# HG changeset patch
# User John W. Eaton <jwe@octave.org> and Mike Miller <mtmiller@ieee.org>
# Date 1424965760 18000
#      Thu Feb 26 10:49:20 2015 -0500
# Node ID 09ed6f7538dddc5e630b1d5badccfc84fffdae89
# Parent  6b851f6acd55adb146a08d87b65c846e998c4f2e
avoid needing to include hdf5 in public header files (bug #44370, #43180)

* oct-hdf5-id.cc, oct-hdf5-id.h: New files.
* libinterp/corefcn/module.mk: Update.

* libgui/src/module.mk (src_libgui_src_la_CPPFLAGS): Remove
$(HDF5_CPPFLAGS) from the list.

* load-save.h (enum load_save_format_type): Always include LS_HDF5
in the list of values.

* ls-hdf5.cc (read_hdf5_data, save_hdf5_data):
Call check_hdf5_id_type.

* oct-hdf5.h: Also #define HDF5_SAVE_TYPE.

* ov.h, ov-base.h: Include oct-hdf5-id.h instead of oct-hdf5.h.
Always declare load_hdf5 and save_hdf5 functions.

* ov-base-int.cc, ov-base-int.h, ov-base.cc, ov-bool-mat.cc,
ov-bool-mat.h, ov-bool-sparse.cc, ov-bool-sparse.h, ov-bool.cc,
ov-bool.h, ov-cell.cc, ov-cell.h, ov-class.cc, ov-class.h,
ov-complex.cc, ov-complex.h, ov-cx-mat.cc, ov-cx-mat.h,
ov-cx-sparse.cc, ov-cx-sparse.h, ov-fcn-handle.cc, ov-fcn-handle.h,
ov-fcn-inline.cc, ov-fcn-inline.h, ov-float.cc, ov-float.h,
ov-flt-complex.cc, ov-flt-complex.h, ov-flt-cx-mat.cc,
ov-flt-cx-mat.h, ov-flt-re-mat.cc, ov-flt-re-mat.h, ov-int16.cc,
ov-int32.cc, ov-int64.cc, ov-int8.cc, ov-lazy-idx.h, ov-oncleanup.cc,
ov-oncleanup.h, ov-range.cc ov-range.h, ov-re-mat.cc, ov-re-mat.h,
ov-re-sparse.cc, ov-re-sparse.h, ov-scalar.cc, ov-scalar.h,
ov-str-mat.cc, ov-str-mat.h, ov-struct.cc, ov-struct.h, ov-uint16.cc,
ov-uint32.cc, ov-uint64.cc, ov-uint8.cc: Move #ifdef HAVE_HDF5 inside
load_hdf5 and save_hdf5 functions.  Always declare and define
load_hdf5 and save_hdf5 functions.

diff --git a/libgui/src/module.mk b/libgui/src/module.mk
--- a/libgui/src/module.mk
+++ b/libgui/src/module.mk
@@ -178,17 +178,16 @@ src_libgui_src_la_SOURCES = \
   src/workspace-view.cc
 
 nodist_src_libgui_src_la_SOURCES = $(octave_gui_MOC) $(octave_gui_RC)
 
 src_libgui_src_la_CPPFLAGS = \
   $(AM_CPPFLAGS) \
   $(FT2_CPPFLAGS) \
   $(FONTCONFIG_CPPFLAGS) \
-  $(HDF5_CPPFLAGS) \
   @OCTGUI_DLL_DEFS@ \
   @QT_CPPFLAGS@ \
   -I$(srcdir)/qterminal/libqterminal \
   -Isrc -I$(srcdir)/src \
   -I$(srcdir)/src/m-editor \
   -I$(srcdir)/src/qtinfo \
   -I$(srcdir)/graphics \
   -I$(top_srcdir)/liboctave/cruft/misc \
diff --git a/libinterp/corefcn/load-save.h b/libinterp/corefcn/load-save.h
--- a/libinterp/corefcn/load-save.h
+++ b/libinterp/corefcn/load-save.h
@@ -36,19 +36,17 @@ class octave_value;
 enum load_save_format_type
 {
   LS_ASCII,
   LS_BINARY,
   LS_MAT_ASCII,
   LS_MAT_BINARY,
   LS_MAT5_BINARY,
   LS_MAT7_BINARY,
-#ifdef HAVE_HDF5
   LS_HDF5,
-#endif /* HAVE_HDF5 */
   LS_UNKNOWN
 };
 
 enum load_save_format_options
 {
   // LS_MAT_ASCII options (not exclusive)
   LS_MAT_ASCII_LONG = 1,
   LS_MAT_ASCII_TABS = 2,
diff --git a/libinterp/corefcn/ls-hdf5.cc b/libinterp/corefcn/ls-hdf5.cc
--- a/libinterp/corefcn/ls-hdf5.cc
+++ b/libinterp/corefcn/ls-hdf5.cc
@@ -50,16 +50,17 @@ along with Octave; see the file COPYING.
 #include "str-vec.h"
 #include "oct-locbuf.h"
 
 #include "Cell.h"
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "load-save.h"
+#include "oct-hdf5-id.h"
 #include "oct-obj.h"
 #include "oct-map.h"
 #include "ov-cell.h"
 #include "pager.h"
 #include "pt-exp.h"
 #include "sysdep.h"
 #include "unwind-prot.h"
 #include "utils.h"
@@ -582,16 +583,18 @@ done:
 // in doc, and whether it is global in global.  The return value is
 // the name of the variable, or NULL if none were found or there was
 // and error.
 std::string
 read_hdf5_data (std::istream& is, const std::string& /* filename */,
                 bool& global, octave_value& tc, std::string& doc,
                 const string_vector& argv, int argv_idx, int argc)
 {
+  check_hdf5_id_type ();
+
   std::string retval;
 
   doc.resize (0);
 
   hdf5_ifstream& hs = dynamic_cast<hdf5_ifstream&> (is);
   hdf5_callback_data d;
 
   herr_t H5Giterate_retval = -1;
@@ -947,15 +950,17 @@ error_cleanup:
 // Write data from TC in HDF5 (binary) format to the stream OS,
 // which must be an hdf5_ofstream, returning true on success.
 
 bool
 save_hdf5_data (std::ostream& os, const octave_value& tc,
                 const std::string& name, const std::string& doc,
                 bool mark_as_global, bool save_as_floats)
 {
+  check_hdf5_id_type ();
+
   hdf5_ofstream& hs = dynamic_cast<hdf5_ofstream&> (os);
 
   return add_hdf5_data (hs.file_id, tc, name, doc,
                         mark_as_global, save_as_floats);
 }
 
 #endif
diff --git a/libinterp/corefcn/module.mk b/libinterp/corefcn/module.mk
--- a/libinterp/corefcn/module.mk
+++ b/libinterp/corefcn/module.mk
@@ -77,16 +77,17 @@ COREFCN_INC = \
   corefcn/ls-oct-binary.h \
   corefcn/ls-utils.h \
   corefcn/mex.h \
   corefcn/mexproto.h \
   corefcn/oct-errno.h \
   corefcn/oct-fstrm.h \
   corefcn/oct-handle.h \
   corefcn/oct-hdf5.h \
+  corefcn/oct-hdf5-id.h \
   corefcn/oct-hist.h \
   corefcn/oct-iostrm.h \
   corefcn/oct-lvalue.h \
   corefcn/oct-map.h \
   corefcn/oct-obj.h \
   corefcn/oct-prcstrm.h \
   corefcn/oct-procbuf.h \
   corefcn/oct-stdstrm.h \
@@ -207,16 +208,17 @@ COREFCN_SRC = \
   corefcn/mappers.cc \
   corefcn/matrix_type.cc \
   corefcn/max.cc \
   corefcn/md5sum.cc \
   corefcn/mex.cc \
   corefcn/mgorth.cc \
   corefcn/nproc.cc \
   corefcn/oct-fstrm.cc \
+  corefcn/oct-hdf5-id.cc \
   corefcn/oct-hist.cc \
   corefcn/oct-iostrm.cc \
   corefcn/oct-lvalue.cc \
   corefcn/oct-map.cc \
   corefcn/oct-obj.cc \
   corefcn/oct-prcstrm.cc \
   corefcn/oct-procbuf.cc \
   corefcn/oct-stream.cc \
diff --git a/libinterp/corefcn/oct-hdf5-id.cc b/libinterp/corefcn/oct-hdf5-id.cc
new file mode 100644
--- /dev/null
+++ b/libinterp/corefcn/oct-hdf5-id.cc
@@ -0,0 +1,56 @@
+/*
+
+Copyright (C) 2015 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "error.h"
+#include "oct-hdf5.h"
+#include "oct-hdf5-id.h"
+
+bool
+check_hdf5_id_type (bool warn)
+{
+  static bool checked = false;
+  static bool ok = false;
+
+  if (! checked)
+    {
+#if defined (HAVE_HDF5)
+      ok = sizeof (octave_hdf5_id) >= sizeof (hid_t);
+
+      if (warn && ! ok)
+        warning_with_id
+          ("Octave:internal",
+           "the size of octave_hdf5_id is smaller than the size of HDF5 hid_t");
+#else
+      warning_with_id
+        ("Octave:internal",
+         "check_hdf5_id_type called but Octave was not compiled with support for HDF5");
+#endif
+
+      checked = true;
+    }
+
+  return ok;
+}
diff --git a/libinterp/corefcn/oct-hdf5-id.h b/libinterp/corefcn/oct-hdf5-id.h
new file mode 100644
--- /dev/null
+++ b/libinterp/corefcn/oct-hdf5-id.h
@@ -0,0 +1,30 @@
+/*
+
+Copyright (C) 2015 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#if !defined (octave_oct_hdf5_id_h)
+#define octave_oct_hdf5_id_h 1
+
+typedef int octave_hdf5_id;
+
+extern bool check_hdf5_id_type (bool warn = true);
+
+#endif
diff --git a/libinterp/corefcn/oct-hdf5.h b/libinterp/corefcn/oct-hdf5.h
--- a/libinterp/corefcn/oct-hdf5.h
+++ b/libinterp/corefcn/oct-hdf5.h
@@ -19,12 +19,16 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_oct_hdf5_h)
 #define octave_hdf5_h 1
 
 #if defined (HAVE_HDF5_H)
+
 #include <hdf5.h>
+
+#define HDF5_SAVE_TYPE H5T_NATIVE_UINT8
+
 #endif
 
 #endif
diff --git a/libinterp/octave-value/ov-base-int.cc b/libinterp/octave-value/ov-base-int.cc
--- a/libinterp/octave-value/ov-base-int.cc
+++ b/libinterp/octave-value/ov-base-int.cc
@@ -33,16 +33,17 @@ along with Octave; see the file COPYING.
 #include "mx-base.h"
 #include "quit.h"
 #include "oct-locbuf.h"
 
 #include "defun.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "oct-lvalue.h"
+#include "oct-hdf5.h"
 #include "oct-stream.h"
 #include "ops.h"
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "ov-base-mat.cc"
 #include "ov-base-scalar.h"
 #include "ov-base-scalar.cc"
 #include "ov-base-int.h"
@@ -328,24 +329,25 @@ octave_base_int_matrix<T>::load_binary (
             break;
           }
     }
 
   this->matrix = m;
   return true;
 }
 
-#if defined (HAVE_HDF5)
-
 template <class T>
 bool
-octave_base_int_matrix<T>::save_hdf5 (hid_t loc_id, const char *name, bool)
+octave_base_int_matrix<T>::save_hdf5 (octave_hdf5_id loc_id, const char *name, bool)
 {
+  bool retval = false;
+
+#if defined (HAVE_HDF5)
+
   hid_t save_type_hid = HDF5_SAVE_TYPE;
-  bool retval = true;
   dim_vector dv = this->dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   int rank = dv.length ();
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
@@ -372,25 +374,32 @@ octave_base_int_matrix<T>::save_hdf5 (hi
     }
 
   retval = H5Dwrite (data_hid, save_type_hid, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, this->matrix.data ()) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
+#else
+  gripe_save ("hdf5");
+#endif
+
   return retval;
 }
 
 template <class T>
 bool
-octave_base_int_matrix<T>::load_hdf5 (hid_t loc_id, const char *name)
+octave_base_int_matrix<T>::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
+  bool retval = false;
+
+#if defined (HAVE_HDF5)
+
   hid_t save_type_hid = HDF5_SAVE_TYPE;
-  bool retval = false;
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     this->matrix.resize (dv);
   if (empty)
     return (empty > 0);
 
 #if HAVE_HDF5_18
@@ -434,21 +443,23 @@ octave_base_int_matrix<T>::load_hdf5 (hi
     {
       retval = true;
       this->matrix = m;
     }
 
   H5Sclose (space_id);
   H5Dclose (data_hid);
 
+#else
+  gripe_load ("hdf5");
+#endif
+
   return retval;
 }
 
-#endif
-
 template <class T>
 void
 octave_base_int_matrix<T>::print_raw (std::ostream& os,
                                       bool pr_as_read_syntax) const
 {
   octave_print_internal (os, this->matrix, pr_as_read_syntax,
                          this->current_print_indent_level ());
 }
@@ -537,24 +548,25 @@ octave_base_int_scalar<T>::load_binary (
       case 1:
       default:
         break;
       }
   this->scalar = tmp;
   return true;
 }
 
-#if defined (HAVE_HDF5)
-
 template <class T>
 bool
-octave_base_int_scalar<T>::save_hdf5 (hid_t loc_id, const char *name, bool)
+octave_base_int_scalar<T>::save_hdf5 (octave_hdf5_id loc_id, const char *name, bool)
 {
+  bool retval = false;
+
+#if defined (HAVE_HDF5)
+
   hid_t save_type_hid = HDF5_SAVE_TYPE;
-  bool retval = true;
   hsize_t dimens[3];
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0) return false;
 
 #if HAVE_HDF5_18
@@ -571,23 +583,29 @@ octave_base_int_scalar<T>::save_hdf5 (hi
     }
 
   retval = H5Dwrite (data_hid, save_type_hid, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, &(this->scalar)) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
+#else
+  gripe_save ("hdf5");
+#endif
+
   return retval;
 }
 
 template <class T>
 bool
-octave_base_int_scalar<T>::load_hdf5 (hid_t loc_id, const char *name)
+octave_base_int_scalar<T>::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
+#if defined (HAVE_HDF5)
+
   hid_t save_type_hid = HDF5_SAVE_TYPE;
 #if HAVE_HDF5_18
   hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
   hid_t space_id = H5Dget_space (data_hid);
 
@@ -607,11 +625,15 @@ octave_base_int_scalar<T>::load_hdf5 (hi
       return false;
     }
 
   this->scalar = tmp;
 
   H5Dclose (data_hid);
 
   return true;
+
+#else
+  gripe_load ("hdf5");
+  return false;
+#endif
 }
 
-#endif
diff --git a/libinterp/octave-value/ov-base-int.h b/libinterp/octave-value/ov-base-int.h
--- a/libinterp/octave-value/ov-base-int.h
+++ b/libinterp/octave-value/ov-base-int.h
@@ -73,21 +73,19 @@ public:
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool&);
 
   bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format);
 
-#if defined (HAVE_HDF5)
-  bool save_hdf5 (hid_t loc_id, const char *name, bool);
+  bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool);
 
-  bool load_hdf5 (hid_t loc_id, const char *name);
-#endif
+  bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 };
 
 // base int scalar values.
 
 template <class T>
 class
 octave_base_int_scalar : public octave_base_scalar<T>
 {
@@ -118,16 +116,14 @@ public:
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool&);
 
   bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format);
 
-#if defined (HAVE_HDF5)
-  bool save_hdf5 (hid_t loc_id, const char *name, bool);
+  bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool);
 
-  bool load_hdf5 (hid_t loc_id, const char *name);
-#endif
+  bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 };
 
 #endif
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -31,16 +31,17 @@ along with Octave; see the file COPYING.
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 
 #include "defun.h"
 #include "gripes.h"
 #include "mxarray.h"
 #include "oct-map.h"
 #include "oct-obj.h"
+#include "oct-hdf5.h"
 #include "oct-lvalue.h"
 #include "oct-stream.h"
 #include "ops.h"
 #include "ov-base.h"
 #include "ov-cell.h"
 #include "ov-ch-mat.h"
 #include "ov-complex.h"
 #include "ov-cx-mat.h"
@@ -1085,36 +1086,32 @@ octave_base_value::save_binary (std::ost
 bool
 octave_base_value::load_binary (std::istream&, bool,
                                 oct_mach_info::float_format)
 {
   gripe_wrong_type_arg ("octave_base_value::load_binary()", type_name ());
   return false;
 }
 
-#if defined (HAVE_HDF5)
-
 bool
-octave_base_value::save_hdf5 (hid_t, const char *, bool)
+octave_base_value::save_hdf5 (octave_hdf5_id, const char *, bool)
 {
   gripe_wrong_type_arg ("octave_base_value::save_binary()", type_name ());
 
   return false;
 }
 
 bool
-octave_base_value::load_hdf5 (hid_t, const char *)
+octave_base_value::load_hdf5 (octave_hdf5_id, const char *)
 {
   gripe_wrong_type_arg ("octave_base_value::load_binary()", type_name ());
 
   return false;
 }
 
-#endif
-
 int
 octave_base_value::write (octave_stream&, int, oct_data_conv::data_type,
                           int, oct_mach_info::float_format) const
 {
   gripe_wrong_type_arg ("octave_base_value::write()", type_name ());
 
   return false;
 }
@@ -1252,16 +1249,34 @@ octave_base_value::get_umap_name (unary_
   };
 
   if (umap < 0 || umap >= num_unary_mappers)
     return "unknown";
   else
     return names[umap];
 }
 
+void
+octave_base_value::gripe_load (const char *type) const
+{
+  warning_with_id
+    ("Octave:load-save-unavailable",
+     "%s: loading %s files not available in this version of Octave",
+     t_name.c_str (), type);
+}
+
+void
+octave_base_value::gripe_save (const char *type) const
+{
+  warning_with_id
+    ("Octave:load-save-unavailable",
+     "%s: saving %s files not available in this version of Octave",
+     t_name.c_str (), type);
+}
+
 octave_value
 octave_base_value::map (unary_mapper_t umap) const
 {
   error ("%s: not defined for %s", get_umap_name (umap), type_name ().c_str ());
   return octave_value ();
 }
 
 void
diff --git a/libinterp/octave-value/ov-base.h b/libinterp/octave-value/ov-base.h
--- a/libinterp/octave-value/ov-base.h
+++ b/libinterp/octave-value/ov-base.h
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 #include <string>
 
 #include "Range.h"
 #include "data-conv.h"
 #include "mx-base.h"
 #include "str-vec.h"
 
 #include "error.h"
-#include "oct-hdf5.h"
+#include "oct-hdf5-id.h"
 
 class Cell;
 class mxArray;
 class octave_map;
 class octave_scalar_map;
 class octave_value;
 class octave_value_list;
 class octave_stream;
@@ -631,23 +631,21 @@ public:
 
   virtual bool load_ascii (std::istream& is);
 
   virtual bool save_binary (std::ostream& os, bool& save_as_floats);
 
   virtual bool load_binary (std::istream& is, bool swap,
                             oct_mach_info::float_format fmt);
 
-#if defined (HAVE_HDF5)
   virtual bool
-  save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
+  save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   virtual bool
-  load_hdf5 (hid_t loc_id, const char *name);
-#endif
+  load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   virtual int
   write (octave_stream& os, int block_size,
          oct_data_conv::data_type output_type, int skip,
          oct_mach_info::float_format flt_fmt) const;
 
   virtual void *mex_get_data (void) const { return 0; }
 
@@ -816,16 +814,19 @@ protected:
   // A reference count.
   // NOTE: the declaration is octave_idx_type because with 64-bit indexing,
   // it is well possible to have more than MAX_INT copies of a single value
   // (think of an empty cell array with >2G elements).
   octave_refcount<octave_idx_type> count;
 
   static const char *get_umap_name (unary_mapper_t);
 
+  void gripe_load (const char *type) const;
+  void gripe_save (const char *type) const;
+
 private:
 
   static int curr_print_indent_level;
   static bool beginning_of_line;
 
   DECLARE_OV_BASE_TYPEID_FUNCTIONS_AND_DATA
 };
 
diff --git a/libinterp/octave-value/ov-bool-mat.cc b/libinterp/octave-value/ov-bool-mat.cc
--- a/libinterp/octave-value/ov-bool-mat.cc
+++ b/libinterp/octave-value/ov-bool-mat.cc
@@ -31,16 +31,17 @@ along with Octave; see the file COPYING.
 #include "lo-ieee.h"
 #include "mx-base.h"
 #include "oct-locbuf.h"
 
 #include "defun.h"
 #include "gripes.h"
 #include "mxarray.h"
 #include "oct-obj.h"
+#include "oct-hdf5.h"
 #include "ops.h"
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "ov-base-mat.cc"
 #include "ov-bool.h"
 #include "ov-bool-mat.h"
 #include "ov-re-mat.h"
 #include "pr-output.h"
@@ -403,31 +404,32 @@ octave_bool_matrix::load_binary (std::is
   bool *mtmp = m.fortran_vec ();
   for (octave_idx_type i = 0; i < nel; i++)
     mtmp[i] = (htmp[i] ? 1 : 0);
   matrix = m;
 
   return true;
 }
 
+bool
+octave_bool_matrix::save_hdf5 (octave_hdf5_id loc_id, const char *name,
+                               bool /* save_as_floats */)
+{
+  bool retval = true;
+
 #if defined (HAVE_HDF5)
 
-bool
-octave_bool_matrix::save_hdf5 (hid_t loc_id, const char *name,
-                               bool /* save_as_floats */)
-{
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   int rank = dv.length ();
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
-  bool retval = true;
   boolNDArray m = bool_array_value ();
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
     hdims[i] = dv (rank-i-1);
 
@@ -454,24 +456,30 @@ octave_bool_matrix::save_hdf5 (hid_t loc
     htmp[i] = mtmp[i];
 
   retval = H5Dwrite (data_hid, H5T_NATIVE_HBOOL, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, htmp) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
+#else
+  gripe_save ("hdf5");
+#endif
+
   return retval;
 }
 
 bool
-octave_bool_matrix::load_hdf5 (hid_t loc_id, const char *name)
+octave_bool_matrix::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
   bool retval = false;
 
+#if defined (HAVE_HDF5)
+
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize (dv);
   if (empty)
     return (empty > 0);
 
 #if HAVE_HDF5_18
@@ -519,21 +527,23 @@ octave_bool_matrix::load_hdf5 (hid_t loc
       for (octave_idx_type i = 0; i < nel; i++)
         btmp.elem (i) = htmp[i];
 
       matrix = btmp;
     }
 
   H5Dclose (data_hid);
 
+#else
+  gripe_load ("hdf5");
+#endif
+
   return retval;
 }
 
-#endif
-
 mxArray *
 octave_bool_matrix::as_mxArray (void) const
 {
   mxArray *retval = new mxArray (mxLOGICAL_CLASS, dims (), mxREAL);
 
   bool *pr = static_cast<bool *> (retval->get_data ());
 
   mwSize nel = numel ();
diff --git a/libinterp/octave-value/ov-bool-mat.h b/libinterp/octave-value/ov-bool-mat.h
--- a/libinterp/octave-value/ov-bool-mat.h
+++ b/libinterp/octave-value/ov-bool-mat.h
@@ -200,21 +200,19 @@ public:
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
-#if defined (HAVE_HDF5)
-  bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
+  bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name);
-#endif
+  bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              oct_mach_info::float_format flt_fmt) const
   { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
diff --git a/libinterp/octave-value/ov-bool-sparse.cc b/libinterp/octave-value/ov-bool-sparse.cc
--- a/libinterp/octave-value/ov-bool-sparse.cc
+++ b/libinterp/octave-value/ov-bool-sparse.cc
@@ -35,16 +35,18 @@ along with Octave; see the file COPYING.
 #include "ov-base.h"
 #include "ov-scalar.h"
 #include "ov-bool.h"
 #include "ov-bool-mat.h"
 #include "gripes.h"
 #include "ops.h"
 #include "oct-locbuf.h"
 
+#include "oct-hdf5.h"
+
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 #include "ov-bool-sparse.h"
 
 #include "ov-base-sparse.h"
 #include "ov-base-sparse.cc"
 
 template class OCTINTERP_API octave_base_sparse<SparseBoolMatrix>;
@@ -331,21 +333,23 @@ octave_sparse_bool_matrix::load_binary (
   if (! m.indices_ok ())
     return false;
 
   matrix = m;
 
   return true;
 }
 
+bool
+octave_sparse_bool_matrix::save_hdf5 (octave_hdf5_id loc_id, const char *name, bool)
+{
+  bool retval = false;
+
 #if defined (HAVE_HDF5)
 
-bool
-octave_sparse_bool_matrix::save_hdf5 (hid_t loc_id, const char *name, bool)
-{
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
 #if HAVE_HDF5_18
@@ -354,17 +358,16 @@ octave_sparse_bool_matrix::save_hdf5 (hi
 #else
   hid_t group_hid = H5Gcreate (loc_id, name, 0);
 #endif
   if (group_hid < 0)
     return false;
 
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
-  bool retval = true;
   SparseBoolMatrix m = sparse_bool_matrix_value ();
   octave_idx_type tmp;
   hsize_t hdims[2];
 
   space_hid = H5Screate_simple (0, hdims, 0);
   if (space_hid < 0)
     {
       H5Gclose (group_hid);
@@ -540,22 +543,30 @@ octave_sparse_bool_matrix::save_hdf5 (hi
     htmp[i] = m.xdata(i);
 
   retval = H5Dwrite (data_hid, H5T_NATIVE_HBOOL, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, htmp) >= 0;
   H5Dclose (data_hid);
   H5Sclose (space_hid);
   H5Gclose (group_hid);
 
+#else
+  gripe_save ("hdf5");
+#endif
+  
   return retval;
 }
 
 bool
-octave_sparse_bool_matrix::load_hdf5 (hid_t loc_id, const char *name)
+octave_sparse_bool_matrix::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
+  bool retval = false;
+
+#if defined (HAVE_HDF5)
+
   octave_idx_type nr, nc, nz;
   hid_t group_hid, data_hid, space_hid;
   hsize_t rank;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize (dv);
@@ -754,38 +765,40 @@ octave_sparse_bool_matrix::load_hdf5 (hi
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   OCTAVE_LOCAL_BUFFER (hbool_t, htmp, nz);
-  bool retval = false;
+
   if (H5Dread (data_hid, H5T_NATIVE_HBOOL, H5S_ALL, H5S_ALL,
                H5P_DEFAULT, htmp) >= 0
       && m.indices_ok ())
     {
       retval = true;
 
       for (int i = 0; i < nz; i++)
         m.xdata(i) = htmp[i];
 
       matrix = m;
     }
 
   H5Sclose (space_hid);
   H5Dclose (data_hid);
   H5Gclose (group_hid);
 
+#else
+  gripe_load ("hdf5");
+#endif
+
   return retval;
 }
 
-#endif
-
 mxArray *
 octave_sparse_bool_matrix::as_mxArray (void) const
 {
   mwSize nz = nzmax ();
   mxArray *retval = new mxArray (mxLOGICAL_CLASS, rows (), columns (),
                                  nz, mxREAL);
   bool *pr = static_cast<bool *> (retval->get_data ());
   mwIndex *ir = retval->get_ir ();
diff --git a/libinterp/octave-value/ov-bool-sparse.h b/libinterp/octave-value/ov-bool-sparse.h
--- a/libinterp/octave-value/ov-bool-sparse.h
+++ b/libinterp/octave-value/ov-bool-sparse.h
@@ -130,21 +130,19 @@ public:
 
   octave_value convert_to_str_internal (bool pad, bool force, char type) const;
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
-#if defined (HAVE_HDF5)
-  bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
+  bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name);
-#endif
+  bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   mxArray *as_mxArray (void) const;
 
   // Mapper functions are converted to double for treatment
   octave_value map (unary_mapper_t umap) const
   {
     octave_sparse_matrix m (sparse_matrix_value ());
     return m.map (umap);
diff --git a/libinterp/octave-value/ov-bool.cc b/libinterp/octave-value/ov-bool.cc
--- a/libinterp/octave-value/ov-bool.cc
+++ b/libinterp/octave-value/ov-bool.cc
@@ -25,16 +25,17 @@ along with Octave; see the file COPYING.
 #endif
 
 #include <iostream>
 
 #include "mx-base.h"
 
 #include "gripes.h"
 #include "mxarray.h"
+#include "oct-hdf5.h"
 #include "oct-obj.h"
 #include "ops.h"
 #include "ov-bool.h"
 #include "ov-bool-mat.h"
 #include "ov-base.h"
 #include "ov-base-scalar.h"
 #include "ov-base-scalar.cc"
 #include "ov-re-mat.h"
@@ -152,26 +153,27 @@ octave_bool::load_binary (std::istream& 
 {
   char tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), 1))
     return false;
   scalar = (tmp ? 1 : 0);
   return true;
 }
 
+bool
+octave_bool::save_hdf5 (octave_hdf5_id loc_id, const char *name,
+                        bool /* save_as_floats */)
+{
+  bool retval = false;
+
 #if defined (HAVE_HDF5)
 
-bool
-octave_bool::save_hdf5 (hid_t loc_id, const char *name,
-                        bool /* save_as_floats */)
-{
   hsize_t dimens[3];
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
-  bool retval = true;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0) return false;
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_DOUBLE, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_DOUBLE, space_hid,
@@ -185,22 +187,28 @@ octave_bool::save_hdf5 (hid_t loc_id, co
 
   double tmp = double_value ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, &tmp) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
+#else
+  gripe_save ("hdf5");
+#endif
+
   return retval;
 }
 
 bool
-octave_bool::load_hdf5 (hid_t loc_id, const char *name)
+octave_bool::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
+#if defined (HAVE_HDF5)
+
 #if HAVE_HDF5_18
   hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
   hid_t space_id = H5Dget_space (data_hid);
 
   hsize_t rank = H5Sget_simple_extent_ndims (space_id);
@@ -218,21 +226,23 @@ octave_bool::load_hdf5 (hid_t loc_id, co
       H5Dclose (data_hid);
       return false;
     }
 
   scalar = (dtmp != 0.);
 
   H5Dclose (data_hid);
 
+#else
+  gripe_load ("hdf5");
+#endif
+
   return true;
 }
 
-#endif
-
 mxArray *
 octave_bool::as_mxArray (void) const
 {
   mxArray *retval = new mxArray (mxLOGICAL_CLASS, 1, 1, mxREAL);
 
   bool *pr = static_cast<bool *> (retval->get_data ());
 
   pr[0] = scalar;
diff --git a/libinterp/octave-value/ov-bool.h b/libinterp/octave-value/ov-bool.h
--- a/libinterp/octave-value/ov-bool.h
+++ b/libinterp/octave-value/ov-bool.h
@@ -213,21 +213,19 @@ public:
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
-#if defined (HAVE_HDF5)
-  bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
+  bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name);
-#endif
+  bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              oct_mach_info::float_format flt_fmt) const
   {
     return os.write (bool_array_value (), block_size, output_type,
                      skip, flt_fmt);
   }
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -37,16 +37,17 @@ along with Octave; see the file COPYING.
 #include "quit.h"
 #include "oct-locbuf.h"
 
 #include "defun.h"
 #include "error.h"
 #include "mxarray.h"
 #include "ov-cell.h"
 #include "oct-obj.h"
+#include "oct-hdf5.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "ov-base-mat.h"
 #include "ov-base-mat.cc"
 #include "ov-re-mat.h"
 #include "ov-scalar.h"
 #include "pr-output.h"
 #include "ov-scalar.h"
@@ -1060,21 +1061,21 @@ octave_cell::load_binary (std::istream& 
 
 void *
 octave_cell::mex_get_data (void) const
 {
   clear_cellstr_cache ();
   return matrix.mex_get_data ();
 }
 
+bool
+octave_cell::save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats)
+{
 #if defined (HAVE_HDF5)
 
-bool
-octave_cell::save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats)
-{
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   hsize_t rank = dv.length ();
   hid_t space_hid, data_hid, size_hid;
   space_hid = data_hid = size_hid = -1;
@@ -1151,25 +1152,32 @@ octave_cell::save_hdf5 (hid_t loc_id, co
           H5Gclose (data_hid);
           return false;
         }
     }
 
   H5Gclose (data_hid);
 
   return true;
+
+#else
+  gripe_save ("hdf5");
+  return false;
+#endif
 }
 
 bool
-octave_cell::load_hdf5 (hid_t loc_id, const char *name)
+octave_cell::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
+  bool retval = false;
+
+#if defined (HAVE_HDF5)
+
   clear_cellstr_cache ();
 
-  bool retval = false;
-
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize (dv);
   if (empty)
     return (empty > 0);
 
 #if HAVE_HDF5_18
@@ -1255,21 +1263,23 @@ octave_cell::load_hdf5 (hid_t loc_id, co
     }
 
   if (retval2 >= 0)
     {
       matrix = m;
       retval = true;
     }
 
+#else
+  gripe_load ("hdf5");
+#endif
+
   return retval;
 }
 
-#endif
-
 DEFUN (iscell, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} iscell (@var{x})\n\
 Return true if @var{x} is a cell array object.\n\
 @seealso{ismatrix, isstruct, iscellstr, isa}\n\
 @end deftypefn")
 {
   octave_value retval;
diff --git a/libinterp/octave-value/ov-cell.h b/libinterp/octave-value/ov-cell.h
--- a/libinterp/octave-value/ov-cell.h
+++ b/libinterp/octave-value/ov-cell.h
@@ -156,21 +156,19 @@ public:
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
-#if defined (HAVE_HDF5)
-  bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
+  bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name);
-#endif
+  bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   octave_value map (unary_mapper_t umap) const;
 
   mxArray *as_mxArray (void) const;
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
   void *mex_get_data (void) const;
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -39,16 +39,17 @@ along with Octave; see the file COPYING.
 #include "gripes.h"
 #include "load-path.h"
 #include "ls-hdf5.h"
 #include "ls-oct-ascii.h"
 #include "ls-oct-binary.h"
 #include "ls-utils.h"
 #include "mxarray.h"
 #include "oct-lvalue.h"
+#include "oct-hdf5.h"
 #include "ov-class.h"
 #ifdef HAVE_JAVA
 #include "ov-java.h"
 #endif
 #include "ov-fcn.h"
 #include "ov-usr-fcn.h"
 #include "pager.h"
 #include "parse.h"
@@ -1500,21 +1501,21 @@ octave_class::load_binary (std::istream&
   else if (len == 0)
     map = octave_map (dim_vector (1, 1));
   else
     panic_impossible ();
 
   return success;
 }
 
+bool
+octave_class::save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats)
+{
 #if defined (HAVE_HDF5)
 
-bool
-octave_class::save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats)
-{
   hsize_t hdims[3];
   hid_t group_hid = -1;
   hid_t type_hid = -1;
   hid_t space_hid = -1;
   hid_t class_hid = -1;
   hid_t data_hid = -1;
   octave_map m;
   octave_map::iterator i;
@@ -1596,23 +1597,30 @@ error_cleanup:
 
   if (type_hid > 0)
     H5Tclose (type_hid);
 
   if (group_hid > 0)
     H5Gclose (group_hid);
 
   return true;
+
+#else
+  gripe_save ("hdf5");
+  return false;
+#endif
 }
 
 bool
-octave_class::load_hdf5 (hid_t loc_id, const char *name)
+octave_class::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
   bool retval = false;
 
+#if defined (HAVE_HDF5)
+
   hid_t group_hid = -1;
   hid_t data_hid = -1;
   hid_t type_hid = -1;
   hid_t type_class_hid = -1;
   hid_t space_hid = -1;
   hid_t subgroup_hid = -1;
   hid_t st_id = -1;
 
@@ -1736,21 +1744,23 @@ octave_class::load_hdf5 (hid_t loc_id, c
 
 error_cleanup:
   if (data_hid > 0)
     H5Dclose (data_hid);
 
   if (data_hid > 0)
     H5Gclose (group_hid);
 
+#else
+  gripe_load ("hdf5");
+#endif
+
   return retval;
 }
 
-#endif
-
 mxArray *
 octave_class::as_mxArray (void) const
 {
   gripe_wrong_type_arg ("octave_class::as_mxArray ()", type_name ());
 
   return 0;
 }
 
diff --git a/libinterp/octave-value/ov-class.h b/libinterp/octave-value/ov-class.h
--- a/libinterp/octave-value/ov-class.h
+++ b/libinterp/octave-value/ov-class.h
@@ -189,21 +189,19 @@ public:
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
-#if defined (HAVE_HDF5)
-  bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
+  bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name);
-#endif
+  bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   mxArray *as_mxArray (void) const;
 
 private:
 
   octave_map map;
 
 
diff --git a/libinterp/octave-value/ov-complex.cc b/libinterp/octave-value/ov-complex.cc
--- a/libinterp/octave-value/ov-complex.cc
+++ b/libinterp/octave-value/ov-complex.cc
@@ -27,16 +27,17 @@ along with Octave; see the file COPYING.
 #include <iostream>
 
 #include "lo-ieee.h"
 #include "lo-specfun.h"
 #include "lo-mappers.h"
 
 #include "mxarray.h"
 #include "oct-obj.h"
+#include "oct-hdf5.h"
 #include "oct-stream.h"
 #include "ops.h"
 #include "ov-complex.h"
 #include "ov-flt-complex.h"
 #include "ov-base.h"
 #include "ov-base-scalar.h"
 #include "ov-base-scalar.cc"
 #include "ov-cx-mat.h"
@@ -302,26 +303,27 @@ octave_complex::load_binary (std::istrea
                 static_cast<save_type> (tmp), 2, swap, fmt);
   if (error_state || ! is)
     return false;
 
   scalar = ctmp;
   return true;
 }
 
+bool
+octave_complex::save_hdf5 (octave_hdf5_id loc_id, const char *name,
+                           bool /* save_as_floats */)
+{
+  bool retval = false;
+
 #if defined (HAVE_HDF5)
 
-bool
-octave_complex::save_hdf5 (hid_t loc_id, const char *name,
-                           bool /* save_as_floats */)
-{
   hsize_t dimens[3];
   hid_t space_hid, type_hid, data_hid;
   space_hid = type_hid = data_hid = -1;
-  bool retval = true;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0)
     return false;
 
   type_hid = hdf5_make_complex_type (H5T_NATIVE_DOUBLE);
   if (type_hid < 0)
     {
@@ -344,23 +346,30 @@ octave_complex::save_hdf5 (hid_t loc_id,
   Complex tmp = complex_value ();
   retval = H5Dwrite (data_hid, type_hid, H5S_ALL, H5S_ALL, H5P_DEFAULT,
                      &tmp) >= 0;
 
   H5Dclose (data_hid);
   H5Tclose (type_hid);
   H5Sclose (space_hid);
 
+#else
+  gripe_save ("hdf5");
+#endif
+
   return retval;
 }
 
 bool
-octave_complex::load_hdf5 (hid_t loc_id, const char *name)
+octave_complex::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
   bool retval = false;
+
+#if defined (HAVE_HDF5)
+
 #if HAVE_HDF5_18
   hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
   hid_t type_hid = H5Dget_type (data_hid);
 
   hid_t complex_type = hdf5_make_complex_type (H5T_NATIVE_DOUBLE);
@@ -391,21 +400,23 @@ octave_complex::load_hdf5 (hid_t loc_id,
       retval = true;
       scalar = ctmp;
     }
 
   H5Tclose (complex_type);
   H5Sclose (space_id);
   H5Dclose (data_hid);
 
+#else
+  gripe_load ("hdf5");
+#endif
+
   return retval;
 }
 
-#endif
-
 mxArray *
 octave_complex::as_mxArray (void) const
 {
   mxArray *retval = new mxArray (mxDOUBLE_CLASS, 1, 1, mxCOMPLEX);
 
   double *pr = static_cast<double *> (retval->get_data ());
   double *pi = static_cast<double *> (retval->get_imag_data ());
 
diff --git a/libinterp/octave-value/ov-complex.h b/libinterp/octave-value/ov-complex.h
--- a/libinterp/octave-value/ov-complex.h
+++ b/libinterp/octave-value/ov-complex.h
@@ -171,21 +171,19 @@ public:
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
-#if defined (HAVE_HDF5)
-  bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
+  bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name);
-#endif
+  bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              oct_mach_info::float_format flt_fmt) const
   {
     // Yes, for compatibility, we drop the imaginary part here.
     return os.write (array_value (true), block_size, output_type,
                      skip, flt_fmt);
diff --git a/libinterp/octave-value/ov-cx-mat.cc b/libinterp/octave-value/ov-cx-mat.cc
--- a/libinterp/octave-value/ov-cx-mat.cc
+++ b/libinterp/octave-value/ov-cx-mat.cc
@@ -34,16 +34,17 @@ along with Octave; see the file COPYING.
 #include "lo-mappers.h"
 #include "mx-base.h"
 #include "mach-info.h"
 #include "oct-locbuf.h"
 
 #include "gripes.h"
 #include "mxarray.h"
 #include "oct-obj.h"
+#include "oct-hdf5.h"
 #include "oct-stream.h"
 #include "ops.h"
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "ov-base-mat.cc"
 #include "ov-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
@@ -557,22 +558,22 @@ octave_complex_matrix::load_binary (std:
                     static_cast<save_type> (tmp), 2*len, swap, fmt);
       if (error_state || ! is)
         return false;
       matrix = m;
     }
   return true;
 }
 
+bool
+octave_complex_matrix::save_hdf5 (octave_hdf5_id loc_id, const char *name,
+                                  bool save_as_floats)
+{
 #if defined (HAVE_HDF5)
 
-bool
-octave_complex_matrix::save_hdf5 (hid_t loc_id, const char *name,
-                                  bool save_as_floats)
-{
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   int rank = dv.length ();
   hid_t space_hid, data_hid, type_hid;
   space_hid = data_hid = type_hid = -1;
@@ -646,23 +647,30 @@ octave_complex_matrix::save_hdf5 (hid_t 
     }
 
   H5Tclose (complex_type_hid);
   H5Dclose (data_hid);
   H5Tclose (type_hid);
   H5Sclose (space_hid);
 
   return retval;
+
+#else
+  gripe_save ("hdf5");
+  return false;
+#endif
 }
 
 bool
-octave_complex_matrix::load_hdf5 (hid_t loc_id, const char *name)
+octave_complex_matrix::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
   bool retval = false;
 
+#if defined (HAVE_HDF5)
+
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize (dv);
   if (empty)
     return (empty > 0);
 
 #if HAVE_HDF5_18
@@ -720,21 +728,23 @@ octave_complex_matrix::load_hdf5 (hid_t 
       retval = true;
       matrix = m;
     }
 
   H5Tclose (complex_type);
   H5Sclose (space_id);
   H5Dclose (data_hid);
 
+#else
+  gripe_load ("hdf5");
+#endif
+
   return retval;
 }
 
-#endif
-
 void
 octave_complex_matrix::print_raw (std::ostream& os,
                                   bool pr_as_read_syntax) const
 {
   octave_print_internal (os, matrix, pr_as_read_syntax,
                          current_print_indent_level ());
 }
 
diff --git a/libinterp/octave-value/ov-cx-mat.h b/libinterp/octave-value/ov-cx-mat.h
--- a/libinterp/octave-value/ov-cx-mat.h
+++ b/libinterp/octave-value/ov-cx-mat.h
@@ -150,21 +150,19 @@ public:
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
-#if defined (HAVE_HDF5)
-  bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
+  bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name);
-#endif
+  bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              oct_mach_info::float_format flt_fmt) const
   {
     // Yes, for compatibility, we drop the imaginary part here.
     return os.write (matrix_value (true), block_size, output_type,
                      skip, flt_fmt);
diff --git a/libinterp/octave-value/ov-cx-sparse.cc b/libinterp/octave-value/ov-cx-sparse.cc
--- a/libinterp/octave-value/ov-cx-sparse.cc
+++ b/libinterp/octave-value/ov-cx-sparse.cc
@@ -34,16 +34,18 @@ along with Octave; see the file COPYING.
 #include "oct-locbuf.h"
 
 #include "mxarray.h"
 #include "ov-base.h"
 #include "ov-scalar.h"
 #include "ov-complex.h"
 #include "gripes.h"
 
+#include "oct-hdf5.h"
+
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 
 #include "ov-base-sparse.h"
 #include "ov-base-sparse.cc"
 
 #include "ov-bool-sparse.h"
 
@@ -361,22 +363,24 @@ octave_sparse_complex_matrix::load_binar
   if (! m.indices_ok ())
     return false;
 
   matrix = m;
 
   return true;
 }
 
+bool
+octave_sparse_complex_matrix::save_hdf5 (octave_hdf5_id loc_id, const char *name,
+                                         bool save_as_floats)
+{
+  bool retval = false;
+
 #if defined (HAVE_HDF5)
 
-bool
-octave_sparse_complex_matrix::save_hdf5 (hid_t loc_id, const char *name,
-                                         bool save_as_floats)
-{
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
 
@@ -386,17 +390,16 @@ octave_sparse_complex_matrix::save_hdf5 
 #else
   hid_t group_hid = H5Gcreate (loc_id, name, 0);
 #endif
   if (group_hid < 0)
     return false;
 
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
-  bool retval = true;
   SparseComplexMatrix m = sparse_complex_matrix_value ();
   octave_idx_type tmp;
   hsize_t hdims[2];
 
   space_hid = H5Screate_simple (0, hdims, 0);
   if (space_hid < 0)
     {
       H5Gclose (group_hid);
@@ -609,22 +612,30 @@ octave_sparse_complex_matrix::save_hdf5 
                          H5P_DEFAULT, ctmp) >= 0;
     }
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
   H5Tclose (type_hid);
   H5Gclose (group_hid);
 
+#else
+  gripe_save ("hdf5");
+#endif
+
   return retval;
 }
 
 bool
-octave_sparse_complex_matrix::load_hdf5 (hid_t loc_id, const char *name)
+octave_sparse_complex_matrix::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
+  bool retval = false;
+
+#if defined (HAVE_HDF5)
+
   octave_idx_type nr, nc, nz;
   hid_t group_hid, data_hid, space_hid;
   hsize_t rank;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize (dv);
@@ -835,35 +846,37 @@ octave_sparse_complex_matrix::load_hdf5 
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   Complex *ctmp = m.xdata ();
-  bool retval = false;
+
   if (H5Dread (data_hid, complex_type, H5S_ALL, H5S_ALL,
                H5P_DEFAULT, ctmp) >= 0
       && m.indices_ok ())
     {
       retval = true;
       matrix = m;
     }
 
   H5Tclose (complex_type);
   H5Sclose (space_hid);
   H5Dclose (data_hid);
   H5Gclose (group_hid);
 
+#else
+  gripe_load ("hdf5");
+#endif
+
   return retval;
 }
 
-#endif
-
 mxArray *
 octave_sparse_complex_matrix::as_mxArray (void) const
 {
   mwSize nz = nzmax ();
   mxArray *retval = new mxArray (mxDOUBLE_CLASS, rows (), columns (),
                                  nz, mxCOMPLEX);
   double *pr = static_cast<double *> (retval->get_data ());
   double *pi = static_cast<double *> (retval->get_imag_data ());
diff --git a/libinterp/octave-value/ov-cx-sparse.h b/libinterp/octave-value/ov-cx-sparse.h
--- a/libinterp/octave-value/ov-cx-sparse.h
+++ b/libinterp/octave-value/ov-cx-sparse.h
@@ -136,21 +136,19 @@ public:
   }
 #endif
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
-#if defined (HAVE_HDF5)
-  bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
+  bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name);
-#endif
+  bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   mxArray *as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
 
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -32,16 +32,17 @@ along with Octave; see the file COPYING.
 
 #include "file-ops.h"
 #include "oct-locbuf.h"
 
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "input.h"
+#include "oct-hdf5.h"
 #include "oct-map.h"
 #include "ov-base.h"
 #include "ov-fcn-handle.h"
 #include "ov-usr-fcn.h"
 #include "pr-output.h"
 #include "pt-pr-code.h"
 #include "pt-misc.h"
 #include "pt-stmt.h"
@@ -699,21 +700,22 @@ octave_fcn_handle::load_binary (std::ist
         }
 
       success = set_fcn (octaveroot, fpath);
     }
 
   return success;
 }
 
-#if defined (HAVE_HDF5)
 bool
-octave_fcn_handle::save_hdf5 (hid_t loc_id, const char *name,
+octave_fcn_handle::save_hdf5 (octave_hdf5_id loc_id, const char *name,
                               bool save_as_floats)
 {
+#if defined (HAVE_HDF5)
+
   bool retval = true;
 
   hid_t group_hid = -1;
 #if HAVE_HDF5_18
   group_hid = H5Gcreate (loc_id, name, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   group_hid = H5Gcreate (loc_id, name, 0);
 #endif
@@ -926,21 +928,28 @@ octave_fcn_handle::save_hdf5 (hid_t loc_
         retval = false;
     }
 
   H5Sclose (space_hid);
   H5Tclose (type_hid);
   H5Gclose (group_hid);
 
   return retval;
+
+#else
+  gripe_save ("hdf5");
+  return false;
+#endif
 }
 
 bool
-octave_fcn_handle::load_hdf5 (hid_t loc_id, const char *name)
+octave_fcn_handle::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
+#if defined (HAVE_HDF5)
+
   bool success = true;
 
   hid_t group_hid, data_hid, space_hid, type_hid, type_class_hid, st_id;
   hsize_t rank;
   int slen;
 
 #if HAVE_HDF5_18
   group_hid = H5Gopen (loc_id, name, H5P_DEFAULT);
@@ -1286,20 +1295,23 @@ octave_fcn_handle::load_hdf5 (hid_t loc_
       success = (success ? set_fcn (octaveroot, fpath) : success);
     }
 
   H5Tclose (type_hid);
   H5Sclose (space_hid);
   H5Gclose (group_hid);
 
   return success;
+
+#else
+  gripe_load ("hdf5");
+  return false;
+#endif
 }
 
-#endif
-
 /*
 %!test
 %! a = 2;
 %! f = @(x) a + x;
 %! g = @(x) 2 * x;
 %! hm = @version;
 %! hdld = @svd;
 %! hbi = @log2;
diff --git a/libinterp/octave-value/ov-fcn-handle.h b/libinterp/octave-value/ov-fcn-handle.h
--- a/libinterp/octave-value/ov-fcn-handle.h
+++ b/libinterp/octave-value/ov-fcn-handle.h
@@ -141,21 +141,19 @@ public:
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
-#if defined (HAVE_HDF5)
-  bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
+  bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name);
-#endif
+  bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   void print (std::ostream& os, bool pr_as_read_syntax = false);
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   // Simple function handles are printed without a newline.
   bool print_as_scalar (void) const { return nm != anonymous; }
 
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -33,16 +33,17 @@ Open Source Initiative (www.opensource.o
 #include <sstream>
 #include <vector>
 
 #include "oct-locbuf.h"
 
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
+#include "oct-hdf5.h"
 #include "oct-map.h"
 #include "ov-base.h"
 #include "ov-fcn-inline.h"
 #include "ov-usr-fcn.h"
 #include "pr-output.h"
 #include "variables.h"
 #include "parse.h"
 #include "toplev.h"
@@ -267,37 +268,40 @@ octave_fcn_inline::load_binary (std::ist
         return false;
 
       octave_fcn_inline ftmp (iftext, ifargs, nm);
       fcn = ftmp.fcn;
     }
   return true;
 }
 
-#if defined (HAVE_HDF5)
 bool
-octave_fcn_inline::save_hdf5 (hid_t loc_id, const char *name,
+octave_fcn_inline::save_hdf5 (octave_hdf5_id loc_id, const char *name,
                               bool /* save_as_floats */)
 {
+  bool retval = false;
+
+#if defined (HAVE_HDF5)
+
   hid_t group_hid = -1;
+
 #if HAVE_HDF5_18
   group_hid = H5Gcreate (loc_id, name, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   group_hid = H5Gcreate (loc_id, name, 0);
 #endif
   if (group_hid < 0) return false;
 
   size_t len = 0;
   for (int i = 0; i < ifargs.length (); i++)
     if (len < ifargs(i).length ())
       len = ifargs(i).length ();
 
   hid_t space_hid, data_hid, type_hid;
   space_hid = data_hid = type_hid = -1;
-  bool retval = true;
 
   // FIXME: Is there a better way of saving string vectors,
   //        than a null padded matrix?
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, 2);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   hdims[1] = ifargs.length ();
@@ -403,22 +407,28 @@ octave_fcn_inline::save_hdf5 (hid_t loc_
       return false;
     }
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
   H5Tclose (type_hid);
   H5Gclose (group_hid);
 
+#else
+  gripe_save ("hdf5");
+#endif
+
   return retval;
 }
 
 bool
-octave_fcn_inline::load_hdf5 (hid_t loc_id, const char *name)
+octave_fcn_inline::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
+#if defined (HAVE_HDF5)
+
   hid_t group_hid, data_hid, space_hid, type_hid, type_class_hid, st_id;
   hsize_t rank;
   int slen;
 
 #if HAVE_HDF5_18
   group_hid = H5Gopen (loc_id, name, H5P_DEFAULT);
 #else
   group_hid = H5Gopen (loc_id, name);
@@ -588,18 +598,22 @@ octave_fcn_inline::load_hdf5 (hid_t loc_
   H5Tclose (st_id);
   H5Dclose (data_hid);
   iftext = iftext_tmp;
 
   octave_fcn_inline ftmp (iftext, ifargs, nm);
   fcn = ftmp.fcn;
 
   return true;
+
+#else
+  gripe_load ("hdf5");
+  return false;
+#endif
 }
-#endif
 
 void
 octave_fcn_inline::print (std::ostream& os, bool pr_as_read_syntax)
 {
   print_raw (os, pr_as_read_syntax);
   newline (os);
 }
 
diff --git a/libinterp/octave-value/ov-fcn-inline.h b/libinterp/octave-value/ov-fcn-inline.h
--- a/libinterp/octave-value/ov-fcn-inline.h
+++ b/libinterp/octave-value/ov-fcn-inline.h
@@ -74,21 +74,19 @@ public:
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
-#if defined (HAVE_HDF5)
-  bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
+  bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name);
-#endif
+  bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   void print (std::ostream& os, bool pr_as_read_syntax = false);
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
 private:
 
 
diff --git a/libinterp/octave-value/ov-float.cc b/libinterp/octave-value/ov-float.cc
--- a/libinterp/octave-value/ov-float.cc
+++ b/libinterp/octave-value/ov-float.cc
@@ -30,16 +30,17 @@ along with Octave; see the file COPYING.
 #include "mach-info.h"
 #include "lo-specfun.h"
 #include "lo-mappers.h"
 
 #include "defun.h"
 #include "gripes.h"
 #include "mxarray.h"
 #include "oct-obj.h"
+#include "oct-hdf5.h"
 #include "oct-stream.h"
 #include "ov-scalar.h"
 #include "ov-float.h"
 #include "ov-base.h"
 #include "ov-base-scalar.h"
 #include "ov-base-scalar.cc"
 #include "ov-flt-re-mat.h"
 #include "ov-typeinfo.h"
@@ -178,22 +179,22 @@ octave_float_scalar::load_binary (std::i
   read_floats (is, &dtmp, static_cast<save_type> (tmp), 1, swap, fmt);
   if (error_state || ! is)
     return false;
 
   scalar = dtmp;
   return true;
 }
 
+bool
+octave_float_scalar::save_hdf5 (octave_hdf5_id loc_id, const char *name,
+                                bool /* save_as_floats */)
+{
 #if defined (HAVE_HDF5)
 
-bool
-octave_float_scalar::save_hdf5 (hid_t loc_id, const char *name,
-                                bool /* save_as_floats */)
-{
   hsize_t dimens[3];
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
   bool retval = true;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0) return false;
 #if HAVE_HDF5_18
@@ -211,22 +212,28 @@ octave_float_scalar::save_hdf5 (hid_t lo
 
   float tmp = float_value ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_FLOAT, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, &tmp) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
+#else
+  gripe_save ("hdf5");
+#endif
+
   return retval;
 }
 
 bool
-octave_float_scalar::load_hdf5 (hid_t loc_id, const char *name)
+octave_float_scalar::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
+#if defined (HAVE_HDF5)
+
 #if HAVE_HDF5_18
   hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
   hid_t space_id = H5Dget_space (data_hid);
 
   hsize_t rank = H5Sget_simple_extent_ndims (space_id);
@@ -245,20 +252,23 @@ octave_float_scalar::load_hdf5 (hid_t lo
       return false;
     }
 
   scalar = dtmp;
 
   H5Dclose (data_hid);
 
   return true;
+
+#else
+  gripe_load ("hdf5");
+  return false;
+#endif
 }
 
-#endif
-
 mxArray *
 octave_float_scalar::as_mxArray (void) const
 {
   mxArray *retval = new mxArray (mxSINGLE_CLASS, 1, 1, mxREAL);
 
   float *pr = static_cast<float *> (retval->get_data ());
 
   pr[0] = scalar;
diff --git a/libinterp/octave-value/ov-float.h b/libinterp/octave-value/ov-float.h
--- a/libinterp/octave-value/ov-float.h
+++ b/libinterp/octave-value/ov-float.h
@@ -226,21 +226,19 @@ public:
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
-#if defined (HAVE_HDF5)
-  bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
+  bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name);
-#endif
+  bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              oct_mach_info::float_format flt_fmt) const
   {
     return os.write (array_value (), block_size, output_type,
                      skip, flt_fmt);
   }
diff --git a/libinterp/octave-value/ov-flt-complex.cc b/libinterp/octave-value/ov-flt-complex.cc
--- a/libinterp/octave-value/ov-flt-complex.cc
+++ b/libinterp/octave-value/ov-flt-complex.cc
@@ -27,16 +27,17 @@ along with Octave; see the file COPYING.
 #include <iostream>
 
 #include "lo-ieee.h"
 #include "lo-specfun.h"
 #include "lo-mappers.h"
 
 #include "mxarray.h"
 #include "oct-obj.h"
+#include "oct-hdf5.h"
 #include "oct-stream.h"
 #include "ops.h"
 #include "ov-complex.h"
 #include "ov-base.h"
 #include "ov-base-scalar.h"
 #include "ov-base-scalar.cc"
 #include "ov-flt-cx-mat.h"
 #include "ov-float.h"
@@ -288,26 +289,27 @@ octave_float_complex::load_binary (std::
                static_cast<save_type> (tmp), 2, swap, fmt);
   if (error_state || ! is)
     return false;
 
   scalar = ctmp;
   return true;
 }
 
+bool
+octave_float_complex::save_hdf5 (octave_hdf5_id loc_id, const char *name,
+                                 bool /* save_as_floats */)
+{
+  bool retval = false;
+
 #if defined (HAVE_HDF5)
 
-bool
-octave_float_complex::save_hdf5 (hid_t loc_id, const char *name,
-                                 bool /* save_as_floats */)
-{
   hsize_t dimens[3];
   hid_t space_hid, type_hid, data_hid;
   space_hid = type_hid = data_hid = -1;
-  bool retval = true;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0)
     return false;
 
   type_hid = hdf5_make_complex_type (H5T_NATIVE_FLOAT);
   if (type_hid < 0)
     {
@@ -330,23 +332,30 @@ octave_float_complex::save_hdf5 (hid_t l
   FloatComplex tmp = float_complex_value ();
   retval = H5Dwrite (data_hid, type_hid, H5S_ALL, H5S_ALL, H5P_DEFAULT,
                      &tmp) >= 0;
 
   H5Dclose (data_hid);
   H5Tclose (type_hid);
   H5Sclose (space_hid);
 
+#else
+  gripe_save ("hdf5");
+#endif
+
   return retval;
 }
 
 bool
-octave_float_complex::load_hdf5 (hid_t loc_id, const char *name)
+octave_float_complex::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
   bool retval = false;
+
+#if defined (HAVE_HDF5)
+
 #if HAVE_HDF5_18
   hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
   hid_t type_hid = H5Dget_type (data_hid);
 
   hid_t complex_type = hdf5_make_complex_type (H5T_NATIVE_FLOAT);
@@ -377,21 +386,23 @@ octave_float_complex::load_hdf5 (hid_t l
       retval = true;
       scalar = ctmp;
     }
 
   H5Tclose (complex_type);
   H5Sclose (space_id);
   H5Dclose (data_hid);
 
+#else
+  gripe_load ("hdf5");
+#endif
+
   return retval;
 }
 
-#endif
-
 mxArray *
 octave_float_complex::as_mxArray (void) const
 {
   mxArray *retval = new mxArray (mxSINGLE_CLASS, 1, 1, mxCOMPLEX);
 
   float *pr = static_cast<float *> (retval->get_data ());
   float *pi = static_cast<float *> (retval->get_imag_data ());
 
diff --git a/libinterp/octave-value/ov-flt-complex.h b/libinterp/octave-value/ov-flt-complex.h
--- a/libinterp/octave-value/ov-flt-complex.h
+++ b/libinterp/octave-value/ov-flt-complex.h
@@ -162,21 +162,19 @@ public:
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
-#if defined (HAVE_HDF5)
-  bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
+  bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name);
-#endif
+  bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              oct_mach_info::float_format flt_fmt) const
   {
     // Yes, for compatibility, we drop the imaginary part here.
     return os.write (array_value (true), block_size, output_type,
                      skip, flt_fmt);
diff --git a/libinterp/octave-value/ov-flt-cx-mat.cc b/libinterp/octave-value/ov-flt-cx-mat.cc
--- a/libinterp/octave-value/ov-flt-cx-mat.cc
+++ b/libinterp/octave-value/ov-flt-cx-mat.cc
@@ -34,16 +34,17 @@ along with Octave; see the file COPYING.
 #include "lo-mappers.h"
 #include "mx-base.h"
 #include "mach-info.h"
 #include "oct-locbuf.h"
 
 #include "gripes.h"
 #include "mxarray.h"
 #include "oct-obj.h"
+#include "oct-hdf5.h"
 #include "oct-stream.h"
 #include "ops.h"
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "ov-base-mat.cc"
 #include "ov-complex.h"
 #include "ov-flt-complex.h"
 #include "ov-cx-mat.h"
@@ -519,30 +520,31 @@ octave_float_complex_matrix::load_binary
                    static_cast<save_type> (tmp), 2*len, swap, fmt);
       if (error_state || ! is)
         return false;
       matrix = m;
     }
   return true;
 }
 
+bool
+octave_float_complex_matrix::save_hdf5 (octave_hdf5_id loc_id, const char *name, bool)
+{
+  bool retval = false;
+
 #if defined (HAVE_HDF5)
 
-bool
-octave_float_complex_matrix::save_hdf5 (hid_t loc_id, const char *name, bool)
-{
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   int rank = dv.length ();
   hid_t space_hid, data_hid, type_hid;
   space_hid = data_hid = type_hid = -1;
-  bool retval = true;
   FloatComplexNDArray m = complex_array_value ();
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
     hdims[i] = dv (rank-i-1);
 
@@ -596,24 +598,30 @@ octave_float_complex_matrix::save_hdf5 (
         }
     }
 
   H5Tclose (complex_type_hid);
   H5Dclose (data_hid);
   H5Tclose (type_hid);
   H5Sclose (space_hid);
 
+#else
+  gripe_save ("hdf5");
+#endif
+
   return retval;
 }
 
 bool
-octave_float_complex_matrix::load_hdf5 (hid_t loc_id, const char *name)
+octave_float_complex_matrix::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
   bool retval = false;
 
+#if defined (HAVE_HDF5)
+
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize (dv);
   if (empty)
     return (empty > 0);
 
 #if HAVE_HDF5_18
@@ -671,21 +679,23 @@ octave_float_complex_matrix::load_hdf5 (
       retval = true;
       matrix = m;
     }
 
   H5Tclose (complex_type);
   H5Sclose (space_id);
   H5Dclose (data_hid);
 
+#else
+  gripe_load ("hdf5");
+#endif
+
   return retval;
 }
 
-#endif
-
 void
 octave_float_complex_matrix::print_raw (std::ostream& os,
                                         bool pr_as_read_syntax) const
 {
   octave_print_internal (os, matrix, pr_as_read_syntax,
                          current_print_indent_level ());
 }
 
diff --git a/libinterp/octave-value/ov-flt-cx-mat.h b/libinterp/octave-value/ov-flt-cx-mat.h
--- a/libinterp/octave-value/ov-flt-cx-mat.h
+++ b/libinterp/octave-value/ov-flt-cx-mat.h
@@ -146,21 +146,19 @@ public:
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
-#if defined (HAVE_HDF5)
-  bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
+  bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name);
-#endif
+  bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              oct_mach_info::float_format flt_fmt) const
   {
     // Yes, for compatibility, we drop the imaginary part here.
     return os.write (matrix_value (true), block_size, output_type,
                      skip, flt_fmt);
diff --git a/libinterp/octave-value/ov-flt-re-mat.cc b/libinterp/octave-value/ov-flt-re-mat.cc
--- a/libinterp/octave-value/ov-flt-re-mat.cc
+++ b/libinterp/octave-value/ov-flt-re-mat.cc
@@ -39,16 +39,17 @@ along with Octave; see the file COPYING.
 #include "quit.h"
 #include "oct-locbuf.h"
 
 #include "defun.h"
 #include "gripes.h"
 #include "mxarray.h"
 #include "oct-obj.h"
 #include "oct-lvalue.h"
+#include "oct-hdf5.h"
 #include "oct-stream.h"
 #include "ops.h"
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "ov-base-mat.cc"
 #include "ov-scalar.h"
 #include "ov-float.h"
 #include "ov-flt-complex.h"
@@ -546,30 +547,31 @@ octave_float_matrix::load_binary (std::i
       read_floats (is, re, static_cast<save_type> (tmp), len, swap, fmt);
       if (error_state || ! is)
         return false;
       matrix = m;
     }
   return true;
 }
 
+bool
+octave_float_matrix::save_hdf5 (octave_hdf5_id loc_id, const char *name, bool)
+{
+  bool retval = false;
+
 #if defined (HAVE_HDF5)
 
-bool
-octave_float_matrix::save_hdf5 (hid_t loc_id, const char *name, bool)
-{
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   int rank = dv.length ();
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
-  bool retval = true;
   FloatNDArray m = array_value ();
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
     hdims[i] = dv (rank-i-1);
 
@@ -605,24 +607,30 @@ octave_float_matrix::save_hdf5 (hid_t lo
 
   float *mtmp = m.fortran_vec ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_FLOAT, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, mtmp) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
+#else
+  gripe_save ("hdf5");
+#endif
+
   return retval;
 }
 
 bool
-octave_float_matrix::load_hdf5 (hid_t loc_id, const char *name)
+octave_float_matrix::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
   bool retval = false;
 
+#if defined (HAVE_HDF5)
+
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize (dv);
   if (empty)
     return (empty > 0);
 
 #if HAVE_HDF5_18
@@ -667,21 +675,23 @@ octave_float_matrix::load_hdf5 (hid_t lo
     {
       retval = true;
       matrix = m;
     }
 
   H5Sclose (space_id);
   H5Dclose (data_hid);
 
+#else
+  gripe_load ("hdf5");
+#endif
+
   return retval;
 }
 
-#endif
-
 void
 octave_float_matrix::print_raw (std::ostream& os,
                                 bool pr_as_read_syntax) const
 {
   octave_print_internal (os, matrix, pr_as_read_syntax,
                          current_print_indent_level ());
 }
 
diff --git a/libinterp/octave-value/ov-flt-re-mat.h b/libinterp/octave-value/ov-flt-re-mat.h
--- a/libinterp/octave-value/ov-flt-re-mat.h
+++ b/libinterp/octave-value/ov-flt-re-mat.h
@@ -184,21 +184,19 @@ public:
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
-#if defined (HAVE_HDF5)
-  bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
+  bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name);
-#endif
+  bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              oct_mach_info::float_format flt_fmt) const
   { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
diff --git a/libinterp/octave-value/ov-int16.cc b/libinterp/octave-value/ov-int16.cc
--- a/libinterp/octave-value/ov-int16.cc
+++ b/libinterp/octave-value/ov-int16.cc
@@ -31,23 +31,20 @@ along with Octave; see the file COPYING.
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "quit.h"
 
 #include "defun.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "oct-lvalue.h"
+#include "oct-hdf5.h"
 #include "ops.h"
 #include "ov-base.h"
 
-#ifdef HAVE_HDF5
-#define HDF5_SAVE_TYPE H5T_NATIVE_INT16
-#endif
-
 #include "ov-base-int.h"
 #include "ov-base-int.cc"
 #include "ov-int16.h"
 #include "ov-type-conv.h"
 #include "pr-output.h"
 #include "variables.h"
 
 #include "byte-swap.h"
diff --git a/libinterp/octave-value/ov-int32.cc b/libinterp/octave-value/ov-int32.cc
--- a/libinterp/octave-value/ov-int32.cc
+++ b/libinterp/octave-value/ov-int32.cc
@@ -31,23 +31,20 @@ along with Octave; see the file COPYING.
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "quit.h"
 
 #include "defun.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "oct-lvalue.h"
+#include "oct-hdf5.h"
 #include "ops.h"
 #include "ov-base.h"
 
-#ifdef HAVE_HDF5
-#define HDF5_SAVE_TYPE H5T_NATIVE_INT32
-#endif
-
 #include "ov-base-int.h"
 #include "ov-base-int.cc"
 #include "ov-int32.h"
 #include "ov-type-conv.h"
 #include "pr-output.h"
 #include "variables.h"
 
 #include "byte-swap.h"
diff --git a/libinterp/octave-value/ov-int64.cc b/libinterp/octave-value/ov-int64.cc
--- a/libinterp/octave-value/ov-int64.cc
+++ b/libinterp/octave-value/ov-int64.cc
@@ -31,23 +31,20 @@ along with Octave; see the file COPYING.
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "quit.h"
 
 #include "defun.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "oct-lvalue.h"
+#include "oct-hdf5.h"
 #include "ops.h"
 #include "ov-base.h"
 
-#ifdef HAVE_HDF5
-#define HDF5_SAVE_TYPE H5T_NATIVE_INT64
-#endif
-
 #include "ov-base-int.h"
 #include "ov-base-int.cc"
 #include "ov-int64.h"
 #include "ov-type-conv.h"
 #include "pr-output.h"
 #include "variables.h"
 
 #include "byte-swap.h"
diff --git a/libinterp/octave-value/ov-int8.cc b/libinterp/octave-value/ov-int8.cc
--- a/libinterp/octave-value/ov-int8.cc
+++ b/libinterp/octave-value/ov-int8.cc
@@ -31,23 +31,20 @@ along with Octave; see the file COPYING.
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "quit.h"
 
 #include "defun.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "oct-lvalue.h"
+#include "oct-hdf5.h"
 #include "ops.h"
 #include "ov-base.h"
 
-#ifdef HAVE_HDF5
-#define HDF5_SAVE_TYPE H5T_NATIVE_INT8
-#endif
-
 #include "ov-base-int.h"
 #include "ov-base-int.cc"
 #include "ov-int8.h"
 #include "ov-type-conv.h"
 #include "pr-output.h"
 #include "variables.h"
 
 #include "byte-swap.h"
diff --git a/libinterp/octave-value/ov-lazy-idx.h b/libinterp/octave-value/ov-lazy-idx.h
--- a/libinterp/octave-value/ov-lazy-idx.h
+++ b/libinterp/octave-value/ov-lazy-idx.h
@@ -198,17 +198,16 @@ public:
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
-  // HDF5 functions not defined.
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              oct_mach_info::float_format flt_fmt) const
   { return make_value ().write (os, block_size, output_type, skip, flt_fmt); }
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
@@ -243,9 +242,8 @@ private:
 
   static octave_base_value *
   numeric_conversion_function (const octave_base_value&);
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
-
diff --git a/libinterp/octave-value/ov-oncleanup.cc b/libinterp/octave-value/ov-oncleanup.cc
--- a/libinterp/octave-value/ov-oncleanup.cc
+++ b/libinterp/octave-value/ov-oncleanup.cc
@@ -142,32 +142,32 @@ octave_oncleanup::save_binary (std::ostr
 bool
 octave_oncleanup::load_binary (std::istream& /* is */, bool /* swap */,
                                oct_mach_info::float_format /* fmt */)
 {
   warn_save_load ();
   return true;
 }
 
-#if defined (HAVE_HDF5)
 bool
-octave_oncleanup::save_hdf5 (hid_t /* loc_id */, const char * /* name */,
+octave_oncleanup::save_hdf5 (octave_hdf5_id /* loc_id */,
+                             const char * /* name */,
                              bool /* save_as_floats */)
 {
   warn_save_load ();
   return true;
 }
 
 bool
-octave_oncleanup::load_hdf5 (hid_t /* loc_id */, const char * /* name */)
+octave_oncleanup::load_hdf5 (octave_hdf5_id /* loc_id */,
+                             const char * /* name */)
 {
   warn_save_load ();
   return true;
 }
-#endif
 
 void
 octave_oncleanup::print (std::ostream& os, bool pr_as_read_syntax)
 {
   print_raw (os, pr_as_read_syntax);
   newline (os);
 }
 
diff --git a/libinterp/octave-value/ov-oncleanup.h b/libinterp/octave-value/ov-oncleanup.h
--- a/libinterp/octave-value/ov-oncleanup.h
+++ b/libinterp/octave-value/ov-oncleanup.h
@@ -76,21 +76,19 @@ public:
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
-#if defined (HAVE_HDF5)
-  bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
+  bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name);
-#endif
+  bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   void print (std::ostream& os, bool pr_as_read_syntax = false);
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
 private:
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
diff --git a/libinterp/octave-value/ov-range.cc b/libinterp/octave-value/ov-range.cc
--- a/libinterp/octave-value/ov-range.cc
+++ b/libinterp/octave-value/ov-range.cc
@@ -30,16 +30,17 @@ along with Octave; see the file COPYING.
 #include "lo-utils.h"
 
 #include "defun.h"
 #include "variables.h"
 #include "gripes.h"
 #include "mxarray.h"
 #include "ops.h"
 #include "oct-obj.h"
+#include "oct-hdf5.h"
 #include "ov-range.h"
 #include "ov-re-mat.h"
 #include "ov-scalar.h"
 #include "pr-output.h"
 
 #include "byte-swap.h"
 #include "ls-ascii-helper.h"
 #include "ls-hdf5.h"
@@ -538,24 +539,29 @@ hdf5_make_range_type (hid_t num_type)
 
   H5Tinsert (type_id, "base", 0 * sizeof (double), num_type);
   H5Tinsert (type_id, "limit", 1 * sizeof (double), num_type);
   H5Tinsert (type_id, "increment", 2 * sizeof (double), num_type);
 
   return type_id;
 }
 
+#endif
+
 bool
-octave_range::save_hdf5 (hid_t loc_id, const char *name,
+octave_range::save_hdf5 (octave_hdf5_id loc_id, const char *name,
                          bool /* save_as_floats */)
 {
+  bool retval = false;
+
+#if defined (HAVE_HDF5)
+
   hsize_t dimens[3];
   hid_t space_hid, type_hid, data_hid;
   space_hid = type_hid = data_hid = -1;
-  bool retval = true;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0) return false;
 
   type_hid = hdf5_make_range_type (H5T_NATIVE_DOUBLE);
   if (type_hid < 0)
     {
       H5Sclose (space_hid);
@@ -589,24 +595,30 @@ octave_range::save_hdf5 (hid_t loc_id, c
     }
   else
     retval = false;
 
   H5Dclose (data_hid);
   H5Tclose (type_hid);
   H5Sclose (space_hid);
 
+#else
+  gripe_save ("hdf5");
+#endif
+
   return retval;
 }
 
 bool
-octave_range::load_hdf5 (hid_t loc_id, const char *name)
+octave_range::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
   bool retval = false;
 
+#if defined (HAVE_HDF5)
+
 #if HAVE_HDF5_18
   hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
   hid_t type_hid = H5Dget_type (data_hid);
 
   hid_t range_type = hdf5_make_range_type (H5T_NATIVE_DOUBLE);
@@ -647,21 +659,23 @@ octave_range::load_hdf5 (hid_t loc_id, c
                            static_cast<octave_idx_type> (rangevals[1]));
         }
     }
 
   H5Tclose (range_type);
   H5Sclose (space_hid);
   H5Dclose (data_hid);
 
+#else
+  gripe_load ("hdf5");
+#endif
+
   return retval;
 }
 
-#endif
-
 mxArray *
 octave_range::as_mxArray (void) const
 {
   mxArray *retval = new mxArray (mxDOUBLE_CLASS, dims (), mxREAL);
 
   double *pr = static_cast<double *> (retval->get_data ());
 
   mwSize nel = numel ();
diff --git a/libinterp/octave-value/ov-range.h b/libinterp/octave-value/ov-range.h
--- a/libinterp/octave-value/ov-range.h
+++ b/libinterp/octave-value/ov-range.h
@@ -260,21 +260,19 @@ public:
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
-#if defined (HAVE_HDF5)
-  bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
+  bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name);
-#endif
+  bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              oct_mach_info::float_format flt_fmt) const
   {
     // FIXME: could be more memory efficient by having a
     // special case of the octave_stream::write method for ranges.
 
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -39,16 +39,17 @@ along with Octave; see the file COPYING.
 #include "quit.h"
 #include "oct-locbuf.h"
 
 #include "defun.h"
 #include "gripes.h"
 #include "mxarray.h"
 #include "oct-obj.h"
 #include "oct-lvalue.h"
+#include "oct-hdf5.h"
 #include "oct-stream.h"
 #include "ops.h"
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "ov-base-mat.cc"
 #include "ov-scalar.h"
 #include "ov-re-mat.h"
 #include "ov-flt-re-mat.h"
@@ -658,30 +659,31 @@ octave_matrix::load_binary (std::istream
       read_doubles (is, re, static_cast<save_type> (tmp), len, swap, fmt);
       if (error_state || ! is)
         return false;
       matrix = m;
     }
   return true;
 }
 
+bool
+octave_matrix::save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats)
+{
+  bool retval = false;
+
 #if defined (HAVE_HDF5)
 
-bool
-octave_matrix::save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats)
-{
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   int rank = dv.length ();
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
-  bool retval = true;
   NDArray m = array_value ();
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
     hdims[i] = dv (rank-i-1);
 
@@ -728,24 +730,30 @@ octave_matrix::save_hdf5 (hid_t loc_id, 
 
   double *mtmp = m.fortran_vec ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, mtmp) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
+#else
+  gripe_save ("hdf5");
+#endif
+
   return retval;
 }
 
 bool
-octave_matrix::load_hdf5 (hid_t loc_id, const char *name)
+octave_matrix::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
   bool retval = false;
 
+#if defined (HAVE_HDF5)
+
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize (dv);
   if (empty)
     return (empty > 0);
 
 #if HAVE_HDF5_18
@@ -790,21 +798,23 @@ octave_matrix::load_hdf5 (hid_t loc_id, 
     {
       retval = true;
       matrix = m;
     }
 
   H5Sclose (space_id);
   H5Dclose (data_hid);
 
+#else
+  gripe_load ("hdf5");
+#endif
+
   return retval;
 }
 
-#endif
-
 void
 octave_matrix::print_raw (std::ostream& os,
                           bool pr_as_read_syntax) const
 {
   octave_print_internal (os, matrix, pr_as_read_syntax,
                          current_print_indent_level ());
 }
 
diff --git a/libinterp/octave-value/ov-re-mat.h b/libinterp/octave-value/ov-re-mat.h
--- a/libinterp/octave-value/ov-re-mat.h
+++ b/libinterp/octave-value/ov-re-mat.h
@@ -208,21 +208,19 @@ public:
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
-#if defined (HAVE_HDF5)
-  bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
+  bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name);
-#endif
+  bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              oct_mach_info::float_format flt_fmt) const
   { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
diff --git a/libinterp/octave-value/ov-re-sparse.cc b/libinterp/octave-value/ov-re-sparse.cc
--- a/libinterp/octave-value/ov-re-sparse.cc
+++ b/libinterp/octave-value/ov-re-sparse.cc
@@ -33,16 +33,17 @@ along with Octave; see the file COPYING.
 #include "lo-mappers.h"
 #include "oct-locbuf.h"
 
 #include "mxarray.h"
 #include "ov-base.h"
 #include "ov-scalar.h"
 #include "gripes.h"
 
+#include "oct-hdf5.h"
 #include "ls-hdf5.h"
 
 #include "ov-re-sparse.h"
 
 #include "ov-base-sparse.h"
 #include "ov-base-sparse.cc"
 
 #include "ov-bool-sparse.h"
@@ -392,22 +393,24 @@ octave_sparse_matrix::load_binary (std::
   if (! m.indices_ok ())
     return false;
 
   matrix = m;
 
   return true;
 }
 
+bool
+octave_sparse_matrix::save_hdf5 (octave_hdf5_id loc_id, const char *name,
+                                 bool save_as_floats)
+{
+  bool retval = false;
+
 #if defined (HAVE_HDF5)
 
-bool
-octave_sparse_matrix::save_hdf5 (hid_t loc_id, const char *name,
-                                 bool save_as_floats)
-{
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
 
@@ -417,17 +420,16 @@ octave_sparse_matrix::save_hdf5 (hid_t l
 #else
   hid_t group_hid = H5Gcreate (loc_id, name, 0);
 #endif
   if (group_hid < 0)
     return false;
 
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
-  bool retval = true;
   SparseMatrix m = sparse_matrix_value ();
   octave_idx_type tmp;
   hsize_t hdims[2];
 
   space_hid = H5Screate_simple (0, hdims, 0);
   if (space_hid < 0)
     {
       H5Gclose (group_hid);
@@ -622,22 +624,30 @@ octave_sparse_matrix::save_hdf5 (hid_t l
 
   double * dtmp = m.xdata ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, dtmp) >= 0;
   H5Dclose (data_hid);
   H5Sclose (space_hid);
   H5Gclose (group_hid);
 
+#else
+  gripe_save ("hdf5");
+#endif
+
   return retval;
 }
 
 bool
-octave_sparse_matrix::load_hdf5 (hid_t loc_id, const char *name)
+octave_sparse_matrix::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
+  bool retval = false;
+
+#if defined (HAVE_HDF5)
+
   octave_idx_type nr, nc, nz;
   hid_t group_hid, data_hid, space_hid;
   hsize_t rank;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize (dv);
@@ -834,34 +844,36 @@ octave_sparse_matrix::load_hdf5 (hid_t l
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   double *dtmp = m.xdata ();
-  bool retval = false;
+
   if (H5Dread (data_hid, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL,
                H5P_DEFAULT, dtmp) >= 0
       && m.indices_ok ())
     {
       retval = true;
       matrix = m;
     }
 
   H5Sclose (space_hid);
   H5Dclose (data_hid);
   H5Gclose (group_hid);
 
+#else
+  gripe_load ("hdf5");
+#endif
+  
   return retval;
 }
 
-#endif
-
 mxArray *
 octave_sparse_matrix::as_mxArray (void) const
 {
   mwSize nz = nzmax ();
   mwSize nr = rows ();
   mwSize nc = columns ();
   mxArray *retval = new mxArray (mxDOUBLE_CLASS, nr, nc, nz, mxREAL);
   double *pr = static_cast<double *> (retval->get_data ());
diff --git a/libinterp/octave-value/ov-re-sparse.h b/libinterp/octave-value/ov-re-sparse.h
--- a/libinterp/octave-value/ov-re-sparse.h
+++ b/libinterp/octave-value/ov-re-sparse.h
@@ -139,21 +139,19 @@ public:
   { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 #endif
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
-#if defined (HAVE_HDF5)
-  bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
+  bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name);
-#endif
+  bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   mxArray *as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
   octave_value map (double (*fcn) (double)) const;
 
diff --git a/libinterp/octave-value/ov-scalar.cc b/libinterp/octave-value/ov-scalar.cc
--- a/libinterp/octave-value/ov-scalar.cc
+++ b/libinterp/octave-value/ov-scalar.cc
@@ -30,16 +30,17 @@ along with Octave; see the file COPYING.
 #include "mach-info.h"
 #include "lo-specfun.h"
 #include "lo-mappers.h"
 
 #include "defun.h"
 #include "gripes.h"
 #include "mxarray.h"
 #include "oct-obj.h"
+#include "oct-hdf5.h"
 #include "oct-stream.h"
 #include "ov-scalar.h"
 #include "ov-float.h"
 #include "ov-base.h"
 #include "ov-base-scalar.h"
 #include "ov-base-scalar.cc"
 #include "ov-re-mat.h"
 #include "ov-typeinfo.h"
@@ -193,26 +194,27 @@ octave_scalar::load_binary (std::istream
   read_doubles (is, &dtmp, static_cast<save_type> (tmp), 1, swap, fmt);
   if (error_state || ! is)
     return false;
 
   scalar = dtmp;
   return true;
 }
 
+bool
+octave_scalar::save_hdf5 (octave_hdf5_id loc_id, const char *name,
+                          bool /* save_as_floats */)
+{
+  bool retval = false;
+
 #if defined (HAVE_HDF5)
 
-bool
-octave_scalar::save_hdf5 (hid_t loc_id, const char *name,
-                          bool /* save_as_floats */)
-{
   hsize_t dimens[3];
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
-  bool retval = true;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0) return false;
 
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_DOUBLE, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
@@ -227,22 +229,28 @@ octave_scalar::save_hdf5 (hid_t loc_id, 
 
   double tmp = double_value ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, &tmp) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
+#else
+  gripe_save ("hdf5");
+#endif
+
   return retval;
 }
 
 bool
-octave_scalar::load_hdf5 (hid_t loc_id, const char *name)
+octave_scalar::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
+#if defined (HAVE_HDF5)
+
 #if HAVE_HDF5_18
   hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
   hid_t space_id = H5Dget_space (data_hid);
 
   hsize_t rank = H5Sget_simple_extent_ndims (space_id);
@@ -261,20 +269,23 @@ octave_scalar::load_hdf5 (hid_t loc_id, 
       return false;
     }
 
   scalar = dtmp;
 
   H5Dclose (data_hid);
 
   return true;
+
+#else
+  gripe_load ("hdf5");
+  return false;
+#endif
 }
 
-#endif
-
 mxArray *
 octave_scalar::as_mxArray (void) const
 {
   mxArray *retval = new mxArray (mxDOUBLE_CLASS, 1, 1, mxREAL);
 
   double *pr = static_cast<double *> (retval->get_data ());
 
   pr[0] = scalar;
diff --git a/libinterp/octave-value/ov-scalar.h b/libinterp/octave-value/ov-scalar.h
--- a/libinterp/octave-value/ov-scalar.h
+++ b/libinterp/octave-value/ov-scalar.h
@@ -225,21 +225,19 @@ public:
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
-#if defined (HAVE_HDF5)
-  bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
+  bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name);
-#endif
+  bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              oct_mach_info::float_format flt_fmt) const
   {
     return os.write (array_value (), block_size, output_type,
                      skip, flt_fmt);
   }
diff --git a/libinterp/octave-value/ov-str-mat.cc b/libinterp/octave-value/ov-str-mat.cc
--- a/libinterp/octave-value/ov-str-mat.cc
+++ b/libinterp/octave-value/ov-str-mat.cc
@@ -39,16 +39,17 @@ along with Octave; see the file COPYING.
 #include "byte-swap.h"
 #include "defun.h"
 #include "gripes.h"
 #include "ls-ascii-helper.h"
 #include "ls-hdf5.h"
 #include "ls-oct-ascii.h"
 #include "ls-utils.h"
 #include "oct-obj.h"
+#include "oct-hdf5.h"
 #include "oct-stream.h"
 #include "ops.h"
 #include "ov-scalar.h"
 #include "ov-re-mat.h"
 #include "ov-str-mat.h"
 #include "pr-output.h"
 #include "pt-mat.h"
 #include "utils.h"
@@ -564,31 +565,32 @@ octave_char_matrix_str::load_binary (std
             }
           chm.insert (btmp, i, 0);
         }
       matrix = chm;
     }
   return true;
 }
 
+bool
+octave_char_matrix_str::save_hdf5 (octave_hdf5_id loc_id, const char *name,
+                                   bool /* save_as_floats */)
+{
+  bool retval = false;
+
 #if defined (HAVE_HDF5)
 
-bool
-octave_char_matrix_str::save_hdf5 (hid_t loc_id, const char *name,
-                                   bool /* save_as_floats */)
-{
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   int rank = dv.length ();
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
-  bool retval = true;
   charNDArray m = char_array_value ();
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
     hdims[i] = dv (rank-i-1);
 
@@ -614,24 +616,30 @@ octave_char_matrix_str::save_hdf5 (hid_t
     s[i] = m(i);
 
   retval = H5Dwrite (data_hid, H5T_NATIVE_CHAR, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, s) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
+#else
+  gripe_save ("hdf5");
+#endif
+
   return retval;
 }
 
 bool
-octave_char_matrix_str::load_hdf5 (hid_t loc_id, const char *name)
+octave_char_matrix_str::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
   bool retval = false;
 
+#if defined (HAVE_HDF5)
+
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize (dv);
   if (empty)
     return (empty > 0);
 
 #if HAVE_HDF5_18
@@ -783,12 +791,14 @@ octave_char_matrix_str::load_hdf5 (hid_t
         {
           H5Tclose (type_hid);
           H5Sclose (space_hid);
           H5Dclose (data_hid);
           return false;
         }
     }
 
+#else
+  gripe_load ("hdf5");
+#endif
+
   return retval;
 }
-
-#endif
diff --git a/libinterp/octave-value/ov-str-mat.h b/libinterp/octave-value/ov-str-mat.h
--- a/libinterp/octave-value/ov-str-mat.h
+++ b/libinterp/octave-value/ov-str-mat.h
@@ -148,21 +148,19 @@ public:
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
-#if defined (HAVE_HDF5)
-  bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
+  bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name);
-#endif
+  bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              oct_mach_info::float_format flt_fmt) const
   { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
 protected:
 
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -27,16 +27,17 @@ along with Octave; see the file COPYING.
 #include <iostream>
 
 #include "Cell.h"
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "mxarray.h"
 #include "oct-lvalue.h"
+#include "oct-hdf5.h"
 #include "ov-struct.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
 #include "Array-util.h"
 #include "oct-locbuf.h"
 
@@ -974,21 +975,21 @@ octave_struct::load_binary (std::istream
   else if (len == 0)
     map = octave_map (dv);
   else
     success = false;
 
   return success;
 }
 
+bool
+octave_struct::save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats)
+{
 #if defined (HAVE_HDF5)
 
-bool
-octave_struct::save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats)
-{
   hid_t data_hid = -1;
 
 #if HAVE_HDF5_18
   data_hid = H5Gcreate (loc_id, name, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Gcreate (loc_id, name, 0);
 #endif
   if (data_hid < 0) return false;
@@ -1013,23 +1014,30 @@ octave_struct::save_hdf5 (hid_t loc_id, 
 
       if (! retval2)
         break;
     }
 
   H5Gclose (data_hid);
 
   return true;
+
+#else
+  gripe_save ("hdf5");
+  return false;
+#endif
 }
 
 bool
-octave_struct::load_hdf5 (hid_t loc_id, const char *name)
+octave_struct::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
   bool retval = false;
 
+#if defined (HAVE_HDF5)
+
   hdf5_callback_data dsub;
 
   herr_t retval2 = 0;
   octave_map m (dim_vector (1, 1));
   int current_item = 0;
   hsize_t num_obj = 0;
 #if HAVE_HDF5_18
   hid_t group_id = H5Gopen (loc_id, name, H5P_DEFAULT);
@@ -1061,21 +1069,23 @@ octave_struct::load_hdf5 (hid_t loc_id, 
     }
 
   if (retval2 >= 0)
     {
       map = m;
       retval = true;
     }
 
+#else
+  gripe_load ("hdf5");
+#endif
+
   return retval;
 }
 
-#endif
-
 mxArray *
 octave_struct::as_mxArray (void) const
 {
   int nf = nfields ();
   string_vector kv = map_keys ();
 
   OCTAVE_LOCAL_BUFFER (const char *, f, nf);
 
@@ -1609,22 +1619,22 @@ octave_scalar_struct::load_binary (std::
   else if (len == 0)
     map = octave_scalar_map ();
   else
     success = false;
 
   return success;
 }
 
-#if defined (HAVE_HDF5)
-
 bool
-octave_scalar_struct::save_hdf5 (hid_t loc_id, const char *name,
+octave_scalar_struct::save_hdf5 (octave_hdf5_id loc_id, const char *name,
                                  bool save_as_floats)
 {
+#if defined (HAVE_HDF5)
+
   hid_t data_hid = -1;
 
 #if HAVE_HDF5_18
   data_hid = H5Gcreate (loc_id, name, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Gcreate (loc_id, name, 0);
 #endif
   if (data_hid < 0) return false;
@@ -1649,23 +1659,30 @@ octave_scalar_struct::save_hdf5 (hid_t l
 
       if (! retval2)
         break;
     }
 
   H5Gclose (data_hid);
 
   return true;
+
+#else
+  gripe_save ("hdf5");
+  return false;
+#endif
 }
 
 bool
-octave_scalar_struct::load_hdf5 (hid_t loc_id, const char *name)
+octave_scalar_struct::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
   bool retval = false;
 
+#if defined (HAVE_HDF5)
+
   hdf5_callback_data dsub;
 
   herr_t retval2 = 0;
   octave_scalar_map m;
   int current_item = 0;
   hsize_t num_obj = 0;
 #if HAVE_HDF5_18
   hid_t group_id = H5Gopen (loc_id, name, H5P_DEFAULT);
@@ -1695,21 +1712,23 @@ octave_scalar_struct::load_hdf5 (hid_t l
     }
 
   if (retval2 >= 0)
     {
       map = m;
       retval = true;
     }
 
+#else
+  gripe_load ("hdf5");
+#endif
+
   return retval;
 }
 
-#endif
-
 mxArray *
 octave_scalar_struct::as_mxArray (void) const
 {
   int nf = nfields ();
   string_vector kv = map_keys ();
 
   OCTAVE_LOCAL_BUFFER (const char *, f, nf);
 
diff --git a/libinterp/octave-value/ov-struct.h b/libinterp/octave-value/ov-struct.h
--- a/libinterp/octave-value/ov-struct.h
+++ b/libinterp/octave-value/ov-struct.h
@@ -135,21 +135,19 @@ public:
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
-#if defined (HAVE_HDF5)
-  bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
+  bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name);
-#endif
+  bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   mxArray *as_mxArray (void) const;
 
   octave_value
   fast_elem_extract (octave_idx_type n) const;
 
   bool
   fast_elem_insert (octave_idx_type n, const octave_value& x);
@@ -257,21 +255,19 @@ public:
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
-#if defined (HAVE_HDF5)
-  bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
+  bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name);
-#endif
+  bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   mxArray *as_mxArray (void) const;
 
   bool fast_elem_insert_self (void *where, builtin_type_t btyp) const;
 
 protected:
 
   // The associative array used to manage the structure data.
diff --git a/libinterp/octave-value/ov-uint16.cc b/libinterp/octave-value/ov-uint16.cc
--- a/libinterp/octave-value/ov-uint16.cc
+++ b/libinterp/octave-value/ov-uint16.cc
@@ -31,23 +31,20 @@ along with Octave; see the file COPYING.
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "quit.h"
 
 #include "defun.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "oct-lvalue.h"
+#include "oct-hdf5.h"
 #include "ops.h"
 #include "ov-base.h"
 
-#ifdef HAVE_HDF5
-#define HDF5_SAVE_TYPE H5T_NATIVE_UINT16
-#endif
-
 #include "ov-base-int.h"
 #include "ov-base-int.cc"
 #include "ov-uint16.h"
 #include "ov-type-conv.h"
 #include "pr-output.h"
 #include "variables.h"
 
 #include "byte-swap.h"
diff --git a/libinterp/octave-value/ov-uint32.cc b/libinterp/octave-value/ov-uint32.cc
--- a/libinterp/octave-value/ov-uint32.cc
+++ b/libinterp/octave-value/ov-uint32.cc
@@ -31,23 +31,20 @@ along with Octave; see the file COPYING.
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "quit.h"
 
 #include "defun.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "oct-lvalue.h"
+#include "oct-hdf5.h"
 #include "ops.h"
 #include "ov-base.h"
 
-#ifdef HAVE_HDF5
-#define HDF5_SAVE_TYPE H5T_NATIVE_UINT32
-#endif
-
 #include "ov-base-int.h"
 #include "ov-base-int.cc"
 #include "ov-uint32.h"
 #include "ov-type-conv.h"
 #include "pr-output.h"
 #include "variables.h"
 
 #include "byte-swap.h"
diff --git a/libinterp/octave-value/ov-uint64.cc b/libinterp/octave-value/ov-uint64.cc
--- a/libinterp/octave-value/ov-uint64.cc
+++ b/libinterp/octave-value/ov-uint64.cc
@@ -31,23 +31,20 @@ along with Octave; see the file COPYING.
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "quit.h"
 
 #include "defun.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "oct-lvalue.h"
+#include "oct-hdf5.h"
 #include "ops.h"
 #include "ov-base.h"
 
-#ifdef HAVE_HDF5
-#define HDF5_SAVE_TYPE H5T_NATIVE_UINT64
-#endif
-
 #include "ov-base-int.h"
 #include "ov-base-int.cc"
 #include "ov-uint64.h"
 #include "ov-type-conv.h"
 #include "pr-output.h"
 #include "variables.h"
 
 #include "byte-swap.h"
diff --git a/libinterp/octave-value/ov-uint8.cc b/libinterp/octave-value/ov-uint8.cc
--- a/libinterp/octave-value/ov-uint8.cc
+++ b/libinterp/octave-value/ov-uint8.cc
@@ -31,23 +31,20 @@ along with Octave; see the file COPYING.
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "quit.h"
 
 #include "defun.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "oct-lvalue.h"
+#include "oct-hdf5.h"
 #include "ops.h"
 #include "ov-base.h"
 
-#ifdef HAVE_HDF5
-#define HDF5_SAVE_TYPE H5T_NATIVE_UINT8
-#endif
-
 #include "ov-base-int.h"
 #include "ov-base-int.cc"
 #include "ov-uint8.h"
 #include "ov-type-conv.h"
 #include "pr-output.h"
 #include "variables.h"
 
 #include "byte-swap.h"
diff --git a/libinterp/octave-value/ov.h b/libinterp/octave-value/ov.h
--- a/libinterp/octave-value/ov.h
+++ b/libinterp/octave-value/ov.h
@@ -33,17 +33,16 @@ along with Octave; see the file COPYING.
 #include "Range.h"
 #include "data-conv.h"
 #include "idx-vector.h"
 #include "mach-info.h"
 #include "mx-base.h"
 #include "oct-time.h"
 #include "str-vec.h"
 
-#include "oct-hdf5.h"
 #include "oct-sort.h"
 
 class Cell;
 class mxArray;
 class octave_map;
 class octave_scalar_map;
 class octave_stream;
 class octave_function;
@@ -52,18 +51,16 @@ class octave_fcn_handle;
 class octave_fcn_inline;
 class octave_value_list;
 class octave_lvalue;
 
 #include "ov-base.h"
 
 // Constants.
 
-class octave_value;
-
 class
 OCTINTERP_API
 octave_value
 {
 public:
 
   enum unary_op
   {
@@ -1089,23 +1086,22 @@ public:
 
   bool save_binary (std::ostream& os, bool& save_as_floats)
   { return rep->save_binary (os, save_as_floats); }
 
   bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt)
   { return rep->load_binary (is, swap, fmt); }
 
-#if defined (HAVE_HDF5)
-  bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats)
+  bool save_hdf5 (octave_hdf5_id loc_id, const char *name,
+                  bool save_as_floats)
   { return rep->save_hdf5 (loc_id, name, save_as_floats); }
 
-  bool load_hdf5 (hid_t loc_id, const char *name)
+  bool load_hdf5 (octave_hdf5_id loc_id, const char *name)
   { return rep->load_hdf5 (loc_id, name); }
-#endif
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              oct_mach_info::float_format flt_fmt) const;
 
   octave_base_value *internal_rep (void) const { return rep; }
 
   // Unsafe.  These functions exist to support the MEX interface.
