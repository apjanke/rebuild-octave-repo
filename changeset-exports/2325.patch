# HG changeset patch
# User jwe
# Date 837469221 0
#      Mon Jul 15 22:20:21 1996 +0000
# Node ID b5568c31ee2c8adbaebe32b78e0a42b12a441f84
# Parent  fdc6e2f813334cd492fe37cedc53f084f3e72581
[project @ 1996-07-15 22:20:21 by jwe]

diff --git a/scripts/audio/lin2mu.m b/scripts/audio/lin2mu.m
--- a/scripts/audio/lin2mu.m
+++ b/scripts/audio/lin2mu.m
@@ -22,35 +22,35 @@
 ## x is a vector of an 8- or 16-bit linearly encoded audio sample,
 ## This is transformed into a mu-law encoded vector.
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 17 October 1994
 ## Adapted-By: jwe
 
 function y = lin2mu (x)
-  
+
   if (nargin != 1)
     usage ("y = lin2mu (x)");
   endif
 
   if (! is_vector (x))
     error ("lin2mu: x must be a vector");
   endif
-  
+
   ## transform 8-bit format to 16-bit
   if (max (abs (x)) <= 128)
     x = 256 .* x;
   endif
 
   ## determine sign of x, set sign(0) = 1.
   sig = sign(x) + (x == 0);
 
   ## take absolute value of x, but force it to be smaller than 32636;
-  ## add bias 
+  ## add bias
   x = min (abs (x), 32635 * ones (size (x))) + 132;
 
   ## find exponent and fraction of bineary representation
   [f, e] = log2 (x);
 
   y = 64 * sig - 16 * e - fix (32 * f) + 335;
 
 endfunction
diff --git a/scripts/audio/loadaudio.m b/scripts/audio/loadaudio.m
--- a/scripts/audio/loadaudio.m
+++ b/scripts/audio/loadaudio.m
@@ -14,35 +14,35 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## usage:  X = loadaudio (name [, ext [, bit]])
 ##
-## Loads audio data from the file "name.ext" into the data vector X. 
+## Loads audio data from the file "name.ext" into the data vector X.
 ## Default value for the "ext" argument, which has to be written
 ## without the initial ".", is "lin".
 ## Currently, the following audio formats are supported:
 ## *) mu-law encoding with extension "mu", "au" or "snd"
 ## *) linear encoding with extension "lin" or "raw"
-## 
+##
 ## The `bit' argument can be either 8 (default) or 16.
 ## Depending on the value of bit, linearly encoded files are
 ## interpreted as being in 8 and 16 bit format, respectively, and
 ## mu-law encoded files are transformed to 8 and 16-bit linear
 ## format, respectively.
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 10 April 1994
 ## Adapted-By: jwe
 
 function X = loadaudio (name, ext, bit)
-  
+
   if (nargin == 0 || nargin > 3)
     usage ("loadaudio (name [, ext [, bit]])");
   endif
 
   if (nargin == 1)
     ext = "lin";
   endif
 
@@ -71,13 +71,13 @@ function X = loadaudio (name, ext, bit)
     endif
     X = mu2lin (Y, bit);
   else
     fclose (num);
     error ("loadaudio does not support given extension");
   endif
 
   fclose (num);
-  
+
 endfunction
 
 
 
diff --git a/scripts/audio/mu2lin.m b/scripts/audio/mu2lin.m
--- a/scripts/audio/mu2lin.m
+++ b/scripts/audio/mu2lin.m
@@ -16,39 +16,39 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## usage: y = mu2lin (x [, bit])
 ##
 ## If x is a vector of audio data with mu-law encoding, mu2lin (x)
 ## holds the same data with linear encoding.
-## The optional argument bit specifies whether the input data is 
+## The optional argument bit specifies whether the input data is
 ## 8 bit (default) or 16 bit.
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 18 October 1994
 ## Adapted-By: jwe
 
 function y = mu2lin (x, bit)
-  
+
   if (nargin == 1)
     bit = 8;
   elseif (nargin == 2)
     if (bit != 8 && bit != 16)
       error ("mu2lin: bit must be either 8 or 16");
     endif
   else
     usage ("y = mu2lin (x [, bit])");
   endif
 
   if (! is_vector (x))
     error ("mu2lin: x must be a vector");
   endif
-  
+
   exp_lut = [0; 132; 396; 924; 1980; 4092; 8316; 16764];
 
   ## invert x bitwise
   x = 255 - x;
 
   ## determine sign of y
   sig = (x > 127);
 
diff --git a/scripts/audio/playaudio.m b/scripts/audio/playaudio.m
--- a/scripts/audio/playaudio.m
+++ b/scripts/audio/playaudio.m
@@ -12,41 +12,41 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## usage: playaudio (name [, ext]) 
+## usage: playaudio (name [, ext])
 ##        playaudio (X)
 ##
 ## `playaudio ("name" [, "ext"])' plays the audio file "name.ext". The
 ## default value for the "ext" argument, which has to be written
 ## without the initial ".", is "lin".
 ## Currently, the following audio formats are suppored:
 ## *) linear encoding with extension "lin" or "raw", played using
-##    /dev/dsp 
+##    /dev/dsp
 ## *) mu-law encoding with extension "mu", "au" or "snd", played
-##    using /dev/audio 
+##    using /dev/audio
 ##
 ## `playaudio (X)' plays the audio data contained in the vector X.
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 11 April 1994
 ## Adapted-By: jwe
 
 function playaudio (name, ext)
-  
+
   file = octave_tmp_file_name ();
 
   usage_msg = "playaudio (name [, ext])  or  playaudio (X)";
-  
-  if (nargin == 1 && is_vector (name) && ! isstr (name)) 
+
+  if (nargin == 1 && is_vector (name) && ! isstr (name))
     ## play a vector
     [nr, nc] = size (name);
     if (nc != 1)
       if (nr == 1)
 	name = name';
 	nr = nc;
       else
 	error ("playaudio: X must be a vector");
diff --git a/scripts/audio/saveaudio.m b/scripts/audio/saveaudio.m
--- a/scripts/audio/saveaudio.m
+++ b/scripts/audio/saveaudio.m
@@ -16,30 +16,30 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## usage:  saveaudio (name, X, [, ext [, bit]])
 ##
 ## Saves a vector X of audio data in the file "name.ext".
 ## The format of the audio file is determined by ext which has to be
-## written without an inital ".";  default value for ext is "lin". 
+## written without an inital ".";  default value for ext is "lin".
 ##
 ## Currently, the following audio formats are supported:
 ## *) mu-law files with extension "mu", "au" or "snd"
 ## *) linearly encoded files with extension "lin" or "raw"
 ## If the data is saved linearly, the bit argument decides whether an
 ## 8-bit (default) or a 16-bit format is used.
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 5 September 1994
 ## Adapted-By: jwe
 
 function saveaudio (name, X, ext, bit)
-  
+
   if (nargin < 2 || nargin > 4)
     usage ("saveaudio (X, name [, ext [, bit]])");
   endif
 
   if (nargin == 2)
     ext = "lin";
   endif
 
@@ -56,17 +56,17 @@ function saveaudio (name, X, ext, bit)
       nr = nc;
     else
       error ("saveaudio: X must be a vector.");
     endif
   endif
 
   num = fopen ([name, ".", ext], "w");
 
-  if (strcmp (ext, "lin") || strcmp (ext, "raw")) 
+  if (strcmp (ext, "lin") || strcmp (ext, "raw"))
     if (bit == 8)
       ld = max (abs (X));
       if (ld > 127)   # convert 16 to 8 bit
 	if (ld < 16384)
 	  sc = 64 / ld;
 	else
 	  sc = 1 / 256;
 	endif
@@ -81,10 +81,10 @@ function saveaudio (name, X, ext, bit)
     Y = lin2mu (X);
     c = fwrite (num, Y, "uchar");
   else
     fclose (num);
     error ("saveaudio does not support given extension");
   endif
 
   fclose (num);
-  
+
 endfunction
diff --git a/scripts/audio/setaudio.m b/scripts/audio/setaudio.m
--- a/scripts/audio/setaudio.m
+++ b/scripts/audio/setaudio.m
@@ -21,20 +21,20 @@
 ##
 ## executes the shell command `mixer [w_type [, value]]'
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 5 October 1994
 ## Adapted-By: jwe
 
 function setaudio (w_type, value)
-  
+
   if (nargin == 0)
     system ("mixer");
   elseif (nargin == 1)
     system (sprintf ("mixer %s", w_type));
   elseif (nargin == 2)
     system (sprintf ("mixer %s %d", w_type, value));
   else
     usage ("setaudio ([w_type [, value]])");
   endif
-  
+
 endfunction
diff --git a/scripts/control/are.m b/scripts/control/are.m
--- a/scripts/control/are.m
+++ b/scripts/control/are.m
@@ -72,17 +72,17 @@ function x = are (a, b, c, opt)
     if (n != m || n != p)
       error ("are: a, b, c not conformably dimensioned.");
     endif
 
     ## Should check for controllability/observability here
     ## use Boley-Golub (Syst. Contr. Letters, 1984) method, not the
     ##
     ##                     n-1
-    ## rank ([ B A*B ... A^   *B]) method 
+    ## rank ([ B A*B ... A^   *B]) method
 
     [d, h] = balance ([a, -b; -c, -a'], opt);
     [u, s] = schur (h, "A");
     u = d * u;
     n1 = n + 1;
     n2 = 2 * n;
     x = u (n1:n2, 1:n) / u (1:n, 1:n);
   else
diff --git a/scripts/control/dare.m b/scripts/control/dare.m
--- a/scripts/control/dare.m
+++ b/scripts/control/dare.m
@@ -22,30 +22,30 @@
 ## Solves discrete-time algebraic riccati equation
 ##
 ##   a' x a - x + a' x b (r + b' x b)^{-1} b' x a + c = 0
 ##
 ## for
 ##
 ##   a: nxn
 ##   b: nxm
-##   c: nxn, symmetric positive semidefinite 
+##   c: nxn, symmetric positive semidefinite
 ##   r: mxm, invertible
 ##
 ## If c is not square, then the function attempts to use c'*c instead.
 ##
 ## Solution method: Laub's Schur method (IEEE Trans Auto Contr, 1979) applied
 ## to the appropriate symplectic matrix.
 ##
 ## See also: Ran and Rodman, "Stable Hermitian Solutions of Discrete
 ## Algebraic Riccati Equations," Mathematics of Control, Signals and
 ## Systems, Vol 5, no 2 (1992)  pp 165-194.
 ##
 ## opt is an option passed to the eigenvalue balancing routine default
-## is "B". 
+## is "B".
 ##
 ## See also: balance, are
 
 ## Author: A. S. Hodel <scotte@eng.auburn.edu>
 ## Created: August 1993
 ## Adapted-By: jwe
 
 function x = dare (a, b, c, r, opt)
diff --git a/scripts/control/dlqe.m b/scripts/control/dlqe.m
--- a/scripts/control/dlqe.m
+++ b/scripts/control/dlqe.m
@@ -14,28 +14,28 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## Usage: [l, m, p, e] = dlqe (A, G, C, SigW, SigV {,Z})
 ##
-## Linear quadratic estimator (Kalman filter) design for the 
+## Linear quadratic estimator (Kalman filter) design for the
 ## discrete time system
 ##
 ##  x[k+1] = A x[k] + B u[k] + G w[k]
 ##    y[k] = C x[k] + D u[k] + w[k]
 ##
 ## where w, v are zero-mean gaussian noise processes with respective
 ## intensities SigW = cov (w, w) and SigV = cov (v, v).
 ##
 ## Z (if specified) is cov(w,v); otherwise cov(w,v) = 0.
 ##
-## Observer structure is 
+## Observer structure is
 ##     z[k+1] = A z[k] + B u[k] + k(y[k] - C z[k] - D u[k]).
 ##
 ## Returns:
 ##
 ##   l = observer gain, (A - A L C) is stable
 ##   m = Ricatti equation solution
 ##   p = the estimate error covariance after the measurement update
 ##   e = closed loop poles of (A - A L C)
diff --git a/scripts/control/dlqr.m b/scripts/control/dlqr.m
--- a/scripts/control/dlqr.m
+++ b/scripts/control/dlqr.m
@@ -55,17 +55,17 @@ function [k, p, e] = dlqr (a, b, q, r, z
 
   ## Check b.
   [n1, m] = size (b);
   if (n1 != n)
     error ("dlqr: a,b not conformal");
   endif
 
   ## Check q.
-  
+
   if ((n1 = is_square (q)) == 0 || n1 != n)
     error ("dlqr: q must be square and conformal with a");
   endif
 
   ## Check r.
   if((m1 = is_square(r)) == 0 || m1 != m)
     error ("dlqr: r must be square and conformal with column dimension of b");
   endif
diff --git a/scripts/control/dlyap.m b/scripts/control/dlyap.m
--- a/scripts/control/dlyap.m
+++ b/scripts/control/dlyap.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## Usage: x = dlyap (a, b)
 ##
 ## Solve a x a' - x + b = 0 (discrete Lyapunov equation) for square
-## matrices a and b.  If b is not square, then the function attempts 
+## matrices a and b.  If b is not square, then the function attempts
 ## to solve either
 ##
 ##  a x a' - x + b b' = 0
 ##
 ## or
 ##
 ##  a' x a - x + b' b = 0
 ##
diff --git a/scripts/control/lqe.m b/scripts/control/lqe.m
--- a/scripts/control/lqe.m
+++ b/scripts/control/lqe.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## Usage: [k, p, e] = lqe (A, G, C, SigW, SigV {,Z})
 ##
-## Linear quadratic estimator (Kalman filter) design for the 
+## Linear quadratic estimator (Kalman filter) design for the
 ## continuous time system
 ##
 ##   dx/dt = A x + B u + G w
 ##       y = C x + D u + v
 ##
 ## where w, v are zero-mean gaussian noise processes with respective
 ## intensities SigW = cov (w, w) and SigV = cov (v, v).
 ##
diff --git a/scripts/control/lqr.m b/scripts/control/lqr.m
--- a/scripts/control/lqr.m
+++ b/scripts/control/lqr.m
@@ -54,17 +54,17 @@ function [k, p, e] = lqr (a, b, q, r, zz
 
   ## Check b.
   [n1, m] = size (b);
   if (n1 != n)
     error ("lqr: a,b not conformal");
   endif
 
   ## Check q.
-  
+
   if ((n1 = is_square (q)) == 0 || n1 != n)
     error ("lqr: q must be square and conformal with a");
   endif
 
   ## Check r.
   if((m1 = is_square(r)) == 0 || m1 != m)
     error ("lqr: r must be square and conformal with column dimension of b");
   endif
diff --git a/scripts/control/lyap.m b/scripts/control/lyap.m
--- a/scripts/control/lyap.m
+++ b/scripts/control/lyap.m
@@ -19,24 +19,24 @@
 
 ## Usage: x = lyap (a, b {,c})
 ##
 ## If (a, b, c) are specified, then lyap returns the solution of the
 ## Sylvester equation
 ##
 ##   a x + x b + c = 0
 ##
-## If only (a, b) are specified, then lyap returns the solution of the 
+## If only (a, b) are specified, then lyap returns the solution of the
 ## Lyapunov equation
 ##
 ##   a' x + x a + b = 0
 ##
 ## If b is not square, then lyap returns the solution of either
 ##
-##   a' x + x a + b' b = 0 	
+##   a' x + x a + b' b = 0
 ##
 ## or
 ##
 ##   a x + x a' + b b' = 0
 ##
 ## whichever is appropriate.
 ##
 ## Solves by using the Bartels-Stewart algorithm (1972).
@@ -61,17 +61,17 @@ function x = lyap (a, b, c)
 
     if ((m = is_square (b)) == 0)
       if ((m = rows (b)) == n)
 
 	## solve a x + x a' + b b' = 0
 
 	b = b * b';
 	a = a';
-      else 
+      else
 
 	## Try to solve a'x + x a + b' b = 0.
 
 	m = columns (b);
 	b = b' * b;
       endif
 
       if (m != n)
@@ -80,17 +80,17 @@ function x = lyap (a, b, c)
     endif
 
     ## Set up Sylvester equation.
 
     c = b;
     b = a;
     a = b';
 
-  else 
+  else
 
     ## Check dimensions.
 
     if ((m = is_square (b)) == 0)
       error ("lyap: b must be square in a sylvester equation");
     endif
 
     [n1, m1] = size(c);
diff --git a/scripts/elfun/acoth.m b/scripts/elfun/acoth.m
--- a/scripts/elfun/acoth.m
+++ b/scripts/elfun/acoth.m
@@ -12,17 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## acoth (z):  compute the inverse hyperbolic cotangent for each element of z. 
+## acoth (z):  compute the inverse hyperbolic cotangent for each element of z.
 
 ## Author: jwe
 
 function w = acoth (z)
 
   if (nargin != 1)
     usage ("acoth (z)");
   endif
diff --git a/scripts/elfun/acsc.m b/scripts/elfun/acsc.m
--- a/scripts/elfun/acsc.m
+++ b/scripts/elfun/acsc.m
@@ -17,16 +17,16 @@
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## acsc (z):  compute the inverse cosecant for each element of z.
 
 ## Author: jwe
 
 function w = acsc (z)
-  
+
   if (nargin != 1)
     usage ("acsc (z)");
   endif
 
   w = asin (1 ./ z);
-  
+
 endfunction
\ No newline at end of file
diff --git a/scripts/elfun/acsch.m b/scripts/elfun/acsch.m
--- a/scripts/elfun/acsch.m
+++ b/scripts/elfun/acsch.m
@@ -17,16 +17,16 @@
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## acsch (z):  compute the inverse hyperbolic cosecant for each element of z.
 
 ## Author: jwe
 
 function w = acsch (z)
-  
+
   if (nargin != 1)
     usage ("acsch (z)");
   endif
 
   w = asinh (1 ./ z);
-  
+
 endfunction
\ No newline at end of file
diff --git a/scripts/elfun/asec.m b/scripts/elfun/asec.m
--- a/scripts/elfun/asec.m
+++ b/scripts/elfun/asec.m
@@ -17,16 +17,16 @@
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## asec (z):  compute the inverse secant for each element of z.
 
 ## Author: jwe
 
 function w = asec (z)
-  
+
   if (nargin != 1)
     usage ("asec (z)");
   endif
 
   w = acos (1 ./ z);
-  
+
 endfunction
\ No newline at end of file
diff --git a/scripts/elfun/asech.m b/scripts/elfun/asech.m
--- a/scripts/elfun/asech.m
+++ b/scripts/elfun/asech.m
@@ -17,16 +17,16 @@
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## asech (z):  compute the inverse hyperbolic secant for each element of z.
 
 ## Author: jwe
 
 function w = asech (z)
-  
+
   if (nargin != 1)
     usage ("acosh (z)");
   endif
 
   w = acosh (1 ./ z);
-  
+
 endfunction
diff --git a/scripts/elfun/cot.m b/scripts/elfun/cot.m
--- a/scripts/elfun/cot.m
+++ b/scripts/elfun/cot.m
@@ -17,16 +17,16 @@
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## cot (z):  compute the cotangent for each element of z.
 
 ## Author: jwe
 
 function w = cot (z)
-  
+
   if (nargin != 1)
     usage ("cot (z)");
   endif
 
   w = 1 ./ tan(z);
-  
+
 endfunction
\ No newline at end of file
diff --git a/scripts/elfun/coth.m b/scripts/elfun/coth.m
--- a/scripts/elfun/coth.m
+++ b/scripts/elfun/coth.m
@@ -17,16 +17,16 @@
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## coth (z):  compute the hyperbolic cotangent for each element of z.
 
 ## Author: jwe
 
 function w = coth (z)
-  
+
   if (nargin != 1)
     usage ("coth (z)");
   endif
 
   w = 1 ./ tanh(z);
-  
+
 endfunction
\ No newline at end of file
diff --git a/scripts/elfun/csc.m b/scripts/elfun/csc.m
--- a/scripts/elfun/csc.m
+++ b/scripts/elfun/csc.m
@@ -17,16 +17,16 @@
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## csc (z):  compute the cosecant for each element of z.
 
 ## Author: jwe
 
 function w = csc (z)
-  
+
   if (nargin != 1)
     usage ("csc (z)");
   endif
 
   w = 1 ./ sin(z);
-  
+
 endfunction
diff --git a/scripts/elfun/csch.m b/scripts/elfun/csch.m
--- a/scripts/elfun/csch.m
+++ b/scripts/elfun/csch.m
@@ -17,16 +17,16 @@
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## csch (z):  compute the hyperbolic cosecant for each element of z.
 
 ## Author: jwe
 
 function w = csch (z)
-  
+
   if (nargin != 1)
     usage ("csch (z)");
   endif
 
   w = 1 ./ sinh(z);
-  
+
 endfunction
diff --git a/scripts/elfun/gcd.m b/scripts/elfun/gcd.m
--- a/scripts/elfun/gcd.m
+++ b/scripts/elfun/gcd.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## usage: gcd (a, ...)
-##  
+##
 ## [g [, v]] = gcd (a) returns the greatest common divisor g of the
 ## entries of the integer vector a, and an integer vector v such that
 ## g = v(1) * a(k) + ... + v(k) * a(k).
 ##
 ## [g [, v]] = gcd (a1, ..., ak) is the same with a = [a1, ..., ak].
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 16 September 1994
@@ -32,29 +32,28 @@
 function [g, v] = gcd (a, ...)
 
   if (nargin > 1)
     va_start;
     for k = 2:nargin;
       a = [a, (va_arg ())];
     endfor
   endif
-  
+
   if (round (a) != a)
     error ("gcd: all arguments must be integer");
   endif
-  
+
   g = abs (a(1));
   v = sign (a(1));
   for k = 1:(length (a) - 1)
     x = [g, 1, 0];
     y = [(abs (a(k+1))), 0, 1];
     while (y(1) > 0)
       r = x - y * floor (x(1) / y(1));
       x = y;
       y = r;
     endwhile
     g = x(1);
     v = [x(2) * v, x(3) * (sign (a(k+1)))];
   endfor
-    
+
 endfunction
-    
\ No newline at end of file
diff --git a/scripts/elfun/lcm.m b/scripts/elfun/lcm.m
--- a/scripts/elfun/lcm.m
+++ b/scripts/elfun/lcm.m
@@ -29,25 +29,24 @@
 
 function l = lcm (a, ...)
 
     va_start;
     for k = 2:nargin;
       a = [a, (va_arg ())];
     endfor
   endif
-  
+
   if (round (a) != a)
     error ("lcm:  all arguments must be integer");
   endif
-  
+
   if (any (a) == 0)
     l = 0;
   else
     a = abs (a);
     l = a (1);
     for k = 1:(length (a) - 1)
       l = l * a(k+1) / gcd (l, a(k+1));
     endfor
   endif
-    
+
 endfunction
-    
\ No newline at end of file
diff --git a/scripts/elfun/log2.m b/scripts/elfun/log2.m
--- a/scripts/elfun/log2.m
+++ b/scripts/elfun/log2.m
@@ -17,16 +17,16 @@
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## log2 (z):  compute the logarithm base 2 for each element of z.
 
 ## Author: jwe
 
 function w = log2 (z)
-  
+
 if (nargin != 1)
     usage ("log2 (z)");
   endif
 
   w = log(z) / log(2);
-  
+
 endfunction
\ No newline at end of file
diff --git a/scripts/elfun/sec.m b/scripts/elfun/sec.m
--- a/scripts/elfun/sec.m
+++ b/scripts/elfun/sec.m
@@ -17,16 +17,16 @@
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## sec (z): compute the secant for each element of z.
 
 ## Author: jwe
 
 function w = sec (z)
-  
+
   if (nargin != 1)
     usage ("sec (z)");
   endif
-  
+
   w = 1 ./ cos(z);
-  
+
 endfunction
diff --git a/scripts/elfun/sech.m b/scripts/elfun/sech.m
--- a/scripts/elfun/sech.m
+++ b/scripts/elfun/sech.m
@@ -17,16 +17,16 @@
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## sech (z):  compute the hyperbolic secant for each element of z.
 
 ## Author: jwe
 
 function w = sech (z)
-  
+
 if (nargin != 1)
     usage ("sech (z)");
   endif
 
   w = 1 ./ cosh(z);
-  
+
 endfunction
diff --git a/scripts/general/int2str.m b/scripts/general/int2str.m
--- a/scripts/general/int2str.m
+++ b/scripts/general/int2str.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## usage: int2str (x)
 ##
 ## Round x to the nearest integer and format as a string.
 ##
-## See also: sprintf, num2str 
+## See also: sprintf, num2str
 
 ## Author: jwe
 
 function retval = int2str (x)
 
   ## XXX FIXME XXX -- this will fail for very large values.
 
   if (nargin == 1)
diff --git a/scripts/general/is_square.m b/scripts/general/is_square.m
--- a/scripts/general/is_square.m
+++ b/scripts/general/is_square.m
@@ -27,17 +27,17 @@
 ## Author: A. S. Hodel <scotte@eng.auburn.edu>
 ## Created: August 1993
 ## Adapted-By: jwe
 
 function retval = is_square (x)
 
   if (nargin == 1)
     [nr, nc] = size (x);
-    if (nr == nc) 
+    if (nr == nc)
       retval = nr;
     else
       retval = 0;
     endif
   else
     usage ("is_square (x)");
   endif
 
diff --git a/scripts/general/is_symmetric.m b/scripts/general/is_symmetric.m
--- a/scripts/general/is_symmetric.m
+++ b/scripts/general/is_symmetric.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## Usage: is_symmetric (x {,tol})
 ##
 ## If x is symmetric, return the dimension of x, otherwise, return 0.
 ##
-## See also: size, rows, columns, length, is_matrix, is_scalar, 
+## See also: size, rows, columns, length, is_matrix, is_scalar,
 ## is_square, is_vector
 
 ## Author: A. S. Hodel <scotte@eng.auburn.edu>
 ## Created: August 1993
 ## Adapted-By: jwe
 
 function retval = is_symmetric (x,tol)
 
diff --git a/scripts/general/is_vector.m b/scripts/general/is_vector.m
--- a/scripts/general/is_vector.m
+++ b/scripts/general/is_vector.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## usage: is_vector (x)
 ##
 ## Return 1 if the either the number of rows (columns) of x is 1 and
-## the number of columns (rows) is greater than one.  Otherwise, return 0. 
+## the number of columns (rows) is greater than one.  Otherwise, return 0.
 ##
 ## See also: size, rows, columns, length, is_scalar, is_matrix
 
 ## Author: jwe
 
 function retval = is_vector (x)
 
   if (nargin == 1)
diff --git a/scripts/general/logspace.m b/scripts/general/logspace.m
--- a/scripts/general/logspace.m
+++ b/scripts/general/logspace.m
@@ -19,17 +19,17 @@
 
 ## usage: logspace (x1, x2, n)
 ##
 ## Return a vector of n logarithmically equally spaced points between
 ## x1 and x2 inclusive.
 ##
 ## If the final argument is omitted, n = 50 is assumed.
 ##
-## All three arguments must be scalars. 
+## All three arguments must be scalars.
 ##
 ## Note that if if x2 is pi, the points are between 10^x1 and pi, NOT
 ## 10^x1 and 10^pi.
 ##
 ## Yes, this is pretty stupid, because you could achieve the same
 ## result with logspace (x1, log10 (pi)), but Matlab does this, and
 ## claims that is useful for signal processing applications.
 ##
@@ -41,17 +41,17 @@ function retval = logspace (x1, x2, n)
 
   if (nargin == 2)
     npoints = 50;
   elseif (nargin == 3)
     if (length (n) == 1)
       npoints = fix (n);
     else
       error ("logspace: arguments must be scalars");
-    endif  
+    endif
   else
     usage ("logspace (x1, x2 [, n])");
   endif
 
   if (npoints < 2)
     error ("logspace: npoints must be greater than 2");
   endif
 
diff --git a/scripts/image/colormap.m b/scripts/image/colormap.m
--- a/scripts/image/colormap.m
+++ b/scripts/image/colormap.m
@@ -13,25 +13,25 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## Set the current colormap.
-## 
+##
 ## colormap (map) sets the current colormap to map.  map should be an n
 ## row by 3 column matrix. The columns contain red, green, and blue
 ## intensities respectively.  All entries should be between 0 and 1
 ## inclusive. The new colormap is returned.
-## 
+##
 ## colormap ("default") restores the default colormap (a gray scale
 ## colormap with 64 entries). The default colormap is returned.
-## 
+##
 ## colormap with no arguments returns the current colormap.
 
 ## Author: Tony Richardson <amr@mpl.ucsd.edu>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function cmap = colormap (map)
 
diff --git a/scripts/image/loadimage.m b/scripts/image/loadimage.m
--- a/scripts/image/loadimage.m
+++ b/scripts/image/loadimage.m
@@ -39,12 +39,12 @@ function [X, map] = loadimage (filename)
 
   file = file_in_path (IMAGEPATH, filename);
 
   if (isempty (file))
     error ("loadimage: unable to find image file");
   endif
 
   ## XXX FIXME XXX -- file is assumed to have variables X and map.
-  
+
   eval (['load ', file]);
 
 endfunction
diff --git a/scripts/image/ocean.m b/scripts/image/ocean.m
--- a/scripts/image/ocean.m
+++ b/scripts/image/ocean.m
@@ -31,17 +31,17 @@ function map = ocean (number)
     if (! is_scalar (number))
       error ("ocean: argument must be a scalar");
     endif
   else
     usage ("ocean (number)");
   endif
 
   cutin = fix (number/3);
-  
+
   dr = (number - 1) / cutin;
 
   r = prepad ([0:dr:(number-1)], number)';
 
   dg = (number - 1) / (2 * cutin);
 
   g = prepad([0:dg:(number-1)], number)';
 
diff --git a/scripts/image/saveimage.m b/scripts/image/saveimage.m
--- a/scripts/image/saveimage.m
+++ b/scripts/image/saveimage.m
@@ -37,33 +37,33 @@
 ##
 ## Note: If the colormap contains only two entries and these entries
 ## are black and white, the bitmap ppm and PostScript formats are used.
 ## If the image is a gray scale image (the entries within each row of
 ## the colormap are equal) the gray scale ppm and PostScript image
 ## formats are used, otherwise the full color formats are used.
 ##
 ## The conversion to PostScript is based on pbmtolps.c, which was
-## written by 
+## written by
 ##
 ##   George Phillips <phillips@cs.ubc.ca>
 ##   Department of Computer Science
 ##   University of British Columbia
 ##
 ## and is part of the portable bitmap utilities,
 ##
 ## SEE ALSO: loadimage, save, load, colormap
 
 ## Author: Tony Richardson <amr@mpl.ucsd.edu>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 ## Rewritten by jwe to avoid using octoppm and pbm routines so that
 ## people who don't have the the pbm stuff installed can still use this
-## function. 
+## function.
 ##
 ## The conversion to PostScript is based on pnmtops.c, which is part of
 ## the portable bitmap utilties and bears this copyright notice:
 ##
 ## Copyright (C) 1989 by Jef Poskanzer.
 ##
 ## Permission to use, copy, modify, and distribute this software and its
 ## documentation for any purpose and without fee is hereby granted, provided
diff --git a/scripts/linear-algebra/kron.m b/scripts/linear-algebra/kron.m
--- a/scripts/linear-algebra/kron.m
+++ b/scripts/linear-algebra/kron.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## Usage: x = kron (a, b)
 ##
 ## Form the Kronecker product of two matrices, defined block by block
-## as 
+## as
 ##
 ##   x = [a(i,j) b]
 
 ## Author: A. S. Hodel <scotte@eng.auburn.edu>
 ## Created: August 1993
 ## Adapted-By: jwe
 
 function x = kron (a, b)
diff --git a/scripts/linear-algebra/null.m b/scripts/linear-algebra/null.m
--- a/scripts/linear-algebra/null.m
+++ b/scripts/linear-algebra/null.m
@@ -20,17 +20,17 @@
 ## usage: null (A, tol)
 ##        null (A)
 ##
 ## Returns an orthonormal basis of the null space of A.
 ##
 ## The dimension of the null space is taken as the number of singular
 ## values of A not greater than tol;  the default for tol is
 ## max (size (A)) * sigma_max (A) * eps, where sigma_max (A) is the
-## maximal singular value of A. 
+## maximal singular value of A.
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 24 December 1993.
 ## Adapted-By: jwe
 
 function retval = null (A, tol)
 
   [U, S, V] = svd (A);
@@ -43,17 +43,17 @@ function retval = null (A, tol)
     s = S(1);
   else
     s = diag (S);
   endif
 
   if (nargin == 1)
     tol = max (size (A)) * s (1) * eps;
   elseif (nargin != 2)
-    usage ("null (A [, tol])"); 
+    usage ("null (A [, tol])");
   endif
 
   rank = sum (s > tol);
 
   if (rank < cols)
     retval = V (:, rank+1:cols);
   else
     retval = zeros (cols, 0);
diff --git a/scripts/linear-algebra/orth.m b/scripts/linear-algebra/orth.m
--- a/scripts/linear-algebra/orth.m
+++ b/scripts/linear-algebra/orth.m
@@ -43,17 +43,17 @@ function retval = orth (A, tol)
     s = S(1);
   else
     s = diag (S);
   endif
 
   if (nargin == 1)
     tol = max (size (A)) * s (1) * eps;
   elseif (nargin != 2)
-    usage ("orth (A [, tol])"); 
+    usage ("orth (A [, tol])");
   endif
 
   rank = sum (s > tol);
 
   if (rank > 0)
     retval = -U (:, 1:rank);
   else
     retval = zeros (rows, 0);
diff --git a/scripts/miscellaneous/popen2.m b/scripts/miscellaneous/popen2.m
--- a/scripts/miscellaneous/popen2.m
+++ b/scripts/miscellaneous/popen2.m
@@ -56,17 +56,17 @@ function [in, out, pid] = popen2 (comman
 
       [stdin_pipe, stdin_status] = pipe ();
       [stdout_pipe, stdout_status] = pipe ();
 
       if (stdin_status == 0 && stdout_status == 0)
 
 	pid = fork ();
 
-	if (pid == 0) 
+	if (pid == 0)
 
 	  fclose (stdin_pipe (2));
 	  fclose (stdout_pipe (1));
 
 	  dup2 (stdin_pipe (1), stdin);
 	  fclose (stdin_pipe (1));
 
 	  dup2 (stdout_pipe (2), stdout);
@@ -84,17 +84,17 @@ function [in, out, pid] = popen2 (comman
 
 	  if (fcntl (stdout_pipe (1), __F_SETFL__, __O_NONBLOCK__) < 0)
 	    error ("popen2: error setting file mode");
 	  else
 	    in = stdin_pipe (2);
 	    out = stdout_pipe (1);
 	  endif
 
-	elseif (pid < 0) 
+	elseif (pid < 0)
 	  error ("popen2: fork failed -- unable to create child process");
 	endif
       else
 	error ("popen2: pipe creation failed");
       endif
     else
       error ("popen2: file name must be a string");
     endif
diff --git a/scripts/plot/__plt__.m b/scripts/plot/__plt__.m
--- a/scripts/plot/__plt__.m
+++ b/scripts/plot/__plt__.m
@@ -60,17 +60,17 @@ function __plt__ (caller, ...)
 	elseif (x_set)
 	  if (y_set)
 	    __plt2__ (x, y, fmt);
 	    hold on;
 	    x = new;
 	    y_set = 0;
 	  else
 	    y = new;
-	    y_set = 1;          
+	    y_set = 1;
 	  endif
 	else
 	  x = new;
 	  x_set = 1;
 	endif
 
       endwhile
 
diff --git a/scripts/plot/axis.m b/scripts/plot/axis.m
--- a/scripts/plot/axis.m
+++ b/scripts/plot/axis.m
@@ -21,17 +21,17 @@
 ##        axis ([xmin, xmax])
 ##        axis ([xmin, xmax, ymin, ymax])
 ##        axis ([xmin, xmax, ymin, ymax, zmin, zmax])
 ##
 ## Sets the axis limits.
 ##
 ## With no arguments, turns autoscaling on.
 ##
-## If your plot is already drawn, then you need to REPLOT before 
+## If your plot is already drawn, then you need to REPLOT before
 ## the new axis limits will take effect.
 
 ## Author: jwe
 
 function curr_axis = axis (ax)
 
   ## This may not be correct if someone has used the gnuplot interface
   ## directly...
diff --git a/scripts/plot/bar.m b/scripts/plot/bar.m
--- a/scripts/plot/bar.m
+++ b/scripts/plot/bar.m
@@ -32,17 +32,17 @@
 ## and
 ##
 ##   [xb, yb] = bar (x, y);
 ##   plot (xb, yb);
 ##
 ## are equivalent.
 ##
 ## See also: plot, semilogx, semilogy, loglog, polar, mesh, contour,
-##           stairs, gplot, gsplot, replot, xlabel, ylabel, title 
+##           stairs, gplot, gsplot, replot, xlabel, ylabel, title
 
 ## Author: jwe
 
 function [xb, yb] = bar (x, y)
 
   if (nargin == 1)
     if (is_vector (x))
       len = 3 * length (x) + 1;
diff --git a/scripts/plot/bottom_title.m b/scripts/plot/bottom_title.m
--- a/scripts/plot/bottom_title.m
+++ b/scripts/plot/bottom_title.m
@@ -17,29 +17,29 @@
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## usage: bottom_title (text)
 ##
 ## NOTE: this will work only with gnuplot installed with
 ##       multiplot patch
 ##
-## makes a title with the given text at the bottom of the plot 
+## makes a title with the given text at the bottom of the plot
 ## rather than the top.
 ##
 
 ## Author: Vinayak Dutt <Dutt.Vinayak@mayo.EDU>
 ## Adapted-By: jwe
 
 function bottom_title (text)
 
   if (! gnuplot_has_multiplot)
     error ("bottom_title: gnuplot does not appear to support this feature");
   endif
-    
+
   if (nargin != 1)
     usage ("bottom_title (text)");
   endif
 
   if (isstr (text))
     set top_title;
     set title;
     eval (sprintf ("set bottom_title \"%s\"", text));
diff --git a/scripts/plot/contour.m b/scripts/plot/contour.m
--- a/scripts/plot/contour.m
+++ b/scripts/plot/contour.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## usage: contour (z, n, x, y)
 ##
 ## See also: plot, semilogx, semilogy, loglog, polar, mesh, contour,
-##           bar, stairs, gplot, gsplot, replot, xlabel, ylabel, title 
+##           bar, stairs, gplot, gsplot, replot, xlabel, ylabel, title
 
 ## Author: jwe
 
 function contour (z, n, x, y)
 
 
   if (nargin == 1)
     n = 10;
@@ -71,14 +71,14 @@ function contour (z, n, x, y)
 	gsplot zz w l 1;
       else
         msg = "mesh: rows (z) must be the same as length (x) and";
         msg = sprintf ("%s\ncolumns (z) must be the same as length (y)", msg);
         error (msg);
       endif
     else
       error ("mesh: x and y must be vectors and z must be a matrix");
-    endif    
+    endif
   else
     usage ("mesh (z, levels, x, y)");
   endif
 
 endfunction
diff --git a/scripts/plot/grid.m b/scripts/plot/grid.m
--- a/scripts/plot/grid.m
+++ b/scripts/plot/grid.m
@@ -19,17 +19,17 @@
 
 ## usage: grid ("on" | "off")
 ##
 ## Turn grid lines on or off for plotting.
 ##
 ## If the argument is omitted, "on" is assumed.
 ##
 ## See also: plot, semilogx, semilogy, loglog, polar, mesh, contour,
-##           bar, stairs, gplot, gsplot, replot, xlabel, ylabel, title 
+##           bar, stairs, gplot, gsplot, replot, xlabel, ylabel, title
 
 ## Author: jwe
 
 function grid (x)
 
   if (nargin == 0)
     set grid;
   elseif (nargin == 1)
diff --git a/scripts/plot/hist.m b/scripts/plot/hist.m
--- a/scripts/plot/hist.m
+++ b/scripts/plot/hist.m
@@ -40,17 +40,17 @@
 
 ## Author: jwe
 
 function [nn, xx] = hist (y, x)
 
   if (nargin < 1 || nargin > 2)
     usage ("[nn, xx] = hist (y, x)");
   endif
-    
+
   if (is_vector (y))
     max_val = max (y);
     min_val = min (y);
   else
     error ("hist: first argument must be a vector");
   endif
 
   if (nargin == 1)
diff --git a/scripts/plot/loglog.m b/scripts/plot/loglog.m
--- a/scripts/plot/loglog.m
+++ b/scripts/plot/loglog.m
@@ -16,23 +16,23 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## usage: loglog (x, y)
 ##        loglog (x1, y1, x2, y2, ...)
 ##        loglog (x, y, fmt)
 ##
-## Make a 2D plot of y versus x using a log scale for the x axis. 
+## Make a 2D plot of y versus x using a log scale for the x axis.
 ##
 ## See the help message for the plot command for a description of how
-## the arguments are interpreted. 
+## the arguments are interpreted.
 ##
 ## See also: plot, semilogy, loglog, polar, mesh, contour, bar, stairs,
-##           gplot, gsplot, replot, xlabel, ylabel, title 
+##           gplot, gsplot, replot, xlabel, ylabel, title
 
 ## Author: jwe
 
 function loglog (...)
 
   set logscale x;
   set logscale y;
   set nopolar;
diff --git a/scripts/plot/mesh.m b/scripts/plot/mesh.m
--- a/scripts/plot/mesh.m
+++ b/scripts/plot/mesh.m
@@ -20,18 +20,18 @@
 ## usage: mesh (x, y, z)
 ##
 ## Surface plot.  If x, y, and z are matrices with the same dimensions,
 ## then corresponding elements represent vertices of the plot.  If x and
 ## y are vectors, then a typical vertex is (x(j), y(i), z(i,j)).  Thus,
 ## columns of z correspond to different x values and rows of z correspond
 ## to different y values.
 ##
-## See also: plot, semilogx, semilogy, loglog, polar, meshgrid, meshdom, 
-##           contour, bar, stairs, gplot, gsplot, replot, xlabel, ylabel, title 
+## See also: plot, semilogx, semilogy, loglog, polar, meshgrid, meshdom,
+##           contour, bar, stairs, gplot, gsplot, replot, xlabel, ylabel, title
 
 ## Author: jwe
 
 function mesh (x, y, z)
 
   if (nargin == 1)
     z = x;
     if (is_matrix (z))
@@ -95,14 +95,14 @@ function mesh (x, y, z)
 	set parametric;
         set view 60, 30, 1, 1
 	gsplot (zz);
       else
         error ("mesh: x, y, and z must have same dimensions");
       endif
     else
       error ("mesh: x and y must be vectors and z must be a matrix");
-    endif    
+    endif
   else
     usage ("mesh (z)");
   endif
 
 endfunction
diff --git a/scripts/plot/meshdom.m b/scripts/plot/meshdom.m
--- a/scripts/plot/meshdom.m
+++ b/scripts/plot/meshdom.m
@@ -20,17 +20,17 @@
 ## usage: [xx, yy] = meshdom (x, y)
 ##
 ## Given vectors of x and y coordinates, return two matrices
 ## corresponding to the x and y coordinates of the mesh.
 ##
 ## See the file sombrero.m for an example of using mesh and meshdom.
 ##
 ## See also: plot, semilogx, semilogy, loglog, polar, mesh, contour,
-##           bar, stairs, gplot, gsplot, replot, xlabel, ylabel, title 
+##           bar, stairs, gplot, gsplot, replot, xlabel, ylabel, title
 
 ## Author: jwe
 
 function [xx, yy] = meshdom (x, y)
 
   if (nargin == 2)
     if (is_vector (x) && is_vector (y))
       xlen = length (x);
diff --git a/scripts/plot/meshgrid.m b/scripts/plot/meshgrid.m
--- a/scripts/plot/meshgrid.m
+++ b/scripts/plot/meshgrid.m
@@ -21,17 +21,17 @@
 ##
 ## Given vectors of x and y coordinates, return two matrices corresponding
 ## to the x and y coordinates of a mesh.  The rows of xx are copies of x,
 ## and the columns of yy are copies of y.
 ##
 ## [xx, yy] = meshgrid (x) is an abbreviation for [xx, yy] = meshgrid (x, x).
 ##
 ## See also: plot, semilogx, semilogy, loglog, polar, mesh, meshdom, contour,
-##           bar, stairs, gplot, gsplot, replot, xlabel, ylabel, title 
+##           bar, stairs, gplot, gsplot, replot, xlabel, ylabel, title
 
 ## Author: jwe
 
 function [xx, yy] = meshgrid (x, y)
 
   if (nargin == 1)
     y = x;
   endif
diff --git a/scripts/plot/multiplot.m b/scripts/plot/multiplot.m
--- a/scripts/plot/multiplot.m
+++ b/scripts/plot/multiplot.m
@@ -18,31 +18,31 @@
 ## 02111-1307, USA.
 
 ## usage: multiplot (xn, yn)
 ##
 ## Sets and resets multiplot mode
 ##
 ## If multiplot(0,0) then it will close multiplot mode and and if
 ## arguments are non-zero, then it will set up multiplot mode with
-## xn,yn subplots along x and y axes. 
+## xn,yn subplots along x and y axes.
 ##
 ## NOTE: this will work only with gnuplot installed with
 ##       multiplot patch
 
 ## Author: Vinayak Dutt, Dutt.Vinayak@mayo.EDU
 ## Created: 3 July 95
 ## Adapted-By: jwe
 
 function multiplot (xn, yn)
 
   if (! gnuplot_has_multiplot)
     error ("multiplot: gnuplot does not appear to support this feature");
   endif
-    
+
   ## global variables to keep track of multiplot options
 
   global multiplot_mode
   global multiplot_xsize multiplot_ysize
   global multiplot_xn multiplot_yn
   global multiplot_xi multiplot_yi
 
   ## This is a real kludge.  We gnuplot should be made so that replot can
diff --git a/scripts/plot/oneplot.m b/scripts/plot/oneplot.m
--- a/scripts/plot/oneplot.m
+++ b/scripts/plot/oneplot.m
@@ -12,34 +12,34 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## usage: oneplot 
+## usage: oneplot
 ##
 ## NOTE: this will work only with gnuplot installed with
 ##       multiplot patch
 ##
 ## Switches from multiplot (if in  multiplot mode) to single plot
 ## mode
 
 ## Author: Vinayak Dutt <Dutt.Vinayak@mayo.EDU>
 ## Created: 3 July 95
 ## Adapted-By: jwe
 
 function oneplot ()
 
   if (! gnuplot_has_multiplot)
     error ("oneplot: gnuplot does not appear to support this feature");
   endif
-    
+
   global multiplot_mode
 
   set nomultiplot;
   set size 1, 1;
   set origin 0, 0;
   multiplot_mode = 0;
 
 endfunction
diff --git a/scripts/plot/plot.m b/scripts/plot/plot.m
--- a/scripts/plot/plot.m
+++ b/scripts/plot/plot.m
@@ -54,17 +54,17 @@
 ##     y3 will be plotted with lines of color 4.
 ##     y4 will be plotted with points which are "+"s.
 ##
 ##   plot (b, "*")
 ##
 ##     b will be plotted with points of type "*".
 ##
 ## See also: semilogx, semilogy, loglog, polar, mesh, contour, __pltopt__
-##           bar, stairs, gplot, gsplot, replot, xlabel, ylabel, title 
+##           bar, stairs, gplot, gsplot, replot, xlabel, ylabel, title
 
 ## Author: jwe
 
 function plot (...)
 
   set nologscale;
   set nopolar;
 
diff --git a/scripts/plot/plot_border.m b/scripts/plot/plot_border.m
--- a/scripts/plot/plot_border.m
+++ b/scripts/plot/plot_border.m
@@ -18,17 +18,17 @@
 ## 02111-1307, USA.
 
 ## usage: plot_border (...)
 ##
 ## NOTE: this will work only with gnuplot installed with
 ##       multiplot patch
 ##
 ## Multiple arguments allowed to specify the sides on which the border
-## is shown. allowed strings: 
+## is shown. allowed strings:
 ##
 ## allowed input strings:
 ##
 ##  "blank", "BLANK", "b", "B",   --->  No borders displayed
 ##    "all",   "ALL", "a", "A",   ---> All borders displayed
 ##  "north", "NORTH", "n", "N",   ---> North Border
 ##  "south", "SOUTH", "s", "S",   ---> South Border
 ##   "east",  "EAST", "e", "E",   --->  East Border
@@ -40,17 +40,17 @@
 ## Created: 3 July 95
 ## Adapted-By: jwe
 
 function plot_border (...)
 
   if (! gnuplot_has_multiplot)
     error ("plot_border: gnuplot does not appear to support this feature");
   endif
-    
+
   south = 0;
   west = 0;
   north = 0;
   east = 0;
   all = 0;
   none = 1;
 
   va_start ();
diff --git a/scripts/plot/polar.m b/scripts/plot/polar.m
--- a/scripts/plot/polar.m
+++ b/scripts/plot/polar.m
@@ -19,17 +19,17 @@
 
 ## usage: polar (theta, rho, fmt)
 ##
 ## Make a 2D plot given polar the coordinates theta and rho.
 ##
 ## The optional third argument specifies the line type.
 ##
 ## See also: plot, semilogx, semilogy, loglog, mesh, contour, bar,
-##           stairs, gplot, gsplot, replot, xlabel, ylabel, title 
+##           stairs, gplot, gsplot, replot, xlabel, ylabel, title
 
 ## Author: jwe
 
 function polar (x1, x2, fmt)
 
   set nologscale;
   set nopolar;
 
diff --git a/scripts/plot/semilogx.m b/scripts/plot/semilogx.m
--- a/scripts/plot/semilogx.m
+++ b/scripts/plot/semilogx.m
@@ -16,23 +16,23 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## usage: semilogx (x, y)
 ##        semilogx (x1, y1, x2, y2, ...)
 ##        semilogx (x, y, fmt)
 ##
-## Make a 2D plot of y versus x using a log scale for the x axis. 
+## Make a 2D plot of y versus x using a log scale for the x axis.
 ##
 ## See the help message for the plot command for a description of how
-## the arguments are interpreted. 
+## the arguments are interpreted.
 ##
 ## See also: plot, semilogy, loglog, polar, mesh, contour, bar, stairs,
-##           gplot, gsplot, replot, xlabel, ylabel, title 
+##           gplot, gsplot, replot, xlabel, ylabel, title
 
 ## Author: jwe
 
 function semilogx (...)
 
   set logscale x;
   set nologscale y;
   set nopolar;
diff --git a/scripts/plot/semilogy.m b/scripts/plot/semilogy.m
--- a/scripts/plot/semilogy.m
+++ b/scripts/plot/semilogy.m
@@ -16,23 +16,23 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## usage: semilogy (x, y)
 ##        semilogy (x1, y1, x2, y2, ...)
 ##        semilogy (x, y, fmt)
 ##
-## Make a 2D plot of y versus x using a log scale for the x axis. 
+## Make a 2D plot of y versus x using a log scale for the x axis.
 ##
 ## See the help message for the plot command for a description of how
-## the arguments are interpreted. 
+## the arguments are interpreted.
 ##
 ## See also: plot, semilogx, loglog, polar, mesh, contour, bar, stairs,
-##           gplot, gsplot, replot, xlabel, ylabel, title 
+##           gplot, gsplot, replot, xlabel, ylabel, title
 
 ## Author: jwe
 
 function semilogy (...)
 
   set nologscale x;
   set logscale y;
   set nopolar;
diff --git a/scripts/plot/stairs.m b/scripts/plot/stairs.m
--- a/scripts/plot/stairs.m
+++ b/scripts/plot/stairs.m
@@ -32,17 +32,17 @@
 ## and
 ##
 ##   [xs, ys] = stairs (x, y);
 ##   plot (xs, ys);
 ##
 ## are equivalent.
 ##
 ## See also: plot, semilogx, semilogy, loglog, polar, mesh, contour,
-##           bar, gplot, gsplot, replot, xlabel, ylabel, title 
+##           bar, gplot, gsplot, replot, xlabel, ylabel, title
 
 ## Author: jwe
 
 function [xs, ys] = stairs (x, y)
 
 
   if (nargin == 1)
     if (is_vector (x))
diff --git a/scripts/plot/subplot.m b/scripts/plot/subplot.m
--- a/scripts/plot/subplot.m
+++ b/scripts/plot/subplot.m
@@ -59,18 +59,18 @@
 function subplot (rows, columns, index)
 
   if (! gnuplot_has_multiplot)
     error ("subplot: gnuplot does not appear to support this feature");
   endif
 
   ## global variables to keep track of multiplot options
 
-  global multiplot_mode 
-  global multiplot_xsize multiplot_ysize 
+  global multiplot_mode
+  global multiplot_xsize multiplot_ysize
   global multiplot_xn multiplot_yn
   global multiplot_xi multiplot_yi
 
   ## This is a real kludge.  We gnuplot should be made so that replot can
   ## be executed while doing multiple plots...
 
   global multiplot_save_auto_replot = automatic_replot
 
diff --git a/scripts/plot/subwindow.m b/scripts/plot/subwindow.m
--- a/scripts/plot/subwindow.m
+++ b/scripts/plot/subwindow.m
@@ -33,18 +33,18 @@
 function subwindow (xn, yn)
 
   if (! gnuplot_has_multiplot)
     error ("subwindow: gnuplot does not appear to support this feature");
   endif
 
   ## global variables to keep track of multiplot options
 
-  global multiplot_mode 
-  global multiplot_xsize multiplot_ysize 
+  global multiplot_mode
+  global multiplot_xsize multiplot_ysize
   global multiplot_xn multiplot_yn
 
   ## check calling argument count
 
   if (nargin != 2)
     usage ("subwindow (xn, yn)");
   endif
 
@@ -53,27 +53,27 @@ function subwindow (xn, yn)
   if (! (is_scalar (xn) && is_scalar (yn)))
     error ("subwindow: xn and yn have to be scalars");
   endif
 
   xn = round (xn);
   yn = round (yn);
 
   ## switch to multiplot mode if not already in, and use the args as the
-  ## args to multiplot() 
+  ## args to multiplot()
 
   if (multiplot_mode != 1)
     multiplot (xn, yn);
     return;
   endif
 
   ## get the sub plot location
 
   if (xn < 1 || xn > multiplot_xn || yn < 1 || yn > multiplot_yn)
     error ("subwindow: incorrect xn and yn");
   endif
 
   xo = (xn - 1.0)*multiplot_xsize;
   yo = (multiplot_yn - yn)*multiplot_ysize;
 
   eval (sprintf ("set origin %g, %g", xo, yo));
-      
+
 endfunction
diff --git a/scripts/plot/title.m b/scripts/plot/title.m
--- a/scripts/plot/title.m
+++ b/scripts/plot/title.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## usage: title (text)
 ##
 ## Defines a title for a plot.  The title will appear the next time a
-## plot is displayed. 
+## plot is displayed.
 ##
 ## See also: plot, semilogx, semilogy, loglog, polar, mesh, contour,
 ##           bar, stairs, gplot, gsplot, replot, xlabel, ylabel
 
 ## Author: jwe
 
 function title (text)
 
diff --git a/scripts/plot/top_title.m b/scripts/plot/top_title.m
--- a/scripts/plot/top_title.m
+++ b/scripts/plot/top_title.m
@@ -17,17 +17,17 @@
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## usage: top_title (text)
 ##
 ## NOTE: this will work only with gnuplot installed with
 ##       multiplot patch
 ##
-## makes a title with text "text" at the top of the plot 
+## makes a title with text "text" at the top of the plot
 
 ## Author: Vinayak Dutt <Dutt.Vinayak@mayo.EDU>
 ## Created: 3 July 95
 ## Adapted-By: jwe
 
 function top_title (text)
 
   if (! gnuplot_has_multiplot)
diff --git a/scripts/polynomial/conv.m b/scripts/polynomial/conv.m
--- a/scripts/polynomial/conv.m
+++ b/scripts/polynomial/conv.m
@@ -22,24 +22,24 @@
 ## Convolve two vectors.
 ##
 ## y = conv (a, b) returns a vector of length equal to length (a) +
 ## length (b) -1.
 ##
 ## If a and b are polynomial coefficient vectors, conv returns the
 ## coefficients of the product polynomial.
 ##
-## SEE ALSO: deconv, poly, roots, residue, polyval, polyderiv, polyinteg 
+## SEE ALSO: deconv, poly, roots, residue, polyval, polyderiv, polyinteg
 
 ## Author: Tony Richardson <amr@mpl.ucsd.edu>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function y = conv (a, b)
-  
+
   if (nargin != 2)
     usage ("conv(a, b)");
   endif
 
   if (is_matrix (a) || is_matrix (b))
     error("conv: both arguments must be vectors");
   endif
 
diff --git a/scripts/polynomial/deconv.m b/scripts/polynomial/deconv.m
--- a/scripts/polynomial/deconv.m
+++ b/scripts/polynomial/deconv.m
@@ -16,25 +16,25 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## usage: deconv (y, a)
 ##
 ## Deconvolve two vectors.
 ##
-## [b, r] = deconv (y, a) solves for b and r such that 
+## [b, r] = deconv (y, a) solves for b and r such that
 ##    y = conv(a,b) + r
 ##
 ## If y and a are polynomial coefficient vectors, b will contain the
 ## coefficients of the polynomial quotient and r will be a remander
 ## polynomial of lowest order.
 ##
 ## SEE ALSO: conv, poly, roots, residue, polyval, polyderiv,
-## polyinteg 
+## polyinteg
 
 ## Author: Tony Richardson <amr@mpl.ucsd.edu>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function [b, r] = deconv (y, a)
 
   if (nargin != 2)
diff --git a/scripts/polynomial/poly.m b/scripts/polynomial/poly.m
--- a/scripts/polynomial/poly.m
+++ b/scripts/polynomial/poly.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## usage: poly (x)
 ##
-## If A is a square n-by-n matrix, poly (A) is the row vector of 
+## If A is a square n-by-n matrix, poly (A) is the row vector of
 ## the coefficients of det (z * eye(n) - A), the characteristic
 ## polynomial of A.
 ##
 ## If x is a vector, poly (x) is a vector of coefficients of the
 ## polynomial whose roots are the elements of x.
 
 ## Author: KH <Kurt.Hornik@neuro.tuwien.ac.at>
 ## Created: 24 December 1993
@@ -42,20 +42,20 @@ function y = poly (x)
     y = 1;
   elseif (m == 1)
     v = x;
   elseif (m == n)
     v = eig (x);
   else
     usage ("poly (x), where x is a vector or a square matrix");
   endif
-  
+
   y = zeros (1, n+1);
   y(1) = 1;
   for j = 1:n;
     y(2:(j+1)) = y(2:(j+1)) - v(j) .* y(1:j);
   endfor
-  
+
   if (all (all (imag (x) == 0)))
     y = real (y);
   endif
-  
+
 endfunction
diff --git a/scripts/polynomial/polyfit.m b/scripts/polynomial/polyfit.m
--- a/scripts/polynomial/polyfit.m
+++ b/scripts/polynomial/polyfit.m
@@ -15,42 +15,42 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## usage:  polyfit (x, y, n)
 ##
 ## Returns the coefficients of a polynomial p(x) of degree n that
-## minimizes sumsq (p(x(i)) - y(i)), i.e., that best fits the data 
+## minimizes sumsq (p(x(i)) - y(i)), i.e., that best fits the data
 ## in the least squares sense.
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 13 December 1994
 ## Adapted-By: jwe
 
 function p = polyfit (x, y, n)
-  
- 
+
+
   if (nargin != 3)
     usage ("polyfit (x, y, n)");
   endif
-  
+
   if (! (is_vector (x) && is_vector (y) && size (x) == size (y)))
     error ("polyfit: x and y must be vectors of the same size");
   endif
-  
+
   if (! (is_scalar (n) && n >= 0 && ! isinf (n) && n == round (n)))
     error ("polyfit: n must be a nonnegative integer");
   endif
-  
+
   l = length (x);
   x = reshape (x, l, 1);
   y = reshape (y, l, 1);
-  
+
   X = ones (l, 1);
 
   if (n > 0)
     tmp = (x * ones (1, n)) .^ (ones (l, 1) * (1 : n));
     X = [X, tmp];
   endif
 
   ## Compute polynomial coeffients, making returned value compatible
diff --git a/scripts/polynomial/polyval.m b/scripts/polynomial/polyval.m
--- a/scripts/polynomial/polyval.m
+++ b/scripts/polynomial/polyval.m
@@ -15,28 +15,28 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## usage: polyval (c, x)
 ##
 ## Evaluate a polynomial.
-## 
+##
 ## In octave, a polynomial is represented by it's coefficients (arranged
 ## in descending order). For example a vector c of length n+1 corresponds
 ## to the following nth order polynomial
-## 
+##
 ##   p(x) = c(1) x^n + ... + c(n) x + c(n+1).
-## 
+##
 ## polyval(c,x) will evaluate the polynomial at the specified value of x.
-## 
+##
 ## If x is a vector or matrix, the polynomial is evaluated at each of the
 ## elements of x.
-## 
+##
 ## SEE ALSO: polyvalm, poly, roots, conv, deconv, residue, filter,
 ##           polyderiv, polyinteg
 
 ## Author: Tony Richardson <amr@mpl.ucsd.edu>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function y = polyval (c, x)
diff --git a/scripts/polynomial/roots.m b/scripts/polynomial/roots.m
--- a/scripts/polynomial/roots.m
+++ b/scripts/polynomial/roots.m
@@ -26,37 +26,37 @@
 ## Created: 24 December 1993
 ## Adapted-By: jwe
 
 function r = roots (v)
 
   if (min (size (v)) > 1 || nargin != 1)
     usage ("roots (v), where v is a vector");
   endif
-  
+
   n = length (v);
-  v = reshape (v, 1, n);  
+  v = reshape (v, 1, n);
 
   ## If v = [ 0 ... 0 v(k+1) ... v(k+l) 0 ... 0 ], we can remove the
-  ## leading k zeros and n - k - l roots of the polynomial are zero.  
+  ## leading k zeros and n - k - l roots of the polynomial are zero.
 
   f = find (v);
   m = max (size (f));
-  
+
   if (m > 0 && n > 1)
     v = v(f(1):f(m));
     l = max (size (v));
     if (l > 1)
       A = diag (ones (1, l-2), -1);
       A(1,:) = -v(2:l) ./ v(1);
-      r = eig (A);    
+      r = eig (A);
       if (f(m) < n)
         tmp = zeros (n - f(m), 1);
 	r = [r; tmp];
       endif
     else
       r = zeros (n - f(m), 1);
     endif
   else
     r = [];
   endif
-  
+
 endfunction
diff --git a/scripts/set/create_set.m b/scripts/set/create_set.m
--- a/scripts/set/create_set.m
+++ b/scripts/set/create_set.m
@@ -47,11 +47,11 @@ function y = create_set(x)
       if(cur_val != x(xindex))
         cur_val = x(xindex);
         y(yindex++) = cur_val;
       endif
       xindex++;
     endwhile
     y = y(1:(yindex-1));
   endif
-  
+
 endfunction
-  
+
diff --git a/scripts/signal/fftconv.m b/scripts/signal/fftconv.m
--- a/scripts/signal/fftconv.m
+++ b/scripts/signal/fftconv.m
@@ -15,33 +15,33 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## usage: fftconv (a, b [, N])
 ##
 ## c = fftconv (a, b) returns the convolution of the vectors a and b,
-## a vector with length equal to length (a) + length (b) - 1.  
+## a vector with length equal to length (a) + length (b) - 1.
 ## If a and b are the coefficient vectors of two polynomials, c is
 ## the coefficient vector of the product polynomial.
 ##
 ## The computation uses the FFT by calling fftfilt.  If the optional
 ## argument N is specified, an N-point FFT is used.
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 3 September 1994
 ## Adapted-By: jwe
 
 function c = fftconv (a, b, N)
 
   if (nargin < 2 || nargin > 3)
     usage ("fftconv (b, x [, N])");
   endif
-  
+
   if (is_matrix (a) || is_matrix (b))
     error ("fftconv:  both a and b should be vectors");
   endif
   la = length (a);
   lb = length (b);
   if ((la == 1) || (lb == 1))
     c = a * b;
   else
diff --git a/scripts/signal/fftfilt.m b/scripts/signal/fftfilt.m
--- a/scripts/signal/fftfilt.m
+++ b/scripts/signal/fftfilt.m
@@ -27,42 +27,42 @@
 ## Processing (Chapter 8).  Prentice-Hall.
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 3 September 1994
 ## Adapted-By: jwe
 
 function y = fftfilt (b, x, N)
 
-  ## If N is not specified explicitly, we do not use the overlap-add 
+  ## If N is not specified explicitly, we do not use the overlap-add
   ## method at all because loops are really slow.  Otherwise, we only
   ## ensure that the number of points in the FFT is the smallest power
   ## of two larger than N and length(b).  This could result in length
   ## one blocks, but if the user knows better ...
-  
+
   if (nargin < 2 || nargin > 3)
     usage (" fftfilt (b, x [, N])");
   endif
-  
+
   [r_x, c_x] = size (x);
   [r_b, c_b] = size (b);
   if (! (min ([r_x, c_x]) == 1 || min ([r_b, c_b]) == 1))
     error ("fftfilt: both x and b should be vectors");
   endif
   l_x  = r_x * c_x;
   l_b  = r_b * c_b;
 
   if ((l_x == 1) && (l_b == 1))
-    y = b * x;  
+    y = b * x;
     return;
   endif
-  
+
   x = reshape (x, 1, l_x);
   b = reshape (b, 1, l_b);
-  
+
   if (nargin == 2)
     ## Use FFT with the smallest power of 2 which is >= length (x) +
     ## length (b) - 1 as number of points ...
     N    = 2^(ceil (log (l_x + l_b - 1) / log(2)));
     y    = ifft (fft (x, N) .* fft(b, N));
   else
     ## Use overlap-add method ...
     if !(is_scalar (N))
@@ -74,19 +74,19 @@ function y = fftfilt (b, x, N)
     R = ceil (l_x / L);
     y = zeros (1, l_x);
     for r = 1:R;
       lo  = (r - 1) * L + 1;
       hi  = min (r * L, l_x);
       tmp = ifft (fft (x(lo:hi), N) .* B);
       hi  = min (lo+N-1, l_x);
       y(lo:hi) = y(lo:hi) + tmp(1:(hi-lo+1));
-    endfor  
+    endfor
   endif
-    
+
   y = reshape (y(1:l_x), r_x, c_x);
 
   ## Final cleanups:  if both x and b are real respectively integer, y
   ## should also be
 
   if (! (any (imag (x)) || any (imag (b))))
     y = real (y);
   endif
diff --git a/scripts/signal/freqz.m b/scripts/signal/freqz.m
--- a/scripts/signal/freqz.m
+++ b/scripts/signal/freqz.m
@@ -51,17 +51,17 @@ function [h, w] = freqz(b,...)
     region = "half";
   elseif (nargin == 3)
     a = va_arg();
     n = va_arg();
     region = "half";
   elseif (nargin == 4)
     a = va_arg();
     n = va_arg();
-    region = va_arg();     
+    region = va_arg();
   endif
 
   la = length(a);
   a = reshape(a,1,la);
   lb = length(b);
   b = reshape(b,1,lb);
 
   k = max([la, lb]);
@@ -75,13 +75,13 @@ function [h, w] = freqz(b,...)
       h = h(1:n);
       w = pi*[0:(n-1)]/n;
     endif
   else
     if (strcmp(region,"whole"))
       w = 2*pi*[0:(n-1)]/n;
     else
       w = pi*[0:(n-1)]/n;
-    endif    
+    endif
     h = polyval(postpad(b,k),exp(j*w)) ./ polyval(postpad(a,k),exp(j*w));
   endif
 
 endfunction
diff --git a/scripts/specfun/beta.m b/scripts/specfun/beta.m
--- a/scripts/specfun/beta.m
+++ b/scripts/specfun/beta.m
@@ -22,17 +22,17 @@
 ## Returns the beta function beta(a,b) = gamma(a) * gamma(b) / gamma(a+b)
 ## of a and b.
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 13 June 1993
 ## Adapted-By: jwe
 
 function retval = beta (a, b)
-  
+
   if (nargin != 2)
     usage ("beta (a, b)");
   endif
 
   retval = exp (lgamma (a) + lgamma (b) - lgamma (a+b));
 
 endfunction
 
diff --git a/scripts/specfun/betai.m b/scripts/specfun/betai.m
--- a/scripts/specfun/betai.m
+++ b/scripts/specfun/betai.m
@@ -24,20 +24,20 @@
 ## If x has more than one component, both a and b must be scalars.
 ## If x is a scalar, a and b must be of compatible dimensions.
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 2 August 1994.
 ## Adapted-By: jwe
 
 function y = betai (a, b, x)
-  
+
   ## Computation is based on the series expansion
-  ##   betai(a, b, x) 
-  ##     = \frac{1}{B(a, b)} x^a 
+  ##   betai(a, b, x)
+  ##     = \frac{1}{B(a, b)} x^a
   ##         \sum_{k=0}^\infty \frac{(1-b)\cdots(k-b)}{a+k} \frac{x^k}{k!}
   ## for x <= 1/2.  For x > 1/2, betai(a, b, x) = 1 - betai(b, a, 1-x).
 
   if (nargin <> 3)
     usage (" betai (a, b, x)");
   endif
 
   if (! (a > 0 && b > 0))
@@ -47,17 +47,17 @@ function y = betai (a, b, x)
   if (min ([nr, nc]) == 0)
     error ("betai: x must not be empty.");
   endif
   if (any (x < 0) || any (x > 1))
     error ("betai: all entries of x must be in [0,1].");
   endif
 
   if (nr > 1 || nc > 1)
-    
+
     if (! (is_scalar (a) && is_scalar (b)))
       error ("betai: if x is not a scalar, a and b must be scalars");
     endif
 
     n = nr * nc;
     x = reshape (x, 1, n);
     y = zeros (1, n);
     c = exp (lgamma (a+b) - lgamma (a) - lgamma (b));
@@ -71,53 +71,53 @@ function y = betai (a, b, x)
     k = (1:K)';
 
     ind = find ((x > 0) & (x <= 1/2));
     len = length (ind);
     if (len > 0)
       tmp    = cumprod((1 - b./k) * x(ind)) ./ ((a + k) * ones(1, len));
       y(ind) = c * exp(a * log(x(ind))) .* (1/a + sum(tmp));
     endif
-    
+
     ind = find ((x > 1/2) & (x < 1));
     len = length(ind);
     if (len > 0)
       tmp    = cumprod ((1 - a./k) * (1 - x(ind))) ./ ((b + k) * ones(1, len));
       y(ind) = 1 - c * exp (b * log (1-x(ind))) .* (1/b + sum (tmp));
     endif
-  
+
     y = reshape (y, nr, nc);
-    
+
   else
-    
+
     [ra, ca] = size (a);
     [rb, cb] = size (b);
     if (! (ra == rb && ca == cb))
       error ("betai: a and b must have the same size");
     endif
 
     n = ra * ca;
     a = reshape (a, 1, n);
     b = reshape (b, 1, n);
     c = exp (lgamma (a+b) - lgamma (a) - lgamma (b));
-    
+
     if (x == 0)
       y   = zeros (1, n);
     elseif (x == 1)
       y   = ones (1, n);
     else
       K = ceil (-log (eps) / log (2));
       k = (1:K)' * ones (1, n);
       h = ones (K, 1);
       if (x > 0 && x <= 1/2)
 	tmp = cumprod ((1 - (h * b) ./ k) * x) ./ ((h * a) + k);
 	y   = c .* exp (a * log(x)) .* (1 ./ a + sum (tmp));
       else
 	tmp = cumprod ((1 - (h * a) ./ k) * (1-x)) ./ ((h * b) + k);
 	y   = 1 - c .* exp (b * log (1-x)) .* (1 ./ b + sum (tmp));
       endif
     endif
-  
+
     y = reshape (y, ra, ca);
-    
+
   endif
 
 endfunction
diff --git a/scripts/specfun/betainc.m b/scripts/specfun/betainc.m
--- a/scripts/specfun/betainc.m
+++ b/scripts/specfun/betainc.m
@@ -19,12 +19,12 @@
 
 ## Usage: betainc (x, a, b)
 ##
 ## See also: betai
 
 ## Author: jwe
 
 function y = betainc (x, a, b)
-  
+
   y = betai (a, b, x);
 
 endfunction
diff --git a/scripts/specfun/gammai.m b/scripts/specfun/gammai.m
--- a/scripts/specfun/gammai.m
+++ b/scripts/specfun/gammai.m
@@ -16,44 +16,44 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## usage: gammai (a, x)
 ##
 ## Computes the incomplete gamma function
 ##
-##   gammai (a, x) 
+##   gammai (a, x)
 ##     = (integral from 0 to x of exp(-t) t^(a-1) dt) / gamma(a).
 ##
 ## If a is scalar, then gammai(a, x) is returned for each element of x
 ## and vice versa.
 ##
 ## If neither a nor x is scalar, the sizes of a and x must agree, and
 ## gammai is applied pointwise.
 
 ## Author: KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 13 August 1994
 ## Adapted-By: jwe
 
 function y = gammai (a, x)
-  
+
   if (nargin != 2)
     usage ("gammai (a, x)");
   endif
-  
+
   [r_a, c_a] = size (a);
   [r_x, c_x] = size (x);
   e_a = r_a * c_a;
   e_x = r_x * c_x;
-  
+
   ## The following code is rather ugly.  We want the function to work
-  ## whenever a and x have the same size or a or x is scalar.  
+  ## whenever a and x have the same size or a or x is scalar.
   ## We do this by reducing the latter cases to the former.
-  
+
   if (e_a == 0 || e_x == 0)
     error ("gammai: both a and x must be nonempty");
   endif
   if (r_a == r_x && c_a == c_x)
     n   = e_a;
     a   = reshape (a, 1, n);
     x   = reshape (x, 1, n);
     r_y = r_a;
@@ -66,32 +66,32 @@ function y = gammai (a, x)
     c_y = c_x;
   elseif (e_x == 1)
     n   = e_a;
     a   = reshape (a, 1, n);
     x   = x * ones (1, n);
     r_y = r_a;
     c_y = c_a;
   else
-    error ("gammai: a and x must have the same size if neither is scalar"); 
+    error ("gammai: a and x must have the same size if neither is scalar");
   endif
 
   ## Now we can do sanity checking ...
-  
+
   if (any (a <= 0) || any (a == Inf))
     error ("gammai: all entries of a must be positive anf finite");
   endif
   if (any (x < 0))
     error ("gammai: all entries of x must be nonnegative");
   endif
-  
+
   y = zeros (1, n);
 
   ## For x < a + 1, use summation.  The below choice of k should ensure
-  ## that the overall error is less than eps ... 
+  ## that the overall error is less than eps ...
 
   S = find ((x > 0) & (x < a + 1));
   s = length (S);
   if (s > 0)
     k   = ceil (- max ([a(S), x(S)]) * log (eps));
     K   = (1:k)';
     M   = ones (k, 1);
     A   = cumprod ((M * x(S)) ./ (M * a(S) + K * ones(1, s)));
@@ -116,14 +116,14 @@ function y = gammai (a, x)
       c_old = c_new;
       u = v + u .* (ones (2, 1) * (n - a(S)));
       v = u .* (ones (2, 1) * x(S)) + n * v;
       c_new = v(1,:) ./ v(2,:);
       n = n + 1;
     endwhile
     y(S) = 1 - exp (-x(S) + a(S) .* log (x(S))) .* c_new ./ gamma (a(S));
   endif
-  
+
   y (find (x == Inf)) = ones (1, sum (x == Inf));
-  
+
   y = reshape (y, r_y, c_y);
 
 endfunction
diff --git a/scripts/specfun/gammainc.m b/scripts/specfun/gammainc.m
--- a/scripts/specfun/gammainc.m
+++ b/scripts/specfun/gammainc.m
@@ -19,12 +19,12 @@
 
 ## Usage: gammainc (x, a)
 ##
 ## See also: gammai
 
 ## Author: jwe
 
 function y = gammainc (x, a)
-  
+
   y = gammai (a, x);
 
 endfunction
diff --git a/scripts/special-matrix/hankel.m b/scripts/special-matrix/hankel.m
--- a/scripts/special-matrix/hankel.m
+++ b/scripts/special-matrix/hankel.m
@@ -18,17 +18,17 @@
 ## 02111-1307, USA.
 
 ## usage: hankel (c, r)
 ##
 ## Return the Hankel matrix constructed given the first column
 ## c, and (optionally) the last row r.
 ##
 ## If the second argument is omitted, zeros are inserted below the main
-## anti-diagonal.  If the last element of c is not the same as the first 
+## anti-diagonal.  If the last element of c is not the same as the first
 ## element of r, the last element of c is used.
 ##
 ## See also: vander, hadamard, hilb, invhilb, toeplitz
 
 ## Author: jwe
 
 function retval = hankel (c, r)
 
@@ -40,17 +40,17 @@ function retval = hankel (c, r)
 
   [c_nr, c_nc] = size (c);
   [r_nr, r_nc] = size (r);
 
   if ((c_nr != 1 && c_nc != 1) || (r_nr != 1 && r_nc != 1))
     error ("hankel: expecting vector arguments");
   endif
 
-  if (nargin == 1) 
+  if (nargin == 1)
     r (1) = c (length (c));
   endif
 
   if (c_nc != 1)
     c = c.';
   endif
 
   if (r_nr != 1)
diff --git a/scripts/statistics/gls.m b/scripts/statistics/gls.m
--- a/scripts/statistics/gls.m
+++ b/scripts/statistics/gls.m
@@ -33,25 +33,25 @@
 ## v is the GLS estimator for s^2.
 ## R = Y - X*BETA is the matrix of GLS residuals.
 
 ## Author: Teresa Twaroch <twaroch@ci.tuwien.ac.at>
 ## Created: May 1993
 ## Adapted-By: jwe
 
 function [BETA, v, R] = gls (Y, X, O)
-  
+
   if (nargin != 3)
     usage ("[BETA, v [, R]] = gls (Y, X, O)");
   endif
 
   [rx, cx] = size (X);
   [ry, cy] = size (Y);
   if (rx != ry)
-    error ("gls: incorrect matrix dimensions");  
+    error ("gls: incorrect matrix dimensions");
   endif
 
   O = O^(-1/2);
   Z = kron (eye (cy), X);
   Z = O * Z;
   Y1 = O * reshape (Y, ry*cy, 1);
   U = Z' * Z;
   r = rank (U);
diff --git a/scripts/strings/bin2dec.m b/scripts/strings/bin2dec.m
--- a/scripts/strings/bin2dec.m
+++ b/scripts/strings/bin2dec.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 1996 Kurt Hornik
-## 
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
@@ -22,22 +22,22 @@
 ## Returns the decimal number corresponding to the binary number in
 ## quotes.  For example, bin2dec ("1110") returns 14.
 
 ## Author: jwe
 
 function y = bin2dec (x)
 
 ## Original version by Kurt Hornik <Kurt.Hornik@ci.tuwien.ac.at>.
-  
+
   if (nargin != 1)
     usage ("bin2dec (x)");
   endif
 
   x = toascii (x) - toascii ("0");
 
   if (all (x == 0 | x == 1))
     y = sum ((x .* (ones (rows (x), 1) * 2.^((length (x) - 1) : -1 : 0)))')';
   else
     error ("bin2dec: argument must be a string of zeros and ones");
   endif
-  
+
 endfunction
diff --git a/scripts/strings/blanks.m b/scripts/strings/blanks.m
--- a/scripts/strings/blanks.m
+++ b/scripts/strings/blanks.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 1996 Kurt Hornik
-## 
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
@@ -19,26 +19,26 @@
 
 ## usage:  blanks (n)
 ##
 ## Returns a string of n blanks.
 
 ## Author: jwe
 
 function s = blanks (n)
-  
+
 ## Original version by Kurt Hornik <Kurt.Hornik@ci.tuwien.ac.at>.
 
   if (nargin != 1)
     usage ("blanks (n)");
   endif
-  
+
   if (is_scalar (n) && n > 0 && n == round (n))
     s = setstr (ones (1, n) * toascii (" "));
   else
     error ("blanks: n must be a positive integer");
   endif
-  
+
 endfunction
-  
 
 
 
+
diff --git a/scripts/strings/deblank.m b/scripts/strings/deblank.m
--- a/scripts/strings/deblank.m
+++ b/scripts/strings/deblank.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 1996 Kurt Hornik
-## 
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
@@ -19,23 +19,23 @@
 
 ## usage:  deblank (s)
 ##
 ## Remove trailing blanks from the string s.
 
 ## Author: jwe
 
 function t = deblank (s)
-  
+
 ## Original version by Kurt Hornik <Kurt.Hornik@ci.tuwien.ac.at>.
 
   if (nargin != 1)
     usage ("deblank (s)");
   endif
-  
+
   if (isstr (s))
 
     [nr, nc] = size (s);
     len = nr * nc;
 
     if (len == 0)
       t = s;
     else
diff --git a/scripts/strings/dec2bin.m b/scripts/strings/dec2bin.m
--- a/scripts/strings/dec2bin.m
+++ b/scripts/strings/dec2bin.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 1996 Kurt Hornik
-## 
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
@@ -22,17 +22,17 @@
 ## Returns the binary number corresponding to the nonnegative integer
 ## x.  For example, dec2bin (14) returns "1110".
 
 ## Author: jwe
 
 function y = dec2bin (x)
 
   ## Original version by Kurt Hornik <Kurt.Hornik@ci.tuwien.ac.at>.
-  
+
   if (nargin != 1)
     usage ("dec2bin (x)");
   endif
 
   [nr, nc] = size (x);
 
   len = nr * nc;
 
@@ -57,9 +57,9 @@ function y = dec2bin (x)
     endfor
     y = fliplr (y);
     y = setstr (y + toascii ("0"));
   unwind_protect_cleanup
     empty_list_elements_ok = eleo;
   end_unwind_protect
 
 endfunction
-    
+
diff --git a/scripts/strings/dec2hex.m b/scripts/strings/dec2hex.m
--- a/scripts/strings/dec2hex.m
+++ b/scripts/strings/dec2hex.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 1996 Kurt Hornik
-## 
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
@@ -15,28 +15,28 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## usage:  dec2hex (d)
 ##
 ## Returns the hex number corresponding to the decimal number d.  For
-## example, dec2hex (2748) returns "abc". 
+## example, dec2hex (2748) returns "abc".
 
 ## Author: jwe
 
 function h = dec2hex (d)
 
 ## Original version by Kurt Hornik <Kurt.Hornik@ci.tuwien.ac.at>.
 
   if (nargin != 1)
     usage ("dec2hex (d)");
   endif
-  
+
   [nr, nc] = size (d);
 
   len = nr * nc;
 
   d = reshape (d, 1, len);
 
   eleo = empty_list_elements_ok;
   unwind_protect
diff --git a/scripts/strings/findstr.m b/scripts/strings/findstr.m
--- a/scripts/strings/findstr.m
+++ b/scripts/strings/findstr.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 1996 Kurt Hornik
-## 
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
@@ -20,17 +20,17 @@
 ## usage: findstr (s, t [, overlap])
 ##
 ## Returns the vector of all positions in the longer of the two strings
 ## S and T where an occurence of the shorter of the two starts.
 ##
 ## If the optional argument OVERLAP is nonzero, the returned vector
 ## can include overlapping positions (this is the default).
 ##
-## For example, 
+## For example,
 ##
 ##   findstr ("abababa", "aba")     =>  [1, 3, 5]
 ##   findstr ("abababa", "aba", 0)  =>  [1, 5]
 
 ## Author: jwe
 
 function v = findstr (s, t, overlap)
 
diff --git a/scripts/strings/index.m b/scripts/strings/index.m
--- a/scripts/strings/index.m
+++ b/scripts/strings/index.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 1996 Kurt Hornik
-## 
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
@@ -51,10 +51,10 @@ function n = index (s, t)
 	  return;
 	endif
       endfor
     endif
 
   else
     error ("index: expecting string arguments");
   endif
-  
+
 endfunction
diff --git a/scripts/strings/rindex.m b/scripts/strings/rindex.m
--- a/scripts/strings/rindex.m
+++ b/scripts/strings/rindex.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 1996 Kurt Hornik
-## 
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
@@ -51,10 +51,10 @@ function n = rindex (s, t)
 	  return;
 	endif
       endfor
     endif
 
   else
     error ("rindex: expecting string arguments");
   endif
-  
+
 endfunction
diff --git a/scripts/strings/split.m b/scripts/strings/split.m
--- a/scripts/strings/split.m
+++ b/scripts/strings/split.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 1996 Kurt Hornik
-## 
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
@@ -21,32 +21,32 @@
 ##
 ## Divides the string S into pieces separated by T, and stores the
 ## pieces as the rows of M (padded with blanks to form a valid
 ## matrix).
 
 ## Author: jwe
 
 function m = split (s, t)
-  
+
 ## Original version by Kurt Hornik <Kurt.Hornik@ci.tuwien.ac.at>.
 
   if (nargin != 2)
     usage ("split (s, t)");
   endif
-  
+
   if (isstr (s) && isstr (t))
-  
+
   l_s = length (s);
   l_t = length (t);
-  
+
   if (l_s < l_t)
     error ("split: s must not be shorter than t");
   endif
-  
+
   if (l_t == 0)
     ind = 1 : (l_s + 1);
   else
     ind = findstr (s, t, 0);
     if (length (ind) == 0)
       m = s;
       return;
     endif
@@ -65,15 +65,15 @@ function m = split (s, t)
       cmd = sprintf ("%s\"%s\", ", cmd, s (range));
     else
       cmd = sprintf ("%s\"%s\"", cmd, s (range));
     endif
 
   endfor
 
   m = eval (sprintf ("str2mat (%s);", cmd));
-  
+
 
   else
     error ("split:  both s and t must be strings");
   endif
 
 endfunction
diff --git a/scripts/strings/str2mat.m b/scripts/strings/str2mat.m
--- a/scripts/strings/str2mat.m
+++ b/scripts/strings/str2mat.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 1996 Kurt Hornik
-## 
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
@@ -20,17 +20,17 @@
 ## usage:  m = str2mat (s1, ...)
 ##
 ## Forms the matrix M containing the strings S1, ... as its rows.
 ## Each string is padded with blanks in order to form a valid matrix.
 
 ## Author: jwe
 
 function m = str2mat (...)
-  
+
   ## Original version by Kurt Hornik <Kurt.Hornik@ci.tuwien.ac.at>.
 
   if (nargin == 0)
     usage ("str2mat (s1, ...)");
   endif
 
   nc = 0;
 
@@ -55,10 +55,10 @@ function m = str2mat (...)
 
   for k = 1 : nargin
     s = va_arg ();
     tmp = columns (s);
     if (tmp > 0)
       m (k, 1:tmp) = s;
     endif
   endfor
-  
+
 endfunction
diff --git a/scripts/strings/strcmp.m b/scripts/strings/strcmp.m
--- a/scripts/strings/strcmp.m
+++ b/scripts/strings/strcmp.m
@@ -18,21 +18,21 @@
 ## 02111-1307, USA.
 
 ## usage: strcmp (s1, s2)
 ##
 ## Compare two strings.  Trailing blanks are significant.
 ##
 ## WARNING:  Unlike the C function of the same name, this function
 ## returns 1 for equal and zero for not equal.  Why?  To be compatible
-## with Matlab, of course. 
+## with Matlab, of course.
 ##
 ## Why doesn't this always return a scalar instead of vector with
 ## elements corresponding to the rows of the string array?  To be
-## compatible with Matlab, of course. 
+## compatible with Matlab, of course.
 
 ## Author: jwe
 
 function status = strcmp (s1, s2)
 
   if (nargin != 2)
     usage ("strcmp (s, t)");
   endif
diff --git a/scripts/strings/strrep.m b/scripts/strings/strrep.m
--- a/scripts/strings/strrep.m
+++ b/scripts/strings/strrep.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 1995, 1996  Kurt Hornik
-## 
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
@@ -22,30 +22,30 @@
 ## Replace all occurences of the substring x of the string s with the
 ## string y.
 
 ## Author: Kurt Hornik <Kurt.Hornik@ci.tuwien.ac.at>
 ## Created: 11 November 1994
 ## Adapted-By: jwe
 
 function t = strrep (s, x, y)
-  
+
   if (nargin <> 3)
     usage ("strrep (s, x, y)");
   endif
-  
+
   if (! (isstr (s) && isstr (x) && isstr (y)))
     error ("strrep: all arguments must be strings");
   endif
-  
+
   if (length (x) > length (s) || isempty (x))
     t = s;
     return;
   endif
-  
+
   ind = findstr (s, x, 0);
   len = length (ind);
   if (len == 0)
     t = s;
   else
     s = toascii (s);
     x = toascii (x);
     y = toascii (y);
@@ -56,10 +56,10 @@ function t = strrep (s, x, y)
     for k = 1 : len - 1
       tmp = s (ind (k) + l_x : ind (k+1) - 1);
       t = [t, tmp, y];
     endfor
     tmp = s (ind(len) + l_x : length (s));
     t = [t, tmp];
     t = setstr (t);
   endif
-  
+
 endfunction
diff --git a/scripts/strings/substr.m b/scripts/strings/substr.m
--- a/scripts/strings/substr.m
+++ b/scripts/strings/substr.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 1996 Kurt Hornik
-## 
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
@@ -46,10 +46,10 @@ function t = substr (s, beg, len)
 	error ("substr: length = %d out of range", len);
       endif
     else
       error ("substr: beginning index = %d out of range", beg);
     endif
   else
     error ("substr: expecting string argument");
   endif
-  
+
 endfunction
