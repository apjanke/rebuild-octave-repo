# HG changeset patch
# User Rik <octave@nomad.inbox5.com>
# Date 1329146984 28800
#      Mon Feb 13 07:29:44 2012 -0800
# Node ID f3d52523cde158a2a66e54d929d1abd6e411b8ef
# Parent  8de863b7126b3e78b6d214d4eb144be2c3647b77
Use Octave coding conventions in all m-file %!test blocks

* wavread.m, acosd.m, acot.m, acotd.m, acoth.m, acsc.m, acscd.m, acsch.m,
asec.m, asecd.m, asech.m, asind.m, atand.m, cosd.m, cot.m, cotd.m, coth.m,
csc.m, cscd.m, csch.m, sec.m, secd.m, sech.m, sind.m, tand.m, accumarray.m,
accumdim.m, bitcmp.m, bitget.m, bitset.m, blkdiag.m, cart2pol.m, cart2sph.m,
celldisp.m, chop.m, circshift.m, colon.m, common_size.m, cplxpair.m,
cumtrapz.m, curl.m, dblquad.m, deal.m, divergence.m, flipdim.m, fliplr.m,
flipud.m, genvarname.m, gradient.m, idivide.m, int2str.m, interp1.m,
interp1q.m, interp2.m, interp3.m, interpft.m, interpn.m, isa.m, isdir.m,
isequal.m, isequalwithequalnans.m, issquare.m, logspace.m, nargchk.m,
narginchk.m, nargoutchk.m, nextpow2.m, nthargout.m, num2str.m, pol2cart.m,
polyarea.m, postpad.m, prepad.m, profile.m, profshow.m, quadgk.m, quadv.m,
randi.m, rat.m, repmat.m, rot90.m, rotdim.m, shift.m, shiftdim.m, sph2cart.m,
structfun.m, trapz.m, triplequad.m, convhull.m, dsearch.m, dsearchn.m,
griddata3.m, griddatan.m, rectint.m, tsearchn.m, __makeinfo__.m, doc.m,
get_first_help_sentence.m, help.m, type.m, unimplemented.m, which.m, imread.m,
imwrite.m, dlmwrite.m, fileread.m, is_valid_file_id.m, strread.m, textread.m,
textscan.m, commutation_matrix.m, cond.m, condest.m, cross.m,
duplication_matrix.m, expm.m, housh.m, isdefinite.m, ishermitian.m,
issymmetric.m, logm.m, normest.m, null.m, onenormest.m, orth.m, planerot.m,
qzhess.m, rank.m, rref.m, trace.m, vech.m, ans.m, bincoeff.m, bug_report.m,
bzip2.m, comma.m, compare_versions.m, computer.m, edit.m, fileparts.m,
fullfile.m, getfield.m, gzip.m, info.m, inputname.m, isappdata.m, isdeployed.m,
ismac.m, ispc.m, isunix.m, list_primes.m, ls.m, mexext.m, namelengthmax.m,
news.m, orderfields.m, paren.m, recycle.m, rmappdata.m, semicolon.m,
setappdata.m, setfield.m, substruct.m, symvar.m, ver.m, version.m,
warning_ids.m, xor.m, fminbnd.m, fsolve.m, fzero.m, lsqnonneg.m, optimset.m,
pqpnonneg.m, sqp.m, matlabroot.m, __gnuplot_drawnow__.m,
__plt_get_axis_arg__.m, ancestor.m, cla.m, clf.m, close.m, colorbar.m,
colstyle.m, comet3.m, contourc.m, figure.m, gca.m, gcbf.m, gcbo.m, gcf.m,
ginput.m, graphics_toolkit.m, gtext.m, hggroup.m, hist.m, hold.m, isfigure.m,
ishghandle.m, ishold.m, isocolors.m, isonormals.m, isosurface.m, isprop.m,
legend.m, line.m, loglog.m, loglogerr.m, meshgrid.m, ndgrid.m, newplot.m,
orient.m, patch.m, plot3.m, plotyy.m, __print_parse_opts__.m, quiver3.m,
refreshdata.m, ribbon.m, semilogx.m, semilogxerr.m, semilogy.m, stem.m,
stem3.m, subplot.m, title.m, uigetfile.m, view.m, whitebg.m, compan.m, conv.m,
deconv.m, mkpp.m, mpoles.m, pchip.m, poly.m, polyaffine.m, polyder.m,
polyfit.m, polygcd.m, polyint.m, polyout.m, polyval.m, polyvalm.m, ppder.m,
ppint.m, ppjumps.m, ppval.m, residue.m, roots.m, spline.m, intersect.m,
ismember.m, powerset.m, setdiff.m, setxor.m, union.m, unique.m,
autoreg_matrix.m, bartlett.m, blackman.m, detrend.m, fftconv.m, fftfilt.m,
fftshift.m, freqz.m, hamming.m, hanning.m, ifftshift.m, sinc.m, sinetone.m,
sinewave.m, unwrap.m, bicg.m, bicgstab.m, gmres.m, gplot.m, nonzeros.m, pcg.m,
pcr.m, spaugment.m, spconvert.m, spdiags.m, speye.m, spfun.m, spones.m,
sprand.m, sprandsym.m, spstats.m, spy.m, svds.m, treelayout.m, bessel.m,
beta.m, betaln.m, factor.m, factorial.m, isprime.m, lcm.m, legendre.m,
nchoosek.m, nthroot.m, perms.m, pow2.m, primes.m, reallog.m, realpow.m,
realsqrt.m, hadamard.m, hankel.m, hilb.m, invhilb.m, magic.m, rosser.m,
vander.m, __finish__.m, center.m, cloglog.m, corr.m, cov.m, gls.m, histc.m,
iqr.m, kendall.m, kurtosis.m, logit.m, mahalanobis.m, mean.m, meansq.m,
median.m, mode.m, moment.m, ols.m, ppplot.m, prctile.m, probit.m, quantile.m,
range.m, ranks.m, run_count.m, runlength.m, skewness.m, spearman.m,
statistics.m, std.m, table.m, var.m, zscore.m, betacdf.m, betainv.m, betapdf.m,
betarnd.m, binocdf.m, binoinv.m, binopdf.m, binornd.m, cauchy_cdf.m,
cauchy_inv.m, cauchy_pdf.m, cauchy_rnd.m, chi2cdf.m, chi2inv.m, chi2pdf.m,
chi2rnd.m, discrete_cdf.m, discrete_inv.m, discrete_pdf.m, discrete_rnd.m,
empirical_cdf.m, empirical_inv.m, empirical_pdf.m, empirical_rnd.m, expcdf.m,
expinv.m, exppdf.m, exprnd.m, fcdf.m, finv.m, fpdf.m, frnd.m, gamcdf.m,
gaminv.m, gampdf.m, gamrnd.m, geocdf.m, geoinv.m, geopdf.m, geornd.m,
hygecdf.m, hygeinv.m, hygepdf.m, hygernd.m, kolmogorov_smirnov_cdf.m,
laplace_cdf.m, laplace_inv.m, laplace_pdf.m, laplace_rnd.m, logistic_cdf.m,
logistic_inv.m, logistic_pdf.m, logistic_rnd.m, logncdf.m, logninv.m,
lognpdf.m, lognrnd.m, nbincdf.m, nbininv.m, nbinpdf.m, nbinrnd.m, normcdf.m,
norminv.m, normpdf.m, normrnd.m, poisscdf.m, poissinv.m, poisspdf.m,
poissrnd.m, stdnormal_cdf.m, stdnormal_inv.m, stdnormal_pdf.m, stdnormal_rnd.m,
tcdf.m, tinv.m, tpdf.m, trnd.m, unidcdf.m, unidinv.m, unidpdf.m, unidrnd.m,
unifcdf.m, unifinv.m, unifpdf.m, unifrnd.m, wblcdf.m, wblinv.m, wblpdf.m,
wblrnd.m, kolmogorov_smirnov_test.m, kruskal_wallis_test.m, base2dec.m,
bin2dec.m, blanks.m, cstrcat.m, deblank.m, dec2base.m, dec2bin.m, dec2hex.m,
findstr.m, hex2dec.m, index.m, isletter.m, mat2str.m, rindex.m, str2num.m,
strcat.m, strjust.m, strmatch.m, strsplit.m, strtok.m, strtrim.m, strtrunc.m,
substr.m, validatestring.m, demo.m, example.m, fail.m, speed.m, addtodate.m,
asctime.m, clock.m, ctime.m, date.m, datenum.m, datetick.m, datevec.m,
eomday.m, etime.m, is_leap_year.m, now.m:
Use Octave coding conventions in all m-file %!test blocks

diff --git a/scripts/audio/wavread.m b/scripts/audio/wavread.m
--- a/scripts/audio/wavread.m
+++ b/scripts/audio/wavread.m
@@ -239,11 +239,12 @@ function chunk_size = find_chunk (fid, c
     chunk_size += rem (chunk_size, 2);
     offset = offset + 8 + chunk_size;
   endwhile
   if (! strcmp (id, chunk_id))
     chunk_size = -1;
   endif
 endfunction
 
-## Mark file as being tested.  Tests for wavread/wavwrite pair are in
-## wavwrite.m
+
+## Mark file as tested.  Tests for wavread/wavwrite pair are in wavwrite.m.
 %!assert(1)
+
diff --git a/scripts/elfun/acosd.m b/scripts/elfun/acosd.m
--- a/scripts/elfun/acosd.m
+++ b/scripts/elfun/acosd.m
@@ -30,12 +30,13 @@ function y = acosd (x)
     print_usage ();
   endif
 
   y = acos (x) .* 180 ./ pi;
 
 endfunction
 
 
-%!assert (acosd (0:0.1:1), 180/pi*acos (0:0.1:1), -10*eps)
+%!assert (acosd (0:0.1:1), 180/pi * acos (0:0.1:1), -10*eps)
 
 %!error acosd ()
 %!error acosd (1, 2)
+
diff --git a/scripts/elfun/acot.m b/scripts/elfun/acot.m
--- a/scripts/elfun/acot.m
+++ b/scripts/elfun/acot.m
@@ -35,13 +35,13 @@ function y = acot (x)
 endfunction
 
 
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 %! x = [rt3, 1, rt3/3, 0, -rt3/3, -1, -rt3];
 %! v = [pi/6, pi/4, pi/3, pi/2, -pi/3, -pi/4, -pi/6];
-%! assert (all (abs (acot (x) - v) < sqrt (eps)));
+%! assert (acot (x), v, sqrt (eps));
 
 %!error acot ()
 %!error acot (1, 2)
 
diff --git a/scripts/elfun/acotd.m b/scripts/elfun/acotd.m
--- a/scripts/elfun/acotd.m
+++ b/scripts/elfun/acotd.m
@@ -30,12 +30,13 @@ function y = acotd (x)
     print_usage ();
   endif
 
   y = atand (1 ./ x);
 
 endfunction
 
 
-%!assert (acotd (0:10:90), 180./pi.*acot (0:10:90), -10*eps)
+%!assert (acotd (0:10:90), 180/pi * acot (0:10:90), -10*eps)
 
 %!error acotd ()
 %!error acotd (1, 2)
+
diff --git a/scripts/elfun/acoth.m b/scripts/elfun/acoth.m
--- a/scripts/elfun/acoth.m
+++ b/scripts/elfun/acoth.m
@@ -35,13 +35,13 @@ function y = acoth (x)
 endfunction
 
 
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 %! v = -i*[pi/6, pi/4, pi/3, -pi/3, -pi/4, -pi/6];
 %! x = i*[rt3, 1, rt3/3, -rt3/3, -1, -rt3];
-%! assert (all (abs (acoth (x) - v) < sqrt (eps)));
+%! assert (acoth (x), v, sqrt (eps));
 
 %!error acoth ()
 %!error acoth (1, 2)
 
diff --git a/scripts/elfun/acsc.m b/scripts/elfun/acsc.m
--- a/scripts/elfun/acsc.m
+++ b/scripts/elfun/acsc.m
@@ -35,13 +35,13 @@ function y = acsc (x)
 endfunction
 
 
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 %! v = [pi/6, pi/4, pi/3, pi/2, pi/3, pi/4, pi/6];
 %! x = [2, rt2, 2*rt3/3, 1, 2*rt3/3, rt2, 2];
-%! assert (all (abs (acsc (x) - v) < sqrt (eps)));
+%! assert (acsc (x), v, sqrt (eps));
 
 %!error acsc ()
 %!error acsc (1, 2)
 
diff --git a/scripts/elfun/acscd.m b/scripts/elfun/acscd.m
--- a/scripts/elfun/acscd.m
+++ b/scripts/elfun/acscd.m
@@ -30,12 +30,13 @@ function y = acscd (x)
     print_usage ();
   endif
 
   y = acsc (x) .* 180 ./ pi;
 
 endfunction
 
 
-%!assert (acscd (0:10:90), 180/pi*acsc (0:10:90), -10*eps)
+%!assert (acscd (0:10:90), 180/pi * acsc (0:10:90), -10*eps)
 
 %!error acscd ()
 %!error acscd (1, 2)
+
diff --git a/scripts/elfun/acsch.m b/scripts/elfun/acsch.m
--- a/scripts/elfun/acsch.m
+++ b/scripts/elfun/acsch.m
@@ -33,13 +33,13 @@ function y = acsch (x)
   y = asinh (1 ./ x);
 
 endfunction
 
 
 %!test
 %! v = [pi/2*i, -pi/2*i];
 %! x = [-i, i];
-%! assert (all (abs (acsch (x) - v) < sqrt (eps)));
+%! assert (acsch (x), v, sqrt (eps));
 
 %!error acsch ()
 %!error acsch (1, 2)
 
diff --git a/scripts/elfun/asec.m b/scripts/elfun/asec.m
--- a/scripts/elfun/asec.m
+++ b/scripts/elfun/asec.m
@@ -35,12 +35,13 @@ function y = asec (x)
 endfunction
 
 
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 %! v = [0, pi/6, pi/4, pi/3, 2*pi/3, 3*pi/4, 5*pi/6, pi];
 %! x = [1, 2*rt3/3, rt2, 2, -2, -rt2, -2*rt3/3, -1];
-%! assert (all (abs (asec (x) - v) < sqrt (eps)));
+%! assert (asec (x), v, sqrt (eps));
 
 %!error asec ()
 %!error asec (1, 2)
+
diff --git a/scripts/elfun/asecd.m b/scripts/elfun/asecd.m
--- a/scripts/elfun/asecd.m
+++ b/scripts/elfun/asecd.m
@@ -30,12 +30,13 @@ function y = asecd (x)
     print_usage ();
   endif
 
   y = asec (x) .* 180 ./ pi;
 
 endfunction
 
 
-%!assert (asecd (0:10:90), 180./pi.*asec (0:10:90), -10*eps)
+%!assert (asecd (0:10:90), 180/pi * asec (0:10:90), -10*eps)
 
 %!error asecd ()
 %!error asecd (1, 2)
+
diff --git a/scripts/elfun/asech.m b/scripts/elfun/asech.m
--- a/scripts/elfun/asech.m
+++ b/scripts/elfun/asech.m
@@ -33,13 +33,13 @@ function y = asech (x)
   y = acosh (1 ./ x);
 
 endfunction
 
 
 %!test
 %! v = [0, pi*i];
 %! x = [1, -1];
-%! assert (all (abs (asech (x) - v) < sqrt (eps)));
+%! assert (asech (x), v, sqrt (eps));
 
 %!error asech ()
 %!error asech (1, 2)
 
diff --git a/scripts/elfun/asind.m b/scripts/elfun/asind.m
--- a/scripts/elfun/asind.m
+++ b/scripts/elfun/asind.m
@@ -30,12 +30,13 @@ function y = asind (x)
     print_usage ();
   endif
 
   y = asin (x) .* 180 ./ pi;
 
 endfunction
 
 
-%!assert (asind (0:0.1:1), 180/pi*asin (0:0.1:1), -10*eps)
+%!assert (asind (0:0.1:1), 180/pi * asin (0:0.1:1), -10*eps)
 
 %!error asind ()
 %!error asind (1, 2)
+
diff --git a/scripts/elfun/atand.m b/scripts/elfun/atand.m
--- a/scripts/elfun/atand.m
+++ b/scripts/elfun/atand.m
@@ -30,12 +30,13 @@ function y = atand (x)
     print_usage ();
   endif
 
   y = 180 ./ pi .* atan (x);
 
 endfunction
 
 
-%!assert (atand (0:10:90), 180./pi.*atan (0:10:90), -10*eps)
+%!assert (atand (0:10:90), 180/pi * atan (0:10:90), -10*eps)
 
 %!error atand ()
 %!error atand (1, 2)
+
diff --git a/scripts/elfun/cosd.m b/scripts/elfun/cosd.m
--- a/scripts/elfun/cosd.m
+++ b/scripts/elfun/cosd.m
@@ -40,8 +40,9 @@ endfunction
 
 
 %!assert (cosd (0:10:80), cos (pi*[0:10:80]/180), -10*eps)
 %!assert (cosd ([0, 180, 360]) != 0)
 %!assert (cosd ([90, 270]) == 0)
 
 %!error cosd ()
 %!error cosd (1, 2)
+
diff --git a/scripts/elfun/cot.m b/scripts/elfun/cot.m
--- a/scripts/elfun/cot.m
+++ b/scripts/elfun/cot.m
@@ -35,13 +35,13 @@ function y = cot (x)
 endfunction
 
 
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 %! x = [pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6];
 %! v = [rt3, 1, rt3/3, 0, -rt3/3, -1, -rt3];
-%! assert (all (abs (cot (x) - v) < sqrt (eps)));
+%! assert (cot (x), v, sqrt (eps));
 
 %!error cot ()
 %!error cot (1, 2)
 
diff --git a/scripts/elfun/cotd.m b/scripts/elfun/cotd.m
--- a/scripts/elfun/cotd.m
+++ b/scripts/elfun/cotd.m
@@ -36,8 +36,9 @@ endfunction
 
 
 %!assert (cotd (10:10:80), cot (pi*[10:10:80]/180), -10*eps)
 %!assert (cotd ([0, 180, 360]) == Inf)
 %!assert (cotd ([90, 270]) == 0)
 
 %!error cotd ()
 %!error cotd (1, 2)
+
diff --git a/scripts/elfun/coth.m b/scripts/elfun/coth.m
--- a/scripts/elfun/coth.m
+++ b/scripts/elfun/coth.m
@@ -33,13 +33,13 @@ function y = coth (x)
   y = 1 ./ tanh (x);
 
 endfunction
 
 
 %!test
 %! x = [pi/2*i, 3*pi/2*i];
 %! v = [0, 0];
-%! assert (all (abs (coth (x) - v) < sqrt (eps)));
+%! assert (coth (x), v, sqrt (eps));
 
 %!error coth ()
 %!error coth (1, 2)
 
diff --git a/scripts/elfun/csc.m b/scripts/elfun/csc.m
--- a/scripts/elfun/csc.m
+++ b/scripts/elfun/csc.m
@@ -35,13 +35,13 @@ function y = csc (x)
 endfunction
 
 
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 %! x = [pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6];
 %! v = [2, rt2, 2*rt3/3, 1, 2*rt3/3, rt2, 2];
-%! assert (all (abs (csc (x) - v) < sqrt (eps)));
+%! assert (csc (x), v, sqrt (eps));
 
 %!error csc ()
 %!error csc (1, 2)
 
diff --git a/scripts/elfun/cscd.m b/scripts/elfun/cscd.m
--- a/scripts/elfun/cscd.m
+++ b/scripts/elfun/cscd.m
@@ -36,8 +36,9 @@ endfunction
 
 
 %!assert (cscd (10:10:90), csc (pi*[10:10:90]/180), -10*eps)
 %!assert (cscd ([0, 180, 360]) == Inf)
 %!assert (cscd ([90, 270]) != Inf)
 
 %!error cscd ()
 %!error cscd (1, 2)
+
diff --git a/scripts/elfun/csch.m b/scripts/elfun/csch.m
--- a/scripts/elfun/csch.m
+++ b/scripts/elfun/csch.m
@@ -33,13 +33,13 @@ function y = csch (x)
   y = 1 ./ sinh (x);
 
 endfunction
 
 
 %!test
 %! x = [pi/2*i, 3*pi/2*i];
 %! v = [-i, i];
-%! assert (all (abs (csch (x) - v) < sqrt (eps)));
+%! assert (csch (x), v, sqrt (eps));
 
 %!error csch ()
 %!error csch (1, 2)
 
diff --git a/scripts/elfun/sec.m b/scripts/elfun/sec.m
--- a/scripts/elfun/sec.m
+++ b/scripts/elfun/sec.m
@@ -35,13 +35,13 @@ function y = sec (x)
 endfunction
 
 
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 %! x = [0, pi/6, pi/4, pi/3, 2*pi/3, 3*pi/4, 5*pi/6, pi];
 %! v = [1, 2*rt3/3, rt2, 2, -2, -rt2, -2*rt3/3, -1];
-%! assert (all (abs (sec (x) - v) < sqrt (eps)));
+%! assert (sec (x), v, sqrt (eps));
 
 %!error sec ()
 %!error sec (1, 2)
 
diff --git a/scripts/elfun/secd.m b/scripts/elfun/secd.m
--- a/scripts/elfun/secd.m
+++ b/scripts/elfun/secd.m
@@ -36,8 +36,9 @@ endfunction
 
 
 %!assert (secd (0:10:80), sec (pi*[0:10:80]/180), -10*eps)
 %!assert (secd ([0, 180, 360]) != Inf)
 %!assert (secd ([90, 270]) == Inf)
 
 %!error secd ()
 %!error secd (1, 2)
+
diff --git a/scripts/elfun/sech.m b/scripts/elfun/sech.m
--- a/scripts/elfun/sech.m
+++ b/scripts/elfun/sech.m
@@ -33,13 +33,13 @@ if (nargin != 1)
   y = 1 ./ cosh (x);
 
 endfunction
 
 
 %!test
 %! x = [0, pi*i];
 %! v = [1, -1];
-%! assert (all (abs (sech (x) - v) < sqrt (eps)));
+%! assert (sech (x), v, sqrt (eps));
 
 %!error sech ()
 %!error sech (1, 2)
 
diff --git a/scripts/elfun/sind.m b/scripts/elfun/sind.m
--- a/scripts/elfun/sind.m
+++ b/scripts/elfun/sind.m
@@ -39,8 +39,9 @@ endfunction
 
 
 %!assert (sind (10:10:90), sin (pi*[10:10:90]/180), -10*eps)
 %!assert (sind ([0, 180, 360]) == 0)
 %!assert (sind ([90, 270]) != 0)
 
 %!error sind ()
 %!error sind (1, 2)
+
diff --git a/scripts/elfun/tand.m b/scripts/elfun/tand.m
--- a/scripts/elfun/tand.m
+++ b/scripts/elfun/tand.m
@@ -42,8 +42,9 @@ endfunction
 
 
 %!assert (tand (10:10:80), tan (pi*[10:10:80]/180), -10*eps)
 %!assert (tand ([0, 180, 360]) == 0)
 %!assert (tand ([90, 270]) == Inf)
 
 %!error tand ()
 %!error tand (1, 2)
+
diff --git a/scripts/general/accumarray.m b/scripts/general/accumarray.m
--- a/scripts/general/accumarray.m
+++ b/scripts/general/accumarray.m
@@ -363,34 +363,33 @@ function A = accumarray (subs, vals, sz 
       endif
 
       ## Set the reduced values.
       A(subs) = vals;
     endif
   endif
 endfunction
 
-%!error (accumarray (1:5))
-%!error (accumarray ([1,2,3],1:2))
+
 %!assert (accumarray ([1;2;4;2;4],101:105), [101;206;0;208])
-%!assert (accumarray ([1,1,1;2,1,2;2,3,2;2,1,2;2,3,2],101:105),cat(3, [101,0,0;0,0,0],[0,0,0;206,0,208]))
-%!assert (accumarray ([1,1,1;2,1,2;2,3,2;2,1,2;2,3,2],101:105,[],@(x)sin(sum(x))),sin(cat(3, [101,0,0;0,0,0],[0,0,0;206,0,208])))
-%!assert (accumarray ({[1 3 3 2 3 1 2 2 3 3 1 2],[3 4 2 1 4 3 4 2 2 4 3 4],[1 1 2 2 1 1 2 1 1 1 2 2]},101:112),cat(3,[0,0,207,0;0,108,0,0;0,109,0,317],[0,0,111,0;104,0,0,219;0,103,0,0]))
-%!assert (accumarray ([1,1;2,1;2,3;2,1;2,3],101:105,[2,4],@max,NaN),[101,NaN,NaN,NaN;104,NaN,105,NaN])
+%!assert (accumarray ([1,1,1;2,1,2;2,3,2;2,1,2;2,3,2],101:105), cat(3, [101,0,0;0,0,0],[0,0,0;206,0,208]))
+%!assert (accumarray ([1,1,1;2,1,2;2,3,2;2,1,2;2,3,2],101:105,[],@(x)sin(sum(x))), sin (cat (3, [101,0,0;0,0,0],[0,0,0;206,0,208])))
+%!assert (accumarray ({[1 3 3 2 3 1 2 2 3 3 1 2],[3 4 2 1 4 3 4 2 2 4 3 4],[1 1 2 2 1 1 2 1 1 1 2 2]},101:112), cat (3, [0,0,207,0;0,108,0,0;0,109,0,317], [0,0,111,0;104,0,0,219;0,103,0,0]))
+%!assert (accumarray ([1,1;2,1;2,3;2,1;2,3],101:105,[2,4],@max,NaN), [101,NaN,NaN,NaN;104,NaN,105,NaN])
 %!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],101:105, [], @prod), [101, 0, 0; 10608, 0, 10815])
-%!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],101:105,[2 4],@prod,0,true),sparse([1,2,2],[1,1,3],[101,10608,10815],2,4))
+%!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],101:105,[2 4],@prod,0,true), sparse ([1,2,2],[1,1,3],[101,10608,10815],2,4))
 %!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],1,[2,4]), [1,0,0,0;2,0,2,0])
-%!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],101:105,[2,4],@(x)length(x)>1),[false,false,false,false;true,false,true,false])
+%!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],101:105,[2,4],@(x)length(x)>1), [false,false,false,false;true,false,true,false])
 %!assert (accumarray ([1; 2], [3; 4], [2, 1], @min, [], 0), [3; 4])
 %!assert (accumarray ([1; 2], [3; 4], [2, 1], @min, [], 1), sparse ([3; 4]))
 %!assert (accumarray ([1; 2], [3; 4], [1, 2], @min, [], 0), [3, 4])
 %!assert (accumarray ([1; 2], [3; 4], [1, 2], @min, [], 1), sparse ([3, 4]))
 %!test
-%! A = accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],101:105,[2,4],@(x){x});
-%! assert (A{2},[102;104])
+%! A = accumarray ([1 1; 2 1; 2 3; 2 1; 2 3], 101:105, [2,4], @(x){x});
+%! assert (A{2},[102;104]);
 %!test
 %! subs = ceil (rand (2000, 3)*10);
 %! vals = rand (2000, 1);
 %! assert (accumarray (subs, vals, [], @max), accumarray (subs, vals, [], @(x) max (x)));
 %!test
 %! subs = ceil (rand (2000, 1)*100);
 %! vals = rand (2000, 1);
 %! assert (accumarray (subs, vals, [100, 1], @min, NaN), accumarray (subs, vals, [100, 1], @(x) min (x), NaN));
@@ -400,9 +399,11 @@ endfunction
 %! vals = rand (2000, 1);
 %! assert (accumarray (subsc, vals, [], [], 0, true), accumarray (subs, vals, [], [], 0, true));
 %!test
 %! subs = ceil (rand (2000, 3)*10);
 %! subsc = num2cell (subs, 1);
 %! vals = rand (2000, 1);
 %! assert (accumarray (subsc, vals, [], @max), accumarray (subs, vals, [], @max));
 
+%!error (accumarray (1:5))
+%!error (accumarray ([1,2,3],1:2))
 
diff --git a/scripts/general/accumdim.m b/scripts/general/accumdim.m
--- a/scripts/general/accumdim.m
+++ b/scripts/general/accumdim.m
@@ -143,17 +143,19 @@ function A = accumdim (subs, vals, dim, 
   endif
 
   ## Set the reduced values.
   subsc{dim} = subs;
   A(subsc{:}) = vals;
 
 endfunction
 
+
 %%test accumdim vs. accumarray
 
 %!shared a
 %! a = rand (5, 5, 5);
 
 %!assert (accumdim ([1;3;1;3;3], a)(:,2,3), accumarray ([1;3;1;3;3], a(:,2,3)))
 %!assert (accumdim ([2;3;2;2;2], a, 2, 4)(4,:,2), accumarray ([2;3;2;2;2], a(4,:,2), [1,4]))
 %!assert (accumdim ([2;3;2;1;2], a, 3, 3, @min)(1,5,:), accumarray ([2;3;2;1;2], a(1,5,:), [1,1,3], @min))
 %!assert (accumdim ([1;3;2;2;1], a, 2, 3, @median)(4,:,5), accumarray ([1;3;2;2;1], a(4,:,5), [1,3], @median))
+
diff --git a/scripts/general/bitcmp.m b/scripts/general/bitcmp.m
--- a/scripts/general/bitcmp.m
+++ b/scripts/general/bitcmp.m
@@ -81,43 +81,43 @@ function C = bitcmp (A, k)
     endif
     mask = bitshift (bmax, k - amax);
     C = bitxor (bitand (A, mask), mask);
   endif
 endfunction
 
 
 %!test
-%! Amax=53;
+%! Amax = 53;
 %! Bmax = bitmax;
-%! A = bitshift(Bmax,-2);
-%! assert(bitcmp(A,Amax),bitor(bitshift(1,Amax-1),bitshift(1,Amax-2)));
-%! assert(bitcmp(A,Amax-1),bitshift(1,Amax-2));
-%! assert(bitcmp(A,Amax-2),0);
+%! A = bitshift (Bmax,-2);
+%! assert (bitcmp (A,Amax),bitor (bitshift (1,Amax-1), bitshift (1,Amax-2)));
+%! assert (bitcmp (A,Amax-1), bitshift (1,Amax-2));
+%! assert (bitcmp (A,Amax-2), 0);
 %!test
-%! Amax=8;
-%! Bmax = intmax('uint8');
-%! A = bitshift(Bmax,-2);
-%! assert(bitcmp(A,Amax),bitor(bitshift(uint8(1),Amax-1),bitshift(uint8(1),Amax-2)));
-%! assert(bitcmp(A,Amax-1),bitshift(uint8(1),Amax-2));
-%! assert(bitcmp(A,Amax-2),uint8(0));
+%! Amax = 8;
+%! Bmax = intmax ("uint8");
+%! A = bitshift (Bmax,-2);
+%! assert (bitcmp (A,Amax),bitor (bitshift (uint8 (1),Amax-1), bitshift (uint8 (1),Amax-2)));
+%! assert (bitcmp (A,Amax-1), bitshift (uint8 (1),Amax-2));
+%! assert (bitcmp (A,Amax-2), uint8 (0));
 %!test
-%! Amax=16;
-%! Bmax = intmax('uint16');
-%! A = bitshift(Bmax,-2);
-%! assert(bitcmp(A,Amax),bitor(bitshift(uint16(1),Amax-1),bitshift(uint16(1),Amax-2)));
-%! assert(bitcmp(A,Amax-1),bitshift(uint16(1),Amax-2));
-%! assert(bitcmp(A,Amax-2),uint16(0));
+%! Amax = 16;
+%! Bmax = intmax ("uint16");
+%! A = bitshift (Bmax,-2);
+%! assert (bitcmp (A,Amax),bitor (bitshift (uint16 (1),Amax-1), bitshift (uint16 (1),Amax-2)));
+%! assert (bitcmp (A,Amax-1), bitshift (uint16 (1),Amax-2));
+%! assert (bitcmp (A,Amax-2), uint16 (0));
 %!test
-%! Amax=32;
-%! Bmax = intmax('uint32');
-%! A = bitshift(Bmax,-2);
-%! assert(bitcmp(A,Amax),bitor(bitshift(uint32(1),Amax-1),bitshift(uint32(1),Amax-2)));
-%! assert(bitcmp(A,Amax-1),bitshift(uint32(1),Amax-2));
-%! assert(bitcmp(A,Amax-2),uint32(0));
+%! Amax = 32;
+%! Bmax = intmax ("uint32");
+%! A = bitshift (Bmax,-2);
+%! assert (bitcmp (A,Amax),bitor (bitshift (uint32 (1),Amax-1), bitshift (uint32 (1),Amax-2)));
+%! assert (bitcmp (A,Amax-1), bitshift (uint32 (1),Amax-2));
+%! assert (bitcmp (A,Amax-2), uint32 (0));
 %!test
-%! Amax=64;
-%! Bmax = intmax('uint64');
-%! A = bitshift(Bmax,-2);
-%! assert(bitcmp(A,Amax),bitor(bitshift(uint64(1),Amax-1),bitshift(uint64(1),Amax-2)));
-%! assert(bitcmp(A,Amax-1),bitshift(uint64(1),Amax-2));
-%! assert(bitcmp(A,Amax-2),uint64(0));
+%! Amax = 64;
+%! Bmax = intmax ("uint64");
+%! A = bitshift (Bmax,-2);
+%! assert (bitcmp (A,Amax),bitor (bitshift (uint64 (1),Amax-1), bitshift (uint64 (1),Amax-2)));
+%! assert (bitcmp (A,Amax-1), bitshift (uint64 (1),Amax-2));
+%! assert (bitcmp (A,Amax-2), uint64 (0));
 
diff --git a/scripts/general/bitget.m b/scripts/general/bitget.m
--- a/scripts/general/bitget.m
+++ b/scripts/general/bitget.m
@@ -75,35 +75,37 @@ function C = bitget (A, n)
   if (any (m < 1) || any (m > Amax))
     error ("bitget: N must be in the range [1,%d]", Amax);
   endif
 
   C = bitand (A, bitshift (_conv (1), uint8 (n) - uint8 (1))) != _conv (0);
 
 endfunction
 
-%!error bitget (1);
-%!error bitget (1, 2, 3);
 
 %!test
 %! assert (bitget ([4, 14], [3, 3]), logical ([1, 1]));
 %! pfx = {"", "u"};
 %! for i = 1:2
 %!   for prec = [8, 16, 32, 64]
 %!     fcn = str2func (sprintf ("%sint%d", pfx{i}, prec));
 %!     assert (bitget (fcn ([4, 14]), [3, 3]), logical ([1, 1]));
 %!   endfor
 %! endfor
 
-%!error bitget (0, 0);
-%!error bitget (0, 55);
+%!error bitget (0, 0)
+%!error bitget (0, 55)
 
-%!error bitget (int8 (0), 9);
-%!error bitget (uint8 (0), 9);
+%!error bitget (int8 (0), 9)
+%!error bitget (uint8 (0), 9)
+
+%!error bitget (int16 (0), 17)
+%!error bitget (uint16 (0), 17)
 
-%!error bitget (int16 (0), 17);
-%!error bitget (uint16 (0), 17);
+%!error bitget (int32 (0), 33)
+%!error bitget (uint32 (0), 33)
 
-%!error bitget (int32 (0), 33);
-%!error bitget (uint32 (0), 33);
+%!error bitget (int64 (0), 65)
+%!error bitget (uint64 (0), 65)
 
-%!error bitget (int64 (0), 65);
-%!error bitget (uint64 (0), 65);
+%!error bitget (1)
+%!error bitget (1, 2, 3)
+
diff --git a/scripts/general/bitset.m b/scripts/general/bitset.m
--- a/scripts/general/bitset.m
+++ b/scripts/general/bitset.m
@@ -88,35 +88,33 @@ function C = bitset (A, n, val)
   C = bitxor (A, bitand (A, mask));
 
   if (val)
     C = bitor (A, mask);
   endif
 
 endfunction
 
-%!error bitset (1);
-%!error bitset (1, 2, 3, 4);
 
 %!test
 %! assert (bitset ([0, 10], [3, 3]), [4, 14]);
 %! pfx = {"", "u"};
 %! for i = 1:2
 %!   for prec = [8, 16, 32, 64]
 %!     fcn = str2func (sprintf ("%sint%d", pfx{i}, prec));
 %!     assert (bitset (fcn ([0, 10]), [3, 3]), fcn ([4, 14]));
 %!   endfor
 %! endfor
 
-%!error bitset (0, 0);
-%!error bitset (0, 55);
-
-%!error bitset (int8 (0), 9);
-%!error bitset (uint8 (0), 9);
+%!error bitset (0, 0)
+%!error bitset (0, 55)
+%!error bitset (int8 (0), 9)
+%!error bitset (uint8 (0), 9)
+%!error bitset (int16 (0), 17)
+%!error bitset (uint16 (0), 17)
+%!error bitset (int32 (0), 33)
+%!error bitset (uint32 (0), 33)
+%!error bitset (int64 (0), 65)
+%!error bitset (uint64 (0), 65)
 
-%!error bitset (int16 (0), 17);
-%!error bitset (uint16 (0), 17);
+%!error bitset (1)
+%!error bitset (1, 2, 3, 4)
 
-%!error bitset (int32 (0), 33);
-%!error bitset (uint32 (0), 33);
-
-%!error bitset (int64 (0), 65);
-%!error bitset (uint64 (0), 65);
diff --git a/scripts/general/blkdiag.m b/scripts/general/blkdiag.m
--- a/scripts/general/blkdiag.m
+++ b/scripts/general/blkdiag.m
@@ -58,24 +58,26 @@ function retval = blkdiag (varargin)
     vp = varargin{p};
     if (! isempty (vp))
       retval((csz(p,1)+1):csz(p+1,1),(csz(p,2)+1):csz(p+1,2)) = vp;
     endif
   endfor
 
 endfunction
 
+
 ## regular tests
-%!assert(blkdiag(1,ones(2),1),[1,0,0,0;0,1,1,0;0,1,1,0;0,0,0,1])
-%!assert(blkdiag([1,2],[3,4],[5,6]),[1,2,0,0,0,0;0,0,3,4,0,0;0,0,0,0,5,6])
-%!assert(blkdiag([1,2],[3;4],[5,6]),[1,2,0,0,0;0,0,3,0,0;0,0,4,0,0;0,0,0,5,6])
-%!assert(blkdiag([1,2;3,4],[5,6,7]),[1,2,0,0,0;3,4,0,0,0;0,0,5,6,7])
+%!assert (blkdiag (1,ones (2),1), [1,0,0,0;0,1,1,0;0,1,1,0;0,0,0,1])
+%!assert (blkdiag ([1,2],[3,4],[5,6]), [1,2,0,0,0,0;0,0,3,4,0,0;0,0,0,0,5,6])
+%!assert (blkdiag ([1,2],[3;4],[5,6]), [1,2,0,0,0;0,0,3,0,0;0,0,4,0,0;0,0,0,5,6])
+%!assert (blkdiag ([1,2;3,4],[5,6,7]), [1,2,0,0,0;3,4,0,0,0;0,0,5,6,7])
 ## tests involving empty matrices
-%!assert(blkdiag([],[],[]),[])
-%!assert(blkdiag([],[1,2;3,4],[],5,[]),[1,2,0;3,4,0;0,0,5])
-%!assert(blkdiag(zeros(1,0,1),[1,2,3],1,0,5,zeros(0,1,1)),[0,0,0,0,0,0,0;1,2,3,0,0,0,0;0,0,0,1,0,0,0;0,0,0,0,0,0,0;0,0,0,0,0,5,0]);
+%!assert (blkdiag ([],[],[]), [])
+%!assert (blkdiag ([],[1,2;3,4],[],5,[]), [1,2,0;3,4,0;0,0,5])
+%!assert (blkdiag (zeros (1,0,1),[1,2,3],1,0,5,zeros (0,1,1)), [0,0,0,0,0,0,0;1,2,3,0,0,0,0;0,0,0,1,0,0,0;0,0,0,0,0,0,0;0,0,0,0,0,5,0]);
 ## tests involving sparse matrices
-%!assert (blkdiag (sparse([1,2;3,4]),[5,6;7,8]), sparse([1,2,0,0;3,4,0,0;0,0,5,6;0,0,7,8]))
-%!assert (blkdiag (sparse([1,2;3,4]),[5,6]), sparse([1,2,0,0;3,4,0,0;0,0,5,6]))
+%!assert (blkdiag (sparse ([1,2;3,4]),[5,6;7,8]), sparse ([1,2,0,0;3,4,0,0;0,0,5,6;0,0,7,8]))
+%!assert (blkdiag (sparse ([1,2;3,4]),[5,6]), sparse ([1,2,0,0;3,4,0,0;0,0,5,6]))
 # sanity checks
 %!test
 %! A = rand (round (rand (1, 2) * 10));
 %! assert (blkdiag (A), A);
+
diff --git a/scripts/general/cart2pol.m b/scripts/general/cart2pol.m
--- a/scripts/general/cart2pol.m
+++ b/scripts/general/cart2pol.m
@@ -76,37 +76,38 @@ function [theta, r, z] = cart2pol (x, y,
   r = sqrt (x .^ 2 + y .^ 2);
 
   if (nargout <= 1)
     theta = [theta, r, z];
   endif
 
 endfunction
 
+
 %!test
 %! x = [0, 1, 2];
 %! y = 0;
 %! [t, r] = cart2pol (x, y);
 %! assert (t, [0, 0, 0]);
 %! assert (r, x);
 
 %!test
 %! x = [0, 1, 2];
 %! y = [0, 1, 2];
 %! [t, r] = cart2pol (x, y);
-%! assert (t, [0, pi/4, pi/4], sqrt(eps));
-%! assert (r, sqrt(2)*[0, 1, 2], sqrt(eps));
+%! assert (t, [0, pi/4, pi/4], sqrt (eps));
+%! assert (r, sqrt (2)*[0, 1, 2], sqrt (eps));
 
 %!test
 %! x = [0, 1, 2];
 %! y = [0, 1, 2];
 %! z = [0, 1, 2];
 %! [t, r, z2] = cart2pol (x, y, z);
-%! assert (t, [0, pi/4, pi/4], sqrt(eps));
-%! assert (r, sqrt(2)*[0, 1, 2], sqrt(eps));
+%! assert (t, [0, pi/4, pi/4], sqrt (eps));
+%! assert (r, sqrt (2)*[0, 1, 2], sqrt (eps));
 %! assert (z, z2);
 
 %!test
 %! x = [0, 1, 2];
 %! y = 0;
 %! z = 0;
 %! [t, r, z2] = cart2pol (x, y, z);
 %! assert (t, [0, 0, 0], eps);
@@ -129,15 +130,15 @@ endfunction
 %! [t, r, z2] = cart2pol (x, y, z);
 %! assert (t, 0);
 %! assert (r, 0);
 %! assert (z, z2);
 
 %!test
 %! C = [0, 0; 1, 1; 2, 2];
 %! P = [0, 0; pi/4, sqrt(2); pi/4, 2*sqrt(2)];
-%! assert (cart2pol (C), P, sqrt(eps));
+%! assert (cart2pol (C), P, sqrt (eps));
 
 %!test
 %! C = [0, 0, 0; 1, 1, 1; 2, 2, 2];
 %! P = [0, 0, 0; pi/4, sqrt(2), 1; pi/4, 2*sqrt(2), 2];
-%! assert (cart2pol (C), P, sqrt(eps));
+%! assert (cart2pol (C), P, sqrt (eps));
 
diff --git a/scripts/general/cart2sph.m b/scripts/general/cart2sph.m
--- a/scripts/general/cart2sph.m
+++ b/scripts/general/cart2sph.m
@@ -66,48 +66,50 @@ function [theta, phi, r] = cart2sph (x, 
   r = sqrt (x .^ 2 + y .^ 2 + z .^ 2);
 
   if (nargout <= 1)
     theta = [theta, phi, r];
   endif
 
 endfunction
 
+
 %!test
 %! x = [0, 1, 2];
 %! y = [0, 1, 2];
 %! z = [0, 1, 2];
 %! [t, p, r] = cart2sph (x, y, z);
 %! assert (t, [0, pi/4, pi/4], eps);
-%! assert (p, [0, 1, 1]*atan(sqrt(0.5)), eps);
-%! assert (r, [0, 1, 2]*sqrt(3), eps);
+%! assert (p, [0, 1, 1]*atan (sqrt (0.5)), eps);
+%! assert (r, [0, 1, 2]*sqrt (3), eps);
 
 %!test
 %! x = 0;
 %! y = [0, 1, 2];
 %! z = [0, 1, 2];
 %! [t, p, r] = cart2sph (x, y, z);
 %! assert (t, [0, 1, 1] * pi/2, eps);
 %! assert (p, [0, 1, 1] * pi/4, eps);
-%! assert (r, [0, 1, 2] * sqrt(2), eps);
+%! assert (r, [0, 1, 2] * sqrt (2), eps);
 
 %!test
 %! x = [0, 1, 2];
 %! y = 0;
 %! z = [0, 1, 2];
 %! [t, p, r] = cart2sph (x, y, z);
 %! assert (t, [0, 0, 0]);
 %! assert (p, [0, 1, 1] * pi/4);
-%! assert (r, [0, 1, 2] * sqrt(2));
+%! assert (r, [0, 1, 2] * sqrt (2));
 
 %!test
 %! x = [0, 1, 2];
 %! y = [0, 1, 2];
 %! z = 0;
 %! [t, p, r] = cart2sph (x, y, z);
 %! assert (t, [0, 1, 1] * pi/4);
 %! assert (p, [0, 0, 0]);
-%! assert (r, [0, 1, 2] * sqrt(2));
+%! assert (r, [0, 1, 2] * sqrt (2));
 
 %!test
 %! C = [0, 0, 0; 1, 0, 1; 2, 0, 2];
 %! S = [0, 0, 0; 0, pi/4, sqrt(2); 0, pi/4, 2*sqrt(2)];
-%! assert (cart2sph(C), S, eps);
+%! assert (cart2sph (C), S, eps);
+
diff --git a/scripts/general/celldisp.m b/scripts/general/celldisp.m
--- a/scripts/general/celldisp.m
+++ b/scripts/general/celldisp.m
@@ -78,11 +78,12 @@ function s = indices (dv, i)
   endif
 endfunction
 
 
 %!demo
 %! c = {1, 2, {31, 32}};
 %! celldisp (c, "b")
 
-%!error celldisp ();
-%!error celldisp ({}, "name", 1);
-%!error celldisp (1);
+%!error celldisp ()
+%!error celldisp ({}, "name", 1)
+%!error celldisp (1)
+
diff --git a/scripts/general/chop.m b/scripts/general/chop.m
--- a/scripts/general/chop.m
+++ b/scripts/general/chop.m
@@ -73,8 +73,9 @@ endfunction
 %!assert (chop (e, 4, 5), 2.72)
 %!assert (chop (e, 4, 7), 2.716)
 %!assert (chop (-e, 3), -2.72)
 %!assert (chop (-e, 4), -2.718)
 %!assert (chop (-e, 4, 5), -2.72)
 %!assert (chop (-e, 4, 7), -2.716)
 %!assert (chop (hilb (3), 3), [1,.5,.333;.5,.333,.25;.333,.25,.2])
 %!assert (chop (hilb (3), 2, 7), [.7,.49,.35;.49,.35,.28;.35,.28,.21], 2*eps)
+
diff --git a/scripts/general/circshift.m b/scripts/general/circshift.m
--- a/scripts/general/circshift.m
+++ b/scripts/general/circshift.m
@@ -93,12 +93,12 @@ endfunction
 
 %!assert (circshift (eye (3), 1), circshift (eye (3), 1))
 %!assert (circshift (eye (3), 1), [0,0,1;1,0,0;0,1,0])
 
 %% Test input validation
 %!error circshift ()
 %!error circshift (1)
 %!error circshift (1,2,3)
-%!error circshift (1, ones(2,2))
+%!error circshift (1, ones (2,2))
 %!error circshift (1, [1 2 3])
 %!error circshift (1, 1.5)
 
diff --git a/scripts/general/colon.m b/scripts/general/colon.m
--- a/scripts/general/colon.m
+++ b/scripts/general/colon.m
@@ -34,11 +34,12 @@
 ## @end deftypefn
 
 function r = colon (varargin)
   if (nargin != 0)
     error ("colon: not defined for class \"%s\"", class(varargin{1}));
   endif
 endfunction
 
+
 %!error colon (1)
 
 ## FIXME -- what does colon () mean since it doesn't set a return value?
diff --git a/scripts/general/common_size.m b/scripts/general/common_size.m
--- a/scripts/general/common_size.m
+++ b/scripts/general/common_size.m
@@ -74,17 +74,19 @@ function [errorcode, varargout] = common
           subs = arrayfun (@ones, 1, dims, "uniformoutput", false);
           varargout(scal) = cellindexmat (varargin(scal), subs{:});
         endif
       endif
     endif
   endif
 endfunction
 
-%!error common_size ();
 
 %!test
 %! m = [1,2;3,4];
 %! [err, a, b, c] = common_size (m, 3, 5);
 %! assert (err, 0);
 %! assert (a, m);
 %! assert (b, [3,3;3,3]);
 %! assert (c, [5,5;5,5]);
+
+%!error common_size ()
+
diff --git a/scripts/general/cplxpair.m b/scripts/general/cplxpair.m
--- a/scripts/general/cplxpair.m
+++ b/scripts/general/cplxpair.m
@@ -158,9 +158,9 @@ endfunction
 %!assert (cplxpair (z(randperm (7))), z)
 %!assert (cplxpair (z(randperm (7))), z)
 %!assert (cplxpair ([z(randperm(7)),z(randperm(7))]), [z,z])
 %!assert (cplxpair ([z(randperm(7)),z(randperm(7))],[],1), [z,z])
 %!assert (cplxpair ([z(randperm(7)).';z(randperm(7)).'],[],2), [z.';z.'])
 
 %!## tolerance test
 %!assert (cplxpair ([1i, -1i, 1+(1i*eps)],2*eps), [-1i, 1i, 1+(1i*eps)])
-
+ 
diff --git a/scripts/general/cumtrapz.m b/scripts/general/cumtrapz.m
--- a/scripts/general/cumtrapz.m
+++ b/scripts/general/cumtrapz.m
@@ -112,23 +112,23 @@ function z = cumtrapz (x, y, dim)
 
 endfunction
 
 
 %!shared x1,x2,y
 %! x1 = [0,0,0;2,2,2];
 %! x2 = [0,2,4;0,2,4];
 %! y = [1,2,3;4,5,6];
-%!assert (cumtrapz(y), [0,0,0;2.5,3.5,4.5])
-%!assert (cumtrapz(x1,y), [0,0,0;5,7,9])
-%!assert (cumtrapz(y,1), [0,0,0;2.5,3.5,4.5])
-%!assert (cumtrapz(x1,y,1), [0,0,0;5,7,9])
-%!assert (cumtrapz(y,2), [0,1.5,4;0,4.5,10])
-%!assert (cumtrapz(x2,y,2), [0,3,8;0,9,20])
+%!assert (cumtrapz (y), [0,0,0;2.5,3.5,4.5])
+%!assert (cumtrapz (x1,y), [0,0,0;5,7,9])
+%!assert (cumtrapz (y,1), [0,0,0;2.5,3.5,4.5])
+%!assert (cumtrapz (x1,y,1), [0,0,0;5,7,9])
+%!assert (cumtrapz (y,2), [0,1.5,4;0,4.5,10])
+%!assert (cumtrapz (x2,y,2), [0,3,8;0,9,20])
 %% Test ND-array implementation
 %!shared x1,x2,y
 %! x1 = 1:3;
 %! x2 = reshape ([0,2,4;0,2,4], [1 2 3]);
 %! y = reshape ([1,2,3;4,5,6], [1 2 3]);
-%!assert (cumtrapz(y,3), reshape([0,1.5,4;0,4.5,10],[1 2 3]))
-%!assert (cumtrapz(x1,y,3), reshape([0,1.5,4;0,4.5,10],[1 2 3]))
-%!assert (cumtrapz(x2,y,3), reshape([0,3,8;0,9,20],[1 2 3]))
+%!assert (cumtrapz (y,3), reshape ([0,1.5,4;0,4.5,10],[1 2 3]))
+%!assert (cumtrapz (x1,y,3), reshape ([0,1.5,4;0,4.5,10],[1 2 3]))
+%!assert (cumtrapz (x2,y,3), reshape ([0,3,8;0,9,20],[1 2 3]))
 
diff --git a/scripts/general/curl.m b/scripts/general/curl.m
--- a/scripts/general/curl.m
+++ b/scripts/general/curl.m
@@ -124,19 +124,21 @@ function varargout = curl (varargin)
       varargout{2} = rot_y;
       varargout{3} = rot_z;
       varargout{4} = av;
     endif
   endif
 
 endfunction
 
+
 %!test
-%! [X,Y]=meshgrid(-20:20,-22:22);
-%! av = curl(2*(X-Y),Y);
-%! assert(all(av(:)==1));
-%! [cz,av] = curl(2*(X-Y),Y);
-%! assert(all(cz(:)==2));
-%! assert(all(av(:)==1));
-%! [cz,av] = curl(X/2,Y/2,2*(X-Y),Y);
-%! assert(all(cz(:)==4));
-%! assert(all(av(:)==2));
-%! assert(size_equal(X,Y,cz,av));
+%! [X,Y] = meshgrid (-20:20,-22:22);
+%! av = curl (2*(X-Y), Y);
+%! assert (all (av(:) == 1));
+%! [cz,av] = curl (2*(X-Y), Y);
+%! assert (all (cz(:) == 2));
+%! assert (all (av(:) == 1));
+%! [cz,av] = curl (X/2, Y/2, 2*(X-Y), Y);
+%! assert (all (cz(:) == 4));
+%! assert (all (av(:) == 2));
+%! assert (size_equal (X,Y,cz,av));
+
diff --git a/scripts/general/dblquad.m b/scripts/general/dblquad.m
--- a/scripts/general/dblquad.m
+++ b/scripts/general/dblquad.m
@@ -68,15 +68,16 @@ endfunction
 
 function q = __dblquad_inner__ (y, f, xa, xb, tol, quadf, varargin)
   q = zeros (size(y));
   for i = 1 : length (y)
     q(i) = feval (quadf, @(x) f(x, y(i), varargin{:}), xa, xb, tol);
   endfor
 endfunction
 
+
 %% Nasty integrand to show quadcc off
-%!assert (dblquad (@(x,y) 1 ./ (x+y), 0, 1, 0, 1), 2*log(2), 1e-6)
+%!assert (dblquad (@(x,y) 1 ./ (x+y), 0, 1, 0, 1), 2*log (2), 1e-6)
 
-%!assert (dblquad (@(x,y) exp(-x.^2 - y.^2) , -1, 1, -1, 1, 1e-6, @quadgk), pi * erf(1).^2, 1e-6)
-%!assert (dblquad (@(x,y) exp(-x.^2 - y.^2) , -1, 1, -1, 1, 1e-6, @quadl), pi * erf(1).^2, 1e-6)
-%!assert (dblquad (@(x,y) exp(-x.^2 - y.^2) , -1, 1, -1, 1, 1e-6, @quadv), pi * erf(1).^2, 1e-6)
+%!assert (dblquad (@(x,y) exp (-x.^2 - y.^2) , -1, 1, -1, 1, 1e-6, @quadgk), pi * erf (1).^2, 1e-6)
+%!assert (dblquad (@(x,y) exp (-x.^2 - y.^2) , -1, 1, -1, 1, 1e-6, @quadl), pi * erf (1).^2, 1e-6)
+%!assert (dblquad (@(x,y) exp (-x.^2 - y.^2) , -1, 1, -1, 1, 1e-6, @quadv), pi * erf (1).^2, 1e-6)
 
diff --git a/scripts/general/deal.m b/scripts/general/deal.m
--- a/scripts/general/deal.m
+++ b/scripts/general/deal.m
@@ -68,16 +68,18 @@ function [varargout] = deal (varargin)
   elseif (nargin == 1 || nargin == nargout)
     varargout(1:nargout) = varargin;
   else
     error ("deal: nargin > 1 and nargin != nargout");
   endif
 
 endfunction
 
+
 %!test
-%! [a,b]=deal(1,2);
-%! assert(a,1);
-%! assert(b,2);
+%! [a,b] = deal (1,2);
+%! assert (a, 1);
+%! assert (b, 2);
 %!test
-%! [a,b]=deal(1);
-%! assert(a,1);
-%! assert(b,1);
+%! [a,b] = deal (1);
+%! assert (a, 1);
+%! assert (b, 1);
+
diff --git a/scripts/general/divergence.m b/scripts/general/divergence.m
--- a/scripts/general/divergence.m
+++ b/scripts/general/divergence.m
@@ -100,13 +100,15 @@ function retval = divergence (varargin)
     ## y-direction
     retval += shiftdim (gradient (shiftdim (varargin{fidx + 1}, 2), dy), 1);
     ## z-direction
     retval += shiftdim (gradient (shiftdim (varargin{fidx + 2}, 1), dz), 2);
   endif
 
 endfunction
 
+
 %!test
-%! [X,Y]=meshgrid(-20:20,-22:22);
-%! div = divergence(X-Y,Y);
-%! assert(all(div(:)==2));
-%! assert(size_equal(X,Y,div));
+%! [X,Y] = meshgrid (-20:20,-22:22);
+%! div = divergence (X-Y,Y);
+%! assert (all (div(:) == 2));
+%! assert (size_equal (X,Y,div));
+
diff --git a/scripts/general/flipdim.m b/scripts/general/flipdim.m
--- a/scripts/general/flipdim.m
+++ b/scripts/general/flipdim.m
@@ -52,16 +52,18 @@ function y = flipdim (x, dim)
   endif
 
   idx(1:max(nd, dim)) = {':'};
   idx{dim} = size (x, dim):-1:1;
   y = x(idx{:});
 
 endfunction
 
-%!error flipdim ();
-%!error flipdim (1, 2, 3);
 
-%!assert (flipdim ([1,2;3,4]), flipdim ([1,2 ; 3,4], 1));
-%!assert (flipdim ([1,2;3,4], 2), [2,1;4,3]);
-%!assert (flipdim ([1,2;3,4], 3), [1,2;3,4]);
+%!assert (flipdim ([1,2;3,4]), flipdim ([1,2 ; 3,4], 1))
+%!assert (flipdim ([1,2;3,4], 2), [2,1;4,3])
+%!assert (flipdim ([1,2;3,4], 3), [1,2;3,4])
 
 ## FIXME -- we need tests for multidimensional arrays.
+
+%!error flipdim ()
+%!error flipdim (1, 2, 3)
+
diff --git a/scripts/general/fliplr.m b/scripts/general/fliplr.m
--- a/scripts/general/fliplr.m
+++ b/scripts/general/fliplr.m
@@ -47,16 +47,16 @@ function y = fliplr (x)
     error ("fliplr: Only works with 2-D arrays");
   endif
 
   nc = columns (x);
   y = x (:, nc:-1:1);
 
 endfunction
 
-%!assert((fliplr ([1, 2; 3, 4]) == [2, 1; 4, 3]
-%! && fliplr ([1, 2; 3, 4; 5, 6]) == [2, 1; 4, 3; 6, 5]
-%! && fliplr ([1, 2, 3; 4, 5, 6]) == [3, 2, 1; 6, 5, 4]));
 
-%!error fliplr();
+%!assert (fliplr ([1, 2; 3, 4]), [2, 1; 4, 3])
+%!assert (fliplr ([1, 2; 3, 4; 5, 6]), [2, 1; 4, 3; 6, 5])
+%!assert (fliplr ([1, 2, 3; 4, 5, 6]), [3, 2, 1; 6, 5, 4])
 
-%!error fliplr (1, 2);
+%!error fliplr()
+%!error fliplr (1, 2)
 
diff --git a/scripts/general/flipud.m b/scripts/general/flipud.m
--- a/scripts/general/flipud.m
+++ b/scripts/general/flipud.m
@@ -47,16 +47,16 @@ function y = flipud (x)
     error ("flipud: Only works with 2-d arrays");
   endif
 
   nr = rows (x);
   y = x (nr:-1:1, :);
 
 endfunction
 
-%!assert((flipud ([1, 2; 3, 4]) == [3, 4; 1, 2]
-%! && flipud ([1, 2; 3, 4; 5, 6]) == [5, 6; 3, 4; 1, 2]
-%! && flipud ([1, 2, 3; 4, 5, 6]) == [4, 5, 6; 1, 2, 3]));
 
-%!error flipud ();
+%!assert (flipud ([1, 2; 3, 4]), [3, 4; 1, 2])
+%!assert (flipud ([1, 2; 3, 4; 5, 6]), [5, 6; 3, 4; 1, 2])
+%!assert (flipud ([1, 2, 3; 4, 5, 6]), [4, 5, 6; 1, 2, 3])
 
-%!error flipud (1, 2);
+%!error flipud ()
+%!error flipud (1, 2)
 
diff --git a/scripts/general/genvarname.m b/scripts/general/genvarname.m
--- a/scripts/general/genvarname.m
+++ b/scripts/general/genvarname.m
@@ -167,42 +167,43 @@ function varname = genvarname (str, excl
   endfor
 
   if strinput
     varname = varname{1};
   endif
 
 endfunction
 
-## Tests
+
 ## a single argument
-%!assert(genvarname("a"), "a")
+%!assert (genvarname ("a"), "a")
 ## a single argument with a non-conflicting exception
-%!assert(genvarname("a", "b"), "a")
+%!assert (genvarname ("a", "b"), "a")
 ## a single argument with a conflicting exception
-%!assert(genvarname("a", "a"), "a1")
+%!assert (genvarname ("a", "a"), "a1")
 ## a single argument as a cell
-%!assert(genvarname({"a"}), {"a"})
-%!assert(genvarname({"a"}, "b"), {"a"})
-%!assert(genvarname({"a"}, {"b"}), {"a"})
-%!assert(genvarname({"a"}, "a"), {"a1"})
-%!assert(genvarname({"a"}, {"a"}), {"a1"})
+%!assert (genvarname ({"a"}), {"a"})
+%!assert (genvarname ({"a"}, "b"), {"a"})
+%!assert (genvarname ({"a"}, {"b"}), {"a"})
+%!assert (genvarname ({"a"}, "a"), {"a1"})
+%!assert (genvarname ({"a"}, {"a"}), {"a1"})
 ## Test different arguments
 ## orientation
-%!assert(genvarname({"a" "b"}), {"a" "b"})
-%!assert(genvarname({"a";"b"}), {"a";"b"})
-%!assert(genvarname({"a" "a"}), {"a" "a1"})
-%!assert(genvarname({"a" "b";"c" "d"}), {"a" "b";"c" "d"})
-%!assert(genvarname({"a" "a" "a";"a" "a" "a"}), {"a" "a2" "a4";"a1" "a3" "a5"})
+%!assert (genvarname ({"a" "b"}), {"a" "b"})
+%!assert (genvarname ({"a";"b"}), {"a";"b"})
+%!assert (genvarname ({"a" "a"}), {"a" "a1"})
+%!assert (genvarname ({"a" "b";"c" "d"}), {"a" "b";"c" "d"})
+%!assert (genvarname ({"a" "a" "a";"a" "a" "a"}), {"a" "a2" "a4";"a1" "a3" "a5"})
 ## more than one repetition
-%!assert(genvarname({"a" "a" "a"}), {"a" "a1" "a2"})
-%!assert(genvarname({"a" "a" "a"}, {"a" "a1" "a2"}), {"a3" "a4" "a5"})
+%!assert (genvarname ({"a" "a" "a"}), {"a" "a1" "a2"})
+%!assert (genvarname ({"a" "a" "a"}, {"a" "a1" "a2"}), {"a3" "a4" "a5"})
 ## more than one repetition not in order
-%!assert(genvarname({"a" "b" "a" "b" "a"}), {"a" "b" "a1" "b1" "a2"})
+%!assert (genvarname ({"a" "b" "a" "b" "a"}), {"a" "b" "a1" "b1" "a2"})
 ## Variable name munging
 %!assert (genvarname ("__x__"), "_x_")
 %!assert (genvarname ("123456789"), "_123456789")
 %!assert (genvarname ("_$1__"), "_1_")
 %!assert (genvarname ("__foo__", "_foo_"), "_foo_1")
 %!assert (genvarname ("1million_and1", "_1million_and1"), "_1million_and1_1")
 %!assert (genvarname ({"", "", ""}), {"x", "x1", "x2"})
 %!assert (genvarname ("if"), "_if")
 %!assert (genvarname ({"if", "if", "if"}), {"_if", "_if1", "_if2"})
+
diff --git a/scripts/general/gradient.m b/scripts/general/gradient.m
--- a/scripts/general/gradient.m
+++ b/scripts/general/gradient.m
@@ -215,81 +215,82 @@ function varargout = handle_gradient (f,
     if (dim == 1)
       varargout{d} = reshape (df_dx, p0_size);
     else
       varargout{d} = df_dx;
     endif
   endfor
 endfunction
 
+
 %!test
 %! data = [1, 2, 4, 2];
 %! dx = gradient (data);
 %! dx2 = gradient (data, 0.25);
 %! dx3 = gradient (data, [0.25, 0.5, 1, 3]);
 %! assert (dx, [1, 3/2, 0, -2]);
 %! assert (dx2, [4, 6, 0, -8]);
 %! assert (dx3, [4, 4, 0, -1]);
-%! assert (size_equal(data, dx));
+%! assert (size_equal (data, dx));
 
 %!test
 %! [Y,X,Z,U] = ndgrid (2:2:8,1:5,4:4:12,3:5:30);
 %! [dX,dY,dZ,dU] = gradient (X);
-%! assert (all(dX(:)==1));
-%! assert (all(dY(:)==0));
-%! assert (all(dZ(:)==0));
-%! assert (all(dU(:)==0));
+%! assert (all (dX(:) == 1));
+%! assert (all (dY(:) == 0));
+%! assert (all (dZ(:) == 0));
+%! assert (all (dU(:) == 0));
 %! [dX,dY,dZ,dU] = gradient (Y);
-%! assert (all(dX(:)==0));
-%! assert (all(dY(:)==2));
-%! assert (all(dZ(:)==0));
-%! assert (all(dU(:)==0));
+%! assert (all (dX(:) == 0));
+%! assert (all (dY(:) == 2));
+%! assert (all (dZ(:) == 0));
+%! assert (all (dU(:) == 0));
 %! [dX,dY,dZ,dU] = gradient (Z);
-%! assert (all(dX(:)==0));
-%! assert (all(dY(:)==0));
-%! assert (all(dZ(:)==4));
-%! assert (all(dU(:)==0));
+%! assert (all (dX(:) == 0));
+%! assert (all (dY(:) == 0));
+%! assert (all (dZ(:) == 4));
+%! assert (all (dU(:) == 0));
 %! [dX,dY,dZ,dU] = gradient (U);
-%! assert (all(dX(:)==0));
-%! assert (all(dY(:)==0));
-%! assert (all(dZ(:)==0));
-%! assert (all(dU(:)==5));
-%! assert (size_equal(dX, dY, dZ, dU, X, Y, Z, U));
+%! assert (all (dX(:) == 0));
+%! assert (all (dY(:) == 0));
+%! assert (all (dZ(:) == 0));
+%! assert (all (dU(:) == 5));
+%! assert (size_equal (dX, dY, dZ, dU, X, Y, Z, U));
 %! [dX,dY,dZ,dU] = gradient (U, 5.0);
-%! assert (all(dU(:)==1));
+%! assert (all (dU(:) == 1));
 %! [dX,dY,dZ,dU] = gradient (U, 1.0, 2.0, 3.0, 2.5);
-%! assert (all(dU(:)==2));
+%! assert (all (dU(:) == 2));
 
 %!test
 %! [Y,X,Z,U] = ndgrid (2:2:8,1:5,4:4:12,3:5:30);
 %! [dX,dY,dZ,dU] = gradient (X+j*X);
-%! assert (all(dX(:)==1+1j));
-%! assert (all(dY(:)==0));
-%! assert (all(dZ(:)==0));
-%! assert (all(dU(:)==0));
+%! assert (all (dX(:) == 1+1j));
+%! assert (all (dY(:) == 0));
+%! assert (all (dZ(:) == 0));
+%! assert (all (dU(:) == 0));
 %! [dX,dY,dZ,dU] = gradient (Y-j*Y);
-%! assert (all(dX(:)==0));
-%! assert (all(dY(:)==2-j*2));
-%! assert (all(dZ(:)==0));
-%! assert (all(dU(:)==0));
+%! assert (all (dX(:) == 0));
+%! assert (all (dY(:) == 2-j*2));
+%! assert (all (dZ(:) == 0));
+%! assert (all (dU(:) == 0));
 %! [dX,dY,dZ,dU] = gradient (Z+j*1);
-%! assert (all(dX(:)==0));
-%! assert (all(dY(:)==0));
-%! assert (all(dZ(:)==4));
-%! assert (all(dU(:)==0));
+%! assert (all (dX(:) == 0));
+%! assert (all (dY(:) == 0));
+%! assert (all (dZ(:) == 4));
+%! assert (all (dU(:) == 0));
 %! [dX,dY,dZ,dU] = gradient (U-j*1);
-%! assert (all(dX(:)==0));
-%! assert (all(dY(:)==0));
-%! assert (all(dZ(:)==0));
-%! assert (all(dU(:)==5));
+%! assert (all (dX(:) == 0));
+%! assert (all (dY(:) == 0));
+%! assert (all (dZ(:) == 0));
+%! assert (all (dU(:) == 5));
 %! assert (size_equal(dX, dY, dZ, dU, X, Y, Z, U));
 %! [dX,dY,dZ,dU] = gradient (U, 5.0);
-%! assert (all(dU(:)==1));
+%! assert (all (dU(:) == 1));
 %! [dX,dY,dZ,dU] = gradient (U, 1.0, 2.0, 3.0, 2.5);
-%! assert (all(dU(:)==2));
+%! assert (all (dU(:) == 2));
 
 %!test
 %! x = 0:10;
 %! f = @cos;
 %! df_dx = @(x) -sin (x);
 %! assert (gradient (f, x), df_dx (x), 0.2);
 %! assert (gradient (f, x, 0.5), df_dx (x), 0.1);
 
diff --git a/scripts/general/idivide.m b/scripts/general/idivide.m
--- a/scripts/general/idivide.m
+++ b/scripts/general/idivide.m
@@ -95,30 +95,32 @@ function z = idivide (x, y, op)
     elseif (strcmp (op, "ceil"))
       z = cast (ceil (double (x) ./ double (y)), typ);
     else
       error ("idivide: unrecognized rounding type");
     endif
   endif
 endfunction
 
+
 %!shared a, af, b, bf
-%! a = int8(3);
+%! a = int8 (3);
 %! af = 3;
-%! b = int8([-4, 4]);
+%! b = int8 ([-4, 4]);
 %! bf = [-4, 4];
 
 %!assert (idivide (a, b), int8 ([0, 0]))
-%!assert (idivide (a, b, "floor"), int8([-1, 0]))
+%!assert (idivide (a, b, "floor"), int8 ([-1, 0]))
 %!assert (idivide (a, b, "ceil"), int8 ([0, 1]))
 %!assert (idivide (a, b, "round"), int8 ([-1, 1]))
 
 %!assert (idivide (af, b), int8 ([0, 0]))
-%!assert (idivide (af, b, "floor"), int8([-1, 0]))
+%!assert (idivide (af, b, "floor"), int8 ([-1, 0]))
 %!assert (idivide (af, b, "ceil"), int8 ([0, 1]))
 %!assert (idivide (af, b, "round"), int8 ([-1, 1]))
 
 %!assert (idivide (a, bf), int8 ([0, 0]))
-%!assert (idivide (a, bf, "floor"), int8([-1, 0]))
+%!assert (idivide (a, bf, "floor"), int8 ([-1, 0]))
 %!assert (idivide (a, bf, "ceil"), int8 ([0, 1]))
 %!assert (idivide (a, bf, "round"), int8 ([-1, 1]))
 
-%!error (idivide (uint8(1), int8(1)))
+%!error (idivide (uint8 (1), int8 (1)))
+
diff --git a/scripts/general/int2str.m b/scripts/general/int2str.m
--- a/scripts/general/int2str.m
+++ b/scripts/general/int2str.m
@@ -108,15 +108,17 @@ function fmt = get_fmt (x, sep)
         fw++;
       endif
       fmt = sprintf ("%%%dd", max (fw, min_fw));
     endif
   endif
 
 endfunction
 
-%!assert (strcmp (int2str (-123), "-123") && strcmp (int2str (1.2), "1"));
-%!assert (all (int2str ([1, 2, 3; 4, 5, 6]) == ["1  2  3";"4  5  6"]));
-%!assert (int2str([]), "");
 
-%!error int2str ();
-%!error int2str (1, 2);
+%!assert (int2str (-123), "-123")
+%!assert (int2str (1.2), "1")
+%!assert (int2str ([1, 2, 3; 4, 5, 6]), ["1  2  3";"4  5  6"])
+%!assert (int2str ([]), "")
 
+%!error int2str ()
+%!error int2str (1, 2)
+
diff --git a/scripts/general/interp1.m b/scripts/general/interp1.m
--- a/scripts/general/interp1.m
+++ b/scripts/general/interp1.m
@@ -296,31 +296,31 @@ function yi = interp1 (x, y, varargin)
     yi.orient = "first";
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
-%! xf = 0:0.05:10; yf = sin (2*pi*xf/5);
-%! xp = 0:10;      yp = sin (2*pi*xp/5);
+%! xf = 0:0.05:10;  yf = sin (2*pi*xf/5);
+%! xp = 0:10;       yp = sin (2*pi*xp/5);
 %! lin = interp1 (xp,yp,xf, "linear");
 %! spl = interp1 (xp,yp,xf, "spline");
 %! cub = interp1 (xp,yp,xf, "pchip");
 %! near= interp1 (xp,yp,xf, "nearest");
 %! plot (xf,yf,"r",xf,near,"g",xf,lin,"b",xf,cub,"c",xf,spl,"m",xp,yp,"r*");
 %! legend ("original", "nearest", "linear", "pchip", "spline");
 %! %--------------------------------------------------------
 %! % confirm that interpolated function matches the original
 
 %!demo
 %! clf;
-%! xf = 0:0.05:10; yf = sin (2*pi*xf/5);
-%! xp = 0:10;      yp = sin (2*pi*xp/5);
+%! xf = 0:0.05:10;  yf = sin (2*pi*xf/5);
+%! xp = 0:10;       yp = sin (2*pi*xp/5);
 %! lin = interp1 (xp,yp,xf, "*linear");
 %! spl = interp1 (xp,yp,xf, "*spline");
 %! cub = interp1 (xp,yp,xf, "*cubic");
 %! near= interp1 (xp,yp,xf, "*nearest");
 %! plot (xf,yf,"r",xf,near,"g",xf,lin,"b",xf,cub,"c",xf,spl,"m",xp,yp,"r*");
 %! legend ("*original", "*nearest", "*linear", "*cubic", "*spline");
 %! %--------------------------------------------------------
 %! % confirm that interpolated function matches the original
@@ -335,18 +335,18 @@ endfunction
 %! ddys = diff (diff (interp1 (t,y,ti, "spline"))./dti)./dti;
 %! ddyp = diff (diff (interp1 (t,y,ti, "pchip")) ./dti)./dti;
 %! plot (ti(2:end-1),ddyc,'g+', ti(2:end-1),ddys,'b*', ti(2:end-1),ddyp,'c^');
 %! legend ("cubic", "spline", "pchip");
 %! title ("Second derivative of interpolated 'sin (4*t + 0.3) .* cos (3*t - 0.1)'");
 
 %!demo
 %! clf;
-%! xf = 0:0.05:10;               yf = sin (2*pi*xf/5) - (xf >= 5);
-%! xp = [0:.5:4.5,4.99,5:.5:10]; yp = sin (2*pi*xp/5) - (xp >= 5);
+%! xf = 0:0.05:10;                yf = sin (2*pi*xf/5) - (xf >= 5);
+%! xp = [0:.5:4.5,4.99,5:.5:10];  yp = sin (2*pi*xp/5) - (xp >= 5);
 %! lin = interp1 (xp,yp,xf, "linear");
 %! near= interp1 (xp,yp,xf, "nearest");
 %! plot (xf,yf,"r", xf,near,"g", xf,lin,"b", xp,yp,"r*");
 %! legend ("original", "nearest", "linear");
 %! %--------------------------------------------------------
 %! % confirm that interpolated function matches the original
 
 ##FIXME: add test for n-d arguments here
@@ -367,209 +367,210 @@ endfunction
 ## the tests are identical.
 ## Note that the block checks style and *style; if you add more tests
 ## be sure to add them to both sections of each block.  One test,
 ## style vs. *style, occurs only in the first section.
 ## There is an ENDBLOCKTEST after the final block
 
 %!test style = "nearest";
 ## BLOCK
-%!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
-%!assert (interp1(xp,yp,xp,style), yp, 100*eps);
-%!assert (interp1(xp,yp,xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp,style), yp, 100*eps);
-%!assert (isempty(interp1(xp',yp',[],style)));
-%!assert (isempty(interp1(xp,yp,[],style)));
-%!assert (interp1(xp,[yp',yp'],xi(:),style),...
-%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
-%!assert (interp1(xp,yp,xi,style),...
-%!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
-%!assert (ppval(interp1(xp,yp,style,"pp"),xi),
-%!        interp1(xp,yp,xi,style,"extrap"),10*eps);
-%!error interp1(1,1,1, style);
-%!assert (interp1(xp,[yp',yp'],xi,style),
-%!        interp1(xp,[yp',yp'],xi,["*",style]),100*eps);
-%!test style=['*',style];
-%!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
-%!assert (interp1(xp,yp,xp,style), yp, 100*eps);
-%!assert (interp1(xp,yp,xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp,style), yp, 100*eps);
-%!assert (isempty(interp1(xp',yp',[],style)));
-%!assert (isempty(interp1(xp,yp,[],style)));
-%!assert (interp1(xp,[yp',yp'],xi(:),style),...
-%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
-%!assert (interp1(xp,yp,xi,style),...
-%!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
-%!assert (ppval(interp1(xp,yp,style,"pp"),xi),
-%!        interp1(xp,yp,xi,style,"extrap"),10*eps);
-%!error interp1(1,1,1, style);
+%!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
+%!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
+%!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
+%!assert (isempty (interp1 (xp',yp',[],style)))
+%!assert (isempty (interp1 (xp,yp,[],style)))
+%!assert (interp1 (xp,[yp',yp'],xi(:),style),...
+%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
+%!assert (interp1 (xp,yp,xi,style),...
+%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
+%!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
+%!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
+%!error interp1 (1,1,1, style)
+%!assert (interp1 (xp,[yp',yp'],xi,style),
+%!        interp1 (xp,[yp',yp'],xi,["*",style]),100*eps)
+%!test style = ["*",style];
+%!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
+%!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
+%!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
+%!assert (isempty (interp1 (xp',yp',[],style)))
+%!assert (isempty (interp1 (xp,yp,[],style)))
+%!assert (interp1 (xp,[yp',yp'],xi(:),style),...
+%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
+%!assert (interp1 (xp,yp,xi,style),...
+%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
+%!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
+%!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
+%!error interp1 (1,1,1, style)
 ## ENDBLOCK
 
-%!test style='linear';
+%!test style = "linear";
 ## BLOCK
-%!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
-%!assert (interp1(xp,yp,xp,style), yp, 100*eps);
-%!assert (interp1(xp,yp,xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp,style), yp, 100*eps);
-%!assert (isempty(interp1(xp',yp',[],style)));
-%!assert (isempty(interp1(xp,yp,[],style)));
-%!assert (interp1(xp,[yp',yp'],xi(:),style),...
-%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
-%!assert (interp1(xp,yp,xi,style),...
-%!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
-%!assert (ppval(interp1(xp,yp,style,"pp"),xi),
-%!        interp1(xp,yp,xi,style,"extrap"),10*eps);
-%!error interp1(1,1,1, style);
-%!assert (interp1(xp,[yp',yp'],xi,style),
-%!        interp1(xp,[yp',yp'],xi,["*",style]),100*eps);
-%!test style=['*',style];
-%!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
-%!assert (interp1(xp,yp,xp,style), yp, 100*eps);
-%!assert (interp1(xp,yp,xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp,style), yp, 100*eps);
-%!assert (isempty(interp1(xp',yp',[],style)));
-%!assert (isempty(interp1(xp,yp,[],style)));
-%!assert (interp1(xp,[yp',yp'],xi(:),style),...
-%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
-%!assert (interp1(xp,yp,xi,style),...
-%!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
-%!assert (ppval(interp1(xp,yp,style,"pp"),xi),
-%!        interp1(xp,yp,xi,style,"extrap"),10*eps);
-%!error interp1(1,1,1, style);
+%!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
+%!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
+%!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
+%!assert (isempty (interp1 (xp',yp',[],style)))
+%!assert (isempty (interp1 (xp,yp,[],style)))
+%!assert (interp1 (xp,[yp',yp'],xi(:),style),...
+%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
+%!assert (interp1 (xp,yp,xi,style),...
+%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
+%!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
+%!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
+%!error interp1 (1,1,1, style)
+%!assert (interp1 (xp,[yp',yp'],xi,style),
+%!        interp1 (xp,[yp',yp'],xi,["*",style]),100*eps)
+%!test style = ['*',style];
+%!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
+%!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
+%!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
+%!assert (isempty (interp1 (xp',yp',[],style)))
+%!assert (isempty (interp1 (xp,yp,[],style)))
+%!assert (interp1 (xp,[yp',yp'],xi(:),style),...
+%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
+%!assert (interp1 (xp,yp,xi,style),...
+%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
+%!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
+%!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
+%!error interp1 (1,1,1, style)
 ## ENDBLOCK
 
-%!test style='cubic';
+%!test style = "cubic";
 ## BLOCK
-%!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
-%!assert (interp1(xp,yp,xp,style), yp, 100*eps);
-%!assert (interp1(xp,yp,xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp,style), yp, 100*eps);
-%!assert (isempty(interp1(xp',yp',[],style)));
-%!assert (isempty(interp1(xp,yp,[],style)));
-%!assert (interp1(xp,[yp',yp'],xi(:),style),...
-%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
-%!assert (interp1(xp,yp,xi,style),...
-%!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
-%!assert (ppval(interp1(xp,yp,style,"pp"),xi),
-%!        interp1(xp,yp,xi,style,"extrap"),100*eps);
-%!error interp1(1,1,1, style);
-%!assert (interp1(xp,[yp',yp'],xi,style),
-%!        interp1(xp,[yp',yp'],xi,["*",style]),100*eps);
-%!test style=['*',style];
-%!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
-%!assert (interp1(xp,yp,xp,style), yp, 100*eps);
-%!assert (interp1(xp,yp,xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp,style), yp, 100*eps);
-%!assert (isempty(interp1(xp',yp',[],style)));
-%!assert (isempty(interp1(xp,yp,[],style)));
-%!assert (interp1(xp,[yp',yp'],xi(:),style),...
-%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
-%!assert (interp1(xp,yp,xi,style),...
-%!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
-%!assert (ppval(interp1(xp,yp,style,"pp"),xi),
-%!        interp1(xp,yp,xi,style,"extrap"),100*eps);
-%!error interp1(1,1,1, style);
+%!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
+%!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
+%!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
+%!assert (isempty (interp1 (xp',yp',[],style)))
+%!assert (isempty (interp1 (xp,yp,[],style)))
+%!assert (interp1 (xp,[yp',yp'],xi(:),style),...
+%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
+%!assert (interp1 (xp,yp,xi,style),...
+%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
+%!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
+%!        interp1 (xp,yp,xi,style,"extrap"),100*eps)
+%!error interp1 (1,1,1, style)
+%!assert (interp1 (xp,[yp',yp'],xi,style),
+%!        interp1 (xp,[yp',yp'],xi,["*",style]),100*eps)
+%!test style = ["*",style];
+%!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
+%!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
+%!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
+%!assert (isempty (interp1 (xp',yp',[],style)))
+%!assert (isempty (interp1 (xp,yp,[],style)))
+%!assert (interp1 (xp,[yp',yp'],xi(:),style),...
+%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
+%!assert (interp1 (xp,yp,xi,style),...
+%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
+%!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
+%!        interp1 (xp,yp,xi,style,"extrap"),100*eps)
+%!error interp1 (1,1,1, style)
 ## ENDBLOCK
 
-%!test style='pchip';
+%!test style = "pchip";
 ## BLOCK
-%!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
-%!assert (interp1(xp,yp,xp,style), yp, 100*eps);
-%!assert (interp1(xp,yp,xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp,style), yp, 100*eps);
-%!assert (isempty(interp1(xp',yp',[],style)));
-%!assert (isempty(interp1(xp,yp,[],style)));
-%!assert (interp1(xp,[yp',yp'],xi(:),style),...
-%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
-%!assert (interp1(xp,yp,xi,style),...
-%!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
-%!assert (ppval(interp1(xp,yp,style,"pp"),xi),
-%!        interp1(xp,yp,xi,style,"extrap"),10*eps);
-%!error interp1(1,1,1, style);
-%!assert (interp1(xp,[yp',yp'],xi,style),
-%!        interp1(xp,[yp',yp'],xi,["*",style]),100*eps);
-%!test style=['*',style];
-%!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
-%!assert (interp1(xp,yp,xp,style), yp, 100*eps);
-%!assert (interp1(xp,yp,xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp,style), yp, 100*eps);
-%!assert (isempty(interp1(xp',yp',[],style)));
-%!assert (isempty(interp1(xp,yp,[],style)));
-%!assert (interp1(xp,[yp',yp'],xi(:),style),...
-%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
-%!assert (interp1(xp,yp,xi,style),...
-%!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
-%!assert (ppval(interp1(xp,yp,style,"pp"),xi),
-%!        interp1(xp,yp,xi,style,"extrap"),10*eps);
-%!error interp1(1,1,1, style);
+%!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
+%!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
+%!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
+%!assert (isempty (interp1 (xp',yp',[],style)))
+%!assert (isempty (interp1 (xp,yp,[],style)))
+%!assert (interp1 (xp,[yp',yp'],xi(:),style),...
+%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
+%!assert (interp1 (xp,yp,xi,style),...
+%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
+%!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
+%!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
+%!error interp1 (1,1,1, style)
+%!assert (interp1 (xp,[yp',yp'],xi,style),
+%!        interp1 (xp,[yp',yp'],xi,["*",style]),100*eps)
+%!test style = ["*",style];
+%!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
+%!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
+%!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
+%!assert (isempty (interp1 (xp',yp',[],style)))
+%!assert (isempty (interp1 (xp,yp,[],style)))
+%!assert (interp1 (xp,[yp',yp'],xi(:),style),...
+%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
+%!assert (interp1 (xp,yp,xi,style),...
+%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
+%!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
+%!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
+%!error interp1 (1,1,1, style)
 ## ENDBLOCK
 
-%!test style='spline';
+%!test style = "spline";
 ## BLOCK
-%!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
-%!assert (interp1(xp,yp,xp,style), yp, 100*eps);
-%!assert (interp1(xp,yp,xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp,style), yp, 100*eps);
-%!assert (isempty(interp1(xp',yp',[],style)));
-%!assert (isempty(interp1(xp,yp,[],style)));
-%!assert (interp1(xp,[yp',yp'],xi(:),style),...
-%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
-%!assert (interp1(xp,yp,xi,style),...
-%!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
-%!assert (ppval(interp1(xp,yp,style,"pp"),xi),
-%!        interp1(xp,yp,xi,style,"extrap"),10*eps);
-%!error interp1(1,1,1, style);
-%!assert (interp1(xp,[yp',yp'],xi,style),
-%!        interp1(xp,[yp',yp'],xi,["*",style]),100*eps);
-%!test style=['*',style];
-%!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
-%!assert (interp1(xp,yp,xp,style), yp, 100*eps);
-%!assert (interp1(xp,yp,xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp',style), yp', 100*eps);
-%!assert (interp1(xp',yp',xp,style), yp, 100*eps);
-%!assert (isempty(interp1(xp',yp',[],style)));
-%!assert (isempty(interp1(xp,yp,[],style)));
-%!assert (interp1(xp,[yp',yp'],xi(:),style),...
-%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
-%!assert (interp1(xp,yp,xi,style),...
-%!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
-%!assert (ppval(interp1(xp,yp,style,"pp"),xi),
-%!        interp1(xp,yp,xi,style,"extrap"),10*eps);
-%!error interp1(1,1,1, style);
+%!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
+%!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
+%!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
+%!assert (isempty (interp1 (xp',yp',[],style)))
+%!assert (isempty (interp1 (xp,yp,[],style)))
+%!assert (interp1 (xp,[yp',yp'],xi(:),style),...
+%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
+%!assert (interp1 (xp,yp,xi,style),...
+%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
+%!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
+%!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
+%!error interp1 (1,1,1, style)
+%!assert (interp1 (xp,[yp',yp'],xi,style),
+%!        interp1 (xp,[yp',yp'],xi,["*",style]),100*eps)
+%!test style = ["*",style];
+%!assert (interp1 (xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA])
+%!assert (interp1 (xp,yp,xp,style), yp, 100*eps)
+%!assert (interp1 (xp,yp,xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp',style), yp', 100*eps)
+%!assert (interp1 (xp',yp',xp,style), yp, 100*eps)
+%!assert (isempty (interp1 (xp',yp',[],style)))
+%!assert (isempty (interp1 (xp,yp,[],style)))
+%!assert (interp1 (xp,[yp',yp'],xi(:),style),...
+%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)])
+%!assert (interp1 (xp,yp,xi,style),...
+%!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
+%!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
+%!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
+%!error interp1 (1,1,1, style)
 ## ENDBLOCK
 ## ENDBLOCKTEST
 
 %!# test linear extrapolation
-%!assert (interp1([1:5],[3:2:11],[0,6],"linear","extrap"), [1, 13], eps);
-%!assert (interp1(xp, yp, [-1, max(xp)+1],"linear",5), [5, 5]);
-
-%!error interp1
-%!error interp1(1:2,1:2,1,"bogus")
+%!assert (interp1 ([1:5],[3:2:11],[0,6],"linear","extrap"), [1, 13], eps)
+%!assert (interp1 (xp, yp, [-1, max(xp)+1],"linear",5), [5, 5])
 
-%!assert (interp1(1:2,1:2,1.4,"nearest"),1);
-%!error interp1(1,1,1, "linear");
-%!assert (interp1(1:2,1:2,1.4,"linear"),1.4);
-%!assert (interp1(1:4,1:4,1.4,"cubic"),1.4);
-%!assert (interp1(1:2,1:2,1.1, "spline"), 1.1);
-%!assert (interp1(1:3,1:3,1.4,"spline"),1.4);
+%!assert (interp1 (1:2,1:2,1.4,"nearest"), 1)
+%!assert (interp1 (1:2,1:2,1.4,"linear"), 1.4)
+%!assert (interp1 (1:4,1:4,1.4,"cubic"), 1.4)
+%!assert (interp1 (1:2,1:2,1.1, "spline"), 1.1)
+%!assert (interp1 (1:3,1:3,1.4,"spline"), 1.4)
 
-%!error interp1(1,1,1, "*nearest");
-%!assert (interp1(1:2:4,1:2:4,1.4,"*nearest"),1);
-%!error interp1(1,1,1, "*linear");
-%!assert (interp1(1:2:4,1:2:4,[0,1,1.4,3,4],"*linear"),[NA,1,1.4,3,NA]);
-%!assert (interp1(1:2:8,1:2:8,1.4,"*cubic"),1.4);
-%!assert (interp1(1:2,1:2,1.3, "*spline"), 1.3);
-%!assert (interp1(1:2:6,1:2:6,1.4,"*spline"),1.4);
+%!assert (interp1 (1:2:4,1:2:4,1.4,"*nearest"), 1)
+%!assert (interp1 (1:2:4,1:2:4,[0,1,1.4,3,4],"*linear"), [NA,1,1.4,3,NA])
+%!assert (interp1 (1:2:8,1:2:8,1.4,"*cubic"), 1.4)
+%!assert (interp1 (1:2,1:2,1.3, "*spline"), 1.3)
+%!assert (interp1 (1:2:6,1:2:6,1.4,"*spline"), 1.4)
 
-%!assert (interp1([3,2,1],[3,2,2],2.5),2.5)
+%!assert (interp1 ([3,2,1],[3,2,2],2.5), 2.5)
 
 %!assert (interp1 ([1,2,2,3,4],[0,1,4,2,1],[-1,1.5,2,2.5,3.5], "linear", "extrap"), [-2,0.5,4,3,1.5])
 %!assert (interp1 ([4,4,3,2,0],[0,1,4,2,1],[1.5,4,4.5], "linear"), [1.75,1,NA])
 %!assert (interp1 (0:4, 2.5), 1.5)
+
+%!error interp1 ()
+%!error interp1 (1,1,1, "linear")
+%!error interp1 (1,1,1, "*nearest")
+%!error interp1 (1,1,1, "*linear")
+%!error interp1 (1:2,1:2,1, "bogus")
+
diff --git a/scripts/general/interp1q.m b/scripts/general/interp1q.m
--- a/scripts/general/interp1q.m
+++ b/scripts/general/interp1q.m
@@ -52,19 +52,21 @@ function yi = interp1q (x, y, xi)
   yi(range,:) = NA;
   if (length (szx) == 2 && any (szx == 1))
     yi = reshape (yi, [max(szx), szy(2:end)]);
   else
     yi = reshape (yi, [szx, szy(2:end)]);
   endif
 endfunction
 
+
 %!shared xp, yp, xi, yi
-%! xp=[0:2:10].';      yp = sin(2*pi*xp/5);
+%! xp = [0:2:10].';   yp = sin(2*pi*xp/5);
 %! xi = [-1; 0; 2.2; 4; 6.6; 10; 11];
 %! yi = interp1 (xp,yp,xi);
-%!assert (interp1q(xp, yp, [min(xp)-1; max(xp)+1]), [NA; NA]);
-%!assert (interp1q(xp,yp,xp), yp, 100*eps);
-%!assert (isempty(interp1q(xp,yp,[])));
-%!assert (interp1q(xp,yp,xi), yi);
-%!assert (interp1q(xp,[yp,yp],xi), [yi, yi]);
-%!assert (interp1q(xp,yp,[xi,xi]), [yi, yi]);
-%!assert (interp1q(xp,[yp,yp],[xi,xi]), cat (3, [yi, yi], [yi, yi]));
+%!assert (interp1q (xp,yp, [min(xp)-1; max(xp)+1]), [NA; NA]);
+%!assert (interp1q (xp,yp,xp), yp, 100*eps);
+%!assert (isempty (interp1q (xp,yp,[])));
+%!assert (interp1q (xp,yp,xi), yi);
+%!assert (interp1q (xp,[yp,yp],xi), [yi, yi]);
+%!assert (interp1q (xp,yp,[xi,xi]), [yi, yi]);
+%!assert (interp1q (xp,[yp,yp],[xi,xi]), cat (3, [yi, yi], [yi, yi]));
+
diff --git a/scripts/general/interp2.m b/scripts/general/interp2.m
--- a/scripts/general/interp2.m
+++ b/scripts/general/interp2.m
@@ -444,187 +444,188 @@ function ind = sym_sub2ind(sz, Y, X)
   ind = sub2ind(sz, Y, X);
 endfunction
 
 
 %!demo
 %! clf;
 %! colormap ("default");
 %! A = [13,-1,12;5,4,3;1,6,2];
-%! x = [0,1,4]; y = [10,11,12];
-%! xi = linspace (min(x), max(x), 17);
-%! yi = linspace (min(y), max(y), 26)';
+%! x = [0,1,4];  y = [10,11,12];
+%! xi = linspace (min (x), max (x), 17);
+%! yi = linspace (min (y), max (y), 26)';
 %! mesh (xi,yi,interp2 (x,y,A,xi,yi, "linear"));
 %! [x,y] = meshgrid (x,y);
 %! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
 %! clf;
 %! colormap ("default");
 %! [x,y,A] = peaks (10);
-%! x = x(1,:)'; y = y(:,1);
-%! xi = linspace (min(x), max(x), 41);
-%! yi = linspace (min(y), max(y), 41)';
+%! x = x(1,:)';  y = y(:,1);
+%! xi = linspace (min (x), max (x), 41);
+%! yi = linspace (min (y), max (y), 41)';
 %! mesh (xi,yi,interp2 (x,y,A,xi,yi, "linear"));
 %! [x,y] = meshgrid (x,y);
 %! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
 %! clf;
 %! colormap ("default");
 %! A = [13,-1,12;5,4,3;1,6,2];
-%! x = [0,1,4]; y = [10,11,12];
-%! xi = linspace (min(x), max(x), 17);
-%! yi = linspace (min(y), max(y), 26)';
+%! x = [0,1,4];  y = [10,11,12];
+%! xi = linspace (min (x), max (x), 17);
+%! yi = linspace (min (y), max (y), 26)';
 %! mesh (xi,yi,interp2 (x,y,A,xi,yi, "nearest"));
 %! [x,y] = meshgrid (x,y);
 %! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
 %! clf;
 %! colormap ("default");
 %! [x,y,A] = peaks (10);
-%! x = x(1,:)'; y = y(:,1);
-%! xi = linspace (min(x), max(x), 41);
-%! yi = linspace (min(y), max(y), 41)';
+%! x = x(1,:)';  y = y(:,1);
+%! xi = linspace (min (x), max (x), 41);
+%! yi = linspace (min (y), max (y), 41)';
 %! mesh (xi,yi,interp2 (x,y,A,xi,yi, "nearest"));
 %! [x,y] = meshgrid (x,y);
 %! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
 %! clf;
 %! colormap ("default");
 %! A = [13,-1,12;5,4,3;1,6,2];
-%! x = [0,1,2]; y = [10,11,12];
-%! xi = linspace (min(x), max(x), 17);
-%! yi = linspace (min(y), max(y), 26)';
+%! x = [0,1,2];  y = [10,11,12];
+%! xi = linspace (min (x), max (x), 17);
+%! yi = linspace (min (y), max (y), 26)';
 %! mesh (xi,yi,interp2 (x,y,A,xi,yi, "pchip"));
 %! [x,y] = meshgrid (x,y);
 %! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
 %! clf;
 %! colormap ("default");
 %! [x,y,A] = peaks (10);
-%! x = x(1,:)'; y = y(:,1);
-%! xi = linspace (min(x), max(x), 41);
-%! yi = linspace (min(y), max(y), 41)';
+%! x = x(1,:)';  y = y(:,1);
+%! xi = linspace (min (x), max (x), 41);
+%! yi = linspace (min (y), max (y), 41)';
 %! mesh (xi,yi,interp2 (x,y,A,xi,yi, "pchip"));
 %! [x,y] = meshgrid (x,y);
 %! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
 %! clf;
 %! colormap ("default");
 %! A = [13,-1,12;5,4,3;1,6,2];
-%! x = [0,1,2]; y = [10,11,12];
-%! xi = linspace (min(x), max(x), 17);
-%! yi = linspace (min(y), max(y), 26)';
+%! x = [0,1,2];  y = [10,11,12];
+%! xi = linspace (min (x), max (x), 17);
+%! yi = linspace (min (y), max (y), 26)';
 %! mesh (xi,yi,interp2 (x,y,A,xi,yi, "cubic"));
 %! [x,y] = meshgrid (x,y);
 %! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
 %! clf;
 %! colormap ("default");
 %! [x,y,A] = peaks (10);
-%! x = x(1,:)'; y = y(:,1);
-%! xi = linspace (min(x), max(x), 41);
-%! yi = linspace (min(y), max(y), 41)';
+%! x = x(1,:)';  y = y(:,1);
+%! xi = linspace (min (x), max (x), 41);
+%! yi = linspace (min (y), max (y), 41)';
 %! mesh (xi,yi,interp2 (x,y,A,xi,yi, "cubic"));
 %! [x,y] = meshgrid (x,y);
 %! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
 %! clf;
 %! colormap ("default");
 %! A = [13,-1,12;5,4,3;1,6,2];
-%! x = [0,1,2]; y = [10,11,12];
-%! xi = linspace (min(x), max(x), 17);
-%! yi = linspace (min(y), max(y), 26)';
+%! x = [0,1,2];  y = [10,11,12];
+%! xi = linspace (min (x), max (x), 17);
+%! yi = linspace (min (y), max (y), 26)';
 %! mesh (xi,yi,interp2 (x,y,A,xi,yi, "spline"));
 %! [x,y] = meshgrid (x,y);
 %! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
 %! clf;
 %! colormap ("default");
 %! [x,y,A] = peaks (10);
-%! x = x(1,:)'; y = y(:,1);
-%! xi = linspace (min(x), max(x), 41);
-%! yi = linspace (min(y), max(y), 41)';
+%! x = x(1,:)';  y = y(:,1);
+%! xi = linspace (min (x), max (x), 41);
+%! yi = linspace (min (y), max (y), 41)';
 %! mesh (xi,yi,interp2 (x,y,A,xi,yi, "spline"));
 %! [x,y] = meshgrid (x,y);
 %! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!test % simple test
-%!  x = [1,2,3];
-%!  y = [4,5,6,7];
-%!  [X, Y] = meshgrid (x,y);
-%!  Orig = X.^2 + Y.^3;
-%!  xi = [1.2,2, 1.5];
-%!  yi = [6.2, 4.0, 5.0]';
+%! x = [1,2,3];
+%! y = [4,5,6,7];
+%! [X, Y] = meshgrid (x, y);
+%! Orig = X.^2 + Y.^3;
+%! xi = [1.2,2, 1.5];
+%! yi = [6.2, 4.0, 5.0]';
 %!
-%!  Expected = ...
-%!    [243,   245.4,  243.9;
-%!      65.6,  68,     66.5;
-%!     126.6, 129,    127.5];
-%!  Result = interp2 (x,y,Orig, xi, yi);
+%! Expected = ...
+%!   [243,   245.4,  243.9;
+%!     65.6,  68,     66.5;
+%!    126.6, 129,    127.5];
+%! Result = interp2 (x,y,Orig, xi, yi);
 %!
-%!  assert(Result, Expected, 1000*eps);
+%! assert (Result, Expected, 1000*eps);
 
 %!test % 2^n form
-%!  x = [1,2,3];
-%!  y = [4,5,6,7];
-%!  [X, Y] = meshgrid(x,y);
-%!  Orig = X.^2 + Y.^3;
-%!  xi = [1:0.25:3]; yi = [4:0.25:7]';
-%!  Expected = interp2(x,y,Orig, xi, yi);
-%!  Result = interp2(Orig,2);
+%! x = [1,2,3];
+%! y = [4,5,6,7];
+%! [X, Y] = meshgrid (x, y);
+%! Orig = X.^2 + Y.^3;
+%! xi = [1:0.25:3];  yi = [4:0.25:7]';
+%! Expected = interp2 (x,y,Orig, xi, yi);
+%! Result = interp2 (Orig, 2);
 %!
-%!  assert(Result, Expected, 10*eps);
+%! assert (Result, Expected, 10*eps);
 
 %!test % matrix slice
-%!  A = eye(4);
-%!  assert(interp2(A,[1:4],[1:4]),[1,1,1,1]);
+%! A = eye (4);
+%! assert (interp2 (A,[1:4],[1:4]), [1,1,1,1]);
 
 %!test % non-gridded XI,YI
-%!  A = eye(4);
-%!  assert(interp2(A,[1,2;3,4],[1,3;2,4]),[1,0;0,1]);
+%! A = eye (4);
+%! assert (interp2 (A,[1,2;3,4],[1,3;2,4]), [1,0;0,1]);
 
 %!test % for values outside of boundaries
-%!  x = [1,2,3];
-%!  y = [4,5,6,7];
-%!  [X, Y] = meshgrid(x,y);
-%!  Orig = X.^2 + Y.^3;
-%!  xi = [0,4];
-%!  yi = [3,8]';
-%!  assert(interp2(x,y,Orig, xi, yi),[NA,NA;NA,NA]);
-%!  assert(interp2(x,y,Orig, xi, yi,'linear', 0),[0,0;0,0]);
+%! x = [1,2,3];
+%! y = [4,5,6,7];
+%! [X, Y] = meshgrid (x,y);
+%! Orig = X.^2 + Y.^3;
+%! xi = [0,4];
+%! yi = [3,8]';
+%! assert (interp2 (x,y,Orig, xi, yi), [NA,NA;NA,NA]);
+%! assert (interp2 (x,y,Orig, xi, yi,"linear", 0), [0,0;0,0]);
 
 %!test % for values at boundaries
-%!  A=[1,2;3,4];
-%!  x=[0,1];
-%!  y=[2,3]';
-%!  assert(interp2(x,y,A,x,y,'linear'), A);
-%!  assert(interp2(x,y,A,x,y,'nearest'), A);
+%! A=[1,2;3,4];
+%! x=[0,1];
+%! y=[2,3]';
+%! assert (interp2 (x,y,A,x,y,"linear"), A);
+%! assert (interp2 (x,y,A,x,y,"nearest"), A);
 
 %!test % for Matlab-compatible rounding for 'nearest'
 %! X = meshgrid (1:4);
-%! assert (interp2 (X, 2.5, 2.5, 'nearest'), 3);
+%! assert (interp2 (X, 2.5, 2.5, "nearest"), 3);
 
 %!shared z, zout, tol
-%!  z = [1 3 5; 3 5 7; 5 7 9];
-%!  zout = [1 2 3 4 5; 2 3 4 5 6; 3 4 5 6 7; 4 5 6 7 8; 5 6 7 8 9];
-%!  tol = 2 * eps;
-%!assert (interp2 (z), zout, tol);
-%!assert (interp2 (z, "linear"), zout, tol);
-%!assert (interp2 (z, "pchip"), zout, tol);
-%!assert (interp2 (z, "cubic"), zout, 10 * tol);
-%!assert (interp2 (z, "spline"), zout, tol);
+%! z = [1 3 5; 3 5 7; 5 7 9];
+%! zout = [1 2 3 4 5; 2 3 4 5 6; 3 4 5 6 7; 4 5 6 7 8; 5 6 7 8 9];
+%! tol = 2 * eps;
+%!assert (interp2 (z), zout, tol)
+%!assert (interp2 (z, "linear"), zout, tol)
+%!assert (interp2 (z, "pchip"), zout, tol)
+%!assert (interp2 (z, "cubic"), zout, 10 * tol)
+%!assert (interp2 (z, "spline"), zout, tol)
 %!assert (interp2 (z, [2 3 1], [2 2 2]', "linear"), repmat ([5, 7, 3], [3, 1]), tol) 
 %!assert (interp2 (z, [2 3 1], [2 2 2]', "pchip"), repmat ([5, 7, 3], [3, 1]), tol) 
 %!assert (interp2 (z, [2 3 1], [2 2 2]', "cubic"), repmat ([5, 7, 3], [3, 1]), 10 * tol) 
 %!assert (interp2 (z, [2 3 1], [2 2 2]', "spline"), repmat ([5, 7, 3], [3, 1]), tol) 
-%!assert (interp2 (z, [2 3 1], [2 2 2], "linear"), [5 7 3], tol);
-%!assert (interp2 (z, [2 3 1], [2 2 2], "pchip"), [5 7 3], tol);
-%!assert (interp2 (z, [2 3 1], [2 2 2], "cubic"), [5 7 3], 10 * tol);
-%!assert (interp2 (z, [2 3 1], [2 2 2], "spline"), [5 7 3], tol);
+%!assert (interp2 (z, [2 3 1], [2 2 2], "linear"), [5 7 3], tol)
+%!assert (interp2 (z, [2 3 1], [2 2 2], "pchip"), [5 7 3], tol)
+%!assert (interp2 (z, [2 3 1], [2 2 2], "cubic"), [5 7 3], 10 * tol)
+%!assert (interp2 (z, [2 3 1], [2 2 2], "spline"), [5 7 3], tol)
+
diff --git a/scripts/general/interp3.m b/scripts/general/interp3.m
--- a/scripts/general/interp3.m
+++ b/scripts/general/interp3.m
@@ -130,26 +130,27 @@ function vi = interp3 (varargin)
     endif
     v = permute (v, [2, 1, 3]);
     vi = ipermute (interpn (x{:}, v, y{:}, method, extrapval), [2, 1, 3]);
   else
     error ("interp3: wrong number or incorrectly formatted input arguments");
   endif
 endfunction
 
+
 %!test
 %! x = y = z = -1:1;
 %! f = @(x,y,z) x.^2 - y - z.^2;
 %! [xx, yy, zz] = meshgrid (x, y, z);
 %! v = f (xx,yy,zz);
 %! xi = yi = zi = -1:0.5:1;
 %! [xxi, yyi, zzi] = meshgrid (xi, yi, zi);
-%! vi = interp3(x, y, z, v, xxi, yyi, zzi);
+%! vi = interp3 (x, y, z, v, xxi, yyi, zzi);
 %! [xxi, yyi, zzi] = ndgrid (xi, yi, zi);
-%! vi2 = interpn(x, y, z, v, xxi, yyi, zzi);
+%! vi2 = interpn (x, y, z, v, xxi, yyi, zzi);
 %! assert (vi, vi2);
 
 %!shared z, zout, tol
 %! z = zeros (3, 3, 3);
 %! zout = zeros (5, 5, 5);
 %! z(:,:,1) = [1 3 5; 3 5 7; 5 7 9];
 %! z(:,:,2) = z(:,:,1) + 2;
 %! z(:,:,3) = z(:,:,2) + 2;
@@ -159,8 +160,9 @@ endfunction
 %!                  3 4 5 6 7;
 %!                  4 5 6 7 8;
 %!                  5 6 7 8 9] + (n-1);
 %! end
 %! tol = 10 * eps;
 %!assert (interp3 (z), zout, tol)
 %!assert (interp3 (z, "linear"), zout, tol)
 %!assert (interp3 (z, "spline"), zout, tol)
+
diff --git a/scripts/general/interpft.m b/scripts/general/interpft.m
--- a/scripts/general/interpft.m
+++ b/scripts/general/interpft.m
@@ -88,27 +88,27 @@ function z = interpft (x, n, dim)
 
   z = ipermute (z, perm);
 
 endfunction
 
 
 %!demo
 %! clf;
-%! t = 0 : 0.3 : pi; dt = t(2)-t(1);
-%! n = length (t); k = 100;
+%! t = 0 : 0.3 : pi;  dt = t(2)-t(1);
+%! n = length (t);  k = 100;
 %! ti = t(1) + [0 : k-1]*dt*n/k;
 %! y = sin (4*t + 0.3) .* cos (3*t - 0.1);
 %! yp = sin (4*ti + 0.3) .* cos (3*ti - 0.1);
 %! plot (ti, yp, 'g', ti, interp1(t, y, ti, "spline"), 'b', ...
 %!       ti, interpft (y, k), 'c', t, y, "r+");
 %! legend ("sin(4t+0.3)cos(3t-0.1)", "spline", "interpft", "data");
 
 %!shared n,y
-%! x = [0:10]'; y = sin(x); n = length (x);
+%! x = [0:10]';  y = sin(x);  n = length (x);
 %!assert (interpft (y, n), y, 20*eps);
 %!assert (interpft (y', n), y', 20*eps);
 %!assert (interpft ([y,y],n), [y,y], 20*eps);
 
 %% Test input validation
 %!error interpft ()
 %!error interpft (1)
 %!error interpft (1,2,3)
diff --git a/scripts/general/interpn.m b/scripts/general/interpn.m
--- a/scripts/general/interpn.m
+++ b/scripts/general/interpn.m
@@ -209,66 +209,66 @@ function vi = interpn (varargin)
 
 endfunction
 
 
 %!demo
 %! clf;
 %! colormap ("default");
 %! A = [13,-1,12;5,4,3;1,6,2];
-%! x = [0,1,4]; y = [10,11,12];
-%! xi = linspace (min(x), max(x), 17);
-%! yi = linspace (min(y), max(y), 26)';
+%! x = [0,1,4];  y = [10,11,12];
+%! xi = linspace (min (x), max (x), 17);
+%! yi = linspace (min (y), max (y), 26)';
 %! mesh (xi, yi, interpn (x,y,A.',xi,yi, "linear").');
 %! [x,y] = meshgrid (x,y);
 %! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
 %! clf;
 %! colormap ("default");
 %! A = [13,-1,12;5,4,3;1,6,2];
-%! x = [0,1,4]; y = [10,11,12];
-%! xi = linspace (min(x), max(x), 17);
-%! yi = linspace (min(y), max(y), 26)';
+%! x = [0,1,4];  y = [10,11,12];
+%! xi = linspace (min (x), max (x), 17);
+%! yi = linspace (min (y), max (y), 26)';
 %! mesh (xi, yi, interpn (x,y,A.',xi,yi, "nearest").');
 %! [x,y] = meshgrid (x,y);
 %! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!#demo  # FIXME: Uncomment when support for "cubic" has been added
 %! clf;
 %! colormap ("default");
 %! A = [13,-1,12;5,4,3;1,6,2];
-%! x = [0,1,2]; y = [10,11,12];
-%! xi = linspace (min(x), max(x), 17);
-%! yi = linspace (min(y), max(y), 26)';
+%! x = [0,1,2];  y = [10,11,12];
+%! xi = linspace (min (x), max (x), 17);
+%! yi = linspace (min (y), max (y), 26)';
 %! mesh (xi, yi, interpn (x,y,A.',xi,yi, "cubic").');
 %! [x,y] = meshgrid (x,y);
 %! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
 %! clf;
 %! colormap ("default");
 %! A = [13,-1,12;5,4,3;1,6,2];
-%! x = [0,1,2]; y = [10,11,12];
-%! xi = linspace (min(x), max(x), 17);
-%! yi = linspace (min(y), max(y), 26)';
+%! x = [0,1,2];  y = [10,11,12];
+%! xi = linspace (min (x), max (x), 17);
+%! yi = linspace (min (y), max (y), 26)';
 %! mesh (xi, yi, interpn (x,y,A.',xi,yi, "spline").');
 %! [x,y] = meshgrid (x,y);
 %! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
 %! clf;
 %! colormap ("default");
 %! x = y = z = -1:1;
 %! f = @(x,y,z) x.^2 - y - z.^2;
 %! [xx, yy, zz] = meshgrid (x, y, z);
 %! v = f (xx,yy,zz);
 %! xi = yi = zi = -1:0.1:1;
 %! [xxi, yyi, zzi] = ndgrid (xi, yi, zi);
-%! vi = interpn (x, y, z, v, xxi, yyi, zzi, 'spline');
+%! vi = interpn (x, y, z, v, xxi, yyi, zzi, "spline");
 %! mesh (yi, zi, squeeze (vi(1,:,:)));
 
 %!test
 %! [x,y,z] = ndgrid (0:2);
 %! f = x + y + z;
 %! assert (interpn (x,y,z,f,[.5 1.5],[.5 1.5],[.5 1.5]), [1.5, 4.5]);
 %! assert (interpn (x,y,z,f,[.51 1.51],[.51 1.51],[.51 1.51],"nearest"), [3, 6]);
 %! assert (interpn (x,y,z,f,[.5 1.5],[.5 1.5],[.5 1.5],"spline"), [1.5, 4.5]);
diff --git a/scripts/general/isa.m b/scripts/general/isa.m
--- a/scripts/general/isa.m
+++ b/scripts/general/isa.m
@@ -46,16 +46,17 @@ function retval = isa (obj, cname)
     retval = strcmp (class_of_x, cname);
     if (! retval && isobject (obj))
       retval = __isa_parent__ (obj, cname);
     endif
   endif
 
 endfunction
 
+
 %!assert (isa ("char", "float"), false)
 %!assert (isa (logical (1), "float"), false)
 %!assert (isa (double (13), "float"), true)
 %!assert (isa (single (13), "float"), true)
 %!assert (isa (int8 (13), "float"), false)
 %!assert (isa (int16 (13), "float"), false)
 %!assert (isa (int32 (13), "float"), false)
 %!assert (isa (int64 (13), "float"), false)
@@ -71,26 +72,26 @@ endfunction
 %!assert (isa (int16 (13), "numeric"), true)
 %!assert (isa (int32 (13), "numeric"), true)
 %!assert (isa (int64 (13), "numeric"), true)
 %!assert (isa (uint8 (13), "numeric"), true)
 %!assert (isa (uint16 (13), "numeric"), true)
 %!assert (isa (uint32 (13), "numeric"), true)
 %!assert (isa (uint64 (13), "numeric"), true)
 
-%!assert (isa (double (13), "double"));
-%!assert (isa (single (13), "single"));
-%!assert (isa (int8 (13), "int8"));
-%!assert (isa (int16 (13), "int16"));
-%!assert (isa (int32 (13), "int32"));
-%!assert (isa (int64 (13), "int64"));
-%!assert (isa (uint8 (13), "uint8"));
-%!assert (isa (uint16 (13), "uint16"));
-%!assert (isa (uint32 (13), "uint32"));
-%!assert (isa (uint64 (13), "uint64"));
-%!assert (isa ("string", "char"));
-%!assert (isa (true, "logical"));
-%!assert (isa (false, "logical"));
-%!assert (isa ({1, 2}, "cell"));
+%!assert (isa (double (13), "double"))
+%!assert (isa (single (13), "single"))
+%!assert (isa (int8 (13), "int8"))
+%!assert (isa (int16 (13), "int16"))
+%!assert (isa (int32 (13), "int32"))
+%!assert (isa (int64 (13), "int64"))
+%!assert (isa (uint8 (13), "uint8"))
+%!assert (isa (uint16 (13), "uint16"))
+%!assert (isa (uint32 (13), "uint32"))
+%!assert (isa (uint64 (13), "uint64"))
+%!assert (isa ("string", "char"))
+%!assert (isa (true, "logical"))
+%!assert (isa (false, "logical"))
+%!assert (isa ({1, 2}, "cell"))
 %!test
 %! a.b = 1;
 %! assert (isa (a, "struct"));
 
diff --git a/scripts/general/isdir.m b/scripts/general/isdir.m
--- a/scripts/general/isdir.m
+++ b/scripts/general/isdir.m
@@ -27,13 +27,14 @@ function retval = isdir (f)
     print_usage ("isdir");
   endif
 
   ## Exist returns an integer but isdir should return a logical.
   retval = (exist (f, "dir") == 7);
 
 endfunction
 
-%!error isdir ();
-%!error isdir (1, 2);
+%!assert (isdir (pwd ()))
+%!assert (! isdir ("this is highly unlikely to be a directory name"))
 
-%!assert (isdir (pwd ()));
-%!assert (! isdir ("this is highly unlikely to be a directory name"));
+%!error isdir ()
+%!error isdir (1, 2)
+
diff --git a/scripts/general/isequal.m b/scripts/general/isequal.m
--- a/scripts/general/isequal.m
+++ b/scripts/general/isequal.m
@@ -27,22 +27,23 @@ function retval = isequal (x1, varargin)
   if (nargin < 2)
     print_usage ();
   endif
 
   retval = __isequal__ (false, x1, varargin{:});
 
 endfunction
 
+
 ## test size and shape
-%!assert(isequal([1,2,3,4],[1,2,3,4]), true)
-%!assert(isequal([1;2;3;4],[1;2;3;4]), true)
-%!assert(isequal([1,2,3,4],[1;2;3;4]), false)
-%!assert(isequal([1,2,3,4],[1,2;3,4]), false)
-%!assert(isequal([1,2,3,4],[1,3;2,4]), false)
+%!assert (isequal ([1,2,3,4],[1,2,3,4]), true)
+%!assert (isequal ([1;2;3;4],[1;2;3;4]), true)
+%!assert (isequal ([1,2,3,4],[1;2;3;4]), false)
+%!assert (isequal ([1,2,3,4],[1,2;3,4]), false)
+%!assert (isequal ([1,2,3,4],[1,3;2,4]), false)
 
 %!test
 %! A = 1:8;
 %! B = reshape (A, 2, 2, 2);
 %! assert (isequal (A, B), false);
 
 %!test
 %! A = reshape (1:8, 2, 2, 2);
@@ -50,25 +51,26 @@ endfunction
 %! assert (isequal (A, B), true);
 
 %!test
 %! A = reshape (1:8, 2, 4);
 %! B = reshape (A, 2, 2, 2);
 %! assert (isequal (A, B), false);
 
 ## test for equality
-%!assert(isequal([1,2,3,4],[1,2,3,4]), true)
-%!assert(isequal(['a','b','c','d'],['a','b','c','d']), true)
+%!assert (isequal ([1,2,3,4],[1,2,3,4]), true)
+%!assert (isequal (['a','b','c','d'],['a','b','c','d']), true)
 ## Test multi-line strings
-%!assert(isequal(["test";"strings"],["test";"strings"],["test";"strings"]), true)
+%!assert (isequal (["test";"strings"],["test";"strings"],["test";"strings"]), true)
 ## test for inequality
-%!assert(isequal([1,2,3,4],[1;2;3;4]),false)
-%!assert(isequal({1,2,3,4},[1,2,3,4]),false)
-%!assert(isequal([1,2,3,4],{1,2,3,4}),false)
-%!assert(isequal([1,2,NaN,4],[1,2,NaN,4]),false)
-%!assert(isequal(['a','b','c','d'],['a';'b';'c';'d']),false)
-%!assert(isequal({'a','b','c','d'},{'a';'b';'c';'d'}),false)
+%!assert (isequal ([1,2,3,4],[1;2;3;4]), false)
+%!assert (isequal ({1,2,3,4},[1,2,3,4]), false)
+%!assert (isequal ([1,2,3,4],{1,2,3,4}), false)
+%!assert (isequal ([1,2,NaN,4],[1,2,NaN,4]), false)
+%!assert (isequal (['a','b','c','d'],['a';'b';'c';'d']), false)
+%!assert (isequal ({'a','b','c','d'},{'a';'b';'c';'d'}), false)
 ## test for equality (struct)
-%!assert(isequal(struct('a',1,'b',2),struct('a',1,'b',2)),true)
-%!assert(isequal(struct('a',1,'b',2),struct('a',1,'b',2),struct('a',1,'b',2)),true)
-%!assert(isequal(struct('a','abc','b',2),struct('a','abc','b',2)),true)
+%!assert (isequal (struct ('a',1,'b',2),struct ('a',1,'b',2)), true)
+%!assert (isequal (struct ('a',1,'b',2),struct ('a',1,'b',2),struct ('a',1,'b',2)), true)
+%!assert (isequal (struct ('a',"abc",'b',2),struct ('a',"abc",'b',2)), true)
 ## test for inequality (struct)
-%!assert(isequal(struct('a',NaN,'b',2),struct('a',NaN,'b',2),struct('a',NaN,'b',2)),false)
+%!assert (isequal (struct ('a',NaN,'b',2),struct ('a',NaN,'b',2),struct ('a',NaN,'b',2)), false)
+
diff --git a/scripts/general/isequalwithequalnans.m b/scripts/general/isequalwithequalnans.m
--- a/scripts/general/isequalwithequalnans.m
+++ b/scripts/general/isequalwithequalnans.m
@@ -28,17 +28,19 @@ function retval = isequalwithequalnans (
   if (nargin < 2)
     print_usage ();
   endif
 
   retval = __isequal__ (true, x1, varargin{:});
 
 endfunction
 
+
 ## test for equality
-%!assert(isequalwithequalnans({1,2,NaN,4},{1,2,NaN,4}), true)
-%!assert(isequalwithequalnans([1,2,NaN,4],[1,2,NaN,4]), true)
+%!assert (isequalwithequalnans ({1,2,NaN,4},{1,2,NaN,4}), true)
+%!assert (isequalwithequalnans ([1,2,NaN,4],[1,2,NaN,4]), true)
 ## test for inequality
-%!assert(isequalwithequalnans([1,2,NaN,4],[1,NaN,3,4]),false)
-%!assert(isequalwithequalnans([1,2,NaN,4],[1,2,3,4]),false)
+%!assert (isequalwithequalnans ([1,2,NaN,4],[1,NaN,3,4]), false)
+%!assert (isequalwithequalnans ([1,2,NaN,4],[1,2,3,4]), false)
 ## test for equality (struct)
-%!assert(isequalwithequalnans(struct('a',NaN,'b',2),struct('a',NaN,'b',2),struct('a',NaN,'b',2)),true)
-%!assert(isequalwithequalnans(1,2,1), false)
+%!assert (isequalwithequalnans (struct ('a',NaN,'b',2),struct ('a',NaN,'b',2),struct ('a',NaN,'b',2)), true)
+%!assert (isequalwithequalnans (1,2,1), false)
+
diff --git a/scripts/general/issquare.m b/scripts/general/issquare.m
--- a/scripts/general/issquare.m
+++ b/scripts/general/issquare.m
@@ -36,27 +36,28 @@ function retval = issquare (x)
     [r, c] = size (x);
     retval = r == c;
   else
     retval = false;
   endif
 
 endfunction
 
-%!assert(issquare ([]));
-%!assert(issquare (1));
-%!assert(!(issquare ([1, 2])));
-%!assert(issquare ([1, 2; 3, 4]));
-%!assert(!(issquare ([1, 2; 3, 4; 5, 6])));
-%!assert(!(issquare (ones (3,3,3))));
-%!assert(issquare ("t"));
-%!assert(!(issquare ("test")));
-%!assert(issquare (["test"; "ing"; "1"; "2"]));
+
+%!assert (issquare ([]))
+%!assert (issquare (1))
+%!assert (! issquare ([1, 2]))
+%!assert (issquare ([1, 2; 3, 4]))
+%!assert (! issquare ([1, 2; 3, 4; 5, 6]))
+%!assert (! issquare (ones (3,3,3)))
+%!assert (issquare ("t"))
+%!assert (! issquare ("test"))
+%!assert (issquare (["test"; "ing"; "1"; "2"]))
 %!test
 %! s.a = 1;
-%! assert(issquare (s));
-%!assert(issquare ({1, 2; 3, 4}));
-%!assert(sparse (([1, 2; 3, 4])));
+%! assert (issquare (s));
+%!assert (issquare ({1, 2; 3, 4}))
+%!assert (sparse (([1, 2; 3, 4])))
 
 %% Test input validation
-%!error issquare ();
-%!error issquare ([1, 2; 3, 4], 2);
+%!error issquare ()
+%!error issquare ([1, 2; 3, 4], 2)
 
diff --git a/scripts/general/logspace.m b/scripts/general/logspace.m
--- a/scripts/general/logspace.m
+++ b/scripts/general/logspace.m
@@ -86,14 +86,14 @@ endfunction
 %! x3 = logspace (1, -2, 10);
 %! x4 = logspace (1, pi, 10);
 %! assert (size (x1) == [1, 50] && x1(1) == 10 && x1(50) == 100);
 %! assert (size (x2) == [1, 10] && x2(1) == 10 && x2(10) == 100);
 %! assert (size (x3) == [1, 10] && x3(1) == 10 && x3(10) == 0.01);
 %! assert (size (x4) == [1, 10] && x4(1) == 10 && abs (x4(10) - pi) < sqrt (eps));
 
 %% Test input validation
-%!error logspace ();
-%!error logspace (1, 2, 3, 4);
-%!error logspace ([1, 2; 3, 4], 5, 6);
-%!error logspace (1, [1, 2; 3, 4], 6);
-%!error logspace (1, 2, [1, 2; 3, 4]);
+%!error logspace ()
+%!error logspace (1, 2, 3, 4)
+%!error logspace ([1, 2; 3, 4], 5, 6)
+%!error logspace (1, [1, 2; 3, 4], 6)
+%!error logspace (1, 2, [1, 2; 3, 4])
 
diff --git a/scripts/general/nargchk.m b/scripts/general/nargchk.m
--- a/scripts/general/nargchk.m
+++ b/scripts/general/nargchk.m
@@ -58,23 +58,24 @@ function msg = nargchk (minargs, maxargs
     msg = resize (msg, 0, 1);
   endif
 
 endfunction
 
 
 ## Tests
 %!shared stnul, stmin, stmax
-%!  stnul = resize (struct ("message", "", "identifier", ""), 0, 1);
-%!  stmin = struct ("message", "not enough input arguments",
-%!                  "identifier", "Octave:nargchk:not-enough-inputs");
-%!  stmax = struct ("message", "too many input arguments",
-%!                  "identifier", "Octave:nargchk:too-many-inputs");
+%! stnul = resize (struct ("message", "", "identifier", ""), 0, 1);
+%! stmin = struct ("message", "not enough input arguments",
+%!                 "identifier", "Octave:nargchk:not-enough-inputs");
+%! stmax = struct ("message", "too many input arguments",
+%!                 "identifier", "Octave:nargchk:too-many-inputs");
 %!assert (nargchk (0, 1, 0), "")
 %!assert (nargchk (0, 1, 1), "")
 %!assert (nargchk (1, 1, 0), "not enough input arguments")
 %!assert (nargchk (0, 1, 2), "too many input arguments")
 %!assert (nargchk (0, 1, 2, "string"), "too many input arguments")
 ## Struct outputs
-%!assert (isequal (nargchk (0, 1, 0, "struct"), stnul))
-%!assert (isequal (nargchk (0, 1, 1, "struct"), stnul))
+%!assert (nargchk (0, 1, 0, "struct"), stnul)
+%!assert (nargchk (0, 1, 1, "struct"), stnul)
 %!assert (nargchk (1, 1, 0, "struct"), stmin)
 %!assert (nargchk (0, 1, 2, "struct"), stmax)
+
diff --git a/scripts/general/narginchk.m b/scripts/general/narginchk.m
--- a/scripts/general/narginchk.m
+++ b/scripts/general/narginchk.m
@@ -50,20 +50,21 @@ function narginchk (minargs, maxargs)
   if (args < minargs)
     error ("not enough input arguments");
   elseif (args > maxargs)
     error ("too many input arguments");
   endif
 
 endfunction
 
+
 %!function f (nargs, varargin)
 %! narginchk (nargs(1), nargs(2));
 %!endfunction
 
 %!error <too many input arguments> f([0,0])
 %!error <not enough input arguments> f([3, 3], 1)
 
 %!test
 %! f([1,1])
-
 %!test
 %! f([1,5], 2, 3, 4, 5)
+
diff --git a/scripts/general/nargoutchk.m b/scripts/general/nargoutchk.m
--- a/scripts/general/nargoutchk.m
+++ b/scripts/general/nargoutchk.m
@@ -99,26 +99,26 @@ function msg = nargoutchk (minargs, maxa
     endif
 
   else
     print_usage;
   endif
 
 endfunction
 
-## Tests
+
 %!shared stnul, stmin, stmax
-%!  stnul = resize (struct ("message", "", "identifier", ""), 0, 1);
-%!  stmin = struct ("message", "not enough output arguments",
-%!                  "identifier", "Octave:nargoutchk:not-enough-outputs");
-%!  stmax = struct ("message", "too many output arguments",
-%!                  "identifier", "Octave:nargoutchk:too-many-outputs");
+%! stnul = resize (struct ("message", "", "identifier", ""), 0, 1);
+%! stmin = struct ("message", "not enough output arguments",
+%!                 "identifier", "Octave:nargoutchk:not-enough-outputs");
+%! stmax = struct ("message", "too many output arguments",
+%!                 "identifier", "Octave:nargoutchk:too-many-outputs");
 %!assert (nargoutchk (0, 1, 0), "")
 %!assert (nargoutchk (0, 1, 1), "")
 %!assert (nargoutchk (1, 1, 0), "not enough output arguments")
 %!assert (nargoutchk (0, 1, 2), "too many output arguments")
 %!assert (nargoutchk (0, 1, 2, "string"), "too many output arguments")
 ## Struct outputs
-%!assert (isequal (nargoutchk (0, 1, 0, "struct"), stnul))
-%!assert (isequal (nargoutchk (0, 1, 1, "struct"), stnul))
+%!assert (nargoutchk (0, 1, 0, "struct"), stnul)
+%!assert (nargoutchk (0, 1, 1, "struct"), stnul)
 %!assert (nargoutchk (1, 1, 0, "struct"), stmin)
 %!assert (nargoutchk (0, 1, 2, "struct"), stmax)
 
diff --git a/scripts/general/nextpow2.m b/scripts/general/nextpow2.m
--- a/scripts/general/nextpow2.m
+++ b/scripts/general/nextpow2.m
@@ -51,18 +51,20 @@ function n = nextpow2 (x)
 
   [f, n] = log2 (abs (x));
   if (f == 0.5)
     n = n - 1;
   endif
 
 endfunction
 
-%!error nexpow2 ();
-%!error nexpow2 (1, 2);
 
-%!assert (nextpow2 (16), 4);
-%!assert (nextpow2 (17), 5);
-%!assert (nextpow2 (31), 5);
-%!assert (nextpow2 (-16), 4);
-%!assert (nextpow2 (-17), 5);
-%!assert (nextpow2 (-31), 5);
-%!assert (nextpow2 (1:17), 5);
+%!assert (nextpow2 (16), 4)
+%!assert (nextpow2 (17), 5)
+%!assert (nextpow2 (31), 5)
+%!assert (nextpow2 (-16), 4)
+%!assert (nextpow2 (-17), 5)
+%!assert (nextpow2 (-31), 5)
+%!assert (nextpow2 (1:17), 5)
+
+%!error nexpow2 ()
+%!error nexpow2 (1, 2)
+
diff --git a/scripts/general/nthargout.m b/scripts/general/nthargout.m
--- a/scripts/general/nthargout.m
+++ b/scripts/general/nthargout.m
@@ -102,12 +102,14 @@ function out = nthargout (n, varargin)
       error ("nthargout: Too many output arguments: %d", ntot);
     else
       error (err);
     endif
   end_try_catch
 
 endfunction
 
+
 %!shared m
 %! m = magic (5);
-%!assert (nthargout ([1, 2], @ind2sub, size(m), nthargout (2, @max, m(:))), {5,3}) 
+%!assert (nthargout ([1,2], @ind2sub, size (m), nthargout (2, @max, m(:))), {5,3})
 %!assert (nthargout (3, @find, m(m>20)), [23, 24, 25, 21, 22]')
+
diff --git a/scripts/general/num2str.m b/scripts/general/num2str.m
--- a/scripts/general/num2str.m
+++ b/scripts/general/num2str.m
@@ -172,15 +172,18 @@ function retval = num2str (x, arg)
     nd = ndims (x);
     tmp = sprintf (fmt, permute (x, [2, 1, 3:nd]));
     tmp(length (tmp)) = "";
     retval = strtrim (char (strsplit (tmp, "\n")));
   endif
 
 endfunction
 
-%!assert ((strcmp (num2str (123), "123") && strcmp (num2str (1.23), "1.23")));
-%!assert (num2str (123.456, 4), "123.5");
-%!assert (all (num2str ([1, 1.34; 3, 3.56], "%5.1f") == ["1.0  1.3"; "3.0  3.6"]));
-%!assert (num2str (1.234 + 27.3i), "1.234+27.3i");
-%!error num2str ();
-%!error num2str (1, 2, 3);
 
+%!assert (num2str (123), "123")
+%!assert (num2str (1.23), "1.23")
+%!assert (num2str (123.456, 4), "123.5")
+%!assert (num2str ([1, 1.34; 3, 3.56], "%5.1f"),  ["1.0  1.3"; "3.0  3.6"])
+%!assert (num2str (1.234 + 27.3i), "1.234+27.3i")
+
+%!error num2str ()
+%!error num2str (1, 2, 3)
+
diff --git a/scripts/general/pol2cart.m b/scripts/general/pol2cart.m
--- a/scripts/general/pol2cart.m
+++ b/scripts/general/pol2cart.m
@@ -75,68 +75,69 @@ function [x, y, z] = pol2cart (theta, r,
   y = r .* sin (theta);
 
   if (nargout <= 1)
     x  = [x, y, z];
   endif
 
 endfunction
 
+
 %!test
 %! t = [0, 0.5, 1] * pi;
 %! r = 1;
 %! [x, y] = pol2cart (t, r);
-%! assert (x, [1, 0, -1], sqrt(eps));
-%! assert (y, [0, 1,  0], sqrt(eps));
+%! assert (x, [1, 0, -1], sqrt (eps));
+%! assert (y, [0, 1,  0], sqrt (eps));
 
 %!test
 %! t = [0, 1, 1] * pi/4;
-%! r = sqrt(2) * [0, 1, 2];
+%! r = sqrt (2) * [0, 1, 2];
 %! [x, y] = pol2cart (t, r);
-%! assert (x, [0, 1, 2], sqrt(eps));
-%! assert (y, [0, 1, 2], sqrt(eps));
+%! assert (x, [0, 1, 2], sqrt (eps));
+%! assert (y, [0, 1, 2], sqrt (eps));
 
 %!test
 %! t = [0, 1, 1] * pi/4;
-%! r = sqrt(2) * [0, 1, 2];
+%! r = sqrt (2) * [0, 1, 2];
 %! z = [0, 1, 2];
 %! [x, y, z2] = pol2cart (t, r, z);
-%! assert (x, [0, 1, 2], sqrt(eps));
-%! assert (y, [0, 1, 2], sqrt(eps));
+%! assert (x, [0, 1, 2], sqrt (eps));
+%! assert (y, [0, 1, 2], sqrt (eps));
 %! assert (z, z2);
 
 %!test
 %! t = 0;
 %! r = [0, 1, 2];
 %! z = [0, 1, 2];
 %! [x, y, z2] = pol2cart (t, r, z);
-%! assert (x, [0, 1, 2], sqrt(eps));
-%! assert (y, [0, 0, 0], sqrt(eps));
+%! assert (x, [0, 1, 2], sqrt (eps));
+%! assert (y, [0, 0, 0], sqrt (eps));
 %! assert (z, z2);
 
 %!test
 %! t = [1, 1, 1]*pi/4;
 %! r = 1;
 %! z = [0, 1, 2];
 %! [x, y, z2] = pol2cart (t, r, z);
-%! assert (x, [1, 1, 1] / sqrt(2), eps);
-%! assert (y, [1, 1, 1] / sqrt(2), eps);
+%! assert (x, [1, 1, 1] / sqrt (2), eps);
+%! assert (y, [1, 1, 1] / sqrt (2), eps);
 %! assert (z, z2);
 
 %!test
 %! t = 0;
 %! r = [1, 2, 3];
 %! z = 1;
 %! [x, y, z2] = pol2cart (t, r, z);
 %! assert (x, [1, 2, 3], eps);
-%! assert (y, [0, 0, 0] / sqrt(2), eps);
+%! assert (y, [0, 0, 0] / sqrt (2), eps);
 %! assert (z, z2);
 
 %!test
 %! P = [0, 0; pi/4, sqrt(2); pi/4, 2*sqrt(2)];
 %! C = [0, 0; 1, 1; 2, 2];
-%! assert (pol2cart(P), C, sqrt(eps));
+%! assert (pol2cart (P), C, sqrt (eps));
 
 %!test
 %! P = [0, 0, 0; pi/4, sqrt(2), 1; pi/4, 2*sqrt(2), 2];
 %! C = [0, 0, 0; 1, 1, 1; 2, 2, 2];
-%! assert (pol2cart(P), C, sqrt(eps));
+%! assert (pol2cart (P), C, sqrt (eps));
 
diff --git a/scripts/general/polyarea.m b/scripts/general/polyarea.m
--- a/scripts/general/polyarea.m
+++ b/scripts/general/polyarea.m
@@ -56,15 +56,17 @@ function a = polyarea (x, y, dim)
     else
       a = abs (sum (x .* (shift (y, -1, dim) - shift (y, 1, dim)), dim)) / 2;
     endif
   else
     error ("polyarea: X and Y must have the same shape");
   endif
 endfunction
 
+
 %!shared x, y
 %! x = [1;1;3;3;1];
 %! y = [1;3;3;1;1];
-%!assert (polyarea(x,y), 4, eps)
-%!assert (polyarea([x,x],[y,y]), [4,4], eps)
-%!assert (polyarea([x,x],[y,y],1), [4,4], eps)
-%!assert (polyarea([x,x]',[y,y]',2), [4;4], eps)
+%!assert (polyarea (x,y), 4, eps)
+%!assert (polyarea ([x,x],[y,y]), [4,4], eps)
+%!assert (polyarea ([x,x],[y,y],1), [4,4], eps)
+%!assert (polyarea ([x,x]',[y,y]',2), [4;4], eps)
+
diff --git a/scripts/general/postpad.m b/scripts/general/postpad.m
--- a/scripts/general/postpad.m
+++ b/scripts/general/postpad.m
@@ -78,20 +78,20 @@ function y = postpad (x, l, c, dim)
     y = x(idx{:});
   else
     sz (dim) = l - d;
     y = cat (dim, x, c * ones (sz));
   endif
 
 endfunction
 
-%!error postpad ();
-%!error postpad (1);
-%!error postpad (1,2,3,4,5);
-%!error postpad ([1,2], 2, 2,3);
 
-%!assert (postpad ([1,2], 4), [1,2,0,0]);
-%!assert (postpad ([1;2], 4), [1;2;0;0]);
+%!assert (postpad ([1,2], 4), [1,2,0,0])
+%!assert (postpad ([1;2], 4), [1;2;0;0])
+%!assert (postpad ([1,2], 4, 2), [1,2,2,2])
+%!assert (postpad ([1;2], 4, 2), [1;2;2;2])
+%!assert (postpad ([1,2], 2, 2, 1), [1,2;2,2])
 
-%!assert (postpad ([1,2], 4, 2), [1,2,2,2]);
-%!assert (postpad ([1;2], 4, 2), [1;2;2;2]);
+%!error postpad ()
+%!error postpad (1)
+%!error postpad (1,2,3,4,5)
+%!error postpad ([1,2], 2, 2,3)
 
-%!assert (postpad ([1,2], 2, 2, 1), [1,2;2,2]);
diff --git a/scripts/general/prepad.m b/scripts/general/prepad.m
--- a/scripts/general/prepad.m
+++ b/scripts/general/prepad.m
@@ -78,22 +78,24 @@ function y = prepad (x, l, c, dim)
     y = x(idx{:});
   else
     sz (dim) = l - d;
     y = cat (dim, c * ones (sz), x);
   endif
 
 endfunction
 
-%!error prepad ();
-%!error prepad (1);
-%!error prepad (1,2,3,4,5);
-%!error prepad ([1,2], 2, 2,3);
+
+%!assert (prepad ([1,2], 4), [0,0,1,2])
+%!assert (prepad ([1;2], 4), [0;0;1;2])
 
-%!assert (prepad ([1,2], 4), [0,0,1,2]);
-%!assert (prepad ([1;2], 4), [0;0;1;2]);
+%!assert (prepad ([1,2], 4, 2), [2,2,1,2])
+%!assert (prepad ([1;2], 4, 2), [2;2;1;2])
 
-%!assert (prepad ([1,2], 4, 2), [2,2,1,2]);
-%!assert (prepad ([1;2], 4, 2), [2;2;1;2]);
-
-%!assert (prepad ([1,2], 2, 2, 1), [2,2;1,2]);
+%!assert (prepad ([1,2], 2, 2, 1), [2,2;1,2])
 
 ## FIXME -- we need tests for multidimensional arrays.
+
+%!error prepad ()
+%!error prepad (1)
+%!error prepad (1,2,3,4,5)
+%!error prepad ([1,2], 2, 2,3)
+
diff --git a/scripts/general/profile.m b/scripts/general/profile.m
--- a/scripts/general/profile.m
+++ b/scripts/general/profile.m
@@ -145,10 +145,10 @@ endfunction
 %! assert (fieldnames (ftbl), {"FunctionName"; "TotalTime"; "NumCalls"; "IsRecursive"; "Parents"; "Children"});
 %! hier = info.Hierarchical;
 %! assert (size (hier), [0, 1]);
 %! assert (fieldnames (hier), {"Index"; "SelfTime"; "NumCalls"; "Children"});
 
 %% Test input validation
 %!error profile ()
 %!error profile ("on", 2)
-%!error profile ("INVALID_OPTION");
+%!error profile ("INVALID_OPTION")
 
diff --git a/scripts/general/profshow.m b/scripts/general/profshow.m
--- a/scripts/general/profshow.m
+++ b/scripts/general/profshow.m
@@ -91,12 +91,12 @@ endfunction
 %! profshow (T, 10);
 
 %!demo
 %! profile on;
 %! expm (rand (500) + eye (500));
 %! profile off;
 %! profshow (profile ("info"), 5);
 
-%!error profshow ();
-%!error profshow (1, 2, 3);
-%!error profshow (struct (), 1.2);
+%!error profshow ()
+%!error profshow (1, 2, 3)
+%!error profshow (struct (), 1.2)
 
diff --git a/scripts/general/quadgk.m b/scripts/general/quadgk.m
--- a/scripts/general/quadgk.m
+++ b/scripts/general/quadgk.m
@@ -435,27 +435,29 @@ function [q, err] = __quadgk_eval__ (f, 
 endfunction
 
 function t = __quadgk_finite_waypoint__ (x, a, b)
   c = (-4 .* x + 2.* (b + a)) ./ (b - a);
   k = ((sqrt(c .^ 2 - 4) + c) ./ 2) .^ (1/3);
   t = real ((sqrt(3) .* 1i * (1 - k .^ 2) - (1 + k .^ 2)) ./ 2 ./ k);
 endfunction
 
+
+%!assert (quadgk (@sin,-pi,pi), 0, 1e-6)
+%!assert (quadgk (inline ("sin"),-pi,pi), 0, 1e-6)
+%!assert (quadgk ("sin",-pi,pi), 0, 1e-6)
+%!assert (quadgk (@sin,-pi,pi, "waypoints", 0, "MaxIntervalCount", 100, "reltol", 1e-3, "abstol", 1e-6, "trace", false), 0, 1e-6)
+%!assert (quadgk (@sin,-pi,pi, 1e-6,false), 0, 1e-6)
+
+%!assert (quadgk (@sin,-pi,0), -2, 1e-6)
+%!assert (quadgk (@sin,0,pi), 2, 1e-6)
+%!assert (quadgk (@(x) 1./sqrt (x),0,1), 2, 1e-6)
+%!assert (quadgk (@(x) abs (1 - x.^2),0,2, "Waypoints", 1), 2, 1e-6)
+%!assert (quadgk (@(x) 1./(sqrt (x) .* (x+1)),0,Inf), pi, 1e-6)
+%!assert (quadgk (@(z) log (z),1+1i,1+1i, "WayPoints", [1-1i, -1,-1i, -1+1i]), -pi * 1i, 1e-6)
+
+%!assert (quadgk (@(x) exp (-x .^ 2),-Inf,Inf), sqrt (pi), 1e-6)
+%!assert (quadgk (@(x) exp (-x .^ 2),-Inf,0), sqrt (pi)/2, 1e-6)
+
 %error (quadgk (@sin))
 %error (quadgk (@sin, -pi))
-%error (quadgk (@sin, -pi, pi, 'DummyArg'))
-
-%!assert (quadgk(@sin,-pi,pi), 0, 1e-6)
-%!assert (quadgk(inline('sin'),-pi,pi), 0, 1e-6)
-%!assert (quadgk('sin',-pi,pi), 0, 1e-6)
-%!assert (quadgk(@sin,-pi,pi,'waypoints', 0, 'MaxIntervalCount', 100, 'reltol', 1e-3, 'abstol', 1e-6, 'trace', false), 0, 1e-6)
-%!assert (quadgk(@sin,-pi,pi,1e-6,false), 0, 1e-6)
+%error (quadgk (@sin, -pi, pi, "DummyArg"))
 
-%!assert (quadgk(@sin,-pi,0), -2, 1e-6)
-%!assert (quadgk(@sin,0,pi), 2, 1e-6)
-%!assert (quadgk(@(x) 1./sqrt(x), 0, 1), 2, 1e-6)
-%!assert (quadgk (@(x) abs (1 - x.^2), 0, 2, 'Waypoints', 1), 2, 1e-6)
-%!assert (quadgk(@(x) 1./(sqrt(x).*(x+1)), 0, Inf), pi, 1e-6)
-%!assert (quadgk (@(z) log (z), 1+1i, 1+1i, 'WayPoints', [1-1i, -1,-1i, -1+1i]), -pi * 1i, 1e-6)
-
-%!assert (quadgk (@(x) exp(-x .^ 2), -Inf, Inf), sqrt(pi), 1e-6)
-%!assert (quadgk (@(x) exp(-x .^ 2), -Inf, 0), sqrt(pi)/2, 1e-6)
diff --git a/scripts/general/quadv.m b/scripts/general/quadv.m
--- a/scripts/general/quadv.m
+++ b/scripts/general/quadv.m
@@ -143,19 +143,21 @@ function [q, nfun, hmin] = simpsonstp (f
                                     tol, trace, varargin{:});
       [q2, nfun, hmin] = simpsonstp (f, c, b, e, fc, fb, fe, q2, nfun, hmin,
                                      tol, trace, varargin{:});
       q = q1 + q2;
     endif
   endif
 endfunction
 
+
 %!assert (quadv (@sin, 0, 2 * pi), 0, 1e-5)
 %!assert (quadv (@sin, 0, pi), 2, 1e-5)
 
 %% Handles weak singularities at the edge
 %!assert (quadv (@(x) 1 ./ sqrt(x), 0, 1), 2, 1e-5)
 
 %% Handles vector-valued functions
 %!assert (quadv (@(x) [(sin (x)), (sin (2 * x))], 0, pi), [2, 0], 1e-5)
 
 %% Handles matrix-valued functions
 %!assert (quadv (@(x) [ x, x, x; x, 1./sqrt(x), x; x, x, x ], 0, 1 ), [0.5, 0.5, 0.5; 0.5, 2, 0.5; 0.5, 0.5, 0.5], 1e-5)
+
diff --git a/scripts/general/randi.m b/scripts/general/randi.m
--- a/scripts/general/randi.m
+++ b/scripts/general/randi.m
@@ -108,34 +108,34 @@ function ri = randi (bounds, varargin)
   if (! strcmp (rclass, "double"))
     ri = cast (ri, rclass);
   endif
 
 endfunction
 
 %!test
 %! ri = randi (10, 1000, 1);
-%! assert(isequal(ri, fix (ri)));
-%! assert(min(ri) == 1);
-%! assert(max(ri) == 10);
-%! assert(rows(ri) == 1000);
-%! assert(columns(ri) == 1);
-%! assert(strcmp (class (ri), "double"));
+%! assert (ri, fix (ri));
+%! assert (min (ri), 1);
+%! assert (max (ri), 10);
+%! assert (rows (ri), 1000);
+%! assert (columns (ri), 1);
+%! assert (class (ri), "double");
 %!test
 %! ri = randi ([-5, 10], 1000, 1, "int8");
-%! assert(isequal(ri, fix (ri)));
-%! assert(min(ri) == -5);
-%! assert(max(ri) == 10);
-%! assert(strcmp (class (ri), "int8"));
+%! assert (ri, fix (ri));
+%! assert (min (ri), int8 (-5));
+%! assert (max (ri), int8 (10));
+%! assert (class (ri), "int8");
 %!
-%!assert(size (randi(10, 3,1,2)) == [3, 1, 2])
+%!assert (size (randi (10, 3,1,2)), [3, 1, 2])
 
 %% Test input validation
-%!error(randi())
-%!error(randi("test"))
-%!error(randi(10+2i))
-%!error(randi(0))
-%!error(randi([10, 1]))
-%!error(randi(256, "uint8"))
-%!error(randi(2^25, "single"))
-%!error(randi(bitmax() + 1))
-%!error(randi([-1, bitmax()]))
+%!error (randi ())
+%!error (randi ("test"))
+%!error (randi (10+2i))
+%!error (randi (0))
+%!error (randi ([10, 1]))
+%!error (randi (256, "uint8"))
+%!error (randi (2^25, "single"))
+%!error (randi (bitmax () + 1))
+%!error (randi ([-1, bitmax()]))
 
diff --git a/scripts/general/rat.m b/scripts/general/rat.m
--- a/scripts/general/rat.m
+++ b/scripts/general/rat.m
@@ -146,15 +146,17 @@ function [n,d] = rat(x,tol)
         n(:,n_nc+1:s_nc) = " ";
       endif
       n = cat (1, n, s);
     endfor
   endif
 
 endfunction
 
-%!error rat ();
-%!error rat (1, 2, 3);
 
 %!test
 %! [n, d] = rat ([0.5, 0.3, 1/3]);
 %! assert (n, [1, 3, 1]);
 %! assert (d, [2, 10, 3]);
+
+%!error rat ();
+%!error rat (1, 2, 3);
+
diff --git a/scripts/general/repmat.m b/scripts/general/repmat.m
--- a/scripts/general/repmat.m
+++ b/scripts/general/repmat.m
@@ -96,68 +96,69 @@ function x = repmat (A, m, n)
     # add singleton dims
     aaidx(2,:) = 1;
     A = reshape (A, aaidx(:));
     x = reshape (A (cidx{:}), idx .* aidx);
   endif
 
 endfunction
 
+
 # Test various methods of providing size parameters
 %!shared x
 %! x = [1 2;3 4];
-%!assert(repmat(x, [1 1]), repmat(x, 1));
-%!assert(repmat(x, [3 3]), repmat(x, 3));
-%!assert(repmat(x, [1 1]), repmat(x, 1, 1));
-%!assert(repmat(x, [1 3]), repmat(x, 1, 3));
-%!assert(repmat(x, [3 1]), repmat(x, 3, 1));
-%!assert(repmat(x, [3 3]), repmat(x, 3, 3));
+%!assert (repmat (x, [1 1]), repmat (x, 1))
+%!assert (repmat (x, [3 3]), repmat (x, 3))
+%!assert (repmat (x, [1 1]), repmat (x, 1, 1))
+%!assert (repmat (x, [1 3]), repmat (x, 1, 3))
+%!assert (repmat (x, [3 1]), repmat (x, 3, 1))
+%!assert (repmat (x, [3 3]), repmat (x, 3, 3))
 
 # Tests for numel==1 case:
 %!shared x, r
 %! x = [ 65 ];
-%! r = kron(ones(2,2), x);
-%!assert(r, repmat(x, [2 2]));
-%!assert(char(r), repmat(char(x), [2 2]));
-%!assert(int8(r), repmat(int8(x), [2 2]));
+%! r = kron (ones (2,2), x);
+%!assert (r, repmat (x, [2 2]))
+%!assert (char (r), repmat (char (x), [2 2]))
+%!assert (int8 (r), repmat (int8 (x), [2 2]))
 
 # Tests for ndims==2 case:
 %!shared x, r
 %! x = [ 65 66 67 ];
-%! r = kron(ones(2,2), x);
-%!assert(r, repmat(x, [2 2]));
-%!assert(char(r), repmat(char(x), [2 2]));
-%!assert(int8(r), repmat(int8(x), [2 2]));
+%! r = kron (ones (2,2), x);
+%!assert (r, repmat (x, [2 2]))
+%!assert (char (r), repmat (char (x), [2 2]))
+%!assert (int8 (r), repmat (int8 (x), [2 2]))
 
 # Tests for dim>2 case:
 %!shared x, r
 %! x = [ 65 66 67 ];
-%! r = kron(ones(2,2), x);
+%! r = kron (ones (2,2), x);
 %! r(:,:,2) = r(:,:,1);
-%!assert(r, repmat(x, [2 2 2]));
-%!assert(char(r), repmat(char(x), [2 2 2]));
-%!assert(int8(r), repmat(int8(x), [2 2 2]));
+%!assert (r, repmat (x, [2 2 2]))
+%!assert (char (r), repmat (char (x), [2 2 2]))
+%!assert (int8 (r), repmat (int8 (x), [2 2 2]))
 
 # Test that sparsity is kept
-%!assert(sparse(4,4), repmat(sparse(2,2),[2 2]));
+%!assert (sparse (4,4), repmat (sparse (2,2),[2 2]))
 
+%!assert (size (repmat (".", -1, 1)), [0, 1])
+%!assert (size (repmat (".", 1, -1)), [1, 0])
 
-%!assert (size (repmat (".", -1, 1)), [0, 1]);
-%!assert (size (repmat (".", 1, -1)), [1, 0]);
-%!error (size (repmat (".", -1, -1)));
-
-%!assert (size (repmat (1, [1, 0])), [1, 0]);
-%!assert (size (repmat (1, [5, 0])), [5, 0]);
-%!assert (size (repmat (1, [0, 1])), [0, 1]);
-%!assert (size (repmat (1, [0, 5])), [0, 5]);
+%!assert (size (repmat (1, [1, 0])), [1, 0])
+%!assert (size (repmat (1, [5, 0])), [5, 0])
+%!assert (size (repmat (1, [0, 1])), [0, 1])
+%!assert (size (repmat (1, [0, 5])), [0, 5])
 
 %!shared x
 %! x = struct ("a", [], "b", []);
-%!assert (size (repmat (x, [1, 0])), [1, 0]);
-%!assert (size (repmat (x, [5, 0])), [5, 0]);
-%!assert (size (repmat (x, [0, 1])), [0, 1]);
-%!assert (size (repmat (x, [0, 5])), [0, 5]);
+%!assert (size (repmat (x, [1, 0])), [1, 0])
+%!assert (size (repmat (x, [5, 0])), [5, 0])
+%!assert (size (repmat (x, [0, 1])), [0, 1])
+%!assert (size (repmat (x, [0, 5])), [0, 5])
 
-%!assert (size (repmat ({1}, [1, 0])), [1, 0]);
-%!assert (size (repmat ({1}, [5, 0])), [5, 0]);
-%!assert (size (repmat ({1}, [0, 1])), [0, 1]);
-%!assert (size (repmat ({1}, [0, 5])), [0, 5]);
+%!assert (size (repmat ({1}, [1, 0])), [1, 0])
+%!assert (size (repmat ({1}, [5, 0])), [5, 0])
+%!assert (size (repmat ({1}, [0, 1])), [0, 1])
+%!assert (size (repmat ({1}, [0, 5])), [0, 5])
 
+%!error (size (repmat (".", -1, -1)))
+
diff --git a/scripts/general/rot90.m b/scripts/general/rot90.m
--- a/scripts/general/rot90.m
+++ b/scripts/general/rot90.m
@@ -90,13 +90,14 @@ endfunction
 %! assert(rot90 (x1), x2);
 %! assert(rot90 (x1, 2), x3);
 %! assert(rot90 (x1, 3), x4);
 %! assert(rot90 (x1, 4), x1);
 %! assert(rot90 (x1, 5), x2);
 %! assert(rot90 (x1, -1), x4);
 
 %% Test input validation
-%!error rot90 ();
-%!error rot90 (1, 2, 3);
-%!error rot90 (1, ones(2));
-%!error rot90 (1, 1.5);
-%!error rot90 (1, 1+i);
+%!error rot90 ()
+%!error rot90 (1, 2, 3)
+%!error rot90 (1, ones(2))
+%!error rot90 (1, 1.5)
+%!error rot90 (1, 1+i)
+
diff --git a/scripts/general/rotdim.m b/scripts/general/rotdim.m
--- a/scripts/general/rotdim.m
+++ b/scripts/general/rotdim.m
@@ -119,40 +119,42 @@ function y = rotdim (x, n, plane)
       y = flipdim (y, max (plane));
     endif
   else
     error ("rotdim: internal error!");
   endif
 
 endfunction
 
-%!error rotdim ();
-%!error rotdim (1, 2, 3, 4);
 
 %!shared r, rr
-%! r = [1,2,3]; rr = [3,2,1];
-%!assert (rotdim (r, 0), r);
-%!assert (rotdim (r, 1), rr');
-%!assert (rotdim (r, 2), rr);
-%!assert (rotdim (r, 3), r');
-%!assert (rotdim (r, 3), rotdim (r, -1));
-%!assert (rotdim (r, 1), rotdim (r));
+%! r = [1,2,3];  rr = [3,2,1];
+%!assert (rotdim (r, 0), r)
+%!assert (rotdim (r, 1), rr')
+%!assert (rotdim (r, 2), rr)
+%!assert (rotdim (r, 3), r')
+%!assert (rotdim (r, 3), rotdim (r, -1))
+%!assert (rotdim (r, 1), rotdim (r))
 
 %!shared c, cr
-%! c = [1;2;3]; cr = [3;2;1];
-%!assert (rotdim (c, 0), c);
-%!assert (rotdim (c, 1), c');
-%!assert (rotdim (c, 2), cr);
-%!assert (rotdim (c, 3), cr');
-%!assert (rotdim (c, 3), rotdim (c, -1));
-%!assert (rotdim (c, 1), rotdim (c));
+%! c = [1;2;3];  cr = [3;2;1];
+%!assert (rotdim (c, 0), c)
+%!assert (rotdim (c, 1), c')
+%!assert (rotdim (c, 2), cr)
+%!assert (rotdim (c, 3), cr')
+%!assert (rotdim (c, 3), rotdim (c, -1))
+%!assert (rotdim (c, 1), rotdim (c))
 
 %!shared m
 %! m = [1,2;3,4];
-%!assert (rotdim (m, 0), m);
-%!assert (rotdim (m, 1), [2,4;1,3]);
-%!assert (rotdim (m, 2), [4,3;2,1]);
-%!assert (rotdim (m, 3), [3,1;4,2]);
-%!assert (rotdim (m, 3), rotdim (m, -1));
-%!assert (rotdim (m, 1), rotdim (m));
+%!assert (rotdim (m, 0), m)
+%!assert (rotdim (m, 1), [2,4;1,3])
+%!assert (rotdim (m, 2), [4,3;2,1])
+%!assert (rotdim (m, 3), [3,1;4,2])
+%!assert (rotdim (m, 3), rotdim (m, -1))
+%!assert (rotdim (m, 1), rotdim (m))
 
 ## FIXME -- we need tests for multidimensional arrays and different
 ## values of PLANE.
+
+%!error rotdim ()
+%!error rotdim (1, 2, 3, 4)
+
diff --git a/scripts/general/shift.m b/scripts/general/shift.m
--- a/scripts/general/shift.m
+++ b/scripts/general/shift.m
@@ -75,25 +75,25 @@ endfunction
 %!test
 %! a = [1, 2, 3];
 %! b = [4, 5, 6];
 %! c = [7, 8, 9];
 %!
 %! r = [a, b, c];
 %! m = [a; b; c];
 %!
-%! assert(shift (r, 0), r);
-%! assert(shift (r, 3), [c, a, b]);
-%! assert(shift (r, -6), [c, a, b]);
-%! assert(shift (r, -3), [b, c, a]);
-%! assert(shift (m, 1), [c; a; b]);
-%! assert(shift (m, -2), [c; a; b]);
+%! assert (shift (r, 0), r);
+%! assert (shift (r, 3), [c, a, b]);
+%! assert (shift (r, -6), [c, a, b]);
+%! assert (shift (r, -3), [b, c, a]);
+%! assert (shift (m, 1), [c; a; b]);
+%! assert (shift (m, -2), [c; a; b]);
 
 %% Test input validation
 %!error shift ()
 %!error shift (1, 2, 3, 4)
 %!error shift ([], 1)
-%!error shift (ones(2), ones(2))
-%!error shift (ones(2), 1.5)
+%!error shift (ones (2), ones (2))
+%!error shift (ones (2), 1.5)
 %!error shift (1, 1, 1.5)
 %!error shift (1, 1, 0)
 %!error shift (1, 1, 3)
 
diff --git a/scripts/general/shiftdim.m b/scripts/general/shiftdim.m
--- a/scripts/general/shiftdim.m
+++ b/scripts/general/shiftdim.m
@@ -85,16 +85,17 @@ endfunction
 
 %!test
 %! x = rand (1, 1, 4, 2);
 %! [y, ns] = shiftdim (x);
 %! assert (size (y), [4 2]);
 %! assert (ns, 2);
 %! assert (shiftdim (y, -2), x);
 %! assert (size (shiftdim (x, 2)), [4 2]);
-%!assert (size (shiftdim (rand (0, 1, 2))), [0 1 2]);
+
+%!assert (size (shiftdim (rand (0, 1, 2))), [0 1 2])
 
 %% Test input validation
-%!error(shiftdim ());
-%!error(shiftdim (1,2,3));
-%!error(shiftdim (1, ones (2)));
-%!error(shiftdim (1, 1.5));
+%!error (shiftdim ())
+%!error (shiftdim (1,2,3))
+%!error (shiftdim (1, ones (2)))
+%!error (shiftdim (1, 1.5))
 
diff --git a/scripts/general/sph2cart.m b/scripts/general/sph2cart.m
--- a/scripts/general/sph2cart.m
+++ b/scripts/general/sph2cart.m
@@ -66,16 +66,17 @@ function [x, y, z] = sph2cart (theta, ph
   z = r .* sin (phi);
 
   if (nargout <= 1)
     x = [x, y, z];
   endif
 
 endfunction
 
+
 %!test
 %! t = [0, 0, 0];
 %! p = [0, 0, 0];
 %! r = [0, 1, 2];
 %! [x, y, z] = sph2cart (t, p, r);
 %! assert (x, r);
 %! assert (y, [0, 0, 0]);
 %! assert (z, [0, 0, 0]);
@@ -105,10 +106,10 @@ endfunction
 %! [x, y, z] = sph2cart (t, p, r);
 %! assert (x, [1, 0, -1], eps);
 %! assert (y, [0, 1, 0], eps);
 %! assert (z, [0, 0, 0], eps);
 
 %!test
 %! S = [ 0, 0, 1; 0.5*pi, 0, 1; pi, 0, 1];
 %! C = [ 1, 0, 0; 0, 1, 0; -1, 0, 0];
-%! assert (sph2cart(S), C, eps);
+%! assert (sph2cart (S), C, eps);
 
diff --git a/scripts/general/structfun.m b/scripts/general/structfun.m
--- a/scripts/general/structfun.m
+++ b/scripts/general/structfun.m
@@ -128,19 +128,20 @@ endfunction
 %!test
 %! s = struct ("a", {1, 2, 3}, "b", {4, 5, 6});
 %! c(1:2, 1, 1) = [2; 8];
 %! c(1:2, 1, 2) = [4; 10];
 %! c(1:2, 1, 3) = [6; 12];
 %! d(1:2, 1, 1) = [1; 16];
 %! d(1:2, 1, 2) = [4; 25];
 %! d(1:2, 1, 3) = [9; 36];
-%! [aa, bb] = structfun(@__twoouts, s);
-%! assert(aa, c);
-%! assert(bb, d);
+%! [aa, bb] = structfun (@__twoouts, s);
+%! assert (aa, c);
+%! assert (bb, d);
 
 %!test
 %! s = struct ("a", {1, 2, 3}, "b", {4, 5, 6});
 %! c = struct ("a", {2, 4, 6}, "b", {8, 10, 12});
 %! d = struct ("a", {1, 4, 9}, "b", {16, 25, 36});
-%! [aa, bb] = structfun(@__twoouts, s, "UniformOutput", false);
-%! assert(aa, c);
-%! assert(bb, d);
+%! [aa, bb] = structfun (@__twoouts, s, "UniformOutput", false);
+%! assert (aa, c);
+%! assert (bb, d);
+
diff --git a/scripts/general/trapz.m b/scripts/general/trapz.m
--- a/scripts/general/trapz.m
+++ b/scripts/general/trapz.m
@@ -118,21 +118,21 @@ function z = trapz (x, y, dim)
         error ("trapz: X and Y must have same shape");
       endif
       z = 0.5 * sum (diff (x, 1, dim) .* (y(idx1{:}) + y(idx2{:})), dim);
     endif
   endif
 endfunction
 
 
-%!assert (trapz(1:5), 12)
-%!assert (trapz(0:0.5:2,1:5), 6)
-%!assert (trapz([1:5;1:5].',1), [12,12])
-%!assert (trapz([1:5;1:5],2), [12;12])
-%!assert (trapz(repmat(reshape(1:5,1,1,5),2,2), 3), [12 12; 12 12])
-%!assert (trapz([0:0.5:2;0:0.5:2].',[1:5;1:5].',1), [6, 6])
-%!assert (trapz([0:0.5:2;0:0.5:2],[1:5;1:5],2), [6; 6])
-%!assert (trapz(repmat(reshape([0:0.5:2],1,1,5),2,2), ...
-%!              repmat(reshape(1:5,1,1,5),2,2), 3), [6 6; 6 6])
-%!assert (trapz(0:0.5:2,[(1:5)',(1:5)']), [6, 6])
-%!assert (trapz(0:0.5:2,[(1:5);(1:5)],2), [6; 6])
-%!assert (trapz(0:0.5:2,repmat(reshape(1:5,1,1,5),2,2),3), [6 6; 6 6])
+%!assert (trapz (1:5), 12)
+%!assert (trapz (0:0.5:2,1:5), 6)
+%!assert (trapz ([1:5;1:5].',1), [12,12])
+%!assert (trapz ([1:5;1:5],2), [12;12])
+%!assert (trapz (repmat (reshape (1:5,1,1,5),2,2), 3), [12 12; 12 12])
+%!assert (trapz ([0:0.5:2;0:0.5:2].',[1:5;1:5].',1), [6, 6])
+%!assert (trapz ([0:0.5:2;0:0.5:2],[1:5;1:5],2), [6; 6])
+%!assert (trapz (repmat (reshape ([0:0.5:2],1,1,5),2,2), ...
+%!               repmat (reshape (1:5,1,1,5),2,2), 3), [6 6; 6 6])
+%!assert (trapz (0:0.5:2,[(1:5)',(1:5)']), [6, 6])
+%!assert (trapz (0:0.5:2,[(1:5);(1:5)],2), [6; 6])
+%!assert (trapz (0:0.5:2,repmat (reshape (1:5,1,1,5),2,2),3), [6 6; 6 6])
 
diff --git a/scripts/general/triplequad.m b/scripts/general/triplequad.m
--- a/scripts/general/triplequad.m
+++ b/scripts/general/triplequad.m
@@ -71,15 +71,15 @@ endfunction
 function q = __triplequad_inner__ (y, z, f, xa, xb, tol, quadf, varargin)
   q = zeros (size(y));
   for i = 1 : length (y)
     q(i) = feval (quadf, @(x) f (x, y(i), z, varargin{:}), xa, xb, tol);
   endfor
 endfunction
 
 
-%!assert (triplequad (@(x,y,z) exp(-x.^2 - y.^2 - z.^2) , -1, 1, -1, 1, -1, 1, [],  @quadcc), pi ^ (3/2) * erf(1).^3, 1e-6)
+%!assert (triplequad (@(x,y,z) exp (-x.^2 - y.^2 - z.^2) , -1, 1, -1, 1, -1, 1, [], @quadcc), pi^(3/2) * erf (1).^3, 1e-6)
 
 %% These tests are too expensive to run normally (~30 sec each).  Disable them
-#%!assert (triplequad (@(x,y,z) exp(-x.^2 - y.^2 - z.^2) , -1, 1, -1, 1, -1, 1, [],  @quadgk), pi ^ (3/2) * erf(1).^3, 1e-6)
-#%!#assert (triplequad (@(x,y,z) exp(-x.^2 - y.^2 - z.^2) , -1, 1, -1, 1, -1, 1, [],  @quadl), pi ^ (3/2) * erf(1).^3, 1e-6)
-#%!#assert (triplequad (@(x,y,z) exp(-x.^2 - y.^2 - z.^2) , -1, 1, -1, 1, -1, 1, [],  @quadv), pi ^ (3/2) * erf(1).^3, 1e-6)
+#%!assert (triplequad (@(x,y,z) exp (-x.^2 - y.^2 - z.^2) , -1, 1, -1, 1, -1, 1, [], @quadgk), pi^(3/2) * erf (1).^3, 1e-6)
+#%!#assert (triplequad (@(x,y,z) exp (-x.^2 - y.^2 - z.^2) , -1, 1, -1, 1, -1, 1, [], @quadl), pi^(3/2) * erf (1).^3, 1e-6)
+#%!#assert (triplequad (@(x,y,z) exp (-x.^2 - y.^2 - z.^2) , -1, 1, -1, 1, -1, 1, [], @quadv), pi^(3/2) * erf (1).^3, 1e-6)
 
diff --git a/scripts/geometry/convhull.m b/scripts/geometry/convhull.m
--- a/scripts/geometry/convhull.m
+++ b/scripts/geometry/convhull.m
@@ -93,12 +93,12 @@ endfunction
 %! y = abs (sin (x));
 %! k = convhull (x, y);
 %! plot (x(k),y(k),"r-;convex hull;", x,y,"b+;points;");
 %! axis ([-3.05, 3.05, -0.05, 1.05]);
 
 %!testif HAVE_QHULL
 %! x = -3:0.5:3;
 %! y = abs (sin (x));
-%! assert (convhull (x, y), [1;7;13;12;11;10;4;3;2;1])
+%! assert (convhull (x, y), [1;7;13;12;11;10;4;3;2;1]);
 
 %% FIXME: Need input validation tests
 
diff --git a/scripts/geometry/dsearch.m b/scripts/geometry/dsearch.m
--- a/scripts/geometry/dsearch.m
+++ b/scripts/geometry/dsearch.m
@@ -27,14 +27,16 @@
 
 function idx = dsearch (x, y, tri, xi, yi, s)
   if (nargin < 5 || nargin > 6)
     print_usage ();
   endif
   idx = __dsearchn__ ([x(:), y(:)], [xi(:), yi(:)]);
 endfunction
 
+
 %!shared x, y, tri
 %! x = [-1;-1;1];
 %! y = [-1;1;-1];
 %! tri = [1,2,3];
-%!assert (dsearch(x,y,tri,1,1/3), 3);
-%!assert (dsearch(x,y,tri,1/3,1), 2);
+%!assert (dsearch (x,y,tri,1,1/3), 3)
+%!assert (dsearch (x,y,tri,1/3,1), 2)
+
diff --git a/scripts/geometry/dsearchn.m b/scripts/geometry/dsearchn.m
--- a/scripts/geometry/dsearchn.m
+++ b/scripts/geometry/dsearchn.m
@@ -41,17 +41,19 @@ function [idx, d] = dsearchn (x, tri, xi
     if (nargin == 4)
       idx2 = isnan (tsearchn (x, tri, xi));
       idx(idx2) = outval;
       d(idx2) = outval;
     endif
   endif
 endfunction
 
+
 %!shared x, tri
 %! x = [-1,-1;-1,1;1,-1];
 %! tri = [1,2,3];
-%!assert (dsearchn(x,tri,[1,1/3]), 3);
-%!assert (dsearchn(x,tri,[1,1/3],NaN), NaN);
-%!assert (dsearchn(x,tri,[1,1/3],NA), NA);
-%!assert (dsearchn(x,tri,[1/3,1]), 2);
-%!assert (dsearchn(x,tri,[1/3,1],NaN), NaN);
-%!assert (dsearchn(x,tri,[1/3,1],NA), NA);
+%!assert (dsearchn (x,tri,[1,1/3]), 3)
+%!assert (dsearchn (x,tri,[1,1/3],NaN), NaN)
+%!assert (dsearchn (x,tri,[1,1/3],NA), NA)
+%!assert (dsearchn (x,tri,[1/3,1]), 2)
+%!assert (dsearchn (x,tri,[1/3,1],NaN), NaN)
+%!assert (dsearchn (x,tri,[1/3,1],NA), NA)
+
diff --git a/scripts/geometry/griddata3.m b/scripts/geometry/griddata3.m
--- a/scripts/geometry/griddata3.m
+++ b/scripts/geometry/griddata3.m
@@ -61,24 +61,25 @@ endfunction
 %! old_state = rand ("state");
 %! restore_state = onCleanup (@() rand ("state", old_state));
 %! rand ("state", 0);
 %! x = 2 * rand (1000, 1) - 1;
 %! y = 2 * rand (1000, 1) - 1;
 %! z = 2 * rand (1000, 1) - 1;
 %! v = x.^2 + y.^2 + z.^2;
 %! [xi, yi, zi] = meshgrid (-0.8:0.2:0.8);
-%! vi = griddata3 (x, y, z, v, xi, yi, zi, 'linear');
+%! vi = griddata3 (x, y, z, v, xi, yi, zi, "linear");
 %! vv = vi - xi.^2 - yi.^2 - zi.^2;
 %! assert (max (abs (vv(:))), 0, 0.1);
 
 %!testif HAVE_QHULL
 %! old_state = rand ("state");
 %! restore_state = onCleanup (@() rand ("state", old_state));
 %! rand ("state", 0);
 %! x = 2 * rand (1000, 1) - 1;
 %! y = 2 * rand (1000, 1) - 1;
 %! z = 2 * rand (1000, 1) - 1;
 %! v = x.^2 + y.^2 + z.^2;
 %! [xi, yi, zi] = meshgrid (-0.8:0.2:0.8);
-%! vi = griddata3 (x, y, z, v, xi, yi, zi, 'nearest');
+%! vi = griddata3 (x, y, z, v, xi, yi, zi, "nearest");
 %! vv = vi - xi.^2 - yi.^2 - zi.^2;
 %! assert (max (abs (vv(:))), 0, 0.1)
+
diff --git a/scripts/geometry/griddatan.m b/scripts/geometry/griddatan.m
--- a/scripts/geometry/griddatan.m
+++ b/scripts/geometry/griddatan.m
@@ -80,27 +80,29 @@ function yi = griddatan (x, y, xi, metho
     yi(valid) = sum (y(tri(tri_list,:)) .* bary_list, 2);
 
   else
     error ("griddatan: unknown interpolation METHOD");
   endif
 
 endfunction
 
-%!testif HAVE_QHULL
-%! [xx,yy] = meshgrid(linspace(-1,1,32));
-%! xi = [xx(:), yy(:)];
-%! x = (2 * rand(100,2) - 1);
-%! x = [x;1,1;1,-1;-1,-1;-1,1];
-%! y = sin(2*(sum(x.^2,2)));
-%! zz = griddatan(x,y,xi,'linear');
-%! zz2 = griddata(x(:,1),x(:,2),y,xi(:,1),xi(:,2),'linear');
-%! assert (zz, zz2, 1e-10)
 
 %!testif HAVE_QHULL
-%! [xx,yy] = meshgrid(linspace(-1,1,32));
+%! [xx,yy] = meshgrid (linspace (-1,1,32));
 %! xi = [xx(:), yy(:)];
-%! x = (2 * rand(100,2) - 1);
+%! x = 2*rand (100,2) - 1;
 %! x = [x;1,1;1,-1;-1,-1;-1,1];
-%! y = sin(2*(sum(x.^2,2)));
-%! zz = griddatan(x,y,xi,'nearest');
-%! zz2 = griddata(x(:,1),x(:,2),y,xi(:,1),xi(:,2),'nearest');
-%! assert (zz, zz2, 1e-10)
+%! y = sin (2 * sum (x.^2,2));
+%! zz = griddatan (x,y,xi,"linear");
+%! zz2 = griddata (x(:,1),x(:,2),y,xi(:,1),xi(:,2),"linear");
+%! assert (zz, zz2, 1e-10);
+
+%!testif HAVE_QHULL
+%! [xx,yy] = meshgrid (linspace (-1,1,32));
+%! xi = [xx(:), yy(:)];
+%! x = 2*rand (100,2) - 1;
+%! x = [x;1,1;1,-1;-1,-1;-1,1];
+%! y = sin (2*sum (x.^2,2));
+%! zz = griddatan (x,y,xi,"nearest");
+%! zz2 = griddata (x(:,1),x(:,2),y,xi(:,1),xi(:,2),"nearest");
+%! assert (zz, zz2, 1e-10);
+
diff --git a/scripts/geometry/rectint.m b/scripts/geometry/rectint.m
--- a/scripts/geometry/rectint.m
+++ b/scripts/geometry/rectint.m
@@ -106,26 +106,27 @@ function area = rectint (a, b)
   endfor
 
   if swapinputs
     area = area';
   endif
 
 endfunction
 
-## Tests
+
 ## Exactly overlapping
-%!assert(rectint([0 0 1 1], [0 0 1 1]), 1)
+%!assert (rectint ([0 0 1 1], [0 0 1 1]), 1)
 ## rect2 completely enclosed by rect1
-%!assert(rectint([-1 -1 3 3], [0 0 1 1]), 1)
+%!assert (rectint ([-1 -1 3 3], [0 0 1 1]), 1)
 ## rect1 completely enclosed by rect2
-%!assert(rectint([0 0 1 1], [-1 -1 3 3]), 1)
+%!assert (rectint ([0 0 1 1], [-1 -1 3 3]), 1)
 ## rect1 right and top in rect2
-%!assert(rectint([-1 -1 1.5 1.5], [0 0 1 1]), 0.25)
+%!assert (rectint ([-1 -1 1.5 1.5], [0 0 1 1]), 0.25)
 ## rect2 right and top in rect1
-%!assert(rectint([0 0 1 1], [-1 -1 1.5 1.5]), 0.25)
+%!assert (rectint ([0 0 1 1], [-1 -1 1.5 1.5]), 0.25)
 ## no overlap - shared corner
-%!assert(rectint([0 0 1 1], [1 1 2 2]), 0)
+%!assert (rectint ([0 0 1 1], [1 1 2 2]), 0)
 ## no overlap - shared edge
-%!assert(rectint([0 0 1 1], [0 1 2 2]), 0)
+%!assert (rectint ([0 0 1 1], [0 1 2 2]), 0)
 ## Correct orientation of output
-%!assert(rectint([0 0 1 1;0.5 0.5 1 1;-1 -1 2 2], [1 1 2 2]), [0;0.25;0])
-%!assert(rectint([1 1 2 2], [0 0 1 1;0.5 0.5 1 1;-1 -1 2 2]), [0 0.25 0])
+%!assert (rectint ([0 0 1 1;0.5 0.5 1 1;-1 -1 2 2], [1 1 2 2]), [0;0.25;0])
+%!assert (rectint ([1 1 2 2], [0 0 1 1;0.5 0.5 1 1;-1 -1 2 2]), [0 0.25 0])
+
diff --git a/scripts/geometry/tsearchn.m b/scripts/geometry/tsearchn.m
--- a/scripts/geometry/tsearchn.m
+++ b/scripts/geometry/tsearchn.m
@@ -77,31 +77,33 @@ function Beta = cart2bary (T, P)
   ## Beta(end) = sum(Beta)
   ##
   ## Note below is generalize for multiple values of P, one per row.
   [M, N] = size (P);
   Beta = (P - ones (M,1) * T(end,:)) / (T(1:end-1,:) - ones(N,1) * T(end,:));
   Beta (:,end+1) = 1 - sum(Beta, 2);
 endfunction
 
+
 %!shared x, tri
 %! x = [-1,-1;-1,1;1,-1];
 %! tri = [1, 2, 3];
 %!test
 %! [idx, p] = tsearchn (x,tri,[-1,-1]);
-%! assert (idx, 1)
-%! assert (p, [1,0,0], 1e-12)
+%! assert (idx, 1);
+%! assert (p, [1,0,0], 1e-12);
 %!test
 %! [idx, p] = tsearchn (x,tri,[-1,1]);
-%! assert (idx, 1)
-%! assert (p, [0,1,0], 1e-12)
+%! assert (idx, 1);
+%! assert (p, [0,1,0], 1e-12);
 %!test
 %! [idx, p] = tsearchn (x,tri,[1,-1]);
-%! assert (idx, 1)
-%! assert (p, [0,0,1], 1e-12)
+%! assert (idx, 1);
+%! assert (p, [0,0,1], 1e-12);
 %!test
 %! [idx, p] = tsearchn (x,tri,[-1/3,-1/3]);
-%! assert (idx, 1)
-%! assert (p, [1/3,1/3,1/3], 1e-12)
+%! assert (idx, 1);
+%! assert (p, [1/3,1/3,1/3], 1e-12);
 %!test
 %! [idx, p] = tsearchn (x,tri,[1,1]);
-%! assert (idx, NaN)
-%! assert (p, [NaN, NaN, NaN])
+%! assert (idx, NaN);
+%! assert (p, [NaN, NaN, NaN]);
+
diff --git a/scripts/help/__makeinfo__.m b/scripts/help/__makeinfo__.m
--- a/scripts/help/__makeinfo__.m
+++ b/scripts/help/__makeinfo__.m
@@ -143,11 +143,12 @@ function [retval, status] = __makeinfo__
 
   unwind_protect_cleanup
     if (exist (name, "file"))
       delete (name);
     endif
   end_unwind_protect
 endfunction
 
+
 ## No test needed for internal helper function.
 %!assert (1)
 
diff --git a/scripts/help/doc.m b/scripts/help/doc.m
--- a/scripts/help/doc.m
+++ b/scripts/help/doc.m
@@ -101,11 +101,15 @@ function retval = doc (fname)
     endif
 
   else
     print_usage ();
   endif
 
 endfunction
 
-%!test if exist( info_file ()) != 2 && exist (sprintf ("%s.gz", info_file ())) != 2
-%!       error ("Info file %s or %s.gz does not exist!", info_file (), info_file ());
-%!     endif
+
+%!test
+%! ifile = info_file ();
+%! if (exist (ifile) != 2 && exist (sprintf ("%s.gz", ifile)) != 2)
+%!   error ("Info file %s or %s.gz does not exist!", ifile, ifile);
+%! endif
+
diff --git a/scripts/help/get_first_help_sentence.m b/scripts/help/get_first_help_sentence.m
--- a/scripts/help/get_first_help_sentence.m
+++ b/scripts/help/get_first_help_sentence.m
@@ -148,17 +148,18 @@ endfunction
 function [text, status] = first_sentence_html (help_text, max_len)
   ## Strip tags
   [help_text, status] = strip_html_tags (help_text);
 
   ## Extract first line with plain text method.
   text = first_sentence_plain_text (help_text, max_len);
 endfunction
 
-%!assert (strcmp (get_first_help_sentence('get_first_help_sentence'), "Return the first sentence of a function's help text."));
+
+%!assert (get_first_help_sentence ('get_first_help_sentence'), "Return the first sentence of a function's help text.")
 
 %% Test input validation
 %!error get_first_help_sentence ()
 %!error get_first_help_sentence (1, 2, 3)
 %!error get_first_help_sentence (1)
 %!error get_first_help_sentence ('ls', 'a')
 %!error get_first_help_sentence ('ls', 0)
 %!error get_first_help_sentence ('ls', 80.1)
diff --git a/scripts/help/help.m b/scripts/help/help.m
--- a/scripts/help/help.m
+++ b/scripts/help/help.m
@@ -179,8 +179,9 @@ function do_contents (name)
   endif
 
 endfunction
 
 
 %!assert (! isempty (strfind (help ("ls"), "List directory contents")))
 %!error <invalid input> help (42)
 
+
diff --git a/scripts/help/type.m b/scripts/help/type.m
--- a/scripts/help/type.m
+++ b/scripts/help/type.m
@@ -106,19 +106,21 @@ function retval = type (varargin)
     if (nargout == 0)
       disp (text);
     else
       retval {n} = text;
     endif
   endfor
 endfunction
 
+
 %!test
 %! var = 1;
 %! typestr = type ("var");
 %! typestr = typestr{1}(1:17);
 %! assert (typestr, "var is a variable");
 
-%!assert (type ('dot'){1}, "dot is a dynamically-linked function")
-%!assert (type ('cat'){1}, "cat is a built-in function")
-%!assert (type ('+'){1}, "+ is an operator")
-%!assert (type ('end'){1}, "end is a keyword")
+%!assert (type ("dot"){1}, "dot is a dynamically-linked function")
+%!assert (type ("cat"){1}, "cat is a built-in function")
+%!assert (type ("+"){1}, "+ is an operator")
+%!assert (type ("end"){1}, "end is a keyword")
 %!error (type ('NO_NAME'))
+ 
diff --git a/scripts/help/unimplemented.m b/scripts/help/unimplemented.m
--- a/scripts/help/unimplemented.m
+++ b/scripts/help/unimplemented.m
@@ -424,10 +424,9 @@ endfunction
 
 %!test
 %! str = unimplemented ("no_name_function");
 %! assert (isempty (str));
 %! str = unimplemented ("quad2d");
 %! assert (str(1:51), "quad2d is not implemented.  Consider using dblquad.");
 %! str = unimplemented ("MException");
 %! assert (str(1:58), "the `MException' function is not yet implemented in Octave");
-
-
+ 
diff --git a/scripts/help/which.m b/scripts/help/which.m
--- a/scripts/help/which.m
+++ b/scripts/help/which.m
@@ -57,9 +57,10 @@ endfunction
 
 %!test
 %! str = which ("ls");
 %! assert (str(end-17:end), strcat ("miscellaneous", filesep(), "ls.m"));
 %!test
 %! str = which ("dot");
 %! assert (str(end-6:end), "dot.oct");
 
-%!assert (which ("NO_NAME"), "");
+%!assert (which ("_NO_SUCH_NAME_"), "")
+
diff --git a/scripts/image/imread.m b/scripts/image/imread.m
--- a/scripts/image/imread.m
+++ b/scripts/image/imread.m
@@ -84,16 +84,17 @@ function varargout = imread (filename, v
     else
       error ("imread: invalid Octave image file format");
     endif
 
   end_try_catch
 
 endfunction
 
+
 %!testif HAVE_MAGICK
 %! vpng = [ ...
 %!  137,  80,  78,  71,  13,  10,  26,  10,   0,   0, ...
 %!    0,  13,  73,  72,  68,  82,   0,   0,   0,   3, ...
 %!    0,   0,   0,   3,   8,   2,   0,   0,   0, 217, ...
 %!   74,  34, 232,   0,   0,   0,   1, 115,  82,  71, ...
 %!   66,   0, 174, 206,  28, 233,   0,   0,   0,   4, ...
 %!  103,  65,  77,  65,   0,   0, 177, 143,  11, 252, ...
@@ -102,16 +103,17 @@ endfunction
 %!  250,   0,   0,   0, 128, 232,   0,   0, 117,  48, ...
 %!    0,   0, 234,  96,   0,   0,  58, 152,   0,   0, ...
 %!   23, 112, 156, 186,  81,  60,   0,   0,   0,  25, ...
 %!   73,  68,  65,  84,  24,  87,  99,  96,  96,  96, ...
 %!  248, 255, 255,  63, 144,   4,  81, 111, 101,  84, ...
 %!   16,  28, 160,  16,   0, 197, 214,  13,  34,  74, ...
 %!  117, 213,  17,   0,   0,   0,   0,  73,  69,  78, ...
 %!   68, 174,  66,  96, 130];
-%! fid = fopen('test.png', 'wb');
-%! fwrite(fid, vpng);
-%! fclose(fid);
-%! A = imread('test.png');
-%! delete('test.png');
-%! assert(A(:,:,1), uint8 ([0, 255, 0; 255, 237, 255; 0, 255, 0]));
-%! assert(A(:,:,2), uint8 ([0, 255, 0; 255,  28, 255; 0, 255, 0]));
-%! assert(A(:,:,3), uint8 ([0, 255, 0; 255,  36, 255; 0, 255, 0]));
+%! fid = fopen ("test.png", "wb");
+%! fwrite (fid, vpng);
+%! fclose (fid);
+%! A = imread ("test.png");
+%! delete ("test.png");
+%! assert (A(:,:,1), uint8 ([0, 255, 0; 255, 237, 255; 0, 255, 0]));
+%! assert (A(:,:,2), uint8 ([0, 255, 0; 255,  28, 255; 0, 255, 0]));
+%! assert (A(:,:,3), uint8 ([0, 255, 0; 255,  36, 255; 0, 255, 0]));
+
diff --git a/scripts/image/imwrite.m b/scripts/image/imwrite.m
--- a/scripts/image/imwrite.m
+++ b/scripts/image/imwrite.m
@@ -182,19 +182,20 @@ function imwrite (img, varargin)
     else
       __magick_write__ (filename, fmt, tmp);
       ## __magick_write__ (filename, fmt, img, map);
     endif
   endif
 
 endfunction
 
+
 %% Test input validation
-%!error imwrite ()                           # Wrong # of args
-%!error imwrite (1)                          # Wrong # of args
-%!error imwrite ({"cell"}, "filename.jpg")   # Wrong class for img
-%!error imwrite (1, [], "filename.jpg")      # Empty image map
-%!error imwrite (1, 2, 3)                    # No filename specified
-%!error imwrite (1, "filename")              # No fmt specified
-%!error imwrite (1, "filename", "junk")      # Invalid fmt specified
-%!error imwrite ([], "filename.jpg")         # Empty img matrix
-%!error imwrite (spones(2), "filename.jpg")  # Invalid sparse img
+%!error imwrite ()                            # Wrong # of args
+%!error imwrite (1)                           # Wrong # of args
+%!error imwrite ({"cell"}, "filename.jpg")    # Wrong class for img
+%!error imwrite (1, [], "filename.jpg")       # Empty image map
+%!error imwrite (1, 2, 3)                     # No filename specified
+%!error imwrite (1, "filename")               # No fmt specified
+%!error imwrite (1, "filename", "junk")       # Invalid fmt specified
+%!error imwrite ([], "filename.jpg")          # Empty img matrix
+%!error imwrite (spones (2), "filename.jpg")  # Invalid sparse img
 
diff --git a/scripts/io/dlmwrite.m b/scripts/io/dlmwrite.m
--- a/scripts/io/dlmwrite.m
+++ b/scripts/io/dlmwrite.m
@@ -192,21 +192,21 @@ function dlmwrite (file, M, varargin)
     endif
   endif
 
 endfunction
 
 
 %!test
 %! f = tmpnam ();
-%! dlmwrite (f,[1,2;3,4],'precision','%5.2f','newline','unix','roffset',1,'coffset',1);
+%! dlmwrite (f,[1,2;3,4],"precision","%5.2f","newline","unix","roffset",1,"coffset",1);
 %! fid = fopen (f,"rt");
-%! f1 = char (fread (fid,Inf,'char')');
+%! f1 = char (fread (fid,Inf,"char")');
 %! fclose (fid);
-%! dlmwrite (f,[5,6],'precision','%5.2f','newline','unix','coffset',1,'delimiter',',','-append');
+%! dlmwrite (f,[5,6],"precision","%5.2f","newline","unix","coffset",1,"delimiter",",","-append");
 %! fid = fopen (f,"rt");
-%! f2 = char (fread (fid,Inf,'char')');
+%! f2 = char (fread (fid,Inf,"char")');
 %! fclose (fid);
 %! unlink (f);
 %!
 %! assert (f1,",,\n, 1.00, 2.00\n, 3.00, 4.00\n");
 %! assert (f2,",,\n, 1.00, 2.00\n, 3.00, 4.00\n, 5.00, 6.00\n");
 
diff --git a/scripts/io/fileread.m b/scripts/io/fileread.m
--- a/scripts/io/fileread.m
+++ b/scripts/io/fileread.m
@@ -45,17 +45,17 @@ function str = fileread (filename)
 
 endfunction
 
 
 %!test
 %! cstr = {"Hello World", "The answer is 42", "Goodbye World"};
 %! fname = tmpnam ();
 %! fid = fopen (fname, "w");
-%! fprintf (fid, "%s\n", cstr{:})
+%! fprintf (fid, "%s\n", cstr{:});
 %! fclose (fid);
 %! str = fileread (fname);
 %! assert (str', [cstr{1} "\n" cstr{2} "\n" cstr{3} "\n"]);
 %! unlink (fname);
 
 %% Test input validation
 %!error fileread ()
 %!error fileread (1, 2)
diff --git a/scripts/io/is_valid_file_id.m b/scripts/io/is_valid_file_id.m
--- a/scripts/io/is_valid_file_id.m
+++ b/scripts/io/is_valid_file_id.m
@@ -34,13 +34,15 @@ function retval = is_valid_file_id (fid)
       endif
     end_try_catch
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!assert (is_valid_file_id (stdout))
 %!assert (! is_valid_file_id ([1,2;3,4]))
 %!assert (! is_valid_file_id ("not_a_file_id"))
 %!assert (! is_valid_file_id (-1))
 %!assert (! is_valid_file_id (pi))
+
diff --git a/scripts/io/strread.m b/scripts/io/strread.m
--- a/scripts/io/strread.m
+++ b/scripts/io/strread.m
@@ -732,39 +732,39 @@ endfunction
 
 
 %!test
 %! [a, b] = strread ("1 2", "%f%f");
 %! assert (a, 1);
 %! assert (b, 2);
 
 %!test
-%! str = '';
+%! str = "";
 %! a = rand (10, 1);
 %! b = char (randi ([65, 85], 10, 1));
 %! for k = 1:10
 %!   str = sprintf ('%s %.6f %s\n', str, a(k), b(k));
 %! endfor
-%! [aa, bb] = strread (str, '%f %s');
+%! [aa, bb] = strread (str, "%f %s");
 %! assert (a, aa, 1e-6);
 %! assert (cellstr (b), bb);
 
 %!test
-%! str = '';
+%! str = "";
 %! a = rand (10, 1);
 %! b = char (randi ([65, 85], 10, 1));
 %! for k = 1:10
 %!   str = sprintf ('%s %.6f %s\n', str, a(k), b(k));
 %! endfor
-%! aa = strread (str, '%f %*s');
+%! aa = strread (str, "%f %*s");
 %! assert (a, aa, 1e-6);
 
 %!test
 %! str = sprintf ('/* this is\nacomment*/ 1 2 3');
-%! a = strread (str, '%f', 'commentstyle', 'c');
+%! a = strread (str, "%f", "commentstyle", "c");
 %! assert (a, [1; 2; 3]);
 
 %!test
 %! str = "# comment\n# comment\n1 2 3";
 %! [a, b] = strread (str, '%n %s', 'commentstyle', 'shell', 'endofline', "\n");
 %! assert (a, [1; 3]);
 %! assert (b, {"2"});
 
@@ -778,70 +778,70 @@ endfunction
 
 %!test
 %! a = strread ("a b c, d e, , f", "%s", "delimiter", ",");
 %! assert (a, {"a b c"; "d e"; ""; "f"});
 
 %!test
 %! # Bug #33536
 %! [a, b, c] = strread ("1,,2", "%s%s%s", "delimiter", ",");
-%! assert (a{1}, '1');
-%! assert (b{1}, '');
-%! assert (c{1}, '2');
+%! assert (a{1}, "1");
+%! assert (b{1}, "");
+%! assert (c{1}, "2");
 
 %!test
 %! # Bug #33536
 %! a = strread ("[SomeText]", "[%s", "delimiter", "]");
 %! assert (a{1}, "SomeText");
 
 %!test
 %! dat = "Data file.\r\n=  =  =  =  =\r\nCOMPANY    : <Company name>\r\n";
-%! a = strread (dat, "%s", 'delimiter', "\n", 'whitespace', '', 'endofline', "\r\n");
+%! a = strread (dat, "%s", "delimiter", "\n", "whitespace", "", "endofline", "\r\n");
 %! assert (a{2}, "=  =  =  =  =");
 %! assert (double (a{3}(end-5:end)), [32 110 97 109 101 62]);
 
 %!test
-%! [a, b, c, d] = strread ("1,2,3,,5,6", "%d%f%d%f", 'delimiter', ',');
+%! [a, b, c, d] = strread ("1,2,3,,5,6", "%d%f%d%f", "delimiter", ",");
 %! assert (c, int32 (3));
 %! assert (d, NaN);
 
 %!test
-%! [a, b, c, d] = strread ("1,2,3,,5,6\n", "%d%d%f%d", 'delimiter', ',');
+%! [a, b, c, d] = strread ("1,2,3,,5,6\n", "%d%d%f%d", "delimiter", ",");
 %! assert (c, [3; NaN]);
 %! assert (d, int32 ([0; 0]));
 
 %!test
 %! # Default format (= %f)
 %1 [a, b, c] = strread ("0.12 0.234 0.3567");
 %1 assert (a, 0.12);
 %1 assert (b, 0.234);
 %1 assert (c, 0.3567);
 
 %!test
-%! [a, b] = strread('0.41 8.24 3.57 6.24 9.27', "%f%f", 2, 'delimiter', ' ');
+%! [a, b] = strread ("0.41 8.24 3.57 6.24 9.27", "%f%f", 2, "delimiter", " ");
 %1 assert (a, [0.41; 3.57]);
 
 %!test
 %! # TreatAsEmpty
-%! [a, b, c, d] = strread ("1,2,3,NN,5,6\n", "%d%d%d%f", 'delimiter', ',', 'TreatAsEmpty', 'NN');
+%! [a, b, c, d] = strread ("1,2,3,NN,5,6\n", "%d%d%d%f", "delimiter", ",", "TreatAsEmpty", "NN");
 %! assert (c, int32 ([3; 0]));
 %! assert (d, [NaN; NaN]);
 
 %!test
 %! # No delimiters at all besides EOL.  Plain reading numbers & strings
 %! str = "Text1Text2Text\nText398Text4Text\nText57Text";
 %! [a, b] = strread (str, "Text%dText%1sText");
 %! assert (a, int32 ([1; 398; 57]));
-%! assert (b(1:2), {'2'; '4'});
+%! assert (b(1:2), {"2"; "4"});
 %! assert (isempty (b{3}), true);
 
 %% MultipleDelimsAsOne
 %!test
 %! str = "11, 12, 13,, 15\n21,, 23, 24, 25\n,, 33, 34, 35";
-%! [a b c d] = strread (str, "%f %f %f %f", 'delimiter', ',', 'multipledelimsasone', 1, 'endofline', "\n");
+%! [a b c d] = strread (str, "%f %f %f %f", "delimiter", ",", "multipledelimsasone", 1, "endofline", "\n");
 %! assert (a', [11, 21, NaN]);
 %! assert (b', [12, 23, 33]);
 %! assert (c', [13, 24, 34]);
 %! assert (d', [15, 25, 35]);
 
 %% delimiter as sq_string and dq_string
 %!test
 %! assert (strread ("1\n2\n3", "%d", "delimiter", "\n"),
@@ -882,8 +882,9 @@ endfunction
 %!test
 %! str =  "0.31, 0.86, 0.94\n 0.60, 0.72, 0.87";
 %! fmt = "%f %f %f";
 %! args = {"delimiter", ",", "endofline", "\n", "whitespace", " "};
 %! [a, b, c] = strread (str, fmt, args {:});
 %! assert (a, [0.31; 0.60], 0.01)
 %! assert (b, [0.86; 0.72], 0.01)
 %! assert (c, [0.94; 0.87], 0.01)
+
diff --git a/scripts/io/textread.m b/scripts/io/textread.m
--- a/scripts/io/textread.m
+++ b/scripts/io/textread.m
@@ -126,23 +126,23 @@ function varargout = textread (filename,
 
   ## Call strread to make it do the real work
   [varargout{1:max (nargout, 1)}] = strread (str, format, varargin {:});
 
 endfunction
 
 
 %!test
-%! f = tmpnam();
+%! f = tmpnam ();
 %! d = rand (5, 3);
-%! dlmwrite (f, d, 'precision', '%5.2f');
+%! dlmwrite (f, d, "precision", "%5.2f");
 %! [a, b, c] = textread (f, "%f %f %f", "delimiter", ",", "headerlines", 3);
-%! unlink(f);
+%! unlink (f);
 %! assert (a, d(4:5, 1), 1e-2);
 %! assert (b, d(4:5, 2), 1e-2);
 %! assert (c, d(4:5, 3), 1e-2);
 
 %% Test input validation
 %!error textread ()
 %!error textread (1)
-%!error <arguments must be strings> textread (1, '%f')
+%!error <arguments must be strings> textread (1, "%f")
 %!error <arguments must be strings> textread ("fname", 1)
 
diff --git a/scripts/io/textscan.m b/scripts/io/textscan.m
--- a/scripts/io/textscan.m
+++ b/scripts/io/textscan.m
@@ -250,16 +250,17 @@ function C = colloutp (C)
     else
       ## No similar class in column to the left, search from there
       --ii;
     endif
   endwhile
 
 endfunction
 
+
 %!test
 %! str = "1,  2,  3,  4\n 5,  ,  ,  8\n 9, 10, 11, 12";
 %! fmtstr = "%f %d %f %s";
 %! c = textscan (str, fmtstr, 2, "delimiter", ",", "emptyvalue", -Inf);
 %! assert (isequal (c{1}, [1;5]));
 %! assert (length (c{1}), 2);
 %! assert (iscellstr (c{4}));
 %! assert (isequal (c{3}, [3; -Inf]));
@@ -270,57 +271,57 @@ endfunction
 %! str = sprintf ("%g miles/hr = %g kilometers/hr\n", b);
 %! fmt = "%f miles/hr = %f kilometers/hr";
 %! c = textscan (str, fmt);
 %! assert (b(1,:)', c{1}, 1e-5);
 %! assert (b(2,:)', c{2}, 1e-5);
 
 #%!test
 #%! str = "13, 72, NA, str1, 25\r\n// Middle line\r\n36, na, 05, str3, 6";
-#%! a = textscan(str, '%d %n %f %s %n', 'delimiter', ',','treatAsEmpty', {'NA', 'na'},'commentStyle', '//');
+#%! a = textscan (str, "%d %n %f %s %n", "delimiter", ",","treatAsEmpty", {"NA", "na"},"commentStyle", "//");
 #%! assert (a{1}, int32([13; 36]));
 #%! assert (a{2}, [72; NaN]);
 #%! assert (a{3}, [NaN; 5]);
 #%! assert (a{4}, {"str1"; "str3"});
 #%! assert (a{5}, [25; 6]);
 
 %!test
 %! str = "Km:10 = hhhBjjj miles16hour\r\n";
 %! str = [str "Km:15 = hhhJjjj miles241hour\r\n"];
 %! str = [str "Km:2 = hhhRjjj miles3hour\r\n"];
 %! str = [str "Km:25 = hhhZ\r\n"];
 %! fmt = "Km:%d = hhh%1sjjj miles%dhour";
-%! a = textscan (str, fmt, 'delimiter', ' ');
+%! a = textscan (str, fmt, "delimiter", " ");
 %! assert (a{1}', int32([10 15 2 25]));
 %! assert (a{2}', {'B' 'J' 'R' 'Z'});
 %! assert (a{3}', int32([16 241 3 0]));
 
 %% Test with default endofline parameter
 %!test
 %! c = textscan ("L1\nL2", "%s");
 %! assert (c{:}, {"L1"; "L2"});
 
-%% Test with endofline parameter set to '' (empty) - newline should be in word
+%% Test with endofline parameter set to "" (empty) - newline should be in word
 %!test
-%! c = textscan ("L1\nL2", "%s", 'endofline', '');
+%! c = textscan ("L1\nL2", "%s", "endofline", "");
 %! assert (int8(c{:}{:}), int8([ 76,  49,  10,  76,  50 ]));
 
 %!test
 %! # No delimiters at all besides EOL.  Skip fields, even empty fields
 %! str = "Text1Text2Text\nTextText4Text\nText57Text";
 %! c = textscan (str, "Text%*dText%dText");
 %! assert (c{1}, int32 ([2; 4; 0]));
 
 %!test
 %% CollectOutput test
 %! b = [10:10:100];
 %! b = [b; 8*b/5; 8*b*1000/5];
 %! str = sprintf ("%g miles/hr = %g (%g) kilometers (meters)/hr\n", b);
 %! fmt = "%f miles%s %s %f (%f) kilometers %*s";
-%! c = textscan (str, fmt, 'collectoutput', 1);
+%! c = textscan (str, fmt, "collectoutput", 1);
 %! assert (size(c{3}), [10, 2]);
 %! assert (size(c{2}), [10, 2]);
 
 %% Test input validation
 %!error textscan ()
 %!error textscan (single (4))
 %!error textscan ({4})
 %!error <must be a string> textscan ("Hello World", 2)
diff --git a/scripts/linear-algebra/commutation_matrix.m b/scripts/linear-algebra/commutation_matrix.m
--- a/scripts/linear-algebra/commutation_matrix.m
+++ b/scripts/linear-algebra/commutation_matrix.m
@@ -91,29 +91,31 @@ function k = commutation_matrix (m, n)
   for i = 1 : m
     for j = 1 : n
       k ((i - 1) * n + j, (j - 1) * m + i) = 1;
     endfor
   endfor
 
 endfunction
 
+
 %!test
-%! c = commutation_matrix(1,1);
-%! assert(c,1);
+%! c = commutation_matrix (1,1);
+%! assert (c,1);
 
 %!test
-%! A = rand(3,5);
-%! vc = vec(A);
-%! vr = vec(A');
-%! c = commutation_matrix(3,5);
-%! assert(c*vc,vr);
+%! A = rand (3,5);
+%! vc = vec (A);
+%! vr = vec (A');
+%! c = commutation_matrix (3,5);
+%! assert (c*vc, vr);
 
 %!test
-%! A = rand(4,6);
-%! vc = vec(A);
-%! vr = vec(A');
-%! c = commutation_matrix(4,6);
-%! assert(c*vc,vr);
+%! A = rand (4,6);
+%! vc = vec (A);
+%! vr = vec (A');
+%! c = commutation_matrix (4,6);
+%! assert (c*vc, vr);
 
-%!error commutation_matrix(0,0);
-%!error commutation_matrix(1,0);
-%!error commutation_matrix(0,1);
+%!error <M must be a positive integer> commutation_matrix (0,0)
+%!error <N must be a positive integer> commutation_matrix (1,0)
+%!error <M must be a positive integer> commutation_matrix (0,1)
+
diff --git a/scripts/linear-algebra/cond.m b/scripts/linear-algebra/cond.m
--- a/scripts/linear-algebra/cond.m
+++ b/scripts/linear-algebra/cond.m
@@ -69,25 +69,24 @@ function retval = cond (A, p)
       retval = norm (A, p) * norm (inv (A), p);
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!test
-%! y= [7, 2, 3; 1, 3, 4; 6, 4, 5];
+%! y = [7, 2, 3; 1, 3, 4; 6, 4, 5];
 %! tol = 1e-6;
-%! type = {1, 2, 'fro', 'inf', inf};
-%! for n = 1:numel(type)
+%! type = {1, 2, "fro", "inf", inf};
+%! for n = 1:numel (type)
 %!   rcondition(n) = 1 / cond (y, type{n});
 %! endfor
 %! assert (rcondition, [0.017460, 0.019597, 0.018714, 0.012022, 0.012022], tol);
 
-%!assert (abs (cond ([1, 2; 2, 1]) - 3) < sqrt (eps));
-
-%!assert (cond ([1, 2, 3; 4, 5, 6; 7, 8, 9]) > 1.0e+16);
+%!assert (cond ([1, 2; 2, 1]), 3, sqrt (eps))
+%!assert (cond ([1, 2, 3; 4, 5, 6; 7, 8, 9]) > 1.0e+16)
 
-%!error cond ();
+%!error cond ()
+%!error cond (1, 2, 3)
 
-%!error cond (1, 2, 3);
-
diff --git a/scripts/linear-algebra/condest.m b/scripts/linear-algebra/condest.m
--- a/scripts/linear-algebra/condest.m
+++ b/scripts/linear-algebra/condest.m
@@ -231,9 +231,10 @@ endfunction
 %! cA_test = norm (inv (A), 1) * norm (A, 1);
 %! assert (cA, cA_test, -2^-6);
 
 %!test
 %! N = 12;
 %! A = hilb (N);
 %! [rcondA, v] = condest (A);
 %! x = A*v;
-%! assert (norm(x, inf), 0, eps);
+%! assert (norm (x, inf), 0, eps);
+
diff --git a/scripts/linear-algebra/cross.m b/scripts/linear-algebra/cross.m
--- a/scripts/linear-algebra/cross.m
+++ b/scripts/linear-algebra/cross.m
@@ -86,30 +86,31 @@ function z = cross (x, y, dim)
     y3 = y(idx3{:});
     z = cat (dim, (x2.*y3 - x3.*y2), (x3.*y1 - x1.*y3), (x1.*y2 - x2.*y1));
   else
     error ("cross: X and Y must have the same dimensions");
   endif
 
 endfunction
 
+
 %!test
 %! x = [1 0 0];
 %! y = [0 1 0];
 %! r = [0 0 1];
-%! assert(cross(x, y), r, 2e-8);
+%! assert (cross (x, y), r, 2e-8);
 
 %!test
 %! x = [1 2 3];
 %! y = [4 5 6];
 %! r = [(2*6-3*5) (3*4-1*6) (1*5-2*4)];
-%! assert(cross(x, y), r, 2e-8);
+%! assert (cross (x, y), r, 2e-8);
 
 %!test
 %! x = [1 0 0; 0 1 0; 0 0 1];
 %! y = [0 1 0; 0 0 1; 1 0 0];
 %! r = [0 0 1; 1 0 0; 0 1 0];
-%! assert(cross(x, y, 2), r, 2e-8);
-%! assert(cross(x, y, 1), -r, 2e-8);
+%! assert (cross (x, y, 2), r, 2e-8);
+%! assert (cross (x, y, 1), -r, 2e-8);
 
-%!error cross(0,0);
-%!error cross();
+%!error cross (0,0)
+%!error cross ()
 
diff --git a/scripts/linear-algebra/duplication_matrix.m b/scripts/linear-algebra/duplication_matrix.m
--- a/scripts/linear-algebra/duplication_matrix.m
+++ b/scripts/linear-algebra/duplication_matrix.m
@@ -82,39 +82,41 @@ function d = duplication_matrix (n)
       d ((j - 1) * n + i, count + i) = 1;
       d ((i - 1) * n + j, count + i) = 1;
     endfor
     count = count + n - j;
   endfor
 
 endfunction
 
+
 %!test
 %! N = 2;
-%! A = rand(N);
+%! A = rand (N);
 %! B = A * A';
 %! C = A + A';
 %! D = duplication_matrix (N);
 %! assert (D * vech (B), vec (B), 1e-6);
 %! assert (D * vech (C), vec (C), 1e-6);
 
 %!test
 %! N = 3;
-%! A = rand(N);
+%! A = rand (N);
 %! B = A * A';
 %! C = A + A';
 %! D = duplication_matrix (N);
 %! assert (D * vech (B), vec (B), 1e-6);
 %! assert (D * vech (C), vec (C), 1e-6);
 
 %!test
 %! N = 4;
-%! A = rand(N);
+%! A = rand (N);
 %! B = A * A';
 %! C = A + A';
 %! D = duplication_matrix (N);
 %! assert (D * vech (B), vec (B), 1e-6);
 %! assert (D * vech (C), vec (C), 1e-6);
 
-%!error duplication_matrix ();
-%!error duplication_matrix (0.5);
-%!error duplication_matrix (-1);
-%!error duplication_matrix (ones(1,4));
+%!error duplication_matrix ()
+%!error duplication_matrix (0.5)
+%!error duplication_matrix (-1)
+%!error duplication_matrix (ones (1,4))
+
diff --git a/scripts/linear-algebra/expm.m b/scripts/linear-algebra/expm.m
--- a/scripts/linear-algebra/expm.m
+++ b/scripts/linear-algebra/expm.m
@@ -136,19 +136,21 @@ function r = expm (A)
   r(p, p) = r;
   ## Inverse trace reduction.
   if (trshift >0)
     r *= exp (trshift);
   endif
 
 endfunction
 
-%!assert(norm(expm([1 -1;0 1]) - [e -e; 0 e]) < 1e-5);
-%!assert(expm([1 -1 -1;0 1 -1; 0 0 1]), [e -e -e/2; 0 e -e; 0 0 e], 1e-5);
 
-%% Test input validation
-%!error expm ();
-%!error expm (1, 2);
-%!error <expm: A must be a square matrix> expm([1 0;0 1; 2 2]);
+%!assert (norm (expm ([1 -1;0 1]) - [e -e; 0 e]) < 1e-5);
+%!assert (expm ([1 -1 -1;0 1 -1; 0 0 1]), [e -e -e/2; 0 e -e; 0 0 e], 1e-5);
 
 %!assert (expm (10), expm (10))
 %!assert (full (expm (eye (3))), expm (full (eye (3))))
 %!assert (full (expm (10*eye (3))), expm (full (10*eye (3))), 8*eps)
+
+%% Test input validation
+%!error expm ()
+%!error expm (1, 2)
+%!error <expm: A must be a square matrix> expm ([1 0;0 1; 2 2])
+
diff --git a/scripts/linear-algebra/housh.m b/scripts/linear-algebra/housh.m
--- a/scripts/linear-algebra/housh.m
+++ b/scripts/linear-algebra/housh.m
@@ -87,47 +87,48 @@ function [housv, beta, zer] = housh (x, 
     else
       beta = 0.0;
     endif
     zer = (beta == 0);
   endif
 
 endfunction
 
+
 %!test
 %! x = [1 2 3]';
 %! j = 3;
-%! [hv, b, z] = housh(x, j, 0);
-%! r = (eye(3) - b*hv*hv') * x;
-%! d = - norm(x) * [0 0 1]';
-%! assert(r, d, 2e-8);
-%! assert(z, 0, 2e-8);
+%! [hv, b, z] = housh (x, j, 0);
+%! r = (eye (3) - b*hv*hv') * x;
+%! d = - norm (x) * [0 0 1]';
+%! assert (r, d, 2e-8);
+%! assert (z, 0, 2e-8);
 
 %!test
 %! x = [7 -3 1]';
 %! j = 2;
-%! [hv, b, z] = housh(x, j, 0);
-%! r = (eye(3) - b*hv*hv') * x;
-%! d = norm(x) * [0 1 0]';
-%! assert(r, d, 2e-8);
-%! assert(z, 0, 2e-8);
+%! [hv, b, z] = housh (x, j, 0);
+%! r = (eye (3) - b*hv*hv') * x;
+%! d = norm (x) * [0 1 0]';
+%! assert (r, d, 2e-8);
+%! assert (z, 0, 2e-8);
 
 %!test
 %! x = [1 0 0]';
 %! j = 1;
-%! [hv, b, z] = housh(x, j, 10);
-%! r = (eye(3) - b*hv*hv') * x;
-%! d = norm(x) * [1 0 0]';
-%! assert(r, d, 2e-8);
-%! assert(z, 1, 2e-8);
+%! [hv, b, z] = housh (x, j, 10);
+%! r = (eye (3) - b*hv*hv') * x;
+%! d = norm (x) * [1 0 0]';
+%! assert (r, d, 2e-8);
+%! assert (z, 1, 2e-8);
 
 %!test
 %! x = [5 0 4 1]';
 %! j = 2;
-%! [hv, b, z] = housh(x, j, 0);
-%! r = (eye(4) - b*hv*hv') * x;
-%! d = - norm(x) * [0 1 0 0]';
-%! assert(r, d, 2e-8);
-%! assert(z, 0, 2e-8);
+%! [hv, b, z] = housh (x, j, 0);
+%! r = (eye (4) - b*hv*hv') * x;
+%! d = - norm (x) * [0 1 0 0]';
+%! assert (r, d, 2e-8);
+%! assert (z, 0, 2e-8);
 
-%!error housh([0]);
-%!error housh();
+%!error housh ([0])
+%!error housh ()
 
diff --git a/scripts/linear-algebra/isdefinite.m b/scripts/linear-algebra/isdefinite.m
--- a/scripts/linear-algebra/isdefinite.m
+++ b/scripts/linear-algebra/isdefinite.m
@@ -62,26 +62,26 @@ function retval = isdefinite (x, tol)
     endif
   endif
 
 endfunction
 
 
 %!test
 %! A = [-1 0; 0 -1];
-%! assert (isdefinite (A), -1)
+%! assert (isdefinite (A), -1);
 
 %!test
 %! A = [1 0; 0 1];
-%! assert (isdefinite (A), 1)
+%! assert (isdefinite (A), 1);
 
 %!test
 %! A = [2 -1 0; -1 2 -1; 0 -1 2];
-%! assert (isdefinite (A), 1)
+%! assert (isdefinite (A), 1);
 
 %!test
 %! A = [1 0; 0 0];
-%! assert (isdefinite (A), 0)
+%! assert (isdefinite (A), 0);
 
 %!error isdefinite ()
 %!error isdefinite (1,2,3)
 %!error <X must be a Hermitian matrix> isdefinite ([1 2; 3 4])
 
diff --git a/scripts/linear-algebra/ishermitian.m b/scripts/linear-algebra/ishermitian.m
--- a/scripts/linear-algebra/ishermitian.m
+++ b/scripts/linear-algebra/ishermitian.m
@@ -45,23 +45,26 @@ function retval = ishermitian (x, tol = 
     else
       norm_x = norm (x, inf);
       retval = norm_x == 0 || norm (x - x', inf) / norm_x <= tol;
     endif
   endif
 
 endfunction
 
-%!assert(ishermitian (1));
-%!assert(!(ishermitian ([1, 2])));
-%!assert(ishermitian ([]));
-%!assert(ishermitian ([1, 2; 2, 1]));
-%!assert(!(ishermitian ("test")));
-%!assert(ishermitian ([1, 2.1; 2, 1.1], 0.2));
-%!assert(ishermitian ([1, -2i; 2i, 1]));
-%!assert(!(ishermitian ("t")));
-%!assert(!(ishermitian (["te"; "et"])));
-%!error ishermitian ([1, 2; 2, 1], 0, 0);
-%!error ishermitian ();
+
+%!assert (ishermitian (1))
+%!assert (! ishermitian ([1, 2]))
+%!assert (ishermitian ([]))
+%!assert (ishermitian ([1, 2; 2, 1]))
+%!assert (! ishermitian ("test"))
+%!assert (ishermitian ([1, 2.1; 2, 1.1], 0.2))
+%!assert (ishermitian ([1, -2i; 2i, 1]))
+%!assert (! ishermitian ("t"))
+%!assert (! ishermitian (["te"; "et"]))
 
 %!test
 %! s.a = 1;
-%! assert(!(ishermitian (s)));
+%! assert(! ishermitian (s));
+
+%!error ishermitian ([1, 2; 2, 1], 0, 0)
+%!error ishermitian ()
+
diff --git a/scripts/linear-algebra/issymmetric.m b/scripts/linear-algebra/issymmetric.m
--- a/scripts/linear-algebra/issymmetric.m
+++ b/scripts/linear-algebra/issymmetric.m
@@ -44,23 +44,26 @@ function retval = issymmetric (x, tol = 
     else
       norm_x = norm (x, inf);
       retval = norm_x == 0 || norm (x - x.', inf) / norm_x <= tol;
     endif
   endif
 
 endfunction
 
-%!assert(issymmetric (1));
-%!assert(!(issymmetric ([1, 2])));
-%!assert(issymmetric ([]));
-%!assert(issymmetric ([1, 2; 2, 1]));
-%!assert(!(issymmetric ("test")));
-%!assert(issymmetric ([1, 2.1; 2, 1.1], 0.2));
-%!assert(issymmetric ([1, 2i; 2i, 1]));
-%!assert(!(issymmetric ("t")));
-%!assert(!(issymmetric (["te"; "et"])));
-%!error issymmetric ([1, 2; 2, 1], 0, 0);
-%!error issymmetric ();
+
+%!assert (issymmetric (1))
+%!assert (! issymmetric ([1, 2]))
+%!assert (issymmetric ([]))
+%!assert (issymmetric ([1, 2; 2, 1]))
+%!assert (! (issymmetric ("test")))
+%!assert (issymmetric ([1, 2.1; 2, 1.1], 0.2))
+%!assert (issymmetric ([1, 2i; 2i, 1]))
+%!assert (! (issymmetric ("t")))
+%!assert (! (issymmetric (["te"; "et"])))
 
 %!test
 %! s.a = 1;
-%! assert(!(issymmetric (s)));
+%! assert(! issymmetric (s));
+
+%!error issymmetric ([1, 2; 2, 1], 0, 0)
+%!error issymmetric ()
+
diff --git a/scripts/linear-algebra/logm.m b/scripts/linear-algebra/logm.m
--- a/scripts/linear-algebra/logm.m
+++ b/scripts/linear-algebra/logm.m
@@ -151,20 +151,20 @@ function [x, w] = gauss_legendre (n)
   i = 1:n-1;
   v = i./sqrt ((2*i).^2-1);
   [V, D] = eig (diag (v, -1) + diag (v, 1));
   x = diag (D);
   w = 2*(V(1,:)'.^2);
 endfunction
 
 
-%!assert(norm(logm([1 -1;0 1]) - [0 -1; 0 0]) < 1e-5);
-%!assert(norm(expm(logm([-1 2 ; 4 -1])) - [-1 2 ; 4 -1]) < 1e-5);
-%!assert(logm([1 -1 -1;0 1 -1; 0 0 1]), [0 -1 -1.5; 0 0 -1; 0 0 0], 1e-5);
-
-%% Test input validation
-%!error logm ();
-%!error logm (1, 2, 3);
-%!error <logm: A must be a square matrix> logm([1 0;0 1; 2 2]);
-
+%!assert (norm (logm ([1 -1;0 1]) - [0 -1; 0 0]) < 1e-5)
+%!assert (norm (expm (logm ([-1 2 ; 4 -1])) - [-1 2 ; 4 -1]) < 1e-5)
+%!assert (logm ([1 -1 -1;0 1 -1; 0 0 1]), [0 -1 -1.5; 0 0 -1; 0 0 0], 1e-5)
 %!assert (logm (10), log (10))
 %!assert (full (logm (eye (3))), logm (full (eye (3))))
 %!assert (full (logm (10*eye (3))), logm (full (10*eye (3))), 8*eps)
+
+%% Test input validation
+%!error logm ()
+%!error logm (1, 2, 3)
+%!error <logm: A must be a square matrix> logm ([1 0;0 1; 2 2])
+
diff --git a/scripts/linear-algebra/normest.m b/scripts/linear-algebra/normest.m
--- a/scripts/linear-algebra/normest.m
+++ b/scripts/linear-algebra/normest.m
@@ -70,23 +70,24 @@ function [n, c] = normest (A, tol = 1e-6
     y = A' * x;
     n = norm (y);
     c += 1;
   until (abs (n - n0) <= tol * n)
 
   rand ("state", v);    # restore state of random number generator
 endfunction
 
+
 %!test
 %! A = toeplitz ([-2,1,0,0]);
-%! assert (normest(A), norm(A), 1e-6);
+%! assert (normest (A), norm (A), 1e-6);
 
 %!test
 %! A = rand (10);
-%! assert (normest(A), norm(A), 1e-6);
+%! assert (normest (A), norm (A), 1e-6);
 
 %% Test input validation
 %!error normest ()
 %!error normest (1, 2, 3)
 %!error normest ([true true])
 %!error normest (ones (3,3,3))
 %!error normest (1, [1, 2])
 %!error normest (1, 1+1i)
diff --git a/scripts/linear-algebra/null.m b/scripts/linear-algebra/null.m
--- a/scripts/linear-algebra/null.m
+++ b/scripts/linear-algebra/null.m
@@ -73,39 +73,43 @@ function retval = null (A, tol)
       endif
     else
       retval = zeros (cols, 0);
     endif
   endif
 
 endfunction
 
+
+%% FIXME: Need some tests for 'single' variables as well
+
 %!test
 %! A = 0;
-%! assert(null(A), 1);
+%! assert (null (A), 1);
 
 %!test
 %! A = 1;
-%! assert(null(A), zeros(1,0))
+%! assert (null (A), zeros (1,0));
 
 %!test
 %! A = [1 0; 0 1];
-%! assert(null(A), zeros(2,0));
+%! assert (null (A), zeros (2,0));
 
 %!test
 %! A = [1 0; 1 0];
-%! assert(null(A), [0 1]')
+%! assert (null (A), [0 1]');
 
 %!test
 %! A = [1 1; 0 0];
-%! assert(null(A), [-1/sqrt(2) 1/sqrt(2)]', eps)
+%! assert (null (A), [-1/sqrt(2) 1/sqrt(2)]', eps);
 
 %!test
 %! tol = 1e-4;
 %! A = [1 0; 0 tol-eps];
-%! assert(null(A,tol), [0 1]')
+%! assert (null (A,tol), [0; 1]);
 
 %!test
 %! tol = 1e-4;
 %! A = [1 0; 0 tol+eps];
-%! assert(null(A,tol), zeros(2,0));
+%! assert (null (A,tol), zeros (2,0));
 
-%!error null()
+%!error null ()
+
diff --git a/scripts/linear-algebra/onenormest.m b/scripts/linear-algebra/onenormest.m
--- a/scripts/linear-algebra/onenormest.m
+++ b/scripts/linear-algebra/onenormest.m
@@ -248,44 +248,45 @@ endfunction
 
 %!test
 %! N = 10;
 %! A = ones (N);
 %! [nm1, v1, w1] = onenormest (A);
 %! [nminf, vinf, winf] = onenormest (A', 6);
 %! assert (nm1, N, -2*eps);
 %! assert (nminf, N, -2*eps);
-%! assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps)
-%! assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps)
+%! assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps);
+%! assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps);
 
 %!test
 %! N = 10;
 %! A = ones (N);
 %! [nm1, v1, w1] = onenormest (@(x) A*x, @(x) A'*x, N, 3);
 %! [nminf, vinf, winf] = onenormest (@(x) A'*x, @(x) A*x, N, 3);
 %! assert (nm1, N, -2*eps);
 %! assert (nminf, N, -2*eps);
-%! assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps)
-%! assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps)
+%! assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps);
+%! assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps);
 
 %!test
 %! N = 5;
 %! A = hilb (N);
 %! [nm1, v1, w1] = onenormest (A);
 %! [nminf, vinf, winf] = onenormest (A', 6);
 %! assert (nm1, norm (A, 1), -2*eps);
 %! assert (nminf, norm (A, inf), -2*eps);
-%! assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps)
-%! assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps)
+%! assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps);
+%! assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps);
 
 ## Only likely to be within a factor of 10.
 %!test
 %! old_state = rand ("state");
 %! restore_state = onCleanup (@() rand ("state", old_state));
 %! rand ('state', 42);  % Initialize to guarantee reproducible results
 %! N = 100;
 %! A = rand (N);
 %! [nm1, v1, w1] = onenormest (A);
 %! [nminf, vinf, winf] = onenormest (A', 6);
 %! assert (nm1, norm (A, 1), -.1);
 %! assert (nminf, norm (A, inf), -.1);
-%! assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps)
-%! assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps)
+%! assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps);
+%! assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps);
+
diff --git a/scripts/linear-algebra/orth.m b/scripts/linear-algebra/orth.m
--- a/scripts/linear-algebra/orth.m
+++ b/scripts/linear-algebra/orth.m
@@ -75,16 +75,18 @@ function retval = orth (A, tol)
   else
 
     print_usage ();
 
   endif
 
 endfunction
 
+
 %!test
-%! for ii=1:20
+%! for i = 1:20
 %!   A = rand (10, 10);
 %!   V = orth (A);
 %!   if (det (A) != 0)
-%!     assert (V'*V, eye (10), 100*eps)
+%!     assert (V'*V, eye (10), 100*eps);
 %!   endif
 %! endfor
+
diff --git a/scripts/linear-algebra/planerot.m b/scripts/linear-algebra/planerot.m
--- a/scripts/linear-algebra/planerot.m
+++ b/scripts/linear-algebra/planerot.m
@@ -30,18 +30,19 @@
 ## @seealso{givens}
 ## @end deftypefn
 
 function [G, y] = planerot (x)
   G = givens (x(1), x(2));
   y = G * x(:);
 endfunction
 
+
 %!test
 %! x = [3 4];
-%! [g y] = planerot(x);
-%! assert(g - [x(1) x(2); -x(2) x(1)] / sqrt(x(1)^2 + x(2)^2), zeros(2), 2e-8);
-%! assert(y(2), 0, 2e-8);
+%! [g y] = planerot (x);
+%! assert (g, [x(1) x(2); -x(2) x(1)] / sqrt (x(1)^2 + x(2)^2), 2e-8);
+%! assert (y(2), 0, 2e-8);
 
-%!error planerot([0]);
-%!error planerot([0 0 0]);
-%!error planerot();
+%!error planerot ([0])
+%!error planerot ([0 0 0])
+%!error planerot ()
 
diff --git a/scripts/linear-algebra/qzhess.m b/scripts/linear-algebra/qzhess.m
--- a/scripts/linear-algebra/qzhess.m
+++ b/scripts/linear-algebra/qzhess.m
@@ -86,36 +86,37 @@ function [aa, bb, q, z] = qzhess (A, B)
   bb (2, 1) = 0.0;
   for i = 3:na
     bb (i, 1:(i-1)) = zeros (1, i-1);
     aa (i, 1:(i-2)) = zeros (1, i-2);
   endfor
 
 endfunction
 
+
 %!test
 %! a = [1 2 1 3;
 %!      2 5 3 2;
 %!      5 5 1 0;
 %!      4 0 3 2];
 %! b = [0 4 2 1;
 %!      2 3 1 1;
 %!      1 0 2 1;
 %!      2 5 3 2];
 %! mask = [0 0 0 0;
 %!         0 0 0 0;
 %!         1 0 0 0;
 %!         1 1 0 0];
-%! [aa, bb, q, z] = qzhess(a, b);
-%! assert(inv(q) - q', zeros(4), 2e-8);
-%! assert(inv(z) - z', zeros(4), 2e-8);
-%! assert(q * a * z, aa, 2e-8);
-%! assert(aa .* mask, zeros(4), 2e-8);
-%! assert(q * b * z, bb, 2e-8);
-%! assert(bb .* mask, zeros(4), 2e-8);
+%! [aa, bb, q, z] = qzhess (a, b);
+%! assert (inv (q) - q', zeros (4), 2e-8);
+%! assert (inv (z) - z', zeros (4), 2e-8);
+%! assert (q * a * z, aa, 2e-8);
+%! assert (aa .* mask, zeros (4), 2e-8);
+%! assert (q * b * z, bb, 2e-8);
+%! assert (bb .* mask, zeros (4), 2e-8);
 
 %!test
 %! a = [1 2 3 4 5;
 %!      3 2 3 1 0;
 %!      4 3 2 1 1;
 %!      0 1 0 1 0;
 %!      3 2 1 0 5];
 %! b = [5 0 4 0 1;
@@ -123,19 +124,19 @@ endfunction
 %!      0 3 2 1 0;
 %!      4 3 0 3 5;
 %!      2 1 2 1 3];
 %! mask = [0 0 0 0 0;
 %!         0 0 0 0 0;
 %!         1 0 0 0 0;
 %!         1 1 0 0 0;
 %!         1 1 1 0 0];
-%! [aa, bb, q, z] = qzhess(a, b);
-%! assert(inv(q) - q', zeros(5), 2e-8);
-%! assert(inv(z) - z', zeros(5), 2e-8);
-%! assert(q * a * z, aa, 2e-8);
-%! assert(aa .* mask, zeros(5), 2e-8);
-%! assert(q * b * z, bb, 2e-8);
-%! assert(bb .* mask, zeros(5), 2e-8);
+%! [aa, bb, q, z] = qzhess (a, b);
+%! assert (inv (q) - q', zeros (5), 2e-8);
+%! assert (inv (z) - z', zeros (5), 2e-8);
+%! assert (q * a * z, aa, 2e-8);
+%! assert (aa .* mask, zeros (5), 2e-8);
+%! assert (q * b * z, bb, 2e-8);
+%! assert (bb .* mask, zeros (5), 2e-8);
 
-%!error qzhess([0]);
-%!error qzhess();
+%!error qzhess ([0])
+%!error qzhess ()
 
diff --git a/scripts/linear-algebra/rank.m b/scripts/linear-algebra/rank.m
--- a/scripts/linear-algebra/rank.m
+++ b/scripts/linear-algebra/rank.m
@@ -54,58 +54,60 @@ function retval = rank (A, tol)
   else
     print_usage ();
   endif
 
   retval = sum (sigma > tolerance);
 
 endfunction
 
+
 %!test
 %! A = [1 2 3 4 5 6 7;
 %!      4 5 6 7 8 9 12;
 %!      1 2 3.1 4 5 6 7;
 %!      2 3 4 5 6 7 8;
 %!      3 4 5 6 7 8 9;
 %!      4 5 6 7 8 9 10;
 %!      5 6 7 8 9 10 11];
-%! assert(rank(A),4);
+%! assert (rank (A), 4);
 
 %!test
 %! A = [1 2 3 4 5 6 7;
 %!      4 5 6 7 8 9 12;
 %!      1 2 3.0000001 4 5 6 7;
 %!      4 5 6 7 8 9 12.00001;
 %!      3 4 5 6 7 8 9;
 %!      4 5 6 7 8 9 10;
 %!      5 6 7 8 9 10 11];
-%! assert(rank(A),4);
+%! assert (rank (A), 4);
 
 %!test
 %! A = [1 2 3 4 5 6 7;
 %!      4 5 6 7 8 9 12;
 %!      1 2 3 4 5 6 7;
 %!      4 5 6 7 8 9 12.00001;
 %!      3 4 5 6 7 8 9;
 %!      4 5 6 7 8 9 10;
 %!      5 6 7 8 9 10 11];
-%! assert(rank(A),3);
+%! assert (rank (A), 3);
 
 %!test
 %! A = [1 2 3 4 5 6 7;
 %!      4 5 6 7 8 9 12;
 %!      1 2 3 4 5 6 7;
 %!      4 5 6 7 8 9 12;
 %!      3 4 5 6 7 8 9;
 %!      4 5 6 7 8 9 10;
 %!      5 6 7 8 9 10 11];
-%! assert(rank(A),3);
+%! assert (rank (A), 3);
 
 %!test
-%! A = eye(100);
-%! assert(rank(A),100);
+%! A = eye (100);
+%! assert (rank (A), 100);
 
 %!test
 %! A = [1, 2, 3; 1, 2.001, 3; 1, 2, 3.0000001];
-%! assert(rank(A),3)
-%! assert(rank(A,0.0009),1)
-%! assert(rank(A,0.0006),2)
-%! assert(rank(A,0.00000002),3)
\ No newline at end of file
+%! assert (rank (A), 3);
+%! assert (rank (A,0.0009), 1);
+%! assert (rank (A,0.0006), 2);
+%! assert (rank (A,0.00000002), 3);
+
diff --git a/scripts/linear-algebra/rref.m b/scripts/linear-algebra/rref.m
--- a/scripts/linear-algebra/rref.m
+++ b/scripts/linear-algebra/rref.m
@@ -82,47 +82,47 @@ function [A, k] = rref (A, tol)
         break;
       endif
     endif
   endfor
   k = find (used);
 
 endfunction
 
+
 %!test
 %! a = [1];
-%! [r k] = rref(a);
-%! assert(r, [1], 2e-8);
-%! assert(k, [1], 2e-8);
+%! [r k] = rref (a);
+%! assert (r, [1], 2e-8);
+%! assert (k, [1], 2e-8);
 
 %!test
 %! a = [1 3; 4 5];
-%! [r k] = rref(a);
-%! assert(rank(a), rank(r), 2e-8);
-%! assert(r, eye(2), 2e-8);
-%! assert(k == [1, 2] || k == [2, 1]);
-
+%! [r k] = rref (a);
+%! assert (rank (a), rank (r), 2e-8);
+%! assert (r, eye (2), 2e-8);
+%! assert (k == [1, 2] || k == [2, 1]);
 
 %!test
 %! a = [1 3; 4 5; 7 9];
-%! [r k] = rref(a);
-%! assert(rank(a), rank(r), 2e-8);
-%! assert(r, eye(3)(:,1:2), 2e-8);
-%! assert(k, [1 2], 2e-8);
+%! [r k] = rref (a);
+%! assert (rank (a), rank (r), 2e-8);
+%! assert (r, eye(3)(:,1:2), 2e-8);
+%! assert (k, [1 2], 2e-8);
 
 %!test
 %! a = [1 2 3; 2 4 6; 7 2 0];
-%! [r k] = rref(a);
-%! assert(rank(a), rank(r), 2e-8);
-%! assert(r, [1 0 (3-7/2); 0 1 (7/4); 0 0 0], 2e-8);
-%! assert(k, [1 2], 2e-8);
+%! [r k] = rref (a);
+%! assert (rank (a), rank (r), 2e-8);
+%! assert (r, [1 0 (3-7/2); 0 1 (7/4); 0 0 0], 2e-8);
+%! assert (k, [1 2], 2e-8);
 
 %!test
 %! a = [1 2 1; 2 4 2.01; 2 4 2.1];
 %! tol = 0.02;
-%! [r k] = rref(a, tol);
-%! assert(rank(a, tol), rank(r, tol), 2e-8);
+%! [r k] = rref (a, tol);
+%! assert (rank (a, tol), rank (r, tol), 2e-8);
 %! tol = 0.2;
-%! [r k] = rref(a, tol);
-%! assert(rank(a, tol), rank(r, tol), 2e-8);
+%! [r k] = rref (a, tol);
+%! assert (rank (a, tol), rank (r, tol), 2e-8);
 
-%!error rref();
+%!error rref ();
 
diff --git a/scripts/linear-algebra/trace.m b/scripts/linear-algebra/trace.m
--- a/scripts/linear-algebra/trace.m
+++ b/scripts/linear-algebra/trace.m
@@ -36,17 +36,19 @@ function y = trace (A)
   elseif (any (size (A) == 1))
     y = A(1);
   else
     y = sum (diag (A));
   endif
 
 endfunction
 
-%!assert(trace ([1, 2; 3, 4]) == 5);
-%!assert(trace ([1, 2; 3, 4; 5, 6]) == 5);
-%!assert(trace ([1, 3, 5; 2, 4, 6]) == 5);
-%!assert(trace ([]), 0);
-%!assert(trace (randn(1,0)), 0);
-%!
-%!error trace ();
-%!error trace (1, 2);
-%!error <only valid on 2-D objects> trace(reshape(1:9,[1,3,3]));
+
+%!assert (trace ([1, 2; 3, 4]), 5)
+%!assert (trace ([1, 2; 3, 4; 5, 6]), 5)
+%!assert (trace ([1, 3, 5; 2, 4, 6]), 5)
+%!assert (trace ([]), 0)
+%!assert (trace (randn (1,0)), 0)
+
+%!error trace ()
+%!error trace (1, 2)
+%!error <only valid on 2-D objects> trace (reshape (1:9,[1,3,3]))
+
diff --git a/scripts/linear-algebra/vech.m b/scripts/linear-algebra/vech.m
--- a/scripts/linear-algebra/vech.m
+++ b/scripts/linear-algebra/vech.m
@@ -45,14 +45,14 @@ function v = vech (x)
   endif
 
   n = rows (x);
   slices = cellslices (x(:), (1:n) + n*(0:n-1), n*(1:n));
   v = vertcat (slices{:});
 
 endfunction
 
-%!assert(all (vech ([1, 2, 3; 4, 5, 6; 7, 8, 9]) == [1; 4; 7; 5; 8; 9]));
+
+%!assert (vech ([1, 2, 3; 4, 5, 6; 7, 8, 9]), [1; 4; 7; 5; 8; 9])
 
-%!error vech ();
+%!error vech ()
+%!error vech (1, 2)
 
-%!error vech (1, 2);
-
diff --git a/scripts/miscellaneous/ans.m b/scripts/miscellaneous/ans.m
--- a/scripts/miscellaneous/ans.m
+++ b/scripts/miscellaneous/ans.m
@@ -24,11 +24,12 @@
 ## @example
 ## 3^2 + 4^2
 ## @end example
 ##
 ## @noindent
 ## is evaluated, the value returned by @code{ans} is 25.
 ## @end defvr
 
+
 ## Mark file as being tested.  No real test needed for a documentation .m file
 %!assert (1)
 
diff --git a/scripts/miscellaneous/bincoeff.m b/scripts/miscellaneous/bincoeff.m
--- a/scripts/miscellaneous/bincoeff.m
+++ b/scripts/miscellaneous/bincoeff.m
@@ -98,23 +98,23 @@ function b = bincoeff (n, k)
   b(n_int) = round (b(n_int));
 
   idx = ! n_int;
   b(idx) = real (b(idx));
 
 endfunction
 
 
-%!assert(bincoeff (4, 2), 6)
-%!assert(bincoeff (2, 4), 0)
-%!assert(bincoeff (-4, 2), 10)
-%!assert(bincoeff (5, 2), 10)
-%!assert(bincoeff (50, 6), 15890700)
-%!assert(bincoeff (0.4, 2), -.12, 8*eps)
+%!assert (bincoeff (4, 2), 6)
+%!assert (bincoeff (2, 4), 0)
+%!assert (bincoeff (-4, 2), 10)
+%!assert (bincoeff (5, 2), 10)
+%!assert (bincoeff (50, 6), 15890700)
+%!assert (bincoeff (0.4, 2), -.12, 8*eps)
 
-%!assert(bincoeff ([4 NaN 4], [-1, 2, 2.5]), NaN (1, 3))
+%!assert (bincoeff ([4 NaN 4], [-1, 2, 2.5]), NaN (1, 3))
 
 %% Test input validation
-%!error bincoeff ();
-%!error bincoeff (1, 2, 3);
-%!error bincoeff (ones(3),ones(2))
-%!error bincoeff (ones(2),ones(3))
+%!error bincoeff ()
+%!error bincoeff (1, 2, 3)
+%!error bincoeff (ones (3),ones (2))
+%!error bincoeff (ones (2),ones (3))
 
diff --git a/scripts/miscellaneous/bug_report.m b/scripts/miscellaneous/bug_report.m
--- a/scripts/miscellaneous/bug_report.m
+++ b/scripts/miscellaneous/bug_report.m
@@ -39,10 +39,11 @@ function bug_report ()
   puts ("\n");
   puts ("  to learn how to submit useful bug reports that will\n");
   puts ("  help the Octave community diagnose and fix the problem\n");
   puts ("  quickly and efficiently.\n");
   puts ("\n");
 
 endfunction
 
+
 ## Mark file as being tested.  No real test needed for this function.
 %!assert (1)
diff --git a/scripts/miscellaneous/bzip2.m b/scripts/miscellaneous/bzip2.m
--- a/scripts/miscellaneous/bzip2.m
+++ b/scripts/miscellaneous/bzip2.m
@@ -37,25 +37,27 @@ function entries = bzip2 (varargin)
       entries = __xzip__ ("bzip2", "bz2", "bzip2 %s", varargin{:});
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!xtest
-%!  # test for correct cleanup of temporary files
-%!  unwind_protect
-%!    filename = tmpnam;
-%!    dummy    = 1;
-%!    save(filename, "dummy");
-%!    n_tmpfiles_before = length(find(strncmp("oct-", cellstr(ls(P_tmpdir)), 4)));
-%!    entry = bzip2(filename);
-%!    n_tmpfiles_after = length(find(strncmp("oct-", cellstr(ls(P_tmpdir)), 4)));
-%!    if (n_tmpfiles_before != n_tmpfiles_after)
-%!      error("bzip2 has not cleaned up temporary files correctly!");
-%!    endif
-%!  unwind_protect_cleanup
-%!    delete(filename);
-%!    [path, basename, extension] = fileparts(filename);
-%!    delete([basename, extension, ".bz2"]);
-%!  end_unwind_protect
+%! # test for correct cleanup of temporary files
+%! unwind_protect
+%!   filename = tmpnam;
+%!   dummy    = 1;
+%!   save (filename, "dummy");
+%!   n_tmpfiles_before = length (find (strncmp ("oct-", cellstr (ls (P_tmpdir)), 4)));
+%!   entry = bzip2 (filename);
+%!   n_tmpfiles_after = length (find (strncmp ("oct-", cellstr (ls (P_tmpdir)), 4)));
+%!   if (n_tmpfiles_before != n_tmpfiles_after)
+%!     error ("bzip2 has not cleaned up temporary files correctly!");
+%!   endif
+%! unwind_protect_cleanup
+%!   delete (filename);
+%!   [path, basename, extension] = fileparts (filename);
+%!   delete ([basename, extension, ".bz2"]);
+%! end_unwind_protect
+
diff --git a/scripts/miscellaneous/comma.m b/scripts/miscellaneous/comma.m
--- a/scripts/miscellaneous/comma.m
+++ b/scripts/miscellaneous/comma.m
@@ -17,11 +17,12 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Operator} {} ,
 ## Array index, function argument, or command separator.
 ## @seealso{semicolon}
 ## @end deftypefn
 
+
 ## Mark file as being tested.  No real test needed for a documentation .m file
 %!assert (1)
 
diff --git a/scripts/miscellaneous/compare_versions.m b/scripts/miscellaneous/compare_versions.m
--- a/scripts/miscellaneous/compare_versions.m
+++ b/scripts/miscellaneous/compare_versions.m
@@ -195,59 +195,59 @@ function out = compare_versions (v1, v2,
 
   ## Reverse the output if not is given.
   if (not_op)
     out = !out;
   endif
 
 endfunction
 
+
 ## tests
 ## test both equality symbols
 ## test arbitrarily long equality
-%!assert(compare_versions("1.1.0.0.0", "1.1", "=="), true)
-%!assert(compare_versions("1", "1.1", "<"), true)
-%!assert(compare_versions("1.1", "1.1", "<="), true)
-%!assert(compare_versions("1.1", "1.1.1", "<="), true)
-%!assert(compare_versions("1.23", "1.24", "=<"), true)
+%!assert (compare_versions ("1.1.0.0.0", "1.1", "=="), true)
+%!assert (compare_versions ("1", "1.1", "<"), true)
+%!assert (compare_versions ("1.1", "1.1", "<="), true)
+%!assert (compare_versions ("1.1", "1.1.1", "<="), true)
+%!assert (compare_versions ("1.23", "1.24", "=<"), true)
 ## test different length numbers
-%!assert(compare_versions("23.2000", "23.1", ">"), true)
-%!assert(compare_versions("0.0.2", "0.0.1", ">="), true)
-%!assert(compare_versions("0.2", "0.0.100", "=>"), true)
-%!assert(compare_versions("0.1", "0.2", "!="), true)
-%!assert(compare_versions("0.1", "0.2", "~="), true)
+%!assert (compare_versions ("23.2000", "23.1", ">"), true)
+%!assert (compare_versions ("0.0.2", "0.0.1", ">="), true)
+%!assert (compare_versions ("0.2", "0.0.100", "=>"), true)
+%!assert (compare_versions ("0.1", "0.2", "!="), true)
+%!assert (compare_versions ("0.1", "0.2", "~="), true)
 
 ## test alphanumeric strings
-%!assert(compare_versions("1a", "1b", "<"), true)
-%!assert(compare_versions("a", "1", "<"), true)
-%!assert(compare_versions("1a", "1b", ">"), false)
-%!assert(compare_versions("a", "1", ">"), false)
-%!assert(compare_versions("1.1.0a", "1.1.0b", "=="), false)
-%!assert(compare_versions("1.1.0a", "1.1.0b", "!="), true)
-%!assert(compare_versions("1.1.0test", "1.1.0b", "=="), false)
-%!assert(compare_versions("1.1.0test", "1.1.0test", "=="), true)
+%!assert (compare_versions ("1a", "1b", "<"), true)
+%!assert (compare_versions ("a", "1", "<"), true)
+%!assert (compare_versions ("1a", "1b", ">"), false)
+%!assert (compare_versions ("a", "1", ">"), false)
+%!assert (compare_versions ("1.1.0a", "1.1.0b", "=="), false)
+%!assert (compare_versions ("1.1.0a", "1.1.0b", "!="), true)
+%!assert (compare_versions ("1.1.0test", "1.1.0b", "=="), false)
+%!assert (compare_versions ("1.1.0test", "1.1.0test", "=="), true)
 
 ## make sure that it won't just give true output
-%!assert(compare_versions("1", "0", "=="), false)
+%!assert (compare_versions ("1", "0", "=="), false)
 ## test arbitrarily long equality
-%!assert(compare_versions("1.1.1.0.0", "1.1", "=="), false)
-%!assert(compare_versions("1.1", "1", "<"), false)
-%!assert(compare_versions("2", "1.1", "<="), false)
-%!assert(compare_versions("1.1.1", "1.1", "<="), false)
-%!assert(compare_versions("1.25", "1.24", "=<"), false)
+%!assert (compare_versions ("1.1.1.0.0", "1.1", "=="), false)
+%!assert (compare_versions ("1.1", "1", "<"), false)
+%!assert (compare_versions ("2", "1.1", "<="), false)
+%!assert (compare_versions ("1.1.1", "1.1", "<="), false)
+%!assert (compare_versions ("1.25", "1.24", "=<"), false)
 ## test different length numbers
-%!assert(compare_versions("23.2", "23.100", ">"), false)
-%!assert(compare_versions("0.0.0.2", "0.0.1", ">="), false)
-%!assert(compare_versions("0.0.20", "0.10.2", "=>"), false)
-%!assert(compare_versions("0.1", "0.1", "!="), false)
-%!assert(compare_versions("0.1", "0.1", "~="), false)
+%!assert (compare_versions ("23.2", "23.100", ">"), false)
+%!assert (compare_versions ("0.0.0.2", "0.0.1", ">="), false)
+%!assert (compare_versions ("0.0.20", "0.10.2", "=>"), false)
+%!assert (compare_versions ("0.1", "0.1", "!="), false)
+%!assert (compare_versions ("0.1", "0.1", "~="), false)
 
 %% Test input validation
-%!error(compare_versions(0.1, "0.1", "=="))
-%!error(compare_versions("0.1", 0.1, "=="))
-%!error(compare_versions(["0";".";"1"], "0.1", "=="))
-%!error(compare_versions("0.1", ["0";".";"1"], "=="))
-%!error(compare_versions("0.1", "0.1", "<>"))
-%!error(compare_versions("0.1", "0.1", "!>"))
-%!error(compare_versions("0.1", "0.1", "="))
-%!error(compare_versions("0.1", "0.1", "aa"))
+%!error (compare_versions (0.1, "0.1", "=="))
+%!error (compare_versions ("0.1", 0.1, "=="))
+%!error (compare_versions (["0";".";"1"], "0.1", "=="))
+%!error (compare_versions ("0.1", ["0";".";"1"], "=="))
+%!error (compare_versions ("0.1", "0.1", "<>"))
+%!error (compare_versions ("0.1", "0.1", "!>"))
+%!error (compare_versions ("0.1", "0.1", "="))
+%!error (compare_versions ("0.1", "0.1", "aa"))
 
-
diff --git a/scripts/miscellaneous/computer.m b/scripts/miscellaneous/computer.m
--- a/scripts/miscellaneous/computer.m
+++ b/scripts/miscellaneous/computer.m
@@ -80,12 +80,15 @@ function [c, maxsize, endian] = computer
       endif
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
-%!assert((ischar (computer ())
-%! && computer () == octave_config_info ("canonical_host_type")));
-%!assert(ischar (computer ("arch")));
-%!error computer (2);
+
+%!assert (ischar (computer ()))
+%!assert (computer (), octave_config_info ("canonical_host_type"))
+%!assert (ischar (computer ("arch")))
+
+%!error computer (2)
+
diff --git a/scripts/miscellaneous/edit.m b/scripts/miscellaneous/edit.m
--- a/scripts/miscellaneous/edit.m
+++ b/scripts/miscellaneous/edit.m
@@ -499,16 +499,17 @@ function ret = default_user (long_form)
       ret = ret(1:pos-1);
     endif
   else
     ret = ent.name;
   endif
 
 endfunction
 
+
 %!test
 %! s.editor = edit ("get", "editor");
 %! s.home = edit ("get", "home");
 %! s.author = edit ("get", "author");
 %! s.email = edit ("get", "email");
 %! s.license = edit ("get", "license");
 %! s.editinplace = edit ("get", "editinplace");
 %! s.mode = edit ("get", "mode");
diff --git a/scripts/miscellaneous/fileparts.m b/scripts/miscellaneous/fileparts.m
--- a/scripts/miscellaneous/fileparts.m
+++ b/scripts/miscellaneous/fileparts.m
@@ -54,16 +54,17 @@ function [directory, name, extension, ve
       error ("fileparts: expecting FILENAME argument to be a string");
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!test
 %! [d, n, e] = fileparts ("file");
 %! assert (strcmp (d, "") && strcmp (n, "file") && strcmp (e, ""));
 
 %!test
 %! [d, n, e] = fileparts ("file.ext");
 %! assert (strcmp (d, "") && strcmp (n, "file") && strcmp (e, ".ext"));
 
@@ -89,8 +90,9 @@ endfunction
 
 %!test
 %! [d, n, e] = fileparts ("/.ext");
 %! assert (strcmp (d, "/") && strcmp (n, char (zeros (1, 0))) && strcmp (e, ".ext"));
 
 %!test
 %! [d, n, e] = fileparts (".ext");
 %! assert (strcmp (d, "") && strcmp (n, char (zeros (1, 0))) && strcmp (e, ".ext"));
+
diff --git a/scripts/miscellaneous/fullfile.m b/scripts/miscellaneous/fullfile.m
--- a/scripts/miscellaneous/fullfile.m
+++ b/scripts/miscellaneous/fullfile.m
@@ -48,16 +48,17 @@ function filename = fullfile (varargin)
       filename = "";
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!shared fs, fsx, xfs, fsxfs, xfsy
 %! fs = filesep ();
 %! fsx = cstrcat (fs, "x");
 %! xfs = cstrcat ("x", fs);
 %! fsxfs = cstrcat (fs, "x", fs);
 %! xfsy = cstrcat ("x", fs, "y");
 %!assert (fullfile (""), "")
 %!assert (fullfile (fs), fs)
@@ -73,8 +74,9 @@ endfunction
 %!assert (fullfile ("x", "", "y", ""), xfsy)
 %!assert (fullfile ("", "x", "", "y", ""), xfsy)
 %!assert (fullfile (fs), fs)
 %!assert (fullfile (fs, fs), fs)
 %!assert (fullfile (fs, "x"), fsx)
 %!assert (fullfile (fs, xfs), fsxfs)
 %!assert (fullfile (fsx, fs), fsxfs)
 %!assert (fullfile (fs, "x", fs), fsxfs)
+
diff --git a/scripts/miscellaneous/getfield.m b/scripts/miscellaneous/getfield.m
--- a/scripts/miscellaneous/getfield.m
+++ b/scripts/miscellaneous/getfield.m
@@ -55,14 +55,16 @@ function obj = getfield (s, varargin)
   if (all (flds | idxs))
     typs = merge (flds, {"."}, {"()"});
     obj = subsref (s, struct ("type", typs, "subs", subs));
   else
     error ("getfield: invalid index");
   endif
 endfunction
 
+
 %!test
 %! x.a = "hello";
-%! assert(getfield(x,"a"),"hello");
+%! assert (getfield (x, "a"), "hello");
 %!test
 %! ss(1,2).fd(3).b = 5;
-%! assert(getfield(ss,{1,2},'fd',{3},'b'),5)
+%! assert (getfield (ss,{1,2},"fd",{3},"b"), 5);
+
diff --git a/scripts/miscellaneous/gzip.m b/scripts/miscellaneous/gzip.m
--- a/scripts/miscellaneous/gzip.m
+++ b/scripts/miscellaneous/gzip.m
@@ -35,38 +35,41 @@ function entries = gzip (varargin)
   if (nargout == 0)
     __xzip__ ("gzip", "gz", "gzip -r %s", varargin{:});
   else
     entries = __xzip__ ("gzip", "gz", "gzip -r %s", varargin{:});
   endif
 
 endfunction
 
-%!error <Invalid call to gzip.  Correct usage is> gzip("1", "2", "3");
-%!error <Invalid call to gzip.  Correct usage is> gzip();
-%!error <output directory does not exist> gzip("1", tmpnam);
-%!error <FILES must be a character array or cellstr> gzip(1);
+
 %!xtest
-%!  # test gzip together with gunzip
-%!  unwind_protect
-%!    filename = tmpnam;
-%!    dummy    = 1;
-%!    save(filename, "dummy");
-%!    dirname  = tmpnam;
-%!    mkdir(dirname);
-%!    entry = gzip(filename, dirname);
-%!    [path, basename, extension] = fileparts(filename);
-%!    if ! strcmp(entry, [dirname, filesep, basename, extension, ".gz"])
-%!      error("gzipped file does not match expected name!");
-%!    endif
-%!    if ! exist(entry, "file")
-%!      error("gzipped file cannot be found!");
-%!    endif
-%!    gunzip(entry);
-%!    if (system(sprintf("diff %s %s%c%s%s", filename, dirname, filesep,
-%!                                          basename, extension)))
-%!      error("unzipped file not equal to original file!");
-%!    end
-%!  unwind_protect_cleanup
-%!    delete(filename);
-%!    delete([dirname, filesep, basename, extension]);
-%!    rmdir(dirname);
-%!  end_unwind_protect
+%! # test gzip together with gunzip
+%! unwind_protect
+%!   filename = tmpnam;
+%!   dummy    = 1;
+%!   save (filename, "dummy");
+%!   dirname  = tmpnam;
+%!   mkdir (dirname);
+%!   entry = gzip (filename, dirname);
+%!   [path, basename, extension] = fileparts (filename);
+%!   if ! strcmp (entry, [dirname, filesep, basename, extension, ".gz"])
+%!     error ("gzipped file does not match expected name!");
+%!   endif
+%!   if ! exist (entry, "file")
+%!     error ("gzipped file cannot be found!");
+%!   endif
+%!   gunzip (entry);
+%!   if (system (sprintf ("diff %s %s%c%s%s", filename, dirname, filesep,
+%!                                            basename, extension)))
+%!     error ("unzipped file not equal to original file!");
+%!   end
+%! unwind_protect_cleanup
+%!   delete (filename);
+%!   delete ([dirname, filesep, basename, extension]);
+%!   rmdir (dirname);
+%! end_unwind_protect
+
+%!error gzip ()
+%!error gzip ("1", "2", "3")
+%!error <output directory does not exist> gzip ("1", tmpnam)
+%!error <FILES must be a character array or cellstr> gzip (1)
+
diff --git a/scripts/miscellaneous/info.m b/scripts/miscellaneous/info.m
--- a/scripts/miscellaneous/info.m
+++ b/scripts/miscellaneous/info.m
@@ -39,10 +39,12 @@ function info ()
 \n\
   Report bugs to the bug tracker at\n\
   http://bugs.octave.org\n\
   But first, please read the guidelines to writing a helpful report at\n\
   http://www.octave.org/bugs.html\n");
 
 endfunction
 
+
 ## Mark file as being tested.  No real test needed for this function.
 %! assert (1)
+
diff --git a/scripts/miscellaneous/inputname.m b/scripts/miscellaneous/inputname.m
--- a/scripts/miscellaneous/inputname.m
+++ b/scripts/miscellaneous/inputname.m
@@ -35,22 +35,25 @@ function s = inputname (n)
       s = "";
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
+
 ## Warning: heap big magic in the following tests!!!
 ## The test function builds a private context for each
 ## test, with only the specified values shared between
 ## them.  It does this using the following template:
 ##
 ##     function [<shared>] = testfn(<shared>)
 ##        <test>
 ##
 ## To test inputname, I need a function context invoked
 ## with known parameter names.  So define a couple of
 ## shared parameters, et voila!, the test is trivial.
-%!shared hello,worldly
-%!assert(inputname(1),'hello');
-%!assert(inputname(2),'worldly');
+  
+%!shared hello, worldly
+%!assert (inputname (1), "hello")
+%!assert (inputname (2), "worldly")
+
diff --git a/scripts/miscellaneous/isappdata.m b/scripts/miscellaneous/isappdata.m
--- a/scripts/miscellaneous/isappdata.m
+++ b/scripts/miscellaneous/isappdata.m
@@ -36,13 +36,14 @@ function res = isappdata (h, name)
       res(nh) = true;
     else
       res(nh) = false;
     endif
   endfor
 
 endfunction
 
+
 %!test
-%! setappdata (0, "hello", "world")
-%! assert (isappdata (0, "hello"), true)
-%!assert (isappdata (0, "foobar"), false)
+%! setappdata (0, "hello", "world");
+%! assert (isappdata (0, "hello"), true);
+%! assert (isappdata (0, "foobar"), false);
 
diff --git a/scripts/miscellaneous/isdeployed.m b/scripts/miscellaneous/isdeployed.m
--- a/scripts/miscellaneous/isdeployed.m
+++ b/scripts/miscellaneous/isdeployed.m
@@ -23,9 +23,10 @@
 ## the Octave interpreter.  Currently, this function always returns
 ## false in Octave.
 ## @end deftypefn
 
 function retval = isdeployed ()
   retval = false;
 endfunction
 
+
 %!assert (isdeployed (), false)
diff --git a/scripts/miscellaneous/ismac.m b/scripts/miscellaneous/ismac.m
--- a/scripts/miscellaneous/ismac.m
+++ b/scripts/miscellaneous/ismac.m
@@ -27,10 +27,12 @@ function retval = ismac ()
   if (nargin == 0)
     retval = octave_config_info ("mac");
   else
     print_usage ();
   endif
 
 endfunction
 
-%!error ismac (1);
-%!assert (islogical (ismac ()));
+
+%!assert (islogical (ismac ()))
+
+%!error ismac (1)
diff --git a/scripts/miscellaneous/ispc.m b/scripts/miscellaneous/ispc.m
--- a/scripts/miscellaneous/ispc.m
+++ b/scripts/miscellaneous/ispc.m
@@ -27,10 +27,13 @@ function retval = ispc ()
   if (nargin == 0)
     retval = octave_config_info ("windows");
   else
     print_usage ();
   endif
 
 endfunction
 
-%!error ispc (1);
-%!assert (islogical (ispc ()));
+
+%!assert (islogical (ispc ()))
+
+%!error ispc (1)
+
diff --git a/scripts/miscellaneous/isunix.m b/scripts/miscellaneous/isunix.m
--- a/scripts/miscellaneous/isunix.m
+++ b/scripts/miscellaneous/isunix.m
@@ -27,10 +27,13 @@ function retval = isunix ()
   if (nargin == 0)
     retval = octave_config_info ("unix");
   else
     print_usage ();
   endif
 
 endfunction
 
-%!error isunix (1);
-%!assert (islogical (isunix ()));
+
+%!assert (islogical (isunix ()))
+
+%!error isunix (1)
+
diff --git a/scripts/miscellaneous/list_primes.m b/scripts/miscellaneous/list_primes.m
--- a/scripts/miscellaneous/list_primes.m
+++ b/scripts/miscellaneous/list_primes.m
@@ -79,13 +79,13 @@ function retval = list_primes (n)
       n--;
     endif
     p = p + 2;
 
   endwhile
 
 endfunction
 
-%!test
-%! assert (list_primes(), [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41,\
-%!                        43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]);
-%! assert (list_primes(5), [2, 3, 5, 7, 11]);
 
+%!assert (list_primes (), [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, ...
+%!                         43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97])
+%!assert (list_primes (5), [2, 3, 5, 7, 11]);
+
diff --git a/scripts/miscellaneous/ls.m b/scripts/miscellaneous/ls.m
--- a/scripts/miscellaneous/ls.m
+++ b/scripts/miscellaneous/ls.m
@@ -85,10 +85,10 @@ function retval = ls (varargin)
 endfunction
 
 
 %!test
 %! list = ls ();
 %! assert (ischar (list));
 %! assert (! isempty (list));
 
-%!error ls (1);
+%!error ls (1)
 
diff --git a/scripts/miscellaneous/mexext.m b/scripts/miscellaneous/mexext.m
--- a/scripts/miscellaneous/mexext.m
+++ b/scripts/miscellaneous/mexext.m
@@ -21,9 +21,10 @@
 ## Return the filename extension used for MEX files.
 ## @seealso{mex}
 ## @end deftypefn
 
 function retval = mexext ()
   retval = "mex";
 endfunction
 
+
 %!assert (mexext (), "mex")
diff --git a/scripts/miscellaneous/namelengthmax.m b/scripts/miscellaneous/namelengthmax.m
--- a/scripts/miscellaneous/namelengthmax.m
+++ b/scripts/miscellaneous/namelengthmax.m
@@ -26,9 +26,9 @@
 ## format will have their names truncated to this length.
 ## @end deftypefn
 
 function n = namelengthmax ()
   n = 63;
 endfunction
 
 
-%!assert (namelengthmax, 63)
+%!assert (namelengthmax (), 63)
diff --git a/scripts/miscellaneous/news.m b/scripts/miscellaneous/news.m
--- a/scripts/miscellaneous/news.m
+++ b/scripts/miscellaneous/news.m
@@ -63,8 +63,9 @@ function news (package = "octave")
   fclose (fid);
 
 endfunction
 
 
 %!error news (1, 2)
 %!error <PACKAGE must be a string> news (1)
 %!error <Package .* is not installed> news ("__NOT_A_VALID_PKG_NAME__")
+
diff --git a/scripts/miscellaneous/orderfields.m b/scripts/miscellaneous/orderfields.m
--- a/scripts/miscellaneous/orderfields.m
+++ b/scripts/miscellaneous/orderfields.m
@@ -157,39 +157,41 @@ function [t, p] = orderfields (s1, s2)
       [t(1:n).(el)] = s1(:).(el);
     endfor
     ## inherit dimensions
     t = reshape (t, size (s1));
   endif
 
 endfunction
 
+
 %!shared a, b, c
 %! a = struct ("foo", {1, 2}, "bar", {3, 4});
 %! b = struct ("bar", 6, "foo", 5);
 %! c = struct ("bar", {7, 8}, "foo", 9);
 %!test
 %! a(2) = orderfields (b, a);
-%! assert (a(2).foo, 5)
-%! assert (a(2).bar, 6)
+%! assert (a(2).foo, 5);
+%! assert (a(2).bar, 6);
 %!test
 %! [a(2), p] = orderfields (b, [2 1]);
-%! assert (a(2).foo, 5)
-%! assert (a(2).bar, 6)
+%! assert (a(2).foo, 5);
+%! assert (a(2).bar, 6);
 %! assert (p, [2; 1]);
 %!test
 %! a(2) = orderfields (b, fieldnames (a));
-%! assert (a(2).foo, 5)
-%! assert (a(2).bar, 6)
+%! assert (a(2).foo, 5);
+%! assert (a(2).bar, 6);
 %!test
 %! a(1:2) = orderfields (c, fieldnames (a));
-%! assert (a(2).foo, 9)
-%! assert (a(2).bar, 8)
+%! assert (a(2).foo, 9);
+%! assert (a(2).bar, 8);
 
 %!test
 %! aa.x = {1, 2};
 %! aa.y = 3;
 %! aa(2).x = {4, 5};
 %! bb.y = {6, 7};
 %! bb.x = 8;
 %! aa(2) = orderfields (bb, aa);
 %! assert (aa(2).x, 8);
 %! assert (aa(2).y{1}, 6);
+
diff --git a/scripts/miscellaneous/paren.m b/scripts/miscellaneous/paren.m
--- a/scripts/miscellaneous/paren.m
+++ b/scripts/miscellaneous/paren.m
@@ -17,11 +17,12 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Operator} {} (
 ## @deftypefnx {Operator} {} )
 ## Array index or function argument delimeter.
 ## @end deftypefn
 
+
 ## Mark file as being tested.  No real test needed for a documentation .m file
 %!assert (1)
 
diff --git a/scripts/miscellaneous/recycle.m b/scripts/miscellaneous/recycle.m
--- a/scripts/miscellaneous/recycle.m
+++ b/scripts/miscellaneous/recycle.m
@@ -46,21 +46,23 @@ function retval = recycle (state)
       if (strcmpi (state, "on"))
         error ("recycle: recycling files is not implemented");
       elseif (strcmpi (state, "off"))
         current_state = "off";
       else
         error ("recycle: invalid value of STATE = `%s'", state);
       endif
     else
-      error ("recycle: expecting STATE to be a character string");
+      error ("recycle: STATE must be a character string");
     endif
   endif
 
 endfunction
 
-%!error recycle ("on");
-%!error recycle ("on", "and I mean it");
-%!error recycle (1);
 
 %!test
 %! recycle ("off");
 %! assert (recycle ("off"), "off");
+
+%!error <recycling files is not implemented> recycle ("on")
+%!error recycle ("on", "and I mean it")
+%!error <STATE must be a character string> recycle (1)
+
diff --git a/scripts/miscellaneous/rmappdata.m b/scripts/miscellaneous/rmappdata.m
--- a/scripts/miscellaneous/rmappdata.m
+++ b/scripts/miscellaneous/rmappdata.m
@@ -32,13 +32,14 @@ function rmappdata (h, varargin)
   for nh = 1:numel(h)
     appdata = get (h(nh), "__appdata__");
     appdata = rmfield (appdata, varargin);
     set (h(nh), "__appdata__", appdata);
   endfor
 
 endfunction
 
+
 %!test
-%! setappdata (0, "hello", "world")
-%! rmappdata (0, "hello")
-%! assert (isappdata (0, "hello"), false)
+%! setappdata (0, "hello", "world");
+%! rmappdata (0, "hello");
+%! assert (isappdata (0, "hello"), false);
 
diff --git a/scripts/miscellaneous/semicolon.m b/scripts/miscellaneous/semicolon.m
--- a/scripts/miscellaneous/semicolon.m
+++ b/scripts/miscellaneous/semicolon.m
@@ -17,11 +17,12 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Operator} {} ;
 ## Array row or command separator.
 ## @seealso{comma}
 ## @end deftypefn
 
+
 ## Mark file as being tested.  No real test needed for a documentation .m file
 %!assert (1)
 
diff --git a/scripts/miscellaneous/setappdata.m b/scripts/miscellaneous/setappdata.m
--- a/scripts/miscellaneous/setappdata.m
+++ b/scripts/miscellaneous/setappdata.m
@@ -47,13 +47,14 @@ function setappdata (h, varargin)
         error ("setappdata: invalid input");
       endif
     endfor
     set (h(nh), "__appdata__", appdata);
   endfor
 
 endfunction
 
+
 %!test
-%! setappdata (0, "hello", "world")
-%! assert (isappdata (0, "hello"), true)
-%!assert (getappdata (0, "hello"), "world")
+%! setappdata (0, "hello", "world");
+%! assert (isappdata (0, "hello"), true);
+%! assert (getappdata (0, "hello"), "world");
 
diff --git a/scripts/miscellaneous/setfield.m b/scripts/miscellaneous/setfield.m
--- a/scripts/miscellaneous/setfield.m
+++ b/scripts/miscellaneous/setfield.m
@@ -55,17 +55,19 @@ function obj = setfield (obj, varargin)
   if (all (flds | idxs))
     typs = merge (flds, {"."}, {"()"});
     obj = subsasgn (obj, struct ("type", typs, "subs", subs), rhs);
   else
     error ("setfield: invalid index");
   endif
 endfunction
 
+
 %!test
 %! x.a = "hello";
-%! x = setfield(x,"b","world");
-%! y = struct("a","hello","b","world");
-%! assert(x,y);
+%! x = setfield (x, "b", "world");
+%! y = struct ("a", "hello", "b", "world");
+%! assert (x,y);
 %!test
-%! oo(1,1).f0= 1;
-%! oo = setfield(oo,{1,2},"fd",{3},"b", 6);
-%! assert (oo(1,2).fd(3).b, 6)
+%! oo(1,1).f0 = 1;
+%! oo = setfield (oo,{1,2},"fd",{3},"b", 6);
+%! assert (oo(1,2).fd(3).b, 6);
+
diff --git a/scripts/miscellaneous/substruct.m b/scripts/miscellaneous/substruct.m
--- a/scripts/miscellaneous/substruct.m
+++ b/scripts/miscellaneous/substruct.m
@@ -68,22 +68,25 @@ function retval = substruct (varargin)
 
     retval = struct ("type", typ, "subs", sub);
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!test
 %! x(1,1).type = "()";
 %! x(1,2).type = "{}";
 %! x(1,3).type = ".";
 %! x(1,1).subs = {1,2,3};
 %! x(1,2).subs = {":"};
 %! x(1,3).subs = "foo";
 %! y = substruct ("()", {1,2,3}, "{}", {":"}, ".", "foo");
-%! assert(x,y);
-%!error assert(substruct);
-%!error assert(substruct (1, 2, 3));
-%!error assert(substruct ("x", 1));
-%!error assert(substruct ("()", [1,2,3]));
-%!error assert(substruct (".", {1,2,3}));
+%! assert (x,y);
+
+%!error substruct ()
+%!error substruct (1, 2, 3)
+%!error substruct ("x", 1)
+%!error substruct ("()", [1,2,3])
+%!error substruct (".", {1,2,3})
+
diff --git a/scripts/miscellaneous/symvar.m b/scripts/miscellaneous/symvar.m
--- a/scripts/miscellaneous/symvar.m
+++ b/scripts/miscellaneous/symvar.m
@@ -24,10 +24,12 @@
 ## found are returned in a cell array of strings.  If no variables are
 ## found then the returned cell array is empty.
 ## @end deftypefn
 
 function args = symvar (s)
   args = argnames (inline (s));
 endfunction
 
+
 ## This function is tested by the tests for argnames().
 %!assert (1)
+
diff --git a/scripts/miscellaneous/ver.m b/scripts/miscellaneous/ver.m
--- a/scripts/miscellaneous/ver.m
+++ b/scripts/miscellaneous/ver.m
@@ -102,27 +102,28 @@ function varargout = ver (package = "")
       endfor
       ret = ret(n);
     endif
     varargout{1} = ret;
   endif
 
 endfunction
 
+
 %!test
 %! result = ver;
-%! assert (result(1).Name, "Octave")
-%! assert (result(1).Version, version)
+%! assert (result(1).Name, "Octave");
+%! assert (result(1).Version, version);
 %! result = ver ("octave");
-%! assert (result(1).Name, "Octave")
-%! assert (result(1).Version, version)
+%! assert (result(1).Name, "Octave");
+%! assert (result(1).Version, version);
 
 %!test
 %! lst = pkg ("list");
-%! for n=1:numel(lst)
+%! for n = 1:numel (lst)
 %!   expected = lst{n}.name;
 %!   result = ver (expected);
 %!   assert (result.Name, expected);
 %!   assert (isfield (result, "Version"), true);
 %!   assert (isfield (result, "Release"), true);
 %!   assert (isfield (result, "Date"), true);
 %! endfor
 
diff --git a/scripts/miscellaneous/version.m b/scripts/miscellaneous/version.m
--- a/scripts/miscellaneous/version.m
+++ b/scripts/miscellaneous/version.m
@@ -32,12 +32,14 @@ function vs = version ()
   if (nargin != 0)
     warning ("version: ignoring extra arguments");
   endif
 
   vs = OCTAVE_VERSION;
 
 endfunction
 
-%!assert(ischar (version ()) && strcmp (version (), OCTAVE_VERSION));
+
+%!assert (ischar (version ()))
+%!assert (version (), OCTAVE_VERSION)
 
 %!warning version (1);
 
diff --git a/scripts/miscellaneous/warning_ids.m b/scripts/miscellaneous/warning_ids.m
--- a/scripts/miscellaneous/warning_ids.m
+++ b/scripts/miscellaneous/warning_ids.m
@@ -315,10 +315,12 @@
 ## expression.
 ## By default, the @code{Octave:variable-switch-label} warning is disabled.
 ## @end table
 
 function warning_ids ()
   help ("warning_ids");
 endfunction
 
+
 ## Remove from test statistics.  No real tests possible
 %!assert (1)
+
diff --git a/scripts/miscellaneous/xor.m b/scripts/miscellaneous/xor.m
--- a/scripts/miscellaneous/xor.m
+++ b/scripts/miscellaneous/xor.m
@@ -55,17 +55,17 @@ function z = xor (x, y)
       end_try_catch
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
-%!assert((xor ([1, 1, 0, 0], [0, 1, 0, 1]) == [1, 0, 0, 1]
-%! && xor ([i, i, 0, 0], [1, 0, 1, 0]) == [0, 1, 1, 0]));
 
-%!assert(all (all (xor (eye (2), fliplr (eye (2))) == ones (2))));
+%!assert (xor ([1, 1, 0, 0], [0, 1, 0, 1]), logical ([1, 0, 0, 1]))
+%!assert (xor ([i, i, 0, 0], [1, 0, 1, 0]), logical ([0, 1, 1, 0]))
 
-%!error xor ();
+%!assert (xor (eye (2), fliplr (eye (2))), logical (ones (2)))
 
-%!error xor (1, 2, 3);
+%!error xor ()
+%!error xor (1, 2, 3)
 
diff --git a/scripts/optimization/fminbnd.m b/scripts/optimization/fminbnd.m
--- a/scripts/optimization/fminbnd.m
+++ b/scripts/optimization/fminbnd.m
@@ -200,14 +200,16 @@ function fx = guarded_eval (fun, x)
   fx = fx(1);
   if (! isreal (fx))
     error ("fminbnd:notreal", "fminbnd: non-real value encountered");
   elseif (isnan (fx))
     error ("fminbnd:isnan", "fminbnd: NaN value encountered");
   endif
 endfunction
 
+
 %!shared opt0
 %! opt0 = optimset ("tolx", 0);
-%!assert (fminbnd (@cos, pi/2, 3*pi/2, opt0), pi, 10*sqrt(eps))
-%!assert (fminbnd (@(x) (x - 1e-3)^4, -1, 1, opt0), 1e-3, 10e-3*sqrt(eps))
-%!assert (fminbnd (@(x) abs(x-1e7), 0, 1e10, opt0), 1e7, 10e7*sqrt(eps))
-%!assert (fminbnd (@(x) x^2 + sin(2*pi*x), 0.4, 1, opt0), fzero (@(x) 2*x + 2*pi*cos(2*pi*x), [0.4, 1], opt0), sqrt(eps))
+%!assert (fminbnd (@cos, pi/2, 3*pi/2, opt0), pi, 10*sqrt (eps))
+%!assert (fminbnd (@(x) (x - 1e-3)^4, -1, 1, opt0), 1e-3, 10e-3*sqrt (eps))
+%!assert (fminbnd (@(x) abs (x-1e7), 0, 1e10, opt0), 1e7, 10e7*sqrt (eps))
+%!assert (fminbnd (@(x) x^2 + sin (2*pi*x), 0.4, 1, opt0), fzero (@(x) 2*x + 2*pi*cos (2*pi*x), [0.4, 1], opt0), sqrt (eps))
+
diff --git a/scripts/optimization/fsolve.m b/scripts/optimization/fsolve.m
--- a/scripts/optimization/fsolve.m
+++ b/scripts/optimization/fsolve.m
@@ -460,24 +460,24 @@ function [fx, jx] = make_fcn_jac (x, fcn
   endif
 endfunction
 
 %!function retval = __f (p)
 %!  x = p(1);
 %!  y = p(2);
 %!  z = p(3);
 %!  retval = zeros (3, 1);
-%!  retval(1) = sin(x) + y**2 + log(z) - 7;
-%!  retval(2) = 3*x + 2**y -z**3 + 1;
+%!  retval(1) = sin (x) + y^2 + log (z) - 7;
+%!  retval(2) = 3*x + 2^y -z^3 + 1;
 %!  retval(3) = x + y + z - 5;
 %!endfunction
 %!test
 %! x_opt = [ 0.599054;
-%! 2.395931;
-%! 2.005014 ];
+%!           2.395931;
+%!           2.005014 ];
 %! tol = 1.0e-5;
 %! [x, fval, info] = fsolve (@__f, [ 0.5; 2.0; 2.5 ]);
 %! assert (info > 0);
 %! assert (norm (x - x_opt, Inf) < tol);
 %! assert (norm (fval) < tol);
 
 %!function retval = __f (p)
 %!  x = p(1);
@@ -486,56 +486,57 @@ endfunction
 %!  w = p(4);
 %!  retval = zeros (4, 1);
 %!  retval(1) = 3*x + 4*y + exp (z + w) - 1.007;
 %!  retval(2) = 6*x - 4*y + exp (3*z + w) - 11;
 %!  retval(3) = x^4 - 4*y^2 + 6*z - 8*w - 20;
 %!  retval(4) = x^2 + 2*y^3 + z - w - 4;
 %!endfunction
 %!test
-%! x_opt = [ -0.767297326653401, 0.590671081117440, 1.47190018629642, -1.52719341133957 ];
+%! x_opt = [ -0.767297326653401, 0.590671081117440, ...
+%!            1.47190018629642, -1.52719341133957 ];
 %! tol = 1.0e-5;
 %! [x, fval, info] = fsolve (@__f, [-1, 1, 2, -1]);
 %! assert (info > 0);
 %! assert (norm (x - x_opt, Inf) < tol);
 %! assert (norm (fval) < tol);
 
 %!function retval = __f (p)
 %!  x = p(1);
 %!  y = p(2);
 %!  z = p(3);
 %!  retval = zeros (3, 1);
-%!  retval(1) = sin(x) + y**2 + log(z) - 7;
-%!  retval(2) = 3*x + 2**y -z**3 + 1;
+%!  retval(1) = sin (x) + y^2 + log (z) - 7;
+%!  retval(2) = 3*x + 2^y -z^3 + 1;
 %!  retval(3) = x + y + z - 5;
-%!  retval(4) = x*x + y - z*log(z) - 1.36;
+%!  retval(4) = x*x + y - z*log (z) - 1.36;
 %!endfunction
 %!test
 %! x_opt = [ 0.599054;
-%! 2.395931;
-%! 2.005014 ];
+%!           2.395931;
+%!           2.005014 ];
 %! tol = 1.0e-5;
 %! [x, fval, info] = fsolve (@__f, [ 0.5; 2.0; 2.5 ]);
 %! assert (info > 0);
 %! assert (norm (x - x_opt, Inf) < tol);
 %! assert (norm (fval) < tol);
 
 %!function retval = __f (p)
 %!  x = p(1);
 %!  y = p(2);
 %!  z = p(3);
 %!  retval = zeros (3, 1);
-%!  retval(1) = sin(x) + y**2 + log(z) - 7;
-%!  retval(2) = 3*x + 2**y -z**3 + 1;
+%!  retval(1) = sin (x) + y^2 + log (z) - 7;
+%!  retval(2) = 3*x + 2^y -z^3 + 1;
 %!  retval(3) = x + y + z - 5;
 %!endfunction
 %!test
 %! x_opt = [ 0.599054;
-%! 2.395931;
-%! 2.005014 ];
+%!           2.395931;
+%!           2.005014 ];
 %! tol = 1.0e-5;
 %! opt = optimset ("Updating", "qrp");
 %! [x, fval, info] = fsolve (@__f, [ 0.5; 2.0; 2.5 ], opt);
 %! assert (info > 0);
 %! assert (norm (x - x_opt, Inf) < tol);
 %! assert (norm (fval) < tol);
 
 %!test
@@ -547,17 +548,16 @@ endfunction
 %! c_opt = [a0, b0];
 %! tol = 1e-5;
 %!
 %! [c, fval, info, output] =  fsolve (@(c) (exp(-c(1)*x) + c(2) - y), [0, 0]);
 %! assert (info > 0);
 %! assert (norm (c - c_opt, Inf) < tol);
 %! assert (norm (fval) < norm (noise));
 
-
 %!function y = cfun (x)
 %!  y(1) = (1+i)*x(1)^2 - (1-i)*x(2) - 2;
 %!  y(2) = sqrt (x(1)*x(2)) - (1-2i)*x(3) + (3-4i);
 %!  y(3) = x(1) * x(2) - x(3)^2 + (3+2i);
 %!endfunction
 
 %!test
 %! x_opt = [-1+i, 1-i, 2+i];
diff --git a/scripts/optimization/fzero.m b/scripts/optimization/fzero.m
--- a/scripts/optimization/fzero.m
+++ b/scripts/optimization/fzero.m
@@ -354,10 +354,11 @@ function fx = guarded_eval (fun, x)
     error ("fzero:notreal", "fzero: non-real value encountered");
   elseif (isnan (fx))
     error ("fzero:isnan", "fzero: NaN value encountered");
   endif
 endfunction
 
 %!shared opt0
 %! opt0 = optimset ("tolx", 0);
-%!assert(fzero(@cos, [0, 3], opt0), pi/2, 10*eps)
-%!assert(fzero(@(x) x^(1/3) - 1e-8, [0,1], opt0), 1e-24, 1e-22*eps)
+%!assert (fzero (@cos, [0, 3], opt0), pi/2, 10*eps)
+%!assert (fzero (@(x) x^(1/3) - 1e-8, [0,1], opt0), 1e-24, 1e-22*eps)
+
diff --git a/scripts/optimization/lsqnonneg.m b/scripts/optimization/lsqnonneg.m
--- a/scripts/optimization/lsqnonneg.m
+++ b/scripts/optimization/lsqnonneg.m
@@ -193,19 +193,20 @@ function [x, resnorm, residual, exitflag
   endif
   if (nargout > 5)
     lambda = zeros (size (x));
     lambda(p) = w;
   endif
 
 endfunction
 
-## Tests
+
 %!test
 %! C = [1 0;0 1;2 1];
 %! d = [1;3;-2];
-%! assert (lsqnonneg (C, d), [0;0.5], 100*eps)
+%! assert (lsqnonneg (C, d), [0;0.5], 100*eps);
 
 %!test
 %! C = [0.0372 0.2869;0.6861 0.7071;0.6233 0.6245;0.6344 0.6170];
 %! d = [0.8587;0.1781;0.0747;0.8405];
 %! xnew = [0;0.6929];
-%! assert (lsqnonneg (C, d), xnew, 0.0001)
+%! assert (lsqnonneg (C, d), xnew, 0.0001);
+
diff --git a/scripts/optimization/optimset.m b/scripts/optimization/optimset.m
--- a/scripts/optimization/optimset.m
+++ b/scripts/optimization/optimset.m
@@ -136,13 +136,13 @@ function retval = optimset (varargin)
     retval = optimset (struct (), cell2struct (pairs(2, :), pairs(1, :), 2));
   else
     print_usage ();
   endif
 
 endfunction
 
 
-%!assert (optimget (optimset ('tolx', 1e-2), 'tOLx'), 1e-2)
-%!assert (isfield (optimset ('tolFun', 1e-3), 'TolFun'))
+%!assert (optimget (optimset ("tolx", 1e-2), "tOLx"), 1e-2)
+%!assert (isfield (optimset ("tolFun", 1e-3), "TolFun"))
 
 %!error (optimset ("%NOT_A_REAL_FUNCTION_NAME%"))
 
diff --git a/scripts/optimization/pqpnonneg.m b/scripts/optimization/pqpnonneg.m
--- a/scripts/optimization/pqpnonneg.m
+++ b/scripts/optimization/pqpnonneg.m
@@ -193,19 +193,20 @@ function [x, minval, exitflag, output, l
   endif
   if (nargout > 4)
     lambda = zeros (size (x));
     lambda(p) = w;
   endif
 
 endfunction
 
-## Tests
+
 %!test
 %! C = [5 2;2 2];
 %! d = [3; -1];
-%! assert (pqpnonneg (C, d), [0;0.5], 100*eps)
+%! assert (pqpnonneg (C, d), [0;0.5], 100*eps);
 
 ## Test equivalence of lsq and pqp
 %!test
 %! C = rand (20, 10);
 %! d = rand (20, 1);
-%! assert (pqpnonneg (C'*C, -C'*d), lsqnonneg (C, d), 100*eps)
+%! assert (pqpnonneg (C'*C, -C'*d), lsqnonneg (C, d), 100*eps);
+
diff --git a/scripts/optimization/sqp.m b/scripts/optimization/sqp.m
--- a/scripts/optimization/sqp.m
+++ b/scripts/optimization/sqp.m
@@ -728,54 +728,56 @@ function report (iter, qp_iter, alpha, n
   if (nargin == 0)
     printf ("  Itn ItQP     Step  Nfun     Objective\n");
   else
     printf ("%5d %4d %8.1g %5d %13.6e\n", iter, qp_iter, alpha, nfun, obj);
   endif
 
 endfunction
 
+
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %% Test Code
 
 %!function r = __g (x)
 %!  r = [sumsq(x)-10;
 %!       x(2)*x(3)-5*x(4)*x(5);
 %!       x(1)^3+x(2)^3+1 ];
 %!endfunction
 %!
 %!function obj = __phi (x)
-%!  obj = exp(prod(x)) - 0.5*(x(1)^3+x(2)^3+1)^2;
+%!  obj = exp (prod (x)) - 0.5*(x(1)^3 + x(2)^3 + 1)^2;
 %!endfunction
 %!
 %!test
 %!
 %! x0 = [-1.8; 1.7; 1.9; -0.8; -0.8];
 %!
 %! [x, obj, info, iter, nf, lambda] = sqp (x0, @__phi, @__g, []);
 %!
 %! x_opt = [-1.717143501952599;
 %!           1.595709610928535;
 %!           1.827245880097156;
 %!          -0.763643103133572;
 %!          -0.763643068453300];
 %!
 %! obj_opt = 0.0539498477702739;
 %!
-%! assert (all (abs (x-x_opt) < 5*sqrt (eps)) && abs (obj-obj_opt) < sqrt (eps));
+%! assert (x, x_opt, 5*sqrt (eps));
+%! assert (obj, obj_opt, sqrt (eps));
 
 %% Test input validation
 %!error sqp ()
 %!error sqp (1)
 %!error sqp (1,2,3,4,5,6,7,8,9)
 %!error sqp (1,2,3,4,5)
-%!error sqp (ones(2,2))
-%!error sqp (1,cell(4,1))
-%!error sqp (1,cell(3,1),cell(3,1))
-%!error sqp (1,cell(3,1),cell(2,1),cell(3,1))
-%!error sqp (1,cell(3,1),cell(2,1),cell(2,1),ones(2,2),[])
-%!error sqp (1,cell(3,1),cell(2,1),cell(2,1),[],ones(2,2))
-%!error sqp (1,cell(3,1),cell(2,1),cell(2,1),1,-1)
-%!error sqp (1,cell(3,1),cell(2,1),cell(2,1),[],[],ones(2,2))
-%!error sqp (1,cell(3,1),cell(2,1),cell(2,1),[],[],-1)
-%!error sqp (1,cell(3,1),cell(2,1),cell(2,1),[],[],1.5)
-%!error sqp (1,cell(3,1),cell(2,1),cell(2,1),[],[],[],ones(2,2))
-%!error sqp (1,cell(3,1),cell(2,1),cell(2,1),[],[],[],-1)
+%!error sqp (ones (2,2))
+%!error sqp (1, cell (4,1))
+%!error sqp (1, cell (3,1), cell (3,1))
+%!error sqp (1, cell (3,1), cell (2,1), cell (3,1))
+%!error sqp (1, cell (3,1), cell (2,1), cell (2,1), ones (2,2),[])
+%!error sqp (1, cell (3,1), cell (2,1), cell (2,1),[], ones (2,2))
+%!error sqp (1, cell (3,1), cell (2,1), cell (2,1),1,-1)
+%!error sqp (1, cell (3,1), cell (2,1), cell (2,1),[],[], ones (2,2))
+%!error sqp (1, cell (3,1), cell (2,1), cell (2,1),[],[],-1)
+%!error sqp (1, cell (3,1), cell (2,1), cell (2,1),[],[],1.5)
+%!error sqp (1, cell (3,1), cell (2,1), cell (2,1),[],[],[], ones (2,2))
+%!error sqp (1, cell (3,1), cell (2,1), cell (2,1),[],[],[],-1)
diff --git a/scripts/path/matlabroot.m b/scripts/path/matlabroot.m
--- a/scripts/path/matlabroot.m
+++ b/scripts/path/matlabroot.m
@@ -27,10 +27,11 @@
 
 function retval = matlabroot ()
 
   retval = OCTAVE_HOME;
 
 endfunction
 
 
-%!assert (matlabroot(), OCTAVE_HOME())
 
+%!assert (matlabroot (), OCTAVE_HOME ())
+
diff --git a/scripts/plot/__gnuplot_drawnow__.m b/scripts/plot/__gnuplot_drawnow__.m
--- a/scripts/plot/__gnuplot_drawnow__.m
+++ b/scripts/plot/__gnuplot_drawnow__.m
@@ -385,8 +385,9 @@ function retval = have_non_legend_axes (
       retval = (n_all_axes - n_legend_axes) > 1;
     endif
   endif
 endfunction
 
 
 ## No test needed for internal helper function.
 %!assert (1)
+
diff --git a/scripts/plot/__plt_get_axis_arg__.m b/scripts/plot/__plt_get_axis_arg__.m
--- a/scripts/plot/__plt_get_axis_arg__.m
+++ b/scripts/plot/__plt_get_axis_arg__.m
@@ -75,8 +75,9 @@ function [h, varargin, narg] = __plt_get
 
   narg = length (varargin);
 
 endfunction
 
 
 ## No test needed for internal helper function.
 %!assert (1)
+
diff --git a/scripts/plot/ancestor.m b/scripts/plot/ancestor.m
--- a/scripts/plot/ancestor.m
+++ b/scripts/plot/ancestor.m
@@ -70,17 +70,19 @@ function p = ancestor (h, type, toplevel
       error ("ancestor: second argument must be a string or cell array of strings");
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   l = line;
 %!   assert (ancestor (l, "axes"), gca);
 %!   assert (ancestor (l, "figure"), hf);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/cla.m b/scripts/plot/cla.m
--- a/scripts/plot/cla.m
+++ b/scripts/plot/cla.m
@@ -84,19 +84,21 @@ function cla (varargin)
   axes (hax);
   axis ("auto");
 
   ## Set the current axis back to where it was upon entry.
   axes (oldhax);
 
 endfunction
 
+
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
-%!   plot (1:10)
-%!   cla ()
+%!   plot (1:10);
+%!   cla ();
 %!   kids = get (gca, "children");
-%!   cla ()
+%!   cla ();
 %! unwind_protect_cleanup
-%!   close (hf)
+%!   close (hf);
 %! end_unwind_protect
-%! assert (numel (kids), 0)
+%! assert (numel (kids), 0);
+
diff --git a/scripts/plot/clf.m b/scripts/plot/clf.m
--- a/scripts/plot/clf.m
+++ b/scripts/plot/clf.m
@@ -84,17 +84,17 @@ function retval = clf (varargin)
 
 endfunction
 
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   l = line;
-%!   assert (!isempty (get (gcf, "children")));
+%!   assert (! isempty (get (gcf, "children")));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   clf;
diff --git a/scripts/plot/close.m b/scripts/plot/close.m
--- a/scripts/plot/close.m
+++ b/scripts/plot/close.m
@@ -75,19 +75,21 @@ function close_all_figures (close_hidden
     ## handlevisibility = get (fig, "handlevisibility")
     ## if (close_hidden_figs || ! strcmpi (handlevisibility, "off"))
     close (fig);
     ## endif
   endwhile
 
 endfunction
 
+
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   close (hf);
 %!   objs = findobj ("type", "figure");
 %!   assert (isempty (intersect (objs, hf)));
 %! unwind_protect_cleanup
 %!   if (isfigure (hf))
 %!     close (hf);
 %!   endif
 %! end_unwind_protect
+
diff --git a/scripts/plot/colorbar.m b/scripts/plot/colorbar.m
--- a/scripts/plot/colorbar.m
+++ b/scripts/plot/colorbar.m
@@ -377,17 +377,17 @@ endfunction
 %! imagesc (x);
 %! colorbar ('westoutside');
 
 %!demo
 %! clf;
 %! colormap ('default');
 %! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
 %! imagesc (x);
-%! colorbar ('peer', gca (), 'northoutside');
+%! colorbar ('peer', gca, 'northoutside');
 
 %!demo
 %! clf;
 %! colormap ('default');
 %! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
 %! imagesc (x);
 %! colorbar ('southoutside');
 
diff --git a/scripts/plot/colstyle.m b/scripts/plot/colstyle.m
--- a/scripts/plot/colstyle.m
+++ b/scripts/plot/colstyle.m
@@ -59,16 +59,17 @@ function [l, c, m, msg] = colstyle (styl
     endswitch
   catch
     l = c = m = [];
     msg = lasterr ();
   end_try_catch
 
 endfunction
 
+
 %!test
 %! [l, c, m, msg] = colstyle ("r:x");
 %! assert (isempty (msg));
 %! assert (l, ":");
 %! assert (c, "r");
 %! assert (m, "x");
 
 %!test
diff --git a/scripts/plot/comet3.m b/scripts/plot/comet3.m
--- a/scripts/plot/comet3.m
+++ b/scripts/plot/comet3.m
@@ -79,10 +79,10 @@ function comet3 (varargin)
   end_unwind_protect
 
 endfunction
 
 
 %!demo
 %! clf;
 %! t = 0:pi/20:5*pi;
-%! comet3 (cos(t), sin(t), t, 0.01);
+%! comet3 (cos (t), sin (t), t, 0.01);
 
diff --git a/scripts/plot/contourc.m b/scripts/plot/contourc.m
--- a/scripts/plot/contourc.m
+++ b/scripts/plot/contourc.m
@@ -135,19 +135,19 @@ function [cout, lev] = contourc (varargi
 
   if (nargout > 0)
     cout = c;
     lev = vv;
   endif
 
 endfunction
 
+
 %!test
 %! x = 0:2;
 %! y = x;
 %! z = x' * y;
 %! [c_actual, lev_actual]= contourc (x, y, z, 2:3);
 %! c_expected = [2, 1, 1, 2, 2, 3, 1.5, 2; 4, 2, 2, 1, 1, 2, 2, 1.5];
 %! lev_expected = [2 3];
-%! assert (c_actual, c_expected, eps)
-%! assert (lev_actual, lev_expected, eps)
+%! assert (c_actual, c_expected, eps);
+%! assert (lev_actual, lev_expected, eps);
 
-
diff --git a/scripts/plot/figure.m b/scripts/plot/figure.m
--- a/scripts/plot/figure.m
+++ b/scripts/plot/figure.m
@@ -91,16 +91,18 @@ function h = figure (varargin)
   endif
 
   if (nargout > 0)
     h = f;
   endif
 
 endfunction
 
+
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   assert (gcf, hf);
 %!   assert (isfigure (hf));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/gca.m b/scripts/plot/gca.m
--- a/scripts/plot/gca.m
+++ b/scripts/plot/gca.m
@@ -45,16 +45,18 @@ function h = gca ()
       h = axes ();
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!test
 %! hf = figure ("visible", "off");
 %! ax = axes;
 %! unwind_protect
 %!   assert (gca, ax);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/gcbf.m b/scripts/plot/gcbf.m
--- a/scripts/plot/gcbf.m
+++ b/scripts/plot/gcbf.m
@@ -27,10 +27,11 @@
 ##@end deftypefn
 
 function fig = gcbf ()
 
   [dummy, fig] = gcbo ();
 
 endfunction
 
-%!test
-%! assert (isempty (gcbf ));
+
+%!assert (isempty (gcbf))
+
diff --git a/scripts/plot/gcbo.m b/scripts/plot/gcbo.m
--- a/scripts/plot/gcbo.m
+++ b/scripts/plot/gcbo.m
@@ -37,10 +37,12 @@ function [h, fig] = gcbo ()
   fig = [];
 
   if (! isempty (h) && nargout > 1)
     fig = ancestor (h, "figure");
   endif
 
 endfunction
 
+
 %!test
-%! assert (isempty (gcbo ));
+%! assert (isempty (gcbo));
+
diff --git a/scripts/plot/gcf.m b/scripts/plot/gcf.m
--- a/scripts/plot/gcf.m
+++ b/scripts/plot/gcf.m
@@ -49,15 +49,17 @@ function h = gcf ()
       h = figure (1);
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   assert (gcf, hf);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/ginput.m b/scripts/plot/ginput.m
--- a/scripts/plot/ginput.m
+++ b/scripts/plot/ginput.m
@@ -38,11 +38,13 @@ function varargout = ginput (n)
   if (nargin == 0)
     [varargout{:}] = feval (strcat ("__", toolkit, "_ginput__"), f);
   else
     [varargout{:}] = feval (strcat ("__", toolkit, "_ginput__"), f, n);
   endif
 
 endfunction
 
+
 ## Remove from test statistics.  No real tests possible.
 %!test
 %! assert (1);
+
diff --git a/scripts/plot/graphics_toolkit.m b/scripts/plot/graphics_toolkit.m
--- a/scripts/plot/graphics_toolkit.m
+++ b/scripts/plot/graphics_toolkit.m
@@ -85,11 +85,11 @@ endfunction
 %!testif HAVE_FLTK
 %! old_toolkit = graphics_toolkit ();
 %! switch old_toolkit
 %!   case {"gnuplot"}
 %!     new_toolkit = "fltk";
 %!   otherwise
 %!     new_toolkit = "gnuplot";
 %! endswitch
-%! assert (graphics_toolkit (new_toolkit), old_toolkit)
-%! assert (graphics_toolkit (old_toolkit), new_toolkit)
+%! assert (graphics_toolkit (new_toolkit), old_toolkit);
+%! assert (graphics_toolkit (old_toolkit), new_toolkit);
 
diff --git a/scripts/plot/gtext.m b/scripts/plot/gtext.m
--- a/scripts/plot/gtext.m
+++ b/scripts/plot/gtext.m
@@ -39,11 +39,12 @@ function gtext (s, varargin)
 
   if (! isempty (s))
     [x, y] = ginput (1);
     text (x, y, s, varargin{:});
   endif
 
 endfunction
 
+
 ## Remove from test statistics.  No real tests possible.
-%!test
-%! assert (1);
+%!assert (1)
+
diff --git a/scripts/plot/hggroup.m b/scripts/plot/hggroup.m
--- a/scripts/plot/hggroup.m
+++ b/scripts/plot/hggroup.m
@@ -37,17 +37,19 @@ function h = hggroup (varargin)
   tmp = __go_hggroup__ (ax, varargin{:});
 
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
 
+
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   h = hggroup;
 %!   assert (findobj (hf, "type", "hggroup"), h);
 %!   assert (get (h, "type"), "hggroup");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/hist.m b/scripts/plot/hist.m
--- a/scripts/plot/hist.m
+++ b/scripts/plot/hist.m
@@ -163,35 +163,36 @@ function [nn, xx] = hist (y, varargin)
   elseif (size (freq, 2) != 1)
     bar (x, freq, 0.8, varargin{iarg:end});
   else
     bar (x, freq, 1.0, varargin{iarg:end});
   endif
 
 endfunction
 
+
 %!test
-%!  [nn,xx]=hist([1:4],3);
-%!  assert(xx, [1.5,2.5,3.5]);
-%!  assert(nn, [2,1,1]);
+%! [nn,xx] = hist ([1:4], 3);
+%! assert (xx, [1.5,2.5,3.5]);
+%! assert (nn, [2,1,1]);
 %!test
-%!  [nn,xx]=hist([1:4]',3);
-%!  assert(xx, [1.5,2.5,3.5]);
-%!  assert(nn, [2,1,1]);
+%! [nn,xx] = hist ([1:4]', 3);
+%! assert (xx, [1.5,2.5,3.5]);
+%! assert (nn, [2,1,1]);
 %!test
-%!  [nn,xx]=hist([1 1 1 NaN NaN NaN 2 2 3],[1 2 3]);
-%!  assert(xx, [1,2,3]);
-%!  assert(nn, [3,2,1]);
+%! [nn,xx] = hist ([1 1 1 NaN NaN NaN 2 2 3],[1 2 3]);
+%! assert (xx, [1,2,3]);
+%! assert (nn, [3,2,1]);
 %!test
-%!  [nn,xx]=hist([[1:4]',[1:4]'],3);
-%!  assert(xx, [1.5;2.5;3.5]);
-%!  assert(nn, [[2,1,1]',[2,1,1]']);
-%!assert(hist(1,1),1);
+%! [nn,xx] = hist ([[1:4]', [1:4]'], 3);
+%! assert (xx, [1.5;2.5;3.5]);
+%! assert (nn, [[2,1,1]',[2,1,1]']);
 %!test
-%!  for n = [10, 30, 100, 1000]
-%!    assert(sum(hist([1:n], n)), n);
-%!    assert(sum(hist([1:n], [2:n-1])), n);
-%!    assert(sum(hist([1:n], [1:n])), n);
-%!    assert(sum(hist([1:n], 29)), n);
-%!    assert(sum(hist([1:n], 30)), n);
-%!  endfor
-%!test
-%!  assert (size (hist(randn(750,240), 200)), [200,240]);
+%! for n = [10, 30, 100, 1000]
+%!   assert (sum (hist ([1:n], n)), n);
+%!   assert (sum (hist ([1:n], [2:n-1])), n);
+%!   assert (sum (hist ([1:n], [1:n])), n);
+%!   assert (sum (hist ([1:n], 29)), n);
+%!   assert (sum (hist ([1:n], 30)), n);
+%! endfor
+%!assert (hist (1,1), 1)
+%!assert (size (hist (randn (750,240), 200)), [200,240])
+
diff --git a/scripts/plot/hold.m b/scripts/plot/hold.m
--- a/scripts/plot/hold.m
+++ b/scripts/plot/hold.m
@@ -146,33 +146,33 @@ endfunction
 ##hold on
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   p = plot ([0 1]);
 %!   assert (! ishold);
 %!   hold on;
 %!   assert (ishold);
-%!   p1 = fill ([0 1 1], [0 0 1],"black");
+%!   p1 = fill ([0 1 1], [0 0 1], "black");
 %!   p2 = fill ([0 1 0], [0 1 1], "red");
 %!   assert (length (get (hf, "children")), 1);
 %!   assert (length (get (gca, "children")), 3);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 ##hold off
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   p = plot ([0 1]);
 %!   assert (! ishold);
 %!   hold on;
 %!   assert (ishold);
-%!   p1 = fill ([0 1 1], [0 0 1],"black");
+%!   p1 = fill ([0 1 1], [0 0 1], "black");
 %!   hold off;
 %!   p2 = fill ([0 1 0], [0 1 1], "red");
 %!   assert (length (get (hf, "children")), 1);
 %!   assert (length (get (gca, "children")), 1);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
diff --git a/scripts/plot/isfigure.m b/scripts/plot/isfigure.m
--- a/scripts/plot/isfigure.m
+++ b/scripts/plot/isfigure.m
@@ -30,16 +30,18 @@ function retval = isfigure (h)
   if (nargin == 1)
     retval = (ishandle (h) && strcmp (get (h, "type"), "figure"));
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   assert (isfigure (hf));
-%!   assert (!isfigure (-hf));
+%!   assert (! isfigure (-hf));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/ishghandle.m b/scripts/plot/ishghandle.m
--- a/scripts/plot/ishghandle.m
+++ b/scripts/plot/ishghandle.m
@@ -22,38 +22,39 @@
 ## @end deftypefn
 
 function retval = ishghandle (h)
   ## This function is just included for compatibility as Octave has
   ## no simulink equivalent.
   retval = ishandle (h);
 endfunction
 
+
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   assert (ishghandle (hf));
-%!   assert (!ishghandle (-hf));
+%!   assert (! ishghandle (-hf));
 %!   l = line;
-%!   ax = gca();
+%!   ax = gca;
 %!   assert (ishghandle (ax));
-%!   assert (!ishghandle (-ax));
+%!   assert (! ishghandle (-ax));
 %!   assert (ishghandle (l));
-%!   assert (!ishghandle (-l));
+%!   assert (! ishghandle (-l));
 %!   p = patch;
 %!   assert (ishghandle (p));
-%!   assert (!ishghandle (-p));
+%!   assert (! ishghandle (-p));
 %!   s = surface;
 %!   assert (ishghandle (s));
-%!   assert (!ishghandle (-s));
+%!   assert (! ishghandle (-s));
 %!   t = text;
 %!   assert (ishghandle (t));
-%!   assert (!ishghandle (-t));
+%!   assert (! ishghandle (-t));
 %!   i = image;
 %!   assert (ishghandle (i));
-%!   assert (!ishghandle (-i));
+%!   assert (! ishghandle (-i));
 %!   hg = hggroup;
 %!   assert (ishghandle (hg));
-%!   assert (!ishghandle (-hg));
+%!   assert (! ishghandle (-hg));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
diff --git a/scripts/plot/ishold.m b/scripts/plot/ishold.m
--- a/scripts/plot/ishold.m
+++ b/scripts/plot/ishold.m
@@ -50,30 +50,32 @@ function retval = ishold (h)
     print_usage ();
   endif
 
   retval = (strcmpi (get (fig, "nextplot"), "add")
             && ! isempty (ax) && strcmpi (get (ax, "nextplot"), "add"));
 
 endfunction
 
+
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
-%!   assert (!ishold);
+%!   assert (! ishold);
 %!   assert (isempty (get (hf, "currentaxes")));
 %!   assert (get (hf, "NextPlot"), "add");
 %!   l = plot ([0 1]);
-%!   assert (!ishold);
-%!   assert (!ishold (gca));
+%!   assert (! ishold);
+%!   assert (! ishold (gca));
 %!   assert (get (gca, "NextPlot"), "replace");
 %!   assert (get (hf, "NextPlot"), "add");
 %!   hold;
 %!   assert (ishold);
 %!   assert (ishold (gca));
 %!   assert (get (gca, "NextPlot"), "add");
 %!   assert (get (hf, "NextPlot"), "add");
 %!   p = fill ([0 1 1], [0 0 1],"black");
 %!   assert (length (get (hf, "children")), 1);
 %!   assert (length (get (gca, "children")), 2);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/isocolors.m b/scripts/plot/isocolors.m
--- a/scripts/plot/isocolors.m
+++ b/scripts/plot/isocolors.m
@@ -158,15 +158,17 @@ function varargout = isocolors(varargin)
       endif
     case 1
       varargout = {new_col};
     otherwise
       print_usage ();
   endswitch
 endfunction
 
+
 %!test
-%!  [x, y, z] = meshgrid (0:.5:2, 0:.5:2, 0:.5:2);
-%!  c = (x-.5).^2 + (y-.5).^2 + (z-.5).^2;
-%!  [f, v] = isosurface (x, y, z, c, .4);
-%!  cdat = isocolors (x, y, z, c, v);
-%!  assert (size (cdat, 1) == size (v, 1));
+%! [x, y, z] = meshgrid (0:.5:2, 0:.5:2, 0:.5:2);
+%! c = (x-.5).^2 + (y-.5).^2 + (z-.5).^2;
+%! [f, v] = isosurface (x, y, z, c, .4);
+%! cdat = isocolors (x, y, z, c, v);
+%! assert (rows (cdat) == rows (v));
 ## Can't create a patch handle for tests without a figure
+
diff --git a/scripts/plot/isonormals.m b/scripts/plot/isonormals.m
--- a/scripts/plot/isonormals.m
+++ b/scripts/plot/isonormals.m
@@ -143,21 +143,23 @@ function varargout = isonormals(varargin
       endif
     case 1
       varargout = {normals};
     otherwise
       print_usage ();
   endswitch
 endfunction
 
+
 %!test
-%!  [x, y, z] = meshgrid (0:.5:2, 0:.5:2, 0:.5:2);
-%!  c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
-%!  [f, v, cdat] = isosurface (x, y, z, c, .4, y);
-%!  n = isonormals (x, y, z, c, v);
-%!  assert (size (v), size (n));
+%! [x, y, z] = meshgrid (0:.5:2, 0:.5:2, 0:.5:2);
+%! c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
+%! [f, v, cdat] = isosurface (x, y, z, c, .4, y);
+%! n = isonormals (x, y, z, c, v);
+%! assert (size (v), size (n));
 %!test
-%!  [x, y, z] = meshgrid (0:.5:2, 0:.5:2, 0:.5:2);
-%!  c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
-%!  [f, v, cdat] = isosurface (x, y, z, c, .4, y);
-%!  np = isonormals (x, y, z, c, v);
-%!  nn = isonormals (x, y, z, c, v, "negate");
-%!  assert (all (np == -nn));
+%! [x, y, z] = meshgrid (0:.5:2, 0:.5:2, 0:.5:2);
+%! c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
+%! [f, v, cdat] = isosurface (x, y, z, c, .4, y);
+%! np = isonormals (x, y, z, c, v);
+%! nn = isonormals (x, y, z, c, v, "negate");
+%! assert (np, -nn);
+
diff --git a/scripts/plot/isosurface.m b/scripts/plot/isosurface.m
--- a/scripts/plot/isosurface.m
+++ b/scripts/plot/isosurface.m
@@ -192,35 +192,35 @@ endfunction
 
 %!demo
 %! clf;
 %! [x,y,z] = meshgrid (-2:0.5:2, -2:0.5:2, -2:0.5:2);
 %! v = x.^2 + y.^2 + z.^2;
 %! isosurface (x, y, z, v, 1);
 
 %!shared x, y, z, val
-%!  [x, y, z]  = meshgrid (0:1, 0:1, 0:1); %% Points for single
-%!  val        = [0, 0; 0, 0];             %% cube and a 3-D
-%!  val(:,:,2) = [0, 0; 1, 0];             %% array of values
+%! [x, y, z]  = meshgrid (0:1, 0:1, 0:1); %% Points for single
+%! val        = [0, 0; 0, 0];             %% cube and a 3-D
+%! val(:,:,2) = [0, 0; 1, 0];             %% array of values
 %!test
-%!  fv = isosurface (x, y, z, val, 0.3);
-%!  assert (isfield (fv, "vertices"), true);
-%!  assert (isfield (fv, "faces"), true);
-%!  assert (size (fv.vertices), [3 3]);
-%!  assert (size (fv.faces), [1 3]);
+%! fv = isosurface (x, y, z, val, 0.3);
+%! assert (isfield (fv, "vertices"), true);
+%! assert (isfield (fv, "faces"), true);
+%! assert (size (fv.vertices), [3 3]);
+%! assert (size (fv.faces), [1 3]);
 %!test
-%!  fvc = isosurface (x, y, z, val, .3, y);
-%!  assert (isfield (fvc, "vertices"), true);
-%!  assert (isfield (fvc, "faces"), true);
-%!  assert (isfield (fvc, "facevertexcdata"), true);
-%!  assert (size (fvc.vertices), [3 3]);
-%!  assert (size (fvc.faces), [1 3]);
-%!  assert (size (fvc.facevertexcdata), [3 1]);
+%! fvc = isosurface (x, y, z, val, .3, y);
+%! assert (isfield (fvc, "vertices"), true);
+%! assert (isfield (fvc, "faces"), true);
+%! assert (isfield (fvc, "facevertexcdata"), true);
+%! assert (size (fvc.vertices), [3 3]);
+%! assert (size (fvc.faces), [1 3]);
+%! assert (size (fvc.facevertexcdata), [3 1]);
 %!test
-%!  [f, v] = isosurface (x, y, z, val, .3);
-%!  assert (size (f), [1 3]);
-%!  assert (size (v), [3 3]);
+%! [f, v] = isosurface (x, y, z, val, .3);
+%! assert (size (f), [1 3]);
+%! assert (size (v), [3 3]);
 %!test
-%!  [f, v, c] = isosurface (x, y, z, val, .3, y);
-%!  assert (size (f), [1 3]);
-%!  assert (size (v), [3 3]);
-%!  assert (size (c), [3 1]);
+%! [f, v, c] = isosurface (x, y, z, val, .3, y);
+%! assert (size (f), [1 3]);
+%! assert (size (v), [3 3]);
+%! assert (size (c), [3 1]);
 
diff --git a/scripts/plot/isprop.m b/scripts/plot/isprop.m
--- a/scripts/plot/isprop.m
+++ b/scripts/plot/isprop.m
@@ -42,14 +42,13 @@ function res = isprop (h, prop)
     try
       v = get (h(n), prop);
     catch
       res(n) = false;
     end_try_catch
   endfor
 endfunction
 
+
 %!assert (isprop (0, "foobar"), false)
-
 %!assert (isprop (0, "screenpixelsperinch"), true)
-
 %!assert (isprop (zeros (2, 3), "visible"), true (2, 3))
 
diff --git a/scripts/plot/legend.m b/scripts/plot/legend.m
--- a/scripts/plot/legend.m
+++ b/scripts/plot/legend.m
@@ -1030,17 +1030,17 @@ endfunction
 %! title ('a very long label can sometimes cause problems');
 %! legend ('hello world', 'location', 'northeastoutside');
 
 %!demo
 %! clf;
 %! labels = {};
 %! colororder = get (gca, 'colororder');
 %! for i = 1:5
-%!   h = plot (1:100, i + rand(100,1)); hold on;
+%!   h = plot (1:100, i + rand (100,1)); hold on;
 %!   set (h, 'color', colororder(i,:));
 %!   labels = {labels{:}, ['Signal ', num2str(i)]};
 %! end
 %! hold off;
 %! title ('Signals with random offset and uniform noise');
 %! xlabel ('Sample Nr [k]'); ylabel ('Amplitude [V]');
 %! legend (labels, 'location', 'southoutside');
 %! legend ('boxon');
@@ -1096,62 +1096,62 @@ endfunction
 %! legend ('1st Bar', '2nd Bar', '3rd Bar');
 %! legend right;
 
 %!demo
 %! clf;
 %! x = 0:0.1:7;
 %! h = plot (x,sin(x), x,cos(x), x,sin(x.^2/10), x,cos(x.^2/10));
 %! title ('Only the sin() objects have keylabels');
-%! legend (h([1, 3]), {'sin(x)', 'sin(x^2/10)'}, 'location', 'southwest');
+%! legend (h([1, 3]), {'sin (x)', 'sin (x^2/10)'}, 'location', 'southwest');
 
 %!demo
 %! clf;
 %! x = 0:0.1:10;
-%! plot (x, sin(x), ';sin(x);');
+%! plot (x, sin (x), ';sin (x);');
 %! hold all;
-%! plot (x, cos(x), ';cos(x);');
+%! plot (x, cos (x), ';cos (x);');
 %! hold off;
 
 %!demo
 %! clf;
 %! x = 0:0.1:10;
-%! plot (x, sin(x), ';sin(x);');
+%! plot (x, sin (x), ';sin (x);');
 %! hold all;
-%! plot (x, cos(x), ';cos(x);');
+%! plot (x, cos (x), ';cos (x);');
 %! hold off;
-%! legend ({'sin(x)', 'cos(x)'}, 'location', 'northeastoutside');
+%! legend ({'sin (x)', 'cos (x)'}, 'location', 'northeastoutside');
 
 %!demo
 %! clf;
 %! x = 0:10;
 %! plot (x, rand (11));
 %! xlabel ('Indices');
 %! ylabel ('Random Values');
 %! title ('Legend ''off'' should delete the legend');
 %! legend (cellstr (num2str ((1:10)')), 'location', 'northeastoutside');
 %! legend off;
 %! axis ([0, 10, 0 1]);
 
 %!demo
 %! clf;
 %! x = (1:5)';
-%! subplot (2, 2, 1);
+%! subplot (2,2,1);
 %!  plot (x, rand (numel (x)));
 %!  legend (cellstr (num2str (x)), 'location', 'northwestoutside');
 %!  legend boxon;
-%! subplot (2, 2, 2);
+%! subplot (2,2,2);
 %!  plot (x, rand (numel (x)));
 %!  legend (cellstr (num2str (x)), 'location', 'northeastoutside');
 %!  legend boxon;
-%! subplot (2, 2, 3);
+%! subplot (2,2,3);
 %!  plot (x, rand (numel (x)));
 %!  legend (cellstr (num2str (x)), 'location', 'southwestoutside');
 %!  legend boxon;
-%! subplot (2, 2, 4);
+%! subplot (2,2,4);
 %!  plot (x, rand (numel (x)));
 %!  legend (cellstr (num2str (x)), 'location', 'southeastoutside');
 %!  legend boxon;
 
 %!demo
 %! clf;
 %! plot (rand (2));
 %! title ('Warn of extra labels');
diff --git a/scripts/plot/line.m b/scripts/plot/line.m
--- a/scripts/plot/line.m
+++ b/scripts/plot/line.m
@@ -52,8 +52,9 @@ endfunction
 %!   assert (get (h, "ydata"), [0 1], eps);
 %!   assert (get (h, "type"), "line");
 %!   assert (get (h, "color"), get (0, "defaultlinecolor"));
 %!   assert (get (h, "linestyle"), get (0, "defaultlinelinestyle"));
 %!   assert (get (h, "linewidth"), get (0, "defaultlinelinewidth"), eps);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/loglog.m b/scripts/plot/loglog.m
--- a/scripts/plot/loglog.m
+++ b/scripts/plot/loglog.m
@@ -62,17 +62,17 @@ function retval = loglog (varargin)
 
 endfunction
 
 
 %!demo
 %! clf;
 %! t = 1:0.01:10;
 %! x = sort ((t .* (1 + rand (size (t)))) .^ 2);
-%! y = ((t .* (1 + rand (size (t)))) .^ 2);
+%! y = (t .* (1 + rand (size (t)))) .^ 2;
 %! loglog (x, y);
 
 %!demo
 %! clf;
 %! a = logspace (-5, 1, 10);
 %! b =-logspace (-5, 1, 10);
 %!
 %! subplot (1,2,1);
diff --git a/scripts/plot/loglogerr.m b/scripts/plot/loglogerr.m
--- a/scripts/plot/loglogerr.m
+++ b/scripts/plot/loglogerr.m
@@ -58,15 +58,15 @@ function retval = loglogerr (varargin)
     axes (oldh);
   end_unwind_protect
 
 endfunction
 
 
 %!demo
 %! clf;
-%! x = exp (log(0.01):0.2:log(10));
+%! x = exp (log (0.01):0.2:log (10));
 %! y = wblpdf (x, 3, 2);
 %! eyu = 2*rand (size (y)) .* y;
 %! eyl = 0.5*rand (size (y)) .* y;
 %! loglogerr (x, y, eyl, eyu, '#~x-');
 %! xlim (x([1, end]));
 
diff --git a/scripts/plot/meshgrid.m b/scripts/plot/meshgrid.m
--- a/scripts/plot/meshgrid.m
+++ b/scripts/plot/meshgrid.m
@@ -66,16 +66,17 @@ function [xx, yy, zz] = meshgrid (x, y, 
        zz = reshape (repmat (z(:).', lenx*leny, 1)(:), leny, lenx, lenz);
     else
       error ("meshgrid: arguments must be vectors");
     endif
   endif
 
 endfunction
 
+
 %!test
 %! x = 1:2;
 %! y = 1:3;
 %! z = 1:4;
 %! [XX, YY, ZZ] = meshgrid (x, y, z);
 %! assert (size_equal (XX, YY, ZZ));
 %! assert (ndims (XX), 3);
 %! assert (size (XX), [3, 2, 4]);
@@ -95,9 +96,10 @@ endfunction
 %!test
 %! x = 1:3;
 %! [XX1, YY1] = meshgrid (x, x);
 %! [XX2, YY2] = meshgrid (x);
 %! assert (size_equal (XX1, XX2, YY1, YY2));
 %! assert (ndims (XX1), 2);
 %! assert (size (XX1), [3, 3]);
 %! assert (XX1, XX2);
-%! assert (YY1, YY2);
\ No newline at end of file
+%! assert (YY1, YY2);
+
diff --git a/scripts/plot/ndgrid.m b/scripts/plot/ndgrid.m
--- a/scripts/plot/ndgrid.m
+++ b/scripts/plot/ndgrid.m
@@ -65,16 +65,17 @@ function varargout = ndgrid (varargin)
     s = shape;
     s(i) = 1;
 
     varargout{i} = repmat (reshape (varargin{i}, r), s);
   endfor
 
 endfunction
 
+
 %!test
 %! x = 1:2;
 %! y = 1:3;
 %! z = 1:4;
 %! [XX, YY, ZZ] = ndgrid (x, y, z);
 %! assert (size_equal (XX, YY, ZZ));
 %! assert (ndims (XX), 3);
 %! assert (size (XX), [2, 3, 4]);
@@ -90,8 +91,9 @@ endfunction
 %! assert (size_equal (XX2, YY2));
 %! assert (ndims (XX1), 2);
 %! assert (size (XX1), [3, 2]);
 %! assert (size (XX2), [2, 3]);
 %! assert (XX2(1) * YY2(1), x(1) * y(1));
 %! assert (XX2(end) * YY2(end), x(end) * y(end));
 %! assert (XX1, XX2.');
 %! assert (YY1, YY2.');
+
diff --git a/scripts/plot/newplot.m b/scripts/plot/newplot.m
--- a/scripts/plot/newplot.m
+++ b/scripts/plot/newplot.m
@@ -60,17 +60,19 @@ function newplot ()
         error ("newplot: unrecognized nextplot property for current axes");
     endswitch
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   p = plot ([0, 1]);
 %!   newplot;
 %!   assert (isempty (get (gca, "children")));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/orient.m b/scripts/plot/orient.m
--- a/scripts/plot/orient.m
+++ b/scripts/plot/orient.m
@@ -65,45 +65,47 @@ function retval = orient (varargin)
       error ("orient: unknown ORIENTATION");
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!shared papersize, paperposition, tallpaperposition, hfig
-%!  papersize = [8.5, 11];
-%!  paperposition = [0.25, 2.5, 8, 6];
-%!  tallpaperposition = [0.25, 0.25, (papersize-0.5)];
-%!  hfig = figure ();
-%!  set (hfig, "visible", "off")
-%!  set (hfig, "paperorientation", "portrait")
-%!  set (hfig, "papersize", papersize)
-%!  set (hfig, "paperposition", paperposition)
+%! papersize = [8.5, 11];
+%! paperposition = [0.25, 2.5, 8, 6];
+%! tallpaperposition = [0.25, 0.25, (papersize-0.5)];
+%! hfig = figure ();
+%! set (hfig, "visible", "off");
+%! set (hfig, "paperorientation", "portrait");
+%! set (hfig, "papersize", papersize);
+%! set (hfig, "paperposition", paperposition);
 %!test
-%!  orient portrait
-%!  assert (orient, "portrait") # default
-%!  assert (get (hfig, "papersize"), papersize)
-%!  assert (get (hfig, "paperposition"), paperposition)
+%! orient portrait;
+%! assert (orient, "portrait")   # default
+%! assert (get (hfig, "papersize"), papersize);
+%! assert (get (hfig, "paperposition"), paperposition);
 %!test
-%!  orient landscape
-%!  assert (orient,"landscape") # change to landscape
-%!  assert (get (hfig, "papersize"), papersize([2, 1]))
-%!  assert (get (hfig, "paperposition"), paperposition([2, 1, 4, 3]))
+%! orient landscape;
+%! assert (orient,"landscape")   # change to landscape
+%! assert (get (hfig, "papersize"), papersize([2, 1]));
+%! assert (get (hfig, "paperposition"), paperposition([2, 1, 4, 3]));
 %!test
-%!  orient portrait # change back to portrait
-%!  assert (orient, "portrait")
-%!  assert (get (hfig, "papersize"), papersize)
-%!  assert (get (hfig, "paperposition"), paperposition)
+%! orient portrait   # change back to portrait
+%! assert (orient, "portrait");
+%! assert (get (hfig, "papersize"), papersize);
+%! assert (get (hfig, "paperposition"), paperposition);
 %!test
-%!  orient landscape
-%!  orient tall
-%!  assert (orient, "portrait")
-%!  assert (get (hfig, "papersize"), papersize)
-%!  assert (get (hfig, "paperposition"), tallpaperposition)
+%! orient landscape;
+%! orient tall;
+%! assert (orient, "portrait");
+%! assert (get (hfig, "papersize"), papersize);
+%! assert (get (hfig, "paperposition"), tallpaperposition);
 %!fail ("orient ('nobody')", "unknown ORIENTATION")
 %!test
-%!  orient portrait # errors don't change the state
-%!  assert (orient, "portrait")
-%!  assert (get (hfig, "papersize"), papersize)
-%!  assert (get (hfig, "paperposition"), tallpaperposition)
-%!  close (hfig)
+%! orient portrait   # errors don't change the state
+%! assert (orient, "portrait");
+%! assert (get (hfig, "papersize"), papersize);
+%! assert (get (hfig, "paperposition"), tallpaperposition);
+%! close (hfig);
+
diff --git a/scripts/plot/patch.m b/scripts/plot/patch.m
--- a/scripts/plot/patch.m
+++ b/scripts/plot/patch.m
@@ -101,28 +101,28 @@ endfunction
 %! t1 = (1/16:1/8:1)' * 2*pi;
 %! t2 = ((1/16:1/16:1)' + 1/32) * 2*pi;
 %! x1 = sin (t1) - 0.8;
 %! y1 = cos (t1);
 %! x2 = sin (t2) + 0.8;
 %! y2 = cos (t2);
 %! vert = [x1, y1; x2, y2];
 %! fac = [1:8,NaN(1,8);9:24];
-%! patch ('Faces',fac, 'Vertices',vert, 'FaceVertexCData', [0, 1, 0; 0, 0, 1]);
+%! patch ('Faces',fac, 'Vertices',vert, 'FaceVertexCData',[0, 1, 0; 0, 0, 1]);
 
 %!demo
 %! %% Property change on multiple patches
 %! clf;
 %! t1 = (1/16:1/8:1)' * 2*pi;
 %! t2 = ((1/16:1/8:1)' + 1/32) * 2*pi;
 %! x1 = sin (t1) - 0.8;
 %! y1 = cos (t1);
 %! x2 = sin (t2) + 0.8;
 %! y2 = cos (t2);
-%! h = patch ([x1,x2], [y1,y2], cat (3,[0,0],[1,0],[0,1]));
+%! h = patch ([x1,x2], [y1,y2], cat (3, [0,0],[1,0],[0,1]));
 %! pause (1);
 %! set (h, 'FaceColor', 'r');
 
 %!demo
 %! clf;
 %! vertices = [0, 0, 0;
 %!             1, 0, 0;
 %!             1, 1, 0;
@@ -151,38 +151,38 @@ endfunction
 %!        'FaceVertexCData', jet (5), 'FaceColor', 'interp');
 %! view (-37.5, 30);
 
 %!demo
 %! clf;
 %! colormap (jet (64));
 %! x = [0 1 1 0];
 %! y = [0 0 1 1];
-%! subplot (2, 1, 1);
+%! subplot (2,1,1);
 %!  title ('Blue, Light-Green, and Red Horizontal Bars');
 %!  patch (x, y + 0, 1);
 %!  patch (x, y + 1, 2);
 %!  patch (x, y + 2, 3);
-%! subplot (2, 1, 2);
+%! subplot (2,1,2);
 %!  title ('Blue, Light-Green, and Red Vertical Bars');
 %!  patch (x + 0, y, 1 * ones (size (x)));
 %!  patch (x + 1, y, 2 * ones (size (x)));
 %!  patch (x + 2, y, 3 * ones (size (x)));
 
 %!demo
 %! clf;
 %! colormap (jet (64));
 %! x = [0 1 1 0];
 %! y = [0 0 1 1];
-%! subplot (2, 1, 1);
+%! subplot (2,1,1);
 %!  title ('Blue horizontal bars: Dark to Light');
 %!  patch (x, y + 0, 1, 'cdatamapping', 'direct');
 %!  patch (x, y + 1, 9, 'cdatamapping', 'direct');
 %!  patch (x, y + 2, 17, 'cdatamapping', 'direct');
-%! subplot (2, 1, 2);
+%! subplot (2,1,2);
 %!  title ('Blue vertical bars: Dark to Light');
 %!  patch (x + 0, y, 1 * ones (size (x)), 'cdatamapping', 'direct');
 %!  patch (x + 1, y, 9 * ones (size (x)), 'cdatamapping', 'direct');
 %!  patch (x + 2, y, 17 * ones (size (x)), 'cdatamapping', 'direct');
 
 %!demo
 %! clf;
 %! colormap (jet (64));
diff --git a/scripts/plot/plot3.m b/scripts/plot/plot3.m
--- a/scripts/plot/plot3.m
+++ b/scripts/plot/plot3.m
@@ -337,11 +337,11 @@ function retval = plot3 (varargin)
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! z = [0:0.05:5];
-%! plot3 (cos(2*pi*z), sin(2*pi*z), z, ';helix;');
-%! plot3 (z, exp(2i*pi*z), ';complex sinusoid;');
+%! plot3 (cos (2*pi*z), sin (2*pi*z), z, ';helix;');
+%! plot3 (z, exp (2i*pi*z), ';complex sinusoid;');
 
diff --git a/scripts/plot/plotyy.m b/scripts/plot/plotyy.m
--- a/scripts/plot/plotyy.m
+++ b/scripts/plot/plotyy.m
@@ -255,17 +255,17 @@ endfunction
 %!  contour (peaks (25));
 %! subplot (2,2,4);
 %!  plotyy (x,10*sin(2*pi*x), x,cos(2*pi*x));
 %! axis square;
 
 %!demo
 %! clf;
 %! x = linspace (-1, 1, 201);
-%! hax = plotyy (x, sin(pi*x), x, cos(pi*x));
+%! hax = plotyy (x, sin (pi*x), x, cos (pi*x));
 %! ylabel ('Blue on the Left');
 %! ylabel (hax(2), 'Green on the Right');
 %! xlabel ('xlabel');
 
 function deleteplotyy (h, d, ax2, t2)
   if (ishandle (ax2) && strcmp (get (ax2, "type"), "axes")
       && (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off"))
       && strcmp (get (ax2, "beingdeleted"), "off"))
diff --git a/scripts/plot/private/__print_parse_opts__.m b/scripts/plot/private/__print_parse_opts__.m
--- a/scripts/plot/private/__print_parse_opts__.m
+++ b/scripts/plot/private/__print_parse_opts__.m
@@ -366,66 +366,66 @@ endfunction
 
 ## Test blocks are not allowed (and not needed) for private functions
 #%!test
 %! opts = __print_parse_opts__ ();
 %! assert (opts.devopt, "pswrite");
 %! assert (opts.use_color, 1);
 %! assert (opts.send_to_printer, true);
 %! assert (opts.canvas_size, [576, 432]);
-%! assert (opts.ghostscript.device, "pswrite")
+%! assert (opts.ghostscript.device, "pswrite");
 
 #%!test
 %! opts = __print_parse_opts__ ("test.pdf", "-S640,480");
 %! assert (opts.canvas_size, [307.2, 230.4], 0.1);
 
 #%!test
 %! opts = __print_parse_opts__ ("-dpsc", "-append", "-loose");
 %! assert (opts.devopt, "pswrite");
 %! assert (opts.send_to_printer, true);
 %! assert (opts.use_color, 1);
 %! assert (opts.append_to_file, false);
-%! assert (opts.ghostscript.device, "pswrite")
+%! assert (opts.ghostscript.device, "pswrite");
 %! assert (opts.ghostscript.epscrop, false);
 
 #%!test
 %! opts = __print_parse_opts__ ("-deps", "-tight");
 %! assert (opts.tight_flag, true);
 %! assert (opts.send_to_printer, true);
 %! assert (opts.use_color, -1);
-%! assert (opts.ghostscript.device, "")
+%! assert (opts.ghostscript.device, "");
 
 #%!test
 %! opts = __print_parse_opts__ ("-djpg", "foobar", "-mono", "-loose");
-%! assert (opts.devopt, "jpeg")
-%! assert (opts.name, "foobar.jpg")
-%! assert (opts.ghostscript.device, "jpeg")
+%! assert (opts.devopt, "jpeg");
+%! assert (opts.name, "foobar.jpg");
+%! assert (opts.ghostscript.device, "jpeg");
 %! assert (opts.ghostscript.epscrop, true);
 %! assert (opts.ghostscript.papersize, "");
 %! assert (opts.ghostscript.pageoffset, [0, 0]);
 %! assert (opts.send_to_printer, false);
 %! assert (opts.printer, "");
 %! assert (opts.use_color, -1);
 
 #%!test
 %! opts = __print_parse_opts__ ("-ddeskjet", "foobar", "-mono", "-Pmyprinter");
-%! assert (opts.ghostscript.output, "foobar.deskjet")
-%! assert (opts.ghostscript.device, "deskjet")
-%! assert (opts.devopt, "deskjet")
+%! assert (opts.ghostscript.output, "foobar.deskjet");
+%! assert (opts.ghostscript.device, "deskjet");
+%! assert (opts.devopt, "deskjet");
 %! assert (opts.send_to_printer, true);
 %! assert (opts.printer, "-Pmyprinter");
 %! assert (opts.use_color, -1);
 
 #%!test
 %! opts = __print_parse_opts__ ("-f5", "-dljet3");
-%! assert (opts.ghostscript.device, "ljet3")
-%! assert (strfind (opts.ghostscript.output, ".ljet3"))
-%! assert (opts.devopt, "ljet3")
+%! assert (opts.ghostscript.device, "ljet3");
+%! assert (strfind (opts.ghostscript.output, ".ljet3"));
+%! assert (opts.devopt, "ljet3");
 %! assert (opts.send_to_printer, true);
-%! assert (opts.figure, 5)
+%! assert (opts.figure, 5);
 
 function cmd = __quote_path__ (cmd)
   if (any (cmd == " ") && ! (cmd(1) == """" && cmd(end) == """"))
     cmd = strcat ("""", strrep (cmd, """", """"""), """");
   endif
 endfunction
 
 function gs = __ghostscript_binary__ ()
diff --git a/scripts/plot/quiver3.m b/scripts/plot/quiver3.m
--- a/scripts/plot/quiver3.m
+++ b/scripts/plot/quiver3.m
@@ -88,17 +88,17 @@ endfunction
 %!demo
 %! clf;
 %! colormap ('default');
 %! [x,y] = meshgrid (-1:0.1:1);
 %! z = sin (2*pi * sqrt (x.^2 + y.^2));
 %! theta = 2*pi * sqrt (x.^2 + y.^2) + pi/2;
 %! quiver3 (x, y, z, sin (theta), cos (theta), ones (size (z)));
 %! hold on;
-%! mesh (x,y,z);
+%! mesh (x, y, z);
 %! hold off;
 
 %!demo
 %! clf;
 %! colormap ('default');
 %! [x, y, z] = peaks (25);
 %! surf (x, y, z);
 %! hold on;
diff --git a/scripts/plot/refreshdata.m b/scripts/plot/refreshdata.m
--- a/scripts/plot/refreshdata.m
+++ b/scripts/plot/refreshdata.m
@@ -110,11 +110,11 @@ endfunction
 %!demo
 %! clf;
 %! x = 0:0.1:10;
 %! y = sin (x);
 %! plot (x, y, 'ydatasource', 'y');
 %! for i = 1 : 100
 %!   pause (0.1);
 %!   y = sin (x + 0.1 * i);
-%!   refreshdata (gcf (), 'caller');
+%!   refreshdata (gcf, 'caller');
 %! end
 
diff --git a/scripts/plot/ribbon.m b/scripts/plot/ribbon.m
--- a/scripts/plot/ribbon.m
+++ b/scripts/plot/ribbon.m
@@ -88,8 +88,9 @@ endfunction
 %!demo
 %! clf;
 %! colormap ('default');
 %! [x, y, z] = sombrero ();
 %! [x, y] = meshgrid (x, y);
 %! ribbon (y, z);
 
 %!FIXME: Could have some input validation tests here
+
diff --git a/scripts/plot/semilogx.m b/scripts/plot/semilogx.m
--- a/scripts/plot/semilogx.m
+++ b/scripts/plot/semilogx.m
@@ -97,17 +97,17 @@ endfunction
 %!  set (gca, 'xdir', 'reverse', 'activepositionproperty', 'outerposition');
 %!  xlabel ({'semilogx (-x, y)', 'xdir = reversed'});
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   a = logspace (-5, 1, 10);
 %!   b = logspace (-5, 1, 10);
-%!   semilogx (a, b)
+%!   semilogx (a, b);
 %!   assert (get (gca, "xscale"), "log");
 %!   assert (get (gca, "yscale"), "linear");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
diff --git a/scripts/plot/semilogxerr.m b/scripts/plot/semilogxerr.m
--- a/scripts/plot/semilogxerr.m
+++ b/scripts/plot/semilogxerr.m
@@ -58,14 +58,14 @@ function retval = semilogxerr (varargin)
     axes (oldh);
   end_unwind_protect
 
 endfunction
 
 
 %!demo
 %! clf;
-%! x = exp (log(0.01):0.2:log(10));
+%! x = exp (log (0.01):0.2:log (10));
 %! y = wblpdf (x, 2, 2);
 %! ey = 0.5*rand (size (y)) .* y;
 %! semilogxerr (x, y, ey, '#~x-');
 %! xlim (x([1, end]));
 
diff --git a/scripts/plot/semilogy.m b/scripts/plot/semilogy.m
--- a/scripts/plot/semilogy.m
+++ b/scripts/plot/semilogy.m
@@ -70,35 +70,35 @@ endfunction
 %! y = (x .* (1 + rand (size (x)))) .^ 2;
 %! semilogy (x, y);
 
 %!demo
 %! clf;
 %! x = logspace (-5, 1, 10);
 %! y = logspace (-5, 1, 10);
 %!
-%! subplot (2, 1, 1);
+%! subplot (2,1,1);
 %! semilogy (x, y);
 %! ylabel ('semilogy (x, y)');
 %!
-%! subplot (2, 1, 2);
+%! subplot (2,1,2);
 %! semilogy (x, -y);
 %! ylabel ('semilogy (x, -y)');
 
 %!demo
 %! clf;
 %! x = logspace (-5, 1, 10);
 %! y = logspace (-5, 1, 10);
 %!
-%! subplot (2, 1, 1);
+%! subplot (2,1,1);
 %! semilogy (x, y);
 %! set (gca, 'ydir', 'reverse', 'activepositionproperty', 'outerposition');
 %! ylabel ({'semilogy (x, y)', 'ydir = reversed'});
 %!
-%! subplot (2, 1, 2);
+%! subplot (2,1,2);
 %! semilogy (x, -y);
 %! set (gca, 'ydir', 'reverse', 'activepositionproperty', 'outerposition');
 %! ylabel ({'semilogy (x, -y)', 'ydir = reversed'});
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   a = logspace (-5, 1, 10);
diff --git a/scripts/plot/stem.m b/scripts/plot/stem.m
--- a/scripts/plot/stem.m
+++ b/scripts/plot/stem.m
@@ -123,10 +123,10 @@ endfunction
 %! h = stem (x, y, 'filled');
 
 %!demo
 %! clf;
 %! x = (0 : 10)';
 %! y = [sin(x), cos(x)];
 %! h = stem (x, y);
 %! set (h(2), 'color', 'g');
-%! set (h(1), 'basevalue', -1)
+%! set (h(1), 'basevalue', -1);
 
diff --git a/scripts/plot/stem3.m b/scripts/plot/stem3.m
--- a/scripts/plot/stem3.m
+++ b/scripts/plot/stem3.m
@@ -51,10 +51,10 @@ function h = stem3 (varargin)
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! theta = 0:0.2:6;
-%! stem3 (cos(theta), sin(theta), theta);
+%! stem3 (cos (theta), sin (theta), theta);
 
diff --git a/scripts/plot/subplot.m b/scripts/plot/subplot.m
--- a/scripts/plot/subplot.m
+++ b/scripts/plot/subplot.m
@@ -322,16 +322,17 @@ function pos = subplot_position (rows, c
     pos = [x0, y0, x1-x0, y1-y0];
   else
     ## subplot (row, col, num)
     pos = [x0, y0, width, height];
   endif
 
 endfunction
 
+
 %!demo
 %! clf;
 %! r = 3;
 %! c = 3;
 %! fmt = {'horizontalalignment', 'center', 'verticalalignment', 'middle'};
 %! for n = 1 : r*c
 %!   subplot (r, c, n);
 %!   xlabel (sprintf ('xlabel #%d', n));
@@ -346,20 +347,20 @@ endfunction
 %! title (sprintf ('title #%d:%d', 1, 3));
 %! text (0.5, 0.5, sprintf('subplot(%d,%d,%d:%d)', r, c, 1, 3), fmt{:});
 %! axis ([0 1 0 1]);
 
 %!demo
 %! clf;
 %! x = 0:1;
 %! for n = 1:4
-%!   subplot (2, 2, n, 'align');
+%!   subplot (2,2,n, 'align');
 %!   plot (x, x);
 %!   xlabel (sprintf ('xlabel (2,2,%d)', n));
 %!   ylabel (sprintf ('ylabel (2,2,%d)', n));
 %!   title (sprintf ('title (2,2,%d)', n));
 %! end
-%! subplot (1, 2, 1, 'align');
+%! subplot (1,2,1, 'align');
 %! plot (x, x);
 %! xlabel ('xlabel (1,2,1)');
 %! ylabel ('ylabel (1,2,1)');
 %! title ('title (1,2,1)');
 
diff --git a/scripts/plot/title.m b/scripts/plot/title.m
--- a/scripts/plot/title.m
+++ b/scripts/plot/title.m
@@ -43,41 +43,41 @@ function retval = title (varargin)
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
 %! ax = axes ();
-%! xl = get (ax,'title');
+%! xl = get (ax, 'title');
 %! title ('Testing title');
 %! assert (get (xl, 'string'), 'Testing title');
 
 %!demo
 %! clf;
 %! plot3 ([0,1], [0,1], [0,1]);
-%! xl = get (gca (), 'title');
+%! xl = get (gca, 'title');
 %! title ('Testing title');
 %! assert (get (xl, 'string'), 'Testing title');
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
-%!   ax = axes();
-%!   xl = get (ax,"title");
+%!   ax = axes ();
+%!   xl = get (ax, "title");
 %!   title ("Testing title");
 %!   assert (get (xl, "string"), "Testing title");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   plot3 ([0,1], [0,1], [0,1]);
-%!   xl = get (gca (), "title");
+%!   xl = get (gca, "title");
 %!   title ("Testing title");
 %!   assert (get (xl, "string"), "Testing title");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
diff --git a/scripts/plot/uigetfile.m b/scripts/plot/uigetfile.m
--- a/scripts/plot/uigetfile.m
+++ b/scripts/plot/uigetfile.m
@@ -186,10 +186,10 @@ function [retfile, retpath, retindex] = 
 
 endfunction
 
 
 %!demo
 %! uigetfile ({'*.gif;*.png;*.jpg', 'Supported Picture Formats'});
 
 ## Remove from test statistics.  No real tests possible.
-%!assert (1);
+%!assert (1)
 
diff --git a/scripts/plot/view.m b/scripts/plot/view.m
--- a/scripts/plot/view.m
+++ b/scripts/plot/view.m
@@ -89,16 +89,17 @@ function [azimuth, elevation] = view (va
       elevation = el;
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   plot3 ([0,1], [0,1], [0,1]);
 %!   [az, el] = view;
 %!   assert ([az, el], [-37.5, 30], eps);
 %!   view (2);
 %!   [az, el] = view;
@@ -117,8 +118,9 @@ endfunction
 %!   [az, el] = view;
 %!   assert ([az, el], [0, 90], eps);
 %!   view (3);
 %!   [az, el] = view;
 %!   assert ([az, el], [-37.5, 30], eps);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/whitebg.m b/scripts/plot/whitebg.m
--- a/scripts/plot/whitebg.m
+++ b/scripts/plot/whitebg.m
@@ -139,16 +139,17 @@ function whitebg (varargin)
       if (isfield (defs, "defaultaxescolor")
           && strcmp (defs.defaultaxescolor, "none"))
         set (0, "defaultaxescolor", color);
       endif
     endif
   endif
 endfunction
 
+
 %!test
 %! dac = get (0, "defaultaxescolor");
 %! dfc = get (0, "defaultfigurecolor");
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   l = line;
 %!   assert (get (hf, "color"), dfc);
 %!   assert (get (gca, "color"), dac);
@@ -157,8 +158,9 @@ endfunction
 %!   assert (get (gca, "color"), 1 - dac);
 %!   c = [0.2 0.2 0.2];
 %!   whitebg (hf, c);
 %!   assert (get (hf, "color"), 1 - dfc);
 %!   assert (get (gca, "color"), c);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/polynomial/compan.m b/scripts/polynomial/compan.m
--- a/scripts/polynomial/compan.m
+++ b/scripts/polynomial/compan.m
@@ -74,20 +74,17 @@ function A = compan (c)
     A = [];
   else
     A = diag (ones (n-2, 1), -1);
     A(1,:) = -c(2:n) / c(1);
   endif
 
 endfunction
 
-%!assert(all (all (compan ([1, 2, 3]) == [-2, -3; 1, 0])));
-
-%!assert(all (all (compan ([1; 2; 3]) == [-2, -3; 1, 0])));
-
-%!assert(isempty (compan (4)));
 
-%!assert(all (all (compan ([3, 2, 1]) == [-2/3, -1/3; 1, 0])));
+%!assert (compan ([1, 2, 3]), [-2, -3; 1, 0])
+%!assert (compan ([1; 2; 3]), [-2, -3; 1, 0])
+%!assert (isempty (compan (4)))
+%!assert (compan ([3, 2, 1]), [-2/3, -1/3; 1, 0])
 
-%!error compan ([1,2;3,4]);
+%!error compan ([1,2;3,4])
+%!error compan ([])
 
-%!error compan ([]);
-
diff --git a/scripts/polynomial/conv.m b/scripts/polynomial/conv.m
--- a/scripts/polynomial/conv.m
+++ b/scripts/polynomial/conv.m
@@ -104,42 +104,42 @@ endfunction
 %! assert (conv (x, c), [3; 3; 3]);
 %! assert (conv (y, c), [3, 3, 3]);
 %! assert (conv (b, c), 6);
 
 %!shared a,b
 %!test
 %! a = 1:10;
 %! b = 1:3;
-%!assert (size (conv (a,b)), [1, numel(a)+numel(b)-1]);
-%!assert (size (conv (b,a)), [1, numel(a)+numel(b)-1]);
+%!assert (size (conv (a,b)), [1, numel(a)+numel(b)-1])
+%!assert (size (conv (b,a)), [1, numel(a)+numel(b)-1])
 
 %!test
 %! a = (1:10).';
-%!assert (size (conv (a,b)), [numel(a)+numel(b)-1, 1]);
-%!assert (size (conv (b,a)), [numel(a)+numel(b)-1, 1]);
+%!assert (size (conv (a,b)), [numel(a)+numel(b)-1, 1])
+%!assert (size (conv (b,a)), [numel(a)+numel(b)-1, 1])
 
 %!test
 %! a = 1:10;
 %! b = (1:3).';
-%!assert (size (conv (a,b)), [1, numel(a)+numel(b)-1]);
-%!assert (size (conv (b,a)), [1, numel(a)+numel(b)-1]);
+%!assert (size (conv (a,b)), [1, numel(a)+numel(b)-1])
+%!assert (size (conv (b,a)), [1, numel(a)+numel(b)-1])
 
 %!test
 %! a = 1:10;
 %! b = 1:3;
 
-%!assert (conv (a,b,"full"), conv (a,b));
-%!assert (conv (b,a,"full"), conv (b,a));
+%!assert (conv (a,b,"full"), conv (a,b))
+%!assert (conv (b,a,"full"), conv (b,a))
 
-%!assert (conv (a,b,"same"), [4, 10, 16, 22, 28, 34, 40, 46, 52, 47]);
-%!assert (conv (b,a,"same"), [28, 34, 40]);
+%!assert (conv (a,b,"same"), [4, 10, 16, 22, 28, 34, 40, 46, 52, 47])
+%!assert (conv (b,a,"same"), [28, 34, 40])
 
-%!assert (conv (a,b,"valid"), [10, 16, 22, 28, 34, 40, 46, 52]);
-%!assert (conv (b,a,"valid"), zeros (1,0));
+%!assert (conv (a,b,"valid"), [10, 16, 22, 28, 34, 40, 46, 52])
+%!assert (conv (b,a,"valid"), zeros (1,0))
 
 
 %% Test input validation
 %!error conv (1)
 %!error conv (1,2,3,4)
 %!error <A and B must be vectors> conv ([1, 2; 3, 4], 3)
 %!error <A and B must be vectors> conv (3, [1, 2; 3, 4])
 %!error <SHAPE argument must be> conv (2, 3, "INVALID_SHAPE")
diff --git a/scripts/polynomial/deconv.m b/scripts/polynomial/deconv.m
--- a/scripts/polynomial/deconv.m
+++ b/scripts/polynomial/deconv.m
@@ -76,35 +76,39 @@ function [b, r] = deconv (y, a)
     if (ly < la)
       ## Trim the remainder is equal to the length of Y.
       r = r(end-(length(y)-1):end);
     endif
   endif
 
 endfunction
 
+
 %!test
 %! [b, r] = deconv ([3, 6, 9, 9], [1, 2, 3]);
-%! assert(all (all (b == [3, 0])) && all (all (r == [0, 0, 0, 9])));
+%! assert (b, [3, 0]);
+%! assert (r, [0, 0, 0, 9]);
 
 %!test
 %! [b, r] = deconv ([3, 6], [1, 2, 3]);
-%! assert(b == 0 && all (all (r == [3, 6])));
+%! assert (b, 0);
+%! assert (r, [3, 6]);
 
 %!test
 %! [b, r] = deconv ([3, 6], [1; 2; 3]);
-%! assert(b == 0 && all (all (r == [3, 6])));
+%! assert (b, 0);
+%! assert (r, [3, 6]);
 
 %!test
 %! [b,r] = deconv ([3; 6], [1; 2; 3]);
-%! assert (b == 0 && all (all (r == [3; 6])))
+%! assert (b, 0);
+%! assert (r, [3; 6]);
 
 %!test
 %! [b, r] = deconv ([3; 6], [1, 2, 3]);
-%! assert (b == 0 && all (all (r == [3; 6])))
-
-%!test
-%! assert (deconv ((1:3)',[1, 1]), [1; 1])
+%! assert (b, 0);
+%! assert (r, [3; 6]);
 
-%!error [b, r] = deconv ([3, 6], [1, 2; 3, 4]);
+%!assert (deconv ((1:3)',[1, 1]), [1; 1])
 
-%!error [b, r] = deconv ([3, 6; 1, 2], [1, 2, 3]);
+%!error [b, r] = deconv ([3, 6], [1, 2; 3, 4])
+%!error [b, r] = deconv ([3, 6; 1, 2], [1, 2, 3])
 
diff --git a/scripts/polynomial/mkpp.m b/scripts/polynomial/mkpp.m
--- a/scripts/polynomial/mkpp.m
+++ b/scripts/polynomial/mkpp.m
@@ -83,32 +83,32 @@ endfunction
 %!demo # linear interpolation
 %! x = linspace (0,pi,5)';
 %! t = [sin(x), cos(x)];
 %! m = diff (t) ./ (x(2)-x(1));
 %! b = t(1:4,:);
 %! pp = mkpp (x, [m(:),b(:)]);
 %! xi = linspace (0,pi,50);
 %! plot (x,t,"x", xi,ppval (pp,xi));
-%! legend ("control","interp");
+%! legend ("control", "interp");
 
 %!shared b,c,pp
 %! b = 1:3; c = 1:24; pp = mkpp (b,c);
-%!assert (pp.pieces, 2);
-%!assert (pp.order, 12);
-%!assert (pp.dim, 1);
-%!assert (size (pp.coefs), [2,12]);
+%!assert (pp.pieces, 2)
+%!assert (pp.order, 12)
+%!assert (pp.dim, 1)
+%!assert (size (pp.coefs), [2,12])
 %! pp = mkpp(b,c,2);
-%!assert (pp.pieces, 2);
-%!assert (pp.order, 6);
-%!assert (pp.dim, 2);
-%!assert (size (pp.coefs), [4,6]);
+%!assert (pp.pieces, 2)
+%!assert (pp.order, 6)
+%!assert (pp.dim, 2)
+%!assert (size (pp.coefs), [4,6])
 %! pp = mkpp(b,c,3);
-%!assert (pp.pieces, 2);
-%!assert (pp.order, 4);
-%!assert (pp.dim, 3);
-%!assert (size (pp.coefs), [6,4]);
+%!assert (pp.pieces, 2)
+%!assert (pp.order, 4)
+%!assert (pp.dim, 3)
+%!assert (size (pp.coefs), [6,4])
 %! pp = mkpp(b,c,[2,3]);
-%!assert (pp.pieces, 2);
-%!assert (pp.order, 2);
-%!assert (pp.dim, [2,3]);
-%!assert (size (pp.coefs), [12,2]);
+%!assert (pp.pieces, 2)
+%!assert (pp.order, 2)
+%!assert (pp.dim, [2,3])
+%!assert (size (pp.coefs), [12,2])
 
diff --git a/scripts/polynomial/mpoles.m b/scripts/polynomial/mpoles.m
--- a/scripts/polynomial/mpoles.m
+++ b/scripts/polynomial/mpoles.m
@@ -111,12 +111,13 @@ function [multp, indx] = mpoles (p, tol,
     indx = [indx; k];
     n = find (multp == 0, 1);
   endwhile
   multp = multp(indx);
   indx = ordr(indx);
 
 endfunction
 
+
 %!test
 %! [mp, n] = mpoles ([0 0], 0.01);
-%! assert (mp, [1; 2])
+%! assert (mp, [1; 2]);
 
diff --git a/scripts/polynomial/pchip.m b/scripts/polynomial/pchip.m
--- a/scripts/polynomial/pchip.m
+++ b/scripts/polynomial/pchip.m
@@ -147,25 +147,25 @@ endfunction
 %!assert (pchip (x',y',x), y)
 %!assert (isempty (pchip(x',y',[])))
 %!assert (isempty (pchip(x,y,[])))
 %!assert (pchip (x,[y;y],x), [pchip(x,y,x);pchip(x,y,x)])
 %!assert (pchip (x,[y;y],x'), [pchip(x,y,x);pchip(x,y,x)])
 %!assert (pchip (x',[y;y],x), [pchip(x,y,x);pchip(x,y,x)])
 %!assert (pchip (x',[y;y],x'), [pchip(x,y,x);pchip(x,y,x)])
 %!test
-%! x = (0:8)*pi/4; y = [sin(x);cos(x)];
+%! x = (0:8)*pi/4; y = [sin(x); cos(x)];
 %! y2(:,:,1) = y; y2(:,:,2) = y+1; y2(:,:,3) = y-1;
 %! pp = pchip (x, shiftdim (y2,2));
 %! yi1 = ppval (pp, (1:4)*pi/4);
 %! yi2 = ppval (pp, repmat ((1:4)*pi/4, [5,1]));
 %! yi3 = ppval (pp, [pi/2,pi]);
 %!assert (size (pp.coefs), [48,4])
 %!assert (pp.pieces, 8)
 %!assert (pp.order, 4)
 %!assert (pp.dim, [3,2])
 %!assert (ppval (pp,pi), [0,-1;1,0;-1,-2], 1e-14)
-%!assert (yi3(:,:,2), ppval(pp,pi), 1e-14)
+%!assert (yi3(:,:,2), ppval (pp,pi), 1e-14)
 %!assert (yi3(:,:,1), [1,0;2,1;0,-1], 1e-14)
 %!assert (squeeze (yi1(1,2,:)), [1/sqrt(2); 0; -1/sqrt(2);-1], 1e-14)
 %!assert (size (yi2), [3,2,5,4])
 %!assert (squeeze (yi2(1,2,3,:)), [1/sqrt(2); 0; -1/sqrt(2);-1], 1e-14)
 
diff --git a/scripts/polynomial/poly.m b/scripts/polynomial/poly.m
--- a/scripts/polynomial/poly.m
+++ b/scripts/polynomial/poly.m
@@ -76,16 +76,15 @@ function y = poly (x)
   endfor
 
   if (all (all (imag (x) == 0)))
     y = real (y);
   endif
 
 endfunction
 
-%!assert(all (all (poly ([1, 2, 3]) == [1, -6, 11, -6])));
-
-%!assert(all (all (abs (poly ([1, 2; 3, 4]) - [1, -5, -2]) < sqrt (eps))));
 
-%!error poly ([1, 2, 3; 4, 5, 6]);
+%!assert (poly ([]), 1)
+%!assert (poly ([1, 2, 3]), [1, -6, 11, -6])
+%!assert (poly ([1, 2; 3, 4]), [1, -5, -2], sqrt (eps))
 
-%!assert(poly ([]),1);
+%!error poly ([1, 2, 3; 4, 5, 6])
 
diff --git a/scripts/polynomial/polyaffine.m b/scripts/polynomial/polyaffine.m
--- a/scripts/polynomial/polyaffine.m
+++ b/scripts/polynomial/polyaffine.m
@@ -25,17 +25,16 @@
 ##
 ## @example
 ## g(x) = f( (x - @var{mu}(1)) / @var{mu}(2) )
 ## @end example
 ##
 ## @seealso{polyval, polyfit}
 ## @end deftypefn
 
-
 function g = polyaffine (f, mu)
 
    if (nargin != 2)
       print_usage ();
    endif
 
    if (! isvector (f))
       error ("polyaffine: F must be a vector");
diff --git a/scripts/polynomial/polyder.m b/scripts/polynomial/polyder.m
--- a/scripts/polynomial/polyder.m
+++ b/scripts/polynomial/polyder.m
@@ -86,14 +86,15 @@ function [q, d] = polyder (p, a)
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
 
-%!assert(all (all (polyder ([1, 2, 3]) == [2, 2])));
-%!assert(polyder (13) == 0);
+%!assert (polyder ([1, 2, 3], [2, 2]))
+%!assert (polyder (13), 0)
 
-%!error polyder ([]);
-%!error polyder ([1, 2; 3, 4]);
+%!error polyder ([])
+%!error polyder (1,2,3)
+%!error <argument must be a vector> polyder ([1, 2; 3, 4])
 
diff --git a/scripts/polynomial/polyfit.m b/scripts/polynomial/polyfit.m
--- a/scripts/polynomial/polyfit.m
+++ b/scripts/polynomial/polyfit.m
@@ -111,67 +111,58 @@ function [p, s, mu] = polyfit (x, y, n)
     s.normr = norm (yf - y);
   endif
 
   ## Return a row vector.
   p = p.';
 
 endfunction
 
-%!test
-%! x = [-2, -1, 0, 1, 2];
-%! assert(all (all (abs (polyfit (x, x.^2+x+1, 2) - [1, 1, 1]) < sqrt (eps))));
 
-%!error(polyfit ([1, 2; 3, 4], [1, 2, 3, 4], 2))
-
-%!test
+%!shared x
 %! x = [-2, -1, 0, 1, 2];
-%! assert(all (all (abs (polyfit (x, x.^2+x+1, 3) - [0, 1, 1, 1]) < sqrt (eps))));
-
-%!test
-%! x = [-2, -1, 0, 1, 2];
-%! fail("polyfit (x, x.^2+x+1)");
-
-%!test
-%! x = [-2, -1, 0, 1, 2];
-%! fail("polyfit (x, x.^2+x+1, [])");
+%!assert (polyfit (x, x.^2+x+1, 2), [1, 1, 1], sqrt (eps))
+%!assert (polyfit (x, x.^2+x+1, 3), [0, 1, 1, 1], sqrt (eps))
+%!fail ("polyfit (x, x.^2+x+1)")
+%!fail ("polyfit (x, x.^2+x+1, [])")
 
 ## Test difficult case where scaling is really needed. This example
 ## demonstrates the rather poor result which occurs when the dependent
 ## variable is not normalized properly.
 ## Also check the usage of 2nd & 3rd output arguments.
 %!test
 %! x = [ -1196.4, -1195.2, -1194, -1192.8, -1191.6, -1190.4, -1189.2, -1188, \
 %!       -1186.8, -1185.6, -1184.4, -1183.2, -1182];
 %! y = [ 315571.7086, 315575.9618, 315579.4195, 315582.6206, 315585.4966,    \
 %!       315588.3172, 315590.9326, 315593.5934, 315596.0455, 315598.4201,    \
 %!       315600.7143, 315602.9508, 315605.1765 ];
 %! [p1, s1] = polyfit (x, y, 10);
 %! [p2, s2, mu] = polyfit (x, y, 10);
-%! assert (s2.normr < s1.normr)
+%! assert (s2.normr < s1.normr);
 
 %!test
 %! x = 1:4;
 %! p0 = [1i, 0, 2i, 4];
 %! y0 = polyval (p0, x);
-%! p = polyfit (x, y0, numel(p0)-1);
-%! assert (p, p0, 1000*eps)
+%! p = polyfit (x, y0, numel (p0) - 1);
+%! assert (p, p0, 1000*eps);
 
 %!test
 %! x = 1000 + (-5:5);
 %! xn = (x - mean (x)) / std (x);
 %! pn = ones (1,5);
 %! y = polyval (pn, xn);
-%! [p, s, mu] = polyfit (x, y, numel(pn)-1);
-%! [p2, s2] = polyfit (x, y, numel(pn)-1);
-%! assert (p, pn, s.normr)
-%! assert (s.yf, y, s.normr)
-%! assert (mu, [mean(x), std(x)])
-%! assert (s.normr/s2.normr < sqrt(eps))
+%! [p, s, mu] = polyfit (x, y, numel (pn) - 1);
+%! [p2, s2] = polyfit (x, y, numel (pn) - 1);
+%! assert (p, pn, s.normr);
+%! assert (s.yf, y, s.normr);
+%! assert (mu, [mean(x), std(x)]);
+%! assert (s.normr/s2.normr < sqrt (eps));
 
 %!test
 %! x = [1, 2, 3; 4, 5, 6];
 %! y = [0, 0, 1; 1, 0, 0];
 %! p = polyfit (x, y, 5);
-%! expected = [0, 1, -14, 65, -112, 60]/12;
-%! assert (p, expected, sqrt(eps))
+%! expected = [0, 1, -14, 65, -112, 60] / 12;
+%! assert (p, expected, sqrt (eps));
 
+%!error <vectors of the same size> polyfit ([1, 2; 3, 4], [1, 2, 3, 4], 2)
 
diff --git a/scripts/polynomial/polygcd.m b/scripts/polynomial/polygcd.m
--- a/scripts/polynomial/polygcd.m
+++ b/scripts/polynomial/polygcd.m
@@ -77,26 +77,24 @@ function x = polygcd (b, a, tol)
   else
     print_usage ();
   endif
 
 endfunction
 
 
 %!test
-%! poly1 = [1 6 11 6]; % (x+1)(x+2)(x+3)
-%! poly2 = [1 3 2]; % (x+1)(x+2)
+%! poly1 = [1 6 11 6]; # (x+1)(x+2)(x+3);
+%! poly2 = [1 3 2];    # (x+1)(x+2);
 %! poly3 = polygcd (poly1, poly2);
-%! assert (poly3, poly2, sqrt (eps))
+%! assert (poly3, poly2, sqrt (eps));
 
-%!test
-%! assert (polygcd (poly(1:8), poly(3:12)), poly(3:8), sqrt (eps))
-
-%!test
-%! assert (deconv (poly(1:8), polygcd (poly(1:8), poly(3:12))), poly(1:2), sqrt (eps))
+%!assert (polygcd (poly (1:8), poly (3:12)), poly (3:8), sqrt (eps))
+%!assert (deconv (poly (1:8), polygcd (poly (1:8), poly (3:12))), poly (1:2), sqrt (eps))
 
 %!test
 %! for ii=1:10
 %!   p  = (unique (randn (10, 1)) * 10).';
 %!   p1 = p(3:end);
 %!   p2 = p(1:end-2);
-%!   assert (polygcd (poly (-p1), poly (-p2)), poly (- intersect (p1, p2)), sqrt (eps))
+%!   assert (polygcd (poly (-p1), poly (-p2)), poly (- intersect (p1, p2)), sqrt (eps));
 %! endfor
+
diff --git a/scripts/polynomial/polyint.m b/scripts/polynomial/polyint.m
--- a/scripts/polynomial/polyint.m
+++ b/scripts/polynomial/polyint.m
@@ -56,22 +56,24 @@ function retval = polyint (p, k)
     ## Convert to column vector
     p = p.';
   endif
 
   retval = [(p ./ [lp:-1:1]), k];
 
 endfunction
 
+
 %!test
 %! A = [3, 2, 1];
-%! assert (polyint(A),polyint(A,0));
-%! assert (polyint(A),polyint(A'));
-%! assert (polyint(A),[1, 1, 1, 0]);
-%! assert (polyint(A,1),ones(1,4));
+%! assert (polyint (A), polyint (A,0));
+%! assert (polyint (A), polyint (A'));
+%! assert (polyint (A), [1, 1, 1, 0]);
+%! assert (polyint (A,1), ones (1,4));
 
 %!test
-%! A = ones(1,8);
+%! A = ones (1,8);
 %! B = [length(A):-1:1];
-%! assert (polyint(A),[1./B, 0]);
+%! assert (polyint (A), [1./B, 0]);
 
-%!error polyint()
-%!error polyint(ones(2,2))
+%!error polyint ()
+%!error polyint (ones (2,2))
+
diff --git a/scripts/polynomial/polyout.m b/scripts/polynomial/polyout.m
--- a/scripts/polynomial/polyout.m
+++ b/scripts/polynomial/polyout.m
@@ -91,13 +91,16 @@ function str = coeff (c)
     else
       str = num2str (c, 5);
     endif
   else
     str = num2str (c, 5);
   endif
 endfunction
 
-%!assert (polyout ([3 2 1]), '3*s^2 + 2*s^1 + 1')
-%!assert (polyout ([3 2 1], 'x'), '3*x^2 + 2*x^1 + 1')
-%!assert (polyout ([3 2 1], 'wxyz'), '3*wxyz^2 + 2*wxyz^1 + 1')
-%!assert (polyout ([5 4 3 2 1], '1'),'5*1^4 + 4*1^3 + 3*1^2 + 2*1^1 + 1')
+
+%!assert (polyout ([3 2 1]), "3*s^2 + 2*s^1 + 1")
+%!assert (polyout ([3 2 1], "x"), "3*x^2 + 2*x^1 + 1")
+%!assert (polyout ([3 2 1], "wxyz"), "3*wxyz^2 + 2*wxyz^1 + 1")
+%!assert (polyout ([5 4 3 2 1], "1"),"5*1^4 + 4*1^3 + 3*1^2 + 2*1^1 + 1")
+
 %!error polyout ([])
+
diff --git a/scripts/polynomial/polyval.m b/scripts/polynomial/polyval.m
--- a/scripts/polynomial/polyval.m
+++ b/scripts/polynomial/polyval.m
@@ -88,65 +88,66 @@ function [y, dy] = polyval (p, x, s = []
       else
         error ("polyval: third input is not a structure.");
       endif
     end_try_catch
   endif
 
 endfunction
 
-%!test
-%! fail("polyval([1,0;0,1],0:10)");
+
+%!fail ("polyval ([1,0;0,1],0:10)")
 
 %!test
 %! r = 0:10:50;
 %! p = poly (r);
-%! p = p / max(abs(p));
-%! x = linspace(0,50,11);
-%! y = polyval(p,x) + 0.25*sin(100*x);
-%! [pf, s] = polyfit (x, y, numel(r));
+%! p = p / max (abs (p));
+%! x = linspace (0,50,11);
+%! y = polyval (p,x) + 0.25*sin (100*x);
+%! [pf, s] = polyfit (x, y, numel (r));
 %! [y1, delta] = polyval (pf, x, s);
 %! expected = [0.37235, 0.35854, 0.32231, 0.32448, 0.31328, ...
 %!    0.32036, 0.31328, 0.32448, 0.32231, 0.35854, 0.37235];
-%! assert (delta, expected, 0.00001)
+%! assert (delta, expected, 0.00001);
 
 %!test
 %! x = 10 + (-2:2);
 %! y = [0, 0, 1, 0, 2];
 %! p = polyfit (x, y, numel (x) - 1);
 %! [pn, s, mu] = polyfit (x, y, numel (x) - 1);
 %! y1 = polyval (p, x);
 %! yn = polyval (pn, x, [], mu);
-%! assert (y1, y, sqrt(eps))
-%! assert (yn, y, sqrt(eps))
+%! assert (y1, y, sqrt (eps));
+%! assert (yn, y, sqrt (eps));
 
 %!test
 %! p = [0, 1, 0];
 %! x = 1:10;
-%! assert (x, polyval(p,x), eps)
+%! assert (x, polyval (p,x), eps);
 %! x = x(:);
-%! assert (x, polyval(p,x), eps)
+%! assert (x, polyval (p,x), eps);
 %! x = reshape(x, [2, 5]);
-%! assert (x, polyval(p,x), eps)
+%! assert (x, polyval (p,x), eps);
 %! x = reshape(x, [5, 2]);
-%! assert (x, polyval(p,x), eps)
-%! x = reshape(x, [1, 1, 5, 2]);
-%! assert (x, polyval(p,x), eps)
+%! assert (x, polyval (p,x), eps);
+%! x = reshape (x, [1, 1, 5, 2]);
+%! assert (x, polyval (p,x), eps);
 
 %!test
 %! p = [1];
 %! x = 1:10;
-%! y = ones(size(x));
-%! assert (y, polyval(p,x), eps)
+%! y = ones (size (x));
+%! assert (y, polyval (p,x), eps);
 %! x = x(:);
-%! y = ones(size(x));
-%! assert (y, polyval(p,x), eps)
-%! x = reshape(x, [2, 5]);
-%! y = ones(size(x));
-%! assert (y, polyval(p,x), eps)
-%! x = reshape(x, [5, 2]);
-%! y = ones(size(x));
-%! assert (y, polyval(p,x), eps)
-%! x = reshape(x, [1, 1, 5, 2]);
+%! y = ones (size (x));
+%! assert (y, polyval (p,x), eps);
+%! x = reshape (x, [2, 5]);
+%! y = ones (size (x));
+%! assert (y, polyval (p,x), eps);
+%! x = reshape (x, [5, 2]);
+%! y = ones (size (x));
+%! assert (y, polyval (p,x), eps);
+%! x = reshape (x, [1, 1, 5, 2]);
 
 %!assert (zeros (1, 10), polyval ([], 1:10))
 %!assert ([], polyval (1, []))
 %!assert ([], polyval ([], []))
+
diff --git a/scripts/polynomial/polyvalm.m b/scripts/polynomial/polyvalm.m
--- a/scripts/polynomial/polyvalm.m
+++ b/scripts/polynomial/polyvalm.m
@@ -56,13 +56,13 @@ function y = polyvalm (c, x)
     for i = 2:n
       y = y * x + c(i) * id;
     endfor
   endif
 
 endfunction
 
 
-%!assert(! any (polyvalm ([], [1, 2; 3, 4]))(:));
-%!assert(polyvalm ([1, 2, 3, 4], [3, -4, 1; -2, 0, 2; -1, 4, -3]), [117, -124, 11; -70, 36, 38; -43, 92, -45])
+%!assert (! any (polyvalm ([], [1, 2; 3, 4]))(:));
+%!assert (polyvalm ([1, 2, 3, 4], [3, -4, 1; -2, 0, 2; -1, 4, -3]), [117, -124, 11; -70, 36, 38; -43, 92, -45])
 
-%!error polyvalm ([1, 1, 1], [1, 2; 3, 4; 5, 6]);
+%!error <must be a square matrix> polyvalm ([1, 1, 1], [1, 2; 3, 4; 5, 6])
 
diff --git a/scripts/polynomial/ppder.m b/scripts/polynomial/ppder.m
--- a/scripts/polynomial/ppder.m
+++ b/scripts/polynomial/ppder.m
@@ -46,25 +46,29 @@ function ppd = ppder (pp, m)
     ff = bincoeff (f, m + 1) .* factorial (m + 1) ./ f;
     k -= m;
     pd = p(:,1:k) * diag (ff(1:k));
   endif
 
   ppd = mkpp (x, pd, d);
 endfunction
 
+
 %!shared x,y,pp,ppd
-%! x=0:8;y=[x.^2;x.^3+1];pp=spline(x,y);
-%! ppd=ppder(pp);
-%!assert(ppval(ppd,x),[2*x;3*x.^2],1e-14)
-%!assert(ppd.order,3)
-%! ppd=ppder(pp,2);
-%!assert(ppval(ppd,x),[2*ones(size(x));6*x],1e-14)
-%!assert(ppd.order,2)
-%! ppd=ppder(pp,3);
-%!assert(ppd.order,1)
-%!assert(ppd.pieces,8)
-%!assert(size(ppd.coefs),[16,1])
-%! ppd=ppder(pp,4);
-%!assert(ppd.order,1)
-%!assert(ppd.pieces,1)
-%!assert(size(ppd.coefs),[2,1])
-%!assert(ppval(ppd,x),zeros(size(y)),1e-14)
+%! x = 0:8;
+%! y = [x.^2; x.^3+1];
+%! pp = spline (x, y);
+%! ppd = ppder (pp);
+%!assert (ppval (ppd, x), [2*x; 3*x.^2], 1e-14)
+%!assert (ppd.order, 3)
+%! ppd = ppder (pp, 2);
+%!assert (ppval (ppd, x), [2*ones(size (x)); 6*x], 1e-14)
+%!assert (ppd.order, 2)
+%! ppd = ppder (pp, 3);
+%!assert (ppd.order, 1)
+%!assert (ppd.pieces, 8)
+%!assert (size (ppd.coefs), [16, 1])
+%! ppd = ppder (pp, 4);
+%!assert (ppd.order, 1)
+%!assert (ppd.pieces, 1)
+%!assert (size (ppd.coefs), [2, 1])
+%!assert (ppval (ppd,x), zeros (size (y)), 1e-14)
+
diff --git a/scripts/polynomial/ppint.m b/scripts/polynomial/ppint.m
--- a/scripts/polynomial/ppint.m
+++ b/scripts/polynomial/ppint.m
@@ -46,13 +46,17 @@ function ppi = ppint (pp, c)
 
   ppi = mkpp (x, pi, d);
 
   tmp = -cumsum (ppjumps (ppi), length (d) + 1);
   ppi.coefs(prod(d)+1:end, k) = tmp(:);
 
 endfunction
 
+
 %!shared x,y,pp,ppi
-%! x=0:8;y=[ones(size(x));x+1];pp=spline(x,y);
-%! ppi=ppint(pp);
-%!assert(ppval(ppi,x),[x;0.5*x.^2+x],1e-14)
-%!assert(ppi.order,5)
+%! x = 0:8;
+%! y = [ ones(size(x)); x+1 ];
+%! pp = spline (x, y);
+%! ppi = ppint (pp);
+%!assert (ppval (ppi, x), [x; 0.5*x.^2 + x], 1e-14)
+%!assert (ppi.order, 5)
+
diff --git a/scripts/polynomial/ppjumps.m b/scripts/polynomial/ppjumps.m
--- a/scripts/polynomial/ppjumps.m
+++ b/scripts/polynomial/ppjumps.m
@@ -59,26 +59,25 @@ endfunction
 
 
 %!test
 %! p = [1 6 11 6];
 %! x = linspace (5, 6, 4);
 %! y = polyval (p, x);
 %! pp = spline (x, y);
 %! jj = ppjumps (pp);
-%! assert (jj, [0 0], eps)
+%! assert (jj, [0 0], eps);
 
 %!test
-%!
 %! breaks = [0 1 2];
 %! pp1 = poly (-[1 2 3]);
 %! pp2 = poly (-([1 2 3]+1));
 %! pp = mkpp (breaks, [pp1;pp2]);
-%! assert (ppjumps (pp), 0, eps)
+%! assert (ppjumps (pp), 0, eps);
 
 %!test
-%!
 %! breaks = [0 1 2];
 %! pp1 = poly (-[1 2 3]);
 %! pp2 = poly (([1 2 3]+1));
 %! pp = mkpp (breaks, [pp1;pp2]);
 %! j  = - 2 * polyval (pp1, 1);
-%! assert (ppjumps (pp), j, eps)
+%! assert (ppjumps (pp), j, eps);
+
diff --git a/scripts/polynomial/ppval.m b/scripts/polynomial/ppval.m
--- a/scripts/polynomial/ppval.m
+++ b/scripts/polynomial/ppval.m
@@ -97,20 +97,26 @@ function yi = ppval (pp, xi)
 
   ##
   #if (d == 1)
   #  yi = reshape (yi, sxi);
   #endif
 
 endfunction
 
+
 %!shared b,c,pp,pp2,xi,abserr
-%! b = 1:3; c = ones(2); pp=mkpp(b,c);abserr = 1e-14;pp2=mkpp(b,[c;c],2);
+%! b = 1:3;
+%! c = ones (2);
+%! pp = mkpp (b, c);
+%! abserr = 1e-14;
+%! pp2 = mkpp (b, [c;c], 2);
 %! xi = [1.1 1.3 1.9 2.1];
-%!assert (ppval(pp,1.1), 1.1, abserr);
-%!assert (ppval(pp,2.1), 1.1, abserr);
-%!assert (ppval(pp,xi), [1.1 1.3 1.9 1.1], abserr);
-%!assert (ppval(pp,xi.'), [1.1 1.3 1.9 1.1].', abserr);
-%!assert (ppval(pp2,1.1), [1.1;1.1], abserr);
-%!assert (ppval(pp2,2.1), [1.1;1.1], abserr);
-%!assert (ppval(pp2,xi), [1.1 1.3 1.9 1.1;1.1 1.3 1.9 1.1], abserr);
-%!assert (ppval(pp2,xi'), [1.1 1.3 1.9 1.1;1.1 1.3 1.9 1.1], abserr);
-%!assert (size(ppval(pp2,[xi;xi])), [2 2 4]);
+%!assert (ppval (pp, 1.1), 1.1, abserr)
+%!assert (ppval (pp, 2.1), 1.1, abserr)
+%!assert (ppval (pp, xi), [1.1 1.3 1.9 1.1], abserr)
+%!assert (ppval (pp, xi.'), [1.1 1.3 1.9 1.1].', abserr)
+%!assert (ppval (pp2, 1.1), [1.1;1.1], abserr)
+%!assert (ppval (pp2, 2.1), [1.1;1.1], abserr)
+%!assert (ppval (pp2, xi), [1.1 1.3 1.9 1.1;1.1 1.3 1.9 1.1], abserr)
+%!assert (ppval (pp2, xi'), [1.1 1.3 1.9 1.1;1.1 1.3 1.9 1.1], abserr)
+%!assert (size (ppval (pp2, [xi;xi])), [2 2 4])
+
diff --git a/scripts/polynomial/residue.m b/scripts/polynomial/residue.m
--- a/scripts/polynomial/residue.m
+++ b/scripts/polynomial/residue.m
@@ -346,74 +346,77 @@ function [pnum, pden, e] = rresidue (r, 
   pnum(abs (pnum) < small) = 0;
   pden(abs (pden) < small) = 0;
 
   pnum = polyreduce (pnum);
   pden = polyreduce (pden);
 
 endfunction
 
+
 %!test
 %! b = [1, 1, 1];
 %! a = [1, -5, 8, -4];
 %! [r, p, k, e] = residue (b, a);
-%! assert (abs (r - [-2; 7; 3]) < 1e-12
-%!   && abs (p - [2; 2; 1]) < 1e-12
-%!   && isempty (k)
-%!   && e == [1; 2; 1]);
+%! assert (r, [-2; 7; 3], 1e-12);
+%! assert (p, [2; 2; 1], 1e-12);
+%! assert (isempty (k));
+%! assert (e, [1; 2; 1]);
 %! k = [1 0];
 %! b = conv (k, a) + prepad (b, numel (k) + numel (a) - 1, 0);
 %! a = a;
 %! [br, ar] = residue (r, p, k);
-%! assert ((abs (br - b) < 1e-12
-%!   && abs (ar - a) < 1e-12));
+%! assert (br, b, 1e-12);
+%! assert (ar, a, 1e-12);
 %! [br, ar] = residue (r, p, k, e);
-%! assert ((abs (br - b) < 1e-12
-%!   && abs (ar - a) < 1e-12));
+%! assert (br, b, 1e-12);
+%! assert (ar, a, 1e-12);
 
 %!test
 %! b = [1, 0, 1];
 %! a = [1, 0, 18, 0, 81];
 %! [r, p, k, e] = residue (b, a);
 %! r1 = [-5i; 12; +5i; 12]/54;
 %! p1 = [+3i; +3i; -3i; -3i];
-%! assert (abs (r - r1) < 1e-12 && abs (p - p1) < 1e-12
-%!   && isempty (k)
-%!   && e == [1; 2; 1; 2]);
+%! assert (r, r1, 1e-12);
+%! assert (p, p1, 1e-12);
+%! assert (isempty (k));
+%! assert (e, [1; 2; 1; 2]);
 %! [br, ar] = residue (r, p, k);
-%! assert ((abs (br - b) < 1e-12
-%!   && abs (ar - a) < 1e-12));
+%! assert (br, b, 1e-12);
+%! assert (ar, a, 1e-12);
 
 %!test
 %! r = [7; 3; -2];
 %! p = [2; 1; 2];
 %! k = [1 0];
 %! e = [2; 1; 1];
 %! [b, a] = residue (r, p, k, e);
-%! assert ((abs (b - [1, -5, 9, -3, 1]) < 1e-12
-%!   && abs (a - [1, -5, 8, -4]) < 1e-12));
+%! assert (b, [1, -5, 9, -3, 1], 1e-12);
+%! assert (a, [1, -5, 8, -4], 1e-12);
 %! [rr, pr, kr, er] = residue (b, a);
-%! [jnk, n] = mpoles(p);
-%! assert ((abs (rr - r(n)) < 1e-12
-%!   && abs (pr - p(n)) < 1e-12
-%!   && abs (kr - k) < 1e-12
-%!   && abs (er - e(n)) < 1e-12));
+%! [jnk, n] = mpoles (p);
+%! assert (rr, r(n), 1e-12);
+%! assert (pr, p(n), 1e-12);
+%! assert (kr, k, 1e-12);
+%! assert (er, e(n), 1e-12);
 
 %!test
 %! b = [1];
 %! a = [1, 10, 25];
 %! [r, p, k, e] = residue (b, a);
 %! r1 = [0; 1];
 %! p1 = [-5; -5];
-%! assert (abs (r - r1) < 1e-12 && abs (p - p1) < 1e-12
-%!   && isempty (k)
-%!   && e == [1; 2]);
+%! assert (r, r1, 1e-12);
+%! assert (p, p1, 1e-12);
+%! assert (isempty (k));
+%! assert (e, [1; 2]);
 %! [br, ar] = residue (r, p, k);
-%! assert ((abs (br - b) < 1e-12
-%!   && abs (ar - a) < 1e-12));
+%! assert (br, b, 1e-12);
+%! assert (ar, a, 1e-12);
 
 ## The following test is due to Bernard Grung (bug #34266)
 %!xtest
 %! z1 =  7.0372976777e6;
 %! p1 = -3.1415926536e9;
 %! p2 = -4.9964813512e8;
 %! r1 = -(1 + z1/p1)/(1 - p1/p2)/p2/p1;
 %! r2 = -(1 + z1/p2)/(1 - p2/p1)/p2/p1;
@@ -423,8 +426,9 @@ endfunction
 %! p = [p1; p2; 0; 0];
 %! k = [];
 %! e = [1; 1; 1; 2];
 %! b = [1, z1];
 %! a = [1, -(p1 + p2), p1*p2, 0, 0];
 %! [br, ar] = residue (r, p, k, e);
 %! assert (br, b, 1e-8);
 %! assert (ar, a, 1e-8);
+
diff --git a/scripts/polynomial/roots.m b/scripts/polynomial/roots.m
--- a/scripts/polynomial/roots.m
+++ b/scripts/polynomial/roots.m
@@ -113,29 +113,27 @@ function r = roots (v)
       r = zeros (n - f(m), 1);
     endif
   else
     r = [];
   endif
 
 endfunction
 
+
 %!test
 %! p = [poly([3 3 3 3]), 0 0 0 0];
 %! r = sort (roots (p));
-%! assert (r, [0; 0; 0; 0; 3; 3; 3; 3], 0.001)
-
-%!assert(all (all (abs (roots ([1, -6, 11, -6]) - [3; 2; 1]) < sqrt (eps))));
-
-%!assert(isempty (roots ([])));
-
-%!error roots ([1, 2; 3, 4]);
+%! assert (r, [0; 0; 0; 0; 3; 3; 3; 3], 0.001);
 
-%!assert(isempty (roots (1)));
-
-%!error roots ([1, 2; 3, 4]);
-
-%!error roots ([1 Inf 1]);
-
-%!error roots ([1 NaN 1]);
+%!assert (isempty (roots ([])))
+%!assert (isempty (roots (1)))
+%!assert (roots ([1, -6, 11, -6]), [3; 2; 1], sqrt (eps))
 
 %!assert(roots ([1e-200, -1e200, 1]), 1e-200)
 %!assert(roots ([1e-200, -1e200 * 1i, 1]), -1e-200 * 1i)
+
+%!error roots ()
+%!error roots (1,2)
+%!error roots ([1, 2; 3, 4])
+%!error <inputs must not contain Inf or NaN> roots ([1 Inf 1])
+%!error <inputs must not contain Inf or NaN> roots ([1 NaN 1])
+
diff --git a/scripts/polynomial/spline.m b/scripts/polynomial/spline.m
--- a/scripts/polynomial/spline.m
+++ b/scripts/polynomial/spline.m
@@ -242,18 +242,18 @@ function ret = spline (x, y, xi)
     ret = ppval (ret, xi);
   endif
 
 endfunction
 
 
 %!demo
 %! x = 0:10; y = sin (x);
-%! xspline = 0:0.1:10; yspline = spline (x,y,xspline);
-%! title ("spline fit to points from sin(x)");
+%! xspline = 0:0.1:10;  yspline = spline (x,y,xspline);
+%! title ("spline fit to points from sin (x)");
 %! plot (xspline,sin(xspline),"r", xspline,yspline,"g-", x,y,"b+");
 %! legend ("original", "interpolation", "interpolation points");
 %! %--------------------------------------------------------
 %! % confirm that interpolated function matches the original
 
 %!shared x,y,abserr
 %! x = [0:10]; y = sin (x); abserr = 1e-14;
 %!assert (spline (x,y,x), y, abserr)
@@ -261,17 +261,17 @@ endfunction
 %!assert (spline (x',y',x'), y', abserr)
 %!assert (spline (x',y',x), y, abserr)
 %!assert (isempty (spline (x',y',[])))
 %!assert (isempty (spline (x,y,[])))
 %!assert (spline (x,[y;y],x), [spline(x,y,x);spline(x,y,x)], abserr)
 %!assert (spline (x,[y;y],x'), [spline(x,y,x);spline(x,y,x)], abserr)
 %!assert (spline (x',[y;y],x), [spline(x,y,x);spline(x,y,x)], abserr)
 %!assert (spline (x',[y;y],x'), [spline(x,y,x);spline(x,y,x)], abserr)
-%! y = cos(x) + i*sin(x);
+%! y = cos (x) + i*sin (x);
 %!assert (spline (x,y,x), y, abserr)
 %!assert (real (spline (x,y,x)), real (y), abserr)
 %!assert (real (spline (x,y,x.')), real (y).', abserr)
 %!assert (real (spline (x.',y.',x.')), real (y).', abserr)
 %!assert (real (spline (x.',y,x)), real (y), abserr)
 %!assert (imag (spline (x,y,x)), imag (y), abserr)
 %!assert (imag (spline (x,y,x.')), imag (y).', abserr)
 %!assert (imag (spline (x.',y.',x.')), imag (y).', abserr)
diff --git a/scripts/set/intersect.m b/scripts/set/intersect.m
--- a/scripts/set/intersect.m
+++ b/scripts/set/intersect.m
@@ -82,34 +82,35 @@ function [c, ia, ib] = intersect (a, b, 
 
 endfunction
 
 
 %!# Test the routine for index vectors ia and ib
 %!test
 %! a = [3 2 4 5 7 6 5 1 0 13 13];
 %! b = [3 5 12 1 1 7];
-%! [c,ia,ib] = intersect(a,b);
-%! assert(c,[1 3 5 7]);
-%! assert(ia,[8 1 7 5]);
-%! assert(ib,[5 1 2 6]);
-%! assert(a(ia),c);
-%! assert(b(ib),c);
+%! [c,ia,ib] = intersect (a, b);
+%! assert (c, [1 3 5 7]);
+%! assert (ia, [8 1 7 5]);
+%! assert (ib, [5 1 2 6]);
+%! assert (a(ia), c);
+%! assert (b(ib), c);
 %!test
 %! a = [1,1,2;1,4,5;2,1,7];
 %! b = [1,4,5;2,3,4;1,1,2;9,8,7];
-%! [c,ia,ib] = intersect(a,b,'rows');
-%! assert(c,[1,1,2;1,4,5]);
-%! assert(ia,[1;2]);
-%! assert(ib,[3;1]);
-%! assert(a(ia,:),c);
-%! assert(b(ib,:),c);
+%! [c,ia,ib] = intersect (a, b, "rows");
+%! assert (c, [1,1,2;1,4,5]);
+%! assert (ia, [1;2]);
+%! assert (ib, [3;1]);
+%! assert (a(ia,:), c);
+%! assert (b(ib,:), c);
 %!test
 %! a = [1 1 1 2 2 2];
 %! b = [1 2 3 4 5 6];
-%! c = intersect(a,b);
+%! c = intersect (a, b);
 %! assert(c, [1,2]);
 %!test
 %! a = [1 2 3 4; 5 6 7 8; 9 10 11 12];
-%! [b, ia, ib] = intersect(a, a, "rows");
-%! assert(b, a);
-%! assert(ia, [1:3]');
-%! assert(ib, [1:3]');
+%! [b, ia, ib] = intersect (a, a, "rows");
+%! assert (b, a);
+%! assert (ia, [1:3]');
+%! assert (ib, [1:3]');
+
diff --git a/scripts/set/ismember.m b/scripts/set/ismember.m
--- a/scripts/set/ismember.m
+++ b/scripts/set/ismember.m
@@ -128,82 +128,89 @@ function [tf, a_idx] = ismember (A, s, v
         a_idx = max (0, jj - na);
       endif
 
     endif
   endif
 
 endfunction
 
-%!assert (ismember ({''}, {'abc', 'def'}), false);
-%!assert (ismember ('abc', {'abc', 'def'}), true);
-%!assert (isempty (ismember ([], [1, 2])), true);
-%!assert (isempty (ismember ({}, {'a', 'b'})), true);
-%!assert (ismember ('', {'abc', 'def'}), false);
-%!fail ('ismember ([], {1, 2})');
-%!fail ('ismember ({[]}, {1, 2})');
-%!fail ('ismember ({}, {1, 2})');
-%!fail ('ismember ({1}, {''1'', ''2''})');
-%!fail ('ismember (1, ''abc'')');
-%!fail ('ismember ({''1''}, {''1'', ''2''},''rows'')');
-%!fail ('ismember ([1 2 3], [5 4 3 1], ''rows'')');
-%!assert (ismember ({'foo', 'bar'}, {'foobar'}), logical ([0, 0]));
-%!assert (ismember ({'foo'}, {'foobar'}), false);
-%!assert (ismember ({'bar'}, {'foobar'}), false);
-%!assert (ismember ({'bar'}, {'foobar', 'bar'}), true);
-%!assert (ismember ({'foo', 'bar'}, {'foobar', 'bar'}), logical ([0, 1]));
-%!assert (ismember ({'xfb', 'f', 'b'}, {'fb', 'b'}), logical ([0, 0, 1]));
-%!assert (ismember ("1", "0123456789."), true);
+
+%!assert (ismember ({""}, {"abc", "def"}), false)
+%!assert (ismember ("abc", {"abc", "def"}), true)
+%!assert (isempty (ismember ([], [1, 2])), true)
+%!assert (isempty (ismember ({}, {'a', 'b'})), true)
+%!assert (ismember ("", {"abc", "def"}), false)
+%!fail ("ismember ([], {1, 2})")
+%!fail ("ismember ({[]}, {1, 2})")
+%!fail ("ismember ({}, {1, 2})")
+%!fail ("ismember ({1}, {'1', '2'})")
+%!fail ("ismember (1, 'abc')")
+%!fail ("ismember ({'1'}, {'1' '2'},'rows')")
+%!fail ("ismember ([1 2 3], [5 4 3 1], 'rows')")
+%!assert (ismember ({"foo", "bar"}, {"foobar"}), [false false])
+%!assert (ismember ({"foo"}, {"foobar"}), false)
+%!assert (ismember ({"bar"}, {"foobar"}), false)
+%!assert (ismember ({"bar"}, {"foobar", "bar"}), true)
+%!assert (ismember ({"foo", "bar"}, {"foobar", "bar"}), [false true])
+%!assert (ismember ({"xfb", "f", "b"}, {"fb", "b"}), [false false true])
+%!assert (ismember ("1", "0123456789."), true)
 
 %!test
 %! [result, a_idx] = ismember ([1, 2], []);
-%! assert (result, logical ([0, 0]))
+%! assert (result, [false false])
 %! assert (a_idx, [0, 0]);
 
 %!test
 %! [result, a_idx] = ismember ([], [1, 2]);
 %! assert (result, logical ([]))
 %! assert (a_idx, []);
 
 %!test
-%! [result, a_idx] = ismember ({'a', 'b'}, '');
-%! assert (result, logical ([0, 0]))
+%! [result, a_idx] = ismember ({"a", "b"}, "");
+%! assert (result, [false false])
 %! assert (a_idx, [0, 0]);
 
 %!test
-%! [result, a_idx] = ismember ({'a', 'b'}, {});
-%! assert (result, logical ([0, 0]))
+%! [result, a_idx] = ismember ({"a", "b"}, {});
+%! assert (result, [false false])
 %! assert (a_idx, [0, 0]);
 
 %!test
-%! [result, a_idx] = ismember ('', {'a', 'b'});
+%! [result, a_idx] = ismember ("", {"a", "b"});
 %! assert (result, false)
 %! assert (a_idx, 0);
 
 %!test
-%! [result, a_idx] = ismember ({}, {'a', 'b'});
+%! [result, a_idx] = ismember ({}, {"a", "b"});
 %! assert (result, logical ([]))
 %! assert (a_idx, []);
 
 %!test
 %! [result, a_idx] = ismember([1 2 3 4 5], [3]);
-%! assert (all (result == logical ([0 0 1 0 0])) && all (a_idx == [0 0 1 0 0]));
+%! assert (result, logical ([0 0 1 0 0]))
+%! assert (a_idx , [0 0 1 0 0]);
 
 %!test
 %! [result, a_idx] = ismember([1 6], [1 2 3 4 5 1 6 1]);
-%! assert (all (result == logical ([1 1])) && a_idx(2) == 7);
+%! assert (result, [true true]);
+%! assert (a_idx(2), 7);
 
 %!test
 %! [result, a_idx] = ismember ([3,10,1], [0,1,2,3,4,5,6,7,8,9]);
-%! assert (all (result == logical ([1, 0, 1])) && all (a_idx == [4, 0, 2]));
+%! assert (result, [true false true]);
+%! assert (a_idx, [4, 0, 2]);
 
 %!test
 %! [result, a_idx] = ismember ("1.1", "0123456789.1");
-%! assert (all (result == logical ([1, 1, 1])) && all (a_idx == [12, 11, 12]));
+%! assert (result, [true true true]);
+%! assert (a_idx, [12, 11, 12]);
 
 %!test
-%! [result, a_idx] = ismember([1:3; 5:7; 4:6], [0:2; 1:3; 2:4; 3:5; 4:6], 'rows');
-%! assert (all (result == logical ([1; 0; 1])) && all (a_idx == [2; 0; 5]));
+%! [result, a_idx] = ismember ([1:3; 5:7; 4:6], [0:2; 1:3; 2:4; 3:5; 4:6], "rows");
+%! assert (result, [true; false; true]);
+%! assert (a_idx, [2; 0; 5]);
 
 %!test
-%! [result, a_idx] = ismember([1.1,1.2,1.3; 2.1,2.2,2.3; 10,11,12], [1.1,1.2,1.3; 10,11,12; 2.12,2.22,2.32], 'rows');
-%! assert (all (result == logical ([1; 0; 1])) && all (a_idx == [1; 0; 2]));
+%! [result, a_idx] = ismember ([1.1,1.2,1.3; 2.1,2.2,2.3; 10,11,12], [1.1,1.2,1.3; 10,11,12; 2.12,2.22,2.32], "rows");
+%! assert (result, [true; false; true]);
+%! assert (a_idx, [1; 0; 2]);
 
diff --git a/scripts/set/powerset.m b/scripts/set/powerset.m
--- a/scripts/set/powerset.m
+++ b/scripts/set/powerset.m
@@ -76,8 +76,9 @@ function p = powerset (a, byrows_arg)
 
 endfunction
 
 
 %!test
 %! c = sort (cellstr ({ [], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]}));
 %! p = sort (cellstr (powerset ([1, 2, 3])));
 %! assert (p, c);
+
diff --git a/scripts/set/setdiff.m b/scripts/set/setdiff.m
--- a/scripts/set/setdiff.m
+++ b/scripts/set/setdiff.m
@@ -85,21 +85,23 @@ function [c, i] = setdiff (a, b, varargi
       if (size (c, 1) != 1 && size (b, 1) == 1)
         c = c.';
       endif
     endif
   endif
 
 endfunction
 
-%!assert(setdiff(["bb";"zz";"bb";"zz"],["bb";"cc";"bb"],"rows"), "zz")
-%!assert(setdiff(["b";"z";"b";"z"],["b";"c";"b"],"rows"), "z")
-%!assert(setdiff(["b";"z";"b";"z"],["b";"c";"b"]), "z")
-%!assert(setdiff([1, 1; 2, 2; 3, 3; 4, 4], [1, 1; 2, 2; 4, 4], "rows"), [3 3])
-%!assert(setdiff([1; 2; 3; 4], [1; 2; 4], "rows"), 3)
-%!assert(setdiff([1, 2; 3, 4], [1, 2; 3, 6], "rows"), [3, 4])
-%!assert(setdiff({"one","two";"three","four"},{"one","two";"three","six"}), {"four"})
+
+%!assert (setdiff (["bb";"zz";"bb";"zz"], ["bb";"cc";"bb"], "rows"), "zz")
+%!assert (setdiff (["b";"z";"b";"z"], ["b";"c";"b"], "rows"), "z")
+%!assert (setdiff (["b";"z";"b";"z"], ["b";"c";"b"]), "z")
+%!assert (setdiff ([1, 1; 2, 2; 3, 3; 4, 4], [1, 1; 2, 2; 4, 4], "rows"), [3 3])
+%!assert (setdiff ([1; 2; 3; 4], [1; 2; 4], "rows"), 3)
+%!assert (setdiff ([1, 2; 3, 4], [1, 2; 3, 6], "rows"), [3, 4])
+%!assert (setdiff ({"one","two";"three","four"}, {"one","two";"three","six"}), {"four"})
 
 %!test
-%! a = [3, 1, 4, 1, 5]; b = [1, 2, 3, 4];
+%! a = [3, 1, 4, 1, 5];  b = [1, 2, 3, 4];
 %! [y, i] = setdiff (a, b.');
-%! assert(y, [5]);
-%! assert(y, a(i));
+%! assert (y, [5]);
+%! assert (y, a(i));
+
diff --git a/scripts/set/setxor.m b/scripts/set/setxor.m
--- a/scripts/set/setxor.m
+++ b/scripts/set/setxor.m
@@ -86,16 +86,17 @@ function [c, ia, ib] = setxor (a, b, var
   endif
   if (nargout > 1)
     ia = ia(i(i <= na));
     ib = ib(i(i > na) - na);
   endif
 
 endfunction
 
-%!assert(setxor([1,2,3],[2,3,4]),[1,4])
-%!assert(setxor({'a'}, {'a', 'b'}), {'b'});
+
+%!assert (setxor ([1,2,3],[2,3,4]),[1,4])
+%!assert (setxor ({'a'}, {'a', 'b'}), {'b'})
 %!test
-%! a = [3, 1, 4, 1, 5]; b = [1, 2, 3, 4];
+%! a = [3, 1, 4, 1, 5];  b = [1, 2, 3, 4];
 %! [y, ia, ib] = setxor (a, b.');
-%! assert(y, [2, 5]);
-%! assert(y, sort([a(ia), b(ib)]));
+%! assert (y, [2, 5]);
+%! assert (y, sort([a(ia), b(ib)]));
 
diff --git a/scripts/set/union.m b/scripts/set/union.m
--- a/scripts/set/union.m
+++ b/scripts/set/union.m
@@ -78,23 +78,22 @@ function [y, ia, ib] = union (a, b, vara
   else
     [y, i] = unique (y, varargin{:});
     ia = i(i <= na);
     ib = i(i > na) - na;
   endif
 
 endfunction
 
-%!assert(all (all (union ([1, 2, 4], [2, 3, 5]) == [1, 2, 3, 4, 5])));
 
-%!assert(all (all (union ([1; 2; 4], [2, 3, 5]) == [1, 2, 3, 4, 5])));
-
-%!assert(all (all (union ([1, 2, 3], [5; 7; 9]) == [1, 2, 3, 5, 7, 9])));
-
-%!error union (1);
-
-%!error union (1, 2, 3);
+%!assert (union ([1, 2, 4], [2, 3, 5]), [1, 2, 3, 4, 5]);
+%!assert (union ([1; 2; 4], [2, 3, 5]), [1, 2, 3, 4, 5]);
+%!assert (union ([1, 2, 3], [5; 7; 9]), [1, 2, 3, 5, 7, 9]);
 
 %!test
-%! a = [3, 1, 4, 1, 5]; b = [1, 2, 3, 4];
+%! a = [3, 1, 4, 1, 5];  b = [1, 2, 3, 4];
 %! [y, ia, ib] = union (a, b.');
-%! assert(y, [1, 2, 3, 4, 5]);
-%! assert(y, sort([a(ia), b(ib)]));
+%! assert (y, [1, 2, 3, 4, 5]);
+%! assert (y, sort ([a(ia), b(ib)]));
+
+%!error union (1)
+%!error union (1, 2, 3)
+
diff --git a/scripts/set/unique.m b/scripts/set/unique.m
--- a/scripts/set/unique.m
+++ b/scripts/set/unique.m
@@ -158,57 +158,59 @@ function [y, i, j] = unique (x, varargin
       i(idx+1) = [];
     else
       i(idx) = [];
     endif
   endif
 
 endfunction
 
-%!assert(unique([1 1 2; 1 2 1; 1 1 2]),[1;2])
-%!assert(unique([1 1 2; 1 0 1; 1 1 2],'rows'),[1 0 1; 1 1 2])
-%!assert(unique([]),[])
-%!assert(unique([1]),[1])
-%!assert(unique([1 2]),[1 2])
-%!assert(unique([1;2]),[1;2])
-%!assert(unique([1,NaN,Inf,NaN,Inf]),[1,Inf,NaN,NaN])
-%!assert(unique({'Foo','Bar','Foo'}),{'Bar','Foo'})
-%!assert(unique({'Foo','Bar','FooBar'}'),{'Bar','Foo','FooBar'}')
-%!assert(unique(zeros(1,0)), zeros(0,1))
-%!assert(unique(zeros(1,0), 'rows'), zeros(1,0))
-%!assert(unique(cell(1,0)), cell(0,1))
-%!assert(unique({}), {})
-%!assert(unique([1,2,2,3,2,4], 'rows'), [1,2,2,3,2,4])
-%!assert(unique([1,2,2,3,2,4]), [1,2,3,4])
-%!assert(unique([1,2,2,3,2,4]', 'rows'), [1,2,3,4]')
-%!assert(unique(sparse([2,0;2,0])), [0,2]')
-%!assert(unique(sparse([1,2;2,3])), [1,2,3]')
-%!assert(unique([1,2,2,3,2,4]', 'rows'), [1,2,3,4]')
-%!assert(unique(single([1,2,2,3,2,4]), 'rows'), single([1,2,2,3,2,4]))
-%!assert(unique(single([1,2,2,3,2,4])), single([1,2,3,4]))
-%!assert(unique(single([1,2,2,3,2,4]'), 'rows'), single([1,2,3,4]'))
-%!assert(unique(uint8([1,2,2,3,2,4]), 'rows'), uint8([1,2,2,3,2,4]))
-%!assert(unique(uint8([1,2,2,3,2,4])), uint8([1,2,3,4]))
-%!assert(unique(uint8([1,2,2,3,2,4]'), 'rows'), uint8([1,2,3,4]'))
+
+%!assert (unique ([1 1 2; 1 2 1; 1 1 2]),[1;2])
+%!assert (unique ([1 1 2; 1 0 1; 1 1 2],"rows"),[1 0 1; 1 1 2])
+%!assert (unique ([]),[])
+%!assert (unique ([1]),[1])
+%!assert (unique ([1 2]),[1 2])
+%!assert (unique ([1;2]),[1;2])
+%!assert (unique ([1,NaN,Inf,NaN,Inf]),[1,Inf,NaN,NaN])
+%!assert (unique ({"Foo","Bar","Foo"}),{"Bar","Foo"})
+%!assert (unique ({"Foo","Bar","FooBar"}'),{"Bar","Foo","FooBar"}')
+%!assert (unique (zeros (1,0)), zeros (0,1))
+%!assert (unique (zeros (1,0), "rows"), zeros (1,0))
+%!assert (unique (cell (1,0)), cell (0,1))
+%!assert (unique ({}), {})
+%!assert (unique ([1,2,2,3,2,4], "rows"), [1,2,2,3,2,4])
+%!assert (unique ([1,2,2,3,2,4]), [1,2,3,4])
+%!assert (unique ([1,2,2,3,2,4]', "rows"), [1,2,3,4]')
+%!assert (unique (sparse ([2,0;2,0])), [0,2]')
+%!assert (unique (sparse ([1,2;2,3])), [1,2,3]')
+%!assert (unique ([1,2,2,3,2,4]', "rows"), [1,2,3,4]')
+%!assert (unique (single ([1,2,2,3,2,4]), "rows"), single ([1,2,2,3,2,4]))
+%!assert (unique (single ([1,2,2,3,2,4])), single ([1,2,3,4]))
+%!assert (unique (single ([1,2,2,3,2,4]'), "rows"), single ([1,2,3,4]'))
+%!assert (unique (uint8 ([1,2,2,3,2,4]), "rows"), uint8 ([1,2,2,3,2,4]))
+%!assert (unique (uint8 ([1,2,2,3,2,4])), uint8 ([1,2,3,4]))
+%!assert (unique (uint8 ([1,2,2,3,2,4]'), "rows"), uint8 ([1,2,3,4]'))
 %!test
-%! [a,i,j] = unique([1,1,2,3,3,3,4]);
-%! assert(a,[1,2,3,4])
-%! assert(i,[2,3,6,7])
-%! assert(j,[1,1,2,3,3,3,4])
+%! [a,i,j] = unique ([1,1,2,3,3,3,4]);
+%! assert (a, [1,2,3,4]);
+%! assert (i, [2,3,6,7]);
+%! assert (j, [1,1,2,3,3,3,4]);
 %!
 %!test
-%! [a,i,j] = unique([1,1,2,3,3,3,4]','first');
-%! assert(a,[1,2,3,4]')
-%! assert(i,[1,3,4,7]')
-%! assert(j,[1,1,2,3,3,3,4]')
+%! [a,i,j] = unique ([1,1,2,3,3,3,4]', "first");
+%! assert (a, [1,2,3,4]');
+%! assert (i, [1,3,4,7]');
+%! assert (j, [1,1,2,3,3,3,4]');
 %!
 %!test
-%! [a,i,j] = unique({'z'; 'z'; 'z'});
-%! assert(a,{'z'})
-%! assert(i,[3]')
-%! assert(j,[1,1,1]')
+%! [a,i,j] = unique ({"z"; "z"; "z"});
+%! assert (a, {"z"});
+%! assert (i, [3]');
+%! assert (j, [1;1;1]);
 %!
 %!test
-%! A=[1,2,3;1,2,3];
-%! [a,i,j] = unique(A,'rows');
-%! assert(a,[1,2,3])
-%! assert(A(i,:),a)
-%! assert(a(j,:),A)
+%! A = [1,2,3;1,2,3];
+%! [a,i,j] = unique (A, "rows");
+%! assert (a, [1,2,3]);
+%! assert (A(i,:), a);
+%! assert (a(j,:), A);
+
diff --git a/scripts/signal/autoreg_matrix.m b/scripts/signal/autoreg_matrix.m
--- a/scripts/signal/autoreg_matrix.m
+++ b/scripts/signal/autoreg_matrix.m
@@ -45,18 +45,19 @@ function X = autoreg_matrix (y, k)
   for j = 1 : k;
     X(:, j+1) = [(zeros (j, 1)); y(1:T-j)];
   endfor
 
 endfunction
 
 
 %!test
-%! K=4;
+%! K = 4;
 %! A = zeros(1,K+1);
 %! A(1) = 1;
 %! B = eye(K+1);
 %! B(:,1) = 1;
-%! assert (autoreg_matrix(A,K),B);
+%! assert (autoreg_matrix (A,K), B);
 
-%!error autoreg_matrix()
-%!error autoreg_matrix(1)
-%!error autoreg_matrix(ones(4,1),5)
+%!error autoreg_matrix ()
+%!error autoreg_matrix (1)
+%!error autoreg_matrix (ones (4,1), 5)
+
diff --git a/scripts/signal/bartlett.m b/scripts/signal/bartlett.m
--- a/scripts/signal/bartlett.m
+++ b/scripts/signal/bartlett.m
@@ -43,21 +43,23 @@ function c = bartlett (m)
   else
     m = m - 1;
     n = fix (m / 2);
     c = [2*(0:n)/m, 2-2*(n+1:m)/m]';
   endif
 
 endfunction
 
-%!assert (bartlett (1), 1);
-%!assert (bartlett (2), zeros (2,1));
-%!assert (bartlett (16), fliplr (bartlett (16)));
-%!assert (bartlett (15), fliplr (bartlett (15)));
+
+%!assert (bartlett (1), 1)
+%!assert (bartlett (2), zeros (2,1))
+%!assert (bartlett (16), fliplr (bartlett (16)))
+%!assert (bartlett (15), fliplr (bartlett (15)))
 %!test
 %! N = 9;
 %! A = bartlett (N);
-%! assert (A (ceil (N/2)), 1);
+%! assert (A(ceil (N/2)), 1);
 
-%!error bartlett ();
-%!error bartlett (0.5);
-%!error bartlett (-1);
-%!error bartlett (ones(1,4));
+%!error bartlett ()
+%!error bartlett (0.5)
+%!error bartlett (-1)
+%!error bartlett (ones (1,4))
+
diff --git a/scripts/signal/blackman.m b/scripts/signal/blackman.m
--- a/scripts/signal/blackman.m
+++ b/scripts/signal/blackman.m
@@ -42,22 +42,24 @@ function c = blackman (m)
   else
     m = m - 1;
     k = (0 : m)' / m;
     c = 0.42 - 0.5 * cos (2 * pi * k) + 0.08 * cos (4 * pi * k);
   endif
 
 endfunction
 
-%!assert (blackman (1), 1);
-%!assert (blackman (2), zeros(2,1), 1e-6);
-%!assert (blackman (16), fliplr (blackman (16)));
-%!assert (blackman (15), fliplr (blackman (15)));
+
+%!assert (blackman (1), 1)
+%!assert (blackman (2), zeros (2,1), 1e-6)
+%!assert (blackman (16), fliplr (blackman (16)))
+%!assert (blackman (15), fliplr (blackman (15)))
 %!test
 %! N = 9;
 %! A = blackman (N);
 %! assert (A (ceil (N/2)), 1, 1e-6);
 %! assert ([A(1), A(length (A))], zeros (1, 2), 1e-6);
 
-%!error blackman ();
-%!error blackman (0.5);
-%!error blackman (-1);
-%!error blackman (ones(1,4));
+%!error blackman ()
+%!error blackman (0.5)
+%!error blackman (-1)
+%!error blackman (ones (1,4))
+
diff --git a/scripts/signal/detrend.m b/scripts/signal/detrend.m
--- a/scripts/signal/detrend.m
+++ b/scripts/signal/detrend.m
@@ -62,28 +62,29 @@ function y = detrend (x, p = 1)
   y = x - b * (b \ x);
 
   if (m == 1)
     y = y';
   endif
 
 endfunction
 
-%!test
-%! N=32;
-%! x = (0:1:N-1)/N + 2;
-%! y = detrend(x);
-%! assert(all (all (abs (y) < 20*eps)));
 
 %!test
-%! N=32;
+%! N = 32;
+%! x = (0:1:N-1)/N + 2;
+%! y = detrend (x);
+%! assert (abs (y(:)) < 20*eps);
+
+%!test
+%! N = 32;
 %! t = (0:1:N-1)/N;
 %! x = t .* t + 2;
-%! y = detrend(x,2);
-%! assert(all (all (abs (y) < 30*eps)));
+%! y = detrend (x,2);
+%! assert (abs (y(:)) < 30*eps);
 
 %!test
-%! N=32;
+%! N = 32;
 %! t = (0:1:N-1)/N;
 %! x = [t;4*t-3]';
-%! y = detrend(x);
-%! assert(all (all (abs (y) < 20*eps)));
+%! y = detrend (x);
+%! assert (abs (y(:)) < 20*eps);
 
diff --git a/scripts/signal/fftconv.m b/scripts/signal/fftconv.m
--- a/scripts/signal/fftconv.m
+++ b/scripts/signal/fftconv.m
@@ -79,28 +79,29 @@ endfunction
 %!  assert (fftconv (c, y), [3, 3, 3], 5*eps);
 %!  assert (fftconv (x, c), [3; 3; 3], 5*eps);
 %!  assert (fftconv (y, c), [3, 3, 3], 5*eps);
 %!  assert (fftconv (b, c), 6, 5*eps);
 
 %!test
 %!  a = 1:10;
 %!  b = 1:3;
-%!  assert (size(conv(a,b)), [1, numel(a)+numel(b)-1])
-%!  assert (size(conv(b,a)), [1, numel(a)+numel(b)-1])
+%!  assert (size (conv (a,b)), [1, numel(a)+numel(b)-1])
+%!  assert (size (conv (b,a)), [1, numel(a)+numel(b)-1])
 
 %!  a = (1:10).';
 %!  b = 1:3;
-%!  assert (size(conv(a,b)), [numel(a)+numel(b)-1, 1])
-%!  assert (size(conv(b,a)), [numel(a)+numel(b)-1, 1])
+%!  assert (size (conv (a,b)), [numel(a)+numel(b)-1, 1])
+%!  assert (size (conv (b,a)), [numel(a)+numel(b)-1, 1])
 
 %!test
 %!  a = 1:10;
 %!  b = (1:3).';
-%!  assert (size(conv(a,b)), [1, numel(a)+numel(b)-1])
-%!  assert (size(conv(b,a)), [1, numel(a)+numel(b)-1])
+%!  assert (size (conv (a,b)), [1, numel(a)+numel(b)-1])
+%!  assert (size (conv (b,a)), [1, numel(a)+numel(b)-1])
 
 %% Test input validation
-%!error fftconv (1);
-%!error fftconv (1,2,3,4);
-%!error fftconv ([1, 2; 3, 4], 3);
-%!error fftconv (2, []);
-%!error fftconv ([1,1], [2,2] , [3, 4]);
+%!error fftconv (1)
+%!error fftconv (1,2,3,4)
+%!error fftconv ([1, 2; 3, 4], 3)
+%!error fftconv (2, [])
+%!error fftconv ([1,1], [2,2] , [3, 4])
+
diff --git a/scripts/signal/fftfilt.m b/scripts/signal/fftfilt.m
--- a/scripts/signal/fftfilt.m
+++ b/scripts/signal/fftfilt.m
@@ -109,43 +109,43 @@ function y = fftfilt (b, x, n)
     y(:, idx) = round (y(:, idx));
   endif
 
 endfunction
 
 
 %!shared b, x, r
 %!test
-%!  b = [1 1];
-%!  x = [1, zeros(1,9)];
-%!  assert(fftfilt(b,  x  ), [1 1 0 0 0 0 0 0 0 0]  , eps);
-%!  assert(fftfilt(b,  x.'), [1 1 0 0 0 0 0 0 0 0].', eps);
-%!  assert(fftfilt(b.',x  ), [1 1 0 0 0 0 0 0 0 0]  , eps);
-%!  assert(fftfilt(b.',x.'), [1 1 0 0 0 0 0 0 0 0].', eps);
+%! b = [1 1];
+%! x = [1, zeros(1,9)];
+%! assert (fftfilt (b,  x  ), [1 1 0 0 0 0 0 0 0 0]  , eps);
+%! assert (fftfilt (b,  x.'), [1 1 0 0 0 0 0 0 0 0].', eps);
+%! assert (fftfilt (b.',x  ), [1 1 0 0 0 0 0 0 0 0]  , eps);
+%! assert (fftfilt (b.',x.'), [1 1 0 0 0 0 0 0 0 0].', eps);
 
 %!test
-%!  r = sqrt(1/2) * (1+i);
-%!  b = b*r;
-%!  assert(fftfilt(b, x  ), r*[1 1 0 0 0 0 0 0 0 0]  , eps);
-%!  assert(fftfilt(b, r*x), r*r*[1 1 0 0 0 0 0 0 0 0], eps);
-%!  assert(fftfilt(b, x.'), r*[1 1 0 0 0 0 0 0 0 0].', eps);
+%! r = sqrt (1/2) * (1+i);
+%! b = b*r;
+%! assert (fftfilt (b, x  ), r*[1 1 0 0 0 0 0 0 0 0]  , eps);
+%! assert (fftfilt (b, r*x), r*r*[1 1 0 0 0 0 0 0 0 0], eps);
+%! assert (fftfilt (b, x.'), r*[1 1 0 0 0 0 0 0 0 0].', eps);
 
 %!test
-%!  b = [1 1];
-%!  x = zeros (10,3); x(1,1)=-1; x(1,2)=1;
-%!  y0 = zeros (10,3); y0(1:2,1)=-1; y0(1:2,2)=1;
-%!  y = fftfilt (b, x);
-%!  assert (y,y0);
+%! b = [1 1];
+%! x = zeros (10,3); x(1,1)=-1; x(1,2)=1;
+%! y0 = zeros (10,3); y0(1:2,1)=-1; y0(1:2,2)=1;
+%! y = fftfilt (b, x);
+%! assert (y,y0);
 
 %!test
-%!  b  = rand (10, 1);
-%!  x  = rand (10, 1);
-%!  y0 = filter (b, 1, x);
-%!  y  = filter (b, 1, x);
-%!  assert (y, y0);
+%! b  = rand (10, 1);
+%! x  = rand (10, 1);
+%! y0 = filter (b, 1, x);
+%! y  = filter (b, 1, x);
+%! assert (y, y0);
 
 %% Test input validation
 %!error fftfilt (1)
 %!error fftfilt (1, 2, 3, 4)
 %!error fftfilt (ones (2), 1)
 %!error fftfilt (2, ones (3,3,3))
 %!error fftfilt (2, 1, ones (2))
 
diff --git a/scripts/signal/fftshift.m b/scripts/signal/fftshift.m
--- a/scripts/signal/fftshift.m
+++ b/scripts/signal/fftshift.m
@@ -82,50 +82,50 @@ function retval = fftshift (x, dim)
   endif
 
 endfunction
 
 
 %!test
 %!  x = [0:7];
 %!  y = fftshift (x);
-%!  assert(y, [4 5 6 7 0 1 2 3]);
-%!  assert(fftshift (y), x);
+%!  assert (y, [4 5 6 7 0 1 2 3]);
+%!  assert (fftshift (y), x);
 
 %!test
 %!  x = [0:6];
 %!  y = fftshift (x);
-%!  assert(y, [4 5 6 0 1 2 3]);
-%!  assert(fftshift (y), [1 2 3 4 5 6 0]);
+%!  assert (y, [4 5 6 0 1 2 3]);
+%!  assert (fftshift (y), [1 2 3 4 5 6 0]);
 
 %!test
 %!  x = [0:7]';
 %!  y = fftshift (x);
-%!  assert(y, [4;5;6;7;0;1;2;3]);
-%!  assert(fftshift (y), x);
+%!  assert (y, [4;5;6;7;0;1;2;3]);
+%!  assert (fftshift (y), x);
 
 %!test
 %!  x = [0:6]';
 %!  y = fftshift (x);
-%!  assert(y, [4;5;6;0;1;2;3]);
-%!  assert(fftshift (y), [1;2;3;4;5;6;0]);
+%!  assert (y, [4;5;6;0;1;2;3]);
+%!  assert (fftshift (y), [1;2;3;4;5;6;0]);
 
 %!test
 %!  x = [0:3];
 %!  x = [x;2*x;3*x+1;4*x+1];
 %!  y = fftshift (x);
-%!  assert(y, [[7 10 1 4];[9 13 1 5];[2 3 0 1];[4 6 0 2]]);
-%!  assert(fftshift (y), x);
+%!  assert (y, [[7 10 1 4];[9 13 1 5];[2 3 0 1];[4 6 0 2]]);
+%!  assert (fftshift (y), x);
 
 %!test
 %!  x = [0:3];
 %!  x = [x;2*x;3*x+1;4*x+1];
 %!  y = fftshift (x,1);
-%!  assert(y, [[1 4 7 10];[1 5 9 13];[0 1 2 3];[0 2 4 6]]);
-%!  assert(fftshift (y,1), x);
+%!  assert (y, [[1 4 7 10];[1 5 9 13];[0 1 2 3];[0 2 4 6]]);
+%!  assert (fftshift (y,1), x);
 
 %!test
 %!  x = [0:3];
 %!  x = [x;2*x;3*x+1;4*x+1];
 %!  y = fftshift (x,2);
-%!  assert(y, [[2 3 0 1];[4 6 0 2];[7 10 1 4];[9 13 1 5]]);
-%!  assert(fftshift (y,2), x);
+%!  assert (y, [[2 3 0 1];[4 6 0 2];[7 10 1 4];[9 13 1 5]]);
+%!  assert (fftshift (y,2), x);
 
diff --git a/scripts/signal/freqz.m b/scripts/signal/freqz.m
--- a/scripts/signal/freqz.m
+++ b/scripts/signal/freqz.m
@@ -164,34 +164,35 @@ function [h_r, f_r] = freqz (b, a, n, re
     f_r = f;
   else
     ## Plot and don't return values.
     freqz_plot (f, h);
   endif
 
 endfunction
 
+
 %!test # correct values and fft-polyval consistency
 %! # butterworth filter, order 2, cutoff pi/2 radians
 %! b = [0.292893218813452  0.585786437626905  0.292893218813452];
 %! a = [1  0  0.171572875253810];
-%! [h,w] = freqz(b,a,32);
-%! assert(h(1),1,10*eps);
-%! assert(abs(h(17)).^2,0.5,10*eps);
-%! assert(h,freqz(b,a,w),10*eps); # fft should be consistent with polyval
+%! [h,w] = freqz (b,a,32);
+%! assert (h(1),1,10*eps);
+%! assert (abs (h(17)).^2,0.5,10*eps);
+%! assert (h,freqz (b,a,w),10*eps); # fft should be consistent with polyval
 
 %!test # whole-half consistency
 %! b = [1 1 1]/3; # 3-sample average
-%! [h,w] = freqz(b,1,32,'whole');
-%! assert(h(2:16),conj(h(32:-1:18)),20*eps);
-%! [h2,w2] = freqz(b,1,16,'half');
-%! assert(h(1:16),h2,20*eps);
-%! assert(w(1:16),w2,20*eps);
+%! [h,w] = freqz (b,1,32,"whole");
+%! assert (h(2:16),conj (h(32:-1:18)),20*eps);
+%! [h2,w2] = freqz (b,1,16,"half");
+%! assert (h(1:16),h2,20*eps);
+%! assert (w(1:16),w2,20*eps);
 
 %!test # Sampling frequency properly interpreted
 %! b = [1 1 1]/3; a = [1 0.2];
-%! [h,f] = freqz(b,a,16,320);
-%! assert(f,[0:15]'*10,10*eps);
-%! [h2,f2] = freqz(b,a,[0:15]*10,320);
-%! assert(f2,[0:15]*10,10*eps);
-%! assert(h,h2.',20*eps);
-%! [h3,f3] = freqz(b,a,32,'whole',320);
-%! assert(f3,[0:31]'*10,10*eps);
+%! [h,f] = freqz (b,a,16,320);
+%! assert (f,[0:15]'*10,10*eps);
+%! [h2,f2] = freqz (b,a,[0:15]*10,320);
+%! assert (f2,[0:15]*10,10*eps);
+%! assert (h,h2.',20*eps);
+%! [h3,f3] = freqz (b,a,32,"whole",320);
+%! assert (f3,[0:31]'*10,10*eps);
diff --git a/scripts/signal/hamming.m b/scripts/signal/hamming.m
--- a/scripts/signal/hamming.m
+++ b/scripts/signal/hamming.m
@@ -41,21 +41,23 @@ function c = hamming (m)
     c = 1;
   else
     m = m - 1;
     c = 0.54 - 0.46 * cos (2 * pi * (0:m)' / m);
   endif
 
 endfunction
 
-%!assert (hamming (1), 1);
-%!assert (hamming (2), (0.54 - 0.46)*ones(2,1));
-%!assert (hamming (16), fliplr (hamming (16)));
-%!assert (hamming (15), fliplr (hamming (15)));
+
+%!assert (hamming (1), 1)
+%!assert (hamming (2), (0.54 - 0.46)*ones (2,1))
+%!assert (hamming (16), fliplr (hamming (16)))
+%!assert (hamming (15), fliplr (hamming (15)))
 %!test
 %! N = 15;
 %! A = hamming (N);
 %! assert (A (ceil (N/2)), 1);
 
-%!error hamming ();
-%!error hamming (0.5);
-%!error hamming (-1);
-%!error hamming (ones(1,4));
+%!error hamming ()
+%!error hamming (0.5)
+%!error hamming (-1)
+%!error hamming (ones (1,4))
+
diff --git a/scripts/signal/hanning.m b/scripts/signal/hanning.m
--- a/scripts/signal/hanning.m
+++ b/scripts/signal/hanning.m
@@ -41,21 +41,23 @@ function c = hanning (m)
     c = 1;
   else
     m = m - 1;
     c = 0.5 - 0.5 * cos (2 * pi * (0 : m)' / m);
   endif
 
 endfunction
 
+
 %!assert (hanning (1), 1);
-%!assert (hanning (2), zeros(2,1));
+%!assert (hanning (2), zeros (2,1));
 %!assert (hanning (16), fliplr (hanning (16)));
 %!assert (hanning (15), fliplr (hanning (15)));
 %!test
 %! N = 15;
 %! A = hanning (N);
-%! assert (A (ceil (N/2)), 1);
+%! assert (A(ceil (N/2)), 1);
 
-%!error hanning ();
-%!error hanning (0.5);
-%!error hanning (-1);
-%!error hanning (ones(1,4));
+%!error hanning ()
+%!error hanning (0.5)
+%!error hanning (-1)
+%!error hanning (ones(1,4))
+
diff --git a/scripts/signal/ifftshift.m b/scripts/signal/ifftshift.m
--- a/scripts/signal/ifftshift.m
+++ b/scripts/signal/ifftshift.m
@@ -64,53 +64,54 @@ function retval = ifftshift (x, dim)
       retval = x(idx{:});
     else
       error ("ifftshift: expecting vector or matrix argument");
     endif
   endif
 
 endfunction
 
+
 %!test
-%!  x = [0:7];
-%!  y = ifftshift (x);
-%!  assert(y, [4 5 6 7 0 1 2 3]);
-%!  assert(ifftshift (y), x);
+%! x = [0:7];
+%! y = ifftshift (x);
+%! assert (y, [4 5 6 7 0 1 2 3]);
+%! assert (ifftshift (y), x);
 
 %!test
-%!  x = [0:6];
-%!  y = ifftshift (x);
-%!  assert(y, [3 4 5 6 0 1 2]);
-%!  assert(ifftshift (y), [6 0 1 2 3 4 5]);
+%! x = [0:6];
+%! y = ifftshift (x);
+%! assert (y, [3 4 5 6 0 1 2]);
+%! assert (ifftshift (y), [6 0 1 2 3 4 5]);
 
 %!test
-%!  x = [0:7]';
-%!  y = ifftshift (x);
-%!  assert(y, [4;5;6;7;0;1;2;3]);
-%!  assert(ifftshift (y), x);
+%! x = [0:7]';
+%! y = ifftshift (x);
+%! assert (y, [4;5;6;7;0;1;2;3]);
+%! assert (ifftshift (y), x);
 
 %!test
-%!  x = [0:6]';
-%!  y = ifftshift (x);
-%!  assert(y, [3;4;5;6;0;1;2]);
-%!  assert(ifftshift (y), [6;0;1;2;3;4;5]);
+%! x = [0:6]';
+%! y = ifftshift (x);
+%! assert (y, [3;4;5;6;0;1;2]);
+%! assert (ifftshift (y), [6;0;1;2;3;4;5]);
 
 %!test
-%!  x = [0:3];
-%!  x = [x;2*x;3*x+1;4*x+1];
-%!  y = ifftshift (x);
-%!  assert(y, [[7 10 1 4];[9 13 1 5];[2 3 0 1];[4 6 0 2]]);
-%!  assert(ifftshift (y), x);
+%! x = [0:3];
+%! x = [x;2*x;3*x+1;4*x+1];
+%! y = ifftshift (x);
+%! assert (y, [[7 10 1 4];[9 13 1 5];[2 3 0 1];[4 6 0 2]]);
+%! assert (ifftshift (y), x);
 
 %!test
-%!  x = [0:3];
-%!  x = [x;2*x;3*x+1;4*x+1];
-%!  y = ifftshift (x,1);
-%!  assert(y, [[1 4 7 10];[1 5 9 13];[0 1 2 3];[0 2 4 6]]);
-%!  assert(ifftshift (y,1), x);
+%! x = [0:3];
+%! x = [x;2*x;3*x+1;4*x+1];
+%! y = ifftshift (x,1);
+%! assert (y, [[1 4 7 10];[1 5 9 13];[0 1 2 3];[0 2 4 6]]);
+%! assert (ifftshift (y,1), x);
 
 %!test
-%!  x = [0:3];
-%!  x = [x;2*x;3*x+1;4*x+1];
-%!  y = ifftshift (x,2);
-%!  assert(y, [[2 3 0 1];[4 6 0 2];[7 10 1 4];[9 13 1 5]]);
-%!  assert(ifftshift (y,2), x);
+%! x = [0:3];
+%! x = [x;2*x;3*x+1;4*x+1];
+%! y = ifftshift (x,2);
+%! assert (y, [[2 3 0 1];[4 6 0 2];[7 10 1 4];[9 13 1 5]]);
+%! assert (ifftshift (y,2), x);
 
diff --git a/scripts/signal/sinc.m b/scripts/signal/sinc.m
--- a/scripts/signal/sinc.m
+++ b/scripts/signal/sinc.m
@@ -42,13 +42,14 @@ function result = sinc (x)
   if (any (i(:)))
     t = pi * x(i);
     result(i) = sin (t) ./ t;
   endif
 
 endfunction
 
 
-%!assert (sinc (0), 1);
-%!assert (sinc (1), 0,1e-6);
+%!assert (sinc (0), 1)
+%!assert (sinc (1), 0,1e-6)
 %!assert (sinc (1/2), 2/pi, 1e-6)
 
 %!error sinc()
+
diff --git a/scripts/signal/sinetone.m b/scripts/signal/sinetone.m
--- a/scripts/signal/sinetone.m
+++ b/scripts/signal/sinetone.m
@@ -59,9 +59,10 @@ function retval = sinetone (freq, rate, 
 
   for k = 1:n
     retval (:, k) = ampl(k) * sin (2 * pi * (1:ns) / rate * freq(k))';
   endfor
 
 endfunction
 
 
-%!assert (size (sinetone (18e6, 150e6, 19550/150e6, 1)), [19550, 1]);
+%!assert (size (sinetone (18e6, 150e6, 19550/150e6, 1)), [19550, 1])
+
diff --git a/scripts/signal/sinewave.m b/scripts/signal/sinewave.m
--- a/scripts/signal/sinewave.m
+++ b/scripts/signal/sinewave.m
@@ -39,17 +39,19 @@ function x = sinewave (m, n, d)
     endif
     x = sin (((1 : m) + d - 1) * 2 * pi / n);
   else
     print_usage ();
   endif
 
 endfunction
 
-%!assert (sinewave (1), 0);
-%!assert (sinewave (1, 4, 1), 1);
-%!assert (sinewave (1, 12, 1), 1/2, 1e-6);
-%!assert (sinewave (1, 12, 2), sqrt (3)/2, 1e-6);
-%!assert (sinewave (1, 20, 1), (sqrt (5)-1)/4, 1e-6);
-%!assert (sinewave (1), sinewave (1, 1,0));
-%!assert (sinewave (3, 4), sinewave(3, 4, 0));
 
-%!error sinewave ();
+%!assert (sinewave (1), 0)
+%!assert (sinewave (1, 4, 1), 1)
+%!assert (sinewave (1, 12, 1), 1/2, 1e-6)
+%!assert (sinewave (1, 12, 2), sqrt (3)/2, 1e-6)
+%!assert (sinewave (1, 20, 1), (sqrt (5)-1)/4, 1e-6)
+%!assert (sinewave (1), sinewave (1, 1,0))
+%!assert (sinewave (3, 4), sinewave (3, 4, 0))
+
+%!error sinewave ()
+
diff --git a/scripts/signal/unwrap.m b/scripts/signal/unwrap.m
--- a/scripts/signal/unwrap.m
+++ b/scripts/signal/unwrap.m
@@ -84,73 +84,75 @@ function retval = unwrap (x, tol, dim)
   r = cumsum (p, dim);
 
   ## Now add the "steps" to the original data and put output in the
   ## same shape as originally.
   retval = x + r;
 
 endfunction
 
+
 %!function t = __xassert(a,b,tol)
 %!  if (nargin == 1)
-%!    t = all(a(:));
+%!    t = all (a(:));
 %!  else
 %!    if (nargin == 2)
 %!      tol = 0;
 %!    endif
-%!    if (any (size(a) != size(b)))
+%!    if (any (size (a) != size (b)))
 %!      t = 0;
-%!    elseif (any (abs(a(:) - b(:)) > tol))
+%!    elseif (any (abs (a(:) - b(:)) > tol))
 %!      t = 0;
 %!    else
 %!      t = 1;
 %!    endif
 %!  endif
 %!endfunction
 %!
 %!test
 %!
 %! i = 0;
 %! t = [];
 %!
 %! r = [0:100];                        # original vector
-%! w = r - 2*pi*floor((r+pi)/(2*pi));  # wrapped into [-pi,pi]
+%! w = r - 2*pi*floor ((r+pi)/(2*pi)); # wrapped into [-pi,pi]
 %! tol = 1e3*eps;                      # maximum expected deviation
 %!
-%! t(++i) = __xassert(r, unwrap(w), tol);               #unwrap single row
-%! t(++i) = __xassert(r', unwrap(w'), tol);             #unwrap single column
-%! t(++i) = __xassert([r',r'], unwrap([w',w']), tol);   #unwrap 2 columns
-%! t(++i) = __xassert([r;r], unwrap([w;w],[],2), tol);  #check that dim works
-%! t(++i) = __xassert(r+10, unwrap(10+w), tol);         #check r(1)>pi works
+%! t(++i) = __xassert (r, unwrap (w), tol);              #unwrap single row
+%! t(++i) = __xassert (r', unwrap (w'), tol);            #unwrap single column
+%! t(++i) = __xassert ([r',r'], unwrap ([w',w']), tol);  #unwrap 2 columns
+%! t(++i) = __xassert ([r;r], unwrap ([w;w],[],2), tol); #check that dim works
+%! t(++i) = __xassert (r+10, unwrap (10+w), tol);        #check r(1)>pi works
 %!
-%! t(++i) = __xassert(w', unwrap(w',[],2));  #unwrap col by rows should not change it
-%! t(++i) = __xassert(w, unwrap(w,[],1));    #unwrap row by cols should not change it
-%! t(++i) = __xassert([w;w], unwrap([w;w])); #unwrap 2 rows by cols should not change them
+%! t(++i) = __xassert (w', unwrap (w',[],2));  #unwrap col by rows should not change it
+%! t(++i) = __xassert (w, unwrap (w,[],1));    #unwrap row by cols should not change it
+%! t(++i) = __xassert ([w;w], unwrap ([w;w])); #unwrap 2 rows by cols should not change them
 %!
 %! ## verify that setting tolerance too low will cause bad results.
-%! t(++i) = __xassert(any(abs(r - unwrap(w,0.8)) > 100));
+%! t(++i) = __xassert (any (abs (r - unwrap (w,0.8)) > 100));
 %!
-%! assert(all(t));
+%! assert (all (t));
 %!
 %!test
 %! A = [pi*(-4), pi*(-2+1/6), pi/4, pi*(2+1/3), pi*(4+1/2), pi*(8+2/3), pi*(16+1), pi*(32+3/2), pi*64];
-%! assert (unwrap(A), unwrap(A, pi));
-%! assert (unwrap(A, pi), unwrap(A, pi, 2));
-%! assert (unwrap(A', pi), unwrap(A', pi, 1));
+%! assert (unwrap (A), unwrap (A, pi));
+%! assert (unwrap (A, pi), unwrap (A, pi, 2));
+%! assert (unwrap (A', pi), unwrap (A', pi, 1));
 %!
 %!test
 %! A = [pi*(-4); pi*(2+1/3); pi*(16+1)];
 %! B = [pi*(-2+1/6); pi*(4+1/2); pi*(32+3/2)];
 %! C = [pi/4; pi*(8+2/3); pi*64];
 %! D = [pi*(-2+1/6); pi*(2+1/3); pi*(8+2/3)];
 %! E(:, :, 1) = [A, B, C, D];
 %! E(:, :, 2) = [A+B, B+C, C+D, D+A];
 %! F(:, :, 1) = [unwrap(A), unwrap(B), unwrap(C), unwrap(D)];
 %! F(:, :, 2) = [unwrap(A+B), unwrap(B+C), unwrap(C+D), unwrap(D+A)];
-%! assert (unwrap(E), F);
+%! assert (unwrap (E), F);
 %!
 %!test
 %! A = [0, 2*pi, 4*pi, 8*pi, 16*pi, 65536*pi];
 %! B = [pi*(-2+1/6), pi/4, pi*(2+1/3), pi*(4+1/2), pi*(8+2/3), pi*(16+1), pi*(32+3/2), pi*64];
-%! assert (unwrap(A), zeros(1, length(A)));
-%! assert (diff(unwrap(B), 1)<2*pi, true(1, length(B)-1));
-%!
+%! assert (unwrap (A), zeros (1, length (A)));
+%! assert (diff (unwrap (B), 1) < 2*pi, true (1, length (B)-1));
+
 %!error unwrap()
+
diff --git a/scripts/sparse/bicg.m b/scripts/sparse/bicg.m
--- a/scripts/sparse/bicg.m
+++ b/scripts/sparse/bicg.m
@@ -223,17 +223,16 @@ endfunction;
 %! A = spdiags ([-2*ones(n,1) 4*ones(n,1) -ones(n,1)], -1:1, n, n);
 %! b = sum (A, 2);
 %! tol = 1e-8;
 %! maxit = 15;
 %! M1 = spdiags ([ones(n,1)/(-2) ones(n,1)],-1:0, n, n);
 %! M2 = spdiags ([4*ones(n,1) -ones(n,1)], 0:1, n, n);
 %! [x, flag, relres, iter, resvec] = bicg (A, b, tol, maxit, M1, M2);
 %! assert (x, ones (size (b)), 1e-7);
-%!
 
 %!function y = afun (x, t, a)
 %!  switch t
 %!   case "notransp"
 %!     y = a * x;
 %!   case "transp"
 %!     y = a' * x;
 %!  endswitch
@@ -255,8 +254,9 @@ endfunction;
 %!test
 %! n = 100;
 %! tol = 1e-8;
 %! a = sprand (n, n, .1);
 %! A = a' * a + 100 * eye (n);
 %! b = sum (A, 2);
 %! [x, flag, relres, iter, resvec] = bicg (A, b, tol, [], diag (diag (A)));
 %! assert (x, ones (size (b)), 1e-7);
+
diff --git a/scripts/sparse/bicgstab.m b/scripts/sparse/bicgstab.m
--- a/scripts/sparse/bicgstab.m
+++ b/scripts/sparse/bicgstab.m
@@ -241,8 +241,9 @@ endfunction
 %!test
 %! n = 100;
 %! tol = 1e-8;
 %! a = sprand (n, n, .1);
 %! A = a'*a + 100 * eye (n);
 %! b = sum (A, 2);
 %! [x, flag, relres, iter, resvec] = bicgstab (A, b, tol, [], diag (diag (A)));
 %! assert (x, ones (size (b)), 1e-7);
+
diff --git a/scripts/sparse/gmres.m b/scripts/sparse/gmres.m
--- a/scripts/sparse/gmres.m
+++ b/scripts/sparse/gmres.m
@@ -192,27 +192,28 @@ function [x, flag, presn, it, resids] = 
 
 endfunction
 
 
 %!shared A, b, dim
 %! dim = 100;
 %!test
 %! A = spdiags ([-ones(dim,1) 2*ones(dim,1) ones(dim,1)], [-1:1], dim, dim);
-%! b = ones(dim, 1);
-%! x = gmres (A, b, 10, 1e-10, dim, @(x) x./diag(A), [],  b);
-%! assert(x, A\b, 1e-9*norm(x,inf));
+%! b = ones (dim, 1);
+%! x = gmres (A, b, 10, 1e-10, dim, @(x) x ./ diag (A), [], b);
+%! assert (x, A\b, 1e-9*norm (x, Inf));
 %!
 %!test
-%! x = gmres (A, b, dim, 1e-10, 1e4, @(x) diag(diag(A))\x, [],  b);
-%! assert(x, A\b, 1e-7*norm(x,inf));
+%! x = gmres (A, b, dim, 1e-10, 1e4, @(x) diag (diag (A)) \ x, [], b);
+%! assert(x, A\b, 1e-7*norm (x, Inf));
 %!
 %!test
 %! A = spdiags ([[1./(2:2:2*(dim-1)) 0]; 1./(1:2:2*dim-1); [0 1./(2:2:2*(dim-1))]]', -1:1, dim, dim);
 %! A = A'*A;
 %! b = rand (dim, 1);
-%! [x, resids] = gmres (@(x) A*x, b, dim, 1e-10, dim, @(x) x./diag(A), [],  []);
-%! assert(x, A\b, 1e-9*norm(x,inf))
-%! x = gmres (@(x) A*x, b, dim, 1e-10, 1e6, @(x) diag(diag(A))\x, [],  []);
-%! assert(x, A\b, 1e-9*norm(x,inf));
+%! [x, resids] = gmres (@(x) A*x, b, dim, 1e-10, dim, @(x) x./diag (A), [], []);
+%! assert (x, A\b, 1e-9*norm (x, Inf));
+%! x = gmres (@(x) A*x, b, dim, 1e-10, 1e6, @(x) diag (diag (A)) \ x, [], []);
+%! assert (x, A\b, 1e-9*norm (x, Inf));
 %!test
-%! x =  gmres (@(x) A*x, b, dim, 1e-10, 1e6, @(x) x./diag(A), [],  []);
-%! assert(x, A\b, 1e-7*norm(x,inf));
+%! x = gmres (@(x) A*x, b, dim, 1e-10, 1e6, @(x) x./diag(A), [], []);
+%! assert (x, A\b, 1e-7*norm (x, Inf));
+
diff --git a/scripts/sparse/gplot.m b/scripts/sparse/gplot.m
--- a/scripts/sparse/gplot.m
+++ b/scripts/sparse/gplot.m
@@ -75,10 +75,10 @@ endfunction
 %!       4  , 0];
 %!
 %! clf;
 %! gplot (A, xy, "o-");
 %! set (get (gca, ("children")), "markersize", 12);
 %! title ("gplot() of Binary Tree Adjacency matrix");
 
 %% Mark graphical function as tested by demo block
-%!assert (1);
+%!assert (1)
 
diff --git a/scripts/sparse/nonzeros.m b/scripts/sparse/nonzeros.m
--- a/scripts/sparse/nonzeros.m
+++ b/scripts/sparse/nonzeros.m
@@ -29,12 +29,13 @@ function t = nonzeros (s)
 
   [~, ~, t] = find (s);
 
   t = t(:);
 
 endfunction
 
 
-%!assert(nonzeros([1,2;3,0]),[1;3;2])
-%!assert(nonzeros([1,2,3,0]),[1;2;3])
-%!assert(nonzeros(sparse([1,2;3,0])),[1;3;2])
-%!assert(nonzeros(sparse([1,2,3,0])),[1;2;3])
+%!assert (nonzeros ([1,2;3,0]), [1;3;2])
+%!assert (nonzeros ([1,2,3,0]), [1;2;3])
+%!assert (nonzeros (sparse ([1,2;3,0])), [1;3;2])
+%!assert (nonzeros (sparse ([1,2,3,0])), [1;2;3])
+
diff --git a/scripts/sparse/pcg.m b/scripts/sparse/pcg.m
--- a/scripts/sparse/pcg.m
+++ b/scripts/sparse/pcg.m
@@ -428,17 +428,16 @@ endfunction
 %!  printf ("Condition number estimate is %g\n", eigest(2) / eigest(1));
 %!  printf ("Actual condition number is   %g\n", cond (A));
 %!  title ("Convergence history");
 %!  semilogy ([0:iter], resvec, ["o-g";"+-r"]);
 %!  xlabel ("Iteration"); ylabel ("log(||b-Ax||)");
 %!  legend ("absolute residual", "absolute preconditioned residual");
 
 %!demo
-%!
 %!  # Full output from pcg, including the eigenvalue estimates
 %!  # We use the 1-D Laplacian matrix for A, and cond(A) = O(N^2)
 %!  # and that's the reason we need some preconditioner; here we take
 %!  # a very simple and not powerful Jacobi preconditioner,
 %!  # which is the diagonal of A
 %!
 %!  N = 100;
 %!  A = zeros (N, N);
diff --git a/scripts/sparse/pcr.m b/scripts/sparse/pcr.m
--- a/scripts/sparse/pcr.m
+++ b/scripts/sparse/pcr.m
@@ -298,110 +298,110 @@ function [x, flag, relres, iter, resvec]
       warning ("system matrix singular or preconditioner indefinite?\n");
     endif
   endif
 
 endfunction
 
 
 %!demo
-%!  # Simplest usage of PCR (see also 'help pcr')
+%! # Simplest usage of PCR (see also 'help pcr')
 %!
-%!  N = 20;
-%!  A = diag (linspace (-3.1,3,N)); b = rand (N,1);
-%!  y = A \ b;  # y is the true solution
-%!  x = pcr (A,b);
-%!  printf ("The solution relative error is %g\n", norm (x-y) / norm (y));
+%! N = 20;
+%! A = diag (linspace (-3.1,3,N)); b = rand (N,1);
+%! y = A \ b;  # y is the true solution
+%! x = pcr (A,b);
+%! printf ("The solution relative error is %g\n", norm (x-y) / norm (y));
 %!
-%!  # You shouldn't be afraid if PCR issues some warning messages in this
-%!  # example: watch out in the second example, why it takes N iterations
-%!  # of PCR to converge to (a very accurate, by the way) solution
+%! # You shouldn't be afraid if PCR issues some warning messages in this
+%! # example: watch out in the second example, why it takes N iterations
+%! # of PCR to converge to (a very accurate, by the way) solution
 
 %!demo
-%!  # Full output from PCR
-%!  # We use this output to plot the convergence history
+%! # Full output from PCR
+%! # We use this output to plot the convergence history
 %!
-%!  N = 20;
-%!  A = diag (linspace(-3.1,30,N)); b = rand (N,1);
-%!  X = A \ b;  # X is the true solution
-%!  [x, flag, relres, iter, resvec] = pcr (A,b);
-%!  printf ("The solution relative error is %g\n", norm (x-X) / norm (X));
-%!  clf;
-%!  title ("Convergence history");
-%!  xlabel ("Iteration"); ylabel ("log(||b-Ax||/||b||)");
-%!  semilogy ([0:iter], resvec/resvec(1), "o-g;relative residual;");
+%! N = 20;
+%! A = diag (linspace (-3.1,30,N)); b = rand (N,1);
+%! X = A \ b;  # X is the true solution
+%! [x, flag, relres, iter, resvec] = pcr (A,b);
+%! printf ("The solution relative error is %g\n", norm (x-X) / norm (X));
+%! clf;
+%! title ("Convergence history");
+%! xlabel ("Iteration"); ylabel ("log(||b-Ax||/||b||)");
+%! semilogy ([0:iter], resvec/resvec(1), "o-g;relative residual;");
 
 %!demo
-%!  # Full output from PCR
-%!  # We use indefinite matrix based on the Hilbert matrix, with one
-%!  # strongly negative eigenvalue
-%!  # Hilbert matrix is extremely ill conditioned, so is ours,
-%!  # and that's why PCR WILL have problems
+%! # Full output from PCR
+%! # We use indefinite matrix based on the Hilbert matrix, with one
+%! # strongly negative eigenvalue
+%! # Hilbert matrix is extremely ill conditioned, so is ours,
+%! # and that's why PCR WILL have problems
 %!
-%!  N = 10;
-%!  A = hilb (N); A(1,1) = -A(1,1); b = rand (N,1);
-%!  X = A \ b;  # X is the true solution
-%!  printf ("Condition number of A is   %g\n", cond (A));
-%!  [x, flag, relres, iter, resvec] = pcr (A,b,[],200);
-%!  if (flag == 3)
-%!    printf ("PCR breakdown.  System matrix is [close to] singular\n");
-%!  end
-%!  clf;
-%!  title ("Convergence history");
-%!  xlabel ("Iteration"); ylabel ("log(||b-Ax||)");
-%!  semilogy ([0:iter], resvec, "o-g;absolute residual;");
+%! N = 10;
+%! A = hilb (N); A(1,1) = -A(1,1); b = rand (N,1);
+%! X = A \ b;  # X is the true solution
+%! printf ("Condition number of A is   %g\n", cond (A));
+%! [x, flag, relres, iter, resvec] = pcr (A,b,[],200);
+%! if (flag == 3)
+%!   printf ("PCR breakdown.  System matrix is [close to] singular\n");
+%! end
+%! clf;
+%! title ("Convergence history");
+%! xlabel ("Iteration"); ylabel ("log(||b-Ax||)");
+%! semilogy ([0:iter], resvec, "o-g;absolute residual;");
 
 %!demo
-%!  # Full output from PCR
-%!  # We use an indefinite matrix based on the 1-D Laplacian matrix for A,
-%!  # and here we have cond(A) = O(N^2)
-%!  # That's the reason we need some preconditioner; here we take
-%!  # a very simple and not powerful Jacobi preconditioner,
-%!  # which is the diagonal of A
+%! # Full output from PCR
+%! # We use an indefinite matrix based on the 1-D Laplacian matrix for A,
+%! # and here we have cond(A) = O(N^2)
+%! # That's the reason we need some preconditioner; here we take
+%! # a very simple and not powerful Jacobi preconditioner,
+%! # which is the diagonal of A
 %!
-%!  # Note that we use here indefinite preconditioners!
+%! # Note that we use here indefinite preconditioners!
 %!
-%!  N = 100;
-%!  A = zeros (N,N);
-%!  for i=1:N-1 # form 1-D Laplacian matrix
-%!    A(i:i+1,i:i+1) = [2 -1; -1 2];
-%!  endfor
-%!  A = [A, zeros(size(A)); zeros(size(A)), -A];
-%!  b = rand (2*N,1);
-%!  X = A \ b;  # X is the true solution
-%!  maxit = 80;
-%!  printf ("System condition number is %g\n", cond (A));
-%!  # No preconditioner: the convergence is very slow!
+%! N = 100;
+%! A = zeros (N,N);
+%! for i=1:N-1 # form 1-D Laplacian matrix
+%!   A(i:i+1,i:i+1) = [2 -1; -1 2];
+%! endfor
+%! A = [A, zeros(size(A)); zeros(size(A)), -A];
+%! b = rand (2*N,1);
+%! X = A \ b;  # X is the true solution
+%! maxit = 80;
+%! printf ("System condition number is %g\n", cond (A));
+%! # No preconditioner: the convergence is very slow!
 %!
-%!  [x, flag, relres, iter, resvec] = pcr (A,b,[],maxit);
-%!  clf;
-%!  title ("Convergence history");
-%!  xlabel ("Iteration"); ylabel ("log(||b-Ax||)");
-%!  semilogy ([0:iter], resvec, "o-g;NO preconditioning: absolute residual;");
+%! [x, flag, relres, iter, resvec] = pcr (A,b,[],maxit);
+%! clf;
+%! title ("Convergence history");
+%! xlabel ("Iteration"); ylabel ("log(||b-Ax||)");
+%! semilogy ([0:iter], resvec, "o-g;NO preconditioning: absolute residual;");
 %!
-%!  pause (1);
-%!  # Test Jacobi preconditioner: it will not help much!!!
+%! pause (1);
+%! # Test Jacobi preconditioner: it will not help much!!!
 %!
-%!  M = diag (diag (A)); # Jacobi preconditioner
-%!  [x, flag, relres, iter, resvec] = pcr (A,b,[],maxit,M);
-%!  hold on;
-%!  semilogy ([0:iter],resvec,"o-r;JACOBI preconditioner: absolute residual;");
+%! M = diag (diag (A)); # Jacobi preconditioner
+%! [x, flag, relres, iter, resvec] = pcr (A,b,[],maxit,M);
+%! hold on;
+%! semilogy ([0:iter],resvec,"o-r;JACOBI preconditioner: absolute residual;");
 %!
-%!  pause (1);
-%!  # Test nonoverlapping block Jacobi preconditioner: this one should give
-%!  # some convergence speedup!
+%! pause (1);
+%! # Test nonoverlapping block Jacobi preconditioner: this one should give
+%! # some convergence speedup!
 %!
-%!  M = zeros (N,N); k = 4;
-%!  for i=1:k:N # get k x k diagonal blocks of A
-%!    M(i:i+k-1,i:i+k-1) = A(i:i+k-1,i:i+k-1);
-%!  endfor
-%!  M = [M, zeros(size (M)); zeros(size(M)), -M];
-%!  [x, flag, relres, iter, resvec] = pcr (A,b,[],maxit,M);
-%!  semilogy ([0:iter], resvec, "o-b;BLOCK JACOBI preconditioner: absolute residual;");
-%!  hold off;
+%! M = zeros (N,N); k = 4;
+%! for i=1:k:N # get k x k diagonal blocks of A
+%!   M(i:i+k-1,i:i+k-1) = A(i:i+k-1,i:i+k-1);
+%! endfor
+%! M = [M, zeros(size (M)); zeros(size(M)), -M];
+%! [x, flag, relres, iter, resvec] = pcr (A,b,[],maxit,M);
+%! semilogy ([0:iter], resvec, "o-b;BLOCK JACOBI preconditioner: absolute residual;");
+%! hold off;
 
 %!test
 %! # solve small indefinite diagonal system
 %!
 %! N = 10;
 %! A = diag (linspace (-10.1,10,N)); b = ones (N,1);
 %! X = A \ b;  # X is the true solution
 %! [x, flag] = pcr (A,b,[],N+1);
diff --git a/scripts/sparse/spaugment.m b/scripts/sparse/spaugment.m
--- a/scripts/sparse/spaugment.m
+++ b/scripts/sparse/spaugment.m
@@ -85,17 +85,19 @@ function s = spaugment (A, c)
   elseif (!isscalar (c))
     error ("spaugment: C must be a scalar");
   endif
 
   [m, n] = size (A);
   s = [ c * speye(m, m), A; A', sparse(n, n)];
 endfunction
 
+
 %!testif HAVE_UMFPACK
-%! m = 11; n = 10; mn = max(m ,n);
+%! m = 11; n = 10; mn = max (m ,n);
 %! A = spdiags ([ones(mn,1), 10*ones(mn,1), -ones(mn,1)],[-1,0,1], m, n);
 %! x0 = A \ ones (m,1);
 %! s = spaugment (A);
 %! [L, U, P, Q] = lu (s);
 %! x1 = Q * (U \ (L \ (P  * [ones(m,1); zeros(n,1)])));
 %! x1 = x1(end - n + 1 : end);
-%! assert (x1, x0, 1e-6)
+%! assert (x1, x0, 1e-6);
+
diff --git a/scripts/sparse/spconvert.m b/scripts/sparse/spconvert.m
--- a/scripts/sparse/spconvert.m
+++ b/scripts/sparse/spconvert.m
@@ -60,8 +60,9 @@ endfunction
 
 %% Test input validation
 %!error spconvert ()
 %!error spconvert (1, 2)
 %!error spconvert ({[1 2 3]})
 %!error spconvert ([1 2])
 %!error spconvert ([1 2 3i])
 %!error spconvert ([1 2 3 4 5])
+
diff --git a/scripts/sparse/spdiags.m b/scripts/sparse/spdiags.m
--- a/scripts/sparse/spdiags.m
+++ b/scripts/sparse/spdiags.m
@@ -82,13 +82,12 @@ function [A, c] = spdiags (v, c, m, n)
     j = j + offset(i);
     i = j-c(:)(i);
     idx = i > 0 & i <= m & j > 0 & j <= n;
     A = sparse (i(idx), j(idx), v(idx), m, n);
   endif
 
 endfunction
 
-%!test
-%assert(spdiags(zeros(1,0),1,1,1),0)
 
-%!test
-%assert(spdiags(zeros(0,1),1,1,1),0)
+%!assert (spdiags (zeros (1,0),1,1,1), sparse (0))
+%!assert (spdiags (zeros (0,1),1,1,1), sparse (0))
+
diff --git a/scripts/sparse/speye.m b/scripts/sparse/speye.m
--- a/scripts/sparse/speye.m
+++ b/scripts/sparse/speye.m
@@ -45,13 +45,15 @@ function s = speye (m, n)
       error ("speye: invalid matrix dimension");
     endif
   endif
 
   lo = min ([m, n]);
   s = sparse (1:lo, 1:lo, 1, m, n);
 endfunction
 
-%!assert(issparse(speye(4)))
-%!assert(speye(4),sparse(1:4,1:4,1))
-%!assert(speye(2,4),sparse(1:2,1:2,1,2,4))
-%!assert(speye(4,2),sparse(1:2,1:2,1,4,2))
-%!assert(speye([4,2]),sparse(1:2,1:2,1,4,2))
+
+%!assert (issparse (speye (4)))
+%!assert (speye (4), sparse (1:4,1:4,1))
+%!assert (speye (2,4), sparse (1:2,1:2,1,2,4))
+%!assert (speye (4,2), sparse (1:2,1:2,1,4,2))
+%!assert (speye ([4,2]), sparse (1:2,1:2,1,4,2))
+
diff --git a/scripts/sparse/spfun.m b/scripts/sparse/spfun.m
--- a/scripts/sparse/spfun.m
+++ b/scripts/sparse/spfun.m
@@ -37,13 +37,14 @@ function y = spfun (f, S)
   if (isa (f, "function_handle") || isa (f, "inline function"))
     y = sparse (i, j, f(v), m, n);
   else
     y = sparse(i, j, feval (f, v), m, n);
   endif
 
 endfunction
 
-%!assert(spfun('exp',[1,2;3,0]),sparse([exp(1),exp(2);exp(3),0]))
-%!assert(spfun('exp',sparse([1,2;3,0])),sparse([exp(1),exp(2);exp(3),0]))
-%!assert(spfun(@exp,[1,2;3,0]),sparse([exp(1),exp(2);exp(3),0]))
-%!assert(spfun(@exp,sparse([1,2;3,0])),sparse([exp(1),exp(2);exp(3),0]))
 
+%!assert (spfun ("exp", [1,2;3,0]), sparse ([exp(1),exp(2);exp(3),0]))
+%!assert (spfun ("exp", sparse ([1,2;3,0])), sparse ([exp(1),exp(2);exp(3),0]))
+%!assert (spfun (@exp, [1,2;3,0]), sparse ([exp(1),exp(2);exp(3),0]))
+%!assert (spfun (@exp, sparse ([1,2;3,0])), sparse ([exp(1),exp(2);exp(3),0]))
+
diff --git a/scripts/sparse/spones.m b/scripts/sparse/spones.m
--- a/scripts/sparse/spones.m
+++ b/scripts/sparse/spones.m
@@ -30,11 +30,13 @@ function r = spones (S)
 
   [i, j, v] = find (S);
   [m, n] = size (S);
 
   r = sparse (i, j, 1, m, n);
 
 endfunction
 
-%!assert(issparse(spones([1,2;3,0])))
-%!assert(spones([1,2;3,0]),sparse([1,1;1,0]))
-%!assert(spones(sparse([1,2;3,0])),sparse([1,1;1,0]))
+
+%!assert (issparse (spones ([1,2;3,0])))
+%!assert (spones ([1,2;3,0]), sparse ([1,1;1,0]))
+%!assert (spones (sparse ([1,2;3,0])), sparse ([1,1;1,0]))
+
diff --git a/scripts/sparse/sprand.m b/scripts/sparse/sprand.m
--- a/scripts/sparse/sprand.m
+++ b/scripts/sparse/sprand.m
@@ -49,16 +49,17 @@ function S = sprand (m, n, d)
   elseif ( nargin == 3)
     S = __sprand_impl__ (m, n, d, "sprand", @rand);
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!test
 %! s = sprand (4, 10, 0.1);
 %! assert (size (s), [4, 10]);
 %! assert (nnz (s) / numel (s), 0.1);
 
 %% Test 1-input calling form
 %!test
 %! s = sprand (sparse ([1 2 3], [3 2 3], [2 2 2]));
@@ -66,17 +67,17 @@ endfunction
 %! assert (sort (i), [1 2 3]');
 %! assert (sort (j), [2 3 3]');
 %! assert (all (v > 0 & v < 1));
 
 %% Test input validation
 %!error sprand ()
 %!error sprand (1, 2)
 %!error sprand (1, 2, 3, 4)
-%!error sprand (ones(3), 3, 0.5)
+%!error sprand (ones (3), 3, 0.5)
 %!error sprand (3.5, 3, 0.5)
 %!error sprand (0, 3, 0.5)
-%!error sprand (3, ones(3), 0.5)
+%!error sprand (3, ones (3), 0.5)
 %!error sprand (3, 3.5, 0.5)
 %!error sprand (3, 0, 0.5)
 %!error sprand (3, 3, -1)
 %!error sprand (3, 3, 2)
 
diff --git a/scripts/sparse/sprandsym.m b/scripts/sparse/sprandsym.m
--- a/scripts/sparse/sprandsym.m
+++ b/scripts/sparse/sprandsym.m
@@ -146,16 +146,17 @@ function r = pick_rand_diag (n, k)
   ## Add final d
   d(end+1) = d(end) + 2;
 
   ## Pick a random r using this distribution
   r = d(sum (cumsum (p) < rand) + 1);
 
 endfunction
 
+
 %!test
 %! s = sprandsym (10, 0.1);
 %! assert (issparse (s));
 %! assert (issymmetric (s));
 %! assert (size (s), [10, 10]);
 %! assert (nnz (s) / numel (s), 0.1, .01);
 
 %% Test 1-input calling form
@@ -163,14 +164,14 @@ endfunction
 %! s = sprandsym (sparse ([1 2 3], [3 2 3], [2 2 2]));
 %! [i, j] = find (s);
 %! assert (sort (i), [2 3]');
 %! assert (sort (j), [2 3]');
 
 %% Test input validation
 %!error sprandsym ()
 %!error sprandsym (1, 2, 3)
-%!error sprandsym (ones(3), 0.5)
+%!error sprandsym (ones (3), 0.5)
 %!error sprandsym (3.5, 0.5)
 %!error sprandsym (0, 0.5)
 %!error sprandsym (3, -1)
 %!error sprandsym (3, 2)
 
diff --git a/scripts/sparse/spstats.m b/scripts/sparse/spstats.m
--- a/scripts/sparse/spstats.m
+++ b/scripts/sparse/spstats.m
@@ -54,12 +54,13 @@ function [count, mean, var] = spstats (S
     diff = S - sparse (i, j, mean(j), n, m);
     var = sum (diff .* diff) ./ (count - 1);
   endif
 
 endfunction
 
 
 %!test
-%! [n,m,v] = spstats([1 2 1 2 3 4],[2 2 1 1 1 1]);
-%! assert(n,sparse([4,2]));
-%! assert(m,sparse([10/4,3/2]),10*eps);
-%! assert(v,sparse([5/3,1/2]),10*eps);
+%! [n,m,v] = spstats ([1 2 1 2 3 4],[2 2 1 1 1 1]);
+%! assert (n, sparse ([4,2]));
+%! assert (m, sparse ([10/4,3/2]), 10*eps);
+%! assert (v, sparse ([5/3,1/2]), 10*eps);
+
diff --git a/scripts/sparse/spy.m b/scripts/sparse/spy.m
--- a/scripts/sparse/spy.m
+++ b/scripts/sparse/spy.m
@@ -67,9 +67,10 @@ function spy (x, varargin)
 endfunction
 
 
 %!demo
 %! clf;
 %! spy (sprand (10,10, 0.2));
 
 %% Mark graphical function as tested by demo block
-%!assert (1);
+%!assert (1)
+
diff --git a/scripts/sparse/svds.m b/scripts/sparse/svds.m
--- a/scripts/sparse/svds.m
+++ b/scripts/sparse/svds.m
@@ -236,16 +236,17 @@ function [u, s, v, flag] = svds (A, k, s
 
     if (nargout > 3)
       flag = norm (A*v - u*s, 1) > root2 * opts.tol * norm (A, 1);
     endif
   endif
 
 endfunction
 
+
 %!shared n, k, A, u, s, v, opts, rand_state, randn_state
 %! n = 100;
 %! k = 7;
 %! A = sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),0.4*n*ones(1,n),ones(1,n-2)]);
 %! [u,s,v] = svd (full (A));
 %! s = diag (s);
 %! [~, idx] = sort (abs(s));
 %! s = s(idx);
diff --git a/scripts/sparse/treelayout.m b/scripts/sparse/treelayout.m
--- a/scripts/sparse/treelayout.m
+++ b/scripts/sparse/treelayout.m
@@ -197,16 +197,17 @@ function [x_coordinate, y_coordinate, he
     ## Calculate the x coordinates (the known values are the position
     ## of most left and most right descendants).
     x_coordinate = (x_coordinate_l + x_coordinate_r) / 2;
 
     height = num_nodes - max_ht - 1;
   endif
 endfunction
 
+
 %!test
 %! % Compute a simple tree layout
 %! [x, y, h, s] = treelayout ([0, 1, 2, 2]);
 %! assert (x, [1.5, 1.5, 2, 1]);
 %! assert (y, [3, 2, 1, 1]);
 %! assert (h, 2);
 %! assert (s, 2);
 
@@ -220,8 +221,9 @@ endfunction
 
 %!test
 %! % Compute a simple tree layout with defined postorder permutation
 %! [x, y, h, s] = treelayout ([0, 1, 2, 2], [4, 2, 3, 1]);
 %! assert (x, [0, 0, 0, 1]);
 %! assert (y, [0, 0, 0, 3]);
 %! assert (h, 0);
 %! assert (s, 1);
+
diff --git a/scripts/specfun/bessel.m b/scripts/specfun/bessel.m
--- a/scripts/specfun/bessel.m
+++ b/scripts/specfun/bessel.m
@@ -86,9 +86,10 @@
 ## return @code{NaN}.
 ## @end enumerate
 ## @end deftypefn
 
 function bessel ()
   error ("bessel: you must use besselj, bessely, besseli, or besselk");
 endfunction
 
+
 %!error bessel ()
diff --git a/scripts/specfun/beta.m b/scripts/specfun/beta.m
--- a/scripts/specfun/beta.m
+++ b/scripts/specfun/beta.m
@@ -50,33 +50,35 @@ function retval = beta (a, b)
   if (! isreal (a) || ! isreal (b))
     error ("beta: inputs A and B must be real");
   endif
 
   retval = real (exp (gammaln (a) + gammaln (b) - gammaln (a+b)));
 
 endfunction
 
+
 %!test
-%! a=[1, 1.5, 2, 3];
-%! b=[4, 3, 2, 1];
-%! v1=beta(a,b);
-%! v2=beta(b,a);
-%! v3=gamma(a).*gamma(b)./gamma(a+b);
-%! assert(all(abs(v1-v2)<sqrt(eps)) && all(abs(v2-v3)<sqrt(eps)));
+%! a = [1, 1.5, 2, 3];
+%! b = [4, 3, 2, 1];
+%! v1 = beta (a,b);
+%! v2 = beta (b,a);
+%! v3 = gamma (a).*gamma (b) ./ gamma (a+b);
+%! assert (v1, v2, sqrt (eps));
+%! assert (v2, v3, sqrt (eps));
 
-%!error beta();
-
-%!error beta(1);
-
-%!assert (1, beta (1, 1))
+%!assert (beta (1, 1), 1)
 
 %!test
 %! a = 2:10;
 %! tol = 10 * max (a) * eps;
-%! assert (-a, beta (-1./a, 1), tol)
-%! assert (-a, beta (1, -1./a), tol)
+%! assert (-a, beta (-1./a, 1), tol);
+%! assert (-a, beta (1, -1./a), tol);
 
 %!test
 %! a = 0.25 + (0:5) * 0.5;
 %! tol = 10 * max (a) * eps;
-%! assert (zeros (size (a)), beta (a, -a), tol)
-%! assert (zeros (size (a)), beta (-a, a), tol)
+%! assert (zeros (size (a)), beta (a, -a), tol);
+%! assert (zeros (size (a)), beta (-a, a), tol);
+
+%!error beta ()
+%!error beta (1)
+
diff --git a/scripts/specfun/betaln.m b/scripts/specfun/betaln.m
--- a/scripts/specfun/betaln.m
+++ b/scripts/specfun/betaln.m
@@ -45,13 +45,13 @@ function retval = betaln (a, b)
     print_usage ();
   endif
 
   retval = gammaln (a) + gammaln (b) - gammaln (a + b);
 
 endfunction
 
 
-%!assert (betaln (3,4), log (beta(3,4)),eps);
+%!assert (betaln (3,4), log (beta (3,4)), eps)
 
 %% Test input validation
 %!error (betaln (1))
 %!error (betaln (1,2,3))
diff --git a/scripts/specfun/factor.m b/scripts/specfun/factor.m
--- a/scripts/specfun/factor.m
+++ b/scripts/specfun/factor.m
@@ -77,19 +77,20 @@ function [x, n] = factor (q)
   if (nargout > 1)
     idx = find ([0, x] != [x, 0]);
     x = x(idx(1:length(idx)-1));
     n = diff (idx);
   endif
 
 endfunction
 
+
+%!assert (factor (1), 1)
 %!test
-%!  assert(factor(1),1);
-%!  for i=2:20
-%!     p = factor(i);
-%!     assert(prod(p),i);
-%!     assert(all(isprime(p)));
-%!     [p,n] = factor(i);
-%!     assert(prod(p.^n),i);
-%!     assert(all([0,p]!=[p,0]));
-%!  endfor
+%! for i = 2:20
+%!   p = factor (i);
+%!   assert (prod (p), i);
+%!   assert (all (isprime (p)));
+%!   [p,n] = factor (i);
+%!   assert (prod (p.^n), i);
+%!   assert (all ([0,p] != [p,0]));
+%! endfor
 
diff --git a/scripts/specfun/factorial.m b/scripts/specfun/factorial.m
--- a/scripts/specfun/factorial.m
+++ b/scripts/specfun/factorial.m
@@ -30,13 +30,16 @@ function x = factorial (n)
   if (nargin != 1)
     print_usage ();
   elseif (any (n(:) < 0 | n(:) != fix (n(:))))
     error ("factorial: N must all be non-negative integers");
   endif
   x = round (gamma (n+1));
 endfunction
 
-%!assert (factorial(5), prod(1:5))
-%!assert (factorial([1,2;3,4]), [1,2;6,24])
-%!assert (factorial(70), exp(sum(log(1:70))), -128*eps)
-%!fail ('factorial(5.5)', "must all be non-negative integers")
-%!fail ('factorial(-3)', "must all be non-negative integers")
+
+%!assert (factorial (5), prod (1:5))
+%!assert (factorial ([1,2;3,4]), [1,2;6,24])
+%!assert (factorial (70), exp (sum (log (1:70))), -128*eps)
+
+%!fail ("factorial (5.5)", "must all be non-negative integers")
+%!fail ("factorial (-3)", "must all be non-negative integers")
+
diff --git a/scripts/specfun/isprime.m b/scripts/specfun/isprime.m
--- a/scripts/specfun/isprime.m
+++ b/scripts/specfun/isprime.m
@@ -75,13 +75,15 @@ function t = isprime (x)
 
   else
     print_usage ();
   endif
 
 endfunction
 
 
-%!assert (isprime (4), logical (0));
-%!assert (isprime (3), logical (1));
-%!assert (isprime (magic (3)), logical ([0, 0, 0; 1, 1, 1; 0, 0, 1]));
+%!assert (isprime (3), true)
+%!assert (isprime (4), false)
+%!assert (isprime (magic (3)), logical ([0, 0, 0; 1, 1, 1; 0, 0, 1]))
+
 %!error isprime ()
 %!error isprime (1, 2)
+
diff --git a/scripts/specfun/lcm.m b/scripts/specfun/lcm.m
--- a/scripts/specfun/lcm.m
+++ b/scripts/specfun/lcm.m
@@ -46,16 +46,16 @@ function l = lcm (varargin)
       l(msk) = 0;
     endfor
   else
     print_usage ();
   endif
 
 endfunction
 
-%!assert(lcm (3, 5, 7, 15) == 105);
+
+%!assert (lcm (3, 5, 7, 15), 105)
 
 %!error lcm ();
-
 %!test
 %! s.a = 1;
-%! fail("lcm (s)");
+%! fail ("lcm (s)");
 
diff --git a/scripts/specfun/legendre.m b/scripts/specfun/legendre.m
--- a/scripts/specfun/legendre.m
+++ b/scripts/specfun/legendre.m
@@ -281,35 +281,36 @@ endfunction
 
 %!test
 %! result = legendre (150, 0);
 %! ## This agrees with Matlab's result.
 %! assert (result(end), 3.7532741115719e+306, 0.0000000000001e+306);
 
 %!test
 %! result = legendre (0, 0:0.1:1);
-%! assert (result, full(ones(1,11)));
+%! assert (result, full (ones (1,11)));
 
 %!test
 %! result = legendre (3, [-1,0,1;1,0,-1]);
 %! ## Test matrix input
 %! expected(:,:,1) = [-1,1;0,0;0,0;0,0];
 %! expected(:,:,2) = [0,0;1.5,1.5;0,0;-15,-15];
 %! expected(:,:,3) = [1,-1;0,0;0,0;0,0];
 %! assert (result, expected);
 
 %!test
 %! result = legendre (3, [-1,0,1;1,0,-1]');
 %! expected(:,:,1) = [-1,0,1;0,1.5,0;0,0,0;0,-15,0];
 %! expected(:,:,2) = [1,0,-1;0,1.5,0;0,0,0;0,-15,0];
 %! assert (result, expected);
 
 %% Check correct invocation
-%!error legendre ();
-%!error legendre (1);
-%!error legendre (1,2,3,4);
-%!error legendre ([1, 2], [-1, 0, 1]);
-%!error legendre (-1, [-1, 0, 1]);
-%!error legendre (1.1, [-1, 0, 1]);
-%!error legendre (1, [-1+i, 0, 1]);
-%!error legendre (1, [-2, 0, 1]);
-%!error legendre (1, [-1, 0, 2]);
-%!error legendre (1, [-1, 0, 1], "badnorm");
+%!error legendre ()
+%!error legendre (1)
+%!error legendre (1,2,3,4)
+%!error legendre ([1, 2], [-1, 0, 1])
+%!error legendre (-1, [-1, 0, 1])
+%!error legendre (1.1, [-1, 0, 1])
+%!error legendre (1, [-1+i, 0, 1])
+%!error legendre (1, [-2, 0, 1])
+%!error legendre (1, [-1, 0, 2])
+%!error legendre (1, [-1, 0, 1], "badnorm")
+
diff --git a/scripts/specfun/nchoosek.m b/scripts/specfun/nchoosek.m
--- a/scripts/specfun/nchoosek.m
+++ b/scripts/specfun/nchoosek.m
@@ -136,17 +136,17 @@ function A = nchoosek (v, k)
     endfor
     clear cA b;
     A = A.';
   endif
 endfunction
 
 
 %!assert (nchoosek (80,10), bincoeff (80,10))
-%!assert (nchoosek(1:5,3), [1:3;1,2,4;1,2,5;1,3,4;1,3,5;1,4,5;2:4;2,3,5;2,4,5;3:5])
+%!assert (nchoosek (1:5,3), [1:3;1,2,4;1,2,5;1,3,4;1,3,5;1,4,5;2:4;2,3,5;2,4,5;3:5])
 
 %% Test input validation
 %!warning nchoosek (100,45);
 %!error nchoosek ("100", 45)
 %!error nchoosek (100, "45")
 %!error nchoosek (100, ones (2,2))
 %!error nchoosek (repmat (100, [2 2]), 45)
 %!error nchoosek (100, -45)
diff --git a/scripts/specfun/nthroot.m b/scripts/specfun/nthroot.m
--- a/scripts/specfun/nthroot.m
+++ b/scripts/specfun/nthroot.m
@@ -76,21 +76,22 @@ function y = nthroot (x, n)
       y = ((n-1)*y + x ./ (y.^(n-1))) / n;
       y = merge (finite (y), y, x);
     endif
 
   endif
 
 endfunction
 
-%!assert (nthroot(-32,5), -2);
-%!assert (nthroot(81,4), 3);
-%!assert (nthroot(Inf,4), Inf);
-%!assert (nthroot(-Inf,7), -Inf);
-%!assert (nthroot(-Inf,-7), 0);
+
+%!assert (nthroot (-32,5), -2);
+%!assert (nthroot (81,4), 3);
+%!assert (nthroot (Inf,4), Inf);
+%!assert (nthroot (-Inf,7), -Inf);
+%!assert (nthroot (-Inf,-7), 0);
 
 %% Test input validation
 %!error (nthroot ())
 %!error (nthroot (1))
 %!error (nthroot (1,2,3))
 %!error (nthroot (1+j,2))
 %!error (nthroot (1,[1 2]))
 %!error (nthroot (1,0))
diff --git a/scripts/specfun/perms.m b/scripts/specfun/perms.m
--- a/scripts/specfun/perms.m
+++ b/scripts/specfun/perms.m
@@ -59,15 +59,16 @@ function A = perms (v)
         A(idx,i) = v(j);
         A(idx,i+1:j) = B(:,i:j-1);
         idx += k;
       endfor
     endfor
   endif
 endfunction
 
-%!error perms ();
-%!error perms (1, 2);
 
-%!assert (perms ([1,2,3]), [1,2,3;2,1,3;1,3,2;2,3,1;3,1,2;3,2,1]);
-%!assert (perms (1:3), perms ([1,2,3]));
+%!assert (perms ([1,2,3]), [1,2,3;2,1,3;1,3,2;2,3,1;3,1,2;3,2,1])
+%!assert (perms (1:3), perms ([1,2,3]))
+%!assert (perms (int8 ([1,2,3])), int8 ([1,2,3;2,1,3;1,3,2;2,3,1;3,1,2;3,2,1]))
 
-%!assert (perms (int8([1,2,3])), int8([1,2,3;2,1,3;1,3,2;2,3,1;3,1,2;3,2,1]));
+%!error perms ()
+%!error perms (1, 2)
+
diff --git a/scripts/specfun/pow2.m b/scripts/specfun/pow2.m
--- a/scripts/specfun/pow2.m
+++ b/scripts/specfun/pow2.m
@@ -49,21 +49,22 @@ function y = pow2 (f, e)
   elseif (nargin == 2)
     y = f .* (2 .^ e);
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!test
 %! x = [3, 0, -3];
 %! v = [8, 1, .125];
-%! assert(all (abs (pow2 (x) - v) < sqrt (eps)));
+%! assert (pow2 (x), v, sqrt (eps));
 
 %!test
 %! x = [3, 0, -3, 4, 0, -4, 5, 0, -5];
 %! y = [-2, -2, -2, 1, 1, 1, 3, 3, 3];
 %! z = x .* (2 .^ y);
-%! assert(all (abs (pow2 (x,y) - z) < sqrt (eps)));
+%! assert (pow2 (x,y), z, sqrt (eps));
 
-%!error pow2();
+%!error pow2 ()
 
diff --git a/scripts/specfun/primes.m b/scripts/specfun/primes.m
--- a/scripts/specfun/primes.m
+++ b/scripts/specfun/primes.m
@@ -88,15 +88,15 @@ function x = primes (n)
          173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, ...
          233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, ...
          293, 307, 311, 313, 317, 331, 337, 347, 349];
     x = a(a <= n);
   endif
 
 endfunction
 
-%!error primes ();
-%!error primes (1, 2);
+
+%!assert (size (primes (350)), [1, 70])
+%!assert (primes (357)(end), 353)
 
-%!assert (size (primes (350)), [1, 70]);
-%!assert (size (primes (350)), [1, 70]);
+%!error primes ()
+%!error primes (1, 2)
 
-%!assert (primes (357)(end), 353);
diff --git a/scripts/specfun/reallog.m b/scripts/specfun/reallog.m
--- a/scripts/specfun/reallog.m
+++ b/scripts/specfun/reallog.m
@@ -28,13 +28,16 @@ function y = reallog (x)
     print_usage ();
   elseif (iscomplex (x) || any (x(:) < 0))
     error ("reallog: produced complex result");
   else
     y = log (x);
   endif
 endfunction
 
-%!assert (log(1:5),reallog(1:5))
+
+%!assert (log (1:5), reallog (1:5))
 %!test
 %! x = rand (10,10);
-%! assert (log(x),reallog(x))
-%!error (reallog(-1))
+%! assert (log (x),reallog (x));
+
+%!error <produced complex result> reallog (-1)
+
diff --git a/scripts/specfun/realpow.m b/scripts/specfun/realpow.m
--- a/scripts/specfun/realpow.m
+++ b/scripts/specfun/realpow.m
@@ -30,16 +30,19 @@ function z = realpow (x, y)
   else
     z = x .^ y;
     if (iscomplex (z))
       error ("realpow: produced complex result");
     endif
   endif
 endfunction
 
+
 %!assert (power (1:10, 0.5:0.5:5), realpow (1:10, 0.5:0.5:5))
 %!assert ([1:10] .^ [0.5:0.5:5], realpow (1:10, 0.5:0.5:5))
 %!test
 %! x = rand (10,10);
 %! y = randn (10,10);
-%! assert (x.^y,realpow(x,y))
-%!assert (realpow(1i,2),-1)
-%!error (realpow(-1, 1/2))
+%! assert (x.^y, realpow (x,y));
+%!assert (realpow (1i,2), -1)
+
+%!error <produced complex result> realpow (-1, 1/2)
+
diff --git a/scripts/specfun/realsqrt.m b/scripts/specfun/realsqrt.m
--- a/scripts/specfun/realsqrt.m
+++ b/scripts/specfun/realsqrt.m
@@ -28,13 +28,16 @@ function y = realsqrt (x)
     print_usage ();
   elseif (iscomplex (x) || any (x(:) < 0))
     error ("realsqrt: produced complex result");
   else
     y = sqrt (x);
   endif
 endfunction
 
-%!assert (sqrt(1:5),realsqrt(1:5))
+
+%!assert (sqrt (1:5), realsqrt (1:5))
 %!test
 %! x = rand (10,10);
-%! assert (sqrt(x),realsqrt(x))
-%!error (realsqrt(-1))
+%! assert (sqrt (x), realsqrt (x));
+
+%!error <produced complex result> realsqrt (-1)
+
diff --git a/scripts/special-matrix/hadamard.m b/scripts/special-matrix/hadamard.m
--- a/scripts/special-matrix/hadamard.m
+++ b/scripts/special-matrix/hadamard.m
@@ -160,16 +160,16 @@ function h = h28 ()
        1 -1 1 1 -1 -1 1 1 -1 -1 -1 1 -1 -1 1 1 -1 1 1 1 -1 -1 1 1 -1 -1 1 -1];
 endfunction
 
 
 %!assert (hadamard (1), 1)
 %!assert (hadamard (2), [1,1;1,-1])
 %!test
 %! for n = [1,2,4,8,12,24,48,20,28,2^9]
-%!   h = hadamard(n);
+%!   h = hadamard (n);
 %!   assert (norm (h*h' - n*eye (n)), 0);
 %! endfor
 
 %!error hadamard ()
 %!error hadamard (1,2)
 %!error <N must be 2\^k\*p> hadamard (5)
 
diff --git a/scripts/special-matrix/hankel.m b/scripts/special-matrix/hankel.m
--- a/scripts/special-matrix/hankel.m
+++ b/scripts/special-matrix/hankel.m
@@ -86,13 +86,13 @@ endfunction
 %!assert (hankel (1), [1])
 %!assert (hankel ([1, 2]), [1, 2; 2, 0])
 %!assert (hankel ([1, 2], [2; -1; -3]), [1, 2, -1; 2, -1, -3])
 %!assert (hankel (1:3), [1,2,3;2,3,0;3,0,0])
 %!assert (hankel (1:3,3:6), [1,2,3,4;2,3,4,5;3,4,5,6])
 %!assert (hankel (1:3,3:4), [1,2;2,3;3,4])
 %!assert (hankel (1:3,4:6), [1,2,3;2,3,5;3,5,6])
 
-%!error hankel ();
-%!error hankel (1, 2, 3);
+%!error hankel ()
+%!error hankel (1, 2, 3)
 %!error <C must be a vector> hankel ([1, 2; 3, 4])
 %!error <C and R must be vectors> hankel (1:4, [1, 2; 3, 4])
 
diff --git a/scripts/special-matrix/hilb.m b/scripts/special-matrix/hilb.m
--- a/scripts/special-matrix/hilb.m
+++ b/scripts/special-matrix/hilb.m
@@ -70,10 +70,10 @@ function retval = hilb (n)
 endfunction
 
 
 %!assert (hilb (2), [1, 1/2; 1/2, 1/3])
 %!assert (hilb (3), [1, 1/2, 1/3; 1/2, 1/3, 1/4; 1/3, 1/4, 1/5])
 
 %!error hilb ()
 %!error hilb (1, 2)
-%!error <N must be a scalar integer> hilb (ones(2))
+%!error <N must be a scalar integer> hilb (ones (2))
 
diff --git a/scripts/special-matrix/invhilb.m b/scripts/special-matrix/invhilb.m
--- a/scripts/special-matrix/invhilb.m
+++ b/scripts/special-matrix/invhilb.m
@@ -115,14 +115,14 @@ endfunction
 %!assert (invhilb (1), 1)
 %!assert (invhilb (2), [4, -6; -6, 12])
 %!test
 %! result4 = [16  , -120 , 240  , -140;
 %!            -120, 1200 , -2700, 1680;
 %!            240 , -2700, 6480 , -4200;
 %!            -140, 1680 , -4200, 2800];
 %! assert (invhilb (4), result4);
-%!assert (abs (invhilb (7) * hilb (7) - eye (7)) < sqrt (eps))
+%!assert (invhilb (7) * hilb (7), eye (7), sqrt (eps))
 
 %!error invhilb ()
 %!error invhilb (1, 2)
 %!error <N must be a scalar integer> invhilb ([1, 2])
 
diff --git a/scripts/special-matrix/magic.m b/scripts/special-matrix/magic.m
--- a/scripts/special-matrix/magic.m
+++ b/scripts/special-matrix/magic.m
@@ -75,23 +75,23 @@ function A = magic(n)
     A([I,I+m],I) = A([I+m,I],I);
 
   endif
 
 endfunction
 
 
 %!test
-%! for i=3:30
+%! for i = 3:30
 %!   A = magic (i);
 %!   assert (norm(diff([sum(diag(A)),sum(diag(flipud(A))),sum(A),sum(A')])),0);
 %! endfor
 
 %!assert (isempty (magic (0)))
-%!assert (magic(1), 1)
+%!assert (magic (1), 1)
 
 %% Test input validation
 %!error magic ()
 %!error magic (1, 2)
 %!error <N must be a positive integer not equal to 2> magic (1.5)
 %!error <N must be a positive integer not equal to 2> magic (-1)
 %!error <N must be a positive integer not equal to 2> magic (2)
 
diff --git a/scripts/special-matrix/rosser.m b/scripts/special-matrix/rosser.m
--- a/scripts/special-matrix/rosser.m
+++ b/scripts/special-matrix/rosser.m
@@ -39,10 +39,14 @@ function retval = rosser ()
             407,  -192,   196,   611,     8,    44,    59,   -23;
              -8,   -71,    61,     8,   411,  -599,   208,   208;
             -52,   -43,    49,    44,  -599,   411,   208,   208;
             -49,    -8,     8,    59,   208,   208,    99,  -911;
              29,   -44,    52,   -23,   208,   208,  -911,    99];
 
 endfunction
 
-%!assert (size(rosser()), [8,8])
-%!error (rosser(1))
+
+%!assert (size (rosser ()), [8,8])
+%!assert (rosser ()([1, end]), [611, 99])
+
+%!error (rosser (1))
+
diff --git a/scripts/special-matrix/vander.m b/scripts/special-matrix/vander.m
--- a/scripts/special-matrix/vander.m
+++ b/scripts/special-matrix/vander.m
@@ -74,22 +74,22 @@ function retval = vander (c, n)
   endfor
 
 endfunction
 
 
 %!test
 %! c = [0,1,2,3];
 %! expect = [0,0,0,1; 1,1,1,1; 8,4,2,1; 27,9,3,1];
-%! assert(vander (c), expect);
+%! assert (vander (c), expect);
 
 %!assert (vander (1), 1)
 %!assert (vander ([1, 2, 3]), vander ([1; 2; 3]))
 %!assert (vander ([1, 2, 3]), [1, 1, 1; 4, 2, 1; 9, 3, 1])
 %!assert (vander ([1, 2, 3]*i), [-1, i, 1; -4, 2i, 1; -9, 3i, 1])
 
-%!assert(vander (2, 3), [4, 2, 1])
-%!assert(vander ([2, 3], 3), [4, 2, 1; 9, 3, 1])
+%!assert (vander (2, 3), [4, 2, 1])
+%!assert (vander ([2, 3], 3), [4, 2, 1; 9, 3, 1])
 
-%!error vander ();
-%!error vander (1, 2, 3);
-%!error <polynomial C must be a vector> vander ([1, 2; 3, 4]);
+%!error vander ()
+%!error vander (1, 2, 3)
+%!error <polynomial C must be a vector> vander ([1, 2; 3, 4])
 
diff --git a/scripts/startup/__finish__.m b/scripts/startup/__finish__.m
--- a/scripts/startup/__finish__.m
+++ b/scripts/startup/__finish__.m
@@ -32,10 +32,11 @@ function __finish__ ()
   if (exist ("finish", "file"))
     ## No arg list here since finish might be a script.
     finish;
   endif
 
 endfunction
 
 
+
 ## No test needed for internal helper function.
 %!assert (1)
diff --git a/scripts/statistics/base/center.m b/scripts/statistics/base/center.m
--- a/scripts/statistics/base/center.m
+++ b/scripts/statistics/base/center.m
@@ -60,24 +60,26 @@ function retval = center (x, dim)
   if (n == 0)
     retval = x;
   else
     retval = bsxfun (@minus, x, mean (x, dim));
   endif
 
 endfunction
 
-%!assert(center ([1,2,3]), [-1,0,1])
-%!assert(center (single([1,2,3])), single([-1,0,1]))
-%!assert(center (int8 ([1,2,3])), [-1,0,1])
-%!assert(center (logical ([1, 0, 0, 1])), [0.5, -0.5, -0.5, 0.5])
-%!assert(center (ones (3,2,0,2)), zeros (3,2,0,2))
-%!assert(center (ones (3,2,0,2, "single")), zeros (3,2,0,2, "single"))
-%!assert(center (magic (3)), [3,-4,1;-2,0,2;-1,4,-3])
-%!assert(center ([1 2 3; 6 5 4], 2), [-1 0 1; 1 0 -1])
+
+%!assert (center ([1,2,3]), [-1,0,1])
+%!assert (center (single ([1,2,3])), single ([-1,0,1]))
+%!assert (center (int8 ([1,2,3])), [-1,0,1])
+%!assert (center (logical ([1, 0, 0, 1])), [0.5, -0.5, -0.5, 0.5])
+%!assert (center (ones (3,2,0,2)), zeros (3,2,0,2))
+%!assert (center (ones (3,2,0,2, "single")), zeros (3,2,0,2, "single"))
+%!assert (center (magic (3)), [3,-4,1;-2,0,2;-1,4,-3])
+%!assert (center ([1 2 3; 6 5 4], 2), [-1 0 1; 1 0 -1])
 
 %% Test input validation
 %!error center ()
 %!error center (1, 2, 3)
-%!error center (1, ones(2,2))
+%!error center (1, ones (2,2))
 %!error center (1, 1.5)
 %!error center (1, 0)
 %!error center (1, 3)
+
diff --git a/scripts/statistics/base/cloglog.m b/scripts/statistics/base/cloglog.m
--- a/scripts/statistics/base/cloglog.m
+++ b/scripts/statistics/base/cloglog.m
@@ -41,15 +41,17 @@ function y = cloglog (x)
   if (nargin != 1)
     print_usage ();
   endif
 
   y = - log (- log (x));
 
 endfunction
 
-%!assert(cloglog(0), -Inf)
-%!assert(cloglog(1), Inf)
-%!assert(cloglog(1/e), 0)
+
+%!assert (cloglog (0), -Inf)
+%!assert (cloglog (1), Inf)
+%!assert (cloglog (1/e), 0)
 
 %% Test input validation
 %!error cloglog ()
 %!error cloglog (1, 2)
+
diff --git a/scripts/statistics/base/corr.m b/scripts/statistics/base/corr.m
--- a/scripts/statistics/base/corr.m
+++ b/scripts/statistics/base/corr.m
@@ -84,29 +84,29 @@ endfunction
 %! cc1 = corr (x);
 %! cc2 = corr (x, x);
 %! assert (size (cc1) == [10, 10] && size (cc2) == [10, 10]);
 %! assert (cc1, cc2, sqrt (eps));
 
 %!test
 %! x = [1:3]';
 %! y = [3:-1:1]';
-%! assert (corr (x,y), -1, 5*eps)
-%! assert (corr (x,flipud (y)), 1, 5*eps)
-%! assert (corr ([x, y]), [1 -1; -1 1], 5*eps)
+%! assert (corr (x, y), -1, 5*eps);
+%! assert (corr (x, flipud (y)), 1, 5*eps);
+%! assert (corr ([x, y]), [1 -1; -1 1], 5*eps);
 
 %!test
 %! x = single ([1:3]');
 %! y = single ([3:-1:1]');
-%! assert (corr (x,y), single (-1), 5*eps)
-%! assert (corr (x,flipud (y)), single (1), 5*eps)
-%! assert (corr ([x, y]), single ([1 -1; -1 1]), 5*eps)
+%! assert (corr (x, y), single (-1), 5*eps);
+%! assert (corr (x, flipud (y)), single (1), 5*eps);
+%! assert (corr ([x, y]), single ([1 -1; -1 1]), 5*eps);
 
-%!assert (corr (5), 1);
-%!assert (corr (single(5)), single(1));
+%!assert (corr (5), 1)
+%!assert (corr (single(5)), single(1))
 
 %% Test input validation
-%!error corr ();
-%!error corr (1, 2, 3);
-%!error corr ([1; 2], ["A", "B"]);
-%!error corr (ones (2,2,2));
-%!error corr (ones (2,2), ones (2,2,2));
+%!error corr ()
+%!error corr (1, 2, 3)
+%!error corr ([1; 2], ["A", "B"])
+%!error corr (ones (2,2,2))
+%!error corr (ones (2,2), ones (2,2,2))
 
diff --git a/scripts/statistics/base/cov.m b/scripts/statistics/base/cov.m
--- a/scripts/statistics/base/cov.m
+++ b/scripts/statistics/base/cov.m
@@ -116,50 +116,50 @@ function c = cov (x, y = [], opt = 0)
 
 endfunction
 
 
 %!test
 %! x = rand (10);
 %! cx1 = cov (x);
 %! cx2 = cov (x, x);
-%! assert(size (cx1) == [10, 10] && size (cx2) == [10, 10]);
-%! assert(cx1, cx2, 1e1*eps);
+%! assert (size (cx1) == [10, 10] && size (cx2) == [10, 10]);
+%! assert (cx1, cx2, 1e1*eps);
 
 %!test
 %! x = [1:3]';
 %! y = [3:-1:1]';
-%! assert (cov (x,y), -1, 5*eps)
-%! assert (cov (x,flipud (y)), 1, 5*eps)
-%! assert (cov ([x, y]), [1 -1; -1 1], 5*eps)
+%! assert (cov (x, y), -1, 5*eps);
+%! assert (cov (x, flipud (y)), 1, 5*eps);
+%! assert (cov ([x, y]), [1 -1; -1 1], 5*eps);
 
 %!test
 %! x = single ([1:3]');
 %! y = single ([3:-1:1]');
-%! assert (cov (x,y), single (-1), 5*eps)
-%! assert (cov (x,flipud (y)), single (1), 5*eps)
-%! assert (cov ([x, y]), single ([1 -1; -1 1]), 5*eps)
+%! assert (cov (x, y), single (-1), 5*eps);
+%! assert (cov (x, flipud (y)), single (1), 5*eps);
+%! assert (cov ([x, y]), single ([1 -1; -1 1]), 5*eps);
 
 %!test
 %! x = [1:5];
 %! c = cov (x);
 %! assert (isscalar (c));
 %! assert (c, 2.5);
 
-%!assert(cov (5), 0);
-%!assert(cov (single(5)), single(0));
+%!assert(cov (5), 0)
+%!assert(cov (single(5)), single(0))
 
 %!test
 %! x = [1:5];
 %! c = cov (x, 0);
 %! assert(c, 2.5);
 %! c = cov (x, 1);
 %! assert(c, 2);
 
 %% Test input validation
-%!error cov ();
-%!error cov (1, 2, 3, 4);
-%!error cov ([1; 2], ["A", "B"]);
-%!error cov (ones (2,2,2));
-%!error cov (ones (2,2), ones (2,2,2));
-%!error cov (1, 3);
-%!error cov (ones (2,2), ones (3,2));
+%!error cov ()
+%!error cov (1, 2, 3, 4)
+%!error cov ([1; 2], ["A", "B"])
+%!error cov (ones (2,2,2))
+%!error cov (ones (2,2), ones (2,2,2))
+%!error cov (1, 3)
+%!error cov (ones (2,2), ones (3,2))
 
diff --git a/scripts/statistics/base/gls.m b/scripts/statistics/base/gls.m
--- a/scripts/statistics/base/gls.m
+++ b/scripts/statistics/base/gls.m
@@ -135,11 +135,11 @@ endfunction
 %!error gls (1, 2)
 %!error gls (1, 2, 3, 4)
 %!error gls ([true, true], [1, 2], ones (2))
 %!error gls ([1, 2], [true, true], ones (2))
 %!error gls ([1, 2], [1, 2], true (2))
 %!error gls (ones (2,2,2), ones (2,2), ones (4,4))
 %!error gls (ones (2,2), ones (2,2,2), ones (4,4))
 %!error gls (ones (2,2), ones (2,2), ones (4,4,4))
-%!error gls (ones(1,2), ones(2,2), ones (2,2))
-%!error gls (ones(2,2), ones(2,2), ones (2,2))
+%!error gls (ones (1,2), ones (2,2), ones (2,2))
+%!error gls (ones (2,2), ones (2,2), ones (2,2))
 
diff --git a/scripts/statistics/base/histc.m b/scripts/statistics/base/histc.m
--- a/scripts/statistics/base/histc.m
+++ b/scripts/statistics/base/histc.m
@@ -163,14 +163,15 @@ endfunction
 %! n = histc (x, 0:10);
 %! assert (n, [repmat(100, 1, 10), 1]);
 
 %!test
 %! x = repmat (linspace (0, 10, 1001), [2, 1, 3]);
 %! n = histc (x, 0:10, 2);
 %! assert (n, repmat ([repmat(100, 1, 10), 1], [2, 1, 3]));
 
-%!error histc ();
-%!error histc (1);
-%!error histc (1, 2, 3, 4);
-%!error histc ([1:10 1+i], 2);
-%!error histc (1:10, []);
-%!error histc (1, 1, 3);
+%!error histc ()
+%!error histc (1)
+%!error histc (1, 2, 3, 4)
+%!error histc ([1:10 1+i], 2)
+%!error histc (1:10, [])
+%!error histc (1, 1, 3)
+
diff --git a/scripts/statistics/base/iqr.m b/scripts/statistics/base/iqr.m
--- a/scripts/statistics/base/iqr.m
+++ b/scripts/statistics/base/iqr.m
@@ -77,22 +77,22 @@ function y = iqr (x, dim)
     rng = [0 : n-1] * stride + offset;
 
     y(i) = diff (empirical_inv ([1/4, 3/4], x(rng)));
   endfor
 
 endfunction
 
 
-%!assert (iqr (1:101), 50);
-%!assert (iqr (single(1:101)), single(50));
+%!assert (iqr (1:101), 50)
+%!assert (iqr (single (1:101)), single (50))
 
 %%!test
 %%! x = [1:100];
 %%! n = iqr (x, 0:10);
 %%! assert (n, [repmat(100, 1, 10), 1]);
 
-%!error iqr ();
-%!error iqr (1, 2, 3);
-%!error iqr (1);
-%!error iqr (['A'; 'B']);
-%!error iqr (1:10, 3);
+%!error iqr ()
+%!error iqr (1, 2, 3)
+%!error iqr (1)
+%!error iqr (['A'; 'B'])
+%!error iqr (1:10, 3)
 
diff --git a/scripts/statistics/base/kendall.m b/scripts/statistics/base/kendall.m
--- a/scripts/statistics/base/kendall.m
+++ b/scripts/statistics/base/kendall.m
@@ -116,19 +116,20 @@ endfunction
 
 
 %!test
 %! x = [1:2:10];
 %! y = [100:10:149];
 %! assert (kendall (x,y), 1, 5*eps);
 %! assert (kendall (x,fliplr (y)), -1, 5*eps);
 
-%!assert (kendall (logical(1)), 1);
-%!assert (kendall (single(1)), single(1));
+%!assert (kendall (logical (1)), 1)
+%!assert (kendall (single (1)), single (1))
 
 %% Test input validation
-%!error kendall ();
-%!error kendall (1, 2, 3);
-%!error kendall (['A'; 'B']);
-%!error kendall (ones(2,1), ['A'; 'B']);
-%!error kendall (ones (2,2,2));
-%!error kendall (ones (2,2), ones (2,2,2));
-%!error kendall (ones (2,2), ones (3,2));
+%!error kendall ()
+%!error kendall (1, 2, 3)
+%!error kendall (['A'; 'B'])
+%!error kendall (ones (2,1), ['A'; 'B'])
+%!error kendall (ones (2,2,2))
+%!error kendall (ones (2,2), ones (2,2,2))
+%!error kendall (ones (2,2), ones (3,2))
+
diff --git a/scripts/statistics/base/kurtosis.m b/scripts/statistics/base/kurtosis.m
--- a/scripts/statistics/base/kurtosis.m
+++ b/scripts/statistics/base/kurtosis.m
@@ -82,19 +82,19 @@ function retval = kurtosis (x, dim)
 endfunction
 
 
 %!test
 %! x = [-1; 0; 0; 0; 1];
 %! y = [x, 2*x];
 %! assert (kurtosis (y), [-1.4, -1.4], sqrt (eps));
 
-%!assert (kurtosis (single(1)), single(0));
+%!assert (kurtosis (single (1)), single (0))
 
 %% Test input validation
 %!error kurtosis ()
 %!error kurtosis (1, 2, 3)
 %!error kurtosis (['A'; 'B'])
-%!error kurtosis (1, ones(2,2))
+%!error kurtosis (1, ones (2,2))
 %!error kurtosis (1, 1.5)
 %!error kurtosis (1, 0)
 %!error kurtosis (1, 3)
 
diff --git a/scripts/statistics/base/logit.m b/scripts/statistics/base/logit.m
--- a/scripts/statistics/base/logit.m
+++ b/scripts/statistics/base/logit.m
@@ -45,15 +45,16 @@ function y = logit (p)
 
   y = logistic_inv (p);
 
 endfunction
 
 
 %!test
 %! p = [0.01:0.01:0.99];
-%! assert(logit (p), log (p ./ (1-p)), 25*eps)
+%! assert (logit (p), log (p ./ (1-p)), 25*eps);
 
-%!assert(logit ([-1, 0, 0.5, 1, 2]), [NaN, -Inf, 0, +Inf, NaN])
+%!assert (logit ([-1, 0, 0.5, 1, 2]), [NaN, -Inf, 0, +Inf, NaN])
 
 %% Test input validation
 %!error logit ()
 %!error logit (1, 2)
+
diff --git a/scripts/statistics/base/mahalanobis.m b/scripts/statistics/base/mahalanobis.m
--- a/scripts/statistics/base/mahalanobis.m
+++ b/scripts/statistics/base/mahalanobis.m
@@ -66,15 +66,16 @@ function retval = mahalanobis (x, y)
   winv = inv (w);
 
   retval = (xm - ym) * winv * (xm - ym)';
 
 endfunction
 
 
 %% Test input validation
-%!error mahalanobis ();
-%!error mahalanobis (1, 2, 3);
-%!error mahalanobis ('A', 'B');
-%!error mahalanobis ([1, 2], ['A', 'B']);
-%!error mahalanobis (ones (2,2,2));
-%!error mahalanobis (ones (2,2), ones (2,2,2));
-%!error mahalanobis (ones (2,2), ones (2,3));
+%!error mahalanobis ()
+%!error mahalanobis (1, 2, 3)
+%!error mahalanobis ('A', 'B')
+%!error mahalanobis ([1, 2], ['A', 'B'])
+%!error mahalanobis (ones (2,2,2))
+%!error mahalanobis (ones (2,2), ones (2,2,2))
+%!error mahalanobis (ones (2,2), ones (2,3))
+
diff --git a/scripts/statistics/base/mean.m b/scripts/statistics/base/mean.m
--- a/scripts/statistics/base/mean.m
+++ b/scripts/statistics/base/mean.m
@@ -122,30 +122,30 @@ function y = mean (x, opt1, opt2)
 
 endfunction
 
 
 %!test
 %! x = -10:10;
 %! y = x';
 %! z = [y, y+10];
-%! assert(mean (x) == 0);
-%! assert(mean (y) == 0);
-%! assert(mean (z) == [0, 10]);
+%! assert (mean (x), 0);
+%! assert (mean (y), 0);
+%! assert (mean (z), [0, 10]);
 
-%!assert(mean (magic(3), 1), [5, 5, 5]);
-%!assert(mean (magic(3), 2), [5; 5; 5]);
-%!assert(mean ([2 8], 'g'), 4);
-%!assert(mean ([4 4 2], 'h'), 3);
-%!assert(mean (logical ([1 0 1 1])), 0.75);
-%!assert(mean (single ([1 0 1 1])), single (0.75));
+%!assert (mean (magic (3), 1), [5, 5, 5])
+%!assert (mean (magic (3), 2), [5; 5; 5])
+%!assert (mean ([2 8], "g"), 4)
+%!assert (mean ([4 4 2], "h"), 3)
+%!assert (mean (logical ([1 0 1 1])), 0.75)
+%!assert (mean (single ([1 0 1 1])), single (0.75))
 
 %% Test input validation
-%!error mean ();
-%!error mean (1, 2, 3, 4);
-%!error mean ({1:5});
-%!error mean (1, 2, 3);
-%!error mean (1, ones(2,2));
-%!error mean (1, 1.5);
-%!error mean (1, 0);
-%!error mean (1, 3);
-%!error mean (1, 'b');
+%!error mean ()
+%!error mean (1, 2, 3, 4)
+%!error mean ({1:5})
+%!error mean (1, 2, 3)
+%!error mean (1, ones(2,2))
+%!error mean (1, 1.5)
+%!error mean (1, 0)
+%!error mean (1, 3)
+%!error mean (1, "b")
 
diff --git a/scripts/statistics/base/meansq.m b/scripts/statistics/base/meansq.m
--- a/scripts/statistics/base/meansq.m
+++ b/scripts/statistics/base/meansq.m
@@ -68,22 +68,22 @@ function y = meansq (x, dim)
     endif
   endif
 
   y = sumsq (x, dim) / sz(dim);
 
 endfunction
 
 
-%!assert(meansq (1:5), 11);
-%!assert(meansq (single(1:5)), single(11));
-%!assert(meansq (magic (4)), [94.5, 92.5, 92.5, 94.5]);
-%!assert(meansq (magic (4), 2), [109.5; 77.5; 77.5; 109.5]);
+%!assert (meansq (1:5), 11)
+%!assert (meansq (single (1:5)), single (11))
+%!assert (meansq (magic (4)), [94.5, 92.5, 92.5, 94.5])
+%!assert (meansq (magic (4), 2), [109.5; 77.5; 77.5; 109.5])
 
 %% Test input validation
 %!error meansq ()
 %!error meansq (1, 2, 3)
-%!error meansq (['A'; 'B']);
-%!error meansq (1, ones(2,2))
+%!error meansq (['A'; 'B'])
+%!error meansq (1, ones (2,2))
 %!error meansq (1, 1.5)
 %!error meansq (1, 0)
 %!error meansq (1, 3)
 
diff --git a/scripts/statistics/base/median.m b/scripts/statistics/base/median.m
--- a/scripts/statistics/base/median.m
+++ b/scripts/statistics/base/median.m
@@ -89,25 +89,25 @@ endfunction
 
 
 %!test
 %! x = [1, 2, 3, 4, 5, 6];
 %! x2 = x';
 %! y = [1, 2, 3, 4, 5, 6, 7];
 %! y2 = y';
 %!
-%! assert(median (x) == median (x2) && median (x) == 3.5);
-%! assert(median (y) == median (y2) && median (y) == 4);
-%! assert(median ([x2, 2*x2]) == [3.5, 7]);
-%! assert(median ([y2, 3*y2]) == [4, 12]);
+%! assert (median (x) == median (x2) && median (x) == 3.5);
+%! assert (median (y) == median (y2) && median (y) == 4);
+%! assert (median ([x2, 2*x2]), [3.5, 7]);
+%! assert (median ([y2, 3*y2]), [4, 12]);
 
-%!assert(median (single([1,2,3])), single(2));
-%!assert(median ([1,2,NaN;4,5,6;NaN,8,9]), [NaN, 5, NaN]);
+%!assert (median (single ([1,2,3])), single (2))
+%!assert (median ([1,2,NaN;4,5,6;NaN,8,9]), [NaN, 5, NaN])
 
 %% Test input validation
-%!error median ();
-%!error median (1, 2, 3);
-%!error median ({1:5});
-%!error median (['A'; 'B']);
-%!error median (1, ones(2,2));
-%!error median (1, 1.5);
-%!error median (1, 0);
+%!error median ()
+%!error median (1, 2, 3)
+%!error median ({1:5})
+%!error median (['A'; 'B'])
+%!error median (1, ones(2,2))
+%!error median (1, 1.5)
+%!error median (1, 0)
 
diff --git a/scripts/statistics/base/mode.m b/scripts/statistics/base/mode.m
--- a/scripts/statistics/base/mode.m
+++ b/scripts/statistics/base/mode.m
@@ -111,25 +111,25 @@ endfunction
 %! [m, f, c] = mode (a);
 %! [m2, f2, c2] = mode (full (a));
 %! assert (m, sparse (m2));
 %! assert (f, sparse (f2));
 %! c_exp(1:length(a)) = { sparse (0) };
 %! assert (c ,c_exp);
 %! assert (c2,c_exp );
 
-%!assert(mode ([2,3,1,2,3,4],1),[2,3,1,2,3,4]);
-%!assert(mode ([2,3,1,2,3,4],2),2);
-%!assert(mode ([2,3,1,2,3,4]),2);
-%!assert(mode (single([2,3,1,2,3,4])), single(2));
-%!assert(mode (int8([2,3,1,2,3,4])), int8(2));
+%!assert (mode ([2,3,1,2,3,4],1),[2,3,1,2,3,4])
+%!assert (mode ([2,3,1,2,3,4],2),2)
+%!assert (mode ([2,3,1,2,3,4]),2)
+%!assert (mode (single ([2,3,1,2,3,4])), single (2))
+%!assert (mode (int8 ([2,3,1,2,3,4])), int8 (2))
 
-%!assert(mode ([2;3;1;2;3;4],1),2);
-%!assert(mode ([2;3;1;2;3;4],2),[2;3;1;2;3;4]);
-%!assert(mode ([2;3;1;2;3;4]),2);
+%!assert (mode ([2;3;1;2;3;4],1),2)
+%!assert (mode ([2;3;1;2;3;4],2),[2;3;1;2;3;4])
+%!assert (mode ([2;3;1;2;3;4]),2)
 
 %!shared x
 %! x(:,:,1) = toeplitz (1:3);
 %! x(:,:,2) = circshift (toeplitz (1:3), 1);
 %! x(:,:,3) = circshift (toeplitz (1:3), 2);
 %!test
 %! [m, f, c] = mode (x, 1);
 %! assert (reshape (m, [3, 3]), [1 1 1; 2 2 2; 1 1 1]);
@@ -155,13 +155,13 @@ endfunction
 %! assert (c{2}, [1; 2; 3]);
 %! assert (c{3}, [1; 2; 3]);
 
 %% Test input validation
 %!error mode ()
 %!error mode (1, 2, 3)
 %!error mode ({1 2 3})
 %!error mode (['A'; 'B'])
-%!error mode (1, ones(2,2))
+%!error mode (1, ones (2,2))
 %!error mode (1, 1.5)
 %!error mode (1, 0)
 %!error mode (1, 3)
 
diff --git a/scripts/statistics/base/moment.m b/scripts/statistics/base/moment.m
--- a/scripts/statistics/base/moment.m
+++ b/scripts/statistics/base/moment.m
@@ -174,26 +174,26 @@ function m = moment (x, p, opt1, opt2)
 endfunction
 
 
 %!test
 %! x = rand (10);
 %! assert (moment (x,1), mean (x), 1e1*eps);
 %! assert (moment (x,2), meansq (x), 1e1*eps);
 %! assert (moment (x,1,2), mean (x,2), 1e1*eps);
-%! assert (moment (x,1,'c'), mean (center (x)), 1e1*eps);
-%! assert (moment (x,1,'a'), mean (abs (x)), 1e1*eps);
+%! assert (moment (x,1,"c"), mean (center (x)), 1e1*eps);
+%! assert (moment (x,1,"a"), mean (abs (x)), 1e1*eps);
 
-%!assert (moment (single([1 2 3]),1), single(2));
+%!assert (moment (single ([1 2 3]), 1), single (2))
 
 %% Test input validation
 %!error moment ()
 %!error moment (1)
 %!error moment (1, 2, 3, 4, 5)
 %!error moment (['A'; 'B'], 2)
-%!error moment (ones(2,0,3), 2)
+%!error moment (ones (2,0,3), 2)
 %!error moment (1, true)
-%!error moment (1, ones(2,2))
+%!error moment (1, ones (2,2))
 %!error moment (1, 2, 3, 4)
-%!error moment (1, 2, ones(2,2))
+%!error moment (1, 2, ones (2,2))
 %!error moment (1, 2, 1.5)
 %!error moment (1, 2, 4)
 
diff --git a/scripts/statistics/base/ols.m b/scripts/statistics/base/ols.m
--- a/scripts/statistics/base/ols.m
+++ b/scripts/statistics/base/ols.m
@@ -134,17 +134,17 @@ function [beta, sigma, r] = ols (y, x)
 
 endfunction
 
 
 %!test
 %! x = [1:5]';
 %! y = 3*x + 2;
 %! x = [x, ones(5,1)];
-%! assert (ols(y,x), [3; 2], 50*eps)
+%! assert (ols (y,x), [3; 2], 50*eps)
 
 %!test
 %! x = [1, 2; 3, 4];
 %! y = [1; 2];
 %! [b, s, r] = ols (x, y);
 %! assert (b, [1.4, 2], 2*eps);
 %! assert (s, [0.2, 0; 0, 0], 2*eps);
 %! assert (r, [-0.4, 0; 0.2, 0], 2*eps);
@@ -158,16 +158,17 @@ endfunction
 
 %!test
 %! x = [1, 2; 3, 4];
 %! y = [1; 2];
 %! b = ols (x, y);
 %! assert (b, [1.4, 2], 2*eps);
 
 %% Test input validation
-%!error ols ();
-%!error ols (1);
-%!error ols (1, 2, 3);
-%!error ols ([true, true], [1, 2]);
-%!error ols ([1, 2], [true, true]);
-%!error ols (ones (2,2,2), ones (2,2));
-%!error ols (ones (2,2), ones (2,2,2));
-%!error ols (ones(1,2), ones(2,2));
+%!error ols ()
+%!error ols (1)
+%!error ols (1, 2, 3)
+%!error ols ([true, true], [1, 2])
+%!error ols ([1, 2], [true, true])
+%!error ols (ones (2,2,2), ones (2,2))
+%!error ols (ones (2,2), ones (2,2,2))
+%!error ols (ones (1,2), ones (2,2))
+
diff --git a/scripts/statistics/base/ppplot.m b/scripts/statistics/base/ppplot.m
--- a/scripts/statistics/base/ppplot.m
+++ b/scripts/statistics/base/ppplot.m
@@ -74,11 +74,11 @@ function [p, y] = ppplot (x, dist, varar
     plot (p, y);
     axis ([0, 1, 0, 1]);
   endif
 
 endfunction
 
 
 %% Test input validation
-%!error ppplot ();
-%!error ppplot (ones(2,2));
+%!error ppplot ()
+%!error ppplot (ones (2,2))
 
diff --git a/scripts/statistics/base/prctile.m b/scripts/statistics/base/prctile.m
--- a/scripts/statistics/base/prctile.m
+++ b/scripts/statistics/base/prctile.m
@@ -168,8 +168,9 @@ endfunction
 %!error prctile ()
 %!error prctile (1, 2, 3, 4)
 %!error prctile (['A'; 'B'], 10)
 %!error prctile (1:10, [true, false])
 %!error prctile (1:10, ones (2,2))
 %!error prctile (1, 1, 1.5)
 %!error prctile (1, 1, 0)
 %!error prctile (1, 1, 3)
+
diff --git a/scripts/statistics/base/probit.m b/scripts/statistics/base/probit.m
--- a/scripts/statistics/base/probit.m
+++ b/scripts/statistics/base/probit.m
@@ -31,14 +31,15 @@ function y = probit (p)
   if (nargin != 1)
     print_usage ();
   endif
 
   y = stdnormal_inv (p);
 
 endfunction
 
-%!assert(probit([-1, 0, 0.5, 1, 2]), [NaN, -Inf, 0, Inf, NaN]);
+
+%!assert (probit ([-1, 0, 0.5, 1, 2]), [NaN, -Inf, 0, Inf, NaN])
 
 %% Test input validation
 %!error probit ()
 %!error probit (1, 2)
 
diff --git a/scripts/statistics/base/quantile.m b/scripts/statistics/base/quantile.m
--- a/scripts/statistics/base/quantile.m
+++ b/scripts/statistics/base/quantile.m
@@ -152,138 +152,138 @@ function q = quantile (x, p = [], dim = 
 
 endfunction
 
 
 %!test
 %! p = 0.5;
 %! x = sort (rand (11));
 %! q = quantile (x, p);
-%! assert (q, x(6,:))
+%! assert (q, x(6,:));
 %! x = x.';
 %! q = quantile (x, p, 2);
 %! assert (q, x(:,6));
 
 %!test
 %! p = [0.00, 0.25, 0.50, 0.75, 1.00];
 %! x = [1; 2; 3; 4];
 %! a = [1.0000   1.0000   2.0000   3.0000   4.0000
 %!      1.0000   1.5000   2.5000   3.5000   4.0000
 %!      1.0000   1.0000   2.0000   3.0000   4.0000
 %!      1.0000   1.0000   2.0000   3.0000   4.0000
 %!      1.0000   1.5000   2.5000   3.5000   4.0000
 %!      1.0000   1.2500   2.5000   3.7500   4.0000
 %!      1.0000   1.7500   2.5000   3.2500   4.0000
 %!      1.0000   1.4167   2.5000   3.5833   4.0000
 %!      1.0000   1.4375   2.5000   3.5625   4.0000];
-%! for m = (1:9)
+%! for m = 1:9
 %!   q = quantile (x, p, 1, m).';
-%!   assert (q, a(m,:), 0.0001)
+%!   assert (q, a(m,:), 0.0001);
 %! endfor
 
 %!test
 %! p = [0.00, 0.25, 0.50, 0.75, 1.00];
 %! x = [1; 2; 3; 4; 5];
 %! a = [1.0000   2.0000   3.0000   4.0000   5.0000
 %!      1.0000   2.0000   3.0000   4.0000   5.0000
 %!      1.0000   1.0000   2.0000   4.0000   5.0000
 %!      1.0000   1.2500   2.5000   3.7500   5.0000
 %!      1.0000   1.7500   3.0000   4.2500   5.0000
 %!      1.0000   1.5000   3.0000   4.5000   5.0000
 %!      1.0000   2.0000   3.0000   4.0000   5.0000
 %!      1.0000   1.6667   3.0000   4.3333   5.0000
 %!      1.0000   1.6875   3.0000   4.3125   5.0000];
-%! for m = (1:9)
+%! for m = 1:9
 %!   q = quantile (x, p, 1, m).';
-%!   assert (q, a(m,:), 0.0001)
+%!   assert (q, a(m,:), 0.0001);
 %! endfor
 
 %!test
 %! p = [0.00, 0.25, 0.50, 0.75, 1.00];
 %! x = [1; 2; 5; 9];
 %! a = [1.0000   1.0000   2.0000   5.0000   9.0000
 %!      1.0000   1.5000   3.5000   7.0000   9.0000
 %!      1.0000   1.0000   2.0000   5.0000   9.0000
 %!      1.0000   1.0000   2.0000   5.0000   9.0000
 %!      1.0000   1.5000   3.5000   7.0000   9.0000
 %!      1.0000   1.2500   3.5000   8.0000   9.0000
 %!      1.0000   1.7500   3.5000   6.0000   9.0000
 %!      1.0000   1.4167   3.5000   7.3333   9.0000
 %!      1.0000   1.4375   3.5000   7.2500   9.0000];
-%! for m = (1:9)
+%! for m = 1:9
 %!   q = quantile (x, p, 1, m).';
-%!   assert (q, a(m,:), 0.0001)
+%!   assert (q, a(m,:), 0.0001);
 %! endfor
 
 %!test
 %! p = [0.00, 0.25, 0.50, 0.75, 1.00];
 %! x = [1; 2; 5; 9; 11];
 %! a = [1.0000    2.0000    5.0000    9.0000   11.0000
 %!      1.0000    2.0000    5.0000    9.0000   11.0000
 %!      1.0000    1.0000    2.0000    9.0000   11.0000
 %!      1.0000    1.2500    3.5000    8.0000   11.0000
 %!      1.0000    1.7500    5.0000    9.5000   11.0000
 %!      1.0000    1.5000    5.0000   10.0000   11.0000
 %!      1.0000    2.0000    5.0000    9.0000   11.0000
 %!      1.0000    1.6667    5.0000    9.6667   11.0000
 %!      1.0000    1.6875    5.0000    9.6250   11.0000];
-%! for m = (1:9)
+%! for m = 1:9
 %!   q = quantile (x, p, 1, m).';
-%!   assert (q, a(m,:), 0.0001)
+%!   assert (q, a(m,:), 0.0001);
 %! endfor
 
 %!test
 %! p = [0.00, 0.25, 0.50, 0.75, 1.00];
 %! x = [16; 11; 15; 12; 15;  8; 11; 12;  6; 10];
 %! a = [6.0000   10.0000   11.0000   15.0000   16.0000
 %!      6.0000   10.0000   11.5000   15.0000   16.0000
 %!      6.0000    8.0000   11.0000   15.0000   16.0000
 %!      6.0000    9.0000   11.0000   13.5000   16.0000
 %!      6.0000   10.0000   11.5000   15.0000   16.0000
 %!      6.0000    9.5000   11.5000   15.0000   16.0000
 %!      6.0000   10.2500   11.5000   14.2500   16.0000
 %!      6.0000    9.8333   11.5000   15.0000   16.0000
 %!      6.0000    9.8750   11.5000   15.0000   16.0000];
-%! for m = (1:9)
+%! for m = 1:9
 %!   q = quantile (x, p, 1, m).';
-%!   assert (q, a(m,:), 0.0001)
+%!   assert (q, a(m,:), 0.0001);
 %! endfor
 
 %!test
 %! p = [0.00, 0.25, 0.50, 0.75, 1.00];
 %! x = [-0.58851;  0.40048;  0.49527; -2.551500; -0.52057; ...
 %!      -0.17841; 0.057322; -0.62523;  0.042906;  0.12337];
 %! a = [-2.551474  -0.588505  -0.178409   0.123366   0.495271
 %!      -2.551474  -0.588505  -0.067751   0.123366   0.495271
 %!      -2.551474  -0.625231  -0.178409   0.123366   0.495271
 %!      -2.551474  -0.606868  -0.178409   0.090344   0.495271
 %!      -2.551474  -0.588505  -0.067751   0.123366   0.495271
 %!      -2.551474  -0.597687  -0.067751   0.192645   0.495271
 %!      -2.551474  -0.571522  -0.067751   0.106855   0.495271
 %!      -2.551474  -0.591566  -0.067751   0.146459   0.495271
 %!      -2.551474  -0.590801  -0.067751   0.140686   0.495271];
-%! for m = (1:9)
+%! for m = 1:9
 %!   q = quantile (x, p, 1, m).';
-%!   assert (q, a(m,:), 0.0001)
+%!   assert (q, a(m,:), 0.0001);
 %! endfor
 
 %!test
 %! p = 0.5;
 %! x = [0.112600, 0.114800, 0.052100, 0.236400, 0.139300
 %!      0.171800, 0.727300, 0.204100, 0.453100, 0.158500
 %!      0.279500, 0.797800, 0.329600, 0.556700, 0.730700
 %!      0.428800, 0.875300, 0.647700, 0.628700, 0.816500
 %!      0.933100, 0.931200, 0.963500, 0.779600, 0.846100];
 %! tol = 0.00001;
 %! x(5,5) = NaN;
-%! assert (quantile(x, p, 1), [0.27950, 0.79780, 0.32960, 0.55670, 0.44460], tol);
+%! assert (quantile (x, p, 1), [0.27950, 0.79780, 0.32960, 0.55670, 0.44460], tol);
 %! x(1,1) = NaN;
-%! assert (quantile(x, p, 1), [0.35415, 0.79780, 0.32960, 0.55670, 0.44460], tol);
+%! assert (quantile (x, p, 1), [0.35415, 0.79780, 0.32960, 0.55670, 0.44460], tol);
 %! x(3,3) = NaN;
-%! assert (quantile(x, p, 1), [0.35415, 0.79780, 0.42590, 0.55670, 0.44460], tol);
+%! assert (quantile (x, p, 1), [0.35415, 0.79780, 0.42590, 0.55670, 0.44460], tol);
 
 %!test
 %! sx = [2, 3, 4];
 %! x = rand (sx);
 %! dim = 2;
 %! p = 0.5;
 %! yobs = quantile (x, p, dim);
 %! yexp = median (x, dim);
diff --git a/scripts/statistics/base/range.m b/scripts/statistics/base/range.m
--- a/scripts/statistics/base/range.m
+++ b/scripts/statistics/base/range.m
@@ -45,17 +45,18 @@ function y = range (x, dim)
     y = max (x) - min (x);
   else
     y = max (x, [], dim) - min (x, [], dim);
   endif
 
 endfunction
 
 
-%!assert(range (1:10), 9);
-%!assert(range (single(1:10)), single(9));
-%!assert(range (magic (3)), [5, 8, 5]);
-%!assert(range (magic (3), 2), [7; 4; 7]);
-%!assert(range (2), 0);
+%!assert (range (1:10), 9)
+%!assert (range (single (1:10)), single (9))
+%!assert (range (magic (3)), [5, 8, 5])
+%!assert (range (magic (3), 2), [7; 4; 7])
+%!assert (range (2), 0)
 
 %% Test input validation
 %!error range ()
 %!error range (1, 2, 3)
+
diff --git a/scripts/statistics/base/ranks.m b/scripts/statistics/base/ranks.m
--- a/scripts/statistics/base/ranks.m
+++ b/scripts/statistics/base/ranks.m
@@ -81,22 +81,22 @@ function y = ranks (x, dim)
     if (dim != 1)
       y = permute (y, perm);
     endif
   endif
 
 endfunction
 
 
-%!assert(ranks (1:2:10), 1:5);
-%!assert(ranks (10:-2:1), 5:-1:1);
-%!assert(ranks ([2, 1, 2, 4]), [2.5, 1, 2.5, 4]);
-%!assert(ranks (ones(1, 5)), 3*ones(1, 5));
-%!assert(ranks (1e6*ones(1, 5)), 3*ones(1, 5));
-%!assert(ranks (rand (1, 5), 1), ones(1, 5));
+%!assert (ranks (1:2:10), 1:5)
+%!assert (ranks (10:-2:1), 5:-1:1)
+%!assert (ranks ([2, 1, 2, 4]), [2.5, 1, 2.5, 4])
+%!assert (ranks (ones (1, 5)), 3*ones (1, 5))
+%!assert (ranks (1e6*ones (1, 5)), 3*ones (1, 5))
+%!assert (ranks (rand (1, 5), 1), ones (1, 5))
 
 %% Test input validation
 %!error ranks ()
 %!error ranks (1, 2, 3)
 %!error ranks ({1, 2})
 %!error ranks (['A'; 'B'])
 %!error ranks (1, 1.5)
 %!error ranks (1, 0)
diff --git a/scripts/statistics/base/run_count.m b/scripts/statistics/base/run_count.m
--- a/scripts/statistics/base/run_count.m
+++ b/scripts/statistics/base/run_count.m
@@ -88,26 +88,26 @@ function retval = run_count (x, n, dim)
 
   if (dim != 1)
     retval = ipermute (retval, perm);
   endif
 
 endfunction
 
 
-%!assert(run_count (magic(3), 4), [1,0,1;1,0,1;0,1,0;0,0,0])
-%!assert(run_count (magic(3), 4, 2), [1,0,1;1,0,1;0,1,0;0,0,0]')
-%!assert(run_count (5:-1:1, 5), [5, 0, 0, 0, 0])
-%!assert(run_count (ones(3), 4), [0,0,0;0,0,0;1,1,1;0,0,0])
+%!assert (run_count (magic (3), 4), [1,0,1;1,0,1;0,1,0;0,0,0])
+%!assert (run_count (magic (3), 4, 2), [1,0,1;1,0,1;0,1,0;0,0,0]')
+%!assert (run_count (5:-1:1, 5), [5, 0, 0, 0, 0])
+%!assert (run_count (ones (3), 4), [0,0,0;0,0,0;1,1,1;0,0,0])
 
 %% Test input validation
 %!error run_count ()
 %!error run_count (1)
 %!error run_count (1, 2, 3, 4)
 %!error run_count ({1, 2}, 3)
 %!error run_count (['A'; 'A'; 'B'], 3)
-%!error run_count (1:5, ones(2,2))
+%!error run_count (1:5, ones (2,2))
 %!error run_count (1:5, 1.5)
 %!error run_count (1:5, -2)
-%!error run_count (1:5, 3, ones(2,2))
+%!error run_count (1:5, 3, ones (2,2))
 %!error run_count (1:5, 3, 1.5)
 %!error run_count (1:5, 3, 0)
 
diff --git a/scripts/statistics/base/runlength.m b/scripts/statistics/base/runlength.m
--- a/scripts/statistics/base/runlength.m
+++ b/scripts/statistics/base/runlength.m
@@ -47,20 +47,21 @@ function [count, value] = runlength (x)
   count = diff ([0 idx]);
   if (nargout == 2)
     value = x(idx);
   endif
 
 endfunction
 
 
-%!assert (runlength([2 2 0 4 4 4 0 1 1 1 1]), [2 1 3 1 4]);
-%!assert (runlength([2 2 0 4 4 4 0 1 1 1 1]'), [2 1 3 1 4]);
+%!assert (runlength ([2 2 0 4 4 4 0 1 1 1 1]), [2 1 3 1 4])
+%!assert (runlength ([2 2 0 4 4 4 0 1 1 1 1]'), [2 1 3 1 4])
 %!test
 %! [c, v] = runlength ([2 2 0 4 4 4 0 1 1 1 1]);
 %! assert (c, [2 1 3 1 4]);
 %! assert (v, [2 0 4 0 1]);
 
 %% Test input validation
 %!error runlength ()
 %!error runlength (1, 2)
 %!error runlength (['A'; 'B'])
-%!error runlength (ones(2,2))
+%!error runlength (ones (2,2))
+
diff --git a/scripts/statistics/base/skewness.m b/scripts/statistics/base/skewness.m
--- a/scripts/statistics/base/skewness.m
+++ b/scripts/statistics/base/skewness.m
@@ -74,27 +74,28 @@ function retval = skewness (x, dim)
   s = std (x, [], dim);
   idx = find (s > 0);
   x = sum (x .^ 3, dim);
   retval(idx) = x(idx) ./ (n * s(idx) .^ 3);
 
 endfunction
 
 
-%!assert(skewness ([-1,0,1]), 0);
-%!assert(skewness ([-2,0,1]) < 0);
-%!assert(skewness ([-1,0,2]) > 0);
-%!assert(skewness ([-3,0,1]) == -1*skewness([-1,0,3]));
+%!assert (skewness ([-1,0,1]), 0)
+%!assert (skewness ([-2,0,1]) < 0)
+%!assert (skewness ([-1,0,2]) > 0)
+%!assert (skewness ([-3,0,1]) == -1*skewness ([-1,0,3]))
 %!test
 %! x = [0; 0; 0; 1];
 %! y = [x, 2*x];
 %! assert(all (abs (skewness (y) - [0.75, 0.75]) < sqrt (eps)));
 
-%!assert (skewness (single(1)), single(0));
+%!assert (skewness (single (1)), single (0))
 
 %% Test input validation
 %!error skewness ()
 %!error skewness (1, 2, 3)
 %!error skewness (['A'; 'B'])
-%!error skewness (1, ones(2,2))
+%!error skewness (1, ones (2,2))
 %!error skewness (1, 1.5)
 %!error skewness (1, 0)
 %!error skewness (1, 3)
+
diff --git a/scripts/statistics/base/spearman.m b/scripts/statistics/base/spearman.m
--- a/scripts/statistics/base/spearman.m
+++ b/scripts/statistics/base/spearman.m
@@ -77,18 +77,19 @@ endfunction
 
 
 %!test
 %! x = 1:10;
 %! y = exp (x);
 %! assert (spearman (x,y), 1, 5*eps);
 %! assert (spearman (x,-y), -1, 5*eps);
 
-%!assert(spearman ([1 2 3], [-1 1 -2]), -0.5, 5*eps)
+%!assert (spearman ([1 2 3], [-1 1 -2]), -0.5, 5*eps)
 
 %% Test input validation
-%!error spearman ();
-%!error spearman (1, 2, 3);
-%!error spearman (['A'; 'B']);
-%!error spearman (ones(1,2), {1, 2});
-%!error spearman (ones (2,2,2));
-%!error spearman (ones (2,2), ones (2,2,2));
-%!error spearman (ones (2,2), ones (3,2));
+%!error spearman ()
+%!error spearman (1, 2, 3)
+%!error spearman (['A'; 'B'])
+%!error spearman (ones (1,2), {1, 2})
+%!error spearman (ones (2,2,2))
+%!error spearman (ones (2,2), ones (2,2,2))
+%!error spearman (ones (2,2), ones (3,2))
+
diff --git a/scripts/statistics/base/statistics.m b/scripts/statistics/base/statistics.m
--- a/scripts/statistics/base/statistics.m
+++ b/scripts/statistics/base/statistics.m
@@ -76,14 +76,14 @@ endfunction
 %! assert (std (x), s(7,:), eps);
 %! assert (skewness (x), s(8,:), eps);
 %! assert (kurtosis (x), s(9,:), eps);
 
 %% Test input validation
 %!error statistics ()
 %!error statistics (1, 2, 3)
 %!error statistics (['A'; 'B'])
-%!error statistics (1, ones(2,2))
+%!error statistics (1, ones (2,2))
 %!error statistics (1, 1.5)
 %!error statistics (1, 0)
 %!error statistics (1, 3)
 %!error statistics (1)
 
diff --git a/scripts/statistics/base/std.m b/scripts/statistics/base/std.m
--- a/scripts/statistics/base/std.m
+++ b/scripts/statistics/base/std.m
@@ -102,26 +102,26 @@ function retval = std (x, opt = 0, dim)
   endif
 
 endfunction
 
 
 %!test
 %! x = ones (10, 2);
 %! y = [1, 3];
-%! assert(std (x) == [0, 0]);
-%! assert(std (y), sqrt (2), sqrt (eps));
-%! assert(std (x, 0, 2), zeros (10, 1));
+%! assert (std (x), [0, 0]);
+%! assert (std (y), sqrt (2), sqrt (eps));
+%! assert (std (x, 0, 2), zeros (10, 1));
 
-%!assert(std (ones (3, 1, 2), 0, 2), zeros (3, 1, 2));
-%!assert(std ([1 2], 0), sqrt(2)/2, 5*eps);
-%!assert(std ([1 2], 1), 0.5, 5*eps);
-%!assert(std(1), 0);
-%!assert(std(single(1)), single(0));
-%!assert(std([]), []);
-%!assert(std(ones (1,3,0,2)), ones (1,3,0,2));
+%!assert (std (ones (3, 1, 2), 0, 2), zeros (3, 1, 2));
+%!assert (std ([1 2], 0), sqrt (2)/2, 5*eps);
+%!assert (std ([1 2], 1), 0.5, 5*eps);
+%!assert (std (1), 0);
+%!assert (std (single (1)), single (0));
+%!assert (std ([]), []);
+%!assert (std (ones (1,3,0,2)), ones (1,3,0,2));
 
 %% Test input validation
-%!error std ();
-%!error std (1, 2, 3, 4);
+%!error std ()
+%!error std (1, 2, 3, 4)
 %!error std (['A'; 'B'])
-%!error std (1, -1);
+%!error std (1, -1)
 
diff --git a/scripts/statistics/base/table.m b/scripts/statistics/base/table.m
--- a/scripts/statistics/base/table.m
+++ b/scripts/statistics/base/table.m
@@ -66,8 +66,9 @@ endfunction
 %!error table (1, 2, 3)
 %!error table (ones (2))
 %!error table ([true true])
 %!error table (ones (2,1), true (2,1))
 %!error table (true (2,1), ones (2,1))
 %!error table (ones (2,2), ones (2,1))
 %!error table (ones (2,1), ones (2,2))
 %!error table (ones (2,1), ones (3,1))
+
diff --git a/scripts/statistics/base/var.m b/scripts/statistics/base/var.m
--- a/scripts/statistics/base/var.m
+++ b/scripts/statistics/base/var.m
@@ -101,21 +101,21 @@ function retval = var (x, opt = 0, dim)
     retval = sumsq (center (x, dim), dim) / (n - 1 + opt);
   else
     error ("var: X must not be empty");
   endif
 
 endfunction
 
 
-%!assert(var (13), 0);
-%!assert(var (single(13)), single(0));
-%!assert(var ([1,2,3]), 1);
-%!assert(var ([1,2,3], 1), 2/3, eps);
-%!assert(var ([1,2,3], [], 1), [0,0,0]);
+%!assert (var (13), 0)
+%!assert (var (single (13)), single (0))
+%!assert (var ([1,2,3]), 1)
+%!assert (var ([1,2,3], 1), 2/3, eps)
+%!assert (var ([1,2,3], [], 1), [0,0,0])
 
 %% Test input validation
 %!error var ()
 %!error var (1,2,3,4)
 %!error var (['A'; 'B'])
-%!error var (1, -1);
-%!error var ([],1)
+%!error var (1, -1)
+%!error var ([], 1)
 
diff --git a/scripts/statistics/base/zscore.m b/scripts/statistics/base/zscore.m
--- a/scripts/statistics/base/zscore.m
+++ b/scripts/statistics/base/zscore.m
@@ -84,23 +84,23 @@ function [z, mu, sigma] = zscore (x, opt
     s(s==0) = 1;
     ## FIXME: Use normal broadcasting once we can disable that warning
     z = bsxfun (@rdivide, bsxfun (@minus, x, mu), s);
   endif
 
 endfunction
 
 
-%!assert(zscore ([1,2,3]), [-1,0,1])
-%!assert(zscore (single([1,2,3])), single([-1,0,1]))
-%!assert(zscore (int8([1,2,3])), [-1,0,1])
-%!assert(zscore (ones (3,2,2,2)), zeros (3,2,2,2))
-%!assert(zscore ([2,0,-2;0,2,0;-2,-2,2]), [1,0,-1;0,1,0;-1,-1,1])
+%!assert (zscore ([1,2,3]), [-1,0,1])
+%!assert (zscore (single ([1,2,3])), single ([-1,0,1]))
+%!assert (zscore (int8 ([1,2,3])), [-1,0,1])
+%!assert (zscore (ones (3,2,2,2)), zeros (3,2,2,2))
+%!assert (zscore ([2,0,-2;0,2,0;-2,-2,2]), [1,0,-1;0,1,0;-1,-1,1])
 
 %% Test input validation
 %!error zscore ()
 %!error zscore (1, 2, 3)
 %!error zscore (['A'; 'B'])
-%!error zscore (1, ones(2,2))
+%!error zscore (1, ones (2,2))
 %!error zscore (1, 1.5)
 %!error zscore (1, 1, 0)
 %!error zscore (1, 3)
 
diff --git a/scripts/statistics/distributions/betacdf.m b/scripts/statistics/distributions/betacdf.m
--- a/scripts/statistics/distributions/betacdf.m
+++ b/scripts/statistics/distributions/betacdf.m
@@ -64,30 +64,30 @@ function cdf = betacdf (x, a, b)
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 0.5 1 2];
 %! y = [0 0 0.75 1 1];
-%!assert(betacdf (x, ones(1,5), 2*ones(1,5)), y);
-%!assert(betacdf (x, 1, 2*ones(1,5)), y);
-%!assert(betacdf (x, ones(1,5), 2), y);
-%!assert(betacdf (x, [0 1 NaN 1 1], 2), [NaN 0 NaN 1 1]);
-%!assert(betacdf (x, 1, 2*[0 1 NaN 1 1]), [NaN 0 NaN 1 1]);
-%!assert(betacdf ([x(1:2) NaN x(4:5)], 1, 2), [y(1:2) NaN y(4:5)]);
+%!assert (betacdf (x, ones (1,5), 2*ones (1,5)), y)
+%!assert (betacdf (x, 1, 2*ones (1,5)), y)
+%!assert (betacdf (x, ones (1,5), 2), y)
+%!assert (betacdf (x, [0 1 NaN 1 1], 2), [NaN 0 NaN 1 1])
+%!assert (betacdf (x, 1, 2*[0 1 NaN 1 1]), [NaN 0 NaN 1 1])
+%!assert (betacdf ([x(1:2) NaN x(4:5)], 1, 2), [y(1:2) NaN y(4:5)])
 
 %% Test class of input preserved
-%!assert(betacdf ([x, NaN], 1, 2), [y, NaN]);
-%!assert(betacdf (single([x, NaN]), 1, 2), single([y, NaN]));
-%!assert(betacdf ([x, NaN], single(1), 2), single([y, NaN]));
-%!assert(betacdf ([x, NaN], 1, single(2)), single([y, NaN]));
+%!assert (betacdf ([x, NaN], 1, 2), [y, NaN])
+%!assert (betacdf (single ([x, NaN]), 1, 2), single ([y, NaN]))
+%!assert (betacdf ([x, NaN], single (1), 2), single ([y, NaN]))
+%!assert (betacdf ([x, NaN], 1, single (2)), single ([y, NaN]))
 
 %% Test input validation
 %!error betacdf ()
 %!error betacdf (1)
 %!error betacdf (1,2)
 %!error betacdf (1,2,3,4)
-%!error betacdf (ones(3),ones(2),ones(2))
-%!error betacdf (ones(2),ones(3),ones(2))
-%!error betacdf (ones(2),ones(2),ones(3))
+%!error betacdf (ones (3), ones (2), ones (2))
+%!error betacdf (ones (2), ones (3), ones (2))
+%!error betacdf (ones (2), ones (2), ones (3))
 
diff --git a/scripts/statistics/distributions/betainv.m b/scripts/statistics/distributions/betainv.m
--- a/scripts/statistics/distributions/betainv.m
+++ b/scripts/statistics/distributions/betainv.m
@@ -104,33 +104,33 @@ function inv = betainv (x, a, b)
     inv(k) = y_new;
   endif
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.75 1 2];
-%!assert(betainv (x, ones(1,5), 2*ones(1,5)), [NaN 0 0.5 1 NaN]);
-%!assert(betainv (x, 1, 2*ones(1,5)), [NaN 0 0.5 1 NaN]);
-%!assert(betainv (x, ones(1,5), 2), [NaN 0 0.5 1 NaN]);
-%!assert(betainv (x, [1 0 NaN 1 1], 2), [NaN NaN NaN 1 NaN]);
-%!assert(betainv (x, 1, 2*[1 0 NaN 1 1]), [NaN NaN NaN 1 NaN]);
-%!assert(betainv ([x(1:2) NaN x(4:5)], 1, 2), [NaN 0 NaN 1 NaN]);
+%!assert (betainv (x, ones (1,5), 2*ones (1,5)), [NaN 0 0.5 1 NaN])
+%!assert (betainv (x, 1, 2*ones (1,5)), [NaN 0 0.5 1 NaN])
+%!assert (betainv (x, ones (1,5), 2), [NaN 0 0.5 1 NaN])
+%!assert (betainv (x, [1 0 NaN 1 1], 2), [NaN NaN NaN 1 NaN])
+%!assert (betainv (x, 1, 2*[1 0 NaN 1 1]), [NaN NaN NaN 1 NaN])
+%!assert (betainv ([x(1:2) NaN x(4:5)], 1, 2), [NaN 0 NaN 1 NaN])
 
 %% Test class of input preserved
-%!assert(betainv ([x, NaN], 1, 2), [NaN 0 0.5 1 NaN NaN]);
-%!assert(betainv (single([x, NaN]), 1, 2), single([NaN 0 0.5 1 NaN NaN]));
-%!assert(betainv ([x, NaN], single(1), 2), single([NaN 0 0.5 1 NaN NaN]));
-%!assert(betainv ([x, NaN], 1, single(2)), single([NaN 0 0.5 1 NaN NaN]));
+%!assert (betainv ([x, NaN], 1, 2), [NaN 0 0.5 1 NaN NaN])
+%!assert (betainv (single ([x, NaN]), 1, 2), single ([NaN 0 0.5 1 NaN NaN]))
+%!assert (betainv ([x, NaN], single (1), 2), single ([NaN 0 0.5 1 NaN NaN]))
+%!assert (betainv ([x, NaN], 1, single (2)), single ([NaN 0 0.5 1 NaN NaN]))
 
 %% Test input validation
 %!error betainv ()
 %!error betainv (1)
 %!error betainv (1,2)
 %!error betainv (1,2,3,4)
-%!error betainv (ones(3),ones(2),ones(2))
-%!error betainv (ones(2),ones(3),ones(2))
-%!error betainv (ones(2),ones(2),ones(3))
+%!error betainv (ones (3), ones (2), ones (2))
+%!error betainv (ones (2), ones (3), ones (2))
+%!error betainv (ones (2), ones (2), ones (3))
 %!error betainv (i, 2, 2)
 %!error betainv (2, i, 2)
 %!error betainv (2, 2, i)
 
diff --git a/scripts/statistics/distributions/betapdf.m b/scripts/statistics/distributions/betapdf.m
--- a/scripts/statistics/distributions/betapdf.m
+++ b/scripts/statistics/distributions/betapdf.m
@@ -90,41 +90,41 @@ function pdf = betapdf (x, a, b)
   pdf(k) = Inf;
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 0.5 1 2];
 %! y = [0 2 1 0 0];
-%!assert(betapdf (x, ones(1,5), 2*ones(1,5)), y);
-%!assert(betapdf (x, 1, 2*ones(1,5)), y);
-%!assert(betapdf (x, ones(1,5), 2), y);
-%!assert(betapdf (x, [0 NaN 1 1 1], 2), [NaN NaN y(3:5)]);
-%!assert(betapdf (x, 1, 2*[0 NaN 1 1 1]), [NaN NaN y(3:5)]);
-%!assert(betapdf ([x, NaN], 1, 2), [y, NaN]);
+%!assert (betapdf (x, ones (1,5), 2*ones (1,5)), y)
+%!assert (betapdf (x, 1, 2*ones (1,5)), y)
+%!assert (betapdf (x, ones (1,5), 2), y)
+%!assert (betapdf (x, [0 NaN 1 1 1], 2), [NaN NaN y(3:5)])
+%!assert (betapdf (x, 1, 2*[0 NaN 1 1 1]), [NaN NaN y(3:5)])
+%!assert (betapdf ([x, NaN], 1, 2), [y, NaN])
 
 %% Test class of input preserved
-%!assert(betapdf (single([x, NaN]), 1, 2), single([y, NaN]));
-%!assert(betapdf ([x, NaN], single(1), 2), single([y, NaN]));
-%!assert(betapdf ([x, NaN], 1, single(2)), single([y, NaN]));
+%!assert (betapdf (single ([x, NaN]), 1, 2), single ([y, NaN]))
+%!assert (betapdf ([x, NaN], single (1), 2), single ([y, NaN]))
+%!assert (betapdf ([x, NaN], 1, single (2)), single ([y, NaN]))
 
 %% Beta (1/2,1/2) == arcsine distribution
 %!test
 %! x = rand (10,1);
 %! y = 1./(pi * sqrt (x.*(1-x)));
-%! assert(betapdf (x, 1/2, 1/2), y, 50*eps);
+%! assert (betapdf (x, 1/2, 1/2), y, 50*eps);
 
 %% Test large input values to betapdf
-%!assert (betapdf(0.5, 1000, 1000), 35.678, 1e-3)
+%!assert (betapdf (0.5, 1000, 1000), 35.678, 1e-3)
 
 %% Test input validation
 %!error betapdf ()
 %!error betapdf (1)
 %!error betapdf (1,2)
 %!error betapdf (1,2,3,4)
-%!error betapdf (ones(3),ones(2),ones(2))
-%!error betapdf (ones(2),ones(3),ones(2))
-%!error betapdf (ones(2),ones(2),ones(3))
+%!error betapdf (ones (3), ones (2), ones (2))
+%!error betapdf (ones (2), ones (3), ones (2))
+%!error betapdf (ones (2), ones (2), ones (3))
 %!error betapdf (i, 2, 2)
 %!error betapdf (2, i, 2)
 %!error betapdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/betarnd.m b/scripts/statistics/distributions/betarnd.m
--- a/scripts/statistics/distributions/betarnd.m
+++ b/scripts/statistics/distributions/betarnd.m
@@ -98,40 +98,40 @@ function rnd = betarnd (a, b, varargin)
     k = (a > 0) & (a < Inf) & (b > 0) & (b < Inf);
     r = randg (a(k));
     rnd(k) = r ./ (r + randg (b(k)));
   endif
 
 endfunction
 
 
-%!assert(size (betarnd (1,2)), [1, 1]);
-%!assert(size (betarnd (ones(2,1), 2)), [2, 1]);
-%!assert(size (betarnd (ones(2,2), 2)), [2, 2]);
-%!assert(size (betarnd (1, 2*ones(2,1))), [2, 1]);
-%!assert(size (betarnd (1, 2*ones(2,2))), [2, 2]);
-%!assert(size (betarnd (1, 2, 3)), [3, 3]);
-%!assert(size (betarnd (1, 2, [4 1])), [4, 1]);
-%!assert(size (betarnd (1, 2, 4, 1)), [4, 1]);
+%!assert (size (betarnd (1,2)), [1, 1])
+%!assert (size (betarnd (ones (2,1), 2)), [2, 1])
+%!assert (size (betarnd (ones (2,2), 2)), [2, 2])
+%!assert (size (betarnd (1, 2*ones (2,1))), [2, 1])
+%!assert (size (betarnd (1, 2*ones (2,2))), [2, 2])
+%!assert (size (betarnd (1, 2, 3)), [3, 3])
+%!assert (size (betarnd (1, 2, [4 1])), [4, 1])
+%!assert (size (betarnd (1, 2, 4, 1)), [4, 1])
 
 %% Test class of input preserved
-%!assert(class (betarnd (1, 2)), "double");
-%!assert(class (betarnd (single(1), 2)), "single");
-%!assert(class (betarnd (single([1 1]), 2)), "single");
-%!assert(class (betarnd (1, single(2))), "single");
-%!assert(class (betarnd (1, single([2 2]))), "single");
+%!assert (class (betarnd (1, 2)), "double")
+%!assert (class (betarnd (single (1), 2)), "single")
+%!assert (class (betarnd (single ([1 1]), 2)), "single")
+%!assert (class (betarnd (1, single (2))), "single")
+%!assert (class (betarnd (1, single ([2 2]))), "single")
 
 %% Test input validation
 %!error betarnd ()
 %!error betarnd (1)
-%!error betarnd (ones(3),ones(2))
-%!error betarnd (ones(2),ones(3))
+%!error betarnd (ones (3), ones (2))
+%!error betarnd (ones (2), ones (3))
 %!error betarnd (i, 2)
 %!error betarnd (2, i)
 %!error betarnd (1,2, -1)
-%!error betarnd (1,2, ones(2))
+%!error betarnd (1,2, ones (2))
 %!error binornd (1,2, [2 -1 2])
-%!error betarnd (1,2, 1, ones(2))
+%!error betarnd (1,2, 1, ones (2))
 %!error betarnd (1,2, 1, -1)
-%!error betarnd (ones(2,2), 2, 3)
-%!error betarnd (ones(2,2), 2, [3, 2])
-%!error betarnd (ones(2,2), 2, 2, 3)
+%!error betarnd (ones (2,2), 2, 3)
+%!error betarnd (ones (2,2), 2, [3, 2])
+%!error betarnd (ones (2,2), 2, 2, 3)
 
diff --git a/scripts/statistics/distributions/binocdf.m b/scripts/statistics/distributions/binocdf.m
--- a/scripts/statistics/distributions/binocdf.m
+++ b/scripts/statistics/distributions/binocdf.m
@@ -66,33 +66,33 @@ function cdf = binocdf (x, n, p)
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 1 2 3];
 %! y = [0 1/4 3/4 1 1];
-%!assert(binocdf (x, 2*ones(1,5), 0.5*ones(1,5)), y);
-%!assert(binocdf (x, 2, 0.5*ones(1,5)), y);
-%!assert(binocdf (x, 2*ones(1,5), 0.5), y);
-%!assert(binocdf (x, 2*[0 -1 NaN 1.1 1], 0.5), [0 NaN NaN NaN 1]);
-%!assert(binocdf (x, 2, 0.5*[0 -1 NaN 3 1]), [0 NaN NaN NaN 1]);
-%!assert(binocdf ([x(1:2) NaN x(4:5)], 2, 0.5), [y(1:2) NaN y(4:5)]);
+%!assert (binocdf (x, 2*ones (1,5), 0.5*ones (1,5)), y)
+%!assert (binocdf (x, 2, 0.5*ones (1,5)), y)
+%!assert (binocdf (x, 2*ones (1,5), 0.5), y)
+%!assert (binocdf (x, 2*[0 -1 NaN 1.1 1], 0.5), [0 NaN NaN NaN 1])
+%!assert (binocdf (x, 2, 0.5*[0 -1 NaN 3 1]), [0 NaN NaN NaN 1])
+%!assert (binocdf ([x(1:2) NaN x(4:5)], 2, 0.5), [y(1:2) NaN y(4:5)])
 
 %% Test class of input preserved
-%!assert(binocdf ([x, NaN], 2, 0.5), [y, NaN]);
-%!assert(binocdf (single([x, NaN]), 2, 0.5), single([y, NaN]));
-%!assert(binocdf ([x, NaN], single(2), 0.5), single([y, NaN]));
-%!assert(binocdf ([x, NaN], 2, single(0.5)), single([y, NaN]));
+%!assert (binocdf ([x, NaN], 2, 0.5), [y, NaN])
+%!assert (binocdf (single ([x, NaN]), 2, 0.5), single ([y, NaN]))
+%!assert (binocdf ([x, NaN], single (2), 0.5), single ([y, NaN]))
+%!assert (binocdf ([x, NaN], 2, single (0.5)), single ([y, NaN]))
 
 %% Test input validation
 %!error binocdf ()
 %!error binocdf (1)
 %!error binocdf (1,2)
 %!error binocdf (1,2,3,4)
-%!error binocdf (ones(3),ones(2),ones(2))
-%!error binocdf (ones(2),ones(3),ones(2))
-%!error binocdf (ones(2),ones(2),ones(3))
+%!error binocdf (ones (3), ones (2), ones (2))
+%!error binocdf (ones (2), ones (3), ones (2))
+%!error binocdf (ones (2), ones (2), ones (3))
 %!error binocdf (i, 2, 2)
 %!error binocdf (2, i, 2)
 %!error binocdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/binoinv.m b/scripts/statistics/distributions/binoinv.m
--- a/scripts/statistics/distributions/binoinv.m
+++ b/scripts/statistics/distributions/binoinv.m
@@ -83,33 +83,33 @@ function inv = binoinv (x, n, p)
     endif
   endif
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
-%!assert(binoinv (x, 2*ones(1,5), 0.5*ones(1,5)), [NaN 0 1 2 NaN]);
-%!assert(binoinv (x, 2, 0.5*ones(1,5)), [NaN 0 1 2 NaN]);
-%!assert(binoinv (x, 2*ones(1,5), 0.5), [NaN 0 1 2 NaN]);
-%!assert(binoinv (x, 2*[0 -1 NaN 1.1 1], 0.5), [NaN NaN NaN NaN NaN]);
-%!assert(binoinv (x, 2, 0.5*[0 -1 NaN 3 1]), [NaN NaN NaN NaN NaN]);
-%!assert(binoinv ([x(1:2) NaN x(4:5)], 2, 0.5), [NaN 0 NaN 2 NaN]);
+%!assert (binoinv (x, 2*ones (1,5), 0.5*ones (1,5)), [NaN 0 1 2 NaN])
+%!assert (binoinv (x, 2, 0.5*ones (1,5)), [NaN 0 1 2 NaN])
+%!assert (binoinv (x, 2*ones (1,5), 0.5), [NaN 0 1 2 NaN])
+%!assert (binoinv (x, 2*[0 -1 NaN 1.1 1], 0.5), [NaN NaN NaN NaN NaN])
+%!assert (binoinv (x, 2, 0.5*[0 -1 NaN 3 1]), [NaN NaN NaN NaN NaN])
+%!assert (binoinv ([x(1:2) NaN x(4:5)], 2, 0.5), [NaN 0 NaN 2 NaN])
 
 %% Test class of input preserved
-%!assert(binoinv ([x, NaN], 2, 0.5), [NaN 0 1 2 NaN NaN]);
-%!assert(binoinv (single([x, NaN]), 2, 0.5), single([NaN 0 1 2 NaN NaN]));
-%!assert(binoinv ([x, NaN], single(2), 0.5), single([NaN 0 1 2 NaN NaN]));
-%!assert(binoinv ([x, NaN], 2, single(0.5)), single([NaN 0 1 2 NaN NaN]));
+%!assert (binoinv ([x, NaN], 2, 0.5), [NaN 0 1 2 NaN NaN])
+%!assert (binoinv (single ([x, NaN]), 2, 0.5), single ([NaN 0 1 2 NaN NaN]))
+%!assert (binoinv ([x, NaN], single (2), 0.5), single ([NaN 0 1 2 NaN NaN]))
+%!assert (binoinv ([x, NaN], 2, single (0.5)), single ([NaN 0 1 2 NaN NaN]))
 
 %% Test input validation
 %!error binoinv ()
 %!error binoinv (1)
 %!error binoinv (1,2)
 %!error binoinv (1,2,3,4)
-%!error binoinv (ones(3),ones(2),ones(2))
-%!error binoinv (ones(2),ones(3),ones(2))
-%!error binoinv (ones(2),ones(2),ones(3))
+%!error binoinv (ones (3), ones (2), ones (2))
+%!error binoinv (ones (2), ones (3), ones (2))
+%!error binoinv (ones (2), ones (2), ones (3))
 %!error binoinv (i, 2, 2)
 %!error binoinv (2, i, 2)
 %!error binoinv (2, 2, i)
 
diff --git a/scripts/statistics/distributions/binopdf.m b/scripts/statistics/distributions/binopdf.m
--- a/scripts/statistics/distributions/binopdf.m
+++ b/scripts/statistics/distributions/binopdf.m
@@ -70,32 +70,32 @@ endfunction
 %!shared x,y,tol
 %! if (ismac ())
 %!   tol = eps ();
 %! else
 %!   tol = 0;
 %! endif
 %! x = [-1 0 1 2 3];
 %! y = [0 1/4 1/2 1/4 0];
-%!assert(binopdf (x, 2*ones(1,5), 0.5*ones(1,5)), y, tol);
-%!assert(binopdf (x, 2, 0.5*ones(1,5)), y, tol);
-%!assert(binopdf (x, 2*ones(1,5), 0.5), y, tol);
-%!assert(binopdf (x, 2*[0 -1 NaN 1.1 1], 0.5), [0 NaN NaN NaN 0]);
-%!assert(binopdf (x, 2, 0.5*[0 -1 NaN 3 1]), [0 NaN NaN NaN 0]);
-%!assert(binopdf ([x, NaN], 2, 0.5), [y, NaN], tol);
+%!assert (binopdf (x, 2*ones (1,5), 0.5*ones (1,5)), y, tol)
+%!assert (binopdf (x, 2, 0.5*ones (1,5)), y, tol)
+%!assert (binopdf (x, 2*ones (1,5), 0.5), y, tol)
+%!assert (binopdf (x, 2*[0 -1 NaN 1.1 1], 0.5), [0 NaN NaN NaN 0])
+%!assert (binopdf (x, 2, 0.5*[0 -1 NaN 3 1]), [0 NaN NaN NaN 0])
+%!assert (binopdf ([x, NaN], 2, 0.5), [y, NaN], tol)
 
 %% Test class of input preserved
-%!assert(binopdf (single([x, NaN]), 2, 0.5), single([y, NaN]));
-%!assert(binopdf ([x, NaN], single(2), 0.5), single([y, NaN]));
-%!assert(binopdf ([x, NaN], 2, single(0.5)), single([y, NaN]));
+%!assert (binopdf (single ([x, NaN]), 2, 0.5), single ([y, NaN]))
+%!assert (binopdf ([x, NaN], single (2), 0.5), single ([y, NaN]))
+%!assert (binopdf ([x, NaN], 2, single (0.5)), single ([y, NaN]))
 
 %% Test input validation
 %!error binopdf ()
 %!error binopdf (1)
 %!error binopdf (1,2)
 %!error binopdf (1,2,3,4)
-%!error binopdf (ones(3),ones(2),ones(2))
-%!error binopdf (ones(2),ones(3),ones(2))
-%!error binopdf (ones(2),ones(2),ones(3))
+%!error binopdf (ones (3), ones (2), ones (2))
+%!error binopdf (ones (2), ones (3), ones (2))
+%!error binopdf (ones (2), ones (2), ones (3))
 %!error binopdf (i, 2, 2)
 %!error binopdf (2, i, 2)
 %!error binopdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/binornd.m b/scripts/statistics/distributions/binornd.m
--- a/scripts/statistics/distributions/binornd.m
+++ b/scripts/statistics/distributions/binornd.m
@@ -115,40 +115,40 @@ function rnd = binornd (n, p, varargin)
   endif
 
 endfunction
 
 
 %!assert (binornd (0, 0, 1), 0)
 %!assert (binornd ([0, 0], [0, 0], 1, 2), [0, 0])
 
-%!assert(size (binornd (2, 1/2)), [1, 1]);
-%!assert(size (binornd (2*ones(2,1), 1/2)), [2, 1]);
-%!assert(size (binornd (2*ones(2,2), 1/2)), [2, 2]);
-%!assert(size (binornd (2, 1/2*ones(2,1))), [2, 1]);
-%!assert(size (binornd (2, 1/2*ones(2,2))), [2, 2]);
-%!assert(size (binornd (2, 1/2, 3)), [3, 3]);
-%!assert(size (binornd (2, 1/2, [4 1])), [4, 1]);
-%!assert(size (binornd (2, 1/2, 4, 1)), [4, 1]);
+%!assert (size (binornd (2, 1/2)), [1, 1])
+%!assert (size (binornd (2*ones (2,1), 1/2)), [2, 1])
+%!assert (size (binornd (2*ones (2,2), 1/2)), [2, 2])
+%!assert (size (binornd (2, 1/2*ones (2,1))), [2, 1])
+%!assert (size (binornd (2, 1/2*ones (2,2))), [2, 2])
+%!assert (size (binornd (2, 1/2, 3)), [3, 3])
+%!assert (size (binornd (2, 1/2, [4 1])), [4, 1])
+%!assert (size (binornd (2, 1/2, 4, 1)), [4, 1])
 
 %% Test class of input preserved
-%!assert(class (binornd (2, 0.5)), "double");
-%!assert(class (binornd (single(2), 0.5)), "single");
-%!assert(class (binornd (single([2 2]), 0.5)), "single");
-%!assert(class (binornd (2, single(0.5))), "single");
-%!assert(class (binornd (2, single([0.5 0.5]))), "single");
+%!assert (class (binornd (2, 0.5)), "double")
+%!assert (class (binornd (single (2), 0.5)), "single")
+%!assert (class (binornd (single ([2 2]), 0.5)), "single")
+%!assert (class (binornd (2, single (0.5))), "single")
+%!assert (class (binornd (2, single ([0.5 0.5]))), "single")
 
 %% Test input validation
 %!error binornd ()
 %!error binornd (1)
-%!error binornd (ones(3),ones(2))
-%!error binornd (ones(2),ones(3))
+%!error binornd (ones (3), ones (2))
+%!error binornd (ones (2), ones (3))
 %!error binornd (i, 2)
 %!error binornd (2, i)
 %!error binornd (1,2, -1)
-%!error binornd (1,2, ones(2))
+%!error binornd (1,2, ones (2))
 %!error binornd (1,2, [2 -1 2])
-%!error binornd (1,2, 1, ones(2))
+%!error binornd (1,2, 1, ones (2))
 %!error binornd (1,2, 1, -1)
-%!error binornd (ones(2,2), 2, 3)
-%!error binornd (ones(2,2), 2, [3, 2])
-%!error binornd (ones(2,2), 2, 2, 3)
+%!error binornd (ones (2,2), 2, 3)
+%!error binornd (ones (2,2), 2, [3, 2])
+%!error binornd (ones (2,2), 2, 2, 3)
 
diff --git a/scripts/statistics/distributions/cauchy_cdf.m b/scripts/statistics/distributions/cauchy_cdf.m
--- a/scripts/statistics/distributions/cauchy_cdf.m
+++ b/scripts/statistics/distributions/cauchy_cdf.m
@@ -60,32 +60,32 @@ function cdf = cauchy_cdf (x, location =
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 0.5 1 2];
 %! y = 1/pi * atan ((x-1) / 2) + 1/2;
-%!assert(cauchy_cdf (x, ones(1,5), 2*ones(1,5)), y);
-%!assert(cauchy_cdf (x, 1, 2*ones(1,5)), y);
-%!assert(cauchy_cdf (x, ones(1,5), 2), y);
-%!assert(cauchy_cdf (x, [-Inf 1 NaN 1 Inf], 2), [NaN y(2) NaN y(4) NaN]);
-%!assert(cauchy_cdf (x, 1, 2*[0 1 NaN 1 Inf]), [NaN y(2) NaN y(4) NaN]);
-%!assert(cauchy_cdf ([x(1:2) NaN x(4:5)], 1, 2), [y(1:2) NaN y(4:5)]);
+%!assert (cauchy_cdf (x, ones (1,5), 2*ones (1,5)), y)
+%!assert (cauchy_cdf (x, 1, 2*ones (1,5)), y)
+%!assert (cauchy_cdf (x, ones (1,5), 2), y)
+%!assert (cauchy_cdf (x, [-Inf 1 NaN 1 Inf], 2), [NaN y(2) NaN y(4) NaN])
+%!assert (cauchy_cdf (x, 1, 2*[0 1 NaN 1 Inf]), [NaN y(2) NaN y(4) NaN])
+%!assert (cauchy_cdf ([x(1:2) NaN x(4:5)], 1, 2), [y(1:2) NaN y(4:5)])
 
 %% Test class of input preserved
-%!assert(cauchy_cdf ([x, NaN], 1, 2), [y, NaN]);
-%!assert(cauchy_cdf (single([x, NaN]), 1, 2), single([y, NaN]), eps("single"));
-%!assert(cauchy_cdf ([x, NaN], single(1), 2), single([y, NaN]), eps("single"));
-%!assert(cauchy_cdf ([x, NaN], 1, single(2)), single([y, NaN]), eps("single"));
+%!assert (cauchy_cdf ([x, NaN], 1, 2), [y, NaN])
+%!assert (cauchy_cdf (single ([x, NaN]), 1, 2), single ([y, NaN]), eps ("single"))
+%!assert (cauchy_cdf ([x, NaN], single (1), 2), single ([y, NaN]), eps ("single"))
+%!assert (cauchy_cdf ([x, NaN], 1, single (2)), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error cauchy_cdf ()
 %!error cauchy_cdf (1,2)
 %!error cauchy_cdf (1,2,3,4)
-%!error cauchy_cdf (ones(3),ones(2),ones(2))
-%!error cauchy_cdf (ones(2),ones(3),ones(2))
-%!error cauchy_cdf (ones(2),ones(2),ones(3))
+%!error cauchy_cdf (ones (3), ones (2), ones (2))
+%!error cauchy_cdf (ones (2), ones (3), ones (2))
+%!error cauchy_cdf (ones (2), ones (2), ones (3))
 %!error cauchy_cdf (i, 2, 2)
 %!error cauchy_cdf (2, i, 2)
 %!error cauchy_cdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/cauchy_inv.m b/scripts/statistics/distributions/cauchy_inv.m
--- a/scripts/statistics/distributions/cauchy_inv.m
+++ b/scripts/statistics/distributions/cauchy_inv.m
@@ -67,32 +67,32 @@ function inv = cauchy_inv (x, location =
     inv(k) = location(k) - scale(k) .* cot (pi * x(k));
   endif
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
-%!assert(cauchy_inv (x, ones(1,5), 2*ones(1,5)), [NaN -Inf 1 Inf NaN], eps);
-%!assert(cauchy_inv (x, 1, 2*ones(1,5)), [NaN -Inf 1 Inf NaN], eps);
-%!assert(cauchy_inv (x, ones(1,5), 2), [NaN -Inf 1 Inf NaN], eps);
-%!assert(cauchy_inv (x, [1 -Inf NaN Inf 1], 2), [NaN NaN NaN NaN NaN]);
-%!assert(cauchy_inv (x, 1, 2*[1 0 NaN Inf 1]), [NaN NaN NaN NaN NaN]);
-%!assert(cauchy_inv ([x(1:2) NaN x(4:5)], 1, 2), [NaN -Inf NaN Inf NaN]);
+%!assert (cauchy_inv (x, ones (1,5), 2*ones (1,5)), [NaN -Inf 1 Inf NaN], eps)
+%!assert (cauchy_inv (x, 1, 2*ones (1,5)), [NaN -Inf 1 Inf NaN], eps)
+%!assert (cauchy_inv (x, ones (1,5), 2), [NaN -Inf 1 Inf NaN], eps)
+%!assert (cauchy_inv (x, [1 -Inf NaN Inf 1], 2), [NaN NaN NaN NaN NaN])
+%!assert (cauchy_inv (x, 1, 2*[1 0 NaN Inf 1]), [NaN NaN NaN NaN NaN])
+%!assert (cauchy_inv ([x(1:2) NaN x(4:5)], 1, 2), [NaN -Inf NaN Inf NaN])
 
 %% Test class of input preserved
-%!assert(cauchy_inv ([x, NaN], 1, 2), [NaN -Inf 1 Inf NaN NaN], eps);
-%!assert(cauchy_inv (single([x, NaN]), 1, 2), single([NaN -Inf 1 Inf NaN NaN]), eps("single"));
-%!assert(cauchy_inv ([x, NaN], single(1), 2), single([NaN -Inf 1 Inf NaN NaN]), eps("single"));
-%!assert(cauchy_inv ([x, NaN], 1, single(2)), single([NaN -Inf 1 Inf NaN NaN]), eps("single"));
+%!assert (cauchy_inv ([x, NaN], 1, 2), [NaN -Inf 1 Inf NaN NaN], eps)
+%!assert (cauchy_inv (single ([x, NaN]), 1, 2), single ([NaN -Inf 1 Inf NaN NaN]), eps ("single"))
+%!assert (cauchy_inv ([x, NaN], single (1), 2), single ([NaN -Inf 1 Inf NaN NaN]), eps ("single"))
+%!assert (cauchy_inv ([x, NaN], 1, single (2)), single ([NaN -Inf 1 Inf NaN NaN]), eps ("single"))
 
 %% Test input validation
 %!error cauchy_inv ()
 %!error cauchy_inv (1,2)
 %!error cauchy_inv (1,2,3,4)
-%!error cauchy_inv (ones(3),ones(2),ones(2))
-%!error cauchy_inv (ones(2),ones(3),ones(2))
-%!error cauchy_inv (ones(2),ones(2),ones(3))
+%!error cauchy_inv (ones (3), ones (2), ones (2))
+%!error cauchy_inv (ones (2), ones (3), ones (2))
+%!error cauchy_inv (ones (2), ones (2), ones (3))
 %!error cauchy_inv (i, 2, 2)
 %!error cauchy_inv (2, i, 2)
 %!error cauchy_inv (2, 2, i)
 
diff --git a/scripts/statistics/distributions/cauchy_pdf.m b/scripts/statistics/distributions/cauchy_pdf.m
--- a/scripts/statistics/distributions/cauchy_pdf.m
+++ b/scripts/statistics/distributions/cauchy_pdf.m
@@ -62,36 +62,36 @@ function pdf = cauchy_pdf (x, location =
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 0.5 1 2];
 %! y = 1/pi * ( 2 ./ ((x-1).^2 + 2^2) );
-%!assert(cauchy_pdf (x, ones(1,5), 2*ones(1,5)), y);
-%!assert(cauchy_pdf (x, 1, 2*ones(1,5)), y);
-%!assert(cauchy_pdf (x, ones(1,5), 2), y);
-%!assert(cauchy_pdf (x, [-Inf 1 NaN 1 Inf], 2), [NaN y(2) NaN y(4) NaN]);
-%!assert(cauchy_pdf (x, 1, 2*[0 1 NaN 1 Inf]), [NaN y(2) NaN y(4) NaN]);
-%!assert(cauchy_pdf ([x, NaN], 1, 2), [y, NaN]);
+%!assert (cauchy_pdf (x, ones (1,5), 2*ones (1,5)), y)
+%!assert (cauchy_pdf (x, 1, 2*ones (1,5)), y)
+%!assert (cauchy_pdf (x, ones (1,5), 2), y)
+%!assert (cauchy_pdf (x, [-Inf 1 NaN 1 Inf], 2), [NaN y(2) NaN y(4) NaN])
+%!assert (cauchy_pdf (x, 1, 2*[0 1 NaN 1 Inf]), [NaN y(2) NaN y(4) NaN])
+%!assert (cauchy_pdf ([x, NaN], 1, 2), [y, NaN])
 
 %% Test class of input preserved
-%!assert(cauchy_pdf (single([x, NaN]), 1, 2), single([y, NaN]), eps("single"));
-%!assert(cauchy_pdf ([x, NaN], single(1), 2), single([y, NaN]), eps("single"));
-%!assert(cauchy_pdf ([x, NaN], 1, single(2)), single([y, NaN]), eps("single"));
+%!assert (cauchy_pdf (single ([x, NaN]), 1, 2), single ([y, NaN]), eps ("single"))
+%!assert (cauchy_pdf ([x, NaN], single (1), 2), single ([y, NaN]), eps ("single"))
+%!assert (cauchy_pdf ([x, NaN], 1, single (2)), single ([y, NaN]), eps ("single"))
 
 %% Cauchy (0,1) == Student's T distribution with 1 DOF
 %!test
 %! x = rand (10, 1);
-%! assert(cauchy_pdf (x, 0, 1), tpdf (x, 1), eps);
+%! assert (cauchy_pdf (x, 0, 1), tpdf (x, 1), eps);
 
 %% Test input validation
 %!error cauchy_pdf ()
 %!error cauchy_pdf (1,2)
 %!error cauchy_pdf (1,2,3,4)
-%!error cauchy_pdf (ones(3),ones(2),ones(2))
-%!error cauchy_pdf (ones(2),ones(3),ones(2))
-%!error cauchy_pdf (ones(2),ones(2),ones(3))
+%!error cauchy_pdf (ones (3), ones (2), ones (2))
+%!error cauchy_pdf (ones (2), ones (3), ones (2))
+%!error cauchy_pdf (ones (2), ones (2), ones (3))
 %!error cauchy_pdf (i, 2, 2)
 %!error cauchy_pdf (2, i, 2)
 %!error cauchy_pdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/cauchy_rnd.m b/scripts/statistics/distributions/cauchy_rnd.m
--- a/scripts/statistics/distributions/cauchy_rnd.m
+++ b/scripts/statistics/distributions/cauchy_rnd.m
@@ -93,40 +93,40 @@ function rnd = cauchy_rnd (location, sca
 
     k = !isinf (location) & (scale > 0) & (scale < Inf);
     rnd(k) = location(k)(:) - cot (pi * rand (sum (k(:)), 1)) .* scale(k)(:);
   endif
 
 endfunction
 
 
-%!assert(size (cauchy_rnd (1,2)), [1, 1]);
-%!assert(size (cauchy_rnd (ones(2,1), 2)), [2, 1]);
-%!assert(size (cauchy_rnd (ones(2,2), 2)), [2, 2]);
-%!assert(size (cauchy_rnd (1, 2*ones(2,1))), [2, 1]);
-%!assert(size (cauchy_rnd (1, 2*ones(2,2))), [2, 2]);
-%!assert(size (cauchy_rnd (1, 2, 3)), [3, 3]);
-%!assert(size (cauchy_rnd (1, 2, [4 1])), [4, 1]);
-%!assert(size (cauchy_rnd (1, 2, 4, 1)), [4, 1]);
+%!assert (size (cauchy_rnd (1,2)), [1, 1])
+%!assert (size (cauchy_rnd (ones (2,1), 2)), [2, 1])
+%!assert (size (cauchy_rnd (ones (2,2), 2)), [2, 2])
+%!assert (size (cauchy_rnd (1, 2*ones (2,1))), [2, 1])
+%!assert (size (cauchy_rnd (1, 2*ones (2,2))), [2, 2])
+%!assert (size (cauchy_rnd (1, 2, 3)), [3, 3])
+%!assert (size (cauchy_rnd (1, 2, [4 1])), [4, 1])
+%!assert (size (cauchy_rnd (1, 2, 4, 1)), [4, 1])
 
 %% Test class of input preserved
-%!assert(class (cauchy_rnd (1, 2)), "double");
-%!assert(class (cauchy_rnd (single(1), 2)), "single");
-%!assert(class (cauchy_rnd (single([1 1]), 2)), "single");
-%!assert(class (cauchy_rnd (1, single(2))), "single");
-%!assert(class (cauchy_rnd (1, single([2 2]))), "single");
+%!assert (class (cauchy_rnd (1, 2)), "double")
+%!assert (class (cauchy_rnd (single (1), 2)), "single")
+%!assert (class (cauchy_rnd (single ([1 1]), 2)), "single")
+%!assert (class (cauchy_rnd (1, single (2))), "single")
+%!assert (class (cauchy_rnd (1, single ([2 2]))), "single")
 
 %% Test input validation
 %!error cauchy_rnd ()
 %!error cauchy_rnd (1)
-%!error cauchy_rnd (ones(3),ones(2))
-%!error cauchy_rnd (ones(2),ones(3))
+%!error cauchy_rnd (ones (3), ones (2))
+%!error cauchy_rnd (ones (2), ones (3))
 %!error cauchy_rnd (i, 2)
 %!error cauchy_rnd (2, i)
 %!error cauchy_rnd (1,2, -1)
-%!error cauchy_rnd (1,2, ones(2))
+%!error cauchy_rnd (1,2, ones (2))
 %!error cauchy_rnd (1,2, [2 -1 2])
-%!error cauchy_rnd (1,2, 1, ones(2))
+%!error cauchy_rnd (1,2, 1, ones (2))
 %!error cauchy_rnd (1,2, 1, -1)
-%!error cauchy_rnd (ones(2,2), 2, 3)
-%!error cauchy_rnd (ones(2,2), 2, [3, 2])
-%!error cauchy_rnd (ones(2,2), 2, 2, 3)
+%!error cauchy_rnd (ones (2,2), 2, 3)
+%!error cauchy_rnd (ones (2,2), 2, [3, 2])
+%!error cauchy_rnd (ones (2,2), 2, 2, 3)
 
diff --git a/scripts/statistics/distributions/chi2cdf.m b/scripts/statistics/distributions/chi2cdf.m
--- a/scripts/statistics/distributions/chi2cdf.m
+++ b/scripts/statistics/distributions/chi2cdf.m
@@ -47,27 +47,27 @@ function cdf = chi2cdf (x, n)
   cdf = gamcdf (x, n/2, 2);
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 0.5 1 2];
 %! y = [0, 1 - exp(-x(2:end)/2)];
-%!assert(chi2cdf (x, 2*ones(1,5)), y, eps);
-%!assert(chi2cdf (x, 2), y, eps);
-%!assert(chi2cdf (x, 2*[1 0 NaN 1 1]), [y(1) NaN NaN y(4:5)], eps);
-%!assert(chi2cdf ([x(1:2) NaN x(4:5)], 2), [y(1:2) NaN y(4:5)], eps);
+%!assert (chi2cdf (x, 2*ones (1,5)), y, eps)
+%!assert (chi2cdf (x, 2), y, eps)
+%!assert (chi2cdf (x, 2*[1 0 NaN 1 1]), [y(1) NaN NaN y(4:5)], eps)
+%!assert (chi2cdf ([x(1:2) NaN x(4:5)], 2), [y(1:2) NaN y(4:5)], eps)
 
 %% Test class of input preserved
-%!assert(chi2cdf ([x, NaN], 2), [y, NaN], eps);
-%!assert(chi2cdf (single([x, NaN]), 2), single([y, NaN]), eps("single"));
-%!assert(chi2cdf ([x, NaN], single(2)), single([y, NaN]), eps("single"));
+%!assert (chi2cdf ([x, NaN], 2), [y, NaN], eps)
+%!assert (chi2cdf (single ([x, NaN]), 2), single ([y, NaN]), eps ("single"))
+%!assert (chi2cdf ([x, NaN], single (2)), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error chi2cdf ()
 %!error chi2cdf (1)
 %!error chi2cdf (1,2,3)
-%!error chi2cdf (ones(3),ones(2))
-%!error chi2cdf (ones(2),ones(3))
+%!error chi2cdf (ones (3), ones (2))
+%!error chi2cdf (ones (2), ones (3))
 %!error chi2cdf (i, 2)
 %!error chi2cdf (2, i)
 
diff --git a/scripts/statistics/distributions/chi2inv.m b/scripts/statistics/distributions/chi2inv.m
--- a/scripts/statistics/distributions/chi2inv.m
+++ b/scripts/statistics/distributions/chi2inv.m
@@ -46,27 +46,27 @@ function inv = chi2inv (x, n)
 
   inv = gaminv (x, n/2, 2);
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.3934693402873666 1 2];
-%!assert(chi2inv (x, 2*ones(1,5)), [NaN 0 1 Inf NaN], 5*eps);
-%!assert(chi2inv (x, 2), [NaN 0 1 Inf NaN], 5*eps);
-%!assert(chi2inv (x, 2*[0 1 NaN 1 1]), [NaN 0 NaN Inf NaN], 5*eps);
-%!assert(chi2inv ([x(1:2) NaN x(4:5)], 2), [NaN 0 NaN Inf NaN], 5*eps);
+%!assert (chi2inv (x, 2*ones (1,5)), [NaN 0 1 Inf NaN], 5*eps)
+%!assert (chi2inv (x, 2), [NaN 0 1 Inf NaN], 5*eps)
+%!assert (chi2inv (x, 2*[0 1 NaN 1 1]), [NaN 0 NaN Inf NaN], 5*eps)
+%!assert (chi2inv ([x(1:2) NaN x(4:5)], 2), [NaN 0 NaN Inf NaN], 5*eps)
 
 %% Test class of input preserved
-%!assert(chi2inv ([x, NaN], 2), [NaN 0 1 Inf NaN NaN], 5*eps);
-%!assert(chi2inv (single([x, NaN]), 2), single([NaN 0 1 Inf NaN NaN]), 5*eps("single"));
-%!assert(chi2inv ([x, NaN], single(2)), single([NaN 0 1 Inf NaN NaN]), 5*eps("single"));
+%!assert (chi2inv ([x, NaN], 2), [NaN 0 1 Inf NaN NaN], 5*eps)
+%!assert (chi2inv (single ([x, NaN]), 2), single ([NaN 0 1 Inf NaN NaN]), 5*eps ("single"))
+%!assert (chi2inv ([x, NaN], single (2)), single ([NaN 0 1 Inf NaN NaN]), 5*eps ("single"))
 
 %% Test input validation
 %!error chi2inv ()
 %!error chi2inv (1)
 %!error chi2inv (1,2,3)
-%!error chi2inv (ones(3),ones(2))
-%!error chi2inv (ones(2),ones(3))
+%!error chi2inv (ones (3), ones (2))
+%!error chi2inv (ones (2), ones (3))
 %!error chi2inv (i, 2)
 %!error chi2inv (2, i)
 
diff --git a/scripts/statistics/distributions/chi2pdf.m b/scripts/statistics/distributions/chi2pdf.m
--- a/scripts/statistics/distributions/chi2pdf.m
+++ b/scripts/statistics/distributions/chi2pdf.m
@@ -47,26 +47,26 @@ function pdf = chi2pdf (x, n)
   pdf = gampdf (x, n/2, 2);
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 0.5 1 Inf];
 %! y = [0, 1/2 * exp(-x(2:5)/2)];
-%!assert(chi2pdf (x, 2*ones(1,5)), y);
-%!assert(chi2pdf (x, 2), y);
-%!assert(chi2pdf (x, 2*[1 0 NaN 1 1]), [y(1) NaN NaN y(4:5)]);
-%!assert(chi2pdf ([x, NaN], 2), [y, NaN]);
+%!assert (chi2pdf (x, 2*ones (1,5)), y)
+%!assert (chi2pdf (x, 2), y)
+%!assert (chi2pdf (x, 2*[1 0 NaN 1 1]), [y(1) NaN NaN y(4:5)])
+%!assert (chi2pdf ([x, NaN], 2), [y, NaN])
 
 %% Test class of input preserved
-%!assert(chi2pdf (single([x, NaN]), 2), single([y, NaN]));
-%!assert(chi2pdf ([x, NaN], single(2)), single([y, NaN]));
+%!assert (chi2pdf (single ([x, NaN]), 2), single ([y, NaN]))
+%!assert (chi2pdf ([x, NaN], single (2)), single ([y, NaN]))
 
 %% Test input validation
 %!error chi2pdf ()
 %!error chi2pdf (1)
 %!error chi2pdf (1,2,3)
-%!error chi2pdf (ones(3),ones(2))
-%!error chi2pdf (ones(2),ones(3))
+%!error chi2pdf (ones (3), ones (2))
+%!error chi2pdf (ones (2), ones (3))
 %!error chi2pdf (i, 2)
 %!error chi2pdf (2, i)
 
diff --git a/scripts/statistics/distributions/chi2rnd.m b/scripts/statistics/distributions/chi2rnd.m
--- a/scripts/statistics/distributions/chi2rnd.m
+++ b/scripts/statistics/distributions/chi2rnd.m
@@ -89,32 +89,32 @@ function rnd = chi2rnd (n, varargin)
 
     k = (n > 0) | (n < Inf);
     rnd(k) = 2 * randg (n(k)/2);
   endif
 
 endfunction
 
 
-%!assert(size (chi2rnd (2)), [1, 1]);
-%!assert(size (chi2rnd (ones(2,1))), [2, 1]);
-%!assert(size (chi2rnd (ones(2,2))), [2, 2]);
-%!assert(size (chi2rnd (1, 3)), [3, 3]);
-%!assert(size (chi2rnd (1, [4 1])), [4, 1]);
-%!assert(size (chi2rnd (1, 4, 1)), [4, 1]);
+%!assert (size (chi2rnd (2)), [1, 1])
+%!assert (size (chi2rnd (ones (2,1))), [2, 1])
+%!assert (size (chi2rnd (ones (2,2))), [2, 2])
+%!assert (size (chi2rnd (1, 3)), [3, 3])
+%!assert (size (chi2rnd (1, [4 1])), [4, 1])
+%!assert (size (chi2rnd (1, 4, 1)), [4, 1])
 
 %% Test class of input preserved
-%!assert(class (chi2rnd (2)), "double");
-%!assert(class (chi2rnd (single(2))), "single");
-%!assert(class (chi2rnd (single([2 2]))), "single");
+%!assert (class (chi2rnd (2)), "double")
+%!assert (class (chi2rnd (single (2))), "single")
+%!assert (class (chi2rnd (single ([2 2]))), "single")
 
 %% Test input validation
 %!error chi2rnd ()
-%!error chi2rnd (ones(3),ones(2))
-%!error chi2rnd (ones(2),ones(3))
+%!error chi2rnd (ones (3), ones (2))
+%!error chi2rnd (ones (2), ones (3))
 %!error chi2rnd (i)
 %!error chi2rnd (1, -1)
-%!error chi2rnd (1, ones(2))
+%!error chi2rnd (1, ones (2))
 %!error chi2rnd (1, [2 -1 2])
-%!error chi2rnd (ones(2,2), 3)
-%!error chi2rnd (ones(2,2), [3, 2])
-%!error chi2rnd (ones(2,2), 2, 3)
+%!error chi2rnd (ones (2,2), 3)
+%!error chi2rnd (ones (2,2), [3, 2])
+%!error chi2rnd (ones (2,2), 2, 3)
 
diff --git a/scripts/statistics/distributions/discrete_cdf.m b/scripts/statistics/distributions/discrete_cdf.m
--- a/scripts/statistics/distributions/discrete_cdf.m
+++ b/scripts/statistics/distributions/discrete_cdf.m
@@ -53,29 +53,29 @@ function cdf = discrete_cdf (x, v, p)
   cdf(k) = [0 ; cumsum(p(vi))](lookup (vs, x(k)) + 1);
 
 endfunction
 
 
 %!shared x,v,p,y
 %! x = [-1 0.1 1.1 1.9 3];
 %! v = 0.1:0.2:1.9;
-%! p = 1/length(v) * ones(1, length(v));
+%! p = 1/length(v) * ones (1, length(v));
 %! y = [0 0.1 0.6 1 1];
-%!assert(discrete_cdf ([x, NaN], v, p), [y, NaN], eps);
+%!assert (discrete_cdf ([x, NaN], v, p), [y, NaN], eps)
 
 %% Test class of input preserved
-%!assert(discrete_cdf (single([x, NaN]), v, p), single([y, NaN]), 2*eps("single"));
-%!assert(discrete_cdf ([x, NaN], single(v), p), single([y, NaN]), 2*eps("single"));
-%!assert(discrete_cdf ([x, NaN], v, single(p)), single([y, NaN]), 2*eps("single"));
+%!assert (discrete_cdf (single ([x, NaN]), v, p), single ([y, NaN]), 2*eps ("single"))
+%!assert (discrete_cdf ([x, NaN], single (v), p), single ([y, NaN]), 2*eps ("single"))
+%!assert (discrete_cdf ([x, NaN], v, single (p)), single ([y, NaN]), 2*eps ("single"))
 
 %% Test input validation
 %!error discrete_cdf ()
 %!error discrete_cdf (1)
 %!error discrete_cdf (1,2)
 %!error discrete_cdf (1,2,3,4)
-%!error discrete_cdf (1, ones(2), ones(2,1))
-%!error discrete_cdf (1, [1 ; NaN], ones(2,1))
-%!error discrete_cdf (1, ones(2,1), ones(1,1))
-%!error discrete_cdf (1, ones(2,1), [1 -1])
-%!error discrete_cdf (1, ones(2,1), [1 NaN])
-%!error discrete_cdf (1, ones(2,1), [0  0])
+%!error discrete_cdf (1, ones (2), ones (2,1))
+%!error discrete_cdf (1, [1 ; NaN], ones (2,1))
+%!error discrete_cdf (1, ones (2,1), ones (1,1))
+%!error discrete_cdf (1, ones (2,1), [1 -1])
+%!error discrete_cdf (1, ones (2,1), [1 NaN])
+%!error discrete_cdf (1, ones (2,1), [0  0])
 
diff --git a/scripts/statistics/distributions/discrete_inv.m b/scripts/statistics/distributions/discrete_inv.m
--- a/scripts/statistics/distributions/discrete_inv.m
+++ b/scripts/statistics/distributions/discrete_inv.m
@@ -68,28 +68,28 @@ function inv = discrete_inv (x, v, p)
   inv(k) = v(length (p) - lookup (sort (p, "descend"), x(k)) + 1);
 
 endfunction
 
 
 %!shared x,v,p,y
 %! x = [-1 0 0.1 0.5 1 2];
 %! v = 0.1:0.2:1.9;
-%! p = 1/length(v) * ones(1, length(v));
+%! p = 1/length(v) * ones (1, length(v));
 %! y = [NaN v(1) v(1) v(end/2) v(end) NaN];
-%!assert(discrete_inv ([x, NaN], v, p), [y, NaN], eps);
+%!assert (discrete_inv ([x, NaN], v, p), [y, NaN], eps)
 
 %% Test class of input preserved
-%!assert(discrete_inv (single([x, NaN]), v, p), single([y, NaN]), eps("single"));
-%!assert(discrete_inv ([x, NaN], single(v), p), single([y, NaN]), eps("single"));
-%!assert(discrete_inv ([x, NaN], v, single(p)), single([y, NaN]), eps("single"));
+%!assert (discrete_inv (single ([x, NaN]), v, p), single ([y, NaN]), eps ("single"))
+%!assert (discrete_inv ([x, NaN], single (v), p), single ([y, NaN]), eps ("single"))
+%!assert (discrete_inv ([x, NaN], v, single (p)), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error discrete_inv ()
 %!error discrete_inv (1)
 %!error discrete_inv (1,2)
 %!error discrete_inv (1,2,3,4)
-%!error discrete_inv (1, ones(2), ones(2,1))
-%!error discrete_inv (1, ones(2,1), ones(1,1))
-%!error discrete_inv (1, ones(2,1), [1 NaN])
-%!error discrete_inv (1, ones(2,1), [1 -1])
-%!error discrete_inv (1, ones(2,1), [0  0])
+%!error discrete_inv (1, ones (2), ones (2,1))
+%!error discrete_inv (1, ones (2,1), ones (1,1))
+%!error discrete_inv (1, ones (2,1), [1 NaN])
+%!error discrete_inv (1, ones (2,1), [1 -1])
+%!error discrete_inv (1, ones (2,1), [0  0])
 
diff --git a/scripts/statistics/distributions/discrete_pdf.m b/scripts/statistics/distributions/discrete_pdf.m
--- a/scripts/statistics/distributions/discrete_pdf.m
+++ b/scripts/statistics/distributions/discrete_pdf.m
@@ -57,29 +57,29 @@ function pdf = discrete_pdf (x, v, p)
   pdf(k) = p([0 ; vi](lookup (vs, x(k), 'm') + 1) + 1);
 
 endfunction
 
 
 %!shared x,v,p,y
 %! x = [-1 0.1 1.1 1.9 3];
 %! v = 0.1:0.2:1.9;
-%! p = 1/length(v) * ones(1, length(v));
+%! p = 1/length (v) * ones (1, length (v));
 %! y = [0 0.1 0.1 0.1 0];
-%!assert(discrete_pdf ([x, NaN], v, p), [y, NaN], 5*eps);
+%!assert (discrete_pdf ([x, NaN], v, p), [y, NaN], 5*eps)
 
 %% Test class of input preserved
-%!assert(discrete_pdf (single([x, NaN]), v, p), single([y, NaN]), 5*eps("single"));
-%!assert(discrete_pdf ([x, NaN], single(v), p), single([y, NaN]), 5*eps("single"));
-%!assert(discrete_pdf ([x, NaN], v, single(p)), single([y, NaN]), 5*eps("single"));
+%!assert (discrete_pdf (single ([x, NaN]), v, p), single ([y, NaN]), 5*eps ("single"))
+%!assert (discrete_pdf ([x, NaN], single (v), p), single ([y, NaN]), 5*eps ("single"))
+%!assert (discrete_pdf ([x, NaN], v, single (p)), single ([y, NaN]), 5*eps ("single"))
 
 %% Test input validation
 %!error discrete_pdf ()
 %!error discrete_pdf (1)
 %!error discrete_pdf (1,2)
 %!error discrete_pdf (1,2,3,4)
-%!error discrete_pdf (1, ones(2), ones(2,1))
-%!error discrete_pdf (1, [1 ; NaN], ones(2,1))
-%!error discrete_pdf (1, ones(2,1), ones(1,1))
-%!error discrete_pdf (1, ones(2,1), [1 -1])
-%!error discrete_pdf (1, ones(2,1), [1 NaN])
-%!error discrete_pdf (1, ones(2,1), [0  0])
+%!error discrete_pdf (1, ones (2), ones (2,1))
+%!error discrete_pdf (1, [1 ; NaN], ones (2,1))
+%!error discrete_pdf (1, ones (2,1), ones (1,1))
+%!error discrete_pdf (1, ones (2,1), [1 -1])
+%!error discrete_pdf (1, ones (2,1), [1 NaN])
+%!error discrete_pdf (1, ones (2,1), [0  0])
 
diff --git a/scripts/statistics/distributions/discrete_rnd.m b/scripts/statistics/distributions/discrete_rnd.m
--- a/scripts/statistics/distributions/discrete_rnd.m
+++ b/scripts/statistics/distributions/discrete_rnd.m
@@ -72,33 +72,33 @@ function rnd = discrete_rnd (v, p, varar
   endif
 
   rnd = v(lookup (cumsum (p(1:end-1)) / sum (p), rand (sz)) + 1);
   rnd = reshape (rnd, sz);
 
 endfunction
 
 
-%!assert(size (discrete_rnd (1:2, 1:2, 3)), [3, 3]);
-%!assert(size (discrete_rnd (1:2, 1:2, [4 1])), [4, 1]);
-%!assert(size (discrete_rnd (1:2, 1:2, 4, 1)), [4, 1]);
+%!assert (size (discrete_rnd (1:2, 1:2, 3)), [3, 3])
+%!assert (size (discrete_rnd (1:2, 1:2, [4 1])), [4, 1])
+%!assert (size (discrete_rnd (1:2, 1:2, 4, 1)), [4, 1])
 
 %% Test class of input preserved
-%!assert(class (discrete_rnd (1:2, 1:2)), "double");
-%!assert(class (discrete_rnd (single(1:2), 1:2)), "single");
+%!assert (class (discrete_rnd (1:2, 1:2)), "double")
+%!assert (class (discrete_rnd (single (1:2), 1:2)), "single")
 ## FIXME: Maybe this should work, maybe it shouldn't.
 #%!assert(class (discrete_rnd (1:2, single(1:2))), "single");
 
 %% Test input validation
 %!error discrete_rnd ()
 %!error discrete_rnd (1)
 %!error discrete_rnd (1:2,1:2, -1)
-%!error discrete_rnd (1:2,1:2, ones(2))
+%!error discrete_rnd (1:2,1:2, ones (2))
 %!error discrete_rnd (1:2,1:2, [2 -1 2])
-%!error discrete_rnd (1:2,1:2, 1, ones(2))
+%!error discrete_rnd (1:2,1:2, 1, ones (2))
 %!error discrete_rnd (1:2,1:2, 1, -1)
 %% test v,p verification
-%!error discrete_rnd (1, ones(2), ones(2,1))
-%!error discrete_rnd (1, ones(2,1), ones(1,1))
-%!error discrete_rnd (1, ones(2,1), [1 -1])
-%!error discrete_rnd (1, ones(2,1), [1 NaN])
-%!error discrete_rnd (1, ones(2,1), [0  0])
+%!error discrete_rnd (1, ones (2), ones (2,1))
+%!error discrete_rnd (1, ones (2,1), ones (1,1))
+%!error discrete_rnd (1, ones (2,1), [1 -1])
+%!error discrete_rnd (1, ones (2,1), [1 NaN])
+%!error discrete_rnd (1, ones (2,1), [0  0])
 
diff --git a/scripts/statistics/distributions/empirical_cdf.m b/scripts/statistics/distributions/empirical_cdf.m
--- a/scripts/statistics/distributions/empirical_cdf.m
+++ b/scripts/statistics/distributions/empirical_cdf.m
@@ -41,22 +41,22 @@ function cdf = empirical_cdf (x, data)
 
 endfunction
 
 
 %!shared x,v,y
 %! x = [-1 0.1 1.1 1.9 3];
 %! v = 0.1:0.2:1.9;
 %! y = [0 0.1 0.6 1 1];
-%!assert(empirical_cdf (x, v), y, eps);
-%!assert(empirical_cdf ([x(1) NaN x(3:5)], v), [0 NaN 0.6 1 1], eps);
+%!assert (empirical_cdf (x, v), y, eps)
+%!assert (empirical_cdf ([x(1) NaN x(3:5)], v), [0 NaN 0.6 1 1], eps)
 
 %% Test class of input preserved
-%!assert(empirical_cdf ([x, NaN], v), [y, NaN], eps);
-%!assert(empirical_cdf (single([x, NaN]), v), single([y, NaN]), eps);
-%!assert(empirical_cdf ([x, NaN], single(v)), single([y, NaN]), eps);
+%!assert (empirical_cdf ([x, NaN], v), [y, NaN], eps)
+%!assert (empirical_cdf (single ([x, NaN]), v), single ([y, NaN]), eps)
+%!assert (empirical_cdf ([x, NaN], single (v)), single ([y, NaN]), eps)
 
 %% Test input validation
 %!error empirical_cdf ()
 %!error empirical_cdf (1)
 %!error empirical_cdf (1,2,3)
-%!error empirical_cdf (1, ones(2))
+%!error empirical_cdf (1, ones (2))
 
diff --git a/scripts/statistics/distributions/empirical_inv.m b/scripts/statistics/distributions/empirical_inv.m
--- a/scripts/statistics/distributions/empirical_inv.m
+++ b/scripts/statistics/distributions/empirical_inv.m
@@ -41,21 +41,21 @@ function inv = empirical_inv (x, data)
 
 endfunction
 
 
 %!shared x,v,y
 %! x = [-1 0 0.1 0.5 1 2];
 %! v = 0.1:0.2:1.9;
 %! y = [NaN v(1) v(1) v(end/2) v(end) NaN];
-%!assert(empirical_inv (x, v), y, eps);
+%!assert (empirical_inv (x, v), y, eps)
 
 %% Test class of input preserved
-%!assert(empirical_inv ([x, NaN], v), [y, NaN], eps);
-%!assert(empirical_inv (single([x, NaN]), v), single([y, NaN]), eps);
-%!assert(empirical_inv ([x, NaN], single(v)), single([y, NaN]), eps);
+%!assert (empirical_inv ([x, NaN], v), [y, NaN], eps)
+%!assert (empirical_inv (single ([x, NaN]), v), single ([y, NaN]), eps)
+%!assert (empirical_inv ([x, NaN], single (v)), single ([y, NaN]), eps)
 
 %% Test input validation
 %!error empirical_inv ()
 %!error empirical_inv (1)
 %!error empirical_inv (1,2,3)
-%!error empirical_inv (1, ones(2))
+%!error empirical_inv (1, ones (2))
 
diff --git a/scripts/statistics/distributions/empirical_pdf.m b/scripts/statistics/distributions/empirical_pdf.m
--- a/scripts/statistics/distributions/empirical_pdf.m
+++ b/scripts/statistics/distributions/empirical_pdf.m
@@ -41,20 +41,20 @@ function pdf = empirical_pdf (x, data)
 
 endfunction
 
 
 %!shared x,v,y
 %! x = [-1 0.1 1.1 1.9 3];
 %! v = 0.1:0.2:1.9;
 %! y = [0 0.1 0.1 0.1 0];
-%!assert(empirical_pdf (x, v), y);
+%!assert (empirical_pdf (x, v), y)
 
 %% Test class of input preserved
-%!assert(empirical_pdf (single(x), v), single (y));
-%!assert(empirical_pdf (x, single(v)), single (y));
+%!assert (empirical_pdf (single (x), v), single (y))
+%!assert (empirical_pdf (x, single (v)), single (y))
 
 %% Test input validation
 %!error empirical_pdf ()
 %!error empirical_pdf (1)
 %!error empirical_pdf (1,2,3)
-%!error empirical_inv (1, ones(2))
+%!error empirical_inv (1, ones (2))
 
diff --git a/scripts/statistics/distributions/empirical_rnd.m b/scripts/statistics/distributions/empirical_rnd.m
--- a/scripts/statistics/distributions/empirical_rnd.m
+++ b/scripts/statistics/distributions/empirical_rnd.m
@@ -48,22 +48,22 @@ function rnd = empirical_rnd (data, vara
     error ("empirical_rnd: DATA must be a vector");
   endif
 
   rnd = discrete_rnd (data, ones (size (data)), varargin{:});
 
 endfunction
 
 
-%!assert(size (empirical_rnd (ones (3, 1))), [3, 1]);
-%!assert(size (empirical_rnd (1:2, [4 1])), [4, 1]);
-%!assert(size (empirical_rnd (1:2, 4, 1)), [4, 1]);
+%!assert (size (empirical_rnd (ones (3, 1))), [3, 1])
+%!assert (size (empirical_rnd (1:2, [4 1])), [4, 1])
+%!assert (size (empirical_rnd (1:2, 4, 1)), [4, 1])
 
 %% Test class of input preserved
-%!assert(class (empirical_rnd (1:2, 1)), "double");
-%!assert(class (empirical_rnd (single(1:2), 1)), "single");
+%!assert (class (empirical_rnd (1:2, 1)), "double")
+%!assert (class (empirical_rnd (single (1:2), 1)), "single")
 
 %% Test input validation
 %!error empirical_rnd ()
-%!error empirical_rnd (ones(2), 1)
+%!error empirical_rnd (ones (2), 1)
 %% test data verification
-%!error empirical_rnd (ones(2), 1, 1)
+%!error empirical_rnd (ones (2), 1, 1)
 
diff --git a/scripts/statistics/distributions/expcdf.m b/scripts/statistics/distributions/expcdf.m
--- a/scripts/statistics/distributions/expcdf.m
+++ b/scripts/statistics/distributions/expcdf.m
@@ -66,26 +66,26 @@ function cdf = expcdf (x, lambda)
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 0.5 1 Inf];
 %! y = [0, 1 - exp(-x(2:end)/2)];
-%!assert(expcdf (x, 2*ones(1,5)), y);
-%!assert(expcdf (x, 2), y);
-%!assert(expcdf (x, 2*[1 0 NaN 1 1]), [y(1) NaN NaN y(4:5)]);
+%!assert (expcdf (x, 2*ones (1,5)), y)
+%!assert (expcdf (x, 2), y)
+%!assert (expcdf (x, 2*[1 0 NaN 1 1]), [y(1) NaN NaN y(4:5)])
 
 %% Test class of input preserved
-%!assert(expcdf ([x, NaN], 2), [y, NaN]);
-%!assert(expcdf (single([x, NaN]), 2), single([y, NaN]));
-%!assert(expcdf ([x, NaN], single(2)), single([y, NaN]));
+%!assert (expcdf ([x, NaN], 2), [y, NaN])
+%!assert (expcdf (single ([x, NaN]), 2), single ([y, NaN]))
+%!assert (expcdf ([x, NaN], single (2)), single ([y, NaN]))
 
 %% Test input validation
 %!error expcdf ()
 %!error expcdf (1)
 %!error expcdf (1,2,3)
-%!error expcdf (ones(3),ones(2))
-%!error expcdf (ones(2),ones(3))
+%!error expcdf (ones (3), ones (2))
+%!error expcdf (ones (2), ones (3))
 %!error expcdf (i, 2)
 %!error expcdf (2, i)
 
diff --git a/scripts/statistics/distributions/expinv.m b/scripts/statistics/distributions/expinv.m
--- a/scripts/statistics/distributions/expinv.m
+++ b/scripts/statistics/distributions/expinv.m
@@ -69,27 +69,27 @@ function inv = expinv (x, lambda)
     inv(k) = - lambda(k) .* log (1 - x(k));
   endif
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.3934693402873666 1 2];
-%!assert(expinv (x, 2*ones(1,5)), [NaN 0 1 Inf NaN], eps);
-%!assert(expinv (x, 2), [NaN 0 1 Inf NaN], eps);
-%!assert(expinv (x, 2*[1 0 NaN 1 1]), [NaN NaN NaN Inf NaN], eps);
-%!assert(expinv ([x(1:2) NaN x(4:5)], 2), [NaN 0 NaN Inf NaN], eps);
+%!assert (expinv (x, 2*ones (1,5)), [NaN 0 1 Inf NaN], eps)
+%!assert (expinv (x, 2), [NaN 0 1 Inf NaN], eps)
+%!assert (expinv (x, 2*[1 0 NaN 1 1]), [NaN NaN NaN Inf NaN], eps)
+%!assert (expinv ([x(1:2) NaN x(4:5)], 2), [NaN 0 NaN Inf NaN], eps)
 
 %% Test class of input preserved
-%!assert(expinv ([x, NaN], 2), [NaN 0 1 Inf NaN NaN], eps);
-%!assert(expinv (single([x, NaN]), 2), single([NaN 0 1 Inf NaN NaN]), eps);
-%!assert(expinv ([x, NaN], single(2)), single([NaN 0 1 Inf NaN NaN]), eps);
+%!assert (expinv ([x, NaN], 2), [NaN 0 1 Inf NaN NaN], eps)
+%!assert (expinv (single ([x, NaN]), 2), single ([NaN 0 1 Inf NaN NaN]), eps)
+%!assert (expinv ([x, NaN], single (2)), single ([NaN 0 1 Inf NaN NaN]), eps)
 
 %% Test input validation
 %!error expinv ()
 %!error expinv (1)
 %!error expinv (1,2,3)
-%!error expinv (ones(3),ones(2))
-%!error expinv (ones(2),ones(3))
+%!error expinv (ones (3), ones (2))
+%!error expinv (ones (2), ones (3))
 %!error expinv (i, 2)
 %!error expinv (2, i)
 
diff --git a/scripts/statistics/distributions/exppdf.m b/scripts/statistics/distributions/exppdf.m
--- a/scripts/statistics/distributions/exppdf.m
+++ b/scripts/statistics/distributions/exppdf.m
@@ -60,25 +60,25 @@ function pdf = exppdf (x, lambda)
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 0.5 1 Inf];
 %! y = gampdf (x, 1, 2);
-%!assert(exppdf (x, 2*ones(1,5)), y);
-%!assert(exppdf (x, 2*[1 0 NaN 1 1]), [y(1) NaN NaN y(4:5)]);
-%!assert(exppdf ([x, NaN], 2), [y, NaN]);
+%!assert (exppdf (x, 2*ones (1,5)), y)
+%!assert (exppdf (x, 2*[1 0 NaN 1 1]), [y(1) NaN NaN y(4:5)])
+%!assert (exppdf ([x, NaN], 2), [y, NaN])
 
 %% Test class of input preserved
-%!assert(exppdf (single([x, NaN]), 2), single([y, NaN]));
-%!assert(exppdf ([x, NaN], single(2)), single([y, NaN]));
+%!assert (exppdf (single ([x, NaN]), 2), single ([y, NaN]))
+%!assert (exppdf ([x, NaN], single (2)), single ([y, NaN]))
 
 %% Test input validation
 %!error exppdf ()
 %!error exppdf (1)
 %!error exppdf (1,2,3)
-%!error exppdf (ones(3),ones(2))
-%!error exppdf (ones(2),ones(3))
+%!error exppdf (ones (3), ones (2))
+%!error exppdf (ones (2), ones (3))
 %!error exppdf (i, 2)
 %!error exppdf (2, i)
 
diff --git a/scripts/statistics/distributions/exprnd.m b/scripts/statistics/distributions/exprnd.m
--- a/scripts/statistics/distributions/exprnd.m
+++ b/scripts/statistics/distributions/exprnd.m
@@ -86,32 +86,32 @@ function rnd = exprnd (lambda, varargin)
 
     k = (lambda > 0) & (lambda < Inf);
     rnd(k) = rande (sum (k(:)), 1) .* lambda(k)(:);
   endif
 
 endfunction
 
 
-%!assert(size (exprnd (2)), [1, 1]);
-%!assert(size (exprnd (ones(2,1))), [2, 1]);
-%!assert(size (exprnd (ones(2,2))), [2, 2]);
-%!assert(size (exprnd (1, 3)), [3, 3]);
-%!assert(size (exprnd (1, [4 1])), [4, 1]);
-%!assert(size (exprnd (1, 4, 1)), [4, 1]);
+%!assert (size (exprnd (2)), [1, 1])
+%!assert (size (exprnd (ones (2,1))), [2, 1])
+%!assert (size (exprnd (ones (2,2))), [2, 2])
+%!assert (size (exprnd (1, 3)), [3, 3])
+%!assert (size (exprnd (1, [4 1])), [4, 1])
+%!assert (size (exprnd (1, 4, 1)), [4, 1])
 
 %% Test class of input preserved
-%!assert(class (exprnd (1)), "double");
-%!assert(class (exprnd (single(1))), "single");
-%!assert(class (exprnd (single([1 1]))), "single");
+%!assert (class (exprnd (1)), "double")
+%!assert (class (exprnd (single (1))), "single")
+%!assert (class (exprnd (single ([1 1]))), "single")
 
 %% Test input validation
 %!error exprnd ()
 %!error exprnd (1, -1)
-%!error exprnd (1, ones(2))
+%!error exprnd (1, ones (2))
 %!error exprnd (i)
 %!error exprnd (1, [2 -1 2])
 %!error exprnd (1, 2, -1)
-%!error exprnd (1, 2, ones(2))
-%!error exprnd (ones(2,2), 3)
-%!error exprnd (ones(2,2), [3, 2])
-%!error exprnd (ones(2,2), 2, 3)
+%!error exprnd (1, 2, ones (2))
+%!error exprnd (ones (2,2), 3)
+%!error exprnd (ones (2,2), [3, 2])
+%!error exprnd (ones (2,2), 2, 3)
 
diff --git a/scripts/statistics/distributions/fcdf.m b/scripts/statistics/distributions/fcdf.m
--- a/scripts/statistics/distributions/fcdf.m
+++ b/scripts/statistics/distributions/fcdf.m
@@ -64,33 +64,33 @@ function cdf = fcdf (x, m, n)
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 0.5 1 2 Inf];
 %! y = [0 0 1/3 1/2 2/3 1];
-%!assert(fcdf (x, 2*ones(1,6), 2*ones(1,6)), y, eps);
-%!assert(fcdf (x, 2, 2*ones(1,6)), y, eps);
-%!assert(fcdf (x, 2*ones(1,6), 2), y, eps);
-%!assert(fcdf (x, [0 NaN Inf 2 2 2], 2), [NaN NaN NaN y(4:6)], eps);
-%!assert(fcdf (x, 2, [0 NaN Inf 2 2 2]), [NaN NaN NaN y(4:6)], eps);
-%!assert(fcdf ([x(1:2) NaN x(4:6)], 2, 2), [y(1:2) NaN y(4:6)], eps);
+%!assert (fcdf (x, 2*ones (1,6), 2*ones (1,6)), y, eps)
+%!assert (fcdf (x, 2, 2*ones (1,6)), y, eps)
+%!assert (fcdf (x, 2*ones (1,6), 2), y, eps)
+%!assert (fcdf (x, [0 NaN Inf 2 2 2], 2), [NaN NaN NaN y(4:6)], eps)
+%!assert (fcdf (x, 2, [0 NaN Inf 2 2 2]), [NaN NaN NaN y(4:6)], eps)
+%!assert (fcdf ([x(1:2) NaN x(4:6)], 2, 2), [y(1:2) NaN y(4:6)], eps)
 
 %% Test class of input preserved
-%!assert(fcdf ([x, NaN], 2, 2), [y, NaN], eps);
-%!assert(fcdf (single([x, NaN]), 2, 2), single([y, NaN]), eps("single"));
-%!assert(fcdf ([x, NaN], single(2), 2), single([y, NaN]), eps("single"));
-%!assert(fcdf ([x, NaN], 2, single(2)), single([y, NaN]), eps("single"));
+%!assert (fcdf ([x, NaN], 2, 2), [y, NaN], eps)
+%!assert (fcdf (single ([x, NaN]), 2, 2), single ([y, NaN]), eps ("single"))
+%!assert (fcdf ([x, NaN], single (2), 2), single ([y, NaN]), eps ("single"))
+%!assert (fcdf ([x, NaN], 2, single (2)), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error fcdf ()
 %!error fcdf (1)
 %!error fcdf (1,2)
 %!error fcdf (1,2,3,4)
-%!error fcdf (ones(3),ones(2),ones(2))
-%!error fcdf (ones(2),ones(3),ones(2))
-%!error fcdf (ones(2),ones(2),ones(3))
+%!error fcdf (ones (3), ones (2), ones (2))
+%!error fcdf (ones (2), ones (3), ones (2))
+%!error fcdf (ones (2), ones (2), ones (3))
 %!error fcdf (i, 2, 2)
 %!error fcdf (2, i, 2)
 %!error fcdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/finv.m b/scripts/statistics/distributions/finv.m
--- a/scripts/statistics/distributions/finv.m
+++ b/scripts/statistics/distributions/finv.m
@@ -61,33 +61,33 @@ function inv = finv (x, m, n)
               .* n(k) ./ m(k));
   endif
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
-%!assert(finv (x, 2*ones(1,5), 2*ones(1,5)), [NaN 0 1 Inf NaN]);
-%!assert(finv (x, 2, 2*ones(1,5)), [NaN 0 1 Inf NaN]);
-%!assert(finv (x, 2*ones(1,5), 2), [NaN 0 1 Inf NaN]);
-%!assert(finv (x, [2 -Inf NaN Inf 2], 2), [NaN NaN NaN NaN NaN]);
-%!assert(finv (x, 2, [2 -Inf NaN Inf 2]), [NaN NaN NaN NaN NaN]);
-%!assert(finv ([x(1:2) NaN x(4:5)], 2, 2), [NaN 0 NaN Inf NaN]);
+%!assert (finv (x, 2*ones (1,5), 2*ones (1,5)), [NaN 0 1 Inf NaN])
+%!assert (finv (x, 2, 2*ones (1,5)), [NaN 0 1 Inf NaN])
+%!assert (finv (x, 2*ones (1,5), 2), [NaN 0 1 Inf NaN])
+%!assert (finv (x, [2 -Inf NaN Inf 2], 2), [NaN NaN NaN NaN NaN])
+%!assert (finv (x, 2, [2 -Inf NaN Inf 2]), [NaN NaN NaN NaN NaN])
+%!assert (finv ([x(1:2) NaN x(4:5)], 2, 2), [NaN 0 NaN Inf NaN])
 
 %% Test class of input preserved
-%!assert(finv ([x, NaN], 2, 2), [NaN 0 1 Inf NaN NaN]);
-%!assert(finv (single([x, NaN]), 2, 2), single([NaN 0 1 Inf NaN NaN]));
-%!assert(finv ([x, NaN], single(2), 2), single([NaN 0 1 Inf NaN NaN]));
-%!assert(finv ([x, NaN], 2, single(2)), single([NaN 0 1 Inf NaN NaN]));
+%!assert (finv ([x, NaN], 2, 2), [NaN 0 1 Inf NaN NaN])
+%!assert (finv (single ([x, NaN]), 2, 2), single ([NaN 0 1 Inf NaN NaN]))
+%!assert (finv ([x, NaN], single (2), 2), single ([NaN 0 1 Inf NaN NaN]))
+%!assert (finv ([x, NaN], 2, single (2)), single ([NaN 0 1 Inf NaN NaN]))
 
 %% Test input validation
 %!error finv ()
 %!error finv (1)
 %!error finv (1,2)
 %!error finv (1,2,3,4)
-%!error finv (ones(3),ones(2),ones(2))
-%!error finv (ones(2),ones(3),ones(2))
-%!error finv (ones(2),ones(2),ones(3))
+%!error finv (ones (3), ones (2), ones (2))
+%!error finv (ones (2), ones (3), ones (2))
+%!error finv (ones (2), ones (2), ones (3))
 %!error finv (i, 2, 2)
 %!error finv (2, i, 2)
 %!error finv (2, 2, i)
 
diff --git a/scripts/statistics/distributions/fpdf.m b/scripts/statistics/distributions/fpdf.m
--- a/scripts/statistics/distributions/fpdf.m
+++ b/scripts/statistics/distributions/fpdf.m
@@ -69,37 +69,37 @@ function pdf = fpdf (x, m, n)
 endfunction
 
 
 %% F (x, 1, m) == T distribution (sqrt (x), m) / sqrt (x)
 %!test
 %! x = rand (10,1);
 %! x = x(x > 0.1 & x < 0.9);
 %! y = tpdf (sqrt (x), 2) ./ sqrt (x);
-%! assert(fpdf (x, 1, 2), y, 5*eps);
+%! assert (fpdf (x, 1, 2), y, 5*eps);
 
 %!shared x,y
 %! x = [-1 0 0.5 1 2];
 %! y = [0 0 4/9 1/4 1/9];
-%!assert(fpdf (x, 2*ones(1,5), 2*ones(1,5)), y, eps);
-%!assert(fpdf (x, 2, 2*ones(1,5)), y, eps);
-%!assert(fpdf (x, 2*ones(1,5), 2), y, eps);
-%!assert(fpdf (x, [0 NaN Inf 2 2], 2), [NaN NaN NaN y(4:5)], eps);
-%!assert(fpdf (x, 2, [0 NaN Inf 2 2]), [NaN NaN NaN y(4:5)], eps);
-%!assert(fpdf ([x, NaN], 2, 2), [y, NaN], eps);
+%!assert (fpdf (x, 2*ones (1,5), 2*ones (1,5)), y, eps)
+%!assert (fpdf (x, 2, 2*ones (1,5)), y, eps)
+%!assert (fpdf (x, 2*ones (1,5), 2), y, eps)
+%!assert (fpdf (x, [0 NaN Inf 2 2], 2), [NaN NaN NaN y(4:5)], eps)
+%!assert (fpdf (x, 2, [0 NaN Inf 2 2]), [NaN NaN NaN y(4:5)], eps)
+%!assert (fpdf ([x, NaN], 2, 2), [y, NaN], eps)
 
 %% Test class of input preserved
-%!assert(fpdf (single([x, NaN]), 2, 2), single([y, NaN]), eps("single"));
-%!assert(fpdf ([x, NaN], single(2), 2), single([y, NaN]), eps("single"));
-%!assert(fpdf ([x, NaN], 2, single(2)), single([y, NaN]), eps("single"));
+%!assert (fpdf (single ([x, NaN]), 2, 2), single ([y, NaN]), eps ("single"))
+%!assert (fpdf ([x, NaN], single (2), 2), single ([y, NaN]), eps ("single"))
+%!assert (fpdf ([x, NaN], 2, single (2)), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error fpdf ()
 %!error fpdf (1)
 %!error fpdf (1,2)
 %!error fpdf (1,2,3,4)
-%!error fpdf (ones(3),ones(2),ones(2))
-%!error fpdf (ones(2),ones(3),ones(2))
-%!error fpdf (ones(2),ones(2),ones(3))
+%!error fpdf (ones (3), ones (2), ones (2))
+%!error fpdf (ones (2), ones (3), ones (2))
+%!error fpdf (ones (2), ones (2), ones (3))
 %!error fpdf (i, 2, 2)
 %!error fpdf (2, i, 2)
 %!error fpdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/frnd.m b/scripts/statistics/distributions/frnd.m
--- a/scripts/statistics/distributions/frnd.m
+++ b/scripts/statistics/distributions/frnd.m
@@ -93,40 +93,40 @@ function rnd = frnd (m, n, varargin)
 
     k = (m > 0) & (m < Inf) & (n > 0) & (n < Inf);
     rnd(k) = n(k) ./ m(k) .* randg (m(k)/2) ./ randg (n(k)/2);
   endif
 
 endfunction
 
 
-%!assert(size (frnd (1,2)), [1, 1]);
-%!assert(size (frnd (ones(2,1), 2)), [2, 1]);
-%!assert(size (frnd (ones(2,2), 2)), [2, 2]);
-%!assert(size (frnd (1, 2*ones(2,1))), [2, 1]);
-%!assert(size (frnd (1, 2*ones(2,2))), [2, 2]);
-%!assert(size (frnd (1, 2, 3)), [3, 3]);
-%!assert(size (frnd (1, 2, [4 1])), [4, 1]);
-%!assert(size (frnd (1, 2, 4, 1)), [4, 1]);
+%!assert (size (frnd (1,2)), [1, 1])
+%!assert (size (frnd (ones (2,1), 2)), [2, 1])
+%!assert (size (frnd (ones (2,2), 2)), [2, 2])
+%!assert (size (frnd (1, 2*ones (2,1))), [2, 1])
+%!assert (size (frnd (1, 2*ones (2,2))), [2, 2])
+%!assert (size (frnd (1, 2, 3)), [3, 3])
+%!assert (size (frnd (1, 2, [4 1])), [4, 1])
+%!assert (size (frnd (1, 2, 4, 1)), [4, 1])
 
 %% Test class of input preserved
-%!assert(class (frnd (1, 2)), "double");
-%!assert(class (frnd (single(1), 2)), "single");
-%!assert(class (frnd (single([1 1]), 2)), "single");
-%!assert(class (frnd (1, single(2))), "single");
-%!assert(class (frnd (1, single([2 2]))), "single");
+%!assert (class (frnd (1, 2)), "double")
+%!assert (class (frnd (single (1), 2)), "single")
+%!assert (class (frnd (single ([1 1]), 2)), "single")
+%!assert (class (frnd (1, single (2))), "single")
+%!assert (class (frnd (1, single ([2 2]))), "single")
 
 %% Test input validation
 %!error frnd ()
 %!error frnd (1)
-%!error frnd (ones(3),ones(2))
-%!error frnd (ones(2),ones(3))
+%!error frnd (ones (3), ones (2))
+%!error frnd (ones (2), ones (3))
 %!error frnd (i, 2)
 %!error frnd (2, i)
 %!error frnd (1,2, -1)
-%!error frnd (1,2, ones(2))
+%!error frnd (1,2, ones (2))
 %!error frnd (1, 2, [2 -1 2])
-%!error frnd (1,2, 1, ones(2))
+%!error frnd (1,2, 1, ones (2))
 %!error frnd (1,2, 1, -1)
-%!error frnd (ones(2,2), 2, 3)
-%!error frnd (ones(2,2), 2, [3, 2])
-%!error frnd (ones(2,2), 2, 2, 3)
+%!error frnd (ones (2,2), 2, 3)
+%!error frnd (ones (2,2), 2, [3, 2])
+%!error frnd (ones (2,2), 2, 2, 3)
 
diff --git a/scripts/statistics/distributions/gamcdf.m b/scripts/statistics/distributions/gamcdf.m
--- a/scripts/statistics/distributions/gamcdf.m
+++ b/scripts/statistics/distributions/gamcdf.m
@@ -61,31 +61,31 @@ function cdf = gamcdf (x, a, b)
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 0.5 1 2 Inf];
 %! y = [0, gammainc(x(2:end), 1)];
-%!assert(gamcdf (x, ones(1,6), ones(1,6)), y);
-%!assert(gamcdf (x, 1, ones(1,6)), y);
-%!assert(gamcdf (x, ones(1,6), 1), y);
-%!assert(gamcdf (x, [0 -Inf NaN Inf 1 1], 1), [NaN NaN NaN NaN y(5:6)]);
-%!assert(gamcdf (x, 1, [0 -Inf NaN Inf 1 1]), [NaN NaN NaN NaN y(5:6)]);
-%!assert(gamcdf ([x(1:2) NaN x(4:6)], 1, 1), [y(1:2) NaN y(4:6)]);
+%!assert (gamcdf (x, ones (1,6), ones (1,6)), y)
+%!assert (gamcdf (x, 1, ones (1,6)), y)
+%!assert (gamcdf (x, ones (1,6), 1), y)
+%!assert (gamcdf (x, [0 -Inf NaN Inf 1 1], 1), [NaN NaN NaN NaN y(5:6)])
+%!assert (gamcdf (x, 1, [0 -Inf NaN Inf 1 1]), [NaN NaN NaN NaN y(5:6)])
+%!assert (gamcdf ([x(1:2) NaN x(4:6)], 1, 1), [y(1:2) NaN y(4:6)])
 
 %% Test class of input preserved
-%!assert(gamcdf ([x, NaN], 1, 1), [y, NaN]);
-%!assert(gamcdf (single([x, NaN]), 1, 1), single([y, NaN]), eps("single"));
+%!assert (gamcdf ([x, NaN], 1, 1), [y, NaN])
+%!assert (gamcdf (single ([x, NaN]), 1, 1), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error gamcdf ()
 %!error gamcdf (1)
 %!error gamcdf (1,2)
 %!error gamcdf (1,2,3,4)
-%!error gamcdf (ones(3),ones(2),ones(2))
-%!error gamcdf (ones(2),ones(3),ones(2))
-%!error gamcdf (ones(2),ones(2),ones(3))
+%!error gamcdf (ones (3), ones (2), ones (2))
+%!error gamcdf (ones (2), ones (3), ones (2))
+%!error gamcdf (ones (2), ones (2), ones (3))
 %!error gamcdf (i, 2, 2)
 %!error gamcdf (2, i, 2)
 %!error gamcdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/gaminv.m b/scripts/statistics/distributions/gaminv.m
--- a/scripts/statistics/distributions/gaminv.m
+++ b/scripts/statistics/distributions/gaminv.m
@@ -97,33 +97,33 @@ function inv = gaminv (x, a, b)
     inv(k) = y_new;
   endif
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.63212055882855778 1 2];
-%!assert(gaminv (x, ones(1,5), ones(1,5)), [NaN 0 1 Inf NaN], eps);
-%!assert(gaminv (x, 1, ones(1,5)), [NaN 0 1 Inf NaN], eps);
-%!assert(gaminv (x, ones(1,5), 1), [NaN 0 1 Inf NaN], eps);
-%!assert(gaminv (x, [1 -Inf NaN Inf 1], 1), [NaN NaN NaN NaN NaN]);
-%!assert(gaminv (x, 1, [1 -Inf NaN Inf 1]), [NaN NaN NaN NaN NaN]);
-%!assert(gaminv ([x(1:2) NaN x(4:5)], 1, 1), [NaN 0 NaN Inf NaN]);
+%!assert (gaminv (x, ones (1,5), ones (1,5)), [NaN 0 1 Inf NaN], eps)
+%!assert (gaminv (x, 1, ones (1,5)), [NaN 0 1 Inf NaN], eps)
+%!assert (gaminv (x, ones (1,5), 1), [NaN 0 1 Inf NaN], eps)
+%!assert (gaminv (x, [1 -Inf NaN Inf 1], 1), [NaN NaN NaN NaN NaN])
+%!assert (gaminv (x, 1, [1 -Inf NaN Inf 1]), [NaN NaN NaN NaN NaN])
+%!assert (gaminv ([x(1:2) NaN x(4:5)], 1, 1), [NaN 0 NaN Inf NaN])
 
 %% Test class of input preserved
-%!assert(gaminv ([x, NaN], 1, 1), [NaN 0 1 Inf NaN NaN], eps);
-%!assert(gaminv (single([x, NaN]), 1, 1), single([NaN 0 1 Inf NaN NaN]), eps("single"));
-%!assert(gaminv ([x, NaN], single(1), 1), single([NaN 0 1 Inf NaN NaN]), eps("single"));
-%!assert(gaminv ([x, NaN], 1, single(1)), single([NaN 0 1 Inf NaN NaN]), eps("single"));
+%!assert (gaminv ([x, NaN], 1, 1), [NaN 0 1 Inf NaN NaN], eps)
+%!assert (gaminv (single ([x, NaN]), 1, 1), single ([NaN 0 1 Inf NaN NaN]), eps ("single"))
+%!assert (gaminv ([x, NaN], single (1), 1), single ([NaN 0 1 Inf NaN NaN]), eps ("single"))
+%!assert (gaminv ([x, NaN], 1, single (1)), single ([NaN 0 1 Inf NaN NaN]), eps ("single"))
 
 %% Test input validation
 %!error gaminv ()
 %!error gaminv (1)
 %!error gaminv (1,2)
 %!error gaminv (1,2,3,4)
-%!error gaminv (ones(3),ones(2),ones(2))
-%!error gaminv (ones(2),ones(3),ones(2))
-%!error gaminv (ones(2),ones(2),ones(3))
+%!error gaminv (ones (3), ones (2), ones (2))
+%!error gaminv (ones (2), ones (3), ones (2))
+%!error gaminv (ones (2), ones (2), ones (3))
 %!error gaminv (i, 2, 2)
 %!error gaminv (2, i, 2)
 %!error gaminv (2, 2, i)
 
diff --git a/scripts/statistics/distributions/gampdf.m b/scripts/statistics/distributions/gampdf.m
--- a/scripts/statistics/distributions/gampdf.m
+++ b/scripts/statistics/distributions/gampdf.m
@@ -72,32 +72,32 @@ function pdf = gampdf (x, a, b)
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 0.5 1 Inf];
 %! y = [0 exp(-x(2:end))];
-%!assert(gampdf (x, ones(1,5), ones(1,5)), y);
-%!assert(gampdf (x, 1, ones(1,5)), y);
-%!assert(gampdf (x, ones(1,5), 1), y);
-%!assert(gampdf (x, [0 -Inf NaN Inf 1], 1), [NaN NaN NaN NaN y(5)]);
-%!assert(gampdf (x, 1, [0 -Inf NaN Inf 1]), [NaN NaN NaN 0 y(5)]);
-%!assert(gampdf ([x, NaN], 1, 1), [y, NaN]);
+%!assert (gampdf (x, ones (1,5), ones (1,5)), y)
+%!assert (gampdf (x, 1, ones (1,5)), y)
+%!assert (gampdf (x, ones (1,5), 1), y)
+%!assert (gampdf (x, [0 -Inf NaN Inf 1], 1), [NaN NaN NaN NaN y(5)])
+%!assert (gampdf (x, 1, [0 -Inf NaN Inf 1]), [NaN NaN NaN 0 y(5)])
+%!assert (gampdf ([x, NaN], 1, 1), [y, NaN])
 
 %% Test class of input preserved
-%!assert(gampdf (single([x, NaN]), 1, 1), single([y, NaN]));
-%!assert(gampdf ([x, NaN], single(1), 1), single([y, NaN]));
-%!assert(gampdf ([x, NaN], 1, single(1)), single([y, NaN]));
+%!assert (gampdf (single ([x, NaN]), 1, 1), single ([y, NaN]))
+%!assert (gampdf ([x, NaN], single (1), 1), single ([y, NaN]))
+%!assert (gampdf ([x, NaN], 1, single (1)), single ([y, NaN]))
 
 %% Test input validation
 %!error gampdf ()
 %!error gampdf (1)
 %!error gampdf (1,2)
 %!error gampdf (1,2,3,4)
-%!error gampdf (ones(3),ones(2),ones(2))
-%!error gampdf (ones(2),ones(3),ones(2))
-%!error gampdf (ones(2),ones(2),ones(3))
+%!error gampdf (ones (3), ones (2), ones (2))
+%!error gampdf (ones (2), ones (3), ones (2))
+%!error gampdf (ones (2), ones (2), ones (3))
 %!error gampdf (i, 2, 2)
 %!error gampdf (2, i, 2)
 %!error gampdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/gamrnd.m b/scripts/statistics/distributions/gamrnd.m
--- a/scripts/statistics/distributions/gamrnd.m
+++ b/scripts/statistics/distributions/gamrnd.m
@@ -96,40 +96,40 @@ function rnd = gamrnd (a, b, varargin)
 
     k = (a > 0) & (a < Inf) & (b > 0) & (b < Inf);
     rnd(k) = b(k) .* randg (a(k));
   endif
 
 endfunction
 
 
-%!assert(size (gamrnd (1,2)), [1, 1]);
-%!assert(size (gamrnd (ones(2,1), 2)), [2, 1]);
-%!assert(size (gamrnd (ones(2,2), 2)), [2, 2]);
-%!assert(size (gamrnd (1, 2*ones(2,1))), [2, 1]);
-%!assert(size (gamrnd (1, 2*ones(2,2))), [2, 2]);
-%!assert(size (gamrnd (1, 2, 3)), [3, 3]);
-%!assert(size (gamrnd (1, 2, [4 1])), [4, 1]);
-%!assert(size (gamrnd (1, 2, 4, 1)), [4, 1]);
+%!assert (size (gamrnd (1,2)), [1, 1])
+%!assert (size (gamrnd (ones (2,1), 2)), [2, 1])
+%!assert (size (gamrnd (ones (2,2), 2)), [2, 2])
+%!assert (size (gamrnd (1, 2*ones (2,1))), [2, 1])
+%!assert (size (gamrnd (1, 2*ones (2,2))), [2, 2])
+%!assert (size (gamrnd (1, 2, 3)), [3, 3])
+%!assert (size (gamrnd (1, 2, [4 1])), [4, 1])
+%!assert (size (gamrnd (1, 2, 4, 1)), [4, 1])
 
 %% Test class of input preserved
-%!assert(class (gamrnd (1, 2)), "double");
-%!assert(class (gamrnd (single(1), 2)), "single");
-%!assert(class (gamrnd (single([1 1]), 2)), "single");
-%!assert(class (gamrnd (1, single(2))), "single");
-%!assert(class (gamrnd (1, single([2 2]))), "single");
+%!assert (class (gamrnd (1, 2)), "double")
+%!assert (class (gamrnd (single (1), 2)), "single")
+%!assert (class (gamrnd (single ([1 1]), 2)), "single")
+%!assert (class (gamrnd (1, single (2))), "single")
+%!assert (class (gamrnd (1, single ([2 2]))), "single")
 
 %% Test input validation
 %!error gamrnd ()
 %!error gamrnd (1)
-%!error gamrnd (ones(3),ones(2))
-%!error gamrnd (ones(2),ones(3))
+%!error gamrnd (ones (3), ones (2))
+%!error gamrnd (ones (2), ones (3))
 %!error gamrnd (i, 2)
 %!error gamrnd (2, i)
 %!error gamrnd (1,2, -1)
-%!error gamrnd (1,2, ones(2))
+%!error gamrnd (1,2, ones (2))
 %!error gamrnd (1, 2, [2 -1 2])
-%!error gamrnd (1,2, 1, ones(2))
+%!error gamrnd (1,2, 1, ones (2))
 %!error gamrnd (1,2, 1, -1)
-%!error gamrnd (ones(2,2), 2, 3)
-%!error gamrnd (ones(2,2), 2, [3, 2])
-%!error gamrnd (ones(2,2), 2, 2, 3)
+%!error gamrnd (ones (2,2), 2, 3)
+%!error gamrnd (ones (2,2), 2, [3, 2])
+%!error gamrnd (ones (2,2), 2, 2, 3)
 
diff --git a/scripts/statistics/distributions/geocdf.m b/scripts/statistics/distributions/geocdf.m
--- a/scripts/statistics/distributions/geocdf.m
+++ b/scripts/statistics/distributions/geocdf.m
@@ -63,27 +63,27 @@ function cdf = geocdf (x, p)
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 1 Inf];
 %! y = [0 0.5 0.75 1];
-%!assert(geocdf (x, 0.5*ones(1,4)), y);
-%!assert(geocdf (x, 0.5), y);
-%!assert(geocdf (x, 0.5*[-1 NaN 4 1]), [NaN NaN NaN y(4)]);
-%!assert(geocdf ([x(1:2) NaN x(4)], 0.5), [y(1:2) NaN y(4)]);
+%!assert (geocdf (x, 0.5*ones (1,4)), y)
+%!assert (geocdf (x, 0.5), y)
+%!assert (geocdf (x, 0.5*[-1 NaN 4 1]), [NaN NaN NaN y(4)])
+%!assert (geocdf ([x(1:2) NaN x(4)], 0.5), [y(1:2) NaN y(4)])
 
 %% Test class of input preserved
-%!assert(geocdf ([x, NaN], 0.5), [y, NaN]);
-%!assert(geocdf (single([x, NaN]), 0.5), single([y, NaN]));
-%!assert(geocdf ([x, NaN], single(0.5)), single([y, NaN]));
+%!assert (geocdf ([x, NaN], 0.5), [y, NaN])
+%!assert (geocdf (single ([x, NaN]), 0.5), single ([y, NaN]))
+%!assert (geocdf ([x, NaN], single (0.5)), single ([y, NaN]))
 
 %% Test input validation
 %!error geocdf ()
 %!error geocdf (1)
 %!error geocdf (1,2,3)
-%!error geocdf (ones(3),ones(2))
-%!error geocdf (ones(2),ones(3))
+%!error geocdf (ones (3), ones (2))
+%!error geocdf (ones (2), ones (3))
 %!error geocdf (i, 2)
 %!error geocdf (2, i)
 
diff --git a/scripts/statistics/distributions/geoinv.m b/scripts/statistics/distributions/geoinv.m
--- a/scripts/statistics/distributions/geoinv.m
+++ b/scripts/statistics/distributions/geoinv.m
@@ -59,27 +59,27 @@ function inv = geoinv (x, p)
     inv(k) = max (ceil (log (1 - x(k)) ./ log (1 - p(k))) - 1, 0);
   endif
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.75 1 2];
-%!assert(geoinv (x, 0.5*ones(1,5)), [NaN 0 1 Inf NaN]);
-%!assert(geoinv (x, 0.5), [NaN 0 1 Inf NaN]);
-%!assert(geoinv (x, 0.5*[1 -1 NaN 4 1]), [NaN NaN NaN NaN NaN]);
-%!assert(geoinv ([x(1:2) NaN x(4:5)], 0.5), [NaN 0 NaN Inf NaN]);
+%!assert (geoinv (x, 0.5*ones (1,5)), [NaN 0 1 Inf NaN])
+%!assert (geoinv (x, 0.5), [NaN 0 1 Inf NaN])
+%!assert (geoinv (x, 0.5*[1 -1 NaN 4 1]), [NaN NaN NaN NaN NaN])
+%!assert (geoinv ([x(1:2) NaN x(4:5)], 0.5), [NaN 0 NaN Inf NaN])
 
 %% Test class of input preserved
-%!assert(geoinv ([x, NaN], 0.5), [NaN 0 1 Inf NaN NaN]);
-%!assert(geoinv (single([x, NaN]), 0.5), single([NaN 0 1 Inf NaN NaN]));
-%!assert(geoinv ([x, NaN], single(0.5)), single([NaN 0 1 Inf NaN NaN]));
+%!assert (geoinv ([x, NaN], 0.5), [NaN 0 1 Inf NaN NaN])
+%!assert (geoinv (single ([x, NaN]), 0.5), single ([NaN 0 1 Inf NaN NaN]))
+%!assert (geoinv ([x, NaN], single (0.5)), single ([NaN 0 1 Inf NaN NaN]))
 
 %% Test input validation
 %!error geoinv ()
 %!error geoinv (1)
 %!error geoinv (1,2,3)
-%!error geoinv (ones(3),ones(2))
-%!error geoinv (ones(2),ones(3))
+%!error geoinv (ones (3), ones (2))
+%!error geoinv (ones (2), ones (3))
 %!error geoinv (i, 2)
 %!error geoinv (2, i)
 
diff --git a/scripts/statistics/distributions/geopdf.m b/scripts/statistics/distributions/geopdf.m
--- a/scripts/statistics/distributions/geopdf.m
+++ b/scripts/statistics/distributions/geopdf.m
@@ -60,26 +60,26 @@ function pdf = geopdf (x, p)
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 1 Inf];
 %! y = [0, 1/2, 1/4, NaN];
-%!assert(geopdf (x, 0.5*ones(1,4)), y);
-%!assert(geopdf (x, 0.5), y);
-%!assert(geopdf (x, 0.5*[-1 NaN 4 1]), [NaN NaN NaN y(4)]);
-%!assert(geopdf ([x, NaN], 0.5), [y, NaN]);
+%!assert (geopdf (x, 0.5*ones (1,4)), y)
+%!assert (geopdf (x, 0.5), y)
+%!assert (geopdf (x, 0.5*[-1 NaN 4 1]), [NaN NaN NaN y(4)])
+%!assert (geopdf ([x, NaN], 0.5), [y, NaN])
 
 %% Test class of input preserved
-%!assert(geopdf (single([x, NaN]), 0.5), single([y, NaN]), 5*eps("single"));
-%!assert(geopdf ([x, NaN], single(0.5)), single([y, NaN]), 5*eps("single"));
+%!assert (geopdf (single ([x, NaN]), 0.5), single ([y, NaN]), 5*eps ("single"))
+%!assert (geopdf ([x, NaN], single (0.5)), single ([y, NaN]), 5*eps ("single"))
 
 %% Test input validation
 %!error geopdf ()
 %!error geopdf (1)
 %!error geopdf (1,2,3)
-%!error geopdf (ones(3),ones(2))
-%!error geopdf (ones(2),ones(3))
+%!error geopdf (ones (3), ones (2))
+%!error geopdf (ones (2), ones (3))
 %!error geopdf (i, 2)
 %!error geopdf (2, i)
 
diff --git a/scripts/statistics/distributions/geornd.m b/scripts/statistics/distributions/geornd.m
--- a/scripts/statistics/distributions/geornd.m
+++ b/scripts/statistics/distributions/geornd.m
@@ -93,33 +93,33 @@ function rnd = geornd (p, varargin)
 
     k = (p == 0);
     rnd(k) = Inf;
   endif
 
 endfunction
 
 
-%!assert(size (geornd (0.5)), [1, 1]);
-%!assert(size (geornd (0.5*ones(2,1))), [2, 1]);
-%!assert(size (geornd (0.5*ones(2,2))), [2, 2]);
-%!assert(size (geornd (0.5, 3)), [3, 3]);
-%!assert(size (geornd (0.5, [4 1])), [4, 1]);
-%!assert(size (geornd (0.5, 4, 1)), [4, 1]);
+%!assert (size (geornd (0.5)), [1, 1])
+%!assert (size (geornd (0.5*ones (2,1))), [2, 1])
+%!assert (size (geornd (0.5*ones (2,2))), [2, 2])
+%!assert (size (geornd (0.5, 3)), [3, 3])
+%!assert (size (geornd (0.5, [4 1])), [4, 1])
+%!assert (size (geornd (0.5, 4, 1)), [4, 1])
 
 %% Test class of input preserved
-%!assert(class (geornd (0.5)), "double");
-%!assert(class (geornd (single(0.5))), "single");
-%!assert(class (geornd (single([0.5 0.5]))), "single");
-%!assert(class (geornd (single(0))), "single");
-%!assert(class (geornd (single(1))), "single");
+%!assert (class (geornd (0.5)), "double")
+%!assert (class (geornd (single (0.5))), "single")
+%!assert (class (geornd (single ([0.5 0.5]))), "single")
+%!assert (class (geornd (single (0))), "single")
+%!assert (class (geornd (single (1))), "single")
 
 %% Test input validation
 %!error geornd ()
-%!error geornd (ones(3),ones(2))
-%!error geornd (ones(2),ones(3))
+%!error geornd (ones (3), ones (2))
+%!error geornd (ones (2), ones (3))
 %!error geornd (i)
 %!error geornd (1, -1)
-%!error geornd (1, ones(2))
+%!error geornd (1, ones (2))
 %!error geornd (1, [2 -1 2])
-%!error geornd (ones(2,2), 2, 3)
-%!error geornd (ones(2,2), 3, 2)
+%!error geornd (ones (2,2), 2, 3)
+%!error geornd (ones (2,2), 3, 2)
 
diff --git a/scripts/statistics/distributions/hygecdf.m b/scripts/statistics/distributions/hygecdf.m
--- a/scripts/statistics/distributions/hygecdf.m
+++ b/scripts/statistics/distributions/hygecdf.m
@@ -71,39 +71,39 @@ function cdf = hygecdf (x, t, m, n)
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 1 2 3];
 %! y = [0 1/6 5/6 1 1];
-%!assert(hygecdf (x, 4*ones(1,5), 2, 2), y, eps);
-%!assert(hygecdf (x, 4, 2*ones(1,5), 2), y, eps);
-%!assert(hygecdf (x, 4, 2, 2*ones(1,5)), y, eps);
-%!assert(hygecdf (x, 4*[1 -1 NaN 1.1 1], 2, 2), [y(1) NaN NaN NaN y(5)], eps);
-%!assert(hygecdf (x, 4, 2*[1 -1 NaN 1.1 1], 2), [y(1) NaN NaN NaN y(5)], eps);
-%!assert(hygecdf (x, 4, 5, 2), [NaN NaN NaN NaN NaN]);
-%!assert(hygecdf (x, 4, 2, 2*[1 -1 NaN 1.1 1]), [y(1) NaN NaN NaN y(5)], eps);
-%!assert(hygecdf (x, 4, 2, 5), [NaN NaN NaN NaN NaN]);
-%!assert(hygecdf ([x(1:2) NaN x(4:5)], 4, 2, 2), [y(1:2) NaN y(4:5)], eps);
+%!assert (hygecdf (x, 4*ones (1,5), 2, 2), y, eps)
+%!assert (hygecdf (x, 4, 2*ones (1,5), 2), y, eps)
+%!assert (hygecdf (x, 4, 2, 2*ones (1,5)), y, eps)
+%!assert (hygecdf (x, 4*[1 -1 NaN 1.1 1], 2, 2), [y(1) NaN NaN NaN y(5)], eps)
+%!assert (hygecdf (x, 4, 2*[1 -1 NaN 1.1 1], 2), [y(1) NaN NaN NaN y(5)], eps)
+%!assert (hygecdf (x, 4, 5, 2), [NaN NaN NaN NaN NaN])
+%!assert (hygecdf (x, 4, 2, 2*[1 -1 NaN 1.1 1]), [y(1) NaN NaN NaN y(5)], eps)
+%!assert (hygecdf (x, 4, 2, 5), [NaN NaN NaN NaN NaN])
+%!assert (hygecdf ([x(1:2) NaN x(4:5)], 4, 2, 2), [y(1:2) NaN y(4:5)], eps)
 
 %% Test class of input preserved
-%!assert(hygecdf ([x, NaN], 4, 2, 2), [y, NaN], eps);
-%!assert(hygecdf (single([x, NaN]), 4, 2, 2), single([y, NaN]), eps("single"));
-%!assert(hygecdf ([x, NaN], single(4), 2, 2), single([y, NaN]), eps("single"));
-%!assert(hygecdf ([x, NaN], 4, single(2), 2), single([y, NaN]), eps("single"));
-%!assert(hygecdf ([x, NaN], 4, 2, single(2)), single([y, NaN]), eps("single"));
+%!assert (hygecdf ([x, NaN], 4, 2, 2), [y, NaN], eps)
+%!assert (hygecdf (single ([x, NaN]), 4, 2, 2), single ([y, NaN]), eps ("single"))
+%!assert (hygecdf ([x, NaN], single (4), 2, 2), single ([y, NaN]), eps ("single"))
+%!assert (hygecdf ([x, NaN], 4, single (2), 2), single ([y, NaN]), eps ("single"))
+%!assert (hygecdf ([x, NaN], 4, 2, single (2)), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error hygecdf ()
 %!error hygecdf (1)
 %!error hygecdf (1,2)
 %!error hygecdf (1,2,3)
 %!error hygecdf (1,2,3,4,5)
-%!error hygecdf (ones(2), ones(3), 1, 1)
-%!error hygecdf (1, ones(2), ones(3), 1)
-%!error hygecdf (1, 1, ones(2), ones(3))
+%!error hygecdf (ones (2), ones (3), 1, 1)
+%!error hygecdf (1, ones (2), ones (3), 1)
+%!error hygecdf (1, 1, ones (2), ones (3))
 %!error hygecdf (i, 2, 2, 2)
 %!error hygecdf (2, i, 2, 2)
 %!error hygecdf (2, 2, i, 2)
 %!error hygecdf (2, 2, 2, i)
 
diff --git a/scripts/statistics/distributions/hygeinv.m b/scripts/statistics/distributions/hygeinv.m
--- a/scripts/statistics/distributions/hygeinv.m
+++ b/scripts/statistics/distributions/hygeinv.m
@@ -75,40 +75,40 @@ function inv = hygeinv (x, t, m, n)
     endfor
   endif
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
-%!assert(hygeinv (x, 4*ones(1,5), 2*ones(1,5), 2*ones(1,5)), [NaN 0 1 2 NaN]);
-%!assert(hygeinv (x, 4*ones(1,5), 2, 2), [NaN 0 1 2 NaN]);
-%!assert(hygeinv (x, 4, 2*ones(1,5), 2), [NaN 0 1 2 NaN]);
-%!assert(hygeinv (x, 4, 2, 2*ones(1,5)), [NaN 0 1 2 NaN]);
-%!assert(hygeinv (x, 4*[1 -1 NaN 1.1 1], 2, 2), [NaN NaN NaN NaN NaN]);
-%!assert(hygeinv (x, 4, 2*[1 -1 NaN 1.1 1], 2), [NaN NaN NaN NaN NaN]);
-%!assert(hygeinv (x, 4, 5, 2), [NaN NaN NaN NaN NaN]);
-%!assert(hygeinv (x, 4, 2, 2*[1 -1 NaN 1.1 1]), [NaN NaN NaN NaN NaN]);
-%!assert(hygeinv (x, 4, 2, 5), [NaN NaN NaN NaN NaN]);
-%!assert(hygeinv ([x(1:2) NaN x(4:5)], 4, 2, 2), [NaN 0 NaN 2 NaN]);
+%!assert (hygeinv (x, 4*ones (1,5), 2*ones (1,5), 2*ones (1,5)), [NaN 0 1 2 NaN])
+%!assert (hygeinv (x, 4*ones (1,5), 2, 2), [NaN 0 1 2 NaN])
+%!assert (hygeinv (x, 4, 2*ones (1,5), 2), [NaN 0 1 2 NaN])
+%!assert (hygeinv (x, 4, 2, 2*ones (1,5)), [NaN 0 1 2 NaN])
+%!assert (hygeinv (x, 4*[1 -1 NaN 1.1 1], 2, 2), [NaN NaN NaN NaN NaN])
+%!assert (hygeinv (x, 4, 2*[1 -1 NaN 1.1 1], 2), [NaN NaN NaN NaN NaN])
+%!assert (hygeinv (x, 4, 5, 2), [NaN NaN NaN NaN NaN])
+%!assert (hygeinv (x, 4, 2, 2*[1 -1 NaN 1.1 1]), [NaN NaN NaN NaN NaN])
+%!assert (hygeinv (x, 4, 2, 5), [NaN NaN NaN NaN NaN])
+%!assert (hygeinv ([x(1:2) NaN x(4:5)], 4, 2, 2), [NaN 0 NaN 2 NaN])
 
 %% Test class of input preserved
-%!assert(hygeinv ([x, NaN], 4, 2, 2), [NaN 0 1 2 NaN NaN]);
-%!assert(hygeinv (single([x, NaN]), 4, 2, 2), single([NaN 0 1 2 NaN NaN]));
-%!assert(hygeinv ([x, NaN], single(4), 2, 2), single([NaN 0 1 2 NaN NaN]));
-%!assert(hygeinv ([x, NaN], 4, single(2), 2), single([NaN 0 1 2 NaN NaN]));
-%!assert(hygeinv ([x, NaN], 4, 2, single(2)), single([NaN 0 1 2 NaN NaN]));
+%!assert (hygeinv ([x, NaN], 4, 2, 2), [NaN 0 1 2 NaN NaN])
+%!assert (hygeinv (single ([x, NaN]), 4, 2, 2), single ([NaN 0 1 2 NaN NaN]))
+%!assert (hygeinv ([x, NaN], single (4), 2, 2), single ([NaN 0 1 2 NaN NaN]))
+%!assert (hygeinv ([x, NaN], 4, single (2), 2), single ([NaN 0 1 2 NaN NaN]))
+%!assert (hygeinv ([x, NaN], 4, 2, single (2)), single ([NaN 0 1 2 NaN NaN]))
 
 %% Test input validation
 %!error hygeinv ()
 %!error hygeinv (1)
 %!error hygeinv (1,2)
 %!error hygeinv (1,2,3)
 %!error hygeinv (1,2,3,4,5)
-%!error hygeinv (ones(2), ones(3), 1, 1)
-%!error hygeinv (1, ones(2), ones(3), 1)
-%!error hygeinv (1, 1, ones(2), ones(3))
+%!error hygeinv (ones (2), ones (3), 1, 1)
+%!error hygeinv (1, ones (2), ones (3), 1)
+%!error hygeinv (1, 1, ones (2), ones (3))
 %!error hygeinv (i, 2, 2, 2)
 %!error hygeinv (2, i, 2, 2)
 %!error hygeinv (2, 2, i, 2)
 %!error hygeinv (2, 2, 2, i)
 
diff --git a/scripts/statistics/distributions/hygepdf.m b/scripts/statistics/distributions/hygepdf.m
--- a/scripts/statistics/distributions/hygepdf.m
+++ b/scripts/statistics/distributions/hygepdf.m
@@ -75,38 +75,38 @@ function pdf = hygepdf (x, t, m, n)
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 1 2 3];
 %! y = [0 1/6 4/6 1/6 0];
-%!assert(hygepdf (x, 4*ones(1,5), 2, 2), y);
-%!assert(hygepdf (x, 4, 2*ones(1,5), 2), y);
-%!assert(hygepdf (x, 4, 2, 2*ones(1,5)), y);
-%!assert(hygepdf (x, 4*[1 -1 NaN 1.1 1], 2, 2), [0 NaN NaN NaN 0]);
-%!assert(hygepdf (x, 4, 2*[1 -1 NaN 1.1 1], 2), [0 NaN NaN NaN 0]);
-%!assert(hygepdf (x, 4, 5, 2), [NaN NaN NaN NaN NaN]);
-%!assert(hygepdf (x, 4, 2, 2*[1 -1 NaN 1.1 1]), [0 NaN NaN NaN 0]);
-%!assert(hygepdf (x, 4, 2, 5), [NaN NaN NaN NaN NaN]);
-%!assert(hygepdf ([x, NaN], 4, 2, 2), [y, NaN], eps);
+%!assert (hygepdf (x, 4*ones (1,5), 2, 2), y)
+%!assert (hygepdf (x, 4, 2*ones (1,5), 2), y)
+%!assert (hygepdf (x, 4, 2, 2*ones (1,5)), y)
+%!assert (hygepdf (x, 4*[1 -1 NaN 1.1 1], 2, 2), [0 NaN NaN NaN 0])
+%!assert (hygepdf (x, 4, 2*[1 -1 NaN 1.1 1], 2), [0 NaN NaN NaN 0])
+%!assert (hygepdf (x, 4, 5, 2), [NaN NaN NaN NaN NaN])
+%!assert (hygepdf (x, 4, 2, 2*[1 -1 NaN 1.1 1]), [0 NaN NaN NaN 0])
+%!assert (hygepdf (x, 4, 2, 5), [NaN NaN NaN NaN NaN])
+%!assert (hygepdf ([x, NaN], 4, 2, 2), [y, NaN], eps)
 
 %% Test class of input preserved
-%!assert(hygepdf (single([x, NaN]), 4, 2, 2), single([y, NaN]));
-%!assert(hygepdf ([x, NaN], single(4), 2, 2), single([y, NaN]));
-%!assert(hygepdf ([x, NaN], 4, single(2), 2), single([y, NaN]));
-%!assert(hygepdf ([x, NaN], 4, 2, single(2)), single([y, NaN]));
+%!assert (hygepdf (single ([x, NaN]), 4, 2, 2), single ([y, NaN]))
+%!assert (hygepdf ([x, NaN], single (4), 2, 2), single ([y, NaN]))
+%!assert (hygepdf ([x, NaN], 4, single (2), 2), single ([y, NaN]))
+%!assert (hygepdf ([x, NaN], 4, 2, single (2)), single ([y, NaN]))
 
 %% Test input validation
 %!error hygepdf ()
 %!error hygepdf (1)
 %!error hygepdf (1,2)
 %!error hygepdf (1,2,3)
 %!error hygepdf (1,2,3,4,5)
-%!error hygepdf (1, ones(3),ones(2),ones(2))
-%!error hygepdf (1, ones(2),ones(3),ones(2))
-%!error hygepdf (1, ones(2),ones(2),ones(3))
+%!error hygepdf (1, ones (3), ones (2), ones (2))
+%!error hygepdf (1, ones (2), ones (3), ones (2))
+%!error hygepdf (1, ones (2), ones (2), ones (3))
 %!error hygepdf (i, 2, 2, 2)
 %!error hygepdf (2, i, 2, 2)
 %!error hygepdf (2, 2, i, 2)
 %!error hygepdf (2, 2, 2, i)
 
diff --git a/scripts/statistics/distributions/hygernd.m b/scripts/statistics/distributions/hygernd.m
--- a/scripts/statistics/distributions/hygernd.m
+++ b/scripts/statistics/distributions/hygernd.m
@@ -105,44 +105,44 @@ function rnd = hygernd (t, m, n, varargi
       p = hygepdf (v, t(i), m(i), n(i));
       rnd(i) = v(lookup (cumsum (p(1 : end-1)) / sum (p), rn(i)) + 1);
     endfor
   endif
 
 endfunction
 
 
-%!assert(size (hygernd (4,2,2)), [1, 1]);
-%!assert(size (hygernd (4*ones(2,1), 2,2)), [2, 1]);
-%!assert(size (hygernd (4*ones(2,2), 2,2)), [2, 2]);
-%!assert(size (hygernd (4, 2*ones(2,1), 2)), [2, 1]);
-%!assert(size (hygernd (4, 2*ones(2,2), 2)), [2, 2]);
-%!assert(size (hygernd (4, 2, 2*ones(2,1))), [2, 1]);
-%!assert(size (hygernd (4, 2, 2*ones(2,2))), [2, 2]);
-%!assert(size (hygernd (4, 2, 2, 3)), [3, 3]);
-%!assert(size (hygernd (4, 2, 2, [4 1])), [4, 1]);
-%!assert(size (hygernd (4, 2, 2, 4, 1)), [4, 1]);
+%!assert (size (hygernd (4,2,2)), [1, 1])
+%!assert (size (hygernd (4*ones (2,1), 2,2)), [2, 1])
+%!assert (size (hygernd (4*ones (2,2), 2,2)), [2, 2])
+%!assert (size (hygernd (4, 2*ones (2,1), 2)), [2, 1])
+%!assert (size (hygernd (4, 2*ones (2,2), 2)), [2, 2])
+%!assert (size (hygernd (4, 2, 2*ones (2,1))), [2, 1])
+%!assert (size (hygernd (4, 2, 2*ones (2,2))), [2, 2])
+%!assert (size (hygernd (4, 2, 2, 3)), [3, 3])
+%!assert (size (hygernd (4, 2, 2, [4 1])), [4, 1])
+%!assert (size (hygernd (4, 2, 2, 4, 1)), [4, 1])
 
-%!assert(class (hygernd (4,2,2)), "double");
-%!assert(class (hygernd (single(4),2,2)), "single");
-%!assert(class (hygernd (single([4 4]),2,2)), "single");
-%!assert(class (hygernd (4,single(2),2)), "single");
-%!assert(class (hygernd (4,single([2 2]),2)), "single");
-%!assert(class (hygernd (4,2,single(2))), "single");
-%!assert(class (hygernd (4,2,single([2 2]))), "single");
+%!assert (class (hygernd (4,2,2)), "double")
+%!assert (class (hygernd (single (4),2,2)), "single")
+%!assert (class (hygernd (single ([4 4]),2,2)), "single")
+%!assert (class (hygernd (4,single (2),2)), "single")
+%!assert (class (hygernd (4,single ([2 2]),2)), "single")
+%!assert (class (hygernd (4,2,single (2))), "single")
+%!assert (class (hygernd (4,2,single ([2 2]))), "single")
 
 %% Test input validation
 %!error hygernd ()
 %!error hygernd (1)
 %!error hygernd (1,2)
-%!error hygernd (ones(3),ones(2),ones(2), 2)
-%!error hygernd (ones(2),ones(3),ones(2), 2)
-%!error hygernd (ones(2),ones(2),ones(3), 2)
+%!error hygernd (ones (3), ones (2), ones (2), 2)
+%!error hygernd (ones (2), ones (3), ones (2), 2)
+%!error hygernd (ones (2), ones (2), ones (3), 2)
 %!error hygernd (i, 2, 2)
 %!error hygernd (2, i, 2)
 %!error hygernd (2, 2, i)
 %!error hygernd (4,2,2, -1)
-%!error hygernd (4,2,2, ones(2))
+%!error hygernd (4,2,2, ones (2))
 %!error hygernd (4,2,2, [2 -1 2])
-%!error hygernd (4*ones(2),2,2, 3)
-%!error hygernd (4*ones(2),2,2, [3, 2])
-%!error hygernd (4*ones(2),2,2, 3, 2)
+%!error hygernd (4*ones (2),2,2, 3)
+%!error hygernd (4*ones (2),2,2, [3, 2])
+%!error hygernd (4*ones (2),2,2, 3, 2)
 
diff --git a/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m b/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
--- a/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
+++ b/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
@@ -85,11 +85,11 @@ function cdf = kolmogorov_smirnov_cdf (x
   endif
 
 endfunction
 
 
 %% Test input validation
 %!error kolmogorov_smirnov_cdf ()
 %!error kolmogorov_smirnov_cdf (1,2,3)
-%!error kolmogorov_smirnov_cdf (1, ones(2))
+%!error kolmogorov_smirnov_cdf (1, ones (2))
 %!error kolmogorov_smirnov_cdf ([], 1)
 
diff --git a/scripts/statistics/distributions/laplace_cdf.m b/scripts/statistics/distributions/laplace_cdf.m
--- a/scripts/statistics/distributions/laplace_cdf.m
+++ b/scripts/statistics/distributions/laplace_cdf.m
@@ -39,18 +39,18 @@ function cdf = laplace_cdf (x)
   cdf = (1 + sign (x) .* (1 - exp (- abs (x)))) / 2;
 
 endfunction
 
 
 %!shared x,y
 %! x = [-Inf -log(2) 0 log(2) Inf];
 %! y = [0, 1/4, 1/2, 3/4, 1]; 
-%!assert(laplace_cdf ([x, NaN]), [y, NaN]);
+%!assert (laplace_cdf ([x, NaN]), [y, NaN])
 
 %% Test class of input preserved
-%!assert(laplace_cdf (single([x, NaN])), single([y, NaN]));
+%!assert (laplace_cdf (single ([x, NaN])), single ([y, NaN]))
 
 %% Test input validation
 %!error laplace_cdf ()
 %!error laplace_cdf (1,2)
 %!error laplace_cdf (i)
 
diff --git a/scripts/statistics/distributions/laplace_inv.m b/scripts/statistics/distributions/laplace_inv.m
--- a/scripts/statistics/distributions/laplace_inv.m
+++ b/scripts/statistics/distributions/laplace_inv.m
@@ -46,19 +46,19 @@ function inv = laplace_inv (x)
   inv(k) = ((x(k) < 1/2) .* log (2 * x(k))
             - (x(k) > 1/2) .* log (2 * (1 - x(k))));
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
-%!assert(laplace_inv (x), [NaN -Inf 0 Inf NaN]);
+%!assert (laplace_inv (x), [NaN -Inf 0 Inf NaN])
 
 %% Test class of input preserved
-%!assert(laplace_inv ([x, NaN]), [NaN -Inf 0 Inf NaN NaN]);
-%!assert(laplace_inv (single([x, NaN])), single([NaN -Inf 0 Inf NaN NaN]));
+%!assert (laplace_inv ([x, NaN]), [NaN -Inf 0 Inf NaN NaN])
+%!assert (laplace_inv (single ([x, NaN])), single ([NaN -Inf 0 Inf NaN NaN]))
 
 %% Test input validation
 %!error laplace_inv ()
 %!error laplace_inv (1,2)
 %!error laplace_inv (i)
 
diff --git a/scripts/statistics/distributions/laplace_pdf.m b/scripts/statistics/distributions/laplace_pdf.m
--- a/scripts/statistics/distributions/laplace_pdf.m
+++ b/scripts/statistics/distributions/laplace_pdf.m
@@ -39,18 +39,18 @@ function pdf = laplace_pdf (x)
   pdf = exp (- abs (x)) / 2;
 
 endfunction
 
 
 %!shared x,y
 %! x = [-Inf -log(2) 0 log(2) Inf];
 %! y = [0, 1/4, 1/2, 1/4, 0]; 
-%!assert(laplace_pdf ([x, NaN]), [y, NaN]);
+%!assert (laplace_pdf ([x, NaN]), [y, NaN])
 
 %% Test class of input preserved
-%!assert(laplace_pdf (single([x, NaN])), single([y, NaN]));
+%!assert (laplace_pdf (single ([x, NaN])), single ([y, NaN]))
 
 %% Test input validation
 %!error laplace_pdf ()
 %!error laplace_pdf (1,2)
 %!error laplace_pdf (i)
 
diff --git a/scripts/statistics/distributions/laplace_rnd.m b/scripts/statistics/distributions/laplace_rnd.m
--- a/scripts/statistics/distributions/laplace_rnd.m
+++ b/scripts/statistics/distributions/laplace_rnd.m
@@ -55,20 +55,20 @@ function rnd = laplace_rnd (varargin)
   endif
 
   tmp = rand (sz);
   rnd = (tmp < 1/2) .* log (2 * tmp) - (tmp > 1/2) .* log (2 * (1 - tmp));
 
 endfunction
 
 
-%!assert(size (laplace_rnd (3)), [3, 3]);
-%!assert(size (laplace_rnd ([4 1])), [4, 1]);
-%!assert(size (laplace_rnd (4,1)), [4, 1]);
+%!assert (size (laplace_rnd (3)), [3, 3])
+%!assert (size (laplace_rnd ([4 1])), [4, 1])
+%!assert (size (laplace_rnd (4,1)), [4, 1])
 
 %% Test input validation
 %!error laplace_rnd ()
 %!error laplace_rnd (-1)
-%!error laplace_rnd (ones(2))
+%!error laplace_rnd (ones (2))
 %!error laplace_rnd ([2 -1 2])
-%!error laplace_rnd (1, ones(2))
+%!error laplace_rnd (1, ones (2))
 %!error laplace_rnd (1, -1)
 
diff --git a/scripts/statistics/distributions/logistic_cdf.m b/scripts/statistics/distributions/logistic_cdf.m
--- a/scripts/statistics/distributions/logistic_cdf.m
+++ b/scripts/statistics/distributions/logistic_cdf.m
@@ -39,18 +39,18 @@ function cdf = logistic_cdf (x)
   cdf = 1 ./ (1 + exp (-x));
 
 endfunction
 
 
 %!shared x,y
 %! x = [-Inf -log(3) 0 log(3) Inf];
 %! y = [0, 1/4, 1/2, 3/4, 1]; 
-%!assert(logistic_cdf ([x, NaN]), [y, NaN], eps);
+%!assert (logistic_cdf ([x, NaN]), [y, NaN], eps)
 
 %% Test class of input preserved
-%!assert(logistic_cdf (single([x, NaN])), single([y, NaN]), eps ("single"));
+%!assert (logistic_cdf (single ([x, NaN])), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error logistic_cdf ()
 %!error logistic_cdf (1,2)
 %!error logistic_cdf (i)
 
diff --git a/scripts/statistics/distributions/logistic_inv.m b/scripts/statistics/distributions/logistic_inv.m
--- a/scripts/statistics/distributions/logistic_inv.m
+++ b/scripts/statistics/distributions/logistic_inv.m
@@ -51,19 +51,19 @@ function inv = logistic_inv (x)
   k = (x > 0) & (x < 1);
   inv(k) = - log (1 ./ x(k) - 1);
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
-%!assert(logistic_inv (x), [NaN -Inf 0 Inf NaN]);
+%!assert (logistic_inv (x), [NaN -Inf 0 Inf NaN])
 
 %% Test class of input preserved
-%!assert(logistic_inv ([x, NaN]), [NaN -Inf 0 Inf NaN NaN]);
-%!assert(logistic_inv (single([x, NaN])), single([NaN -Inf 0 Inf NaN NaN]));
+%!assert (logistic_inv ([x, NaN]), [NaN -Inf 0 Inf NaN NaN])
+%!assert (logistic_inv (single ([x, NaN])), single ([NaN -Inf 0 Inf NaN NaN]))
 
 %% Test input validation
 %!error logistic_inv ()
 %!error logistic_inv (1,2)
 %!error logistic_inv (i)
 
diff --git a/scripts/statistics/distributions/logistic_pdf.m b/scripts/statistics/distributions/logistic_pdf.m
--- a/scripts/statistics/distributions/logistic_pdf.m
+++ b/scripts/statistics/distributions/logistic_pdf.m
@@ -39,18 +39,18 @@ function pdf = logistic_pdf (x)
   pdf = cdf .* (1 - cdf);
 
 endfunction
 
 
 %!shared x,y
 %! x = [-Inf -log(4) 0 log(4) Inf];
 %! y = [0, 0.16, 1/4, 0.16, 0]; 
-%!assert(logistic_pdf ([x, NaN]), [y, NaN], eps);
+%!assert (logistic_pdf ([x, NaN]), [y, NaN], eps)
 
 %% Test class of input preserved
-%!assert(logistic_pdf (single([x, NaN])), single([y, NaN]), eps ("single"));
+%!assert (logistic_pdf (single ([x, NaN])), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error logistic_pdf ()
 %!error logistic_pdf (1,2)
 %!error logistic_pdf (i)
 
diff --git a/scripts/statistics/distributions/logistic_rnd.m b/scripts/statistics/distributions/logistic_rnd.m
--- a/scripts/statistics/distributions/logistic_rnd.m
+++ b/scripts/statistics/distributions/logistic_rnd.m
@@ -54,20 +54,20 @@ function rnd = logistic_rnd (varargin)
     sz = [varargin{:}];
   endif
 
   rnd = - log (1 ./ rand (sz) - 1);
 
 endfunction
 
 
-%!assert(size (logistic_rnd (3)), [3, 3]);
-%!assert(size (logistic_rnd ([4 1])), [4, 1]);
-%!assert(size (logistic_rnd (4,1)), [4, 1]);
+%!assert (size (logistic_rnd (3)), [3, 3])
+%!assert (size (logistic_rnd ([4 1])), [4, 1])
+%!assert (size (logistic_rnd (4,1)), [4, 1])
 
 %% Test input validation
 %!error logistic_rnd ()
 %!error logistic_rnd (-1)
-%!error logistic_rnd (ones(2))
+%!error logistic_rnd (ones (2))
 %!error logistic_rnd ([2 -1 2])
-%!error logistic_rnd (1, ones(2))
+%!error logistic_rnd (1, ones (2))
 %!error logistic_rnd (1, -1)
 
diff --git a/scripts/statistics/distributions/logncdf.m b/scripts/statistics/distributions/logncdf.m
--- a/scripts/statistics/distributions/logncdf.m
+++ b/scripts/statistics/distributions/logncdf.m
@@ -69,32 +69,32 @@ function cdf = logncdf (x, mu = 0, sigma
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 1 e Inf];
 %! y = [0, 0, 0.5, 1/2+1/2*erf(1/2), 1];
-%!assert(logncdf (x, zeros(1,5), sqrt(2)*ones(1,5)), y);
-%!assert(logncdf (x, 0, sqrt(2)*ones(1,5)), y);
-%!assert(logncdf (x, zeros(1,5), sqrt(2)), y);
-%!assert(logncdf (x, [0 1 NaN 0 1], sqrt(2)), [0 0 NaN y(4:5)]);
-%!assert(logncdf (x, 0, sqrt(2)*[0 NaN Inf 1 1]), [NaN NaN NaN y(4:5)]);
-%!assert(logncdf ([x(1:3) NaN x(5)], 0, sqrt(2)), [y(1:3) NaN y(5)]);
+%!assert (logncdf (x, zeros (1,5), sqrt(2)*ones (1,5)), y)
+%!assert (logncdf (x, 0, sqrt(2)*ones (1,5)), y)
+%!assert (logncdf (x, zeros (1,5), sqrt(2)), y)
+%!assert (logncdf (x, [0 1 NaN 0 1], sqrt(2)), [0 0 NaN y(4:5)])
+%!assert (logncdf (x, 0, sqrt(2)*[0 NaN Inf 1 1]), [NaN NaN NaN y(4:5)])
+%!assert (logncdf ([x(1:3) NaN x(5)], 0, sqrt(2)), [y(1:3) NaN y(5)])
 
 %% Test class of input preserved
-%!assert(logncdf ([x, NaN], 0, sqrt(2)), [y, NaN]);
-%!assert(logncdf (single([x, NaN]), 0, sqrt(2)), single([y, NaN]), eps("single"));
-%!assert(logncdf ([x, NaN], single(0), sqrt(2)), single([y, NaN]), eps("single"));
-%!assert(logncdf ([x, NaN], 0, single(sqrt(2))), single([y, NaN]), eps("single"));
+%!assert (logncdf ([x, NaN], 0, sqrt(2)), [y, NaN])
+%!assert (logncdf (single ([x, NaN]), 0, sqrt(2)), single ([y, NaN]), eps ("single"))
+%!assert (logncdf ([x, NaN], single (0), sqrt(2)), single ([y, NaN]), eps ("single"))
+%!assert (logncdf ([x, NaN], 0, single (sqrt(2))), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error logncdf ()
 %!error logncdf (1,2)
 %!error logncdf (1,2,3,4)
-%!error logncdf (ones(3),ones(2),ones(2))
-%!error logncdf (ones(2),ones(3),ones(2))
-%!error logncdf (ones(2),ones(2),ones(3))
+%!error logncdf (ones (3), ones (2), ones (2))
+%!error logncdf (ones (2), ones (3), ones (2))
+%!error logncdf (ones (2), ones (2), ones (3))
 %!error logncdf (i, 2, 2)
 %!error logncdf (2, i, 2)
 %!error logncdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/logninv.m b/scripts/statistics/distributions/logninv.m
--- a/scripts/statistics/distributions/logninv.m
+++ b/scripts/statistics/distributions/logninv.m
@@ -68,32 +68,32 @@ function inv = logninv (x, mu = 0, sigma
     inv(k) = exp (mu(k)) .* exp (sigma(k) .* stdnormal_inv (x(k)));
   endif
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
-%!assert(logninv (x, ones(1,5), ones(1,5)), [NaN 0 e Inf NaN]);
-%!assert(logninv (x, 1, ones(1,5)), [NaN 0 e Inf NaN]);
-%!assert(logninv (x, ones(1,5), 1), [NaN 0 e Inf NaN]);
-%!assert(logninv (x, [1 1 NaN 0 1], 1), [NaN 0 NaN Inf NaN]);
-%!assert(logninv (x, 1, [1 0 NaN Inf 1]), [NaN NaN NaN NaN NaN]);
-%!assert(logninv ([x(1:2) NaN x(4:5)], 1, 2), [NaN 0 NaN Inf NaN]);
+%!assert (logninv (x, ones (1,5), ones (1,5)), [NaN 0 e Inf NaN])
+%!assert (logninv (x, 1, ones (1,5)), [NaN 0 e Inf NaN])
+%!assert (logninv (x, ones (1,5), 1), [NaN 0 e Inf NaN])
+%!assert (logninv (x, [1 1 NaN 0 1], 1), [NaN 0 NaN Inf NaN])
+%!assert (logninv (x, 1, [1 0 NaN Inf 1]), [NaN NaN NaN NaN NaN])
+%!assert (logninv ([x(1:2) NaN x(4:5)], 1, 2), [NaN 0 NaN Inf NaN])
 
 %% Test class of input preserved
-%!assert(logninv ([x, NaN], 1, 1), [NaN 0 e Inf NaN NaN]);
-%!assert(logninv (single([x, NaN]), 1, 1), single([NaN 0 e Inf NaN NaN]));
-%!assert(logninv ([x, NaN], single(1), 1), single([NaN 0 e Inf NaN NaN]));
-%!assert(logninv ([x, NaN], 1, single(1)), single([NaN 0 e Inf NaN NaN]));
+%!assert (logninv ([x, NaN], 1, 1), [NaN 0 e Inf NaN NaN])
+%!assert (logninv (single ([x, NaN]), 1, 1), single ([NaN 0 e Inf NaN NaN]))
+%!assert (logninv ([x, NaN], single (1), 1), single ([NaN 0 e Inf NaN NaN]))
+%!assert (logninv ([x, NaN], 1, single (1)), single ([NaN 0 e Inf NaN NaN]))
 
 %% Test input validation
 %!error logninv ()
 %!error logninv (1,2)
 %!error logninv (1,2,3,4)
-%!error logninv (ones(3),ones(2),ones(2))
-%!error logninv (ones(2),ones(3),ones(2))
-%!error logninv (ones(2),ones(2),ones(3))
+%!error logninv (ones (3), ones (2), ones (2))
+%!error logninv (ones (2), ones (3), ones (2))
+%!error logninv (ones (2), ones (2), ones (3))
 %!error logninv (i, 2, 2)
 %!error logninv (2, i, 2)
 %!error logninv (2, 2, i)
 
diff --git a/scripts/statistics/distributions/lognpdf.m b/scripts/statistics/distributions/lognpdf.m
--- a/scripts/statistics/distributions/lognpdf.m
+++ b/scripts/statistics/distributions/lognpdf.m
@@ -66,31 +66,31 @@ function pdf = lognpdf (x, mu = 0, sigma
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 e Inf];
 %! y = [0, 0, 1/(e*sqrt(2*pi)) * exp(-1/2), 0];
-%!assert(lognpdf (x, zeros(1,4), ones(1,4)), y, eps);
-%!assert(lognpdf (x, 0, ones(1,4)), y, eps);
-%!assert(lognpdf (x, zeros(1,4), 1), y, eps);
-%!assert(lognpdf (x, [0 1 NaN 0], 1), [0 0 NaN y(4)], eps);
-%!assert(lognpdf (x, 0, [0 NaN Inf 1]), [NaN NaN NaN y(4)], eps);
-%!assert(lognpdf ([x, NaN], 0, 1), [y, NaN], eps);
+%!assert (lognpdf (x, zeros (1,4), ones (1,4)), y, eps)
+%!assert (lognpdf (x, 0, ones (1,4)), y, eps)
+%!assert (lognpdf (x, zeros (1,4), 1), y, eps)
+%!assert (lognpdf (x, [0 1 NaN 0], 1), [0 0 NaN y(4)], eps)
+%!assert (lognpdf (x, 0, [0 NaN Inf 1]), [NaN NaN NaN y(4)], eps)
+%!assert (lognpdf ([x, NaN], 0, 1), [y, NaN], eps)
 
 %% Test class of input preserved
-%!assert(lognpdf (single([x, NaN]), 0, 1), single([y, NaN]), eps("single"));
-%!assert(lognpdf ([x, NaN], single(0), 1), single([y, NaN]), eps("single"));
-%!assert(lognpdf ([x, NaN], 0, single(1)), single([y, NaN]), eps("single"));
+%!assert (lognpdf (single ([x, NaN]), 0, 1), single ([y, NaN]), eps ("single"))
+%!assert (lognpdf ([x, NaN], single (0), 1), single ([y, NaN]), eps ("single"))
+%!assert (lognpdf ([x, NaN], 0, single (1)), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error lognpdf ()
 %!error lognpdf (1,2)
 %!error lognpdf (1,2,3,4)
-%!error lognpdf (ones(3),ones(2),ones(2))
-%!error lognpdf (ones(2),ones(3),ones(2))
-%!error lognpdf (ones(2),ones(2),ones(3))
+%!error lognpdf (ones (3), ones (2), ones (2))
+%!error lognpdf (ones (2), ones (3), ones (2))
+%!error lognpdf (ones (2), ones (2), ones (3))
 %!error lognpdf (i, 2, 2)
 %!error lognpdf (2, i, 2)
 %!error lognpdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/lognrnd.m b/scripts/statistics/distributions/lognrnd.m
--- a/scripts/statistics/distributions/lognrnd.m
+++ b/scripts/statistics/distributions/lognrnd.m
@@ -93,40 +93,40 @@ function rnd = lognrnd (mu, sigma, varar
 
     k = (sigma < 0) | (sigma == Inf);
     rnd(k) = NaN;
   endif
 
 endfunction
 
 
-%!assert(size (lognrnd (1,2)), [1, 1]);
-%!assert(size (lognrnd (ones(2,1), 2)), [2, 1]);
-%!assert(size (lognrnd (ones(2,2), 2)), [2, 2]);
-%!assert(size (lognrnd (1, 2*ones(2,1))), [2, 1]);
-%!assert(size (lognrnd (1, 2*ones(2,2))), [2, 2]);
-%!assert(size (lognrnd (1, 2, 3)), [3, 3]);
-%!assert(size (lognrnd (1, 2, [4 1])), [4, 1]);
-%!assert(size (lognrnd (1, 2, 4, 1)), [4, 1]);
+%!assert (size (lognrnd (1,2)), [1, 1])
+%!assert (size (lognrnd (ones (2,1), 2)), [2, 1])
+%!assert (size (lognrnd (ones (2,2), 2)), [2, 2])
+%!assert (size (lognrnd (1, 2*ones (2,1))), [2, 1])
+%!assert (size (lognrnd (1, 2*ones (2,2))), [2, 2])
+%!assert (size (lognrnd (1, 2, 3)), [3, 3])
+%!assert (size (lognrnd (1, 2, [4 1])), [4, 1])
+%!assert (size (lognrnd (1, 2, 4, 1)), [4, 1])
 
 %% Test class of input preserved
-%!assert(class (lognrnd (1, 2)), "double");
-%!assert(class (lognrnd (single(1), 2)), "single");
-%!assert(class (lognrnd (single([1 1]), 2)), "single");
-%!assert(class (lognrnd (1, single(2))), "single");
-%!assert(class (lognrnd (1, single([2 2]))), "single");
+%!assert (class (lognrnd (1, 2)), "double")
+%!assert (class (lognrnd (single (1), 2)), "single")
+%!assert (class (lognrnd (single ([1 1]), 2)), "single")
+%!assert (class (lognrnd (1, single (2))), "single")
+%!assert (class (lognrnd (1, single ([2 2]))), "single")
 
 %% Test input validation
 %!error lognrnd ()
 %!error lognrnd (1)
-%!error lognrnd (ones(3),ones(2))
-%!error lognrnd (ones(2),ones(3))
+%!error lognrnd (ones (3), ones (2))
+%!error lognrnd (ones (2), ones (3))
 %!error lognrnd (i, 2)
 %!error lognrnd (2, i)
 %!error lognrnd (1,2, -1)
-%!error lognrnd (1,2, ones(2))
+%!error lognrnd (1,2, ones (2))
 %!error lognrnd (1, 2, [2 -1 2])
-%!error lognrnd (1,2, 1, ones(2))
+%!error lognrnd (1,2, 1, ones (2))
 %!error lognrnd (1,2, 1, -1)
-%!error lognrnd (ones(2,2), 2, 3)
-%!error lognrnd (ones(2,2), 2, [3, 2])
-%!error lognrnd (ones(2,2), 2, 2, 3)
+%!error lognrnd (ones (2,2), 2, 3)
+%!error lognrnd (ones (2,2), 2, [3, 2])
+%!error lognrnd (ones (2,2), 2, 2, 3)
 
diff --git a/scripts/statistics/distributions/nbincdf.m b/scripts/statistics/distributions/nbincdf.m
--- a/scripts/statistics/distributions/nbincdf.m
+++ b/scripts/statistics/distributions/nbincdf.m
@@ -73,33 +73,33 @@ function cdf = nbincdf (x, n, p)
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 1 2 Inf];
 %! y = [0 1/2 3/4 7/8 1];
-%!assert(nbincdf (x, ones(1,5), 0.5*ones(1,5)), y);
-%!assert(nbincdf (x, 1, 0.5*ones(1,5)), y);
-%!assert(nbincdf (x, ones(1,5), 0.5), y);
-%!assert(nbincdf ([x(1:3) 0 x(5)], [0 1 NaN 1.5 Inf], 0.5), [NaN 1/2 NaN nbinpdf(0,1.5,0.5) NaN], eps);
-%!assert(nbincdf (x, 1, 0.5*[-1 NaN 4 1 1]), [NaN NaN NaN y(4:5)]);
-%!assert(nbincdf ([x(1:2) NaN x(4:5)], 1, 0.5), [y(1:2) NaN y(4:5)]);
+%!assert (nbincdf (x, ones (1,5), 0.5*ones (1,5)), y)
+%!assert (nbincdf (x, 1, 0.5*ones (1,5)), y)
+%!assert (nbincdf (x, ones (1,5), 0.5), y)
+%!assert (nbincdf ([x(1:3) 0 x(5)], [0 1 NaN 1.5 Inf], 0.5), [NaN 1/2 NaN nbinpdf(0,1.5,0.5) NaN], eps)
+%!assert (nbincdf (x, 1, 0.5*[-1 NaN 4 1 1]), [NaN NaN NaN y(4:5)])
+%!assert (nbincdf ([x(1:2) NaN x(4:5)], 1, 0.5), [y(1:2) NaN y(4:5)])
 
 %% Test class of input preserved
-%!assert(nbincdf ([x, NaN], 1, 0.5), [y, NaN]);
-%!assert(nbincdf (single([x, NaN]), 1, 0.5), single([y, NaN]));
-%!assert(nbincdf ([x, NaN], single(1), 0.5), single([y, NaN]));
-%!assert(nbincdf ([x, NaN], 1, single(0.5)), single([y, NaN]));
+%!assert (nbincdf ([x, NaN], 1, 0.5), [y, NaN])
+%!assert (nbincdf (single ([x, NaN]), 1, 0.5), single ([y, NaN]))
+%!assert (nbincdf ([x, NaN], single (1), 0.5), single ([y, NaN]))
+%!assert (nbincdf ([x, NaN], 1, single (0.5)), single ([y, NaN]))
 
 %% Test input validation
 %!error nbincdf ()
 %!error nbincdf (1)
 %!error nbincdf (1,2)
 %!error nbincdf (1,2,3,4)
-%!error nbincdf (ones(3),ones(2),ones(2))
-%!error nbincdf (ones(2),ones(3),ones(2))
-%!error nbincdf (ones(2),ones(2),ones(3))
+%!error nbincdf (ones (3), ones (2), ones (2))
+%!error nbincdf (ones (2), ones (3), ones (2))
+%!error nbincdf (ones (2), ones (2), ones (3))
 %!error nbincdf (i, 2, 2)
 %!error nbincdf (2, i, 2)
 %!error nbincdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/nbininv.m b/scripts/statistics/distributions/nbininv.m
--- a/scripts/statistics/distributions/nbininv.m
+++ b/scripts/statistics/distributions/nbininv.m
@@ -95,34 +95,34 @@ function inv = nbininv (x, n, p)
   endif
   inv(k) = m;
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 3/4 1 2];
-%!assert(nbininv (x, ones(1,5), 0.5*ones(1,5)), [NaN 0 1 Inf NaN]);
-%!assert(nbininv (x, 1, 0.5*ones(1,5)), [NaN 0 1 Inf NaN]);
-%!assert(nbininv (x, ones(1,5), 0.5), [NaN 0 1 Inf NaN]);
-%!assert(nbininv (x, [1 0 NaN Inf 1], 0.5), [NaN NaN NaN NaN NaN]);
-%!assert(nbininv (x, [1 0 1.5 Inf 1], 0.5), [NaN NaN 2 NaN NaN]);
-%!assert(nbininv (x, 1, 0.5*[1 -Inf NaN Inf 1]), [NaN NaN NaN NaN NaN]);
-%!assert(nbininv ([x(1:2) NaN x(4:5)], 1, 0.5), [NaN 0 NaN Inf NaN]);
+%!assert (nbininv (x, ones (1,5), 0.5*ones (1,5)), [NaN 0 1 Inf NaN])
+%!assert (nbininv (x, 1, 0.5*ones (1,5)), [NaN 0 1 Inf NaN])
+%!assert (nbininv (x, ones (1,5), 0.5), [NaN 0 1 Inf NaN])
+%!assert (nbininv (x, [1 0 NaN Inf 1], 0.5), [NaN NaN NaN NaN NaN])
+%!assert (nbininv (x, [1 0 1.5 Inf 1], 0.5), [NaN NaN 2 NaN NaN])
+%!assert (nbininv (x, 1, 0.5*[1 -Inf NaN Inf 1]), [NaN NaN NaN NaN NaN])
+%!assert (nbininv ([x(1:2) NaN x(4:5)], 1, 0.5), [NaN 0 NaN Inf NaN])
 
 %% Test class of input preserved
-%!assert(nbininv ([x, NaN], 1, 0.5), [NaN 0 1 Inf NaN NaN]);
-%!assert(nbininv (single([x, NaN]), 1, 0.5), single([NaN 0 1 Inf NaN NaN]));
-%!assert(nbininv ([x, NaN], single(1), 0.5), single([NaN 0 1 Inf NaN NaN]));
-%!assert(nbininv ([x, NaN], 1, single(0.5)), single([NaN 0 1 Inf NaN NaN]));
+%!assert (nbininv ([x, NaN], 1, 0.5), [NaN 0 1 Inf NaN NaN])
+%!assert (nbininv (single ([x, NaN]), 1, 0.5), single ([NaN 0 1 Inf NaN NaN]))
+%!assert (nbininv ([x, NaN], single (1), 0.5), single ([NaN 0 1 Inf NaN NaN]))
+%!assert (nbininv ([x, NaN], 1, single (0.5)), single ([NaN 0 1 Inf NaN NaN]))
 
 %% Test input validation
 %!error nbininv ()
 %!error nbininv (1)
 %!error nbininv (1,2)
 %!error nbininv (1,2,3,4)
-%!error nbininv (ones(3),ones(2),ones(2))
-%!error nbininv (ones(2),ones(3),ones(2))
-%!error nbininv (ones(2),ones(2),ones(3))
+%!error nbininv (ones (3), ones (2), ones (2))
+%!error nbininv (ones (2), ones (3), ones (2))
+%!error nbininv (ones (2), ones (2), ones (3))
 %!error nbininv (i, 2, 2)
 %!error nbininv (2, i, 2)
 %!error nbininv (2, 2, i)
 
diff --git a/scripts/statistics/distributions/nbinpdf.m b/scripts/statistics/distributions/nbinpdf.m
--- a/scripts/statistics/distributions/nbinpdf.m
+++ b/scripts/statistics/distributions/nbinpdf.m
@@ -71,32 +71,32 @@ function pdf = nbinpdf (x, n, p)
   
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 1 2 Inf];
 %! y = [0 1/2 1/4 1/8 NaN];
-%!assert(nbinpdf (x, ones(1,5), 0.5*ones(1,5)), y);
-%!assert(nbinpdf (x, 1, 0.5*ones(1,5)), y);
-%!assert(nbinpdf (x, ones(1,5), 0.5), y);
-%!assert(nbinpdf (x, [0 1 NaN 1.5 Inf], 0.5), [NaN 1/2 NaN 1.875*0.5^1.5/4 NaN], eps);
-%!assert(nbinpdf (x, 1, 0.5*[-1 NaN 4 1 1]), [NaN NaN NaN y(4:5)]);
-%!assert(nbinpdf ([x, NaN], 1, 0.5), [y, NaN]);
+%!assert (nbinpdf (x, ones (1,5), 0.5*ones (1,5)), y)
+%!assert (nbinpdf (x, 1, 0.5*ones (1,5)), y)
+%!assert (nbinpdf (x, ones (1,5), 0.5), y)
+%!assert (nbinpdf (x, [0 1 NaN 1.5 Inf], 0.5), [NaN 1/2 NaN 1.875*0.5^1.5/4 NaN], eps)
+%!assert (nbinpdf (x, 1, 0.5*[-1 NaN 4 1 1]), [NaN NaN NaN y(4:5)])
+%!assert (nbinpdf ([x, NaN], 1, 0.5), [y, NaN])
 
 %% Test class of input preserved
-%!assert(nbinpdf (single([x, NaN]), 1, 0.5), single([y, NaN]));
-%!assert(nbinpdf ([x, NaN], single(1), 0.5), single([y, NaN]));
-%!assert(nbinpdf ([x, NaN], 1, single(0.5)), single([y, NaN]));
+%!assert (nbinpdf (single ([x, NaN]), 1, 0.5), single ([y, NaN]))
+%!assert (nbinpdf ([x, NaN], single (1), 0.5), single ([y, NaN]))
+%!assert (nbinpdf ([x, NaN], 1, single (0.5)), single ([y, NaN]))
 
 %% Test input validation
 %!error nbinpdf ()
 %!error nbinpdf (1)
 %!error nbinpdf (1,2)
 %!error nbinpdf (1,2,3,4)
-%!error nbinpdf (ones(3),ones(2),ones(2))
-%!error nbinpdf (ones(2),ones(3),ones(2))
-%!error nbinpdf (ones(2),ones(2),ones(3))
+%!error nbinpdf (ones (3), ones (2), ones (2))
+%!error nbinpdf (ones (2), ones (3), ones (2))
+%!error nbinpdf (ones (2), ones (2), ones (3))
 %!error nbinpdf (i, 2, 2)
 %!error nbinpdf (2, i, 2)
 %!error nbinpdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/nbinrnd.m b/scripts/statistics/distributions/nbinrnd.m
--- a/scripts/statistics/distributions/nbinrnd.m
+++ b/scripts/statistics/distributions/nbinrnd.m
@@ -101,40 +101,40 @@ function rnd = nbinrnd (n, p, varargin)
 
     k = (n > 0) & (n < Inf) & (p > 0) & (p <= 1);
     rnd(k) = randp ((1 - p(k)) ./ p(k) .* randg (n(k)));
   endif
 
 endfunction
 
 
-%!assert(size (nbinrnd (2, 1/2)), [1, 1]);
-%!assert(size (nbinrnd (2*ones(2,1), 1/2)), [2, 1]);
-%!assert(size (nbinrnd (2*ones(2,2), 1/2)), [2, 2]);
-%!assert(size (nbinrnd (2, 1/2*ones(2,1))), [2, 1]);
-%!assert(size (nbinrnd (2, 1/2*ones(2,2))), [2, 2]);
-%!assert(size (nbinrnd (2, 1/2, 3)), [3, 3]);
-%!assert(size (nbinrnd (2, 1/2, [4 1])), [4, 1]);
-%!assert(size (nbinrnd (2, 1/2, 4, 1)), [4, 1]);
+%!assert (size (nbinrnd (2, 1/2)), [1, 1])
+%!assert (size (nbinrnd (2*ones (2,1), 1/2)), [2, 1])
+%!assert (size (nbinrnd (2*ones (2,2), 1/2)), [2, 2])
+%!assert (size (nbinrnd (2, 1/2*ones (2,1))), [2, 1])
+%!assert (size (nbinrnd (2, 1/2*ones (2,2))), [2, 2])
+%!assert (size (nbinrnd (2, 1/2, 3)), [3, 3])
+%!assert (size (nbinrnd (2, 1/2, [4 1])), [4, 1])
+%!assert (size (nbinrnd (2, 1/2, 4, 1)), [4, 1])
 
 %% Test class of input preserved
-%!assert(class (nbinrnd (2, 1/2)), "double");
-%!assert(class (nbinrnd (single(2), 1/2)), "single");
-%!assert(class (nbinrnd (single([2 2]), 1/2)), "single");
-%!assert(class (nbinrnd (2, single(1/2))), "single");
-%!assert(class (nbinrnd (2, single([1/2 1/2]))), "single");
+%!assert (class (nbinrnd (2, 1/2)), "double")
+%!assert (class (nbinrnd (single (2), 1/2)), "single")
+%!assert (class (nbinrnd (single ([2 2]), 1/2)), "single")
+%!assert (class (nbinrnd (2, single (1/2))), "single")
+%!assert (class (nbinrnd (2, single ([1/2 1/2]))), "single")
 
 %% Test input validation
 %!error nbinrnd ()
 %!error nbinrnd (1)
-%!error nbinrnd (ones(3),ones(2))
-%!error nbinrnd (ones(2),ones(3))
+%!error nbinrnd (ones (3), ones (2))
+%!error nbinrnd (ones (2), ones (3))
 %!error nbinrnd (i, 2)
 %!error nbinrnd (2, i)
 %!error nbinrnd (1,2, -1)
-%!error nbinrnd (1,2, ones(2))
+%!error nbinrnd (1,2, ones (2))
 %!error nbinrnd (1, 2, [2 -1 2])
-%!error nbinrnd (1,2, 1, ones(2))
+%!error nbinrnd (1,2, 1, ones (2))
 %!error nbinrnd (1,2, 1, -1)
-%!error nbinrnd (ones(2,2), 2, 3)
-%!error nbinrnd (ones(2,2), 2, [3, 2])
-%!error nbinrnd (ones(2,2), 2, 2, 3)
+%!error nbinrnd (ones (2,2), 2, 3)
+%!error nbinrnd (ones (2,2), 2, [3, 2])
+%!error nbinrnd (ones (2,2), 2, 2, 3)
 
diff --git a/scripts/statistics/distributions/normcdf.m b/scripts/statistics/distributions/normcdf.m
--- a/scripts/statistics/distributions/normcdf.m
+++ b/scripts/statistics/distributions/normcdf.m
@@ -68,32 +68,32 @@ function cdf = normcdf (x, mu = 0, sigma
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-Inf 1 2 Inf];
 %! y = [0, 0.5, 1/2*(1+erf(1/sqrt(2))), 1];
-%!assert(normcdf (x, ones(1,4), ones(1,4)), y);
-%!assert(normcdf (x, 1, ones(1,4)), y);
-%!assert(normcdf (x, ones(1,4), 1), y);
-%!assert(normcdf (x, [0 -Inf NaN Inf], 1), [y(1) NaN NaN NaN]);
-%!assert(normcdf (x, 1, [Inf NaN -1 0]), [NaN NaN NaN NaN]);
-%!assert(normcdf ([x(1:2) NaN x(4)], 1, 1), [y(1:2) NaN y(4)]);
+%!assert (normcdf (x, ones (1,4), ones (1,4)), y)
+%!assert (normcdf (x, 1, ones (1,4)), y)
+%!assert (normcdf (x, ones (1,4), 1), y)
+%!assert (normcdf (x, [0 -Inf NaN Inf], 1), [y(1) NaN NaN NaN])
+%!assert (normcdf (x, 1, [Inf NaN -1 0]), [NaN NaN NaN NaN])
+%!assert (normcdf ([x(1:2) NaN x(4)], 1, 1), [y(1:2) NaN y(4)])
 
 %% Test class of input preserved
-%!assert(normcdf ([x, NaN], 1, 1), [y, NaN]);
-%!assert(normcdf (single([x, NaN]), 1, 1), single([y, NaN]), eps("single"));
-%!assert(normcdf ([x, NaN], single(1), 1), single([y, NaN]), eps("single"));
-%!assert(normcdf ([x, NaN], 1, single(1)), single([y, NaN]), eps("single"));
+%!assert (normcdf ([x, NaN], 1, 1), [y, NaN])
+%!assert (normcdf (single ([x, NaN]), 1, 1), single ([y, NaN]), eps ("single"))
+%!assert (normcdf ([x, NaN], single (1), 1), single ([y, NaN]), eps ("single"))
+%!assert (normcdf ([x, NaN], 1, single (1)), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error normcdf ()
 %!error normcdf (1,2)
 %!error normcdf (1,2,3,4)
-%!error normcdf (ones(3),ones(2),ones(2))
-%!error normcdf (ones(2),ones(3),ones(2))
-%!error normcdf (ones(2),ones(2),ones(3))
+%!error normcdf (ones (3), ones (2), ones (2))
+%!error normcdf (ones (2), ones (3), ones (2))
+%!error normcdf (ones (2), ones (2), ones (3))
 %!error normcdf (i, 2, 2)
 %!error normcdf (2, i, 2)
 %!error normcdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/norminv.m b/scripts/statistics/distributions/norminv.m
--- a/scripts/statistics/distributions/norminv.m
+++ b/scripts/statistics/distributions/norminv.m
@@ -62,32 +62,32 @@ function inv = norminv (x, mu = 0, sigma
     inv(k) = mu(k) + sigma(k) .* stdnormal_inv (x(k));
   endif
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
-%!assert(norminv (x, ones(1,5), ones(1,5)), [NaN -Inf 1 Inf NaN]);
-%!assert(norminv (x, 1, ones(1,5)), [NaN -Inf 1 Inf NaN]);
-%!assert(norminv (x, ones(1,5), 1), [NaN -Inf 1 Inf NaN]);
-%!assert(norminv (x, [1 -Inf NaN Inf 1], 1), [NaN NaN NaN NaN NaN]);
-%!assert(norminv (x, 1, [1 0 NaN Inf 1]), [NaN NaN NaN NaN NaN]);
-%!assert(norminv ([x(1:2) NaN x(4:5)], 1, 1), [NaN -Inf NaN Inf NaN]);
+%!assert (norminv (x, ones (1,5), ones (1,5)), [NaN -Inf 1 Inf NaN])
+%!assert (norminv (x, 1, ones (1,5)), [NaN -Inf 1 Inf NaN])
+%!assert (norminv (x, ones (1,5), 1), [NaN -Inf 1 Inf NaN])
+%!assert (norminv (x, [1 -Inf NaN Inf 1], 1), [NaN NaN NaN NaN NaN])
+%!assert (norminv (x, 1, [1 0 NaN Inf 1]), [NaN NaN NaN NaN NaN])
+%!assert (norminv ([x(1:2) NaN x(4:5)], 1, 1), [NaN -Inf NaN Inf NaN])
 
 %% Test class of input preserved
-%!assert(norminv ([x, NaN], 1, 1), [NaN -Inf 1 Inf NaN NaN]);
-%!assert(norminv (single([x, NaN]), 1, 1), single([NaN -Inf 1 Inf NaN NaN]));
-%!assert(norminv ([x, NaN], single(1), 1), single([NaN -Inf 1 Inf NaN NaN]));
-%!assert(norminv ([x, NaN], 1, single(1)), single([NaN -Inf 1 Inf NaN NaN]));
+%!assert (norminv ([x, NaN], 1, 1), [NaN -Inf 1 Inf NaN NaN])
+%!assert (norminv (single ([x, NaN]), 1, 1), single ([NaN -Inf 1 Inf NaN NaN]))
+%!assert (norminv ([x, NaN], single (1), 1), single ([NaN -Inf 1 Inf NaN NaN]))
+%!assert (norminv ([x, NaN], 1, single (1)), single ([NaN -Inf 1 Inf NaN NaN]))
 
 %% Test input validation
 %!error norminv ()
 %!error norminv (1,2)
 %!error norminv (1,2,3,4)
-%!error norminv (ones(3),ones(2),ones(2))
-%!error norminv (ones(2),ones(3),ones(2))
-%!error norminv (ones(2),ones(2),ones(3))
+%!error norminv (ones (3), ones (2), ones (2))
+%!error norminv (ones (2), ones (3), ones (2))
+%!error norminv (ones (2), ones (2), ones (3))
 %!error norminv (i, 2, 2)
 %!error norminv (2, i, 2)
 %!error norminv (2, 2, i)
 
diff --git a/scripts/statistics/distributions/normpdf.m b/scripts/statistics/distributions/normpdf.m
--- a/scripts/statistics/distributions/normpdf.m
+++ b/scripts/statistics/distributions/normpdf.m
@@ -68,31 +68,31 @@ function pdf = normpdf (x, mu = 0, sigma
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-Inf 1 2 Inf];
 %! y = 1/sqrt(2*pi)*exp (-(x-1).^2/2);
-%!assert(normpdf (x, ones(1,4), ones(1,4)), y);
-%!assert(normpdf (x, 1, ones(1,4)), y);
-%!assert(normpdf (x, ones(1,4), 1), y);
-%!assert(normpdf (x, [0 -Inf NaN Inf], 1), [y(1) NaN NaN NaN]);
-%!assert(normpdf (x, 1, [Inf NaN -1 0]), [NaN NaN NaN NaN]);
-%!assert(normpdf ([x, NaN], 1, 1), [y, NaN]);
+%!assert (normpdf (x, ones (1,4), ones (1,4)), y)
+%!assert (normpdf (x, 1, ones (1,4)), y)
+%!assert (normpdf (x, ones (1,4), 1), y)
+%!assert (normpdf (x, [0 -Inf NaN Inf], 1), [y(1) NaN NaN NaN])
+%!assert (normpdf (x, 1, [Inf NaN -1 0]), [NaN NaN NaN NaN])
+%!assert (normpdf ([x, NaN], 1, 1), [y, NaN])
 
 %% Test class of input preserved
-%!assert(normpdf (single([x, NaN]), 1, 1), single([y, NaN]), eps("single"));
-%!assert(normpdf ([x, NaN], single(1), 1), single([y, NaN]), eps("single"));
-%!assert(normpdf ([x, NaN], 1, single(1)), single([y, NaN]), eps("single"));
+%!assert (normpdf (single ([x, NaN]), 1, 1), single ([y, NaN]), eps ("single"))
+%!assert (normpdf ([x, NaN], single (1), 1), single ([y, NaN]), eps ("single"))
+%!assert (normpdf ([x, NaN], 1, single (1)), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error normpdf ()
 %!error normpdf (1,2)
 %!error normpdf (1,2,3,4)
-%!error normpdf (ones(3),ones(2),ones(2))
-%!error normpdf (ones(2),ones(3),ones(2))
-%!error normpdf (ones(2),ones(2),ones(3))
+%!error normpdf (ones (3), ones (2), ones (2))
+%!error normpdf (ones (2), ones (3), ones (2))
+%!error normpdf (ones (2), ones (2), ones (3))
 %!error normpdf (i, 2, 2)
 %!error normpdf (2, i, 2)
 %!error normpdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/normrnd.m b/scripts/statistics/distributions/normrnd.m
--- a/scripts/statistics/distributions/normrnd.m
+++ b/scripts/statistics/distributions/normrnd.m
@@ -92,40 +92,40 @@ function rnd = normrnd (mu, sigma, varar
     rnd = mu + sigma .* randn (sz);
     k = isnan (mu) | isinf (mu) | !(sigma > 0) | !(sigma < Inf);
     rnd(k) = NaN;
   endif
 
 endfunction
 
 
-%!assert(size (normrnd (1,2)), [1, 1]);
-%!assert(size (normrnd (ones(2,1), 2)), [2, 1]);
-%!assert(size (normrnd (ones(2,2), 2)), [2, 2]);
-%!assert(size (normrnd (1, 2*ones(2,1))), [2, 1]);
-%!assert(size (normrnd (1, 2*ones(2,2))), [2, 2]);
-%!assert(size (normrnd (1, 2, 3)), [3, 3]);
-%!assert(size (normrnd (1, 2, [4 1])), [4, 1]);
-%!assert(size (normrnd (1, 2, 4, 1)), [4, 1]);
+%!assert (size (normrnd (1,2)), [1, 1])
+%!assert (size (normrnd (ones (2,1), 2)), [2, 1])
+%!assert (size (normrnd (ones (2,2), 2)), [2, 2])
+%!assert (size (normrnd (1, 2*ones (2,1))), [2, 1])
+%!assert (size (normrnd (1, 2*ones (2,2))), [2, 2])
+%!assert (size (normrnd (1, 2, 3)), [3, 3])
+%!assert (size (normrnd (1, 2, [4 1])), [4, 1])
+%!assert (size (normrnd (1, 2, 4, 1)), [4, 1])
 
 %% Test class of input preserved
-%!assert(class (normrnd (1, 2)), "double");
-%!assert(class (normrnd (single(1), 2)), "single");
-%!assert(class (normrnd (single([1 1]), 2)), "single");
-%!assert(class (normrnd (1, single(2))), "single");
-%!assert(class (normrnd (1, single([2 2]))), "single");
+%!assert (class (normrnd (1, 2)), "double")
+%!assert (class (normrnd (single (1), 2)), "single")
+%!assert (class (normrnd (single ([1 1]), 2)), "single")
+%!assert (class (normrnd (1, single (2))), "single")
+%!assert (class (normrnd (1, single ([2 2]))), "single")
 
 %% Test input validation
 %!error normrnd ()
 %!error normrnd (1)
-%!error normrnd (ones(3),ones(2))
-%!error normrnd (ones(2),ones(3))
+%!error normrnd (ones (3), ones (2))
+%!error normrnd (ones (2), ones (3))
 %!error normrnd (i, 2)
 %!error normrnd (2, i)
 %!error normrnd (1,2, -1)
-%!error normrnd (1,2, ones(2))
+%!error normrnd (1,2, ones (2))
 %!error normrnd (1, 2, [2 -1 2])
-%!error normrnd (1,2, 1, ones(2))
+%!error normrnd (1,2, 1, ones (2))
 %!error normrnd (1,2, 1, -1)
-%!error normrnd (ones(2,2), 2, 3)
-%!error normrnd (ones(2,2), 2, [3, 2])
-%!error normrnd (ones(2,2), 2, 2, 3)
+%!error normrnd (ones (2,2), 2, 3)
+%!error normrnd (ones (2,2), 2, [3, 2])
+%!error normrnd (ones (2,2), 2, 2, 3)
 
diff --git a/scripts/statistics/distributions/poisscdf.m b/scripts/statistics/distributions/poisscdf.m
--- a/scripts/statistics/distributions/poisscdf.m
+++ b/scripts/statistics/distributions/poisscdf.m
@@ -63,28 +63,28 @@ function cdf = poisscdf (x, lambda)
     cdf(k) = 1 - gammainc (lambda(k), floor (x(k)) + 1);
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 1 2 Inf];
-%! y = [0, gammainc(1, (x(2:4) +1), 'upper'), 1];
-%!assert(poisscdf (x, ones(1,5)), y);
-%!assert(poisscdf (x, 1), y);
-%!assert(poisscdf (x, [1 0 NaN 1 1]), [y(1) NaN NaN y(4:5)]);
-%!assert(poisscdf ([x(1:2) NaN Inf x(5)], 1), [y(1:2) NaN 1 y(5)]);
+%! y = [0, gammainc(1, (x(2:4) +1), "upper"), 1];
+%!assert (poisscdf (x, ones (1,5)), y)
+%!assert (poisscdf (x, 1), y)
+%!assert (poisscdf (x, [1 0 NaN 1 1]), [y(1) NaN NaN y(4:5)])
+%!assert (poisscdf ([x(1:2) NaN Inf x(5)], 1), [y(1:2) NaN 1 y(5)])
 
 %% Test class of input preserved
-%!assert(poisscdf ([x, NaN], 1), [y, NaN]);
-%!assert(poisscdf (single([x, NaN]), 1), single([y, NaN]), eps("single"));
-%!assert(poisscdf ([x, NaN], single(1)), single([y, NaN]), eps("single"));
+%!assert (poisscdf ([x, NaN], 1), [y, NaN])
+%!assert (poisscdf (single ([x, NaN]), 1), single ([y, NaN]), eps ("single"))
+%!assert (poisscdf ([x, NaN], single (1)), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error poisscdf ()
 %!error poisscdf (1)
 %!error poisscdf (1,2,3)
-%!error poisscdf (ones(3),ones(2))
-%!error poisscdf (ones(2),ones(3))
+%!error poisscdf (ones (3), ones (2))
+%!error poisscdf (ones (2), ones (3))
 %!error poisscdf (i, 2)
 %!error poisscdf (2, i)
 
diff --git a/scripts/statistics/distributions/poissinv.m b/scripts/statistics/distributions/poissinv.m
--- a/scripts/statistics/distributions/poissinv.m
+++ b/scripts/statistics/distributions/poissinv.m
@@ -77,27 +77,27 @@ function inv = poissinv (x, lambda)
     endif
   endwhile
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
-%!assert(poissinv (x, ones(1,5)), [NaN 0 1 Inf NaN]);
-%!assert(poissinv (x, 1), [NaN 0 1 Inf NaN]);
-%!assert(poissinv (x, [1 0 NaN 1 1]), [NaN NaN NaN Inf NaN]);
-%!assert(poissinv ([x(1:2) NaN x(4:5)], 1), [NaN 0 NaN Inf NaN]);
+%!assert (poissinv (x, ones (1,5)), [NaN 0 1 Inf NaN])
+%!assert (poissinv (x, 1), [NaN 0 1 Inf NaN])
+%!assert (poissinv (x, [1 0 NaN 1 1]), [NaN NaN NaN Inf NaN])
+%!assert (poissinv ([x(1:2) NaN x(4:5)], 1), [NaN 0 NaN Inf NaN])
 
 %% Test class of input preserved
-%!assert(poissinv ([x, NaN], 1), [NaN 0 1 Inf NaN NaN]);
-%!assert(poissinv (single([x, NaN]), 1), single([NaN 0 1 Inf NaN NaN]));
-%!assert(poissinv ([x, NaN], single(1)), single([NaN 0 1 Inf NaN NaN]));
+%!assert (poissinv ([x, NaN], 1), [NaN 0 1 Inf NaN NaN])
+%!assert (poissinv (single ([x, NaN]), 1), single ([NaN 0 1 Inf NaN NaN]))
+%!assert (poissinv ([x, NaN], single (1)), single ([NaN 0 1 Inf NaN NaN]))
 
 %% Test input validation
 %!error poissinv ()
 %!error poissinv (1)
 %!error poissinv (1,2,3)
-%!error poissinv (ones(3),ones(2))
-%!error poissinv (ones(2),ones(3))
+%!error poissinv (ones (3), ones (2))
+%!error poissinv (ones (2), ones (3))
 %!error poissinv (i, 2)
 %!error poissinv (2, i)
 
diff --git a/scripts/statistics/distributions/poisspdf.m b/scripts/statistics/distributions/poisspdf.m
--- a/scripts/statistics/distributions/poisspdf.m
+++ b/scripts/statistics/distributions/poisspdf.m
@@ -60,26 +60,26 @@ function pdf = poisspdf (x, lambda)
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 1 2 Inf];
 %! y = [0, exp(-1)*[1 1 0.5], 0];
-%!assert(poisspdf (x, ones(1,5)), y, eps);
-%!assert(poisspdf (x, 1), y, eps);
-%!assert(poisspdf (x, [1 0 NaN 1 1]), [y(1) NaN NaN y(4:5)], eps);
-%!assert(poisspdf ([x, NaN], 1), [y, NaN], eps);
+%!assert (poisspdf (x, ones (1,5)), y, eps)
+%!assert (poisspdf (x, 1), y, eps)
+%!assert (poisspdf (x, [1 0 NaN 1 1]), [y(1) NaN NaN y(4:5)], eps)
+%!assert (poisspdf ([x, NaN], 1), [y, NaN], eps)
 
 %% Test class of input preserved
-%!assert(poisspdf (single([x, NaN]), 1), single([y, NaN]), eps("single"));
-%!assert(poisspdf ([x, NaN], single(1)), single([y, NaN]), eps("single"));
+%!assert (poisspdf (single ([x, NaN]), 1), single ([y, NaN]), eps ("single"))
+%!assert (poisspdf ([x, NaN], single (1)), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error poisspdf ()
 %!error poisspdf (1)
 %!error poisspdf (1,2,3)
-%!error poisspdf (ones(3),ones(2))
-%!error poisspdf (ones(2),ones(3))
+%!error poisspdf (ones (3), ones (2))
+%!error poisspdf (ones (2), ones (3))
 %!error poisspdf (i, 2)
 %!error poisspdf (2, i)
 
diff --git a/scripts/statistics/distributions/poissrnd.m b/scripts/statistics/distributions/poissrnd.m
--- a/scripts/statistics/distributions/poissrnd.m
+++ b/scripts/statistics/distributions/poissrnd.m
@@ -89,32 +89,32 @@ function rnd = poissrnd (lambda, varargi
 
     k = (lambda > 0) & (lambda < Inf);
     rnd(k) = randp (lambda(k));
   endif
 
 endfunction
 
 
-%!assert(size (poissrnd (2)), [1, 1]);
-%!assert(size (poissrnd (ones(2,1))), [2, 1]);
-%!assert(size (poissrnd (ones(2,2))), [2, 2]);
-%!assert(size (poissrnd (1, 3)), [3, 3]);
-%!assert(size (poissrnd (1, [4 1])), [4, 1]);
-%!assert(size (poissrnd (1, 4, 1)), [4, 1]);
+%!assert (size (poissrnd (2)), [1, 1])
+%!assert (size (poissrnd (ones (2,1))), [2, 1])
+%!assert (size (poissrnd (ones (2,2))), [2, 2])
+%!assert (size (poissrnd (1, 3)), [3, 3])
+%!assert (size (poissrnd (1, [4 1])), [4, 1])
+%!assert (size (poissrnd (1, 4, 1)), [4, 1])
 
 %% Test class of input preserved
-%!assert(class (poissrnd (2)), "double");
-%!assert(class (poissrnd (single(2))), "single");
-%!assert(class (poissrnd (single([2 2]))), "single");
+%!assert (class (poissrnd (2)), "double")
+%!assert (class (poissrnd (single (2))), "single")
+%!assert (class (poissrnd (single ([2 2]))), "single")
 
 %% Test input validation
 %!error poissrnd ()
 %!error poissrnd (1, -1)
-%!error poissrnd (1, ones(2))
-%!error poissrnd (1, 2, ones(2))
+%!error poissrnd (1, ones (2))
+%!error poissrnd (1, 2, ones (2))
 %!error poissrnd (i)
 %!error poissrnd (1, 2, -1)
 %!error poissrnd (1, [2 -1 2])
-%!error poissrnd (ones(2,2), 3)
-%!error poissrnd (ones(2,2), [3, 2])
-%!error poissrnd (ones(2,2), 2, 3)
+%!error poissrnd (ones (2,2), 3)
+%!error poissrnd (ones (2,2), [3, 2])
+%!error poissrnd (ones (2,2), 2, 3)
 
diff --git a/scripts/statistics/distributions/stdnormal_cdf.m b/scripts/statistics/distributions/stdnormal_cdf.m
--- a/scripts/statistics/distributions/stdnormal_cdf.m
+++ b/scripts/statistics/distributions/stdnormal_cdf.m
@@ -40,18 +40,18 @@ function cdf = stdnormal_cdf (x)
   cdf = erfc (x / (-sqrt(2))) / 2;
 
 endfunction
 
 
 %!shared x,y
 %! x = [-Inf 0 1 Inf];
 %! y = [0, 0.5, 1/2*(1+erf(1/sqrt(2))), 1];
-%!assert(stdnormal_cdf ([x, NaN]), [y, NaN]);
+%!assert (stdnormal_cdf ([x, NaN]), [y, NaN])
 
 %% Test class of input preserved
-%!assert(stdnormal_cdf (single([x, NaN])), single([y, NaN]), eps("single"));
+%!assert (stdnormal_cdf (single ([x, NaN])), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error stdnormal_cdf ()
 %!error stdnormal_cdf (1,2)
 %!error stdnormal_cdf (i)
 
diff --git a/scripts/statistics/distributions/stdnormal_inv.m b/scripts/statistics/distributions/stdnormal_inv.m
--- a/scripts/statistics/distributions/stdnormal_inv.m
+++ b/scripts/statistics/distributions/stdnormal_inv.m
@@ -39,19 +39,19 @@ function inv = stdnormal_inv (x)
 
   inv = sqrt (2) * erfinv (2 * x - 1);
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
-%!assert(stdnormal_inv (x), [NaN -Inf 0 Inf NaN]);
+%!assert (stdnormal_inv (x), [NaN -Inf 0 Inf NaN])
 
 %% Test class of input preserved
-%!assert(stdnormal_inv ([x, NaN]), [NaN -Inf 0 Inf NaN NaN]);
-%!assert(stdnormal_inv (single([x, NaN])), single([NaN -Inf 0 Inf NaN NaN]));
+%!assert (stdnormal_inv ([x, NaN]), [NaN -Inf 0 Inf NaN NaN])
+%!assert (stdnormal_inv (single ([x, NaN])), single ([NaN -Inf 0 Inf NaN NaN]))
 
 %% Test input validation
 %!error stdnormal_inv ()
 %!error stdnormal_inv (1,2)
 %!error stdnormal_inv (i)
 
diff --git a/scripts/statistics/distributions/stdnormal_pdf.m b/scripts/statistics/distributions/stdnormal_pdf.m
--- a/scripts/statistics/distributions/stdnormal_pdf.m
+++ b/scripts/statistics/distributions/stdnormal_pdf.m
@@ -40,18 +40,18 @@ function pdf = stdnormal_pdf (x)
   pdf = (2 * pi)^(- 1/2) * exp (- x .^ 2 / 2);
 
 endfunction
 
 
 %!shared x,y
 %! x = [-Inf 0 1 Inf];
 %! y = 1/sqrt(2*pi)*exp (-x.^2/2);
-%!assert(stdnormal_pdf ([x, NaN]), [y, NaN], eps);
+%!assert (stdnormal_pdf ([x, NaN]), [y, NaN], eps)
 
 %% Test class of input preserved
-%!assert(stdnormal_pdf (single([x, NaN])), single([y, NaN]), eps("single"));
+%!assert (stdnormal_pdf (single ([x, NaN])), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error stdnormal_pdf ()
 %!error stdnormal_pdf (1,2)
 %!error stdnormal_pdf (i)
 
diff --git a/scripts/statistics/distributions/stdnormal_rnd.m b/scripts/statistics/distributions/stdnormal_rnd.m
--- a/scripts/statistics/distributions/stdnormal_rnd.m
+++ b/scripts/statistics/distributions/stdnormal_rnd.m
@@ -55,20 +55,20 @@ function rnd = stdnormal_rnd (varargin)
     sz = [varargin{:}];
   endif
 
   rnd = randn (sz);
 
 endfunction
 
 
-%!assert(size (stdnormal_rnd (3)), [3, 3]);
-%!assert(size (stdnormal_rnd ([4 1])), [4, 1]);
-%!assert(size (stdnormal_rnd (4,1)), [4, 1]);
+%!assert (size (stdnormal_rnd (3)), [3, 3])
+%!assert (size (stdnormal_rnd ([4 1])), [4, 1])
+%!assert (size (stdnormal_rnd (4,1)), [4, 1])
 
 %% Test input validation
 %!error stdnormal_rnd ()
 %!error stdnormal_rnd (-1)
-%!error stdnormal_rnd (ones(2))
+%!error stdnormal_rnd (ones (2))
 %!error stdnormal_rnd ([2 -1 2])
-%!error stdnormal_rnd (1, ones(2))
+%!error stdnormal_rnd (1, ones (2))
 %!error stdnormal_rnd (1, -1)
 
diff --git a/scripts/statistics/distributions/tcdf.m b/scripts/statistics/distributions/tcdf.m
--- a/scripts/statistics/distributions/tcdf.m
+++ b/scripts/statistics/distributions/tcdf.m
@@ -68,27 +68,27 @@ function cdf = tcdf (x, n)
   cdf(k) = 1;
 
 endfunction
 
 
 %!shared x,y
 %! x = [-Inf 0 1 Inf];
 %! y = [0 1/2 3/4 1];
-%!assert(tcdf (x, ones(1,4)), y, eps);
-%!assert(tcdf (x, 1), y, eps);
-%!assert(tcdf (x, [0 1 NaN 1]), [NaN 1/2 NaN 1], eps);
-%!assert(tcdf ([x(1:2) NaN x(4)], 1), [y(1:2) NaN y(4)], eps);
+%!assert (tcdf (x, ones (1,4)), y, eps)
+%!assert (tcdf (x, 1), y, eps)
+%!assert (tcdf (x, [0 1 NaN 1]), [NaN 1/2 NaN 1], eps)
+%!assert (tcdf ([x(1:2) NaN x(4)], 1), [y(1:2) NaN y(4)], eps)
 
 %% Test class of input preserved
-%!assert(tcdf ([x, NaN], 1), [y, NaN], eps);
-%!assert(tcdf (single([x, NaN]), 1), single([y, NaN]), eps("single"));
-%!assert(tcdf ([x, NaN], single(1)), single([y, NaN]), eps("single"));
+%!assert (tcdf ([x, NaN], 1), [y, NaN], eps)
+%!assert (tcdf (single ([x, NaN]), 1), single ([y, NaN]), eps ("single"))
+%!assert (tcdf ([x, NaN], single (1)), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error tcdf ()
 %!error tcdf (1)
 %!error tcdf (1,2,3)
-%!error tcdf (ones(3),ones(2))
-%!error tcdf (ones(2),ones(3))
+%!error tcdf (ones (3), ones (2))
+%!error tcdf (ones (2), ones (3))
 %!error tcdf (i, 2)
 %!error tcdf (2, i)
 
diff --git a/scripts/statistics/distributions/tinv.m b/scripts/statistics/distributions/tinv.m
--- a/scripts/statistics/distributions/tinv.m
+++ b/scripts/statistics/distributions/tinv.m
@@ -82,27 +82,27 @@ function inv = tinv (x, n)
     inv(k) = stdnormal_inv (x(k));
   endif
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
-%!assert(tinv (x, ones(1,5)), [NaN -Inf 0 Inf NaN]);
-%!assert(tinv (x, 1), [NaN -Inf 0 Inf NaN], eps);
-%!assert(tinv (x, [1 0 NaN 1 1]), [NaN NaN NaN Inf NaN], eps);
-%!assert(tinv ([x(1:2) NaN x(4:5)], 1), [NaN -Inf NaN Inf NaN]);
+%!assert (tinv (x, ones (1,5)), [NaN -Inf 0 Inf NaN])
+%!assert (tinv (x, 1), [NaN -Inf 0 Inf NaN], eps)
+%!assert (tinv (x, [1 0 NaN 1 1]), [NaN NaN NaN Inf NaN], eps)
+%!assert (tinv ([x(1:2) NaN x(4:5)], 1), [NaN -Inf NaN Inf NaN])
 
 %% Test class of input preserved
-%!assert(tinv ([x, NaN], 1), [NaN -Inf 0 Inf NaN NaN], eps);
-%!assert(tinv (single([x, NaN]), 1), single([NaN -Inf 0 Inf NaN NaN]), eps("single"));
-%!assert(tinv ([x, NaN], single(1)), single([NaN -Inf 0 Inf NaN NaN]), eps("single"));
+%!assert (tinv ([x, NaN], 1), [NaN -Inf 0 Inf NaN NaN], eps)
+%!assert (tinv (single ([x, NaN]), 1), single ([NaN -Inf 0 Inf NaN NaN]), eps ("single"))
+%!assert (tinv ([x, NaN], single (1)), single ([NaN -Inf 0 Inf NaN NaN]), eps ("single"))
 
 %% Test input validation
 %!error tinv ()
 %!error tinv (1)
 %!error tinv (1,2,3)
-%!error tinv (ones(3),ones(2))
-%!error tinv (ones(2),ones(3))
+%!error tinv (ones (3), ones (2))
+%!error tinv (ones (2), ones (3))
 %!error tinv (i, 2)
 %!error tinv (2, i)
 
diff --git a/scripts/statistics/distributions/tpdf.m b/scripts/statistics/distributions/tpdf.m
--- a/scripts/statistics/distributions/tpdf.m
+++ b/scripts/statistics/distributions/tpdf.m
@@ -63,31 +63,31 @@ function pdf = tpdf (x, n)
   endif
 
 endfunction
 
 
 %!test
 %! x = rand (10,1);
 %! y = 1./(pi * (1 + x.^2));
-%! assert(tpdf (x, 1), y, 5*eps);
+%! assert (tpdf (x, 1), y, 5*eps);
 
 %!shared x,y
 %! x = [-Inf 0 0.5 1 Inf];
 %! y = 1./(pi * (1 + x.^2));
-%!assert(tpdf (x, ones(1,5)), y, eps);
-%!assert(tpdf (x, 1), y, eps);
-%!assert(tpdf (x, [0 NaN 1 1 1]), [NaN NaN y(3:5)], eps);
+%!assert (tpdf (x, ones (1,5)), y, eps)
+%!assert (tpdf (x, 1), y, eps)
+%!assert (tpdf (x, [0 NaN 1 1 1]), [NaN NaN y(3:5)], eps)
 
 %% Test class of input preserved
-%!assert(tpdf ([x, NaN], 1), [y, NaN], eps);
-%!assert(tpdf (single([x, NaN]), 1), single([y, NaN]), eps("single"));
-%!assert(tpdf ([x, NaN], single(1)), single([y, NaN]), eps("single"));
+%!assert (tpdf ([x, NaN], 1), [y, NaN], eps)
+%!assert (tpdf (single ([x, NaN]), 1), single ([y, NaN]), eps ("single"))
+%!assert (tpdf ([x, NaN], single (1)), single ([y, NaN]), eps ("single"))
 
 %% Test input validation
 %!error tpdf ()
 %!error tpdf (1)
 %!error tpdf (1,2,3)
-%!error tpdf (ones(3),ones(2))
-%!error tpdf (ones(2),ones(3))
+%!error tpdf (ones (3), ones (2))
+%!error tpdf (ones (2), ones (3))
 %!error tpdf (i, 2)
 %!error tpdf (2, i)
 
diff --git a/scripts/statistics/distributions/trnd.m b/scripts/statistics/distributions/trnd.m
--- a/scripts/statistics/distributions/trnd.m
+++ b/scripts/statistics/distributions/trnd.m
@@ -86,32 +86,32 @@ function rnd = trnd (n, varargin)
 
     k = (n > 0) & (n < Inf);
     rnd(k) = randn (sum (k(:)), 1) ./ sqrt (2*randg (n(k)/2) ./ n(k))(:);
   endif
 
 endfunction
 
 
-%!assert(size (trnd (2)), [1, 1]);
-%!assert(size (trnd (ones(2,1))), [2, 1]);
-%!assert(size (trnd (ones(2,2))), [2, 2]);
-%!assert(size (trnd (1, 3)), [3, 3]);
-%!assert(size (trnd (1, [4 1])), [4, 1]);
-%!assert(size (trnd (1, 4, 1)), [4, 1]);
+%!assert (size (trnd (2)), [1, 1])
+%!assert (size (trnd (ones (2,1))), [2, 1])
+%!assert (size (trnd (ones (2,2))), [2, 2])
+%!assert (size (trnd (1, 3)), [3, 3])
+%!assert (size (trnd (1, [4 1])), [4, 1])
+%!assert (size (trnd (1, 4, 1)), [4, 1])
 
 %% Test class of input preserved
-%!assert(class (trnd (1)), "double");
-%!assert(class (trnd (single(1))), "single");
-%!assert(class (trnd (single([1 1]))), "single");
+%!assert (class (trnd (1)), "double")
+%!assert (class (trnd (single (1))), "single")
+%!assert (class (trnd (single ([1 1]))), "single")
 
 %% Test input validation
 %!error trnd ()
 %!error trnd (1, -1)
-%!error trnd (1, ones(2))
+%!error trnd (1, ones (2))
 %!error trnd (i)
 %!error trnd (1, [2 -1 2])
-%!error trnd (1, 2, ones(2))
+%!error trnd (1, 2, ones (2))
 %!error trnd (1, 2, -1)
-%!error trnd (ones(2,2), 3)
-%!error trnd (ones(2,2), [3, 2])
-%!error trnd (ones(2,2), 2, 3)
+%!error trnd (ones (2,2), 3)
+%!error trnd (ones (2,2), [3, 2])
+%!error trnd (ones (2,2), 2, 3)
 
diff --git a/scripts/statistics/distributions/unidcdf.m b/scripts/statistics/distributions/unidcdf.m
--- a/scripts/statistics/distributions/unidcdf.m
+++ b/scripts/statistics/distributions/unidcdf.m
@@ -63,27 +63,27 @@ function cdf = unidcdf (x, n)
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [0 1 2.5 10 11];
 %! y = [0, 0.1 0.2 1.0 1.0];
-%!assert(unidcdf (x, 10*ones(1,5)), y);
-%!assert(unidcdf (x, 10), y);
-%!assert(unidcdf (x, 10*[0 1 NaN 1 1]), [NaN 0.1 NaN y(4:5)]);
-%!assert(unidcdf ([x(1:2) NaN Inf x(5)], 10), [y(1:2) NaN 1 y(5)]);
+%!assert (unidcdf (x, 10*ones (1,5)), y)
+%!assert (unidcdf (x, 10), y)
+%!assert (unidcdf (x, 10*[0 1 NaN 1 1]), [NaN 0.1 NaN y(4:5)])
+%!assert (unidcdf ([x(1:2) NaN Inf x(5)], 10), [y(1:2) NaN 1 y(5)])
 
 %% Test class of input preserved
-%!assert(unidcdf ([x, NaN], 10), [y, NaN]);
-%!assert(unidcdf (single([x, NaN]), 10), single([y, NaN]));
-%!assert(unidcdf ([x, NaN], single(10)), single([y, NaN]));
+%!assert (unidcdf ([x, NaN], 10), [y, NaN])
+%!assert (unidcdf (single ([x, NaN]), 10), single ([y, NaN]))
+%!assert (unidcdf ([x, NaN], single (10)), single ([y, NaN]))
 
 %% Test input validation
 %!error unidcdf ()
 %!error unidcdf (1)
 %!error unidcdf (1,2,3)
-%!error unidcdf (ones(3),ones(2))
-%!error unidcdf (ones(2),ones(3))
+%!error unidcdf (ones (3), ones (2))
+%!error unidcdf (ones (2), ones (3))
 %!error unidcdf (i, 2)
 %!error unidcdf (2, i)
 
diff --git a/scripts/statistics/distributions/unidinv.m b/scripts/statistics/distributions/unidinv.m
--- a/scripts/statistics/distributions/unidinv.m
+++ b/scripts/statistics/distributions/unidinv.m
@@ -55,27 +55,27 @@ function inv = unidinv (x, n)
     inv(k) = floor (x(k) .* n(k));
   endif
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
-%!assert(unidinv (x, 10*ones(1,5)), [NaN NaN 5 10 NaN], eps);
-%!assert(unidinv (x, 10), [NaN NaN 5 10 NaN], eps);
-%!assert(unidinv (x, 10*[0 1 NaN 1 1]), [NaN NaN NaN 10 NaN], eps);
-%!assert(unidinv ([x(1:2) NaN x(4:5)], 10), [NaN NaN NaN 10 NaN], eps);
+%!assert (unidinv (x, 10*ones (1,5)), [NaN NaN 5 10 NaN], eps)
+%!assert (unidinv (x, 10), [NaN NaN 5 10 NaN], eps)
+%!assert (unidinv (x, 10*[0 1 NaN 1 1]), [NaN NaN NaN 10 NaN], eps)
+%!assert (unidinv ([x(1:2) NaN x(4:5)], 10), [NaN NaN NaN 10 NaN], eps)
 
 %% Test class of input preserved
-%!assert(unidinv ([x, NaN], 10), [NaN NaN 5 10 NaN NaN], eps);
-%!assert(unidinv (single([x, NaN]), 10), single([NaN NaN 5 10 NaN NaN]), eps);
-%!assert(unidinv ([x, NaN], single(10)), single([NaN NaN 5 10 NaN NaN]), eps);
+%!assert (unidinv ([x, NaN], 10), [NaN NaN 5 10 NaN NaN], eps)
+%!assert (unidinv (single ([x, NaN]), 10), single ([NaN NaN 5 10 NaN NaN]), eps)
+%!assert (unidinv ([x, NaN], single (10)), single ([NaN NaN 5 10 NaN NaN]), eps)
 
 %% Test input validation
 %!error unidinv ()
 %!error unidinv (1)
 %!error unidinv (1,2,3)
-%!error unidinv (ones(3),ones(2))
-%!error unidinv (ones(2),ones(3))
+%!error unidinv (ones (3), ones (2))
+%!error unidinv (ones (2), ones (3))
 %!error unidinv (i, 2)
 %!error unidinv (2, i)
 
diff --git a/scripts/statistics/distributions/unidpdf.m b/scripts/statistics/distributions/unidpdf.m
--- a/scripts/statistics/distributions/unidpdf.m
+++ b/scripts/statistics/distributions/unidpdf.m
@@ -62,26 +62,26 @@ function pdf = unidpdf (x, n)
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 1 2 10 11];
 %! y = [0 0 0.1 0.1 0.1 0];
-%!assert(unidpdf (x, 10*ones(1,6)), y);
-%!assert(unidpdf (x, 10), y);
-%!assert(unidpdf (x, 10*[0 NaN 1 1 1 1]), [NaN NaN y(3:6)]);
-%!assert(unidpdf ([x, NaN], 10), [y, NaN]);
+%!assert (unidpdf (x, 10*ones (1,6)), y)
+%!assert (unidpdf (x, 10), y)
+%!assert (unidpdf (x, 10*[0 NaN 1 1 1 1]), [NaN NaN y(3:6)])
+%!assert (unidpdf ([x, NaN], 10), [y, NaN])
 
 %% Test class of input preserved
-%!assert(unidpdf (single([x, NaN]), 10), single([y, NaN]));
-%!assert(unidpdf ([x, NaN], single(10)), single([y, NaN]));
+%!assert (unidpdf (single ([x, NaN]), 10), single ([y, NaN]))
+%!assert (unidpdf ([x, NaN], single (10)), single ([y, NaN]))
 
 %% Test input validation
 %!error unidpdf ()
 %!error unidpdf (1)
 %!error unidpdf (1,2,3)
-%!error unidpdf (ones(3),ones(2))
-%!error unidpdf (ones(2),ones(3))
+%!error unidpdf (ones (3), ones (2))
+%!error unidpdf (ones (2), ones (3))
 %!error unidpdf (i, 2)
 %!error unidpdf (2, i)
 
diff --git a/scripts/statistics/distributions/unidrnd.m b/scripts/statistics/distributions/unidrnd.m
--- a/scripts/statistics/distributions/unidrnd.m
+++ b/scripts/statistics/distributions/unidrnd.m
@@ -86,26 +86,26 @@ function rnd = unidrnd (n, varargin)
 
     k = ! (n > 0 & n == fix (n));
     rnd(k) = NaN;
   endif
 
 endfunction
 
 
-%!assert(size (unidrnd (2)), [1, 1]);
-%!assert(size (unidrnd (ones(2,1))), [2, 1]);
-%!assert(size (unidrnd (ones(2,2))), [2, 2]);
-%!assert(size (unidrnd (10, [4 1])), [4, 1]);
-%!assert(size (unidrnd (10, 4, 1)), [4, 1]);
+%!assert (size (unidrnd (2)), [1, 1])
+%!assert (size (unidrnd (ones (2,1))), [2, 1])
+%!assert (size (unidrnd (ones (2,2))), [2, 2])
+%!assert (size (unidrnd (10, [4 1])), [4, 1])
+%!assert (size (unidrnd (10, 4, 1)), [4, 1])
 
 %% Test class of input preserved
-%!assert(class (unidrnd (2)), "double");
-%!assert(class (unidrnd (single(2))), "single");
-%!assert(class (unidrnd (single([2 2]))), "single");
+%!assert (class (unidrnd (2)), "double")
+%!assert (class (unidrnd (single (2))), "single")
+%!assert (class (unidrnd (single ([2 2]))), "single")
 
 %% Test input validation
 %!error unidrnd ()
 %!error unidrnd (10, [1;2;3])
-%!error unidrnd (10, 2, ones(2))
-%!error unidrnd (10*ones(2), 2, 1)
+%!error unidrnd (10, 2, ones (2))
+%!error unidrnd (10*ones (2), 2, 1)
 %!error unidrnd (i)
 
diff --git a/scripts/statistics/distributions/unifcdf.m b/scripts/statistics/distributions/unifcdf.m
--- a/scripts/statistics/distributions/unifcdf.m
+++ b/scripts/statistics/distributions/unifcdf.m
@@ -67,32 +67,32 @@ function cdf = unifcdf (x, a = 0, b = 1)
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 0.5 1 2] + 1;
 %! y = [0 0 0.5 1 1];
-%!assert(unifcdf (x, ones(1,5), 2*ones(1,5)), y);
-%!assert(unifcdf (x, 1, 2*ones(1,5)), y);
-%!assert(unifcdf (x, ones(1,5), 2), y);
-%!assert(unifcdf (x, [2 1 NaN 1 1], 2), [NaN 0 NaN 1 1]);
-%!assert(unifcdf (x, 1, 2*[0 1 NaN 1 1]), [NaN 0 NaN 1 1]);
-%!assert(unifcdf ([x(1:2) NaN x(4:5)], 1, 2), [y(1:2) NaN y(4:5)]);
+%!assert (unifcdf (x, ones (1,5), 2*ones (1,5)), y)
+%!assert (unifcdf (x, 1, 2*ones (1,5)), y)
+%!assert (unifcdf (x, ones (1,5), 2), y)
+%!assert (unifcdf (x, [2 1 NaN 1 1], 2), [NaN 0 NaN 1 1])
+%!assert (unifcdf (x, 1, 2*[0 1 NaN 1 1]), [NaN 0 NaN 1 1])
+%!assert (unifcdf ([x(1:2) NaN x(4:5)], 1, 2), [y(1:2) NaN y(4:5)])
 
 %% Test class of input preserved
-%!assert(unifcdf ([x, NaN], 1, 2), [y, NaN]);
-%!assert(unifcdf (single([x, NaN]), 1, 2), single([y, NaN]));
-%!assert(unifcdf ([x, NaN], single(1), 2), single([y, NaN]));
-%!assert(unifcdf ([x, NaN], 1, single(2)), single([y, NaN]));
+%!assert (unifcdf ([x, NaN], 1, 2), [y, NaN])
+%!assert (unifcdf (single ([x, NaN]), 1, 2), single ([y, NaN]))
+%!assert (unifcdf ([x, NaN], single (1), 2), single ([y, NaN]))
+%!assert (unifcdf ([x, NaN], 1, single (2)), single ([y, NaN]))
 
 %% Test input validation
 %!error unifcdf ()
 %!error unifcdf (1,2)
 %!error unifcdf (1,2,3,4)
-%!error unifcdf (ones(3),ones(2),ones(2))
-%!error unifcdf (ones(2),ones(3),ones(2))
-%!error unifcdf (ones(2),ones(2),ones(3))
+%!error unifcdf (ones (3), ones (2), ones (2))
+%!error unifcdf (ones (2), ones (3), ones (2))
+%!error unifcdf (ones (2), ones (2), ones (3))
 %!error unifcdf (i, 2, 2)
 %!error unifcdf (2, i, 2)
 %!error unifcdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/unifinv.m b/scripts/statistics/distributions/unifinv.m
--- a/scripts/statistics/distributions/unifinv.m
+++ b/scripts/statistics/distributions/unifinv.m
@@ -60,32 +60,32 @@ function inv = unifinv (x, a = 0, b = 1)
     inv(k) = a(k) + x(k) .* (b(k) - a(k));
   endif
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.5 1 2];
-%!assert(unifinv (x, ones(1,5), 2*ones(1,5)), [NaN 1 1.5 2 NaN]);
-%!assert(unifinv (x, 1, 2*ones(1,5)), [NaN 1 1.5 2 NaN]);
-%!assert(unifinv (x, ones(1,5), 2), [NaN 1 1.5 2 NaN]);
-%!assert(unifinv (x, [1 2 NaN 1 1], 2), [NaN NaN NaN 2 NaN]);
-%!assert(unifinv (x, 1, 2*[1 0 NaN 1 1]), [NaN NaN NaN 2 NaN]);
-%!assert(unifinv ([x(1:2) NaN x(4:5)], 1, 2), [NaN 1 NaN 2 NaN]);
+%!assert (unifinv (x, ones (1,5), 2*ones (1,5)), [NaN 1 1.5 2 NaN])
+%!assert (unifinv (x, 1, 2*ones (1,5)), [NaN 1 1.5 2 NaN])
+%!assert (unifinv (x, ones (1,5), 2), [NaN 1 1.5 2 NaN])
+%!assert (unifinv (x, [1 2 NaN 1 1], 2), [NaN NaN NaN 2 NaN])
+%!assert (unifinv (x, 1, 2*[1 0 NaN 1 1]), [NaN NaN NaN 2 NaN])
+%!assert (unifinv ([x(1:2) NaN x(4:5)], 1, 2), [NaN 1 NaN 2 NaN])
 
 %% Test class of input preserved
-%!assert(unifinv ([x, NaN], 1, 2), [NaN 1 1.5 2 NaN NaN]);
-%!assert(unifinv (single([x, NaN]), 1, 2), single([NaN 1 1.5 2 NaN NaN]));
-%!assert(unifinv ([x, NaN], single(1), 2), single([NaN 1 1.5 2 NaN NaN]));
-%!assert(unifinv ([x, NaN], 1, single(2)), single([NaN 1 1.5 2 NaN NaN]));
+%!assert (unifinv ([x, NaN], 1, 2), [NaN 1 1.5 2 NaN NaN])
+%!assert (unifinv (single ([x, NaN]), 1, 2), single ([NaN 1 1.5 2 NaN NaN]))
+%!assert (unifinv ([x, NaN], single (1), 2), single ([NaN 1 1.5 2 NaN NaN]))
+%!assert (unifinv ([x, NaN], 1, single (2)), single ([NaN 1 1.5 2 NaN NaN]))
 
 %% Test input validation
 %!error unifinv ()
 %!error unifinv (1,2)
 %!error unifinv (1,2,3,4)
-%!error unifinv (ones(3),ones(2),ones(2))
-%!error unifinv (ones(2),ones(3),ones(2))
-%!error unifinv (ones(2),ones(2),ones(3))
+%!error unifinv (ones (3), ones (2), ones (2))
+%!error unifinv (ones (2), ones (3), ones (2))
+%!error unifinv (ones (2), ones (2), ones (3))
 %!error unifinv (i, 2, 2)
 %!error unifinv (2, i, 2)
 %!error unifinv (2, 2, i)
 
diff --git a/scripts/statistics/distributions/unifpdf.m b/scripts/statistics/distributions/unifpdf.m
--- a/scripts/statistics/distributions/unifpdf.m
+++ b/scripts/statistics/distributions/unifpdf.m
@@ -63,31 +63,31 @@ function pdf = unifpdf (x, a = 0, b = 1)
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 0.5 1 2] + 1;
 %! y = [0 1 1 1 0];
-%!assert(unifpdf (x, ones(1,5), 2*ones(1,5)), y);
-%!assert(unifpdf (x, 1, 2*ones(1,5)), y);
-%!assert(unifpdf (x, ones(1,5), 2), y);
-%!assert(unifpdf (x, [2 NaN 1 1 1], 2), [NaN NaN y(3:5)]);
-%!assert(unifpdf (x, 1, 2*[0 NaN 1 1 1]), [NaN NaN y(3:5)]);
-%!assert(unifpdf ([x, NaN], 1, 2), [y, NaN]);
+%!assert (unifpdf (x, ones (1,5), 2*ones (1,5)), y)
+%!assert (unifpdf (x, 1, 2*ones (1,5)), y)
+%!assert (unifpdf (x, ones (1,5), 2), y)
+%!assert (unifpdf (x, [2 NaN 1 1 1], 2), [NaN NaN y(3:5)])
+%!assert (unifpdf (x, 1, 2*[0 NaN 1 1 1]), [NaN NaN y(3:5)])
+%!assert (unifpdf ([x, NaN], 1, 2), [y, NaN])
 
 %% Test class of input preserved
-%!assert(unifpdf (single([x, NaN]), 1, 2), single([y, NaN]));
-%!assert(unifpdf (single([x, NaN]), single(1), 2), single([y, NaN]));
-%!assert(unifpdf ([x, NaN], 1, single(2)), single([y, NaN]));
+%!assert (unifpdf (single ([x, NaN]), 1, 2), single ([y, NaN]))
+%!assert (unifpdf (single ([x, NaN]), single (1), 2), single ([y, NaN]))
+%!assert (unifpdf ([x, NaN], 1, single (2)), single ([y, NaN]))
 
 %% Test input validation
 %!error unifpdf ()
 %!error unifpdf (1,2)
 %!error unifpdf (1,2,3,4)
-%!error unifpdf (ones(3),ones(2),ones(2))
-%!error unifpdf (ones(2),ones(3),ones(2))
-%!error unifpdf (ones(2),ones(2),ones(3))
+%!error unifpdf (ones (3), ones (2), ones (2))
+%!error unifpdf (ones (2), ones (3), ones (2))
+%!error unifpdf (ones (2), ones (2), ones (3))
 %!error unifpdf (i, 2, 2)
 %!error unifpdf (2, i, 2)
 %!error unifpdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/unifrnd.m b/scripts/statistics/distributions/unifrnd.m
--- a/scripts/statistics/distributions/unifrnd.m
+++ b/scripts/statistics/distributions/unifrnd.m
@@ -93,40 +93,40 @@ function rnd = unifrnd (a, b, varargin)
 
     k = !(-Inf < a) | !(a < b) | !(b < Inf);
     rnd(k) = NaN;
   endif
 
 endfunction
 
 
-%!assert(size (unifrnd (1,2)), [1, 1]);
-%!assert(size (unifrnd (ones(2,1), 2)), [2, 1]);
-%!assert(size (unifrnd (ones(2,2), 2)), [2, 2]);
-%!assert(size (unifrnd (1, 2*ones(2,1))), [2, 1]);
-%!assert(size (unifrnd (1, 2*ones(2,2))), [2, 2]);
-%!assert(size (unifrnd (1, 2, 3)), [3, 3]);
-%!assert(size (unifrnd (1, 2, [4 1])), [4, 1]);
-%!assert(size (unifrnd (1, 2, 4, 1)), [4, 1]);
+%!assert (size (unifrnd (1,2)), [1, 1])
+%!assert (size (unifrnd (ones (2,1), 2)), [2, 1])
+%!assert (size (unifrnd (ones (2,2), 2)), [2, 2])
+%!assert (size (unifrnd (1, 2*ones (2,1))), [2, 1])
+%!assert (size (unifrnd (1, 2*ones (2,2))), [2, 2])
+%!assert (size (unifrnd (1, 2, 3)), [3, 3])
+%!assert (size (unifrnd (1, 2, [4 1])), [4, 1])
+%!assert (size (unifrnd (1, 2, 4, 1)), [4, 1])
 
 %% Test class of input preserved
-%!assert(class (unifrnd (1, 2)), "double");
-%!assert(class (unifrnd (single(1), 2)), "single");
-%!assert(class (unifrnd (single([1 1]), 2)), "single");
-%!assert(class (unifrnd (1, single(2))), "single");
-%!assert(class (unifrnd (1, single([2 2]))), "single");
+%!assert (class (unifrnd (1, 2)), "double")
+%!assert (class (unifrnd (single (1), 2)), "single")
+%!assert (class (unifrnd (single ([1 1]), 2)), "single")
+%!assert (class (unifrnd (1, single (2))), "single")
+%!assert (class (unifrnd (1, single ([2 2]))), "single")
 
 %% Test input validation
 %!error unifrnd ()
 %!error unifrnd (1)
-%!error unifrnd (ones(3),ones(2))
-%!error unifrnd (ones(2),ones(3))
+%!error unifrnd (ones (3), ones (2))
+%!error unifrnd (ones (2), ones (3))
 %!error unifrnd (i, 2)
 %!error unifrnd (2, i)
 %!error unifrnd (1,2, -1)
-%!error unifrnd (1,2, ones(2))
+%!error unifrnd (1,2, ones (2))
 %!error unifrnd (1, 2, [2 -1 2])
-%!error unifrnd (1,2, 1, ones(2))
+%!error unifrnd (1,2, 1, ones (2))
 %!error unifrnd (1,2, 1, -1)
-%!error unifrnd (ones(2,2), 2, 3)
-%!error unifrnd (ones(2,2), 2, [3, 2])
-%!error unifrnd (ones(2,2), 2, 2, 3)
+%!error unifrnd (ones (2,2), 2, 3)
+%!error unifrnd (ones (2,2), 2, [3, 2])
+%!error unifrnd (ones (2,2), 2, 2, 3)
 
diff --git a/scripts/statistics/distributions/wblcdf.m b/scripts/statistics/distributions/wblcdf.m
--- a/scripts/statistics/distributions/wblcdf.m
+++ b/scripts/statistics/distributions/wblcdf.m
@@ -83,31 +83,31 @@ function cdf = wblcdf (x, scale = 1, sha
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 0.5 1 Inf];
 %! y = [0, 1-exp(-x(2:4)), 1];
-%!assert(wblcdf (x, ones(1,5), ones(1,5)), y);
-%!assert(wblcdf (x, 1, ones(1,5)), y);
-%!assert(wblcdf (x, ones(1,5), 1), y);
-%!assert(wblcdf (x, [0 1 NaN Inf 1], 1), [NaN 0 NaN NaN 1]);
-%!assert(wblcdf (x, 1, [0 1 NaN Inf 1]), [NaN 0 NaN NaN 1]);
-%!assert(wblcdf ([x(1:2) NaN x(4:5)], 1, 1), [y(1:2) NaN y(4:5)]);
+%!assert (wblcdf (x, ones (1,5), ones (1,5)), y)
+%!assert (wblcdf (x, 1, ones (1,5)), y)
+%!assert (wblcdf (x, ones (1,5), 1), y)
+%!assert (wblcdf (x, [0 1 NaN Inf 1], 1), [NaN 0 NaN NaN 1])
+%!assert (wblcdf (x, 1, [0 1 NaN Inf 1]), [NaN 0 NaN NaN 1])
+%!assert (wblcdf ([x(1:2) NaN x(4:5)], 1, 1), [y(1:2) NaN y(4:5)])
 
 %% Test class of input preserved
-%!assert(wblcdf ([x, NaN], 1, 1), [y, NaN]);
-%!assert(wblcdf (single([x, NaN]), 1, 1), single([y, NaN]));
-%!assert(wblcdf ([x, NaN], single(1), 1), single([y, NaN]));
-%!assert(wblcdf ([x, NaN], 1, single(1)), single([y, NaN]));
+%!assert (wblcdf ([x, NaN], 1, 1), [y, NaN])
+%!assert (wblcdf (single ([x, NaN]), 1, 1), single ([y, NaN]))
+%!assert (wblcdf ([x, NaN], single (1), 1), single ([y, NaN]))
+%!assert (wblcdf ([x, NaN], 1, single (1)), single ([y, NaN]))
 
 %% Test input validation
 %!error wblcdf ()
 %!error wblcdf (1,2,3,4)
-%!error wblcdf (ones(3),ones(2),ones(2))
-%!error wblcdf (ones(2),ones(3),ones(2))
-%!error wblcdf (ones(2),ones(2),ones(3))
+%!error wblcdf (ones (3), ones (2), ones (2))
+%!error wblcdf (ones (2), ones (3), ones (2))
+%!error wblcdf (ones (2), ones (2), ones (3))
 %!error wblcdf (i, 2, 2)
 %!error wblcdf (2, i, 2)
 %!error wblcdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/wblinv.m b/scripts/statistics/distributions/wblinv.m
--- a/scripts/statistics/distributions/wblinv.m
+++ b/scripts/statistics/distributions/wblinv.m
@@ -69,31 +69,31 @@ function inv = wblinv (x, scale = 1, sha
     inv(k) = scale(k) .* (- log (1 - x(k))) .^ (1 ./ shape(k));
   endif
 
 endfunction
 
 
 %!shared x
 %! x = [-1 0 0.63212055882855778 1 2];
-%!assert(wblinv (x, ones(1,5), ones(1,5)), [NaN 0 1 Inf NaN], eps);
-%!assert(wblinv (x, 1, ones(1,5)), [NaN 0 1 Inf NaN], eps);
-%!assert(wblinv (x, ones(1,5), 1), [NaN 0 1 Inf NaN], eps);
-%!assert(wblinv (x, [1 -1 NaN Inf 1], 1), [NaN NaN NaN NaN NaN]);
-%!assert(wblinv (x, 1, [1 -1 NaN Inf 1]), [NaN NaN NaN NaN NaN]);
-%!assert(wblinv ([x(1:2) NaN x(4:5)], 1, 1), [NaN 0 NaN Inf NaN]);
+%!assert (wblinv (x, ones (1,5), ones (1,5)), [NaN 0 1 Inf NaN], eps)
+%!assert (wblinv (x, 1, ones (1,5)), [NaN 0 1 Inf NaN], eps)
+%!assert (wblinv (x, ones (1,5), 1), [NaN 0 1 Inf NaN], eps)
+%!assert (wblinv (x, [1 -1 NaN Inf 1], 1), [NaN NaN NaN NaN NaN])
+%!assert (wblinv (x, 1, [1 -1 NaN Inf 1]), [NaN NaN NaN NaN NaN])
+%!assert (wblinv ([x(1:2) NaN x(4:5)], 1, 1), [NaN 0 NaN Inf NaN])
 
 %% Test class of input preserved
-%!assert(wblinv ([x, NaN], 1, 1), [NaN 0 1 Inf NaN NaN], eps);
-%!assert(wblinv (single([x, NaN]), 1, 1), single([NaN 0 1 Inf NaN NaN]), eps("single"));
-%!assert(wblinv ([x, NaN], single(1), 1), single([NaN 0 1 Inf NaN NaN]), eps("single"));
-%!assert(wblinv ([x, NaN], 1, single(1)), single([NaN 0 1 Inf NaN NaN]), eps("single"));
+%!assert (wblinv ([x, NaN], 1, 1), [NaN 0 1 Inf NaN NaN], eps)
+%!assert (wblinv (single ([x, NaN]), 1, 1), single ([NaN 0 1 Inf NaN NaN]), eps ("single"))
+%!assert (wblinv ([x, NaN], single (1), 1), single ([NaN 0 1 Inf NaN NaN]), eps ("single"))
+%!assert (wblinv ([x, NaN], 1, single (1)), single ([NaN 0 1 Inf NaN NaN]), eps ("single"))
 
 %% Test input validation
 %!error wblinv ()
 %!error wblinv (1,2,3,4)
-%!error wblinv (ones(3),ones(2),ones(2))
-%!error wblinv (ones(2),ones(3),ones(2))
-%!error wblinv (ones(2),ones(2),ones(3))
+%!error wblinv (ones (3), ones (2), ones (2))
+%!error wblinv (ones (2), ones (3), ones (2))
+%!error wblinv (ones (2), ones (2), ones (3))
 %!error wblinv (i, 2, 2)
 %!error wblinv (2, i, 2)
 %!error wblinv (2, 2, i)
 
diff --git a/scripts/statistics/distributions/wblpdf.m b/scripts/statistics/distributions/wblpdf.m
--- a/scripts/statistics/distributions/wblpdf.m
+++ b/scripts/statistics/distributions/wblpdf.m
@@ -83,30 +83,30 @@ function pdf = wblpdf (x, scale = 1, sha
   endif
 
 endfunction
 
 
 %!shared x,y
 %! x = [-1 0 0.5 1 Inf];
 %! y = [0, exp(-x(2:4)), NaN];
-%!assert(wblpdf (x, ones(1,5), ones(1,5)), y);
-%!assert(wblpdf (x, 1, ones(1,5)), y);
-%!assert(wblpdf (x, ones(1,5), 1), y);
-%!assert(wblpdf (x, [0 NaN Inf 1 1], 1), [NaN NaN NaN y(4:5)]);
-%!assert(wblpdf (x, 1, [0 NaN Inf 1 1]), [NaN NaN NaN y(4:5)]);
-%!assert(wblpdf ([x, NaN], 1, 1), [y, NaN]);
+%!assert (wblpdf (x, ones (1,5), ones (1,5)), y)
+%!assert (wblpdf (x, 1, ones (1,5)), y)
+%!assert (wblpdf (x, ones (1,5), 1), y)
+%!assert (wblpdf (x, [0 NaN Inf 1 1], 1), [NaN NaN NaN y(4:5)])
+%!assert (wblpdf (x, 1, [0 NaN Inf 1 1]), [NaN NaN NaN y(4:5)])
+%!assert (wblpdf ([x, NaN], 1, 1), [y, NaN])
 
 %% Test class of input preserved
-%!assert(wblpdf (single([x, NaN]), 1, 1), single([y, NaN]));
-%!assert(wblpdf ([x, NaN], single(1), 1), single([y, NaN]));
-%!assert(wblpdf ([x, NaN], 1, single(1)), single([y, NaN]));
+%!assert (wblpdf (single ([x, NaN]), 1, 1), single ([y, NaN]))
+%!assert (wblpdf ([x, NaN], single (1), 1), single ([y, NaN]))
+%!assert (wblpdf ([x, NaN], 1, single (1)), single ([y, NaN]))
 
 %% Test input validation
 %!error wblpdf ()
 %!error wblpdf (1,2,3,4)
-%!error wblpdf (ones(3),ones(2),ones(2))
-%!error wblpdf (ones(2),ones(3),ones(2))
-%!error wblpdf (ones(2),ones(2),ones(3))
+%!error wblpdf (ones (3), ones (2), ones (2))
+%!error wblpdf (ones (2), ones (3), ones (2))
+%!error wblpdf (ones (2), ones (2), ones (3))
 %!error wblpdf (i, 2, 2)
 %!error wblpdf (2, i, 2)
 %!error wblpdf (2, 2, i)
 
diff --git a/scripts/statistics/distributions/wblrnd.m b/scripts/statistics/distributions/wblrnd.m
--- a/scripts/statistics/distributions/wblrnd.m
+++ b/scripts/statistics/distributions/wblrnd.m
@@ -93,40 +93,40 @@ function rnd = wblrnd (scale, shape, var
 
     k = (scale <= 0) | (scale == Inf) | (shape <= 0) | (shape == Inf);
     rnd(k) = NaN;
   endif
 
 endfunction
 
 
-%!assert(size (wblrnd (1,2)), [1, 1]);
-%!assert(size (wblrnd (ones(2,1), 2)), [2, 1]);
-%!assert(size (wblrnd (ones(2,2), 2)), [2, 2]);
-%!assert(size (wblrnd (1, 2*ones(2,1))), [2, 1]);
-%!assert(size (wblrnd (1, 2*ones(2,2))), [2, 2]);
-%!assert(size (wblrnd (1, 2, 3)), [3, 3]);
-%!assert(size (wblrnd (1, 2, [4 1])), [4, 1]);
-%!assert(size (wblrnd (1, 2, 4, 1)), [4, 1]);
+%!assert (size (wblrnd (1,2)), [1, 1])
+%!assert (size (wblrnd (ones (2,1), 2)), [2, 1])
+%!assert (size (wblrnd (ones (2,2), 2)), [2, 2])
+%!assert (size (wblrnd (1, 2*ones (2,1))), [2, 1])
+%!assert (size (wblrnd (1, 2*ones (2,2))), [2, 2])
+%!assert (size (wblrnd (1, 2, 3)), [3, 3])
+%!assert (size (wblrnd (1, 2, [4 1])), [4, 1])
+%!assert (size (wblrnd (1, 2, 4, 1)), [4, 1])
 
 %% Test class of input preserved
-%!assert(class (wblrnd (1, 2)), "double");
-%!assert(class (wblrnd (single(1), 2)), "single");
-%!assert(class (wblrnd (single([1 1]), 2)), "single");
-%!assert(class (wblrnd (1, single(2))), "single");
-%!assert(class (wblrnd (1, single([2 2]))), "single");
+%!assert (class (wblrnd (1, 2)), "double")
+%!assert (class (wblrnd (single (1), 2)), "single")
+%!assert (class (wblrnd (single ([1 1]), 2)), "single")
+%!assert (class (wblrnd (1, single (2))), "single")
+%!assert (class (wblrnd (1, single ([2 2]))), "single")
 
 %% Test input validation
 %!error wblrnd ()
 %!error wblrnd (1)
-%!error wblrnd (ones(3),ones(2))
-%!error wblrnd (ones(2),ones(3))
+%!error wblrnd (ones (3), ones (2))
+%!error wblrnd (ones (2), ones (3))
 %!error wblrnd (i, 2)
 %!error wblrnd (2, i)
 %!error wblrnd (1,2, -1)
-%!error wblrnd (1,2, ones(2))
+%!error wblrnd (1,2, ones (2))
 %!error wblrnd (1, 2, [2 -1 2])
-%!error wblrnd (1,2, 1, ones(2))
+%!error wblrnd (1,2, 1, ones (2))
 %!error wblrnd (1,2, 1, -1)
-%!error wblrnd (ones(2,2), 2, 3)
-%!error wblrnd (ones(2,2), 2, [3, 2])
-%!error wblrnd (ones(2,2), 2, 2, 3)
+%!error wblrnd (ones (2,2), 2, 3)
+%!error wblrnd (ones (2,2), 2, [3, 2])
+%!error wblrnd (ones (2,2), 2, 2, 3)
 
diff --git a/scripts/statistics/tests/kolmogorov_smirnov_test.m b/scripts/statistics/tests/kolmogorov_smirnov_test.m
--- a/scripts/statistics/tests/kolmogorov_smirnov_test.m
+++ b/scripts/statistics/tests/kolmogorov_smirnov_test.m
@@ -105,22 +105,23 @@ function [pval, ks] = kolmogorov_smirnov
   endif
 
   if (nargout == 0)
     printf ("pval: %g\n", pval);
   endif
 
 endfunction
 
-%!error <Invalid call to kolmogorov_smirnov_test>
-%!  kolmogorov_smirnov_test (1);
-%!error <kolmogorov_smirnov_test: X must be a vector>
-%!  kolmogorov_smirnov_test ({}, "unif", 2, 4);
-%!error <kolmogorov_smirnov_test: no not_a_distcdf or not_a_dist_cdf function found>
+
+## test for recognition of unifcdf function
+%!assert (kolmogorov_smirnov_test (0:100, "unif", 0, 100), 1.0, eps)
+## test for recognition of logistic_cdf function
+%!assert (kolmogorov_smirnov_test (0:100, "logistic"), 0)
+## test for  F < G
+%!assert (kolmogorov_smirnov_test (50:100, "unif", 0, 50, "<"))
+
+%!error kolmogorov_smirnov_test (1)
+%!error <X must be a vector> kolmogorov_smirnov_test ({}, "unif", 2, 4)
+%!error <no not_a_distcdf or not_a_dist_cdf function found>
 %!  kolmogorov_smirnov_test (1, "not_a_dist");
-%!error <kolmogorov_smirnov_test: alternative bla not recognized>
-%!  kolmogorov_smirnov_test (1, "unif", 2, 4, "bla");
-%!test # for recognition of unifcdf function
-%!  assert (kolmogorov_smirnov_test (0:100, "unif", 0, 100), 1.0, eps);
-%!test # for recognition of logistic_cdf function
-%!  assert (kolmogorov_smirnov_test (0:100, "logistic"), 0);
-%!test # F < G
-%!  assert (kolmogorov_smirnov_test (50:100, "unif", 0, 50, "<"));
+%!error <alternative foo not recognized>
+%!  kolmogorov_smirnov_test (1, "unif", 2, 4, "foo");
+
diff --git a/scripts/statistics/tests/kruskal_wallis_test.m b/scripts/statistics/tests/kruskal_wallis_test.m
--- a/scripts/statistics/tests/kruskal_wallis_test.m
+++ b/scripts/statistics/tests/kruskal_wallis_test.m
@@ -89,10 +89,11 @@ function [pval, k, df] = kruskal_wallis_
   pval = 1 - chi2cdf (k, df);
 
   if (nargout == 0)
     printf ("pval: %g\n", pval);
   endif
 
 endfunction
 
+
 ## Test with ties
-%!assert (abs(kruskal_wallis_test([86 86], [74]) - 0.157299207050285) < 0.0000000000001)
+%!assert (abs (kruskal_wallis_test ([86 86], [74]) - 0.157299207050285) < 0.0000000000001)
diff --git a/scripts/strings/base2dec.m b/scripts/strings/base2dec.m
--- a/scripts/strings/base2dec.m
+++ b/scripts/strings/base2dec.m
@@ -93,22 +93,22 @@ function out = base2dec (s, base)
 
   ## Multiply the resulting digits by the appropriate power
   ## and sum the rows.
   out = s * (base .^ (columns(s)-1 : -1 : 0)');
 
 endfunction
 
 
-%!assert(base2dec ("11120", 3), 123);
-%!assert(base2dec ("yyyzx", "xyz"), 123);
-%!assert(base2dec ("-1", 2), NaN);
-%!assert(base2dec ({"A1", "1A"}, 16), [161; 26]);
+%!assert (base2dec ("11120", 3), 123)
+%!assert (base2dec ("yyyzx", "xyz"), 123)
+%!assert (base2dec ("-1", 2), NaN)
+%!assert (base2dec ({"A1", "1A"}, 16), [161; 26])
 
 %%Test input validation
-%!error base2dec ();
-%!error base2dec ("11120");
-%!error base2dec ("11120", 3, 4);
-%!error base2dec ("11120", "1231");
-%!error base2dec ("11120", "12 3");
-%!error base2dec ("11120", ones(2));
-%!error base2dec ("11120", 37);
+%!error base2dec ()
+%!error base2dec ("11120")
+%!error base2dec ("11120", 3, 4)
+%!error base2dec ("11120", "1231")
+%!error base2dec ("11120", "12 3")
+%!error base2dec ("11120", ones (2))
+%!error base2dec ("11120", 37)
 
diff --git a/scripts/strings/bin2dec.m b/scripts/strings/bin2dec.m
--- a/scripts/strings/bin2dec.m
+++ b/scripts/strings/bin2dec.m
@@ -45,18 +45,18 @@ function d = bin2dec (s)
     print_usage ();
   endif
 
   d = base2dec (s, 2);
 
 endfunction
 
 
-%!assert(bin2dec ("0000"), 0);
-%!assert(bin2dec ("1110"), 14);
-%!assert(bin2dec ("11111111111111111111111111111111111111111111111111111"), 2^53-1);
-%!assert(bin2dec ({"1110", "1111"}), [14; 15]);
+%!assert (bin2dec ("0000"), 0)
+%!assert (bin2dec ("1110"), 14)
+%!assert (bin2dec ("11111111111111111111111111111111111111111111111111111"), 2^53-1)
+%!assert (bin2dec ({"1110", "1111"}), [14; 15])
 
 %%Test input validation
-%!error bin2dec ();
-%!error bin2dec (1);
-%!error bin2dec ("1", 2);
+%!error bin2dec ()
+%!error bin2dec (1)
+%!error bin2dec ("1", 2)
 
diff --git a/scripts/strings/blanks.m b/scripts/strings/blanks.m
--- a/scripts/strings/blanks.m
+++ b/scripts/strings/blanks.m
@@ -47,19 +47,19 @@ function s = blanks (n)
   ## If 1:n is empty, the following expression will create an empty
   ## character string.  Otherwise, it will create a row vector.
   s(1:n) = " ";
 
 endfunction
 
 
 ## There really isn't that much to test here
-%!assert(blanks (0), "")
-%!assert(blanks (5), "     ")
-%!assert(blanks (10), "          ")
+%!assert (blanks (0), "")
+%!assert (blanks (5), "     ")
+%!assert (blanks (10), "          ")
 
 %% Test input validation
 %!error blanks ()
 %!error blanks (1, 2)
 %!error blanks (ones (2))
 %!error blanks (2.1)
 %!error blanks (-2)
 
diff --git a/scripts/strings/cstrcat.m b/scripts/strings/cstrcat.m
--- a/scripts/strings/cstrcat.m
+++ b/scripts/strings/cstrcat.m
@@ -59,11 +59,11 @@ endfunction
 %!assert (cstrcat ("ab ", "ab "), "ab ab ")
 ## 2d
 %!assert (cstrcat (["ab ";"cde"], ["ab ";"cde"]), ["ab ab ";"cdecde"])
 
 %!assert (cstrcat ("foo", "bar"), "foobar")
 %!assert (cstrcat (["a"; "bb"], ["foo"; "bar"]), ["a foo"; "bbbar"])
 
 %% Test input validation
-%!error cstrcat ();
-%!error cstrcat (1, 2);
+%!error cstrcat ()
+%!error cstrcat (1, 2)
 
diff --git a/scripts/strings/deblank.m b/scripts/strings/deblank.m
--- a/scripts/strings/deblank.m
+++ b/scripts/strings/deblank.m
@@ -70,20 +70,20 @@ function s = deblank (s)
 
   else
     error ("deblank: S argument must be a string or cellstring");
   endif
 
 endfunction
 
 
-%!assert (deblank (" f o o \0"), " f o o");
-%!assert (deblank ('   '), '');
-%!assert (deblank ("   "), "");
-%!assert (deblank (""), "");
-%!assert (deblank ({}), {});
-%!assert (deblank ({" abc   ", {"   def   "}}), {" abc", {"   def"}});
+%!assert (deblank (" f o o \0"), " f o o")
+%!assert (deblank ('   '), '')
+%!assert (deblank ("   "), "")
+%!assert (deblank (""), "")
+%!assert (deblank ({}), {})
+%!assert (deblank ({" abc   ", {"   def   "}}), {" abc", {"   def"}})
 
-%!error <Invalid call to deblank> deblank ();
-%!error <Invalid call to deblank> deblank ("foo", "bar");
-%!error <argument must be a string> deblank (1);
-%!error <argument must be a string> deblank ({[]});
+%!error <Invalid call to deblank> deblank ()
+%!error <Invalid call to deblank> deblank ("foo", "bar")
+%!error <argument must be a string> deblank (1)
+%!error <argument must be a string> deblank ({[]})
 
diff --git a/scripts/strings/dec2base.m b/scripts/strings/dec2base.m
--- a/scripts/strings/dec2base.m
+++ b/scripts/strings/dec2base.m
@@ -114,47 +114,47 @@ function retval = dec2base (d, base, len
       && length (retval) != 1 && ! any (retval(:,1) != symbols(1)))
     retval = retval(:,2:end);
   endif
 
 endfunction
 
 
 %!test
-%! s0 = '';
+%! s0 = "";
 %! for n = 1:13
 %!   for b = 2:16
 %!     pp = dec2base (b^n+1, b);
-%!     assert (dec2base(b^n, b), ['1',s0,'0']);
-%!     assert (dec2base(b^n+1, b), ['1',s0,'1']);
+%!     assert (dec2base (b^n, b), ['1',s0,'0']);
+%!     assert (dec2base (b^n+1, b), ['1',s0,'1']);
 %!   endfor
 %!   s0 = [s0,'0'];
 %! endfor
 
 %!test
-%! digits='0123456789ABCDEF';
+%! digits = "0123456789ABCDEF";
 %! for n = 1:13
 %!   for b = 2:16
-%!     pm = dec2base(b^n-1, b);
+%!     pm = dec2base (b^n-1, b);
 %!     assert (length (pm), n);
-%!     assert (all (pm==digits(b)));
+%!     assert (all (pm == digits(b)));
 %!   endfor
 %! endfor
 
 %!test
 %! for b = 2:16
 %!   assert (dec2base (0, b), '0');
 %! endfor
 
-%!assert(dec2base (0, 2, 4), "0000");
-%!assert(dec2base (2^51-1, 2), ...
-%!       '111111111111111111111111111111111111111111111111111');
-%!assert(dec2base(uint64(2)^63-1, 16), '7FFFFFFFFFFFFFFF');
-%!assert(dec2base([1, 2; 3, 4], 2, 3), ["001"; "011"; "010"; "100"]);
-%!assert(dec2base({1, 2; 3, 4}, 2, 3), ["001"; "011"; "010"; "100"]);
+%!assert (dec2base (0, 2, 4), "0000")
+%!assert (dec2base (2^51-1, 2), ...
+%!        "111111111111111111111111111111111111111111111111111")
+%!assert (dec2base (uint64 (2)^63-1, 16), "7FFFFFFFFFFFFFFF")
+%!assert (dec2base ([1, 2; 3, 4], 2, 3), ["001"; "011"; "010"; "100"])
+%!assert (dec2base ({1, 2; 3, 4}, 2, 3), ["001"; "011"; "010"; "100"])
 
 %%Test input validation
 %!error dec2base ()
 %!error dec2base (1)
 %!error dec2base (1, 2, 3, 4)
 %!error dec2base ("A")
 %!error dec2base (2i)
 %!error dec2base (-1)
diff --git a/scripts/strings/dec2bin.m b/scripts/strings/dec2bin.m
--- a/scripts/strings/dec2bin.m
+++ b/scripts/strings/dec2bin.m
@@ -48,16 +48,16 @@ function b = dec2bin (d, len)
     b = dec2base (d, 2, len);
   else
     print_usage ();
   endif
 
 endfunction
 
 
-%!assert(dec2bin (14), "1110");
-%!assert(dec2bin (14, 6), "001110");
-%!assert(dec2bin ({1, 2; 3, 4}), ["001"; "011"; "010"; "100"]);
+%!assert (dec2bin (14), "1110")
+%!assert (dec2bin (14, 6), "001110")
+%!assert (dec2bin ({1, 2; 3, 4}), ["001"; "011"; "010"; "100"])
 
 %%Test input validation
-%!error dec2bin ();
-%!error dec2bin (1, 2, 3);
+%!error dec2bin ()
+%!error dec2bin (1, 2, 3)
 
diff --git a/scripts/strings/dec2hex.m b/scripts/strings/dec2hex.m
--- a/scripts/strings/dec2hex.m
+++ b/scripts/strings/dec2hex.m
@@ -48,16 +48,16 @@ function h = dec2hex (d, len)
     h = dec2base (d, 16, len);
   else
     print_usage ();
   endif
 
 endfunction
 
 
-%!assert(dec2hex (2748), "ABC");
-%!assert(dec2hex (2748, 5), "00ABC");
-%!assert(dec2hex ({2748, 2746}), ["ABC"; "ABA"]);
+%!assert (dec2hex (2748), "ABC")
+%!assert (dec2hex (2748, 5), "00ABC")
+%!assert (dec2hex ({2748, 2746}), ["ABC"; "ABA"])
 
 %% Test input validation
-%!error dec2hex ();
-%!error dec2hex (1, 2, 3);
+%!error dec2hex ()
+%!error dec2hex (1, 2, 3)
 
diff --git a/scripts/strings/findstr.m b/scripts/strings/findstr.m
--- a/scripts/strings/findstr.m
+++ b/scripts/strings/findstr.m
@@ -128,16 +128,16 @@ function v = findstr (s, t, overlap = tr
   if (iscolumn (v))
     v = v.';
   endif
 
 endfunction
 
 
 %!assert (findstr ("abababa", "a"), [1, 3, 5, 7])
-%!assert (findstr ("abababa", "aba"), [1, 3, 5]);
-%!assert (findstr ("aba", "abababa", 0), [1, 5]);
+%!assert (findstr ("abababa", "aba"), [1, 3, 5])
+%!assert (findstr ("aba", "abababa", 0), [1, 5])
 
 %% Test input validation
 %!error findstr ()
-%!error findstr ("foo", "bar", 3, 4);
-%!error findstr (["AB" ; "CD"], "C");
+%!error findstr ("foo", "bar", 3, 4)
+%!error <must have only one non-singleton dimension> findstr (["AB" ; "CD"], "C")
 
diff --git a/scripts/strings/hex2dec.m b/scripts/strings/hex2dec.m
--- a/scripts/strings/hex2dec.m
+++ b/scripts/strings/hex2dec.m
@@ -48,18 +48,18 @@ function d = hex2dec (s)
     print_usage ();
   endif
 
   d = base2dec (s, 16);
 
 endfunction
 
 
-%!assert(hex2dec ("0000"), 0);
-%!assert(hex2dec ("1FFFFFFFFFFFFF"), 2^53-1);
-%!assert(hex2dec (["12b"; "12B"]), [299; 299]);
-%!assert(hex2dec ({"A1", "1A"}), [161; 26]);
+%!assert (hex2dec ("0000"), 0)
+%!assert (hex2dec ("1FFFFFFFFFFFFF"), 2^53-1)
+%!assert (hex2dec (["12b"; "12B"]), [299; 299])
+%!assert (hex2dec ({"A1", "1A"}), [161; 26])
 
 %%Test input validation
-%!error hex2dec ();
-%!error hex2dec (1);
-%!error hex2dec ("1", 2);
+%!error hex2dec ()
+%!error hex2dec (1)
+%!error hex2dec ("1", 2)
 
diff --git a/scripts/strings/index.m b/scripts/strings/index.m
--- a/scripts/strings/index.m
+++ b/scripts/strings/index.m
@@ -79,30 +79,31 @@ function n = index (s, t, direction = "f
     endif
   else
     error ('index: DIRECTION must be either "first" or "last"');
   endif
 
 endfunction
 
 
-%!assert (index ("foobarbaz", "b") == 4 && index ("foobarbaz", "z") == 9);
+%!assert (index ("foobarbaz", "b"), 4)
+%!assert (index ("foobarbaz", "z"), 9)
 
-%!assert (index("astringbstringcstring", "s"), 2)
-%!assert (index("astringbstringcstring", "st"), 2)
-%!assert (index("astringbstringcstring", "str"), 2)
-%!assert (index("astringbstringcstring", "string"), 2)
-%!assert (index("abc---", "abc+++"), 0)
+%!assert (index ("astringbstringcstring", "s"), 2)
+%!assert (index ("astringbstringcstring", "st"), 2)
+%!assert (index ("astringbstringcstring", "str"), 2)
+%!assert (index ("astringbstringcstring", "string"), 2)
+%!assert (index ("abc---", "abc+++"), 0)
 
 ## test everything out in reverse
-%!assert (index("astringbstringcstring", "s", "last"), 16)
-%!assert (index("astringbstringcstring", "st", "last"), 16)
-%!assert (index("astringbstringcstring", "str", "last"), 16)
-%!assert (index("astringbstringcstring", "string", "last"), 16)
-%!assert (index("abc---", "abc+++", "last"), 0)
+%!assert (index ("astringbstringcstring", "s", "last"), 16)
+%!assert (index ("astringbstringcstring", "st", "last"), 16)
+%!assert (index ("astringbstringcstring", "str", "last"), 16)
+%!assert (index ("astringbstringcstring", "string", "last"), 16)
+%!assert (index ("abc---", "abc+++", "last"), 0)
 
 %!test
 %! str = char ("Hello", "World", "Goodbye", "World");
 %! assert (index (str, "o"), [5; 2; 2; 2]);
 %! assert (index (str, "o", "last"), [5; 2; 3; 2]);
 %! str = cellstr (str);
 %! assert (index (str, "o"), [5; 2; 2; 2]);
 %! assert (index (str, "o", "last"), [5; 2; 3; 2]);
diff --git a/scripts/strings/isletter.m b/scripts/strings/isletter.m
--- a/scripts/strings/isletter.m
+++ b/scripts/strings/isletter.m
@@ -31,10 +31,12 @@ function retval = isletter (s)
   if (nargin != 1)
     print_usage ();
   endif
 
   retval = isalpha (s);
 
 endfunction
 
-%!error isletter();
-%!error isletter("a", "b");
+
+%!error isletter ()
+%!error isletter ("a", "b")
+
diff --git a/scripts/strings/mat2str.m b/scripts/strings/mat2str.m
--- a/scripts/strings/mat2str.m
+++ b/scripts/strings/mat2str.m
@@ -123,25 +123,25 @@ function s = mat2str (x, n = 15, cls = "
 
   if (strcmp ("class", cls))
     s = cstrcat (class (x), "(", s, ")");
   endif
 
 endfunction
 
 
-%!assert (mat2str (0.7), "0.7");
-%!assert (mat2str (pi), "3.14159265358979");
-%!assert (mat2str (pi, 5), "3.1416");
-%!assert (mat2str (single (pi), 5, "class"), "single(3.1416)");
+%!assert (mat2str (0.7), "0.7")
+%!assert (mat2str (pi), "3.14159265358979")
+%!assert (mat2str (pi, 5), "3.1416")
+%!assert (mat2str (single (pi), 5, "class"), "single(3.1416)")
 %!assert (mat2str ([-1/3 + i/7; 1/3 - i/7], [4 2]), "[-0.3333+0.14i;0.3333-0.14i]")
 %!assert (mat2str ([-1/3 +i/7; 1/3 -i/7], [4 2]), "[-0.3333+0i 0+0.14i;0.3333+0i -0-0.14i]")
-%!assert (mat2str (int16 ([1 -1]), 'class'), "int16([1 -1])")
-%!assert (mat2str (true), "true");
-%!assert (mat2str (false), "false");
-%!assert (mat2str (logical (eye (2))), "[true false;false true]");
+%!assert (mat2str (int16 ([1 -1]), "class"), "int16([1 -1])")
+%!assert (mat2str (true), "true")
+%!assert (mat2str (false), "false")
+%!assert (mat2str (logical (eye (2))), "[true false;false true]")
 
 %% Test input validation
 %!error mat2str ()
 %!error mat2str (1,2,3,4)
 %!error mat2str (["Hello"])
-%!error mat2str (ones(3,3,2))
+%!error <X must be two dimensional> mat2str (ones(3,3,2))
 
diff --git a/scripts/strings/rindex.m b/scripts/strings/rindex.m
--- a/scripts/strings/rindex.m
+++ b/scripts/strings/rindex.m
@@ -47,17 +47,18 @@ function n = rindex (s, t)
     print_usage ();
   endif
 
   n = index (s, t, "last");
 
 endfunction
 
 
-%!assert(rindex ("foobarbaz", "b") == 7 && rindex ("foobarbaz", "o") == 3);
+%!assert (rindex ("foobarbaz", "b"), 7)
+%!assert (rindex ("foobarbaz", "o"), 3)
 
 %!test
 %! str = char ("Hello", "World", "Goodbye", "World");
 %! assert (rindex (str, "o"), [5; 2; 3; 2]);
 %! str = cellstr (str);
 %! assert (rindex (str, "o"), [5; 2; 3; 2]);
 
 %% Test input validation
diff --git a/scripts/strings/str2num.m b/scripts/strings/str2num.m
--- a/scripts/strings/str2num.m
+++ b/scripts/strings/str2num.m
@@ -63,18 +63,18 @@ function [m, state] = str2num (s)
   if (ischar (m))
     m = [];
     state = false;
   endif
 
 endfunction
 
 
-%!assert(str2num ("-1.3e2"), -130);
-%!assert(str2num ("[1, 2; 3, 4]"), [1, 2; 3, 4]);
+%!assert (str2num ("-1.3e2"), -130)
+%!assert (str2num ("[1, 2; 3, 4]"), [1, 2; 3, 4])
 
 %!test
 %! [x, state] = str2num ("pi");
 %! assert (state);
 %! [x, state] = str2num ("Hello World");
 %! assert (! state);
 
 %% Test input validation
diff --git a/scripts/strings/strcat.m b/scripts/strings/strcat.m
--- a/scripts/strings/strcat.m
+++ b/scripts/strings/strcat.m
@@ -91,37 +91,36 @@ function st = strcat (varargin)
   else
     print_usage ();
   endif
 
 endfunction
 
 ## test the dimensionality
 ## 1d
-%!assert(strcat("ab ", "ab "), "abab")
-%!assert(strcat({"ab "}, "ab "), {"ab ab"})
-%!assert(strcat("ab ", {"ab "}), {"abab "})
-%!assert(strcat({"ab "}, {"ab "}), {"ab ab "})
-%!assert(strcat("", "ab"), "ab")
-%!assert(strcat("", {"ab"}, {""}), {"ab"})
+%!assert (strcat ("ab ", "ab "), "abab")
+%!assert (strcat ({"ab "}, "ab "), {"ab ab"})
+%!assert (strcat ("ab ", {"ab "}), {"abab "})
+%!assert (strcat ({"ab "}, {"ab "}), {"ab ab "})
+%!assert (strcat ("", "ab"), "ab")
+%!assert (strcat ("", {"ab"}, {""}), {"ab"})
 ## 2d
-%!assert(strcat(["ab ";"cde"], ["ab ";"cde"]), ["abab  ";"cdecde"])
+%!assert (strcat (["ab ";"cde"], ["ab ";"cde"]), ["abab  ";"cdecde"])
 
 ## test for deblanking implied trailing spaces of character input
-%!assert((strcmp (strcat ("foo", "bar"), "foobar")
-%!        && strcmp (strcat (["a"; "bb"], ["foo"; "bar"]), ["afoo "; "bbbar"])));
+%!assert (strcat ("foo", "bar"), "foobar")
+%!assert (strcat (["a"; "bb"], ["foo"; "bar"]), ["afoo "; "bbbar"])
 
 ## test for mixing character and cell inputs
-%!assert(all (strcmp (strcat ("a", {"bc", "de"}, "f"), {"abcf", "adef"})))
+%!assert (strcat ("a", {"bc", "de"}, "f"), {"abcf", "adef"})
 
 ## test for scalar strings with vector strings
-%!assert(all (strcmp (strcat (["a"; "b"], "c"), ["ac"; "bc"])))
+%!assert (strcat (["a"; "b"], "c"), ["ac"; "bc"])
 
 ## test with cells with strings of differing lengths
-%!assert(all (strcmp (strcat ({"a", "bb"}, "ccc"), {"accc", "bbccc"})))
-%!assert(all (strcmp (strcat ("a", {"bb", "ccc"}), {"abb", "accc"})))
-
-%!error strcat ();
+%!assert (all (strcmp (strcat ({"a", "bb"}, "ccc"), {"accc", "bbccc"})))
+%!assert (all (strcmp (strcat ("a", {"bb", "ccc"}), {"abb", "accc"})))
 
 %!assert (strcat (1, 2), strcat (char(1), char(2)))
+%!assert (strcat ("", 2), strcat ([], char(2)))
 
-%!assert (strcat ('', 2), strcat ([], char(2)))
+%!error strcat ()
 
diff --git a/scripts/strings/strjust.m b/scripts/strings/strjust.m
--- a/scripts/strings/strjust.m
+++ b/scripts/strings/strjust.m
@@ -92,21 +92,21 @@ function y = strjust (s, pos = "right")
   ## Create a blank matrix and position the nonblank characters.
   y = repmat (" ", nr, nc);
   y(sub2ind ([nr, nc], idx, jdx)) = s(nonbl);
 
 endfunction
 
 
 %!assert (strjust (["a"; "ab"; "abc"; "abcd"]),
-%!        ["   a";"  ab"; " abc"; "abcd"]);
+%!        ["   a";"  ab"; " abc"; "abcd"])
 %!assert (strjust ([" a"; "  ab"; "abc"; "abcd"], "left"),
-%!        ["a   "; "ab  "; "abc "; "abcd"]);
+%!        ["a   "; "ab  "; "abc "; "abcd"])
 %!assert (strjust (["a"; "ab"; "abc"; "abcd"], "CENTER"),
-%!        [" a  "; " ab"; "abc "; "abcd"]);
-%!assert (strjust (["";""]), "");
+%!        [" a  "; " ab"; "abc "; "abcd"])
+%!assert (strjust (["";""]), "")
 
 %% Test input validation
 %!error <Invalid call to strjust> strjust ()
 %!error <Invalid call to strjust> strjust (["a";"ab"], "center", 1)
-%!error <S must be a string> strjust (ones(3,3))
-%!error <S must be a string> strjust (char (ones(3,3,3)))
+%!error <S must be a string> strjust (ones (3,3))
+%!error <S must be a string> strjust (char (ones (3,3,3)))
 
diff --git a/scripts/strings/strmatch.m b/scripts/strings/strmatch.m
--- a/scripts/strings/strmatch.m
+++ b/scripts/strings/strmatch.m
@@ -92,28 +92,28 @@ function idx = strmatch (s, A, exact)
       B = regexprep (A(idx), "[ \\0]+$", '');
       idx = idx(strcmp (s, B));
     endif
   endif
 
 endfunction
 
 
-%!assert (strmatch("a", {"aaa", "bab", "bbb"}), 1);
-%!assert (strmatch ("apple", "apple juice"), 1);
-%!assert (strmatch ("apple", ["apple pie"; "apple juice"; "an apple"]), [1; 2]);
-%!assert (strmatch ("apple", {"apple pie"; "apple juice"; "tomato"}), [1; 2]);
-%!assert (strmatch ("apple pie", "apple"), []);
-%!assert (strmatch ("a ", "a"), 1);
-%!assert (strmatch ("a", "a \0", "exact"), 1);
-%!assert (strmatch ("a b", {"a b", "a c", "c d"}), 1);
-%!assert (strmatch ("", {"", "foo", "bar", ""}), [1, 4]);
-%!assert (strmatch ('', { '', '% comment', 'var a = 5', ''}, 'exact'), [1,4]);
+%!assert (strmatch ("a", {"aaa", "bab", "bbb"}), 1)
+%!assert (strmatch ("apple", "apple juice"), 1)
+%!assert (strmatch ("apple", ["apple pie"; "apple juice"; "an apple"]), [1; 2])
+%!assert (strmatch ("apple", {"apple pie"; "apple juice"; "tomato"}), [1; 2])
+%!assert (strmatch ("apple pie", "apple"), [])
+%!assert (strmatch ("a ", "a"), 1)
+%!assert (strmatch ("a", "a \0", "exact"), 1)
+%!assert (strmatch ("a b", {"a b", "a c", "c d"}), 1)
+%!assert (strmatch ("", {"", "foo", "bar", ""}), [1, 4])
+%!assert (strmatch ('', { '', '% comment', 'var a = 5', ''}, 'exact'), [1,4])
 
 %% Test input validation
-%!error <Invalid call to strmatch> strmatch();
-%!error <Invalid call to strmatch> strmatch("a");
-%!error <Invalid call to strmatch> strmatch("a", "aaa", "exact", 1);
-%!error <S must be a string> strmatch(1, "aaa");
-%!error <S must be a string> strmatch(char ("a", "bb"), "aaa");
-%!error <A must be a string> strmatch("a", 1);
-%!error <A must be a string> strmatch("a", {"hello", [1]});
+%!error <Invalid call to strmatch> strmatch ()
+%!error <Invalid call to strmatch> strmatch ("a")
+%!error <Invalid call to strmatch> strmatch ("a", "aaa", "exact", 1)
+%!error <S must be a string> strmatch (1, "aaa")
+%!error <S must be a string> strmatch (char ("a", "bb"), "aaa")
+%!error <A must be a string> strmatch ("a", 1)
+%!error <A must be a string> strmatch ("a", {"hello", [1]})
 
diff --git a/scripts/strings/strsplit.m b/scripts/strings/strsplit.m
--- a/scripts/strings/strsplit.m
+++ b/scripts/strings/strsplit.m
@@ -109,10 +109,10 @@ endfunction
 %!assert (strsplit (["a,bc";",de"], ", ", true), {"a", "bc", "de"})
 
 %% Test input validation
 %!error strsplit ()
 %!error strsplit ("abc")
 %!error strsplit ("abc", "b", true, 4)
 %!error <S and SEP must be string values> strsplit (123, "b")
 %!error <S and SEP must be string values> strsplit ("abc", 1)
-%!error <STRIP_EMPTY must be a scalar value> strsplit ("abc", "def", ones(3,3))
+%!error <STRIP_EMPTY must be a scalar value> strsplit ("abc", "def", ones (3,3))
 
diff --git a/scripts/strings/strtok.m b/scripts/strings/strtok.m
--- a/scripts/strings/strtok.m
+++ b/scripts/strings/strtok.m
@@ -185,40 +185,40 @@ endfunction
 %! assert (t{5}, "this");
 %! assert (r{5}, "");
 %! assert (t{6}, "this");
 %! assert (r{6}, " ");
 %! assert (t{7}, "");
 %! assert (r{7}, "");
 
 %% Simple check for 2, 3, and 4 delimeters
-%!assert(strtok ("this is", "i "), "th");
-%!assert(strtok ("this is", "ij "), "th");
-%!assert(strtok ("this is", "ijk "), "th");
+%!assert (strtok ("this is", "i "), "th")
+%!assert (strtok ("this is", "ij "), "th")
+%!assert (strtok ("this is", "ijk "), "th")
 
 %% Test all cases for 8 delimiters since a different
 %!# algorithm is used when more than 7 delimiters
-%!assert (strtok ("","jklmnop "), "");
-%!assert (strtok ("this","jklmnop "), "this");
-%!assert (strtok ("this ","jklmnop "), "this");
-%!assert (strtok ("this is","jklmnop "), "this");
-%!assert (strtok (" this","jklmnop "), "this");
-%!assert (strtok (" this ","jklmnop "), "this");
-%!assert (strtok (" ","jklmnop "), ""(1:0));
+%!assert (strtok ("","jklmnop "), "")
+%!assert (strtok ("this","jklmnop "), "this")
+%!assert (strtok ("this ","jklmnop "), "this")
+%!assert (strtok ("this is","jklmnop "), "this")
+%!assert (strtok (" this","jklmnop "), "this")
+%!assert (strtok (" this ","jklmnop "), "this")
+%!assert (strtok (" ","jklmnop "), ""(1:0))
 
 %% Test 'bad' string orientations
 %!assert (strtok (" this ".'), "this".');   # delimiter at start and end
 %!assert (strtok (" this ".',"jkl "), "this".');
 
 %% Test with TAB, LF, VT, FF, and CR
 %!test
 %! for ch = "\t\n\v\f\r"
 %!   [t, r] = strtok (cstrcat ("beg", ch, "end"));
 %!   assert (t, "beg");
-%!   assert (r, cstrcat (ch, "end"))
+%!   assert (r, cstrcat (ch, "end"));
 %! endfor
 
 %% Test input validation
 %!error strtok ()
 %!error strtok ("a", "b", "c")
 %!error <STR must be a string> strtok (1, "b")
 %!error <STR cannot be a 2-D> strtok (char ("hello", "world"), "l")
 
diff --git a/scripts/strings/strtrim.m b/scripts/strings/strtrim.m
--- a/scripts/strings/strtrim.m
+++ b/scripts/strings/strtrim.m
@@ -69,20 +69,20 @@ function s = strtrim (s)
 
   else
     error ("strtrim: S argument must be a string or cellstring");
   endif
 
 endfunction
 
 
-%!assert (strtrim ("    abc  "), "abc");
-%!assert (strtrim ("  "), "");
-%!assert (strtrim ("abc"), "abc");
-%!assert (strtrim ([" abc   "; "   def   "]), ["abc  "; "  def"]);
-%!assert (strtrim ({" abc   "; "   def   "}), {"abc"; "def"});
-%!assert (strtrim ({" abc   ", {"   def   "}}), {"abc", {"def"}});
+%!assert (strtrim ("    abc  "), "abc")
+%!assert (strtrim ("  "), "")
+%!assert (strtrim ("abc"), "abc")
+%!assert (strtrim ([" abc   "; "   def   "]), ["abc  "; "  def"])
+%!assert (strtrim ({" abc   "; "   def   "}), {"abc"; "def"})
+%!assert (strtrim ({" abc   ", {"   def   "}}), {"abc", {"def"}})
 
-%!error <Invalid call to strtrim> strtrim ();
-%!error <Invalid call to strtrim> strtrim ("abc", "def");
-%!error <argument must be a string> strtrim (1);
-%!error <argument must be a string> strtrim ({[]});
+%!error <Invalid call to strtrim> strtrim ()
+%!error <Invalid call to strtrim> strtrim ("abc", "def")
+%!error <argument must be a string> strtrim (1)
+%!error <argument must be a string> strtrim ({[]})
 
diff --git a/scripts/strings/strtrunc.m b/scripts/strings/strtrunc.m
--- a/scripts/strings/strtrunc.m
+++ b/scripts/strings/strtrunc.m
@@ -50,22 +50,22 @@ function s = strtrunc (s, n)
     endif
   else
     error ("strtrunc: S must be a character string or a cell array of strings");
   endif
 
 endfunction
 
 
-%!assert (strtrunc("abcdefg", 4), "abcd");
-%!assert (strtrunc("abcdefg", 10), "abcdefg");
-%!assert (strtrunc(char ("abcdef", "fedcba"), 3), ["abc"; "fed"]);
-%!assert (strtrunc({"abcdef", "fedcba"}, 3), {"abc", "fed"});
-%!assert (strtrunc({"", "1", "21", "321"}, 1), {"", "1", "2", "3"})
-%!assert (strtrunc({"1", "", "2"}, 1), {"1", "", "2"})
+%!assert (strtrunc ("abcdefg", 4), "abcd")
+%!assert (strtrunc ("abcdefg", 10), "abcdefg")
+%!assert (strtrunc (char ("abcdef", "fedcba"), 3), ["abc"; "fed"])
+%!assert (strtrunc ({"abcdef", "fedcba"}, 3), {"abc", "fed"})
+%!assert (strtrunc ({"", "1", "21", "321"}, 1), {"", "1", "2", "3"})
+%!assert (strtrunc ({"1", "", "2"}, 1), {"1", "", "2"})
 %!test
 %! cstr = {"line1"; ["line2"; "line3"]; "line4"};
 %! y = strtrunc (cstr, 4);
 %! assert (size (y), [3, 1]); 
 %! assert (size (y{2}), [2, 4]); 
 %! assert (y{2}, repmat ("line", 2, 1));
 
 %% Test input validation
diff --git a/scripts/strings/substr.m b/scripts/strings/substr.m
--- a/scripts/strings/substr.m
+++ b/scripts/strings/substr.m
@@ -87,22 +87,22 @@ function t = substr (s, offset, len)
     error ("substr: No overlap with chosen values of OFFSET and LEN");
   endif
 
   t = s(:, offset:eos);
 
 endfunction
 
 
-%!assert (substr ("This is a test string", 6, 9), "is a test");
-%!assert (substr ("This is a test string", -11), "test string");
-%!assert (substr ("This is a test string", -11, 4), "test");
-%!assert (substr ("This is a test string", -11, -7), "test");
-%!assert (substr ("This is a test string", 1, -7), "This is a test");
-%!assert (isempty (substr ("This is a test string", 1, 0)));
+%!assert (substr ("This is a test string", 6, 9), "is a test")
+%!assert (substr ("This is a test string", -11), "test string")
+%!assert (substr ("This is a test string", -11, 4), "test")
+%!assert (substr ("This is a test string", -11, -7), "test")
+%!assert (substr ("This is a test string", 1, -7), "This is a test")
+%!assert (isempty (substr ("This is a test string", 1, 0)))
 
 %% Test input validation
 %!error substr ()
 %!error substr ("foo", 2, 3, 4)
 %!error substr (ones (5, 1), 1, 1)
 %!error substr ("foo", ones(2,2))
 %!error substr ("foo", 1, ones(2,2))
 %!error substr ("foo", 0)
diff --git a/scripts/strings/validatestring.m b/scripts/strings/validatestring.m
--- a/scripts/strings/validatestring.m
+++ b/scripts/strings/validatestring.m
@@ -133,22 +133,23 @@ function str = validatestring (str, stra
              errstr, str, sprintf ("%s, ", strarray{match_idx})(1:end-2));
     endif
   endif
 
 endfunction
 
 
 %!shared strarray
-%!  strarray = {"octave" "Oct" "octopus" "octaves"};
+%! strarray = {"octave" "Oct" "octopus" "octaves"};
 %!assert (validatestring ("octave", strarray), "octave")
 %!assert (validatestring ("oct", strarray), "Oct")
 %!assert (validatestring ("octa", strarray), "octave")
-%!  strarray = {"abc1" "def" "abc2"};
+%! strarray = {"abc1" "def" "abc2"};
 %!assert (validatestring ("d", strarray), "def")
+
 %!error <'xyz' does not match any> validatestring ("xyz", strarray)
 %!error <Function: DUMMY_TEST> validatestring ("xyz", strarray, "DUMMY_TEST")
 %!error <Function: DUMMY_TEST Variable: DUMMY_VAR:> validatestring ("xyz", strarray, "DUMMY_TEST", "DUMMY_VAR")
 %!error <Function: DUMMY_TEST Variable: DUMMY_VAR Argument position 5> validatestring ("xyz", strarray, "DUMMY_TEST", "DUMMY_VAR", 5)
 %!error <multiple unique matches were found for 'abc'> validatestring ("abc", strarray)
 
 %% Test input validation
 %!error validatestring ("xyz")
diff --git a/scripts/testfun/demo.m b/scripts/testfun/demo.m
--- a/scripts/testfun/demo.m
+++ b/scripts/testfun/demo.m
@@ -144,14 +144,15 @@ function demo (name, n)
   endfor
 
 endfunction
 
 
 %!demo
 %! t = 0:0.01:2*pi;
 %! x = sin (t);
-%! plot (t,x);
+%! plot (t, x);
 %! %-------------------------------------------------
 %! % the figure window shows one cycle of a sine wave
 
-%!error demo ();
-%!error demo (1, 2, 3);
+%!error demo ()
+%!error demo (1, 2, 3)
+
diff --git a/scripts/testfun/example.m b/scripts/testfun/example.m
--- a/scripts/testfun/example.m
+++ b/scripts/testfun/example.m
@@ -81,26 +81,26 @@ function [code_r, idx_r] = example (name
     endfor
   endif
 
 endfunction
 
 
 ## WARNING: don't modify the demos without modifying the tests!
 %!demo
-%! example ('example');
+%! example ("example");
 
 %!demo
 %! clf;
-%! t=0:0.01:2*pi; x = sin(t);
+%! t = 0:0.01:2*pi;  x = sin (t);
 %! plot (t,x)
 
-%!assert (example('example',1), "\n example ('example');");
+%!assert (example ("example",1), "\n example (\"example\");");
 %!test
-%! [code, idx] = example ('example');
+%! [code, idx] = example ("example");
 %! assert (code, ...
-%!         "\n example ('example');\n clf;\n t=0:0.01:2*pi; x = sin(t);\n plot (t,x)")
-%! assert (idx, [1, 23, 69]);
+%!         "\n example (\"example\");\n clf;\n t = 0:0.01:2*pi;  x = sin (t);\n plot (t,x)")
+%! assert (idx, [1, 23, 73]);
 
 %% Test input validation
 %!error example
-%!error example ('example', 3, 5)
+%!error example ("example", 3, 5)
 
diff --git a/scripts/testfun/fail.m b/scripts/testfun/fail.m
--- a/scripts/testfun/fail.m
+++ b/scripts/testfun/fail.m
@@ -125,20 +125,21 @@ function ret = fail (code, pattern, warn
   endif
 
   ## If we get here, then code didn't fail or error didn't match.
   error (msg);
 
 endfunction
 
 
-%!fail ('[1,2]*[2,3]', 'nonconformant')
+%!fail ("[1,2]*[2,3]", "nonconformant")
 %!fail ("fail('[1,2]*[2;3]', 'nonconformant')", "expected error <nonconformant> but got none")
 %!fail ("fail('[1,2]*[2,3]','usage:')", "expected error <usage:>\nbut got.*nonconformant")
-%!fail ("warning('test warning')", 'warning','test warning');
+%!fail ("warning('test warning')", "warning", "test warning");
 
 ##% !fail ("warning('next test')",'warning','next test');  ## only allowed one warning test?!?
 
 %% Test that fail() itself will generate an error
-%!error fail ("1");
-%!error <undefined> fail ('a*[2;3]', 'nonconformant')
-%!error <expected error>  fail ('a*[2,3]', 'usage:')
-%!error <warning failure> fail ("warning('warning failure')", 'warning', 'success')
+%!error fail ("1")
+%!error <undefined> fail ("a*[2;3]", "nonconformant")
+%!error <expected error>  fail ("a*[2,3]", "usage:")
+%!error <warning failure> fail ("warning('warning failure')", "warning", "success")
+
diff --git a/scripts/testfun/speed.m b/scripts/testfun/speed.m
--- a/scripts/testfun/speed.m
+++ b/scripts/testfun/speed.m
@@ -351,73 +351,73 @@ endfunction
 
 
 %% FIXME: Demos with declared functions do not work.  See bug #31815.
 %%        A workaround has been hacked by not declaring the functions
 %%        but using eval to create them in the proper context.
 %%        Unfortunately, we can't remove them from the user's workspace
 %%        because of another bug (#34497).
 %!demo
-%!  fstr_build_orig = cstrcat (
-%!    "function x = build_orig (n)\n",
-%!    "  ## extend the target vector on the fly\n",
-%!    "  for i=0:n-1, x([1:100]+i*100) = 1:100; endfor\n",
-%!    "endfunction");
-%!  fstr_build = cstrcat (
-%!    "function x = build (n)\n",
-%!    "  ## preallocate the target vector\n",
-%!    "  x = zeros (1, n*100);\n",
-%!    "  for i=0:n-1, x([1:100]+i*100) = 1:100; endfor\n",
-%!    "endfunction");
+%! fstr_build_orig = cstrcat (
+%!   "function x = build_orig (n)\n",
+%!   "  ## extend the target vector on the fly\n",
+%!   "  for i=0:n-1, x([1:100]+i*100) = 1:100; endfor\n",
+%!   "endfunction");
+%! fstr_build = cstrcat (
+%!   "function x = build (n)\n",
+%!   "  ## preallocate the target vector\n",
+%!   "  x = zeros (1, n*100);\n",
+%!   "  for i=0:n-1, x([1:100]+i*100) = 1:100; endfor\n",
+%!   "endfunction");
 %!
-%!  disp ("-----------------------");
-%!  disp (fstr_build_orig);
-%!  disp ("-----------------------");
-%!  disp (fstr_build);
-%!  disp ("-----------------------");
+%! disp ("-----------------------");
+%! disp (fstr_build_orig);
+%! disp ("-----------------------");
+%! disp (fstr_build);
+%! disp ("-----------------------");
 %!
-%!  ## Eval functions strings to create them in the current context
-%!  eval (fstr_build_orig);
-%!  eval (fstr_build);
+%! ## Eval functions strings to create them in the current context
+%! eval (fstr_build_orig);
+%! eval (fstr_build);
 %!
-%!  disp ("Preallocated vector test.\nThis takes a little while...");
-%!  speed("build (n)", "", 1000, "build_orig (n)");
-%!  clear -f build build_orig
-%!  disp ("-----------------------");
-%!  disp ("Note how much faster it is to pre-allocate a vector.");
-%!  disp ("Notice the peak speedup ratio.");
+%! disp ("Preallocated vector test.\nThis takes a little while...");
+%! speed("build (n)", "", 1000, "build_orig (n)");
+%! clear -f build build_orig
+%! disp ("-----------------------");
+%! disp ("Note how much faster it is to pre-allocate a vector.");
+%! disp ("Notice the peak speedup ratio.");
 
 %!demo
-%!  fstr_build_orig = cstrcat (
-%!    "function x = build_orig (n)\n",
-%!    "  for i=0:n-1, x([1:100]+i*100) = 1:100; endfor\n",
-%!    "endfunction");
-%!  fstr_build = cstrcat (
-%!    "function x = build (n)\n",
-%!    "  idx = [1:100]';\n",
-%!    "  x = idx(:,ones(1,n));\n",
-%!    "  x = reshape (x, 1, n*100);\n",
-%!    "endfunction");
+%! fstr_build_orig = cstrcat (
+%!   "function x = build_orig (n)\n",
+%!   "  for i=0:n-1, x([1:100]+i*100) = 1:100; endfor\n",
+%!   "endfunction");
+%! fstr_build = cstrcat (
+%!   "function x = build (n)\n",
+%!   "  idx = [1:100]';\n",
+%!   "  x = idx(:,ones(1,n));\n",
+%!   "  x = reshape (x, 1, n*100);\n",
+%!   "endfunction");
 %!
-%!  disp ("-----------------------");
-%!  disp (fstr_build_orig);
-%!  disp ("-----------------------");
-%!  disp (fstr_build);
-%!  disp ("-----------------------");
+%! disp ("-----------------------");
+%! disp (fstr_build_orig);
+%! disp ("-----------------------");
+%! disp (fstr_build);
+%! disp ("-----------------------");
 %!
-%!  ## Eval functions strings to create them in the current context
-%!  eval (fstr_build_orig);
-%!  eval (fstr_build);
+%! ## Eval functions strings to create them in the current context
+%! eval (fstr_build_orig);
+%! eval (fstr_build);
 %!
-%!  disp ("Vectorized test.\nThis takes a little while...");
-%!  speed("build (n)", "", 1000, "build_orig (n)");
-%!  clear -f build build_orig
-%!  disp ("-----------------------");
-%!  disp ("This time, the for loop is done away with entirely.");
-%!  disp ("Notice how much bigger the speedup is than in example 1.");
+%! disp ("Vectorized test.\nThis takes a little while...");
+%! speed("build (n)", "", 1000, "build_orig (n)");
+%! clear -f build build_orig
+%! disp ("-----------------------");
+%! disp ("This time, the for loop is done away with entirely.");
+%! disp ("Notice how much bigger the speedup is than in example 1.");
 
 %!test
 %! [order, n, T_f1, T_f2] = speed ("airy (x)", "x = rand (n, 10)", [100, 1000]);
 %! assert (isstruct (order));
 %! assert (size (order), [1, 1]);
 %! assert (fieldnames (order), {"p"; "a"});
 %! assert (isnumeric (n));
 %! assert (length (n) > 10);
@@ -436,11 +436,11 @@ endfunction
 %! assert (isnumeric (n));
 %! assert (length (n) > 10);
 %! assert (isnumeric (T_f1));
 %! assert (size (T_f1), size (n));
 %! assert (isnumeric (T_f2));
 %! assert (length (T_f2) > 10);
 
 %% Test input validation
-%!error speed ();
-%!error speed (1, 2, 3, 4, 5, 6, 7);
+%!error speed ()
+%!error speed (1, 2, 3, 4, 5, 6, 7)
 
diff --git a/scripts/time/addtodate.m b/scripts/time/addtodate.m
--- a/scripts/time/addtodate.m
+++ b/scripts/time/addtodate.m
@@ -72,17 +72,17 @@ function d = addtodate (d, q, f)
     error ("addtodate: Invalid time unit: %s", f);
   endif
 
 endfunction
 
 
 ## tests
 %!shared d
-%!  d = datenum (2008, 1, 1);
+%! d = datenum (2008, 1, 1);
 ## Identity
 %!assert (addtodate (d, 0, "year"), d)
 %!assert (addtodate (d, 0, "month"), d)
 %!assert (addtodate (d, 0, "day"), d)
 %!assert (addtodate (d, 0, "hour"), d)
 %!assert (addtodate (d, 0, "minute"), d)
 %!assert (addtodate (d, 0, "second"), d)
 %!assert (addtodate (d, 0, "millisecond"), d)
diff --git a/scripts/time/asctime.m b/scripts/time/asctime.m
--- a/scripts/time/asctime.m
+++ b/scripts/time/asctime.m
@@ -42,13 +42,13 @@ function retval = asctime (tm_struct)
 
   retval = strftime ("%a %b %d %H:%M:%S %Y\n", tm_struct);
 
 endfunction
 
 
 %!test
 %! t = time ();
-%! assert(strcmp (asctime (localtime (t)), ctime (t)));
+%! assert (strcmp (asctime (localtime (t)), ctime (t)));
 
-%!error asctime ();
-%!error asctime (1, 2);
+%!error asctime ()
+%!error asctime (1, 2)
 
diff --git a/scripts/time/clock.m b/scripts/time/clock.m
--- a/scripts/time/clock.m
+++ b/scripts/time/clock.m
@@ -52,10 +52,10 @@ function retval = clock ()
   retval(5) = tm.min;
   retval(6) = tm.sec + tm.usec / 1e6;
 
 endfunction
 
 %!test
 %! t1 = clock;
 %! t2 = str2num (strftime ("[%Y, %m, %d, %H, %M, %S]", localtime (time ())));
-%! assert(etime (t1, t2) < 1);
+%! assert (etime (t1, t2) < 1);
 
diff --git a/scripts/time/ctime.m b/scripts/time/ctime.m
--- a/scripts/time/ctime.m
+++ b/scripts/time/ctime.m
@@ -42,13 +42,13 @@ function retval = ctime (t)
 
   retval = asctime (localtime (t));
 
 endfunction
 
 
 %!test
 %! t = time ();
-%! assert(strcmp (asctime (localtime (t)), ctime (t)));
+%! assert (strcmp (asctime (localtime (t)), ctime (t)));
 
-%!error ctime ();
-%!error ctime (1, 2);
+%!error ctime ()
+%!error ctime (1, 2)
 
diff --git a/scripts/time/date.m b/scripts/time/date.m
--- a/scripts/time/date.m
+++ b/scripts/time/date.m
@@ -34,10 +34,11 @@
 ## Author: jwe
 
 function retval = date ()
 
   retval = strftime ("%d-%b-%Y", localtime (time ()));
 
 endfunction
 
-%!assert(strcmp (date (), strftime ("%d-%b-%Y", localtime (time ()))));
 
+%!assert (strcmp (date (), strftime ("%d-%b-%Y", localtime (time ()))))
+
diff --git a/scripts/time/datenum.m b/scripts/time/datenum.m
--- a/scripts/time/datenum.m
+++ b/scripts/time/datenum.m
@@ -154,29 +154,29 @@ endfunction
 %! n = [730990; 517712] + part;
 %! assert (datenum (t), n, 2*eps);
 %! ## Check that vectors can have either orientation
 %! t = t';
 %! n = n';
 %! assert (datenum (t(1,:), t(2,:), t(3,:), t(4,:), t(5,:), t(6,:)), n, 2*eps);
 
 ## Test mixed vectors and scalars
-%!assert (datenum([2008;2009], 1, 1), [datenum(2008, 1, 1);datenum(2009, 1, 1)]);
-%!assert (datenum(2008, [1;2], 1), [datenum(2008, 1, 1);datenum(2008, 2, 1)]);
-%!assert (datenum(2008, 1, [1;2]), [datenum(2008, 1, 1);datenum(2008, 1, 2)]);
-%!assert (datenum([2008;2009], [1;2], 1), [datenum(2008, 1, 1);datenum(2009, 2, 1)]);
-%!assert (datenum([2008;2009], 1, [1;2]), [datenum(2008, 1, 1);datenum(2009, 1, 2)]);
-%!assert (datenum(2008, [1;2], [1;2]), [datenum(2008, 1, 1);datenum(2008, 2, 2)]);
+%!assert (datenum ([2008;2009],1,1), [datenum(2008,1,1);datenum(2009,1,1)])
+%!assert (datenum (2008, [1;2], 1), [datenum(2008,1,1);datenum(2008,2,1)])
+%!assert (datenum (2008, 1, [1;2]), [datenum(2008,1,1);datenum(2008,1,2)])
+%!assert (datenum ([2008;2009], [1;2], 1), [datenum(2008,1,1);datenum(2009,2,1)])
+%!assert (datenum ([2008;2009], 1, [1;2]), [datenum(2008,1,1);datenum(2009,1,2)])
+%!assert (datenum (2008, [1;2], [1;2]), [datenum(2008,1,1);datenum(2008,2,2)])
 ## And the other orientation
-%!assert (datenum([2008 2009], 1, 1), [datenum(2008, 1, 1) datenum(2009, 1, 1)]);
-%!assert (datenum(2008, [1 2], 1), [datenum(2008, 1, 1) datenum(2008, 2, 1)]);
-%!assert (datenum(2008, 1, [1 2]), [datenum(2008, 1, 1) datenum(2008, 1, 2)]);
-%!assert (datenum([2008 2009], [1 2], 1), [datenum(2008, 1, 1) datenum(2009, 2, 1)]);
-%!assert (datenum([2008 2009], 1, [1 2]), [datenum(2008, 1, 1) datenum(2009, 1, 2)]);
-%!assert (datenum(2008, [1 2], [1 2]), [datenum(2008, 1, 1) datenum(2008, 2, 2)]);
+%!assert (datenum ([2008 2009], 1, 1), [datenum(2008,1,1) datenum(2009,1,1)])
+%!assert (datenum (2008, [1 2], 1), [datenum(2008,1,1) datenum(2008,2,1)])
+%!assert (datenum (2008, 1, [1 2]), [datenum(2008,1,1) datenum(2008,1,2)])
+%!assert (datenum ([2008 2009], [1 2], 1), [datenum(2008,1,1) datenum(2009,2,1)])
+%!assert (datenum ([2008 2009], 1, [1 2]), [datenum(2008,1,1) datenum(2009,1,2)])
+%!assert (datenum (2008, [1 2], [1 2]), [datenum(2008,1,1) datenum(2008,2,2)])
 ## Test string and cellstr inputs
 %!assert (datenum ("5/19/2001"), 730990)
 %!assert (datenum ({"5/19/2001"}), 730990)
 %!assert (datenum (char ("5/19/2001", "6/6/1944")), [730990; 710189])
 %!assert (datenum ({"5/19/2001", "6/6/1944"}), [730990; 710189])
 
 %% Test input validation
 %!error datenum ()
diff --git a/scripts/time/datetick.m b/scripts/time/datetick.m
--- a/scripts/time/datetick.m
+++ b/scripts/time/datetick.m
@@ -60,17 +60,17 @@ endfunction
 %!demo
 %! clf;
 %! yr = 1988:2:2002;
 %! yr = datenum (yr,1,1);
 %! pr = [12.1 13.3 12.6 13.1 13.3 14.1 14.4 15.2];
 %! plot (yr, pr);
 %! xlabel ("year");
 %! ylabel ("average price");
-%! ax = gca ();
+%! ax = gca;
 %! set (ax, "xtick", datenum (1990:5:2005,1,1));
 %! datetick (2, "keepticks");
 %! set (ax, "ytick", 12:16);
 
 ## Remove from test statistics.  No real tests possible.
 %!assert (1)
 
 function __datetick__ (varargin)
diff --git a/scripts/time/datevec.m b/scripts/time/datevec.m
--- a/scripts/time/datevec.m
+++ b/scripts/time/datevec.m
@@ -292,13 +292,13 @@ endfunction
 %!assert (datevec ("15:38"), [nowvec(1:3),15,38,0])
 %!assert (datevec ("03:38 PM"), [nowvec(1:3),15,38,0])
 %!assert (datevec ("03/13/1962"), [1962,3,13,0,0,0])
 
 %% Test millisecond format FFF
 %!assert (datevec ("15:38:21.25", "HH:MM:SS.FFF"), [nowvec(1:3),15,38,21.025])
 
 # Other tests
-%!assert (datenum (datevec ([-1e4:1e4])), [-1e4:1e4]')
+%!assert (datenum (datevec ([-1e4:1e4])), [-1e4:1e4]');
 %!test
 %! t = linspace (-2e5, 2e5, 10993);
 %! assert (all (abs (datenum (datevec (t)) - t') < 1e-5));
 
diff --git a/scripts/time/eomday.m b/scripts/time/eomday.m
--- a/scripts/time/eomday.m
+++ b/scripts/time/eomday.m
@@ -49,17 +49,17 @@ endfunction
 %!assert (eomday ([-4:4],2), [29,28,28,28,29,28,28,28,29])
 %!assert (eomday ([-901,901],2), [28,28])
 %!assert (eomday ([-100,100],2), [28,28])
 %!assert (eomday ([-900,900],2), [28,28])
 %!assert (eomday ([-400,400],2), [29,29])
 %!assert (eomday ([-800,800],2), [29,29])
 %!assert (eomday (2001,1:12), [31,28,31,30,31,30,31,31,30,31,30,31])
 %!assert (eomday (1:3,1:3), [31,28,31])
-%!assert (eomday (1:2000,2)', datevec(datenum(1:2000,3,0))(:,3))
+%!assert (eomday (1:2000,2)', datevec (datenum (1:2000,3,0))(:,3))
 %!assert ([1900:1999](find(eomday(1900:1999,2*ones(1,100))==29)), [1904,1908,1912,1916,1920,1924,1928,1932,1936,1940,1944,1948,1952,1956,1960,1964,1968,1972,1976,1980,1984,1988,1992,1996])
 %!assert (eomday ([2004;2005], [2;2]), [29;28])
 
 %% Test input validation
 %!error eomday ()
 %!error eomday (1)
 %!error eomday (1,2,3)
 
diff --git a/scripts/time/etime.m b/scripts/time/etime.m
--- a/scripts/time/etime.m
+++ b/scripts/time/etime.m
@@ -46,24 +46,24 @@ function secs = etime (t2, t1)
   [~, s2] = datenum (t2);
   [~, s1] = datenum (t1);
 
   secs = s2 - s1;
 
 endfunction
 
 
-%!assert (etime ([1900,12,31,23,59,59],[1901,1,1,0,0,0]),-1)
-%!assert (etime ([1900,2,28,23,59,59],[1900,3,1,0,0,0]),-1)
-%!assert (etime ([2000,2,28,23,59,59],[2000,3,1,0,0,0]),-86401)
-%!assert (etime ([1996,2,28,23,59,59],[1996,3,1,0,0,0]),-86401)
+%!assert (etime ([1900,12,31,23,59,59], [1901,1,1,0,0,0]), -1)
+%!assert (etime ([1900,2,28,23,59,59], [1900,3,1,0,0,0]), -1)
+%!assert (etime ([2000,2,28,23,59,59], [2000,3,1,0,0,0]), -86401)
+%!assert (etime ([1996,2,28,23,59,59], [1996,3,1,0,0,0]), -86401)
 %!test
 %! t1 = [1900,12,31,23,59,59; 1900,2,28,23,59,59];
 %! t2 = [1901,1,1,0,0,0; 1900,3,1,0,0,0];
-%! assert(etime(t2, t1), [1;1]);
+%! assert (etime (t2, t1), [1;1]);
 
 %!test
 %! t1 = [1993, 8, 20, 4, 56, 1];
 %! t2 = [1993, 8, 21, 4, 56, 1];
 %! t3 = [1993, 8, 20, 5, 56, 1];
 %! t4 = [1993, 8, 20, 4, 57, 1];
 %! t5 = [1993, 8, 20, 4, 56, 14];
 %!
diff --git a/scripts/time/is_leap_year.m b/scripts/time/is_leap_year.m
--- a/scripts/time/is_leap_year.m
+++ b/scripts/time/is_leap_year.m
@@ -51,10 +51,10 @@ endfunction
 
 
 %!assert (is_leap_year (2000), true)
 %!assert (is_leap_year (1976), true)
 %!assert (is_leap_year (1000), false)
 %!assert (is_leap_year (1800), false)
 %!assert (is_leap_year (1600), true)
 
-%!error is_leap_year (1, 2);
+%!error is_leap_year (1, 2)
 
diff --git a/scripts/time/now.m b/scripts/time/now.m
--- a/scripts/time/now.m
+++ b/scripts/time/now.m
@@ -49,13 +49,14 @@ function t = now ()
   ##
   ## mktime(gmtime(0)) does indeed return the offset from Greenwich to the
   ## local time zone, but we need to account for daylight savings time
   ## changing by an hour the offset from CUT for part of the year.
 
 endfunction
 
 
-%!assert (isnumeric (now ()));
-%!assert (now () > 0);
-%!assert (now () <= now ());
+%!assert (isnumeric (now ()))
+%!assert (now () > 0)
+%!assert (now () <= now ())
 
-%!error now (1);
+%!error now (1)
+
