# HG changeset patch
# User Rik <rik@octave.org>
# Date 1497365633 25200
#      Tue Jun 13 07:53:53 2017 -0700
# Node ID 0cc2011d800e8f3548150ce57207ab9cf87e3378
# Parent  c3075ae020e1c0477a0e466588377db2ac7fc2cb
maint: Deprecate is_real_type and replace with isreal.

* ov.h (is_real_type): Use OCTAVE_DEPRECATED macro around function.
* ov.h (isreal): New function.

* QtHandlesUtils.cc, __luinc__.cc, bsxfun.cc, cellfun.cc, conv2.cc, data.cc,
det.cc, eig.cc, ellipj.cc, fft.cc, fft2.cc, fftn.cc, find.cc, graphics.cc,
graphics.in.h, gsvd.cc, hess.cc, inv.cc, lu.cc, mex.cc, oct-stream.cc, pinv.cc,
psi.cc, qz.cc, schur.cc, svd.cc, typecast.cc, chol.cc, dmperm.cc, qr.cc,
symbfact.cc, symrcm.cc, ov-base-int.h, ov-base.h, ov-bool-mat.h,
ov-bool-sparse.h, ov-bool.h, ov-ch-mat.h, ov-float.h, ov-flt-re-diag.h,
ov-flt-re-mat.h, ov-java.cc, ov-lazy-idx.h, ov-perm.h, ov-range.h,
ov-re-diag.h, ov-re-mat.h, ov-re-sparse.h, ov-scalar.h, pt-tm-const.cc:
Replace instances of is_real_type with isreal.

diff --git a/libgui/graphics/QtHandlesUtils.cc b/libgui/graphics/QtHandlesUtils.cc
--- a/libgui/graphics/QtHandlesUtils.cc
+++ b/libgui/graphics/QtHandlesUtils.cc
@@ -323,17 +323,17 @@ namespace QtHandles
 
                     img.setPixel (x_off + i, y_off + j,
                                   qRgba (octave::math::round (r * 255),
                                          octave::math::round (g * 255),
                                          octave::math::round (b * 255),
                                          a));
                   }
             }
-          else if (v.is_real_type ())
+          else if (v.isreal ())
             {
               NDArray d = v.array_value ();
 
               for (int i = 0; i < w; i++)
                 for (int j = 0; j < h; j++)
                   {
                     double r = d(j, i, 0);
                     double g = d(j, i, 1);
diff --git a/libinterp/corefcn/__luinc__.cc b/libinterp/corefcn/__luinc__.cc
--- a/libinterp/corefcn/__luinc__.cc
+++ b/libinterp/corefcn/__luinc__.cc
@@ -125,17 +125,17 @@ See documentation for @code{luinc}.
     }
 
   // FIXME: Add code for zero-level factorization
   if (zero_level)
     error ("luinc: zero-level factorization not implemented");
 
   octave_value_list retval;
 
-  if (args(0).is_real_type ())
+  if (args(0).isreal ())
     {
       SparseMatrix sm = args(0).sparse_matrix_value ();
       octave_idx_type sm_nr = sm.rows ();
       octave_idx_type sm_nc = sm.cols ();
       ColumnVector Qinit (sm_nc);
 
       for (octave_idx_type i = 0; i < sm_nc; i++)
         Qinit(i) = i;
diff --git a/libinterp/corefcn/bsxfun.cc b/libinterp/corefcn/bsxfun.cc
--- a/libinterp/corefcn/bsxfun.cc
+++ b/libinterp/corefcn/bsxfun.cc
@@ -466,33 +466,33 @@ dimensionality as the other array.
 
               if (i == 0)
                 {
                   if (! tmp(0).is_sparse_type ())
                     {
                       std::string result_type = tmp(0).class_name ();
                       if (result_type == "double")
                         {
-                          if (tmp(0).is_real_type ())
+                          if (tmp(0).isreal ())
                             {
                               have_NDArray = true;
                               result_NDArray = tmp(0).array_value ();
                               result_NDArray.resize (dvc);
                             }
                           else
                             {
                               have_ComplexNDArray = true;
                               result_ComplexNDArray =
                                 tmp(0).complex_array_value ();
                               result_ComplexNDArray.resize (dvc);
                             }
                         }
                       else if (result_type == "single")
                         {
-                          if (tmp(0).is_real_type ())
+                          if (tmp(0).isreal ())
                             {
                               have_FloatNDArray = true;
                               result_FloatNDArray
                                 = tmp(0).float_array_value ();
                               result_FloatNDArray.resize (dvc);
                             }
                           else
                             {
@@ -561,17 +561,17 @@ dimensionality as the other array.
                               result_NDArray =
                                 NDArray (result_FloatNDArray);
                               result_NDArray.insert
                                 (tmp(0).array_value (), ra_idx);
                               have_FloatNDArray = false;
                               have_NDArray = true;
                             }
                         }
-                      else if (tmp(0).is_real_type ())
+                      else if (tmp(0).isreal ())
                         result_FloatNDArray.insert
                           (tmp(0).float_array_value (), ra_idx);
                       else
                         {
                           result_FloatComplexNDArray =
                             FloatComplexNDArray (result_FloatNDArray);
                           result_FloatComplexNDArray.insert
                             (tmp(0).float_complex_array_value (),
@@ -583,17 +583,17 @@ dimensionality as the other array.
                   else if (have_NDArray)
                     {
                       if (! tmp(0).is_float_type ())
                         {
                           have_NDArray = false;
                           C = result_NDArray;
                           C = do_cat_op (C, tmp(0), ra_idx);
                         }
-                      else if (tmp(0).is_real_type ())
+                      else if (tmp(0).isreal ())
                         result_NDArray.insert (tmp(0).array_value (),
                                                ra_idx);
                       else
                         {
                           result_ComplexNDArray =
                             ComplexNDArray (result_NDArray);
                           result_ComplexNDArray.insert
                             (tmp(0).complex_array_value (), ra_idx);
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -150,17 +150,17 @@ try_cellfun_internal_ops (const octave_v
       for (octave_idx_type count= 0; count < k; count++)
         result(count) = f_args.elem (count).is_numeric_type ();
       retval(0) = result;
     }
   else if (name == "isreal")
     {
       BNDA result (f_args.dims ());
       for (octave_idx_type count= 0; count < k; count++)
-        result(count) = f_args.elem (count).is_real_type ();
+        result(count) = f_args.elem (count).isreal ();
       retval(0) = result;
     }
   else if (name == "length")
     {
       NDA result (f_args.dims ());
       for (octave_idx_type count= 0; count < k; count++)
         result(count) = static_cast<double> (f_args.elem (count).length ());
       retval(0) = result;
diff --git a/libinterp/corefcn/conv2.cc b/libinterp/corefcn/conv2.cc
--- a/libinterp/corefcn/conv2.cc
+++ b/libinterp/corefcn/conv2.cc
@@ -109,17 +109,17 @@ When the third argument is a matrix, ret
 
       if (args(0).is_single_type () || args(1).is_single_type ()
           || args(2).is_single_type ())
         {
           if (args(0).iscomplex () || args(1).iscomplex ()
               || args(2).iscomplex ())
             {
               FloatComplexMatrix a (args(2).float_complex_matrix_value ());
-              if (args(1).is_real_type () && args(2).is_real_type ())
+              if (args(1).isreal () && args(2).isreal ())
                 {
                   FloatColumnVector v1 (args(0).float_vector_value ());
                   FloatRowVector v2 (args(1).float_vector_value ());
                   retval = convn (a, v1, v2, ct);
                 }
               else
                 {
                   FloatComplexColumnVector v1 (args(0).float_complex_vector_value ());
@@ -136,17 +136,17 @@ When the third argument is a matrix, ret
             }
         }
       else
         {
           if (args(0).iscomplex () || args(1).iscomplex ()
               || args(2).iscomplex ())
             {
               ComplexMatrix a (args(2).complex_matrix_value ());
-              if (args(1).is_real_type () && args(2).is_real_type ())
+              if (args(1).isreal () && args(2).isreal ())
                 {
                   ColumnVector v1 (args(0).vector_value ());
                   RowVector v2 (args(1).vector_value ());
                   retval = convn (a, v1, v2, ct);
                 }
               else
                 {
                   ComplexColumnVector v1 (args(0).complex_vector_value ());
@@ -165,17 +165,17 @@ When the third argument is a matrix, ret
     } // if (separable)
   else
     {
       if (args(0).is_single_type () || args(1).is_single_type ())
         {
           if (args(0).iscomplex () || args(1).iscomplex ())
             {
               FloatComplexMatrix a (args(0).float_complex_matrix_value ());
-              if (args(1).is_real_type ())
+              if (args(1).isreal ())
                 {
                   FloatMatrix b (args(1).float_matrix_value ());
                   retval = convn (a, b, ct);
                 }
               else
                 {
                   FloatComplexMatrix b (args(1).float_complex_matrix_value ());
                   retval = convn (a, b, ct);
@@ -188,17 +188,17 @@ When the third argument is a matrix, ret
               retval = convn (a, b, ct);
             }
         }
       else
         {
           if (args(0).iscomplex () || args(1).iscomplex ())
             {
               ComplexMatrix a (args(0).complex_matrix_value ());
-              if (args(1).is_real_type ())
+              if (args(1).isreal ())
                 {
                   Matrix b (args(1).matrix_value ());
                   retval = convn (a, b, ct);
                 }
               else
                 {
                   ComplexMatrix b (args(1).complex_matrix_value ());
                   retval = convn (a, b, ct);
@@ -330,17 +330,17 @@ The size of the result is @code{max (siz
 
   octave_value retval;
 
   if (args(0).is_single_type () || args(1).is_single_type ())
     {
       if (args(0).iscomplex () || args(1).iscomplex ())
         {
           FloatComplexNDArray a (args(0).float_complex_array_value ());
-          if (args(1).is_real_type ())
+          if (args(1).isreal ())
             {
               FloatNDArray b (args(1).float_array_value ());
               retval = convn (a, b, ct);
             }
           else
             {
               FloatComplexNDArray b (args(1).float_complex_array_value ());
               retval = convn (a, b, ct);
@@ -353,17 +353,17 @@ The size of the result is @code{max (siz
           retval = convn (a, b, ct);
         }
     }
   else
     {
       if (args(0).iscomplex () || args(1).iscomplex ())
         {
           ComplexNDArray a (args(0).complex_array_value ());
-          if (args(1).is_real_type ())
+          if (args(1).isreal ())
             {
               NDArray b (args(1).array_value ());
               retval = convn (a, b, ct);
             }
           else
             {
               ComplexNDArray b (args(1).complex_array_value ());
               retval = convn (a, b, ct);
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -494,17 +494,17 @@ and @var{e} is an integer.  If
     print_usage ();
 
   octave_value_list retval;
 
   if (nargout < 2)
     retval = ovl (args(0).log2 ());
   else if (args(0).is_single_type ())
     {
-      if (args(0).is_real_type ())
+      if (args(0).isreal ())
         {
           FloatNDArray f;
           FloatNDArray x = args(0).float_array_value ();
           // FIXME: should E be an int value?
           FloatMatrix e;
           map_2_xlog2 (x, f, e);
           retval = ovl (f, e);
         }
@@ -513,17 +513,17 @@ and @var{e} is an integer.  If
           FloatComplexNDArray f;
           FloatComplexNDArray x = args(0).float_complex_array_value ();
           // FIXME: should E be an int value?
           FloatNDArray e;
           map_2_xlog2 (x, f, e);
           retval = ovl (f, e);
         }
     }
-  else if (args(0).is_real_type ())
+  else if (args(0).isreal ())
     {
       NDArray f;
       NDArray x = args(0).array_value ();
       // FIXME: should E be an int value?
       Matrix e;
       map_2_xlog2 (x, f, e);
       retval = ovl (f, e);
     }
@@ -921,17 +921,17 @@ negative numbers or when the values are 
                                                                         \
   octave_value arg = args(0);                                           \
                                                                         \
   int dim = (nargin == 1 ? -1 : args(1).int_value (true) - 1);          \
                                                                         \
   if (dim < -1)                                                         \
     error (#FCN ": invalid dimension argument = %d", dim + 1);          \
                                                                         \
-  if (arg.is_real_type ())                                              \
+  if (arg.isreal ())                                              \
     {                                                                   \
       if (arg.is_sparse_type ())                                        \
         {                                                               \
           SparseMatrix tmp = arg.sparse_matrix_value ();                \
                                                                         \
           retval = tmp.FCN (dim);                                       \
         }                                                               \
       else if (arg.is_single_type ())                                   \
@@ -1793,20 +1793,20 @@ do_cat (const octave_value_list& xargs, 
             result_type = octave::get_concat_class (result_type, args(i).class_name ());
 
           if (all_strings_p && ! args(i).is_string ())
             all_strings_p = false;
           if (all_sq_strings_p && ! args(i).is_sq_string ())
             all_sq_strings_p = false;
           if (all_dq_strings_p && ! args(i).is_dq_string ())
             all_dq_strings_p = false;
-          if (all_real_p && ! args(i).is_real_type ())
+          if (all_real_p && ! args(i).isreal ())
             all_real_p = false;
           if (all_cmplx_p && ! (args(i).iscomplex ()
-                                || args(i).is_real_type ()))
+                                || args(i).isreal ()))
             all_cmplx_p = false;
           if (! any_sparse_p && args(i).is_sparse_type ())
             any_sparse_p = true;
           if (! any_cell_p && args(i).iscell ())
             any_cell_p = true;
           if (! any_class_p && args(i).is_object ())
             any_class_p = true;
         }
@@ -3531,17 +3531,17 @@ Return true if @var{x} is a non-complex 
 For compatibility with @sc{matlab}, this includes logical and character
 matrices.
 @seealso{iscomplex, isnumeric, isa}
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
-  return ovl (args(0).is_real_type ());
+  return ovl (args(0).isreal ());
 }
 
 DEFUN (isempty, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} isempty (@var{a})
 Return true if @var{a} is an empty matrix (any one of its dimensions is
 zero).
 @seealso{isnull, isa}
diff --git a/libinterp/corefcn/det.cc b/libinterp/corefcn/det.cc
--- a/libinterp/corefcn/det.cc
+++ b/libinterp/corefcn/det.cc
@@ -124,17 +124,17 @@ For that, use any of the condition numbe
         retval.resize (1);
 
       retval(0) = static_cast<double> (arg.perm_matrix_value ().determinant ());
       if (nargout > 1)
         retval(1) = 1.0;
     }
   else if (arg.is_single_type ())
     {
-      if (arg.is_real_type ())
+      if (arg.isreal ())
         {
           octave_idx_type info;
           float rcond = 0.0;
           // Always compute rcond, so we can detect singular matrices.
           FloatMatrix m = arg.float_matrix_value ();
 
           MAYBE_CAST (rep, octave_float_matrix);
           MatrixType mtype = (rep ? rep -> matrix_type () : MatrixType ());
@@ -157,17 +157,17 @@ For that, use any of the condition numbe
           retval(0) = (info == -1 ? FloatComplex (0.0) : det.value ());
           retval(1) = rcond;
           if (rep)
             rep->matrix_type (mtype);
         }
     }
   else
     {
-      if (arg.is_real_type ())
+      if (arg.isreal ())
         {
           octave_idx_type info;
           double rcond = 0.0;
           // Always compute rcond, so we can detect singular matrices.
           if (arg.is_sparse_type ())
             {
               SparseMatrix m = arg.sparse_matrix_value ();
 
diff --git a/libinterp/corefcn/eig.cc b/libinterp/corefcn/eig.cc
--- a/libinterp/corefcn/eig.cc
+++ b/libinterp/corefcn/eig.cc
@@ -195,32 +195,32 @@ The eigenvalues returned by @code{eig} a
   FloatMatrix ftmp_a, ftmp_b;
   FloatComplexMatrix fctmp_a, fctmp_b;
 
   if (arg_a.is_single_type ())
     {
       FloatEIG result;
       if (AEPcase)
         {
-          if (arg_a.is_real_type ())
+          if (arg_a.isreal ())
             {
               ftmp_a = arg_a.float_matrix_value ();
 
               result = FloatEIG (ftmp_a, nargout > 1, nargout > 2, balance);
             }
           else
             {
               fctmp_a = arg_a.float_complex_matrix_value ();
 
               result = FloatEIG (fctmp_a, nargout > 1, nargout > 2, balance);
             }
         }
       else
         {
-          if (arg_a.is_real_type () && arg_b.is_real_type ())
+          if (arg_a.isreal () && arg_b.isreal ())
             {
               ftmp_a = arg_a.float_matrix_value ();
               ftmp_b = arg_b.float_matrix_value ();
 
               result = FloatEIG (ftmp_a, ftmp_b, nargout > 1, nargout > 2,
                                  force_qz);
             }
           else
@@ -261,32 +261,32 @@ The eigenvalues returned by @code{eig} a
         }
     }
   else
     {
       EIG result;
 
       if (AEPcase)
         {
-          if (arg_a.is_real_type ())
+          if (arg_a.isreal ())
             {
               tmp_a = arg_a.matrix_value ();
 
               result = EIG (tmp_a, nargout > 1, nargout > 2, balance);
             }
           else
             {
               ctmp_a = arg_a.complex_matrix_value ();
 
               result = EIG (ctmp_a, nargout > 1, nargout > 2, balance);
             }
         }
       else
         {
-          if (arg_a.is_real_type () && arg_b.is_real_type ())
+          if (arg_a.isreal () && arg_b.isreal ())
             {
               tmp_a = arg_a.matrix_value ();
               tmp_b = arg_b.matrix_value ();
 
               result = EIG (tmp_a, tmp_b, nargout > 1, nargout > 2, force_qz);
             }
           else
             {
diff --git a/libinterp/corefcn/ellipj.cc b/libinterp/corefcn/ellipj.cc
--- a/libinterp/corefcn/ellipj.cc
+++ b/libinterp/corefcn/ellipj.cc
@@ -77,17 +77,17 @@ and 16.15), Dover, 1965.
   octave_value m_arg = args(1);
 
   if (m_arg.is_scalar_type ())
     {
       double m = args(1).xdouble_value ("ellipj: M must be a scalar or matrix");
 
       if (u_arg.is_scalar_type ())
         {
-          if (u_arg.is_real_type ())
+          if (u_arg.isreal ())
             {
               // u real, m scalar
               double u = args(0).xdouble_value ("ellipj: U must be a scalar or matrix");
 
               double sn, cn, dn;
               double err = 0;
 
               octave::math::ellipj (u, m, sn, cn, dn, err);
@@ -134,17 +134,17 @@ and 16.15), Dover, 1965.
     {
       NDArray m = args(1).xarray_value ("ellipj: M must be a scalar or matrix");
 
       dim_vector sz_m = m.dims ();
 
       if (u_arg.is_scalar_type ())
         {
           // u is scalar, m is array
-          if (u_arg.is_real_type ())
+          if (u_arg.isreal ())
             {
               // u is real scalar, m is array
               double u = u_arg.xdouble_value ("ellipj: U must be a scalar or matrix");
 
               NDArray sn (sz_m), cn (sz_m), dn (sz_m);
               NDArray err (sz_m);
 
               const double *pm = m.data ();
@@ -178,17 +178,17 @@ and 16.15), Dover, 1965.
                 octave::math::ellipj (u, pm[i], psn[i], pcn[i], pdn[i], perr[i]);
 
               return ovl (sn, cn, dn, err);
             }
         }
       else
         {
           // u is array, m is array
-          if (u_arg.is_real_type ())
+          if (u_arg.isreal ())
             {
               // u is real array, m is array
               NDArray u = u_arg.xarray_value ("ellipj: U must be a scalar or matrix");
 
               dim_vector sz_u = u.dims ();
 
               if (sz_u.ndims () == 2 && sz_m.ndims () == 2
                   && sz_u(1) == 1 && sz_m(0) == 1)
diff --git a/libinterp/corefcn/fft.cc b/libinterp/corefcn/fft.cc
--- a/libinterp/corefcn/fft.cc
+++ b/libinterp/corefcn/fft.cc
@@ -117,34 +117,34 @@ do_fft (const octave_value_list& args, c
         idx(i) = idx_vector::colon;
       idx(dim) = idx_vector (static_cast<octave_idx_type> (0));
 
       return arg.do_index_op (idx);
     }
 
   if (arg.is_single_type ())
     {
-      if (arg.is_real_type ())
+      if (arg.isreal ())
         {
           FloatNDArray nda = arg.float_array_value ();
 
           nda.resize (dims, 0.0);
           retval = (type != 0 ? nda.ifourier (dim) : nda.fourier (dim));
         }
       else
         {
           FloatComplexNDArray cnda = arg.float_complex_array_value ();
 
           cnda.resize (dims, 0.0);
           retval = (type != 0 ? cnda.ifourier (dim) : cnda.fourier (dim));
         }
     }
   else
     {
-      if (arg.is_real_type ())
+      if (arg.isreal ())
         {
           NDArray nda = arg.array_value ();
 
           nda.resize (dims, 0.0);
           retval = (type != 0 ? nda.ifourier (dim) : nda.fourier (dim));
         }
       else if (arg.iscomplex ())
         {
diff --git a/libinterp/corefcn/fft2.cc b/libinterp/corefcn/fft2.cc
--- a/libinterp/corefcn/fft2.cc
+++ b/libinterp/corefcn/fft2.cc
@@ -96,34 +96,34 @@ do_fft2 (const octave_value_list& args, 
       if (arg.is_single_type ())
         return octave_value (FloatMatrix ());
       else
         return octave_value (Matrix ());
     }
 
   if (arg.is_single_type ())
     {
-      if (arg.is_real_type ())
+      if (arg.isreal ())
         {
           FloatNDArray nda = arg.float_array_value ();
 
           nda.resize (dims, 0.0);
           retval = (type != 0 ? nda.ifourier2d () : nda.fourier2d ());
         }
       else
         {
           FloatComplexNDArray cnda = arg.float_complex_array_value ();
 
           cnda.resize (dims, 0.0);
           retval = (type != 0 ? cnda.ifourier2d () : cnda.fourier2d ());
         }
     }
   else
     {
-      if (arg.is_real_type ())
+      if (arg.isreal ())
         {
           NDArray nda = arg.array_value ();
 
           nda.resize (dims, 0.0);
           retval = (type != 0 ? nda.ifourier2d () : nda.fourier2d ());
         }
       else if (arg.iscomplex ())
         {
diff --git a/libinterp/corefcn/fftn.cc b/libinterp/corefcn/fftn.cc
--- a/libinterp/corefcn/fftn.cc
+++ b/libinterp/corefcn/fftn.cc
@@ -82,34 +82,34 @@ do_fftn (const octave_value_list& args, 
       if (arg.is_single_type ())
         return octave_value (FloatMatrix ());
       else
         return octave_value (Matrix ());
     }
 
   if (arg.is_single_type ())
     {
-      if (arg.is_real_type ())
+      if (arg.isreal ())
         {
           FloatNDArray nda = arg.float_array_value ();
 
           nda.resize (dims, 0.0);
           retval = (type != 0 ? nda.ifourierNd () : nda.fourierNd ());
         }
       else
         {
           FloatComplexNDArray cnda = arg.float_complex_array_value ();
 
           cnda.resize (dims, 0.0);
           retval = (type != 0 ? cnda.ifourierNd () : cnda.fourierNd ());
         }
     }
   else
     {
-      if (arg.is_real_type ())
+      if (arg.isreal ())
         {
           NDArray nda = arg.array_value ();
 
           nda.resize (dims, 0.0);
           retval = (type != 0 ? nda.ifourierNd () : nda.fourierNd ());
         }
       else if (arg.iscomplex ())
         {
diff --git a/libinterp/corefcn/find.cc b/libinterp/corefcn/find.cc
--- a/libinterp/corefcn/find.cc
+++ b/libinterp/corefcn/find.cc
@@ -469,17 +469,17 @@ b = sparse (i, j, v, sz(1), sz(2));
       DO_INT_BRANCH (uint16)
       DO_INT_BRANCH (uint32)
       DO_INT_BRANCH (uint64)
       else
         panic_impossible ();
     }
   else if (arg.is_sparse_type ())
     {
-      if (arg.is_real_type ())
+      if (arg.isreal ())
         {
           SparseMatrix v = arg.sparse_matrix_value ();
 
           retval = find_nonzero_elem_idx (v, nargout, n_to_find, direction);
         }
       else if (arg.iscomplex ())
         {
           SparseComplexMatrix v = arg.sparse_complex_matrix_value ();
@@ -498,30 +498,30 @@ b = sparse (i, j, v, sz(1), sz(2));
   else if (arg.is_string ())
     {
       charNDArray chnda = arg.char_array_value ();
 
       retval = find_nonzero_elem_idx (chnda, nargout, n_to_find, direction);
     }
   else if (arg.is_single_type ())
     {
-      if (arg.is_real_type ())
+      if (arg.isreal ())
         {
           FloatNDArray nda = arg.float_array_value ();
 
           retval = find_nonzero_elem_idx (nda, nargout, n_to_find, direction);
         }
       else if (arg.iscomplex ())
         {
           FloatComplexNDArray cnda = arg.float_complex_array_value ();
 
           retval = find_nonzero_elem_idx (cnda, nargout, n_to_find, direction);
         }
     }
-  else if (arg.is_real_type ())
+  else if (arg.isreal ())
     {
       NDArray nda = arg.array_value ();
 
       retval = find_nonzero_elem_idx (nda, nargout, n_to_find, direction);
     }
   else if (arg.iscomplex ())
     {
       ComplexNDArray cnda = arg.complex_array_value ();
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -1381,17 +1381,17 @@ double_radio_property::do_set (const oct
                              "%s: allowing %s to match %s value %s",
                              "set", s.c_str (), get_name ().c_str (),
                              match.c_str ());
           current_val = match;
           current_type = radio_t;
           return true;
         }
     }
-  else if (val.is_scalar_type () && val.is_real_type ())
+  else if (val.is_scalar_type () && val.isreal ())
     {
       double new_dval = val.double_value ();
 
       if (current_type != double_t || new_dval != dval)
         {
           dval = new_dval;
           current_type = double_t;
           return true;
@@ -2868,17 +2868,17 @@ is_handle (double val)
 
 static octave_value
 is_handle (const octave_value& val)
 {
   octave_value retval = false;
 
   if (val.is_real_scalar () && is_handle (val.double_value ()))
     retval = true;
-  else if (val.is_numeric_type () && val.is_real_type ())
+  else if (val.is_numeric_type () && val.isreal ())
     {
       const NDArray handles = val.array_value ();
 
       boolNDArray result (handles.dims ());
 
       for (octave_idx_type i = 0; i < handles.numel (); i++)
         result.xelem (i) = is_handle (handles(i));
 
@@ -10164,17 +10164,17 @@ is_handle_visible (double val)
 
 static octave_value
 is_handle_visible (const octave_value& val)
 {
   octave_value retval = false;
 
   if (val.is_real_scalar () && is_handle_visible (val.double_value ()))
     retval = true;
-  else if (val.is_numeric_type () && val.is_real_type ())
+  else if (val.is_numeric_type () && val.isreal ())
     {
       const NDArray handles = val.array_value ();
 
       boolNDArray result (handles.dims ());
 
       for (octave_idx_type i = 0; i < handles.numel (); i++)
         result.xelem (i) = is_handle_visible (handles(i));
 
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -1205,17 +1205,17 @@ public:
   }
 
   void add_constraint (const finite_type finite)
   { finite_constraint = finite; }
 
 protected:
   bool do_set (const octave_value& v)
   {
-    if (! v.is_scalar_type () || ! v.is_real_type ())
+    if (! v.is_scalar_type () || ! v.isreal ())
       error ("set: invalid value for double property \"%s\"",
              get_name ().c_str ());
 
     double new_val = v.double_value ();
 
     // Check min and max
     if (! octave::math::isnan (minval.first))
       {
diff --git a/libinterp/corefcn/gsvd.cc b/libinterp/corefcn/gsvd.cc
--- a/libinterp/corefcn/gsvd.cc
+++ b/libinterp/corefcn/gsvd.cc
@@ -205,17 +205,17 @@ and zggsvd routines.
     }
   else
     {
       if (nc != np)
         print_usage ();
 
       if (argA.is_single_type () || argB.is_single_type ())
         {
-          if (argA.is_real_type () && argB.is_real_type ())
+          if (argA.isreal () && argB.isreal ())
             {
               FloatMatrix tmpA = argA.xfloat_matrix_value ("gsvd: A must be a real or complex matrix");
               FloatMatrix tmpB = argB.xfloat_matrix_value ("gsvd: B must be a real or complex matrix");
 
               if (tmpA.any_element_is_inf_or_nan ())
                 error ("gsvd: A cannot have Inf or NaN values");
               if (tmpB.any_element_is_inf_or_nan ())
                 error ("gsvd: B cannot have Inf or NaN values");
@@ -234,17 +234,17 @@ and zggsvd routines.
 
               retval = do_gsvd (ctmpA, ctmpB, nargout, true);
             }
           else
             error ("gsvd: A and B must be real or complex matrices");
         }
       else
         {
-          if (argA.is_real_type () && argB.is_real_type ())
+          if (argA.isreal () && argB.isreal ())
             {
               Matrix tmpA = argA.xmatrix_value ("gsvd: A must be a real or complex matrix");
               Matrix tmpB = argB.xmatrix_value ("gsvd: B must be a real or complex matrix");
 
               if (tmpA.any_element_is_inf_or_nan ())
                 error ("gsvd: A cannot have Inf or NaN values");
               if (tmpB.any_element_is_inf_or_nan ())
                 error ("gsvd: B cannot have Inf or NaN values");
diff --git a/libinterp/corefcn/hess.cc b/libinterp/corefcn/hess.cc
--- a/libinterp/corefcn/hess.cc
+++ b/libinterp/corefcn/hess.cc
@@ -70,17 +70,17 @@ IEEE Transactions on Automatic Control, 
 
   if (arg.rows () != arg.columns ())
     err_square_matrix_required ("hess", "A");
 
   octave_value_list retval;
 
   if (arg.is_single_type ())
     {
-      if (arg.is_real_type ())
+      if (arg.isreal ())
         {
           FloatMatrix tmp = arg.float_matrix_value ();
 
           octave::math::hess<FloatMatrix> result (tmp);
 
           if (nargout <= 1)
             retval = ovl (result.hess_matrix ());
           else
@@ -97,17 +97,17 @@ IEEE Transactions on Automatic Control, 
             retval = ovl (result.hess_matrix ());
           else
             retval = ovl (result.unitary_hess_matrix (),
                           result.hess_matrix ());
         }
     }
   else
     {
-      if (arg.is_real_type ())
+      if (arg.isreal ())
         {
           Matrix tmp = arg.matrix_value ();
 
           octave::math::hess<Matrix> result (tmp);
 
           if (nargout <= 1)
             retval = ovl (result.hess_matrix ());
           else
diff --git a/libinterp/corefcn/inv.cc b/libinterp/corefcn/inv.cc
--- a/libinterp/corefcn/inv.cc
+++ b/libinterp/corefcn/inv.cc
@@ -112,17 +112,17 @@ sparse matrix if possible.
   else if (arg.is_perm_matrix ())
     {
       rcond = 1.0;
       info = 0;
       result = arg.perm_matrix_value ().inverse ();
     }
   else if (isfloat)
     {
-      if (arg.is_real_type ())
+      if (arg.isreal ())
         {
           FloatMatrix m = arg.float_matrix_value ();
 
           MatrixType mattyp = args(0).matrix_type ();
           result = m.inverse (mattyp, info, frcond, 1);
           args(0).matrix_type (mattyp);
         }
       else if (arg.iscomplex ())
@@ -131,17 +131,17 @@ sparse matrix if possible.
 
           MatrixType mattyp = args(0).matrix_type ();
           result = m.inverse (mattyp, info, frcond, 1);
           args(0).matrix_type (mattyp);
         }
     }
   else
     {
-      if (arg.is_real_type ())
+      if (arg.isreal ())
         {
           if (arg.is_sparse_type ())
             {
               SparseMatrix m = arg.sparse_matrix_value ();
 
               MatrixType mattyp = args(0).matrix_type ();
               result = m.inverse (mattyp, info, rcond, 1);
               args(0).matrix_type (mattyp);
diff --git a/libinterp/corefcn/lu.cc b/libinterp/corefcn/lu.cc
--- a/libinterp/corefcn/lu.cc
+++ b/libinterp/corefcn/lu.cc
@@ -185,17 +185,17 @@ permutation information.
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   if (issparse)
     {
       if (arg.isempty ())
         return octave_value_list (5, SparseMatrix ());
 
-      if (arg.is_real_type ())
+      if (arg.isreal ())
         {
           SparseMatrix m = arg.sparse_matrix_value ();
 
           if (nargout < 4)
             {
               ColumnVector Qinit (nc);
               for (octave_idx_type i = 0; i < nc; i++)
                 Qinit(i) = i;
@@ -325,17 +325,17 @@ permutation information.
       else
         err_wrong_type_arg ("lu", arg);
     }
   else
     {
       if (arg.isempty ())
         return octave_value_list (3, Matrix ());
 
-      if (arg.is_real_type ())
+      if (arg.isreal ())
         {
           if (arg.is_single_type ())
             {
               FloatMatrix m = arg.float_matrix_value ();
 
               octave::math::lu<FloatMatrix> fact (m);
 
               switch (nargout)
@@ -625,18 +625,18 @@ factorization from scratch.
 
   if (! check_lu_dims (argl, argu, argp))
     error ("luupdate: dimension mismatch");
 
   PermMatrix P = (pivoted
                   ? argp.perm_matrix_value ()
                   : PermMatrix::eye (argl.rows ()));
 
-  if (argl.is_real_type () && argu.is_real_type ()
-      && argx.is_real_type () && argy.is_real_type ())
+  if (argl.isreal () && argu.isreal ()
+      && argx.isreal () && argy.isreal ())
     {
       // all real case
       if (argl.is_single_type () || argu.is_single_type ()
           || argx.is_single_type () || argy.is_single_type ())
         {
           FloatMatrix L = argl.float_matrix_value ();
           FloatMatrix U = argu.float_matrix_value ();
           FloatMatrix x = argx.float_matrix_value ();
diff --git a/libinterp/corefcn/mex.cc b/libinterp/corefcn/mex.cc
--- a/libinterp/corefcn/mex.cc
+++ b/libinterp/corefcn/mex.cc
@@ -247,17 +247,17 @@ public:
   int is_uint32 (void) const { return val.is_uint32_type (); }
 
   int is_uint64 (void) const { return val.is_uint64_type (); }
 
   int is_uint8 (void) const { return val.is_uint8_type (); }
 
   int is_range (void) const { return val.is_range (); }
 
-  int is_real_type (void) const { return val.is_real_type (); }
+  int isreal (void) const { return val.isreal (); }
 
   int is_logical_scalar_true (void) const
   {
     return (is_logical_scalar () && val.is_true ());
   }
 
   mwSize get_m (void) const { return val.rows (); }
 
@@ -392,17 +392,17 @@ public:
       {
         // For sparse arrays, return the first non-zero value.
         void *data = val.mex_get_data ();
         if (data == nullptr)
           return 0.0;
 
         if (val.islogical ())
           return *static_cast<bool *> (data);
-        else if (val.is_real_type ())
+        else if (val.isreal ())
           return *static_cast<double *> (data);
         else  // Complex type, only return real part
           return *static_cast<double *> (data);
       }
     else
       return val.scalar_value (true);
   }
 
@@ -417,17 +417,17 @@ public:
 
     return retval;
   }
 
   void * get_imag_data (void) const
   {
     void *retval = nullptr;
 
-    if (is_numeric () && is_real_type ())
+    if (is_numeric () && isreal ())
       retval = 0;
     else
       request_mutation ();
 
     return retval;
   }
 
   // Not allowed.
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -3280,34 +3280,34 @@ namespace octave
             Complex v;
             skip_whitespace (is);
             scan_complex (is, fmt, v);
 
             if (! fmt.discard && ! is.fail ())
               {
                 if (fmt.bitwidth == 64)
                   {
-                    if (ov.is_real_type () && v.imag () == 0)
+                    if (ov.isreal () && v.imag () == 0)
                       ov.internal_rep ()->fast_elem_insert (row(0), v.real ());
                     else
                       {
-                        if (ov.is_real_type ())  // cat does type conversion
+                        if (ov.isreal ())  // cat does type conversion
                           ov = do_cat_op (ov, octave_value (v), row);
                         else
                           ov.internal_rep ()->fast_elem_insert (row(0), v);
                       }
                   }
                 else
                   {
-                    if (ov.is_real_type () && v.imag () == 0)
+                    if (ov.isreal () && v.imag () == 0)
                       ov.internal_rep ()->fast_elem_insert (row(0),
                                                             float (v.real ()));
                     else
                       {
-                        if (ov.is_real_type ())  // cat does type conversion
+                        if (ov.isreal ())  // cat does type conversion
                           ov = do_cat_op (ov, octave_value (v), row);
                         else
                           ov.internal_rep ()->fast_elem_insert (row(0),
                                                                 FloatComplex (v));
                       }
                   }
               }
           }
diff --git a/libinterp/corefcn/pinv.cc b/libinterp/corefcn/pinv.cc
--- a/libinterp/corefcn/pinv.cc
+++ b/libinterp/corefcn/pinv.cc
@@ -73,31 +73,31 @@ where @code{sigma_max (@var{x})} is the 
         {
           float tol = 0.0;
           if (nargin == 2)
             tol = args(1).float_value ();
 
           if (tol < 0.0)
             error ("pinv: TOL must be greater than zero");
 
-          if (arg.is_real_type ())
+          if (arg.isreal ())
             retval = arg.float_diag_matrix_value ().pseudo_inverse (tol);
           else
             retval = arg.float_complex_diag_matrix_value ().pseudo_inverse (tol);
         }
       else
         {
           double tol = 0.0;
           if (nargin == 2)
             tol = args(1).double_value ();
 
           if (tol < 0.0)
             error ("pinv: TOL must be greater than zero");
 
-          if (arg.is_real_type ())
+          if (arg.isreal ())
             retval = arg.diag_matrix_value ().pseudo_inverse (tol);
           else
             retval = arg.complex_diag_matrix_value ().pseudo_inverse (tol);
         }
     }
   else if (arg.is_perm_matrix ())
     {
       retval = arg.perm_matrix_value ().inverse ();
@@ -106,17 +106,17 @@ where @code{sigma_max (@var{x})} is the 
     {
       float tol = 0.0;
       if (nargin == 2)
         tol = args(1).float_value ();
 
       if (tol < 0.0)
         error ("pinv: TOL must be greater than zero");
 
-      if (arg.is_real_type ())
+      if (arg.isreal ())
         {
           FloatMatrix m = arg.float_matrix_value ();
 
           retval = m.pseudo_inverse (tol);
         }
       else if (arg.iscomplex ())
         {
           FloatComplexMatrix m = arg.float_complex_matrix_value ();
@@ -130,17 +130,17 @@ where @code{sigma_max (@var{x})} is the 
     {
       double tol = 0.0;
       if (nargin == 2)
         tol = args(1).double_value ();
 
       if (tol < 0.0)
         error ("pinv: TOL must be greater than zero");
 
-      if (arg.is_real_type ())
+      if (arg.isreal ())
         {
           Matrix m = arg.matrix_value ();
 
           retval = m.pseudo_inverse (tol);
         }
       else if (arg.iscomplex ())
         {
           ComplexMatrix m = arg.complex_matrix_value ();
diff --git a/libinterp/corefcn/psi.cc b/libinterp/corefcn/psi.cc
--- a/libinterp/corefcn/psi.cc
+++ b/libinterp/corefcn/psi.cc
@@ -110,17 +110,17 @@ can have any value real or complex value
           else
             error ("psi: Z must be a floating point");
         }
 
 #undef FLOAT_BRANCH
     }
   else
     {
-      if (! oct_z.is_real_type ())
+      if (! oct_z.isreal ())
         error ("psi: Z must be real value for polygamma (K > 0)");
 
 #define FLOAT_BRANCH(T, A, M, E)                                        \
       if (oct_z.is_ ## T ##_type ())                                    \
         {                                                               \
           const A ## NDArray z = oct_z.M ## array_value ();             \
           A ## NDArray psi_z (z.dims ());                               \
                                                                         \
diff --git a/libinterp/corefcn/qz.cc b/libinterp/corefcn/qz.cc
--- a/libinterp/corefcn/qz.cc
+++ b/libinterp/corefcn/qz.cc
@@ -389,20 +389,20 @@ Note: @code{qz} performs permutation bal
 
   if (complex_case)
     {
 #if defined (DEBUG)
       if (comp_q == 'V')
         std::cout << "qz: performing balancing; CQ=" << std::endl
                   << CQ << std::endl;
 #endif
-      if (args(0).is_real_type ())
+      if (args(0).isreal ())
         caa = ComplexMatrix (aa);
 
-      if (args(1).is_real_type ())
+      if (args(1).isreal ())
         cbb = ComplexMatrix (bb);
 
       if (comp_q == 'V')
         CQ = ComplexMatrix (QQ);
 
       if (comp_z == 'V')
         CZ = ComplexMatrix (ZZ);
 
diff --git a/libinterp/corefcn/schur.cc b/libinterp/corefcn/schur.cc
--- a/libinterp/corefcn/schur.cc
+++ b/libinterp/corefcn/schur.cc
@@ -168,17 +168,17 @@ in control (see @code{are} and @code{dar
 
   if (! arg.is_numeric_type ())
     err_wrong_type_arg ("schur", arg);
 
   octave_value_list retval;
 
   if (arg.is_single_type ())
     {
-      if (! force_complex && arg.is_real_type ())
+      if (! force_complex && arg.isreal ())
         {
           FloatMatrix tmp = arg.float_matrix_value ();
 
           if (nargout <= 1)
             {
               octave::math::schur<FloatMatrix> result (tmp, ord, false);
               retval = ovl (result.schur_matrix ());
             }
@@ -203,17 +203,17 @@ in control (see @code{are} and @code{dar
               octave::math::schur<FloatComplexMatrix> result (ctmp, ord, true);
               retval = ovl (result.unitary_matrix (),
                             mark_upper_triangular (result.schur_matrix ()));
             }
         }
     }
   else
     {
-      if (! force_complex && arg.is_real_type ())
+      if (! force_complex && arg.isreal ())
         {
           Matrix tmp = arg.matrix_value ();
 
           if (nargout <= 1)
             {
               octave::math::schur<Matrix> result (tmp, ord, false);
               retval = ovl (result.schur_matrix ());
             }
diff --git a/libinterp/corefcn/svd.cc b/libinterp/corefcn/svd.cc
--- a/libinterp/corefcn/svd.cc
+++ b/libinterp/corefcn/svd.cc
@@ -175,17 +175,17 @@ and may be less accurate for some matric
     error ("svd: A must be a 2-D matrix");
 
   octave_value_list retval;
 
   bool isfloat = arg.is_single_type ();
 
   if (isfloat)
     {
-      if (arg.is_real_type ())
+      if (arg.isreal ())
         {
           FloatMatrix tmp = arg.float_matrix_value ();
 
           if (tmp.any_element_is_inf_or_nan ())
             error ("svd: cannot take SVD of matrix containing Inf or NaN values");
 
           octave::math::svd<FloatMatrix> result
             (tmp,
@@ -220,17 +220,17 @@ and may be less accurate for some matric
           else
             retval = ovl (result.left_singular_matrix (),
                           sigma,
                           result.right_singular_matrix ());
         }
     }
   else
     {
-      if (arg.is_real_type ())
+      if (arg.isreal ())
         {
           Matrix tmp = arg.matrix_value ();
 
           if (tmp.any_element_is_inf_or_nan ())
             error ("svd: cannot take SVD of matrix containing Inf or NaN values");
 
           octave::math::svd<Matrix> result
             (tmp,
diff --git a/libinterp/corefcn/typecast.cc b/libinterp/corefcn/typecast.cc
--- a/libinterp/corefcn/typecast.cc
+++ b/libinterp/corefcn/typecast.cc
@@ -189,17 +189,17 @@ typecast (@var{x}, "uint8")
     {
       if (array.is_single_type ())
         get_data_and_bytesize (array.float_complex_array_value (), data,
                                byte_size, old_dims, frame);
       else
         get_data_and_bytesize (array.complex_array_value (), data,
                                byte_size, old_dims, frame);
     }
-  else if (array.is_real_type ())
+  else if (array.isreal ())
     {
       if (array.is_single_type ())
         get_data_and_bytesize (array.float_array_value (), data, byte_size,
                                old_dims, frame);
       else
         get_data_and_bytesize (array.array_value (), data, byte_size,
                                old_dims, frame);
     }
@@ -520,17 +520,17 @@ column vector.
     }
   else if (array.iscomplex ())
     {
       if (array.is_single_type ())
         retval = do_bitunpack (array.float_complex_array_value ());
       else
         retval = do_bitunpack (array.complex_array_value ());
     }
-  else if (array.is_real_type ())
+  else if (array.isreal ())
     {
       if (array.is_single_type ())
         retval = do_bitunpack (array.float_array_value ());
       else
         retval = do_bitunpack (array.array_value ());
     }
   else
     error ("bitunpack: invalid input class: %s",
diff --git a/libinterp/dldfcn/chol.cc b/libinterp/dldfcn/chol.cc
--- a/libinterp/dldfcn/chol.cc
+++ b/libinterp/dldfcn/chol.cc
@@ -180,17 +180,17 @@ sparse matrices.
     return ovl (Matrix ());
 
   if (arg.is_sparse_type ())
     {
       octave_idx_type info;
       bool natural = (nargout != 3);
       bool force = nargout > 1;
 
-      if (arg.is_real_type ())
+      if (arg.isreal ())
         {
           SparseMatrix m = arg.sparse_matrix_value ();
 
           octave::math::sparse_chol<SparseMatrix> fact (m, info, natural, force);
 
           if (nargout == 3)
             {
               if (vecout)
@@ -237,17 +237,17 @@ sparse matrices.
         }
       else
         err_wrong_type_arg ("chol", arg);
     }
   else if (arg.is_single_type ())
     {
       if (vecout)
         error ("chol: A must be sparse for the \"vector\" option");
-      if (arg.is_real_type ())
+      if (arg.isreal ())
         {
           FloatMatrix m = arg.float_matrix_value ();
 
           octave_idx_type info;
 
           octave::math::chol<FloatMatrix> fact (m, info, LLt != true);
 
           if (nargout == 2 || info == 0)
@@ -270,17 +270,17 @@ sparse matrices.
         }
       else
         err_wrong_type_arg ("chol", arg);
     }
   else
     {
       if (vecout)
         error ("chol: A must be sparse for the \"vector\" option");
-      if (arg.is_real_type ())
+      if (arg.isreal ())
         {
           Matrix m = arg.matrix_value ();
 
           octave_idx_type info;
 
           octave::math::chol<Matrix> fact (m, info, LLt != true);
 
           if (nargout == 2 || info == 0)
@@ -373,17 +373,17 @@ the Cholesky@tie{}factorization.
   if (nr == 0 || nc == 0)
     retval = Matrix ();
   else
     {
       if (arg.is_sparse_type ())
         {
           octave_idx_type info;
 
-          if (arg.is_real_type ())
+          if (arg.isreal ())
             {
               SparseMatrix m = arg.sparse_matrix_value ();
 
               octave::math::sparse_chol<SparseMatrix> chol (m, info);
 
               if (info == 0)
                 retval = chol.inverse ();
               else
@@ -400,17 +400,17 @@ the Cholesky@tie{}factorization.
               else
                 error ("cholinv: A must be positive definite");
             }
           else
             err_wrong_type_arg ("cholinv", arg);
         }
       else if (arg.is_single_type ())
         {
-          if (arg.is_real_type ())
+          if (arg.isreal ())
             {
               FloatMatrix m = arg.float_matrix_value ();
 
               octave_idx_type info;
               octave::math::chol<FloatMatrix> chol (m, info);
               if (info == 0)
                 retval = chol.inverse ();
               else
@@ -427,17 +427,17 @@ the Cholesky@tie{}factorization.
               else
                 error ("cholinv: A must be positive definite");
             }
           else
             err_wrong_type_arg ("chol", arg);
         }
       else
         {
-          if (arg.is_real_type ())
+          if (arg.isreal ())
             {
               Matrix m = arg.matrix_value ();
 
               octave_idx_type info;
               octave::math::chol<Matrix> chol (m, info);
               if (info == 0)
                 retval = chol.inverse ();
               else
@@ -500,34 +500,34 @@ diagonal elements.  @code{chol2inv (@var
   octave_idx_type nc = arg.columns ();
 
   if (nr == 0 || nc == 0)
     retval = Matrix ();
   else
     {
       if (arg.is_sparse_type ())
         {
-          if (arg.is_real_type ())
+          if (arg.isreal ())
             {
               SparseMatrix r = arg.sparse_matrix_value ();
 
               retval = octave::math::chol2inv (r);
             }
           else if (arg.iscomplex ())
             {
               SparseComplexMatrix r = arg.sparse_complex_matrix_value ();
 
               retval = octave::math::chol2inv (r);
             }
           else
             err_wrong_type_arg ("chol2inv", arg);
         }
       else if (arg.is_single_type ())
         {
-          if (arg.is_real_type ())
+          if (arg.isreal ())
             {
               FloatMatrix r = arg.float_matrix_value ();
 
               retval = octave::math::chol2inv (r);
             }
           else if (arg.iscomplex ())
             {
               FloatComplexMatrix r = arg.float_complex_matrix_value ();
@@ -535,17 +535,17 @@ diagonal elements.  @code{chol2inv (@var
               retval = octave::math::chol2inv (r);
             }
           else
             err_wrong_type_arg ("chol2inv", arg);
 
         }
       else
         {
-          if (arg.is_real_type ())
+          if (arg.isreal ())
             {
               Matrix r = arg.matrix_value ();
 
               retval = octave::math::chol2inv (r);
             }
           else if (arg.iscomplex ())
             {
               ComplexMatrix r = arg.complex_matrix_value ();
@@ -645,17 +645,17 @@ If @var{info} is not present, an error m
     error ("cholupdate: OP must be \"+\" or \"-\"");
 
   if (argr.columns () != n || argu.rows () != n || argu.columns () != 1)
     error ("cholupdate: dimension mismatch between R and U");
 
   int err = 0;
   if (argr.is_single_type () || argu.is_single_type ())
     {
-      if (argr.is_real_type () && argu.is_real_type ())
+      if (argr.isreal () && argu.isreal ())
         {
           // real case
           FloatMatrix R = argr.float_matrix_value ();
           FloatColumnVector u = argu.float_column_vector_value ();
 
           octave::math::chol<FloatMatrix> fact;
           fact.set (R);
 
@@ -681,17 +681,17 @@ If @var{info} is not present, an error m
           else
             fact.update (u);
 
           retval = ovl (get_chol_r (fact));
         }
     }
   else
     {
-      if (argr.is_real_type () && argu.is_real_type ())
+      if (argr.isreal () && argu.isreal ())
         {
           // real case
           Matrix R = argr.matrix_value ();
           ColumnVector u = argu.column_vector_value ();
 
           octave::math::chol<Matrix> fact;
           fact.set (R);
 
@@ -836,17 +836,17 @@ If @var{info} is not present, an error m
   if (j < 1 || j > n+1)
     error ("cholinsert: index J out of range");
 
   octave_value_list retval (nargout == 2 ? 2 : 1);
 
   int err = 0;
   if (argr.is_single_type () || argu.is_single_type ())
     {
-      if (argr.is_real_type () && argu.is_real_type ())
+      if (argr.isreal () && argu.isreal ())
         {
           // real case
           FloatMatrix R = argr.float_matrix_value ();
           FloatColumnVector u = argu.float_column_vector_value ();
 
           octave::math::chol<FloatMatrix> fact;
           fact.set (R);
           err = fact.insert_sym (u, j-1);
@@ -864,17 +864,17 @@ If @var{info} is not present, an error m
           fact.set (R);
           err = fact.insert_sym (u, j-1);
 
           retval = ovl (get_chol_r (fact));
         }
     }
   else
     {
-      if (argr.is_real_type () && argu.is_real_type ())
+      if (argr.isreal () && argu.isreal ())
         {
           // real case
           Matrix R = argr.matrix_value ();
           ColumnVector u = argu.column_vector_value ();
 
           octave::math::chol<Matrix> fact;
           fact.set (R);
           err = fact.insert_sym (u, j-1);
@@ -1072,17 +1072,17 @@ triangular, return the Cholesky@tie{}fac
 
   if (j < 0 && j > n)
     error ("choldelete: index J out of range");
 
   octave_value_list retval;
 
   if (argr.is_single_type ())
     {
-      if (argr.is_real_type ())
+      if (argr.isreal ())
         {
           // real case
           FloatMatrix R = argr.float_matrix_value ();
 
           octave::math::chol<FloatMatrix> fact;
           fact.set (R);
           fact.delete_sym (j-1);
 
@@ -1097,17 +1097,17 @@ triangular, return the Cholesky@tie{}fac
           fact.set (R);
           fact.delete_sym (j-1);
 
           retval = ovl (get_chol_r (fact));
         }
     }
   else
     {
-      if (argr.is_real_type ())
+      if (argr.isreal ())
         {
           // real case
           Matrix R = argr.matrix_value ();
 
           octave::math::chol<Matrix> fact;
           fact.set (R);
           fact.delete_sym (j-1);
 
@@ -1202,17 +1202,17 @@ triangular, return the Cholesky@tie{}fac
   if (j < 0 || j > n+1 || i < 0 || i > n+1)
     error ("cholshift: index I or J is out of range");
 
   octave_value_list retval;
 
   if (argr.is_single_type () && argi.is_single_type ()
       && argj.is_single_type ())
     {
-      if (argr.is_real_type ())
+      if (argr.isreal ())
         {
           // real case
           FloatMatrix R = argr.float_matrix_value ();
 
           octave::math::chol<FloatMatrix> fact;
           fact.set (R);
           fact.shift_sym (i-1, j-1);
 
@@ -1227,17 +1227,17 @@ triangular, return the Cholesky@tie{}fac
           fact.set (R);
           fact.shift_sym (i-1, j-1);
 
           retval = ovl (get_chol_r (fact));
         }
     }
   else
     {
-      if (argr.is_real_type ())
+      if (argr.isreal ())
         {
           // real case
           Matrix R = argr.matrix_value ();
 
           octave::math::chol<Matrix> fact;
           fact.set (R);
           fact.shift_sym (i-1, j-1);
 
diff --git a/libinterp/dldfcn/dmperm.cc b/libinterp/dldfcn/dmperm.cc
--- a/libinterp/dldfcn/dmperm.cc
+++ b/libinterp/dldfcn/dmperm.cc
@@ -62,17 +62,17 @@ dmperm_internal (bool rank, const octave
   SparseMatrix m;
   SparseComplexMatrix cm;
   CXSPARSE_NAME () csm;
   csm.m = nr;
   csm.n = nc;
   csm.x = 0;
   csm.nz = -1;
 
-  if (arg.is_real_type ())
+  if (arg.isreal ())
     {
       m = arg.sparse_matrix_value ();
       csm.nzmax = m.nnz ();
       csm.p = octave::to_suitesparse_intptr (m.xcidx ());
       csm.i = octave::to_suitesparse_intptr (m.xridx ());
     }
   else
     {
diff --git a/libinterp/dldfcn/qr.cc b/libinterp/dldfcn/qr.cc
--- a/libinterp/dldfcn/qr.cc
+++ b/libinterp/dldfcn/qr.cc
@@ -306,17 +306,17 @@ permutation vector instead of a permutat
           else
             retval = ovl (q.R (economy));
         }
     }
   else
     {
       if (arg.is_single_type ())
         {
-          if (arg.is_real_type ())
+          if (arg.isreal ())
             {
               octave::math::qr<FloatMatrix>::type type
                 = qr_type<FloatMatrix> (nargin, nargout);
 
               FloatMatrix m = arg.float_matrix_value ();
 
               switch (nargout)
                 {
@@ -392,17 +392,17 @@ permutation vector instead of a permutat
                       retval = ovl (fact.Q (), get_qr_r (fact), fact.P ());
                   }
                   break;
                 }
             }
         }
       else
         {
-          if (arg.is_real_type ())
+          if (arg.isreal ())
             {
               octave::math::qr<Matrix>::type type = qr_type<Matrix> (nargin, nargout);
 
               Matrix m = arg.matrix_value ();
 
               switch (nargout)
                 {
                 case 0:
@@ -871,17 +871,17 @@ bool check_qr_dims (const octave_value& 
   octave_idx_type n = r.columns ();
   return ((q.ndims () == 2 && r.ndims () == 2 && k == q.columns ())
           && (m == k || (allow_ecf && k == n && k < m)));
 }
 
 static
 bool check_index (const octave_value& i, bool vector_allowed = false)
 {
-  return ((i.is_real_type () || i.isinteger ())
+  return ((i.isreal () || i.isinteger ())
           && (i.is_scalar_type () || vector_allowed));
 }
 
 DEFUN_DLD (qrupdate, args, ,
            doc: /* -*- texinfo -*-
 @deftypefn {} {[@var{Q1}, @var{R1}] =} qrupdate (@var{Q}, @var{R}, @var{u}, @var{v})
 Given a QR@tie{}factorization of a real or complex matrix
 @w{@var{A} = @var{Q}*@var{R}}, @var{Q}@tie{}unitary and
@@ -910,18 +910,18 @@ economized (R is square).
 
   if (! argq.is_numeric_type () || ! argr.is_numeric_type ()
       || ! argu.is_numeric_type () || ! argv.is_numeric_type ())
     print_usage ();
 
   if (! check_qr_dims (argq, argr, true))
     error ("qrupdate: Q and R dimensions don't match");
 
-  if (argq.is_real_type () && argr.is_real_type () && argu.is_real_type ()
-      && argv.is_real_type ())
+  if (argq.isreal () && argr.isreal () && argu.isreal ()
+      && argv.isreal ())
     {
       // all real case
       if (argq.is_single_type () || argr.is_single_type ()
           || argu.is_single_type () || argv.is_single_type ())
         {
           FloatMatrix Q = argq.float_matrix_value ();
           FloatMatrix R = argr.float_matrix_value ();
           FloatMatrix u = argu.float_matrix_value ();
@@ -1096,17 +1096,17 @@ If @var{orient} is @qcode{"row"}, full f
     error ("qrinsert: invalid index J");
 
   octave_value_list retval;
 
   MArray<octave_idx_type> j = argj.octave_idx_type_vector_value ();
 
   octave_idx_type one = 1;
 
-  if (argq.is_real_type () && argr.is_real_type () && argx.is_real_type ())
+  if (argq.isreal () && argr.isreal () && argx.isreal ())
     {
       // real case
       if (argq.is_single_type () || argr.is_single_type ()
           || argx.is_single_type ())
         {
           FloatMatrix Q = argq.float_matrix_value ();
           FloatMatrix R = argr.float_matrix_value ();
           FloatMatrix x = argx.float_matrix_value ();
@@ -1289,17 +1289,17 @@ If @var{orient} is @qcode{"row"}, full f
   MArray<octave_idx_type> j = argj.octave_idx_type_vector_value ();
   if (! check_index (argj, col))
     error ("qrdelete: invalid index J");
 
   octave_value_list retval;
 
   octave_idx_type one = 1;
 
-  if (argq.is_real_type () && argr.is_real_type ())
+  if (argq.isreal () && argr.isreal ())
     {
       // real case
       if (argq.is_single_type () || argr.is_single_type ())
         {
           FloatMatrix Q = argq.float_matrix_value ();
           FloatMatrix R = argr.float_matrix_value ();
 
           octave::math::qr<FloatMatrix> fact (Q, R);
@@ -1514,17 +1514,17 @@ of @w{@var{A}(:,p)}, where @w{p} is the 
   octave_idx_type i = argi.idx_type_value ();
   octave_idx_type j = argj.idx_type_value ();
 
   if (! check_index (argi) || ! check_index (argj))
     error ("qrshift: invalid index I or J");
 
   octave_value_list retval;
 
-  if (argq.is_real_type () && argr.is_real_type ())
+  if (argq.isreal () && argr.isreal ())
     {
       // all real case
       if (argq.is_single_type ()
           && argr.is_single_type ())
         {
           FloatMatrix Q = argq.float_matrix_value ();
           FloatMatrix R = argr.float_matrix_value ();
 
diff --git a/libinterp/dldfcn/symbfact.cc b/libinterp/dldfcn/symbfact.cc
--- a/libinterp/dldfcn/symbfact.cc
+++ b/libinterp/dldfcn/symbfact.cc
@@ -126,17 +126,17 @@ Cholesky@tie{}factorization as determine
   A->itype = CHOLMOD_LONG;
 #else
   A->itype = CHOLMOD_INT;
 #endif
   A->dtype = CHOLMOD_DOUBLE;
   A->stype = 1;
   A->x = &dummy;
 
-  if (args(0).is_real_type ())
+  if (args(0).isreal ())
     {
       const SparseMatrix a = args(0).sparse_matrix_value ();
       A->nrow = a.rows ();
       A->ncol = a.cols ();
       A->p = a.cidx ();
       A->i = a.ridx ();
       A->nzmax = a.nnz ();
       A->xtype = CHOLMOD_REAL;
diff --git a/libinterp/dldfcn/symrcm.cc b/libinterp/dldfcn/symrcm.cc
--- a/libinterp/dldfcn/symrcm.cc
+++ b/libinterp/dldfcn/symrcm.cc
@@ -450,17 +450,17 @@ Mathematics, ISBN 0-13-165274-5, 1981.
 
   // the parameter of the matrix is converted into a sparse matrix
   //(if necessary)
   octave_idx_type *cidx;
   octave_idx_type *ridx;
   SparseMatrix Ar;
   SparseComplexMatrix Ac;
 
-  if (arg.is_real_type ())
+  if (arg.isreal ())
     {
       Ar = arg.sparse_matrix_value ();
       // Note cidx/ridx are const, so use xridx and xcidx...
       cidx = Ar.xcidx ();
       ridx = Ar.xridx ();
     }
   else
     {
diff --git a/libinterp/octave-value/ov-base-int.h b/libinterp/octave-value/ov-base-int.h
--- a/libinterp/octave-value/ov-base-int.h
+++ b/libinterp/octave-value/ov-base-int.h
@@ -56,17 +56,17 @@ public:
   octave_base_value * clone (void) const
   { return new octave_base_int_matrix (*this); }
 
   octave_base_value * empty_clone (void) const
   { return new octave_base_int_matrix (); }
 
   octave_base_value * try_narrowing_conversion (void);
 
-  bool is_real_type (void) const { return true; }
+  bool isreal (void) const { return true; }
 
   //  void increment (void) { matrix += 1; }
 
   //  void decrement (void) { matrix -= 1; }
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   octave_value convert_to_str_internal (bool, bool, char type) const;
@@ -114,17 +114,17 @@ public:
 
   octave_base_value * clone (void) const
   { return new octave_base_int_scalar (*this); }
   octave_base_value * empty_clone (void) const
   { return new octave_base_int_scalar (); }
 
   octave_base_value * try_narrowing_conversion (void) { return 0; }
 
-  bool is_real_type (void) const { return true; }
+  bool isreal (void) const { return true; }
 
   bool is_real_scalar (void) const { return true; }
 
   //  void increment (void) { scalar += 1; }
 
   //  void decrement (void) { scalar -= 1; }
 
   octave_value convert_to_str_internal (bool, bool, char type) const;
diff --git a/libinterp/octave-value/ov-base.h b/libinterp/octave-value/ov-base.h
--- a/libinterp/octave-value/ov-base.h
+++ b/libinterp/octave-value/ov-base.h
@@ -408,17 +408,17 @@ public:
   virtual bool is_uint32_type (void) const { return false; }
 
   virtual bool is_uint64_type (void) const { return false; }
 
   virtual bool islogical (void) const { return false; }
 
   virtual bool isinteger (void) const { return false; }
 
-  virtual bool is_real_type (void) const { return false; }
+  virtual bool isreal (void) const { return false; }
 
   virtual bool iscomplex (void) const { return false; }
 
   // Would be nice to get rid of the next four functions:
 
   virtual bool is_scalar_type (void) const { return false; }
 
   virtual bool is_matrix_type (void) const { return false; }
diff --git a/libinterp/octave-value/ov-bool-mat.h b/libinterp/octave-value/ov-bool-mat.h
--- a/libinterp/octave-value/ov-bool-mat.h
+++ b/libinterp/octave-value/ov-bool-mat.h
@@ -93,17 +93,17 @@ public:
   }
 
   builtin_type_t builtin_type (void) const { return btyp_bool; }
 
   bool is_bool_matrix (void) const { return true; }
 
   bool islogical (void) const { return true; }
 
-  bool is_real_type (void) const { return true; }
+  bool isreal (void) const { return true; }
 
   bool is_numeric_type (void) const { return false; }
 
   int8NDArray
   int8_array_value (void) const { return int8NDArray (matrix); }
 
   int16NDArray
   int16_array_value (void) const { return int16NDArray (matrix); }
diff --git a/libinterp/octave-value/ov-bool-sparse.h b/libinterp/octave-value/ov-bool-sparse.h
--- a/libinterp/octave-value/ov-bool-sparse.h
+++ b/libinterp/octave-value/ov-bool-sparse.h
@@ -91,17 +91,17 @@ public:
   }
 
   builtin_type_t builtin_type (void) const { return btyp_bool; }
 
   bool is_bool_matrix (void) const { return true; }
 
   bool islogical (void) const { return true; }
 
-  bool is_real_type (void) const { return true; }
+  bool isreal (void) const { return true; }
 
   bool is_numeric_type (void) const { return false; }
 
   double double_value (bool = false) const;
 
   double scalar_value (bool frc_str_conv = false) const
   { return double_value (frc_str_conv); }
 
diff --git a/libinterp/octave-value/ov-bool.h b/libinterp/octave-value/ov-bool.h
--- a/libinterp/octave-value/ov-bool.h
+++ b/libinterp/octave-value/ov-bool.h
@@ -76,17 +76,17 @@ public:
   builtin_type_t builtin_type (void) const { return btyp_bool; }
 
   bool is_real_scalar (void) const { return true; }
 
   bool is_bool_scalar (void) const { return true; }
 
   bool islogical (void) const { return true; }
 
-  bool is_real_type (void) const { return true; }
+  bool isreal (void) const { return true; }
 
   bool is_numeric_type (void) const { return false; }
 
   bool is_true (void) const { return scalar; }
 
   int8NDArray
   int8_array_value (void) const
   { return int8NDArray (dim_vector (1, 1), scalar); }
diff --git a/libinterp/octave-value/ov-ch-mat.h b/libinterp/octave-value/ov-ch-mat.h
--- a/libinterp/octave-value/ov-ch-mat.h
+++ b/libinterp/octave-value/ov-ch-mat.h
@@ -89,17 +89,17 @@ public:
 
   idx_vector index_vector (bool require_integers = false) const;
 
   builtin_type_t builtin_type (void) const { return btyp_char; }
 
   bool is_char_matrix (void) const { return true; }
   bool is_real_matrix (void) const { return true; }
 
-  bool is_real_type (void) const { return true; }
+  bool isreal (void) const { return true; }
 
   double double_value (bool = false) const;
 
   float float_value (bool = false) const;
 
   double scalar_value (bool frc_str_conv = false) const
   { return double_value (frc_str_conv); }
 
diff --git a/libinterp/octave-value/ov-float.h b/libinterp/octave-value/ov-float.h
--- a/libinterp/octave-value/ov-float.h
+++ b/libinterp/octave-value/ov-float.h
@@ -80,17 +80,17 @@ public:
 
   octave_value any (int = 0) const
   { return (scalar != 0 && ! lo_ieee_isnan (scalar)); }
 
   builtin_type_t builtin_type (void) const { return btyp_float; }
 
   bool is_real_scalar (void) const { return true; }
 
-  bool is_real_type (void) const { return true; }
+  bool isreal (void) const { return true; }
 
   bool is_single_type (void) const { return true; }
 
   bool is_float_type (void) const { return true; }
 
   int8NDArray
   int8_array_value (void) const
   { return int8NDArray (dim_vector (1, 1), scalar); }
diff --git a/libinterp/octave-value/ov-flt-re-diag.h b/libinterp/octave-value/ov-flt-re-diag.h
--- a/libinterp/octave-value/ov-flt-re-diag.h
+++ b/libinterp/octave-value/ov-flt-re-diag.h
@@ -58,17 +58,17 @@ public:
   type_conv_info numeric_conversion_function (void) const;
 
   octave_base_value * try_narrowing_conversion (void);
 
   builtin_type_t builtin_type (void) const { return btyp_float; }
 
   bool is_real_matrix (void) const { return true; }
 
-  bool is_real_type (void) const { return true; }
+  bool isreal (void) const { return true; }
 
   bool is_single_type (void) const { return true; }
 
   bool is_float_type (void) const { return true; }
 
   DiagMatrix diag_matrix_value (bool = false) const;
 
   FloatDiagMatrix float_diag_matrix_value (bool = false) const;
diff --git a/libinterp/octave-value/ov-flt-re-mat.h b/libinterp/octave-value/ov-flt-re-mat.h
--- a/libinterp/octave-value/ov-flt-re-mat.h
+++ b/libinterp/octave-value/ov-flt-re-mat.h
@@ -92,17 +92,17 @@ public:
   {
     return idx_cache ? *idx_cache : set_idx_cache (idx_vector (matrix));
   }
 
   builtin_type_t builtin_type (void) const { return btyp_float; }
 
   bool is_real_matrix (void) const { return true; }
 
-  bool is_real_type (void) const { return true; }
+  bool isreal (void) const { return true; }
 
   bool is_single_type (void) const { return true; }
 
   bool is_float_type (void) const { return true; }
 
   int8NDArray
   int8_array_value (void) const { return int8NDArray (matrix); }
 
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -1622,17 +1622,17 @@ unbox (JNIEnv *jni_env, const octave_val
       Matrix m = val.matrix_value ();
       jdoubleArray dv = jni_env->NewDoubleArray (m.numel ());
       jni_env->SetDoubleArrayRegion (dv, 0, m.numel (), m.fortran_vec ());
       jobj = dv;
       jcls = jni_env->GetObjectClass (jobj);
     }
   else if (Vjava_matrix_autoconversion
            && (val.is_matrix_type () || val.is_range ())
-           && val.is_real_type ())
+           && val.isreal ())
     {
       jclass_ref mcls (jni_env, find_octave_class (jni_env,
                                                    "org/octave/Matrix"));
       dim_vector dims = val.dims ();
       jintArray_ref iv (jni_env, jni_env->NewIntArray (dims.ndims ()));
       jint *iv_data = jni_env->GetIntArrayElements (jintArray (iv), 0);
 
       for (int i = 0; i < dims.ndims (); i++)
diff --git a/libinterp/octave-value/ov-lazy-idx.h b/libinterp/octave-value/ov-lazy-idx.h
--- a/libinterp/octave-value/ov-lazy-idx.h
+++ b/libinterp/octave-value/ov-lazy-idx.h
@@ -64,17 +64,17 @@ public:
   octave_value full_value (void) const { return make_value (); }
 
   idx_vector index_vector (bool /* require_integers */ = false) const { return index; }
 
   builtin_type_t builtin_type (void) const { return btyp_double; }
 
   bool is_real_matrix (void) const { return true; }
 
-  bool is_real_type (void) const { return true; }
+  bool isreal (void) const { return true; }
 
   bool is_double_type (void) const { return true; }
 
   bool is_float_type (void) const { return true; }
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx)
   { return make_value ().subsref (type, idx); }
diff --git a/libinterp/octave-value/ov-perm.h b/libinterp/octave-value/ov-perm.h
--- a/libinterp/octave-value/ov-perm.h
+++ b/libinterp/octave-value/ov-perm.h
@@ -113,17 +113,17 @@ public:
   bool is_numeric_type (void) const { return true; }
 
   bool is_defined (void) const { return true; }
 
   bool is_constant (void) const { return true; }
 
   bool is_real_matrix (void) const { return true; }
 
-  bool is_real_type (void) const { return true; }
+  bool isreal (void) const { return true; }
 
   bool is_double_type (void) const { return true; }
 
   bool is_float_type (void) const { return true; }
 
   bool is_true (void) const;
 
   double double_value (bool = false) const;
diff --git a/libinterp/octave-value/ov-range.h b/libinterp/octave-value/ov-range.h
--- a/libinterp/octave-value/ov-range.h
+++ b/libinterp/octave-value/ov-range.h
@@ -152,17 +152,17 @@ public:
   Array<octave_idx_type> sort_rows_idx (sortmode) const
   { return Array<octave_idx_type> (dim_vector (1, 0)); }
 
   sortmode is_sorted_rows (sortmode mode = UNSORTED) const
   { return mode ? mode : ASCENDING; }
 
   builtin_type_t builtin_type (void) const { return btyp_double; }
 
-  bool is_real_type (void) const { return true; }
+  bool isreal (void) const { return true; }
 
   bool is_double_type (void) const { return true; }
 
   bool is_float_type (void) const { return true; }
 
   bool is_numeric_type (void) const { return true; }
 
   bool is_true (void) const;
diff --git a/libinterp/octave-value/ov-re-diag.h b/libinterp/octave-value/ov-re-diag.h
--- a/libinterp/octave-value/ov-re-diag.h
+++ b/libinterp/octave-value/ov-re-diag.h
@@ -63,17 +63,17 @@ public:
 
   octave_value do_index_op (const octave_value_list& idx,
                             bool resize_ok = false);
 
   builtin_type_t builtin_type (void) const { return btyp_double; }
 
   bool is_real_matrix (void) const { return true; }
 
-  bool is_real_type (void) const { return true; }
+  bool isreal (void) const { return true; }
 
   bool is_double_type (void) const { return true; }
 
   bool is_float_type (void) const { return true; }
 
   DiagMatrix diag_matrix_value (bool = false) const;
 
   FloatDiagMatrix float_diag_matrix_value (bool = false) const;
diff --git a/libinterp/octave-value/ov-re-mat.h b/libinterp/octave-value/ov-re-mat.h
--- a/libinterp/octave-value/ov-re-mat.h
+++ b/libinterp/octave-value/ov-re-mat.h
@@ -105,17 +105,17 @@ public:
 
   idx_vector index_vector (bool /* require_integers */ = false) const
   { return idx_cache ? *idx_cache : set_idx_cache (idx_vector (matrix)); }
 
   builtin_type_t builtin_type (void) const { return btyp_double; }
 
   bool is_real_matrix (void) const { return true; }
 
-  bool is_real_type (void) const { return true; }
+  bool isreal (void) const { return true; }
 
   bool is_double_type (void) const { return true; }
 
   bool is_float_type (void) const { return true; }
 
   int8NDArray
   int8_array_value (void) const { return int8NDArray (matrix); }
 
diff --git a/libinterp/octave-value/ov-re-sparse.h b/libinterp/octave-value/ov-re-sparse.h
--- a/libinterp/octave-value/ov-re-sparse.h
+++ b/libinterp/octave-value/ov-re-sparse.h
@@ -92,17 +92,17 @@ public:
   octave_base_value * try_narrowing_conversion (void);
 
   idx_vector index_vector (bool require_integers = false) const;
 
   builtin_type_t builtin_type (void) const { return btyp_double; }
 
   bool is_real_matrix (void) const { return true; }
 
-  bool is_real_type (void) const { return true; }
+  bool isreal (void) const { return true; }
 
   bool is_double_type (void) const { return true; }
 
   bool is_float_type (void) const { return true; }
 
   double double_value (bool = false) const;
 
   double scalar_value (bool frc_str_conv = false) const
diff --git a/libinterp/octave-value/ov-scalar.h b/libinterp/octave-value/ov-scalar.h
--- a/libinterp/octave-value/ov-scalar.h
+++ b/libinterp/octave-value/ov-scalar.h
@@ -79,17 +79,17 @@ public:
 
   octave_value any (int = 0) const
   { return (scalar != 0 && ! lo_ieee_isnan (scalar)); }
 
   builtin_type_t builtin_type (void) const { return btyp_double; }
 
   bool is_real_scalar (void) const { return true; }
 
-  bool is_real_type (void) const { return true; }
+  bool isreal (void) const { return true; }
 
   bool is_double_type (void) const { return true; }
 
   bool is_float_type (void) const { return true; }
 
   int8NDArray
   int8_array_value (void) const
   { return int8NDArray (dim_vector (1, 1), scalar); }
diff --git a/libinterp/octave-value/ov.h b/libinterp/octave-value/ov.h
--- a/libinterp/octave-value/ov.h
+++ b/libinterp/octave-value/ov.h
@@ -669,18 +669,22 @@ public:
 
   bool isinteger (void) const
   { return rep->isinteger (); }
 
   OCTAVE_DEPRECATED ("use 'isinteger' instead")
   bool is_integer_type (void) const
   { return rep->isinteger (); }
 
+  bool isreal (void) const
+  { return rep->isreal (); }
+
+  OCTAVE_DEPRECATED ("use 'isreal' instead")
   bool is_real_type (void) const
-  { return rep->is_real_type (); }
+  { return rep->isreal (); }
 
   bool iscomplex (void) const
   { return rep->iscomplex (); }
 
   OCTAVE_DEPRECATED ("use 'iscomplex' instead")
   bool is_complex_type (void) const
   { return rep->iscomplex (); }
 
diff --git a/libinterp/parse-tree/pt-tm-const.cc b/libinterp/parse-tree/pt-tm-const.cc
--- a/libinterp/parse-tree/pt-tm-const.cc
+++ b/libinterp/parse-tree/pt-tm-const.cc
@@ -94,20 +94,20 @@ namespace octave
       all_sq_str = false;
 
     if (all_dq_str && ! val.is_dq_string ())
       all_dq_str = false;
 
     if (! some_str && val.is_string ())
       some_str = true;
 
-    if (all_real && ! val.is_real_type ())
+    if (all_real && ! val.isreal ())
       all_real = false;
 
-    if (all_cmplx && ! (val.iscomplex () || val.is_real_type ()))
+    if (all_cmplx && ! (val.iscomplex () || val.isreal ()))
       all_cmplx = false;
 
     if (! any_cell && val.iscell ())
       any_cell = true;
 
     if (! any_sparse && val.is_sparse_type ())
       any_sparse = true;
 
