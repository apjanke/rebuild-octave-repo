# HG changeset patch
# User Rik <octave@nomad.inbox5.com>
# Date 1326401664 28800
#      Thu Jan 12 12:54:24 2012 -0800
# Node ID 67a0ab9f8283b14f33e161c6bf40ff08fd991045
# Parent  969532305835d15d22bf1e9452a11a18c8147241
# Parent  f50e5fa121cff65dac9ac594e06c07f1c690333d
maint: Merge stable to default branch.

diff --git a/.hgsubstate b/.hgsubstate
--- a/.hgsubstate
+++ b/.hgsubstate
@@ -1,1 +1,1 @@
-3559997a03e82d650aaa708447362fe20a6eaf15 gnulib
+f9813bce2c06a6130a68db4478d1b16ddadaf276 gnulib
diff --git a/.hgtags b/.hgtags
--- a/.hgtags
+++ b/.hgtags
@@ -50,8 +50,11 @@ 6c69a7c39039bccd5a2fe481fcc7f896c82b160b
 3cbc0d77db48aec32bcb202d09a036d2cb9cc3b9 ss-3-3-53
 bd2643f0ce57d070963bedd48857405f6924aa85 ss-3-3-54
 695141f1c05cf1b240592bdd18e7a1503bb2a539 ss-3-3-55
 901d466ee55ac902a875ec0ade6f1eccef0841dc release-3-4-1
 3666e8e6f96e6899b8306d6ea9614aadf0500d67 release-3-4-2
 b0e70a71647b671ebcfa7a79af1ae6d3c0f52065 release-3-4-3
 3781981be535e80d44c85373b8fdaa60ca5cd097 ss-3-5-90
 ff5588774680d4f54567311fc109c8e351950f1c ss-3-5-91
+a737b3fb9c4d89d3694da6b4e623aeee64b212e1 ss-3-5-92
+72aebe6196414e38ef802469ff6e238f914f04c9 rc-3-6-0-0
+64d9f33313cc8c691974bcd123357e24bccbabdc rc-3-6-0-1
diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -1,12 +1,21 @@
 Summary of important user-visible changes for version 3.6:
 ---------------------------------------------------------
 
- ** The PCRE library is now required to build Octave.
+ ** The PCRE library is now required to build Octave.  If a pre-compiled
+    package does not exist for your system, you can find PCRE sources
+    at http://www.pcre.org
+
+ ** The ARPACK library is no longer distributed with Octave.
+    If you need the eigs or svds functions you must provide an
+    external ARPACK through a package manager or by compiling it
+    yourself.  If a pre-compiled package does not exist for your system,
+    you can find the current ARPACK sources at
+    http://forge.scilab.org/index.php/p/arpack-ng
 
  ** Many of Octave's binary operators (.*, .^, +, -, ...) now perform
     automatic broadcasting for array operations that allows you to use
     operator notation instead of calling bsxfun or expanding arrays (and
     unnecessarily wasting memory) with repmat or similar idioms.  For
     example, to scale the columns of a matrix by the elements of a row
     vector, you may now write
 
@@ -43,35 +52,36 @@ Summary of important user-visible change
       +=  -=  .+=  .-=  .*=  ./=  .\=  .^=  .**=  &=  |=
 
     See the "Broadcasting" section in the new "Vectorization and Faster
     Code Execution" chapter of the manual for more details.
 
  ** Octave now features a profiler, thanks to the work of Daniel Kraft
     under the Google Summer of Code mentorship program.  The manual has
     been updated to reflect this addition.  The new user-visible
-    functions are profexplore, profile, and profshow.
+    functions are profile, profshow, and profexplore.
 
  ** Overhaul of statistical distribution functions
 
     Functions now return "single" outputs for inputs of class "single".
 
     75% reduction in memory usage through use of logical indexing.
 
-    Random sample functions now use the same syntax as rand() and accept
+    Random sample functions now use the same syntax as rand and accept
     a comma separated list of dimensions or a dimension vector.
 
     Functions have been made Matlab-compatible with regard to special
     cases (probability on boundaries, probabilities for values outside
     distribution, etc.).  This may cause subtle changes to existing
     scripts.
 
-    negative binomial function has been extended to real, non-integer inputs.
-    discrete_inv() now returns v(1) for 0 instead of NaN.
-    nbincdf() recoded to use closed form solution with betainc().
+    negative binomial function has been extended to real, non-integer
+    inputs.  The discrete_inv fucntion now returns v(1) for 0 instead of
+    NaN.  The nbincdf fucntion has bbeen recoded to use a closed form
+    solution with betainc.
 
  ** strread, textscan, and textread have been completely revamped.
 
     They now support nearly all Matlab functionality including:
 
       * Matlab-compatible whitespace and delimiter defaults
 
       * Matlab-compatible options: 'whitespace', treatasempty', format
@@ -162,20 +172,22 @@ Summary of important user-visible change
     functions nor the waitfor function.
 
  ** New keyword parfor (parallel for loop) is now recognized as a valid
     keyword.  Implementation, however, is still mapped to an ordinary
     for loop.
 
  ** Other new functions added in 3.6.0:
 
-      is_dq_string    nthargout    usejava     
-      is_sq_string    python       waitbar
-      narginchk       recycle      zscore            
-    
+      bicg                       nthargout                   usejava
+      is_dq_string               narginchk                   waitbar
+      is_sq_string               python                      zscore
+      is_function_handle         register_graphics_toolkit 
+      loaded_graphics_toolkits   recycle                   
+
  ** Deprecated functions.
 
     The following functions were deprecated in Octave 3.2 and have been
     removed from Octave 3.6.
                                            
       create_set          spcholinv    splu   
       dmult               spcumprod    spmax
       iscommand           spcumsum     spmin
@@ -392,18 +404,18 @@ Summary of important user-visible change
     also try to do the operation in-place if it's argument is a
     temporary expression.
 
  ** The effect of comparison operators (<, >, <=, and >=) applied to
     complex numbers has changed to be consistent with the strict
     ordering defined by the `max', `min', and `sort' functions.  More
     specifically, complex numbers are compared by lexicographical
     comparison of the pairs `[abs(z), arg(z)]'.  Previously, only real
-    parts were compared; this can be trivially achieved by wrapping the
-    operands in real().
+    parts were compared; this can be trivially achieved by converting
+    the operands to real values with the `real' function.
 
  ** The automatic simplification of complex computation results has
     changed.  Octave will now simplify any complex number with a zero
     imaginary part or any complex matrix with all elements having zero
     imaginary part to a real value.  Previously, this was done only for
     positive zeros.  Note that the behavior of the complex function is
     unchanged and it still produces a complex value even if the
     imaginary part is zero.
@@ -522,17 +534,17 @@ Summary of important user-visible change
     space allocated for nonzero elements).
 
     Sparse concatenation is also affected, and concatenating sparse 
     matrices, especially larger collections, is now significantly more 
     efficient.  This applies to both the [] operator and the 
     cat/vertcat/horzcat functions.
 
  ** It is now possible to optionally employ the xGESDD LAPACK drivers
-    for computing the singular value decomposition using svd(), instead
+    for computing the singular value decomposition using svd, instead
     of the default xGESVD, using the configuration pseudo-variable
     svd_driver.  The xGESDD driver can be up to 6x times faster when
     singular vectors are requested, but is reported to be somewhat less
     robust on highly ill-conditioned matrices.
 
  ** Configuration pseudo-variables, such as page_screen_output or 
     confirm_recursive_rmdir (or the above mentioned svd_driver), now 
     accept a "local" option as second argument, requesting the change 
@@ -707,17 +719,17 @@ Summary of important user-visible change
     have been added to these group objects such that
 
            x = 0:0.1:10;
            y = sin (x);
            plot (x, y, "ydatasource", "y");
            for i = 1 : 100
              pause(0.1)
              y = sin (x + 0.1 * i);
-             refreshdata();
+             refreshdata ();
            endfor
 
     works as expected.  This capability has be used to introduce
     stem-series, bar-series, etc., objects for better Matlab
     compatibility.
 
  ** New graphics functions:
 
diff --git a/autogen.sh b/autogen.sh
--- a/autogen.sh
+++ b/autogen.sh
@@ -32,8 +32,22 @@ echo "generating doc/interpreter/images.
 
 echo "generating src/DLD-FUNCTIONS/module.mk..."
 
 (cd src/DLD-FUNCTIONS; ./config-module.sh)
 
 echo "bootstrapping..."
 
 build-aux/bootstrap "$@"
+
+## G77 is obsolete, but it is still the first option in the autoconf Fortran
+## macros.  We should avoid it, because mixing old versions of g77 with modern
+## gcc and g++ causes trouble.  The following will make it harder (but not
+## impossible) for users to make this mistake.
+##
+## FIXME -- we should really work to fix autoconf so that it prefers gfortran
+## over g77 even when searching for a Fortran 77 compiler.
+
+echo "replacing all occurrences of g77 with gfortran in configure script..."
+
+sed 's/g77/gfortran/g' configure > configure.t
+mv configure.t configure
+chmod 755 configure
diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -22,23 +22,23 @@ dnl Copyright (C) 1993-2012 John W. Eato
 
 ### Preserve CFLAGS and CXXFLAGS from the environment before doing
 ### anything else because we don't know which macros might call
 ### AC_PROG_CC or AC_PROG_CXX.
 
 EXTERN_CFLAGS="$CFLAGS"
 EXTERN_CXXFLAGS="$CXXFLAGS"
 
-AC_INIT([GNU Octave], [3.5.91+], [http://octave.org/bugs.html], [octave])
+AC_INIT([GNU Octave], [3.6.0-rc1], [http://octave.org/bugs.html], [octave])
 
 dnl PACKAGE_VERSION is set by the AC_INIT VERSION arg
 OCTAVE_VERSION="$PACKAGE_VERSION"
-OCTAVE_API_VERSION_NUMBER="46"
+OCTAVE_API_VERSION_NUMBER="47"
 OCTAVE_API_VERSION="api-v$OCTAVE_API_VERSION_NUMBER+"
-OCTAVE_RELEASE_DATE="2011-12-23"
+OCTAVE_RELEASE_DATE="2012-01-12"
 OCTAVE_COPYRIGHT="Copyright (C) 2012 John W. Eaton and others."
 AC_SUBST(OCTAVE_VERSION)
 AC_SUBST(OCTAVE_API_VERSION_NUMBER)
 AC_SUBST(OCTAVE_API_VERSION)
 AC_SUBST(OCTAVE_RELEASE_DATE)
 AC_SUBST(OCTAVE_COPYRIGHT)
 
 AC_REVISION($Revision: 1.603 $)
diff --git a/doc/interpreter/contributors.in b/doc/interpreter/contributors.in
--- a/doc/interpreter/contributors.in
+++ b/doc/interpreter/contributors.in
@@ -20,16 +20,17 @@ Paul Boven
 Richard Bovey
 John Bradshaw
 Marcus Brinkmann
 Remy Bruno
 Ansgar Burchard
 Marco Caliari
 Daniel Calvelo
 John C. Campbell
+Juan Pablo Carbajal
 Jean-Francois Cardoso
 Joao Cardoso
 Larrie Carr
 David Castelow
 Vincent Cautaerts
 Clinton Chee
 Albert Chin-A-Young
 Carsten Clark
diff --git a/doc/interpreter/doccheck/aspell-octave.en.pws b/doc/interpreter/doccheck/aspell-octave.en.pws
--- a/doc/interpreter/doccheck/aspell-octave.en.pws
+++ b/doc/interpreter/doccheck/aspell-octave.en.pws
@@ -33,16 +33,17 @@ AutoCAD
 Autoconf
 autocorrelations
 autocovariances
 autoload
 Autoload
 autoloaded
 autoloading
 Autoloading
+Automake
 autoregression
 autoregressions
 autoscaled
 AutoScaling
 AWK
 awt
 backend
 Backends
@@ -77,16 +78,17 @@ boolMatrix
 boxerrorbars
 boxoff
 boxon
 boxxyerrorbars
 bracketx
 brackety
 breakpoint
 Brenan
+broadcastable
 Brockwell
 BSX
 builtin
 builtins
 ButtonDownFcn
 BV
 bz
 BZ
@@ -300,16 +302,17 @@ fontname
 forall
 foregroundcolor
 formfeed
 Fortran
 fpdf
 fprintf
 FreeBSD
 freespacing
+FreeType
 freetype
 frnd
 frob
 Frobenius
 Fs
 FSF
 FunValCheck
 gamcdf
@@ -334,25 +337,27 @@ gesvd
 gfortan
 Ghostscript
 gif
 GIF
 glibc
 globbing
 glpk
 GLS
+gnulib
 gnuplot
 Gnuplot
 gnuplot's
 Golub
 Gonnet
 goto
 Goto
 gotos
 GPL
+GPLK
 gplot
 grabdemo
 GradObj
 GraphicsMagick
 Graymap
 grayscale
 Graz
 griddata
@@ -480,16 +485,17 @@ leq
 Levinson
 LF
 lfloor
 li
 libcruft
 libcurl
 liblapack
 liboctave
+Libtool
 licensors
 lineanchors
 linefeeds
 linesearch
 linespec
 linespoints
 linkprop
 literalspacing
@@ -546,16 +552,17 @@ meshgrid
 meshgridded
 metafile
 Metafile
 metafiles
 Metafont
 mex
 Michelsen
 Microsystems
+MinGW
 minima
 Minimizers
 Minitab
 minval
 MIP
 miscompiled
 Misra
 mkoctfile
@@ -567,16 +574,17 @@ mmmm
 mmmyy
 mmmyyyy
 modelled
 Moler
 Montanet
 mpoles
 mpower
 mrdivide
+MSYS
 mtimes
 Multi
 multi
 multibyte
 multiline
 multipledelimsasone
 MultiSelect
 mxArray
@@ -740,16 +748,17 @@ readline
 recursing
 reentrant
 regex
 regressor
 reimported
 Reindent
 relicensing
 ren
+renderer
 repelems
 repmat
 resampled
 resampling
 Resize
 resize
 resized
 resnorm
@@ -776,16 +785,17 @@ Sandia
 SAS
 sB
 Schafer
 schar
 Schur
 SCO
 screenful
 se
+sed
 seealso
 semidefinite
 Sep
 Shampine
 shiftdim
 si
 signum
 SIGNUM
@@ -904,16 +914,17 @@ textscan
 th
 ths
 tif
 Tikhonov
 TikZ
 tinv
 Tisseur
 Tisseur's
+tmp
 Toeplitz
 tokenExtents
 TolF
 TolFun
 TolX
 toolkits
 Toolkits
 tp
@@ -1041,18 +1052,20 @@ xu
 xwd
 xy
 xyerrorbar
 xyerrorbars
 xyz
 ydata
 yerrorbar
 yerrorbars
+ylim
 yy
 YY
 yyyy
 YYYY
 yyyymmdd
 yyyymmddTHHMMSS
 Zechner
 zer
 Ziggurat
 zlib
+zlim
diff --git a/doc/interpreter/doccheck/mk_undocumented_list b/doc/interpreter/doccheck/mk_undocumented_list
--- a/doc/interpreter/doccheck/mk_undocumented_list
+++ b/doc/interpreter/doccheck/mk_undocumented_list
@@ -4,17 +4,17 @@
 # Get a list from Octave of all visible functions
 @octave_output = <<`_END_OCT_SCRIPT_`;
 ../../run-octave --norc --silent --no-history --eval '\
  funclist  = vertcat (__list_functions__ , __builtins__) \
  disp("#!-separator-!#") \
  where = cellfun (\@which, funclist, \"UniformOutput\", 0)'
 _END_OCT_SCRIPT_
 
-die "Unable to invoke 'run-octave'.  Exiting\n" unless (@octave_output);
+unless (@octave_output) { die "Unable to invoke 'run-octave'.  Exiting\n" ;}
 
 ################################################################################
 # Winnow list of functions that require a DOCSTRING
 
 $idx = 0;
 while (($_ = $octave_output[$idx++]) !~ /^#!-separator-!#$/)
 {
    push(@all_functions, $1) if (/] = (\w+)$/);
@@ -81,19 +81,19 @@ bug_report
 chdir
 comma
 debug
 dbnext
 exit
 F_DUPFD
 F_GETFD
 F_GETFL
+fact
 finite
 fmod
-fntests
 F_SETFD
 F_SETFL
 gammaln
 home
 i
 ifelse
 inf
 inverse
diff --git a/doc/interpreter/expr.txi b/doc/interpreter/expr.txi
--- a/doc/interpreter/expr.txi
+++ b/doc/interpreter/expr.txi
@@ -518,36 +518,36 @@ and matrices.  The element-by-element op
 @table @asis
 @item @var{x} + @var{y}
 @opindex +
 Addition.  If both operands are matrices, the number of rows and columns
 must both agree, or they must be broadcastable to the same shape.
 
 @item @var{x} .+ @var{y}
 @opindex .+
-Element by element addition.  This operator is equivalent to @code{+}.
+Element-by-element addition.  This operator is equivalent to @code{+}.
 
 @item @var{x} - @var{y}
 @opindex -
 Subtraction.  If both operands are matrices, the number of rows and
 columns of both must agree, or they must be broadcastable to the same
 shape.
 
 @item @var{x} .- @var{y}
-Element by element subtraction.  This operator is equivalent to @code{-}.
+Element-by-element subtraction.  This operator is equivalent to @code{-}.
 
 @item @var{x} * @var{y}
 @opindex *
-Matrix multiplication. The number of columns of @var{x} must agree with
+Matrix multiplication.  The number of columns of @var{x} must agree with
 the number of rows of @var{y}, or they must be broadcastable to the same
 shape.
 
 @item @var{x} .* @var{y}
 @opindex .*
-Element by element multiplication. If both operands are matrices, the
+Element-by-element multiplication.  If both operands are matrices, the
 number of rows and columns must both agree, or they must be
 broadcastable to the same shape.
 
 @item @var{x} / @var{y}
 @opindex /
 Right division.  This is conceptually equivalent to the expression
 
 @example
@@ -557,17 +557,17 @@ Right division.  This is conceptually eq
 @noindent
 but it is computed without forming the inverse of @var{y'}.
 
 If the system is not square, or if the coefficient matrix is singular,
 a minimum norm solution is computed.
 
 @item @var{x} ./ @var{y}
 @opindex ./
-Element by element right division.
+Element-by-element right division.
 
 @item @var{x} \ @var{y}
 @opindex \
 Left division.  This is conceptually equivalent to the expression
 
 @example
 inverse (x) * y
 @end example
@@ -575,17 +575,17 @@ inverse (x) * y
 @noindent
 but it is computed without forming the inverse of @var{x}.
 
 If the system is not square, or if the coefficient matrix is singular,
 a minimum norm solution is computed.
 
 @item @var{x} .\ @var{y}
 @opindex .\
-Element by element left division.  Each element of @var{y} is divided
+Element-by-element left division.  Each element of @var{y} is divided
 by each corresponding element of @var{x}.
 
 @item @var{x} ^ @var{y}
 @itemx @var{x} ** @var{y}
 @opindex **
 @opindex ^
 Power operator.  If @var{x} and @var{y} are both scalars, this operator
 returns @var{x} raised to the power @var{y}.  If @var{x} is a scalar and
@@ -596,19 +596,23 @@ expansion if @var{y} is not an integer. 
 @var{x} and @var{y} are matrices.
 
 The implementation of this operator needs to be improved.
 
 @item @var{x} .^ @var{y}
 @itemx @var{x} .** @var{y}
 @opindex .**
 @opindex .^
-Element by element power operator. If both operands are matrices, the
+Element-by-element power operator.  If both operands are matrices, the
 number of rows and columns must both agree, or they must be
-broadcastable to the same shape.
+broadcastable to the same shape.  If several complex results are
+possible, the one with smallest non-negative argument (angle) is taken.
+This rule may return a complex root even when a real root is also possible.
+Use @code{realpow}, @code{realsqrt}, @code{cbrt}, or @code{nthroot} if a
+real result is preferred.
 
 @item -@var{x}
 @opindex -
 Negation.
 
 @item +@var{x}
 @opindex +
 Unary plus.  This operator has no effect on the operand.
@@ -623,17 +627,17 @@ equivalent to the expression
 conj (x.')
 @end example
 
 @item @var{x}.'
 @opindex .'
 Transpose.
 @end table
 
-Note that because Octave's element by element operators begin with a
+Note that because Octave's element-by-element operators begin with a
 @samp{.}, there is a possible ambiguity for statements like
 
 @example
 1./m
 @end example
 
 @noindent
 because the period could be interpreted either as part of the constant
diff --git a/doc/interpreter/func.txi b/doc/interpreter/func.txi
--- a/doc/interpreter/func.txi
+++ b/doc/interpreter/func.txi
@@ -1140,16 +1140,18 @@ list.  If there are no arguments, you mu
 f = @@sin;
 feval (f, pi/4)
     @result{} 0.70711
 f (pi/4)
     @result{} 0.70711
 @end group
 @end example
 
+@DOCSTRING(is_function_handle)
+
 @DOCSTRING(functions)
 
 @DOCSTRING(func2str)
 
 @DOCSTRING(str2func)
 
 @node Anonymous Functions
 @subsection Anonymous Functions
diff --git a/doc/interpreter/install.txi b/doc/interpreter/install.txi
--- a/doc/interpreter/install.txi
+++ b/doc/interpreter/install.txi
@@ -59,16 +59,66 @@ steps as described in @ref{Building the 
 @node Build Dependencies
 @section Build Dependencies
 
 Octave is a fairly large program with many build dependencies.  You may
 be able to find pre-packaged versions of the dependencies distributed as
 part of your system, or you may have to build some or all of them
 yourself.
 
+@menu
+* Tips for Specific Systems::
+* Build Tools::
+* External Packages::
+@end menu
+
+@node Tips for Specific Systems
+@subsection Tips for Specific Systems
+
+The names of pre-compiled packages vary by system and do not always
+match exactly the names listed above.
+
+You will usually need the development version of an external dependency
+so that you get the libraries and header files for building software,
+not just for running already compiled programs.  These packages
+typically have names that end with the suffix @code{-dev} or @code{-devel}.
+
+On systems with @code{apt-get} (Debian, Ubuntu, etc.), you may be able
+to install most of the tools and external packages using a command
+similar to
+
+@example
+apt-get build-dep octave
+@end example
+
+@noindent
+The specific package name may be @code{octave3.2} or @code{octave3.4}.
+The set of required tools and external dependencies does not change
+frequently, so it is not important that the version match exactly, but
+you should use the most recent one available.
+
+On systems with @code{yum} (Fedora, Red Hat, etc.), you may be able to
+install most of the tools and external packages using a command similar to
+
+@example
+yum-builddep octave
+@end example
+
+@noindent
+The @code{yum-builddep} utility is part of the @code{yum-utils} package.
+
+For either type of system, the package name may include a version
+number.  The set of required tools and external dependencies does not
+change frequently, so it is not important that the version exactly match
+the version you are installing, but you should use the most recent one
+available.
+
+@node Build Tools
+@subsection Build Tools
+
 The following tools are required:
 
 @table @asis
 @item C++, C, and Fortran compilers
 The Octave sources are primarily written in C++, but some portions are
 also written in C and Fortran.  The Octave sources are intended to be
 portable.  Recent versions of the GNU compiler collection (GCC) should
 work (@url{http://gcc.gnu.org}).  If you use GCC, you should avoid
@@ -113,28 +163,31 @@ you modify Octave's @code{Makefile.am} f
 depend on.
 
 @item Libtool
 Package for building software libraries
 (@url{http://www.gnu.org/software/libtool}).  Libtool is required by
 Automake.
 @end table
 
+@node External Packages
+@subsection External Packages
+
 The following external packages are required:
 
 @table @asis
-@item PCRE
-The Perl Compatible Reular Expression library (http://www.pcre.org).
 @item BLAS
 Basic Linear Algebra Subroutine library
 (@url{http://www.netlib.org/blas}).  Accelerated BLAS libraries such as
 ATLAS (@url{http://math-atlas.sourceforge.net}) are recommeded for
 better performance.
 @item LAPACK
 Linear Algebra Package (@url{http://www.netlib.org/lapack}).
+@item PCRE
+The Perl Compatible Regular Expression library (http://www.pcre.org).
 @end table
 
 The following external package is optional but strongly recommended:
 
 @table @asis
 @item GNU Readline
 Command-line editing library (@url{www.gnu.org/s/readline}).
 @end table
@@ -147,17 +200,17 @@ The following external software packages
 @table @asis
 @item ARPACK
 Library for the solution of large-scale eigenvalue problems
 (@url{http://forge.scilab.org/index.php/p/arpack-ng}).  ARPACK is
 required to provide the functions @code{eigs} and @code{svds}.
 
 @item cURL
 Library for transferring data with URL syntax
-(@url{http://curl.haxx.se}). cURL is required to provide the
+(@url{http://curl.haxx.se}).  cURL is required to provide the
 @code{urlread} and @code{urlwrite} functions and the @code{ftp} class.
 
 @item FFTW3
 Library for computing discrete Fourier transforms
 (@url{http://www.fftw.org}).  FFTW3 is used to provide better
 performance for functions that compute discrete Fourier transforms
 (@code{fft}, @code{ifft}, @code{fft2}, etc.)
 
@@ -167,17 +220,17 @@ used to provide windows for Octave's Ope
 
 @item fontconfig
 Library for configuring and customizing font access
 (@url{http://www.freedesktop.org/wiki/Software/fontconfig}).  Fontconfig
 is used to manage fonts for Octave's OpenGL-based graphics functions.
 
 @item FreeType
 Portable font engine (@url{http://www.freetype.org}).  FreeType is used
-to peform font rendering Octave's OpenGL-based graphics functions.
+to perform font rendering for Octave's OpenGL-based graphics functions.
 
 @item GLPK
 GNU Linear Programming Kit (@url{http://www.gnu.org/software/glpk}).
 GPLK is required for the function @code{glpk}.
 
 @item gnuplot
 Interactive graphics program (@url{http://www.gnuplot.info}).  gnuplot
 is currently the default graphics renderer for Octave.
@@ -185,17 +238,17 @@ is currently the default graphics render
 @item GraphicsMagick++
 Image processing library (@url{http://www.graphicsmagick.org}).
 GraphicsMagick++ is used to provide the @code{imread} and @code{imwrite}
 functions.
 
 @item HDF5
 Library for manipulating portable data files
 (@url{http://www.hdfgroup.org/HDF5}).  HDF5 is required for Octave's
-@code{save} and @code{load} commands to write and read HDF data files.
+@code{load} and @code{save} commands to read and write HDF data files.
 
 @item OpenGL
 API for portable 2D and 3D graphics (@url{http://www.opengl.org}).  An
 OpenGL implementation is required to provide Octave's OpenGL-based
 graphics functions.  Octave's OpenGL-based graphics functions usually
 outperform the gnuplot-based graphics functions because plot data can be
 rendered directly instead of sending data and commands to gnuplot for
 interpretation and rendering.
diff --git a/doc/interpreter/octave.texi b/doc/interpreter/octave.texi
--- a/doc/interpreter/octave.texi
+++ b/doc/interpreter/octave.texi
@@ -381,17 +381,17 @@ Expressions
 * Comparison Ops::              
 * Boolean Expressions::         
 * Assignment Ops::              
 * Increment Ops::               
 * Operator Precedence::         
 
 Index Expressions
 
-* Advanced Indexing::           
+* Advanced Indexing::
 
 Calling Functions
 
 * Call by Value::               
 * Recursion::                   
 
 Boolean Expressions
 
@@ -472,28 +472,29 @@ Handling Warnings
 
 Debugging
 
 * Entering Debug Mode::
 * Leaving Debug Mode::
 * Breakpoints::
 * Debug Mode::
 * Call Stack::
+* Profiling::
+* Profiler Example::
 
 Input and Output
 
 * Basic Input and Output::      
 * C-Style I/O Functions::       
 
 Basic Input and Output
 
 * Terminal Output::             
 * Terminal Input::              
 * Simple File I/O::             
-* Rational Approximations::
 
 Terminal Output
 
 * Paging Screen Output::
 
 Simple File I/O
 
 * Saving Data on Unexpected Exits::
@@ -541,17 +542,17 @@ High-Level Plotting
 Two-Dimensional Plots
 
 * Axis Configuration::  
 * Two-dimensional Function Plotting::  
 * Two-dimensional Geometric Shapes::  
 
 Three-Dimensional Plots
 
-* Aspect Ratio::  
+* Aspect Ratio::
 * Three-dimensional Function Plotting::  
 * Three-dimensional Geometric Shapes::  
 
 Graphics Data Structures
 
 * Introduction to Graphics Structures::  
 * Graphics Objects::            
 * Graphics Object Properties::  
@@ -570,17 +571,17 @@ Graphics Object Properties
 * Surface Properties::          
 
 Advanced Plotting
 
 * Colors::                      
 * Line Styles::                 
 * Marker Styles::               
 * Callbacks::                   
-* Application-defined Data
+* Application-defined Data::
 * Object Groups::               
 * Graphics Toolkits::           
 
 Object Groups
 
 * Data Sources in Object Groups::  
 * Area Series::                 
 * Bar Series::                  
@@ -590,17 +591,17 @@ Object Groups
 * Quiver Group::                
 * Scatter Group::               
 * Stair Group::                 
 * Stem Series::                 
 * Surface Group::               
 
 Graphics Toolkits
 
-* Customizing Toolkit Behavior::
+* Customizing Toolkit Behavior::    
 
 Matrix Manipulation
 
 * Finding Elements and Checking Conditions::  
 * Rearranging Matrices::        
 * Special Utility Matrices::    
 * Famous Matrices::             
 
@@ -621,27 +622,27 @@ Linear Algebra
 * Techniques Used for Linear Algebra::
 * Basic Matrix Functions::      
 * Matrix Factorizations::       
 * Functions of a Matrix::       
 * Specialized Solvers::
 
 Vectorization and Faster Code Execution
 
-* Basic Vectorization::
-* Broadcasting::
-* Function Application::
-* Accumulation::
-* Miscellaneous Techniques::
+* Basic Vectorization::        Basic techniques for code optimization
+* Broadcasting::               Broadcasting operations
+* Function Application::       Applying functions to arrays, cells, and structs
+* Accumulation::               Accumulation functions
+* Miscellaneous Techniques::   Other techniques for speeding up code
 * Examples::
 
 Nonlinear Equations
 
 * Solvers::
-* Minimizers::
+* Minimizers::          
 
 Diagonal and Permutation Matrices
 
 * Basic Usage::          Creation and Manipulation of Diagonal and Permutation Matrices
 * Matrix Algebra::       Linear Algebra with Diagonal and Permutation Matrices
 * Function Support::     Functions That Are Aware of These Matrices
 * Example Codes::        Some Examples of Usage
 * Zeros Treatment::      The Differences in Treatment of Zero Elements
@@ -700,17 +701,17 @@ Optimization
 * Nonlinear Programming::       
 * Linear Least Squares::        
 
 Statistics
 
 * Descriptive Statistics::
 * Basic Statistical Functions:: 
 * Statistical Plots:: 
-* Correlation and Regression Analysis::
+* Correlation and Regression Analysis::                      
 * Distributions::     
 * Tests::                       
 * Random Number Generation::          
 
 Sets
 
 * Set Operations::
 
@@ -767,17 +768,17 @@ Overloading Objects
 * Operator Overloading::
 * Precedence of Objects::
 
 GUI Development
 
 * I/O Dialogs::       
 * Progress Bar::       
 * GUI Utility Functions::       
-* User-Defined Preferences::
+* User-Defined Preferences::       
 
 System Utilities
 
 * Timing Utilities::            
 * Filesystem Utilities::        
 * File Archiving Utilities::
 * Networking Utilities::
 * Controlling Subprocesses::    
@@ -871,26 +872,32 @@ Trouble
 
 * Actual Bugs::                 Bugs we will fix later.
 * Reporting Bugs::              
 * Service::                     
 
 Reporting Bugs
 
 * Bug Criteria::                
-* Bug Tracker::                 Where to submit your bug report.
-* Bug Reporting::               How to report a bug effectively.
-* Sending Patches::             How to send a patch for Octave.
+* Bug Tracker::        Where to submit your bug report.
+* Bug Reporting::      How to report a bug effectively.
+* Sending Patches::    How to send a patch for Octave.
 
 Installation
 
 * Build Dependencies::
 * Running Configure and Make::
-* Compiling Octave with 64-bit Indexing::       
-* Installation Problems::       
+* Compiling Octave with 64-bit Indexing::
+* Installation Problems::
+
+Build Dependencies
+
+* Tips for Specific Systems::
+* Build Tools::
+* External Packages::
 
 Emacs Octave Support
 
 * Installing EOS::              
 * Using Octave Mode::           
 * Running Octave from Within Emacs::  
 * Using the Emacs Info Reader for Octave::  
 
diff --git a/doc/interpreter/preface.txi b/doc/interpreter/preface.txi
--- a/doc/interpreter/preface.txi
+++ b/doc/interpreter/preface.txi
@@ -27,39 +27,39 @@ undergraduate-level textbook on chemical
 James B. Rawlings of the University of Wisconsin-Madison and John
 G. Ekerdt of the University of Texas.
 
 Clearly, Octave is now much more than just another `courseware' package
 with limited utility beyond the classroom.  Although our initial goals
 were somewhat vague, we knew that we wanted to create something that
 would enable students to solve realistic problems, and that they could
 use for many things other than chemical reactor design problems.
-
-There are those who would say that we should be teaching the students
-Fortran instead, because that is the computer language of engineering,
-but every time we have tried that, the students have spent far too much
-time trying to figure out why their Fortran code crashes and not enough
-time learning about chemical engineering.  With Octave, most students
-pick up the basics quickly, and are using it confidently in just a few
-hours.
+We find that most students pick up the basics of Octave quickly, and are
+using it confidently in just a few hours.
 
 Although it was originally intended to be used to teach reactor design,
 it has been used in several other undergraduate and graduate
 courses in the Chemical Engineering Department at the University of
 Texas, and the math department at the University of Texas has been using
-it for teaching differential equations and linear algebra as well.  If
-you find it useful, please let us know.  We are always interested to
-find out how Octave is being used in other places.
+it for teaching differential equations and linear algebra as well.
+More recently, Octave has been used as the primary computational tool
+for teaching Stanford's online Machine Learning class
+(@url{ml-class.org}) taught by Andrew Ng.  Tens of thousands of students
+participated in the course.
+
+If you find Octave useful, please let us know.  We are always interested
+to find out how Octave is being used.
 
 Virtually everyone thinks that the name Octave has something to do with
-music, but it is actually the name of a former professor of mine who
-wrote a famous textbook on chemical reaction engineering, and who was
-also well known for his ability to do quick `back of the envelope'
-calculations.  We hope that this software will make it possible for many
-people to do more ambitious computations just as easily.
+music, but it is actually the name of one of John W. Eaton's former
+professors who wrote a famous textbook on chemical reaction engineering,
+and who was also well known for his ability to do quick `back of the
+envelope' calculations.  We hope that this software will make it
+possible for many people to do more ambitious computations just as
+easily.
 
 Everyone is encouraged to share this software with others under the
 terms of the GNU General Public License (@pxref{Copying}).  You are 
 also encouraged to help make Octave more useful by writing and 
 contributing additional functions for it, and by reporting any problems
 you may have.
 
 @menu
@@ -157,16 +157,34 @@ high-quality code for solving new proble
 available for others to use.  @xref{Contributing Guidelines}, for detailed 
 information on contributing new code.
 
 If you find Octave useful, consider providing additional funding to
 continue its development.  Even a modest amount of additional funding
 could make a significant difference in the amount of time that is
 available for development and support.
 
+Donations supporting Octave development may be made on the web at
+@url{https://my.fsf.org/donate/working-together/octave}.  These
+donations also help to support the Free Software Foundation
+
+If you'd prefer to pay by check or money order, you can do so by sending
+a check to the FSF at the following address:
+
+@quotation
+Free Software Foundation@*
+51 Franklin Street, Suite 500@*
+Boston, MA 02110-1335@*
+USA
+@end quotation
+
+@noindent
+If you pay by check, please be sure to write ``GNU Octave'' in the memo
+field of your check.
+
 If you cannot provide funding or contribute code, you can still help
 make Octave better and more reliable by reporting any bugs you find and
 by offering suggestions for ways to improve Octave.  @xref{Trouble}, for
 tips on how to write useful bug reports.
 
 @node Distribution
 @unnumberedsec Distribution
 @cindex distribution of Octave
@@ -175,23 +193,12 @@ Octave is @dfn{free} software.  This mea
 use it and free to redistribute it on certain conditions.  Octave 
 is not, however, in the public domain.  It is copyrighted and there are
 restrictions on its distribution, but the restrictions are designed to 
 ensure that others will have the same freedom to use and redistribute 
 Octave that you have.  The precise conditions can be found in the 
 GNU General Public License that comes with Octave and that also appears 
 in @ref{Copying}.
 
-Octave is available on CD-ROM, with various collections of other free
-software, from the Free Software Foundation.  Ordering a copy of
-Octave from the Free Software Foundation helps to fund the development
-of more free software.  For more information, write to
+To download a copy of Octave, please visit
+@url{http://www.octave.org/download.html}.
 
-@quotation
-Free Software Foundation@*
-51 Franklin Street, Fifth Floor@*
-Boston, MA 02110-1301--1307@*
-USA
-@end quotation
-
-Octave can also be downloaded from @url{http://www.octave.org}, where
-additional information is available.
 @end ifclear
diff --git a/libcruft/Makefile.am b/libcruft/Makefile.am
--- a/libcruft/Makefile.am
+++ b/libcruft/Makefile.am
@@ -38,17 +38,17 @@ include link-deps.mk
 
 libcruft_la_LIBADD = \
   libranlib.la \
   ../libgnu/libgnu.la \
   $(LIBCRUFT_LINK_DEPS)
 
 # Increment these as needed and according to the rules in the libtool
 # manual:
-libcruft_current = 0
+libcruft_current = 1
 libcruft_revision = 0
 libcruft_age = 0
 
 libcruft_version_info = $(libcruft_current):$(libcruft_revision):$(libcruft_age)
 
 libcruft_la_LDFLAGS = \
   -version-info $(libcruft_version_info) \
   $(NO_UNDEFINED_LDFLAG) \
diff --git a/liboctave/Makefile.am b/liboctave/Makefile.am
--- a/liboctave/Makefile.am
+++ b/liboctave/Makefile.am
@@ -515,17 +515,17 @@ liboctave_la_CPPFLAGS = \
   @OCTAVE_DLL_DEFS@ \
   $(SPARSE_XCPPFLAGS) \
   $(FFTW_XCPPFLAGS) \
   $(ARPACK_CPPFLAGS) \
   $(AM_CPPFLAGS)
 
 # Increment these as needed and according to the rules in the libtool
 # manual:
-liboctave_current = 0
+liboctave_current = 1
 liboctave_revision = 0
 liboctave_age = 0
 
 liboctave_version_info = $(liboctave_current):$(liboctave_revision):$(liboctave_age)
 
 liboctave_la_LDFLAGS = \
   -version-info $(liboctave_version_info) \
   $(NO_UNDEFINED_LDFLAG) \
diff --git a/liboctave/lo-specfun.cc b/liboctave/lo-specfun.cc
--- a/liboctave/lo-specfun.cc
+++ b/liboctave/lo-specfun.cc
@@ -847,16 +847,23 @@ zbesi (const Complex& z, double alpha, i
           yi *= expz;
         }
 
       if (zi == 0.0 && zr >= 0.0)
         yi = 0.0;
 
       retval = bessel_return_value (Complex (yr, yi), ierr);
     }
+  else if (is_integer_value (alpha))
+    {
+      // zbesi can overflow as z->0, and cause troubles for generic case below
+      alpha = -alpha;
+      Complex tmp = zbesi (z, alpha, kode, ierr);
+      retval = bessel_return_value (tmp, ierr);
+    }
   else
     {
       alpha = -alpha;
 
       Complex tmp = zbesi (z, alpha, kode, ierr);
 
       if (ierr == 0 || ierr == 3)
         {
diff --git a/liboctave/oct-inttypes.h b/liboctave/oct-inttypes.h
--- a/liboctave/oct-inttypes.h
+++ b/liboctave/oct-inttypes.h
@@ -361,18 +361,18 @@ public:
 
   // Multiplication is done using promotion to wider integer type. If there is
   // no suitable promotion type, this operation *MUST* be specialized.
   static T
   mul (T x, T y)
     {
       // Promotion type for multiplication (if exists).
       typedef typename query_integer_type<2*sizeof (T), false>::type mptype;
-      return truncate_int (static_cast<mptype> (x)
-                           * static_cast<mptype> (y));
+      return octave_int_base<T>::truncate_int (static_cast<mptype> (x)
+                                               * static_cast<mptype> (y));
     }
 
   // Division with rounding to nearest. Note that / and % are probably
   // computed by a single instruction.
   static T
   div (T x, T y)
     {
       if (y != 0)
@@ -616,18 +616,18 @@ public:
 
   // Multiplication is done using promotion to wider integer type. If there is
   // no suitable promotion type, this operation *MUST* be specialized.
   static T
   mul (T x, T y)
     {
       // Promotion type for multiplication (if exists).
       typedef typename query_integer_type<2*sizeof (T), true>::type mptype;
-      return truncate_int (static_cast<mptype> (x)
-                           * static_cast<mptype> (y));
+      return octave_int_base<T>::truncate_int (static_cast<mptype> (x)
+                                               * static_cast<mptype> (y));
     }
 
   // Division.
   static T
   div (T x, T y)
     {
       T z;
       if (y == 0)
diff --git a/scripts/deprecated/module.mk b/scripts/deprecated/module.mk
--- a/scripts/deprecated/module.mk
+++ b/scripts/deprecated/module.mk
@@ -22,18 +22,16 @@ deprecated_FCN_FILES = \
   deprecated/isstr.m \
   deprecated/krylovb.m \
   deprecated/perror.m \
   deprecated/polyderiv.m \
   deprecated/replot.m \
   deprecated/saveimage.m \
   deprecated/setstr.m \
   deprecated/shell_cmd.m \
-  deprecated/sphcat.m \
-  deprecated/spvcat.m \
   deprecated/strerror.m \
   deprecated/studentize.m \
   deprecated/sylvester_matrix.m \
   deprecated/values.m \
   deprecated/weibcdf.m \
   deprecated/weibinv.m \
   deprecated/weibpdf.m \
   deprecated/weibrnd.m
diff --git a/scripts/deprecated/sphcat.m b/scripts/deprecated/sphcat.m
deleted file mode 100644
--- a/scripts/deprecated/sphcat.m
+++ /dev/null
@@ -1,35 +0,0 @@
-## Copyright (C) 2004-2012 David Bateman and Andy Adler
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {@var{y} =} sphcat (@var{a1}, @var{a2}, @dots{}, @var{aN})
-## Return the horizontal concatenation of sparse matrices.  This function
-## is obselete and @code{horzcat} should be used instead.
-## @seealso {horzcat, spvcat, vertcat, cat}
-## @end deftypefn
-
-function y = sphcat (varargin)
-  persistent warned = false;
-  if (! warned)
-    warned = true;
-    warning ("Octave:deprecated-function",
-             "sphcat is obsolete and will be removed from a future version of Octave; please use horzcat instead");
-  endif
-
-  y = horzcat (varargin{:});
-endfunction
diff --git a/scripts/deprecated/spvcat.m b/scripts/deprecated/spvcat.m
deleted file mode 100644
--- a/scripts/deprecated/spvcat.m
+++ /dev/null
@@ -1,35 +0,0 @@
-## Copyright (C) 2004-2012 David Bateman and Andy Adler
-##
-## This file is part of Octave.
-##
-## Octave is free software; you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 3 of the License, or (at
-## your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-## General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <http://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {Function File} {@var{y} =} spvcat (@var{a1}, @var{a2}, @dots{}, @var{aN})
-## Return the vertical concatenation of sparse matrices.  This function
-## is obselete and @code{vertcat} should be used instead.
-## @seealso{vertcat, sphcat, horzcat, cat}
-## @end deftypefn
-
-function y = spvcat (varargin)
-  persistent warned = false;
-  if (! warned)
-    warned = true;
-    warning ("Octave:deprecated-function",
-             "spvcat is obsolete and will be removed from a future version of Octave; please use vertcat instead");
-  endif
-
-  y = vertcat (varargin{:});
-endfunction
diff --git a/scripts/plot/figure.m b/scripts/plot/figure.m
--- a/scripts/plot/figure.m
+++ b/scripts/plot/figure.m
@@ -58,17 +58,26 @@ function h = figure (varargin)
   if (! isempty (cf) && cf != 0)
     if (isnan (f) || cf != f)
       drawnow ();
     endif
   endif
 
   if (rem (nargs, 2) == 0)
     if (isnan (f) || init_new_figure)
-      f = __go_figure__ (f, varargin{:});
+      if (ismac () && strcmp (graphics_toolkit (), "fltk"))
+        ## FIXME - Hack for fltk-aqua to work around bug # 31931
+        f = __go_figure__ (f);
+        drawnow ();
+        if (! isempty (varargin))
+          set (f, varargin{:});
+        endif
+      else
+        f = __go_figure__ (f, varargin{:});
+      endif
     elseif (nargs > 0)
       set (f, varargin{:});
     endif
     set (0, "currentfigure", f);
   else
     print_usage ();
   endif
 
diff --git a/scripts/plot/plot3.m b/scripts/plot/plot3.m
--- a/scripts/plot/plot3.m
+++ b/scripts/plot/plot3.m
@@ -165,16 +165,18 @@ function retval = plot3 (varargin)
           [x, y] = meshgrid (x, y);
         else
           error ("plot3: [length(x), length(y)] must match size(z)");
         endif
       endif
 
       if (! size_equal (x, y, z))
         error ("plot3: x, y, and z must have the same shape");
+      elseif (ndims (x) > 2)
+        error ("plot3: x, y, and z must not have more than two dimensions");
       endif
 
       for i = 1 : columns (x)
         linestyle = options.linestyle;
         marker = options.marker;
         if (isempty (marker) && isempty (linestyle))
            [linestyle, marker] = __next_line_style__ ();
         endif
@@ -217,16 +219,18 @@ function retval = plot3 (varargin)
           [x, y] = meshgrid (x, y);
         else
           error ("plot3: [length(x), length(y)] must match size(z)");
         endif
       endif
 
       if (! size_equal (x, y, z))
         error ("plot3: x, y, and z must have the same shape");
+      elseif (ndims (x) > 2)
+        error ("plot3: x, y, and z must not have more than two dimensions");
       endif
 
       options =  __default_plot_options__ ();
       for i = 1 : columns (x)
         linestyle = options.linestyle;
         marker = options.marker;
         if (isempty (marker) && isempty (linestyle))
            [linestyle, marker] = __next_line_style__ ();
@@ -289,16 +293,18 @@ function retval = plot3 (varargin)
         [x, y] = meshgrid (x, y);
       else
         error ("plot3: [length(x), length(y)] must match size(z)");
       endif
     endif
 
     if (! size_equal (x, y, z))
       error ("plot3: x, y, and z must have the same shape");
+    elseif (ndims (x) > 2)
+      error ("plot3: x, y, and z must not have more than two dimensions");
     endif
 
     options =  __default_plot_options__ ();
 
     for i = 1 : columns (x)
       linestyle = options.linestyle;
       marker = options.marker;
       if (isempty (marker) && isempty (linestyle))
diff --git a/scripts/plot/private/__fltk_print__.m b/scripts/plot/private/__fltk_print__.m
--- a/scripts/plot/private/__fltk_print__.m
+++ b/scripts/plot/private/__fltk_print__.m
@@ -47,25 +47,27 @@ function opts = __fltk_print__ (opts)
   case {"epslatex", "pslatex", "pdflatex", "epslatexstandalone", ...
         "pslatexstandalone", "pdflatexstandalone"}
     ## format GL2PS_TEX
     n = find (opts.devopt == "l", 1);
     suffix = opts.devopt(1:n-1);
     dot = find (opts.name == ".", 1, "last");
     if ((! isempty (dot))
         && any (strcmpi (opts.name(dot:end), ...
-                {".eps", ".ps", ".pdf", ".tex", "."})))
+                {strcat(".", suffix), ".tex", "."})))
       name = opts.name(1:dot-1);
       if (dot < numel (opts.name)
           && any (strcmpi (opts.name(dot+1:end), {"eps", "ps", "pdf"})))
         ## If user provides eps/ps/pdf suffix, use it.
         suffix = opts.name(dot+1:end);
       endif
-    elseif (dot == numel (opts.name))
-      name = opts.name;
+    else
+      error ("print:invalid-suffix", 
+             "invalid suffix `%s' for device `%s'.",
+             opts.name(dot:end), lower (opts.devopt));
     endif
     gl2ps_device = {sprintf("%snotxt", lower (suffix))};
     gl2ps_device{2} = "tex";
     if (dos_shell)
       ## FIXME - this will only work on MinGW with the MSYS shell
       pipeline = {sprintf("cat > %s-inc.%s", name, suffix)};
       pipeline{2} = sprintf ("cat > %s.tex", name);
     else
diff --git a/scripts/plot/private/__gnuplot_print__.m b/scripts/plot/private/__gnuplot_print__.m
--- a/scripts/plot/private/__gnuplot_print__.m
+++ b/scripts/plot/private/__gnuplot_print__.m
@@ -64,20 +64,26 @@ function opts = __gnuplot_print__ (opts)
       pipeline = {sprintf("%s %s",
                           opts.epstool_cmd (opts, tmp_file, opts.name),
                           cleanup)};
     else
       eps_drawnow (opts, opts.name, gp_opts);
     endif
   case {"epslatex", "pslatex", "pstex", "epslatexstandalone"}
     dot = find (opts.name == ".", 1, "last");
-    if ((! isempty (dot))
-        && any (strcmpi (opts.name(dot:end),
-                {".eps", ".ps", ".pdf", ".tex", "."})))
-      name = opts.name(1:dot-1);
+    n = find (opts.devopt == "l", 1);
+    suffix = opts.devopt(1:n-1);
+    if (! isempty (dot))
+      if (any (strcmpi (opts.name(dot:end), {strcat(".", suffix), ".tex", "."})))
+        name = opts.name(1:dot-1);
+      else
+        error ("print:invalid-suffix", 
+               "invalid suffix `%s' for device `%s'.",
+               opts.name(dot:end), lower (opts.devopt));
+      endif
     endif
     if (strfind (opts.devopt, "standalone"))
       term = sprintf ("%s ",
                       strrep (opts.devopt, "standalone", " standalone"));
     else
       term = sprintf ("%s ", opts.devopt);
     endif
     if (__gnuplot_has_feature__ ("epslatex_implies_eps_filesuffix"))
diff --git a/scripts/plot/xlim.m b/scripts/plot/xlim.m
--- a/scripts/plot/xlim.m
+++ b/scripts/plot/xlim.m
@@ -12,16 +12,20 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
+## @c List other forms of function in documentation index
+## @findex ylim
+## @findex zlim
+##
 ## @deftypefn  {Function File} {@var{xl} =} xlim ()
 ## @deftypefnx {Function File} {} xlim (@var{xl})
 ## @deftypefnx {Function File} {@var{m} =} xlim ('mode')
 ## @deftypefnx {Function File} {} xlim (@var{m})
 ## @deftypefnx {Function File} {} xlim (@var{h}, @dots{})
 ## Get or set the limits of the x-axis of the current plot.  Called without
 ## arguments @code{xlim} returns the x-axis limits of the current plot.
 ## If passed a two element vector @var{xl}, the limits of the x-axis are set
diff --git a/scripts/sparse/svds.m b/scripts/sparse/svds.m
--- a/scripts/sparse/svds.m
+++ b/scripts/sparse/svds.m
@@ -259,23 +259,23 @@ endfunction
 %!                         % to guarantee reproducible results
 %!
 %!testif HAVE_ARPACK
 %! [u2,s2,v2,flag] = svds (A,k);
 %! s2 = diag (s2);
 %! assert (flag, !1);
 %! assert (s2, s(end:-1:end-k+1), 1e-10);
 %!
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! [u2,s2,v2,flag] = svds (A,k,0,opts);
 %! s2 = diag (s2);
 %! assert (flag, !1);
 %! assert (s2, s(k:-1:1), 1e-10);
 %!
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! idx = floor(n/2);
 %! % Don't put sigma right on a singular value or there are convergence issues
 %! sigma = 0.99*s(idx) + 0.01*s(idx+1);
 %! [u2,s2,v2,flag] = svds (A,k,sigma,opts);
 %! s2 = diag (s2);
 %! assert (flag, !1);
 %! assert (s2, s((idx+floor(k/2)):-1:(idx-floor(k/2))), 1e-10);
 %!
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -451,18 +451,22 @@ function [__ret1, __ret2, __ret3, __ret4
         clear __test__;
       endif
       ## Code already processed.
       __code = "";
 
 ### TESTIF
 
     elseif (strcmp (__type, "testif"))
-      [__e, __feat] = regexp (__code, '^\s*(\S+)', 'end', 'tokens');
-      if (isempty (findstr (octave_config_info ("DEFS"), __feat{1}{1})))
+      __e = regexp (__code, '.$', 'lineanchors', 'once');
+      ## Strip comment any comment from testif line before looking for features
+      __feat_line = strtok (__code(1:__e), '#%'); 
+      __feat = regexp (__feat_line, '\w+', 'match');
+      __have_feat = strfind (octave_config_info ("DEFS"), __feat); 
+      if (any (cellfun ("isempty", __have_feat)))
         __xskip++;
         __istest = 0;
         __code = ""; # Skip the code.
         __msg = sprintf ("%sskipped test\n", __signal_skip);
       else
         __istest = 1;
         __code = __code(__e + 1 : end);
       endif
diff --git a/src/DLD-FUNCTIONS/__magick_read__.cc b/src/DLD-FUNCTIONS/__magick_read__.cc
--- a/src/DLD-FUNCTIONS/__magick_read__.cc
+++ b/src/DLD-FUNCTIONS/__magick_read__.cc
@@ -207,17 +207,18 @@ read_images (const std::vector<Magick::I
   dim_vector idim = dim_vector ();
   idim.resize (4);
   idim(0) = rows;
   idim(1) = columns;
   idim(2) = 1;
   idim(3) = nframes;
 
   Magick::ImageType type = imvec[0].type ();
-  const int divisor = (((1 << QuantumDepth) - 1) / ((1 << depth) - 1));
+  const int divisor = ((uint64_t (1) << QuantumDepth) - 1) / 
+                      ((uint64_t (1) << depth) - 1);
 
   switch (type)
     {
     case Magick::BilevelType:
     case Magick::GrayscaleType:
       {
         im = T (idim);
         P *vec = im.fortran_vec ();
diff --git a/src/DLD-FUNCTIONS/eigs.cc b/src/DLD-FUNCTIONS/eigs.cc
--- a/src/DLD-FUNCTIONS/eigs.cc
+++ b/src/DLD-FUNCTIONS/eigs.cc
@@ -784,90 +784,90 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
 %! d1 = eigs (A, k);
 %! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
 %!testif HAVE_ARPACK
 %! d1 = eigs (A,k+1);
 %! assert (d1, d0(end:-1:(end-k)),1e-11);
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'lm');
 %! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! d1 = eigs (A, k, 'sm');
 %! assert (d1, d0(k:-1:1), 1e-11);
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'la');
 %! assert (d1, d2(end:-1:(end-k+1)), 1e-11);
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'sa');
 %! assert (d1, d2(1:k), 1e-11);
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'be');
 %! assert (d1, d2([1:floor(k/2), (end - ceil(k/2) + 1):end]), 1e-11);
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k+1, 'be');
 %! assert (d1, d2([1:floor((k+1)/2), (end - ceil((k+1)/2) + 1):end]), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! d1 = eigs (A, k, 4.1);
 %! [~,idx0] = sort (abs(d0 - 4.1));
 %! [~,idx1] = sort (abs(d1 - 4.1));
 %! assert (d1(idx1), d0(idx0(1:k)), 1e-11);
-%!testif HAVE_CHOLMOD
+%!testif HAVE_ARPACK, HAVE_CHOLMOD
 %! d1 = eigs(A, speye(n), k, 'lm');
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! assert (eigs(A,k,4.1), eigs(A,speye(n),k,4.1), 1e-11);
 %!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! d1 = eigs(A, speye(n), k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! q = [2:n,1];
 %! opts.permB=q;
 %! d1 = eigs(A, speye(n)(q,q), k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! opts.cholB=true;
 %! d1 = eigs(A, speye(n), k, 4.1, opts);
 %! assert (abs(d1), eigs(A,k,4.1), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! opts.cholB=true;
 %! q = [2:n,1];
 %! opts.permB=q;
 %! d1 = eigs(A, speye(n)(q,q), k, 4.1, opts);
 %! assert (abs(d1), eigs(A,k,4.1), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! assert (eigs(A,k,4.1), eigs(A,speye(n),k,4.1), 1e-11);
 %!testif HAVE_ARPACK
 %! fn = @(x) A * x;
 %! opts.issym = 1; opts.isreal = 1;
 %! d1 = eigs (fn, n, k, 'lm', opts);
 %! assert (d1, d0(end:-1:(end-k+1)), 1e-11);
 %!testif HAVE_ARPACK
 %! fn = @(x) A \ x;
 %! opts.issym = 1; opts.isreal = 1;
 %! d1 = eigs (fn, n, k, 'sm', opts);
 %! assert (d1, d0(k:-1:1), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! fn = @(x) (A - 4.1 * eye(n)) \ x;
 %! opts.issym = 1; opts.isreal = 1;
 %! d1 = eigs (fn, n, k, 4.1, opts);
 %! assert (d1, eigs(A,k,4.1), 1e-11);
 %!testif HAVE_ARPACK
 %! AA = speye (10);
 %! fn = @(x) AA * x;
 %! opts.issym = 1; opts.isreal = 1;
 %! assert (eigs (fn, 10, AA, 3, 'lm', opts), [1; 1; 1],10*eps);
 %!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'lm');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! [v1,d1] = eigs(A, k, 'sm');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
 %!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'la');
 %! d1 = diag(d1);
@@ -904,17 +904,17 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
 %! d1 = eigs (A, k);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
 %! d1 = eigs (A,k+1);
 %! assert (abs(d1), abs(d0(end:-1:(end-k))),1e-11);
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'lm');
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! d1 = eigs (A, k, 'sm');
 %! assert (abs(d1), abs(d0(1:k)), 1e-11);
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'lr');
 %! [~, idx] = sort (real(d0));
 %! d2 = d0(idx);
 %! assert (real(d1), real(d2(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
@@ -927,71 +927,71 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
 %! [~, idx] = sort (imag(abs(d0)));
 %! d2 = d0(idx);
 %! assert (sort(imag(d1)), sort(imag(d2(end:-1:(end-k+1)))), 1e-11);
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'si');
 %! [~, idx] = sort (imag(abs(d0)));
 %! d2 = d0(idx);
 %! assert (sort(imag(d1)), sort(imag(d2(1:k))), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! d1 = eigs (A, k, 4.1);
 %! [~,idx0] = sort (abs(d0 - 4.1));
 %! [~,idx1] = sort (abs(d1 - 4.1));
 %! assert (abs(d1(idx1)), abs(d0(idx0(1:k))), 1e-11);
 %! assert (sort(imag(d1(idx1))), sort(imag(d0(idx0(1:k)))), 1e-11);
-%!testif HAVE_CHOLMOD
+%!testif HAVE_ARPACK, HAVE_CHOLMOD
 %! d1 = eigs(A, speye(n), k, 'lm');
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! d1 = eigs(A, speye(n), k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! q = [2:n,1];
 %! opts.permB=q;
 %! d1 = eigs(A, speye(n)(q,q), k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! opts.cholB=true;
 %! d1 = eigs(A, speye(n), k, 4.1, opts);
 %! assert (abs(d1), eigs(A,k,4.1), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! opts.cholB=true;
 %! q = [2:n,1];
 %! opts.permB=q;
 %! d1 = eigs(A, speye(n)(q,q), k, 4.1, opts);
 %! assert (abs(d1), eigs(A,k,4.1), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! assert (abs(eigs(A,k,4.1)), abs(eigs(A,speye(n),k,4.1)), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! assert (sort(imag(eigs(A,k,4.1))), sort(imag(eigs(A,speye(n),k,4.1))), 1e-11);
 %!testif HAVE_ARPACK
 %! fn = @(x) A * x;
 %! opts.issym = 0; opts.isreal = 1;
 %! d1 = eigs (fn, n, k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
 %! fn = @(x) A \ x;
 %! opts.issym = 0; opts.isreal = 1;
 %! d1 = eigs (fn, n, k, 'sm', opts);
 %! assert (abs(d1), d0(1:k), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! fn = @(x) (A - 4.1 * eye(n)) \ x;
 %! opts.issym = 0; opts.isreal = 1;
 %! d1 = eigs (fn, n, k, 4.1, opts);
 %! assert (abs(d1), eigs(A,k,4.1), 1e-11);
 %!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'lm');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! [v1,d1] = eigs(A, k, 'sm');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
 %!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'lr');
 %! d1 = diag(d1);
@@ -1034,17 +1034,17 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
 %! d1 = eigs (A, k);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
 %! d1 = eigs (A,k+1);
 %! assert (abs(d1), abs(d0(end:-1:(end-k))),1e-11);
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'lm');
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! d1 = eigs (A, k, 'sm');
 %! assert (abs(d1), abs(d0(1:k)), 1e-11);
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'lr');
 %! [~, idx] = sort (real(abs(d0)));
 %! d2 = d0(idx);
 %! assert (real(d1), real(d2(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
@@ -1057,73 +1057,73 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
 %! [~, idx] = sort (imag(abs(d0)));
 %! d2 = d0(idx);
 %! assert (sort(imag(d1)), sort(imag(d2(end:-1:(end-k+1)))), 1e-11);
 %!testif HAVE_ARPACK
 %! d1 = eigs (A, k, 'si');
 %! [~, idx] = sort (imag(abs(d0)));
 %! d2 = d0(idx);
 %! assert (sort(imag(d1)), sort(imag(d2(1:k))), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! d1 = eigs (A, k, 4.1);
 %! [~,idx0] = sort (abs(d0 - 4.1));
 %! [~,idx1] = sort (abs(d1 - 4.1));
 %! assert (abs(d1(idx1)), abs(d0(idx0(1:k))), 1e-11);
 %! assert (sort(imag(d1(idx1))), sort(imag(d0(idx0(1:k)))), 1e-11);
-%!testif HAVE_CHOLMOD
+%!testif HAVE_ARPACK, HAVE_CHOLMOD
 %! d1 = eigs(A, speye(n), k, 'lm');
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! d1 = eigs(A, speye(n), k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
 %! opts.cholB=true;
 %! q = [2:n,1];
 %! opts.permB=q;
 %! d1 = eigs(A, speye(n)(q,q), k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! opts.cholB=true;
 %! d1 = eigs(A, speye(n), k, 4.1, opts);
 %! assert (abs(abs(d1)), abs(eigs(A,k,4.1)), 1e-11);
 %! assert (sort(imag(abs(d1))), sort(imag(eigs(A,k,4.1))), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! opts.cholB=true;
 %! q = [2:n,1];
 %! opts.permB=q;
 %! d1 = eigs(A, speye(n)(q,q), k, 4.1, opts);
 %! assert (abs(abs(d1)), abs(eigs(A,k,4.1)), 1e-11);
 %! assert (sort(imag(abs(d1))), sort(imag(eigs(A,k,4.1))), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! assert (abs(eigs(A,k,4.1)), abs(eigs(A,speye(n),k,4.1)), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! assert (sort(imag(eigs(A,k,4.1))), sort(imag(eigs(A,speye(n),k,4.1))), 1e-11);
 %!testif HAVE_ARPACK
 %! fn = @(x) A * x;
 %! opts.issym = 0; opts.isreal = 0;
 %! d1 = eigs (fn, n, k, 'lm', opts);
 %! assert (abs(d1), abs(d0(end:-1:(end-k+1))), 1e-11);
 %!testif HAVE_ARPACK
 %! fn = @(x) A \ x;
 %! opts.issym = 0; opts.isreal = 0;
 %! d1 = eigs (fn, n, k, 'sm', opts);
 %! assert (abs(d1), d0(1:k), 1e-11);
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! fn = @(x) (A - 4.1 * eye(n)) \ x;
 %! opts.issym = 0; opts.isreal = 0;
 %! d1 = eigs (fn, n, k, 4.1, opts);
 %! assert (abs(d1), eigs(A,k,4.1), 1e-11);
 %!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'lm');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
-%!testif HAVE_UMFPACK
+%!testif HAVE_ARPACK, HAVE_UMFPACK
 %! [v1,d1] = eigs(A, k, 'sm');
 %! d1 = diag(d1);
 %! for i=1:k
 %!  assert(max(abs((A - d1(i)*speye(n))*v1(:,i))),0.,1e-11)
 %! endfor
 %!testif HAVE_ARPACK
 %! [v1,d1] = eigs(A, k, 'lr');
 %! d1 = diag(d1);
diff --git a/src/DLD-FUNCTIONS/module-files b/src/DLD-FUNCTIONS/module-files
--- a/src/DLD-FUNCTIONS/module-files
+++ b/src/DLD-FUNCTIONS/module-files
@@ -27,17 +27,17 @@ convhulln.cc|$(QHULL_CPPFLAGS)|$(QHULL_L
 daspk.cc
 dasrt.cc
 dassl.cc
 det.cc
 dlmread.cc
 dmperm.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
 dot.cc
 eig.cc
-eigs.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS) $(LAPACK_LIBS) $(BLAS_LIBS)
+eigs.cc|$(ARPACK_CPPFLAGS) $(SPARSE_XCPPFLAGS)|$(ARPACK_LDFLAGS) $(SPARSE_XLDFLAGS)|$(ARPACK_LIBS) $(SPARSE_XLIBS) $(LAPACK_LIBS) $(BLAS_LIBS)
 fft.cc|$(FFTW_XCPPFLAGS)|$(FFTW_XLDFLAGS)|$(FFTW_XLIBS)
 fft2.cc|$(FFTW_XCPPFLAGS)|$(FFTW_XLDFLAGS)|$(FFTW_XLIBS)
 fftn.cc|$(FFTW_XCPPFLAGS)|$(FFTW_XLDFLAGS)|$(FFTW_XLIBS)
 fftw.cc|$(FFTW_XCPPFLAGS)|$(FFTW_XLDFLAGS)|$(FFTW_XLIBS)
 filter.cc
 find.cc
 gammainc.cc
 gcd.cc
diff --git a/src/DLD-FUNCTIONS/pinv.cc b/src/DLD-FUNCTIONS/pinv.cc
--- a/src/DLD-FUNCTIONS/pinv.cc
+++ b/src/DLD-FUNCTIONS/pinv.cc
@@ -169,23 +169,24 @@ where @code{sigma_max (@var{x})} is the 
 
   return retval;
 }
 
 /*
 %!shared a, b, tol, hitol, d, u, x, y
 %! a = reshape (rand*[1:16], 4, 4);   ## Rank 2 matrix
 %! b = pinv (a);
-%! tol = 1e-14;
-%! hitol = 15*sqrt(eps);
+%! tol = 4e-14;
+%! hitol = 40*sqrt (eps);
 %! d = diag ([rand, rand, hitol, hitol]);
 %! u = rand (4);                      ## Could be singular by freak accident
 %! x = inv (u)*d*u;
-%! y = pinv (x, sqrt(eps));
-%!assert(a*b*a, a, tol);
-%!assert(b*a*b, b, tol);
-%!assert((b*a)', b*a, tol);
-%!assert((a*b)', a*b, tol);
-%!assert(x*y*x, x, -hitol);
-%!assert(y*x*y, y, -hitol);
-%!assert((x*y)', x*y, hitol);
-%!assert((y*x)', y*x, hitol);
+%! y = pinv (x, sqrt (eps));
+%!
+%!assert (a*b*a, a, tol)
+%!assert (b*a*b, b, tol)
+%!assert ((b*a)', b*a, tol)
+%!assert ((a*b)', a*b, tol)
+%!assert (x*y*x, x, -hitol)
+%!assert (y*x*y, y, -hitol)
+%!assert ((x*y)', x*y, hitol)
+%!assert ((y*x)', y*x, hitol)
 */
diff --git a/src/Makefile.am b/src/Makefile.am
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -510,17 +510,17 @@ liboctinterp_la_CPPFLAGS = @OCTINTERP_DL
 include link-deps.mk
 
 liboctinterp_la_LIBADD = \
   ../liboctave/liboctave.la \
   ../libcruft/libcruft.la \
   $(LIBOCTINTERP_LINK_DEPS)
 
 # Increment these as needed and according to the rules in the libtool manual:
-liboctinterp_current = 0
+liboctinterp_current = 1
 liboctinterp_revision = 0
 liboctinterp_age = 0
 
 liboctinterp_version_info = $(liboctinterp_current):$(liboctinterp_revision):$(liboctinterp_age)
 
 liboctinterp_la_LDFLAGS = \
   -version-info $(liboctinterp_version_info) \
   $(NO_UNDEFINED_LDFLAG) \
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -3922,16 +3922,19 @@ val = zeros (m,n, \"uint8\")\n\
 %!assert(zeros (2, 3,'int8'), int8([0, 0, 0; 0, 0, 0]));
 %!assert(zeros (3, 2,'int8'), int8([0, 0; 0, 0; 0, 0]));
 %!assert(size (zeros (3, 4, 5, 'int8')),  [3, 4, 5]);
 
  */
 
 DEFUN (Inf, args, ,
   "-*- texinfo -*-\n\
+@c List other form of function in documentation index\n\
+@findex inf\n\
+\n\
 @deftypefn  {Built-in Function} {} Inf\n\
 @deftypefnx {Built-in Function} {} Inf (@var{n})\n\
 @deftypefnx {Built-in Function} {} Inf (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} Inf (@var{n}, @var{m}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} Inf (@dots{}, @var{class})\n\
 Return a scalar, matrix or N-dimensional array whose elements are all equal\n\
 to the IEEE representation for positive infinity.\n\
 \n\
@@ -3979,16 +3982,19 @@ DEFALIAS (inf, Inf);
 %!error(inf (2, 3,'int8'));
 %!error(inf (3, 2,'int8'));
 %!error(inf (3, 4, 5, 'int8'));
 
  */
 
 DEFUN (NaN, args, ,
   "-*- texinfo -*-\n\
+@c List other form of function in documentation index\n\
+@findex nan\n\
+\n\
 @deftypefn  {Built-in Function} {} NaN\n\
 @deftypefnx {Built-in Function} {} NaN (@var{n})\n\
 @deftypefnx {Built-in Function} {} NaN (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} NaN (@var{n}, @var{m}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} NaN (@dots{}, @var{class})\n\
 Return a scalar, matrix, or N-dimensional array whose elements are all equal\n\
 to the IEEE symbol NaN (Not a Number).\n\
 NaN is the result of operations which do not produce a well defined numerical\n\
@@ -5594,19 +5600,23 @@ This function and @w{@xcode{x ./ y}} are
 {
   return binary_op_defun_body (octave_value::op_el_div, args);
 }
 
 DEFUN (power, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} power (@var{x}, @var{y})\n\
 Return the element-by-element operation of @var{x} raised to the\n\
-@var{y} power.\n\
+@var{y} power.  If several complex results are possible,\n\
+returns the one with smallest non-negative argument (angle).  Use\n\
+@code{realpow}, @code{realsqrt}, @code{cbrt}, or @code{nthroot} if a\n\
+real result is preferred.\n\
+\n\
 This function and @w{@xcode{x .^ y}} are equivalent.\n\
-@seealso{mpower}\n\
+@seealso{mpower, realpow, realsqrt, cbrt, nthroot}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_el_pow, args);
 }
 
 DEFUN (ldivide, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ldivide (@var{x}, @var{y})\n\
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -1874,16 +1874,19 @@ use @code{fclose} for the same purpose.\
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("tmpnam", Ftmpnam, args, ,
  "-*- texinfo -*-\n\
+@c List other forms of function in documentation index\n\
+@findex octave_tmp_file_name\n\
+\n\
 @deftypefn  {Built-in Function} {} tmpnam ()\n\
 @deftypefnx {Built-in Function} {} tmpnam (@var{dir})\n\
 @deftypefnx {Built-in Function} {} tmpnam (@var{dir}, @var{prefix})\n\
 Return a unique temporary file name as a string.\n\
 \n\
 If @var{prefix} is omitted, a value of @code{\"oct-\"} is used.\n\
 If @var{dir} is also omitted, the default directory for temporary files\n\
 is used.  If @var{dir} is provided, it must exist, otherwise the default\n\
@@ -2173,46 +2176,51 @@ this system.  The name of this directory
 // NOTE: the values of SEEK_SET, SEEK_CUR, and SEEK_END have to be
 // this way for Matlab compatibility.
 
 DEFUNX ("SEEK_SET", FSEEK_SET, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} SEEK_SET ()\n\
 @deftypefnx {Built-in Function} {} SEEK_CUR ()\n\
 @deftypefnx {Built-in Function} {} SEEK_END ()\n\
-Return the value required to request that @code{fseek} perform\n\
+Return the numerical value to pass to @code{fseek} to perform\n\
 one of the following actions:\n\
 @table @code\n\
 @item SEEK_SET\n\
 Position file relative to the beginning.\n\
 \n\
 @item SEEK_CUR\n\
 Position file relative to the current position.\n\
 \n\
 @item SEEK_END\n\
 Position file relative to the end.\n\
 @end table\n\
+@seealso{fseek}\n\
 @end deftypefn")
 {
   return const_value ("SEEK_SET", args, -1);
 }
 
 DEFUNX ("SEEK_CUR", FSEEK_CUR, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} SEEK_CUR ()\n\
-See SEEK_SET.\n\
+Return the numerical value to pass to @code{fseek} to\n\
+position the file pointer relative to the current position.\n\
+@seealso{SEEK_SET, SEEK_END}.\n\
 @end deftypefn")
 {
   return const_value ("SEEK_CUR", args, 0);
 }
 
 DEFUNX ("SEEK_END", FSEEK_END, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} SEEK_END ()\n\
-See SEEK_SET.\n\
+Return the numerical value to pass to @code{fseek} to\n\
+position the file pointer relative to the end of the file.\n\
+@seealso{SEEK_SET, SEEK_CUR}.\n\
 @end deftypefn")
 {
   return const_value ("SEEK_END", args, 1);
 }
 
 static octave_value
 const_value (const char *, const octave_value_list& args,
              const octave_value& val)
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -234,25 +234,29 @@ Array index or function argument delimit
 @deftypefn {Operator} {} *\n\
 Multiplication operator.\n\
 @seealso{.*, times}\n\
 @end deftypefn"),
 
   pair_type ("**",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} **\n\
-Power operator.\n\
-@seealso{power, ^, .**, .^}\n\
+Power operator.  This may return complex results for real inputs.  Use\n\
+@code{realsqrt}, @code{cbrt}, @code{nthroot}, or @code{realroot} to obtain\n\
+real results when possible.\n\
+@seealso{power, ^, .**, .^, realpow, realsqrt, cbrt, nthroot}\n\
 @end deftypefn"),
 
   pair_type ("^",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} ^\n\
-Power operator.\n\
-@seealso{power, **, .^, .**}\n\
+Power operator.  This may return complex results for real inputs.  Use\n\
+@code{realsqrt}, @code{cbrt}, @code{nthroot}, or @code{realroot} to obtain\n\
+real results when possible.\n\
+@seealso{power, **, .^, .**, realpow, realsqrt, cbrt, nthroot}\n\
 @end deftypefn"),
 
   pair_type ("+",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} +\n\
 Addition operator.\n\
 @seealso{plus}\n\
 @end deftypefn"),
@@ -299,25 +303,31 @@ transpose, @emph{not} the complex conjug
 @deftypefn {Operator} {} .*\n\
 Element by element multiplication operator.\n\
 @seealso{*, times}\n\
 @end deftypefn"),
 
   pair_type (".**",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} .*\n\
-Element by element power operator.\n\
-@seealso{**, ^, .^, power}\n\
+Element by element power operator.  If several complex results are possible,\n\
+returns the one with smallest non-negative argument (angle).  Use\n\
+@code{realpow}, @code{realsqrt}, @code{cbrt}, or @code{nthroot} if a\n\
+real result is preferred.\n\
+@seealso{**, ^, .^, power, realpow, realsqrt, cbrt, nthroot}\n\
 @end deftypefn"),
 
   pair_type (".^",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} .^\n\
-Element by element power operator.\n\
-@seealso{.**, ^, **, power}\n\
+Element by element power operator.  If several complex results are possible,\n\
+returns the one with smallest non-negative argument (angle).  Use\n\
+@code{realpow}, @code{realsqrt}, @code{cbrt}, or @code{nthroot} if a\n\
+real result is preferred.\n\
+@seealso{.**, ^, **, power, realpow, realsqrt, cbrt, nthroot}\n\
 @end deftypefn"),
 
   pair_type ("./",
     "-*- texinfo -*-\n\
 @deftypefn {Operator} {} ./\n\
 Element by element right division operator.\n\
 @seealso{/, .\\, rdivide, mrdivide}\n\
 @end deftypefn"),
diff --git a/src/oct-parse.yy b/src/oct-parse.yy
--- a/src/oct-parse.yy
+++ b/src/oct-parse.yy
@@ -1894,18 +1894,16 @@ fold (tree_binary_expression *e)
   frame.protect_var (discard_warning_messages);
 
   discard_error_messages = true;
   discard_warning_messages = true;
 
   tree_expression *op1 = e->lhs ();
   tree_expression *op2 = e->rhs ();
 
-  octave_value::binary_op op_type = e->op_type ();
-
   if (op1->is_constant () && op2->is_constant ())
     {
       octave_value tmp = e->rvalue1 ();
 
       if (! (error_state || warning_state))
         {
           tree_constant *tc_retval
             = new tree_constant (tmp, op1->line (), op1->column ());
@@ -3261,17 +3259,17 @@ static bool
 looks_like_copyright (const std::string& s)
 {
   bool retval = false;
 
   if (! s.empty ())
     {
       size_t offset = s.find_first_not_of (" \t");
 
-      retval = (s.substr (offset, 9) == "Copyright");
+      retval = (s.substr (offset, 9) == "Copyright" || s.substr (offset, 6) == "Author");
     }
 
   return retval;
 }
 
 static int
 text_getc (FILE *f)
 {
@@ -4443,17 +4441,18 @@ cleanup_statement_list (tree_statement_l
     {
       delete *lst;
       *lst = 0;
     }
 }
 
 DEFUN (eval, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} eval (@var{try}, @var{catch})\n\
+@deftypefn  {Built-in Function} {} eval (@var{try})\n\
+@deftypefnx {Built-in Function} {} eval (@var{try}, @var{catch})\n\
 Parse the string @var{try} and evaluate it as if it were an Octave\n\
 program.  If that fails, evaluate the optional string @var{catch}.\n\
 The string @var{try} is evaluated in the current context,\n\
 so any results remain available after @code{eval} returns.\n\
 \n\
 The following example makes the variable @var{a} with the approximate\n\
 value 3.1416 available.\n\
 \n\
@@ -4467,16 +4466,21 @@ string is evaluated, as the following ex
 @example\n\
 @group\n\
 eval ('error (\"This is a bad example\");',\n\
       'printf (\"This error occurred:\\n%s\\n\", lasterr ());');\n\
      @print{} This error occurred:\n\
         This is a bad example\n\
 @end group\n\
 @end example\n\
+\n\
+Consider using try/catch blocks instead if you are only using @code{eval}\n\
+as an error-capturing mechanism rather than for the execution of arbitrary\n\
+code strings.\n\
+@seealso{evalin}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin > 0)
     {
@@ -4549,16 +4553,17 @@ eval ('error (\"This is a bad example\")
 
 */
 
 DEFUN (assignin, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} assignin (@var{context}, @var{varname}, @var{value})\n\
 Assign @var{value} to @var{varname} in context @var{context}, which\n\
 may be either @code{\"base\"} or @code{\"caller\"}.\n\
+@seealso{evalin}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 3)
     {
@@ -4598,20 +4603,22 @@ may be either @code{\"base\"} or @code{\
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (evalin, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} evalin (@var{context}, @var{try}, @var{catch})\n\
+@deftypefn  {Built-in Function} {} evalin (@var{context}, @var{try})\n\
+@deftypefnx {Built-in Function} {} evalin (@var{context}, @var{try}, @var{catch})\n\
 Like @code{eval}, except that the expressions are evaluated in the\n\
 context @var{context}, which may be either @code{\"caller\"} or\n\
 @code{\"base\"}.\n\
+@seealso{eval, assignin}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin > 1)
     {
diff --git a/src/ov-fcn-handle.cc b/src/ov-fcn-handle.cc
--- a/src/ov-fcn-handle.cc
+++ b/src/ov-fcn-handle.cc
@@ -1771,16 +1771,48 @@ are ignored in the lookup.\n\
 %!    y = __testrecursionfunc (@(x) f(2*x), x, n);
 %!  endif
 %!endfunction
 %!
 %!assert (__testrecursionfunc (@(x) x, 1), 8)
 
 */
 
+DEFUN (is_function_handle, args, ,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} is_function_handle (@var{x})\n\
+Return true if @var{x} is a function handle.\n\
+@seealso{isa, typeinfo, class}\n\
+@end deftypefn")
+{
+  octave_value retval;
+
+  int nargin = args.length ();
+
+  if (nargin == 1)
+    retval = args(0).is_function_handle ();
+  else
+    print_usage ();
+
+  return retval;
+}
+
+/*
+%!shared fh
+%! fh = @(x) x;
+
+%!assert (is_function_handle (fh))
+%!assert (! is_function_handle ({fh}))
+%!assert (! is_function_handle (1))
+%!error is_function_handle ();
+%!error is_function_handle (1, 2);
+
+*/
+
+
 octave_fcn_binder::octave_fcn_binder (const octave_value& f,
                                       const octave_value& root,
                                       const octave_value_list& templ,
                                       const std::vector<int>& mask,
                                       int exp_nargin)
 : octave_fcn_handle (f), root_handle (root), arg_template (templ),
   arg_mask (mask), expected_nargin (exp_nargin)
 {
diff --git a/src/syscalls.cc b/src/syscalls.cc
--- a/src/syscalls.cc
+++ b/src/syscalls.cc
@@ -1641,81 +1641,81 @@ const_value (const octave_value_list& ar
 
 #if !defined (O_NONBLOCK) && defined (O_NDELAY)
 #define O_NONBLOCK O_NDELAY
 #endif
 
 DEFUNX ("F_DUPFD", FF_DUPFD, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} F_DUPFD ()\n\
-Return the value required to request that @code{fcntl} return a\n\
+Return the numerical value to pass to @code{fcntl} to return a\n\
 duplicate file descriptor.\n\
 @seealso{fcntl, F_GETFD, F_GETFL, F_SETFD, F_SETFL}\n\
 @end deftypefn")
 {
 #if defined (F_DUPFD)
   return const_value (args, F_DUPFD);
 #else
   error ("F_DUPFD: not available on this system");
   return octave_value ();
 #endif
 }
 
 DEFUNX ("F_GETFD", FF_GETFD, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} F_GETFD ()\n\
-Return the value required to request that @code{fcntl} to return the\n\
+Return the numerical value to pass to @code{fcntl} to return the\n\
 file descriptor flags.\n\
 @seealso{fcntl, F_DUPFD, F_GETFL, F_SETFD, F_SETFL}\n\
 @end deftypefn")
 {
 #if defined (F_GETFD)
   return const_value (args, F_GETFD);
 #else
   error ("F_GETFD: not available on this system");
   return octave_value ();
 #endif
 }
 
 DEFUNX ("F_GETFL", FF_GETFL, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} F_GETFL ()\n\
-Return the value required to request that @code{fcntl} to return the\n\
+Return the numerical value to pass to @code{fcntl} to return the\n\
 file status flags.\n\
 @seealso{fcntl, F_DUPFD, F_GETFD, F_SETFD, F_SETFL}\n\
 @end deftypefn")
 {
 #if defined (F_GETFL)
   return const_value (args, F_GETFL);
 #else
   error ("F_GETFL: not available on this system");
   return octave_value ();
 #endif
 }
 
 DEFUNX ("F_SETFD", FF_SETFD, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} F_SETFD ()\n\
-Return the value required to request that @code{fcntl} to set the file\n\
+Return the numerical value to pass to @code{fcntl} to set the file\n\
 descriptor flags.\n\
 @seealso{fcntl, F_DUPFD, F_GETFD, F_GETFL, F_SETFL}\n\
 @end deftypefn")
 {
 #if defined (F_SETFD)
   return const_value (args, F_SETFD);
 #else
   error ("F_SETFD: not available on this system");
   return octave_value ();
 #endif
 }
 
 DEFUNX ("F_SETFL", FF_SETFL, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} F_SETFL ()\n\
-Return the value required to request that @code{fcntl} to set the file\n\
+Return the numerical value to pass to @code{fcntl} to set the file\n\
 status flags.\n\
 @seealso{fcntl, F_DUPFD, F_GETFD, F_GETFL, F_SETFD}\n\
 @end deftypefn")
 {
 #if defined (F_SETFL)
   return const_value (args, F_SETFL);
 #else
   error ("F_SETFL: not available on this system");
diff --git a/test/Makefile.am b/test/Makefile.am
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -18,29 +18,27 @@
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 include $(top_srcdir)/build-aux/common.mk
 
 FCN_FILES = \
   fntests.m \
   test_args.m \
-  test_contin.m \
   test_diag_perm.m \
   test_error.m \
   test_eval-catch.m \
   test_for.m \
   test_func.m \
   test_global.m \
   test_if.m \
-  test_index-wfi-f.m \
-  test_index-wfi-t.m \
+  test_index.m \
   test_io.m \
-  test_logical-wfi-f.m \
-  test_logical-wfi-t.m \
+  test_line_continue.m \
+  test_logical_index.m \
   test_null_assign.m \
   test_parser.m \
   test_prefer.m \
   test_range.m \
   test_recursion.m \
   test_return.m \
   test_slice.m \
   test_struct.m \
diff --git a/test/build_sparse_tests.sh b/test/build_sparse_tests.sh
--- a/test/build_sparse_tests.sh
+++ b/test/build_sparse_tests.sh
@@ -641,57 +641,57 @@ gen_square_tests() {
 %! [l,u] = lu (sparse ([1,1;1,1]));
 %! assert (l*u, [1,1;1,1], 10*eps);
 
 %!testif HAVE_UMFPACK
 %! [l,u] = lu (sparse ([1,1;1,1+i]));
 %! assert (l, sparse ([1,2,2],[1,1,2],1), 10*eps);
 %! assert (u, sparse ([1,1,2],[1,2,2],[1,1,1i]), 10*eps);
 
-%!testif HAVE_UMFPACK ;# permuted LU
+%!testif HAVE_UMFPACK   # permuted LU
 %! [L,U] = lu (bs);
 %! assert (L*U, bs, 1e-10);
 
-%!testif HAVE_UMFPACK ;# simple LU + row permutations
+%!testif HAVE_UMFPACK   # simple LU + row permutations
 %! [L,U,P] = lu (bs);
 %! assert (P'*L*U, bs, 1e-10);
 %! # triangularity
 %! [i,j,v] = find (L);
 %! assert (i-j>=0);
 %! [i,j,v] = find (U);
 %! assert (j-i>=0);
 
-%!testif HAVE_UMFPACK ;# simple LU + row/col permutations
+%!testif HAVE_UMFPACK   # simple LU + row/col permutations
 %! [L,U,P,Q] = lu (bs);
 %! assert (P'*L*U*Q', bs, 1e-10);
 %! # triangularity
 %! [i,j,v] = find (L);
 %! assert (i-j>=0);
 %! [i,j,v] = find (U);
 %! assert (j-i>=0);
 
-%!testif HAVE_UMFPACK ;# LU with vector permutations
+%!testif HAVE_UMFPACK   # LU with vector permutations
 %! [L,U,P,Q] = lu (bs,'vector');
 %! assert (L(P,:)*U(:,Q), bs, 1e-10);
 %! # triangularity
 %! [i,j,v] = find (L);
 %! assert (i-j>=0);
 %! [i,j,v] = find (U);
 %! assert (j-i>=0);
 
-%!testif HAVE_UMFPACK ;# LU with scaling
+%!testif HAVE_UMFPACK   # LU with scaling
 %! [L,U,P,Q,R] = lu (bs);
 %! assert (R*P'*L*U*Q', bs, 1e-10);
 %! # triangularity
 %! [i,j,v] = find (L);
 %! assert (i-j>=0);
 %! [i,j,v] = find (U);
 %! assert (j-i>=0);
 
-%!testif HAVE_UMFPACK ;# inverse
+%!testif HAVE_UMFPACK   # inverse
 %! assert (inv (bs)*bs, sparse (eye (rows (bs))), 1e-10);
 
 %!assert (bf\as', bf\af', 100*eps);
 %!assert (bs\af', bf\af', 100*eps);
 %!assert (bs\as', sparse (bf\af'), 100*eps);
 
 EOF
 }
@@ -701,25 +701,25 @@ gen_cholesky_tests() {
     cat >>$TESTS <<EOF
 %!testif HAVE_CHOLMOD
 %! assert (chol (bs)'*chol (bs), bs, 1e-10);
 %!testif HAVE_CHOLMOD 
 %! assert (chol (bs,'lower')*chol (bs,'lower')', bs, 1e-10);
 %!testif HAVE_CHOLMOD
 %! assert (chol (bs,'lower'), chol (bs)', 1e-10);
 
-%!testif HAVE_CHOLMOD ;# Return Partial Cholesky factorization
+%!testif HAVE_CHOLMOD   # Return Partial Cholesky factorization
 %! [RS,PS] = chol (bs);
 %! assert (RS'*RS, bs, 1e-10);
 %! assert (PS, 0);
 %! [LS,PS] = chol (bs,'lower');
 %! assert (LS*LS', bs, 1e-10);
 %! assert (PS, 0);
 
-%!testif HAVE_CHOLMOD ;# Permuted Cholesky factorization
+%!testif HAVE_CHOLMOD   # Permuted Cholesky factorization
 %! [RS,PS,QS] = chol (bs);
 %! assert (RS'*RS, QS*bs*QS', 1e-10);
 %! assert (PS, 0);
 %! [LS,PS,QS] = chol (bs,'lower');
 %! assert (LS*LS', QS*bs*QS', 1e-10);
 %! assert (PS, 0);
 
 EOF
@@ -745,48 +745,48 @@ gen_rectangular_tests() {
     gen_unaryop_tests
     gen_elementop_tests
     gen_sparsesparse_elementop_tests
     gen_matrixop_tests
     # gen_divop_tests # Disable rectangular \ and / for now
     gen_matrixdiag_tests
     gen_matrixreshape_tests
     cat >>$TESTS <<EOF
-%!testif HAVE_UMFPACK ;# permuted LU
+%!testif HAVE_UMFPACK   # permuted LU
 %! [L,U] = lu (bs);
 %! assert (L*U, bs, 1e-10);
 
-%!testif HAVE_UMFPACK ;# simple LU + row permutations
+%!testif HAVE_UMFPACK   # simple LU + row permutations
 %! [L,U,P] = lu (bs);
 %! assert (P'*L*U, bs, 1e-10);
 %! # triangularity
 %! [i,j,v] = find (L);
 %! assert (i-j>=0);
 %! [i,j,v] = find (U);
 %! assert (j-i>=0);
 
-%!testif HAVE_UMFPACK ;# simple LU + row/col permutations
+%!testif HAVE_UMFPACK   # simple LU + row/col permutations
 %! [L,U,P,Q] = lu (bs);
 %! assert (P'*L*U*Q', bs, 1e-10);
 %! # triangularity
 %! [i,j,v] = find (L);
 %! assert (i-j>=0);
 %! [i,j,v] = find (U);
 %! assert (j-i>=0);
 
-%!testif HAVE_UMFPACK ;# LU with vector permutations
+%!testif HAVE_UMFPACK   # LU with vector permutations
 %! [L,U,P,Q] = lu (bs,'vector');
 %! assert (L (P,:)*U (:,Q), bs, 1e-10);
 %! # triangularity
 %! [i,j,v] = find (L);
 %! assert (i-j>=0);
 %! [i,j,v] = find (U);
 %! assert (j-i>=0);
 
-%!testif HAVE_UMFPACK ;# LU with scaling
+%!testif HAVE_UMFPACK   # LU with scaling
 %! [L,U,P,Q,R] = lu (bs);
 %! assert (R*P'*L*U*Q', bs, 1e-10);
 %! # triangularity
 %! [i,j,v] = find (L);
 %! assert (i-j>=0);
 %! [i,j,v] = find (U);
 %! assert (j-i>=0);
 
@@ -925,17 +925,17 @@ gen_save_tests() {
 %!test # save binary
 %! savefile = tmpnam ();
 %! as_save = as;
 %! save ("-binary", savefile, "bf", "as_save", "af");
 %! clear as_save;
 %! load (savefile, "as_save");
 %! unlink (savefile);
 %! assert (as_save, sparse(af));
-%!testif HAVE_HDF5 # save hdf5
+%!testif HAVE_HDF5   # save hdf5
 %! savefile = tmpnam ();
 %! as_save = as;
 %! save ("-hdf5", savefile, "bf", "as_save", "af");
 %! clear as_save;
 %! load (savefile, "as_save");
 %! unlink (savefile);
 %! assert (as_save, sparse(af));
 ## FIXME: We should skip (or mark as an expected failure) the test for
