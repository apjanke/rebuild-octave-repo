# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1484599461 18000
#      Mon Jan 16 15:44:21 2017 -0500
# Node ID f97e22a9012a44d01e3b95fb6cd9f6da10aa92b1
# Parent  6e9f4f6283b7675413f752e2291ffb0988d0ed70
move octave_call_stack inside octave namespace

* call-stack.h, call-stack.cc (call_stack): Move inside octave
namespace and rename from octave_call_stack.  Change all uses.

diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -1779,17 +1779,17 @@ file_editor_tab::exit_debug_and_clear (c
   if (octave::sys::canonicalize_file_name (full_name.c_str ())
       != octave::sys::canonicalize_file_name (fcn->fcn_file_name ().c_str ()))
     return true;
 
   // If this file is loaded, check that we aren't currently running it
   bool retval = true;
   octave_idx_type curr_frame = -1;
   size_t nskip = 0;
-  octave_map stk = octave_call_stack::backtrace (nskip, curr_frame, false);
+  octave_map stk = octave::call_stack::backtrace (nskip, curr_frame, false);
   Cell names = stk.contents ("name");
   for (octave_idx_type i = names.numel () - 1; i >= 0; i--)
     {
       if (names(i).string_value () == base_name)
         {
           int ans = QMessageBox::question (0, tr ("Debug or Save"),
              tr ("This file is currently being executed.\n"
                           "Quit debugging and save?"),
@@ -1797,17 +1797,17 @@ file_editor_tab::exit_debug_and_clear (c
 
           if (ans == QMessageBox::Save)
             {
               emit execute_command_in_terminal_signal ("dbquit");
               // Wait until dbquit has actually occurred
               while (names.numel () > i)
                 {
                   octave_sleep (0.01);
-                  stk = octave_call_stack::backtrace (nskip, curr_frame, false);
+                  stk = octave::call_stack::backtrace (nskip, curr_frame, false);
                   names = stk.contents ("name");
                 }
             }
           else
             retval = false;
           break;
         }
     }
diff --git a/libinterp/corefcn/call-stack.cc b/libinterp/corefcn/call-stack.cc
--- a/libinterp/corefcn/call-stack.cc
+++ b/libinterp/corefcn/call-stack.cc
@@ -28,558 +28,559 @@ along with Octave; see the file COPYING.
 
 #include "call-stack.h"
 #include "oct-map.h"
 #include "ov.h"
 #include "ov-fcn.h"
 #include "ov-fcn-handle.h"
 #include "ov-usr-fcn.h"
 
-octave_call_stack *octave_call_stack::instance = 0;
-
-std::string
-octave_call_stack::stack_frame::fcn_file_name (void) const
-{
-  return m_fcn ? m_fcn->fcn_file_name () : "";
-}
-
-std::string
-octave_call_stack::stack_frame::fcn_name (bool print_subfn) const
-{
-  std::string retval;
-
-  if (m_fcn)
-    {
-      std::string parent_fcn_name = m_fcn->parent_fcn_name ();
-
-      if (print_subfn && ! parent_fcn_name.empty ())
-        retval = parent_fcn_name + Vfilemarker;
-
-      if (m_fcn->is_anonymous_function ())
-        retval += octave_fcn_handle::anonymous;
-      else
-        retval += m_fcn->name ();
-    }
-  else
-    retval = "<unknown>";
-
-  return retval;
-}
-
-bool
-octave_call_stack::stack_frame::operator == (const octave_call_stack::stack_frame &rhs) const
-{
-  if (this->line () != rhs.line ())
-    return false;
-  else if (this->column () != rhs.column ())
-    return false;
-  else if (this->fcn_file_name () != rhs.fcn_file_name ())
-    return false;
-  else if (this->fcn_name () != rhs.fcn_name ())
-    return false;
-  else
-    return true;
-}
-
-void
-octave_call_stack::create_instance (void)
-{
-  instance = new octave_call_stack ();
-
-  if (instance)
-    {
-      instance->do_push (0, symbol_table::top_scope (), 0);
-
-      singleton_cleanup_list::add (cleanup_instance);
-    }
-}
-
-int
-octave_call_stack::do_current_line (void) const
-{
-  int retval = -1;
-
-  if (! cs.empty ())
-    {
-      const stack_frame& elt = cs[curr_frame];
-      retval = elt.m_line;
-    }
-
-  return retval;
-}
-
-int
-octave_call_stack::do_current_column (void) const
-{
-  int retval = -1;
-
-  if (! cs.empty ())
-    {
-      const stack_frame& elt = cs[curr_frame];
-      retval = elt.m_column;
-    }
-
-  return retval;
-}
-
-size_t
-octave_call_stack::do_num_user_code_frames
-  (octave_idx_type& curr_user_frame) const
-{
-  size_t retval = 0;
-
-  curr_user_frame = 0;
-
-  // Look for the caller of dbstack.
-  size_t xframe = cs[curr_frame].m_prev;
-
-  bool found = false;
-
-  size_t k = cs.size ();
-
-  for (const_reverse_iterator p = cs.rbegin (); p != cs.rend (); p++)
-    {
-      octave_function *f = (*p).m_fcn;
-
-      if (--k == xframe)
-        found = true;
-
-      if (f && f->is_user_code ())
-        {
-          if (! found)
-            curr_user_frame++;
-
-          retval++;
-        }
-    }
-
-  // We counted how many user frames were not the one, in reverse.
-  // Now set curr_user_frame to be the index in the other direction.
-  curr_user_frame = retval - curr_user_frame - 1;
-
-  return retval;
-}
-
-octave_user_code *
-octave_call_stack::do_caller_user_code (size_t nskip) const
-{
-  octave_user_code *retval = 0;
-
-  const_iterator p = cs.end ();
-
-  while (p != cs.begin ())
-    {
-      const stack_frame& elt = *(--p);
-
-      octave_function *f = elt.m_fcn;
-
-      if (f && f->is_user_code ())
-        {
-          if (nskip > 0)
-            nskip--;
-          else
-            {
-              retval = dynamic_cast<octave_user_code *> (f);
-              break;
-            }
-        }
-    }
-
-  return retval;
-}
-
-int
-octave_call_stack::do_caller_user_code_line (void) const
-{
-  int retval = -1;
-
-  const_iterator p = cs.end ();
-
-  while (p != cs.begin ())
-    {
-      const stack_frame& elt = *(--p);
-
-      octave_function *f = elt.m_fcn;
-
-      if (f && f->is_user_code ())
-        {
-          if (elt.m_line > 0)
-            {
-              retval = elt.m_line;
-              break;
-            }
-        }
-    }
-
-  return retval;
-}
-
-int
-octave_call_stack::do_caller_user_code_column (void) const
-{
-  int retval = -1;
-
-  const_iterator p = cs.end ();
-
-  while (p != cs.begin ())
-    {
-      const stack_frame& elt = *(--p);
-
-      octave_function *f = elt.m_fcn;
-
-      if (f && f->is_user_code ())
-        {
-          if (elt.m_column)
-            {
-              retval = elt.m_column;
-              break;
-            }
-        }
-    }
-
-  return retval;
-}
-
-octave_user_code *
-octave_call_stack::do_debug_user_code (void) const
-{
-  octave_user_code *retval = 0;
-
-  // This should never happen...
-  if (curr_frame == 0)
-    return retval;
-
-  // Start looking with the caller of the calling debug function.
-  size_t i = cs[curr_frame].m_prev;
-
-  while (i != 0)
-    {
-      const stack_frame& elt = cs[i--];
-
-      octave_function *f = elt.m_fcn;
-
-      if (f && f->is_user_code ())
-        {
-          retval = dynamic_cast<octave_user_code *> (f);
-          break;
-        }
-    }
-
-  return retval;
-}
-
-int
-octave_call_stack::do_debug_user_code_line (void) const
-{
-  int retval = -1;
-
-  // This should never happen...
-  if (curr_frame == 0)
-    return retval;
-
-  // Start looking with the caller of the calling debug function.
-  size_t i = cs[curr_frame].m_prev;
-
-  while (i != 0)
-    {
-      const stack_frame& elt = cs[i--];
-
-      octave_function *f = elt.m_fcn;
-
-      if (f && f->is_user_code ())
-        {
-          if (elt.m_line)
-            {
-              retval = elt.m_line;
-              break;
-            }
-        }
-    }
-
-  return retval;
-}
-
-int
-octave_call_stack::do_debug_user_code_column (void) const
-{
-  int retval = -1;
-
-  // This should never happen...
-  if (curr_frame == 0)
-    return retval;
-
-  // Start looking with the caller of the calling debug function.
-  size_t i = cs[curr_frame].m_prev;
-
-  while (i != 0)
-    {
-      const stack_frame& elt = cs[i--];
-
-      octave_function *f = elt.m_fcn;
-
-      if (f && f->is_user_code ())
-        {
-          if (elt.m_column)
-            {
-              retval = elt.m_column;
-              break;
-            }
-        }
-    }
-
-  return retval;
-}
-
-bool
-octave_call_stack::do_all_scripts (void) const
-{
-  bool retval = true;
-
-  const_iterator p = cs.end ();
-
-  while (p != cs.begin ())
-    {
-      const stack_frame& elt = *(--p);
-
-      octave_function *f = elt.m_fcn;
-
-      if (f && ! f->is_user_script ())
-        {
-          retval = false;
-          break;
-        }
-    }
-
-  return retval;
-}
-
 // Use static fields for the best efficiency.
 // NOTE: C++0x will allow these two to be merged into one.
-static const char *bt_fieldnames[] = { "file", "name", "line",
-                                       "column", "scope", "context", 0
-                                     };
+static const char *bt_fieldnames[] =
+  { "file", "name", "line", "column", "scope", "context", 0 };
 static const octave_fields bt_fields (bt_fieldnames);
 
-octave_map
-octave_call_stack::empty_backtrace (void)
+namespace octave
 {
-  return octave_map (dim_vector (0, 1), bt_fields);
-}
+  call_stack *call_stack::instance = 0;
+
+  std::string
+  call_stack::stack_frame::fcn_file_name (void) const
+  {
+    return m_fcn ? m_fcn->fcn_file_name () : "";
+  }
+
+  std::string
+  call_stack::stack_frame::fcn_name (bool print_subfn) const
+  {
+    std::string retval;
 
-std::list<octave_call_stack::stack_frame>
-octave_call_stack::do_backtrace_frames (size_t nskip,
-                                        octave_idx_type& curr_user_frame) const
-{
-  std::list<octave_call_stack::stack_frame> retval;
+    if (m_fcn)
+      {
+        std::string parent_fcn_name = m_fcn->parent_fcn_name ();
+
+        if (print_subfn && ! parent_fcn_name.empty ())
+          retval = parent_fcn_name + Vfilemarker;
+
+        if (m_fcn->is_anonymous_function ())
+          retval += octave_fcn_handle::anonymous;
+        else
+          retval += m_fcn->name ();
+      }
+    else
+      retval = "<unknown>";
+
+    return retval;
+  }
 
-  size_t user_code_frames = do_num_user_code_frames (curr_user_frame);
-
-  size_t nframes = nskip <= user_code_frames ? user_code_frames - nskip : 0;
+  bool
+  call_stack::stack_frame::operator == (const call_stack::stack_frame &rhs) const
+  {
+    if (this->line () != rhs.line ())
+      return false;
+    else if (this->column () != rhs.column ())
+      return false;
+    else if (this->fcn_file_name () != rhs.fcn_file_name ())
+      return false;
+    else if (this->fcn_name () != rhs.fcn_name ())
+      return false;
+    else
+      return true;
+  }
 
-  // Our list is reversed.
-  curr_user_frame = nframes - curr_user_frame - 1;
+  void
+  call_stack::create_instance (void)
+  {
+    instance = new call_stack ();
+
+    if (instance)
+      {
+        instance->do_push (0, symbol_table::top_scope (), 0);
 
-  if (nframes > 0)
-    {
-      for (const_reverse_iterator p = cs.rbegin (); p != cs.rend (); p++)
-        {
-          const stack_frame& elt = *p;
+        singleton_cleanup_list::add (cleanup_instance);
+      }
+  }
+
+  int
+  call_stack::do_current_line (void) const
+  {
+    int retval = -1;
 
-          octave_function *f = elt.m_fcn;
+    if (! cs.empty ())
+      {
+        const stack_frame& elt = cs[curr_frame];
+        retval = elt.m_line;
+      }
+
+    return retval;
+  }
+
+  int
+  call_stack::do_current_column (void) const
+  {
+    int retval = -1;
 
-          if (f && f->is_user_code ())
-            {
-              if (nskip > 0)
-                nskip--;
-              else
-                retval.push_back (elt);
-            }
-        }
-    }
+    if (! cs.empty ())
+      {
+        const stack_frame& elt = cs[curr_frame];
+        retval = elt.m_column;
+      }
+
+    return retval;
+  }
+
+  size_t
+  call_stack::do_num_user_code_frames
+  (octave_idx_type& curr_user_frame) const
+  {
+    size_t retval = 0;
+
+    curr_user_frame = 0;
+
+    // Look for the caller of dbstack.
+    size_t xframe = cs[curr_frame].m_prev;
 
-  return retval;
-}
+    bool found = false;
+
+    size_t k = cs.size ();
+
+    for (const_reverse_iterator p = cs.rbegin (); p != cs.rend (); p++)
+      {
+        octave_function *f = (*p).m_fcn;
+
+        if (--k == xframe)
+          found = true;
+
+        if (f && f->is_user_code ())
+          {
+            if (! found)
+              curr_user_frame++;
 
-octave_map
-octave_call_stack::do_backtrace (size_t nskip,
-                                 octave_idx_type& curr_user_frame,
-                                 bool print_subfn) const
-{
-  std::list<octave_call_stack::stack_frame> frames
-    = do_backtrace_frames (nskip, curr_user_frame);
+            retval++;
+          }
+      }
+
+    // We counted how many user frames were not the one, in reverse.
+    // Now set curr_user_frame to be the index in the other direction.
+    curr_user_frame = retval - curr_user_frame - 1;
 
-  size_t nframes = frames.size ();
+    return retval;
+  }
 
-  octave_map retval (dim_vector (nframes, 1), bt_fields);
+  octave_user_code *
+  call_stack::do_caller_user_code (size_t nskip) const
+  {
+    octave_user_code *retval = 0;
+
+    const_iterator p = cs.end ();
 
-  Cell& file = retval.contents (0);
-  Cell& name = retval.contents (1);
-  Cell& line = retval.contents (2);
-  Cell& column = retval.contents (3);
-  Cell& scope = retval.contents (4);
-  Cell& context = retval.contents (5);
+    while (p != cs.begin ())
+      {
+        const stack_frame& elt = *(--p);
+
+        octave_function *f = elt.m_fcn;
 
-  octave_idx_type k = 0;
+        if (f && f->is_user_code ())
+          {
+            if (nskip > 0)
+              nskip--;
+            else
+              {
+                retval = dynamic_cast<octave_user_code *> (f);
+                break;
+              }
+          }
+      }
+
+    return retval;
+  }
+
+  int
+  call_stack::do_caller_user_code_line (void) const
+  {
+    int retval = -1;
+
+    const_iterator p = cs.end ();
 
-  for (const auto& frm : frames)
-    {
-      scope(k)   = frm.m_scope;
-      context(k) = frm.m_context;
-      file(k)    = frm.fcn_file_name ();
-      name(k)    = frm.fcn_name (print_subfn);
-      line(k)    = frm.m_line;
-      column(k)  = frm.m_column;
+    while (p != cs.begin ())
+      {
+        const stack_frame& elt = *(--p);
+
+        octave_function *f = elt.m_fcn;
+
+        if (f && f->is_user_code ())
+          {
+            if (elt.m_line > 0)
+              {
+                retval = elt.m_line;
+                break;
+              }
+          }
+      }
 
-      k++;
-    }
+    return retval;
+  }
+
+  int
+  call_stack::do_caller_user_code_column (void) const
+  {
+    int retval = -1;
 
-  return retval;
-}
+    const_iterator p = cs.end ();
 
-bool
-octave_call_stack::do_goto_frame (size_t n, bool verbose)
-{
-  bool retval = false;
+    while (p != cs.begin ())
+      {
+        const stack_frame& elt = *(--p);
+
+        octave_function *f = elt.m_fcn;
 
-  if (n < cs.size ())
-    {
-      retval = true;
+        if (f && f->is_user_code ())
+          {
+            if (elt.m_column)
+              {
+                retval = elt.m_column;
+                break;
+              }
+          }
+      }
+
+    return retval;
+  }
+
+  octave_user_code *
+  call_stack::do_debug_user_code (void) const
+  {
+    octave_user_code *retval = 0;
 
-      curr_frame = n;
+    // This should never happen...
+    if (curr_frame == 0)
+      return retval;
+
+    // Start looking with the caller of the calling debug function.
+    size_t i = cs[curr_frame].m_prev;
 
-      const stack_frame& elt = cs[n];
+    while (i != 0)
+      {
+        const stack_frame& elt = cs[i--];
+
+        octave_function *f = elt.m_fcn;
 
-      symbol_table::set_scope_and_context (elt.m_scope, elt.m_context);
+        if (f && f->is_user_code ())
+          {
+            retval = dynamic_cast<octave_user_code *> (f);
+            break;
+          }
+      }
 
-      if (verbose)
-        octave_stdout << "stopped in " << elt.fcn_name ()
-                      << " at line " << elt.m_line
-                      << " column " << elt.m_column
-                      << " [" << elt.fcn_file_name () << "] "
-                      << " (scope = " << elt.m_scope
-                      << "[context = " << elt.m_context << "])"
-                      << std::endl;
-    }
+    return retval;
+  }
+
+  int
+  call_stack::do_debug_user_code_line (void) const
+  {
+    int retval = -1;
+
+    // This should never happen...
+    if (curr_frame == 0)
+      return retval;
+
+    // Start looking with the caller of the calling debug function.
+    size_t i = cs[curr_frame].m_prev;
+
+    while (i != 0)
+      {
+        const stack_frame& elt = cs[i--];
 
-  return retval;
-}
+        octave_function *f = elt.m_fcn;
 
-bool
-octave_call_stack::do_goto_frame_relative (int nskip, bool verbose)
-{
-  bool retval = false;
+        if (f && f->is_user_code ())
+          {
+            if (elt.m_line)
+              {
+                retval = elt.m_line;
+                break;
+              }
+          }
+      }
 
-  int incr = 0;
+    return retval;
+  }
+
+  int
+  call_stack::do_debug_user_code_column (void) const
+  {
+    int retval = -1;
 
-  if (nskip < 0)
-    incr = -1;
-  else if (nskip > 0)
-    incr = 1;
+    // This should never happen...
+    if (curr_frame == 0)
+      return retval;
+
+    // Start looking with the caller of the calling debug function.
+    size_t i = cs[curr_frame].m_prev;
+
+    while (i != 0)
+      {
+        const stack_frame& elt = cs[i--];
+
+        octave_function *f = elt.m_fcn;
 
-  // Start looking with the caller of dbup/dbdown/keyboard.
-  size_t xframe = cs[curr_frame].m_prev;
+        if (f && f->is_user_code ())
+          {
+            if (elt.m_column)
+              {
+                retval = elt.m_column;
+                break;
+              }
+          }
+      }
 
-  while (true)
-    {
-      if ((incr < 0 && xframe == 0) || (incr > 0 && xframe == cs.size () - 1))
-        break;
+    return retval;
+  }
+
+  bool
+  call_stack::do_all_scripts (void) const
+  {
+    bool retval = true;
+
+    const_iterator p = cs.end ();
 
-      xframe += incr;
+    while (p != cs.begin ())
+      {
+        const stack_frame& elt = *(--p);
+
+        octave_function *f = elt.m_fcn;
 
-      const stack_frame& elt = cs[xframe];
+        if (f && ! f->is_user_script ())
+          {
+            retval = false;
+            break;
+          }
+      }
 
-      octave_function *f = elt.m_fcn;
+    return retval;
+  }
 
-      if (xframe == 0 || (f && f->is_user_code ()))
-        {
-          if (nskip > 0)
-            nskip--;
-          else if (nskip < 0)
-            nskip++;
+  octave_map
+  call_stack::empty_backtrace (void)
+  {
+    return octave_map (dim_vector (0, 1), bt_fields);
+  }
+
+  std::list<call_stack::stack_frame>
+  call_stack::do_backtrace_frames (size_t nskip,
+                                   octave_idx_type& curr_user_frame) const
+  {
+    std::list<call_stack::stack_frame> retval;
+
+    size_t user_code_frames = do_num_user_code_frames (curr_user_frame);
+
+    size_t nframes = nskip <= user_code_frames ? user_code_frames - nskip : 0;
+
+    // Our list is reversed.
+    curr_user_frame = nframes - curr_user_frame - 1;
 
-          if (nskip == 0)
-            {
-              curr_frame = xframe;
-              cs[cs.size () - 1].m_prev = curr_frame;
+    if (nframes > 0)
+      {
+        for (const_reverse_iterator p = cs.rbegin (); p != cs.rend (); p++)
+          {
+            const stack_frame& elt = *p;
+
+            octave_function *f = elt.m_fcn;
 
-              symbol_table::set_scope_and_context (elt.m_scope, elt.m_context);
+            if (f && f->is_user_code ())
+              {
+                if (nskip > 0)
+                  nskip--;
+                else
+                  retval.push_back (elt);
+              }
+          }
+      }
 
-              if (verbose)
-                {
-                  std::ostringstream buf;
+    return retval;
+  }
+
+  octave_map
+  call_stack::do_backtrace (size_t nskip,
+                            octave_idx_type& curr_user_frame,
+                            bool print_subfn) const
+  {
+    std::list<call_stack::stack_frame> frames
+      = do_backtrace_frames (nskip, curr_user_frame);
+
+    size_t nframes = frames.size ();
+
+    octave_map retval (dim_vector (nframes, 1), bt_fields);
 
-                  if (f)
-                    buf << "stopped in " << elt.fcn_name ()
-                        << " at line " << elt.m_line
-                        << " [" << elt.fcn_file_name () << "] "
-                        << std::endl;
-                  else
-                    buf << "at top level" << std::endl;
+    Cell& file = retval.contents (0);
+    Cell& name = retval.contents (1);
+    Cell& line = retval.contents (2);
+    Cell& column = retval.contents (3);
+    Cell& scope = retval.contents (4);
+    Cell& context = retval.contents (5);
+
+    octave_idx_type k = 0;
 
-                  octave_stdout << buf.str ();
-                }
+    for (const auto& frm : frames)
+      {
+        scope(k)   = frm.m_scope;
+        context(k) = frm.m_context;
+        file(k)    = frm.fcn_file_name ();
+        name(k)    = frm.fcn_name (print_subfn);
+        line(k)    = frm.m_line;
+        column(k)  = frm.m_column;
+
+        k++;
+      }
 
-              retval = true;
-              break;
-            }
-        }
-      else if (incr == 0)  // Break out of infinite loop by choosing an incr.
-        incr = -1;
+    return retval;
+  }
+
+  bool
+  call_stack::do_goto_frame (size_t n, bool verbose)
+  {
+    bool retval = false;
+
+    if (n < cs.size ())
+      {
+        retval = true;
+
+        curr_frame = n;
 
-      // There is no need to set scope and context here.  That will
-      // happen when the dbup/dbdown/keyboard frame is popped and we
-      // jump to the new "prev" frame set above.
-    }
+        const stack_frame& elt = cs[n];
+
+        symbol_table::set_scope_and_context (elt.m_scope, elt.m_context);
+
+        if (verbose)
+          octave_stdout << "stopped in " << elt.fcn_name ()
+                        << " at line " << elt.m_line
+                        << " column " << elt.m_column
+                        << " [" << elt.fcn_file_name () << "] "
+                        << " (scope = " << elt.m_scope
+                        << "[context = " << elt.m_context << "])"
+                        << std::endl;
+      }
 
-  return retval;
-}
+    return retval;
+  }
+
+  bool
+  call_stack::do_goto_frame_relative (int nskip, bool verbose)
+  {
+    bool retval = false;
+
+    int incr = 0;
+
+    if (nskip < 0)
+      incr = -1;
+    else if (nskip > 0)
+      incr = 1;
+
+    // Start looking with the caller of dbup/dbdown/keyboard.
+    size_t xframe = cs[curr_frame].m_prev;
 
-void
-octave_call_stack::do_goto_caller_frame (void)
-{
-  size_t xframe = curr_frame;
+    while (true)
+      {
+        if ((incr < 0 && xframe == 0) || (incr > 0 && xframe == cs.size () - 1))
+          break;
+
+        xframe += incr;
+
+        const stack_frame& elt = cs[xframe];
 
-  bool skipped = false;
+        octave_function *f = elt.m_fcn;
+
+        if (xframe == 0 || (f && f->is_user_code ()))
+          {
+            if (nskip > 0)
+              nskip--;
+            else if (nskip < 0)
+              nskip++;
 
-  while (xframe != 0)
-    {
-      xframe = cs[xframe].m_prev;
+            if (nskip == 0)
+              {
+                curr_frame = xframe;
+                cs[cs.size () - 1].m_prev = curr_frame;
+
+                symbol_table::set_scope_and_context (elt.m_scope, elt.m_context);
 
-      const stack_frame& elt = cs[xframe];
+                if (verbose)
+                  {
+                    std::ostringstream buf;
 
-      octave_function *f = elt.m_fcn;
+                    if (f)
+                      buf << "stopped in " << elt.fcn_name ()
+                          << " at line " << elt.m_line
+                          << " [" << elt.fcn_file_name () << "] "
+                          << std::endl;
+                    else
+                      buf << "at top level" << std::endl;
 
-      if (elt.m_scope == cs[0].m_scope || (f && f->is_user_code ()))
-        {
-          if (! skipped)
-            // We found the current user code frame, so skip it.
-            skipped = true;
-          else
-            {
-              // We found the caller user code frame.
-              stack_frame tmp (elt);
-              tmp.m_prev = curr_frame;
+                    octave_stdout << buf.str ();
+                  }
+
+                retval = true;
+                break;
+              }
+          }
+        else if (incr == 0)  // Break out of infinite loop by choosing an incr.
+          incr = -1;
+
+        // There is no need to set scope and context here.  That will
+        // happen when the dbup/dbdown/keyboard frame is popped and we
+        // jump to the new "prev" frame set above.
+      }
 
-              curr_frame = cs.size ();
+    return retval;
+  }
+
+  void
+  call_stack::do_goto_caller_frame (void)
+  {
+    size_t xframe = curr_frame;
 
-              cs.push_back (tmp);
+    bool skipped = false;
 
-              symbol_table::set_scope_and_context (tmp.m_scope, tmp.m_context);
+    while (xframe != 0)
+      {
+        xframe = cs[xframe].m_prev;
+
+        const stack_frame& elt = cs[xframe];
+
+        octave_function *f = elt.m_fcn;
 
-              break;
-            }
-        }
-    }
-}
+        if (elt.m_scope == cs[0].m_scope || (f && f->is_user_code ()))
+          {
+            if (! skipped)
+              // We found the current user code frame, so skip it.
+              skipped = true;
+            else
+              {
+                // We found the caller user code frame.
+                stack_frame tmp (elt);
+                tmp.m_prev = curr_frame;
+
+                curr_frame = cs.size ();
+
+                cs.push_back (tmp);
+
+                symbol_table::set_scope_and_context (tmp.m_scope, tmp.m_context);
 
-void
-octave_call_stack::do_goto_base_frame (void)
-{
-  stack_frame tmp (cs[0]);
-  tmp.m_prev = curr_frame;
+                break;
+              }
+          }
+      }
+  }
 
-  curr_frame = cs.size ();
-
-  cs.push_back (tmp);
+  void
+  call_stack::do_goto_base_frame (void)
+  {
+    stack_frame tmp (cs[0]);
+    tmp.m_prev = curr_frame;
 
-  symbol_table::set_scope_and_context (tmp.m_scope, tmp.m_context);
+    curr_frame = cs.size ();
+
+    cs.push_back (tmp);
+
+    symbol_table::set_scope_and_context (tmp.m_scope, tmp.m_context);
+  }
 }
-
diff --git a/libinterp/corefcn/call-stack.h b/libinterp/corefcn/call-stack.h
--- a/libinterp/corefcn/call-stack.h
+++ b/libinterp/corefcn/call-stack.h
@@ -31,449 +31,460 @@ along with Octave; see the file COPYING.
 class octave_function;
 class octave_user_code;
 class octave_user_script;
 
 #include "input.h"
 #include "oct-map.h"
 #include "symtab.h"
 
-class
-OCTINTERP_API
-octave_call_stack
+namespace octave
 {
-protected:
+  class
+  OCTINTERP_API
+  call_stack
+  {
+  protected:
 
-  octave_call_stack (void) : cs (), curr_frame (0) { }
+    call_stack (void) : cs (), curr_frame (0) { }
 
-public:
-
-  class stack_frame
-  {
   public:
 
-    friend class octave_call_stack;
+    class stack_frame
+    {
+    public:
+
+      friend class call_stack;
+
+      stack_frame (octave_function *fcn = 0, symbol_table::scope_id scope = 0,
+                   symbol_table::context_id context = 0, size_t prev = 0)
+        : m_fcn (fcn), m_line (-1), m_column (-1), m_scope (scope),
+          m_context (context), m_prev (prev)
+      { }
+
+      stack_frame (const stack_frame& elt)
+        : m_fcn (elt.m_fcn), m_line (elt.m_line), m_column (elt.m_column),
+          m_scope (elt.m_scope), m_context (elt.m_context), m_prev (elt.m_prev)
+      { }
+
+      int line (void) const { return m_line; }
+
+      int column (void) const { return m_column; }
+
+      std::string fcn_file_name (void) const;
+
+      std::string fcn_name (bool print_subfn = true) const;
+
+      bool operator == (const stack_frame &rhs) const;
+
+    private:
+
+      octave_function *m_fcn;
+      int m_line;
+      int m_column;
+      symbol_table::scope_id m_scope;
+      symbol_table::context_id m_context;
+      size_t m_prev;
+    };
+
+    typedef std::deque<stack_frame>::iterator iterator;
+    typedef std::deque<stack_frame>::const_iterator const_iterator;
+
+    typedef std::deque<stack_frame>::reverse_iterator reverse_iterator;
+    typedef std::deque<stack_frame>::const_reverse_iterator const_reverse_iterator;
+
+    static void create_instance (void);
+
+    static bool instance_ok (void)
+    {
+      bool retval = true;
+
+      if (! instance)
+        create_instance ();
+
+      if (! instance)
+        error ("unable to create call stack object!");
+
+      return retval;
+    }
+
+    // Current function (top of stack).
+    static octave_function *current (void)
+    {
+      return instance_ok () ? instance->do_current () : 0;
+    }
 
-    stack_frame (octave_function *fcn = 0, symbol_table::scope_id scope = 0,
-                 symbol_table::context_id context = 0, size_t prev = 0)
-      : m_fcn (fcn), m_line (-1), m_column (-1), m_scope (scope),
-        m_context (context), m_prev (prev)
-    { }
+    // Current line in current function.
+    static int current_line (void)
+    {
+      return instance_ok () ? instance->do_current_line () : -1;
+    }
+
+    // Current column in current function.
+    static int current_column (void)
+    {
+      return instance_ok () ? instance->do_current_column () : -1;
+    }
+
+    // Caller function, may be built-in.
+    static octave_function *caller (void)
+    {
+      return instance_ok () ? instance->do_caller () : 0;
+    }
+
+    static size_t current_frame (void)
+    {
+      return instance_ok () ? instance->do_current_frame () : 0;
+    }
+
+    static size_t size (void)
+    {
+      return instance_ok () ? instance->do_size () : 0;
+    }
+
+    static size_t num_user_code_frames (octave_idx_type& curr_user_frame)
+    {
+      return instance_ok ()
+        ? instance->do_num_user_code_frames (curr_user_frame) : 0;
+    }
+
+    static symbol_table::scope_id current_scope (void)
+    {
+      return instance_ok () ? instance->do_current_scope () : 0;
+    }
+
+    static symbol_table::context_id current_context (void)
+    {
+      return instance_ok () ? instance->do_current_context () : 0;
+    }
+
+#if 0
+    static stack_frame frame (size_t idx)
+    {
+      return instance_ok () ? instance->do_frame (idx) : stack_frame ();
+    }
+#endif
+
+    // Function at location N on the call stack (N == 0 is current), may
+    // be built-in.
+    static octave_function *element (size_t n)
+    {
+      return instance_ok () ? instance->do_element (n) : 0;
+    }
+
+    // User code caller.
+    static octave_user_code *caller_user_code (size_t nskip = 0)
+    {
+      return instance_ok () ? instance->do_caller_user_code (nskip) : 0;
+    }
+
+    // Line in user code caller.
+    static int caller_user_code_line (void)
+    {
+      return instance_ok () ? instance->do_caller_user_code_line () : -1;
+    }
 
-    stack_frame (const stack_frame& elt)
-      : m_fcn (elt.m_fcn), m_line (elt.m_line), m_column (elt.m_column),
-        m_scope (elt.m_scope), m_context (elt.m_context), m_prev (elt.m_prev)
-    { }
+    // Column in user code caller.
+    static int caller_user_code_column (void)
+    {
+      return instance_ok () ? instance->do_caller_user_code_column () : -1;
+    }
+
+    // Current function that we are debugging.
+    static octave_user_code *debug_user_code (void)
+    {
+      return instance_ok () ? instance->do_debug_user_code () : 0;
+    }
+
+    // Line number in current function that we are debugging.
+    static int debug_user_code_line (void)
+    {
+      return instance_ok () ? instance->do_debug_user_code_line () : 0;
+    }
+
+    // Column number in current function that we are debugging.
+    static int debug_user_code_column (void)
+    {
+      return instance_ok () ? instance->do_debug_user_code_column () : 0;
+    }
+
+    // Return TRUE if all elements on the call stack are scripts.
+    static bool all_scripts (void)
+    {
+      return instance_ok () ? instance->do_all_scripts () : false;
+    }
 
-    int line (void) const { return m_line; }
+    static void
+    push (octave_function *f,
+          symbol_table::scope_id scope = symbol_table::current_scope (),
+          symbol_table::context_id context = symbol_table::current_context ())
+    {
+      if (instance_ok ())
+        instance->do_push (f, scope, context);
+    }
+
+    static void
+    push (symbol_table::scope_id scope = symbol_table::current_scope (),
+          symbol_table::context_id context = symbol_table::current_context ())
+    {
+      if (instance_ok ())
+        instance->do_push (0, scope, context);
+    }
+
+    static void set_location (int l, int c)
+    {
+      if (instance_ok ())
+        instance->do_set_location (l, c);
+    }
+
+    static void set_line (int l)
+    {
+      if (instance_ok ())
+        instance->do_set_line (l);
+    }
+
+    static void set_column (int c)
+    {
+      if (instance_ok ())
+        instance->do_set_column (c);
+    }
+
+    static bool goto_frame (size_t n = 0, bool verbose = false)
+    {
+      return instance_ok () ? instance->do_goto_frame (n, verbose) : false;
+    }
 
-    int column (void) const { return m_column; }
+    static void restore_frame (size_t n)
+    {
+      goto_frame (n);
+    }
+
+    static bool goto_frame_relative (int n, bool verbose = false)
+    {
+      return instance_ok ()
+        ? instance->do_goto_frame_relative (n, verbose) : false;
+    }
 
-    std::string fcn_file_name (void) const;
+    static void goto_caller_frame (void)
+    {
+      if (instance_ok ())
+        instance->do_goto_caller_frame ();
+    }
+
+    static void goto_base_frame (void)
+    {
+      if (instance_ok ())
+        instance->do_goto_base_frame ();
+    }
+
+    static octave_map backtrace (size_t nskip = 0)
+    {
+      octave_idx_type curr_user_frame = -1;
+
+      return instance_ok ()
+        ? instance->do_backtrace (nskip, curr_user_frame, true)
+        : octave_map ();
+    }
 
-    std::string fcn_name (bool print_subfn = true) const;
+    static octave_map backtrace (size_t nskip, octave_idx_type& curr_user_frame,
+                                 bool print_subfn = true)
+    {
+      return instance_ok ()
+        ? instance->do_backtrace (nskip, curr_user_frame, print_subfn)
+        : octave_map ();
+    }
+
+    static std::list<call_stack::stack_frame>
+    backtrace_frames (size_t nskip = 0)
+    {
+      octave_idx_type curr_user_frame = -1;
+
+      return instance_ok ()
+        ? instance->do_backtrace_frames (nskip, curr_user_frame)
+        : std::list<call_stack::stack_frame> ();
+    }
 
-    bool operator == (const stack_frame &rhs) const;
+    static std::list<call_stack::stack_frame>
+    backtrace_frames (size_t nskip, octave_idx_type& curr_user_frame)
+    {
+      return instance_ok ()
+        ? instance->do_backtrace_frames (nskip, curr_user_frame)
+        : std::list<call_stack::stack_frame> ();
+    }
+
+    static octave_map empty_backtrace (void);
+
+    static void pop (void)
+    {
+      if (instance_ok ())
+        instance->do_pop ();
+    }
+
+    static void clear (void)
+    {
+      if (instance_ok ())
+        instance->do_clear ();
+    }
 
   private:
 
-    octave_function *m_fcn;
-    int m_line;
-    int m_column;
-    symbol_table::scope_id m_scope;
-    symbol_table::context_id m_context;
-    size_t m_prev;
-  };
+    // The current call stack.
+    std::deque<stack_frame> cs;
 
-  typedef std::deque<stack_frame>::iterator iterator;
-  typedef std::deque<stack_frame>::const_iterator const_iterator;
+    size_t curr_frame;
 
-  typedef std::deque<stack_frame>::reverse_iterator reverse_iterator;
-  typedef std::deque<stack_frame>::const_reverse_iterator const_reverse_iterator;
+    static call_stack *instance;
 
-  static void create_instance (void);
+    static void cleanup_instance (void) { delete instance; instance = 0; }
 
-  static bool instance_ok (void)
-  {
-    bool retval = true;
+    int do_current_line (void) const;
 
-    if (! instance)
-      create_instance ();
+    int do_current_column (void) const;
 
-    if (! instance)
-      error ("unable to create call stack object!");
-
-    return retval;
-  }
-
-  // Current function (top of stack).
-  static octave_function *current (void)
-  {
-    return instance_ok () ? instance->do_current () : 0;
-  }
+    octave_function *do_caller (void) const
+    {
+      return curr_frame > 1 ? cs[curr_frame-1].m_fcn : cs[0].m_fcn;
+    }
 
-  // Current line in current function.
-  static int current_line (void)
-  {
-    return instance_ok () ? instance->do_current_line () : -1;
-  }
+    size_t do_current_frame (void) { return curr_frame; }
 
-  // Current column in current function.
-  static int current_column (void)
-  {
-    return instance_ok () ? instance->do_current_column () : -1;
-  }
+    size_t do_size (void) { return cs.size (); }
 
-  // Caller function, may be built-in.
-  static octave_function *caller (void)
-  {
-    return instance_ok () ? instance->do_caller () : 0;
-  }
+    size_t do_num_user_code_frames (octave_idx_type& curr_user_frame) const;
 
-  static size_t current_frame (void)
-  {
-    return instance_ok () ? instance->do_current_frame () : 0;
-  }
-
-  static size_t size (void)
-  {
-    return instance_ok () ? instance->do_size () : 0;
-  }
+    symbol_table::scope_id do_current_scope (void) const
+    {
+      return curr_frame > 0 && curr_frame < cs.size ()
+                                            ? cs[curr_frame].m_scope : 0;
+    }
 
-  static size_t num_user_code_frames (octave_idx_type& curr_user_frame)
-  {
-    return instance_ok ()
-           ? instance->do_num_user_code_frames (curr_user_frame) : 0;
-  }
-
-  static symbol_table::scope_id current_scope (void)
-  {
-    return instance_ok () ? instance->do_current_scope () : 0;
-  }
-
-  static symbol_table::context_id current_context (void)
-  {
-    return instance_ok () ? instance->do_current_context () : 0;
-  }
+    symbol_table::context_id do_current_context (void) const
+    {
+      return curr_frame > 0 && curr_frame < cs.size ()
+                                            ? cs[curr_frame].m_context : 0;
+    }
 
 #if 0
-  static stack_frame frame (size_t idx)
-  {
-    return instance_ok () ? instance->do_frame (idx) : stack_frame ();
-  }
+    const stack_frame& do_frame (size_t idx)
+    {
+      static stack_frame foobar;
+
+      return idx < cs.size () ? cs[idx] : foobar;
+    }
 #endif
 
-  // Function at location N on the call stack (N == 0 is current), may
-  // be built-in.
-  static octave_function *element (size_t n)
-  {
-    return instance_ok () ? instance->do_element (n) : 0;
-  }
-
-  // User code caller.
-  static octave_user_code *caller_user_code (size_t nskip = 0)
-  {
-    return instance_ok () ? instance->do_caller_user_code (nskip) : 0;
-  }
+    octave_function *do_element (size_t n)
+    {
+      octave_function *retval = 0;
 
-  // Line in user code caller.
-  static int caller_user_code_line (void)
-  {
-    return instance_ok () ? instance->do_caller_user_code_line () : -1;
-  }
-
-  // Column in user code caller.
-  static int caller_user_code_column (void)
-  {
-    return instance_ok () ? instance->do_caller_user_code_column () : -1;
-  }
-
-  // Current function that we are debugging.
-  static octave_user_code *debug_user_code (void)
-  {
-    return instance_ok () ? instance->do_debug_user_code () : 0;
-  }
+      if (cs.size () > n)
+        {
+          stack_frame& elt = cs[n];
+          retval = elt.m_fcn;
+        }
 
-  // Line number in current function that we are debugging.
-  static int debug_user_code_line (void)
-  {
-    return instance_ok () ? instance->do_debug_user_code_line () : 0;
-  }
-
-  // Column number in current function that we are debugging.
-  static int debug_user_code_column (void)
-  {
-    return instance_ok () ? instance->do_debug_user_code_column () : 0;
-  }
-
-  // Return TRUE if all elements on the call stack are scripts.
-  static bool all_scripts (void)
-  {
-    return instance_ok () ? instance->do_all_scripts () : false;
-  }
+      return retval;
+    }
 
-  static void
-  push (octave_function *f,
-        symbol_table::scope_id scope = symbol_table::current_scope (),
-        symbol_table::context_id context = symbol_table::current_context ())
-  {
-    if (instance_ok ())
-      instance->do_push (f, scope, context);
-  }
+    octave_user_code *do_caller_user_code (size_t nskip) const;
+    int do_caller_user_code_line (void) const;
+    int do_caller_user_code_column (void) const;
 
-  static void
-  push (symbol_table::scope_id scope = symbol_table::current_scope (),
-        symbol_table::context_id context = symbol_table::current_context ())
-  {
-    if (instance_ok ())
-      instance->do_push (0, scope, context);
-  }
+    octave_user_code *do_debug_user_code (void) const;
+    int do_debug_user_code_line (void) const;
+    int do_debug_user_code_column (void) const;
 
-  static void set_location (int l, int c)
-  {
-    if (instance_ok ())
-      instance->do_set_location (l, c);
-  }
+    bool do_all_scripts (void) const;
 
-  static void set_line (int l)
-  {
-    if (instance_ok ())
-      instance->do_set_line (l);
-  }
-
-  static void set_column (int c)
-  {
-    if (instance_ok ())
-      instance->do_set_column (c);
-  }
-
-  static bool goto_frame (size_t n = 0, bool verbose = false)
-  {
-    return instance_ok () ? instance->do_goto_frame (n, verbose) : false;
-  }
+    void do_push (octave_function *fcn, symbol_table::scope_id scope,
+                  symbol_table::context_id context)
+    {
+      size_t prev_frame = curr_frame;
+      curr_frame = cs.size ();
+      cs.push_back (stack_frame (fcn, scope, context, prev_frame));
+      symbol_table::set_scope_and_context (scope, context);
+    }
 
-  static void restore_frame (size_t n)
-  {
-    goto_frame (n);
-  }
-
-  static bool goto_frame_relative (int n, bool verbose = false)
-  {
-    return instance_ok ()
-           ? instance->do_goto_frame_relative (n, verbose) : false;
-  }
-
-  static void goto_caller_frame (void)
-  {
-    if (instance_ok ())
-      instance->do_goto_caller_frame ();
-  }
-
-  static void goto_base_frame (void)
-  {
-    if (instance_ok ())
-      instance->do_goto_base_frame ();
-  }
+    octave_function *do_current (void) const
+    {
+      octave_function *retval = 0;
 
-  static octave_map backtrace (size_t nskip = 0)
-  {
-    octave_idx_type curr_user_frame = -1;
+      if (! cs.empty ())
+        {
+          const stack_frame& elt = cs[curr_frame];
+          retval = elt.m_fcn;
+        }
 
-    return instance_ok ()
-           ? instance->do_backtrace (nskip, curr_user_frame, true)
-           : octave_map ();
-  }
-
-  static octave_map backtrace (size_t nskip, octave_idx_type& curr_user_frame,
-                               bool print_subfn = true)
-  {
-    return instance_ok ()
-           ? instance->do_backtrace (nskip, curr_user_frame, print_subfn)
-           : octave_map ();
-  }
+      return retval;
+    }
 
-  static std::list<octave_call_stack::stack_frame>
-  backtrace_frames (size_t nskip = 0)
-  {
-    octave_idx_type curr_user_frame = -1;
-
-    return instance_ok ()
-           ? instance->do_backtrace_frames (nskip, curr_user_frame)
-           : std::list<octave_call_stack::stack_frame> ();
-  }
+    void do_set_location (int l, int c)
+    {
+      if (! cs.empty ())
+        {
+          stack_frame& elt = cs.back ();
 
-  static std::list<octave_call_stack::stack_frame>
-  backtrace_frames (size_t nskip, octave_idx_type& curr_user_frame)
-  {
-    return instance_ok ()
-           ? instance->do_backtrace_frames (nskip, curr_user_frame)
-           : std::list<octave_call_stack::stack_frame> ();
-  }
-
-  static octave_map empty_backtrace (void);
-
-  static void pop (void)
-  {
-    if (instance_ok ())
-      instance->do_pop ();
-  }
+          elt.m_line = l;
+          elt.m_column = c;
+        }
+    }
 
-  static void clear (void)
-  {
-    if (instance_ok ())
-      instance->do_clear ();
-  }
-
-private:
-
-  // The current call stack.
-  std::deque<stack_frame> cs;
-
-  size_t curr_frame;
-
-  static octave_call_stack *instance;
-
-  static void cleanup_instance (void) { delete instance; instance = 0; }
-
-  int do_current_line (void) const;
+    void do_set_line (int l)
+    {
+      if (! cs.empty ())
+        {
+          stack_frame& elt = cs.back ();
 
-  int do_current_column (void) const;
-
-  octave_function *do_caller (void) const
-  {
-    return curr_frame > 1 ? cs[curr_frame-1].m_fcn : cs[0].m_fcn;
-  }
-
-  size_t do_current_frame (void) { return curr_frame; }
-
-  size_t do_size (void) { return cs.size (); }
-
-  size_t do_num_user_code_frames (octave_idx_type& curr_user_frame) const;
-
-  symbol_table::scope_id do_current_scope (void) const
-  {
-    return curr_frame > 0 && curr_frame < cs.size ()
-           ? cs[curr_frame].m_scope : 0;
-  }
+          elt.m_line = l;
+        }
+    }
 
-  symbol_table::context_id do_current_context (void) const
-  {
-    return curr_frame > 0 && curr_frame < cs.size ()
-           ? cs[curr_frame].m_context : 0;
-  }
-
-#if 0
-  const stack_frame& do_frame (size_t idx)
-  {
-    static stack_frame foobar;
-
-    return idx < cs.size () ? cs[idx] : foobar;
-  }
-#endif
-
-  octave_function *do_element (size_t n)
-  {
-    octave_function *retval = 0;
+    void do_set_column (int c)
+    {
+      if (! cs.empty ())
+        {
+          stack_frame& elt = cs.back ();
 
-    if (cs.size () > n)
-      {
-        stack_frame& elt = cs[n];
-        retval = elt.m_fcn;
-      }
-
-    return retval;
-  }
+          elt.m_column = c;
+        }
+    }
 
-  octave_user_code *do_caller_user_code (size_t nskip) const;
-  int do_caller_user_code_line (void) const;
-  int do_caller_user_code_column (void) const;
+    std::list<call_stack::stack_frame>
+    do_backtrace_frames (size_t nskip, octave_idx_type& curr_user_frame) const;
 
-  octave_user_code *do_debug_user_code (void) const;
-  int do_debug_user_code_line (void) const;
-  int do_debug_user_code_column (void) const;
-
-  bool do_all_scripts (void) const;
+    octave_map do_backtrace (size_t nskip,
+                             octave_idx_type& curr_user_frame,
+                             bool print_subfn) const;
 
-  void do_push (octave_function *fcn, symbol_table::scope_id scope,
-                symbol_table::context_id context)
-  {
-    size_t prev_frame = curr_frame;
-    curr_frame = cs.size ();
-    cs.push_back (stack_frame (fcn, scope, context, prev_frame));
-    symbol_table::set_scope_and_context (scope, context);
-  }
+    bool do_goto_frame (size_t n, bool verbose);
 
-  octave_function *do_current (void) const
-  {
-    octave_function *retval = 0;
-
-    if (! cs.empty ())
-      {
-        const stack_frame& elt = cs[curr_frame];
-        retval = elt.m_fcn;
-      }
+    bool do_goto_frame_relative (int n, bool verbose);
 
-    return retval;
-  }
-
-  void do_set_location (int l, int c)
-  {
-    if (! cs.empty ())
-      {
-        stack_frame& elt = cs.back ();
+    void do_goto_caller_frame (void);
 
-        elt.m_line = l;
-        elt.m_column = c;
-      }
-  }
-
-  void do_set_line (int l)
-  {
-    if (! cs.empty ())
-      {
-        stack_frame& elt = cs.back ();
+    void do_goto_base_frame (void);
 
-        elt.m_line = l;
-      }
-  }
-
-  void do_set_column (int c)
-  {
-    if (! cs.empty ())
-      {
-        stack_frame& elt = cs.back ();
-
-        elt.m_column = c;
-      }
-  }
-
-  std::list<octave_call_stack::stack_frame>
-  do_backtrace_frames (size_t nskip, octave_idx_type& curr_user_frame) const;
-
-  octave_map do_backtrace (size_t nskip,
-                           octave_idx_type& curr_user_frame,
-                           bool print_subfn) const;
+    void do_pop (void)
+    {
+      if (cs.size () > 1)
+        {
+          const stack_frame& elt = cs.back ();
+          curr_frame = elt.m_prev;
+          cs.pop_back ();
+          const stack_frame& new_elt = cs[curr_frame];
+          symbol_table::set_scope_and_context (new_elt.m_scope,
+                                               new_elt.m_context);
+        }
+    }
 
-  bool do_goto_frame (size_t n, bool verbose);
-
-  bool do_goto_frame_relative (int n, bool verbose);
-
-  void do_goto_caller_frame (void);
-
-  void do_goto_base_frame (void);
+    void do_clear (void) { cs.clear (); }
+  };
+}
 
-  void do_pop (void)
-  {
-    if (cs.size () > 1)
-      {
-        const stack_frame& elt = cs.back ();
-        curr_frame = elt.m_prev;
-        cs.pop_back ();
-        const stack_frame& new_elt = cs[curr_frame];
-        symbol_table::set_scope_and_context (new_elt.m_scope, new_elt.m_context);
-      }
-  }
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
-  void do_clear (void) { cs.clear (); }
-};
+OCTAVE_DEPRECATED ("use 'octave::call_stack' instead")
+typedef octave::call_stack octave_call_stack;
 
 #endif
 
+#endif
+
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -177,17 +177,17 @@ get_file_line (const std::string& fname,
 // current call stack.
 
 static octave_user_code *
 get_user_code (const std::string& fname = "")
 {
   octave_user_code *dbg_fcn = 0;
 
   if (fname.empty ())
-    dbg_fcn = octave_call_stack::debug_user_code ();
+    dbg_fcn = octave::call_stack::debug_user_code ();
   else
     {
       std::string name = fname;
 
       if (octave::sys::file_ops::dir_sep_char () != '/' && name[0] == '@')
         {
           int len = name.length () - 1;         // -1: can't have trailing '/'
           for (int i = 2; i < len; i++)         //  2: can't have @/method
@@ -1565,17 +1565,17 @@ is stopped.
   if (! dbg_fcn)
     {
       octave_stdout << "stopped at top level" << std::endl;
       return ovl ();
     }
 
   octave_stdout << "stopped in " << dbg_fcn->name () << " at ";
 
-  int l = octave_call_stack::debug_user_code_line ();
+  int l = octave::call_stack::debug_user_code_line ();
 
   if (l > 0)
     {
       octave_stdout << "line " << l;
 
       std::string file_name = dbg_fcn->fcn_file_name ();
 
       if (! file_name.empty ())
@@ -1814,17 +1814,17 @@ If unspecified @var{n} defaults to 10 (+
   std::string name = dbg_fcn->fcn_file_name ();
 
   if (name.empty ())
     {
       have_file = false;
       name = dbg_fcn->name ();
     }
 
-  int l = octave_call_stack::debug_user_code_line ();
+  int l = octave::call_stack::debug_user_code_line ();
 
   if (l > 0)
     {
       if (have_file)
         {
           int l_min = std::max (l - n/2, 0);
           int l_max = l + n/2;
           do_dbtype (octave_stdout, name, l_min, l-1);
@@ -1887,17 +1887,17 @@ do_dbstack (const octave_value_list& arg
         }
 
       if (n > 0)
         nskip = n;
     }
 
   if (nargout == 0)
     {
-      octave_map stk = octave_call_stack::backtrace (nskip, curr_frame);
+      octave_map stk = octave::call_stack::backtrace (nskip, curr_frame);
       octave_idx_type nframes_to_display = stk.numel ();
 
       if (nframes_to_display > 0)
         {
           octave_preserve_stream_state stream_state (os);
 
           os << "stopped in:\n\n";
 
@@ -1933,17 +1933,17 @@ do_dbstack (const octave_value_list& arg
             }
 
           if (show_top_level)
             os << "  --> top level" << std::endl;
         }
     }
   else
     {
-      octave_map stk = octave_call_stack::backtrace (nskip, curr_frame, false);
+      octave_map stk = octave::call_stack::backtrace (nskip, curr_frame, false);
 
       retval = ovl (stk, curr_frame < 0 ? 1 : curr_frame + 1);
     }
 
   return retval;
 }
 
 // A function that can be easily called from a debugger print the Octave stack.
@@ -2021,17 +2021,17 @@ do_dbupdown (const octave_value_list& ar
         }
       else
         n = args(0).int_value ();
     }
 
   if (who == "dbup")
     n = -n;
 
-  if (! octave_call_stack::goto_frame_relative (n, true))
+  if (! octave::call_stack::goto_frame_relative (n, true))
     error ("%s: invalid stack frame", who.c_str ());
 }
 
 DEFUN (dbup, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {} dbup
 @deftypefnx {} {} dbup @var{n}
 In debugging mode, move up the execution stack @var{n} frames.
diff --git a/libinterp/corefcn/defun.cc b/libinterp/corefcn/defun.cc
--- a/libinterp/corefcn/defun.cc
+++ b/libinterp/corefcn/defun.cc
@@ -46,17 +46,17 @@ along with Octave; see the file COPYING.
 #include "interpreter.h"
 #include "variables.h"
 #include "parse.h"
 
 // Print the usage part of the doc string of FCN (user-defined or DEFUN).
 void
 print_usage (void)
 {
-  const octave_function *cur = octave_call_stack::current ();
+  const octave_function *cur = octave::call_stack::current ();
   if (cur)
     print_usage (cur->name ());
   else
     error ("print_usage: invalid function");
 }
 
 void
 print_usage (const std::string& name)
@@ -130,17 +130,17 @@ install_builtin_dispatch (const std::str
   symbol_table::install_built_in_dispatch (name, klass);
 }
 
 octave::dynamic_library
 get_current_shlib (void)
 {
   octave::dynamic_library retval;
 
-  octave_function *curr_fcn = octave_call_stack::current ();
+  octave_function *curr_fcn = octave::call_stack::current ();
   if (curr_fcn)
     {
       if (curr_fcn->is_dld_function ())
         {
           octave_dld_function *dld
             = dynamic_cast<octave_dld_function *> (curr_fcn);
           retval = dld->get_shlib ();
         }
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -137,17 +137,17 @@ initialize_warning_options (const std::s
   initw.setfield ("state", state);
 
   warning_options = initw;
 }
 
 static octave_map
 initialize_last_error_stack (void)
 {
-  return octave_call_stack::empty_backtrace ();
+  return octave::call_stack::empty_backtrace ();
 }
 
 static void
 verror (bool save_last_error, std::ostream& os,
         const char *name, const char *id, const char *fmt, va_list args,
         bool with_cfn = false)
 {
   if (discard_error_messages && ! Vdebug_on_caught)
@@ -182,17 +182,17 @@ verror (bool save_last_error, std::ostre
     }
 
   // If with_fcn is specified, we'll attempt to prefix the message with the name
   // of the current executing function.  But we'll do so only if:
   // 1. the name is not empty (anonymous function)
   // 2. it is not already there (including the following colon)
   if (with_cfn)
     {
-      octave_function *curfcn = octave_call_stack::current ();
+      octave_function *curfcn = octave::call_stack::current ();
       if (curfcn)
         {
           std::string cfn = curfcn->name ();
           if (! cfn.empty ())
             {
               cfn += ':';
               if (cfn.length () > base_msg.length ()
                   || base_msg.compare (0, cfn.length (), cfn) != 0)
@@ -207,23 +207,23 @@ verror (bool save_last_error, std::ostre
 
   if (save_last_error)
     {
       // This is the first error in a possible series.
 
       Vlast_error_id = id;
       Vlast_error_message = base_msg;
 
-      octave_user_code *fcn = octave_call_stack::caller_user_code ();
+      octave_user_code *fcn = octave::call_stack::caller_user_code ();
 
       if (fcn)
         {
           octave_idx_type curr_frame = -1;
 
-          Vlast_error_stack = octave_call_stack::backtrace (0, curr_frame);
+          Vlast_error_stack = octave::call_stack::backtrace (0, curr_frame);
         }
       else
         Vlast_error_stack = initialize_last_error_stack ();
     }
 
   if (! buffer_error_messages || Vdebug_on_caught)
     {
       octave_diary << msg_string;
@@ -302,18 +302,18 @@ pr_where (std::ostream& os, const char *
       else
         pr_where_1 (os, "    %s\n", fcn_name.c_str ());
     }
 }
 
 static void
 pr_where (std::ostream& os, const char *who)
 {
-  std::list<octave_call_stack::stack_frame> call_stack_frames
-    = octave_call_stack::backtrace_frames ();
+  std::list<octave::call_stack::stack_frame> call_stack_frames
+    = octave::call_stack::backtrace_frames ();
 
   // Print the error message only if it is different from the previous one;
   // Makes the output more concise and readable.
   call_stack_frames.unique ();
 
   std::list<error_stack_frame> frames;
   for (const auto& frm : call_stack_frames)
     {
@@ -346,25 +346,25 @@ make_execution_exception (const char *wh
 static void
 maybe_enter_debugger (octave::execution_exception& e,
                       bool show_stack_trace = false)
 {
   if ((octave::application::interactive ()
        || octave::application::forced_interactive ())
       && ((Vdebug_on_error && bp_table::debug_on_err (last_error_id ()))
           || (Vdebug_on_caught && bp_table::debug_on_caught (last_error_id ())))
-      && octave_call_stack::caller_user_code ())
+      && octave::call_stack::caller_user_code ())
     {
       octave::unwind_protect frame;
       frame.protect_var (Vdebug_on_error);
       Vdebug_on_error = false;
 
       octave::tree_evaluator::debug_mode = true;
 
-      octave::tree_evaluator::current_frame = octave_call_stack::current_frame ();
+      octave::tree_evaluator::current_frame = octave::call_stack::current_frame ();
 
       if (show_stack_trace)
         {
           std::string stack_trace = e.info ();
 
           if (! stack_trace.empty ())
             {
               std::cerr << stack_trace;
@@ -523,17 +523,17 @@ error_1 (octave::execution_exception& e,
 
                   // If format ends with newline, suppress stack trace.
                   e.set_stack_trace ();
                 }
               else
                 {
                   verror (true, os, name, id, fmt, args, with_cfn);
 
-                  bool in_user_code = octave_call_stack::caller_user_code () != 0;
+                  bool in_user_code = octave::call_stack::caller_user_code () != 0;
 
                   if (in_user_code && ! discard_error_messages)
                     show_stack_trace = true;
                 }
             }
         }
     }
   else
@@ -743,34 +743,34 @@ warning_1 (const char *id, const char *f
         {
           // Strip newline before issuing warning
           std::string tmp_fmt (fmt, fmt_len - 1);
           vwarning ("warning", id, tmp_fmt.c_str (), args);
         }
       else
         vwarning ("warning", id, fmt, args);
 
-      bool in_user_code = octave_call_stack::caller_user_code () != 0;
+      bool in_user_code = octave::call_stack::caller_user_code () != 0;
 
       if (! fmt_suppresses_backtrace && in_user_code
           && Vbacktrace_on_warning
           && ! discard_warning_messages)
         pr_where (std::cerr, "warning");
 
       if ((octave::application::interactive ()
            || octave::application::forced_interactive ())
           && Vdebug_on_warning && in_user_code && bp_table::debug_on_warn (id))
         {
           octave::unwind_protect frame;
           frame.protect_var (Vdebug_on_warning);
           Vdebug_on_warning = false;
 
           octave::tree_evaluator::debug_mode = true;
 
-          octave::tree_evaluator::current_frame = octave_call_stack::current_frame ();
+          octave::tree_evaluator::current_frame = octave::call_stack::current_frame ();
 
           do_keyboard (octave_value_list ());
         }
     }
 }
 
 void
 vwarning (const char *fmt, va_list args)
@@ -1492,20 +1492,20 @@ disable escape sequence expansion use a 
       if (arg1 == "on" || arg1 == "off" || arg1 == "error")
         {
           octave_map old_warning_options = warning_options;
 
           if (nargin == 3 && argv[3] == "local"
               && ! symbol_table::at_top_level ())
             {
               symbol_table::scope_id scope
-                = octave_call_stack::current_scope ();
+                = octave::call_stack::current_scope ();
 
               symbol_table::context_id context
-                = octave_call_stack::current_context ();
+                = octave::call_stack::current_context ();
 
               octave_scalar_map val = warning_query (arg2);
 
               octave_value curr_state = val.contents ("state");
 
               // FIXME: this might be better with a dictionary object.
 
               octave_value curr_warning_states
@@ -1937,17 +1937,17 @@ fields are set to their default values.
               Vlast_error_stack = new_err_stack;
             }
           else
             {
               // No stack field.  Fill it in with backtrace info.
               octave_idx_type curr_frame = -1;
 
               Vlast_error_stack
-                = octave_call_stack::backtrace (0, curr_frame);
+                = octave::call_stack::backtrace (0, curr_frame);
             }
         }
       else
         error ("lasterror: argument must be a structure or a string");
     }
 
   return ovl (err);
 }
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -186,17 +186,17 @@ const static string_vector keyword_names
 
 // Return a vector of all functions from this file,
 // for use in command line auto-completion.
 static string_vector
 local_functions (void)
 {
   string_vector retval;
 
-  octave_user_code *curr_fcn = octave_call_stack::caller_user_code ();
+  octave_user_code *curr_fcn = octave::call_stack::caller_user_code ();
 
   if (! curr_fcn)
     return retval;
 
   // All subfunctions are listed in the top-level function of this file.
   while (curr_fcn->is_subfunction ())
     curr_fcn = symbol_table::get_curr_fcn (curr_fcn->parent_fcn_scope ());
 
@@ -687,17 +687,17 @@ the return value is an empty cell array.
 @end deftypefn */)
 {
   if (args.length () != 0)
     print_usage ();
 
   Cell retval;
 
   // Find the main function we are in.
-  octave_user_code *parent_fcn = octave_call_stack::debug_user_code ();
+  octave_user_code *parent_fcn = octave::call_stack::debug_user_code ();
 
   if (! parent_fcn)
     return ovl (retval);
 
   // Find the subfunctions of this function.
   // 1) subfunction_names contains only valid subfunctions
   // 2) subfunctions contains both nested functions and subfunctions
   const std::list<std::string> names = parent_fcn->subfunction_names ();
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -584,35 +584,35 @@ execute_in_debugger_handler (const std::
 static void
 get_debug_input (const std::string& prompt)
 {
   octave::unwind_protect frame;
 
   bool silent = octave::tree_evaluator::quiet_breakpoint_flag;
   octave::tree_evaluator::quiet_breakpoint_flag = false;
 
-  octave_user_code *caller = octave_call_stack::caller_user_code ();
+  octave_user_code *caller = octave::call_stack::caller_user_code ();
   std::string nm;
   int curr_debug_line;
 
   bool have_file = false;
 
   if (caller)
     {
       nm = caller->fcn_file_name ();
 
       if (nm.empty ())
         nm = caller->name ();
       else
         have_file = true;
 
-      curr_debug_line = octave_call_stack::caller_user_code_line ();
+      curr_debug_line = octave::call_stack::caller_user_code_line ();
     }
   else
-    curr_debug_line = octave_call_stack::current_line ();
+    curr_debug_line = octave::call_stack::current_line ();
 
   std::ostringstream buf;
 
   if (! nm.empty ())
     {
       if (Vgud_mode)
         {
           static char ctrl_z = 'Z' & 0x1f;
@@ -938,18 +938,18 @@ do_keyboard (const octave_value_list& ar
 
   frame.add_fcn (octave::command_history::ignore_entries,
                  octave::command_history::ignoring_entries ());
 
   octave::command_history::ignore_entries (false);
 
   frame.protect_var (Vdebugging);
 
-  frame.add_fcn (octave_call_stack::restore_frame,
-                 octave_call_stack::current_frame ());
+  frame.add_fcn (octave::call_stack::restore_frame,
+                 octave::call_stack::current_frame ());
 
   // FIXME: probably we just want to print one line, not the
   // entire statement, which might span many lines...
   //
   // tree_print_code tpc (octave_stdout);
   // stmt.accept (tpc);
 
   Vdebugging = true;
@@ -982,26 +982,26 @@ If @code{keyboard} is invoked without ar
 @seealso{dbstop, dbcont, dbquit}
 @end deftypefn */)
 {
   if (args.length () > 1)
     print_usage ();
 
   octave::unwind_protect frame;
 
-  frame.add_fcn (octave_call_stack::restore_frame,
-                 octave_call_stack::current_frame ());
+  frame.add_fcn (octave::call_stack::restore_frame,
+                 octave::call_stack::current_frame ());
 
   // Skip the frame assigned to the keyboard function.
-  octave_call_stack::goto_frame_relative (0);
+  octave::call_stack::goto_frame_relative (0);
 
   octave::tree_evaluator::debug_mode = true;
   octave::tree_evaluator::quiet_breakpoint_flag = false;
 
-  octave::tree_evaluator::current_frame = octave_call_stack::current_frame ();
+  octave::tree_evaluator::current_frame = octave::call_stack::current_frame ();
 
   do_keyboard (args);
 
   return ovl ();
 }
 
 DEFUN (echo, args, ,
        doc: /* -*- texinfo -*-
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -980,18 +980,18 @@ read_mat5_binary_element (std::istream& 
             // Set up temporary scope to use for evaluating the text
             // that defines the anonymous function.
 
             symbol_table::scope_id local_scope = symbol_table::alloc_scope ();
             frame.add_fcn (symbol_table::erase_scope, local_scope);
 
             symbol_table::set_scope (local_scope);
 
-            octave_call_stack::push (local_scope, 0);
-            frame.add_fcn (octave_call_stack::pop);
+            octave::call_stack::push (local_scope, 0);
+            frame.add_fcn (octave::call_stack::pop);
 
             if (m2.nfields () > 0)
               {
                 octave_value tmp;
 
                 for (octave_map::iterator p0 = m2.begin () ;
                      p0 != m2.end (); p0++)
                   {
diff --git a/libinterp/corefcn/mex.cc b/libinterp/corefcn/mex.cc
--- a/libinterp/corefcn/mex.cc
+++ b/libinterp/corefcn/mex.cc
@@ -2110,17 +2110,17 @@ public:
 
     mxFree (fname);
   }
 
   const char *function_name (void) const
   {
     if (! fname)
       {
-        octave_function *fcn = octave_call_stack::current ();
+        octave_function *fcn = octave::call_stack::current ();
 
         if (fcn)
           {
             std::string nm = fcn->name ();
             fname = mxArray::strsave (nm.c_str ());
           }
         else
           fname = mxArray::strsave ("unknown");
@@ -3404,19 +3404,19 @@ mexGetVariable (const char *space, const
 
       if (caller || base)
         {
           // MEX files don't create a separate frame in the call stack,
           // so we are already in the "caller" frame.
 
           if (base)
             {
-              octave_call_stack::goto_base_frame ();
-
-              frame.add_fcn (octave_call_stack::pop);
+              octave::call_stack::goto_base_frame ();
+
+              frame.add_fcn (octave::call_stack::pop);
             }
 
           val = symbol_table::varval (name);
         }
       else
         mexErrMsgTxt ("mexGetVariable: symbol table does not exist");
     }
 
@@ -3464,19 +3464,19 @@ mexPutVariable (const char *space, const
 
       if (caller || base)
         {
           // MEX files don't create a separate frame in the call stack,
           // so we are already in the "caller" frame.
 
           if (base)
             {
-              octave_call_stack::goto_base_frame ();
-
-              frame.add_fcn (octave_call_stack::pop);
+              octave::call_stack::goto_base_frame ();
+
+              frame.add_fcn (octave::call_stack::pop);
             }
 
           symbol_table::assign (name, mxArray::as_octave_value (ptr));
         }
       else
         mexErrMsgTxt ("mexPutVariable: symbol table does not exist");
     }
 
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -730,17 +730,17 @@ wants_local_change (const octave_value_l
     }
 
   return retval;
 }
 
 template <typename T>
 bool try_local_protect (T& var)
 {
-  octave_user_code *curr_usr_code = octave_call_stack::caller_user_code ();
+  octave_user_code *curr_usr_code = octave::call_stack::caller_user_code ();
   octave_user_function *curr_usr_fcn = 0;
   if (curr_usr_code && curr_usr_code->is_user_function ())
     curr_usr_fcn = dynamic_cast<octave_user_function *> (curr_usr_code);
 
   if (curr_usr_fcn && curr_usr_fcn->local_protect (var))
     return true;
   else
     return false;
@@ -1657,18 +1657,18 @@ do_who (int argc, const string_vector& a
 
           // Set up temporary scope.
 
           symbol_table::scope_id tmp_scope = symbol_table::alloc_scope ();
           frame.add_fcn (symbol_table::erase_scope, tmp_scope);
 
           symbol_table::set_scope (tmp_scope);
 
-          octave_call_stack::push (tmp_scope, 0);
-          frame.add_fcn (octave_call_stack::pop);
+          octave::call_stack::push (tmp_scope, 0);
+          frame.add_fcn (octave::call_stack::pop);
 
           frame.add_fcn (symbol_table::clear_variables);
 
           feval ("load", octave_value (nm), 0);
 
           std::string newmsg = std::string ("Variables in the file ")
                                + nm + ":\n\n";
 
@@ -1779,17 +1779,17 @@ do_who (int argc, const string_vector& a
         }
     }
 
   if (return_list)
     {
       if (verbose)
         {
           std::string caller_function_name;
-          octave_function *caller = octave_call_stack::caller ();
+          octave_function *caller = octave::call_stack::caller ();
           if (caller)
             caller_function_name = caller->name ();
 
           retval = symbol_stats.map_value (caller_function_name, 1);
         }
       else
         retval = Cell (string_vector (symbol_names));
     }
@@ -1970,17 +1970,17 @@ bind_internal_variable (const std::strin
   args(0) = val;
 
   feval (fname, args, 0);
 }
 
 void
 mlock (void)
 {
-  octave_function *fcn = octave_call_stack::current ();
+  octave_function *fcn = octave::call_stack::current ();
 
   if (! fcn)
     error ("mlock: invalid use outside a function");
 
   fcn->lock ();
 }
 
 void
@@ -2020,17 +2020,17 @@ DEFUN (mlock, args, ,
 @deftypefn {} {} mlock ()
 Lock the current function into memory so that it can't be cleared.
 @seealso{munlock, mislocked, persistent}
 @end deftypefn */)
 {
   if (args.length () != 0)
     print_usage ();
 
-  octave_function *fcn = octave_call_stack::caller ();
+  octave_function *fcn = octave::call_stack::caller ();
 
   if (! fcn)
     error ("mlock: invalid use outside a function");
 
   fcn->lock ();
 
   return ovl ();
 }
@@ -2053,17 +2053,17 @@ If no function is named then unlock the 
   if (nargin == 1)
     {
       std::string name = args(0).xstring_value ("munlock: FCN must be a string");
 
       munlock (name);
     }
   else
     {
-      octave_function *fcn = octave_call_stack::caller ();
+      octave_function *fcn = octave::call_stack::caller ();
 
       if (! fcn)
         error ("munlock: invalid use outside a function");
 
       fcn->unlock ();
     }
 
   return ovl ();
@@ -2089,17 +2089,17 @@ If no function is named then return true
   if (nargin == 1)
     {
       std::string name = args(0).xstring_value ("mislocked: FCN must be a string");
 
       retval = mislocked (name);
     }
   else
     {
-      octave_function *fcn = octave_call_stack::caller ();
+      octave_function *fcn = octave::call_stack::caller ();
 
       if (! fcn)
         error ("mislocked: invalid use outside a function");
 
       retval = fcn->islocked ();
     }
 
   return retval;
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -1511,17 +1511,17 @@ make_idx_args (const std::string& type,
   m.assign ("subs", subs_field);
 
   return m;
 }
 
 bool
 called_from_builtin (void)
 {
-  octave_function *fcn = octave_call_stack::caller ();
+  octave_function *fcn = octave::call_stack::caller ();
 
   // FIXME: we probably need a better check here, or some other
   // mechanism to avoid overloaded functions when builtin is used.
   // For example, what if someone overloads the builtin function?
   // Also, are there other places where using builtin is not properly
   // avoiding dispatch?
 
   return (fcn && fcn->name () == "builtin");
diff --git a/libinterp/octave-value/ov-builtin.cc b/libinterp/octave-value/ov-builtin.cc
--- a/libinterp/octave-value/ov-builtin.cc
+++ b/libinterp/octave-value/ov-builtin.cc
@@ -106,19 +106,19 @@ octave_builtin::do_multi_index_op (int n
 {
   octave_value_list retval;
 
   if (args.has_magic_colon ())
     error ("invalid use of colon in function argument list");
 
   octave::unwind_protect frame;
 
-  octave_call_stack::push (this);
+  octave::call_stack::push (this);
 
-  frame.add_fcn (octave_call_stack::pop);
+  frame.add_fcn (octave::call_stack::pop);
 
   if (lvalue_list || curr_lvalue_list)
     {
       frame.protect_var (curr_lvalue_list);
       curr_lvalue_list = lvalue_list;
     }
 
   BEGIN_PROFILER_BLOCK (octave_builtin)
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -220,17 +220,17 @@ octave_class::unique_clone (void)
 
 std::string
 octave_class::get_current_method_class (void)
 {
   std::string retval = class_name ();
 
   if (nparents () > 0)
     {
-      octave_function *fcn = octave_call_stack::current ();
+      octave_function *fcn = octave::call_stack::current ();
 
       // Here we are just looking to see if FCN is a method or constructor
       // for any class, not specifically this one.
       if (fcn && (fcn->is_class_method () || fcn->is_class_constructor ()))
         retval = fcn->dispatch_class ();
     }
 
   return retval;
@@ -1613,17 +1613,17 @@ mxArray *
 octave_class::as_mxArray (void) const
 {
   err_wrong_type_arg ("octave_class::as_mxArray ()", type_name ());
 }
 
 bool
 octave_class::in_class_method (void)
 {
-  octave_function *fcn = octave_call_stack::current ();
+  octave_function *fcn = octave::call_stack::current ();
 
   return (fcn
           && (fcn->is_class_method ()
               || fcn->is_class_constructor ()
               || fcn->is_anonymous_function_of_class ()
               || fcn->is_private_function_of_class (class_name ()))
           && find_parent_class (fcn->dispatch_class ()));
 }
@@ -1705,17 +1705,17 @@ is derived.
   if (nargin == 1)
     // Called for class of object
     retval = args(0).class_name ();
   else
     {
       // Called as class constructor
       std::string id = args(1).xstring_value ("class: ID (class name) must be a string");
 
-      octave_function *fcn = octave_call_stack::caller ();
+      octave_function *fcn = octave::call_stack::caller ();
 
       if (! fcn)
         error ("class: invalid call from outside class constructor or method");
 
       if (! fcn->is_class_constructor (id) && ! fcn->is_class_method (id))
         error ("class: '%s' is invalid as a class name in this context",
                id.c_str ());
 
@@ -1990,17 +1990,17 @@ DEFUN (superiorto, args, ,
 When called from a class constructor, mark the object currently constructed
 as having a higher precedence than @var{class_name}.
 
 More that one such class can be specified in a single call.  This function
 may @emph{only} be called from a class constructor.
 @seealso{inferiorto}
 @end deftypefn */)
 {
-  octave_function *fcn = octave_call_stack::caller ();
+  octave_function *fcn = octave::call_stack::caller ();
   if (! fcn || ! fcn->is_class_constructor ())
     error ("superiorto: invalid call from outside class constructor");
 
   for (int i = 0; i < args.length (); i++)
     {
       std::string inf_class = args(i).xstring_value ("superiorto: CLASS_NAME must be a string");
 
       // User defined classes always have higher precedence
@@ -2023,17 +2023,17 @@ DEFUN (inferiorto, args, ,
 When called from a class constructor, mark the object currently constructed
 as having a lower precedence than @var{class_name}.
 
 More that one such class can be specified in a single call.  This function
 may @emph{only} be called from a class constructor.
 @seealso{superiorto}
 @end deftypefn */)
 {
-  octave_function *fcn = octave_call_stack::caller ();
+  octave_function *fcn = octave::call_stack::caller ();
   if (! fcn || ! fcn->is_class_constructor ())
     error ("inferiorto: invalid call from outside class constructor");
 
   for (int i = 0; i < args.length (); i++)
     {
       std::string sup_class = args(i).xstring_value ("inferiorto: CLASS_NAME must be a string");
 
       if (is_built_in_class (sup_class))
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -260,17 +260,17 @@ class_get_properties (const octave_value
   return retval;
 }
 
 static cdef_class
 get_class_context (std::string& name, bool& in_constructor)
 {
   cdef_class cls;
 
-  octave_function* fcn = octave_call_stack::current ();
+  octave_function* fcn = octave::call_stack::current ();
 
   in_constructor = false;
 
   if (fcn && (fcn->is_class_method ()
               || fcn->is_classdef_constructor ()
               || fcn->is_anonymous_function_of_class ()
               || (fcn->is_private_function ()
                   && ! fcn->dispatch_class ().empty ())))
@@ -417,17 +417,17 @@ is_dummy_method (const octave_value& fcn
     retval = true;
 
   return retval;
 }
 
 bool
 is_method_executing (const octave_value& ov, const cdef_object& obj)
 {
-  octave_function* stack_fcn = octave_call_stack::current ();
+  octave_function* stack_fcn = octave::call_stack::current ();
 
   octave_function* method_fcn = ov.function_value (true);
 
   // Does the top of the call stack match our target function?
 
   if (stack_fcn && stack_fcn == method_fcn)
     {
       octave_user_function* uf = method_fcn->user_function_value (true);
@@ -1168,17 +1168,17 @@ public:
       }
 
     return retval;
   }
 
 private:
   bool is_constructed_object (const std::string nm)
   {
-    octave_function *of = octave_call_stack::current ();
+    octave_function *of = octave::call_stack::current ();
 
     if (of->is_classdef_constructor ())
       {
         octave_user_function *uf = of->user_function_value (true);
 
         if (uf)
           {
             tree_parameter_list *ret_list = uf->return_list ();
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -432,18 +432,18 @@ octave_fcn_handle::load_ascii (std::istr
       // Set up temporary scope to use for evaluating the text that
       // defines the anonymous function.
 
       symbol_table::scope_id local_scope = symbol_table::alloc_scope ();
       frame.add_fcn (symbol_table::erase_scope, local_scope);
 
       symbol_table::set_scope (local_scope);
 
-      octave_call_stack::push (local_scope, 0);
-      frame.add_fcn (octave_call_stack::pop);
+      octave::call_stack::push (local_scope, 0);
+      frame.add_fcn (octave::call_stack::pop);
 
       octave_idx_type len = 0;
 
       if (extract_keyword (is, "length", len, true) && len >= 0)
         {
           if (len > 0)
             {
               for (octave_idx_type i = 0; i < len; i++)
@@ -615,18 +615,18 @@ octave_fcn_handle::load_binary (std::ist
       // Set up temporary scope to use for evaluating the text that
       // defines the anonymous function.
 
       symbol_table::scope_id local_scope = symbol_table::alloc_scope ();
       frame.add_fcn (symbol_table::erase_scope, local_scope);
 
       symbol_table::set_scope (local_scope);
 
-      octave_call_stack::push (local_scope, 0);
-      frame.add_fcn (octave_call_stack::pop);
+      octave::call_stack::push (local_scope, 0);
+      frame.add_fcn (octave::call_stack::pop);
 
       if (len > 0)
         {
           for (octave_idx_type i = 0; i < len; i++)
             {
               octave_value t2;
               bool dummy;
               std::string doc;
@@ -1131,18 +1131,18 @@ octave_fcn_handle::load_hdf5 (octave_hdf
       // Set up temporary scope to use for evaluating the text that
       // defines the anonymous function.
 
       symbol_table::scope_id local_scope = symbol_table::alloc_scope ();
       frame.add_fcn (symbol_table::erase_scope, local_scope);
 
       symbol_table::set_scope (local_scope);
 
-      octave_call_stack::push (local_scope, 0);
-      frame.add_fcn (octave_call_stack::pop);
+      octave::call_stack::push (local_scope, 0);
+      frame.add_fcn (octave::call_stack::pop);
 
       if (len > 0 && success)
         {
           hsize_t num_obj = 0;
 #if defined (HAVE_HDF5_18)
           data_hid = H5Gopen (group_hid, "symbol table", octave_H5P_DEFAULT);
 #else
           data_hid = H5Gopen (group_hid, "symbol table");
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -91,17 +91,17 @@ octave_fcn_inline::octave_fcn_inline (co
       if (fh)
         {
           fcn = fh->fcn_val ();
 
           octave_user_function *uf = fcn.user_function_value ();
 
           if (uf)
             {
-              octave_function *curr_fcn = octave_call_stack::current ();
+              octave_function *curr_fcn = octave::call_stack::current ();
 
               if (curr_fcn)
                 {
                   symbol_table::scope_id parent_scope
                     = curr_fcn->parent_fcn_scope ();
 
                   if (parent_scope < 0)
                     parent_scope = curr_fcn->scope ();
diff --git a/libinterp/octave-value/ov-mex-fcn.cc b/libinterp/octave-value/ov-mex-fcn.cc
--- a/libinterp/octave-value/ov-mex-fcn.cc
+++ b/libinterp/octave-value/ov-mex-fcn.cc
@@ -133,19 +133,19 @@ octave_mex_function::do_multi_index_op (
 {
   octave_value_list retval;
 
   if (args.has_magic_colon ())
     error ("invalid use of colon in function argument list");
 
   octave::unwind_protect frame;
 
-  octave_call_stack::push (this);
+  octave::call_stack::push (this);
 
-  frame.add_fcn (octave_call_stack::pop);
+  frame.add_fcn (octave::call_stack::pop);
 
   BEGIN_PROFILER_BLOCK (octave_mex_function)
 
   retval = call_mex (have_fmex, mex_fcn_ptr, args, nargout, this);
 
   END_PROFILER_BLOCK
 
   return retval;
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -132,19 +132,19 @@ octave_user_script::do_multi_index_op (i
   if (cmd_list)
     {
       frame.protect_var (call_depth);
       call_depth++;
 
       if (call_depth >= Vmax_recursion_depth)
         error ("max_recursion_depth exceeded");
 
-      octave_call_stack::push (this);
+      octave::call_stack::push (this);
 
-      frame.add_fcn (octave_call_stack::pop);
+      frame.add_fcn (octave::call_stack::pop);
 
       // Update line number even if debugging.
       frame.protect_var (Vtrack_line_num);
       Vtrack_line_num = true;
 
       frame.protect_var (octave::tree_evaluator::statement_context);
       octave::tree_evaluator::statement_context = octave::tree_evaluator::script;
 
@@ -501,21 +501,21 @@ octave_user_function::do_multi_index_op 
   if (call_depth >= Vmax_recursion_depth)
     error ("max_recursion_depth exceeded");
 
   // Save old and set current symbol table context, for
   // eval_undefined_error().
 
   int context = active_context ();
 
-  octave_call_stack::push (this, local_scope, context);
+  octave::call_stack::push (this, local_scope, context);
 
   frame.protect_var (Vtrack_line_num);
   Vtrack_line_num = true;    // update source line numbers, even if debugging
-  frame.add_fcn (octave_call_stack::pop);
+  frame.add_fcn (octave::call_stack::pop);
 
   if (call_depth > 0 && ! is_anonymous_function ())
     {
       symbol_table::push_context ();
 
       frame.add_fcn (symbol_table::pop_context);
     }
 
@@ -593,17 +593,17 @@ octave_user_function::do_multi_index_op 
       assert (cmd_list->length () == 1);
 
       tree_statement *stmt = cmd_list->front ();
 
       tree_expression *expr = stmt->expression ();
 
       if (expr)
         {
-          octave_call_stack::set_location (stmt->line (), stmt->column ());
+          octave::call_stack::set_location (stmt->line (), stmt->column ());
 
           retval = (lvalue_list
                     ? expr->rvalue (nargout, lvalue_list)
                     : expr->rvalue (nargout));
         }
     }
   else
     cmd_list->accept (*octave::current_evaluator);
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -4487,17 +4487,17 @@ not loaded anymore during the current Oc
   else
     {
       string_vector argv = args.make_argv ("autoload");
 
       std::string nm = argv[2];
 
       if (! octave::sys::env::absolute_pathname (nm))
         {
-          octave_user_code *fcn = octave_call_stack::caller_user_code ();
+          octave_user_code *fcn = octave::call_stack::caller_user_code ();
 
           bool found = false;
 
           if (fcn)
             {
               std::string fname = fcn->fcn_file_name ();
 
               if (! fname.empty ())
@@ -4589,23 +4589,23 @@ source_file (const std::string& file_nam
   source_call_depth[file_full_name]++;
 
   if (source_call_depth[file_full_name] >= Vmax_recursion_depth)
     error ("max_recursion_depth exceeded");
 
   if (! context.empty ())
     {
       if (context == "caller")
-        octave_call_stack::goto_caller_frame ();
+        octave::call_stack::goto_caller_frame ();
       else if (context == "base")
-        octave_call_stack::goto_base_frame ();
+        octave::call_stack::goto_base_frame ();
       else
         error ("source: context must be \"caller\" or \"base\"");
 
-      frame.add_fcn (octave_call_stack::pop);
+      frame.add_fcn (octave::call_stack::pop);
     }
 
   octave_function *fcn = 0;
   // Don't delete a function already in symbol_table
   bool delete_fcn = false;
 
   // Find symbol name that would be in symbol_table, if it were loaded.
   size_t dir_end = file_name.find_last_of (octave::sys::file_ops::dir_sep_chars ());
@@ -4705,17 +4705,17 @@ the filename and the extension.
 
   std::string arg;
 
   if (nargin == 1)
     arg = args(0).xstring_value ("mfilename: argument must be a string");
 
   std::string fname;
 
-  octave_user_code *fcn = octave_call_stack::caller_user_code ();
+  octave_user_code *fcn = octave::call_stack::caller_user_code ();
 
   if (fcn)
     {
       fname = fcn->fcn_file_name ();
 
       if (fname.empty ())
         fname = fcn->name ();
     }
@@ -5203,23 +5203,23 @@ may be either @qcode{"base"} or @qcode{"
   if (args.length () != 3)
     print_usage ();
 
   std::string context = args(0).xstring_value ("assignin: CONTEXT must be a string");
 
   octave::unwind_protect frame;
 
   if (context == "caller")
-    octave_call_stack::goto_caller_frame ();
+    octave::call_stack::goto_caller_frame ();
   else if (context == "base")
-    octave_call_stack::goto_base_frame ();
+    octave::call_stack::goto_base_frame ();
   else
     error ("assignin: CONTEXT must be \"caller\" or \"base\"");
 
-  frame.add_fcn (octave_call_stack::pop);
+  frame.add_fcn (octave::call_stack::pop);
 
   std::string nm = args(1).xstring_value ("assignin: VARNAME must be a string");
 
   if (valid_identifier (nm))
     {
       // Put the check here so that we don't slow down assignments
       // generally.  Any that go through Octave's parser should have
       // already been checked.
@@ -5257,23 +5257,23 @@ Like @code{eval}, except that the expres
   if (nargin < 2)
     print_usage ();
 
   std::string context = args(0).xstring_value ("evalin: CONTEXT must be a string");
 
   octave::unwind_protect frame;
 
   if (context == "caller")
-    octave_call_stack::goto_caller_frame ();
+    octave::call_stack::goto_caller_frame ();
   else if (context == "base")
-    octave_call_stack::goto_base_frame ();
+    octave::call_stack::goto_base_frame ();
   else
     error ("evalin: CONTEXT must be \"caller\" or \"base\"");
 
-  frame.add_fcn (octave_call_stack::pop);
+  frame.add_fcn (octave::call_stack::pop);
 
   if (nargin > 2)
     {
       frame.protect_var (buffer_error_messages);
       buffer_error_messages++;
     }
 
   int parse_status = 0;
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -507,17 +507,17 @@ namespace octave
   void
   tree_evaluator::visit_if_command_list (tree_if_command_list& lst)
   {
     for (tree_if_clause* tic : lst)
       {
         tree_expression *expr = tic->condition ();
 
         if (statement_context == function || statement_context == script)
-          octave_call_stack::set_location (tic->line (), tic->column ());
+          octave::call_stack::set_location (tic->line (), tic->column ());
 
         if (debug_mode && ! tic->is_else_clause ())
           do_breakpoint (tic->is_breakpoint (true));
 
         if (tic->is_else_clause () || expr->is_logically_true ("if"))
           {
             tree_statement_list *stmt_lst = tic->commands ();
 
@@ -600,17 +600,17 @@ namespace octave
   tree_evaluator::visit_return_command (tree_return_command& cmd)
   {
     if (debug_mode)
       do_breakpoint (cmd.is_breakpoint (true));
 
     // Act like dbcont.
 
     if (Vdebugging
-        && octave_call_stack::current_frame () == current_frame)
+        && octave::call_stack::current_frame () == current_frame)
       {
         Vdebugging = false;
 
         reset_debug_state ();
       }
     else if (statement_context == function || statement_context == script
              || in_loop_command)
       tree_return_command::returning = 1;
@@ -637,21 +637,21 @@ namespace octave
     if (cmd || expr)
       {
         if (statement_context == function || statement_context == script)
           {
             // Skip commands issued at a debug> prompt to avoid disturbing
             // the state of the program we are debugging.
 
             if (Vtrack_line_num)
-              octave_call_stack::set_location (stmt.line (), stmt.column ());
+              octave::call_stack::set_location (stmt.line (), stmt.column ());
 
             if ((statement_context == script
                  && ((Vecho_executing_commands & ECHO_SCRIPTS
-                      && octave_call_stack::all_scripts ())
+                      && octave::call_stack::all_scripts ())
                      || Vecho_executing_commands & ECHO_FUNCTIONS))
                 || (statement_context == function
                     && Vecho_executing_commands & ECHO_FUNCTIONS))
               stmt.echo_code ();
           }
 
         try
           {
@@ -877,20 +877,20 @@ namespace octave
   {
     octave::unwind_protect frame;
 
     frame.protect_var (octave_interrupt_state);
     octave_interrupt_state = 0;
 
     // We want to preserve the last location info for possible
     // backtracking.
-    frame.add_fcn (octave_call_stack::set_line,
-                   octave_call_stack::current_line ());
-    frame.add_fcn (octave_call_stack::set_column,
-                   octave_call_stack::current_column ());
+    frame.add_fcn (octave::call_stack::set_line,
+                   octave::call_stack::current_line ());
+    frame.add_fcn (octave::call_stack::set_column,
+                   octave::call_stack::current_column ());
 
     // Similarly, if we have seen a return or break statement, allow all
     // the cleanup code to run before returning or handling the break.
     // We don't have to worry about continue statements because they can
     // only occur in loops.
 
     frame.protect_var (tree_return_command::returning);
     tree_return_command::returning = 0;
@@ -1054,17 +1054,17 @@ namespace octave
           loop_body->accept (*this);
 
         if (quit_loop_now ())
           break;
 
         if (debug_mode)
           do_breakpoint (cmd.is_breakpoint (true));
 
-        octave_call_stack::set_location (until_line, until_column);
+        octave::call_stack::set_location (until_line, until_column);
 
         if (expr->is_logically_true ("do-until"))
           break;
       }
   }
 
   void
   tree_evaluator::do_breakpoint (tree_statement& stmt) const
@@ -1079,29 +1079,29 @@ namespace octave
     bool break_on_this_statement = false;
 
     if (octave_debug_on_interrupt_state)
       {
         break_on_this_statement = true;
 
         octave_debug_on_interrupt_state = false;
 
-        current_frame = octave_call_stack::current_frame ();
+        current_frame = octave::call_stack::current_frame ();
       }
     else if (is_breakpoint)
       {
         break_on_this_statement = true;
 
         dbstep_flag = 0;
 
-        current_frame = octave_call_stack::current_frame ();
+        current_frame = octave::call_stack::current_frame ();
       }
     else if (dbstep_flag > 0)
       {
-        if (octave_call_stack::current_frame () == current_frame)
+        if (octave::call_stack::current_frame () == current_frame)
           {
             if (dbstep_flag == 1 || is_end_of_fcn_or_script)
               {
                 // We get here if we are doing a "dbstep" or a "dbstep N" and the
                 // count has reached 1 so that we must stop and return to debug
                 // prompt.  Alternatively, "dbstep N" has been used but the end
                 // of the frame has been reached so we stop at the last line and
                 // return to prompt.
@@ -1114,47 +1114,47 @@ namespace octave
               {
                 // Executing "dbstep N".  Decrease N by one and continue.
 
                 dbstep_flag--;
               }
 
           }
         else if (dbstep_flag == 1
-                 && octave_call_stack::current_frame () < current_frame)
+                 && octave::call_stack::current_frame () < current_frame)
           {
             // We stepped out from the end of a function.
 
-            current_frame = octave_call_stack::current_frame ();
+            current_frame = octave::call_stack::current_frame ();
 
             break_on_this_statement = true;
 
             dbstep_flag = 0;
           }
       }
     else if (dbstep_flag == -1)
       {
         // We get here if we are doing a "dbstep in".
 
         break_on_this_statement = true;
 
         dbstep_flag = 0;
 
-        current_frame = octave_call_stack::current_frame ();
+        current_frame = octave::call_stack::current_frame ();
       }
     else if (dbstep_flag == -2)
       {
         // We get here if we are doing a "dbstep out".  Check for end of
         // function and whether the current frame is the same as the
         // cached value because we want to step out from the frame where
         // "dbstep out" was evaluated, not from any functions called from
         // that frame.
 
         if (is_end_of_fcn_or_script
-            && octave_call_stack::current_frame () == current_frame)
+            && octave::call_stack::current_frame () == current_frame)
           dbstep_flag = -1;
       }
 
     if (break_on_this_statement)
       do_keyboard ();
 
   }
 
diff --git a/libinterp/parse-tree/pt-fcn-handle.cc b/libinterp/parse-tree/pt-fcn-handle.cc
--- a/libinterp/parse-tree/pt-fcn-handle.cc
+++ b/libinterp/parse-tree/pt-fcn-handle.cc
@@ -104,17 +104,17 @@ tree_anon_fcn_handle::rvalue1 (int)
                            symbol_table::current_context ());
 
   octave_user_function *uf
     = new octave_user_function (new_scope,
                                 param_list ? param_list->dup (new_scope, 0) : 0,
                                 ret_list ? ret_list->dup (new_scope, 0) : 0,
                                 cmd_list ? cmd_list->dup (new_scope, 0) : 0);
 
-  octave_function *curr_fcn = octave_call_stack::current ();
+  octave_function *curr_fcn = octave::call_stack::current ();
 
   if (curr_fcn)
     {
       // FIXME: maybe it would be better to just stash curr_fcn
       // instead of individual bits of info about it?
 
       uf->stash_parent_fcn_name (curr_fcn->name ());
       uf->stash_dir_name (curr_fcn->dir_name ());
