# HG changeset patch
# User Rik <rik@octave.org>
# Date 1450378528 28800
#      Thu Dec 17 10:55:28 2015 -0800
# Node ID 69dcb58b9adafd8f817372cf6bf77644564facf0
# Parent  b6ea72a439f8932bebf520c48a055424e7b074e1
Clean up use of error() versus ::error() in stream-based code.

* oct-fstrm.cc, oct-iostrm.cc, oct-strstrm.cc: Add comments before code that is
specifically using error from stream class rather than ::error from error.h

* oct-stream.cc: Overhaul file.  Add programming note about difference between
error() and ::error() at top of file.  Put input validation first.  Cuddle
parentheses to variable when doing indexing.  Declare variables as late as
possible.  Wrap lines < 80 characters, but try to break comments into
intelligible blocks.  Avoid declaring retval when returning a value would
do just as well.

diff --git a/libinterp/corefcn/oct-fstrm.cc b/libinterp/corefcn/oct-fstrm.cc
--- a/libinterp/corefcn/oct-fstrm.cc
+++ b/libinterp/corefcn/oct-fstrm.cc
@@ -51,33 +51,38 @@ octave_fstream::octave_fstream (const st
   // Override default protection of 0664 so that umask will appear to
   // do the right thing.
 
   fs.open (nm.c_str (), arg_md, 0666);
 
 #endif
 
   if (! fs)
+    // Note: error() is inherited from octave_base_stream, not ::error().
     error (gnulib::strerror (errno));
 }
 
 // Position a stream at OFFSET relative to ORIGIN.
 
 int
 octave_fstream::seek (off_t, int)
 {
+  // Note: error() is inherited from octave_base_stream, not ::error().
+  // This error function does not halt execution so "return ..." must exist.
   error ("fseek: invalid_operation");
   return -1;
 }
 
 // Return current stream position.
 
 off_t
 octave_fstream::tell (void)
 {
+  // Note: error() is inherited from octave_base_stream, not ::error().
+  // This error function does not halt execution so "return ..." must exist.
   error ("ftell: invalid_operation");
   return -1;
 }
 
 // Return nonzero if EOF has been reached on this stream.
 
 bool
 octave_fstream::eof (void) const
diff --git a/libinterp/corefcn/oct-iostrm.cc b/libinterp/corefcn/oct-iostrm.cc
--- a/libinterp/corefcn/oct-iostrm.cc
+++ b/libinterp/corefcn/oct-iostrm.cc
@@ -52,16 +52,17 @@ octave_base_iostream::eof (void) const
 {
   invalid_operation ();
   return false;
 }
 
 void
 octave_base_iostream::invalid_operation (void) const
 {
+  // Note: use '::error()' to get error from error.h which halts operation.
   ::error ("%s: invalid operation", stream_type ());
 }
 
 // Return nonzero if EOF has been reached on this stream.
 
 bool
 octave_istream::eof (void) const
 {
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -48,16 +48,27 @@ along with Octave; see the file COPYING.
 #include "gripes.h"
 #include "input.h"
 #include "oct-stdstrm.h"
 #include "oct-stream.h"
 #include "oct-obj.h"
 #include "toplev.h"
 #include "utils.h"
 
+////////////////////////////////////////////////////////////////////////////////
+// Programming Note: There are two very different error() functions used
+// in the stream code.  When invoked with "error (...)" the member function
+// from octave_stream or octave_base_stream is called.  This function sets the
+// error state on the stream AND returns control to the caller.  The caller
+// must then return a value at the end of the function.  When invoked with
+// "::error (...)" the exception-based error function from error.h is used.
+// This function will throw an exception and not return control to the caller.
+// BE CAREFUL and invoke the correct error function!
+////////////////////////////////////////////////////////////////////////////////
+
 // Possible values for conv_err:
 //
 //   1 : not a real scalar
 //   2 : value is NaN
 //   3 : value is not an integer
 
 static int
 convert_to_valid_int (const octave_value& tc, int& conv_err)
@@ -97,31 +108,29 @@ convert_to_valid_int (const octave_value
   return retval;
 }
 
 static int
 get_size (double d, const std::string& who)
 {
   int retval = -1;
 
-  if (! lo_ieee_isnan (d))
+  if (lo_ieee_isnan (d))
+    ::error ("%s: NaN is invalid as size specification", who.c_str ());
+
+  if (xisinf (d))
+    retval = -1;
+  else
     {
-      if (! xisinf (d))
-        {
-          if (d >= 0.0)
-            retval = NINT (d);
-          else
-            ::error ("%s: negative value invalid as size specification",
-                     who.c_str ());
-        }
+      if (d >= 0.0)
+        retval = NINT (d);
       else
-        retval = -1;
+        ::error ("%s: negative value invalid as size specification",
+                 who.c_str ());
     }
-  else
-    ::error ("%s: NaN is invalid as size specification", who.c_str ());
 
   return retval;
 }
 
 static void
 get_size (const Array<double>& size, octave_idx_type& nr, octave_idx_type& nc,
           bool& one_elt_size_spec, const std::string& who)
 {
@@ -134,26 +143,26 @@ get_size (const Array<double>& size, oct
   double dnc = -1.0;
 
   octave_idx_type sz_len = size.numel ();
 
   if (sz_len == 1)
     {
       one_elt_size_spec = true;
 
-      dnr = size (0);
+      dnr = size(0);
 
       dnc = (dnr == 0.0) ? 0.0 : 1.0;
     }
   else if (sz_len == 2)
     {
-      dnr = size (0);
+      dnr = size(0);
 
       if (! xisinf (dnr))
-        dnc = size (1);
+        dnc = size(1);
       else
         ::error ("%s: invalid size specification", who.c_str ());
     }
   else
     ::error ("%s: invalid size specification", who.c_str ());
 
   nr = get_size (dnr, who);
 
@@ -931,43 +940,47 @@ octave_base_stream::clearerr (void)
 
 // Functions that are defined for all input streams (input streams
 // are those that define is).
 
 std::string
 octave_base_stream::do_gets (octave_idx_type max_len, bool& err,
                              bool strip_newline, const std::string& who)
 {
-  std::string retval;
-
   if (interactive && file_number () == 0)
     ::error ("%s: unable to read from stdin while running interactively",
              who.c_str ());
 
+  std::string retval;
+
   err = false;
 
   std::istream *isp = input_stream ();
 
-  if (isp)
+  if (! isp)
+    {
+      err = true;
+      invalid_operation (who, "reading");
+    }
+  else
     {
       std::istream& is = *isp;
 
       std::ostringstream buf;
 
       int c = 0;
       int char_count = 0;
 
       if (max_len != 0)
         {
           while (is && (c = is.get ()) != EOF)
             {
               char_count++;
 
               // Handle CRLF, CR, or LF as line ending.
-
               if (c == '\r')
                 {
                   if (! strip_newline)
                     buf << static_cast<char> (c);
 
                   c = is.get ();
 
                   if (c != EOF)
@@ -997,19 +1010,19 @@ octave_base_stream::do_gets (octave_idx_
 
               if (max_len > 0 && char_count == max_len)
                 break;
             }
         }
 
       if (! is.eof () && char_count > 0)
         {
-          // GAGME.  Matlab seems to check for EOF even if the last
-          // character in a file is a newline character.  This is NOT
-          // what the corresponding C-library functions do.
+          // GAGME.  Matlab seems to check for EOF even if the last character
+          // in a file is a newline character.  This is NOT what the
+          // corresponding C-library functions do.
           int disgusting_compatibility_hack = is.get ();
           if (! is.eof ())
             is.putback (disgusting_compatibility_hack);
         }
 
       if (is.good () || (is.eof () && char_count > 0))
         retval = buf.str ();
       else
@@ -1017,21 +1030,16 @@ octave_base_stream::do_gets (octave_idx_
           err = true;
 
           if (is.eof () && char_count == 0)
             error (who, "at end of file");
           else
             error (who, "read error");
         }
     }
-  else
-    {
-      err = true;
-      invalid_operation (who, "reading");
-    }
 
   return retval;
 }
 
 std::string
 octave_base_stream::getl (octave_idx_type max_len, bool& err,
                           const std::string& who)
 {
@@ -1043,42 +1051,42 @@ octave_base_stream::gets (octave_idx_typ
                           const std::string& who)
 {
   return do_gets (max_len, err, false, who);
 }
 
 off_t
 octave_base_stream::skipl (off_t num, bool& err, const std::string& who)
 {
+  if (interactive && file_number () == 0)
+    ::error ("%s: unable to read from stdin while running interactively",
+             who.c_str ());
+
   off_t cnt = -1;
 
-  if (interactive && file_number () == 0)
-    {
-      ::error ("%s: unable to read from stdin while running interactively",
-               who.c_str ());
-
-      return count;
-    }
-
   err = false;
 
   std::istream *isp = input_stream ();
 
-  if (isp)
+  if (! isp)
+    {
+      err = true;
+      invalid_operation (who, "reading");
+    }
+  else
     {
       std::istream& is = *isp;
 
       int c = 0;
       int lastc = -1;
       cnt = 0;
 
       while (is && (c = is.get ()) != EOF)
         {
           // Handle CRLF, CR, or LF as line ending.
-
           if (c == '\r' || (c == '\n' && lastc != '\r'))
             {
               if (++cnt == num)
                 break;
             }
 
           lastc = c;
         }
@@ -1091,21 +1099,16 @@ octave_base_stream::skipl (off_t num, bo
         {
           err = true;
           error (who, "read error");
         }
 
       if (err)
         cnt = -1;
     }
-  else
-    {
-      err = true;
-      invalid_operation (who, "reading");
-    }
 
   return cnt;
 }
 
 #define OCTAVE_SCAN(is, fmt, arg) octave_scan (is, fmt, arg)
 
 template <class T>
 std::istream&
@@ -1123,17 +1126,17 @@ octave_scan_1 (std::istream& is, const s
       is >> std::hex >> ref >> std::dec;
       break;
 
     case 'i':
       {
         int c1 = EOF;
 
         while (is && (c1 = is.get ()) != EOF && isspace (c1))
-          /* skip whitespace */;
+          { /* skip whitespace */ }
 
         if (c1 != EOF)
           {
             if (c1 == '0')
               {
                 int c2 = is.peek ();
 
                 if (c2 == 'x' || c2 == 'X')
@@ -1175,17 +1178,16 @@ octave_scan_1 (std::istream& is, const s
 template <class T>
 std::istream&
 octave_scan (std::istream& is, const scanf_format_elt& fmt, T* valptr)
 {
   if (fmt.width)
     {
       // Limit input to fmt.width characters by reading into a
       // temporary stringstream buffer.
-
       std::string tmp;
 
       is.width (fmt.width);
       is >> tmp;
 
       std::istringstream ss (tmp);
 
       octave_scan_1 (ss, fmt, valptr);
@@ -1217,17 +1219,17 @@ octave_scan<> (std::istream& is, const s
     {
     case 'e':
     case 'f':
     case 'g':
       {
         int c1 = EOF;
 
         while (is && (c1 = is.get ()) != EOF && isspace (c1))
-          /* skip whitespace */;
+          { /* skip whitespace */ }
 
         if (c1 != EOF)
           {
             is.putback (c1);
 
             ref = octave_read_value<double> (is);
           }
       }
@@ -1245,50 +1247,50 @@ template <class T>
 void
 do_scanf_conv (std::istream& is, const scanf_format_elt& fmt,
                T valptr, Matrix& mval, double *data, octave_idx_type& idx,
                octave_idx_type& conversion_count, octave_idx_type nr,
                octave_idx_type max_size, bool discard)
 {
   OCTAVE_SCAN (is, fmt, valptr);
 
-  if (is)
+  if (! is)
+    return;
+
+  if (idx == max_size && ! discard)
     {
-      if (idx == max_size && ! discard)
-        {
-          max_size *= 2;
-
-          if (nr > 0)
-            mval.resize (nr, max_size / nr, 0.0);
-          else
-            mval.resize (max_size, 1, 0.0);
-
-          data = mval.fortran_vec ();
-        }
-
-      if (! discard)
-        {
-          conversion_count++;
-          data[idx++] = *(valptr);
-        }
+      max_size *= 2;
+
+      if (nr > 0)
+        mval.resize (nr, max_size / nr, 0.0);
+      else
+        mval.resize (max_size, 1, 0.0);
+
+      data = mval.fortran_vec ();
+    }
+
+  if (! discard)
+    {
+      conversion_count++;
+      data[idx++] = *(valptr);
     }
 }
 
 template void
 do_scanf_conv (std::istream&, const scanf_format_elt&, double*,
                Matrix&, double*, octave_idx_type&, octave_idx_type&,
                octave_idx_type, octave_idx_type, bool);
 
 #define DO_WHITESPACE_CONVERSION() \
   do \
     { \
       int c = EOF; \
  \
       while (is && (c = is.get ()) != EOF && isspace (c)) \
-        /* skip whitespace */; \
+        { /* skip whitespace */ } \
  \
       if (c != EOF) \
         is.putback (c); \
     } \
   while (0)
 
 #define DO_LITERAL_CONVERSION() \
   do \
@@ -1492,26 +1494,22 @@ do_scanf_conv (std::istream&, const scan
 
 octave_value
 octave_base_stream::do_scanf (scanf_format_list& fmt_list,
                               octave_idx_type nr, octave_idx_type nc,
                               bool one_elt_size_spec,
                               octave_idx_type& conversion_count,
                               const std::string& who)
 {
+  if (interactive && file_number () == 0)
+    ::error ("%s: unable to read from stdin while running interactively",
+             who.c_str ());
+
   octave_value retval = Matrix ();
 
-  if (interactive && file_number () == 0)
-    {
-      ::error ("%s: unable to read from stdin while running interactively",
-               who.c_str ());
-
-      return retval;
-    }
-
   conversion_count = 0;
 
   octave_idx_type nconv = fmt_list.num_conversions ();
 
   octave_idx_type data_index = 0;
 
   if (nr == 0 || nc == 0)
     {
@@ -1530,20 +1528,18 @@ octave_base_stream::do_scanf (scanf_form
   octave_idx_type max_size = 0;
   octave_idx_type max_conv = 0;
 
   octave_idx_type final_nr = 0;
   octave_idx_type final_nc = 0;
 
   if (all_char_conv)
     {
-      // Any of these could be resized later (if we have %s
-      // conversions, we may read more than one element for each
-      // conversion).
-
+      // Any of these could be resized later (if we have %s conversions,
+      // we may read more than one element for each conversion).
       if (one_elt_size_spec)
         {
           max_size = 512;
           mval.resize (1, max_size, 0.0);
 
           if (nr > 0)
             max_conv = nr;
         }
@@ -1607,23 +1603,21 @@ octave_base_stream::do_scanf (scanf_form
           if (elt)
             {
               if (elt->type == scanf_format_elt::null
                   || (! (elt->type == scanf_format_elt::whitespace_conversion
                         || elt->type == scanf_format_elt::literal_conversion
                         || elt->type == '%')
                       && max_conv > 0 && conversion_count == max_conv))
                 {
-                  // We are done, either because we have reached the end
-                  // of the format string and are not cycling through
-                  // the format again or because we've converted all the
-                  // values that have been requested and the next format
-                  // element is a conversion.  Determine final array
-                  // size and exit.
-
+                  // We are done, either because we have reached the end of the
+                  // format string and are not cycling through the format again
+                  // or because we've converted all the values that have been
+                  // requested and the next format element is a conversion.
+                  // Determine final array size and exit.
                   if (all_char_conv && one_elt_size_spec)
                     {
                       final_nr = 1;
                       final_nc = data_index;
                     }
                   else
                     {
                       final_nr = nr;
@@ -1824,28 +1818,25 @@ octave_base_stream::do_scanf (scanf_form
                   else
                     {
                       final_nr = data_index;
                       final_nc = 1;
                     }
 
                   // If it looks like we have a matching failure, then
                   // reset the failbit in the stream state.
-
                   if (is.rdstate () & std::ios::failbit)
                     is.clear (is.rdstate () & (~std::ios::failbit));
 
                   // FIXME: is this the right thing to do?
-
                   if (interactive && ! forced_interactive && name () == "stdin")
                     {
                       is.clear ();
 
                       // Skip to end of line.
-
                       bool err;
                       do_gets (-1, err, false, who);
                     }
 
                   break;
                 }
             }
           else
@@ -1866,21 +1857,20 @@ octave_base_stream::do_scanf (scanf_form
                   final_nr = nr;
                   final_nc = (data_index - 1) / nr + 1;
                 }
 
               break;
             }
           else
             {
-              // Cycle through the format list more than once if we have
-              // some conversions to make and we haven't reached the
-              // limit on the number of values to convert (possibly
-              // because there is no specified limit).
-
+              // Cycle through the format list more than once if we have some
+              // conversions to make and we haven't reached the limit on the
+              // number of values to convert (possibly because there is no
+              // specified limit).
               elt = fmt_list.next (nconv > 0
                                    && (max_conv == 0
                                        || conversion_count < max_conv));
             }
         }
     }
 
   if (ok ())
@@ -1902,285 +1892,280 @@ octave_base_stream::scanf (const std::st
                            const std::string& who)
 {
   octave_value retval = Matrix ();
 
   conversion_count = 0;
 
   std::istream *isp = input_stream ();
 
-  if (isp)
+  if (! isp)
+    invalid_operation (who, "reading");
+  else
     {
       scanf_format_list fmt_list (fmt);
 
       if (fmt_list.num_conversions () == -1)
         ::error ("%s: invalid format specified", who.c_str ());
-      else
-        {
-          octave_idx_type nr = -1;
-          octave_idx_type nc = -1;
-
-          bool one_elt_size_spec;
-
-          get_size (size, nr, nc, one_elt_size_spec, who);
-
-          retval = do_scanf (fmt_list, nr, nc, one_elt_size_spec,
-                             conversion_count, who);
-        }
+
+      octave_idx_type nr = -1;
+      octave_idx_type nc = -1;
+
+      bool one_elt_size_spec;
+
+      get_size (size, nr, nc, one_elt_size_spec, who);
+
+      retval = do_scanf (fmt_list, nr, nc, one_elt_size_spec,
+                         conversion_count, who);
     }
-  else
-    invalid_operation (who, "reading");
 
   return retval;
 }
 
 bool
 octave_base_stream::do_oscanf (const scanf_format_elt *elt,
                                octave_value& retval, const std::string& who)
 {
+  std::istream *isp = input_stream ();
+
+  if (! isp)
+    return false;
+
   bool quit = false;
 
-  std::istream *isp = input_stream ();
-
-  if (isp)
+  std::istream& is = *isp;
+
+  std::ios::fmtflags flags = is.flags ();
+
+  if (elt)
     {
-      std::istream& is = *isp;
-
-      std::ios::fmtflags flags = is.flags ();
-
-      if (elt)
+      const char *fmt = elt->text;
+
+      bool discard = elt->discard;
+
+      switch (elt->type)
         {
-          const char *fmt = elt->text;
-
-          bool discard = elt->discard;
-
-          switch (elt->type)
-            {
-            case scanf_format_elt::whitespace_conversion:
-              DO_WHITESPACE_CONVERSION ();
-              break;
-
-            case scanf_format_elt::literal_conversion:
-              DO_LITERAL_CONVERSION ();
-              break;
-
-            case '%':
-              {
-                DO_PCT_CONVERSION ();
-
-                if (! is)
-                  quit = true;
-
-              }
-              break;
-
-            case 'd': case 'i':
+        case scanf_format_elt::whitespace_conversion:
+          DO_WHITESPACE_CONVERSION ();
+          break;
+
+        case scanf_format_elt::literal_conversion:
+          DO_LITERAL_CONVERSION ();
+          break;
+
+        case '%':
+          {
+            DO_PCT_CONVERSION ();
+
+            if (! is)
+              quit = true;
+          }
+          break;
+
+        case 'd': case 'i':
+          {
+            int tmp;
+
+            if (OCTAVE_SCAN (is, *elt, &tmp))
               {
-                int tmp;
-
-                if (OCTAVE_SCAN (is, *elt, &tmp))
-                  {
-                    if (! discard)
-                      retval = tmp;
-                  }
-                else
-                  quit = true;
+                if (! discard)
+                  retval = tmp;
               }
-              break;
-
-            case 'o': case 'u': case 'x':
+            else
+              quit = true;
+          }
+          break;
+
+        case 'o': case 'u': case 'x':
+          {
+            long int tmp;
+
+            if (OCTAVE_SCAN (is, *elt, &tmp))
               {
-                long int tmp;
-
-                if (OCTAVE_SCAN (is, *elt, &tmp))
-                  {
-                    if (! discard)
-                      retval = tmp;
-                  }
-                else
-                  quit = true;
-              }
-              break;
-
-            case 'e': case 'f': case 'g':
-              {
-                double tmp;
-
-                if (OCTAVE_SCAN (is, *elt, &tmp))
-                  {
-                    if (! discard)
-                      retval = tmp;
-                  }
-                else
-                  quit = true;
-              }
-              break;
-
-            case 'c':
-              {
-                BEGIN_C_CONVERSION ();
-
                 if (! discard)
                   retval = tmp;
-
-                if (! is)
-                  quit = true;
-
-                is.setf (flags);
               }
-              break;
-
-            case 's':
+            else
+              quit = true;
+          }
+          break;
+
+        case 'e': case 'f': case 'g':
+          {
+            double tmp;
+
+            if (OCTAVE_SCAN (is, *elt, &tmp))
               {
-                BEGIN_S_CONVERSION ();
-
-                if (! discard)
-                  retval = tmp;
-
-                if (! is)
-                  quit = true;
-              }
-              break;
-
-            case '[': case '^':
-              {
-                BEGIN_CHAR_CLASS_CONVERSION ();
-
                 if (! discard)
                   retval = tmp;
-
-                if (! is)
-                  quit = true;
               }
-              break;
-
-            case 'p':
-              error ("%s: unsupported format specifier", who.c_str ());
-              break;
-
-            default:
-              error ("%s: internal format error", who.c_str ());
-              break;
-            }
+            else
+              quit = true;
+          }
+          break;
+
+        case 'c':
+          {
+            BEGIN_C_CONVERSION ();
+
+            if (! discard)
+              retval = tmp;
+
+            if (! is)
+              quit = true;
+
+            is.setf (flags);
+          }
+          break;
+
+        case 's':
+          {
+            BEGIN_S_CONVERSION ();
+
+            if (! discard)
+              retval = tmp;
+
+            if (! is)
+              quit = true;
+          }
+          break;
+
+        case '[':
+        case '^':
+          {
+            BEGIN_CHAR_CLASS_CONVERSION ();
+
+            if (! discard)
+              retval = tmp;
+
+            if (! is)
+              quit = true;
+          }
+          break;
+
+        case 'p':
+          error ("%s: unsupported format specifier", who.c_str ());
+          break;
+
+        default:
+          error ("%s: internal format error", who.c_str ());
+          break;
         }
-
-      if (ok () && is.fail ())
+    }
+
+  if (ok () && is.fail ())
+    {
+      error ("%s: read error", who.c_str ());
+
+      // FIXME: is this the right thing to do?
+
+      if (interactive && ! forced_interactive && name () == "stdin")
         {
-          error ("%s: read error", who.c_str ());
-
-          // FIXME: is this the right thing to do?
-
-          if (interactive && ! forced_interactive && name () == "stdin")
-            {
-              // Skip to end of line.
-
-              bool err;
-              do_gets (-1, err, false, who);
-            }
+          // Skip to end of line.
+          bool err;
+          do_gets (-1, err, false, who);
         }
     }
 
   return quit;
 }
 
 octave_value_list
 octave_base_stream::oscanf (const std::string& fmt, const std::string& who)
 {
   octave_value_list retval;
 
   std::istream *isp = input_stream ();
 
-  if (isp)
+  if (! isp)
+    invalid_operation (who, "reading");
+  else
     {
       std::istream& is = *isp;
 
       scanf_format_list fmt_list (fmt);
 
       octave_idx_type nconv = fmt_list.num_conversions ();
 
       if (nconv == -1)
         ::error ("%s: invalid format specified", who.c_str ());
-      else
+
+      is.clear ();
+
+      octave_idx_type len = fmt_list.length ();
+
+      retval.resize (nconv+2, Matrix ());
+
+      const scanf_format_elt *elt = fmt_list.first ();
+
+      int num_values = 0;
+
+      bool quit = false;
+
+      for (octave_idx_type i = 0; i < len; i++)
         {
-          is.clear ();
-
-          octave_idx_type len = fmt_list.length ();
-
-          retval.resize (nconv+2, Matrix ());
-
-          const scanf_format_elt *elt = fmt_list.first ();
-
-          int num_values = 0;
-
-          bool quit = false;
-
-          for (octave_idx_type i = 0; i < len; i++)
+          octave_value tmp;
+
+          quit = do_oscanf (elt, tmp, who);
+
+          if (quit)
+            break;
+          else
+            {
+              if (tmp.is_defined ())
+                retval(num_values++) = tmp;
+
+              if (! ok ())
+                break;
+
+              elt = fmt_list.next (nconv > 0);
+            }
+        }
+
+      retval(nconv) = num_values;
+
+      int err_num;
+      retval(nconv+1) = error (false, err_num);
+
+      if (! quit)
+        {
+          // Pick up any trailing stuff.
+          if (ok () && len > nconv)
             {
               octave_value tmp;
 
-              quit = do_oscanf (elt, tmp, who);
-
-              if (quit)
-                break;
-              else
-                {
-                  if (tmp.is_defined ())
-                    retval(num_values++) = tmp;
-
-                  if (! ok ())
-                    break;
-
-                  elt = fmt_list.next (nconv > 0);
-                }
-            }
-
-          retval(nconv) = num_values;
-
-          int err_num;
-          retval(nconv+1) = error (false, err_num);
-
-          if (! quit)
-            {
-              // Pick up any trailing stuff.
-              if (ok () && len > nconv)
-                {
-                  octave_value tmp;
-
-                  elt = fmt_list.next ();
-
-                  do_oscanf (elt, tmp, who);
-                }
+              elt = fmt_list.next ();
+
+              do_oscanf (elt, tmp, who);
             }
         }
     }
-  else
-    invalid_operation (who, "reading");
 
   return retval;
 }
 
-// Functions that are defined for all output streams (output streams
-// are those that define os).
+// Functions that are defined for all output streams
+// (output streams are those that define os).
 
 int
 octave_base_stream::flush (void)
 {
   int retval = -1;
 
   std::ostream *os = output_stream ();
 
-  if (os)
+  if (! os)
+    invalid_operation ("fflush", "writing");
+  else
     {
       os->flush ();
 
       if (os->good ())
         retval = 0;
     }
-  else
-    invalid_operation ("fflush", "writing");
 
   return retval;
 }
 
 class
 printf_value_cache
 {
 public:
@@ -2269,17 +2254,16 @@ printf_value_cache::get_next_value (char
 
                   // We've consumed the rest of the value.
                   elt_idx = n_elts;
                 }
               else
                 {
                   // Convert to character string while values are
                   // integers in the range [0 : char max]
-
                   const NDArray val = curr_val.array_value ();
 
                   octave_idx_type idx = elt_idx;
 
                   for (; idx < n_elts; idx++)
                     {
                       double dval = val(idx);
 
@@ -2507,21 +2491,19 @@ octave_base_stream::do_numeric_printf_co
 
   if (is_nan_or_inf (val))
     {
       double dval = val.double_value ();
 
       std::string tfmt = fmt;
       std::string::size_type i1, i2;
 
-      tfmt.replace ((i1 = tfmt.rfind (elt->type)),
-                    1, 1, 's');
-
-      if ((i2 = tfmt.rfind ('.')) != std::string::npos
-          && i2 < i1)
+      tfmt.replace ((i1 = tfmt.rfind (elt->type)), 1, 1, 's');
+
+      if ((i2 = tfmt.rfind ('.')) != std::string::npos && i2 < i1)
         {
           tfmt.erase (i2, i1-i2);
           if (elt->prec == -2)
             nsa--;
         }
 
       const char *tval;
       if (lo_ieee_isinf (dval))
@@ -2601,16 +2583,18 @@ octave_base_stream::do_numeric_printf_co
           {
             double dval = val.double_value (true);
 
             retval += do_printf_conv (os, fmt, nsa, sa_1, sa_2, dval, who);
           }
           break;
 
         default:
+          // Note: error() is member fcn from octave_base_stream, not ::error().
+          // This error() does not halt execution so "return ..." must exist.
           error ("%s: invalid format specifier", who.c_str ());
           return -1;
           break;
         }
     }
 
   return retval;
 }
@@ -2621,32 +2605,33 @@ octave_base_stream::do_printf (printf_fo
                                const std::string& who)
 {
   int retval = 0;
 
   octave_idx_type nconv = fmt_list.num_conversions ();
 
   std::ostream *osp = output_stream ();
 
-  if (osp)
+  if (! osp)
+    invalid_operation (who, "writing");
+  else
     {
       std::ostream& os = *osp;
 
       const printf_format_elt *elt = fmt_list.first ();
 
       printf_value_cache val_cache (args, who);
 
       for (;;)
         {
           octave_quit ();
 
           if (elt)
             {
               // NSA is the number of 'star' args to convert.
-
               int nsa = (elt->fw == -2) + (elt->prec == -2);
 
               int sa_1 = 0;
               int sa_2 = 0;
 
               if (nsa > 0)
                 {
                   sa_1 = val_cache.int_value ();
@@ -2709,84 +2694,79 @@ octave_base_stream::do_printf (printf_fo
               if (! os)
                 {
                   error ("%s: write error", who.c_str ());
                   break;
                 }
             }
           else
             {
+              // FIXME: should this be member fcn "error"?
+              //        Otherwise, retval and break are unnecessary.
               ::error ("%s: internal error handling format", who.c_str ());
               retval = -1;
               break;
             }
 
           elt = fmt_list.next (nconv > 0 && ! val_cache.exhausted ());
 
           if (! elt || (val_cache.exhausted () && elt->args > 0))
             break;
         }
     }
-  else
-    invalid_operation (who, "writing");
 
   return retval;
 }
 
 int
 octave_base_stream::printf (const std::string& fmt,
                             const octave_value_list& args,
                             const std::string& who)
 {
-  int retval = 0;
-
   printf_format_list fmt_list (fmt);
 
   if (fmt_list.num_conversions () == -1)
     ::error ("%s: invalid format specified", who.c_str ());
-  else
-    retval = do_printf (fmt_list, args, who);
-
-  return retval;
+
+  return do_printf (fmt_list, args, who);
 }
 
 int
 octave_base_stream::puts (const std::string& s, const std::string& who)
 {
   int retval = -1;
 
   std::ostream *osp = output_stream ();
 
-  if (osp)
+  if (! osp)
+    invalid_operation (who, "writing");
+  else
     {
       std::ostream& os = *osp;
 
       os << s;
 
-      if (os)
+      if (! os)
+        error ("%s: write error", who.c_str ());
+      else
         {
           // FIXME: why does this seem to be necessary?
           // Without it, output from a loop like
           //
           //   for i = 1:100, fputs (stdout, "foo\n"); endfor
           //
           // doesn't seem to go to the pager immediately.
-
           os.flush ();
 
           if (os)
             retval = 0;
           else
             error ("%s: write error", who.c_str ());
         }
-      else
-        error ("%s: write error", who.c_str ());
     }
-  else
-    invalid_operation (who, "writing");
 
   return retval;
 }
 
 // Return current error message for this stream.
 
 std::string
 octave_base_stream::error (bool clear_err, int& err_num)
@@ -2799,18 +2779,17 @@ octave_base_stream::error (bool clear_er
     clear ();
 
   return tmp;
 }
 
 void
 octave_base_stream::invalid_operation (const std::string& who, const char *rw)
 {
-  // Note that this is not ::error () !
-
+  // Note: This calls the member fcn error(), not ::error() from error.h.
   error (who, std::string ("stream not open for ") + rw);
 }
 
 octave_stream::octave_stream (octave_base_stream *bs)
   : rep (bs)
 {
   if (rep)
     rep->count = 1;
@@ -2867,18 +2846,16 @@ octave_stream::getl (octave_idx_type max
 
   return retval;
 }
 
 std::string
 octave_stream::getl (const octave_value& tc_max_len, bool& err,
                      const std::string& who)
 {
-  std::string retval;
-
   err = false;
 
   int conv_err = 0;
 
   int max_len = -1;
 
   if (tc_max_len.is_defined ())
     {
@@ -2886,19 +2863,17 @@ octave_stream::getl (const octave_value&
 
       if (conv_err || max_len < 0)
         {
           err = true;
           ::error ("%s: invalid maximum length specified", who.c_str ());
         }
     }
 
-  retval = getl (max_len, err, who);
-
-  return retval;
+  return getl (max_len, err, who);
 }
 
 std::string
 octave_stream::gets (octave_idx_type max_len, bool& err, const std::string& who)
 {
   std::string retval;
 
   if (stream_ok ())
@@ -2906,18 +2881,16 @@ octave_stream::gets (octave_idx_type max
 
   return retval;
 }
 
 std::string
 octave_stream::gets (const octave_value& tc_max_len, bool& err,
                      const std::string& who)
 {
-  std::string retval;
-
   err = false;
 
   int conv_err = 0;
 
   int max_len = -1;
 
   if (tc_max_len.is_defined ())
     {
@@ -2925,19 +2898,17 @@ octave_stream::gets (const octave_value&
 
       if (conv_err || max_len < 0)
         {
           err = true;
           ::error ("%s: invalid maximum length specified", who.c_str ());
         }
     }
 
-  retval = gets (max_len, err, who);
-
-  return retval;
+  return gets (max_len, err, who);
 }
 
 off_t
 octave_stream::skipl (off_t count, bool& err, const std::string& who)
 {
   off_t retval = -1;
 
   if (stream_ok ())
@@ -2945,18 +2916,16 @@ octave_stream::skipl (off_t count, bool&
 
   return retval;
 }
 
 off_t
 octave_stream::skipl (const octave_value& tc_count, bool& err,
                       const std::string& who)
 {
-  off_t retval = -1;
-
   err = false;
 
   int conv_err = 0;
 
   int count = 1;
 
   if (tc_count.is_defined ())
     {
@@ -2969,80 +2938,70 @@ octave_stream::skipl (const octave_value
           if (conv_err || count < 0)
             {
               err = true;
               ::error ("%s: invalid number of lines specified", who.c_str ());
             }
         }
     }
 
-  retval = skipl (count, err, who);
-
-  return retval;
+  return skipl (count, err, who);
 }
 
 int
 octave_stream::seek (off_t offset, int origin)
 {
   int status = -1;
 
   if (stream_ok ())
     {
       clearerr ();
 
       // Find current position so we can return to it if needed.
-
       off_t orig_pos = rep->tell ();
 
       // Move to end of file.  If successful, find the offset of the end.
-
       status = rep->seek (0, SEEK_END);
 
       if (status == 0)
         {
           off_t eof_pos = rep->tell ();
 
           if (origin == SEEK_CUR)
             {
-              // Move back to original position, otherwise we will be
-              // seeking from the end of file which is probably not the
-              // original location.
-
+              // Move back to original position, otherwise we will be seeking
+              // from the end of file which is probably not the original
+              // location.
               rep->seek (orig_pos, SEEK_SET);
             }
 
-          // Attempt to move to desired position; may be outside bounds
-          // of existing file.
-
+          // Attempt to move to desired position; may be outside bounds of
+          // existing file.
           status = rep->seek (offset, origin);
 
           if (status == 0)
             {
               // Where are we after moving to desired position?
-
               off_t desired_pos = rep->tell ();
 
-              // I don't think save_pos can be less than zero, but we'll
-              // check anyway...
-
+              // I don't think save_pos can be less than zero,
+              // but we'll check anyway...
               if (desired_pos > eof_pos || desired_pos < 0)
                 {
-                  // Seek outside bounds of file.  Failure should leave
-                  // position unchanged.
-
+                  // Seek outside bounds of file.
+                  // Failure should leave position unchanged.
                   rep->seek (orig_pos, SEEK_SET);
 
                   status = -1;
                 }
             }
           else
             {
-              // Seeking to the desired position failed.  Move back to
-              // original position and return failure status.
-
+              // Seeking to the desired position failed.
+              // Move back to original position and return failure status.
               rep->seek (orig_pos, SEEK_SET);
 
               status = -1;
             }
         }
     }
 
   return status;
@@ -3092,19 +3051,21 @@ octave_stream::seek (const octave_value&
         }
     }
 
   if (! conv_err)
     {
       retval = seek (xoffset, origin);
 
       if (retval != 0)
+        // FIXME: Should this be ::error()?
         error ("fseek: failed to seek to requested position");
     }
   else
+    // FIXME: Should this be ::error()?
     error ("fseek: invalid value for origin");
 
   return retval;
 }
 
 off_t
 octave_stream::tell (void)
 {
@@ -3319,21 +3280,21 @@ octave_stream::finalize_read (std::list<
 
         retval = fptr (input_buf_list, input_buf_elts, elts_read,
                        nr, nc, swap, do_float_fmt_conv, do_NA_conv, ffmt);
       }
       break;
 
     default:
       retval = false;
+      // FIXME: Should this be ::error()?
       error ("read: invalid type specification");
       break;
     }
 
-
   return retval;
 }
 
 octave_value
 octave_stream::read (const Array<double>& size, octave_idx_type block_size,
                      oct_data_conv::data_type input_type,
                      oct_data_conv::data_type output_type,
                      octave_idx_type skip, oct_mach_info::float_format ffmt,
@@ -3341,217 +3302,215 @@ octave_stream::read (const Array<double>
 {
   octave_value retval;
 
   octave_idx_type nr = -1;
   octave_idx_type nc = -1;
 
   bool one_elt_size_spec = false;
 
-  if (stream_ok ())
+  if (! stream_ok ())
+    return retval;
+
+  // FIXME: we may eventually want to make this extensible.
+
+  // FIXME: we need a better way to ensure that this
+  // numbering stays consistent with the order of the elements in the
+  // data_type enum in the oct_data_conv class.
+
+  // Expose this in a future version?
+  octave_idx_type char_count = 0;
+
+  count = 0;
+
+  try
     {
-      // FIXME: we may eventually want to make this extensible.
-
-      // FIXME: we need a better way to ensure that this
-      // numbering stays consistent with the order of the elements in the
-      // data_type enum in the oct_data_conv class.
-
-      // Expose this in a future version?
-      octave_idx_type char_count = 0;
-
-      count = 0;
-
-      try
-        {
-          get_size (size, nr, nc, one_elt_size_spec, "fread");
-        }
-      catch (const octave_execution_exception&)
-        {
-          invalid_operation ("fread", "reading");
-        }
-
-      octave_idx_type elts_to_read;
-
-      if (one_elt_size_spec)
-        {
-          // If NR == 0, Matlab returns [](0x0).
-
-          // If NR > 0, the result will be a column vector with the given
-          // number of rows.
-
-          // If NR < 0, then we have Inf and the result will be a column
-          // vector but we have to wait to see how big NR will be.
-
-          if (nr == 0)
-            nr = nc = 0;
-          else
-            nc = 1;
-        }
+      get_size (size, nr, nc, one_elt_size_spec, "fread");
+    }
+  catch (const octave_execution_exception&)
+    {
+      invalid_operation ("fread", "reading");
+    }
+
+  octave_idx_type elts_to_read;
+
+  if (one_elt_size_spec)
+    {
+      // If NR == 0, Matlab returns [](0x0).
+
+      // If NR > 0, the result will be a column vector with the given
+      // number of rows.
+
+      // If NR < 0, then we have Inf and the result will be a column
+      // vector but we have to wait to see how big NR will be.
+
+      if (nr == 0)
+        nr = nc = 0;
       else
-        {
-          // Matlab returns [] even if there are two elements in the size
-          // specification and one is nonzero.
-
-          // If NC < 0 we have [NR, Inf] and we'll wait to decide how big NC
-          // should be.
-
-          if (nr == 0 || nc == 0)
-            nr = nc = 0;
-        }
-
-      // FIXME: Ensure that this does not overflow.
-      //        Maybe try comparing nr * nc computed in double with
-      //        std::numeric_limits<octave_idx_type>::max ();
-
-      elts_to_read = nr * nc;
-
-      bool read_to_eof = elts_to_read < 0;
-
-      octave_idx_type input_buf_elts = -1;
-
-      if (skip == 0)
-        {
-          if (read_to_eof)
-            input_buf_elts = 1024 * 1024;
-          else
-            input_buf_elts = elts_to_read;
-        }
+        nc = 1;
+    }
+  else
+    {
+      // Matlab returns [] even if there are two elements in the size
+      // specification and one is nonzero.
+
+      // If NC < 0 we have [NR, Inf] and we'll wait to decide how big NC
+      // should be.
+
+      if (nr == 0 || nc == 0)
+        nr = nc = 0;
+    }
+
+  // FIXME: Ensure that this does not overflow.
+  //        Maybe try comparing nr * nc computed in double with
+  //        std::numeric_limits<octave_idx_type>::max ();
+  elts_to_read = nr * nc;
+
+  bool read_to_eof = elts_to_read < 0;
+
+  octave_idx_type input_buf_elts = -1;
+
+  if (skip == 0)
+    {
+      if (read_to_eof)
+        input_buf_elts = 1024 * 1024;
       else
-        input_buf_elts = block_size;
-
-      octave_idx_type input_elt_size
-                                        = oct_data_conv::data_type_size (input_type);
-
-      octave_idx_type input_buf_size = input_buf_elts * input_elt_size;
-
-      assert (input_buf_size >= 0);
-
-      // Must also work and return correct type object
-      // for 0 elements to read.
-
-      std::istream *isp = input_stream ();
-
-      if (isp)
+        input_buf_elts = elts_to_read;
+    }
+  else
+    input_buf_elts = block_size;
+
+  octave_idx_type input_elt_size
+    = oct_data_conv::data_type_size (input_type);
+
+  octave_idx_type input_buf_size = input_buf_elts * input_elt_size;
+
+  assert (input_buf_size >= 0);
+
+  // Must also work and return correct type object
+  // for 0 elements to read.
+  std::istream *isp = input_stream ();
+
+  if (! isp)
+    error ("fread: invalid input stream");
+  else
+    {
+      std::istream& is = *isp;
+
+      std::list <void *> input_buf_list;
+
+      while (is && ! is.eof ()
+             && (read_to_eof || count < elts_to_read))
         {
-          std::istream& is = *isp;
-
-          std::list <void *> input_buf_list;
-
-          while (is && ! is.eof ()
-                 && (read_to_eof || count < elts_to_read))
+          if (! read_to_eof)
+            {
+              octave_idx_type remaining_elts = elts_to_read - count;
+
+              if (remaining_elts < input_buf_elts)
+                input_buf_size = remaining_elts * input_elt_size;
+            }
+
+          char *input_buf = new char [input_buf_size];
+
+          is.read (input_buf, input_buf_size);
+
+          size_t gcount = is.gcount ();
+
+          char_count += gcount;
+
+          octave_idx_type nel = gcount / input_elt_size;
+
+          count += nel;
+
+          input_buf_list.push_back (input_buf);
+
+          if (is && skip != 0 && nel == block_size)
             {
-              if (! read_to_eof)
-                {
-                  octave_idx_type remaining_elts = elts_to_read - count;
-
-                  if (remaining_elts < input_buf_elts)
-                    input_buf_size = remaining_elts * input_elt_size;
-                }
-
-              char *input_buf = new char [input_buf_size];
-
-              is.read (input_buf, input_buf_size);
-
-              size_t gcount = is.gcount ();
-
-              char_count += gcount;
-
-              octave_idx_type nel = gcount / input_elt_size;
-
-              count += nel;
-
-              input_buf_list.push_back (input_buf);
-
-              if (is && skip != 0 && nel == block_size)
-                {
-                  // Seek to skip.  If skip would move past EOF,
-                  // position at EOF.
-
-                  off_t orig_pos = tell ();
-
-                  seek (0, SEEK_END);
-
-                  off_t eof_pos = tell ();
-
-                  // Is it possible for this to fail to return us to
-                  // the original position?
-                  seek (orig_pos, SEEK_SET);
-
-                  off_t remaining = eof_pos - orig_pos;
-
-                  if (remaining < skip)
-                    seek (0, SEEK_END);
-                  else
-                    seek (skip, SEEK_CUR);
-
-                  if (! is)
-                    break;
-                }
+              // Seek to skip.
+              // If skip would move past EOF, position at EOF.
+
+              off_t orig_pos = tell ();
+
+              seek (0, SEEK_END);
+
+              off_t eof_pos = tell ();
+
+              // Is it possible for this to fail to return us to
+              // the original position?
+              seek (orig_pos, SEEK_SET);
+
+              off_t remaining = eof_pos - orig_pos;
+
+              if (remaining < skip)
+                seek (0, SEEK_END);
+              else
+                seek (skip, SEEK_CUR);
+
+              if (! is)
+                break;
             }
-
-          if (read_to_eof)
-            {
-              if (nc < 0)
-                {
-                  nc = count / nr;
-
-                  if (count % nr != 0)
-                    nc++;
-                }
-              else
-                nr = count;
-            }
-          else if (count == 0)
+        }
+
+      if (read_to_eof)
+        {
+          if (nc < 0)
             {
-              nr = 0;
-              nc = 0;
-            }
-          else if (count != nr * nc)
-            {
+              nc = count / nr;
+
               if (count % nr != 0)
-                nc = count / nr + 1;
-              else
-                nc = count / nr;
-
-              if (count < nr)
-                nr = count;
+                nc++;
             }
-
-          retval = finalize_read (input_buf_list, input_buf_elts, count,
-                                  nr, nc, input_type, output_type, ffmt);
+          else
+            nr = count;
+        }
+      else if (count == 0)
+        {
+          nr = 0;
+          nc = 0;
         }
-      else
-        error ("fread: invalid input stream");
+      else if (count != nr * nc)
+        {
+          if (count % nr != 0)
+            nc = count / nr + 1;
+          else
+            nc = count / nr;
+
+          if (count < nr)
+            nr = count;
+        }
+
+      retval = finalize_read (input_buf_list, input_buf_elts, count,
+                              nr, nc, input_type, output_type, ffmt);
     }
 
   return retval;
 }
 
 octave_idx_type
 octave_stream::write (const octave_value& data, octave_idx_type block_size,
                       oct_data_conv::data_type output_type,
                       octave_idx_type skip, oct_mach_info::float_format flt_fmt)
 {
   octave_idx_type retval = -1;
 
-  if (stream_ok ())
+  if (! stream_ok ())
+    invalid_operation ("fwrite", "writing");
+  else
     {
       if (flt_fmt == oct_mach_info::flt_fmt_unknown)
         flt_fmt = float_format ();
 
       octave_idx_type status = data.write (*this, block_size, output_type,
                                            skip, flt_fmt);
 
       if (status < 0)
         error ("fwrite: write error");
       else
         retval = status;
     }
-  else
-    invalid_operation ("fwrite", "writing");
 
   return retval;
 }
 
 template <class T, class V>
 static void
 convert_chars (const void *data, void *conv_data, octave_idx_type n_elts)
 {
@@ -3569,19 +3528,17 @@ convert_ints (const T *data, void *conv_
               bool swap)
 {
   typedef typename V::val_type val_type;
 
   val_type *vt_data = static_cast<val_type *> (conv_data);
 
   for (octave_idx_type i = 0; i < n_elts; i++)
     {
-      // Yes, we want saturation semantics when converting to an integer
-      // type.
-
+      // Yes, we want saturation semantics when converting to an integer type.
       V val (data[i]);
 
       vt_data[i] = val.value ();
 
       if (swap)
         swap_bytes<sizeof (val_type)> (&vt_data[i]);
     }
 }
@@ -3688,16 +3645,17 @@ convert_data (const T *data, void *conv_
             if (do_float_conversion)
               do_double_format_conversion (&vt_data[i], 1, flt_fmt);
           }
       }
       break;
 
     default:
       retval = false;
+      // FIXME: Should this be ::error()?
       error ("write: invalid type specification");
       break;
     }
 
   return retval;
 }
 
 bool
@@ -3725,51 +3683,48 @@ octave_stream::write_bytes (const void *
 
 bool
 octave_stream::skip_bytes (size_t skip)
 {
   bool status = false;
 
   std::ostream *osp = output_stream ();
 
-  if (osp)
+  if (! osp)
+    return false;
+
+  std::ostream& os = *osp;
+
+  // Seek to skip when inside bounds of existing file.
+  // Otherwise, write NUL to skip.
+  off_t orig_pos = tell ();
+
+  seek (0, SEEK_END);
+
+  off_t eof_pos = tell ();
+
+  // Is it possible for this to fail to return us to the original position?
+  seek (orig_pos, SEEK_SET);
+
+  size_t remaining = eof_pos - orig_pos;
+
+  if (remaining < skip)
     {
-      std::ostream& os = *osp;
-
-      // Seek to skip when inside bounds of existing file.
-      // Otherwise, write NUL to skip.
-
-      off_t orig_pos = tell ();
-
       seek (0, SEEK_END);
 
-      off_t eof_pos = tell ();
-
-      // Is it possible for this to fail to return us to the
-      // original position?
-      seek (orig_pos, SEEK_SET);
-
-      size_t remaining = eof_pos - orig_pos;
-
-      if (remaining < skip)
-        {
-          seek (0, SEEK_END);
-
-          // FIXME: probably should try to write larger blocks...
-
-          unsigned char zero = 0;
-          for (size_t j = 0; j < skip - remaining; j++)
-            os.write (reinterpret_cast<const char *> (&zero), 1);
-        }
-      else
-        seek (skip, SEEK_CUR);
-
-      if (os)
-        status = true;
+      // FIXME: probably should try to write larger blocks...
+      unsigned char zero = 0;
+      for (size_t j = 0; j < skip - remaining; j++)
+        os.write (reinterpret_cast<const char *> (&zero), 1);
     }
+  else
+    seek (skip, SEEK_CUR);
+
+  if (os)
+    status = true;
 
   return status;
 }
 
 template <class T>
 octave_idx_type
 octave_stream::write (const Array<T>& data, octave_idx_type block_size,
                       oct_data_conv::data_type output_type,
@@ -3891,18 +3846,17 @@ octave_stream::scanf (const octave_value
 
       if (fmt.is_sq_string ())
         sfmt = do_string_escapes (sfmt);
 
       retval = scanf (sfmt, size, count, who);
     }
   else
     {
-      // Note that this is not ::error () !
-
+      // Note: error() is member fcn from octave_stream, not ::error().
       error (who + ": format must be a string");
     }
 
   return retval;
 }
 
 octave_value_list
 octave_stream::oscanf (const std::string& fmt, const std::string& who)
@@ -3926,18 +3880,17 @@ octave_stream::oscanf (const octave_valu
 
       if (fmt.is_sq_string ())
         sfmt = do_string_escapes (sfmt);
 
       retval = oscanf (sfmt, who);
     }
   else
     {
-      // Note that this is not ::error () !
-
+      // Note: error() is member fcn from octave_stream, not ::error().
       error (who + ": format must be a string");
     }
 
   return retval;
 }
 
 int
 octave_stream::printf (const std::string& fmt, const octave_value_list& args,
@@ -3963,18 +3916,17 @@ octave_stream::printf (const octave_valu
 
       if (fmt.is_sq_string ())
         sfmt = do_string_escapes (sfmt);
 
       retval = printf (sfmt, args, who);
     }
   else
     {
-      // Note that this is not ::error () !
-
+      // Note: error() is member fcn from octave_stream, not ::error().
       error (who + ": format must be a string");
     }
 
   return retval;
 }
 
 int
 octave_stream::puts (const std::string& s, const std::string& who)
@@ -3996,18 +3948,17 @@ octave_stream::puts (const octave_value&
 
   if (tc_s.is_string ())
     {
       std::string s = tc_s.string_value ();
       retval = puts (s, who);
     }
   else
     {
-      // Note that this is not ::error () !
-
+      // Note: error() is member fcn from octave_stream, not ::error().
       error (who + ": argument must be a string");
     }
 
   return retval;
 }
 
 bool
 octave_stream::eof (void) const
@@ -4191,19 +4142,19 @@ octave_stream_list::get_file_number (con
   return (instance_ok ()) ? instance->do_get_file_number (fid) : -1;
 }
 
 int
 octave_stream_list::do_insert (octave_stream& os)
 {
   // Insert item with key corresponding to file-descriptor.
 
-  int stream_number;
-
-  if ((stream_number = os.file_number ()) == -1)
+  int stream_number = os.file_number ();
+
+  if (stream_number == -1)
     return stream_number;
 
   // Should we test for
   //
   //  (list.find (stream_number) != list.end ()
   //   && list[stream_number].is_open ())
   //
   // and respond with "error ("internal error: ...")"?  It should not
@@ -4214,16 +4165,17 @@ octave_stream_list::do_insert (octave_st
   // overwrite this entry, although the wrong entry might have done harm
   // before.
 
   if (list.size () < list.max_size ())
     list[stream_number] = os;
   else
     {
       stream_number = -1;
+      // FIXME: Should this be ::error()?
       error ("could not create file id");
     }
 
   return stream_number;
 
 }
 
 static void
@@ -4262,55 +4214,51 @@ octave_stream_list::do_lookup (int fid, 
 
   return retval;
 }
 
 octave_stream
 octave_stream_list::do_lookup (const octave_value& fid,
                                const std::string& who) const
 {
-  octave_stream retval;
-
   int i = get_file_number (fid);
 
-  retval = do_lookup (i, who);
-
-  return retval;
+  return do_lookup (i, who);
 }
 
 int
 octave_stream_list::do_remove (int fid, const std::string& who)
 {
   int retval = -1;
 
   // Can't remove stdin (std::cin), stdout (std::cout), or stderr (std::cerr).
-  if (fid > 2)
+  if (fid < 3)
+    gripe_invalid_file_id (fid, who);
+  else
     {
       ostrl_map::iterator iter = list.find (fid);
 
-      if (iter != list.end ())
+      if (iter == list.end ())
+        gripe_invalid_file_id (fid, who);
+      else
         {
           octave_stream os = iter->second;
           list.erase (iter);
           lookup_cache = list.end ();
 
           // FIXME: is this check redundant?
           if (os.is_valid ())
             {
               os.close ();
               retval = 0;
             }
           else
             gripe_invalid_file_id (fid, who);
         }
-      else
-        gripe_invalid_file_id (fid, who);
     }
-  else
-    gripe_invalid_file_id (fid, who);
 
   return retval;
 }
 
 int
 octave_stream_list::do_remove (const octave_value& fid, const std::string& who)
 {
   int retval = -1;
@@ -4388,35 +4336,29 @@ octave_stream_list::do_get_info (int fid
   retval(2) = oct_mach_info::float_format_as_string (os.float_format ());
 
   return retval;
 }
 
 string_vector
 octave_stream_list::do_get_info (const octave_value& fid) const
 {
-  string_vector retval;
-
   int conv_err = 0;
 
   int int_fid = convert_to_valid_int (fid, conv_err);
 
-  if (! conv_err)
-    retval = do_get_info (int_fid);
-  else
+  if (conv_err)
     ::error ("file id must be a file object or integer value");
 
-  return retval;
+  return do_get_info (int_fid);
 }
 
 std::string
 octave_stream_list::do_list_open_files (void) const
 {
-  std::string retval;
-
   std::ostringstream buf;
 
   buf << "\n"
       << "  number  mode  arch       name\n"
       << "  ------  ----  ----       ----\n";
 
   for (ostrl_map::const_iterator p = list.begin (); p != list.end (); p++)
     {
@@ -4434,32 +4376,29 @@ octave_stream_list::do_list_open_files (
           << std::setw (9)
           << oct_mach_info::float_format_as_string (os.float_format ())
           << "  "
           << os.name () << "\n";
     }
 
   buf << "\n";
 
-  retval = buf.str ();
-
-  return retval;
+  return buf.str ();
 }
 
 octave_value
 octave_stream_list::do_open_file_numbers (void) const
 {
   Matrix retval (1, list.size (), 0.0);
 
   int num_open = 0;
 
   for (ostrl_map::const_iterator p = list.begin (); p != list.end (); p++)
     {
       // Skip stdin, stdout, and stderr.
-
       if (p->first > 2 && p->second)
         retval(0,num_open++) = p->first;
     }
 
   retval.resize ((num_open > 0), num_open);
 
   return retval;
 }
@@ -4470,19 +4409,17 @@ octave_stream_list::do_get_file_number (
   int retval = -1;
 
   if (fid.is_string ())
     {
       std::string nm = fid.string_value ();
 
       for (ostrl_map::const_iterator p = list.begin (); p != list.end (); p++)
         {
-          // stdin (std::cin), stdout (std::cout), and stderr (std::cerr)
-          // are unnamed.
-
+          // stdin, stdout, and stderr are unnamed.
           if (p->first > 2)
             {
               octave_stream os = p->second;
 
               if (os && os.name () == nm)
                 {
                   retval = p->first;
                   break;
@@ -4493,14 +4430,14 @@ octave_stream_list::do_get_file_number (
   else
     {
       int conv_err = 0;
 
       int int_fid = convert_to_valid_int (fid, conv_err);
 
       if (conv_err)
         ::error ("file id must be a file object, std::string, or integer value");
-      else
-        retval = int_fid;
+
+      retval = int_fid;
     }
 
   return retval;
 }
diff --git a/libinterp/corefcn/oct-strstrm.cc b/libinterp/corefcn/oct-strstrm.cc
--- a/libinterp/corefcn/oct-strstrm.cc
+++ b/libinterp/corefcn/oct-strstrm.cc
@@ -26,25 +26,29 @@ along with Octave; see the file COPYING.
 
 #include "oct-strstrm.h"
 
 // Position a stream at OFFSET relative to ORIGIN.
 
 int
 octave_base_strstream::seek (off_t, int)
 {
+  // Note: error() is inherited from octave_base_stream, not ::error().
+  // This error function does not halt execution so "return ..." must exist.
   error ("fseek: invalid operation");
   return -1;
 }
 
 // Return current stream position.
 
 off_t
 octave_base_strstream::tell (void)
 {
+  // Note: error() is inherited from octave_base_stream, not ::error().
+  // This error function does not halt execution so "return ..." must exist.
   error ("ftell: invalid operation");
   return -1;
 }
 
 octave_stream
 octave_istrstream::create (const char *data, std::ios::openmode arg_md,
                            oct_mach_info::float_format flt_fmt)
 {
