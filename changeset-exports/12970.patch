# HG changeset patch
# User Ben Abbott  <bpabbott@mac.com>
# Date 1313448496 14400
#      Mon Aug 15 18:48:16 2011 -0400
# Node ID 7b4ec6f841a251ac4a1b6e21f37312cc2a0d1894
# Parent  6fc2c61660f2f606ba0488e564e435fd53777cb0
Update sources for gl2ps.

* gl2ps.h: Update to version 1.3.5.
* gl2ps.c: Ditto.

diff --git a/src/gl2ps.c b/src/gl2ps.c
--- a/src/gl2ps.c
+++ b/src/gl2ps.c
@@ -45,17 +45,17 @@
 #if defined(GL2PS_HAVE_ZLIB)
 #include <zlib.h>
 #endif
 
 #if defined(GL2PS_HAVE_LIBPNG)
 #include <png.h>
 #endif
 
-/*********************************************************************
+/********************************************************************* 
  *
  * Private definitions, data structures and prototypes
  *
  *********************************************************************/
 
 /* Magic numbers (assuming that the order of magnitude of window
    coordinates is 10^3) */
 
@@ -162,17 +162,16 @@ typedef struct {
 } GL2PSstring;
 
 typedef struct {
   GLsizei width, height;
   /* Note: for an imagemap, 'type' indicates if it has already been
      written to the file or not, and 'format' indicates if it is
      visible or not */
   GLenum format, type;
-  GLfloat zoom_x, zoom_y;
   GLfloat *pixels;
 } GL2PSimage;
 
 typedef struct _GL2PSimagemap GL2PSimagemap;
 
 struct _GL2PSimagemap {
   GL2PSimage *image;
   GL2PSimagemap *next;
@@ -223,17 +222,17 @@ typedef struct {
 
   /* BSP-specific */
   GLint maxbestroot;
 
   /* Occlusion culling-specific */
   GLboolean zerosurfacearea;
   GL2PSbsptree2d *imagetree;
   GL2PSprimitive *primitivetoadd;
-
+  
   /* PDF-specific */
   int streamlength;
   GL2PSlist *pdfprimlist, *pdfgrouplist;
   int *xreflist;
   int objects_stack; /* available objects */
   int extgs_stack; /* graphics state object number */
   int font_stack; /* font object number */
   int im_stack; /* image object number */
@@ -261,34 +260,34 @@ typedef struct {
    local GL2PScontext during gl2psBeginPage) */
 
 static GL2PScontext *gl2ps = NULL;
 
 /* Need to forward-declare this one */
 
 static GLint gl2psPrintPrimitives(void);
 
-/*********************************************************************
+/********************************************************************* 
  *
  * Utility routines
  *
  *********************************************************************/
 
 static void gl2psMsg(GLint level, const char *fmt, ...)
 {
   va_list args;
 
   if(!(gl2ps->options & GL2PS_SILENT)){
     switch(level){
     case GL2PS_INFO : fprintf(stderr, "GL2PS info: "); break;
     case GL2PS_WARNING : fprintf(stderr, "GL2PS warning: "); break;
     case GL2PS_ERROR : fprintf(stderr, "GL2PS error: "); break;
     }
     va_start(args, fmt);
-    vfprintf(stderr, fmt, args);
+    vfprintf(stderr, fmt, args); 
     va_end(args);
     fprintf(stderr, "\n");
   }
   /* if(level == GL2PS_ERROR) exit(1); */
 }
 
 static void *gl2psMalloc(size_t size)
 {
@@ -355,45 +354,45 @@ static void gl2psFreeCompress(void)
   gl2ps->compress->dest = NULL;
   gl2ps->compress->srcLen = 0;
   gl2ps->compress->destLen = 0;
 }
 
 static int gl2psAllocCompress(unsigned int srcsize)
 {
   gl2psFreeCompress();
-
+  
   if(!gl2ps->compress || !srcsize)
     return GL2PS_ERROR;
-
+  
   gl2ps->compress->srcLen = srcsize;
   gl2ps->compress->destLen = (int)ceil(1.001 * gl2ps->compress->srcLen + 12);
   gl2ps->compress->src = (Bytef*)gl2psMalloc(gl2ps->compress->srcLen);
   gl2ps->compress->start = gl2ps->compress->src;
   gl2ps->compress->dest = (Bytef*)gl2psMalloc(gl2ps->compress->destLen);
-
+  
   return GL2PS_SUCCESS;
 }
 
 static void *gl2psReallocCompress(unsigned int srcsize)
 {
   if(!gl2ps->compress || !srcsize)
     return NULL;
-
+  
   if(srcsize < gl2ps->compress->srcLen)
     return gl2ps->compress->start;
-
+  
   gl2ps->compress->srcLen = srcsize;
   gl2ps->compress->destLen = (int)ceil(1.001 * gl2ps->compress->srcLen + 12);
-  gl2ps->compress->src = (Bytef*)gl2psRealloc(gl2ps->compress->src,
+  gl2ps->compress->src = (Bytef*)gl2psRealloc(gl2ps->compress->src, 
                                               gl2ps->compress->srcLen);
   gl2ps->compress->start = gl2ps->compress->src;
-  gl2ps->compress->dest = (Bytef*)gl2psRealloc(gl2ps->compress->dest,
+  gl2ps->compress->dest = (Bytef*)gl2psRealloc(gl2ps->compress->dest, 
                                                gl2ps->compress->destLen);
-
+  
   return gl2ps->compress->start;
 }
 
 static size_t gl2psWriteBigEndianCompress(unsigned long data, size_t bytes)
 {
   size_t i;
   size_t size = sizeof(unsigned long);
   for(i = 1; i <= bytes; ++i){
@@ -402,18 +401,18 @@ static size_t gl2psWriteBigEndianCompres
   }
   return bytes;
 }
 
 static int gl2psDeflate(void)
 {
   /* For compatibility with older zlib versions, we use compress(...)
      instead of compress2(..., Z_BEST_COMPRESSION) */
-  return compress(gl2ps->compress->dest, &gl2ps->compress->destLen,
-                  gl2ps->compress->start, gl2ps->compress->srcLen);
+  return compress(gl2ps->compress->dest, &gl2ps->compress->destLen, 
+                  gl2ps->compress->start, gl2ps->compress->srcLen);  
 }
 
 #endif
 
 static int gl2psPrintf(const char* fmt, ...)
 {
   int ret;
   va_list args;
@@ -451,17 +450,17 @@ static void gl2psPrintGzipHeader()
                   2, /* extra flags: max compression */
                   '\x03'}; /* OS code: 0x03 (Unix) */
 
   if(gl2ps->options & GL2PS_COMPRESS){
     gl2psSetupCompress();
     /* add the gzip file header */
     fwrite(tmp, 10, 1, gl2ps->stream);
   }
-#endif
+#endif  
 }
 
 static void gl2psPrintGzipFooter()
 {
 #if defined(GL2PS_HAVE_ZLIB)
   int n;
   uLong crc, len;
   char tmp[8];
@@ -472,17 +471,17 @@ static void gl2psPrintGzipFooter()
     }
     else{
       /* determine the length of the header in the zlib stream */
       n = 2; /* CMF+FLG */
       if(gl2ps->compress->dest[1] & (1<<5)){
         n += 4; /* DICTID */
       }
       /* write the data, without the zlib header and footer */
-      fwrite(gl2ps->compress->dest+n, gl2ps->compress->destLen-(n+4),
+      fwrite(gl2ps->compress->dest+n, gl2ps->compress->destLen-(n+4), 
              1, gl2ps->stream);
       /* add the gzip file footer */
       crc = crc32(0L, gl2ps->compress->start, gl2ps->compress->srcLen);
       for(n = 0; n < 4; ++n){
         tmp[n] = (char)(crc & 0xff);
         crc >>= 8;
       }
       len = gl2ps->compress->srcLen;
@@ -491,17 +490,17 @@ static void gl2psPrintGzipFooter()
         len >>= 8;
       }
       fwrite(tmp, 8, 1, gl2ps->stream);
     }
     gl2psFreeCompress();
     gl2psFree(gl2ps->compress);
     gl2ps->compress = NULL;
   }
-#endif
+#endif 
 }
 
 /* The list handling routines */
 
 static void gl2psListRealloc(GL2PSlist *list, GLint n)
 {
   if(!list){
     gl2psMsg(GL2PS_ERROR, "Cannot reallocate NULL list");
@@ -540,17 +539,17 @@ static GL2PSlist *gl2psListCreate(GLint 
 static void gl2psListReset(GL2PSlist *list)
 {
   if(!list) return;
   list->n = 0;
 }
 
 static void gl2psListDelete(GL2PSlist *list)
 {
-  if(!list) return;
+  if(!list) return;  
   gl2psFree(list->array);
   gl2psFree(list);
 }
 
 static void gl2psListAdd(GL2PSlist *list, void *data)
 {
   if(!list){
     gl2psMsg(GL2PS_ERROR, "Cannot add into unallocated list");
@@ -613,17 +612,17 @@ static void gl2psListRead(GL2PSlist *lis
 {
   if((index < 0) || (index >= list->n))
     gl2psMsg(GL2PS_ERROR, "Wrong list index in gl2psListRead");
   memcpy(data, &list->array[index * list->size], list->size);
 }
 
 static void gl2psEncodeBase64Block(unsigned char in[3], unsigned char out[4], int len)
 {
-  static const char cb64[] =
+  static const char cb64[] = 
     "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
 
   out[0] = cb64[ in[0] >> 2 ];
   out[1] = cb64[ ((in[0] & 0x03) << 4) | ((in[1] & 0xf0) >> 4) ];
   out[2] = (len > 1) ? cb64[ ((in[1] & 0x0f) << 2) | ((in[2] & 0xc0) >> 6) ] : '=';
   out[3] = (len > 2) ? cb64[ in[2] & 0x3f ] : '=';
 }
 
@@ -666,17 +665,17 @@ static void gl2psListEncodeBase64(GL2PSl
 static GLboolean gl2psSameColor(GL2PSrgba rgba1, GL2PSrgba rgba2)
 {
   if(!GL2PS_ZERO(rgba1[0] - rgba2[0]) ||
      !GL2PS_ZERO(rgba1[1] - rgba2[1]) ||
      !GL2PS_ZERO(rgba1[2] - rgba2[2]))
     return GL_FALSE;
   return GL_TRUE;
 }
-
+  
 static GLboolean gl2psVertsSameColor(const GL2PSprimitive *prim)
 {
   int i;
 
   for(i = 1; i < prim->numverts; i++){
     if(!gl2psSameColor(prim->verts[0].rgba, prim->verts[i].rgba)){
       return GL_FALSE;
     }
@@ -685,45 +684,45 @@ static GLboolean gl2psVertsSameColor(con
 }
 
 static GLboolean gl2psSameColorThreshold(int n, GL2PSrgba rgba[],
                                          GL2PSrgba threshold)
 {
   int i;
 
   if(n < 2) return GL_TRUE;
-
+  
   for(i = 1; i < n; i++){
     if(fabs(rgba[0][0] - rgba[i][0]) > threshold[0] ||
        fabs(rgba[0][1] - rgba[i][1]) > threshold[1] ||
        fabs(rgba[0][2] - rgba[i][2]) > threshold[2])
       return GL_FALSE;
   }
-
+  
   return GL_TRUE;
 }
 
 static void gl2psSetLastColor(GL2PSrgba rgba)
 {
-  int i;
+  int i;        
   for(i = 0; i < 3; ++i){
     gl2ps->lastrgba[i] = rgba[i];
   }
 }
 
 static GLfloat gl2psGetRGB(GL2PSimage *im, GLuint x, GLuint y,
                            GLfloat *red, GLfloat *green, GLfloat *blue)
 {
-
+  
   GLsizei width = im->width;
   GLsizei height = im->height;
   GLfloat *pixels = im->pixels;
   GLfloat *pimag;
 
-  /* OpenGL image is from down to up, PS image is up to down */
+  /* OpenGL image is from down to up, PS image is up to down */  
   switch(im->format){
   case GL_RGBA:
     pimag = pixels + 4 * (width * (height - 1 - y) + x);
     break;
   case GL_RGB:
   default:
     pimag = pixels + 3 * (width * (height - 1 - y) + x);
     break;
@@ -736,37 +735,35 @@ static GLfloat gl2psGetRGB(GL2PSimage *i
 }
 
 /* Helper routines for pixmaps */
 
 static GL2PSimage *gl2psCopyPixmap(GL2PSimage *im)
 {
   int size;
   GL2PSimage *image = (GL2PSimage*)gl2psMalloc(sizeof(GL2PSimage));
-
+  
   image->width = im->width;
   image->height = im->height;
   image->format = im->format;
   image->type = im->type;
-  image->zoom_x = im->zoom_x;
-  image->zoom_y = im->zoom_y;
 
   switch(image->format){
   case GL_RGBA:
     size = image->height * image->width * 4 * sizeof(GLfloat);
     break;
   case GL_RGB:
   default:
     size = image->height * image->width * 3 * sizeof(GLfloat);
     break;
   }
 
   image->pixels = (GLfloat*)gl2psMalloc(size);
   memcpy(image->pixels, im->pixels, size);
-
+  
   return image;
 }
 
 static void gl2psFreePixmap(GL2PSimage *im)
 {
   if(!im)
     return;
   gl2psFree(im->pixels);
@@ -778,17 +775,17 @@ static void gl2psFreePixmap(GL2PSimage *
 #if !defined(png_jmpbuf)
 #  define png_jmpbuf(png_ptr) ((png_ptr)->jmpbuf)
 #endif
 
 static void gl2psUserWritePNG(png_structp png_ptr, png_bytep data, png_size_t length)
 {
   unsigned int i;
   GL2PSlist *png = (GL2PSlist*)png_get_io_ptr(png_ptr);
-  for(i = 0; i < length; i++)
+  for(i = 0; i < length; i++) 
     gl2psListAdd(png, &data[i]);
 }
 
 static void gl2psUserFlushPNG(png_structp png_ptr)
 {
 }
 
 static void gl2psConvertPixmapToPNG(GL2PSimage *pixmap, GL2PSlist *png)
@@ -796,31 +793,31 @@ static void gl2psConvertPixmapToPNG(GL2P
   png_structp png_ptr;
   png_infop info_ptr;
   unsigned char *row_data;
   GLfloat dr, dg, db;
   int row, col;
 
   if(!(png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL)))
     return;
-
+  
   if(!(info_ptr = png_create_info_struct(png_ptr))){
     png_destroy_write_struct(&png_ptr, NULL);
     return;
   }
-
+  
   if(setjmp(png_jmpbuf(png_ptr))) {
     png_destroy_write_struct(&png_ptr, &info_ptr);
     return;
   }
-
+  
   png_set_write_fn(png_ptr, (void *)png, gl2psUserWritePNG, gl2psUserFlushPNG);
   png_set_compression_level(png_ptr, Z_DEFAULT_COMPRESSION);
-  png_set_IHDR(png_ptr, info_ptr, pixmap->width, pixmap->height, 8,
-               PNG_COLOR_TYPE_RGB, PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_BASE,
+  png_set_IHDR(png_ptr, info_ptr, pixmap->width, pixmap->height, 8, 
+               PNG_COLOR_TYPE_RGB, PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_BASE, 
                PNG_FILTER_TYPE_BASE);
   png_write_info(png_ptr, info_ptr);
 
   row_data = (unsigned char*)gl2psMalloc(3 * pixmap->width * sizeof(unsigned char));
   for(row = 0; row < pixmap->height; row++){
     for(col = 0; col < pixmap->width; col++){
       gl2psGetRGB(pixmap, col, row, &dr, &dg, &db);
       row_data[3*col] = (unsigned char)(255. * dr);
@@ -834,17 +831,17 @@ static void gl2psConvertPixmapToPNG(GL2P
   png_write_end(png_ptr, info_ptr);
   png_destroy_write_struct(&png_ptr, &info_ptr);
 }
 
 #endif
 
 /* Helper routines for text strings */
 
-static GLint gl2psAddText(GLint type, const char *str, const char *fontname,
+static GLint gl2psAddText(GLint type, const char *str, const char *fontname, 
                           GLshort fontsize, GLint alignment, GLfloat angle)
 {
   GLfloat pos[4];
   GL2PSprimitive *prim;
   GLboolean valid;
 
   if(!gl2ps || !str || !fontname) return GL2PS_UNINITIALIZED;
 
@@ -866,40 +863,40 @@ static GLint gl2psAddText(GLint type, co
   prim->culled = 0;
   prim->offset = 0;
   prim->pattern = 0;
   prim->factor = 0;
   prim->width = 1;
   glGetFloatv(GL_CURRENT_RASTER_COLOR, prim->verts[0].rgba);
   prim->data.text = (GL2PSstring*)gl2psMalloc(sizeof(GL2PSstring));
   prim->data.text->str = (char*)gl2psMalloc((strlen(str)+1)*sizeof(char));
-  strcpy(prim->data.text->str, str);
+  strcpy(prim->data.text->str, str); 
   prim->data.text->fontname = (char*)gl2psMalloc((strlen(fontname)+1)*sizeof(char));
   strcpy(prim->data.text->fontname, fontname);
   prim->data.text->fontsize = fontsize;
   prim->data.text->alignment = alignment;
   prim->data.text->angle = angle;
 
   gl2psListAdd(gl2ps->auxprimitives, &prim);
   glPassThrough(GL2PS_TEXT_TOKEN);
-
+    
   return GL2PS_SUCCESS;
 }
 
 static GL2PSstring *gl2psCopyText(GL2PSstring *t)
 {
   GL2PSstring *text = (GL2PSstring*)gl2psMalloc(sizeof(GL2PSstring));
   text->str = (char*)gl2psMalloc((strlen(t->str)+1)*sizeof(char));
-  strcpy(text->str, t->str);
+  strcpy(text->str, t->str); 
   text->fontname = (char*)gl2psMalloc((strlen(t->fontname)+1)*sizeof(char));
   strcpy(text->fontname, t->fontname);
   text->fontsize = t->fontsize;
   text->alignment = t->alignment;
   text->angle = t->angle;
-
+  
   return text;
 }
 
 static void gl2psFreeText(GL2PSstring *text)
 {
   if(!text)
     return;
   gl2psFree(text->str);
@@ -909,17 +906,17 @@ static void gl2psFreeText(GL2PSstring *t
 
 /* Helpers for blending modes */
 
 static GLboolean gl2psSupportedBlendMode(GLenum sfactor, GLenum dfactor)
 {
   /* returns TRUE if gl2ps supports the argument combination: only two
      blending modes have been implemented so far */
 
-  if( (sfactor == GL_SRC_ALPHA && dfactor == GL_ONE_MINUS_SRC_ALPHA) ||
+  if( (sfactor == GL_SRC_ALPHA && dfactor == GL_ONE_MINUS_SRC_ALPHA) || 
       (sfactor == GL_ONE && dfactor == GL_ZERO) )
     return GL_TRUE;
   return GL_FALSE;
 }
 
 static void gl2psAdaptVertexForBlending(GL2PSvertex *v)
 {
   /* Transforms vertex depending on the actual blending function -
@@ -929,17 +926,17 @@ static void gl2psAdaptVertexForBlending(
 
   if(!v || !gl2ps)
     return;
 
   if(gl2ps->options & GL2PS_NO_BLENDING || !gl2ps->blending){
     v->rgba[3] = 1.0F;
     return;
   }
-
+  
   switch(gl2ps->blendfunc[0]){
   case GL_ONE:
     v->rgba[3] = 1.0F;
     break;
   default:
     break;
   }
 }
@@ -950,27 +947,27 @@ static void gl2psAssignTrianglePropertie
 
   t->prop = T_VAR_COLOR;
 
   /* Uncommenting the following lines activates an even more fine
      grained distinction between triangle types - please don't delete,
      a remarkable amount of PDF handling code inside this file depends
      on it if activated */
   /*
-  t->prop = T_CONST_COLOR;
+  t->prop = T_CONST_COLOR;    
   for(i = 0; i < 3; ++i){
-    if(!GL2PS_ZERO(t->vertex[0].rgba[i] - t->vertex[1].rgba[i]) ||
+    if(!GL2PS_ZERO(t->vertex[0].rgba[i] - t->vertex[1].rgba[i]) || 
        !GL2PS_ZERO(t->vertex[1].rgba[i] - t->vertex[2].rgba[i])){
       t->prop = T_VAR_COLOR;
       break;
     }
   }
   */
 
-  if(!GL2PS_ZERO(t->vertex[0].rgba[3] - t->vertex[1].rgba[3]) ||
+  if(!GL2PS_ZERO(t->vertex[0].rgba[3] - t->vertex[1].rgba[3]) || 
      !GL2PS_ZERO(t->vertex[1].rgba[3] - t->vertex[2].rgba[3])){
     t->prop |= T_VAR_ALPHA;
   }
   else{
     if(t->vertex[0].rgba[3] < 1)
       t->prop |= T_ALPHA_LESS_1;
     else
       t->prop |= T_ALPHA_1;
@@ -1003,17 +1000,17 @@ static GL2PSprimitive *gl2psCopyPrimitiv
   GL2PSprimitive *prim;
 
   if(!p){
     gl2psMsg(GL2PS_ERROR, "Trying to copy an empty primitive");
     return NULL;
   }
 
   prim = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
-
+  
   prim->type = p->type;
   prim->numverts = p->numverts;
   prim->boundary = p->boundary;
   prim->offset = p->offset;
   prim->pattern = p->pattern;
   prim->factor = p->factor;
   prim->culled = p->culled;
   prim->width = p->width;
@@ -1039,27 +1036,27 @@ static GLboolean gl2psSamePosition(GL2PS
 {
   if(!GL2PS_ZERO(p1[0] - p2[0]) ||
      !GL2PS_ZERO(p1[1] - p2[1]) ||
      !GL2PS_ZERO(p1[2] - p2[2]))
     return GL_FALSE;
   return GL_TRUE;
 }
 
-/*********************************************************************
+/********************************************************************* 
  *
- * 3D sorting routines
+ * 3D sorting routines 
  *
  *********************************************************************/
 
 static GLfloat gl2psComparePointPlane(GL2PSxyz point, GL2PSplane plane)
 {
-  return (plane[0] * point[0] +
-          plane[1] * point[1] +
-          plane[2] * point[2] +
+  return (plane[0] * point[0] + 
+          plane[1] * point[1] + 
+          plane[2] * point[2] + 
           plane[3]);
 }
 
 static GLfloat gl2psPsca(GLfloat *a, GLfloat *b)
 {
   return (a[0]*b[0] + a[1]*b[1] + a[2]*b[2]);
 }
 
@@ -1096,53 +1093,53 @@ static void gl2psGetNormal(GLfloat *a, G
 
 static void gl2psGetPlane(GL2PSprimitive *prim, GL2PSplane plane)
 {
   GL2PSxyz v = {0.0F, 0.0F, 0.0F}, w = {0.0F, 0.0F, 0.0F};
 
   switch(prim->type){
   case GL2PS_TRIANGLE :
   case GL2PS_QUADRANGLE :
-    v[0] = prim->verts[1].xyz[0] - prim->verts[0].xyz[0];
-    v[1] = prim->verts[1].xyz[1] - prim->verts[0].xyz[1];
-    v[2] = prim->verts[1].xyz[2] - prim->verts[0].xyz[2];
-    w[0] = prim->verts[2].xyz[0] - prim->verts[0].xyz[0];
-    w[1] = prim->verts[2].xyz[1] - prim->verts[0].xyz[1];
-    w[2] = prim->verts[2].xyz[2] - prim->verts[0].xyz[2];
-    if((GL2PS_ZERO(v[0]) && GL2PS_ZERO(v[1]) && GL2PS_ZERO(v[2])) ||
+    v[0] = prim->verts[1].xyz[0] - prim->verts[0].xyz[0]; 
+    v[1] = prim->verts[1].xyz[1] - prim->verts[0].xyz[1]; 
+    v[2] = prim->verts[1].xyz[2] - prim->verts[0].xyz[2]; 
+    w[0] = prim->verts[2].xyz[0] - prim->verts[0].xyz[0]; 
+    w[1] = prim->verts[2].xyz[1] - prim->verts[0].xyz[1]; 
+    w[2] = prim->verts[2].xyz[2] - prim->verts[0].xyz[2]; 
+    if((GL2PS_ZERO(v[0]) && GL2PS_ZERO(v[1]) && GL2PS_ZERO(v[2])) || 
        (GL2PS_ZERO(w[0]) && GL2PS_ZERO(w[1]) && GL2PS_ZERO(w[2]))){
       plane[0] = plane[1] = 0.0F;
       plane[2] = 1.0F;
       plane[3] = -prim->verts[0].xyz[2];
     }
     else{
       gl2psGetNormal(v, w, plane);
-      plane[3] =
-        - plane[0] * prim->verts[0].xyz[0]
-        - plane[1] * prim->verts[0].xyz[1]
+      plane[3] = 
+        - plane[0] * prim->verts[0].xyz[0] 
+        - plane[1] * prim->verts[0].xyz[1] 
         - plane[2] * prim->verts[0].xyz[2];
     }
     break;
   case GL2PS_LINE :
-    v[0] = prim->verts[1].xyz[0] - prim->verts[0].xyz[0];
-    v[1] = prim->verts[1].xyz[1] - prim->verts[0].xyz[1];
-    v[2] = prim->verts[1].xyz[2] - prim->verts[0].xyz[2];
+    v[0] = prim->verts[1].xyz[0] - prim->verts[0].xyz[0]; 
+    v[1] = prim->verts[1].xyz[1] - prim->verts[0].xyz[1]; 
+    v[2] = prim->verts[1].xyz[2] - prim->verts[0].xyz[2]; 
     if(GL2PS_ZERO(v[0]) && GL2PS_ZERO(v[1]) && GL2PS_ZERO(v[2])){
       plane[0] = plane[1] = 0.0F;
       plane[2] = 1.0F;
       plane[3] = -prim->verts[0].xyz[2];
     }
     else{
       if(GL2PS_ZERO(v[0]))      w[0] = 1.0F;
       else if(GL2PS_ZERO(v[1])) w[1] = 1.0F;
       else                      w[2] = 1.0F;
       gl2psGetNormal(v, w, plane);
-      plane[3] =
-        - plane[0] * prim->verts[0].xyz[0]
-        - plane[1] * prim->verts[0].xyz[1]
+      plane[3] = 
+        - plane[0] * prim->verts[0].xyz[0] 
+        - plane[1] * prim->verts[0].xyz[1] 
         - plane[2] * prim->verts[0].xyz[2];
     }
     break;
   case GL2PS_POINT :
   case GL2PS_PIXMAP :
   case GL2PS_TEXT :
   case GL2PS_SPECIAL :
   case GL2PS_IMAGEMAP:
@@ -1167,21 +1164,21 @@ static void gl2psCutEdge(GL2PSvertex *a,
   v[0] = b->xyz[0] - a->xyz[0];
   v[1] = b->xyz[1] - a->xyz[1];
   v[2] = b->xyz[2] - a->xyz[2];
 
   if(!GL2PS_ZERO(psca = gl2psPsca(plane, v)))
     sect = -gl2psComparePointPlane(a->xyz, plane) / psca;
   else
     sect = 0.0F;
-
+  
   c->xyz[0] = a->xyz[0] + v[0] * sect;
   c->xyz[1] = a->xyz[1] + v[1] * sect;
   c->xyz[2] = a->xyz[2] + v[2] * sect;
-
+  
   c->rgba[0] = (1 - sect) * a->rgba[0] + sect * b->rgba[0];
   c->rgba[1] = (1 - sect) * a->rgba[1] + sect * b->rgba[1];
   c->rgba[2] = (1 - sect) * a->rgba[2] + sect * b->rgba[2];
   c->rgba[3] = (1 - sect) * a->rgba[3] + sect * b->rgba[3];
 }
 
 static void gl2psCreateSplitPrimitive(GL2PSprimitive *parent, GL2PSplane plane,
                                       GL2PSprimitive *child, GLshort numverts,
@@ -1194,20 +1191,20 @@ static void gl2psCreateSplitPrimitive(GL
     child->data.image = parent->data.image;
   }
   else{
     if(numverts > 4){
       gl2psMsg(GL2PS_WARNING, "%d vertices in polygon", numverts);
       numverts = 4;
     }
     switch(numverts){
-    case 1 : child->type = GL2PS_POINT; break;
-    case 2 : child->type = GL2PS_LINE; break;
-    case 3 : child->type = GL2PS_TRIANGLE; break;
-    case 4 : child->type = GL2PS_QUADRANGLE; break;
+    case 1 : child->type = GL2PS_POINT; break; 
+    case 2 : child->type = GL2PS_LINE; break; 
+    case 3 : child->type = GL2PS_TRIANGLE; break; 
+    case 4 : child->type = GL2PS_QUADRANGLE; break;    
     default: child->type = GL2PS_NO_TYPE; break;
     }
   }
 
   child->boundary = 0; /* FIXME: not done! */
   child->culled = parent->culled;
   child->offset = parent->offset;
   child->pattern = parent->pattern;
@@ -1216,23 +1213,23 @@ static void gl2psCreateSplitPrimitive(GL
   child->numverts = numverts;
   child->verts = (GL2PSvertex*)gl2psMalloc(numverts * sizeof(GL2PSvertex));
 
   for(i = 0; i < numverts; i++){
     if(index1[i] < 0){
       child->verts[i] = parent->verts[index0[i]];
     }
     else{
-      gl2psCutEdge(&parent->verts[index0[i]], &parent->verts[index1[i]],
+      gl2psCutEdge(&parent->verts[index0[i]], &parent->verts[index1[i]], 
                    plane, &child->verts[i]);
     }
   }
 }
 
-static void gl2psAddIndex(GLshort *index0, GLshort *index1, GLshort *nb,
+static void gl2psAddIndex(GLshort *index0, GLshort *index1, GLshort *nb, 
                           GLshort i, GLshort j)
 {
   GLint k;
 
   for(k = 0; k < *nb; k++){
     if((index0[k] == i && index1[k] == j) ||
        (index1[k] == i && index0[k] == j)) return;
   }
@@ -1245,77 +1242,77 @@ static GLshort gl2psGetIndex(GLshort i, 
 {
   return (i < num - 1) ? i + 1 : 0;
 }
 
 static GLint gl2psTestSplitPrimitive(GL2PSprimitive *prim, GL2PSplane plane)
 {
   GLint type = GL2PS_COINCIDENT;
   GLshort i, j;
-  GLfloat d[5];
-
-  for(i = 0; i < prim->numverts; i++){
+  GLfloat d[5]; 
+
+  for(i = 0; i < prim->numverts; i++){  
     d[i] = gl2psComparePointPlane(prim->verts[i].xyz, plane);
   }
 
   if(prim->numverts < 2){
     return 0;
   }
   else{
     for(i = 0; i < prim->numverts; i++){
       j = gl2psGetIndex(i, prim->numverts);
       if(d[j] > GL2PS_EPSILON){
         if(type == GL2PS_COINCIDENT)      type = GL2PS_IN_BACK_OF;
-        else if(type != GL2PS_IN_BACK_OF) return 1;
+        else if(type != GL2PS_IN_BACK_OF) return 1; 
         if(d[i] < -GL2PS_EPSILON)         return 1;
       }
       else if(d[j] < -GL2PS_EPSILON){
-        if(type == GL2PS_COINCIDENT)       type = GL2PS_IN_FRONT_OF;
+        if(type == GL2PS_COINCIDENT)       type = GL2PS_IN_FRONT_OF;   
         else if(type != GL2PS_IN_FRONT_OF) return 1;
         if(d[i] > GL2PS_EPSILON)           return 1;
       }
     }
   }
   return 0;
 }
 
-static GLint gl2psSplitPrimitive(GL2PSprimitive *prim, GL2PSplane plane,
+static GLint gl2psSplitPrimitive(GL2PSprimitive *prim, GL2PSplane plane, 
                                  GL2PSprimitive **front, GL2PSprimitive **back)
 {
   GLshort i, j, in = 0, out = 0, in0[5], in1[5], out0[5], out1[5];
   GLint type;
-  GLfloat d[5];
+  GLfloat d[5]; 
 
   type = GL2PS_COINCIDENT;
 
-  for(i = 0; i < prim->numverts; i++){
+  for(i = 0; i < prim->numverts; i++){  
     d[i] = gl2psComparePointPlane(prim->verts[i].xyz, plane);
   }
 
   switch(prim->type){
   case GL2PS_POINT :
     if(d[0] > GL2PS_EPSILON)       type = GL2PS_IN_BACK_OF;
     else if(d[0] < -GL2PS_EPSILON) type = GL2PS_IN_FRONT_OF;
     else                           type = GL2PS_COINCIDENT;
     break;
   default :
     for(i = 0; i < prim->numverts; i++){
       j = gl2psGetIndex(i, prim->numverts);
       if(d[j] > GL2PS_EPSILON){
         if(type == GL2PS_COINCIDENT)      type = GL2PS_IN_BACK_OF;
-        else if(type != GL2PS_IN_BACK_OF) type = GL2PS_SPANNING;
+        else if(type != GL2PS_IN_BACK_OF) type = GL2PS_SPANNING; 
         if(d[i] < -GL2PS_EPSILON){
           gl2psAddIndex(in0, in1, &in, i, j);
           gl2psAddIndex(out0, out1, &out, i, j);
           type = GL2PS_SPANNING;
         }
         gl2psAddIndex(out0, out1, &out, j, -1);
       }
       else if(d[j] < -GL2PS_EPSILON){
-        if(type == GL2PS_COINCIDENT)       type = GL2PS_IN_FRONT_OF;
+        if(type == GL2PS_COINCIDENT)       type = GL2PS_IN_FRONT_OF;   
         else if(type != GL2PS_IN_FRONT_OF) type = GL2PS_SPANNING;
         if(d[i] > GL2PS_EPSILON){
           gl2psAddIndex(in0, in1, &in, i, j);
           gl2psAddIndex(out0, out1, &out, i, j);
           type = GL2PS_SPANNING;
         }
         gl2psAddIndex(in0, in1, &in, j, -1);
       }
@@ -1332,17 +1329,17 @@ static GLint gl2psSplitPrimitive(GL2PSpr
     *front = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
     gl2psCreateSplitPrimitive(prim, plane, *back, out, out0, out1);
     gl2psCreateSplitPrimitive(prim, plane, *front, in, in0, in1);
   }
 
   return type;
 }
 
-static void gl2psDivideQuad(GL2PSprimitive *quad,
+static void gl2psDivideQuad(GL2PSprimitive *quad, 
                             GL2PSprimitive **t1, GL2PSprimitive **t2)
 {
   *t1 = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
   *t2 = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
   (*t1)->type = (*t2)->type = GL2PS_TRIANGLE;
   (*t1)->numverts = (*t2)->numverts = 3;
   (*t1)->culled = (*t2)->culled = quad->culled;
   (*t1)->offset = (*t2)->offset = quad->offset;
@@ -1361,27 +1358,27 @@ static void gl2psDivideQuad(GL2PSprimiti
   (*t2)->boundary = ((quad->boundary & 4) ? 2 : 0) | ((quad->boundary & 4) ? 2 : 0);
 }
 
 static int gl2psCompareDepth(const void *a, const void *b)
 {
   GL2PSprimitive *q, *w;
   GLfloat dq = 0.0F, dw = 0.0F, diff;
   int i;
-
+  
   q = *(GL2PSprimitive**)a;
   w = *(GL2PSprimitive**)b;
 
   for(i = 0; i < q->numverts; i++){
-    dq += q->verts[i].xyz[2];
+    dq += q->verts[i].xyz[2]; 
   }
   dq /= (GLfloat)q->numverts;
 
   for(i = 0; i < w->numverts; i++){
-    dw += w->verts[i].xyz[2];
+    dw += w->verts[i].xyz[2]; 
   }
   dw /= (GLfloat)w->numverts;
 
   diff = dq - dw;
   if(diff > 0.){
     return -1;
   }
   else if(diff < 0.){
@@ -1422,17 +1419,17 @@ static GLint gl2psFindRoot(GL2PSlist *pr
     }
     for(i = 0; i < maxp; i++){
       prim1 = *(GL2PSprimitive**)gl2psListPointer(primitives, i);
       gl2psGetPlane(prim1, plane);
       count = 0;
       for(j = 0; j < gl2psListNbr(primitives); j++){
         if(j != i){
           prim2 = *(GL2PSprimitive**)gl2psListPointer(primitives, j);
-          count += gl2psTestSplitPrimitive(prim2, plane);
+          count += gl2psTestSplitPrimitive(prim2, plane); 
         }
         if(count > best) break;
       }
       if(count < best){
         best = count;
         index = i;
         *root = prim1;
         if(!count) return index;
@@ -1456,17 +1453,17 @@ static void gl2psFreeImagemap(GL2PSimage
     gl2psFree(list);
     list = next;
   }
 }
 
 static void gl2psFreePrimitive(void *data)
 {
   GL2PSprimitive *q;
-
+  
   q = *(GL2PSprimitive**)data;
   gl2psFree(q->verts);
   if(q->type == GL2PS_TEXT || q->type == GL2PS_SPECIAL){
     gl2psFreeText(q->data.text);
   }
   else if(q->type == GL2PS_PIXMAP){
     gl2psFreePixmap(q->data.image);
   }
@@ -1481,17 +1478,17 @@ static void gl2psAddPrimitiveInList(GL2P
     gl2psListAdd(list, &prim);
   }
   else{
     gl2psDivideQuad(prim, &t1, &t2);
     gl2psListAdd(list, &t1);
     gl2psListAdd(list, &t2);
     gl2psFreePrimitive(&prim);
   }
-
+  
 }
 
 static void gl2psFreeBspTree(GL2PSbsptree **tree)
 {
   if(*tree){
     if((*tree)->back) gl2psFreeBspTree(&(*tree)->back);
     if((*tree)->primitives){
       gl2psListAction((*tree)->primitives, gl2psFreePrimitive);
@@ -1593,17 +1590,17 @@ static void gl2psTraverseBspTree(GL2PSbs
     if(inverse){
       gl2psListActionInverse(tree->primitives, action);
     }
     else{
       gl2psListAction(tree->primitives, action);
     }
     gl2psTraverseBspTree(tree->front, eye, epsilon, compare, action, inverse);
   }
-  else if(GL_TRUE == compare(-epsilon, result)){
+  else if(GL_TRUE == compare(-epsilon, result)){ 
     gl2psTraverseBspTree(tree->front, eye, epsilon, compare, action, inverse);
     if(inverse){
       gl2psListActionInverse(tree->primitives, action);
     }
     else{
       gl2psListAction(tree->primitives, action);
     }
     gl2psTraverseBspTree(tree->back, eye, epsilon, compare, action, inverse);
@@ -1661,28 +1658,28 @@ static void gl2psRescaleAndOffset()
       else{
         prim->verts[0].xyz[2] -= GL2PS_ZOFFSET;
         prim->verts[1].xyz[2] -= GL2PS_ZOFFSET;
       }
     }
     else if(prim->offset && (prim->type == GL2PS_TRIANGLE)){
       factor = gl2ps->offset[0];
       units = gl2ps->offset[1];
-      area =
-        (prim->verts[1].xyz[0] - prim->verts[0].xyz[0]) *
-        (prim->verts[2].xyz[1] - prim->verts[1].xyz[1]) -
-        (prim->verts[2].xyz[0] - prim->verts[1].xyz[0]) *
+      area = 
+        (prim->verts[1].xyz[0] - prim->verts[0].xyz[0]) * 
+        (prim->verts[2].xyz[1] - prim->verts[1].xyz[1]) - 
+        (prim->verts[2].xyz[0] - prim->verts[1].xyz[0]) * 
         (prim->verts[1].xyz[1] - prim->verts[0].xyz[1]);
       if(!GL2PS_ZERO(area)){
-        dZdX =
+        dZdX = 
           ((prim->verts[2].xyz[1] - prim->verts[1].xyz[1]) *
            (prim->verts[1].xyz[2] - prim->verts[0].xyz[2]) -
            (prim->verts[1].xyz[1] - prim->verts[0].xyz[1]) *
            (prim->verts[2].xyz[2] - prim->verts[1].xyz[2])) / area;
-        dZdY =
+        dZdY = 
           ((prim->verts[1].xyz[0] - prim->verts[0].xyz[0]) *
            (prim->verts[2].xyz[2] - prim->verts[1].xyz[2]) -
            (prim->verts[2].xyz[0] - prim->verts[1].xyz[0]) *
            (prim->verts[1].xyz[2] - prim->verts[0].xyz[2])) / area;
         maxdZ = (GLfloat)sqrt(dZdX * dZdX + dZdY * dZdY);
       }
       else{
         maxdZ = 0.0F;
@@ -1690,34 +1687,34 @@ static void gl2psRescaleAndOffset()
       dZ = factor * maxdZ + units;
       prim->verts[0].xyz[2] += dZ;
       prim->verts[1].xyz[2] += dZ;
       prim->verts[2].xyz[2] += dZ;
     }
   }
 }
 
-/*********************************************************************
+/********************************************************************* 
  *
- * 2D sorting routines (for occlusion culling)
+ * 2D sorting routines (for occlusion culling) 
  *
  *********************************************************************/
 
 static GLint gl2psGetPlaneFromPoints(GL2PSxyz a, GL2PSxyz b, GL2PSplane plane)
 {
-  GLfloat n;
+  GLfloat n; 
 
   plane[0] = b[1] - a[1];
   plane[1] = a[0] - b[0];
   n = (GLfloat)sqrt(plane[0]*plane[0] + plane[1]*plane[1]);
   plane[2] = 0.0F;
   if(!GL2PS_ZERO(n)){
     plane[0] /= n;
     plane[1] /= n;
-    plane[3] = -plane[0]*a[0]-plane[1]*a[1];
+    plane[3] = -plane[0]*a[0]-plane[1]*a[1]; 
     return 1;
   }
   else{
     plane[0] = -1.0F;
     plane[1] = 0.0F;
     plane[3] = a[0];
     return 0;
   }
@@ -1892,47 +1889,47 @@ static GL2PSprimitive *gl2psCreateSplitP
   child->verts = (GL2PSvertex*)gl2psMalloc(numverts * sizeof(GL2PSvertex));
   for(i = 0; i < numverts; i++){
     child->verts[i] = vertx[i];
   }
   return child;
 }
 
 static void gl2psSplitPrimitive2D(GL2PSprimitive *prim,
-                                  GL2PSplane plane,
-                                  GL2PSprimitive **front,
+                                  GL2PSplane plane, 
+                                  GL2PSprimitive **front, 
                                   GL2PSprimitive **back)
 {
   /* cur will hold the position of the current vertex
      prev will hold the position of the previous vertex
      prev0 will hold the position of the vertex number 0
      v1 and v2 represent the current and previous vertices, respectively
      flag is set if the current vertex should be checked against the plane */
   GLint cur = -1, prev = -1, i, v1 = 0, v2 = 0, flag = 1, prev0 = -1;
-
+  
   /* list of vertices that will go in front and back primitive */
   GL2PSvertex *front_list = NULL, *back_list = NULL;
-
+  
   /* number of vertices in front and back list */
   GLshort front_count = 0, back_count = 0;
 
   for(i = 0; i <= prim->numverts; i++){
     v1 = i;
     if(v1 == prim->numverts){
       if(prim->numverts < 3) break;
       v1 = 0;
       v2 = prim->numverts - 1;
       cur = prev0;
     }
     else if(flag){
       cur = gl2psCheckPoint(prim->verts[v1].xyz, plane);
       if(i == 0){
         prev0 = cur;
       }
-    }
+    } 
     if(((prev == -1) || (prev == cur) || (prev == 0) || (cur == 0)) &&
        (i < prim->numverts)){
       if(cur == GL2PS_POINT_INFRONT){
         front_count++;
         front_list = (GL2PSvertex*)gl2psRealloc(front_list,
                                                 sizeof(GL2PSvertex)*front_count);
         front_list[front_count-1] = prim->verts[v1];
       }
@@ -1977,36 +1974,36 @@ static void gl2psSplitPrimitive2D(GL2PSp
   gl2psFree(front_list);
   gl2psFree(back_list);
 }
 
 static GLint gl2psAddInBspImageTree(GL2PSprimitive *prim, GL2PSbsptree2d **tree)
 {
   GLint ret = 0;
   GL2PSprimitive *frontprim = NULL, *backprim = NULL;
-
+  
   /* FIXME: until we consider the actual extent of text strings and
      pixmaps, never cull them. Otherwise the whole string/pixmap gets
      culled as soon as the reference point is hidden */
-  if(prim->type == GL2PS_PIXMAP ||
-     prim->type == GL2PS_TEXT ||
+  if(prim->type == GL2PS_PIXMAP || 
+     prim->type == GL2PS_TEXT || 
      prim->type == GL2PS_SPECIAL){
     return 1;
   }
 
   if(*tree == NULL){
     if((prim->type != GL2PS_IMAGEMAP) && (GL_FALSE == gl2ps->zerosurfacearea)){
       gl2psAddPlanesInBspTreeImage(gl2ps->primitivetoadd, tree);
     }
     return 1;
   }
   else{
     switch(gl2psCheckPrimitive(prim, (*tree)->plane)){
     case GL2PS_IN_BACK_OF: return gl2psAddInBspImageTree(prim, &(*tree)->back);
-    case GL2PS_IN_FRONT_OF:
+    case GL2PS_IN_FRONT_OF: 
       if((*tree)->front != NULL) return gl2psAddInBspImageTree(prim, &(*tree)->front);
       else                       return 0;
     case GL2PS_SPANNING:
       gl2psSplitPrimitive2D(prim, (*tree)->plane, &frontprim, &backprim);
       ret = gl2psAddInBspImageTree(backprim, &(*tree)->back);
       if((*tree)->front != NULL){
         if(gl2psAddInBspImageTree(frontprim, &(*tree)->front)){
           ret = 1;
@@ -2131,24 +2128,24 @@ static void gl2psBuildPolygonBoundary(GL
   gl2psBuildPolygonBoundary(tree->back);
   for(i = 0; i < gl2psListNbr(tree->primitives); i++){
     prim = *(GL2PSprimitive**)gl2psListPointer(tree->primitives, i);
     if(prim->boundary) gl2psAddBoundaryInList(prim, tree->primitives);
   }
   gl2psBuildPolygonBoundary(tree->front);
 }
 
-/*********************************************************************
+/********************************************************************* 
  *
  * Feedback buffer parser
  *
  *********************************************************************/
 
-static void gl2psAddPolyPrimitive(GLshort type, GLshort numverts,
-                                  GL2PSvertex *verts, GLint offset,
+static void gl2psAddPolyPrimitive(GLshort type, GLshort numverts, 
+                                  GL2PSvertex *verts, GLint offset, 
                                   GLushort pattern, GLint factor,
                                   GLfloat width, char boundary)
 {
   GL2PSprimitive *prim;
 
   prim = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
   prim->type = type;
   prim->numverts = numverts;
@@ -2205,38 +2202,38 @@ static void gl2psParseFeedbackBuffer(GLi
   GL2PSimagemap *node;
 
   current = gl2ps->feedback;
   boundary = gl2ps->boundary = GL_FALSE;
 
   while(used > 0){
 
     if(GL_TRUE == boundary) gl2ps->boundary = GL_TRUE;
-
+    
     switch((GLint)*current){
     case GL_POINT_TOKEN :
       current ++;
       used --;
       i = gl2psGetVertex(&vertices[0], current);
       current += i;
       used    -= i;
-      gl2psAddPolyPrimitive(GL2PS_POINT, 1, vertices, 0,
+      gl2psAddPolyPrimitive(GL2PS_POINT, 1, vertices, 0, 
                             pattern, factor, psize, 0);
       break;
     case GL_LINE_TOKEN :
     case GL_LINE_RESET_TOKEN :
       current ++;
       used --;
       i = gl2psGetVertex(&vertices[0], current);
       current += i;
       used    -= i;
       i = gl2psGetVertex(&vertices[1], current);
       current += i;
       used    -= i;
-      gl2psAddPolyPrimitive(GL2PS_LINE, 2, vertices, 0,
+      gl2psAddPolyPrimitive(GL2PS_LINE, 2, vertices, 0, 
                             pattern, factor, lwidth, 0);
       break;
     case GL_POLYGON_TOKEN :
       count = (GLint)current[1];
       current += 2;
       used -= 2;
       v = vtot = 0;
       while(count > 0 && used > 0){
@@ -2257,94 +2254,92 @@ static void gl2psParseFeedbackBuffer(GLi
             flag = 0;
           gl2psAddPolyPrimitive(GL2PS_TRIANGLE, 3, vertices, offset,
                                 pattern, factor, 1, flag);
           vertices[1] = vertices[2];
         }
         else
           v ++;
       }
-      break;
+      break;      
     case GL_BITMAP_TOKEN :
     case GL_DRAW_PIXEL_TOKEN :
     case GL_COPY_PIXEL_TOKEN :
       current ++;
       used --;
       i = gl2psGetVertex(&vertices[0], current);
       current += i;
       used    -= i;
-      break;
+      break;      
     case GL_PASS_THROUGH_TOKEN :
       switch((GLint)current[1]){
       case GL2PS_BEGIN_OFFSET_TOKEN : offset = 1; break;
       case GL2PS_END_OFFSET_TOKEN : offset = 0; break;
       case GL2PS_BEGIN_BOUNDARY_TOKEN : boundary = GL_TRUE; break;
       case GL2PS_END_BOUNDARY_TOKEN : boundary = GL_FALSE; break;
       case GL2PS_END_STIPPLE_TOKEN : pattern = factor = 0; break;
       case GL2PS_BEGIN_BLEND_TOKEN : gl2ps->blending = GL_TRUE; break;
       case GL2PS_END_BLEND_TOKEN : gl2ps->blending = GL_FALSE; break;
-      case GL2PS_BEGIN_STIPPLE_TOKEN :
+      case GL2PS_BEGIN_STIPPLE_TOKEN : 
         current += 2;
-        used -= 2;
-        pattern = (GLushort)current[1];
+        used -= 2; 
+        pattern = (GLushort)current[1]; 
         current += 2;
-        used -= 2;
-        factor = (GLint)current[1];
+        used -= 2; 
+        factor = (GLint)current[1]; 
         break;
-      case GL2PS_SRC_BLEND_TOKEN :
-        current += 2;
-        used -= 2;
+      case GL2PS_SRC_BLEND_TOKEN : 
+        current += 2; 
+        used -= 2; 
         gl2ps->blendfunc[0] = (GLint)current[1];
         break;
-      case GL2PS_DST_BLEND_TOKEN :
-        current += 2;
-        used -= 2;
+      case GL2PS_DST_BLEND_TOKEN : 
+        current += 2; 
+        used -= 2; 
         gl2ps->blendfunc[1] = (GLint)current[1];
         break;
-      case GL2PS_POINT_SIZE_TOKEN :
-        current += 2;
-        used -= 2;
+      case GL2PS_POINT_SIZE_TOKEN : 
+        current += 2; 
+        used -= 2; 
         psize = current[1];
         break;
-      case GL2PS_LINE_WIDTH_TOKEN :
-        current += 2;
-        used -= 2;
+      case GL2PS_LINE_WIDTH_TOKEN : 
+        current += 2; 
+        used -= 2; 
         lwidth = current[1];
         break;
       case GL2PS_IMAGEMAP_TOKEN :
         prim = (GL2PSprimitive *)gl2psMalloc(sizeof(GL2PSprimitive));
         prim->type = GL2PS_IMAGEMAP;
         prim->boundary = 0;
         prim->numverts = 4;
         prim->verts = (GL2PSvertex *)gl2psMalloc(4 * sizeof(GL2PSvertex));
         prim->culled = 0;
         prim->offset = 0;
         prim->pattern = 0;
         prim->factor = 0;
         prim->width = 1;
-
+        
         node = (GL2PSimagemap*)gl2psMalloc(sizeof(GL2PSimagemap));
         node->image = (GL2PSimage*)gl2psMalloc(sizeof(GL2PSimage));
         node->image->type = 0;
         node->image->format = 0;
-        node->image->zoom_x = 1.0F;
-        node->image->zoom_y = 1.0F;
         node->next = NULL;
-
+        
         if(gl2ps->imagemap_head == NULL)
           gl2ps->imagemap_head = node;
         else
           gl2ps->imagemap_tail->next = node;
         gl2ps->imagemap_tail = node;
         prim->data.image = node->image;
-
+        
         current += 2; used -= 2;
         i = gl2psGetVertex(&prim->verts[0], &current[1]);
         current += i; used -= i;
-
+        
         node->image->width = (GLint)current[2];
         current += 2; used -= 2;
         node->image->height = (GLint)current[2];
         prim->verts[0].xyz[0] = prim->verts[0].xyz[0] - (int)(node->image->width / 2) + 0.5F;
         prim->verts[0].xyz[1] = prim->verts[0].xyz[1] - (int)(node->image->height / 2) + 0.5F;
         for(i = 1; i < 4; i++){
           for(v = 0; v < 3; v++){
             prim->verts[i].xyz[v] = prim->verts[0].xyz[v];
@@ -2354,56 +2349,56 @@ static void gl2psParseFeedbackBuffer(GLi
         }
         prim->verts[1].xyz[0] = prim->verts[1].xyz[0] + node->image->width;
         prim->verts[2].xyz[0] = prim->verts[1].xyz[0];
         prim->verts[2].xyz[1] = prim->verts[2].xyz[1] + node->image->height;
         prim->verts[3].xyz[1] = prim->verts[2].xyz[1];
 
         sizeoffloat = sizeof(GLfloat);
         v = 2 * sizeoffloat;
-        vtot = node->image->height + node->image->height *
+        vtot = node->image->height + node->image->height * 
           ((node->image->width - 1) / 8);
         node->image->pixels = (GLfloat*)gl2psMalloc(v + vtot);
         node->image->pixels[0] = prim->verts[0].xyz[0];
         node->image->pixels[1] = prim->verts[0].xyz[1];
-
+        
         for(i = 0; i < vtot; i += sizeoffloat){
           current += 2; used -= 2;
           if((vtot - i) >= 4)
             memcpy(&(((char*)(node->image->pixels))[i + v]), &(current[2]), sizeoffloat);
           else
             memcpy(&(((char*)(node->image->pixels))[i + v]), &(current[2]), vtot - i);
         }
         current++; used--;
         gl2psListAdd(gl2ps->primitives, &prim);
         break;
       case GL2PS_DRAW_PIXELS_TOKEN :
       case GL2PS_TEXT_TOKEN :
         if(auxindex < gl2psListNbr(gl2ps->auxprimitives))
-          gl2psListAdd(gl2ps->primitives,
+          gl2psListAdd(gl2ps->primitives, 
                        gl2psListPointer(gl2ps->auxprimitives, auxindex++));
         else
           gl2psMsg(GL2PS_ERROR, "Wrong number of auxiliary tokens in buffer");
         break;
       }
-      current += 2;
-      used -= 2;
-      break;
+      current += 2; 
+      used -= 2; 
+      break;      
     default :
       gl2psMsg(GL2PS_WARNING, "Unknown token in buffer");
       current ++;
       used --;
       break;
     }
   }
 
   gl2psListReset(gl2ps->auxprimitives);
 }
 
-/*********************************************************************
+/********************************************************************* 
  *
  * PostScript routines
  *
  *********************************************************************/
 
 static void gl2psWriteByte(unsigned char byte)
 {
   unsigned char h = byte / 16;
@@ -2423,36 +2418,36 @@ static void gl2psPrintPostScriptPixmap(G
   /* FIXME: should we define an option for these? Or just keep the
      8-bit per component case? */
   int greyscale = 0; /* set to 1 to output greyscale image */
   int nbit = 8; /* number of bits per color compoment (2, 4 or 8) */
 
   if((width <= 0) || (height <= 0)) return;
 
   gl2psPrintf("gsave\n");
-  gl2psPrintf("%.2f %.2f translate\n", x, y);
-  gl2psPrintf("%.2f %.2f scale\n", width * im->zoom_x, height * im->zoom_y);
+  gl2psPrintf("%.2f %.2f translate\n", x, y); 
+  gl2psPrintf("%d %d scale\n", width, height); 
 
   if(greyscale){ /* greyscale */
-    gl2psPrintf("/picstr %d string def\n", width);
-    gl2psPrintf("%d %d %d\n", width, height, 8);
-    gl2psPrintf("[ %d 0 0 -%d 0 %d ]\n", width, height, height);
+    gl2psPrintf("/picstr %d string def\n", width); 
+    gl2psPrintf("%d %d %d\n", width, height, 8); 
+    gl2psPrintf("[ %d 0 0 -%d 0 %d ]\n", width, height, height); 
     gl2psPrintf("{ currentfile picstr readhexstring pop }\n");
     gl2psPrintf("image\n");
     for(row = 0; row < height; row++){
-      for(col = 0; col < width; col++){
+      for(col = 0; col < width; col++){ 
         gl2psGetRGB(im, col, row, &dr, &dg, &db);
         fgrey = (0.30F * dr + 0.59F * dg + 0.11F * db);
         grey = (unsigned char)(255. * fgrey);
         gl2psWriteByte(grey);
       }
       gl2psPrintf("\n");
     }
-    nbhex = width * height * 2;
-    gl2psPrintf("%%%% nbhex digit          :%d\n", nbhex);
+    nbhex = width * height * 2; 
+    gl2psPrintf("%%%% nbhex digit          :%d\n", nbhex); 
   }
   else if(nbit == 2){ /* color, 2 bits for r and g and b; rgbs following each other */
     nrgb = width  * 3;
     nbits = nrgb * nbit;
     nbyte = nbits / 8;
     if((nbyte * 8) != nbits) nbyte++;
     gl2psPrintf("/rgbstr %d string def\n", nbyte);
     gl2psPrintf("%d %d %d\n", width, height, nbit);
@@ -2463,42 +2458,42 @@ static void gl2psPrintPostScriptPixmap(G
     for(row = 0; row < height; row++){
       icase = 1;
       col = 0;
       b = 0;
       for(ibyte = 0; ibyte < nbyte; ibyte++){
         if(icase == 1) {
           if(col < width) {
             gl2psGetRGB(im, col, row, &dr, &dg, &db);
-          }
+          } 
           else {
             dr = dg = db = 0;
           }
           col++;
           red = (unsigned char)(3. * dr);
           green = (unsigned char)(3. * dg);
           blue = (unsigned char)(3. * db);
           b = red;
           b = (b<<2) + green;
           b = (b<<2) + blue;
           if(col < width) {
             gl2psGetRGB(im, col, row, &dr, &dg, &db);
-          }
+          } 
           else {
             dr = dg = db = 0;
           }
           col++;
           red = (unsigned char)(3. * dr);
           green = (unsigned char)(3. * dg);
           blue = (unsigned char)(3. * db);
           b = (b<<2) + red;
           gl2psWriteByte(b);
           b = 0;
           icase++;
-        }
+        } 
         else if(icase == 2) {
           b = green;
           b = (b<<2) + blue;
           if(col < width) {
             gl2psGetRGB(im, col, row, &dr, &dg, &db);
           }
           else {
             dr = dg = db = 0;
@@ -2507,17 +2502,17 @@ static void gl2psPrintPostScriptPixmap(G
           red = (unsigned char)(3. * dr);
           green = (unsigned char)(3. * dg);
           blue = (unsigned char)(3. * db);
           b = (b<<2) + red;
           b = (b<<2) + green;
           gl2psWriteByte(b);
           b = 0;
           icase++;
-        }
+        } 
         else if(icase == 3) {
           b = blue;
           if(col < width) {
             gl2psGetRGB(im, col, row, &dr, &dg, &db);
           }
           else {
             dr = dg = db = 0;
           }
@@ -2535,45 +2530,45 @@ static void gl2psPrintPostScriptPixmap(G
       }
       gl2psPrintf("\n");
     }
   }
   else if(nbit == 4){ /* color, 4 bits for r and g and b; rgbs following each other */
     nrgb = width  * 3;
     nbits = nrgb * nbit;
     nbyte = nbits / 8;
-    if((nbyte * 8) != nbits) nbyte++;
+    if((nbyte * 8) != nbits) nbyte++; 
     gl2psPrintf("/rgbstr %d string def\n", nbyte);
     gl2psPrintf("%d %d %d\n", width, height, nbit);
     gl2psPrintf("[ %d 0 0 -%d 0 %d ]\n", width, height, height);
     gl2psPrintf("{ currentfile rgbstr readhexstring pop }\n");
     gl2psPrintf("false 3\n");
     gl2psPrintf("colorimage\n");
     for(row = 0; row < height; row++){
       col = 0;
       icase = 1;
       for(ibyte = 0; ibyte < nbyte; ibyte++){
         if(icase == 1) {
           if(col < width) {
             gl2psGetRGB(im, col, row, &dr, &dg, &db);
-          }
+          } 
           else {
             dr = dg = db = 0;
           }
           col++;
           red = (unsigned char)(15. * dr);
           green = (unsigned char)(15. * dg);
           gl2psPrintf("%x%x", red, green);
           icase++;
-        }
+        } 
         else if(icase == 2) {
           blue = (unsigned char)(15. * db);
           if(col < width) {
             gl2psGetRGB(im, col, row, &dr, &dg, &db);
-          }
+          } 
           else {
             dr = dg = db = 0;
           }
           col++;
           red = (unsigned char)(15. * dr);
           gl2psPrintf("%x%x", blue, red);
           icase++;
         }
@@ -2586,49 +2581,49 @@ static void gl2psPrintPostScriptPixmap(G
       }
       gl2psPrintf("\n");
     }
   }
   else{ /* 8 bit for r and g and b */
     nbyte = width * 3;
     gl2psPrintf("/rgbstr %d string def\n", nbyte);
     gl2psPrintf("%d %d %d\n", width, height, 8);
-    gl2psPrintf("[ %d 0 0 -%d 0 %d ]\n", width, height, height);
+    gl2psPrintf("[ %d 0 0 -%d 0 %d ]\n", width, height, height); 
     gl2psPrintf("{ currentfile rgbstr readhexstring pop }\n");
     gl2psPrintf("false 3\n");
     gl2psPrintf("colorimage\n");
     for(row = 0; row < height; row++){
       for(col = 0; col < width; col++){
         gl2psGetRGB(im, col, row, &dr, &dg, &db);
         red = (unsigned char)(255. * dr);
         gl2psWriteByte(red);
         green = (unsigned char)(255. * dg);
         gl2psWriteByte(green);
         blue = (unsigned char)(255. * db);
         gl2psWriteByte(blue);
       }
       gl2psPrintf("\n");
     }
   }
-
+  
   gl2psPrintf("grestore\n");
 }
 
 static void gl2psPrintPostScriptImagemap(GLfloat x, GLfloat y,
                                          GLsizei width, GLsizei height,
                                          const unsigned char *imagemap){
   int i, size;
-
+  
   if((width <= 0) || (height <= 0)) return;
-
+  
   size = height + height * (width - 1) / 8;
-
+  
   gl2psPrintf("gsave\n");
   gl2psPrintf("%.2f %.2f translate\n", x, y);
-  gl2psPrintf("%d %d scale\n%d %d\ntrue\n", width, height,width, height);
+  gl2psPrintf("%d %d scale\n%d %d\ntrue\n", width, height,width, height); 
   gl2psPrintf("[ %d 0 0 -%d 0 %d ] {<", width, height);
   for(i = 0; i < size; i++){
     gl2psWriteByte(*imagemap);
     imagemap++;
   }
   gl2psPrintf(">} imagemask\ngrestore\n");
 }
 
@@ -2652,37 +2647,37 @@ static void gl2psPrintPostScriptHeader(v
 
   gl2psPrintf("%%%%Title: %s\n"
               "%%%%Creator: GL2PS %d.%d.%d%s, %s\n"
               "%%%%For: %s\n"
               "%%%%CreationDate: %s"
               "%%%%LanguageLevel: 3\n"
               "%%%%DocumentData: Clean7Bit\n"
               "%%%%Pages: 1\n",
-              gl2ps->title, GL2PS_MAJOR_VERSION, GL2PS_MINOR_VERSION,
+              gl2ps->title, GL2PS_MAJOR_VERSION, GL2PS_MINOR_VERSION, 
               GL2PS_PATCH_VERSION, GL2PS_EXTRA_VERSION, GL2PS_COPYRIGHT,
               gl2ps->producer, ctime(&now));
 
   if(gl2ps->format == GL2PS_PS){
     gl2psPrintf("%%%%Orientation: %s\n"
                 "%%%%DocumentMedia: Default %d %d 0 () ()\n",
                 (gl2ps->options & GL2PS_LANDSCAPE) ? "Landscape" : "Portrait",
                 (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[3] :
-                (int)gl2ps->viewport[2],
-                (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[2] :
+                (int)gl2ps->viewport[2], 
+                (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[2] : 
                 (int)gl2ps->viewport[3]);
   }
 
   gl2psPrintf("%%%%BoundingBox: %d %d %d %d\n"
               "%%%%EndComments\n",
-              (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[1] :
+              (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[1] : 
               (int)gl2ps->viewport[0],
               (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[0] :
               (int)gl2ps->viewport[1],
-              (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[3] :
+              (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[3] : 
               (int)gl2ps->viewport[2],
               (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[2] :
               (int)gl2ps->viewport[3]);
 
   /* RGB color: r g b C (replace C by G in output to change from rgb to gray)
      Grayscale: r g b G
      Font choose: size fontname FC
      Text string: (string) x y size fontname S??
@@ -2720,32 +2715,32 @@ static void gl2psPrintPostScriptHeader(v
               "/SCR{ FC moveto SW neg SH -2 div rmoveto show } BD\n"
               "/STL{ FC moveto 0 SH neg rmoveto show } BD\n"
               "/STC{ FC moveto SW -2 div SH neg rmoveto show } BD\n"
               "/STR{ FC moveto SW neg SH neg rmoveto show } BD\n");
 
   /* rotated text routines: same nameanem with R appended */
 
   gl2psPrintf("/FCT { FC translate 0 0 } BD\n"
-              "/SR  { gsave FCT moveto rotate show grestore } BD\n"
+              "/SR  { gsave FCT moveto rotate show grestore } BD\n"  
               "/SBCR{ gsave FCT moveto rotate SW -2 div 0 rmoveto show grestore } BD\n"
               "/SBRR{ gsave FCT moveto rotate SW neg 0 rmoveto show grestore } BD\n"
               "/SCLR{ gsave FCT moveto rotate 0 SH -2 div rmoveto show grestore} BD\n");
   gl2psPrintf("/SCCR{ gsave FCT moveto rotate SW -2 div SH -2 div rmoveto show grestore} BD\n"
               "/SCRR{ gsave FCT moveto rotate SW neg SH -2 div rmoveto show grestore} BD\n"
               "/STLR{ gsave FCT moveto rotate 0 SH neg rmoveto show grestore } BD\n"
               "/STCR{ gsave FCT moveto rotate SW -2 div SH neg rmoveto show grestore } BD\n"
               "/STRR{ gsave FCT moveto rotate SW neg SH neg rmoveto show grestore } BD\n");
 
   gl2psPrintf("/P  { newpath 0.0 360.0 arc closepath fill } BD\n"
               "/LS { newpath moveto } BD\n"
               "/L  { lineto } BD\n"
               "/LE { lineto stroke } BD\n"
               "/T  { newpath moveto lineto lineto closepath fill } BD\n");
-
+  
   /* Smooth-shaded triangle with PostScript level 3 shfill operator:
         x3 y3 r3 g3 b3 x2 y2 r2 g2 b2 x1 y1 r1 g1 b1 STshfill */
 
   gl2psPrintf("/STshfill {\n"
               "      /b1 exch def /g1 exch def /r1 exch def /y1 exch def /x1 exch def\n"
               "      /b2 exch def /g2 exch def /r2 exch def /y2 exch def /x2 exch def\n"
               "      /b3 exch def /g3 exch def /r3 exch def /y3 exch def /x3 exch def\n"
               "      gsave << /ShadingType 4 /ColorSpace [/DeviceRGB]\n"
@@ -2789,21 +2784,21 @@ static void gl2psPrintPostScriptHeader(v
   /* stack = (V3) (V13) (V23) (V13) (V23) (V13) (V23) (V2) (V1) */
 
   gl2psPrintf("      4 index 10 index add 0.5 mul\n" /* x12 = (x1+x2)/2 */
               "      4 index 10 index add 0.5 mul\n" /* y12 = (y1+y2)/2 */
               "      4 index 10 index add 0.5 mul\n" /* r12 = (r1+r2)/2 */
               "      4 index 10 index add 0.5 mul\n" /* g12 = (g1+g2)/2 */
               "      4 index 10 index add 0.5 mul\n" /* b12 = (b1+b2)/2 */
               "      5 copy 5 copy 40 5 roll 25 5 roll 15 5 roll 25 5 roll\n");
-
+  
   /* stack = (V3) (V13) (V23) (V13) (V12) (V23) (V13) (V1) (V12) (V23) (V12) (V2) */
 
   gl2psPrintf("      STnoshfill STnoshfill STnoshfill STnoshfill } BD\n");
-
+  
   /* Gouraud shaded triangle using recursive subdivision until the difference
      between corner colors does not exceed the thresholds:
         x3 y3 r3 g3 b3 x2 y2 r2 g2 b2 x1 y1 r1 g1 b1 STnoshfill  */
 
   gl2psPrintf("/STnoshfill {\n"
               "      2 index 8 index sub abs rThreshold gt\n" /* |r1-r2|>rth */
               "      { STsplit }\n"
               "      { 1 index 7 index sub abs gThreshold gt\n" /* |g1-g2|>gth */
@@ -2827,51 +2822,51 @@ static void gl2psPrintPostScriptHeader(v
               "                    ifelse }\n"
               "                  ifelse }\n"
               "                ifelse }\n"
               "              ifelse }\n"
               "            ifelse }\n"
               "          ifelse }\n"
               "        ifelse }\n"
               "      ifelse } BD\n");
-
+  
   gl2psPrintf("tryPS3shading\n"
               "{ /shfill where\n"
               "  { /ST { STshfill } BD }\n"
               "  { /ST { STnoshfill } BD }\n"
               "  ifelse }\n"
               "{ /ST { STnoshfill } BD }\n"
               "ifelse\n");
 
   gl2psPrintf("end\n"
               "%%%%EndProlog\n"
               "%%%%BeginSetup\n"
               "/DeviceRGB setcolorspace\n"
               "gl2psdict begin\n"
               "%%%%EndSetup\n"
               "%%%%Page: 1 1\n"
               "%%%%BeginPageSetup\n");
-
+  
   if(gl2ps->options & GL2PS_LANDSCAPE){
     gl2psPrintf("%d 0 translate 90 rotate\n",
                 (int)gl2ps->viewport[3]);
   }
 
   gl2psPrintf("%%%%EndPageSetup\n"
               "mark\n"
               "gsave\n"
               "1.0 1.0 scale\n");
-
+          
   if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
     gl2psPrintf("%g %g %g C\n"
                 "newpath %d %d moveto %d %d lineto %d %d lineto %d %d lineto\n"
                 "closepath fill\n",
-                gl2ps->bgcolor[0], gl2ps->bgcolor[1], gl2ps->bgcolor[2],
-                (int)gl2ps->viewport[0], (int)gl2ps->viewport[1], (int)gl2ps->viewport[2],
-                (int)gl2ps->viewport[1], (int)gl2ps->viewport[2], (int)gl2ps->viewport[3],
+                gl2ps->bgcolor[0], gl2ps->bgcolor[1], gl2ps->bgcolor[2], 
+                (int)gl2ps->viewport[0], (int)gl2ps->viewport[1], (int)gl2ps->viewport[2], 
+                (int)gl2ps->viewport[1], (int)gl2ps->viewport[2], (int)gl2ps->viewport[3], 
                 (int)gl2ps->viewport[0], (int)gl2ps->viewport[3]);
   }
 }
 
 static void gl2psPrintPostScriptColor(GL2PSrgba rgba)
 {
   if(!gl2psSameColor(gl2ps->lastrgba, rgba)){
     gl2psSetLastColor(rgba);
@@ -2891,17 +2886,17 @@ static void gl2psEndPostScriptLine(void)
     gl2psPrintf("%g %g LE\n", gl2ps->lastvertex.xyz[0], gl2ps->lastvertex.xyz[1]);
     for(i = 0; i < 3; i++)
       gl2ps->lastvertex.xyz[i] = -1.;
     for(i = 0; i < 4; i++)
       gl2ps->lastvertex.rgba[i] = -1.;
   }
 }
 
-static void gl2psParseStipplePattern(GLushort pattern, GLint factor,
+static void gl2psParseStipplePattern(GLushort pattern, GLint factor, 
                                      int *nb, int array[10])
 {
   int i, n;
   int on[8] = {0, 0, 0, 0, 0, 0, 0, 0};
   int off[8] = {0, 0, 0, 0, 0, 0, 0, 0};
   char tmp[16];
 
   /* extract the 16 bits from the OpenGL stipple pattern */
@@ -2931,34 +2926,34 @@ static void gl2psParseStipplePattern(GLu
 }
 
 static int gl2psPrintPostScriptDash(GLushort pattern, GLint factor, const char *str)
 {
   int len = 0, i, n, array[10];
 
   if(pattern == gl2ps->lastpattern && factor == gl2ps->lastfactor)
     return 0;
-
+  
   gl2ps->lastpattern = pattern;
   gl2ps->lastfactor = factor;
-
+  
   if(!pattern || !factor){
     /* solid line */
     len += gl2psPrintf("[] 0 %s\n", str);
   }
   else{
     gl2psParseStipplePattern(pattern, factor, &n, array);
     len += gl2psPrintf("[");
     for(i = 0; i < n; i++){
       if(i) len += gl2psPrintf(" ");
       len += gl2psPrintf("%d", array[i]);
     }
     len += gl2psPrintf("] 0 %s\n", str);
   }
-
+  
   return len;
 }
 
 static void gl2psPrintPostScriptPrimitive(void *data)
 {
   int newline;
   GL2PSprimitive *prim;
 
@@ -2971,17 +2966,17 @@ static void gl2psPrintPostScriptPrimitiv
      line joins and to not restart the stippling for every line
      segment. So if the primitive to print is not a line we must first
      finish the current line (if any): */
   if(prim->type != GL2PS_LINE) gl2psEndPostScriptLine();
 
   switch(prim->type){
   case GL2PS_POINT :
     gl2psPrintPostScriptColor(prim->verts[0].rgba);
-    gl2psPrintf("%g %g %g P\n",
+    gl2psPrintf("%g %g %g P\n", 
                 prim->verts[0].xyz[0], prim->verts[0].xyz[1], 0.5 * prim->width);
     break;
   case GL2PS_LINE :
     if(!gl2psSamePosition(gl2ps->lastvertex.xyz, prim->verts[0].xyz) ||
        !gl2psSameColor(gl2ps->lastrgba, prim->verts[0].rgba) ||
        gl2ps->lastlinewidth != prim->width ||
        gl2ps->lastpattern != prim->pattern ||
        gl2ps->lastfactor != prim->factor){
@@ -3134,24 +3129,24 @@ static void gl2psPrintPostScriptBeginVie
       rgba[0] = gl2ps->colormap[index][0];
       rgba[1] = gl2ps->colormap[index][1];
       rgba[2] = gl2ps->colormap[index][2];
       rgba[3] = 1.0F;
     }
     gl2psPrintf("%g %g %g C\n"
                 "newpath %d %d moveto %d %d lineto %d %d lineto %d %d lineto\n"
                 "closepath fill\n",
-                rgba[0], rgba[1], rgba[2],
+                rgba[0], rgba[1], rgba[2], 
                 x, y, x+w, y, x+w, y+h, x, y+h);
   }
-
+    
   gl2psPrintf("newpath %d %d moveto %d %d lineto %d %d lineto %d %d lineto\n"
               "closepath clip\n",
               x, y, x+w, y, x+w, y+h, x, y+h);
-
+  
 }
 
 static GLint gl2psPrintPostScriptEndViewport(void)
 {
   GLint res;
 
   res = gl2psPrintPrimitives();
   gl2psPrintf("grestore\n");
@@ -3183,17 +3178,17 @@ static GL2PSbackend gl2psEPS = {
   gl2psPrintPostScriptBeginViewport,
   gl2psPrintPostScriptEndViewport,
   gl2psPrintPostScriptPrimitive,
   gl2psPrintPostScriptFinalPrimitive,
   "eps",
   "Encapsulated Postscript"
 };
 
-/*********************************************************************
+/********************************************************************* 
  *
  * LaTeX routines
  *
  *********************************************************************/
 
 static void gl2psPrintTeXHeader(void)
 {
   char name[256];
@@ -3211,26 +3206,26 @@ static void gl2psPrintTeXHeader(void)
     if(i <= 0) strcpy(name, gl2ps->filename);
   }
   else{
     strcpy(name, "untitled");
   }
 
   time(&now);
 
-  fprintf(gl2ps->stream,
+  fprintf(gl2ps->stream, 
           "%% Title: %s\n"
           "%% Creator: GL2PS %d.%d.%d%s, %s\n"
           "%% For: %s\n"
           "%% CreationDate: %s",
           gl2ps->title, GL2PS_MAJOR_VERSION, GL2PS_MINOR_VERSION,
           GL2PS_PATCH_VERSION, GL2PS_EXTRA_VERSION, GL2PS_COPYRIGHT,
           gl2ps->producer, ctime(&now));
 
-  fprintf(gl2ps->stream,
+  fprintf(gl2ps->stream, 
           "\\setlength{\\unitlength}{1pt}\n"
           "\\begin{picture}(0,0)\n"
           "\\includegraphics{%s}\n"
           "\\end{picture}%%\n"
           "%s\\begin{picture}(%d,%d)(0,0)\n",
           name, (gl2ps->options & GL2PS_LANDSCAPE) ? "\\rotatebox{90}{" : "",
           (int)gl2ps->viewport[2], (int)gl2ps->viewport[3]);
 }
@@ -3238,23 +3233,20 @@ static void gl2psPrintTeXHeader(void)
 static void gl2psPrintTeXPrimitive(void *data)
 {
   GL2PSprimitive *prim;
 
   prim = *(GL2PSprimitive**)data;
 
   switch(prim->type){
   case GL2PS_TEXT :
-    fprintf(gl2ps->stream, "\\fontsize{%d}{0}\n\\selectfont",
+    fprintf(gl2ps->stream, "\\fontsize{%d}{0}\n\\selectfont", 
             prim->data.text->fontsize);
-    fprintf(gl2ps->stream, "\\put(%g,%g)",
+    fprintf(gl2ps->stream, "\\put(%g,%g){\\makebox(0,0)",
             prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
-    if(prim->data.text->angle)
-      fprintf(gl2ps->stream, "{\\rotatebox{%g}", prim->data.text->angle);
-    fprintf(gl2ps->stream, "{\\makebox(0,0)");
     switch(prim->data.text->alignment){
     case GL2PS_TEXT_C:
       fprintf(gl2ps->stream, "{");
       break;
     case GL2PS_TEXT_CL:
       fprintf(gl2ps->stream, "[l]{");
       break;
     case GL2PS_TEXT_CR:
@@ -3275,16 +3267,18 @@ static void gl2psPrintTeXPrimitive(void 
     case GL2PS_TEXT_TR:
       fprintf(gl2ps->stream, "[tr]{");
       break;
     case GL2PS_TEXT_BL:
     default:
       fprintf(gl2ps->stream, "[bl]{");
       break;
     }
+    if(prim->data.text->angle)
+      fprintf(gl2ps->stream, "\\rotatebox{%g}{", prim->data.text->angle);
     fprintf(gl2ps->stream, "\\textcolor[rgb]{%g,%g,%g}{{%s}}",
             prim->verts[0].rgba[0], prim->verts[0].rgba[1], prim->verts[0].rgba[2],
             prim->data.text->str);
     if(prim->data.text->angle)
       fprintf(gl2ps->stream, "}");
     fprintf(gl2ps->stream, "}}\n");
     break;
   case GL2PS_SPECIAL :
@@ -3302,17 +3296,17 @@ static void gl2psPrintTeXFooter(void)
 {
   fprintf(gl2ps->stream, "\\end{picture}%s\n",
           (gl2ps->options & GL2PS_LANDSCAPE) ? "}" : "");
 }
 
 static void gl2psPrintTeXBeginViewport(GLint viewport[4])
 {
   glRenderMode(GL_FEEDBACK);
-
+  
   if(gl2ps->header){
     gl2psPrintTeXHeader();
     gl2ps->header = GL_FALSE;
   }
 }
 
 static GLint gl2psPrintTeXEndViewport(void)
 {
@@ -3331,17 +3325,17 @@ static GL2PSbackend gl2psTEX = {
   gl2psPrintTeXBeginViewport,
   gl2psPrintTeXEndViewport,
   gl2psPrintTeXPrimitive,
   gl2psPrintTeXFinalPrimitive,
   "tex",
   "LaTeX text"
 };
 
-/*********************************************************************
+/********************************************************************* 
  *
  * PDF routines
  *
  *********************************************************************/
 
 static int gl2psPrintPDFCompressorType(void)
 {
 #if defined(GL2PS_HAVE_ZLIB)
@@ -3367,17 +3361,17 @@ static int gl2psPrintPDFStrokeColor(GL2P
   }
   offs += gl2psPrintf("RG\n");
   return offs;
 }
 
 static int gl2psPrintPDFFillColor(GL2PSrgba rgba)
 {
   int i, offs = 0;
-
+  
   for(i = 0; i < 3; ++i){
     if(GL2PS_ZERO(rgba[i]))
       offs += gl2psPrintf("%.0f ", 0.);
     else if(rgba[i] < 1e-4 || rgba[i] > 1e6) /* avoid %e formatting */
       offs += gl2psPrintf("%f ", rgba[i]);
     else
       offs += gl2psPrintf("%g ", rgba[i]);
   }
@@ -3393,28 +3387,28 @@ static int gl2psPrintPDFLineWidth(GLfloa
     return gl2psPrintf("%f w\n", lw);
   else
     return gl2psPrintf("%g w\n", lw);
 }
 
 static void gl2psPutPDFText(GL2PSstring *text, int cnt, GLfloat x, GLfloat y)
 {
   GLfloat rad, crad, srad;
-
+  
   if(text->angle == 0.0F){
     gl2ps->streamlength += gl2psPrintf
       ("BT\n"
        "/F%d %d Tf\n"
        "%f %f Td\n"
        "(%s) Tj\n"
-       "ET\n",
+       "ET\n", 
        cnt, text->fontsize, x, y, text->str);
   }
   else{
-    rad = (GLfloat)M_PI * text->angle / 180.0F;
+    rad = M_PI * text->angle / 180.0F;
     srad = (GLfloat)sin(rad);
     crad = (GLfloat)cos(rad);
     gl2ps->streamlength += gl2psPrintf
       ("BT\n"
        "/F%d %d Tf\n"
        "%f %f %f %f %f %f Tm\n"
        "(%s) Tj\n"
        "ET\n",
@@ -3429,33 +3423,33 @@ static void gl2psPutPDFImage(GL2PSimage 
      "%d 0 0 %d %f %f cm\n"
      "/Im%d Do\n"
      "Q\n",
      (int)image->width, (int)image->height, x, y, cnt);
 }
 
 static void gl2psPDFstacksInit(void)
 {
-  gl2ps->objects_stack = 7 /* FIXED_XREF_ENTRIES */ + 1;
-  gl2ps->extgs_stack = 0;
-  gl2ps->font_stack = 0;
-  gl2ps->im_stack = 0;
-  gl2ps->trgroupobjects_stack = 0;
-  gl2ps->shader_stack = 0;
-  gl2ps->mshader_stack = 0;
+  gl2ps->objects_stack = 7 /* FIXED_XREF_ENTRIES */ + 1; 
+  gl2ps->extgs_stack = 0;   
+  gl2ps->font_stack = 0;    
+  gl2ps->im_stack = 0;      
+  gl2ps->trgroupobjects_stack = 0;    
+  gl2ps->shader_stack = 0;  
+  gl2ps->mshader_stack = 0; 
 }
 
 static void gl2psPDFgroupObjectInit(GL2PSpdfgroup *gro)
 {
   if(!gro)
     return;
-
+  
   gro->ptrlist = NULL;
-  gro->fontno = gro->gsno = gro->imno = gro->maskshno = gro->shno
-    = gro->trgroupno = gro->fontobjno = gro->imobjno = gro->shobjno
+  gro->fontno = gro->gsno = gro->imno = gro->maskshno = gro->shno 
+    = gro->trgroupno = gro->fontobjno = gro->imobjno = gro->shobjno 
     = gro->maskshobjno = gro->gsobjno = gro->trgroupobjno = -1;
 }
 
 /* Build up group objects and assign name and object numbers */
 
 static void gl2psPDFgroupListInit(void)
 {
   int i;
@@ -3470,17 +3464,17 @@ static void gl2psPDFgroupListInit(void)
   int lastTriangleWasNotSimpleWithSameColor = 0;
 
   if(!gl2ps->pdfprimlist)
     return;
 
   gl2ps->pdfgrouplist = gl2psListCreate(500, 500, sizeof(GL2PSpdfgroup));
   gl2psInitTriangle(&lastt);
 
-  for(i = 0; i < gl2psListNbr(gl2ps->pdfprimlist); ++i){
+  for(i = 0; i < gl2psListNbr(gl2ps->pdfprimlist); ++i){  
     p = *(GL2PSprimitive**)gl2psListPointer(gl2ps->pdfprimlist, i);
     switch(p->type){
     case GL2PS_PIXMAP:
       gl2psPDFgroupObjectInit(&gro);
       gro.ptrlist = gl2psListCreate(1, 2, sizeof(GL2PSprimitive*));
       gro.imno = gl2ps->im_stack++;
       gl2psListAdd(gro.ptrlist, &p);
       gl2psListAdd(gl2ps->pdfgrouplist, &gro);
@@ -3488,17 +3482,17 @@ static void gl2psPDFgroupListInit(void)
     case GL2PS_TEXT:
       gl2psPDFgroupObjectInit(&gro);
       gro.ptrlist = gl2psListCreate(1, 2, sizeof(GL2PSprimitive*));
       gro.fontno = gl2ps->font_stack++;
       gl2psListAdd(gro.ptrlist, &p);
       gl2psListAdd(gl2ps->pdfgrouplist, &gro);
       break;
     case GL2PS_LINE:
-      if(lasttype != p->type || lastwidth != p->width ||
+      if(lasttype != p->type || lastwidth != p->width || 
          lastpattern != p->pattern || lastfactor != p->factor ||
          !gl2psSameColor(p->verts[0].rgba, lastrgba)){
         gl2psPDFgroupObjectInit(&gro);
         gro.ptrlist = gl2psListCreate(1, 2, sizeof(GL2PSprimitive*));
         gl2psListAdd(gro.ptrlist, &p);
         gl2psListAdd(gl2ps->pdfgrouplist, &gro);
       }
       else{
@@ -3507,102 +3501,102 @@ static void gl2psPDFgroupListInit(void)
       lastpattern = p->pattern;
       lastfactor = p->factor;
       lastwidth = p->width;
       lastrgba[0] = p->verts[0].rgba[0];
       lastrgba[1] = p->verts[0].rgba[1];
       lastrgba[2] = p->verts[0].rgba[2];
       break;
     case GL2PS_POINT:
-      if(lasttype != p->type || lastwidth != p->width ||
+      if(lasttype != p->type || lastwidth != p->width || 
          !gl2psSameColor(p->verts[0].rgba, lastrgba)){
         gl2psPDFgroupObjectInit(&gro);
         gro.ptrlist = gl2psListCreate(1,2,sizeof(GL2PSprimitive*));
         gl2psListAdd(gro.ptrlist, &p);
         gl2psListAdd(gl2ps->pdfgrouplist, &gro);
       }
       else{
         gl2psListAdd(gro.ptrlist, &p);
       }
       lastwidth = p->width;
       lastrgba[0] = p->verts[0].rgba[0];
       lastrgba[1] = p->verts[0].rgba[1];
       lastrgba[2] = p->verts[0].rgba[2];
       break;
     case GL2PS_TRIANGLE:
       gl2psFillTriangleFromPrimitive(&tmpt, p, GL_TRUE);
-      lastTriangleWasNotSimpleWithSameColor =
+      lastTriangleWasNotSimpleWithSameColor = 
         !(tmpt.prop & T_CONST_COLOR && tmpt.prop & T_ALPHA_1) ||
         !gl2psSameColor(tmpt.vertex[0].rgba, lastt.vertex[0].rgba);
-      if(lasttype == p->type && tmpt.prop == lastt.prop &&
+      if(lasttype == p->type && tmpt.prop == lastt.prop && 
          lastTriangleWasNotSimpleWithSameColor){
         /* TODO Check here for last alpha */
         gl2psListAdd(gro.ptrlist, &p);
       }
       else{
         gl2psPDFgroupObjectInit(&gro);
         gro.ptrlist = gl2psListCreate(1, 2, sizeof(GL2PSprimitive*));
         gl2psListAdd(gro.ptrlist, &p);
         gl2psListAdd(gl2ps->pdfgrouplist, &gro);
       }
       lastt = tmpt;
       break;
     default:
       break;
-    }
+    } 
     lasttype = p->type;
   }
 }
 
 static void gl2psSortOutTrianglePDFgroup(GL2PSpdfgroup *gro)
 {
   GL2PStriangle t;
   GL2PSprimitive *prim = NULL;
-
+  
   if(!gro)
     return;
 
   if(!gl2psListNbr(gro->ptrlist))
     return;
 
   prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, 0);
 
   if(prim->type != GL2PS_TRIANGLE)
     return;
 
   gl2psFillTriangleFromPrimitive(&t, prim, GL_TRUE);
-
-  if(t.prop & T_CONST_COLOR && t.prop & T_ALPHA_LESS_1){
-    gro->gsno = gl2ps->extgs_stack++;
+  
+  if(t.prop & T_CONST_COLOR && t.prop & T_ALPHA_LESS_1){        
+    gro->gsno = gl2ps->extgs_stack++; 
     gro->gsobjno = gl2ps->objects_stack ++;
   }
-  else if(t.prop & T_CONST_COLOR && t.prop & T_VAR_ALPHA){
+  else if(t.prop & T_CONST_COLOR && t.prop & T_VAR_ALPHA){              
     gro->gsno = gl2ps->extgs_stack++;
     gro->gsobjno = gl2ps->objects_stack++;
-    gro->trgroupno = gl2ps->trgroupobjects_stack++;
+    gro->trgroupno = gl2ps->trgroupobjects_stack++; 
     gro->trgroupobjno = gl2ps->objects_stack++;
     gro->maskshno = gl2ps->mshader_stack++;
     gro->maskshobjno = gl2ps->objects_stack++;
   }
-  else if(t.prop & T_VAR_COLOR && t.prop & T_ALPHA_1){
+  else if(t.prop & T_VAR_COLOR && t.prop & T_ALPHA_1){          
     gro->shno = gl2ps->shader_stack++;
     gro->shobjno = gl2ps->objects_stack++;
   }
-  else if(t.prop & T_VAR_COLOR && t.prop & T_ALPHA_LESS_1){
+  else if(t.prop & T_VAR_COLOR && t.prop & T_ALPHA_LESS_1){             
     gro->gsno = gl2ps->extgs_stack++;
     gro->gsobjno = gl2ps->objects_stack++;
-    gro->shno = gl2ps->shader_stack++;
+    gro->shno = gl2ps->shader_stack++; 
     gro->shobjno = gl2ps->objects_stack++;
   }
-  else if(t.prop & T_VAR_COLOR && t.prop & T_VAR_ALPHA){
+  else if(t.prop & T_VAR_COLOR && t.prop & T_VAR_ALPHA){                
     gro->gsno = gl2ps->extgs_stack++;
     gro->gsobjno = gl2ps->objects_stack++;
-    gro->shno = gl2ps->shader_stack++;
+    gro->shno = gl2ps->shader_stack++; 
     gro->shobjno = gl2ps->objects_stack++;
-    gro->trgroupno = gl2ps->trgroupobjects_stack++;
+    gro->trgroupno = gl2ps->trgroupobjects_stack++; 
     gro->trgroupobjno = gl2ps->objects_stack++;
     gro->maskshno = gl2ps->mshader_stack++;
     gro->maskshobjno = gl2ps->objects_stack++;
   }
 }
 
 /* Main stream data */
 
@@ -3625,236 +3619,236 @@ static void gl2psPDFgroupListWriteMainSt
 
     prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, 0);
 
     switch(prim->type){
     case GL2PS_POINT:
       gl2ps->streamlength += gl2psPrintf("1 J\n");
       gl2ps->streamlength += gl2psPrintPDFLineWidth(prim->width);
       gl2ps->streamlength += gl2psPrintPDFStrokeColor(prim->verts[0].rgba);
-      for(j = 0; j <= lastel; ++j){
+      for(j = 0; j <= lastel; ++j){  
         prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
         gl2ps->streamlength +=
           gl2psPrintf("%f %f m %f %f l\n",
                       prim->verts[0].xyz[0], prim->verts[0].xyz[1],
                       prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
       }
-      gl2ps->streamlength += gl2psPrintf("S\n");
+      gl2ps->streamlength += gl2psPrintf("S\n"); 
       gl2ps->streamlength += gl2psPrintf("0 J\n");
       break;
     case GL2PS_LINE:
       /* We try to use as few paths as possible to draw lines, in
          order to get nice stippling even when the individual segments
          are smaller than the stipple */
       gl2ps->streamlength += gl2psPrintPDFLineWidth(prim->width);
       gl2ps->streamlength += gl2psPrintPDFStrokeColor(prim->verts[0].rgba);
       gl2ps->streamlength += gl2psPrintPostScriptDash(prim->pattern, prim->factor, "d");
       /* start new path */
-      gl2ps->streamlength +=
-        gl2psPrintf("%f %f m\n",
+      gl2ps->streamlength += 
+        gl2psPrintf("%f %f m\n", 
                     prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
-
+      
       for(j = 1; j <= lastel; ++j){
         prev = prim;
         prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
         if(!gl2psSamePosition(prim->verts[0].xyz, prev->verts[1].xyz)){
           /* the starting point of the new segment does not match the
              end point of the previous line, so we end the current
              path and start a new one */
-          gl2ps->streamlength +=
-            gl2psPrintf("%f %f l\n",
+          gl2ps->streamlength += 
+            gl2psPrintf("%f %f l\n", 
                         prev->verts[1].xyz[0], prev->verts[1].xyz[1]);
-          gl2ps->streamlength +=
-            gl2psPrintf("%f %f m\n",
+          gl2ps->streamlength += 
+            gl2psPrintf("%f %f m\n", 
                         prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
         }
         else{
           /* the two segements are connected, so we just append to the
              current path */
-          gl2ps->streamlength +=
+          gl2ps->streamlength += 
             gl2psPrintf("%f %f l\n",
                         prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
         }
       }
       /* end last path */
-      gl2ps->streamlength +=
-        gl2psPrintf("%f %f l\n",
+      gl2ps->streamlength += 
+        gl2psPrintf("%f %f l\n", 
                     prim->verts[1].xyz[0], prim->verts[1].xyz[1]);
       gl2ps->streamlength += gl2psPrintf("S\n");
       break;
     case GL2PS_TRIANGLE:
       gl2psFillTriangleFromPrimitive(&t, prim, GL_TRUE);
       gl2psSortOutTrianglePDFgroup(gro);
-
+      
       /* No alpha and const color: Simple PDF draw orders  */
-      if(t.prop & T_CONST_COLOR && t.prop & T_ALPHA_1){
-        gl2ps->streamlength += gl2psPrintPDFFillColor(t.vertex[0].rgba);
-        for(j = 0; j <= lastel; ++j){
+      if(t.prop & T_CONST_COLOR && t.prop & T_ALPHA_1){         
+        gl2ps->streamlength += gl2psPrintPDFFillColor(t.vertex[0].rgba);        
+        for(j = 0; j <= lastel; ++j){  
           prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
           gl2psFillTriangleFromPrimitive(&t, prim, GL_FALSE);
-          gl2ps->streamlength
+          gl2ps->streamlength 
             += gl2psPrintf("%f %f m\n"
                            "%f %f l\n"
                            "%f %f l\n"
                            "h f\n",
                            t.vertex[0].xyz[0], t.vertex[0].xyz[1],
                            t.vertex[1].xyz[0], t.vertex[1].xyz[1],
                            t.vertex[2].xyz[0], t.vertex[2].xyz[1]);
         }
       }
-      /* Const alpha < 1 and const color: Simple PDF draw orders
+      /* Const alpha < 1 and const color: Simple PDF draw orders 
          and an extra extended Graphics State for the alpha const */
-      else if(t.prop & T_CONST_COLOR && t.prop & T_ALPHA_LESS_1){
+      else if(t.prop & T_CONST_COLOR && t.prop & T_ALPHA_LESS_1){               
         gl2ps->streamlength += gl2psPrintf("q\n"
                                            "/GS%d gs\n",
                                            gro->gsno);
         gl2ps->streamlength += gl2psPrintPDFFillColor(prim->verts[0].rgba);
-        for(j = 0; j <= lastel; ++j){
+        for(j = 0; j <= lastel; ++j){  
           prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
           gl2psFillTriangleFromPrimitive(&t, prim, GL_FALSE);
-          gl2ps->streamlength
+          gl2ps->streamlength 
             += gl2psPrintf("%f %f m\n"
                            "%f %f l\n"
                            "%f %f l\n"
                            "h f\n",
                            t.vertex[0].xyz[0], t.vertex[0].xyz[1],
                            t.vertex[1].xyz[0], t.vertex[1].xyz[1],
                            t.vertex[2].xyz[0], t.vertex[2].xyz[1]);
         }
         gl2ps->streamlength += gl2psPrintf("Q\n");
       }
-      /* Variable alpha and const color: Simple PDF draw orders
-         and an extra extended Graphics State + Xobject + Shader
+      /* Variable alpha and const color: Simple PDF draw orders 
+         and an extra extended Graphics State + Xobject + Shader 
          object for the alpha mask */
-      else if(t.prop & T_CONST_COLOR && t.prop & T_VAR_ALPHA){
+      else if(t.prop & T_CONST_COLOR && t.prop & T_VAR_ALPHA){          
         gl2ps->streamlength += gl2psPrintf("q\n"
                                            "/GS%d gs\n"
                                            "/TrG%d Do\n",
                                            gro->gsno, gro->trgroupno);
         gl2ps->streamlength += gl2psPrintPDFFillColor(prim->verts[0].rgba);
-        for(j = 0; j <= lastel; ++j){
+        for(j = 0; j <= lastel; ++j){  
           prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
           gl2psFillTriangleFromPrimitive(&t, prim, GL_FALSE);
-          gl2ps->streamlength
+          gl2ps->streamlength 
             += gl2psPrintf("%f %f m\n"
                            "%f %f l\n"
                            "%f %f l\n"
                            "h f\n",
                            t.vertex[0].xyz[0], t.vertex[0].xyz[1],
                            t.vertex[1].xyz[0], t.vertex[1].xyz[1],
                            t.vertex[2].xyz[0], t.vertex[2].xyz[1]);
         }
         gl2ps->streamlength += gl2psPrintf("Q\n");
       }
       /* Variable color and no alpha: Shader Object for the colored
          triangle(s) */
-      else if(t.prop & T_VAR_COLOR && t.prop & T_ALPHA_1){
+      else if(t.prop & T_VAR_COLOR && t.prop & T_ALPHA_1){              
         gl2ps->streamlength += gl2psPrintf("/Sh%d sh\n", gro->shno);
       }
-      /* Variable color and const alpha < 1: Shader Object for the
-         colored triangle(s) and an extra extended Graphics State
+      /* Variable color and const alpha < 1: Shader Object for the 
+         colored triangle(s) and an extra extended Graphics State 
          for the alpha const */
-      else if(t.prop & T_VAR_COLOR && t.prop & T_ALPHA_LESS_1){
+      else if(t.prop & T_VAR_COLOR && t.prop & T_ALPHA_LESS_1){         
         gl2ps->streamlength += gl2psPrintf("q\n"
                                            "/GS%d gs\n"
                                            "/Sh%d sh\n"
                                            "Q\n",
                                            gro->gsno, gro->shno);
       }
-      /* Variable alpha and color: Shader Object for the colored
-         triangle(s) and an extra extended Graphics State
+      /* Variable alpha and color: Shader Object for the colored 
+         triangle(s) and an extra extended Graphics State 
          + Xobject + Shader object for the alpha mask */
-      else if(t.prop & T_VAR_COLOR && t.prop & T_VAR_ALPHA){
+      else if(t.prop & T_VAR_COLOR && t.prop & T_VAR_ALPHA){            
         gl2ps->streamlength += gl2psPrintf("q\n"
                                            "/GS%d gs\n"
                                            "/TrG%d Do\n"
                                            "/Sh%d sh\n"
                                            "Q\n",
                                            gro->gsno, gro->trgroupno, gro->shno);
       }
       break;
     case GL2PS_PIXMAP:
       for(j = 0; j <= lastel; ++j){
         prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
-        gl2psPutPDFImage(prim->data.image, gro->imno, prim->verts[0].xyz[0],
+        gl2psPutPDFImage(prim->data.image, gro->imno, prim->verts[0].xyz[0], 
                          prim->verts[0].xyz[1]);
       }
       break;
     case GL2PS_TEXT:
-      for(j = 0; j <= lastel; ++j){
+      for(j = 0; j <= lastel; ++j){  
         prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
         gl2ps->streamlength += gl2psPrintPDFFillColor(prim->verts[0].rgba);
         gl2psPutPDFText(prim->data.text, gro->fontno, prim->verts[0].xyz[0],
                         prim->verts[0].xyz[1]);
       }
       break;
     default:
       break;
-    }
+    } 
   }
 }
 
 /* Graphics State names */
 
 static int gl2psPDFgroupListWriteGStateResources(void)
 {
   GL2PSpdfgroup *gro;
   int offs = 0;
   int i;
 
   offs += fprintf(gl2ps->stream,
-                  "/ExtGState\n"
+                  "/ExtGState\n" 
                   "<<\n"
                   "/GSa 7 0 R\n");
-  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){
-    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i);
+  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){  
+    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i); 
     if(gro->gsno >= 0)
       offs += fprintf(gl2ps->stream, "/GS%d %d 0 R\n", gro->gsno, gro->gsobjno);
   }
-  offs += fprintf(gl2ps->stream, ">>\n");
+  offs += fprintf(gl2ps->stream, ">>\n"); 
   return offs;
 }
 
 /* Main Shader names */
 
 static int gl2psPDFgroupListWriteShaderResources(void)
 {
   GL2PSpdfgroup *gro;
   int offs = 0;
   int i;
 
   offs += fprintf(gl2ps->stream,
                   "/Shading\n"
                   "<<\n");
-  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){
-    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i);
+  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){  
+    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i); 
     if(gro->shno >= 0)
       offs += fprintf(gl2ps->stream, "/Sh%d %d 0 R\n", gro->shno, gro->shobjno);
     if(gro->maskshno >= 0)
       offs += fprintf(gl2ps->stream, "/TrSh%d %d 0 R\n", gro->maskshno, gro->maskshobjno);
   }
-  offs += fprintf(gl2ps->stream,">>\n");
+  offs += fprintf(gl2ps->stream,">>\n");  
   return offs;
 }
 
 /* Images & Mask Shader XObject names */
 
 static int gl2psPDFgroupListWriteXObjectResources(void)
 {
   int i;
   GL2PSprimitive *p = NULL;
   GL2PSpdfgroup *gro;
   int offs = 0;
 
   offs += fprintf(gl2ps->stream,
                   "/XObject\n"
                   "<<\n");
 
-  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){
-    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i);
+  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){  
+    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i); 
     if(!gl2psListNbr(gro->ptrlist))
       continue;
     p = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, 0);
     switch(p->type){
     case GL2PS_PIXMAP:
       gro->imobjno = gl2ps->objects_stack++;
       if(GL_RGBA == p->data.image->format)  /* reserve one object for image mask */
         gl2ps->objects_stack++;
@@ -3876,212 +3870,212 @@ static int gl2psPDFgroupListWriteXObject
 static int gl2psPDFgroupListWriteFontResources(void)
 {
   int i;
   GL2PSpdfgroup *gro;
   int offs = 0;
 
   offs += fprintf(gl2ps->stream, "/Font\n<<\n");
 
-  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){
-    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i);
+  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){  
+    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i); 
     if(gro->fontno < 0)
       continue;
     gro->fontobjno = gl2ps->objects_stack++;
     offs += fprintf(gl2ps->stream, "/F%d %d 0 R\n", gro->fontno, gro->fontobjno);
   }
   offs += fprintf(gl2ps->stream, ">>\n");
 
   return offs;
 }
 
 static void gl2psPDFgroupListDelete(void)
 {
   int i;
   GL2PSpdfgroup *gro = NULL;
-
+  
   if(!gl2ps->pdfgrouplist)
     return;
 
-  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){
+  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){ 
     gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist,i);
     gl2psListDelete(gro->ptrlist);
   }
 
   gl2psListDelete(gl2ps->pdfgrouplist);
   gl2ps->pdfgrouplist = NULL;
 }
 
 /* Print 1st PDF object - file info */
 
 static int gl2psPrintPDFInfo(void)
 {
   int offs;
   time_t now;
   struct tm *newtime;
-
+  
   time(&now);
   newtime = gmtime(&now);
-
+  
   offs = fprintf(gl2ps->stream,
                  "1 0 obj\n"
                  "<<\n"
                  "/Title (%s)\n"
                  "/Creator (GL2PS %d.%d.%d%s, %s)\n"
                  "/Producer (%s)\n",
                  gl2ps->title, GL2PS_MAJOR_VERSION, GL2PS_MINOR_VERSION,
                  GL2PS_PATCH_VERSION, GL2PS_EXTRA_VERSION, GL2PS_COPYRIGHT,
                  gl2ps->producer);
-
+  
   if(!newtime){
-    offs += fprintf(gl2ps->stream,
+    offs += fprintf(gl2ps->stream, 
                     ">>\n"
                     "endobj\n");
     return offs;
   }
-
-  offs += fprintf(gl2ps->stream,
+  
+  offs += fprintf(gl2ps->stream, 
                   "/CreationDate (D:%d%02d%02d%02d%02d%02d)\n"
                   ">>\n"
                   "endobj\n",
-                  newtime->tm_year+1900,
-                  newtime->tm_mon+1,
+                  newtime->tm_year+1900, 
+                  newtime->tm_mon+1, 
                   newtime->tm_mday,
                   newtime->tm_hour,
                   newtime->tm_min,
                   newtime->tm_sec);
   return offs;
 }
 
 /* Create catalog and page structure - 2nd and 3th PDF object */
 
 static int gl2psPrintPDFCatalog(void)
 {
-  return fprintf(gl2ps->stream,
+  return fprintf(gl2ps->stream, 
                  "2 0 obj\n"
                  "<<\n"
                  "/Type /Catalog\n"
                  "/Pages 3 0 R\n"
                  ">>\n"
                  "endobj\n");
 }
 
 static int gl2psPrintPDFPages(void)
 {
-  return fprintf(gl2ps->stream,
+  return fprintf(gl2ps->stream, 
                  "3 0 obj\n"
-                 "<<\n"
+                 "<<\n" 
                  "/Type /Pages\n"
                  "/Kids [6 0 R]\n"
                  "/Count 1\n"
                  ">>\n"
                  "endobj\n");
 }
 
 /* Open stream for data - graphical objects, fonts etc. PDF object 4 */
 
 static int gl2psOpenPDFDataStream(void)
 {
   int offs = 0;
-
-  offs += fprintf(gl2ps->stream,
+  
+  offs += fprintf(gl2ps->stream, 
                   "4 0 obj\n"
-                  "<<\n"
+                  "<<\n" 
                   "/Length 5 0 R\n" );
   offs += gl2psPrintPDFCompressorType();
-  offs += fprintf(gl2ps->stream,
+  offs += fprintf(gl2ps->stream, 
                   ">>\n"
                   "stream\n");
   return offs;
 }
 
 /* Stream setup - Graphics state, fill background if allowed */
 
 static int gl2psOpenPDFDataStreamWritePreface(void)
 {
   int offs;
 
   offs = gl2psPrintf("/GSa gs\n");
-
+  
   if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
     offs += gl2psPrintPDFFillColor(gl2ps->bgcolor);
     offs += gl2psPrintf("%d %d %d %d re\n",
                         (int)gl2ps->viewport[0], (int)gl2ps->viewport[1],
                         (int)gl2ps->viewport[2], (int)gl2ps->viewport[3]);
-    offs += gl2psPrintf("f\n");
+    offs += gl2psPrintf("f\n");  
   }
   return offs;
 }
 
 /* Use the functions above to create the first part of the PDF*/
 
 static void gl2psPrintPDFHeader(void)
 {
   int offs = 0;
   gl2ps->pdfprimlist = gl2psListCreate(500, 500, sizeof(GL2PSprimitive*));
   gl2psPDFstacksInit();
 
-  gl2ps->xreflist = (int*)gl2psMalloc(sizeof(int) * gl2ps->objects_stack);
+  gl2ps->xreflist = (int*)gl2psMalloc(sizeof(int) * gl2ps->objects_stack); 
 
 #if defined(GL2PS_HAVE_ZLIB)
   if(gl2ps->options & GL2PS_COMPRESS){
     gl2psSetupCompress();
   }
-#endif
+#endif    
   gl2ps->xreflist[0] = 0;
   offs += fprintf(gl2ps->stream, "%%PDF-1.4\n");
   gl2ps->xreflist[1] = offs;
-
+  
   offs += gl2psPrintPDFInfo();
   gl2ps->xreflist[2] = offs;
-
+  
   offs += gl2psPrintPDFCatalog();
   gl2ps->xreflist[3] = offs;
-
+  
   offs += gl2psPrintPDFPages();
   gl2ps->xreflist[4] = offs;
-
+  
   offs += gl2psOpenPDFDataStream();
   gl2ps->xreflist[5] = offs; /* finished in gl2psPrintPDFFooter */
   gl2ps->streamlength = gl2psOpenPDFDataStreamWritePreface();
 }
 
 /* The central primitive drawing */
 
 static void gl2psPrintPDFPrimitive(void *data)
 {
   GL2PSprimitive *prim = *(GL2PSprimitive**)data;
 
-  if((gl2ps->options & GL2PS_OCCLUSION_CULL) && prim->culled)
+  if((gl2ps->options & GL2PS_OCCLUSION_CULL) && prim->culled) 
     return;
 
   prim = gl2psCopyPrimitive(prim); /* deep copy */
   gl2psListAdd(gl2ps->pdfprimlist, &prim);
 }
 
 /* close stream and ... */
 
 static int gl2psClosePDFDataStream(void)
 {
   int offs = 0;
-
+ 
 #if defined(GL2PS_HAVE_ZLIB)
   if(gl2ps->options & GL2PS_COMPRESS){
     if(Z_OK != gl2psDeflate())
       gl2psMsg(GL2PS_ERROR, "Zlib deflate error");
     else
       fwrite(gl2ps->compress->dest, gl2ps->compress->destLen, 1, gl2ps->stream);
     gl2ps->streamlength += gl2ps->compress->destLen;
-
+    
     offs += gl2ps->streamlength;
     gl2psFreeCompress();
   }
-#endif
-
-  offs += fprintf(gl2ps->stream,
+#endif 
+  
+  offs += fprintf(gl2ps->stream, 
                   "endstream\n"
                   "endobj\n");
   return offs;
 }
 
 /* ... write the now known length object */
 
 static int gl2psPrintPDFDataStreamLength(int val)
@@ -4092,58 +4086,58 @@ static int gl2psPrintPDFDataStreamLength
                  "endobj\n", val);
 }
 
 /* Put the info created before in PDF objects */
 
 static int gl2psPrintPDFOpenPage(void)
 {
   int offs;
-
+  
   /* Write fixed part */
-
-  offs = fprintf(gl2ps->stream,
+  
+  offs = fprintf(gl2ps->stream, 
                  "6 0 obj\n"
-                 "<<\n"
+                 "<<\n" 
                  "/Type /Page\n"
                  "/Parent 3 0 R\n"
                  "/MediaBox [%d %d %d %d]\n",
                  (int)gl2ps->viewport[0], (int)gl2ps->viewport[1],
                  (int)gl2ps->viewport[2], (int)gl2ps->viewport[3]);
-
+  
   if(gl2ps->options & GL2PS_LANDSCAPE)
     offs += fprintf(gl2ps->stream, "/Rotate -90\n");
-
+  
   offs += fprintf(gl2ps->stream,
                   "/Contents 4 0 R\n"
-                  "/Resources\n"
-                  "<<\n"
+                  "/Resources\n" 
+                  "<<\n" 
                   "/ProcSet [/PDF /Text /ImageB /ImageC]  %%/ImageI\n");
-
+  
   return offs;
 
   /* End fixed part, proceeds in gl2psPDFgroupListWriteVariableResources() */
 }
 
 static int gl2psPDFgroupListWriteVariableResources(void)
 {
   int offs = 0;
-
+  
   /* a) Graphics States for shader alpha masks*/
-  offs += gl2psPDFgroupListWriteGStateResources();
-
-  /* b) Shader and shader masks */
-  offs += gl2psPDFgroupListWriteShaderResources();
-
+  offs += gl2psPDFgroupListWriteGStateResources();  
+  
+  /* b) Shader and shader masks */ 
+  offs += gl2psPDFgroupListWriteShaderResources();  
+ 
   /* c) XObjects (Images & Shader Masks) */
   offs += gl2psPDFgroupListWriteXObjectResources();
-
+  
   /* d) Fonts */
   offs += gl2psPDFgroupListWriteFontResources();
-
+  
   /* End resources and page */
   offs += fprintf(gl2ps->stream,
                   ">>\n"
                   ">>\n"
                   "endobj\n");
   return offs;
 }
 
@@ -4164,229 +4158,229 @@ static int gl2psPrintPDFGSObject(void)
                  "/UCR2 /Default\n"
                  "/TR2 /Default\n"
                  ">>\n"
                  "endobj\n");
 }
 
 /* Put vertex' edge flag (8bit) and coordinates (32bit) in shader stream */
 
-static int gl2psPrintPDFShaderStreamDataCoord(GL2PSvertex *vertex,
-                                              size_t (*action)(unsigned long data,
-                                                               size_t size),
-                                              GLfloat dx, GLfloat dy,
+static int gl2psPrintPDFShaderStreamDataCoord(GL2PSvertex *vertex, 
+                                              size_t (*action)(unsigned long data, 
+                                                               size_t size), 
+                                              GLfloat dx, GLfloat dy, 
                                               GLfloat xmin, GLfloat ymin)
 {
   int offs = 0;
   unsigned long imap;
   GLfloat diff;
   double dmax = ~1UL;
   char edgeflag = 0;
 
   /* FIXME: temp bux fix for 64 bit archs: */
   if(sizeof(unsigned long) == 8) dmax = dmax - 2048.;
 
   offs += (*action)(edgeflag, 1);
 
   /* The Shader stream in PDF requires to be in a 'big-endian'
      order */
-
+    
   if(GL2PS_ZERO(dx * dy)){
     offs += (*action)(0, 4);
     offs += (*action)(0, 4);
   }
   else{
     diff = (vertex->xyz[0] - xmin) / dx;
     if(diff > 1)
       diff = 1.0F;
     else if(diff < 0)
       diff = 0.0F;
     imap = (unsigned long)(diff * dmax);
     offs += (*action)(imap, 4);
-
+      
     diff = (vertex->xyz[1] - ymin) / dy;
     if(diff > 1)
       diff = 1.0F;
     else if(diff < 0)
       diff = 0.0F;
     imap = (unsigned long)(diff * dmax);
     offs += (*action)(imap, 4);
   }
-
+  
   return offs;
 }
 
 /* Put vertex' rgb value (8bit for every component) in shader stream */
 
 static int gl2psPrintPDFShaderStreamDataRGB(GL2PSvertex *vertex,
-                                            size_t (*action)(unsigned long data,
+                                            size_t (*action)(unsigned long data, 
                                                              size_t size))
 {
   int offs = 0;
   unsigned long imap;
   double dmax = ~1UL;
 
   /* FIXME: temp bux fix for 64 bit archs: */
   if(sizeof(unsigned long) == 8) dmax = dmax - 2048.;
 
   imap = (unsigned long)((vertex->rgba[0]) * dmax);
   offs += (*action)(imap, 1);
-
+    
   imap = (unsigned long)((vertex->rgba[1]) * dmax);
   offs += (*action)(imap, 1);
-
+    
   imap = (unsigned long)((vertex->rgba[2]) * dmax);
   offs += (*action)(imap, 1);
-
+  
   return offs;
 }
 
 /* Put vertex' alpha (8/16bit) in shader stream */
 
-static int gl2psPrintPDFShaderStreamDataAlpha(GL2PSvertex *vertex,
-                                              size_t (*action)(unsigned long data,
+static int gl2psPrintPDFShaderStreamDataAlpha(GL2PSvertex *vertex, 
+                                              size_t (*action)(unsigned long data, 
                                                                size_t size),
                                               int sigbyte)
 {
   int offs = 0;
   unsigned long imap;
   double dmax = ~1UL;
 
   /* FIXME: temp bux fix for 64 bit archs: */
   if(sizeof(unsigned long) == 8) dmax = dmax - 2048.;
 
   if(sigbyte != 8 && sigbyte != 16)
     sigbyte = 8;
-
+        
   sigbyte /= 8;
-
+  
   imap = (unsigned long)((vertex->rgba[3]) * dmax);
-
+  
   offs += (*action)(imap, sigbyte);
-
+  
   return offs;
 }
 
 /* Put a triangles raw data in shader stream */
 
-static int gl2psPrintPDFShaderStreamData(GL2PStriangle *triangle,
-                                         GLfloat dx, GLfloat dy,
+static int gl2psPrintPDFShaderStreamData(GL2PStriangle *triangle, 
+                                         GLfloat dx, GLfloat dy, 
                                          GLfloat xmin, GLfloat ymin,
-                                         size_t (*action)(unsigned long data,
+                                         size_t (*action)(unsigned long data, 
                                                           size_t size),
                                          int gray)
 {
   int i, offs = 0;
   GL2PSvertex v;
-
+  
   if(gray && gray != 8 && gray != 16)
     gray = 8;
-
+  
   for(i = 0; i < 3; ++i){
     offs += gl2psPrintPDFShaderStreamDataCoord(&triangle->vertex[i], action,
                                                dx, dy, xmin, ymin);
-    if(gray){
+    if(gray){ 
       v = triangle->vertex[i];
-      offs += gl2psPrintPDFShaderStreamDataAlpha(&v, action, gray);
+      offs += gl2psPrintPDFShaderStreamDataAlpha(&v, action, gray); 
     }
     else{
       offs += gl2psPrintPDFShaderStreamDataRGB(&triangle->vertex[i], action);
     }
   }
-
+  
   return offs;
 }
 
-static void gl2psPDFRectHull(GLfloat *xmin, GLfloat *xmax,
-                             GLfloat *ymin, GLfloat *ymax,
+static void gl2psPDFRectHull(GLfloat *xmin, GLfloat *xmax, 
+                             GLfloat *ymin, GLfloat *ymax, 
                              GL2PStriangle *triangles, int cnt)
 {
   int i, j;
 
   *xmin = triangles[0].vertex[0].xyz[0];
   *xmax = triangles[0].vertex[0].xyz[0];
   *ymin = triangles[0].vertex[0].xyz[1];
   *ymax = triangles[0].vertex[0].xyz[1];
-
+  
   for(i = 0; i < cnt; ++i){
     for(j = 0; j < 3; ++j){
       if(*xmin > triangles[i].vertex[j].xyz[0])
         *xmin = triangles[i].vertex[j].xyz[0];
       if(*xmax < triangles[i].vertex[j].xyz[0])
         *xmax = triangles[i].vertex[j].xyz[0];
       if(*ymin > triangles[i].vertex[j].xyz[1])
         *ymin = triangles[i].vertex[j].xyz[1];
       if(*ymax < triangles[i].vertex[j].xyz[1])
         *ymax = triangles[i].vertex[j].xyz[1];
     }
   }
 }
 
-/* Writes shaded triangle
+/* Writes shaded triangle 
    gray == 0 means write RGB triangles
    gray == 8             8bit-grayscale (for alpha masks)
    gray == 16            16bit-grayscale (for alpha masks) */
 
-static int gl2psPrintPDFShader(int obj, GL2PStriangle *triangles,
+static int gl2psPrintPDFShader(int obj, GL2PStriangle *triangles, 
                                int size, int gray)
 {
   int i, offs = 0, vertexbytes, done = 0;
   GLfloat xmin, xmax, ymin, ymax;
-
+        
   switch(gray){
   case 0:
     vertexbytes = 1+4+4+1+1+1;
     break;
   case 8:
     vertexbytes = 1+4+4+1;
     break;
   case 16:
     vertexbytes = 1+4+4+2;
     break;
   default:
     gray = 8;
     vertexbytes = 1+4+4+1;
     break;
   }
-
+  
   gl2psPDFRectHull(&xmin, &xmax, &ymin, &ymax, triangles, size);
-
+  
   offs += fprintf(gl2ps->stream,
                   "%d 0 obj\n"
                   "<< "
                   "/ShadingType 4 "
                   "/ColorSpace %s "
                   "/BitsPerCoordinate 32 "
                   "/BitsPerComponent %d "
                   "/BitsPerFlag 8 "
                   "/Decode [%f %f %f %f 0 1 %s] ",
                   obj,
-                  (gray) ? "/DeviceGray" : "/DeviceRGB",
+                  (gray) ? "/DeviceGray" : "/DeviceRGB", 
                   (gray) ? gray : 8,
                   xmin, xmax, ymin, ymax,
                   (gray) ? "" : "0 1 0 1");
-
+  
 #if defined(GL2PS_HAVE_ZLIB)
   if(gl2ps->options & GL2PS_COMPRESS){
     gl2psAllocCompress(vertexbytes * size * 3);
 
     for(i = 0; i < size; ++i)
       gl2psPrintPDFShaderStreamData(&triangles[i],
-                                    xmax-xmin, ymax-ymin, xmin, ymin,
+                                    xmax-xmin, ymax-ymin, xmin, ymin, 
                                     gl2psWriteBigEndianCompress, gray);
 
     if(Z_OK == gl2psDeflate() && 23 + gl2ps->compress->destLen < gl2ps->compress->srcLen){
       offs += gl2psPrintPDFCompressorType();
       offs += fprintf(gl2ps->stream,
                       "/Length %d "
                       ">>\n"
                       "stream\n",
                       (int)gl2ps->compress->destLen);
-      offs += gl2ps->compress->destLen * fwrite(gl2ps->compress->dest,
-                                                gl2ps->compress->destLen,
+      offs += gl2ps->compress->destLen * fwrite(gl2ps->compress->dest, 
+                                                gl2ps->compress->destLen, 
                                                 1, gl2ps->stream);
       done = 1;
     }
     gl2psFreeCompress();
   }
 #endif
 
   if(!done){
@@ -4397,118 +4391,118 @@ static int gl2psPrintPDFShader(int obj, 
                     ">>\n"
                     "stream\n",
                     vertexbytes * 3 * size);
     for(i = 0; i < size; ++i)
       offs += gl2psPrintPDFShaderStreamData(&triangles[i],
                                             xmax-xmin, ymax-ymin, xmin, ymin,
                                             gl2psWriteBigEndian, gray);
   }
-
+  
   offs += fprintf(gl2ps->stream,
                   "\nendstream\n"
                   "endobj\n");
-
+  
   return offs;
 }
 
 /* Writes a XObject for a shaded triangle mask */
 
 static int gl2psPrintPDFShaderMask(int obj, int childobj)
 {
   int offs = 0, len;
-
+  
   offs += fprintf(gl2ps->stream,
                   "%d 0 obj\n"
                   "<<\n"
                   "/Type /XObject\n"
                   "/Subtype /Form\n"
                   "/BBox [ %d %d %d %d ]\n"
                   "/Group \n<<\n/S /Transparency /CS /DeviceRGB\n"
                   ">>\n",
                   obj,
                   (int)gl2ps->viewport[0], (int)gl2ps->viewport[1],
                   (int)gl2ps->viewport[2], (int)gl2ps->viewport[3]);
-
-  len = (childobj>0)
+  
+  len = (childobj>0) 
     ? strlen("/TrSh sh\n") + (int)log10((double)childobj)+1
-    : strlen("/TrSh0 sh\n");
-
+    : strlen("/TrSh0 sh\n"); 
+  
   offs += fprintf(gl2ps->stream,
                   "/Length %d\n"
                   ">>\n"
                   "stream\n",
                   len);
   offs += fprintf(gl2ps->stream,
                   "/TrSh%d sh\n",
                   childobj);
   offs += fprintf(gl2ps->stream,
                   "endstream\n"
                   "endobj\n");
-
+  
   return offs;
 }
 
 /* Writes a Extended graphics state for a shaded triangle mask if
    simplealpha ist true the childobj argument is ignored and a /ca
    statement will be written instead */
 
 static int gl2psPrintPDFShaderExtGS(int obj, int childobj)
 {
   int offs = 0;
-
+  
   offs += fprintf(gl2ps->stream,
                   "%d 0 obj\n"
                   "<<\n",
                   obj);
-
+  
   offs += fprintf(gl2ps->stream,
                   "/SMask << /S /Alpha /G %d 0 R >> ",
                   childobj);
-
+  
   offs += fprintf(gl2ps->stream,
                   ">>\n"
                   "endobj\n");
   return offs;
 }
 
 /* a simple graphics state */
 
 static int gl2psPrintPDFShaderSimpleExtGS(int obj, GLfloat alpha)
 {
   int offs = 0;
-
+  
   offs += fprintf(gl2ps->stream,
                   "%d 0 obj\n"
                   "<<\n"
                   "/ca %g"
                   ">>\n"
                   "endobj\n",
                   obj, alpha);
   return offs;
 }
 
 /* Similar groups of functions for pixmaps and text */
 
 static int gl2psPrintPDFPixmapStreamData(GL2PSimage *im,
-                                         size_t (*action)(unsigned long data,
-                                                          size_t size),
+                                         size_t (*action)(unsigned long data, 
+                                                          size_t size), 
                                          int gray)
 {
   int x, y, shift;
   GLfloat r, g, b, a;
 
   if(im->format != GL_RGBA && gray)
     return 0;
 
   if(gray && gray != 8 && gray != 16)
     gray = 8;
 
   gray /= 8;
-
+  
   shift = (sizeof(unsigned long) - 1) * 8;
 
   for(y = 0; y < im->height; ++y){
     for(x = 0; x < im->width; ++x){
       a = gl2psGetRGB(im, x, y, &r, &g, &b);
       if(im->format == GL_RGBA && gray){
         (*action)((unsigned long)(a * 255) << shift, gray);
       }
@@ -4529,20 +4523,20 @@ static int gl2psPrintPDFPixmapStreamData
 }
 
 static int gl2psPrintPDFPixmap(int obj, int childobj, GL2PSimage *im, int gray)
 {
   int offs = 0, done = 0, sigbytes = 3;
 
   if(gray && gray !=8 && gray != 16)
     gray = 8;
-
+  
   if(gray)
-    sigbytes = gray / 8;
-
+    sigbytes = gray / 8; 
+  
   offs += fprintf(gl2ps->stream,
                   "%d 0 obj\n"
                   "<<\n"
                   "/Type /XObject\n"
                   "/Subtype /Image\n"
                   "/Width %d\n"
                   "/Height %d\n"
                   "/ColorSpace %s \n"
@@ -4550,60 +4544,60 @@ static int gl2psPrintPDFPixmap(int obj, 
                   obj,
                   (int)im->width, (int)im->height,
                   (gray) ? "/DeviceGray" : "/DeviceRGB" );
   if(GL_RGBA == im->format && gray == 0){
     offs += fprintf(gl2ps->stream,
                     "/SMask %d 0 R\n",
                     childobj);
   }
-
+  
 #if defined(GL2PS_HAVE_ZLIB)
   if(gl2ps->options & GL2PS_COMPRESS){
     gl2psAllocCompress((int)(im->width * im->height * sigbytes));
-
+    
     gl2psPrintPDFPixmapStreamData(im, gl2psWriteBigEndianCompress, gray);
-
+    
     if(Z_OK == gl2psDeflate() && 23 + gl2ps->compress->destLen < gl2ps->compress->srcLen){
       offs += gl2psPrintPDFCompressorType();
       offs += fprintf(gl2ps->stream,
                       "/Length %d "
                       ">>\n"
                       "stream\n",
                       (int)gl2ps->compress->destLen);
       offs += gl2ps->compress->destLen * fwrite(gl2ps->compress->dest, gl2ps->compress->destLen,
                                                 1, gl2ps->stream);
       done = 1;
     }
     gl2psFreeCompress();
   }
 #endif
-
+  
   if(!done){
     /* no compression, or too long after compression, or compress error
        -> write non-compressed entry */
     offs += fprintf(gl2ps->stream,
                     "/Length %d "
                     ">>\n"
                     "stream\n",
                     (int)(im->width * im->height * sigbytes));
     offs += gl2psPrintPDFPixmapStreamData(im, gl2psWriteBigEndian, gray);
   }
-
+  
   offs += fprintf(gl2ps->stream,
                   "\nendstream\n"
                   "endobj\n");
-
+  
   return offs;
 }
 
 static int gl2psPrintPDFText(int obj, GL2PSstring *s, int fontnumber)
 {
   int offs = 0;
-
+  
   offs += fprintf(gl2ps->stream,
                   "%d 0 obj\n"
                   "<<\n"
                   "/Type /Font\n"
                   "/Subtype /Type1\n"
                   "/Name /F%d\n"
                   "/BaseFont /%s\n"
                   "/Encoding /MacRomanEncoding\n"
@@ -4621,31 +4615,31 @@ static int gl2psPDFgroupListWriteObjects
   GL2PSprimitive *p = NULL;
   GL2PSpdfgroup *gro;
   int offs = entryoffs;
   GL2PStriangle *triangles;
   int size = 0;
 
   if(!gl2ps->pdfgrouplist)
     return offs;
-
-  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){
-    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i);
+  
+  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){  
+    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i); 
     if(!gl2psListNbr(gro->ptrlist))
       continue;
     p = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, 0);
     switch(p->type){
     case GL2PS_POINT:
       break;
     case GL2PS_LINE:
       break;
     case GL2PS_TRIANGLE:
       size = gl2psListNbr(gro->ptrlist);
       triangles = (GL2PStriangle*)gl2psMalloc(sizeof(GL2PStriangle) * size);
-      for(j = 0; j < size; ++j){
+      for(j = 0; j < size; ++j){  
         p = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
         gl2psFillTriangleFromPrimitive(&triangles[j], p, GL_TRUE);
       }
       if(triangles[0].prop & T_VAR_COLOR){
         gl2ps->xreflist[gro->shobjno] = offs;
         offs += gl2psPrintPDFShader(gro->shobjno, triangles, size, 0);
       }
       if(triangles[0].prop & T_ALPHA_LESS_1){
@@ -4677,79 +4671,79 @@ static int gl2psPDFgroupListWriteObjects
     case GL2PS_SPECIAL :
       /* alignment contains the format for which the special output text
          is intended */
       if(p->data.text->alignment == GL2PS_PDF)
         offs += fprintf(gl2ps->stream, "%s\n", p->data.text->str);
       break;
     default:
       break;
-    }
+    } 
   }
   return offs;
 }
 
 /* All variable data has been written at this point and all required
    functioninality has been gathered, so we can write now file footer
    with cross reference table and trailer */
 
 static void gl2psPrintPDFFooter(void)
 {
-  int i, offs;
+  int i, offs;  
 
   gl2psPDFgroupListInit();
   gl2psPDFgroupListWriteMainStream();
-
-  offs = gl2ps->xreflist[5] + gl2ps->streamlength;
+ 
+  offs = gl2ps->xreflist[5] + gl2ps->streamlength; 
   offs += gl2psClosePDFDataStream();
   gl2ps->xreflist[5] = offs;
-
+  
   offs += gl2psPrintPDFDataStreamLength(gl2ps->streamlength);
   gl2ps->xreflist[6] = offs;
   gl2ps->streamlength = 0;
-
+  
   offs += gl2psPrintPDFOpenPage();
   offs += gl2psPDFgroupListWriteVariableResources();
   gl2ps->xreflist = (int*)gl2psRealloc(gl2ps->xreflist,
                                        sizeof(int) * (gl2ps->objects_stack + 1));
   gl2ps->xreflist[7] = offs;
-
+  
   offs += gl2psPrintPDFGSObject();
   gl2ps->xreflist[8] = offs;
-
-  gl2ps->xreflist[gl2ps->objects_stack] =
+  
+  gl2ps->xreflist[gl2ps->objects_stack] = 
     gl2psPDFgroupListWriteObjects(gl2ps->xreflist[8]);
 
   /* Start cross reference table. The file has to been opened in
      binary mode to preserve the 20 digit string length! */
   fprintf(gl2ps->stream,
           "xref\n"
           "0 %d\n"
           "%010d 65535 f \n", gl2ps->objects_stack, 0);
-
+  
   for(i = 1; i < gl2ps->objects_stack; ++i)
     fprintf(gl2ps->stream, "%010d 00000 n \n", gl2ps->xreflist[i]);
-
+  
   fprintf(gl2ps->stream,
           "trailer\n"
-          "<<\n"
+          "<<\n" 
           "/Size %d\n"
           "/Info 1 0 R\n"
           "/Root 2 0 R\n"
           ">>\n"
           "startxref\n%d\n"
           "%%%%EOF\n",
           gl2ps->objects_stack, gl2ps->xreflist[gl2ps->objects_stack]);
-
-  /* Free auxiliary lists and arrays */
+  
+  /* Free auxiliary lists and arrays */    
   gl2psFree(gl2ps->xreflist);
   gl2psListAction(gl2ps->pdfprimlist, gl2psFreePrimitive);
   gl2psListDelete(gl2ps->pdfprimlist);
   gl2psPDFgroupListDelete();
-
+  
 #if defined(GL2PS_HAVE_ZLIB)
   if(gl2ps->options & GL2PS_COMPRESS){
     gl2psFreeCompress();
     gl2psFree(gl2ps->compress);
     gl2ps->compress = NULL;
   }
 #endif
 }
@@ -4757,26 +4751,26 @@ static void gl2psPrintPDFFooter(void)
 /* PDF begin viewport */
 
 static void gl2psPrintPDFBeginViewport(GLint viewport[4])
 {
   int offs = 0;
   GLint index;
   GLfloat rgba[4];
   int x = viewport[0], y = viewport[1], w = viewport[2], h = viewport[3];
-
+  
   glRenderMode(GL_FEEDBACK);
-
+  
   if(gl2ps->header){
     gl2psPrintPDFHeader();
     gl2ps->header = GL_FALSE;
   }
 
   offs += gl2psPrintf("q\n");
-
+  
   if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
     if(gl2ps->colormode == GL_RGBA || gl2ps->colorsize == 0){
       glGetFloatv(GL_COLOR_CLEAR_VALUE, rgba);
     }
     else{
       glGetIntegerv(GL_INDEX_CLEAR_VALUE, &index);
       rgba[0] = gl2ps->colormap[index][0];
       rgba[1] = gl2ps->colormap[index][1];
@@ -4786,28 +4780,28 @@ static void gl2psPrintPDFBeginViewport(G
     offs += gl2psPrintPDFFillColor(rgba);
     offs += gl2psPrintf("%d %d %d %d re\n"
                         "W\n"
                         "f\n",
                         x, y, w, h);
   }
   else{
     offs += gl2psPrintf("%d %d %d %d re\n"
-                        "W\n"
+                        "W\n"   
                         "n\n",
-                        x, y, w, h);
-  }
-
+                        x, y, w, h);            
+  }
+  
   gl2ps->streamlength += offs;
 }
 
 static GLint gl2psPrintPDFEndViewport(void)
 {
   GLint res;
-
+  
   res = gl2psPrintPrimitives();
   gl2ps->streamlength += gl2psPrintf("Q\n");
   return res;
 }
 
 static void gl2psPrintPDFFinalPrimitive(void)
 {
 }
@@ -4820,23 +4814,23 @@ static GL2PSbackend gl2psPDF = {
   gl2psPrintPDFBeginViewport,
   gl2psPrintPDFEndViewport,
   gl2psPrintPDFPrimitive,
   gl2psPrintPDFFinalPrimitive,
   "pdf",
   "Portable Document Format"
 };
 
-/*********************************************************************
+/********************************************************************* 
  *
  * SVG routines
  *
  *********************************************************************/
 
-static void gl2psSVGGetCoordsAndColors(int n, GL2PSvertex *verts,
+static void gl2psSVGGetCoordsAndColors(int n, GL2PSvertex *verts, 
                                        GL2PSxyz *xyz, GL2PSrgba *rgba)
 {
   int i, j;
 
   for(i = 0; i < n; i++){
     xyz[i][0] = verts[i].xyz[0];
     xyz[i][1] = gl2ps->viewport[3] - verts[i].xyz[1];
     xyz[i][2] = 0.0F;
@@ -4856,35 +4850,35 @@ static void gl2psSVGGetColorString(GL2PS
   sprintf(str, "#%2.2x%2.2x%2.2x", rc, gc, bc);
 }
 
 static void gl2psPrintSVGHeader(void)
 {
   int x, y, width, height;
   char col[32];
   time_t now;
-
+  
   time(&now);
-
+  
   if (gl2ps->options & GL2PS_LANDSCAPE){
     x = (int)gl2ps->viewport[1];
     y = (int)gl2ps->viewport[0];
     width = (int)gl2ps->viewport[3];
     height = (int)gl2ps->viewport[2];
   }
   else{
     x = (int)gl2ps->viewport[0];
     y = (int)gl2ps->viewport[1];
     width = (int)gl2ps->viewport[2];
     height = (int)gl2ps->viewport[3];
   }
-
+  
   /* Compressed SVG files (.svgz) are simply gzipped SVG files */
   gl2psPrintGzipHeader();
-
+  
   gl2psPrintf("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n");
   gl2psPrintf("<svg xmlns=\"http://www.w3.org/2000/svg\"\n");
   gl2psPrintf("     xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n"
               "     width=\"%dpx\" height=\"%dpx\" viewBox=\"%d %d %d %d\">\n",
               width, height, x, y, width, height);
   gl2psPrintf("<title>%s</title>\n", gl2ps->title);
   gl2psPrintf("<desc>\n");
   gl2psPrintf("Creator: GL2PS %d.%d.%d%s, %s\n"
@@ -4894,19 +4888,19 @@ static void gl2psPrintSVGHeader(void)
               GL2PS_EXTRA_VERSION, GL2PS_COPYRIGHT, gl2ps->producer, ctime(&now));
   gl2psPrintf("</desc>\n");
   gl2psPrintf("<defs>\n");
   gl2psPrintf("</defs>\n");
 
   if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
     gl2psSVGGetColorString(gl2ps->bgcolor, col);
     gl2psPrintf("<polygon fill=\"%s\" points=\"%d,%d %d,%d %d,%d %d,%d\"/>\n", col,
-                (int)gl2ps->viewport[0], (int)gl2ps->viewport[1],
-                (int)gl2ps->viewport[2], (int)gl2ps->viewport[1],
-                (int)gl2ps->viewport[2], (int)gl2ps->viewport[3],
+                (int)gl2ps->viewport[0], (int)gl2ps->viewport[1], 
+                (int)gl2ps->viewport[2], (int)gl2ps->viewport[1], 
+                (int)gl2ps->viewport[2], (int)gl2ps->viewport[3], 
                 (int)gl2ps->viewport[0], (int)gl2ps->viewport[3]);
   }
 
   /* group all the primitives and disable antialiasing */
   gl2psPrintf("<g shape-rendering=\"crispEdges\">\n");
 }
 
 static void gl2psPrintSVGSmoothTriangle(GL2PSxyz xyz[3], GL2PSrgba rgba[3])
@@ -4919,62 +4913,62 @@ static void gl2psPrintSVGSmoothTriangle(
   /* Apparently there is no easy way to do Gouraud shading in SVG
      without explicitly pre-defining gradients, so for now we just do
      recursive subdivision */
 
   if(gl2psSameColorThreshold(3, rgba, gl2ps->threshold)){
     gl2psSVGGetColorString(rgba[0], col);
     gl2psPrintf("<polygon fill=\"%s\" ", col);
     if(rgba[0][3] < 1.0F) gl2psPrintf("fill-opacity=\"%g\" ", rgba[0][3]);
-    gl2psPrintf("points=\"%g,%g %g,%g %g,%g\"/>\n", xyz[0][0], xyz[0][1],
+    gl2psPrintf("points=\"%g,%g %g,%g %g,%g\"/>\n", xyz[0][0], xyz[0][1], 
                 xyz[1][0], xyz[1][1], xyz[2][0], xyz[2][1]);
   }
   else{
     /* subdivide into 4 subtriangles */
     for(i = 0; i < 3; i++){
-      xyz2[0][i] = xyz[0][i];
+      xyz2[0][i] = xyz[0][i]; 
       xyz2[1][i] = 0.5F * (xyz[0][i] + xyz[1][i]);
       xyz2[2][i] = 0.5F * (xyz[0][i] + xyz[2][i]);
     }
     for(i = 0; i < 4; i++){
-      rgba2[0][i] = rgba[0][i];
+      rgba2[0][i] = rgba[0][i]; 
       rgba2[1][i] = 0.5F * (rgba[0][i] + rgba[1][i]);
       rgba2[2][i] = 0.5F * (rgba[0][i] + rgba[2][i]);
     }
     gl2psPrintSVGSmoothTriangle(xyz2, rgba2);
     for(i = 0; i < 3; i++){
       xyz2[0][i] = 0.5F * (xyz[0][i] + xyz[1][i]);
-      xyz2[1][i] = xyz[1][i];
+      xyz2[1][i] = xyz[1][i]; 
       xyz2[2][i] = 0.5F * (xyz[1][i] + xyz[2][i]);
     }
     for(i = 0; i < 4; i++){
       rgba2[0][i] = 0.5F * (rgba[0][i] + rgba[1][i]);
-      rgba2[1][i] = rgba[1][i];
+      rgba2[1][i] = rgba[1][i]; 
       rgba2[2][i] = 0.5F * (rgba[1][i] + rgba[2][i]);
     }
     gl2psPrintSVGSmoothTriangle(xyz2, rgba2);
     for(i = 0; i < 3; i++){
       xyz2[0][i] = 0.5F * (xyz[0][i] + xyz[2][i]);
-      xyz2[1][i] = xyz[2][i];
+      xyz2[1][i] = xyz[2][i]; 
       xyz2[2][i] = 0.5F * (xyz[1][i] + xyz[2][i]);
     }
     for(i = 0; i < 4; i++){
       rgba2[0][i] = 0.5F * (rgba[0][i] + rgba[2][i]);
-      rgba2[1][i] = rgba[2][i];
+      rgba2[1][i] = rgba[2][i]; 
       rgba2[2][i] = 0.5F * (rgba[1][i] + rgba[2][i]);
     }
     gl2psPrintSVGSmoothTriangle(xyz2, rgba2);
     for(i = 0; i < 3; i++){
       xyz2[0][i] = 0.5F * (xyz[0][i] + xyz[1][i]);
-      xyz2[1][i] = 0.5F * (xyz[1][i] + xyz[2][i]);
+      xyz2[1][i] = 0.5F * (xyz[1][i] + xyz[2][i]); 
       xyz2[2][i] = 0.5F * (xyz[0][i] + xyz[2][i]);
     }
     for(i = 0; i < 4; i++){
       rgba2[0][i] = 0.5F * (rgba[0][i] + rgba[1][i]);
-      rgba2[1][i] = 0.5F * (rgba[1][i] + rgba[2][i]);
+      rgba2[1][i] = 0.5F * (rgba[1][i] + rgba[2][i]); 
       rgba2[2][i] = 0.5F * (rgba[0][i] + rgba[2][i]);
     }
     gl2psPrintSVGSmoothTriangle(xyz2, rgba2);
   }
 }
 
 static void gl2psPrintSVGDash(GLushort pattern, GLint factor)
 {
@@ -4990,17 +4984,17 @@ static void gl2psPrintSVGDash(GLushort p
   }
   gl2psPrintf("\" ");
 }
 
 static void gl2psEndSVGLine(void)
 {
   int i;
   if(gl2ps->lastvertex.rgba[0] >= 0.){
-    gl2psPrintf("%g,%g\"/>\n", gl2ps->lastvertex.xyz[0],
+    gl2psPrintf("%g,%g\"/>\n", gl2ps->lastvertex.xyz[0], 
                 gl2ps->viewport[3] - gl2ps->lastvertex.xyz[1]);
     for(i = 0; i < 3; i++)
       gl2ps->lastvertex.xyz[i] = -1.;
     for(i = 0; i < 4; i++)
       gl2ps->lastvertex.rgba[i] = -1.;
   }
 }
 
@@ -5012,17 +5006,17 @@ static void gl2psPrintSVGPixmap(GLfloat 
   int i;
 
   /* The only image types supported by the SVG standard are JPEG, PNG
      and SVG. Here we choose PNG, and since we want to embed the image
      directly in the SVG stream (and not link to an external image
      file), we need to encode the pixmap into PNG in memory, then
      encode it into base64. */
 
-  png = gl2psListCreate(pixmap->width * pixmap->height * 3, 1000,
+  png = gl2psListCreate(pixmap->width * pixmap->height * 3, 1000, 
                         sizeof(unsigned char));
   gl2psConvertPixmapToPNG(pixmap, png);
   gl2psListEncodeBase64(png);
   gl2psPrintf("<image x=\"%g\" y=\"%g\" width=\"%d\" height=\"%d\"\n",
               x, y - pixmap->height, pixmap->width, pixmap->height);
   gl2psPrintf("xlink:href=\"data:image/png;base64,");
   for(i = 0; i < gl2psListNbr(png); i++){
     gl2psListRead(png, i, &c);
@@ -5081,17 +5075,17 @@ static void gl2psPrintSVGPrimitive(void 
     }
     gl2ps->lastvertex = prim->verts[1];
     gl2psSetLastColor(prim->verts[0].rgba);
     gl2ps->lastlinewidth = prim->width;
     gl2ps->lastpattern = prim->pattern;
     gl2ps->lastfactor = prim->factor;
     if(newline){
       gl2psSVGGetColorString(rgba[0], col);
-      gl2psPrintf("<polyline fill=\"none\" stroke=\"%s\" stroke-width=\"%g\" ",
+      gl2psPrintf("<polyline fill=\"none\" stroke=\"%s\" stroke-width=\"%g\" ", 
                   col, prim->width);
       if(rgba[0][3] < 1.0F) gl2psPrintf("stroke-opacity=\"%g\" ", rgba[0][3]);
       gl2psPrintSVGDash(prim->pattern, prim->factor);
       gl2psPrintf("points=\"%g,%g ", xyz[0][0], xyz[0][1]);
     }
     else{
       gl2psPrintf("%g,%g ", xyz[0][0], xyz[0][1]);
     }
@@ -5107,52 +5101,16 @@ static void gl2psPrintSVGPrimitive(void 
     break;
   case GL2PS_TEXT :
     gl2psSVGGetColorString(prim->verts[0].rgba, col);
     gl2psPrintf("<text fill=\"%s\" x=\"%g\" y=\"%g\" font-size=\"%d\" ",
                 col, xyz[0][0], xyz[0][1], prim->data.text->fontsize);
     if(prim->data.text->angle)
       gl2psPrintf("transform=\"rotate(%g, %g, %g)\" ",
                   -prim->data.text->angle, xyz[0][0], xyz[0][1]);
-    switch(prim->data.text->alignment){
-    case GL2PS_TEXT_C:
-      gl2psPrintf("text-anchor=\"middle\" baseline-shift=\"%d\" ",
-                  -prim->data.text->fontsize / 2);
-      break;
-    case GL2PS_TEXT_CL:
-      gl2psPrintf("text-anchor=\"start\" baseline-shift=\"%d\" ",
-                  -prim->data.text->fontsize / 2);
-      break;
-    case GL2PS_TEXT_CR:
-      gl2psPrintf("text-anchor=\"end\" baseline-shift=\"%d\" ",
-                  -prim->data.text->fontsize / 2);
-      break;
-    case GL2PS_TEXT_B:
-      gl2psPrintf("text-anchor=\"middle\" baseline-shift=\"0\" ");
-      break;
-    case GL2PS_TEXT_BR:
-      gl2psPrintf("text-anchor=\"end\" baseline-shift=\"0\" ");
-      break;
-    case GL2PS_TEXT_T:
-      gl2psPrintf("text-anchor=\"middle\" baseline-shift=\"%d\" ",
-                  -prim->data.text->fontsize);
-      break;
-    case GL2PS_TEXT_TL:
-      gl2psPrintf("text-anchor=\"start\" baseline-shift=\"%d\" ",
-                  -prim->data.text->fontsize);
-      break;
-    case GL2PS_TEXT_TR:
-      gl2psPrintf("text-anchor=\"end\" baseline-shift=\"%d\" ",
-                  -prim->data.text->fontsize);
-      break;
-    case GL2PS_TEXT_BL:
-    default: /* same as GL2PS_TEXT_BL */
-      gl2psPrintf("text-anchor=\"start\" baseline-shift=\"0\" ");
-      break;
-    }
     if(!strcmp(prim->data.text->fontname, "Times-Roman"))
       gl2psPrintf("font-family=\"Times\">");
     else if(!strcmp(prim->data.text->fontname, "Times-Bold"))
       gl2psPrintf("font-family=\"Times\" font-weight=\"bold\">");
     else if(!strcmp(prim->data.text->fontname, "Times-Italic"))
       gl2psPrintf("font-family=\"Times\" font-style=\"italic\">");
     else if(!strcmp(prim->data.text->fontname, "Times-BoldItalic"))
       gl2psPrintf("font-family=\"Times\" font-style=\"italic\" font-weight=\"bold\">");
@@ -5181,30 +5139,30 @@ static void gl2psPrintSVGPrimitive(void 
   default :
     break;
   }
 }
 
 static void gl2psPrintSVGFooter(void)
 {
   gl2psPrintf("</g>\n");
-  gl2psPrintf("</svg>\n");
-
+  gl2psPrintf("</svg>\n");  
+  
   gl2psPrintGzipFooter();
 }
 
 static void gl2psPrintSVGBeginViewport(GLint viewport[4])
 {
   GLint index;
   char col[32];
   GLfloat rgba[4];
   int x = viewport[0], y = viewport[1], w = viewport[2], h = viewport[3];
 
   glRenderMode(GL_FEEDBACK);
-
+  
   if(gl2ps->header){
     gl2psPrintSVGHeader();
     gl2ps->header = GL_FALSE;
   }
 
   if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
     if(gl2ps->colormode == GL_RGBA || gl2ps->colorsize == 0){
       glGetFloatv(GL_COLOR_CLEAR_VALUE, rgba);
@@ -5212,28 +5170,28 @@ static void gl2psPrintSVGBeginViewport(G
     else{
       glGetIntegerv(GL_INDEX_CLEAR_VALUE, &index);
       rgba[0] = gl2ps->colormap[index][0];
       rgba[1] = gl2ps->colormap[index][1];
       rgba[2] = gl2ps->colormap[index][2];
       rgba[3] = 1.0F;
     }
     gl2psSVGGetColorString(rgba, col);
-    gl2psPrintf("<polygon fill=\"%s\" points=\"%d,%d %d,%d %d,%d %d,%d\"/>\n", col,
-                x, gl2ps->viewport[3] - y,
-                x + w, gl2ps->viewport[3] - y,
-                x + w, gl2ps->viewport[3] - (y + h),
+    gl2psPrintf("<polygon fill=\"%s\" points=\"%d,%d %d,%d %d,%d %d,%d\"/>\n", col, 
+                x, gl2ps->viewport[3] - y, 
+                x + w, gl2ps->viewport[3] - y, 
+                x + w, gl2ps->viewport[3] - (y + h), 
                 x, gl2ps->viewport[3] - (y + h));
   }
 
   gl2psPrintf("<clipPath id=\"cp%d%d%d%d\">\n", x, y, w, h);
-  gl2psPrintf("  <polygon points=\"%d,%d %d,%d %d,%d %d,%d\"/>\n",
-              x, gl2ps->viewport[3] - y,
-              x + w, gl2ps->viewport[3] - y,
-              x + w, gl2ps->viewport[3] - (y + h),
+  gl2psPrintf("  <polygon points=\"%d,%d %d,%d %d,%d %d,%d\"/>\n", 
+              x, gl2ps->viewport[3] - y, 
+              x + w, gl2ps->viewport[3] - y, 
+              x + w, gl2ps->viewport[3] - (y + h), 
               x, gl2ps->viewport[3] - (y + h));
   gl2psPrintf("</clipPath>\n");
   gl2psPrintf("<g clip-path=\"url(#cp%d%d%d%d)\">\n", x, y, w, h);
 }
 
 static GLint gl2psPrintSVGEndViewport(void)
 {
   GLint res;
@@ -5277,17 +5235,17 @@ static void gl2psPrintPGFColor(GL2PSrgba
 }
 
 static void gl2psPrintPGFHeader(void)
 {
   time_t now;
 
   time(&now);
 
-  fprintf(gl2ps->stream,
+  fprintf(gl2ps->stream, 
           "%% Title: %s\n"
           "%% Creator: GL2PS %d.%d.%d%s, %s\n"
           "%% For: %s\n"
           "%% CreationDate: %s",
           gl2ps->title, GL2PS_MAJOR_VERSION, GL2PS_MINOR_VERSION,
           GL2PS_PATCH_VERSION, GL2PS_EXTRA_VERSION, GL2PS_COPYRIGHT,
           gl2ps->producer, ctime(&now));
 
@@ -5331,59 +5289,59 @@ static const char *gl2psPGFTextAlignment
   case GL2PS_TEXT_C  : return "center";
   case GL2PS_TEXT_CL : return "west";
   case GL2PS_TEXT_CR : return "east";
   case GL2PS_TEXT_B  : return "south";
   case GL2PS_TEXT_BR : return "south east";
   case GL2PS_TEXT_T  : return "north";
   case GL2PS_TEXT_TL : return "north west";
   case GL2PS_TEXT_TR : return "north east";
-  case GL2PS_TEXT_BL :
+  case GL2PS_TEXT_BL : 
   default            : return "south west";
   }
 }
 
 static void gl2psPrintPGFPrimitive(void *data)
 {
   GL2PSprimitive *prim;
 
   prim = *(GL2PSprimitive**)data;
 
   switch(prim->type){
   case GL2PS_POINT :
     /* Points in openGL are rectangular */
     gl2psPrintPGFColor(prim->verts[0].rgba);
-    fprintf(gl2ps->stream,
+    fprintf(gl2ps->stream, 
             "\\pgfpathrectangle{\\pgfpoint{%fpt}{%fpt}}"
             "{\\pgfpoint{%fpt}{%fpt}}\n\\pgfusepath{fill}\n",
             prim->verts[0].xyz[0]-0.5*prim->width,
             prim->verts[0].xyz[1]-0.5*prim->width,
             prim->width,prim->width);
     break;
   case GL2PS_LINE :
     gl2psPrintPGFColor(prim->verts[0].rgba);
     if(gl2ps->lastlinewidth != prim->width){
       gl2ps->lastlinewidth = prim->width;
       fprintf(gl2ps->stream, "\\pgfsetlinewidth{%fpt}\n", gl2ps->lastlinewidth);
     }
     gl2psPrintPGFDash(prim->pattern, prim->factor);
-    fprintf(gl2ps->stream,
+    fprintf(gl2ps->stream, 
             "\\pgfpathmoveto{\\pgfpoint{%fpt}{%fpt}}\n"
             "\\pgflineto{\\pgfpoint{%fpt}{%fpt}}\n"
             "\\pgfusepath{stroke}\n",
             prim->verts[1].xyz[0], prim->verts[1].xyz[1],
             prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
     break;
   case GL2PS_TRIANGLE :
     if(gl2ps->lastlinewidth != 0){
       gl2ps->lastlinewidth = 0;
       fprintf(gl2ps->stream, "\\pgfsetlinewidth{0.01pt}\n");
     }
     gl2psPrintPGFColor(prim->verts[0].rgba);
-    fprintf(gl2ps->stream,
+    fprintf(gl2ps->stream, 
             "\\pgfpathmoveto{\\pgfpoint{%fpt}{%fpt}}\n"
             "\\pgflineto{\\pgfpoint{%fpt}{%fpt}}\n"
             "\\pgflineto{\\pgfpoint{%fpt}{%fpt}}\n"
             "\\pgfpathclose\n"
             "\\pgfusepath{fill,stroke}\n",
             prim->verts[2].xyz[0], prim->verts[2].xyz[1],
             prim->verts[1].xyz[0], prim->verts[1].xyz[1],
             prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
@@ -5442,24 +5400,24 @@ static void gl2psPrintPGFBeginViewport(G
     else{
       glGetIntegerv(GL_INDEX_CLEAR_VALUE, &index);
       rgba[0] = gl2ps->colormap[index][0];
       rgba[1] = gl2ps->colormap[index][1];
       rgba[2] = gl2ps->colormap[index][2];
       rgba[3] = 1.0F;
     }
     gl2psPrintPGFColor(rgba);
-    fprintf(gl2ps->stream,
+    fprintf(gl2ps->stream, 
             "\\pgfpathrectangle{\\pgfpoint{%dpt}{%dpt}}"
             "{\\pgfpoint{%dpt}{%dpt}}\n"
             "\\pgfusepath{fill}\n",
             x, y, w, h);
   }
-
-  fprintf(gl2ps->stream,
+  
+  fprintf(gl2ps->stream, 
           "\\pgfpathrectangle{\\pgfpoint{%dpt}{%dpt}}"
           "{\\pgfpoint{%dpt}{%dpt}}\n"
           "\\pgfusepath{clip}\n",
           x, y, w, h);
 }
 
 static GLint gl2psPrintPGFEndViewport(void)
 {
@@ -5481,17 +5439,17 @@ static GL2PSbackend gl2psPGF = {
   gl2psPrintPGFBeginViewport,
   gl2psPrintPGFEndViewport,
   gl2psPrintPGFPrimitive,
   gl2psPrintPGFFinalPrimitive,
   "tex",
   "PGF Latex Graphics"
 };
 
-/*********************************************************************
+/********************************************************************* 
  *
  * General primitive printing routine
  *
  *********************************************************************/
 
 /* Warning: the ordering of the backends must match the format
    #defines in gl2ps.h */
 
@@ -5516,17 +5474,17 @@ static void gl2psComputeTightBoundingBox
       gl2ps->viewport[0] = (GLint)prim->verts[i].xyz[0];
     if(prim->verts[i].xyz[0] > gl2ps->viewport[2])
       gl2ps->viewport[2] = (GLint)(prim->verts[i].xyz[0] + 0.5F);
     if(prim->verts[i].xyz[1] < gl2ps->viewport[1])
       gl2ps->viewport[1] = (GLint)prim->verts[i].xyz[1];
     if(prim->verts[i].xyz[1] > gl2ps->viewport[3])
       gl2ps->viewport[3] = (GLint)(prim->verts[i].xyz[1] + 0.5F);
   }
-}
+}  
 
 static GLint gl2psPrintPrimitives(void)
 {
   GL2PSbsptree *root;
   GL2PSxyz eye = {0.0F, 0.0F, 100.0F * GL2PS_ZSCALE};
   GLint used;
 
   used = glRenderMode(GL_RENDER);
@@ -5537,17 +5495,17 @@ static GLint gl2psPrintPrimitives(void)
   }
 
   if(used > 0)
     gl2psParseFeedbackBuffer(used);
 
   gl2psRescaleAndOffset();
 
   if(gl2ps->header){
-    if(gl2psListNbr(gl2ps->primitives) &&
+    if(gl2psListNbr(gl2ps->primitives) && 
        (gl2ps->options & GL2PS_TIGHT_BOUNDING_BOX)){
       gl2ps->viewport[0] = gl2ps->viewport[1] = 100000;
       gl2ps->viewport[2] = gl2ps->viewport[3] = -100000;
       gl2psListAction(gl2ps->primitives, gl2psComputeTightBoundingBox);
     }
     (gl2psbackends[gl2ps->format]->printHeader)();
     gl2ps->header = GL_FALSE;
   }
@@ -5579,36 +5537,36 @@ static GLint gl2psPrintPrimitives(void)
     root = (GL2PSbsptree*)gl2psMalloc(sizeof(GL2PSbsptree));
     gl2psBuildBspTree(root, gl2ps->primitives);
     if(GL_TRUE == gl2ps->boundary) gl2psBuildPolygonBoundary(root);
     if(gl2ps->options & GL2PS_OCCLUSION_CULL){
       gl2psTraverseBspTree(root, eye, -GL2PS_EPSILON, gl2psLess,
                            gl2psAddInImageTree, 1);
       gl2psFreeBspImageTree(&gl2ps->imagetree);
     }
-    gl2psTraverseBspTree(root, eye, GL2PS_EPSILON, gl2psGreater,
+    gl2psTraverseBspTree(root, eye, GL2PS_EPSILON, gl2psGreater, 
                          gl2psbackends[gl2ps->format]->printPrimitive, 0);
     gl2psFreeBspTree(&root);
     /* reallocate the primitive list (it's been deleted by
        gl2psBuildBspTree) in case there is another viewport */
     gl2ps->primitives = gl2psListCreate(500, 500, sizeof(GL2PSprimitive*));
     break;
   }
   gl2psbackends[gl2ps->format]->printFinalPrimitive();
 
   return GL2PS_SUCCESS;
 }
 
-/*********************************************************************
+/********************************************************************* 
  *
  * Public routines
  *
  *********************************************************************/
 
-GL2PSDLL_API GLint gl2psBeginPage(const char *title, const char *producer,
+GL2PSDLL_API GLint gl2psBeginPage(const char *title, const char *producer, 
                                   GLint viewport[4], GLint format, GLint sort,
                                   GLint options, GLint colormode,
                                   GLint colorsize, GL2PSrgba *colormap,
                                   GLint nr, GLint ng, GLint nb, GLint buffersize,
                                   FILE *stream, const char *filename)
 {
   GLint index;
   int i;
@@ -5666,17 +5624,17 @@ GL2PSDLL_API GLint gl2psBeginPage(const 
   else{
     for(i = 0; i < 4; i++){
       gl2ps->viewport[i] = viewport[i];
     }
   }
 
   if(!gl2ps->viewport[2] || !gl2ps->viewport[3]){
     gl2psMsg(GL2PS_ERROR, "Incorrect viewport (x=%d, y=%d, width=%d, height=%d)",
-             gl2ps->viewport[0], gl2ps->viewport[1],
+             gl2ps->viewport[0], gl2ps->viewport[1], 
              gl2ps->viewport[2], gl2ps->viewport[3]);
     gl2psFree(gl2ps);
     gl2ps = NULL;
     return GL2PS_ERROR;
   }
 
   gl2ps->threshold[0] = nr ? 1.0F / (GLfloat)nr : 0.064F;
   gl2ps->threshold[1] = ng ? 1.0F / (GLfloat)ng : 0.034F;
@@ -5690,21 +5648,21 @@ GL2PSDLL_API GLint gl2psBeginPage(const 
     gl2ps->lastvertex.rgba[i] = -1.0F;
     gl2ps->lastrgba[i] = -1.0F;
   }
   gl2ps->lastlinewidth = -1.0F;
   gl2ps->lastpattern = 0;
   gl2ps->lastfactor = 0;
   gl2ps->imagetree = NULL;
   gl2ps->primitivetoadd = NULL;
-  gl2ps->zerosurfacearea = GL_FALSE;
+  gl2ps->zerosurfacearea = GL_FALSE;  
   gl2ps->pdfprimlist = NULL;
   gl2ps->pdfgrouplist = NULL;
   gl2ps->xreflist = NULL;
-
+  
   /* get default blending mode from current OpenGL state (enabled by
      default for SVG) */
   gl2ps->blending = (gl2ps->format == GL2PS_SVG) ? GL_TRUE : glIsEnabled(GL_BLEND);
   glGetIntegerv(GL_BLEND_SRC, &gl2ps->blendfunc[0]);
   glGetIntegerv(GL_BLEND_DST, &gl2ps->blendfunc[1]);
 
   if(gl2ps->colormode == GL_RGBA){
     gl2ps->colorsize = 0;
@@ -5737,55 +5695,55 @@ GL2PSDLL_API GLint gl2psBeginPage(const 
   if(!title){
     gl2ps->title = (char*)gl2psMalloc(sizeof(char));
     gl2ps->title[0] = '\0';
   }
   else{
     gl2ps->title = (char*)gl2psMalloc((strlen(title)+1)*sizeof(char));
     strcpy(gl2ps->title, title);
   }
-
+    
   if(!producer){
     gl2ps->producer = (char*)gl2psMalloc(sizeof(char));
     gl2ps->producer[0] = '\0';
   }
   else{
     gl2ps->producer = (char*)gl2psMalloc((strlen(producer)+1)*sizeof(char));
     strcpy(gl2ps->producer, producer);
   }
-
+  
   if(!filename){
     gl2ps->filename = (char*)gl2psMalloc(sizeof(char));
     gl2ps->filename[0] = '\0';
   }
   else{
     gl2ps->filename = (char*)gl2psMalloc((strlen(filename)+1)*sizeof(char));
     strcpy(gl2ps->filename, filename);
   }
 
   gl2ps->primitives = gl2psListCreate(500, 500, sizeof(GL2PSprimitive*));
   gl2ps->auxprimitives = gl2psListCreate(100, 100, sizeof(GL2PSprimitive*));
   gl2ps->feedback = (GLfloat*)gl2psMalloc(gl2ps->buffersize * sizeof(GLfloat));
   glFeedbackBuffer(gl2ps->buffersize, GL_3D_COLOR, gl2ps->feedback);
-  glRenderMode(GL_FEEDBACK);
+  glRenderMode(GL_FEEDBACK);  
 
   return GL2PS_SUCCESS;
 }
 
 GL2PSDLL_API GLint gl2psEndPage(void)
 {
   GLint res;
 
   if(!gl2ps) return GL2PS_UNINITIALIZED;
 
   res = gl2psPrintPrimitives();
 
   if(res != GL2PS_OVERFLOW)
     (gl2psbackends[gl2ps->format]->printFooter)();
-
+  
   fflush(gl2ps->stream);
 
   gl2psListDelete(gl2ps->primitives);
   gl2psListDelete(gl2ps->auxprimitives);
   gl2psFreeImagemap(gl2ps->imagemap_head);
   gl2psFree(gl2ps->colormap);
   gl2psFree(gl2ps->title);
   gl2psFree(gl2ps->producer);
@@ -5797,17 +5755,17 @@ GL2PSDLL_API GLint gl2psEndPage(void)
   return res;
 }
 
 GL2PSDLL_API GLint gl2psBeginViewport(GLint viewport[4])
 {
   if(!gl2ps) return GL2PS_UNINITIALIZED;
 
   (gl2psbackends[gl2ps->format]->beginViewport)(viewport);
-
+  
   return GL2PS_SUCCESS;
 }
 
 GL2PSDLL_API GLint gl2psEndViewport(void)
 {
   GLint res;
 
   if(!gl2ps) return GL2PS_UNINITIALIZED;
@@ -5815,17 +5773,17 @@ GL2PSDLL_API GLint gl2psEndViewport(void
   res = (gl2psbackends[gl2ps->format]->endViewport)();
 
   /* reset last used colors, line widths */
   gl2ps->lastlinewidth = -1.0F;
 
   return res;
 }
 
-GL2PSDLL_API GLint gl2psTextOpt(const char *str, const char *fontname,
+GL2PSDLL_API GLint gl2psTextOpt(const char *str, const char *fontname, 
                                 GLshort fontsize, GLint alignment, GLfloat angle)
 {
   return gl2psAddText(GL2PS_TEXT, str, fontname, fontsize, alignment, angle);
 }
 
 GL2PSDLL_API GLint gl2psText(const char *str, const char *fontname, GLshort fontsize)
 {
   return gl2psAddText(GL2PS_TEXT, str, fontname, fontsize, GL2PS_TEXT_BL, 0.0F);
@@ -5833,21 +5791,21 @@ GL2PSDLL_API GLint gl2psText(const char 
 
 GL2PSDLL_API GLint gl2psSpecial(GLint format, const char *str)
 {
   return gl2psAddText(GL2PS_SPECIAL, str, "", 0, format, 0.0F);
 }
 
 GL2PSDLL_API GLint gl2psDrawPixels(GLsizei width, GLsizei height,
                                    GLint xorig, GLint yorig,
-                                   GLenum format, GLenum type,
+                                   GLenum format, GLenum type, 
                                    const void *pixels)
 {
   int size, i;
-  GLfloat pos[4], *piv, zoom_x, zoom_y;
+  GLfloat pos[4], *piv;
   GL2PSprimitive *prim;
   GLboolean valid;
 
   if(!gl2ps || !pixels) return GL2PS_UNINITIALIZED;
 
   if((width <= 0) || (height <= 0)) return GL2PS_ERROR;
 
   if(gl2ps->options & GL2PS_NO_PIXMAP) return GL2PS_SUCCESS;
@@ -5857,18 +5815,16 @@ GL2PSDLL_API GLint gl2psDrawPixels(GLsiz
              "GL_RGB/GL_RGBA, GL_FLOAT pixels");
     return GL2PS_ERROR;
   }
 
   glGetBooleanv(GL_CURRENT_RASTER_POSITION_VALID, &valid);
   if(GL_FALSE == valid) return GL2PS_SUCCESS; /* the primitive is culled */
 
   glGetFloatv(GL_CURRENT_RASTER_POSITION, pos);
-  glGetFloatv(GL_ZOOM_X, &zoom_x);
-  glGetFloatv(GL_ZOOM_Y, &zoom_y);
 
   prim = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
   prim->type = GL2PS_PIXMAP;
   prim->boundary = 0;
   prim->numverts = 1;
   prim->verts = (GL2PSvertex*)gl2psMalloc(sizeof(GL2PSvertex));
   prim->verts[0].xyz[0] = pos[0] + xorig;
   prim->verts[0].xyz[1] = pos[1] + yorig;
@@ -5877,34 +5833,32 @@ GL2PSDLL_API GLint gl2psDrawPixels(GLsiz
   prim->offset = 0;
   prim->pattern = 0;
   prim->factor = 0;
   prim->width = 1;
   glGetFloatv(GL_CURRENT_RASTER_COLOR, prim->verts[0].rgba);
   prim->data.image = (GL2PSimage*)gl2psMalloc(sizeof(GL2PSimage));
   prim->data.image->width = width;
   prim->data.image->height = height;
-  prim->data.image->zoom_x = zoom_x;
-  prim->data.image->zoom_y = zoom_y;
   prim->data.image->format = format;
   prim->data.image->type = type;
 
   switch(format){
   case GL_RGBA:
     if(gl2ps->options & GL2PS_NO_BLENDING || !gl2ps->blending){
       /* special case: blending turned off */
       prim->data.image->format = GL_RGB;
       size = height * width * 3;
       prim->data.image->pixels = (GLfloat*)gl2psMalloc(size * sizeof(GLfloat));
       piv = (GLfloat*)pixels;
       for(i = 0; i < size; ++i, ++piv){
         prim->data.image->pixels[i] = *piv;
-        if(!((i + 1) % 3))
+        if(!((i+1)%3))
           ++piv;
-      }
+      }   
     }
     else{
       size = height * width * 4;
       prim->data.image->pixels = (GLfloat*)gl2psMalloc(size * sizeof(GLfloat));
       memcpy(prim->data.image->pixels, pixels, size * sizeof(GLfloat));
     }
     break;
   case GL_RGB:
@@ -5921,21 +5875,21 @@ GL2PSDLL_API GLint gl2psDrawPixels(GLsiz
   return GL2PS_SUCCESS;
 }
 
 GL2PSDLL_API GLint gl2psDrawImageMap(GLsizei width, GLsizei height,
                                      const GLfloat position[3],
                                      const unsigned char *imagemap){
   int size, i;
   int sizeoffloat = sizeof(GLfloat);
-
+  
   if(!gl2ps || !imagemap) return GL2PS_UNINITIALIZED;
 
   if((width <= 0) || (height <= 0)) return GL2PS_ERROR;
-
+  
   size = height + height * ((width - 1) / 8);
   glPassThrough(GL2PS_IMAGEMAP_TOKEN);
   glBegin(GL_POINTS);
   glVertex3f(position[0], position[1],position[2]);
   glEnd();
   glPassThrough((GLfloat)width);
   glPassThrough((GLfloat)height);
   for(i = 0; i < size; i += sizeoffloat){
@@ -6005,17 +5959,17 @@ GL2PSDLL_API GLint gl2psDisable(GLint mo
 }
 
 GL2PSDLL_API GLint gl2psPointSize(GLfloat value)
 {
   if(!gl2ps) return GL2PS_UNINITIALIZED;
 
   glPassThrough(GL2PS_POINT_SIZE_TOKEN);
   glPassThrough(value);
-
+  
   return GL2PS_SUCCESS;
 }
 
 GL2PSDLL_API GLint gl2psLineWidth(GLfloat value)
 {
   if(!gl2ps) return GL2PS_UNINITIALIZED;
 
   glPassThrough(GL2PS_LINE_WIDTH_TOKEN);
diff --git a/src/gl2ps.h b/src/gl2ps.h
--- a/src/gl2ps.h
+++ b/src/gl2ps.h
@@ -134,19 +134,19 @@
 /* Arguments for gl2psEnable/gl2psDisable */
 
 #define GL2PS_POLYGON_OFFSET_FILL 1
 #define GL2PS_POLYGON_BOUNDARY    2
 #define GL2PS_LINE_STIPPLE        3
 #define GL2PS_BLEND               4
 
 /* Text alignment (o=raster position; default mode is BL):
-   +---+ +---+ +---+ +---+ +---+ +---+ +-o-+ o---+ +---o
-   | o | o   | |   o |   | |   | |   | |   | |   | |   |
-   +---+ +---+ +---+ +-o-+ o---+ +---o +---+ +---+ +---+
+   +---+ +---+ +---+ +---+ +---+ +---+ +-o-+ o---+ +---o 
+   | o | o   | |   o |   | |   | |   | |   | |   | |   | 
+   +---+ +---+ +---+ +-o-+ o---+ +---o +---+ +---+ +---+ 
     C     CL    CR    B     BL    BR    T     TL    TR */
 
 #define GL2PS_TEXT_C  1
 #define GL2PS_TEXT_CL 2
 #define GL2PS_TEXT_CR 3
 #define GL2PS_TEXT_B  4
 #define GL2PS_TEXT_BL 5
 #define GL2PS_TEXT_BR 6
@@ -155,30 +155,30 @@
 #define GL2PS_TEXT_TR 9
 
 typedef GLfloat GL2PSrgba[4];
 
 #if defined(__cplusplus)
 extern "C" {
 #endif
 
-GL2PSDLL_API GLint gl2psBeginPage(const char *title, const char *producer,
+GL2PSDLL_API GLint gl2psBeginPage(const char *title, const char *producer, 
                                   GLint viewport[4], GLint format, GLint sort,
                                   GLint options, GLint colormode,
-                                  GLint colorsize, GL2PSrgba *colormap,
+                                  GLint colorsize, GL2PSrgba *colormap, 
                                   GLint nr, GLint ng, GLint nb, GLint buffersize,
                                   FILE *stream, const char *filename);
 GL2PSDLL_API GLint gl2psEndPage(void);
 GL2PSDLL_API GLint gl2psSetOptions(GLint options);
 GL2PSDLL_API GLint gl2psGetOptions(GLint *options);
 GL2PSDLL_API GLint gl2psBeginViewport(GLint viewport[4]);
 GL2PSDLL_API GLint gl2psEndViewport(void);
-GL2PSDLL_API GLint gl2psText(const char *str, const char *fontname,
+GL2PSDLL_API GLint gl2psText(const char *str, const char *fontname, 
                              GLshort fontsize);
-GL2PSDLL_API GLint gl2psTextOpt(const char *str, const char *fontname,
+GL2PSDLL_API GLint gl2psTextOpt(const char *str, const char *fontname, 
                                 GLshort fontsize, GLint align, GLfloat angle);
 GL2PSDLL_API GLint gl2psSpecial(GLint format, const char *str);
 GL2PSDLL_API GLint gl2psDrawPixels(GLsizei width, GLsizei height,
                                    GLint xorig, GLint yorig,
                                    GLenum format, GLenum type, const void *pixels);
 GL2PSDLL_API GLint gl2psEnable(GLint mode);
 GL2PSDLL_API GLint gl2psDisable(GLint mode);
 GL2PSDLL_API GLint gl2psPointSize(GLfloat value);
