# HG changeset patch
# User jwe
# Date 1138731780 0
#      Tue Jan 31 18:23:00 2006 +0000
# Node ID 2857357f9d3cd31223f10ba9559de72839fd7fa9
# Parent  2c66c36d2698676ee17d0d09fa75f748f095c36c
[project @ 2006-01-31 18:22:59 by jwe]

diff --git a/liboctave/CSparse.cc b/liboctave/CSparse.cc
--- a/liboctave/CSparse.cc
+++ b/liboctave/CSparse.cc
@@ -100,56 +100,56 @@ extern "C"
 			   Complex*, const octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (zgtsv, ZGTSV) (const octave_idx_type&, const octave_idx_type&, Complex*, Complex*,
 			   Complex*, Complex*, const octave_idx_type&, octave_idx_type&);
 }
 
 SparseComplexMatrix::SparseComplexMatrix (const SparseMatrix& a)
-  : MSparse<Complex> (a.rows (), a.cols (), a.nnz ())
+  : MSparse<Complex> (a.rows (), a.cols (), a.nzmax ())
 {
   octave_idx_type nc = cols ();
-  octave_idx_type nz = nnz ();
+  octave_idx_type nz = nzmax ();
 
   for (octave_idx_type i = 0; i < nc + 1; i++)
     cidx (i) = a.cidx (i);
 
   for (octave_idx_type i = 0; i < nz; i++)
     {
       data (i) = a.data (i);
       ridx (i) = a.ridx (i);
     }
 }
 
 SparseComplexMatrix::SparseComplexMatrix (const SparseBoolMatrix& a)
-  : MSparse<Complex> (a.rows (), a.cols (), a.nnz ())
+  : MSparse<Complex> (a.rows (), a.cols (), a.nzmax ())
 {
   octave_idx_type nc = cols ();
-  octave_idx_type nz = nnz ();
+  octave_idx_type nz = nzmax ();
 
   for (octave_idx_type i = 0; i < nc + 1; i++)
     cidx (i) = a.cidx (i);
 
   for (octave_idx_type i = 0; i < nz; i++)
     {
       data (i) = a.data (i);
       ridx (i) = a.ridx (i);
     }
 }
 
 bool
 SparseComplexMatrix::operator == (const SparseComplexMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-  octave_idx_type nz = nnz ();
+  octave_idx_type nz = nzmax ();
   octave_idx_type nr_a = a.rows ();
   octave_idx_type nc_a = a.cols ();
-  octave_idx_type nz_a = a.nnz ();
+  octave_idx_type nz_a = a.nzmax ();
 
   if (nr != nr_a || nc != nc_a || nz != nz_a)
     return false;
 
   for (octave_idx_type i = 0; i < nc + 1; i++)
     if (cidx(i) != a.cidx(i))
 	return false;
 
@@ -540,17 +540,17 @@ SparseComplexMatrix::matrix_value (void)
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::hermitian (void) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-  octave_idx_type nz = nnz ();
+  octave_idx_type nz = nzmax ();
   SparseComplexMatrix retval (nc, nr, nz);
 
   retval.cidx(0) = 0;
   for (octave_idx_type i = 0, iidx = 0; i < nr; i++)
     {
       for (octave_idx_type j = 0; j < nc; j++)
 	for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
 	  if (ridx(k) == i)
@@ -564,17 +564,17 @@ SparseComplexMatrix::hermitian (void) co
   return retval;
 }
 
 SparseComplexMatrix
 conj (const SparseComplexMatrix& a)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
-  octave_idx_type nz = a.nnz ();
+  octave_idx_type nz = a.nzmax ();
   SparseComplexMatrix retval (nc, nr, nz);
 
   for (octave_idx_type i = 0; i < nc + 1; i++)
     retval.cidx (i) = a.cidx (i);
 
   for (octave_idx_type i = 0; i < nz; i++)
     {
       retval.data (i) = conj (a.data (i));
@@ -697,17 +697,17 @@ SparseComplexMatrix::tinverse (SparseTyp
 		    atmp += std::abs(data(i));
 		  if (atmp > anorm)
 		    anorm = atmp;
 		}
 	    }
 
 	  if (typ == SparseType::Upper || typ == SparseType::Lower)
 	    {
-	      octave_idx_type nz = nnz();
+	      octave_idx_type nz = nzmax ();
 	      octave_idx_type cx = 0;
 	      octave_idx_type nz2 = nz;
 	      retval = SparseComplexMatrix (nr, nc, nz2);
 
 	      for (octave_idx_type i = 0; i < nr; i++)
 		{
 		  OCTAVE_QUIT;
 		  // place the 1 in the identity position
@@ -782,17 +782,17 @@ SparseComplexMatrix::tinverse (SparseTyp
 		    for (octave_idx_type j = cx_colstart; j < cx; j++)
 		      retval.xdata(j) /= pivot;
 		}
 	      retval.xcidx(nr) = cx;
 	      retval.maybe_compress ();
 	    }
 	  else
 	    {
-	      octave_idx_type nz = nnz();
+	      octave_idx_type nz = nzmax ();
 	      octave_idx_type cx = 0;
 	      octave_idx_type nz2 = nz;
 	      retval = SparseComplexMatrix (nr, nc, nz2);
 
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
 	      OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nr);
 
 	      octave_idx_type *perm = mattyp.triangular_perm();
@@ -1174,17 +1174,17 @@ SparseComplexMatrix::dsolve (SparseType 
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Diagonal ||
 	  typ == SparseType::Permuted_Diagonal)
 	{
 	  octave_idx_type b_nr = b.rows ();
 	  octave_idx_type b_nc = b.cols ();
-	  octave_idx_type b_nz = b.nnz ();
+	  octave_idx_type b_nz = b.nzmax ();
 	  retval = SparseComplexMatrix (b_nr, b_nc, b_nz);
 
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  if (typ == SparseType::Diagonal)
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      {
 		for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
@@ -1304,17 +1304,17 @@ SparseComplexMatrix::dsolve (SparseType 
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Diagonal ||
 	  typ == SparseType::Permuted_Diagonal)
 	{
 	  octave_idx_type b_nr = b.rows ();
 	  octave_idx_type b_nc = b.cols ();
-	  octave_idx_type b_nz = b.nnz ();
+	  octave_idx_type b_nz = b.nzmax ();
 	  retval = SparseComplexMatrix (b_nr, b_nc, b_nz);
 
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  if (typ == SparseType::Diagonal)
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      {
 		for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
@@ -1606,17 +1606,17 @@ SparseComplexMatrix::utsolve (SparseType
 	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += std::abs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
 	  octave_idx_type b_nr = b.rows ();
 	  octave_idx_type b_nc = b.cols ();
-	  octave_idx_type b_nz = b.nnz ();
+	  octave_idx_type b_nz = b.nzmax ();
 	  retval = SparseComplexMatrix (b_nr, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Upper)
 	    {
 	      octave_idx_type *perm = mattype.triangular_perm ();
@@ -2080,17 +2080,17 @@ SparseComplexMatrix::utsolve (SparseType
 	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += std::abs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
 	  octave_idx_type b_nr = b.rows ();
 	  octave_idx_type b_nc = b.cols ();
-	  octave_idx_type b_nz = b.nnz ();
+	  octave_idx_type b_nz = b.nzmax ();
 	  retval = SparseComplexMatrix (b_nr, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Upper)
 	    {
 	      octave_idx_type *perm = mattype.triangular_perm ();
@@ -2576,17 +2576,17 @@ SparseComplexMatrix::ltsolve (SparseType
 	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += std::abs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
 	  octave_idx_type b_nr = b.rows ();
 	  octave_idx_type b_nc = b.cols ();
-	  octave_idx_type b_nz = b.nnz ();
+	  octave_idx_type b_nz = b.nzmax ();
 	  retval = SparseComplexMatrix (b_nr, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Lower)
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
@@ -3093,17 +3093,17 @@ SparseComplexMatrix::ltsolve (SparseType
 	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += std::abs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
 	  octave_idx_type b_nr = b.rows ();
 	  octave_idx_type b_nc = b.cols ();
-	  octave_idx_type b_nz = b.nnz ();
+	  octave_idx_type b_nz = b.nzmax ();
 	  retval = SparseComplexMatrix (b_nr, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Lower)
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
@@ -3575,17 +3575,17 @@ SparseComplexMatrix::trisolve (SparseTyp
 		  else
 		    (*current_liboctave_error_handler)
 		      ("matrix singular to machine precision");
 
 		} 
 	      else 
 		{
 		  char job = 'N';
-		  volatile octave_idx_type x_nz = b.nnz ();
+		  volatile octave_idx_type x_nz = b.nzmax ();
 		  octave_idx_type b_nc = b.cols ();
 		  retval = SparseComplexMatrix (nr, b_nc, x_nz);
 		  retval.xcidx(0) = 0;
 		  volatile octave_idx_type ii = 0;
 
 		  OCTAVE_LOCAL_BUFFER (Complex, work, nr);
 
 		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
@@ -3886,17 +3886,17 @@ SparseComplexMatrix::trisolve (SparseTyp
 		  rcond = 1.;
 		  char job = 'N';
 		  octave_idx_type b_nr = b.rows ();
 		  octave_idx_type b_nc = b.cols ();
 		  OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
 
 		  // Take a first guess that the number of non-zero terms
 		  // will be as many as in b
-		  volatile octave_idx_type x_nz = b.nnz ();
+		  volatile octave_idx_type x_nz = b.nzmax ();
 		  volatile octave_idx_type ii = 0;
 		  retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
 		  retval.xcidx(0) = 0;
 		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
 		    {
 
 		      for (octave_idx_type i = 0; i < b_nr; i++)
@@ -4274,17 +4274,17 @@ SparseComplexMatrix::bsolve (SparseType 
 		{
 		  rcond = 1.;
 		  octave_idx_type b_nr = b.rows ();
 		  octave_idx_type b_nc = b.cols ();
 		  OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
 
 		  // Take a first guess that the number of non-zero terms
 		  // will be as many as in b
-		  volatile octave_idx_type x_nz = b.nnz ();
+		  volatile octave_idx_type x_nz = b.nzmax ();
 		  volatile octave_idx_type ii = 0;
 		  retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
 		  retval.xcidx(0) = 0;
 		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
 		    {
 		      for (octave_idx_type i = 0; i < b_nr; i++)
 			Bx[i] = b.elem (i, j);
@@ -4380,17 +4380,17 @@ SparseComplexMatrix::bsolve (SparseType 
 		  else
 		    (*current_liboctave_error_handler)
 		      ("matrix singular to machine precision");
 
 		} 
 	      else 
 		{
 		  char job = 'N';
-		  volatile octave_idx_type x_nz = b.nnz ();
+		  volatile octave_idx_type x_nz = b.nzmax ();
 		  octave_idx_type b_nc = b.cols ();
 		  retval = SparseComplexMatrix (nr, b_nc, x_nz);
 		  retval.xcidx(0) = 0;
 		  volatile octave_idx_type ii = 0;
 
 		  OCTAVE_LOCAL_BUFFER (Complex, work, nr);
 
 		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
@@ -4686,17 +4686,17 @@ SparseComplexMatrix::bsolve (SparseType 
 		{
 		  rcond = 1.;
 		  octave_idx_type b_nr = b.rows ();
 		  octave_idx_type b_nc = b.cols ();
 		  OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
 
 		  // Take a first guess that the number of non-zero terms
 		  // will be as many as in b
-		  volatile octave_idx_type x_nz = b.nnz ();
+		  volatile octave_idx_type x_nz = b.nzmax ();
 		  volatile octave_idx_type ii = 0;
 		  retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
 		  retval.xcidx(0) = 0;
 		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
 		    {
 
 		      for (octave_idx_type i = 0; i < b_nr; i++)
@@ -4799,17 +4799,17 @@ SparseComplexMatrix::bsolve (SparseType 
 		  else
 		    (*current_liboctave_error_handler)
 		      ("matrix singular to machine precision");
 
 		}
 	      else 
 		{
 		  char job = 'N';
-		  volatile octave_idx_type x_nz = b.nnz ();
+		  volatile octave_idx_type x_nz = b.nzmax ();
 		  octave_idx_type b_nc = b.cols ();
 		  retval = SparseComplexMatrix (nr, b_nc, x_nz);
 		  retval.xcidx(0) = 0;
 		  volatile octave_idx_type ii = 0;
 
 		  OCTAVE_LOCAL_BUFFER (Complex, Bx, nr);
 
 		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
@@ -5052,17 +5052,17 @@ SparseComplexMatrix::fsolve (SparseType 
 	  cholmod_sparse Astore;
 	  cholmod_sparse *A = &Astore;
 	  double dummy;
 	  A->nrow = nr;
 	  A->ncol = nc;
 
 	  A->p = cidx();
 	  A->i = ridx();
-	  A->nzmax = nonzero();
+	  A->nzmax = nnz();
 	  A->packed = true;
 	  A->sorted = true;
 	  A->nz = NULL;
 #ifdef IDX_TYPE_LONG
 	  A->itype = CHOLMOD_LONG;
 #else
 	  A->itype = CHOLMOD_INT;
 #endif
@@ -5321,17 +5321,17 @@ SparseComplexMatrix::fsolve (SparseType 
 	  cholmod_sparse Astore;
 	  cholmod_sparse *A = &Astore;
 	  double dummy;
 	  A->nrow = nr;
 	  A->ncol = nc;
 
 	  A->p = cidx();
 	  A->i = ridx();
-	  A->nzmax = nonzero();
+	  A->nzmax = nnz();
 	  A->packed = true;
 	  A->sorted = true;
 	  A->nz = NULL;
 #ifdef IDX_TYPE_LONG
 	  A->itype = CHOLMOD_LONG;
 #else
 	  A->itype = CHOLMOD_INT;
 #endif
@@ -5345,17 +5345,17 @@ SparseComplexMatrix::fsolve (SparseType 
 	    A->x = data();
 
 	  cholmod_sparse Bstore;
 	  cholmod_sparse *B = &Bstore;
 	  B->nrow = b.rows();
 	  B->ncol = b.cols();
 	  B->p = b.cidx();
 	  B->i = b.ridx();
-	  B->nzmax = b.nonzero();
+	  B->nzmax = b.nnz();
 	  B->packed = true;
 	  B->sorted = true;
 	  B->nz = NULL;
 #ifdef IDX_TYPE_LONG
 	  B->itype = CHOLMOD_LONG;
 #else
 	  B->itype = CHOLMOD_INT;
 #endif
@@ -5459,17 +5459,17 @@ SparseComplexMatrix::fsolve (SparseType 
 	      for (octave_idx_type i = 0; i < b_nr; i++)
 		Bz[i] = 0.;
 #else
 	      OCTAVE_LOCAL_BUFFER (Complex, Bz, b_nr);
 #endif
 
 	      // Take a first guess that the number of non-zero terms
 	      // will be as many as in b
-	      octave_idx_type x_nz = b.nnz ();
+	      octave_idx_type x_nz = b.nzmax ();
 	      octave_idx_type ii = 0;
 	      retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
 	      OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
 	      
 	      retval.xcidx(0) = 0;
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
@@ -5635,17 +5635,17 @@ SparseComplexMatrix::fsolve (SparseType 
 	  cholmod_sparse Astore;
 	  cholmod_sparse *A = &Astore;
 	  double dummy;
 	  A->nrow = nr;
 	  A->ncol = nc;
 
 	  A->p = cidx();
 	  A->i = ridx();
-	  A->nzmax = nonzero();
+	  A->nzmax = nnz();
 	  A->packed = true;
 	  A->sorted = true;
 	  A->nz = NULL;
 #ifdef IDX_TYPE_LONG
 	  A->itype = CHOLMOD_LONG;
 #else
 	  A->itype = CHOLMOD_INT;
 #endif
@@ -5882,17 +5882,17 @@ SparseComplexMatrix::fsolve (SparseType 
 	  cholmod_sparse Astore;
 	  cholmod_sparse *A = &Astore;
 	  double dummy;
 	  A->nrow = nr;
 	  A->ncol = nc;
 
 	  A->p = cidx();
 	  A->i = ridx();
-	  A->nzmax = nonzero();
+	  A->nzmax = nnz();
 	  A->packed = true;
 	  A->sorted = true;
 	  A->nz = NULL;
 #ifdef IDX_TYPE_LONG
 	  A->itype = CHOLMOD_LONG;
 #else
 	  A->itype = CHOLMOD_INT;
 #endif
@@ -5906,17 +5906,17 @@ SparseComplexMatrix::fsolve (SparseType 
 	    A->x = data();
 
 	  cholmod_sparse Bstore;
 	  cholmod_sparse *B = &Bstore;
 	  B->nrow = b.rows();
 	  B->ncol = b.cols();
 	  B->p = b.cidx();
 	  B->i = b.ridx();
-	  B->nzmax = b.nonzero();
+	  B->nzmax = b.nnz();
 	  B->packed = true;
 	  B->sorted = true;
 	  B->nz = NULL;
 #ifdef IDX_TYPE_LONG
 	  B->itype = CHOLMOD_LONG;
 #else
 	  B->itype = CHOLMOD_INT;
 #endif
@@ -6013,17 +6013,17 @@ SparseComplexMatrix::fsolve (SparseType 
 	      const octave_idx_type *Ap = cidx ();
 	      const octave_idx_type *Ai = ridx ();
 	      const Complex *Ax = data ();
 
 	      OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
 
 	      // Take a first guess that the number of non-zero terms
 	      // will be as many as in b
-	      octave_idx_type x_nz = b.nnz ();
+	      octave_idx_type x_nz = b.nzmax ();
 	      octave_idx_type ii = 0;
 	      retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
 	      OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
 	      
 	      retval.xcidx(0) = 0;
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
@@ -6713,17 +6713,17 @@ SparseComplexMatrix::lssolve (const Comp
 }
 
 // unary operations
 SparseBoolMatrix
 SparseComplexMatrix::operator ! (void) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-  octave_idx_type nz1 = nnz ();
+  octave_idx_type nz1 = nzmax ();
   octave_idx_type nz2 = nr*nc - nz1;
    
   SparseBoolMatrix r (nr, nc, nz2);
    
   octave_idx_type ii = 0;
   octave_idx_type jj = 0;
   r.cidx (0) = 0;
   for (octave_idx_type i = 0; i < nc; i++)
@@ -6787,17 +6787,17 @@ SparseComplexMatrix::ipermute (const Arr
 
 // other operations
 
 SparseComplexMatrix
 SparseComplexMatrix::map (c_c_Mapper f) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-  octave_idx_type nz = nnz ();
+  octave_idx_type nz = nzmax ();
   bool f_zero = (f(0.0) == 0.0);
 
   // Count number of non-zero elements
   octave_idx_type nel = (f_zero ? 0 : nr*nc - nz);
   for (octave_idx_type i = 0; i < nz; i++)
     if (f (data(i)) != 0.0)
       nel++;
 
@@ -6837,17 +6837,17 @@ SparseComplexMatrix::map (c_c_Mapper f) 
   return retval;
 }
 
 SparseMatrix
 SparseComplexMatrix::map (d_c_Mapper f) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-  octave_idx_type nz = nnz ();
+  octave_idx_type nz = nzmax ();
   bool f_zero = (f(0.0) == 0.0);
 
   // Count number of non-zero elements
   octave_idx_type nel = (f_zero ? 0 : nr*nc - nz);
   for (octave_idx_type i = 0; i < nz; i++)
     if (f (data(i)) != 0.0)
       nel++;
 
@@ -6887,17 +6887,17 @@ SparseComplexMatrix::map (d_c_Mapper f) 
   return retval;
 }
 
 SparseBoolMatrix
 SparseComplexMatrix::map (b_c_Mapper f) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-  octave_idx_type nz = nnz ();
+  octave_idx_type nz = nzmax ();
   bool f_zero = f(0.0);
 
   // Count number of non-zero elements
   octave_idx_type nel = (f_zero ? 0 : nr*nc - nz);
   for (octave_idx_type i = 0; i < nz; i++)
     if (f (data(i)) != 0.0)
       nel++;
 
@@ -6942,34 +6942,34 @@ SparseComplexMatrix::apply (c_c_Mapper f
 {
   *this = map (f);
   return *this;
 }
 
 bool
 SparseComplexMatrix::any_element_is_inf_or_nan (void) const
 {
-  octave_idx_type nel = nnz ();
+  octave_idx_type nel = nzmax ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       Complex val = data (i);
       if (xisinf (val) || xisnan (val))
 	return true;
     }
 
   return false;
 }
 
 // Return true if no elements have imaginary components.
 
 bool
 SparseComplexMatrix::all_elements_are_real (void) const
 {
-  octave_idx_type nel = nnz ();
+  octave_idx_type nel = nzmax ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double ip = std::imag (data (i));
       
       if (ip != 0.0 || lo_ieee_signbit (ip))
 	return false;
     }
@@ -6979,17 +6979,17 @@ SparseComplexMatrix::all_elements_are_re
 
 // Return nonzero if any element of CM has a non-integer real or
 // imaginary part.  Also extract the largest and smallest (real or
 // imaginary) values and return them in MAX_VAL and MIN_VAL. 
 
 bool
 SparseComplexMatrix::all_integers (double& max_val, double& min_val) const
 {
-  octave_idx_type nel = nnz ();
+  octave_idx_type nel = nzmax ();
 
   if (nel == 0)
     return false;
 
   max_val = std::real(data (0));
   min_val = std::real(data (0));
 
   for (octave_idx_type i = 0; i < nel; i++)
@@ -7016,17 +7016,17 @@ SparseComplexMatrix::all_integers (doubl
     }
 
   return true;
 }
 
 bool
 SparseComplexMatrix::too_large_for_float (void) const
 {
-  octave_idx_type nel = nnz ();
+  octave_idx_type nel = nzmax ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
 	Complex val = data (i);
 
 	double r_val = std::real (val);
 	double i_val = std::imag (val);
 
@@ -7094,17 +7094,17 @@ SparseComplexMatrix::sumsq (int dim) con
 			    COL_EXPR, 0.0, 0.0);
 
 #undef ROW_EXPR
 #undef COL_EXPR
 }
 
 SparseMatrix SparseComplexMatrix::abs (void) const
 {
-  octave_idx_type nz = nnz ();
+  octave_idx_type nz = nzmax ();
   octave_idx_type nc = cols ();
 
   SparseMatrix retval (rows(), nc, nz);
 
   for (octave_idx_type i = 0; i < nc + 1; i++)
     retval.cidx (i) = cidx (i);
 
   for (octave_idx_type i = 0; i < nz; i++)
@@ -7222,17 +7222,17 @@ operator << (std::ostream& os, const Spa
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, SparseComplexMatrix& a)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
-  octave_idx_type nz = a.nnz ();
+  octave_idx_type nz = a.nzmax ();
 
   if (nr < 1 || nc < 1)
     is.clear (std::ios::badbit);
   else
     {
       octave_idx_type itmp, jtmp, jold = 0;
       Complex tmp;
       octave_idx_type ii = 0;
@@ -7389,24 +7389,24 @@ min (const SparseComplexMatrix& a, const
   if ((a.rows() == b.rows()) && (a.cols() == b.cols())) 
     {
       octave_idx_type a_nr = a.rows ();
       octave_idx_type a_nc = a.cols ();
 
       octave_idx_type b_nr = b.rows ();
       octave_idx_type b_nc = b.cols ();
 
-      if (a_nr == 0 || b_nc == 0 || a.nnz () == 0 || b.nnz () == 0)
+      if (a_nr == 0 || b_nc == 0 || a.nzmax () == 0 || b.nzmax () == 0)
 	return SparseComplexMatrix (a_nr, a_nc);
 
       if (a_nr != b_nr || a_nc != b_nc)
 	gripe_nonconformant ("min", a_nr, a_nc, b_nr, b_nc);
       else
 	{
-	  r = SparseComplexMatrix (a_nr, a_nc, (a.nnz () + b.nnz ()));
+	  r = SparseComplexMatrix (a_nr, a_nc, (a.nzmax () + b.nzmax ()));
        
 	  octave_idx_type jx = 0;
 	  r.cidx (0) = 0;
 	  for (octave_idx_type i = 0 ; i < a_nc ; i++)
 	    {
 	      octave_idx_type  ja = a.cidx(i);
 	      octave_idx_type  ja_max = a.cidx(i+1);
 	      bool ja_lt_max= ja < ja_max;
@@ -7511,26 +7511,26 @@ max (const SparseComplexMatrix& a, const
       octave_idx_type a_nr = a.rows ();
       octave_idx_type a_nc = a.cols ();
 
       octave_idx_type b_nr = b.rows ();
       octave_idx_type b_nc = b.cols ();
 
       if (a_nr == 0 || b_nc == 0)
 	return SparseComplexMatrix (a_nr, a_nc);
-      if (a.nnz () == 0)
+      if (a.nzmax () == 0)
 	return SparseComplexMatrix (b);
-      if (b.nnz () == 0)
+      if (b.nzmax () == 0)
 	return SparseComplexMatrix (a);
 
       if (a_nr != b_nr || a_nc != b_nc)
 	gripe_nonconformant ("min", a_nr, a_nc, b_nr, b_nc);
       else
 	{
-	  r = SparseComplexMatrix (a_nr, a_nc, (a.nnz () + b.nnz ()));
+	  r = SparseComplexMatrix (a_nr, a_nc, (a.nzmax () + b.nzmax ()));
        
 	  octave_idx_type jx = 0;
 	  r.cidx (0) = 0;
 	  for (octave_idx_type i = 0 ; i < a_nc ; i++)
 	    {
 	      octave_idx_type  ja = a.cidx(i);
 	      octave_idx_type  ja_max = a.cidx(i+1);
 	      bool ja_lt_max= ja < ja_max;
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,16 @@
+2006-01-31  John W. Eaton  <jwe@octave.org>
+
+	* Sparse.h (Sparse<T>::nzmax): New function.
+	(Sparse<T>::nnz): Rename from nonzero.
+	Change all uses of old nnz function to be nzmax.  Change all uses
+	of nonzero to be nnz.
+	(Sparse<T>::nzmx): Rename from nnz (data member).  Change all uses.
+
 2006-01-21  David Bateman  <dbateman@free.fr>
 
         * sparse-sort.cc (bool octave_sparse_sidxl_comp): 64-bit fix.
         (bool octave_idx_vector_comp): New function.
         (template class octave_sort<octave_idx_vector_sort *>): Instantiate
         indexed idx_vector sorting function.
         * sparse-sort.h (class octave_sparse_sort_idxl): 64-bit fix.
         (class octave_idx_vector_sort): New class for indexed idx_vector
diff --git a/liboctave/MSparse.cc b/liboctave/MSparse.cc
--- a/liboctave/MSparse.cc
+++ b/liboctave/MSparse.cc
@@ -47,17 +47,17 @@ operator += (MSparse<T>& a, const MSpars
 
     octave_idx_type b_nr = b.rows ();
     octave_idx_type b_nc = b.cols ();
 
     if (a_nr != b_nr || a_nc != b_nc)
       gripe_nonconformant ("operator +=" , a_nr, a_nc, b_nr, b_nc);
     else
       {
-        r = MSparse<T> (a_nr, a_nc, (a.nnz () + b.nnz ()));
+        r = MSparse<T> (a_nr, a_nc, (a.nzmax () + b.nzmax ()));
        
         octave_idx_type jx = 0;
         for (octave_idx_type i = 0 ; i < a_nc ; i++)
           {
             octave_idx_type  ja = a.cidx(i);
             octave_idx_type  ja_max = a.cidx(i+1);
             bool ja_lt_max= ja < ja_max;
            
@@ -120,17 +120,17 @@ operator -= (MSparse<T>& a, const MSpars
 
     octave_idx_type b_nr = b.rows ();
     octave_idx_type b_nc = b.cols ();
 
     if (a_nr != b_nr || a_nc != b_nc)
       gripe_nonconformant ("operator -=" , a_nr, a_nc, b_nr, b_nc);
     else
       {
-        r = MSparse<T> (a_nr, a_nc, (a.nnz () + b.nnz ()));
+        r = MSparse<T> (a_nr, a_nc, (a.nzmax () + b.nzmax ()));
        
         octave_idx_type jx = 0;
         for (octave_idx_type i = 0 ; i < a_nc ; i++)
           {
             octave_idx_type  ja = a.cidx(i);
             octave_idx_type  ja_max = a.cidx(i+1);
             bool ja_lt_max= ja < ja_max;
            
@@ -202,17 +202,17 @@ operator -= (MSparse<T>& a, const MSpars
 
 #define SPARSE_A2S_OP_2(OP) \
   template <class T> \
   MSparse<T> \
   operator OP (const MSparse<T>& a, const T& s) \
   { \
     octave_idx_type nr = a.rows (); \
     octave_idx_type nc = a.cols (); \
-    octave_idx_type nz = a.nnz (); \
+    octave_idx_type nz = a.nzmax (); \
  \
     MSparse<T> r (nr, nc, nz); \
  \
     for (octave_idx_type i = 0; i < nz; i++) \
       { \
 	r.data(i) = a.data(i) OP s; \
 	r.ridx(i) = a.ridx(i); \
       } \
@@ -248,17 +248,17 @@ SPARSE_A2S_OP_2 (/)
 
 #define SPARSE_SA2_OP_2(OP) \
   template <class T> \
   MSparse<T> \
   operator OP (const T& s, const MSparse<T>& a) \
   { \
     octave_idx_type nr = a.rows (); \
     octave_idx_type nc = a.cols (); \
-    octave_idx_type nz = a.nnz (); \
+    octave_idx_type nz = a.nzmax (); \
  \
     MSparse<T> r (nr, nc, nz); \
  \
     for (octave_idx_type i = 0; i < nz; i++) \
       { \
 	r.data(i) = s OP a.data(i); \
 	r.ridx(i) = a.ridx(i); \
       } \
@@ -287,17 +287,17 @@ SPARSE_SA2_OP_2 (/)
  \
     octave_idx_type b_nr = b.rows (); \
     octave_idx_type b_nc = b.cols (); \
  \
     if (a_nr != b_nr || a_nc != b_nc) \
       gripe_nonconformant ("operator " # OP, a_nr, a_nc, b_nr, b_nc); \
     else \
       { \
-        r = MSparse<T> (a_nr, a_nc, (a.nnz () + b.nnz ())); \
+        r = MSparse<T> (a_nr, a_nc, (a.nzmax () + b.nzmax ())); \
         \
         octave_idx_type jx = 0; \
 	r.cidx (0) = 0; \
         for (octave_idx_type i = 0 ; i < a_nc ; i++) \
           { \
             octave_idx_type  ja = a.cidx(i); \
             octave_idx_type  ja_max = a.cidx(i+1); \
             bool ja_lt_max= ja < ja_max; \
@@ -362,17 +362,17 @@ SPARSE_SA2_OP_2 (/)
  \
     octave_idx_type b_nr = b.rows (); \
     octave_idx_type b_nc = b.cols (); \
  \
     if (a_nr != b_nr || a_nc != b_nc) \
       gripe_nonconformant (#FCN, a_nr, a_nc, b_nr, b_nc); \
     else \
       { \
-        r = MSparse<T> (a_nr, a_nc, (a.nnz() > b.nnz() ? a.nnz() : b.nnz())); \
+        r = MSparse<T> (a_nr, a_nc, (a.nzmax () > b.nzmax () ? a.nzmax () : b.nzmax ())); \
         \
         octave_idx_type jx = 0; \
 	r.cidx (0) = 0; \
         for (octave_idx_type i = 0 ; i < a_nc ; i++) \
           { \
             octave_idx_type  ja = a.cidx(i); \
             octave_idx_type  ja_max = a.cidx(i+1); \
             bool ja_lt_max= ja < ja_max; \
@@ -489,17 +489,17 @@ operator + (const MSparse<T>& a)
   return a;
 }
 
 template <class T>
 MSparse<T>
 operator - (const MSparse<T>& a)
 {
   MSparse<T> retval (a);
-  octave_idx_type nz = a.nnz ();
+  octave_idx_type nz = a.nzmax ();
   for (octave_idx_type i = 0; i < nz; i++)
     retval.data(i) = - retval.data(i);
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/Sparse-op-defs.h b/liboctave/Sparse-op-defs.h
--- a/liboctave/Sparse-op-defs.h
+++ b/liboctave/Sparse-op-defs.h
@@ -58,17 +58,17 @@ Boston, MA 02110-1301, USA.
   }
 
 #define SPARSE_SMS_BIN_OP_2(R, F, OP, M, S)	\
   R \
   F (const M& m, const S& s) \
   { \
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
-    octave_idx_type nz = m.nnz (); \
+    octave_idx_type nz = m.nzmax (); \
  \
     R r (nr, nc, nz); \
  \
     for (octave_idx_type i = 0; i < nz; i++) \
       { \
 	r.data(i) = m.data(i) OP s; \
 	r.ridx(i) = m.ridx(i); \
       } \
@@ -98,17 +98,17 @@ Boston, MA 02110-1301, USA.
   SPARSE_CMP_OP_DECL (mx_el_ne, M, S);
 
 #define SPARSE_SMS_CMP_OP(F, OP, M, MZ, MC, S, SZ, SC)	\
   SparseBoolMatrix \
   F (const M& m, const S& s) \
   { \
     /* Count num of non-zero elements */ \
     octave_idx_type nel = 0; \
-    octave_idx_type nz = m.nnz (); \
+    octave_idx_type nz = m.nzmax (); \
     if (MC (MZ) OP SC (s))   \
       nel += m.numel() - nz; \
     for (octave_idx_type i = 0; i < nz; i++) \
       if (MC (m.data (i)) OP SC (s)) \
         nel++;	\
     \
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
@@ -173,17 +173,17 @@ Boston, MA 02110-1301, USA.
   SPARSE_BOOL_OP_DECL (mx_el_or,  M, S);
 
 #define SPARSE_SMS_BOOL_OP(F, OP, M, S, LHS_ZERO, RHS_ZERO) \
   SparseBoolMatrix \
   F (const M& m, const S& s) \
   { \
     /* Count num of non-zero elements */ \
     octave_idx_type nel = 0; \
-    octave_idx_type nz = m.nnz (); \
+    octave_idx_type nz = m.nzmax (); \
     if (LHS_ZERO OP (s != RHS_ZERO)) \
       nel += m.numel() - nz; \
     for (octave_idx_type i = 0; i < nz; i++) \
       if ((m.data(i) != LHS_ZERO) OP (s != RHS_ZERO))\
         nel++;	\
     \
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
@@ -268,17 +268,17 @@ Boston, MA 02110-1301, USA.
   }
 
 #define SPARSE_SSM_BIN_OP_2(R, F, OP, S, M) \
   R \
   F (const S& s, const M& m) \
   { \
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
-    octave_idx_type nz = m.nnz (); \
+    octave_idx_type nz = m.nzmax (); \
  \
     R r (nr, nc, nz); \
  \
     for (octave_idx_type i = 0; i < nz; i++) \
       { \
 	r.data(i) = s OP m.data(i); \
 	r.ridx(i) = m.ridx(i); \
       } \
@@ -308,17 +308,17 @@ Boston, MA 02110-1301, USA.
   SPARSE_CMP_OP_DECL (mx_el_ne, S, M);
 
 #define SPARSE_SSM_CMP_OP(F, OP, S, SZ, SC, M, MZ, MC)	\
   SparseBoolMatrix \
   F (const S& s, const M& m) \
   { \
     /* Count num of non-zero elements */ \
     octave_idx_type nel = 0; \
-    octave_idx_type nz = m.nnz (); \
+    octave_idx_type nz = m.nzmax (); \
     if (SC (s) OP MC (MZ))   \
       nel += m.numel() - nz; \
     for (octave_idx_type i = 0; i < nz; i++) \
       if (SC (s) OP MC (m.data (i))) \
         nel++;	\
     \
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
@@ -383,17 +383,17 @@ Boston, MA 02110-1301, USA.
   SPARSE_BOOL_OP_DECL (mx_el_or,  S, M); \
 
 #define SPARSE_SSM_BOOL_OP(F, OP, S, M, LHS_ZERO, RHS_ZERO) \
   SparseBoolMatrix \
   F (const S& s, const M& m) \
   { \
     /* Count num of non-zero elements */ \
     octave_idx_type nel = 0; \
-    octave_idx_type nz = m.nnz (); \
+    octave_idx_type nz = m.nzmax (); \
     if ((s != LHS_ZERO) OP  RHS_ZERO) \
       nel += m.numel() - nz; \
     for (octave_idx_type i = 0; i < nz; i++) \
       if ((s != LHS_ZERO) OP m.data(i) != RHS_ZERO) \
         nel++;	\
     \
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
@@ -472,17 +472,17 @@ Boston, MA 02110-1301, USA.
  \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
  \
     if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
-	r = R (m1_nr, m1_nc, (m1.nnz () + m2.nnz ())); \
+	r = R (m1_nr, m1_nc, (m1.nzmax () + m2.nzmax ())); \
         \
         octave_idx_type jx = 0; \
         r.cidx (0) = 0; \
         for (octave_idx_type i = 0 ; i < m1_nc ; i++) \
           { \
             octave_idx_type  ja = m1.cidx(i); \
             octave_idx_type  ja_max = m1.cidx(i+1); \
             bool ja_lt_max= ja < ja_max; \
@@ -546,17 +546,17 @@ Boston, MA 02110-1301, USA.
  \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
  \
     if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
-        r = R (m1_nr, m1_nc, (m1.nnz () > m2.nnz () ? m1.nnz () : m2.nnz ())); \
+        r = R (m1_nr, m1_nc, (m1.nzmax () > m2.nzmax () ? m1.nzmax () : m2.nzmax ())); \
         \
         octave_idx_type jx = 0; \
 	r.cidx (0) = 0; \
         for (octave_idx_type i = 0 ; i < m1_nc ; i++) \
           { \
             octave_idx_type  ja = m1.cidx(i); \
             octave_idx_type  ja_max = m1.cidx(i+1); \
             bool ja_lt_max= ja < ja_max; \
diff --git a/liboctave/Sparse.cc b/liboctave/Sparse.cc
--- a/liboctave/Sparse.cc
+++ b/liboctave/Sparse.cc
@@ -45,27 +45,27 @@ Boston, MA 02110-1301, USA.
 #include "oct-spparms.h"
 
 template <class T>
 T&
 Sparse<T>::SparseRep::elem (octave_idx_type _r, octave_idx_type _c)
 {
   octave_idx_type i;
 
-  if (nnz > 0)
+  if (nzmx > 0)
     {
       for (i = c[_c]; i < c[_c + 1]; i++)
 	if (r[i] == _r)
 	  return d[i];
 	else if (r[i] > _r)
 	  break;
 
       // Ok, If we've gotten here, we're in trouble.. Have to create a 
       // new element in the sparse array. This' gonna be slow!!!
-      if (c[ncols+1] == nnz)
+      if (c[ncols+1] == nzmx)
 	{
 	  (*current_liboctave_error_handler)
 	    ("Sparse::SparseRep::elem (octave_idx_type, octave_idx_type): sparse matrix filled");
 	  return *d;
 	}
 
       octave_idx_type to_move = c[ncols] - i;
       if (to_move != 0)
@@ -92,60 +92,60 @@ Sparse<T>::SparseRep::elem (octave_idx_t
       return *d;
     }
 }
 
 template <class T>
 T
 Sparse<T>::SparseRep::celem (octave_idx_type _r, octave_idx_type _c) const
 {
-  if (nnz > 0)
+  if (nzmx > 0)
     for (octave_idx_type i = c[_c]; i < c[_c + 1]; i++)
       if (r[i] == _r)
 	return d[i];
   return T ();
 }
 
 template <class T>
 void
 Sparse<T>::SparseRep::maybe_compress (bool remove_zeros)
 {
-  octave_idx_type ndel = nnz - c[ncols];
+  octave_idx_type ndel = nzmx - c[ncols];
   octave_idx_type nzero = 0;
 
   if (remove_zeros)
-    for (octave_idx_type i = 0; i < nnz - ndel; i++)
+    for (octave_idx_type i = 0; i < nzmx - ndel; i++)
       if (d[i] == T ())
 	nzero++;
 
   if (!ndel && !nzero)
     return;
 
   if (!nzero)
     {
-      octave_idx_type new_nnz = nnz - ndel;
-
-      T *new_data = new T [new_nnz];
-      for (octave_idx_type i = 0; i < new_nnz; i++)
+      octave_idx_type new_nzmx = nzmx - ndel;
+
+      T *new_data = new T [new_nzmx];
+      for (octave_idx_type i = 0; i < new_nzmx; i++)
 	new_data[i] = d[i];
       delete [] d;
       d = new_data;
 
-      octave_idx_type *new_ridx = new octave_idx_type [new_nnz];
-      for (octave_idx_type i = 0; i < new_nnz; i++)
+      octave_idx_type *new_ridx = new octave_idx_type [new_nzmx];
+      for (octave_idx_type i = 0; i < new_nzmx; i++)
 	new_ridx[i] = r[i];
       delete [] r;
       r = new_ridx;
     }
   else
     {
-      octave_idx_type new_nnz = nnz - ndel - nzero;
-
-      T *new_data = new T [new_nnz];
-      octave_idx_type *new_ridx = new octave_idx_type [new_nnz];
+      octave_idx_type new_nzmx = nzmx - ndel - nzero;
+
+      T *new_data = new T [new_nzmx];
+      octave_idx_type *new_ridx = new octave_idx_type [new_nzmx];
 
       octave_idx_type ii = 0;
       octave_idx_type ic = 0;
       for (octave_idx_type j = 0; j < ncols; j++)
 	{
 	  for (octave_idx_type k = ic; k < c[j+1]; k++)
 	    if (d[k] != T ())
 	      {
@@ -158,62 +158,62 @@ Sparse<T>::SparseRep::maybe_compress (bo
 
       delete [] d;
       d = new_data;
 
       delete [] r;
       r = new_ridx;
     }
 
-  nnz -= ndel + nzero;
+  nzmx -= ndel + nzero;
 }
 
 template <class T>
 void
 Sparse<T>::SparseRep::change_length (octave_idx_type nz)
 {
-  if (nz != nnz)
+  if (nz != nzmx)
     {
-      octave_idx_type min_nnz = (nz < nnz ? nz : nnz);
+      octave_idx_type min_nzmx = (nz < nzmx ? nz : nzmx);
 
       octave_idx_type * new_ridx = new octave_idx_type [nz];
-      for (octave_idx_type i = 0; i < min_nnz; i++)
+      for (octave_idx_type i = 0; i < min_nzmx; i++)
 	new_ridx[i] = r[i];
 
       delete [] r;
       r = new_ridx;
 
       T * new_data = new T [nz];
-      for (octave_idx_type i = 0; i < min_nnz; i++)
+      for (octave_idx_type i = 0; i < min_nzmx; i++)
 	new_data[i] = d[i];
 
       delete [] d;
       d = new_data;
 
-      if (nz < nnz)
+      if (nz < nzmx)
 	for (octave_idx_type i = 0; i <= ncols; i++)
 	  if (c[i] > nz)
 	    c[i] = nz;
 
-      nnz = nz;
+      nzmx = nz;
     }
 }
 
 template <class T>
 template <class U>
 Sparse<T>::Sparse (const Sparse<U>& a)
   : dimensions (a.dimensions), idx (0), idx_count (0)
 {
-  if (a.nnz () == 0)
+  if (a.nzmax () == 0)
     rep = new typename Sparse<T>::SparseRep (rows (), cols());
   else
     {
-      rep = new typename Sparse<T>::SparseRep (rows (), cols (), a.nnz ());
+      rep = new typename Sparse<T>::SparseRep (rows (), cols (), a.nzmax ());
       
-      octave_idx_type nz = nnz ();
+      octave_idx_type nz = nzmax ();
       octave_idx_type nc = cols ();
       for (octave_idx_type i = 0; i < nz; i++)
 	{
 	  xdata (i) = T (a.data (i));
 	  xridx (i) = a.ridx (i);
 	}
       for (octave_idx_type i = 0; i < nc + 1; i++)
 	xcidx (i) = a.cidx (i);
@@ -262,40 +262,40 @@ Sparse<T>::Sparse (const Sparse<T>& a, c
     static_cast<unsigned long long>(dv (1));
 
   if (a_nel != dv_nel)
     (*current_liboctave_error_handler)
       ("Sparse::Sparse (const Sparse&, const dim_vector&): dimension mismatch");
   else
     {
       dim_vector old_dims = a.dims();
-      octave_idx_type new_nnz = a.nnz ();
+      octave_idx_type new_nzmx = a.nzmax ();
       octave_idx_type new_nr = dv (0);
       octave_idx_type new_nc = dv (1);
       octave_idx_type old_nr = old_dims (0);
       octave_idx_type old_nc = old_dims (1);
 
-      rep = new typename Sparse<T>::SparseRep (new_nr, new_nc, new_nnz);
+      rep = new typename Sparse<T>::SparseRep (new_nr, new_nc, new_nzmx);
 
       octave_idx_type kk = 0;
       xcidx(0) = 0;
       for (octave_idx_type i = 0; i < old_nc; i++)
 	for (octave_idx_type j = a.cidx(i); j < a.cidx(i+1); j++)
 	  {
 	    octave_idx_type tmp = i * old_nr + a.ridx(j);
 	    octave_idx_type ii = tmp % new_nr;
 	    octave_idx_type jj = (tmp - ii) / new_nr; 
 	    for (octave_idx_type k = kk; k < jj; k++)
 	      xcidx(k+1) = j;
 	    kk = jj;
 	    xdata(j) = a.data(j);
 	    xridx(j) = ii;
 	  }
       for (octave_idx_type k = kk; k < new_nc; k++)
-	xcidx(k+1) = new_nnz;
+	xcidx(k+1) = new_nzmx;
     }
 }
 
 template <class T>
 Sparse<T>::Sparse (const Array<T>& a, const Array<octave_idx_type>& r, 
 		   const Array<octave_idx_type>& c, octave_idx_type nr,
 		   octave_idx_type nc, bool sum_terms)
   : dimensions (dim_vector (nr, nc)), idx (0), idx_count (0)
@@ -313,77 +313,77 @@ Sparse<T>::Sparse (const Array<T>& a, co
     {
       (*current_liboctave_error_handler)
 	("Sparse::Sparse (const Array<T>&, const Array<octave_idx_type>&, ...): dimension mismatch");
       rep = nil_rep ();
       dimensions = dim_vector (0, 0);
     }
   else
     {
-      octave_idx_type max_nnz = (r_len > c_len ? r_len : c_len);
-
-      OCTAVE_LOCAL_BUFFER (octave_sparse_sort_idxl *, sidx, max_nnz);
-      OCTAVE_LOCAL_BUFFER (octave_sparse_sort_idxl, sidxX, max_nnz);
-
-      for (octave_idx_type i = 0; i < max_nnz; i++)
+      octave_idx_type max_nzmx = (r_len > c_len ? r_len : c_len);
+
+      OCTAVE_LOCAL_BUFFER (octave_sparse_sort_idxl *, sidx, max_nzmx);
+      OCTAVE_LOCAL_BUFFER (octave_sparse_sort_idxl, sidxX, max_nzmx);
+
+      for (octave_idx_type i = 0; i < max_nzmx; i++)
 	sidx[i] = &sidxX[i];
 
-      octave_idx_type actual_nnz = 0;
+      octave_idx_type actual_nzmx = 0;
       OCTAVE_QUIT;
-      for (octave_idx_type i = 0; i < max_nnz; i++) 
+      for (octave_idx_type i = 0; i < max_nzmx; i++) 
 	{
 	  octave_idx_type rowidx =  (ri_scalar ? r(0) : r(i));
 	  octave_idx_type colidx = (ci_scalar ? c(0) : c(i));
 	  if (rowidx < nr && rowidx >= 0 &&
 	      colidx < nc && colidx >= 0 ) 
 	    {
 	      if ( a (cf_scalar ? 0 : i ) != T ()) 
 		{
-		  sidx[actual_nnz]->r = rowidx;
-		  sidx[actual_nnz]->c = colidx;
-		  sidx[actual_nnz]->idx = i;
-		  actual_nnz++;	
+		  sidx[actual_nzmx]->r = rowidx;
+		  sidx[actual_nzmx]->c = colidx;
+		  sidx[actual_nzmx]->idx = i;
+		  actual_nzmx++;	
 		}
 	    }
 	  else 
 	    {
 	      (*current_liboctave_error_handler)
 		("Sparse::Sparse : index (%d,%d) out of range", 
 		 rowidx + 1, colidx + 1);
 	      rep = nil_rep ();
 	      dimensions = dim_vector (0, 0);
 	      return;
 	    }
 	}
   
-      if (actual_nnz == 0)
+      if (actual_nzmx == 0)
 	rep = new typename Sparse<T>::SparseRep (nr, nc);
       else
 	{
 	  OCTAVE_QUIT;
 	  octave_sort<octave_sparse_sort_idxl *> 
 	    sort (octave_sparse_sidxl_comp);
 
-	  sort.sort (sidx, actual_nnz);
+	  sort.sort (sidx, actual_nzmx);
 	  OCTAVE_QUIT;
 
 	  // Now count the unique non-zero values
-	  octave_idx_type real_nnz = 1;
-	  for (octave_idx_type i = 1; i < actual_nnz; i++) 
+	  octave_idx_type real_nzmx = 1;
+	  for (octave_idx_type i = 1; i < actual_nzmx; i++) 
 	    if (sidx[i-1]->r != sidx[i]->r || sidx[i-1]->c != sidx[i]->c) 
-	      real_nnz++;
-
-	  rep = new typename Sparse<T>::SparseRep (nr, nc, real_nnz);
+	      real_nzmx++;
+
+	  rep = new typename Sparse<T>::SparseRep (nr, nc, real_nzmx);
 
 	  octave_idx_type cx = 0;
 	  octave_idx_type prev_rval = -1;
 	  octave_idx_type prev_cval = -1;
 	  octave_idx_type ii = -1;
 	  xcidx (0) = 0;
-	  for (octave_idx_type i = 0; i < actual_nnz; i++) 
+	  for (octave_idx_type i = 0; i < actual_nzmx; i++) 
 	    {
 	      OCTAVE_QUIT;
 	      octave_idx_type iidx = sidx[i]->idx;
 	      octave_idx_type rval = sidx[i]->r;
 	      octave_idx_type cval = sidx[i]->c;
 
 	      if (prev_cval < cval || (prev_rval < rval && prev_cval == cval)) 
 		{
@@ -430,78 +430,78 @@ Sparse<T>::Sparse (const Array<T>& a, co
     {
       (*current_liboctave_error_handler)
 	("Sparse::Sparse (const Array<T>&, const Array<double>&, ...): dimension mismatch");
       rep = nil_rep ();
       dimensions = dim_vector (0, 0);
     }
   else
     {
-      octave_idx_type max_nnz = (r_len > c_len ? r_len : c_len);
+      octave_idx_type max_nzmx = (r_len > c_len ? r_len : c_len);
   
-      OCTAVE_LOCAL_BUFFER (octave_sparse_sort_idxl *, sidx, max_nnz);
-      OCTAVE_LOCAL_BUFFER (octave_sparse_sort_idxl, sidxX, max_nnz);
-
-      for (octave_idx_type i = 0; i < max_nnz; i++)
+      OCTAVE_LOCAL_BUFFER (octave_sparse_sort_idxl *, sidx, max_nzmx);
+      OCTAVE_LOCAL_BUFFER (octave_sparse_sort_idxl, sidxX, max_nzmx);
+
+      for (octave_idx_type i = 0; i < max_nzmx; i++)
 	sidx[i] = &sidxX[i];
 
-      octave_idx_type actual_nnz = 0;
+      octave_idx_type actual_nzmx = 0;
       OCTAVE_QUIT;
 
-      for (octave_idx_type i = 0; i < max_nnz; i++) 
+      for (octave_idx_type i = 0; i < max_nzmx; i++) 
 	{
 	  octave_idx_type rowidx = static_cast<octave_idx_type> (ri_scalar ? r(0) : r(i));
 	  octave_idx_type colidx = static_cast<octave_idx_type> (ci_scalar ? c(0) : c(i));
 	  if (rowidx < nr && rowidx >= 0 &&
 	      colidx < nc && colidx >= 0 ) 
 	    {
 	      if ( a (cf_scalar ? 0 : i ) != T ()) 
 		{
-		  sidx[actual_nnz]->r = rowidx;
-		  sidx[actual_nnz]->c = colidx;
-		  sidx[actual_nnz]->idx = i;
-		  actual_nnz++;	
+		  sidx[actual_nzmx]->r = rowidx;
+		  sidx[actual_nzmx]->c = colidx;
+		  sidx[actual_nzmx]->idx = i;
+		  actual_nzmx++;	
 		}
 	    }
 	  else 
 	    {
 	      (*current_liboctave_error_handler)
 		("Sparse::Sparse : index (%d,%d) out of range", 
 		 rowidx + 1, colidx + 1);
 	      rep = nil_rep ();
 	      dimensions = dim_vector (0, 0);
 	      return;
 	    }
 	}
 
-      if (actual_nnz == 0)
+      if (actual_nzmx == 0)
 	rep = new typename Sparse<T>::SparseRep (nr, nc);
       else
 	{
 	  OCTAVE_QUIT;
 	  octave_sort<octave_sparse_sort_idxl *> 
 	    sort (octave_sparse_sidxl_comp);
 
-	  sort.sort (sidx, actual_nnz);
+	  sort.sort (sidx, actual_nzmx);
 	  OCTAVE_QUIT;
 
 	  // Now count the unique non-zero values
-	  octave_idx_type real_nnz = 1;
-	  for (octave_idx_type i = 1; i < actual_nnz; i++) 
+	  octave_idx_type real_nzmx = 1;
+	  for (octave_idx_type i = 1; i < actual_nzmx; i++) 
 	    if (sidx[i-1]->r != sidx[i]->r || sidx[i-1]->c != sidx[i]->c) 
-	      real_nnz++;
-
-	  rep = new typename Sparse<T>::SparseRep (nr, nc, real_nnz);
+	      real_nzmx++;
+
+	  rep = new typename Sparse<T>::SparseRep (nr, nc, real_nzmx);
 
 	  octave_idx_type cx = 0;
 	  octave_idx_type prev_rval = -1;
 	  octave_idx_type prev_cval = -1;
 	  octave_idx_type ii = -1;
 	  xcidx (0) = 0;
-	  for (octave_idx_type i = 0; i < actual_nnz; i++) 
+	  for (octave_idx_type i = 0; i < actual_nzmx; i++) 
 	    {
 	      OCTAVE_QUIT;
 	      octave_idx_type iidx = sidx[i]->idx;
 	      octave_idx_type rval = sidx[i]->r;
 	      octave_idx_type cval = sidx[i]->c;
 
 	      if (prev_cval < cval || (prev_rval < rval && prev_cval == cval)) 
 		{
@@ -532,24 +532,24 @@ Sparse<T>::Sparse (const Array<T>& a, co
 
 template <class T>
 Sparse<T>::Sparse (const Array2<T>& a)
   : dimensions (a.dims ()), idx (0), idx_count (0)
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type len = a.length ();
-  octave_idx_type new_nnz = 0;
+  octave_idx_type new_nzmx = 0;
 
   // First count the number of non-zero terms
   for (octave_idx_type i = 0; i < len; i++)
     if (a(i) != T ())
-      new_nnz++;
-
-  rep = new typename Sparse<T>::SparseRep (nr, nc, new_nnz);
+      new_nzmx++;
+
+  rep = new typename Sparse<T>::SparseRep (nr, nc, new_nzmx);
 
   octave_idx_type ii = 0;
   xcidx(0) = 0;
   for (octave_idx_type j = 0; j < nc; j++)
     {
       for (octave_idx_type i = 0; i < nr; i++)
 	if (a.elem (i,j) != T ())
 	  {
@@ -567,24 +567,24 @@ Sparse<T>::Sparse (const Array<T>& a)
   if (dimensions.length () > 2)
     (*current_liboctave_error_handler)
       ("Sparse::Sparse (const Array<T>&): dimension mismatch");
   else
     {
       octave_idx_type nr = rows ();
       octave_idx_type nc = cols ();
       octave_idx_type len = a.length ();
-      octave_idx_type new_nnz = 0;
+      octave_idx_type new_nzmx = 0;
 
       // First count the number of non-zero terms
       for (octave_idx_type i = 0; i < len; i++)
 	if (a(i) != T ())
-	  new_nnz++;
-
-      rep = new typename Sparse<T>::SparseRep (nr, nc, new_nnz);
+	  new_nzmx++;
+
+      rep = new typename Sparse<T>::SparseRep (nr, nc, new_nzmx);
 
       octave_idx_type ii = 0;
       xcidx(0) = 0;
       for (octave_idx_type j = 0; j < nc; j++)
 	{
 	  for (octave_idx_type i = 0; i < nr; i++)
 	    if (a.elem (i,j) != T ())
 	      {
@@ -726,39 +726,39 @@ Sparse<T>
 Sparse<T>::reshape (const dim_vector& new_dims) const
 {
   Sparse<T> retval;
 
   if (dimensions != new_dims)
     {
       if (dimensions.numel () == new_dims.numel ())
 	{
-	  octave_idx_type new_nnz = nnz ();
+	  octave_idx_type new_nzmx = nzmax ();
 	  octave_idx_type new_nr = new_dims (0);
 	  octave_idx_type new_nc = new_dims (1);
 	  octave_idx_type old_nr = rows ();
 	  octave_idx_type old_nc = cols ();
-	  retval = Sparse<T> (new_nr, new_nc, new_nnz);
+	  retval = Sparse<T> (new_nr, new_nc, new_nzmx);
 
 	  octave_idx_type kk = 0;
 	  retval.xcidx(0) = 0;
 	  for (octave_idx_type i = 0; i < old_nc; i++)
 	    for (octave_idx_type j = cidx(i); j < cidx(i+1); j++)
 	      {
 		octave_idx_type tmp = i * old_nr + ridx(j);
 		octave_idx_type ii = tmp % new_nr;
 		octave_idx_type jj = (tmp - ii) / new_nr; 
 		for (octave_idx_type k = kk; k < jj; k++)
 		  retval.xcidx(k+1) = j;
 		kk = jj;
 		retval.xdata(j) = data(j);
 		retval.xridx(j) = ii;
 	      }
 	  for (octave_idx_type k = kk; k < new_nc; k++)
-	    retval.xcidx(k+1) = new_nnz;
+	    retval.xcidx(k+1) = new_nzmx;
 	}
       else
 	(*current_liboctave_error_handler) ("reshape: size mismatch");
     }
   else
     retval = *this;
 
   return retval;
@@ -841,17 +841,17 @@ Sparse<T>::resize_no_fill (octave_idx_ty
 
   if (r == dim1 () && c == dim2 ())
     return;
 
   typename Sparse<T>::SparseRep *old_rep = Sparse<T>::rep;
   octave_idx_type nc = cols ();
   octave_idx_type nr = rows ();
 
-  if (nnz () == 0 || r == 0 || c == 0)
+  if (nzmax () == 0 || r == 0 || c == 0)
     // Special case of redimensioning to/from a sparse matrix with 
     // no elements
     rep = new typename Sparse<T>::SparseRep (r, c);
   else
     {
       octave_idx_type n = 0;
       Sparse<T> tmpval;
       if (r >= nr)
@@ -930,17 +930,17 @@ Sparse<T>::insert (const Sparse<T>& a, o
 
   if (r < 0 || r + a_rows > rows () || c < 0 || c + a_cols > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   // First count the number of elements in the final array
-  octave_idx_type nel = cidx(c) + a.nnz ();
+  octave_idx_type nel = cidx(c) + a.nzmax ();
 
   if (c + a_cols < nc)
     nel += cidx(nc) - cidx(c + a_cols);
 
   for (octave_idx_type i = c; i < c + a_cols; i++)
     for (octave_idx_type j = cidx(i); j < cidx(i+1); j++)
       if (ridx(j) < r || ridx(j) >= r + a_rows)
 	nel++;
@@ -1020,17 +1020,17 @@ Sparse<T>::insert (const Sparse<T>& a, c
 template <class T>
 Sparse<T>
 Sparse<T>::transpose (void) const
 {
   assert (ndims () == 2);
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-  octave_idx_type nz = nnz ();
+  octave_idx_type nz = nzmax ();
   Sparse<T> retval (nc, nr, nz);
 
   retval.cidx(0) = 0;
   for (octave_idx_type i = 0, iidx = 0; i < nr; i++)
     {
       for (octave_idx_type j = 0; j < nc; j++)
 	for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
 	  if (ridx(k) == i)
@@ -1118,47 +1118,47 @@ Sparse<T>::maybe_delete_elements (idx_ve
 
   idx_arg.sort (true);
 
   octave_idx_type num_to_delete = idx_arg.length (n);
 
   if (num_to_delete != 0)
     {
       octave_idx_type new_n = n;
-      octave_idx_type new_nnz = nnz ();
+      octave_idx_type new_nzmx = nzmax ();
 
       octave_idx_type iidx = 0;
 
       const Sparse<T> tmp (*this);
 
       for (octave_idx_type i = 0; i < n; i++)
 	{
 	  OCTAVE_QUIT;
 
 	  if (i == idx_arg.elem (iidx))
 	    {
 	      iidx++;
 	      new_n--;
 
 	      if (tmp.elem (i) != T ())
-		new_nnz--;
+		new_nzmx--;
 
 	      if (iidx == num_to_delete)
 		break;
 	    }
 	}
 
       if (new_n > 0)
 	{
 	  rep->count--;
 
 	  if (nr == 1)
-	    rep = new typename Sparse<T>::SparseRep (1, new_n, new_nnz);
+	    rep = new typename Sparse<T>::SparseRep (1, new_n, new_nzmx);
 	  else
-	    rep = new typename Sparse<T>::SparseRep (new_n, 1, new_nnz);
+	    rep = new typename Sparse<T>::SparseRep (new_n, 1, new_nzmx);
 
 	  octave_idx_type ii = 0;
 	  octave_idx_type jj = 0;
 	  iidx = 0;
 	  for (octave_idx_type i = 0; i < n; i++)
 	    {
 	      OCTAVE_QUIT;
 
@@ -1191,17 +1191,17 @@ Sparse<T>::maybe_delete_elements (idx_ve
 		}
 
 	      dimensions(0) = 1;
 	      dimensions(1) = new_n;
 	    }
 	  else
 	    {
 	      cidx(0) = 0;
-	      cidx(1) = new_nnz;
+	      cidx(1) = new_nzmx;
 	      dimensions(0) = new_n;
 	      dimensions(1) = 1;
 	    }
 	}
       else
 	(*current_liboctave_error_handler)
 	  ("A(idx) = []: index out of range");
     }
@@ -1263,42 +1263,42 @@ Sparse<T>::maybe_delete_elements (idx_ve
 
 	  if (num_to_delete != 0)
 	    {
 	      if (nr == 1 && num_to_delete == nc)
 		resize_no_fill (0, 0);
 	      else
 		{
 		  octave_idx_type new_nc = nc;
-		  octave_idx_type new_nnz = nnz ();
+		  octave_idx_type new_nzmx = nzmax ();
 
 		  octave_idx_type iidx = 0;
 
 		  for (octave_idx_type j = 0; j < nc; j++)
 		    {
 		      OCTAVE_QUIT;
 
 		      if (j == idx_j.elem (iidx))
 			{
 			  iidx++;
 			  new_nc--;
 			  
-			  new_nnz -= cidx(j+1) - cidx(j);
+			  new_nzmx -= cidx(j+1) - cidx(j);
 
 			  if (iidx == num_to_delete)
 			    break;
 			}
 		    }
 
 		  if (new_nc > 0)
 		    {
 		      const Sparse<T> tmp (*this);
 		      --rep->count;
 		      rep = new typename Sparse<T>::SparseRep (nr, new_nc, 
-							       new_nnz);
+							       new_nzmx);
 		      octave_idx_type ii = 0;
 		      octave_idx_type jj = 0;
 		      iidx = 0;
 		      cidx(0) = 0;
 		      for (octave_idx_type j = 0; j < nc; j++)
 			{
 			  OCTAVE_QUIT;
 
@@ -1338,44 +1338,44 @@ Sparse<T>::maybe_delete_elements (idx_ve
 
 	  if (num_to_delete != 0)
 	    {
 	      if (nc == 1 && num_to_delete == nr)
 		resize_no_fill (0, 0);
 	      else
 		{
 		  octave_idx_type new_nr = nr;
-		  octave_idx_type new_nnz = nnz ();
+		  octave_idx_type new_nzmx = nzmax ();
 
 		  octave_idx_type iidx = 0;
 
 		  for (octave_idx_type i = 0; i < nr; i++)
 		    {
 		      OCTAVE_QUIT;
 
 		      if (i == idx_i.elem (iidx))
 			{
 			  iidx++;
 			  new_nr--;
 			  
-			  for (octave_idx_type j = 0; j < nnz (); j++)
+			  for (octave_idx_type j = 0; j < nzmax (); j++)
 			    if (ridx(j) == i)
-			      new_nnz--;
+			      new_nzmx--;
 
 			  if (iidx == num_to_delete)
 			    break;
 			}
 		    }
 
 		  if (new_nr > 0)
 		    {
 		      const Sparse<T> tmp (*this);
 		      --rep->count;
 		      rep = new typename Sparse<T>::SparseRep (new_nr, nc, 
-							       new_nnz);
+							       new_nzmx);
 
 		      octave_idx_type jj = 0;
 		      cidx(0) = 0;
 		      for (octave_idx_type i = 0; i < nc; i++)
 			{
 			  iidx = 0;
 			  for (octave_idx_type j = tmp.cidx(i); j < tmp.cidx(i+1); j++)
 			    {
@@ -1459,17 +1459,17 @@ Sparse<T>
 Sparse<T>::index (idx_vector& idx_arg, int resize_ok) const
 {
   Sparse<T> retval;
 
   assert (ndims () == 2);
 
   octave_idx_type nr = dim1 ();
   octave_idx_type nc = dim2 ();
-  octave_idx_type nz = nnz ();
+  octave_idx_type nz = nzmax ();
 
   octave_idx_type orig_len = nr * nc;
 
   dim_vector idx_orig_dims = idx_arg.orig_dimensions ();
 
   octave_idx_type idx_orig_rows = idx_arg.orig_rows ();
   octave_idx_type idx_orig_columns = idx_arg.orig_columns ();
 
@@ -1567,49 +1567,49 @@ Sparse<T>::index (idx_vector& idx_arg, i
 	if ((n != 0 && idx_arg.one_zero_only ())
 	    || idx_orig_rows == 1 || idx_orig_columns == 1)
 	  retval = Sparse<T> ((nr == 1 ? 1 : n), (nr == 1 ? n : 1));
 	else
 	  retval = Sparse<T> (idx_orig_dims);
       else
 	{
 
-	  octave_idx_type new_nnz = 0;
+	  octave_idx_type new_nzmx = 0;
 	  if (nr == 1)
 	    for (octave_idx_type i = 0; i < n; i++)
 	      {
 		OCTAVE_QUIT;
 
 		octave_idx_type ii = idx_arg.elem (i);
 		if (ii < len)
 		  if (cidx(ii) != cidx(ii+1))
-		    new_nnz++;
+		    new_nzmx++;
 	      }
 	  else
 	    for (octave_idx_type i = 0; i < n; i++)
 	      {
 		octave_idx_type ii = idx_arg.elem (i);
 		if (ii < len)
 		  for (octave_idx_type j = 0; j < nz; j++)
 		    {
 		      OCTAVE_QUIT;
 
 		      if (ridx(j) == ii)
-			new_nnz++;
+			new_nzmx++;
 		      if (ridx(j) >= ii)
 			break;
 		    }
 	      }
 
 	  if (idx_arg.one_zero_only () || idx_orig_rows == 1 || 
 	      idx_orig_columns == 1)
 	    {
 	      if (nr == 1)
 		{
-		  retval = Sparse<T> (1, n, new_nnz);
+		  retval = Sparse<T> (1, n, new_nzmx);
 		  octave_idx_type jj = 0;
 		  retval.xcidx(0) = 0;
 		  for (octave_idx_type i = 0; i < n; i++)
 		    {
 		      OCTAVE_QUIT;
 
 		      octave_idx_type ii = idx_arg.elem (i);
 		      if (ii < len)
@@ -1618,19 +1618,19 @@ Sparse<T>::index (idx_vector& idx_arg, i
 			    retval.xdata(jj) = data(cidx(ii));
 			    retval.xridx(jj++) = 0;
 			  }
 		      retval.xcidx(i+1) = jj;
 		    }
 		}
 	      else
 		{
-		  retval = Sparse<T> (n, 1, new_nnz);
+		  retval = Sparse<T> (n, 1, new_nzmx);
 		  retval.xcidx(0) = 0;
-		  retval.xcidx(1) = new_nnz;
+		  retval.xcidx(1) = new_nzmx;
 		  octave_idx_type jj = 0;
 		  for (octave_idx_type i = 0; i < n; i++)
 		    {
 		      octave_idx_type ii = idx_arg.elem (i);
 		      if (ii < len)
 			for (octave_idx_type j = 0; j < nz; j++)
 			  {
 			    OCTAVE_QUIT;
@@ -1656,17 +1656,17 @@ Sparse<T>::index (idx_vector& idx_arg, i
 		  new_nc = idx_orig_columns;
 		}
 	      else
 		{
 		  new_nr = n;
 		  new_nc = 1;
 		}
 
-	      retval = Sparse<T> (new_nr, new_nc, new_nnz);
+	      retval = Sparse<T> (new_nr, new_nc, new_nzmx);
 
 	      if (nr == 1)
 		{
 		  octave_idx_type jj = 0;
 		  retval.xcidx(0) = 0;
 		  for (octave_idx_type i = 0; i < n; i++)
 		    {
 		      OCTAVE_QUIT;
@@ -1732,41 +1732,41 @@ Sparse<T>::index (idx_vector& idx_arg, i
 	      result_nc = (result_nr > 0 ? 1 : 0);
 	    }
 
 	  if (nz < 1)
 	      retval = Sparse<T> (result_nr, result_nc);
 	  else
 	    {
 	      // Count number of non-zero elements
-	      octave_idx_type new_nnz = 0;
+	      octave_idx_type new_nzmx = 0;
 	      octave_idx_type kk = 0;
 	      for (octave_idx_type j = 0; j < result_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < result_nr; i++)
 		    {
 		      OCTAVE_QUIT;
 		      
 		      octave_idx_type ii = idx_arg.elem (kk++);
 		      if (ii < orig_len)
 			{
 			  octave_idx_type fr = ii % nr;
 			  octave_idx_type fc = (ii - fr) / nr;
 			  for (octave_idx_type k = cidx(fc); k < cidx(fc+1); k++)
 			    {
 			      if (ridx(k) == fr)
-				new_nnz++;
+				new_nzmx++;
 			      if (ridx(k) >= fr)
 				break;
 			    }
 			}
 		    }
 		}
 	      
-	      retval = Sparse<T> (result_nr, result_nc, new_nnz);
+	      retval = Sparse<T> (result_nr, result_nc, new_nzmx);
 
 	      kk = 0;
 	      octave_idx_type jj = 0;
 	      retval.xcidx(0) = 0;
 	      for (octave_idx_type j = 0; j < result_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < result_nr; i++)
 		    {
@@ -1821,39 +1821,39 @@ Sparse<T>::index (idx_vector& idx_i, idx
 	}
       else if (idx_i.is_colon_equiv (nr) && idx_j.is_colon_equiv (nc))
 	{
 	  retval = *this;
 	}
       else
 	{
 	  // First count the number of non-zero elements
-	  octave_idx_type new_nnz = 0;
+	  octave_idx_type new_nzmx = 0;
 	  for (octave_idx_type j = 0; j < m; j++)
 	    {
 	      octave_idx_type jj = idx_j.elem (j);
 	      for (octave_idx_type i = 0; i < n; i++)
 		{
 		  OCTAVE_QUIT;
 
 		  octave_idx_type ii = idx_i.elem (i);
 		  if (ii < nr && jj < nc)
 		    {
 		      for (octave_idx_type k = cidx(jj); k < cidx(jj+1); k++)
 			{
 			  if (ridx(k) == ii)
-			    new_nnz++;
+			    new_nzmx++;
 			  if (ridx(k) >= ii)
 			    break;
 			}
 		    }
 		}
 	    }
 
-	  retval = Sparse<T> (n, m, new_nnz);
+	  retval = Sparse<T> (n, m, new_nzmx);
 
 	  octave_idx_type kk = 0;
 	  retval.xcidx(0) = 0;
 	  for (octave_idx_type j = 0; j < m; j++)
 	    {
 	      octave_idx_type jj = idx_j.elem (j);
 	      for (octave_idx_type i = 0; i < n; i++)
 		{
@@ -1931,33 +1931,33 @@ assign1 (Sparse<LT>& lhs, const Sparse<R
 	 "in the future.");
 
       lhs.clear_index ();
       return 0;
     }
 
   octave_idx_type nr = lhs.rows ();
   octave_idx_type nc = lhs.cols ();
-  octave_idx_type nz = lhs.nnz ();
+  octave_idx_type nz = lhs.nzmax ();
 
   octave_idx_type n = lhs_idx.freeze (lhs_len, "vector", true, 
 				      liboctave_wrore_flag);
 
   if (n != 0)
     {
       octave_idx_type max_idx = lhs_idx.max () + 1;
       max_idx = max_idx < lhs_len ? lhs_len : max_idx;
 
       // Take a constant copy of lhs. This means that elem won't 
       // create missing elements.
       const Sparse<LT> c_lhs (lhs);
 
       if (rhs_len == n)
 	{
-	  octave_idx_type new_nnz = lhs.nnz ();
+	  octave_idx_type new_nzmx = lhs.nzmax ();
 
 	  OCTAVE_LOCAL_BUFFER (octave_idx_type, rhs_idx, n);
 	  if (! lhs_idx.is_colon ())
 	    {
 	      // Ok here we have to be careful with the indexing,
 	      // to treat cases like "a([3,2,1]) = b", and still 
 	      // handle the need for strict sorting of the sparse 
 	      // elements.
@@ -1993,26 +1993,26 @@ assign1 (Sparse<LT>& lhs, const Sparse<R
 
 	  // First count the number of non-zero elements
 	  for (octave_idx_type i = 0; i < n; i++)
 	    {
 	      OCTAVE_QUIT;
 
 	      octave_idx_type ii = lhs_idx.elem (i);
 	      if (ii < lhs_len && c_lhs.elem(ii) != LT ())
-		new_nnz--;
+		new_nzmx--;
 	      if (rhs.elem(rhs_idx[i]) != RT ())
-		new_nnz++;
+		new_nzmx++;
 	    }
 
 	  if (nr > 1)
 	    {
-	      Sparse<LT> tmp (max_idx, 1, new_nnz);
+	      Sparse<LT> tmp (max_idx, 1, new_nzmx);
 	      tmp.cidx(0) = 0;
-	      tmp.cidx(1) = tmp.nnz ();
+	      tmp.cidx(1) = tmp.nzmax ();
 
 	      octave_idx_type i = 0;
 	      octave_idx_type ii = 0;
 	      if (i < nz)
 		ii = c_lhs.ridx(i);
 
 	      octave_idx_type j = 0;
 	      octave_idx_type jj = lhs_idx.elem(j);
@@ -2044,17 +2044,17 @@ assign1 (Sparse<LT>& lhs, const Sparse<R
 			jj = lhs_idx.elem(j);
 		    }
 		}
 
 	      lhs = tmp;
 	    }
 	  else
 	    {
-	      Sparse<LT> tmp (1, max_idx, new_nnz);
+	      Sparse<LT> tmp (1, max_idx, new_nzmx);
 
 	      octave_idx_type i = 0;
 	      octave_idx_type ii = 0;
 	      while (ii < nc && c_lhs.cidx(ii+1) <= i)
 		ii++;
 
 	      octave_idx_type j = 0;
 	      octave_idx_type jj = lhs_idx.elem(j);
@@ -2100,38 +2100,38 @@ assign1 (Sparse<LT>& lhs, const Sparse<R
 	      for (octave_idx_type iidx = ic; iidx < max_idx+1; iidx++)
 		tmp.xcidx(iidx) = kk;
 
 	      lhs = tmp;
 	    }
 	}
       else if (rhs_len == 1)
 	{
-	  octave_idx_type new_nnz = lhs.nnz ();
+	  octave_idx_type new_nzmx = lhs.nzmax ();
 	  RT scalar = rhs.elem (0);
 	  bool scalar_non_zero = (scalar != RT ());
 	  lhs_idx.sort (true);
 
 	  // First count the number of non-zero elements
 	  if (scalar != RT ())
-	    new_nnz += n;
+	    new_nzmx += n;
 	  for (octave_idx_type i = 0; i < n; i++)
 	    {
 	      OCTAVE_QUIT;
 
 	      octave_idx_type ii = lhs_idx.elem (i);
 	      if (ii < lhs_len && c_lhs.elem(ii) != LT ())
-		new_nnz--;
+		new_nzmx--;
 	    }
 
 	  if (nr > 1)
 	    {
-	      Sparse<LT> tmp (max_idx, 1, new_nnz);
+	      Sparse<LT> tmp (max_idx, 1, new_nzmx);
 	      tmp.cidx(0) = 0;
-	      tmp.cidx(1) = tmp.nnz ();
+	      tmp.cidx(1) = tmp.nzmax ();
 
 	      octave_idx_type i = 0;
 	      octave_idx_type ii = 0;
 	      if (i < nz)
 		ii = c_lhs.ridx(i);
 
 	      octave_idx_type j = 0;
 	      octave_idx_type jj = lhs_idx.elem(j);
@@ -2162,17 +2162,17 @@ assign1 (Sparse<LT>& lhs, const Sparse<R
 			jj = lhs_idx.elem(j);
 		    }
 		}
 
 	      lhs = tmp;
 	    }
 	  else
 	    {
-	      Sparse<LT> tmp (1, max_idx, new_nnz);
+	      Sparse<LT> tmp (1, max_idx, new_nzmx);
 
 	      octave_idx_type i = 0;
 	      octave_idx_type ii = 0;
 	      while (ii < nc && c_lhs.cidx(ii+1) <= i)
 		ii++;
 
 	      octave_idx_type j = 0;
 	      octave_idx_type jj = lhs_idx.elem(j);
@@ -2224,18 +2224,18 @@ assign1 (Sparse<LT>& lhs, const Sparse<R
 	  retval = 0;
 	}
     }
   else if (lhs_idx.is_colon ())
     {
       if (lhs_len == 0)
 	{
 
-	  octave_idx_type new_nnz = rhs.nnz ();
-	  Sparse<LT> tmp (1, rhs_len, new_nnz);
+	  octave_idx_type new_nzmx = rhs.nzmax ();
+	  Sparse<LT> tmp (1, rhs_len, new_nzmx);
 
 	  octave_idx_type ii = 0;
 	  octave_idx_type jj = 0;
 	  for (octave_idx_type i = 0; i < rhs.cols(); i++)
 	    for (octave_idx_type j = rhs.cidx(i); j < rhs.cidx(i+1); j++)
 	      {
 		OCTAVE_QUIT;
 		for (octave_idx_type k = jj; k <= i * rhs.rows() + rhs.ridx(j); k++)
@@ -2272,17 +2272,17 @@ int
 assign (Sparse<LT>& lhs, const Sparse<RT>& rhs)
 {
   int retval = 1;
 
   int n_idx = lhs.index_count ();
 
   octave_idx_type lhs_nr = lhs.rows ();
   octave_idx_type lhs_nc = lhs.cols ();
-  octave_idx_type lhs_nz = lhs.nnz ();
+  octave_idx_type lhs_nz = lhs.nzmax ();
 
   octave_idx_type rhs_nr = rhs.rows ();
   octave_idx_type rhs_nc = rhs.cols ();
 
   idx_vector *tmp = lhs.get_idx ();
 
   idx_vector idx_i;
   idx_vector idx_j;
@@ -2340,17 +2340,17 @@ assign (Sparse<LT>& lhs, const Sparse<RT
 			idx_j.max () + 1;
 		      octave_idx_type new_nr = max_row_idx > lhs_nr ? 
 			max_row_idx : lhs_nr;
 		      octave_idx_type new_nc = max_col_idx > lhs_nc ? 
 			max_col_idx : lhs_nc;
 		      RT scalar = rhs.elem (0, 0);
 
 		      // Count the number of non-zero terms
-		      octave_idx_type new_nnz = lhs.nnz ();
+		      octave_idx_type new_nzmx = lhs.nzmax ();
 		      for (octave_idx_type j = 0; j < m; j++)
 			{
 			  octave_idx_type jj = idx_j.elem (j);
 			  if (jj < lhs_nc)
 			    {
 			      for (octave_idx_type i = 0; i < n; i++)
 				{
 				  OCTAVE_QUIT;
@@ -2358,29 +2358,29 @@ assign (Sparse<LT>& lhs, const Sparse<RT
 				  octave_idx_type ii = idx_i.elem (i);
 			      
 				  if (ii < lhs_nr)
 				    {
 				      for (octave_idx_type k = lhs.cidx(jj); 
 					   k < lhs.cidx(jj+1); k++)
 					{
 					  if (lhs.ridx(k) == ii)
-					    new_nnz--;
+					    new_nzmx--;
 					  if (lhs.ridx(k) >= ii)
 					    break;
 					}
 				    }
 				}
 			    }
 			}
 
 		      if (scalar != RT())
-			new_nnz += m * n;
-
-		      Sparse<LT> stmp (new_nr, new_nc, new_nnz);
+			new_nzmx += m * n;
+
+		      Sparse<LT> stmp (new_nr, new_nc, new_nzmx);
 
 		      octave_idx_type jji = 0;
 		      octave_idx_type jj = idx_j.elem (jji);
 		      octave_idx_type kk = 0;
 		      stmp.cidx(0) = 0;
 		      for (octave_idx_type j = 0; j < new_nc; j++)
 			{
 			  if (jji < m && jj == j)
@@ -2521,17 +2521,17 @@ assign (Sparse<LT>& lhs, const Sparse<RT
 
 			  idx_j = idx_vector (new_idx);
 			}
 		      else
 			for (octave_idx_type i = 0; i < m; i++)
 			  rhs_idx_j[i] = i;
 
 		      // Count the number of non-zero terms
-		      octave_idx_type new_nnz = lhs.nnz ();
+		      octave_idx_type new_nzmx = lhs.nzmax ();
 		      for (octave_idx_type j = 0; j < m; j++)
 			{
 			  octave_idx_type jj = idx_j.elem (j);
 			  for (octave_idx_type i = 0; i < n; i++)
 			    {
 			      OCTAVE_QUIT;
 
 			      if (jj < lhs_nc)
@@ -2539,29 +2539,29 @@ assign (Sparse<LT>& lhs, const Sparse<RT
 				  octave_idx_type ii = idx_i.elem (i);
 			      
 				  if (ii < lhs_nr)
 				    {
 				      for (octave_idx_type k = lhs.cidx(jj); 
 					   k < lhs.cidx(jj+1); k++)
 					{
 					  if (lhs.ridx(k) == ii)
-					    new_nnz--;
+					    new_nzmx--;
 					  if (lhs.ridx(k) >= ii)
 					    break;
 					}
 				    }
 				}
 			      
 			      if (rhs.elem(rhs_idx_i[i],rhs_idx_j[j]) != RT ())
-				new_nnz++;
+				new_nzmx++;
 			    }
 			}
 
-		      Sparse<LT> stmp (new_nr, new_nc, new_nnz);
+		      Sparse<LT> stmp (new_nr, new_nc, new_nzmx);
 
 		      octave_idx_type jji = 0;
 		      octave_idx_type jj = idx_j.elem (jji);
 		      octave_idx_type kk = 0;
 		      stmp.cidx(0) = 0;
 		      for (octave_idx_type j = 0; j < new_nc; j++)
 			{
 			  if (jji < m && jj == j)
@@ -2741,17 +2741,17 @@ assign (Sparse<LT>& lhs, const Sparse<RT
 		{
 		  if (! ((rhs_nr == 1 && rhs_nc == 1)
 			 || (rhs_nr == 0 || rhs_nc == 0)))
 		    (*current_liboctave_error_handler)
 		      ("A([]) = X: X must be an empty matrix or scalar");
 		}
 	      else if (len == rhs_nr * rhs_nc)
 		{
-		  octave_idx_type new_nnz = lhs_nz;
+		  octave_idx_type new_nzmx = lhs_nz;
 		  OCTAVE_LOCAL_BUFFER (octave_idx_type, rhs_idx, len);
 		  
 		  if (! idx_i.is_colon ())
 		    {
 		      // Ok here we have to be careful with the indexing, to
 		      // treat cases like "a([3,2,1]) = b", and still handle
 		      // the need for strict sorting of the sparse elements.
 
@@ -2789,22 +2789,22 @@ assign (Sparse<LT>& lhs, const Sparse<RT
 
 		  // First count the number of non-zero elements
 		  for (octave_idx_type i = 0; i < len; i++)
 		    {
 		      OCTAVE_QUIT;
 		      
 		      octave_idx_type ii = idx_i.elem (i);
 		      if (ii < lhs_len && c_lhs.elem(ii) != LT ())
-			new_nnz--;
+			new_nzmx--;
 		      if (rhs.elem(rhs_idx[i]) != RT ())
-			new_nnz++;
+			new_nzmx++;
 		    }
 
-		  Sparse<LT> stmp (lhs_nr, lhs_nc, new_nnz);
+		  Sparse<LT> stmp (lhs_nr, lhs_nc, new_nzmx);
 
 		  octave_idx_type i = 0;
 		  octave_idx_type ii = 0;
 		  octave_idx_type ic = 0;
 		  if (i < lhs_nz)
 		    {
 		      while (ic < lhs_nc && i >= c_lhs.cidx(ic+1))
 			ic++;
@@ -2864,31 +2864,31 @@ assign (Sparse<LT>& lhs, const Sparse<RT
 		  for (octave_idx_type iidx = kc; iidx < lhs_nc+1; iidx++)
 		    stmp.xcidx(iidx) = kk; 
 
 		  lhs = stmp;
 		}
 	      else if (rhs_nr == 1 && rhs_nc == 1)
 		{
 		  RT scalar = rhs.elem (0, 0);
-		  octave_idx_type new_nnz = lhs_nz;
+		  octave_idx_type new_nzmx = lhs_nz;
 		  idx_i.sort (true);
 
 		  // First count the number of non-zero elements
 		  if (scalar != RT ())
-		    new_nnz += len;
+		    new_nzmx += len;
 		  for (octave_idx_type i = 0; i < len; i++)
 		    {
 		      OCTAVE_QUIT;
 		      octave_idx_type ii = idx_i.elem (i);
 		      if (ii < lhs_len && c_lhs.elem(ii) != LT ())
-			new_nnz--;
+			new_nzmx--;
 		    }
 
-		  Sparse<LT> stmp (lhs_nr, lhs_nc, new_nnz);
+		  Sparse<LT> stmp (lhs_nr, lhs_nc, new_nzmx);
 
 		  octave_idx_type i = 0;
 		  octave_idx_type ii = 0;
 		  octave_idx_type ic = 0;
 		  if (i < lhs_nz)
 		    {
 		      while (ic < lhs_nc && i >= c_lhs.cidx(ic+1))
 			ic++;
@@ -2973,17 +2973,17 @@ assign (Sparse<LT>& lhs, const Sparse<RT
   return retval;
 }
 
 template <class T>
 void
 Sparse<T>::print_info (std::ostream& os, const std::string& prefix) const
 {
   os << prefix << "rep address: " << rep << "\n"
-     << prefix << "rep->nnz:    " << rep->nnz << "\n"
+     << prefix << "rep->nzmx:   " << rep->nzmx  << "\n"
      << prefix << "rep->nrows:  " << rep->nrows << "\n"
      << prefix << "rep->ncols:  " << rep->ncols << "\n"
      << prefix << "rep->data:   " << static_cast<void *> (rep->d) << "\n"
      << prefix << "rep->ridx:   " << static_cast<void *> (rep->r) << "\n"
      << prefix << "rep->cidx:   " << static_cast<void *> (rep->c) << "\n"
      << prefix << "rep->count:  " << rep->count << "\n";
 }
 
diff --git a/liboctave/Sparse.h b/liboctave/Sparse.h
--- a/liboctave/Sparse.h
+++ b/liboctave/Sparse.h
@@ -50,64 +50,64 @@ protected:
 
   class SparseRep
   {
   public:
 
     T *d;
     octave_idx_type *r;
     octave_idx_type *c;
-    octave_idx_type nnz;
+    octave_idx_type nzmx;
     octave_idx_type nrows;
     octave_idx_type ncols;
     int count;
 
-    SparseRep (void) : d (0), r (0), c (new octave_idx_type [1]), nnz (0), nrows (0),
+    SparseRep (void) : d (0), r (0), c (new octave_idx_type [1]), nzmx (0), nrows (0),
 		       ncols (0), count (1) { c[0] = 0; }
 
-    SparseRep (octave_idx_type n) : d (0), r (0), c (new octave_idx_type [n+1]), nnz (0), nrows (n),
+    SparseRep (octave_idx_type n) : d (0), r (0), c (new octave_idx_type [n+1]), nzmx (0), nrows (n),
       ncols (n), count (1)
       { 
 	for (octave_idx_type i = 0; i < n + 1; i++)
 	  c[i] = 0;
       }
 
-    SparseRep (octave_idx_type nr, octave_idx_type nc) : d (0), r (0), c (new octave_idx_type [nc+1]), nnz (0), 
+    SparseRep (octave_idx_type nr, octave_idx_type nc) : d (0), r (0), c (new octave_idx_type [nc+1]), nzmx (0), 
       nrows (nr), ncols (nc), count (1)
       { 
 	for (octave_idx_type i = 0; i < nc + 1; i++)
 	  c[i] = 0;
       }
 
     SparseRep (octave_idx_type nr, octave_idx_type nc, octave_idx_type nz) : d (new T [nz]), 
-      r (new octave_idx_type [nz]), c (new octave_idx_type [nc+1]), nnz (nz), nrows (nr), 
+      r (new octave_idx_type [nz]), c (new octave_idx_type [nc+1]), nzmx (nz), nrows (nr), 
       ncols (nc), count (1)
       { 
 	for (octave_idx_type i = 0; i < nc + 1; i++)
 	  c[i] = 0;
       }
 
     SparseRep (const SparseRep& a)
-      : d (new T [a.nnz]), r (new octave_idx_type [a.nnz]), c (new octave_idx_type [a.ncols + 1]), 
-      nnz (a.nnz), nrows (a.nrows), ncols (a.ncols), count (1)
+      : d (new T [a.nzmx]), r (new octave_idx_type [a.nzmx]), c (new octave_idx_type [a.ncols + 1]), 
+      nzmx (a.nzmx), nrows (a.nrows), ncols (a.ncols), count (1)
       {
-	for (octave_idx_type i = 0; i < nnz; i++)
+	for (octave_idx_type i = 0; i < nzmx; i++)
 	  {
 	    d[i] = a.d[i];
 	    r[i] = a.r[i];
 	  }
 	for (octave_idx_type i = 0; i < ncols + 1; i++)
 	  c[i] = a.c[i];
       }
  
     ~SparseRep (void) { delete [] d; delete [] r; delete [] c; }
 
-    octave_idx_type length (void) const { return nnz; }
+    octave_idx_type length (void) const { return nzmx; }
 
-    octave_idx_type nonzero (void) const { return c [ncols]; }
+    octave_idx_type nnz (void) const { return c [ncols]; }
 
     T& elem (octave_idx_type _r, octave_idx_type _c);
 
     T celem (octave_idx_type _r, octave_idx_type _c) const;
 
     T& data (octave_idx_type i) { return d[i]; }
 
     T cdata (octave_idx_type i) const { return d[i]; }
@@ -233,21 +233,22 @@ public:
 	}
 
       idx_count = 0;
       idx = 0;
 
       return *this;
     }
 
-  // Note that capacity and nnz are the amount of storage for non-zero
-  // elements, while nonzero is the actual number of non-zero terms
-  octave_idx_type capacity (void) const { return rep->length (); }
-  octave_idx_type nnz (void) const { return capacity (); }
-  octave_idx_type nonzero (void) const { return rep->nonzero (); }
+  // Note that nzmax and capacity are the amount of storage for
+  // non-zero elements, while nnz is the actual number of non-zero
+  // terms.
+  octave_idx_type nzmax (void) const { return rep->length (); }
+  octave_idx_type capacity (void) const { return nzmax (); }
+  octave_idx_type nnz (void) const { return rep->nnz (); }
 
   // Paranoid number of elements test for case of dims = (-1,-1)
   octave_idx_type numel (void) const 
     { 
       if (dim1() < 0 || dim2() < 0)
         return 0;
       else
         return dimensions.numel (); 
diff --git a/liboctave/SparseType.cc b/liboctave/SparseType.cc
--- a/liboctave/SparseType.cc
+++ b/liboctave/SparseType.cc
@@ -50,17 +50,17 @@ SparseType::SparseType (const SparseType
 	perm[i] = a.perm[i];
     }
 }
 
 SparseType::SparseType (const SparseMatrix &a)
 {
   octave_idx_type nrows = a.rows ();
   octave_idx_type ncols = a.cols ();
-  octave_idx_type nnz = a.nnz ();
+  octave_idx_type nnz = a.nzmax ();
 
   if (Voctave_sparse_controls.get_key ("spumoni") != 0.)
     (*current_liboctave_warning_handler) 
       ("Calculating Sparse Matrix Type");
 
   nperm = 0;
 
   if (nrows != ncols)
@@ -321,17 +321,17 @@ SparseType::SparseType (const SparseMatr
 	}
     }
 }
 
 SparseType::SparseType (const SparseComplexMatrix &a)
 {
   octave_idx_type nrows = a.rows ();
   octave_idx_type ncols = a.cols ();
-  octave_idx_type nnz = a.nnz ();
+  octave_idx_type nnz = a.nzmax ();
 
   if (Voctave_sparse_controls.get_key ("spumoni") != 0.)
     (*current_liboctave_warning_handler) 
       ("Calculating Sparse Matrix Type");
 
   nperm = 0;
 
   if (nrows != ncols)
diff --git a/liboctave/boolSparse.cc b/liboctave/boolSparse.cc
--- a/liboctave/boolSparse.cc
+++ b/liboctave/boolSparse.cc
@@ -36,20 +36,20 @@ Boston, MA 02110-1301, USA.
 
 // SparseBoolMatrix class.
 
 bool
 SparseBoolMatrix::operator == (const SparseBoolMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-  octave_idx_type nz = nnz ();
+  octave_idx_type nz = nzmax ();
   octave_idx_type nr_a = a.rows ();
   octave_idx_type nc_a = a.cols ();
-  octave_idx_type nz_a = a.nnz ();
+  octave_idx_type nz_a = a.nzmax ();
 
   if (nr != nr_a || nc != nc_a || nz != nz_a)
     return false;
 
   for (octave_idx_type i = 0; i < nc + 1; i++)
     if (cidx(i) != a.cidx(i))
 	return false;
 
@@ -84,17 +84,17 @@ SparseBoolMatrix::concat (const SparseBo
 
 // unary operations
 
 SparseBoolMatrix
 SparseBoolMatrix::operator ! (void) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-  octave_idx_type nz1 = nnz ();
+  octave_idx_type nz1 = nzmax ();
   octave_idx_type nz2 = nr*nc - nz1;
    
   SparseBoolMatrix r (nr, nc, nz2);
    
   octave_idx_type ii = 0;
   octave_idx_type jj = 0;
   for (octave_idx_type i = 0; i < nc; i++)
     {
@@ -162,17 +162,17 @@ operator << (std::ostream& os, const Spa
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, SparseBoolMatrix& a)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
-  octave_idx_type nz = a.nnz ();
+  octave_idx_type nz = a.nzmax ();
 
   if (nr < 1 || nc < 1)
     is.clear (std::ios::badbit);
   else
     {
       octave_idx_type itmp, jtmp, jold = 0;
       bool tmp;
       octave_idx_type ii = 0;
diff --git a/liboctave/dSparse.cc b/liboctave/dSparse.cc
--- a/liboctave/dSparse.cc
+++ b/liboctave/dSparse.cc
@@ -109,40 +109,40 @@ extern "C"
 
   F77_RET_T
   F77_FUNC (zgtsv, ZGTSV) (const octave_idx_type&, const octave_idx_type&, Complex*, Complex*,
 			   Complex*, Complex*, const octave_idx_type&, octave_idx_type&);
 
 }
 
 SparseMatrix::SparseMatrix (const SparseBoolMatrix &a)
-  : MSparse<double> (a.rows (), a.cols (), a.nnz ())
+  : MSparse<double> (a.rows (), a.cols (), a.nzmax ())
 {
   octave_idx_type nc = cols ();
-  octave_idx_type nz = nnz ();
+  octave_idx_type nz = nzmax ();
 
   for (octave_idx_type i = 0; i < nc + 1; i++)
     cidx (i) = a.cidx (i);
 
   for (octave_idx_type i = 0; i < nz; i++)
     {
       data (i) = a.data (i);
       ridx (i) = a.ridx (i);
     }
 }
 
 bool
 SparseMatrix::operator == (const SparseMatrix& a) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-  octave_idx_type nz = nnz ();
+  octave_idx_type nz = nzmax ();
   octave_idx_type nr_a = a.rows ();
   octave_idx_type nc_a = a.cols ();
-  octave_idx_type nz_a = a.nnz ();
+  octave_idx_type nz_a = a.nzmax ();
 
   if (nr != nr_a || nc != nc_a || nz != nz_a)
     return false;
 
   for (octave_idx_type i = 0; i < nc + 1; i++)
     if (cidx(i) != a.cidx(i))
 	return false;
 
@@ -492,17 +492,17 @@ SparseMatrix::concat (const SparseComple
   return retval;
 }
 
 SparseMatrix
 real (const SparseComplexMatrix& a)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
-  octave_idx_type nz = a.nnz ();
+  octave_idx_type nz = a.nzmax ();
   SparseMatrix r (nr, nc, nz);
 
   for (octave_idx_type i = 0; i < nc +1; i++)
     r.cidx(i) = a.cidx(i);
 
   for (octave_idx_type i = 0; i < nz; i++)
     {
       r.data(i) = std::real (a.data(i));
@@ -512,17 +512,17 @@ real (const SparseComplexMatrix& a)
   return r;
 }
 
 SparseMatrix
 imag (const SparseComplexMatrix& a)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
-  octave_idx_type nz = a.nnz ();
+  octave_idx_type nz = a.nzmax ();
   SparseMatrix r (nr, nc, nz);
 
   for (octave_idx_type i = 0; i < nc +1; i++)
     r.cidx(i) = a.cidx(i);
 
   for (octave_idx_type i = 0; i < nz; i++)
     {
       r.data(i) = std::imag (a.data(i));
@@ -554,17 +554,17 @@ atan2 (const double& x, const SparseMatr
     }
 }
 
 SparseMatrix 
 atan2 (const SparseMatrix& x, const double& y)
 {
   octave_idx_type nr = x.rows ();
   octave_idx_type nc = x.cols ();
-  octave_idx_type nz = x.nnz ();
+  octave_idx_type nz = x.nzmax ();
 
   SparseMatrix retval (nr, nc, nz);
 
   octave_idx_type ii = 0;
   retval.xcidx(0) = 0;
   for (octave_idx_type i = 0; i < nc; i++)
     {
       for (octave_idx_type j = x.cidx(i); j < x.cidx(i+1); j++)
@@ -607,17 +607,17 @@ atan2 (const SparseMatrix& x, const Spar
 
       octave_idx_type y_nr = y.rows ();
       octave_idx_type y_nc = y.cols ();
 
       if (x_nr != y_nr || x_nc != y_nc)
 	gripe_nonconformant ("atan2", x_nr, x_nc, y_nr, y_nc);
       else
 	{
-	  r = SparseMatrix (x_nr, x_nc, (x.nnz () + y.nnz ()));
+	  r = SparseMatrix (x_nr, x_nc, (x.nzmax () + y.nzmax ()));
        
 	  octave_idx_type jx = 0;
 	  r.cidx (0) = 0;
 	  for (octave_idx_type i = 0 ; i < x_nc ; i++)
 	    {
 	      octave_idx_type  ja = x.cidx(i);
 	      octave_idx_type  ja_max = x.cidx(i+1);
 	      bool ja_lt_max= ja < ja_max;
@@ -784,17 +784,17 @@ SparseMatrix::tinverse (SparseType &matt
 		    atmp += fabs(data(i));
 		  if (atmp > anorm)
 		    anorm = atmp;
 		}
 	    }
 
 	  if (typ == SparseType::Upper || typ == SparseType::Lower)
 	    {
-	      octave_idx_type nz = nnz();
+	      octave_idx_type nz = nzmax ();
 	      octave_idx_type cx = 0;
 	      octave_idx_type nz2 = nz;
 	      retval = SparseMatrix (nr, nc, nz2);
 
 	      for (octave_idx_type i = 0; i < nr; i++)
 		{
 		  OCTAVE_QUIT;
 		  // place the 1 in the identity position
@@ -869,17 +869,17 @@ SparseMatrix::tinverse (SparseType &matt
 		    for (octave_idx_type j = cx_colstart; j < cx; j++)
 		      retval.xdata(j) /= pivot;
 		}
 	      retval.xcidx(nr) = cx;
 	      retval.maybe_compress ();
 	    }
 	  else
 	    {
-	      octave_idx_type nz = nnz();
+	      octave_idx_type nz = nzmax ();
 	      octave_idx_type cx = 0;
 	      octave_idx_type nz2 = nz;
 	      retval = SparseMatrix (nr, nc, nz2);
 
 	      OCTAVE_LOCAL_BUFFER (double, work, nr);
 	      OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nr);
 
 	      octave_idx_type *perm = mattyp.triangular_perm();
@@ -1254,17 +1254,17 @@ SparseMatrix::dsolve (SparseType &mattyp
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Diagonal ||
 	  typ == SparseType::Permuted_Diagonal)
 	{
 	  octave_idx_type b_nr = b.rows ();
 	  octave_idx_type b_nc = b.cols ();
-	  octave_idx_type b_nz = b.nnz ();
+	  octave_idx_type b_nz = b.nzmax ();
 	  retval = SparseMatrix (b_nr, b_nc, b_nz);
 
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  if (typ == SparseType::Diagonal)
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      {
 		for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
@@ -1384,17 +1384,17 @@ SparseMatrix::dsolve (SparseType &mattyp
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Diagonal ||
 	  typ == SparseType::Permuted_Diagonal)
 	{
 	  octave_idx_type b_nr = b.rows ();
 	  octave_idx_type b_nc = b.cols ();
-	  octave_idx_type b_nz = b.nnz ();
+	  octave_idx_type b_nz = b.nzmax ();
 	  retval = SparseComplexMatrix (b_nr, b_nc, b_nz);
 
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  if (typ == SparseType::Diagonal)
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      {
 		for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
@@ -1684,17 +1684,17 @@ SparseMatrix::utsolve (SparseType &matty
 	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += fabs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
 	  octave_idx_type b_nr = b.rows ();
 	  octave_idx_type b_nc = b.cols ();
-	  octave_idx_type b_nz = b.nnz ();
+	  octave_idx_type b_nz = b.nzmax ();
 	  retval = SparseMatrix (b_nr, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Upper)
 	    {
 	      octave_idx_type *perm = mattype.triangular_perm ();
@@ -2156,17 +2156,17 @@ SparseMatrix::utsolve (SparseType &matty
 	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += fabs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
 	  octave_idx_type b_nr = b.rows ();
 	  octave_idx_type b_nc = b.cols ();
-	  octave_idx_type b_nz = b.nnz ();
+	  octave_idx_type b_nz = b.nzmax ();
 	  retval = SparseComplexMatrix (b_nr, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Upper)
 	    {
 	      octave_idx_type *perm = mattype.triangular_perm ();
@@ -2654,17 +2654,17 @@ SparseMatrix::ltsolve (SparseType &matty
 	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += fabs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
 	  octave_idx_type b_nr = b.rows ();
 	  octave_idx_type b_nc = b.cols ();
-	  octave_idx_type b_nz = b.nnz ();
+	  octave_idx_type b_nz = b.nzmax ();
 	  retval = SparseMatrix (b_nr, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Lower)
 	    {
 	      OCTAVE_LOCAL_BUFFER (double, work, nr);
@@ -3171,17 +3171,17 @@ SparseMatrix::ltsolve (SparseType &matty
 	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += fabs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
 	  octave_idx_type b_nr = b.rows ();
 	  octave_idx_type b_nc = b.cols ();
-	  octave_idx_type b_nz = b.nnz ();
+	  octave_idx_type b_nz = b.nzmax ();
 	  retval = SparseComplexMatrix (b_nr, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Lower)
 	    {
 	      OCTAVE_LOCAL_BUFFER (Complex, cwork, nr);
@@ -3654,17 +3654,17 @@ SparseMatrix::trisolve (SparseType &matt
 		  else
 		    (*current_liboctave_error_handler)
 		      ("matrix singular to machine precision");
 
 		} 
 	      else 
 		{
 		  char job = 'N';
-		  volatile octave_idx_type x_nz = b.nnz ();
+		  volatile octave_idx_type x_nz = b.nzmax ();
 		  octave_idx_type b_nc = b.cols ();
 		  retval = SparseMatrix (nr, b_nc, x_nz);
 		  retval.xcidx(0) = 0;
 		  volatile octave_idx_type ii = 0;
 
 		  OCTAVE_LOCAL_BUFFER (double, work, nr);
 
 		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
@@ -3965,17 +3965,17 @@ SparseMatrix::trisolve (SparseType &matt
 		  char job = 'N';
 		  octave_idx_type b_nr = b.rows ();
 		  octave_idx_type b_nc = b.cols ();
 		  OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
 		  OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
 
 		  // Take a first guess that the number of non-zero terms
 		  // will be as many as in b
-		  volatile octave_idx_type x_nz = b.nnz ();
+		  volatile octave_idx_type x_nz = b.nzmax ();
 		  volatile octave_idx_type ii = 0;
 		  retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
 		  retval.xcidx(0) = 0;
 		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
 		    {
 
 		      for (octave_idx_type i = 0; i < b_nr; i++)
@@ -4379,17 +4379,17 @@ SparseMatrix::bsolve (SparseType &mattyp
 		{
 		  rcond = 1.;
 		  octave_idx_type b_nr = b.rows ();
 		  octave_idx_type b_nc = b.cols ();
 		  OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
 
 		  // Take a first guess that the number of non-zero terms
 		  // will be as many as in b
-		  volatile octave_idx_type x_nz = b.nnz ();
+		  volatile octave_idx_type x_nz = b.nzmax ();
 		  volatile octave_idx_type ii = 0;
 		  retval = SparseMatrix (b_nr, b_nc, x_nz);
 
 		  retval.xcidx(0) = 0;
 		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
 		    {
 		      for (octave_idx_type i = 0; i < b_nr; i++)
 			Bx[i] = b.elem (i, j);
@@ -4485,17 +4485,17 @@ SparseMatrix::bsolve (SparseType &mattyp
 		  else
 		    (*current_liboctave_error_handler)
 		      ("matrix singular to machine precision");
 
 		} 
 	      else 
 		{
 		  char job = 'N';
-		  volatile octave_idx_type x_nz = b.nnz ();
+		  volatile octave_idx_type x_nz = b.nzmax ();
 		  octave_idx_type b_nc = b.cols ();
 		  retval = SparseMatrix (nr, b_nc, x_nz);
 		  retval.xcidx(0) = 0;
 		  volatile octave_idx_type ii = 0;
 
 		  OCTAVE_LOCAL_BUFFER (double, work, nr);
 
 		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
@@ -4860,17 +4860,17 @@ SparseMatrix::bsolve (SparseType &mattyp
 		  rcond = 1.;
 		  octave_idx_type b_nr = b.rows ();
 		  octave_idx_type b_nc = b.cols ();
 		  OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
 		  OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
 
 		  // Take a first guess that the number of non-zero terms
 		  // will be as many as in b
-		  volatile octave_idx_type x_nz = b.nnz ();
+		  volatile octave_idx_type x_nz = b.nzmax ();
 		  volatile octave_idx_type ii = 0;
 		  retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
 		  retval.xcidx(0) = 0;
 		  for (volatile octave_idx_type j = 0; j < b_nc; j++)
 		    {
 
 		      for (octave_idx_type i = 0; i < b_nr; i++)
@@ -5000,17 +5000,17 @@ SparseMatrix::bsolve (SparseType &mattyp
 		  else
 		    (*current_liboctave_error_handler)
 		      ("matrix singular to machine precision");
 
 		} 
 	      else 
 		{
 		  char job = 'N';
-		  volatile octave_idx_type x_nz = b.nnz ();
+		  volatile octave_idx_type x_nz = b.nzmax ();
 		  octave_idx_type b_nc = b.cols ();
 		  retval = SparseComplexMatrix (nr, b_nc, x_nz);
 		  retval.xcidx(0) = 0;
 		  volatile octave_idx_type ii = 0;
 
 		  OCTAVE_LOCAL_BUFFER (double, Bx, nr);
 		  OCTAVE_LOCAL_BUFFER (double, Bz, nr);
 
@@ -5272,17 +5272,17 @@ SparseMatrix::fsolve (SparseType &mattyp
 	  cholmod_sparse Astore;
 	  cholmod_sparse *A = &Astore;
 	  double dummy;
 	  A->nrow = nr;
 	  A->ncol = nc;
 
 	  A->p = cidx();
 	  A->i = ridx();
-	  A->nzmax = nonzero();
+	  A->nzmax = nnz();
 	  A->packed = true;
 	  A->sorted = true;
 	  A->nz = NULL;
 #ifdef IDX_TYPE_LONG
 	  A->itype = CHOLMOD_LONG;
 #else
 	  A->itype = CHOLMOD_INT;
 #endif
@@ -5514,17 +5514,17 @@ SparseMatrix::fsolve (SparseType &mattyp
 	  cholmod_sparse Astore;
 	  cholmod_sparse *A = &Astore;
 	  double dummy;
 	  A->nrow = nr;
 	  A->ncol = nc;
 
 	  A->p = cidx();
 	  A->i = ridx();
-	  A->nzmax = nonzero();
+	  A->nzmax = nnz();
 	  A->packed = true;
 	  A->sorted = true;
 	  A->nz = NULL;
 #ifdef IDX_TYPE_LONG
 	  A->itype = CHOLMOD_LONG;
 #else
 	  A->itype = CHOLMOD_INT;
 #endif
@@ -5538,17 +5538,17 @@ SparseMatrix::fsolve (SparseType &mattyp
 	    A->x = data();
 
 	  cholmod_sparse Bstore;
 	  cholmod_sparse *B = &Bstore;
 	  B->nrow = b.rows();
 	  B->ncol = b.cols();
 	  B->p = b.cidx();
 	  B->i = b.ridx();
-	  B->nzmax = b.nonzero();
+	  B->nzmax = b.nnz();
 	  B->packed = true;
 	  B->sorted = true;
 	  B->nz = NULL;
 #ifdef IDX_TYPE_LONG
 	  B->itype = CHOLMOD_LONG;
 #else
 	  B->itype = CHOLMOD_INT;
 #endif
@@ -5646,17 +5646,17 @@ SparseMatrix::fsolve (SparseType &mattyp
 	      const octave_idx_type *Ai = ridx ();
 	      const double *Ax = data ();
 
 	      OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
 	      OCTAVE_LOCAL_BUFFER (double, Xx, b_nr);
 
 	      // Take a first guess that the number of non-zero terms
 	      // will be as many as in b
-	      octave_idx_type x_nz = b.nnz ();
+	      octave_idx_type x_nz = b.nzmax ();
 	      octave_idx_type ii = 0;
 	      retval = SparseMatrix (b_nr, b_nc, x_nz);
 
 	      retval.xcidx(0) = 0;
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 
 		  for (octave_idx_type i = 0; i < b_nr; i++)
@@ -5803,17 +5803,17 @@ SparseMatrix::fsolve (SparseType &mattyp
 	  cholmod_sparse Astore;
 	  cholmod_sparse *A = &Astore;
 	  double dummy;
 	  A->nrow = nr;
 	  A->ncol = nc;
 
 	  A->p = cidx();
 	  A->i = ridx();
-	  A->nzmax = nonzero();
+	  A->nzmax = nnz();
 	  A->packed = true;
 	  A->sorted = true;
 	  A->nz = NULL;
 #ifdef IDX_TYPE_LONG
 	  A->itype = CHOLMOD_LONG;
 #else
 	  A->itype = CHOLMOD_INT;
 #endif
@@ -6065,17 +6065,17 @@ SparseMatrix::fsolve (SparseType &mattyp
 	  cholmod_sparse Astore;
 	  cholmod_sparse *A = &Astore;
 	  double dummy;
 	  A->nrow = nr;
 	  A->ncol = nc;
 
 	  A->p = cidx();
 	  A->i = ridx();
-	  A->nzmax = nonzero();
+	  A->nzmax = nnz();
 	  A->packed = true;
 	  A->sorted = true;
 	  A->nz = NULL;
 #ifdef IDX_TYPE_LONG
 	  A->itype = CHOLMOD_LONG;
 #else
 	  A->itype = CHOLMOD_INT;
 #endif
@@ -6089,17 +6089,17 @@ SparseMatrix::fsolve (SparseType &mattyp
 	    A->x = data();
 
 	  cholmod_sparse Bstore;
 	  cholmod_sparse *B = &Bstore;
 	  B->nrow = b.rows();
 	  B->ncol = b.cols();
 	  B->p = b.cidx();
 	  B->i = b.ridx();
-	  B->nzmax = b.nonzero();
+	  B->nzmax = b.nnz();
 	  B->packed = true;
 	  B->sorted = true;
 	  B->nz = NULL;
 #ifdef IDX_TYPE_LONG
 	  B->itype = CHOLMOD_LONG;
 #else
 	  B->itype = CHOLMOD_INT;
 #endif
@@ -6198,17 +6198,17 @@ SparseMatrix::fsolve (SparseType &mattyp
 	      const octave_idx_type *Ai = ridx ();
 	      const double *Ax = data ();
 
 	      OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
 	      OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
 
 	      // Take a first guess that the number of non-zero terms
 	      // will be as many as in b
-	      octave_idx_type x_nz = b.nnz ();
+	      octave_idx_type x_nz = b.nzmax ();
 	      octave_idx_type ii = 0;
 	      retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
 	      OCTAVE_LOCAL_BUFFER (double, Xx, b_nr);
 	      OCTAVE_LOCAL_BUFFER (double, Xz, b_nr);
 	      
 	      retval.xcidx(0) = 0;
 	      for (octave_idx_type j = 0; j < b_nc; j++)
@@ -6889,17 +6889,17 @@ SparseMatrix::lssolve (const ComplexColu
 
 // other operations.
 
 SparseMatrix
 SparseMatrix::map (d_d_Mapper f) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-  octave_idx_type nz = nnz ();
+  octave_idx_type nz = nzmax ();
   bool f_zero = (f(0.0) == 0.0);
 
   // Count number of non-zero elements
   octave_idx_type nel = (f_zero ? 0 : nr*nc - nz);
   for (octave_idx_type i = 0; i < nz; i++)
     if (f (data(i)) != 0.0)
       nel++;
 
@@ -6939,17 +6939,17 @@ SparseMatrix::map (d_d_Mapper f) const
   return retval;
 }
 
 SparseBoolMatrix
 SparseMatrix::map (b_d_Mapper f) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-  octave_idx_type nz = nnz ();
+  octave_idx_type nz = nzmax ();
   bool f_zero = f(0.0);
 
   // Count number of non-zero elements
   octave_idx_type nel = (f_zero ? 0 : nr*nc - nz);
   for (octave_idx_type i = 0; i < nz; i++)
     if (f (data(i)) != 0.0)
       nel++;
 
@@ -6994,17 +6994,17 @@ SparseMatrix::apply (d_d_Mapper f)
 {
   *this = map (f);
   return *this;
 }
 
 bool
 SparseMatrix::any_element_is_negative (bool neg_zero) const
 {
-  octave_idx_type nel = nnz ();
+  octave_idx_type nel = nzmax ();
 
   if (neg_zero)
     {
       for (octave_idx_type i = 0; i < nel; i++)
 	if (lo_ieee_signbit (data (i)))
 	  return true;
     }
   else
@@ -7015,32 +7015,32 @@ SparseMatrix::any_element_is_negative (b
     }
 
   return false;
 }
 
 bool
 SparseMatrix::any_element_is_inf_or_nan (void) const
 {
-  octave_idx_type nel = nnz ();
+  octave_idx_type nel = nzmax ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = data (i);
       if (xisinf (val) || xisnan (val))
 	return true;
     }
 
   return false;
 }
 
 bool
 SparseMatrix::all_elements_are_int_or_inf_or_nan (void) const
 {
-  octave_idx_type nel = nnz ();
+  octave_idx_type nel = nzmax ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = data (i);
       if (xisnan (val) || D_NINT (val) == val)
 	continue;
       else
 	return false;
@@ -7050,17 +7050,17 @@ SparseMatrix::all_elements_are_int_or_in
 }
 
 // Return nonzero if any element of M is not an integer.  Also extract
 // the largest and smallest values and return them in MAX_VAL and MIN_VAL.
 
 bool
 SparseMatrix::all_integers (double& max_val, double& min_val) const
 {
-  octave_idx_type nel = nnz ();
+  octave_idx_type nel = nzmax ();
 
   if (nel == 0)
     return false;
 
   max_val = data (0);
   min_val = data (0);
 
   for (octave_idx_type i = 0; i < nel; i++)
@@ -7078,17 +7078,17 @@ SparseMatrix::all_integers (double& max_
     }
 
   return true;
 }
 
 bool
 SparseMatrix::too_large_for_float (void) const
 {
-  octave_idx_type nel = nnz ();
+  octave_idx_type nel = nzmax ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       double val = data (i);
 
       if (val > FLT_MAX || val < FLT_MIN)
 	return true;
     }
@@ -7096,17 +7096,17 @@ SparseMatrix::too_large_for_float (void)
   return false;
 }
 
 SparseBoolMatrix 
 SparseMatrix::operator ! (void) const 
 { 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
-  octave_idx_type nz1 = nnz ();
+  octave_idx_type nz1 = nzmax ();
   octave_idx_type nz2 = nr*nc - nz1;
    
   SparseBoolMatrix r (nr, nc, nz2);
    
   octave_idx_type ii = 0;
   octave_idx_type jj = 0;
   r.cidx (0) = 0;
   for (octave_idx_type i = 0; i < nc; i++)
@@ -7182,17 +7182,17 @@ SparseMatrix::sumsq (int dim) const
 
 #undef ROW_EXPR
 #undef COL_EXPR
 }
 
 SparseMatrix
 SparseMatrix::abs (void) const
 {
-  octave_idx_type nz = nnz ();
+  octave_idx_type nz = nzmax ();
 
   SparseMatrix retval (*this);
 
   for (octave_idx_type i = 0; i < nz; i++)
     retval.data(i) = fabs(retval.data(i));
 
   return retval;
 }
@@ -7317,17 +7317,17 @@ operator << (std::ostream& os, const Spa
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, SparseMatrix& a)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
-  octave_idx_type nz = a.nnz ();
+  octave_idx_type nz = a.nzmax ();
 
   if (nr < 1 || nc < 1)
     is.clear (std::ios::badbit);
   else
     {
       octave_idx_type itmp, jtmp, jold = 0;
       double tmp;
       octave_idx_type ii = 0;
@@ -7523,17 +7523,17 @@ min (const SparseMatrix& a, const Sparse
 
       octave_idx_type b_nr = b.rows ();
       octave_idx_type b_nc = b.cols ();
 
       if (a_nr != b_nr || a_nc != b_nc)
 	gripe_nonconformant ("min", a_nr, a_nc, b_nr, b_nc);
       else
 	{
-	  r = SparseMatrix (a_nr, a_nc, (a.nnz () + b.nnz ()));
+	  r = SparseMatrix (a_nr, a_nc, (a.nzmax () + b.nzmax ()));
        
 	  octave_idx_type jx = 0;
 	  r.cidx (0) = 0;
 	  for (octave_idx_type i = 0 ; i < a_nc ; i++)
 	    {
 	      octave_idx_type  ja = a.cidx(i);
 	      octave_idx_type  ja_max = a.cidx(i+1);
 	      bool ja_lt_max= ja < ja_max;
@@ -7673,17 +7673,17 @@ max (const SparseMatrix& a, const Sparse
 
       octave_idx_type b_nr = b.rows ();
       octave_idx_type b_nc = b.cols ();
 
       if (a_nr != b_nr || a_nc != b_nc)
 	gripe_nonconformant ("min", a_nr, a_nc, b_nr, b_nc);
       else
 	{
-	  r = SparseMatrix (a_nr, a_nc, (a.nnz () + b.nnz ()));
+	  r = SparseMatrix (a_nr, a_nc, (a.nzmax () + b.nzmax ()));
        
 	  octave_idx_type jx = 0;
 	  r.cidx (0) = 0;
 	  for (octave_idx_type i = 0 ; i < a_nc ; i++)
 	    {
 	      octave_idx_type  ja = a.cidx(i);
 	      octave_idx_type  ja_max = a.cidx(i+1);
 	      bool ja_lt_max= ja < ja_max;
diff --git a/liboctave/sparse-base-chol.cc b/liboctave/sparse-base-chol.cc
--- a/liboctave/sparse-base-chol.cc
+++ b/liboctave/sparse-base-chol.cc
@@ -145,17 +145,17 @@ sparse_base_chol<chol_type, chol_elt, p_
   cholmod_sparse A;
   cholmod_sparse *ac = &A;
   double dummy;
   ac->nrow = a_nr;
   ac->ncol = a_nc;
 
   ac->p = a.cidx();
   ac->i = a.ridx();
-  ac->nzmax = a.nonzero();
+  ac->nzmax = a.nnz();
   ac->packed = true;
   ac->sorted = true;
   ac->nz = 0;
 #ifdef IDX_TYPE_LONG
   ac->itype = CHOLMOD_LONG;
 #else
   ac->itype = CHOLMOD_INT;
 #endif
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,17 @@
+2006-01-31  John W. Eaton  <jwe@octave.org>
+
+	* ov-base-sparse.h (octave_base_sparse<T>::nzmax): New function.
+	* ov.h (octave_value::nzmax): New function.
+	* ov-base.cc (octave_base_value::nzmax): New function.
+	* ov-base.h: Provide decl.
+	* data.cc (Fnzmax): New function.
+	* DLD-FUNCTIONS/sparse.cc (Fnzmax): Delete.
+
 2006-01-31  Kim Hansen  <kim@i9.dk>
 
 	* __glpk__.cc (F_glpk__): Fix for sparse matrices.
 
 2006-01-30  John W. Eaton  <jwe@octave.org>
 
 	* gripes.cc (gripe_wrong_type_arg (const char*, const char*, bool)):
 	New function.
diff --git a/src/DLD-FUNCTIONS/__glpk__.cc b/src/DLD-FUNCTIONS/__glpk__.cc
--- a/src/DLD-FUNCTIONS/__glpk__.cc
+++ b/src/DLD-FUNCTIONS/__glpk__.cc
@@ -487,17 +487,17 @@ You should be using using the @code{glpk
       if (error_state)
 	{
 	  error ("__glpk__: invalid value of A");
 	  return retval;
 	}
 
       mrowsA = A.rows ();
       octave_idx_type Anc = A.cols ();
-      octave_idx_type Anz = A.nnz ();
+      octave_idx_type Anz = A.nzmax ();
       rn.resize (Anz+1);
       cn.resize (Anz+1);
       a.resize (Anz+1, 0.0);
 
       if (Anc != mrowsc)
 	{
 	  error ("__glpk__: invalid value of A");
 	  return retval;
diff --git a/src/DLD-FUNCTIONS/ccolamd.cc b/src/DLD-FUNCTIONS/ccolamd.cc
--- a/src/DLD-FUNCTIONS/ccolamd.cc
+++ b/src/DLD-FUNCTIONS/ccolamd.cc
@@ -213,41 +213,41 @@ colamd, symamd, and other related orderi
 
       if (args(0).class_name () == "sparse")
 	{
 	  if (args(0).is_complex_type ())
 	    {
 	      scm = args(0). sparse_complex_matrix_value ();
 	      n_row = scm.rows ();
 	      n_col = scm.cols ();
-	      nnz = scm.nnz ();
+	      nnz = scm.nzmax ();
 	      ridx = scm.xridx ();
 	      cidx = scm.xcidx ();
 	    }
 	  else
 	    {
 	      sm = args(0).sparse_matrix_value ();
 
 	      n_row = sm.rows ();
 	      n_col = sm.cols ();
-	      nnz = sm.nnz ();
+	      nnz = sm.nzmax ();
 	      ridx = sm.xridx ();
 	      cidx = sm.xcidx ();
 	    }
 	}
       else
 	{
 	  if (args(0).is_complex_type ())
 	    sm = SparseMatrix (real (args(0).complex_matrix_value ()));
 	  else
 	    sm = SparseMatrix (args(0).matrix_value ());
 
 	  n_row = sm.rows ();
 	  n_col = sm.cols ();
-	  nnz = sm.nnz ();
+	  nnz = sm.nzmax ();
 	  ridx = sm.xridx ();
 	  cidx = sm.xcidx ();
 	}
 
       // Allocate workspace for ccolamd
       OCTAVE_LOCAL_BUFFER (octave_idx_type, p, n_col+1);
       for (octave_idx_type i = 0; i < n_col+1; i++)
 	p[i] = cidx [i];
@@ -449,40 +449,40 @@ colamd, symamd, and other related orderi
 
       if (args(0).class_name () == "sparse")
 	{
 	  if (args(0).is_complex_type ())
 	    {
 	      scm = args(0).sparse_complex_matrix_value ();
 	      n_row = scm.rows ();
 	      n_col = scm.cols ();
-	      nnz = scm.nnz ();
+	      nnz = scm.nzmax ();
 	      ridx = scm.xridx ();
 	      cidx = scm.xcidx ();
 	    }
 	  else
 	    {
 	      sm = args(0).sparse_matrix_value ();
 	      n_row = sm.rows ();
 	      n_col = sm.cols ();
-	      nnz = sm.nnz ();
+	      nnz = sm.nzmax ();
 	      ridx = sm.xridx ();
 	      cidx = sm.xcidx ();
 	    }
 	}
       else
 	{
 	  if (args(0).is_complex_type ())
 	    sm = SparseMatrix (real (args(0).complex_matrix_value ()));
 	  else
 	    sm = SparseMatrix (args(0).matrix_value ());
 	  
 	  n_row = sm.rows ();
 	  n_col = sm.cols ();
-	  nnz = sm.nnz ();
+	  nnz = sm.nzmax ();
 	  ridx = sm.xridx ();
 	  cidx = sm.xcidx ();
 	}
 
       if (n_row != n_col)
 	{
 	  error ("symamd: matrix must be square");
 	  return retval;
diff --git a/src/DLD-FUNCTIONS/colamd.cc b/src/DLD-FUNCTIONS/colamd.cc
--- a/src/DLD-FUNCTIONS/colamd.cc
+++ b/src/DLD-FUNCTIONS/colamd.cc
@@ -332,41 +332,41 @@ Ng, Oak Ridge National Laboratory. (see\
 
       if (args(0).class_name () == "sparse")
 	{
 	  if (args(0).is_complex_type ())
 	    {
 	      scm = args(0). sparse_complex_matrix_value ();
 	      n_row = scm.rows ();
 	      n_col = scm.cols ();
-	      nnz = scm.nnz ();
+	      nnz = scm.nzmax ();
 	      ridx = scm.xridx ();
 	      cidx = scm.xcidx ();
 	    }
 	  else
 	    {
 	      sm = args(0).sparse_matrix_value ();
 
 	      n_row = sm.rows ();
 	      n_col = sm.cols ();
-	      nnz = sm.nnz ();
+	      nnz = sm.nzmax ();
 	      ridx = sm.xridx ();
 	      cidx = sm.xcidx ();
 	    }
 	}
       else
 	{
 	  if (args(0).is_complex_type ())
 	    sm = SparseMatrix (real (args(0).complex_matrix_value ()));
 	  else
 	    sm = SparseMatrix (args(0).matrix_value ());
 
 	  n_row = sm.rows ();
 	  n_col = sm.cols ();
-	  nnz = sm.nnz ();
+	  nnz = sm.nzmax ();
 	  ridx = sm.xridx ();
 	  cidx = sm.xcidx ();
 	}
 
       // Allocate workspace for colamd
       OCTAVE_LOCAL_BUFFER (octave_idx_type, p, n_col+1);
       for (octave_idx_type i = 0; i < n_col+1; i++)
 	p[i] = cidx [i];
@@ -541,40 +541,40 @@ Ng, Oak Ridge National Laboratory. (see\
 
       if (args(0).class_name () == "sparse")
 	{
 	  if (args(0).is_complex_type ())
 	    {
 	      scm = args(0).sparse_complex_matrix_value ();
 	      n_row = scm.rows ();
 	      n_col = scm.cols ();
-	      nnz = scm.nnz ();
+	      nnz = scm.nzmax ();
 	      ridx = scm.xridx ();
 	      cidx = scm.xcidx ();
 	    }
 	  else
 	    {
 	      sm = args(0).sparse_matrix_value ();
 	      n_row = sm.rows ();
 	      n_col = sm.cols ();
-	      nnz = sm.nnz ();
+	      nnz = sm.nzmax ();
 	      ridx = sm.xridx ();
 	      cidx = sm.xcidx ();
 	    }
 	}
       else
 	{
 	  if (args(0).is_complex_type ())
 	    sm = SparseMatrix (real (args(0).complex_matrix_value ()));
 	  else
 	    sm = SparseMatrix (args(0).matrix_value ());
 	  
 	  n_row = sm.rows ();
 	  n_col = sm.cols ();
-	  nnz = sm.nnz ();
+	  nnz = sm.nzmax ();
 	  ridx = sm.xridx ();
 	  cidx = sm.xcidx ();
 	}
 
       if (n_row != n_col)
 	{
 	  error ("symamd: matrix must be square");
 	  return retval;
@@ -666,26 +666,26 @@ permutations on the tree.\n\
 
       if (args(0).class_name () == "sparse")
 	{
 	  if (args(0).is_complex_type ())
 	    {
 	      scm = args(0).sparse_complex_matrix_value ();
 	      n_row = scm.rows ();
 	      n_col = scm.cols ();
-	      nnz = scm.nnz ();
+	      nnz = scm.nzmax ();
 	      ridx = scm.xridx ();
 	      cidx = scm.xcidx ();
 	    }
 	  else
 	    {
 	      sm = args(0).sparse_matrix_value ();
 	      n_row = sm.rows ();
 	      n_col = sm.cols ();
-	      nnz = sm.nnz ();
+	      nnz = sm.nzmax ();
 	      ridx = sm.xridx ();
 	      cidx = sm.xcidx ();
 	    }
 
 	}
       else
 	{
 	  error ("etree: must be called with a sparse matrix");
diff --git a/src/DLD-FUNCTIONS/sparse.cc b/src/DLD-FUNCTIONS/sparse.cc
--- a/src/DLD-FUNCTIONS/sparse.cc
+++ b/src/DLD-FUNCTIONS/sparse.cc
@@ -399,59 +399,21 @@ DEFUN_DLD (full, args, ,
   else if (args(0).is_complex_type())
     retval = args(0).complex_matrix_value();
   else
     gripe_wrong_type_arg ("full", args(0));
 
   return retval;
 }
 
-DEFUN_DLD (nzmax, args, ,
-   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{scalar} =} nzmax (@var{SM})\n\
-Return the amount of storage allocated to the sparse matrix @var{SM}.\n\
-Note that Octave tends to crop unused memory at the first oppurtunity\n\
-for sparse objects. There are some cases of user created sparse objects\n\
-where the value returned by @dfn{nzmaz} will not be the same as @dfn{nnz},\n\
-but in general they will give the same result.\n\
-@seealso{sparse, spalloc}\n\
-@end deftypefn")
-{
-  octave_value retval;
-
-  if (args.length() < 1) 
-    {
-      print_usage ("nzmax");
-      return retval;
-    }
-
-  if (args(0).class_name () == "sparse") 
-    {
-      // XXX FIXME XXX should nnz be a method of octave_base_value so that the
-      // below can be replaced with "retval = (double) (args(0).nz ());"
-      const octave_value& rep = args(0).get_rep ();
-
-      if (args(0).type_name () == "sparse matrix")
-	retval = (double) ((const octave_sparse_matrix&) rep) .nnz ();
-      else if (args(0).type_name () == "sparse complex matrix")
-	retval = (double) ((const octave_sparse_complex_matrix&) rep) .nnz ();
-      else if (args(0).type_name () == "sparse bool matrix")
-	retval = (double) ((const octave_sparse_bool_matrix&) rep) .nnz ();
-    }
-  else
-    error ("nzmax: argument must be a sparse matrix");
-
-  return retval;
-}
-
 static octave_value_list
 sparse_find (const SparseMatrix& v)
 {
   octave_value_list retval;
-  octave_idx_type nnz = v.nonzero ();
+  octave_idx_type nnz = v.nnz ();
   dim_vector dv = v.dims ();
   octave_idx_type nr = dv(0);
   octave_idx_type nc = dv (1);
 
   ColumnVector I (nnz), J (nnz);
   ColumnVector S (nnz);
 
   for (octave_idx_type i = 0, cx = 0; i < nc; i++) 
@@ -482,17 +444,17 @@ sparse_find (const SparseMatrix& v)
   retval(4)= (double) nc;
   return retval;
 }
 
 static octave_value_list
 sparse_find (const SparseComplexMatrix& v)
 {
   octave_value_list retval;
-  octave_idx_type nnz = v.nonzero ();
+  octave_idx_type nnz = v.nnz ();
   dim_vector dv = v.dims ();
   octave_idx_type nr = dv(0);
   octave_idx_type nc = dv (1);
 
   ColumnVector I (nnz), J (nnz);
   ComplexColumnVector S (nnz);
 
   for (octave_idx_type i = 0, cx = 0; i < nc; i++) 
@@ -523,17 +485,17 @@ sparse_find (const SparseComplexMatrix& 
   retval(4)= (double) nc;
   return retval;
 }
 
 static octave_value_list
 sparse_find (const SparseBoolMatrix& v)
 {
   octave_value_list retval;
-  octave_idx_type nnz = v.nonzero ();
+  octave_idx_type nnz = v.nnz ();
   dim_vector dv = v.dims ();
   octave_idx_type nr = dv(0);
   octave_idx_type nc = dv (1);
 
   ColumnVector I (nnz), J (nnz);
   ColumnVector S (nnz);
 
   for (octave_idx_type i = 0, cx = 0; i < nc; i++) 
@@ -1113,17 +1075,17 @@ make_spdiag (const octave_value& a, cons
 	      k = -k;
 	      roff = k;
 	      coff = 0;
 	    }
 
 	  if (nr == 1) 
 	    {
 	      octave_idx_type n = nc + k;
-	      octave_idx_type nz = m.nnz ();
+	      octave_idx_type nz = m.nzmax ();
 	      SparseComplexMatrix r (n, n, nz);
 	      for (octave_idx_type i = 0; i < coff+1; i++)
 		r.xcidx (i) = 0;
 	      for (octave_idx_type j = 0; j < nc; j++)
 		{
 		  for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
 		    {
 		      r.xdata (i) = m.data (i);
@@ -1133,17 +1095,17 @@ make_spdiag (const octave_value& a, cons
 		}
 	      for (octave_idx_type i = nc+coff+1; i < n+1; i++)
 		r.xcidx (i) = nz;
 	      retval = r;
 	    } 
 	  else 
 	    {
 	      octave_idx_type n = nr + k;
-	      octave_idx_type nz = m.nnz ();
+	      octave_idx_type nz = m.nzmax ();
 	      octave_idx_type ii = 0;
 	      octave_idx_type ir = m.ridx(0);
 	      SparseComplexMatrix r (n, n, nz);
 	      for (octave_idx_type i = 0; i < coff+1; i++)
 		r.xcidx (i) = 0;
 	      for (octave_idx_type i = 0; i < nr; i++)
 		{
 		  if (ir == i)
@@ -1196,17 +1158,17 @@ make_spdiag (const octave_value& a, cons
 	      k = -k;
 	      roff = k;
 	      coff = 0;
 	    }
 
 	  if (nr == 1) 
 	    {
 	      octave_idx_type n = nc + k;
-	      octave_idx_type nz = m.nnz ();
+	      octave_idx_type nz = m.nzmax ();
 	      SparseMatrix r (n, n, nz);
 
 	      for (octave_idx_type i = 0; i < coff+1; i++)
 		r.xcidx (i) = 0;
 	      for (octave_idx_type j = 0; j < nc; j++)
 		{
 		  for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
 		    {
@@ -1217,17 +1179,17 @@ make_spdiag (const octave_value& a, cons
 		}
 	      for (octave_idx_type i = nc+coff+1; i < n+1; i++)
 		r.xcidx (i) = nz;
 	      retval = r;
 	    } 
 	  else 
 	    {
 	      octave_idx_type n = nr + k;
-	      octave_idx_type nz = m.nnz ();
+	      octave_idx_type nz = m.nzmax ();
 	      octave_idx_type ii = 0;
 	      octave_idx_type ir = m.ridx(0);
 	      SparseMatrix r (n, n, nz);
 	      for (octave_idx_type i = 0; i < coff+1; i++)
 		r.xcidx (i) = 0;
 	      for (octave_idx_type i = 0; i < nr; i++)
 		{
 		  if (ir == i)
diff --git a/src/DLD-FUNCTIONS/spchol.cc b/src/DLD-FUNCTIONS/spchol.cc
--- a/src/DLD-FUNCTIONS/spchol.cc
+++ b/src/DLD-FUNCTIONS/spchol.cc
@@ -451,30 +451,30 @@ factorization as determined by @var{typ}
 
   if (args(0).is_real_type ())
     {
       const SparseMatrix a = args(0).sparse_matrix_value();
       A->nrow = a.rows();
       A->ncol = a.cols();
       A->p = a.cidx();
       A->i = a.ridx();
-      A->nzmax = a.nonzero();
+      A->nzmax = a.nnz();
       A->xtype = CHOLMOD_REAL;
 
       if (a.rows() > 0 && a.cols() > 0)
 	A->x = a.data();
     }
   else if (args(0).is_complex_type ())
     {
       const SparseComplexMatrix a = args(0).sparse_complex_matrix_value();
       A->nrow = a.rows();
       A->ncol = a.cols();
       A->p = a.cidx();
       A->i = a.ridx();
-      A->nzmax = a.nonzero();
+      A->nzmax = a.nnz();
       A->xtype = CHOLMOD_COMPLEX;
 
       if (a.rows() > 0 && a.cols() > 0)
 	A->x = a.data();
     }
   else
     gripe_wrong_type_arg ("symbfact", arg(0));
 
diff --git a/src/DLD-FUNCTIONS/spkron.cc b/src/DLD-FUNCTIONS/spkron.cc
--- a/src/DLD-FUNCTIONS/spkron.cc
+++ b/src/DLD-FUNCTIONS/spkron.cc
@@ -45,17 +45,17 @@ kron (const Sparse<Complex>&, const Spar
 #endif
 
 template <class T>
 void
 kron (const Sparse<T>& A, const Sparse<T>& B, Sparse<T>& C)
 {
   octave_idx_type idx = 0;
   C = Sparse<T> (A.rows () * B.rows (), A.columns () * B.columns (), 
-		 A.nnz () * B.nnz ());
+		 A.nzmax () * B.nzmax ());
 
   C.cidx (0) = 0;
 
   for (octave_idx_type Aj = 0; Aj < A.columns (); Aj++)
     for (octave_idx_type Bj = 0; Bj < B.columns (); Bj++)
       {
 	for (octave_idx_type Ai = A.cidx (Aj); Ai < A.cidx (Aj+1); Ai++)
 	  {
diff --git a/src/DLD-FUNCTIONS/splu.cc b/src/DLD-FUNCTIONS/splu.cc
--- a/src/DLD-FUNCTIONS/splu.cc
+++ b/src/DLD-FUNCTIONS/splu.cc
@@ -120,17 +120,17 @@ be square.\n\
 	      for (octave_idx_type i = 0; i < nel; i++)
 		Qinit (i) = tmp (i) - 1;
 	      have_Qinit = true;
 	    }
 	  else
 	    {
 	      octave_idx_type t_nc = tmp.cols ();
 	      
-	      if (tmp.nnz () != t_nc)
+	      if (tmp.nzmax () != t_nc)
 		error ("splu: Not a valid permutation matrix");
 	      else
 		{
 		  for (octave_idx_type i = 0; i < t_nc + 1; i++)
 		    if (tmp.cidx(i) != i)
 		      {
 			error ("splu: Not a valid permutation matrix");
 			break;
@@ -176,17 +176,17 @@ be square.\n\
 	      have_Qinit = true;
 	    }
 	  else
 	    {
 	      SparseMatrix tmp2 (tmp);
 
 	      octave_idx_type t_nc = tmp2.cols ();
 	      
-	      if (tmp2.nnz () != t_nc)
+	      if (tmp2.nzmax () != t_nc)
 		error ("splu: Not a valid permutation matrix");
 	      else
 		{
 		  for (octave_idx_type i = 0; i < t_nc + 1; i++)
 		    if (tmp2.cidx(i) != i)
 		      {
 			error ("splu: Not a valid permutation matrix");
 			break;
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -1089,16 +1089,37 @@ returns number of non zero elements in @
   if (args.length () == 1)
     retval = args(0).nnz ();
   else
     print_usage ("nnz");
 
   return retval;
 }
 
+DEFUN (nzmax, args, ,
+   "-*- texinfo -*-\n\
+@deftypefn {Loadable Function} {@var{scalar} =} nzmax (@var{SM})\n\
+Return the amount of storage allocated to the sparse matrix @var{SM}.\n\
+Note that Octave tends to crop unused memory at the first oppurtunity\n\
+for sparse objects. There are some cases of user created sparse objects\n\
+where the value returned by @dfn{nzmaz} will not be the same as @dfn{nnz},\n\
+but in general they will give the same result.\n\
+@seealso{sparse, spalloc}\n\
+@end deftypefn")
+{
+  octave_value retval;
+
+  if (args.length() == 1)
+    retval = args(0).nzmax ();
+  else
+    print_usage ("nzmax");
+
+  return retval;
+}
+
 DEFUN (sum, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} sum (@var{x}, @var{dim})\n\
 Sum of elements along dimension @var{dim}.  If @var{dim} is\n\
 omitted, it defaults to 1 (column-wise sum).\n\
 \n\
 As a special case, if @var{x} is a vector and @var{dim} is omitted,\n\
 return the sum of the elements.\n\
diff --git a/src/ls-mat5.cc b/src/ls-mat5.cc
--- a/src/ls-mat5.cc
+++ b/src/ls-mat5.cc
@@ -1350,26 +1350,26 @@ save_mat5_element_length (const octave_v
 	ret += PAD (2 * chm.rows () * chm.cols ());
     }
   else if (cname == "sparse")
     {
       if (tc.is_complex_type ())
 	{
 	  SparseComplexMatrix m = tc.sparse_complex_matrix_value ();
 	  int nc = m.cols ();
-	  int nnz = m.nnz ();
+	  int nnz = m.nzmax ();
 
 	  ret += 16 + PAD (nnz * sizeof (int)) + PAD ((nc + 1) * sizeof (int)) +
 	    save_mat5_array_length (m.data (), m.nelem (), save_as_floats);
 	}
       else
 	{
 	  SparseMatrix m = tc.sparse_matrix_value ();
 	  int nc = m.cols ();
-	  int nnz = m.nnz ();
+	  int nnz = m.nzmax ();
 
 	  ret += 16 + PAD (nnz * sizeof (int)) + PAD ((nc + 1) * sizeof (int)) +
 	    save_mat5_array_length (m.data (), m.nelem (), save_as_floats);
 	}
     }
 
 #define INT_LEN(nel, size) \
   { \
@@ -1538,22 +1538,22 @@ save_mat5_binary_element (std::ostream& 
   else if (cname == "uint64")
     flags |= mxUINT64_CLASS;
   else if (cname == "sparse")
     {
       flags |= mxSPARSE_CLASS;
       if (tc.is_complex_type ())
 	{
 	  SparseComplexMatrix scm = tc.sparse_complex_matrix_value ();
-	  nnz = scm.nnz ();
+	  nnz = scm.nzmax ();
 	}
       else
 	{
 	  SparseMatrix sm = tc.sparse_matrix_value ();
-	  nnz = sm.nnz ();
+	  nnz = sm.nzmax ();
 	}
     }
   else if (tc.is_real_scalar ())
     flags |= mxDOUBLE_CLASS;
   else if (tc.is_real_matrix () || tc.is_range ())
     flags |= mxDOUBLE_CLASS;
   else if (tc.is_complex_scalar ())
     flags |= mxDOUBLE_CLASS;
diff --git a/src/ov-base-sparse.cc b/src/ov-base-sparse.cc
--- a/src/ov-base-sparse.cc
+++ b/src/ov-base-sparse.cc
@@ -196,17 +196,17 @@ octave_base_sparse<T>::assign (const oct
 
 template <class T>
 bool 
 octave_base_sparse<T>::is_true (void) const
 {
   bool retval = false;
   dim_vector dv = matrix.dims ();
   octave_idx_type nel = dv.numel ();
-  octave_idx_type nz = nnz ();
+  octave_idx_type nz = nzmax ();
 
   if (nz == nel && nel > 0)
     {
       T t1 (matrix.reshape (dim_vector (nel, 1)));
 
       SparseBoolMatrix t2 = t1.all ();
 
       retval = t2(0);
@@ -242,17 +242,17 @@ octave_base_sparse<T>::print_info (std::
 
 template <class T>
 void
 octave_base_sparse<T>::print_raw (std::ostream& os,
 				  bool pr_as_read_syntax) const
 {
   octave_idx_type nr = matrix.rows ();
   octave_idx_type nc = matrix.cols ();
-  octave_idx_type nz = nonzero ();
+  octave_idx_type nz = nnz ();
 
   // XXX FIXME XXX -- this should probably all be handled by a
   // separate octave_print_internal function that can handle format
   // compact, loose, etc.
 
   os << "Compressed Column Sparse (rows = " << nr
      << ", cols = " << nc
      << ", nnz = " << nz << ")\n";
@@ -288,17 +288,17 @@ template <class T>
 bool
 octave_base_sparse<T>::save_ascii (std::ostream& os, bool&, bool)
 {
   dim_vector dv = this->dims ();
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
 
-  os << "# nnz: "      << nnz () << "\n";
+  os << "# nnz: "      << nzmax () << "\n";
   os << "# rows: "     << dv (0) << "\n";
   os << "# columns: "  << dv (1) << "\n";
 
   os << this->matrix;
 
   return true;
 }
 
diff --git a/src/ov-base-sparse.h b/src/ov-base-sparse.h
--- a/src/ov-base-sparse.h
+++ b/src/ov-base-sparse.h
@@ -71,17 +71,18 @@ octave_base_sparse : public octave_base_
 
   ~octave_base_sparse (void) { }
 
   octave_value *clone (void) const { return new octave_base_sparse (*this); }
   octave_value *empty_clone (void) const 
     { return new octave_base_sparse (); }
 
   octave_idx_type nnz (void) const { return matrix.nnz (); }
-  octave_idx_type nonzero (void) const { return matrix.nonzero (); }
+
+  octave_idx_type nzmax (void) const { return matrix.nzmax (); }
 
   size_t byte_size (void) const { return matrix.byte_size (); }
 
   octave_value squeeze (void) const { return matrix.squeeze (); }
 
   octave_value subsref (const std::string& type,
 			const std::list<octave_value_list>& idx);
 
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -175,16 +175,23 @@ octave_base_value::subsasgn (const std::
 
 octave_idx_type
 octave_base_value::nnz (void) const
 {
   gripe_wrong_type_arg ("octave_base_value::nnz ()", type_name ());
   return -1;
 }
 
+octave_idx_type
+octave_base_value::nzmax (void) const
+{
+  gripe_wrong_type_arg ("octave_base_value::nzmax ()", type_name ());
+  return -1;
+}
+
 octave_value
 octave_base_value::reshape (const dim_vector&) const
 {
   gripe_wrong_type_arg ("octave_base_value::reshape ()", type_name ());
   return octave_value ();
 }
 
 octave_value
diff --git a/src/ov-base.h b/src/ov-base.h
--- a/src/ov-base.h
+++ b/src/ov-base.h
@@ -96,16 +96,18 @@ public:
   octave_idx_type numel (void) const { return dims ().numel (); }
 
   octave_idx_type capacity (void) const { return numel (); }
 
   size_t byte_size (void) const { return 0; }
 
   octave_idx_type nnz (void) const;
 
+  octave_idx_type nzmax (void) const;
+
   octave_value reshape (const dim_vector&) const;
 
   octave_value permute (const Array<int>& vec, bool = false) const;
 
   octave_value resize (const dim_vector&) const;
 
   bool is_defined (void) const { return false; }
 
diff --git a/src/ov-bool-sparse.cc b/src/ov-bool-sparse.cc
--- a/src/ov-bool-sparse.cc
+++ b/src/ov-bool-sparse.cc
@@ -200,17 +200,17 @@ octave_sparse_bool_matrix::save_binary (
   if (d.length() < 1)
     return false;
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
 
   int nr = d(0);
   int nc = d(1);
-  int nz = nnz ();
+  int nz = nzmax ();
 
   FOUR_BYTE_INT itmp;
   // Use negative value for ndims to be consistent with other formats
   itmp= -2;        
   os.write (X_CAST (char *, &itmp), 4);
   
   itmp= nr;    
   os.write (X_CAST (char *, &itmp), 4);
@@ -390,17 +390,17 @@ octave_sparse_bool_matrix::save_hdf5 (hi
 			H5P_DEFAULT);
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
-  tmp = m.nnz ();
+  tmp = m.nzmax ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
 		     H5P_DEFAULT, (void*) &tmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
@@ -436,17 +436,17 @@ octave_sparse_bool_matrix::save_hdf5 (hi
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }    
 
   H5Sclose (space_hid);
 
-  hdims[0] = m.nnz();
+  hdims[0] = m.nzmax ();
   hdims[1] = 1;
 
   space_hid = H5Screate_simple (2, hdims, 0);
 
   if (space_hid < 0) 
     {
       H5Gclose (group_hid);
       return false;
@@ -476,18 +476,18 @@ octave_sparse_bool_matrix::save_hdf5 (hi
 			H5P_DEFAULT);
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
-  hbool_t htmp[m.nnz ()];
-  for (int i = 0; i < m.nnz (); i++)
+  hbool_t htmp[m.nzmax ()];
+  for (int i = 0; i < m.nzmax (); i++)
     htmp[i] = m.xdata(i);
 
   retval = H5Dwrite (data_hid, H5T_NATIVE_HBOOL, H5S_ALL, H5S_ALL,
 		     H5P_DEFAULT, (void*) htmp) >= 0;
   H5Dclose (data_hid);
   H5Sclose (space_hid);
   H5Gclose (group_hid);
 
diff --git a/src/ov-cx-sparse.cc b/src/ov-cx-sparse.cc
--- a/src/ov-cx-sparse.cc
+++ b/src/ov-cx-sparse.cc
@@ -206,17 +206,17 @@ octave_sparse_complex_matrix::save_binar
   if (d.length() < 1)
     return false;
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
 
   int nr = d(0);
   int nc = d(1);
-  int nz = nnz ();
+  int nz = nzmax ();
 
   FOUR_BYTE_INT itmp;
   // Use negative value for ndims to be consistent with other formats
   itmp= -2;        
   os.write (X_CAST (char *, &itmp), 4);
   
   itmp= nr;    
   os.write (X_CAST (char *, &itmp), 4);
@@ -233,17 +233,17 @@ octave_sparse_complex_matrix::save_binar
       if (matrix.too_large_for_float ())
 	{
 	  warning ("save: some values too large to save as floats --");
 	  warning ("save: saving as doubles instead");
 	}
       else
 	st = LS_FLOAT;
     }
-  else if (matrix.nnz () > 8192) // XXX FIXME XXX -- make this configurable.
+  else if (matrix.nzmax () > 8192) // XXX FIXME XXX -- make this configurable.
     {
       double max_val, min_val;
       if (matrix.all_integers (max_val, min_val))
 	st = get_save_type (max_val, min_val);
     }
 
   // add one to the printed indices to go from
   // zero-based to one-based arrays
@@ -409,17 +409,17 @@ octave_sparse_complex_matrix::save_hdf5 
 			H5P_DEFAULT);
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
-  tmp = m.nnz ();
+  tmp = m.nzmax ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
 		     H5P_DEFAULT, (void*) &tmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
@@ -455,17 +455,17 @@ octave_sparse_complex_matrix::save_hdf5 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }    
 
   H5Sclose (space_hid);
 
-  hdims[0] = m.nnz();
+  hdims[0] = m.nzmax ();
   hdims[1] = 1;
 
   space_hid = H5Screate_simple (2, hdims, 0);
 
   if (space_hid < 0) 
     {
       H5Gclose (group_hid);
       return false;
diff --git a/src/ov-mapper.cc b/src/ov-mapper.cc
--- a/src/ov-mapper.cc
+++ b/src/ov-mapper.cc
@@ -55,17 +55,17 @@ any_element_less_than (const NDArray& a,
     }
 
   return false;
 }
 
 static bool
 any_element_less_than (const SparseMatrix& a, double val)
 {
-  octave_idx_type len = a.nonzero ();
+  octave_idx_type len = a.nnz ();
 
   if (val > 0. && len != a.numel ())
     return true;
 
   for (octave_idx_type i = 0; i < len; i++)
     {
       OCTAVE_QUIT;
 
@@ -90,17 +90,17 @@ any_element_greater_than (const NDArray&
     }
 
   return false;
 }
 
 static bool
 any_element_greater_than (const SparseMatrix& a, double val)
 {
-  octave_idx_type len = a.nonzero ();
+  octave_idx_type len = a.nnz ();
 
   if (val < 0. && len != a.numel ())
     return true;
 
   for (octave_idx_type i = 0; i < len; i++)
     {
       OCTAVE_QUIT;
 
@@ -165,17 +165,17 @@ any_element_greater_than (const SparseMa
 		  return retval; \
 	      } \
 	  \
 	  result.maybe_compress (true);	\
           retval = R; \
 	} \
       else \
 	{ \
-	  octave_idx_type nnz = M.nonzero (); \
+	  octave_idx_type nnz = M.nnz (); \
 	  octave_idx_type nr = M.rows (); \
 	  octave_idx_type nc = M.cols (); \
 	  \
 	  T result (nr, nc, nnz); \
 	  ET zero = ET (0.); \
 	  octave_idx_type ii = 0; \
 	  result.cidx (ii) = 0; \
 	  \
diff --git a/src/ov-re-sparse.cc b/src/ov-re-sparse.cc
--- a/src/ov-re-sparse.cc
+++ b/src/ov-re-sparse.cc
@@ -46,17 +46,17 @@ template class octave_base_sparse<Sparse
 
 DEFINE_OCTAVE_ALLOCATOR (octave_sparse_matrix);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_sparse_matrix, "sparse matrix", "sparse");
 
 idx_vector
 octave_sparse_matrix::index_vector (void) const
 {
-  if (matrix.numel () == matrix.nonzero ())
+  if (matrix.numel () == matrix.nnz ())
     return idx_vector (array_value ());
   else
     {
       std::string nm = type_name ();
       error ("%s type invalid as index value", nm.c_str ());
       return idx_vector ();
     }
 }
@@ -251,17 +251,17 @@ octave_sparse_matrix::save_binary (std::
   if (d.length() < 1)
     return false;
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
 
   int nr = d(0);
   int nc = d(1);
-  int nz = nnz ();
+  int nz = nzmax ();
 
   FOUR_BYTE_INT itmp;
   // Use negative value for ndims to be consistent with other formats
   itmp= -2;        
   os.write (X_CAST (char *, &itmp), 4);
   
   itmp= nr;    
   os.write (X_CAST (char *, &itmp), 4);
@@ -278,17 +278,17 @@ octave_sparse_matrix::save_binary (std::
       if (matrix.too_large_for_float ())
 	{
 	  warning ("save: some values too large to save as floats --");
 	  warning ("save: saving as doubles instead");
 	}
       else
 	st = LS_FLOAT;
     }
-  else if (matrix.nnz () > 8192) // XXX FIXME XXX -- make this configurable.
+  else if (matrix.nzmax () > 8192) // XXX FIXME XXX -- make this configurable.
     {
       double max_val, min_val;
       if (matrix.all_integers (max_val, min_val))
 	st = get_save_type (max_val, min_val);
     }
 
   // add one to the printed indices to go from
   // zero-based to one-based arrays
@@ -453,17 +453,17 @@ octave_sparse_matrix::save_hdf5 (hid_t l
 			H5P_DEFAULT);
   if (data_hid < 0) 
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
   
-  tmp = m.nnz ();
+  tmp = m.nzmax ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT,
 		     (void*) &tmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
@@ -499,17 +499,17 @@ octave_sparse_matrix::save_hdf5 (hid_t l
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }    
 
   H5Sclose (space_hid);
 
-  hdims[0] = m.nnz();
+  hdims[0] = m.nzmax ();
   hdims[1] = 1;
 
   space_hid = H5Screate_simple (2, hdims, 0);
 
   if (space_hid < 0) 
     {
       H5Gclose (group_hid);
       return false;
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -373,16 +373,18 @@ public:
   virtual octave_idx_type capacity (void) const
     { return rep->capacity (); }
 
   virtual size_t byte_size (void) const
     { return rep->byte_size (); }
 
   virtual octave_idx_type nnz (void) const { return rep->nnz (); }
 
+  virtual octave_idx_type nzmax (void) const { return rep->nzmax (); }
+
   virtual octave_value reshape (const dim_vector& dv) const
     { return rep->reshape (dv); }
 
   virtual octave_value permute (const Array<int>& vec, bool inv = false) const
     { return rep->permute (vec, inv); }
 
   octave_value ipermute (const Array<int>& vec) const
     { return rep->permute (vec, true); }
diff --git a/src/sparse-xpow.cc b/src/sparse-xpow.cc
--- a/src/sparse-xpow.cc
+++ b/src/sparse-xpow.cc
@@ -301,17 +301,17 @@ octave_value
 elem_xpow (const SparseMatrix& a, double b)
 {
   // XXX FIXME XXX What should a .^ 0 give?? Matlab gives a 
   // sparse matrix with same structure as a, which is strictly
   // incorrect. Keep compatiability.
 
   octave_value retval;
 
-  octave_idx_type nz = a.nnz ();
+  octave_idx_type nz = a.nzmax ();
 
   if (b <= 0.0)
     {
       octave_idx_type nr = a.rows ();
       octave_idx_type nc = a.cols ();
 
       if (static_cast<int> (b) != b && a.any_element_is_negative ())
 	{
@@ -487,17 +487,17 @@ elem_xpow (const SparseMatrix& a, const 
 {
   octave_value retval;
 
   if (b == 0.0)
     // Can this case ever happen, due to automatic retyping with maybe_mutate?
     retval = octave_value (NDArray (a.dims (), 1));
   else
     {
-      octave_idx_type nz = a.nnz ();
+      octave_idx_type nz = a.nzmax ();
       SparseComplexMatrix result (a);
       
       for (octave_idx_type i = 0; i < nz; i++)
 	{
 	  OCTAVE_QUIT;
 	  result.data (i) = pow (Complex (a.data (i)), b);
 	}
   
@@ -630,17 +630,17 @@ elem_xpow (const SparseComplexMatrix& a,
 		result (a.ridx(i), j) = pow (a.data (i), b);
 	      }
 	}  
 
       retval = result;
     }
   else
     {
-      octave_idx_type nz = a.nnz ();
+      octave_idx_type nz = a.nzmax ();
 
       SparseComplexMatrix result (a);
   
       if (xisint (b))
 	{
 	  for (octave_idx_type i = 0; i < nz; i++)
 	    {
 	      OCTAVE_QUIT;
@@ -723,17 +723,17 @@ elem_xpow (const SparseComplexMatrix& a,
   octave_value retval;
 
   if (b == 0.0)
     // Can this case ever happen, due to automatic retyping with maybe_mutate?
     retval = octave_value (NDArray (a.dims (), 1));
   else
     {
 
-      octave_idx_type nz = a.nnz ();
+      octave_idx_type nz = a.nzmax ();
 
       SparseComplexMatrix result (a);
 
       for (octave_idx_type i = 0; i < nz; i++)
 	{
 	  OCTAVE_QUIT;
 	  result.data (i) = pow (a.data (i), b);
 	}
