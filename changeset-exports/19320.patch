# HG changeset patch
# User CarnÃ« Draug <carandraug@octave.org>
# Date 1415348155 0
#      Fri Nov 07 08:15:55 2014 +0000
# Node ID d0c73e23a5056f8b1e0eba8fb16c5e375738acf0
# Parent  8b4a24081e47146e2e889a13733c9857be348422
Change inheritance tree so that <T>Matrix inherit from <T>NDArray.

* liboctave/array/CMatrix.cc, liboctave/array/CMatrix.h,
liboctave/array/CNDArray.cc, liboctave/array/CNDArray.h,
liboctave/array/dMatrix.cc, liboctave/array/dMatrix.h,
liboctave/array/dNDArray.cc, liboctave/array/dNDArray.h,
liboctave/array/fCMatrix.cc, liboctave/array/fCMatrix.h,
liboctave/array/fCNDArray.cc, liboctave/array/fCNDArray.h,
liboctave/array/fMatrix.cc, liboctave/array/fMatrix.h,
liboctave/array/fNDArray.cc, liboctave/array/fNDArray.h: change base class of
Matrix, FloatMatrix, ComplexMatrix, and FloatComplexMatrix to NDArray,
FloatNDArray, ComplexNDArray, and FloatComplexNDArray respectively.  This will
allow to reduce duplicated code since the Matrix classes will be able to
inherit many of their methods from their NDArray counterparts.  Also remove
the matrix_value () method since a constructor now suffices.
* liboctave/array/CSparse.h: include CMatrix
* libinterp/corefcn/pr-output.cc, libinterp/octave-value/ov-cx-mat.cc,
libinterp/octave-value/ov-flt-cx-mat.cc,
libinterp/octave-value/ov-flt-re-mat.cc, libinterp/octave-value/ov-re-mat.cc:
replace calls to matrix_value () with constructor with respective Matrix
subclass.

diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -2083,17 +2083,17 @@ void print_nd_array (std::ostream& os, c
 void
 octave_print_internal (std::ostream& os, const NDArray& nda,
                        bool pr_as_read_syntax, int extra_indent)
 {
   switch (nda.ndims ())
     {
     case 1:
     case 2:
-      octave_print_internal (os, nda.matrix_value (),
+      octave_print_internal (os, Matrix (nda),
                              pr_as_read_syntax, extra_indent);
       break;
 
     default:
       print_nd_array <NDArray, double, Matrix> (os, nda, pr_as_read_syntax);
       break;
     }
 }
@@ -2560,17 +2560,17 @@ octave_print_internal (std::ostream& os,
 void
 octave_print_internal (std::ostream& os, const ComplexNDArray& nda,
                        bool pr_as_read_syntax, int extra_indent)
 {
   switch (nda.ndims ())
     {
     case 1:
     case 2:
-      octave_print_internal (os, nda.matrix_value (),
+      octave_print_internal (os, ComplexMatrix (nda),
                              pr_as_read_syntax, extra_indent);
       break;
 
     default:
       print_nd_array <ComplexNDArray, Complex, ComplexMatrix>
                       (os, nda, pr_as_read_syntax);
       break;
     }
diff --git a/libinterp/octave-value/ov-cx-mat.cc b/libinterp/octave-value/ov-cx-mat.cc
--- a/libinterp/octave-value/ov-cx-mat.cc
+++ b/libinterp/octave-value/ov-cx-mat.cc
@@ -147,31 +147,31 @@ Matrix
 octave_complex_matrix::matrix_value (bool force_conversion) const
 {
   Matrix retval;
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
                                "complex matrix", "real matrix");
 
-  retval = ::real (matrix.matrix_value ());
+  retval = ::real (ComplexMatrix (matrix));
 
   return retval;
 }
 
 FloatMatrix
 octave_complex_matrix::float_matrix_value (bool force_conversion) const
 {
   FloatMatrix retval;
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
                                "complex matrix", "real matrix");
 
-  retval = ::real (matrix.matrix_value ());
+  retval = ::real (ComplexMatrix (matrix));
 
   return retval;
 }
 
 Complex
 octave_complex_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
@@ -209,23 +209,23 @@ octave_complex_matrix::float_complex_val
     gripe_invalid_conversion ("complex matrix", "complex scalar");
 
   return retval;
 }
 
 ComplexMatrix
 octave_complex_matrix::complex_matrix_value (bool) const
 {
-  return matrix.matrix_value ();
+  return ComplexMatrix (matrix);
 }
 
 FloatComplexMatrix
 octave_complex_matrix::float_complex_matrix_value (bool) const
 {
-  return FloatComplexMatrix (matrix.matrix_value ());
+  return FloatComplexMatrix (ComplexMatrix (matrix));
 }
 
 boolNDArray
 octave_complex_matrix::bool_array_value (bool warn) const
 {
   if (matrix.any_element_is_nan ())
     gripe_nan_to_logical_conversion ();
   else if (warn && (! matrix.all_elements_are_real ()
@@ -265,25 +265,25 @@ SparseMatrix
 octave_complex_matrix::sparse_matrix_value (bool force_conversion) const
 {
   SparseMatrix retval;
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
                                "complex matrix", "real matrix");
 
-  retval = SparseMatrix (::real (matrix.matrix_value ()));
+  retval = SparseMatrix (::real (ComplexMatrix (matrix)));
 
   return retval;
 }
 
 SparseComplexMatrix
 octave_complex_matrix::sparse_complex_matrix_value (bool) const
 {
-  return SparseComplexMatrix (matrix.matrix_value ());
+  return SparseComplexMatrix (ComplexMatrix (matrix));
 }
 
 octave_value
 octave_complex_matrix::diag (octave_idx_type k) const
 {
   octave_value retval;
   if (k == 0 && matrix.ndims () == 2
       && (matrix.rows () == 1 || matrix.columns () == 1))
@@ -297,17 +297,17 @@ octave_complex_matrix::diag (octave_idx_
 octave_value
 octave_complex_matrix::diag (octave_idx_type m, octave_idx_type n) const
 {
   octave_value retval;
 
   if (matrix.ndims () == 2
       && (matrix.rows () == 1 || matrix.columns () == 1))
     {
-      ComplexMatrix mat = matrix.matrix_value ();
+      ComplexMatrix mat (matrix);
 
       retval = mat.diag (m, n);
     }
   else
     error ("diag: expecting vector argument");
 
   return retval;
 }
diff --git a/libinterp/octave-value/ov-flt-cx-mat.cc b/libinterp/octave-value/ov-flt-cx-mat.cc
--- a/libinterp/octave-value/ov-flt-cx-mat.cc
+++ b/libinterp/octave-value/ov-flt-cx-mat.cc
@@ -135,31 +135,31 @@ Matrix
 octave_float_complex_matrix::matrix_value (bool force_conversion) const
 {
   Matrix retval;
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
                                "complex matrix", "real matrix");
 
-  retval = ::real (matrix.matrix_value ());
+  retval = ::real (FloatComplexMatrix (matrix));
 
   return retval;
 }
 
 FloatMatrix
 octave_float_complex_matrix::float_matrix_value (bool force_conversion) const
 {
   FloatMatrix retval;
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
                                "complex matrix", "real matrix");
 
-  retval = ::real (matrix.matrix_value ());
+  retval = ::real (FloatComplexMatrix (matrix));
 
   return retval;
 }
 
 Complex
 octave_float_complex_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
@@ -197,23 +197,23 @@ octave_float_complex_matrix::float_compl
     gripe_invalid_conversion ("complex matrix", "complex scalar");
 
   return retval;
 }
 
 ComplexMatrix
 octave_float_complex_matrix::complex_matrix_value (bool) const
 {
-  return matrix.matrix_value ();
+  return FloatComplexMatrix (matrix);
 }
 
 FloatComplexMatrix
 octave_float_complex_matrix::float_complex_matrix_value (bool) const
 {
-  return FloatComplexMatrix (matrix.matrix_value ());
+  return FloatComplexMatrix (matrix);
 }
 
 boolNDArray
 octave_float_complex_matrix::bool_array_value (bool warn) const
 {
   if (matrix.any_element_is_nan ())
     gripe_nan_to_logical_conversion ();
   else if (warn && (! matrix.all_elements_are_real ()
@@ -285,17 +285,17 @@ octave_float_complex_matrix::diag (octav
 octave_value
 octave_float_complex_matrix::diag (octave_idx_type m, octave_idx_type n) const
 {
   octave_value retval;
 
   if (matrix.ndims () == 2
       && (matrix.rows () == 1 || matrix.columns () == 1))
     {
-      FloatComplexMatrix mat = matrix.matrix_value ();
+      FloatComplexMatrix mat (matrix);
 
       retval = mat.diag (m, n);
     }
   else
     error ("diag: expecting vector argument");
 
   return retval;
 }
diff --git a/libinterp/octave-value/ov-flt-re-mat.cc b/libinterp/octave-value/ov-flt-re-mat.cc
--- a/libinterp/octave-value/ov-flt-re-mat.cc
+++ b/libinterp/octave-value/ov-flt-re-mat.cc
@@ -122,23 +122,23 @@ octave_float_matrix::float_value (bool) 
   return retval;
 }
 
 // FIXME
 
 Matrix
 octave_float_matrix::matrix_value (bool) const
 {
-  return Matrix (matrix.matrix_value ());
+  return Matrix (FloatMatrix (matrix));
 }
 
 FloatMatrix
 octave_float_matrix::float_matrix_value (bool) const
 {
-  return matrix.matrix_value ();
+  return FloatMatrix (matrix);
 }
 
 Complex
 octave_float_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
@@ -176,23 +176,23 @@ octave_float_matrix::float_complex_value
   return retval;
 }
 
 // FIXME
 
 ComplexMatrix
 octave_float_matrix::complex_matrix_value (bool) const
 {
-  return ComplexMatrix (matrix.matrix_value ());
+  return ComplexMatrix (FloatMatrix (matrix));
 }
 
 FloatComplexMatrix
 octave_float_matrix::float_complex_matrix_value (bool) const
 {
-  return FloatComplexMatrix (matrix.matrix_value ());
+  return FloatComplexMatrix (FloatMatrix (matrix));
 }
 
 ComplexNDArray
 octave_float_matrix::complex_array_value (bool) const
 {
   return ComplexNDArray (matrix);
 }
 
@@ -263,17 +263,17 @@ octave_float_matrix::diag (octave_idx_ty
 octave_value
 octave_float_matrix::diag (octave_idx_type m, octave_idx_type n) const
 {
   octave_value retval;
 
   if (matrix.ndims () == 2
       && (matrix.rows () == 1 || matrix.columns () == 1))
     {
-      FloatMatrix mat = matrix.matrix_value ();
+      FloatMatrix mat (matrix);
 
       retval = mat.diag (m, n);
     }
   else
     error ("diag: expecting vector argument");
 
   return retval;
 }
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -137,23 +137,23 @@ octave_matrix::float_value (bool) const
   return retval;
 }
 
 // FIXME
 
 Matrix
 octave_matrix::matrix_value (bool) const
 {
-  return matrix.matrix_value ();
+  return Matrix (matrix);
 }
 
 FloatMatrix
 octave_matrix::float_matrix_value (bool) const
 {
-  return FloatMatrix (matrix.matrix_value ());
+  return FloatMatrix (Matrix (matrix));
 }
 
 Complex
 octave_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
@@ -191,23 +191,23 @@ octave_matrix::float_complex_value (bool
   return retval;
 }
 
 // FIXME
 
 ComplexMatrix
 octave_matrix::complex_matrix_value (bool) const
 {
-  return ComplexMatrix (matrix.matrix_value ());
+  return ComplexMatrix (Matrix (matrix));
 }
 
 FloatComplexMatrix
 octave_matrix::float_complex_matrix_value (bool) const
 {
-  return FloatComplexMatrix (matrix.matrix_value ());
+  return FloatComplexMatrix (Matrix (matrix));
 }
 
 ComplexNDArray
 octave_matrix::complex_array_value (bool) const
 {
   return ComplexNDArray (matrix);
 }
 
@@ -239,17 +239,17 @@ octave_matrix::char_array_value (bool) c
     retval.elem (i) = static_cast<char>(matrix.elem (i));
 
   return retval;
 }
 
 SparseMatrix
 octave_matrix::sparse_matrix_value (bool) const
 {
-  return SparseMatrix (matrix.matrix_value ());
+  return SparseMatrix (Matrix (matrix));
 }
 
 SparseComplexMatrix
 octave_matrix::sparse_complex_matrix_value (bool) const
 {
   // FIXME: Need a SparseComplexMatrix (Matrix) constructor to make
   // this function more efficient.  Then this should become
   // return SparseComplexMatrix (matrix.matrix_value ());
@@ -272,17 +272,17 @@ octave_matrix::diag (octave_idx_type k) 
 octave_value
 octave_matrix::diag (octave_idx_type m, octave_idx_type n) const
 {
   octave_value retval;
 
   if (matrix.ndims () == 2
       && (matrix.rows () == 1 || matrix.columns () == 1))
     {
-      Matrix mat = matrix.matrix_value ();
+      Matrix mat (matrix);
 
       retval = mat.diag (m, n);
     }
   else
     error ("diag: expecting vector argument");
 
   return retval;
 }
diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -35,16 +35,17 @@ along with Octave; see the file COPYING.
 // FIXME
 #include <sys/types.h>
 
 #include "Array-util.h"
 #include "boolMatrix.h"
 #include "chMatrix.h"
 #include "dMatrix.h"
 #include "CMatrix.h"
+#include "CNDArray.h"
 #include "CRowVector.h"
 #include "dRowVector.h"
 #include "CDiagMatrix.h"
 #include "dDiagMatrix.h"
 #include "CmplxCHOL.h"
 #include "CmplxSCHUR.h"
 #include "CmplxSVD.h"
 #include "DET.h"
@@ -262,71 +263,71 @@ extern "C"
                                F77_CHAR_ARG_LEN_DECL);
 }
 
 static const Complex Complex_NaN_result (octave_NaN, octave_NaN);
 
 // Complex Matrix class
 
 ComplexMatrix::ComplexMatrix (const Matrix& a)
-  : MArray<Complex> (a)
+  : ComplexNDArray (a)
 {
 }
 
 ComplexMatrix::ComplexMatrix (const RowVector& rv)
-  : MArray<Complex> (rv)
+  : ComplexNDArray (rv)
 {
 }
 
 ComplexMatrix::ComplexMatrix (const ColumnVector& cv)
-  : MArray<Complex> (cv)
+  : ComplexNDArray (cv)
 {
 }
 
 ComplexMatrix::ComplexMatrix (const DiagMatrix& a)
-  : MArray<Complex> (a.dims (), 0.0)
+  : ComplexNDArray (a.dims (), 0.0)
 {
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) = a.elem (i, i);
 }
 
 ComplexMatrix::ComplexMatrix (const ComplexRowVector& rv)
-  : MArray<Complex> (rv)
+  : ComplexNDArray (rv)
 {
 }
 
 ComplexMatrix::ComplexMatrix (const ComplexColumnVector& cv)
-  : MArray<Complex> (cv)
+  : ComplexNDArray (cv)
 {
 }
 
 ComplexMatrix::ComplexMatrix (const ComplexDiagMatrix& a)
-  : MArray<Complex> (a.dims (), 0.0)
+  : ComplexNDArray (a.dims (), 0.0)
 {
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) = a.elem (i, i);
 }
 
 // FIXME: could we use a templated mixed-type copy function here?
 
 ComplexMatrix::ComplexMatrix (const boolMatrix& a)
-  : MArray<Complex> (a)
+  : ComplexNDArray (a)
 {
 }
 
 ComplexMatrix::ComplexMatrix (const charMatrix& a)
-  : MArray<Complex> (a.dims (), 0.0)
+  : ComplexNDArray (a.dims (), 0.0)
 {
   for (octave_idx_type i = 0; i < a.rows (); i++)
     for (octave_idx_type j = 0; j < a.cols (); j++)
       elem (i, j) = static_cast<unsigned char> (a.elem (i, j));
 }
 
 ComplexMatrix::ComplexMatrix (const Matrix& re, const Matrix& im)
-  : MArray<Complex> (re.dims ())
+  : ComplexNDArray (re.dims ())
 {
   if (im.rows () != rows () || im.cols () != cols ())
     (*current_liboctave_error_handler) ("complex: internal error");
 
   octave_idx_type nel = numel ();
   for (octave_idx_type i = 0; i < nel; i++)
     xelem (i) = Complex (re(i), im(i));
 }
@@ -463,17 +464,17 @@ ComplexMatrix::insert (const DiagMatrix&
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::insert (const ComplexMatrix& a,
                        octave_idx_type r, octave_idx_type c)
 {
-  Array<Complex>::insert (a, r, c);
+  ComplexNDArray::insert (a, r, c);
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::insert (const ComplexRowVector& a,
                        octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_len = a.length ();
@@ -3243,17 +3244,17 @@ ComplexMatrix::sumsq (int dim) const
 Matrix ComplexMatrix::abs (void) const
 {
   return do_mx_unary_map<double, Complex, std::abs> (*this);
 }
 
 ComplexMatrix
 ComplexMatrix::diag (octave_idx_type k) const
 {
-  return MArray<Complex>::diag (k);
+  return ComplexNDArray::diag (k);
 }
 
 ComplexDiagMatrix
 ComplexMatrix::diag (octave_idx_type m, octave_idx_type n) const
 {
   ComplexDiagMatrix retval;
 
   octave_idx_type nr = rows ();
diff --git a/liboctave/array/CMatrix.h b/liboctave/array/CMatrix.h
--- a/liboctave/array/CMatrix.h
+++ b/liboctave/array/CMatrix.h
@@ -21,53 +21,54 @@ along with Octave; see the file COPYING.
 */
 
 #if !defined (octave_CMatrix_h)
 #define octave_CMatrix_h 1
 
 #include "MArray.h"
 #include "MDiagArray2.h"
 #include "MatrixType.h"
+#include "CNDArray.h"
 
 #include "mx-defs.h"
 #include "mx-op-decl.h"
 #include "oct-cmplx.h"
 #include "DET.h"
 
 class
 OCTAVE_API
-ComplexMatrix : public MArray<Complex>
+ComplexMatrix : public ComplexNDArray
 {
 public:
 
   typedef ComplexColumnVector column_vector_type;
   typedef ComplexRowVector row_vector_type;
 
   typedef void (*solve_singularity_handler) (double rcon);
 
-  ComplexMatrix (void) : MArray<Complex> () { }
+  ComplexMatrix (void) : ComplexNDArray () { }
 
   ComplexMatrix (octave_idx_type r, octave_idx_type c)
-    : MArray<Complex> (dim_vector (r, c)) { }
+    : ComplexNDArray (dim_vector (r, c)) { }
 
   ComplexMatrix (octave_idx_type r, octave_idx_type c, const Complex& val)
-    : MArray<Complex> (dim_vector (r, c), val) { }
+    : ComplexNDArray (dim_vector (r, c), val) { }
 
-  ComplexMatrix (const dim_vector& dv) : MArray<Complex> (dv.redim (2)) { }
+  ComplexMatrix (const dim_vector& dv) : ComplexNDArray (dv.redim (2)) { }
 
   ComplexMatrix (const dim_vector& dv, const Complex& val)
-    : MArray<Complex> (dv.redim (2), val) { }
+    : ComplexNDArray (dv.redim (2), val) { }
 
-  ComplexMatrix (const ComplexMatrix& a) : MArray<Complex> (a) { }
+  ComplexMatrix (const ComplexMatrix& a) : ComplexNDArray (a) { }
 
   template <class U>
-  ComplexMatrix (const MArray<U>& a) : MArray<Complex> (a.as_matrix ()) { }
+  ComplexMatrix (const MArray<U>& a) : ComplexNDArray (a.as_matrix ()) { }
 
   template <class U>
-  ComplexMatrix (const Array<U>& a) : MArray<Complex> (a.as_matrix ()) { }
+  ComplexMatrix (const Array<U>& a) : ComplexNDArray (a.as_matrix ()) { }
 
   ComplexMatrix (const Matrix& re, const Matrix& im);
 
   explicit ComplexMatrix (const Matrix& a);
 
   explicit ComplexMatrix (const RowVector& rv);
 
   explicit ComplexMatrix (const ColumnVector& cv);
@@ -81,17 +82,17 @@ public:
   explicit ComplexMatrix (const ComplexDiagMatrix& a);
 
   explicit ComplexMatrix (const boolMatrix& a);
 
   explicit ComplexMatrix (const charMatrix& a);
 
   ComplexMatrix& operator = (const ComplexMatrix& a)
   {
-    MArray<Complex>::operator = (a);
+    ComplexNDArray::operator = (a);
     return *this;
   }
 
   bool operator == (const ComplexMatrix& a) const;
   bool operator != (const ComplexMatrix& a) const;
 
   bool is_hermitian (void) const;
 
diff --git a/liboctave/array/CNDArray.cc b/liboctave/array/CNDArray.cc
--- a/liboctave/array/CNDArray.cc
+++ b/liboctave/array/CNDArray.cc
@@ -810,30 +810,16 @@ ComplexNDArray::insert (const ComplexNDA
 ComplexNDArray&
 ComplexNDArray::insert (const ComplexNDArray& a,
                         const Array<octave_idx_type>& ra_idx)
 {
   Array<Complex>::insert (a, ra_idx);
   return *this;
 }
 
-ComplexMatrix
-ComplexNDArray::matrix_value (void) const
-{
-  ComplexMatrix retval;
-
-  if (ndims () == 2)
-    retval = ComplexMatrix (Array<Complex> (*this));
-  else
-    (*current_liboctave_error_handler)
-      ("invalid conversion of ComplexNDArray to ComplexMatrix");
-
-  return retval;
-}
-
 void
 ComplexNDArray::increment_index (Array<octave_idx_type>& ra_idx,
                                  const dim_vector& dimensions,
                                  int start_dimension)
 {
   ::increment_index (ra_idx, dimensions, start_dimension);
 }
 
diff --git a/liboctave/array/CNDArray.h b/liboctave/array/CNDArray.h
--- a/liboctave/array/CNDArray.h
+++ b/liboctave/array/CNDArray.h
@@ -19,41 +19,36 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_CNDArray_h)
 #define octave_CNDArray_h 1
 
 #include "MArray.h"
-#include "CMatrix.h"
 
 #include "mx-defs.h"
 #include "mx-op-decl.h"
 #include "bsxfun-decl.h"
 
 class
 OCTAVE_API
 ComplexNDArray : public MArray<Complex>
 {
 public:
 
-  typedef ComplexMatrix matrix_type;
-
   ComplexNDArray (void) : MArray<Complex> () { }
 
   ComplexNDArray (const dim_vector& dv) : MArray<Complex> (dv) { }
 
   ComplexNDArray (const dim_vector& dv, const Complex& val)
     : MArray<Complex> (dv, val) { }
 
   ComplexNDArray (const ComplexNDArray& a) : MArray<Complex> (a) { }
 
-  ComplexNDArray (const ComplexMatrix& a) : MArray<Complex> (a) { }
-
   template <class U>
   ComplexNDArray (const MArray<U>& a) : MArray<Complex> (a) { }
 
   template <class U>
   ComplexNDArray (const Array<U>& a) : MArray<Complex> (a) { }
 
   ComplexNDArray (const charNDArray&);
 
@@ -119,18 +114,16 @@ public:
   ComplexNDArray ifourier (int dim = 1) const;
 
   ComplexNDArray fourier2d (void) const;
   ComplexNDArray ifourier2d (void) const;
 
   ComplexNDArray fourierNd (void) const;
   ComplexNDArray ifourierNd (void) const;
 
-  ComplexMatrix matrix_value (void) const;
-
   ComplexNDArray squeeze (void) const { return MArray<Complex>::squeeze (); }
 
   static void increment_index (Array<octave_idx_type>& ra_idx,
                                const dim_vector& dimensions,
                                int start_dimension = 0);
 
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
                                         const dim_vector& dimensions);
diff --git a/liboctave/array/CSparse.h b/liboctave/array/CSparse.h
--- a/liboctave/array/CSparse.h
+++ b/liboctave/array/CSparse.h
@@ -21,16 +21,17 @@ along with Octave; see the file COPYING.
 
 */
 
 #if !defined (octave_CSparse_h)
 #define octave_CSparse_h 1
 
 #include "dMatrix.h"
 #include "dNDArray.h"
+#include "CMatrix.h"
 #include "CNDArray.h"
 #include "dColVector.h"
 #include "CColVector.h"
 #include "oct-cmplx.h"
 
 #include "DET.h"
 #include "MSparse.h"
 #include "MSparse-defs.h"
diff --git a/liboctave/array/dMatrix.cc b/liboctave/array/dMatrix.cc
--- a/liboctave/array/dMatrix.cc
+++ b/liboctave/array/dMatrix.cc
@@ -241,50 +241,50 @@ extern "C"
                                const double*, const octave_idx_type&,
                                double*, double&
                                F77_CHAR_ARG_LEN_DECL);
 }
 
 // Matrix class.
 
 Matrix::Matrix (const RowVector& rv)
-  : MArray<double> (rv)
+  : NDArray (rv)
 {
 }
 
 Matrix::Matrix (const ColumnVector& cv)
-  : MArray<double> (cv)
+  : NDArray (cv)
 {
 }
 
 Matrix::Matrix (const DiagMatrix& a)
-  : MArray<double> (a.dims (), 0.0)
+  : NDArray (a.dims (), 0.0)
 {
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) = a.elem (i, i);
 }
 
 Matrix::Matrix (const PermMatrix& a)
-  : MArray<double> (a.dims (), 0.0)
+  : NDArray (a.dims (), 0.0)
 {
   const Array<octave_idx_type> ia (a.col_perm_vec ());
   octave_idx_type len = a.rows ();
   for (octave_idx_type i = 0; i < len; i++)
     elem (ia(i), i) = 1.0;
 }
 
 // FIXME: could we use a templated mixed-type copy function here?
 
 Matrix::Matrix (const boolMatrix& a)
-  : MArray<double> (a)
+  : NDArray (a)
 {
 }
 
 Matrix::Matrix (const charMatrix& a)
-  : MArray<double> (a.dims ())
+  : NDArray (a.dims ())
 {
   for (octave_idx_type i = 0; i < a.rows (); i++)
     for (octave_idx_type j = 0; j < a.cols (); j++)
       elem (i, j) = static_cast<unsigned char> (a.elem (i, j));
 }
 
 bool
 Matrix::operator == (const Matrix& a) const
@@ -2795,17 +2795,17 @@ Matrix
 Matrix::abs (void) const
 {
   return do_mx_unary_map<double, double, std::abs> (*this);
 }
 
 Matrix
 Matrix::diag (octave_idx_type k) const
 {
-  return MArray<double>::diag (k);
+  return NDArray::diag (k);
 }
 
 DiagMatrix
 Matrix::diag (octave_idx_type m, octave_idx_type n) const
 {
   DiagMatrix retval;
 
   octave_idx_type nr = rows ();
diff --git a/liboctave/array/dMatrix.h b/liboctave/array/dMatrix.h
--- a/liboctave/array/dMatrix.h
+++ b/liboctave/array/dMatrix.h
@@ -18,55 +18,56 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_dMatrix_h)
 #define octave_dMatrix_h 1
 
+#include "dNDArray.h"
 #include "MArray.h"
 #include "MDiagArray2.h"
 #include "MatrixType.h"
 
 #include "mx-defs.h"
 #include "mx-op-decl.h"
 #include "DET.h"
 
 class
 OCTAVE_API
-Matrix : public MArray<double>
+Matrix : public NDArray
 {
 public:
 
   typedef ColumnVector column_vector_type;
   typedef RowVector row_vector_type;
 
   typedef void (*solve_singularity_handler) (double rcon);
 
-  Matrix (void) : MArray<double> () { }
+  Matrix (void) : NDArray () { }
 
   Matrix (octave_idx_type r, octave_idx_type c)
-    : MArray<double> (dim_vector (r, c)) { }
+    : NDArray (dim_vector (r, c)) { }
 
   Matrix (octave_idx_type r, octave_idx_type c, double val)
-    : MArray<double> (dim_vector (r, c), val) { }
+    : NDArray (dim_vector (r, c), val) { }
 
-  Matrix (const dim_vector& dv) : MArray<double> (dv.redim (2)) { }
+  Matrix (const dim_vector& dv) : NDArray (dv.redim (2)) { }
 
   Matrix (const dim_vector& dv, double val)
-    : MArray<double> (dv.redim (2), val) { }
+    : NDArray (dv.redim (2), val) { }
 
-  Matrix (const Matrix& a) : MArray<double> (a) { }
+  Matrix (const Matrix& a) : NDArray (a) { }
 
   template <class U>
-  Matrix (const MArray<U>& a) : MArray<double> (a.as_matrix ()) { }
+  Matrix (const MArray<U>& a) : NDArray (a.as_matrix ()) { }
 
   template <class U>
-  Matrix (const Array<U>& a) : MArray<double> (a.as_matrix ()) { }
+  Matrix (const Array<U>& a) : NDArray (a.as_matrix ()) { }
 
   explicit Matrix (const RowVector& rv);
 
   explicit Matrix (const ColumnVector& cv);
 
   explicit Matrix (const DiagMatrix& a);
 
   explicit Matrix (const PermMatrix& a);
diff --git a/liboctave/array/dNDArray.cc b/liboctave/array/dNDArray.cc
--- a/liboctave/array/dNDArray.cc
+++ b/liboctave/array/dNDArray.cc
@@ -836,30 +836,16 @@ NDArray::isinf (void) const
 }
 
 boolNDArray
 NDArray::isfinite (void) const
 {
   return do_mx_unary_map<bool, double, xfinite> (*this);
 }
 
-Matrix
-NDArray::matrix_value (void) const
-{
-  Matrix retval;
-
-  if (ndims () == 2)
-    retval = Matrix (Array<double> (*this));
-  else
-    (*current_liboctave_error_handler)
-      ("invalid conversion of NDArray to Matrix");
-
-  return retval;
-}
-
 void
 NDArray::increment_index (Array<octave_idx_type>& ra_idx,
                           const dim_vector& dimensions,
                           int start_dimension)
 {
   ::increment_index (ra_idx, dimensions, start_dimension);
 }
 
diff --git a/liboctave/array/dNDArray.h b/liboctave/array/dNDArray.h
--- a/liboctave/array/dNDArray.h
+++ b/liboctave/array/dNDArray.h
@@ -19,42 +19,37 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_dNDArray_h)
 #define octave_dNDArray_h 1
 
 #include "MArray.h"
-#include "dMatrix.h"
 #include "intNDArray.h"
 
 #include "mx-defs.h"
 #include "mx-op-decl.h"
 #include "bsxfun-decl.h"
 
 class
 OCTAVE_API
 NDArray : public MArray<double>
 {
 public:
 
-  typedef Matrix matrix_type;
-
   NDArray (void) : MArray<double> () { }
 
   NDArray (const dim_vector& dv) : MArray<double> (dv) { }
 
   NDArray (const dim_vector& dv, double val)
     : MArray<double> (dv, val) { }
 
   NDArray (const NDArray& a) : MArray<double> (a) { }
 
-  NDArray (const Matrix& a) : MArray<double> (a) { }
-
   NDArray (const Array<octave_idx_type>& a, bool zero_based = false,
            bool negative_to_nan = false);
 
   template <class U>
   NDArray (const MArray<U>& a) : MArray<double> (a) { }
 
   template <class U>
   NDArray (const Array<U>& a) : MArray<double> (a) { }
@@ -136,18 +131,16 @@ public:
   ComplexNDArray fourierNd (void) const;
   ComplexNDArray ifourierNd (void) const;
 
   friend OCTAVE_API NDArray real (const ComplexNDArray& a);
   friend OCTAVE_API NDArray imag (const ComplexNDArray& a);
 
   friend class ComplexNDArray;
 
-  Matrix matrix_value (void) const;
-
   NDArray squeeze (void) const { return MArray<double>::squeeze (); }
 
   static void increment_index (Array<octave_idx_type>& ra_idx,
                                const dim_vector& dimensions,
                                int start_dimension = 0);
 
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
                                         const dim_vector& dimensions);
diff --git a/liboctave/array/fCMatrix.cc b/liboctave/array/fCMatrix.cc
--- a/liboctave/array/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -36,16 +36,17 @@ along with Octave; see the file COPYING.
 #include <sys/types.h>
 
 #include "Array-util.h"
 #include "DET.h"
 #include "f77-fcn.h"
 #include "boolMatrix.h"
 #include "chMatrix.h"
 #include "fCMatrix.h"
+#include "fCNDArray.h"
 #include "fCDiagMatrix.h"
 #include "fCColVector.h"
 #include "fCRowVector.h"
 #include "fCmplxCHOL.h"
 #include "fCmplxSCHUR.h"
 #include "fCmplxSVD.h"
 #include "functor.h"
 #include "lo-error.h"
@@ -263,73 +264,73 @@ extern "C"
 }
 
 static const FloatComplex FloatComplex_NaN_result (octave_Float_NaN,
                                                    octave_Float_NaN);
 
 // FloatComplex Matrix class
 
 FloatComplexMatrix::FloatComplexMatrix (const FloatMatrix& a)
-  : MArray<FloatComplex> (a)
+  : FloatComplexNDArray (a)
 {
 }
 
 FloatComplexMatrix::FloatComplexMatrix (const FloatRowVector& rv)
-  : MArray<FloatComplex> (rv)
+  : FloatComplexNDArray (rv)
 {
 }
 
 FloatComplexMatrix::FloatComplexMatrix (const FloatColumnVector& cv)
-  : MArray<FloatComplex> (cv)
+  : FloatComplexNDArray (cv)
 {
 }
 
 FloatComplexMatrix::FloatComplexMatrix (const FloatDiagMatrix& a)
-  : MArray<FloatComplex> (a.dims (), 0.0)
+  : FloatComplexNDArray (a.dims (), 0.0)
 {
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) = a.elem (i, i);
 }
 
 FloatComplexMatrix::FloatComplexMatrix (const FloatComplexRowVector& rv)
-  : MArray<FloatComplex> (rv)
+  : FloatComplexNDArray (rv)
 {
 }
 
 FloatComplexMatrix::FloatComplexMatrix (const FloatComplexColumnVector& cv)
-  : MArray<FloatComplex> (cv)
+  : FloatComplexNDArray (cv)
 {
 }
 
 FloatComplexMatrix::FloatComplexMatrix (const FloatComplexDiagMatrix& a)
-  : MArray<FloatComplex> (a.dims (), 0.0)
+  : FloatComplexNDArray (a.dims (), 0.0)
 {
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) = a.elem (i, i);
 }
 
 // FIXME: could we use a templated mixed-type copy function
 // here?
 
 FloatComplexMatrix::FloatComplexMatrix (const boolMatrix& a)
-  : MArray<FloatComplex> (a)
+  : FloatComplexNDArray (a)
 {
 }
 
 FloatComplexMatrix::FloatComplexMatrix (const charMatrix& a)
-  : MArray<FloatComplex> (a.dims (), 0.0)
+  : FloatComplexNDArray (a.dims (), 0.0)
 {
   for (octave_idx_type i = 0; i < a.rows (); i++)
     for (octave_idx_type j = 0; j < a.cols (); j++)
       elem (i, j) = static_cast<unsigned char> (a.elem (i, j));
 }
 
 FloatComplexMatrix::FloatComplexMatrix (const FloatMatrix& re,
                                         const FloatMatrix& im)
-  : MArray<FloatComplex> (re.dims ())
+  : FloatComplexNDArray (re.dims ())
 {
   if (im.rows () != rows () || im.cols () != cols ())
     (*current_liboctave_error_handler) ("complex: internal error");
 
   octave_idx_type nel = numel ();
   for (octave_idx_type i = 0; i < nel; i++)
     xelem (i) = FloatComplex (re(i), im(i));
 }
diff --git a/liboctave/array/fCMatrix.h b/liboctave/array/fCMatrix.h
--- a/liboctave/array/fCMatrix.h
+++ b/liboctave/array/fCMatrix.h
@@ -18,61 +18,62 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_fCMatrix_h)
 #define octave_fCMatrix_h 1
 
+#include "fCNDArray.h"
 #include "MArray.h"
 #include "MDiagArray2.h"
 #include "MatrixType.h"
 
 #include "mx-defs.h"
 #include "mx-op-decl.h"
 #include "oct-cmplx.h"
 #include "DET.h"
 
 class
 OCTAVE_API
-FloatComplexMatrix : public MArray<FloatComplex>
+FloatComplexMatrix : public FloatComplexNDArray
 {
 public:
 
   typedef FloatComplexColumnVector column_vector_type;
   typedef FloatComplexRowVector row_vector_type;
 
   typedef void (*solve_singularity_handler) (float rcon);
 
-  FloatComplexMatrix (void) : MArray<FloatComplex> () { }
+  FloatComplexMatrix (void) : FloatComplexNDArray () { }
 
   FloatComplexMatrix (octave_idx_type r, octave_idx_type c)
-    : MArray<FloatComplex> (dim_vector (r, c)) { }
+    : FloatComplexNDArray (dim_vector (r, c)) { }
 
   FloatComplexMatrix (octave_idx_type r, octave_idx_type c,
                       const FloatComplex& val)
-    : MArray<FloatComplex> (dim_vector (r, c), val) { }
+    : FloatComplexNDArray (dim_vector (r, c), val) { }
 
   FloatComplexMatrix (const dim_vector& dv)
-    : MArray<FloatComplex> (dv.redim (2)) { }
+    : FloatComplexNDArray (dv.redim (2)) { }
 
   FloatComplexMatrix (const dim_vector& dv, const FloatComplex& val)
-    : MArray<FloatComplex> (dv.redim (2), val) { }
+    : FloatComplexNDArray (dv.redim (2), val) { }
 
   FloatComplexMatrix (const FloatComplexMatrix& a)
-    : MArray<FloatComplex> (a) { }
+    : FloatComplexNDArray (a) { }
 
   template <class U>
   FloatComplexMatrix (const MArray<U>& a)
-    : MArray<FloatComplex> (a.as_matrix ()) { }
+    : FloatComplexNDArray (a.reshape (a.dims ().redim (2))) { }
 
   template <class U>
   FloatComplexMatrix (const Array<U>& a)
-    : MArray<FloatComplex> (a.as_matrix ()) { }
+    : FloatComplexNDArray (a.reshape (a.dims ().redim (2))) { }
 
   explicit FloatComplexMatrix (const FloatMatrix& a);
 
   explicit FloatComplexMatrix (const FloatRowVector& rv);
 
   explicit FloatComplexMatrix (const FloatColumnVector& cv);
 
   explicit FloatComplexMatrix (const FloatDiagMatrix& a);
diff --git a/liboctave/array/fCNDArray.cc b/liboctave/array/fCNDArray.cc
--- a/liboctave/array/fCNDArray.cc
+++ b/liboctave/array/fCNDArray.cc
@@ -821,30 +821,16 @@ FloatComplexNDArray::insert (const Float
 FloatComplexNDArray&
 FloatComplexNDArray::insert (const FloatComplexNDArray& a,
                              const Array<octave_idx_type>& ra_idx)
 {
   Array<FloatComplex>::insert (a, ra_idx);
   return *this;
 }
 
-FloatComplexMatrix
-FloatComplexNDArray::matrix_value (void) const
-{
-  FloatComplexMatrix retval;
-
-  if (ndims () == 2)
-    retval = FloatComplexMatrix (Array<FloatComplex> (*this));
-  else
-    (*current_liboctave_error_handler)
-      ("invalid conversion of FloatComplexNDArray to FloatComplexMatrix");
-
-  return retval;
-}
-
 void
 FloatComplexNDArray::increment_index (Array<octave_idx_type>& ra_idx,
                                       const dim_vector& dimensions,
                                       int start_dimension)
 {
   ::increment_index (ra_idx, dimensions, start_dimension);
 }
 
diff --git a/liboctave/array/fCNDArray.h b/liboctave/array/fCNDArray.h
--- a/liboctave/array/fCNDArray.h
+++ b/liboctave/array/fCNDArray.h
@@ -19,43 +19,37 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_fCNDArray_h)
 #define octave_fCNDArray_h 1
 
 #include "MArray.h"
-#include "fCMatrix.h"
 
 #include "mx-defs.h"
 #include "mx-op-decl.h"
 #include "bsxfun-decl.h"
 
 class
 OCTAVE_API
 FloatComplexNDArray : public MArray<FloatComplex>
 {
 public:
 
-  typedef FloatComplexMatrix matrix_type;
-
   FloatComplexNDArray (void) : MArray<FloatComplex> () { }
 
   FloatComplexNDArray (const dim_vector& dv) : MArray<FloatComplex> (dv) { }
 
   FloatComplexNDArray (const dim_vector& dv, const FloatComplex& val)
     : MArray<FloatComplex> (dv, val) { }
 
   FloatComplexNDArray (const FloatComplexNDArray& a)
     : MArray<FloatComplex> (a) { }
 
-  FloatComplexNDArray (const FloatComplexMatrix& a)
-    : MArray<FloatComplex> (a) { }
-
   template <class U>
   FloatComplexNDArray (const MArray<U>& a) : MArray<FloatComplex> (a) { }
 
   template <class U>
   FloatComplexNDArray (const Array<U>& a) : MArray<FloatComplex> (a) { }
 
   FloatComplexNDArray (const charNDArray&);
 
@@ -124,18 +118,16 @@ public:
   FloatComplexNDArray ifourier (int dim = 1) const;
 
   FloatComplexNDArray fourier2d (void) const;
   FloatComplexNDArray ifourier2d (void) const;
 
   FloatComplexNDArray fourierNd (void) const;
   FloatComplexNDArray ifourierNd (void) const;
 
-  FloatComplexMatrix matrix_value (void) const;
-
   FloatComplexNDArray squeeze (void) const
   { return MArray<FloatComplex>::squeeze (); }
 
   static void increment_index (Array<octave_idx_type>& ra_idx,
                                const dim_vector& dimensions,
                                int start_dimension = 0);
 
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
diff --git a/liboctave/array/fMatrix.cc b/liboctave/array/fMatrix.cc
--- a/liboctave/array/fMatrix.cc
+++ b/liboctave/array/fMatrix.cc
@@ -27,16 +27,17 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include <cfloat>
 
 #include <iostream>
 #include <vector>
 
+#include "fNDArray.h"
 #include "Array-util.h"
 #include "boolMatrix.h"
 #include "chMatrix.h"
 #include "fMatrix.h"
 #include "fDiagMatrix.h"
 #include "fCMatrix.h"
 #include "fColVector.h"
 #include "fRowVector.h"
@@ -243,50 +244,50 @@ extern "C"
                                const octave_idx_type&, const float*,
                                const octave_idx_type&, float*, float&
                                F77_CHAR_ARG_LEN_DECL);
 }
 
 // Matrix class.
 
 FloatMatrix::FloatMatrix (const FloatRowVector& rv)
-  : MArray<float> (rv)
+  : FloatNDArray (rv)
 {
 }
 
 FloatMatrix::FloatMatrix (const FloatColumnVector& cv)
-  : MArray<float> (cv)
+  : FloatNDArray (cv)
 {
 }
 
 FloatMatrix::FloatMatrix (const FloatDiagMatrix& a)
-  : MArray<float> (a.dims (), 0.0)
+  : FloatNDArray (a.dims (), 0.0)
 {
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) = a.elem (i, i);
 }
 
 FloatMatrix::FloatMatrix (const PermMatrix& a)
-  : MArray<float> (a.dims (), 0.0)
+  : FloatNDArray (a.dims (), 0.0)
 {
   const Array<octave_idx_type> ia (a.col_perm_vec ());
   octave_idx_type len = a.rows ();
   for (octave_idx_type i = 0; i < len; i++)
     elem (ia(i), i) = 1.0;
 }
 
 // FIXME: could we use a templated mixed-type copy function here?
 
 FloatMatrix::FloatMatrix (const boolMatrix& a)
-  : MArray<float> (a)
+  : FloatNDArray (a)
 {
 }
 
 FloatMatrix::FloatMatrix (const charMatrix& a)
-  : MArray<float> (a.dims ())
+  : FloatNDArray (a.dims ())
 {
   for (octave_idx_type i = 0; i < a.rows (); i++)
     for (octave_idx_type j = 0; j < a.cols (); j++)
       elem (i, j) = static_cast<unsigned char> (a.elem (i, j));
 }
 
 bool
 FloatMatrix::operator == (const FloatMatrix& a) const
diff --git a/liboctave/array/fMatrix.h b/liboctave/array/fMatrix.h
--- a/liboctave/array/fMatrix.h
+++ b/liboctave/array/fMatrix.h
@@ -18,69 +18,69 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_fMatrix_h)
 #define octave_fMatrix_h 1
 
+#include "fNDArray.h"
 #include "MArray.h"
 #include "MDiagArray2.h"
 #include "MatrixType.h"
 
 #include "mx-defs.h"
 #include "mx-op-decl.h"
 #include "DET.h"
 
 class
 OCTAVE_API
-FloatMatrix : public MArray<float>
+FloatMatrix : public FloatNDArray
 {
 public:
 
   typedef FloatColumnVector column_vector_type;
   typedef FloatRowVector row_vector_type;
 
   typedef void (*solve_singularity_handler) (float rcon);
 
-  FloatMatrix (void) : MArray<float> () { }
+  FloatMatrix (void) : FloatNDArray () { }
 
   FloatMatrix (octave_idx_type r, octave_idx_type c)
-    : MArray<float> (dim_vector (r, c)) { }
+    : FloatNDArray (dim_vector (r, c)) { }
 
   FloatMatrix (octave_idx_type r, octave_idx_type c, float val)
-    : MArray<float> (dim_vector (r, c), val) { }
+    : FloatNDArray (dim_vector (r, c), val) { }
 
-  FloatMatrix (const dim_vector& dv) : MArray<float> (dv.redim (2)) { }
+  FloatMatrix (const dim_vector& dv) : FloatNDArray (dv.redim (2)) { }
 
   FloatMatrix (const dim_vector& dv, float val)
-    : MArray<float> (dv.redim (2), val) { }
+    : FloatNDArray (dv.redim (2), val) { }
 
-  FloatMatrix (const FloatMatrix& a) : MArray<float> (a) { }
+  FloatMatrix (const FloatMatrix& a) : FloatNDArray (a) { }
 
   template <class U>
-  FloatMatrix (const MArray<U>& a) : MArray<float> (a.as_matrix ()) { }
+  FloatMatrix (const MArray<U>& a) : FloatNDArray (a.as_matrix ()) { }
 
   template <class U>
-  FloatMatrix (const Array<U>& a) : MArray<float> (a.as_matrix ()) { }
+  FloatMatrix (const Array<U>& a) : FloatNDArray (a.as_matrix ()) { }
 
   explicit FloatMatrix (const FloatRowVector& rv);
 
   explicit FloatMatrix (const FloatColumnVector& cv);
 
   explicit FloatMatrix (const FloatDiagMatrix& a);
 
   explicit FloatMatrix (const PermMatrix& a);
 
   explicit FloatMatrix (const boolMatrix& a);
 
   explicit FloatMatrix (const charMatrix& a);
 
-
   FloatMatrix& operator = (const FloatMatrix& a)
   {
     MArray<float>::operator = (a);
     return *this;
   }
 
   bool operator == (const FloatMatrix& a) const;
   bool operator != (const FloatMatrix& a) const;
diff --git a/liboctave/array/fNDArray.cc b/liboctave/array/fNDArray.cc
--- a/liboctave/array/fNDArray.cc
+++ b/liboctave/array/fNDArray.cc
@@ -807,30 +807,16 @@ FloatNDArray::isinf (void) const
 }
 
 boolNDArray
 FloatNDArray::isfinite (void) const
 {
   return do_mx_unary_map<bool, float, xfinite> (*this);
 }
 
-FloatMatrix
-FloatNDArray::matrix_value (void) const
-{
-  FloatMatrix retval;
-
-  if (ndims () == 2)
-    retval = FloatMatrix (Array<float> (*this));
-  else
-    (*current_liboctave_error_handler)
-      ("invalid conversion of FloatNDArray to FloatMatrix");
-
-  return retval;
-}
-
 void
 FloatNDArray::increment_index (Array<octave_idx_type>& ra_idx,
                                const dim_vector& dimensions,
                                int start_dimension)
 {
   ::increment_index (ra_idx, dimensions, start_dimension);
 }
 
diff --git a/liboctave/array/fNDArray.h b/liboctave/array/fNDArray.h
--- a/liboctave/array/fNDArray.h
+++ b/liboctave/array/fNDArray.h
@@ -19,42 +19,37 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_fNDArray_h)
 #define octave_fNDArray_h 1
 
 #include "MArray.h"
-#include "fMatrix.h"
 #include "intNDArray.h"
 
 #include "mx-defs.h"
 #include "mx-op-decl.h"
 #include "bsxfun-decl.h"
 
 class
 OCTAVE_API
 FloatNDArray : public MArray<float>
 {
 public:
 
-  typedef FloatMatrix matrix_type;
-
   FloatNDArray (void) : MArray<float> () { }
 
   FloatNDArray (const dim_vector& dv) : MArray<float> (dv) { }
 
   FloatNDArray (const dim_vector& dv, float val)
     : MArray<float> (dv, val) { }
 
   FloatNDArray (const FloatNDArray& a) : MArray<float> (a) { }
 
-  FloatNDArray (const FloatMatrix& a) : MArray<float> (a) { }
-
   template <class U>
   FloatNDArray (const MArray<U>& a) : MArray<float> (a) { }
 
   template <class U>
   FloatNDArray (const Array<U>& a) : MArray<float> (a) { }
 
   template <class U>
   explicit FloatNDArray (const intNDArray<U>& a) : MArray<float> (a) { }
@@ -132,18 +127,16 @@ public:
   FloatComplexNDArray fourierNd (void) const;
   FloatComplexNDArray ifourierNd (void) const;
 
   friend OCTAVE_API FloatNDArray real (const FloatComplexNDArray& a);
   friend OCTAVE_API FloatNDArray imag (const FloatComplexNDArray& a);
 
   friend class FloatComplexNDArray;
 
-  FloatMatrix matrix_value (void) const;
-
   FloatNDArray squeeze (void) const { return MArray<float>::squeeze (); }
 
   static void increment_index (Array<octave_idx_type>& ra_idx,
                                const dim_vector& dimensions,
                                int start_dimension = 0);
 
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
                                         const dim_vector& dimensions);
