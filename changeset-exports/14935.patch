# HG changeset patch
# User Max Brister <max@2bass.com>
# Date 1338833444 18000
#      Mon Jun 04 13:10:44 2012 -0500
# Node ID 5801e031a3b5eff3c1b8889e04269a224e3602a5
# Parent  4ec5f49cdfe4fef56ad1204f4a7ad285c4d89321
Place releases after last use and generalize dom visiting

diff --git a/src/pt-jit.cc b/src/pt-jit.cc
--- a/src/pt-jit.cc
+++ b/src/pt-jit.cc
@@ -334,40 +334,40 @@ jit_typeinfo::jit_typeinfo (llvm::Module
     }
 
   llvm::Type *void_t = llvm::Type::getVoidTy (context);
 
   // grab any
   fn = create_function ("octave_jit_grab_any", any, any);
                         
   engine->addGlobalMapping (fn, reinterpret_cast<void*>(&octave_jit_grab_any));
-  grab_fn.add_overload (fn, false, any, any);
+  grab_fn.add_overload (fn, false, false, any, any);
   grab_fn.stash_name ("grab");
 
   // grab scalar
   fn = create_identity (scalar);
-  grab_fn.add_overload (fn, false, scalar, scalar);
+  grab_fn.add_overload (fn, false, false, scalar, scalar);
 
   // grab index
   fn = create_identity (index);
-  grab_fn.add_overload (fn, false, index, index);
+  grab_fn.add_overload (fn, false, false, index, index);
 
   // release any
   fn = create_function ("octave_jit_release_any", void_t, any->to_llvm ());
   engine->addGlobalMapping (fn, reinterpret_cast<void*>(&octave_jit_release_any));
-  release_fn.add_overload (fn, false, 0, any);
+  release_fn.add_overload (fn, false, false, 0, any);
   release_fn.stash_name ("release");
 
   // release scalar
   fn = create_identity (scalar);
-  release_fn.add_overload (fn, false, 0, scalar);
+  release_fn.add_overload (fn, false, false, 0, scalar);
 
   // release index
   fn = create_identity (index);
-  release_fn.add_overload (fn, false, 0, index);
+  release_fn.add_overload (fn, false, false, 0, index);
 
   // now for binary scalar operations
   // FIXME: Finish all operations
   add_binary_op (scalar, octave_value::op_add, llvm::Instruction::FAdd);
   add_binary_op (scalar, octave_value::op_sub, llvm::Instruction::FSub);
   add_binary_op (scalar, octave_value::op_mul, llvm::Instruction::FMul);
   add_binary_op (scalar, octave_value::op_el_mul, llvm::Instruction::FMul);
 
@@ -396,33 +396,33 @@ jit_typeinfo::jit_typeinfo (llvm::Module
   fn = create_function ("octave_jit_for_range_init", index, range);
   llvm::BasicBlock *body = llvm::BasicBlock::Create (context, "body", fn); 
   builder.SetInsertPoint (body);
   {
     llvm::Value *zero = llvm::ConstantInt::get (index_t, 0);
     builder.CreateRet (zero);
   }
   llvm::verifyFunction (*fn);
-  for_init_fn.add_overload (fn, false, index, range);
+  for_init_fn.add_overload (fn, false, false, index, range);
 
   // bounds check for for loop
   for_check_fn.stash_name ("for_check");
 
   fn = create_function ("octave_jit_for_range_check", boolean, range, index);
   body = llvm::BasicBlock::Create (context, "body", fn);
   builder.SetInsertPoint (body);
   {
     llvm::Value *nelem
       = builder.CreateExtractValue (fn->arg_begin (), 3);
     llvm::Value *idx = ++fn->arg_begin ();
     llvm::Value *ret = builder.CreateICmpULT (idx, nelem);
     builder.CreateRet (ret);
   }
   llvm::verifyFunction (*fn);
-  for_check_fn.add_overload (fn, false, boolean, range, index);
+  for_check_fn.add_overload (fn, false, false, boolean, range, index);
 
   // index variabe for for loop
   for_index_fn.stash_name ("for_index");
 
   fn = create_function ("octave_jit_for_range_idx", scalar, range, index);
   body = llvm::BasicBlock::Create (context, "body", fn);
   builder.SetInsertPoint (body);
   {
@@ -432,74 +432,74 @@ jit_typeinfo::jit_typeinfo (llvm::Module
     llvm::Value *base = builder.CreateExtractValue (rng, 0);
     llvm::Value *inc = builder.CreateExtractValue (rng, 2);
 
     llvm::Value *ret = builder.CreateFMul (didx, inc);
     ret = builder.CreateFAdd (base, ret);
     builder.CreateRet (ret);
   }
   llvm::verifyFunction (*fn);
-  for_index_fn.add_overload (fn, false, scalar, range, index);
+  for_index_fn.add_overload (fn, false, false, scalar, range, index);
 
   // logically true
   // FIXME: Check for NaN
   fn = create_function ("octave_logically_true_scalar", boolean, scalar);
   body = llvm::BasicBlock::Create (context, "body", fn);
   builder.SetInsertPoint (body);
   {
     llvm::Value *zero = llvm::ConstantFP::get (scalar->to_llvm (), 0);
     llvm::Value *ret = builder.CreateFCmpUNE (fn->arg_begin (), zero);
     builder.CreateRet (ret);
   }
   llvm::verifyFunction (*fn);
-  logically_true.add_overload (fn, true, boolean, scalar);
+  logically_true.add_overload (fn, true, false, boolean, scalar);
 
   fn = create_function ("octave_logically_true_bool", boolean, boolean);
   body = llvm::BasicBlock::Create (context, "body", fn);
   builder.SetInsertPoint (body);
   builder.CreateRet (fn->arg_begin ());
   llvm::verifyFunction (*fn);
-  logically_true.add_overload (fn, false, boolean, boolean);
+  logically_true.add_overload (fn, false, false, boolean, boolean);
   logically_true.stash_name ("logically_true");
 
   casts[any->type_id ()].stash_name ("(any)");
   casts[scalar->type_id ()].stash_name ("(scalar)");
 
   // cast any <- scalar
   fn = create_function ("octave_jit_cast_any_scalar", any, scalar);
   engine->addGlobalMapping (fn, reinterpret_cast<void*> (&octave_jit_cast_any_scalar));
-  casts[any->type_id ()].add_overload (fn, false, any, scalar);
+  casts[any->type_id ()].add_overload (fn, false, false, any, scalar);
 
   // cast scalar <- any
   fn = create_function ("octave_jit_cast_scalar_any", scalar, any);
   engine->addGlobalMapping (fn, reinterpret_cast<void*> (&octave_jit_cast_scalar_any));
-  casts[scalar->type_id ()].add_overload (fn, false, scalar, any);
+  casts[scalar->type_id ()].add_overload (fn, false, false, scalar, any);
 
   // cast any <- any
   fn = create_identity (any);
-  casts[any->type_id ()].add_overload (fn, false, any, any);
+  casts[any->type_id ()].add_overload (fn, false, false, any, any);
 
   // cast scalar <- scalar
   fn = create_identity (scalar);
-  casts[scalar->type_id ()].add_overload (fn, false, scalar, scalar);
+  casts[scalar->type_id ()].add_overload (fn, false, false, scalar, scalar);
 }
 
 void
 jit_typeinfo::add_print (jit_type *ty, void *call)
 {
   std::stringstream name;
   name << "octave_jit_print_" << ty->name ();
 
   llvm::Type *void_t = llvm::Type::getVoidTy (context);
   llvm::Function *fn = create_function (name.str (), void_t,
                                         llvm::Type::getInt8PtrTy (context),
                                         ty->to_llvm ());
   engine->addGlobalMapping (fn, call);
 
-  jit_function::overload ol (fn, false, 0, string, ty);
+  jit_function::overload ol (fn, false, true, 0, string, ty);
   print_fn.add_overload (ol);
 }
 
 // FIXME: cp between add_binary_op, add_binary_icmp, and add_binary_fcmp
 void
 jit_typeinfo::add_binary_op (jit_type *ty, int op, int llvm_op)
 {
   std::stringstream fname;
@@ -512,17 +512,17 @@ jit_typeinfo::add_binary_op (jit_type *t
   builder.SetInsertPoint (block);
   llvm::Instruction::BinaryOps temp
     = static_cast<llvm::Instruction::BinaryOps>(llvm_op);
   llvm::Value *ret = builder.CreateBinOp (temp, fn->arg_begin (),
                                           ++fn->arg_begin ());
   builder.CreateRet (ret);
   llvm::verifyFunction (*fn);
 
-  jit_function::overload ol(fn, false, ty, ty, ty);
+  jit_function::overload ol(fn, false, false, ty, ty, ty);
   binary_ops[op].add_overload (ol);
 }
 
 void
 jit_typeinfo::add_binary_icmp (jit_type *ty, int op, int llvm_op)
 {
   std::stringstream fname;
   octave_value::binary_op ov_op = static_cast<octave_value::binary_op>(op);
@@ -534,17 +534,17 @@ jit_typeinfo::add_binary_icmp (jit_type 
   builder.SetInsertPoint (block);
   llvm::CmpInst::Predicate temp
     = static_cast<llvm::CmpInst::Predicate>(llvm_op);
   llvm::Value *ret = builder.CreateICmp (temp, fn->arg_begin (),
                                          ++fn->arg_begin ());
   builder.CreateRet (ret);
   llvm::verifyFunction (*fn);
 
-  jit_function::overload ol (fn, false, boolean, ty, ty);
+  jit_function::overload ol (fn, false, false, boolean, ty, ty);
   binary_ops[op].add_overload (ol);
 }
 
 void
 jit_typeinfo::add_binary_fcmp (jit_type *ty, int op, int llvm_op)
 {
   std::stringstream fname;
   octave_value::binary_op ov_op = static_cast<octave_value::binary_op>(op);
@@ -556,17 +556,17 @@ jit_typeinfo::add_binary_fcmp (jit_type 
   builder.SetInsertPoint (block);
   llvm::CmpInst::Predicate temp
     = static_cast<llvm::CmpInst::Predicate>(llvm_op);
   llvm::Value *ret = builder.CreateFCmp (temp, fn->arg_begin (),
                                          ++fn->arg_begin ());
   builder.CreateRet (ret);
   llvm::verifyFunction (*fn);
 
-  jit_function::overload ol (fn, false, boolean, ty, ty);
+  jit_function::overload ol (fn, false, false, boolean, ty, ty);
   binary_ops[op].add_overload (ol);
 }
 
 llvm::Function *
 jit_typeinfo::create_function (const llvm::Twine& name, llvm::Type *ret,
                                const std::vector<llvm::Type *>& args)
 {
   llvm::FunctionType *ft = llvm::FunctionType::get (ret, args, false);
@@ -661,16 +661,23 @@ JIT_VISIT_IR_NOTEMPLATE
 std::ostream&
 operator<< (std::ostream& os, const jit_value& value)
 {
   return value.short_print (os);
 }
 
 // -------------------- jit_instruction --------------------
 void
+jit_instruction::remove (void)
+{
+  if (mparent)
+    mparent->remove (mlocation);
+}
+
+void
 jit_instruction::push_variable (void)
 {
   if (tag ())
     tag ()->push (this);
 }
 
 void
 jit_instruction::pop_variable (void)
@@ -710,53 +717,70 @@ jit_instruction::stash_tag (jit_variable
   mtag.stash_value (atag, this);
 }
 
 // -------------------- jit_block --------------------
 jit_instruction *
 jit_block::prepend (jit_instruction *instr)
 {
   instructions.push_front (instr);
-  instr->stash_parent (this);
+  instr->stash_parent (this, instructions.begin ());
   return instr;
 }
 
 jit_instruction *
+jit_block::prepend_after_phi (jit_instruction *instr)
+{
+  // FIXME: Make this O(1)
+  for (iterator iter = begin (); iter != end (); ++iter)
+    {
+      jit_instruction *temp = *iter;
+      if (! temp->is_phi ())
+        {
+          insert_before (iter, instr);
+          return instr;
+        }
+    }
+
+  return append (instr);
+}
+
+jit_instruction *
 jit_block::append (jit_instruction *instr)
 {
   instructions.push_back (instr);
-  instr->stash_parent (this);
+  instr->stash_parent (this, --instructions.end ());
   return instr;
 }
 
 jit_instruction *
 jit_block::insert_before (iterator loc, jit_instruction *instr)
 {
-  instructions.insert (loc, instr);
-  instr->stash_parent (this);
+  iterator iloc = instructions.insert (loc, instr);
+  instr->stash_parent (this, iloc);
   return instr;
 }
 
 jit_instruction *
 jit_block::insert_after (iterator loc, jit_instruction *instr)
 {
   ++loc;
-  instructions.insert (loc, instr);
-  instr->stash_parent (this);
+  iterator iloc = instructions.insert (loc, instr);
+  instr->stash_parent (this, iloc);
   return instr;
 }
 
 jit_terminator *
 jit_block::terminator (void) const
 {
   if (instructions.empty ())
     return 0;
 
   jit_instruction *last = instructions.back ();
-  return dynamic_cast<jit_terminator *> (last);
+  return last->to_terminator ();
 }
 
 jit_block *
 jit_block::pred (size_t idx) const
 {
   // FIXME: Make this O(1)
   
   // here we get the use in backwards order. This means we preserve phi
@@ -920,71 +944,18 @@ jit_block::update_idom (size_t visit_cou
       idom = new_idom;
       return true;
     }
 
   return changed;
 }
 
 void
-jit_block::finish_phi (jit_block *apred)
-{
-  size_t pred_idx = pred_index (apred);
-  for (iterator iter = begin (); iter != end ()
-         && dynamic_cast<jit_phi *> (*iter); ++iter)
-    {
-      jit_instruction *phi = *iter;
-      jit_variable *var = phi->tag ();
-      phi->stash_argument (pred_idx, var->top ());
-    }
-}
-
-void
-jit_block::do_construct_ssa (jit_convert& convert, size_t visit_count)
+jit_block::pop_all (void)
 {
-  if (mvisit_count > visit_count)
-    return;
-  ++mvisit_count;
-
-  for (iterator iter = begin (); iter != end (); ++iter)
-    {
-      jit_instruction *instr = *iter;
-      bool isphi = dynamic_cast<jit_phi *> (instr);
-
-      if (! isphi)
-        {
-          for (size_t i = 0; i < instr->argument_count (); ++i)
-            {
-              jit_variable *var;
-              var = dynamic_cast<jit_variable *> (instr->argument (i));
-              if (var)
-                instr->stash_argument (i, var->top ());
-            }
-
-          // FIXME: Remove need for jit_store_argument dynamic cast
-          jit_variable *tag = instr->tag ();
-          if (tag && tag->has_top ()
-              && ! dynamic_cast<jit_store_argument *> (instr))
-            {
-              jit_call *rel = convert.create<jit_call> (jit_typeinfo::release,
-                                                        tag->top ());
-              insert_after (iter, rel);
-              ++iter;
-            }
-        }
-
-      instr->push_variable ();
-    }
-
-  for (size_t i = 0; i < succ_count (); ++i)
-    succ (i)->finish_phi (this);
-
-  for (size_t i = 0; i < dom_succ.size (); ++i)
-    dom_succ[i]->do_construct_ssa (convert, visit_count);
-
   for (iterator iter = begin (); iter != end (); ++iter)
     {
       jit_instruction *instr = *iter;
       instr->pop_variable ();
     }
 }
 
 void
@@ -1016,16 +987,28 @@ jit_block::idom_intersect (jit_block *b)
         j = j->idom;
     }
 
   return i;
 }
 
 // -------------------- jit_call --------------------
 bool
+jit_call::dead (void) const
+{
+  return ! has_side_effects () && use_count () == 0;
+}
+
+bool
+jit_call::almost_dead (void) const
+{
+  return ! has_side_effects () && use_count () <= 1;
+}
+
+bool
 jit_call::infer (void)
 {
   // FIXME: explain algorithm
   for (size_t i = 0; i < argument_count (); ++i)
     {
       already_infered[i] = argument_type (i);
       if (! already_infered[i])
         return false;
@@ -1077,42 +1060,40 @@ jit_convert::jit_convert (llvm::Module *
 
   construct_ssa (final_block);
 
   // initialize the worklist to instructions derived from constants
   for (std::list<jit_value *>::iterator iter = constants.begin ();
        iter != constants.end (); ++iter)
     append_users (*iter);
 
-#ifdef OCTAVE_JIT_DEBUG
-  print_blocks ("octave jit ir");
-#endif
-
   // FIXME: Describe algorithm here
   while (worklist.size ())
     {
       jit_instruction *next = worklist.front ();
       worklist.pop_front ();
 
       if (next->infer ())
         append_users (next);
     }
 
+  place_releases ();
+
 #ifdef OCTAVE_JIT_DEBUG
   std::cout << "-------------------- Compiling tree --------------------\n";
   std::cout << tee.str_print_code () << std::endl;
   print_blocks ("octave jit ir");
 #endif
 
   // for now just init arguments from entry, later we will have to do something
   // more interesting
   for (jit_block::iterator iter = entry_block->begin ();
        iter != entry_block->end (); ++iter)
     {
-      if (jit_extract_argument *extract = dynamic_cast<jit_extract_argument *> (*iter))
+      if (jit_extract_argument *extract = (*iter)->to_extract_argument ())
         arguments.push_back (std::make_pair (extract->name (), true));
     }
 
   convert_llvm to_llvm;
   function = to_llvm.convert (module, arguments, blocks);
 
 #ifdef OCTAVE_JIT_DEBUG
   std::cout << "-------------------- llvm ir --------------------";
@@ -1709,17 +1690,17 @@ jit_convert::visit (tree& tee)
 void
 jit_convert::construct_ssa (jit_block *final_block)
 {
   final_block->label ();
   entry_block->compute_idom (final_block);
   entry_block->compute_df ();
   entry_block->create_dom_tree ();
 
-  // insert phi nodes where needed
+  // insert phi nodes where needed, this is done on a per variable basis
   for (vmap_t::iterator iter = vmap.begin (); iter != vmap.end (); ++iter)
     {
       jit_block::df_set visited, added_phi;
       std::list<jit_block *> ssa_worklist;
       iter->second->use_blocks (visited);
       ssa_worklist.insert (ssa_worklist.begin (), visited.begin (), visited.end ());
 
       while (ssa_worklist.size ())
@@ -1743,30 +1724,112 @@ jit_convert::construct_ssa (jit_block *f
                 {
                   ssa_worklist.push_back (dblock);
                   visited.insert (dblock);
                 }
             }
         }
     }
 
-  entry_block->construct_ssa (*this);
+  entry_block->visit_dom (&jit_convert::do_construct_ssa, &jit_block::pop_all);
 }
 
 void
-jit_convert::finish_breaks (jit_block *dest, const break_list& lst)
+jit_convert::do_construct_ssa (jit_block& block)
 {
-  for (break_list::const_iterator iter = lst.begin (); iter != lst.end ();
+  // replace variables with their current SSA value
+  for (jit_block::iterator iter = block.begin (); iter != block.end (); ++iter)
+    {
+      jit_instruction *instr = *iter;
+      if (! instr->is_phi ())
+        {
+          for (size_t i = 0; i < instr->argument_count (); ++i)
+            {
+              jit_variable *var;
+              var = instr->argument_variable (i);
+              assert (var == instr->argument (i)->to_variable ());
+              assert (var == dynamic_cast<jit_variable *> (instr->argument (i)));
+              if (var)
+                instr->stash_argument (i, var->top ());
+            }
+        }
+
+      instr->push_variable ();
+    }
+
+  // finish phi nodes of sucessors
+  for (size_t i = 0; i < block.succ_count (); ++i)
+    {
+      jit_block *finish = block.succ (i);
+      size_t pred_idx = finish->pred_index (&block);
+
+      for (jit_block::iterator iter = finish->begin (); iter != finish->end ()
+             && (*iter)->is_phi (); ++iter)
+        {
+          jit_instruction *phi = *iter;
+          jit_variable *var = phi->tag ();
+          phi->stash_argument (pred_idx, var->top ());
+        }
+    }
+}
+
+void
+jit_convert::place_releases (void)
+{
+  jit_convert::release_placer placer (*this);
+  entry_block->visit_dom (placer, &jit_block::pop_all);
+}
+
+void
+jit_convert::finish_breaks (jit_block *dest, const block_list& lst)
+{
+  for (block_list::const_iterator iter = lst.begin (); iter != lst.end ();
        ++iter)
     {
       jit_block *b = *iter;
       b->append (create<jit_break> (dest));
     }
 }
 
+// -------------------- jit_convert::release_placer --------------------
+void
+jit_convert::release_placer::operator() (jit_block& block)
+{
+  for (jit_block::iterator iter = block.begin (); iter != block.end (); ++iter)
+    {
+      jit_instruction *instr = *iter;
+      for (size_t i = 0; i < instr->argument_count (); ++i)
+        {
+          jit_instruction *arg = instr->argument_instruction (i);
+          if (arg && arg->tag ())
+            {
+              jit_variable *tag = arg->tag ();
+              tag->stash_last_use (instr);
+            }
+        }
+
+      jit_variable *tag = instr->tag ();
+      if (tag && ! (instr->is_phi () || instr->is_store_argument ())
+          && tag->has_top ())
+        {
+          jit_instruction *last_use = tag->last_use ();
+          jit_call *release = convert.create<jit_call> (jit_typeinfo::release,
+                                                        tag->top ());
+          release->infer ();
+          if (last_use && last_use->parent () == &block
+              && ! last_use->is_phi ())
+            block.insert_after (last_use->location (), release);
+          else
+            block.prepend_after_phi (release);
+        }
+
+      instr->push_variable ();
+    }
+}
+
 // -------------------- jit_convert::convert_llvm --------------------
 llvm::Function *
 jit_convert::convert_llvm::convert (llvm::Module *module,
                                     const std::vector<std::pair< std::string, bool> >& args,
                                     const std::list<jit_block *>& blocks)
 {
   jit_type *any = jit_typeinfo::get_any ();
 
@@ -1807,68 +1870,117 @@ jit_convert::convert_llvm::convert (llvm
       for (biter = blocks.begin (); biter != blocks.end (); ++biter)
         visit (*biter);
 
       // now finish phi nodes
       for (biter = blocks.begin (); biter != blocks.end (); ++biter)
         {
           jit_block& block = **biter;
           for (jit_block::iterator piter = block.begin ();
-               piter != block.end () && dynamic_cast<jit_phi *> (*piter); ++piter)
+               piter != block.end () && (*piter)->is_phi (); ++piter)
             {
-              // our phi nodes don't have to have the same incomming type,
-              // so we do casts here
               jit_instruction *phi = *piter;
-              jit_block *pblock = phi->parent ();
-              llvm::PHINode *llvm_phi = llvm::cast<llvm::PHINode> (phi->to_llvm ());
-              for (size_t i = 0; i < phi->argument_count (); ++i)
-                {
-                  llvm::BasicBlock *pred = pblock->pred_llvm (i);
-                  if (phi->argument_type_llvm (i) == phi->type_llvm ())
-                    {
-                      llvm_phi->addIncoming (phi->argument_llvm (i), pred);
-                    }
-                  else
-                    {
-                      // add cast right before pred terminator
-                      builder.SetInsertPoint (--pred->end ());
-
-                      const jit_function::overload& ol
-                        = jit_typeinfo::cast (phi->type (),
-                                              phi->argument_type (i));
-                      if (! ol.function)
-                        {
-                          std::stringstream ss;
-                          ss << "No cast for phi(" << i << "): ";
-                          phi->print (ss);
-                          fail (ss.str ());
-                        }
-
-                      llvm::Value *casted;
-                      casted = builder.CreateCall (ol.function,
-                                                   phi->argument_llvm (i));
-                      llvm_phi->addIncoming (casted, pred);
-                    }
-                }
+              finish_phi (phi);
             }
         }
 
       jit_block *last = blocks.back ();
       builder.SetInsertPoint (last->to_llvm ());
       builder.CreateRetVoid ();
     } catch (const jit_fail_exception& e)
     {
       function->eraseFromParent ();
       throw;
     }
 
   return function;
 }
 
 void
+jit_convert::convert_llvm::finish_phi (jit_instruction *phi)
+{
+  jit_block *pblock = phi->parent ();
+  llvm::PHINode *llvm_phi = llvm::cast<llvm::PHINode> (phi->to_llvm ());
+
+  bool can_remove = llvm_phi->use_empty ();
+  if (! can_remove && llvm_phi->hasOneUse () && phi->use_count () == 1)
+    {
+      jit_instruction *user = phi->first_use ()->user ();
+      can_remove = user->is_call (); // must be a remove
+    }
+
+  if (can_remove)
+    {
+      // replace with releases along each incomming branch
+      while (! llvm_phi->use_empty ())
+        {
+          llvm::Instruction *llvm_instr;
+          llvm_instr = llvm::cast<llvm::Instruction> (llvm_phi->use_back ());
+          llvm_instr->eraseFromParent ();
+        }
+
+      llvm_phi->eraseFromParent ();
+      phi->stash_llvm (0);
+
+      for (size_t i = 0; i < phi->argument_count (); ++i)
+        {
+          jit_value *arg = phi->argument (i);
+          if (arg->has_llvm () && phi->argument_type (i) != phi->type ())
+            {
+              llvm::BasicBlock *pred = pblock->pred_llvm (i);
+              builder.SetInsertPoint (--pred->end ());
+              const jit_function::overload& ol
+                = jit_typeinfo::get_release (phi->argument_type (i));
+              if (! ol.function)
+                {
+                  std::stringstream ss;
+                  ss << "No release for phi(" << i << "): ";
+                  phi->print (ss);
+                  fail (ss.str ());
+                }
+
+              builder.CreateCall (ol.function, phi->argument_llvm (i));
+            }
+        }
+    }
+  else
+    {
+      for (size_t i = 0; i < phi->argument_count (); ++i)
+        {
+          llvm::BasicBlock *pred = pblock->pred_llvm (i);
+          if (phi->argument_type (i) == phi->type ())
+            {
+              llvm_phi->addIncoming (phi->argument_llvm (i), pred);
+            }
+          else
+            {
+              // add cast right before pred terminator
+              builder.SetInsertPoint (--pred->end ());
+
+              const jit_function::overload& ol
+                = jit_typeinfo::cast (phi->type (),
+                                      phi->argument_type (i));
+              if (! ol.function)
+                {
+                  std::stringstream ss;
+                  ss << "No cast for phi(" << i << "): ";
+                  phi->print (ss);
+                  fail (ss.str ());
+                }
+
+              llvm::Value *casted;
+              casted = builder.CreateCall (ol.function,
+                                           phi->argument_llvm (i));
+              llvm_phi->addIncoming (casted, pred);
+            }
+        }
+    }
+}
+
+void
 jit_convert::convert_llvm::visit (jit_const_string& cs)
 {
   cs.stash_llvm (builder.CreateGlobalStringPtr (cs.value ()));
 }
 
 void
 jit_convert::convert_llvm::visit (jit_const_scalar& cs)
 {
diff --git a/src/pt-jit.h b/src/pt-jit.h
--- a/src/pt-jit.h
+++ b/src/pt-jit.h
@@ -158,55 +158,57 @@ private:
 std::ostream& jit_print (std::ostream& os, jit_type *atype);
 
 // Keeps track of overloads for a builtin function. Used for both type inference
 // and code generation.
 class
 jit_function
 {
 public:
-  struct overload
+  struct
+  overload
   {
     overload (void) : function (0), can_error (true), result (0) {}
 
-    overload (llvm::Function *f, bool e, jit_type *r, jit_type *arg0) :
-      function (f), can_error (e), result (r), arguments (1)
+    overload (llvm::Function *f, bool e, bool s, jit_type *r, jit_type *arg0) :
+      function (f), can_error (e), side_effects (s), result (r), arguments (1)
     {
       arguments[0] = arg0;
     }
 
-    overload (llvm::Function *f, bool e, jit_type *r, jit_type *arg0,
-              jit_type *arg1) : function (f), can_error (e), result (r),
-                                arguments (2)
+    overload (llvm::Function *f, bool e, bool s, jit_type *r, jit_type *arg0,
+              jit_type *arg1) : function (f), can_error (e), side_effects (s),
+                                result (r), arguments (2)
     {
       arguments[0] = arg0;
       arguments[1] = arg1;
     }
 
     llvm::Function *function;
     bool can_error;
+    bool side_effects;
     jit_type *result;
     std::vector<jit_type*> arguments;
   };
 
   void add_overload (const overload& func)
   {
     add_overload (func, func.arguments);
   }
 
-  void add_overload (llvm::Function *f, bool e, jit_type *r, jit_type *arg0)
+  void add_overload (llvm::Function *f, bool e, bool s, jit_type *r, jit_type *arg0)
   {
-    overload ol (f, e, r, arg0);
+    overload ol (f, e, s, r, arg0);
     add_overload (ol);
   }
 
-  void add_overload (llvm::Function *f, bool e, jit_type *r, jit_type *arg0,
+  void add_overload (llvm::Function *f, bool e, bool s, jit_type *r, jit_type *arg0,
                      jit_type *arg1)
   {
-    overload ol (f, e, r, arg0, arg1);
+    overload ol (f, e, s, r, arg0, arg1);
     add_overload (ol);
   }
 
   void add_overload (const overload& func,
                      const std::vector<jit_type*>& args);
 
   const overload& get_overload (const std::vector<jit_type *>& types) const;
 
@@ -288,16 +290,21 @@ public:
 
   static const jit_function& grab (void) { return instance->grab_fn; }
 
   static const jit_function& release (void)
   {
     return instance->release_fn;
   }
 
+  static const jit_function::overload& get_release (jit_type *type)
+  {
+    return instance->release_fn.get_overload (type);
+  }
+
   static const jit_function& print_value (void)
   {
     return instance->print_fn;
   }
 
   static const jit_function& for_init (void)
   {
     return instance->for_init_fn;
@@ -485,29 +492,64 @@ private:
   std::vector<llvm::Function *> identities;
 };
 
 // The low level octave jit ir
 // this ir is close to llvm, but contains information for doing type inference.
 // We convert the octave parse tree to this IR directly.
 
 #define JIT_VISIT_IR_NOTEMPLATE                 \
-  JIT_METH(block);                              \
-  JIT_METH(break);                              \
-  JIT_METH(cond_break);                         \
-  JIT_METH(call);                               \
-  JIT_METH(extract_argument);                   \
-  JIT_METH(store_argument);                     \
-  JIT_METH(phi);                                \
+  JIT_METH(block)                               \
+  JIT_METH(break)                               \
+  JIT_METH(cond_break)                          \
+  JIT_METH(call)                                \
+  JIT_METH(extract_argument)                    \
+  JIT_METH(store_argument)                      \
+  JIT_METH(phi)                                 \
   JIT_METH(variable)
 
+#define JIT_VISIT_IR_CONST                      \
+  JIT_METH(const_scalar)                        \
+  JIT_METH(const_index)                         \
+  JIT_METH(const_string)                        \
+  JIT_METH(const_range)
+
+#define JIT_VISIT_IR_ABSTRACT                   \
+  JIT_METH(instruction)                         \
+  JIT_METH(terminator)
+
 #define JIT_VISIT_IR_CLASSES                    \
-  JIT_VISIT_IR_NOTEMPLATE;                      \
+  JIT_VISIT_IR_NOTEMPLATE                       \
   JIT_VISIT_IR_CONST
 
+#define JIT_VISIT_IR_ALL                        \
+  JIT_VISIT_IR_CLASSES                          \
+  JIT_VISIT_IR_ABSTRACT
+
+// forward declare all ir classes
+#define JIT_METH(cname)                         \
+  class jit_ ## cname;
+
+JIT_VISIT_IR_ABSTRACT
+JIT_VISIT_IR_NOTEMPLATE
+
+#undef JIT_METH
+
+// constants are typedefs from jit_const
+template <typename T, jit_type *(*EXTRACT_T)(void), typename PASS_T = T,
+          bool QUOTE=false>
+class jit_const;
+
+typedef jit_const<double, jit_typeinfo::get_scalar> jit_const_scalar;
+typedef jit_const<octave_idx_type, jit_typeinfo::get_index> jit_const_index;
+
+typedef jit_const<std::string, jit_typeinfo::get_string, const std::string&, true>
+jit_const_string;
+typedef jit_const<jit_range, jit_typeinfo::get_range, const jit_range&>
+jit_const_range;
 
 class jit_ir_walker;
 class jit_use;
 
 class
 jit_value
 {
   friend class jit_use;
@@ -561,16 +603,32 @@ public:
     assert (llvm_value);
     return llvm_value;
   }
 
   void stash_llvm (llvm::Value *compiled)
   {
     llvm_value = compiled;
   }
+
+#define JIT_METH(cname)                                         \
+  virtual bool is_ ## cname (void) const                        \
+  { return false; }                                             \
+                                                                \
+  virtual jit_ ## cname *to_ ## cname (void)                    \
+  { return 0; }                                                 \
+                                                                \
+  virtual const jit_ ## cname *to_ ## cname (void) const        \
+  { return 0; }
+
+JIT_VISIT_IR_NOTEMPLATE
+JIT_VISIT_IR_ABSTRACT
+
+#undef JIT_METH
+
 protected:
   std::ostream& print_indent (std::ostream& os, size_t indent) const
   {
     for (size_t i = 0; i < indent * 8; ++i)
       os << " ";
     return os;
   }
 
@@ -578,18 +636,25 @@ protected:
 private:
   jit_type *ty;
   jit_use *use_head;
   size_t myuse_count;
 };
 
 std::ostream& operator<< (std::ostream& os, const jit_value& value);
 
-class jit_instruction;
-class jit_block;
+#define JIT_GEN_CASTS(cname)                                    \
+  virtual bool is_ ## cname (void) const                        \
+  { return true; }                                              \
+                                                                \
+  virtual jit_ ## cname *to_ ## cname (void)                    \
+  { return this; }                                              \
+                                                                \
+  virtual const jit_ ## cname *to_ ## cname (void) const        \
+  { return this; }
 
 class
 jit_use
 {
 public:
   jit_use (void) : mvalue (0), mnext (0), mprev (0), muser (0), mindex (0) {}
 
   // we should really have a move operator, but not until c++11 :(
@@ -610,16 +675,18 @@ public:
   jit_value *value (void) const { return mvalue; }
 
   size_t index (void) const { return mindex; }
 
   jit_instruction *user (void) const { return muser; }
 
   jit_block *user_parent (void) const;
 
+  std::list<jit_block *> user_parent_location (void) const;
+
   void stash_value (jit_value *avalue, jit_instruction *auser = 0,
                     size_t aindex = -1)
   {
     remove ();
 
     mvalue = avalue;
 
     if (mvalue)
@@ -663,18 +730,16 @@ private:
 
   jit_value *mvalue;
   jit_use *mnext;
   jit_use *mprev;
   jit_instruction *muser;
   size_t mindex;
 };
 
-class jit_variable;
-
 class
 jit_instruction : public jit_value
 {
 public:
   // FIXME: this code could be so much pretier with varadic templates...
   jit_instruction (void) : id (next_id ()), mparent (0)
   {}
 
@@ -733,16 +798,30 @@ public:
   }
 
   llvm::Type *argument_type_llvm (size_t i) const
   {
     assert (argument (i));
     return argument_type (i)->to_llvm ();
   }
 
+  // generate functions of form argument_type where type is any subclass of
+  // jit_value
+#define JIT_METH(cname)                                 \
+  jit_ ## cname *argument_ ## cname (size_t i) const    \
+  {                                                     \
+    jit_value *arg = argument (i);                      \
+    return arg ? arg->to_ ## cname () : 0;              \
+  }
+
+JIT_VISIT_IR_ABSTRACT
+JIT_VISIT_IR_NOTEMPLATE
+
+#undef JIT_METH
+
   std::ostream& print_argument (std::ostream& os, size_t i) const
   {
     if (argument (i))
       return argument (i)->short_print (os); 
     else
       return os << "NULL";
   }
 
@@ -765,37 +844,51 @@ public:
       for (size_t i = old; i < acount; ++i)
         stash_argument (i, adefault);
   }
 
   // argument types which have been infered already
   const std::vector<jit_type *>& argument_types (void) const
   { return already_infered; }
 
+  virtual bool dead (void) const { return false; }
+
+  virtual bool almost_dead (void) const { return false; }
+
   virtual bool infer (void) { return false; }
 
+  void remove (void);
+
   void push_variable (void);
 
   void pop_variable (void);
 
   virtual std::ostream& short_print (std::ostream& os) const;
 
   jit_block *parent (void) const { return mparent; }
 
+  std::list<jit_instruction *>::iterator location (void) const
+  {
+    return mlocation;
+  }
+
   llvm::BasicBlock *parent_llvm (void) const;
 
-  void stash_parent (jit_block *aparent)
+  void stash_parent (jit_block *aparent,
+                     std::list<jit_instruction *>::iterator alocation)
   {
-    assert (! mparent);
     mparent = aparent;
+    mlocation = alocation;
   }
 
   jit_variable *tag (void) const;
 
   void stash_tag (jit_variable *atag);
+
+  JIT_GEN_CASTS (instruction)
 protected:
   std::vector<jit_type *> already_infered;
 private:
   static size_t next_id (bool reset = false)
   {
     static size_t ret = 0;
     if (reset)
       return ret = 0;
@@ -804,24 +897,25 @@ private:
   }
 
   std::vector<jit_use> arguments;
 
   jit_use mtag;
 
   size_t id;
   jit_block *mparent;
+  std::list<jit_instruction *>::iterator mlocation;
 };
 
 // defnie accept methods for subclasses
 #define JIT_VALUE_ACCEPT(clname)                \
   virtual void accept (jit_ir_walker& walker);
 
-template <typename T, jit_type *(*EXTRACT_T)(void), typename PASS_T = T,
-          bool QUOTE=false>
+template <typename T, jit_type *(*EXTRACT_T)(void), typename PASS_T,
+          bool QUOTE>
 class
 jit_const : public jit_instruction
 {
 public:
   typedef PASS_T pass_t;
 
   jit_const (PASS_T avalue) : mvalue (avalue)
   {
@@ -842,34 +936,16 @@ public:
     return os;
   }
 
   JIT_VALUE_ACCEPT (jit_const);
 private:
   T mvalue;
 };
 
-typedef jit_const<double, jit_typeinfo::get_scalar> jit_const_scalar;
-typedef jit_const<octave_idx_type, jit_typeinfo::get_index> jit_const_index;
-
-typedef jit_const<std::string, jit_typeinfo::get_string, const std::string&, true>
-jit_const_string;
-typedef jit_const<jit_range, jit_typeinfo::get_range, const jit_range&>
-jit_const_range;
-
-#define JIT_VISIT_IR_CONST                      \
-  JIT_METH(const_scalar);                       \
-  JIT_METH(const_index);                        \
-  JIT_METH(const_string);                       \
-  JIT_METH(const_range)
-
-class jit_terminator;
-class jit_phi;
-class jit_convert;
-
 class
 jit_block : public jit_value
 {
 public:
   typedef std::list<jit_instruction *> instruction_list;
   typedef instruction_list::iterator iterator;
   typedef instruction_list::const_iterator const_iterator;
 
@@ -879,25 +955,29 @@ public:
   jit_block (const std::string& aname) : mvisit_count (0), mid (NO_ID), idom (0),
                                          mname (aname)
   {}
 
   const std::string& name (void) const { return mname; }
 
   jit_instruction *prepend (jit_instruction *instr);
 
+  jit_instruction *prepend_after_phi (jit_instruction *instr);
+
   jit_instruction *append (jit_instruction *instr);
 
   jit_instruction *insert_before (iterator loc, jit_instruction *instr);
 
   jit_instruction *insert_after (iterator loc, jit_instruction *instr);
 
   void remove (jit_block::iterator iter)
   {
+    jit_instruction *instr = *iter;
     instructions.erase (iter);
+    instr->stash_parent (0, instructions.end ());
   }
 
   jit_terminator *terminator (void) const;
 
   jit_block *pred (size_t idx) const;
 
   jit_terminator *pred_terminator (size_t idx) const
   {
@@ -996,21 +1076,28 @@ public:
     compute_df (mvisit_count);
   }
 
   void create_dom_tree (void)
   {
     create_dom_tree (mvisit_count);
   }
 
-  void construct_ssa (jit_convert& convert)
+  // visit blocks in the order of the dominator tree
+  // inorder - Run on the root first, then children
+  // postorder - Run on children first, then the root
+  template <typename func_type0, typename func_type1>
+  void visit_dom (func_type0 inorder, func_type1 postorder)
   {
-    do_construct_ssa (convert, mvisit_count);
+    do_visit_dom (mvisit_count, inorder, postorder);
   }
 
+  // call pop_varaible on all instructions
+  void pop_all (void);
+
   virtual std::ostream& print (std::ostream& os, size_t indent) const
   {
     print_indent (os, indent) << mname << ":        %pred = ";
     for (size_t i = 0; i < pred_count (); ++i)
       {
         print_pred (os, i);
         if (i + 1 < pred_count ())
           os << ", ";
@@ -1031,73 +1118,132 @@ public:
   virtual std::ostream& short_print (std::ostream& os) const
   {
     return os << mname;
   }
 
   llvm::BasicBlock *to_llvm (void) const;
 
   JIT_VALUE_ACCEPT (block)
+  JIT_GEN_CASTS (block)
 private:
   void compute_df (size_t visit_count);
 
   bool update_idom (size_t visit_count);
 
-  void finish_phi (jit_block *pred);
-
-  void do_construct_ssa (jit_convert& convert, size_t visit_count);
-
   void create_dom_tree (size_t visit_count);
 
   jit_block *idom_intersect (jit_block *b);
 
+  template <typename func_type0, typename func_type1>
+  void do_visit_dom (size_t visit_count, func_type0 inorder, func_type1 postorder);
+
   static const size_t NO_ID = static_cast<size_t> (-1);
   size_t mvisit_count;
   size_t mid;
   jit_block *idom;
   df_set mdf;
   std::vector<jit_block *> dom_succ;
   std::string mname;
   instruction_list instructions;
   mutable std::vector<llvm::BasicBlock *> mpred_llvm;
 };
 
+// allow regular function pointers as well as pointers to members
+template <typename func_type>
+class jit_block_callback
+{
+public:
+  jit_block_callback (func_type afunction) : function (afunction) {}
+
+  void operator() (jit_block& block)
+  {
+    function (block);
+  }
+private:
+  func_type function;
+};
+
+template <>
+class jit_block_callback<void (jit_block::*)(void)>
+{
+public:
+  typedef void (jit_block::*func_type)(void);
+
+  jit_block_callback (func_type afunction) : function (afunction) {}
+
+  void operator() (jit_block& ablock)
+  {
+    (ablock.*function) ();
+  }
+private:
+  func_type function;
+};
+
+template <typename func_type0, typename func_type1>
+void
+jit_block::do_visit_dom (size_t visit_count, func_type0 inorder, func_type1 postorder)
+{
+  if (mvisit_count > visit_count)
+    return;
+  mvisit_count = visit_count + 1;
+
+  jit_block_callback<func_type0> inorder_cb (inorder);
+  inorder_cb (*this);
+
+  for (size_t i = 0; i < dom_succ.size (); ++i)
+    dom_succ[i]->do_visit_dom (visit_count, inorder, postorder);
+
+  jit_block_callback<func_type1> postorder_cb (postorder);
+  postorder_cb (*this);
+}
 
 
 // A non-ssa variable
 class
 jit_variable : public jit_value
 {
 public:
-  jit_variable (const std::string& aname) : mname (aname) {}
+  jit_variable (const std::string& aname) : mname (aname), mlast_use (0) {}
 
   const std::string &name (void) const { return mname; }
 
   // manipulate the value_stack, for use during SSA construction. The top of the
   // value stack represents the current value for this variable
   bool has_top (void) const
   {
     return ! value_stack.empty ();
   }
 
   jit_value *top (void) const
   {
     return value_stack.top ();
   }
 
-  void push (jit_value *v)
+  void push (jit_instruction *v)
   {
     value_stack.push (v);
+    mlast_use = v;
   }
 
   void pop (void)
   {
     value_stack.pop ();
   }
 
+  jit_instruction *last_use (void) const
+  {
+    return mlast_use;
+  }
+
+  void stash_last_use (jit_instruction *instr)
+  {
+    mlast_use = instr;
+  }
+
   // blocks in which we are used
   void use_blocks (jit_block::df_set& result)
   {
     jit_use *use = first_use ();
     while (use)
       {
         result.insert (use->user_parent ());
         use = use->next ();
@@ -1105,31 +1251,43 @@ public:
   }
 
   virtual std::ostream& print (std::ostream& os, size_t indent) const
   {
     return print_indent (os, indent) << mname;
   }
 
   JIT_VALUE_ACCEPT (variable)
+  JIT_GEN_CASTS (variable)
 private:
   std::string mname;
   std::stack<jit_value *> value_stack;
+  jit_instruction *mlast_use;
 };
 
 class
 jit_phi : public jit_instruction
 {
 public:
   jit_phi (jit_variable *avariable, size_t npred)
     : jit_instruction (npred)
   {
     stash_tag (avariable);
   }
 
+  virtual bool dead (void) const
+  {
+    return use_count () == 0;
+  }
+
+  virtual bool almost_dead (void) const
+  {
+    return use_count () <= 1;
+  }
+
   virtual bool infer (void)
   {
     jit_type *infered = 0;
     for (size_t i = 0; i < argument_count (); ++i)
       infered = jit_typeinfo::join (infered, argument_type (i));
 
     if (infered != type ())
       {
@@ -1162,16 +1320,17 @@ public:
         if (i + 1 < argument_count ())
           os << std::endl;
       }
 
     return os;
   }
 
   JIT_VALUE_ACCEPT (phi);
+  JIT_GEN_CASTS (phi)
 };
 
 class
 jit_terminator : public jit_instruction
 {
 public:
   jit_terminator (jit_value *arg0) : jit_instruction (arg0) {}
 
@@ -1192,16 +1351,18 @@ public:
   }
 
   std::ostream& print_sucessor (std::ostream& os, size_t idx = 0) const
   {
     return sucessor (idx)->short_print (os);
   }
 
   virtual size_t sucessor_count (void) const = 0;
+
+  JIT_GEN_CASTS (terminator)
 };
 
 class
 jit_break : public jit_terminator
 {
 public:
   jit_break (jit_block *succ) : jit_terminator (succ) {}
 
@@ -1215,16 +1376,17 @@ public:
 
   virtual std::ostream& print (std::ostream& os, size_t indent) const
   {
     print_indent (os, indent) << "break: ";
     return print_sucessor (os);
   }
 
   JIT_VALUE_ACCEPT (break)
+  JIT_GEN_CASTS (break)
 };
 
 class
 jit_cond_break : public jit_terminator
 {
 public:
   jit_cond_break (jit_value *c, jit_block *ctrue, jit_block *cfalse)
     : jit_terminator (c, ctrue, cfalse) {}
@@ -1253,16 +1415,17 @@ public:
   {
     print_indent (os, indent) << "cond_break: ";
     print_cond (os) << ", ";
     print_sucessor (os, 0) << ", ";
     return print_sucessor (os, 1);
   }
 
   JIT_VALUE_ACCEPT (cond_break)
+  JIT_GEN_CASTS (cond_break)
 };
 
 class
 jit_call : public jit_instruction
 {
 public:
   jit_call (const jit_function& afunction,
             jit_value *arg0) : jit_instruction (arg0), mfunction (afunction) {}
@@ -1275,16 +1438,21 @@ public:
                                                 mfunction (afunction) {}
 
   jit_call (const jit_function& (*afunction) (void),
             jit_value *arg0, jit_value *arg1) : jit_instruction (arg0, arg1),
                                                 mfunction (afunction ()) {}
 
   const jit_function& function (void) const { return mfunction; }
 
+  bool has_side_effects (void) const
+  {
+    return overload ().side_effects;
+  }
+
   const jit_function::overload& overload (void) const
   {
     return mfunction.get_overload (argument_types ());
   }
 
   virtual std::ostream& print (std::ostream& os, size_t indent) const
   {
     print_indent (os, indent);
@@ -1297,19 +1465,24 @@ public:
       {
         print_argument (os, i);
         if (i + 1 < argument_count ())
           os << ", ";
       }
     return os << ")";
   }
 
+  virtual bool dead (void) const;
+
+  virtual bool almost_dead (void) const;
+
   virtual bool infer (void);
 
   JIT_VALUE_ACCEPT (call)
+  JIT_GEN_CASTS (call)
 private:
   const jit_function& mfunction;
 };
 
 class
 jit_extract_argument : public jit_instruction
 {
 public:
@@ -1334,16 +1507,17 @@ public:
   {
     print_indent (os, indent);
     os << "exract ";
     short_print (os);
     return os;
   }
 
   JIT_VALUE_ACCEPT (extract_argument)
+  JIT_GEN_CASTS (extract_argument)
 };
 
 class
 jit_store_argument : public jit_instruction
 {
 public:
   jit_store_argument (jit_variable *var)
     : jit_instruction (var)
@@ -1380,26 +1554,27 @@ public:
   {
     jit_value *res = result ();
     print_indent (os, indent) << "store ";
     short_print (os) << " = ";
     return res->short_print (os);
   }
 
   JIT_VALUE_ACCEPT (store_argument)
+  JIT_GEN_CASTS (store_argument)
 };
 
 class
 jit_ir_walker
 {
 public:
   virtual ~jit_ir_walker () {}
 
 #define JIT_METH(clname) \
-  virtual void visit (jit_ ## clname&) = 0
+  virtual void visit (jit_ ## clname&) = 0;
 
   JIT_VISIT_IR_CLASSES;
 
 #undef JIT_METH
 };
 
 template <typename T, jit_type *(*EXTRACT_T)(void), typename PASS_T, bool QUOTE>
 void
@@ -1543,16 +1718,19 @@ public:
   template <typename T, typename ARG0, typename ARG1, typename ARG2>
   T *create (const ARG0& arg0, const ARG1& arg1, const ARG2& arg2)
   {
     T *ret = new T(arg0, arg1, arg2);
     track_value (ret);
     return ret;
   }
 private:
+  typedef std::list<jit_block *> block_list;
+  typedef block_list::iterator block_iterator;
+
   std::vector<std::pair<std::string, bool> > arguments;
   type_bound_vector bounds;
 
   // used instead of return values from visit_* functions
   jit_instruction *result;
 
   jit_block *entry_block;
 
@@ -1592,16 +1770,20 @@ private:
   {
     if (value->type ())
       constants.push_back (value);
     all_values.push_back (value);
   }
 
   void construct_ssa (jit_block *final_block);
 
+  static void do_construct_ssa (jit_block& block);
+
+  void place_releases (void);
+
   void print_blocks (const std::string& header)
   {
     std::cout << "-------------------- " << header << " --------------------\n";
     for (std::list<jit_block *>::iterator iter = blocks.begin ();
          iter != blocks.end (); ++iter)
       {
         assert (*iter);
         (*iter)->print (std::cout, 0);
@@ -1616,23 +1798,30 @@ private:
          iter != blocks.end (); ++iter)
       {
         assert (*iter);
         (*iter)->print_dom (std::cout);
       }
     std::cout << std::endl;
   }
 
-  typedef std::list<jit_block *> break_list;
+  bool breaking; // true if we are breaking OR continuing
+  block_list breaks;
+  block_list continues;
+
+  void finish_breaks (jit_block *dest, const block_list& lst);
 
-  bool breaking; // true if we are breaking OR continuing
-  break_list breaks;
-  break_list continues;
+  struct release_placer
+  {
+    release_placer (jit_convert& aconvert) : convert (aconvert) {}
 
-  void finish_breaks (jit_block *dest, const break_list& lst);
+    jit_convert& convert;
+
+    void operator() (jit_block& block);
+  };
 
   // this case is much simpler, just convert from the jit ir to llvm
   class
   convert_llvm : public jit_ir_walker
   {
   public:
     llvm::Function *convert (llvm::Module *module,
                              const std::vector<std::pair<std::string, bool> >& args,
@@ -1643,16 +1832,17 @@ private:
 
     JIT_VISIT_IR_CLASSES;
 
 #undef JIT_METH
   private:
     // name -> llvm argument
     std::map<std::string, llvm::Value *> arguments;
 
+    void finish_phi (jit_instruction *phi);
 
     void visit (jit_value *jvalue)
     {
       return visit (*jvalue);
     }
 
     void visit (jit_value &jvalue)
     {
