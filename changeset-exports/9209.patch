# HG changeset patch
# User Rik <rdrider0-list@yahoo.com>
# Date 1242587886 25200
#      Sun May 17 12:18:06 2009 -0700
# Node ID 923c7cb7f13f3774811cf7504a9e0e221ead7c84
# Parent  cb163402bf794c145f5bbbf3a0adb39137b9164d
Simplify TeXinfo files by eliminating redundant @iftex followed by @tex construction.

spellchecked all .txi and .texi files.

diff --git a/doc/ChangeLog b/doc/ChangeLog
--- a/doc/ChangeLog
+++ b/doc/ChangeLog
@@ -1,8 +1,13 @@
+2009-05-17  Rik  <rdrider0-list@yahoo.com>
+
+	* interpreter/*.txi: Simplify TeXinfo files by eliminating redundant @iftex
+	followed by @tex construction.  Also, spellchecked all .txi and .texi files.
+
 2009-05-14  Rik  <rdrider0-list@yahoo.com>
 
 	* interpreter/arith.txi: Update section 17.8 (Mathematical Consants)
 	of arith.txi.
 
 2009-05-01  Rik  <rdrider0-list@yahoo.com>
 
 	* interpreter/arith.txi: Update section 17.7 (Coordinate
diff --git a/doc/interpreter/arith.txi b/doc/interpreter/arith.txi
--- a/doc/interpreter/arith.txi
+++ b/doc/interpreter/arith.txi
@@ -72,22 +72,20 @@ sin ([1, 2; 3, 4])
 @DOCSTRING(realsqrt)
 
 @DOCSTRING(sqrt)
 
 @node Complex Arithmetic
 @section Complex Arithmetic
 
 In the descriptions of the following functions,
-@iftex
 @tex
 $z$ is the complex number $x + iy$, where $i$ is defined as
 $\sqrt{-1}$.
 @end tex
-@end iftex
 @ifinfo
 @var{z} is the complex number @var{x} + @var{i}@var{y}, where @var{i} is
 defined as @code{sqrt (-1)}.
 @end ifinfo
 
 @DOCSTRING(abs)
 
 @DOCSTRING(arg)
diff --git a/doc/interpreter/container.txi b/doc/interpreter/container.txi
--- a/doc/interpreter/container.txi
+++ b/doc/interpreter/container.txi
@@ -317,17 +317,16 @@ ans =
 @end group
 @end example
 
 Elements can be deleted from a structure array in a similar manner to a
 numerical array, by assigning the elements to an empty matrix.  For
 example
 
 @example
-@group
 in = struct ("call1", @{x, Inf, "last"@}, 
              "call2", @{x, Inf, "first"@});
 in (1, :) = []
 @result{} in =
       @{
         call1 =
       
         (,
@@ -338,17 +337,16 @@ in (1, :) = []
         call2 =
       
         (,
           [1] = Inf
           [2] = first
         ,)
       
       @}
-@end group
 @end example
 
 @node Creating Structures
 @subsection Creating Structures
 
 As well as indexing a structure with ".", Octave can create a structure
 with the @code{struct} command.  @code{struct} takes pairs of arguments,
 where the first argument in the pair is the fieldname to include in the
@@ -366,17 +364,16 @@ struct ("field1", 1, "field2", 2)
 @end group
 @end example
 
 If the values passed to @code{struct} are a mix of scalar and cell
 arrays, then the scalar arguments are expanded to create a 
 structure array with a consistent dimension.  For example
 
 @example
-@group
 struct ("field1", @{1, "one"@}, "field2", @{2, "two"@},
         "field3", 3)
 @result{} ans =
       @{
         field1 =
       
         (,
           [1] =  1
@@ -393,17 +390,16 @@ struct ("field1", @{1, "one"@}, "field2"
         field3 =
       
         (,
           [1] =  3
           [2] =  3
         ,)
       
       @}
-@end group
 @end example
 
 @DOCSTRING(struct)
 
 @DOCSTRING(isstruct)
 
 Additional functions that can manipulate the fields of a structure are
 listed below.
@@ -553,29 +549,31 @@ c = cell(2,2)
 Just like numerical arrays, cell arrays can be multidimensional.  The
 @code{cell} function accepts any number of positive integers to describe
 the size of the returned cell array.  It is also possible to set the size
 of the cell array through a vector of positive integers.  In the
 following example two cell arrays of equal size are created, and the size
 of the first one is displayed
 
 @example
+@group
 c1 = cell(3, 4, 5);
 c2 = cell( [3, 4, 5] );
 size(c1)
      @result{} ans =
          3   4   5
+@end group
 @end example
 
 @noindent
 As can be seen, the @code{size} function also works for cell arrays.  As
 do the other functions describing the size of an object, such as
 @code{length}, @code{numel}, @code{rows}, and @code{columns}.
 
-As an alternative to creating empty cell arrays, and then filling them,  it
+As an alternative to creating empty cell arrays, and then filling them, it
 is possible to convert numerical arrays into cell arrays using the
 @code{num2cell} and @code{mat2cell} functions.
 
 @DOCSTRING(cell)
 
 @DOCSTRING(iscell)
 
 @DOCSTRING(num2cell)
@@ -646,38 +644,42 @@ One common use of cell arrays is to stor
 variable.  It is possible to store multiple strings in a character matrix
 by letting each row be a string.  This, however, introduces the problem
 that all strings must be of equal length.  Therefore it is recommended to
 use cell arrays to store multiple strings.  If, however, the character
 matrix representation is required for an operation, it can be converted
 to a cell array of strings using the @code{cellstr} function
 
 @example
+@group
 a = ["hello"; "world"];
 c = cellstr (a)
      @result{} c =
          @{
            [1,1] = hello
            [2,1] = world
          @}
+@end group
 @end example
 
 One further advantage of using cell arrays to store multiple strings is
 that most functions for string manipulations included with Octave
 support this representation.  As an example, it is possible to compare
 one string with many others using the @code{strcmp} function.  If one of
 the arguments to this function is a string and the other is a cell array
 of strings, each element of the cell array will be compared the string
 argument,
 
 @example
+@group
 c = @{"hello", "world"@};
 strcmp ("hello", c)
      @result{} ans =
         1   0
+@end group
 @end example
 
 @noindent
 The following functions for string manipulation support cell arrays of
 strings, @code{strcmp}, @code{strcmpi}, @code{strncmp}, @code{strncmpi}, 
 @code{str2double}, @code{char}, @code{strappend}, @code{strtrunc},
 @code{strvcat}, @code{strfind}, and @code{strmatch}.
 
@@ -737,68 +739,76 @@ separated lists, which makes them useful
 return values of functions organized.  Another example of where a comma
 separated list can be used is in the creation of a new array.  If all the
 accessed elements of a cell array are scalars or column vectors, they
 can be concatenated into a new column vector containing the elements, by
 surrounding the list with @code{[} and @code{]} as in the following
 example
 
 @example
+@group
 a = @{1, [2, 3], 4@};
 b = [a@{:@}]
      @result{} b =
          1   2   3   4
+@end group
 @end example
 
 It is also possible to pass the accessed elements directly to a
 function.  The list of elements from the cell array will be passed as an
 argument list to a given function as if it is called with the elements as
 arguments.  The two calls to @code{printf} in the following example are
 identical but the latter is simpler and handles more situations
 
 @example
+@group
 c = @{"GNU", "Octave", "is", "Free", "Software"@};
 printf ("%s ", c@{1@}, c@{2@}, c@{3@}, c@{4@}, c@{5@});
      @print{} GNU Octave is Free Software 
 printf ("%s ", c@{:@});
      @print{} GNU Octave is Free Software 
+@end group
 @end example
 
 Just like it is possible to create a numerical array from selected
 elements of a cell array, it is possible to create a new cell array
 containing the selected elements.  By surrounding the list with 
 @samp{@{} and @samp{@}} a new cell array will be created, as the
 following example illustrates
 
 @example
+@group
 a = @{1, rand(2, 2), "three"@};
 b = @{ a@{ [1, 3] @} @}
      @result{} b =
          @{
            [1,1] =  1
            [1,2] = three
          @}
+@end group
 @end example
 
 @noindent
 This syntax is however a bit cumbersome, and since this is a common
 operation, it is possible to achieve the same using the @samp{(}
 and @samp{)} operators for indexing.  When a cell array is indexed
 using the @samp{(} and @samp{)} operators a new cell array containing
 the selected elements will be created.  Using this syntax, the previous 
 example can be simplified into the following
 
 @example
+@group
 a = @{1, rand(2, 2), "three"@};
 b = a( [1, 3] )
      @result{} b =
          @{
            [1,1] =  1
            [1,2] = three
          @}
+@end group
 @end example
 
 A comma separated list can equally appear on the left-hand side of an
 assignment.  An example is 
 
 @example
 @group
 in @{1@} = ceil (rand (10, 1));
diff --git a/doc/interpreter/contrib.txi b/doc/interpreter/contrib.txi
--- a/doc/interpreter/contrib.txi
+++ b/doc/interpreter/contrib.txi
@@ -302,17 +302,17 @@ standard library.  Use of STL containers
 templates wisely to reduce code duplication.  Avoid comma expressions, labels
 and gotos, and explicit typecasts.  If you need to typecast, use the modern C++
 casting operators.  In functions, try to reduce the number of @code{return}
 statements - use nested @code{if} statements if possible.
 
 @node Other Sources
 @section Other Sources
 Apart from C++ and Octave language (m-files), Octave's sources include files
-written in C, Fortran, M4, perl, unix shell, AWK, texinfo and TeX.  There are
+written in C, Fortran, M4, perl, unix shell, AWK, texinfo and @TeX{}.  There are
 not many rules to follow when using these other languages; some of them are
 summarized below.  In any case, the golden rule is: if you modify a source
 file, try to follow any conventions you can detect in the file or other similar
 files.
 
 For C you should obviously follow all C++ rules that can apply.
 
 If you happen to modify a Fortran file, you should stay within Fortran 77
diff --git a/doc/interpreter/data.txi b/doc/interpreter/data.txi
--- a/doc/interpreter/data.txi
+++ b/doc/interpreter/data.txi
@@ -77,30 +77,26 @@ use of the following functions.
 @subsection Numeric Objects
 @cindex numeric constant
 @cindex numeric value
 
 Octave's built-in numeric objects include real, complex, and integer
 scalars and matrices.  All built-in floating point numeric data is
 currently stored as double precision numbers.  On systems that use the
 IEEE floating point format, values in the range of approximately
-@iftex
 @tex
  $2.2251\times10^{-308}$ to $1.7977\times10^{308}$
 @end tex
-@end iftex
 @ifnottex
  2.2251e-308 to 1.7977e+308
 @end ifnottex
  can be stored, and the relative precision is approximately
-@iftex
 @tex
  $2.2204\times10^{-16}$.
 @end tex
-@end iftex
 @ifnottex
  2.2204e-16.
 @end ifnottex
 The exact values are given by the variables @code{realmin},
 @code{realmax}, and @code{eps}, respectively.
 
 Matrix objects can be of any size, and can be dynamically reshaped and
 resized.  It is easy to extract individual rows, columns, or submatrices
diff --git a/doc/interpreter/debug.txi b/doc/interpreter/debug.txi
--- a/doc/interpreter/debug.txi
+++ b/doc/interpreter/debug.txi
@@ -75,59 +75,61 @@ result in Octave terminating normally.
 
 Breakpoints can be set in any Octave function, using the @code{dbstop}
 function.
 
 @DOCSTRING(dbstop)
 
 @noindent
 Note that breakpoints cannot be set in built-in functions
-(e.g., @code{sin}, etc) or dynamically loaded function (i.e., oct-files).  To
+(e.g., @code{sin}, etc.) or dynamically loaded function (i.e., oct-files).  To
 set a breakpoint immediately on entering a function, the breakpoint
 should be set to line 1. The leading comment block will be ignored and
 the breakpoint will be set to the first executable statement in the
 function.  For example
 
 @example
 @group
 dbstop ("asind", 1)
 @result{} 27
 @end group
 @end example
 
 @noindent
 Note that the return value of @code{27} means that the breakpoint was
-effectively set to line 27. The status of breakpoints in a function can
+effectively set to line 27.  The status of breakpoints in a function can
 be queried with the @code{dbstatus} function.
 
 @DOCSTRING(dbstatus)
 
 @noindent
 Taking the above as an example, @code{dbstatus ("asind")} should return
-27. The breakpoints can then be cleared with the @code{dbclear} function
+27.  The breakpoints can then be cleared with the @code{dbclear} function
 
 @DOCSTRING(dbclear)
 
 @noindent
 These functions can be used to clear all the breakpoints in a function.  For example,
 
 @example
 dbclear ("asind", dbstatus ("asind"));
 @end example
 
 A breakpoint can be set in a subfunction.  For example if a file contains
 the functions
 
 @example
+@group
 function y = func1 (x)
   y = func2 (x);
 endfunction
 function y = func2 (x)
   y = x + 1;
 endfunction
+@end group
 @end example
 
 @noindent
 then a breakpoint can be set at the start of the subfunction directly
 with
 
 @example
 @group
diff --git a/doc/interpreter/diagperm.txi b/doc/interpreter/diagperm.txi
--- a/doc/interpreter/diagperm.txi
+++ b/doc/interpreter/diagperm.txi
@@ -27,37 +27,33 @@
 * Zeros Treatment::      The Differences in Treatment of Zero Elements
 @end menu
 
 @node Basic Usage
 @section Creating and Manipulating Diagonal and Permutation Matrices
 
 A diagonal matrix is defined as a matrix that has zero entries outside the main diagonal;
 that is, 
-@iftex
 @tex
 $D_{ij} = 0$ if $i \neq j$
 @end tex
-@end iftex
 @ifnottex
 @code{D(i,j) == 0} if @code{i != j}.
 @end ifnottex
 Most often, square diagonal matrices are considered; however, the definition can equally
 be applied to nonsquare matrices, in which case we usually speak of a rectangular diagonal 
 matrix.
 
 A permutation matrix is defined as a square matrix that has a single element equal to unity
 in each row and each column; all other elements are zero.  That is, there exists a 
 permutation (vector) 
-@iftex
 @tex
 $p$ such that $P_{ij}=1$ if $j = p_i$ and
 $P_{ij}=0$ otherwise.  
 @end tex
-@end iftex
 @ifnottex
 @code{p} such that @code{P(i,j) == 1} if @code{j == p(i)} and 
 @code{P(i,j) == 0} otherwise.  
 @end ifnottex
 
 Octave provides special treatment of real and complex rectangular diagonal matrices,
 as well as permutation matrices.  They are stored as special objects, using efficient 
 storage and algorithms, facilitating writing both readable and efficient matrix algebra
@@ -81,17 +77,16 @@ The result of these expressions will be 
 than a general matrix object.
 
 Diagonal matrix with unit elements can be created using @dfn{eye}.
 Some other built-in functions can also return diagonal matrices.  Examples include
 @dfn{balance} or @dfn{inv}.
 
 Example:
 @example
-@group
   diag (1:4)
 @result{}
 Diagonal Matrix
 
    1   0   0   0
    0   2   0   0
    0   0   3   0
    0   0   0   4
@@ -101,17 +96,16 @@ Diagonal Matrix
 @result{}
 Diagonal Matrix
 
    1   0   0
    0   2   0
    0   0   3
    0   0   0
    0   0   0
-@end group
 @end example  
 
 @node Creating Permutation Matrices
 @subsection Creating Permutation Matrices
 
 For creating permutation matrices, Octave does not introduce a new function, but
 rather overrides an existing syntax: permutation matrices can be conveniently
 created by indexing an identity matrix by permutation vectors.
@@ -219,21 +213,19 @@ are treated specially when performed on 
 
 @node Expressions Involving Diagonal Matrices
 @subsection Expressions Involving Diagonal Matrices
 
 Assume @var{D} is a diagonal matrix.  If @var{M} is a full matrix,
 then @code{D*M} will scale the rows of @var{M}.  That means,
 if @code{S = D*M}, then for each pair of indices
 i,j it holds 
-@iftex
 @tex
 $$S_{ij} = D_{ii} M_{ij}$$
 @end tex
-@end iftex
 @ifnottex
 @example
 S(i,j) = D(i,i) * M(i,j).
 @end example
 @end ifnottex
 Similarly, @code{M*D} will do a column scaling.
 
 The matrix @var{D} may also be rectangular, m-by-n where @code{m != n}.
@@ -483,17 +475,16 @@ assumed zeros as numerical ones.
 
 Note that certain competing software does not strictly follow this principle
 and converts assumed zeros to numerical zeros in certain cases, while not doing
 so in other cases.  As of today, there are no intentions to mimic such behavior 
 in Octave.
 
 Examples of effects of assumed zeros vs. numerical zeros:
 @example
-@group
 Inf * eye (3)
 @result{}
    Inf     0     0
      0   Inf     0
      0     0   Inf
 
 Inf * speye (3)
 @result{}
@@ -504,17 +495,16 @@ Compressed Column Sparse (rows = 3, cols
   (3, 3) -> Inf
 
 Inf * full (eye (3))
 @result{}
    Inf   NaN   NaN
    NaN   Inf   NaN
    NaN   NaN   Inf
 
-@end group
 @end example
 
 @example
 @group
 diag(1:3) * [NaN; 1; 1]
 @result{}
    NaN
      2
diff --git a/doc/interpreter/diffeq.txi b/doc/interpreter/diffeq.txi
--- a/doc/interpreter/diffeq.txi
+++ b/doc/interpreter/diffeq.txi
@@ -31,23 +31,21 @@ All solvers are based on reliable ODE ro
 @cindex Differential Equations
 @cindex ODE
 @cindex DAE
 
 @node Ordinary Differential Equations
 @section Ordinary Differential Equations
 
 The function @code{lsode} can be used to solve ODEs of the form
-@iftex
 @tex
 $$
  {dx\over dt} = f (x, t)
 $$
 @end tex
-@end iftex
 @ifinfo
 
 @example
 @group
 dx
 -- = f (x, t)
 dt
 @end group
@@ -109,37 +107,33 @@ t = [0, logspace (-1, log10(303), 150), 
 See Alan C. Hindmarsh, @cite{ODEPACK, A Systematized Collection of ODE
 Solvers}, in Scientific Computing, R. S. Stepleman, editor, (1983) for
 more information about the inner workings of @code{lsode}.
 
 @node Differential-Algebraic Equations
 @section Differential-Algebraic Equations
 
 The function @code{daspk} can be used to solve DAEs of the form
-@iftex
 @tex
 $$
  0 = f (\dot{x}, x, t), \qquad x(t=0) = x_0, \dot{x}(t=0) = \dot{x}_0
 $$
 @end tex
-@end iftex
 @ifnottex
 
 @example
 0 = f (x-dot, x, t),    x(t=0) = x_0, x-dot(t=0) = x-dot_0
 @end example
 @end ifnottex
 
 @noindent
 where
-@iftex
 @tex
 $\dot{x} = {dx \over dt}$
 @end tex
-@end iftex
 @ifnottex
 @math{x-dot}
 @end ifnottex
 is the derivative of @math{x}.  The equation is solved using Petzold's
 DAE solver @sc{Daspk}.
 
 @DOCSTRING(daspk)
 
diff --git a/doc/interpreter/dynamic.txi b/doc/interpreter/dynamic.txi
--- a/doc/interpreter/dynamic.txi
+++ b/doc/interpreter/dynamic.txi
@@ -116,47 +116,47 @@ Consider the short example
 
 This example although short introduces the basics of writing a C++
 function that can be dynamically linked to Octave.  The easiest way to
 make available most of the definitions that might be necessary for an
 oct-file in Octave is to use the @code{#include <octave/oct.h>}
 header.
 
 The macro that defines the entry point into the dynamically loaded
-function is @code{DEFUN_DLD}.  This macro takes four arguments, these being
+function is @w{@code{DEFUN_DLD}}.  This macro takes four arguments, these being
 
 @enumerate 1
 @item The function name as it will be seen in Octave,
 @item The list of arguments to the function of type @code{octave_value_list},
 @item The number of output arguments, which can and often is omitted if
 not used, and
 @item The string that will be seen as the help text of the function.
 @end enumerate
 
-The return type of functions defined with @code{DEFUN_DLD} is always
+The return type of functions defined with @w{@code{DEFUN_DLD}} is always
 @code{octave_value_list}.
 
 There are a couple of important considerations in the choice of function
 name.  Firstly, it must be a valid Octave function name and so must be a
 sequence of letters, digits and underscores, not starting with a
 digit.  Secondly, as Octave uses the function name to define the filename
-it attempts to find the function in, the function name in the @code{DEFUN_DLD}
+it attempts to find the function in, the function name in the @w{@code{DEFUN_DLD}}
 macro must match the filename of the oct-file.  Therefore, the above
 function should be in a file @file{helloworld.cc}, and it should be
 compiled to an oct-file using the command
 
 @example
 mkoctfile helloworld.cc
 @end example
 
 This will create a file called @file{helloworld.oct}, that is the compiled
 version of the function.  It should be noted that it is perfectly
-acceptable to have more than one @code{DEFUN_DLD} function in a source
+acceptable to have more than one @w{@code{DEFUN_DLD}} function in a source
 file.  However, there must either be a symbolic link to the oct-file for
-each of the functions defined in the source code with the @code{DEFUN_DLD}
+each of the functions defined in the source code with the @w{@code{DEFUN_DLD}}
 macro or the autoload (@ref{Function Files}) function should be used.
 
 The rest of this function then shows how to find the number of input
 arguments, how to print through the octave pager, and return from the
 function.  After compiling this function as above, an example of its use
 is
 
 @example
@@ -287,17 +287,17 @@ an external library.
 @end deftypefn
 
 Operators such an @code{+}, @code{-}, or @code{*} can be used on the
 majority of the above types.  In addition there are a number of methods
 that are of interest only for matrices such as @code{transpose},
 @code{hermitian}, @code{solve}, etc.
 
 The typical way to extract a matrix or array from the input arguments of
-@code{DEFUN_DLD} function is as follows
+@w{@code{DEFUN_DLD}} function is as follows
 
 @examplefile{addtwomatrices.cc}
 
 To avoid segmentation faults causing Octave to abort, this function
 explicitly checks that there are sufficient arguments available before
 accessing these arguments.  It then obtains two multi-dimensional arrays
 of type @code{NDArray} and adds these together.  Note that the array_value
 method is called without using the @code{is_matrix_type} type, and instead the
@@ -706,17 +706,16 @@ A third means of creating a sparse matri
 the data in compressed row format.  An example of this technique might
 be
 
 @c Note the @verbatim environment is a relatively new addition to texinfo.
 @c Therefore use the @example environment and replace @, with @@,
 @c { with @{, etc
 
 @example
-@group
 octave_value arg;
 @dots{}
 int nz = 6, nr = 3, nc = 4;   // Assume we know the max no nz
 SparseMatrix sm (nr, nc, nz);
 Matrix m = arg.matrix_value ();
 
 int ii = 0;
 sm.cidx (0) = 0;
@@ -731,29 +730,27 @@ for (int j = 1; j < nc; j++)
             sm.ridx(ii) = i;
             ii++;
           @}
       @}
     sm.cidx(j+1) = ii;
  @}
 sm.maybe_compress ();  // If don't know a-priori 
                        // the final no of nz.
-@end group
 @end example
 
 @noindent
 which is probably the most efficient means of creating the sparse matrix.
 
 Finally, it might sometimes arise that the amount of storage initially
 created is insufficient to completely store the sparse matrix.  Therefore,
 the method @code{change_capacity} exists to reallocate the sparse memory.
 The above example would then be modified as
 
 @example
-@group
 octave_value arg;
 @dots{}
 int nz = 6, nr = 3, nc = 4;   // Assume we know the max no nz
 SparseMatrix sm (nr, nc, nz);
 Matrix m = arg.matrix_value ();
 
 int ii = 0;
 sm.cidx (0) = 0;
@@ -773,17 +770,16 @@ for (int j = 1; j < nc; j++)
             sm.ridx(ii) = i;
             ii++;
           @}
       @}
     sm.cidx(j+1) = ii;
  @}
 sm.maybe_mutate ();  // If don't know a-priori 
                      // the final no of nz.
-@end group
 @end example
 
 Note that both increasing and decreasing the number of non-zero elements in
 a sparse matrix is expensive, as it involves memory reallocation.  Also as
 parts of the matrix, though not its entirety, exist as the old and new copy
 at the same time, additional memory is needed.  Therefore if possible this
 should be avoided.
 
@@ -939,26 +935,26 @@ with C or C++ code.  Octave supplies a n
 consistent behavior across a number of compilers.
 
 The underlying Fortran code should use the @code{XSTOPX} function to
 replace the Fortran @code{STOP} function.  @code{XSTOPX} uses the Octave
 exception handler to treat failing cases in the fortran code
 explicitly.  Note that Octave supplies its own replacement @sc{blas}
 @code{XERBLA} function, which uses @code{XSTOPX}.
 
-If the underlying code calls @code{XSTOPX}, then the @code{F77_XFCN}
+If the underlying code calls @code{XSTOPX}, then the @w{@code{F77_XFCN}}
 macro should be used to call the underlying fortran function.  The Fortran
 exception state can then be checked with the global variable
 @code{f77_exception_encountered}.  If @code{XSTOPX} will not be called,
-then the @code{F77_FCN} macro should be used instead to call the Fortran
+then the @w{@code{F77_FCN}} macro should be used instead to call the Fortran
 code.
 
-There is no harm in using @code{F77_XFCN} in all cases, except that for
+There is no harm in using @w{@code{F77_XFCN}} in all cases, except that for
 Fortran code that is short running and executes a large number of times,
-there is potentially an overhead in doing so.  However, if @code{F77_FCN}
+there is potentially an overhead in doing so.  However, if @w{@code{F77_FCN}}
 is used with code that calls @code{XSTOP}, Octave can generate a
 segmentation fault.
 
 An example of the inclusion of a Fortran function in an oct-file is
 given in the following example, where the C++ wrapper is
 
 @longexamplefile{fortdemo.cc}
 
@@ -985,17 +981,17 @@ error: fortdemo: error in fortran
 @end example
 
 @node Allocating Local Memory in Oct-Files
 @subsection Allocating Local Memory in Oct-Files
 
 Allocating memory within an oct-file might seem easy as the C++
 new/delete operators can be used.  However, in that case care must be
 taken to avoid memory leaks.  The preferred manner in which to allocate
-memory for use locally is to use the @code{OCTAVE_LOCAL_BUFFER} macro.
+memory for use locally is to use the @w{@code{OCTAVE_LOCAL_BUFFER}} macro.
 An example of its use is
 
 @example
 OCTAVE_LOCAL_BUFFER (double, tmp, len)
 @end example
 
 that returns a pointer @code{tmp} of type @code{double *} of length
 @code{len}.
@@ -1040,55 +1036,55 @@ paramdemo ([1, 2, NaN, Inf])
 @node Exception and Error Handling in Oct-Files
 @subsection Exception and Error Handling in Oct-Files
 
 Another important feature of Octave is its ability to react to the user
 typing @kbd{Control-C} even during calculations.  This ability is based on the
 C++ exception handler, where memory allocated by the C++ new/delete
 methods are automatically released when the exception is treated.  When
 writing an oct-file, to allow Octave to treat the user typing @kbd{Control-C},
-the @code{OCTAVE_QUIT} macro is supplied.  For example
+the @w{@code{OCTAVE_QUIT}} macro is supplied.  For example
 
 @example
 @group
 for (octave_idx_type i = 0; i < a.nelem (); i++)
   @{
     OCTAVE_QUIT;
     b.elem(i) = 2. * a.elem(i);
   @}
 @end group
 @end example
 
-The presence of the @code{OCTAVE_QUIT} macro in the inner loop allows Octave to
+The presence of the @w{@code{OCTAVE_QUIT}} macro in the inner loop allows Octave to
 treat the user request with the @kbd{Control-C}.  Without this macro, the user
 must either wait for the function to return before the interrupt is
 processed, or press @kbd{Control-C} three times to force Octave to exit.
 
-The @code{OCTAVE_QUIT} macro does impose a very small speed penalty, and so for
+The @w{@code{OCTAVE_QUIT}} macro does impose a very small speed penalty, and so for
 loops that are known to be small it might not make sense to include
-@code{OCTAVE_QUIT}.
+@w{@code{OCTAVE_QUIT}}.
 
 When creating an oct-file that uses an external libraries, the function
 might spend a significant portion of its time in the external
-library.  It is not generally possible to use the @code{OCTAVE_QUIT} macro in
+library.  It is not generally possible to use the @w{@code{OCTAVE_QUIT}} macro in
 this case.  The alternative in this case is
 
 @example
 @group
 BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 @dots{}  some code that calls a "foreign" function @dots{}
 END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 @end group
 @end example
 
 The disadvantage of this is that if the foreign code allocates any
 memory internally, then this memory might be lost during an interrupt,
 without being deallocated.  Therefore, ideally Octave itself should
 allocate any memory that is needed by the foreign code, with either the
-fortran_vec method or the @code{OCTAVE_LOCAL_BUFFER} macro.
+fortran_vec method or the @w{@code{OCTAVE_LOCAL_BUFFER}} macro.
 
 The Octave unwind_protect mechanism (@ref{The @code{unwind_protect} Statement})
 can also be used in oct-files.  In conjunction with the exception
 handling of Octave, it is important to enforce that certain code is run
 to allow variables, etc. to be restored even if an exception occurs.  An
 example of the use of this mechanism is
 
 @longexamplefile{unwinddemo.cc}
@@ -1107,17 +1103,17 @@ 1 / 0
 
 The division by zero (and in fact all warnings) is disabled in the
 @code{unwinddemo} function.
 
 @node Documentation and Test of Oct-Files
 @subsection Documentation and Test of Oct-Files
 
 The documentation of an oct-file is the fourth string parameter of the
-@code{DEFUN_DLD} macro.  This string can be formatted in the same manner
+@w{@code{DEFUN_DLD}} macro.  This string can be formatted in the same manner
 as the help strings for user functions (@ref{Documentation Tips}),
 however there are some issue that are particular to the formatting of
 help strings within oct-files.
 
 The major issue is that the help string will typically be longer than a
 single line of text, and so the formatting of long help strings need to
 be taken into account.  There are several manners in which to treat this
 issue, but the most common is illustrated in the following example
@@ -1489,17 +1485,16 @@ includes a Cell Array per field of the s
 An example that demonstrates the use of structures in mex-file can be
 found in the file @file{mystruct.c}, as seen below
 
 @longexamplefile{mystruct.c}
 
 An example of the behavior of this function within Octave is then
 
 @example
-@group
 a(1).f1 = "f11"; a(1).f2 = "f12"; 
 a(2).f1 = "f21"; a(2).f2 = "f22";
 b = mystruct(a)
 @result{} field f1(0) = f11
     field f1(1) = f21
     field f2(0) = f12
     field f2(1) = f22
     b =
@@ -1518,25 +1513,24 @@ b = mystruct(a)
       (,
         [1] = that1
         [2] = that2
         [3] = that3
         [4] = that4
       ,)
     
     @}
-@end group
 @end example
 
 @node Sparse Matrices with Mex-Files
 @subsection Sparse Matrices with Mex-Files
 
 The Octave format for sparse matrices is identical to the mex format in
 that it is a compressed column sparse format.  Also in both, sparse
-matrices are required to be two dimensional.  The only difference is that
+matrices are required to be two-dimensional.  The only difference is that
 the real and imaginary parts of the matrix are stored separately.
 
 The mex-file interface, as well as using @code{mxGetM}, @code{mxGetN},
 @code{mxSetM}, @code{mxSetN}, @code{mxGetPr}, @code{mxGetPi},
 @code{mxSetPr} and @code{mxSetPi}, the mex-file interface supplies the
 functions
 
 @example
diff --git a/doc/interpreter/emacs.txi b/doc/interpreter/emacs.txi
--- a/doc/interpreter/emacs.txi
+++ b/doc/interpreter/emacs.txi
@@ -286,17 +286,17 @@ solution is
     (local-set-key "\C-m" x)))
 (add-hook 'octave-mode-hook 'RET-behaves-as-LFD)
 @end lisp
 @noindent
 (this works for all modes by adding to the startup hooks, without having
 to know the particular binding of @key{RET} in that mode!).  Similar
 considerations apply for using @key{M-RET} as @key{M-LFD}.  As Barry
 A. Warsaw <bwarsaw@@cnri.reston.va.us> says in the documentation for his
-@code{cc-mode}, ``This is a very common question. @code{:-)} If you want
+@code{cc-mode}, ``This is a very common question.  @code{:-)} If you want
 this to be the default behavior, don't lobby me, lobby RMS!''
 
 The following variables can be used to customize Octave mode.
 
 @table @code
 @item octave-auto-indent
 Non-@code{nil} means auto-indent the current line after a semicolon or
 space.  Default is @code{nil}.
diff --git a/doc/interpreter/eos.txi b/doc/interpreter/eos.txi
--- a/doc/interpreter/eos.txi
+++ b/doc/interpreter/eos.txi
@@ -236,17 +236,17 @@ Put point at the beginning of this block
 The block marked is the one that contains point or follows point.
 
 @item C-c ]
 Close the current block on a separate line (@code{octave-close-block}).
 An error is signaled if no block to close is found.
 
 @item C-c f
 Insert a function skeleton, prompting for the function's name, arguments
-and return values which have to be entered without parens
+and return values which have to be entered without parentheses
 (@code{octave-insert-defun}).
 
 @item C-c C-h
 Search the function, operator and variable indices of all info files
 with documentation for Octave for entries (@code{octave-help}).  If used
 interactively, the entry is prompted for with completion.  If multiple
 matches are found, one can cycle through them using the standard
 @samp{,} (@code{Info-index-next}) command of the Info reader.
@@ -286,17 +286,17 @@ solution is
     (local-set-key "\C-m" x)))
 (add-hook 'octave-mode-hook 'RET-behaves-as-LFD)
 @end lisp
 @noindent
 (this works for all modes by adding to the startup hooks, without having
 to know the particular binding of @key{RET} in that mode!).  Similar
 considerations apply for using @key{M-RET} as @key{M-LFD}.  As Barry
 A. Warsaw <bwarsaw@@cnri.reston.va.us> says in the documentation for his
-@code{cc-mode}, ``This is a very common question. @code{:-)} If you want
+@code{cc-mode}, ``This is a very common question.  @code{:-)} If you want
 this to be the default behavior, don't lobby me, lobby RMS!''
 
 The following variables can be used to customize Octave mode.
 
 @table @code
 @item octave-auto-indent
 Non-@code{nil} means auto-indent the current line after a semicolon or
 space.  Default is @code{nil}.
@@ -490,17 +490,17 @@ If @file{gnuserv} is installed, add the 
 (require 'gnuserv)
 (gnuserv-start)
 @end lisp
 @noindent
 to your @file{.emacs} file.
 
 You can use either `plain' Emacs Info or the function @code{octave-help}
 as your Octave info reader (for @samp{help -i}).  In the former case,
-set the Octave variable @code{INFO_PROGRAM} to @code{"info-emacs-info"}.
+set the Octave variable @w{@code{INFO_PROGRAM}} to @code{"info-emacs-info"}.
 The latter is perhaps more attractive because it allows to look up keys
 in the indices of @emph{several} info files related to Octave (provided
 that the Emacs variable @code{octave-help-files} is set correctly).  In
-this case, set @code{INFO_PROGRAM} to @code{"info-emacs-octave-help"}.
+this case, set @w{@code{INFO_PROGRAM}} to @code{"info-emacs-octave-help"}.
 
 If you use Octave from within Emacs, these settings are best done in the
 @file{~/.emacs-octave} startup file (or the file pointed to by the Emacs
 variable @code{inferior-octave-startup-file}).
diff --git a/doc/interpreter/errors.txi b/doc/interpreter/errors.txi
--- a/doc/interpreter/errors.txi
+++ b/doc/interpreter/errors.txi
@@ -54,21 +54,23 @@ described in @ref{The @code{try} Stateme
 @node Raising Errors
 @subsection Raising Errors
 
 The most common use of errors is for checking input arguments to
 functions.  The following example calls the @code{error} function if
 the function @code{f} is called without any input arguments.
 
 @example
+@group
 function f (arg1)
   if (nargin == 0)
     error("not enough input arguments");
   endif
 endfunction
+@end group
 @end example
 
 When the @code{error} function is called, it prints the given message
 and returns to the Octave prompt.  This means that no code following
 a call to @code{error} will be executed.
 
 @DOCSTRING(error)
 
@@ -79,44 +81,48 @@ of the function calling @code{print_usag
 If the help text is written in Texinfo it is possible to present an
 error message that only contains the function prototypes as described
 by the @code{@@deftypefn} parts of the help text.  When the help text
 isn't written in Texinfo, the error message contains the entire help
 message.
 
 Consider the following function.
 @example
+@group
 ## -*- texinfo -*-
 ## @@deftypefn @{Function File@} f (@@var@{arg1@})
 ## Function help text goes here@dots{}
 ## @@end deftypefn
 function f (arg1)
   if (nargin == 0)
     print_usage ();
   endif
 endfunction
+@end group
 @end example
 
 @noindent
 When it is called with no input arguments it produces the following
 error.
 
 @example
+@group
 f ()
 
 Invalid call to f.  Correct usage is:
 
      @print{}  -- Function File: f (ARG1)
      @print{}      Function help text goes here@dots{}
      @print{} 
      @print{} 
      @print{} 
      @print{} error: called from:
      @print{} error:   print_usage at line -1, column -1
      @print{} error:   /home/jwe/octave/f.m at line 7, column 5
+@end group
 @end example
 
 @DOCSTRING(print_usage)
 
 @DOCSTRING(usage)
 
 @DOCSTRING(beep)
 
@@ -126,72 +132,78 @@ Invalid call to f.  Correct usage is:
 @subsection Catching Errors
 
 When an error occurs, it can be detected and handled using the
 @code{try} statement as described in @ref{The @code{try} Statement}.
 As an example, the following piece of code counts the number of errors
 that occurs during a @code{for} loop.
 
 @example
+@group
 number_of_errors = 0;
 for n = 1:100
   try
     @dots{}
   catch
     number_of_errors++;
   end_try_catch
 endfor
+@end group
 @end example
 
 The above example treats all errors the same.  In many situations it
 can however be necessary to discriminate between errors, and take
 different actions depending on the error.  The @code{lasterror}
 function returns a structure containing information about the last
 error that occurred.  As an example, the code above could be changed
 to count the number of errors related to the @samp{*} operator.
 
 @example
+@group
 number_of_errors = 0;
 for n = 1:100
   try
     @dots{}
   catch
     msg = lasterror.message;
     if (strfind (msg, "operator *"))
       number_of_errors++;
     endif
   end_try_catch
 endfor
+@end group
 @end example
 
 @DOCSTRING(lasterror)
 
 @DOCSTRING(lasterr)
 
 When an error has been handled it is possible to raise it again.  This
 can be useful when an error needs to be detected, but the program should
 still abort.  This is possible using the @code{rethrow} function.  The
 previous example can now be changed to count the number of errors
 related to the @samp{*} operator, but still abort if another kind of
 error occurs.
 
 @example
+@group
 number_of_errors = 0;
 for n = 1:100
   try
     @dots{}
   catch
     msg = lasterror.message;
     if (strfind (msg, "operator *"))
       number_of_errors++;
     else
       rethrow (lasterror);
     endif
   end_try_catch
 endfor
+@end group
 @end example
 
 @DOCSTRING(rethrow)
 
 @c FIXME: I have no idea what the rest of the functions are used for...
 
 @DOCSTRING(errno)
 
@@ -202,19 +214,21 @@ endfor
 
 Like an error, a warning is issued when something unexpected happens.
 Unlike an error, a warning doesn't abort the currently running program.
 A simple example of a warning is when a number is divided by zero.  In
 this case Octave will issue a warning and assign the value @code{Inf}
 to the result.
 
 @example
+@group
 a = 1/0
      @print{} warning: division by zero
      @result{} a = Inf
+@end group
 @end example
 
 @menu
 * Issuing Warnings::
 * Enabling and Disabling Warnings::
 @end menu
 
 @node Issuing Warnings
@@ -222,22 +236,24 @@ a = 1/0
 
 It is possible to issue warnings from any code using the @code{warning}
 function.  In its most simple form, the @code{warning} function takes a
 string describing the warning as its input argument.  As an example,
 the following code controls if the variable @samp{a} is non-negative,
 and if not issues a warning and sets @samp{a} to zero.
 
 @example
+@group
 a = -1;
 if (a < 0)
   warning ("'a' must be non-negative.  Setting 'a' to zero.");
   a = 0;
 endif
      @print{} 'a' must be non-negative.  Setting 'a' to zero.
+@end group
 @end example
 
 Since warnings aren't fatal to a running program, it is not possible
 to catch a warning using the @code{try} statement or something similar.
 It is however possible to access the last warning as a string using the
 @code{lastwarn} function.
 
 It is also possible to assign an identification string to a warning.
@@ -257,27 +273,31 @@ The @code{warning} function also allows 
 are actually printed to the screen.  If the @code{warning} function
 is called with a string argument that is either @code{"on"} or @code{"off"}
 all warnings will be enabled or disabled.
 
 It is also possible to enable and disable individual warnings through
 their string identifications.  The following code will issue a warning
 
 @example
+@group
 warning ("non-negative-variable", 
          "'a' must be non-negative.  Setting 'a' to zero.");
+@end group
 @end example
 
 @noindent
 while the following won't issue a warning
 
 @example
+@group
 warning ("off", "non-negative-variable");
 warning ("non-negative-variable", 
          "'a' must be non-negative.  Setting 'a' to zero.");
+@end group
 @end example
 
 The functions distributed with Octave can issue one of the following
 warnings.
 
 @DOCSTRING(warning_ids)
 
 
diff --git a/doc/interpreter/eval.txi b/doc/interpreter/eval.txi
--- a/doc/interpreter/eval.txi
+++ b/doc/interpreter/eval.txi
@@ -43,17 +43,16 @@ call user-supplied functions.  The @code
 of the function to call as its first argument, and the remaining 
 arguments are given to the function.
 
 The following example is a simple-minded function using @code{feval}
 that finds the root of a user-supplied function of one variable using
 Newton's method.
 
 @example
-@group
 @cindex Fordyce, A. P.
 @findex newtroot
 function result = newtroot (fname, x)
 
 # usage: newtroot (fname, x)
 #
 #   fname : a string naming a function f(x).
 #   x     : initial guess
@@ -71,17 +70,16 @@ function result = newtroot (fname, x)
       x = x - fx / deriv;
       fx = fx_new;
     endif
   endfor
 
   result = x;
 
 endfunction
-@end group
 @end example
 
 Note that this is only meant to be an example of calling user-supplied
 functions and should not be taken too seriously.  In addition to using a
 more robust algorithm, any serious code would check the number and type
 of all the arguments, ensure that the supplied function really was a
 function, etc.  @xref{Predicates for Numeric Objects}, for example,
 for a list of predicates for numeric objects, and see @ref{Status of
@@ -111,58 +109,66 @@ call it, it modifies variables in your o
 allows you to use a pass-by-name style of function,
 which is similar to using a pointer in programming languages such
 as C.
 
 Consider how you might write @code{save} and @code{load} as
 m-files.  For example,
 
 @example
+@group
 function create_data
   x = linspace (0, 10, 10);
   y = sin (x);
   save mydata x y
 endfunction
+@end group
 @end example
 
 With @code{evalin}, you could write @code{save} as follows:
 
 @example
+@group
 function save (file, name1, name2)
   f = open_save_file (file);
   save_var(f, name1, evalin ("caller", name1));
   save_var(f, name2, evalin ("caller", name2));
 endfunction
+@end group
 @end example
 
 @noindent
 Here, @samp{caller} is the @code{create_data} function and @code{name1}
 is the string @code{"x"}, which evaluates simply as the value of @code{x}.
 
 You later want to load the values back from @code{mydata}
 in a different context:
 
 @example
+@group
 function process_data
   load mydata
   @dots{} do work @dots{}
 endfunction
+@end group
 @end example
 
 @noindent
 With @code{assignin}, you could write @code{load} as follows:
 
 @example
+@group
 function load (file)
   f = open_load_file (file);
   [name, val] = load_var (f);
   assignin ("caller", name, val);
   [name, val] = load_var (f);
   assignin ("caller", name, val);
 endfunction
+@end group
 @end example
 
 @noindent
 Here, @samp{caller} is the @code{process_data} function.
 
 You can set and use variables at the command prompt
 using the context @samp{base} rather than @samp{caller}.
 
diff --git a/doc/interpreter/expr.txi b/doc/interpreter/expr.txi
--- a/doc/interpreter/expr.txi
+++ b/doc/interpreter/expr.txi
@@ -56,19 +56,21 @@ Indices may be scalars, vectors, ranges,
 @samp{:}, which may be used to select entire rows or columns.
 
 Vectors are indexed using a single index expression.  Matrices may be
 indexed using one or two indices.  When using a single index
 expression, the elements of the matrix are taken in column-first order;
 the dimensions of the output match those of the index expression.  For
 example,
 @example
+@group
 a (2)       # a scalar
 a (1:2)     # a row vector
 a ([1; 2])  # a column vector
+@end group
 @end example
 
 As a special case, when a colon is used as a single index, the output
 is a column vector containing all the elements of the vector or matrix.
 For example
 @example
 a (:)       # a column vector
 @end example
@@ -90,17 +92,17 @@ a (1, :)
 @end group
 @end example
 
 @noindent
 and select the first row of the matrix.
 
 In general, an array with @samp{n} dimensions can be indexed using @samp{m}
 indices.  If @code{n == m}, each index corresponds to its respective dimension.
-The set of index tuples determining the result is formed by the cartesian product
+The set of index tuples determining the result is formed by the Cartesian product
 of the index vectors (or ranges or scalars).
 If @code{n < m}, then the array is padded by trailing singleton dimensions.
 If @code{n > m}, the last @code{n-m+1} dimensions are folded into a single
 dimension with extent equal to product of extents of the original dimensions.
 
 @c FIXED -- sections on variable prefer_zero_one_indexing were removed
 
 Indexing a scalar with a vector of ones can be used to create a
@@ -135,51 +137,51 @@ The last example could also be written a
 @example
 @group
 13 (ones (2, 3))
 @end group
 @end example
 
 It should be, noted that @code{ones (1, n)} (a row vector of ones) results in a
 range (with zero increment), and is therefore more efficient when used in index
-expression than other forms of @dfn{ones}. In particular, when @samp{r} is a row
+expression than other forms of @dfn{ones}.  In particular, when @samp{r} is a row
 vector, the expressions
 
 @example
   r(ones (1, n), :)
 @end example
 
 @example
   r(ones (n, 1), :)
 @end example
 
-will produce indentical results, but the first one will be significantly
-faster, at least for @samp{r} and @samp{n} large enough. The reason is that
+will produce identical results, but the first one will be significantly
+faster, at least for @samp{r} and @samp{n} large enough.  The reason is that
 in the first case the index is kept in a compressed form, which allows Octave
 to choose a more efficient algorithm to handle the expression.
 
 In general, for an user unaware of these subtleties, it is best to use
 the function @dfn{repmat} for spreading arrays into bigger ones.
 
 It is also possible to create a matrix with different values.  The
 following example creates a 10 dimensional row vector @math{a} containing
 the values
-@iftex
 @tex
 $a_i = \sqrt{i}$.
 @end tex
-@end iftex
 @ifnottex
 a(i) = sqrt(i).
 @end ifnottex
 
 @example
+@group
 for i = 1:10
   a(i) = sqrt (i);
 endfor
+@end group
 @end example
 
 @noindent
 Note that it is quite inefficient to create a vector using a loop like
 the one shown in the example above.  In this particular case, it would
 have been much more efficient to use the expression
 
 @example
@@ -651,17 +653,17 @@ comparison expressions using the boolean
 operators ``or'' (@samp{|}), ``and'' (@samp{&}), and ``not'' (@samp{!}),
 along with parentheses to control nesting.  The truth of the boolean
 expression is computed by combining the truth values of the
 corresponding elements of the component expressions.  A value is
 considered to be false if it is zero, and true otherwise.
 
 Element-by-element boolean expressions can be used wherever comparison
 expressions can be used.  They can be used in @code{if} and @code{while}
-statements.  However,  a matrix value used as the condition in an
+statements.  However, a matrix value used as the condition in an
 @code{if} or @code{while} statement is only true if @emph{all} of its
 elements are nonzero.
 
 Like comparison operations, each element of an element-by-element
 boolean expression also has a numeric value (1 if true, 0 if false) that
 comes into play if the result of the boolean expression is stored in a
 variable, or used in arithmetic.
 
@@ -967,18 +969,20 @@ b = s
 @end example
 
 @noindent
 The number of values on the left side of the expression can, however,
 not exceed the number of values on the right side.  For example, the
 following will produce an error.
 
 @example
+@group
 [a, b, c, d] = [u, s, v] = svd (a);
 @print{} error: element number 4 undefined in return list
+@end group
 @end example
 
 @opindex +=
 A very common programming pattern is to increment an existing variable
 with a given value, like this
 
 @example
 a = a + 2;
diff --git a/doc/interpreter/func.txi b/doc/interpreter/func.txi
--- a/doc/interpreter/func.txi
+++ b/doc/interpreter/func.txi
@@ -244,19 +244,21 @@ possibilities and issue our own error me
 @node Multiple Return Values
 @section Multiple Return Values
 
 Unlike many other computer languages, Octave allows you to define
 functions that return more than one value.  The syntax for defining
 functions that return multiple values is
 
 @example
+@group
 function [@var{ret-list}] = @var{name} (@var{arg-list})
   @var{body}
 endfunction
+@end group
 @end example
 
 @noindent
 where @var{name}, @var{arg-list}, and @var{body} have the same meaning
 as before, and @var{ret-list} is a comma-separated list of variable
 names that will hold the values returned from the function.  The list of
 return values must have at least one element.  If @var{ret-list} has
 only one element, this form of the @code{function} statement is
@@ -297,38 +299,42 @@ arguments, so the value of @code{nargout
 The @code{svd} and @code{lu} functions are examples of built-in
 functions that behave differently depending on the value of
 @code{nargout}.
 
 It is possible to write functions that only set some return values.  For
 example, calling the function
 
 @example
+@group
 function [x, y, z] = f ()
   x = 1;
   z = 2;
 endfunction
+@end group
 @end example
 
 @noindent
 as
 
 @example
 [a, b, c] = f ()
 @end example
 
 @noindent
 produces:
 
 @example
+@group
 a = 1
 
 b = [](0x0)
 
 c = 2
+@end group
 @end example
 
 @noindent
 along with a warning.
 
 @DOCSTRING(nargout)
 
 @DOCSTRING(nargchk)
@@ -341,74 +347,84 @@ along with a warning.
 @cindex variable-length argument lists
 @cindex @code{varargin}
 
 Sometimes the number of input arguments is not known when the function
 is defined.  As an example think of a function that returns the smallest
 of all its input arguments.  For example,
 
 @example
+@group
 a = smallest (1, 2, 3);
 b = smallest (1, 2, 3, 4);
+@end group
 @end example
 
 @noindent
 In this example both @code{a} and @code{b} would be 1.  One way to write
 the @code{smallest} function is
 
 @example
+@group
 function val = smallest (arg1, arg2, arg3, arg4, arg5)
   @var{body}
 endfunction
+@end group
 @end example
 
 @noindent
 and then use the value of @code{nargin} to determine which of the input
 arguments should be considered.  The problem with this approach is
 that it can only handle a limited number of input arguments.
 
 If the special parameter name @code{varargin} appears at the end of a
 function parameter list it indicates that the function takes a variable
 number of input arguments.  Using @code{varargin} the function
 looks like this
 
 @example
+@group
 function val = smallest (varargin)
   @var{body}
 endfunction
+@end group
 @end example
 
 @noindent
 In the function body the input arguments can be accessed through the
 variable @code{varargin}.  This variable is a cell array containing
 all the input arguments.  @xref{Cell Arrays}, for details on working
 with cell arrays.  The @code{smallest} function can now be defined
 like this
 
 @example
+@group
 function val = smallest (varargin)
   val = min ([varargin@{:@}]);
 endfunction
+@end group
 @end example
 
 @noindent
 This implementation handles any number of input arguments, but it's also
 a very simple solution to the problem.
 
 A slightly more complex example of @code{varargin} is a function 
 @code{print_arguments} that prints all input arguments.  Such a function
 can be defined like this
 
 @example
+@group
 function print_arguments (varargin)
   for i = 1:length (varargin)
     printf ("Input argument %d: ", i);
     disp (varargin@{i@});
   endfor
 endfunction
+@end group
 @end example
 
 @noindent
 This function produces output like this
 
 @example
 @group
 print_arguments (1, "two", 3);
@@ -431,21 +447,23 @@ special @code{varargin} parameter name. 
 variable number of output arguments the special output parameter name
 @code{varargout} is used.  As with @code{varargin}, @code{varargout} is
 a cell array that will contain the requested output arguments.
 
 As an example the following function sets the first output argument to
 1, the second to 2, and so on.
 
 @example
+@group
 function varargout = one_to_n ()
   for i = 1:nargout
     varargout@{i@} = i;
   endfor
 endfunction
+@end group
 @end example
 
 @noindent
 When called this function returns values like this
 
 @example
 @group
 [a, b, c] = one_to_n ()
@@ -514,31 +532,35 @@ at the end of every function definition.
 @cindex default arguments
 
 Since Octave supports variable number of input arguments, it is very useful
 to assign default values to some input arguments.  When an input argument
 is declared in the argument list it is possible to assign a default
 value to the argument like this
 
 @example
+@group
 function @var{name} (@var{arg1} = @var{val1}, @dots{})
   @var{body}
 endfunction
+@end group
 @end example
 
 @noindent
 If no value is assigned to @var{arg1} by the user, it will have the
 value @var{val1}.
 
 As an example, the following function implements a variant of the classic
 ``Hello, World'' program.
 @example
+@group
 function hello (who = "World")
   printf ("Hello, %s!\n", who);
 endfunction
+@end group
 @end example
 
 @noindent
 When called without an input argument the function prints the following
 @example
 @group
 hello ();
      @print{} Hello, World!
@@ -578,17 +600,17 @@ before using them.  You simply need to p
 place where Octave can find them.
 
 When Octave encounters an identifier that is undefined, it first looks
 for variables or functions that are already compiled and currently
 listed in its symbol table.  If it fails to find a definition there, it
 searches a list of directories (the @dfn{path}) for files ending in
 @file{.m} that have the same base name as the undefined
 identifier.@footnote{The @samp{.m} suffix was chosen for compatibility
-with @sc{Matlab}.}  Once Octave finds a file with a name that matches,
+with @sc{matlab}.}  Once Octave finds a file with a name that matches,
 the contents of the file are read.  If it defines a @emph{single}
 function, it is compiled and executed.  @xref{Script Files}, for more
 information about how you can define more than one function in a single
 file.
 
 When Octave defines a function from a function file, it saves the full
 name of the file it read and the time stamp on the file.  If the time
 stamp on the file changes, Octave may reload the file.  When Octave is
@@ -754,17 +776,17 @@ endfunction
 dispatch ("sin", "spsin", "sparse matrix");
 y0 = sin(eye(3));
 y1 = sin(speye(3));
 @end group
 @end example
 
 @noindent
 which aliases the user-defined function @code{spsin} to @code{sin}, but only for real sparse
-matrices.  Note that the builtin @code{sin} already  correctly treats
+matrices.  Note that the builtin @code{sin} already correctly treats
 sparse matrices and so this example is only illustrative.
 
 @DOCSTRING(dispatch)
 
 @DOCSTRING(builtin)
 
 A single dynamically linked file might define several
 functions.  However, as Octave searches for functions based on the
@@ -1046,32 +1068,36 @@ f = @@sin;
 Creates a function handle called @code{f} that refers to the
 function @code{sin}.
 
 Function handles are used to call other functions indirectly, or to pass
 a function as an argument to another function like @code{quad} or
 @code{fsolve}.  For example
 
 @example
+@group
 f = @@sin;
 quad (f, 0, pi)
     @result{} 2
+@end group
 @end example
 
 You may use @code{feval} to call a function using function handle, or
 simply write the name of the function handle followed by an argument
 list.  If there are no arguments, you must use an empty argument list
 @samp{()}.  For example
 
 @example
+@group
 f = @@sin;
 feval (f, pi/4)
     @result{} 0.70711
 f (pi/4)
     @result{} 0.70711
+@end group
 @end example
 
 @DOCSTRING(functions)
 
 @DOCSTRING(func2str)
 
 @DOCSTRING(str2func)
 
@@ -1087,38 +1113,44 @@ Anonymous functions are defined using th
 @noindent
 Any variables that are not found in the argument list are inherited from
 the enclosing scope.  Anonymous functions are useful for creating simple
 unnamed functions from expressions or for wrapping calls to other
 functions to adapt them for use by functions like @code{quad}.  For
 example,
 
 @example
+@group
 f = @@(x) x.^2;
 quad (f, 0, 10)
     @result{} 333.33
+@end group
 @end example
 
 @noindent
 creates a simple unnamed function from the expression @code{x.^2} and
 passes it to @code{quad},
 
 @example
+@group
 quad (@@(x) sin (x), 0, pi)
     @result{} 2
+@end group
 @end example
 
 @noindent
 wraps another function, and
 
 @example
+@group
 a = 1;
 b = 2;
 quad (@@(x) betainc (x, a, b), 0, 0.4)
     @result{} 0.13867
+@end group
 @end example
 
 @noindent
 adapts a function with several parameters to the form required by
 @code{quad}.  In this example, the values of @var{a} and @var{b} that
 are passed to @code{betainc} are inherited from the current
 environment.
 
diff --git a/doc/interpreter/install.txi b/doc/interpreter/install.txi
--- a/doc/interpreter/install.txi
+++ b/doc/interpreter/install.txi
@@ -281,17 +281,17 @@ Image files that are distributed with Oc
 
 This section contains a list of problems (and some apparent problems
 that don't really mean anything is wrong) that may show up during
 installation of Octave.
 
 @itemize @bullet
 @item
 On some SCO systems, @code{info} fails to compile if
-@code{HAVE_TERMIOS_H} is defined in @file{config.h}.  Simply removing
+@w{@code{HAVE_TERMIOS_H}} is defined in @file{config.h}.  Simply removing
 the definition from @file{info/config.h} should allow it to compile.
 
 @item
 If @code{configure} finds @code{dlopen}, @code{dlsym}, @code{dlclose},
 and @code{dlerror}, but not the header file @file{dlfcn.h}, you need to
 find the source for the header file and install it in the directory
 @file{usr/include}.  This is reportedly a problem with Slackware 3.1.
 For Linux/GNU systems, the source for @file{dlfcn.h} is in the
@@ -305,17 +305,17 @@ is needed to build shared versions of ve
 on the HP-PA architecture.  You can find the patch at
 @url{ftp://ftp.cygnus.com/pub/g++/libg++-2.7.2-hppa-gcc-fix}.
 
 @item
 On some alpha systems there may be a problem with the @code{libdxml}
 library, resulting in floating point errors and/or segmentation faults in
 the linear algebra routines called by Octave.  If you encounter such
 problems, then you should modify the configure script so that
-@code{SPECIAL_MATH_LIB} is not set to @code{-ldxml}.
+@w{@code{SPECIAL_MATH_LIB}} is not set to @code{-ldxml}.
 
 @item
 On FreeBSD systems Octave may hang while initializing some internal
 constants.  The fix appears to be to use
 
 @example
 options      GPL_MATH_EMULATE
 @end example
@@ -343,44 +343,44 @@ passing `void (*)()' as argument 2 of
 @end example
 
 @noindent
 or
 
 @example
 @group
 warning: ANSI C++ prohibits conversion from `(int)' 
-         to `(...)'
+         to `(@dots{})'
 @end group
 @end example
 
 @noindent
 while compiling @file{sighandlers.cc}, you may need to edit some files
 in the @code{gcc} include subdirectory to add proper prototypes for functions
 there.  For example, Ultrix 4.2 needs proper declarations for the
-@code{signal} function and the @code{SIG_IGN} macro in the file
+@code{signal} function and the @w{@code{SIG_IGN}} macro in the file
 @file{signal.h}.
 
-On some systems the @code{SIG_IGN} macro is defined to be something like
+On some systems the @w{@code{SIG_IGN}} macro is defined to be something like
 this:
 
 @example
 #define  SIG_IGN  (void (*)())1
 @end example
 
 @noindent
 when it should really be something like:
 
 @example
 #define  SIG_IGN  (void (*)(int))1
 @end example
 
 @noindent
 to match the prototype declaration for the @code{signal} function.  This
-change should also be made for the @code{SIG_DFL} and @code{SIG_ERR}
+change should also be made for the @w{@code{SIG_DFL}} and @w{@code{SIG_ERR}}
 symbols.  It may be necessary to change the definitions in
 @file{sys/signal.h} as well.
 
 The @code{gcc} @code{fixincludes} and @code{fixproto} scripts should
 probably fix these problems when @code{gcc} installs its modified set of
 header files, but I don't think that's been done yet.
 
 @strong{You should not change the files in @file{/usr/include}}.  You
@@ -435,17 +435,17 @@ On NeXT systems, if you get errors like 
 
 @noindent
 when compiling @file{Array.cc} and @file{Matrix.cc}, try recompiling
 these files without @code{-g}.
 
 @item
 Some people have reported that calls to shell_cmd and the pager do not
 work on SunOS systems.  This is apparently due to having
-@code{G_HAVE_SYS_WAIT} defined to be 0 instead of 1 when compiling
+@w{@code{G_HAVE_SYS_WAIT}} defined to be 0 instead of 1 when compiling
 @code{libg++}.
 
 @item
 On NeXT systems, linking to @file{libsys_s.a} may fail to resolve the
 following functions
 
 @example
 @group
@@ -484,17 +484,17 @@ for infinity and NaN.
 If your system actually does support IEEE arithmetic, you should be able
 to fix this problem by modifying the function @code{octave_ieee_init} in
 the file @file{lo-ieee.cc} to correctly initialize Octave's internal
 infinity and NaN variables.
 
 If your system does not support IEEE arithmetic but Octave's configure
 script incorrectly determined that it does, you can work around the
 problem by editing the file @file{config.h} to not define
-@code{HAVE_ISINF}, @code{HAVE_FINITE}, and @code{HAVE_ISNAN}.
+@w{@code{HAVE_ISINF}}, @w{@code{HAVE_FINITE}}, and @w{@code{HAVE_ISNAN}}.
 
 In any case, please report this as a bug since it might be possible to
 modify Octave's configuration script to automatically determine the
 proper thing to do.
 
 @item
 If Octave is unable to find a header file because it is installed in a
 location that is not normally searched by the compiler, you can add the
diff --git a/doc/interpreter/intro.txi b/doc/interpreter/intro.txi
--- a/doc/interpreter/intro.txi
+++ b/doc/interpreter/intro.txi
@@ -83,21 +83,19 @@ knows about arithmetic operations (+,-,*
 natural logarithms/exponents (log, exp), and the trigonometric 
 functions (sin, cos, @dots{}).  Moreover, Octave calculations work 
 on real or imaginary numbers (i,j).  In addition, some mathematical 
 constants such as the base of the natural logarithm (e) and the ratio 
 of a circle's circumference to its diameter (pi) are pre-defined.
 
 @noindent
 For example, to verify Euler's Identity,
-@iftex
 @tex
 $$e^{\imath\pi} = -1$$
 @end tex
-@end iftex
 @ifnottex
 @display
 
  i*pi
 e     = -1
 @end display
 @end ifnottex
 
@@ -156,21 +154,19 @@ octave:4> 2 * A
 To multiply the two matrices @code{A} and @code{B}, type the command
 
 @example
 octave:5> A * B
 @end example
 
 @noindent
 and to form the matrix product
-@iftex
 @tex
 $@code{A}^T@code{A}$,
 @end tex
-@end iftex
 @ifnottex
 @code{transpose (A) * A},
 @end ifnottex
 type the command
 
 @example
 octave:6> A' * A
 @end example
@@ -182,59 +178,53 @@ To solve the set of linear equations @co
 use the left division operator, @samp{\}:
 
 @example
 @var{x} = A \ b
 @end example
 
 @noindent
 This is conceptually equivalent to
-@iftex
 @tex
 $@code{A}^{-1}@code{b}$,
 @end tex
-@end iftex
 @ifnottex
 @code{inv (a) * b},
 @end ifnottex
 but avoids computing the inverse of a matrix directly.
 
 If the coefficient matrix is singular, Octave will print a warning
 message and compute a minimum norm solution.
 
 A simple example comes from chemistry and the need to obtain balanced 
 chemical equations.  Consider the burning of hydrogen and oxygen to 
 produce water.
 
-@iftex
 @tex
 $$ {\rm H_{2}} + {\rm O_{2}} \rightarrow {\rm H_{2}O} $$
 @end tex
-@end iftex
 @ifnottex
 @example
 H2 + O2 --> H2O
 @end example
 @end ifnottex
 
 @noindent
 The equation above is not accurate.  The Law of Conservation of Mass requires 
 that the number of molecules of each type balance on the left- and right-hand 
 sides of the equation.  Writing the variable overall reaction with 
 individual equations for hydrogen and oxygen one finds:
 
-@iftex
 @tex
 \vbox{
 $$ x_{1}{\rm H_{2}} + x_{2}{\rm O_{2}} \rightarrow {\rm H_{2}O} $$
 $$ {\rm H:}\quad 2x_{1} + 0x_{2} \rightarrow 2 $$
 $$ {\rm O:}\quad 0x_{1} + 2x_{2} \rightarrow 1 $$
 }
 @end tex
-@end iftex
 @ifnottex
 @example
 @group
 x1*H2 + x2*O2 --> H2O
 H: 2*x1 + 0*x2 --> 2
 O: 0*x1 + 2*x2 --> 1
 @end group
 @end example
@@ -250,23 +240,21 @@ octave:2> b = [ 2; 1 ];
 octave:3> x = A \ b
 @end group
 @end example
 
 @subsection Integrating Differential Equations
 
 Octave has built-in functions for solving nonlinear differential
 equations of the form
-@iftex
 @tex
 $$
  {dx \over dt} = f(x,t), \qquad x(t=t_0) = x_0
 $$
 @end tex
-@end iftex
 @ifnottex
 
 @example
 @group
 dx
 -- = f (x, t)
 dt
 @end group
@@ -278,21 +266,19 @@ with the initial condition
 @example
 x(t = t0) = x0
 @end example
 @end ifnottex
 
 @noindent
 For Octave to integrate equations of this form, you must first provide a
 definition of the function
-@iftex
 @tex
 $f (x, t)$.
 @end tex
-@end iftex
 @ifnottex
 @code{f(x,t)}.
 @end ifnottex
 This is straightforward, and may be accomplished by entering the
 function body directly on the command line.  For example, the following
 commands define the right-hand side function for an interesting pair of
 nonlinear differential equations.  Note that while you are entering a
 function, Octave responds with a different prompt, to indicate that it
diff --git a/doc/interpreter/io.txi b/doc/interpreter/io.txi
--- a/doc/interpreter/io.txi
+++ b/doc/interpreter/io.txi
@@ -46,18 +46,20 @@ after the C standard library are also pr
 @subsection Terminal Output
 
 Since Octave normally prints the value of an expression as soon as it
 has been evaluated, the simplest of all I/O functions is a simple
 expression.  For example, the following expression will display the
 value of @samp{pi}
 
 @example
+@group
 pi
      @print{} pi = 3.1416
+@end group
 @end example
 
 This works well as long as it is acceptable to have the name of the
 variable (or @samp{ans}) printed along with the value.  To print the
 value of a variable without printing its name, use the function
 @code{disp}.
 
 The @code{format} command offers some control over the way Octave prints
@@ -145,31 +147,35 @@ The @code{save} and @code{load} commands
 read from disk files in various formats.  The default format of files
 written by the @code{save} command can be controlled using the functions
 @code{default_save_options} and @code{save_precision}.
 
 As an example the following code creates a 3-by-3 matrix and saves it
 to the file @samp{myfile.mat}.
 
 @example
+@group
 A = [ 1:3; 4:6; 7:9 ];
 save myfile.mat A
+@end group
 @end example
 
 Once one or more variables have been saved to a file, they can be
 read into memory using the @code{load} command.
 
 @example
+@group
 load myfile.mat
 A
      @print{} A =
      @print{} 
      @print{}    1   2   3
      @print{}    4   5   6
      @print{}    7   8   9
+@end group
 @end example
 
 @DOCSTRING(save)
 
 @DOCSTRING(load)
 
 There are three functions that modify the behavior of @code{save}.
 
@@ -183,20 +189,22 @@ There are three functions that modify th
 
 It is possible to write data to a file in a similar way to the
 @code{disp} function for writing data to the screen.  The @code{fdisp}
 works just like @code{disp} except its first argument is a file pointer
 as created by @code{fopen}.  As an example, the following code writes
 to data @samp{myfile.txt}.
 
 @example
+@group
 fid = fopen ("myfile.txt", "w");
 fdisp (fid, "3/8 is ");
 fdisp (fid, 3/8);
 fclose (fid);
+@end group
 @end example
 
 @noindent
 @xref{Opening and Closing Files}, for details on how to use @code{fopen}
 and @code{fclose}.
 
 @DOCSTRING(fdisp)
 
@@ -295,39 +303,43 @@ When reading data from a file it must be
 likewise when writing to a file.  The @code{fopen} function returns a
 pointer to an open file that is ready to be read or written.  Once all
 data has been read from or written to the opened file it should be closed.
 The @code{fclose} function does this.  The following code illustrates
 the basic pattern for writing to a file, but a very similar pattern is
 used when reading a file.
 
 @example
+@group
 filename = "myfile.txt";
 fid = fopen (filename, "w");
 # Do the actual I/O here@dots{}
 fclose (fid);
+@end group
 @end example
 
 @DOCSTRING(fopen)
 
 @DOCSTRING(fclose)
 
 @node Simple Output
 @subsection Simple Output
 
 Once a file has been opened for writing a string can be written to the
 file using the @code{fputs} function.  The following example shows
 how to write the string @samp{Free Software is needed for Free Science}
 to the file @samp{free.txt}.
 
 @example
+@group
 filename = "free.txt";
 fid = fopen (filename, "w");
 fputs (fid, "Free Software is needed for Free Science");
 fclose (fid);
+@end group
 @end example
 
 @DOCSTRING(fputs)
 
 A function much similar to @code{fputs} is available for writing data
 to the screen.  The @code{puts} function works just like @code{fputs}
 except it doesn't take a file pointer as its input.
 
@@ -336,20 +348,22 @@ except it doesn't take a file pointer as
 @node Line-Oriented Input
 @subsection Line-Oriented Input
 
 To read from a file it must be opened for reading using @code{fopen}.
 Then a line can be read from the file using @code{fgetl} as the following
 code illustrates
 
 @example
+@group
 fid = fopen ("free.txt");
 txt = fgetl (fid)
      @print{} Free Software is needed for Free Science
 fclose (fid);
+@end group
 @end example
 
 @noindent
 This of course assumes that the file @samp{free.txt} exists and contains
 the line @samp{Free Software is needed for Free Science}.
 
 @DOCSTRING(fgetl)
 
@@ -378,28 +392,32 @@ about their types and what style should 
 
 Ordinary characters in the template string are simply written to the
 output stream as-is, while @dfn{conversion specifications} introduced by
 a @samp{%} character in the template cause subsequent arguments to be
 formatted and written to the output stream.  For example,
 @cindex conversion specifications (@code{printf})
 
 @example
+@group
 pct = 37;
 filename = "foo.txt";
 printf ("Processed %d%% of `%s'.\nPlease be patient.\n",
         pct, filename);
+@end group
 @end example
 
 @noindent
 produces output like
 
 @example
+@group
 Processed 37% of `foo.txt'.
 Please be patient.
+@end group
 @end example
 
 This example shows the use of the @samp{%d} conversion to specify that a
 scalar argument should be printed in decimal notation, the @samp{%s}
 conversion to specify printing of a string argument, and the @samp{%%}
 conversion to print a literal @samp{%} character.
 
 There are also conversions for printing an integer argument as an
@@ -984,22 +1002,24 @@ files will be deleted, so this step need
 
 Once a file has been opened its status can be acquired.  As an example
 the @code{feof} functions determines if the end of the file has been
 reached.  This can be very useful when reading small parts of a file
 at a time.  The following example shows how to read one line at a time
 from a file until the end has been reached.
 
 @example
+@group
 filename = "myfile.txt";
 fid = fopen (filename, "r");
 while (! feof (fid) )
   text_line = fgetl (fid);
 endwhile
 fclose (fid);
+@end group
 @end example
 
 @noindent
 Note that in some situations it is more efficient to read the entire
 contents of a file and then process it, than it is to read it line by
 line.  This has the potential advantage of removing the loop in the
 above code.
 
@@ -1025,14 +1045,16 @@ the file pointer for a given file.
 
 @DOCSTRING(frewind)
 
 The following example stores the current file position in the variable
 @code{marker}, moves the pointer to the beginning of the file, reads
 four characters, and then returns to the original position.
 
 @example
+@group
 marker = ftell (myfile);
 frewind (myfile);
 fourch = fgets (myfile, 4);
 fseek (myfile, marker, SEEK_SET);
+@end group
 @end example
 
diff --git a/doc/interpreter/linalg.txi b/doc/interpreter/linalg.txi
--- a/doc/interpreter/linalg.txi
+++ b/doc/interpreter/linalg.txi
@@ -17,17 +17,17 @@
 @c <http://www.gnu.org/licenses/>.
 
 @node Linear Algebra
 @chapter Linear Algebra
 
 This chapter documents the linear algebra functions of Octave.
 Reference material for many of these functions may be found in
 Golub and Van Loan, @cite{Matrix Computations, 2nd Ed.}, Johns Hopkins,
-1989, and in the @cite{@sc{Lapack} Users' Guide}, SIAM, 1992.
+1989, and in the @cite{@sc{lapack} Users' Guide}, SIAM, 1992.
 
 @menu
 * Techniques used for Linear Algebra::
 * Basic Matrix Functions::      
 * Matrix Factorizations::       
 * Functions of a Matrix::       
 * Specialized Solvers::
 @end menu
@@ -42,34 +42,34 @@ the cost of factorizing the matrix itsel
 type is cached once it is calculated, so that it is not re-determined 
 each time it is used in a linear equation.
 
 The selection tree for how the linear equation is solve or a matrix
 inverse is form is given by
 
 @enumerate 1
 @item If the matrix is upper or lower triangular sparse a forward or
-backward substitution using the @sc{Lapack} xTRTRS function, and goto 4.
+backward substitution using the @sc{lapack} xTRTRS function, and goto 4.
 
 @c Permuted triangular matrices currently disabled in the code
 @c
 @c @item If the matrix is a upper triangular matrix with column permutations
 @c or lower triangular matrix with row permutations, perform a forward or
 @c backward substitution, and goto 5.
 
 @item If the matrix is square, hermitian with a real positive diagonal,
-attempt Cholesky factorization using the @sc{Lapack} xPOTRF function.
+attempt Cholesky factorization using the @sc{lapack} xPOTRF function.
 
 @item If the Cholesky factorization failed or the matrix is not
 hermitian with a real positive diagonal, and the matrix is square, factorize 
-using the @sc{Lapack} xGETRF function.
+using the @sc{lapack} xGETRF function.
 
 @item If the matrix is not square, or any of the previous solvers flags
 a singular or near singular matrix, find a least squares solution using
-the @sc{Lapack} xGELSD function.
+the @sc{lapack} xGELSD function.
 @end enumerate
 
 The user can force the type of the matrix with the @code{matrix_type}
 function.  This overcomes the cost of discovering the type of the matrix.
 However, it should be noted that identifying the type of the matrix incorrectly
 will lead to unpredictable results, and so @code{matrix_type} should be
 used with care.
 
diff --git a/doc/interpreter/nonlin.txi b/doc/interpreter/nonlin.txi
--- a/doc/interpreter/nonlin.txi
+++ b/doc/interpreter/nonlin.txi
@@ -17,47 +17,43 @@
 @c <http://www.gnu.org/licenses/>.
 
 @node Nonlinear Equations
 @chapter Nonlinear Equations
 @cindex nonlinear equations
 @cindex equations, nonlinear
 
 Octave can solve sets of nonlinear equations of the form
-@iftex
 @tex
 $$
  f (x) = 0
 $$
 @end tex
-@end iftex
 @ifnottex
 
 @example
 F (x) = 0
 @end example
 @end ifnottex
 
 @noindent
 using the function @code{fsolve}, which is based on the @sc{Minpack}
 subroutine @code{hybrd}.  This is an iterative technique so a starting
 point will have to be provided.  This also has the consequence that
 convergence is not guaranteed even if a solution exists.
 
 @DOCSTRING(fsolve)
 
 Here is a complete example.  To solve the set of equations
-@iftex
 @tex
 $$
  \eqalign{-2x^2 + 3xy + 4\sin(y) - 6 &= 0\cr
            3x^2 - 2xy^2 + 3\cos(x) + 4 &= 0}
 $$
 @end tex
-@end iftex
 @ifinfo
 
 @example
 @group
 -2x^2 + 3xy   + 4 sin(y) = 6
  3x^2 - 2xy^2 + 3 cos(x) = -4
 @end group
 @end example
diff --git a/doc/interpreter/numbers.txi b/doc/interpreter/numbers.txi
--- a/doc/interpreter/numbers.txi
+++ b/doc/interpreter/numbers.txi
@@ -50,21 +50,19 @@ 3 + 4i
 3.0 + 4.0i
 0.3e1 + 40e-1i
 @end group
 @end example
 
 @noindent
 all of which are equivalent.  The letter @samp{i} in the previous example
 stands for the pure imaginary constant, defined as
-@iftex
 @tex
   $\sqrt{-1}$.
 @end tex
-@end iftex
 @ifnottex
   @code{sqrt (-1)}.
 @end ifnottex
 
 For Octave to recognize a value as the imaginary part of a complex
 constant, a space must not appear between the number and the @samp{i}.
 If it does, Octave will print an error message, like this:
 
@@ -114,21 +112,19 @@ matrix is determined automatically, so i
 state the dimensions.  The expression
 
 @example
 a = [1, 2; 3, 4]
 @end example
 
 @noindent
 results in the matrix
-@iftex
 @tex
 $$ a = \left[ \matrix{ 1 & 2 \cr 3 & 4 } \right] $$
 @end tex
-@end iftex
 @ifnottex
 
 @example
 @group
 
         /      \
         | 1  2 |
   a  =  |      |
@@ -246,22 +242,24 @@ expression
 @example
 [ 1 a ' ]
 @end example
 
 @noindent
 produces the error message
 
 @example
+@group
 parse error:
 
   syntax error
 
 >>> [ 1 a ' ]
               ^
+@end group
 @end example
 
 @noindent
 because not doing so would cause trouble when parsing the valid expression
 
 @example
 [ a 'foo' ]
 @end example
@@ -305,31 +303,29 @@ easily be misinterpreted.
 @subsection Empty Matrices
 
 A matrix may have one or both dimensions zero, and operations on empty
 matrices are handled as described by Carl de Boor in @cite{An Empty
 Exercise}, SIGNUM, Volume 25, pages 2-6, 1990 and C. N. Nett and W. M.
 Haddad, in @cite{A System-Theoretic Appropriate Realization of the Empty
 Matrix Concept}, IEEE Transactions on Automatic Control, Volume 38,
 Number 5, May 1993.
-@iftex
 @tex
 Briefly, given a scalar $s$, an $m\times n$ matrix $M_{m\times n}$,
 and an $m\times n$ empty matrix $[\,]_{m\times n}$ (with either one or
 both dimensions equal to zero), the following are true:
 $$
 \eqalign{%
 s \cdot [\,]_{m\times n} = [\,]_{m\times n} \cdot s &= [\,]_{m\times n}\cr
 [\,]_{m\times n} + [\,]_{m\times n} &= [\,]_{m\times n}\cr
-[\,]_{0\times m} \cdot  M_{m\times n} &= [\,]_{0\times n}\cr
+[\,]_{0\times m} \cdot M_{m\times n} &= [\,]_{0\times n}\cr
 M_{m\times n} \cdot [\,]_{n\times 0} &= [\,]_{m\times 0}\cr
 [\,]_{m\times 0} \cdot [\,]_{0\times n} &=  0_{m\times n}}
 $$
 @end tex
-@end iftex
 @ifnottex
 Briefly, given a scalar @var{s}, an @var{m} by
 @var{n} matrix @code{M(mxn)}, and an @var{m} by @var{n} empty matrix
 @code{[](mxn)} (with either one or both dimensions equal to zero), the
 following are true:
 
 @example
 @group
@@ -401,30 +397,30 @@ defined by floating point values can pro
 Octave uses floating point arithmetic to compute the values in the
 range.  If it is important to include the endpoints of a range and the
 number of elements is known, you should use the @code{linspace} function
 instead (@pxref{Special Utility Matrices}).
 
 When adding a scalar to a range, subtracting a scalar from it (or subtracting a
 range from a scalar) and multiplying by scalar, Octave will attempt to avoid
 unpacking the range and keep the result as a range, too, if it can determine
-that it is safe to do so. For instance, doing
+that it is safe to do so.  For instance, doing
 
 @example
 a = 2*(1:1e7) - 1;
 @end example
 
 will produce the same result as @samp{1:2:2e7-1}, but without ever forming a
 vector with ten million elements.
 
 Using zero as an increment in the colon notation, as @samp{1:0:1} is not
 allowed, because a division by zero would occur in determining the number of
-range elements. However, ranges with zero increment (i.e. all elements equal)
+range elements.  However, ranges with zero increment (i.e., all elements equal)
 are useful, especially in indexing, and Octave allows them to be constructed
-using the built-in function @dfn{ones}. Note that because a range must be a row
+using the built-in function @dfn{ones}.  Note that because a range must be a row
 vector, @samp{ones (1, 10)} produces a range, while @samp{ones (10, 1)} does not.
 
 When Octave parses a range expression, it examines the elements of the
 expression to determine whether they are all constants.  If they are, it
 replaces the range expression with a single range constant.
 
 @node Single Precision Data Types
 @section Single Precision Data Types
@@ -434,35 +430,39 @@ functions in Octave accept single precis
 precision answers.  A single precision variable is created with the
 @code{single} function.
 
 @DOCSTRING(single)
 
 for example
 
 @example
+@group
 sngl = single (rand (2, 2))
      @result{} sngl = 
         0.37569   0.92982
         0.11962   0.50876
 class (sngl)
     @result{} single
+@end group
 @end example
 
 Many functions can also return single precision values directly.  For
 example
 
 @example
+@group
 ones (2, 2, "single")
 zeros (2, 2, "single")
 eye (2, 2,  "single")
 rand (2, 2, "single")
 NaN (2, 2, "single")
 NA (2, 2, "single")
 Inf (2, 2, "single")
+@end group
 @end example
 
 @noindent
 will all return single precision matrices.
 
 @node Integer Data Types
 @section Integer Data Types
 
@@ -474,22 +474,24 @@ often change type when involved in numer
 reason integers are most often used to store data, and not for
 calculations.
 
 In general most integer matrices are created by casting
 existing matrices to integers.  The following example shows how to cast
 a matrix into 32 bit integers.
 
 @example
+@group
 float = rand (2, 2)
      @result{} float = 0.37569   0.92982
                 0.11962   0.50876
 integer = int32 (float)
      @result{} integer = 0  1
                   0  1
+@end group
 @end example
 
 @noindent
 As can be seen, floating point values are rounded to the nearest integer
 when converted.
 
 @DOCSTRING(isinteger)
 
@@ -589,17 +591,17 @@ As the maximum value that can be represe
 for bit manipulation, particularly when forming masks, Octave supplies
 the function @code{bitmax}.
 
 @DOCSTRING(bitmax)
 
 This is the double precision version of the functions @code{intmax},
 previously discussed.
 
-Octave also includes the basic  bitwise 'and', 'or' and 'exclusive or'
+Octave also includes the basic bitwise 'and', 'or' and 'exclusive or'
 operators.
 
 @DOCSTRING(bitand)
 
 @DOCSTRING(bitor)
 
 @DOCSTRING(bitxor)
 
@@ -649,20 +651,22 @@ calculations.  In this case @code{true} 
 point numbers.  So, the result of @code{true*22 - false/6} is @code{22}.
 
 Logical values can also be used to index matrices and cell arrays.
 When indexing with a logical array the result will be a vector containing
 the values corresponding to @code{true} parts of the logical array.
 The following example illustrates this.
 
 @example
+@group
 data = [ 1, 2; 3, 4 ];
 idx = (data <= 2);
 data(idx)
      @result{} ans = [ 1; 2 ]
+@end group
 @end example
 
 @noindent
 Instead of creating the @code{idx} array it is possible to replace
 @code{data(idx)} with @code{data( data <= 2 )} in the above code.
 
 Logical values can also be constructed by
 casting numeric objects to logical values, or by using the @code{true}
@@ -675,99 +679,111 @@ or @code{false} functions.
 @DOCSTRING(false)
 
 @node Promotion and Demotion of Data Types
 @section Promotion and Demotion of Data Types
 
 Many operators and functions can work with mixed data types.  For example
 
 @example
+@group
 uint8 (1) + 1
     @result{} 2
+@end group
 @end example
 
 @noindent
 where the above operator works with an 8-bit integer and a double precision
 value and returns an 8-bit integer value.  Note that the type is demoted
 to an 8-bit integer, rather than promoted to a double precision value as
 might be expected.  The reason is that if Octave promoted values in
 expressions like the above with all numerical constants would need to be
 explicitly cast to the appropriate data type like
 
 @example
+@group
 uint8 (1) + uint8 (1)
     @result{} 2
+@end group
 @end example
 
 @noindent
 which becomes difficult for the user to apply uniformly and might allow
 hard to find bugs to be introduced.  The same applies to single precision
 values where a mixed operation such as
 
 @example
+@group
 single (1) + 1
     @result{} 2
+@end group
 @end example
 
 @noindent
 returns a single precision value.  The mixed operations that are valid
 and their returned data types are
 
 @multitable @columnfractions .2 .3 .3 .2
-@item @tab Mixed Operation @tab  Result @tab 
+@item @tab Mixed Operation @tab Result @tab 
 @item @tab double OP single @tab single @tab
 @item @tab double OP integer @tab integer @tab
 @item @tab double OP char @tab double @tab
 @item @tab double OP logical @tab double @tab
 @item @tab single OP integer @tab integer @tab
 @item @tab single OP char @tab single @tab
 @item @tab single OP logical @tab single @tab
 @end multitable
 
 The same logic applies to functions with mixed arguments such as
 
 @example
+@group
 min (single (1), 0)
    @result{} 0
+@end group
 @end example
 
 @noindent
 where the returned value is single precision.
 
 In the case of mixed type indexed assignments, the type is not
 changed.  For example
 
 @example
+@group
 x = ones (2, 2);
 x (1, 1) = single (2)
     @result{} x = 2   1
            1   1
+@end group
 @end example
 
 @noindent
 where @code{x} remains of the double precision type. 
 
 @node Predicates for Numeric Objects
 @section Predicates for Numeric Objects
 
 Since the type of a variable may change during the execution of a
 program, it can be necessary to do type checking at run-time.  Doing this
 also allows you to change the behavior of a function depending on the
 type of the input.  As an example, this naive implementation of @code{abs}
 returns the absolute value of the input if it is a real number, and the
 length of the input if it is a complex number.
 
 @example
+@group
 function a = abs (x)
   if (isreal (x))
     a = sign (x) .* x;
   elseif (iscomplex (x))
     a = sqrt (real(x).^2 + imag(x).^2);
   endif
 endfunction
+@end group
 @end example
 
 The following functions are available for determining the type of a
 variable.
 
 @DOCSTRING(isnumeric)
 
 @DOCSTRING(isreal)
diff --git a/doc/interpreter/oop.txi b/doc/interpreter/oop.txi
--- a/doc/interpreter/oop.txi
+++ b/doc/interpreter/oop.txi
@@ -62,34 +62,30 @@ it is simple, and so doesn't distract un
 discussion of the programming features of Octave.  However, even still
 a small understand of the polynomial class itself is necessary to
 fully grasp the techniques described.
 
 The polynomial class is used to represent polynomials of the form
 
 @example
 @group
-@iftex
 @tex
 $a_0 + a_1 x + a_2 x^2 + \ldots a_n x^n$
 @end tex
-@end iftex
 @ifnottex
 a0 + a1 * x + a2 * x^2 + @dots{} + an * x^n
 @end ifnottex
 @end group
 @end example
 
 @noindent
 where
-@iftex
 @tex
 $a_0$, $a_1$, etc. are elements of $\Re$.
 @end tex
-@end iftex
 @ifnottex
 a0, a1, etc. are real scalars.
 @end ifnottex
 Thus the polynomial can be represented by a vector
 
 @example
 a = [a0, a1, a2, @dots{}, an];
 @end example
@@ -354,17 +350,16 @@ in the use of methods of other classes w
 
 @anchor{doc-rdivide} @anchor{doc-plus} @anchor{doc-minus} @anchor{doc-uminus}
 @anchor{doc-uplus} @anchor{doc-times} @anchor{doc-mtimes} @anchor{doc-mrdivide}
 @anchor{doc-ldivide} @anchor{doc-mldivide} @anchor{doc-power}
 @anchor{doc-mpower} @anchor{doc-lt} @anchor{doc-le} @anchor{doc-gt}
 @anchor{doc-ge} @anchor{doc-eq} @anchor{doc-ne} @anchor{doc-and}
 @anchor{doc-or} @anchor{doc-not} @anchor{doc-ctranspose} @anchor{doc-transpose}
 
-@iftex
 @tex
 \vskip 6pt
 {\hbox to \hsize {\hfill\vbox{\offinterlineskip \tabskip=0pt 
 \halign{
 \vrule height2.0ex depth1.ex width 0.6pt #\tabskip=0.3em &
 # \hfil & \vrule # & # \hfil & \vrule # & # \hfil & # \vrule 
 width 0.6pt \tabskip=0pt\cr
 \noalign{\hrule height 0.6pt}
@@ -399,17 +394,16 @@ width 0.6pt \tabskip=0pt\cr
 & $[a; b]$ && vertcat (a, b) && Vertical concatenation operator &\cr
 & $a(s_1, \ldots, s_n)$ && subsref (a, s) && Subscripted reference &\cr
 & $a(s_1, \ldots, s_n) = b$ && subsasgn (a, s, b) && Subscripted assignment &\cr
 & $b (a)$ && subsindex (a) && Convert to zero-based index &\cr
 & {\it display} && display (a) && Commandline display function &\cr
 \noalign{\hrule height 0.6pt}
 }}\hfill}}
 @end tex
-@end iftex
 @ifnottex
 @multitable @columnfractions .1 .20 .20 .40 .1
 @item @tab Operation @tab Method @tab Description @tab
 @item @tab a + b @tab plus (a, b) @tab Binary addition @tab
 @item @tab a - b$ @tab minus (a, b) @tab Binary subtraction operator @tab
 @item @tab + a$ @tab uplus (a) @tab Unary addition operator @tab
 @item @tab - a$ @tab uminus (a) @tab Unary subtraction operator @tab
 @item @tab a .* b$ @tab times (a, b) @tab Element-wise multiplication operator @tab
diff --git a/doc/interpreter/optim.txi b/doc/interpreter/optim.txi
--- a/doc/interpreter/optim.txi
+++ b/doc/interpreter/optim.txi
@@ -40,67 +40,59 @@ Minimization.
 @cindex NLP
 
 @node Linear Programming
 @section Linear Programming
 
 Octave can solve Linear Programming problems using the @code{glpk}
 function.  That is, Octave can solve
 
-@iftex
 @tex
 $$
   \min_x c^T x
 $$
 @end tex
-@end iftex
 @ifnottex
 @example
 min C'*x
 @end example
 @end ifnottex
 subject to the linear constraints
-@iftex
 @tex
 $Ax = b$ where $x \geq 0$.
 @end tex
-@end iftex
 @ifnottex
 @math{A*x = b} where @math{x >= 0}.
 @end ifnottex
 
 @noindent
 The @code{glpk} function also supports variations of this problem.
 
 @DOCSTRING(glpk)
 
 @node Quadratic Programming
 @section Quadratic Programming
 
 Octave can also solve Quadratic Programming problems, this is
-@iftex
 @tex
 $$
  \min_x {1 \over 2} x^T H x + x^T q
 $$
 @end tex
-@end iftex
 @ifnottex
 @example
 min 0.5 x'*H*x + x'*q
 @end example
 @end ifnottex
 subject to
-@iftex
 @tex
 $$
  Ax = b \qquad lb \leq x \leq ub \qquad A_{lb} \leq A_{in} \leq A_{ub}
 $$
 @end tex
-@end iftex
 @ifnottex
 @example
 @group
      A*x = b
      lb <= x <= ub
      A_lb <= A_in*x <= A_ub
 @end group
 @end example
@@ -116,21 +108,19 @@ successive quadratic programming solver.
 
 @DOCSTRING(sqp)
 
 @node Linear Least Squares
 @section Linear Least Squares
 
 Octave also supports linear least squares minimization.  That is,
 Octave can find the parameter @math{b} such that the model
-@iftex
 @tex
 $y = xb$
 @end tex
-@end iftex
 @ifnottex
 @math{y = x*b}
 @end ifnottex
 fits data @math{(x,y)} as well as possible, assuming zero-mean
 Gaussian noise.  If the noise is assumed to be isotropic the problem
 can be solved using the @samp{\} or @samp{/} operators, or the @code{ols}
 function.  In the general case where the noise is assumed to be anisotropic
 the @code{gls} is needed.
diff --git a/doc/interpreter/package.txi b/doc/interpreter/package.txi
--- a/doc/interpreter/package.txi
+++ b/doc/interpreter/package.txi
@@ -198,17 +198,17 @@ This is an optional file describing the 
 package.  If this file is not given then one with be created
 automatically from the functions in the package and the
 @code{Categories} keyword in the @code{DESCRIPTION} file.
 @xref{The INDEX file}, for details on this file.
 
 @anchor{doc-PKG_ADD}
 @item package/PKG_ADD
 An optional file that includes commands that are run when the package
-is added to the users path.  Note that @code{PKG_ADD} directives in the
+is added to the users path.  Note that @w{@code{PKG_ADD}} directives in the
 source code of the package will also be added to this file by the
 Octave package manager.  Note that symbolic links are to be avoided in
 packages, as symbolic links do not exist on some file systems, and so
 a typical use for this file is the replacement of the symbolic link
 
 @example
 ln -s foo.oct bar.oct
 @end example
@@ -216,25 +216,25 @@ ln -s foo.oct bar.oct
 @noindent
 with an autoload directive like
 
 @example
 autoload ('bar', which ('foo'));
 @end example
 
 @noindent
-@xref{PKG_ADD and PKG_DEL directives}, for details on @code{PKG_ADD}
+@xref{PKG_ADD and PKG_DEL directives}, for details on @w{@code{PKG_ADD}}
 directives.
 
 @item package/PKG_DEL
 An optional file that includes commands that are run when the package
-is removed from the users path.  Note that @code{PKG_DEL} directives in
+is removed from the users path.  Note that @w{@code{PKG_DEL}} directives in
 the source code of the package will also be added to this file by the
 Octave package manager. 
-@xref{PKG_ADD and PKG_DEL directives}, for details on @code{PKG_DEL}
+@xref{PKG_ADD and PKG_DEL directives}, for details on @w{@code{PKG_DEL}}
 directives.
 
 @item package/pre_install.m
 This is an optional script that is run prior to the installation of a
 package. 
 
 @item package/post_install.m
 This is an optional script that is run after the installation of a
@@ -267,17 +267,17 @@ will be copied to the @code{inst} direct
 
 @item package/doc
 An optional directory containing documentation for the package.  The
 files in this directory will be directly installed in a sub-directory
 of the installed package for future reference.
 
 @item package/bin
 An optional directory containing files that will be added to the
-Octave @code{EXEC_PATH} when the package is loaded.  This might contain
+Octave @w{@code{EXEC_PATH}} when the package is loaded.  This might contain
 external scripts, etc., called by functions within the package.
 @end table
 
 @menu
 * The DESCRIPTION File::        
 * The INDEX file::              
 * PKG_ADD and PKG_DEL directives::  
 @end menu
@@ -514,36 +514,36 @@ arcov = $TSA <code>armcv</code>
 @end example
 
 @noindent
 id is any string of letters, numbers and @code{_}.
 
 @node PKG_ADD and PKG_DEL directives
 @subsection PKG_ADD and PKG_DEL directives
 
-If the package contains files called @code{PKG_ADD} or @code{PKG_DEL}
+If the package contains files called @w{@code{PKG_ADD}} or @w{@code{PKG_DEL}}
 the commands in these files will be executed when the package is
 added or removed from the users path.  In some situations such files
 are a bit cumbersome to maintain, so the package manager supports
 automatic creation of such files.  If a source file in the package
-contains a @code{PKG_ADD} or @code{PKG_DEL} directive they will be
-added to either the @code{PKG_ADD} or @code{PKG_DEL} files.
+contains a @w{@code{PKG_ADD}} or @w{@code{PKG_DEL}} directive they will be
+added to either the @w{@code{PKG_ADD}} or @w{@code{PKG_DEL}} files.
 
-In @code{m}-files a @code{PKG_ADD} directive looks like this
+In @code{m}-files a @w{@code{PKG_ADD}} directive looks like this
 
 @example
 ## PKG_ADD: some_octave_command
 @end example
 
 @noindent
 Such lines should be added before the @code{function} keyword.
-In C++ files a @code{PKG_ADD} directive looks like this
+In C++ files a @w{@code{PKG_ADD}} directive looks like this
 
 @example
 // PKG_ADD: some_octave_command
 @end example
 
 @noindent
 In both cases @code{some_octave_command} should be replaced by the
-command that should be placed in the @code{PKG_ADD} file.
-@code{PKG_DEL} directives work in the same way, except the @code{PKG_ADD}
-keyword is replaced with @code{PKG_DEL} and the commands get added
-to the @code{PKG_DEL} file.
+command that should be placed in the @w{@code{PKG_ADD}} file.
+@w{@code{PKG_DEL}} directives work in the same way, except the @w{@code{PKG_ADD}}
+keyword is replaced with @w{@code{PKG_DEL}} and the commands get added
+to the @w{@code{PKG_DEL}} file.
diff --git a/doc/interpreter/plot.txi b/doc/interpreter/plot.txi
--- a/doc/interpreter/plot.txi
+++ b/doc/interpreter/plot.txi
@@ -121,17 +121,17 @@ shown in @ref{fig:hist}.
 
 @DOCSTRING(plotmatrix)
 
 @DOCSTRING(pareto)
 
 @DOCSTRING(rose)
 
 The @code{contour}, @code{contourf} and @code{contourc} functions
-produce two-dimensional contour plots from three dimensional data.
+produce two-dimensional contour plots from three-dimensional data.
 
 @DOCSTRING(contour)
 
 @DOCSTRING(contourf)
 
 @DOCSTRING(contourc)
 
 @DOCSTRING(contour3)
@@ -489,17 +489,17 @@ selection the position at which to place
 
 @DOCSTRING(gtext)
 
 @node Test Plotting Functions
 @subsection Test Plotting Functions
 
 The functions @code{sombrero} and @code{peaks} provide a way to check
 that plotting is working.  Typing either @code{sombrero} or @code{peaks}
-at the Octave prompt should display a three dimensional plot.
+at the Octave prompt should display a three-dimensional plot.
 
 @DOCSTRING(sombrero)
 
 @DOCSTRING(peaks)
 
 @node Advanced Plotting
 @section Advanced Plotting
 
@@ -818,18 +818,18 @@ An integer from 1 to 4 specifying the po
 indicates upper right corner, 2 indicates upper left, 3 indicates lower
 left, and 4 indicates lower right.  Note that this property is not
 compatible with @sc{matlab} and may be removed in a future version of
 Octave.
 
 @item dataaspectratio
 A two-element vector specifying the relative height and width of the
 data displayed in the axes.  Setting @code{dataaspectratio} to @samp{1,
-2]} causes the length of one unit as displayed on the y axis to be the
-same as the length of 2 units on the x axis.  Setting
+2]} causes the length of one unit as displayed on the y-axis to be the
+same as the length of 2 units on the x-axis.  Setting
 @code{dataaspectratio} also forces the @code{dataaspectratiomode}
 property to be set to @code{"manual"}.
 
 @item dataaspectratiomode
 Either @code{"manual"} or @code{"auto"}.
 
 @item xlim
 @itemx ylim
@@ -889,18 +889,18 @@ Either @code{"linear"} or @code{"log"}.
 
 @item xdir
 @itemx ydir
 @itemx zdir
 Either @code{"forward"} or @code{"reverse"}.
 
 @item xaxislocation
 @itemx yaxislocation
-Either @code{"top"} or @code{"bottom"} for the x axis and @code{"left"}
-or @code{"right"} for the y axis.
+Either @code{"top"} or @code{"bottom"} for the x-axis and @code{"left"}
+or @code{"right"} for the y-axis.
 
 @item view
 A three element vector specifying the view point for three-dimensional plots.
 
 @item visible
 Either @code{"on"} or @code{"off"} to toggle display of the axes.
 
 @item nextplot
@@ -1043,17 +1043,16 @@ use @tab
 
 Finally, the superscript and subscripting can be controlled with the '^'
 and '_' characters.  If the '^' or '_' is followed by a @{ character,
 then all of the block surrounded by the @{ @} pair is super- or
 sub-scripted.  Without the @{ @} pair, only the character immediately
 following the '^' or '_' is super- or sub-scripted.
 
 @float Table,tab:extended
-@iftex
 @tex
 \vskip 6pt
 {\hbox to \hsize {\hfill\vbox{\offinterlineskip \tabskip=0pt 
 \halign{
 \vrule height2.0ex depth1.ex width 0.6pt #\tabskip=0.3em &
 # \hfil & \vrule # & # \hfil & # \vrule &
 # \hfil & \vrule # & # \hfil & # \vrule &
 # \hfil & \vrule # & # \hfil & # \vrule 
@@ -1167,17 +1166,16 @@ width 0.6pt \tabskip=0pt\cr
 && $\backslash$rfloor   && $\rfloor$ 
 && $\backslash$lceil    && $\lceil$    &\cr
 & $\backslash$lfloor    && $\lfloor$ 
 && $\backslash$rceil    && $\rceil$ 
 && $\backslash$int      && $\int$      &\cr
 \noalign{\hrule height 0.6pt}
 }}\hfill}}
 @end tex
-@end iftex
 @ifnottex
 @multitable @columnfractions .125 .25 .25 .25 .125
 @item @tab  \forall     @tab  \exists     @tab  \ni      @tab
 @item @tab  \cong       @tab  \Delta      @tab  \Phi     @tab
 @item @tab  \Gamma      @tab  \vartheta   @tab  \Lambda  @tab
 @item @tab  \Pi         @tab  \Theta      @tab  \Sigma   @tab
 @item @tab  \varsigma   @tab  \Omega      @tab  \Xi      @tab
 @item @tab  \Psi        @tab  \perp       @tab  \alpha   @tab
diff --git a/doc/interpreter/poly.txi b/doc/interpreter/poly.txi
--- a/doc/interpreter/poly.txi
+++ b/doc/interpreter/poly.txi
@@ -17,24 +17,22 @@
 @c <http://www.gnu.org/licenses/>.
 
 @node Polynomial Manipulations
 @chapter Polynomial Manipulations
 
 In Octave, a polynomial is represented by its coefficients (arranged
 in descending order).  For example, a vector @var{c} of length
 @math{N+1} corresponds to the following polynomial of order
-@iftex
 @tex
  $N$
 $$
  p (x) = c_1 x^N + \ldots + c_N x + c_{N+1}.
 $$
 @end tex
-@end iftex
 @ifinfo
  @var{N}
 
 @example
 p(x) = @var{c}(1) x^@var{N} + @dots{} + @var{c}(@var{N}) x + @var{c}(@var{N}+1).
 @end example
 @end ifinfo
 
diff --git a/doc/interpreter/quad.txi b/doc/interpreter/quad.txi
--- a/doc/interpreter/quad.txi
+++ b/doc/interpreter/quad.txi
@@ -28,23 +28,21 @@ integration problems.
 * Functions of Multiple Variables:: 
 * Orthogonal Collocation::      
 @end menu
 
 @node Functions of One Variable
 @section Functions of One Variable
 
 Octave supports three different algorithms for computing the integral
-@iftex
 @tex
 $$
  \int_a^b f(x) d x
 $$
 @end tex
-@end iftex
 of a function @math{f} over the interval from @math{a} to @math{b}.
 These are
 
 @table @code
 @item quad
 Numerical integration based on Gaussian quadrature.
 
 @item quadl
@@ -65,24 +63,22 @@ Besides these functions Octave also allo
 numerical integration using the trapezoidal method through the
 @code{cumtrapz} function.
 
 @DOCSTRING(quad)
 
 @DOCSTRING(quad_options)
 
 Here is an example of using @code{quad} to integrate the function
-@iftex
 @tex
 $$
  f(x) = x \sin (1/x) \sqrt {|1 - x|}
 $$
 from $x = 0$ to $x = 3$.
 @end tex
-@end iftex
 @ifnottex
 
 @example
   @var{f}(@var{x}) = @var{x} * sin (1/@var{x}) * sqrt (abs (1 - @var{x}))
 @end example
 
 @noindent
 from @var{x} = 0 to @var{x} = 3.
@@ -134,35 +130,31 @@ if you move the lower bound to 0.1, then
 
 @node Orthogonal Collocation
 @section Orthogonal Collocation
 
 @DOCSTRING(colloc)
 
 Here is an example of using @code{colloc} to generate weight matrices
 for solving the second order differential equation
-@iftex
 @tex
 $u^\prime - \alpha u^{\prime\prime} = 0$ with the boundary conditions
 $u(0) = 0$ and $u(1) = 1$.
 @end tex
-@end iftex
 @ifnottex
 @var{u}' - @var{alpha} * @var{u}'' = 0 with the boundary conditions
 @var{u}(0) = 0 and @var{u}(1) = 1.
 @end ifnottex
 
 First, we can generate the weight matrices for @var{n} points (including
 the endpoints of the interval), and incorporate the boundary conditions
 in the right hand side (for a specific value of
-@iftex
 @tex
 $\alpha$).
 @end tex
-@end iftex
 @ifnottex
 @var{alpha}).
 @end ifnottex
 
 @example
 @group
 n = 7;
 alpha = 0.1;
@@ -187,23 +179,21 @@ u = [ 0; (at - alpha * bt) \ rhs; 1]
 
 Octave does not have built-in functions for computing the integral of
 functions of multiple variables directly.  It is however possible to
 compute the integral of a function of multiple variables using the
 functions for one-dimensional integrals.
 
 To illustrate how the integration can be performed, we will integrate
 the function
-@iftex
 @tex
 $$
   f(x, y) = \sin(\pi x y)\sqrt{x y}
 $$
 @end tex
-@end iftex
 @ifnottex
 @example
 f(x, y) = sin(pi*x*y)*sqrt(x*y)
 @end example
 @end ifnottex
 for @math{x} and @math{y} between 0 and 1.
 
 The first approach creates a function that integrates @math{f} with
@@ -245,23 +235,21 @@ I =  dblquad (@@(x, y) sin(pi.*x.*y).*sq
 @DOCSTRING(triplequad)
 
 The above mentioned approach works but is fairly slow, and that problem
 increases exponentially with the dimensionality the problem.  Another
 possible solution is to use Orthogonal Collocation as described in the
 previous section.  The integral of a function @math{f(x,y)} for
 @math{x} and @math{y} between 0 and 1 can be approximated using @math{n}
 points by
-@iftex
 @tex
 $$
  \int_0^1 \int_0^1 f(x,y) d x d y \approx \sum_{i=1}^n \sum_{j=1}^n q_i q_j f(r_i, r_j),
 $$
 @end tex
-@end iftex
 @ifnottex
 the sum over @code{i=1:n} and @code{j=1:n} of @code{q(i)*q(j)*f(r(i),r(j))},
 @end ifnottex
 where @math{q} and @math{r} is as returned by @code{colloc(n)}.  The
 generalization to more than two variables is straight forward.  The
 following code computes the studied integral using @math{n=7} points.
 
 @example
diff --git a/doc/interpreter/sparse.txi b/doc/interpreter/sparse.txi
--- a/doc/interpreter/sparse.txi
+++ b/doc/interpreter/sparse.txi
@@ -889,89 +889,75 @@ are partial factorizations of the origin
 A common application for sparse matrices is in the solution of Finite
 Element Models.  Finite element models allow numerical solution of
 partial differential equations that do not have closed form solutions,
 typically because of the complex shape of the domain.
 
 In order to motivate this application, we consider the boundary value
 Laplace equation.  This system can model scalar potential fields, such
 as heat or electrical potential.  Given a medium 
-@iftex
 @tex
 $\Omega$ 
 @end tex
-@end iftex
 @ifinfo
 Omega
 @end ifinfo
 with boundary
-@iftex
 @tex
 $\partial\Omega$ 
 @end tex
-@end iftex
 @ifinfo
 dOmega
 @end ifinfo
 . At all points on the 
-@iftex
 @tex
 $\partial\Omega$ 
 @end tex
-@end iftex
 @ifinfo
 dOmega
 @end ifinfo
 the boundary conditions are known, and we wish to calculate the potential in
-@iftex
 @tex
 $\Omega$ 
 @end tex
-@end iftex
 @ifinfo
 Omega
 @end ifinfo
 . Boundary conditions may specify the potential (Dirichlet
 boundary condition), its normal derivative across the boundary
 (Neumann boundary condition), or a weighted sum of the potential and
 its derivative (Cauchy boundary condition).
 
 In a thermal model, we want to calculate the temperature in
-@iftex
 @tex
 $\Omega$ 
 @end tex
-@end iftex
 @ifinfo
 Omega
 @end ifinfo
 and know the boundary temperature (Dirichlet condition)
 or heat flux (from which we can calculate the Neumann condition
 by dividing by the thermal conductivity at the boundary).  Similarly, 
 in an electrical model, we want to calculate the voltage in
-@iftex
 @tex
 $\Omega$ 
 @end tex
-@end iftex
 @ifinfo
 Omega
 @end ifinfo
 and know the boundary voltage (Dirichlet) or current
 (Neumann condition after diving by the electrical conductivity).
 In an electrical model, it is common for much of the boundary
 to be electrically isolated; this is a Neumann boundary condition
 with the current equal to zero.
 
 The simplest finite element models will divide 
-@iftex
 @tex
 $\Omega$ 
 @end tex
-@end iftex
 @ifinfo
 Omega
 @end ifinfo
 into simplexes (triangles in 2D, pyramids in 3D).
 @ifset htmltex
 We take as an 3D example a cylindrical liquid filled tank with a small 
 non-conductive ball from the EIDORS project@footnote{EIDORS - Electrical 
 Impedance Tomography and Diffuse optical Tomography Reconstruction Software 
@@ -1022,34 +1008,31 @@ This creates a N-by-2 matrix @code{nodes
     1    2    3    4    2    3    4 @dots{}
     2    3    4    5    7    8    9 @dots{}
     6    7    8    9    6    7    8 @dots{}
 @end group
 @end example
 
 Using a first order FEM, we approximate the electrical conductivity 
 distribution in 
-@iftex
 @tex
 $\Omega$ 
 @end tex
-@end iftex
 @ifinfo
 Omega
 @end ifinfo
 as constant on each simplex (represented by the vector @code{conductivity}).
 Based on the finite element geometry, we first calculate a system (or
 stiffness) matrix for each simplex (represented as 3-by-3 elements on the
 diagonal of the element-wise system matrix @code{SE}.  Based on @code{SE} 
 and a N-by-DE connectivity matrix @code{C}, representing the connections 
 between simplices and vertices, the global connectivity matrix @code{S} is
 calculated.
 
 @example
-@group
   # Element conductivity
   conductivity= [1*ones(1,16), ...
          2*ones(1,48), 1*ones(1,16)];
 
   # Connectivity matrix
   C = sparse ((1:D*E), reshape (elems', ...
          D*E, 1), 1, D*E, N);
 
@@ -1066,42 +1049,36 @@ calculated.
          dfact / abs(det(a));
      Sdata(D*(j-1)+(1:D),:) = const * ...
          a(2:D,:)' * a(2:D,:);
   endfor
   # Element-wise system matrix
   SE= sparse(Siidx,Sjidx,Sdata);
   # Global system matrix
   S= C'* SE *C;
-@end group
 @end example
 
 The system matrix acts like the conductivity 
-@iftex
 @tex
 $S$ 
 @end tex
-@end iftex
 @ifinfo
 @code{S}
 @end ifinfo
 in Ohm's law 
-@iftex
 @tex
 $SV = I$. 
 @end tex
-@end iftex
 @ifinfo
 @code{S * V = I}.
 @end ifinfo
 Based on the Dirichlet and Neumann boundary conditions, we are able to 
 solve for the voltages at each vertex @code{V}. 
 
 @example
-@group
   # Dirichlet boundary conditions
   D_nodes=[1:5, 51:55]; 
   D_value=[10*ones(1,5), 20*ones(1,5)]; 
 
   V= zeros(N,1);
   V(D_nodes) = D_value;
   idx = 1:N; # vertices without Dirichlet 
              # boundary condns
@@ -1113,17 +1090,16 @@ solve for the voltages at each vertex @c
   N_nodes=[];
   N_value=[];
 
   Q = zeros(N,1);
   Q(N_nodes) = N_value;
 
   V(idx) = S(idx,idx) \ ( Q(idx) - ...
             S(idx,D_nodes) * V(D_nodes));
-@end group
 @end example
 
 Finally, in order to display the solution, we show each solved voltage 
 value in the z-axis for each simplex vertex.
 @ifset htmltex
 @ifset HAVE_CHOLMOD
 @ifset HAVE_UMFPACK
 @ifset HAVE_COLAMD
diff --git a/doc/interpreter/stats.txi b/doc/interpreter/stats.txi
--- a/doc/interpreter/stats.txi
+++ b/doc/interpreter/stats.txi
@@ -149,17 +149,16 @@ using the @code{hist} function as descri
 @DOCSTRING(ppplot)
 
 @node Tests
 @section Tests
 
 Octave can perform several different statistical tests.  The following
 table summarizes the available tests.
 
-@iftex
 @tex
 \vskip 6pt
 {\hbox to \hsize {\hfill\vbox{\offinterlineskip \tabskip=0pt 
 \halign{
 \vrule height2.0ex depth1.ex width 0.6pt #\tabskip=0.3em &
 # \hfil & \vrule # & # \hfil & # \vrule width 0.6pt \tabskip=0pt\cr
 \noalign{\hrule height 0.6pt}
 & @strong{Hypothesis} && {\bf Test Functions} &\cr
@@ -176,17 +175,16 @@ table summarizes the available tests.
 &                          && run\_test &\cr
 & Uncorrelated observations && cor\_test &\cr
 & Given mean value && hotelling\_test, t\_test, z\_test &\cr
 & Observations from distribution && kolmogorov\_smirnov\_test &\cr
 & Regression && f\_test\_regression, t\_test\_regression &\cr
 \noalign{\hrule height 0.6pt}
 }}\hfill}}
 @end tex
-@end iftex
 @ifnottex
 @multitable @columnfractions .4 .5
 @item @strong{Hypothesis}
   @tab @strong{Test Functions}
 @item Equal mean values
   @tab @code{anova}, @code{hotelling_test2}, @code{t_test_2},
        @code{welch_test}, @code{wilcoxon_test}, @code{z_test_2}
 @item Equal medians
@@ -280,17 +278,16 @@ if the p-value exceeds @math{0.05}.
 Octave has functions for computing the Probability Density Function
 (PDF), the Cumulative Distribution function (CDF), and the quantile
 (the inverse of the CDF) of a large number of distributions.
 
 The following table summarizes the supported distributions (in 
 alphabetical order).
 
 @c Do the table explicitly in TeX if possible to get a better layout.
-@iftex
 @tex
 \vskip 6pt
 {\hbox to \hsize {\hfill\vbox{\offinterlineskip \tabskip=0pt 
 \halign{
 \vrule height2.0ex depth1.ex width 0.6pt #\tabskip=0.3em &
 # \hfil & \vrule # & # \hfil & \vrule # & # \hfil & \vrule # & # \hfil &
 # \vrule width 0.6pt \tabskip=0pt\cr
 \noalign{\hrule height 0.6pt}
@@ -317,17 +314,16 @@ alphabetical order).
 &Poisson      && poisspdf       && poisscdf      && poissinv&\cr
 &t (Student)  && tpdf           && tcdf          && tinv&\cr
 &Univariate Discrete && unidpdf && unidcdf       && unidinv&\cr
 &Uniform      && unifpdf        && unifcdf       && unifinv&\cr
 &Weibull      && wblpdf         && wblcdf        && wblinv&\cr
 \noalign{\hrule height 0.6pt}
 }}\hfill}}
 @end tex
-@end iftex
 @ifnottex
 @multitable @columnfractions .31 .23 .23 .23
 @item @strong{Distribution}
   @tab @strong{PDF}
   @tab @strong{CDF}
   @tab @strong{Quantile}
 @item Beta Distribution
   @tab @code{betapdf}
@@ -554,17 +550,16 @@ alphabetical order).
 Octave can generate random numbers from a large number of distributions.
 The random number generators are based on the random number generators
 described in @ref{Special Utility Matrices}.
 @c Should rand, randn, rande, randp, and randg be moved to here?
 
 The following table summarizes the available random number generators
 (in alphabetical order).
 
-@iftex
 @tex
 \vskip 6pt
 {\hbox to \hsize {\hfill\vbox{\offinterlineskip \tabskip=0pt 
 \halign{
 \vrule height2.0ex depth1.ex width 0.6pt #\tabskip=0.3em &
 # \hfil & \vrule # & # \hfil & # \vrule width 0.6pt \tabskip=0pt\cr
 \noalign{\hrule height 0.6pt}
 & {\bf Distribution}                && {\bf Function} &\cr
@@ -589,17 +584,16 @@ The following table summarizes the avail
 & t (Student) Distribution          && trnd &\cr
 & Univariate Discrete Distribution  && unidrnd &\cr
 & Uniform Distribution              && unifrnd &\cr
 & Weibull Distribution              && wblrnd &\cr
 & Wiener Process                    && wienrnd &\cr
 \noalign{\hrule height 0.6pt}
 }}\hfill}}
 @end tex
-@end iftex
 @ifnottex
 @multitable @columnfractions .4 .3
 @item @strong{Distribution}             @tab @strong{Function}
 @item Beta Distribution                 @tab @code{betarnd}
 @item Binomial Distribution             @tab @code{binornd}
 @item Cauchy Distribution               @tab @code{cauchy_rnd}
 @item Chi-Square Distribution           @tab @code{chi2rnd}
 @item Univariate Discrete Distribution  @tab @code{discrete_rnd}
diff --git a/doc/interpreter/stmt.txi b/doc/interpreter/stmt.txi
--- a/doc/interpreter/stmt.txi
+++ b/doc/interpreter/stmt.txi
@@ -215,39 +215,43 @@ using the indentation to show how Octave
 @cindex @code{otherwise} statement
 @cindex @code{endswitch} statement
 
 It is very common to take different actions depending on the value of
 one variable.  This is possible using the @code{if} statement in the
 following way
 
 @example
+@group
 if (X == 1)
   do_something ();
 elseif (X == 2)
   do_something_else ();
 else
   do_something_completely_different ();
 endif
+@end group
 @end example
 
 @noindent
 This kind of code can however be very cumbersome to both write and
 maintain.  To overcome this problem Octave supports the @code{switch}
 statement.  Using this statement, the above example becomes
 
 @example
+@group
 switch (X)
   case 1
     do_something ();
   case 2
     do_something_else ();
   otherwise
     do_something_completely_different ();
 endswitch
+@end group
 @end example
 
 @noindent
 This code makes the repetitive structure of the problem more explicit,
 making the code easier to read, and hence maintain.  Also, if the
 variable @code{X} should change its name, only one line would need
 changing compared to one line per case when @code{if} statements are
 used.
@@ -278,23 +282,25 @@ corresponding to the first match will be
 while the @code{otherwise @var{command_list}} clause is optional.
 
 If @var{label} is a cell array the corresponding @var{command_list}
 is executed if @emph{any} of the elements of the cell array match
 @var{expression}.  As an example, the following program will print
 @samp{Variable is either 6 or 7}.
 
 @example
+@group
 A = 7;
 switch A
   case @{ 6, 7 @}
     printf ("variable is either 6 or 7\n");
   otherwise
     printf ("variable is neither 6 nor 7\n");
 endswitch
+@end group
 @end example
 
 As with all other specific @code{end} keywords, @code{endswitch} may be
 replaced by @code{end}, but you can get better diagnostics if you use
 the specific forms.
 
 @c Strings can be matched
 
@@ -308,21 +314,23 @@ if (X == "a string") # This is NOT valid
 
 @noindent
 since a character-to-character comparison between @code{X} and the
 string will be made instead of evaluating if the strings are equal.
 This special-case is handled by the @code{switch} statement, and it
 is possible to write programs that look like this
 
 @example
+@group
 switch (X)
   case "a string"
     do_something
   @dots{}
 endswitch
+@end group
 @end example
 
 @menu
 * Notes for the C programmer::  
 @end menu
 
 @node Notes for the C programmer
 @subsection Notes for the C programmer
@@ -576,17 +584,17 @@ a = [1,3;2,4]; b = cat(3, a, 2*a);
 for i = c
   i
 endfor
 @end group 
 @end example
 
 @noindent
 In the above case, the multidimensional matrix @var{c} is reshaped to a
-two dimensional matrix as @code{reshape (c, rows(c),
+two-dimensional matrix as @code{reshape (c, rows(c),
 prod(size(c)(2:end)))} and then the same behavior as a loop over a two
 dimensional matrix is produced.
 
 Although it is possible to rewrite all @code{for} loops as @code{while}
 loops, the Octave language has both statements because often a
 @code{for} loop is both less work to type and more natural to think of.
 Counting the number of iterations is very common in loops and it can be
 easier to think of this counting as part of looping rather than as
diff --git a/doc/interpreter/strings.txi b/doc/interpreter/strings.txi
--- a/doc/interpreter/strings.txi
+++ b/doc/interpreter/strings.txi
@@ -150,17 +150,17 @@ example,
 
 
 @node Character Arrays
 @section Character Arrays
 
 The string representation used by Octave is an array of characters, so
 internally the string "dddddddddd" is actually a row vector of length 10
 containing the value 100 in all places (100 is the ASCII code of "d").  This
-lends itself to the obvious generalisation to character matrices.  Using a
+lends itself to the obvious generalization to character matrices.  Using a
 matrix of characters, it is possible to represent a collection of same-length
 strings in one variable.  The convention used in Octave is that each row in a
 character matrix is a separate string, but letting each column represent a
 string is equally possible.
 
 The easiest way to create a character matrix is to put several strings
 together into a matrix.
 
@@ -364,20 +364,22 @@ data as strings is the @code{sprintf} fu
 
 @node Comparing Strings
 @section Comparing Strings
 
 Since a string is a character array, comparisons between strings work
 element by element as the following example shows:
 
 @example
+@group
 GNU = "GNU's Not UNIX";
 spaces = (GNU == " ")
      @result{} spaces =
        0   0   0   0   0   1   0   0   0   1   0   0   0   0
+@end group
 @end example
 
 @noindent To determine if two strings are identical it is necessary to use the
 @code{strcmp} function.  It compares complete strings and is case
 sensitive.  @code{strncmp} compares only the first @code{N} characters (with
 @code{N} given as a parameter).  @code{strcmpi} and @code{strncmpi} are the
 corresponding functions for case-insensitive comparison.
 
@@ -396,17 +398,17 @@ corresponding functions for case-insensi
 
 Octave supports a wide range of functions for manipulating strings.
 Since a string is just a matrix, simple manipulations can be accomplished
 using standard operators.  The following example shows how to replace
 all blank characters with underscores.
 
 @example
 @group
-quote = @dots{}
+quote = ...
   "First things first, but not necessarily in that order";
 quote( quote == " " ) = "_"
 @result{} quote = 
     First_things_first,_but_not_necessarily_in_that_order
 @end group
 @end example
 
 For more complex manipulations, such as searching, replacing, and
@@ -449,18 +451,20 @@ general regular expressions, the followi
 @node String Conversions
 @section String Conversions
 
 Octave supports various kinds of conversions between strings and
 numbers.  As an example, it is possible to convert a string containing
 a hexadecimal number to a floating point number.
 
 @example
+@group
 hex2dec ("FF")
      @result{} ans = 255
+@end group
 @end example
 
 @DOCSTRING(bin2dec)
 
 @DOCSTRING(dec2bin)
 
 @DOCSTRING(dec2hex)
 
diff --git a/doc/interpreter/tips.txi b/doc/interpreter/tips.txi
--- a/doc/interpreter/tips.txi
+++ b/doc/interpreter/tips.txi
@@ -389,17 +389,17 @@ Help text in Texinfo format.  Code sampl
 like @@code@{sample of code@} and variables should be marked
 as @@var@{variable@}.
 @@seealso@{fn2@}
 @@end deftypefn
 @end group
 @end example
 
 This help string must be commented in user functions, or in the help
-string of the @code{DEFUN_DLD} macro for dynamically loadable
+string of the @w{@code{DEFUN_DLD}} macro for dynamically loadable
 functions.  The important aspects of the documentation string are
 
 @table @asis
 @item -*- texinfo -*-
 This string signals Octave that the following text is in Texinfo format,
 and should be the first part of any help string in Texinfo format.
 @item @@deftypefn@{class@} @dots{} @@end deftypefn
 The entire help string should be enclosed within the block defined by
@@ -418,17 +418,17 @@ reasons as the @@var macro.
 This is a comma separated list of function names that allows cross
 referencing from one function documentation string to another.
 @end table
 
 Texinfo format has been designed to generate output for online viewing
 with text-terminals as well as generating high-quality printed output.
 To these ends, Texinfo has commands which control the diversion of parts
 of the document into a particular output processor.  Three formats are
-of importance: info, html and TeX.  These are selected with
+of importance: info, html and @TeX{}.  These are selected with
 
 @example
 @group
 @@ifinfo
 Text area for info only
 @@end ifinfo
 @end group
 @end example
@@ -446,17 +446,17 @@ Text area for html only
 @@iftex
 @@tex
 text for TeX only
 @@end tex
 @@end iftex
 @end group
 @end example
 
-Note that often TeX output can be used in html documents and so often
+Note that often @TeX{} output can be used in html documents and so often
 the @code{@@ifhtml} blocks are unnecessary.  If no specific output
 processor is chosen, by default, the text goes into all output
 processors.  It is usual to have the above blocks in pairs to allow the
 same information to be conveyed in all output formats, but with a
 different markup.
 
 Another important feature of Texinfo that is often used in Octave help
 strings is the @code{@@example} environment.  An example of its use is
@@ -500,17 +500,16 @@ Help text in Texinfo format.
 @end example
 
 Many complete examples of Texinfo documentation can be taken from the
 help strings for the Octave functions themselves.  A relatively complete
 example of which is the @code{nchoosek} function.  The Texinfo
 documentation string of @code{nchoosek} is
 
 @example
-@group
 -*- texinfo -*-
 @@deftypefn @{Function File@} @{@} nchoosek (@@var@{n@}, @@var@{k@})
 
 Compute the binomial coefficient or all combinations of 
 @@var@{n@}.  If @@var@{n@} is a scalar then, calculate the
 binomial coefficient of @@var@{n@} and @@var@{k@}, defined as
 
 @@iftex
@@ -535,17 +534,16 @@ binomial coefficient of @@var@{n@} and @
 
 If @@var@{n@} is a vector, this generates all combinations
 of the elements of @@var@{n@}, taken @@var@{k@} at a time,
 one row per combination.  The resulting @@var@{c@} has size
 @@code@{[nchoosek (length (@@var@{n@}),@@var@{k@}), @@var@{k@}]@}.
 
 @@seealso@{bincoeff@}
 @@end deftypefn
-@end group
 @end example
 
 which demonstrates most of the concepts discussed above.
 @iftex
 This documentation string renders as
 
 @c Note actually use the output of info below rather than try and 
 @c reproduce it here to prevent it looking different than how it would
@@ -568,17 +566,17 @@ This documentation string renders as
      combination.  The resulting C has size `[nchoosek
      (length (N), K), K]'.
 
 
      See also: bincoeff.
 @end group
 @end example
 
-using info, whereas in a printed documentation using TeX it will appear
+using info, whereas in a printed documentation using @TeX{} it will appear
 as
 
 @deftypefn {Function File} {@var{c} =} nchoosek (@var{n}, @var{k})
 
 Compute the binomial coefficient or all combinations of @var{n}.
 If @var{n} is a scalar then, calculate the binomial coefficient
 of @var{n} and @var{k}, defined as
 
diff --git a/doc/interpreter/var.txi b/doc/interpreter/var.txi
--- a/doc/interpreter/var.txi
+++ b/doc/interpreter/var.txi
@@ -263,17 +263,16 @@ endfunction
 This implementation behaves in exactly the same way as the previous
 implementation of @code{count_calls}.
 
 The value of a persistent variable is kept in memory until it is
 explicitly cleared.  Assuming that the implementation of @code{count_calls}
 is saved on disc, we get the following behavior.
 
 @example
-@group
 for i = 1:2
   count_calls ();
 endfor
 @print{} 'count_calls' has been called 1 times
 @print{} 'count_calls' has been called 2 times
 
 clear
 for i = 1:2
@@ -290,17 +289,16 @@ endfor
 @print{} 'count_calls' has been called 2 times
 
 clear count_calls
 for i = 1:2
   count_calls();
 endfor
 @print{} 'count_calls' has been called 1 times
 @print{} 'count_calls' has been called 2 times
-@end group
 @end example
 
 @noindent
 That is, the persistent variable is only removed from memory when the
 function containing the variable is removed.  Note that if the function
 definition is typed directly into the Octave prompt, the persistent
 variable will be cleared by a simple @code{clear} command as the entire
 function definition will be removed from memory.  If you do not want
@@ -312,38 +310,42 @@ cleared, you should use the @code{mlock}
 @section Status of Variables
 
 When creating simple one-shot programs it can be very convenient to
 see which variables are available at the prompt.  The function @code{who}
 and its siblings @code{whos} and @code{whos_line_format} will show
 different information about what is in memory, as the following shows.
 
 @example
+@group
 str = "A random string";
 who -variables
      @print{} *** local user variables:
      @print{} 
      @print{} __nargin__  str
+@end group
 @end example
 
 @DOCSTRING(who)
 
 @DOCSTRING(whos)
 
 @DOCSTRING(whos_line_format)
 
 Instead of displaying which variables are in memory, it is possible
 to determine if a given variable is available.  That way it is possible
 to alter the behavior of a program depending on the existence of a
 variable.  The following example illustrates this.
 
 @example
+@group
 if (! exist ("meaning", "var"))
   disp ("The program has no 'meaning'");
 endif
+@end group
 @end example
 
 @DOCSTRING(exist)
 
 Usually Octave will manage the memory, but sometimes it can be practical
 to remove variables from memory manually.  This is usually needed when
 working with large variables that fill a substantial part of the memory.
 On a computer that uses the IEEE floating point format, the following
diff --git a/scripts/deprecated/exponential_rnd.m b/scripts/deprecated/exponential_rnd.m
--- a/scripts/deprecated/exponential_rnd.m
+++ b/scripts/deprecated/exponential_rnd.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} exponential_rnd (@var{lambda}, @var{r}, @var{c})
 ## @deftypefnx {Function File} {} exponential_rnd (@var{lambda}, @var{sz})
 ## Return an @var{r} by @var{c} matrix of random samples from the
 ## exponential distribution with parameter @var{lambda}, which must be a
-## scalar or of size @var{r} by @var{c}. Or if @var{sz} is a vector, 
+## scalar or of size @var{r} by @var{c}.  Or if @var{sz} is a vector, 
 ## create a matrix of size @var{sz}.
 ##
 ## If @var{r} and @var{c} are omitted, the size of the result matrix is
 ## the size of @var{lambda}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the exponential distribution
diff --git a/scripts/deprecated/geometric_rnd.m b/scripts/deprecated/geometric_rnd.m
--- a/scripts/deprecated/geometric_rnd.m
+++ b/scripts/deprecated/geometric_rnd.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} geometric_rnd (@var{p}, @var{r}, @var{c})
 ## @deftypefnx {Function File} {} geometric_rnd (@var{p}, @var{sz})
 ## Return an @var{r} by @var{c} matrix of random samples from the
 ## geometric distribution with parameter @var{p}, which must be a scalar
 ## or of size @var{r} by @var{c}.
 ##
 ## If @var{r} and @var{c} are given create a matrix with @var{r} rows and
-## @var{c} columns. Or if @var{sz} is a vector, create a matrix of size
+## @var{c} columns.  Or if @var{sz} is a vector, create a matrix of size
 ## @var{sz}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the geometric distribution
 
 ## Deprecated in version 3.0
 
diff --git a/scripts/deprecated/hypergeometric_pdf.m b/scripts/deprecated/hypergeometric_pdf.m
--- a/scripts/deprecated/hypergeometric_pdf.m
+++ b/scripts/deprecated/hypergeometric_pdf.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} hypergeometric_pdf (@var{x}, @var{m}, @var{t}, @var{n})
 ## Compute the probability density function (PDF) at @var{x} of the
 ## hypergeometric distribution with parameters @var{m}, @var{t}, and
-## @var{n}. This is the probability of obtaining @var{x} marked items
+## @var{n}.  This is the probability of obtaining @var{x} marked items
 ## when randomly drawing a sample of size @var{n} without replacement
 ## from a population of total size @var{t} containing @var{m} marked items.
 ##
 ## The arguments must be of common size or scalar.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: PDF of the hypergeometric distribution
diff --git a/scripts/deprecated/lognormal_rnd.m b/scripts/deprecated/lognormal_rnd.m
--- a/scripts/deprecated/lognormal_rnd.m
+++ b/scripts/deprecated/lognormal_rnd.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} lognormal_rnd (@var{a}, @var{v}, @var{r}, @var{c})
 ## @deftypefnx {Function File} {} lognormal_rnd (@var{a}, @var{v}, @var{sz})
 ## Return an @var{r} by @var{c} matrix of random samples from the
-## lognormal distribution with parameters @var{a} and @var{v}. Both
+## lognormal distribution with parameters @var{a} and @var{v}.  Both
 ## @var{a} and @var{v} must be scalar or of size @var{r} by @var{c}.
 ## Or if @var{sz} is a vector, create a matrix of size @var{sz}.
 ##
 ## If @var{r} and @var{c} are omitted, the size of the result matrix is
 ## the common size of @var{a} and @var{v}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
diff --git a/scripts/deprecated/pascal_rnd.m b/scripts/deprecated/pascal_rnd.m
--- a/scripts/deprecated/pascal_rnd.m
+++ b/scripts/deprecated/pascal_rnd.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} pascal_rnd (@var{n}, @var{p}, @var{r}, @var{c})
 ## @deftypefnx {Function File} {} pascal_rnd (@var{n}, @var{p}, @var{sz})
 ## Return an @var{r} by @var{c} matrix of random samples from the Pascal
 ## (negative binomial) distribution with parameters @var{n} and @var{p}.
 ## Both @var{n} and @var{p} must be scalar or of size @var{r} by @var{c}.
 ##
 ## If @var{r} and @var{c} are omitted, the size of the result matrix is
-## the common size of @var{n} and @var{p}. Or if @var{sz} is a vector, 
+## the common size of @var{n} and @var{p}.  Or if @var{sz} is a vector, 
 ## create a matrix of size @var{sz}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the Pascal distribution
 
 ## Deprecated in version 3.0
 
diff --git a/scripts/deprecated/spdet.m b/scripts/deprecated/spdet.m
--- a/scripts/deprecated/spdet.m
+++ b/scripts/deprecated/spdet.m
@@ -12,17 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Loadable Function} {[@var{d}, @var{rcond}] = } spdet (@var{a})
+## @deftypefn {Loadable Function} {[@var{d}, @var{rcond}] =} spdet (@var{a})
 ## This function has been deprecated.  Use @code{det} instead.
 ## @end deftypefn
 
 ## Deprecated in version 3.2
 
 function varargout = spdet (varargin)
   persistent warned = false;
   if (! warned)
diff --git a/scripts/deprecated/spdiag.m b/scripts/deprecated/spdiag.m
--- a/scripts/deprecated/spdiag.m
+++ b/scripts/deprecated/spdiag.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} spdiag (@var{v}, @var{k})
-## This function has been deprecated.  Use @code{sparse (diag (...))} instead.
+## This function has been deprecated.  Use @code{sparse (diag (@dots{}))} instead.
 ## @end deftypefn
 
 ## Deprecated in version 3.2
 
 function retval = spdiag (varargin)
   persistent warned = false;
   if (! warned)
     warned = true;
diff --git a/scripts/deprecated/split.m b/scripts/deprecated/split.m
--- a/scripts/deprecated/split.m
+++ b/scripts/deprecated/split.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} split (@var{s}, @var{t}, @var{n})
-## This function has been deprecated. Use @code{char (strsplit (s, t))}
+## This function has been deprecated.  Use @code{char (strsplit (s, t))}
 ## instead.
 ## @end deftypefn
 
 ## Divides the string @var{s} into pieces separated by @var{t}, returning
 ## the result in a string array (padded with blanks to form a valid
 ## matrix).  If the optional input @var{n} is supplied, split @var{s}
 ## into at most @var{n} different pieces.
 ##
diff --git a/scripts/deprecated/str2mat.m b/scripts/deprecated/str2mat.m
--- a/scripts/deprecated/str2mat.m
+++ b/scripts/deprecated/str2mat.m
@@ -18,17 +18,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} str2mat (@var{s_1}, @dots{}, @var{s_n})
 ## Return a matrix containing the strings @var{s_1}, @dots{}, @var{s_n} as
 ## its rows.  Each string is padded with blanks in order to form a valid
 ## matrix.
 ##
-## This function is modelled after @sc{Matlab}.  In Octave, you can create
+## This function is modelled after @sc{matlab}.  In Octave, you can create
 ## a matrix of strings by @code{[@var{s_1}; @dots{}; @var{s_n}]} even if
 ## the strings are not all the same length.
 ## @end deftypefn
 
 ## Author: Kurt Hornik <Kurt.Hornik@wu-wien.ac.at>
 ## Adapted-By: jwe
 
 ## Deprecated in version 3.2
diff --git a/scripts/deprecated/t_rnd.m b/scripts/deprecated/t_rnd.m
--- a/scripts/deprecated/t_rnd.m
+++ b/scripts/deprecated/t_rnd.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} t_rnd (@var{n}, @var{r}, @var{c})
 ## @deftypefnx {Function File} {} t_rnd (@var{n}, @var{sz})
 ## Return an @var{r} by @var{c} matrix of random samples from the t
 ## (Student) distribution with @var{n} degrees of freedom.  @var{n} must
-## be a scalar or of size @var{r} by @var{c}. Or if @var{sz} is a
+## be a scalar or of size @var{r} by @var{c}.  Or if @var{sz} is a
 ## vector create a matrix of size @var{sz}.
 ##
 ## If @var{r} and @var{c} are omitted, the size of the result matrix is
 ## the size of @var{n}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the t distribution
diff --git a/scripts/deprecated/weibrnd.m b/scripts/deprecated/weibrnd.m
--- a/scripts/deprecated/weibrnd.m
+++ b/scripts/deprecated/weibrnd.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} weibrnd (@var{scale}, @var{shape}, @var{r}, @var{c})
 ## @deftypefnx {Function File} {} weibrnd (@var{scale}, @var{shape}, @var{sz})
 ## Return an @var{r} by @var{c} matrix of random samples from the
 ## Weibull distribution with parameters @var{scale} and @var{shape}
-## which must be scalar or of size @var{r} by @var{c}. Or if @var{sz}
+## which must be scalar or of size @var{r} by @var{c}.  Or if @var{sz}
 ## is a vector return a matrix of size @var{sz}.
 ##
 ## If @var{r} and @var{c} are omitted, the size of the result matrix is
 ## the common size of @var{alpha} and @var{sigma}.
 ## @end deftypefn
 
 ## Deprecated in version 3.0
 
diff --git a/scripts/deprecated/weibull_rnd.m b/scripts/deprecated/weibull_rnd.m
--- a/scripts/deprecated/weibull_rnd.m
+++ b/scripts/deprecated/weibull_rnd.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} weibull_rnd (@var{shape}, @var{scale}, @var{r}, @var{c})
 ## @deftypefnx {Function File} {} weibull_rnd (@var{shape}, @var{scale}, @var{sz})
 ## Return an @var{r} by @var{c} matrix of random samples from the
 ## Weibull distribution with parameters @var{scale} and @var{shape}
-## which must be scalar or of size @var{r} by @var{c}. Or if @var{sz}
+## which must be scalar or of size @var{r} by @var{c}.  Or if @var{sz}
 ## is a vector return a matrix of size @var{sz}.
 ##
 ## If @var{r} and @var{c} are omitted, the size of the result matrix is
 ## the common size of @var{alpha} and @var{sigma}.
 ## @end deftypefn
 
 ## Deprecated in version 3.0
 
diff --git a/scripts/deprecated/wiener_rnd.m b/scripts/deprecated/wiener_rnd.m
--- a/scripts/deprecated/wiener_rnd.m
+++ b/scripts/deprecated/wiener_rnd.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} wiener_rnd (@var{t}, @var{d}, @var{n})
 ## Return a simulated realization of the @var{d}-dimensional Wiener Process
 ## on the interval [0, @var{t}].  If @var{d} is omitted, @var{d} = 1 is
-## used. The first column of the return matrix contains time, the
+## used.  The first column of the return matrix contains time, the
 ## remaining columns contain the Wiener process.
 ##
 ## The optional parameter @var{n} gives the number of summands used for
 ## simulating the process over an interval of length 1.  If @var{n} is
 ## omitted, @var{n} = 1000 is used.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
diff --git a/scripts/general/diff.m b/scripts/general/diff.m
--- a/scripts/general/diff.m
+++ b/scripts/general/diff.m
@@ -29,17 +29,17 @@
 ## @ifnottex
 ##  @var{x}(2) - @var{x}(1), @dots{}, @var{x}(n) - @var{x}(n-1).
 ## @end ifnottex
 ##
 ## If @var{x} is a matrix, @code{diff (@var{x})} is the matrix of column
 ## differences along the first non-singleton dimension.
 ##
 ## The second argument is optional.  If supplied, @code{diff (@var{x},
-## @var{k})}, where @var{k} is a nonnegative integer, returns the
+## @var{k})}, where @var{k} is a non-negative integer, returns the
 ## @var{k}-th differences.  It is possible that @var{k} is larger than
 ## then first non-singleton dimension of the matrix.  In this case,
 ## @code{diff} continues to take the differences along the next
 ## non-singleton dimension.
 ##
 ## The dimension along which to take the difference can be explicitly
 ## stated with the optional variable @var{dim}.  In this case the 
 ## @var{k}-th order differences are calculated along this dimension.
diff --git a/scripts/general/interp3.m b/scripts/general/interp3.m
--- a/scripts/general/interp3.m
+++ b/scripts/general/interp3.m
@@ -23,18 +23,18 @@
 ## @deftypefnx {Function File} {@var{vi} =} interp3 (@var{v})
 ## @deftypefnx {Function File} {@var{vi} =} interp3 (@dots{}, @var{method})
 ## @deftypefnx {Function File} {@var{vi} =} interp3 (@dots{}, @var{method}, @var{extrapval})
 ##
 ## Perform 3-dimensional interpolation.  Each element of the 3-dimensional 
 ## array @var{v} represents a value at a location given by the parameters 
 ## @var{x}, @var{y}, and @var{z}.  The parameters @var{x}, @var{x}, and 
 ## @var{z} are either 3-dimensional arrays of the same size as the array 
-## @var{v} in the 'meshgrid' format or vectors.  The parameters @var{xi}, etc 
-## respect a similar format to @var{x}, etc, and they represent the points 
+## @var{v} in the 'meshgrid' format or vectors.  The parameters @var{xi}, etc. 
+## respect a similar format to @var{x}, etc., and they represent the points 
 ## at which the array @var{vi} is interpolated.
 ##
 ## If @var{x}, @var{y}, @var{z} are omitted, they are assumed to be 
 ## @code{x = 1 : size (@var{v}, 2)}, @code{y = 1 : size (@var{v}, 1)} and
 ## @code{z = 1 : size (@var{v}, 3)}.  If @var{m} is specified, then
 ## the interpolation adds a point half way between each of the interpolation 
 ## points.  This process is performed @var{m} times.  If only @var{v} is 
 ## specified, then @var{m} is assumed to be @code{1}.
diff --git a/scripts/general/interpn.m b/scripts/general/interpn.m
--- a/scripts/general/interpn.m
+++ b/scripts/general/interpn.m
@@ -24,18 +24,18 @@
 ## @deftypefnx {Function File} {@var{vi} =} interpn (@dots{}, @var{method})
 ## @deftypefnx {Function File} {@var{vi} =} interpn (@dots{}, @var{method}, @var{extrapval})
 ##
 ## Perform @var{n}-dimensional interpolation, where @var{n} is at least two. 
 ## Each element of the @var{n}-dimensional array @var{v} represents a value 
 ## at a location given by the parameters @var{x1}, @var{x2}, @dots{}, @var{xn}. 
 ## The parameters @var{x1}, @var{x2}, @dots{}, @var{xn} are either 
 ## @var{n}-dimensional arrays of the same size as the array @var{v} in 
-## the 'ndgrid' format or vectors.  The parameters @var{y1}, etc respect a 
-## similar format to @var{x1}, etc, and they represent the points at which
+## the 'ndgrid' format or vectors.  The parameters @var{y1}, etc. respect a 
+## similar format to @var{x1}, etc., and they represent the points at which
 ## the array @var{vi} is interpolated.
 ##
 ## If @var{x1}, @dots{}, @var{xn} are omitted, they are assumed to be 
 ## @code{x1 = 1 : size (@var{v}, 1)}, etc.  If @var{m} is specified, then
 ## the interpolation adds a point half way between each of the interpolation 
 ## points.  This process is performed @var{m} times.  If only @var{v} is 
 ## specified, then @var{m} is assumed to be @code{1}.
 ##
diff --git a/scripts/general/quadl.m b/scripts/general/quadl.m
--- a/scripts/general/quadl.m
+++ b/scripts/general/quadl.m
@@ -29,17 +29,17 @@
 ## the function to evaluate.  The function @var{f} must return a vector
 ## of output values if given a vector of input values.
 ##
 ## If defined, @var{tol} defines the relative tolerance to which to
 ## which to integrate @code{@var{f}(@var{x})}.  While if @var{trace} is
 ## defined, displays the left end point of the current interval, the 
 ## interval length, and the partial integral.
 ##
-## Additional arguments @var{p1}, etc, are passed directly to @var{f}.
+## Additional arguments @var{p1}, etc., are passed directly to @var{f}.
 ## To use default values for @var{tol} and @var{trace}, one may pass
 ## empty matrices.
 ##
 ## Reference: W. Gander and W. Gautschi, 'Adaptive Quadrature - 
 ## Revisited', BIT Vol. 40, No. 1, March 2000, pp. 84--101.
 ## @url{http://www.inf.ethz.ch/personal/gander/}
 ##
 ## @end deftypefn
diff --git a/scripts/general/quadv.m b/scripts/general/quadv.m
--- a/scripts/general/quadv.m
+++ b/scripts/general/quadv.m
@@ -31,17 +31,17 @@
 ## must accept a string, and can return a vector representing the
 ## approximation to @var{n} different sub-functions.
 ##
 ## If defined, @var{tol} defines the absolute tolerance to which to
 ## which to integrate each sub-interval of @code{@var{f}(@var{x})}.
 ## While if @var{trace} is defined, displays the left end point of the
 ## current interval, the interval length, and the partial integral.
 ##
-## Additional arguments @var{p1}, etc, are passed directly to @var{f}.
+## Additional arguments @var{p1}, etc., are passed directly to @var{f}.
 ## To use default values for @var{tol} and @var{trace}, one may pass
 ## empty matrices.
 ## @seealso{triplequad, dblquad, quad, quadl, quadgk, trapz}
 ## @end deftypefn
 
 function [q, fcnt] = quadv (f, a, b, tol, trace, varargin)
   if (nargin < 3)
     print_usage ();
diff --git a/scripts/miscellaneous/version.m b/scripts/miscellaneous/version.m
--- a/scripts/miscellaneous/version.m
+++ b/scripts/miscellaneous/version.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} version ()
 ## Return Octave's version number as a string.  This is also the value of
-## the built-in variable @code{OCTAVE_VERSION}.
+## the built-in variable @w{@code{OCTAVE_VERSION}}.
 ## @end deftypefn
 
 ## Author: jwe
 
 function vs = version ()
 
   if (nargin != 0)
     warning ("version: ignoring extra arguments");
diff --git a/scripts/optimization/fsolve.m b/scripts/optimization/fsolve.m
--- a/scripts/optimization/fsolve.m
+++ b/scripts/optimization/fsolve.m
@@ -86,40 +86,38 @@
 ## employ OutputFcn: After a vector is evaluated for residuals, if OutputFcn is
 ## called with that vector, then the intermediate results should be saved for
 ## future jacobian evaluation, and should be kept until a jacobian evaluation
 ## is requested or until outputfcn is called with a different vector, in which
 ## case they should be dropped in favor of this most recent vector.  A short
 ## example how this can be achieved follows:
 ##
 ## @example
-## @group
 ## function [fvec, fjac] = user_func (x, optimvalues, state)
 ## persistent sav = [], sav0 = [];
 ## if (nargin == 1)
 ##   ## evaluation call
 ##   if (nargout == 1)
 ##     sav0.x = x; # mark saved vector
 ##     ## calculate fvec, save results to sav0.
 ##   elseif (nargout == 2)
 ##     ## calculate fjac using sav.
 ##   endif
 ## else
 ##   ## outputfcn call.
 ##   if (all (x == sav0.x))
 ##     sav = sav0;
 ##   endif
-##   ## maybe output iteration status etc.
+##   ## maybe output iteration status, etc.
 ## endif
 ## endfunction
 ##
 ## ## @dots{}.
 ## 
 ## fsolve (@@user_func, x0, optimset ("OutputFcn", @@user_func, @dots{}))
-## @end group
 ## @end example
 ###
 ## @end deftypefn
 
 ## PKG_ADD: __all_opts__ ("fsolve");
 
 function [x, fvec, info, output, fjac] = fsolve (fcn, x0, options = struct ())
 
diff --git a/scripts/optimization/sqp.m b/scripts/optimization/sqp.m
--- a/scripts/optimization/sqp.m
+++ b/scripts/optimization/sqp.m
@@ -147,17 +147,16 @@
 ## the default value is 100.
 ##
 ## The eighth argument is tolerance for stopping criteria.  If not specified,
 ## the default value is @var{eps}.
 ##
 ## Here is an example of calling @code{sqp}:
 ##
 ## @example
-## @group
 ## function r = g (x)
 ##   r = [ sumsq(x)-10;
 ##         x(2)*x(3)-5*x(4)*x(5); 
 ##         x(1)^3+x(2)^3+1 ];
 ## endfunction
 ##
 ## function obj = phi (x)
 ##   obj = exp(prod(x)) - 0.5*(x(1)^3+x(2)^3+1)^2;
@@ -179,17 +178,16 @@
 ## info = 101
 ## iter = 8
 ## nf = 10
 ## lambda =
 ##     
 ##   -0.0401627
 ##    0.0379578
 ##   -0.0052227
-## @end group
 ## @end example
 ##
 ## The value returned in @var{info} may be one of the following:
 ## @table @asis
 ## @item 101
 ## The algorithm terminated because the norm of the last step was less
 ## than @code{tol * norm (x))} (the value of tol is currently fixed at
 ## @code{sqrt (eps)}---edit @file{sqp.m} to modify this value.
diff --git a/scripts/plot/axis.m b/scripts/plot/axis.m
--- a/scripts/plot/axis.m
+++ b/scripts/plot/axis.m
@@ -18,18 +18,18 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} axis (@var{limits})
 ## Set axis limits for plots.
 ##
 ## The argument @var{limits} should be a 2, 4, or 6 element vector.  The
 ## first and second elements specify the lower and upper limits for the x
-## axis.  The third and fourth specify the limits for the y axis, and the
-## fifth and sixth specify the limits for the z axis.
+## axis.  The third and fourth specify the limits for the y-axis, and the
+## fifth and sixth specify the limits for the z-axis.
 ##
 ## Without any arguments, @code{axis} turns autoscaling on.  
 ##
 ## With one output argument, @code{x = axis} returns the current axes 
 ##
 ## The vector argument specifying limits is optional, and additional
 ## string arguments may be used to specify various axis properties.  For
 ## example,
diff --git a/scripts/plot/errorbar.m b/scripts/plot/errorbar.m
--- a/scripts/plot/errorbar.m
+++ b/scripts/plot/errorbar.m
@@ -34,17 +34,17 @@
 ## If more than two arguments are given, they are interpreted as
 ##
 ## @example
 ## errorbar (@var{x}, @var{y}, @dots{}, @var{fmt}, @dots{})
 ## @end example
 ##
 ## @noindent
 ## where after @var{x} and @var{y} there can be up to four error
-## parameters such as @var{ey}, @var{ex}, @var{ly}, @var{uy} etc.,
+## parameters such as @var{ey}, @var{ex}, @var{ly}, @var{uy}, etc.,
 ## depending on the plot type.  Any number of argument sets may appear,
 ## as long as they are separated with a format string @var{fmt}.
 ##
 ## If @var{y} is a matrix, @var{x} and error parameters must also be matrices
 ## having same dimensions.  The columns of @var{y} are plotted versus the
 ## corresponding columns of @var{x} and errorbars are drawn from
 ## the corresponding columns of error parameters.
 ##
diff --git a/scripts/plot/meshgrid.m b/scripts/plot/meshgrid.m
--- a/scripts/plot/meshgrid.m
+++ b/scripts/plot/meshgrid.m
@@ -17,17 +17,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{xx}, @var{yy}, @var{zz}] =} meshgrid (@var{x}, @var{y}, @var{z})
 ## @deftypefnx {Function File} {[@var{xx}, @var{yy}] =} meshgrid (@var{x}, @var{y})
 ## @deftypefnx {Function File} {[@var{xx}, @var{yy}] =} meshgrid (@var{x})
 ## Given vectors of @var{x} and @var{y} and @var{z} coordinates, and
-## returning 3 arguments, return three dimensional arrays corresponding
+## returning 3 arguments, return three-dimensional arrays corresponding
 ## to the @var{x}, @var{y}, and @var{z} coordinates of a mesh.  When
 ## returning only 2 arguments, return matrices corresponding to the
 ## @var{x} and @var{y} coordinates of a mesh.  The rows of @var{xx} are
 ## copies of @var{x}, and the columns of @var{yy} are copies of @var{y}.
 ## If @var{y} is omitted, then it is assumed to be the same as @var{x},
 ## and @var{z} is assumed the same as @var{y}.
 ## @seealso{mesh, contour}
 ## @end deftypefn
diff --git a/scripts/plot/plotmatrix.m b/scripts/plot/plotmatrix.m
--- a/scripts/plot/plotmatrix.m
+++ b/scripts/plot/plotmatrix.m
@@ -44,17 +44,17 @@
 ## string defining a marker in the same manner as the @code{plot}
 ## command.  If a leading axes handle @var{h} is passed to
 ## @code{plotmatrix}, then this axis will be used for the plot.
 ##
 ## The optional return value @var{h} provides handles to the individual
 ## graphics objects in the scatter plots, whereas @var{ax} returns the
 ## handles to the scatter plot axis objects.  @var{bigax} is a hidden
 ## axis object that surrounds the other axes, such that the commands 
-## @code{xlabel}, @code{title}, etc, will be associated with this hidden
+## @code{xlabel}, @code{title}, etc., will be associated with this hidden
 ## axis.  Finally @var{p} returns the graphics objects associated with
 ## the histogram and @var{pax} the corresponding axes objects.
 ##
 ## @example
 ## @group
 ## plotmatrix (randn (100, 3), 'g+')
 ## @end group
 ## @end example
diff --git a/scripts/plot/print.m b/scripts/plot/print.m
--- a/scripts/plot/print.m
+++ b/scripts/plot/print.m
@@ -29,17 +29,17 @@
 ## the handle for the current figure is used.
 ##
 ## @var{options}:
 ## @table @code
 ## @item -P@var{printer}
 ##   Set the @var{printer} name to which the graph is sent if no
 ##   @var{filename} is specified.
 ## @item -G@var{ghostscript_command}
-##   Specify the command for calling Ghostscript. For Unix and Windows,
+##   Specify the command for calling Ghostscript.  For Unix and Windows,
 ## the defaults are 'gs' and 'gswin32c', respectively.
 ## @item -color
 ## @itemx -mono
 ##   Monochrome or color lines.
 ## @item -solid
 ## @itemx -dashed
 ##   Solid or dashed lines.
 ## @item -portrait
@@ -58,20 +58,20 @@
 ##   @itemx epsc
 ##   @itemx epsc2
 ##     Encapsulated postscript (level 1 and 2, mono and color)
 ##   @item tex
 ##   @itemx epslatex
 ##   @itemx epslatexstandalone
 ##   @itemx pstex
 ##   @itemx pslatex
-##     Generate a LaTeX (or TeX) file for labels, and eps/ps for
+##     Generate a @LaTeX{} (or @TeX{}) file for labels, and eps/ps for
 ## graphics.  The file produced by @code{epslatexstandalone} can be
-## processed directly by LaTeX.  The other formats are intended to
-## be included in a LaTeX (or TeX) document.  The @code{tex} device
+## processed directly by @LaTeX{}.  The other formats are intended to
+## be included in a @LaTeX{} (or @TeX{}) document.  The @code{tex} device
 ## is the same as the @code{epslatex} device.
 ##   @item ill
 ##   @itemx aifm
 ##     Adobe Illustrator
 ##   @item cdr
 ##   @itemx corel
 ##     CorelDraw
 ##   @item dxf
@@ -126,34 +126,34 @@
 ##   @item ppm
 ##     Portable Pixel Map file format
 ##   @end table
 ##
 ##   For a complete list, type `system ("gs -h")' to see what formats
 ## and devices are available.
 ##
 ##   For output sent to a printer, the size is determined by the
-## figure's "papersize" property. For output to a file the, size
+## figure's "papersize" property.  For output to a file the, size
 ## is determined by the "paperposition" property.
 ##
 ## @itemx -r@var{NUM}
-##   Resolution of bitmaps in pixels per inch. For both metafiles and 
+##   Resolution of bitmaps in pixels per inch.  For both metafiles and 
 ## SVG the default is the screen resolution, for other it is 150 dpi.
 ## To specify screen resolution, use "-r0".
 ##
 ## @item -tight
-##   Forces a tight bounding box for eps-files. Since the ghostscript
+##   Forces a tight bounding box for eps-files.  Since the ghostscript
 ## devices are conversion of an eps-file, this option works the those
 ## devices as well.
 ##
 ## @itemx -S@var{xsize},@var{ysize}
-##   Plot size in pixels for EMF, GIF, JPEG, PBM, PNG and SVG. If
+##   Plot size in pixels for EMF, GIF, JPEG, PBM, PNG and SVG.  If
 ## using the command form of the print function, you must quote the
 ## @var{xsize},@var{ysize} option.  For example, by writing
-## @code{"-S640,480"}.  The size defaults to that specified by the
+## @w{@code{"-S640,480"}}.  The size defaults to that specified by the
 ## figure's paperposition property.
 ##
 ## @item -F@var{fontname}
 ## @itemx -F@var{fontname}:@var{size}
 ## @itemx -F:@var{size}
 ##   @var{fontname} set the postscript font (for use with postscript,
 ## aifm, corel and fig).  By default, 'Helvetica' is set for PS/Aifm,
 ## and 'SwitzerlandLight' for Corel.  It can also be 'Times-Roman'.
diff --git a/scripts/plot/slice.m b/scripts/plot/slice.m
--- a/scripts/plot/slice.m
+++ b/scripts/plot/slice.m
@@ -23,17 +23,17 @@
 ## @deftypefnx {Function File} {} slice (@var{v}, @var{xi}, @var{yi}, @var{zi})
 ## @deftypefnx {Function File} {@var{h} =} slice (@dots{})
 ## @deftypefnx {Function File} {@var{h} =} slice (@dots{}, @var{method})
 ## Plot slices of 3D data/scalar fields.  Each element of the 3-dimensional 
 ## array @var{v} represents a scalar value at a location given by the
 ## parameters @var{x}, @var{y}, and @var{z}.  The parameters @var{x},
 ## @var{x}, and @var{z} are either 3-dimensional arrays of the same size
 ## as the array @var{v} in the "meshgrid" format or vectors.  The
-## parameters @var{xi}, etc respect a similar format to @var{x}, etc,
+## parameters @var{xi}, etc. respect a similar format to @var{x}, etc.,
 ## and they represent the points at which the array @var{vi} is
 ## interpolated using interp3.  The vectors @var{sx}, @var{sy}, and
 ## @var{sz} contain points of orthogonal slices of the respective axes.
 ##
 ## If @var{x}, @var{y}, @var{z} are omitted, they are assumed to be 
 ## @code{x = 1:size (@var{v}, 2)}, @code{y = 1:size (@var{v}, 1)} and
 ## @code{z = 1:size (@var{v}, 3)}. 
 ##
diff --git a/scripts/plot/xlim.m b/scripts/plot/xlim.m
--- a/scripts/plot/xlim.m
+++ b/scripts/plot/xlim.m
@@ -17,22 +17,22 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{xl} =} xlim ()
 ## @deftypefnx {Function File} {} xlim (@var{xl})
 ## @deftypefnx {Function File} {@var{m} =} xlim ('mode')
 ## @deftypefnx {Function File} {} xlim (@var{m})
 ## @deftypefnx {Function File} {} xlim (@var{h}, @dots{})
-## Get or set the limits of the x axis of the current plot.  Called without
-## arguments @code{xlim} returns the x axis limits of the current plot.
-## If passed a two element vector @var{xl}, the limits of the x axis are set
+## Get or set the limits of the x-axis of the current plot.  Called without
+## arguments @code{xlim} returns the x-axis limits of the current plot.
+## If passed a two element vector @var{xl}, the limits of the x-axis are set
 ## to this value.
 ##
-## The current mode for calculation of the x axis can be returned with a
+## The current mode for calculation of the x-axis can be returned with a
 ## call @code{xlim ('mode')}, and can be either 'auto' or 'manual'.  The 
 ## current plotting mode can be set by passing either 'auto' or 'manual' 
 ## as the argument.
 ##
 ## If passed an handle as the first argument, then operate on this handle
 ## rather than the current axes handle.
 ## @seealso{ylim, zlim, set, get, gca}
 ## @end deftypefn
diff --git a/scripts/plot/ylim.m b/scripts/plot/ylim.m
--- a/scripts/plot/ylim.m
+++ b/scripts/plot/ylim.m
@@ -17,22 +17,22 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{xl} =} ylim ()
 ## @deftypefnx {Function File} {} ylim (@var{xl})
 ## @deftypefnx {Function File} {@var{m} =} ylim ('mode')
 ## @deftypefnx {Function File} {} ylim (@var{m})
 ## @deftypefnx {Function File} {} ylim (@var{h}, @dots{})
-## Get or set the limits of the y axis of the current plot.  Called without
-## arguments @code{ylim} returns the y axis limits of the current plot.
-## If passed a two element vector @var{xl}, the limits of the y axis are set
+## Get or set the limits of the y-axis of the current plot.  Called without
+## arguments @code{ylim} returns the y-axis limits of the current plot.
+## If passed a two element vector @var{xl}, the limits of the y-axis are set
 ## to this value.
 ##
-## The current mode for calculation of the y axis can be returned with a
+## The current mode for calculation of the y-axis can be returned with a
 ## call @code{ylim ('mode')}, and can be either 'auto' or 'manual'.  The 
 ## current plotting mode can be set by passing either 'auto' or 'manual' 
 ## as the argument.
 ##
 ## If passed an handle as the first argument, then operate on this handle
 ## rather than the current axes handle.
 ## @seealso{xlim, zlim, set, get, gca}
 ## @end deftypefn
diff --git a/scripts/plot/zlim.m b/scripts/plot/zlim.m
--- a/scripts/plot/zlim.m
+++ b/scripts/plot/zlim.m
@@ -17,22 +17,22 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{xl} =} zlim ()
 ## @deftypefnx {Function File} {} zlim (@var{xl})
 ## @deftypefnx {Function File} {@var{m} =} zlim ('mode')
 ## @deftypefnx {Function File} {} zlim (@var{m})
 ## @deftypefnx {Function File} {} zlim (@var{h}, @dots{})
-## Get or set the limits of the z axis of the current plot.  Called without
-## arguments @code{zlim} returns the z axis limits of the current plot.
-## If passed a two element vector @var{xl}, the limits of the z axis are set
+## Get or set the limits of the z-axis of the current plot.  Called without
+## arguments @code{zlim} returns the z-axis limits of the current plot.
+## If passed a two element vector @var{xl}, the limits of the z-axis are set
 ## to this value.
 ##
-## The current mode for calculation of the z axis can be returned with a
+## The current mode for calculation of the z-axis can be returned with a
 ## call @code{zlim ('mode')}, and can be either 'auto' or 'manual'.  The 
 ## current plotting mode can be set by passing either 'auto' or 'manual' 
 ## as the argument.
 ##
 ## If passed an handle as the first argument, then operate on this handle
 ## rather than the current axes handle.
 ## @seealso{xlim, ylim, set, get, gca}
 ## @end deftypefn
diff --git a/scripts/sparse/svds.m b/scripts/sparse/svds.m
--- a/scripts/sparse/svds.m
+++ b/scripts/sparse/svds.m
@@ -21,17 +21,17 @@
 ## @deftypefnx {Function File} {[@var{u}, @var{s}, @var{v}, @var{flag}] =} svds (@dots{})
 ##
 ## Find a few singular values of the matrix @var{a}.  The singular values
 ## are calculated using 
 ##
 ## @example
 ## @group
 ## [@var{m}, @var{n}] = size(@var{a})
-## @var{s} = eigs([sparse(@var{m}, @var{m}), @var{a}; @dots{}
+## @var{s} = eigs([sparse(@var{m}, @var{m}), @var{a}; ...
 ##                 @var{a}', sparse(@var{n}, @var{n})])
 ## @end group
 ## @end example
 ##
 ## The eigenvalues returned by @code{eigs} correspond to the singular
 ## values of @var{a}.  The number of singular values to calculate is given
 ## by @var{k}, whose default value is 6.
 ## 
@@ -64,17 +64,17 @@
 ##
 ## If more than one output argument is given, then @code{svds} also
 ## calculates the left and right singular vectors of @var{a}.  @var{flag}
 ## is used to signal the convergence of @code{svds}.  If @code{svds} 
 ## converges to the desired tolerance, then @var{flag} given by
 ##
 ## @example
 ## @group
-## norm (@var{a} * @var{v} - @var{u} * @var{s}, 1) <= @dots{}
+## norm (@var{a} * @var{v} - @var{u} * @var{s}, 1) <= ...
 ##         @var{tol} * norm (@var{a}, 1)
 ## @end group
 ## @end example
 ##
 ## will be zero.
 ## @end deftypefn
 ## @seealso{eigs}
 
diff --git a/scripts/specfun/nchoosek.m b/scripts/specfun/nchoosek.m
--- a/scripts/specfun/nchoosek.m
+++ b/scripts/specfun/nchoosek.m
@@ -45,17 +45,17 @@
 ## @end example
 ## @end ifnottex
 ##
 ## If @var{n} is a vector generate all combinations of the elements
 ## of @var{n}, taken @var{k} at a time, one row per combination.  The 
 ## resulting @var{c} has size @code{[nchoosek (length (@var{n}), 
 ## @var{k}), @var{k}]}.
 ##
-## @code{nchoosek} works only for nonnegative integer arguments; use
+## @code{nchoosek} works only for non-negative integer arguments; use
 ## @code{bincoeff} for non-integer scalar arguments and for using vector
 ## arguments to compute many coefficients at once.
 ##
 ## @seealso{bincoeff}
 ## @end deftypefn
 
 ## Author: Rolf Fabian  <fabian@tu-cottbus.de>
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
diff --git a/scripts/special-matrix/pascal.m b/scripts/special-matrix/pascal.m
--- a/scripts/special-matrix/pascal.m
+++ b/scripts/special-matrix/pascal.m
@@ -19,17 +19,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} pascal (@var{n}, @var{t})
 ##
 ## Return the Pascal matrix of order @var{n} if @code{@var{t} = 0}.
 ## @var{t} defaults to 0. Return lower triangular Cholesky factor of 
 ## the Pascal matrix if @code{@var{t} = 1}.  This matrix is its own
 ## inverse, that is @code{pascal (@var{n}, 1) ^ 2 == eye (@var{n})}.
-## If @code{@var{t} = -1}, return its absolute value. This is the
+## If @code{@var{t} = -1}, return its absolute value.  This is the
 ## standard pascal triangle as a lower-triangular matrix.
 ## If @code{@var{t} = 2}, return a transposed and permuted version of
 ## @code{pascal (@var{n}, 1)}, which is the cube-root of the identity
 ## matrix.  That is @code{pascal (@var{n}, 2) ^ 3 == eye (@var{n})}.
 ##
 ## @seealso{hankel, vander, sylvester_matrix, hilb, invhilb, toeplitz
 ##           hadamard, wilkinson, compan, rosser}
 ## @end deftypefn
diff --git a/scripts/strings/dec2base.m b/scripts/strings/dec2base.m
--- a/scripts/strings/dec2base.m
+++ b/scripts/strings/dec2base.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} dec2base (@var{n}, @var{b}, @var{len})
 ## Return a string of symbols in base @var{b} corresponding to
-## the nonnegative integer @var{n}.
+## the non-negative integer @var{n}.
 ##
 ## @example
 ## @group
 ## dec2base (123, 3)
 ##      @result{} "11120"
 ## @end group
 ## @end example
 ##
diff --git a/scripts/strings/dec2bin.m b/scripts/strings/dec2bin.m
--- a/scripts/strings/dec2bin.m
+++ b/scripts/strings/dec2bin.m
@@ -14,17 +14,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} dec2bin (@var{n}, @var{len})
-## Return a binary number corresponding to the nonnegative decimal number
+## Return a binary number corresponding to the non-negative decimal number
 ## @var{n}, as a string of ones and zeros.  For example,
 ##
 ## @example
 ## @group
 ## dec2bin (14)
 ##      @result{} "1110"
 ## @end group
 ## @end example
diff --git a/scripts/strings/dec2hex.m b/scripts/strings/dec2hex.m
--- a/scripts/strings/dec2hex.m
+++ b/scripts/strings/dec2hex.m
@@ -14,17 +14,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} dec2hex (@var{n}, @var{len})
-## Return the hexadecimal string corresponding to the nonnegative 
+## Return the hexadecimal string corresponding to the non-negative 
 ## integer @var{n}.  For example,
 ##
 ## @example
 ## @group
 ## dec2hex (2748)
 ##      @result{} "ABC"
 ## @end group
 ## @end example
diff --git a/scripts/strings/validatestring.m b/scripts/strings/validatestring.m
--- a/scripts/strings/validatestring.m
+++ b/scripts/strings/validatestring.m
@@ -13,18 +13,18 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{validstr} =} validatestring (@var{str}, @var{strarray})
-## @deftypefnx {Function File} {@var{validstr} =} validatestring (@var{str}, @var{strarray}, @var{funname})
-## @deftypefnx {Function File} {@var{validstr} =} validatestring (@var{str}, @var{strarray}, @var{funname}, @var{varname})
+## @deftypefnx {Function File} {@var{validstr} =} validatestring (@var{str}, @var{strarray}, @var{funcname})
+## @deftypefnx {Function File} {@var{validstr} =} validatestring (@var{str}, @var{strarray}, @var{funcname}, @var{varname})
 ## @deftypefnx {Function File} {@var{validstr} =} validatestring (@dots{}, @var{position})
 ## Verify that @var{str} is a string or substring of an element of
 ## @var{strarray}.
 ##
 ## @var{str} is a character string to be tested, and @var{strarray} is a
 ## cellstr of valid values.  @var{validstr} will be the validated form
 ## of @var{str} where validation is defined as @var{str} being a member
 ## or substring of @var{validstr}.  If @var{str} is a substring of
@@ -40,67 +40,67 @@
 
 function str = validatestring (str, strarray, varargin)
 
   if (nargin < 2 || nargin > 5)
     print_usage ();
   endif
 
   ## set the defaults
-  funname = "";
+  funcname = "";
   varname = "";
   position = 0;
   ## set the actual values
   if (! isempty (varargin))
     if (isnumeric (varargin{end}))
       position = varargin{end};
       varargin(end) = [];
     endif
   endif
-  funnameset = false;
+  funcnameset = false;
   varnameset = false;
   for i = 1:numel (varargin)
     if (ischar (varargin{i}))
       if (varnameset)
         error ("validatestring: invalid number of character inputs: %d",
                numel (varargin));
-      elseif (funnameset)
+      elseif (funcnameset)
         varname = varargin{i};
         varnameset = true;
       else
-        funname = varargin{i};
-        funnameset = true;
+        funcname = varargin{i};
+        funcnameset = true;
       endif
     endif
   endfor
 
   ## Check the inputs
   if (! ischar (str))
     error ("validatestring: str must be a character string");
   elseif (rows (str) != 1)
     error ("validatestring: str must have only one row");
   elseif (! iscellstr (strarray))
     error ("validatestring: strarray must be a cellstr");
-  elseif (! ischar (funname))
-    error ("validatestring: funname must be a character string");
-  elseif (! isempty (funname) && (rows (funname) != 1))
-    error ("validatestring: funname must be exactly one row");
+  elseif (! ischar (funcname))
+    error ("validatestring: funcname must be a character string");
+  elseif (! isempty (funcname) && (rows (funcname) != 1))
+    error ("validatestring: funcname must be exactly one row");
   elseif (! ischar (varname))
     error ("validatestring: varname must be a character string");
   elseif (! isempty (varname) && (rows (varname) != 1))
     error ("validatestring: varname must be exactly one row");
   elseif (position < 0)
     error ("validatestring: position must be >= 0");
   endif
 
-  ## make the part of the error that will use funname, varname, and
+  ## make the part of the error that will use funcname, varname, and
   ## position
   errstr = "";
-  if (! isempty (funname))
-    errstr = sprintf ("Function: %s ", funname);
+  if (! isempty (funcname))
+    errstr = sprintf ("Function: %s ", funcname);
   endif
   if (! isempty (varname))
     errstr = sprintf ("%sVariable: %s ", errstr, varname);
   endif
   if (position > 0)
     errstr = sprintf ("%sArgument position %d ", errstr, position);
   endif
   if (! isempty (errstr))
diff --git a/scripts/time/ctime.m b/scripts/time/ctime.m
--- a/scripts/time/ctime.m
+++ b/scripts/time/ctime.m
@@ -14,17 +14,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} ctime (@var{t})
-## Convert a value returned from @code{time} (or any other nonnegative
+## Convert a value returned from @code{time} (or any other non-negative
 ## integer), to the local time and return a string of the same form as
 ## @code{asctime}.  The function @code{ctime (time)} is equivalent to
 ## @code{asctime (localtime (time))}.  For example,
 ##
 ## @example
 ## @group
 ## ctime (time ())
 ##      @result{} "Mon Feb 17 01:15:06 1997\n"
diff --git a/src/DLD-FUNCTIONS/balance.cc b/src/DLD-FUNCTIONS/balance.cc
--- a/src/DLD-FUNCTIONS/balance.cc
+++ b/src/DLD-FUNCTIONS/balance.cc
@@ -77,17 +77,17 @@ The eigenvalue balancing option @code{op
 @table @asis\n\
 @item @code{\"noperm\"}, @code{\"S\"}\n\
 Scale only; do not permute.\n\
 \n\
 @item @code{\"noscal\"}, @code{\"P\"}\n\
 Permute only; do not scale.\n\
 @end table\n\
 \n\
-Algebraic eigenvalue balancing uses standard @sc{Lapack} routines.\n\
+Algebraic eigenvalue balancing uses standard @sc{lapack} routines.\n\
 \n\
 Generalized eigenvalue problem balancing uses Ward's algorithm\n\
 (SIAM Journal on Scientific and Statistical Computing, 1981).\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
diff --git a/src/DLD-FUNCTIONS/cellfun.cc b/src/DLD-FUNCTIONS/cellfun.cc
--- a/src/DLD-FUNCTIONS/cellfun.cc
+++ b/src/DLD-FUNCTIONS/cellfun.cc
@@ -1007,17 +1007,16 @@ to the dimensions of @var{a}, then it is
 == size (@var{a}, i)}.\n\
 \n\
 Given a single dimensional argument @var{r}, the other dimensional\n\
 arguments are assumed to equal @code{size (@var{a},@var{i})}.\n\
 \n\
 An example of the use of mat2cell is\n\
 \n\
 @example\n\
-@group\n\
 mat2cell (reshape(1:16,4,4),[3,1],[3,1])\n\
 @result{} @{\n\
   [1,1] =\n\
 \n\
      1   5   9\n\
      2   6  10\n\
      3   7  11\n\
 \n\
@@ -1028,17 +1027,16 @@ mat2cell (reshape(1:16,4,4),[3,1],[3,1])
   [1,2] =\n\
 \n\
     13\n\
     14\n\
     15\n\
 \n\
   [2,2] = 16\n\
 @}\n\
-@end group\n\
 @end example\n\
 @seealso{num2cell, cell2mat}\n\
 @end deftypefn")
 {
   int nargin = args.length();
   octave_value retval;
 
   if (nargin < 2)
diff --git a/src/DLD-FUNCTIONS/det.cc b/src/DLD-FUNCTIONS/det.cc
--- a/src/DLD-FUNCTIONS/det.cc
+++ b/src/DLD-FUNCTIONS/det.cc
@@ -46,17 +46,17 @@ along with Octave; see the file COPYING.
 
 #define MAYBE_CAST(VAR, CLASS) \
   const CLASS *VAR = arg.type_id () == CLASS::static_type_id () ? \
    dynamic_cast<const CLASS *> (&arg.get_rep ()) : 0
 
 DEFUN_DLD (det, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{d}, @var{rcond}] =} det (@var{a})\n\
-Compute the determinant of @var{a} using @sc{Lapack} for full and UMFPACK\n\
+Compute the determinant of @var{a} using @sc{lapack} for full and UMFPACK\n\
 for sparse matrices.  Return an estimate of the reciprocal condition number\n\
 if requested.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
diff --git a/src/DLD-FUNCTIONS/kron.cc b/src/DLD-FUNCTIONS/kron.cc
--- a/src/DLD-FUNCTIONS/kron.cc
+++ b/src/DLD-FUNCTIONS/kron.cc
@@ -122,17 +122,17 @@ kron (const Sparse<T>& A, const Sparse<T
 
 template void
 kron (const Sparse<double>&, const Sparse<double>&, Sparse<double>&);
 
 template void
 kron (const Sparse<Complex>&, const Sparse<Complex>&, Sparse<Complex>&);
 
 
-DEFUN_DLD (kron, args,  nargout, "-*- texinfo -*-\n\
+DEFUN_DLD (kron, args, nargout, "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} kron (@var{a}, @var{b})\n\
 Form the kronecker product of two matrices, defined block by block as\n\
 \n\
 @example\n\
 x = [a(i, j) b]\n\
 @end example\n\
 \n\
 For example,\n\
diff --git a/src/DLD-FUNCTIONS/lu.cc b/src/DLD-FUNCTIONS/lu.cc
--- a/src/DLD-FUNCTIONS/lu.cc
+++ b/src/DLD-FUNCTIONS/lu.cc
@@ -68,17 +68,17 @@ DEFUN_DLD (lu, args, nargout,
 @deftypefn {Loadable Function} {[@var{l}, @var{u}, @var{p}] =} lu (@var{a})\n\
 @deftypefnx {Loadable Function} {[@var{l}, @var{u}, @var{p}, @var{q}] =} lu (@var{s})\n\
 @deftypefnx {Loadable Function} {[@var{l}, @var{u}, @var{p}, @var{q}, @var{r}] =} lu (@var{s})\n\
 @deftypefnx {Loadable Function} {[@dots{}] =} lu (@var{s}, @var{thres})\n\
 @deftypefnx {Loadable Function} {@var{y} =} lu (@dots{})\n\
 @deftypefnx {Loadable Function} {[@dots{}] =} lu (@dots{}, 'vector')\n\
 @cindex LU decomposition\n\
 Compute the LU decomposition of @var{a}.  If @var{a} is full subroutines from\n\
-@sc{Lapack} are used and if @var{a} is sparse then UMFPACK is used.  The\n\
+@sc{lapack} are used and if @var{a} is sparse then UMFPACK is used.  The\n\
 result is returned in a permuted form, according to the optional return\n\
 value @var{p}.  For example, given the matrix @code{a = [1, 2; 3, 4]},\n\
 \n\
 @example\n\
 [l, u, p] = lu (a)\n\
 @end example\n\
 \n\
 @noindent\n\
@@ -126,17 +126,17 @@ defined by @code{spparms} are used and a
 \n\
 Given the string argument 'vector', @dfn{lu} returns the values of @var{p}\n\
 @var{q} as vector values, such that for full matrix, @code{@var{a}\n\
 (@var{p},:) = @var{l} * @var{u}}, and @code{@var{r}(@var{p},:) * @var{a}\n\
 (:, @var{q}) = @var{l} * @var{u}}.\n\
 \n\
 With two output arguments, returns the permuted forms of the upper and\n\
 lower triangular matrices, such that @code{@var{a} = @var{l} * @var{u}}.\n\
-With one output argument @var{y}, then the matrix returned by the @sc{Lapack}\n\
+With one output argument @var{y}, then the matrix returned by the @sc{lapack}\n\
 routines is returned.  If the input matrix is sparse then the matrix @var{l}\n\
 is embedded into @var{u} to give a return value similar to the full case.\n\
 For both full and sparse matrices, @dfn{lu} looses the permutation\n\
 information.\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
diff --git a/src/DLD-FUNCTIONS/qr.cc b/src/DLD-FUNCTIONS/qr.cc
--- a/src/DLD-FUNCTIONS/qr.cc
+++ b/src/DLD-FUNCTIONS/qr.cc
@@ -84,17 +84,17 @@ maybe_set_triangular (const MT& m, Matri
 // qr (X) alone returns the output of the LAPACK routine dgeqrf, such
 // that R = triu (qr (X))
 
 DEFUN_DLD (qr, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{q}, @var{r}, @var{p}] =} qr (@var{a})\n\
 @deftypefnx {Loadable Function} {[@var{q}, @var{r}, @var{p}] =} qr (@var{a}, '0')\n\
 @cindex QR factorization\n\
-Compute the QR factorization of @var{a}, using standard @sc{Lapack}\n\
+Compute the QR factorization of @var{a}, using standard @sc{lapack}\n\
 subroutines.  For example, given the matrix @code{a = [1, 2; 3, 4]},\n\
 \n\
 @example\n\
 [q, r] = qr (a)\n\
 @end example\n\
 \n\
 @noindent\n\
 returns\n\
diff --git a/src/DLD-FUNCTIONS/qz.cc b/src/DLD-FUNCTIONS/qz.cc
--- a/src/DLD-FUNCTIONS/qz.cc
+++ b/src/DLD-FUNCTIONS/qz.cc
@@ -266,17 +266,17 @@ of the revised pencil contains all eigen
 @item \"B\"\n\
 = big: leading block has all |lambda| >= 1 \n\
 \n\
 @item \"-\"\n\
 = negative real part: leading block has all eigenvalues\n\
 in the open left half-plane\n\
 \n\
 @item \"+\"\n\
-= nonnegative real part: leading block has all eigenvalues\n\
+= non-negative real part: leading block has all eigenvalues\n\
 in the closed right half-plane\n\
 @end table\n\
 @end table\n\
 @end enumerate\n\
 \n\
 Note: qz performs permutation balancing, but not scaling (see balance).\n\
 Order of output arguments was selected for compatibility with @sc{matlab}\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/rcond.cc b/src/DLD-FUNCTIONS/rcond.cc
--- a/src/DLD-FUNCTIONS/rcond.cc
+++ b/src/DLD-FUNCTIONS/rcond.cc
@@ -29,17 +29,17 @@ along with Octave; see the file COPYING.
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN_DLD (rcond, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{c} =} rcond (@var{a})\n\
 Compute the 1-norm estimate of the reciprocal condition as returned\n\
-by LAPACK.  If the matrix is well-conditioned then @var{c} will be near\n\
+by @sc{lapack}.  If the matrix is well-conditioned then @var{c} will be near\n\
 1 and if the matrix is poorly conditioned it will be close to zero.\n\
 \n\
 The matrix @var{a} must not be sparse.  If the matrix is sparse then\n\
 @code{condest (@var{a})} or @code{rcond (full (@var{a}))} should be used\n\
 instead.\n\
 @seealso{inv}\n\
 @end deftypefn")
 {
diff --git a/src/DLD-FUNCTIONS/spparms.cc b/src/DLD-FUNCTIONS/spparms.cc
--- a/src/DLD-FUNCTIONS/spparms.cc
+++ b/src/DLD-FUNCTIONS/spparms.cc
@@ -71,17 +71,17 @@ use the sparsity preserving mmd function
 Flag whether the LU and the '\\' and '/' operators will automatically\n\
 use the sparsity preserving amd functions (default 1)\n\
 @item piv_tol\n\
 The pivot tolerance of the UMFPACK solvers (default 0.1)\n\
 @item sym_tol\n\
 The pivot tolerance of the UMFPACK symmetric solvers (default 0.001)\n\
 @item bandden\n\
 The density of non-zero elements in a banded matrix before it is treated\n\
-by the LAPACK banded solvers (default 0.5)\n\
+by the @sc{lapack} banded solvers (default 0.5)\n\
 @item umfpack\n\
 Flag whether the UMFPACK or mmd solvers are used for the LU, '\\' and\n\
 '/' operations (default 1)\n\
 @end table\n\
 \n\
 The value of individual keys can be set with @code{spparms (@var{key},\n\
 @var{val})}.  The default values can be restored with the special keyword\n\
 'defaults'.  The special keyword 'tight' can be used to set the mmd solvers\n\
diff --git a/src/DLD-FUNCTIONS/syl.cc b/src/DLD-FUNCTIONS/syl.cc
--- a/src/DLD-FUNCTIONS/syl.cc
+++ b/src/DLD-FUNCTIONS/syl.cc
@@ -45,17 +45,17 @@ Solve the Sylvester equation\n\
 @end tex\n\
 @end iftex\n\
 @ifnottex\n\
 \n\
 @example\n\
 A X + X B + C = 0\n\
 @end example\n\
 @end ifnottex\n\
-using standard @sc{Lapack} subroutines.  For example,\n\
+using standard @sc{lapack} subroutines.  For example,\n\
 \n\
 @example\n\
 @group\n\
 syl ([1, 2; 3, 4], [5, 6; 7, 8], [9, 10; 11, 12])\n\
      @result{} [ -0.50000, -0.66667; -0.66667, -0.50000 ]\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
diff --git a/src/DLD-FUNCTIONS/time.cc b/src/DLD-FUNCTIONS/time.cc
--- a/src/DLD-FUNCTIONS/time.cc
+++ b/src/DLD-FUNCTIONS/time.cc
@@ -100,17 +100,17 @@ value returned by @code{time} was 856163
 
 %!assert(time () > 0);
 
 */
 
 DEFUN_DLD (gmtime, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} gmtime (@var{t})\n\
-Given a value returned from time (or any nonnegative integer),\n\
+Given a value returned from time (or any non-negative integer),\n\
 return a time structure corresponding to CUT.  For example,\n\
 \n\
 @example\n\
 @group\n\
 gmtime (time ())\n\
      @result{} @{\n\
            usec = 0\n\
            year = 97\n\
@@ -164,17 +164,17 @@ gmtime (time ())\n\
 
 %!error <Invalid call to gmtime.*> gmtime (1, 2);
 
 */
 
 DEFUN_DLD (localtime, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} localtime (@var{t})\n\
-Given a value returned from time (or any nonnegative integer),\n\
+Given a value returned from time (or any non-negative integer),\n\
 return a time structure corresponding to the local time zone.\n\
 \n\
 @example\n\
 @group\n\
 localtime (time ())\n\
      @result{} @{\n\
            usec = 0\n\
            year = 97\n\
diff --git a/src/bitfcns.cc b/src/bitfcns.cc
--- a/src/bitfcns.cc
+++ b/src/bitfcns.cc
@@ -259,39 +259,39 @@ along with Octave; see the file COPYING.
   else \
     print_usage (); \
  \
   return retval
 
 DEFUN (bitand, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} bitand (@var{x}, @var{y})\n\
-Return the bitwise AND of nonnegative integers.\n\
+Return the bitwise AND of non-negative integers.\n\
 @var{x}, @var{y} must be in the range [0,bitmax]\n\
 @seealso{bitor, bitxor, bitset, bitget, bitcmp, bitshift, bitmax}\n\
 @end deftypefn")
 {
   BITOP (&, "bitand");
 }
 
 DEFUN (bitor, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} bitor (@var{x}, @var{y})\n\
-Return the bitwise OR of nonnegative integers.\n\
+Return the bitwise OR of non-negative integers.\n\
 @var{x}, @var{y} must be in the range [0,bitmax]\n\
 @seealso{bitor, bitxor, bitset, bitget, bitcmp, bitshift, bitmax}\n\
 @end deftypefn")
 {
   BITOP (|, "bitor");
 }
 
 DEFUN (bitxor, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} bitxor (@var{x}, @var{y})\n\
-Return the bitwise XOR of nonnegative integers.\n\
+Return the bitwise XOR of non-negative integers.\n\
 @var{x}, @var{y} must be in the range [0,bitmax]\n\
 @seealso{bitand, bitor, bitset, bitget, bitcmp, bitshift, bitmax}\n\
 @end deftypefn")
 {
   BITOP (^, "bitxor");
 }
 
 static int64_t
diff --git a/src/defaults.cc b/src/defaults.cc
--- a/src/defaults.cc
+++ b/src/defaults.cc
@@ -415,22 +415,22 @@ environment variable is not initialized,
 
 DEFUN (EXEC_PATH, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{val} =} EXEC_PATH ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} EXEC_PATH (@var{new_val})\n\
 Query or set the internal variable that specifies a colon separated\n\
 list of directories to search when executing external programs.\n\
 Its initial value is taken from the environment variable\n\
-@code{OCTAVE_EXEC_PATH} (if it exists) or @code{PATH}, but that\n\
+@w{@code{OCTAVE_EXEC_PATH}} (if it exists) or @code{PATH}, but that\n\
 value can be overridden by the command line argument\n\
 @code{--exec-path PATH}.  At startup, an additional set of\n\
 directories (including the shell PATH) is appended to the path\n\
 specified in the environment or on the command line.  If you use\n\
-the @code{EXEC_PATH} function to modify the path, you should take\n\
+the @w{@code{EXEC_PATH}} function to modify the path, you should take\n\
 care to preserve these additional directories.\n\
 @end deftypefn")
 {
   std::string saved_exec_path = VEXEC_PATH;
 
   octave_value retval = SET_NONEMPTY_INTERNAL_STRING_VARIABLE (EXEC_PATH);
 
   if (VEXEC_PATH != saved_exec_path)
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -747,21 +747,21 @@ 0 for success, and -1 if an error was en
 }
 
 DEFUN (fseek, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fseek (@var{fid}, @var{offset}, @var{origin})\n\
 Set the file pointer to any location within the file @var{fid}.\n\
 \n\
 The pointer is positioned @var{offset} characters from the @var{origin},\n\
-which may be one of the predefined variables @code{SEEK_CUR} (current\n\
-position), @code{SEEK_SET} (beginning), or @code{SEEK_END} (end of\n\
+which may be one of the predefined variables @w{@code{SEEK_CUR}} (current\n\
+position), @w{@code{SEEK_SET}} (beginning), or @w{@code{SEEK_END}} (end of\n\
 file) or strings \"cof\", \"bof\" or \"eof\".  If @var{origin} is omitted,\n\
-@code{SEEK_SET} is assumed.  The offset must be zero, or a value returned\n\
-by @code{ftell} (in which case @var{origin} must be @code{SEEK_SET}).\n\
+@w{@code{SEEK_SET}} is assumed.  The offset must be zero, or a value returned\n\
+by @code{ftell} (in which case @var{origin} must be @w{@code{SEEK_SET}}).\n\
 \n\
 Return 0 on success and -1 on error.\n\
 @seealso{ftell, fopen, fclose}\n\
 @end deftypefn")
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
@@ -1916,17 +1916,17 @@ DEFUN (mkstemp, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{fid}, @var{name}, @var{msg}] =} mkstemp (@var{template}, @var{delete})\n\
 Return the file ID corresponding to a new temporary file with a unique\n\
 name created from @var{template}.  The last six characters of @var{template}\n\
 must be @code{XXXXXX} and these are replaced with a string that makes the\n\
 filename unique.  The file is then created with mode read/write and\n\
 permissions that are system dependent (on GNU/Linux systems, the permissions\n\
 will be 0600 for versions of glibc 2.0.7 and later).  The file is opened\n\
-with the @code{O_EXCL} flag.\n\
+with the @w{@code{O_EXCL}} flag.\n\
 \n\
 If the optional argument @var{delete} is supplied and is true,\n\
 the file will be deleted automatically when Octave exits, or when\n\
 the function @code{purge_tmp_files} is called.\n\
 \n\
 If successful, @var{fid} is a valid file ID, @var{name} is the name of\n\
 the file, and @var{msg} is an empty string.  Otherwise, @var{fid}\n\
 is -1, @var{name} is empty, and @var{msg} contains a system-dependent\n\
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -1638,17 +1638,17 @@ toascii (\"ASCII\")\n\
   return retval;
 }
 
 DEFUNX ("tolower", Ftolower, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} tolower (@var{s})\n\
 @deftypefnx {Mapping Function} {} lower (@var{s})\n\
 Return a copy of the string or cell string @var{s}, with each upper-case\n\
-character replaced by the corresponding lower-case one; nonalphabetic\n\
+character replaced by the corresponding lower-case one; non-alphabetic\n\
 characters are left unchanged.  For example,\n\
 \n\
 @example\n\
 @group\n\
 tolower (\"MiXeD cAsE 123\")\n\
      @result{} \"mixed case 123\"\n\
 @end group\n\
 @end example\n\
@@ -1684,17 +1684,17 @@ DEFALIAS (lower, tolower);
 */
 
 
 DEFUNX ("toupper", Ftoupper, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} toupper (@var{s})\n\
 @deftypefnx {Built-in Function} {} upper (@var{s})\n\
 Return a copy of the string or cell string @var{s}, with each lower-case\n\
-character replaced by the corresponding upper-case one; nonalphabetic\n\
+character replaced by the corresponding upper-case one; non-alphabetic\n\
 characters are left unchanged.  For example,\n\
 \n\
 @example\n\
 @group\n\
 toupper (\"MiXeD cAsE 123\")\n\
      @result{} \"MIXED CASE 123\"\n\
 @end group\n\
 @end example\n\
diff --git a/src/syscalls.cc b/src/syscalls.cc
--- a/src/syscalls.cc
+++ b/src/syscalls.cc
@@ -230,17 +230,16 @@ containing options for the command.  The
 and output streams of the subprocess are returned in @var{in} and\n\
 @var{out}.  If execution of the command is successful, @var{pid}\n\
 contains the process ID of the subprocess.  Otherwise, @var{pid} is\n\
 @minus{}1.\n\
 \n\
 For example,\n\
 \n\
 @example\n\
-@group\n\
 [in, out, pid] = popen2 (\"sort\", \"-r\");\n\
 fputs (in, \"these\\nare\\nsome\\nstrings\\n\");\n\
 fclose (in);\n\
 EAGAIN = errno (\"EAGAIN\");\n\
 done = false;\n\
 do\n\
   s = fgets (out);\n\
   if (ischar (s))\n\
@@ -252,17 +251,16 @@ do\n\
     done = true;\n\
   endif\n\
 until (done)\n\
 fclose (out);\n\
      @print{} are\n\
      @print{} some\n\
      @print{} strings\n\
      @print{} these\n\
-@end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(2) = -1;
   retval(1) = Matrix ();
   retval(0) = Matrix ();
@@ -434,18 +432,18 @@ Nonblocking mode.\n\
 Wait for writes to complete.\n\
 \n\
 @item O_ASYNC\n\
 Asynchronous I/O.\n\
 @end vtable\n\
 \n\
 @item F_SETFL\n\
 Set the file status flags for @var{fid} to the value specified by\n\
-@var{arg}.  The only flags that can be changed are @code{O_APPEND} and\n\
-@code{O_NONBLOCK}.\n\
+@var{arg}.  The only flags that can be changed are @w{@code{O_APPEND}} and\n\
+@w{@code{O_NONBLOCK}}.\n\
 @end vtable\n\
 \n\
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a\n\
 system-dependent error message.\n\
 @end deftypefn")
 {
   octave_value_list retval;
@@ -915,19 +913,19 @@ Return a structure @var{s} containing th
 @table @code\n\
 @item dev\n\
 ID of device containing a directory entry for this file.\n\
 \n\
 @item ino\n\
 File number of the file.\n\
 \n\
 @item mode\n\
-File mode, as an integer.  Use the functions @code{S_ISREG},\n\
-@code{S_ISDIR}, @code{S_ISCHR}, @code{S_ISBLK}, @code{S_ISFIFO},\n\
-@code{S_ISLNK}, or @code{S_ISSOCK} to extract information from this\n\
+File mode, as an integer.  Use the functions @w{@code{S_ISREG}},\n\
+@w{@code{S_ISDIR}}, @w{@code{S_ISCHR}}, @w{@code{S_ISBLK}}, @w{@code{S_ISFIFO}},\n\
+@w{@code{S_ISLNK}}, or @w{@code{S_ISSOCK}} to extract information from this\n\
 value.\n\
 \n\
 @item modestr\n\
 File mode, as a string of ten letters or dashes as would be returned by\n\
 @kbd{ls -l}.\n\
 \n\
 @item nlink\n\
 Number of links.\n\
@@ -970,17 +968,16 @@ corresponding system error message.\n\
 \n\
 If @var{file} is a symbolic link, @code{stat} will return information\n\
 about the actual file that is referenced by the link.  Use @code{lstat}\n\
 if you want information about the symbolic link itself.\n\
 \n\
 For example,\n\
 \n\
 @example\n\
-@group\n\
 [s, err, msg] = stat (\"/vmlinuz\")\n\
       @result{} s =\n\
         @{\n\
           atime = 855399756\n\
           rdev = 0\n\
           ctime = 847219094\n\
           uid = 0\n\
           size = 389218\n\
@@ -991,17 +988,16 @@ For example,\n\
           blocks = 768\n\
           mode = -rw-r--r--\n\
           modestr = -rw-r--r--\n\
           ino = 9316\n\
           dev = 2049\n\
         @}\n\
      @result{} err = 0\n\
      @result{} msg = \n\
-@end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       std::string fname = args(0).string_value ();
