# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1480767130 18000
#      Sat Dec 03 07:12:10 2016 -0500
# Node ID 0b1e25cc4457faf668922f1e3e07e2d041d5ec08
# Parent  adc66f043cfc0cba2d7efe1aebab165caf600293
eliminate use of OCTAVE_QUIT macro in C++ sources

* __dsearchn__.cc, __magick_read__.cc, filter.cc, find.cc,
graphics.cc, quadcc.cc, qz.cc, tsearch.cc audiodevinfo.cc, symrcm.cc,
op-int.h, lo-regexp.cc: Use inline octave_quit function instead of
OCTAVE_QUIT macro.

diff --git a/libinterp/corefcn/__dsearchn__.cc b/libinterp/corefcn/__dsearchn__.cc
--- a/libinterp/corefcn/__dsearchn__.cc
+++ b/libinterp/corefcn/__dsearchn__.cc
@@ -79,17 +79,17 @@ Undocumented internal function.
           px += n;
           double d;
           DIST (d, px, pxi, n);
           if (d < d0)
             {
               d0 = d;
               *pidx = static_cast<double>(j + 1);
             }
-          OCTAVE_QUIT;
+          octave_quit ();
         }
 
       *pdist++ = d0;
       pidx++;
       pxi += n;
     }
 
   return ovl (idx, dist);
diff --git a/libinterp/corefcn/__magick_read__.cc b/libinterp/corefcn/__magick_read__.cc
--- a/libinterp/corefcn/__magick_read__.cc
+++ b/libinterp/corefcn/__magick_read__.cc
@@ -241,17 +241,18 @@ read_indexed_images (const std::vector<M
   const octave_idx_type col_cache = region["col_cache"];
 
   // When reading PixelPackets from the Image Pixel Cache, they come in
   // row major order.  So we keep moving back and forth there so we can
   // write the image in column major order.
   octave_idx_type idx = 0;
   for (octave_idx_type frame = 0; frame < nFrames; frame++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
+
       imvec[frameidx(frame)].getConstPixels (col_start, row_start,
                                              col_cache, row_cache);
 
       const Magick::IndexPacket *pix
         = imvec[frameidx(frame)].getConstIndexes ();
 
       for (octave_idx_type col = 0; col < nCols; col++)
         {
@@ -446,17 +447,18 @@ read_images (std::vector<Magick::Image>&
     case Magick::GrayscaleType:         // Grayscale image
       {
         img = T (dim_vector (nRows, nCols, 1, nFrames));
         P *img_fvec = img.fortran_vec ();
 
         octave_idx_type idx = 0;
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
-            OCTAVE_QUIT;
+            octave_quit ();
+
             const Magick::PixelPacket *pix
               = imvec[frameidx(frame)].getConstPixels (col_start, row_start,
                                                        col_cache, row_cache);
 
             for (octave_idx_type col = 0; col < nCols; col++)
               {
                 for (octave_idx_type row = 0; row < nRows; row++)
                   {
@@ -474,17 +476,18 @@ read_images (std::vector<Magick::Image>&
         img = T (dim_vector (nRows, nCols, 1, nFrames));
         T alpha (dim_vector (nRows, nCols, 1, nFrames));
         P *img_fvec = img.fortran_vec ();
         P *a_fvec   = alpha.fortran_vec ();
 
         octave_idx_type idx = 0;
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
-            OCTAVE_QUIT;
+            octave_quit ();
+
             const Magick::PixelPacket *pix
               = imvec[frameidx(frame)].getConstPixels (col_start, row_start,
                                                        col_cache, row_cache);
 
             for (octave_idx_type col = 0; col < nCols; col++)
               {
                 for (octave_idx_type row = 0; row < nRows; row++)
                   {
@@ -504,17 +507,18 @@ read_images (std::vector<Magick::Image>&
     case Magick::TrueColorType:         // Truecolor image
       {
         img = T (dim_vector (nRows, nCols, 3, nFrames));
         P *img_fvec = img.fortran_vec ();
 
         const octave_idx_type frame_stride = color_stride * 3;
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
-            OCTAVE_QUIT;
+            octave_quit ();
+
             const Magick::PixelPacket *pix
               = imvec[frameidx(frame)].getConstPixels (col_start, row_start,
                                                        col_cache, row_cache);
 
             octave_idx_type idx = 0;
             P *rbuf = img_fvec;
             P *gbuf = img_fvec + color_stride;
             P *bbuf = img_fvec + color_stride * 2;
@@ -546,17 +550,18 @@ read_images (std::vector<Magick::Image>&
 
         const octave_idx_type frame_stride = color_stride * 3;
 
         // Unlike the index for the other channels, this one won't need
         // to be reset on each frame since it's a separate matrix.
         octave_idx_type a_idx = 0;
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
-            OCTAVE_QUIT;
+            octave_quit ();
+
             const Magick::PixelPacket *pix
               = imvec[frameidx(frame)].getConstPixels (col_start, row_start,
                                                        col_cache, row_cache);
 
             octave_idx_type idx = 0;
             P *rbuf = img_fvec;
             P *gbuf = img_fvec + color_stride;
             P *bbuf = img_fvec + color_stride * 2;
@@ -583,17 +588,18 @@ read_images (std::vector<Magick::Image>&
     case Magick::ColorSeparationType:  // Cyan/Magenta/Yellow/Black (CMYK) image
       {
         img = T (dim_vector (nRows, nCols, 4, nFrames));
         P *img_fvec = img.fortran_vec ();
 
         const octave_idx_type frame_stride = color_stride * 4;
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
-            OCTAVE_QUIT;
+            octave_quit ();
+
             const Magick::PixelPacket *pix
               = imvec[frameidx(frame)].getConstPixels (col_start, row_start,
                                                        col_cache, row_cache);
 
             octave_idx_type idx = 0;
             P *cbuf = img_fvec;
             P *mbuf = img_fvec + color_stride;
             P *ybuf = img_fvec + color_stride * 2;
@@ -627,17 +633,18 @@ read_images (std::vector<Magick::Image>&
 
         const octave_idx_type frame_stride = color_stride * 4;
 
         // Unlike the index for the other channels, this one won't need
         // to be reset on each frame since it's a separate matrix.
         octave_idx_type a_idx = 0;
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
-            OCTAVE_QUIT;
+            octave_quit ();
+
             const Magick::PixelPacket *pix
               = imvec[frameidx(frame)].getConstPixels (col_start, row_start,
                                                        col_cache, row_cache);
             // Note that for CMYKColorspace + matte (CMYKA), the opacity is
             // stored in the assocated IndexPacket.
             const Magick::IndexPacket *apix
               = imvec[frameidx(frame)].getConstIndexes ();
 
@@ -952,17 +959,18 @@ encode_indexed_images (std::vector<Magic
     for (octave_idx_type map_idx = 0; map_idx < cmap_size; map_idx++)
       colormap.push_back (Magick::ColorRGB (cmap_fvec[map_idx],
                                             cmap_fvec[map_idx + G_offset],
                                             cmap_fvec[map_idx + B_offset]));
   }
 
   for (octave_idx_type frame = 0; frame < nFrames; frame++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
+
       Magick::Image m_img = init_enconde_image (nCols, nRows, bitdepth,
                                                 Magick::PaletteType,
                                                 Magick::PseudoClass);
 
       // Insert colormap.
       m_img.colorMapSize (cmap_size);
       for (octave_idx_type map_idx = 0; map_idx < cmap_size; map_idx++)
         m_img.colorMap (map_idx, colormap[map_idx]);
@@ -1008,17 +1016,18 @@ encode_bool_image (std::vector<Magick::I
 
   // The initialized image will be black, this is for the other pixels
   const Magick::Color white ("white");
 
   const bool *img_fvec = img.fortran_vec ();
   octave_idx_type img_idx = 0;
   for (octave_idx_type frame = 0; frame < nFrames; frame++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
+
       // For some reason, we can't set the type to Magick::BilevelType or
       // the output image will be black, changing to white has no effect.
       // However, this will still work fine and a binary image will be
       // saved because we are setting the bitdepth to 1.
       Magick::Image m_img = init_enconde_image (nCols, nRows, 1,
                                                 Magick::GrayscaleType,
                                                 Magick::DirectClass);
 
@@ -1100,17 +1109,18 @@ encode_uint_image (std::vector<Magick::I
   const P *img_fvec = img.fortran_vec ();
   const P *a_fvec   = alpha.fortran_vec ();
   switch (type)
     {
     case Magick::GrayscaleType:
       {
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
-            OCTAVE_QUIT;
+            octave_quit ();
+
             Magick::Image m_img = init_enconde_image (nCols, nRows, bitdepth,
                                                       type,
                                                       Magick::DirectClass);
 
             Magick::PixelPacket *pix = m_img.getPixels (0, 0, nCols, nRows);
             octave_idx_type GM_idx = 0;
             for (octave_idx_type col = 0; col < nCols; col++)
               {
@@ -1130,17 +1140,18 @@ encode_uint_image (std::vector<Magick::I
           }
         break;
       }
 
     case Magick::GrayscaleMatteType:
       {
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
-            OCTAVE_QUIT;
+            octave_quit ();
+
             Magick::Image m_img = init_enconde_image (nCols, nRows, bitdepth,
                                                       type,
                                                       Magick::DirectClass);
 
             Magick::PixelPacket *pix = m_img.getPixels (0, 0, nCols, nRows);
             octave_idx_type GM_idx = 0;
             for (octave_idx_type col = 0; col < nCols; col++)
               {
@@ -1165,17 +1176,18 @@ encode_uint_image (std::vector<Magick::I
 
     case Magick::TrueColorType:
       {
         // The fortran_vec offset for the green and blue channels
         const octave_idx_type G_offset = nCols * nRows;
         const octave_idx_type B_offset = nCols * nRows * 2;
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
-            OCTAVE_QUIT;
+            octave_quit ();
+
             Magick::Image m_img = init_enconde_image (nCols, nRows, bitdepth,
                                                       type,
                                                       Magick::DirectClass);
 
             Magick::PixelPacket *pix = m_img.getPixels (0, 0, nCols, nRows);
             octave_idx_type GM_idx = 0;
             for (octave_idx_type col = 0; col < nCols; col++)
               {
@@ -1200,17 +1212,18 @@ encode_uint_image (std::vector<Magick::I
 
     case Magick::TrueColorMatteType:
       {
         // The fortran_vec offset for the green and blue channels
         const octave_idx_type G_offset = nCols * nRows;
         const octave_idx_type B_offset = nCols * nRows * 2;
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
-            OCTAVE_QUIT;
+            octave_quit ();
+
             Magick::Image m_img = init_enconde_image (nCols, nRows, bitdepth,
                                                       type,
                                                       Magick::DirectClass);
 
             Magick::PixelPacket *pix = m_img.getPixels (0, 0, nCols, nRows);
             octave_idx_type GM_idx = 0;
             for (octave_idx_type col = 0; col < nCols; col++)
               {
@@ -1238,17 +1251,18 @@ encode_uint_image (std::vector<Magick::I
     case Magick::ColorSeparationType:
       {
         // The fortran_vec offset for the Magenta, Yellow, and blacK channels
         const octave_idx_type M_offset = nCols * nRows;
         const octave_idx_type Y_offset = nCols * nRows * 2;
         const octave_idx_type K_offset = nCols * nRows * 3;
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
-            OCTAVE_QUIT;
+            octave_quit ();
+
             Magick::Image m_img = init_enconde_image (nCols, nRows, bitdepth,
                                                       type,
                                                       Magick::DirectClass);
 
             Magick::PixelPacket *pix = m_img.getPixels (0, 0, nCols, nRows);
             octave_idx_type GM_idx = 0;
             for (octave_idx_type col = 0; col < nCols; col++)
               {
@@ -1275,17 +1289,18 @@ encode_uint_image (std::vector<Magick::I
     case Magick::ColorSeparationMatteType:
       {
         // The fortran_vec offset for the Magenta, Yellow, and blacK channels
         const octave_idx_type M_offset = nCols * nRows;
         const octave_idx_type Y_offset = nCols * nRows * 2;
         const octave_idx_type K_offset = nCols * nRows * 3;
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
-            OCTAVE_QUIT;
+            octave_quit ();
+
             Magick::Image m_img = init_enconde_image (nCols, nRows, bitdepth,
                                                       type,
                                                       Magick::DirectClass);
 
             Magick::PixelPacket *pix = m_img.getPixels (0, 0, nCols, nRows);
             Magick::IndexPacket *ind = m_img.getIndexes ();
             octave_idx_type GM_idx = 0;
             for (octave_idx_type col = 0; col < nCols; col++)
@@ -1917,17 +1932,18 @@ Use @code{imfinfo} instead.
   const octave::sys::localtime mtime (fs.mtime ());
   const std::string filetime = mtime.strftime ("%e-%b-%Y %H:%M:%S");
   template_info.setfield ("Filename",    octave_value (filename));
   template_info.setfield ("FileModDate", octave_value (filetime));
   template_info.setfield ("FileSize",    octave_value (fs.size ()));
 
   for (octave_idx_type frame = 0; frame < nFrames; frame++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
+
       octave_scalar_map info_frame (template_info);
       const Magick::Image img = imvec[frame];
 
       info_frame.setfield ("Width",  octave_value (img.columns ()));
       info_frame.setfield ("Height", octave_value (img.rows ()));
       info_frame.setfield ("BitDepth",
                            octave_value (get_depth (const_cast<Magick::Image&> (img))));
 
diff --git a/libinterp/corefcn/filter.cc b/libinterp/corefcn/filter.cc
--- a/libinterp/corefcn/filter.cc
+++ b/libinterp/corefcn/filter.cc
@@ -142,26 +142,26 @@ filter (MArray<T>& b, MArray<T>& a, MArr
                i++, idx += x_stride)
             {
               py[idx] = psi[0] + pb[0] * px[idx];
 
               if (si_len > 0)
                 {
                   for (octave_idx_type j = 0; j < si_len - 1; j++)
                     {
-                      OCTAVE_QUIT;
+                      octave_quit ();
 
                       psi[j] = psi[j+1] - pa[j+1] * py[idx] + pb[j+1] * px[idx];
                     }
 
                   psi[si_len-1] = pb[si_len] * px[idx] - pa[si_len] * py[idx];
                 }
               else
                 {
-                  OCTAVE_QUIT;
+                  octave_quit ();
 
                   psi[0] = pb[si_len] * px[idx] - pa[si_len] * py[idx];
                 }
             }
         }
       else if (si_len > 0)
         {
           T *py = y.fortran_vec ();
@@ -177,26 +177,26 @@ filter (MArray<T>& b, MArray<T>& a, MArr
                i++, idx += x_stride)
             {
               py[idx] = psi[0] + pb[0] * px[idx];
 
               if (si_len > 1)
                 {
                   for (octave_idx_type j = 0; j < si_len - 1; j++)
                     {
-                      OCTAVE_QUIT;
+                      octave_quit ();
 
                       psi[j] = psi[j+1] + pb[j+1] * px[idx];
                     }
 
                   psi[si_len-1] = pb[si_len] * px[idx];
                 }
               else
                 {
-                  OCTAVE_QUIT;
+                  octave_quit ();
 
                   psi[0] = pb[1] * px[idx];
                 }
             }
         }
     }
 
   return y;
diff --git a/libinterp/corefcn/find.cc b/libinterp/corefcn/find.cc
--- a/libinterp/corefcn/find.cc
+++ b/libinterp/corefcn/find.cc
@@ -106,31 +106,33 @@ find_nonzero_elem_idx (const Sparse<T>& 
       end_nc = nc;
       n_to_find = nz;
       count = nz;
     }
   else if (direction > 0)
     {
       for (octave_idx_type j = 0; j < nc; j++)
         {
-          OCTAVE_QUIT;
+          octave_quit ();
+
           if (v.cidx (j) == 0 && v.cidx (j+1) != 0)
             start_nc = j;
           if (v.cidx (j+1) >= n_to_find)
             {
               end_nc = j + 1;
               break;
             }
         }
     }
   else
     {
       for (octave_idx_type j = nc; j > 0; j--)
         {
-          OCTAVE_QUIT;
+          octave_quit ();
+
           if (v.cidx (j) == nz && v.cidx (j-1) != nz)
             end_nc = j;
           if (nz - v.cidx (j-1) >= n_to_find)
             {
               start_nc = j - 1;
               break;
             }
         }
@@ -164,17 +166,18 @@ find_nonzero_elem_idx (const Sparse<T>& 
 
   if (count > 0)
     {
       // Search for elements to return.  Only search the region where there
       // are elements to be found using the count that we want to find.
       for (octave_idx_type j = start_nc, cx = 0; j < end_nc; j++)
         for (octave_idx_type i = v.cidx (j); i < v.cidx (j+1); i++)
           {
-            OCTAVE_QUIT;
+            octave_quit ();
+
             if (direction < 0 && i < nz - count)
               continue;
             i_idx(cx) = static_cast<double> (v.ridx (i) + 1);
             j_idx(cx) = static_cast<double> (j + 1);
             idx(cx) = j * nr + v.ridx (i) + 1;
             val(cx) = v.data(i);
             cx++;
             if (cx == count)
@@ -258,17 +261,18 @@ find_nonzero_elem_idx (const PermMatrix&
   // Every value is 1.
   Array<double> val (dim_vector (count, 1), 1.0);
 
   if (count > 0)
     {
       const Array<octave_idx_type>& p = v.col_perm_vec ();
       for (octave_idx_type k = 0; k < count; k++)
         {
-          OCTAVE_QUIT;
+          octave_quit ();
+
           const octave_idx_type j = start_nc + k;
           const octave_idx_type i = p(j);
           i_idx(k) = static_cast<double> (1+i);
           j_idx(k) = static_cast<double> (1+j);
           idx(k) = j * nc + i + 1;
         }
     }
   else
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -11850,17 +11850,17 @@ In all cases, typing CTRL-C stops progra
                 break;
             }
           else
             break;
         }
 
       octave_sleep (0.1); // FIXME: really needed?
 
-      OCTAVE_QUIT;
+      octave_quit ();
 
       octave::command_editor::run_event_hooks ();
 
       if (timeout > 0)
         {
           octave::sys::time now;
 
           if (start + timeout < now)
diff --git a/libinterp/corefcn/quadcc.cc b/libinterp/corefcn/quadcc.cc
--- a/libinterp/corefcn/quadcc.cc
+++ b/libinterp/corefcn/quadcc.cc
@@ -1748,17 +1748,17 @@ Mathematical Software, Vol. 37, Issue 3,
   err_final = 0.0;
 
   // Main loop.
   while (nivals > 0 && err > 0.0 && err > fabs (igral) * tol
          && !(err_final > fabs (igral) * tol
               && err - err_final < fabs (igral) * tol))
     {
       // Allow the user to interrupt.
-      OCTAVE_QUIT;
+      octave_quit ();
 
       // Put our finger on the interval with the largest error.
       iv = &(ivals[heap[0]]);
       m = (iv->a + iv->b) / 2;
       h = (iv->b - iv->a) / 2;
 
 #if (DEBUG_QUADCC)
       printf ("quadcc: processing ival %i (of %i) with [%e,%e] int=%e, err=%e, depth=%i\n",
diff --git a/libinterp/corefcn/qz.cc b/libinterp/corefcn/qz.cc
--- a/libinterp/corefcn/qz.cc
+++ b/libinterp/corefcn/qz.cc
@@ -349,17 +349,18 @@ compatibility with @sc{matlab}.
   char compq = (nargout >= 3 ? 'V' : 'N');
   char compz = ((nargout >= 4 || nargin == 3)? 'V' : 'N');
 
   // Initialize Q, Z to identity if we need either of them.
   if (compq == 'V' || compz == 'V')
     for (octave_idx_type ii = 0; ii < nn; ii++)
       for (octave_idx_type jj = 0; jj < nn; jj++)
         {
-          OCTAVE_QUIT;
+          octave_quit ();
+
           QQ(ii,jj) = ZZ(ii,jj) = (ii == jj ? 1.0 : 0.0);
         }
 
   // Always perform permutation balancing.
   const char bal_job = 'P';
   RowVector lscale (nn), rscale (nn), work (6 * nn), rwork (nn);
 
   if (complex_case)
@@ -919,17 +920,17 @@ compatibility with @sc{matlab}.
                      F77_CHAR_ARG_LEN (1)
                      F77_CHAR_ARG_LEN (1)));
 
           // Now construct the complex form of VV, WW.
           int jj = 0;
 
           while (jj < nn)
             {
-              OCTAVE_QUIT;
+              octave_quit ();
 
               // See if real or complex eigenvalue.
 
               // Column increment; assume complex eigenvalue.
               int cinc = 2;
 
               if (jj == (nn-1))
                 // Single column.
diff --git a/libinterp/corefcn/tsearch.cc b/libinterp/corefcn/tsearch.cc
--- a/libinterp/corefcn/tsearch.cc
+++ b/libinterp/corefcn/tsearch.cc
@@ -121,17 +121,18 @@ convex hull, @var{idx} is NaN.
               values(kp) = double(k+1);
               continue;
             }
         }
 
       // it doesn't, so go through all elements
       for (k = 0; k < nelem; k++)
         {
-          OCTAVE_QUIT;
+          octave_quit ();
+
           if (xt >= minx(k) && xt <= maxx(k) && yt >= miny(k) && yt <= maxy(k))
             {
               // element inside the minimum rectangle: examine it closely
               x0  = REF (x, k, 0);
               y0  = REF (y, k, 0);
               a11 = REF (x, k, 1) - x0;
               a12 = REF (y, k, 1) - y0;
               a21 = REF (x, k, 2) - x0;
diff --git a/libinterp/dldfcn/audiodevinfo.cc b/libinterp/dldfcn/audiodevinfo.cc
--- a/libinterp/dldfcn/audiodevinfo.cc
+++ b/libinterp/dldfcn/audiodevinfo.cc
@@ -1103,17 +1103,18 @@ audioplayer::playblocking (void)
   end = get_end_sample ();
 
   octave::unwind_protect frame;
 
   frame.add_fcn (safe_audioplayer_stop, this);
 
   for (unsigned int i = start; i < end; i += buffer_size)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
+
       if (octave_callback_function != 0)
         octave_play_callback (0, buffer, buffer_size, 0, 0, this);
       else
         portaudio_play_callback (0, buffer, buffer_size, 0, 0, this);
 
       err = Pa_WriteStream (stream, buffer, buffer_size);
     }
 }
@@ -1723,17 +1724,18 @@ audiorecorder::recordblocking (float sec
   unsigned int frames = seconds * get_fs ();
 
   octave::unwind_protect frame;
 
   frame.add_fcn (safe_audiorecorder_stop, this);
 
   for (unsigned int i = 0; i < frames; i += buffer_size)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
+
       Pa_ReadStream (get_stream (), buffer, buffer_size);
 
       if (octave_callback_function != 0)
         octave_record_callback (buffer, 0, buffer_size, 0, 0, this);
       else
         portaudio_record_callback (buffer, 0, buffer_size, 0, 0, this);
     }
 }
diff --git a/libinterp/dldfcn/symrcm.cc b/libinterp/dldfcn/symrcm.cc
--- a/libinterp/dldfcn/symrcm.cc
+++ b/libinterp/dldfcn/symrcm.cc
@@ -225,17 +225,17 @@ find_starting_node (octave_idx_type N, c
 
           octave_idx_type i = v.id;
 
           // add all unvisited neighbors to the queue
           octave_idx_type j1 = cidx[i];
           octave_idx_type j2 = cidx2[i];
           while (j1 < cidx[i+1] || j2 < cidx2[i+1])
             {
-              OCTAVE_QUIT;
+              octave_quit ();
 
               if (j1 == cidx[i+1])
                 {
                   octave_idx_type r2 = ridx2[j2++];
                   if (! visit[r2])
                     {
                       // the distance of node j is dist(i)+1
                       w.id = r2;
@@ -334,30 +334,31 @@ calc_degrees (octave_idx_type N, const o
 
   for (octave_idx_type i = 0; i < N; i++)
     D[i] = 0;
 
   for (octave_idx_type j = 0; j < N; j++)
     {
       for (octave_idx_type i = cidx[j]; i < cidx[j+1]; i++)
         {
-          OCTAVE_QUIT;
+          octave_quit ();
+
           octave_idx_type k = ridx[i];
           // there is a nonzero element (k,j)
           D[k]++;
           if (D[k] > max_deg)
             max_deg = D[k];
           // if there is no element (j,k) there is one in
           // the symmetric matrix:
           if (k != j)
             {
               bool found = false;
               for (octave_idx_type l = cidx[k]; l < cidx[k + 1]; l++)
                 {
-                  OCTAVE_QUIT;
+                  octave_quit ();
 
                   if (ridx[l] == j)
                     {
                       found = true;
                       break;
                     }
                   else if (ridx[l] > j)
                     break;
@@ -388,28 +389,30 @@ transpose (octave_idx_type N, const octa
   OCTAVE_LOCAL_BUFFER (octave_idx_type, w, N + 1);
   for (octave_idx_type i = 0; i < N; i++)
     w[i] = 0;
   for (octave_idx_type i = 0; i < nz; i++)
     w[ridx[i]]++;
   nz = 0;
   for (octave_idx_type i = 0; i < N; i++)
     {
-      OCTAVE_QUIT;
+      octave_quit ();
+
       cidx2[i] = nz;
       nz += w[i];
       w[i] = cidx2[i];
     }
   cidx2[N] = nz;
   w[N] = nz;
 
   for (octave_idx_type j = 0; j < N; j++)
     for (octave_idx_type k = cidx[j]; k < cidx[j + 1]; k++)
       {
-        OCTAVE_QUIT;
+        octave_quit ();
+
         octave_idx_type q = w[ridx[k]]++;
         ridx2[q] = j;
       }
 }
 
 // An implementation of the Cuthill-McKee algorithm.
 DEFUN_DLD (symrcm, args, ,
            doc: /* -*- texinfo -*-
@@ -570,20 +573,22 @@ Mathematics, ISBN 0-13-165274-5, 1981.
           // A(P(i),P(j)) or P*A*P' is banded
           P(c) = i;
 
           // put all unvisited neighbors j of node i on the heap
           s = 0;
           octave_idx_type j1 = cidx[i];
           octave_idx_type j2 = cidx2[i];
 
-          OCTAVE_QUIT;
+          octave_quit ();
+
           while (j1 < cidx[i+1] || j2 < cidx2[i+1])
             {
-              OCTAVE_QUIT;
+              octave_quit ();
+
               if (j1 == cidx[i+1])
                 {
                   octave_idx_type r2 = ridx2[j2++];
                   if (! visit[r2])
                     {
                       // the distance of node j is dist(i)+1
                       w.id = r2;
                       w.deg = D[r2];
@@ -635,17 +640,17 @@ Mathematics, ISBN 0-13-165274-5, 1981.
                       j2++;
                     }
                 }
             }
 
           // add the neighbors to the queue (sorted by node degree)
           while (! H_empty (S, s))
             {
-              OCTAVE_QUIT;
+              octave_quit ();
 
               // locate a neighbor of i with minimal degree in O(log(N))
               v = H_remove_min (S, s, 1);
 
               // entered the BFS a new level?
               if (v.dist > level)
                 {
                   // adjustment of bandwith:
diff --git a/libinterp/operators/op-int.h b/libinterp/operators/op-int.h
--- a/libinterp/operators/op-int.h
+++ b/libinterp/operators/op-int.h
@@ -394,65 +394,65 @@ along with Octave; see the file COPYING.
 
 #define OCTAVE_SM_POW_OPS(T1, T2)                               \
   octave_value                                                  \
   elem_xpow (const octave_ ## T1& a, const T2 ## NDArray& b)    \
   {                                                             \
     T2 ## NDArray result (b.dims ());                           \
     for (int i = 0; i < b.numel (); i++)                        \
       {                                                         \
-        OCTAVE_QUIT;                                            \
+        octave_quit ();                                         \
         result (i) = pow (a, b(i));                             \
       }                                                         \
     return octave_value (result);                               \
   }                                                             \
                                                                 \
   octave_value                                                  \
   elem_xpow (const octave_ ## T1& a, const NDArray& b)          \
   {                                                             \
     T1 ## NDArray result (b.dims ());                           \
     for (int i = 0; i < b.numel (); i++)                        \
       {                                                         \
-        OCTAVE_QUIT;                                            \
+        octave_quit ();                                         \
         result (i) = pow (a, b(i));                             \
       }                                                         \
     return octave_value (result);                               \
   }                                                             \
                                                                 \
   octave_value                                                  \
   elem_xpow (double a, const T2 ## NDArray& b)                  \
   {                                                             \
     T2 ## NDArray result (b.dims ());                           \
     for (int i = 0; i < b.numel (); i++)                        \
       {                                                         \
-        OCTAVE_QUIT;                                            \
+        octave_quit ();                                         \
         result (i) = pow (a, b(i));                             \
       }                                                         \
     return octave_value (result);                               \
   }                                                             \
                                                                 \
   octave_value                                                  \
   elem_xpow (const octave_ ## T1& a, const FloatNDArray& b)     \
   {                                                             \
     T1 ## NDArray result (b.dims ());                           \
     for (int i = 0; i < b.numel (); i++)                        \
       {                                                         \
-        OCTAVE_QUIT;                                            \
+        octave_quit ();                                         \
         result (i) = powf (a, b(i));                            \
       }                                                         \
     return octave_value (result);                               \
   }                                                             \
                                                                 \
   octave_value                                                  \
   elem_xpow (float a, const T2 ## NDArray& b)                   \
   {                                                             \
     T2 ## NDArray result (b.dims ());                           \
     for (int i = 0; i < b.numel (); i++)                        \
       {                                                         \
-        OCTAVE_QUIT;                                            \
+        octave_quit ();                                         \
         result (i) = powf (a, b(i));                            \
       }                                                         \
     return octave_value (result);                               \
   }
 
 #define OCTAVE_SM_CONV(TS, TM)                                          \
   DEFCONV (TS ## s_ ## TM ## m_conv, TM ## scalar, TM ## matrix)        \
   {                                                                     \
@@ -563,61 +563,61 @@ along with Octave; see the file COPYING.
   DEFNDASSIGNOP_OP (PFX ## _assign_div, TM ## matrix, TM ## scalar, TM ## scalar, /=)
 
 #define OCTAVE_MS_POW_OPS(T1, T2)                               \
   octave_value elem_xpow (T1 ## NDArray a, octave_ ## T2 b)     \
   {                                                             \
    T1 ## NDArray result (a.dims ());                            \
    for (int i = 0; i < a.numel (); i++)                         \
      {                                                          \
-       OCTAVE_QUIT;                                             \
+       octave_quit ();                                          \
        result (i) = pow (a(i), b);                              \
      }                                                          \
    return octave_value (result);                                \
   }                                                             \
                                                                 \
   octave_value elem_xpow (T1 ## NDArray a, double b)            \
   {                                                             \
     T1 ## NDArray result (a.dims ());                           \
     for (int i = 0; i < a.numel (); i++)                        \
       {                                                         \
-        OCTAVE_QUIT;                                            \
+        octave_quit ();                                         \
         result (i) = pow (a(i), b);                             \
       }                                                         \
     return octave_value (result);                               \
   }                                                             \
                                                                 \
   octave_value elem_xpow (NDArray a, octave_ ## T2 b)           \
   {                                                             \
     T2 ## NDArray result (a.dims ());                           \
     for (int i = 0; i < a.numel (); i++)                        \
       {                                                         \
-        OCTAVE_QUIT;                                            \
+        octave_quit ();                                         \
         result (i) = pow (a(i), b);                             \
       }                                                         \
     return octave_value (result);                               \
   }                                                             \
                                                                 \
   octave_value elem_xpow (T1 ## NDArray a, float b)             \
   {                                                             \
     T1 ## NDArray result (a.dims ());                           \
     for (int i = 0; i < a.numel (); i++)                        \
       {                                                         \
-        OCTAVE_QUIT;                                            \
+        octave_quit ();                                         \
         result (i) = powf (a(i), b);                            \
       }                                                         \
     return octave_value (result);                               \
   }                                                             \
                                                                 \
   octave_value elem_xpow (FloatNDArray a, octave_ ## T2 b)      \
   {                                                             \
     T2 ## NDArray result (a.dims ());                           \
     for (int i = 0; i < a.numel (); i++)                        \
       {                                                         \
-        OCTAVE_QUIT;                                            \
+        octave_quit ();                                         \
         result (i) = powf (a(i), b);                            \
       }                                                         \
     return octave_value (result);                               \
   }
 
 #define OCTAVE_MS_INT_OPS(TYPE)                                         \
   OCTAVE_MS_POW_OPS (TYPE, TYPE)                                        \
   OCTAVE_MS_INT_ARITH_OPS (ms, TYPE ## _, TYPE ## _, TYPE)              \
@@ -733,17 +733,17 @@ along with Octave; see the file COPYING.
         if (! is_valid_bsxfun ("operator .^", a_dims, b_dims))  \
           octave::err_nonconformant ("operator .^", a_dims, b_dims);    \
                                                                 \
         return bsxfun_pow (a, b);                               \
       }                                                         \
     T1 ## NDArray result (a_dims);                              \
     for (int i = 0; i < a.numel (); i++)                        \
       {                                                         \
-        OCTAVE_QUIT;                                            \
+        octave_quit ();                                         \
         result (i) = pow (a(i), b(i));                          \
       }                                                         \
     return octave_value (result);                               \
   }                                                             \
                                                                 \
   octave_value                                                  \
   elem_xpow (const T1 ## NDArray& a, const NDArray& b)          \
   {                                                             \
@@ -754,17 +754,17 @@ along with Octave; see the file COPYING.
         if (! is_valid_bsxfun ("operator .^", a_dims, b_dims))  \
           octave::err_nonconformant ("operator .^", a_dims, b_dims);    \
                                                                 \
         return bsxfun_pow (a, b);                               \
       }                                                         \
     T1 ## NDArray result (a_dims);                              \
     for (int i = 0; i < a.numel (); i++)                        \
       {                                                         \
-        OCTAVE_QUIT;                                            \
+        octave_quit ();                                         \
         result (i) = pow (a(i), b(i));                          \
       }                                                         \
     return octave_value (result);                               \
   }                                                             \
                                                                 \
   octave_value                                                  \
   elem_xpow (const NDArray& a, const T2 ## NDArray& b)          \
   {                                                             \
@@ -775,17 +775,17 @@ along with Octave; see the file COPYING.
         if (! is_valid_bsxfun ("operator .^", a_dims, b_dims))  \
           octave::err_nonconformant ("operator .^", a_dims, b_dims);    \
                                                                 \
         return bsxfun_pow (a, b);                               \
       }                                                         \
     T2 ## NDArray result (a_dims);                              \
     for (int i = 0; i < a.numel (); i++)                        \
       {                                                         \
-        OCTAVE_QUIT;                                            \
+        octave_quit ();                                         \
         result (i) = pow (a(i), b(i));                          \
       }                                                         \
     return octave_value (result);                               \
   }                                                             \
                                                                 \
   octave_value                                                  \
   elem_xpow (const T1 ## NDArray& a, const FloatNDArray& b)     \
   {                                                             \
@@ -796,17 +796,17 @@ along with Octave; see the file COPYING.
         if (! is_valid_bsxfun ("operator .^", a_dims, b_dims))  \
           octave::err_nonconformant ("operator .^", a_dims, b_dims);    \
                                                                 \
         return bsxfun_pow (a, b);                               \
       }                                                         \
     T1 ## NDArray result (a_dims);                              \
     for (int i = 0; i < a.numel (); i++)                        \
       {                                                         \
-        OCTAVE_QUIT;                                            \
+        octave_quit ();                                         \
         result (i) = powf (a(i), b(i));                         \
       }                                                         \
     return octave_value (result);                               \
   }                                                             \
                                                                 \
   octave_value                                                  \
   elem_xpow (const FloatNDArray& a, const T2 ## NDArray& b)     \
   {                                                             \
@@ -817,17 +817,17 @@ along with Octave; see the file COPYING.
         if (! is_valid_bsxfun ("operator .^", a_dims, b_dims))  \
           octave::err_nonconformant ("operator .^", a_dims, b_dims);    \
                                                                 \
         return bsxfun_pow (a, b);                               \
       }                                                         \
     T2 ## NDArray result (a_dims);                              \
     for (int i = 0; i < a.numel (); i++)                        \
       {                                                         \
-        OCTAVE_QUIT;                                            \
+        octave_quit ();                                         \
         result (i) = powf (a(i), b(i));                         \
       }                                                         \
     return octave_value (result);                               \
   }
 
 #define OCTAVE_MM_CONV(T1, T2)                                          \
   DEFCONV (T1 ## m_ ## T2 ## m_conv, T1 ## matrix, T2 ## matrix)        \
   {                                                                     \
diff --git a/liboctave/util/lo-regexp.cc b/liboctave/util/lo-regexp.cc
--- a/liboctave/util/lo-regexp.cc
+++ b/liboctave/util/lo-regexp.cc
@@ -265,17 +265,17 @@ namespace octave
         // Index of subpattern in first two bytes MSB first of name.
         // Extract index.
         nidx[i] = (static_cast<int> (nametable[i*nameentrysize])) << 8
                   | static_cast<int> (nametable[i*nameentrysize+1]);
       }
 
     while (true)
       {
-        OCTAVE_QUIT;
+        octave_quit ();
 
         int matches = pcre_exec (re, 0, buffer.c_str (),
                                  buffer.length (), idx,
                                  (idx ? PCRE_NOTBOL : 0),
                                  ovector, (subpatterns+1)*3);
 
         if (matches == PCRE_ERROR_MATCHLIMIT)
           {
@@ -291,17 +291,17 @@ namespace octave
                          static_cast<void *> (&pe.match_limit));
 
             pe.flags = PCRE_EXTRA_MATCH_LIMIT;
 
             int i = 0;
             while (matches == PCRE_ERROR_MATCHLIMIT
                    && i++ < PCRE_MATCHLIMIT_MAX)
               {
-                OCTAVE_QUIT;
+                octave_quit ();
 
                 pe.match_limit *= 10;
                 matches = pcre_exec (re, &pe, buffer.c_str (),
                                      buffer.length (), idx,
                                      (idx ? PCRE_NOTBOL : 0),
                                      ovector, (subpatterns+1)*3);
               }
           }
@@ -506,17 +506,17 @@ namespace octave
     if (num_tokens > 0)
       {
         // Determine replacement length
         const size_t replen = repstr.size () - 2*num_tokens;
         int delta = 0;
         regexp::match_data::const_iterator p = rx_lst.begin ();
         for (size_t i = 0; i < num_matches; i++)
           {
-            OCTAVE_QUIT;
+            octave_quit ();
 
             double start = p->start ();
             double end = p->end ();
 
             const Matrix pairs (p->token_extents ());
             size_t pairlen = 0;
             for (int j = 0; j < num_tokens; j++)
               {
@@ -532,17 +532,17 @@ namespace octave
           }
 
         // Build replacement string
         rep.reserve (buffer.size () + delta);
         size_t from = 0;
         p = rx_lst.begin ();
         for (size_t i = 0; i < num_matches; i++)
           {
-            OCTAVE_QUIT;
+            octave_quit ();
 
             double start = p->start ();
             double end = p->end ();
 
             const Matrix pairs (p->token_extents ());
             rep.append (&buffer[from], static_cast<size_t> (start - 1) - from);
             from = static_cast<size_t> (end);
 
@@ -582,29 +582,31 @@ namespace octave
     else
       {
         // Determine repstr length
         const size_t replen = repstr.size ();
         int delta = 0;
         regexp::match_data::const_iterator p = rx_lst.begin ();
         for (size_t i = 0; i < num_matches; i++)
           {
-            OCTAVE_QUIT;
+            octave_quit ();
+
             delta += static_cast<int> (replen)
                      - static_cast<int> (p->end () - p->start () + 1);
             p++;
           }
 
         // Build replacement string
         rep.reserve (buffer.size () + delta);
         size_t from = 0;
         p = rx_lst.begin ();
         for (size_t i = 0; i < num_matches; i++)
           {
-            OCTAVE_QUIT;
+            octave_quit ();
+
             rep.append (&buffer[from],
                         static_cast<size_t> (p->start () - 1) - from);
             from = static_cast<size_t> (p->end ());
             rep.append (repstr);
             p++;
           }
         rep.append (&buffer[from], buffer.size () - from);
       }
