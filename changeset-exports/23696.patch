# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1498482337 14400
#      Mon Jun 26 09:05:37 2017 -0400
# Node ID 08036a7f366023c687b7274f96f30a5500dc1c99
# Parent  47c39af894018ac80ded0254d6660836b44a763b
remove octave:: namespace tag from symbols used inside octave namespace

* octave-gui.cc, dynamic-ld.h, ft-text-renderer.cc, gl-render.cc,
gl-render.h, gl2ps-print.cc, input.cc, input.h, interpreter.cc,
load-path.cc, load-path.h, oct-stream.cc, sighandlers.cc, symtab.cc,
symtab.h, __ode15__.cc, gzip.cc, octave.cc, lex.ll, oct-parse.in.yy,
parse.h, pt-arg-list.cc, pt-arg-list.h, pt-array-list.h,
pt-classdef.h, pt-decl.h, pt-eval.cc, pt-eval.h, pt-exp.h,
pt-fcn-handle.cc, pt-idx.cc, pt-misc.h, pt-select.h, pt-stmt.h,
pt-tm-const.cc, pt-tm-const.h, pt.cc, aepbalance.cc, chol.cc,
gepbalance.cc, gsvd.cc, hess.cc, lo-mappers.h, lo-specfun.cc, lu.cc,
qr.cc, qrp.cc, schur.cc, sparse-chol.cc, sparse-lu.cc, sparse-qr.cc,
svd.cc, child-list.cc, dir-ops.cc, file-ops.cc, file-stat.cc,
file-stat.h, lo-sysdep.cc, oct-env.cc, oct-syscalls.cc, cmd-edit.cc,
cmd-hist.cc, oct-glob.cc, oct-locbuf.cc, oct-mutex.cc, oct-mutex.h,
oct-shlib.cc, oct-shlib.h, pathsearch.cc, url-transfer.cc,
url-transfer.h:  Remove octave:: namespace tag from symbols used
inside octave namespace.

* oct-conf-post.in.h (OCTAVE_USE_DEPRECATED_FUNCTIONS): Don't define.

diff --git a/libgui/src/octave-gui.cc b/libgui/src/octave-gui.cc
--- a/libgui/src/octave-gui.cc
+++ b/libgui/src/octave-gui.cc
@@ -133,17 +133,17 @@ namespace octave
 
   int gui_application::execute (void)
   {
     octave_thread_manager::block_interrupt_signal ();
 
     set_application_id ();
 
     std::string show_gui_msgs =
-      octave::sys::env::getenv ("OCTAVE_SHOW_GUI_MESSAGES");
+      sys::env::getenv ("OCTAVE_SHOW_GUI_MESSAGES");
 
     // Installing our handler suppresses the messages.
 
     if (show_gui_msgs.empty ())
       {
 #if defined (HAVE_QT4)
         qInstallMsgHandler (message_handler);
 #else
@@ -210,19 +210,19 @@ namespace octave
     if (start_gui)
       {
         resource_manager::update_network_settings ();
 
         // We provide specific terminal capabilities, so ensure that
         // TERM is always set appropriately.
 
 #if defined (OCTAVE_USE_WINDOWS_API)
-        octave::sys::env::putenv ("TERM", "cygwin");
+        sys::env::putenv ("TERM", "cygwin");
 #else
-        octave::sys::env::putenv ("TERM", "xterm");
+        sys::env::putenv ("TERM", "xterm");
 #endif
 
         shortcut_manager::init_data ();
       }
 
     // Force left-to-right alignment (see bug #46204)
     qt_app.setLayoutDirection (Qt::LeftToRight);
 
diff --git a/libinterp/corefcn/dynamic-ld.h b/libinterp/corefcn/dynamic-ld.h
--- a/libinterp/corefcn/dynamic-ld.h
+++ b/libinterp/corefcn/dynamic-ld.h
@@ -41,41 +41,41 @@ namespace octave
   {
   private:
 
     class
     shlibs_list
     {
     public:
 
-      typedef std::list<octave::dynamic_library>::iterator iterator;
-      typedef std::list<octave::dynamic_library>::const_iterator const_iterator;
+      typedef std::list<dynamic_library>::iterator iterator;
+      typedef std::list<dynamic_library>::const_iterator const_iterator;
 
       shlibs_list (void) : m_lib_list () { }
 
       // No copying!
 
       shlibs_list (const shlibs_list&) = delete;
 
       shlibs_list& operator = (const shlibs_list&) = delete;
 
       ~shlibs_list (void) = default;
 
-      void append (const octave::dynamic_library& shl);
+      void append (const dynamic_library& shl);
 
-      std::list<std::string> remove (octave::dynamic_library& shl);
+      std::list<std::string> remove (dynamic_library& shl);
 
-      octave::dynamic_library find_file (const std::string& file_name) const;
+      dynamic_library find_file (const std::string& file_name) const;
 
       void display (void) const;
 
     private:
 
       // List of libraries we have loaded.
-      std::list<octave::dynamic_library> m_lib_list;
+      std::list<dynamic_library> m_lib_list;
     };
 
 
   public:
 
     dynamic_loader (interpreter& interp)
       : m_interpreter (interp), m_loaded_shlibs (), m_doing_load (false)
     { }
@@ -94,26 +94,26 @@ namespace octave
               bool relative = false);
 
     octave_function *
     load_mex (const std::string& fcn_name,
               const std::string& file_name = "",
               bool relative = false);
 
     bool remove_oct (const std::string& fcn_name,
-                            octave::dynamic_library& shl);
+                            dynamic_library& shl);
 
     bool remove_mex (const std::string& fcn_name,
-                            octave::dynamic_library& shl);
+                            dynamic_library& shl);
 
   private:
 
     void clear_function (const std::string& fcn_name);
 
-    void clear (octave::dynamic_library& oct_file);
+    void clear (dynamic_library& oct_file);
 
     interpreter& m_interpreter;
 
     shlibs_list m_loaded_shlibs;
 
     bool m_doing_load;
 
     static std::string name_mangler (const std::string& name);
diff --git a/libinterp/corefcn/ft-text-renderer.cc b/libinterp/corefcn/ft-text-renderer.cc
--- a/libinterp/corefcn/ft-text-renderer.cc
+++ b/libinterp/corefcn/ft-text-renderer.cc
@@ -610,17 +610,17 @@ namespace octave
         for (const auto& lbox : line_bbox)
           {
             if (bbox.isempty ())
               bbox = lbox.extract (0, 0, 0, 3);
             else
               {
                 bbox(1) -= lbox(3);
                 bbox(3) += lbox(3);
-                bbox(2) = octave::math::max (bbox(2), lbox(2));
+                bbox(2) = math::max (bbox(2), lbox(2));
               }
           }
         break;
       }
   }
 
   void
   ft_text_renderer::update_line_bbox (void)
@@ -812,17 +812,17 @@ namespace octave
 
                         xoffset += (delta.x >> 6);
                       }
 
                     // Extend current X offset box by the width of the current
                     // glyph.  Then extend the line bounding box if necessary.
 
                     xoffset += (face->glyph->advance.x >> 6);
-                    bb(2) = octave::math::max (bb(2), xoffset);
+                    bb(2) = math::max (bb(2), xoffset);
                   }
                 break;
               }
           }
       }
 
     return glyph_index;
   }
@@ -1079,17 +1079,17 @@ namespace octave
   {
     int saved_xoffset = xoffset;
     int max_xoffset = xoffset;
 
     for (auto *txt_elt : e)
       {
         xoffset = saved_xoffset;
         txt_elt->accept (*this);
-        max_xoffset = octave::math::max (xoffset, max_xoffset);
+        max_xoffset = math::max (xoffset, max_xoffset);
       }
 
     xoffset = max_xoffset;
   }
 
   void
   ft_text_renderer::reset (void)
   {
diff --git a/libinterp/corefcn/gl-render.cc b/libinterp/corefcn/gl-render.cc
--- a/libinterp/corefcn/gl-render.cc
+++ b/libinterp/corefcn/gl-render.cc
@@ -122,17 +122,17 @@ namespace octave
       void tex_coord (double q, double r) const
       { if (valid) glTexCoord2d (q*tx, r*ty); }
 
       GLuint id;
       int w, h;
       int tw, th;
       double tx, ty;
       bool valid;
-      octave::refcount<int> count;
+      refcount<int> count;
     };
 
     texture_rep *rep;
 
   private:
     opengl_texture (texture_rep *_rep) : rep (_rep) { }
 
   public:
@@ -373,17 +373,17 @@ namespace octave
       double alpha;
       float ambient;
       float diffuse;
       float specular;
       float specular_exp;
       float specular_color_refl;
 
       // reference counter
-      octave::refcount<int> count;
+      refcount<int> count;
 
       vertex_data_rep (void)
         : coords (), color (), normal (), alpha (),
           ambient (), diffuse (), specular (), specular_exp (),
           specular_color_refl (), count (1) { }
 
       vertex_data_rep (const Matrix& c, const Matrix& col, const Matrix& n,
                        double a, float as, float ds, float ss, float se,
@@ -1429,17 +1429,17 @@ namespace octave
         bool is_origin = props.xaxislocation_is ("origin") && props.get_is2D ()
                          && ! props.yscale_is ("log");
         bool is_origin_low = is_origin && (y_min + y_max) < 0;
         Matrix xticks = xform.xscale (props.get_xtick ().matrix_value ());
         Matrix xmticks = xform.xscale (props.get_xminortickvalues ().matrix_value ());
         string_vector xticklabels = props.get_xticklabel ().string_vector_value ();
         int wmax = 0;
         int hmax = 0;
-        bool tick_along_z = nearhoriz || octave::math::isinf (fy);
+        bool tick_along_z = nearhoriz || math::isinf (fy);
         bool mirror = props.is_box () && xstate != AXE_ANY_DIR;
 
         if (props.xcolormode_is ("manual"))
           {
             // use axis color for (minor)gridcolor
             if (props.gridcolormode_is ("auto"))
               gridcolor = props.get_xcolor_rgb ();
             if (props.minorgridcolormode_is ("auto"))
@@ -1472,58 +1472,58 @@ namespace octave
                        0, (zstate != AXE_DEPTH_DIR));
 
         set_color (props.get_xcolor_rgb ());
 
         // axis line
         double y_axis_pos = 0.;
         if (is_origin)
           {
-            y_axis_pos = octave::math::max (octave::math::min (0., y_max),
+            y_axis_pos = math::max (math::min (0., y_max),
                                             y_min);
             glBegin (GL_LINES);
             set_color (props.get_ycolor_rgb ());
             glVertex3d (x_min, y_axis_pos, zpTick);
             glVertex3d (x_max, y_axis_pos, zpTick);
             glEnd ();
           }
 
         // minor tick marks
         if (do_xminortick)
           {
             if (tick_along_z)
               render_tickmarks (xmticks, x_min, x_max,
                                 is_origin ? y_axis_pos : ypTick, ypTick,
                                 zpTick, zpTickN, 0., 0.,
                                 (is_origin_low ? -1. : 1.) *
-                                octave::math::signum (zpTick-zpTickN)*fz*xticklen/2,
+                                math::signum (zpTick-zpTickN)*fz*xticklen/2,
                                 0, ! is_origin && mirror);
             else
               render_tickmarks (xmticks, x_min, x_max,
                                 is_origin ? y_axis_pos : ypTick, ypTickN,
                                 zpTick, zpTick, 0.,
                                 (is_origin_low ? -1. : 1.) *
-                                octave::math::signum (ypTick-ypTickN)*fy*xticklen/2,
+                                math::signum (ypTick-ypTickN)*fy*xticklen/2,
                                 0., 0, ! is_origin && mirror);
           }
 
         // tick marks
         if (tick_along_z)
           render_tickmarks (xticks, x_min, x_max,
                             is_origin ? y_axis_pos : ypTick, ypTick,
                             zpTick, zpTickN, 0., 0.,
                             (is_origin_low ? -1. : 1.) *
-                            octave::math::signum (zpTick-zpTickN)*fz*xticklen,
+                            math::signum (zpTick-zpTickN)*fz*xticklen,
                             0, ! is_origin && mirror);
         else
           render_tickmarks (xticks, x_min, x_max,
                             is_origin ? y_axis_pos : ypTick, ypTickN,
                             zpTick, zpTick, 0.,
                             (is_origin_low ? -1. : 1.) *
-                            octave::math::signum (ypTick-ypTickN)*fy*xticklen,
+                            math::signum (ypTick-ypTickN)*fy*xticklen,
                             0., 0, ! is_origin && mirror);
 
         // tick texts
         if (xticklabels.numel () > 0)
           {
             int halign = (xstate == AXE_HORZ_DIR
                           ? 1
                           : (xyzSym || is_origin_low ? 0 : 2));
@@ -1531,23 +1531,23 @@ namespace octave
                           ? 1
                           : (x2Dtop || is_origin_low ? 0 : 2));
 
             if (tick_along_z)
               render_ticktexts (xticks, xticklabels, x_min, x_max,
                                 is_origin ? y_axis_pos : ypTick,
                                 zpTick +
                                 (is_origin_low ? -1. : 1.) *
-                                octave::math::signum (zpTick-zpTickN)*fz*xtickoffset,
+                                math::signum (zpTick-zpTickN)*fz*xtickoffset,
                                 0, halign, valign, wmax, hmax);
             else
               render_ticktexts (xticks, xticklabels, x_min, x_max,
                                 (is_origin ? y_axis_pos : ypTick) +
                                 (is_origin_low ?  -1. : 1.) *
-                                octave::math::signum (ypTick-ypTickN)*fy*xtickoffset,
+                                math::signum (ypTick-ypTickN)*fy*xtickoffset,
                                 zpTick, 0, halign, valign, wmax, hmax);
           }
 
         gh_manager::get_object (props.get_xlabel ()).set ("visible", "on");
       }
     else
       gh_manager::get_object (props.get_xlabel ()).set ("visible", "off");
 
@@ -1610,17 +1610,17 @@ namespace octave
         bool is_origin = props.yaxislocation_is ("origin") && props.get_is2D ()
                          && ! props.xscale_is ("log");
         bool is_origin_low = is_origin && (x_min + x_max) < 0;
         Matrix yticks = xform.yscale (props.get_ytick ().matrix_value ());
         Matrix ymticks = xform.yscale (props.get_yminortickvalues ().matrix_value ());
         string_vector yticklabels = props.get_yticklabel ().string_vector_value ();
         int wmax = 0;
         int hmax = 0;
-        bool tick_along_z = nearhoriz || octave::math::isinf (fx);
+        bool tick_along_z = nearhoriz || math::isinf (fx);
         bool mirror = props.is_box () && ystate != AXE_ANY_DIR
                       && (! props.has_property ("__plotyy_axes__"));
 
         if (props.ycolormode_is ("manual"))
           {
             // use axis color for (minor)gridcolor
             if (props.gridcolormode_is ("auto"))
               gridcolor = props.get_ycolor_rgb ();
@@ -1654,58 +1654,58 @@ namespace octave
                        1, (zstate != AXE_DEPTH_DIR));
 
         set_color (props.get_ycolor_rgb ());
 
         // axis line
         double x_axis_pos = 0.;
         if (is_origin)
           {
-            x_axis_pos = octave::math::max (octave::math::min (0., x_max),
+            x_axis_pos = math::max (math::min (0., x_max),
                                             x_min);
             glBegin (GL_LINES);
             set_color (props.get_ycolor_rgb ());
             glVertex3d (x_axis_pos, y_min, zpTick);
             glVertex3d (x_axis_pos, y_max, zpTick);
             glEnd ();
           }
 
         // minor tick marks
         if (do_yminortick)
           {
             if (tick_along_z)
               render_tickmarks (ymticks, y_min, y_max,
                                 is_origin ? x_axis_pos : xpTick, xpTick,
                                 zpTick, zpTickN, 0., 0.,
                                 (is_origin_low ? -1. : 1.) *
-                                octave::math::signum (zpTick-zpTickN)*fz*yticklen/2,
+                                math::signum (zpTick-zpTickN)*fz*yticklen/2,
                                 1, ! is_origin && mirror);
             else
               render_tickmarks (ymticks, y_min, y_max,
                                 is_origin ? x_axis_pos : xpTick, xpTickN,
                                 zpTick, zpTick,
                                 (is_origin_low ? -1. : 1.) *
-                                octave::math::signum (xpTick-xpTickN)*fx*yticklen/2,
+                                math::signum (xpTick-xpTickN)*fx*yticklen/2,
                                 0., 0., 1, ! is_origin && mirror);
           }
 
         // tick marks
         if (tick_along_z)
           render_tickmarks (yticks, y_min, y_max,
                             is_origin ? x_axis_pos : xpTick, xpTick,
                             zpTick, zpTickN, 0., 0.,
                             (is_origin_low ? -1. : 1.) *
-                            octave::math::signum (zpTick-zpTickN)*fz*yticklen,
+                            math::signum (zpTick-zpTickN)*fz*yticklen,
                             1, ! is_origin && mirror);
         else
           render_tickmarks (yticks, y_min, y_max,
                             is_origin ? x_axis_pos : xpTick, xpTickN,
                             zpTick, zpTick,
                             (is_origin_low ? -1. : 1.) *
-                            octave::math::signum (xPlaneN-xPlane)*fx*yticklen,
+                            math::signum (xPlaneN-xPlane)*fx*yticklen,
                             0., 0., 1, ! is_origin && mirror);
 
         // tick texts
         if (yticklabels.numel () > 0)
           {
             int halign = (ystate == AXE_HORZ_DIR
                           ? 1
                           : (! xyzSym || y2Dright || is_origin_low ? 0 : 2));
@@ -1713,23 +1713,23 @@ namespace octave
                           ? 1
                           : (is_origin_low ? 0 : 2));
 
             if (tick_along_z)
               render_ticktexts (yticks, yticklabels, y_min, y_max,
                                 is_origin ? x_axis_pos : xpTick,
                                 zpTick +
                                 (is_origin_low ? -1. : 1.) *
-                                octave::math::signum (zpTick-zpTickN)*fz*ytickoffset,
+                                math::signum (zpTick-zpTickN)*fz*ytickoffset,
                                 1, halign, valign, wmax, hmax);
             else
               render_ticktexts (yticks, yticklabels, y_min, y_max,
                                 (is_origin ? x_axis_pos : xpTick) +
                                 (is_origin_low ?  -1. : 1.) *
-                                octave::math::signum (xpTick-xpTickN)*fx*ytickoffset,
+                                math::signum (xpTick-xpTickN)*fx*ytickoffset,
                                 zpTick, 1, halign, valign, wmax, hmax);
           }
 
         gh_manager::get_object (props.get_ylabel ()).set ("visible", "on");
       }
     else
       gh_manager::get_object (props.get_ylabel ()).set ("visible", "off");
 
@@ -1819,96 +1819,96 @@ namespace octave
 
         set_color (props.get_zcolor_rgb ());
 
         // minor tick marks
         if (do_zminortick)
           {
             if (xySym)
               {
-                if (octave::math::isinf (fy))
+                if (math::isinf (fy))
                   render_tickmarks (zmticks, z_min, z_max, xPlaneN, xPlane,
                                     yPlane, yPlane,
-                                    octave::math::signum (xPlaneN-xPlane)*fx*zticklen/2,
+                                    math::signum (xPlaneN-xPlane)*fx*zticklen/2,
                                     0., 0., 2, mirror);
                 else
                   render_tickmarks (zmticks, z_min, z_max, xPlaneN, xPlaneN,
                                     yPlane, yPlane, 0.,
-                                    octave::math::signum (yPlane-yPlaneN)*fy*zticklen/2,
+                                    math::signum (yPlane-yPlaneN)*fy*zticklen/2,
                                     0., 2, false);
               }
             else
               {
-                if (octave::math::isinf (fx))
+                if (math::isinf (fx))
                   render_tickmarks (zmticks, z_min, z_max, xPlane, xPlane,
                                     yPlaneN, yPlane, 0.,
-                                    octave::math::signum (yPlaneN-yPlane)*fy*zticklen/2,
+                                    math::signum (yPlaneN-yPlane)*fy*zticklen/2,
                                     0., 2, mirror);
                 else
                   render_tickmarks (zmticks, z_min, z_max, xPlane, xPlane,
                                     yPlaneN, yPlaneN,
-                                    octave::math::signum (xPlane-xPlaneN)*fx*zticklen/2,
+                                    math::signum (xPlane-xPlaneN)*fx*zticklen/2,
                                     0., 0., 2, false);
               }
           }
 
         // tick marks
         if (xySym)
           {
-            if (octave::math::isinf (fy))
+            if (math::isinf (fy))
               render_tickmarks (zticks, z_min, z_max, xPlaneN, xPlane,
                                 yPlane, yPlane,
-                                octave::math::signum (xPlaneN-xPlane)*fx*zticklen,
+                                math::signum (xPlaneN-xPlane)*fx*zticklen,
                                 0., 0., 2, mirror);
             else
               render_tickmarks (zticks, z_min, z_max, xPlaneN, xPlaneN,
                                 yPlane, yPlane, 0.,
-                                octave::math::signum (yPlane-yPlaneN)*fy*zticklen,
+                                math::signum (yPlane-yPlaneN)*fy*zticklen,
                                 0., 2, false);
           }
         else
           {
-            if (octave::math::isinf (fx))
+            if (math::isinf (fx))
               render_tickmarks (zticks, z_min, z_max, xPlaneN, xPlane,
                                 yPlaneN, yPlane, 0.,
-                                octave::math::signum (yPlaneN-yPlane)*fy*zticklen,
+                                math::signum (yPlaneN-yPlane)*fy*zticklen,
                                 0., 2, mirror);
             else
               render_tickmarks (zticks, z_min, z_max, xPlane, xPlane,
                                 yPlaneN, yPlane,
-                                octave::math::signum (xPlane-xPlaneN)*fx*zticklen,
+                                math::signum (xPlane-xPlaneN)*fx*zticklen,
                                 0., 0., 2, false);
           }
 
         // tick texts
         if (zticklabels.numel () > 0)
           {
             int halign = 2;
             int valign = (zstate == AXE_VERT_DIR ? 1 : (zSign ? 3 : 2));
 
             if (xySym)
               {
-                if (octave::math::isinf (fy))
+                if (math::isinf (fy))
                   render_ticktexts (zticks, zticklabels, z_min, z_max,
-                                    xPlaneN + octave::math::signum (xPlaneN-xPlane)*fx*ztickoffset,
+                                    xPlaneN + math::signum (xPlaneN-xPlane)*fx*ztickoffset,
                                     yPlane, 2, halign, valign, wmax, hmax);
                 else
                   render_ticktexts (zticks, zticklabels, z_min, z_max, xPlaneN,
-                                    yPlane + octave::math::signum (yPlane-yPlaneN)*fy*ztickoffset,
+                                    yPlane + math::signum (yPlane-yPlaneN)*fy*ztickoffset,
                                     2, halign, valign, wmax, hmax);
               }
             else
               {
-                if (octave::math::isinf (fx))
+                if (math::isinf (fx))
                   render_ticktexts (zticks, zticklabels, z_min, z_max, xPlane,
-                                    yPlaneN + octave::math::signum (yPlaneN-yPlane)*fy*ztickoffset,
+                                    yPlaneN + math::signum (yPlaneN-yPlane)*fy*ztickoffset,
                                     2, halign, valign, wmax, hmax);
                 else
                   render_ticktexts (zticks, zticklabels, z_min, z_max,
-                                    xPlane + octave::math::signum (xPlane-xPlaneN)*fx*ztickoffset,
+                                    xPlane + math::signum (xPlane-xPlaneN)*fx*ztickoffset,
                                     yPlaneN, 2, halign, valign, wmax, hmax);
               }
           }
 
         gh_manager::get_object (props.get_zlabel ()).set ("visible", "on");
       }
     else
       gh_manager::get_object (props.get_zlabel ()).set ("visible", "off");
@@ -2415,24 +2415,24 @@ namespace octave
 
                     if (clip(j-1, i-1) || clip(j, i-1)
                         || clip(j-1, i) || clip(j, i))
                       continue;
 
                     if (fc_mode == FLAT)
                       {
                         // "flat" only needs color at lower-left vertex
-                        if (! octave::math::isfinite (c(j-1,i-1)))
+                        if (! math::isfinite (c(j-1,i-1)))
                           continue;
                       }
                     else if (fc_mode == INTERP)
                       {
                         // "interp" needs valid color at all 4 vertices
-                        if (! (octave::math::isfinite (c(j-1, i-1)) && octave::math::isfinite (c(j, i-1))
-                               && octave::math::isfinite (c(j-1, i)) && octave::math::isfinite (c(j, i))))
+                        if (! (math::isfinite (c(j-1, i-1)) && math::isfinite (c(j, i-1))
+                               && math::isfinite (c(j-1, i)) && math::isfinite (c(j, i))))
                           continue;
                       }
 
                     if (x_mat)
                       {
                         j1 = j-1;
                         j2 = j;
                       }
@@ -2624,23 +2624,23 @@ namespace octave
                     for (int j = 1; j < zr; j++)
                       {
                         if (clip(j-1,i) || clip(j,i))
                           continue;
 
                         if (ec_mode == FLAT)
                           {
                             // "flat" only needs color at lower-left vertex
-                            if (! octave::math::isfinite (c(j-1,i)))
+                            if (! math::isfinite (c(j-1,i)))
                               continue;
                           }
                         else if (ec_mode == INTERP)
                           {
                             // "interp" needs valid color at both vertices
-                            if (! (octave::math::isfinite (c(j-1, i)) && octave::math::isfinite (c(j, i))))
+                            if (! (math::isfinite (c(j-1, i)) && math::isfinite (c(j, i))))
                               continue;
                           }
 
                         if (x_mat)
                           {
                             j1 = j-1;
                             j2 = j;
                           }
@@ -2721,23 +2721,23 @@ namespace octave
                     for (int i = 1; i < zc; i++)
                       {
                         if (clip(j,i-1) || clip(j,i))
                           continue;
 
                         if (ec_mode == FLAT)
                           {
                             // "flat" only needs color at lower-left vertex
-                            if (! octave::math::isfinite (c(j,i-1)))
+                            if (! math::isfinite (c(j,i-1)))
                               continue;
                           }
                         else if (ec_mode == INTERP)
                           {
                             // "interp" needs valid color at both vertices
-                            if (! (octave::math::isfinite (c(j, i-1)) && octave::math::isfinite (c(j, i))))
+                            if (! (math::isfinite (c(j, i-1)) && math::isfinite (c(j, i))))
                               continue;
                           }
 
                         if (y_mat)
                           {
                             i1 = i-1;
                             i2 = i;
                           }
@@ -2859,17 +2859,17 @@ namespace octave
                   continue;
 
                 if (x_mat)
                   j1 = j;
 
                 if ((do_edge && mecolor.isempty ())
                     || (do_face && mfcolor.isempty ()))
                   {
-                    if (! octave::math::isfinite (c(j,i)))
+                    if (! math::isfinite (c(j,i)))
                       continue;  // Skip NaNs in color data
 
                     for (int k = 0; k < 3; k++)
                       cc(k) = c(j,i,k);
                   }
 
                 Matrix lc = (do_edge ? (mecolor.isempty () ? cc : mecolor)
                                      : Matrix ());
@@ -2964,17 +2964,17 @@ namespace octave
     boolMatrix clip_f (1, nf, false);
     Array<int> count_f (dim_vector (nf, 1), 0);
 
     for (int i = 0; i < nf; i++)
       {
         bool fclip = false;
         int count = 0;
 
-        for (int j = 0; j < fcmax && ! octave::math::isnan (f(i,j)); j++, count++)
+        for (int j = 0; j < fcmax && ! math::isnan (f(i,j)); j++, count++)
           fclip = (fclip || clip(int (f(i,j) - 1)));
 
         clip_f(i) = fclip;
         count_f(i) = count;
       }
 
     if (fc_mode > 0 || ec_mode > 0)
       {
@@ -3469,18 +3469,18 @@ namespace octave
       x(1) = x(1) + (w-1);
 
     if (h > 1 && y(1) == y(0))
       y(1) = y(1) + (h-1);
 
     const ColumnVector p0 = xform.transform (x(0), y(0), 0);
     const ColumnVector p1 = xform.transform (x(1), y(1), 0);
 
-    if (octave::math::isnan (p0(0)) || octave::math::isnan (p0(1))
-        || octave::math::isnan (p1(0)) || octave::math::isnan (p1(1)))
+    if (math::isnan (p0(0)) || math::isnan (p0(1))
+        || math::isnan (p1(0)) || math::isnan (p1(1)))
       {
         warning ("opengl_renderer: image X,Y data too large to draw");
         return;
       }
 
     // image pixel size in screen pixel units
     float pix_dx, pix_dy;
     // image pixel size in normalized units
diff --git a/libinterp/corefcn/gl-render.h b/libinterp/corefcn/gl-render.h
--- a/libinterp/corefcn/gl-render.h
+++ b/libinterp/corefcn/gl-render.h
@@ -143,20 +143,20 @@ namespace octave
                                    double p1, double p2,
                                    int xyz, int ha, int va,
                                    int& wmax, int& hmax);
 
   private:
 
     bool is_nan_or_inf (double x, double y, double z) const
     {
-      return (octave::math::isnan (x) || octave::math::isnan (y)
-              || octave::math::isnan (z)
-              || octave::math::isinf (x) || octave::math::isinf (y)
-              || octave::math::isinf (z));
+      return (math::isnan (x) || math::isnan (y)
+              || math::isnan (z)
+              || math::isinf (x) || math::isinf (y)
+              || math::isinf (z));
     }
 
     octave_uint8 clip_code (double x, double y, double z) const
     {
       return ((x < xmin ? 1 : 0)
               | (x > xmax ? 1 : 0) << 1
               | (y < ymin ? 1 : 0) << 2
               | (y > ymax ? 1 : 0) << 3
diff --git a/libinterp/corefcn/gl2ps-print.cc b/libinterp/corefcn/gl2ps-print.cc
--- a/libinterp/corefcn/gl2ps-print.cc
+++ b/libinterp/corefcn/gl2ps-print.cc
@@ -52,28 +52,28 @@ namespace octave
 {
   class
   OCTINTERP_API
   gl2ps_renderer : public opengl_renderer
   {
   public:
 
     gl2ps_renderer (FILE *_fp, const std::string& _term)
-      : octave::opengl_renderer () , fp (_fp), term (_term), fontsize (),
+      : opengl_renderer () , fp (_fp), term (_term), fontsize (),
         fontname (), buffer_overflow (false)
     { }
 
     ~gl2ps_renderer (void) = default;
 
     // FIXME: should we import the functions from the base class and
     // overload them here, or should we use a different name so we don't
     // have to do this?  Without the using declaration or a name change,
     // the base class functions will be hidden.  That may be OK, but it
     // can also cause some confusion.
-    using octave::opengl_renderer::draw;
+    using opengl_renderer::draw;
 
     void draw (const graphics_object& go, const std::string& print_cmd);
 
   protected:
 
     Matrix render_text (const std::string& txt,
                         double x, double y, double z,
                         int halign, int valign, double rotation = 0.0);
@@ -83,17 +83,17 @@ namespace octave
     void draw_axes (const axes::properties& props)
     {
       // Initialize a sorting tree (viewport) in gl2ps for each axes
       GLint vp[4];
       glGetIntegerv (GL_VIEWPORT, vp);
       gl2psBeginViewport (vp);
 
       // Draw and finish () or there may primitives missing in the gl2ps output.
-      octave::opengl_renderer::draw_axes (props);
+      opengl_renderer::draw_axes (props);
       finish ();
 
       // Finalize viewport
       GLint state = gl2psEndViewport ();
       if (state == GL2PS_NO_FEEDBACK)
         warning ("gl2ps_renderer::draw_axes: empty feedback buffer and/or nothing else to print");
       else if (state == GL2PS_ERROR)
         error ("gl2ps_renderer::draw_axes: gl2psEndPage returned GL2PS_ERROR");
@@ -111,78 +111,78 @@ namespace octave
 
     void draw_pixels (int w, int h, const float *data);
     void draw_pixels (int w, int h, const uint8_t *data);
     void draw_pixels (int w, int h, const uint16_t *data);
 
     void set_linestyle (const std::string& s, bool use_stipple = false,
                         double linewidth = 0.5)
     {
-      octave::opengl_renderer::set_linestyle (s, use_stipple, linewidth);
+      opengl_renderer::set_linestyle (s, use_stipple, linewidth);
 
       if (s == "-" && ! use_stipple)
         gl2psDisable (GL2PS_LINE_STIPPLE);
       else
         gl2psEnable (GL2PS_LINE_STIPPLE);
     }
 
     void set_linecap (const std::string& s)
       {
-        octave::opengl_renderer::set_linejoin (s);
+        opengl_renderer::set_linejoin (s);
 
 #if defined (HAVE_GL2PSLINEJOIN)
         if (s == "butt")
           gl2psLineCap (GL2PS_LINE_CAP_BUTT);
         else if (s == "square")
           gl2psLineCap (GL2PS_LINE_CAP_SQUARE);
         else if (s == "round")
           gl2psLineCap (GL2PS_LINE_CAP_ROUND);
 #endif
       }
 
     void set_linejoin (const std::string& s)
     {
-      octave::opengl_renderer::set_linejoin (s);
+      opengl_renderer::set_linejoin (s);
 
 #if defined (HAVE_GL2PSLINEJOIN)
       if (s == "round")
         gl2psLineJoin (GL2PS_LINE_JOIN_ROUND);
       else if (s == "miter")
         gl2psLineJoin (GL2PS_LINE_JOIN_MITER);
       else if (s == "chamfer")
         gl2psLineJoin (GL2PS_LINE_JOIN_BEVEL);
 #endif
     }
 
     void set_polygon_offset (bool on, float offset = 0.0f)
     {
       if (on)
         {
-          octave::opengl_renderer::set_polygon_offset (on, offset);
+          opengl_renderer::set_polygon_offset (on, offset);
           gl2psEnable (GL2PS_POLYGON_OFFSET_FILL);
         }
       else
         {
           gl2psDisable (GL2PS_POLYGON_OFFSET_FILL);
-          octave::opengl_renderer::set_polygon_offset (on, offset);
+          opengl_renderer::set_polygon_offset (on, offset);
         }
     }
 
     void set_linewidth (float w)
     {
       gl2psLineWidth (w);
     }
 
   private:
 
     // Use xform to compute the coordinates of the string list
     // that have been parsed by freetype
     void fix_strlist_position (double x, double y, double z,
                                Matrix box, double rotation,
-                               std::list<octave::text_renderer::string>& lst);
+                               std::list<text_renderer::string>& lst);
 
     int alignment_to_mode (int ha, int va) const;
     FILE *fp;
     caseless_str term;
     double fontsize;
     std::string fontname;
     bool buffer_overflow;
   };
@@ -191,17 +191,17 @@ namespace octave
   gl2ps_renderer::draw (const graphics_object& go, const std::string& print_cmd)
   {
     static bool in_draw = false;
     static std::string old_print_cmd;
     static GLint buffsize;
 
     if (! in_draw)
       {
-        octave::unwind_protect frame;
+        unwind_protect frame;
 
         frame.protect_var (in_draw);
 
         in_draw = true;
 
         GLint gl2ps_term = GL2PS_PS;
         if (term.find ("eps") != std::string::npos)
           gl2ps_term = GL2PS_EPS;
@@ -293,17 +293,17 @@ namespace octave
                                         GL_RGBA, 0, 0, 0, 0, 0,
                                         buffsize, tmpf, include_graph.c_str ());
             if (ret == GL2PS_ERROR)
               {
                 old_print_cmd.clear ();
                 error ("gl2ps_renderer::draw: gl2psBeginPage returned GL2PS_ERROR");
               }
 
-            octave::opengl_renderer::draw (go);
+            opengl_renderer::draw (go);
 
             if (buffer_overflow)
               warning ("gl2ps_renderer::draw: retrying with buffer size: %.1E B\n", double (2*buffsize));
 
             if (! buffer_overflow)
               old_print_cmd = print_cmd;
 
             // Don't check return value of gl2psEndPage, it is not meaningful.
@@ -320,24 +320,24 @@ namespace octave
         while (! feof (tmpf) && nread)
           {
             nread = std::fread (str, 1, 8192, tmpf);
             if (nread)
               {
                 nwrite = std::fwrite (str, 1, nread, fp);
                 if (nwrite != nread)
                   {
-                    octave::signal_handler ();   // Clear SIGPIPE signal
+                    signal_handler ();   // Clear SIGPIPE signal
                     error ("gl2ps_renderer::draw: internal pipe error");
                   }
               }
           }
       }
     else
-      octave::opengl_renderer::draw (go);
+      opengl_renderer::draw (go);
   }
 
   int
   gl2ps_renderer::alignment_to_mode (int ha, int va) const
   {
     int gl2psa = GL2PS_TEXT_BL;
 
     if (ha == 0)
@@ -369,17 +369,17 @@ namespace octave
       }
 
     return gl2psa;
   }
 
   void
   gl2ps_renderer::fix_strlist_position (double x, double y, double z,
                                         Matrix box, double rotation,
-                                        std::list<octave::text_renderer::string>& lst)
+                                        std::list<text_renderer::string>& lst)
   {
     for (auto& txtobj : lst)
       {
         // Get pixel coordinates
         ColumnVector coord_pix = get_transform ().transform (x, y, z, false);
 
         // Translate and rotate
         double rot = rotation * 4.0 * atan (1.0) / 180;
@@ -621,30 +621,30 @@ namespace octave
 
     if (txt.empty ())
       return Matrix (1, 4, 0.0);
 
     // We have no way to get a bounding box from gl2ps, so we parse the raw
     // string using freetype
     Matrix bbox;
     std::string str = txt;
-    std::list<octave::text_renderer::string> lst;
+    std::list<text_renderer::string> lst;
 
     text_to_strlist (str, lst, bbox, ha, va, rotation);
 
     // When using "tex" or when the string has only one line and no
     // special characters, use gl2ps for alignment
     if (lst.empty () || term.find ("tex") != std::string::npos
         || (lst.size () == 1 && ! lst.front ().get_code ()))
       {
         std::string name = fontname;
         int sz = fontsize;
         if (! lst.empty () && term.find ("tex") == std::string::npos)
           {
-            octave::text_renderer::string s = lst.front ();
+            text_renderer::string s = lst.front ();
             name = select_font (s.get_name (), s.get_weight () == "bold",
                                 s.get_angle () == "italic");
             set_color (s.get_color ());
             str = s.get_string ();
             sz = s.get_size ();
           }
 
         glRasterPos3d (x, y, z);
@@ -706,17 +706,17 @@ namespace octave
 
     fontname = saved_font;
     return bbox;
   }
 
   void
   gl2ps_renderer::set_font (const base_properties& props)
   {
-    octave::opengl_renderer::set_font (props);
+    opengl_renderer::set_font (props);
 
     // Set the interpreter so that text_to_pixels can parse strings properly
     if (props.has_property ("interpreter"))
       set_interpreter (props.get ("interpreter").string_value ());
 
     fontsize = props.get ("__fontsize_points__").double_value ();
 
     caseless_str fn = props.get ("fontname").xtolower ().string_value ();
@@ -842,17 +842,17 @@ namespace octave
 
     // FIXME: should we have a way to create a file that begins with the
     // character '|'?
 
     bool have_cmd = stream.length () > 1 && stream[0] == '|';
 
     FILE *fp = nullptr;
 
-    octave::unwind_protect frame;
+    unwind_protect frame;
 
     if (have_cmd)
       {
         // Create process and pipe gl2ps output to it.
 
         std::string cmd = stream.substr (1);
 
         fp = octave_popen (cmd.c_str (), "w");
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -146,33 +146,33 @@ set_default_prompts (void)
   octave_link::set_default_prompts (VPS1, VPS2, VPS4);
 }
 
 namespace octave
 {
   void
   base_reader::do_input_echo (const std::string& input_string) const
   {
-    bool forced_interactive = octave::application::forced_interactive ();
+    bool forced_interactive = application::forced_interactive ();
 
     int do_echo = reading_script_file ()
       ? (Vecho_executing_commands & ECHO_SCRIPTS)
       : ((Vecho_executing_commands & ECHO_CMD_LINE) && ! forced_interactive);
 
     if (do_echo)
       {
         if (forced_interactive)
           {
             if (pflag > 0)
-              octave_stdout << octave::command_editor::decode_prompt_string (VPS1);
+              octave_stdout << command_editor::decode_prompt_string (VPS1);
             else
-              octave_stdout << octave::command_editor::decode_prompt_string (VPS2);
+              octave_stdout << command_editor::decode_prompt_string (VPS2);
           }
         else
-          octave_stdout << octave::command_editor::decode_prompt_string (VPS4);
+          octave_stdout << command_editor::decode_prompt_string (VPS4);
 
         if (! input_string.empty ())
           {
             octave_stdout << input_string;
 
             if (input_string[input_string.length () - 1] != '\n')
               octave_stdout << "\n";
           }
@@ -244,49 +244,49 @@ namespace octave
 
     eof = false;
 
     std::string retval;
 
     // Process pre input event hook function prior to flushing output and
     // printing the prompt.
 
-    if (octave::application::interactive ())
+    if (application::interactive ())
       {
         if (! Vdebugging)
           octave_link::exit_debugger_event ();
 
         octave_link::pre_input_event ();
 
         octave_link::set_workspace ();
       }
 
     bool history_skip_auto_repeated_debugging_command = false;
 
     std::string ps = (pflag > 0) ? VPS1 : VPS2;
 
-    std::string prompt = octave::command_editor::decode_prompt_string (ps);
+    std::string prompt = command_editor::decode_prompt_string (ps);
 
-    octave::pipe_handler_error_count = 0;
+    pipe_handler_error_count = 0;
 
-    octave::flush_stdout ();
+    flush_stdout ();
 
-    octave::pager_stream::reset ();
-    octave::diary_stream::reset ();
+    pager_stream::reset ();
+    diary_stream::reset ();
 
     octave_diary << prompt;
 
     retval = interactive_input (prompt, eof);
 
     // There is no need to update the load_path cache if there is no
     // user input.
     if (retval != "\n"
         && retval.find_first_not_of (" \t\n\r") != std::string::npos)
       {
-        load_path& lp = octave::__get_load_path__ ("base_reader::octave_gets");
+        load_path& lp = __get_load_path__ ("base_reader::octave_gets");
 
         lp.update ();
 
         if (Vdebugging)
           last_debugging_command = retval;
         else
           last_debugging_command = "\n";
       }
@@ -295,34 +295,34 @@ namespace octave
         retval = last_debugging_command;
         history_skip_auto_repeated_debugging_command = true;
       }
 
     if (retval != "\n")
       {
         if (! history_skip_auto_repeated_debugging_command)
           {
-            if (octave::command_history::add (retval))
+            if (command_history::add (retval))
               octave_link::append_history (retval);
           }
 
         octave_diary << retval;
 
         if (retval[retval.length () - 1] != '\n')
           octave_diary << "\n";
 
         do_input_echo (retval);
       }
     else
       octave_diary << "\n";
 
     // Process post input event hook function after the internal history
     // list has been updated.
 
-    if (octave::application::interactive ())
+    if (application::interactive ())
       octave_link::post_input_event ();
 
     return retval;
   }
 
   bool
   base_reader::reading_fcn_file (void) const
   {
diff --git a/libinterp/corefcn/input.h b/libinterp/corefcn/input.h
--- a/libinterp/corefcn/input.h
+++ b/libinterp/corefcn/input.h
@@ -90,17 +90,17 @@ namespace octave
 {
   class
   base_reader
   {
   public:
 
     friend class input_reader;
 
-    base_reader (octave::base_lexer *lxr)
+    base_reader (base_lexer *lxr)
       : count (1), pflag (0), lexer (lxr)
     { }
 
     base_reader (const base_reader& x)
       : count (1), pflag (x.pflag), lexer (x.lexer)
     { }
 
     virtual ~base_reader (void) = default;
@@ -135,33 +135,33 @@ namespace octave
     virtual bool input_from_terminal (void) const { return false; }
 
     virtual bool input_from_file (void) const { return false; }
 
     virtual bool input_from_eval_string (void) const { return false; }
 
   private:
 
-    octave::refcount<int> count;
+    refcount<int> count;
 
     int pflag;
 
-    octave::base_lexer *lexer;
+    base_lexer *lexer;
 
     void do_input_echo (const std::string&) const;
 
     static const std::string in_src;
   };
 
   class
   terminal_reader : public base_reader
   {
   public:
 
-    terminal_reader (octave::base_lexer *lxr = nullptr)
+    terminal_reader (base_lexer *lxr = nullptr)
       : base_reader (lxr)
     { }
 
     std::string get_input (bool& eof);
 
     std::string input_source (void) const { return in_src; }
 
     bool input_from_terminal (void) const { return true; }
@@ -171,17 +171,17 @@ namespace octave
     static const std::string in_src;
   };
 
   class
   file_reader : public base_reader
   {
   public:
 
-    file_reader (FILE *f_arg, octave::base_lexer *lxr = nullptr)
+    file_reader (FILE *f_arg, base_lexer *lxr = nullptr)
       : base_reader (lxr), file (f_arg) { }
 
     std::string get_input (bool& eof);
 
     std::string input_source (void) const { return in_src; }
 
     bool input_from_file (void) const { return true; }
 
@@ -193,17 +193,17 @@ namespace octave
   };
 
   class
   eval_string_reader : public base_reader
   {
   public:
 
     eval_string_reader (const std::string& str,
-                               octave::base_lexer *lxr = nullptr)
+                               base_lexer *lxr = nullptr)
       : base_reader (lxr), eval_string (str)
     { }
 
     std::string get_input (bool& eof);
 
     std::string input_source (void) const { return in_src; }
 
     bool input_from_eval_string (void) const { return true; }
@@ -214,25 +214,25 @@ namespace octave
 
     static const std::string in_src;
   };
 
   class
   input_reader
   {
   public:
-    input_reader (octave::base_lexer *lxr = nullptr)
+    input_reader (base_lexer *lxr = nullptr)
       : rep (new terminal_reader (lxr))
     { }
 
-    input_reader (FILE *file, octave::base_lexer *lxr = nullptr)
+    input_reader (FILE *file, base_lexer *lxr = nullptr)
       : rep (new file_reader (file, lxr))
     { }
 
-    input_reader (const std::string& str, octave::base_lexer *lxr = nullptr)
+    input_reader (const std::string& str, base_lexer *lxr = nullptr)
       : rep (new eval_string_reader (str, lxr))
     { }
 
     input_reader (const input_reader& ir)
     {
       rep = ir.rep;
       rep->count++;
     }
diff --git a/libinterp/corefcn/interpreter.cc b/libinterp/corefcn/interpreter.cc
--- a/libinterp/corefcn/interpreter.cc
+++ b/libinterp/corefcn/interpreter.cc
@@ -391,49 +391,49 @@ namespace octave
       throw std::runtime_error
         ("only one Octave interpreter object may be active");
 
     instance = this;
 
     // Matlab uses "C" locale for LC_NUMERIC class regardless of local setting
     setlocale (LC_NUMERIC, "C");
     setlocale (LC_TIME, "C");
-    octave::sys::env::putenv ("LC_NUMERIC", "C");
-    octave::sys::env::putenv ("LC_TIME", "C");
+    sys::env::putenv ("LC_NUMERIC", "C");
+    sys::env::putenv ("LC_TIME", "C");
 
     // Initialize the default floating point unit control state.
     octave_set_default_fpucw ();
 
-    octave::thread::init ();
+    thread::init ();
 
     set_default_prompts ();
 
     // Initialize default warning state before --traditional option
     // that may reset them.
 
     initialize_default_warning_state ();
 
     octave_ieee_init ();
 
     octave_prepare_hdf5 ();
 
     // The idea here is to force xerbla to be referenced so that we will link to
     // our own version instead of the one provided by the BLAS library.  But
-    // octave::numeric_limits<double>::NaN () should never be -1, so we
+    // numeric_limits<double>::NaN () should never be -1, so we
     // should never actually call xerbla.  FIXME (again!):  If this
     // becomes a constant expression the test might be optimized away and
     // then the reference to the function might also disappear.
 
-    if (octave::numeric_limits<double>::NaN () == -1)
+    if (numeric_limits<double>::NaN () == -1)
       F77_FUNC (xerbla, XERBLA) ("octave", 13 F77_CHAR_ARG_LEN (6));
 
     initialize_error_handlers ();
 
     if (m_app_context)
-      octave::install_signal_handlers ();
+      install_signal_handlers ();
     else
       quit_allowed = false;
 
     initialize_file_io ();
 
     install_types ();
 
     install_ops ();
@@ -497,17 +497,17 @@ namespace octave
 
         traditional = options.traditional ();
       }
 
     // Force default line editor if we don't want readline editing.
     if (line_editing)
       initialize_command_input ();
     else
-      octave::command_editor::force_default_editor ();
+      command_editor::force_default_editor ();
 
     // These can come after command line args since none of them set any
     // defaults that might be changed by command line options.
 
     initialize_version_info ();
 
     // This should be done before initializing the load path because
     // some PKG_ADD files might need --traditional behavior.
@@ -550,17 +550,17 @@ namespace octave
             const cmdline_options& options = m_app_context->options ();
 
             read_history_file = options.read_history_file ();
           }
 
         ::initialize_history (read_history_file);
 
         if (! m_app_context)
-          octave::command_history::ignore_entries ();
+          command_history::ignore_entries ();
 
         m_history_initialized = true;
       }
   }
 
   // Set the initial path to the system default unless command-line
   // option says to leave it empty.
 
@@ -581,17 +581,17 @@ namespace octave
         // catches exceptions.  This is better than wrapping
         // load_path::initialize in a try-catch block because it will
         // not stop executing PKG_ADD files at the first exception.
         // It's also better than changing the default execute_pkg_add
         // function to use safe_source file because that will normally
         // be evaluated from the normal intepreter loop where exceptions
         // are already handled.
 
-        octave::unwind_protect frame;
+        unwind_protect frame;
 
         frame.add_method (m_load_path, &load_path::set_add_hook,
                           m_load_path.get_add_hook ());
 
         m_load_path.set_add_hook (execute_pkg_add);
 
         m_load_path.initialize (set_initial_path);
 
@@ -658,26 +658,26 @@ namespace octave
               return exit_status;
           }
 
         // Force input to be echoed if not really interactive,
         // but the user has forced interactive behavior.
 
         if (options.forced_interactive ())
           {
-            octave::command_editor::blink_matching_paren (false);
+            command_editor::blink_matching_paren (false);
 
             // FIXME: is this the right thing to do?
             Fecho_executing_commands (octave_value (ECHO_CMD_LINE));
           }
       }
 
     // Avoid counting commands executed from startup or script files.
 
-    octave::command_editor::reset_current_command_number (1);
+    command_editor::reset_current_command_number (1);
 
     m_initialized = true;
 
     return exit_status;
   }
 
   int interpreter::execute (void)
   {
@@ -685,17 +685,17 @@ namespace octave
       {
         int status = initialize ();
 
         if (! m_initialized)
           return status;
 
         return main_loop ();
       }
-    catch (const octave::exit_exception& ex)
+    catch (const exit_exception& ex)
       {
         return ex.exit_status ();
       }
   }
 
   void interpreter::display_startup_message (void) const
   {
     bool inhibit_startup_message = false;
@@ -763,54 +763,54 @@ namespace octave
     if (read_init_files)
       {
         // Try to execute commands from $HOME/$OCTAVE_INITFILE and
         // $OCTAVE_INITFILE.  If $OCTAVE_INITFILE is not set,
         // .octaverc is assumed.
 
         bool home_rc_already_executed = false;
 
-        std::string initfile = octave::sys::env::getenv ("OCTAVE_INITFILE");
+        std::string initfile = sys::env::getenv ("OCTAVE_INITFILE");
 
         if (initfile.empty ())
           initfile = ".octaverc";
 
-        std::string home_dir = octave::sys::env::get_home_directory ();
+        std::string home_dir = sys::env::get_home_directory ();
 
-        std::string home_rc = octave::sys::env::make_absolute (initfile, home_dir);
+        std::string home_rc = sys::env::make_absolute (initfile, home_dir);
 
         std::string local_rc;
 
         if (! home_rc.empty ())
           {
             int status = safe_source_file (home_rc, context, verbose,
                                            require_file);
 
             if (status)
               exit_status = status;
 
             // Names alone are not enough.
 
-            octave::sys::file_stat fs_home_rc (home_rc);
+            sys::file_stat fs_home_rc (home_rc);
 
             if (fs_home_rc)
               {
                 // We want to check for curr_dir after executing home_rc
                 // because doing that may change the working directory.
 
-                local_rc = octave::sys::env::make_absolute (initfile);
+                local_rc = sys::env::make_absolute (initfile);
 
                 home_rc_already_executed = same_file (home_rc, local_rc);
               }
           }
 
         if (! home_rc_already_executed)
           {
             if (local_rc.empty ())
-              local_rc = octave::sys::env::make_absolute (initfile);
+              local_rc = sys::env::make_absolute (initfile);
 
             int status = safe_source_file (local_rc, context, verbose,
                                            require_file);
 
             if (status)
               exit_status = status;
           }
       }
@@ -824,71 +824,71 @@ namespace octave
   // Execute any code specified with --eval 'CODE'
 
   int interpreter::execute_eval_option_code (void)
   {
     const cmdline_options& options = m_app_context->options ();
 
     std::string code_to_eval = options.code_to_eval ();
 
-    octave::unwind_protect frame;
+    unwind_protect frame;
 
     octave_save_signal_mask ();
 
-    octave::can_interrupt = true;
+    can_interrupt = true;
 
-    octave_signal_hook = octave::signal_handler;
+    octave_signal_hook = signal_handler;
     octave_interrupt_hook = 0;
     octave_bad_alloc_hook = 0;
 
-    octave::catch_interrupts ();
+    catch_interrupts ();
 
     octave_initialized = true;
 
     frame.add_method (this, &interpreter::interactive, m_interactive);
 
     m_interactive = false;
 
     int parse_status = 0;
 
     try
       {
         eval_string (code_to_eval, false, parse_status, 0);
       }
-    catch (const octave::interrupt_exception&)
+    catch (const interrupt_exception&)
       {
         recover_from_exception ();
 
         return 1;
       }
-    catch (const octave::execution_exception&)
+    catch (const execution_exception&)
       {
         recover_from_exception ();
 
         return 1;
       }
 
     return parse_status;
   }
 
   int interpreter::execute_command_line_file (void)
   {
     const cmdline_options& options = m_app_context->options ();
 
-    octave::unwind_protect frame;
+    unwind_protect frame;
 
     octave_save_signal_mask ();
 
-    octave::can_interrupt = true;
+    can_interrupt = true;
 
-    octave_signal_hook = octave::signal_handler;
+    octave_signal_hook = signal_handler;
     octave_interrupt_hook = 0;
     octave_bad_alloc_hook = 0;
 
-    octave::catch_interrupts ();
+    catch_interrupts ();
 
     octave_initialized = true;
 
     frame.add_method (this, &interpreter::interactive, m_interactive);
 
     string_vector args = options.all_args ();
 
     frame.add_method (m_app_context, &application::intern_argv, args);
@@ -926,57 +926,57 @@ namespace octave
 
   int interpreter::main_loop (void)
   {
     if (! m_app_context)
       return 0;
 
     octave_save_signal_mask ();
 
-    octave::can_interrupt = true;
+    can_interrupt = true;
 
-    octave_signal_hook = octave::signal_handler;
+    octave_signal_hook = signal_handler;
     octave_interrupt_hook = 0;
     octave_bad_alloc_hook = 0;
 
-    octave::catch_interrupts ();
+    catch_interrupts ();
 
     octave_initialized = true;
 
     // The big loop.
 
-    octave::lexer *lxr = (octave::application::interactive ()
-                          ? new octave::lexer ()
-                          : new octave::lexer (stdin));
+    lexer *lxr = (application::interactive ()
+                          ? new lexer ()
+                          : new lexer (stdin));
 
-    octave::parser parser (*lxr);
+    parser parser (*lxr);
 
     int retval = 0;
     do
       {
         try
           {
             reset_error_handler ();
 
             parser.reset ();
 
             if (m_symbol_table.at_top_level ())
-              octave::tree_evaluator::reset_debug_state ();
+              tree_evaluator::reset_debug_state ();
 
             retval = parser.run ();
 
             if (retval == 0)
               {
                 if (parser.m_stmt_list)
                   {
                     parser.m_stmt_list->accept (m_evaluator);
 
                     octave_quit ();
 
-                    if (! octave::application::interactive ())
+                    if (! application::interactive ())
                       {
                         bool quit = (tree_return_command::returning
                                      || tree_break_command::breaking);
 
                         if (tree_return_command::returning)
                           tree_return_command::returning = 0;
 
                         if (tree_break_command::breaking)
@@ -984,49 +984,49 @@ namespace octave
 
                         if (quit)
                           break;
                       }
 
                     if (octave_completion_matches_called)
                       octave_completion_matches_called = false;
                     else
-                      octave::command_editor::increment_current_command_number ();
+                      command_editor::increment_current_command_number ();
                   }
                 else if (parser.m_lexer.end_of_input)
                   {
                     retval = EOF;
                     break;
                   }
               }
           }
-        catch (const octave::interrupt_exception&)
+        catch (const interrupt_exception&)
           {
             recover_from_exception ();
 
             // Required newline when the user does Ctrl+C at the prompt.
-            if (octave::application::interactive ())
+            if (application::interactive ())
               octave_stdout << "\n";
           }
-        catch (const octave::index_exception& e)
+        catch (const index_exception& e)
           {
             recover_from_exception ();
 
             std::cerr << "error: unhandled index exception: "
                       << e.message () << " -- trying to return to prompt"
                       << std::endl;
           }
-        catch (const octave::execution_exception& e)
+        catch (const execution_exception& e)
           {
             std::string stack_trace = e.info ();
 
             if (! stack_trace.empty ())
               std::cerr << stack_trace;
 
-            if (octave::application::interactive ())
+            if (application::interactive ())
               recover_from_exception ();
             else
               {
                 // We should exit with a nonzero status.
                 retval = 1;
                 break;
               }
           }
@@ -1045,17 +1045,17 @@ namespace octave
               debug_or_throw_exception (true);  // true = stack trace
           }
 #endif
       }
     while (retval == 0);
 
     if (retval == EOF)
       {
-        if (octave::application::interactive ())
+        if (application::interactive ())
           octave_stdout << "\n";
 
         retval = 0;
       }
 
     return retval;
   }
 
@@ -1071,29 +1071,29 @@ namespace octave
                 << std::endl;                                           \
     }
 
 #define OCTAVE_SAFE_CALL(F, ARGS)                                       \
   do                                                                    \
     {                                                                   \
       try                                                               \
         {                                                               \
-          octave::unwind_protect frame;                                 \
+          unwind_protect frame;                                 \
                                                                         \
           frame.protect_var (Vdebug_on_error);                          \
           frame.protect_var (Vdebug_on_warning);                        \
                                                                         \
           Vdebug_on_error = false;                                      \
           Vdebug_on_warning = false;                                    \
                                                                         \
           F ARGS;                                                       \
         }                                                               \
-      OCTAVE_IGNORE_EXCEPTION (const octave::exit_exception&)           \
-      OCTAVE_IGNORE_EXCEPTION (const octave::interrupt_exception&)      \
-      OCTAVE_IGNORE_EXCEPTION (const octave::execution_exception&)      \
+      OCTAVE_IGNORE_EXCEPTION (const exit_exception&)           \
+      OCTAVE_IGNORE_EXCEPTION (const interrupt_exception&)      \
+      OCTAVE_IGNORE_EXCEPTION (const execution_exception&)      \
       OCTAVE_IGNORE_EXCEPTION (const std::bad_alloc&)                   \
     }                                                                   \
   while (0)
 
   void interpreter::cleanup (void)
   {
     // If we are attached to a GUI, process pending events and
     // disconnect the link.
@@ -1106,32 +1106,32 @@ namespace octave
     while (! atexit_functions.empty ())
       {
         std::string fcn = atexit_functions.front ();
 
         atexit_functions.pop_front ();
 
         OCTAVE_SAFE_CALL (reset_error_handler, ());
 
-        OCTAVE_SAFE_CALL (octave::feval, (fcn, octave_value_list (), 0));
+        OCTAVE_SAFE_CALL (feval, (fcn, octave_value_list (), 0));
 
-        OCTAVE_SAFE_CALL (octave::flush_stdout, ());
+        OCTAVE_SAFE_CALL (flush_stdout, ());
       }
 
     // Do this explicitly so that destructors for mex file objects
     // are called, so that functions registered with mexAtExit are
     // called.
     OCTAVE_SAFE_CALL (clear_mex_functions, ());
 
-    OCTAVE_SAFE_CALL (octave::command_editor::restore_terminal_state, ());
+    OCTAVE_SAFE_CALL (command_editor::restore_terminal_state, ());
 
     OCTAVE_SAFE_CALL (octave_history_write_timestamp, ());
 
-    if (! octave::command_history::ignoring_entries ())
-      OCTAVE_SAFE_CALL (octave::command_history::clean_up_and_save, ());
+    if (! command_history::ignoring_entries ())
+      OCTAVE_SAFE_CALL (command_history::clean_up_and_save, ());
 
     OCTAVE_SAFE_CALL (gh_manager::close_all_figures, ());
 
     OCTAVE_SAFE_CALL (gtk_manager::unload_all_toolkits, ());
 
     OCTAVE_SAFE_CALL (close_files, ());
 
     OCTAVE_SAFE_CALL (cleanup_tmp_files, ());
@@ -1140,31 +1140,31 @@ namespace octave
     // destructors for class objects will run properly.  Should that be
     // done earlier?  Before or after atexit functions are executed?
     m_symbol_table.cleanup ();
 
     OCTAVE_SAFE_CALL (sysdep_cleanup, ());
 
     OCTAVE_SAFE_CALL (octave_finalize_hdf5, ());
 
-    OCTAVE_SAFE_CALL (octave::flush_stdout, ());
+    OCTAVE_SAFE_CALL (flush_stdout, ());
 
     // Don't call singleton_cleanup_list::cleanup until we have the
     // problems with registering/unregistering types worked out.  For
     // example, uncomment the following line, then use the make_int
     // function from the examples directory to create an integer
     // object and then exit Octave.  Octave should crash with a
     // segfault when cleaning up the typinfo singleton.  We need some
     // way to force new octave_value_X types that are created in
     // .oct files to be unregistered when the .oct file shared library
     // is unloaded.
     //
     // OCTAVE_SAFE_CALL (singleton_cleanup_list::cleanup, ());
 
-    OCTAVE_SAFE_CALL (octave::chunk_buffer::clear, ());
+    OCTAVE_SAFE_CALL (chunk_buffer::clear, ());
   }
 
   tree_evaluator& interpreter::get_evaluator (void)
   {
     return m_evaluator;
   }
 
   symbol_table::scope *
@@ -1186,23 +1186,23 @@ namespace octave
 
   call_stack& interpreter::get_call_stack (void)
   {
     return m_evaluator.get_call_stack ();
   }
 
   void interpreter::recover_from_exception (void)
   {
-    octave::can_interrupt = true;
+    can_interrupt = true;
     octave_interrupt_immediately = 0;
     octave_interrupt_state = 0;
     octave_signal_caught = 0;
     octave_exception_state = octave_no_exception;
     octave_restore_signal_mask ();
-    octave::catch_interrupts ();
+    catch_interrupts ();
   }
 
   // Functions to call when the interpreter exits.
 
   std::list<std::string> interpreter::atexit_functions;
 
   void interpreter::add_atexit_function (const std::string& fname)
   {
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -221,26 +221,26 @@ namespace octave
         maybe_add_path_elts (sys_path, Voct_file_dir);
         maybe_add_path_elts (sys_path, Vfcn_file_dir);
         maybe_add_path_elts (sys_path, Voct_data_dir);
       }
 
     std::string tpath = load_path::m_command_line_path;
 
     if (tpath.empty ())
-      tpath = octave::sys::env::getenv ("OCTAVE_PATH");
+      tpath = sys::env::getenv ("OCTAVE_PATH");
 
     std::string xpath;
 
     if (! tpath.empty ())
       {
         xpath = tpath;
 
         if (! sys_path.empty ())
-          xpath += octave::directory_path::path_sep_str () + sys_path;
+          xpath += directory_path::path_sep_str () + sys_path;
       }
     else
       xpath = sys_path;
 
     set (xpath, false, true);
   }
 
   void
@@ -274,17 +274,17 @@ namespace octave
                                  "default load path altered.  Some built-in functions may not be found.  Try restoredefaultpath() to recover it.");
                 break;
               }
           }
       }
 
     // Temporarily disable add hook.
 
-    octave::unwind_protect frame;
+    unwind_protect frame;
     frame.protect_var (add_hook);
 
     add_hook = 0;
 
     clear ();
 
     for (const auto& elt : elts)
       append (elt, warn);
@@ -329,17 +329,17 @@ namespace octave
           {
             warning ("rmpath: can't remove \".\" from path");
 
             // Avoid additional warnings.
             retval = true;
           }
         else
           {
-            std::string dir = octave::sys::file_ops::tilde_expand (dir_arg);
+            std::string dir = sys::file_ops::tilde_expand (dir_arg);
 
             dir = strip_trailing_separators (dir);
 
             dir_info_list_iterator i = find_dir_info (dir);
 
             if (i != dir_info_list.end ())
               {
                 retval = true;
@@ -424,41 +424,41 @@ namespace octave
     return retval;
   }
 
   std::string
   load_path::find_file (const std::string& file) const
   {
     std::string retval;
 
-    if (octave::sys::env::absolute_pathname (file)
-        || octave::sys::env::rooted_relative_pathname (file))
+    if (sys::env::absolute_pathname (file)
+        || sys::env::rooted_relative_pathname (file))
       {
-        octave::sys::file_stat fs (file);
+        sys::file_stat fs (file);
 
         return fs.exists () ? file : retval;
       }
     else
       {
         std::string tfile = find_private_file (file);
 
         if (! tfile.empty ())
           return tfile;
       }
 
-    if (file.find_first_of (octave::sys::file_ops::dir_sep_chars ())
+    if (file.find_first_of (sys::file_ops::dir_sep_chars ())
         != std::string::npos)
       {
         // Given name has a directory separator, so append it to each
         // element of the load path in turn.
         for (const auto& di : dir_info_list)
           {
-            std::string tfile = octave::sys::file_ops::concat (di.dir_name, file);
-
-            octave::sys::file_stat fs (tfile);
+            std::string tfile = sys::file_ops::concat (di.dir_name, file);
+
+            sys::file_stat fs (tfile);
 
             if (fs.exists ())
               return tfile;
           }
       }
     else
       {
         // Look in cache.
@@ -466,106 +466,106 @@ namespace octave
           {
             string_vector all_files = di.all_files;
 
             octave_idx_type len = all_files.numel ();
 
             for (octave_idx_type i = 0; i < len; i++)
               {
                 if (all_files[i] == file)
-                  return octave::sys::file_ops::concat (di.dir_name, file);
+                  return sys::file_ops::concat (di.dir_name, file);
               }
           }
       }
 
     return retval;
   }
 
   std::string
   load_path::find_dir (const std::string& dir) const
   {
     std::string retval;
 
-    if (dir.find_first_of (octave::sys::file_ops::dir_sep_chars ()) != std::string::npos
-        && (octave::sys::env::absolute_pathname (dir)
-            || octave::sys::env::rooted_relative_pathname (dir)))
+    if (dir.find_first_of (sys::file_ops::dir_sep_chars ()) != std::string::npos
+        && (sys::env::absolute_pathname (dir)
+            || sys::env::rooted_relative_pathname (dir)))
       {
-        octave::sys::file_stat fs (dir);
+        sys::file_stat fs (dir);
 
         if (fs.exists () && fs.is_dir ())
           return dir;
       }
     else
       {
         for (const auto& di : dir_info_list)
           {
-            std::string dname = octave::sys::env::make_absolute (di.dir_name);
+            std::string dname = sys::env::make_absolute (di.dir_name);
 
             size_t dname_len = dname.length ();
 
             if (dname.substr (dname_len - 1)
-                == octave::sys::file_ops::dir_sep_str ())
+                == sys::file_ops::dir_sep_str ())
               {
                 dname = dname.substr (0, dname_len - 1);
                 dname_len--;
               }
 
             size_t dir_len = dir.length ();
 
             if (dname_len > dir_len
-                && octave::sys::file_ops::is_dir_sep (dname[dname_len - dir_len - 1])
+                && sys::file_ops::is_dir_sep (dname[dname_len - dir_len - 1])
                 && dir == dname.substr (dname_len - dir_len))
               {
-                octave::sys::file_stat fs (di.dir_name);
+                sys::file_stat fs (di.dir_name);
 
                 if (fs.exists () && fs.is_dir ())
                   return di.dir_name;
               }
           }
       }
 
     return retval;
   }
 
   string_vector
   load_path::find_matching_dirs (const std::string& dir) const
   {
     std::list<std::string> retlist;
 
-    if (dir.find_first_of (octave::sys::file_ops::dir_sep_chars ()) != std::string::npos
-        && (octave::sys::env::absolute_pathname (dir)
-            || octave::sys::env::rooted_relative_pathname (dir)))
+    if (dir.find_first_of (sys::file_ops::dir_sep_chars ()) != std::string::npos
+        && (sys::env::absolute_pathname (dir)
+            || sys::env::rooted_relative_pathname (dir)))
       {
-        octave::sys::file_stat fs (dir);
+        sys::file_stat fs (dir);
 
         if (fs.exists () && fs.is_dir ())
           retlist.push_back (dir);
       }
     else
       {
         for (const auto& di : dir_info_list)
           {
-            std::string dname = octave::sys::env::make_absolute (di.dir_name);
+            std::string dname = sys::env::make_absolute (di.dir_name);
 
             size_t dname_len = dname.length ();
 
             if (dname.substr (dname_len - 1)
-                == octave::sys::file_ops::dir_sep_str ())
+                == sys::file_ops::dir_sep_str ())
               {
                 dname = dname.substr (0, dname_len - 1);
                 dname_len--;
               }
 
             size_t dir_len = dir.length ();
 
             if (dname_len > dir_len
-                && octave::sys::file_ops::is_dir_sep (dname[dname_len - dir_len - 1])
+                && sys::file_ops::is_dir_sep (dname[dname_len - dir_len - 1])
                 && dir == dname.substr (dname_len - dir_len))
               {
-                octave::sys::file_stat fs (di.dir_name);
+                sys::file_stat fs (di.dir_name);
 
                 if (fs.exists () && fs.is_dir ())
                   retlist.push_back (di.dir_name);
               }
           }
       }
 
     return retlist;
@@ -583,35 +583,35 @@ namespace octave
     octave_idx_type rel_flen = 0;
 
     string_vector rel_flist (flen);
 
     for (octave_idx_type i = 0; i < flen; i++)
       {
         std::string file = flist[i];
 
-        if (file.find_first_of (octave::sys::file_ops::dir_sep_chars ())
+        if (file.find_first_of (sys::file_ops::dir_sep_chars ())
             != std::string::npos)
           {
-            if (octave::sys::env::absolute_pathname (file)
-                || octave::sys::env::rooted_relative_pathname (file))
+            if (sys::env::absolute_pathname (file)
+                || sys::env::rooted_relative_pathname (file))
               {
-                octave::sys::file_stat fs (file);
+                sys::file_stat fs (file);
 
                 if (fs.exists ())
                   return file;
               }
             else
               {
                 for (const auto& di : dir_info_list)
                   {
                     std::string tfile;
-                    tfile = octave::sys::file_ops::concat (di.dir_name, file);
-
-                    octave::sys::file_stat fs (tfile);
+                    tfile = sys::file_ops::concat (di.dir_name, file);
+
+                    sys::file_stat fs (tfile);
 
                     if (fs.exists ())
                       return tfile;
                   }
               }
           }
         else
           rel_flist[rel_flen++] = file;
@@ -638,17 +638,17 @@ namespace octave
                   }
               }
           }
       }
 
   done:
 
     if (! dir_name.empty ())
-      retval = octave::sys::file_ops::concat (dir_name, file_name);
+      retval = sys::file_ops::concat (dir_name, file_name);
 
     return retval;
   }
 
   string_vector
   load_path::find_all_first_of (const string_vector& flist) const
   {
     std::list<std::string> retlist;
@@ -660,35 +660,35 @@ namespace octave
     octave_idx_type rel_flen = 0;
 
     string_vector rel_flist (flen);
 
     for (octave_idx_type i = 0; i < flen; i++)
       {
         std::string file = flist[i];
 
-        if (file.find_first_of (octave::sys::file_ops::dir_sep_chars ())
+        if (file.find_first_of (sys::file_ops::dir_sep_chars ())
             != std::string::npos)
           {
-            if (octave::sys::env::absolute_pathname (file)
-                || octave::sys::env::rooted_relative_pathname (file))
+            if (sys::env::absolute_pathname (file)
+                || sys::env::rooted_relative_pathname (file))
               {
-                octave::sys::file_stat fs (file);
+                sys::file_stat fs (file);
 
                 if (fs.exists ())
                   retlist.push_back (file);
               }
             else
               {
                 for (const auto& di : dir_info_list)
                   {
                     std::string tfile;
-                    tfile = octave::sys::file_ops::concat (di.dir_name, file);
-
-                    octave::sys::file_stat fs (tfile);
+                    tfile = sys::file_ops::concat (di.dir_name, file);
+
+                    sys::file_stat fs (tfile);
 
                     if (fs.exists ())
                       retlist.push_back (tfile);
                   }
               }
           }
         else
           rel_flist[rel_flen++] = file;
@@ -702,17 +702,17 @@ namespace octave
 
         octave_idx_type len = all_files.numel ();
 
         for (octave_idx_type i = 0; i < len; i++)
           {
             for (octave_idx_type j = 0; j < rel_flen; j++)
               {
                 if (all_files[i] == rel_flist[j])
-                  retlist.push_back (octave::sys::file_ops::concat (di.dir_name,
+                  retlist.push_back (sys::file_ops::concat (di.dir_name,
                                                                     rel_flist[j]));
               }
           }
       }
 
     return retlist;
   }
 
@@ -784,17 +784,17 @@ namespace octave
     string_vector xdirs = load_path::dirs ();
 
     octave_idx_type len = xdirs.numel ();
 
     if (len > 0)
       xpath = xdirs[0];
 
     for (octave_idx_type i = 1; i < len; i++)
-      xpath += octave::directory_path::path_sep_str () + xdirs[i];
+      xpath += directory_path::path_sep_str () + xdirs[i];
 
     return xpath;
   }
 
   void
   load_path::display (std::ostream& os) const
   {
     for (const auto& di : dir_info_list)
@@ -845,17 +845,17 @@ namespace octave
     execute_pkg_add_or_del (dir, "PKG_DEL");
   }
 
   // FIXME: maybe we should also maintain a map to speed up this method of access.
 
   load_path::const_dir_info_list_iterator
   load_path::find_dir_info (const std::string& dir_arg) const
   {
-    std::string dir = octave::sys::file_ops::tilde_expand (dir_arg);
+    std::string dir = sys::file_ops::tilde_expand (dir_arg);
 
     const_dir_info_list_iterator retval = dir_info_list.begin ();
 
     while (retval != dir_info_list.end ())
       {
         if (retval->dir_name == dir)
           break;
 
@@ -863,17 +863,17 @@ namespace octave
       }
 
     return retval;
   }
 
   load_path::dir_info_list_iterator
   load_path::find_dir_info (const std::string& dir_arg)
   {
-    std::string dir = octave::sys::file_ops::tilde_expand (dir_arg);
+    std::string dir = sys::file_ops::tilde_expand (dir_arg);
 
     dir_info_list_iterator retval = dir_info_list.begin ();
 
     while (retval != dir_info_list.end ())
       {
         if (retval->dir_name == dir)
           break;
 
@@ -931,27 +931,27 @@ namespace octave
   load_path::add (const std::string& dir_arg, bool at_end, bool warn)
   {
     size_t len = dir_arg.length ();
 
     if (len > 1 && dir_arg.substr (len-2) == "//")
       warning_with_id ("Octave:recursive-path-search",
                        "trailing '//' is no longer special in search path elements");
 
-    std::string dir = octave::sys::file_ops::tilde_expand (dir_arg);
+    std::string dir = sys::file_ops::tilde_expand (dir_arg);
 
     dir = strip_trailing_separators (dir);
 
     dir_info_list_iterator i = find_dir_info (dir);
 
     if (i != dir_info_list.end ())
       move (i, at_end);
     else
       {
-        octave::sys::file_stat fs (dir);
+        sys::file_stat fs (dir);
 
         if (fs)
           {
             if (fs.is_dir ())
               {
                 dir_info di (dir);
 
                 if (at_end)
@@ -1063,17 +1063,17 @@ namespace octave
     return retval;
   }
 
   load_path::dir_info::fcn_file_map_type
   get_fcn_files (const std::string& d)
   {
     load_path::dir_info::fcn_file_map_type retval;
 
-    octave::sys::dir_entry dir (d);
+    sys::dir_entry dir (d);
 
     if (dir)
       {
         string_vector flist = dir.read ();
 
         octave_idx_type len = flist.numel ();
 
         for (octave_idx_type i = 0; i < len; i++)
@@ -1111,30 +1111,30 @@ namespace octave
       }
 
     return retval;
   }
 
   void
   load_path::dir_info::update (void)
   {
-    octave::sys::file_stat fs (dir_name);
+    sys::file_stat fs (dir_name);
 
     if (! fs)
       {
         std::string msg = fs.error ();
         warning ("load_path: %s: %s", dir_name.c_str (), msg.c_str ());
       }
     else
       {
         if (is_relative)
           {
             try
               {
-                std::string abs_name = octave::sys::env::make_absolute (dir_name);
+                std::string abs_name = sys::env::make_absolute (dir_name);
 
                 const_abs_dir_cache_iterator p = abs_dir_cache.find (abs_name);
 
                 if (p != abs_dir_cache.end ())
                   {
                     // The directory is in the cache of all directories we have
                     // visited (indexed by absolute name).  If it is out of date,
                     // initialize it.  Otherwise, copy the info from the cache.
@@ -1160,21 +1160,21 @@ namespace octave
                       }
                   }
                 else
                   {
                     // We haven't seen this directory before.
                     initialize ();
                   }
               }
-            catch (const octave::execution_exception&)
+            catch (const execution_exception&)
               {
                 // Skip updating if we don't know where we are,
                 // but don't treat it as an error.
-                octave::interpreter::recover_from_exception ();
+                interpreter::recover_from_exception ();
               }
           }
         // Absolute path, check timestamp to see whether it requires re-caching
         else if (fs.mtime () + fs.time_resolution () > dir_time_last_checked)
           initialize ();
       }
   }
 
@@ -1197,61 +1197,61 @@ namespace octave
         else
           return false;
       }
   }
 
   void
   load_path::dir_info::initialize (void)
   {
-    is_relative = ! octave::sys::env::absolute_pathname (dir_name);
-
-    dir_time_last_checked = octave::sys::time (static_cast<time_t> (0));
-
-    octave::sys::file_stat fs (dir_name);
+    is_relative = ! sys::env::absolute_pathname (dir_name);
+
+    dir_time_last_checked = sys::time (static_cast<time_t> (0));
+
+    sys::file_stat fs (dir_name);
 
     if (fs)
       {
         method_file_map.clear ();
         package_dir_map.clear ();
 
         dir_mtime = fs.mtime ();
-        dir_time_last_checked = octave::sys::time ();
+        dir_time_last_checked = sys::time ();
 
         get_file_list (dir_name);
 
         try
           {
-            std::string abs_name = octave::sys::env::make_absolute (dir_name);
+            std::string abs_name = sys::env::make_absolute (dir_name);
 
             // FIXME: nothing is ever removed from this cache of
             // directory information, so there could be some resource
             // problems.  Perhaps it should be pruned from time to time.
 
             abs_dir_cache[abs_name] = *this;
           }
-        catch (const octave::execution_exception&)
+        catch (const execution_exception&)
           {
             // Skip updating if we don't know where we are but don't treat
             // it as an error.
 
-            octave::interpreter::recover_from_exception ();
+            interpreter::recover_from_exception ();
           }
       }
     else
       {
         std::string msg = fs.error ();
         warning ("load_path: %s: %s", dir_name.c_str (), msg.c_str ());
       }
   }
 
   void
   load_path::dir_info::get_file_list (const std::string& d)
   {
-    octave::sys::dir_entry dir (d);
+    sys::dir_entry dir (d);
 
     if (dir)
       {
         string_vector flist = dir.read ();
 
         octave_idx_type len = flist.numel ();
 
         all_files.resize (len);
@@ -1259,19 +1259,19 @@ namespace octave
 
         octave_idx_type all_files_count = 0;
         octave_idx_type fcn_files_count = 0;
 
         for (octave_idx_type i = 0; i < len; i++)
           {
             std::string fname = flist[i];
 
-            std::string full_name = octave::sys::file_ops::concat (d, fname);
-
-            octave::sys::file_stat fs (full_name);
+            std::string full_name = sys::file_ops::concat (d, fname);
+
+            sys::file_stat fs (full_name);
 
             if (fs)
               {
                 if (fs.is_dir ())
                   {
                     if (fname == "private")
                       get_private_file_map (full_name);
                     else if (fname[0] == '@')
@@ -1318,19 +1318,19 @@ namespace octave
   }
 
   void
   load_path::dir_info::get_method_file_map (const std::string& d,
                                             const std::string& class_name)
   {
     method_file_map[class_name].method_file_map = get_fcn_files (d);
 
-    std::string pd = octave::sys::file_ops::concat (d, "private");
-
-    octave::sys::file_stat fs (pd);
+    std::string pd = sys::file_ops::concat (d, "private");
+
+    sys::file_stat fs (pd);
 
     if (fs && fs.is_dir ())
       method_file_map[class_name].private_file_map = get_fcn_files (pd);
   }
 
   void
   load_path::dir_info::get_package_dir (const std::string& d,
                                         const std::string& package_name)
@@ -1388,17 +1388,17 @@ namespace octave
 
     for (const auto& dir : dir_list)
       os << dir << "\n";
     os << "\n";
 
     for (const auto& dir_fnlst : private_fcn_map)
       {
         os << "\n*** private functions in "
-           << octave::sys::file_ops::concat (dir_fnlst.first, "private")
+           << sys::file_ops::concat (dir_fnlst.first, "private")
            << ":\n\n";
 
         print_fcn_list (os, dir_fnlst.second);
       }
 
 #if defined (DEBUG_LOAD_PATH)
 
     for (const auto& nm_filst : fcn_map)
@@ -1475,17 +1475,17 @@ namespace octave
         const_fcn_map_iterator p = fcn_map.find (fcn);
 
         if (p != fcn_map.end ())
           {
             const file_info_list_type& file_info_list = p->second;
 
             for (const auto& fi : file_info_list)
               {
-                retval = octave::sys::file_ops::concat (fi.dir_name, fcn);
+                retval = sys::file_ops::concat (fi.dir_name, fcn);
 
                 if (check_file_type (retval, type, fi.types,
                                      fcn, "load_path::find_fcn"))
                   {
                     dir_name = fi.dir_name;
                     break;
                   }
                 else
@@ -1512,17 +1512,17 @@ namespace octave
       {
         const dir_info::fcn_file_map_type& m = q->second;
 
         dir_info::const_fcn_file_map_iterator p = m.find (fcn);
 
         if (p != m.end ())
           {
             std::string fname
-              = octave::sys::file_ops::concat (octave::sys::file_ops::concat (dir, "private"), fcn);
+              = sys::file_ops::concat (sys::file_ops::concat (dir, "private"), fcn);
 
             if (check_file_type (fname, type, p->second, fcn,
                                  "load_path::find_private_fcn"))
               retval = fname;
           }
       }
 
     return retval;
@@ -1549,17 +1549,17 @@ namespace octave
         const_fcn_map_iterator p = m.find (meth);
 
         if (p != m.end ())
           {
             const file_info_list_type& file_info_list = p->second;
 
             for (const auto& fi : file_info_list)
               {
-                retval = octave::sys::file_ops::concat (fi.dir_name, meth);
+                retval = sys::file_ops::concat (fi.dir_name, meth);
 
                 bool found = check_file_type (retval, type, fi.types,
                                               meth, "load_path::find_method");
 
                 if (found)
                   {
                     dir_name = fi.dir_name;
                     break;
@@ -1678,22 +1678,22 @@ namespace octave
           {
             // Warn if a built-in or library function is being shadowed,
             // but not if we are just updating (rehashing) the list.
 
             if (! updating)
               {
                 if (file_info_list.empty ())
                   {
-                    octave::symbol_table& symtab
-                      = octave::__get_symbol_table__ ("load_path::package_info::add_to_fcn_map");
+                    symbol_table& symtab
+                      = __get_symbol_table__ ("load_path::package_info::add_to_fcn_map");
 
                     if (symtab.is_built_in_function_name (base))
                       {
-                        std::string fcn_path = octave::sys::file_ops::concat (dir_name, fname);
+                        std::string fcn_path = sys::file_ops::concat (dir_name, fname);
 
                         warning_with_id ("Octave:shadowed-function",
                                          "function %s shadows a built-in function",
                                          fcn_path.c_str ());
                       }
                   }
                 else if (! at_end)
                   {
@@ -1705,17 +1705,17 @@ namespace octave
 
                     // Don't warn about Contents.m files since we expect
                     // more than one to exist in the load path.
 
                     if (fname != "Contents.m"
                         && sys_path.find (old.dir_name) != std::string::npos
                         && in_path_list (sys_path, old.dir_name))
                       {
-                        std::string fcn_path = octave::sys::file_ops::concat (dir_name, fname);
+                        std::string fcn_path = sys::file_ops::concat (dir_name, fname);
 
                         warning_with_id ("Octave:shadowed-function",
                                          "function %s shadows a core library function",
                                          fcn_path.c_str ());
                       }
                   }
               }
 
@@ -1754,17 +1754,17 @@ namespace octave
 
     for (const auto& cls_ci : method_file_map)
       {
         std::string class_name = cls_ci.first;
 
         fcn_map_type& fm = method_map[class_name];
 
         std::string full_dir_name
-          = octave::sys::file_ops::concat (dir_name, "@" + class_name);
+          = sys::file_ops::concat (dir_name, "@" + class_name);
 
         const dir_info::class_info& ci = cls_ci.second;
 
         // <FCN_NAME, TYPES>
         const dir_info::fcn_file_map_type& m = ci.method_file_map;
 
         for (const auto& nm_typ : m)
           {
@@ -1862,17 +1862,17 @@ namespace octave
   {
     for (auto& cls_fnmap : method_map)
       {
         std::string class_name = cls_fnmap.first;
 
         fcn_map_type& fn_map = cls_fnmap.second;
 
         std::string full_dir_name
-          = octave::sys::file_ops::concat (dir_name, "@" + class_name);
+          = sys::file_ops::concat (dir_name, "@" + class_name);
 
         for (auto& nm_filst : fn_map)
           {
             file_info_list_type& file_info_list = nm_filst.second;
 
             if (file_info_list.size () == 1)
               continue;
             else
@@ -1953,17 +1953,17 @@ namespace octave
   {
     for (auto& cls_fnmap : method_map)
       {
         std::string class_name = cls_fnmap.first;
 
         fcn_map_type& fn_map = cls_fnmap.second;
 
         std::string full_dir_name
-          = octave::sys::file_ops::concat (dir, "@" + class_name);
+          = sys::file_ops::concat (dir, "@" + class_name);
 
         for (auto& nm_filst : fn_map)
           {
             file_info_list_type& file_info_list = nm_filst.second;
 
             if (file_info_list.size () == 1)
               continue;
             else
@@ -2124,17 +2124,17 @@ namespace octave
       }
   }
 
   std::string
   genpath (const std::string& dirname, const string_vector& skip)
   {
     std::string retval;
 
-    octave::sys::dir_entry dir (dirname);
+    sys::dir_entry dir (dirname);
 
     if (dir)
       {
         retval = dirname;
 
         string_vector dirlist = dir.read ().sort (false);
 
         octave_idx_type len = dirlist.numel ();
@@ -2152,22 +2152,22 @@ namespace octave
                   {
                     skip_p = (elt == skip[j]);
                     if (skip_p)
                       break;
                   }
 
                 if (! skip_p)
                   {
-                    std::string nm = octave::sys::file_ops::concat (dirname, elt);
-
-                    octave::sys::file_stat fs (nm);
+                    std::string nm = sys::file_ops::concat (dirname, elt);
+
+                    sys::file_stat fs (nm);
 
                     if (fs && fs.is_dir ())
-                      retval += octave::directory_path::path_sep_str () + genpath (nm, skip);
+                      retval += directory_path::path_sep_str () + genpath (nm, skip);
                   }
               }
           }
       }
 
     return retval;
   }
 }
diff --git a/libinterp/corefcn/load-path.h b/libinterp/corefcn/load-path.h
--- a/libinterp/corefcn/load-path.h
+++ b/libinterp/corefcn/load-path.h
@@ -178,17 +178,17 @@ namespace octave
     static void execute_pkg_add (const std::string& dir);
     static void execute_pkg_del (const std::string& dir);
 
     void set_command_line_path (const std::string& p)
     {
       if (m_command_line_path.empty ())
         m_command_line_path = p;
       else
-        m_command_line_path += octave::directory_path::path_sep_str () + p;
+        m_command_line_path += directory_path::path_sep_str () + p;
     }
 
     std::string get_command_line_path (void) const
     {
       return m_command_line_path;
     }
 
     std::string system_path (void) const { return sys_path; }
@@ -265,18 +265,18 @@ namespace octave
 
       dir_info& operator = (const dir_info& di) = default;
 
       void update (void);
 
       std::string dir_name;
       std::string abs_dir_name;
       bool is_relative;
-      octave::sys::time dir_mtime;
-      octave::sys::time dir_time_last_checked;
+      sys::time dir_mtime;
+      sys::time dir_time_last_checked;
       string_vector all_files;
       string_vector fcn_files;
       fcn_file_map_type private_file_map;
       method_file_map_type method_file_map;
       package_dir_map_type package_dir_map;
 
       bool is_package (const std::string& name) const;
 
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -2540,17 +2540,17 @@ namespace octave
 
     return retval;             // May have returned 4 above.
   }
 
   textscan::textscan (const std::string& who_arg)
     : who (who_arg), buf (), whitespace_table (), delim_table (),
       delims (), comment_style (), comment_len (0), comment_char (-2),
       buffer_size (0), date_locale (), inf_nan (init_inf_nan ()),
-      empty_value (octave::numeric_limits<double>::NaN ()), exp_chars ("edED"),
+      empty_value (numeric_limits<double>::NaN ()), exp_chars ("edED"),
       header_lines (0), treat_as_empty (), treat_as_empty_len (0),
       whitespace (" \b\t"), eol1 ('\r'), eol2 ('\n'),
       return_on_error (1), collect_output (false),
       multiple_delims_as_one (false), default_exp (true), lines (0)
   { }
 
   octave_value
   textscan::scan (std::istream& isp, const std::string& fmt,
@@ -2904,38 +2904,38 @@ namespace octave
       is.putback (ch);
 
     // Check for +/- inf and NaN
     if (! valid && width_left >= 3)
       {
         int i = lookahead (is, inf_nan, 3, false);   // false -> case insensitive
         if (i == 0)
           {
-            retval = octave::numeric_limits<double>::Inf ();
+            retval = numeric_limits<double>::Inf ();
             valid = true;
           }
         else if (i == 1)
           {
-            retval = octave::numeric_limits<double>::NaN ();
+            retval = numeric_limits<double>::NaN ();
             valid = true;
           }
       }
 
     // Check for +/- inf and NaN
     if (! valid && width_left >= 3)
       {
         int i = lookahead (is, inf_nan, 3, false);   // false -> case insensitive
         if (i == 0)
           {
-            retval = octave::numeric_limits<double>::Inf ();
+            retval = numeric_limits<double>::Inf ();
             valid = true;
           }
         else if (i == 1)
           {
-            retval = octave::numeric_limits<double>::NaN ();
+            retval = numeric_limits<double>::NaN ();
             valid = true;
           }
       }
 
     if (! valid)
       is.setstate (std::ios::failbit);
     else
       is.setstate (is.rdstate () & ~std::ios::failbit);
@@ -2971,18 +2971,18 @@ namespace octave
                 char *pos = is.tellg ();
                 std::ios::iostate state = is.rdstate ();
 
                 is.get ();
                 ch2 = is.get ();
                 if (ch2 == 'f')
                   {
                     inf = true;
-                    re = (ch == '+' ? octave::numeric_limits<double>::Inf ()
-                                    : -octave::numeric_limits<double>::Inf ());
+                    re = (ch == '+' ? numeric_limits<double>::Inf ()
+                                    : -numeric_limits<double>::Inf ());
                     value = 0;
                   }
                 else
                   {
                     is.clear (state);
                     is.seekg (pos);   // reset to position before look-ahead
                   }
               }
@@ -2997,18 +2997,18 @@ namespace octave
       {
         char *pos = is.tellg ();
         std::ios::iostate state = is.rdstate ();
         //re = octave_read_value<double> (is);
         re = read_double (is, fmt);
 
         // check for "treat as empty" string
         if (treat_as_empty.numel ()
-            && (is.fail () || octave::math::is_NaN_or_NA (Complex (re))
-                || re == octave::numeric_limits<double>::Inf ()))
+            && (is.fail () || math::is_NaN_or_NA (Complex (re))
+                || re == numeric_limits<double>::Inf ()))
           {
 
             for (int i = 0; i < treat_as_empty.numel (); i++)
               {
                 if (ch == treat_as_empty (i).string_value ()[0])
                   {
                     as_empty = true;   // first char matches, so read the lot
                     break;
@@ -4000,17 +4000,17 @@ namespace octave
 
   // Functions that are defined for all input streams (input streams
   // are those that define is).
 
   std::string
   base_stream::do_gets (octave_idx_type max_len, bool& err,
                         bool strip_newline, const std::string& who)
   {
-    if (octave::application::interactive () && file_number () == 0)
+    if (application::interactive () && file_number () == 0)
       ::error ("%s: unable to read from stdin while running interactively",
                who.c_str ());
 
     std::string retval;
 
     err = false;
 
     std::istream *isp = input_stream ();
@@ -4111,17 +4111,17 @@ namespace octave
                      const std::string& who)
   {
     return do_gets (max_len, err, false, who);
   }
 
   off_t
   base_stream::skipl (off_t num, bool& err, const std::string& who)
   {
-    if (octave::application::interactive () && file_number () == 0)
+    if (application::interactive () && file_number () == 0)
       ::error ("%s: unable to read from stdin while running interactively",
                who.c_str ());
 
     off_t cnt = -1;
 
     err = false;
 
     std::istream *isp = input_stream ();
@@ -5709,17 +5709,17 @@ namespace octave
             {
               double dval = val.double_value (true);
 
               retval += do_printf_conv (os, fmt, nsa, sa_1, sa_2, dval, who);
             }
             break;
 
           default:
-            // Note: error is member fcn from octave::base_stream, not ::error.
+            // Note: error is member fcn from base_stream, not ::error.
             // This error does not halt execution so "return ..." must exist.
             error ("%s: invalid format specifier", who.c_str ());
             return -1;
             break;
           }
       }
 
     return retval;
@@ -6046,17 +6046,17 @@ namespace octave
 
     int conv_err = 0;
 
     int count = 1;
 
     if (tc_count.is_defined ())
       {
         if (tc_count.is_scalar_type ()
-            && octave::math::isinf (tc_count.scalar_value ()))
+            && math::isinf (tc_count.scalar_value ()))
           count = -1;
         else
           {
             count = convert_to_valid_int (tc_count, conv_err);
 
             if (conv_err || count < 0)
               {
                 err = true;
@@ -6374,17 +6374,17 @@ namespace octave
 {
   octave_value
   stream::finalize_read (std::list<void *>& input_buf_list,
                          octave_idx_type input_buf_elts,
                          octave_idx_type elts_read,
                          octave_idx_type nr, octave_idx_type nc,
                          oct_data_conv::data_type input_type,
                          oct_data_conv::data_type output_type,
-                         octave::mach_info::float_format ffmt)
+                         mach_info::float_format ffmt)
   {
     octave_value retval;
 
     static bool initialized = false;
 
     // Table function pointers for return types x read types.
 
     static conv_fptr conv_fptr_table[oct_data_conv::dt_unknown][14];
@@ -6410,23 +6410,23 @@ namespace octave
         FILL_TABLE_ROW (dt_uchar, unsigned char);
         FILL_TABLE_ROW (dt_logical, bool);
 
         initialized = true;
       }
 
     bool swap = false;
 
-    if (ffmt == octave::mach_info::flt_fmt_unknown)
+    if (ffmt == mach_info::flt_fmt_unknown)
       ffmt = float_format ();
 
-    if (octave::mach_info::words_big_endian ())
-      swap = (ffmt == octave::mach_info::flt_fmt_ieee_little_endian);
+    if (mach_info::words_big_endian ())
+      swap = (ffmt == mach_info::flt_fmt_ieee_little_endian);
     else
-      swap = (ffmt == octave::mach_info::flt_fmt_ieee_big_endian);
+      swap = (ffmt == mach_info::flt_fmt_ieee_big_endian);
 
     bool do_float_fmt_conv = ((input_type == oct_data_conv::dt_double
                                || input_type == oct_data_conv::dt_single)
                               && ffmt != float_format ());
 
     bool do_NA_conv = (output_type == oct_data_conv::dt_double);
 
     switch (output_type)
@@ -6459,17 +6459,17 @@ namespace octave
 
     return retval;
   }
 
   octave_value
   stream::read (const Array<double>& size, octave_idx_type block_size,
                 oct_data_conv::data_type input_type,
                 oct_data_conv::data_type output_type,
-                octave_idx_type skip, octave::mach_info::float_format ffmt,
+                octave_idx_type skip, mach_info::float_format ffmt,
                 octave_idx_type& count)
   {
     octave_value retval;
 
     octave_idx_type nr = -1;
     octave_idx_type nc = -1;
 
     bool one_elt_size_spec = false;
@@ -6487,17 +6487,17 @@ namespace octave
     size_t char_count = 0;
 
     ptrdiff_t tmp_count = 0;
 
     try
       {
         get_size (size, nr, nc, one_elt_size_spec, "fread");
       }
-    catch (const octave::execution_exception&)
+    catch (const execution_exception&)
       {
         invalid_operation ("fread", "reading");
 
         return retval;
       }
 
     if (one_elt_size_spec)
       {
@@ -6655,25 +6655,25 @@ namespace octave
       }
 
     return retval;
   }
 
   octave_idx_type
   stream::write (const octave_value& data, octave_idx_type block_size,
                  oct_data_conv::data_type output_type,
-                 octave_idx_type skip, octave::mach_info::float_format flt_fmt)
+                 octave_idx_type skip, mach_info::float_format flt_fmt)
   {
     octave_idx_type retval = -1;
 
     if (! stream_ok ())
       invalid_operation ("fwrite", "writing");
     else
       {
-        if (flt_fmt == octave::mach_info::flt_fmt_unknown)
+        if (flt_fmt == mach_info::flt_fmt_unknown)
           flt_fmt = float_format ();
 
         octave_idx_type status = data.write (*this, block_size, output_type,
                                              skip, flt_fmt);
 
         if (status < 0)
           error ("fwrite: write error");
         else
@@ -6899,27 +6899,27 @@ namespace octave
     return status;
   }
 
   template <typename T>
   octave_idx_type
   stream::write (const Array<T>& data, octave_idx_type block_size,
                  oct_data_conv::data_type output_type,
                  octave_idx_type skip,
-                 octave::mach_info::float_format flt_fmt)
+                 mach_info::float_format flt_fmt)
   {
     bool swap = false;
 
-    if (octave::mach_info::words_big_endian ())
-      swap = (flt_fmt == octave::mach_info::flt_fmt_ieee_little_endian);
+    if (mach_info::words_big_endian ())
+      swap = (flt_fmt == mach_info::flt_fmt_ieee_little_endian);
     else
-      swap = (flt_fmt == octave::mach_info::flt_fmt_ieee_big_endian);
+      swap = (flt_fmt == mach_info::flt_fmt_ieee_big_endian);
 
     bool do_data_conversion = (swap || ! is_equivalent_type<T> (output_type)
-                               || flt_fmt != octave::mach_info::float_format ());
+                               || flt_fmt != mach_info::float_format ());
 
     octave_idx_type nel = data.numel ();
 
     octave_idx_type chunk_size;
 
     if (skip != 0)
       chunk_size = block_size;
     else if (do_data_conversion)
@@ -6972,17 +6972,17 @@ namespace octave
   }
 
 #define INSTANTIATE_WRITE(T)                                            \
   template                                                              \
   octave_idx_type                                                       \
   stream::write (const Array<T>& data, octave_idx_type block_size,      \
                  oct_data_conv::data_type output_type,                  \
                  octave_idx_type skip,                                  \
-                 octave::mach_info::float_format flt_fmt)
+                 mach_info::float_format flt_fmt)
 
     INSTANTIATE_WRITE (octave_int8);
   INSTANTIATE_WRITE (octave_uint8);
   INSTANTIATE_WRITE (octave_int16);
   INSTANTIATE_WRITE (octave_uint16);
   INSTANTIATE_WRITE (octave_int32);
   INSTANTIATE_WRITE (octave_uint32);
   INSTANTIATE_WRITE (octave_int64);
@@ -7189,20 +7189,20 @@ namespace octave
     int retval = 0;
 
     if (stream_ok ())
       retval = rep->mode ();
 
     return retval;
   }
 
-  octave::mach_info::float_format
+  mach_info::float_format
   stream::float_format (void) const
   {
-    octave::mach_info::float_format retval = octave::mach_info::flt_fmt_unknown;
+    mach_info::float_format retval = mach_info::flt_fmt_unknown;
 
     if (stream_ok ())
       retval = rep->float_format ();
 
     return retval;
   }
 
   std::string
@@ -7519,17 +7519,17 @@ namespace octave
         lookup_cache = iter;
       }
 
     if (! os.is_valid ())
       return retval;
 
     retval(0) = os.name ();
     retval(1) = stream::mode_as_string (os.mode ());
-    retval(2) = octave::mach_info::float_format_as_string (os.float_format ());
+    retval(2) = mach_info::float_format_as_string (os.float_format ());
 
     return retval;
   }
 
   string_vector
   stream_list::do_get_info (const octave_value& fid) const
   {
     int conv_err = 0;
@@ -7560,17 +7560,17 @@ namespace octave
             << std::setw (4) << fid_strm.first << "     "
           // reset necessary in addition to setiosflags since this is one stmt.
             << std::resetiosflags (std::ios::adjustfield)
             << std::setiosflags (std::ios::left)
             << std::setw (3)
             << stream::mode_as_string (os.mode ())
             << "  "
             << std::setw (9)
-            << octave::mach_info::float_format_as_string (os.float_format ())
+            << mach_info::float_format_as_string (os.float_format ())
             << "  "
             << os.name () << "\n";
       }
 
     buf << "\n";
 
     return buf.str ();
   }
diff --git a/libinterp/corefcn/sighandlers.cc b/libinterp/corefcn/sighandlers.cc
--- a/libinterp/corefcn/sighandlers.cc
+++ b/libinterp/corefcn/sighandlers.cc
@@ -72,17 +72,17 @@ namespace octave
   // Allow users to avoid writing octave-workspace for SIGHUP (sent by
   // closing gnome-terminal, for example).  Note that this variable has
   // no effect if Vcrash_dumps_octave_core is FALSE.
   static bool Vsighup_dumps_octave_core = true;
 
   // Similar to Vsighup_dumps_octave_core, but for SIGTERM signal.
   static bool Vsigterm_dumps_octave_core = true;
 
-  // List of signals we have caught since last call to octave::signal_handler.
+  // List of signals we have caught since last call to signal_handler.
   static bool *signals_caught = nullptr;
 
   // Forward declarations.
   static void user_terminate (int sig_number);
   static void user_abort (int sig_number);
 
   class
   base_interrupt_manager
@@ -168,35 +168,35 @@ namespace octave
         }
     }
 
     void do_user_terminate (int sig_number)
     {
       bool is_interrupt_thread = (GetCurrentThreadId () == thread_id);
 
       if (is_interrupt_thread)
-        octave::user_terminate (sig_number);
+        user_terminate (sig_number);
       else
         {
           SuspendThread (thread);
-          octave::user_terminate (sig_number);
+          user_terminate (sig_number);
           ResumeThread (thread);
         }
     }
 
     void do_user_abort (int sig_number)
     {
       bool is_interrupt_thread = (GetCurrentThreadId () == thread_id);
 
       if (is_interrupt_thread)
-        octave::user_abort (sig_number);
+        user_abort (sig_number);
       else
         {
           SuspendThread (thread);
-          octave::user_abort (sig_number);
+          user_abort (sig_number);
           ResumeThread (thread);
         }
     }
 
     void do_raise_sigint (void)
     {
       bool is_interrupt_thread = (GetCurrentThreadId () == thread_id);
 
@@ -241,22 +241,22 @@ namespace octave
 
     void do_jump_to_enclosing_context (void)
     {
       ::octave_jump_to_enclosing_context ();
     }
 
     void do_user_terminate (int sig_number)
     {
-      octave::user_terminate (sig_number);
+      user_terminate (sig_number);
     }
 
     void do_user_abort (int sig_number)
     {
-      octave::user_abort (sig_number);
+      user_abort (sig_number);
     }
 
     void do_raise_sigint (void)
     {
       octave_raise_wrapper (SIGINT);
     }
   };
 
@@ -344,17 +344,17 @@ namespace octave
               << octave_strsignal_wrapper (sig)
               << " -- stopping myself..." << std::endl;
 
     if (save_vars)
       dump_octave_core ();
 
     sysdep_cleanup ();
 
-    throw octave::exit_exception (1);
+    throw exit_exception (1);
   }
 
   // Called from octave_quit () to actually do something about the signals
   // we have caught.
 
   void
   signal_handler (void)
   {
@@ -477,26 +477,26 @@ namespace octave
       exit (1);
 
     if (can_interrupt)
       {
         if (Vdebug_on_interrupt)
           {
             if (! octave_debug_on_interrupt_state)
               {
-                octave::tree_evaluator::debug_mode = true;
+                tree_evaluator::debug_mode = true;
                 octave_debug_on_interrupt_state = true;
 
                 return;
               }
             else
               {
                 // Clear the flag and do normal interrupt stuff.
 
-                octave::tree_evaluator::debug_mode
+                tree_evaluator::debug_mode
                   = bp_table::have_breakpoints () || Vdebugging;
                 octave_debug_on_interrupt_state = false;
               }
           }
 
         if (octave_interrupt_immediately)
           {
             if (octave_interrupt_state == 0)
@@ -514,18 +514,18 @@ namespace octave
             // arrived.
 
             if (octave_interrupt_state < 0)
               octave_interrupt_state = 0;
 
             octave_signal_caught = 1;
             octave_interrupt_state++;
 
-            if (octave::application::interactive ()
-                && ! octave::application::forced_interactive ()
+            if (application::interactive ()
+                && ! application::forced_interactive ()
                 && octave_interrupt_state == 2)
               std::cerr << "Press Control-C again to abort." << std::endl;
 
             if (octave_interrupt_state >= 3)
               my_friendly_exit (sig_number, true);
           }
       }
   }
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -76,17 +76,17 @@ namespace octave
         assign (octave_value ());
       }
   }
 
   void
   symbol_table::symbol_record::symbol_record_rep::init_persistent (void)
   {
     symbol_table::scope *scope
-      = octave::__require_current_scope__ ("symbol_table::symbol_record::symbol_record_rep::init_persistent");
+      = __require_current_scope__ ("symbol_table::symbol_record::symbol_record_rep::init_persistent");
 
     if (! is_defined ())
       {
         mark_persistent ();
 
         assign (scope->persistent_varval (name));
       }
     // FIXME: this causes trouble with recursive calls.
@@ -95,17 +95,17 @@ namespace octave
   }
 
   void
   symbol_table::symbol_record::symbol_record_rep::erase_persistent (void)
   {
     unmark_persistent ();
 
     symbol_table::scope *scope
-      = octave::__require_current_scope__ ("symbol_table::symbol_record::symbol_record_rep::erase_persistent");
+      = __require_current_scope__ ("symbol_table::symbol_record::symbol_record_rep::erase_persistent");
 
     scope->erase_persistent (name);
   }
 
   symbol_table::symbol_record::symbol_record_rep *
   symbol_table::symbol_record::symbol_record_rep::dup (scope *new_scope) const
   {
     return new symbol_record_rep (new_scope, name, varval (), storage_class);
@@ -131,65 +131,65 @@ namespace octave
 
     return octave_value (m);
   }
 
   octave_value&
   symbol_table::symbol_record::symbol_record_rep::xglobal_varref (void)
   {
     symbol_table& symtab
-      = octave::__get_symbol_table__ ("symbol_table::symbol_record::symbol_record_rep::xglobal_varref");
+      = __get_symbol_table__ ("symbol_table::symbol_record::symbol_record_rep::xglobal_varref");
 
     symbol_table::global_symbols_iterator p
       = symtab.m_global_symbols.find (name);
 
     return (p == symtab.m_global_symbols.end ()
             ? symtab.m_global_symbols[name] : p->second);
   }
 
   octave_value&
   symbol_table::symbol_record::symbol_record_rep::xpersistent_varref (void)
   {
     symbol_table::scope *scope
-      = octave::__get_current_scope__ ("symbol_table::symbol_record::symbol_record_rep::xpersistent_varref");
+      = __get_current_scope__ ("symbol_table::symbol_record::symbol_record_rep::xpersistent_varref");
 
     return scope ? scope->persistent_varref (name) : dummy_octave_value;
   }
 
   octave_value
   symbol_table::symbol_record::symbol_record_rep::xglobal_varval (void) const
   {
     symbol_table& symtab
-      = octave::__get_symbol_table__ ("symbol_table::symbol_record::symbol_record_rep::xglobal_varval");
+      = __get_symbol_table__ ("symbol_table::symbol_record::symbol_record_rep::xglobal_varval");
 
     return symtab.global_varval (name);
   }
 
   octave_value
   symbol_table::symbol_record::symbol_record_rep::xpersistent_varval (void) const
   {
     symbol_table::scope *scope
-      = octave::__get_current_scope__ ("symbol_table::symbol_record::symbol_record_rep::xpersistent_varval");
+      = __get_current_scope__ ("symbol_table::symbol_record::symbol_record_rep::xpersistent_varval");
 
     return scope ? scope->persistent_varval (name) : octave_value ();
   }
 
   symbol_table::symbol_record::symbol_record (void)
-    : rep (new symbol_record_rep (octave::__get_current_scope__ ("symbol_record"),
+    : rep (new symbol_record_rep (__get_current_scope__ ("symbol_record"),
                                   "", octave_value (), local))
 
   { }
 
   octave_value
   symbol_table::symbol_record::find (const octave_value_list& args) const
   {
     octave_value retval;
 
     symbol_table& symtab
-      = octave::__get_symbol_table__ ("symbol_table::symbol_record::find");
+      = __get_symbol_table__ ("symbol_table::symbol_record::find");
 
     if (is_global ())
       retval = symtab.global_varval (name ());
     else
       {
         retval = varval ();
 
         if (retval.is_undefined ())
@@ -218,24 +218,24 @@ namespace octave
   }
 
   symbol_table::symbol_record
   symbol_table::dummy_symbol_record (static_cast<symbol_table::scope*> (nullptr));
 
   symbol_table::symbol_reference::symbol_reference (const symbol_record& record)
     : m_scope (0), m_context (0),m_sym (record)
   {
-    m_scope = octave::__get_current_scope__ ("symbol_reference");
+    m_scope = __get_current_scope__ ("symbol_reference");
   }
 
   void
   symbol_table::symbol_reference::update (void) const
   {
     symbol_table::scope *curr_scope
-      = octave::__get_current_scope__ ("symbol_reference::update");
+      = __get_current_scope__ ("symbol_reference::update");
 
     if (curr_scope && (m_scope != curr_scope || ! m_sym.is_valid ()))
       {
         m_scope = curr_scope;
         m_sym = m_scope->insert (m_sym.name ());  // ???
       }
 
     m_context = m_scope ? m_scope->current_context () : 0;
@@ -313,17 +313,17 @@ namespace octave
         // FIXME: we need to handle subfunctions properly here.
 
         if (! fcn->is_subfunction ())
           {
             std::string ff = fcn->fcn_file_name ();
 
             if (! ff.empty ())
               {
-                octave::sys::time tc = fcn->time_checked ();
+                sys::time tc = fcn->time_checked ();
 
                 bool relative = check_relative && fcn->is_relative ();
 
                 if (tc <= Vlast_prompt_time
                     || (relative && tc < Vlast_chdir_time))
                   {
                     bool clear_breakpoints = false;
                     std::string nm = fcn->name ();
@@ -334,43 +334,43 @@ namespace octave
 
                     std::string file;
                     std::string dir_name;
 
                     if (check_relative)
                       {
                         int nm_len = nm.length ();
 
-                        if (octave::sys::env::absolute_pathname (nm)
+                        if (sys::env::absolute_pathname (nm)
                             && ((nm_len > 4
                                  && (nm.substr (nm_len-4) == ".oct"
                                      || nm.substr (nm_len-4) == ".mex"))
                                 || (nm_len > 2
                                     && nm.substr (nm_len-2) == ".m")))
                           file = nm;
                         else
                           {
                             // We don't want to make this an absolute name,
                             // because load_fcn_file looks at the name to
                             // decide whether it came from a relative lookup.
 
                             if (! dispatch_type.empty ())
                               {
-                                octave::load_path& lp = octave::__get_load_path__ ("out_of_date_check");
+                                load_path& lp = __get_load_path__ ("out_of_date_check");
 
                                 file = lp.find_method (dispatch_type, nm,
                                                        dir_name, pack);
 
                                 if (file.empty ())
                                   {
                                     std::string s_name;
                                     std::string s_pack;
 
                                     symbol_table& symtab
-                                      = octave::__get_symbol_table__ ("out_of_date_check");
+                                      = __get_symbol_table__ ("out_of_date_check");
 
                                     const std::list<std::string>& plist
                                       = symtab.parent_classes (dispatch_type);
 
                                     std::list<std::string>::const_iterator it
                                       = plist.begin ();
 
                                     while (it != plist.end ())
@@ -388,21 +388,21 @@ namespace octave
 
                                         it++;
                                       }
                                   }
                               }
 
                             // Maybe it's an autoload?
                             if (file.empty ())
-                              file = octave::lookup_autoload (nm);
+                              file = lookup_autoload (nm);
 
                             if (file.empty ())
                               {
-                                octave::load_path& lp = octave::__get_load_path__ ("out_of_date_check");
+                                load_path& lp = __get_load_path__ ("out_of_date_check");
                                 file = lp.find_fcn (nm, dir_name, pack);
                               }
                           }
 
                         if (! file.empty ())
                           is_same_file = same_file (file, ff);
                       }
                     else
@@ -419,26 +419,26 @@ namespace octave
                         function = octave_value ();
 
                         clear_breakpoints = true;
                       }
                     else if (is_same_file)
                       {
                         // Same file.  If it is out of date, then reload it.
 
-                        octave::sys::time ottp = fcn->time_parsed ();
+                        sys::time ottp = fcn->time_parsed ();
                         time_t tp = ottp.unix_time ();
 
-                        fcn->mark_fcn_file_up_to_date (octave::sys::time ());
+                        fcn->mark_fcn_file_up_to_date (sys::time ());
 
                         if (! (Vignore_function_time_stamp == 2
                                || (Vignore_function_time_stamp
                                    && fcn->is_system_fcn_file ())))
                           {
-                            octave::sys::file_stat fs (ff);
+                            sys::file_stat fs (ff);
 
                             if (fs)
                               {
                                 if (fs.is_newer (tp))
                                   {
                                     retval = load_out_of_date_fcn (ff, dir_name,
                                                                    function,
                                                                    dispatch_type,
@@ -480,37 +480,37 @@ namespace octave
   }
 
   octave_value
   symbol_table::fcn_info::fcn_info_rep::load_private_function
   (const std::string& dir_name)
   {
     octave_value retval;
 
-    octave::load_path& lp
-      = octave::__get_load_path__ ("symbol_table::fcn_info::fcn_info_rep::load_private_function");
+    load_path& lp
+      = __get_load_path__ ("symbol_table::fcn_info::fcn_info_rep::load_private_function");
 
     std::string file_name = lp.find_private_fcn (dir_name, name);
 
     if (file_name.empty ())
       return retval;
 
-    octave_value ov_fcn = octave::load_fcn_from_file (file_name, dir_name);
+    octave_value ov_fcn = load_fcn_from_file (file_name, dir_name);
 
     if (ov_fcn.is_undefined ())
       return retval;
 
     octave_function *tmpfcn = ov_fcn.function_value ();
 
     if (! tmpfcn)
       return retval;
 
     std::string class_name;
 
-    size_t pos = dir_name.find_last_of (octave::sys::file_ops::dir_sep_chars ());
+    size_t pos = dir_name.find_last_of (sys::file_ops::dir_sep_chars ());
 
     if (pos != std::string::npos)
       {
         std::string tmp = dir_name.substr (pos+1);
 
         if (tmp[0] == '@')
           class_name = tmp.substr (1);
       }
@@ -524,25 +524,25 @@ namespace octave
 
   octave_value
   symbol_table::fcn_info::fcn_info_rep::load_class_constructor (void)
   {
     octave_value retval;
 
     std::string dir_name;
 
-    octave::load_path& lp
-      = octave::__get_load_path__ ("symbol_table::fcn_info::fcn_info_rep::load_class_constructor");
+    load_path& lp
+      = __get_load_path__ ("symbol_table::fcn_info::fcn_info_rep::load_class_constructor");
 
     std::string file_name = lp.find_method (name, name, dir_name, package_name);
 
     if (! file_name.empty ())
       {
         octave_value ov_fcn
-          = octave::load_fcn_from_file (file_name, dir_name, name,
+          = load_fcn_from_file (file_name, dir_name, name,
                                         package_name);
 
         if (ov_fcn.is_defined ())
           {
             // Note: ov_fcn may be an octave_classdef_meta object instead
             // of the actual constructor function.
 
             retval = ov_fcn;
@@ -587,36 +587,36 @@ namespace octave
   {
     octave_value retval;
 
     if (full_name () == dispatch_type)
       retval = load_class_constructor ();
     else
       {
         cdef_manager& cdm
-          = octave::__get_cdef_manager__ ("symbol_table::fcn_info::fcn_info_rep::load_class_method");
+          = __get_cdef_manager__ ("symbol_table::fcn_info::fcn_info_rep::load_class_method");
 
         octave_function *cm = cdm.find_method_symbol (name, dispatch_type);
 
         if (cm)
           retval = octave_value (cm);
 
         if (! retval.is_defined ())
           {
             std::string dir_name;
 
-            octave::load_path& lp = octave::__get_load_path__ ("symbol_table::fcn_info::fcn_info_rep::load_class_method");
+            load_path& lp = __get_load_path__ ("symbol_table::fcn_info::fcn_info_rep::load_class_method");
 
             std::string file_name = lp.find_method (dispatch_type, name,
                                                     dir_name);
 
             if (! file_name.empty ())
               {
                 octave_value ov_fcn
-                  = octave::load_fcn_from_file (file_name, dir_name,
+                  = load_fcn_from_file (file_name, dir_name,
                                                 dispatch_type);
 
                 if (ov_fcn.is_defined ())
                   {
                     octave_function *tmpfcn = ov_fcn.function_value ();
 
                     if (tmpfcn && tmpfcn->is_class_method (dispatch_type))
                       {
@@ -627,17 +627,17 @@ namespace octave
                   }
               }
 
             if (retval.is_undefined ())
               {
                 // Search parent classes
 
                 symbol_table& symtab
-                  = octave::__get_symbol_table__ ("symbol_table::fcn_info::fcn_info_rep::load_class_method");
+                  = __get_symbol_table__ ("symbol_table::fcn_info::fcn_info_rep::load_class_method");
 
                 const std::list<std::string>& plist =
                   symtab.parent_classes (dispatch_type);
 
                 std::list<std::string>::const_iterator it = plist.begin ();
 
                 while (it != plist.end ())
                   {
@@ -736,17 +736,17 @@ namespace octave
               }
           }
 
         if (builtin_type == btyp_unknown)
           {
             // There's a non-builtin class in the argument list.
             dispatch_type = args(i).class_name ();
 
-            symbol_table& symtab = octave::__get_symbol_table__ ("get_dispatch_type");
+            symbol_table& symtab = __get_symbol_table__ ("get_dispatch_type");
 
             for (int j = i+1; j < n; j++)
               {
                 octave_value arg = args(j);
 
                 if (arg.builtin_type () == btyp_unknown)
                   {
                     std::string cname = arg.class_name ();
@@ -795,34 +795,34 @@ namespace octave
     octave_value retval = xfind (args, local_funcs);
 
     if (retval.is_undefined ())
       {
         // It is possible that the user created a file on the fly since
         // the last prompt or chdir, so try updating the load path and
         // searching again.
 
-        octave::load_path& lp = octave::__get_load_path__ ("symbol_table::fcn_info::fcn_info_rep::find");
+        load_path& lp = __get_load_path__ ("symbol_table::fcn_info::fcn_info_rep::find");
 
         lp.update ();
 
         retval = xfind (args, local_funcs);
       }
 
     return retval;
   }
 
   octave_value
   symbol_table::fcn_info::fcn_info_rep::xfind (const octave_value_list& args,
                                                bool local_funcs)
   {
     if (local_funcs)
       {
         symbol_table::scope *scope
-          = octave::__get_current_scope__ ("symbol_table::fcn_info::fcn_info_rep::xfind");
+          = __get_current_scope__ ("symbol_table::fcn_info::fcn_info_rep::xfind");
 
         octave_user_function *current_fcn = scope ? scope->function () : 0;
 
         // Local function.
 
         if (current_fcn)
           {
             std::string fcn_file = current_fcn->fcn_file_name ();
@@ -977,17 +977,17 @@ namespace octave
     octave_value retval = x_builtin_find ();
 
     if (! retval.is_defined ())
       {
         // It is possible that the user created a file on the fly since
         // the last prompt or chdir, so try updating the load path and
         // searching again.
 
-        octave::load_path& lp = octave::__get_load_path__ ("symbol_table::fcn_info::fcn_info_rep::builtin_find");
+        load_path& lp = __get_load_path__ ("symbol_table::fcn_info::fcn_info_rep::builtin_find");
 
         lp.update ();
 
         retval = x_builtin_find ();
       }
 
     return retval;
   }
@@ -1016,17 +1016,17 @@ namespace octave
     // Command-line function.
 
     if (cmdline_function.is_defined ())
       return cmdline_function;
 
     // Private function.
 
     symbol_table::scope *scope
-      = octave::__get_current_scope__ ("symbol_table::fcn_info::fcn_info_rep::x_builtin_find");
+      = __get_current_scope__ ("symbol_table::fcn_info::fcn_info_rep::x_builtin_find");
 
     octave_user_function *current_fcn = scope ? scope->function () : 0;
 
     if (current_fcn)
       {
         std::string dir_name = current_fcn->dir_name ();
 
         if (! dir_name.empty ())
@@ -1081,17 +1081,17 @@ namespace octave
           }
       }
 
     // Subfunction.  I think it only makes sense to check for
     // subfunctions if we are currently executing a function defined
     // from a .m file.
 
     symbol_table::scope *curr_scope
-      = octave::__get_current_scope__ ("symbol_table::fcn_info::fcn_info_rep::x_builtin_find");
+      = __get_current_scope__ ("symbol_table::fcn_info::fcn_info_rep::x_builtin_find");
 
     if (curr_scope)
       {
         octave_value val = curr_scope->find_subfunction (name);
 
         if (val.is_defined ())
           return val;
       }
@@ -1140,26 +1140,26 @@ namespace octave
   {
     // Autoloaded function.
 
     if (autoload_function.is_defined ())
       out_of_date_check (autoload_function);
 
     if (! autoload_function.is_defined ())
       {
-        std::string file_name = octave::lookup_autoload (name);
+        std::string file_name = lookup_autoload (name);
 
         if (! file_name.empty ())
           {
-            size_t pos = file_name.find_last_of (octave::sys::file_ops::dir_sep_chars ());
+            size_t pos = file_name.find_last_of (sys::file_ops::dir_sep_chars ());
 
             std::string dir_name = file_name.substr (0, pos);
 
             octave_value ov_fcn
-              = octave::load_fcn_from_file (file_name, dir_name, "", "",
+              = load_fcn_from_file (file_name, dir_name, "", "",
                                             name, true);
 
             if (ov_fcn.is_defined ())
               autoload_function = octave_value (ov_fcn);
           }
       }
 
     return autoload_function;
@@ -1172,25 +1172,25 @@ namespace octave
 
     if (function_on_path.is_defined ())
       out_of_date_check (function_on_path);
 
     if (function_on_path.is_undefined ())
       {
         std::string dir_name;
 
-        octave::load_path& lp = octave::__get_load_path__ ("symbol_table::fcn_info::fcn_info_rep::find_user_function");
+        load_path& lp = __get_load_path__ ("symbol_table::fcn_info::fcn_info_rep::find_user_function");
 
 
         std::string file_name = lp.find_fcn (name, dir_name, package_name);
 
         if (! file_name.empty ())
           {
             octave_value ov_fcn
-              = octave::load_fcn_from_file (file_name, dir_name, "",
+              = load_fcn_from_file (file_name, dir_name, "",
                                             package_name);
 
             if (ov_fcn.is_defined ())
               function_on_path = ov_fcn;
           }
       }
 
     return function_on_path;
@@ -1201,17 +1201,17 @@ namespace octave
   {
     // FIXME: implement correct way to check out of date package
     //if (package.is_defined ())
     //  out_of_date_check (package);
 
     if (package.is_undefined ())
       {
         cdef_manager& cdm
-          = octave::__get_cdef_manager__ ("symbol_table::fcn_info::fcn_info_rep::find_package");
+          = __get_cdef_manager__ ("symbol_table::fcn_info::fcn_info_rep::find_package");
 
         octave_function *fcn = cdm.find_package_symbol (full_name ());
 
         if (fcn)
           package = octave_value (fcn);
       }
 
     return package;
@@ -1344,20 +1344,20 @@ namespace octave
                                const octave_value_list& args, bool local_funcs)
   {
     octave_value retval;
 
     if (! name.empty () && name[0] == '@')
       {
         // Look for a class specific function.
         std::string dispatch_type =
-          name.substr (1, name.find_first_of (octave::sys::file_ops::dir_sep_str ()) - 1);
+          name.substr (1, name.find_first_of (sys::file_ops::dir_sep_str ()) - 1);
 
         std::string method;
-        size_t pos = name.find_last_of (octave::sys::file_ops::dir_sep_str ());
+        size_t pos = name.find_last_of (sys::file_ops::dir_sep_str ());
         if (pos != std::string::npos)
           method = name.substr (pos + 1);
 
         retval = find_method (method, dispatch_type);
       }
     else
       {
         size_t pos = name.find_first_of (Vfilemarker);
@@ -1395,17 +1395,17 @@ namespace octave
   // look for @class/method>subfunction
   octave_value
   symbol_table::find_submethod (const std::string& name,
                                 const std::string& dispatch_type)
   {
     octave_value fcn;
 
     std::string full_name = "@" + dispatch_type +
-      octave::sys::file_ops::dir_sep_str () + name;
+      sys::file_ops::dir_sep_str () + name;
     size_t pos = full_name.find_first_of (Vfilemarker);
 
     if (pos != std::string::npos)
       {
         std::string fcn_scope = full_name.substr (0, pos);
         scope *stored_scope = m_current_scope;
         m_current_scope = m_top_scope;
         octave_value parent = find_function (full_name.substr (0, pos),
@@ -1498,17 +1498,17 @@ namespace octave
                              const octave_value_list& args,
                              bool skip_variables, bool local_funcs)
   {
     octave_value retval;
 
     // Variable.
 
     symbol_table& symtab
-      = octave::__get_symbol_table__ ("symbol_table::scope::find");
+      = __get_symbol_table__ ("symbol_table::scope::find");
 
     if (! skip_variables)
       {
         table_iterator p = m_symbols.find (name);
 
         if (p != m_symbols.end ())
           {
             symbol_record sr = p->second;
@@ -1557,17 +1557,17 @@ namespace octave
   }
 
   octave_value
   symbol_table::scope::builtin_find (const std::string& name)
   {
     octave_value retval;
 
     symbol_table& symtab
-      = octave::__get_symbol_table__ ("symbol_table::scope::find");
+      = __get_symbol_table__ ("symbol_table::scope::find");
 
     fcn_table_iterator p = symtab.m_fcn_table.find (name);
 
     if (p != symtab.m_fcn_table.end ())
       return p->second.builtin_find ();
     else
       {
         fcn_info finfo (name);
@@ -1615,17 +1615,17 @@ namespace octave
       {
         symbol_table::symbol_record& sr = p->second;
 
         if (sr.is_global ())
           sr.unmark_global ();
       }
 
     symbol_table& symtab
-      = octave::__get_symbol_table__ ("symbol_table::scope::clear_global");
+      = __get_symbol_table__ ("symbol_table::scope::clear_global");
 
     global_symbols_iterator q = symtab.m_global_symbols.find (name);
 
     if (q != symtab.m_global_symbols.end ())
       symtab.m_global_symbols.erase (q);
 
   }
 
@@ -1638,17 +1638,17 @@ namespace octave
       {
         symbol_table::symbol_record& sr = nm_sr.second;
 
         if (sr.is_global () && pattern.match (sr.name ()))
           sr.unmark_global ();
       }
 
     symbol_table& symtab
-      = octave::__get_symbol_table__ ("symbol_table::scope::clear_global_pattern");
+      = __get_symbol_table__ ("symbol_table::scope::clear_global_pattern");
 
     global_symbols_iterator q = symtab.m_global_symbols.begin ();
 
     while (q != symtab.m_global_symbols.end ())
       {
         if (pattern.match (q->first))
           symtab.m_global_symbols.erase (q++);
         else
diff --git a/libinterp/corefcn/symtab.h b/libinterp/corefcn/symtab.h
--- a/libinterp/corefcn/symtab.h
+++ b/libinterp/corefcn/symtab.h
@@ -299,17 +299,17 @@ namespace octave
         std::deque<octave_value> value_stack;
 
         unsigned int storage_class;
 
         //      fcn_info *finfo;
 
         bool valid;
 
-        octave::refcount<size_t> count;
+        refcount<size_t> count;
 
       private:
 
         octave_value& xglobal_varref (void);
 
         octave_value& xpersistent_varref (void);
 
         octave_value xglobal_varval (void) const;
@@ -732,17 +732,17 @@ namespace octave
         octave_value autoload_function;
 
         octave_value function_on_path;
 
         octave_value package;
 
         octave_value built_in_function;
 
-        octave::refcount<size_t> count;
+        refcount<size_t> count;
 
       private:
 
         octave_value xfind (const octave_value_list& args, bool local_funcs);
 
         octave_value x_builtin_find (void);
       };
 
diff --git a/libinterp/dldfcn/__ode15__.cc b/libinterp/dldfcn/__ode15__.cc
--- a/libinterp/dldfcn/__ode15__.cc
+++ b/libinterp/dldfcn/__ode15__.cc
@@ -649,25 +649,25 @@ namespace octave
 
     octave_value_list args = ovl (tsol, y, yp);
 
     // cont is the number of steps reached by the solver
     // temp is the number of events registered
 
     if (flag == "init")
       {
-        octave_value_list output = octave::feval (event_fcn, args, 3);
+        octave_value_list output = feval (event_fcn, args, 3);
         oldval = output(0).vector_value ();
         oldisterminal = output(1).vector_value ();
         olddir = output(2).vector_value ();
       }
     else if (flag == "")
       {
         ColumnVector index (0);
-        octave_value_list output = octave::feval (event_fcn, args, 3);
+        octave_value_list output = feval (event_fcn, args, 3);
         ColumnVector val = output(0).vector_value ();
         ColumnVector isterminal = output(1).vector_value ();
         ColumnVector dir = output(2).vector_value ();
 
         // Get the index of the changed values
         for (octave_idx_type i = 0; i < val.numel (); i++)
           {
             if ((val(i) > 0 && oldval(i) < 0 && dir(i) != -1) // increasing
@@ -829,28 +829,28 @@ namespace octave
 
     if (flag == "init")
       {
         ColumnVector toutput(2);
         toutput(0) = tsol;
         toutput(1) = tend;
         output(0) = toutput;
 
-        octave::feval (output_fcn, output, 0);
+        feval (output_fcn, output, 0);
       }
     else if (flag == "")
       {
         output(0) = tsol;
-        octave_value_list val = octave::feval (output_fcn, output, 1);
+        octave_value_list val = feval (output_fcn, output, 1);
         status = val(0).bool_value ();
       }
     else
       {  // Cleanup plotter
         output(0) = tend;
-        octave::feval (output_fcn, output, 0);
+        feval (output_fcn, output, 0);
       }
 
     return status;
   }
 
   void
   IDA::set_maxstep (realtype maxstep)
   {
@@ -897,55 +897,55 @@ namespace octave
   ColumnVector
   ida_user_function (const ColumnVector& x, const ColumnVector& xdot,
                      double t, octave_function *ida_fc)
   {
     octave_value_list tmp;
 
     try
       {
-        tmp = octave::feval (ida_fc, ovl (t, x, xdot), 1);
+        tmp = feval (ida_fc, ovl (t, x, xdot), 1);
       }
-    catch (octave::execution_exception& e)
+    catch (execution_exception& e)
       {
         err_user_supplied_eval (e, "__ode15__");
       }
 
     return tmp(0).vector_value ();
   }
 
   Matrix
   ida_dense_jac (const ColumnVector& x, const ColumnVector& xdot,
                  double t, double cj, octave_function *ida_jc)
   {
     octave_value_list tmp;
 
     try
       {
-        tmp = octave::feval (ida_jc, ovl (t, x, xdot), 2);
+        tmp = feval (ida_jc, ovl (t, x, xdot), 2);
       }
-    catch (octave::execution_exception& e)
+    catch (execution_exception& e)
       {
         err_user_supplied_eval (e, "__ode15__");
       }
 
     return tmp(0).matrix_value () + cj * tmp(1).matrix_value ();
   }
 
   SparseMatrix
   ida_sparse_jac (const ColumnVector& x, const ColumnVector& xdot,
                   double t, double cj, octave_function *ida_jc)
   {
     octave_value_list tmp;
 
     try
       {
-        tmp = octave::feval (ida_jc, ovl (t, x, xdot), 2);
+        tmp = feval (ida_jc, ovl (t, x, xdot), 2);
       }
-    catch (octave::execution_exception& e)
+    catch (execution_exception& e)
       {
         err_user_supplied_eval (e, "__ode15__");
       }
 
     return tmp(0).sparse_matrix_value () + cj * tmp(1).sparse_matrix_value ();
   }
 
   Matrix
diff --git a/libinterp/dldfcn/gzip.cc b/libinterp/dldfcn/gzip.cc
--- a/libinterp/dldfcn/gzip.cc
+++ b/libinterp/dldfcn/gzip.cc
@@ -279,19 +279,19 @@ namespace octave
 
     class gzip_header : public gz_header
     {
     public:
 
       gzip_header (void) = delete;
 
       gzip_header (const std::string& source_path)
-        : m_basename (octave::sys::env::base_pathname (source_path))
+        : m_basename (sys::env::base_pathname (source_path))
       {
-        const octave::sys::file_stat source_stat (source_path);
+        const sys::file_stat source_stat (source_path);
         if (! source_stat)
           throw std::runtime_error ("unable to stat source file");
 
         // time_t may be a signed int in which case it will be a
         // positive number so it is safe to uLong.  Or is it?  Can
         // unix_time really never be negative?
         time = uLong (source_stat.mtime ().unix_time ());
 
@@ -475,30 +475,30 @@ namespace octave
   xzip (const Array<std::string>& source_patterns,
         const std::function<std::string(const std::string&)>& mk_dest_path)
   {
     std::list<std::string> dest_paths;
 
     std::function<void(const std::string&)> walk;
     walk = [&walk, &mk_dest_path, &dest_paths] (const std::string& path) -> void
     {
-      const octave::sys::file_stat fs (path);
+      const sys::file_stat fs (path);
       // is_dir and is_reg will return false if failed to stat.
       if (fs.is_dir ())
         {
-          octave::sys::dir_entry dir (path);
+          sys::dir_entry dir (path);
           if (dir)
             {
               // Collect the whole list of filenames first, before recursion
               // to avoid issues with infinite loop if the action generates
               // files in the same directory (highly likely).
               string_vector dirlist = dir.read ();
               for (octave_idx_type i = 0; i < dirlist.numel (); i++)
                 if (dirlist(i) != "." && dirlist(i) != "..")
-                  walk (octave::sys::file_ops::concat (path, dirlist(i)));
+                  walk (sys::file_ops::concat (path, dirlist(i)));
             }
           // Note that we skip any problem with directories.
         }
       else if (fs.is_reg ())
         {
           const std::string dest_path = mk_dest_path (path);
           try
             {
@@ -506,28 +506,28 @@ namespace octave
             }
           catch (...)
             {
               // Error "handling" is not including filename on the output list.
               // Also remove created file which maybe was not even created
               // in the first place.  Note that it is possible for the file
               // to exist in the first place and for X::zip to not have
               // clobber it yet but we remove it anyway by design.
-              octave::sys::unlink (dest_path);
+              sys::unlink (dest_path);
               return;
             }
           dest_paths.push_front (dest_path);
         }
       // Skip all other file types and errors.
       return;
     };
 
     for (octave_idx_type i = 0; i < source_patterns.numel (); i++)
       {
-        const glob_match pattern (octave::sys::file_ops::tilde_expand (source_patterns(i)));
+        const glob_match pattern (sys::file_ops::tilde_expand (source_patterns(i)));
         const string_vector filepaths = pattern.glob ();
         for (octave_idx_type j = 0; j < filepaths.numel (); j++)
           walk (filepaths(j));
       }
     return string_vector (dest_paths);
   }
 
 
@@ -547,25 +547,25 @@ namespace octave
   template<typename X>
   string_vector
   xzip (const Array<std::string>& source_patterns, const std::string& out_dir)
   {
     const std::string ext = X::extension;
     const std::function<std::string(const std::string&)> mk_dest_path
       = [&out_dir, &ext] (const std::string& source_path) -> std::string
       {
-        const std::string basename = octave::sys::env::base_pathname (source_path);
-        return octave::sys::file_ops::concat (out_dir, basename + ext);
+        const std::string basename = sys::env::base_pathname (source_path);
+        return sys::file_ops::concat (out_dir, basename + ext);
       };
 
     // We don't care if mkdir fails.  Maybe it failed because it already
     // exists, or maybe it can't bre created.  If the first, then there's
     // nothing to do, if the later, then it will be handled later.  Any
     // is to be handled by not listing files in the output.
-    octave::sys::mkdir (out_dir, 0777);
+    sys::mkdir (out_dir, 0777);
     return xzip<X> (source_patterns, mk_dest_path);
   }
 
   template<typename X>
   static octave_value_list
   xzip (const std::string& func_name, const octave_value_list& args)
   {
     const octave_idx_type nargin = args.length ();
diff --git a/libinterp/octave.cc b/libinterp/octave.cc
--- a/libinterp/octave.cc
+++ b/libinterp/octave.cc
@@ -312,17 +312,17 @@ namespace octave
     init ();
   }
 
   void
   application::set_program_names (const std::string& pname)
   {
     m_program_invocation_name = pname;
 
-    size_t pos = pname.find_last_of (octave::sys::file_ops::dir_sep_chars ());
+    size_t pos = pname.find_last_of (sys::file_ops::dir_sep_chars ());
 
     m_program_name = (pos != std::string::npos) ? pname.substr (pos+1) : pname;
   }
 
   void
   application::intern_argv (const string_vector& args)
   {
     octave_idx_type nargs = args.numel ();
diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -2104,17 +2104,17 @@ namespace octave
   }
 
   symbol_table::scope *
   lexical_feedback::symbol_table_context::curr_scope (void) const
   {
     if (empty ())
       {
         symbol_table::scope *scope
-          = octave::__get_current_scope__ ("lexical_feedback::symbol_table_context::curr_scope");
+          = __get_current_scope__ ("lexical_feedback::symbol_table_context::curr_scope");
 
         return scope;
       }
     else
       return frame_stack.front ();
   }
 
   symbol_table::scope *
@@ -2376,17 +2376,17 @@ namespace octave
     symtab_context.clear ();
 
     // We do want a prompt by default.
     promptflag (1);
 
     // Only ask for input from stdin if we are expecting interactive
     // input.
 
-    if (octave::application::interactive ()
+    if (application::interactive ()
         && ! (reading_fcn_file
               || reading_classdef_file
               || reading_script_file
               || input_from_eval_string ()))
       yyrestart (stdin, scanner);
 
     lexical_feedback::reset ();
 
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -2432,17 +2432,17 @@ namespace octave
 
   tree_expression *
   base_parser::make_colon_expression (tree_expression *base,
                                       tree_expression *limit,
                                       tree_expression *incr)
   {
     tree_expression *retval = nullptr;
 
-    octave::unwind_protect frame;
+    unwind_protect frame;
 
     frame.protect_var (discard_error_messages);
     frame.protect_var (discard_warning_messages);
 
     discard_error_messages = true;
     discard_warning_messages = true;
 
     if (! base || ! limit)
@@ -2460,17 +2460,17 @@ namespace octave
     tree_colon_expression *e
       = new tree_colon_expression (base, limit, incr, l, c);
 
     if (base->is_constant () && limit->is_constant ()
         && (! incr || (incr && incr->is_constant ())))
       {
         try
           {
-            octave::tree_evaluator& tw
+            tree_evaluator& tw
               = __get_evaluator__ ("finish_colon_expression");
 
             octave_value tmp = tw.evaluate (e);
 
             tree_constant *tc_retval
               = new tree_constant (tmp, e->line (), e->column ());
 
             std::ostringstream buf;
@@ -2480,19 +2480,19 @@ namespace octave
             e->accept (tpc);
 
             tc_retval->stash_original_text (buf.str ());
 
             delete e;
 
             retval = tc_retval;
           }
-        catch (const octave::execution_exception&)
+        catch (const execution_exception&)
           {
-            octave::interpreter::recover_from_exception ();
+            interpreter::recover_from_exception ();
           }
       }
     else
       retval = e;
 
     return retval;
   }
 
@@ -3210,17 +3210,17 @@ namespace octave
 
     octave_user_script *script
       = new octave_user_script (m_lexer.fcn_file_full_name,
                                 m_lexer.fcn_file_name,
                                 cmds, m_lexer.help_text);
 
     m_lexer.help_text = "";
 
-    octave::sys::time now;
+    sys::time now;
 
     script->stash_fcn_file_time (now);
 
     m_primary_fcn_ptr = script;
   }
 
   // Define a function.
 
@@ -3300,17 +3300,17 @@ namespace octave
         && m_curr_fcn_depth == 1 && ! m_parsing_subfunctions)
       {
         // FIXME: should m_lexer.fcn_file_name already be
         // preprocessed when we get here?  It seems to only be a
         // problem with relative filenames.
 
         std::string nm = m_lexer.fcn_file_name;
 
-        size_t pos = nm.find_last_of (octave::sys::file_ops::dir_sep_chars ());
+        size_t pos = nm.find_last_of (sys::file_ops::dir_sep_chars ());
 
         if (pos != std::string::npos)
           nm = m_lexer.fcn_file_name.substr (pos+1);
 
         if (nm != id_name)
           {
             warning_with_id
               ("Octave:function-name-clash",
@@ -3318,17 +3318,17 @@ namespace octave
                id_name.c_str (), m_lexer.fcn_file_full_name.c_str ());
 
             id_name = nm;
           }
       }
 
     if (m_lexer.reading_fcn_file || m_lexer.reading_classdef_file || m_autoloading)
       {
-        octave::sys::time now;
+        sys::time now;
 
         fcn->stash_fcn_file_name (m_lexer.fcn_file_full_name);
         fcn->stash_fcn_file_time (now);
         fcn->stash_dir_name (m_lexer.dir_name);
         fcn->stash_package_name (m_lexer.package_name);
         fcn->mark_as_system_fcn_file ();
 
         if (m_fcn_file_from_relative_lookup)
@@ -3351,17 +3351,17 @@ namespace octave
             else
               fcn->mark_as_class_method ();
 
             fcn->stash_dispatch_class (m_curr_class_name);
           }
 
         std::string nm = fcn->fcn_file_name ();
 
-        octave::sys::file_stat fs (nm);
+        sys::file_stat fs (nm);
 
         if (fs && fs.is_newer (now))
           warning_with_id ("Octave:future-time-stamp",
                            "time stamp for '%s' is in the future", nm.c_str ());
       }
     else if (! input_from_tmp_history_file
              && ! m_lexer.force_script
              && m_lexer.reading_script_file
@@ -3410,17 +3410,17 @@ namespace octave
         std::string nm = fcn->name ();
         std::string file = fcn->fcn_file_name ();
 
         std::string tmp = nm;
         if (! file.empty ())
           tmp += ": " + file;
 
         symbol_table& symtab
-          = octave::__get_symbol_table__ ("base_parser::finish_function");
+          = __get_symbol_table__ ("base_parser::finish_function");
 
 
         symbol_table::scope *fcn_scope = fcn->scope ();
         fcn_scope->cache_name (tmp);
 
         if (lc)
           fcn->stash_leading_comment (lc);
 
@@ -3494,33 +3494,33 @@ namespace octave
                                     const std::string& class_nm)
   {
     octave_value_list args;
 
     args(1) = class_nm;
     args(0) = method_nm;
 
     symbol_table& symtab
-      = octave::__get_symbol_table__ ("base_parser::make_superclass_ref");
+      = __get_symbol_table__ ("base_parser::make_superclass_ref");
 
     octave_value fcn
       = symtab.find_built_in_function ("__superclass_reference__");
 
     return new tree_funcall (fcn, args);
   }
 
   tree_funcall *
   base_parser::make_meta_class_query (const std::string& class_nm)
   {
     octave_value_list args;
 
     args(0) = class_nm;
 
     symbol_table& symtab
-      = octave::__get_symbol_table__ ("base_parser::make_meta_class_query");
+      = __get_symbol_table__ ("base_parser::make_meta_class_query");
 
     octave_value fcn
       = symtab.find_built_in_function ("__meta_class_query__");
 
     return new tree_funcall (fcn, args);
   }
 
   // A CLASSDEF block defines a class that has a constructor and other
@@ -3540,17 +3540,17 @@ namespace octave
     tree_classdef *retval = 0;
 
     m_lexer.symtab_context.pop ();
 
     std::string cls_name = id->name ();
 
     std::string nm = m_lexer.fcn_file_name;
 
-    size_t pos = nm.find_last_of (octave::sys::file_ops::dir_sep_chars ());
+    size_t pos = nm.find_last_of (sys::file_ops::dir_sep_chars ());
 
     if (pos != std::string::npos)
       nm = m_lexer.fcn_file_name.substr (pos+1);
 
     if (nm != cls_name)
       {
         delete a;
         delete id;
@@ -4015,17 +4015,17 @@ namespace octave
 
   tree_argument_list *
   base_parser::validate_matrix_for_assignment (tree_expression *e)
   {
     tree_argument_list *retval = 0;
 
     if (e->is_constant ())
       {
-        octave::tree_evaluator& tw
+        tree_evaluator& tw
           = __get_evaluator__ ("validate_matrix_for_assignment");
 
         octave_value ov = tw.evaluate (e);
 
         delete e;
 
         if (ov.isempty ())
           bison_error ("invalid empty left hand side of assignment");
@@ -4074,29 +4074,29 @@ namespace octave
 
   // Finish building an array_list.
 
   tree_expression *
   base_parser::finish_array_list (tree_array_list *array_list)
   {
     tree_expression *retval = array_list;
 
-    octave::unwind_protect frame;
+    unwind_protect frame;
 
     frame.protect_var (discard_error_messages);
     frame.protect_var (discard_warning_messages);
 
     discard_error_messages = true;
     discard_warning_messages = true;
 
     if (array_list->all_elements_are_constant ())
       {
         try
           {
-            octave::tree_evaluator& tw
+            tree_evaluator& tw
               = __get_evaluator__ ("finish_array_list");
 
             octave_value tmp = tw.evaluate (array_list);
 
             tree_constant *tc_retval
               = new tree_constant (tmp, array_list->line (),
                                    array_list->column ());
 
@@ -4107,19 +4107,19 @@ namespace octave
             array_list->accept (tpc);
 
             tc_retval->stash_original_text (buf.str ());
 
             delete array_list;
 
             retval = tc_retval;
           }
-        catch (const octave::execution_exception&)
+        catch (const execution_exception&)
           {
-            octave::interpreter::recover_from_exception ();
+            interpreter::recover_from_exception ();
           }
       }
 
     return retval;
   }
 
   // Finish building a matrix list.
 
@@ -4274,30 +4274,30 @@ namespace octave
     int status = -1;
 
     yypstate *pstate = static_cast<yypstate *> (m_parser_state);
 
     try
       {
         status = octave_pull_parse (pstate, *this);
       }
-    catch (octave::execution_exception& e)
+    catch (execution_exception& e)
       {
         std::string file = m_lexer.fcn_file_full_name;
 
         if (file.empty ())
           error (e, "parse error");
         else
           error (e, "parse error in %s", file.c_str ());
       }
-    catch (const octave::exit_exception&)
+    catch (const exit_exception&)
       {
         throw;
       }
-    catch (octave::interrupt_exception &)
+    catch (interrupt_exception &)
       {
         throw;
       }
     catch (...)
       {
         std::string file = m_lexer.fcn_file_full_name;
 
         if (file.empty ())
@@ -4338,30 +4338,30 @@ namespace octave
           }
 
         yypstate *pstate = static_cast<yypstate *> (m_parser_state);
 
         try
           {
             status = octave_push_parse (pstate, token, &lval, *this);
           }
-        catch (octave::execution_exception& e)
+        catch (execution_exception& e)
           {
             std::string file = m_lexer.fcn_file_full_name;
 
             if (file.empty ())
               error (e, "parse error");
             else
               error (e, "parse error in %s", file.c_str ());
           }
-        catch (const octave::exit_exception&)
+        catch (const exit_exception&)
           {
             throw;
           }
-        catch (octave::interrupt_exception &)
+        catch (interrupt_exception &)
           {
             throw;
           }
         catch (...)
           {
             std::string file = m_lexer.fcn_file_full_name;
 
             if (file.empty ())
@@ -4505,20 +4505,20 @@ namespace octave
     std::string file = full_file;
 
     size_t file_len = file.length ();
 
     if ((file_len > 4 && file.substr (file_len-4) == ".oct")
         || (file_len > 4 && file.substr (file_len-4) == ".mex")
         || (file_len > 2 && file.substr (file_len-2) == ".m"))
       {
-        file = octave::sys::env::base_pathname (file);
+        file = sys::env::base_pathname (file);
         file = file.substr (0, file.find_last_of ('.'));
 
-        size_t pos = file.find_last_of (octave::sys::file_ops::dir_sep_str ());
+        size_t pos = file.find_last_of (sys::file_ops::dir_sep_str ());
         if (pos != std::string::npos)
           file = file.substr (pos+1);
       }
 
     if (! file.empty ())
       {
         symbol_found = true;
 
@@ -4551,17 +4551,17 @@ namespace octave
     std::string retval;
 
     typedef std::map<std::string, std::string>::const_iterator am_iter;
 
     am_iter p = autoload_map.find (nm);
 
     if (p != autoload_map.end ())
       {
-        load_path& lp = octave::__get_load_path__ ("lookup_autoload");
+        load_path& lp = __get_load_path__ ("lookup_autoload");
 
         retval = lp.find_file (p->second);
       }
 
     return retval;
   }
 
   string_vector
@@ -4592,47 +4592,47 @@ namespace octave
   load_fcn_from_file (const std::string& file_name,
                       const std::string& dir_name,
                       const std::string& dispatch_type,
                       const std::string& package_name,
                       const std::string& fcn_name, bool autoload)
   {
     octave_value retval;
 
-    octave::unwind_protect frame;
+    unwind_protect frame;
 
     std::string nm = file_name;
 
     size_t nm_len = nm.length ();
 
     std::string file;
 
     bool relative_lookup = false;
 
     file = nm;
 
     if ((nm_len > 4 && nm.substr (nm_len-4) == ".oct")
         || (nm_len > 4 && nm.substr (nm_len-4) == ".mex")
         || (nm_len > 2 && nm.substr (nm_len-2) == ".m"))
       {
-        nm = octave::sys::env::base_pathname (file);
+        nm = sys::env::base_pathname (file);
         nm = nm.substr (0, nm.find_last_of ('.'));
 
-        size_t pos = nm.find_last_of (octave::sys::file_ops::dir_sep_str ());
+        size_t pos = nm.find_last_of (sys::file_ops::dir_sep_str ());
         if (pos != std::string::npos)
           nm = nm.substr (pos+1);
       }
 
-    relative_lookup = ! octave::sys::env::absolute_pathname (file);
-
-    file = octave::sys::env::make_absolute (file);
+    relative_lookup = ! sys::env::absolute_pathname (file);
+
+    file = sys::env::make_absolute (file);
 
     int len = file.length ();
 
-      octave::dynamic_loader& dyn_loader
+      dynamic_loader& dyn_loader
         = __get_dynamic_loader__ ("~octave_mex_function");
 
     if (len > 4 && file.substr (len-4, len-1) == ".oct")
       {
         if (autoload && ! fcn_name.empty ())
           nm = fcn_name;
 
         octave_function *tmpfcn
@@ -4841,73 +4841,73 @@ namespace octave
     //
     //   source ("foo1.m")
     //
     // (for example).
 
     static std::map<std::string, int> source_call_depth;
 
     std::string file_full_name
-      = octave::sys::file_ops::tilde_expand (file_name);
+      = sys::file_ops::tilde_expand (file_name);
 
     size_t pos
-      = file_full_name.find_last_of (octave::sys::file_ops::dir_sep_str ());
+      = file_full_name.find_last_of (sys::file_ops::dir_sep_str ());
 
     std::string dir_name = file_full_name.substr (0, pos);
 
-    file_full_name = octave::sys::env::make_absolute (file_full_name);
-
-    octave::unwind_protect frame;
+    file_full_name = sys::env::make_absolute (file_full_name);
+
+    unwind_protect frame;
 
     if (source_call_depth.find (file_full_name) == source_call_depth.end ())
       source_call_depth[file_full_name] = -1;
 
     frame.protect_var (source_call_depth[file_full_name]);
 
     source_call_depth[file_full_name]++;
 
     if (source_call_depth[file_full_name] >= Vmax_recursion_depth)
       error ("max_recursion_depth exceeded");
 
     if (! context.empty ())
       {
-        octave::call_stack& cs = octave::__get_call_stack__ ("source_file");
+        call_stack& cs = __get_call_stack__ ("source_file");
 
         if (context == "caller")
           cs.goto_caller_frame ();
         else if (context == "base")
           cs.goto_base_frame ();
         else
           error ("source: context must be \"caller\" or \"base\"");
 
-        frame.add_method (cs, &octave::call_stack::pop);
+        frame.add_method (cs, &call_stack::pop);
       }
 
     // Find symbol name that would be in symbol_table, if it were loaded.
     size_t dir_end
-      = file_name.find_last_of (octave::sys::file_ops::dir_sep_chars ());
+      = file_name.find_last_of (sys::file_ops::dir_sep_chars ());
     dir_end = (dir_end == std::string::npos) ? 0 : dir_end + 1;
 
     size_t extension = file_name.find_last_of ('.');
     if (extension == std::string::npos)
       extension = file_name.length ();
 
     std::string symbol = file_name.substr (dir_end, extension - dir_end);
-    std::string full_name = octave::sys::canonicalize_file_name (file_name);
+    std::string full_name = sys::canonicalize_file_name (file_name);
 
     // Check if this file is already loaded (or in the path)
-    symbol_table& symtab = octave::__get_symbol_table__ ("source_file");
+    symbol_table& symtab = __get_symbol_table__ ("source_file");
     octave_value ov_code = symtab.find (symbol);
 
     if (ov_code.is_user_script ())
       {
         octave_user_script *script = ov_code.user_script_value ();
 
         if (! script
-            || (octave::sys::canonicalize_file_name (script->fcn_file_name ())
+            || (sys::canonicalize_file_name (script->fcn_file_name ())
                 != full_name))
           {
             // Wrong file, so load it below.
             ov_code = octave_value ();
           }
       }
     else
       {
@@ -4921,17 +4921,17 @@ namespace octave
     if (ov_code.is_undefined ())
       {
         try
           {
             ov_code = parse_fcn_file (file_full_name, file_name, dir_name,
                                       "", "", require_file, true, false,
                                       false, warn_for);
           }
-        catch (octave::execution_exception& e)
+        catch (execution_exception& e)
           {
             error (e, "source: error sourcing file '%s'",
                    file_full_name.c_str ());
           }
       }
 
     // Return or error if we don't have a valid script
     if (ov_code.is_undefined ())
@@ -5068,17 +5068,17 @@ namespace octave
     necessarily the same as @c nargout.
 
   */
   octave_value_list
   feval (const std::string& name, const octave_value_list& args, int nargout)
   {
     octave_value_list retval;
 
-    symbol_table& symtab = octave::__get_symbol_table__ ("feval");
+    symbol_table& symtab = __get_symbol_table__ ("feval");
 
     octave_value fcn = symtab.find_function (name, args);
 
     if (fcn.is_defined ())
       {
         tree_evaluator& tw = __get_evaluator__ ("feval");
 
         octave_function *of = fcn.function_value ();
@@ -5106,31 +5106,31 @@ namespace octave
     return retval;
   }
 
   octave_value_list
   feval (octave_value& val, const octave_value_list& args, int nargout)
   {
     if (val.is_function ())
       {
-        return octave::feval (val.function_value (), args, nargout);
+        return feval (val.function_value (), args, nargout);
       }
     else if (val.is_function_handle ())
       {
         // This covers function handles, inline functions, and anonymous
         //  functions.
 
         std::list<octave_value_list> arg_list;
         arg_list.push_back (args);
 
         return val.subsref ("(", arg_list, nargout);
       }
     else if (val.is_string ())
       {
-        return octave::feval (val.string_value (), args, nargout);
+        return feval (val.string_value (), args, nargout);
       }
     else
       error ("feval: first argument must be a string, inline function, or a function handle");
 
     return ovl ();
   }
 }
 
@@ -5158,17 +5158,17 @@ namespace octave
   feval (const octave_value_list& args, int nargout)
   {
     if (args.length () > 0)
       {
         octave_value f_arg = args(0);
 
         octave_value_list tmp_args = get_feval_args (args);
 
-        return octave::feval (f_arg, tmp_args, nargout);
+        return feval (f_arg, tmp_args, nargout);
       }
     else
       error ("feval: first argument must be a string, inline function, or a function handle");
 
     return ovl ();
   }
 }
 
@@ -5266,31 +5266,31 @@ builtin ("sin", 0)
 namespace octave
 {
   octave_value_list
   eval_string (const std::string& eval_str, bool silent,
                int& parse_status, int nargout)
   {
     octave_value_list retval;
 
-    octave::parser parser (eval_str);
+    parser parser (eval_str);
 
     do
       {
         parser.reset ();
 
         parse_status = parser.run ();
 
         if (parse_status == 0)
           {
             if (parser.m_stmt_list)
               {
                 tree_statement *stmt = 0;
 
-                octave::tree_evaluator& tw = __get_evaluator__ ("eval_string");
+                tree_evaluator& tw = __get_evaluator__ ("eval_string");
 
                 if (parser.m_stmt_list->length () == 1
                     && (stmt = parser.m_stmt_list->front ())
                     && stmt->is_expression ())
                   {
                     tree_expression *expr = stmt->expression ();
 
                     if (silent)
diff --git a/libinterp/parse-tree/parse.h b/libinterp/parse-tree/parse.h
--- a/libinterp/parse-tree/parse.h
+++ b/libinterp/parse-tree/parse.h
@@ -478,28 +478,28 @@ namespace octave
     void *m_parser_state;
   };
 
   class parser : public base_parser
   {
   public:
 
     parser (void)
-      : base_parser (*(new octave::lexer ()))
+      : base_parser (*(new lexer ()))
     { }
 
     parser (FILE *file)
-      : base_parser (*(new octave::lexer (file)))
+      : base_parser (*(new lexer (file)))
     { }
 
     parser (const std::string& eval_string)
-      : base_parser (*(new octave::lexer (eval_string)))
+      : base_parser (*(new lexer (eval_string)))
     { }
 
-    parser (octave::lexer& lxr)
+    parser (lexer& lxr)
       : base_parser (lxr)
     { }
 
     // No copying!
 
     parser (const parser&) = delete;
 
     parser& operator = (const parser&) = delete;
@@ -509,17 +509,17 @@ namespace octave
     int run (void);
   };
 
   class push_parser : public base_parser
   {
   public:
 
     push_parser (void)
-      : base_parser (*(new octave::push_lexer ()))
+      : base_parser (*(new push_lexer ()))
     { }
 
     // No copying!
 
     push_parser (const push_parser&) = delete;
 
     push_parser& operator = (const push_parser&) = delete;
 
@@ -578,17 +578,17 @@ namespace octave
 
   extern OCTINTERP_API octave_value_list
   eval_string (const std::string&, bool silent, int& parse_status, int nargout);
 
   extern OCTINTERP_API octave_value
   eval_string (const std::string&, bool silent, int& parse_status);
 
   extern OCTINTERP_API void
-  cleanup_statement_list (octave::tree_statement_list **lst);
+  cleanup_statement_list (tree_statement_list **lst);
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED (4.4, "use 'octave::get_help_from_file' instead")
 static inline std::string
 get_help_from_file (const std::string& nm, bool& symbol_found,
                     std::string& file)
diff --git a/libinterp/parse-tree/pt-arg-list.cc b/libinterp/parse-tree/pt-arg-list.cc
--- a/libinterp/parse-tree/pt-arg-list.cc
+++ b/libinterp/parse-tree/pt-arg-list.cc
@@ -69,17 +69,17 @@ namespace octave
       }
 
     return false;
   }
 
   void
   tree_argument_list::append (const element_type& s)
   {
-    octave::base_list<tree_expression *>::append (s);
+    base_list<tree_expression *>::append (s);
 
     if (! list_includes_magic_end && s && s->has_magic_end ())
       list_includes_magic_end = true;
 
     if (! list_includes_magic_tilde && s && s->is_identifier ())
       {
         tree_identifier *id = dynamic_cast<tree_identifier *> (s);
         list_includes_magic_tilde = id && id->is_black_hole ();
@@ -211,17 +211,17 @@ namespace octave
     // END doesn't make sense for functions.  Maybe we need a different
     // way of asking an octave_value object this question?
 
     bool stash_object = (list_includes_magic_end
                          && object
                          && ! (object->is_function ()
                                || object->is_function_handle ()));
 
-    octave::unwind_protect frame;
+    unwind_protect frame;
 
     if (stash_object)
       {
         frame.protect_var (indexed_object);
 
         indexed_object = object;
       }
 
diff --git a/libinterp/parse-tree/pt-arg-list.h b/libinterp/parse-tree/pt-arg-list.h
--- a/libinterp/parse-tree/pt-arg-list.h
+++ b/libinterp/parse-tree/pt-arg-list.h
@@ -38,17 +38,17 @@ class octave_value_list;
 namespace octave
 {
   class tree_evaluator;
   class tree_expression;
 
   // Argument lists.  Used to hold the list of expressions that are the
   // arguments in a function call or index expression.
 
-  class tree_argument_list : public octave::base_list<tree_expression *>
+  class tree_argument_list : public base_list<tree_expression *>
   {
   public:
 
     typedef tree_expression* element_type;
 
     tree_argument_list (void)
       : list_includes_magic_end (false), list_includes_magic_tilde (false),
         simple_assign_lhs (false) { }
diff --git a/libinterp/parse-tree/pt-array-list.h b/libinterp/parse-tree/pt-array-list.h
--- a/libinterp/parse-tree/pt-array-list.h
+++ b/libinterp/parse-tree/pt-array-list.h
@@ -32,27 +32,27 @@ along with Octave; see the file COPYING.
 
 namespace octave
 {
   class tree_walker;
 
   // Base class for cell arrays and matrices.
 
   class tree_array_list : public tree_expression,
-                          public octave::base_list<tree_argument_list *>
+                          public base_list<tree_argument_list *>
   {
   public:
 
-    typedef octave::base_list<tree_argument_list *>::iterator iterator;
-    typedef octave::base_list<tree_argument_list *>::const_iterator const_iterator;
+    typedef base_list<tree_argument_list *>::iterator iterator;
+    typedef base_list<tree_argument_list *>::const_iterator const_iterator;
 
   protected:
 
     tree_array_list (tree_argument_list *row = nullptr, int l = -1, int c = -1)
-      : tree_expression (l, c), octave::base_list<tree_argument_list *> ()
+      : tree_expression (l, c), base_list<tree_argument_list *> ()
     {
       if (row)
         append (row);
     }
 
   public:
 
     // No copying!
diff --git a/libinterp/parse-tree/pt-classdef.h b/libinterp/parse-tree/pt-classdef.h
--- a/libinterp/parse-tree/pt-classdef.h
+++ b/libinterp/parse-tree/pt-classdef.h
@@ -76,26 +76,26 @@ namespace octave
 
   private:
 
     tree_identifier *id;
     tree_expression *expr;
     bool neg;
   };
 
-  class tree_classdef_attribute_list : public octave::base_list<tree_classdef_attribute *>
+  class tree_classdef_attribute_list : public base_list<tree_classdef_attribute *>
   {
   public:
 
     tree_classdef_attribute_list (void) { }
 
     tree_classdef_attribute_list (tree_classdef_attribute *a) { append (a); }
 
-    tree_classdef_attribute_list (const octave::base_list<tree_classdef_attribute *>& a)
-      : octave::base_list<tree_classdef_attribute *> (a) { }
+    tree_classdef_attribute_list (const base_list<tree_classdef_attribute *>& a)
+      : base_list<tree_classdef_attribute *> (a) { }
 
     // No copying!
 
     tree_classdef_attribute_list (const tree_classdef_attribute_list&) = delete;
 
     tree_classdef_attribute_list&
     operator = (const tree_classdef_attribute_list&) = delete;
 
@@ -130,26 +130,26 @@ namespace octave
       tw.visit_classdef_superclass (*this);
     }
 
   private:
 
     std::string cls_name;
   };
 
-  class tree_classdef_superclass_list : public octave::base_list<tree_classdef_superclass *>
+  class tree_classdef_superclass_list : public base_list<tree_classdef_superclass *>
   {
   public:
 
     tree_classdef_superclass_list (void) { }
 
     tree_classdef_superclass_list (tree_classdef_superclass *sc) { append (sc); }
 
-    tree_classdef_superclass_list (const octave::base_list<tree_classdef_superclass *>& a)
-      : octave::base_list<tree_classdef_superclass *> (a) { }
+    tree_classdef_superclass_list (const base_list<tree_classdef_superclass *>& a)
+      : base_list<tree_classdef_superclass *> (a) { }
 
     // No copying!
 
     tree_classdef_superclass_list (const tree_classdef_superclass_list&) = delete;
 
     tree_classdef_superclass_list&
     operator = (const tree_classdef_superclass_list&) = delete;
 
@@ -162,17 +162,17 @@ namespace octave
   };
 
   template <typename T>
   class tree_classdef_element : public tree
   {
   public:
 
     tree_classdef_element (tree_classdef_attribute_list *a,
-                           octave::base_list<T> *elist,
+                           base_list<T> *elist,
                            octave_comment_list *lc, octave_comment_list *tc,
                            int l = -1, int c = -1)
       : tree (l, c), attr_list (a), elt_list (elist),
         lead_comm (lc), trail_comm (tc)
     { }
 
     // No copying!
 
@@ -185,31 +185,31 @@ namespace octave
       delete attr_list;
       delete elt_list;
       delete lead_comm;
       delete trail_comm;
     }
 
     tree_classdef_attribute_list * attribute_list (void) { return attr_list; }
 
-    octave::base_list<T> * element_list (void) { return elt_list; }
+    base_list<T> * element_list (void) { return elt_list; }
 
     octave_comment_list * leading_comment (void) { return lead_comm; }
 
     octave_comment_list * trailing_comment (void) { return trail_comm; }
 
     void accept (tree_walker&) { }
 
   private:
 
     // List of attributes that apply to this class.
     tree_classdef_attribute_list *attr_list;
 
     // The list of objects contained in this block.
-    octave::base_list<T> *elt_list;
+    base_list<T> *elt_list;
 
     // Comment preceding the token marking the beginning of the block.
     octave_comment_list *lead_comm;
 
     // Comment preceding END token.
     octave_comment_list *trail_comm;
   };
 
@@ -242,26 +242,26 @@ namespace octave
     }
 
   private:
 
     tree_identifier *id;
     tree_expression *expr;
   };
 
-  class tree_classdef_property_list : public octave::base_list<tree_classdef_property *>
+  class tree_classdef_property_list : public base_list<tree_classdef_property *>
   {
   public:
 
     tree_classdef_property_list (void) { }
 
     tree_classdef_property_list (tree_classdef_property *p) { append (p); }
 
-    tree_classdef_property_list (const octave::base_list<tree_classdef_property *>& a)
-      : octave::base_list<tree_classdef_property *> (a) { }
+    tree_classdef_property_list (const base_list<tree_classdef_property *>& a)
+      : base_list<tree_classdef_property *> (a) { }
 
     // No copying!
 
     tree_classdef_property_list (const tree_classdef_property_list&) = delete;
 
     tree_classdef_property_list&
     operator = (const tree_classdef_property_list&) = delete;
 
@@ -295,26 +295,26 @@ namespace octave
     ~tree_classdef_properties_block (void) = default;
 
     void accept (tree_walker& tw)
     {
       tw.visit_classdef_properties_block (*this);
     }
   };
 
-  class tree_classdef_methods_list : public octave::base_list<octave_value>
+  class tree_classdef_methods_list : public base_list<octave_value>
   {
   public:
 
     tree_classdef_methods_list (void) { }
 
     tree_classdef_methods_list (const octave_value& f) { append (f); }
 
-    tree_classdef_methods_list (const octave::base_list<octave_value>& a)
-      : octave::base_list<octave_value> (a) { }
+    tree_classdef_methods_list (const base_list<octave_value>& a)
+      : base_list<octave_value> (a) { }
 
     // No copying!
 
     tree_classdef_methods_list (const tree_classdef_methods_list&) = delete;
 
     tree_classdef_methods_list&
     operator = (const tree_classdef_methods_list&) = delete;
 
@@ -375,26 +375,26 @@ namespace octave
       tw.visit_classdef_event (*this);
     }
 
   private:
 
     tree_identifier *id;
   };
 
-  class tree_classdef_events_list : public octave::base_list<tree_classdef_event *>
+  class tree_classdef_events_list : public base_list<tree_classdef_event *>
   {
   public:
 
     tree_classdef_events_list (void) { }
 
     tree_classdef_events_list (tree_classdef_event *e) { append (e); }
 
-    tree_classdef_events_list (const octave::base_list<tree_classdef_event *>& a)
-      : octave::base_list<tree_classdef_event *> (a) { }
+    tree_classdef_events_list (const base_list<tree_classdef_event *>& a)
+      : base_list<tree_classdef_event *> (a) { }
 
     // No copying!
 
     tree_classdef_events_list (const tree_classdef_events_list&) = delete;
 
     tree_classdef_events_list&
     operator = (const tree_classdef_events_list&) = delete;
 
@@ -463,26 +463,26 @@ namespace octave
     }
 
   private:
 
     tree_identifier *id;
     tree_expression *expr;
   };
 
-  class tree_classdef_enum_list : public octave::base_list<tree_classdef_enum *>
+  class tree_classdef_enum_list : public base_list<tree_classdef_enum *>
   {
   public:
 
     tree_classdef_enum_list (void) { }
 
     tree_classdef_enum_list (tree_classdef_enum *e) { append (e); }
 
-    tree_classdef_enum_list (const octave::base_list<tree_classdef_enum *>& a)
-      : octave::base_list<tree_classdef_enum *> (a) { }
+    tree_classdef_enum_list (const base_list<tree_classdef_enum *>& a)
+      : base_list<tree_classdef_enum *> (a) { }
 
     // No copying!
 
     tree_classdef_enum_list (const tree_classdef_enum_list&) = delete;
 
     tree_classdef_enum_list& operator = (const tree_classdef_enum_list&) = delete;
 
     ~tree_classdef_enum_list (void);
diff --git a/libinterp/parse-tree/pt-decl.h b/libinterp/parse-tree/pt-decl.h
--- a/libinterp/parse-tree/pt-decl.h
+++ b/libinterp/parse-tree/pt-decl.h
@@ -106,17 +106,17 @@ namespace octave
 
     // An identifier to tag with the declared property.
     tree_identifier *id;
 
     // An initializer expression (may be zero);
     tree_expression *expr;
   };
 
-  class tree_decl_init_list : public octave::base_list<tree_decl_elt *>
+  class tree_decl_init_list : public base_list<tree_decl_elt *>
   {
   public:
 
     tree_decl_init_list (void) { }
 
     tree_decl_init_list (tree_decl_elt *t) { append (t); }
 
     // No copying!
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -376,17 +376,17 @@ namespace octave
 
         symbol_table& symtab = m_interpreter.get_symbol_table ();
 
         octave_value fcn = symtab.find_function ("colon", tmp1);
 
         if (! fcn.is_defined ())
           error ("can not find overloaded colon function");
 
-        octave_value_list tmp2 = octave::feval (fcn, tmp1, 1);
+        octave_value_list tmp2 = feval (fcn, tmp1, 1);
 
         val = tmp2 (0);
       }
     else
       {
         octave_value ov_increment = 1.0;
 
         if (op_increment)
@@ -683,32 +683,32 @@ namespace octave
   {
     for (tree_decl_elt *elt : lst)
       elt->accept (*this);
   }
 
   void
   tree_evaluator::visit_decl_elt (tree_decl_elt& elt)
   {
-    octave::tree_identifier *id = elt.ident ();
+    tree_identifier *id = elt.ident ();
 
     if (id)
       {
         if (elt.is_global ())
           id->mark_global ();
         else if (elt.is_persistent ())
           id->mark_persistent ();
         else
           error ("declaration list element not global or persistent");
 
         octave_lvalue ult = id->lvalue (this);
 
         if (ult.is_undefined ())
           {
-            octave::tree_expression *expr = elt.expression ();
+            tree_expression *expr = elt.expression ();
 
             octave_value init_val;
 
             if (expr)
               init_val = evaluate (expr);
             else
               init_val = Matrix ();
 
@@ -745,17 +745,17 @@ namespace octave
   tree_evaluator::visit_simple_for_command (tree_simple_for_command& cmd)
   {
     if (debug_mode)
       do_breakpoint (cmd.is_breakpoint (true));
 
     // FIXME: need to handle PARFOR loops here using cmd.in_parallel ()
     // and cmd.maxproc_expr ();
 
-    octave::unwind_protect frame;
+    unwind_protect frame;
 
     frame.protect_var (in_loop_command);
 
     in_loop_command = true;
 
     tree_expression *expr = cmd.control_expr ();
 
     octave_value rhs = evaluate (expr);
@@ -863,17 +863,17 @@ namespace octave
   }
 
   void
   tree_evaluator::visit_complex_for_command (tree_complex_for_command& cmd)
   {
     if (debug_mode)
       do_breakpoint (cmd.is_breakpoint (true));
 
-    octave::unwind_protect frame;
+    unwind_protect frame;
 
     frame.protect_var (in_loop_command);
 
     in_loop_command = true;
 
     tree_expression *expr = cmd.control_expr ();
 
     octave_value rhs = evaluate (expr);
@@ -1012,21 +1012,21 @@ namespace octave
         if (fcn && ! (expr.is_postfix_indexed ()
                       && fcn->accepts_postfix_index (expr.postfix_index ())))
           {
             retval = fcn->call (*this, nargout);
           }
         else
           {
             if (expr.print_result () && nargout == 0
-                && octave::tree_evaluator::statement_printing_enabled ())
+                && tree_evaluator::statement_printing_enabled ())
               {
                 octave_value_list args = ovl (val);
                 args.stash_name_tags (string_vector (expr.name ()));
-                octave::feval ("display", args);
+                feval ("display", args);
               }
 
             retval = val;
           }
       }
     else if (sym->is_added_static ())
       expr.static_workspace_error ();
     else
@@ -1244,17 +1244,17 @@ namespace octave
               fcn = val.function_value (true);
 
             if (fcn)
               {
                 try
                   {
                     retval = fcn->call (*this, nargout, first_args);
                   }
-                catch (octave::index_exception& e)
+                catch (index_exception& e)
                   {
                     final_index_error (e, expr);
                   }
 
                 beg++;
                 p_args++;
                 p_arg_nm++;
                 p_dyn_field++;
@@ -1326,17 +1326,17 @@ namespace octave
                             // Found an object, so now we'll build up
                             // complete index list for one big subsref
                             // call from this point on.
 
                             indexing_object = true;
                           }
                       }
                   }
-                catch (octave::index_exception& e)
+                catch (index_exception& e)
                   {
                     final_index_error (e, expr);
                   }
               }
           }
 
         switch (type[i])
           {
@@ -1367,17 +1367,17 @@ namespace octave
       {
         try
           {
             retval = base_expr_val.subsref (type.substr (beg, n-beg), idx, nargout);
 
             beg = n;
             idx.clear ();
           }
-        catch (octave::index_exception& e)  // range problems, bad index type, etc.
+        catch (index_exception& e)  // range problems, bad index type, etc.
           {
             final_index_error (e, expr);
           }
       }
 
     // This happens if... ??
 
     octave_value val = (retval.length () ? retval(0) : octave_value ());
@@ -1799,30 +1799,30 @@ namespace octave
                       error ("element number %d undefined in return list", k+1);
 
                     k++;
                     continue;
                   }
               }
 
             if (expr.print_result ()
-                && octave::tree_evaluator::statement_printing_enabled ())
+                && tree_evaluator::statement_printing_enabled ())
               {
                 // We clear any index here so that we can get
                 // the new value of the referenced object below,
                 // instead of the indexed value (which should be
                 // the same as the right hand side value).
 
                 ult.clear_index ();
 
                 octave_value lhs_val = ult.value ();
 
                 octave_value_list args = ovl (lhs_val);
                 args.stash_name_tags (string_vector (lhs_elt->name ()));
-                octave::feval ("display", args);
+                feval ("display", args);
               }
           }
 
         // Concatenate return values.
         val = retval_list;
       }
 
     m_value_stack.push (val);
@@ -1862,17 +1862,17 @@ namespace octave
     octave_value_list retval;
 
     octave_value fcn = expr.function ();
 
     octave_value_list args = expr.arguments ();
 
     int nargout = m_nargout_stack.top ();
 
-    retval = octave::feval (fcn.function_value (), args, nargout);
+    retval = feval (fcn.function_value (), args, nargout);
 
     if (retval.length () == 1 && retval(0).is_function ())
       {
         // The return object is a function.  We may need to re-index it
         // using the same logic as for identifier.  This is primarily
         // used for superclass references in classdef.
 
         octave_value val = retval(0);
@@ -2025,17 +2025,17 @@ namespace octave
 
             rhs_val = lst(0);
           }
 
         tree_expression *lhs = expr.left_hand_side ();
 
         try
           {
-            octave::unwind_protect frame;
+            unwind_protect frame;
 
             octave_lvalue ult = lhs->lvalue (this);
 
             std::list<octave_lvalue> lvalue_list;
             lvalue_list.push_back (ult);
 
             m_lvalue_list_stack.push (&lvalue_list);
 
@@ -2050,34 +2050,34 @@ namespace octave
             ult.assign (etype, rhs_val);
 
             if (etype == octave_value::op_asn_eq)
               val = rhs_val;
             else
               val = ult.value ();
 
             if (expr.print_result ()
-                && octave::tree_evaluator::statement_printing_enabled ())
+                && tree_evaluator::statement_printing_enabled ())
               {
                 // We clear any index here so that we can
                 // get the new value of the referenced
                 // object below, instead of the indexed
                 // value (which should be the same as the
                 // right hand side value).
 
                 ult.clear_index ();
 
                 octave_value lhs_val = ult.value ();
 
                 octave_value_list args = ovl (lhs_val);
                 args.stash_name_tags (string_vector (lhs->name ()));
-                octave::feval ("display", args);
+                feval ("display", args);
               }
           }
-        catch (octave::index_exception& e)
+        catch (index_exception& e)
           {
             e.set_var (lhs->name ());
             std::string msg = e.message ();
             error_with_id (e.err_id (), msg.c_str ());
           }
       }
 
     m_value_stack.push (ovl (val));
@@ -2258,17 +2258,17 @@ namespace octave
 
   void
   tree_evaluator::visit_try_catch_command (tree_try_catch_command& cmd)
   {
     bool execution_error = false;
 
     {
       // unwind frame before catch block
-      octave::unwind_protect frame;
+      unwind_protect frame;
 
       frame.protect_var (buffer_error_messages);
       frame.protect_var (Vdebug_on_error);
       frame.protect_var (Vdebug_on_warning);
 
       buffer_error_messages++;
       Vdebug_on_error = false;
       Vdebug_on_warning = false;
@@ -2281,19 +2281,19 @@ namespace octave
       if (try_code)
         {
           try
             {
               in_try_catch++;
               try_code->accept (*this);
               in_try_catch--;
             }
-          catch (const octave::execution_exception&)
+          catch (const execution_exception&)
             {
-              octave::interpreter::recover_from_exception ();
+              interpreter::recover_from_exception ();
 
               in_try_catch--;          // must be restored before "catch" block
               execution_error = true;
             }
         }
       // Unwind to let the user print any messages from
       // errors that occurred in the body of the try_catch statement,
       // or throw further errors.
@@ -2325,27 +2325,27 @@ namespace octave
               catch_code->accept (*this);
           }
       }
   }
 
   void
   tree_evaluator::do_unwind_protect_cleanup_code (tree_statement_list *list)
   {
-    octave::unwind_protect frame;
+    unwind_protect frame;
 
     frame.protect_var (octave_interrupt_state);
     octave_interrupt_state = 0;
 
     // We want to preserve the last location info for possible
     // backtracking.
 
-    frame.add_method (m_call_stack, &octave::call_stack::set_line,
+    frame.add_method (m_call_stack, &call_stack::set_line,
                       m_call_stack.current_line ());
-    frame.add_method (m_call_stack, &octave::call_stack::set_column,
+    frame.add_method (m_call_stack, &call_stack::set_column,
                       m_call_stack.current_column ());
 
     // Similarly, if we have seen a return or break statement, allow all
     // the cleanup code to run before returning or handling the break.
     // We don't have to worry about continue statements because they can
     // only occur in loops.
 
     frame.protect_var (tree_return_command::returning);
@@ -2354,19 +2354,19 @@ namespace octave
     frame.protect_var (tree_break_command::breaking);
     tree_break_command::breaking = 0;
 
     try
       {
         if (list)
           list->accept (*this);
       }
-    catch (const octave::execution_exception&)
+    catch (const execution_exception&)
       {
-        octave::interpreter::recover_from_exception ();
+        interpreter::recover_from_exception ();
 
         if (tree_break_command::breaking || tree_return_command::returning)
           frame.discard (2);
         else
           frame.run (2);
 
         frame.discard (2);
 
@@ -2414,36 +2414,36 @@ namespace octave
     tree_statement_list *unwind_protect_code = cmd.body ();
 
     if (unwind_protect_code)
       {
         try
           {
             unwind_protect_code->accept (*this);
           }
-        catch (const octave::execution_exception&)
+        catch (const execution_exception&)
           {
             // FIXME: Maybe we should be able to temporarily set the
             // interpreter's exception handling state to something "safe"
             // while the cleanup block runs instead of just resetting it
             // here?
-            octave::interpreter::recover_from_exception ();
+            interpreter::recover_from_exception ();
 
             // Run the cleanup code on exceptions, so that it is run even
             // in case of interrupt or out-of-memory.
             do_unwind_protect_cleanup_code (cleanup_code);
 
             // If an error occurs inside the cleanup code, a new
             // exception will be thrown instead of the original.
             throw;
           }
-        catch (const octave::interrupt_exception&)
+        catch (const interrupt_exception&)
           {
             // The comments above apply here as well.
-            octave::interpreter::recover_from_exception ();
+            interpreter::recover_from_exception ();
             do_unwind_protect_cleanup_code (cleanup_code);
             throw;
           }
 
         // Also execute the unwind_protect_cleanump code if the
         // unwind_protect block runs without error.
         do_unwind_protect_cleanup_code (cleanup_code);
       }
@@ -2452,17 +2452,17 @@ namespace octave
   void
   tree_evaluator::visit_while_command (tree_while_command& cmd)
   {
 #if defined (HAVE_LLVM)
     if (tree_jit::execute (cmd))
       return;
 #endif
 
-    octave::unwind_protect frame;
+    unwind_protect frame;
 
     frame.protect_var (in_loop_command);
 
     in_loop_command = true;
 
     tree_expression *expr = cmd.condition ();
 
     if (! expr)
@@ -2491,17 +2491,17 @@ namespace octave
   void
   tree_evaluator::visit_do_until_command (tree_do_until_command& cmd)
   {
 #if defined (HAVE_LLVM)
     if (tree_jit::execute (cmd))
       return;
 #endif
 
-    octave::unwind_protect frame;
+    unwind_protect frame;
 
     frame.protect_var (in_loop_command);
 
     in_loop_command = true;
 
     tree_expression *expr = cmd.condition ();
     int until_line = cmd.line ();
     int until_column = cmd.column ();
@@ -2643,17 +2643,17 @@ namespace octave
       return t1.is_true ();
     else
       error ("%s: undefined value used in conditional expression", warn_for);
 
     return expr_value;
   }
 
   octave_value_list
-  tree_evaluator::make_value_list (octave::tree_argument_list *args,
+  tree_evaluator::make_value_list (tree_argument_list *args,
                                    const string_vector& arg_nm,
                                    const octave_value *object, bool rvalue)
   {
     octave_value_list retval;
 
     if (args)
       {
         // Function calls inside an argument list can't have ignored
diff --git a/libinterp/parse-tree/pt-eval.h b/libinterp/parse-tree/pt-eval.h
--- a/libinterp/parse-tree/pt-eval.h
+++ b/libinterp/parse-tree/pt-eval.h
@@ -302,17 +302,17 @@ namespace octave
                         bool is_end_of_fcn_or_script = false) const;
 
     virtual octave_value
     do_keyboard (const octave_value_list& args = octave_value_list ()) const;
 
     bool is_logically_true (tree_expression *expr, const char *warn_for);
 
     octave_value_list
-    make_value_list (octave::tree_argument_list *args,
+    make_value_list (tree_argument_list *args,
                      const string_vector& arg_nm,
                      const octave_value *object, bool rvalue = true);
 
     std::list<octave_lvalue> make_lvalue_list (tree_argument_list *);
 
     value_stack<octave_value_list> m_value_stack;
 
     value_stack<const std::list<octave_lvalue>*> m_lvalue_list_stack;
diff --git a/libinterp/parse-tree/pt-exp.h b/libinterp/parse-tree/pt-exp.h
--- a/libinterp/parse-tree/pt-exp.h
+++ b/libinterp/parse-tree/pt-exp.h
@@ -89,17 +89,17 @@ namespace octave
     int paren_count (void) const { return num_parens; }
 
     bool is_postfix_indexed (void) const { return (postfix_index_type != '\0'); }
 
     char postfix_index (void) const { return postfix_index_type; }
 
     // Check if the result of the expression should be printed.
     // Should normally be used in conjunction with
-    // octave::tree_evaluator::statement_printing_enabled.
+    // tree_evaluator::statement_printing_enabled.
     bool print_result (void) const { return print_flag; }
 
     virtual std::string oper (void) const { return "<unknown>"; }
 
     virtual std::string name (void) const { return "<unknown>"; }
 
     virtual std::string original_text (void) const;
 
diff --git a/libinterp/parse-tree/pt-fcn-handle.cc b/libinterp/parse-tree/pt-fcn-handle.cc
--- a/libinterp/parse-tree/pt-fcn-handle.cc
+++ b/libinterp/parse-tree/pt-fcn-handle.cc
@@ -67,17 +67,17 @@ namespace octave
   {
     tree_parameter_list *param_list = parameter_list ();
     tree_expression *expr = expression ();
 
     symbol_table::scope *af_scope = m_scope;
     symbol_table::scope *af_parent_scope = m_parent_scope;
 
     symbol_table& symtab
-      = octave::__get_symbol_table__ ("tree_anon_fcn_handle::dup");
+      = __get_symbol_table__ ("tree_anon_fcn_handle::dup");
 
     symbol_table::scope *new_scope = af_scope ? af_scope->dup () : 0;
 
     // FIXME: why should we inherit from the current scope here?  That
     // doesn't seem right, but with the way things work now it appears
     // to be required for bug-31371.tst to pass.
 
     if (new_scope)
diff --git a/libinterp/parse-tree/pt-idx.cc b/libinterp/parse-tree/pt-idx.cc
--- a/libinterp/parse-tree/pt-idx.cc
+++ b/libinterp/parse-tree/pt-idx.cc
@@ -260,17 +260,17 @@ namespace octave
           err_indexed_cs_list ();
 
         if (tmpi < i)
           {
             try
               {
                 tmp = tmp.subsref (type.substr (tmpi, i-tmpi), tmpidx, true);
               }
-            catch (octave::index_exception& e)  // problems with range, invalid type etc.
+            catch (index_exception& e)  // problems with range, invalid type etc.
               {
                 final_index_error (e, expr);
               }
 
             tmpidx.clear ();
           }
 
         switch (type[i])
diff --git a/libinterp/parse-tree/pt-misc.h b/libinterp/parse-tree/pt-misc.h
--- a/libinterp/parse-tree/pt-misc.h
+++ b/libinterp/parse-tree/pt-misc.h
@@ -34,17 +34,17 @@ namespace octave
 {
   class tree_identifier;
   class tree_index_expression;
 
   // Parameter lists.  Used to hold the list of input and output
   // parameters in a function definition.  Elements are identifiers
   // only.
 
-  class tree_parameter_list : public octave::base_list<tree_decl_elt *>
+  class tree_parameter_list : public base_list<tree_decl_elt *>
   {
   public:
 
     enum in_or_out
       {
         in = 1,
         out = 2
       };
@@ -90,17 +90,17 @@ namespace octave
   private:
 
     int marked_for_varargs;
   };
 
   // Return lists.  Used to hold the right hand sides of multiple
   // assignment expressions.
 
-  class tree_return_list : public octave::base_list<tree_index_expression *>
+  class tree_return_list : public base_list<tree_index_expression *>
   {
   public:
 
     tree_return_list (void) { }
 
     tree_return_list (tree_index_expression *t) { append (t); }
 
     // No copying!
diff --git a/libinterp/parse-tree/pt-select.h b/libinterp/parse-tree/pt-select.h
--- a/libinterp/parse-tree/pt-select.h
+++ b/libinterp/parse-tree/pt-select.h
@@ -82,17 +82,17 @@ namespace octave
 
     // The list of statements to evaluate if expr is true.
     tree_statement_list *list;
 
     // Comment preceding ELSE or ELSEIF token.
     octave_comment_list *lead_comm;
   };
 
-  class tree_if_command_list : public octave::base_list<tree_if_clause *>
+  class tree_if_command_list : public base_list<tree_if_clause *>
   {
   public:
 
     tree_if_command_list (void) { }
 
     tree_if_command_list (tree_if_clause *t) { append (t); }
 
     // No copying!
@@ -205,17 +205,17 @@ namespace octave
 
     // The list of statements to evaluate if the label matches.
     tree_statement_list *list;
 
     // Comment preceding CASE or OTHERWISE token.
     octave_comment_list *lead_comm;
   };
 
-  class tree_switch_case_list : public octave::base_list<tree_switch_case *>
+  class tree_switch_case_list : public base_list<tree_switch_case *>
   {
   public:
 
     tree_switch_case_list (void) { }
 
     tree_switch_case_list (tree_switch_case *t) { append (t); }
 
     // No copying!
diff --git a/libinterp/parse-tree/pt-stmt.h b/libinterp/parse-tree/pt-stmt.h
--- a/libinterp/parse-tree/pt-stmt.h
+++ b/libinterp/parse-tree/pt-stmt.h
@@ -123,17 +123,17 @@ namespace octave
     tree_expression *expr;
 
     // Comment associated with this statement.
     octave_comment_list *comm;
   };
 
   // A list of statements to evaluate.
 
-  class tree_statement_list : public octave::base_list<tree_statement *>
+  class tree_statement_list : public base_list<tree_statement *>
   {
   public:
 
     tree_statement_list (void)
       : function_body (false), anon_function_body (false),
         script_body (false) { }
 
     tree_statement_list (tree_statement *s)
diff --git a/libinterp/parse-tree/pt-tm-const.cc b/libinterp/parse-tree/pt-tm-const.cc
--- a/libinterp/parse-tree/pt-tm-const.cc
+++ b/libinterp/parse-tree/pt-tm-const.cc
@@ -352,36 +352,36 @@ namespace octave
       }
 
     ok = true;
   }
 
   template <>
   octave_value
   do_single_type_concat<octave_map> (const dim_vector& dv,
-                                     octave::tm_const& tmp)
+                                     tm_const& tmp)
   {
     octave_map result;
 
     if (tmp.all_1x1_p ())
       single_type_concat<octave_scalar_map> (result, dv, tmp);
     else
       single_type_concat<octave_map> (result, dv, tmp);
 
     return result;
   }
 
-  octave_value do_class_concat (octave::tm_const& tmc)
+  octave_value do_class_concat (tm_const& tmc)
   {
     octave_value retval;
 
     octave_value_list rows (tmc.length (), octave_value ());
 
     octave_idx_type j = 0;
-    for (octave::tm_row_const& tmrc : tmc)
+    for (tm_row_const& tmrc : tmc)
       {
         octave_quit ();
 
         if (tmrc.length () == 1)
           rows(j++) = *(tmrc.begin ());
         else
           {
             octave_value_list row (tmrc.length (), octave_value ());
diff --git a/libinterp/parse-tree/pt-tm-const.h b/libinterp/parse-tree/pt-tm-const.h
--- a/libinterp/parse-tree/pt-tm-const.h
+++ b/libinterp/parse-tree/pt-tm-const.h
@@ -50,17 +50,17 @@ namespace octave
   // But first, some internal classes that make our job much easier.
 
   class
   tm_row_const
   {
   private:
 
     class
-    tm_row_const_rep : public octave::base_list<octave_value>
+    tm_row_const_rep : public base_list<octave_value>
     {
     public:
 
       tm_row_const_rep (void)
         : count (1), dv (0, 0), all_str (false),
           all_sq_str (false), all_dq_str (false),
           some_str (false), all_real (false), all_cmplx (false),
           all_mt (true), any_cell (false), any_sparse (false),
@@ -73,17 +73,17 @@ namespace octave
           some_str (false), all_real (false), all_cmplx (false),
           all_mt (true), any_cell (false), any_sparse (false),
           any_class (false), all_1x1 (! row.empty ()),
           first_elem_is_struct (false), class_nm (), ok (false)
       { init (row, tw); }
 
       ~tm_row_const_rep (void) = default;
 
-      octave::refcount<int> count;
+      refcount<int> count;
 
       dim_vector dv;
 
       bool all_str;
       bool all_sq_str;
       bool all_dq_str;
       bool some_str;
       bool all_real;
@@ -188,17 +188,17 @@ namespace octave
     const_iterator end (void) const { return rep->end (); }
 
   private:
 
     tm_row_const_rep *rep;
   };
 
   class
-  tm_const : public octave::base_list<tm_row_const>
+  tm_const : public base_list<tm_row_const>
   {
   public:
 
     tm_const (const tree_matrix& tm, tree_evaluator *tw = 0)
       : dv (0, 0), all_str (false), all_sq_str (false),
         all_dq_str (false),
         some_str (false), all_real (false), all_cmplx (false),
         all_mt (true), any_cell (false), any_sparse (false),
@@ -254,22 +254,22 @@ namespace octave
 
     tm_const& operator = (const tm_const&);
 
     void init (const tree_matrix& tm, tree_evaluator *tw);
   };
 
   template <typename TYPE, typename T>
   void
-  single_type_concat (Array<T>& result, octave::tm_const& tmp)
+  single_type_concat (Array<T>& result, tm_const& tmp)
   {
     octave_idx_type r = 0;
     octave_idx_type c = 0;
 
-    for (octave::tm_row_const& row : tmp)
+    for (tm_row_const& row : tmp)
       {
         // Skip empty arrays to allow looser rules.
         if (row.dims ().any_zero ())
           continue;
 
         for (auto& elt : row)
           {
             octave_quit ();
@@ -289,29 +289,29 @@ namespace octave
         r += row.rows ();
         c = 0;
       }
   }
 
   template <typename TYPE, typename T>
   void
   single_type_concat (Array<T>& result, const dim_vector& dv,
-                      octave::tm_const& tmp)
+                      tm_const& tmp)
   {
     if (dv.any_zero ())
       {
         result = Array<T> (dv);
         return;
       }
 
     if (tmp.length () == 1)
       {
         // If possible, forward the operation to liboctave.
         // Single row.
-        octave::tm_row_const& row = tmp.front ();
+        tm_row_const& row = tmp.front ();
         if (! (equal_types<T, char>::value || equal_types<T, octave_value>::value)
             && row.all_1x1_p ())
           {
             // Optimize all scalars case.
             result.clear (dv);
             assert (static_cast<size_t> (result.numel ()) == row.length ());
             octave_idx_type i = 0;
             for (const auto& elt : row)
@@ -338,31 +338,31 @@ namespace octave
         result = Array<T> (dv);
         single_type_concat<TYPE> (result, tmp);
       }
   }
 
   template <typename TYPE, typename T>
   void
   single_type_concat (Sparse<T>& result, const dim_vector& dv,
-                      octave::tm_const& tmp)
+                      tm_const& tmp)
   {
     if (dv.any_zero ())
       {
         result = Sparse<T> (dv);
         return;
       }
 
     // Sparse matrices require preallocation for efficient indexing; besides,
     // only horizontal concatenation can be efficiently handled by indexing.
     // So we just cat all rows through liboctave, then cat the final column.
     octave_idx_type nrows = tmp.length ();
     octave_idx_type j = 0;
     OCTAVE_LOCAL_BUFFER (Sparse<T>, sparse_row_list, nrows);
-    for (octave::tm_row_const& row : tmp)
+    for (tm_row_const& row : tmp)
       {
         octave_idx_type ncols = row.length ();
         octave_idx_type i = 0;
         OCTAVE_LOCAL_BUFFER (Sparse<T>, sparse_list, ncols);
 
         for (auto& elt : row)
           {
             octave_quit ();
@@ -377,28 +377,28 @@ namespace octave
       }
 
     result = Sparse<T>::cat (-1, nrows, sparse_row_list);
   }
 
   template <typename MAP>
   void
   single_type_concat (octave_map& result, const dim_vector& dv,
-                      octave::tm_const& tmp)
+                      tm_const& tmp)
   {
     if (dv.any_zero ())
       {
         result = octave_map (dv);
         return;
       }
 
     octave_idx_type nrows = tmp.length ();
     octave_idx_type j = 0;
     OCTAVE_LOCAL_BUFFER (octave_map, map_row_list, nrows);
-    for (octave::tm_row_const& row : tmp)
+    for (tm_row_const& row : tmp)
       {
         octave_idx_type ncols = row.length ();
         octave_idx_type i = 0;
         OCTAVE_LOCAL_BUFFER (MAP, map_list, ncols);
 
         for (auto& elt : row)
           {
             octave_quit ();
@@ -412,26 +412,26 @@ namespace octave
         j++;
       }
 
     result = octave_map::cat (-1, nrows, map_row_list);
   }
 
   template <typename TYPE>
   octave_value
-  do_single_type_concat (const dim_vector& dv, octave::tm_const& tmp)
+  do_single_type_concat (const dim_vector& dv, tm_const& tmp)
   {
     TYPE result;
 
     single_type_concat<TYPE> (result, dv, tmp);
 
     return result;
   }
 
   template <>
   octave_value
   do_single_type_concat<octave_map> (const dim_vector& dv,
-                                     octave::tm_const& tmp);
+                                     tm_const& tmp);
 
-  extern octave_value do_class_concat (octave::tm_const& tmc);
+  extern octave_value do_class_concat (tm_const& tmc);
 }
 
 #endif
diff --git a/libinterp/parse-tree/pt.cc b/libinterp/parse-tree/pt.cc
--- a/libinterp/parse-tree/pt.cc
+++ b/libinterp/parse-tree/pt.cc
@@ -62,17 +62,17 @@ namespace octave
     if (bp == 0)
       retval = false;
     else if (bp->empty ())     // empty condition always met
       retval = true;
     else
       {
         int parse_status = 0;
 
-        octave::unwind_protect frame;
+        unwind_protect frame;
         frame.protect_var (buffer_error_messages);
         frame.protect_var (Vdebug_on_error);
         frame.protect_var (Vdebug_on_warning);
 
         buffer_error_messages++;
         Vdebug_on_error = false;
         Vdebug_on_warning = false;
 
@@ -86,17 +86,17 @@ namespace octave
                   warning ("Breakpoint condition must be a scalar, not size %s",
                            val(0).dims ().str ('x').c_str ());
                 else
                   retval = val(0).bool_value ();
               }
             else
               warning ("Error parsing breakpoint condition");
           }
-        catch (const octave::execution_exception& e)
+        catch (const execution_exception& e)
           {
             warning ("Error evaluating breakpoint condition:\n    %s",
                      last_error_message ().c_str ());
           }
       }
     return retval;
   }
 }
diff --git a/liboctave/numeric/aepbalance.cc b/liboctave/numeric/aepbalance.cc
--- a/liboctave/numeric/aepbalance.cc
+++ b/liboctave/numeric/aepbalance.cc
@@ -45,17 +45,17 @@ namespace octave
 {
   namespace math
   {
     template <>
     aepbalance<Matrix>::aepbalance (const Matrix& a, bool noperm, bool noscal)
       : balanced_mat (a), scale (), ilo (), ihi (),
         job (get_job (noperm, noscal))
     {
-      F77_INT n = octave::to_f77_int (a.cols ());
+      F77_INT n = to_f77_int (a.cols ());
 
       if (a.rows () != n)
         (*current_liboctave_error_handler)
           ("aepbalance: requires square matrix");
 
       scale = ColumnVector (n);
 
       F77_INT info, t_ilo, t_ihi;
@@ -68,25 +68,25 @@ namespace octave
       ilo = t_ilo;
       ihi = t_ihi;
     }
 
     template <>
     Matrix
     aepbalance<Matrix>::balancing_matrix (void) const
     {
-      F77_INT n = octave::to_f77_int (balanced_mat.rows ());
+      F77_INT n = to_f77_int (balanced_mat.rows ());
 
       Matrix balancing_mat (n, n, 0.0);
       for (F77_INT i = 0; i < n; i++)
         balancing_mat.elem (i ,i) = 1.0;
 
       F77_INT info;
-      F77_INT t_ilo = octave::to_f77_int (ilo);
-      F77_INT t_ihi = octave::to_f77_int (ihi);
+      F77_INT t_ilo = to_f77_int (ilo);
+      F77_INT t_ihi = to_f77_int (ihi);
 
       char side = 'R';
 
       F77_XFCN (dgebak, DGEBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
                                  F77_CONST_CHAR_ARG2 (&side, 1),
                                  n, t_ilo, t_ihi, scale.data (), n,
                                  balancing_mat.fortran_vec (), n, info
                                  F77_CHAR_ARG_LEN (1)
@@ -96,17 +96,17 @@ namespace octave
     }
 
     template <>
     aepbalance<FloatMatrix>::aepbalance (const FloatMatrix& a, bool noperm,
                                          bool noscal)
       : balanced_mat (a), scale (), ilo (), ihi (),
         job (get_job (noperm, noscal))
     {
-      F77_INT n = octave::to_f77_int (a.cols ());
+      F77_INT n = to_f77_int (a.cols ());
 
       if (a.rows () != n)
         (*current_liboctave_error_handler)
           ("aepbalance: requires square matrix");
 
       scale = FloatColumnVector (n);
 
       F77_INT info, t_ilo, t_ihi;
@@ -119,25 +119,25 @@ namespace octave
       ilo = t_ilo;
       ihi = t_ihi;
     }
 
     template <>
     FloatMatrix
     aepbalance<FloatMatrix>::balancing_matrix (void) const
     {
-      F77_INT n = octave::to_f77_int (balanced_mat.rows ());
+      F77_INT n = to_f77_int (balanced_mat.rows ());
 
       FloatMatrix balancing_mat (n, n, 0.0);
       for (F77_INT i = 0; i < n; i++)
         balancing_mat.elem (i ,i) = 1.0;
 
       F77_INT info;
-      F77_INT t_ilo = octave::to_f77_int (ilo);
-      F77_INT t_ihi = octave::to_f77_int (ihi);
+      F77_INT t_ilo = to_f77_int (ilo);
+      F77_INT t_ihi = to_f77_int (ihi);
 
       char side = 'R';
 
       F77_XFCN (sgebak, SGEBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
                                  F77_CONST_CHAR_ARG2 (&side, 1),
                                  n, t_ilo, t_ihi, scale.data (), n,
                                  balancing_mat.fortran_vec (), n, info
                                  F77_CHAR_ARG_LEN (1)
@@ -147,17 +147,17 @@ namespace octave
     }
 
     template <>
     aepbalance<ComplexMatrix>::aepbalance (const ComplexMatrix& a, bool noperm,
                                            bool noscal)
       : balanced_mat (a), scale (), ilo (), ihi (),
         job (get_job (noperm, noscal))
     {
-      F77_INT n = octave::to_f77_int (a.cols ());
+      F77_INT n = to_f77_int (a.cols ());
 
       if (a.rows () != n)
         (*current_liboctave_error_handler)
           ("aepbalance: requires square matrix");
 
       scale = ColumnVector (n);
 
       F77_INT info, t_ilo, t_ihi;
@@ -170,25 +170,25 @@ namespace octave
       ilo = t_ilo;
       ihi = t_ihi;
     }
 
     template <>
     ComplexMatrix
     aepbalance<ComplexMatrix>::balancing_matrix (void) const
     {
-      F77_INT n = octave::to_f77_int (balanced_mat.rows ());
+      F77_INT n = to_f77_int (balanced_mat.rows ());
 
       ComplexMatrix balancing_mat (n, n, 0.0);
       for (F77_INT i = 0; i < n; i++)
         balancing_mat.elem (i, i) = 1.0;
 
       F77_INT info;
-      F77_INT t_ilo = octave::to_f77_int (ilo);
-      F77_INT t_ihi = octave::to_f77_int (ihi);
+      F77_INT t_ilo = to_f77_int (ilo);
+      F77_INT t_ihi = to_f77_int (ihi);
 
       char side = 'R';
 
       F77_XFCN (zgebak, ZGEBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
                                  F77_CONST_CHAR_ARG2 (&side, 1),
                                  n, t_ilo, t_ihi, scale.data (), n,
                                  F77_DBLE_CMPLX_ARG (balancing_mat.fortran_vec ()),
                                  n, info
@@ -199,17 +199,17 @@ namespace octave
     }
 
     template <>
     aepbalance<FloatComplexMatrix>::aepbalance (const FloatComplexMatrix& a,
                                                 bool noperm, bool noscal)
       : balanced_mat (a), scale (), ilo (), ihi (),
         job (get_job (noperm, noscal))
     {
-      F77_INT n = octave::to_f77_int (a.cols ());
+      F77_INT n = to_f77_int (a.cols ());
 
       if (a.rows () != n)
         (*current_liboctave_error_handler)
           ("aepbalance: requires square matrix");
 
       scale = FloatColumnVector (n);
 
       F77_INT info, t_ilo, t_ihi;
@@ -222,25 +222,25 @@ namespace octave
       ilo = t_ilo;
       ihi = t_ihi;
     }
 
     template <>
     FloatComplexMatrix
     aepbalance<FloatComplexMatrix>::balancing_matrix (void) const
     {
-      F77_INT n = octave::to_f77_int (balanced_mat.rows ());
+      F77_INT n = to_f77_int (balanced_mat.rows ());
 
       FloatComplexMatrix balancing_mat (n, n, 0.0);
       for (F77_INT i = 0; i < n; i++)
         balancing_mat.elem (i, i) = 1.0;
 
       F77_INT info;
-      F77_INT t_ilo = octave::to_f77_int (ilo);
-      F77_INT t_ihi = octave::to_f77_int (ihi);
+      F77_INT t_ilo = to_f77_int (ilo);
+      F77_INT t_ihi = to_f77_int (ihi);
 
       char side = 'R';
 
       F77_XFCN (cgebak, CGEBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
                                  F77_CONST_CHAR_ARG2 (&side, 1),
                                  n, t_ilo, t_ihi, scale.data (), n,
                                  F77_CMPLX_ARG (balancing_mat.fortran_vec ()),
                                  n, info
diff --git a/liboctave/numeric/chol.cc b/liboctave/numeric/chol.cc
--- a/liboctave/numeric/chol.cc
+++ b/liboctave/numeric/chol.cc
@@ -328,29 +328,29 @@ namespace octave
 
       if (u.numel () != n + 1)
         (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
       if (j < 0 || j > n)
         (*current_liboctave_error_handler) ("cholinsert: index out of range");
 
       if (singular (chol_mat))
         info = 2;
-      else if (octave::math::imag (u(j)) != zero)
+      else if (math::imag (u(j)) != zero)
         info = 3;
       else
         {
           T a = chol_mat.hermitian () * chol_mat;
           T a1 (n+1, n+1);
           for (octave_idx_type k = 0; k < n+1; k++)
             for (octave_idx_type l = 0; l < n+1; l++)
               {
                 if (l == j)
                   a1(k, l) = u(k);
                 else if (k == j)
-                  a1(k, l) = octave::math::conj (u(l));
+                  a1(k, l) = math::conj (u(l));
                 else
                   a1(k, l) = a(k < j ? k : k-1, l < j ? l : l-1);
               }
           info = init (a1, true, false);
           if (info) info = 1;
         }
 
       return info;
@@ -410,17 +410,17 @@ namespace octave
     chol<Matrix>::init (const Matrix& a, bool upper, bool calc_cond)
     {
       octave_idx_type a_nr = a.rows ();
       octave_idx_type a_nc = a.cols ();
 
       if (a_nr != a_nc)
         (*current_liboctave_error_handler) ("chol: requires square matrix");
 
-      F77_INT n = octave::to_f77_int (a_nc);
+      F77_INT n = to_f77_int (a_nc);
       F77_INT info;
 
       is_upper = upper;
 
       chol_mat.clear (n, n);
       if (is_upper)
         for (octave_idx_type j = 0; j < n; j++)
           {
@@ -479,17 +479,17 @@ namespace octave
     }
 
 #if defined (HAVE_QRUPDATE)
 
     template <>
     void
     chol<Matrix>::update (const ColumnVector& u)
     {
-      F77_INT n = octave::to_f77_int (chol_mat.rows ());
+      F77_INT n = to_f77_int (chol_mat.rows ());
 
       if (u.numel () != n)
         (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
       ColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (double, w, n);
 
@@ -498,17 +498,17 @@ namespace octave
     }
 
     template <>
     octave_idx_type
     chol<Matrix>::downdate (const ColumnVector& u)
     {
       F77_INT info = -1;
 
-      F77_INT n = octave::to_f77_int (chol_mat.rows ());
+      F77_INT n = to_f77_int (chol_mat.rows ());
 
       if (u.numel () != n)
         (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
       ColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (double, w, n);
 
@@ -519,61 +519,61 @@ namespace octave
     }
 
     template <>
     octave_idx_type
     chol<Matrix>::insert_sym (const ColumnVector& u, octave_idx_type j_arg)
     {
       F77_INT info = -1;
 
-      F77_INT n = octave::to_f77_int (chol_mat.rows ());
-      F77_INT j = octave::to_f77_int (j_arg);
+      F77_INT n = to_f77_int (chol_mat.rows ());
+      F77_INT j = to_f77_int (j_arg);
 
       if (u.numel () != n + 1)
         (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
       if (j < 0 || j > n)
         (*current_liboctave_error_handler) ("cholinsert: index out of range");
 
       ColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (double, w, n);
 
       chol_mat.resize (n+1, n+1);
-      F77_INT ldcm = octave::to_f77_int (chol_mat.rows ());
+      F77_INT ldcm = to_f77_int (chol_mat.rows ());
 
       F77_XFCN (dchinx, DCHINX, (n, chol_mat.fortran_vec (), ldcm,
                                  j + 1, utmp.fortran_vec (), w, info));
 
       return info;
     }
 
     template <>
     void
     chol<Matrix>::delete_sym (octave_idx_type j_arg)
     {
-      F77_INT n = octave::to_f77_int (chol_mat.rows ());
-      F77_INT j = octave::to_f77_int (j_arg);
+      F77_INT n = to_f77_int (chol_mat.rows ());
+      F77_INT j = to_f77_int (j_arg);
 
       if (j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("choldelete: index out of range");
 
       OCTAVE_LOCAL_BUFFER (double, w, n);
 
       F77_XFCN (dchdex, DCHDEX, (n, chol_mat.fortran_vec (), n, j + 1, w));
 
       chol_mat.resize (n-1, n-1);
     }
 
     template <>
     void
     chol<Matrix>::shift_sym (octave_idx_type i_arg, octave_idx_type j_arg)
     {
-      F77_INT n = octave::to_f77_int (chol_mat.rows ());
-      F77_INT i = octave::to_f77_int (i_arg);
-      F77_INT j = octave::to_f77_int (j_arg);
+      F77_INT n = to_f77_int (chol_mat.rows ());
+      F77_INT i = to_f77_int (i_arg);
+      F77_INT j = to_f77_int (j_arg);
 
       if (i < 0 || i > n-1 || j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("cholshift: index out of range");
 
       OCTAVE_LOCAL_BUFFER (double, w, 2*n);
 
       F77_XFCN (dchshx, DCHSHX, (n, chol_mat.fortran_vec (), n,
                                  i + 1, j + 1, w));
@@ -586,17 +586,17 @@ namespace octave
     chol<FloatMatrix>::init (const FloatMatrix& a, bool upper, bool calc_cond)
     {
       octave_idx_type a_nr = a.rows ();
       octave_idx_type a_nc = a.cols ();
 
       if (a_nr != a_nc)
         (*current_liboctave_error_handler) ("chol: requires square matrix");
 
-      F77_INT n = octave::to_f77_int (a_nc);
+      F77_INT n = to_f77_int (a_nc);
       F77_INT info;
 
       is_upper = upper;
 
       chol_mat.clear (n, n);
       if (is_upper)
         for (octave_idx_type j = 0; j < n; j++)
           {
@@ -655,17 +655,17 @@ namespace octave
     }
 
 #if defined (HAVE_QRUPDATE)
 
     template <>
     void
     chol<FloatMatrix>::update (const FloatColumnVector& u)
     {
-      F77_INT n = octave::to_f77_int (chol_mat.rows ());
+      F77_INT n = to_f77_int (chol_mat.rows ());
 
       if (u.numel () != n)
         (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
       FloatColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (float, w, n);
 
@@ -674,17 +674,17 @@ namespace octave
     }
 
     template <>
     octave_idx_type
     chol<FloatMatrix>::downdate (const FloatColumnVector& u)
     {
       F77_INT info = -1;
 
-      F77_INT n = octave::to_f77_int (chol_mat.rows ());
+      F77_INT n = to_f77_int (chol_mat.rows ());
 
       if (u.numel () != n)
         (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
       FloatColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (float, w, n);
 
@@ -696,62 +696,62 @@ namespace octave
 
     template <>
     octave_idx_type
     chol<FloatMatrix>::insert_sym (const FloatColumnVector& u,
                                    octave_idx_type j_arg)
     {
       F77_INT info = -1;
 
-      F77_INT n = octave::to_f77_int (chol_mat.rows ());
-      F77_INT j = octave::to_f77_int (j_arg);
+      F77_INT n = to_f77_int (chol_mat.rows ());
+      F77_INT j = to_f77_int (j_arg);
 
       if (u.numel () != n + 1)
         (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
       if (j < 0 || j > n)
         (*current_liboctave_error_handler) ("cholinsert: index out of range");
 
       FloatColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (float, w, n);
 
       chol_mat.resize (n+1, n+1);
-      F77_INT ldcm = octave::to_f77_int (chol_mat.rows ());
+      F77_INT ldcm = to_f77_int (chol_mat.rows ());
 
       F77_XFCN (schinx, SCHINX, (n, chol_mat.fortran_vec (), ldcm,
                                  j + 1, utmp.fortran_vec (), w, info));
 
       return info;
     }
 
     template <>
     void
     chol<FloatMatrix>::delete_sym (octave_idx_type j_arg)
     {
-      F77_INT n = octave::to_f77_int (chol_mat.rows ());
-      F77_INT j = octave::to_f77_int (j_arg);
+      F77_INT n = to_f77_int (chol_mat.rows ());
+      F77_INT j = to_f77_int (j_arg);
 
       if (j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("choldelete: index out of range");
 
       OCTAVE_LOCAL_BUFFER (float, w, n);
 
       F77_XFCN (schdex, SCHDEX, (n, chol_mat.fortran_vec (), n,
                                  j + 1, w));
 
       chol_mat.resize (n-1, n-1);
     }
 
     template <>
     void
     chol<FloatMatrix>::shift_sym (octave_idx_type i_arg, octave_idx_type j_arg)
     {
-      F77_INT n = octave::to_f77_int (chol_mat.rows ());
-      F77_INT i = octave::to_f77_int (i_arg);
-      F77_INT j = octave::to_f77_int (j_arg);
+      F77_INT n = to_f77_int (chol_mat.rows ());
+      F77_INT i = to_f77_int (i_arg);
+      F77_INT j = to_f77_int (j_arg);
 
       if (i < 0 || i > n-1 || j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("cholshift: index out of range");
 
       OCTAVE_LOCAL_BUFFER (float, w, 2*n);
 
       F77_XFCN (schshx, SCHSHX, (n, chol_mat.fortran_vec (), n,
                                  i + 1, j + 1, w));
@@ -764,17 +764,17 @@ namespace octave
     chol<ComplexMatrix>::init (const ComplexMatrix& a, bool upper, bool calc_cond)
     {
       octave_idx_type a_nr = a.rows ();
       octave_idx_type a_nc = a.cols ();
 
       if (a_nr != a_nc)
         (*current_liboctave_error_handler) ("chol: requires square matrix");
 
-      F77_INT n = octave::to_f77_int (a_nc);
+      F77_INT n = to_f77_int (a_nc);
       F77_INT info;
 
       is_upper = upper;
 
       chol_mat.clear (n, n);
       if (is_upper)
         for (octave_idx_type j = 0; j < n; j++)
           {
@@ -832,17 +832,17 @@ namespace octave
     }
 
 #if defined (HAVE_QRUPDATE)
 
     template <>
     void
     chol<ComplexMatrix>::update (const ComplexColumnVector& u)
     {
-      F77_INT n = octave::to_f77_int (chol_mat.rows ());
+      F77_INT n = to_f77_int (chol_mat.rows ());
 
       if (u.numel () != n)
         (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
       ComplexColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (double, rw, n);
 
@@ -854,17 +854,17 @@ namespace octave
     }
 
     template <>
     octave_idx_type
     chol<ComplexMatrix>::downdate (const ComplexColumnVector& u)
     {
       F77_INT info = -1;
 
-      F77_INT n = octave::to_f77_int (chol_mat.rows ());
+      F77_INT n = to_f77_int (chol_mat.rows ());
 
       if (u.numel () != n)
         (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
       ComplexColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (double, rw, n);
 
@@ -879,46 +879,46 @@ namespace octave
 
     template <>
     octave_idx_type
     chol<ComplexMatrix>::insert_sym (const ComplexColumnVector& u,
                                      octave_idx_type j_arg)
     {
       F77_INT info = -1;
 
-      F77_INT n = octave::to_f77_int (chol_mat.rows ());
-      F77_INT j = octave::to_f77_int (j_arg);
+      F77_INT n = to_f77_int (chol_mat.rows ());
+      F77_INT j = to_f77_int (j_arg);
 
       if (u.numel () != n + 1)
         (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
       if (j < 0 || j > n)
         (*current_liboctave_error_handler) ("cholinsert: index out of range");
 
       ComplexColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (double, rw, n);
 
       chol_mat.resize (n+1, n+1);
-      F77_INT ldcm = octave::to_f77_int (chol_mat.rows ());
+      F77_INT ldcm = to_f77_int (chol_mat.rows ());
 
       F77_XFCN (zchinx, ZCHINX, (n,
                                  F77_DBLE_CMPLX_ARG (chol_mat.fortran_vec ()),
                                  ldcm, j + 1,
                                  F77_DBLE_CMPLX_ARG (utmp.fortran_vec ()),
                                  rw, info));
 
       return info;
     }
 
     template <>
     void
     chol<ComplexMatrix>::delete_sym (octave_idx_type j_arg)
     {
-      F77_INT n = octave::to_f77_int (chol_mat.rows ());
-      F77_INT j = octave::to_f77_int (j_arg);
+      F77_INT n = to_f77_int (chol_mat.rows ());
+      F77_INT j = to_f77_int (j_arg);
 
       if (j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("choldelete: index out of range");
 
       OCTAVE_LOCAL_BUFFER (double, rw, n);
 
       F77_XFCN (zchdex, ZCHDEX, (n,
                                  F77_DBLE_CMPLX_ARG (chol_mat.fortran_vec ()),
@@ -927,19 +927,19 @@ namespace octave
       chol_mat.resize (n-1, n-1);
     }
 
     template <>
     void
     chol<ComplexMatrix>::shift_sym (octave_idx_type i_arg,
                                     octave_idx_type j_arg)
     {
-      F77_INT n = octave::to_f77_int (chol_mat.rows ());
-      F77_INT i = octave::to_f77_int (i_arg);
-      F77_INT j = octave::to_f77_int (j_arg);
+      F77_INT n = to_f77_int (chol_mat.rows ());
+      F77_INT i = to_f77_int (i_arg);
+      F77_INT j = to_f77_int (j_arg);
 
       if (i < 0 || i > n-1 || j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("cholshift: index out of range");
 
       OCTAVE_LOCAL_BUFFER (Complex, w, n);
       OCTAVE_LOCAL_BUFFER (double, rw, n);
 
       F77_XFCN (zchshx, ZCHSHX, (n,
@@ -956,17 +956,17 @@ namespace octave
                                     bool calc_cond)
     {
       octave_idx_type a_nr = a.rows ();
       octave_idx_type a_nc = a.cols ();
 
       if (a_nr != a_nc)
         (*current_liboctave_error_handler) ("chol: requires square matrix");
 
-      F77_INT n = octave::to_f77_int (a_nc);
+      F77_INT n = to_f77_int (a_nc);
       F77_INT info;
 
       is_upper = upper;
 
       chol_mat.clear (n, n);
       if (is_upper)
         for (octave_idx_type j = 0; j < n; j++)
           {
@@ -1024,17 +1024,17 @@ namespace octave
     }
 
 #if defined (HAVE_QRUPDATE)
 
     template <>
     void
     chol<FloatComplexMatrix>::update (const FloatComplexColumnVector& u)
     {
-      F77_INT n = octave::to_f77_int (chol_mat.rows ());
+      F77_INT n = to_f77_int (chol_mat.rows ());
 
       if (u.numel () != n)
         (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
       FloatComplexColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (float, rw, n);
 
@@ -1043,17 +1043,17 @@ namespace octave
     }
 
     template <>
     octave_idx_type
     chol<FloatComplexMatrix>::downdate (const FloatComplexColumnVector& u)
     {
       F77_INT info = -1;
 
-      F77_INT n = octave::to_f77_int (chol_mat.rows ());
+      F77_INT n = to_f77_int (chol_mat.rows ());
 
       if (u.numel () != n)
         (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
       FloatComplexColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (float, rw, n);
 
@@ -1065,46 +1065,46 @@ namespace octave
     }
 
     template <>
     octave_idx_type
     chol<FloatComplexMatrix>::insert_sym (const FloatComplexColumnVector& u,
                                           octave_idx_type j_arg)
     {
       F77_INT info = -1;
-      F77_INT j = octave::to_f77_int (j_arg);
+      F77_INT j = to_f77_int (j_arg);
 
-      F77_INT n = octave::to_f77_int (chol_mat.rows ());
+      F77_INT n = to_f77_int (chol_mat.rows ());
 
       if (u.numel () != n + 1)
         (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
       if (j < 0 || j > n)
         (*current_liboctave_error_handler) ("cholinsert: index out of range");
 
       FloatComplexColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (float, rw, n);
 
       chol_mat.resize (n+1, n+1);
-      F77_INT ldcm = octave::to_f77_int (chol_mat.rows ());
+      F77_INT ldcm = to_f77_int (chol_mat.rows ());
 
       F77_XFCN (cchinx, CCHINX, (n, F77_CMPLX_ARG (chol_mat.fortran_vec ()),
                                  ldcm, j + 1,
                                  F77_CMPLX_ARG (utmp.fortran_vec ()),
                                  rw, info));
 
       return info;
     }
 
     template <>
     void
     chol<FloatComplexMatrix>::delete_sym (octave_idx_type j_arg)
     {
-      F77_INT n = octave::to_f77_int (chol_mat.rows ());
-      F77_INT j = octave::to_f77_int (j_arg);
+      F77_INT n = to_f77_int (chol_mat.rows ());
+      F77_INT j = to_f77_int (j_arg);
 
       if (j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("choldelete: index out of range");
 
       OCTAVE_LOCAL_BUFFER (float, rw, n);
 
       F77_XFCN (cchdex, CCHDEX, (n, F77_CMPLX_ARG (chol_mat.fortran_vec ()),
                                  n, j + 1, rw));
@@ -1112,19 +1112,19 @@ namespace octave
       chol_mat.resize (n-1, n-1);
     }
 
     template <>
     void
     chol<FloatComplexMatrix>::shift_sym (octave_idx_type i_arg,
                                          octave_idx_type j_arg)
     {
-      F77_INT n = octave::to_f77_int (chol_mat.rows ());
-      F77_INT i = octave::to_f77_int (i_arg);
-      F77_INT j = octave::to_f77_int (j_arg);
+      F77_INT n = to_f77_int (chol_mat.rows ());
+      F77_INT i = to_f77_int (i_arg);
+      F77_INT j = to_f77_int (j_arg);
 
       if (i < 0 || i > n-1 || j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("cholshift: index out of range");
 
       OCTAVE_LOCAL_BUFFER (FloatComplex, w, n);
       OCTAVE_LOCAL_BUFFER (float, rw, n);
 
       F77_XFCN (cchshx, CCHSHX, (n, F77_CMPLX_ARG (chol_mat.fortran_vec ()),
diff --git a/liboctave/numeric/gepbalance.cc b/liboctave/numeric/gepbalance.cc
--- a/liboctave/numeric/gepbalance.cc
+++ b/liboctave/numeric/gepbalance.cc
@@ -39,24 +39,24 @@ namespace octave
 {
   namespace math
   {
     template <>
     octave_idx_type
     gepbalance<Matrix>::init (const Matrix& a, const Matrix& b,
                               const std::string& balance_job)
     {
-      F77_INT n = octave::to_f77_int (a.cols ());
+      F77_INT n = to_f77_int (a.cols ());
 
       if (a.rows () != n)
         (*current_liboctave_error_handler)
           ("GEPBALANCE requires square matrix");
 
       if (a.dims () != b.dims ())
-        octave::err_nonconformant ("GEPBALANCE", n, n, b.rows(), b.cols());
+        err_nonconformant ("GEPBALANCE", n, n, b.rows(), b.cols());
 
       F77_INT info;
       F77_INT ilo;
       F77_INT ihi;
 
       OCTAVE_LOCAL_BUFFER (double, plscale, n);
       OCTAVE_LOCAL_BUFFER (double, prscale, n);
       OCTAVE_LOCAL_BUFFER (double, pwork, 6 * n);
@@ -104,24 +104,24 @@ namespace octave
       return info;
     }
 
     template <>
     octave_idx_type
     gepbalance<FloatMatrix>::init (const FloatMatrix& a, const FloatMatrix& b,
                                    const std::string& balance_job)
     {
-      F77_INT n = octave::to_f77_int (a.cols ());
+      F77_INT n = to_f77_int (a.cols ());
 
       if (a.rows () != n)
         (*current_liboctave_error_handler)
           ("FloatGEPBALANCE requires square matrix");
 
       if (a.dims () != b.dims ())
-        octave::err_nonconformant ("FloatGEPBALANCE",
+        err_nonconformant ("FloatGEPBALANCE",
                                    n, n, b.rows(), b.cols());
 
       F77_INT info;
       F77_INT ilo;
       F77_INT ihi;
 
       OCTAVE_LOCAL_BUFFER (float, plscale, n);
       OCTAVE_LOCAL_BUFFER (float, prscale, n);
@@ -171,24 +171,24 @@ namespace octave
     }
 
     template <>
     octave_idx_type
     gepbalance<ComplexMatrix>::init (const ComplexMatrix& a,
                                      const ComplexMatrix& b,
                                      const std::string& balance_job)
     {
-      F77_INT n = octave::to_f77_int (a.cols ());
+      F77_INT n = to_f77_int (a.cols ());
 
       if (a.rows () != n)
         (*current_liboctave_error_handler)
           ("ComplexGEPBALANCE requires square matrix");
 
       if (a.dims () != b.dims ())
-        octave::err_nonconformant ("ComplexGEPBALANCE",
+        err_nonconformant ("ComplexGEPBALANCE",
                                    n, n, b.rows(), b.cols());
 
       F77_INT info;
       F77_INT ilo;
       F77_INT ihi;
 
       OCTAVE_LOCAL_BUFFER (double, plscale, n);
       OCTAVE_LOCAL_BUFFER (double, prscale,  n);
@@ -239,27 +239,27 @@ namespace octave
     }
 
     template <>
     octave_idx_type
     gepbalance<FloatComplexMatrix>::init (const FloatComplexMatrix& a,
                                           const FloatComplexMatrix& b,
                                           const std::string& balance_job)
     {
-      F77_INT n = octave::to_f77_int (a.cols ());
+      F77_INT n = to_f77_int (a.cols ());
 
       if (a.rows () != n)
         {
           (*current_liboctave_error_handler)
             ("FloatComplexGEPBALANCE requires square matrix");
           return -1;
         }
 
       if (a.dims () != b.dims ())
-        octave::err_nonconformant ("FloatComplexGEPBALANCE",
+        err_nonconformant ("FloatComplexGEPBALANCE",
                                    n, n, b.rows(), b.cols());
 
       F77_INT info;
       F77_INT ilo;
       F77_INT ihi;
 
       OCTAVE_LOCAL_BUFFER (float, plscale, n);
       OCTAVE_LOCAL_BUFFER (float, prscale, n);
diff --git a/liboctave/numeric/gsvd.cc b/liboctave/numeric/gsvd.cc
--- a/liboctave/numeric/gsvd.cc
+++ b/liboctave/numeric/gsvd.cc
@@ -204,19 +204,19 @@ namespace octave
         return R;
     }
 
     template <typename T>
     gsvd<T>::gsvd (const T& a, const T& b, gsvd::Type gsvd_type)
     {
       F77_INT info;
 
-      F77_INT m = octave::to_f77_int (a.rows ());
-      F77_INT n = octave::to_f77_int (a.cols ());
-      F77_INT p = octave::to_f77_int (b.rows ());
+      F77_INT m = to_f77_int (a.rows ());
+      F77_INT n = to_f77_int (a.cols ());
+      F77_INT p = to_f77_int (b.rows ());
 
       T atmp = a;
       P *tmp_dataA = atmp.fortran_vec ();
 
       T btmp = b;
       P *tmp_dataB = btmp.fortran_vec ();
 
       char jobu = 'U';
diff --git a/liboctave/numeric/hess.cc b/liboctave/numeric/hess.cc
--- a/liboctave/numeric/hess.cc
+++ b/liboctave/numeric/hess.cc
@@ -36,18 +36,18 @@ along with Octave; see the file COPYING.
 namespace octave
 {
   namespace math
   {
     template <>
     octave_idx_type
     hess<Matrix>::init (const Matrix& a)
    {
-      F77_INT a_nr = octave::to_f77_int (a.rows ());
-      F77_INT a_nc = octave::to_f77_int (a.cols ());
+      F77_INT a_nr = to_f77_int (a.rows ());
+      F77_INT a_nc = to_f77_int (a.cols ());
 
       if (a_nr != a_nc)
         (*current_liboctave_error_handler) ("hess: requires square matrix");
 
       char job = 'N';
       char side = 'R';
 
       F77_INT n = a_nc;
@@ -99,18 +99,18 @@ namespace octave
 
       return info;
     }
 
     template <>
     octave_idx_type
     hess<FloatMatrix>::init (const FloatMatrix& a)
     {
-      F77_INT a_nr = octave::to_f77_int (a.rows ());
-      F77_INT a_nc = octave::to_f77_int (a.cols ());
+      F77_INT a_nr = to_f77_int (a.rows ());
+      F77_INT a_nc = to_f77_int (a.cols ());
 
       if (a_nr != a_nc)
         (*current_liboctave_error_handler) ("hess: requires square matrix");
 
       char job = 'N';
       char side = 'R';
 
       F77_INT n = a_nc;
@@ -162,18 +162,18 @@ namespace octave
 
       return info;
     }
 
     template <>
     octave_idx_type
     hess<ComplexMatrix>::init (const ComplexMatrix& a)
     {
-      F77_INT a_nr = octave::to_f77_int (a.rows ());
-      F77_INT a_nc = octave::to_f77_int (a.cols ());
+      F77_INT a_nr = to_f77_int (a.rows ());
+      F77_INT a_nc = to_f77_int (a.cols ());
 
       if (a_nr != a_nc)
         (*current_liboctave_error_handler) ("hess: requires square matrix");
 
       char job = 'N';
       char side = 'R';
 
       F77_INT n = a_nc;
@@ -225,18 +225,18 @@ namespace octave
 
       return info;
     }
 
     template <>
     octave_idx_type
     hess<FloatComplexMatrix>::init (const FloatComplexMatrix& a)
     {
-      F77_INT a_nr = octave::to_f77_int (a.rows ());
-      F77_INT a_nc = octave::to_f77_int (a.cols ());
+      F77_INT a_nr = to_f77_int (a.rows ());
+      F77_INT a_nc = to_f77_int (a.cols ());
 
       if (a_nr != a_nc)
         {
           (*current_liboctave_error_handler) ("hess: requires square matrix");
           return -1;
         }
 
       char job = 'N';
diff --git a/liboctave/numeric/lo-mappers.h b/liboctave/numeric/lo-mappers.h
--- a/liboctave/numeric/lo-mappers.h
+++ b/liboctave/numeric/lo-mappers.h
@@ -34,30 +34,30 @@ along with Octave; see the file COPYING.
 #include "oct-cmplx.h"
 #include "oct-inttypes-fwd.h"
 
 namespace octave
 {
   namespace math
   {
     extern OCTAVE_API bool isna (double x);
-    OCTAVE_DEPRECATED (4.4, "use 'octave::math::isna' instead")
-    inline bool is_NA (double x) { return octave::math::isna (x); }
+    OCTAVE_DEPRECATED (4.4, "use 'math::isna' instead")
+    inline bool is_NA (double x) { return math::isna (x); }
 
     extern OCTAVE_API bool isna (float x);
-    OCTAVE_DEPRECATED (4.4, "use 'octave::math::isna' instead")
-    inline bool is_NA (float x) { return octave::math::isna (x); }
+    OCTAVE_DEPRECATED (4.4, "use 'math::isna' instead")
+    inline bool is_NA (float x) { return math::isna (x); }
 
     extern OCTAVE_API bool isna (const Complex& x);
-    OCTAVE_DEPRECATED (4.4, "use 'octave::math::isna' instead")
-    inline bool is_NA (const Complex& x) { return octave::math::isna (x); }
+    OCTAVE_DEPRECATED (4.4, "use 'math::isna' instead")
+    inline bool is_NA (const Complex& x) { return math::isna (x); }
 
     extern OCTAVE_API bool isna (const FloatComplex& x);
-    OCTAVE_DEPRECATED (4.4, "use 'octave::math::isna' instead")
-    inline bool is_NA (const FloatComplex& x) { return octave::math::isna (x); }
+    OCTAVE_DEPRECATED (4.4, "use 'math::isna' instead")
+    inline bool is_NA (const FloatComplex& x) { return math::isna (x); }
 
     extern OCTAVE_API bool is_NaN_or_NA (const Complex& x);
     extern OCTAVE_API bool is_NaN_or_NA (const FloatComplex& x);
 
     inline double copysign (double x, double y) { return std::copysign (x, y); }
     inline float copysign (float x, float y) { return std::copysignf (x, y); }
 
     inline double signbit (double x) { return std::signbit (x); }
@@ -244,27 +244,27 @@ namespace octave
 
     template <typename T>
     bool
     isfinite (const std::complex<T>& x)
     {
       return (isfinite (std::real (x)) && isfinite (std::imag (x)));
     }
 
-    OCTAVE_DEPRECATED (4.4, "use 'octave::math::isfinite' instead")
-    inline bool finite (double x) { return octave::math::isfinite (x); }
-    OCTAVE_DEPRECATED (4.4, "use 'octave::math::isfinite' instead")
-    inline bool finite (float x) { return octave::math::isfinite (x); }
+    OCTAVE_DEPRECATED (4.4, "use 'math::isfinite' instead")
+    inline bool finite (double x) { return math::isfinite (x); }
+    OCTAVE_DEPRECATED (4.4, "use 'math::isfinite' instead")
+    inline bool finite (float x) { return math::isfinite (x); }
 
     template <typename T>
-    OCTAVE_DEPRECATED (4.4, "use 'octave::math::isfinite' instead")
+    OCTAVE_DEPRECATED (4.4, "use 'math::isfinite' instead")
     bool
     finite (const std::complex<T>& x)
     {
-      return octave::math::isfinite (x);
+      return math::isfinite (x);
     }
 
     inline bool isinf (double x) { return std::isinf (x); }
     inline bool isinf (float x) { return std::isinf (x); }
 
     template <typename T>
     bool
     isinf (const std::complex<T>& x)
@@ -283,30 +283,30 @@ namespace octave
     {
       double tmp = 0.0;
 
       if (x < 0.0)
         tmp = -1.0;
       else if (x > 0.0)
         tmp = 1.0;
 
-      return isnan (x) ? octave::numeric_limits<double>::NaN () : tmp;
+      return isnan (x) ? numeric_limits<double>::NaN () : tmp;
     }
 
     inline float
     signum (float x)
     {
       float tmp = 0.0f;
 
       if (x < 0.0f)
         tmp = -1.0f;
       else if (x > 0.0f)
         tmp = 1.0f;
 
-      return isnan (x) ? octave::numeric_limits<float>::NaN () : tmp;
+      return isnan (x) ? numeric_limits<float>::NaN () : tmp;
     }
 
     template <typename T>
     std::complex<T>
     signum (const std::complex<T>& x)
     {
       T tmp = abs (x);
 
@@ -377,17 +377,17 @@ namespace octave
 
     template <typename T>
     T
     rem (T x, T y)
     {
       T retval;
 
       if (y == 0)
-        retval = octave::numeric_limits<T>::NaN ();
+        retval = numeric_limits<T>::NaN ();
       else
         {
           T q = x / y;
 
           if (x_nint (y) != y
               && (std::abs ((q - x_nint (q)) / x_nint (q))
                   < std::numeric_limits<T>::epsilon ()))
             retval = 0;
diff --git a/liboctave/numeric/lo-specfun.cc b/liboctave/numeric/lo-specfun.cc
--- a/liboctave/numeric/lo-specfun.cc
+++ b/liboctave/numeric/lo-specfun.cc
@@ -59,22 +59,22 @@ along with Octave; see the file COPYING.
 namespace octave
 {
   namespace math
   {
     static inline Complex
     bessel_return_value (const Complex& val, octave_idx_type ierr)
     {
       static const Complex inf_val
-        = Complex (octave::numeric_limits<double>::Inf (),
-                   octave::numeric_limits<double>::Inf ());
+        = Complex (numeric_limits<double>::Inf (),
+                   numeric_limits<double>::Inf ());
 
       static const Complex nan_val
-        = Complex (octave::numeric_limits<double>::NaN (),
-                   octave::numeric_limits<double>::NaN ());
+        = Complex (numeric_limits<double>::NaN (),
+                   numeric_limits<double>::NaN ());
 
       Complex retval;
 
       switch (ierr)
         {
         case 0:
         case 3:
           retval = val;
@@ -91,22 +91,22 @@ namespace octave
 
       return retval;
     }
 
     static inline FloatComplex
     bessel_return_value (const FloatComplex& val, octave_idx_type ierr)
     {
       static const FloatComplex inf_val
-        = FloatComplex (octave::numeric_limits<float>::Inf (),
-                        octave::numeric_limits<float>::Inf ());
+        = FloatComplex (numeric_limits<float>::Inf (),
+                        numeric_limits<float>::Inf ());
 
       static const FloatComplex nan_val
-        = FloatComplex (octave::numeric_limits<float>::NaN (),
-                        octave::numeric_limits<float>::NaN ());
+        = FloatComplex (numeric_limits<float>::NaN (),
+                        numeric_limits<float>::NaN ());
 
       FloatComplex retval;
 
       switch (ierr)
         {
         case 0:
         case 3:
           retval = val;
@@ -337,18 +337,18 @@ namespace octave
 
           if (ierr == 0 || ierr == 3)
             {
               tmp -= sin (M_PI * alpha) * zbesy (z, alpha, kode, ierr);
 
               retval = bessel_return_value (tmp, ierr);
             }
           else
-            retval = Complex (octave::numeric_limits<double>::NaN (),
-                              octave::numeric_limits<double>::NaN ());
+            retval = Complex (numeric_limits<double>::NaN (),
+                              numeric_limits<double>::NaN ());
         }
 
       return retval;
     }
 
     static inline Complex
     zbesy (const Complex& z, double alpha, int kode, octave_idx_type& ierr)
     {
@@ -365,17 +365,17 @@ namespace octave
 
           double zr = z.real ();
           double zi = z.imag ();
 
           ierr = 0;
 
           if (zr == 0.0 && zi == 0.0)
             {
-              yr = -octave::numeric_limits<double>::Inf ();
+              yr = -numeric_limits<double>::Inf ();
               yi = 0.0;
             }
           else
             {
               F77_FUNC (zbesy, ZBESY) (zr, zi, alpha, 2, 1, &yr, &yi, nz,
                                        &wr, &wi, t_ierr);
 
               ierr = t_ierr;
@@ -410,18 +410,18 @@ namespace octave
 
           if (ierr == 0 || ierr == 3)
             {
               tmp += sin (M_PI * alpha) * zbesj (z, alpha, kode, ierr);
 
               retval = bessel_return_value (tmp, ierr);
             }
           else
-            retval = Complex (octave::numeric_limits<double>::NaN (),
-                              octave::numeric_limits<double>::NaN ());
+            retval = Complex (numeric_limits<double>::NaN (),
+                              numeric_limits<double>::NaN ());
         }
 
       return retval;
     }
 
     static inline Complex
     zbesi (const Complex& z, double alpha, int kode, octave_idx_type& ierr)
     {
@@ -477,18 +477,18 @@ namespace octave
                   tmp2 *= exp (-z - std::abs (z.real ()));
                 }
 
               tmp += tmp2;
 
               retval = bessel_return_value (tmp, ierr);
             }
           else
-            retval = Complex (octave::numeric_limits<double>::NaN (),
-                              octave::numeric_limits<double>::NaN ());
+            retval = Complex (numeric_limits<double>::NaN (),
+                              numeric_limits<double>::NaN ());
         }
 
       return retval;
     }
 
     static inline Complex
     zbesk (const Complex& z, double alpha, int kode, octave_idx_type& ierr)
     {
@@ -503,17 +503,17 @@ namespace octave
 
           double zr = z.real ();
           double zi = z.imag ();
 
           ierr = 0;
 
           if (zr == 0.0 && zi == 0.0)
             {
-              yr = octave::numeric_limits<double>::Inf ();
+              yr = numeric_limits<double>::Inf ();
               yi = 0.0;
             }
           else
             {
               F77_FUNC (zbesk, ZBESK) (zr, zi, alpha, 2, 1, &yr, &yi, nz,
                                        t_ierr);
 
               ierr = t_ierr;
@@ -957,18 +957,18 @@ namespace octave
           if (ierr == 0 || ierr == 3)
             {
               tmp -= sinf (static_cast<float> (M_PI) * alpha)
                      * cbesy (z, alpha, kode, ierr);
 
               retval = bessel_return_value (tmp, ierr);
             }
           else
-            retval = FloatComplex (octave::numeric_limits<float>::NaN (),
-                                   octave::numeric_limits<float>::NaN ());
+            retval = FloatComplex (numeric_limits<float>::NaN (),
+                                   numeric_limits<float>::NaN ());
         }
 
       return retval;
     }
 
     static inline FloatComplex
     cbesy (const FloatComplex& z, float alpha, int kode, octave_idx_type& ierr)
     {
@@ -981,17 +981,17 @@ namespace octave
           F77_INT nz, t_ierr;
 
           FloatComplex w;
 
           ierr = 0;
 
           if (z.real () == 0.0 && z.imag () == 0.0)
             {
-              y = FloatComplex (-octave::numeric_limits<float>::Inf (), 0.0);
+              y = FloatComplex (-numeric_limits<float>::Inf (), 0.0);
             }
           else
             {
               F77_FUNC (cbesy, CBESY) (F77_CONST_CMPLX_ARG (&z), alpha, 2, 1,
                                        F77_CMPLX_ARG (&y), nz,
                                        F77_CMPLX_ARG (&w), t_ierr);
 
               ierr = t_ierr;
@@ -1027,18 +1027,18 @@ namespace octave
           if (ierr == 0 || ierr == 3)
             {
               tmp += sinf (static_cast<float> (M_PI) * alpha)
                      * cbesj (z, alpha, kode, ierr);
 
               retval = bessel_return_value (tmp, ierr);
             }
           else
-            retval = FloatComplex (octave::numeric_limits<float>::NaN (),
-                                   octave::numeric_limits<float>::NaN ());
+            retval = FloatComplex (numeric_limits<float>::NaN (),
+                                   numeric_limits<float>::NaN ());
         }
 
       return retval;
     }
 
     static inline FloatComplex
     cbesi (const FloatComplex& z, float alpha, int kode, octave_idx_type& ierr)
     {
@@ -1084,18 +1084,18 @@ namespace octave
                   tmp2 *= exp (-z - std::abs (z.real ()));
                 }
 
               tmp += tmp2;
 
               retval = bessel_return_value (tmp, ierr);
             }
           else
-            retval = FloatComplex (octave::numeric_limits<float>::NaN (),
-                                   octave::numeric_limits<float>::NaN ());
+            retval = FloatComplex (numeric_limits<float>::NaN (),
+                                   numeric_limits<float>::NaN ());
         }
 
       return retval;
     }
 
     static inline FloatComplex
     cbesk (const FloatComplex& z, float alpha, int kode, octave_idx_type& ierr)
     {
@@ -1106,17 +1106,17 @@ namespace octave
           FloatComplex y = 0.0;
 
           F77_INT nz, t_ierr;
 
           ierr = 0;
 
           if (z.real () == 0.0 && z.imag () == 0.0)
             {
-              y = FloatComplex (octave::numeric_limits<float>::Inf (), 0.0);
+              y = FloatComplex (numeric_limits<float>::Inf (), 0.0);
             }
           else
             {
               F77_FUNC (cbesk, CBESK) (F77_CONST_CMPLX_ARG (&z), alpha, 2, 1,
                                        F77_CMPLX_ARG (&y), nz, t_ierr);
 
               ierr = t_ierr;
 
@@ -2595,21 +2595,21 @@ namespace octave
           const double yd = (((d[0]*q + d[1])*q + d[2])*q + d[3])*q + 1.0;
 
           y = yn / yd;
 
           if (x < pbreak_lo)
             y = -y;
         }
       else if (x == 0.0)
-        return octave::numeric_limits<double>::Inf ();
+        return numeric_limits<double>::Inf ();
       else if (x == 2.0)
-        return -octave::numeric_limits<double>::Inf ();
+        return -numeric_limits<double>::Inf ();
       else
-        return octave::numeric_limits<double>::NaN ();
+        return numeric_limits<double>::NaN ();
 
       if (refine)
         {
           // One iteration of Halley's method gives full precision.
           double u = (erf (y) - (1-x)) * spi2 * exp (y*y);
           y -= u / (1 + y*u);
         }
 
@@ -2713,22 +2713,22 @@ namespace octave
           y = yn / yd;
         }
       else if (ax < 1.0)
         {
           // Tail region.
           const double q = std::sqrt (-2*std::log (0.5*(1-ax)));
           const double yn = ((((c[0]*q + c[1])*q + c[2])*q + c[3])*q + c[4])*q + c[5];
           const double yd = (((d[0]*q + d[1])*q + d[2])*q + d[3])*q + 1.0;
-          y = yn / yd * octave::math::signum (-x);
+          y = yn / yd * math::signum (-x);
         }
       else if (ax == 1.0)
-        return octave::numeric_limits<double>::Inf () * octave::math::signum (x);
+        return numeric_limits<double>::Inf () * math::signum (x);
       else
-        return octave::numeric_limits<double>::NaN ();
+        return numeric_limits<double>::NaN ();
 
       if (refine)
         {
           // One iteration of Halley's method gives full precision.
           double u = (erf (y) - x) * spi2 * exp (y*y);
           y -= u / (1 + y*u);
         }
 
@@ -2787,47 +2787,47 @@ namespace octave
     gamma (double x)
     {
       double result;
 
       // Special cases for (near) compatibility with Matlab instead of tgamma.
       // Matlab does not have -0.
 
       if (x == 0)
-        result = (octave::math::negative_sign (x)
-                  ? -octave::numeric_limits<double>::Inf ()
-                  : octave::numeric_limits<double>::Inf ());
-      else if ((x < 0 && octave::math::x_nint (x) == x)
-               || octave::math::isinf (x))
-        result = octave::numeric_limits<double>::Inf ();
-      else if (octave::math::isnan (x))
-        result = octave::numeric_limits<double>::NaN ();
+        result = (math::negative_sign (x)
+                  ? -numeric_limits<double>::Inf ()
+                  : numeric_limits<double>::Inf ());
+      else if ((x < 0 && math::x_nint (x) == x)
+               || math::isinf (x))
+        result = numeric_limits<double>::Inf ();
+      else if (math::isnan (x))
+        result = numeric_limits<double>::NaN ();
       else
         result = std::tgamma (x);
 
       return result;
     }
 
     float
     gamma (float x)
     {
       float result;
 
       // Special cases for (near) compatibility with Matlab instead of tgamma.
       // Matlab does not have -0.
 
       if (x == 0)
-        result = (octave::math::negative_sign (x)
-                  ? -octave::numeric_limits<float>::Inf ()
-                  : octave::numeric_limits<float>::Inf ());
-      else if ((x < 0 && octave::math::x_nint (x) == x)
-               || octave::math::isinf (x))
-        result = octave::numeric_limits<float>::Inf ();
-      else if (octave::math::isnan (x))
-        result = octave::numeric_limits<float>::NaN ();
+        result = (math::negative_sign (x)
+                  ? -numeric_limits<float>::Inf ()
+                  : numeric_limits<float>::Inf ());
+      else if ((x < 0 && math::x_nint (x) == x)
+               || math::isinf (x))
+        result = numeric_limits<float>::Inf ();
+      else if (math::isnan (x))
+        result = numeric_limits<float>::NaN ();
       else
         result = std::tgammaf (x);
 
       return result;
     }
 
     // FIXME: there is still room for improvement here...
 
@@ -3247,36 +3247,36 @@ namespace octave
 
     template <typename T>
     T
     xpsi (T z)
     {
       static const double euler_mascheroni =
         0.577215664901532860606512090082402431042;
 
-      const bool is_int = (octave::math::floor (z) == z);
+      const bool is_int = (math::floor (z) == z);
 
       T p = 0;
       if (z <= 0)
         {
           // limits - zeros of the gamma function
           if (is_int)
-            p = -octave::numeric_limits<T>::Inf (); // Matlab returns -Inf for psi (0)
+            p = -numeric_limits<T>::Inf (); // Matlab returns -Inf for psi (0)
           else
             // Abramowitz and Stegun, page 259, eq 6.3.7
             p = psi (1 - z) - (pi / tan (pi * z));
         }
       else if (is_int)
         {
           // Abramowitz and Stegun, page 258, eq 6.3.2
           p = - euler_mascheroni;
           for (octave_idx_type k = z - 1; k > 0; k--)
             p += 1.0 / k;
         }
-      else if (octave::math::floor (z + 0.5) == z + 0.5)
+      else if (math::floor (z + 0.5) == z + 0.5)
         {
           // Abramowitz and Stegun, page 258, eq 6.3.3 and 6.3.4
           for (octave_idx_type k = z; k > 0; k--)
             p += 1.0 / (2 * k - 1);
 
           p = - euler_mascheroni - 2 * std::log (2) + 2 * (p);
         }
       else
@@ -3355,29 +3355,29 @@ namespace octave
     static inline void
     fortran_psifn (T z, octave_idx_type n, T& ans, octave_idx_type& ierr);
 
     template <>
     inline void
     fortran_psifn<double> (double z, octave_idx_type n_arg,
                            double& ans, octave_idx_type& ierr)
     {
-      F77_INT n = octave::to_f77_int (n_arg);
+      F77_INT n = to_f77_int (n_arg);
       F77_INT flag = 0;
       F77_INT t_ierr;
       F77_XFCN (dpsifn, DPSIFN, (z, n, 1, 1, ans, flag, t_ierr));
       ierr = t_ierr;
     }
 
     template <>
     inline void
     fortran_psifn<float> (float z, octave_idx_type n_arg,
                           float& ans, octave_idx_type& ierr)
     {
-      F77_INT n = octave::to_f77_int (n_arg);
+      F77_INT n = to_f77_int (n_arg);
       F77_INT flag = 0;
       F77_INT t_ierr;
       F77_XFCN (psifn, PSIFN, (z, n, 1, 1, ans, flag, t_ierr));
       ierr = t_ierr;
     }
 
     template <typename T>
     T
@@ -3394,19 +3394,19 @@ namespace octave
           if (n > 1)
             // FIXME: xgamma here is a killer for our precision since it grows
             //        way too fast.
             ans = ans / (std::pow (-1.0, n + 1) / gamma (double (n+1)));
           else if (n == 0)
             ans = -ans;
         }
       else if (ierr == 2)
-        ans = - octave::numeric_limits<T>::Inf ();
+        ans = - numeric_limits<T>::Inf ();
       else // we probably never get here
-        ans = octave::numeric_limits<T>::NaN ();
+        ans = numeric_limits<T>::NaN ();
 
       return ans;
     }
 
     double psi (octave_idx_type n, double z) { return xpsi (n, z); }
     float psi (octave_idx_type n, float z) { return xpsi (n, z); }
 
     Complex
diff --git a/liboctave/numeric/lu.cc b/liboctave/numeric/lu.cc
--- a/liboctave/numeric/lu.cc
+++ b/liboctave/numeric/lu.cc
@@ -250,18 +250,18 @@ namespace octave
 
 #endif
 
     // Specializations.
 
     template <>
     lu<Matrix>::lu (const Matrix& a)
     {
-      F77_INT a_nr = octave::to_f77_int (a.rows ());
-      F77_INT a_nc = octave::to_f77_int (a.columns ());
+      F77_INT a_nr = to_f77_int (a.rows ());
+      F77_INT a_nc = to_f77_int (a.columns ());
       F77_INT mn = (a_nr < a_nc ? a_nr : a_nc);
 
       ipvt.resize (dim_vector (mn, 1));
       F77_INT *pipvt = ipvt.fortran_vec ();
 
       a_fact = a;
       double *tmp_data = a_fact.fortran_vec ();
 
@@ -280,22 +280,22 @@ namespace octave
     lu<Matrix>::update (const ColumnVector& u, const ColumnVector& v)
     {
       if (packed ())
         unpack ();
 
       Matrix& l = l_fact;
       Matrix& r = a_fact;
 
-      F77_INT m = octave::to_f77_int (l.rows ());
-      F77_INT n = octave::to_f77_int (r.columns ());
-      F77_INT k = octave::to_f77_int (l.columns ());
+      F77_INT m = to_f77_int (l.rows ());
+      F77_INT n = to_f77_int (r.columns ());
+      F77_INT k = to_f77_int (l.columns ());
 
-      F77_INT u_nel = octave::to_f77_int (u.numel ());
-      F77_INT v_nel = octave::to_f77_int (v.numel ());
+      F77_INT u_nel = to_f77_int (u.numel ());
+      F77_INT v_nel = to_f77_int (v.numel ());
 
       if (u_nel != m || v_nel != n)
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       ColumnVector utmp = u;
       ColumnVector vtmp = v;
       F77_XFCN (dlu1up, DLU1UP, (m, n, l.fortran_vec (), m, r.fortran_vec (),
                                  k, utmp.fortran_vec (), vtmp.fortran_vec ()));
@@ -306,25 +306,25 @@ namespace octave
     lu<Matrix>::update (const Matrix& u, const Matrix& v)
     {
       if (packed ())
         unpack ();
 
       Matrix& l = l_fact;
       Matrix& r = a_fact;
 
-      F77_INT m = octave::to_f77_int (l.rows ());
-      F77_INT n = octave::to_f77_int (r.columns ());
-      F77_INT k = octave::to_f77_int (l.columns ());
+      F77_INT m = to_f77_int (l.rows ());
+      F77_INT n = to_f77_int (r.columns ());
+      F77_INT k = to_f77_int (l.columns ());
 
-      F77_INT u_nr = octave::to_f77_int (u.rows ());
-      F77_INT u_nc = octave::to_f77_int (u.columns ());
+      F77_INT u_nr = to_f77_int (u.rows ());
+      F77_INT u_nc = to_f77_int (u.columns ());
 
-      F77_INT v_nr = octave::to_f77_int (v.rows ());
-      F77_INT v_nc = octave::to_f77_int (v.columns ());
+      F77_INT v_nr = to_f77_int (v.rows ());
+      F77_INT v_nc = to_f77_int (v.columns ());
 
       if (u_nr != m || v_nr != n || u_nc != v_nc)
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       for (volatile F77_INT i = 0; i < u_nc; i++)
         {
           ColumnVector utmp = u.column (i);
           ColumnVector vtmp = v.column (i);
@@ -339,22 +339,22 @@ namespace octave
     lu<Matrix>::update_piv (const ColumnVector& u, const ColumnVector& v)
     {
       if (packed ())
         unpack ();
 
       Matrix& l = l_fact;
       Matrix& r = a_fact;
 
-      F77_INT m = octave::to_f77_int (l.rows ());
-      F77_INT n = octave::to_f77_int (r.columns ());
-      F77_INT k = octave::to_f77_int (l.columns ());
+      F77_INT m = to_f77_int (l.rows ());
+      F77_INT n = to_f77_int (r.columns ());
+      F77_INT k = to_f77_int (l.columns ());
 
-      F77_INT u_nel = octave::to_f77_int (u.numel ());
-      F77_INT v_nel = octave::to_f77_int (v.numel ());
+      F77_INT u_nel = to_f77_int (u.numel ());
+      F77_INT v_nel = to_f77_int (v.numel ());
 
       if (u_nel != m || v_nel != n)
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       ColumnVector utmp = u;
       ColumnVector vtmp = v;
       OCTAVE_LOCAL_BUFFER (double, w, m);
       for (F77_INT i = 0; i < m; i++) ipvt(i) += 1; // increment
@@ -370,25 +370,25 @@ namespace octave
     lu<Matrix>::update_piv (const Matrix& u, const Matrix& v)
     {
       if (packed ())
         unpack ();
 
       Matrix& l = l_fact;
       Matrix& r = a_fact;
 
-      F77_INT m = octave::to_f77_int (l.rows ());
-      F77_INT n = octave::to_f77_int (r.columns ());
-      F77_INT k = octave::to_f77_int (l.columns ());
+      F77_INT m = to_f77_int (l.rows ());
+      F77_INT n = to_f77_int (r.columns ());
+      F77_INT k = to_f77_int (l.columns ());
 
-      F77_INT u_nr = octave::to_f77_int (u.rows ());
-      F77_INT u_nc = octave::to_f77_int (u.columns ());
+      F77_INT u_nr = to_f77_int (u.rows ());
+      F77_INT u_nc = to_f77_int (u.columns ());
 
-      F77_INT v_nr = octave::to_f77_int (v.rows ());
-      F77_INT v_nc = octave::to_f77_int (v.columns ());
+      F77_INT v_nr = to_f77_int (v.rows ());
+      F77_INT v_nc = to_f77_int (v.columns ());
 
       if (u_nr != m || v_nr != n || u_nc != v_nc)
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       OCTAVE_LOCAL_BUFFER (double, w, m);
       for (F77_INT i = 0; i < m; i++) ipvt(i) += 1; // increment
       for (volatile F77_INT i = 0; i < u_nc; i++)
         {
@@ -402,18 +402,18 @@ namespace octave
       for (F77_INT i = 0; i < m; i++) ipvt(i) -= 1; // decrement
     }
 
 #endif
 
     template <>
     lu<FloatMatrix>::lu (const FloatMatrix& a)
     {
-      F77_INT a_nr = octave::to_f77_int (a.rows ());
-      F77_INT a_nc = octave::to_f77_int (a.columns ());
+      F77_INT a_nr = to_f77_int (a.rows ());
+      F77_INT a_nc = to_f77_int (a.columns ());
       F77_INT mn = (a_nr < a_nc ? a_nr : a_nc);
 
       ipvt.resize (dim_vector (mn, 1));
       F77_INT *pipvt = ipvt.fortran_vec ();
 
       a_fact = a;
       float *tmp_data = a_fact.fortran_vec ();
 
@@ -433,22 +433,22 @@ namespace octave
                              const FloatColumnVector& v)
     {
       if (packed ())
         unpack ();
 
       FloatMatrix& l = l_fact;
       FloatMatrix& r = a_fact;
 
-      F77_INT m = octave::to_f77_int (l.rows ());
-      F77_INT n = octave::to_f77_int (r.columns ());
-      F77_INT k = octave::to_f77_int (l.columns ());
+      F77_INT m = to_f77_int (l.rows ());
+      F77_INT n = to_f77_int (r.columns ());
+      F77_INT k = to_f77_int (l.columns ());
 
-      F77_INT u_nel = octave::to_f77_int (u.numel ());
-      F77_INT v_nel = octave::to_f77_int (v.numel ());
+      F77_INT u_nel = to_f77_int (u.numel ());
+      F77_INT v_nel = to_f77_int (v.numel ());
 
       if (u_nel != m || v_nel != n)
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       FloatColumnVector utmp = u;
       FloatColumnVector vtmp = v;
       F77_XFCN (slu1up, SLU1UP, (m, n, l.fortran_vec (),
                                  m, r.fortran_vec (), k,
@@ -460,25 +460,25 @@ namespace octave
     lu<FloatMatrix>::update (const FloatMatrix& u, const FloatMatrix& v)
     {
       if (packed ())
         unpack ();
 
       FloatMatrix& l = l_fact;
       FloatMatrix& r = a_fact;
 
-      F77_INT m = octave::to_f77_int (l.rows ());
-      F77_INT n = octave::to_f77_int (r.columns ());
-      F77_INT k = octave::to_f77_int (l.columns ());
+      F77_INT m = to_f77_int (l.rows ());
+      F77_INT n = to_f77_int (r.columns ());
+      F77_INT k = to_f77_int (l.columns ());
 
-      F77_INT u_nr = octave::to_f77_int (u.rows ());
-      F77_INT u_nc = octave::to_f77_int (u.columns ());
+      F77_INT u_nr = to_f77_int (u.rows ());
+      F77_INT u_nc = to_f77_int (u.columns ());
 
-      F77_INT v_nr = octave::to_f77_int (v.rows ());
-      F77_INT v_nc = octave::to_f77_int (v.columns ());
+      F77_INT v_nr = to_f77_int (v.rows ());
+      F77_INT v_nc = to_f77_int (v.columns ());
 
       if (u_nr != m || v_nr != n || u_nc != v_nc)
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       for (volatile F77_INT i = 0; i < u_nc; i++)
         {
           FloatColumnVector utmp = u.column (i);
           FloatColumnVector vtmp = v.column (i);
@@ -494,22 +494,22 @@ namespace octave
                                  const FloatColumnVector& v)
     {
       if (packed ())
         unpack ();
 
       FloatMatrix& l = l_fact;
       FloatMatrix& r = a_fact;
 
-      F77_INT m = octave::to_f77_int (l.rows ());
-      F77_INT n = octave::to_f77_int (r.columns ());
-      F77_INT k = octave::to_f77_int (l.columns ());
+      F77_INT m = to_f77_int (l.rows ());
+      F77_INT n = to_f77_int (r.columns ());
+      F77_INT k = to_f77_int (l.columns ());
 
-      F77_INT u_nel = octave::to_f77_int (u.numel ());
-      F77_INT v_nel = octave::to_f77_int (v.numel ());
+      F77_INT u_nel = to_f77_int (u.numel ());
+      F77_INT v_nel = to_f77_int (v.numel ());
 
       if (u_nel != m || v_nel != n)
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       FloatColumnVector utmp = u;
       FloatColumnVector vtmp = v;
       OCTAVE_LOCAL_BUFFER (float, w, m);
       for (F77_INT i = 0; i < m; i++) ipvt(i) += 1; // increment
@@ -525,25 +525,25 @@ namespace octave
     lu<FloatMatrix>::update_piv (const FloatMatrix& u, const FloatMatrix& v)
     {
       if (packed ())
         unpack ();
 
       FloatMatrix& l = l_fact;
       FloatMatrix& r = a_fact;
 
-      F77_INT m = octave::to_f77_int (l.rows ());
-      F77_INT n = octave::to_f77_int (r.columns ());
-      F77_INT k = octave::to_f77_int (l.columns ());
+      F77_INT m = to_f77_int (l.rows ());
+      F77_INT n = to_f77_int (r.columns ());
+      F77_INT k = to_f77_int (l.columns ());
 
-      F77_INT u_nr = octave::to_f77_int (u.rows ());
-      F77_INT u_nc = octave::to_f77_int (u.columns ());
+      F77_INT u_nr = to_f77_int (u.rows ());
+      F77_INT u_nc = to_f77_int (u.columns ());
 
-      F77_INT v_nr = octave::to_f77_int (v.rows ());
-      F77_INT v_nc = octave::to_f77_int (v.columns ());
+      F77_INT v_nr = to_f77_int (v.rows ());
+      F77_INT v_nc = to_f77_int (v.columns ());
 
       if (u_nr != m || v_nr != n || u_nc != v_nc)
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       OCTAVE_LOCAL_BUFFER (float, w, m);
       for (F77_INT i = 0; i < m; i++) ipvt(i) += 1; // increment
       for (volatile F77_INT i = 0; i < u_nc; i++)
         {
@@ -557,18 +557,18 @@ namespace octave
       for (F77_INT i = 0; i < m; i++) ipvt(i) -= 1; // decrement
     }
 
 #endif
 
     template <>
     lu<ComplexMatrix>::lu (const ComplexMatrix& a)
     {
-      F77_INT a_nr = octave::to_f77_int (a.rows ());
-      F77_INT a_nc = octave::to_f77_int (a.columns ());
+      F77_INT a_nr = to_f77_int (a.rows ());
+      F77_INT a_nc = to_f77_int (a.columns ());
       F77_INT mn = (a_nr < a_nc ? a_nr : a_nc);
 
       ipvt.resize (dim_vector (mn, 1));
       F77_INT *pipvt = ipvt.fortran_vec ();
 
       a_fact = a;
       Complex *tmp_data = a_fact.fortran_vec ();
 
@@ -589,22 +589,22 @@ namespace octave
                                const ComplexColumnVector& v)
     {
       if (packed ())
         unpack ();
 
       ComplexMatrix& l = l_fact;
       ComplexMatrix& r = a_fact;
 
-      F77_INT m = octave::to_f77_int (l.rows ());
-      F77_INT n = octave::to_f77_int (r.columns ());
-      F77_INT k = octave::to_f77_int (l.columns ());
+      F77_INT m = to_f77_int (l.rows ());
+      F77_INT n = to_f77_int (r.columns ());
+      F77_INT k = to_f77_int (l.columns ());
 
-      F77_INT u_nel = octave::to_f77_int (u.numel ());
-      F77_INT v_nel = octave::to_f77_int (v.numel ());
+      F77_INT u_nel = to_f77_int (u.numel ());
+      F77_INT v_nel = to_f77_int (v.numel ());
 
       if (u_nel != m || v_nel != n)
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       ComplexColumnVector utmp = u;
       ComplexColumnVector vtmp = v;
       F77_XFCN (zlu1up, ZLU1UP, (m, n, F77_DBLE_CMPLX_ARG (l.fortran_vec ()), m,
                                  F77_DBLE_CMPLX_ARG (r.fortran_vec ()), k,
@@ -617,25 +617,25 @@ namespace octave
     lu<ComplexMatrix>::update (const ComplexMatrix& u, const ComplexMatrix& v)
     {
       if (packed ())
         unpack ();
 
       ComplexMatrix& l = l_fact;
       ComplexMatrix& r = a_fact;
 
-      F77_INT m = octave::to_f77_int (l.rows ());
-      F77_INT n = octave::to_f77_int (r.columns ());
-      F77_INT k = octave::to_f77_int (l.columns ());
+      F77_INT m = to_f77_int (l.rows ());
+      F77_INT n = to_f77_int (r.columns ());
+      F77_INT k = to_f77_int (l.columns ());
 
-      F77_INT u_nr = octave::to_f77_int (u.rows ());
-      F77_INT u_nc = octave::to_f77_int (u.columns ());
+      F77_INT u_nr = to_f77_int (u.rows ());
+      F77_INT u_nc = to_f77_int (u.columns ());
 
-      F77_INT v_nr = octave::to_f77_int (v.rows ());
-      F77_INT v_nc = octave::to_f77_int (v.columns ());
+      F77_INT v_nr = to_f77_int (v.rows ());
+      F77_INT v_nc = to_f77_int (v.columns ());
 
       if (u_nr != m || v_nr != n || u_nc != v_nc)
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       for (volatile F77_INT i = 0; i < u_nc; i++)
         {
           ComplexColumnVector utmp = u.column (i);
           ComplexColumnVector vtmp = v.column (i);
@@ -654,22 +654,22 @@ namespace octave
                                    const ComplexColumnVector& v)
     {
       if (packed ())
         unpack ();
 
       ComplexMatrix& l = l_fact;
       ComplexMatrix& r = a_fact;
 
-      F77_INT m = octave::to_f77_int (l.rows ());
-      F77_INT n = octave::to_f77_int (r.columns ());
-      F77_INT k = octave::to_f77_int (l.columns ());
+      F77_INT m = to_f77_int (l.rows ());
+      F77_INT n = to_f77_int (r.columns ());
+      F77_INT k = to_f77_int (l.columns ());
 
-      F77_INT u_nel = octave::to_f77_int (u.numel ());
-      F77_INT v_nel = octave::to_f77_int (v.numel ());
+      F77_INT u_nel = to_f77_int (u.numel ());
+      F77_INT v_nel = to_f77_int (v.numel ());
 
       if (u_nel != m || v_nel != n)
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       ComplexColumnVector utmp = u;
       ComplexColumnVector vtmp = v;
       OCTAVE_LOCAL_BUFFER (Complex, w, m);
       for (F77_INT i = 0; i < m; i++) ipvt(i) += 1; // increment
@@ -688,25 +688,25 @@ namespace octave
                                    const ComplexMatrix& v)
     {
       if (packed ())
         unpack ();
 
       ComplexMatrix& l = l_fact;
       ComplexMatrix& r = a_fact;
 
-      F77_INT m = octave::to_f77_int (l.rows ());
-      F77_INT n = octave::to_f77_int (r.columns ());
-      F77_INT k = octave::to_f77_int (l.columns ());
+      F77_INT m = to_f77_int (l.rows ());
+      F77_INT n = to_f77_int (r.columns ());
+      F77_INT k = to_f77_int (l.columns ());
 
-      F77_INT u_nr = octave::to_f77_int (u.rows ());
-      F77_INT u_nc = octave::to_f77_int (u.columns ());
+      F77_INT u_nr = to_f77_int (u.rows ());
+      F77_INT u_nc = to_f77_int (u.columns ());
 
-      F77_INT v_nr = octave::to_f77_int (v.rows ());
-      F77_INT v_nc = octave::to_f77_int (v.columns ());
+      F77_INT v_nr = to_f77_int (v.rows ());
+      F77_INT v_nc = to_f77_int (v.columns ());
 
       if (u_nr != m || v_nr != n || u_nc != v_nc)
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       OCTAVE_LOCAL_BUFFER (Complex, w, m);
       for (F77_INT i = 0; i < m; i++) ipvt(i) += 1; // increment
       for (volatile F77_INT i = 0; i < u_nc; i++)
         {
@@ -724,18 +724,18 @@ namespace octave
       for (F77_INT i = 0; i < m; i++) ipvt(i) -= 1; // decrement
     }
 
 #endif
 
     template <>
     lu<FloatComplexMatrix>::lu (const FloatComplexMatrix& a)
     {
-      F77_INT a_nr = octave::to_f77_int (a.rows ());
-      F77_INT a_nc = octave::to_f77_int (a.columns ());
+      F77_INT a_nr = to_f77_int (a.rows ());
+      F77_INT a_nc = to_f77_int (a.columns ());
       F77_INT mn = (a_nr < a_nc ? a_nr : a_nc);
 
       ipvt.resize (dim_vector (mn, 1));
       F77_INT *pipvt = ipvt.fortran_vec ();
 
       a_fact = a;
       FloatComplex *tmp_data = a_fact.fortran_vec ();
 
@@ -756,22 +756,22 @@ namespace octave
                                     const FloatComplexColumnVector& v)
     {
       if (packed ())
         unpack ();
 
       FloatComplexMatrix& l = l_fact;
       FloatComplexMatrix& r = a_fact;
 
-      F77_INT m = octave::to_f77_int (l.rows ());
-      F77_INT n = octave::to_f77_int (r.columns ());
-      F77_INT k = octave::to_f77_int (l.columns ());
+      F77_INT m = to_f77_int (l.rows ());
+      F77_INT n = to_f77_int (r.columns ());
+      F77_INT k = to_f77_int (l.columns ());
 
-      F77_INT u_nel = octave::to_f77_int (u.numel ());
-      F77_INT v_nel = octave::to_f77_int (v.numel ());
+      F77_INT u_nel = to_f77_int (u.numel ());
+      F77_INT v_nel = to_f77_int (v.numel ());
 
       if (u_nel != m || v_nel != n)
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       FloatComplexColumnVector utmp = u;
       FloatComplexColumnVector vtmp = v;
       F77_XFCN (clu1up, CLU1UP, (m, n, F77_CMPLX_ARG (l.fortran_vec ()), m,
                                  F77_CMPLX_ARG (r.fortran_vec ()), k,
@@ -785,25 +785,25 @@ namespace octave
                                     const FloatComplexMatrix& v)
     {
       if (packed ())
         unpack ();
 
       FloatComplexMatrix& l = l_fact;
       FloatComplexMatrix& r = a_fact;
 
-      F77_INT m = octave::to_f77_int (l.rows ());
-      F77_INT n = octave::to_f77_int (r.columns ());
-      F77_INT k = octave::to_f77_int (l.columns ());
+      F77_INT m = to_f77_int (l.rows ());
+      F77_INT n = to_f77_int (r.columns ());
+      F77_INT k = to_f77_int (l.columns ());
 
-      F77_INT u_nr = octave::to_f77_int (u.rows ());
-      F77_INT u_nc = octave::to_f77_int (u.columns ());
+      F77_INT u_nr = to_f77_int (u.rows ());
+      F77_INT u_nc = to_f77_int (u.columns ());
 
-      F77_INT v_nr = octave::to_f77_int (v.rows ());
-      F77_INT v_nc = octave::to_f77_int (v.columns ());
+      F77_INT v_nr = to_f77_int (v.rows ());
+      F77_INT v_nc = to_f77_int (v.columns ());
 
       if (u_nr != m || v_nr != n || u_nc != v_nc)
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       for (volatile F77_INT i = 0; i < u_nc; i++)
         {
           FloatComplexColumnVector utmp = u.column (i);
           FloatComplexColumnVector vtmp = v.column (i);
@@ -820,22 +820,22 @@ namespace octave
                                         const FloatComplexColumnVector& v)
     {
       if (packed ())
         unpack ();
 
       FloatComplexMatrix& l = l_fact;
       FloatComplexMatrix& r = a_fact;
 
-      F77_INT m = octave::to_f77_int (l.rows ());
-      F77_INT n = octave::to_f77_int (r.columns ());
-      F77_INT k = octave::to_f77_int (l.columns ());
+      F77_INT m = to_f77_int (l.rows ());
+      F77_INT n = to_f77_int (r.columns ());
+      F77_INT k = to_f77_int (l.columns ());
 
-      F77_INT u_nel = octave::to_f77_int (u.numel ());
-      F77_INT v_nel = octave::to_f77_int (v.numel ());
+      F77_INT u_nel = to_f77_int (u.numel ());
+      F77_INT v_nel = to_f77_int (v.numel ());
 
       if (u_nel != m || v_nel != n)
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       FloatComplexColumnVector utmp = u;
       FloatComplexColumnVector vtmp = v;
       OCTAVE_LOCAL_BUFFER (FloatComplex, w, m);
       for (F77_INT i = 0; i < m; i++) ipvt(i) += 1; // increment
@@ -854,25 +854,25 @@ namespace octave
                                         const FloatComplexMatrix& v)
     {
       if (packed ())
         unpack ();
 
       FloatComplexMatrix& l = l_fact;
       FloatComplexMatrix& r = a_fact;
 
-      F77_INT m = octave::to_f77_int (l.rows ());
-      F77_INT n = octave::to_f77_int (r.columns ());
-      F77_INT k = octave::to_f77_int (l.columns ());
+      F77_INT m = to_f77_int (l.rows ());
+      F77_INT n = to_f77_int (r.columns ());
+      F77_INT k = to_f77_int (l.columns ());
 
-      F77_INT u_nr = octave::to_f77_int (u.rows ());
-      F77_INT u_nc = octave::to_f77_int (u.columns ());
+      F77_INT u_nr = to_f77_int (u.rows ());
+      F77_INT u_nc = to_f77_int (u.columns ());
 
-      F77_INT v_nr = octave::to_f77_int (v.rows ());
-      F77_INT v_nc = octave::to_f77_int (v.columns ());
+      F77_INT v_nr = to_f77_int (v.rows ());
+      F77_INT v_nc = to_f77_int (v.columns ());
 
       if (u_nr != m || v_nr != n || u_nc != v_nc)
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       OCTAVE_LOCAL_BUFFER (FloatComplex, w, m);
       for (F77_INT i = 0; i < m; i++) ipvt(i) += 1; // increment
       for (volatile F77_INT i = 0; i < u_nc; i++)
         {
diff --git a/liboctave/numeric/qr.cc b/liboctave/numeric/qr.cc
--- a/liboctave/numeric/qr.cc
+++ b/liboctave/numeric/qr.cc
@@ -235,17 +235,17 @@ namespace octave
       octave_idx_type n = r.cols ();
 
       if (u.numel () != m)
         (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
 
       if (j < 0 || j > n)
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
-      init (octave::math::insert_col (q*r, j, u), get_type ());
+      init (math::insert_col (q*r, j, u), get_type ());
     }
 
     template <typename T>
     void
     qr<T>::insert_col (const T& u, const Array<octave_idx_type>& j)
     {
       warn_qrupdate_once ();
 
@@ -267,34 +267,34 @@ namespace octave
 
       if (nj > 0 && (js(0) < 0 || js(nj-1) > n))
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
       if (nj > 0)
         {
           T a = q*r;
           for (octave_idx_type i = 0; i < nj; i++)
-            a = octave::math::insert_col (a, js(i), u.column (i));
+            a = math::insert_col (a, js(i), u.column (i));
 
           init (a, get_type ());
         }
     }
 
     template <typename T>
     void
     qr<T>::delete_col (octave_idx_type j)
     {
       warn_qrupdate_once ();
 
       octave_idx_type n = r.cols ();
 
       if (j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("qrdelete: index out of range");
 
-      init (octave::math::delete_col (q*r, j), get_type ());
+      init (math::delete_col (q*r, j), get_type ());
     }
 
     template <typename T>
     void
     qr<T>::delete_col (const Array<octave_idx_type>& j)
     {
       warn_qrupdate_once ();
 
@@ -312,17 +312,17 @@ namespace octave
 
       if (nj > 0 && (js(0) > n-1 || js(nj-1) < 0))
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
       if (nj > 0)
         {
           T a = q*r;
           for (octave_idx_type i = 0; i < nj; i++)
-            a = octave::math::delete_col (a, js(i));
+            a = math::delete_col (a, js(i));
 
           init (a, get_type ());
         }
     }
 
     template <typename T>
     void
     qr<T>::insert_row (const RV_T& u, octave_idx_type j)
@@ -333,61 +333,61 @@ namespace octave
       octave_idx_type n = r.cols ();
 
       if (! q.issquare () || u.numel () != n)
         (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
 
       if (j < 0 || j > m)
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
-      init (octave::math::insert_row (q*r, j, u), get_type ());
+      init (math::insert_row (q*r, j, u), get_type ());
     }
 
     template <typename T>
     void
     qr<T>::delete_row (octave_idx_type j)
     {
       warn_qrupdate_once ();
 
       octave_idx_type m = r.rows ();
 
       if (! q.issquare ())
         (*current_liboctave_error_handler) ("qrdelete: dimensions mismatch");
 
       if (j < 0 || j > m-1)
         (*current_liboctave_error_handler) ("qrdelete: index out of range");
 
-      init (octave::math::delete_row (q*r, j), get_type ());
+      init (math::delete_row (q*r, j), get_type ());
     }
 
     template <typename T>
     void
     qr<T>::shift_cols (octave_idx_type i, octave_idx_type j)
     {
       warn_qrupdate_once ();
 
       octave_idx_type n = r.cols ();
 
       if (i < 0 || i > n-1 || j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("qrshift: index out of range");
 
-      init (octave::math::shift_cols (q*r, i, j), get_type ());
+      init (math::shift_cols (q*r, i, j), get_type ());
     }
 
 #endif
 
     // Specializations.
 
     template <>
     void
     qr<Matrix>::form (octave_idx_type n_arg, Matrix& afact, double *tau,
                       type qr_type)
     {
-      F77_INT n = octave::to_f77_int (n_arg);
-      F77_INT m = octave::to_f77_int (afact.rows ());
+      F77_INT n = to_f77_int (n_arg);
+      F77_INT m = to_f77_int (afact.rows ());
       F77_INT min_mn = std::min (m, n);
       F77_INT info;
 
       if (qr_type == qr<Matrix>::raw)
         {
           for (F77_INT j = 0; j < min_mn; j++)
             {
               F77_INT limit = (j < min_mn - 1 ? j : min_mn - 1);
@@ -426,17 +426,17 @@ namespace octave
                     q.xelem (i, j) = afact.xelem (i, j);
                     afact.xelem (i, j) = 0;
                   }
               r = afact;
             }
 
           if (m > 0)
             {
-              F77_INT k = octave::to_f77_int (q.cols ());
+              F77_INT k = to_f77_int (q.cols ());
               // workspace query.
               double rlwork;
               F77_XFCN (dorgqr, DORGQR, (m, k, min_mn, q.fortran_vec (), m,
                                          tau, &rlwork, -1, info));
 
               // allocate buffer and do the job.
               F77_INT lwork = static_cast<F77_INT> (rlwork);
               lwork = std::max (lwork, static_cast<F77_INT> (1));
@@ -446,18 +446,18 @@ namespace octave
             }
         }
     }
 
     template <>
     void
     qr<Matrix>::init (const Matrix& a, type qr_type)
     {
-      F77_INT m = octave::to_f77_int (a.rows ());
-      F77_INT n = octave::to_f77_int (a.cols ());
+      F77_INT m = to_f77_int (a.rows ());
+      F77_INT n = to_f77_int (a.cols ());
 
       F77_INT min_mn = (m < n ? m : n);
       OCTAVE_LOCAL_BUFFER (double, tau, min_mn);
 
       F77_INT info = 0;
 
       Matrix afact = a;
       if (m > n && qr_type == qr<Matrix>::std)
@@ -482,47 +482,47 @@ namespace octave
     }
 
 #if defined (HAVE_QRUPDATE)
 
     template <>
     void
     qr<Matrix>::update (const ColumnVector& u, const ColumnVector& v)
     {
-      F77_INT m = octave::to_f77_int (q.rows ());
-      F77_INT n = octave::to_f77_int (r.cols ());
-      F77_INT k = octave::to_f77_int (q.cols ());
+      F77_INT m = to_f77_int (q.rows ());
+      F77_INT n = to_f77_int (r.cols ());
+      F77_INT k = to_f77_int (q.cols ());
 
-      F77_INT u_nel = octave::to_f77_int (u.numel ());
-      F77_INT v_nel = octave::to_f77_int (v.numel ());
+      F77_INT u_nel = to_f77_int (u.numel ());
+      F77_INT v_nel = to_f77_int (v.numel ());
 
       if (u_nel != m || v_nel != n)
         (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 
       ColumnVector utmp = u;
       ColumnVector vtmp = v;
       OCTAVE_LOCAL_BUFFER (double, w, 2*k);
       F77_XFCN (dqr1up, DQR1UP, (m, n, k, q.fortran_vec (), m,
                                  r.fortran_vec (), k, utmp.fortran_vec (),
                                  vtmp.fortran_vec (), w));
     }
 
     template <>
     void
     qr<Matrix>::update (const Matrix& u, const Matrix& v)
     {
-      F77_INT m = octave::to_f77_int (q.rows ());
-      F77_INT n = octave::to_f77_int (r.cols ());
-      F77_INT k = octave::to_f77_int (q.cols ());
+      F77_INT m = to_f77_int (q.rows ());
+      F77_INT n = to_f77_int (r.cols ());
+      F77_INT k = to_f77_int (q.cols ());
 
-      F77_INT u_rows = octave::to_f77_int (u.rows ());
-      F77_INT u_cols = octave::to_f77_int (u.cols ());
+      F77_INT u_rows = to_f77_int (u.rows ());
+      F77_INT u_cols = to_f77_int (u.cols ());
 
-      F77_INT v_rows = octave::to_f77_int (v.rows ());
-      F77_INT v_cols = octave::to_f77_int (v.cols ());
+      F77_INT v_rows = to_f77_int (v.rows ());
+      F77_INT v_cols = to_f77_int (v.cols ());
 
       if (u_rows != m || v_rows != n || u_cols != v_cols)
         (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 
       OCTAVE_LOCAL_BUFFER (double, w, 2*k);
       for (volatile F77_INT i = 0; i < u_cols; i++)
         {
           ColumnVector utmp = u.column (i);
@@ -532,121 +532,121 @@ namespace octave
                                      vtmp.fortran_vec (), w));
         }
     }
 
     template <>
     void
     qr<Matrix>::insert_col (const ColumnVector& u, octave_idx_type j_arg)
     {
-      F77_INT j = octave::to_f77_int (j_arg);
+      F77_INT j = to_f77_int (j_arg);
 
-      F77_INT m = octave::to_f77_int (q.rows ());
-      F77_INT n = octave::to_f77_int (r.cols ());
-      F77_INT k = octave::to_f77_int (q.cols ());
+      F77_INT m = to_f77_int (q.rows ());
+      F77_INT n = to_f77_int (r.cols ());
+      F77_INT k = to_f77_int (q.cols ());
 
-      F77_INT u_nel = octave::to_f77_int (u.numel ());
+      F77_INT u_nel = to_f77_int (u.numel ());
 
       if (u_nel != m)
         (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
 
       if (j < 0 || j > n)
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
       if (k < m)
         {
           q.resize (m, k+1);
           r.resize (k+1, n+1);
         }
       else
         r.resize (k, n+1);
 
-      F77_INT ldq = octave::to_f77_int (q.rows ());
-      F77_INT ldr = octave::to_f77_int (r.rows ());
+      F77_INT ldq = to_f77_int (q.rows ());
+      F77_INT ldr = to_f77_int (r.rows ());
 
       ColumnVector utmp = u;
       OCTAVE_LOCAL_BUFFER (double, w, k);
       F77_XFCN (dqrinc, DQRINC, (m, n, k, q.fortran_vec (), ldq,
                                  r.fortran_vec (), ldr, j + 1,
                                  utmp.data (), w));
     }
 
     template <>
     void
     qr<Matrix>::insert_col (const Matrix& u, const Array<octave_idx_type>& j)
     {
-      F77_INT m = octave::to_f77_int (q.rows ());
-      F77_INT n = octave::to_f77_int (r.cols ());
-      F77_INT k = octave::to_f77_int (q.cols ());
+      F77_INT m = to_f77_int (q.rows ());
+      F77_INT n = to_f77_int (r.cols ());
+      F77_INT k = to_f77_int (q.cols ());
 
       Array<octave_idx_type> jsi;
       Array<octave_idx_type> js = j.sort (jsi, 0, ASCENDING);
-      F77_INT nj = octave::to_f77_int (js.numel ());
+      F77_INT nj = to_f77_int (js.numel ());
       bool dups = false;
       for (F77_INT i = 0; i < nj - 1; i++)
         dups = dups && js(i) == js(i+1);
 
       if (dups)
         (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
 
-      F77_INT u_nel = octave::to_f77_int (u.numel ());
-      F77_INT u_cols = octave::to_f77_int (u.cols ());
+      F77_INT u_nel = to_f77_int (u.numel ());
+      F77_INT u_cols = to_f77_int (u.cols ());
 
       if (u_nel != m || u_cols != nj)
         (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
 
-      F77_INT js_beg = octave::to_f77_int (js(0));
-      F77_INT js_end = octave::to_f77_int (js(nj-1));
+      F77_INT js_beg = to_f77_int (js(0));
+      F77_INT js_end = to_f77_int (js(nj-1));
 
       if (nj > 0 && (js_beg < 0 || js_end > n))
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
       if (nj > 0)
         {
           F77_INT kmax = std::min (k + nj, m);
           if (k < m)
             {
               q.resize (m, kmax);
               r.resize (kmax, n + nj);
             }
           else
             r.resize (k, n + nj);
 
-          F77_INT ldq = octave::to_f77_int (q.rows ());
-          F77_INT ldr = octave::to_f77_int (r.rows ());
+          F77_INT ldq = to_f77_int (q.rows ());
+          F77_INT ldr = to_f77_int (r.rows ());
 
           OCTAVE_LOCAL_BUFFER (double, w, kmax);
           for (volatile F77_INT i = 0; i < nj; i++)
             {
               F77_INT ii = i;
               ColumnVector utmp = u.column (jsi(i));
-              F77_INT js_elt = octave::to_f77_int (js(ii));
+              F77_INT js_elt = to_f77_int (js(ii));
               F77_XFCN (dqrinc, DQRINC, (m, n + ii, std::min (kmax, k + ii),
                                          q.fortran_vec (), ldq,
                                          r.fortran_vec (), ldr, js_elt + 1,
                                          utmp.data (), w));
             }
         }
     }
 
     template <>
     void
     qr<Matrix>::delete_col (octave_idx_type j_arg)
     {
-      F77_INT j = octave::to_f77_int (j_arg);
+      F77_INT j = to_f77_int (j_arg);
 
-      F77_INT m = octave::to_f77_int (q.rows ());
-      F77_INT k = octave::to_f77_int (r.rows ());
-      F77_INT n = octave::to_f77_int (r.cols ());
+      F77_INT m = to_f77_int (q.rows ());
+      F77_INT k = to_f77_int (r.rows ());
+      F77_INT n = to_f77_int (r.cols ());
 
       if (j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("qrdelete: index out of range");
 
-      F77_INT ldq = octave::to_f77_int (q.rows ());
-      F77_INT ldr = octave::to_f77_int (r.rows ());
+      F77_INT ldq = to_f77_int (q.rows ());
+      F77_INT ldr = to_f77_int (r.rows ());
 
       OCTAVE_LOCAL_BUFFER (double, w, k);
       F77_XFCN (dqrdec, DQRDEC, (m, n, k, q.fortran_vec (), ldq,
                                  r.fortran_vec (), ldr, j + 1, w));
 
       if (k < m)
         {
           q.resize (m, k-1);
@@ -655,46 +655,46 @@ namespace octave
       else
         r.resize (k, n-1);
     }
 
     template <>
     void
     qr<Matrix>::delete_col (const Array<octave_idx_type>& j)
     {
-      F77_INT m = octave::to_f77_int (q.rows ());
-      F77_INT n = octave::to_f77_int (r.cols ());
-      F77_INT k = octave::to_f77_int (q.cols ());
+      F77_INT m = to_f77_int (q.rows ());
+      F77_INT n = to_f77_int (r.cols ());
+      F77_INT k = to_f77_int (q.cols ());
 
       Array<octave_idx_type> jsi;
       Array<octave_idx_type> js = j.sort (jsi, 0, DESCENDING);
-      F77_INT nj = octave::to_f77_int (js.numel ());
+      F77_INT nj = to_f77_int (js.numel ());
       bool dups = false;
       for (F77_INT i = 0; i < nj - 1; i++)
         dups = dups && js(i) == js(i+1);
 
       if (dups)
         (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
 
-      F77_INT js_beg = octave::to_f77_int (js(0));
-      F77_INT js_end = octave::to_f77_int (js(nj-1));
+      F77_INT js_beg = to_f77_int (js(0));
+      F77_INT js_end = to_f77_int (js(nj-1));
 
       if (nj > 0 && (js_beg > n-1 || js_end < 0))
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
       if (nj > 0)
         {
-          F77_INT ldq = octave::to_f77_int (q.rows ());
-          F77_INT ldr = octave::to_f77_int (r.rows ());
+          F77_INT ldq = to_f77_int (q.rows ());
+          F77_INT ldr = to_f77_int (r.rows ());
 
           OCTAVE_LOCAL_BUFFER (double, w, k);
           for (volatile F77_INT i = 0; i < nj; i++)
             {
               F77_INT ii = i;
-              F77_INT js_elt = octave::to_f77_int (js(ii));
+              F77_INT js_elt = to_f77_int (js(ii));
               F77_XFCN (dqrdec, DQRDEC, (m, n - ii, (k == m ? k : k - ii),
                                          q.fortran_vec (), ldq,
                                          r.fortran_vec (), ldr,
                                          js_elt + 1, w));
             }
 
           if (k < m)
             {
@@ -705,103 +705,103 @@ namespace octave
             r.resize (k, n - nj);
         }
     }
 
     template <>
     void
     qr<Matrix>::insert_row (const RowVector& u, octave_idx_type j_arg)
     {
-      F77_INT j = octave::to_f77_int (j_arg);
+      F77_INT j = to_f77_int (j_arg);
 
-      F77_INT m = octave::to_f77_int (r.rows ());
-      F77_INT n = octave::to_f77_int (r.cols ());
+      F77_INT m = to_f77_int (r.rows ());
+      F77_INT n = to_f77_int (r.cols ());
       F77_INT k = std::min (m, n);
 
-      F77_INT u_nel = octave::to_f77_int (u.numel ());
+      F77_INT u_nel = to_f77_int (u.numel ());
 
       if (! q.issquare () || u_nel != n)
         (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
 
       if (j < 0 || j > m)
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
       q.resize (m + 1, m + 1);
       r.resize (m + 1, n);
 
-      F77_INT ldq = octave::to_f77_int (q.rows ());
-      F77_INT ldr = octave::to_f77_int (r.rows ());
+      F77_INT ldq = to_f77_int (q.rows ());
+      F77_INT ldr = to_f77_int (r.rows ());
 
       RowVector utmp = u;
       OCTAVE_LOCAL_BUFFER (double, w, k);
       F77_XFCN (dqrinr, DQRINR, (m, n, q.fortran_vec (), ldq,
                                  r.fortran_vec (), ldr,
                                  j + 1, utmp.fortran_vec (), w));
 
     }
 
     template <>
     void
     qr<Matrix>::delete_row (octave_idx_type j_arg)
     {
-      F77_INT j = octave::to_f77_int (j_arg);
+      F77_INT j = to_f77_int (j_arg);
 
-      F77_INT m = octave::to_f77_int (r.rows ());
-      F77_INT n = octave::to_f77_int (r.cols ());
+      F77_INT m = to_f77_int (r.rows ());
+      F77_INT n = to_f77_int (r.cols ());
 
       if (! q.issquare ())
         (*current_liboctave_error_handler) ("qrdelete: dimensions mismatch");
 
       if (j < 0 || j > m-1)
         (*current_liboctave_error_handler) ("qrdelete: index out of range");
 
-      F77_INT ldq = octave::to_f77_int (q.rows ());
-      F77_INT ldr = octave::to_f77_int (r.rows ());
+      F77_INT ldq = to_f77_int (q.rows ());
+      F77_INT ldr = to_f77_int (r.rows ());
 
       OCTAVE_LOCAL_BUFFER (double, w, 2*m);
       F77_XFCN (dqrder, DQRDER, (m, n, q.fortran_vec (), ldq,
                                  r.fortran_vec (), ldr, j + 1, w));
 
       q.resize (m - 1, m - 1);
       r.resize (m - 1, n);
     }
 
     template <>
     void
     qr<Matrix>::shift_cols (octave_idx_type i_arg, octave_idx_type j_arg)
     {
-      F77_INT i = octave::to_f77_int (i_arg);
-      F77_INT j = octave::to_f77_int (j_arg);
+      F77_INT i = to_f77_int (i_arg);
+      F77_INT j = to_f77_int (j_arg);
 
-      F77_INT m = octave::to_f77_int (q.rows ());
-      F77_INT k = octave::to_f77_int (r.rows ());
-      F77_INT n = octave::to_f77_int (r.cols ());
+      F77_INT m = to_f77_int (q.rows ());
+      F77_INT k = to_f77_int (r.rows ());
+      F77_INT n = to_f77_int (r.cols ());
 
       if (i < 0 || i > n-1 || j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("qrshift: index out of range");
 
-      F77_INT ldq = octave::to_f77_int (q.rows ());
-      F77_INT ldr = octave::to_f77_int (r.rows ());
+      F77_INT ldq = to_f77_int (q.rows ());
+      F77_INT ldr = to_f77_int (r.rows ());
 
       OCTAVE_LOCAL_BUFFER (double, w, 2*k);
       F77_XFCN (dqrshc, DQRSHC, (m, n, k,
                                  q.fortran_vec (), ldq,
                                  r.fortran_vec (), ldr,
                                  i + 1, j + 1, w));
     }
 
 #endif
 
     template <>
     void
     qr<FloatMatrix>::form (octave_idx_type n_arg, FloatMatrix& afact,
                            float *tau, type qr_type)
     {
-      F77_INT n = octave::to_f77_int (n_arg);
-      F77_INT m = octave::to_f77_int (afact.rows ());
+      F77_INT n = to_f77_int (n_arg);
+      F77_INT m = to_f77_int (afact.rows ());
       F77_INT min_mn = std::min (m, n);
       F77_INT info;
 
       if (qr_type == qr<FloatMatrix>::raw)
         {
           for (F77_INT j = 0; j < min_mn; j++)
             {
               F77_INT limit = (j < min_mn - 1 ? j : min_mn - 1);
@@ -840,17 +840,17 @@ namespace octave
                     q.xelem (i, j) = afact.xelem (i, j);
                     afact.xelem (i, j) = 0;
                   }
               r = afact;
             }
 
           if (m > 0)
             {
-              F77_INT k = octave::to_f77_int (q.cols ());
+              F77_INT k = to_f77_int (q.cols ());
               // workspace query.
               float rlwork;
               F77_XFCN (sorgqr, SORGQR, (m, k, min_mn, q.fortran_vec (), m,
                                          tau, &rlwork, -1, info));
 
               // allocate buffer and do the job.
               F77_INT lwork = static_cast<F77_INT> (rlwork);
               lwork = std::max (lwork, static_cast<F77_INT> (1));
@@ -860,18 +860,18 @@ namespace octave
             }
         }
     }
 
     template <>
     void
     qr<FloatMatrix>::init (const FloatMatrix& a, type qr_type)
     {
-      F77_INT m = octave::to_f77_int (a.rows ());
-      F77_INT n = octave::to_f77_int (a.cols ());
+      F77_INT m = to_f77_int (a.rows ());
+      F77_INT n = to_f77_int (a.cols ());
 
       F77_INT min_mn = (m < n ? m : n);
       OCTAVE_LOCAL_BUFFER (float, tau, min_mn);
 
       F77_INT info = 0;
 
       FloatMatrix afact = a;
       if (m > n && qr_type == qr<FloatMatrix>::std)
@@ -896,47 +896,47 @@ namespace octave
     }
 
 #if defined (HAVE_QRUPDATE)
 
     template <>
     void
     qr<FloatMatrix>::update (const FloatColumnVector& u, const FloatColumnVector& v)
     {
-      F77_INT m = octave::to_f77_int (q.rows ());
-      F77_INT n = octave::to_f77_int (r.cols ());
-      F77_INT k = octave::to_f77_int (q.cols ());
+      F77_INT m = to_f77_int (q.rows ());
+      F77_INT n = to_f77_int (r.cols ());
+      F77_INT k = to_f77_int (q.cols ());
 
-      F77_INT u_nel = octave::to_f77_int (u.numel ());
-      F77_INT v_nel = octave::to_f77_int (v.numel ());
+      F77_INT u_nel = to_f77_int (u.numel ());
+      F77_INT v_nel = to_f77_int (v.numel ());
 
       if (u_nel != m || v_nel != n)
         (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 
       FloatColumnVector utmp = u;
       FloatColumnVector vtmp = v;
       OCTAVE_LOCAL_BUFFER (float, w, 2*k);
       F77_XFCN (sqr1up, SQR1UP, (m, n, k, q.fortran_vec (), m,
                                  r.fortran_vec (), k, utmp.fortran_vec (),
                                  vtmp.fortran_vec (), w));
     }
 
     template <>
     void
     qr<FloatMatrix>::update (const FloatMatrix& u, const FloatMatrix& v)
     {
-      F77_INT m = octave::to_f77_int (q.rows ());
-      F77_INT n = octave::to_f77_int (r.cols ());
-      F77_INT k = octave::to_f77_int (q.cols ());
+      F77_INT m = to_f77_int (q.rows ());
+      F77_INT n = to_f77_int (r.cols ());
+      F77_INT k = to_f77_int (q.cols ());
 
-      F77_INT u_rows = octave::to_f77_int (u.rows ());
-      F77_INT u_cols = octave::to_f77_int (u.cols ());
+      F77_INT u_rows = to_f77_int (u.rows ());
+      F77_INT u_cols = to_f77_int (u.cols ());
 
-      F77_INT v_rows = octave::to_f77_int (v.rows ());
-      F77_INT v_cols = octave::to_f77_int (v.cols ());
+      F77_INT v_rows = to_f77_int (v.rows ());
+      F77_INT v_cols = to_f77_int (v.cols ());
 
       if (u_rows != m || v_rows != n || u_cols != v_cols)
         (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 
       OCTAVE_LOCAL_BUFFER (float, w, 2*k);
       for (volatile F77_INT i = 0; i < u_cols; i++)
         {
           FloatColumnVector utmp = u.column (i);
@@ -947,122 +947,122 @@ namespace octave
         }
     }
 
     template <>
     void
     qr<FloatMatrix>::insert_col (const FloatColumnVector& u,
                                  octave_idx_type j_arg)
     {
-      F77_INT j = octave::to_f77_int (j_arg);
+      F77_INT j = to_f77_int (j_arg);
 
-      F77_INT m = octave::to_f77_int (q.rows ());
-      F77_INT n = octave::to_f77_int (r.cols ());
-      F77_INT k = octave::to_f77_int (q.cols ());
+      F77_INT m = to_f77_int (q.rows ());
+      F77_INT n = to_f77_int (r.cols ());
+      F77_INT k = to_f77_int (q.cols ());
 
-      F77_INT u_nel = octave::to_f77_int (u.numel ());
+      F77_INT u_nel = to_f77_int (u.numel ());
 
       if (u_nel != m)
         (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
 
       if (j < 0 || j > n)
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
       if (k < m)
         {
           q.resize (m, k+1);
           r.resize (k+1, n+1);
         }
       else
         r.resize (k, n+1);
 
-      F77_INT ldq = octave::to_f77_int (q.rows ());
-      F77_INT ldr = octave::to_f77_int (r.rows ());
+      F77_INT ldq = to_f77_int (q.rows ());
+      F77_INT ldr = to_f77_int (r.rows ());
 
       FloatColumnVector utmp = u;
       OCTAVE_LOCAL_BUFFER (float, w, k);
       F77_XFCN (sqrinc, SQRINC, (m, n, k, q.fortran_vec (), ldq,
                                  r.fortran_vec (), ldr, j + 1,
                                  utmp.data (), w));
     }
 
     template <>
     void
     qr<FloatMatrix>::insert_col (const FloatMatrix& u,
                                  const Array<octave_idx_type>& j)
     {
-      F77_INT m = octave::to_f77_int (q.rows ());
-      F77_INT n = octave::to_f77_int (r.cols ());
-      F77_INT k = octave::to_f77_int (q.cols ());
+      F77_INT m = to_f77_int (q.rows ());
+      F77_INT n = to_f77_int (r.cols ());
+      F77_INT k = to_f77_int (q.cols ());
 
       Array<octave_idx_type> jsi;
       Array<octave_idx_type> js = j.sort (jsi, 0, ASCENDING);
-      F77_INT nj = octave::to_f77_int (js.numel ());
+      F77_INT nj = to_f77_int (js.numel ());
       bool dups = false;
       for (F77_INT i = 0; i < nj - 1; i++)
         dups = dups && js(i) == js(i+1);
 
       if (dups)
         (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
 
-      F77_INT u_nel = octave::to_f77_int (u.numel ());
-      F77_INT u_cols = octave::to_f77_int (u.cols ());
+      F77_INT u_nel = to_f77_int (u.numel ());
+      F77_INT u_cols = to_f77_int (u.cols ());
 
       if (u_nel != m || u_cols != nj)
         (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
 
-      F77_INT js_beg = octave::to_f77_int (js(0));
-      F77_INT js_end = octave::to_f77_int (js(nj-1));
+      F77_INT js_beg = to_f77_int (js(0));
+      F77_INT js_end = to_f77_int (js(nj-1));
 
       if (nj > 0 && (js_beg < 0 || js_end > n))
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
       if (nj > 0)
         {
           F77_INT kmax = std::min (k + nj, m);
           if (k < m)
             {
               q.resize (m, kmax);
               r.resize (kmax, n + nj);
             }
           else
             r.resize (k, n + nj);
 
-          F77_INT ldq = octave::to_f77_int (q.rows ());
-          F77_INT ldr = octave::to_f77_int (r.rows ());
+          F77_INT ldq = to_f77_int (q.rows ());
+          F77_INT ldr = to_f77_int (r.rows ());
 
           OCTAVE_LOCAL_BUFFER (float, w, kmax);
           for (volatile F77_INT i = 0; i < nj; i++)
             {
               F77_INT ii = i;
               FloatColumnVector utmp = u.column (jsi(i));
-              F77_INT js_elt = octave::to_f77_int (js(ii));
+              F77_INT js_elt = to_f77_int (js(ii));
               F77_XFCN (sqrinc, SQRINC, (m, n + ii, std::min (kmax, k + ii),
                                          q.fortran_vec (), ldq,
                                          r.fortran_vec (), ldr, js_elt + 1,
                                          utmp.data (), w));
             }
         }
     }
 
     template <>
     void
     qr<FloatMatrix>::delete_col (octave_idx_type j_arg)
     {
-      F77_INT j = octave::to_f77_int (j_arg);
+      F77_INT j = to_f77_int (j_arg);
 
-      F77_INT m = octave::to_f77_int (q.rows ());
-      F77_INT k = octave::to_f77_int (r.rows ());
-      F77_INT n = octave::to_f77_int (r.cols ());
+      F77_INT m = to_f77_int (q.rows ());
+      F77_INT k = to_f77_int (r.rows ());
+      F77_INT n = to_f77_int (r.cols ());
 
       if (j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("qrdelete: index out of range");
 
-      F77_INT ldq = octave::to_f77_int (q.rows ());
-      F77_INT ldr = octave::to_f77_int (r.rows ());
+      F77_INT ldq = to_f77_int (q.rows ());
+      F77_INT ldr = to_f77_int (r.rows ());
 
       OCTAVE_LOCAL_BUFFER (float, w, k);
       F77_XFCN (sqrdec, SQRDEC, (m, n, k, q.fortran_vec (), ldq,
                                  r.fortran_vec (), ldr, j + 1, w));
 
       if (k < m)
         {
           q.resize (m, k-1);
@@ -1071,46 +1071,46 @@ namespace octave
       else
         r.resize (k, n-1);
     }
 
     template <>
     void
     qr<FloatMatrix>::delete_col (const Array<octave_idx_type>& j)
     {
-      F77_INT m = octave::to_f77_int (q.rows ());
-      F77_INT n = octave::to_f77_int (r.cols ());
-      F77_INT k = octave::to_f77_int (q.cols ());
+      F77_INT m = to_f77_int (q.rows ());
+      F77_INT n = to_f77_int (r.cols ());
+      F77_INT k = to_f77_int (q.cols ());
 
       Array<octave_idx_type> jsi;
       Array<octave_idx_type> js = j.sort (jsi, 0, DESCENDING);
-      F77_INT nj = octave::to_f77_int (js.numel ());
+      F77_INT nj = to_f77_int (js.numel ());
       bool dups = false;
       for (F77_INT i = 0; i < nj - 1; i++)
         dups = dups && js(i) == js(i+1);
 
       if (dups)
         (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
 
-      F77_INT js_beg = octave::to_f77_int (js(0));
-      F77_INT js_end = octave::to_f77_int (js(nj-1));
+      F77_INT js_beg = to_f77_int (js(0));
+      F77_INT js_end = to_f77_int (js(nj-1));
 
       if (nj > 0 && (js_beg > n-1 || js_end < 0))
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
       if (nj > 0)
         {
-          F77_INT ldq = octave::to_f77_int (q.rows ());
-          F77_INT ldr = octave::to_f77_int (r.rows ());
+          F77_INT ldq = to_f77_int (q.rows ());
+          F77_INT ldr = to_f77_int (r.rows ());
 
           OCTAVE_LOCAL_BUFFER (float, w, k);
           for (volatile F77_INT i = 0; i < nj; i++)
             {
               F77_INT ii = i;
-              F77_INT js_elt = octave::to_f77_int (js(ii));
+              F77_INT js_elt = to_f77_int (js(ii));
               F77_XFCN (sqrdec, SQRDEC, (m, n - ii, (k == m ? k : k - ii),
                                          q.fortran_vec (), ldq,
                                          r.fortran_vec (), ldr,
                                          js_elt + 1, w));
             }
 
           if (k < m)
             {
@@ -1122,104 +1122,104 @@ namespace octave
         }
     }
 
     template <>
     void
     qr<FloatMatrix>::insert_row (const FloatRowVector& u,
                                  octave_idx_type j_arg)
     {
-      F77_INT j = octave::to_f77_int (j_arg);
+      F77_INT j = to_f77_int (j_arg);
 
-      F77_INT m = octave::to_f77_int (r.rows ());
-      F77_INT n = octave::to_f77_int (r.cols ());
+      F77_INT m = to_f77_int (r.rows ());
+      F77_INT n = to_f77_int (r.cols ());
       F77_INT k = std::min (m, n);
 
-      F77_INT u_nel = octave::to_f77_int (u.numel ());
+      F77_INT u_nel = to_f77_int (u.numel ());
 
       if (! q.issquare () || u_nel != n)
         (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
 
       if (j < 0 || j > m)
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
       q.resize (m + 1, m + 1);
       r.resize (m + 1, n);
 
-      F77_INT ldq = octave::to_f77_int (q.rows ());
-      F77_INT ldr = octave::to_f77_int (r.rows ());
+      F77_INT ldq = to_f77_int (q.rows ());
+      F77_INT ldr = to_f77_int (r.rows ());
 
       FloatRowVector utmp = u;
       OCTAVE_LOCAL_BUFFER (float, w, k);
       F77_XFCN (sqrinr, SQRINR, (m, n, q.fortran_vec (), ldq,
                                  r.fortran_vec (), ldr,
                                  j + 1, utmp.fortran_vec (), w));
 
     }
 
     template <>
     void
     qr<FloatMatrix>::delete_row (octave_idx_type j_arg)
     {
-      F77_INT j = octave::to_f77_int (j_arg);
+      F77_INT j = to_f77_int (j_arg);
 
-      F77_INT m = octave::to_f77_int (r.rows ());
-      F77_INT n = octave::to_f77_int (r.cols ());
+      F77_INT m = to_f77_int (r.rows ());
+      F77_INT n = to_f77_int (r.cols ());
 
       if (! q.issquare ())
         (*current_liboctave_error_handler) ("qrdelete: dimensions mismatch");
 
       if (j < 0 || j > m-1)
         (*current_liboctave_error_handler) ("qrdelete: index out of range");
 
-      F77_INT ldq = octave::to_f77_int (q.rows ());
-      F77_INT ldr = octave::to_f77_int (r.rows ());
+      F77_INT ldq = to_f77_int (q.rows ());
+      F77_INT ldr = to_f77_int (r.rows ());
 
       OCTAVE_LOCAL_BUFFER (float, w, 2*m);
       F77_XFCN (sqrder, SQRDER, (m, n, q.fortran_vec (), ldq,
                                  r.fortran_vec (), ldr, j + 1,
                                  w));
 
       q.resize (m - 1, m - 1);
       r.resize (m - 1, n);
     }
 
     template <>
     void
     qr<FloatMatrix>::shift_cols (octave_idx_type i_arg, octave_idx_type j_arg)
     {
-      F77_INT i = octave::to_f77_int (i_arg);
-      F77_INT j = octave::to_f77_int (j_arg);
+      F77_INT i = to_f77_int (i_arg);
+      F77_INT j = to_f77_int (j_arg);
 
-      F77_INT m = octave::to_f77_int (q.rows ());
-      F77_INT k = octave::to_f77_int (r.rows ());
-      F77_INT n = octave::to_f77_int (r.cols ());
+      F77_INT m = to_f77_int (q.rows ());
+      F77_INT k = to_f77_int (r.rows ());
+      F77_INT n = to_f77_int (r.cols ());
 
       if (i < 0 || i > n-1 || j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("qrshift: index out of range");
 
-      F77_INT ldq = octave::to_f77_int (q.rows ());
-      F77_INT ldr = octave::to_f77_int (r.rows ());
+      F77_INT ldq = to_f77_int (q.rows ());
+      F77_INT ldr = to_f77_int (r.rows ());
 
       OCTAVE_LOCAL_BUFFER (float, w, 2*k);
       F77_XFCN (sqrshc, SQRSHC, (m, n, k,
                                  q.fortran_vec (), ldq,
                                  r.fortran_vec (), ldr,
                                  i + 1, j + 1, w));
     }
 
 #endif
 
     template <>
     void
     qr<ComplexMatrix>::form (octave_idx_type n_arg, ComplexMatrix& afact,
                              Complex *tau, type qr_type)
     {
-      F77_INT n = octave::to_f77_int (n_arg);
-      F77_INT m = octave::to_f77_int (afact.rows ());
+      F77_INT n = to_f77_int (n_arg);
+      F77_INT m = to_f77_int (afact.rows ());
       F77_INT min_mn = std::min (m, n);
       F77_INT info;
 
       if (qr_type == qr<ComplexMatrix>::raw)
         {
           for (F77_INT j = 0; j < min_mn; j++)
             {
               F77_INT limit = (j < min_mn - 1 ? j : min_mn - 1);
@@ -1258,17 +1258,17 @@ namespace octave
                     q.xelem (i, j) = afact.xelem (i, j);
                     afact.xelem (i, j) = 0;
                   }
               r = afact;
             }
 
           if (m > 0)
             {
-              F77_INT k = octave::to_f77_int (q.cols ());
+              F77_INT k = to_f77_int (q.cols ());
               // workspace query.
               Complex clwork;
               F77_XFCN (zungqr, ZUNGQR, (m, k, min_mn,
                                          F77_DBLE_CMPLX_ARG (q.fortran_vec ()),
                                          m, F77_DBLE_CMPLX_ARG (tau),
                                          F77_DBLE_CMPLX_ARG (&clwork), -1,
                                          info));
 
@@ -1284,18 +1284,18 @@ namespace octave
             }
         }
     }
 
     template <>
     void
     qr<ComplexMatrix>::init (const ComplexMatrix& a, type qr_type)
     {
-      F77_INT m = octave::to_f77_int (a.rows ());
-      F77_INT n = octave::to_f77_int (a.cols ());
+      F77_INT m = to_f77_int (a.rows ());
+      F77_INT n = to_f77_int (a.cols ());
 
       F77_INT min_mn = (m < n ? m : n);
       OCTAVE_LOCAL_BUFFER (Complex, tau, min_mn);
 
       F77_INT info = 0;
 
       ComplexMatrix afact = a;
       if (m > n && qr_type == qr<ComplexMatrix>::std)
@@ -1325,22 +1325,22 @@ namespace octave
 
 #if defined (HAVE_QRUPDATE)
 
     template <>
     void
     qr<ComplexMatrix>::update (const ComplexColumnVector& u,
                                const ComplexColumnVector& v)
     {
-      F77_INT m = octave::to_f77_int (q.rows ());
-      F77_INT n = octave::to_f77_int (r.cols ());
-      F77_INT k = octave::to_f77_int (q.cols ());
+      F77_INT m = to_f77_int (q.rows ());
+      F77_INT n = to_f77_int (r.cols ());
+      F77_INT k = to_f77_int (q.cols ());
 
-      F77_INT u_nel = octave::to_f77_int (u.numel ());
-      F77_INT v_nel = octave::to_f77_int (v.numel ());
+      F77_INT u_nel = to_f77_int (u.numel ());
+      F77_INT v_nel = to_f77_int (v.numel ());
 
       if (u_nel != m || v_nel != n)
         (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 
       ComplexColumnVector utmp = u;
       ComplexColumnVector vtmp = v;
       OCTAVE_LOCAL_BUFFER (Complex, w, k);
       OCTAVE_LOCAL_BUFFER (double, rw, k);
@@ -1350,25 +1350,25 @@ namespace octave
                                  F77_DBLE_CMPLX_ARG (vtmp.fortran_vec ()),
                                  F77_DBLE_CMPLX_ARG (w), rw));
     }
 
     template <>
     void
     qr<ComplexMatrix>::update (const ComplexMatrix& u, const ComplexMatrix& v)
     {
-      F77_INT m = octave::to_f77_int (q.rows ());
-      F77_INT n = octave::to_f77_int (r.cols ());
-      F77_INT k = octave::to_f77_int (q.cols ());
+      F77_INT m = to_f77_int (q.rows ());
+      F77_INT n = to_f77_int (r.cols ());
+      F77_INT k = to_f77_int (q.cols ());
 
-      F77_INT u_rows = octave::to_f77_int (u.rows ());
-      F77_INT u_cols = octave::to_f77_int (u.cols ());
+      F77_INT u_rows = to_f77_int (u.rows ());
+      F77_INT u_cols = to_f77_int (u.cols ());
 
-      F77_INT v_rows = octave::to_f77_int (v.rows ());
-      F77_INT v_cols = octave::to_f77_int (v.cols ());
+      F77_INT v_rows = to_f77_int (v.rows ());
+      F77_INT v_cols = to_f77_int (v.cols ());
 
       if (u_rows != m || v_rows != n || u_cols != v_cols)
         (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 
       OCTAVE_LOCAL_BUFFER (Complex, w, k);
       OCTAVE_LOCAL_BUFFER (double, rw, k);
       for (volatile F77_INT i = 0; i < u_cols; i++)
         {
@@ -1383,126 +1383,126 @@ namespace octave
         }
     }
 
     template <>
     void
     qr<ComplexMatrix>::insert_col (const ComplexColumnVector& u,
                                    octave_idx_type j_arg)
     {
-      F77_INT j = octave::to_f77_int (j_arg);
+      F77_INT j = to_f77_int (j_arg);
 
-      F77_INT m = octave::to_f77_int (q.rows ());
-      F77_INT n = octave::to_f77_int (r.cols ());
-      F77_INT k = octave::to_f77_int (q.cols ());
+      F77_INT m = to_f77_int (q.rows ());
+      F77_INT n = to_f77_int (r.cols ());
+      F77_INT k = to_f77_int (q.cols ());
 
-      F77_INT u_nel = octave::to_f77_int (u.numel ());
+      F77_INT u_nel = to_f77_int (u.numel ());
 
       if (u_nel != m)
         (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
 
       if (j < 0 || j > n)
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
       if (k < m)
         {
           q.resize (m, k+1);
           r.resize (k+1, n+1);
         }
       else
         r.resize (k, n+1);
 
-      F77_INT ldq = octave::to_f77_int (q.rows ());
-      F77_INT ldr = octave::to_f77_int (r.rows ());
+      F77_INT ldq = to_f77_int (q.rows ());
+      F77_INT ldr = to_f77_int (r.rows ());
 
       ComplexColumnVector utmp = u;
       OCTAVE_LOCAL_BUFFER (double, rw, k);
       F77_XFCN (zqrinc, ZQRINC, (m, n, k, F77_DBLE_CMPLX_ARG (q.fortran_vec ()),
                                  ldq, F77_DBLE_CMPLX_ARG (r.fortran_vec ()),
                                  ldr, j + 1,
                                  F77_CONST_DBLE_CMPLX_ARG (utmp.data ()), rw));
     }
 
     template <>
     void
     qr<ComplexMatrix>::insert_col (const ComplexMatrix& u,
                                    const Array<octave_idx_type>& j)
     {
-      F77_INT m = octave::to_f77_int (q.rows ());
-      F77_INT n = octave::to_f77_int (r.cols ());
-      F77_INT k = octave::to_f77_int (q.cols ());
+      F77_INT m = to_f77_int (q.rows ());
+      F77_INT n = to_f77_int (r.cols ());
+      F77_INT k = to_f77_int (q.cols ());
 
       Array<octave_idx_type> jsi;
       Array<octave_idx_type> js = j.sort (jsi, 0, ASCENDING);
-      F77_INT nj = octave::to_f77_int (js.numel ());
+      F77_INT nj = to_f77_int (js.numel ());
       bool dups = false;
       for (F77_INT i = 0; i < nj - 1; i++)
         dups = dups && js(i) == js(i+1);
 
       if (dups)
         (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
 
-      F77_INT u_nel = octave::to_f77_int (u.numel ());
-      F77_INT u_cols = octave::to_f77_int (u.cols ());
+      F77_INT u_nel = to_f77_int (u.numel ());
+      F77_INT u_cols = to_f77_int (u.cols ());
 
       if (u_nel != m || u_cols != nj)
         (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
 
-      F77_INT js_beg = octave::to_f77_int (js(0));
-      F77_INT js_end = octave::to_f77_int (js(nj-1));
+      F77_INT js_beg = to_f77_int (js(0));
+      F77_INT js_end = to_f77_int (js(nj-1));
 
       if (nj > 0 && (js_beg < 0 || js_end > n))
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
       if (nj > 0)
         {
           F77_INT kmax = std::min (k + nj, m);
           if (k < m)
             {
               q.resize (m, kmax);
               r.resize (kmax, n + nj);
             }
           else
             r.resize (k, n + nj);
 
-          F77_INT ldq = octave::to_f77_int (q.rows ());
-          F77_INT ldr = octave::to_f77_int (r.rows ());
+          F77_INT ldq = to_f77_int (q.rows ());
+          F77_INT ldr = to_f77_int (r.rows ());
 
           OCTAVE_LOCAL_BUFFER (double, rw, kmax);
           for (volatile F77_INT i = 0; i < nj; i++)
             {
               F77_INT ii = i;
               ComplexColumnVector utmp = u.column (jsi(i));
-              F77_INT js_elt = octave::to_f77_int (js(ii));
+              F77_INT js_elt = to_f77_int (js(ii));
               F77_XFCN (zqrinc, ZQRINC, (m, n + ii, std::min (kmax, k + ii),
                                          F77_DBLE_CMPLX_ARG (q.fortran_vec ()),
                                          ldq,
                                          F77_DBLE_CMPLX_ARG (r.fortran_vec ()),
                                          ldr, js_elt + 1,
                                          F77_CONST_DBLE_CMPLX_ARG (utmp.data ()),
                                          rw));
             }
         }
     }
 
     template <>
     void
     qr<ComplexMatrix>::delete_col (octave_idx_type j_arg)
     {
-      F77_INT j = octave::to_f77_int (j_arg);
+      F77_INT j = to_f77_int (j_arg);
 
-      F77_INT m = octave::to_f77_int (q.rows ());
-      F77_INT k = octave::to_f77_int (r.rows ());
-      F77_INT n = octave::to_f77_int (r.cols ());
+      F77_INT m = to_f77_int (q.rows ());
+      F77_INT k = to_f77_int (r.rows ());
+      F77_INT n = to_f77_int (r.cols ());
 
       if (j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("qrdelete: index out of range");
 
-      F77_INT ldq = octave::to_f77_int (q.rows ());
-      F77_INT ldr = octave::to_f77_int (r.rows ());
+      F77_INT ldq = to_f77_int (q.rows ());
+      F77_INT ldr = to_f77_int (r.rows ());
 
       OCTAVE_LOCAL_BUFFER (double, rw, k);
       F77_XFCN (zqrdec, ZQRDEC, (m, n, k, F77_DBLE_CMPLX_ARG (q.fortran_vec ()),
                                  ldq, F77_DBLE_CMPLX_ARG (r.fortran_vec ()),
                                  ldr, j + 1, rw));
 
       if (k < m)
         {
@@ -1512,46 +1512,46 @@ namespace octave
       else
         r.resize (k, n-1);
     }
 
     template <>
     void
     qr<ComplexMatrix>::delete_col (const Array<octave_idx_type>& j)
     {
-      F77_INT m = octave::to_f77_int (q.rows ());
-      F77_INT n = octave::to_f77_int (r.cols ());
-      F77_INT k = octave::to_f77_int (q.cols ());
+      F77_INT m = to_f77_int (q.rows ());
+      F77_INT n = to_f77_int (r.cols ());
+      F77_INT k = to_f77_int (q.cols ());
 
       Array<octave_idx_type> jsi;
       Array<octave_idx_type> js = j.sort (jsi, 0, DESCENDING);
-      F77_INT nj = octave::to_f77_int (js.numel ());
+      F77_INT nj = to_f77_int (js.numel ());
       bool dups = false;
       for (F77_INT i = 0; i < nj - 1; i++)
         dups = dups && js(i) == js(i+1);
 
       if (dups)
         (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
 
-      F77_INT js_beg = octave::to_f77_int (js(0));
-      F77_INT js_end = octave::to_f77_int (js(nj-1));
+      F77_INT js_beg = to_f77_int (js(0));
+      F77_INT js_end = to_f77_int (js(nj-1));
 
       if (nj > 0 && (js_beg > n-1 || js_end < 0))
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
       if (nj > 0)
         {
-          F77_INT ldq = octave::to_f77_int (q.rows ());
-          F77_INT ldr = octave::to_f77_int (r.rows ());
+          F77_INT ldq = to_f77_int (q.rows ());
+          F77_INT ldr = to_f77_int (r.rows ());
 
           OCTAVE_LOCAL_BUFFER (double, rw, k);
           for (volatile F77_INT i = 0; i < nj; i++)
             {
               F77_INT ii = i;
-              F77_INT js_elt = octave::to_f77_int (js(ii));
+              F77_INT js_elt = to_f77_int (js(ii));
               F77_XFCN (zqrdec, ZQRDEC, (m, n - ii, (k == m ? k : k - ii),
                                          F77_DBLE_CMPLX_ARG (q.fortran_vec ()),
                                          ldq,
                                          F77_DBLE_CMPLX_ARG (r.fortran_vec ()),
                                          ldr, js_elt + 1, rw));
             }
 
           if (k < m)
@@ -1564,108 +1564,108 @@ namespace octave
         }
     }
 
     template <>
     void
     qr<ComplexMatrix>::insert_row (const ComplexRowVector& u,
                                    octave_idx_type j_arg)
     {
-      F77_INT j = octave::to_f77_int (j_arg);
+      F77_INT j = to_f77_int (j_arg);
 
-      F77_INT m = octave::to_f77_int (r.rows ());
-      F77_INT n = octave::to_f77_int (r.cols ());
+      F77_INT m = to_f77_int (r.rows ());
+      F77_INT n = to_f77_int (r.cols ());
       F77_INT k = std::min (m, n);
 
-      F77_INT u_nel = octave::to_f77_int (u.numel ());
+      F77_INT u_nel = to_f77_int (u.numel ());
 
       if (! q.issquare () || u_nel != n)
         (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
 
       if (j < 0 || j > m)
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
       q.resize (m + 1, m + 1);
       r.resize (m + 1, n);
 
-      F77_INT ldq = octave::to_f77_int (q.rows ());
-      F77_INT ldr = octave::to_f77_int (r.rows ());
+      F77_INT ldq = to_f77_int (q.rows ());
+      F77_INT ldr = to_f77_int (r.rows ());
 
       ComplexRowVector utmp = u;
       OCTAVE_LOCAL_BUFFER (double, rw, k);
       F77_XFCN (zqrinr, ZQRINR, (m, n, F77_DBLE_CMPLX_ARG (q.fortran_vec ()),
                                  ldq, F77_DBLE_CMPLX_ARG (r.fortran_vec ()),
                                  ldr, j + 1,
                                  F77_DBLE_CMPLX_ARG (utmp.fortran_vec ()), rw));
 
     }
 
     template <>
     void
     qr<ComplexMatrix>::delete_row (octave_idx_type j_arg)
     {
-      F77_INT j = octave::to_f77_int (j_arg);
+      F77_INT j = to_f77_int (j_arg);
 
-      F77_INT m = octave::to_f77_int (r.rows ());
-      F77_INT n = octave::to_f77_int (r.cols ());
+      F77_INT m = to_f77_int (r.rows ());
+      F77_INT n = to_f77_int (r.cols ());
 
       if (! q.issquare ())
         (*current_liboctave_error_handler) ("qrdelete: dimensions mismatch");
 
       if (j < 0 || j > m-1)
         (*current_liboctave_error_handler) ("qrdelete: index out of range");
 
-      F77_INT ldq = octave::to_f77_int (q.rows ());
-      F77_INT ldr = octave::to_f77_int (r.rows ());
+      F77_INT ldq = to_f77_int (q.rows ());
+      F77_INT ldr = to_f77_int (r.rows ());
 
       OCTAVE_LOCAL_BUFFER (Complex, w, m);
       OCTAVE_LOCAL_BUFFER (double, rw, m);
       F77_XFCN (zqrder, ZQRDER, (m, n, F77_DBLE_CMPLX_ARG (q.fortran_vec ()),
                                  ldq, F77_DBLE_CMPLX_ARG (r.fortran_vec ()),
                                  ldr, j + 1, F77_DBLE_CMPLX_ARG (w), rw));
 
       q.resize (m - 1, m - 1);
       r.resize (m - 1, n);
     }
 
     template <>
     void
     qr<ComplexMatrix>::shift_cols (octave_idx_type i_arg,
                                    octave_idx_type j_arg)
     {
-      F77_INT i = octave::to_f77_int (i_arg);
-      F77_INT j = octave::to_f77_int (j_arg);
+      F77_INT i = to_f77_int (i_arg);
+      F77_INT j = to_f77_int (j_arg);
 
-      F77_INT m = octave::to_f77_int (q.rows ());
-      F77_INT k = octave::to_f77_int (r.rows ());
-      F77_INT n = octave::to_f77_int (r.cols ());
+      F77_INT m = to_f77_int (q.rows ());
+      F77_INT k = to_f77_int (r.rows ());
+      F77_INT n = to_f77_int (r.cols ());
 
       if (i < 0 || i > n-1 || j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("qrshift: index out of range");
 
-      F77_INT ldq = octave::to_f77_int (q.rows ());
-      F77_INT ldr = octave::to_f77_int (r.rows ());
+      F77_INT ldq = to_f77_int (q.rows ());
+      F77_INT ldr = to_f77_int (r.rows ());
 
       OCTAVE_LOCAL_BUFFER (Complex, w, k);
       OCTAVE_LOCAL_BUFFER (double, rw, k);
       F77_XFCN (zqrshc, ZQRSHC, (m, n, k,
                                  F77_DBLE_CMPLX_ARG (q.fortran_vec ()), ldq,
                                  F77_DBLE_CMPLX_ARG (r.fortran_vec ()), ldr,
                                  i + 1, j + 1, F77_DBLE_CMPLX_ARG (w), rw));
     }
 
 #endif
 
     template <>
     void
     qr<FloatComplexMatrix>::form (octave_idx_type n_arg, FloatComplexMatrix& afact,
                                   FloatComplex *tau, type qr_type)
     {
-      F77_INT n = octave::to_f77_int (n_arg);
-      F77_INT m = octave::to_f77_int (afact.rows ());
+      F77_INT n = to_f77_int (n_arg);
+      F77_INT m = to_f77_int (afact.rows ());
       F77_INT min_mn = std::min (m, n);
       F77_INT info;
 
       if (qr_type == qr<FloatComplexMatrix>::raw)
         {
           for (F77_INT j = 0; j < min_mn; j++)
             {
               F77_INT limit = (j < min_mn - 1 ? j : min_mn - 1);
@@ -1704,17 +1704,17 @@ namespace octave
                     q.xelem (i, j) = afact.xelem (i, j);
                     afact.xelem (i, j) = 0;
                   }
               r = afact;
             }
 
           if (m > 0)
             {
-              F77_INT k = octave::to_f77_int (q.cols ());
+              F77_INT k = to_f77_int (q.cols ());
               // workspace query.
               FloatComplex clwork;
               F77_XFCN (cungqr, CUNGQR, (m, k, min_mn,
                                          F77_CMPLX_ARG (q.fortran_vec ()), m,
                                          F77_CMPLX_ARG (tau),
                                          F77_CMPLX_ARG (&clwork), -1, info));
 
               // allocate buffer and do the job.
@@ -1728,18 +1728,18 @@ namespace octave
             }
         }
     }
 
     template <>
     void
     qr<FloatComplexMatrix>::init (const FloatComplexMatrix& a, type qr_type)
     {
-      F77_INT m = octave::to_f77_int (a.rows ());
-      F77_INT n = octave::to_f77_int (a.cols ());
+      F77_INT m = to_f77_int (a.rows ());
+      F77_INT n = to_f77_int (a.cols ());
 
       F77_INT min_mn = (m < n ? m : n);
       OCTAVE_LOCAL_BUFFER (FloatComplex, tau, min_mn);
 
       F77_INT info = 0;
 
       FloatComplexMatrix afact = a;
       if (m > n && qr_type == qr<FloatComplexMatrix>::std)
@@ -1767,22 +1767,22 @@ namespace octave
 
 #if defined (HAVE_QRUPDATE)
 
     template <>
     void
     qr<FloatComplexMatrix>::update (const FloatComplexColumnVector& u,
                                     const FloatComplexColumnVector& v)
     {
-      F77_INT m = octave::to_f77_int (q.rows ());
-      F77_INT n = octave::to_f77_int (r.cols ());
-      F77_INT k = octave::to_f77_int (q.cols ());
+      F77_INT m = to_f77_int (q.rows ());
+      F77_INT n = to_f77_int (r.cols ());
+      F77_INT k = to_f77_int (q.cols ());
 
-      F77_INT u_nel = octave::to_f77_int (u.numel ());
-      F77_INT v_nel = octave::to_f77_int (v.numel ());
+      F77_INT u_nel = to_f77_int (u.numel ());
+      F77_INT v_nel = to_f77_int (v.numel ());
 
       if (u_nel != m || v_nel != n)
         (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 
       FloatComplexColumnVector utmp = u;
       FloatComplexColumnVector vtmp = v;
       OCTAVE_LOCAL_BUFFER (FloatComplex, w, k);
       OCTAVE_LOCAL_BUFFER (float, rw, k);
@@ -1793,25 +1793,25 @@ namespace octave
                                  F77_CMPLX_ARG (w), rw));
     }
 
     template <>
     void
     qr<FloatComplexMatrix>::update (const FloatComplexMatrix& u,
                                     const FloatComplexMatrix& v)
     {
-      F77_INT m = octave::to_f77_int (q.rows ());
-      F77_INT n = octave::to_f77_int (r.cols ());
-      F77_INT k = octave::to_f77_int (q.cols ());
+      F77_INT m = to_f77_int (q.rows ());
+      F77_INT n = to_f77_int (r.cols ());
+      F77_INT k = to_f77_int (q.cols ());
 
-      F77_INT u_rows = octave::to_f77_int (u.rows ());
-      F77_INT u_cols = octave::to_f77_int (u.cols ());
+      F77_INT u_rows = to_f77_int (u.rows ());
+      F77_INT u_cols = to_f77_int (u.cols ());
 
-      F77_INT v_rows = octave::to_f77_int (v.rows ());
-      F77_INT v_cols = octave::to_f77_int (v.cols ());
+      F77_INT v_rows = to_f77_int (v.rows ());
+      F77_INT v_cols = to_f77_int (v.cols ());
 
       if (u_rows != m || v_rows != n || u_cols != v_cols)
         (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 
       OCTAVE_LOCAL_BUFFER (FloatComplex, w, k);
       OCTAVE_LOCAL_BUFFER (float, rw, k);
       for (volatile F77_INT i = 0; i < u_cols; i++)
         {
@@ -1825,123 +1825,123 @@ namespace octave
         }
     }
 
     template <>
     void
     qr<FloatComplexMatrix>::insert_col (const FloatComplexColumnVector& u,
                                         octave_idx_type j_arg)
     {
-      F77_INT j = octave::to_f77_int (j_arg);
+      F77_INT j = to_f77_int (j_arg);
 
-      F77_INT m = octave::to_f77_int (q.rows ());
-      F77_INT n = octave::to_f77_int (r.cols ());
-      F77_INT k = octave::to_f77_int (q.cols ());
+      F77_INT m = to_f77_int (q.rows ());
+      F77_INT n = to_f77_int (r.cols ());
+      F77_INT k = to_f77_int (q.cols ());
 
-      F77_INT u_nel = octave::to_f77_int (u.numel ());
+      F77_INT u_nel = to_f77_int (u.numel ());
 
       if (u_nel != m)
         (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
 
       if (j < 0 || j > n)
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
       if (k < m)
         {
           q.resize (m, k+1);
           r.resize (k+1, n+1);
         }
       else
         r.resize (k, n+1);
 
-      F77_INT ldq = octave::to_f77_int (q.rows ());
-      F77_INT ldr = octave::to_f77_int (r.rows ());
+      F77_INT ldq = to_f77_int (q.rows ());
+      F77_INT ldr = to_f77_int (r.rows ());
 
       FloatComplexColumnVector utmp = u;
       OCTAVE_LOCAL_BUFFER (float, rw, k);
       F77_XFCN (cqrinc, CQRINC, (m, n, k, F77_CMPLX_ARG (q.fortran_vec ()), ldq,
                                  F77_CMPLX_ARG (r.fortran_vec ()), ldr, j + 1,
                                  F77_CONST_CMPLX_ARG (utmp.data ()), rw));
     }
 
     template <>
     void
     qr<FloatComplexMatrix>::insert_col (const FloatComplexMatrix& u,
                                         const Array<octave_idx_type>& j)
     {
-      F77_INT m = octave::to_f77_int (q.rows ());
-      F77_INT n = octave::to_f77_int (r.cols ());
-      F77_INT k = octave::to_f77_int (q.cols ());
+      F77_INT m = to_f77_int (q.rows ());
+      F77_INT n = to_f77_int (r.cols ());
+      F77_INT k = to_f77_int (q.cols ());
 
       Array<octave_idx_type> jsi;
       Array<octave_idx_type> js = j.sort (jsi, 0, ASCENDING);
-      F77_INT nj = octave::to_f77_int (js.numel ());
+      F77_INT nj = to_f77_int (js.numel ());
       bool dups = false;
       for (F77_INT i = 0; i < nj - 1; i++)
         dups = dups && js(i) == js(i+1);
 
       if (dups)
         (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
 
-      F77_INT u_nel = octave::to_f77_int (u.numel ());
-      F77_INT u_cols = octave::to_f77_int (u.cols ());
+      F77_INT u_nel = to_f77_int (u.numel ());
+      F77_INT u_cols = to_f77_int (u.cols ());
 
       if (u_nel != m || u_cols != nj)
         (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
 
-      F77_INT js_beg = octave::to_f77_int (js(0));
-      F77_INT js_end = octave::to_f77_int (js(nj-1));
+      F77_INT js_beg = to_f77_int (js(0));
+      F77_INT js_end = to_f77_int (js(nj-1));
 
       if (nj > 0 && (js_beg < 0 || js_end > n))
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
       if (nj > 0)
         {
           F77_INT kmax = std::min (k + nj, m);
           if (k < m)
             {
               q.resize (m, kmax);
               r.resize (kmax, n + nj);
             }
           else
             r.resize (k, n + nj);
 
-          F77_INT ldq = octave::to_f77_int (q.rows ());
-          F77_INT ldr = octave::to_f77_int (r.rows ());
+          F77_INT ldq = to_f77_int (q.rows ());
+          F77_INT ldr = to_f77_int (r.rows ());
 
           OCTAVE_LOCAL_BUFFER (float, rw, kmax);
           for (volatile F77_INT i = 0; i < nj; i++)
             {
               F77_INT ii = i;
-              F77_INT js_elt = octave::to_f77_int (js(ii));
+              F77_INT js_elt = to_f77_int (js(ii));
               F77_XFCN (cqrinc, CQRINC, (m, n + ii, std::min (kmax, k + ii),
                                          F77_CMPLX_ARG (q.fortran_vec ()), ldq,
                                          F77_CMPLX_ARG (r.fortran_vec ()), ldr,
                                          js_elt + 1,
                                          F77_CONST_CMPLX_ARG (u.column (jsi(i)).data ()),
                                          rw));
             }
         }
     }
 
     template <>
     void
     qr<FloatComplexMatrix>::delete_col (octave_idx_type j_arg)
     {
-      F77_INT j = octave::to_f77_int (j_arg);
+      F77_INT j = to_f77_int (j_arg);
 
-      F77_INT m = octave::to_f77_int (q.rows ());
-      F77_INT k = octave::to_f77_int (r.rows ());
-      F77_INT n = octave::to_f77_int (r.cols ());
+      F77_INT m = to_f77_int (q.rows ());
+      F77_INT k = to_f77_int (r.rows ());
+      F77_INT n = to_f77_int (r.cols ());
 
       if (j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("qrdelete: index out of range");
 
-      F77_INT ldq = octave::to_f77_int (q.rows ());
-      F77_INT ldr = octave::to_f77_int (r.rows ());
+      F77_INT ldq = to_f77_int (q.rows ());
+      F77_INT ldr = to_f77_int (r.rows ());
 
       OCTAVE_LOCAL_BUFFER (float, rw, k);
       F77_XFCN (cqrdec, CQRDEC, (m, n, k, F77_CMPLX_ARG (q.fortran_vec ()), ldq,
                                  F77_CMPLX_ARG (r.fortran_vec ()), ldr, j + 1,
                                  rw));
 
       if (k < m)
         {
@@ -1951,46 +1951,46 @@ namespace octave
       else
         r.resize (k, n-1);
     }
 
     template <>
     void
     qr<FloatComplexMatrix>::delete_col (const Array<octave_idx_type>& j)
     {
-      F77_INT m = octave::to_f77_int (q.rows ());
-      F77_INT n = octave::to_f77_int (r.cols ());
-      F77_INT k = octave::to_f77_int (q.cols ());
+      F77_INT m = to_f77_int (q.rows ());
+      F77_INT n = to_f77_int (r.cols ());
+      F77_INT k = to_f77_int (q.cols ());
 
       Array<octave_idx_type> jsi;
       Array<octave_idx_type> js = j.sort (jsi, 0, DESCENDING);
-      F77_INT nj = octave::to_f77_int (js.numel ());
+      F77_INT nj = to_f77_int (js.numel ());
       bool dups = false;
       for (F77_INT i = 0; i < nj - 1; i++)
         dups = dups && js(i) == js(i+1);
 
       if (dups)
         (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
 
-      F77_INT js_beg = octave::to_f77_int (js(0));
-      F77_INT js_end = octave::to_f77_int (js(nj-1));
+      F77_INT js_beg = to_f77_int (js(0));
+      F77_INT js_end = to_f77_int (js(nj-1));
 
       if (nj > 0 && (js_beg > n-1 || js_end < 0))
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
       if (nj > 0)
         {
-          F77_INT ldq = octave::to_f77_int (q.rows ());
-          F77_INT ldr = octave::to_f77_int (r.rows ());
+          F77_INT ldq = to_f77_int (q.rows ());
+          F77_INT ldr = to_f77_int (r.rows ());
 
           OCTAVE_LOCAL_BUFFER (float, rw, k);
           for (volatile F77_INT i = 0; i < nj; i++)
             {
               F77_INT ii = i;
-              F77_INT js_elt = octave::to_f77_int (js(ii));
+              F77_INT js_elt = to_f77_int (js(ii));
               F77_XFCN (cqrdec, CQRDEC, (m, n - ii, (k == m ? k : k - ii),
                                          F77_CMPLX_ARG (q.fortran_vec ()), ldq,
                                          F77_CMPLX_ARG (r.fortran_vec ()), ldr,
                                          js_elt + 1, rw));
             }
 
           if (k < m)
             {
@@ -2002,90 +2002,90 @@ namespace octave
         }
     }
 
     template <>
     void
     qr<FloatComplexMatrix>::insert_row (const FloatComplexRowVector& u,
                                         octave_idx_type j_arg)
     {
-      F77_INT j = octave::to_f77_int (j_arg);
+      F77_INT j = to_f77_int (j_arg);
 
-      F77_INT m = octave::to_f77_int (r.rows ());
-      F77_INT n = octave::to_f77_int (r.cols ());
+      F77_INT m = to_f77_int (r.rows ());
+      F77_INT n = to_f77_int (r.cols ());
       F77_INT k = std::min (m, n);
 
-      F77_INT u_nel = octave::to_f77_int (u.numel ());
+      F77_INT u_nel = to_f77_int (u.numel ());
 
       if (! q.issquare () || u_nel != n)
         (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
 
       if (j < 0 || j > m)
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
       q.resize (m + 1, m + 1);
       r.resize (m + 1, n);
 
-      F77_INT ldq = octave::to_f77_int (q.rows ());
-      F77_INT ldr = octave::to_f77_int (r.rows ());
+      F77_INT ldq = to_f77_int (q.rows ());
+      F77_INT ldr = to_f77_int (r.rows ());
 
       FloatComplexRowVector utmp = u;
       OCTAVE_LOCAL_BUFFER (float, rw, k);
       F77_XFCN (cqrinr, CQRINR, (m, n, F77_CMPLX_ARG (q.fortran_vec ()), ldq,
                                  F77_CMPLX_ARG (r.fortran_vec ()), ldr,
                                  j + 1, F77_CMPLX_ARG (utmp.fortran_vec ()),
                                  rw));
 
     }
 
     template <>
     void
     qr<FloatComplexMatrix>::delete_row (octave_idx_type j_arg)
     {
-      F77_INT j = octave::to_f77_int (j_arg);
+      F77_INT j = to_f77_int (j_arg);
 
-      F77_INT m = octave::to_f77_int (r.rows ());
-      F77_INT n = octave::to_f77_int (r.cols ());
+      F77_INT m = to_f77_int (r.rows ());
+      F77_INT n = to_f77_int (r.cols ());
 
       if (! q.issquare ())
         (*current_liboctave_error_handler) ("qrdelete: dimensions mismatch");
 
       if (j < 0 || j > m-1)
         (*current_liboctave_error_handler) ("qrdelete: index out of range");
 
-      F77_INT ldq = octave::to_f77_int (q.rows ());
-      F77_INT ldr = octave::to_f77_int (r.rows ());
+      F77_INT ldq = to_f77_int (q.rows ());
+      F77_INT ldr = to_f77_int (r.rows ());
 
       OCTAVE_LOCAL_BUFFER (FloatComplex, w, m);
       OCTAVE_LOCAL_BUFFER (float, rw, m);
       F77_XFCN (cqrder, CQRDER, (m, n, F77_CMPLX_ARG (q.fortran_vec ()), ldq,
                                  F77_CMPLX_ARG (r.fortran_vec ()), ldr, j + 1,
                                  F77_CMPLX_ARG (w), rw));
 
       q.resize (m - 1, m - 1);
       r.resize (m - 1, n);
     }
 
     template <>
     void
     qr<FloatComplexMatrix>::shift_cols (octave_idx_type i_arg,
                                         octave_idx_type j_arg)
     {
-      F77_INT i = octave::to_f77_int (i_arg);
-      F77_INT j = octave::to_f77_int (j_arg);
+      F77_INT i = to_f77_int (i_arg);
+      F77_INT j = to_f77_int (j_arg);
 
-      F77_INT m = octave::to_f77_int (q.rows ());
-      F77_INT k = octave::to_f77_int (r.rows ());
-      F77_INT n = octave::to_f77_int (r.cols ());
+      F77_INT m = to_f77_int (q.rows ());
+      F77_INT k = to_f77_int (r.rows ());
+      F77_INT n = to_f77_int (r.cols ());
 
       if (i < 0 || i > n-1 || j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("qrshift: index out of range");
 
-      F77_INT ldq = octave::to_f77_int (q.rows ());
-      F77_INT ldr = octave::to_f77_int (r.rows ());
+      F77_INT ldq = to_f77_int (q.rows ());
+      F77_INT ldr = to_f77_int (r.rows ());
 
       OCTAVE_LOCAL_BUFFER (FloatComplex, w, k);
       OCTAVE_LOCAL_BUFFER (float, rw, k);
       F77_XFCN (cqrshc, CQRSHC, (m, n, k,
                                  F77_CMPLX_ARG (q.fortran_vec ()), ldq,
                                  F77_CMPLX_ARG (r.fortran_vec ()), ldr,
                                  i + 1, j + 1, F77_CMPLX_ARG (w), rw));
     }
diff --git a/liboctave/numeric/qrp.cc b/liboctave/numeric/qrp.cc
--- a/liboctave/numeric/qrp.cc
+++ b/liboctave/numeric/qrp.cc
@@ -48,18 +48,18 @@ namespace octave
     // Specialization.
 
     template <>
     void
     qrp<Matrix>::init (const Matrix& a, type qr_type)
     {
       assert (qr_type != qr<Matrix>::raw);
 
-      F77_INT m = octave::to_f77_int (a.rows ());
-      F77_INT n = octave::to_f77_int (a.cols ());
+      F77_INT m = to_f77_int (a.rows ());
+      F77_INT n = to_f77_int (a.cols ());
 
       F77_INT min_mn = (m < n ? m : n);
       OCTAVE_LOCAL_BUFFER (double, tau, min_mn);
 
       F77_INT info = 0;
 
       Matrix afact = a;
       if (m > n && qr_type == qr<Matrix>::std)
@@ -116,18 +116,18 @@ namespace octave
     }
 
     template <>
     void
     qrp<FloatMatrix>::init (const FloatMatrix& a, type qr_type)
     {
       assert (qr_type != qr<FloatMatrix>::raw);
 
-      F77_INT m = octave::to_f77_int (a.rows ());
-      F77_INT n = octave::to_f77_int (a.cols ());
+      F77_INT m = to_f77_int (a.rows ());
+      F77_INT n = to_f77_int (a.cols ());
 
       F77_INT min_mn = (m < n ? m : n);
       OCTAVE_LOCAL_BUFFER (float, tau, min_mn);
 
       F77_INT info = 0;
 
       FloatMatrix afact = a;
       if (m > n && qr_type == qr<FloatMatrix>::std)
@@ -184,18 +184,18 @@ namespace octave
     }
 
     template <>
     void
     qrp<ComplexMatrix>::init (const ComplexMatrix& a, type qr_type)
     {
       assert (qr_type != qr<ComplexMatrix>::raw);
 
-      F77_INT m = octave::to_f77_int (a.rows ());
-      F77_INT n = octave::to_f77_int (a.cols ());
+      F77_INT m = to_f77_int (a.rows ());
+      F77_INT n = to_f77_int (a.cols ());
 
       F77_INT min_mn = (m < n ? m : n);
       OCTAVE_LOCAL_BUFFER (Complex, tau, min_mn);
 
       F77_INT info = 0;
 
       ComplexMatrix afact = a;
       if (m > n && qr_type == qr<ComplexMatrix>::std)
@@ -260,18 +260,18 @@ namespace octave
     }
 
     template <>
     void
     qrp<FloatComplexMatrix>::init (const FloatComplexMatrix& a, type qr_type)
     {
       assert (qr_type != qr<FloatComplexMatrix>::raw);
 
-      F77_INT m = octave::to_f77_int (a.rows ());
-      F77_INT n = octave::to_f77_int (a.cols ());
+      F77_INT m = to_f77_int (a.rows ());
+      F77_INT n = to_f77_int (a.cols ());
 
       F77_INT min_mn = (m < n ? m : n);
       OCTAVE_LOCAL_BUFFER (FloatComplex, tau, min_mn);
 
       F77_INT info = 0;
 
       FloatComplexMatrix afact = a;
       if (m > n && qr_type == qr<FloatComplexMatrix>::std)
diff --git a/liboctave/numeric/schur.cc b/liboctave/numeric/schur.cc
--- a/liboctave/numeric/schur.cc
+++ b/liboctave/numeric/schur.cc
@@ -93,18 +93,18 @@ namespace octave
       const FloatComplex& a = reinterpret_cast<const FloatComplex&> (a_arg);
       return (abs (a) < 1.0);
     }
 
     template <>
     F77_INT
     schur<Matrix>::init (const Matrix& a, const std::string& ord, bool calc_unitary)
     {
-      F77_INT a_nr = octave::to_f77_int (a.rows ());
-      F77_INT a_nc = octave::to_f77_int (a.cols ());
+      F77_INT a_nr = to_f77_int (a.rows ());
+      F77_INT a_nc = to_f77_int (a.cols ());
 
       if (a_nr != a_nc)
         (*current_liboctave_error_handler) ("schur: requires square matrix");
 
       if (a_nr == 0)
         {
           schur_mat.clear ();
           unitary_mat.clear ();
@@ -180,18 +180,18 @@ namespace octave
       return info;
     }
 
     template <>
     F77_INT
     schur<FloatMatrix>::init (const FloatMatrix& a, const std::string& ord,
                               bool calc_unitary)
     {
-      F77_INT a_nr = octave::to_f77_int (a.rows ());
-      F77_INT a_nc = octave::to_f77_int (a.cols ());
+      F77_INT a_nr = to_f77_int (a.rows ());
+      F77_INT a_nc = to_f77_int (a.cols ());
 
       if (a_nr != a_nc)
         (*current_liboctave_error_handler) ("SCHUR requires square matrix");
 
       if (a_nr == 0)
         {
           schur_mat.clear ();
           unitary_mat.clear ();
@@ -267,18 +267,18 @@ namespace octave
       return info;
     }
 
     template <>
     F77_INT
     schur<ComplexMatrix>::init (const ComplexMatrix& a, const std::string& ord,
                                 bool calc_unitary)
     {
-      F77_INT a_nr = octave::to_f77_int (a.rows ());
-      F77_INT a_nc = octave::to_f77_int (a.cols ());
+      F77_INT a_nr = to_f77_int (a.rows ());
+      F77_INT a_nc = to_f77_int (a.cols ());
 
       if (a_nr != a_nc)
         (*current_liboctave_error_handler) ("SCHUR requires square matrix");
 
       if (a_nr == 0)
         {
           schur_mat.clear ();
           unitary_mat.clear ();
@@ -352,17 +352,17 @@ namespace octave
 
     template <>
     schur<ComplexMatrix>
     rsf2csf<ComplexMatrix, Matrix> (const Matrix& s_arg, const Matrix& u_arg)
     {
       ComplexMatrix s (s_arg);
       ComplexMatrix u (u_arg);
 
-      F77_INT n = octave::to_f77_int (s.rows ());
+      F77_INT n = to_f77_int (s.rows ());
 
       if (s.columns () != n || u.rows () != n || u.columns () != n)
         (*current_liboctave_error_handler)
           ("rsf2csf: inconsistent matrix dimensions");
 
       if (n > 0)
         {
           OCTAVE_LOCAL_BUFFER (double, c, n-1);
@@ -375,18 +375,18 @@ namespace octave
       return schur<ComplexMatrix> (s, u);
     }
 
     template <>
     F77_INT
     schur<FloatComplexMatrix>::init (const FloatComplexMatrix& a,
                                      const std::string& ord, bool calc_unitary)
     {
-      F77_INT a_nr = octave::to_f77_int (a.rows ());
-      F77_INT a_nc = octave::to_f77_int (a.cols ());
+      F77_INT a_nr = to_f77_int (a.rows ());
+      F77_INT a_nc = to_f77_int (a.cols ());
 
       if (a_nr != a_nc)
         (*current_liboctave_error_handler) ("SCHUR requires square matrix");
 
       if (a_nr == 0)
         {
           schur_mat.clear ();
           unitary_mat.clear ();
@@ -461,17 +461,17 @@ namespace octave
     template <>
     schur<FloatComplexMatrix>
     rsf2csf<FloatComplexMatrix, FloatMatrix> (const FloatMatrix& s_arg,
                                               const FloatMatrix& u_arg)
     {
       FloatComplexMatrix s (s_arg);
       FloatComplexMatrix u (u_arg);
 
-      F77_INT n = octave::to_f77_int (s.rows ());
+      F77_INT n = to_f77_int (s.rows ());
 
       if (s.columns () != n || u.rows () != n || u.columns () != n)
         (*current_liboctave_error_handler)
           ("rsf2csf: inconsistent matrix dimensions");
 
       if (n > 0)
         {
           OCTAVE_LOCAL_BUFFER (float, c, n-1);
diff --git a/liboctave/numeric/sparse-chol.cc b/liboctave/numeric/sparse-chol.cc
--- a/liboctave/numeric/sparse-chol.cc
+++ b/liboctave/numeric/sparse-chol.cc
@@ -112,17 +112,17 @@ namespace octave
       RowVector perm (void) const { return perms + 1; }
 
       SparseMatrix Q (void) const;
 
       bool is_positive_definite (void) const { return is_pd; }
 
       double rcond (void) const { return cond; }
 
-      octave::refcount<int> count;
+      refcount<int> count;
 
     private:
 
       bool is_pd;
 
       octave_idx_type minor_p;
 
       RowVector perms;
diff --git a/liboctave/numeric/sparse-lu.cc b/liboctave/numeric/sparse-lu.cc
--- a/liboctave/numeric/sparse-lu.cc
+++ b/liboctave/numeric/sparse-lu.cc
@@ -413,43 +413,43 @@ namespace octave
       octave_idx_type nc = a.cols ();
 
       // Setup the control parameters
       Matrix Control (UMFPACK_CONTROL, 1);
       double *control = Control.fortran_vec ();
       umfpack_defaults<lu_elt_type> (control);
 
       double tmp = octave_sparse_params::get_key ("spumoni");
-      if (! octave::math::isnan (tmp))
+      if (! math::isnan (tmp))
         Control (UMFPACK_PRL) = tmp;
 
       if (piv_thres.numel () == 2)
         {
           tmp = (piv_thres (0) > 1. ? 1. : piv_thres (0));
-          if (! octave::math::isnan (tmp))
+          if (! math::isnan (tmp))
             Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
 
           tmp = (piv_thres (1) > 1. ? 1. : piv_thres (1));
-          if (! octave::math::isnan (tmp))
+          if (! math::isnan (tmp))
             Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
         }
       else
         {
           tmp = octave_sparse_params::get_key ("piv_tol");
-          if (! octave::math::isnan (tmp))
+          if (! math::isnan (tmp))
             Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
 
           tmp = octave_sparse_params::get_key ("sym_tol");
-          if (! octave::math::isnan (tmp))
+          if (! math::isnan (tmp))
             Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
         }
 
       // Set whether we are allowed to modify Q or not
       tmp = octave_sparse_params::get_key ("autoamd");
-      if (! octave::math::isnan (tmp))
+      if (! math::isnan (tmp))
         Control (UMFPACK_FIXQ) = tmp;
 
       // Turn-off UMFPACK scaling for LU
       if (scale)
         Control (UMFPACK_SCALE) = UMFPACK_SCALE_SUM;
       else
         Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
 
@@ -631,49 +631,49 @@ namespace octave
       octave_idx_type nc = a.cols ();
 
       // Setup the control parameters
       Matrix Control (UMFPACK_CONTROL, 1);
       double *control = Control.fortran_vec ();
       umfpack_defaults<lu_elt_type> (control);
 
       double tmp = octave_sparse_params::get_key ("spumoni");
-      if (! octave::math::isnan (tmp))
+      if (! math::isnan (tmp))
         Control (UMFPACK_PRL) = tmp;
 
       if (piv_thres.numel () == 2)
         {
           tmp = (piv_thres (0) > 1. ? 1. : piv_thres (0));
-          if (! octave::math::isnan (tmp))
+          if (! math::isnan (tmp))
             Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
           tmp = (piv_thres (1) > 1. ? 1. : piv_thres (1));
-          if (! octave::math::isnan (tmp))
+          if (! math::isnan (tmp))
             Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
         }
       else
         {
           tmp = octave_sparse_params::get_key ("piv_tol");
-          if (! octave::math::isnan (tmp))
+          if (! math::isnan (tmp))
             Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
 
           tmp = octave_sparse_params::get_key ("sym_tol");
-          if (! octave::math::isnan (tmp))
+          if (! math::isnan (tmp))
             Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
         }
 
       if (droptol >= 0.)
         Control (UMFPACK_DROPTOL) = droptol;
 
       // Set whether we are allowed to modify Q or not
       if (FixedQ)
         Control (UMFPACK_FIXQ) = 1.0;
       else
         {
           tmp = octave_sparse_params::get_key ("autoamd");
-          if (! octave::math::isnan (tmp))
+          if (! math::isnan (tmp))
             Control (UMFPACK_FIXQ) = tmp;
         }
 
       // Turn-off UMFPACK scaling for LU
       if (scale)
         Control (UMFPACK_SCALE) = UMFPACK_SCALE_SUM;
       else
         Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
diff --git a/liboctave/numeric/sparse-qr.cc b/liboctave/numeric/sparse-qr.cc
--- a/liboctave/numeric/sparse-qr.cc
+++ b/liboctave/numeric/sparse-qr.cc
@@ -109,17 +109,17 @@ namespace octave
       SPARSE_T R (bool econ) const;
 
       typename SPARSE_T::dense_matrix_type
       C (const typename SPARSE_T::dense_matrix_type& b) const;
 
       typename SPARSE_T::dense_matrix_type
       Q (void) const;
 
-      octave::refcount<int> count;
+      refcount<int> count;
 
       octave_idx_type nrows;
       octave_idx_type ncols;
 
       typename cxsparse_types<SPARSE_T>::symbolic_type *S;
       typename cxsparse_types<SPARSE_T>::numeric_type *N;
 
       template <typename RHS_T, typename RET_T>
diff --git a/liboctave/numeric/svd.cc b/liboctave/numeric/svd.cc
--- a/liboctave/numeric/svd.cc
+++ b/liboctave/numeric/svd.cc
@@ -273,18 +273,18 @@ namespace octave
 
     template<typename T>
     svd<T>::svd (const T& a, svd::Type type,
                  svd::Driver driver)
       : m_type (type), m_driver (driver), left_sm (), sigma (), right_sm ()
     {
       F77_INT info;
 
-      F77_INT m = octave::to_f77_int (a.rows ());
-      F77_INT n = octave::to_f77_int (a.cols ());
+      F77_INT m = to_f77_int (a.rows ());
+      F77_INT n = to_f77_int (a.cols ());
 
       if (m == 0 || n == 0)
         {
           switch (m_type)
             {
             case svd::Type::std:
               left_sm = T (m, m, 0);
               for (F77_INT i = 0; i < m; i++)
diff --git a/liboctave/system/child-list.cc b/liboctave/system/child-list.cc
--- a/liboctave/system/child-list.cc
+++ b/liboctave/system/child-list.cc
@@ -140,17 +140,17 @@ namespace octave
         child& oc = *p;
 
         pid_t pid = oc.pid;
 
         if (pid > 0)
           {
             int status;
 
-            if (octave::sys::waitpid (pid, &status, octave::sys::wnohang ()) > 0)
+            if (sys::waitpid (pid, &status, sys::wnohang ()) > 0)
               {
                 oc.have_status = 1;
 
                 oc.status = status;
 
                 retval = true;
 
                 break;
diff --git a/liboctave/system/dir-ops.cc b/liboctave/system/dir-ops.cc
--- a/liboctave/system/dir-ops.cc
+++ b/liboctave/system/dir-ops.cc
@@ -48,17 +48,17 @@ namespace octave
     {
       if (! n.empty ())
         name = n;
 
       if (! name.empty ())
         {
           close ();
 
-          std::string fullname = octave::sys::file_ops::tilde_expand (name);
+          std::string fullname = sys::file_ops::tilde_expand (name);
 
           dir = octave_opendir_wrapper (fullname.c_str ());
 
           if (! dir)
             errmsg = std::strerror (errno);
         }
       else
         errmsg = "dir_entry::open: empty filename";
diff --git a/liboctave/system/file-ops.cc b/liboctave/system/file-ops.cc
--- a/liboctave/system/file-ops.cc
+++ b/liboctave/system/file-ops.cc
@@ -50,20 +50,20 @@ along with Octave; see the file COPYING.
 #include "stat-wrappers.h"
 #include "str-vec.h"
 #include "unistd-wrappers.h"
 
 namespace octave
 {
   namespace sys
   {
-    file_ops *octave::sys::file_ops::instance = nullptr;
+    file_ops *sys::file_ops::instance = nullptr;
 
     bool
-    octave::sys::file_ops::instance_ok (void)
+    sys::file_ops::instance_ok (void)
     {
       bool retval = true;
 
       if (! instance)
         {
 #if (defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM) && ! defined (OCTAVE_HAVE_POSIX_FILESYSTEM))
           char system_dev_sep_char = ':';
           char system_dir_sep_char = '\\';
@@ -106,37 +106,37 @@ namespace octave
     // any word separation get desired behavior.
     static const char *default_suffixes[] = { " ", "\n", ":", 0 };
 
     // If non-null, this contains the address of a function that the
     // application wants called before trying the standard tilde
     // expansions.  The function is called with the text sans tilde, and
     // returns a malloc()'ed string which is the expansion, or a NULL
     // pointer if the expansion fails.
-    octave::sys::file_ops::tilde_expansion_hook
-      octave::sys::file_ops::tilde_expansion_preexpansion_hook = 0;
+    sys::file_ops::tilde_expansion_hook
+      sys::file_ops::tilde_expansion_preexpansion_hook = 0;
 
     // If non-null, this contains the address of a function to call if the
     // standard meaning for expanding a tilde fails.  The function is
     // called with the text (sans tilde, as in "foo"), and returns a
     // malloc()'ed string which is the expansion, or a NULL pointer if
     // there is no expansion.
-    octave::sys::file_ops::tilde_expansion_hook
-      octave::sys::file_ops::tilde_expansion_failure_hook = 0;
+    sys::file_ops::tilde_expansion_hook
+      sys::file_ops::tilde_expansion_failure_hook = 0;
 
     // When non-null, this is a NULL terminated array of strings which are
     // duplicates for a tilde prefix.  Bash uses this to expand '=~' and
     // ':~'.
-    string_vector octave::sys::file_ops::tilde_additional_prefixes =
+    string_vector sys::file_ops::tilde_additional_prefixes =
       default_prefixes;
 
     // When non-null, this is a NULL terminated array of strings which
     // match the end of a username, instead of just "/".  Bash sets this
     // to ':' and '=~'.
-    string_vector octave::sys::file_ops::tilde_additional_suffixes =
+    string_vector sys::file_ops::tilde_additional_suffixes =
       default_suffixes;
 
     // Find the start of a tilde expansion in S, and return the index
     // of the tilde which starts the expansion.  Place the length of the
     // text which identified this tilde starter in LEN, excluding the
     // tilde itself.
 
     static size_t
@@ -144,17 +144,17 @@ namespace octave
     {
       len = 0;
 
       size_t s_len = s.length ();
 
       if (s_len == 0 || s[0] == '~')
         return 0;
 
-      string_vector prefixes = octave::sys::file_ops::tilde_additional_prefixes;
+      string_vector prefixes = sys::file_ops::tilde_additional_prefixes;
 
       if (! prefixes.empty ())
         {
           for (size_t i = 0; i < s_len; i++)
             {
               for (int j = 0; j < prefixes.numel (); j++)
                 {
                   size_t pfx_len = prefixes[j].length ();
@@ -174,23 +174,23 @@ namespace octave
     // Find the end of a tilde expansion in S, and return the index
     // of the character which ends the tilde definition.
 
     static size_t
     tilde_find_suffix (const std::string& s)
     {
       size_t s_len = s.length ();
 
-      string_vector suffixes = octave::sys::file_ops::tilde_additional_suffixes;
+      string_vector suffixes = sys::file_ops::tilde_additional_suffixes;
 
       size_t i = 0;
 
       for ( ; i < s_len; i++)
         {
-          if (octave::sys::file_ops::is_dir_sep (s[i]))
+          if (sys::file_ops::is_dir_sep (s[i]))
             break;
 
           if (! suffixes.empty ())
             {
               for (int j = 0; j < suffixes.numel (); j++)
                 {
                   size_t sfx_len = suffixes[j].length ();
 
@@ -207,17 +207,17 @@ namespace octave
 
     static std::string
     isolate_tilde_prefix (const std::string& fname)
     {
       size_t f_len = fname.length ();
 
       size_t len = 1;
 
-      while (len < f_len && ! octave::sys::file_ops::is_dir_sep (fname[len]))
+      while (len < f_len && ! sys::file_ops::is_dir_sep (fname[len]))
         len++;
 
       return fname.substr (1, len);
     }
 
     // Do the work of tilde expansion on FILENAME.  FILENAME starts with a
     // tilde.
 
@@ -228,48 +228,48 @@ namespace octave
 
       if (f_len == 0 || filename[0] != '~')
         return std::string (filename);
 
       // A leading '~/' or a bare '~' is *always* translated to the value
       // of $HOME or the home directory of the current user, regardless of
       // any preexpansion hook.
 
-      if (f_len == 1 || octave::sys::file_ops::is_dir_sep (filename[1]))
-        return octave::sys::env::get_home_directory () + filename.substr (1);
+      if (f_len == 1 || sys::file_ops::is_dir_sep (filename[1]))
+        return sys::env::get_home_directory () + filename.substr (1);
 
       std::string username = isolate_tilde_prefix (filename);
 
       size_t user_len = username.length ();
 
       std::string dirname;
 
-      if (octave::sys::file_ops::tilde_expansion_preexpansion_hook)
+      if (sys::file_ops::tilde_expansion_preexpansion_hook)
         {
           std::string expansion
-            = octave::sys::file_ops::tilde_expansion_preexpansion_hook (username);
+            = sys::file_ops::tilde_expansion_preexpansion_hook (username);
 
           if (! expansion.empty ())
             return expansion + filename.substr (user_len+1);
         }
 
       // No preexpansion hook, or the preexpansion hook failed.  Look in the
       // password database.
 
-      octave::sys::password pw = octave::sys::password::getpwnam (username);
+      sys::password pw = sys::password::getpwnam (username);
 
       if (! pw)
         {
           // If the calling program has a special syntax for expanding tildes,
           // and we couldn't find a standard expansion, then let them try.
 
-          if (octave::sys::file_ops::tilde_expansion_failure_hook)
+          if (sys::file_ops::tilde_expansion_failure_hook)
             {
               std::string expansion
-                = octave::sys::file_ops::tilde_expansion_failure_hook (username);
+                = sys::file_ops::tilde_expansion_failure_hook (username);
 
               if (! expansion.empty ())
                 dirname = expansion + filename.substr (user_len+1);
             }
 
           // If we don't have a failure hook, or if the failure hook did not
           // expand the tilde, return a copy of what we were passed.
 
@@ -278,32 +278,32 @@ namespace octave
         }
       else
         dirname = pw.dir () + filename.substr (user_len+1);
 
       return dirname;
     }
 
     bool
-    octave::sys::file_ops::is_dev_sep (char c)
+    sys::file_ops::is_dev_sep (char c)
     {
 #if (defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM) && ! defined (OCTAVE_HAVE_POSIX_FILESYSTEM))
       return c == dev_sep_char ();
 #else
       octave_unused_parameter (c);
 
       return false;
 #endif
     }
 
     // If NAME has a leading ~ or ~user, Unix-style, expand it to the
     // user's home directory.  If no ~, or no <pwd.h>, just return NAME.
 
     std::string
-    octave::sys::file_ops::tilde_expand (const std::string& name)
+    sys::file_ops::tilde_expand (const std::string& name)
     {
       if (name.find ('~') == std::string::npos)
         return std::string (name);
       else
         {
           std::string result;
 
           size_t name_len = name.length ();
@@ -352,42 +352,42 @@ namespace octave
 
           return result;
         }
     }
 
     // A vector version of the above.
 
     string_vector
-    octave::sys::file_ops::tilde_expand (const string_vector& names)
+    sys::file_ops::tilde_expand (const string_vector& names)
     {
       string_vector retval;
 
       int n = names.numel ();
 
       retval.resize (n);
 
       for (int i = 0; i < n; i++)
         retval[i] = tilde_expand (names[i]);
 
       return retval;
     }
 
     std::string
-    octave::sys::file_ops::concat (const std::string& dir, const std::string& file)
+    sys::file_ops::concat (const std::string& dir, const std::string& file)
     {
       return dir.empty ()
              ? file
              : (is_dir_sep (dir[dir.length ()-1])
                 ? dir + file
                 : dir + dir_sep_char () + file);
     }
 
     std::string
-    octave::sys::file_ops::native_separator_path (const std::string& path)
+    sys::file_ops::native_separator_path (const std::string& path)
     {
       std::string retval;
 
       if (dir_sep_char () == '/')
         retval = path;
       else
         {
           size_t n = path.length ();
@@ -402,17 +402,17 @@ namespace octave
 
       return retval;
     }
 
     int
     mkdir (const std::string& nm, mode_t md)
     {
       std::string msg;
-      return octave::sys::mkdir (nm, md, msg);
+      return sys::mkdir (nm, md, msg);
     }
 
     int
     mkdir (const std::string& name, mode_t mode, std::string& msg)
     {
       msg = "";
 
       int status = octave_mkdir_wrapper (name.c_str (), mode);
@@ -572,36 +572,36 @@ namespace octave
 
     int
     recursive_rmdir (const std::string& name, std::string& msg)
     {
       msg = "";
 
       int status = 0;
 
-      octave::sys::dir_entry dir (name);
+      sys::dir_entry dir (name);
 
       if (dir)
         {
           string_vector dirlist = dir.read ();
 
           for (octave_idx_type i = 0; i < dirlist.numel (); i++)
             {
               octave_quit ();
 
               std::string nm = dirlist[i];
 
               // Skip current directory and parent.
               if (nm == "." || nm == "..")
                 continue;
 
-              std::string fullnm = name + octave::sys::file_ops::dir_sep_str () + nm;
+              std::string fullnm = name + sys::file_ops::dir_sep_str () + nm;
 
               // Get info about the file.  Don't follow links.
-              octave::sys::file_stat fs (fullnm, false);
+              sys::file_stat fs (fullnm, false);
 
               if (fs)
                 {
                   if (fs.is_dir ())
                     {
                       status = recursive_rmdir (fullnm, msg);
 
                       if (status < 0)
@@ -679,25 +679,25 @@ namespace octave
     {
       msg = "";
 
       std::string retval;
 
       // get dir path to use for template
       std::string templatename;
       if (dir.empty ())
-        templatename = octave::sys::env::get_temp_directory ();
-      else if (! octave::sys::file_stat (dir, false).is_dir ())
-        templatename = octave::sys::env::get_temp_directory ();
+        templatename = sys::env::get_temp_directory ();
+      else if (! sys::file_stat (dir, false).is_dir ())
+        templatename = sys::env::get_temp_directory ();
       else
         templatename = dir;
 
       // add dir sep char if it is not there
-      if (*templatename.rbegin () != octave::sys::file_ops::dir_sep_char ())
-        templatename += octave::sys::file_ops::dir_sep_char ();
+      if (*templatename.rbegin () != sys::file_ops::dir_sep_char ())
+        templatename += sys::file_ops::dir_sep_char ();
 
       if (pfx.empty ())
         templatename += "file";
       else
         templatename += pfx;
 
       // add the required XXXXXX for the template
       templatename += "XXXXXX";
diff --git a/liboctave/system/file-stat.cc b/liboctave/system/file-stat.cc
--- a/liboctave/system/file-stat.cc
+++ b/liboctave/system/file-stat.cc
@@ -153,17 +153,17 @@ namespace octave
       return std::string (buf);
     }
 
     // Has FILE been modified since TIME?  Returns 1 for yes, 0 for no,
     // and -1 for any error.
 
     int
     base_file_stat::is_newer (const std::string& file,
-                              const octave::sys::time& time)
+                              const sys::time& time)
     {
       file_stat fs (file);
 
       return fs ? fs.is_newer (time) : -1;
     }
 
     // Private stuff:
 
@@ -179,21 +179,21 @@ namespace octave
     void
     file_stat::update_internal (bool force)
     {
       if (! initialized || force)
         {
           initialized = false;
           fail = false;
 
-          std::string full_file_name = octave::sys::file_ops::tilde_expand (file_name);
+          std::string full_file_name = sys::file_ops::tilde_expand (file_name);
 
 #if defined (__WIN32__)
           // Remove trailing slash.
-          if (octave::sys::file_ops::is_dir_sep (full_file_name[full_file_name.length () - 1])
+          if (sys::file_ops::is_dir_sep (full_file_name[full_file_name.length () - 1])
               && full_file_name.length () != 1
               && ! (full_file_name.length () == 3 && full_file_name[1] == ':'))
             full_file_name.resize (full_file_name.length () - 1);
 #endif
 
           const char *cname = full_file_name.c_str ();
 
           time_t sys_atime, sys_mtime, sys_ctime;
@@ -211,19 +211,19 @@ namespace octave
 
           if (status < 0)
             {
               fail = true;
               errmsg = std::strerror (errno);
             }
           else
             {
-              m_atime = octave::sys::time (sys_atime);
-              m_mtime = octave::sys::time (sys_mtime);
-              m_ctime = octave::sys::time (sys_ctime);
+              m_atime = sys::time (sys_atime);
+              m_mtime = sys::time (sys_mtime);
+              m_ctime = sys::time (sys_ctime);
             }
 
           initialized = true;
         }
     }
 
     void
     file_fstat::update_internal (bool force)
@@ -243,18 +243,18 @@ namespace octave
 
           if (status < 0)
             {
               fail = true;
               errmsg = std::strerror (errno);
             }
           else
             {
-              m_atime = octave::sys::time (sys_atime);
-              m_mtime = octave::sys::time (sys_mtime);
-              m_ctime = octave::sys::time (sys_ctime);
+              m_atime = sys::time (sys_atime);
+              m_mtime = sys::time (sys_mtime);
+              m_ctime = sys::time (sys_ctime);
             }
 
           initialized = true;
         }
     }
   }
 }
diff --git a/liboctave/system/file-stat.h b/liboctave/system/file-stat.h
--- a/liboctave/system/file-stat.h
+++ b/liboctave/system/file-stat.h
@@ -78,19 +78,19 @@ namespace octave
           }
 
         return *this;
       }
 
       // The minimum difference in file time stamp values.
       // FIXME: This value should come from the filesystem itself.
       //        How can we get that info?
-      octave::sys::time time_resolution (void) const
+      sys::time time_resolution (void) const
       {
-        static octave::sys::time resolution (1.0);
+        static sys::time resolution (1.0);
         return resolution;
       }
 
       // File status and info.  The is_XXX functions will return false for
       // file_stat objects that are not properly initialized.  The others
       // should all return 0 (or the equivalent, for the given object)
       // which is likely not meaningful.
 
@@ -119,19 +119,19 @@ namespace octave
 
       nlink_t nlink (void) const { return m_nlink; }
 
       uid_t uid (void) const { return m_uid; }
       gid_t gid (void) const { return m_gid; }
 
       off_t size (void) const { return m_size; }
 
-      octave::sys::time atime (void) const { return m_atime; }
-      octave::sys::time mtime (void) const { return m_mtime; }
-      octave::sys::time ctime (void) const { return m_ctime; }
+      sys::time atime (void) const { return m_atime; }
+      sys::time mtime (void) const { return m_mtime; }
+      sys::time ctime (void) const { return m_ctime; }
 
       dev_t rdev (void) const { return m_rdev; }
 
       long blksize (void) const { return m_blksize; }
       long blocks (void) const { return m_blocks; }
 
       mode_t mode (void) const { return m_mode; }
 
@@ -141,21 +141,21 @@ namespace octave
 
       operator bool () const { return ok (); }
 
       bool exists (void) const { return ok (); }
 
       std::string error (void) const { return ok () ? "" : errmsg; }
 
       // Has the file referenced by this object been modified since TIME?
-      bool is_newer (const octave::sys::time& time) const { return m_mtime > time; }
+      bool is_newer (const sys::time& time) const { return m_mtime > time; }
 
       // It's nice to be able to hide the file_stat object if we don't
       // really care about it.
-      static int is_newer (const std::string&, const octave::sys::time&);
+      static int is_newer (const std::string&, const sys::time&);
 
     protected:
 
       virtual ~base_file_stat (void) = default;
 
       // TRUE means we have already called stat.
       bool initialized;
 
@@ -182,23 +182,23 @@ namespace octave
 
       // group ID of owner
       gid_t m_gid;
 
       // size in bytes, for regular files
       off_t m_size;
 
       // time of last access
-      octave::sys::time m_atime;
+      sys::time m_atime;
 
       // time of last modification
-      octave::sys::time m_mtime;
+      sys::time m_mtime;
 
       // time of last file status change
-      octave::sys::time m_ctime;
+      sys::time m_ctime;
 
       // device number for special files
       dev_t m_rdev;
 
       // best I/O block size
       long m_blksize;
 
       // number of 512-byte blocks allocated
diff --git a/liboctave/system/lo-sysdep.cc b/liboctave/system/lo-sysdep.cc
--- a/liboctave/system/lo-sysdep.cc
+++ b/liboctave/system/lo-sysdep.cc
@@ -53,17 +53,17 @@ namespace octave
       free (tmp);
 
       return retval;
     }
 
     int
     chdir (const std::string& path_arg)
     {
-      std::string path = octave::sys::file_ops::tilde_expand (path_arg);
+      std::string path = sys::file_ops::tilde_expand (path_arg);
 
 #if defined (OCTAVE_USE_WINDOWS_API)
       if (path.length () == 2 && path[1] == ':')
         path += "\\";
 #endif
 
       return octave_chdir_wrapper (path.c_str ());
     }
diff --git a/liboctave/system/oct-env.cc b/liboctave/system/oct-env.cc
--- a/liboctave/system/oct-env.cc
+++ b/liboctave/system/oct-env.cc
@@ -274,17 +274,17 @@ namespace octave
           // exist for the duration of the program so allocate a copy here
           // instead of passing S.c_str () which only exists as long as the
           // string object S.
 
           prog_invocation_name
             = octave_set_program_name_wrapper (strsave (s.c_str ()));
 
           size_t pos
-            = prog_invocation_name.find_last_of (octave::sys::file_ops::dir_sep_chars ());
+            = prog_invocation_name.find_last_of (sys::file_ops::dir_sep_chars ());
 
           // Also keep a shortened version of the program name.
           prog_name = (pos == std::string::npos
                        ? prog_invocation_name
                        : prog_invocation_name.substr (pos+1));
 
           initialized = true;
         }
@@ -298,17 +298,17 @@ namespace octave
     {
       std::string retval;
 
       std::string home_dir = do_get_home_directory ();
 
       size_t len = home_dir.length ();
 
       if (len > 1 && home_dir == name.substr (0, len)
-          && (name.length () == len || octave::sys::file_ops::is_dir_sep (name[len])))
+          && (name.length () == len || sys::file_ops::is_dir_sep (name[len])))
         {
           retval = "~";
           retval.append (name.substr (len));
         }
       else
         retval = name;
 
       return retval;
@@ -317,23 +317,23 @@ namespace octave
     bool
     env::do_absolute_pathname (const std::string& s) const
     {
       size_t len = s.length ();
 
       if (len == 0)
         return false;
 
-      if (octave::sys::file_ops::is_dir_sep (s[0]))
+      if (sys::file_ops::is_dir_sep (s[0]))
         return true;
 
 #if defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM)
       if ((len == 2 && isalpha (s[0]) && s[1] == ':')
           || (len > 2 && isalpha (s[0]) && s[1] == ':'
-              && octave::sys::file_ops::is_dir_sep (s[2])))
+              && sys::file_ops::is_dir_sep (s[2])))
         return true;
 #endif
 
       return false;
     }
 
     bool
     env::do_rooted_relative_pathname (const std::string& s) const
@@ -341,40 +341,40 @@ namespace octave
       size_t len = s.length ();
 
       if (len == 0)
         return false;
 
       if (len == 1 && s[0] == '.')
         return true;
 
-      if (len > 1 && s[0] == '.' && octave::sys::file_ops::is_dir_sep (s[1]))
+      if (len > 1 && s[0] == '.' && sys::file_ops::is_dir_sep (s[1]))
         return true;
 
       if (len == 2 && s[0] == '.' && s[1] == '.')
         return true;
 
       if (len > 2 && s[0] == '.' && s[1] == '.'
-          && octave::sys::file_ops::is_dir_sep (s[2]))
+          && sys::file_ops::is_dir_sep (s[2]))
         return true;
 
       return false;
     }
 
     // Return the 'basename' of the pathname in STRING (the stuff after
     // the last directory separator).  If STRING is not a full pathname,
     // simply return it.
 
     std::string
     env::do_base_pathname (const std::string& s) const
     {
       if (! (do_absolute_pathname (s) || do_rooted_relative_pathname (s)))
         return s;
 
-      size_t pos = s.find_last_of (octave::sys::file_ops::dir_sep_chars ());
+      size_t pos = s.find_last_of (sys::file_ops::dir_sep_chars ());
 
       if (pos == std::string::npos)
         return s;
       else
         return s.substr (pos+1);
     }
 
     // Turn STRING (a pathname) into an absolute pathname, assuming that
@@ -389,51 +389,51 @@ namespace octave
 
       // Optimization: every time Octave returns to the prompt it calls
       // make_absolute_filename with '.' as argument.
       if (s == ".")
         return dot_path;
 
       std::string current_dir = dot_path;
 
-      if (! octave::sys::file_ops::is_dir_sep (current_dir.back ()))
-        current_dir.append (octave::sys::file_ops::dir_sep_str ());
+      if (! sys::file_ops::is_dir_sep (current_dir.back ()))
+        current_dir.append (sys::file_ops::dir_sep_str ());
 
       size_t i = 0;
       size_t slen = s.length ();
 
       while (i < slen)
         {
           if (s[i] == '.')
             {
               if (i + 1 == slen)
                 break;
 
-              if (octave::sys::file_ops::is_dir_sep (s[i+1]))
+              if (sys::file_ops::is_dir_sep (s[i+1]))
                 {
                   i += 2;
                   continue;
                 }
 
               if (s[i+1] == '.'
                   && (i + 2 == slen
-                      || octave::sys::file_ops::is_dir_sep (s[i+2])))
+                      || sys::file_ops::is_dir_sep (s[i+2])))
                 {
                   i += 2;
                   if (i != slen)
                     i++;
 
                   pathname_backup (current_dir, 1);
 
                   continue;
                 }
             }
 
           size_t sep_pos;
-          sep_pos = s.find_first_of (octave::sys::file_ops::dir_sep_chars (), i);
+          sep_pos = s.find_first_of (sys::file_ops::dir_sep_chars (), i);
 
           if (sep_pos == std::string::npos)
             {
               current_dir.append (s, i, sep_pos-i);
               break;
             }
           else if (sep_pos == i)
             {
@@ -443,32 +443,32 @@ namespace octave
           else
             {
               current_dir.append (s, i, sep_pos-i+1);
               i = sep_pos + 1;
             }
         }
 
       // Strip any trailing directory separator
-      if (octave::sys::file_ops::is_dir_sep (current_dir.back ()))
+      if (sys::file_ops::is_dir_sep (current_dir.back ()))
         current_dir.pop_back ();
 
       return current_dir;
     }
 
     // Return a string which is the current working directory.
 
     std::string
     env::do_getcwd () const
     {
       if (! follow_symbolic_links)
         current_directory = "";
 
       if (verbatim_pwd || current_directory.empty ())
-        current_directory = octave::sys::getcwd ();
+        current_directory = sys::getcwd ();
 
       return current_directory;
     }
 
     // This value is not cached because it can change while Octave is
     // running.
 
     std::string
@@ -485,32 +485,32 @@ namespace octave
             hd = do_getenv ("HOMEPATH");
           else
             hd = drv + do_getenv ("HOMEPATH");
         }
 #endif
 
       if (hd.empty ())
         {
-          octave::sys::password pw = octave::sys::password::getpwuid (
-                                       octave::sys::getuid ());
+          sys::password pw = sys::password::getpwuid (
+                                       sys::getuid ());
 
-          hd = (pw ? pw.dir () : std::string (octave::sys::file_ops::dir_sep_str ()));
+          hd = (pw ? pw.dir () : std::string (sys::file_ops::dir_sep_str ()));
         }
 
       return hd;
     }
 
     std::string
     env::do_get_user_name (void) const
     {
       if (user_name.empty ())
         {
-          octave::sys::password pw = octave::sys::password::getpwuid (
-                                       octave::sys::getuid ());
+          sys::password pw = sys::password::getpwuid (
+                                       sys::getuid ());
 
           user_name = (pw ? pw.name () : std::string ("unknown"));
         }
 
       return user_name;
     }
 
     std::string
@@ -557,48 +557,48 @@ namespace octave
             tmp = do_make_absolute (newdir, current_directory);
 
           // Get rid of trailing directory separator.
 
           size_t len = tmp.length ();
 
           if (len > 1)
             {
-              if (octave::sys::file_ops::is_dir_sep (tmp[--len]))
+              if (sys::file_ops::is_dir_sep (tmp[--len]))
                 tmp.resize (len);
             }
 
-          if (! octave::sys::chdir (tmp))
+          if (! sys::chdir (tmp))
             {
               current_directory = tmp;
               retval = true;
             }
         }
       else
-        retval = (! octave::sys::chdir (newdir));
+        retval = (! sys::chdir (newdir));
 
       return retval;
     }
 
     // Remove the last N directories from PATH.
 
     void
     env::pathname_backup (std::string& path, int n) const
     {
       if (path.empty ())
         return;
 
       size_t i = path.length () - 1;
 
       while (n--)
         {
-          while (octave::sys::file_ops::is_dir_sep (path[i]) && i > 0)
+          while (sys::file_ops::is_dir_sep (path[i]) && i > 0)
             i--;
 
-          while (! octave::sys::file_ops::is_dir_sep (path[i]) && i > 0)
+          while (! sys::file_ops::is_dir_sep (path[i]) && i > 0)
             i--;
 
           i++;
         }
 
       path.resize (i);
     }
 
diff --git a/liboctave/system/oct-syscalls.cc b/liboctave/system/oct-syscalls.cc
--- a/liboctave/system/oct-syscalls.cc
+++ b/liboctave/system/oct-syscalls.cc
@@ -45,17 +45,17 @@ along with Octave; see the file COPYING.
 namespace octave
 {
   namespace sys
   {
     int
     dup2 (int old_fd, int new_fd)
     {
       std::string msg;
-      return octave::sys::dup2 (old_fd, new_fd, msg);
+      return sys::dup2 (old_fd, new_fd, msg);
     }
 
     int
     dup2 (int old_fd, int new_fd, std::string& msg)
     {
       msg = "";
 
       int status = -1;
@@ -67,17 +67,17 @@ namespace octave
 
       return status;
     }
 
     int
     execvp (const std::string& file, const string_vector& argv)
     {
       std::string msg;
-      return octave::sys::execvp (file, argv, msg);
+      return sys::execvp (file, argv, msg);
     }
 
     int
     execvp (const std::string& file, const string_vector& args,
             std::string& msg)
     {
       msg = "";
 
@@ -178,17 +178,17 @@ namespace octave
     {
       return octave_geteuid_wrapper ();
     }
 
     int
     pipe (int *fildes)
     {
       std::string msg;
-      return octave::sys::pipe (fildes, msg);
+      return sys::pipe (fildes, msg);
     }
 
     int
     pipe (int *fildes, std::string& msg)
     {
       msg = "";
 
       int status = -1;
@@ -200,17 +200,17 @@ namespace octave
 
       return status;
     }
 
     pid_t
     waitpid (pid_t pid, int *status, int options)
     {
       std::string msg;
-      return octave::sys::waitpid (pid, status, options, msg);
+      return sys::waitpid (pid, status, options, msg);
     }
 
     pid_t
     waitpid (pid_t pid, int *status, int options,
              std::string& msg)
     {
       pid_t retval = -1;
       msg = "";
@@ -288,17 +288,17 @@ namespace octave
     {
       return octave_wuntraced_wrapper ();
     }
 
     int
     kill (pid_t pid, int sig)
     {
       std::string msg;
-      return octave::sys::kill (pid, sig, msg);
+      return sys::kill (pid, sig, msg);
     }
 
     int
     kill (pid_t pid, int sig, std::string& msg)
     {
       msg = "";
 
       int status = -1;
@@ -316,17 +316,17 @@ namespace octave
       return status;
     }
 
     pid_t
     popen2 (const std::string& cmd, const string_vector& args,
             bool sync_mode, int *fildes)
     {
       std::string msg;
-      return octave::sys::popen2 (cmd, args, sync_mode, fildes, msg);
+      return sys::popen2 (cmd, args, sync_mode, fildes, msg);
     }
 
     pid_t
     popen2 (const std::string& cmd, const string_vector& args,
             bool sync_mode, int *fildes, std::string& msg)
     {
       char **argv = args.c_str_vec ();
       const char *errmsg;
@@ -341,17 +341,17 @@ namespace octave
 
       return pid;
     }
 
     int
     fcntl (int fd, int cmd, long arg)
     {
       std::string msg;
-      return octave::sys::fcntl (fd, cmd, arg, msg);
+      return sys::fcntl (fd, cmd, arg, msg);
     }
 
     int
     fcntl (int fd, int cmd, long arg, std::string& msg)
     {
       msg = "";
 
       int status = -1;
diff --git a/liboctave/util/cmd-edit.cc b/liboctave/util/cmd-edit.cc
--- a/liboctave/util/cmd-edit.cc
+++ b/liboctave/util/cmd-edit.cc
@@ -56,17 +56,17 @@ namespace octave
   command_editor *command_editor::instance = nullptr;
 
   std::set<command_editor::startup_hook_fcn> command_editor::startup_hook_set;
 
   std::set<command_editor::pre_input_hook_fcn> command_editor::pre_input_hook_set;
 
   std::set<command_editor::event_hook_fcn> command_editor::event_hook_set;
 
-  static octave::mutex event_hook_lock;
+  static mutex event_hook_lock;
 
 #if defined (USE_READLINE)
 
   class
   gnu_readline : public command_editor
   {
   public:
 
@@ -242,17 +242,17 @@ namespace octave
       previous_pre_input_hook (0),
       previous_event_hook (0), completion_function (0),
       quoting_function (0), dequoting_function (0),
       char_is_quoted_function (0), user_accept_line_function (0)
   {
     // FIXME: need interface to rl_add_defun, rl_initialize, and
     // a function to set rl_terminal_name
 
-    std::string term = octave::sys::env::getenv ("TERM");
+    std::string term = sys::env::getenv ("TERM");
 
     octave_rl_set_terminal_name (term.c_str ());
 
     octave_rl_initialize ();
 
     do_blink_matching_paren (true);
 
     // Bind operate-and-get-next.
@@ -534,33 +534,33 @@ namespace octave
   {
     bool retval = false;
 
     const char *s = strrchr (line, delim);
 
     if (s)
       {
         // Remove incomplete component.
-        const char *f = strrchr (line, octave::sys::file_ops::dir_sep_char ());
+        const char *f = strrchr (line, sys::file_ops::dir_sep_char ());
 
         if (s[1] == '~' || (f && f != s))
           {
             // For something like "A /b", f==s; don't assume a file.
 
             std::string candidate_filename = s+1;
 
             candidate_filename = candidate_filename.substr (0, f - s);
 
             // Handles any complete ~<username>, but doesn't expand usernames.
 
             if (candidate_filename[0] == '~')
               candidate_filename
-                = octave::sys::file_ops::tilde_expand (candidate_filename);
+                = sys::file_ops::tilde_expand (candidate_filename);
 
-            octave::sys::file_stat fs (candidate_filename);
+            sys::file_stat fs (candidate_filename);
 
             retval = fs.is_dir ();
           }
       }
 
     return retval;
   }
 
@@ -1571,17 +1571,17 @@ namespace octave
     event_handler ();
   }
 
   void
   command_editor::read_init_file (const std::string& file_arg)
   {
     if (instance_ok ())
       {
-        std::string file = octave::sys::file_ops::tilde_expand (file_arg);
+        std::string file = sys::file_ops::tilde_expand (file_arg);
 
         instance->do_read_init_file (file);
       }
   }
 
   void
   command_editor::re_read_init_file (void)
   {
@@ -1709,17 +1709,17 @@ namespace octave
 
               case 'd':
               case 't':
               case 'T':
               case '@':
               case 'A':
                 // Make the current time/date into a string.
                 {
-                  octave::sys::localtime now;
+                  sys::localtime now;
 
                   if (c == 'd')
                     tmpstr = now.strftime ("%a %b %d");
                   else if (c == 't')
                     tmpstr = now.strftime ("%H:%M:%S");
                   else if (c == 'T')
                     tmpstr = now.strftime ("%I:%M:%S");
                   else if (c == '@')
@@ -1734,29 +1734,29 @@ namespace octave
                 {
                   tmpstr = '\033';
 
                   break;
                 }
 
               case 'h':
                 {
-                  tmpstr = octave::sys::env::get_host_name ();
+                  tmpstr = sys::env::get_host_name ();
 
                   size_t pos = tmpstr.find ('.');
 
                   if (pos != std::string::npos)
                     tmpstr.resize (pos);
 
                   break;
                 }
 
               case 'H':
                 {
-                  tmpstr = octave::sys::env::get_host_name ();
+                  tmpstr = sys::env::get_host_name ();
 
                   break;
                 }
 
               case 'n':
                 {
                   tmpstr = newline_chars ();
 
@@ -1767,55 +1767,55 @@ namespace octave
                 {
                   tmpstr = '\r';
 
                   break;
                 }
 
               case 's':
                 {
-                  tmpstr = octave::sys::env::get_program_name ();
-                  tmpstr = octave::sys::env::base_pathname (tmpstr);
+                  tmpstr = sys::env::get_program_name ();
+                  tmpstr = sys::env::base_pathname (tmpstr);
 
                   break;
                 }
 
               case 'u':
                 {
-                  tmpstr = octave::sys::env::get_user_name ();
+                  tmpstr = sys::env::get_user_name ();
 
                   break;
                 }
 
               case 'w':
               case 'W':
                 {
                   try
                     {
-                      tmpstr = octave::sys::env::get_current_directory ();
+                      tmpstr = sys::env::get_current_directory ();
                     }
-                  catch (const octave::execution_exception&)
+                  catch (const execution_exception&)
                     {
                       tmpstr = "";
                     }
 
-                  std::string home_dir = octave::sys::env::get_home_directory ();
+                  std::string home_dir = sys::env::get_home_directory ();
 
                   if (c == 'W' && (home_dir.empty () || tmpstr != home_dir))
                     {
                       if (tmpstr != "/" && tmpstr != "//")
                         {
                           size_t pos = tmpstr.rfind ('/');
 
                           if (pos != std::string::npos && pos != 0)
                             tmpstr = tmpstr.substr (pos + 1);
                         }
                     }
                   else
-                    tmpstr = octave::sys::env::polite_directory_format (tmpstr);
+                    tmpstr = sys::env::polite_directory_format (tmpstr);
 
                   break;
                 }
 
               case '!':
                 {
                   char number_buffer[32];
                   int num = command_history::current_number ();
diff --git a/liboctave/util/cmd-hist.cc b/liboctave/util/cmd-hist.cc
--- a/liboctave/util/cmd-hist.cc
+++ b/liboctave/util/cmd-hist.cc
@@ -389,17 +389,17 @@ namespace octave
 
                 std::string f = f_arg;
 
                 if (f.empty ())
                   f = xfile;
 
                 if (! f.empty ())
                   {
-                    octave::sys::file_stat fs (f);
+                    sys::file_stat fs (f);
 
                     if (! fs)
                       {
                         std::fstream tmp (f, std::ios::out);
                         tmp.close ();
                       }
 
                     int status
@@ -543,17 +543,17 @@ namespace octave
     return instance && instance->do_is_initialized ();
   }
 
   void
   command_history::set_file (const std::string& f_arg)
   {
     if (instance_ok ())
       {
-        std::string f = octave::sys::file_ops::tilde_expand (f_arg);
+        std::string f = sys::file_ops::tilde_expand (f_arg);
 
         instance->do_set_file (f);
       }
   }
 
   std::string
   command_history::file (void)
   {
diff --git a/liboctave/util/oct-glob.cc b/liboctave/util/oct-glob.cc
--- a/liboctave/util/oct-glob.cc
+++ b/liboctave/util/oct-glob.cc
@@ -70,17 +70,17 @@ namespace octave
     glob (const string_vector& pat)
     {
       string_vector retval;
 
       int npat = pat.numel ();
 
       int k = 0;
 
-      octave::unwind_protect frame;
+      unwind_protect frame;
 
       void *glob_info = octave_create_glob_info_struct ();
 
       frame.add_fcn (octave_destroy_glob_info_struct, glob_info);
 
       for (int i = 0; i < npat; i++)
         {
           std::string xpat = pat(i);
@@ -146,17 +146,17 @@ namespace octave
     windows_glob (const string_vector& pat)
     {
       string_vector retval;
 
       int npat = pat.numel ();
 
       int k = 0;
 
-      octave::unwind_protect frame;
+      unwind_protect frame;
 
       void *glob_info = octave_create_glob_info_struct ();
 
       frame.add_fcn (octave_destroy_glob_info_struct, glob_info);
 
       for (int i = 0; i < npat; i++)
         {
           std::string xpat = pat(i);
diff --git a/liboctave/util/oct-locbuf.cc b/liboctave/util/oct-locbuf.cc
--- a/liboctave/util/oct-locbuf.cc
+++ b/liboctave/util/oct-locbuf.cc
@@ -34,17 +34,17 @@ along with Octave; see the file COPYING.
 #if ! defined (OCTAVE_LOCBUF_CHUNKSIZE_MB)
 #  define OCTAVE_LOCBUF_CHUNKSIZE_MB 32
 #endif
 
 namespace octave
 {
 // Each chunk will be at least this big.
 
-  const size_t octave::chunk_buffer::chunk_size =
+  const size_t chunk_buffer::chunk_size =
     static_cast<size_t> (OCTAVE_LOCBUF_CHUNKSIZE_MB) << 20;
 
   char *chunk_buffer::top = nullptr;
   char *chunk_buffer::chunk = nullptr;
   size_t chunk_buffer::left = 0;
   size_t chunk_buffer::active = 0;
 
   chunk_buffer::chunk_buffer (size_t size) : cnk (0), dat (0)
diff --git a/liboctave/util/oct-mutex.cc b/liboctave/util/oct-mutex.cc
--- a/liboctave/util/oct-mutex.cc
+++ b/liboctave/util/oct-mutex.cc
@@ -157,22 +157,22 @@ namespace octave
   bool
   thread::is_thread (void)
   {
     return (pthread_equal (thread_id, pthread_self ()) != 0);
   }
 
 #endif
 
-  static octave::base_mutex *
+  static base_mutex *
   init_rep (void)
   {
 #if defined (OCTAVE_USE_WINDOWS_API)
-    return new octave::w32_mutex ();
+    return new w32_mutex ();
 #elif defined (HAVE_PTHREAD_H)
-    return new octave::pthread_mutex ();
+    return new pthread_mutex ();
 #else
-    return new octave::base_mutex ();
+    return new base_mutex ();
 #endif
   }
 
   mutex::mutex (void) : rep (init_rep ()) { }
 }
diff --git a/liboctave/util/oct-mutex.h b/liboctave/util/oct-mutex.h
--- a/liboctave/util/oct-mutex.h
+++ b/liboctave/util/oct-mutex.h
@@ -43,17 +43,17 @@ namespace octave
 
     virtual void lock (void);
 
     virtual void unlock (void);
 
     virtual bool try_lock (void);
 
   private:
-    octave::refcount<int> count;
+    refcount<int> count;
   };
 
   class
   OCTAVE_API
   mutex
   {
   public:
     mutex (void);
@@ -148,17 +148,17 @@ namespace octave
   thread
   {
   public:
 
     static void init (void);
 
     static bool is_thread (void);
 
-    OCTAVE_DEPRECATED (4.4, "use 'octave::is_thread' instead")
+    OCTAVE_DEPRECATED (4.4, "use 'is_thread' instead")
     static bool is_octave_thread (void) { return is_thread (); }
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED (4.4, "use 'octave::mutex' instead")
 typedef octave::mutex octave_mutex;
diff --git a/liboctave/util/oct-shlib.cc b/liboctave/util/oct-shlib.cc
--- a/liboctave/util/oct-shlib.cc
+++ b/liboctave/util/oct-shlib.cc
@@ -72,25 +72,25 @@ namespace octave
       (*current_liboctave_warning_with_id_handler)
         ("Octave:warn-future-time-stamp",
          "timestamp on file %s is in the future", file.c_str ());
   }
 
   bool
   dynamic_library::dynlib_rep::is_out_of_date (void) const
   {
-    octave::sys::file_stat fs (file);
+    sys::file_stat fs (file);
     return (fs && fs.is_newer (tm_loaded));
   }
 
   void
   dynamic_library::dynlib_rep::fake_reload (void)
   {
     // We can't actually reload the library, but we'll pretend we did.
-    octave::sys::file_stat fs (file);
+    sys::file_stat fs (file);
     if (fs && fs.is_newer (tm_loaded))
       {
         tm_loaded = fs.mtime ();
 
         (*current_liboctave_warning_with_id_handler)
           ("Octave:library-reload",
            "library %s not reloaded due to existing references", file.c_str ());
       }
@@ -347,17 +347,17 @@ namespace octave
   set_dll_directory (const std::string& dir = "")
   {
     SetDllDirectory (dir.empty () ? 0 : dir.c_str ());
   }
 
   octave_w32_shlib::octave_w32_shlib (const std::string& f)
     : dynamic_library::dynlib_rep (f), handle (0)
   {
-    std::string dir = octave::sys::file_ops::dirname (f);
+    std::string dir = sys::file_ops::dirname (f);
 
     set_dll_directory (dir);
 
     handle = LoadLibrary (file.c_str ());
 
     set_dll_directory ();
 
     if (! handle)
diff --git a/liboctave/util/oct-shlib.h b/liboctave/util/oct-shlib.h
--- a/liboctave/util/oct-shlib.h
+++ b/liboctave/util/oct-shlib.h
@@ -69,17 +69,17 @@ namespace octave
 
       bool is_out_of_date (void) const;
 
       // This method will be overridden conditionally.
       static dynlib_rep * new_instance (const std::string& f);
 
       static dynlib_rep * get_instance (const std::string& f, bool fake);
 
-      octave::sys::time time_loaded (void) const
+      sys::time time_loaded (void) const
       { return tm_loaded; }
 
       std::string file_name (void) const
       { return file; }
 
       size_t num_fcn_names (void) const { return fcn_names.size (); }
 
       std::list<std::string> function_names (void) const;
@@ -87,24 +87,24 @@ namespace octave
       void add_fcn_name (const std::string&);
 
       bool remove_fcn_name (const std::string&);
 
       void clear_fcn_names (void) { fcn_names.clear (); }
 
     public:
 
-      octave::refcount<int> count;
+      refcount<int> count;
 
     protected:
 
       void fake_reload (void);
 
       std::string file;
-      octave::sys::time tm_loaded;
+      sys::time tm_loaded;
 
       // Set of hooked function names.
       typedef std::map<std::string, size_t>::iterator fcn_names_iterator;
       typedef std::map<std::string, size_t>::const_iterator fcn_names_const_iterator;
 
       std::map<std::string, size_t> fcn_names;
 
       static std::map<std::string, dynlib_rep *> instances;
@@ -185,17 +185,17 @@ namespace octave
     { return rep->num_fcn_names (); }
 
     bool is_out_of_date (void) const
     { return rep->is_out_of_date (); }
 
     std::string file_name (void) const
     { return rep->file_name (); }
 
-    octave::sys::time time_loaded (void) const
+    sys::time time_loaded (void) const
     { return rep->time_loaded (); }
 
   private:
 
     dynlib_rep *rep;
   };
 }
 
diff --git a/liboctave/util/pathsearch.cc b/liboctave/util/pathsearch.cc
--- a/liboctave/util/pathsearch.cc
+++ b/liboctave/util/pathsearch.cc
@@ -118,17 +118,17 @@ namespace octave
 
   void
   directory_path::init (void)
   {
     static bool octave_kpse_initialized = false;
 
     if (! octave_kpse_initialized)
       {
-        std::string val = octave::sys::env::getenv ("KPATHSEA_DEBUG");
+        std::string val = sys::env::getenv ("KPATHSEA_DEBUG");
 
         if (! val.empty ())
           kpse_debug |= atoi (val.c_str ());
 
         octave_kpse_initialized = true;
       }
 
     m_expanded_path
diff --git a/liboctave/util/url-transfer.cc b/liboctave/util/url-transfer.cc
--- a/liboctave/util/url-transfer.cc
+++ b/liboctave/util/url-transfer.cc
@@ -45,45 +45,45 @@ along with Octave; see the file COPYING.
 #  include <curl/easy.h>
 #endif
 
 namespace octave
 {
   void
   base_url_transfer::delete_file (const std::string& file)
   {
-    octave::sys::unlink (file);
+    sys::unlink (file);
   }
 
   void
   base_url_transfer::mget_directory (const std::string& directory,
                                      const std::string& target)
   {
-    std::string sep = octave::sys::file_ops::dir_sep_str ();
-    octave::sys::file_stat fs (directory);
+    std::string sep = sys::file_ops::dir_sep_str ();
+    sys::file_stat fs (directory);
 
     if (! fs || ! fs.is_dir ())
       {
         std::string msg;
-        int status = octave::sys::mkdir (directory, 0777, msg);
+        int status = sys::mkdir (directory, 0777, msg);
 
         if (status < 0)
           {
             ok = false;
             errmsg = "__ftp_mget__: can not create directory '"
                      + target + sep + directory + "': " + msg;
             return;
           }
       }
 
     cwd (directory);
 
     if (good ())
       {
-        octave::unwind_protect_safe frame;
+        unwind_protect_safe frame;
 
         frame.add_fcn (reset_path, this);
 
         string_vector sv = list ();
 
         for (octave_idx_type i = 0; i < sv.numel (); i++)
           {
             time_t ftime;
@@ -103,17 +103,17 @@ namespace octave
 
                 if (! ofile.is_open ())
                   {
                     ok = false;
                     errmsg = "__ftp_mget__: unable to open file";
                     break;
                   }
 
-                octave::unwind_protect_safe frame2;
+                unwind_protect_safe frame2;
 
                 frame2.add_fcn (delete_file, realfile);
 
                 get (sv(i), ofile);
 
                 ofile.close ();
 
                 if (good ())
@@ -129,46 +129,46 @@ namespace octave
   string_vector
   base_url_transfer::mput_directory (const std::string& base,
                                      const std::string& directory)
   {
     string_vector file_list;
 
     std::string realdir
       = (base.empty ()
-         ? directory : base + octave::sys::file_ops::dir_sep_str () + directory);
+         ? directory : base + sys::file_ops::dir_sep_str () + directory);
 
     mkdir (directory);
 
     if (! good ())
       return file_list;
 
     cwd (directory);
 
     if (good ())
       {
-        octave::unwind_protect_safe frame;
+        unwind_protect_safe frame;
 
         frame.add_fcn (reset_path, this);
 
-        octave::sys::dir_entry dirlist (realdir);
+        sys::dir_entry dirlist (realdir);
 
         if (dirlist)
           {
             string_vector files = dirlist.read ();
 
             for (octave_idx_type i = 0; i < files.numel (); i++)
               {
                 std::string file = files (i);
 
                 if (file == "." || file == "..")
                   continue;
 
-                std::string realfile = realdir + octave::sys::file_ops::dir_sep_str () + file;
-                octave::sys::file_stat fs (realfile);
+                std::string realfile = realdir + sys::file_ops::dir_sep_str () + file;
+                sys::file_stat fs (realfile);
 
                 if (! fs.exists ())
                   {
                     ok = false;
                     errmsg = "__ftp__mput: file '" + realfile
                              + "' does not exist";
                     break;
                   }
@@ -411,17 +411,17 @@ namespace octave
     {
       ftp_file_or_dir_action (path, "mkd");
     }
 
     void rename (const std::string& oldname, const std::string& newname)
     {
       struct curl_slist *slist = nullptr;
 
-      octave::unwind_protect frame;
+      unwind_protect frame;
       frame.add_fcn (curl_slist_free_all, slist);
 
       std::string cmd = "rnfr " + oldname;
       slist = curl_slist_append (slist, cmd.c_str ());
       cmd = "rnto " + newname;
       slist = curl_slist_append (slist, cmd.c_str ());
       SETOPT (CURLOPT_POSTQUOTE, slist);
 
@@ -579,17 +579,17 @@ namespace octave
     }
 
     std::string pwd (void)
     {
       std::string retval;
 
       struct curl_slist *slist = nullptr;
 
-      octave::unwind_protect frame;
+      unwind_protect frame;
       frame.add_fcn (curl_slist_free_all, slist);
 
       slist = curl_slist_append (slist, "pwd");
       SETOPTR (CURLOPT_POSTQUOTE, slist);
       SETOPTR (CURLOPT_HEADERFUNCTION, write_data);
 
       std::ostringstream buf;
       SETOPTR (CURLOPT_WRITEHEADER, static_cast<void *>(&buf));
@@ -743,17 +743,17 @@ namespace octave
       return query.str ();
     }
 
     void ftp_file_or_dir_action (const std::string& file_or_dir,
                                  const std::string& action)
     {
       struct curl_slist *slist = nullptr;
 
-      octave::unwind_protect frame;
+      unwind_protect frame;
 
       frame.add_fcn (curl_slist_free_all, slist);
 
       std::string cmd = action + " " + file_or_dir;
 
       slist = curl_slist_append (slist, cmd.c_str ());
 
       SETOPT (CURLOPT_POSTQUOTE, slist);
diff --git a/liboctave/util/url-transfer.h b/liboctave/util/url-transfer.h
--- a/liboctave/util/url-transfer.h
+++ b/liboctave/util/url-transfer.h
@@ -147,17 +147,17 @@ namespace octave
     virtual void http_post (const Array<std::string>& /* param */) { }
 
     virtual void http_action (const Array<std::string>& /* param */,
                               const std::string& /* action */) { }
 
   protected:
 
     // Reference count.
-    octave::refcount<size_t> count;
+    refcount<size_t> count;
 
     // Host for ftp transfers or full URL for http requests.
     std::string host_or_url;
     bool valid;
     bool ftp;
     bool ascii_mode;
     bool ok;
     std::string errmsg;
diff --git a/oct-conf-post.in.h b/oct-conf-post.in.h
--- a/oct-conf-post.in.h
+++ b/oct-conf-post.in.h
@@ -45,17 +45,25 @@ along with Octave; see the file COPYING.
 #  define OCTAVE_UNUSED __attribute__ ((__unused__))
 #  define HAVE_OCTAVE_UNUSED_ATTR 1
 #else
 #  define OCTAVE_DEPRECATED(ver, msg)
 #  define OCTAVE_NORETURN
 #  define OCTAVE_UNUSED
 #endif
 
-#define OCTAVE_USE_DEPRECATED_FUNCTIONS 1
+/* This macro could have a better name...  It is intended to be used
+   only to enable inline functions or typedefs that provide access to
+   symbols that have been moved to the octave namespace.  It may be
+   temporarily useful to define this macro when moving a symbol to the
+   octave namespace but it should not be defined when building
+   released versions of Octave, as building those should not require
+   deprecated symbols.  It is defined in octave-config.h, so users of
+   Octave may continue to access symbols using the deprecated names.  */
+/* #undef OCTAVE_USE_DEPRECATED_FUNCTIONS */
 
 #if defined (__cplusplus)
 template <typename T>
 static inline void
 octave_unused_parameter (const T&)
 { }
 #else
 #  define octave_unused_parameter(param) (void) param;
