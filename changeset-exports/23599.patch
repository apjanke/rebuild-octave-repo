# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1496989288 14400
#      Fri Jun 09 02:21:28 2017 -0400
# Node ID 5cb3a2bb5e1ef8a8928967f8ff279cecd9f6efd4
# Parent  287b07229aff81c3e974ab97e3ace2d61405ea6c
don't use singleton for symbol_table

This is the first of a series of changes to make the symbol table a
part of the interpreter instead of a global object.  These changes
also aim to simplify the implementation of symbol table so that it is
easier to understand and modify.

  * Functions now own their scope (workspace) data.

  * The list of subfunctions is contained in the scope rather than a
    global list.

* symtab.h, symtab.cc (class symbol_table): Don't use singleton
pattern.

* interpreter.h, interpreter.cc (interpreter::m_symbol_table): New
data member.
(interpreter::~interpreter): Don't set instance to 0.

* interpreter-private.h, interpreter-private.cc
(__get_symbol_table__): New function.

Change all uses of call_stack to access call_stack object from the
interpreter.

diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -686,17 +686,22 @@ file_editor_tab::update_lexer ()
             {
               // octave: get keywords from internal informations depending on
               //         user preferences
 
               // keywords are always used
               add_octave_apis (Fiskeyword ());            // add new entries
 
               if (octave_builtins)
-                add_octave_apis (F__builtins__ ());       // add new entries
+                {
+                  octave::interpreter& interp
+                    = octave::__get_interpreter__ ("file_editor_tab::update_lexer");
+
+                  add_octave_apis (F__builtins__ (interp));       // add new entries
+                }
 
               if (octave_functions)
                 add_octave_apis (F__list_functions__ ()); // add new entries
 
             }
           else
             {
 
@@ -1772,21 +1777,24 @@ file_editor_tab::new_file (const QString
 }
 
 // Force reloading of a file after it is saved.
 // This is needed to get the right line numbers for breakpoints (bug #46632).
 bool
 file_editor_tab::exit_debug_and_clear (const QString& full_name_q,
                                        const QString& base_name_q)
 {
+  symbol_table& symtab
+    = octave::__get_symbol_table__ ("file_editor_tab::exit_debug_and_clear");
+
   std::string base_name = base_name_q.toStdString ();
   octave_value sym;
   try
     {
-      sym = symbol_table::find (base_name);
+      sym = symtab.find (base_name);
     }
   catch (const octave::execution_exception& e)
     {
       // Ignore syntax error.
       // It was in the old file on disk; the user may have fixed it already.
     }
 
   // Return early if this file is not loaded in the symbol table
@@ -1831,17 +1839,18 @@ file_editor_tab::exit_debug_and_clear (c
           else
             retval = false;
           break;
         }
     }
 
   // If we aren't currently running it, or have quit above, force a reload.
   if (retval == true)
-    symbol_table::clear_user_function (base_name);
+    symtab.clear_user_function (base_name);
+
   return retval;
 }
 
 void
 file_editor_tab::save_file (const QString& saveFileName,
                             bool remove_on_success, bool restore_breakpoints)
 {
   // If it is a new file with no name, signal that saveFileAs
diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -56,16 +56,20 @@ along with Octave; see the file COPYING.
 #include "shortcut-manager.h"
 
 #include "Array.h"
 #include "cmd-edit.h"
 #include "url-transfer.h"
 
 #include "builtin-defun-decls.h"
 #include "defaults.h"
+#if defined (HAVE_QT_GRAPHICS)
+#  include "__init_qt__.h"
+#endif
+#include "interpreter-private.h"
 #include "oct-map.h"
 #include "octave.h"
 #include "symtab.h"
 #include "utils.h"
 #include "version.h"
 
 static file_editor_interface *
 create_default_editor (QWidget *p)
@@ -89,16 +93,22 @@ octave_interpreter::execute (void)
   thread_manager.register_current_thread ();
 
   octave_thread_manager::unblock_interrupt_signal ();
 
   // The application context owns the interpreter.
 
   m_app_context->create_interpreter ();
 
+#if defined (HAVE_QT_GRAPHICS)
+  install___init_qt___functions ();
+
+  Fregister_graphics_toolkit (ovl ("qt"));
+#endif
+
   int exit_status = 0;
 
   try
     {
       // Final initialization including executing startup files.  If
       // initialization fails, return the last available status from
       // that process.
 
@@ -2405,32 +2415,41 @@ main_window::save_workspace_callback (co
   Fsave (ovl (file));
 }
 
 void
 main_window::load_workspace_callback (const std::string& file)
 {
   Fload (ovl (file));
 
-  octave_link::set_workspace (true, symbol_table::workspace_info ());
+ symbol_table& symtab
+   = octave::__get_symbol_table__ ("main_window::load_workspace_callback");
+
+  octave_link::set_workspace (true, symtab.workspace_info ());
 }
 
 void
 main_window::clear_workspace_callback (void)
 {
-  Fclear ();
+  octave::interpreter& interp
+    = octave::__get_interpreter__ ("main_window::clear_workspace_callback");
+
+  Fclear (interp);
 }
 
 void
 main_window::rename_variable_callback (const main_window::name_pair& names)
 {
-  /* bool status = */ symbol_table::rename (names.first, names.second);
+  symbol_table& symtab
+    = octave::__get_symbol_table__ ("main_window::rename_variable_callback");
+
+  /* bool status = */ symtab.rename (names.first, names.second);
 
   // if (status)
-  octave_link::set_workspace (true, symbol_table::workspace_info ());
+  octave_link::set_workspace (true, symtab.workspace_info ());
 
   //  else
   //    ; // we need an octave_link action that runs a GUI error option.
 }
 
 void
 main_window::command_window_undo_callback (void)
 {
@@ -2461,17 +2480,20 @@ void
 main_window::clear_history_callback (void)
 {
   Fhistory (ovl ("-c"));
 }
 
 void
 main_window::new_figure_callback (void)
 {
-  Fbuiltin (ovl ("figure"));
+  octave::interpreter& interp
+    = octave::__get_interpreter__ ("main_window::new_figure_callback");
+
+  Fbuiltin (interp, ovl ("figure"));
   Fdrawnow ();
 }
 
 void
 main_window::change_directory_callback (const std::string& directory)
 {
   Fcd (ovl (directory));
   _octave_qt_link->update_directory ();
diff --git a/libgui/src/octave-gui.cc b/libgui/src/octave-gui.cc
--- a/libgui/src/octave-gui.cc
+++ b/libgui/src/octave-gui.cc
@@ -41,19 +41,16 @@ along with Octave; see the file COPYING.
 
 #include "lo-utils.h"
 #include "oct-env.h"
 #include "oct-syscalls.h"
 
 #include "builtin-defun-decls.h"
 #include "defaults.h"
 #include "display.h"
-#if defined (HAVE_QT_GRAPHICS)
-#  include "__init_qt__.h"
-#endif
 #include "octave.h"
 #include "sysdep.h"
 #include "unistd-wrappers.h"
 
 #include "main-window.h"
 #include "octave-gui.h"
 #include "resource-manager.h"
 #include "shortcut-manager.h"
@@ -149,22 +146,16 @@ namespace octave
       {
 #if defined (HAVE_QT4)
         qInstallMsgHandler (message_handler);
 #else
         qInstallMessageHandler (message_handler);
 #endif
       }
 
-#if defined (HAVE_QT_GRAPHICS)
-    install___init_qt___functions ();
-
-    Fregister_graphics_toolkit (ovl ("qt"));
-#endif
-
     // If START_GUI is false, we still set up the QApplication so that
     // we can use Qt widgets for plot windows.
 
     QApplication qt_app (m_argc, m_argv);
     QTranslator gui_tr, qt_tr, qsci_tr;
 
     // Set the codec for all strings (before wizard or any GUI object)
 #if ! defined (Q_OS_WIN32)
diff --git a/libgui/src/workspace-view.cc b/libgui/src/workspace-view.cc
--- a/libgui/src/workspace-view.cc
+++ b/libgui/src/workspace-view.cc
@@ -36,16 +36,18 @@ along with Octave; see the file COPYING.
 #include <QPushButton>
 #include <QMenu>
 #include <QLabel>
 #include <QCompleter>
 #include <QSignalMapper>
 
 #include "workspace-view.h"
 #include "resource-manager.h"
+
+#include "interpreter-private.h"
 #include "symtab.h"
 
 workspace_view::workspace_view (QWidget *p)
   : octave_dock_widget (p), view (new QTableView (this))
 {
   setObjectName ("WorkspaceView");
   setWindowIcon (QIcon (":/actions/icons/logo.png"));
   set_title (tr ("Workspace"));
@@ -366,17 +368,20 @@ void
 workspace_view::handle_contextmenu_copy_value (void)
 {
   QModelIndex index = view->currentIndex ();
 
   if (index.isValid ())
     {
       QString var_name = get_var_name (index);
 
-      octave_value val = symbol_table::varval (var_name.toStdString ());
+      symbol_table& symtab
+        = octave::__get_symbol_table__ ("workspace_view::handle_contextmenu_copy_value");
+
+      octave_value val = symtab.varval (var_name.toStdString ());
       std::ostringstream buf;
       val.print_raw (buf, true);
 
       QClipboard *clipboard = QApplication::clipboard ();
       clipboard->setText (QString::fromStdString (buf.str ()));
     }
 }
 
diff --git a/libinterp/corefcn/bsxfun.cc b/libinterp/corefcn/bsxfun.cc
--- a/libinterp/corefcn/bsxfun.cc
+++ b/libinterp/corefcn/bsxfun.cc
@@ -28,16 +28,17 @@ along with Octave; see the file COPYING.
 #include <string>
 #include <vector>
 #include <list>
 
 #include "lo-mappers.h"
 
 #include "oct-map.h"
 #include "defun.h"
+#include "interpreter.h"
 #include "parse.h"
 #include "variables.h"
 #include "ov-colon.h"
 #include "unwind-prot.h"
 #include "ov-fcn-handle.h"
 
 // Optimized bsxfun operations
 enum bsxfun_builtin_op
@@ -311,18 +312,18 @@ update_index (Array<int>& idx, const dim
   idx(0) = 0;
   for (octave_idx_type j = 1; j < nd; j++)
     {
       idx(j) = i % dv(j);
       i /= dv(j);
     }
 }
 
-DEFUN (bsxfun, args, ,
-       doc: /* -*- texinfo -*-
+DEFMETHOD (bsxfun, interp,args, ,
+           doc: /* -*- texinfo -*-
 @deftypefn {} {} bsxfun (@var{f}, @var{A}, @var{B})
 The binary singleton expansion function performs broadcasting,
 that is, it applies a binary function @var{f} element-by-element to two
 array arguments @var{A} and @var{B}, and expands as necessary
 singleton dimensions in either input argument.
 
 @var{f} is a function handle, inline function, or string containing the name
 of the function to evaluate.  The function @var{f} must be capable of
@@ -337,17 +338,21 @@ dimensionality as the other array.
 {
   if (args.length () != 3)
     print_usage ();
 
   octave_value func = args(0);
   if (func.is_string ())
     {
       std::string name = func.string_value ();
-      func = symbol_table::find_function (name);
+
+      symbol_table& symtab = interp.get_symbol_table ();
+
+      func = symtab.find_function (name);
+
       if (func.is_undefined ())
         error ("bsxfun: invalid function name: %s", name.c_str ());
     }
   else if (! (args(0).is_function_handle () || args(0).is_inline_function ()))
     error ("bsxfun: F must be a string or function handle");
 
   octave_value_list retval;
 
diff --git a/libinterp/corefcn/call-stack.cc b/libinterp/corefcn/call-stack.cc
--- a/libinterp/corefcn/call-stack.cc
+++ b/libinterp/corefcn/call-stack.cc
@@ -356,17 +356,19 @@ namespace octave
     if (n < cs.size ())
       {
         retval = true;
 
         curr_frame = n;
 
         const stack_frame& elt = cs[n];
 
-        symbol_table::set_scope_and_context (elt.m_scope, elt.m_context);
+        symbol_table& symtab = m_interpreter.get_symbol_table ();
+
+        symtab.set_scope_and_context (elt.m_scope, elt.m_context);
 
         if (verbose)
           octave_stdout << "stopped in " << elt.fcn_name ()
                         << " at line " << elt.m_line
                         << " column " << elt.m_column
                         << " [" << elt.fcn_file_name () << "] "
                         << " (scope = " << elt.m_scope
                         << "[context = " << elt.m_context << "])"
@@ -409,17 +411,19 @@ namespace octave
             else if (nskip < 0)
               nskip++;
 
             if (nskip == 0)
               {
                 curr_frame = xframe;
                 cs[cs.size () - 1].m_prev = curr_frame;
 
-                symbol_table::set_scope_and_context (elt.m_scope, elt.m_context);
+                symbol_table& symtab = m_interpreter.get_symbol_table ();
+
+                symtab.set_scope_and_context (elt.m_scope, elt.m_context);
 
                 if (verbose)
                   {
                     std::ostringstream buf;
 
                     if (f)
                       buf << "stopped in " << elt.fcn_name ()
                           << " at line " << elt.m_line
@@ -471,17 +475,19 @@ namespace octave
                 // We found the caller user code frame.
                 stack_frame tmp (elt);
                 tmp.m_prev = curr_frame;
 
                 curr_frame = cs.size ();
 
                 cs.push_back (tmp);
 
-                symbol_table::set_scope_and_context (tmp.m_scope, tmp.m_context);
+                symbol_table& symtab = m_interpreter.get_symbol_table ();
+
+                symtab.set_scope_and_context (tmp.m_scope, tmp.m_context);
 
                 break;
               }
           }
       }
   }
 
   void
@@ -489,17 +495,19 @@ namespace octave
   {
     stack_frame tmp (cs[0]);
     tmp.m_prev = curr_frame;
 
     curr_frame = cs.size ();
 
     cs.push_back (tmp);
 
-    symbol_table::set_scope_and_context (tmp.m_scope, tmp.m_context);
+    symbol_table& symtab = m_interpreter.get_symbol_table ();
+
+    symtab.set_scope_and_context (tmp.m_scope, tmp.m_context);
   }
 
   std::list<call_stack::stack_frame>
   call_stack::backtrace_frames (size_t nskip,
                                 octave_idx_type& curr_user_frame) const
   {
     std::list<call_stack::stack_frame> retval;
 
diff --git a/libinterp/corefcn/call-stack.h b/libinterp/corefcn/call-stack.h
--- a/libinterp/corefcn/call-stack.h
+++ b/libinterp/corefcn/call-stack.h
@@ -28,36 +28,36 @@ along with Octave; see the file COPYING.
 #include <deque>
 #include <string>
 
 class octave_function;
 class octave_user_code;
 class octave_user_script;
 
 #include "input.h"
+#include "interpreter.h"
 #include "oct-map.h"
 #include "symtab.h"
 
 namespace octave
 {
-  class interpreter;
-
   class
   OCTINTERP_API
   call_stack
   {
   public:
 
     class stack_frame
     {
     public:
 
       friend class call_stack;
 
-      stack_frame (octave_function *fcn = nullptr, symbol_table::scope_id scope = 0,
+      stack_frame (octave_function *fcn = nullptr,
+                   symbol_table::scope_id scope = 0,
                    symbol_table::context_id context = 0, size_t prev = 0)
         : m_fcn (fcn), m_line (-1), m_column (-1), m_scope (scope),
           m_context (context), m_prev (prev)
       { }
 
       stack_frame (const stack_frame& elt)
         : m_fcn (elt.m_fcn), m_line (elt.m_line), m_column (elt.m_column),
           m_scope (elt.m_scope), m_context (elt.m_context), m_prev (elt.m_prev)
@@ -107,16 +107,17 @@ namespace octave
 
     // Current line in current function.
     int current_line (void) const;
 
     // Current column in current function.
     int current_column (void) const;
 
     // Caller function, may be built-in.
+
     octave_function * caller (void) const
     {
       return curr_frame > 1 ? cs[curr_frame-1].m_fcn : cs[0].m_fcn;
     }
 
     size_t current_frame (void) const { return curr_frame; }
 
     size_t size (void) const { return cs.size (); }
@@ -168,27 +169,31 @@ namespace octave
     // Column number in current function that we are debugging.
     int debug_user_code_column (void) const;
 
     // Return TRUE if all elements on the call stack are scripts.
     bool all_scripts (void) const;
 
     void push (octave_function *fcn)
     {
-      push (fcn, symbol_table::current_scope (),
-            symbol_table::current_context ());
+      symbol_table& symtab = m_interpreter.get_symbol_table ();
+
+      push (fcn, symtab.current_scope (), symtab.current_context ());
     }
 
     void push (octave_function *fcn, symbol_table::scope_id scope,
                symbol_table::context_id context)
     {
       size_t prev_frame = curr_frame;
       curr_frame = cs.size ();
       cs.push_back (stack_frame (fcn, scope, context, prev_frame));
-      symbol_table::set_scope_and_context (scope, context);
+
+      symbol_table& symtab = m_interpreter.get_symbol_table ();
+
+      symtab.set_scope_and_context (scope, context);
     }
 
     void push (void)
     {
       push (nullptr);
     }
 
     void push (symbol_table::scope_id scope, symbol_table::context_id context)
@@ -266,18 +271,20 @@ namespace octave
     void pop (void)
     {
       if (cs.size () > 1)
         {
           const stack_frame& elt = cs.back ();
           curr_frame = elt.m_prev;
           cs.pop_back ();
           const stack_frame& new_elt = cs[curr_frame];
-          symbol_table::set_scope_and_context (new_elt.m_scope,
-                                               new_elt.m_context);
+
+          symbol_table& symtab = m_interpreter.get_symbol_table ();
+
+          symtab.set_scope_and_context (new_elt.m_scope, new_elt.m_context);
         }
     }
 
     void clear (void) { cs.clear (); }
 
   private:
 
     // The current call stack.
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -214,18 +214,19 @@ try_cellfun_internal_ops (const octave_v
 
       retval(0) = result;
     }
 
   return retval;
 }
 
 static void
-get_mapper_fun_options (const octave_value_list& args, int& nargin,
-                        bool& uniform_output, octave_value& error_handler)
+get_mapper_fun_options (symbol_table& symtab, const octave_value_list& args,
+                        int& nargin, bool& uniform_output,
+                        octave_value& error_handler)
 {
   while (nargin > 3 && args(nargin-2).is_string ())
     {
       std::string arg = args(nargin-2).string_value ();
 
       size_t compare_len = std::max (arg.length (), static_cast<size_t> (2));
 
       if (octave::string::strncmpi (arg, "uniformoutput", compare_len))
@@ -236,17 +237,17 @@ get_mapper_fun_options (const octave_val
               || args(nargin-1).is_inline_function ())
             {
               error_handler = args(nargin-1);
             }
           else if (args(nargin-1).is_string ())
             {
               std::string err_name = args(nargin-1).string_value ();
 
-              error_handler = symbol_table::find_function (err_name);
+              error_handler = symtab.find_function (err_name);
 
               if (error_handler.is_undefined ())
                 error ("cellfun: invalid function NAME: %s",
                        err_name.c_str ());
             }
           else
             error ("cellfun: invalid value for 'ErrorHandler' function");
         }
@@ -254,18 +255,18 @@ get_mapper_fun_options (const octave_val
         error ("cellfun: unrecognized parameter %s", arg.c_str ());
 
       nargin -= 2;
     }
 
   nargin -= 1;
 }
 
-DEFUN (cellfun, args, nargout,
-       doc: /* -*- texinfo -*-
+DEFMETHOD (cellfun, interp, args, nargout,
+           doc: /* -*- texinfo -*-
 @deftypefn  {} {} cellfun (@var{name}, @var{C})
 @deftypefnx {} {} cellfun ("size", @var{C}, @var{k})
 @deftypefnx {} {} cellfun ("isclass", @var{C}, @var{class})
 @deftypefnx {} {} cellfun (@var{func}, @var{C})
 @deftypefnx {} {} cellfun (@var{func}, @var{C}, @var{D})
 @deftypefnx {} {[@var{a}, @dots{}] =} cellfun (@dots{})
 @deftypefnx {} {} cellfun (@dots{}, "ErrorHandler", @var{errfunc})
 @deftypefnx {} {} cellfun (@dots{}, "UniformOutput", @var{val})
@@ -405,16 +406,18 @@ v = cellfun (@@det, a); # faster
   if (! args(1).iscell ())
     error ("cellfun: C must be a cell array");
 
   octave_value_list retval;
   int nargout1 = (nargout < 1 ? 1 : nargout);
 
   octave_value func = args(0);
 
+  symbol_table& symtab = interp.get_symbol_table ();
+
   if (func.is_string ())
     {
       retval = try_cellfun_internal_ops<boolNDArray,NDArray> (args, nargin);
 
       if (! retval.empty ())
         return retval;
 
       // See if we can convert the string into a function.
@@ -430,31 +433,31 @@ v = cellfun (@@det, a); # faster
             = extract_function (args(0), "cellfun", fcn_name,
                                 fname, "; endfunction");
 
           if (ptr_func)
             func = octave_value (ptr_func, true);
         }
       else
         {
-          func = symbol_table::find_function (name);
+          func = symtab.find_function (name);
 
           if (func.is_undefined ())
             error ("cellfun: invalid function NAME: %s", name.c_str ());
         }
     }
 
   if (! func.is_function_handle () && ! func.is_inline_function ()
       && ! func.is_function ())
     error ("cellfun: argument NAME must be a string or function handle");
 
   bool uniform_output = true;
   octave_value error_handler;
 
-  get_mapper_fun_options (args, nargin, uniform_output, error_handler);
+  get_mapper_fun_options (symtab, args, nargin, uniform_output, error_handler);
 
   // The following is an optimization because the symbol table can give a
   // more specific function class, so this can result in fewer polymorphic
   // function calls as the function gets called for each value of the array.
   {
     if (func.is_function_handle ())
       {
         octave_fcn_handle *f = func.fcn_handle_value ();
@@ -462,17 +465,17 @@ v = cellfun (@@det, a); # faster
         // Overloaded function handles need to check the type of the
         // arguments for each element of the array, so they cannot be
         // optimized this way.
         if (f -> is_overloaded ())
           goto nevermind;
       }
 
     std::string name = func.function_value () -> name ();
-    octave_value f = symbol_table::find_function (name);
+    octave_value f = symtab.find_function (name);
 
     if (f.is_defined ())
       {
         // Except for these two which are special cases...
         if (name != "size" && name != "class")
           {
             // Try first the optimized code path for built-in functions
             octave_value_list tmp_args = args;
@@ -991,18 +994,18 @@ v = cellfun (@@det, a); # faster
 %!error cellfun (@sin, {[]}, "UniformOuput")
 %!error cellfun (@sin, {[]}, "ErrorHandler")
 */
 
 // Arrayfun was originally a .m file written by Bill Denney and Jaroslav
 // Hajek.  It was converted to C++ by jwe so that it could properly
 // handle the nargout = 0 case.
 
-DEFUN (arrayfun, args, nargout,
-       doc: /* -*- texinfo -*-
+DEFMETHOD (arrayfun, interp, args, nargout,
+           doc: /* -*- texinfo -*-
 @deftypefn  {} {} arrayfun (@var{func}, @var{A})
 @deftypefnx {} {@var{x} =} arrayfun (@var{func}, @var{A})
 @deftypefnx {} {@var{x} =} arrayfun (@var{func}, @var{A}, @var{b}, @dots{})
 @deftypefnx {} {[@var{x}, @var{y}, @dots{}] =} arrayfun (@var{func}, @var{A}, @dots{})
 @deftypefnx {} {} arrayfun (@dots{}, "UniformOutput", @var{val})
 @deftypefnx {} {} arrayfun (@dots{}, "ErrorHandler", @var{errfunc})
 
 Execute a function on each element of an array.
@@ -1116,16 +1119,18 @@ arrayfun (@@str2num, [1234],
   if (nargin < 2)
     print_usage ();
 
   octave_value_list retval;
   int nargout1 = (nargout < 1 ? 1 : nargout);
   bool symbol_table_lookup = false;
   octave_value func = args(0);
 
+  symbol_table& symtab = interp.get_symbol_table ();
+
   if (func.is_string ())
     {
       // See if we can convert the string into a function.
       std::string name = args(0).string_value ();
 
       if (! valid_identifier (name))
         {
           std::string fcn_name = unique_symbol_name ("__arrayfun_fcn__");
@@ -1135,17 +1140,17 @@ arrayfun (@@str2num, [1234],
             = extract_function (args(0), "arrayfun", fcn_name,
                                 fname, "; endfunction");
 
           if (ptr_func)
             func = octave_value (ptr_func, true);
         }
       else
         {
-          func = symbol_table::find_function (name);
+          func = symtab.find_function (name);
 
           if (func.is_undefined ())
             error_with_id ("Octave:invalid-input-arg",
                            "arrayfun: invalid function NAME: %s",
                            name.c_str ());
 
           symbol_table_lookup = true;
         }
@@ -1166,28 +1171,29 @@ arrayfun (@@str2num, [1234],
 
               // Overloaded function handles need to check the type of the
               // arguments for each element of the array, so they cannot be
               // optimized this way.
               if (f -> is_overloaded ())
                 goto nevermind;
             }
           octave_value f
-            = symbol_table::find_function (func.function_value () -> name ());
+            = symtab.find_function (func.function_value () -> name ());
 
           if (f.is_defined ())
             func = f;
         }
 
     nevermind:
 
       bool uniform_output = true;
       octave_value error_handler;
 
-      get_mapper_fun_options (args, nargin, uniform_output, error_handler);
+      get_mapper_fun_options (symtab, args, nargin, uniform_output,
+                              error_handler);
 
       octave_value_list inputlist (nargin, octave_value ());
 
       OCTAVE_LOCAL_BUFFER (octave_value, inputs, nargin);
       OCTAVE_LOCAL_BUFFER (bool, mask, nargin);
 
       octave_idx_type k = 1;
 
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -43,16 +43,17 @@ along with Octave; see the file COPYING.
 #include "oct-time.h"
 #include "quit.h"
 
 #include "Cell.h"
 #include "data.h"
 #include "defun.h"
 #include "error.h"
 #include "errwarn.h"
+#include "interpreter-private.h"
 #include "oct-map.h"
 #include "ov-class.h"
 #include "ov-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-cx-sparse.h"
 #include "ov-float.h"
 #include "ov-flt-complex.h"
 #include "ov-flt-cx-mat.h"
@@ -1625,17 +1626,19 @@ attempt_type_conversion (const octave_va
   octave_value retval;
 
   // First try to find function in the class of OV that can convert to
   // the dispatch type dtype.  It will have the name of the dispatch
   // type.
 
   std::string cname = ov.class_name ();
 
-  octave_value fcn = symbol_table::find_method (dtype, cname);
+  symbol_table& symtab = octave::__get_symbol_table__ ("attempt_type_conversion");
+
+  octave_value fcn = symtab.find_method (dtype, cname);
 
   if (fcn.is_defined ())
     {
       octave_value_list result;
 
       try
         {
           result = octave::feval (fcn, ovl (ov), 1);
@@ -1652,17 +1655,17 @@ attempt_type_conversion (const octave_va
 
       retval = result(0);
     }
   else
     {
       // No conversion function available.  Try the constructor for the
       // dispatch type.
 
-      fcn = symbol_table::find_method (dtype, dtype);
+      fcn = symtab.find_method (dtype, dtype);
 
       if (! fcn.is_defined ())
         error ("no constructor for %s!", dtype.c_str ());
 
       octave_value_list result;
 
       try
         {
@@ -1688,17 +1691,19 @@ octave_value
 do_class_concat (const octave_value_list& ovl, std::string cattype, int dim)
 {
   octave_value retval;
 
   // Get dominant type for list
 
   std::string dtype = get_dispatch_type (ovl);
 
-  octave_value fcn = symbol_table::find_method (cattype, dtype);
+  symbol_table& symtab = octave::__get_symbol_table__ ("do_class_concat");
+
+  octave_value fcn = symtab.find_method (cattype, dtype);
 
   if (fcn.is_defined ())
     {
       // Have method for dominant type.  Call it and let it handle conversions.
 
       octave_value_list tmp2;
 
       try
diff --git a/libinterp/corefcn/defun.cc b/libinterp/corefcn/defun.cc
--- a/libinterp/corefcn/defun.cc
+++ b/libinterp/corefcn/defun.cc
@@ -86,83 +86,97 @@ check_version (const std::string& versio
 
 void
 install_builtin_function (octave_builtin::fcn f, const std::string& name,
                           const std::string& file, const std::string& doc,
                           bool /* can_hide_function -- not yet implemented */)
 {
   octave_value fcn (new octave_builtin (f, name, file, doc));
 
-  symbol_table::install_built_in_function (name, fcn);
+  symbol_table& symtab = octave::__get_symbol_table__ ("install_builtin_function");
+
+  symtab.install_built_in_function (name, fcn);
 }
 
 void
 install_builtin_function (octave_builtin::meth m, const std::string& name,
                           const std::string& file, const std::string& doc,
                           bool /* can_hide_function -- not yet implemented */)
 {
   octave_value fcn (new octave_builtin (m, name, file, doc));
 
-  symbol_table::install_built_in_function (name, fcn);
+  symbol_table& symtab = octave::__get_symbol_table__ ("install_builtin_function");
+
+  symtab.install_built_in_function (name, fcn);
 }
 
 void
 install_dld_function (octave_dld_function::fcn f, const std::string& name,
                       const octave::dynamic_library& shl, const std::string& doc,
                       bool relative)
 {
   octave_dld_function *fcn = new octave_dld_function (f, shl, name, doc);
 
   if (relative)
     fcn->mark_relative ();
 
   octave_value fval (fcn);
 
-  symbol_table::install_built_in_function (name, fval);
+  symbol_table& symtab = octave::__get_symbol_table__ ("install_dld_function");
+
+  symtab.install_built_in_function (name, fval);
 }
 
 void
 install_dld_function (octave_dld_function::meth m, const std::string& name,
                       const octave::dynamic_library& shl, const std::string& doc,
                       bool relative)
 {
   octave_dld_function *fcn = new octave_dld_function (m, shl, name, doc);
 
   if (relative)
     fcn->mark_relative ();
 
   octave_value fval (fcn);
 
-  symbol_table::install_built_in_function (name, fval);
+  symbol_table& symtab = octave::__get_symbol_table__ ("install_dld_function");
+
+  symtab.install_built_in_function (name, fval);
 }
 
 void
 install_mex_function (void *fptr, bool fmex, const std::string& name,
                       const octave::dynamic_library& shl, bool relative)
 {
   octave_mex_function *fcn = new octave_mex_function (fptr, fmex, shl, name);
 
   if (relative)
     fcn->mark_relative ();
 
   octave_value fval (fcn);
 
-  symbol_table::install_built_in_function (name, fval);
+  symbol_table& symtab = octave::__get_symbol_table__ ("install_mex_function");
+
+  symtab.install_built_in_function (name, fval);
 }
 
 void
 alias_builtin (const std::string& alias, const std::string& name)
 {
-  symbol_table::alias_built_in_function (alias, name);
+  symbol_table& symtab = octave::__get_symbol_table__ ("alias_builtin");
+
+  symtab.alias_built_in_function (alias, name);
 }
 
 void
 install_builtin_dispatch (const std::string& name, const std::string& klass)
 {
-  symbol_table::install_built_in_dispatch (name, klass);
+  symbol_table& symtab = octave::__get_symbol_table__ ("install_builtin_dispatch");
+
+  symtab.install_built_in_dispatch (name, klass);
 }
 
 octave::dynamic_library
 get_current_shlib (void)
 {
   octave::dynamic_library retval;
 
   octave::call_stack& cs = octave::__get_call_stack__ ("get_current_shlib");
diff --git a/libinterp/corefcn/dynamic-ld.cc b/libinterp/corefcn/dynamic-ld.cc
--- a/libinterp/corefcn/dynamic-ld.cc
+++ b/libinterp/corefcn/dynamic-ld.cc
@@ -30,16 +30,17 @@ along with Octave; see the file COPYING.
 #include "file-stat.h"
 #include "oct-env.h"
 #include "oct-time.h"
 #include "singleton-cleanup.h"
 
 #include "defaults.h"
 #include "defun.h"
 #include "dynamic-ld.h"
+#include "interpreter-private.h"
 #include "ov-fcn.h"
 #include "ov-dld-fcn.h"
 #include "ov-mex-fcn.h"
 #include "parse.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
@@ -122,17 +123,20 @@ namespace octave
     return retval;
   }
 
   void
   dynamic_loader::do_clear_function (const std::string& fcn_name)
   {
     warning_with_id ("Octave:reload-forces-clear", "  %s", fcn_name.c_str ());
 
-    symbol_table::clear_dld_function (fcn_name);
+    symbol_table& symtab
+      = __get_symbol_table__ ("dynamic_loader::do_clear_function");
+
+    symtab.clear_dld_function (fcn_name);
   }
 
   void
   dynamic_loader::do_clear (dynamic_library& oct_file)
   {
     if (oct_file.number_of_functions_loaded () > 1)
       {
         warning_with_id ("Octave:reload-forces-clear",
@@ -143,18 +147,21 @@ namespace octave
 
         for (const auto& fcn_name : removed_fcns)
           do_clear_function (fcn_name);
       }
     else
       {
         std::list<std::string> removed_fcns = loaded_shlibs.remove (oct_file);
 
+        symbol_table& symtab
+          = __get_symbol_table__ ("dynamic_loader::do_clear");
+
         for (const auto& fcn_name : removed_fcns)
-          symbol_table::clear_dld_function (fcn_name);
+          symtab.clear_dld_function (fcn_name);
       }
   }
 
   octave_function *
   dynamic_loader::do_load_oct (const std::string& fcn_name,
                                const std::string& file_name,
                                bool relative)
   {
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -1505,31 +1505,29 @@ disable escape sequence expansion use a 
         arg2 = argv[2];
 
       octave::call_stack& cs = interp.get_call_stack ();
 
       if (arg1 == "on" || arg1 == "off" || arg1 == "error")
         {
           octave_map old_warning_options = warning_options;
 
+          symbol_table& symtab = interp.get_symbol_table ();
+
           if (nargin == 3 && argv[3] == "local"
-              && ! symbol_table::at_top_level ())
+              && ! symtab.at_top_level ())
             {
-              symbol_table::scope_id scope = cs.current_scope ();
-              symbol_table::context_id context = cs.current_context ();
-
               octave_scalar_map val = warning_query (arg2);
 
               octave_value curr_state = val.contents ("state");
 
               // FIXME: this might be better with a dictionary object.
 
               octave_value curr_warning_states
-                = symbol_table::varval (".saved_warning_states.",
-                                        scope, context);
+                = symtab.varval (".saved_warning_states.");
 
               octave_map m;
 
               if (curr_warning_states.is_defined ())
                 m = curr_warning_states.map_value ();
               else
                 {
                   string_vector fields (2);
@@ -1567,18 +1565,17 @@ disable escape sequence expansion use a 
 
                   ids(nel) = arg2;
                   states(nel) = curr_state;
                 }
 
               m.contents ("identifier") = ids;
               m.contents ("state") = states;
 
-              symbol_table::assign (".saved_warning_states.",
-                                    m, scope, context);
+              symtab.assign (".saved_warning_states.", m);
 
               // Now ignore the "local" argument and continue to
               // handle the current setting.
               nargin--;
             }
 
           if (nargin >= 2 && arg2 == "all")
             {
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -155,19 +155,21 @@ local_functions (void)
 
   octave::call_stack& cs = octave::__get_call_stack__ ("local_functions");
 
   octave_user_code *curr_fcn = cs.caller_user_code ();
 
   if (! curr_fcn)
     return retval;
 
+  symbol_table& symtab = octave::__get_symbol_table__ ("local_functions");
+
   // All subfunctions are listed in the top-level function of this file.
   while (curr_fcn->is_subfunction ())
-    curr_fcn = symbol_table::get_curr_fcn (curr_fcn->parent_fcn_scope ());
+    curr_fcn = symtab.get_curr_fcn (curr_fcn->parent_fcn_scope ());
 
   // Get subfunctions.
   const std::list<std::string> names = curr_fcn->subfunction_names ();
 
   size_t sz = names.size ();
   retval.resize (sz);
 
   // Loop over them.
@@ -181,23 +183,25 @@ local_functions (void)
 // FIXME: It's not likely that this does the right thing now.
 
 string_vector
 make_name_list (void)
 {
   const static string_vector keywords = Fiskeyword ()(0).string_vector_value ();
   const static int key_len = keywords.numel ();
 
-  const string_vector bif = symbol_table::built_in_function_names ();
+  symbol_table& symtab = octave::__get_symbol_table__ ("make_name_list");
+
+  const string_vector bif = symtab.built_in_function_names ();
   const int bif_len = bif.numel ();
 
-  const string_vector cfl = symbol_table::cmdline_function_names ();
+  const string_vector cfl = symtab.cmdline_function_names ();
   const int cfl_len = cfl.numel ();
 
-  const string_vector lcl = symbol_table::variable_names ();
+  const string_vector lcl = symtab.variable_names ();
   const int lcl_len = lcl.numel ();
 
   octave::load_path& lp = octave::__get_load_path__ ("make_name_list");
 
   const string_vector ffl = lp.fcn_names ();
   const int ffl_len = ffl.numel ();
 
   const string_vector afl = octave::autoloaded_functions ();
@@ -267,17 +271,19 @@ looks_like_texinfo (const std::string& m
 }
 
 static bool
 raw_help_from_symbol_table (const std::string& nm, std::string& h,
                             std::string& w, bool& symbol_found)
 {
   bool retval = false;
 
-  octave_value val = symbol_table::find_function (nm);
+  symbol_table& symtab = octave::__get_symbol_table__ ("raw_help_from_symbol_table");
+
+  octave_value val = symtab.find_function (nm);
 
   if (val.is_defined ())
     {
       octave_function *fcn = val.function_value ();
 
       if (fcn)
         {
           symbol_found = true;
@@ -614,23 +620,25 @@ Undocumented internal function.
 // Return a cell array of strings containing the names of all keywords.
 // iskeyword() function is located in lex.ll and is based on what the parser
 // thinks is a keyword.
 
 DEFALIAS (__keywords__, iskeyword)
 
 // Return a cell array of strings with the names of all builtin functions.
 
-DEFUN (__builtins__, , ,
-       doc: /* -*- texinfo -*-
+DEFMETHOD (__builtins__, interp, , ,
+           doc: /* -*- texinfo -*-
 @deftypefn {} {} __builtins__ ()
 Undocumented internal function.
 @end deftypefn */)
 {
-  const string_vector bif = symbol_table::built_in_function_names ();
+  symbol_table& symtab = interp.get_symbol_table ();
+
+  const string_vector bif = symtab.built_in_function_names ();
 
   return ovl (Cell (bif));
 }
 
 DEFMETHOD (localfunctions, interp, args, ,
            doc: /* -*- texinfo -*-
 @deftypefn {} {} localfunctions ()
 Return a list of all local functions, i.e., subfunctions, within the current
@@ -701,17 +709,19 @@ the return value is an empty cell array.
 
 static std::string
 do_which (const std::string& name, std::string& type)
 {
   std::string file;
 
   type = "";
 
-  octave_value val = symbol_table::find_function (name);
+  symbol_table& symtab = octave::__get_symbol_table__ ("do_which");
+
+  octave_value val = symtab.find_function (name);
 
   if (name.find_first_of ('.') == std::string::npos)
     {
       if (val.is_defined ())
         {
           octave_function *fcn = val.function_value ();
 
           if (fcn)
diff --git a/libinterp/corefcn/interpreter-private.cc b/libinterp/corefcn/interpreter-private.cc
--- a/libinterp/corefcn/interpreter-private.cc
+++ b/libinterp/corefcn/interpreter-private.cc
@@ -26,36 +26,54 @@ along with Octave; see the file COPYING.
 
 #include <string>
 
 #include "call-stack.h"
 #include "error.h"
 #include "load-path.h"
 #include "interpreter-private.h"
 #include "interpreter.h"
+#include "symtab.h"
 
 namespace octave
 {
   interpreter& __get_interpreter__ (const std::string& who)
   {
     interpreter *interp = interpreter::the_interpreter ();
 
     if (! interp)
-      error ("%s: interpreter context missing", who.c_str ());
+      {
+        abort ();
+        error ("%s: interpreter context missing", who.c_str ());
+      }
 
     return *interp;
   }
 
   load_path& __get_load_path__ (const std::string& who)
   {
     interpreter& interp = __get_interpreter__ (who);
 
     return interp.get_load_path ();
   }
 
+  symbol_table& __get_symbol_table__ (const std::string& who)
+  {
+    interpreter& interp = __get_interpreter__ (who);
+
+    return interp.get_symbol_table ();
+  }
+
+  symbol_table::scope_id __get_current_scope__ (const std::string& who)
+  {
+    symbol_table& symtab = __get_symbol_table__ (who);
+
+    return symtab.current_scope ();
+  }
+
   tree_evaluator& __get_evaluator__ (const std::string& who)
   {
     interpreter& interp = __get_interpreter__ (who);
 
     return interp.get_evaluator ();
   }
 
   call_stack& __get_call_stack__ (const std::string& who)
diff --git a/libinterp/corefcn/interpreter-private.h b/libinterp/corefcn/interpreter-private.h
--- a/libinterp/corefcn/interpreter-private.h
+++ b/libinterp/corefcn/interpreter-private.h
@@ -22,25 +22,31 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_interpreter_private_h)
 #define octave_interpreter_private_h 1
 
 #include "octave-config.h"
 
 #include <string>
 
+#include "symtab.h"
+
 namespace octave
 {
   class call_stack;
   class interpreter;
   class load_path;
   class tree_evaluator;
 
   extern interpreter& __get_interpreter__ (const std::string& who);
 
   extern load_path& __get_load_path__ (const std::string& who);
 
+  extern symbol_table& __get_symbol_table__ (const std::string& who);
+
+  extern symbol_table::scope_id __get_current_scope__ (const std::string& who);
+
   extern tree_evaluator& __get_evaluator__ (const std::string& who);
 
   extern call_stack& __get_call_stack__ (const std::string& who);
 }
 
 #endif
diff --git a/libinterp/corefcn/interpreter.cc b/libinterp/corefcn/interpreter.cc
--- a/libinterp/corefcn/interpreter.cc
+++ b/libinterp/corefcn/interpreter.cc
@@ -367,18 +367,18 @@ execute_pkg_add (const std::string& dir)
 
 namespace octave
 {
   // Create an interpreter object and perform initialization up to the
   // point of setting reading command history and setting the load
   // path.
 
   interpreter::interpreter (application *app_context)
-    : m_app_context (app_context), m_evaluator (new tree_evaluator (*this)),
-      m_load_path (), m_interactive (false),
+    : m_app_context (app_context), m_load_path (), m_symbol_table (),
+      m_evaluator (new tree_evaluator (*this)), m_interactive (false),
       m_read_site_files (true), m_read_init_files (m_app_context != 0),
       m_verbose (false), m_inhibit_startup_message (false),
       m_load_path_initialized (false), m_history_initialized (false),
       m_initialized (false)
   {
     if (instance)
       throw std::runtime_error
         ("only one Octave interpreter object may be active");
@@ -434,23 +434,26 @@ namespace octave
 
     install_classdef (*this);
 
     bool line_editing = false;
     bool traditional = false;
 
     if (m_app_context)
       {
-        // Embedded interpeters don't execute command line options or
+        // Embedded interpeters don't execute command line options.
         const cmdline_options& options = m_app_context->options ();
 
         // Make all command-line arguments available to startup files,
         // including PKG_ADD files.
 
-        m_app_context->intern_argv (options.all_args ());
+        string_vector args = options.all_args ();
+
+        m_app_context->intern_argv (args);
+        intern_nargin (args.numel () - 1);
 
         bool is_octave_program = m_app_context->is_octave_program ();
 
         std::list<std::string> command_line_path = options.command_line_path ();
 
         for (const auto& pth : command_line_path)
           m_load_path.set_command_line_path (pth);
 
@@ -507,18 +510,22 @@ namespace octave
     octave_interpreter_ready = true;
   }
 
   interpreter *interpreter::instance = nullptr;
 
   interpreter::~interpreter (void)
   {
     cleanup ();
+  }
 
-    instance = 0;
+  void interpreter::intern_nargin (octave_idx_type nargs)
+  {
+    m_symbol_table.assign (".nargin.", nargs);
+    m_symbol_table.mark_hidden (".nargin.");
   }
 
   // Read the history file unless a command-line option inhibits that.
 
   void interpreter::initialize_history (bool read_history_file)
   {
     if (! m_history_initialized)
       {
@@ -863,19 +870,21 @@ namespace octave
     octave_bad_alloc_hook = 0;
 
     octave::catch_interrupts ();
 
     octave_initialized = true;
 
     frame.add_method (this, &interpreter::interactive, m_interactive);
 
-    frame.add_method (m_app_context,
-                      &application::intern_argv,
-                      options.all_args ());
+    string_vector args = options.all_args ();
+
+    frame.add_method (m_app_context, &application::intern_argv, args);
+
+    frame.add_method (this, &interpreter::intern_nargin, args.numel () - 1);
 
     frame.add_method (m_app_context,
                       &application::program_invocation_name,
                       application::program_invocation_name ());
 
     frame.add_method (m_app_context,
                       &application::program_name,
                       application::program_name ());
@@ -883,16 +892,17 @@ namespace octave
     m_interactive = false;
 
     // If we are running an executable script (#! /bin/octave) then
     // we should only see the args passed to the script.
 
     string_vector script_args = options.remaining_args ();
 
     m_app_context->intern_argv (script_args);
+    intern_nargin (script_args.numel () - 1);
 
     std::string fname = script_args[0];
 
     m_app_context->set_program_names (fname);
 
     std::string context;
     bool verbose = false;
     bool require_file = true;
@@ -929,17 +939,17 @@ namespace octave
     do
       {
         try
           {
             reset_error_handler ();
 
             parser.reset ();
 
-            if (symbol_table::at_top_level ())
+            if (m_symbol_table.at_top_level ())
               octave::tree_evaluator::reset_debug_state ();
 
             retval = parser.run ();
 
             if (retval == 0)
               {
                 if (parser.stmt_list)
                   {
@@ -1107,17 +1117,20 @@ namespace octave
     OCTAVE_SAFE_CALL (gh_manager::close_all_figures, ());
 
     OCTAVE_SAFE_CALL (gtk_manager::unload_all_toolkits, ());
 
     OCTAVE_SAFE_CALL (close_files, ());
 
     OCTAVE_SAFE_CALL (cleanup_tmp_files, ());
 
-    OCTAVE_SAFE_CALL (symbol_table::cleanup, ());
+    // FIXME:  May still need something like this to ensure that
+    // destructors for class objects will run properly.  Should that be
+    // done earlier?  Before or after atexit functions are executed?
+    m_symbol_table.cleanup ();
 
     OCTAVE_SAFE_CALL (sysdep_cleanup, ());
 
     OCTAVE_SAFE_CALL (octave_finalize_hdf5, ());
 
     OCTAVE_SAFE_CALL (octave::flush_stdout, ());
 
     // Don't call singleton_cleanup_list::cleanup until we have the
diff --git a/libinterp/corefcn/interpreter.h b/libinterp/corefcn/interpreter.h
--- a/libinterp/corefcn/interpreter.h
+++ b/libinterp/corefcn/interpreter.h
@@ -26,16 +26,17 @@ along with Octave; see the file COPYING.
 #include "octave-config.h"
 
 #include <string>
 
 #include "quit.h"
 #include "str-vec.h"
 
 #include "load-path.h"
+#include "symtab.h"
 
 extern OCTINTERP_API bool quit_allowed;
 
 // TRUE means we are ready to interpret commands, but not everything
 // is ready for interactive use.
 extern OCTINTERP_API bool octave_interpreter_ready;
 
 // TRUE means we've processed all the init code and we are good to go.
@@ -67,16 +68,18 @@ namespace octave
     interpreter (const interpreter&) = delete;
 
     interpreter& operator = (const interpreter&) = delete;
 
     // Clean up the interpreter object.
 
     ~interpreter (void);
 
+    void intern_nargin (octave_idx_type nargs);
+
     // If creating an embedded interpreter, you may inhibit reading
     // the command history file by calling initialize_history with
     // read_history_file = false prior to calling initialize.
 
     void initialize_history (bool read_history_file = false);
 
     // If creating an embedded interpreter, you may inhibit setting
     // the default compiled-in path by calling intialize_load_path
@@ -131,16 +134,21 @@ namespace octave
       return m_initialized;
     }
 
     load_path& get_load_path (void)
     {
       return m_load_path;
     }
 
+    symbol_table& get_symbol_table (void)
+    {
+      return m_symbol_table;
+    }
+
     call_stack& get_call_stack (void);
 
     tree_evaluator& get_evaluator (void);
 
     static void recover_from_exception (void);
 
     static void add_atexit_function (const std::string& fname);
 
@@ -165,19 +173,21 @@ namespace octave
     int execute_command_line_file (void);
 
     int main_loop (void);
 
     void cleanup (void);
 
     application *m_app_context;
 
-    tree_evaluator *m_evaluator;
+    load_path m_load_path;
 
-    load_path m_load_path;
+    symbol_table m_symbol_table;
+
+    tree_evaluator *m_evaluator;
 
     // TRUE means this is an interactive interpreter (forced or not).
     bool m_interactive;
 
     bool m_read_site_files;
 
     bool m_read_init_files;
 
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -116,17 +116,19 @@ strip_trailing_separators (const std::st
 static std::string
 find_private_file (const std::string& fname)
 {
   std::string retval;
 
   // Look in private directory corresponding to current function (if
   // any).
 
-  octave_user_function *curr_fcn = symbol_table::get_curr_fcn ();
+  symbol_table& symtab = octave::__get_symbol_table__ ("find_private_file");
+
+  octave_user_function *curr_fcn = symtab.get_curr_fcn ();
 
   if (curr_fcn)
     {
       // Even for private functions, dir_name doesn't contain the
       // "private" directory component so we append it here in all
       // cases.
 
       std::string dir_name = curr_fcn->dir_name ();
@@ -1676,17 +1678,20 @@ namespace octave
           {
             // Warn if a built-in or library function is being shadowed,
             // but not if we are just updating (rehashing) the list.
 
             if (! updating)
               {
                 if (file_info_list.empty ())
                   {
-                    if (symbol_table::is_built_in_function_name (base))
+                    symbol_table& symtab
+                      = octave::__get_symbol_table__ ("load_path::package_info::add_to_fcn_map");
+
+                    if (symtab.is_built_in_function_name (base))
                       {
                         std::string fcn_path = octave::sys::file_ops::concat (dir_name, fname);
 
                         warning_with_id ("Octave:shadowed-function",
                                          "function %s shadows a built-in function",
                                          fcn_path.c_str ());
                       }
                   }
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -51,16 +51,17 @@ along with Octave; see the file COPYING.
 #include "quit.h"
 #include "str-vec.h"
 #include "strftime-wrapper.h"
 
 #include "Cell.h"
 #include "defun.h"
 #include "error.h"
 #include "errwarn.h"
+#include "interpreter-private.h"
 #include "load-path.h"
 #include "load-save.h"
 #include "oct-hdf5.h"
 #include "ovl.h"
 #include "oct-map.h"
 #include "ov-cell.h"
 #include "pager.h"
 #include "pt-exp.h"
@@ -139,24 +140,26 @@ err_file_open (const std::string& fcn, c
 // Install a variable with name NAME and the value VAL in the
 // symbol table.  If GLOBAL is TRUE, make the variable global.
 
 static void
 install_loaded_variable (const std::string& name,
                          const octave_value& val,
                          bool global, const std::string& /*doc*/)
 {
+  symbol_table& symtab = octave::__get_symbol_table__ ("install_loaded_variable");
+
   if (global)
     {
-      symbol_table::clear (name);
-      symbol_table::mark_global (name);
-      symbol_table::global_assign (name, val);
+      symtab.clear (name);
+      symtab.mark_global (name);
+      symtab.global_assign (name, val);
     }
   else
-    symbol_table::assign (name, val);
+    symtab.assign (name, val);
 }
 
 // Return TRUE if NAME matches one of the given globbing PATTERNS.
 
 static bool
 matches_patterns (const string_vector& patterns, int pat_idx,
                   int num_pat, const std::string& name)
 {
@@ -995,17 +998,19 @@ save_fields (std::ostream& os, const oct
 
 // Save variables with names matching PATTERN on stream OS in the
 // format specified by FMT.
 
 static size_t
 save_vars (std::ostream& os, const std::string& pattern,
            load_save_format fmt, bool save_as_floats)
 {
-  std::list<symbol_table::symbol_record> vars = symbol_table::glob (pattern);
+  symbol_table& symtab = octave::__get_symbol_table__ ("save_vars");
+
+  std::list<symbol_table::symbol_record> vars = symtab.glob (pattern);
 
   size_t saved = 0;
 
   for (const auto& var : vars)
     {
       do_save (os, var, fmt, save_as_floats);
 
       saved++;
@@ -1262,20 +1267,22 @@ save_vars (const string_vector& argv, in
     }
   else if (argv[argv_idx] == "-struct")
     {
       if (++argv_idx >= argc)
         error ("save: missing struct name");
 
       std::string struct_name = argv[argv_idx];
 
-      if (! symbol_table::is_variable (struct_name))
+      symbol_table& symtab = octave::__get_symbol_table__ ("save_vars");
+
+      if (! symtab.is_variable (struct_name))
         error ("save: no such variable: '%s'", struct_name.c_str ());
 
-      octave_value struct_var = symbol_table::varval (struct_name);
+      octave_value struct_var = symtab.varval (struct_name);
 
       if (! struct_var.isstruct () || struct_var.numel () != 1)
         error ("save: '%s' is not a scalar structure", struct_name.c_str ());
 
       octave_scalar_map struct_var_map = struct_var.scalar_map_value ();
 
       ++argv_idx;
 
@@ -1307,18 +1314,20 @@ save_vars (const string_vector& argv, in
 }
 
 static void
 dump_octave_core (std::ostream& os, const char *fname, load_save_format fmt,
                   bool save_as_floats)
 {
   write_header (os, fmt);
 
+  symbol_table& symtab = octave::__get_symbol_table__ ("dump_octave_core");
+
   std::list<symbol_table::symbol_record> vars
-    = symbol_table::all_variables (symbol_table::top_scope (), 0);
+    = symtab.all_variables (symbol_table::top_scope (), 0);
 
   double save_mem_size = 0;
 
   for (const auto& var : vars)
     {
       octave_value val = var.varval ();
 
       if (val.is_defined ())
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -975,37 +975,40 @@ read_mat5_binary_element (std::istream& 
             tc2 = m2.contents ("MCOS").cell_value ()(1 + off).cell_value ()(1);
             m2 = tc2.scalar_map_value ();
 
             octave::unwind_protect_safe frame;
 
             // Set up temporary scope to use for evaluating the text
             // that defines the anonymous function.
 
-            symbol_table::scope_id local_scope = symbol_table::alloc_scope ();
-            frame.add_fcn (symbol_table::erase_scope, local_scope);
-
-            symbol_table::set_scope (local_scope);
+            symbol_table& symtab
+              = octave::__get_symbol_table__ ("read_mat5_binary_element");
+
+            symbol_table::scope_id local_scope = symtab.alloc_scope ();
+            frame.add_method (symtab, &symbol_table::erase_scope, local_scope);
+
+            symtab.set_scope (local_scope);
 
             octave::call_stack& cs
               = octave::__get_call_stack__ ("read_mat5_binary_element");
             cs.push (local_scope, 0);
             frame.add_method (cs, &octave::call_stack::pop);
 
             if (m2.nfields () > 0)
               {
                 octave_value tmp;
 
                 for (octave_map::iterator p0 = m2.begin () ;
                      p0 != m2.end (); p0++)
                   {
                     std::string key = m2.key (p0);
                     octave_value val = m2.contents (p0);
 
-                    symbol_table::assign (key, val, local_scope, 0);
+                    symtab.assign (key, val, local_scope, 0);
                   }
               }
 
             int parse_status;
             octave_value anon_fcn_handle =
               octave::eval_string (fname.substr (4), true, parse_status);
 
             if (parse_status != 0)
diff --git a/libinterp/corefcn/mex.cc b/libinterp/corefcn/mex.cc
--- a/libinterp/corefcn/mex.cc
+++ b/libinterp/corefcn/mex.cc
@@ -3420,17 +3420,19 @@ mexGetVariable (const char *space, const
               octave::call_stack& cs
                 = octave::__get_call_stack__ ("mexGetVariable");
 
               cs.goto_base_frame ();
 
               frame.add_method (cs, &octave::call_stack::pop);
             }
 
-          val = symbol_table::varval (name);
+          symbol_table& symtab = octave::__get_symbol_table__ ("mexGetVariable");
+
+          val = symtab.varval (name);
         }
       else
         mexErrMsgTxt ("mexGetVariable: symbol table does not exist");
     }
 
   if (val.is_defined ())
     {
       retval = mex_context->make_value (val);
@@ -3483,17 +3485,19 @@ mexPutVariable (const char *space, const
               octave::call_stack& cs
                 = octave::__get_call_stack__ ("mexPutVariable");
 
               cs.goto_base_frame ();
 
               frame.add_method (cs, &octave::call_stack::pop);
             }
 
-          symbol_table::assign (name, mxArray::as_octave_value (ptr));
+          symbol_table& symtab = octave::__get_symbol_table__ ("mexPutVariable");
+
+          symtab.assign (name, mxArray::as_octave_value (ptr));
         }
       else
         mexErrMsgTxt ("mexPutVariable: symbol table does not exist");
     }
 
   return 0;
 }
 
diff --git a/libinterp/corefcn/octave-link.cc b/libinterp/corefcn/octave-link.cc
--- a/libinterp/corefcn/octave-link.cc
+++ b/libinterp/corefcn/octave-link.cc
@@ -23,23 +23,23 @@ along with Octave; see the file COPYING.
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include "cmd-edit.h"
 #include "defun.h"
+#include "interpreter-private.h"
+#include "interpreter.h"
 #include "oct-env.h"
 #include "oct-mutex.h"
+#include "octave-link.h"
 #include "pager.h"
 #include "singleton-cleanup.h"
-#include "interpreter.h"
-
-#include "octave-link.h"
 
 static int
 octave_readline_hook (void)
 {
   octave_link::entered_readline_hook ();
   octave_link::generate_events ();
   octave_link::process_events ();
   octave_link::finished_readline_hook ();
@@ -60,20 +60,25 @@ octave_link::~octave_link (void)
 {
   delete event_queue_mutex;
 }
 
 void
 octave_link::set_workspace (void)
 {
   if (enabled ())
-    instance->do_set_workspace ((symbol_table::current_scope ()
-                                 == symbol_table::top_scope ()),
-                                instance->debugging,
-                                symbol_table::workspace_info ());
+    {
+      symbol_table& symtab
+        = octave::__get_symbol_table__ ("octave_link::set_workspace");
+
+
+      instance->do_set_workspace (symtab.at_top_level (),
+                                  instance->debugging,
+                                  symtab.workspace_info ());
+    }
 }
 
 // OBJ should be an object of a class that is derived from the base
 // class octave_link, or 0 to disconnect the link.  It is the
 // responsibility of the caller to delete obj.
 
 void
 octave_link::connect_link (octave_link *obj)
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -33,75 +33,100 @@ along with Octave; see the file COPYING.
 #include "oct-time.h"
 #include "singleton-cleanup.h"
 
 #include "bp-table.h"
 #include "defun.h"
 #include "dirfns.h"
 #include "input.h"
 #include "interpreter-private.h"
+#include "interpreter.h"
 #include "load-path.h"
 #include "ov-classdef.h"
 #include "ov-fcn.h"
 #include "ov-usr-fcn.h"
 #include "pager.h"
 #include "parse.h"
 #include "pt-pr-code.h"
 #include "symtab.h"
 #include "unwind-prot.h"
 #include "utils.h"
 
 octave_value symbol_table::dummy_octave_value;
 
-symbol_table *symbol_table::instance = nullptr;
-
-symbol_table::scope_id_cache *symbol_table::scope_id_cache::instance = nullptr;
-
-std::map<symbol_table::scope_id, symbol_table*> symbol_table::all_instances;
-
-std::map<std::string, octave_value> symbol_table::global_table;
-
-std::map<std::string, symbol_table::fcn_info> symbol_table::fcn_table;
-
-std::map<std::string, std::set<std::string>>
-  symbol_table::class_precedence_table;
-
-std::map<std::string, std::list<std::string>> symbol_table::parent_map;
-
-const symbol_table::scope_id symbol_table::xglobal_scope = 0;
-const symbol_table::scope_id symbol_table::xtop_scope = 1;
-
-symbol_table::scope_id symbol_table::xcurrent_scope = 1;
-
 symbol_table::context_id symbol_table::xcurrent_context = 0;
 
 // Should Octave always check to see if function files have changed
 // since they were last compiled?
 static int Vignore_function_time_stamp = 1;
 
 void
-symbol_table::scope_id_cache::create_instance (void)
+symbol_table::symbol_record::symbol_record_rep::clear (scope_id sid)
+{
+  if (! (is_hidden () || is_inherited ())
+      && sid == decl_scope ())
+    {
+      if (is_global ())
+        unmark_global ();
+
+      if (is_persistent ())
+        {
+          symbol_table& symtab
+            = octave::__get_symbol_table__ ("symbol_table::symbol_record::symbol_record_rep::clear");
+
+          symtab.persistent_assign (name, varval ());
+
+          unmark_persistent ();
+        }
+
+      assign (octave_value ());
+    }
+}
+
+void
+symbol_table::symbol_record::symbol_record_rep::init_persistent (void)
 {
-  instance = new scope_id_cache ();
+  if (! is_defined ())
+    {
+      mark_persistent ();
+
+      symbol_table& symtab
+        = octave::__get_symbol_table__ ("symbol_table::symbol_record::symbol_record_rep::init_persistent");
 
-  singleton_cleanup_list::add (cleanup_instance);
+      assign (symtab.persistent_varval (name));
+    }
+  // FIXME: this causes trouble with recursive calls.
+  // else
+  //   error ("unable to declare existing variable persistent");
+}
+
+void
+symbol_table::symbol_record::symbol_record_rep::erase_persistent (void)
+{
+  unmark_persistent ();
+
+  symbol_table& symtab
+    = octave::__get_symbol_table__ ("symbol_table::symbol_record::symbol_record_rep::erase_persistent");
+
+
+  symtab.erase_persistent (name);
 }
 
 symbol_table::context_id
 symbol_table::symbol_record::symbol_record_rep::active_context (void) const
 {
   octave_user_function *fcn = curr_fcn;
 
   // FIXME: If active_context () == -1, then it does not make much
   // sense to use this symbol_record.  This means an attempt at accessing
   // a variable from a function that has not been called yet is
   // happening.  This should be cleared up when an implementing closures.
 
-  return fcn && fcn->active_context () != static_cast<context_id> (-1)
-         ? fcn->active_context () : xcurrent_context;
+  return (fcn && fcn->active_context () != static_cast<context_id> (-1)
+          ? fcn->active_context () : xcurrent_context);
 }
 
 void
 symbol_table::symbol_record::symbol_record_rep::dump
   (std::ostream& os, const std::string& prefix) const
 {
   octave_value val = varval ();
 
@@ -119,46 +144,125 @@ symbol_table::symbol_record::symbol_reco
          << (is_persistent () ? "p" : "")
          << "] ";
       val.dump (os);
     }
 
   os << "\n";
 }
 
+octave_value&
+symbol_table::symbol_record::symbol_record_rep::xglobal_varref (void)
+{
+  symbol_table& symtab
+    = octave::__get_symbol_table__ ("symbol_table::symbol_record::symbol_record_rep::xglobal_varref");
+
+  symbol_table::global_symbols_iterator p
+    = symtab.m_global_symbols.find (name);
+
+  return (p == symtab.m_global_symbols.end ()
+          ? symtab.m_global_symbols[name] : p->second);
+}
+
+octave_value&
+symbol_table::symbol_record::symbol_record_rep::xpersistent_varref (void)
+{
+  symbol_table& symtab
+    = octave::__get_symbol_table__ ("symbol_table::symbol_record::symbol_record_rep::xpersistent_varref");
+
+  scope *s = symtab.get_scope (symtab.current_scope ());
+
+  return s ? s->persistent_varref (name) : dummy_octave_value;
+}
+
+octave_value
+symbol_table::symbol_record::symbol_record_rep::xglobal_varval (void) const
+{
+  symbol_table& symtab
+    = octave::__get_symbol_table__ ("symbol_table::symbol_record::symbol_record_rep::xglobal_varval");
+
+  return symtab.global_varval (name);
+}
+
+octave_value
+symbol_table::symbol_record::symbol_record_rep::xpersistent_varval (void) const
+{
+  symbol_table& symtab
+    = octave::__get_symbol_table__ ("symbol_table::symbol_record::symbol_record_rep::xpersistent_varval");
+
+  return symtab.persistent_varval (name);
+}
+
+symbol_table::symbol_record::symbol_record (void)
+  : rep (new symbol_record_rep (octave::__get_current_scope__ ("symbol_record"),
+                                "", octave_value (), local))
+{ }
+
 octave_value
 symbol_table::symbol_record::find (const octave_value_list& args) const
 {
   octave_value retval;
 
+  symbol_table& symtab
+    = octave::__get_symbol_table__ ("symbol_table::symbol_record::find");
+
   if (is_global ())
-    retval = symbol_table::global_varval (name ());
+    retval = symtab.global_varval (name ());
   else
     {
       retval = varval ();
 
       if (retval.is_undefined ())
         {
+#if 0
           // Use cached fcn_info pointer if possible.
           if (rep->finfo)
             retval = rep->finfo->find (args);
           else
+#endif
             {
-              retval = symbol_table::find_function (name (), args);
+              retval = symtab.find_function (name (), args);
 
               if (retval.is_defined ())
-                rep->finfo = get_fcn_info (name ());
+                return retval;
+#if 0
+              {
+                  rep->finfo = symtab.get_fcn_info (name ());
+              }
+#endif
             }
         }
     }
 
   return retval;
 }
 
-symbol_table::symbol_record symbol_table::dummy_symbol_record;
+symbol_table::symbol_record symbol_table::dummy_symbol_record = symbol_table::symbol_record (symbol_table::xtop_scope);
+
+symbol_table::symbol_reference::symbol_reference (const symbol_record& record)
+  : m_scope (-1), m_sym (record)
+{
+  symbol_table& symtab = octave::__get_symbol_table__ ("symbol_reference");
+
+  m_scope = symtab.current_scope ();
+}
+
+void
+symbol_table::symbol_reference::update (void) const
+{
+  symbol_table& symtab = octave::__get_symbol_table__ ("symbol_reference::update");
+
+  scope_id curr_scope = symtab.current_scope ();
+
+  if (m_scope != curr_scope || ! m_sym.is_valid ())
+    {
+      m_scope = curr_scope;
+      m_sym = symtab.insert (m_sym.name ());
+    }
+}
 
 static void
 split_name_with_package (const std::string& name, std::string& fname,
                          std::string& pname)
 {
   size_t pos = name.rfind ('.');
 
   fname.clear ();
@@ -270,18 +374,22 @@ out_of_date_check (octave_value& functio
                               file = lp.find_method (dispatch_type, nm,
                                                      dir_name, pack);
 
                               if (file.empty ())
                                 {
                                   std::string s_name;
                                   std::string s_pack;
 
+                                  symbol_table& symtab
+                                    = octave::__get_symbol_table__ ("out_of_date_check");
+
                                   const std::list<std::string>& plist
-                                    = symbol_table::parent_classes (dispatch_type);
+                                    = symtab.parent_classes (dispatch_type);
+
                                   std::list<std::string>::const_iterator it
                                     = plist.begin ();
 
                                   while (it != plist.end ())
                                     {
                                       split_name_with_package (*it, s_name,
                                                                s_pack);
 
@@ -518,18 +626,21 @@ symbol_table::fcn_info::fcn_info_rep::lo
                   class_methods[dispatch_type] = retval;
                 }
             }
 
           if (retval.is_undefined ())
             {
               // Search parent classes
 
+              symbol_table& symtab
+                = octave::__get_symbol_table__ ("symbol_table::fcn_info::fcn_info_rep::load_class_method");
+
               const std::list<std::string>& plist =
-                parent_classes (dispatch_type);
+                symtab.parent_classes (dispatch_type);
 
               std::list<std::string>::const_iterator it = plist.begin ();
 
               while (it != plist.end ())
                 {
                   retval = find_method (*it);
 
                   if (retval.is_defined ())
@@ -560,31 +671,16 @@ symbol_table::fcn_info::fcn_info_rep::lo
                 }
             }
         }
     }
 
   return retval;
 }
 
-void
-symbol_table::fcn_info::fcn_info_rep::mark_subfunction_in_scope_as_private
-  (scope_id scope, const std::string& class_name)
-{
-  scope_val_iterator p = subfunctions.find (scope);
-
-  if (p != subfunctions.end ())
-    {
-      octave_function *fcn = p->second.function_value ();
-
-      if (fcn)
-        fcn->mark_as_private_function (class_name);
-    }
-}
-
 // :-) JWE, can you parse this? Returns a 2D array with second dimension equal
 // to btyp_num_types (static constant).  Only the leftmost dimension can be
 // variable in C/C++.  Typedefs are boring.
 
 static builtin_type_t (*build_sup_table (void))[btyp_num_types]
 {
   static builtin_type_t sup_table[btyp_num_types][btyp_num_types];
   for (int i = 0; i < btyp_num_types; i++)
@@ -637,28 +733,30 @@ get_dispatch_type (const octave_value_li
             }
         }
 
       if (builtin_type == btyp_unknown)
         {
           // There's a non-builtin class in the argument list.
           dispatch_type = args(i).class_name ();
 
+          symbol_table& symtab = octave::__get_symbol_table__ ("get_dispatch_type");
+
           for (int j = i+1; j < n; j++)
             {
               octave_value arg = args(j);
 
               if (arg.builtin_type () == btyp_unknown)
                 {
                   std::string cname = arg.class_name ();
 
                   // Only switch to type of ARG if it is marked superior
                   // to the current DISPATCH_TYPE.
-                  if (! symbol_table::is_superiorto (dispatch_type, cname)
-                      && symbol_table::is_superiorto (cname, dispatch_type))
+                  if (! symtab.is_superiorto (dispatch_type, cname)
+                      && symtab.is_superiorto (cname, dispatch_type))
                     dispatch_type = cname;
                 }
             }
         }
       else
         dispatch_type = btyp_class_name[builtin_type];
     }
   else
@@ -669,21 +767,18 @@ get_dispatch_type (const octave_value_li
 
 std::string
 get_dispatch_type (const octave_value_list& args)
 {
   builtin_type_t builtin_type;
   return get_dispatch_type (args, builtin_type);
 }
 
-// Find the definition of NAME according to the following precedence
-// list:
+// Find function definition according to the following precedence list:
 //
-//   variable
-//   subfunction
 //   private function
 //   class method
 //   class constructor
 //   command-line function
 //   autoload function
 //   function on the path
 //   built-in function
 //
@@ -713,17 +808,20 @@ symbol_table::fcn_info::fcn_info_rep::fi
 }
 
 octave_value
 symbol_table::fcn_info::fcn_info_rep::xfind (const octave_value_list& args,
                                              bool local_funcs)
 {
   if (local_funcs)
     {
-      octave_user_function *current_fcn = symbol_table::get_curr_fcn ();
+      symbol_table& symtab
+        = octave::__get_symbol_table__ ("symbol_table::fcn_info::fcn_info_rep::xfind");
+
+      octave_user_function *current_fcn = symtab.get_curr_fcn ();
 
       // Local function.
 
       if (current_fcn)
         {
           std::string fcn_file = current_fcn->fcn_file_name ();
 
           if (! fcn_file.empty ())
@@ -737,39 +835,16 @@ symbol_table::fcn_info::fcn_info_rep::xf
                   // a primary function or method defined in the same
                   // file.
 
                   return r->second;
                 }
             }
         }
 
-      // Subfunction.  I think it only makes sense to check for
-      // subfunctions if we are currently executing a function defined
-      // from a .m file.
-
-      for (scope_id scope = xcurrent_scope; scope >= 0;)
-        {
-          scope_val_iterator r = subfunctions.find (scope);
-          if (r != subfunctions.end ())
-            {
-              // We shouldn't need an out-of-date check here since
-              // subfunctions may ultimately be called only from a
-              // primary function or method defined in the same file.
-
-              return r->second;
-            }
-
-          octave_user_function *scope_curr_fcn = get_curr_fcn (scope);
-          if (scope_curr_fcn)
-            scope = scope_curr_fcn->parent_fcn_scope ();
-          else
-            scope = -1;
-        }
-
       // Private function.
 
       if (current_fcn)
         {
           std::string dir_name = current_fcn->dir_name ();
 
           if (! dir_name.empty ())
             {
@@ -937,17 +1012,20 @@ symbol_table::fcn_info::fcn_info_rep::x_
 
   // Command-line function.
 
   if (cmdline_function.is_defined ())
     return cmdline_function;
 
   // Private function.
 
-  octave_user_function *current_fcn = symbol_table::get_curr_fcn ();
+  symbol_table& symtab
+    = octave::__get_symbol_table__ ("symbol_table::fcn_info::fcn_info_rep::x_builtin_find");
+
+  octave_user_function *current_fcn = symtab.get_curr_fcn ();
 
   if (current_fcn)
     {
       std::string dir_name = current_fcn->dir_name ();
 
       if (! dir_name.empty ())
         {
           str_val_iterator q = private_functions.find (dir_name);
@@ -999,33 +1077,27 @@ symbol_table::fcn_info::fcn_info_rep::x_
             }
         }
     }
 
   // Subfunction.  I think it only makes sense to check for
   // subfunctions if we are currently executing a function defined
   // from a .m file.
 
-  for (scope_id scope = xcurrent_scope; scope >= 0;)
-    {
-      scope_val_iterator r = subfunctions.find (scope);
-      if (r != subfunctions.end ())
-        {
-          // We shouldn't need an out-of-date check here since
-          // subfunctions may ultimately be called only from a primary
-          // function or method defined in the same file.
+  symbol_table::scope_id current_scope
+    = octave::__get_current_scope__ ("symbol_table::fcn_info::fcn_info_rep::x_builtin_find");
+
+  scope *s = symtab.get_scope (current_scope);
 
-          return r->second;
-        }
+  if (s)
+    {
+      octave_value val = s->find_subfunction (name);
 
-      octave_user_function *scope_curr_fcn = get_curr_fcn (scope);
-      if (scope_curr_fcn)
-        scope = scope_curr_fcn->parent_fcn_scope ();
-      else
-        scope = -1;
+      if (val.is_defined ())
+        return val;
     }
 
   return octave_value ();
 }
 
 octave_value
 symbol_table::fcn_info::fcn_info_rep::find_method
   (const std::string& dispatch_type)
@@ -1151,17 +1223,17 @@ symbol_table::set_class_relationship (co
                                       const std::string& inf_class)
 {
   if (is_superiorto (inf_class, sup_class))
     return false;
 
   // If sup_class doesn't have an entry in the precedence table,
   // this will automatically create it, and associate to it a
   // singleton set {inf_class} of inferior classes.
-  class_precedence_table[sup_class].insert (inf_class);
+  m_class_precedence_table[sup_class].insert (inf_class);
 
   return true;
 }
 
 // Has class A been marked as superior to class B?  Also returns
 // TRUE if B has been marked as inferior to A, since we only keep
 // one table, and convert inferiorto information to a superiorto
 // relationship.  Two calls are required to determine whether there
@@ -1172,19 +1244,19 @@ symbol_table::set_class_relationship (co
 //  else if (symbol_table::is_superiorto (b, a))
 //    // B is superior to A, or A has been marked inferior to B.
 //  else
 //    // No relation.
 
 bool
 symbol_table::is_superiorto (const std::string& a, const std::string& b)
 {
-  class_precedence_table_const_iterator p = class_precedence_table.find (a);
+  class_precedence_table_const_iterator p = m_class_precedence_table.find (a);
   // If a has no entry in the precedence table, return false
-  if (p == class_precedence_table.end ())
+  if (p == m_class_precedence_table.end ())
     return false;
 
   const std::set<std::string>& inferior_classes = p->second;
   std::set<std::string>::const_iterator q = inferior_classes.find (b);
   return (q != inferior_classes.end ());
 }
 
 static std::string
@@ -1232,23 +1304,16 @@ symbol_table::fcn_info::fcn_info_rep::du
   if (autoload_function.is_defined ())
     os << tprefix << "autoload: "
        << fcn_file_name (autoload_function) << "\n";
 
   if (function_on_path.is_defined ())
     os << tprefix << "function from path: "
        << fcn_file_name (function_on_path) << "\n";
 
-  if (! subfunctions.empty ())
-    {
-      for (const auto& scope_val : subfunctions)
-        os << tprefix << "subfunction: " << fcn_file_name (scope_val.second)
-           << " [" << scope_val.first << "]\n";
-    }
-
   if (! local_functions.empty ())
     {
       for (const auto& str_val : local_functions)
         os << tprefix << "local: " << fcn_file_name (str_val.second)
            << " [" << str_val.first << "]\n";
     }
 
   if (! private_functions.empty ())
@@ -1268,58 +1333,38 @@ symbol_table::fcn_info::fcn_info_rep::du
   if (! class_methods.empty ())
     {
       for (const auto& str_val : class_methods)
         os << tprefix << "method: " << fcn_file_name (str_val.second)
            << " [" << str_val.first << "]\n";
     }
 }
 
-void
-symbol_table::install_nestfunction (const std::string& name,
-                                    const octave_value& fcn,
-                                    scope_id parent_scope)
+octave_value
+symbol_table::find (const std::string& name, const octave_value_list& args,
+                    bool skip_variables, bool local_funcs)
 {
-  install_subfunction (name, fcn, parent_scope);
-
-  // Stash the nest_parent for resolving variables after parsing is done.
-  octave_function *fv = fcn.function_value ();
-
-  symbol_table *fcn_table_loc = get_instance (fv->scope ());
-
-  symbol_table *parent_table = get_instance (parent_scope);
+  scope *s = get_scope (m_current_scope);
 
-  parent_table->add_nest_child (*fcn_table_loc);
-}
-
-octave_value
-symbol_table::find (const std::string& name,
-                    const octave_value_list& args,
-                    bool skip_variables,
-                    bool local_funcs)
-{
-  symbol_table *inst = get_instance (xcurrent_scope);
-
-  return inst
-         ? inst->do_find (name, args, skip_variables, local_funcs)
-         : octave_value ();
+  return (s
+          ? s->find (name, args, skip_variables, local_funcs)
+          : octave_value ());
 }
 
 octave_value
 symbol_table::builtin_find (const std::string& name)
 {
-  symbol_table *inst = get_instance (xcurrent_scope);
+  scope *s = get_scope (m_current_scope);
 
-  return inst ? inst->do_builtin_find (name) : octave_value ();
+  return s ? s->builtin_find (name) : octave_value ();
 }
 
 octave_value
 symbol_table::find_function (const std::string& name,
-                             const octave_value_list& args,
-                             bool local_funcs)
+                             const octave_value_list& args, bool local_funcs)
 {
   octave_value retval;
 
   if (! name.empty () && name[0] == '@')
     {
       // Look for a class specific function.
       std::string dispatch_type =
         name.substr (1, name.find_first_of (octave::sys::file_ops::dir_sep_str ()) - 1);
@@ -1335,35 +1380,35 @@ symbol_table::find_function (const std::
     {
       size_t pos = name.find_first_of (Vfilemarker);
 
       if (pos == std::string::npos)
         retval = find (name, args, true, local_funcs);
       else
         {
           std::string fcn_scope = name.substr (0, pos);
-          scope_id stored_scope = xcurrent_scope;
-          xcurrent_scope = xtop_scope;
+          scope_id stored_scope = m_current_scope;
+          m_current_scope = xtop_scope;
           octave_value parent = find_function (name.substr (0, pos),
                                                octave_value_list (), false);
 
           if (parent.is_defined ())
             {
               octave_function *parent_fcn = parent.function_value ();
 
               if (parent_fcn)
                 {
-                  xcurrent_scope = parent_fcn->scope ();
+                  m_current_scope = parent_fcn->scope ();
 
-                  if (xcurrent_scope > 1)
+                  if (m_current_scope > 1)
                     retval = find_function (name.substr (pos + 1), args);
                 }
             }
 
-          xcurrent_scope = stored_scope;
+          m_current_scope = stored_scope;
         }
     }
 
   return retval;
 }
 
 // look for @class/method>subfunction
 octave_value
@@ -1374,214 +1419,251 @@ symbol_table::find_submethod (const std:
 
   std::string full_name = "@" + dispatch_type +
                           octave::sys::file_ops::dir_sep_str () + name;
   size_t pos = full_name.find_first_of (Vfilemarker);
 
   if (pos != std::string::npos)
     {
       std::string fcn_scope = full_name.substr (0, pos);
-      scope_id stored_scope = xcurrent_scope;
-      xcurrent_scope = xtop_scope;
+      scope_id stored_scope = m_current_scope;
+      m_current_scope = xtop_scope;
       octave_value parent = find_function (full_name.substr (0, pos),
                                            octave_value_list (), false);
       if (parent.is_defined ())
         {
           octave_function *parent_fcn = parent.function_value ();
 
           if (parent_fcn)
             {
-              xcurrent_scope = parent_fcn->scope ();
+              m_current_scope = parent_fcn->scope ();
 
-              if (xcurrent_scope > 1)
+              if (m_current_scope > 1)
                 fcn = find_function (full_name.substr (pos + 1),
                                      octave_value_list ());
             }
         }
 
-      xcurrent_scope = stored_scope;
+      m_current_scope = stored_scope;
     }
 
   return fcn;
 }
 
 void
-symbol_table::dump (std::ostream& os, scope_id scope)
+symbol_table::dump (std::ostream& os, scope_id sid)
 {
-  if (scope == xglobal_scope)
+  if (sid == xglobal_scope)
     dump_global (os);
   else
     {
-      symbol_table *inst = get_instance (scope, false);
-
-      if (inst)
-        {
-          os << "*** dumping symbol table scope " << scope
-             << " (" << inst->table_name << ")\n\n";
-
-          std::map<std::string, octave_value> sfuns
-            = symbol_table::subfunctions_defined_in_scope (scope);
+      scope *s = get_scope (sid, false);
 
-          if (! sfuns.empty ())
-            {
-              os << "  subfunctions defined in this scope:\n";
+      if (s)
+        {
+          os << "*** dumping symbol table scope " << sid
+             << " (" << s->name () << ")\n\n";
 
-              for (std::map<std::string,
-                   octave_value>::const_iterator p = sfuns.begin ();
-                   p != sfuns.end (); p++)
-                os << "    " << p->first << "\n";
-
-              os << "\n";
-            }
-
-          inst->do_dump (os);
+          s->dump (os);
         }
     }
 }
 
 void
 symbol_table::dump_global (std::ostream& os)
 {
-  if (! global_table.empty ())
+  if (! m_global_symbols.empty ())
     {
       os << "*** dumping global symbol table\n\n";
 
-      for (const auto& str_val : global_table)
+      for (const auto& str_val : m_global_symbols)
         {
           std::string nm = str_val.first;
           octave_value val = str_val.second;
 
           os << "  " << nm << " ";
           val.dump (os);
           os << "\n";
         }
     }
 }
 
 void
 symbol_table::dump_functions (std::ostream& os)
 {
-  if (! fcn_table.empty ())
+  if (! m_fcn_table.empty ())
     {
       os << "*** dumping globally visible functions from symbol table\n"
          << "    (c=commandline, b=built-in)\n\n";
 
-      for (const auto& nm_fi : fcn_table)
+      for (const auto& nm_fi : m_fcn_table)
         nm_fi.second.dump (os, "  ");
 
       os << "\n";
     }
 }
 
 void
-symbol_table::stash_dir_name_for_subfunctions (scope_id scope,
-                                               const std::string& dir_name)
+symbol_table::cleanup (void)
 {
-  // FIXME: is this the best way to do this?  Maybe it would be
-  // better if we had a map from scope to list of subfunctions
-  // stored with the function.  Do we?
-
-  for (const auto& nm_fi : fcn_table)
-    {
-      std::pair<std::string, octave_value> tmp
-        = nm_fi.second.subfunction_defined_in_scope (scope);
+  clear_all (true);
 
-      std::string nm = tmp.first;
-
-      if (! nm.empty ())
-        {
-          octave_value& fcn = tmp.second;
-
-          octave_user_function *f = fcn.user_function_value ();
-
-          if (f)
-            f->stash_dir_name (dir_name);
-        }
-    }
+  m_global_symbols.clear ();
+  m_fcn_table.clear ();
+  m_class_precedence_table.clear ();
+  m_parent_map.clear ();
+  m_all_scopes.clear ();
 }
 
 octave_value
-symbol_table::do_find (const std::string& name,
-                       const octave_value_list& args,
-                       bool skip_variables,
-                       bool local_funcs)
+symbol_table::scope::find (const std::string& name,
+                           const octave_value_list& args,
+                           bool skip_variables, bool local_funcs)
 {
   octave_value retval;
 
   // Variable.
 
+  symbol_table& symtab
+    = octave::__get_symbol_table__ ("symbol_table::scope::find");
+
   if (! skip_variables)
     {
-      table_iterator p = table.find (name);
+      table_iterator p = m_symbols.find (name);
 
-      if (p != table.end ())
+      if (p != m_symbols.end ())
         {
           symbol_record sr = p->second;
 
           if (sr.is_global ())
-            return symbol_table::global_varval (name);
+            return symtab.global_varval (name);
           else
             {
               octave_value val = sr.varval ();
 
               if (val.is_defined ())
                 return val;
             }
         }
     }
 
-  fcn_table_iterator p = fcn_table.find (name);
+  if (local_funcs)
+    {
+      // Subfunction.  I think it only makes sense to check for
+      // subfunctions if we are currently executing a function defined
+      // from a .m file.
+
+      octave_value fcn = find_subfunction (name);
 
-  if (p != fcn_table.end ())
+      if (fcn.is_defined ())
+        return fcn;
+    }
+
+  fcn_table_iterator p = symtab.m_fcn_table.find (name);
+
+  if (p != symtab.m_fcn_table.end ())
     return p->second.find (args, local_funcs);
   else
     {
       fcn_info finfo (name);
 
       octave_value fcn = finfo.find (args, local_funcs);
 
       if (fcn.is_defined ())
-        fcn_table[name] = finfo;
+        symtab.m_fcn_table[name] = finfo;
 
       return fcn;
     }
 
   return retval;
 }
 
 octave_value
-symbol_table::do_builtin_find (const std::string& name)
+symbol_table::scope::builtin_find (const std::string& name)
 {
   octave_value retval;
 
-  fcn_table_iterator p = fcn_table.find (name);
+  symbol_table& symtab
+    = octave::__get_symbol_table__ ("symbol_table::scope::find");
 
-  if (p != fcn_table.end ())
+  fcn_table_iterator p = symtab.m_fcn_table.find (name);
+
+  if (p != symtab.m_fcn_table.end ())
     return p->second.builtin_find ();
   else
     {
       fcn_info finfo (name);
 
       octave_value fcn = finfo.builtin_find ();
 
       if (fcn.is_defined ())
-        fcn_table[name] = finfo;
+        symtab.m_fcn_table[name] = finfo;
 
       return fcn;
     }
 
   return retval;
 }
 
+void
+symbol_table::scope::clear_global (const std::string& name)
+{
+  table_iterator p = m_symbols.find (name);
+
+  if (p != m_symbols.end ())
+    {
+      symbol_table::symbol_record& sr = p->second;
+
+      if (sr.is_global ())
+        sr.unmark_global ();
+    }
+
+  symbol_table& symtab
+    = octave::__get_symbol_table__ ("symbol_table::scope::clear_global");
+
+  global_symbols_iterator q = symtab.m_global_symbols.find (name);
+
+  if (q != symtab.m_global_symbols.end ())
+    symtab.m_global_symbols.erase (q);
+
+}
+
+void
+symbol_table::scope::clear_global_pattern (const std::string& pat)
+{
+  glob_match pattern (pat);
+
+  for (auto& nm_sr : m_symbols)
+    {
+      symbol_table::symbol_record& sr = nm_sr.second;
+
+      if (sr.is_global () && pattern.match (sr.name ()))
+        sr.unmark_global ();
+    }
+
+  symbol_table& symtab
+    = octave::__get_symbol_table__ ("symbol_table::scope::clear_global_pattern");
+
+  global_symbols_iterator q = symtab.m_global_symbols.begin ();
+
+  while (q != symtab.m_global_symbols.end ())
+    {
+      if (pattern.match (q->first))
+        symtab.m_global_symbols.erase (q++);
+      else
+        q++;
+    }
+}
+
 std::list<workspace_element>
-symbol_table::do_workspace_info (void) const
+symbol_table::scope::workspace_info (void) const
 {
   std::list<workspace_element> retval;
 
-  for (const auto& nm_sr : table)
+  for (const auto& nm_sr : m_symbols)
     {
       std::string nm = nm_sr.first;
       symbol_record sr = nm_sr.second;
 
       if (! sr.is_hidden ())
         {
           octave_value val = sr.varval ();
 
@@ -1621,113 +1703,159 @@ symbol_table::do_workspace_info (void) c
             }
         }
     }
 
   return retval;
 }
 
 void
-symbol_table::do_dump (std::ostream& os)
+symbol_table::scope::dump (std::ostream& os)
 {
-  if (! persistent_table.empty ())
+  if (! m_subfunctions.empty ())
+    {
+      os << "  subfunctions defined in this scope:\n";
+
+      for (const auto& nm_sf : m_subfunctions)
+        os << "    " << nm_sf.first << "\n";
+
+      os << "\n";
+    }
+
+  if (! m_persistent_symbols.empty ())
     {
       os << "  persistent variables in this scope:\n\n";
 
-      for (const auto& nm_val : persistent_table)
+      for (const auto& nm_val : m_persistent_symbols)
         {
           std::string nm = nm_val.first;
           octave_value val = nm_val.second;
 
           os << "    " << nm << " ";
           val.dump (os);
           os << "\n";
         }
 
       os << "\n";
     }
 
-  if (! table.empty ())
+  if (! m_symbols.empty ())
     {
       os << "  other symbols in this scope (l=local; a=auto; f=formal\n"
          << "    h=hidden; i=inherited; g=global; p=persistent)\n\n";
 
-      for (const auto& nm_sr : table)
+      for (const auto& nm_sr : m_symbols)
         nm_sr.second.dump (os, "    ");
 
       os << "\n";
     }
 }
 
-void symbol_table::cleanup (void)
+void
+symbol_table::scope::install_subfunction (const std::string& name,
+                                          const octave_value& fval,
+                                          bool is_nested)
 {
-  clear_all (true);
+  m_subfunctions[name] = fval;
 
-  // Delete all possibly remaining scopes.
+  // This can be simpler once the scope object is stored in the function
+  // object...
+  octave_user_function *fcn = fval.user_function_value ();
 
-  while (! all_instances.empty ())
+  symbol_table& symtab
+    = octave::__get_symbol_table__ ("symbol_table::scope::install_subfunction");
+
+  scope *fcn_scope = symtab.get_scope (fcn->scope ());
+
+  fcn_scope->set_parent (this);
+
+  if (is_nested)
     {
-      // Note that deleting a scope may have side effects such as
-      // deleting other scopes.  If another scope is deleted, it may
-      // invalidate ITER, so erase this map element first.
-
-      all_instances_iterator iter = all_instances.begin ();
+      m_children.push_back (fcn_scope);
 
-      symbol_table *inst = iter->second;
+      fcn->mark_as_nested_function ();
 
-      all_instances.erase (iter);
-
-      delete inst;
+      fcn_scope->m_is_nested = true;
     }
 
-  global_table.clear ();
-  fcn_table.clear ();
-  class_precedence_table.clear ();
-  parent_map.clear ();
-  all_instances.clear ();
+}
+
+octave_value
+symbol_table::scope::find_subfunction (const std::string& name) const
+{
+  subfunctions_const_iterator p = m_subfunctions.find (name);
+
+  if (p != m_subfunctions.end ())
+    return p->second;
+
+  if (m_parent)
+    return m_parent->find_subfunction (name);
+
+  return octave_value ();
 }
 
 void
-symbol_table::do_update_nest (void)
+symbol_table::scope::stash_dir_name_for_subfunctions (const std::string& dir_name)
+{
+  for (const auto& nm_sf : m_subfunctions)
+    {
+      octave_user_function *fcn = nm_sf.second.user_function_value ();
+
+      if (fcn)
+        fcn->stash_dir_name (dir_name);
+    }
+}
+
+void
+symbol_table::scope::mark_subfunctions_in_scope_as_private (const std::string& class_name)
 {
-  if (nest_parent || nest_children.size ())
-    curr_fcn->mark_as_nested_function ();
+  for (auto& nm_sf : m_subfunctions)
+    {
+      octave_function *fcn = nm_sf.second.function_value ();
 
-  if (nest_parent)
+      if (fcn)
+        fcn->mark_as_private_function (class_name);
+    }
+}
+
+void
+symbol_table::scope::update_nest (void)
+{
+  if (m_parent)
     {
       // fix bad symbol_records
-      for (auto& nm_sr : table)
+      for (auto& nm_sr : m_symbols)
         {
           symbol_record& ours = nm_sr.second;
           symbol_record parents;
           if (! ours.is_formal ()
-              && nest_parent->look_nonlocal (nm_sr.first, parents))
+              && m_is_nested && m_parent->look_nonlocal (nm_sr.first, parents))
             {
               if (ours.is_global () || ours.is_persistent ())
                 error ("global and persistent may only be used in the topmost level in which a nested variable is used");
 
               if (! ours.is_formal ())
                 {
                   ours.invalidate ();
                   nm_sr.second = parents;
                 }
             }
           else
-            ours.set_curr_fcn (curr_fcn);
+            ours.set_curr_fcn (m_fcn);
         }
     }
-  else if (nest_children.size ())
+  else if (m_children.size ())
     {
-      static_workspace = true;
-      for (auto& nm_sr : table)
-        nm_sr.second.set_curr_fcn (curr_fcn);
+      m_is_static = true;
+      for (auto& nm_sr : m_symbols)
+        nm_sr.second.set_curr_fcn (m_fcn);
     }
 
-  for (auto& symtab_p : nest_children)
-    symtab_p->do_update_nest ();
+  for (auto& symtab_p : m_children)
+    symtab_p->update_nest ();
 }
 
 DEFUN (ignore_function_time_stamp, args, nargout,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{val} =} ignore_function_time_stamp ()
 @deftypefnx {} {@var{old_val} =} ignore_function_time_stamp (@var{new_val})
 Query or set the internal variable that controls whether Octave checks
 the time stamp on files each time it looks up functions defined in
@@ -1799,105 +1927,111 @@ determine whether functions defined in f
 %! ignore_function_time_stamp (old_state);
 
 ## Test input validation
 %!error (ignore_function_time_stamp ("all", "all"))
 %!error (ignore_function_time_stamp ("UNKNOWN_VALUE"))
 %!error (ignore_function_time_stamp (42))
 */
 
-DEFUN (__current_scope__, , ,
-       doc: /* -*- texinfo -*-
+DEFMETHOD (__current_scope__, interp, , ,
+           doc: /* -*- texinfo -*-
 @deftypefn {} {[@var{scope}, @var{context}]} __current_scope__ ()
 Return the current scope and context as integers.
 @seealso{__dump_symtab_info__}
 @end deftypefn */)
 {
-  return ovl (symbol_table::current_scope (), symbol_table::current_context ());
+  symbol_table& symtab = interp.get_symbol_table ();
+
+  return ovl (symtab.current_scope (), symtab.current_context ());
 }
 
-DEFUN (__dump_symtab_info__, args, ,
-       doc: /* -*- texinfo -*-
+DEFMETHOD (__dump_symtab_info__, interp, args, ,
+           doc: /* -*- texinfo -*-
 @deftypefn  {} {} __dump_symtab_info__ ()
 @deftypefnx {} {} __dump_symtab_info__ (@var{scope})
 @deftypefnx {} {} __dump_symtab_info__ ("scopes")
 @deftypefnx {} {} __dump_symtab_info__ ("functions")
 Undocumented internal function.
 @seealso{__current_scope__}
 @end deftypefn */)
 {
   int nargin = args.length ();
 
   if (nargin > 1)
     print_usage ();
 
   octave_value retval;
 
+  symbol_table& symtab = interp.get_symbol_table ();
+
   if (nargin == 0)
     {
-      symbol_table::dump_functions (octave_stdout);
+      symtab.dump_functions (octave_stdout);
 
-      symbol_table::dump_global (octave_stdout);
+      symtab.dump_global (octave_stdout);
 
-      std::list<symbol_table::scope_id> lst = symbol_table::scopes ();
+      std::list<symbol_table::scope_id> lst = symtab.scopes ();
 
       for (const auto& scope_id : lst)
-        symbol_table::dump (octave_stdout, scope_id);
+        symtab.dump (octave_stdout, scope_id);
     }
   else
     {
       octave_value arg = args(0);
 
       if (arg.is_string ())
         {
           std::string s_arg = arg.string_value ();
 
           if (s_arg == "scopes")
             {
-              std::list<symbol_table::scope_id> lst = symbol_table::scopes ();
+              std::list<symbol_table::scope_id> lst = symtab.scopes ();
 
               RowVector v (lst.size ());
 
               octave_idx_type k = 0;
 
-              for (const auto& scope_id : lst)
-                v.xelem (k++) = scope_id;
+              for (const auto& sid : lst)
+                v.xelem (k++) = sid;
 
               retval = v;
             }
           else if (s_arg == "functions")
             {
-              symbol_table::dump_functions (octave_stdout);
+              symtab.dump_functions (octave_stdout);
             }
           else
             error ("__dump_symtab_info__: string argument must be \"functions\" or \"scopes\"");
         }
       else
         {
-          int s = arg.xint_value ("__dump_symtab_info__: first argument must be string or scope id");
+          int sid = arg.xint_value ("__dump_symtab_info__: first argument must be string or scope id");
 
-          symbol_table::dump (octave_stdout, s);
+          symtab.dump (octave_stdout, sid);
         }
     }
 
   return retval;
 }
 
-DEFUN (__get_cmdline_fcn_txt__, args, ,
-       doc: /* -*- texinfo -*-
+DEFMETHOD (__get_cmdline_fcn_txt__, interp, args, ,
+           doc: /* -*- texinfo -*-
 @deftypefn {} {} __get_cmdline_fcn_txt__ (@var{name})
 Undocumented internal function.
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
   std::string name = args(0).xstring_value ("__get_cmd_line_function_text__: first argument must be function name");
 
-  octave_value ov = symbol_table::find_cmdline_function (name);
+  symbol_table& symtab = interp.get_symbol_table ();
+
+  octave_value ov = symtab.find_cmdline_function (name);
 
   octave_user_function *f = ov.user_function_value ();
 
   octave_value_list retval;
 
   if (f)
     {
       std::ostringstream buf;
@@ -1909,38 +2043,42 @@ Undocumented internal function.
       retval = ovl (buf.str ());
     }
 
   return retval;
 }
 
 // FIXME: should we have functions like this in Octave?
 //
-// DEFUN (set_variable, args, , "set_variable (NAME, VALUE)")
+// DEFMETHOD (set_variable, interp, args, , "set_variable (NAME, VALUE)")
 // {
 //   if (args.length () != 2)
 //     print_usage ();
 //
 //   std::string name = args(0).xstring_value ("set_variable: variable NAME must be a string");
 //
-//   symbol_table::assign (name, args(1));
+//   symbol_table& symtab = interp.get_symbol_table ();
+//
+//   symtab.assign (name, args(1));
 //
 //   return ovl ();
 // }
 //
-// DEFUN (variable_value, args, , "VALUE = variable_value (NAME)")
+// DEFMETHOD (variable_value, interp, args, , "VALUE = variable_value (NAME)")
 // {
 //   if (args.length () != 1)
 //     print_usage ();
 //
 //   octave_value retval;
 //
 //   std::string name = args(0).xstring_value ("variable_value: variable NAME must be a string");
 //
-//   retval = symbol_table::varval (name);
+//   symbol_table& symtab = interp.get_symbol_table ();
+//
+//   retval = symtab.varval (name);
 //
 //   if (retval.is_undefined ())
 //     error ("variable_value: '%s' is not a variable in the current scope",
 //            name.c_str ());
 //
 //   return retval;
 // }
 
diff --git a/libinterp/corefcn/symtab.h b/libinterp/corefcn/symtab.h
--- a/libinterp/corefcn/symtab.h
+++ b/libinterp/corefcn/symtab.h
@@ -22,153 +22,119 @@ along with Octave; see the file COPYING.
 */
 
 #if ! defined (octave_symtab_h)
 #define octave_symtab_h 1
 
 #include "octave-config.h"
 
 #include <deque>
+#include <limits>
 #include <list>
 #include <map>
 #include <set>
 #include <string>
 
 #include "glob-match.h"
 #include "lo-regexp.h"
 
 class tree_argument_list;
 class octave_user_function;
 
+#include "oct-refcount.h"
+#include "ov.h"
 #include "ovl.h"
 #include "workspace-element.h"
-#include "oct-refcount.h"
-#include "ov.h"
 
 class
 OCTINTERP_API
 symbol_table
 {
 public:
 
   static octave_value dummy_octave_value;
 
   typedef int scope_id;
   typedef size_t context_id;
 
-  class
-  scope_id_cache
+  class scope;
+
+  class scope_id_cache
   {
-  protected:
+  public:
 
     typedef std::set<scope_id>::iterator set_iterator;
     typedef std::set<scope_id>::const_iterator set_const_iterator;
 
     // We start with 2 because we allocate 0 for the global symbols
     // and 1 for the top-level workspace.
 
-    scope_id_cache (void) : next_available (2), in_use (), free_list () { }
-
-  public:
+    scope_id_cache (void)
+      : m_next_available (2), m_in_use (), m_free_list () { }
 
     // No copying!
 
     scope_id_cache (const scope_id_cache&) = delete;
 
     scope_id_cache& operator = (const scope_id_cache&) = delete;
 
     ~scope_id_cache (void) = default;
 
-    static scope_id alloc (void)
-    {
-      return instance_ok () ? instance->do_alloc () : -1;
-    }
-
-    static void free (scope_id scope)
-    {
-      if (instance_ok ())
-        return instance->do_free (scope);
-    }
-
-    static std::list<scope_id> scopes (void)
+    scope_id alloc (void)
     {
-      return instance_ok () ? instance->do_scopes () : std::list<scope_id> ();
-    }
-
-    static void create_instance (void);
-
-    static bool instance_ok (void)
-    {
-      bool retval = true;
-
-      if (! instance)
-        create_instance ();
-
-      if (! instance)
-        error ("unable to create scope_id_cache object!");
+      scope_id retval;
+
+      set_iterator p = m_free_list.begin ();
+
+      if (p != m_free_list.end ())
+        {
+          retval = *p;
+          m_free_list.erase (p);
+        }
+      else
+        retval = m_next_available++;
+
+      m_in_use.insert (retval);
 
       return retval;
     }
 
-  private:
-
-    static scope_id_cache *instance;
-
-    static void cleanup_instance (void) { delete instance; instance = 0; }
-
-    // The next available scope not in the free list.
-    scope_id next_available;
-
-    // The set of scope IDs that are currently allocated.
-    std::set<scope_id> in_use;
-
-    // The set of scope IDs that are currently available.
-    std::set<scope_id> free_list;
-
-    scope_id do_alloc (void)
+    void free (scope_id sid)
     {
-      scope_id retval;
-
-      set_iterator p = free_list.begin ();
-
-      if (p != free_list.end ())
-        {
-          retval = *p;
-          free_list.erase (p);
-        }
-      else
-        retval = next_available++;
-
-      in_use.insert (retval);
-
-      return retval;
+      set_iterator p = m_in_use.find (sid);
+
+      if (p == m_in_use.end ())
+        error ("free_scope: scope %d not found!", sid);
+
+      m_in_use.erase (p);
+      m_free_list.insert (sid);
     }
 
-    void do_free (scope_id scope)
-    {
-      set_iterator p = in_use.find (scope);
-
-      if (p == in_use.end ())
-        error ("free_scope: scope %d not found!", scope);
-
-      in_use.erase (p);
-      free_list.insert (scope);
-    }
-
-    std::list<scope_id> do_scopes (void) const
+    std::list<scope_id> scopes (void) const
     {
       std::list<scope_id> retval;
 
-      for (const auto& scope_id : in_use)
+      for (const auto& scope_id : m_in_use)
         retval.push_back (scope_id);
 
       retval.sort ();
 
       return retval;
     }
+
+  private:
+
+    // The next available scope not in the free list.
+    scope_id m_next_available;
+
+    // The set of scope IDs that are currently allocated.
+    std::set<scope_id> m_in_use;
+
+    // The set of scope IDs that are currently available.
+    std::set<scope_id> m_free_list;
   };
 
   class fcn_info;
 
   class
   symbol_record
   {
   public:
@@ -201,30 +167,32 @@ public:
 
   private:
 
     class
     symbol_record_rep
     {
     public:
 
-      symbol_record_rep (scope_id s, const std::string& nm,
+      symbol_record_rep (scope_id sid, const std::string& nm,
                          const octave_value& v, unsigned int sc)
-        : decl_scope (s), curr_fcn (0), name (nm), value_stack (),
-          storage_class (sc), finfo (), valid (true), count (1)
+        : m_decl_scope (sid), curr_fcn (0), name (nm), value_stack (),
+          storage_class (sc), /* finfo (), */ valid (true), count (1)
       {
         value_stack.push_back (v);
       }
 
       // No copying!
 
       symbol_record_rep (const symbol_record_rep& ov) = delete;
 
       symbol_record_rep& operator = (const symbol_record_rep&) = delete;
 
+      ~symbol_record_rep (void) = default;
+
       void assign (const octave_value& value,
                    context_id context = xdefault_context)
       {
         varref (context) = value;
       }
 
       void assign (octave_value::assign_op op,
                    const std::string& type,
@@ -252,69 +220,55 @@ public:
                                   const std::list<octave_value_list>& idx,
                                   context_id context = xdefault_context)
       {
         varref(context).do_non_const_unary_op (op, type, idx);
       }
 
       octave_value& varref (context_id context = xdefault_context)
       {
-        // We duplicate global_varref and persistent_varref here to
-        // avoid calling deprecated functions.
-
         if (is_global ())
-          {
-            symbol_table::global_table_iterator p
-              = symbol_table::global_table.find (name);
-
-            return (p == symbol_table::global_table.end ())
-                   ? symbol_table::global_table[name] : p->second;
-          }
+          return xglobal_varref ();
         else if (is_persistent ())
-          {
-            symbol_table *inst
-              = symbol_table::get_instance (symbol_table::current_scope ());
-
-            return inst ? inst->do_persistent_varref (name) : dummy_octave_value;
-          }
+          return xpersistent_varref ();
         else
           {
             if (context == xdefault_context)
               context = active_context ();
 
             context_id n = value_stack.size ();
             while (n++ <= context)
               value_stack.push_back (octave_value ());
 
             return value_stack[context];
           }
       }
 
       octave_value varval (context_id context = xdefault_context) const
       {
         if (is_global ())
-          return symbol_table::global_varval (name);
+          return xglobal_varval ();
         else if (is_persistent ())
-          return symbol_table::persistent_varval (name);
+          return xpersistent_varval ();
         else
           {
             if (context == xdefault_context)
               context = active_context ();
 
             if (context < value_stack.size ())
               return value_stack[context];
             else
               return octave_value ();
           }
       }
 
-      void push_context (scope_id s)
+      void push_context (scope_id sid)
       {
         if (! (is_persistent () || is_global ())
-            && s == scope ())
+            && sid == decl_scope ())
           value_stack.push_back (octave_value ());
       }
 
       // If pop_context returns 0, we are out of values and this element
       // of the symbol table should be deleted.  This can happen for
       // functions like
       //
       //   function foo (n)
@@ -322,50 +276,33 @@ public:
       //       foo (n-1);
       //     else
       //       eval ("x = 1");
       //     endif
       //   endfunction
       //
       // Here, X should only exist in the final stack frame.
 
-      size_t pop_context (scope_id s)
+      size_t pop_context (scope_id sid)
       {
         size_t retval = 1;
 
         if (! (is_persistent () || is_global ())
-            && s == scope ())
+            && sid == decl_scope ())
           {
             value_stack.pop_back ();
             retval = value_stack.size ();
           }
 
         return retval;
       }
 
-      void clear (void) { clear (scope ()); }
-
-      void clear (scope_id s)
-      {
-        if (! (is_hidden () || is_inherited ())
-            && s == scope ())
-          {
-            if (is_global ())
-              unmark_global ();
-
-            if (is_persistent ())
-              {
-                symbol_table::persistent_assign (name, varval ());
-
-                unmark_persistent ();
-              }
-
-            assign (octave_value ());
-          }
-      }
+      void clear (void) { clear (decl_scope ()); }
+
+      void clear (scope_id sid);
 
       bool is_defined (context_id context = xdefault_context) const
       {
         if (context == xdefault_context)
           context = active_context ();
 
         return varval (context).is_defined ();
       }
@@ -417,78 +354,74 @@ public:
       void unmark_automatic (void) { storage_class &= ~automatic; }
       void unmark_formal (void) { storage_class &= ~formal; }
       void unmark_hidden (void) { storage_class &= ~hidden; }
       void unmark_inherited (void) { storage_class &= ~inherited; }
       void unmark_global (void) { storage_class &= ~global; }
       void unmark_persistent (void) { storage_class &= ~persistent; }
       void unmark_added_static (void) { storage_class &= ~added_static; }
 
-      void init_persistent (void)
-      {
-        if (! is_defined ())
-          {
-            mark_persistent ();
-
-            assign (symbol_table::persistent_varval (name));
-          }
-        // FIXME: this causes trouble with recursive calls.
-        // else
-        //   error ("unable to declare existing variable persistent");
-      }
+      void init_persistent (void);
 
       void invalidate (void)
       {
         valid = false;
       }
 
-      void erase_persistent (void)
-      {
-        unmark_persistent ();
-        symbol_table::erase_persistent (name);
-      }
+      void erase_persistent (void);
 
       OCTINTERP_API context_id active_context (void) const;
 
-      scope_id scope (void) const { return decl_scope; }
+      scope_id decl_scope (void) const { return m_decl_scope; }
 
       void set_curr_fcn (octave_user_function *fcn)
       {
         curr_fcn = fcn;
       }
 
       symbol_record_rep * dup (scope_id new_scope) const
       {
         return new symbol_record_rep (new_scope, name, varval (),
                                       storage_class);
       }
 
       void dump (std::ostream& os, const std::string& prefix) const;
 
-      scope_id decl_scope;
+      scope_id m_decl_scope;
 
       octave_user_function *curr_fcn;
 
       std::string name;
 
       std::deque<octave_value> value_stack;
 
       unsigned int storage_class;
 
-      fcn_info *finfo;
+      //      fcn_info *finfo;
 
       bool valid;
 
       octave::refcount<size_t> count;
+
+    private:
+
+      octave_value& xglobal_varref (void);
+
+      octave_value& xpersistent_varref (void);
+
+      octave_value xglobal_varval (void) const;
+
+      octave_value xpersistent_varval (void) const;
     };
 
   public:
 
-    symbol_record (scope_id s = xcurrent_scope,
-                   const std::string& nm = "",
+    symbol_record (void);
+
+    symbol_record (scope_id s, const std::string& nm = "",
                    const octave_value& v = octave_value (),
                    unsigned int sc = local)
       : rep (new symbol_record_rep (s, nm, v, sc)) { }
 
     symbol_record (const symbol_record& sr)
       : rep (sr.rep)
     {
       rep->count++;
@@ -565,23 +498,23 @@ public:
       return rep->varref (context);
     }
 
     octave_value varval (context_id context = xdefault_context) const
     {
       return rep->varval (context);
     }
 
-    void push_context (scope_id s) { rep->push_context (s); }
-
-    size_t pop_context (scope_id s) { return rep->pop_context (s); }
+    void push_context (scope_id sid) { rep->push_context (sid); }
+
+    size_t pop_context (scope_id sid) { return rep->pop_context (sid); }
 
     void clear (void) { rep->clear (); }
 
-    void clear (scope_id s) { rep->clear (s); }
+    void clear (scope_id sid) { rep->clear (sid); }
 
     bool is_defined (context_id context = xdefault_context) const
     {
       return rep->is_defined (context);
     }
 
     bool is_undefined (context_id context = xdefault_context) const
     {
@@ -628,17 +561,17 @@ public:
     void init_persistent (void) { rep->init_persistent (); }
 
     void erase_persistent (void) { rep->erase_persistent (); }
 
     void invalidate (void) { rep->invalidate (); }
 
     context_id active_context (void) const { return rep->active_context (); }
 
-    scope_id scope (void) const { return rep->scope (); }
+    scope_id decl_scope (void) const { return rep->decl_scope (); }
 
     unsigned int xstorage_class (void) const { return rep->storage_class; }
 
     void set_curr_fcn (octave_user_function *fcn) { rep->set_curr_fcn (fcn); }
 
     void
     dump (std::ostream& os, const std::string& prefix = "") const
     {
@@ -656,103 +589,81 @@ public:
 
   // Always access a symbol from the current scope.
   // Useful for scripts, as they may be executed in more than one scope.
   class
   symbol_reference
   {
   public:
 
-    symbol_reference (void) : scope (-1) { }
-
-    symbol_reference (const symbol_record& record,
-                      scope_id curr_scope = symbol_table::current_scope ())
-      : scope (curr_scope), sym (record)
-    { }
-
-    symbol_reference (const symbol_reference& ref)
-      : scope (ref.scope), sym (ref.sym)
+    symbol_reference (void) : m_scope (-1) { }
+
+    symbol_reference (const symbol_record& record);
+
+    symbol_reference (const symbol_record& record, scope_id curr_scope)
+      : m_scope (curr_scope), m_sym (record)
     { }
 
-    symbol_reference& operator = (const symbol_reference& ref)
-    {
-      if (this != &ref)
-        {
-          scope = ref.scope;
-          sym = ref.sym;
-        }
-      return *this;
-    }
-
-    bool is_black_hole (void) const { return scope < 0; }
+    symbol_reference (const symbol_reference& ref) = default;
+
+    symbol_reference& operator = (const symbol_reference& ref) = default;
+
+    bool is_black_hole (void) const { return m_scope < 0; }
 
     // The name is the same regardless of scope.
-    const std::string& name (void) const { return sym.name (); }
+    const std::string& name (void) const { return m_sym.name (); }
 
     symbol_record *operator-> (void)
     {
       update ();
-      return &sym;
+      return &m_sym;
     }
 
     symbol_record *operator-> (void) const
     {
       update ();
-      return &sym;
+      return &m_sym;
     }
 
     // can be used to place symbol_reference in maps, we don't overload < as
     // it doesn't make any sense for symbol_reference
     struct comparator
     {
       bool operator ()(const symbol_reference& lhs,
                        const symbol_reference& rhs) const
       {
         return lhs.name () < rhs.name ();
       }
     };
   private:
 
-    void update (void) const
-    {
-      scope_id curr_scope = symbol_table::current_scope ();
-
-      if (scope != curr_scope || ! sym.is_valid ())
-        {
-          scope = curr_scope;
-          sym = symbol_table::insert (sym.name ());
-        }
-    }
-
-    mutable scope_id scope;
-    mutable symbol_record sym;
+    void update (void) const;
+
+    mutable scope_id m_scope;
+    mutable symbol_record m_sym;
   };
 
   class
   fcn_info
   {
   public:
 
-    typedef std::map<scope_id, octave_value>::const_iterator
-      scope_val_const_iterator;
-    typedef std::map<scope_id, octave_value>::iterator scope_val_iterator;
-
     typedef std::map<std::string, octave_value>::const_iterator
       str_val_const_iterator;
     typedef std::map<std::string, octave_value>::iterator str_val_iterator;
 
   private:
 
     class
     fcn_info_rep
     {
     public:
 
       fcn_info_rep (const std::string& nm)
-        : name (nm), package_name (), subfunctions (), local_functions (),
+        : name (nm), package_name (), local_functions (),
           private_functions (), class_constructors (), class_methods (),
           cmdline_function (), autoload_function (), function_on_path (),
           built_in_function (), count (1)
       {
         size_t pos = name.rfind ('.');
 
         if (pos != std::string::npos)
           {
@@ -762,16 +673,18 @@ public:
       }
 
       // No copying!
 
       fcn_info_rep (const fcn_info_rep&) = delete;
 
       fcn_info_rep& operator = (const fcn_info_rep&) = delete;
 
+      ~fcn_info_rep (void) = default;
+
       octave_value install_local_function (const std::string& file_name);
 
       octave_value load_private_function (const std::string& dir_name);
 
       octave_value load_class_constructor (void);
 
       octave_value load_class_method (const std::string& dispatch_type);
 
@@ -793,63 +706,21 @@ public:
       }
 
       octave_value find_function (const octave_value_list& args,
                                   bool local_funcs)
       {
         return find (args, local_funcs);
       }
 
-      void lock_subfunction (scope_id scope)
-      {
-        scope_val_iterator p = subfunctions.find (scope);
-
-        if (p != subfunctions.end ())
-          p->second.lock ();
-      }
-
-      void unlock_subfunction (scope_id scope)
-      {
-        scope_val_iterator p = subfunctions.find (scope);
-
-        if (p != subfunctions.end ())
-          p->second.unlock ();
-      }
-
-      std::pair<std::string, octave_value>
-      subfunction_defined_in_scope (scope_id scope) const
-      {
-        scope_val_const_iterator p = subfunctions.find (scope);
-
-        return p == subfunctions.end ()
-               ? std::pair<std::string, octave_value> ()
-               : std::pair<std::string, octave_value> (name, p->second);
-      }
-
-      void erase_subfunction (scope_id scope)
-      {
-        scope_val_iterator p = subfunctions.find (scope);
-
-        if (p != subfunctions.end ())
-          subfunctions.erase (p);
-      }
-
-      void mark_subfunction_in_scope_as_private (scope_id scope,
-                                                 const std::string& class_name);
-
       void install_cmdline_function (const octave_value& f)
       {
         cmdline_function = f;
       }
 
-      void install_subfunction (const octave_value& f, scope_id scope)
-      {
-        subfunctions[scope] = f;
-      }
-
       void install_local_function (const octave_value& f,
                                    const std::string& file_name)
       {
         local_functions[file_name] = f;
       }
 
       void install_user_function (const octave_value& f)
       {
@@ -905,17 +776,16 @@ public:
 
       void clear_package (void)
       {
         package = octave_value ();
       }
 
       void clear (bool force = false)
       {
-        clear_map (subfunctions, force);
         clear_map (local_functions, force);
         clear_map (private_functions, force);
         clear_map (class_constructors, force);
         clear_map (class_methods, force);
 
         clear_autoload_function (force);
         clear_user_function (force);
         clear_package ();
@@ -930,19 +800,16 @@ public:
         else
           return package_name + "." + name;
       }
 
       std::string name;
 
       std::string package_name;
 
-      // Scope id to function object.
-      std::map<scope_id, octave_value> subfunctions;
-
       // File name to function object.
       std::map<std::string, octave_value> local_functions;
 
       // Directory name to function object.
       std::map<std::string, octave_value> private_functions;
 
       // Class name to function object.
       std::map<std::string, octave_value> class_constructors;
@@ -1042,53 +909,21 @@ public:
 
     octave_value find_function (const octave_value_list& args
                                 = octave_value_list (),
                                 bool local_funcs = true)
     {
       return rep->find_function (args, local_funcs);
     }
 
-    void lock_subfunction (scope_id scope)
-    {
-      rep->lock_subfunction (scope);
-    }
-
-    void unlock_subfunction (scope_id scope)
-    {
-      rep->unlock_subfunction (scope);
-    }
-
-    std::pair<std::string, octave_value>
-    subfunction_defined_in_scope (scope_id scope = xcurrent_scope) const
-    {
-      return rep->subfunction_defined_in_scope (scope);
-    }
-
-    void erase_subfunction (scope_id scope)
-    {
-      rep->erase_subfunction (scope);
-    }
-
-    void mark_subfunction_in_scope_as_private (scope_id scope,
-                                               const std::string& class_name)
-    {
-      rep->mark_subfunction_in_scope_as_private (scope, class_name);
-    }
-
     void install_cmdline_function (const octave_value& f)
     {
       rep->install_cmdline_function (f);
     }
 
-    void install_subfunction (const octave_value& f, scope_id scope)
-    {
-      rep->install_subfunction (f, scope);
-    }
-
     void install_local_function (const octave_value& f,
                                  const std::string& file_name)
     {
       rep->install_local_function (f, file_name);
     }
 
     void install_user_function (const octave_value& f)
     {
@@ -1125,358 +960,400 @@ public:
       rep->dump (os, prefix);
     }
 
   private:
 
     fcn_info_rep *rep;
   };
 
+  symbol_table (void)
+    : m_scope_id_cache (), m_global_symbols (), m_all_scopes (),
+      m_fcn_table (), m_class_precedence_table (), m_parent_map (),
+      m_current_scope (xtop_scope)
+  { }
+
+  // No copying!
+
+  symbol_table (const symbol_table&) = delete;
+
+  symbol_table& operator = (const symbol_table&) = delete;
+
+  ~symbol_table (void) = default;
+
   static scope_id global_scope (void) { return xglobal_scope; }
   static scope_id top_scope (void) { return xtop_scope; }
 
-  static scope_id current_scope (void) { return xcurrent_scope; }
-
-  static context_id current_context (void) { return xcurrent_context; }
-
-  static scope_id alloc_scope (void) { return scope_id_cache::alloc (); }
-
-  static void set_scope (scope_id scope)
+  scope_id current_scope (void) { return m_current_scope; }
+
+  context_id current_context (void) { return xcurrent_context; }
+
+  scope_id alloc_scope (void) { return m_scope_id_cache.alloc (); }
+
+  void set_scope (scope_id sid)
   {
-    if (scope == xglobal_scope)
+    set_scope_and_context (sid, 0);
+  }
+
+  void set_scope_and_context (scope_id sid, context_id context)
+  {
+    if (sid == xglobal_scope)
       error ("can't set scope to global");
 
-    if (scope != xcurrent_scope)
+    all_scopes_iterator p = m_all_scopes.find (sid);
+
+    if (p == m_all_scopes.end ())
       {
-        all_instances_iterator p = all_instances.find (scope);
-
-        if (p == all_instances.end ())
-          {
-            symbol_table *inst = new symbol_table (scope);
-
-            if (inst)
-              all_instances[scope] = instance = inst;
-          }
-        else
-          instance = p->second;
-
-        xcurrent_scope = scope;
-        xcurrent_context = 0;
+        // Can only create a new scope if we are starting at the
+        // base context.
+
+        if (context != 0)
+          error ("can't find scope %d", sid);
+
+        scope *s = new scope (sid);
+
+        if (! s)
+          error ("failed to create scope %d", sid);
+
+        m_all_scopes[sid] = s;
+      }
+
+    m_current_scope = sid;
+    xcurrent_context = context;
+  }
+
+  void erase_scope (scope_id sid)
+  {
+    assert (sid != xglobal_scope);
+
+    all_scopes_iterator p = m_all_scopes.find (sid);
+
+    if (p != m_all_scopes.end ())
+      {
+        m_all_scopes.erase (p);
+
+        free_scope (sid);
       }
   }
 
-  static void set_scope_and_context (scope_id scope, context_id context)
-  {
-    if (scope == xglobal_scope)
-      error ("can't set scope to global");
-
-    if (scope != xcurrent_scope)
-      {
-        all_instances_iterator p = all_instances.find (scope);
-
-        if (p == all_instances.end ())
-          error ("scope not found!");
-
-        instance = p->second;
-
-        xcurrent_scope = scope;
-
-        xcurrent_context = context;
-      }
-    else
-      xcurrent_context = context;
-  }
-
-  static void erase_scope (scope_id scope)
+  void erase_subfunctions_in_scope (scope_id sid)
   {
-    assert (scope != xglobal_scope);
-
-    erase_subfunctions_in_scope (scope);
-
-    all_instances_iterator p = all_instances.find (scope);
-
-    if (p != all_instances.end ())
-      {
-        symbol_table *inst = p->second;
-
-        all_instances.erase (p);
-
-        delete inst;
-
-        free_scope (scope);
-      }
+    scope *s = get_scope (sid);
+
+    if (s)
+      s->erase_subfunctions ();
   }
 
-  static void erase_subfunctions_in_scope (scope_id scope)
+  void mark_nested (scope_id sid)
   {
-    for (auto& nm_finfo : fcn_table)
-      nm_finfo.second.erase_subfunction (scope);
+    scope *s = get_scope (sid);
+
+    if (s)
+      s->mark_nested ();
   }
 
-  static void
-  mark_subfunctions_in_scope_as_private (scope_id scope,
+  void
+  mark_subfunctions_in_scope_as_private (scope_id sid,
                                          const std::string& class_name)
   {
-    for (auto& nm_finfo : fcn_table)
-      nm_finfo.second.mark_subfunction_in_scope_as_private (scope, class_name);
+    scope *s = get_scope (sid);
+
+    if (s)
+      s->mark_subfunctions_in_scope_as_private (class_name);
   }
 
-  static scope_id dup_scope (scope_id scope)
+  scope_id dup_scope (scope_id sid)
   {
     scope_id retval = -1;
 
-    symbol_table *inst = get_instance (scope);
-
-    if (inst)
+    scope *s = get_scope (sid);
+
+    if (s)
       {
-        scope_id new_scope = alloc_scope ();
-
-        symbol_table *new_symbol_table = new symbol_table (scope);
-
-        if (new_symbol_table)
-          {
-            all_instances[new_scope] = new_symbol_table;
-
-            inst->do_dup_scope (*new_symbol_table);
-
-            retval = new_scope;
-          }
+        scope_id new_sid = alloc_scope ();
+
+        m_all_scopes[new_sid] = s->dup (new_sid);
+
+        retval = new_sid;
       }
 
     return retval;
   }
 
-  static std::list<scope_id> scopes (void)
+  std::list<scope_id> scopes (void)
   {
-    return scope_id_cache::scopes ();
+    return m_scope_id_cache.scopes ();
   }
 
-  static symbol_record
-  find_symbol (const std::string& name, scope_id scope = xcurrent_scope)
+  symbol_record
+  find_symbol (const std::string& name, scope_id sid)
   {
-    symbol_table *inst = get_instance (scope);
-
-    return inst ? inst->do_find_symbol (name) :
-      symbol_record (scope);
+    scope *s = get_scope (sid);
+
+    return s ? s->find_symbol (name) : symbol_record (sid);
+  }
+
+  symbol_record find_symbol (const std::string& name)
+  {
+    return find_symbol (name, m_current_scope);
   }
 
-  static void
-  inherit (scope_id scope, scope_id donor_scope, context_id donor_context)
+  void
+  inherit (scope_id sid, scope_id donor_sid, context_id donor_context)
   {
-    symbol_table *inst = get_instance (scope);
-
-    if (inst)
+    scope *s = get_scope (sid);
+
+    if (s)
       {
-        symbol_table *donor_symbol_table = get_instance (donor_scope);
-
-        if (donor_symbol_table)
-          inst->do_inherit (*donor_symbol_table, donor_context);
+        while (donor_sid > 0)
+          {
+            scope *donor_scope = get_scope (donor_sid);
+
+            if (donor_scope)
+              {
+                s->inherit (*donor_scope, donor_context);
+
+                if (donor_scope->is_nested ())
+                  donor_sid = donor_scope->parent_scope_id ();
+                else
+                  break;
+              }
+          }
       }
   }
 
-  static bool at_top_level (void) { return xcurrent_scope == xtop_scope; }
+  void
+  inherit (scope_id sid, scope_id donor_sid)
+  {
+    inherit (sid, donor_sid, xcurrent_context);
+  }
+
+  void inherit (scope_id sid)
+  {
+    inherit (sid, m_current_scope);
+  }
+
+  bool at_top_level (void) { return m_current_scope == xtop_scope; }
 
   // Find a value corresponding to the given name in the table.
-  static octave_value
+  octave_value
   find (const std::string& name,
         const octave_value_list& args = octave_value_list (),
         bool skip_variables = false,
         bool local_funcs = true);
 
-  static octave_value builtin_find (const std::string& name);
+  octave_value builtin_find (const std::string& name);
 
   // Insert a new name in the table.
-  static symbol_record& insert (const std::string& name,
-                                scope_id scope = xcurrent_scope)
+  OCTAVE_DEPRECATED ("use 'get_scope' with 'insert (name)' instead")
+  symbol_record& insert (const std::string& name, scope_id sid)
   {
-    symbol_table *inst = get_instance (scope);
-
-    return inst ? inst->do_insert (name) : symbol_table::dummy_symbol_record;
+    scope *s = get_scope (sid);
+
+    return s ? s->insert (name) : symbol_table::dummy_symbol_record;
   }
 
-  static void rename (const std::string& old_name,
-                      const std::string& new_name,
-                      scope_id scope = xcurrent_scope)
+  symbol_record& insert (const std::string& name)
   {
-    symbol_table *inst = get_instance (scope);
-
-    if (inst)
-      inst->do_rename (old_name, new_name);
+    scope *s = get_scope (m_current_scope);
+
+    return s ? s->insert (name) : symbol_table::dummy_symbol_record;
+  }
+
+  void rename (const std::string& old_name, const std::string& new_name)
+  {
+    scope *s = get_scope (m_current_scope);
+
+    if (s)
+      s->rename (old_name, new_name);
   }
 
-  static void assign (const std::string& name,
-                      const octave_value& value = octave_value (),
-                      scope_id scope = xcurrent_scope,
-                      context_id context = xdefault_context,
-                      bool force_add = false)
+  void assign (const std::string& name, const octave_value& value,
+               scope_id sid, context_id context, bool force_add)
   {
-    symbol_table *inst = get_instance (scope);
-
-    if (inst)
-      inst->do_assign (name, value, context, force_add);
+    scope *s = get_scope (sid);
+
+    if (s)
+      s->assign (name, value, context, force_add);
+  }
+
+  void assign (const std::string& name, const octave_value& value,
+               scope_id sid, context_id context)
+  {
+    assign (name, value, sid, context, false);
   }
 
-  OCTAVE_DEPRECATED ("use 'assign' instead")
-  static octave_value&
-  varref (const std::string& name, scope_id scope = xcurrent_scope,
-          context_id context = xdefault_context, bool force_add = false)
+  void assign (const std::string& name, const octave_value& value,
+               scope_id sid)
   {
-    symbol_table *inst = get_instance (scope);
-
-    return inst ? inst->do_varref (name, context, force_add) : dummy_octave_value;
+    assign (name, value, sid, xdefault_context);
   }
 
+  void assign (const std::string& name,
+               const octave_value& value = octave_value ())
+  {
+    assign (name, value, m_current_scope);
+  }
+
+  // use 'assign' instead
+  // octave_value&
+  // varref (const std::string& name, scope_id sid = xcurrent_scope,
+  //         context_id context = xdefault_context, bool force_add = false);
+
   // Convenience function to simplify
   // octave_user_function::bind_automatic_vars
 
-  static void force_assign (const std::string& name,
-                            const octave_value& value = octave_value (),
-                            scope_id scope = xcurrent_scope,
-                            context_id context = xdefault_context)
+  void force_assign (const std::string& name, const octave_value& value,
+                     scope_id sid, context_id context)
   {
-    assign (name, value, scope, context, true);
+    assign (name, value, sid, context, true);
   }
 
-  OCTAVE_DEPRECATED ("use 'force_assign' instead")
-  static octave_value&
-  force_varref (const std::string& name, scope_id scope = xcurrent_scope,
-                context_id context = xdefault_context)
+  void force_assign (const std::string& name, const octave_value& value,
+                     scope_id sid)
+  {
+    assign (name, value, sid, xdefault_context);
+  }
+
+  void force_assign (const std::string& name,
+                     const octave_value& value = octave_value ())
   {
-    symbol_table *inst = get_instance (scope);
-
-    return inst ? inst->do_varref (name, context, true) : dummy_octave_value;
+    assign (name, value, m_current_scope);
   }
 
-  static octave_value varval (const std::string& name,
-                              scope_id scope = xcurrent_scope,
-                              context_id context = xdefault_context)
+  // use 'force_assign' instead
+  // octave_value&
+  // force_varref (const std::string& name, scope_id sid = xcurrent_scope,
+  //               context_id context = xdefault_context);
+
+  octave_value varval (const std::string& name, scope_id sid,
+                       context_id context)
   {
-    symbol_table *inst = get_instance (scope);
-
-    return inst ? inst->do_varval (name, context) : octave_value ();
+    scope *s = get_scope (sid);
+
+    return s ? s->varval (name, context) : octave_value ();
   }
 
-  static void
+  octave_value varval (const std::string& name, scope_id sid)
+  {
+    return varval (name, sid, xdefault_context);
+  }
+
+  octave_value varval (const std::string& name)
+  {
+    return varval (name, m_current_scope);
+  }
+
+  void
   global_assign (const std::string& name,
                  const octave_value& value = octave_value ())
 
   {
-    global_table_iterator p = global_table.find (name);
-
-    if (p == global_table.end ())
-      global_table[name] = value;
+    global_symbols_iterator p = m_global_symbols.find (name);
+
+    if (p == m_global_symbols.end ())
+      m_global_symbols[name] = value;
     else
       p->second = value;
   }
 
-  OCTAVE_DEPRECATED ("use 'global_assign' instead")
-  static octave_value&
-  global_varref (const std::string& name)
-
-  {
-    global_table_iterator p = global_table.find (name);
-
-    return (p == global_table.end ()) ? global_table[name] : p->second;
-  }
-
-  static octave_value
+  // use 'global_assign' instead
+  // octave_value&
+  // global_varref (const std::string& name);
+
+  octave_value
   global_varval (const std::string& name)
   {
-    global_table_const_iterator p = global_table.find (name);
-
-    return (p != global_table.end ()) ? p->second : octave_value ();
+    global_symbols_const_iterator p = m_global_symbols.find (name);
+
+    return (p != m_global_symbols.end ()) ? p->second : octave_value ();
   }
 
-  static void
+  void
   top_level_assign (const std::string& name,
                     const octave_value& value = octave_value ())
   {
     assign (name, value, top_scope (), 0);
   }
 
-  OCTAVE_DEPRECATED ("use 'top_level_assign' instead")
-  static octave_value&
-  top_level_varref (const std::string& name)
-  {
-    symbol_table *inst = get_instance (top_scope ());
-
-    return inst ? inst->do_varref (name, 0, true) : dummy_octave_value;
-  }
-
-  static octave_value
+  // use 'top_level_assign' instead
+  // octave_value&
+  // top_level_varref (const std::string& name);
+
+  octave_value
   top_level_varval (const std::string& name)
   {
     return varval (name, top_scope (), 0);
   }
 
-  static void
-  persistent_assign (const std::string& name, scope_id scope,
+  void
+  persistent_assign (const std::string& name, scope_id sid,
                      const octave_value& value = octave_value ())
   {
-    symbol_table *inst = get_instance (scope);
-
-    if (inst)
-      inst->do_persistent_assign (name, value);
+    scope *s = get_scope (sid);
+
+    if (s)
+      s->persistent_assign (name, value);
   }
 
-  static void
+  void
   persistent_assign (const std::string& name,
                      const octave_value& value = octave_value ())
   {
-    persistent_assign (name, xcurrent_scope, value);
+    persistent_assign (name, m_current_scope, value);
   }
 
-  OCTAVE_DEPRECATED ("use 'persistent_assign' instead")
-  static octave_value&
-  persistent_varref (const std::string& name)
+  // use 'persistent_assign' instead
+  // octave_value&
+  // persistent_varref (const std::string& name);
+
+  octave_value persistent_varval (const std::string& name)
   {
-    symbol_table *inst = get_instance (xcurrent_scope);
-
-    return inst ? inst->do_persistent_varref (name) : dummy_octave_value;
-  }
-
-  static octave_value persistent_varval (const std::string& name,
-                                         scope_id scope = xcurrent_scope)
-  {
-    symbol_table *inst = get_instance (scope);
-
-    return inst ? inst->do_persistent_varval (name) : octave_value ();
+    scope *s = get_scope (m_current_scope);
+
+    return s ? s->persistent_varval (name) : octave_value ();
   }
 
-  static void erase_persistent (const std::string& name,
-                                scope_id scope = xcurrent_scope)
+  void erase_persistent (const std::string& name)
   {
-    symbol_table *inst = get_instance (scope);
-
-    if (inst)
-      inst->do_erase_persistent (name);
+    scope *s = get_scope (m_current_scope);
+
+    if (s)
+      s->erase_persistent (name);
   }
 
-  static bool is_variable (const std::string& name,
-                           scope_id scope = xcurrent_scope)
+  OCTAVE_DEPRECATED ("use 'get_scope' with 'is_variable (name)' instead")
+  bool is_variable (const std::string& name, scope_id sid)
   {
-    symbol_table *inst = get_instance (scope);
-
-    return inst ? inst->do_is_variable (name) : false;
+    scope *s = get_scope (sid);
+
+    return s ? s->is_variable (name) : false;
   }
 
-  static bool
+  bool is_variable (const std::string& name)
+  {
+    scope *s = get_scope (m_current_scope);
+
+    return s ? s->is_variable (name) : false;
+  }
+
+  bool
   is_built_in_function_name (const std::string& name)
   {
     octave_value val = find_built_in_function (name);
 
     return val.is_defined ();
   }
 
-  static octave_value
+  octave_value
   find_method (const std::string& name, const std::string& dispatch_type)
   {
-    fcn_table_const_iterator p = fcn_table.find (name);
-
-    if (p != fcn_table.end ())
+    fcn_table_const_iterator p = m_fcn_table.find (name);
+
+    if (p != m_fcn_table.end ())
       {
         octave_value fcn = p->second.find_method (dispatch_type);
 
         if (! fcn.is_defined ())
           fcn = find_submethod (name, dispatch_type);
 
         return fcn;
       }
@@ -1485,744 +1362,750 @@ public:
         fcn_info finfo (name);
 
         octave_value fcn = finfo.find_method (dispatch_type);
 
         if (! fcn.is_defined ())
           fcn = find_submethod (name, dispatch_type);
 
         if (fcn.is_defined ())
-          fcn_table[name] = finfo;
+          m_fcn_table[name] = finfo;
 
         return fcn;
       }
   }
 
-  static octave_value
+  octave_value
   find_submethod (const std::string& name, const std::string& dispatch_type);
 
-  static octave_value
+  octave_value
   find_built_in_function (const std::string& name)
   {
-    fcn_table_const_iterator p = fcn_table.find (name);
-
-    return (p != fcn_table.end ())
-           ? p->second.find_built_in_function () : octave_value ();
+    fcn_table_const_iterator p = m_fcn_table.find (name);
+
+    return (p != m_fcn_table.end ()
+            ? p->second.find_built_in_function () : octave_value ());
   }
 
-  static octave_value
+  octave_value
   find_autoload (const std::string& name)
   {
-    fcn_table_iterator p = fcn_table.find (name);
-
-    return (p != fcn_table.end ())
-           ? p->second.find_autoload () : octave_value ();
+    fcn_table_iterator p = m_fcn_table.find (name);
+
+    return (p != m_fcn_table.end ()
+            ? p->second.find_autoload () : octave_value ());
   }
 
-  static octave_value
+  octave_value
   find_function (const std::string& name,
                  const octave_value_list& args = octave_value_list (),
                  bool local_funcs = true);
 
-  static octave_value find_user_function (const std::string& name)
+  octave_value find_user_function (const std::string& name)
   {
-    fcn_table_iterator p = fcn_table.find (name);
-
-    return (p != fcn_table.end ())
-           ? p->second.find_user_function () : octave_value ();
+    fcn_table_iterator p = m_fcn_table.find (name);
+
+    return (p != m_fcn_table.end ()
+            ? p->second.find_user_function () : octave_value ());
   }
 
-  static octave_value find_cmdline_function (const std::string& name)
+  octave_value find_cmdline_function (const std::string& name)
   {
-    fcn_table_iterator p = fcn_table.find (name);
-
-    return (p != fcn_table.end ())
-           ? p->second.find_cmdline_function () : octave_value ();
+    fcn_table_iterator p = m_fcn_table.find (name);
+
+    return (p != m_fcn_table.end ()
+            ? p->second.find_cmdline_function () : octave_value ());
   }
 
-  static void install_cmdline_function (const std::string& name,
-                                        const octave_value& fcn)
+  void install_cmdline_function (const std::string& name,
+                                 const octave_value& fcn)
   {
-    fcn_table_iterator p = fcn_table.find (name);
-
-    if (p != fcn_table.end ())
+    fcn_table_iterator p = m_fcn_table.find (name);
+
+    if (p != m_fcn_table.end ())
       {
         fcn_info& finfo = p->second;
 
         finfo.install_cmdline_function (fcn);
       }
     else
       {
         fcn_info finfo (name);
 
         finfo.install_cmdline_function (fcn);
 
-        fcn_table[name] = finfo;
+        m_fcn_table[name] = finfo;
       }
   }
 
   // Install subfunction FCN named NAME.  SCOPE is the scope of the
   // primary function corresponding to this subfunction.
 
-  static void install_subfunction (const std::string& name,
-                                   const octave_value& fcn,
-                                   scope_id scope)
+  void install_subfunction (const std::string& name,
+                            const octave_value& fcn,
+                            scope_id parent_scope)
   {
-    fcn_table_iterator p = fcn_table.find (name);
-
-    if (p != fcn_table.end ())
-      {
-        fcn_info& finfo = p->second;
-
-        finfo.install_subfunction (fcn, scope);
-      }
-    else
-      {
-        fcn_info finfo (name);
-
-        finfo.install_subfunction (fcn, scope);
-
-        fcn_table[name] = finfo;
-      }
+    scope *s = get_scope (parent_scope);
+
+    if (s)
+      s->install_subfunction (name, fcn);
   }
 
-  static void install_nestfunction (const std::string& name,
-                                    const octave_value& fcn,
-                                    scope_id parent_scope);
-
-  static void update_nest (scope_id scope)
+  void install_nestfunction (const std::string& name,
+                             const octave_value& fcn,
+                             scope_id parent_scope)
   {
-    symbol_table *inst = get_instance (scope);
-    if (inst)
-      inst->do_update_nest ();
+    scope *s = get_scope (parent_scope);
+
+    if (s)
+      s->install_subfunction (name, fcn, true);
+  }
+
+  void update_nest (scope_id sid)
+  {
+    scope *s = get_scope (sid);
+
+    if (s)
+      s->update_nest ();
   }
 
   // Install local function FCN named NAME.  FILE_NAME is the name of
   // the file containing the local function.
 
-  static void install_local_function (const std::string& name,
-                                      const octave_value& fcn,
-                                      const std::string& file_name)
+  void install_local_function (const std::string& name,
+                               const octave_value& fcn,
+                               const std::string& file_name)
   {
-    fcn_table_iterator p = fcn_table.find (name);
-
-    if (p != fcn_table.end ())
+    fcn_table_iterator p = m_fcn_table.find (name);
+
+    if (p != m_fcn_table.end ())
       {
         fcn_info& finfo = p->second;
 
         finfo.install_local_function (fcn, file_name);
       }
     else
       {
         fcn_info finfo (name);
 
         finfo.install_local_function (fcn, file_name);
 
-        fcn_table[name] = finfo;
+        m_fcn_table[name] = finfo;
       }
   }
 
-  static void install_user_function (const std::string& name,
-                                     const octave_value& fcn)
+  void install_user_function (const std::string& name,
+                              const octave_value& fcn)
   {
-    fcn_table_iterator p = fcn_table.find (name);
-
-    if (p != fcn_table.end ())
+    fcn_table_iterator p = m_fcn_table.find (name);
+
+    if (p != m_fcn_table.end ())
       {
         fcn_info& finfo = p->second;
 
         finfo.install_user_function (fcn);
       }
     else
       {
         fcn_info finfo (name);
 
         finfo.install_user_function (fcn);
 
-        fcn_table[name] = finfo;
+        m_fcn_table[name] = finfo;
       }
   }
 
-  static void install_built_in_function (const std::string& name,
-                                         const octave_value& fcn)
+  void install_built_in_function (const std::string& name,
+                                  const octave_value& fcn)
   {
-    fcn_table_iterator p = fcn_table.find (name);
-
-    if (p != fcn_table.end ())
+    fcn_table_iterator p = m_fcn_table.find (name);
+
+    if (p != m_fcn_table.end ())
       {
         fcn_info& finfo = p->second;
 
         finfo.install_built_in_function (fcn);
       }
     else
       {
         fcn_info finfo (name);
 
         finfo.install_built_in_function (fcn);
 
-        fcn_table[name] = finfo;
+        m_fcn_table[name] = finfo;
       }
   }
 
-  static void clear (const std::string& name)
+  void clear (const std::string& name)
   {
     clear_variable (name);
   }
 
-  static void clear_all (bool force = false)
+  void clear_all (bool force = false)
   {
     clear_variables ();
 
     clear_global_pattern ("*");
 
     clear_functions (force);
   }
 
   // This is written as two separate functions instead of a single
   // function with default values so that it will work properly with
   // unwind_protect.
 
-  static void clear_variables (scope_id scope)
+  void clear_variables (scope_id sid)
   {
-    symbol_table *inst = get_instance (scope);
-
-    if (inst)
-      inst->do_clear_variables ();
+    scope *s = get_scope (sid);
+
+    if (s)
+      s->clear_variables ();
   }
 
-  static void clear_variables (void)
+  void clear_variables (void)
   {
-    clear_variables (xcurrent_scope);
+    clear_variables (m_current_scope);
   }
 
-  static void clear_objects (scope_id scope = xcurrent_scope)
+  void clear_objects (void)
   {
-    symbol_table *inst = get_instance (scope);
-
-    if (inst)
-      inst->do_clear_objects ();
+    scope *s = get_scope (m_current_scope);
+
+    if (s)
+      s->clear_objects ();
   }
 
-  static void clear_functions (bool force = false)
+  void clear_functions (bool force = false)
   {
-    for (auto& nm_finfo : fcn_table)
-      nm_finfo.second.clear (force);
+    fcn_table_iterator p = m_fcn_table.begin ();
+
+    while (p != m_fcn_table.end ())
+      (p++)->second.clear (force);
   }
 
-  static void clear_function (const std::string& name)
+  void clear_function (const std::string& name)
   {
     clear_user_function (name);
   }
 
-  static void clear_global (const std::string& name,
-                            scope_id scope = xcurrent_scope)
+  void clear_global (const std::string& name)
   {
-    symbol_table *inst = get_instance (scope);
-
-    if (inst)
-      inst->do_clear_global (name);
+    scope *s = get_scope (m_current_scope);
+
+    if (s)
+      s->clear_global (name);
   }
 
-  static void clear_variable (const std::string& name,
-                              scope_id scope = xcurrent_scope)
+  void clear_variable (const std::string& name)
   {
-    symbol_table *inst = get_instance (scope);
-
-    if (inst)
-      inst->do_clear_variable (name);
+    scope *s = get_scope (m_current_scope);
+
+    if (s)
+      s->clear_variable (name);
   }
 
-  static void clear_symbol (const std::string& name)
+  void clear_symbol (const std::string& name)
   {
     // FIXME: are we supposed to do both here?
 
     clear_variable (name);
     clear_function (name);
   }
 
-  static void clear_function_pattern (const std::string& pat)
+  void clear_function_pattern (const std::string& pat)
   {
     glob_match pattern (pat);
 
-    for (auto& nm_finfo : fcn_table)
+    fcn_table_iterator p = m_fcn_table.begin ();
+
+    while (p != m_fcn_table.end ())
       {
-        if (pattern.match (nm_finfo.first))
-          nm_finfo.second.clear_user_function ();
+        if (pattern.match (p->first))
+          (p++)->second.clear_user_function ();
+        else
+          p++;
       }
   }
 
-  static void clear_global_pattern (const std::string& pat,
-                                    scope_id scope = xcurrent_scope)
+  void clear_global_pattern (const std::string& pat)
   {
-    symbol_table *inst = get_instance (scope);
-
-    if (inst)
-      inst->do_clear_global_pattern (pat);
+    scope *s = get_scope (m_current_scope);
+
+    if (s)
+      s->clear_global_pattern (pat);
   }
 
-  static void clear_variable_pattern (const std::string& pat,
-                                      scope_id scope = xcurrent_scope)
+  void clear_variable_pattern (const std::string& pat)
   {
-    symbol_table *inst = get_instance (scope);
-
-    if (inst)
-      inst->do_clear_variable_pattern (pat);
+    scope *s = get_scope (m_current_scope);
+
+    if (s)
+      s->clear_variable_pattern (pat);
   }
 
-  static void clear_variable_regexp (const std::string& pat,
-                                     scope_id scope = xcurrent_scope)
+  void clear_variable_regexp (const std::string& pat)
   {
-    symbol_table *inst = get_instance (scope);
-
-    if (inst)
-      inst->do_clear_variable_regexp (pat);
+    scope *s = get_scope (m_current_scope);
+
+    if (s)
+      s->clear_variable_regexp (pat);
   }
 
-  static void clear_symbol_pattern (const std::string& pat)
+  void clear_symbol_pattern (const std::string& pat)
   {
     // FIXME: are we supposed to do both here?
 
     clear_variable_pattern (pat);
     clear_function_pattern (pat);
   }
 
-  static void clear_user_function (const std::string& name)
+  void clear_user_function (const std::string& name)
   {
-    fcn_table_iterator p = fcn_table.find (name);
-
-    if (p != fcn_table.end ())
+    fcn_table_iterator p = m_fcn_table.find (name);
+
+    if (p != m_fcn_table.end ())
       {
         fcn_info& finfo = p->second;
 
         finfo.clear_user_function ();
       }
     // FIXME: is this necessary, or even useful?
     // else
     //   error ("clear: no such function '%s'", name.c_str ());
   }
 
   // This clears oct and mex files, including autoloads.
-  static void clear_dld_function (const std::string& name)
+  void clear_dld_function (const std::string& name)
   {
-    fcn_table_iterator p = fcn_table.find (name);
-
-    if (p != fcn_table.end ())
+    fcn_table_iterator p = m_fcn_table.find (name);
+
+    if (p != m_fcn_table.end ())
       {
         fcn_info& finfo = p->second;
 
         finfo.clear_autoload_function ();
         finfo.clear_user_function ();
       }
   }
 
-  static void clear_mex_functions (void)
+  void clear_mex_functions (void)
   {
-    for (auto& nm_finfo : fcn_table)
-      nm_finfo.second.clear_mex_function ();
+    fcn_table_iterator p = m_fcn_table.begin ();
+
+    while (p != m_fcn_table.end ())
+      (p++)->second.clear_mex_function ();
   }
 
-  static bool set_class_relationship (const std::string& sup_class,
-                                      const std::string& inf_class);
-
-  static bool is_superiorto (const std::string& a, const std::string& b);
-
-  static void alias_built_in_function (const std::string& alias,
-                                       const std::string& name)
+  bool set_class_relationship (const std::string& sup_class,
+                               const std::string& inf_class);
+
+  bool is_superiorto (const std::string& a, const std::string& b);
+
+  void alias_built_in_function (const std::string& alias,
+                                const std::string& name)
   {
     octave_value fcn = find_built_in_function (name);
 
     if (fcn.is_defined ())
       {
         fcn_info finfo (alias);
 
         finfo.install_built_in_function (fcn);
 
-        fcn_table[alias] = finfo;
+        m_fcn_table[alias] = finfo;
       }
     else
       panic ("alias: '%s' is undefined", name.c_str ());
   }
 
-  static void install_built_in_dispatch (const std::string& name,
-                                         const std::string& klass)
+  void install_built_in_dispatch (const std::string& name,
+                                  const std::string& klass)
   {
-    fcn_table_iterator p = fcn_table.find (name);
-
-    if (p != fcn_table.end ())
+    fcn_table_iterator p = m_fcn_table.find (name);
+
+    if (p != m_fcn_table.end ())
       {
         fcn_info& finfo = p->second;
 
         finfo.install_built_in_dispatch (klass);
       }
     else
       error ("install_built_in_dispatch: '%s' is undefined", name.c_str ());
   }
 
-  static void push_context (scope_id scope = xcurrent_scope)
+  void push_context (void)
   {
-    if (scope == xglobal_scope || scope == xtop_scope)
+    if (m_current_scope == xtop_scope)
       error ("invalid call to symtab::push_context");
 
-    symbol_table *inst = get_instance (scope);
-
-    if (inst)
-      inst->do_push_context ();
+    scope *s = get_scope (m_current_scope);
+
+    if (s)
+      s->push_context ();
   }
 
   // This is written as two separate functions instead of a single
   // function with default values so that it will work properly with
   // unwind_protect.
 
-  static void pop_context (scope_id scope)
+  void pop_context (void)
   {
-    if (scope == xglobal_scope || scope == xtop_scope)
+    if (m_current_scope == xtop_scope)
       error ("invalid call to symtab::pop_context");
 
-    symbol_table *inst = get_instance (scope);
-
-    if (inst)
-      inst->do_pop_context ();
+    scope *s = get_scope (m_current_scope);
+
+    if (s)
+      s->pop_context ();
   }
 
-  static void pop_context (void) { pop_context (xcurrent_scope); }
-
   // For unwind_protect where a pointer argument is needed.
 
-  static void pop_context (void *) { pop_context (); }
-
-  static void mark_automatic (const std::string& name,
-                              scope_id scope = xcurrent_scope)
+  void pop_context (void *) { pop_context (); }
+
+  void mark_automatic (const std::string& name)
   {
-    symbol_table *inst = get_instance (scope);
-
-    if (inst)
-      inst->do_mark_automatic (name);
+    scope *s = get_scope (m_current_scope);
+
+    if (s)
+      s->mark_automatic (name);
   }
 
-  static void mark_hidden (const std::string& name,
-                           scope_id scope = xcurrent_scope)
+  void mark_hidden (const std::string& name)
   {
-    symbol_table *inst = get_instance (scope);
-
-    if (inst)
-      inst->do_mark_hidden (name);
+    scope *s = get_scope (m_current_scope);
+
+    if (s)
+      s->mark_hidden (name);
   }
 
-  static void mark_global (const std::string& name,
-                           scope_id scope = xcurrent_scope)
+  void mark_global (const std::string& name)
   {
-    symbol_table *inst = get_instance (scope);
-
-    if (inst)
-      inst->do_mark_global (name);
+    scope *s = get_scope (m_current_scope);
+
+    if (s)
+      s->mark_global (name);
   }
 
   // exclude: Storage classes to exclude, you can OR them together
-  static std::list<symbol_record>
-  all_variables (scope_id scope = xcurrent_scope,
-                 context_id context = xdefault_context,
-                 bool defined_only = true,
-                 unsigned int exclude = symbol_record::hidden)
+  std::list<symbol_record>
+  all_variables (scope_id sid, context_id context, bool defined_only,
+                 unsigned int exclude)
+  {
+    scope *s = get_scope (sid);
+
+    return (s
+            ? s->all_variables (context, defined_only, exclude)
+            : std::list<symbol_record> ());
+  }
+
+  std::list<symbol_record>
+  all_variables (scope_id sid, context_id context, bool defined_only)
   {
-    symbol_table *inst = get_instance (scope);
-
-    return inst
-           ? inst->do_all_variables (context, defined_only, exclude)
-           : std::list<symbol_record> ();
+    return all_variables (sid, context, defined_only, symbol_record::hidden);
   }
 
-  static std::list<symbol_record> glob (const std::string& pattern,
-                                        scope_id scope = xcurrent_scope)
+  std::list<symbol_record>
+  all_variables (scope_id sid, context_id context)
   {
-    symbol_table *inst = get_instance (scope);
-
-    return inst ? inst->do_glob (pattern) : std::list<symbol_record> ();
+    return all_variables (sid, context, true);
+  }
+
+  std::list<symbol_record>
+  all_variables (scope_id sid)
+  {
+    return all_variables (sid, xdefault_context);
   }
 
-  static std::list<symbol_record> regexp (const std::string& pattern,
-                                          scope_id scope = xcurrent_scope)
+  std::list<symbol_record>
+  all_variables (void)
   {
-    symbol_table *inst = get_instance (scope);
-
-    return inst ? inst->do_regexp (pattern) : std::list<symbol_record> ();
+    return all_variables (m_current_scope);
   }
 
-  static std::list<symbol_record> glob_variables (const std::string& pattern,
-                                                  scope_id scope = xcurrent_scope)
+  std::list<symbol_record> glob (const std::string& pattern)
+  {
+    scope *s = get_scope (m_current_scope);
+
+    return s ? s->glob (pattern) : std::list<symbol_record> ();
+  }
+
+  std::list<symbol_record> regexp (const std::string& pattern)
   {
-    symbol_table *inst = get_instance (scope);
-
-    return inst ? inst->do_glob (pattern, true) : std::list<symbol_record> ();
+    scope *s = get_scope (m_current_scope);
+
+    return s ? s->regexp (pattern) : std::list<symbol_record> ();
   }
 
-  static std::list<symbol_record> regexp_variables (const std::string& pattern,
-                                                    scope_id scope = xcurrent_scope)
+  std::list<symbol_record> glob_variables (const std::string& pattern)
   {
-    symbol_table *inst = get_instance (scope);
-
-    return inst ? inst->do_regexp (pattern, true) : std::list<symbol_record> ();
+    scope *s = get_scope (m_current_scope);
+
+    return s ? s->glob (pattern, true) : std::list<symbol_record> ();
   }
 
-  static std::list<symbol_record>
+  std::list<symbol_record> regexp_variables (const std::string& pattern)
+  {
+    scope *s = get_scope (m_current_scope);
+
+    return s ? s->regexp (pattern, true) : std::list<symbol_record> ();
+  }
+
+  std::list<symbol_record>
   glob_global_variables (const std::string& pattern)
   {
     std::list<symbol_record> retval;
 
     glob_match pat (pattern);
 
-    for (const auto& nm_val : global_table)
+    for (const auto& nm_val : m_global_symbols)
       {
         // We generate a list of symbol_record objects so that the results from
         // glob_variables and glob_global_variables may be handled the same
         // way.
         if (pat.match (nm_val.first))
           retval.push_back (symbol_record (xglobal_scope,
                                            nm_val.first, nm_val.second,
                                            symbol_record::global));
       }
 
     return retval;
   }
 
-  static std::list<symbol_record>
+  std::list<symbol_record>
   regexp_global_variables (const std::string& pattern)
   {
     std::list<symbol_record> retval;
 
     octave::regexp pat (pattern);
 
-    for (const auto& nm_val : global_table)
+    for (const auto& nm_val : m_global_symbols)
       {
         // We generate a list of symbol_record objects so that the results from
         // regexp_variables and regexp_global_variables may be handled the same
         // way.
         if (pat.is_match (nm_val.first))
           retval.push_back (symbol_record (xglobal_scope,
                                            nm_val.first, nm_val.second,
                                            symbol_record::global));
       }
 
     return retval;
   }
 
-  static std::list<symbol_record> glob_variables (const string_vector& patterns)
+  std::list<symbol_record> glob_variables (const string_vector& patterns)
   {
     std::list<symbol_record> retval;
 
     size_t len = patterns.numel ();
 
     for (size_t i = 0; i < len; i++)
       {
         std::list<symbol_record> tmp = glob_variables (patterns[i]);
 
         retval.insert (retval.begin (), tmp.begin (), tmp.end ());
       }
 
     return retval;
   }
 
-  static std::list<symbol_record> regexp_variables
-    (const string_vector& patterns)
+  std::list<symbol_record> regexp_variables (const string_vector& patterns)
   {
     std::list<symbol_record> retval;
 
     size_t len = patterns.numel ();
 
     for (size_t i = 0; i < len; i++)
       {
         std::list<symbol_record> tmp = regexp_variables (patterns[i]);
 
         retval.insert (retval.begin (), tmp.begin (), tmp.end ());
       }
 
     return retval;
   }
 
-  static std::list<std::string> user_function_names (void)
+  std::list<std::string> user_function_names (void)
   {
     std::list<std::string> retval;
 
-    for (const auto& nm_finfo : fcn_table)
+    for (const auto& nm_finfo : m_fcn_table)
       {
         if (nm_finfo.second.is_user_function_defined ())
           retval.push_back (nm_finfo.first);
       }
 
     if (! retval.empty ())
       retval.sort ();
 
     return retval;
   }
 
-  static std::list<std::string> global_variable_names (void)
+  std::list<std::string> global_variable_names (void)
   {
     std::list<std::string> retval;
 
-    for (const auto& nm_val : global_table)
+    for (const auto& nm_val : m_global_symbols)
       retval.push_back (nm_val.first);
 
     retval.sort ();
 
     return retval;
   }
 
-  static std::list<std::string> top_level_variable_names (void)
+  std::list<std::string> top_level_variable_names (void)
   {
-    symbol_table *inst = get_instance (xtop_scope);
-
-    return inst ? inst->do_variable_names () : std::list<std::string> ();
+    scope *s = get_scope (xtop_scope);
+
+    return s ? s->variable_names () : std::list<std::string> ();
   }
 
-  static std::list<std::string> variable_names (scope_id scope = xcurrent_scope)
+  std::list<std::string> variable_names (void)
   {
-    symbol_table *inst = get_instance (scope);
-
-    return inst ? inst->do_variable_names () : std::list<std::string> ();
+    scope *s = get_scope (m_current_scope);
+
+    return s ? s->variable_names () : std::list<std::string> ();
   }
 
-  static std::list<std::string> built_in_function_names (void)
+  std::list<std::string> built_in_function_names (void)
   {
     std::list<std::string> retval;
 
-    for (const auto& nm_finfo : fcn_table)
+    for (const auto& nm_finfo : m_fcn_table)
       {
         octave_value fcn = nm_finfo.second.find_built_in_function ();
 
         if (fcn.is_defined ())
           retval.push_back (nm_finfo.first);
       }
 
     if (! retval.empty ())
       retval.sort ();
 
     return retval;
   }
 
-  static std::list<std::string> cmdline_function_names (void)
+  std::list<std::string> cmdline_function_names (void)
   {
     std::list<std::string> retval;
 
-    for (const auto& nm_finfo : fcn_table)
+    for (const auto& nm_finfo : m_fcn_table)
       {
         octave_value fcn = nm_finfo.second.find_cmdline_function ();
 
         if (fcn.is_defined ())
           retval.push_back (nm_finfo.first);
       }
 
     if (! retval.empty ())
       retval.sort ();
 
     return retval;
   }
 
-  static bool is_local_variable (const std::string& name,
-                                 scope_id scope = xcurrent_scope)
+  bool is_local_variable (const std::string& name)
   {
-    if (scope == xglobal_scope)
-      return false;
-    else
-      {
-        symbol_table *inst = get_instance (scope);
-
-        return inst ? inst->do_is_local_variable (name) : false;
-      }
+    scope *s = get_scope (m_current_scope);
+
+    return s ? s->is_local_variable (name) : false;
   }
 
-  static bool is_global (const std::string& name,
-                         scope_id scope = xcurrent_scope)
+  bool is_global (const std::string& name)
+  {
+    scope *s = get_scope (m_current_scope);
+
+    return s ? s->is_global (name) : false;
+  }
+
+  std::list<workspace_element> workspace_info (void)
   {
-    if (scope == xglobal_scope)
-      return true;
-    else
-      {
-        symbol_table *inst = get_instance (scope);
-
-        return inst ? inst->do_is_global (name) : false;
-      }
+    scope *s = get_scope (m_current_scope);
+
+    return s ? s->workspace_info () : std::list<workspace_element> ();
   }
 
-  static std::list<workspace_element> workspace_info (scope_id scope = xcurrent_scope)
+  void dump (std::ostream& os, scope_id sid);
+
+  void dump_global (std::ostream& os);
+
+  void dump_functions (std::ostream& os);
+
+  void cache_name (scope_id sid, const std::string& name)
   {
-    symbol_table *inst = get_instance (scope);
-
-    return inst
-           ? inst->do_workspace_info () : std::list<workspace_element> ();
+    scope *s = get_scope (sid, false);
+
+    if (s)
+      s->cache_name (name);
   }
 
-  static void dump (std::ostream& os, scope_id scope = xcurrent_scope);
-
-  static void dump_global (std::ostream& os);
-
-  static void dump_functions (std::ostream& os);
-
-  static void cache_name (scope_id scope, const std::string& name)
+  void lock_subfunctions (scope_id sid)
   {
-    symbol_table *inst = get_instance (scope, false);
-
-    if (inst)
-      inst->do_cache_name (name);
+    scope *s = get_scope (sid);
+
+    if (s)
+      s->lock_subfunctions ();
   }
 
-  static void lock_subfunctions (scope_id scope = xcurrent_scope)
+  void unlock_subfunctions (scope_id sid)
   {
-    for (auto& nm_finfo : fcn_table)
-      nm_finfo.second.lock_subfunction (scope);
+    scope *s = get_scope (sid);
+
+    if (s)
+      s->unlock_subfunctions ();
   }
 
-  static void unlock_subfunctions (scope_id scope = xcurrent_scope)
+  std::map<std::string, octave_value>
+  subfunctions_defined_in_scope (scope_id sid)
   {
-    for (auto& nm_finfo : fcn_table)
-      nm_finfo.second.unlock_subfunction (scope);
+    scope *s = get_scope (sid);
+
+    return (s
+            ? s->subfunctions ()
+            : std::map<std::string, octave_value> ());
   }
 
-  static std::map<std::string, octave_value>
-  subfunctions_defined_in_scope (scope_id scope = xcurrent_scope)
+  void free_scope (scope_id sid)
   {
-    std::map<std::string, octave_value> retval;
-
-    for (const auto& nm_finfo : fcn_table)
-      {
-        std::pair<std::string, octave_value> tmp
-          = nm_finfo.second.subfunction_defined_in_scope (scope);
-
-        std::string nm = tmp.first;
-
-        if (! nm.empty ())
-          retval[nm] = tmp.second;
-      }
-
-    return retval;
+    if (sid == xglobal_scope || sid == xtop_scope)
+      error ("can't free global or top-level scopes!");
+
+    m_scope_id_cache.free (sid);
+  }
+
+  void stash_dir_name_for_subfunctions (scope_id sid,
+                                        const std::string& dir_name)
+  {
+    scope *s = get_scope (sid);
+
+    if (s)
+      s->stash_dir_name_for_subfunctions (dir_name);
   }
 
-  static void free_scope (scope_id scope)
+  void set_parent (scope_id child_scope_id, scope_id parent_scope_id)
   {
-    if (scope == xglobal_scope || scope == xtop_scope)
-      error ("can't free global or top-level scopes!");
-
-    symbol_table::scope_id_cache::free (scope);
+    scope *child_scope = get_scope (child_scope_id);
+
+    if (child_scope)
+      child_scope->set_parent (get_scope (parent_scope_id));
   }
 
-  static void stash_dir_name_for_subfunctions (scope_id scope,
-                                               const std::string& dir_name);
-
-  static void add_to_parent_map (const std::string& classname,
-                                 const std::list<std::string>& parent_list)
+  void add_to_parent_map (const std::string& classname,
+                          const std::list<std::string>& parent_list)
   {
-    parent_map[classname] = parent_list;
+    m_parent_map[classname] = parent_list;
   }
 
-  static std::list<std::string>
+  std::list<std::string>
   parent_classes (const std::string& dispatch_type)
   {
     std::list<std::string> retval;
 
-    const_parent_map_iterator it = parent_map.find (dispatch_type);
-
-    if (it != parent_map.end ())
+    const_parent_map_iterator it = m_parent_map.find (dispatch_type);
+
+    if (it != m_parent_map.end ())
       retval = it->second;
 
     for (const auto& nm : retval)
       {
         // Search for parents of parents and append them to the list.
 
         // FIXME: should we worry about a circular inheritance graph?
 
@@ -2230,647 +2113,702 @@ public:
 
         if (! parents.empty ())
           retval.insert (retval.end (), parents.begin (), parents.end ());
       }
 
     return retval;
   }
 
-  static octave_user_function * get_curr_fcn (scope_id scope = xcurrent_scope)
+  OCTAVE_DEPRECATED ("use 'get_scope' with 'get_curr_fcn (name)' instead")
+  octave_user_function * get_curr_fcn (scope_id sid)
   {
-    symbol_table *inst = get_instance (scope);
-    return inst->curr_fcn;
+    scope *s = get_scope (sid);
+    return s->function ();
   }
 
-  static void set_curr_fcn (octave_user_function *curr_fcn,
-                            scope_id scope = xcurrent_scope)
+  octave_user_function * get_curr_fcn (void)
   {
-    assert (scope != xtop_scope && scope != xglobal_scope);
-    symbol_table *inst = get_instance (scope);
+    scope *s = get_scope (m_current_scope);
+    return s->function ();
+  }
+
+  OCTAVE_DEPRECATED ("set_curr_fcn")
+  void set_curr_fcn (octave_user_function *curr_fcn, scope_id sid)
+  {
+    assert (sid != xtop_scope && sid != xglobal_scope);
+    scope *s = get_scope (sid);
     // FIXME: normally, functions should not usurp each other's scope.
     // If for any incredible reason this is needed, call
     // set_user_function (0, scope) first.  This may cause problems with
     // nested functions, as the curr_fcn of symbol_records must be updated.
-    assert (inst->curr_fcn == 0 || curr_fcn == 0);
-    inst->curr_fcn = curr_fcn;
+    assert (s->function () == 0 || curr_fcn == 0);
+    s->set_function (curr_fcn);
+  }
+
+  scope * get_scope (scope_id sid, bool create = true)
+  {
+    scope *retval = nullptr;
+
+    bool ok = true;
+
+    if (sid == xglobal_scope)
+      error ("can't get global scope");
+
+    all_scopes_iterator p = m_all_scopes.find (sid);
+
+    if (p == m_all_scopes.end ())
+      {
+        if (create)
+          {
+            retval = new scope (sid);
+
+            if (retval)
+              {
+                m_all_scopes[sid] = retval;
+
+                if (sid == xtop_scope)
+                  retval->cache_name ("top-level");
+              }
+            else
+              ok = false;
+          }
+        else
+          ok = false;
+      }
+    else
+      retval = p->second;
+
+    if (! ok)
+      error ("unable to %s scope object for scope id %d!",
+             create ? "create" : "find", sid);
+
+    return retval;
   }
 
-  static void cleanup (void);
+  void cleanup (void);
+
+  class scope
+  {
+  public:
+
+    typedef std::map<std::string, symbol_table::symbol_record>::const_iterator
+      table_const_iterator;
+    typedef std::map<std::string, symbol_table::symbol_record>::iterator
+      table_iterator;
+
+    typedef std::map<std::string, octave_value>::const_iterator
+      m_persistent_symbols_const_iterator;
+    typedef std::map<std::string, octave_value>::iterator
+      m_persistent_symbols_iterator;
+
+    typedef std::map<std::string, octave_value>::const_iterator
+      subfunctions_const_iterator;
+    typedef std::map<std::string, octave_value>::iterator subfunctions_iterator;
+
+    scope (scope_id sid)
+      : m_scope (sid), m_name (), m_symbols (), m_children (),
+        m_subfunctions (), m_parent (0), m_fcn (0), m_is_nested (false),
+        m_is_static (false), m_persistent_symbols ()
+    { }
+
+    // No copying!
+
+    scope (const scope&) = delete;
+
+    scope& operator = (const scope&) = delete;
+
+    ~scope (void) = default;
+
+    void insert_symbol_record (const symbol_table::symbol_record& sr)
+    {
+      m_symbols[sr.name ()] = sr;
+    }
+
+    bool is_nested (void) const { return m_is_nested; }
+
+    void mark_nested (void) { m_is_nested = true; }
+
+    scope_id parent_scope_id (void) const
+    {
+      return m_parent ? m_parent->m_scope : -1;
+    }
+
+    scope * dup (scope_id new_sid) const
+    {
+      scope *new_scope = new scope (new_sid);
+
+      for (const auto& nm_sr : m_symbols)
+        new_scope->insert_symbol_record (nm_sr.second.dup (new_sid));
+
+      new_scope->m_parent = m_parent;
+
+      return new_scope;
+    }
+
+    symbol_table::symbol_record find_symbol (const std::string& name)
+    {
+      table_iterator p = m_symbols.find (name);
+
+      if (p == m_symbols.end ())
+        return insert (name);
+      else
+        return p->second;
+    }
+
+    void inherit (scope& donor_table, context_id donor_context)
+    {
+      for (auto& nm_sr : m_symbols)
+        {
+          symbol_table::symbol_record& sr = nm_sr.second;
+
+          if (! (sr.is_automatic () || sr.is_formal ()))
+            {
+              std::string nm = sr.name ();
+
+              if (nm != "__retval__")
+                {
+                  octave_value val = donor_table.varval (nm, donor_context);
+
+                  if (val.is_defined ())
+                    {
+                      sr.assign (val, 0);
+
+                      sr.mark_inherited ();
+                    }
+                }
+            }
+        }
+    }
+
+    octave_value
+    find (const std::string& name, const octave_value_list& args,
+          bool skip_variables, bool local_funcs);
+
+    octave_value builtin_find (const std::string& name);
+
+    symbol_table::symbol_record&
+    insert (const std::string& name, bool force_add = false)
+    {
+      table_iterator p = m_symbols.find (name);
+
+      if (p == m_symbols.end ())
+        {
+          symbol_table::symbol_record ret (m_scope, name);
+
+          if (m_is_nested && m_parent && m_parent->look_nonlocal (name, ret))
+            return m_symbols[name] = ret;
+          else
+            {
+              if (m_is_static && ! force_add)
+                ret.mark_added_static ();
+
+              return m_symbols[name] = ret;
+            }
+        }
+      else
+        return p->second;
+    }
+
+    void rename (const std::string& old_name, const std::string& new_name)
+    {
+      table_iterator p = m_symbols.find (old_name);
+
+      if (p != m_symbols.end ())
+        {
+          symbol_table::symbol_record sr = p->second;
+
+          sr.rename (new_name);
+
+          m_symbols.erase (p);
+
+          m_symbols[new_name] = sr;
+        }
+    }
+
+    void assign (const std::string& name, const octave_value& value,
+                 context_id context, bool force_add)
+    {
+      table_iterator p = m_symbols.find (name);
+
+      if (p == m_symbols.end ())
+        {
+          symbol_table::symbol_record& sr = insert (name, force_add);
+
+          sr.assign (value, context);
+        }
+      else
+        p->second.assign (value, context);
+    }
+
+    void assign (const std::string& name,
+                 const octave_value& value = octave_value ())
+    {
+      table_iterator p = m_symbols.find (name);
+
+      if (p == m_symbols.end ())
+        {
+          symbol_table::symbol_record& sr = insert (name, false);
+
+          sr.assign (value);
+        }
+      else
+        p->second.assign (value);
+    }
+
+    void force_assign (const std::string& name, const octave_value& value)
+    {
+      table_iterator p = m_symbols.find (name);
+
+      if (p == m_symbols.end ())
+        {
+          symbol_table::symbol_record& sr = insert (name, true);
+
+          sr.assign (value);
+        }
+      else
+        p->second.assign (value);
+    }
+
+    // Use assign (name, value, context, force_add) instead.
+    // Delete when deprecated varref functions are removed.
+    octave_value&
+    varref (const std::string& name, context_id context, bool force_add)
+    {
+      table_iterator p = m_symbols.find (name);
+
+      if (p == m_symbols.end ())
+        {
+          symbol_table::symbol_record& sr = insert (name, force_add);
+
+          return sr.varref (context);
+        }
+      else
+        return p->second.varref (context);
+    }
+
+    octave_value varval (const std::string& name, context_id context) const
+    {
+      table_const_iterator p = m_symbols.find (name);
+
+      return (p != m_symbols.end ()
+              ? p->second.varval (context) : octave_value ());
+    }
+
+    octave_value varval (const std::string& name) const
+    {
+      table_const_iterator p = m_symbols.find (name);
+
+      return p != m_symbols.end () ? p->second.varval () : octave_value ();
+    }
+
+    void persistent_assign (const std::string& name, const octave_value& value)
+    {
+      m_persistent_symbols_iterator p = m_persistent_symbols.find (name);
+
+      if (p == m_persistent_symbols.end ())
+        m_persistent_symbols[name] = value;
+      else
+        p->second = value;
+    }
+
+    // Use persistent_assign (name, value) instead.
+    // Delete when deprecated varref functions are removed.
+    octave_value& persistent_varref (const std::string& name)
+    {
+      m_persistent_symbols_iterator p = m_persistent_symbols.find (name);
+
+      return (p == m_persistent_symbols.end ()
+              ? m_persistent_symbols[name] : p->second);
+    }
+
+    octave_value persistent_varval (const std::string& name)
+    {
+      m_persistent_symbols_const_iterator p = m_persistent_symbols.find (name);
+
+      return (p != m_persistent_symbols.end ()) ? p->second : octave_value ();
+    }
+
+    void erase_persistent (const std::string& name)
+    {
+      m_persistent_symbols_iterator p = m_persistent_symbols.find (name);
+
+      if (p != m_persistent_symbols.end ())
+        m_persistent_symbols.erase (p);
+    }
+
+    bool is_variable (const std::string& name) const
+    {
+      bool retval = false;
+
+      table_const_iterator p = m_symbols.find (name);
+
+      if (p != m_symbols.end ())
+        {
+          const symbol_table::symbol_record& sr = p->second;
+
+          retval = sr.is_variable ();
+        }
+
+      return retval;
+    }
+
+    void push_context (void)
+    {
+      for (auto& nm_sr : m_symbols)
+        nm_sr.second.push_context (m_scope);
+    }
+
+    void pop_context (void)
+    {
+      table_iterator tbl_it = m_symbols.begin ();
+
+      while (tbl_it != m_symbols.end ())
+        {
+          if (tbl_it->second.pop_context (m_scope) == 0)
+            m_symbols.erase (tbl_it++);
+          else
+            tbl_it++;
+        }
+    }
+
+    void clear_variables (void)
+    {
+      for (auto& nm_sr : m_symbols)
+        nm_sr.second.clear (m_scope);
+    }
+
+    void clear_objects (void)
+    {
+      for (auto& nm_sr : m_symbols)
+        {
+          symbol_table::symbol_record& sr = nm_sr.second;
+          octave_value val = sr.varval ();
+          if (val.is_object ())
+            nm_sr.second.clear (m_scope);
+        }
+    }
+
+    void clear_global (const std::string& name);
+
+    void clear_variable (const std::string& name)
+    {
+      table_iterator p = m_symbols.find (name);
+
+      if (p != m_symbols.end ())
+        p->second.clear (m_scope);
+    }
+
+    void clear_global_pattern (const std::string& pat);
+
+    void clear_variable_pattern (const std::string& pat)
+    {
+      glob_match pattern (pat);
+
+      for (auto& nm_sr : m_symbols)
+        {
+          symbol_table::symbol_record& sr = nm_sr.second;
+
+          if (sr.is_defined () || sr.is_global ())
+            {
+              if (pattern.match (sr.name ()))
+                sr.clear (m_scope);
+            }
+        }
+    }
+
+    void clear_variable_regexp (const std::string& pat)
+    {
+      octave::regexp pattern (pat);
+
+      for (auto& nm_sr : m_symbols)
+        {
+          symbol_table::symbol_record& sr = nm_sr.second;
+
+          if (sr.is_defined () || sr.is_global ())
+            {
+              if (pattern.is_match (sr.name ()))
+                sr.clear (m_scope);
+            }
+        }
+    }
+
+    void mark_automatic (const std::string& name)
+    {
+      insert (name).mark_automatic ();
+    }
+
+    void mark_hidden (const std::string& name)
+    {
+      insert (name).mark_hidden ();
+    }
+
+    void mark_global (const std::string& name)
+    {
+      insert (name).mark_global ();
+    }
+
+    std::list<symbol_table::symbol_record>
+    all_variables (context_id context, bool defined_only,
+                   unsigned int exclude) const
+    {
+      std::list<symbol_table::symbol_record> retval;
+
+      for (const auto& nm_sr : m_symbols)
+        {
+          const symbol_table::symbol_record& sr = nm_sr.second;
+
+          if ((defined_only && ! sr.is_defined (context))
+              || (sr.xstorage_class () & exclude))
+            continue;
+
+          retval.push_back (sr);
+        }
+
+      return retval;
+    }
+
+    std::list<symbol_table::symbol_record>
+    glob (const std::string& pattern, bool vars_only = false) const
+    {
+      std::list<symbol_table::symbol_record> retval;
+
+      glob_match pat (pattern);
+
+      for (const auto& nm_sr : m_symbols)
+        {
+          if (pat.match (nm_sr.first))
+            {
+              const symbol_table::symbol_record& sr = nm_sr.second;
+
+              if (vars_only && ! sr.is_variable ())
+                continue;
+
+              retval.push_back (sr);
+            }
+        }
+
+      return retval;
+    }
+
+    std::list<symbol_table::symbol_record>
+    regexp (const std::string& pattern, bool vars_only = false) const
+    {
+      std::list<symbol_table::symbol_record> retval;
+
+      octave::regexp pat (pattern);
+
+      for (const auto& nm_sr : m_symbols)
+        {
+          if (pat.is_match (nm_sr.first))
+            {
+              const symbol_table::symbol_record& sr = nm_sr.second;
+
+              if (vars_only && ! sr.is_variable ())
+                continue;
+
+              retval.push_back (sr);
+            }
+        }
+
+      return retval;
+    }
+
+    std::list<std::string> variable_names (void)
+    {
+      std::list<std::string> retval;
+
+      for (const auto& nm_sr : m_symbols)
+        {
+          if (nm_sr.second.is_variable ())
+            retval.push_back (nm_sr.first);
+        }
+
+      retval.sort ();
+
+      return retval;
+    }
+
+    bool is_local_variable (const std::string& name) const
+    {
+      table_const_iterator p = m_symbols.find (name);
+
+      return (p != m_symbols.end ()
+              && ! p->second.is_global ()
+              && p->second.is_defined ());
+    }
+
+    bool is_global (const std::string& name) const
+    {
+      table_const_iterator p = m_symbols.find (name);
+
+      return p != m_symbols.end () && p->second.is_global ();
+    }
+
+    void install_subfunction (const std::string& name,
+                              const octave_value& fval,
+                              bool is_nested = false);
+
+    octave_value find_subfunction (const std::string& name) const;
+
+    void lock_subfunctions (void)
+    {
+      for (auto& nm_sf : m_subfunctions)
+        nm_sf.second.lock ();
+    }
+
+    void unlock_subfunctions (void)
+    {
+      for (auto& nm_sf : m_subfunctions)
+        nm_sf.second.unlock ();
+    }
+
+    std::map<std::string, octave_value> subfunctions (void)
+    {
+      return m_subfunctions;
+    }
+
+    void erase_subfunctions (void)
+    {
+      m_subfunctions.clear ();
+    }
+
+    void stash_dir_name_for_subfunctions (const std::string& dir_name);
+
+    void mark_subfunctions_in_scope_as_private (const std::string& class_name);
+
+    std::list<workspace_element> workspace_info (void) const;
+
+    void dump (std::ostream& os);
+
+    std::string name (void) const { return m_name; }
+
+    void cache_name (const std::string& name) { m_name = name; }
+
+    octave_user_function *function (void) { return m_fcn; }
+
+    void set_function (octave_user_function *fcn) { m_fcn = fcn; }
+
+    void set_parent (scope *p) { m_parent = p; }
+
+    void update_nest (void);
+
+    bool look_nonlocal (const std::string& name,
+                        symbol_table::symbol_record& result)
+    {
+      table_iterator p = m_symbols.find (name);
+      if (p == m_symbols.end ())
+        {
+          if (m_is_nested && m_parent)
+            return m_parent->look_nonlocal (name, result);
+        }
+      else if (! p->second.is_automatic ())
+        {
+          result = p->second;
+          return true;
+        }
+
+      return false;
+    }
+
+  private:
+
+    // The ID for this scope.
+    scope_id m_scope;
+
+    // Name for this scope (usually the corresponding filename of the
+    // function corresponding to the scope).
+    std::string m_name;
+
+    // Map from symbol names to symbol info.
+    std::map<std::string, symbol_table::symbol_record> m_symbols;
+
+    // Child nested functions.
+    std::vector<scope*> m_children;
+
+    // Map from symbol names to subfunctions.
+    std::map<std::string, octave_value> m_subfunctions;
+
+    // Parent of nested function (may be null).
+    scope *m_parent;
+
+    // The associated user code (may be null).
+    octave_user_function *m_fcn;
+
+    // If true, then this scope belongs to a nested function.
+    bool m_is_nested;
+
+    // If true then no variables can be added.
+    bool m_is_static;
+
+    // Map from names of persistent variables to values.
+    std::map<std::string, octave_value> m_persistent_symbols;
+  };
 
 private:
 
-  typedef std::map<std::string, symbol_record>::const_iterator
-    table_const_iterator;
-  typedef std::map<std::string, symbol_record>::iterator
-    table_iterator;
-
   typedef std::map<std::string, octave_value>::const_iterator
-    global_table_const_iterator;
-  typedef std::map<std::string, octave_value>::iterator
-    global_table_iterator;
-
-  typedef std::map<std::string, octave_value>::const_iterator
-    persistent_table_const_iterator;
+    global_symbols_const_iterator;
   typedef std::map<std::string, octave_value>::iterator
-    persistent_table_iterator;
-
-  typedef std::map<scope_id, symbol_table*>::const_iterator
-    all_instances_const_iterator;
-  typedef std::map<scope_id, symbol_table*>::iterator
-    all_instances_iterator;
+    global_symbols_iterator;
+
+  typedef std::map<scope_id, scope*>::const_iterator all_scopes_const_iterator;
+  typedef std::map<scope_id, scope*>::iterator
+    all_scopes_iterator;
 
   typedef std::map<std::string, fcn_info>::const_iterator
     fcn_table_const_iterator;
   typedef std::map<std::string, fcn_info>::iterator
     fcn_table_iterator;
 
-  // The scope of this symbol table.
-  scope_id my_scope;
-
-  // Name for this table
-  // (usually the filename of the function corresponding to the scope);
-  std::string table_name;
-
-  // Map from symbol names to symbol info.
-  std::map<std::string, symbol_record> table;
-
-  // Child nested functions.
-  std::vector<symbol_table*> nest_children;
-
-  // Parent nested function (may be null).
-  symbol_table *nest_parent;
-
-  // The associated user code (may be null).
-  octave_user_function *curr_fcn;
-
-  // If true then no variables can be added.
-  bool static_workspace;
+  scope_id_cache m_scope_id_cache;
 
   // Map from names of global variables to values.
-  static std::map<std::string, octave_value> global_table;
-
-  // Map from names of persistent variables to values.
-  std::map<std::string, octave_value> persistent_table;
-
-  // Pointer to symbol table for current scope (variables only).
-  static symbol_table *instance;
-
-  // Map from scope id to symbol table instances.
-  static std::map<scope_id, symbol_table*> all_instances;
-
-  // Map from function names to function info (subfunctions, private
+  std::map<std::string, octave_value> m_global_symbols;
+
+  // Map from scope id to symbol table scopes.
+  std::map<scope_id, scope*> m_all_scopes;
+
+  // Map from function names to function info (private
   // functions, class constructors, class methods, etc.)
-  static std::map<std::string, fcn_info> fcn_table;
-
-  // Mape from class names to set of classes that have lower
+  // Note that subfunctions are defined in the scope that contains
+  // them.
+  std::map<std::string, fcn_info> m_fcn_table;
+
+  // Map from class names to set of classes that have lower
   // precedence.
-  static std::map<std::string, std::set<std::string>> class_precedence_table;
+  std::map<std::string, std::set<std::string>> m_class_precedence_table;
 
   typedef std::map<std::string, std::set<std::string>>::const_iterator
     class_precedence_table_const_iterator;
   typedef std::map<std::string, std::set<std::string>>::iterator
     class_precedence_table_iterator;
 
   // Map from class names to parent class names.
-  static std::map<std::string, std::list<std::string>> parent_map;
+  std::map<std::string, std::list<std::string>> m_parent_map;
 
   typedef std::map<std::string, std::list<std::string>>::const_iterator
     const_parent_map_iterator;
   typedef std::map<std::string, std::list<std::string>>::iterator
     parent_map_iterator;
 
-  static const scope_id xglobal_scope;
-  static const scope_id xtop_scope;
-
-  static scope_id xcurrent_scope;
+  scope_id m_current_scope;
+
+  static const scope_id xglobal_scope = 0;
+  static const scope_id xtop_scope = 1;
+
+  static const context_id xdefault_context
+    = std::numeric_limits<context_id>::max ();
 
   static context_id xcurrent_context;
 
-  static const context_id xdefault_context = static_cast<context_id> (-1);
-
-  symbol_table (scope_id scope)
-    : my_scope (scope), table_name (), table (), nest_children (),
-      nest_parent (0), curr_fcn (0), static_workspace (false),
-      persistent_table () { }
-
-  // No copying!
-
-  symbol_table (const symbol_table&) = delete;
-
-  symbol_table& operator = (const symbol_table&) = delete;
-
-  ~symbol_table (void) = default;
-
-  static symbol_table * get_instance (scope_id scope, bool create = true)
-  {
-    symbol_table *retval = nullptr;
-
-    bool ok = true;
-
-    if (scope != xglobal_scope)
-      {
-        if (scope == xcurrent_scope)
-          {
-            if (! instance && create)
-              {
-                symbol_table *inst = new symbol_table (scope);
-
-                if (inst)
-                  {
-                    all_instances[scope] = instance = inst;
-
-                    if (scope == xtop_scope)
-                      instance->do_cache_name ("top-level");
-                  }
-              }
-
-            if (! instance)
-              ok = false;
-
-            retval = instance;
-          }
-        else
-          {
-            all_instances_iterator p = all_instances.find (scope);
-
-            if (p == all_instances.end ())
-              {
-                if (create)
-                  {
-                    retval = new symbol_table (scope);
-
-                    if (retval)
-                      all_instances[scope] = retval;
-                    else
-                      ok = false;
-                  }
-                else
-                  ok = false;
-              }
-            else
-              retval = p->second;
-          }
-      }
-
-    if (! ok)
-      error ("unable to %s symbol_table object for scope %d!",
-             create ? "create" : "find", scope);
-
-    return retval;
-  }
-
-  void add_nest_child (symbol_table& st)
-  {
-    assert (! st.nest_parent);
-    nest_children.push_back (&st);
-    st.nest_parent = this;
-  }
-
-  void insert_symbol_record (const symbol_record& sr)
-  {
-    table[sr.name ()] = sr;
-  }
-
-  void
-  do_dup_scope (symbol_table& new_symbol_table) const
-  {
-    for (const auto& nm_sr : table)
-      new_symbol_table.insert_symbol_record (nm_sr.second.dup (new_symbol_table
-                                                               .my_scope));
-  }
-
-  symbol_record do_find_symbol (const std::string& name)
-  {
-    table_iterator p = table.find (name);
-
-    if (p == table.end ())
-      return do_insert (name);
-    else
-      return p->second;
-  }
-
-  void do_inherit (symbol_table& donor_table, context_id donor_context)
-  {
-    for (auto& nm_sr : table)
-      {
-        symbol_record& sr = nm_sr.second;
-
-        if (! (sr.is_automatic () || sr.is_formal ()))
-          {
-            std::string nm = sr.name ();
-
-            if (nm != "__retval__")
-              {
-                octave_value val = donor_table.do_varval (nm, donor_context);
-
-                if (val.is_defined ())
-                  {
-                    sr.assign (val, 0);
-
-                    sr.mark_inherited ();
-                  }
-              }
-          }
-      }
-  }
-
-  static fcn_info * get_fcn_info (const std::string& name)
-  {
-    fcn_table_iterator p = fcn_table.find (name);
-    return p != fcn_table.end () ? &p->second : 0;
-  }
-
-  octave_value
-  do_find (const std::string& name, const octave_value_list& args,
-           bool skip_variables, bool local_funcs);
-
-  octave_value do_builtin_find (const std::string& name);
-
-  symbol_record& do_insert (const std::string& name, bool force_add = false)
-  {
-    table_iterator p = table.find (name);
-
-    if (p == table.end ())
-      {
-        symbol_record ret (my_scope, name);
-
-        if (nest_parent && nest_parent->look_nonlocal (name, ret))
-          return table[name] = ret;
-        else
-          {
-            if (static_workspace && ! force_add)
-              ret.mark_added_static ();
-
-            return table[name] = ret;
-          }
-      }
-    else
-      return p->second;
-  }
-
-  void do_rename (const std::string& old_name, const std::string& new_name)
-  {
-    table_iterator p = table.find (old_name);
-
-    if (p != table.end ())
-      {
-        symbol_record sr = p->second;
-
-        sr.rename (new_name);
-
-        table.erase (p);
-
-        table[new_name] = sr;
-      }
-  }
-
-  void do_assign (const std::string& name, const octave_value& value,
-                  context_id context, bool force_add)
-  {
-    table_iterator p = table.find (name);
-
-    if (p == table.end ())
-      {
-        symbol_record& sr = do_insert (name, force_add);
-
-        sr.assign (value, context);
-      }
-    else
-      p->second.assign (value, context);
-  }
-
-  // Use do_assign (name, value, context, force_add) instead.
-  // Delete when deprecated varref functions are removed.
-  octave_value& do_varref (const std::string& name, context_id context,
-                           bool force_add)
-  {
-    table_iterator p = table.find (name);
-
-    if (p == table.end ())
-      {
-        symbol_record& sr = do_insert (name, force_add);
-
-        return sr.varref (context);
-      }
-    else
-      return p->second.varref (context);
-  }
-
-  octave_value do_varval (const std::string& name, context_id context) const
-  {
-    table_const_iterator p = table.find (name);
-
-    return (p != table.end ()) ? p->second.varval (context) : octave_value ();
-  }
-
-  void do_persistent_assign (const std::string& name, const octave_value& value)
-  {
-    persistent_table_iterator p = persistent_table.find (name);
-
-    if (p == persistent_table.end ())
-      persistent_table[name] = value;
-    else
-      p->second = value;
-  }
-
-  // Use do_persistent_assign (name, value) instead.
-  // Delete when deprecated varref functions are removed.
-  octave_value& do_persistent_varref (const std::string& name)
-  {
-    persistent_table_iterator p = persistent_table.find (name);
-
-    return (p == persistent_table.end ())
-           ? persistent_table[name] : p->second;
-  }
-
-  octave_value do_persistent_varval (const std::string& name)
-  {
-    persistent_table_const_iterator p = persistent_table.find (name);
-
-    return (p != persistent_table.end ()) ? p->second : octave_value ();
-  }
-
-  void do_erase_persistent (const std::string& name)
-  {
-    persistent_table_iterator p = persistent_table.find (name);
-
-    if (p != persistent_table.end ())
-      persistent_table.erase (p);
-  }
-
-  bool do_is_variable (const std::string& name) const
+  fcn_info * get_fcn_info (const std::string& name)
   {
-    bool retval = false;
-
-    table_const_iterator p = table.find (name);
-
-    if (p != table.end ())
-      {
-        const symbol_record& sr = p->second;
-
-        retval = sr.is_variable ();
-      }
-
-    return retval;
-  }
-
-  void do_push_context (void)
-  {
-    for (auto& nm_sr : table)
-      nm_sr.second.push_context (my_scope);
-  }
-
-  void do_pop_context (void)
-  {
-    table_iterator tbl_it = table.begin ();
-
-    while (tbl_it != table.end ())
-      {
-        if (tbl_it->second.pop_context (my_scope) == 0)
-          table.erase (tbl_it++);
-        else
-          tbl_it++;
-      }
-  }
-
-  void do_clear_variables (void)
-  {
-    for (auto& nm_sr : table)
-      nm_sr.second.clear (my_scope);
-  }
-
-  void do_clear_objects (void)
-  {
-    for (auto& nm_sr : table)
-      {
-        symbol_record& sr = nm_sr.second;
-        octave_value val = sr.varval ();
-        if (val.isobject ())
-          nm_sr.second.clear (my_scope);
-      }
-  }
-
-  void do_clear_global (const std::string& name)
-  {
-    table_iterator p = table.find (name);
-
-    if (p != table.end ())
-      {
-        symbol_record& sr = p->second;
-
-        if (sr.is_global ())
-          sr.unmark_global ();
-      }
-
-    global_table_iterator q = global_table.find (name);
-
-    if (q != global_table.end ())
-      global_table.erase (q);
-
-  }
-
-  void do_clear_variable (const std::string& name)
-  {
-    table_iterator p = table.find (name);
-
-    if (p != table.end ())
-      p->second.clear (my_scope);
-  }
-
-  void do_clear_global_pattern (const std::string& pat)
-  {
-    glob_match pattern (pat);
-
-    for (auto& nm_sr : table)
-      {
-        symbol_record& sr = nm_sr.second;
-
-        if (sr.is_global () && pattern.match (sr.name ()))
-          sr.unmark_global ();
-      }
-
-    global_table_iterator q = global_table.begin ();
-
-    while (q != global_table.end ())
-      {
-        if (pattern.match (q->first))
-          global_table.erase (q++);
-        else
-          q++;
-      }
-  }
-
-  void do_clear_variable_pattern (const std::string& pat)
-  {
-    glob_match pattern (pat);
-
-    for (auto& nm_sr : table)
-      {
-        symbol_record& sr = nm_sr.second;
-
-        if (sr.is_defined () || sr.is_global ())
-          {
-            if (pattern.match (sr.name ()))
-              sr.clear (my_scope);
-          }
-      }
-  }
-
-  void do_clear_variable_regexp (const std::string& pat)
-  {
-    octave::regexp pattern (pat);
-
-    for (auto& nm_sr : table)
-      {
-        symbol_record& sr = nm_sr.second;
-
-        if (sr.is_defined () || sr.is_global ())
-          {
-            if (pattern.is_match (sr.name ()))
-              sr.clear (my_scope);
-          }
-      }
-  }
-
-  void do_mark_automatic (const std::string& name)
-  {
-    do_insert (name).mark_automatic ();
-  }
-
-  void do_mark_hidden (const std::string& name)
-  {
-    do_insert (name).mark_hidden ();
-  }
-
-  void do_mark_global (const std::string& name)
-  {
-    do_insert (name).mark_global ();
-  }
-
-  std::list<symbol_record>
-  do_all_variables (context_id context, bool defined_only,
-                    unsigned int exclude) const
-  {
-    std::list<symbol_record> retval;
-
-    for (const auto& nm_sr : table)
-      {
-        const symbol_record& sr = nm_sr.second;
-
-        if ((defined_only && ! sr.is_defined (context))
-            || (sr.xstorage_class () & exclude))
-          continue;
-
-        retval.push_back (sr);
-      }
-
-    return retval;
-  }
-
-  std::list<symbol_record> do_glob (const std::string& pattern,
-                                    bool vars_only = false) const
-  {
-    std::list<symbol_record> retval;
-
-    glob_match pat (pattern);
-
-    for (const auto& nm_sr : table)
-      {
-        if (pat.match (nm_sr.first))
-          {
-            const symbol_record& sr = nm_sr.second;
-
-            if (vars_only && ! sr.is_variable ())
-              continue;
-
-            retval.push_back (sr);
-          }
-      }
-
-    return retval;
-  }
-
-  std::list<symbol_record> do_regexp (const std::string& pattern,
-                                      bool vars_only = false) const
-  {
-    std::list<symbol_record> retval;
-
-    octave::regexp pat (pattern);
-
-    for (const auto& nm_sr : table)
-      {
-        if (pat.is_match (nm_sr.first))
-          {
-            const symbol_record& sr = nm_sr.second;
-
-            if (vars_only && ! sr.is_variable ())
-              continue;
-
-            retval.push_back (sr);
-          }
-      }
-
-    return retval;
-  }
-
-  std::list<std::string> do_variable_names (void)
-  {
-    std::list<std::string> retval;
-
-    for (const auto& nm_sr : table)
-      {
-        if (nm_sr.second.is_variable ())
-          retval.push_back (nm_sr.first);
-      }
-
-    retval.sort ();
-
-    return retval;
-  }
-
-  bool do_is_local_variable (const std::string& name) const
-  {
-    table_const_iterator p = table.find (name);
-
-    return (p != table.end ()
-            && ! p->second.is_global ()
-            && p->second.is_defined ());
-  }
-
-  bool do_is_global (const std::string& name) const
-  {
-    table_const_iterator p = table.find (name);
-
-    return p != table.end () && p->second.is_global ();
-  }
-
-  std::list<workspace_element> do_workspace_info (void) const;
-
-  void do_dump (std::ostream& os);
-
-  void do_cache_name (const std::string& name) { table_name = name; }
-
-  void do_update_nest (void);
-
-  bool look_nonlocal (const std::string& name, symbol_record& result)
-  {
-    table_iterator p = table.find (name);
-    if (p == table.end ())
-      {
-        if (nest_parent)
-          return nest_parent->look_nonlocal (name, result);
-      }
-    else if (! p->second.is_automatic ())
-      {
-        result = p->second;
-        return true;
-      }
-
-    return false;
+    fcn_table_iterator p = m_fcn_table.find (name);
+    return p != m_fcn_table.end () ? &p->second : 0;
   }
 };
 
 extern bool out_of_date_check (octave_value& function,
                                const std::string& dispatch_type = "",
                                bool check_relative = true);
 
 extern OCTINTERP_API std::string
diff --git a/libinterp/corefcn/syscalls.cc b/libinterp/corefcn/syscalls.cc
--- a/libinterp/corefcn/syscalls.cc
+++ b/libinterp/corefcn/syscalls.cc
@@ -41,16 +41,17 @@ along with Octave; see the file COPYING.
 #include "lo-utils.h"
 #include "oct-env.h"
 #include "oct-syscalls.h"
 #include "oct-uname.h"
 
 #include "defun.h"
 #include "error.h"
 #include "errwarn.h"
+#include "interpreter.h"
 #include "oct-hist.h"
 #include "oct-map.h"
 #include "ovl.h"
 #include "oct-stdstrm.h"
 #include "oct-stream.h"
 #include "sysdep.h"
 #include "utils.h"
 #include "variables.h"
@@ -446,18 +447,18 @@ message.
 
   std::string msg;
 
   int status = octave::sys::fcntl (fid, req, arg, msg);
 
   return ovl (status, msg);
 }
 
-DEFUNX ("fork", Ffork, args, ,
-        doc: /* -*- texinfo -*-
+DEFMETHODX ("fork", Ffork, interp, args, ,
+            doc: /* -*- texinfo -*-
 @deftypefn {} {[@var{pid}, @var{msg}] =} fork ()
 Create a copy of the current process.
 
 Fork can return one of the following values:
 
 @table @asis
 @item > 0
 You are in the parent process.  The value returned from @code{fork} is the
@@ -472,17 +473,19 @@ process.  If that fails, you should prob
 The call to @code{fork} failed for some reason.  You must take evasive
 action.  A system dependent error message will be waiting in @var{msg}.
 @end table
 @end deftypefn */)
 {
   if (args.length () != 0)
     print_usage ();
 
-  if (symbol_table::at_top_level ())
+  symbol_table& symtab = interp.get_symbol_table ();
+
+  if (symtab.at_top_level ())
     error ("fork: cannot be called from command line");
 
   std::string msg;
 
   pid_t pid = octave::sys::fork (msg);
 
   return ovl (pid, msg);
 }
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -68,50 +68,60 @@ along with Octave; see the file COPYING.
 
 // Defines layout for the whos/who -long command
 static std::string Vwhos_line_format
   = "  %a:4; %ln:6; %cs:16:6:1;  %rb:12;  %lc:-1;\n";
 
 void
 clear_mex_functions (void)
 {
-  symbol_table::clear_mex_functions ();
+  symbol_table& symtab = octave::__get_symbol_table__ ("clear_mex_functions");
+
+  symtab.clear_mex_functions ();
 }
 
 void
 clear_function (const std::string& nm)
 {
-  symbol_table::clear_function (nm);
+  symbol_table& symtab = octave::__get_symbol_table__ ("clear_function");
+
+  symtab.clear_function (nm);
 }
 
 void
 clear_variable (const std::string& nm)
 {
-  symbol_table::clear_variable (nm);
+  symbol_table& symtab = octave::__get_symbol_table__ ("clear_variable");
+
+  symtab.clear_variable (nm);
 }
 
 void
 clear_symbol (const std::string& nm)
 {
-  symbol_table::clear_symbol (nm);
+  symbol_table& symtab = octave::__get_symbol_table__ ("clear_symbol");
+
+  symtab.clear_symbol (nm);
 }
 
 // Attributes of variables and functions.
 
 // Is this octave_value a valid function?
 
 octave_function *
 is_valid_function (const std::string& fcn_name,
                    const std::string& warn_for, bool warn)
 {
   octave_function *ans = nullptr;
 
   if (! fcn_name.empty ())
     {
-      octave_value val = symbol_table::find_function (fcn_name);
+      symbol_table& symtab = octave::__get_symbol_table__ ("is_valid_function");
+
+      octave_value val = symtab.find_function (fcn_name);
 
       if (val.is_defined ())
         ans = val.function_value (true);
     }
 
   // FIXME: Should this be "err" and "error_for", rather than warn?
   if (! ans && warn)
     error ("%s: the symbol '%s' is not valid as a function",
@@ -220,17 +230,19 @@ get_struct_elts (const std::string& text
 
 static inline bool
 is_variable (const std::string& name)
 {
   bool retval = false;
 
   if (! name.empty ())
     {
-      octave_value val = symbol_table::varval (name);
+      symbol_table& symtab = octave::__get_symbol_table__ ("is_variable");
+
+      octave_value val = symtab.varval (name);
 
       retval = val.is_defined ();
     }
 
   return retval;
 }
 
 string_vector
@@ -339,19 +351,21 @@ static octave_value
 do_isglobal (const octave_value_list& args)
 {
   if (args.length () != 1)
     print_usage ();
 
   if (! args(0).is_string ())
     error ("isglobal: NAME must be a string");
 
+  symbol_table& symtab = octave::__get_symbol_table__ ("do_isglobal");
+
   std::string name = args(0).string_value ();
 
-  return symbol_table::is_global (name);
+  return symtab.is_global (name);
 }
 
 DEFUN (isglobal, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} isglobal (@var{name})
 Return true if @var{name} is a globally visible variable.
 
 For example:
@@ -391,19 +405,21 @@ symbol_exist (const std::string& name, c
   bool search_file = type == "file";
   bool search_builtin = type == "builtin";
   bool search_class = type == "class";
 
   if (! (search_any || search_var || search_dir || search_file ||
          search_builtin || search_class))
     error ("exist: unrecognized type argument \"%s\"", type.c_str ());
 
+  symbol_table& symtab = octave::__get_symbol_table__ ("symbol_exist");
+
   if (search_any || search_var)
     {
-      octave_value val = symbol_table::varval (name);
+      octave_value val = symtab.varval (name);
 
       if (val.is_constant () || val.isobject ()
           || val.is_function_handle ()
           || val.is_anonymous_function ()
           || val.is_inline_function ())
         return 1;
 
       if (search_var)
@@ -411,17 +427,17 @@ symbol_exist (const std::string& name, c
     }
 
   // We shouldn't need to look in the global symbol table, since any name
   // that is visible in the current scope will be in the local symbol table.
 
   // Command line function which Matlab does not support
   if (search_any)
     {
-      octave_value val = symbol_table::find_cmdline_function (name);
+      octave_value val = symtab.find_cmdline_function (name);
 
       if (val.is_defined ())
         return 103;
     }
 
   if (search_any || search_file || search_dir)
     {
       std::string file_name = octave::lookup_autoload (name);
@@ -474,17 +490,17 @@ symbol_exist (const std::string& name, c
         }
 
       if (search_file || search_dir)
         return 0;
     }
 
   if (search_any || search_builtin)
     {
-      if (symbol_table::is_built_in_function_name (name))
+      if (symtab.is_built_in_function_name (name))
         return 5;
 
       if (search_builtin)
         return 0;
     }
 
   return 0;
 }
@@ -674,53 +690,63 @@ them.
 %!error <NAME must be a string> exist (1)
 %!error <unrecognized type argument "foobar"> exist ("a", "foobar")
 
 */
 
 octave_value
 lookup_function_handle (const std::string& nm)
 {
-  octave_value val = symbol_table::varval (nm);
+  symbol_table& symtab = octave::__get_symbol_table__ ("lookup_function_handle");
+
+  octave_value val = symtab.varval (nm);
 
   return val.is_function_handle () ? val : octave_value ();
 }
 
 octave_value
 get_global_value (const std::string& nm, bool silent)
 {
-  octave_value val = symbol_table::global_varval (nm);
+  symbol_table& symtab = octave::__get_symbol_table__ ("get_global_value");
+
+  octave_value val = symtab.global_varval (nm);
 
   if (val.is_undefined () && ! silent)
     error ("get_global_value: undefined symbol '%s'", nm.c_str ());
 
   return val;
 }
 
 void
 set_global_value (const std::string& nm, const octave_value& val)
 {
-  symbol_table::global_assign (nm, val);
+  symbol_table& symtab = octave::__get_symbol_table__ ("set_global_value");
+
+  symtab.global_assign (nm, val);
 }
 
 octave_value
 get_top_level_value (const std::string& nm, bool silent)
 {
-  octave_value val = symbol_table::top_level_varval (nm);
+  symbol_table& symtab = octave::__get_symbol_table__ ("get_top_level_value");
+
+  octave_value val = symtab.top_level_varval (nm);
 
   if (val.is_undefined () && ! silent)
     error ("get_top_level_value: undefined symbol '%s'", nm.c_str ());
 
   return val;
 }
 
 void
 set_top_level_value (const std::string& nm, const octave_value& val)
 {
-  symbol_table::top_level_assign (nm, val);
+  symbol_table& symtab = octave::__get_symbol_table__ ("set_top_level_value");
+
+  symtab.top_level_assign (nm, val);
 }
 
 // Variable values.
 
 static bool
 wants_local_change (const octave_value_list& args, int& nargin)
 {
   bool retval = false;
@@ -1642,16 +1668,18 @@ do_who (octave::interpreter& interp, int
 
   octave::call_stack& cs = interp.get_call_stack ();
 
   std::string my_name = argv[0];
 
   bool global_only = false;
   bool have_regexp = false;
 
+  symbol_table& symtab = octave::__get_symbol_table__ ("do_who");
+
   int i;
   for (i = 1; i < argc; i++)
     {
       if (argv[i] == "-file")
         {
           // FIXME: This is an inefficient manner to implement this as the
           // variables are loaded in to a temporary context and then treated.
           // It would be better to refecat symbol_info_list to not store the
@@ -1662,25 +1690,25 @@ do_who (octave::interpreter& interp, int
             error ("whos: -file argument must be followed by a filename");
 
           std::string nm = argv[i + 1];
 
           octave::unwind_protect frame;
 
           // Set up temporary scope.
 
-          symbol_table::scope_id tmp_scope = symbol_table::alloc_scope ();
-          frame.add_fcn (symbol_table::erase_scope, tmp_scope);
-
-          symbol_table::set_scope (tmp_scope);
+          symbol_table::scope_id tmp_scope = symtab.alloc_scope ();
+          frame.add_method (symtab, &symbol_table::erase_scope, tmp_scope);
+
+          symtab.set_scope (tmp_scope);
 
           cs.push (tmp_scope, 0);
           frame.add_method (cs, &octave::call_stack::pop);
 
-          frame.add_fcn (symbol_table::clear_variables);
+          frame.add_method (symtab, &symbol_table::clear_variables);
 
           octave::feval ("load", octave_value (nm), 0);
 
           std::string newmsg = std::string ("Variables in the file ")
                                + nm + ":\n\n";
 
           retval = do_who (interp, i, argv, return_list, verbose, newmsg);
 
@@ -1716,18 +1744,18 @@ do_who (octave::interpreter& interp, int
 
   for (int j = 0; j < npats; j++)
     {
       std::string pat = pats[j];
 
       if (have_regexp)
         {
           std::list<symbol_table::symbol_record> tmp = global_only
-            ? symbol_table::regexp_global_variables (pat)
-            : symbol_table::regexp_variables (pat);
+            ? symtab.regexp_global_variables (pat)
+            : symtab.regexp_variables (pat);
 
           for (const auto& symrec : tmp)
             {
               if (symrec.is_variable ())
                 {
                   if (verbose)
                     symbol_stats.append (symrec);
                   else
@@ -1747,38 +1775,38 @@ do_who (octave::interpreter& interp, int
                   // expressions based on global values if the variable is
                   // global in the current scope because we currently have
                   // no way of looking up the base value in the global
                   // scope and then evaluating the arguments in the
                   // current scope.
 
                   std::string base_name = pat.substr (0, pos);
 
-                  if (symbol_table::is_variable (base_name))
+                  if (symtab.is_variable (base_name))
                     {
                       symbol_table::symbol_record sr
-                        = symbol_table::find_symbol (base_name);
+                        = symtab.find_symbol (base_name);
 
                       if (! global_only || sr.is_global ())
                         {
                           int parse_status;
 
                           octave_value expr_val
                             = octave::eval_string (pat, true, parse_status);
 
                           symbol_stats.append (sr, pat, expr_val);
                         }
                     }
                 }
             }
           else
             {
               std::list<symbol_table::symbol_record> tmp = global_only
-                ? symbol_table::glob_global_variables (pat)
-                : symbol_table::glob_variables (pat);
+                ? symtab.glob_global_variables (pat)
+                : symtab.glob_variables (pat);
 
               for (const auto& symrec : tmp)
                 {
                   if (symrec.is_variable ())
                     {
                       if (verbose)
                         symbol_stats.append (symrec);
                       else
@@ -1954,17 +1982,19 @@ bind_ans (const octave_value& val, bool 
         {
           octave_value_list lst = val.list_value ();
 
           for (octave_idx_type i = 0; i < lst.length (); i++)
             bind_ans (lst(i), print);
         }
       else
         {
-          symbol_table::force_assign (ans, val);
+          symbol_table& symtab = octave::__get_symbol_table__ ("bind_ans");
+
+          symtab.force_assign (ans, val);
 
           if (print)
             {
               octave_value_list args = ovl (val);
               args.stash_name_tags (string_vector (ans));
               octave::feval ("display", args);
             }
         }
@@ -1992,33 +2022,37 @@ mlock (void)
     error ("mlock: invalid use outside a function");
 
   fcn->lock ();
 }
 
 void
 munlock (const std::string& nm)
 {
-  octave_value val = symbol_table::find_function (nm);
+  symbol_table& symtab = octave::__get_symbol_table__ ("munlock");
+
+  octave_value val = symtab.find_function (nm);
 
   if (val.is_defined ())
     {
       octave_function *fcn = val.function_value ();
 
       if (fcn)
         fcn->unlock ();
     }
 }
 
 bool
 mislocked (const std::string& nm)
 {
   bool retval = false;
 
-  octave_value val = symbol_table::find_function (nm);
+  symbol_table& symtab = octave::__get_symbol_table__ ("mislocked");
+
+  octave_value val = symtab.find_function (nm);
 
   if (val.is_defined ())
     {
       octave_function *fcn = val.function_value ();
 
       if (fcn)
         retval = fcn->islocked ();
     }
@@ -2165,190 +2199,200 @@ maybe_warn_exclusive (bool exclusive)
   if (exclusive)
     warning ("clear: ignoring --exclusive option");
 }
 
 static void
 do_clear_functions (const string_vector& argv, int argc, int idx,
                     bool exclusive = false)
 {
+  symbol_table& symtab = octave::__get_symbol_table__ ("do_clear_functions");
+
   if (idx == argc)
-    symbol_table::clear_functions ();
+    symtab.clear_functions ();
   else
     {
       if (exclusive)
         {
-          string_vector fcns = symbol_table::user_function_names ();
+          string_vector fcns = symtab.user_function_names ();
 
           int fcount = fcns.numel ();
 
           for (int i = 0; i < fcount; i++)
             {
               std::string nm = fcns[i];
 
               if (! name_matches_any_pattern (nm, argv, argc, idx))
-                symbol_table::clear_function (nm);
+                symtab.clear_function (nm);
             }
         }
       else
         {
           while (idx < argc)
-            symbol_table::clear_function_pattern (argv[idx++]);
+            symtab.clear_function_pattern (argv[idx++]);
         }
     }
 }
 
 static void
 do_clear_globals (const string_vector& argv, int argc, int idx,
                   bool exclusive = false)
 {
+  symbol_table& symtab = octave::__get_symbol_table__ ("do_clear_globals");
+
   if (idx == argc)
     {
-      string_vector gvars = symbol_table::global_variable_names ();
+      string_vector gvars = symtab.global_variable_names ();
 
       int gcount = gvars.numel ();
 
       for (int i = 0; i < gcount; i++)
-        symbol_table::clear_global (gvars[i]);
+        symtab.clear_global (gvars[i]);
     }
   else
     {
       if (exclusive)
         {
-          string_vector gvars = symbol_table::global_variable_names ();
+          string_vector gvars = symtab.global_variable_names ();
 
           int gcount = gvars.numel ();
 
           for (int i = 0; i < gcount; i++)
             {
               std::string nm = gvars[i];
 
               if (! name_matches_any_pattern (nm, argv, argc, idx))
-                symbol_table::clear_global (nm);
+                symtab.clear_global (nm);
             }
         }
       else
         {
           while (idx < argc)
-            symbol_table::clear_global_pattern (argv[idx++]);
+            symtab.clear_global_pattern (argv[idx++]);
         }
     }
 }
 
 static void
 do_clear_variables (const string_vector& argv, int argc, int idx,
                     bool exclusive = false, bool have_regexp = false)
 {
+  symbol_table& symtab = octave::__get_symbol_table__ ("do_clear_variables");
+
   if (idx == argc)
-    symbol_table::clear_variables ();
+    symtab.clear_variables ();
   else
     {
       if (exclusive)
         {
-          string_vector lvars = symbol_table::variable_names ();
+          string_vector lvars = symtab.variable_names ();
 
           int lcount = lvars.numel ();
 
           for (int i = 0; i < lcount; i++)
             {
               std::string nm = lvars[i];
 
               if (! name_matches_any_pattern (nm, argv, argc, idx, have_regexp))
-                symbol_table::clear_variable (nm);
+                symtab.clear_variable (nm);
             }
         }
       else
         {
           if (have_regexp)
             while (idx < argc)
-              symbol_table::clear_variable_regexp (argv[idx++]);
+              symtab.clear_variable_regexp (argv[idx++]);
           else
             while (idx < argc)
-              symbol_table::clear_variable_pattern (argv[idx++]);
+              symtab.clear_variable_pattern (argv[idx++]);
         }
     }
 }
 
 static void
 do_clear_symbols (const string_vector& argv, int argc, int idx,
                   bool exclusive = false)
 {
+  symbol_table& symtab = octave::__get_symbol_table__ ("do_clear_symbols");
+
   if (idx == argc)
-    symbol_table::clear_variables ();
+    symtab.clear_variables ();
   else
     {
       if (exclusive)
         {
           // FIXME: is this really what we want, or do we
           // somehow want to only clear the functions that are not
           // shadowed by local variables?  It seems that would be a
           // bit harder to do.
 
           do_clear_variables (argv, argc, idx, exclusive);
           do_clear_functions (argv, argc, idx, exclusive);
         }
       else
         {
           while (idx < argc)
-            symbol_table::clear_symbol_pattern (argv[idx++]);
+            symtab.clear_symbol_pattern (argv[idx++]);
         }
     }
 }
 
 static void
 do_matlab_compatible_clear (const string_vector& argv, int argc, int idx)
 {
   // This is supposed to be mostly Matlab compatible.
 
+  symbol_table& symtab = octave::__get_symbol_table__ ("do_matlab_compatible_clear");
+
   for (; idx < argc; idx++)
     {
       if (argv[idx] == "all"
-          && ! symbol_table::is_local_variable ("all"))
+          && ! symtab.is_local_variable ("all"))
         {
-          symbol_table::clear_all ();
+          symtab.clear_all ();
         }
       else if (argv[idx] == "functions"
-               && ! symbol_table::is_local_variable ("functions"))
+               && ! symtab.is_local_variable ("functions"))
         {
           do_clear_functions (argv, argc, ++idx);
         }
       else if (argv[idx] == "global"
-               && ! symbol_table::is_local_variable ("global"))
+               && ! symtab.is_local_variable ("global"))
         {
           do_clear_globals (argv, argc, ++idx);
         }
       else if (argv[idx] == "variables"
-               && ! symbol_table::is_local_variable ("variables"))
+               && ! symtab.is_local_variable ("variables"))
         {
-          symbol_table::clear_variables ();
+          symtab.clear_variables ();
         }
       else if (argv[idx] == "classes"
-               && ! symbol_table::is_local_variable ("classes"))
+               && ! symtab.is_local_variable ("classes"))
         {
-          symbol_table::clear_objects ();
+          symtab.clear_objects ();
           octave_class::clear_exemplar_map ();
-          symbol_table::clear_all ();
+          symtab.clear_all ();
         }
       else
         {
-          symbol_table::clear_symbol_pattern (argv[idx]);
+          symtab.clear_symbol_pattern (argv[idx]);
         }
     }
 }
 
 #define CLEAR_OPTION_ERROR(cond)                \
   do                                            \
     {                                           \
       if (cond)                                 \
         print_usage ();                         \
     }                                           \
   while (0)
 
-DEFUN (clear, args, ,
-       doc: /* -*- texinfo -*-
+DEFMETHOD (clear, interp, args, ,
+           doc: /* -*- texinfo -*-
 @deftypefn {} {} clear [options] pattern @dots{}
 Delete the names matching the given patterns from the symbol table.
 
 The pattern may contain the following special characters:
 
 @table @code
 @item ?
 Match any single character.
@@ -2435,16 +2479,18 @@ without the dash as well.
       bool clear_functions = false;
       bool clear_globals = false;
       bool clear_variables = false;
       bool clear_objects = false;
       bool exclusive = false;
       bool have_regexp = false;
       bool have_dash_option = false;
 
+      symbol_table& symtab = interp.get_symbol_table ();
+
       while (++idx < argc)
         {
           if (argv[idx] == "-all" || argv[idx] == "-a")
             {
               CLEAR_OPTION_ERROR (have_dash_option && ! exclusive);
 
               have_dash_option = true;
               clear_all = true;
@@ -2501,17 +2547,17 @@ without the dash as well.
             {
               if (clear_all)
                 {
                   maybe_warn_exclusive (exclusive);
 
                   if (++idx < argc)
                     warning ("clear: ignoring extra arguments after -all");
 
-                  symbol_table::clear_all ();
+                  symtab.clear_all ();
                 }
               else if (have_regexp)
                 {
                   do_clear_variables (argv, argc, idx, exclusive, true);
                 }
               else if (clear_functions)
                 {
                   do_clear_functions (argv, argc, idx, exclusive);
@@ -2521,19 +2567,19 @@ without the dash as well.
                   do_clear_globals (argv, argc, idx, exclusive);
                 }
               else if (clear_variables)
                 {
                   do_clear_variables (argv, argc, idx, exclusive);
                 }
               else if (clear_objects)
                 {
-                  symbol_table::clear_objects ();
+                  symtab.clear_objects ();
                   octave_class::clear_exemplar_map ();
-                  symbol_table::clear_all ();
+                  symtab.clear_all ();
                 }
               else
                 {
                   do_clear_symbols (argv, argc, idx, exclusive);
                 }
             }
 
           octave_link::set_workspace ();
@@ -2634,22 +2680,26 @@ When called from inside a function with 
 variable is changed locally for the function and any subroutines it calls.
 The original variable value is restored when exiting the function.
 @seealso{missing_component_hook}
 @end deftypefn */)
 {
   return SET_INTERNAL_VARIABLE (missing_function_hook);
 }
 
-void maybe_missing_function_hook (const std::string& name)
+void
+maybe_missing_function_hook (const std::string& name)
 {
   // Don't do this if we're handling errors.
   if (buffer_error_messages == 0 && ! Vmissing_function_hook.empty ())
     {
-      octave_value val = symbol_table::find_function (Vmissing_function_hook);
+      symbol_table& symtab
+        = octave::__get_symbol_table__ ("maybe_missing_function_hook");
+
+      octave_value val = symtab.find_function (Vmissing_function_hook);
 
       if (val.is_defined ())
         {
           // Ensure auto-restoration.
           octave::unwind_protect frame;
           frame.protect_var (Vmissing_function_hook);
 
           // Clear the variable prior to calling the function.
@@ -2657,28 +2707,30 @@ void maybe_missing_function_hook (const 
           Vmissing_function_hook.clear ();
 
           // Call.
           octave::feval (func_name, octave_value (name));
         }
     }
 }
 
-DEFUN (__varval__, args, ,
-       doc: /* -*- texinfo -*-
+DEFMETHOD (__varval__, interp, args, ,
+           doc: /* -*- texinfo -*-
 @deftypefn {} {} __varval__ (@var{name})
 Return the value of the variable @var{name} directly from the symbol table.
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
   std::string name = args(0).xstring_value ("__varval__: first argument must be a variable name");
 
-  return symbol_table::varval (args(0).string_value ());
+  symbol_table& symtab = interp.get_symbol_table ();
+
+  return symtab.varval (args(0).string_value ());
 }
 
 static std::string Vmissing_component_hook;
 
 DEFUN (missing_component_hook, args, nargout,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{val} =} missing_component_hook ()
 @deftypefnx {} {@var{old_val} =} missing_component_hook (@var{new_val})
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -192,17 +192,19 @@ octave_class::octave_class (const octave
 
               map.assign (pcnm, c);
             }
           else
             error ("class: parent class dimension mismatch");
         }
     }
 
-  symbol_table::add_to_parent_map (id, parent_list);
+  symbol_table& symtab = octave::__get_symbol_table__ ("octave_class");
+
+  symtab.add_to_parent_map (id, parent_list);
 }
 
 octave_base_value *
 octave_class::unique_clone (void)
 {
   if (count == obsolete_copies)
     {
       // All remaining copies are obsolete.  We don't actually need to clone.
@@ -290,17 +292,20 @@ octave_class::dotref (const octave_value
 
 Matrix
 octave_class::size (void)
 {
   if (in_class_method () || called_from_builtin ())
     return octave_base_value::size ();
 
   Matrix retval (1, 2, 1.0);
-  octave_value meth = symbol_table::find_method ("size", class_name ());
+
+  symbol_table& symtab = octave::__get_symbol_table__ ("octave_class::size");
+
+  octave_value meth = symtab.find_method ("size", class_name ());
 
   if (meth.is_defined ())
     {
       count++;
       octave_value_list args (1, octave_value (this));
 
       octave_value_list lv = octave::feval (meth.function_value (), args, 1);
       if (lv.length () <= 0
@@ -328,17 +333,19 @@ octave_idx_type
 octave_class::numel (const octave_value_list& idx)
 {
   if (in_class_method () || called_from_builtin ())
     return octave_base_value::numel (idx);
 
   octave_idx_type retval = -1;
   const std::string cn = class_name ();
 
-  octave_value meth = symbol_table::find_method ("numel", cn);
+  symbol_table& symtab = octave::__get_symbol_table__ ("octave_class::numel");
+
+  octave_value meth = symtab.find_method ("numel", cn);
 
   if (meth.is_defined ())
     {
       octave_value_list args (idx.length () + 1, octave_value ());
 
       count++;
       args(0) = octave_value (this);
 
@@ -421,17 +428,19 @@ octave_class::subsref (const std::string
       // octave_value_list::next_subsref member function?  See also
       // octave_user_function::subsref.
 
       if (idx.size () > 1)
         retval = retval(0).next_subsref (nargout, type, idx, skip);
     }
   else
     {
-      octave_value meth = symbol_table::find_method ("subsref", class_name ());
+      symbol_table& symtab = octave::__get_symbol_table__ ("octave_class::subsref");
+
+      octave_value meth = symtab.find_method ("subsref", class_name ());
 
       if (meth.is_defined ())
         {
           octave_value_list args;
 
           args(1) = make_idx_args (type, idx, "subsref");
 
           count++;
@@ -519,17 +528,20 @@ octave_class::subsasgn_common (const oct
                                const std::string& type,
                                const std::list<octave_value_list>& idx,
                                const octave_value& rhs)
 {
   octave_value retval;
 
   if (! (in_class_method () || called_from_builtin ()))
     {
-      octave_value meth = symbol_table::find_method ("subsasgn", class_name ());
+      symbol_table& symtab
+        = octave::__get_symbol_table__ ("octave_class::subsasgn_common");
+
+      octave_value meth = symtab.find_method ("subsasgn", class_name ());
 
       if (meth.is_defined ())
         {
           octave_value_list args;
 
           if (rhs.is_cs_list ())
             {
               octave_value_list lrhs = rhs.list_value ();
@@ -794,17 +806,19 @@ octave_class::subsasgn_common (const oct
     }
 
   return retval;
 }
 
 idx_vector
 octave_class::index_vector (bool require_integers) const
 {
-  octave_value meth = symbol_table::find_method ("subsindex", class_name ());
+  symbol_table& symtab = octave::__get_symbol_table__ ("octave_class::index_vector");
+
+  octave_value meth = symtab.find_method ("subsindex", class_name ());
 
   if (! meth.is_defined ())
     error ("no subsindex method defined for class %s",
            class_name ().c_str ());
 
   octave_value_list args;
   args(0) = octave_value (new octave_class (map, c_name, parent_list));
 
@@ -840,17 +854,19 @@ octave_class::byte_size (void) const
   return retval;
 }
 
 bool
 octave_class::is_true (void) const
 {
   bool retval = false;
 
-  octave_value meth = symbol_table::find_method ("logical", class_name ());
+  symbol_table& symtab = octave::__get_symbol_table__ ("octave_class::is_true");
+
+  octave_value meth = symtab.find_method ("logical", class_name ());
 
   if (meth.is_defined ())
     {
       octave_value in = new octave_class (*this);
 
       octave_value_list tmp = octave::feval (meth.function_value (), in, 1);
       retval = tmp(0).is_true ();
     }
@@ -956,17 +972,20 @@ octave_class::is_instance_of (const std:
   return retval;
 }
 
 string_vector
 octave_class::string_vector_value (bool pad) const
 {
   string_vector retval;
 
-  octave_value meth = symbol_table::find_method ("char", class_name ());
+  symbol_table& symtab
+    = octave::__get_symbol_table__ ("octave_class::string_vector_value");
+
+  octave_value meth = symtab.find_method ("char", class_name ());
 
   if (! meth.is_defined ())
     error ("no char method defined for class %s", class_name ().c_str ());
 
   octave_value_list args;
   args(0) = octave_value (new octave_class (map, c_name, parent_list));
 
   octave_value_list tmp = octave::feval (meth.function_value (), args, 1);
@@ -1021,17 +1040,20 @@ octave_class::reconstruct_exemplar (void
 
   octave_class::exemplar_const_iterator it
     = octave_class::exemplar_map.find (c_name);
 
   if (it != octave_class::exemplar_map.end ())
     retval = true;
   else
     {
-      octave_value ctor = symbol_table::find_method (c_name, c_name);
+      symbol_table& symtab
+        = octave::__get_symbol_table__ ("octave_class::reconstruct_exemplar");
+
+      octave_value ctor = symtab.find_method (c_name, c_name);
 
       bool have_ctor = false;
 
       if (ctor.is_defined () && ctor.is_function ())
         {
           octave_function *fcn = ctor.function_value ();
 
           if (fcn && fcn->is_class_constructor (c_name))
@@ -2018,18 +2040,20 @@ may @emph{only} be called from a class c
     {
       std::string inf_class = args(i).xstring_value ("superiorto: CLASS_NAME must be a string");
 
       // User defined classes always have higher precedence
       // than built-in classes
       if (is_built_in_class (inf_class))
         break;
 
+      symbol_table& symtab = interp.get_symbol_table ();
+
       std::string sup_class = fcn->name ();
-      if (! symbol_table::set_class_relationship (sup_class, inf_class))
+      if (! symtab.set_class_relationship (sup_class, inf_class))
         error ("superiorto: opposite precedence already set for %s and %s",
                sup_class.c_str (), inf_class.c_str ());
     }
 
   return ovl ();
 }
 
 DEFMETHOD (inferiorto, interp, args, ,
@@ -2053,16 +2077,18 @@ may @emph{only} be called from a class c
   for (int i = 0; i < args.length (); i++)
     {
       std::string sup_class = args(i).xstring_value ("inferiorto: CLASS_NAME must be a string");
 
       if (is_built_in_class (sup_class))
         error ("inferiorto: cannot give user-defined class lower "
                "precedence than built-in class");
 
+      symbol_table& symtab = interp.get_symbol_table ();
+
       std::string inf_class = fcn->name ();
-      if (! symbol_table::set_class_relationship (sup_class, inf_class))
+      if (! symtab.set_class_relationship (sup_class, inf_class))
         error ("inferiorto: opposite precedence already set for %s and %s",
                inf_class.c_str (), sup_class.c_str ());
     }
 
   return octave_value();
 }
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -1090,17 +1090,20 @@ public:
         if (! is_direct_superclass (cls, ctx))
           error ("`%s' is not a direct superclass of `%s'",
                  cname.c_str (), ctx.get_name ().c_str ());
 
         if (! is_constructed_object (mname))
           error ("cannot call superclass constructor with variable `%s'",
                  mname.c_str ());
 
-        octave_value sym = symbol_table::varval (mname);
+        symbol_table& symtab
+          = octave::__get_symbol_table__ ("octave_classdef_superclass_ref::call");
+
+        octave_value sym = symtab.varval (mname);
 
         cls.run_constructor (to_cdef_ref (sym), idx);
 
         retval(0) = sym;
       }
     else
       {
         if (mname != meth_name)
@@ -3224,17 +3227,20 @@ Cell
 cdef_package::cdef_package_rep::get_packages (void) const
 { return map2Cell (package_map); }
 
 octave_value
 cdef_package::cdef_package_rep::find (const std::string& nm)
 {
   std::string symbol_name = get_name () + "." + nm;
 
-  return symbol_table::find (symbol_name, octave_value_list (), true, false);
+  symbol_table& symtab
+    = octave::__get_symbol_table__ ("cdef_package::cdef_package_rep::find");
+
+  return symtab.find (symbol_name, octave_value_list (), true, false);
 }
 
 octave_value_list
 cdef_package::cdef_package_rep::meta_subsref
   (const std::string& type, const std::list<octave_value_list>& idx,
    int nargout)
 {
   octave_value_list retval;
@@ -3312,17 +3318,17 @@ cdef_package::cdef_package_rep::meta_rel
 cdef_class cdef_class::_meta_class = cdef_class ();
 cdef_class cdef_class::_meta_property = cdef_class ();
 cdef_class cdef_class::_meta_method = cdef_class ();
 cdef_class cdef_class::_meta_package = cdef_class ();
 
 cdef_package cdef_package::_meta = cdef_package ();
 
 void
-install_classdef (octave::interpreter& /* interp */)
+install_classdef (octave::interpreter& interp)
 {
   octave_classdef::register_type ();
 
   // bootstrap
   cdef_class handle = make_class ("handle");
 
   cdef_class meta_class
     = cdef_class::_meta_class
@@ -3479,28 +3485,30 @@ install_classdef (octave::interpreter& /
   cdef_package package_meta = cdef_package::_meta = make_package ("meta");
   package_meta.install_class (meta_class,       "class");
   package_meta.install_class (meta_property,    "property");
   package_meta.install_class (meta_method,      "method");
   package_meta.install_class (meta_package,     "package");
   package_meta.install_class (meta_event,       "event");
   package_meta.install_class (meta_dynproperty, "dynproperty");
 
+  symbol_table& symtab = interp.get_symbol_table ();
+
   // install built-in classes into the symbol table
-  symbol_table::install_built_in_function
+  symtab.install_built_in_function
     ("meta.class", octave_value (meta_class.get_constructor_function ()));
-  symbol_table::install_built_in_function
+  symtab.install_built_in_function
     ("meta.method", octave_value (meta_method.get_constructor_function ()));
-  symbol_table::install_built_in_function
+  symtab.install_built_in_function
     ("meta.property", octave_value (meta_property.get_constructor_function ()));
-  symbol_table::install_built_in_function
+  symtab.install_built_in_function
     ("meta.package", octave_value (meta_package.get_constructor_function ()));
-  symbol_table::install_built_in_function
+  symtab.install_built_in_function
     ("meta.event", octave_value (meta_event.get_constructor_function ()));
-  symbol_table::install_built_in_function
+  symtab.install_built_in_function
     ("meta.dynproperty", octave_value (meta_dynproperty.get_constructor_function ()));
 }
 
 //----------------------------------------------------------------------------
 
 cdef_manager *cdef_manager::instance = nullptr;
 
 void
@@ -3522,17 +3530,22 @@ cdef_manager::do_find_class (const std::
     {
       if (load_if_not_found)
         {
           octave_value ov_cls;
 
           size_t pos = name.rfind ('.');
 
           if (pos == std::string::npos)
-            ov_cls = symbol_table::find (name);
+            {
+              symbol_table& symtab
+                = octave::__get_symbol_table__ ("cdef_manager::do_find_class");
+
+              ov_cls = symtab.find (name);
+            }
           else
             {
               std::string pack_name = name.substr (0, pos);
 
               cdef_package pack = do_find_package (pack_name, false, true);
 
               if (pack.ok ())
                 ov_cls = pack.find (name.substr (pos+1));
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -80,17 +80,21 @@ const std::string octave_fcn_handle::ano
 
 octave_fcn_handle::octave_fcn_handle (const octave_value& f,
                                       const std::string& n)
   : fcn (f), nm (n), has_overloads (false)
 {
   octave_user_function *uf = fcn.user_function_value (true);
 
   if (uf && nm != anonymous)
-    symbol_table::cache_name (uf->scope (), nm);
+    {
+      symbol_table& symtab = octave::__get_symbol_table__ ("octave_fcn_handle");
+
+      symtab.cache_name (uf->scope (), nm);
+    }
 
   if (uf && uf->is_nested_function () && ! uf->is_subfunction ())
     error ("handles to nested functions are not yet supported");
 }
 
 octave_value_list
 octave_fcn_handle::subsref (const std::string& type,
                             const std::list<octave_value_list>& idx,
@@ -155,28 +159,31 @@ octave_fcn_handle::call (int nargout, co
       else
         {
           str_ov_map::iterator it = overloads.find (dispatch_type);
 
           if (it == overloads.end ())
             {
               // Try parent classes too.
 
+              symbol_table& symtab
+                = octave::__get_symbol_table__ ("octave_fcn_handle::call");
+
               std::list<std::string> plist
-                = symbol_table::parent_classes (dispatch_type);
+                = symtab.parent_classes (dispatch_type);
 
               std::list<std::string>::const_iterator pit = plist.begin ();
 
               while (pit != plist.end ())
                 {
                   std::string pname = *pit;
 
                   std::string fnm = fcn_name ();
 
-                  octave_value ftmp = symbol_table::find_method (fnm, pname);
+                  octave_value ftmp = symtab.find_method (fnm, pname);
 
                   if (ftmp.is_defined ())
                     {
                       set_overload (pname, ftmp);
 
                       out_of_date_check (ftmp, pname, false);
                       ov_fcn = ftmp;
 
@@ -313,17 +320,20 @@ octave_fcn_handle::set_fcn (const std::s
             error ("function handle points to non-existent function");
 
           octave_value tmp (xfcn);
 
           fcn = octave_value (new octave_fcn_handle (tmp, nm));
         }
       else
         {
-          fcn = symbol_table::find_function (nm);
+          symbol_table& symtab
+            = octave::__get_symbol_table__ ("octave_fcn_handle::set_fcn");
+
+          fcn = symtab.find_function (nm);
 
           if (! fcn.is_function ())
             error ("function handle points to non-existent function");
         }
     }
 
   return true;
 }
@@ -338,18 +348,21 @@ octave_fcn_handle::save_ascii (std::ostr
       print_raw (os, true);
       os << "\n";
 
       if (fcn.is_undefined ())
         return false;
 
       octave_user_function *f = fcn.user_function_value ();
 
+      symbol_table& symtab
+        = octave::__get_symbol_table__ ("octave_fcn_handle::save_ascii");
+
       std::list<symbol_table::symbol_record> vars
-        = symbol_table::all_variables (f->scope (), 0);
+        = symtab.all_variables (f->scope (), 0);
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
         {
           os << "# length: " << varlen << "\n";
 
           for (const auto& symrec : vars)
@@ -413,20 +426,23 @@ octave_fcn_handle::load_ascii (std::istr
 
       pos = is.tellg ();
 
       octave::unwind_protect_safe frame;
 
       // Set up temporary scope to use for evaluating the text that
       // defines the anonymous function.
 
-      symbol_table::scope_id local_scope = symbol_table::alloc_scope ();
-      frame.add_fcn (symbol_table::erase_scope, local_scope);
+      symbol_table& symtab
+        = octave::__get_symbol_table__ ("octave_fcn_handle::load_ascii");
 
-      symbol_table::set_scope (local_scope);
+      symbol_table::scope_id local_scope = symtab.alloc_scope ();
+      frame.add_method (symtab, &symbol_table::erase_scope, local_scope);
+
+      symtab.set_scope (local_scope);
 
       octave::call_stack& cs
         = octave::__get_call_stack__ ("octave_fcn_handle::load_ascii");
 
       cs.push (local_scope, 0);
       frame.add_method (cs, &octave::call_stack::pop);
 
       octave_idx_type len = 0;
@@ -441,17 +457,17 @@ octave_fcn_handle::load_ascii (std::istr
                   bool dummy;
 
                   std::string name
                     = read_text_data (is, "", dummy, t2, i);
 
                   if (! is)
                     error ("load: failed to load anonymous function handle");
 
-                  symbol_table::assign (name, t2, local_scope, 0);
+                  symtab.assign (name, t2, local_scope, 0);
                 }
             }
         }
       else
         {
           is.seekg (pos);
           is.clear ();
         }
@@ -469,17 +485,17 @@ octave_fcn_handle::load_ascii (std::istr
 
               if (fh)
                 {
                   fcn = fh->fcn;
 
                   octave_user_function *uf = fcn.user_function_value (true);
 
                   if (uf)
-                    symbol_table::cache_name (uf->scope (), nm);
+                    symtab.cache_name (uf->scope (), nm);
                 }
               else
                 success = false;
             }
           else
             success = false;
         }
       else
@@ -498,18 +514,21 @@ octave_fcn_handle::save_binary (std::ost
     {
       std::ostringstream nmbuf;
 
       if (fcn.is_undefined ())
         return false;
 
       octave_user_function *f = fcn.user_function_value ();
 
+      symbol_table& symtab
+        = octave::__get_symbol_table__ ("octave_fcn_handle::save_binary");
+
       std::list<symbol_table::symbol_record> vars
-        = symbol_table::all_variables (f->scope (), 0);
+        = symtab.all_variables (f->scope (), 0);
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
         nmbuf << nm << " " << varlen;
       else
         nmbuf << nm;
 
@@ -599,20 +618,23 @@ octave_fcn_handle::load_binary (std::ist
       is.read (ctmp2, tmp);
       ctmp2[tmp] = 0;
 
       octave::unwind_protect_safe frame;
 
       // Set up temporary scope to use for evaluating the text that
       // defines the anonymous function.
 
-      symbol_table::scope_id local_scope = symbol_table::alloc_scope ();
-      frame.add_fcn (symbol_table::erase_scope, local_scope);
+      symbol_table& symtab
+        = octave::__get_symbol_table__ ("octave_fcn_handle::load_binary");
 
-      symbol_table::set_scope (local_scope);
+      symbol_table::scope_id local_scope = symtab.alloc_scope ();
+      frame.add_method (symtab, &symbol_table::erase_scope, local_scope);
+
+      symtab.set_scope (local_scope);
 
       octave::call_stack& cs
         = octave::__get_call_stack__ ("octave_fcn_handle::load_binary");
 
       cs.push (local_scope, 0);
       frame.add_method (cs, &octave::call_stack::pop);
 
       if (len > 0)
@@ -625,17 +647,17 @@ octave_fcn_handle::load_binary (std::ist
 
               std::string name =
                 read_binary_data (is, swap, fmt, "",
                                   dummy, t2, doc);
 
               if (! is)
                 error ("load: failed to load anonymous function handle");
 
-              symbol_table::assign (name, t2, local_scope);
+              symtab.assign (name, t2, local_scope);
             }
         }
 
       if (is && success)
         {
           int parse_status;
           octave_value anon_fcn_handle
             = octave::eval_string (ctmp2, true, parse_status);
@@ -646,17 +668,17 @@ octave_fcn_handle::load_binary (std::ist
 
               if (fh)
                 {
                   fcn = fh->fcn;
 
                   octave_user_function *uf = fcn.user_function_value (true);
 
                   if (uf)
-                    symbol_table::cache_name (uf->scope (), nm);
+                    symtab.cache_name (uf->scope (), nm);
                 }
               else
                 success = false;
             }
           else
             success = false;
         }
     }
@@ -771,18 +793,21 @@ octave_fcn_handle::save_hdf5 (octave_hdf
           H5Gclose (group_hid);
           return false;
         }
 
       H5Dclose (data_hid);
 
       octave_user_function *f = fcn.user_function_value ();
 
+      symbol_table& symtab
+        = octave::__get_symbol_table__ ("octave_fcn_handle::load_hdf5");
+
       std::list<symbol_table::symbol_record> vars
-        = symbol_table::all_variables (f->scope (), 0);
+        = symtab.all_variables (f->scope (), 0);
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
         {
           hid_t as_id = H5Screate (H5S_SCALAR);
 
           if (as_id >= 0)
@@ -1118,20 +1143,23 @@ octave_fcn_handle::load_hdf5 (octave_hdf
       H5Eset_auto (err_func, err_func_data);
 #endif
 
       octave::unwind_protect_safe frame;
 
       // Set up temporary scope to use for evaluating the text that
       // defines the anonymous function.
 
-      symbol_table::scope_id local_scope = symbol_table::alloc_scope ();
-      frame.add_fcn (symbol_table::erase_scope, local_scope);
+      symbol_table& symtab
+        = octave::__get_symbol_table__ ("octave_fcn_handle::load_hdf5");
 
-      symbol_table::set_scope (local_scope);
+      symbol_table::scope_id local_scope = symtab.alloc_scope ();
+      frame.add_method (symtab, &symbol_table::erase_scope, local_scope);
+
+      symtab.set_scope (local_scope);
 
       octave::call_stack& cs
         = octave::__get_call_stack__ ("octave_fcn_handle::load_hdf5");
 
       cs.push (local_scope, 0);
       frame.add_method (cs, &octave::call_stack::pop);
 
       if (len > 0 && success)
@@ -1151,17 +1179,17 @@ octave_fcn_handle::load_hdf5 (octave_hdf
           hdf5_callback_data dsub;
           int current_item = 0;
           for (octave_idx_type i = 0; i < len; i++)
             {
               if (hdf5_h5g_iterate (group_hid, "symbol table", &current_item,
                                     &dsub) <= 0)
                 error ("load: failed to load anonymous function handle");
 
-              symbol_table::assign (dsub.name, dsub.tc, local_scope);
+              symtab.assign (dsub.name, dsub.tc, local_scope);
             }
         }
 
       if (success)
         {
           int parse_status;
           octave_value anon_fcn_handle
             = octave::eval_string (fcn_tmp, true, parse_status);
@@ -1172,17 +1200,17 @@ octave_fcn_handle::load_hdf5 (octave_hdf
 
               if (fh)
                 {
                   fcn = fh->fcn;
 
                   octave_user_function *uf = fcn.user_function_value (true);
 
                   if (uf)
-                    symbol_table::cache_name (uf->scope (), nm);
+                    symtab.cache_name (uf->scope (), nm);
                 }
               else
                 success = false;
             }
           else
             success = false;
         }
 
@@ -1555,18 +1583,20 @@ make_fcn_handle (const std::string& nm, 
           break;
 
         case '|':
           tnm = "or";
           break;
         }
     }
 
-  octave_value f = symbol_table::find_function (tnm, octave_value_list (),
-                                                local_funcs);
+  symbol_table& symtab = octave::__get_symbol_table__ ("make_fcn_handle");
+
+  octave_value f = symtab.find_function (tnm, octave_value_list (),
+                                         local_funcs);
 
   octave_function *fptr = f.function_value (true);
 
   // Here we are just looking to see if FCN is a method or constructor
   // for any class.
   if (local_funcs && fptr
       && (fptr->is_subfunction () || fptr->is_private_function ()
           || fptr->is_class_constructor ()
@@ -1594,17 +1624,17 @@ make_fcn_handle (const std::string& nm, 
         error ("@%s: no function and no method found", tnm.c_str ());
 
       octave_fcn_handle *fh = new octave_fcn_handle (f, tnm);
       retval = fh;
 
       for (auto& cls : classes)
         {
           std::string class_name = cls;
-          octave_value fmeth = symbol_table::find_method (tnm, class_name);
+          octave_value fmeth = symtab.find_method (tnm, class_name);
 
           bool is_builtin = false;
           for (int i = 0; i < btyp_num_types; i++)
             {
               // FIXME: Too slow? Maybe binary lookup?
               if (class_name == btyp_class_name[i])
                 {
                   is_builtin = true;
@@ -1649,18 +1679,18 @@ make_fcn_handle (const std::string& nm, 
 %!      ">", "gt";
 %!      "&", "and";
 %!      "|", "or"};
 %! for i = 1:rows (x)
 %!   assert (functions (str2func (x{i,1})).function, x{i,2});
 %! endfor
 */
 
-DEFUN (functions, args, ,
-       doc: /* -*- texinfo -*-
+DEFMETHOD (functions, interp, args, ,
+           doc: /* -*- texinfo -*-
 @deftypefn {} {@var{s} =} functions (@var{fcn_handle})
 Return a structure containing information about the function handle
 @var{fcn_handle}.
 
 The structure @var{s} always contains these three fields:
 
 @table @asis
 @item function
@@ -1747,18 +1777,20 @@ particular output format.
   std::string nm = fcn->fcn_file_name ();
 
   if (fh_nm == octave_fcn_handle::anonymous)
     {
       m.setfield ("file", nm);
 
       octave_user_function *fu = fh->user_function_value ();
 
+      symbol_table& symtab = interp.get_symbol_table ();
+
       std::list<symbol_table::symbol_record> vars
-        = symbol_table::all_variables (fu->scope (), 0);
+        = symtab.all_variables (fu->scope (), 0);
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
         {
           octave_scalar_map ws;
           for (const auto& symrec : vars)
             ws.assign (symrec.name (), symrec.varval (0));
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -173,17 +173,17 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
                                      "user-defined function");
 
 // Ugh.  This really needs to be simplified (code/data?
 // extrinsic/intrinsic state?).
 
 octave_user_function::octave_user_function
   (symbol_table::scope_id sid, octave::tree_parameter_list *pl,
    octave::tree_parameter_list *rl, octave::tree_statement_list *cl)
-  : octave_user_code ("", ""),
+  : octave_user_code ("", ""), m_scope (0),
     param_list (pl), ret_list (rl), cmd_list (cl),
     lead_comm (), trail_comm (), file_name (),
     location_line (0), location_column (0),
     parent_name (), t_parsed (static_cast<time_t> (0)),
     t_checked (static_cast<time_t> (0)),
     system_fcn_file (false), call_depth (-1),
     num_named_args (param_list ? param_list->length () : 0),
     subfunction (false), inline_function (false),
@@ -194,36 +194,48 @@ octave_user_function::octave_user_functi
 #if defined (HAVE_LLVM)
     , jit_info (0)
 #endif
 {
   if (cmd_list)
     cmd_list->mark_as_function_body ();
 
   if (local_scope >= 0)
-    symbol_table::set_curr_fcn (this, local_scope);
+    {
+      symbol_table& symtab = octave::__get_symbol_table__ ("octave_user_function");
+
+      symtab.set_curr_fcn (this, local_scope);
+
+      m_scope = symtab.get_scope (local_scope);
+    }
 }
 
 octave_user_function::~octave_user_function (void)
 {
+  // FIXME: shouldn't this happen automatically when deleting cmd_list?
   if (cmd_list)
     cmd_list->remove_all_breakpoints (file_name);
 
+  delete m_scope;
+
+  // FIXME: there needs to be a better way...
+  symbol_table& symtab
+    = octave::__get_symbol_table__ ("~octave_user_function");
+
+  symtab.erase_scope (local_scope);
+
   delete param_list;
   delete ret_list;
   delete cmd_list;
   delete lead_comm;
   delete trail_comm;
 
 #if defined (HAVE_LLVM)
   delete jit_info;
 #endif
-
-  // FIXME: this is really playing with fire.
-  symbol_table::erase_scope (local_scope);
 }
 
 octave_user_function *
 octave_user_function::define_ret_list (octave::tree_parameter_list *t)
 {
   ret_list = t;
 
   return this;
@@ -293,16 +305,22 @@ octave_user_function::maybe_relocate_end
           if (f)
             f->maybe_relocate_end_internal ();
         }
     }
 
   maybe_relocate_end_internal ();
 }
 
+void
+octave_user_function::stash_parent_fcn_scope (symbol_table::scope_id ps)
+{
+  parent_scope = ps;
+}
+
 std::string
 octave_user_function::profiler_name (void) const
 {
   std::ostringstream result;
 
   if (is_anonymous_function ())
     result << "anonymous@" << fcn_file_name ()
            << ":" << location_line << ":" << location_column;
@@ -339,44 +357,58 @@ octave_user_function::mark_as_system_fcn
 
       if (Vfcn_file_dir == ff_name.substr (0, Vfcn_file_dir.length ()))
         system_fcn_file = true;
     }
   else
     system_fcn_file = false;
 }
 
+void
+octave_user_function::erase_subfunctions (void)
+{
+  m_scope->erase_subfunctions ();
+}
+
 bool
 octave_user_function::takes_varargs (void) const
 {
   return (param_list && param_list->takes_varargs ());
 }
 
 bool
 octave_user_function::takes_var_return (void) const
 {
   return (ret_list && ret_list->takes_varargs ());
 }
 
 void
+octave_user_function::mark_as_private_function (const std::string& cname)
+{
+  m_scope->mark_subfunctions_in_scope_as_private (cname);
+
+  octave_function::mark_as_private_function (cname);
+}
+
+void
 octave_user_function::lock_subfunctions (void)
 {
-  symbol_table::lock_subfunctions (local_scope);
+  m_scope->lock_subfunctions ();
 }
 
 void
 octave_user_function::unlock_subfunctions (void)
 {
-  symbol_table::unlock_subfunctions (local_scope);
+  m_scope->unlock_subfunctions ();
 }
 
 std::map<std::string, octave_value>
 octave_user_function::subfunctions (void) const
 {
-  return symbol_table::subfunctions_defined_in_scope (local_scope);
+  return m_scope->subfunctions ();
 }
 
 bool
 octave_user_function::has_subfunctions (void) const
 {
   return ! subfcn_names.empty ();
 }
 
@@ -451,19 +483,19 @@ octave_user_function::call (octave::tree
   cs.push (this, local_scope, context);
 
   frame.protect_var (Vtrack_line_num);
   Vtrack_line_num = true;    // update source line numbers, even if debugging
   frame.add_method (cs, &octave::call_stack::pop);
 
   if (call_depth > 0 && ! is_anonymous_function ())
     {
-      symbol_table::push_context ();
+      m_scope->push_context ();
 
-      frame.add_fcn (symbol_table::pop_context);
+      frame.add_method (m_scope, &symbol_table::scope::pop_context);
     }
 
   string_vector arg_names = args.name_tags ();
 
   if (param_list && ! param_list->varargs_only ())
     tw.define_parameter_list_from_arg_vector (param_list, args);
 
   // For classdef constructor, pre-populate the output arguments
@@ -501,17 +533,17 @@ octave_user_function::call (octave::tree
       //
       // This cleanup function is added to the unwind_protect stack
       // after the calls to clear the parameter lists so that local
       // variables will be cleared before the parameter lists are
       // cleared.  That way, any function parameters that have been
       // declared global will be unmarked as global before they are
       // undefined by the clear_param_list cleanup function.
 
-      frame.add_fcn (symbol_table::clear_variables);
+      frame.add_method (m_scope, &symbol_table::scope::clear_variables);
     }
 
   bind_automatic_vars (tw, arg_names, args.length (), nargout,
                        all_va_args (args));
 
   frame.add_method (this, &octave_user_function::restore_warning_states);
 
   bool echo_commands = (Vecho_executing_commands & ECHO_FUNCTIONS);
@@ -568,17 +600,17 @@ octave_user_function::call (octave::tree
     {
       tw.initialize_undefined_parameter_list_elements (ret_list, my_name,
                                                        nargout, Matrix ());
 
       Cell varargout;
 
       if (ret_list->takes_varargs ())
         {
-          octave_value varargout_varval = symbol_table::varval ("varargout");
+          octave_value varargout_varval = m_scope->varval ("varargout");
 
           if (varargout_varval.is_defined ())
             varargout = varargout_varval.xcell_value ("varargout must be a cell array object");
         }
 
       retval = tw.convert_parameter_list_to_const_vector (ret_list, nargout, varargout);
     }
 
@@ -617,17 +649,20 @@ octave_user_function::subsasgn_optimizat
 
   return retval;
 }
 
 #if 0
 void
 octave_user_function::print_symtab_info (std::ostream& os) const
 {
-  symbol_table::print_info (os, local_scope);
+  symbol_table& symtab
+    = octave::__get_symbol_table__ ("octave_user_function::print_symtab_info");
+
+  symtab.print_info (os, local_scope);
 }
 #endif
 
 void
 octave_user_function::print_code_function_header (void)
 {
   octave::tree_print_code tpc (octave_stdout, VPS4);
 
@@ -649,55 +684,54 @@ octave_user_function::bind_automatic_var
 {
   if (! arg_names.empty ())
     {
       // It is better to save this in the hidden variable .argn. and
       // then use that in the inputname function instead of using argn,
       // which might be redefined in a function.  Keep the old argn name
       // for backward compatibility of functions that use it directly.
 
-      symbol_table::force_assign ("argn",
-                                  charMatrix (arg_names, Vstring_fill_char));
-      symbol_table::force_assign (".argn.", Cell (arg_names));
+      m_scope->force_assign ("argn", charMatrix (arg_names, Vstring_fill_char));
+      m_scope->force_assign (".argn.", Cell (arg_names));
 
-      symbol_table::mark_hidden (".argn.");
+      m_scope->mark_hidden (".argn.");
 
-      symbol_table::mark_automatic ("argn");
-      symbol_table::mark_automatic (".argn.");
+      m_scope->mark_automatic ("argn");
+      m_scope->mark_automatic (".argn.");
     }
 
-  symbol_table::force_assign (".nargin.", nargin);
-  symbol_table::force_assign (".nargout.", nargout);
+  m_scope->force_assign (".nargin.", nargin);
+  m_scope->force_assign (".nargout.", nargout);
 
-  symbol_table::mark_hidden (".nargin.");
-  symbol_table::mark_hidden (".nargout.");
+  m_scope->mark_hidden (".nargin.");
+  m_scope->mark_hidden (".nargout.");
 
-  symbol_table::mark_automatic (".nargin.");
-  symbol_table::mark_automatic (".nargout.");
+  m_scope->mark_automatic (".nargin.");
+  m_scope->mark_automatic (".nargout.");
 
-  symbol_table::assign (".saved_warning_states.");
+  m_scope->assign (".saved_warning_states.");
 
-  symbol_table::mark_automatic (".saved_warning_states.");
-  symbol_table::mark_automatic (".saved_warning_states.");
+  m_scope->mark_automatic (".saved_warning_states.");
+  m_scope->mark_automatic (".saved_warning_states.");
 
   if (takes_varargs ())
-    symbol_table::assign ("varargin", va_args.cell_value ());
+    m_scope->assign ("varargin", va_args.cell_value ());
 
   Matrix ignored_fcn_outputs = tw.ignored_fcn_outputs ();
 
-  symbol_table::assign (".ignored.", ignored_fcn_outputs);
+  m_scope->assign (".ignored.", ignored_fcn_outputs);
 
-  symbol_table::mark_hidden (".ignored.");
-  symbol_table::mark_automatic (".ignored.");
+  m_scope->mark_hidden (".ignored.");
+  m_scope->mark_automatic (".ignored.");
 }
 
 void
 octave_user_function::restore_warning_states (void)
 {
-  octave_value val = symbol_table::varval (".saved_warning_states.");
+  octave_value val = m_scope->varval (".saved_warning_states.");
 
   if (val.is_defined ())
     {
       // Fail spectacularly if .saved_warning_states. is not an
       // octave_map (or octave_scalar_map) object.
 
       if (! val.isstruct ())
         panic_impossible ();
@@ -710,18 +744,18 @@ octave_user_function::restore_warning_st
       octave::interpreter& interp
         = octave::__get_interpreter__ ("octave_user_function::restore_warning_states");
 
       for (octave_idx_type i = 0; i < m.numel (); i++)
         Fwarning (interp, ovl (states(i), ids(i)));
     }
 }
 
-DEFUN (nargin, args, ,
-       doc: /* -*- texinfo -*-
+DEFMETHOD (nargin, interp, args, ,
+           doc: /* -*- texinfo -*-
 @deftypefn  {} {} nargin ()
 @deftypefnx {} {} nargin (@var{fcn})
 Report the number of input arguments to a function.
 
 Called from within a function, return the number of arguments passed to the
 function.  At the top level, return the number of command line arguments
 passed to Octave.
 
@@ -750,24 +784,26 @@ Programming Note: @code{nargin} does not
 {
   int nargin = args.length ();
 
   if (nargin > 1)
     print_usage ();
 
   octave_value retval;
 
+  symbol_table& symtab = interp.get_symbol_table ();
+
   if (nargin == 1)
     {
       octave_value func = args(0);
 
       if (func.is_string ())
         {
           std::string name = func.string_value ();
-          func = symbol_table::find_function (name);
+          func = symtab.find_function (name);
           if (func.is_undefined ())
             error ("nargin: invalid function name: %s", name.c_str ());
         }
 
       octave_function *fcn_val = func.function_value (true);
       if (! fcn_val)
         error ("nargin: FCN must be a string or function handle");
 
@@ -786,27 +822,27 @@ Programming Note: @code{nargin} does not
       octave::tree_parameter_list *param_list = fcn->parameter_list ();
 
       retval = (param_list ? param_list->length () : 0);
       if (fcn->takes_varargs ())
         retval = -1 - retval;
     }
   else
     {
-      retval = symbol_table::varval (".nargin.");
+      retval = symtab.varval (".nargin.");
 
       if (retval.is_undefined ())
         retval = 0;
     }
 
   return retval;
 }
 
-DEFUN (nargout, args, ,
-       doc: /* -*- texinfo -*-
+DEFMETHOD (nargout, interp,args, ,
+           doc: /* -*- texinfo -*-
 @deftypefn  {} {} nargout ()
 @deftypefnx {} {} nargout (@var{fcn})
 Report the number of output arguments from a function.
 
 Called from within a function, return the number of values the caller
 expects to receive.  At the top level, @code{nargout} with no argument is
 undefined and will produce an error.
 
@@ -857,24 +893,26 @@ returns -1 for all anonymous functions.
 {
   int nargin = args.length ();
 
   if (nargin > 1)
     print_usage ();
 
   octave_value retval;
 
+  symbol_table& symtab = interp.get_symbol_table ();
+
   if (nargin == 1)
     {
       octave_value func = args(0);
 
       if (func.is_string ())
         {
           std::string name = func.string_value ();
-          func = symbol_table::find_function (name);
+          func = symtab.find_function (name);
           if (func.is_undefined ())
             error ("nargout: invalid function name: %s", name.c_str ());
         }
 
       if (func.is_inline_function ())
         return ovl (1);
 
       if (func.is_function_handle ())
@@ -906,20 +944,20 @@ returns -1 for all anonymous functions.
 
       retval = (ret_list ? ret_list->length () : 0);
 
       if (fcn->takes_var_return ())
         retval = -1 - retval;
     }
   else
     {
-      if (symbol_table::at_top_level ())
+      if (symtab.at_top_level ())
         error ("nargout: invalid call at top level");
 
-      retval = symbol_table::varval (".nargout.");
+      retval = symtab.varval (".nargout.");
 
       if (retval.is_undefined ())
         retval = 0;
     }
 
   return retval;
 }
 
@@ -955,18 +993,18 @@ static bool val_in_table (const Matrix& 
 static bool isargout1 (int nargout, const Matrix& ignored, double k)
 {
   if (k != octave::math::round (k) || k <= 0)
     error ("isargout: K must be a positive integer");
 
   return (k == 1 || k <= nargout) && ! val_in_table (ignored, k);
 }
 
-DEFUN (isargout, args, ,
-       doc: /* -*- texinfo -*-
+DEFMETHOD (isargout, interp, args, ,
+           doc: /* -*- texinfo -*-
 @deftypefn {} {} isargout (@var{k})
 Within a function, return a logical value indicating whether the argument
 @var{k} will be assigned to a variable on output.
 
 If the result is false, the argument has been ignored during the function
 call through the use of the tilde (~) special output argument.  Functions
 can use @code{isargout} to avoid performing unnecessary calculations for
 outputs which are unwanted.
@@ -976,23 +1014,25 @@ false.  @var{k} can also be an array, in
 element-by-element and a logical array is returned.  At the top level,
 @code{isargout} returns an error.
 @seealso{nargout, varargout, nthargout}
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
-  if (symbol_table::at_top_level ())
+  symbol_table& symtab = interp.get_symbol_table ();
+
+  if (symtab.at_top_level ())
     error ("isargout: invalid call at top level");
 
-  int nargout1 = symbol_table::varval (".nargout.").int_value ();
+  int nargout1 = symtab.varval (".nargout.").int_value ();
 
   Matrix ignored;
-  octave_value tmp = symbol_table::varval (".ignored.");
+  octave_value tmp = symtab.varval (".ignored.");
   if (tmp.is_defined ())
     ignored = tmp.matrix_value ();
 
   if (args(0).is_scalar_type ())
     {
       double k = args(0).double_value ();
 
       return ovl (isargout1 (nargout1, ignored, k));
diff --git a/libinterp/octave-value/ov-usr-fcn.h b/libinterp/octave-value/ov-usr-fcn.h
--- a/libinterp/octave-value/ov-usr-fcn.h
+++ b/libinterp/octave-value/ov-usr-fcn.h
@@ -217,17 +217,17 @@ public:
 
   int ending_line (void) const { return end_location_line; }
   int ending_column (void) const { return end_location_column; }
 
   void maybe_relocate_end (void);
 
   void stash_parent_fcn_name (const std::string& p) { parent_name = p; }
 
-  void stash_parent_fcn_scope (symbol_table::scope_id ps) { parent_scope = ps; }
+  void stash_parent_fcn_scope (symbol_table::scope_id ps);
 
   void stash_leading_comment (octave_comment_list *lc) { lead_comm = lc; }
 
   void stash_trailing_comment (octave_comment_list *tc) { trail_comm = tc; }
 
   void mark_fcn_file_up_to_date (const octave::sys::time& t) { t_checked = t; }
 
   void stash_fcn_file_time (const octave::sys::time& t)
@@ -251,31 +251,23 @@ public:
   octave::sys::time time_checked (void) const { return t_checked; }
 
   void mark_as_system_fcn_file (void);
 
   bool is_system_fcn_file (void) const { return system_fcn_file; }
 
   bool is_user_function (void) const { return true; }
 
-  void erase_subfunctions (void)
-  {
-    symbol_table::erase_subfunctions_in_scope (local_scope);
-  }
+  void erase_subfunctions (void);
 
   bool takes_varargs (void) const;
 
   bool takes_var_return (void) const;
 
-  void mark_as_private_function (const std::string& cname = "")
-  {
-    symbol_table::mark_subfunctions_in_scope_as_private (local_scope, cname);
-
-    octave_function::mark_as_private_function (cname);
-  }
+  void mark_as_private_function (const std::string& cname = "");
 
   void lock_subfunctions (void);
 
   void unlock_subfunctions (void);
 
   std::map<std::string, octave_value> subfunctions (void) const;
 
   bool has_subfunctions (void) const;
@@ -396,16 +388,19 @@ private:
 
   enum class_ctor_type
   {
     none,
     legacy,
     classdef
   };
 
+  // Our symbol table scope.
+  symbol_table::scope *m_scope;
+
   // List of arguments for this function.  These are local variables.
   octave::tree_parameter_list *param_list;
 
   // List of parameters we return.  These are also local variables in
   // this function.
   octave::tree_parameter_list *ret_list;
 
   // The list of commands that make up the body of this function.
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -77,16 +77,17 @@ along with Octave; see the file COPYING.
 #include "ov-typeinfo.h"
 #include "ov-null-mat.h"
 #include "ov-lazy-idx.h"
 #include "ov-java.h"
 
 #include "defun.h"
 #include "error.h"
 #include "errwarn.h"
+#include "interpreter-private.h"
 #include "pager.h"
 #include "parse.h"
 #include "pr-output.h"
 #include "symtab.h"
 #include "utils.h"
 #include "variables.h"
 
 // We are likely to have a lot of octave_value objects to allocate, so
@@ -2492,17 +2493,19 @@ do_colon_op (const octave_value& base, c
 
       if (base.isobject ())
         dispatch_type = base.class_name ();
       else if (increment.is_defined () && increment.isobject ())
         dispatch_type = increment.class_name ();
       else
         dispatch_type = limit.class_name ();
 
-      octave_value meth = symbol_table::find_method ("colon", dispatch_type);
+      symbol_table& symtab = octave::__get_symbol_table__ ("do_colon_op");
+
+      octave_value meth = symtab.find_method ("colon", dispatch_type);
 
       if (! meth.is_defined ())
         error ("colon method not defined for %s class", dispatch_type.c_str ());
 
       octave_value_list args;
 
       if (increment.is_defined ())
         {
diff --git a/libinterp/octave.cc b/libinterp/octave.cc
--- a/libinterp/octave.cc
+++ b/libinterp/octave.cc
@@ -320,33 +320,28 @@ namespace octave
     size_t pos = pname.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
     m_program_name = (pos != std::string::npos) ? pname.substr (pos+1) : pname;
   }
 
   void
   application::intern_argv (const string_vector& args)
   {
-    assert (symbol_table::at_top_level ());
-
     octave_idx_type nargs = args.numel ();
 
     if (nargs > 0)
       {
         // Skip first argument (program name).
         nargs--;
 
         m_argv.resize (nargs);
 
         for (octave_idx_type i = 0; i < nargs; i++)
           m_argv[i] = args[i+1];
       }
-
-    symbol_table::assign (".nargin.", nargs);
-    symbol_table::mark_hidden (".nargin.");
   }
 
   void application::interactive (bool arg)
   {
     interpreter *interp = (instance ? instance->m_interpreter : 0);
 
     if (interp)
       interp->interactive (arg);
diff --git a/libinterp/operators/op-class.cc b/libinterp/operators/op-class.cc
--- a/libinterp/operators/op-class.cc
+++ b/libinterp/operators/op-class.cc
@@ -22,16 +22,17 @@ along with Octave; see the file COPYING.
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include "oct-time.h"
 
 #include "errwarn.h"
+#include "interpreter-private.h"
 #include "load-path.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-class.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "symtab.h"
 #include "parse.h"
@@ -41,17 +42,19 @@ along with Octave; see the file COPYING.
 #define DEF_CLASS_UNOP(name)                                            \
   static octave_value                                                   \
   oct_unop_ ## name (const octave_value& a)                             \
   {                                                                     \
     octave_value retval;                                                \
                                                                         \
     std::string class_name = a.class_name ();                           \
                                                                         \
-    octave_value meth = symbol_table::find_method (#name, class_name);  \
+    symbol_table& symtab = octave::__get_symbol_table__ ("oct_unop_" #name);    \
+                                                                        \
+    octave_value meth = symtab.find_method (#name, class_name);         \
                                                                         \
     if (meth.is_undefined ())                                           \
       error ("%s method not defined for %s class", #name,               \
              class_name.c_str ());                                      \
                                                                         \
     octave_value_list args;                                             \
                                                                         \
     args(0) = a;                                                        \
@@ -76,17 +79,19 @@ DEF_CLASS_UNOP (ctranspose)
   static octave_value                                                   \
   oct_binop_ ## name (const octave_value& a1, const octave_value& a2)   \
   {                                                                     \
     octave_value retval;                                                \
                                                                         \
     std::string dispatch_type                                           \
       = (a1.isobject () ? a1.class_name () : a2.class_name ());        \
                                                                         \
-    octave_value meth = symbol_table::find_method (#name, dispatch_type); \
+    symbol_table& symtab = octave::__get_symbol_table__ ("oct_unop_" #name);    \
+                                                                        \
+    octave_value meth = symtab.find_method (#name, dispatch_type);      \
                                                                         \
     if (meth.is_undefined ())                                           \
       error ("%s method not defined for %s class", #name,               \
              dispatch_type.c_str ());                                   \
                                                                         \
     octave_value_list args;                                             \
                                                                         \
     args(1) = a2;                                                       \
diff --git a/libinterp/parse-tree/bp-table.cc b/libinterp/parse-tree/bp-table.cc
--- a/libinterp/parse-tree/bp-table.cc
+++ b/libinterp/parse-tree/bp-table.cc
@@ -190,17 +190,19 @@ get_user_code (const std::string& fname)
               name[i] = octave::sys::file_ops::dir_sep_char ();
         }
 
       size_t name_len = name.length ();
 
       if (! name.empty () && name_len > 2 && name.substr (name_len-2) == ".m")
         name = name.substr (0, name_len-2);
 
-      octave_value fcn = symbol_table::find_function (name);
+      symbol_table& symtab = octave::__get_symbol_table__ ("get_user_code");
+
+      octave_value fcn = symtab.find_function (name);
 
       if (fcn.is_defined () && fcn.is_user_code ())
         dbg_fcn = fcn.user_code_value ();
     }
 
   return dbg_fcn;
 }
 
diff --git a/libinterp/parse-tree/jit-typeinfo.cc b/libinterp/parse-tree/jit-typeinfo.cc
--- a/libinterp/parse-tree/jit-typeinfo.cc
+++ b/libinterp/parse-tree/jit-typeinfo.cc
@@ -2044,19 +2044,21 @@ jit_typeinfo::register_intrinsic (const 
   llvm::Value *ret = builder.CreateCall (ifun, fargs);
   fn.do_return (builder, ret);
   paren_subsref_fn.add_overload (fn);
 }
 
 octave_builtin *
 jit_typeinfo::find_builtin (const std::string& name)
 {
+  symbol_table& symtab = octave::__get_symbol_table__ ("jit_typeinfo::find_builtin");
+
   // FIXME: Finalize what we want to store in octave_builtin, then add functions
   // to access these values in octave_value
-  octave_value ov_builtin = symbol_table::find (name);
+  octave_value ov_builtin = symtab.find (name);
   return dynamic_cast<octave_builtin *> (ov_builtin.internal_rep ());
 }
 
 void
 jit_typeinfo::register_generic (const std::string& name, jit_type *result,
                                 const std::vector<jit_type *>& args)
 {
   octave_builtin *builtin = find_builtin (name);
diff --git a/libinterp/parse-tree/lex.h b/libinterp/parse-tree/lex.h
--- a/libinterp/parse-tree/lex.h
+++ b/libinterp/parse-tree/lex.h
@@ -30,16 +30,18 @@ along with Octave; see the file COPYING.
 #include <list>
 #include <set>
 #include <stack>
 
 #include "comment-list.h"
 #include "input.h"
 #include "token.h"
 
+class symbol_table;
+
 namespace octave
 {
   class interpreter;
 
   // Is the given string a keyword?
   extern bool is_keyword (const std::string& s);
 
   // For communication between the lexer and parser.
@@ -50,47 +52,48 @@ namespace octave
   public:
 
     // Track symbol table information when parsing functions.
 
     class symbol_table_context
     {
     public:
 
-      symbol_table_context (void) : frame_stack () { }
+      symbol_table_context (void)
+        : frame_stack () { }
 
-      void clear (void)
-      {
-        while (! frame_stack.empty ())
-          frame_stack.pop ();
-      }
+      ~symbol_table_context (void);
+
+      void clear (void);
 
       bool empty (void) const { return frame_stack.empty (); }
 
+      size_t size (void) const { return frame_stack.size (); }
+
       void pop (void)
       {
         if (empty ())
           panic_impossible ();
 
-        frame_stack.pop ();
+        frame_stack.pop_front ();
       }
 
-      void push (symbol_table::scope_id scope = symbol_table::current_scope ())
+      void push (void);
+
+      void push (symbol_table::scope_id scope)
       {
-        frame_stack.push (scope);
+        frame_stack.push_front (scope);
       }
 
-      symbol_table::scope_id curr_scope (void) const
-      {
-        return empty () ? symbol_table::current_scope () : frame_stack.top ();
-      }
+      symbol_table::scope_id curr_scope (void) const;
+      symbol_table::scope_id parent_scope (void) const;
 
     private:
 
-      std::stack<symbol_table::scope_id> frame_stack;
+      std::deque<symbol_table::scope_id> frame_stack;
     };
 
     // Track nesting of square brackets, curly braces, and parentheses.
 
     class bbp_nesting_level
     {
     private:
 
diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -101,16 +101,17 @@ object) relevant global values before an
 // times.
 
 #include "Cell.h"
 #include "comment-list.h"
 #include "defun.h"
 #include "error.h"
 #include "errwarn.h"
 #include "input.h"
+#include "interpreter-private.h"
 #include "interpreter.h"
 #include "lex.h"
 #include "octave.h"
 #include "ov.h"
 #include "parse.h"
 #include "pt-all.h"
 #include "symtab.h"
 #include "token.h"
@@ -2075,16 +2076,77 @@ debug information as it processes an exp
   retval = set_internal_variable (lexer_debug_flag, args, nargout,
                                   "__lexer_debug_flag__");
 
   return retval;
 }
 
 namespace octave
 {
+  lexical_feedback::symbol_table_context::~symbol_table_context (void)
+  {
+    clear ();
+  }
+
+  void
+  lexical_feedback::symbol_table_context::clear (void)
+  {
+    symbol_table& symtab
+      = octave::__get_symbol_table__ ("lexical_feedback::symbol_table_context::push");
+
+    while (! frame_stack.empty ())
+      {
+        symbol_table::scope_id sid = curr_scope ();
+
+        if (sid > 0)
+          {
+            // FIXME: for now we need to ensure that the scope_id has a
+            // scope object associated with it.  Calling clear_variables
+            // should do that for us.  In the future, this should not be
+            // necessary.
+            symtab.clear_variables (sid);
+
+            symtab.erase_scope (sid);
+          }
+
+        frame_stack.pop_front ();
+      }
+  }
+
+  void
+  lexical_feedback::symbol_table_context::push (void)
+  {
+    symbol_table& symtab
+      = octave::__get_symbol_table__ ("lexical_feedback::symbol_table_context::push");
+
+    push (symtab.current_scope ());
+  }
+
+  symbol_table::scope_id
+  lexical_feedback::symbol_table_context::curr_scope (void) const
+  {
+    if (empty ())
+      {
+        symbol_table& symtab
+          = octave::__get_symbol_table__ ("lexical_feedback::symbol_table_context::curr_scope");
+
+        return symtab.current_scope ();
+      }
+    else
+      return frame_stack.front ();
+  }
+
+  symbol_table::scope_id
+  lexical_feedback::symbol_table_context::parent_scope (void) const
+  {
+    size_t sz = size ();
+
+    return sz > 1 ? frame_stack[1] : (sz == 1 ? frame_stack[0] : -1);
+  }
+
   lexical_feedback::~lexical_feedback (void)
   {
     tokens.clear ();
   }
 
   void
   lexical_feedback::init (void)
   {
@@ -2474,19 +2536,21 @@ namespace octave
           }
       }
 
     return retval;
   }
 
   bool
   base_lexer::is_variable (const std::string& name,
-                                  symbol_table::scope_id scope)
+                           symbol_table::scope_id scope)
   {
-    return (symbol_table::is_variable (name, scope)
+    symbol_table& symtab = octave::__get_symbol_table__ ("base_lexer::is_variable");
+
+    return (symtab.is_variable (name, scope)
             || (pending_local_variables.find (name)
                 != pending_local_variables.end ()));
   }
 
   // Handle keywords.  Return -1 if the keyword should be ignored.
 
   int
   base_lexer::is_keyword_token (const std::string& s)
@@ -3104,17 +3168,20 @@ namespace octave
 
         return kw_token;
       }
 
     // Find the token in the symbol table.
 
     symbol_table::scope_id sid = symtab_context.curr_scope ();
 
-    token *tok = new token (NAME, &(symbol_table::insert (ident, sid)),
+    symbol_table& symtab
+      = octave::__get_symbol_table__ ("base_lexer::handle_identifier");
+
+    token *tok = new token (NAME, &(symtab.insert (ident, sid)),
                             input_line_number, current_input_column);
 
     // The following symbols are handled specially so that things like
     //
     //   pi +1
     //
     // are parsed as an addition expression instead of as a command-style
     // function call with the argument "+1".
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -1259,17 +1259,18 @@ push_fcn_symtab : // empty
                   {
                     $$ = 0;
 
                     parser.curr_fcn_depth++;
 
                     if (parser.max_fcn_depth < parser.curr_fcn_depth)
                       parser.max_fcn_depth = parser.curr_fcn_depth;
 
-                    lexer.symtab_context.push (symbol_table::alloc_scope ());
+                    symbol_table& symtab = octave::__get_symbol_table__ ("push_fcn_symtab");
+                    lexer.symtab_context.push (symtab.alloc_scope ());
 
                     parser.function_scopes.push (lexer.symtab_context.curr_scope ());
 
                     if (! lexer.reading_script_file
                         && parser.curr_fcn_depth == 1
                         && ! parser.parsing_subfunctions)
                       parser.primary_fcn_scope
                         = lexer.symtab_context.curr_scope ();
@@ -1289,17 +1290,18 @@ push_fcn_symtab : // empty
 
 param_list_beg  : '('
                   {
                     $$ = 0;
                     lexer.looking_at_parameter_list = true;
 
                     if (lexer.looking_at_function_handle)
                       {
-                        lexer.symtab_context.push (symbol_table::alloc_scope ());
+                        symbol_table& symtab = octave::__get_symbol_table__ ("push_fcn_symtab");
+                        lexer.symtab_context.push (symtab.alloc_scope ());
                         lexer.looking_at_function_handle--;
                         lexer.looking_at_anon_fcn_args = true;
                       }
                   }
                 ;
 
 param_list_end  : ')'
                   {
@@ -1615,16 +1617,18 @@ function_end    : END
 classdef_beg    : CLASSDEF
                   {
                     if (! lexer.reading_classdef_file)
                       {
                         parser.bison_error ("classdef must appear inside a file containing only a class definition");
                         YYABORT;
                       }
 
+                    // Create invalid parent scope.
+                    lexer.symtab_context.push (-1);
                     lexer.parsing_classdef = true;
                     $$ = $1;
                   }
                 ;
 
 classdef        : classdef_beg stash_comment opt_attr_list identifier opt_superclass_list opt_sep class_body opt_sep END
                   {
                     YYUSE ($6);
@@ -2480,27 +2484,29 @@ namespace octave
   {
     // FIXME: need to get these from the location of the @ symbol.
     int l = lexer.input_line_number;
     int c = lexer.current_input_column;
 
     tree_parameter_list *ret_list = 0;
 
     symbol_table::scope_id fcn_scope = lexer.symtab_context.curr_scope ();
+    symbol_table::scope_id parent_scope = lexer.symtab_context.parent_scope ();
 
     lexer.symtab_context.pop ();
 
     stmt->set_print_flag (false);
 
     tree_statement_list *body = new tree_statement_list (stmt);
 
     body->mark_as_anon_function_body ();
 
     tree_anon_fcn_handle *retval
-      = new tree_anon_fcn_handle (param_list, ret_list, body, fcn_scope, l, c);
+      = new tree_anon_fcn_handle (param_list, ret_list, body, fcn_scope,
+                                  parent_scope, l, c);
     // FIXME: Stash the filename.  This does not work and produces
     // errors when executed.
     //retval->stash_file_name (lexer.fcn_file_name);
 
     return retval;
   }
 
   // Build a binary expression.
@@ -3382,52 +3388,52 @@ namespace octave
       {
         std::string nm = fcn->name ();
         std::string file = fcn->fcn_file_name ();
 
         std::string tmp = nm;
         if (! file.empty ())
           tmp += ": " + file;
 
-        symbol_table::cache_name (fcn->scope (), tmp);
+        symbol_table& symtab
+          = octave::__get_symbol_table__ ("base_parser::finish_function");
+
+        symtab.cache_name (fcn->scope (), tmp);
 
         if (lc)
           fcn->stash_leading_comment (lc);
 
         fcn->define_ret_list (ret_list);
 
         if (curr_fcn_depth > 1 || parsing_subfunctions)
           {
             fcn->stash_fcn_location (l, c);
 
             if (endfunction_found && function_scopes.size () > 1)
               {
-                symbol_table::scope_id pscope
-                  = function_scopes.parent_scope ();
-
-                symbol_table::install_nestfunction (nm, octave_value (fcn),
-                                                    pscope);
+                symbol_table::scope_id pscope = function_scopes.parent_scope ();
+
+                symtab.install_nestfunction (nm, octave_value (fcn), pscope);
               }
             else
               {
                 fcn->mark_as_subfunction ();
                 subfunction_names.push_back (nm);
 
-                symbol_table::install_subfunction (nm, octave_value (fcn),
-                                                   primary_fcn_scope);
+                symtab.install_subfunction (nm, octave_value (fcn),
+                                            primary_fcn_scope);
                }
           }
 
         if (fcn)
           {
             if (parsing_local_functions )
-              symbol_table::install_local_function (nm, octave_value (fcn),
-                                                    file);
+              symtab.install_local_function (nm, octave_value (fcn), file);
             else if (curr_fcn_depth == 1)
-              symbol_table::update_nest (fcn->scope ());
+              symtab.update_nest (fcn->scope ());
           }
 
         if (! lexer.reading_fcn_file && curr_fcn_depth == 1)
           {
             // We are either reading a script file or defining a function
             // at the command line, so this definition creates a
             // tree_function object that is placed in the parse tree.
             // Otherwise, it is just inserted in the symbol table,
@@ -3466,31 +3472,37 @@ namespace octave
   base_parser::make_superclass_ref (const std::string& method_nm,
                                     const std::string& class_nm)
   {
     octave_value_list args;
 
     args(1) = class_nm;
     args(0) = method_nm;
 
+    symbol_table& symtab
+      = octave::__get_symbol_table__ ("base_parser::make_superclass_ref");
+
     octave_value fcn
-      = symbol_table::find_built_in_function ("__superclass_reference__");
+      = symtab.find_built_in_function ("__superclass_reference__");
 
     return new tree_funcall (fcn, args);
   }
 
   tree_funcall *
   base_parser::make_meta_class_query (const std::string& class_nm)
   {
     octave_value_list args;
 
     args(0) = class_nm;
 
+    symbol_table& symtab
+      = octave::__get_symbol_table__ ("base_parser::make_meta_class_query");
+
     octave_value fcn
-      = symbol_table::find_built_in_function ("__meta_class_query__");
+      = symtab.find_built_in_function ("__meta_class_query__");
 
     return new tree_funcall (fcn, args);
   }
 
   // A CLASSDEF block defines a class that has a constructor and other
   // methods, but it is not an executable command.  Parsing the block
   // makes some changes in the symbol table (inserting the constructor
   // and methods, and adding to the list of known objects) and creates
@@ -3501,16 +3513,18 @@ namespace octave
                               tree_classdef_attribute_list *a,
                               tree_identifier *id,
                               tree_classdef_superclass_list *sc,
                               tree_classdef_body *body, token *end_tok,
                               octave_comment_list *lc)
   {
     tree_classdef *retval = 0;
 
+    lexer.symtab_context.pop ();
+
     std::string cls_name = id->name ();
 
     std::string nm = lexer.fcn_file_name;
 
     size_t pos = nm.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
     if (pos != std::string::npos)
       nm = lexer.fcn_file_name.substr (pos+1);
@@ -4555,17 +4569,19 @@ namespace octave
       {
         retval->stash_dir_name (dir_name);
         retval->stash_package_name (package_name);
 
         if (retval->is_user_function ())
           {
             symbol_table::scope_id id = retval->scope ();
 
-            symbol_table::stash_dir_name_for_subfunctions (id, dir_name);
+            symbol_table& symtab = octave::__get_symbol_table__ ("load_fcn_from_file");
+
+            symtab.stash_dir_name_for_subfunctions (id, dir_name);
           }
       }
 
     return retval;
   }
 }
 
 DEFMETHOD (autoload, interp, args, ,
@@ -4677,17 +4693,18 @@ not loaded anymore during the current Oc
         autoload_map[argv[1]] = nm;
       else if (nargin == 3)
         {
           if (argv[3] != "remove")
             error_with_id ("Octave:invalid-input-arg",
                            "autoload: third argument can only be 'remove'");
 
           // Remove function from symbol table and autoload map.
-          symbol_table::clear_dld_function (argv[1]);
+          symbol_table& symtab = interp.get_symbol_table ();
+          symtab.clear_dld_function (argv[1]);
           autoload_map.erase (argv[1]);
         }
     }
 
   return retval;
 }
 
 namespace octave
@@ -4772,17 +4789,18 @@ namespace octave
     size_t extension = file_name.find_last_of ('.');
     if (extension == std::string::npos)
       extension = file_name.length ();
 
     std::string symbol = file_name.substr (dir_end, extension - dir_end);
     std::string full_name = octave::sys::canonicalize_file_name (file_name);
 
     // Check if this file is already loaded (or in the path)
-    octave_value loaded_sym = symbol_table::find (symbol);
+    symbol_table& symtab = octave::__get_symbol_table__ ("source_file");
+    octave_value loaded_sym = symtab.find (symbol);
     if (loaded_sym.is_function ())
       {
         fcn = loaded_sym.function_value ();
         if (fcn)
           {
             if (octave::sys::canonicalize_file_name (fcn->fcn_file_name ())
                 != full_name)
               {
@@ -4948,17 +4966,19 @@ namespace octave
     necessarily the same as @c nargout.
 
   */
   octave_value_list
   feval (const std::string& name, const octave_value_list& args, int nargout)
   {
     octave_value_list retval;
 
-    octave_value fcn = symbol_table::find_function (name, args);
+    symbol_table& symtab = octave::__get_symbol_table__ ("feval");
+
+    octave_value fcn = symtab.find_function (name, args);
 
     if (fcn.is_defined ())
       {
         tree_evaluator& tw = __get_evaluator__ ("feval");
 
         octave_function *of = fcn.function_value ();
 
         retval = of->call (tw, nargout, args);
@@ -5091,18 +5111,18 @@ instead.
 @end deftypefn */)
 {
   if (args.length () == 0)
     print_usage ();
 
   return octave::feval (args, nargout);
 }
 
-DEFUN (builtin, args, nargout,
-       doc: /* -*- texinfo -*-
+DEFMETHOD (builtin, interp, args, nargout,
+           doc: /* -*- texinfo -*-
 @deftypefn {} {[@dots{}] =} builtin (@var{f}, @dots{})
 Call the base function @var{f} even if @var{f} is overloaded to another
 function for the given type signature.
 
 This is normally useful when doing object-oriented programming and there is
 a requirement to call one of Octave's base functions rather than the
 overloaded one of a new class.
 
@@ -5124,17 +5144,19 @@ builtin ("sin", 0)
 {
   octave_value_list retval;
 
   if (args.length () == 0)
     print_usage ();
 
   const std::string name (args(0).xstring_value ("builtin: function name (F) must be a string"));
 
-  octave_value fcn = symbol_table::builtin_find (name);
+  symbol_table& symtab = interp.get_symbol_table ();
+
+  octave_value fcn = symtab.builtin_find (name);
 
   if (fcn.is_defined ())
     retval = octave::feval (fcn.function_value (), args.splice (0, 1), nargout);
   else
     error ("builtin: lookup for symbol '%s' failed", name.c_str ());
 
   return retval;
 }
@@ -5416,17 +5438,19 @@ may be either @qcode{"base"} or @qcode{"
     {
       // Put the check here so that we don't slow down assignments
       // generally.  Any that go through Octave's parser should have
       // already been checked.
 
       if (octave::is_keyword (nm))
         error ("assignin: invalid assignment to keyword '%s'", nm.c_str ());
 
-      symbol_table::assign (nm, args(2));
+      symbol_table& symtab = interp.get_symbol_table ();
+
+      symtab.assign (nm, args(2));
     }
   else
     error ("assignin: invalid variable name in argument VARNAME");
 
   return retval;
 }
 
 /*
diff --git a/libinterp/parse-tree/pt-arg-list.cc b/libinterp/parse-tree/pt-arg-list.cc
--- a/libinterp/parse-tree/pt-arg-list.cc
+++ b/libinterp/parse-tree/pt-arg-list.cc
@@ -119,18 +119,18 @@ namespace octave
   }
 }
 
 static const octave_value *indexed_object = nullptr;
 static int index_position = 0;
 static int num_indices = 0;
 
 // END is documented in op-kw-docs.
-DEFCONSTFUN (end, , ,
-             doc: /* -*- texinfo -*-
+DEFCONSTMETHOD (end, interp, , ,
+                doc: /* -*- texinfo -*-
 @deftypefn {} {} end
 Last element of an array or the end of any @code{for}, @code{parfor},
 @code{if}, @code{do}, @code{while}, @code{function}, @code{switch},
 @code{try}, or @code{unwind_protect} block.
 
 As an index of an array, the magic index @qcode{"end"} refers to the
 last valid entry in an indexing operation.
 
@@ -160,17 +160,19 @@ Example:
       octave_value_list args;
 
       args(2) = num_indices;
       args(1) = index_position + 1;
       args(0) = *indexed_object;
 
       std::string class_name = indexed_object->class_name ();
 
-      octave_value meth = symbol_table::find_method ("end", class_name);
+      symbol_table& symtab = interp.get_symbol_table ();
+
+      octave_value meth = symtab.find_method ("end", class_name);
 
       if (meth.is_defined ())
         return octave::feval (meth.function_value (), args, 1);
     }
 
   dim_vector dv = indexed_object->dims ();
   int ndims = dv.ndims ();
 
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -32,16 +32,17 @@ along with Octave; see the file COPYING.
 #include <typeinfo>
 
 #include "bp-table.h"
 #include "call-stack.h"
 #include "defun.h"
 #include "error.h"
 #include "errwarn.h"
 #include "input.h"
+#include "interpreter-private.h"
 #include "interpreter.h"
 #include "ov-fcn-handle.h"
 #include "ov-usr-fcn.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 #include "profiler.h"
 #include "pt-all.h"
 #include "pt-eval.h"
@@ -89,57 +90,58 @@ namespace octave
   void
   tree_evaluator::visit_anon_fcn_handle (tree_anon_fcn_handle& expr)
   {
     // FIXME: should CMD_LIST be limited to a single expression?
     // I think that is what Matlab does.
 
     tree_parameter_list *param_list = expr.parameter_list ();
     tree_parameter_list *ret_list = expr.return_list ();
-    tree_statement_list *cmd_list = expr.body ();
-    symbol_table::scope_id this_scope = expr.scope ();
-
-    symbol_table::scope_id new_scope = symbol_table::dup_scope (this_scope);
-
-    if (new_scope > 0)
-      symbol_table::inherit (new_scope, symbol_table::current_scope (),
-                             symbol_table::current_context ());
-
-    octave_user_function *uf
+    tree_statement_list *stmt_list = expr.body ();
+
+    symbol_table::scope_id af_sid = expr.scope ();
+
+    symbol_table& symtab = m_interpreter.get_symbol_table ();
+
+    symbol_table::scope_id af_parent_sid
+      = expr.has_parent_scope () ? symtab.current_scope () : -1;
+
+    symbol_table::scope_id new_scope = symtab.dup_scope (af_sid);
+
+    if (new_scope > 0 && af_parent_sid > 0)
+      symtab.inherit (new_scope, af_parent_sid);
+
+    octave_user_function *af
       = new octave_user_function (new_scope,
                                   param_list ? param_list->dup (new_scope, 0) : 0,
                                   ret_list ? ret_list->dup (new_scope, 0) : 0,
-                                  cmd_list ? cmd_list->dup (new_scope, 0) : 0);
+                                  stmt_list ? stmt_list->dup (new_scope, 0) : 0);
+
+    if (af_parent_sid > 0)
+      symtab.set_parent (new_scope, af_parent_sid);
 
     octave_function *curr_fcn = m_call_stack.current ();
 
     if (curr_fcn)
       {
         // FIXME: maybe it would be better to just stash curr_fcn
         // instead of individual bits of info about it?
 
-        uf->stash_parent_fcn_name (curr_fcn->name ());
-        uf->stash_dir_name (curr_fcn->dir_name ());
-
-        symbol_table::scope_id parent_scope = curr_fcn->parent_fcn_scope ();
-
-        if (parent_scope < 0)
-          parent_scope = curr_fcn->scope ();
-
-        uf->stash_parent_fcn_scope (parent_scope);
+        af->stash_parent_fcn_name (curr_fcn->name ());
+        af->stash_dir_name (curr_fcn->dir_name ());
 
         if (curr_fcn->is_class_method () || curr_fcn->is_class_constructor ())
-          uf->stash_dispatch_class (curr_fcn->dispatch_class ());
+          af->stash_dispatch_class (curr_fcn->dispatch_class ());
       }
 
-    uf->mark_as_anonymous_function ();
-    uf->stash_fcn_file_name (expr.file_name ());
-    uf->stash_fcn_location (expr.line (), expr.column ());
-
-    octave_value ov_fcn (uf);
+    af->mark_as_anonymous_function ();
+    af->stash_fcn_file_name (expr.file_name ());
+    af->stash_fcn_location (expr.line (), expr.column ());
+
+    octave_value ov_fcn (af);
 
     octave_value fh (octave_fcn_binder::maybe_binder (ov_fcn, this));
 
     m_value_stack.push (ovl (fh));
   }
 
   void
   tree_evaluator::visit_argument_list (tree_argument_list&)
@@ -355,17 +357,19 @@ namespace octave
             tmp1(0) = ov_base;
           }
         else
           {
             tmp1(1) = ov_limit;
             tmp1(0) = ov_base;
           }
 
-        octave_value fcn = symbol_table::find_function ("colon", tmp1);
+        symbol_table& symtab = m_interpreter.get_symbol_table ();
+
+        octave_value fcn = symtab.find_function ("colon", tmp1);
 
         if (! fcn.is_defined ())
           error ("can not find overloaded colon function");
 
         octave_value_list tmp2 = octave::feval (fcn, tmp1, 1);
 
         val = tmp2 (0);
       }
@@ -459,17 +463,19 @@ namespace octave
   tree_evaluator::initialize_undefined_parameter_list_elements
     (tree_parameter_list *param_list, const std::string& warnfor,
      int nargout, const octave_value& val)
   {
     bool warned = false;
 
     int count = 0;
 
-    octave_value tmp = symbol_table::varval (".ignored.");
+    symbol_table& symtab = m_interpreter.get_symbol_table ();
+
+    octave_value tmp = symtab.varval (".ignored.");
     const Matrix ignored = (tmp.is_defined () ? tmp.matrix_value () : Matrix ());
 
     octave_idx_type k = 0;
 
     for (tree_decl_elt *elt : *param_list)
       {
         if (++count > nargout)
           break;
@@ -939,22 +945,24 @@ namespace octave
     octave_value fcn = cmd.function ();
 
     octave_function *f = fcn.function_value ();
 
     if (f)
       {
         std::string nm = f->name ();
 
-        symbol_table::install_cmdline_function (nm, fcn);
+        symbol_table& symtab = m_interpreter.get_symbol_table ();
+
+        symtab.install_cmdline_function (nm, fcn);
 
         // Make sure that any variable with the same name as the new
         // function is cleared.
 
-        symbol_table::assign (nm);
+        symtab.assign (nm);
       }
   }
 
   void
   tree_evaluator::visit_identifier (tree_identifier& expr)
   {
     octave_value_list retval;
 
@@ -1061,17 +1069,19 @@ final_index_error (octave::index_excepti
 
   if (expr->is_identifier ()
       && dynamic_cast<const octave::tree_identifier *> (expr)->is_variable ())
     {
       std::string var = expr->name ();
 
       e.set_var (var);
 
-      octave_value fcn = symbol_table::find_function (var);
+      symbol_table& symtab = octave::__get_symbol_table__ ("final_index_error");
+
+      octave_value fcn = symtab.find_function (var);
 
       if (fcn.is_function ())
         {
           octave_function *fp = fcn.function_value ();
 
           if (fp && fp->name () == var)
             extra_message = " (note: variable '" + var + "' shadows function)";
         }
diff --git a/libinterp/parse-tree/pt-fcn-handle.cc b/libinterp/parse-tree/pt-fcn-handle.cc
--- a/libinterp/parse-tree/pt-fcn-handle.cc
+++ b/libinterp/parse-tree/pt-fcn-handle.cc
@@ -23,16 +23,17 @@ along with Octave; see the file COPYING.
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include <iostream>
 
 #include "call-stack.h"
 #include "error.h"
+#include "interpreter-private.h"
 #include "ovl.h"
 #include "ov-fcn-handle.h"
 #include "pt-fcn-handle.h"
 #include "pager.h"
 #include "pt-const.h"
 #include "pt-walk.h"
 #include "variables.h"
 
@@ -58,36 +59,47 @@ namespace octave
   {
     tree_fcn_handle *new_fh = new tree_fcn_handle (nm, line (), column ());
 
     new_fh->copy_base (*this);
 
     return new_fh;
   }
 
+  tree_anon_fcn_handle::~tree_anon_fcn_handle (void)
+  {
+    delete m_parameter_list;
+    delete m_return_list;
+    delete m_statement_list;
+  }
+
   tree_expression *
   tree_anon_fcn_handle::dup (symbol_table::scope_id,
                              symbol_table::context_id) const
   {
     tree_parameter_list *param_list = parameter_list ();
     tree_parameter_list *ret_list = return_list ();
-    tree_statement_list *cmd_list = body ();
-    symbol_table::scope_id this_scope = scope ();
+    tree_statement_list *stmt_list = body ();
+
+    symbol_table::scope_id af_sid = scope ();
+    symbol_table::scope_id af_parent_sid = parent_scope ();
 
-    symbol_table::scope_id new_scope = symbol_table::dup_scope (this_scope);
+    symbol_table& symtab
+      = octave::__get_symbol_table__ ("tree_anon_fcn_handle::dup");
+
+    symbol_table::scope_id new_scope = symtab.dup_scope (af_sid);
 
     if (new_scope > 0)
-      symbol_table::inherit (new_scope, symbol_table::current_scope (),
-                             symbol_table::current_context ());
+      symtab.inherit (new_scope);
 
     tree_anon_fcn_handle *new_afh = new
       tree_anon_fcn_handle (param_list ? param_list->dup (new_scope, 0) : 0,
                             ret_list ? ret_list->dup (new_scope, 0) : 0,
-                            cmd_list ? cmd_list->dup (new_scope, 0) : 0,
-                            new_scope, line (), column ());
+                            stmt_list ? stmt_list->dup (new_scope, 0) : 0,
+                            new_scope, af_parent_sid, line (), column ());
 
     new_afh->copy_base (*this);
 
     return new_afh;
   }
 }
 
 /*
diff --git a/libinterp/parse-tree/pt-fcn-handle.h b/libinterp/parse-tree/pt-fcn-handle.h
--- a/libinterp/parse-tree/pt-fcn-handle.h
+++ b/libinterp/parse-tree/pt-fcn-handle.h
@@ -87,73 +87,81 @@ namespace octave
     std::string nm;
   };
 
   class tree_anon_fcn_handle : public tree_expression
   {
   public:
 
     tree_anon_fcn_handle (int l = -1, int c = -1)
-      : tree_expression (l, c), fcn (0), m_file_name () { }
+      : tree_expression (l, c), m_parameter_list (0), m_return_list (0),
+        m_statement_list (0), m_sid (-1), m_parent_sid (-1), m_file_name ()
+    { }
 
     tree_anon_fcn_handle (tree_parameter_list *pl, tree_parameter_list *rl,
                           tree_statement_list *cl, symbol_table::scope_id sid,
+                          symbol_table::scope_id parent_sid,
                           int l = -1, int c = -1)
-      : tree_expression (l, c),
-        fcn (new octave_user_function (sid, pl, rl, cl)),
-        m_file_name () { }
+      : tree_expression (l, c), m_parameter_list (pl), m_return_list (rl),
+        m_statement_list (cl), m_sid (sid), m_parent_sid (parent_sid),
+        m_file_name ()
+    { }
 
     // No copying!
 
     tree_anon_fcn_handle (const tree_anon_fcn_handle&) = delete;
 
     tree_anon_fcn_handle& operator = (const tree_anon_fcn_handle&) = delete;
 
-    ~tree_anon_fcn_handle (void) { delete fcn; }
+    ~tree_anon_fcn_handle (void);
 
     bool has_magic_end (void) const { return false; }
 
     bool rvalue_ok (void) const { return true; }
 
     tree_parameter_list * parameter_list (void) const
     {
-      return fcn ? fcn->parameter_list () : 0;
-    }
-
-    tree_parameter_list * return_list (void) const
-    {
-      return fcn ? fcn->return_list () : 0;
+      return m_parameter_list;
     }
 
-    tree_statement_list * body (void) const
-    {
-      return fcn ? fcn->body () : 0;
-    }
+    tree_parameter_list * return_list (void) const { return m_return_list; }
+
+    tree_statement_list * body (void) const { return m_statement_list; }
 
-    symbol_table::scope_id scope (void) const
-    {
-      return fcn ? fcn->scope () : -1;
-    }
+    symbol_table::scope_id scope (void) const { return m_sid; }
+
+    symbol_table::scope_id parent_scope (void) const { return m_parent_sid; }
+
+    bool has_parent_scope (void) const { return m_parent_sid > 0; }
 
     tree_expression * dup (symbol_table::scope_id scope,
                            symbol_table::context_id context) const;
 
-    void accept (tree_walker& tw)
-    {
-      tw.visit_anon_fcn_handle (*this);
-    }
+    void accept (tree_walker& tw) { tw.visit_anon_fcn_handle (*this); }
 
     void stash_file_name (const std::string& file) { m_file_name = file; }
 
     std::string file_name (void) const { return m_file_name; }
 
   private:
 
-    // The function.
-    octave_user_function *fcn;
+    // Inputs parameters.
+    tree_parameter_list *m_parameter_list;
+
+    // Output parameters.
+    tree_parameter_list *m_return_list;
+
+    // Function body.
+    tree_statement_list *m_statement_list;
+
+    // Function scope.
+    symbol_table::scope_id m_sid;
+
+    // Parent scope, or -1 if none.
+    symbol_table::scope_id m_parent_sid;
 
     // Filename where the handle was defined.
     std::string m_file_name;
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
diff --git a/libinterp/parse-tree/pt-id.cc b/libinterp/parse-tree/pt-id.cc
--- a/libinterp/parse-tree/pt-id.cc
+++ b/libinterp/parse-tree/pt-id.cc
@@ -20,16 +20,17 @@ along with Octave; see the file COPYING.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include "error.h"
+#include "interpreter-private.h"
 #include "ovl.h"
 #include "oct-lvalue.h"
 #include "pager.h"
 #include "parse.h"
 #include "pt-bp.h"
 #include "pt-const.h"
 #include "pt-eval.h"
 #include "pt-id.h"
@@ -70,19 +71,20 @@ namespace octave
 
   tree_identifier *
   tree_identifier::dup (symbol_table::scope_id sc,
                         symbol_table::context_id) const
   {
     // The new tree_identifier object contains a symbol_record
     // entry from the duplicated scope.
 
+    symbol_table& symtab = octave::__get_symbol_table__ ("tree_identifier::dup");
+
     // FIXME: is this the best way?
-    symbol_table::symbol_record new_sym
-      = symbol_table::find_symbol (name (), sc);
+    symbol_table::symbol_record new_sym = symtab.find_symbol (name (), sc);
 
     tree_identifier *new_id
       = new tree_identifier (new_sym, line (), column ());
 
     new_id->copy_base (*this);
 
     return new_id;
   }
diff --git a/libinterp/parse-tree/pt-id.h b/libinterp/parse-tree/pt-id.h
--- a/libinterp/parse-tree/pt-id.h
+++ b/libinterp/parse-tree/pt-id.h
@@ -49,19 +49,18 @@ namespace octave
     friend class tree_index_expression;
 
   public:
 
     tree_identifier (int l = -1, int c = -1)
       : tree_expression (l, c) { }
 
     tree_identifier (const symbol_table::symbol_record& s,
-                     int l = -1, int c = -1,
-                     symbol_table::scope_id sc = symbol_table::current_scope ())
-      : tree_expression (l, c), sym (s, sc) { }
+                     int l = -1, int c = -1)
+      : tree_expression (l, c), sym (s) { }
 
     // No copying!
 
     tree_identifier (const tree_identifier&) = delete;
 
     tree_identifier& operator = (const tree_identifier&) = delete;
 
     ~tree_identifier (void) = default;
diff --git a/libinterp/parse-tree/pt-idx.cc b/libinterp/parse-tree/pt-idx.cc
--- a/libinterp/parse-tree/pt-idx.cc
+++ b/libinterp/parse-tree/pt-idx.cc
@@ -21,16 +21,17 @@ along with Octave; see the file COPYING.
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include "Cell.h"
 #include "error.h"
+#include "interpreter-private.h"
 #include "oct-map.h"
 #include "ovl.h"
 #include "oct-lvalue.h"
 #include "ov.h"
 #include "pager.h"
 #include "pt-arg-list.h"
 #include "pt-bp.h"
 #include "pt-eval.h"
@@ -210,17 +211,19 @@ final_index_error (octave::index_excepti
 
   if (expr->is_identifier ()
       && dynamic_cast<const octave::tree_identifier *> (expr)->is_variable ())
     {
       std::string var = expr->name ();
 
       e.set_var (var);
 
-      octave_value fcn = symbol_table::find_function (var);
+      symbol_table& symtab = octave::__get_symbol_table__ ("final_index_error");
+
+      octave_value fcn = symtab.find_function (var);
 
       if (fcn.is_function ())
         {
           octave_function *fp = fcn.function_value ();
 
           if (fp && fp->name () == var)
             extra_message = " (note: variable '" + var + "' shadows function)";
         }
diff --git a/libinterp/parse-tree/pt-jit.cc b/libinterp/parse-tree/pt-jit.cc
--- a/libinterp/parse-tree/pt-jit.cc
+++ b/libinterp/parse-tree/pt-jit.cc
@@ -113,17 +113,19 @@ static llvm::LLVMContext& context = llvm
 // is dead.
 class jit_break_exception : public std::exception
 { };
 
 // -------------------- jit_convert --------------------
 jit_convert::jit_convert (tree& tee, jit_type *for_bounds)
   : converting_function (false)
 {
-  initialize (symbol_table::current_scope ());
+  symbol_table& symtab = octave::__get_symbol_table__ ("jit_convert::jit_convert");
+
+  initialize (symtab.current_scope ());
 
   if (for_bounds)
     create_variable (next_for_bounds (false), for_bounds);
 
   try
     {
       visit (tee);
     }
@@ -1121,27 +1123,29 @@ jit_convert::find_variable (const std::s
 
 jit_variable *
 jit_convert::get_variable (const std::string& vname)
 {
   jit_variable *ret = find_variable (vname);
   if (ret)
     return ret;
 
-  symbol_table::symbol_record record = symbol_table::find_symbol (vname, scope);
+  symbol_table& symtab = octave::__get_symbol_table__ ("jit_convert::find_variable");
+
+  symbol_table::symbol_record record = symtab.find_symbol (vname, scope);
   if (record.is_persistent () || record.is_global ())
     throw jit_fail_exception ("Persistent and global not yet supported");
 
   if (converting_function)
     return create_variable (vname, jit_typeinfo::get_any (), false);
   else
     {
       octave_value val = record.varval ();
       if (val.is_undefined ())
-        val = symbol_table::find_function (vname);
+        val = symtab.find_function (vname);
 
       jit_type *type = jit_typeinfo::type_of (val);
       bounds.push_back (type_bound (type, vname));
 
       return create_variable (vname, type);
     }
 }
 
@@ -2395,23 +2399,25 @@ jit_info::execute (const vmap& extra_var
           octave_base_value *obv = current.internal_rep ();
           obv->grab ();
           real_arguments[i] = obv;
         }
     }
 
   function (&real_arguments[0]);
 
+  symbol_table& symtab = octave::__get_symbol_table__ ("jit_info::execute");
+
   for (size_t i = 0; i < arguments.size (); ++i)
     {
       const std::string& name = arguments[i].first;
 
       // do not store for loop bounds temporary
       if (name.size () && name[0] != '#')
-        symbol_table::assign (arguments[i].first, real_arguments[i]);
+        symtab::assign (arguments[i].first, real_arguments[i]);
     }
 
   octave_quit ();
 
   return true;
 }
 
 bool
@@ -2496,18 +2502,25 @@ jit_info::compile (tree_jit& tjit, tree&
       function = reinterpret_cast<jited_function> (void_fn);
     }
 }
 
 octave_value
 jit_info::find (const vmap& extra_vars, const std::string& vname) const
 {
   vmap::const_iterator iter = extra_vars.find (vname);
-  return (iter == extra_vars.end () ? symbol_table::varval (vname)
-                                    : *iter->second);
+
+  if (iter == extra_vars.end ())
+    {
+      symbol_table& symtab = octave::__get_symbol_table__ ("jit_convert::find");
+
+      return symtab.varval (vname);
+    }
+  else
+    return *iter->second;
 }
 
 #endif
 
 DEFUN (jit_failcnt, args, nargout,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{val} =} jit_failcnt ()
 @deftypefnx {} {@var{old_val} =} jit_failcnt (@var{new_val})
