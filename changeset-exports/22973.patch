# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1482963240 18000
#      Wed Dec 28 17:14:00 2016 -0500
# Node ID aa55d32100c9935cfccb511e42c59b6125ca6a19
# Parent  8bc5d69a96f31d84f3f01e3f3941740933acccdb
use F77_INT instead of octave_idx_type for liboctave sparse matrix classes

* dSparse.cc, CSparse.cc: Use F77_INT instead of octave_idx_type for
integer data passed to Fortran subroutines.

diff --git a/liboctave/array/CSparse.cc b/liboctave/array/CSparse.cc
--- a/liboctave/array/CSparse.cc
+++ b/liboctave/array/CSparse.cc
@@ -3678,23 +3678,31 @@ SparseComplexMatrix::trisolve (MatrixTyp
                   {
                     if (ridx (i) == j)
                       D[j] = octave::math::real (data (i));
                     else if (ridx (i) == j + 1)
                       DL[j] = data (i);
                   }
             }
 
-          octave_idx_type b_nc = b.cols ();
+          F77_INT b_nr = to_f77_int (b.rows ());
+          F77_INT b_nc = to_f77_int (b.cols ());
+
           retval = ComplexMatrix (b);
           Complex *result = retval.fortran_vec ();
 
-          F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, F77_DBLE_CMPLX_ARG (DL),
+          F77_INT tmp_nr = to_f77_int (nr);
+
+          F77_INT tmp_err = 0;
+
+          F77_XFCN (zptsv, ZPTSV, (tmp_nr, b_nc, D, F77_DBLE_CMPLX_ARG (DL),
                                    F77_DBLE_CMPLX_ARG (result),
-                                   b.rows (), err));
+                                   b_nr, tmp_err));
+
+          err = tmp_err;
 
           if (err != 0)
             {
               err = 0;
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Tridiagonal;
             }
           else
@@ -3736,23 +3744,31 @@ SparseComplexMatrix::trisolve (MatrixTyp
                       D[j] = data (i);
                     else if (ridx (i) == j + 1)
                       DL[j] = data (i);
                     else if (ridx (i) == j - 1)
                       DU[j-1] = data (i);
                   }
             }
 
-          octave_idx_type b_nc = b.cols ();
+          F77_INT b_nr = to_f77_int (b.rows ());
+          F77_INT b_nc = to_f77_int (b.cols ());
+
           retval = ComplexMatrix (b);
           Complex *result = retval.fortran_vec ();
 
-          F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, F77_DBLE_CMPLX_ARG (DL),
+          F77_INT tmp_nr = to_f77_int (nr);
+
+          F77_INT tmp_err = 0;
+
+          F77_XFCN (zgtsv, ZGTSV, (tmp_nr, b_nc, F77_DBLE_CMPLX_ARG (DL),
                                    F77_DBLE_CMPLX_ARG (D), F77_DBLE_CMPLX_ARG (DU), F77_DBLE_CMPLX_ARG (result),
-                                   b.rows (), err));
+                                   b_nr, tmp_err));
+
+          err = tmp_err;
 
           if (err != 0)
             {
               rcond = 0.;
               err = -2;
 
               if (sing_handler)
                 {
@@ -3803,18 +3819,18 @@ SparseComplexMatrix::trisolve (MatrixTyp
       // Note can't treat symmetric case as there is no dpttrf function
       if (typ == MatrixType::Tridiagonal
           || typ == MatrixType::Tridiagonal_Hermitian)
         {
           OCTAVE_LOCAL_BUFFER (Complex, DU2, nr - 2);
           OCTAVE_LOCAL_BUFFER (Complex, DU, nr - 1);
           OCTAVE_LOCAL_BUFFER (Complex, D, nr);
           OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
-          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
-          octave_idx_type *pipvt = ipvt.fortran_vec ();
+          Array<F77_INT> ipvt (dim_vector (nr, 1));
+          F77_INT *pipvt = ipvt.fortran_vec ();
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
                   D[j] = data (ii++);
@@ -3840,18 +3856,24 @@ SparseComplexMatrix::trisolve (MatrixTyp
                       D[j] = data (i);
                     else if (ridx (i) == j + 1)
                       DL[j] = data (i);
                     else if (ridx (i) == j - 1)
                       DU[j-1] = data (i);
                   }
             }
 
-          F77_XFCN (zgttrf, ZGTTRF, (nr, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (D),
-                                     F77_DBLE_CMPLX_ARG (DU), F77_DBLE_CMPLX_ARG (DU2), pipvt, err));
+          F77_INT tmp_nr = to_f77_int (nr);
+
+          F77_INT tmp_err = 0;
+
+          F77_XFCN (zgttrf, ZGTTRF, (tmp_nr, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (D),
+                                     F77_DBLE_CMPLX_ARG (DU), F77_DBLE_CMPLX_ARG (DU2), pipvt, tmp_err));
+
+          err = tmp_err;
 
           if (err != 0)
             {
               err = -2;
               rcond = 0.0;
 
               if (sing_handler)
                 {
@@ -3860,16 +3882,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
                 }
               else
                 octave::warn_singular_matrix ();
             }
           else
             {
               char job = 'N';
               volatile octave_idx_type x_nz = b.nnz ();
+              F77_INT b_nr = to_f77_int (b.rows ());
               octave_idx_type b_nc = b.cols ();
               retval = SparseComplexMatrix (nr, b_nc, x_nz);
               retval.xcidx (0) = 0;
               volatile octave_idx_type ii = 0;
               rcond = 1.0;
 
               OCTAVE_LOCAL_BUFFER (Complex, work, nr);
 
@@ -3877,21 +3900,23 @@ SparseComplexMatrix::trisolve (MatrixTyp
                 {
                   for (octave_idx_type i = 0; i < nr; i++)
                     work[i] = 0.;
                   for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
                     work[b.ridx (i)] = b.data (i);
 
                   F77_XFCN (zgttrs, ZGTTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, 1, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (D), F77_DBLE_CMPLX_ARG (DU),
+                             tmp_nr, 1, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (D), F77_DBLE_CMPLX_ARG (DU),
                              F77_DBLE_CMPLX_ARG (DU2), pipvt,
-                             F77_DBLE_CMPLX_ARG (work), b.rows (), err
+                             F77_DBLE_CMPLX_ARG (work), b_nr, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
+                  err = tmp_err;
+
                   // Count nonzeros in work vector and adjust
                   // space in retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nr; i++)
                     if (work[i] != 0.)
                       new_nnz++;
 
                   if (ii + new_nnz > x_nz)
@@ -3979,26 +4004,33 @@ SparseComplexMatrix::trisolve (MatrixTyp
                   {
                     if (ridx (i) == j)
                       D[j] = octave::math::real (data (i));
                     else if (ridx (i) == j + 1)
                       DL[j] = data (i);
                   }
             }
 
-          octave_idx_type b_nr = b.rows ();
-          octave_idx_type b_nc = b.cols ();
+          F77_INT b_nr = to_f77_int (b.rows ());
+          F77_INT b_nc = to_f77_int (b.cols ());
+
           rcond = 1.;
 
           retval = ComplexMatrix (b);
           Complex *result = retval.fortran_vec ();
 
-          F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, F77_DBLE_CMPLX_ARG (DL),
+          F77_INT tmp_nr = to_f77_int (nr);
+
+          F77_INT tmp_err = 0;
+
+          F77_XFCN (zptsv, ZPTSV, (tmp_nr, b_nc, D, F77_DBLE_CMPLX_ARG (DL),
                                    F77_DBLE_CMPLX_ARG (result),
-                                   b_nr, err));
+                                   b_nr, tmp_err));
+
+          err = tmp_err;
 
           if (err != 0)
             {
               err = 0;
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Tridiagonal;
             }
         }
@@ -4038,26 +4070,33 @@ SparseComplexMatrix::trisolve (MatrixTyp
                       D[j] = data (i);
                     else if (ridx (i) == j + 1)
                       DL[j] = data (i);
                     else if (ridx (i) == j - 1)
                       DU[j-1] = data (i);
                   }
             }
 
-          octave_idx_type b_nr = b.rows ();
-          octave_idx_type b_nc = b.cols ();
+          F77_INT b_nr = to_f77_int (b.rows ());
+          F77_INT b_nc = to_f77_int (b.cols ());
+
           rcond = 1.;
 
           retval = ComplexMatrix (b);
           Complex *result = retval.fortran_vec ();
 
-          F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, F77_DBLE_CMPLX_ARG (DL),
+          F77_INT tmp_nr = to_f77_int (nr);
+
+          F77_INT tmp_err = 0;
+
+          F77_XFCN (zgtsv, ZGTSV, (tmp_nr, b_nc, F77_DBLE_CMPLX_ARG (DL),
                                    F77_DBLE_CMPLX_ARG (D), F77_DBLE_CMPLX_ARG (DU), F77_DBLE_CMPLX_ARG (result),
-                                   b_nr, err));
+                                   b_nr, tmp_err));
+
+          err = tmp_err;
 
           if (err != 0)
             {
               rcond = 0.;
               err = -2;
 
               if (sing_handler)
                 {
@@ -4106,18 +4145,18 @@ SparseComplexMatrix::trisolve (MatrixTyp
       // Note can't treat symmetric case as there is no dpttrf function
       if (typ == MatrixType::Tridiagonal
           || typ == MatrixType::Tridiagonal_Hermitian)
         {
           OCTAVE_LOCAL_BUFFER (Complex, DU2, nr - 2);
           OCTAVE_LOCAL_BUFFER (Complex, DU, nr - 1);
           OCTAVE_LOCAL_BUFFER (Complex, D, nr);
           OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
-          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
-          octave_idx_type *pipvt = ipvt.fortran_vec ();
+          Array<F77_INT> ipvt (dim_vector (nr, 1));
+          F77_INT *pipvt = ipvt.fortran_vec ();
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
                   D[j] = data (ii++);
@@ -4143,18 +4182,24 @@ SparseComplexMatrix::trisolve (MatrixTyp
                       D[j] = data (i);
                     else if (ridx (i) == j + 1)
                       DL[j] = data (i);
                     else if (ridx (i) == j - 1)
                       DU[j-1] = data (i);
                   }
             }
 
-          F77_XFCN (zgttrf, ZGTTRF, (nr, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (D),
-                                     F77_DBLE_CMPLX_ARG (DU), F77_DBLE_CMPLX_ARG (DU2), pipvt, err));
+          F77_INT tmp_nr = to_f77_int (nr);
+
+          F77_INT tmp_err = 0;
+
+          F77_XFCN (zgttrf, ZGTTRF, (tmp_nr, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (D),
+                                     F77_DBLE_CMPLX_ARG (DU), F77_DBLE_CMPLX_ARG (DU2), pipvt, tmp_err));
+
+          err = tmp_err;
 
           if (err != 0)
             {
               rcond = 0.0;
               err = -2;
 
               if (sing_handler)
                 {
@@ -4163,40 +4208,42 @@ SparseComplexMatrix::trisolve (MatrixTyp
                 }
               else
                 octave::warn_singular_matrix ();
             }
           else
             {
               rcond = 1.;
               char job = 'N';
-              octave_idx_type b_nr = b.rows ();
+              F77_INT b_nr = to_f77_int (b.rows ());
               octave_idx_type b_nc = b.cols ();
               OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
 
               // Take a first guess that the number of nonzero terms
               // will be as many as in b
               volatile octave_idx_type x_nz = b.nnz ();
               volatile octave_idx_type ii = 0;
               retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
               retval.xcidx (0) = 0;
               for (volatile octave_idx_type j = 0; j < b_nc; j++)
                 {
 
-                  for (octave_idx_type i = 0; i < b_nr; i++)
+                  for (F77_INT i = 0; i < b_nr; i++)
                     Bx[i] = b(i,j);
 
                   F77_XFCN (zgttrs, ZGTTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, 1, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (D), F77_DBLE_CMPLX_ARG (DU),
+                             tmp_nr, 1, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (D), F77_DBLE_CMPLX_ARG (DU),
                              F77_DBLE_CMPLX_ARG (DU2), pipvt,
-                             F77_DBLE_CMPLX_ARG (Bx), b_nr, err
+                             F77_DBLE_CMPLX_ARG (Bx), b_nr, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
+                  err = tmp_err;
+
                   if (err != 0)
                     {
                       // FIXME: This should probably be a warning so that
                       //        error value can be passed back.
                       (*current_liboctave_error_handler)
                         ("SparseComplexMatrix::solve solve failed");
 
                       err = -1;
@@ -4259,26 +4306,26 @@ SparseComplexMatrix::bsolve (MatrixType 
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
         {
-          octave_idx_type n_lower = mattype.nlower ();
-          octave_idx_type ldm = n_lower + 1;
+          F77_INT n_lower = to_f77_int (mattype.nlower ());
+          F77_INT ldm = n_lower + 1;
           ComplexMatrix m_band (ldm, nc);
           Complex *tmp_data = m_band.fortran_vec ();
 
           if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
-              for (octave_idx_type j = 0; j < ldm; j++)
+              for (F77_INT j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
             for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
               {
                 octave_idx_type ri = ridx (i);
@@ -4286,21 +4333,27 @@ SparseComplexMatrix::bsolve (MatrixType 
                   m_band(ri - j, j) = data (i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
             anorm = m_band.abs ().sum ().row (0).max ();
 
+          F77_INT tmp_nr = to_f77_int (nr);
+
+          F77_INT tmp_err = 0;
+
           char job = 'L';
           F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                     nr, n_lower, F77_DBLE_CMPLX_ARG (tmp_data), ldm, err
+                                     tmp_nr, n_lower, F77_DBLE_CMPLX_ARG (tmp_data), ldm, tmp_err
                                      F77_CHAR_ARG_LEN (1)));
 
+          err = tmp_err;
+
           if (err != 0)
             {
               rcond = 0.0;
               // Matrix is not positive definite!! Fall through to
               // unsymmetric banded solver.
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Banded;
               err = 0;
@@ -4311,20 +4364,22 @@ SparseComplexMatrix::bsolve (MatrixType 
                 {
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
                   F77_XFCN (zpbcon, ZPBCON,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, n_lower, F77_DBLE_CMPLX_ARG (tmp_data), ldm,
-                             anorm, rcond, F77_DBLE_CMPLX_ARG (pz), piz, err
+                             tmp_nr, n_lower, F77_DBLE_CMPLX_ARG (tmp_data), ldm,
+                             anorm, rcond, F77_DBLE_CMPLX_ARG (pz), piz, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
+                  err = tmp_err;
+
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                     {
                       err = -2;
@@ -4341,50 +4396,53 @@ SparseComplexMatrix::bsolve (MatrixType 
               else
                 rcond = 1.0;
 
               if (err == 0)
                 {
                   retval = ComplexMatrix (b);
                   Complex *result = retval.fortran_vec ();
 
-                  octave_idx_type b_nc = b.cols ();
+                  F77_INT b_nr = to_f77_int (b.rows ());
+                  F77_INT b_nc = to_f77_int (b.cols ());
 
                   F77_XFCN (zpbtrs, ZPBTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, n_lower, b_nc, F77_DBLE_CMPLX_ARG (tmp_data),
-                             ldm, F77_DBLE_CMPLX_ARG (result), b.rows (), err
+                             tmp_nr, n_lower, b_nc, F77_DBLE_CMPLX_ARG (tmp_data),
+                             ldm, F77_DBLE_CMPLX_ARG (result), b_nr, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
+                  err = tmp_err;
+
                   if (err != 0)
                     {
                       // FIXME: Probably should be a warning.
                       (*current_liboctave_error_handler)
                         ("SparseMatrix::solve solve failed");
                       err = -1;
                     }
                 }
             }
         }
 
       if (typ == MatrixType::Banded)
         {
           // Create the storage for the banded form of the sparse matrix
-          octave_idx_type n_upper = mattype.nupper ();
-          octave_idx_type n_lower = mattype.nlower ();
-          octave_idx_type ldm = n_upper + 2 * n_lower + 1;
+          F77_INT n_upper = to_f77_int (mattype.nupper ());
+          F77_INT n_lower = to_f77_int (mattype.nlower ());
+          F77_INT ldm = n_upper + 2 * n_lower + 1;
 
           ComplexMatrix m_band (ldm, nc);
           Complex *tmp_data = m_band.fortran_vec ();
 
           if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
-              for (octave_idx_type j = 0; j < ldm; j++)
+              for (F77_INT j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
             for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
               m_band(ridx (i) - j + n_lower + n_upper, j) = data (i);
 
@@ -4397,22 +4455,28 @@ SparseComplexMatrix::bsolve (MatrixType 
                   double atmp = 0.;
                   for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                     atmp += std::abs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
-          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
-          octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-          F77_XFCN (zgbtrf, ZGBTRF, (nr, nc, n_lower, n_upper,
+          Array<F77_INT> ipvt (dim_vector (nr, 1));
+          F77_INT *pipvt = ipvt.fortran_vec ();
+
+          F77_INT tmp_nr = to_f77_int (nr);
+
+          F77_INT tmp_err = 0;
+
+          F77_XFCN (zgbtrf, ZGBTRF, (tmp_nr, tmp_nr, n_lower, n_upper,
                                      F77_DBLE_CMPLX_ARG (tmp_data),
-                                     ldm, pipvt, err));
+                                     ldm, pipvt, tmp_err));
+
+          err = tmp_err;
 
           // Throw-away extra info LAPACK gives so as to not
           // change output.
           if (err != 0)
             {
               rcond = 0.0;
               err = -2;
 
@@ -4429,22 +4493,26 @@ SparseComplexMatrix::bsolve (MatrixType 
               if (calc_cond)
                 {
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
+                  F77_INT tmp_nc = to_f77_int (nc);
+
                   F77_XFCN (zgbcon, ZGBCON,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nc, n_lower, n_upper, F77_DBLE_CMPLX_ARG (tmp_data), ldm, pipvt,
-                             anorm, rcond, F77_DBLE_CMPLX_ARG (pz), piz, err
+                             tmp_nc, n_lower, n_upper, F77_DBLE_CMPLX_ARG (tmp_data), ldm, pipvt,
+                             anorm, rcond, F77_DBLE_CMPLX_ARG (pz), piz, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
+                  err = tmp_err;
+
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                     {
                       err = -2;
@@ -4461,24 +4529,27 @@ SparseComplexMatrix::bsolve (MatrixType 
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   retval = ComplexMatrix (b);
                   Complex *result = retval.fortran_vec ();
 
-                  octave_idx_type b_nc = b.cols ();
+                  F77_INT b_nr = to_f77_int (b.rows ());
+                  F77_INT b_nc = to_f77_int (b.cols ());
 
                   char job = 'N';
                   F77_XFCN (zgbtrs, ZGBTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, n_lower, n_upper, b_nc, F77_DBLE_CMPLX_ARG (tmp_data),
-                             ldm, pipvt, F77_DBLE_CMPLX_ARG (result), b.rows (), err
+                             tmp_nr, n_lower, n_upper, b_nc, F77_DBLE_CMPLX_ARG (tmp_data),
+                             ldm, pipvt, F77_DBLE_CMPLX_ARG (result), b_nr, tmp_err
                              F77_CHAR_ARG_LEN (1)));
+
+                  err = tmp_err;
                 }
             }
         }
       else if (typ != MatrixType::Banded_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
@@ -4505,27 +4576,27 @@ SparseComplexMatrix::bsolve (MatrixType 
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
         {
-          octave_idx_type n_lower = mattype.nlower ();
-          octave_idx_type ldm = n_lower + 1;
+          F77_INT n_lower = to_f77_int (mattype.nlower ());
+          F77_INT ldm = n_lower + 1;
 
           ComplexMatrix m_band (ldm, nc);
           Complex *tmp_data = m_band.fortran_vec ();
 
           if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
-              for (octave_idx_type j = 0; j < ldm; j++)
+              for (F77_INT j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
             for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
               {
                 octave_idx_type ri = ridx (i);
@@ -4533,21 +4604,27 @@ SparseComplexMatrix::bsolve (MatrixType 
                   m_band(ri - j, j) = data (i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
             anorm = m_band.abs ().sum ().row (0).max ();
 
+          F77_INT tmp_nr = to_f77_int (nr);
+
+          F77_INT tmp_err = 0;
+
           char job = 'L';
           F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                     nr, n_lower, F77_DBLE_CMPLX_ARG (tmp_data), ldm, err
+                                     tmp_nr, n_lower, F77_DBLE_CMPLX_ARG (tmp_data), ldm, tmp_err
                                      F77_CHAR_ARG_LEN (1)));
 
+          err = tmp_err;
+
           if (err != 0)
             {
               rcond = 0.0;
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Banded;
               err = 0;
             }
           else
@@ -4556,20 +4633,22 @@ SparseComplexMatrix::bsolve (MatrixType 
                 {
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
                   F77_XFCN (zpbcon, ZPBCON,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, n_lower, F77_DBLE_CMPLX_ARG (tmp_data), ldm,
-                             anorm, rcond, F77_DBLE_CMPLX_ARG (pz), piz, err
+                             tmp_nr, n_lower, F77_DBLE_CMPLX_ARG (tmp_data), ldm,
+                             anorm, rcond, F77_DBLE_CMPLX_ARG (pz), piz, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
+                  err = tmp_err;
+
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                     {
                       err = -2;
@@ -4583,38 +4662,40 @@ SparseComplexMatrix::bsolve (MatrixType 
                         octave::warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.0;
 
               if (err == 0)
                 {
-                  octave_idx_type b_nr = b.rows ();
+                  F77_INT b_nr = to_f77_int (b.rows ());
                   octave_idx_type b_nc = b.cols ();
                   OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
 
                   // Take a first guess that the number of nonzero terms
                   // will be as many as in b
                   volatile octave_idx_type x_nz = b.nnz ();
                   volatile octave_idx_type ii = 0;
                   retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
                   retval.xcidx (0) = 0;
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
-                      for (octave_idx_type i = 0; i < b_nr; i++)
+                      for (F77_INT i = 0; i < b_nr; i++)
                         Bx[i] = b.elem (i, j);
 
                       F77_XFCN (zpbtrs, ZPBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
-                                 nr, n_lower, 1, F77_DBLE_CMPLX_ARG (tmp_data),
-                                 ldm, F77_DBLE_CMPLX_ARG (Bx), b_nr, err
+                                 tmp_nr, n_lower, 1, F77_DBLE_CMPLX_ARG (tmp_data),
+                                 ldm, F77_DBLE_CMPLX_ARG (Bx), b_nr, tmp_err
                                  F77_CHAR_ARG_LEN (1)));
 
+                      err = tmp_err;
+
                       if (err != 0)
                         {
                           // FIXME: Probably should be a warning.
                           (*current_liboctave_error_handler)
                             ("SparseComplexMatrix::solve solve failed");
                           err = -1;
                           break;
                         }
@@ -4643,28 +4724,28 @@ SparseComplexMatrix::bsolve (MatrixType 
                   retval.maybe_compress ();
                 }
             }
         }
 
       if (typ == MatrixType::Banded)
         {
           // Create the storage for the banded form of the sparse matrix
-          octave_idx_type n_upper = mattype.nupper ();
-          octave_idx_type n_lower = mattype.nlower ();
-          octave_idx_type ldm = n_upper + 2 * n_lower + 1;
+          F77_INT n_upper = to_f77_int (mattype.nupper ());
+          F77_INT n_lower = to_f77_int (mattype.nlower ());
+          F77_INT ldm = n_upper + 2 * n_lower + 1;
 
           ComplexMatrix m_band (ldm, nc);
           Complex *tmp_data = m_band.fortran_vec ();
 
           if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
-              for (octave_idx_type j = 0; j < ldm; j++)
+              for (F77_INT j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
             for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
               m_band(ridx (i) - j + n_lower + n_upper, j) = data (i);
 
@@ -4677,22 +4758,28 @@ SparseComplexMatrix::bsolve (MatrixType 
                   double atmp = 0.;
                   for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                     atmp += std::abs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
-          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
-          octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-          F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper,
+          Array<F77_INT> ipvt (dim_vector (nr, 1));
+          F77_INT *pipvt = ipvt.fortran_vec ();
+
+          F77_INT tmp_nr = to_f77_int (nr);
+
+          F77_INT tmp_err = 0;
+
+          F77_XFCN (zgbtrf, ZGBTRF, (tmp_nr, tmp_nr, n_lower, n_upper,
                                      F77_DBLE_CMPLX_ARG (tmp_data),
-                                     ldm, pipvt, err));
+                                     ldm, pipvt, tmp_err));
+
+          err = tmp_err;
 
           if (err != 0)
             {
               rcond = 0.0;
               err = -2;
 
               if (sing_handler)
                 {
@@ -4707,22 +4794,26 @@ SparseComplexMatrix::bsolve (MatrixType 
               if (calc_cond)
                 {
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
+                  F77_INT tmp_nc = to_f77_int (nc);
+
                   F77_XFCN (zgbcon, ZGBCON,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nc, n_lower, n_upper, F77_DBLE_CMPLX_ARG (tmp_data), ldm, pipvt,
-                             anorm, rcond, F77_DBLE_CMPLX_ARG (pz), piz, err
+                             tmp_nc, n_lower, n_upper, F77_DBLE_CMPLX_ARG (tmp_data), ldm, pipvt,
+                             anorm, rcond, F77_DBLE_CMPLX_ARG (pz), piz, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
+                  err = tmp_err;
+
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                     {
                       err = -2;
@@ -4738,16 +4829,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
                   volatile octave_idx_type x_nz = b.nnz ();
+                  F77_INT b_nr = to_f77_int (b.rows ());
                   octave_idx_type b_nc = b.cols ();
                   retval = SparseComplexMatrix (nr, b_nc, x_nz);
                   retval.xcidx (0) = 0;
                   volatile octave_idx_type ii = 0;
 
                   OCTAVE_LOCAL_BUFFER (Complex, work, nr);
 
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
@@ -4755,20 +4847,22 @@ SparseComplexMatrix::bsolve (MatrixType 
                       for (octave_idx_type i = 0; i < nr; i++)
                         work[i] = 0.;
                       for (octave_idx_type i = b.cidx (j);
                            i < b.cidx (j+1); i++)
                         work[b.ridx (i)] = b.data (i);
 
                       F77_XFCN (zgbtrs, ZGBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
-                                 nr, n_lower, n_upper, 1, F77_DBLE_CMPLX_ARG (tmp_data),
-                                 ldm, pipvt, F77_DBLE_CMPLX_ARG (work), b.rows (), err
+                                 tmp_nr, n_lower, n_upper, 1, F77_DBLE_CMPLX_ARG (tmp_data),
+                                 ldm, pipvt, F77_DBLE_CMPLX_ARG (work), b_nr, tmp_err
                                  F77_CHAR_ARG_LEN (1)));
 
+                      err = tmp_err;
+
                       // Count nonzeros in work vector and adjust
                       // space in retval if needed
                       octave_idx_type new_nnz = 0;
                       for (octave_idx_type i = 0; i < nr; i++)
                         if (work[i] != 0.)
                           new_nnz++;
 
                       if (ii + new_nnz > x_nz)
@@ -4820,27 +4914,27 @@ SparseComplexMatrix::bsolve (MatrixType 
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
         {
-          octave_idx_type n_lower = mattype.nlower ();
-          octave_idx_type ldm = n_lower + 1;
+          F77_INT n_lower = to_f77_int (mattype.nlower ());
+          F77_INT ldm = n_lower + 1;
 
           ComplexMatrix m_band (ldm, nc);
           Complex *tmp_data = m_band.fortran_vec ();
 
           if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
-              for (octave_idx_type j = 0; j < ldm; j++)
+              for (F77_INT j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
             for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
               {
                 octave_idx_type ri = ridx (i);
@@ -4848,21 +4942,27 @@ SparseComplexMatrix::bsolve (MatrixType 
                   m_band(ri - j, j) = data (i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
             anorm = m_band.abs ().sum ().row (0).max ();
 
+          F77_INT tmp_nr = to_f77_int (nr);
+
+          F77_INT tmp_err = 0;
+
           char job = 'L';
           F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                     nr, n_lower, F77_DBLE_CMPLX_ARG (tmp_data), ldm, err
+                                     tmp_nr, n_lower, F77_DBLE_CMPLX_ARG (tmp_data), ldm, tmp_err
                                      F77_CHAR_ARG_LEN (1)));
 
+          err = tmp_err;
+
           if (err != 0)
             {
               // Matrix is not positive definite!! Fall through to
               // unsymmetric banded solver.
               rcond = 0.0;
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Banded;
               err = 0;
@@ -4873,20 +4973,22 @@ SparseComplexMatrix::bsolve (MatrixType 
                 {
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
                   F77_XFCN (zpbcon, ZPBCON,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, n_lower, F77_DBLE_CMPLX_ARG (tmp_data), ldm,
-                             anorm, rcond, F77_DBLE_CMPLX_ARG (pz), piz, err
+                             tmp_nr, n_lower, F77_DBLE_CMPLX_ARG (tmp_data), ldm,
+                             anorm, rcond, F77_DBLE_CMPLX_ARG (pz), piz, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
+                  err = tmp_err;
+
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                     {
                       err = -2;
@@ -4900,53 +5002,55 @@ SparseComplexMatrix::bsolve (MatrixType 
                         octave::warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.0;
 
               if (err == 0)
                 {
-                  octave_idx_type b_nr = b.rows ();
-                  octave_idx_type b_nc = b.cols ();
+                  F77_INT b_nr = to_f77_int (b.rows ());
+                  F77_INT b_nc = to_f77_int (b.cols ());
                   retval = ComplexMatrix (b);
                   Complex *result = retval.fortran_vec ();
 
                   F77_XFCN (zpbtrs, ZPBTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, n_lower, b_nc, F77_DBLE_CMPLX_ARG (tmp_data),
-                             ldm, F77_DBLE_CMPLX_ARG (result), b_nr, err
+                             tmp_nr, n_lower, b_nc, F77_DBLE_CMPLX_ARG (tmp_data),
+                             ldm, F77_DBLE_CMPLX_ARG (result), b_nr, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
+                  err = tmp_err;
+
                   if (err != 0)
                     {
                       // FIXME: Probably should be a warning.
                       (*current_liboctave_error_handler)
                         ("SparseComplexMatrix::solve solve failed");
                       err = -1;
                     }
                 }
             }
         }
 
       if (typ == MatrixType::Banded)
         {
           // Create the storage for the banded form of the sparse matrix
-          octave_idx_type n_upper = mattype.nupper ();
-          octave_idx_type n_lower = mattype.nlower ();
-          octave_idx_type ldm = n_upper + 2 * n_lower + 1;
+          F77_INT n_upper = to_f77_int (mattype.nupper ());
+          F77_INT n_lower = to_f77_int (mattype.nlower ());
+          F77_INT ldm = n_upper + 2 * n_lower + 1;
 
           ComplexMatrix m_band (ldm, nc);
           Complex *tmp_data = m_band.fortran_vec ();
 
           if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
-              for (octave_idx_type j = 0; j < ldm; j++)
+              for (F77_INT j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
             for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
               m_band(ridx (i) - j + n_lower + n_upper, j) = data (i);
 
@@ -4959,22 +5063,28 @@ SparseComplexMatrix::bsolve (MatrixType 
                   double atmp = 0.;
                   for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                     atmp += std::abs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
-          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
-          octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-          F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper,
+          Array<F77_INT> ipvt (dim_vector (nr, 1));
+          F77_INT *pipvt = ipvt.fortran_vec ();
+
+          F77_INT tmp_nr = to_f77_int (nr);
+
+          F77_INT tmp_err = 0;
+
+          F77_XFCN (zgbtrf, ZGBTRF, (tmp_nr, tmp_nr, n_lower, n_upper,
                                      F77_DBLE_CMPLX_ARG (tmp_data),
-                                     ldm, pipvt, err));
+                                     ldm, pipvt, tmp_err));
+
+          err = tmp_err;
 
           if (err != 0)
             {
               err = -2;
               rcond = 0.0;
 
               if (sing_handler)
                 {
@@ -4989,22 +5099,26 @@ SparseComplexMatrix::bsolve (MatrixType 
               if (calc_cond)
                 {
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
+                  F77_INT tmp_nc = to_f77_int (nc);
+
                   F77_XFCN (zgbcon, ZGBCON,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nc, n_lower, n_upper, F77_DBLE_CMPLX_ARG (tmp_data), ldm, pipvt,
-                             anorm, rcond, F77_DBLE_CMPLX_ARG (pz), piz, err
+                             tmp_nc, n_lower, n_upper, F77_DBLE_CMPLX_ARG (tmp_data), ldm, pipvt,
+                             anorm, rcond, F77_DBLE_CMPLX_ARG (pz), piz, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
+                  err = tmp_err;
+
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                     {
                       err = -2;
@@ -5019,25 +5133,28 @@ SparseComplexMatrix::bsolve (MatrixType 
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
-                  octave_idx_type b_nc = b.cols ();
+                  F77_INT b_nr = to_f77_int (b.rows ());
+                  F77_INT b_nc = to_f77_int (b.cols ());
                   retval = ComplexMatrix (b);
                   Complex *result = retval.fortran_vec ();
 
                   F77_XFCN (zgbtrs, ZGBTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, n_lower, n_upper, b_nc, F77_DBLE_CMPLX_ARG (tmp_data),
-                             ldm, pipvt, F77_DBLE_CMPLX_ARG (result), b.rows (), err
+                             tmp_nr, n_lower, n_upper, b_nc, F77_DBLE_CMPLX_ARG (tmp_data),
+                             ldm, pipvt, F77_DBLE_CMPLX_ARG (result), b_nr, tmp_err
                              F77_CHAR_ARG_LEN (1)));
+
+                  err = tmp_err;
                 }
             }
         }
       else if (typ != MatrixType::Banded_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
@@ -5064,27 +5181,27 @@ SparseComplexMatrix::bsolve (MatrixType 
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
         {
-          octave_idx_type n_lower = mattype.nlower ();
-          octave_idx_type ldm = n_lower + 1;
+          F77_INT n_lower = to_f77_int (mattype.nlower ());
+          F77_INT ldm = n_lower + 1;
 
           ComplexMatrix m_band (ldm, nc);
           Complex *tmp_data = m_band.fortran_vec ();
 
           if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
-              for (octave_idx_type j = 0; j < ldm; j++)
+              for (F77_INT j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
             for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
               {
                 octave_idx_type ri = ridx (i);
@@ -5092,21 +5209,27 @@ SparseComplexMatrix::bsolve (MatrixType 
                   m_band(ri - j, j) = data (i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
             anorm = m_band.abs ().sum ().row (0).max ();
 
+          F77_INT tmp_nr = to_f77_int (nr);
+
+          F77_INT tmp_err = 0;
+
           char job = 'L';
           F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                     nr, n_lower, F77_DBLE_CMPLX_ARG (tmp_data), ldm, err
+                                     tmp_nr, n_lower, F77_DBLE_CMPLX_ARG (tmp_data), ldm, tmp_err
                                      F77_CHAR_ARG_LEN (1)));
 
+          err = tmp_err;
+
           if (err != 0)
             {
               // Matrix is not positive definite!! Fall through to
               // unsymmetric banded solver.
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Banded;
 
               rcond = 0.0;
@@ -5118,20 +5241,22 @@ SparseComplexMatrix::bsolve (MatrixType 
                 {
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
                   F77_XFCN (zpbcon, ZPBCON,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, n_lower, F77_DBLE_CMPLX_ARG (tmp_data), ldm,
-                             anorm, rcond, F77_DBLE_CMPLX_ARG (pz), piz, err
+                             tmp_nr, n_lower, F77_DBLE_CMPLX_ARG (tmp_data), ldm,
+                             anorm, rcond, F77_DBLE_CMPLX_ARG (pz), piz, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
+                  err = tmp_err;
+
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                     {
                       err = -2;
@@ -5145,39 +5270,41 @@ SparseComplexMatrix::bsolve (MatrixType 
                         octave::warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.0;
 
               if (err == 0)
                 {
-                  octave_idx_type b_nr = b.rows ();
+                  F77_INT b_nr = to_f77_int (b.rows ());
                   octave_idx_type b_nc = b.cols ();
                   OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
 
                   // Take a first guess that the number of nonzero terms
                   // will be as many as in b
                   volatile octave_idx_type x_nz = b.nnz ();
                   volatile octave_idx_type ii = 0;
                   retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
                   retval.xcidx (0) = 0;
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
 
-                      for (octave_idx_type i = 0; i < b_nr; i++)
+                      for (F77_INT i = 0; i < b_nr; i++)
                         Bx[i] = b(i,j);
 
                       F77_XFCN (zpbtrs, ZPBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
-                                 nr, n_lower, 1, F77_DBLE_CMPLX_ARG (tmp_data),
-                                 ldm, F77_DBLE_CMPLX_ARG (Bx), b_nr, err
+                                 tmp_nr, n_lower, 1, F77_DBLE_CMPLX_ARG (tmp_data),
+                                 ldm, F77_DBLE_CMPLX_ARG (Bx), b_nr, tmp_err
                                  F77_CHAR_ARG_LEN (1)));
 
+                      err = tmp_err;
+
                       if (err != 0)
                         {
                           // FIXME: Probably should be a warning.
                           (*current_liboctave_error_handler)
                             ("SparseMatrix::solve solve failed");
                           err = -1;
                           break;
                         }
@@ -5210,28 +5337,28 @@ SparseComplexMatrix::bsolve (MatrixType 
                   retval.maybe_compress ();
                 }
             }
         }
 
       if (typ == MatrixType::Banded)
         {
           // Create the storage for the banded form of the sparse matrix
-          octave_idx_type n_upper = mattype.nupper ();
-          octave_idx_type n_lower = mattype.nlower ();
-          octave_idx_type ldm = n_upper + 2 * n_lower + 1;
+          F77_INT n_upper = to_f77_int (mattype.nupper ());
+          F77_INT n_lower = to_f77_int (mattype.nlower ());
+          F77_INT ldm = n_upper + 2 * n_lower + 1;
 
           ComplexMatrix m_band (ldm, nc);
           Complex *tmp_data = m_band.fortran_vec ();
 
           if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
-              for (octave_idx_type j = 0; j < ldm; j++)
+              for (F77_INT j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
             for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
               m_band(ridx (i) - j + n_lower + n_upper, j) = data (i);
 
@@ -5244,22 +5371,28 @@ SparseComplexMatrix::bsolve (MatrixType 
                   double atmp = 0.;
                   for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                     atmp += std::abs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
-          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
-          octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-          F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper,
+          Array<F77_INT> ipvt (dim_vector (nr, 1));
+          F77_INT *pipvt = ipvt.fortran_vec ();
+
+          F77_INT tmp_nr = to_f77_int (nr);
+
+          F77_INT tmp_err = 0;
+
+          F77_XFCN (zgbtrf, ZGBTRF, (tmp_nr, tmp_nr, n_lower, n_upper,
                                      F77_DBLE_CMPLX_ARG (tmp_data),
-                                     ldm, pipvt, err));
+                                     ldm, pipvt, tmp_err));
+
+          err = tmp_err;
 
           if (err != 0)
             {
               err = -2;
               rcond = 0.0;
 
               if (sing_handler)
                 {
@@ -5274,22 +5407,26 @@ SparseComplexMatrix::bsolve (MatrixType 
               if (calc_cond)
                 {
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
+                  F77_INT tmp_nc = to_f77_int (nc);
+
                   F77_XFCN (zgbcon, ZGBCON,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nc, n_lower, n_upper, F77_DBLE_CMPLX_ARG (tmp_data), ldm, pipvt,
-                             anorm, rcond, F77_DBLE_CMPLX_ARG (pz), piz, err
+                             tmp_nc, n_lower, n_upper, F77_DBLE_CMPLX_ARG (tmp_data), ldm, pipvt,
+                             anorm, rcond, F77_DBLE_CMPLX_ARG (pz), piz, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
+                  err = tmp_err;
+
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                     {
                       err = -2;
@@ -5305,16 +5442,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
                   volatile octave_idx_type x_nz = b.nnz ();
+                  F77_INT b_nr = to_f77_int (b.rows ());
                   octave_idx_type b_nc = b.cols ();
                   retval = SparseComplexMatrix (nr, b_nc, x_nz);
                   retval.xcidx (0) = 0;
                   volatile octave_idx_type ii = 0;
 
                   OCTAVE_LOCAL_BUFFER (Complex, Bx, nr);
 
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
@@ -5323,20 +5461,22 @@ SparseComplexMatrix::bsolve (MatrixType 
                         Bx[i] = 0.;
 
                       for (octave_idx_type i = b.cidx (j);
                            i < b.cidx (j+1); i++)
                         Bx[b.ridx (i)] = b.data (i);
 
                       F77_XFCN (zgbtrs, ZGBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
-                                 nr, n_lower, n_upper, 1, F77_DBLE_CMPLX_ARG (tmp_data),
-                                 ldm, pipvt, F77_DBLE_CMPLX_ARG (Bx), b.rows (), err
+                                 tmp_nr, n_lower, n_upper, 1, F77_DBLE_CMPLX_ARG (tmp_data),
+                                 ldm, pipvt, F77_DBLE_CMPLX_ARG (Bx), b_nr, tmp_err
                                  F77_CHAR_ARG_LEN (1)));
 
+                      err = tmp_err;
+
                       // Count nonzeros in work vector and adjust
                       // space in retval if needed
                       octave_idx_type new_nnz = 0;
                       for (octave_idx_type i = 0; i < nr; i++)
                         if (Bx[i] != 0.)
                           new_nnz++;
 
                       if (ii + new_nnz > x_nz)
diff --git a/liboctave/array/dSparse.cc b/liboctave/array/dSparse.cc
--- a/liboctave/array/dSparse.cc
+++ b/liboctave/array/dSparse.cc
@@ -3757,22 +3757,30 @@ SparseMatrix::trisolve (MatrixType &matt
                   {
                     if (ridx (i) == j)
                       D[j] = data (i);
                     else if (ridx (i) == j + 1)
                       DL[j] = data (i);
                   }
             }
 
-          octave_idx_type b_nc = b.cols ();
+          F77_INT tmp_nr = to_f77_int (nr);
+
+          F77_INT b_nr = to_f77_int (b.rows ());
+          F77_INT b_nc = to_f77_int (b.cols ());
+
           retval = b;
           double *result = retval.fortran_vec ();
 
-          F77_XFCN (dptsv, DPTSV, (nr, b_nc, D, DL, result,
-                                   b.rows (), err));
+          F77_INT tmp_err = 0;
+
+          F77_XFCN (dptsv, DPTSV, (tmp_nr, b_nc, D, DL, result,
+                                   b_nr, tmp_err));
+
+          err = tmp_err;
 
           if (err != 0)
             {
               err = 0;
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Tridiagonal;
             }
           else
@@ -3814,22 +3822,30 @@ SparseMatrix::trisolve (MatrixType &matt
                       D[j] = data (i);
                     else if (ridx (i) == j + 1)
                       DL[j] = data (i);
                     else if (ridx (i) == j - 1)
                       DU[j-1] = data (i);
                   }
             }
 
-          octave_idx_type b_nc = b.cols ();
+          F77_INT tmp_nr = to_f77_int (nr);
+
+          F77_INT b_nr = to_f77_int (b.rows ());
+          F77_INT b_nc = to_f77_int (b.cols ());
+
           retval = b;
           double *result = retval.fortran_vec ();
 
-          F77_XFCN (dgtsv, DGTSV, (nr, b_nc, DL, D, DU, result,
-                                   b.rows (), err));
+          F77_INT tmp_err = 0;
+
+          F77_XFCN (dgtsv, DGTSV, (tmp_nr, b_nc, DL, D, DU, result,
+                                   b_nr, tmp_err));
+
+          err = tmp_err;
 
           if (err != 0)
             {
               rcond = 0.;
               err = -2;
 
               if (sing_handler)
                 {
@@ -3879,18 +3895,18 @@ SparseMatrix::trisolve (MatrixType &matt
       // Note can't treat symmetric case as there is no dpttrf function
       if (typ == MatrixType::Tridiagonal
           || typ == MatrixType::Tridiagonal_Hermitian)
         {
           OCTAVE_LOCAL_BUFFER (double, DU2, nr - 2);
           OCTAVE_LOCAL_BUFFER (double, DU, nr - 1);
           OCTAVE_LOCAL_BUFFER (double, D, nr);
           OCTAVE_LOCAL_BUFFER (double, DL, nr - 1);
-          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
-          octave_idx_type *pipvt = ipvt.fortran_vec ();
+          Array<F77_INT> ipvt (dim_vector (nr, 1));
+          F77_INT *pipvt = ipvt.fortran_vec ();
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
                   D[j] = data (ii++);
@@ -3916,17 +3932,21 @@ SparseMatrix::trisolve (MatrixType &matt
                       D[j] = data (i);
                     else if (ridx (i) == j + 1)
                       DL[j] = data (i);
                     else if (ridx (i) == j - 1)
                       DU[j-1] = data (i);
                   }
             }
 
-          F77_XFCN (dgttrf, DGTTRF, (nr, DL, D, DU, DU2, pipvt, err));
+          F77_INT tmp_nr = to_f77_int (nr);
+
+          F77_INT tmp_err = 0;
+
+          F77_XFCN (dgttrf, DGTTRF, (tmp_nr, DL, D, DU, DU2, pipvt, tmp_err));
 
           if (err != 0)
             {
               rcond = 0.0;
               err = -2;
 
               if (sing_handler)
                 {
@@ -3950,22 +3970,26 @@ SparseMatrix::trisolve (MatrixType &matt
 
               for (volatile octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nr; i++)
                     work[i] = 0.;
                   for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
                     work[b.ridx (i)] = b.data (i);
 
+                  F77_INT b_nr = to_f77_int (b.rows ());
+
                   F77_XFCN (dgttrs, DGTTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, 1, DL, D, DU, DU2, pipvt,
-                             work, b.rows (), err
+                             tmp_nr, 1, DL, D, DU, DU2, pipvt,
+                             work, b_nr, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
+                  err = tmp_err;
+
                   // Count nonzeros in work vector and adjust
                   // space in retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nr; i++)
                     if (work[i] != 0.)
                       new_nnz++;
 
                   if (ii + new_nnz > x_nz)
@@ -4053,26 +4077,33 @@ SparseMatrix::trisolve (MatrixType &matt
                   {
                     if (ridx (i) == j)
                       D[j] = data (i);
                     else if (ridx (i) == j + 1)
                       DL[j] = data (i);
                   }
             }
 
-          octave_idx_type b_nr = b.rows ();
-          octave_idx_type b_nc = b.cols ();
+          F77_INT tmp_nr = to_f77_int (nr);
+
+          F77_INT b_nr = to_f77_int (b.rows ());
+          F77_INT b_nc = to_f77_int (b.cols ());
+
           rcond = 1.;
 
           retval = b;
           Complex *result = retval.fortran_vec ();
 
-          F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, F77_DBLE_CMPLX_ARG (DL),
+          F77_INT tmp_err = 0;
+
+          F77_XFCN (zptsv, ZPTSV, (tmp_nr, b_nc, D, F77_DBLE_CMPLX_ARG (DL),
                                    F77_DBLE_CMPLX_ARG (result),
-                                   b_nr, err));
+                                   b_nr, tmp_err));
+
+          err = tmp_err;
 
           if (err != 0)
             {
               err = 0;
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Tridiagonal;
             }
         }
@@ -4112,26 +4143,35 @@ SparseMatrix::trisolve (MatrixType &matt
                       D[j] = data (i);
                     else if (ridx (i) == j + 1)
                       DL[j] = data (i);
                     else if (ridx (i) == j - 1)
                       DU[j-1] = data (i);
                   }
             }
 
-          octave_idx_type b_nr = b.rows ();
-          octave_idx_type b_nc = b.cols ();
+          F77_INT tmp_nr = to_f77_int (nr);
+
+          F77_INT b_nr = to_f77_int (b.rows ());
+          F77_INT b_nc = to_f77_int (b.cols ());
+
           rcond = 1.;
 
           retval = b;
           Complex *result = retval.fortran_vec ();
 
-          F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, F77_DBLE_CMPLX_ARG (DL),
-                                   F77_DBLE_CMPLX_ARG (D), F77_DBLE_CMPLX_ARG (DU), F77_DBLE_CMPLX_ARG (result),
-                                   b_nr, err));
+          F77_INT tmp_err = 0;
+
+          F77_XFCN (zgtsv, ZGTSV, (tmp_nr, b_nc, F77_DBLE_CMPLX_ARG (DL),
+                                   F77_DBLE_CMPLX_ARG (D),
+                                   F77_DBLE_CMPLX_ARG (DU),
+                                   F77_DBLE_CMPLX_ARG (result),
+                                   b_nr, tmp_err));
+
+          err = tmp_err;
 
           if (err != 0)
             {
               rcond = 0.;
               err = -2;
 
               if (sing_handler)
                 {
@@ -4179,18 +4219,18 @@ SparseMatrix::trisolve (MatrixType &matt
       // Note can't treat symmetric case as there is no dpttrf function
       if (typ == MatrixType::Tridiagonal
           || typ == MatrixType::Tridiagonal_Hermitian)
         {
           OCTAVE_LOCAL_BUFFER (double, DU2, nr - 2);
           OCTAVE_LOCAL_BUFFER (double, DU, nr - 1);
           OCTAVE_LOCAL_BUFFER (double, D, nr);
           OCTAVE_LOCAL_BUFFER (double, DL, nr - 1);
-          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
-          octave_idx_type *pipvt = ipvt.fortran_vec ();
+          Array<F77_INT> ipvt (dim_vector (nr, 1));
+          F77_INT *pipvt = ipvt.fortran_vec ();
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < nc-1; j++)
                 {
                   D[j] = data (ii++);
@@ -4216,17 +4256,23 @@ SparseMatrix::trisolve (MatrixType &matt
                       D[j] = data (i);
                     else if (ridx (i) == j + 1)
                       DL[j] = data (i);
                     else if (ridx (i) == j - 1)
                       DU[j-1] = data (i);
                   }
             }
 
-          F77_XFCN (dgttrf, DGTTRF, (nr, DL, D, DU, DU2, pipvt, err));
+          F77_INT tmp_nr = to_f77_int (nr);
+
+          F77_INT tmp_err = 0;
+
+          F77_XFCN (dgttrf, DGTTRF, (tmp_nr, DL, D, DU, DU2, pipvt, tmp_err));
+
+          err = tmp_err;
 
           if (err != 0)
             {
               rcond = 0.0;
               err = -2;
 
               if (sing_handler)
                 {
@@ -4235,60 +4281,64 @@ SparseMatrix::trisolve (MatrixType &matt
                 }
               else
                 octave::warn_singular_matrix ();
             }
           else
             {
               rcond = 1.;
               char job = 'N';
-              octave_idx_type b_nr = b.rows ();
+              F77_INT b_nr = to_f77_int (b.rows ());
               octave_idx_type b_nc = b.cols ();
               OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
               OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
 
               // Take a first guess that the number of nonzero terms
               // will be as many as in b
               volatile octave_idx_type x_nz = b.nnz ();
               volatile octave_idx_type ii = 0;
               retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
               retval.xcidx (0) = 0;
               for (volatile octave_idx_type j = 0; j < b_nc; j++)
                 {
 
-                  for (octave_idx_type i = 0; i < b_nr; i++)
+                  for (F77_INT i = 0; i < b_nr; i++)
                     {
                       Complex c = b(i,j);
                       Bx[i] = c.real ();
                       Bz[i] = c.imag ();
                     }
 
                   F77_XFCN (dgttrs, DGTTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, 1, DL, D, DU, DU2, pipvt,
-                             Bx, b_nr, err
+                             tmp_nr, 1, DL, D, DU, DU2, pipvt,
+                             Bx, b_nr, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
+                  err = tmp_err;
+
                   if (err != 0)
                     {
                       // FIXME: Should this be a warning?
                       (*current_liboctave_error_handler)
                         ("SparseMatrix::solve solve failed");
 
                       err = -1;
                       break;
                     }
 
                   F77_XFCN (dgttrs, DGTTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, 1, DL, D, DU, DU2, pipvt,
-                             Bz, b_nr, err
+                             tmp_nr, 1, DL, D, DU, DU2, pipvt,
+                             Bz, b_nr, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
+                  err = tmp_err;
+
                   if (err != 0)
                     {
                       // FIXME: Should this be a warning?
                       (*current_liboctave_error_handler)
                         ("SparseMatrix::solve solve failed");
 
                       err = -1;
                       break;
@@ -4351,18 +4401,18 @@ SparseMatrix::bsolve (MatrixType &mattyp
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
         {
-          octave_idx_type n_lower = mattype.nlower ();
-          octave_idx_type ldm = n_lower + 1;
+          F77_INT n_lower = to_f77_int (mattype.nlower ());
+          F77_INT ldm = n_lower + 1;
           Matrix m_band (ldm, nc);
           double *tmp_data = m_band.fortran_vec ();
 
           if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
@@ -4378,45 +4428,53 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   m_band(ri - j, j) = data (i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
             anorm = m_band.abs ().sum ().row (0).max ();
 
+          F77_INT tmp_nr = to_f77_int (nr);
+
+          F77_INT tmp_err = 0;
+
           char job = 'L';
           F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                     nr, n_lower, tmp_data, ldm, err
+                                     tmp_nr, n_lower, tmp_data, ldm, tmp_err
                                      F77_CHAR_ARG_LEN (1)));
 
+          err = tmp_err;
+
           if (err != 0)
             {
               // Matrix is not positive definite!! Fall through to
               // unsymmetric banded solver.
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Banded;
               rcond = 0.0;
               err = 0;
             }
           else
             {
               if (calc_cond)
                 {
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (dim_vector (nr, 1));
-                  octave_idx_type *piz = iz.fortran_vec ();
+                  Array<F77_INT> iz (dim_vector (nr, 1));
+                  F77_INT *piz = iz.fortran_vec ();
 
                   F77_XFCN (dpbcon, DPBCON,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, n_lower, tmp_data, ldm,
-                             anorm, rcond, pz, piz, err
+                             tmp_nr, n_lower, tmp_data, ldm,
+                             anorm, rcond, pz, piz, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
+                  err = tmp_err;
+
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                     {
                       err = -2;
@@ -4433,50 +4491,53 @@ SparseMatrix::bsolve (MatrixType &mattyp
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   retval = b;
                   double *result = retval.fortran_vec ();
 
-                  octave_idx_type b_nc = b.cols ();
+                  F77_INT b_nr = to_f77_int (b.rows ());
+                  F77_INT b_nc = to_f77_int (b.cols ());
 
                   F77_XFCN (dpbtrs, DPBTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, n_lower, b_nc, tmp_data,
-                             ldm, result, b.rows (), err
+                             tmp_nr, n_lower, b_nc, tmp_data,
+                             ldm, result, b_nr, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
+                  err = tmp_err;
+
                   if (err != 0)
                     {
                       // FIXME: Should this be a warning?
                       (*current_liboctave_error_handler)
                         ("SparseMatrix::solve solve failed");
                       err = -1;
                     }
                 }
             }
         }
 
       if (typ == MatrixType::Banded)
         {
           // Create the storage for the banded form of the sparse matrix
-          octave_idx_type n_upper = mattype.nupper ();
-          octave_idx_type n_lower = mattype.nlower ();
-          octave_idx_type ldm = n_upper + 2 * n_lower + 1;
+          F77_INT n_upper = to_f77_int (mattype.nupper ());
+          F77_INT n_lower = to_f77_int (mattype.nlower ());
+          F77_INT ldm = n_upper + 2 * n_lower + 1;
 
           Matrix m_band (ldm, nc);
           double *tmp_data = m_band.fortran_vec ();
 
           if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
-              for (octave_idx_type j = 0; j < ldm; j++)
+              for (F77_INT j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
             for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
               m_band(ridx (i) - j + n_lower + n_upper, j) = data (i);
 
@@ -4489,21 +4550,27 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   double atmp = 0.;
                   for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                     atmp += fabs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
-          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
-          octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-          F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data,
-                                     ldm, pipvt, err));
+          F77_INT tmp_nr = to_f77_int (nr);
+
+          Array<F77_INT> ipvt (dim_vector (nr, 1));
+          F77_INT *pipvt = ipvt.fortran_vec ();
+
+          F77_INT tmp_err = 0;
+
+          F77_XFCN (dgbtrf, DGBTRF, (tmp_nr, tmp_nr, n_lower, n_upper,
+                                     tmp_data, ldm, pipvt, tmp_err));
+
+          err = tmp_err;
 
           // Throw-away extra info LAPACK gives so as to not
           // change output.
           if (err != 0)
             {
               err = -2;
               rcond = 0.0;
 
@@ -4517,25 +4584,29 @@ SparseMatrix::bsolve (MatrixType &mattyp
             }
           else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (dim_vector (nr, 1));
-                  octave_idx_type *piz = iz.fortran_vec ();
+                  Array<F77_INT> iz (dim_vector (nr, 1));
+                  F77_INT *piz = iz.fortran_vec ();
+
+                  F77_INT tmp_nc = to_f77_int (nc);
 
                   F77_XFCN (dgbcon, DGBCON,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nc, n_lower, n_upper, tmp_data, ldm, pipvt,
-                             anorm, rcond, pz, piz, err
+                             tmp_nc, n_lower, n_upper, tmp_data, ldm, pipvt,
+                             anorm, rcond, pz, piz, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
+                  err = tmp_err;
+
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                     {
                       err = -2;
@@ -4552,24 +4623,27 @@ SparseMatrix::bsolve (MatrixType &mattyp
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   retval = b;
                   double *result = retval.fortran_vec ();
 
-                  octave_idx_type b_nc = b.cols ();
+                  F77_INT b_nr = to_f77_int (b.rows ());
+                  F77_INT b_nc = to_f77_int (b.cols ());
 
                   char job = 'N';
                   F77_XFCN (dgbtrs, DGBTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, n_lower, n_upper, b_nc, tmp_data,
-                             ldm, pipvt, result, b.rows (), err
+                             tmp_nr, n_lower, n_upper, b_nc, tmp_data,
+                             ldm, pipvt, result, b_nr, tmp_err
                              F77_CHAR_ARG_LEN (1)));
+
+                  err = tmp_err;
                 }
             }
         }
       else if (typ != MatrixType::Banded_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
@@ -4596,27 +4670,27 @@ SparseMatrix::bsolve (MatrixType &mattyp
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
         {
-          octave_idx_type n_lower = mattype.nlower ();
-          octave_idx_type ldm = n_lower + 1;
+          F77_INT n_lower = to_f77_int (mattype.nlower ());
+          F77_INT ldm = to_f77_int (n_lower + 1);
 
           Matrix m_band (ldm, nc);
           double *tmp_data = m_band.fortran_vec ();
 
           if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
-              for (octave_idx_type j = 0; j < ldm; j++)
+              for (F77_INT j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
             for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
               {
                 octave_idx_type ri = ridx (i);
@@ -4624,43 +4698,51 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   m_band(ri - j, j) = data (i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
             anorm = m_band.abs ().sum ().row (0).max ();
 
+          F77_INT tmp_nr = to_f77_int (nr);
+
+          F77_INT tmp_err = 0;
+
           char job = 'L';
           F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                     nr, n_lower, tmp_data, ldm, err
+                                     tmp_nr, n_lower, tmp_data, ldm, tmp_err
                                      F77_CHAR_ARG_LEN (1)));
 
+          err = tmp_err;
+
           if (err != 0)
             {
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Banded;
               rcond = 0.0;
               err = 0;
             }
           else
             {
               if (calc_cond)
                 {
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (dim_vector (nr, 1));
-                  octave_idx_type *piz = iz.fortran_vec ();
+                  Array<F77_INT> iz (dim_vector (nr, 1));
+                  F77_INT *piz = iz.fortran_vec ();
 
                   F77_XFCN (dpbcon, DPBCON,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, n_lower, tmp_data, ldm,
-                             anorm, rcond, pz, piz, err
+                             tmp_nr, n_lower, tmp_data, ldm,
+                             anorm, rcond, pz, piz, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
+                  err = tmp_err;
+
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                     {
                       err = -2;
@@ -4674,48 +4756,50 @@ SparseMatrix::bsolve (MatrixType &mattyp
                         octave::warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
-                  octave_idx_type b_nr = b.rows ();
+                  F77_INT b_nr = to_f77_int (b.rows ());
                   octave_idx_type b_nc = b.cols ();
                   OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
 
                   // Take a first guess that the number of nonzero terms
                   // will be as many as in b
                   volatile octave_idx_type x_nz = b.nnz ();
                   volatile octave_idx_type ii = 0;
                   retval = SparseMatrix (b_nr, b_nc, x_nz);
 
                   retval.xcidx (0) = 0;
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
-                      for (octave_idx_type i = 0; i < b_nr; i++)
+                      for (F77_INT i = 0; i < b_nr; i++)
                         Bx[i] = b.elem (i, j);
 
                       F77_XFCN (dpbtrs, DPBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
-                                 nr, n_lower, 1, tmp_data,
-                                 ldm, Bx, b_nr, err
+                                 tmp_nr, n_lower, 1, tmp_data,
+                                 ldm, Bx, b_nr, tmp_err
                                  F77_CHAR_ARG_LEN (1)));
 
+                      err = tmp_err;
+
                       if (err != 0)
                         {
                           // FIXME: Should this be a warning?
                           (*current_liboctave_error_handler)
                             ("SparseMatrix::solve solve failed");
                           err = -1;
                           break;
                         }
 
-                      for (octave_idx_type i = 0; i < b_nr; i++)
+                      for (F77_INT i = 0; i < b_nr; i++)
                         {
                           double tmp = Bx[i];
                           if (tmp != 0.0)
                             {
                               if (ii == x_nz)
                                 {
                                   // Resize the sparse matrix
                                   octave_idx_type sz = x_nz *
@@ -4734,19 +4818,19 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   retval.maybe_compress ();
                 }
             }
         }
 
       if (typ == MatrixType::Banded)
         {
           // Create the storage for the banded form of the sparse matrix
-          octave_idx_type n_upper = mattype.nupper ();
-          octave_idx_type n_lower = mattype.nlower ();
-          octave_idx_type ldm = n_upper + 2 * n_lower + 1;
+          F77_INT n_upper = to_f77_int (mattype.nupper ());
+          F77_INT n_lower = to_f77_int (mattype.nlower ());
+          F77_INT ldm = to_f77_int (n_upper + 2 * n_lower + 1);
 
           Matrix m_band (ldm, nc);
           double *tmp_data = m_band.fortran_vec ();
 
           if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
@@ -4768,21 +4852,27 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   double atmp = 0.;
                   for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                     atmp += fabs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
-          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
-          octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-          F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data,
-                                     ldm, pipvt, err));
+          F77_INT tmp_nr = to_f77_int (nr);
+
+          Array<F77_INT> ipvt (dim_vector (nr, 1));
+          F77_INT *pipvt = ipvt.fortran_vec ();
+
+          F77_INT tmp_err = 0;
+
+          F77_XFCN (dgbtrf, DGBTRF, (tmp_nr, tmp_nr, n_lower, n_upper,
+                                     tmp_data, ldm, pipvt, tmp_err));
+
+          err = tmp_err;
 
           if (err != 0)
             {
               err = -2;
               rcond = 0.0;
 
               if (sing_handler)
                 {
@@ -4794,25 +4884,29 @@ SparseMatrix::bsolve (MatrixType &mattyp
             }
           else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (dim_vector (nr, 1));
-                  octave_idx_type *piz = iz.fortran_vec ();
+                  Array<F77_INT> iz (dim_vector (nr, 1));
+                  F77_INT *piz = iz.fortran_vec ();
+
+                  F77_INT tmp_nc = to_f77_int (nc);
 
                   F77_XFCN (dgbcon, DGBCON,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nc, n_lower, n_upper, tmp_data, ldm, pipvt,
-                             anorm, rcond, pz, piz, err
+                             tmp_nc, n_lower, n_upper, tmp_data, ldm, pipvt,
+                             anorm, rcond, pz, piz, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
+                  err = tmp_err;
+
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                     {
                       err = -2;
@@ -4843,22 +4937,26 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
                       for (octave_idx_type i = 0; i < nr; i++)
                         work[i] = 0.;
                       for (octave_idx_type i = b.cidx (j);
                            i < b.cidx (j+1); i++)
                         work[b.ridx (i)] = b.data (i);
 
+                      F77_INT b_nr = to_f77_int (b.rows ());
+
                       F77_XFCN (dgbtrs, DGBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
-                                 nr, n_lower, n_upper, 1, tmp_data,
-                                 ldm, pipvt, work, b.rows (), err
+                                 tmp_nr, n_lower, n_upper, 1, tmp_data,
+                                 ldm, pipvt, work, b_nr, tmp_err
                                  F77_CHAR_ARG_LEN (1)));
 
+                      err = tmp_err;
+
                       // Count nonzeros in work vector and adjust
                       // space in retval if needed
                       octave_idx_type new_nnz = 0;
                       for (octave_idx_type i = 0; i < nr; i++)
                         if (work[i] != 0.)
                           new_nnz++;
 
                       if (ii + new_nnz > x_nz)
@@ -4910,27 +5008,27 @@ SparseMatrix::bsolve (MatrixType &mattyp
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
         {
-          octave_idx_type n_lower = mattype.nlower ();
-          octave_idx_type ldm = n_lower + 1;
+          F77_INT n_lower = to_f77_int (mattype.nlower ());
+          F77_INT ldm = n_lower + 1;
 
           Matrix m_band (ldm, nc);
           double *tmp_data = m_band.fortran_vec ();
 
           if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
-              for (octave_idx_type j = 0; j < ldm; j++)
+              for (F77_INT j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
             for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
               {
                 octave_idx_type ri = ridx (i);
@@ -4938,45 +5036,53 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   m_band(ri - j, j) = data (i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
             anorm = m_band.abs ().sum ().row (0).max ();
 
+          F77_INT tmp_nr = to_f77_int (nr);
+
+          F77_INT tmp_err = 0;
+
           char job = 'L';
           F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                     nr, n_lower, tmp_data, ldm, err
+                                     tmp_nr, n_lower, tmp_data, ldm, tmp_err
                                      F77_CHAR_ARG_LEN (1)));
 
+          err = tmp_err;
+
           if (err != 0)
             {
               // Matrix is not positive definite!! Fall through to
               // unsymmetric banded solver.
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Banded;
               rcond = 0.0;
               err = 0;
             }
           else
             {
               if (calc_cond)
                 {
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (dim_vector (nr, 1));
-                  octave_idx_type *piz = iz.fortran_vec ();
+                  Array<F77_INT> iz (dim_vector (nr, 1));
+                  F77_INT *piz = iz.fortran_vec ();
 
                   F77_XFCN (dpbcon, DPBCON,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, n_lower, tmp_data, ldm,
-                             anorm, rcond, pz, piz, err
+                             tmp_nr, n_lower, tmp_data, ldm,
+                             anorm, rcond, pz, piz, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
+                  err = tmp_err;
+
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                     {
                       err = -2;
@@ -4990,54 +5096,58 @@ SparseMatrix::bsolve (MatrixType &mattyp
                         octave::warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
-                  octave_idx_type b_nr = b.rows ();
+                  F77_INT b_nr = to_f77_int (b.rows ());
                   octave_idx_type b_nc = b.cols ();
 
                   OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
                   OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
 
                   retval.resize (b_nr, b_nc);
 
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
-                      for (octave_idx_type i = 0; i < b_nr; i++)
+                      for (F77_INT i = 0; i < b_nr; i++)
                         {
                           Complex c = b(i,j);
                           Bx[i] = c.real ();
                           Bz[i] = c.imag ();
                         }
 
                       F77_XFCN (dpbtrs, DPBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
-                                 nr, n_lower, 1, tmp_data,
-                                 ldm, Bx, b_nr, err
+                                 tmp_nr, n_lower, 1, tmp_data,
+                                 ldm, Bx, b_nr, tmp_err
                                  F77_CHAR_ARG_LEN (1)));
 
+                      err = tmp_err;
+
                       if (err != 0)
                         {
                           // FIXME: Should this be a warning?
                           (*current_liboctave_error_handler)
                             ("SparseMatrix::solve solve failed");
                           err = -1;
                           break;
                         }
 
                       F77_XFCN (dpbtrs, DPBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
-                                 nr, n_lower, 1, tmp_data,
-                                 ldm, Bz, b.rows (), err
+                                 tmp_nr, n_lower, 1, tmp_data,
+                                 ldm, Bz, b_nr, tmp_err
                                  F77_CHAR_ARG_LEN (1)));
 
+                      err = tmp_err;
+
                       if (err != 0)
                         {
                           // FIXME: Should this be a warning?
                           (*current_liboctave_error_handler)
                             ("SparseMatrix::solve solve failed");
                           err = -1;
                           break;
                         }
@@ -5047,28 +5157,28 @@ SparseMatrix::bsolve (MatrixType &mattyp
                     }
                 }
             }
         }
 
       if (typ == MatrixType::Banded)
         {
           // Create the storage for the banded form of the sparse matrix
-          octave_idx_type n_upper = mattype.nupper ();
-          octave_idx_type n_lower = mattype.nlower ();
-          octave_idx_type ldm = n_upper + 2 * n_lower + 1;
+          F77_INT n_upper = to_f77_int (mattype.nupper ());
+          F77_INT n_lower = to_f77_int (mattype.nlower ());
+          F77_INT ldm = n_upper + 2 * n_lower + 1;
 
           Matrix m_band (ldm, nc);
           double *tmp_data = m_band.fortran_vec ();
 
           if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
-              for (octave_idx_type j = 0; j < ldm; j++)
+              for (F77_INT j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
             for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
               m_band(ridx (i) - j + n_lower + n_upper, j) = data (i);
 
@@ -5081,21 +5191,27 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   double atmp = 0.;
                   for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                     atmp += fabs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
-          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
-          octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-          F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data,
-                                     ldm, pipvt, err));
+          F77_INT tmp_nr = to_f77_int (nr);
+
+          Array<F77_INT> ipvt (dim_vector (nr, 1));
+          F77_INT *pipvt = ipvt.fortran_vec ();
+
+          F77_INT tmp_err = 0;
+
+          F77_XFCN (dgbtrf, DGBTRF, (tmp_nr, tmp_nr, n_lower, n_upper,
+                                     tmp_data, ldm, pipvt, tmp_err));
+
+          err = tmp_err;
 
           if (err != 0)
             {
               err = -2;
               rcond = 0.0;
 
               if (sing_handler)
                 {
@@ -5107,25 +5223,29 @@ SparseMatrix::bsolve (MatrixType &mattyp
             }
           else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (dim_vector (nr, 1));
-                  octave_idx_type *piz = iz.fortran_vec ();
-
-                  F77_XFCN (dpbcon, DPBCON,
+                  Array<F77_INT> iz (dim_vector (nr, 1));
+                  F77_INT *piz = iz.fortran_vec ();
+
+                  F77_INT tmp_nc = to_f77_int (nc);
+
+                  F77_XFCN (dgbcon, DGBCON,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, n_lower, tmp_data, ldm,
-                             anorm, rcond, pz, piz, err
+                             tmp_nc, n_lower, n_upper, tmp_data, ldm, pipvt,
+                             anorm, rcond, pz, piz, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
+                  err = tmp_err;
+
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                     {
                       err = -2;
@@ -5140,16 +5260,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
+                  F77_INT b_nr = to_f77_int (b.rows ());
                   octave_idx_type b_nc = b.cols ();
                   retval.resize (nr,b_nc);
 
                   OCTAVE_LOCAL_BUFFER (double, Bz, nr);
                   OCTAVE_LOCAL_BUFFER (double, Bx, nr);
 
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
@@ -5157,26 +5278,30 @@ SparseMatrix::bsolve (MatrixType &mattyp
                         {
                           Complex c = b(i, j);
                           Bx[i] = c.real ();
                           Bz[i] = c.imag ();
                         }
 
                       F77_XFCN (dgbtrs, DGBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
-                                 nr, n_lower, n_upper, 1, tmp_data,
-                                 ldm, pipvt, Bx, b.rows (), err
+                                 tmp_nr, n_lower, n_upper, 1, tmp_data,
+                                 ldm, pipvt, Bx, b_nr, tmp_err
                                  F77_CHAR_ARG_LEN (1)));
 
+                      err = tmp_err;
+
                       F77_XFCN (dgbtrs, DGBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
-                                 nr, n_lower, n_upper, 1, tmp_data,
-                                 ldm, pipvt, Bz, b.rows (), err
+                                 tmp_nr, n_lower, n_upper, 1, tmp_data,
+                                 ldm, pipvt, Bz, b_nr, tmp_err
                                  F77_CHAR_ARG_LEN (1)));
 
+                      err = tmp_err;
+
                       for (octave_idx_type i = 0; i < nr; i++)
                         retval(i, j) = Complex (Bx[i], Bz[i]);
                     }
                 }
             }
         }
       else if (typ != MatrixType::Banded_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
@@ -5206,27 +5331,27 @@ SparseMatrix::bsolve (MatrixType &mattyp
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
         {
-          octave_idx_type n_lower = mattype.nlower ();
-          octave_idx_type ldm = n_lower + 1;
+          F77_INT n_lower = to_f77_int (mattype.nlower ());
+          F77_INT ldm = n_lower + 1;
 
           Matrix m_band (ldm, nc);
           double *tmp_data = m_band.fortran_vec ();
 
           if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
-              for (octave_idx_type j = 0; j < ldm; j++)
+              for (F77_INT j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
             for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
               {
                 octave_idx_type ri = ridx (i);
@@ -5234,46 +5359,54 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   m_band(ri - j, j) = data (i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
             anorm = m_band.abs ().sum ().row (0).max ();
 
+          F77_INT tmp_nr = to_f77_int (nr);
+
+          F77_INT tmp_err = 0;
+
           char job = 'L';
           F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                     nr, n_lower, tmp_data, ldm, err
+                                     tmp_nr, n_lower, tmp_data, ldm, tmp_err
                                      F77_CHAR_ARG_LEN (1)));
 
+          err = tmp_err;
+
           if (err != 0)
             {
               // Matrix is not positive definite!! Fall through to
               // unsymmetric banded solver.
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Banded;
 
               rcond = 0.0;
               err = 0;
             }
           else
             {
               if (calc_cond)
                 {
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (dim_vector (nr, 1));
-                  octave_idx_type *piz = iz.fortran_vec ();
+                  Array<F77_INT> iz (dim_vector (nr, 1));
+                  F77_INT *piz = iz.fortran_vec ();
 
                   F77_XFCN (dpbcon, DPBCON,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, n_lower, tmp_data, ldm,
-                             anorm, rcond, pz, piz, err
+                             tmp_nr, n_lower, tmp_data, ldm,
+                             anorm, rcond, pz, piz, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
+                  err = tmp_err;
+
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                     {
                       err = -2;
@@ -5287,59 +5420,63 @@ SparseMatrix::bsolve (MatrixType &mattyp
                         octave::warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
-                  octave_idx_type b_nr = b.rows ();
+                  F77_INT b_nr = to_f77_int (b.rows ());
                   octave_idx_type b_nc = b.cols ();
                   OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
                   OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
 
                   // Take a first guess that the number of nonzero terms
                   // will be as many as in b
                   volatile octave_idx_type x_nz = b.nnz ();
                   volatile octave_idx_type ii = 0;
                   retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
                   retval.xcidx (0) = 0;
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
 
-                      for (octave_idx_type i = 0; i < b_nr; i++)
+                      for (F77_INT i = 0; i < b_nr; i++)
                         {
                           Complex c = b(i,j);
                           Bx[i] = c.real ();
                           Bz[i] = c.imag ();
                         }
 
                       F77_XFCN (dpbtrs, DPBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
-                                 nr, n_lower, 1, tmp_data,
-                                 ldm, Bx, b_nr, err
+                                 tmp_nr, n_lower, 1, tmp_data,
+                                 ldm, Bx, b_nr, tmp_err
                                  F77_CHAR_ARG_LEN (1)));
 
+                      err = tmp_err;
+
                       if (err != 0)
                         {
                           // FIXME: Should this be a warning?
                           (*current_liboctave_error_handler)
                             ("SparseMatrix::solve solve failed");
                           err = -1;
                           break;
                         }
 
                       F77_XFCN (dpbtrs, DPBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
-                                 nr, n_lower, 1, tmp_data,
-                                 ldm, Bz, b_nr, err
+                                 tmp_nr, n_lower, 1, tmp_data,
+                                 ldm, Bz, b_nr, tmp_err
                                  F77_CHAR_ARG_LEN (1)));
 
+                      err = tmp_err;
+
                       if (err != 0)
                         {
                           // FIXME: Should this be a warning?
                           (*current_liboctave_error_handler)
                             ("SparseMatrix::solve solve failed");
 
                           err = -1;
                           break;
@@ -5374,28 +5511,28 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   retval.maybe_compress ();
                 }
             }
         }
 
       if (typ == MatrixType::Banded)
         {
           // Create the storage for the banded form of the sparse matrix
-          octave_idx_type n_upper = mattype.nupper ();
-          octave_idx_type n_lower = mattype.nlower ();
-          octave_idx_type ldm = n_upper + 2 * n_lower + 1;
+          F77_INT n_upper = to_f77_int (mattype.nupper ());
+          F77_INT n_lower = to_f77_int (mattype.nlower ());
+          F77_INT ldm = n_upper + 2 * n_lower + 1;
 
           Matrix m_band (ldm, nc);
           double *tmp_data = m_band.fortran_vec ();
 
           if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
-              for (octave_idx_type j = 0; j < ldm; j++)
+              for (F77_INT j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
           for (octave_idx_type j = 0; j < nc; j++)
             for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
               m_band(ridx (i) - j + n_lower + n_upper, j) = data (i);
 
@@ -5408,21 +5545,27 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   double atmp = 0.;
                   for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                     atmp += fabs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
-          Array<octave_idx_type> ipvt (dim_vector (nr, 1));
-          octave_idx_type *pipvt = ipvt.fortran_vec ();
-
-          F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data,
-                                     ldm, pipvt, err));
+          F77_INT tmp_nr = to_f77_int (nr);
+
+          Array<F77_INT> ipvt (dim_vector (nr, 1));
+          F77_INT *pipvt = ipvt.fortran_vec ();
+
+          F77_INT tmp_err = 0;
+
+          F77_XFCN (dgbtrf, DGBTRF, (tmp_nr, tmp_nr, n_lower, n_upper,
+                                     tmp_data, ldm, pipvt, tmp_err));
+
+          err = tmp_err;
 
           if (err != 0)
             {
               err = -2;
               rcond = 0.0;
 
               if (sing_handler)
                 {
@@ -5434,25 +5577,29 @@ SparseMatrix::bsolve (MatrixType &mattyp
             }
           else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
-                  Array<octave_idx_type> iz (dim_vector (nr, 1));
-                  octave_idx_type *piz = iz.fortran_vec ();
+                  Array<F77_INT> iz (dim_vector (nr, 1));
+                  F77_INT *piz = iz.fortran_vec ();
+
+                  F77_INT tmp_nc = to_f77_int (nc);
 
                   F77_XFCN (dgbcon, DGBCON,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nc, n_lower, n_upper, tmp_data, ldm, pipvt,
-                             anorm, rcond, pz, piz, err
+                             tmp_nc, n_lower, n_upper, tmp_data, ldm, pipvt,
+                             anorm, rcond, pz, piz, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
+                  err = tmp_err;
+
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
                     {
                       err = -2;
@@ -5468,16 +5615,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
                   volatile octave_idx_type x_nz = b.nnz ();
+                  F77_INT b_nr = to_f77_int (b.rows ());
                   octave_idx_type b_nc = b.cols ();
                   retval = SparseComplexMatrix (nr, b_nc, x_nz);
                   retval.xcidx (0) = 0;
                   volatile octave_idx_type ii = 0;
 
                   OCTAVE_LOCAL_BUFFER (double, Bx, nr);
                   OCTAVE_LOCAL_BUFFER (double, Bz, nr);
 
@@ -5493,26 +5641,30 @@ SparseMatrix::bsolve (MatrixType &mattyp
                         {
                           Complex c = b.data (i);
                           Bx[b.ridx (i)] = c.real ();
                           Bz[b.ridx (i)] = c.imag ();
                         }
 
                       F77_XFCN (dgbtrs, DGBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
-                                 nr, n_lower, n_upper, 1, tmp_data,
-                                 ldm, pipvt, Bx, b.rows (), err
+                                 tmp_nr, n_lower, n_upper, 1, tmp_data,
+                                 ldm, pipvt, Bx, b_nr, tmp_err
                                  F77_CHAR_ARG_LEN (1)));
 
+                      err = tmp_err;
+
                       F77_XFCN (dgbtrs, DGBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
-                                 nr, n_lower, n_upper, 1, tmp_data,
-                                 ldm, pipvt, Bz, b.rows (), err
+                                 tmp_nr, n_lower, n_upper, 1, tmp_data,
+                                 ldm, pipvt, Bz, b_nr, tmp_err
                                  F77_CHAR_ARG_LEN (1)));
 
+                      err = tmp_err;
+
                       // Count nonzeros in work vector and adjust
                       // space in retval if needed
                       octave_idx_type new_nnz = 0;
                       for (octave_idx_type i = 0; i < nr; i++)
                         if (Bx[i] != 0. || Bz[i] != 0.)
                           new_nnz++;
 
                       if (ii + new_nnz > x_nz)
