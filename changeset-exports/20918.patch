# HG changeset patch
# User Rik <rik@octave.org>
# Date 1450306831 28800
#      Wed Dec 16 15:00:31 2015 -0800
# Node ID 6f0bd96f93c0b3423feebe7c8fe7843a362f9ede
# Parent  a7051a169cad0ed4eacce0ce807cc50f233f5fee
maint: Use new C++ archetype in more files.
Place input validation first in files.
Move declaration of retval down in function to be closer to point of usage.
Eliminate else clause after if () error.
Use "return ovl()" where it makes sense.

* __dispatch__.cc, __dsearchn__.cc, __ichol__.cc, __lin_interpn__.cc,
balance.cc, betainc.cc, bitfcns.cc, bsxfun.cc, cellfun.cc, colloc.cc, conv2.cc,
daspk.cc, dasrt.cc, dassl.cc, data.cc, debug.cc, dirfns.cc, dlmread.cc, dot.cc,
eig.cc, error.cc, fft.cc, fft2.cc, fftn.cc, file-io.cc, ov-type-conv.h:
Use new C++ archetype in more files.

diff --git a/libinterp/corefcn/__dispatch__.cc b/libinterp/corefcn/__dispatch__.cc
--- a/libinterp/corefcn/__dispatch__.cc
+++ b/libinterp/corefcn/__dispatch__.cc
@@ -37,33 +37,33 @@ along with Octave; see the file COPYING.
 #include "pager.h"
 #include "parse.h"
 #include "symtab.h"
 #include "variables.h"
 
 DEFUN (__dispatch__, args, nargout,
        "Undocumented internal function")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
 
   std::string f, r, t;
 
   f = args(0).xstring_value ("__dispatch__: first argument must be a function name");
 
   if (nargin > 1)
     r = args(1).xstring_value ("__dispatch__: second argument must be a function name");
 
   if (nargin > 2)
     t = args(2).xstring_value ("__dispatch__: third argument must be a type name");
 
+  octave_value retval;
+
   if (nargin == 1)
     {
       if (nargout > 0)
         {
           symbol_table::fcn_info::dispatch_map_type dm
             = symbol_table::get_dispatch (f);
 
           size_t len = dm.size ();
diff --git a/libinterp/corefcn/__dsearchn__.cc b/libinterp/corefcn/__dsearchn__.cc
--- a/libinterp/corefcn/__dsearchn__.cc
+++ b/libinterp/corefcn/__dsearchn__.cc
@@ -35,73 +35,67 @@ along with Octave; see the file COPYING.
 #include "oct-obj.h"
 
 DEFUN (__dsearchn__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {[@var{idx}, @var{d}] =} dsearch (@var{x}, @var{xi})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 2)
     print_usage ();
 
   Matrix x = args(0).matrix_value ().transpose ();
   Matrix xi = args(1).matrix_value ().transpose ();
 
   if (x.rows () != xi.rows () || x.columns () < 1)
     error ("__dsearch__: number of rows of X and XI must match");
-  else
-    {
-      octave_idx_type n = x.rows ();
-      octave_idx_type nx = x.columns ();
-      octave_idx_type nxi = xi.columns ();
+
+  octave_idx_type n = x.rows ();
+  octave_idx_type nx = x.columns ();
+  octave_idx_type nxi = xi.columns ();
 
-      ColumnVector idx (nxi);
-      double *pidx = idx.fortran_vec ();
-      ColumnVector dist (nxi);
-      double *pdist = dist.fortran_vec ();
+  ColumnVector idx (nxi);
+  double *pidx = idx.fortran_vec ();
+  ColumnVector dist (nxi);
+  double *pdist = dist.fortran_vec ();
 
 #define DIST(dd, y, yi, m) \
-  dd = 0.; \
-  for (octave_idx_type k = 0; k < m; k++) \
-   { \
-     double yd = y[k] - yi[k]; \
-     dd += yd * yd; \
-   } \
-  dd = sqrt (dd);
+dd = 0.; \
+for (octave_idx_type k = 0; k < m; k++) \
+{ \
+ double yd = y[k] - yi[k]; \
+ dd += yd * yd; \
+} \
+dd = sqrt (dd);
 
-      const double *pxi = xi.fortran_vec ();
-      for (octave_idx_type i = 0; i < nxi; i++)
+  const double *pxi = xi.fortran_vec ();
+  for (octave_idx_type i = 0; i < nxi; i++)
+    {
+      double d0;
+      const double *px = x.fortran_vec ();
+      DIST(d0, px, pxi, n);
+      *pidx = 1.;
+      for (octave_idx_type j = 1; j < nx; j++)
         {
-          double d0;
-          const double *px = x.fortran_vec ();
-          DIST(d0, px, pxi, n);
-          *pidx = 1.;
-          for (octave_idx_type j = 1; j < nx; j++)
+          px += n;
+          double d;
+          DIST (d, px, pxi, n);
+          if (d < d0)
             {
-              px += n;
-              double d;
-              DIST (d, px, pxi, n);
-              if (d < d0)
-                {
-                  d0 = d;
-                  *pidx = static_cast<double>(j + 1);
-                }
-              OCTAVE_QUIT;
+              d0 = d;
+              *pidx = static_cast<double>(j + 1);
             }
-
-          *pdist++ = d0;
-          pidx++;
-          pxi += n;
+          OCTAVE_QUIT;
         }
 
-      retval = ovl (idx, dist);
+      *pdist++ = d0;
+      pidx++;
+      pxi += n;
     }
 
-  return retval;
+  return ovl (idx, dist);
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
diff --git a/libinterp/corefcn/__ichol__.cc b/libinterp/corefcn/__ichol__.cc
--- a/libinterp/corefcn/__ichol__.cc
+++ b/libinterp/corefcn/__ichol__.cc
@@ -179,62 +179,53 @@ void ichol_0 (octave_matrix_t& sm, const
 }
 
 DEFUN (__ichol0__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{L} =} __ichol0__ (@var{A})\n\
 @deftypefnx {} {@var{L} =} __ichol0__ (@var{A}, @var{michol})\n\
 Undocumented internal function.\n\
 @end deftypefn")
-
 {
-  octave_value_list retval;
-
   int nargin = args.length ();
+
   std::string michol = "off";
-
-  if (nargin < 1 || nargin > 2)
-    print_usage ();
-
   if (nargin == 2)
     michol = args(1).string_value ();
 
   // In ICHOL0 algorithm the zero-pattern of the input matrix is preserved
   // so it's structure does not change during the algorithm.  The same input
   // matrix is used to build the output matrix due to that fact.
   octave_value_list param_list;
-  if (!args(0).is_complex_type ())
+  if (! args(0).is_complex_type ())
     {
       SparseMatrix sm = args(0).sparse_matrix_value ();
       param_list.append (sm);
       sm = feval ("tril", param_list)(0).sparse_matrix_value ();
       ichol_0 <SparseMatrix, double, ichol_mult_real,
                ichol_checkpivot_real> (sm, michol);
 
-      retval(0) = sm;
+      return ovl (sm);
     }
   else
     {
       SparseComplexMatrix sm = args(0).sparse_complex_matrix_value ();
       param_list.append (sm);
       sm = feval ("tril", param_list)(0).sparse_complex_matrix_value ();
       ichol_0 <SparseComplexMatrix, Complex, ichol_mult_complex,
                ichol_checkpivot_complex> (sm, michol);
 
-      retval(0) = sm;
+      return ovl (sm);
     }
-
-  return retval;
 }
 
 template <typename octave_matrix_t, typename T,  T (*ichol_mult) (T, T),
           bool (*ichol_checkpivot) (T)>
 void ichol_t (const octave_matrix_t& sm, octave_matrix_t& L, const T* cols_norm,
               const T droptol, const std::string michol = "off")
-
 {
 
   const octave_idx_type n = sm.cols ();
   octave_idx_type j, jrow, jend, jjrow, i, k, jj, total_len,
                   w_len, max_len, ind;
   char opt;
   enum {OFF, ON};
   if (michol == "on")
@@ -427,27 +418,22 @@ void ichol_t (const octave_matrix_t& sm,
 DEFUN (__icholt__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{L} =} __icholt__ (@var{A})\n\
 @deftypefnx {} {@var{L} =} __icholt__ (@var{A}, @var{droptol})\n\
 @deftypefnx {} {@var{L} =} __icholt__ (@var{A}, @var{droptol}, @var{michol})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  octave_value_list retval;
   int nargin = args.length ();
   // Default values of parameters
   std::string michol = "off";
   double droptol = 0;
 
-  if (nargin < 1 || nargin > 3)
-    print_usage ();
-
   // Don't repeat input validation of arguments done in ichol.m
-
   if (nargin >= 2)
     droptol = args(1).double_value ();
 
   if (nargin == 3)
     michol = args(2).string_value ();
 
   octave_value_list param_list;
   if (! args(0).is_complex_type ())
@@ -461,17 +447,17 @@ Undocumented internal function.\n\
       param_list(1) = 1;
       param_list(2) = "cols";
       cols_norm = feval ("norm", param_list)(0).vector_value ();
       param_list.clear ();
       ichol_t <SparseMatrix,
                double, ichol_mult_real, ichol_checkpivot_real>
                (sm_l, L, cols_norm.fortran_vec (), droptol, michol);
 
-      retval(0) = L;
+      return ovl (L);
     }
   else
     {
       Array <Complex> cols_norm;
       SparseComplexMatrix L;
       param_list.append (args(0).sparse_complex_matrix_value ());
       SparseComplexMatrix sm_l =
         feval ("tril", param_list)(0).sparse_complex_matrix_value ();
@@ -480,19 +466,17 @@ Undocumented internal function.\n\
       param_list(2) = "cols";
       cols_norm = feval ("norm", param_list)(0).complex_vector_value ();
       param_list.clear ();
       ichol_t <SparseComplexMatrix,
                Complex, ichol_mult_complex, ichol_checkpivot_complex>
                (sm_l, L, cols_norm.fortran_vec (),
                 Complex (droptol), michol);
 
-      retval(0) = L;
+      return ovl (L);
     }
-
-  return retval;
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
 
diff --git a/libinterp/corefcn/__lin_interpn__.cc b/libinterp/corefcn/__lin_interpn__.cc
--- a/libinterp/corefcn/__lin_interpn__.cc
+++ b/libinterp/corefcn/__lin_interpn__.cc
@@ -260,23 +260,23 @@ lin_interpn (int n, M *X, const M V, M *
 //This function only performs linear interpolation.
 
 DEFUN (__lin_interpn__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {@var{vi} =} __lin_interpn__ (@var{x1}, @var{x2}, @dots{}, @var{xn}, @var{v}, @var{y1}, @var{y2}, @dots{}, @var{yn})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin < 2 || nargin % 2 == 0)
     print_usage ();
 
+  octave_value retval;
+
   // dimension of the problem
   int n = (nargin-1)/2;
 
   if (args(n).is_single_type ())
     {
       OCTAVE_LOCAL_BUFFER (FloatNDArray, X, n);
       OCTAVE_LOCAL_BUFFER (FloatNDArray, Y, n);
 
diff --git a/libinterp/corefcn/balance.cc b/libinterp/corefcn/balance.cc
--- a/libinterp/corefcn/balance.cc
+++ b/libinterp/corefcn/balance.cc
@@ -86,23 +86,23 @@ Permute only; do not scale.\n\
 @end table\n\
 \n\
 Algebraic eigenvalue balancing uses standard @sc{lapack} routines.\n\
 \n\
 Generalized eigenvalue problem balancing uses Ward's algorithm\n\
 (SIAM Journal on Scientific and Statistical Computing, 1981).\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3 || nargout < 0)
     print_usage ();
 
+  octave_value_list retval;
+
   // determine if it's AEP or GEP
   bool AEPcase = nargin == 1 || args(1).is_string ();
 
   // problem dimension
   octave_idx_type nn = args(0).rows ();
 
   if (nn != args(0).columns ())
     {
diff --git a/libinterp/corefcn/betainc.cc b/libinterp/corefcn/betainc.cc
--- a/libinterp/corefcn/betainc.cc
+++ b/libinterp/corefcn/betainc.cc
@@ -60,21 +60,21 @@ betainc (x, a, b) = -----------   | t^(a
 @end ifnottex\n\
 \n\
 If @var{x} has more than one component, both @var{a} and @var{b} must be\n\
 scalars.  If @var{x} is a scalar, @var{a} and @var{b} must be of\n\
 compatible dimensions.\n\
 @seealso{betaincinv, beta, betaln}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 3)
     print_usage ();
 
+  octave_value retval;
+
   octave_value x_arg = args(0);
   octave_value a_arg = args(1);
   octave_value b_arg = args(2);
 
   // FIXME: Can we make a template version of the duplicated code below
   if (x_arg.is_single_type () || a_arg.is_single_type ()
       || b_arg.is_single_type ())
     {
@@ -293,21 +293,21 @@ Compute the inverse of the incomplete Be
 The inverse is the value @var{x} such that\n\
 \n\
 @example\n\
 @var{y} == betainc (@var{x}, @var{a}, @var{b})\n\
 @end example\n\
 @seealso{betainc, beta, betaln}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 3)
     print_usage ();
 
+  octave_value retval;
+
   octave_value x_arg = args(0);
   octave_value a_arg = args(1);
   octave_value b_arg = args(2);
 
   if (x_arg.is_scalar_type ())
     {
       double x = x_arg.double_value ();
 
@@ -391,17 +391,16 @@ The inverse is the value @var{x} such th
   // extra work to calculate betaincinv to double precision and then throw
   // that precision away.
   if (x_arg.is_single_type () || a_arg.is_single_type ()
       || b_arg.is_single_type ())
     {
       retval = Array<float> (retval.array_value ());
     }
 
-
   return retval;
 }
 
 /*
 %!assert (betaincinv ([0.875 0.6875], [1 2], 3), [0.5 0.5], sqrt (eps))
 %!assert (betaincinv (0.5, 3, 3), 0.5, sqrt (eps))
 %!assert (betaincinv (0.34375, 4, 3), 0.5, sqrt (eps))
 %!assert (betaincinv (0.2265625, 5, 3), 0.5, sqrt (eps))
diff --git a/libinterp/corefcn/bitfcns.cc b/libinterp/corefcn/bitfcns.cc
--- a/libinterp/corefcn/bitfcns.cc
+++ b/libinterp/corefcn/bitfcns.cc
@@ -149,21 +149,21 @@ static inline int
 bitop_arg_is_float (const octave_value& arg)
 {
   return arg.class_name () == octave_float_scalar::static_class_name ();
 }
 
 octave_value
 bitop (const std::string& fname, const octave_value_list& args)
 {
-  octave_value retval;
-
   if (args.length () != 2)
     print_usage ();
 
+  octave_value retval;
+
   if (args(0).class_name () == octave_scalar::static_class_name ()
       || args(0).class_name () == octave_float_scalar::static_class_name ()
       || args(0).class_name () == octave_bool::static_class_name ()
       || args(1).class_name () == octave_scalar::static_class_name ()
       || args(1).class_name () == octave_float_scalar::static_class_name ()
       || args(1).class_name () == octave_bool::static_class_name ())
     {
       bool arg0_is_int = bitop_arg_is_int (args(0));
@@ -565,77 +565,77 @@ bitshift (10, [-2, -1, 0, 1, 2])\n\
 @c\n\
 @c bitshift ([1, 10], 2, [3,4])\n\
 @c @result{} 4  8\n\
 @end group\n\
 @end example\n\
 @seealso{bitand, bitor, bitxor, bitset, bitget, bitcmp, intmax, flintmax}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
 
-  int nbits = 64;
+  NDArray n = args(1).xarray_value ("bitshift: K must be a scalar or array of integers");
 
-  NDArray n = args(1).xarray_value ("bitshift: K must be a scalar or array of integers");
+  int nbits = 64;
 
   if (nargin == 3)
     {
-      // FIXME: for compatibility, we should accept an array
-      // or a scalar as the third argument.
+      // FIXME: for compatibility, we should accept an array or a scalar
+      //        as the third argument.
       if (args(2).numel () > 1)
         error ("bitshift: N must be a scalar integer");
       else
         {
           nbits = args(2).xint_value ("bitshift: N must be an integer");
 
           if (nbits < 0)
             error ("bitshift: N must be positive");
         }
     }
 
+  octave_value retval;
+
   octave_value m_arg = args(0);
   std::string cname = m_arg.class_name ();
 
-  if (cname == "uint8")
+  if (cname == "double")
+    {
+      static const int bits_in_mantissa
+        = std::numeric_limits<double>::digits;
+
+      nbits = (nbits < bits_in_mantissa ? nbits : bits_in_mantissa);
+      int64_t mask = max_mantissa_value<double> ();
+      if (nbits < bits_in_mantissa)
+        mask = mask >> (bits_in_mantissa - nbits);
+      else if (nbits < 1)
+        mask = 0;
+      int bits_in_type = sizeof (double)
+        * std::numeric_limits<unsigned char>::digits;
+      NDArray m = m_arg.array_value ();
+      DO_BITSHIFT ();
+    }
+  else if (cname == "uint8")
     DO_UBITSHIFT (uint8, nbits < 8 ? nbits : 8);
   else if (cname == "uint16")
     DO_UBITSHIFT (uint16, nbits < 16 ? nbits : 16);
   else if (cname == "uint32")
     DO_UBITSHIFT (uint32, nbits < 32 ? nbits : 32);
   else if (cname == "uint64")
     DO_UBITSHIFT (uint64, nbits < 64 ? nbits : 64);
   else if (cname == "int8")
     DO_SBITSHIFT (int8, nbits < 8 ? nbits : 8);
   else if (cname == "int16")
     DO_SBITSHIFT (int16, nbits < 16 ? nbits : 16);
   else if (cname == "int32")
     DO_SBITSHIFT (int32, nbits < 32 ? nbits : 32);
   else if (cname == "int64")
     DO_SBITSHIFT (int64, nbits < 64 ? nbits : 64);
-  else if (cname == "double")
-    {
-      static const int bits_in_mantissa
-        = std::numeric_limits<double>::digits;
-
-      nbits = (nbits < bits_in_mantissa ? nbits : bits_in_mantissa);
-      int64_t mask = max_mantissa_value<double> ();
-      if (nbits < bits_in_mantissa)
-        mask = mask >> (bits_in_mantissa - nbits);
-      else if (nbits < 1)
-        mask = 0;
-      int bits_in_type = sizeof (double)
-        * std::numeric_limits<unsigned char>::digits;
-      NDArray m = m_arg.array_value ();
-      DO_BITSHIFT ();
-    }
   else if (cname == "single")
     {
       static const int bits_in_mantissa
         = std::numeric_limits<float>::digits;
       nbits = (nbits < bits_in_mantissa ? nbits : bits_in_mantissa);
       int64_t mask = max_mantissa_value<float> ();
       if (nbits < bits_in_mantissa)
         mask = mask >> (bits_in_mantissa - nbits);
@@ -674,36 +674,31 @@ Return the largest integer that can be r
 floating point value.\n\
 \n\
 The default class is @qcode{\"double\"}, but @qcode{\"single\"} is a valid\n\
 option.  On IEEE 754 compatible systems, @code{flintmax} is @w{@math{2^{53}}}\n\
 for @qcode{\"double\"} and @w{@math{2^{24}}} for @qcode{\"single\"}.\n\
 @seealso{intmax, realmax, realmin}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  std::string cname = "double";
-
   int nargin = args.length ();
 
   if (nargin > 1)
     print_usage ();
 
+  std::string cname = "double";
   if (nargin == 1)
     cname = args(0).xstring_value ("flintmax: argument must be a string");
 
   if (cname == "double")
-    retval = (static_cast<double> (max_mantissa_value<double> () + 1));
+    return ovl (static_cast<double> (max_mantissa_value<double> () + 1));
   else if (cname == "single")
-    retval = (static_cast<float> (max_mantissa_value<float> () + 1));
+    return ovl (static_cast<float> (max_mantissa_value<float> () + 1));
   else
     error ("flintmax: not defined for class '%s'", cname.c_str ());
-
-  return retval;
 }
 
 /*
 %!assert (flintmax (), 2^53)
 %!assert (flintmax ("double"), 2^53)
 %!assert (flintmax ("single"), single (2^24))
 
 %!error flintmax (0)
@@ -744,28 +739,27 @@ unsigned 32-bit integer.\n\
 @item uint64\n\
 unsigned 64-bit integer.\n\
 @end table\n\
 \n\
 The default for @var{type} is @code{int32}.\n\
 @seealso{intmin, flintmax}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  std::string cname = "int32";
-
   int nargin = args.length ();
 
   if (nargin > 1)
     print_usage ();
 
+  std::string cname = "int32";
   if (nargin == 1)
     cname = args(0).xstring_value ("intmax: argument must be a string");
 
+  octave_value retval;
+
   if (cname == "uint8")
     retval = octave_uint8 (std::numeric_limits<uint8_t>::max ());
   else if (cname == "uint16")
     retval = octave_uint16 (std::numeric_limits<uint16_t>::max ());
   else if (cname == "uint32")
     retval = octave_uint32 (std::numeric_limits<uint32_t>::max ());
   else if (cname == "uint64")
     retval = octave_uint64 (std::numeric_limits<uint64_t>::max ());
@@ -832,28 +826,27 @@ unsigned 32-bit integer.\n\
 @item uint64\n\
 unsigned 64-bit integer.\n\
 @end table\n\
 \n\
 The default for @var{type} is @code{int32}.\n\
 @seealso{intmax, flintmax}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  std::string cname = "int32";
-
   int nargin = args.length ();
 
   if (nargin > 1)
     print_usage ();
 
+  std::string cname = "int32";
   if (nargin == 1)
     cname = args(0).xstring_value ("intmin: argument must be a string");
 
+  octave_value retval;
+
   if (cname == "uint8")
     retval = octave_uint8 (std::numeric_limits<uint8_t>::min ());
   else if (cname == "uint16")
     retval = octave_uint16 (std::numeric_limits<uint16_t>::min ());
   else if (cname == "uint32")
     retval = octave_uint32 (std::numeric_limits<uint32_t>::min ());
   else if (cname == "uint64")
     retval = octave_uint64 (std::numeric_limits<uint64_t>::min ());
diff --git a/libinterp/corefcn/bsxfun.cc b/libinterp/corefcn/bsxfun.cc
--- a/libinterp/corefcn/bsxfun.cc
+++ b/libinterp/corefcn/bsxfun.cc
@@ -330,50 +330,46 @@ accepting two column-vector arguments of
 argument and a scalar.\n\
 \n\
 The dimensions of @var{A} and @var{B} must be equal or singleton.  The\n\
 singleton dimensions of the arrays will be expanded to the same\n\
 dimensionality as the other array.\n\
 @seealso{arrayfun, cellfun}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 3)
     print_usage ();
 
   octave_value func = args(0);
-
   if (func.is_string ())
     {
       std::string name = func.string_value ();
       func = symbol_table::find_function (name);
       if (func.is_undefined ())
         error ("bsxfun: invalid function name: %s", name.c_str ());
     }
-  else if (! (args(0).is_function_handle ()
-              || args(0).is_inline_function ()))
+  else if (! (args(0).is_function_handle () || args(0).is_inline_function ()))
     error ("bsxfun: F must be a string or function handle");
 
+  octave_value_list retval;
+
   const octave_value A = args(1);
   const octave_value B = args(2);
 
   if (func.is_builtin_function ()
-      || (func.is_function_handle ()
-          && ! A.is_object () && ! B.is_object ()))
+      || (func.is_function_handle () && ! A.is_object () && ! B.is_object ()))
     {
       // This may break if the default behavior is overridden.  But if you
-      // override arithmetic operators for builtin classes, you should
-      // expect mayhem anyway (constant folding etc).  Querying
-      // is_overloaded() may not be exactly what we need here.
+      // override arithmetic operators for builtin classes, you should expect
+      // mayhem anyway (constant folding etc).  Querying is_overloaded() may
+      // not be exactly what we need here.
       octave_function *fcn_val = func.function_value ();
       if (fcn_val)
         {
-          octave_value tmp = maybe_optimized_builtin (fcn_val->name (),
-                                                      A, B);
+          octave_value tmp = maybe_optimized_builtin (fcn_val->name (), A, B);
           if (tmp.is_defined ())
             retval(0) = tmp;
         }
     }
 
   if (retval.empty ())
     {
       dim_vector dva = A.dims ();
@@ -387,20 +383,17 @@ dimensionality as the other array.\n\
       else if (nda < ndb)
         {
           dva.resize (ndb, 1);
           nd = ndb;
         }
 
       for (octave_idx_type i = 0; i < nd; i++)
         if (dva(i) != dvb(i) && dva(i) != 1 && dvb(i) != 1)
-          {
-            error ("bsxfun: dimensions of A and B must match");
-            break;
-          }
+          error ("bsxfun: dimensions of A and B must match");
 
       // Find the size of the output
       dim_vector dvc;
       dvc.resize (nd);
 
       for (octave_idx_type i = 0; i < nd; i++)
         dvc(i) = (dva(i) < 1 ? dva(i)
                   : (dvb(i) < 1 ? dvb(i)
@@ -457,24 +450,23 @@ dimensionality as the other array.\n\
           for (octave_idx_type i = 0; i < ncount; i++)
             {
               if (maybe_update_column (Ac, A, dva, dvc, i, idxA))
                 inputs (0) = Ac;
 
               if (maybe_update_column (Bc, B, dvb, dvc, i, idxB))
                 inputs (1) = Bc;
 
-              octave_value_list tmp = func.do_multi_index_op (1,
-                                                              inputs);
+              octave_value_list tmp = func.do_multi_index_op (1, inputs);
 
 #define BSXINIT(T, CLS, EXTRACTOR) \
   (result_type == CLS) \
     { \
       have_ ## T = true; \
-      result_ ## T = tmp (0). EXTRACTOR ## _array_value (); \
+      result_ ## T = tmp(0). EXTRACTOR ## _array_value (); \
       result_ ## T .resize (dvc); \
     }
 
               if (i == 0)
                 {
                   if (! tmp(0).is_sparse_type ())
                     {
                       std::string result_type = tmp(0).class_name ();
@@ -507,29 +499,29 @@ dimensionality as the other array.\n\
                             {
                               have_ComplexNDArray = true;
                               result_ComplexNDArray =
                                 tmp(0).complex_array_value ();
                               result_ComplexNDArray.resize (dvc);
                             }
                         }
                       else if BSXINIT(boolNDArray, "logical", bool)
-                        else if BSXINIT(int8NDArray, "int8", int8)
-                          else if BSXINIT(int16NDArray, "int16", int16)
-                            else if BSXINIT(int32NDArray, "int32", int32)
-                              else if BSXINIT(int64NDArray, "int64", int64)
-                                else if BSXINIT(uint8NDArray, "uint8", uint8)
-                                  else if BSXINIT(uint16NDArray, "uint16", uint16)
-                                    else if BSXINIT(uint32NDArray, "uint32", uint32)
-                                      else if BSXINIT(uint64NDArray, "uint64", uint64)
-                                        else
-                                          {
-                                            C = tmp (0);
-                                            C = C.resize (dvc);
-                                          }
+                      else if BSXINIT(int8NDArray, "int8", int8)
+                      else if BSXINIT(int16NDArray, "int16", int16)
+                      else if BSXINIT(int32NDArray, "int32", int32)
+                      else if BSXINIT(int64NDArray, "int64", int64)
+                      else if BSXINIT(uint8NDArray, "uint8", uint8)
+                      else if BSXINIT(uint16NDArray, "uint16", uint16)
+                      else if BSXINIT(uint32NDArray, "uint32", uint32)
+                      else if BSXINIT(uint64NDArray, "uint64", uint64)
+                      else
+                        {
+                          C = tmp(0);
+                          C = C.resize (dvc);
+                        }
                     }
                 }
               else
                 {
                   update_index (ra_idx, dvc, i);
 
                   if (have_FloatNDArray
                       || have_FloatComplexNDArray)
@@ -604,21 +596,21 @@ dimensionality as the other array.\n\
                           have_NDArray = false;
                           have_ComplexNDArray = true;
                         }
                     }
 
 #define BSXLOOP(T, CLS, EXTRACTOR) \
   (have_ ## T) \
     { \
-      if (tmp (0).class_name () != CLS) \
+      if (tmp(0).class_name () != CLS) \
         { \
           have_ ## T = false; \
           C = result_ ## T; \
-          C = do_cat_op (C, tmp (0), ra_idx); \
+          C = do_cat_op (C, tmp(0), ra_idx); \
         } \
       else \
         result_ ## T .insert (tmp(0). EXTRACTOR ## _array_value (), ra_idx); \
     }
 
                   else if BSXLOOP(ComplexNDArray, "double", complex)
                   else if BSXLOOP(boolNDArray, "logical", bool)
                   else if BSXLOOP(int8NDArray, "int8", int8)
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -396,31 +396,32 @@ a = @{@dots{}@}\n\
 v = cellfun (@@(x) det (x), a); # compute determinants\n\
 v = cellfun (@@det, a); # faster\n\
 @end group\n\
 @end example\n\
 \n\
 @seealso{arrayfun, structfun, spfun}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
   int nargin = args.length ();
-  int nargout1 = (nargout < 1 ? 1 : nargout);
 
   if (nargin < 2)
     print_usage ();
 
-  octave_value func = args(0);
-
   if (! args(1).is_cell ())
     error ("cellfun: C must be a cell array");
 
+  octave_value_list retval;
+  int nargout1 = (nargout < 1 ? 1 : nargout);
+
+  octave_value func = args(0);
+
   if (func.is_string ())
     {
-      retval = try_cellfun_internal_ops<boolNDArray,NDArray>(args, nargin);
+      retval = try_cellfun_internal_ops<boolNDArray,NDArray> (args, nargin);
 
       if (! retval.empty ())
         return retval;
 
       // See if we can convert the string into a function.
 
       std::string name = args(0).string_value ();
 
@@ -438,73 +439,68 @@ v = cellfun (@@det, a); # faster\n\
         }
       else
         {
           func = symbol_table::find_function (name);
 
           if (func.is_undefined ())
             error ("cellfun: invalid function NAME: %s", name.c_str ());
         }
-
-      if (! retval.empty ())
-        return retval;
     }
 
   if (func.is_function_handle () || func.is_inline_function ()
       || func.is_function ())
     {
 
       bool uniform_output = true;
       octave_value error_handler;
 
       get_mapper_fun_options (args, nargin, uniform_output, error_handler);
 
-      // The following is an optimisation because the symbol table can
-      // give a more specific function class, so this can result in
-      // fewer polymorphic function calls as the function gets called
-      // for each value of the array.
+      // The following is an optimization because the symbol table can give a
+      // more specific function class, so this can result in fewer polymorphic
+      // function calls as the function gets called for each value of the array.
       {
         if (func.is_function_handle ())
           {
             octave_fcn_handle* f = func.fcn_handle_value ();
 
             // Overloaded function handles need to check the type of the
-            // arguments for each element of the array, so they cannot
-            // be optimised this way.
+            // arguments for each element of the array, so they cannot be
+            // optimized this way.
             if (f -> is_overloaded ())
               goto nevermind;
           }
 
         std::string name = func.function_value () -> name ();
         octave_value f = symbol_table::find_function (name);
 
         if (f.is_defined ())
           {
-            //Except for these two which are special cases...
+            // Except for these two which are special cases...
             if (name != "size" && name != "class")
               {
-                //Try first the optimised code path for built-in functions
+                // Try first the optimized code path for built-in functions
                 octave_value_list tmp_args = args;
                 tmp_args(0) = name;
 
                 if (uniform_output)
                   retval =
                     try_cellfun_internal_ops<boolNDArray, NDArray> (tmp_args,
                                                                     nargin);
                 else
                   retval =
                     try_cellfun_internal_ops<Cell, Cell> (tmp_args, nargin);
 
                 if (! retval.empty ())
                   return retval;
               }
 
-            //Okay, we tried, doesn't work, let's do the best we can
-            //instead and avoid polymorphic calls for each element of
-            //the array.
+            // Okay, we tried, doesn't work, let's do the best we can instead
+            // and avoid polymorphic calls for each element of the array.
             func = f;
           }
       }
 
     nevermind:
 
       // Extract cell arguments.
 
@@ -515,18 +511,17 @@ v = cellfun (@@det, a); # faster\n\
 
       // This is to prevent copy-on-write.
       const Cell *cinputs = inputs;
 
       octave_idx_type k = 1;
 
       dim_vector fdims (1, 1);
 
-      // Collect arguments.  Pre-fill scalar elements of inputlist
-      // array.
+      // Collect arguments.  Pre-fill scalar elements of inputlist array.
 
       for (int j = 0; j < nargin; j++)
         {
           if (! args(j+1).is_cell ())
             error ("cellfun: arguments must be cells");
 
           inputs[j] = args(j+1).cell_value ();
           mask[j] = inputs[j].numel () != 1;
@@ -592,41 +587,39 @@ v = cellfun (@@det, a); # faster\n\
                   if (count == 0)
                     {
                       for (int j = 0; j < num_to_copy; j++)
                         {
                           if (tmp(j).is_defined ())
                             {
                               octave_value val = tmp(j);
 
-                              if (val.numel () == 1)
-                                retv[j] = val.resize (fdims);
-                              else
+                              if (val.numel () != 1)
                                 error ("cellfun: all values must be scalars when UniformOutput = true");
+
+                              retv[j] = val.resize (fdims);
                             }
                         }
                     }
                   else
                     {
                       for (int j = 0; j < num_to_copy; j++)
                         {
                           if (tmp(j).is_defined ())
                             {
                               octave_value val = tmp(j);
 
                               if (! retv[j].fast_elem_insert (count, val))
                                 {
-                                  if (val.numel () == 1)
-                                    {
-                                      idx_list.front ()(0) = count + 1.0;
-                                      retv[j].assign (octave_value::op_asn_eq,
-                                                      idx_type, idx_list, val);
-                                    }
-                                  else
+                                  if (val.numel () != 1)
                                     error ("cellfun: all values must be scalars when UniformOutput = true");
+
+                                  idx_list.front ()(0) = count + 1.0;
+                                  retv[j].assign (octave_value::op_asn_eq,
+                                                  idx_type, idx_list, val);
                                 }
                             }
                         }
                     }
                 }
             }
 
           retval.resize (nargout1);
@@ -1121,30 +1114,29 @@ arrayfun (@@str2num, [1234],\n\
      [1,1] = MyString\n\
    @}\n\
 @end group\n\
 @end example\n\
 \n\
 @seealso{spfun, cellfun, structfun}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
   int nargin = args.length ();
-  int nargout1 = (nargout < 1 ? 1 : nargout);
 
   if (nargin < 2)
     print_usage ();
 
+  octave_value_list retval;
+  int nargout1 = (nargout < 1 ? 1 : nargout);
+  bool symbol_table_lookup = false;
   octave_value func = args(0);
-  bool symbol_table_lookup = false;
 
   if (func.is_string ())
     {
       // See if we can convert the string into a function.
-
       std::string name = args(0).string_value ();
 
       if (! valid_identifier (name))
         {
           std::string fcn_name = unique_symbol_name ("__arrayfun_fcn__");
           std::string fname = "function y = " + fcn_name + "(x) y = ";
 
           octave_function *ptr_func
@@ -1165,31 +1157,29 @@ arrayfun (@@str2num, [1234],\n\
 
           symbol_table_lookup = true;
         }
     }
 
   if (func.is_function_handle () || func.is_inline_function ()
       || func.is_function ())
     {
-      // The following is an optimisation because the symbol table can
-      // give a more specific function class, so this can result in
-      // fewer polymorphic function calls as the function gets called
-      // for each value of the array.
+      // The following is an optimization because the symbol table can give a
+      // more specific function class, so this can result in fewer polymorphic
+      // function calls as the function gets called for each value of the array.
 
       if (! symbol_table_lookup)
         {
           if (func.is_function_handle ())
             {
               octave_fcn_handle* f = func.fcn_handle_value ();
 
-              // Overloaded function handles need to check the type of
-              // the arguments for each element of the array, so they
-              // cannot be optimised this way.
-
+              // Overloaded function handles need to check the type of the
+              // arguments for each element of the array, so they cannot be
+              // optimized this way.
               if (f -> is_overloaded ())
                 goto nevermind;
             }
           octave_value f
             = symbol_table::find_function (func.function_value () -> name ());
 
           if (f.is_defined ())
             func = f;
@@ -1206,18 +1196,17 @@ arrayfun (@@str2num, [1234],\n\
 
       OCTAVE_LOCAL_BUFFER (octave_value, inputs, nargin);
       OCTAVE_LOCAL_BUFFER (bool, mask, nargin);
 
       octave_idx_type k = 1;
 
       dim_vector fdims (1, 1);
 
-      // Collect arguments.  Pre-fill scalar elements of inputlist
-      // array.
+      // Collect arguments.  Pre-fill scalar elements of inputlist array.
 
       for (int j = 0; j < nargin; j++)
         {
           inputs[j] = args(j+1);
           mask[j] = inputs[j].numel () != 1;
 
           if (! mask[j])
             inputlist(j) = inputs[j];
@@ -1228,27 +1217,23 @@ arrayfun (@@str2num, [1234],\n\
           if (mask[j])
             {
               fdims = inputs[j].dims ();
               k = inputs[j].numel ();
 
               for (int i = j+1; i < nargin; i++)
                 {
                   if (mask[i] && inputs[i].dims () != fdims)
-                    {
-                      error_with_id ("Octave:invalid-input-arg",
-                                     "arrayfun: dimensions mismatch");
-                      return retval;
-                    }
+                    error_with_id ("Octave:invalid-input-arg",
+                                   "arrayfun: dimensions mismatch");
                 }
               break;
             }
         }
 
-
       unwind_protect frame;
       frame.protect_var (buffer_error_messages);
 
       if (error_handler.is_defined ())
         buffer_error_messages++;
 
       // Apply functions.
 
@@ -1270,21 +1255,18 @@ arrayfun (@@str2num, [1234],\n\
                     inputlist.xelem (j) = inputs[j].do_index_op (idx_list);
                 }
 
               const octave_value_list tmp
                 = get_output_list (count, nargout, inputlist, func,
                                    error_handler);
 
               if (nargout > 0 && tmp.length () < nargout)
-                {
-                  error_with_id ("Octave:invalid-fun-call",
-                                 "arrayfun: function returned fewer than nargout values");
-                  return retval;
-                }
+                error_with_id ("Octave:invalid-fun-call",
+                               "arrayfun: function returned fewer than nargout values");
 
               if  (nargout > 0
                    || (nargout == 0
                        && tmp.length () > 0 && tmp(0).is_defined ()))
                 {
                   int num_to_copy = tmp.length ();
 
                   if (num_to_copy > nargout1)
@@ -1296,21 +1278,18 @@ arrayfun (@@str2num, [1234],\n\
                         {
                           if (tmp(j).is_defined ())
                             {
                               octave_value val = tmp(j);
 
                               if (val.numel () == 1)
                                 retv[j] = val.resize (fdims);
                               else
-                                {
-                                  error_with_id ("Octave:invalid-fun-call",
-                                                 "arrayfun: all values must be scalars when UniformOutput = true");
-                                  break;
-                                }
+                                error_with_id ("Octave:invalid-fun-call",
+                                               "arrayfun: all values must be scalars when UniformOutput = true");
                             }
                         }
                     }
                   else
                     {
                       for (int j = 0; j < num_to_copy; j++)
                         {
                           if (tmp(j).is_defined ())
@@ -1321,21 +1300,18 @@ arrayfun (@@str2num, [1234],\n\
                                 {
                                   if (val.numel () == 1)
                                     {
                                       idx_list.front ()(0) = count + 1.0;
                                       retv[j].assign (octave_value::op_asn_eq,
                                                       idx_type, idx_list, val);
                                     }
                                   else
-                                    {
-                                      error_with_id ("Octave:invalid-fun-call",
-                                                     "arrayfun: all values must be scalars when UniformOutput = true");
-                                      break;
-                                    }
+                                    error_with_id ("Octave:invalid-fun-call",
+                                                   "arrayfun: all values must be scalars when UniformOutput = true");
                                 }
                             }
                         }
                     }
                 }
             }
 
           retval.resize (nargout1);
@@ -1371,21 +1347,18 @@ arrayfun (@@str2num, [1234],\n\
                     inputlist.xelem (j) = inputs[j].do_index_op (idx_list);
                 }
 
               const octave_value_list tmp
                 = get_output_list (count, nargout, inputlist, func,
                                    error_handler);
 
               if (nargout > 0 && tmp.length () < nargout)
-                {
-                  error_with_id ("Octave:invalid-fun-call",
-                                 "arrayfun: function returned fewer than nargout values");
-                  return retval;
-                }
+                error_with_id ("Octave:invalid-fun-call",
+                               "arrayfun: function returned fewer than nargout values");
 
               if  (nargout > 0
                    || (nargout == 0
                        && tmp.length () > 0 && tmp(0).is_defined ()))
                 {
                   int num_to_copy = tmp.length ();
 
                   if (num_to_copy > nargout1)
@@ -1802,27 +1775,26 @@ num2cell ([1,2;3,4],1)\n\
            4\n\
       @}\n\
 @end group\n\
 @end example\n\
 \n\
 @seealso{mat2cell}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
+  octave_value retval;
+
   octave_value array = args(0);
 
   Array<int> dimv;
-
   if (nargin > 1)
     dimv = args(1).int_vector_value (true);
 
   if (array.is_bool_type ())
     retval = do_num2cell (array.bool_array_value (), dimv);
   else if (array.is_char_matrix ())
     retval = do_num2cell (array.char_array_value (), dimv);
   else if (array.is_numeric_type ())
@@ -2133,23 +2105,23 @@ mat2cell (reshape (1:16,4,4), [3,1], [3,
      15\n\
 \n\
    [2,2] = 16\n\
 @}\n\
 @end example\n\
 @seealso{num2cell, cell2mat}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin < 2)
     print_usage ();
 
+  octave_value retval;
+
   // Prepare indices.
   OCTAVE_LOCAL_BUFFER (Array<octave_idx_type>, d, nargin-1);
 
   for (int i = 1; i < nargin; i++)
     d[i-1] = args(i).octave_idx_type_vector_value (true);
 
   octave_value a = args(0);
   bool sparse = a.is_sparse_type ();
@@ -2407,17 +2379,18 @@ endfor\n\
 @end example\n\
 @seealso{cellslices, cellfun}\n\
 @end deftypefn")
 {
   if (args.length () == 0)
     print_usage ();
 
   const Cell x = args(0).xcell_value ("cellindexmat: X must be a cell");
-  NoAlias<Cell> y(x.dims ());
+
+  NoAlias<Cell> y (x.dims ());
   octave_idx_type nel = x.numel ();
   octave_value_list idx = args.slice (1, args.length () - 1);
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       octave_quit ();
 
       octave_value tmp = x(i);
diff --git a/libinterp/corefcn/colloc.cc b/libinterp/corefcn/colloc.cc
--- a/libinterp/corefcn/colloc.cc
+++ b/libinterp/corefcn/colloc.cc
@@ -38,64 +38,55 @@ DEFUN (colloc, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {[@var{r}, @var{amat}, @var{bmat}, @var{q}] =} colloc (@var{n}, \"left\", \"right\")\n\
 Compute derivative and integral weight matrices for orthogonal collocation.\n\
 \n\
 Reference: @nospell{J. Villadsen}, @nospell{M. L. Michelsen},\n\
 @cite{Solution of Differential Equation Models by Polynomial Approximation}.\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
 
   if (! args(0).is_scalar_type ())
     error ("colloc: N must be a scalar");
 
   double tmp = args(0).double_value ();
-
   if (xisnan (tmp))
     error ("colloc: N cannot be NaN");
 
   octave_idx_type ncol = NINTbig (tmp);
   if (ncol < 0)
     error ("colloc: N must be positive");
 
   octave_idx_type ntot = ncol;
   octave_idx_type left = 0;
   octave_idx_type right = 0;
 
   for (int i = 1; i < nargin; i++)
     {
       std::string s = args(i).xstring_value ("colloc: optional arguments must be strings");
 
-      if ((s.length () == 1 && (s[0] == 'R' || s[0] == 'r'))
-          || s == "right")
-        {
-          right = 1;
-        }
+      if ((s.length () == 1 && (s[0] == 'R' || s[0] == 'r')) || s == "right")
+        right = 1;
       else if ((s.length () == 1 && (s[0] == 'L' || s[0] == 'l'))
                || s == "left")
-        {
-          left = 1;
-        }
+        left = 1;
       else
         error ("colloc: string argument must be \"left\" or \"right\"");
     }
 
   ntot += left + right;
   if (ntot < 1)
     error ("colloc: the total number of roots must be positive");
 
   CollocWt wts (ncol, left, right);
 
   ColumnVector r = wts.roots ();
   Matrix A = wts.first ();
   Matrix B = wts.second ();
   ColumnVector q = wts.quad_weights ();
 
-  retval = ovl (r, A, B, q);
+  return ovl (r, A, B, q);
+}
 
-  return retval;
-}
diff --git a/libinterp/corefcn/conv2.cc b/libinterp/corefcn/conv2.cc
--- a/libinterp/corefcn/conv2.cc
+++ b/libinterp/corefcn/conv2.cc
@@ -59,26 +59,25 @@ The size of the result is @code{max (siz
 @end table\n\
 \n\
 When the third argument is a matrix, return the convolution of the matrix\n\
 @var{m} by the vector @var{v1} in the column direction and by the vector\n\
 @var{v2} in the row direction.\n\
 @seealso{conv, convn}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  octave_value tmp;
   int nargin = args.length ();
+
+  if (nargin < 2 || nargin > 4)
+    print_usage ();
+
   std::string shape = "full";   // default
   bool separable = false;
   convn_type ct = convn_full;
 
-  if (nargin < 2 || nargin > 4)
-    print_usage ();
-
   if (nargin == 3)
     {
       if (args(2).is_string ())
         shape = args(2).string_value ();
       else
         separable = true;
     }
   else if (nargin == 4)
@@ -94,20 +93,21 @@ When the third argument is a matrix, ret
     ct = convn_full;
   else if (shape == "same")
     ct = convn_same;
   else if (shape == "valid")
     ct = convn_valid;
   else
     error ("conv2: SHAPE type not valid");
 
+  octave_value retval;
+
   if (separable)
     {
       // If user requests separable, check first two params are vectors
-
       if (! (1 == args(0).rows () || 1 == args(0).columns ())
           || ! (1 == args(1).rows () || 1 == args(1).columns ()))
         error ("conv2: arguments must be vectors for separable option");
 
       if (args(0).is_single_type () || args(1).is_single_type ()
           || args(2).is_single_type ())
         {
           if (args(0).is_complex_type () || args(1).is_complex_type ()
@@ -300,37 +300,38 @@ The central part of the convolution begi
 @item @var{shape} = @qcode{\"valid\"}\n\
 Return only the parts which do not include zero-padded edges.\n\
 The size of the result is @code{max (size (A) - size (B) + 1, 0)}.\n\
 @end table\n\
 \n\
 @seealso{conv2, conv}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  octave_value tmp;
   int nargin = args.length ();
-  std::string shape = "full";   // default
-  convn_type ct = convn_full;
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
 
+  std::string shape = "full";   // default
+  convn_type ct = convn_full;
+
   if (nargin == 3)
     shape = args(2).xstring_value ("convn: SHAPE must be a string");
 
   if (shape == "full")
     ct = convn_full;
   else if (shape == "same")
     ct = convn_same;
   else if (shape == "valid")
     ct = convn_valid;
   else
     error ("convn: SHAPE type not valid");
 
+  octave_value retval;
+
   if (args(0).is_single_type () || args(1).is_single_type ())
     {
       if (args(0).is_complex_type () || args(1).is_complex_type ())
         {
           FloatComplexNDArray a (args(0).float_complex_array_value ());
           if (args(1).is_real_type ())
             {
               FloatNDArray b (args(1).float_array_value ());
diff --git a/libinterp/corefcn/daspk.cc b/libinterp/corefcn/daspk.cc
--- a/libinterp/corefcn/daspk.cc
+++ b/libinterp/corefcn/daspk.cc
@@ -272,34 +272,34 @@ greater than zero (consistent with the F
 If the computation is not successful, the value of @var{istate} will be\n\
 less than zero and @var{msg} will contain additional information.\n\
 \n\
 You can use the function @code{daspk_options} to set optional\n\
 parameters for @code{daspk}.\n\
 @seealso{dassl}\n\
 @end deftypefn")
 {
-  octave_value_list retval (4);
+  int nargin = args.length ();
+
+  if (nargin < 4 || nargin > 5)
+    print_usage ();
 
   warned_fcn_imaginary = false;
   warned_jac_imaginary = false;
 
+  octave_value_list retval (4);
+
   unwind_protect frame;
 
   frame.protect_var (call_depth);
   call_depth++;
 
   if (call_depth > 1)
     DASPK_ABORT1 ("invalid recursive call");
 
-  int nargin = args.length ();
-
-  if (nargin < 4 || nargin > 5)
-    print_usage ();
-
   std::string fcn_name, fname, jac_name, jname;
   daspk_fcn = 0;
   daspk_jac = 0;
 
   octave_value f_arg = args(0);
 
   if (f_arg.is_cell ())
     {
@@ -328,30 +328,30 @@ parameters for @code{daspk}.\n\
                 {
                   jac_name = unique_symbol_name ("__daspk_jac__");
                   jname = "function jac = ";
                   jname.append (jac_name);
                   jname.append (" (x, xdot, t, cj) jac = ");
                   daspk_jac = extract_function (c(1), "daspk", jac_name,
                                                 jname, "; endfunction");
 
-                  if (!daspk_jac)
+                  if (! daspk_jac)
                     {
                       if (fcn_name.length ())
                         clear_function (fcn_name);
                       daspk_fcn = 0;
                     }
                 }
             }
         }
       else
         DASPK_ABORT1 ("incorrect number of elements in cell array");
     }
 
-  if (!daspk_fcn && ! f_arg.is_cell ())
+  if (! daspk_fcn && ! f_arg.is_cell ())
     {
       if (f_arg.is_function_handle () || f_arg.is_inline_function ())
         daspk_fcn = f_arg.function_value ();
       else
         {
           switch (f_arg.rows ())
             {
             case 1:
@@ -383,17 +383,17 @@ parameters for @code{daspk}.\n\
                     jac_name = unique_symbol_name ("__daspk_jac__");
                     jname = "function jac = ";
                     jname.append (jac_name);
                     jname.append (" (x, xdot, t, cj) jac = ");
                     daspk_jac = extract_function (tmp(1), "daspk",
                                                   jac_name, jname,
                                                   "; endfunction");
 
-                    if (!daspk_jac)
+                    if (! daspk_jac)
                       {
                         if (fcn_name.length ())
                           clear_function (fcn_name);
                         daspk_fcn = 0;
                       }
                   }
               }
             }
diff --git a/libinterp/corefcn/dasrt.cc b/libinterp/corefcn/dasrt.cc
--- a/libinterp/corefcn/dasrt.cc
+++ b/libinterp/corefcn/dasrt.cc
@@ -351,35 +351,35 @@ greater than zero (consistent with the F
 If the computation is not successful, the value of @var{istate} will be\n\
 less than zero and @var{msg} will contain additional information.\n\
 \n\
 You can use the function @code{dasrt_options} to set optional\n\
 parameters for @code{dasrt}.\n\
 @seealso{dasrt_options, daspk, dasrt, lsode}\n\
 @end deftypefn")
 {
-  octave_value_list retval (5);
+  int nargin = args.length ();
+
+  if (nargin < 4 || nargin > 6)
+    print_usage ();
 
   warned_fcn_imaginary = false;
   warned_jac_imaginary = false;
   warned_cf_imaginary = false;
 
+  octave_value_list retval (5);
+
   unwind_protect frame;
 
   frame.protect_var (call_depth);
   call_depth++;
 
   if (call_depth > 1)
     DASRT_ABORT1 ("invalid recursive call");
 
-  int nargin = args.length ();
-
-  if (nargin < 4 || nargin > 6)
-    print_usage ();
-
   int argp = 0;
   std::string fcn_name, fname, jac_name, jname;
   dasrt_f = 0;
   dasrt_j = 0;
   dasrt_cf = 0;
 
   // Check all the arguments.  Are they the right animals?
 
@@ -414,30 +414,30 @@ parameters for @code{dasrt}.\n\
                 {
                   jac_name = unique_symbol_name ("__dasrt_jac__");
                   jname = "function jac = ";
                   jname.append (jac_name);
                   jname.append (" (x, xdot, t, cj) jac = ");
                   dasrt_j = extract_function (c(1), "dasrt", jac_name, jname,
                                               "; endfunction");
 
-                  if (!dasrt_j)
+                  if (! dasrt_j)
                     {
                       if (fcn_name.length ())
                         clear_function (fcn_name);
                       dasrt_f = 0;
                     }
                 }
             }
         }
       else
         DASRT_ABORT1 ("incorrect number of elements in cell array");
     }
 
-  if (!dasrt_f && ! f_arg.is_cell ())
+  if (! dasrt_f && ! f_arg.is_cell ())
     {
       if (f_arg.is_function_handle () || f_arg.is_inline_function ())
         dasrt_f = f_arg.function_value ();
       else
         {
           switch (f_arg.rows ())
             {
             case 1:
diff --git a/libinterp/corefcn/dassl.cc b/libinterp/corefcn/dassl.cc
--- a/libinterp/corefcn/dassl.cc
+++ b/libinterp/corefcn/dassl.cc
@@ -273,34 +273,34 @@ greater than zero (consistent with the F
 If the computation is not successful, the value of @var{istate} will be\n\
 less than zero and @var{msg} will contain additional information.\n\
 \n\
 You can use the function @code{dassl_options} to set optional\n\
 parameters for @code{dassl}.\n\
 @seealso{daspk, dasrt, lsode}\n\
 @end deftypefn")
 {
-  octave_value_list retval (4);
+  int nargin = args.length ();
+
+  if (nargin < 4 || nargin > 5)
+    print_usage ();
 
   warned_fcn_imaginary = false;
   warned_jac_imaginary = false;
 
+  octave_value_list retval (4);
+
   unwind_protect frame;
 
   frame.protect_var (call_depth);
   call_depth++;
 
   if (call_depth > 1)
     DASSL_ABORT1 ("invalid recursive call");
 
-  int nargin = args.length ();
-
-  if (nargin < 4 || nargin > 5)
-    print_usage ();
-
   std::string fcn_name, fname, jac_name, jname;
   dassl_fcn = 0;
   dassl_jac = 0;
 
   octave_value f_arg = args(0);
 
   if (f_arg.is_cell ())
     {
@@ -329,30 +329,30 @@ parameters for @code{dassl}.\n\
                 {
                   jac_name = unique_symbol_name ("__dassl_jac__");
                   jname = "function jac = ";
                   jname.append (jac_name);
                   jname.append (" (x, xdot, t, cj) jac = ");
                   dassl_jac = extract_function (c(1), "dassl", jac_name,
                                                 jname, "; endfunction");
 
-                  if (!dassl_jac)
+                  if (! dassl_jac)
                     {
                       if (fcn_name.length ())
                         clear_function (fcn_name);
                       dassl_fcn = 0;
                     }
                 }
             }
         }
       else
         DASSL_ABORT1 ("incorrect number of elements in cell array");
     }
 
-  if (!dassl_fcn && ! f_arg.is_cell ())
+  if (! dassl_fcn && ! f_arg.is_cell ())
     {
       if (f_arg.is_function_handle () || f_arg.is_inline_function ())
         dassl_fcn = f_arg.function_value ();
       else
         {
           switch (f_arg.rows ())
             {
             case 1:
@@ -384,17 +384,17 @@ parameters for @code{dassl}.\n\
                     jac_name = unique_symbol_name ("__dassl_jac__");
                     jname = "function jac = ";
                     jname.append (jac_name);
                     jname.append (" (x, xdot, t, cj) jac = ");
                     dassl_jac = extract_function (tmp(1), "dassl",
                                                   jac_name, jname,
                                                   "; endfunction");
 
-                    if (!dassl_jac)
+                    if (! dassl_jac)
                       {
                         if (fcn_name.length ())
                           clear_function (fcn_name);
                         dassl_fcn = 0;
                       }
                   }
               }
             }
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -85,31 +85,28 @@ along with Octave; see the file COPYING.
 static void
 index_error (const char *fmt, const std::string& idx, const std::string& msg)
 {
   error (fmt, idx.c_str (), msg.c_str ());
 }
 
 #define ANY_ALL(FCN) \
  \
-  octave_value retval; \
- \
   int nargin = args.length (); \
  \
   if (nargin < 1 || nargin > 2) \
     print_usage (); \
  \
   int dim = (nargin == 1 ? -1 : args(1).int_value (#FCN ": DIM must be an integer") - 1); \
  \
   if (dim >= -1) \
-    retval = args(0).FCN (dim); \
+    return octave_value (args(0).FCN (dim)); \
   else \
     error (#FCN ": invalid dimension argument = %d", dim + 1); \
  \
-  return retval
 
 DEFUN (all, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} all (@var{x})\n\
 @deftypefnx {} {} all (@var{x}, @var{dim})\n\
 For a vector argument, return true (logical 1) if all elements of the vector\n\
 are nonzero.\n\
 \n\
@@ -214,21 +211,21 @@ DEFUN (atan2, args, ,
 @deftypefn {} {} atan2 (@var{y}, @var{x})\n\
 Compute atan (@var{y} / @var{x}) for corresponding elements of @var{y}\n\
 and @var{x}.\n\
 \n\
 @var{y} and @var{x} must match in size and orientation.\n\
 @seealso{tan, tand, tanh, atanh}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 2)
     print_usage ();
 
+  octave_value retval;
+
   if (! args(0).is_numeric_type ())
     gripe_wrong_type_arg ("atan2", args(0));
   else if (! args(1).is_numeric_type ())
     gripe_wrong_type_arg ("atan2", args(1));
   else if (args(0).is_complex_type () || args(1).is_complex_type ())
     error ("atan2: not defined for complex numbers");
   else if (args(0).is_single_type () || args(1).is_single_type ())
     {
@@ -489,21 +486,21 @@ and @var{e} is an integer.  If\n\
 $x = 0$, $f = e = 0$.\n\
 @end tex\n\
 @ifnottex\n\
 @w{@code{x = 0}}, @w{@code{f = e = 0}}.\n\
 @end ifnottex\n\
 @seealso{pow2, log, log10, exp}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 1)
     print_usage ();
 
+  octave_value_list retval;
+
   if (nargout < 2)
     retval = ovl (args(0).log2 ());
   else if (args(0).is_single_type ())
     {
       if (args(0).is_real_type ())
         {
           FloatNDArray f;
           FloatNDArray x = args(0).float_array_value ();
@@ -597,21 +594,21 @@ rem (@var{x}, @var{y})        returns a 
 \n\
 For the opposite conventions see the @code{mod} function.  In general,\n\
 @code{rem} is best when computing the remainder after division of two\n\
 @emph{positive} numbers.  For negative numbers, or when the values are\n\
 periodic, @code{mod} is a better choice.\n\
 @seealso{mod}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 2)
     print_usage ();
 
+  octave_value retval;
+
   if (! args(0).is_numeric_type ())
     gripe_wrong_type_arg ("rem", args(0));
   else if (! args(1).is_numeric_type ())
     gripe_wrong_type_arg ("rem", args(1));
   else if (args(0).is_complex_type () || args(1).is_complex_type ())
     error ("rem: not defined for complex numbers");
   else if (args(0).is_integer_type () || args(1).is_integer_type ())
     {
@@ -777,21 +774,21 @@ mod (@var{x}, @var{y})      returns a va
 @end example\n\
 \n\
 For the opposite conventions see the @code{rem} function.  In general,\n\
 @code{mod} is a better choice than @code{rem} when any of the inputs are\n\
 negative numbers or when the values are periodic.\n\
 @seealso{rem}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 2)
     print_usage ();
 
+  octave_value retval;
+
   if (! args(0).is_numeric_type ())
     gripe_wrong_type_arg ("mod", args(0));
   else if (! args(1).is_numeric_type ())
     gripe_wrong_type_arg ("mod", args(1));
   else if (args(0).is_complex_type () || args(1).is_complex_type ())
     error ("mod: not defined for complex numbers");
   else if (args(0).is_integer_type () || args(1).is_integer_type ())
     {
@@ -924,18 +921,16 @@ negative numbers or when the values are 
     { \
       TYPE ## NDArray tmp = arg. TYPE ##_array_value (); \
  \
       retval = tmp.FCN (DIM); \
     }
 
 #define NATIVE_REDUCTION(FCN, BOOL_FCN) \
  \
-  octave_value retval; \
- \
   int nargin = args.length (); \
  \
   bool isnative = false; \
   bool isdouble = false; \
  \
   if (nargin > 1 && args(nargin - 1).is_string ()) \
     { \
       std::string str = args(nargin - 1).string_value (); \
@@ -947,206 +942,204 @@ negative numbers or when the values are 
       else \
         error ("sum: unrecognized string argument"); \
       nargin --; \
     } \
  \
   if (nargin < 1 || nargin > 2) \
     print_usage (); \
  \
+  octave_value retval; \
+ \
   octave_value arg = args(0); \
  \
   int dim = (nargin == 1 ? -1 : args(1).int_value (true) - 1); \
  \
-  if (dim >= -1) \
-    { \
-      if (arg.is_sparse_type ()) \
-        { \
-          if (arg.is_real_type ()) \
-            { \
-              SparseMatrix tmp = arg.sparse_matrix_value (); \
+  if (dim < -1) \
+    error (#FCN ": invalid dimension argument = %d", dim + 1); \
  \
-              retval = tmp.FCN (dim); \
-            } \
-          else \
-            { \
-              SparseComplexMatrix tmp \
-                = arg.sparse_complex_matrix_value (); \
- \
-              retval = tmp.FCN (dim); \
-            } \
+  if (arg.is_sparse_type ()) \
+    { \
+      if (arg.is_real_type ()) \
+        { \
+          SparseMatrix tmp = arg.sparse_matrix_value (); \
+\
+          retval = tmp.FCN (dim); \
         } \
       else \
         { \
-          if (isnative) \
+          SparseComplexMatrix tmp \
+            = arg.sparse_complex_matrix_value (); \
+\
+          retval = tmp.FCN (dim); \
+        } \
+    } \
+  else \
+    { \
+      if (isnative) \
+        { \
+          if NATIVE_REDUCTION_1 (FCN, uint8, dim) \
+          else if NATIVE_REDUCTION_1 (FCN, uint16, dim) \
+          else if NATIVE_REDUCTION_1 (FCN, uint32, dim) \
+          else if NATIVE_REDUCTION_1 (FCN, uint64, dim) \
+          else if NATIVE_REDUCTION_1 (FCN, int8, dim) \
+          else if NATIVE_REDUCTION_1 (FCN, int16, dim) \
+          else if NATIVE_REDUCTION_1 (FCN, int32, dim) \
+          else if NATIVE_REDUCTION_1 (FCN, int64, dim) \
+          else if (arg.is_bool_type ()) \
             { \
-              if NATIVE_REDUCTION_1 (FCN, uint8, dim) \
-              else if NATIVE_REDUCTION_1 (FCN, uint16, dim) \
-              else if NATIVE_REDUCTION_1 (FCN, uint32, dim) \
-              else if NATIVE_REDUCTION_1 (FCN, uint64, dim) \
-              else if NATIVE_REDUCTION_1 (FCN, int8, dim) \
-              else if NATIVE_REDUCTION_1 (FCN, int16, dim) \
-              else if NATIVE_REDUCTION_1 (FCN, int32, dim) \
-              else if NATIVE_REDUCTION_1 (FCN, int64, dim) \
-              else if (arg.is_bool_type ()) \
-                { \
-                  boolNDArray tmp = arg.bool_array_value (); \
- \
-                  retval = boolNDArray (tmp.BOOL_FCN (dim)); \
-                } \
-              else if (arg.is_char_matrix ()) \
+              boolNDArray tmp = arg.bool_array_value (); \
+\
+              retval = boolNDArray (tmp.BOOL_FCN (dim)); \
+            } \
+          else if (arg.is_char_matrix ()) \
+            { \
+              error (#FCN, ": invalid char type"); \
+            } \
+          else if (!isdouble && arg.is_single_type ()) \
+            { \
+              if (arg.is_complex_type ()) \
                 { \
-                  error (#FCN, ": invalid char type"); \
-                } \
-              else if (!isdouble && arg.is_single_type ()) \
-                { \
-                  if (arg.is_complex_type ()) \
-                    { \
-                      FloatComplexNDArray tmp = \
-                        arg.float_complex_array_value (); \
- \
-                      retval = tmp.FCN (dim); \
-                    } \
-                  else if (arg.is_real_type ()) \
-                    { \
-                      FloatNDArray tmp = arg.float_array_value (); \
- \
-                      retval = tmp.FCN (dim); \
-                    } \
-                } \
-              else if (arg.is_complex_type ()) \
-                { \
-                  ComplexNDArray tmp = arg.complex_array_value (); \
- \
+                  FloatComplexNDArray tmp = \
+                    arg.float_complex_array_value (); \
+\
                   retval = tmp.FCN (dim); \
                 } \
               else if (arg.is_real_type ()) \
                 { \
-                  NDArray tmp = arg.array_value (); \
- \
+                  FloatNDArray tmp = arg.float_array_value (); \
+\
                   retval = tmp.FCN (dim); \
                 } \
-              else \
-                { \
-                  gripe_wrong_type_arg (#FCN, arg); \
-                  return retval; \
-                } \
             } \
-          else if (arg.is_bool_type ()) \
-            { \
-              boolNDArray tmp = arg.bool_array_value (); \
- \
-              retval = tmp.FCN (dim); \
-            } \
-          else if (!isdouble && arg.is_single_type ()) \
+          else if (arg.is_complex_type ()) \
             { \
-              if (arg.is_real_type ()) \
-                { \
-                  FloatNDArray tmp = arg.float_array_value (); \
- \
-                  retval = tmp.FCN (dim); \
-                } \
-              else if (arg.is_complex_type ()) \
-                { \
-                  FloatComplexNDArray tmp = \
-                    arg.float_complex_array_value (); \
- \
-                  retval = tmp.FCN (dim); \
-                } \
+              ComplexNDArray tmp = arg.complex_array_value (); \
+\
+              retval = tmp.FCN (dim); \
             } \
           else if (arg.is_real_type ()) \
             { \
               NDArray tmp = arg.array_value (); \
- \
-              retval = tmp.FCN (dim); \
-            } \
-          else if (arg.is_complex_type ()) \
-            { \
-              ComplexNDArray tmp = arg.complex_array_value (); \
- \
+\
               retval = tmp.FCN (dim); \
             } \
           else \
             { \
               gripe_wrong_type_arg (#FCN, arg); \
               return retval; \
             } \
         } \
-      else \
-        error (#FCN ": invalid dimension argument = %d", dim + 1); \
-    } \
- \
-  return retval
-
-#define DATA_REDUCTION(FCN) \
- \
-  octave_value retval; \
- \
-  int nargin = args.length (); \
- \
-  if (nargin < 1 || nargin > 2) \
-    print_usage (); \
- \
-  octave_value arg = args(0); \
- \
-  int dim = (nargin == 1 ? -1 : args(1).int_value (true) - 1); \
- \
-  if (dim >= -1) \
-    { \
-      if (arg.is_real_type ()) \
+      else if (arg.is_bool_type ()) \
         { \
-          if (arg.is_sparse_type ()) \
+          boolNDArray tmp = arg.bool_array_value (); \
+\
+          retval = tmp.FCN (dim); \
+        } \
+      else if (!isdouble && arg.is_single_type ()) \
+        { \
+          if (arg.is_real_type ()) \
             { \
-              SparseMatrix tmp = arg.sparse_matrix_value (); \
- \
+              FloatNDArray tmp = arg.float_array_value (); \
+\
               retval = tmp.FCN (dim); \
             } \
-          else if (arg.is_single_type ()) \
+          else if (arg.is_complex_type ()) \
             { \
-              FloatNDArray tmp = arg.float_array_value (); \
- \
-              retval = tmp.FCN (dim); \
-            } \
-          else \
-            { \
-              NDArray tmp = arg.array_value (); \
- \
+              FloatComplexNDArray tmp = \
+                arg.float_complex_array_value (); \
+\
               retval = tmp.FCN (dim); \
             } \
         } \
+      else if (arg.is_real_type ()) \
+        { \
+          NDArray tmp = arg.array_value (); \
+\
+          retval = tmp.FCN (dim); \
+        } \
       else if (arg.is_complex_type ()) \
         { \
-          if (arg.is_sparse_type ()) \
-            { \
-              SparseComplexMatrix tmp = arg.sparse_complex_matrix_value (); \
- \
-              retval = tmp.FCN (dim); \
-            } \
-          else if (arg.is_single_type ()) \
-            { \
-              FloatComplexNDArray tmp \
-                = arg.float_complex_array_value (); \
- \
-              retval = tmp.FCN (dim); \
-            } \
-          else \
-            { \
-              ComplexNDArray tmp = arg.complex_array_value (); \
- \
-              retval = tmp.FCN (dim); \
-            } \
+          ComplexNDArray tmp = arg.complex_array_value (); \
+\
+          retval = tmp.FCN (dim); \
         } \
       else \
         { \
           gripe_wrong_type_arg (#FCN, arg); \
           return retval; \
         } \
     } \
+ \
+  return retval
+
+#define DATA_REDUCTION(FCN) \
+ \
+  int nargin = args.length (); \
+ \
+  if (nargin < 1 || nargin > 2) \
+    print_usage (); \
+ \
+  octave_value retval; \
+ \
+  octave_value arg = args(0); \
+ \
+  int dim = (nargin == 1 ? -1 : args(1).int_value (true) - 1); \
+ \
+  if (dim < -1) \
+    error (#FCN ": invalid dimension argument = %d", dim + 1); \
+ \
+  if (arg.is_real_type ()) \
+    { \
+      if (arg.is_sparse_type ()) \
+        { \
+          SparseMatrix tmp = arg.sparse_matrix_value (); \
+\
+          retval = tmp.FCN (dim); \
+        } \
+      else if (arg.is_single_type ()) \
+        { \
+          FloatNDArray tmp = arg.float_array_value (); \
+\
+          retval = tmp.FCN (dim); \
+        } \
+      else \
+        { \
+          NDArray tmp = arg.array_value (); \
+\
+          retval = tmp.FCN (dim); \
+        } \
+    } \
+  else if (arg.is_complex_type ()) \
+    { \
+      if (arg.is_sparse_type ()) \
+        { \
+          SparseComplexMatrix tmp = arg.sparse_complex_matrix_value (); \
+\
+          retval = tmp.FCN (dim); \
+        } \
+      else if (arg.is_single_type ()) \
+        { \
+          FloatComplexNDArray tmp \
+            = arg.float_complex_array_value (); \
+\
+          retval = tmp.FCN (dim); \
+        } \
+      else \
+        { \
+          ComplexNDArray tmp = arg.complex_array_value (); \
+\
+          retval = tmp.FCN (dim); \
+        } \
+    } \
   else \
-    error (#FCN ": invalid dimension argument = %d", dim + 1); \
+    { \
+      gripe_wrong_type_arg (#FCN, arg); \
+      return retval; \
+    } \
  \
   return retval
 
 DEFUN (cumprod, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} cumprod (@var{x})\n\
 @deftypefnx {} {} cumprod (@var{x}, @var{dim})\n\
 Cumulative product of elements along dimension @var{dim}.\n\
@@ -1189,18 +1182,16 @@ Cumulative sum of elements along dimensi
 \n\
 If @var{dim} is omitted, it defaults to the first non-singleton dimension.\n\
 \n\
 See @code{sum} for an explanation of the optional parameters\n\
 @qcode{\"native\"}, @qcode{\"double\"}, and @qcode{\"extra\"}.\n\
 @seealso{sum, cumprod}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   bool isnative = false;
   bool isdouble = false;
 
   if (nargin > 1 && args(nargin - 1).is_string ())
     {
       std::string str = args(nargin - 1).string_value ();
@@ -1212,26 +1203,27 @@ See @code{sum} for an explanation of the
       else
         error ("cumsum: unrecognized string argument");
       nargin --;
     }
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
-  octave_value arg = args(0);
-
   int dim = -1;
   if (nargin == 2)
     {
       dim = args(1).int_value () - 1;
       if (dim < 0)
         error ("cumsum: invalid dimension argument = %d", dim + 1);
     }
 
+  octave_value retval;
+  octave_value arg = args(0);
+
   switch (arg.builtin_type ())
     {
     case btyp_double:
       if (arg.is_sparse_type ())
         retval = arg.sparse_matrix_value ().cumsum (dim);
       else
         retval = arg.array_value ().cumsum (dim);
       break;
@@ -1347,23 +1339,23 @@ diag ([1, 2, 3], 1)\n\
 The 3-input form returns a diagonal matrix with vector @var{v} on the main\n\
 diagonal and the resulting matrix being of size @var{m} rows x @var{n}\n\
 columns.\n\
 \n\
 Given a matrix argument, instead of a vector, @code{diag} extracts the\n\
 @var{k}-th diagonal of the matrix.\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
 
+  octave_value retval;
+
   if (nargin == 1)
     retval = args(0).diag ();
   else if (nargin == 2)
     {
       octave_idx_type k = args(1).xint_value ("diag: invalid argument K");
 
       retval = args(0).diag (k);
     }
@@ -1477,18 +1469,16 @@ prod ([true, true], \"native\")\n\
 @end group\n\
 @end example\n\
 \n\
 On the contrary, if @qcode{\"double\"} is given, the operation is performed\n\
 in double precision even for single precision inputs.\n\
 @seealso{cumprod, sum}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   bool isnative = false;
   bool isdouble = false;
 
   if (nargin > 1 && args(nargin - 1).is_string ())
     {
       std::string str = args(nargin - 1).string_value ();
@@ -1500,16 +1490,18 @@ in double precision even for single prec
       else
         error ("prod: unrecognized type argument '%s'", str.c_str ());
       nargin --;
     }
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
+  octave_value retval;
+
   octave_value arg = args(0);
 
   int dim = -1;
   if (nargin == 2)
     {
       dim = args(1).int_value () - 1;
       if (dim < 0)
         error ("prod: invalid dimension DIM = %d", dim + 1);
@@ -2550,19 +2542,17 @@ do_permute (const octave_value_list& arg
 {
   if (args.length () != 2 || args(1).length () < args(1).ndims ())
     print_usage ();
 
   Array<int> vec = args(1).int_vector_value ();
 
   // FIXME: maybe we should create an idx_vector object here
   //        and pass that to permute?
-
   int n = vec.numel ();
-
   for (int i = 0; i < n; i++)
     vec(i)--;
 
   return octave_value (args(0).permute (vec, inv));
 }
 
 DEFUN (permute, args, ,
        "-*- texinfo -*-\n\
@@ -2784,25 +2774,23 @@ returns the number of columns in the giv
         }
     }
   else if (nargin == 2 && nargout < 2)
     {
       octave_idx_type nd = args(1).xint_value ("size: DIM must be an integer");
 
       const dim_vector dv = args(0).dims ();
 
-      if (nd > 0)
-        {
-          if (nd <= dv.length ())
-            retval(0) = dv(nd-1);
-          else
-            retval(0) = 1;
-        }
+      if (nd < 1)
+        error ("size: requested dimension DIM (= %d) out of range", nd);
+
+      if (nd <= dv.length ())
+        retval(0) = dv(nd-1);
       else
-        error ("size: requested dimension DIM (= %d) out of range", nd);
+        retval(0) = 1;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (size_equal, args, ,
@@ -2955,18 +2943,16 @@ double precision even for single precisi
 \n\
 For double precision inputs, the @qcode{\"extra\"} option will use a more\n\
 accurate algorithm than straightforward summation.  For single precision\n\
 inputs, @qcode{\"extra\"} is the same as @qcode{\"double\"}.  Otherwise,\n\
 @qcode{\"extra\"} has no effect.\n\
 @seealso{cumsum, sumsq, prod}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   bool isnative = false;
   bool isdouble = false;
   bool isextra = false;
 
   if (nargin > 1 && args(nargin - 1).is_string ())
     {
@@ -2981,26 +2967,27 @@ inputs, @qcode{\"extra\"} is the same as
       else
         error ("sum: unrecognized type argument '%s'", str.c_str ());
       nargin --;
     }
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
-  octave_value arg = args(0);
-
   int dim = -1;
   if (nargin == 2)
     {
       dim = args(1).int_value () - 1;
       if (dim < 0)
         error ("sum: invalid dimension DIM = %d", dim + 1);
     }
 
+  octave_value retval;
+  octave_value arg = args(0);
+
   switch (arg.builtin_type ())
     {
     case btyp_double:
       if (arg.is_sparse_type ())
         {
           if (isextra)
             warning ("sum: 'extra' not yet implemented for sparse matrices");
           retval = arg.sparse_matrix_value ().sum (dim);
@@ -3287,23 +3274,23 @@ For example:\n\
 @group\n\
 complex ([1, 2], [3, 4])\n\
   @result{} [ 1 + 3i   2 + 4i ]\n\
 @end group\n\
 @end example\n\
 @seealso{real, imag, iscomplex, abs, arg}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
+  octave_value retval;
+
   if (nargin == 1)
     {
       octave_value arg = args(0);
 
       if (arg.is_complex_type ())
         retval = arg;
       else
         {
@@ -3397,26 +3384,23 @@ complex ([1, 2], [3, 4])\n\
                         result.data (re_val.ridx (i) + off) +=
                           re_val.data (i);
                     }
                 }
               retval = octave_value (new octave_sparse_complex_matrix (result));
             }
           else
             {
-              if (re_val.dims () == im_val.dims ())
-                {
-                  SparseComplexMatrix result;
-                  result = SparseComplexMatrix (re_val)
-                    + Complex (0, 1) * SparseComplexMatrix (im_val);
-                  retval = octave_value (
-                                         new octave_sparse_complex_matrix (result));
-                }
-              else
+              if (re_val.dims () != im_val.dims ())
                 error ("complex: dimension mismatch");
+
+              SparseComplexMatrix result;
+              result = SparseComplexMatrix (re_val)
+                + Complex (0, 1) * SparseComplexMatrix (im_val);
+              retval = octave_value (new octave_sparse_complex_matrix (result));
             }
         }
       else if (re.is_single_type () || im.is_single_type ())
         {
           if (re.numel () == 1)
             {
               float re_val = re.float_value ();
 
@@ -3457,30 +3441,28 @@ complex ([1, 2], [3, 4])\n\
 
                   retval = octave_value (new octave_float_complex_matrix
                                          (result));
                 }
               else
                 {
                   const FloatNDArray im_val = im.float_array_value ();
 
-                  if (re_val.dims () == im_val.dims ())
-                    {
-                      FloatComplexNDArray result (re_val.dims (),
-                                                  FloatComplex ());
-
-                      for (octave_idx_type i = 0; i < re_val.numel (); i++)
-                        result.xelem (i) = FloatComplex (re_val(i),
-                                                         im_val(i));
-
-                      retval = octave_value (new octave_float_complex_matrix
-                                             (result));
-                    }
-                  else
+                  if (re_val.dims () != im_val.dims ())
                     error ("complex: dimension mismatch");
+                  
+                  FloatComplexNDArray result (re_val.dims (),
+                                              FloatComplex ());
+
+                  for (octave_idx_type i = 0; i < re_val.numel (); i++)
+                    result.xelem (i) = FloatComplex (re_val(i),
+                                                     im_val(i));
+
+                  retval = octave_value (new octave_float_complex_matrix
+                                         (result));
                 }
             }
         }
       else if (re.numel () == 1)
         {
           double re_val = re.double_value ();
 
           if (im.numel () == 1)
@@ -3516,28 +3498,25 @@ complex ([1, 2], [3, 4])\n\
                 result.xelem (i) = Complex (re_val(i), im_val);
 
               retval = octave_value (new octave_complex_matrix (result));
             }
           else
             {
               const NDArray im_val = im.array_value ();
 
-              if (re_val.dims () == im_val.dims ())
-                {
-                  ComplexNDArray result (re_val.dims (), Complex ());
-
-                  for (octave_idx_type i = 0; i < re_val.numel (); i++)
-                    result.xelem (i) = Complex (re_val(i), im_val(i));
-
-                  retval = octave_value (
-                                         new octave_complex_matrix (result));
-                }
-              else
+              if (re_val.dims () != im_val.dims ())
                 error ("complex: dimension mismatch");
+
+              ComplexNDArray result (re_val.dims (), Complex ());
+
+              for (octave_idx_type i = 0; i < re_val.numel (); i++)
+                result.xelem (i) = Complex (re_val(i), im_val(i));
+
+              retval = octave_value (new octave_complex_matrix (result));
             }
         }
     }
 
   return retval;
 }
 
 DEFUN (isreal, args, ,
@@ -4972,18 +4951,16 @@ val = zeros (n,m, \"uint8\")\n\
 @end example\n\
 \n\
 Calling @code{eye} with no arguments is equivalent to calling it with an\n\
 argument of 1.  Any negative dimensions are treated as zero.  These odd\n\
 definitions are for compatibility with @sc{matlab}.\n\
 @seealso{speye, ones, zeros}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   oct_data_conv::data_type dt = oct_data_conv::dt_double;
 
   // Check for type information.
 
   if (nargin > 0 && args(nargin-1).is_string ())
     {
@@ -4991,16 +4968,18 @@ definitions are for compatibility with @
       nargin--;
 
       dt = oct_data_conv::string_to_data_type (nm);
     }
 
   if (nargin > 2)
     print_usage ();
 
+  octave_value retval;
+
   if (nargin == 0)
     retval = identity_matrix (1, 1, dt);
   else if (nargin == 1)
     {
       octave_idx_type nr, nc;
       get_dimensions (args(0), "eye", nr, nc);
 
       retval = identity_matrix (nr, nc, dt);
@@ -5091,30 +5070,26 @@ and @var{limit} are scalars.  If one, or
 each row is an independent sequence between\n\
 @w{@code{@var{base}(@var{row_n}), @var{limit}(@var{row_n})}}.\n\
 \n\
 For compatibility with @sc{matlab}, return the second argument (@var{limit})\n\
 if fewer than two values are requested.\n\
 @seealso{logspace}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
-  octave_idx_type npoints = 100;
-
   if (nargin != 2 && nargin != 3)
     print_usage ();
 
+  octave_idx_type npoints = 100;
   if (nargin == 3)
     {
       // Apparently undocumented Matlab.  If the third arg is an empty
       // numeric value, the number of points defaults to 1.
-
       octave_value arg_3 = args(2);
 
       if (arg_3.is_numeric_type () && arg_3.is_empty ())
         npoints = 1;
       else if (! arg_3.is_scalar_type ())
         error ("linspace: N must be a scalar");
       else
         // Even if third arg is not an integer, it must be cast to int
@@ -5126,23 +5101,25 @@ if fewer than two values are requested.\
 
   dim_vector sz1 = arg_1.dims ();
   bool isvector1 = sz1.length () == 2 && (sz1(0) == 1 || sz1(1) == 1);
   dim_vector sz2 = arg_2.dims ();
   bool isvector2 = sz2.length () == 2 && (sz2(0) == 1 || sz2(1) == 1);
 
   if (! isvector1 || ! isvector2)
     error ("linspace: A, B must be scalars or vectors");
-  else if (arg_1.is_single_type () || arg_2.is_single_type ())
+
+  octave_value retval;
+
+  if (arg_1.is_single_type () || arg_2.is_single_type ())
     {
       if (arg_1.is_complex_type () || arg_2.is_complex_type ())
         retval = do_linspace<FloatComplexMatrix> (arg_1, arg_2, npoints);
       else
         retval = do_linspace<FloatMatrix> (arg_1, arg_2, npoints);
-
     }
   else
     {
       if (arg_1.is_complex_type () || arg_2.is_complex_type ())
         retval = do_linspace<ComplexMatrix> (arg_1, arg_2, npoints);
       else
         retval = do_linspace<Matrix> (arg_1, arg_2, npoints);
     }
@@ -5249,23 +5226,23 @@ If given a vector as input, then the\n\
 dimensions of the result are given by the elements of that vector.\n\
 \n\
 An object can be resized to more dimensions than it has;\n\
 in such case the missing dimensions are assumed to be 1.\n\
 Resizing an object to fewer dimensions is not possible.\n\
 @seealso{reshape, postpad, prepad, cat}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin < 2)
     print_usage ();
 
+  octave_value retval;
+
   if (nargin == 2)
     {
       Array<double> vec = args(1).vector_value ();
       int ndim = vec.numel ();
       if (ndim == 1)
         {
           octave_idx_type m = static_cast<octave_idx_type> (vec(0));
           retval = args(0);
@@ -5326,74 +5303,65 @@ Note that the total number of elements i
 in the new matrix (@code{prod ([@var{m} @var{n} @dots{}])}).\n\
 \n\
 A single dimension of the return matrix may be left unspecified and Octave\n\
 will determine its size automatically.  An empty matrix ([]) is used to flag\n\
 the unspecified dimension.\n\
 @seealso{resize, vec, postpad, cat, squeeze}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin < 2)
     print_usage ();
 
+  octave_value retval;
+
   dim_vector new_dims;
 
   if (nargin == 2)
     {
       Array<octave_idx_type> new_size = args(1).octave_idx_type_vector_value ();
 
       if (new_size.numel () < 2)
         error ("reshape: SIZE must have 2 or more dimensions");
 
       new_dims = dim_vector::alloc (new_size.numel ());
 
       for (octave_idx_type i = 0; i < new_size.numel (); i++)
         {
           if (new_size(i) < 0)
-            {
-              error ("reshape: SIZE must be non-negative");
-              break;
-            }
+            error ("reshape: SIZE must be non-negative");
           else
             new_dims(i) = new_size(i);
         }
     }
   else
     {
       new_dims = dim_vector::alloc (nargin-1);
       int empty_dim = -1;
 
       for (int i = 1; i < nargin; i++)
         {
           if (args(i).is_empty ())
             {
               if (empty_dim > 0)
-                {
-                  error ("reshape: only a single dimension can be unknown");
-                  break;
-                }
+                error ("reshape: only a single dimension can be unknown");
               else
                 {
                   empty_dim = i;
                   new_dims(i-1) = 1;
                 }
             }
           else
             {
               new_dims(i-1) = args(i).idx_type_value ();
 
               if (new_dims(i-1) < 0)
-                {
-                  error ("reshape: SIZE must be non-negative");
-                  break;
-                }
+                error ("reshape: SIZE must be non-negative");
             }
         }
 
       if (empty_dim > 0)
         {
           octave_idx_type nel = new_dims.numel ();
 
           if (nel == 0)
@@ -5451,36 +5419,34 @@ one above the other.\n\
 Without @var{dim} this is equivalent to @code{@var{x}(:)}.\n\
 \n\
 If @var{dim} is supplied, the dimensions of @var{v} are set to @var{dim}\n\
 with all elements along the last dimension.  This is equivalent to\n\
 @code{shiftdim (@var{x}(:), 1-@var{dim})}.\n\
 @seealso{vech, resize, cat}\n\
 @end deftypefn")
 {
-  octave_value retval;
-  int dim = 1;
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage () ;
 
+  int dim = 1;
   if (nargin == 2)
     {
       dim = args(1).idx_type_value ();
 
       if (dim < 1)
         error ("vec: DIM must be greater than zero");
     }
 
   octave_value colon (octave_value::magic_colon_t);
   octave_value arg = args(0);
-  retval = arg.single_subsref ("(", colon);
-
+
+  octave_value retval = arg.single_subsref ("(", colon);
 
   if (dim > 1)
     {
       dim_vector new_dims = dim_vector::alloc (dim);
 
       for (int i = 0; i < dim-1; i++)
         new_dims(i) = 1;
 
@@ -5594,94 +5560,92 @@ the p-pseudonorm defined as above.\n\
 \n\
 If @var{opt} is the value @qcode{\"rows\"}, treat each row as a vector and\n\
 compute its norm.  The result is returned as a column vector.\n\
 Similarly, if @var{opt} is @qcode{\"columns\"} or @qcode{\"cols\"} then\n\
 compute the norms of each column and return a row vector.\n\
 @seealso{cond, svd}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   int nargin = args.length ();
 
   if (nargin < 1 && nargin > 3)
     print_usage ();
 
   octave_value x_arg = args(0);
 
-  if (x_arg.ndims () == 2)
+  if (x_arg.ndims () != 2)
+    error ("norm: only valid for 2-D objects");
+
+  enum { sfmatrix, sfcols, sfrows, sffrob, sfinf } strflag = sfmatrix;
+  if (nargin > 1 && args(nargin-1).is_string ())
     {
-      enum { sfmatrix, sfcols, sfrows, sffrob, sfinf } strflag = sfmatrix;
-      if (nargin > 1 && args(nargin-1).is_string ())
+      std::string str = args(nargin-1).string_value ();
+      if (str == "cols" || str == "columns")
+        strflag = sfcols;
+      else if (str == "rows")
+        strflag = sfrows;
+      else if (str == "fro")
+        strflag = sffrob;
+      else if (str == "inf")
+        strflag = sfinf;
+      else
+        error ("norm: unrecognized option: %s", str.c_str ());
+      // we've handled the last parameter, so act as if it was removed
+      nargin --;
+    }
+
+  octave_value p_arg = (nargin > 1) ? args(1) : octave_value (2);
+
+  if (p_arg.is_empty ())
+    p_arg = octave_value (2);
+  else if (p_arg.is_string ())
+    {
+      std::string str = p_arg.string_value ();
+      if ((strflag == sfcols || strflag == sfrows))
         {
-          std::string str = args(nargin-1).string_value ();
-          if (str == "cols" || str == "columns")
-            strflag = sfcols;
-          else if (str == "rows")
-            strflag = sfrows;
+          if (str == "cols" || str == "columns" || str == "rows")
+            error ("norm: invalid combination of options");
           else if (str == "fro")
-            strflag = sffrob;
+            p_arg = octave_value (2);
           else if (str == "inf")
-            strflag = sfinf;
+            p_arg = octave_Inf;
           else
             error ("norm: unrecognized option: %s", str.c_str ());
-          // we've handled the last parameter, so act as if it was removed
-          nargin --;
         }
-
-      octave_value p_arg = (nargin > 1) ? args(1) : octave_value (2);
-
-      if (p_arg.is_empty ())
-        p_arg = octave_value (2);
-      else if (p_arg.is_string ())
-        {
-          std::string str = p_arg.string_value ();
-          if ((strflag == sfcols || strflag == sfrows))
-            {
-              if (str == "cols" || str == "columns" || str == "rows")
-                error ("norm: invalid combination of options");
-              else if (str == "fro")
-                p_arg = octave_value (2);
-              else if (str == "inf")
-                p_arg = octave_Inf;
-              else
-                error ("norm: unrecognized option: %s", str.c_str ());
-            }
-          else
-            error ("norm: invalid combination of options");
-        }
-      else if (! p_arg.is_scalar_type ())
-        gripe_wrong_type_arg ("norm", p_arg, true);
-
-      switch (strflag)
-        {
-        case sfmatrix:
-          retval(0) = xnorm (x_arg, p_arg);
-          break;
-
-        case sfcols:
-          retval(0) = xcolnorms (x_arg, p_arg);
-          break;
-
-        case sfrows:
-          retval(0) = xrownorms (x_arg, p_arg);
-          break;
-
-        case sffrob:
-          retval(0) = xfrobnorm (x_arg);
-          break;
-
-        case sfinf:
-          retval(0) = xnorm (x_arg, octave_Inf);
-          break;
-        }
+      else
+        error ("norm: invalid combination of options");
     }
-  else
-    error ("norm: only valid for 2-D objects");
+  else if (! p_arg.is_scalar_type ())
+    gripe_wrong_type_arg ("norm", p_arg, true);
+
+  octave_value retval;
+
+  switch (strflag)
+    {
+    case sfmatrix:
+      retval = xnorm (x_arg, p_arg);
+      break;
+
+    case sfcols:
+      retval = xcolnorms (x_arg, p_arg);
+      break;
+
+    case sfrows:
+      retval = xrownorms (x_arg, p_arg);
+      break;
+
+    case sffrob:
+      retval = xfrobnorm (x_arg);
+      break;
+
+    case sfinf:
+      retval = xnorm (x_arg, octave_Inf);
+      break;
+    }
 
   return retval;
 }
 
 /*
 %!shared x
 %! x = [1, -3, 4, 5, -7];
 %!assert (norm (x,1), 20)
@@ -5867,23 +5831,23 @@ binary_op_defun_body (octave_value::bina
   return do_binary_op (op, args(0), args(1));
 }
 
 static octave_value
 binary_assoc_op_defun_body (octave_value::binary_op op,
                             octave_value::assign_op aop,
                             const octave_value_list& args)
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin == 0)
     print_usage ();
 
+  octave_value retval;
+
   if (nargin == 1)
     retval = args(0);
   else if (nargin == 2)
     retval = do_binary_op (op, args(0), args(1));
   else
     {
       retval = do_binary_op (op, args(0), args(1));
 
@@ -6166,19 +6130,18 @@ This function is equivalent to the opera
 or @w{@code{base : increment : limit}}.\n\
 @end deftypefn")
 {
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
 
-  return (nargin == 2)
-    ? do_colon_op (args(0), args(1))
-    : do_colon_op (args(0), args(1), args (2));
+  return (nargin == 2) ? do_colon_op (args(0), args(1))
+                       : do_colon_op (args(0), args(1), args(2));
 }
 
 static double tic_toc_timestamp = -1.0;
 
 DEFUN (tic, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} tic ()\n\
 @deftypefnx {} {@var{id} =} tic ()\n\
@@ -6250,53 +6213,50 @@ doing nothing at all.\n\
 DEFUN (toc, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} toc ()\n\
 @deftypefnx {} {} toc (@var{id})\n\
 @deftypefnx {} {@var{val} =} toc (@dots{})\n\
 @seealso{tic, cputime}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
-  double start_time = tic_toc_timestamp;
-
   if (nargin > 1)
     print_usage ();
 
+  double start_time = tic_toc_timestamp;
+
   if (nargin == 1)
     {
       octave_uint64 id = args(0).xuint64_scalar_value ("toc: invalid ID");
 
       uint64_t val = id.value ();
 
       start_time
         = (static_cast<double> (val / CLOCKS_PER_SEC)
            + static_cast<double> (val % CLOCKS_PER_SEC)
            / CLOCKS_PER_SEC);
 
       // FIXME: should we also check to see whether the start
-      // time is after the beginning of this Octave session?
+      //        time is after the beginning of this Octave session?
     }
 
   if (start_time < 0)
     error ("toc called before timer set");
+
+  octave_time now;
+
+  double etime = now.double_value () - start_time;
+
+  octave_value retval;
+  if (nargout > 0)
+    retval = etime;
   else
-    {
-      octave_time now;
-
-      double tmp = now.double_value () - start_time;
-
-      if (nargout > 0)
-        retval = tmp;
-      else
-        octave_stdout << "Elapsed time is " << tmp << " seconds.\n";
-    }
+    octave_stdout << "Elapsed time is " << etime << " seconds.\n";
 
   return retval;
 }
 
 /*
 %!shared id
 %! id = tic ();
 %!assert (isa (id, "uint64"))
@@ -6688,65 +6648,61 @@ ordered lists.\n\
 */
 
 // Sort the rows of the matrix @var{a} according to the order
 // specified by @var{mode}, which can either be 'ascend' or 'descend'
 // and return the index vector corresponding to the sort order.
 //
 // This function does not yet support sparse matrices.
 
+// FIXME: Is this function used anymore?  12/14/2015
 DEFUN (__sort_rows_idx__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __sort_rows_idx__ (@var{a}, @var{mode})\n\
 Undocumented internal function.\n\
 @end deftypefn\n")
 {
-  octave_value retval;
-
   int nargin = args.length ();
-  sortmode smode = ASCENDING;
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   if (nargin == 2 && ! args(1).is_string ())
     error ("__sort_rows_idx__: second argument must be a string");
 
+  sortmode smode = ASCENDING;
   if (nargin > 1)
     {
       std::string mode = args(1).string_value ();
       if (mode == "ascend")
         smode = ASCENDING;
       else if (mode == "descend")
         smode = DESCENDING;
       else
           error ("__sort_rows_idx__: MODE must be either \"ascend\" or \"descend\"");
     }
 
   octave_value arg = args(0);
 
   if (arg.is_sparse_type ())
     error ("__sort_rows_idx__: sparse matrices not yet supported");
-  if (arg.ndims () == 2)
-    {
-      Array<octave_idx_type> idx = arg.sort_rows_idx (smode);
-
-      retval = octave_value (idx, true, true);
-    }
-  else
+
+  if (arg.ndims () != 2)
     error ("__sort_rows_idx__: needs a 2-dimensional object");
 
-  return retval;
+  Array<octave_idx_type> idx = arg.sort_rows_idx (smode);
+
+  return octave_value (idx, true, true);
 }
 
 static sortmode
 get_sort_mode_option (const octave_value& arg)
 {
   // FIXME: we initialize to UNSORTED here to avoid a GCC warning
-  // about possibly using sortmode uninitialized.
+  //        about possibly using sortmode uninitialized.
   // FIXME: shouldn't these modes be scoped inside a class?
   sortmode smode = UNSORTED;
 
   std::string mode = arg.xstring_value ("issorted: MODE must be a string");
 
   if (mode == "ascending")
     smode = ASCENDING;
   else if (mode == "descending")
@@ -6774,18 +6730,16 @@ same manner as @code{sort}.\n\
 If the optional argument @qcode{\"rows\"} is supplied, check whether\n\
 the array is sorted by rows as output by the function @code{sortrows}\n\
 (with no options).\n\
 \n\
 This function does not support sparse matrices.\n\
 @seealso{sort, sortrows}\n\
 @end deftypefn\n")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
 
   bool by_rows = false;
 
   sortmode smode = ASCENDING;
@@ -6799,33 +6753,35 @@ This function does not support sparse ma
 
       std::string tmp = args(1).xstring_value ("issorted: second argument must be a string");
       if (tmp == "rows")
         by_rows = true;
       else
         smode = get_sort_mode_option (args(1));
     }
 
+  octave_value retval;
+
   octave_value arg = args(0);
 
   if (by_rows)
     {
       if (arg.is_sparse_type ())
         error ("issorted: sparse matrices not yet supported");
-      if (arg.ndims () == 2)
-        retval = arg.is_sorted_rows (smode) != UNSORTED;
-      else
+      if (arg.ndims () != 2)
         error ("issorted: A must be a 2-dimensional object");
+
+      retval = arg.is_sorted_rows (smode) != UNSORTED;
     }
   else
     {
-      if (arg.dims ().is_vector ())
-        retval = args(0).is_sorted (smode) != UNSORTED;
-      else
+      if (! arg.dims ().is_vector ())
         error ("issorted: needs a vector");
+
+      retval = args(0).is_sorted (smode) != UNSORTED;
     }
 
   return retval;
 }
 
 /*
 %!shared sm, um, sv, uv
 %! sm = [1, 2; 3, 4];
@@ -6891,35 +6847,35 @@ not given.\n\
 Programming Note: nth_element encapsulates the C++ standard library\n\
 algorithms nth_element and partial_sort.  On average, the complexity of the\n\
 operation is O(M*log(K)), where @w{@code{M = size (@var{x}, @var{dim})}} and\n\
 @w{@code{K = length (@var{n})}}.  This function is intended for cases where\n\
 the ratio K/M is small; otherwise, it may be better to use @code{sort}.\n\
 @seealso{sort, min, max}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
 
-  octave_value argx = args(0);
-
   int dim = -1;
   if (nargin == 3)
     {
       dim = args(2).int_value (true) - 1;
       if (dim < 0)
         error ("nth_element: DIM must be a valid dimension");
     }
+
+  octave_value argx = args(0);
   if (dim < 0)
     dim = argx.dims ().first_non_singleton ();
 
+  octave_value retval;
+
   try
     {
       idx_vector n = args(1).index_vector ();
 
       switch (argx.builtin_type ())
         {
         case btyp_double:
           retval = argx.array_value ().nth_element (n, dim);
@@ -6987,26 +6943,26 @@ do_accumarray_sum (const idx_vector& idx
 }
 
 DEFUN (__accumarray_sum__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __accumarray_sum__ (@var{idx}, @var{vals}, @var{n})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin < 2 && nargin > 3)
     print_usage ();
 
   if (! args(0).is_numeric_type ())
     error ("__accumarray_sum__: first argument must be numeric");
 
+  octave_value retval;
+
   try
     {
       idx_vector idx = args(0).index_vector ();
       octave_idx_type n = -1;
       if (nargin == 3)
         n = args(2).idx_type_value (true);
 
       octave_value vals = args(1);
@@ -7076,26 +7032,26 @@ do_accumarray_minmax (const idx_vector& 
 
   return retval;
 }
 
 static octave_value_list
 do_accumarray_minmax_fun (const octave_value_list& args,
                           bool ismin)
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin < 3 && nargin > 4)
     print_usage ();
 
   if (! args(0).is_numeric_type ())
     error ("accumarray: first argument must be numeric");
 
+  octave_value retval;
+
   try
     {
       idx_vector idx = args(0).index_vector ();
       octave_idx_type n = -1;
       if (nargin == 4)
         n = args(3).idx_type_value (true);
 
       octave_value vals = args(1);
@@ -7210,26 +7166,26 @@ do_accumdim_sum (const idx_vector& idx, 
 }
 
 DEFUN (__accumdim_sum__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __accumdim_sum__ (@var{idx}, @var{vals}, @var{dim}, @var{n})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin < 2 && nargin > 4)
     print_usage ();
 
   if (! args(0).is_numeric_type ())
     error ("__accumdim_sum__: first argument must be numeric");
 
+  octave_value retval;
+
   try
     {
       idx_vector idx = args(0).index_vector ();
       int dim = -1;
       if (nargin >= 3)
         dim = args(2).int_value () - 1;
 
       octave_idx_type n = -1;
@@ -7359,24 +7315,24 @@ result(! mask) = fval(! mask);\n\
 @end group\n\
 @end example\n\
 \n\
 @var{mask} can also be arbitrary numeric type, in which case it is first\n\
 converted to logical.\n\
 @seealso{logical, diff}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 3)
     print_usage ();
 
   if (! (args(0).is_bool_type () || args(0).is_numeric_type ()))
     error ("merge: first argument must be logical or numeric");
 
+  octave_value retval;
+
   octave_value mask_val = args(0);
 
   if (mask_val.is_scalar_type ())
     retval = mask_val.is_true () ? args(1) : args(2);
   else
     {
       boolNDArray mask = mask_val.bool_array_value ();
 
@@ -7593,18 +7549,16 @@ non-singleton dimension.\n\
 The dimension along which to take the difference can be explicitly\n\
 stated with the optional variable @var{dim}.  In this case the\n\
 @var{k}-th order differences are calculated along this dimension.\n\
 In the case where @var{k} exceeds @w{@code{size (@var{x}, @var{dim})}}\n\
 an empty matrix is returned.\n\
 @seealso{sort, merge}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
 
   if (! (args(0).is_numeric_type () || args(0).is_bool_type ()))
     error ("diff: X must be numeric or logical");
 
@@ -7624,19 +7578,17 @@ an empty matrix is returned.\n\
     {
       dim = args(2).int_value (true, false);
       if (dim < 1 || dim > args(0).ndims ())
         error ("diff: DIM must be a valid dimension");
       else
         dim -= 1;
     }
 
-  retval = do_diff (args(0), order, dim);
-
-  return retval;
+  return do_diff (args(0), order, dim);
 }
 
 /*
 %!assert (diff ([1, 2, 3, 4]), [1, 1, 1])
 %!assert (diff ([1, 3, 7, 19], 2), [2, 8])
 %!assert (diff ([1, 2; 5, 4; 8, 7; 9, 6; 3, 1]), [4, 2; 3, 3; 1, -1; -6, -5])
 %!assert (diff ([1, 2; 5, 4; 8, 7; 9, 6; 3, 1], 3), [-1, -5; -5, 0])
 %!assert (isempty (diff (1)))
@@ -7708,96 +7660,91 @@ endfor\n\
     print_usage ();
 
   octave_value retval;
 
   const Matrix rm = args(1).matrix_value ();
 
   if (rm.rows () != 2 || rm.ndims () != 2)
     error ("repelems: R must be a matrix with two rows");
-  else
+
+  octave_value x = args(0);
+
+  NoAlias< Array<octave_idx_type> > r (rm.dims ());
+
+  for (octave_idx_type i = 0; i < rm.numel (); i++)
     {
-      octave_value x = args(0);
-
-      NoAlias< Array<octave_idx_type> > r (rm.dims ());
-
-      for (octave_idx_type i = 0; i < rm.numel (); i++)
-        {
-          octave_idx_type rx = rm(i);
-          if (static_cast<double> (rx) != rm(i))
-            error ("repelems: R must be a matrix of integers");
-
-          r(i) = rx;
-        }
-
-      switch (x.builtin_type ())
-        {
+      octave_idx_type rx = rm(i);
+      if (static_cast<double> (rx) != rm(i))
+        error ("repelems: R must be a matrix of integers");
+
+      r(i) = rx;
+    }
+
+  switch (x.builtin_type ())
+    {
 #define BTYP_BRANCH(X, EX) \
-        case btyp_ ## X: \
-          retval = do_repelems (x.EX ## _value (), r); \
-          break;
-
-          BTYP_BRANCH (double, array);
-          BTYP_BRANCH (float, float_array);
-          BTYP_BRANCH (complex, complex_array);
-          BTYP_BRANCH (float_complex, float_complex_array);
-          BTYP_BRANCH (bool, bool_array);
-          BTYP_BRANCH (char, char_array);
-
-          BTYP_BRANCH (int8,  int8_array);
-          BTYP_BRANCH (int16, int16_array);
-          BTYP_BRANCH (int32, int32_array);
-          BTYP_BRANCH (int64, int64_array);
-          BTYP_BRANCH (uint8,  uint8_array);
-          BTYP_BRANCH (uint16, uint16_array);
-          BTYP_BRANCH (uint32, uint32_array);
-          BTYP_BRANCH (uint64, uint64_array);
-
-          BTYP_BRANCH (cell, cell);
-          //BTYP_BRANCH (struct, map);//FIXME
+    case btyp_ ## X: \
+      retval = do_repelems (x.EX ## _value (), r); \
+      break;
+
+      BTYP_BRANCH (double, array);
+      BTYP_BRANCH (float, float_array);
+      BTYP_BRANCH (complex, complex_array);
+      BTYP_BRANCH (float_complex, float_complex_array);
+      BTYP_BRANCH (bool, bool_array);
+      BTYP_BRANCH (char, char_array);
+
+      BTYP_BRANCH (int8,  int8_array);
+      BTYP_BRANCH (int16, int16_array);
+      BTYP_BRANCH (int32, int32_array);
+      BTYP_BRANCH (int64, int64_array);
+      BTYP_BRANCH (uint8,  uint8_array);
+      BTYP_BRANCH (uint16, uint16_array);
+      BTYP_BRANCH (uint32, uint32_array);
+      BTYP_BRANCH (uint64, uint64_array);
+
+      BTYP_BRANCH (cell, cell);
+      //BTYP_BRANCH (struct, map);//FIXME
 #undef BTYP_BRANCH
 
-        default:
-          gripe_wrong_type_arg ("repelems", x);
-        }
+    default:
+      gripe_wrong_type_arg ("repelems", x);
     }
 
   return retval;
 }
 
 DEFUN (base64_encode, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {@var{s} =} base64_encode (@var{x})\n\
 Encode a double matrix or array @var{x} into the base64 format string\n\
 @var{s}.\n\
 \n\
 @seealso{base64_decode}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 1)
     print_usage ();
 
   if (! args(0).is_numeric_type ())
     error ("base64_encode: encoding is supported only for numeric arrays");
-  else if (args(0).is_complex_type ()
-           || args(0).is_sparse_type ())
+  else if (args(0).is_complex_type () || args(0).is_sparse_type ())
     error ("base64_encode: encoding complex or sparse data is not supported");
 
+  octave_value_list retval;
+
   if (args(0).is_integer_type ())
     {
 #define MAKE_INT_BRANCH(X) \
       if (args(0).is_ ## X ## _type ()) \
         { \
           const X##NDArray in = args(0).  X## _array_value (); \
-          size_t inlen = \
-            in.numel () * sizeof (X## _t) / sizeof (char); \
-          const char* inc = \
-            reinterpret_cast<const char*> (in.data ()); \
+          size_t inlen = in.numel () * sizeof (X## _t) / sizeof (char); \
+          const char* inc = reinterpret_cast<const char*> (in.data ()); \
           char* out; \
           if (octave_base64_encode (inc, inlen, &out)) \
             { \
               retval(0) = octave_value (out); \
               ::free (out); \
             } \
         }
 
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -1110,31 +1110,29 @@ If unspecified @var{n} defaults to 10 (+
     error ("dblist: must be inside a user function to use dblist\n");
 
   return retval;
 }
 
 static octave_value_list
 do_dbstack (const octave_value_list& args, int nargout, std::ostream& os)
 {
+  int nargin = args.length ();
+
+  if (nargin > 2)
+    print_usage ();
+
   octave_value_list retval;
 
   unwind_protect frame;
 
   octave_idx_type curr_frame = -1;
 
   size_t nskip = 0;
 
-  int nargin = args.length ();
-
-  // dbstack accepts up to 2 arguments.
-
-  if (nargin > 2)
-    print_usage ();
-
   if (nargin == 1 || nargin == 2)
     {
       int n = 0;
 
       for (octave_idx_type i = 0; i < nargin; i++)
         {
           octave_value arg = args(i);
 
@@ -1355,111 +1353,105 @@ any m-files defined on the next line.\n\
 \n\
 Using @code{dbstep out} will cause execution to continue until the current\n\
 function returns.\n\
 \n\
 @code{dbnext} is an alias for @code{dbstep}.\n\
 @seealso{dbcont, dbquit}\n\
 @end deftypefn")
 {
-  if (Vdebugging)
-    {
-      int nargin = args.length ();
+  if (! Vdebugging)
+    error ("dbstep: can only be called in debug mode");
+
+  int nargin = args.length ();
 
-      if (nargin > 1)
-        print_usage ();
+  if (nargin > 1)
+    print_usage ();
 
-      if (nargin == 1)
+  if (nargin == 1)
+    {
+      std::string arg = args(0).xstring_value ("dbstep: input argument must be a string");
+
+      if (arg == "in")
         {
-          std::string arg = args(0).xstring_value ("dbstep: input argument must be a string");
+          Vdebugging = false;
+
+          tree_evaluator::dbstep_flag = -1;
+        }
+      else if (arg == "out")
+        {
+          Vdebugging = false;
 
-          if (arg == "in")
-            {
-              Vdebugging = false;
+          tree_evaluator::dbstep_flag = -2;
+        }
+      else
+        {
+          int n = atoi (arg.c_str ());
 
-              tree_evaluator::dbstep_flag = -1;
-            }
-          else if (arg == "out")
+          if (n > 0)
             {
               Vdebugging = false;
 
-              tree_evaluator::dbstep_flag = -2;
+              tree_evaluator::dbstep_flag = n;
             }
           else
-            {
-              int n = atoi (arg.c_str ());
-
-              if (n > 0)
-                {
-                  Vdebugging = false;
-
-                  tree_evaluator::dbstep_flag = n;
-                }
-              else
-                error ("dbstep: invalid argument");
-            }
-        }
-      else
-        {
-          Vdebugging = false;
-
-          tree_evaluator::dbstep_flag = 1;
+            error ("dbstep: invalid argument");
         }
     }
   else
-    error ("dbstep: can only be called in debug mode");
+    {
+      Vdebugging = false;
+
+      tree_evaluator::dbstep_flag = 1;
+    }
 
   return octave_value_list ();
 }
 
 DEFALIAS (dbnext, dbstep);
 
 DEFUN (dbcont, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} dbcont\n\
 Leave command-line debugging mode and continue code execution normally.\n\
 @seealso{dbstep, dbquit}\n\
 @end deftypefn")
 {
-  if (Vdebugging)
-    {
-      if (args.length () != 0)
-        print_usage ();
+  if (! Vdebugging)
+    error ("dbcont: can only be called in debug mode");
 
-      Vdebugging = false;
+  if (args.length () != 0)
+    print_usage ();
 
-      tree_evaluator::reset_debug_state ();
-    }
-  else
-    error ("dbcont: can only be called in debug mode");
+  Vdebugging = false;
+
+  tree_evaluator::reset_debug_state ();
 
   return octave_value_list ();
 }
 
 DEFUN (dbquit, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} dbquit\n\
 Quit debugging mode immediately without further code execution and return to\n\
 the Octave prompt.\n\
 @seealso{dbcont, dbstep}\n\
 @end deftypefn")
 {
-  if (Vdebugging)
-    {
-      if (args.length () != 0)
-        print_usage ();
+  if (! Vdebugging)
+    error ("dbquit: can only be called in debug mode");
 
-      Vdebugging = false;
+  if (args.length () != 0)
+    print_usage ();
 
-      tree_evaluator::reset_debug_state ();
+  Vdebugging = false;
 
-      octave_throw_interrupt_exception ();
-    }
-  else
-    error ("dbquit: can only be called in debug mode");
+  tree_evaluator::reset_debug_state ();
+
+  octave_throw_interrupt_exception ();
 
   return octave_value_list ();
 }
 
 DEFUN (isdebugmode, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} isdebugmode ()\n\
 Return true if in debugging mode, otherwise false.\n\
@@ -1476,24 +1468,23 @@ DEFUN (__db_next_breakpoint_quiet__, arg
        "-*- texinfo -*-\n\
 @deftypefn  {} {} __db_next_breakpoint_quiet__ ()\n\
 @deftypefnx {} {} __db_next_breakpoint_quiet__ (@var{flag})\n\
 Disable line info printing at the next breakpoint.\n\
 \n\
 With a logical argument @var{flag}, set the state on or off.\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin > 1)
     print_usage ();
 
   bool state = true;
 
   if (nargin == 1)
     state = args(0).bool_value ();
 
   tree_evaluator::quiet_breakpoint_flag = state;
 
-  return retval;
+  return octave_value_list ();
 }
+
diff --git a/libinterp/corefcn/dirfns.cc b/libinterp/corefcn/dirfns.cc
--- a/libinterp/corefcn/dirfns.cc
+++ b/libinterp/corefcn/dirfns.cc
@@ -558,51 +558,52 @@ Return the system-dependent character us
 \n\
 If @qcode{\"all\"} is given, the function returns all valid file separators\n\
 in the form of a string.  The list of file separators is system-dependent.\n\
 It is @samp{/} (forward slash) under UNIX or @w{Mac OS X}, @samp{/} and\n\
 @samp{\\} (forward and backward slashes) under Windows.\n\
 @seealso{pathsep}\n\
 @end deftypefn")
 {
-  octave_value retval;
+  int nargin = args.length ();
 
-  int nargin = args.length ();
   if (nargin > 1)
     print_usage ();
 
+  octave_value retval;
+
   if (nargin == 0)
     retval = file_ops::dir_sep_str ();
   else
     {
       std::string s = args(0).xstring_value ("filesep: argument must be a string");
-      if (s == "all")
-        retval = file_ops::dir_sep_chars ();
-      else
+      if (s != "all")
         error ("filesep: argument must be \"all\"");
+
+      retval = file_ops::dir_sep_chars ();
     }
 
   return retval;
 }
 
 DEFUN (pathsep, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{val} =} pathsep ()\n\
 @deftypefnx {} {@var{old_val} =} pathsep (@var{new_val})\n\
 Query or set the character used to separate directories in a path.\n\
 @seealso{filesep}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin > 1)
     print_usage ();
 
+  octave_value retval;
+
   if (nargout > 0 || nargin == 0)
     retval = dir_path::path_sep_str ();
 
   if (nargin == 1)
     {
       std::string sval = args(0).xstring_value ("pathsep: argument must be a single character");
 
       switch (sval.length ())
diff --git a/libinterp/corefcn/dlmread.cc b/libinterp/corefcn/dlmread.cc
--- a/libinterp/corefcn/dlmread.cc
+++ b/libinterp/corefcn/dlmread.cc
@@ -183,18 +183,16 @@ lowest row index is 1.\n\
 @var{file} should be a filename or file id given by @code{fopen}.  In the\n\
 latter case, the file is read until end of file is reached.\n\
 \n\
 The @qcode{\"emptyvalue\"} option may be used to specify the value used to\n\
 fill empty fields.  The default is zero.\n\
 @seealso{csvread, textscan, textread, dlmwrite}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   int nargin = args.length ();
 
   double empty_value = 0.0;
 
   if (nargin > 2 && args(nargin-2).is_string ()
       && args(nargin-2).string_value () == "emptyvalue")
     {
       empty_value = args(nargin-1).double_value ();
@@ -455,21 +453,19 @@ fill empty fields.  The default is zero.
     {
       if (iscmplx)
         cdata = cdata.extract (0, c0, r1, c1);
       else
         rdata = rdata.extract (0, c0, r1, c1);
     }
 
   if (iscmplx)
-    retval(0) = cdata;
+    return octave_value (cdata);
   else
-    retval(0) = rdata;
-
-  return retval;
+    return octave_value (rdata);
 }
 
 /*
 %!shared file
 %! file = tempname ();
 %! fid = fopen (file, "wt");
 %! fwrite (fid, "1, 2, 3\n4, 5, 6\n7, 8, 9\n10, 11, 12");
 %! fclose (fid);
diff --git a/libinterp/corefcn/dot.cc b/libinterp/corefcn/dot.cc
--- a/libinterp/corefcn/dot.cc
+++ b/libinterp/corefcn/dot.cc
@@ -117,126 +117,118 @@ along this dimension.\n\
 This is equivalent to\n\
 @code{sum (conj (@var{X}) .* @var{Y}, @var{dim})},\n\
 but avoids forming a temporary array and is faster.  When @var{X} and\n\
 @var{Y} are column vectors, the result is equivalent to\n\
 @code{@var{X}' * @var{Y}}.\n\
 @seealso{cross, divergence}\n\
 @end deftypefn")
 {
-  octave_value retval;
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
 
+  octave_value retval;
   octave_value argx = args(0);
   octave_value argy = args(1);
 
-  if (argx.is_numeric_type () && argy.is_numeric_type ())
-    {
-      dim_vector dimx = argx.dims ();
-      dim_vector dimy = argy.dims ();
-      bool match = dimx == dimy;
-      if (! match && nargin == 2
-          && dimx.is_vector () && dimy.is_vector ())
-        {
-          // Change to column vectors.
-          dimx = dimx.redim (1);
-          argx = argx.reshape (dimx);
-          dimy = dimy.redim (1);
-          argy = argy.reshape (dimy);
-          match = dimx == dimy;
-        }
+  if (! argx.is_numeric_type () || ! argy.is_numeric_type ())
+    error ("dot: X and Y must be numeric");
 
-      if (match)
-        {
-          int dim;
-          if (nargin == 2)
-            dim = dimx.first_non_singleton ();
-          else
-            dim = args(2).int_value (true) - 1;
+  dim_vector dimx = argx.dims ();
+  dim_vector dimy = argy.dims ();
+  bool match = dimx == dimy;
+  if (! match && nargin == 2 && dimx.is_vector () && dimy.is_vector ())
+    {
+      // Change to column vectors.
+      dimx = dimx.redim (1);
+      argx = argx.reshape (dimx);
+      dimy = dimy.redim (1);
+      argy = argy.reshape (dimy);
+      match = dimx == dimy;
+    }
 
-          if (dim < 0)
-            error ("dot: DIM must be a valid dimension");
-          else
-            {
-              octave_idx_type m, n, k;
-              dim_vector dimz;
-              if (argx.is_complex_type () || argy.is_complex_type ())
-                {
-                  if (argx.is_single_type () || argy.is_single_type ())
-                    {
-                      FloatComplexNDArray x = argx.float_complex_array_value ();
-                      FloatComplexNDArray y = argy.float_complex_array_value ();
-                      get_red_dims (dimx, dimy, dim, dimz, m, n, k);
-                      FloatComplexNDArray z (dimz);
+  if (! match)
+    error ("dot: sizes of X and Y must match");
 
-                      F77_XFCN (cdotc3, CDOTC3, (m, n, k,
-                                                 x.data (), y.data (),
-                                                 z.fortran_vec ()));
-                      retval = z;
-                    }
-                  else
-                    {
-                      ComplexNDArray x = argx.complex_array_value ();
-                      ComplexNDArray y = argy.complex_array_value ();
-                      get_red_dims (dimx, dimy, dim, dimz, m, n, k);
-                      ComplexNDArray z (dimz);
+  int dim;
+  if (nargin == 2)
+    dim = dimx.first_non_singleton ();
+  else
+    dim = args(2).int_value (true) - 1;
 
-                      F77_XFCN (zdotc3, ZDOTC3, (m, n, k,
-                                                 x.data (), y.data (),
-                                                 z.fortran_vec ()));
-                      retval = z;
-                    }
-                }
-              else if (argx.is_float_type () && argy.is_float_type ())
-                {
-                  if (argx.is_single_type () || argy.is_single_type ())
-                    {
-                      FloatNDArray x = argx.float_array_value ();
-                      FloatNDArray y = argy.float_array_value ();
-                      get_red_dims (dimx, dimy, dim, dimz, m, n, k);
-                      FloatNDArray z (dimz);
+  if (dim < 0)
+    error ("dot: DIM must be a valid dimension");
 
-                      F77_XFCN (sdot3, SDOT3, (m, n, k, x.data (), y.data (),
-                                               z.fortran_vec ()));
-                      retval = z;
-                    }
-                  else
-                    {
-                      NDArray x = argx.array_value ();
-                      NDArray y = argy.array_value ();
-                      get_red_dims (dimx, dimy, dim, dimz, m, n, k);
-                      NDArray z (dimz);
+  octave_idx_type m, n, k;
+  dim_vector dimz;
+  if (argx.is_complex_type () || argy.is_complex_type ())
+    {
+      if (argx.is_single_type () || argy.is_single_type ())
+        {
+          FloatComplexNDArray x = argx.float_complex_array_value ();
+          FloatComplexNDArray y = argy.float_complex_array_value ();
+          get_red_dims (dimx, dimy, dim, dimz, m, n, k);
+          FloatComplexNDArray z (dimz);
 
-                      F77_XFCN (ddot3, DDOT3, (m, n, k, x.data (), y.data (),
-                                               z.fortran_vec ()));
-                      retval = z;
-                    }
-                }
-              else
-                {
-                  // Non-optimized evaluation.
-                  octave_value_list tmp;
-                  tmp(1) = dim + 1;
-                  tmp(0) = do_binary_op (octave_value::op_el_mul, argx, argy);
-
-                  tmp = feval ("sum", tmp, 1);
-                  if (! tmp.empty ())
-                    retval = tmp(0);
-                }
-            }
+          F77_XFCN (cdotc3, CDOTC3, (m, n, k,
+                                     x.data (), y.data (),
+                                     z.fortran_vec ()));
+          retval = z;
         }
       else
-        error ("dot: sizes of X and Y must match");
+        {
+          ComplexNDArray x = argx.complex_array_value ();
+          ComplexNDArray y = argy.complex_array_value ();
+          get_red_dims (dimx, dimy, dim, dimz, m, n, k);
+          ComplexNDArray z (dimz);
 
+          F77_XFCN (zdotc3, ZDOTC3, (m, n, k,
+                                     x.data (), y.data (),
+                                     z.fortran_vec ()));
+          retval = z;
+        }
+    }
+  else if (argx.is_float_type () && argy.is_float_type ())
+    {
+      if (argx.is_single_type () || argy.is_single_type ())
+        {
+          FloatNDArray x = argx.float_array_value ();
+          FloatNDArray y = argy.float_array_value ();
+          get_red_dims (dimx, dimy, dim, dimz, m, n, k);
+          FloatNDArray z (dimz);
+
+          F77_XFCN (sdot3, SDOT3, (m, n, k, x.data (), y.data (),
+                                   z.fortran_vec ()));
+          retval = z;
+        }
+      else
+        {
+          NDArray x = argx.array_value ();
+          NDArray y = argy.array_value ();
+          get_red_dims (dimx, dimy, dim, dimz, m, n, k);
+          NDArray z (dimz);
+
+          F77_XFCN (ddot3, DDOT3, (m, n, k, x.data (), y.data (),
+                                   z.fortran_vec ()));
+          retval = z;
+        }
     }
   else
-    error ("dot: X and Y must be numeric");
+    {
+      // Non-optimized evaluation.
+      octave_value_list tmp;
+      tmp(1) = dim + 1;
+      tmp(0) = do_binary_op (octave_value::op_el_mul, argx, argy);
+
+      tmp = feval ("sum", tmp, 1);
+      if (! tmp.empty ())
+        retval = tmp(0);
+    }
 
   return retval;
 }
 
 /*
 %!assert (dot ([1, 2], [2, 3]), 8)
 
 %!test
@@ -288,104 +280,99 @@ size of @var{B} must be @code{[k,n,@dots
 @group\n\
 for i = 1:prod (size (@var{A})(3:end))\n\
   @var{C}(:,:,i) = @var{A}(:,:,i) * @var{B}(:,:,i)\n\
 endfor\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 2)
     print_usage ();
 
+  octave_value retval;
+
   octave_value argx = args(0);
   octave_value argy = args(1);
 
-  if (argx.is_numeric_type () && argy.is_numeric_type ())
-    {
-      const dim_vector dimx = argx.dims ();
-      const dim_vector dimy = argy.dims ();
-      int nd = dimx.length ();
-      octave_idx_type m = dimx(0);
-      octave_idx_type k = dimx(1);
-      octave_idx_type n = dimy(1);
-      octave_idx_type np = 1;
-      bool match = dimy(0) == k && nd == dimy.length ();
-      dim_vector dimz = dim_vector::alloc (nd);
-      dimz(0) = m;
-      dimz(1) = n;
-      for (int i = 2; match && i < nd; i++)
-        {
-          match = match && dimx(i) == dimy(i);
-          dimz(i) = dimx(i);
-          np *= dimz(i);
-        }
-
-      if (match)
-        {
-          if (argx.is_complex_type () || argy.is_complex_type ())
-            {
-              if (argx.is_single_type () || argy.is_single_type ())
-                {
-                  FloatComplexNDArray x = argx.float_complex_array_value ();
-                  FloatComplexNDArray y = argy.float_complex_array_value ();
-                  FloatComplexNDArray z (dimz);
+  if (! argx.is_numeric_type () || ! argy.is_numeric_type ())
+    error ("blkmm: A and B must be numeric");
 
-                  F77_XFCN (cmatm3, CMATM3, (m, n, k, np,
-                                             x.data (), y.data (),
-                                             z.fortran_vec ()));
-                  retval = z;
-                }
-              else
-                {
-                  ComplexNDArray x = argx.complex_array_value ();
-                  ComplexNDArray y = argy.complex_array_value ();
-                  ComplexNDArray z (dimz);
+  const dim_vector dimx = argx.dims ();
+  const dim_vector dimy = argy.dims ();
+  int nd = dimx.length ();
+  octave_idx_type m = dimx(0);
+  octave_idx_type k = dimx(1);
+  octave_idx_type n = dimy(1);
+  octave_idx_type np = 1;
+  bool match = dimy(0) == k && nd == dimy.length ();
+  dim_vector dimz = dim_vector::alloc (nd);
+  dimz(0) = m;
+  dimz(1) = n;
+  for (int i = 2; match && i < nd; i++)
+    {
+      match = match && dimx(i) == dimy(i);
+      dimz(i) = dimx(i);
+      np *= dimz(i);
+    }
 
-                  F77_XFCN (zmatm3, ZMATM3, (m, n, k, np,
-                                             x.data (), y.data (),
-                                             z.fortran_vec ()));
-                  retval = z;
-                }
-            }
-          else
-            {
-              if (argx.is_single_type () || argy.is_single_type ())
-                {
-                  FloatNDArray x = argx.float_array_value ();
-                  FloatNDArray y = argy.float_array_value ();
-                  FloatNDArray z (dimz);
+  if (! match)
+    error ("blkmm: A and B dimensions don't match: (%s) and (%s)",
+           dimx.str ().c_str (), dimy.str ().c_str ());
 
-                  F77_XFCN (smatm3, SMATM3, (m, n, k, np,
-                                             x.data (), y.data (),
-                                             z.fortran_vec ()));
-                  retval = z;
-                }
-              else
-                {
-                  NDArray x = argx.array_value ();
-                  NDArray y = argy.array_value ();
-                  NDArray z (dimz);
+  if (argx.is_complex_type () || argy.is_complex_type ())
+    {
+      if (argx.is_single_type () || argy.is_single_type ())
+        {
+          FloatComplexNDArray x = argx.float_complex_array_value ();
+          FloatComplexNDArray y = argy.float_complex_array_value ();
+          FloatComplexNDArray z (dimz);
 
-                  F77_XFCN (dmatm3, DMATM3, (m, n, k, np,
-                                             x.data (), y.data (),
-                                             z.fortran_vec ()));
-                  retval = z;
-                }
-            }
+          F77_XFCN (cmatm3, CMATM3, (m, n, k, np,
+                                     x.data (), y.data (),
+                                     z.fortran_vec ()));
+          retval = z;
         }
       else
-        error ("blkmm: A and B dimensions don't match: (%s) and (%s)",
-               dimx.str ().c_str (), dimy.str ().c_str ());
+        {
+          ComplexNDArray x = argx.complex_array_value ();
+          ComplexNDArray y = argy.complex_array_value ();
+          ComplexNDArray z (dimz);
 
+          F77_XFCN (zmatm3, ZMATM3, (m, n, k, np,
+                                     x.data (), y.data (),
+                                     z.fortran_vec ()));
+          retval = z;
+        }
     }
   else
-    error ("blkmm: A and B must be numeric");
+    {
+      if (argx.is_single_type () || argy.is_single_type ())
+        {
+          FloatNDArray x = argx.float_array_value ();
+          FloatNDArray y = argy.float_array_value ();
+          FloatNDArray z (dimz);
+
+          F77_XFCN (smatm3, SMATM3, (m, n, k, np,
+                                     x.data (), y.data (),
+                                     z.fortran_vec ()));
+          retval = z;
+        }
+      else
+        {
+          NDArray x = argx.array_value ();
+          NDArray y = argy.array_value ();
+          NDArray z (dimz);
+
+          F77_XFCN (dmatm3, DMATM3, (m, n, k, np,
+                                     x.data (), y.data (),
+                                     z.fortran_vec ()));
+          retval = z;
+        }
+    }
 
   return retval;
 }
 
 /*
 %!test
 %! x(:,:,1) = [1 2; 3 4];
 %! x(:,:,2) = [1 1; 1 1];
diff --git a/libinterp/corefcn/eig.cc b/libinterp/corefcn/eig.cc
--- a/libinterp/corefcn/eig.cc
+++ b/libinterp/corefcn/eig.cc
@@ -45,55 +45,55 @@ or a pair of matrices\n\
 The algorithm used depends on whether there are one or two input\n\
 matrices, if they are real or complex, and if they are symmetric\n\
 (Hermitian if complex) or non-symmetric.\n\
 \n\
 The eigenvalues returned by @code{eig} are not ordered.\n\
 @seealso{eigs, svd}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   int nargin = args.length ();
 
   if (nargin > 2 || nargin == 0)
     print_usage ();
 
+  octave_value_list retval;
+
   octave_value arg_a, arg_b;
 
   octave_idx_type nr_a, nr_b, nc_a, nc_b;
   nr_a = nr_b = nc_a = nc_b = 0;
 
   arg_a = args(0);
   nr_a = arg_a.rows ();
   nc_a = arg_a.columns ();
 
   int arg_is_empty = empty_arg ("eig", nr_a, nc_a);
   if (arg_is_empty < 0)
     return retval;
   else if (arg_is_empty > 0)
     return octave_value_list (2, Matrix ());
 
-  if (!(arg_a.is_single_type () || arg_a.is_double_type ()))
+  if (! arg_a.is_double_type () && ! arg_a.is_single_type ())
     {
       gripe_wrong_type_arg ("eig", arg_a);
       return retval;
     }
 
   if (nargin == 2)
     {
       arg_b = args(1);
       nr_b = arg_b.rows ();
       nc_b = arg_b.columns ();
 
       arg_is_empty = empty_arg ("eig", nr_b, nc_b);
       if (arg_is_empty < 0)
         return retval;
       else if (arg_is_empty > 0)
-        return octave_value_list (2, Matrix ());
+        return ovl (2, Matrix ());
 
       if (!(arg_b.is_single_type () || arg_b.is_double_type ()))
         {
           gripe_wrong_type_arg ("eig", arg_b);
           return retval;
         }
     }
 
@@ -153,17 +153,16 @@ The eigenvalues returned by @code{eig} a
 
       if (nargout == 0 || nargout == 1)
         {
           retval = ovl (result.eigenvalues ());
         }
       else
         {
           // Blame it on Matlab.
-
           FloatComplexDiagMatrix d (result.eigenvalues ());
 
           retval = ovl (result.eigenvectors (), d);
         }
     }
   else
     {
       EIG result;
@@ -203,17 +202,16 @@ The eigenvalues returned by @code{eig} a
 
       if (nargout == 0 || nargout == 1)
         {
           retval = ovl (result.eigenvalues ());
         }
       else
         {
           // Blame it on Matlab.
-
           ComplexDiagMatrix d (result.eigenvalues ());
 
           retval = ovl (result.eigenvectors (), d);
         }
     }
 
   return retval;
 }
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -906,133 +906,131 @@ error.  Typically @var{err} is returned 
 {
   octave_value retval;
 
   if (args.length () != 1)
     print_usage ();
 
   const octave_scalar_map err = args(0).scalar_map_value ();
 
-  if (err.contains ("message") && err.contains ("identifier"))
-    {
-      std::string msg = err.contents ("message").string_value ();
-      std::string id = err.contents ("identifier").string_value ();
-      int len = msg.length ();
+  if (! err.contains ("message") || ! err.contains ("identifier"))
+    error ("rethrow: ERR structure must contain the fields 'message and 'identifier'");
+
+  std::string msg = err.contents ("message").string_value ();
+  std::string id = err.contents ("identifier").string_value ();
+  int len = msg.length ();
+
+  std::string file;
+  std::string nm;
+  int l = -1;
+  int c = -1;
+
+  octave_map err_stack = initialize_last_error_stack ();
 
-      std::string file;
-      std::string nm;
-      int l = -1;
-      int c = -1;
+  if (err.contains ("stack"))
+    {
+      err_stack = err.contents ("stack").map_value ();
 
-      octave_map err_stack = initialize_last_error_stack ();
+      if (err_stack.numel () > 0)
+        {
+          if (err_stack.contains ("file"))
+            file = err_stack.contents ("file")(0).string_value ();
 
-      if (err.contains ("stack"))
-        {
-          err_stack = err.contents ("stack").map_value ();
+          if (err_stack.contains ("name"))
+            nm = err_stack.contents ("name")(0).string_value ();
+
+          if (err_stack.contains ("line"))
+            l = err_stack.contents ("line")(0).nint_value ();
 
-          if (err_stack.numel () > 0)
-            {
-              if (err_stack.contains ("file"))
-                file = err_stack.contents ("file")(0).string_value ();
-
-              if (err_stack.contains ("name"))
-                nm = err_stack.contents ("name")(0).string_value ();
-
-              if (err_stack.contains ("line"))
-                l = err_stack.contents ("line")(0).nint_value ();
+          if (err_stack.contains ("column"))
+            c = err_stack.contents ("column")(0).nint_value ();
+        }
+    }
 
-              if (err_stack.contains ("column"))
-                c = err_stack.contents ("column")(0).nint_value ();
-            }
+  // Ugh.
+  std::string tmp_msg (msg);
+  if (tmp_msg[len-1] == '\n')
+    {
+      if (len > 1)
+        {
+          tmp_msg.erase (len - 1);
+          rethrow_error (id.c_str (), "%s\n", tmp_msg.c_str ());
         }
+    }
+  else
+    rethrow_error (id.c_str (), "%s", tmp_msg.c_str ());
 
-      // Ugh.
-      std::string tmp_msg (msg);
-      if (tmp_msg[len-1] == '\n')
+  // FIXME: is this the right thing to do for Vlast_error_stack?
+  //        Should it be saved and restored with unwind_protect?
+
+  Vlast_error_stack = err_stack;
+
+  if (err.contains ("stack"))
+    {
+      if (file.empty ())
         {
-          if (len > 1)
+          if (nm.empty ())
             {
-              tmp_msg.erase (len - 1);
-              rethrow_error (id.c_str (), "%s\n", tmp_msg.c_str ());
-            }
-        }
-      else
-        rethrow_error (id.c_str (), "%s", tmp_msg.c_str ());
-
-      // FIXME: is this the right thing to do for Vlast_error_stack?
-      //        Should it be saved and restored with unwind_protect?
-
-      Vlast_error_stack = err_stack;
-
-      if (err.contains ("stack"))
-        {
-          if (file.empty ())
-            {
-              if (nm.empty ())
+              if (l > 0)
                 {
-                  if (l > 0)
-                    {
-                      if (c > 0)
-                        pr_where_1 (std::cerr,
-                                    "error: near line %d, column %d",
-                                    l, c);
-                      else
-                        pr_where_1 (std::cerr, "error: near line %d", l);
-                    }
-                }
-              else
-                {
-                  if (l > 0)
-                    {
-                      if (c > 0)
-                        pr_where_1 (std::cerr,
-                                    "error: called from '%s' near line %d, column %d",
-                                    nm.c_str (), l, c);
-                      else
-                        pr_where_1 (std::cerr,
-                                    "error: called from '%d' near line %d",
-                                    nm.c_str (), l);
-                    }
+                  if (c > 0)
+                    pr_where_1 (std::cerr,
+                                "error: near line %d, column %d",
+                                l, c);
+                  else
+                    pr_where_1 (std::cerr, "error: near line %d", l);
                 }
             }
           else
             {
-              if (nm.empty ())
+              if (l > 0)
                 {
-                  if (l > 0)
-                    {
-                      if (c > 0)
-                        pr_where_1 (std::cerr,
-                                    "error: in file %s near line %d, column %d",
-                                    file.c_str (), l, c);
-                      else
-                        pr_where_1 (std::cerr,
-                                    "error: in file %s near line %d",
-                                    file.c_str (), l);
-                    }
+                  if (c > 0)
+                    pr_where_1 (std::cerr,
+                                "error: called from '%s' near line %d, column %d",
+                                nm.c_str (), l, c);
+                  else
+                    pr_where_1 (std::cerr,
+                                "error: called from '%d' near line %d",
+                                nm.c_str (), l);
                 }
-              else
+            }
+        }
+      else
+        {
+          if (nm.empty ())
+            {
+              if (l > 0)
                 {
-                  if (l > 0)
-                    {
-                      if (c > 0)
-                        pr_where_1 (std::cerr,
-                                    "error: called from '%s' in file %s near line %d, column %d",
-                                    nm.c_str (), file.c_str (), l, c);
-                      else
-                        pr_where_1 (std::cerr,
-                                    "error: called from '%d' in file %s near line %d",
-                                    nm.c_str (), file.c_str (), l);
-                    }
+                  if (c > 0)
+                    pr_where_1 (std::cerr,
+                                "error: in file %s near line %d, column %d",
+                                file.c_str (), l, c);
+                  else
+                    pr_where_1 (std::cerr,
+                                "error: in file %s near line %d",
+                                file.c_str (), l);
+                }
+            }
+          else
+            {
+              if (l > 0)
+                {
+                  if (c > 0)
+                    pr_where_1 (std::cerr,
+                                "error: called from '%s' in file %s near line %d, column %d",
+                                nm.c_str (), file.c_str (), l, c);
+                  else
+                    pr_where_1 (std::cerr,
+                                "error: called from '%d' in file %s near line %d",
+                                nm.c_str (), file.c_str (), l);
                 }
             }
         }
     }
-  else
-    error ("rethrow: ERR structure must contain the fields 'message and 'identifier'");
 
   return retval;
 }
 
 // Determine whether the first argument to error or warning function
 // should be handled as the message identifier or as the format string.
 
 static bool
@@ -1164,27 +1162,28 @@ sequences in @var{template} (e.g., @qcod
 newline) are processed regardless of whether @var{template} has been defined\n\
 with single quotes, as long as there are two or more input arguments.  To\n\
 disable escape sequence expansion use a second backslash before the sequence\n\
 (e.g., @qcode{\"@xbackslashchar{}@xbackslashchar{}n\"}) or use the\n\
 @code{regexptranslate} function.\n\
 @seealso{warning, lasterror}\n\
 @end deftypefn")
 {
-  octave_value retval;
 
   int nargin = args.length ();
 
+  if (nargin == 0)
+    print_usage ();
+
+  octave_value retval;
+
   octave_value_list nargs = args;
 
   std::string id;
 
-  if (nargin == 0)
-    print_usage ();
-
   bool have_fmt = false;
 
   if (nargin == 1 && args(0).is_map ())
     {
       // empty struct is not an error.  return and resume calling function.
       if (args(0).is_empty ())
         return retval;
 
diff --git a/libinterp/corefcn/fft.cc b/libinterp/corefcn/fft.cc
--- a/libinterp/corefcn/fft.cc
+++ b/libinterp/corefcn/fft.cc
@@ -37,42 +37,38 @@ along with Octave; see the file COPYING.
 #define FFTSRC "@sc{fftw}"
 #else
 #define FFTSRC "@sc{fftpack}"
 #endif
 
 static octave_value
 do_fft (const octave_value_list &args, const char *fcn, int type)
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
 
+  octave_value retval;
   octave_value arg = args(0);
   dim_vector dims = arg.dims ();
   octave_idx_type n_points = -1;
   int dim = -1;
 
   if (nargin > 1)
     {
       if (! args(1).is_empty ())
         {
           double dval = args(1).double_value ();
           if (xisnan (dval))
             error ("%s: number of points (N) cannot be NaN", fcn);
-          else
-            {
-              n_points = NINTbig (dval);
-              if (n_points < 0)
-                error ("%s: number of points (N) must be greater than zero",
-                       fcn);
-            }
+
+          n_points = NINTbig (dval);
+          if (n_points < 0)
+            error ("%s: number of points (N) must be greater than zero", fcn);
         }
     }
 
   if (nargin > 2)
     {
       double dval = args(2).double_value ();
       if (xisnan (dval))
         error ("%s: DIM cannot be NaN", fcn);
diff --git a/libinterp/corefcn/fft2.cc b/libinterp/corefcn/fft2.cc
--- a/libinterp/corefcn/fft2.cc
+++ b/libinterp/corefcn/fft2.cc
@@ -39,52 +39,47 @@ along with Octave; see the file COPYING.
 #define FFTSRC "@sc{fftw}"
 #else
 #define FFTSRC "@sc{fftpack}"
 #endif
 
 static octave_value
 do_fft2 (const octave_value_list &args, const char *fcn, int type)
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
 
+  octave_value retval;
   octave_value arg = args(0);
   dim_vector dims = arg.dims ();
   octave_idx_type n_rows = -1;
 
   if (nargin > 1)
     {
       double dval = args(1).double_value ();
       if (xisnan (dval))
         error ("%s: number of rows (N) cannot be NaN", fcn);
-      else
-        {
-          n_rows = NINTbig (dval);
-          if (n_rows < 0)
-            error ("%s: number of rows (N) must be greater than zero", fcn);
-        }
+
+      n_rows = NINTbig (dval);
+      if (n_rows < 0)
+        error ("%s: number of rows (N) must be greater than zero", fcn);
     }
 
   octave_idx_type n_cols = -1;
   if (nargin > 2)
     {
       double dval = args(2).double_value ();
       if (xisnan (dval))
         error ("%s: number of columns (M) cannot be NaN", fcn);
-      else
-        {
-          n_cols = NINTbig (dval);
-          if (n_cols < 0)
-            error ("%s: number of columns (M) must be greater than zero", fcn);
-        }
+
+      n_cols = NINTbig (dval);
+      if (n_cols < 0)
+        error ("%s: number of columns (M) must be greater than zero", fcn);
     }
 
   for (int i = 0; i < dims.length (); i++)
     if (dims(i) < 0)
       return retval;
 
   if (n_rows < 0)
     n_rows = dims(0);
diff --git a/libinterp/corefcn/fftn.cc b/libinterp/corefcn/fftn.cc
--- a/libinterp/corefcn/fftn.cc
+++ b/libinterp/corefcn/fftn.cc
@@ -38,53 +38,47 @@ along with Octave; see the file COPYING.
 #define FFTSRC "@sc{fftw}"
 #else
 #define FFTSRC "@sc{fftpack}"
 #endif
 
 static octave_value
 do_fftn (const octave_value_list &args, const char *fcn, int type)
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
+  octave_value retval;
   octave_value arg = args(0);
   dim_vector dims = arg.dims ();
 
   for (int i = 0; i < dims.length (); i++)
     if (dims(i) < 0)
       return retval;
 
   if (nargin > 1)
     {
       Matrix val = args(1).xmatrix_value ("%s: SIZE must be a vector of length dim", fcn);
 
       if (val.rows () > val.columns ())
         val = val.transpose ();
 
       if (val.columns () != dims.length () || val.rows () != 1)
         error ("%s: SIZE must be a vector of length dim", fcn);
-      else
+
+      for (int i = 0; i < dims.length (); i++)
         {
-          for (int i = 0; i < dims.length (); i++)
-            {
-              if (xisnan (val(i,0)))
-                error ("%s: SIZE has invalid NaN entries", fcn);
-              else if (NINTbig (val(i,0)) < 0)
-                error ("%s: all dimensions in SIZE must be greater than zero",
-                       fcn);
-              else
-                {
-                  dims(i) = NINTbig(val(i,0));
-                }
-            }
+          if (xisnan (val(i,0)))
+            error ("%s: SIZE has invalid NaN entries", fcn);
+          else if (NINTbig (val(i,0)) < 0)
+            error ("%s: all dimensions in SIZE must be greater than zero", fcn);
+          else
+            dims(i) = NINTbig(val(i,0));
         }
     }
 
   if (dims.all_zero ())
     {
       if (arg.is_single_type ())
         return octave_value (FloatMatrix ());
       else
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -253,28 +253,26 @@ with gnuplot.\n\
 DEFUN (fclear, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} fclear (@var{fid})\n\
 Clear the stream state for the file specified by the file descriptor\n\
 @var{fid}.\n\
 @seealso{ferror, fopen}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 1)
     print_usage ();
 
   int fid = octave_stream_list::get_file_number (args(0));
 
   octave_stream os = octave_stream_list::lookup (fid, "fclear");
 
   os.clearerr ();
 
-  return retval;
+  return octave_value_list ();
 }
 
 DEFUN (fflush, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} fflush (@var{fid})\n\
 Flush output to file descriptor @var{fid}.\n\
 \n\
 @code{fflush} returns 0 on success and an OS dependent error value\n\
@@ -282,23 +280,22 @@ Flush output to file descriptor @var{fid
 \n\
 Programming Note: Flushing is useful for ensuring that all pending output\n\
 makes it to the screen before some other event occurs.  For example, it is\n\
 always a good idea to flush the standard output stream before calling\n\
 @code{input}.\n\
 @seealso{fopen, fclose}\n\
 @end deftypefn")
 {
-  octave_value retval = -1;
-
   if (args.length () != 1)
     print_usage ();
 
+  octave_value retval = -1;
+
   // FIXME: any way to avoid special case for stdout?
-
   int fid = octave_stream_list::get_file_number (args(0));
 
   if (fid == 1)
     {
       flush_octave_stdout ();
 
       retval = 0;
     }
@@ -327,39 +324,33 @@ If @var{len} is omitted, @code{fgetl} re
 If there are no more characters to read, @code{fgetl} returns @minus{}1.\n\
 \n\
 To read a line and return the terminating newline see @code{fgets}.\n\
 @seealso{fgets, fscanf, fread, fopen}\n\
 @end deftypefn")
 {
   static std::string who = "fgetl";
 
-  octave_value_list retval;
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
-  retval = ovl (-1, 0);
-
   octave_stream os = octave_stream_list::lookup (args(0), who);
 
   octave_value len_arg = (nargin == 2) ? args(1) : octave_value ();
 
   bool err = false;
 
   std::string tmp = os.getl (len_arg, err, who);
 
   if (! err)
-    {
-      retval = ovl (tmp, tmp.length ());
-    }
-
-  return retval;
+    return ovl (tmp, tmp.length ());
+  else
+    return ovl (-1, 0);
 }
 
 DEFUN (fgets, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{str} =} fgets (@var{fid})\n\
 @deftypefnx {} {@var{str} =} fgets (@var{fid}, @var{len})\n\
 Read characters from a file, stopping after a newline, or EOF,\n\
 or @var{len} characters have been read.\n\
@@ -372,39 +363,33 @@ If @var{len} is omitted, @code{fgets} re
 If there are no more characters to read, @code{fgets} returns @minus{}1.\n\
 \n\
 To read a line and discard the terminating newline see @code{fgetl}.\n\
 @seealso{fputs, fgetl, fscanf, fread, fopen}\n\
 @end deftypefn")
 {
   static std::string who = "fgets";
 
-  octave_value_list retval;
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
-  retval = ovl (-1.0, 0.0);
-
   octave_stream os = octave_stream_list::lookup (args(0), who);
 
   octave_value len_arg = (nargin == 2) ? args(1) : octave_value ();
 
   bool err = false;
 
   std::string tmp = os.gets (len_arg, err, who);
 
   if (! err)
-    {
-      retval = ovl (tmp, tmp.length ());
-    }
-
-  return retval;
+    return ovl (tmp, tmp.length ());
+  else
+    return ovl (-1.0, 0.0);
 }
 
 DEFUN (fskipl, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{nlines} =} fskipl (@var{fid})\n\
 @deftypefnx {} {@var{nlines} =} fskipl (@var{fid}, @var{count})\n\
 @deftypefnx {} {@var{nlines} =} fskipl (@var{fid}, Inf)\n\
 Read and skip @var{count} lines from the file specified by the file\n\
@@ -418,35 +403,33 @@ If @var{count} is omitted, it defaults t
 This form is suitable for counting the number of lines in a file.\n\
 \n\
 Returns the number of lines skipped (end-of-line sequences encountered).\n\
 @seealso{fgetl, fgets, fscanf, fopen}\n\
 @end deftypefn")
 {
   static std::string who = "fskipl";
 
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   octave_stream os = octave_stream_list::lookup (args(0), who);
 
   octave_value count_arg = (nargin == 2) ? args(1) : octave_value ();
 
   bool err = false;
 
   off_t tmp = os.skipl (count_arg, err, who);
 
   if (! err)
-    retval = tmp;
-
-  return retval;
+    return ovl (tmp);
+  else
+    return octave_value_list ();
 }
 
 
 static octave_stream
 do_stream_open (const std::string& name, const std::string& mode_arg,
                 const std::string& arch, int& fid)
 {
   octave_stream retval;
@@ -616,34 +599,31 @@ IEEE little endian format.\n\
 However, conversions are currently only supported for @samp{native},\n\
 @samp{ieee-be}, and @samp{ieee-le} formats.\n\
 \n\
 When opening a new file that does not yet exist, permissions will be set to\n\
 @code{0666 - @var{umask}}.\n\
 @seealso{fclose, fgets, fgetl, fscanf, fread, fputs, fdisp, fprintf, fwrite, fskipl, fseek, frewind, ftell, feof, ferror, fclear, fflush, freport, umask}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
-  retval = ovl (-1.0);
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
 
+  octave_value_list retval = ovl (-1.0);
+
   if (nargin == 1)
     {
       if (args(0).is_string ())
         {
           // If there is only one argument and it is a string but it
           // is not the string "all", we assume it is a file to open
           // with MODE = "r".  To open a file called "all", you have
           // to supply more than one argument.
-
           if (nargout < 2 && args(0).string_value () == "all")
             return octave_stream_list::open_file_numbers ();
         }
       else
         {
           string_vector tmp = octave_stream_list::get_info (args(0));
 
           retval = ovl (tmp(0), tmp(1), tmp(2));
@@ -658,19 +638,17 @@ When opening a new file that does not ye
   octave_value arch = (nargin == 3)
                       ? args(2) : octave_value ("native");
 
   int fid = -1;
 
   octave_stream os = do_stream_open (args(0), mode, arch, "fopen", fid);
 
   if (os)
-    {
-      retval = ovl (octave_stream_list::insert (os), "");
-    }
+    retval = ovl (octave_stream_list::insert (os), "");
   else
     {
       int error_number = 0;
 
       retval = ovl (-1.0, os.error (false, error_number));
     }
 
   return retval;
@@ -716,31 +694,29 @@ DEFUN (frewind, args, nargout,
 Move the file pointer to the beginning of the file specified by file\n\
 descriptor @var{fid}.\n\
 \n\
 @code{frewind} returns 0 for success, and -1 if an error is encountered.  It\n\
 is equivalent to @code{fseek (@var{fid}, 0, SEEK_SET)}.\n\
 @seealso{fseek, ftell, fopen}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   if (args.length () != 1)
     print_usage ();
 
   int result = -1;
 
   octave_stream os = octave_stream_list::lookup (args(0), "frewind");
 
   result = os.rewind ();
 
   if (nargout > 0)
-    retval = result;
-
-  return retval;
+    return ovl (result);
+  else
+    return octave_value_list ();
 }
 
 DEFUN (fseek, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} fseek (@var{fid}, @var{offset})\n\
 @deftypefnx {} {} fseek (@var{fid}, @var{offset}, @var{origin})\n\
 @deftypefnx {} {@var{status} =} fseek (@dots{})\n\
 Set the file pointer to the location @var{offset} within the file @var{fid}.\n\
@@ -752,51 +728,42 @@ file) or strings @qcode{\"cof\"}, @qcode
 @var{origin} is omitted, @w{@code{SEEK_SET}} is assumed.  @var{offset} may\n\
 be positive, negative, or zero but not all combinations of @var{origin} and\n\
 @var{offset} can be realized.\n\
 \n\
 @code{fseek} returns 0 on success and -1 on error.\n\
 @seealso{fskipl, frewind, ftell, fopen}\n\
 @end deftypefn")
 {
-  octave_value retval = -1;
-
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
 
   octave_stream os = octave_stream_list::lookup (args(0), "fseek");
 
-  octave_value origin_arg = (nargin == 3)
-    ? args(2) : octave_value (-1.0);
+  octave_value origin_arg = (nargin == 3) ? args(2) : octave_value (-1.0);
 
-  retval = os.seek (args(1), origin_arg);
-
-  return retval;
+  return octave_value (os.seek (args(1), origin_arg));
 }
 
 DEFUN (ftell, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {@var{pos} =} ftell (@var{fid})\n\
 Return the position of the file pointer as the number of characters from the\n\
 beginning of the file specified by file descriptor @var{fid}.\n\
 @seealso{fseek, frewind, feof, fopen}\n\
 @end deftypefn")
 {
-  octave_value retval = -1;
-
   if (args.length () != 1)
     print_usage ();
 
   octave_stream os = octave_stream_list::lookup (args(0), "ftell");
 
-  retval = os.tell ();
-
-  return retval;
+  return octave_value (os.tell ());
 }
 
 DEFUN (fprintf, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} fprintf (@var{fid}, @var{template}, @dots{})\n\
 @deftypefnx {} {} fprintf (@var{template}, @dots{})\n\
 @deftypefnx {} {@var{numbytes} =} fprintf (@dots{})\n\
 This function is equivalent to @code{printf}, except that the output is\n\
@@ -810,59 +777,53 @@ The optional output returns the number o
 Implementation Note: For compatibility with @sc{matlab}, escape sequences in\n\
 the template string (e.g., @qcode{\"@xbackslashchar{}n\"} => newline) are\n\
 expanded even when the template string is defined with single quotes.\n\
 @seealso{fputs, fdisp, fwrite, fscanf, printf, sprintf, fopen}\n\
 @end deftypefn")
 {
   static std::string who = "fprintf";
 
-  octave_value retval;
-
-  int result = -1;
-
   int nargin = args.length ();
 
   if (! (nargin > 1 || (nargin > 0 && args(0).is_string ())))
     print_usage ();
 
+  int result;
+
   octave_stream os;
   int fmt_n = 0;
 
   if (args(0).is_string ())
-    {
-      os = octave_stream_list::lookup (1, who);
-    }
+    os = octave_stream_list::lookup (1, who);
   else
     {
       fmt_n = 1;
       os = octave_stream_list::lookup (args(0), who);
     }
 
-  if (args(fmt_n).is_string ())
-    {
-      octave_value_list tmp_args;
-
-      if (nargin > 1 + fmt_n)
-        {
-          tmp_args.resize (nargin-fmt_n-1, octave_value ());
-
-          for (int i = fmt_n + 1; i < nargin; i++)
-            tmp_args(i-fmt_n-1) = args(i);
-        }
-
-      result = os.printf (args(fmt_n), tmp_args, who);
-    }
-  else
+  if (! args(fmt_n).is_string ())
     error ("%s: format TEMPLATE must be a string", who.c_str ());
 
+  octave_value_list tmp_args;
+
+  if (nargin > 1 + fmt_n)
+    {
+      tmp_args.resize (nargin-fmt_n-1, octave_value ());
+
+      for (int i = fmt_n + 1; i < nargin; i++)
+        tmp_args(i-fmt_n-1) = args(i);
+    }
+
+  result = os.printf (args(fmt_n), tmp_args, who);
+
   if (nargout > 0)
-    retval = result;
-
-  return retval;
+    return octave_value (result);
+  else
+    return octave_value_list ();
 }
 
 DEFUN (printf, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn {} {} printf (@var{template}, @dots{})\n\
 Print optional arguments under the control of the template string\n\
 @var{template} to the stream @code{stdout} and return the number of\n\
 characters printed.\n\
@@ -875,46 +836,42 @@ complete description of the syntax of th
 Implementation Note: For compatibility with @sc{matlab}, escape sequences in\n\
 the template string (e.g., @qcode{\"@xbackslashchar{}n\"} => newline) are\n\
 expanded even when the template string is defined with single quotes.\n\
 @seealso{fprintf, sprintf, scanf}\n\
 @end deftypefn")
 {
   static std::string who = "printf";
 
-  octave_value retval;
-
-  int result = -1;
-
   int nargin = args.length ();
 
   if (nargin == 0)
     print_usage ();
 
-  if (args(0).is_string ())
-    {
-      octave_value_list tmp_args;
-
-      if (nargin > 1)
-        {
-          tmp_args.resize (nargin-1, octave_value ());
+  int result;
 
-          for (int i = 1; i < nargin; i++)
-            tmp_args(i-1) = args(i);
-        }
-
-      result = stdout_stream.printf (args(0), tmp_args, who);
-    }
-  else
+  if (! args(0).is_string ())
     error ("%s: format TEMPLATE must be a string", who.c_str ());
 
+  octave_value_list tmp_args;
+
+  if (nargin > 1)
+    {
+      tmp_args.resize (nargin-1, octave_value ());
+
+      for (int i = 1; i < nargin; i++)
+        tmp_args(i-1) = args(i);
+    }
+
+  result = stdout_stream.printf (args(0), tmp_args, who);
+
   if (nargout > 0)
-    retval = result;
-
-  return retval;
+    return ovl (result);
+  else
+    return octave_value_list ();
 }
 
 DEFUN (fputs, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} fputs (@var{fid}, @var{string})\n\
 @deftypefnx {} {@var{status} =} fputs (@var{fid}, @var{string})\n\
 Write the string @var{string} to the file with file descriptor @var{fid}.\n\
 \n\
@@ -1063,53 +1020,49 @@ conversions is returned in @var{count}\n
 See the Formatted Input section of the GNU Octave manual for a\n\
 complete description of the syntax of the template string.\n\
 @end ifclear\n\
 @seealso{fgets, fgetl, fread, scanf, sscanf, fopen}\n\
 @end deftypefn")
 {
   static std::string who = "fscanf";
 
-  octave_value_list retval;
-
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
 
+  octave_value_list retval;
+
   if (nargin == 3 && args(2).is_string ())
     {
       octave_stream os = octave_stream_list::lookup (args(0), who);
 
-      if (args(1).is_string ())
-        retval = ovl (os.oscanf (args(1), who));
-      else
+      if (! args(1).is_string ())
         error ("%s: format TEMPLATE must be a string", who.c_str ());
+
+      retval = ovl (os.oscanf (args(1), who));
     }
   else
     {
-      retval = ovl (Matrix (), 0.0, "unknown error");
-
       octave_stream os = octave_stream_list::lookup (args(0), who);
 
-      if (args(1).is_string ())
-        {
-          octave_idx_type count = 0;
+      if (! args(1).is_string ())
+        error ("%s: format must be a string", who.c_str ());
+
+      octave_idx_type count = 0;
 
-          Array<double> size = (nargin == 3)
-            ? args(2).vector_value ()
-            : Array<double> (dim_vector (1, 1),
-                             lo_ieee_inf_value ());
+      Array<double> size = (nargin == 3)
+        ? args(2).vector_value ()
+        : Array<double> (dim_vector (1, 1),
+                         lo_ieee_inf_value ());
 
-          octave_value tmp = os.scanf (args(1), size, count, who);
+      octave_value tmp = os.scanf (args(1), size, count, who);
 
-          retval = ovl (tmp, count, os.error ());
-        }
-      else
-        error ("%s: format must be a string", who.c_str ());
+      retval = ovl (tmp, count, os.error ());
     }
 
   return retval;
 }
 
 static std::string
 get_sscanf_data (const octave_value& val)
 {
@@ -1137,75 +1090,64 @@ string @var{string} instead of from a st
 Reaching the end of the string is treated as an end-of-file condition.  In\n\
 addition to the values returned by @code{fscanf}, the index of the next\n\
 character to be read is returned in @var{pos}.\n\
 @seealso{fscanf, scanf, sprintf}\n\
 @end deftypefn")
 {
   static std::string who = "sscanf";
 
-  octave_value_list retval;
-
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
 
+  octave_value_list retval;
+
   if (nargin == 3 && args(2).is_string ())
     {
       std::string data = get_sscanf_data (args(0));
 
       octave_stream os = octave_istrstream::create (data);
 
-      if (os.is_valid ())
-        {
-          if (args(1).is_string ())
-            retval = ovl (os.oscanf (args(1), who));
-          else
-            error ("%s: format TEMPLATE must be a string", who.c_str ());
-        }
-      else
+      if (! os.is_valid ())
         error ("%s: unable to create temporary input buffer", who.c_str ());
+
+      if (! args(1).is_string ())
+        error ("%s: format TEMPLATE must be a string", who.c_str ());
+
+      retval = ovl (os.oscanf (args(1), who));
     }
   else
     {
-      retval = ovl (Matrix (), 0.0, "unknown error", -1.0);
-
       std::string data = get_sscanf_data (args(0));
 
       octave_stream os = octave_istrstream::create (data);
 
-      if (os.is_valid ())
-        {
-          if (args(1).is_string ())
-            {
-              octave_idx_type count = 0;
+      if (! os.is_valid ())
+        error ("%s: unable to create temporary input buffer", who.c_str ());
 
-              Array<double> size = (nargin == 3)
-                ? args(2).vector_value ()
-                : Array<double> (dim_vector (1, 1),
-                                 lo_ieee_inf_value ());
+      if (! args(1).is_string ())
+        error ("%s: format TEMPLATE must be a string", who.c_str ());
 
-              octave_value tmp = os.scanf (args(1), size, count, who);
+      octave_idx_type count = 0;
 
-              // FIXME: is this the right thing to do?
-              // Extract error message first, because getting
-              // position will clear it.
-              std::string errmsg = os.error ();
+      Array<double> size = (nargin == 3) ? args(2).vector_value ()
+                                         : Array<double> (dim_vector (1, 1),
+                                                          lo_ieee_inf_value ());
+
+      octave_value tmp = os.scanf (args(1), size, count, who);
 
-              retval = ovl (tmp, count, errmsg,
-                            (os.eof () ? data.length () : os.tell ()) + 1);
-            }
-          else
-            error ("%s: format TEMPLATE must be a string",
-                   who.c_str ());
-        }
-      else
-        error ("%s: unable to create temporary input buffer",
-               who.c_str  ());
+      // FIXME: is this the right thing to do?
+      // Extract error message first, because getting
+      // position will clear it.
+      std::string errmsg = os.error ();
+
+      retval = ovl (tmp, count, errmsg,
+                    (os.eof () ? data.length () : os.tell ()) + 1);
     }
 
   return retval;
 }
 
 DEFUN (scanf, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {[@var{val}, @var{count}, @var{errmsg}] =} scanf (@var{template}, @var{size})\n\
@@ -1438,25 +1380,21 @@ created the file descriptor is used.  Ot
 @code{fread} overrides that of @code{fopen} and determines the data format.\n\
 \n\
 The output argument @var{val} contains the data read from the file.\n\
 \n\
 The optional return value @var{count} contains the number of elements read.\n\
 @seealso{fwrite, fgets, fgetl, fscanf, fopen}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 5)
     print_usage ();
 
-  retval = ovl (Matrix (), -1.0);
-
   octave_stream os = octave_stream_list::lookup (args(0), "fread");
 
   octave_value size = lo_ieee_inf_value ();
   octave_value prec = "uchar";
   octave_value skip = 0;
   octave_value arch = "unknown";
 
   int idx = 1;
@@ -1477,19 +1415,17 @@ The optional return value @var{count} co
       arch = skip;
       skip = 0;
     }
 
   octave_idx_type count = -1;
 
   octave_value tmp = do_fread (os, size, prec, skip, arch, count);
 
-  retval = ovl (tmp, count);
-
-  return retval;
+  return ovl (tmp, count);
 }
 
 static int
 do_fwrite (octave_stream& os, const octave_value& data,
            const octave_value& prec_arg, const octave_value& skip_arg,
            const octave_value& arch_arg)
 {
   std::string prec = prec_arg.xstring_value ("fwrite: PRECISION must be a string");
@@ -1615,18 +1551,16 @@ state on the stream will be cleared.\n\
 The optional second output is a numeric indication of the error status.\n\
 @var{err} is 1 if an error condition has been encountered and 0 otherwise.\n\
 \n\
 Note that @code{ferror} indicates if an error has already occurred, not\n\
 whether the next operation will result in an error condition.\n\
 @seealso{fclear, fopen}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   octave_stream os = octave_stream_list::lookup (args(0), "ferror");
 
   bool clear = false;
@@ -1637,19 +1571,17 @@ whether the next operation will result i
 
       clear = (opt == "clear");
     }
 
   int error_number = 0;
 
   std::string error_message = os.error (clear, error_number);
 
-  retval = ovl (error_message, error_number);
-
-  return retval;
+  return ovl (error_message, error_number);
 }
 
 DEFUNX ("popen", Fpopen, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {@var{fid} =} popen (@var{command}, @var{mode})\n\
 Start a process and create a pipe.\n\
 \n\
 The name of the command to run is given by @var{command}.  The argument\n\
@@ -1680,24 +1612,24 @@ endwhile\n\
    @print{} drwxr-xr-x  33 root  root  3072 Feb 15 13:28 etc\n\
    @print{} drwxr-xr-x   3 root  root  1024 Feb 15 13:28 lib\n\
    @print{} drwxrwxrwt  15 root  root  2048 Feb 17 14:53 tmp\n\
 @end group\n\
 @end example\n\
 @seealso{popen2}\n\
 @end deftypefn")
 {
-  octave_value retval = -1;
-
   if (args.length () != 2)
     print_usage ();
 
   std::string name = args(0).xstring_value ("popen: COMMAND must be a string");
   std::string mode = args(1).xstring_value ("popen: MODE must be a string");
 
+  octave_value retval;
+
   if (mode == "r")
     {
       octave_stream ips = octave_iprocstream::create (name);
 
       retval = octave_stream_list::insert (ips);
     }
   else if (mode == "w")
     {
@@ -1741,18 +1673,16 @@ otherwise the default directory for temp
 \n\
 Programming Note: Because the named file is not opened by @code{tempname},\n\
 it is possible, though relatively unlikely, that it will not be available\n\
 by the time your program attempts to open it.  If this is a concern,\n\
 see @code{tmpfile}.\n\
 @seealso{mkstemp, tempdir, P_tmpdir, tmpfile}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin > 2)
     print_usage ();
 
   std::string dir;
 
   if (nargin > 0)
@@ -1824,38 +1754,35 @@ The file is opened in binary read/write 
 deleted automatically when it is closed or when Octave exits.\n\
 \n\
 If successful, @var{fid} is a valid file ID and @var{msg} is an empty\n\
 string.  Otherwise, @var{fid} is -1 and @var{msg} contains a\n\
 system-dependent error message.\n\
 @seealso{tempname, mkstemp, tempdir, P_tmpdir}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 0)
     print_usage ();
 
-  retval = ovl (-1, std::string ());
+  octave_value_list retval;
 
   FILE *fid = gnulib::tmpfile ();
 
   if (fid)
     {
       std::string nm;
 
       std::ios::openmode md = fopen_mode_to_ios_mode ("w+b");
 
       octave_stream s = octave_stdiostream::create (nm, fid, md);
 
-      if (s)
-        retval = ovl (octave_stream_list::insert (s));
-      else
+      if (! s)
         error ("tmpfile: failed to create octave_stdiostream object");
 
+      retval = ovl (octave_stream_list::insert (s), "");
     }
   else
     {
       retval = ovl (-1, gnulib::strerror (errno));
     }
 
   return retval;
 }
@@ -1979,41 +1906,32 @@ interpreted as an octal number); otherwi
 The permission mask is a UNIX concept used when creating new objects on a\n\
 file system such as files, directories, or named FIFOs.  The object to be\n\
 created has base permissions in an octal number @var{mode} which are\n\
 modified according to the octal value of @var{mask}.  The final permissions\n\
 for the new object are @code{@var{mode} - @var{mask}}.\n\
 @seealso{fopen, mkdir, mkfifo}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
-  int status = 0;
-
   if (args.length () != 1)
     print_usage ();
 
   int mask = args(0).xint_value ("umask: MASK must be an integer");
 
   if (mask < 0)
-    {
-      status = -1;
-      error ("umask: MASK must be a positive integer value");
-    }
-  else
-    {
-      int oct_mask = convert (mask, 8, 10);
+    error ("umask: MASK must be a positive integer value");
 
-      status = convert (octave_umask (oct_mask), 10, 8);
-    }
+  int oct_mask = convert (mask, 8, 10);
+
+  int status = convert (octave_umask (oct_mask), 10, 8);
 
   if (status >= 0)
-    retval = ovl (status);
-
-  return retval;
+    return ovl (status);
+  else
+    return octave_value_list ();
 }
 
 static octave_value
 const_value (const char *, const octave_value_list& args, int val)
 {
   if (args.length () != 0)
     print_usage ();
 
diff --git a/libinterp/octave-value/ov-type-conv.h b/libinterp/octave-value/ov-type-conv.h
--- a/libinterp/octave-value/ov-type-conv.h
+++ b/libinterp/octave-value/ov-type-conv.h
@@ -71,36 +71,36 @@ octave_type_conv_body (const octave_valu
     }
 
   return retval;
 }
 
 
 #define OCTAVE_TYPE_CONV_BODY3(NAME, MATRIX_RESULT_T, SCALAR_RESULT_T) \
  \
-  octave_value retval; \
- \
   if (args.length () != 1) \
     print_usage (); \
  \
+  octave_value retval; \
+ \
   const octave_value arg = args(0); \
  \
   int t_result = MATRIX_RESULT_T::static_type_id (); \
  \
   retval = octave_type_conv_body (arg, #NAME, t_result); \
   if (retval.is_undefined ()) \
     { \
       std::string arg_tname = arg.type_name (); \
  \
       std::string result_tname = arg.numel () == 1 \
         ? SCALAR_RESULT_T::static_type_name () \
         : MATRIX_RESULT_T::static_type_name (); \
  \
       gripe_invalid_conversion (arg_tname, result_tname); \
     } \
  \
-  return retval
+  return retval;
 
 #define OCTAVE_TYPE_CONV_BODY(NAME) \
   OCTAVE_TYPE_CONV_BODY3 (NAME, octave_ ## NAME ## _matrix, \
                           octave_ ## NAME ## _scalar)
 
 #endif
