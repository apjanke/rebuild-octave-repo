# HG changeset patch
# User Rik <rik@octave.org>
# Date 1438873741 25200
#      Thu Aug 06 08:09:01 2015 -0700
# Node ID 7ac907da9fba7f72eaee01cd9759bee1c9798dfc
# Parent  d5b877b86ed4ef5222d16fb59e7e009dc0b5350f
Use error() rather than ::error() unless explicitly required.

* resource-manager.cc (instance_ok), shortcut-manager.cc (instance_ok),
daspk.cc (DASPK_ABORT, DASPK_ABORT2), dasrt.cc (DASRT_ABORT, DASRT_ABORT2),
dassl.cc (DASSL_ABORT, DASSL_ABORT2), debug.cc (instance_ok),
display.cc (instance_ok), dynamic-ld.cc (octave_shlib_list::instance_ok,
octave_dynamic_loader::instance_ok, do_load_oct, do_load_mex), file-io.cc
(fopen_mode_to_ios_mode, do_stream_open, Ffprintf, Fsprintf, Fscanf, Ffscanf,
get_sscanf_data, Fsscanf, do_fread, do_fwrite, Fpopen, Ftempname, convert,
Fumask), graphics.in.h (graphics_toolkit::instance_ok,
gh_manager::instance_ok), load-path.cc (instance_ok),
ls-oct-ascii.cc (save_three_d), lsode.cc (LSODE_ABORT, LSODE_ABORT2),
oct-errno.in.cc (instance_ok), octave-link.cc (connect_link),
pager.cc (octave_pager_stream::instance_ok, octave_diary_stream::instance_ok),
quad.cc (QUAD_ABORT, QUAD_ABORT2),
sighandlers.cc (w32_interrupt_manager::instance_ok,
octave_child_list::instance_ok), symtab.cc (do_update_nest),
symtab.h (instance_ok), syscalls.cc (convert), toplev.h (instance_ok),
txt-eng-ft.cc (instance_ok, set_mode), urlwrite.cc (instance_ok),
__init_fltk__.cc (instance_ok), ov-builtin.cc (do_multi_index_op),
ov-classdef.cc (class_fevalStatic, make_class, octave_classdef::subsasgn,
do_multi_index_op, cdef_object_array::subsref, cdef_object_array::subsasgn,
install_meth, meta_subsref, run_constructor, make_meta_class, get_value,
set_value, check_method), ov-classdef.h (meta_subsref, instance_ok),
ov-fcn-handle.cc (octave_fcn_handle), ov-mex-fcn.cc (do_multi_index_op),
ov-range.h (octave_range), ov-typeinfo.cc (instance_ok),
ov-usr-fcn.cc (subsref, do_multi_index_op), pt-arg-list.cc (Fend,
convert_to_const_vector), pt-cell.cc (rvalue1), pt-colon.cc (append, rvalue1),
pt-eval.cc (visit_simple_for_command, visit_switch_command),
pt-exp.cc (is_logically_true, rvalue), pt-id.cc (eval_undefined_error),
pt-id.h (workspace_error), pt-mat.cc (get_concat_class):
Use error() rather than ::error().

diff --git a/libgui/src/resource-manager.cc b/libgui/src/resource-manager.cc
--- a/libgui/src/resource-manager.cc
+++ b/libgui/src/resource-manager.cc
@@ -139,17 +139,17 @@ resource_manager::instance_ok (void)
       instance = new resource_manager ();
 
       if (instance)
         singleton_cleanup_list::add (cleanup_instance);
     }
 
   if (! instance)
     {
-      ::error ("unable to create resource_manager object!");
+      error ("unable to create resource_manager object!");
 
       retval = false;
     }
 
   return retval;
 }
 
 QSettings *
diff --git a/libgui/src/shortcut-manager.cc b/libgui/src/shortcut-manager.cc
--- a/libgui/src/shortcut-manager.cc
+++ b/libgui/src/shortcut-manager.cc
@@ -70,17 +70,17 @@ shortcut_manager::instance_ok (void)
       instance = new shortcut_manager ();
 
       if (instance)
         singleton_cleanup_list::add (cleanup_instance);
     }
 
   if (! instance)
     {
-      ::error ("unable to create shortcut_manager object!");
+      error ("unable to create shortcut_manager object!");
 
       retval = false;
     }
 
   return retval;
 }
 
 void
diff --git a/libinterp/corefcn/daspk.cc b/libinterp/corefcn/daspk.cc
--- a/libinterp/corefcn/daspk.cc
+++ b/libinterp/corefcn/daspk.cc
@@ -152,25 +152,25 @@ daspk_user_jacobian (const ColumnVector&
 }
 
 #define DASPK_ABORT() \
   return retval
 
 #define DASPK_ABORT1(msg) \
   do \
     { \
-      ::error ("daspk: " msg); \
+      error ("daspk: " msg); \
       DASPK_ABORT (); \
     } \
   while (0)
 
 #define DASPK_ABORT2(fmt, arg) \
   do \
     { \
-      ::error ("daspk: " fmt, arg); \
+      error ("daspk: " fmt, arg); \
       DASPK_ABORT (); \
     } \
   while (0)
 
 DEFUN (daspk, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{x}, @var{xdot}, @var{istate}, @var{msg}] =} daspk (@var{fcn}, @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\n\
 Solve the set of differential-algebraic equations\n\
diff --git a/libinterp/corefcn/dasrt.cc b/libinterp/corefcn/dasrt.cc
--- a/libinterp/corefcn/dasrt.cc
+++ b/libinterp/corefcn/dasrt.cc
@@ -188,25 +188,25 @@ dasrt_user_j (const ColumnVector& x, con
 }
 
 #define DASRT_ABORT \
   return retval
 
 #define DASRT_ABORT1(msg) \
   do \
     { \
-      ::error ("dasrt: " msg); \
+      error ("dasrt: " msg); \
       DASRT_ABORT; \
     } \
   while (0)
 
 #define DASRT_ABORT2(fmt, arg) \
   do \
     { \
-      ::error ("dasrt: " fmt, arg); \
+      error ("dasrt: " fmt, arg); \
       DASRT_ABORT; \
     } \
   while (0)
 
 DEFUN (dasrt, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{x}, @var{xdot}, @var{t_out}, @var{istat}, @var{msg}] =} dasrt (@var{fcn}, [], @var{x_0}, @var{xdot_0}, @var{t})\n\
 @deftypefnx {Built-in Function} {@dots{} =} dasrt (@var{fcn}, @var{g}, @var{x_0}, @var{xdot_0}, @var{t})\n\
diff --git a/libinterp/corefcn/dassl.cc b/libinterp/corefcn/dassl.cc
--- a/libinterp/corefcn/dassl.cc
+++ b/libinterp/corefcn/dassl.cc
@@ -152,25 +152,25 @@ dassl_user_jacobian (const ColumnVector&
 }
 
 #define DASSL_ABORT() \
   return retval
 
 #define DASSL_ABORT1(msg) \
   do \
     { \
-      ::error ("dassl: " msg); \
+      error ("dassl: " msg); \
       DASSL_ABORT (); \
     } \
   while (0)
 
 #define DASSL_ABORT2(fmt, arg) \
   do \
     { \
-      ::error ("dassl: " fmt, arg); \
+      error ("dassl: " fmt, arg); \
       DASSL_ABORT (); \
     } \
   while (0)
 
 DEFUN (dassl, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{x}, @var{xdot}, @var{istate}, @var{msg}] =} dassl (@var{fcn}, @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\n\
 Solve the set of differential-algebraic equations\n\
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -287,17 +287,17 @@ bp_table::instance_ok (void)
       instance = new bp_table ();
 
       if (instance)
         singleton_cleanup_list::add (cleanup_instance);
     }
 
   if (! instance)
     {
-      ::error ("unable to create breakpoint table!");
+      error ("unable to create breakpoint table!");
       retval = false;
     }
 
   return retval;
 }
 
 bool
 bp_table::do_add_breakpoint_1 (octave_user_code *fcn,
diff --git a/libinterp/corefcn/display.cc b/libinterp/corefcn/display.cc
--- a/libinterp/corefcn/display.cc
+++ b/libinterp/corefcn/display.cc
@@ -59,15 +59,15 @@ display_info::instance_ok (bool query)
       instance = new display_info (query);
 
       if (instance)
         singleton_cleanup_list::add (cleanup_instance);
     }
 
   if (! instance)
     {
-      ::error ("unable to create display_info object!");
+      error ("unable to create display_info object!");
 
       retval = false;
     }
 
   return retval;
 }
diff --git a/libinterp/corefcn/dynamic-ld.cc b/libinterp/corefcn/dynamic-ld.cc
--- a/libinterp/corefcn/dynamic-ld.cc
+++ b/libinterp/corefcn/dynamic-ld.cc
@@ -155,17 +155,17 @@ octave_shlib_list::instance_ok (void)
       instance = new octave_shlib_list ();
 
       if (instance)
         singleton_cleanup_list::add (cleanup_instance);
     }
 
   if (! instance)
     {
-      ::error ("unable to create shared library list object!");
+      error ("unable to create shared library list object!");
 
       retval = false;
     }
 
   return retval;
 }
 
 void
@@ -211,17 +211,17 @@ octave_dynamic_loader::instance_ok (void
       instance = new octave_dynamic_loader ();
 
       if (instance)
         singleton_cleanup_list::add (cleanup_instance);
     }
 
   if (! instance)
     {
-      ::error ("unable to create dynamic loader object!");
+      error ("unable to create dynamic loader object!");
 
       retval = false;
     }
 
   return retval;
 }
 
 static void
@@ -290,23 +290,22 @@ octave_dynamic_loader::do_load_oct (cons
           if (function)
             {
               octave_dld_fcn_getter f
                 = FCN_PTR_CAST (octave_dld_fcn_getter, function);
 
               retval = f (oct_file, relative);
 
               if (! retval)
-                ::error ("failed to install .oct file function '%s'",
-                         fcn_name.c_str ());
+                error ("failed to install .oct file function '%s'",
+                       fcn_name.c_str ());
             }
         }
       else
-        ::error ("%s is not a valid shared library",
-                 file_name.c_str ());
+        error ("%s is not a valid shared library", file_name.c_str ());
     }
 
   return retval;
 }
 
 octave_function *
 octave_dynamic_loader::do_load_mex (const std::string& fcn_name,
                                     const std::string& file_name,
@@ -358,22 +357,21 @@ octave_dynamic_loader::do_load_mex (cons
                     have_fmex = true;
                 }
             }
 
           if (function)
             retval = new octave_mex_function (function, have_fmex,
                                               mex_file, fcn_name);
           else
-            ::error ("failed to install .mex file function '%s'",
-                     fcn_name.c_str ());
+            error ("failed to install .mex file function '%s'",
+                   fcn_name.c_str ());
         }
       else
-        ::error ("%s is not a valid shared library",
-                 file_name.c_str ());
+        error ("%s is not a valid shared library", file_name.c_str ());
     }
 
   return retval;
 }
 
 bool
 octave_dynamic_loader::do_remove_oct (const std::string& fcn_name,
                                       octave_shlib& shl)
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -225,17 +225,17 @@ fopen_mode_to_ios_mode (const std::strin
         retval = std::ios::in | std::ios::out | std::ios::binary;
       else if (mode == "w+b" || mode == "wb+" || mode == "w+")
         retval = (std::ios::in | std::ios::out | std::ios::trunc
                   | std::ios::binary);
       else if (mode == "a+b" || mode == "ab+" || mode == "a+")
         retval = (std::ios::in | std::ios::out | std::ios::app
                   | std::ios::binary);
       else
-        ::error ("invalid mode specified");
+        error ("invalid mode specified");
     }
 
   return retval;
 }
 
 DEFUN (fclose, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} fclose (@var{fid})\n\
@@ -571,23 +571,23 @@ do_stream_open (const octave_value& tc_n
 
           if (tc_arch.is_string ())
             {
               std::string arch = tc_arch.string_value ();
 
               retval = do_stream_open (name, mode, arch, fid);
             }
           else
-            ::error ("%s: architecture type must be a string", fcn);
+            error ("%s: architecture type must be a string", fcn);
         }
       else
-        ::error ("%s: file mode must be a string", fcn);
+        error ("%s: file mode must be a string", fcn);
     }
   else
-    ::error ("%s: file name must be a string", fcn);
+    error ("%s: file name must be a string", fcn);
 
   return retval;
 }
 
 DEFUN (fopen, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{fid} =} fopen (@var{name})\n\
 @deftypefnx {Built-in Function} {@var{fid} =} fopen (@var{name}, @var{mode})\n\
@@ -941,17 +941,17 @@ expanded even when the template string i
 
                   for (int i = fmt_n + 1; i < nargin; i++)
                     tmp_args(i-fmt_n-1) = args(i);
                 }
 
               result = os.printf (args(fmt_n), tmp_args, who);
             }
           else
-            ::error ("%s: format TEMPLATE must be a string", who.c_str ());
+            error ("%s: format TEMPLATE must be a string", who.c_str ());
         }
     }
   else
     print_usage ();
 
   if (nargout > 0)
     retval = result;
 
@@ -996,17 +996,17 @@ expanded even when the template string i
 
               for (int i = 1; i < nargin; i++)
                 tmp_args(i-1) = args(i);
             }
 
           result = stdout_stream.printf (args(0), tmp_args, who);
         }
       else
-        ::error ("%s: format TEMPLATE must be a string", who.c_str ());
+        error ("%s: format TEMPLATE must be a string", who.c_str ());
     }
   else
     print_usage ();
 
   if (nargout > 0)
     retval = result;
 
   return retval;
@@ -1124,20 +1124,20 @@ expanded even when the template string i
               std::string result = ostr->str ();
               char type = fmt_arg.is_sq_string () ? '\'' : '"';
 
               retval(0) = (result.empty ()
                            ? octave_value (charMatrix (1, 0), type)
                            : octave_value (result, type));
             }
           else
-            ::error ("%s: format TEMPLATE must be a string", who.c_str ());
+            error ("%s: format TEMPLATE must be a string", who.c_str ());
         }
       else
-        ::error ("%s: unable to create output buffer", who.c_str ());
+        error ("%s: unable to create output buffer", who.c_str ());
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (fscanf, args, ,
@@ -1200,17 +1200,17 @@ complete description of the syntax of th
     {
       octave_stream os = octave_stream_list::lookup (args(0), who);
 
       if (! error_state)
         {
           if (args(1).is_string ())
             retval = os.oscanf (args(1), who);
           else
-            ::error ("%s: format TEMPLATE must be a string", who.c_str ());
+            error ("%s: format TEMPLATE must be a string", who.c_str ());
         }
     }
   else
     {
       retval(2) = "unknown error";
       retval(1) = 0.0;
       retval(0) = Matrix ();
 
@@ -1237,17 +1237,17 @@ complete description of the syntax of th
                         {
                           retval(2) = os.error ();
                           retval(1) = count;
                           retval(0) = tmp;
                         }
                     }
                 }
               else
-                ::error ("%s: format must be a string", who.c_str ());
+                error ("%s: format must be a string", who.c_str ());
             }
         }
       else
         print_usage ();
     }
 
   return retval;
 }
@@ -1259,17 +1259,17 @@ get_sscanf_data (const octave_value& val
 
   if (val.is_string ())
     {
       octave_value tmp = val.reshape (dim_vector (1, val.numel ()));
 
       retval = tmp.string_value ();
     }
   else
-    ::error ("sscanf: argument STRING must be a string");
+    error ("sscanf: argument STRING must be a string");
 
   return retval;
 }
 
 DEFUN (sscanf, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{val}, @var{count}, @var{errmsg}, @var{pos}] =} sscanf (@var{string}, @var{template}, @var{size})\n\
 @deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}, @var{errmsg}] =} sscanf (@var{string}, @var{template}, \"C\")\n\
@@ -1296,24 +1296,23 @@ character to be read is returned in @var
         {
           octave_stream os = octave_istrstream::create (data);
 
           if (os.is_valid ())
             {
               if (args(1).is_string ())
                 retval = os.oscanf (args(1), who);
               else
-                ::error ("%s: format TEMPLATE must be a string", who.c_str ());
+                error ("%s: format TEMPLATE must be a string", who.c_str ());
             }
           else
-            ::error ("%s: unable to create temporary input buffer",
-                     who.c_str ());
+            error ("%s: unable to create temporary input buffer", who.c_str ());
         }
       else
-        ::error ("%s: argument STRING must be a string", who.c_str ());
+        error ("%s: argument STRING must be a string", who.c_str ());
     }
   else
     {
       if (nargin == 2 || nargin == 3)
         {
           retval(3) = -1.0;
           retval(2) = "unknown error";
           retval(1) = 0.0;
@@ -1348,22 +1347,22 @@ character to be read is returned in @var
                           retval(3)
                             = (os.eof () ? data.length () : os.tell ()) + 1;
                           retval(2) = errmsg;
                           retval(1) = count;
                           retval(0) = tmp;
                         }
                     }
                   else
-                    ::error ("%s: format TEMPLATE must be a string",
-                             who.c_str ());
+                    error ("%s: format TEMPLATE must be a string",
+                           who.c_str ());
                 }
               else
-                ::error ("%s: unable to create temporary input buffer",
-                         who.c_str  ());
+                error ("%s: unable to create temporary input buffer",
+                       who.c_str  ());
             }
         }
       else
         print_usage ();
     }
 
   return retval;
 }
@@ -1426,29 +1425,29 @@ do_fread (octave_stream& os, const octav
                       oct_mach_info::float_format flt_fmt
                         = oct_mach_info::string_to_float_format (arch);
 
                       if (! error_state)
                         retval = os.read (size, block_size, input_type,
                                           output_type, skip, flt_fmt, count);
                     }
                   else
-                    ::error ("fread: ARCH architecture type must be a string");
+                    error ("fread: ARCH architecture type must be a string");
                 }
               else
-                ::error ("fread: SKIP must be an integer");
+                error ("fread: SKIP must be an integer");
             }
           else
-            ::error ("fread: invalid PRECISION specified");
+            error ("fread: invalid PRECISION specified");
         }
       else
-        ::error ("fread: PRECISION must be a string");
+        error ("fread: PRECISION must be a string");
     }
   else
-    ::error ("fread: invalid SIZE specified");
+    error ("fread: invalid SIZE specified");
 
   return retval;
 }
 
 DEFUN (fread, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} fread (@var{fid})\n\
 @deftypefnx {Built-in Function} {@var{val} =} fread (@var{fid}, @var{size})\n\
@@ -1694,26 +1693,26 @@ do_fwrite (octave_stream& os, const octa
                   oct_mach_info::float_format flt_fmt
                     = oct_mach_info::string_to_float_format (arch);
 
                   if (! error_state)
                     retval = os.write (data, block_size, output_type,
                                        skip, flt_fmt);
                 }
               else
-                ::error ("fwrite: ARCH architecture type must be a string");
+                error ("fwrite: ARCH architecture type must be a string");
             }
           else
-            ::error ("fwrite: SKIP must be an integer");
+            error ("fwrite: SKIP must be an integer");
         }
       else
-        ::error ("fwrite: invalid PRECISION specified");
+        error ("fwrite: invalid PRECISION specified");
     }
   else
-    ::error ("fwrite: PRECISION must be a string");
+    error ("fwrite: PRECISION must be a string");
 
   return retval;
 }
 
 DEFUN (fwrite, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} fwrite (@var{fid}, @var{data})\n\
 @deftypefnx {Built-in Function} {} fwrite (@var{fid}, @var{data}, @var{precision})\n\
@@ -1924,23 +1923,23 @@ endwhile\n\
                 }
               else if (mode == "w")
                 {
                   octave_stream ops = octave_oprocstream::create (name);
 
                   retval = octave_stream_list::insert (ops);
                 }
               else
-                ::error ("popen: invalid MODE specified");
+                error ("popen: invalid MODE specified");
             }
           else
-            ::error ("popen: MODE must be a string");
+            error ("popen: MODE must be a string");
         }
       else
-        ::error ("popen: COMMAND must be a string");
+        error ("popen: COMMAND must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("pclose", Fpclose, args, ,
@@ -1991,26 +1990,26 @@ see @code{tmpfile}.\n\
   if (len < 3)
     {
       std::string dir;
       if (len > 0)
         {
           if (args(0).is_string ())
             dir = args(0).string_value ();
           else
-            ::error ("DIR must be a string");
+            error ("DIR must be a string");
         }
 
       std::string pfx ("oct-");
       if (len > 1)
         {
           if (args(1).is_string ())
             pfx = args(1).string_value ();
           else
-            ::error ("PREFIX must be a string");
+            error ("PREFIX must be a string");
         }
 
       retval = octave_tempnam (dir, pfx);
     }
   else
     print_usage ();
 
   return retval;
@@ -2209,27 +2208,27 @@ file, and @var{msg} is an empty string. 
 static int
 convert (int x, int ibase, int obase)
 {
   int retval = 0;
 
   int tmp = x % obase;
 
   if (tmp > ibase - 1)
-    ::error ("umask: invalid digit");
+    error ("umask: invalid digit");
   else
     {
       retval = tmp;
       int mult = ibase;
       while ((x = (x - tmp) / obase))
         {
           tmp = x % obase;
           if (tmp > ibase - 1)
             {
-              ::error ("umask: invalid digit");
+              error ("umask: invalid digit");
               break;
             }
           retval += mult * tmp;
           mult *= ibase;
         }
     }
 
   return retval;
@@ -2261,30 +2260,30 @@ for the new object are @code{@var{mode} 
     {
       int mask = args(0).int_value (true);
 
       if (! error_state)
         {
           if (mask < 0)
             {
               status = -1;
-              ::error ("umask: MASK must be a positive integer value");
+              error ("umask: MASK must be a positive integer value");
             }
           else
             {
               int oct_mask = convert (mask, 8, 10);
 
               if (! error_state)
                 status = convert (octave_umask (oct_mask), 10, 8);
             }
         }
       else
         {
           status = -1;
-          ::error ("umask: MASK must be an integer");
+          error ("umask: MASK must be an integer");
         }
     }
   else
     print_usage ();
 
   if (status >= 0)
     retval(0) = status;
 
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -2360,17 +2360,17 @@ private:
   {
     bool retval = true;
 
     if (! instance)
       create_instance ();
 
     if (! instance)
       {
-        ::error ("unable to create gh_manager!");
+        error ("unable to create gh_manager!");
 
         retval = false;
       }
 
     return retval;
   }
 
   static void cleanup_instance (void) { delete instance; instance = 0; }
@@ -5955,17 +5955,17 @@ public:
   {
     bool retval = true;
 
     if (! instance)
       create_instance ();
 
     if (! instance)
       {
-        ::error ("unable to create gh_manager!");
+        error ("unable to create gh_manager!");
 
         retval = false;
       }
 
     return retval;
   }
 
   static void cleanup_instance (void) { delete instance; instance = 0; }
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -328,17 +328,17 @@ load_path::instance_ok (void)
       instance = new load_path ();
 
       if (instance)
         singleton_cleanup_list::add (cleanup_instance);
     }
 
   if (! instance)
     {
-      ::error ("unable to create load path object!");
+      error ("unable to create load path object!");
 
       retval = false;
     }
 
   return retval;
 }
 
 // FIXME: maybe we should also maintain a map to speed up this method of access.
diff --git a/libinterp/corefcn/ls-oct-ascii.cc b/libinterp/corefcn/ls-oct-ascii.cc
--- a/libinterp/corefcn/ls-oct-ascii.cc
+++ b/libinterp/corefcn/ls-oct-ascii.cc
@@ -403,17 +403,17 @@ save_three_d (std::ostream& os, const oc
                 os << "\n";
             }
         }
 
       os.precision (old_precision);
     }
   else
     {
-      ::error ("for now, I can only save real matrices in 3-D format");
+      error ("for now, I can only save real matrices in 3-D format");
       fail = true;
     }
 
   return (os && ! fail);
 }
 
 DEFUN (save_precision, args, nargout,
        "-*- texinfo -*-\n\
diff --git a/libinterp/corefcn/lsode.cc b/libinterp/corefcn/lsode.cc
--- a/libinterp/corefcn/lsode.cc
+++ b/libinterp/corefcn/lsode.cc
@@ -138,25 +138,25 @@ lsode_user_jacobian (const ColumnVector&
 }
 
 #define LSODE_ABORT() \
   return retval
 
 #define LSODE_ABORT1(msg) \
   do \
     { \
-      ::error ("lsode: " msg); \
+      error ("lsode: " msg); \
       LSODE_ABORT (); \
     } \
   while (0)
 
 #define LSODE_ABORT2(fmt, arg) \
   do \
     { \
-      ::error ("lsode: " fmt, arg); \
+      error ("lsode: " fmt, arg); \
       LSODE_ABORT (); \
     } \
   while (0)
 
 DEFUN (lsode, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{x}, @var{istate}, @var{msg}] =} lsode (@var{fcn}, @var{x_0}, @var{t})\n\
 @deftypefnx {Built-in Function} {[@var{x}, @var{istate}, @var{msg}] =} lsode (@var{fcn}, @var{x_0}, @var{t}, @var{t_crit})\n\
diff --git a/libinterp/corefcn/oct-errno.in.cc b/libinterp/corefcn/oct-errno.in.cc
--- a/libinterp/corefcn/oct-errno.in.cc
+++ b/libinterp/corefcn/oct-errno.in.cc
@@ -298,17 +298,17 @@ octave_errno::instance_ok (void)
       instance = new octave_errno ();
 
       if (instance)
         singleton_cleanup_list::add (cleanup_instance);
     }
 
   if (! instance)
     {
-      ::error ("unable to create errno object!");
+      error ("unable to create errno object!");
 
       retval = false;
     }
 
   return retval;
 }
 
 int
diff --git a/libinterp/corefcn/octave-link.cc b/libinterp/corefcn/octave-link.cc
--- a/libinterp/corefcn/octave-link.cc
+++ b/libinterp/corefcn/octave-link.cc
@@ -68,17 +68,17 @@ octave_link::set_workspace (void)
 // OBJ should be an object of a class that is derived from the base
 // class octave_link, or 0 to disconnect the link.  It is the
 // responsibility of the caller to delete obj.
 
 void
 octave_link::connect_link (octave_link* obj)
 {
   if (obj && instance)
-    ::error ("octave_link is already linked!");
+    error ("octave_link is already linked!");
   else
     instance = obj;
 }
 
 void
 octave_link::do_generate_events (void)
 {
 }
diff --git a/libinterp/corefcn/pager.cc b/libinterp/corefcn/pager.cc
--- a/libinterp/corefcn/pager.cc
+++ b/libinterp/corefcn/pager.cc
@@ -376,17 +376,17 @@ octave_pager_stream::instance_ok (void)
       instance = new octave_pager_stream ();
 
       if (instance)
         singleton_cleanup_list::add (cleanup_instance);
     }
 
   if (! instance)
     {
-      ::error ("unable to create pager_stream object!");
+      error ("unable to create pager_stream object!");
 
       retval = false;
     }
 
   return retval;
 }
 
 octave_diary_stream *octave_diary_stream::instance = 0;
@@ -441,17 +441,17 @@ octave_diary_stream::instance_ok (void)
       instance = new octave_diary_stream ();
 
       if (instance)
         singleton_cleanup_list::add (cleanup_instance);
     }
 
   if (! instance)
     {
-      ::error ("unable to create diary_stream object!");
+      error ("unable to create diary_stream object!");
 
       retval = false;
     }
 
   return retval;
 }
 
 void
diff --git a/libinterp/corefcn/quad.cc b/libinterp/corefcn/quad.cc
--- a/libinterp/corefcn/quad.cc
+++ b/libinterp/corefcn/quad.cc
@@ -154,25 +154,25 @@ quad_float_user_function (float x)
         clear_function (fcn_name); \
       return retval; \
     } \
   while (0)
 
 #define QUAD_ABORT1(msg) \
   do \
     { \
-      ::error ("quad: " msg); \
+      error ("quad: " msg); \
       QUAD_ABORT (); \
     } \
   while (0)
 
 #define QUAD_ABORT2(fmt, arg) \
   do \
     { \
-      ::error ("quad: " fmt, arg); \
+      error ("quad: " fmt, arg); \
       QUAD_ABORT (); \
     } \
   while (0)
 
 DEFUN (quad, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{q} =} quad (@var{f}, @var{a}, @var{b})\n\
 @deftypefnx {Built-in Function} {@var{q} =} quad (@var{f}, @var{a}, @var{b}, @var{tol})\n\
diff --git a/libinterp/corefcn/sighandlers.cc b/libinterp/corefcn/sighandlers.cc
--- a/libinterp/corefcn/sighandlers.cc
+++ b/libinterp/corefcn/sighandlers.cc
@@ -194,17 +194,17 @@ private:
         instance = new w32_interrupt_manager ();
 
         if (instance)
           singleton_cleanup_list::add (cleanup_instance);
       }
 
     if (! instance)
       {
-        ::error ("unable to create w32_interrupt_manager");
+        error ("unable to create w32_interrupt_manager");
 
         retval = false;
       }
 
     return retval;
   }
 
   static void cleanup_instance (void) { delete instance; instance = 0; }
@@ -924,17 +924,17 @@ octave_child_list::instance_ok (void)
       instance = new octave_child_list_rep ();
 
       if (instance)
         singleton_cleanup_list::add (cleanup_instance);
     }
 
   if (! instance)
     {
-      ::error ("unable to create child list object!");
+      error ("unable to create child list object!");
 
       retval = false;
     }
 
   return retval;
 }
 
 void
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -1616,17 +1616,17 @@ symbol_table::do_update_nest (void)
       for (table_iterator ti = table.begin (); ti != table.end (); ++ti)
         {
           symbol_record &ours = ti->second;
           symbol_record parents;
           if (! ours.is_formal ()
               && nest_parent->look_nonlocal (ti->first, parents))
             {
               if (ours.is_global () || ours.is_persistent ())
-                ::error ("global and persistent may only be used in the topmost level in which a nested variable is used");
+                error ("global and persistent may only be used in the topmost level in which a nested variable is used");
 
               if (! ours.is_formal ())
                 {
                   ours.invalidate ();
                   ti->second = parents;
                 }
             }
           else
diff --git a/libinterp/corefcn/symtab.h b/libinterp/corefcn/symtab.h
--- a/libinterp/corefcn/symtab.h
+++ b/libinterp/corefcn/symtab.h
@@ -89,17 +89,17 @@ public:
     {
       bool retval = true;
 
       if (! instance)
         create_instance ();
 
       if (! instance)
         {
-          ::error ("unable to create scope_id_cache object!");
+          error ("unable to create scope_id_cache object!");
 
           retval = false;
         }
 
       return retval;
     }
 
   private:
diff --git a/libinterp/corefcn/syscalls.cc b/libinterp/corefcn/syscalls.cc
--- a/libinterp/corefcn/syscalls.cc
+++ b/libinterp/corefcn/syscalls.cc
@@ -824,27 +824,27 @@ The function outputs are described in th
 static int
 convert (int x, int ibase, int obase)
 {
   int retval = 0;
 
   int tmp = x % obase;
 
   if (tmp > ibase - 1)
-    ::error ("mkfifo: invalid digit");
+    error ("mkfifo: invalid digit");
   else
     {
       retval = tmp;
       int mult = ibase;
       while ((x = (x - tmp) / obase))
         {
           tmp = x % obase;
           if (tmp > ibase - 1)
             {
-              ::error ("mkfifo: invalid digit");
+              error ("mkfifo: invalid digit");
               break;
             }
           retval += mult * tmp;
           mult *= ibase;
         }
     }
 
   return retval;
diff --git a/libinterp/corefcn/toplev.h b/libinterp/corefcn/toplev.h
--- a/libinterp/corefcn/toplev.h
+++ b/libinterp/corefcn/toplev.h
@@ -129,17 +129,17 @@ public:
   {
     bool retval = true;
 
     if (! instance)
       create_instance ();
 
     if (! instance)
       {
-        ::error ("unable to create call stack object!");
+        error ("unable to create call stack object!");
 
         retval = false;
       }
 
     return retval;
   }
 
   // Current function (top of stack).
diff --git a/libinterp/corefcn/txt-eng-ft.cc b/libinterp/corefcn/txt-eng-ft.cc
--- a/libinterp/corefcn/txt-eng-ft.cc
+++ b/libinterp/corefcn/txt-eng-ft.cc
@@ -85,17 +85,17 @@ public:
         instance = new ft_manager ();
 
         if (instance)
           singleton_cleanup_list::add (cleanup_instance);
       }
 
     if (! instance)
       {
-        ::error ("unable to create ft_manager!");
+        error ("unable to create ft_manager!");
 
         retval = false;
       }
 
     return retval;
   }
 
   static void cleanup_instance (void) { delete instance; instance = 0; }
@@ -133,23 +133,23 @@ private:
   ft_manager (const ft_manager&);
 
   ft_manager& operator = (const ft_manager&);
 
   ft_manager (void)
     : library (), freetype_initialized (false), fontconfig_initialized (false)
   {
     if (FT_Init_FreeType (&library))
-      ::error ("unable to initialize FreeType library");
+      error ("unable to initialize FreeType library");
     else
       freetype_initialized = true;
 
 #if defined (HAVE_FONTCONFIG)
     if (! FcInit ())
-      ::error ("unable to initialize fontconfig library");
+      error ("unable to initialize fontconfig library");
     else
       fontconfig_initialized = true;
 #endif
   }
 
   ~ft_manager (void)
   {
     if (freetype_initialized)
@@ -487,17 +487,17 @@ ft_render::set_mode (int m)
           pixels = uint8NDArray (dim_vector (4, bbox(2), bbox(3)),
                                  static_cast<uint8_t> (0));
           xoffset = compute_line_xoffset (line_bbox.front ());
           line_yoffset = -bbox(1)-1;
           yoffset = 0;
         }
       break;
     default:
-      ::error ("ft_render: invalid mode '%d'", mode);
+      error ("ft_render: invalid mode '%d'", mode);
       break;
     }
 }
 
 FT_UInt
 ft_render::process_character (FT_ULong code, FT_UInt previous)
 {
   FT_Face face = font.get_face ();
diff --git a/libinterp/corefcn/urlwrite.cc b/libinterp/corefcn/urlwrite.cc
--- a/libinterp/corefcn/urlwrite.cc
+++ b/libinterp/corefcn/urlwrite.cc
@@ -76,17 +76,17 @@ public:
   {
     bool retval = true;
 
     if (! instance)
       create_instance ();
 
     if (! instance)
       {
-        ::error ("unable to create ch_manager!");
+        error ("unable to create ch_manager!");
 
         retval = false;
       }
 
     return retval;
   }
 
   static void cleanup_instance (void) { delete instance; instance = 0; }
diff --git a/libinterp/dldfcn/__init_fltk__.cc b/libinterp/dldfcn/__init_fltk__.cc
--- a/libinterp/dldfcn/__init_fltk__.cc
+++ b/libinterp/dldfcn/__init_fltk__.cc
@@ -1772,17 +1772,17 @@ public:
   {
     bool retval = true;
 
     if (! instance)
       instance = new figure_manager ();
 
     if (! instance)
       {
-        ::error ("unable to create figure_manager object!");
+        error ("unable to create figure_manager object!");
 
         retval = false;
       }
 
     return retval;
   }
 
   ~figure_manager (void)
diff --git a/libinterp/octave-value/ov-builtin.cc b/libinterp/octave-value/ov-builtin.cc
--- a/libinterp/octave-value/ov-builtin.cc
+++ b/libinterp/octave-value/ov-builtin.cc
@@ -104,17 +104,17 @@ octave_builtin::do_multi_index_op (int n
                                    const std::list<octave_lvalue> *lvalue_list)
 {
   octave_value_list retval;
 
   if (error_state)
     return retval;
 
   if (args.has_magic_colon ())
-    ::error ("invalid use of colon in function argument list");
+    error ("invalid use of colon in function argument list");
   else
     {
       unwind_protect frame;
 
       octave_call_stack::push (this);
 
       frame.add_fcn (octave_call_stack::pop);
 
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -573,18 +573,17 @@ class_fevalStatic (const octave_value_li
                   if (meth.is_static ())
                     retval = meth.execute (args.splice (0, 2), nargout,
                                            true, "fevalStatic");
                   else
                     error ("fevalStatic: method `%s' is not static",
                            meth_name.c_str ());
                 }
               else
-                error ("fevalStatic: method not found: %s",
-                       meth_name.c_str ());
+                error ("fevalStatic: method not found: %s", meth_name.c_str ());
             }
           else
             error ("fevalStatic: invalid method name, expected a string value");
         }
       error ("fevalStatic: invalid object, expected a meta.class object");
     }
   else
     error ("fevalStatic: invalid arguments");
@@ -735,18 +734,18 @@ make_class (const std::string& name,
            it != super_list.end (); ++it)
         {
           all_handle_compatible = all_handle_compatible
                                   && it->get ("HandleCompatible").bool_value ();
           has_handle_class = has_handle_class || it->is_handle_class ();
         }
 
       if (has_handle_class && ! all_handle_compatible)
-        ::error ("%s: cannot mix handle and non-HandleCompatible classes",
-                 name.c_str ());
+        error ("%s: cannot mix handle and non-HandleCompatible classes",
+               name.c_str ());
       else
         {
           cls.put ("HandleCompatible", all_handle_compatible);
           if (has_handle_class)
             cls.mark_as_handle_class ();
         }
     }
 
@@ -988,17 +987,17 @@ octave_classdef::subsasgn (const std::st
 
               retlist = meth.execute (args, 1, true, "subsasgn");
 
               if (! error_state)
                 {
                   if (retlist.length () > 0)
                     retval = retlist(0);
                   else
-                    ::error ("overloaded method `subsasgn' did not return any value");
+                    error ("overloaded method `subsasgn' did not return any value");
                 }
             }
         }
     }
 
   if (! error_state && ! retval.is_defined ())
     retval = object.subsasgn (type, idx, rhs);
 
@@ -1251,22 +1250,22 @@ public:
                       {
                         octave_value sym = symbol_table::varval (mname);
 
                         cls.run_constructor (to_cdef_ref (sym), idx);
 
                         retval(0) = sym;
                       }
                     else
-                      ::error ("cannot call superclass constructor with "
-                               "variable `%s'", mname.c_str ());
+                      error ("cannot call superclass constructor with "
+                             "variable `%s'", mname.c_str ());
                   }
                 else
-                  ::error ("`%s' is not a direct superclass of `%s'",
-                           cname.c_str (), ctx.get_name ().c_str ());
+                  error ("`%s' is not a direct superclass of `%s'",
+                         cname.c_str (), ctx.get_name ().c_str ());
               }
             else
               {
                 if (mname == meth_name)
                   {
                     if (is_strict_superclass (cls, ctx))
                       {
                         // I see 2 possible implementations here:
@@ -1281,31 +1280,31 @@ public:
                         // go with option 2) for the time being.
 
                         cdef_method meth = cls.find_method (meth_name, false);
 
                         if (meth.ok ())
                           retval = meth.execute (idx, nargout, true,
                                                  meth_name);
                         else
-                          ::error ("no method `%s' found in superclass `%s'",
-                                   meth_name.c_str (), cname.c_str ());
+                          error ("no method `%s' found in superclass `%s'",
+                                 meth_name.c_str (), cname.c_str ());
                       }
                     else
-                      ::error ("`%s' is not a superclass of `%s'",
-                               cname.c_str (), ctx.get_name ().c_str ());
+                      error ("`%s' is not a superclass of `%s'",
+                             cname.c_str (), ctx.get_name ().c_str ());
                   }
                 else
-                  ::error ("method name mismatch (`%s' != `%s')",
-                           mname.c_str (), meth_name.c_str ());
+                  error ("method name mismatch (`%s' != `%s')",
+                         mname.c_str (), meth_name.c_str ());
               }
           }
       }
     else if (! error_state)
-      ::error ("superclass calls can only occur in methods or constructors");
+      error ("superclass calls can only occur in methods or constructors");
 
     return retval;
   }
 
 private:
   bool is_constructed_object (const std::string nm)
   {
     octave_function *of = octave_call_stack::current ();
@@ -1709,18 +1708,18 @@ cdef_object_array::subsref (const std::s
           if (! error_state)
             retval(0) = octave_value (c, true);
 
           break;
         }
       // fall through "default"
 
     default:
-      ::error ("can't perform indexing operation on array of %s objects",
-               class_name ().c_str ());
+      error ("can't perform indexing operation on array of %s objects",
+             class_name ().c_str ());
       break;
     }
 
   return retval;
 }
 
 octave_value
 cdef_object_array::subsasgn (const std::string& type,
@@ -1779,19 +1778,19 @@ cdef_object_array::subsasgn (const std::
                                   refcount++;
                                   retval = to_ov (cdef_object (this));
                                 }
                             }
                         }
                     }
                 }
               else
-                ::error ("can't assign %s object into array of %s objects.",
-                         rhs_obj.class_name ().c_str (),
-                         class_name ().c_str ());
+                error ("can't assign %s object into array of %s objects.",
+                       rhs_obj.class_name ().c_str (),
+                       class_name ().c_str ());
             }
         }
       else
         {
           const octave_value_list& ival = idx.front ();
 
           bool is_scalar = true;
 
@@ -1879,18 +1878,18 @@ cdef_object_array::subsasgn (const std::
                                "objects", class_name ().c_str ());
                     }
                 }
             }
         }
       break;
 
     default:
-      ::error ("can't perform indexing operation on array of %s objects",
-               class_name ().c_str ());
+      error ("can't perform indexing operation on array of %s objects",
+             class_name ().c_str ());
       break;
     }
 
   return retval;
 }
 
 void
 cdef_object_array::fill_empty_values (Array<cdef_object>& arr)
@@ -2172,18 +2171,18 @@ cdef_class::cdef_class_rep::install_meth
                                     << it->get_name () << std::endl;
 #endif
 
                           implicit_ctor_list.remove (*it);
                         }
                     }
                 }
               else
-                ::error ("%s: invalid constructor output arguments",
-                         meth.get_name ().c_str ());
+                error ("%s: invalid constructor output arguments",
+                       meth.get_name ().c_str ());
             }
         }
     }
 }
 
 void
 cdef_class::cdef_class_rep::load_all_methods (void)
 {
@@ -2538,43 +2537,42 @@ cdef_class::cdef_class_rep::meta_subsref
                           skip++;
                         }
 
                       retval = meth.execute (args, (type.length () > skip
                                                     ? 1 : nargout), true,
                                              "meta.class");
                     }
                   else
-                    ::error ("method `%s' is not static", nm.c_str ());
+                    error ("method `%s' is not static", nm.c_str ());
                 }
               else
                 {
                   cdef_property prop = find_property (nm);
 
                   if (prop.ok ())
                     {
                       if (prop.is_constant ())
                         retval(0) = prop.get_value (true, "meta.class");
                       else
-                        ::error ("property `%s' is not constant",
-                                 nm.c_str ());
+                        error ("property `%s' is not constant", nm.c_str ());
                     }
                   else
-                    ::error ("no such method or property `%s'", nm.c_str ());
+                    error ("no such method or property `%s'", nm.c_str ());
                 }
             }
           else
-            ::error ("invalid meta.class indexing, expected a method or property name");
+            error ("invalid meta.class indexing, expected a method or property name");
         }
       else
-        ::error ("invalid meta.class indexing");
+        error ("invalid meta.class indexing");
       break;
 
     default:
-      ::error ("invalid meta.class indexing");
+      error ("invalid meta.class indexing");
       break;
     }
 
   if (! error_state)
     {
       if (type.length () > skip && idx.size () > skip && ! retval.empty ())
         retval = retval(0).next_subsref (nargout, type, idx, skip);
     }
@@ -2659,18 +2657,18 @@ cdef_class::cdef_class_rep::run_construc
       ctor_retval = ctor.execute (ctor_args, 1, true, "constructor");
 
       if (! error_state)
         {
           if (ctor_retval.length () == 1)
             obj = to_cdef (ctor_retval(0));
           else
             {
-              ::error ("%s: invalid number of output arguments for classdef constructor",
-                       ctor_name.c_str ());
+              error ("%s: invalid number of output arguments for classdef constructor",
+                     ctor_name.c_str ());
               return;
             }
         }
     }
 
   obj.mark_as_constructed (wrap ());
 }
 
@@ -2834,18 +2832,18 @@ cdef_class::make_meta_class (tree_classd
           cdef_class sclass = lookup_class (sclass_name);
 
           if (! error_state)
             {
               if (! sclass.get ("Sealed").bool_value ())
                 slist.push_back (sclass);
               else
                 {
-                  ::error ("`%s' cannot inherit from `%s', because it is sealed",
-                           full_class_name.c_str (), sclass_name.c_str ());
+                  error ("`%s' cannot inherit from `%s', because it is sealed",
+                         full_class_name.c_str (), sclass_name.c_str ());
                   return retval;
                 }
             }
           else
             return retval;
 
         }
     }
@@ -3147,18 +3145,18 @@ cdef_property::cdef_property_rep::get_va
     }
 
   if (! obj.is_constructed ())
     {
       cdef_class cls (to_cdef (get ("DefiningClass")));
 
       if (! obj.is_partially_constructed_for (cls))
         {
-          ::error ("cannot reference properties of class `%s' for non-constructed object",
-                   cls.get_name ().c_str ());
+          error ("cannot reference properties of class `%s' for non-constructed object",
+                 cls.get_name ().c_str ());
           return retval;
         }
     }
 
   octave_value get_fcn = get ("GetMethod");
 
   // FIXME: should check whether we're already in get accessor method
 
@@ -3214,18 +3212,18 @@ cdef_property::cdef_property_rep::set_va
     }
 
   if (! obj.is_constructed ())
     {
       cdef_class cls (to_cdef (get ("DefiningClass")));
 
       if (! obj.is_partially_constructed_for (cls))
         {
-          ::error ("cannot reference properties of class `%s' for non-constructed object",
-                   cls.get_name ().c_str ());
+          error ("cannot reference properties of class `%s' for non-constructed object",
+                 cls.get_name ().c_str ());
           return;
         }
     }
 
   octave_value set_fcn = get ("SetMethod");
 
   if (set_fcn.is_empty () || is_method_executing (set_fcn, obj))
     obj.put (get ("Name").string_value (), val);
@@ -3319,18 +3317,18 @@ cdef_method::cdef_method_rep::check_meth
             }
         }
       else
         {
           // FIXME: check out-of-date status
         }
 
       if (is_dummy_method (function))
-        ::error ("no definition found for method `%s' of class `%s'",
-                 get_name ().c_str (), dispatch_type.c_str ());
+        error ("no definition found for method `%s' of class `%s'",
+               get_name ().c_str (), dispatch_type.c_str ());
     }
 }
 
 octave_value_list
 cdef_method::cdef_method_rep::execute (const octave_value_list& args,
                                        int nargout, bool do_check_access,
                                        const std::string& who)
 {
diff --git a/libinterp/octave-value/ov-classdef.h b/libinterp/octave-value/ov-classdef.h
--- a/libinterp/octave-value/ov-classdef.h
+++ b/libinterp/octave-value/ov-classdef.h
@@ -541,17 +541,17 @@ public:
 
   virtual bool is_package (void) const { return false; }
 
   virtual octave_value_list
   meta_subsref (const std::string& /* type */,
                 const std::list<octave_value_list>& /* idx */,
                 int /* nargout */)
   {
-    ::error ("subsref: invalid meta object");
+    error ("subsref: invalid meta object");
     return octave_value_list ();
   }
 
   virtual void meta_release (void) { }
 
   virtual bool meta_is_postfix_index_handled (char /* type */) const
   { return false; }
 
@@ -1623,17 +1623,17 @@ private:
   {
     bool retval = true;
 
     if (! instance)
       create_instance ();
 
     if (! instance)
       {
-        ::error ("unable to create cdef_manager!");
+        error ("unable to create cdef_manager!");
 
         retval = false;
       }
 
     return retval;
   }
 
   static void cleanup_instance (void)
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -77,17 +77,17 @@ octave_fcn_handle::octave_fcn_handle (co
   : fcn (f), nm (n), has_overloads (false)
 {
   octave_user_function *uf = fcn.user_function_value (true);
 
   if (uf && nm != anonymous)
     symbol_table::cache_name (uf->scope (), nm);
 
   if (uf && uf->is_nested_function ())
-    ::error ("handles to nested functions are not yet supported");
+    error ("handles to nested functions are not yet supported");
 }
 
 octave_value_list
 octave_fcn_handle::subsref (const std::string& type,
                             const std::list<octave_value_list>& idx,
                             int nargout)
 {
   return octave_fcn_handle::subsref (type, idx, nargout, 0);
diff --git a/libinterp/octave-value/ov-mex-fcn.cc b/libinterp/octave-value/ov-mex-fcn.cc
--- a/libinterp/octave-value/ov-mex-fcn.cc
+++ b/libinterp/octave-value/ov-mex-fcn.cc
@@ -131,17 +131,17 @@ octave_mex_function::do_multi_index_op (
                                         const octave_value_list& args)
 {
   octave_value_list retval;
 
   if (error_state)
     return retval;
 
   if (args.has_magic_colon ())
-    ::error ("invalid use of colon in function argument list");
+    error ("invalid use of colon in function argument list");
   else
     {
       unwind_protect frame;
 
       octave_call_stack::push (this);
 
       frame.add_fcn (octave_call_stack::pop);
 
diff --git a/libinterp/octave-value/ov-range.h b/libinterp/octave-value/ov-range.h
--- a/libinterp/octave-value/ov-range.h
+++ b/libinterp/octave-value/ov-range.h
@@ -54,24 +54,24 @@ public:
 
   octave_range (void)
     : octave_base_value (), range (), idx_cache () { }
 
   octave_range (double base, double limit, double inc)
     : octave_base_value (), range (base, limit, inc), idx_cache ()
   {
     if (range.numel () < 0)
-      ::error ("invalid range");
+      error ("invalid range");
   }
 
   octave_range (const Range& r)
     : octave_base_value (), range (r), idx_cache ()
   {
     if (range.numel () < 0 && range.numel () != -2)
-      ::error ("invalid range");
+      error ("invalid range");
   }
 
   octave_range (const octave_range& r)
     : octave_base_value (), range (r.range),
       idx_cache (r.idx_cache ? new idx_vector (*r.idx_cache) : 0)
   { }
 
   octave_range (const Range& r, const idx_vector& cache)
diff --git a/libinterp/octave-value/ov-typeinfo.cc b/libinterp/octave-value/ov-typeinfo.cc
--- a/libinterp/octave-value/ov-typeinfo.cc
+++ b/libinterp/octave-value/ov-typeinfo.cc
@@ -47,17 +47,17 @@ octave_value_typeinfo::instance_ok (void
       instance = new octave_value_typeinfo ();
 
       if (instance)
         singleton_cleanup_list::add (cleanup_instance);
     }
 
   if (! instance)
     {
-      ::error ("unable to create value type info object!");
+      error ("unable to create value type info object!");
 
       retval = false;
     }
 
   return retval;
 }
 
 int
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -112,17 +112,17 @@ octave_user_script::~octave_user_script 
 }
 
 octave_value_list
 octave_user_script::subsref (const std::string&,
                              const std::list<octave_value_list>&, int)
 {
   octave_value_list retval;
 
-  ::error ("invalid use of script %s in index expression", file_name.c_str ());
+  error ("invalid use of script %s in index expression", file_name.c_str ());
 
   return retval;
 }
 
 octave_value_list
 octave_user_script::do_multi_index_op (int nargout,
                                        const octave_value_list& args)
 {
@@ -156,17 +156,17 @@ octave_user_script::do_multi_index_op (i
 
                   if (tree_return_command::returning)
                     tree_return_command::returning = 0;
 
                   if (tree_break_command::breaking)
                     tree_break_command::breaking--;
                 }
               else
-                ::error ("max_recursion_depth exceeded");
+                error ("max_recursion_depth exceeded");
             }
         }
       else
         error ("invalid call to script %s", file_name.c_str ());
     }
 
   return retval;
 }
@@ -509,17 +509,17 @@ octave_user_function::do_multi_index_op 
 
   unwind_protect frame;
 
   frame.protect_var (call_depth);
   call_depth++;
 
   if (call_depth >= Vmax_recursion_depth)
     {
-      ::error ("max_recursion_depth exceeded");
+      error ("max_recursion_depth exceeded");
       return retval;
     }
 
   // Save old and set current symbol table context, for
   // eval_undefined_error().
 
   int context = active_context ();
 
@@ -550,18 +550,18 @@ octave_user_function::do_multi_index_op 
       if (ret_list)
         {
           ret_list->define_from_arg_vector (ret_args);
           if (error_state)
             return retval;
         }
       else
         {
-          ::error ("%s: invalid classdef constructor, no output argument defined",
-                   dispatch_class ().c_str ());
+          error ("%s: invalid classdef constructor, no output argument defined",
+                 dispatch_class ().c_str ());
           return retval;
         }
     }
 
   // Force parameter list to be undefined when this function exits.
   // Doing so decrements the reference counts on the values of local
   // variables that are also named function parameters.
 
diff --git a/libinterp/parse-tree/pt-arg-list.cc b/libinterp/parse-tree/pt-arg-list.cc
--- a/libinterp/parse-tree/pt-arg-list.cc
+++ b/libinterp/parse-tree/pt-arg-list.cc
@@ -190,17 +190,17 @@ Example:\n\
         }
 
       if (index_position < ndims)
         retval = dv(index_position);
       else
         retval = 1;
     }
   else
-    ::error ("invalid use of end");
+    error ("invalid use of end");
 
   return retval;
 }
 
 octave_value_list
 tree_argument_list::convert_to_const_vector (const octave_value *object)
 {
   // END doesn't make sense for functions.  Maybe we need a different
@@ -239,17 +239,17 @@ tree_argument_list::convert_to_const_vec
       tree_expression *elt = *p++;
 
       if (elt)
         {
           octave_value tmp = elt->rvalue1 ();
 
           if (error_state)
             {
-              ::error ("evaluating argument list element number %d", k+1);
+              error ("evaluating argument list element number %d", k+1);
               args.clear ();
               break;
             }
           else
             {
               if (tmp.is_cs_list ())
                 args.push_back (tmp.list_value ());
               else if (tmp.is_defined ())
diff --git a/libinterp/parse-tree/pt-cell.cc b/libinterp/parse-tree/pt-cell.cc
--- a/libinterp/parse-tree/pt-cell.cc
+++ b/libinterp/parse-tree/pt-cell.cc
@@ -66,17 +66,17 @@ tree_cell::rvalue1 (int)
           octave_idx_type this_nc = row.length ();
 
           if (this_nc != nc)
             {
               if (this_nc == 0)
                 continue;  // blank line
               else
                 {
-                  ::error ("number of columns must match");
+                  error ("number of columns must match");
                   return retval;
                 }
             }
         }
 
       for (octave_idx_type j = 0; j < nc; j++)
         val(i,j) = row(j);
 
diff --git a/libinterp/parse-tree/pt-colon.cc b/libinterp/parse-tree/pt-colon.cc
--- a/libinterp/parse-tree/pt-colon.cc
+++ b/libinterp/parse-tree/pt-colon.cc
@@ -39,17 +39,17 @@ tree_colon_expression::append (tree_expr
 {
   tree_colon_expression *retval = 0;
 
   if (op_base)
     {
       if (op_limit)
         {
           if (op_increment)
-            ::error ("invalid colon expression");
+            error ("invalid colon expression");
           else
             {
               // Stupid syntax:
               //
               // base : limit
               // base : increment : limit
 
               op_increment = op_limit;
@@ -57,17 +57,17 @@ tree_colon_expression::append (tree_expr
             }
         }
       else
         op_limit = t;
 
       retval = this;
     }
   else
-    ::error ("invalid colon expression");
+    error ("invalid colon expression");
 
   return retval;
 }
 
 octave_value_list
 tree_colon_expression::rvalue (int nargout)
 {
   octave_value_list retval;
@@ -128,17 +128,17 @@ tree_colon_expression::rvalue1 (int)
               if (fcn.is_defined ())
                 {
                   octave_value_list tmp2 = fcn.do_multi_index_op (1, tmp1);
 
                   if (! error_state)
                     retval = tmp2 (0);
                 }
               else
-                ::error ("can not find overloaded colon function");
+                error ("can not find overloaded colon function");
             }
         }
       else
         {
           octave_value ov_increment = 1.0;
 
           if (op_increment)
             {
@@ -155,17 +155,17 @@ tree_colon_expression::rvalue1 (int)
     }
 
   return retval;
 }
 
 void
 tree_colon_expression::eval_error (const std::string& s) const
 {
-  ::error ("%s", s.c_str ());
+  error ("%s", s.c_str ());
 }
 
 int
 tree_colon_expression::line (void) const
 {
   return (op_base ? op_base->line ()
           : (op_increment ? op_increment->line ()
              : (op_limit ? op_limit->line ()
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -407,18 +407,18 @@ tree_evaluator::visit_simple_for_command
 
                 if (quit_loop_now ())
                   break;
               }
           }
       }
     else
       {
-        ::error ("invalid type in for loop expression near line %d, column %d",
-                 cmd.line (), cmd.column ());
+        error ("invalid type in for loop expression near line %d, column %d",
+               cmd.line (), cmd.column ());
       }
   }
 }
 
 void
 tree_evaluator::visit_complex_for_command (tree_complex_for_command& cmd)
 {
   if (error_state)
@@ -873,18 +873,18 @@ tree_evaluator::visit_switch_command (tr
                     stmt_lst->accept (*this);
 
                   break;
                 }
             }
         }
     }
   else
-    ::error ("missing value in switch command near line %d, column %d",
-             cmd.line (), cmd.column ());
+    error ("missing value in switch command near line %d, column %d",
+           cmd.line (), cmd.column ());
 }
 
 void
 tree_evaluator::visit_try_catch_command (tree_try_catch_command& cmd)
 {
   unwind_protect frame;
 
   frame.protect_var (buffer_error_messages);
diff --git a/libinterp/parse-tree/pt-exp.cc b/libinterp/parse-tree/pt-exp.cc
--- a/libinterp/parse-tree/pt-exp.cc
+++ b/libinterp/parse-tree/pt-exp.cc
@@ -42,47 +42,47 @@ tree_expression::is_logically_true (cons
 
   octave_value t1 = rvalue1 ();
 
   if (! error_state)
     {
       if (t1.is_defined ())
         return t1.is_true ();
       else
-        ::error ("%s: undefined value used in conditional expression",
-                 warn_for);
+        error ("%s: undefined value used in conditional expression",
+               warn_for);
     }
 
   return expr_value;
 }
 
 octave_value
 tree_expression::rvalue1 (int)
 {
-  ::error ("invalid rvalue function called in expression");
+  error ("invalid rvalue function called in expression");
   return octave_value ();
 }
 
 octave_value_list
 tree_expression::rvalue (int)
 {
-  ::error ("invalid rvalue function called in expression");
+  error ("invalid rvalue function called in expression");
   return octave_value_list ();
 }
 
 octave_value_list
 tree_expression::rvalue (int nargout, const std::list<octave_lvalue> *)
 {
   return rvalue (nargout);
 }
 
 octave_lvalue
 tree_expression::lvalue (void)
 {
-  ::error ("invalid lvalue function called in expression");
+  error ("invalid lvalue function called in expression");
   return octave_lvalue ();
 }
 
 std::string
 tree_expression::original_text (void) const
 {
   return std::string ();
 }
diff --git a/libinterp/parse-tree/pt-id.cc b/libinterp/parse-tree/pt-id.cc
--- a/libinterp/parse-tree/pt-id.cc
+++ b/libinterp/parse-tree/pt-id.cc
@@ -45,22 +45,22 @@ tree_identifier::eval_undefined_error (v
   int l = line ();
   int c = column ();
 
   maybe_missing_function_hook (name ());
   if (error_state)
     return;
 
   if (l == -1 && c == -1)
-    ::error_with_id ("Octave:undefined-function",
-                     "'%s' undefined", name ().c_str ());
+    error_with_id ("Octave:undefined-function",
+                   "'%s' undefined", name ().c_str ());
   else
-    ::error_with_id ("Octave:undefined-function",
-                     "'%s' undefined near line %d column %d",
-                     name ().c_str (), l, c);
+    error_with_id ("Octave:undefined-function",
+                   "'%s' undefined near line %d column %d",
+                   name ().c_str (), l, c);
 }
 
 octave_value_list
 tree_identifier::rvalue (int nargout,
                          const std::list<octave_lvalue> *lvalue_list)
 {
   octave_value_list retval;
 
diff --git a/libinterp/parse-tree/pt-id.h b/libinterp/parse-tree/pt-id.h
--- a/libinterp/parse-tree/pt-id.h
+++ b/libinterp/parse-tree/pt-id.h
@@ -113,18 +113,18 @@ public:
                             const std::list<octave_lvalue> *lvalue_list);
 
   octave_lvalue lvalue (void);
 
   void eval_undefined_error (void);
 
   void static_workspace_error (void)
   {
-    ::error ("can not add variable \"%s\" to a static workspace",
-             name ().c_str ());
+    error ("can not add variable \"%s\" to a static workspace",
+           name ().c_str ());
   }
 
   tree_identifier *dup (symbol_table::scope_id scope,
                         symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
   symbol_table::symbol_reference symbol (void) const
diff --git a/libinterp/parse-tree/pt-mat.cc b/libinterp/parse-tree/pt-mat.cc
--- a/libinterp/parse-tree/pt-mat.cc
+++ b/libinterp/parse-tree/pt-mat.cc
@@ -271,17 +271,17 @@ get_concat_class (const std::string& c1,
     }
 
   return retval;
 }
 
 static void
 eval_error (const char *msg, const dim_vector& x, const dim_vector& y)
 {
-  ::error ("%s (%s vs %s)", msg, x.str ().c_str (), y.str ().c_str ());
+  error ("%s (%s vs %s)", msg, x.str ().c_str (), y.str ().c_str ());
 }
 
 void
 tm_row_const::tm_row_const_rep::do_init_element (const octave_value& val,
                                                  bool& first_elem)
 {
   std::string this_elt_class_nm
     = val.is_object () ? std::string ("class") : val.class_name ();
