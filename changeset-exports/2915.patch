# HG changeset patch
# User jwe
# Date 862433594 0
#      Wed Apr 30 20:53:14 1997 +0000
# Node ID 649549662cf6248afe17e654bb65714fa84b0b3d
# Parent  d6a3e372373604eb5910f9061702160c83cdf530
[project @ 1997-04-30 20:51:40 by jwe]

diff --git a/src/oct-stream.cc b/src/oct-stream.cc
--- a/src/oct-stream.cc
+++ b/src/oct-stream.cc
@@ -2584,17 +2584,17 @@ octave_stream_list::do_get_info (const o
 
   int conv_err = 0;
 
   int int_fid = convert_to_valid_int (fid, conv_err);
 
   if (! conv_err)
     retval = do_get_info (int_fid);
   else
-    ::error ("file id must be valid integer");
+    ::error ("file id must be a file object or integer value");
 
   return retval;
 }
 
 string_vector
 octave_stream_list::get_info (int fid)
 {
   string_vector retval;
@@ -2724,17 +2724,17 @@ octave_stream_list::do_get_file_number (
     }
   else
     {
       int conv_err = 0;
 
       int int_fid = convert_to_valid_int (fid, conv_err);
 
       if (conv_err)
-	::error ("file id must be a string or integer value");
+	::error ("file id must be a file object, string, or integer value");
       else
 	retval = int_fid;
     }
 
   return retval;
 }
 
 int
diff --git a/src/op-b-b.cc b/src/op-b-b.cc
--- a/src/op-b-b.cc
+++ b/src/op-b-b.cc
@@ -27,38 +27,24 @@ Software Foundation, 59 Temple Place - S
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "gripes.h"
 #include "ov.h"
 #include "ov-bool.h"
 #include "ov-typeinfo.h"
-#include "op-b-b.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // bool by bool ops.
 
-static octave_value
-eq (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_bool&, const octave_bool&);
-
-  return octave_value (v1.bool_value () == v2.bool_value ());
-}
-
-static octave_value
-ne (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_bool&, const octave_bool&);
-
-  return octave_value (v1.bool_value () != v2.bool_value ());
-}
+DEFBINOP_OP (eq, bool, bool, ==)
+DEFBINOP_OP (ne, bool, bool, !=)
 
 void
 install_b_b_ops (void)
 {
   INSTALL_BINOP (eq, octave_bool, octave_bool, eq);
   INSTALL_BINOP (ne, octave_bool, octave_bool, ne);
 }
 
diff --git a/src/op-bm-bm.cc b/src/op-bm-bm.cc
--- a/src/op-bm-bm.cc
+++ b/src/op-bm-bm.cc
@@ -27,38 +27,24 @@ Software Foundation, 59 Temple Place - S
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "gripes.h"
 #include "ov.h"
 #include "ov-bool-mat.h"
 #include "ov-typeinfo.h"
-#include "op-b-b.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // bool matrix by bool matrix ops.
 
-static octave_value
-eq (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_bool_matrix&, const octave_bool_matrix&);
-
-  return octave_value (v1.bool_matrix_value () == v2.bool_matrix_value ());
-}
-
-static octave_value
-ne (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_bool_matrix&, const octave_bool_matrix&);
-
-  return octave_value (v1.bool_matrix_value () != v2.bool_matrix_value ());
-}
+DEFBINOP_OP (eq, bool_matrix, bool_matrix, ==)
+DEFBINOP_OP (ne, bool_matrix, bool_matrix, !=)
 
 void
 install_bm_bm_ops (void)
 {
   INSTALL_BINOP (eq, octave_bool_matrix, octave_bool_matrix, eq);
   INSTALL_BINOP (ne, octave_bool_matrix, octave_bool_matrix, ne);
 }
 
diff --git a/src/op-cm-cm.cc b/src/op-cm-cm.cc
--- a/src/op-cm-cm.cc
+++ b/src/op-cm-cm.cc
@@ -27,181 +27,58 @@ Software Foundation, 59 Temple Place - S
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "gripes.h"
 #include "ov.h"
 #include "ov-cx-mat.h"
 #include "ov-typeinfo.h"
-#include "op-cm-cm.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // complex matrix by complex matrix ops.
 
-static octave_value
-add (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
-
-  return octave_value (v1.complex_matrix_value ()
-		       + v2.complex_matrix_value ());
-}
-
-static octave_value
-sub (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
-
-  return octave_value (v1.complex_matrix_value ()
-		       - v2.complex_matrix_value ());
-}
+DEFBINOP_OP (add, complex_matrix, complex_matrix, +)
+DEFBINOP_OP (sub, complex_matrix, complex_matrix, -)
+DEFBINOP_OP (mul, complex_matrix, complex_matrix, *)
+DEFBINOP_FN (div, complex_matrix, complex_matrix, xdiv)
 
-static octave_value
-mul (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
-
-  return octave_value (v1.complex_matrix_value ()
-		       * v2.complex_matrix_value ());
-}
-
-static octave_value
-div (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
-
-  return xdiv (v1.complex_matrix_value (), v2.complex_matrix_value ());
-}
-
-static octave_value
-pow (const octave_value&, const octave_value&)
+DEFBINOPX (pow, complex_matrix, complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
-static octave_value
-ldiv (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
-
-  return xleftdiv (v1.complex_matrix_value (), v2.complex_matrix_value ());
-}
-
-static octave_value
-lt (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
-
-  return mx_el_lt (v1.complex_matrix_value (), v2.complex_matrix_value ());
-}
-
-static octave_value
-le (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
-
-  return mx_el_le (v1.complex_matrix_value (), v2.complex_matrix_value ());
-}
-
-static octave_value
-eq (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
-
-  return mx_el_eq (v1.complex_matrix_value (), v2.complex_matrix_value ());
-}
-
-static octave_value
-ge (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
-
-  return mx_el_ge (v1.complex_matrix_value (), v2.complex_matrix_value ());
-}
+DEFBINOP_FN (ldiv, complex_matrix, complex_matrix, xleftdiv)
 
-static octave_value
-gt (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
-
-  return mx_el_gt (v1.complex_matrix_value (), v2.complex_matrix_value ());
-}
-
-static octave_value
-ne (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
-
-  return mx_el_ne (v1.complex_matrix_value (), v2.complex_matrix_value ());
-}
-
-static octave_value
-el_mul (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
+DEFBINOP_FN (lt, complex_matrix, complex_matrix, mx_el_lt)
+DEFBINOP_FN (le, complex_matrix, complex_matrix, mx_el_le)
+DEFBINOP_FN (eq, complex_matrix, complex_matrix, mx_el_eq)
+DEFBINOP_FN (ge, complex_matrix, complex_matrix, mx_el_ge)
+DEFBINOP_FN (gt, complex_matrix, complex_matrix, mx_el_gt)
+DEFBINOP_FN (ne, complex_matrix, complex_matrix, mx_el_ne)
 
-  return octave_value (product (v1.complex_matrix_value (),
-				v2.complex_matrix_value ()));
-}
-
-static octave_value
-el_div (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
+DEFBINOP_FN (el_mul, complex_matrix, complex_matrix, product)
+DEFBINOP_FN (el_div, complex_matrix, complex_matrix, quotient)
+DEFBINOP_FN (el_pow, complex_matrix, complex_matrix, elem_xpow)
 
-  return octave_value (quotient (v1.complex_matrix_value (),
-				 v2.complex_matrix_value ()));
-}
-
-static octave_value
-el_pow (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
-
-  return elem_xpow (v1.complex_matrix_value (), v2.complex_matrix_value ());
-}
-
-static octave_value
-el_ldiv (const octave_value& a1, const octave_value& a2)
+DEFBINOP (el_ldiv, complex_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
   return octave_value (quotient (v2.complex_matrix_value (),
 				 v1.complex_matrix_value ()));
 }
 
-static octave_value
-el_and (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
-
-  return mx_el_and (v1.complex_matrix_value (), v2.complex_matrix_value ());
-}
-
-static octave_value
-el_or (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
+DEFBINOP_FN (el_and, complex_matrix, complex_matrix, mx_el_and)
+DEFBINOP_FN (el_or, complex_matrix, complex_matrix, mx_el_or)
 
-  return mx_el_or (v1.complex_matrix_value (), v2.complex_matrix_value ());
-}
-
-static octave_value
-assign (octave_value& a1, const octave_value_list& idx,
-	const octave_value& a2)
-{
-  CAST_BINOP_ARGS (octave_complex_matrix&, const octave_complex_matrix&);
-
-  v1.assign (idx, v2.complex_matrix_value ());
-  return octave_value ();
-}
+DEFASSIGNOP_FN (assign, complex_matrix, complex_matrix, assign)
 
 void
 install_cm_cm_ops (void)
 {
   INSTALL_BINOP (add, octave_complex_matrix, octave_complex_matrix, add);
   INSTALL_BINOP (sub, octave_complex_matrix, octave_complex_matrix, sub);
   INSTALL_BINOP (mul, octave_complex_matrix, octave_complex_matrix, mul);
   INSTALL_BINOP (div, octave_complex_matrix, octave_complex_matrix, div);
diff --git a/src/op-cm-cs.cc b/src/op-cm-cs.cc
--- a/src/op-cm-cs.cc
+++ b/src/op-cm-cs.cc
@@ -28,185 +28,79 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include "gripes.h"
 #include "ov.h"
 #include "ov-cx-mat.h"
 #include "ov-complex.h"
 #include "ov-typeinfo.h"
-#include "op-cm-cs.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // complex matrix by complex scalar ops.
 
-static octave_value
-add (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
-
-  return octave_value (v1.complex_matrix_value () + v2.complex_value ());
-}
-
-static octave_value
-sub (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
+DEFBINOP_OP (add, complex_matrix, complex, +)
+DEFBINOP_OP (sub, complex_matrix, complex, -)
+DEFBINOP_OP (mul, complex_matrix, complex, *)
 
-  return octave_value (v1.complex_matrix_value () - v2.complex_value ());
-}
-
-static octave_value
-mul (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
-
-  return octave_value (v1.complex_matrix_value () * v2.complex_value ());
-}
-
-static octave_value
-div (const octave_value& a1, const octave_value& a2)
+DEFBINOP (div, complex_matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
   Complex d = v2.complex_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v1.complex_matrix_value () / d);
 }
 
-static octave_value
-pow (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
-
-  return xpow (v1.complex_matrix_value (), v2.complex_value ());
-}
-
-static octave_value
-ldiv (const octave_value& v1, const octave_value&)
-{
-  gripe_nonconformant ("operator \\", v1.rows (), v1.columns (), 1, 1);
-  return octave_value ();
-}
+DEFBINOP_FN (pow, complex_matrix, complex, xpow)
 
-static octave_value
-lt (const octave_value& a1, const octave_value& a2)
+DEFBINOP (ldiv, complex_matrix, complex)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
-
-  return mx_el_lt (v1.complex_matrix_value (), v2.complex_value ());
-}
-
-static octave_value
-le (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
-
-  return mx_el_le (v1.complex_matrix_value (), v2.complex_value ());
+  BINOP_NONCONFORMANT ("operator \\");
 }
 
-static octave_value
-eq (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
-
-  return mx_el_eq (v1.complex_matrix_value (), v2.complex_value ());
-}
-
-static octave_value
-ge (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
-
-  return mx_el_ge (v1.complex_matrix_value (), v2.complex_value ());
-}
-
-static octave_value
-gt (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
+DEFBINOP_FN (lt, complex_matrix, complex, mx_el_lt)
+DEFBINOP_FN (le, complex_matrix, complex, mx_el_le)
+DEFBINOP_FN (eq, complex_matrix, complex, mx_el_eq)
+DEFBINOP_FN (ge, complex_matrix, complex, mx_el_ge)
+DEFBINOP_FN (gt, complex_matrix, complex, mx_el_gt)
+DEFBINOP_FN (ne, complex_matrix, complex, mx_el_ne)
 
-  return mx_el_gt (v1.complex_matrix_value (), v2.complex_value ());
-}
-
-static octave_value
-ne (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
-
-  return mx_el_ne (v1.complex_matrix_value (), v2.complex_value ());
-}
+DEFBINOP_OP (el_mul, complex_matrix, complex, *)
 
-static octave_value
-el_mul (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
-
-  return octave_value (v1.complex_matrix_value () * v2.complex_value ());
-}
-
-static octave_value
-el_div (const octave_value& a1, const octave_value& a2)
+DEFBINOP (el_div, complex_matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
   Complex d = v2.complex_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v1.complex_matrix_value () / d);
 }
 
-static octave_value
-el_pow (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
+DEFBINOP_FN (el_pow, complex_matrix, complex, elem_xpow)
 
-  return elem_xpow (v1.complex_matrix_value (), v2.complex_value ());
-}
-
-static octave_value
-el_ldiv (const octave_value& a1, const octave_value& a2)
+DEFBINOP (el_ldiv, complex_matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
   return x_el_div (v2.complex_value (), v1.complex_matrix_value ());
 }
 
-static octave_value
-el_and (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
-
-  return mx_el_and (v1.complex_matrix_value (), v2.complex_value ());
-}
-
-static octave_value
-el_or (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
+DEFBINOP_FN (el_and, complex_matrix, complex, mx_el_and)
+DEFBINOP_FN (el_or, complex_matrix, complex, mx_el_or)
 
-  return mx_el_or (v1.complex_matrix_value (), v2.complex_value ());
-}
-
-static octave_value
-assign (octave_value& a1, const octave_value_list& idx,
-	const octave_value& a2)
-{
-  CAST_BINOP_ARGS (octave_complex_matrix&, const octave_complex&);
-
-  v1.assign (idx, v2.complex_matrix_value ());
-  return octave_value ();
-}
+DEFASSIGNOP_FN (assign, complex_matrix, complex, assign)
 
 void
 install_cm_cs_ops (void)
 {
   INSTALL_BINOP (add, octave_complex_matrix, octave_complex, add);
   INSTALL_BINOP (sub, octave_complex_matrix, octave_complex, sub);
   INSTALL_BINOP (mul, octave_complex_matrix, octave_complex, mul);
   INSTALL_BINOP (div, octave_complex_matrix, octave_complex, div);
diff --git a/src/op-cm-m.cc b/src/op-cm-m.cc
--- a/src/op-cm-m.cc
+++ b/src/op-cm-m.cc
@@ -31,175 +31,63 @@ Software Foundation, 59 Temple Place - S
 #include "mx-cm-m.h"
 #include "mx-m-cm.h"
 
 #include "gripes.h"
 #include "ov.h"
 #include "ov-cx-mat.h"
 #include "ov-re-mat.h"
 #include "ov-typeinfo.h"
-#include "op-cm-m.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // complex matrix by matrix ops.
 
-static octave_value
-add (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
-
-  return octave_value (v1.complex_matrix_value () + v2.matrix_value ());
-}
-
-static octave_value
-sub (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
+DEFBINOP_OP (add, complex_matrix, matrix, +)
+DEFBINOP_OP (sub, complex_matrix, matrix, -)
+DEFBINOP_OP (mul, complex_matrix, matrix, *)
 
-  return octave_value (v1.complex_matrix_value () - v2.matrix_value ());
-}
-
-static octave_value
-mul (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
-
-  return octave_value (v1.complex_matrix_value () * v2.matrix_value ());
-}
-
-static octave_value
-div (const octave_value& a1, const octave_value& a2)
+DEFBINOP (div, complex_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
   return xdiv (v1.complex_matrix_value (), v2.matrix_value ());
 }
 
-static octave_value
-pow (const octave_value&, const octave_value&)
+DEFBINOPX (pow, complex_matrix, matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
-static octave_value
-ldiv (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
-
-  return xleftdiv (v1.complex_matrix_value (), v2.matrix_value ());
-}
-
-static octave_value
-lt (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
-
-  return mx_el_lt (v1.complex_matrix_value (), v2.matrix_value ());
-}
-
-static octave_value
-le (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
-
-  return mx_el_le (v1.complex_matrix_value (), v2.matrix_value ());
-}
-
-static octave_value
-eq (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
-
-  return mx_el_eq (v1.complex_matrix_value (), v2.matrix_value ());
-}
-
-static octave_value
-ge (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
-
-  return mx_el_ge (v1.complex_matrix_value (), v2.matrix_value ());
-}
+DEFBINOP_FN (ldiv, complex_matrix, matrix, xleftdiv)
 
-static octave_value
-gt (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
-
-  return mx_el_gt (v1.complex_matrix_value (), v2.matrix_value ());
-}
-
-static octave_value
-ne (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
-
-  return mx_el_ne (v1.complex_matrix_value (), v2.matrix_value ());
-}
-
-static octave_value
-el_mul (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
+DEFBINOP_FN (lt, complex_matrix, matrix, mx_el_lt)
+DEFBINOP_FN (le, complex_matrix, matrix, mx_el_le)
+DEFBINOP_FN (eq, complex_matrix, matrix, mx_el_eq)
+DEFBINOP_FN (ge, complex_matrix, matrix, mx_el_ge)
+DEFBINOP_FN (gt, complex_matrix, matrix, mx_el_gt)
+DEFBINOP_FN (ne, complex_matrix, matrix, mx_el_ne)
 
-  return product (v1.complex_matrix_value (), v2.matrix_value ());
-}
-
-static octave_value
-el_div (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
-
-  return quotient (v1.complex_matrix_value (), v2.matrix_value ());
-}
+DEFBINOP_FN (el_mul, complex_matrix, matrix, product)
+DEFBINOP_FN (el_div, complex_matrix, matrix, quotient)
+DEFBINOP_FN (el_pow, complex_matrix, matrix, elem_xpow)
 
-static octave_value
-el_pow (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
-
-  return elem_xpow (v1.complex_matrix_value (), v2.matrix_value ());
-}
-
-static octave_value
-el_ldiv (const octave_value& a1, const octave_value& a2)
+DEFBINOP (el_ldiv, complex_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
   return quotient (v2.matrix_value (), v1.complex_matrix_value ());
 }
 
-static octave_value
-el_and (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
-
-  return mx_el_and (v1.complex_matrix_value (), v2.matrix_value ());
-}
-
-static octave_value
-el_or (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
+DEFBINOP_FN (el_and, complex_matrix, matrix, mx_el_and)
+DEFBINOP_FN (el_or, complex_matrix, matrix, mx_el_or)
 
-  return mx_el_or (v1.complex_matrix_value (), v2.matrix_value ());
-}
-
-static octave_value
-assign (octave_value& a1, const octave_value_list& idx,
-	const octave_value& a2)
-{
-  CAST_BINOP_ARGS (octave_complex_matrix&, const octave_matrix&);
-
-  v1.assign (idx, v2.complex_matrix_value ());
-  return octave_value ();
-}
+DEFASSIGNOP_FN (assign, complex_matrix, matrix, assign)
 
 void
 install_cm_m_ops (void)
 {
   INSTALL_BINOP (add, octave_complex_matrix, octave_matrix, add);
   INSTALL_BINOP (sub, octave_complex_matrix, octave_matrix, sub);
   INSTALL_BINOP (mul, octave_complex_matrix, octave_matrix, mul);
   INSTALL_BINOP (div, octave_complex_matrix, octave_matrix, div);
diff --git a/src/op-cm-s.cc b/src/op-cm-s.cc
--- a/src/op-cm-s.cc
+++ b/src/op-cm-s.cc
@@ -30,185 +30,79 @@ Software Foundation, 59 Temple Place - S
 
 #include "mx-cm-s.h"
 
 #include "gripes.h"
 #include "ov.h"
 #include "ov-cx-mat.h"
 #include "ov-scalar.h"
 #include "ov-typeinfo.h"
-#include "op-cm-s.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // complex matrix by scalar ops.
 
-static octave_value
-add (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
-
-  return octave_value (v1.complex_matrix_value () + v2.double_value ());
-}
-
-static octave_value
-sub (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
+DEFBINOP_OP (add, complex_matrix, scalar, +)
+DEFBINOP_OP (sub, complex_matrix, scalar, -)
+DEFBINOP_OP (mul, complex_matrix, scalar, *)
 
-  return octave_value (v1.complex_matrix_value () - v2.double_value ());
-}
-
-static octave_value
-mul (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
-
-  return octave_value (v1.complex_matrix_value () * v2.double_value ());
-}
-
-static octave_value
-div (const octave_value& a1, const octave_value& a2)
+DEFBINOP (div, complex_matrix, scalar)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
   double d = v2.double_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v1.complex_matrix_value () / d);
 }
 
-static octave_value
-pow (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
-
-  return xpow (v1.complex_matrix_value (), v2.double_value ());
-}
-
-static octave_value
-ldiv (const octave_value& v1, const octave_value&)
-{
-  gripe_nonconformant ("operator \\", v1.rows (), v1.columns (), 1, 1);
-  return octave_value ();
-}
+DEFBINOP_FN (pow, complex_matrix, scalar, xpow)
 
-static octave_value
-lt (const octave_value& a1, const octave_value& a2)
+DEFBINOP (ldiv, complex_matrix, scalar)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
-
-  return mx_el_lt (v1.complex_matrix_value (), v2.double_value ());
-}
-
-static octave_value
-le (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
-
-  return mx_el_le (v1.complex_matrix_value (), v2.double_value ());
+  BINOP_NONCONFORMANT ("operator \\");
 }
 
-static octave_value
-eq (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
-
-  return mx_el_eq (v1.complex_matrix_value (), v2.double_value ());
-}
-
-static octave_value
-ge (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
-
-  return mx_el_ge (v1.complex_matrix_value (), v2.double_value ());
-}
-
-static octave_value
-gt (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
+DEFBINOP_FN (lt, complex_matrix, scalar, mx_el_lt)
+DEFBINOP_FN (le, complex_matrix, scalar, mx_el_le)
+DEFBINOP_FN (eq, complex_matrix, scalar, mx_el_eq)
+DEFBINOP_FN (ge, complex_matrix, scalar, mx_el_ge)
+DEFBINOP_FN (gt, complex_matrix, scalar, mx_el_gt)
+DEFBINOP_FN (ne, complex_matrix, scalar, mx_el_ne)
 
-  return mx_el_gt (v1.complex_matrix_value (), v2.double_value ());
-}
-
-static octave_value
-ne (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
-
-  return mx_el_ne (v1.complex_matrix_value (), v2.double_value ());
-}
+DEFBINOP_OP (el_mul, complex_matrix, scalar, *)
 
-static octave_value
-el_mul (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
-
-  return octave_value (v1.complex_matrix_value () * v2.double_value ());
-}
-
-static octave_value
-el_div (const octave_value& a1, const octave_value& a2)
+DEFBINOP (el_div, complex_matrix, scalar)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
   double d = v2.double_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v1.complex_matrix_value () / d);
 }
 
-static octave_value
-el_pow (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
+DEFBINOP_FN (el_pow, complex_matrix, scalar, elem_xpow)
 
-  return elem_xpow (v1.complex_matrix_value (), v2.double_value ());
-}
-
-static octave_value
-el_ldiv (const octave_value& a1, const octave_value& a2)
+DEFBINOP (el_ldiv, complex_matrix, scalar)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
   return x_el_div (v2.double_value (), v1.complex_matrix_value ());
 }
 
-static octave_value
-el_and (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
-
-  return mx_el_and (v1.complex_matrix_value (), v2.double_value ());
-}
-
-static octave_value
-el_or (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
+DEFBINOP_FN (el_and, complex_matrix, scalar, mx_el_and)
+DEFBINOP_FN (el_or, complex_matrix, scalar, mx_el_or)
 
-  return mx_el_or (v1.complex_matrix_value (), v2.double_value ());
-}
-
-static octave_value
-assign (octave_value& a1, const octave_value_list& idx,
-	const octave_value& a2)
-{
-  CAST_BINOP_ARGS (octave_complex_matrix&, const octave_scalar&);
-
-  v1.assign (idx, v2.complex_matrix_value ());
-  return octave_value ();
-}
+DEFASSIGNOP_FN (assign, complex_matrix, scalar, assign)
 
 void
 install_cm_s_ops (void)
 {
   INSTALL_BINOP (add, octave_complex_matrix, octave_scalar, add);
   INSTALL_BINOP (sub, octave_complex_matrix, octave_scalar, sub);
   INSTALL_BINOP (mul, octave_complex_matrix, octave_scalar, mul);
   INSTALL_BINOP (div, octave_complex_matrix, octave_scalar, div);
diff --git a/src/op-cs-cm.cc b/src/op-cs-cm.cc
--- a/src/op-cs-cm.cc
+++ b/src/op-cs-cm.cc
@@ -28,178 +28,72 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include "gripes.h"
 #include "ov.h"
 #include "ov-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-typeinfo.h"
-#include "op-cs-cm.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // complex scalar by complex matrix ops.
 
-static octave_value
-add (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
+DEFBINOP_OP (add, complex, complex_matrix, +)
+DEFBINOP_OP (sub, complex, complex_matrix, -)
+DEFBINOP_OP (mul, complex, complex_matrix, *)
 
-  return octave_value (v1.complex_value () + v2.complex_matrix_value ());
-}
-
-static octave_value
-sub (const octave_value& a1, const octave_value& a2)
+DEFBINOP (div, complex, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
-
-  return octave_value (v1.complex_value () - v2.complex_matrix_value ());
+  BINOP_NONCONFORMANT ("operator /");
 }
 
-static octave_value
-mul (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
-
-  return octave_value (v1.complex_value () * v2.complex_matrix_value ());
-}
+DEFBINOP_FN (pow, complex, complex_matrix, xpow)
 
-static octave_value
-div (const octave_value&, const octave_value& v2)
-{
-  gripe_nonconformant ("operator /", 1, 1, v2.rows (), v2.columns ());
-  return octave_value ();
-}
-
-static octave_value
-pow (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
-
-  return xpow (v1.complex_value (), v2.complex_matrix_value ());
-}
-
-static octave_value
-ldiv (const octave_value& a1, const octave_value& a2)
+DEFBINOP (ldiv, complex, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
   Complex d = v1.complex_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v2.complex_matrix_value () / d);
 }
 
-static octave_value
-lt (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
-
-  return mx_el_lt (v1.complex_value (), v2.complex_matrix_value ());
-}
-
-static octave_value
-le (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
-
-  return mx_el_le (v1.complex_value (), v2.complex_matrix_value ());
-}
-
-static octave_value
-eq (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
-
-  return mx_el_eq (v1.complex_value (), v2.complex_matrix_value ());
-}
-
-static octave_value
-ge (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
-
-  return mx_el_ge (v1.complex_value (), v2.complex_matrix_value ());
-}
-
-static octave_value
-gt (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
+DEFBINOP_FN (lt, complex, complex_matrix, mx_el_lt)
+DEFBINOP_FN (le, complex, complex_matrix, mx_el_le)
+DEFBINOP_FN (eq, complex, complex_matrix, mx_el_eq)
+DEFBINOP_FN (ge, complex, complex_matrix, mx_el_ge)
+DEFBINOP_FN (gt, complex, complex_matrix, mx_el_gt)
+DEFBINOP_FN (ne, complex, complex_matrix, mx_el_ne)
 
-  return mx_el_gt (v1.complex_value (), v2.complex_matrix_value ());
-}
-
-static octave_value
-ne (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
-
-  return mx_el_ne (v1.complex_value (), v2.complex_matrix_value ());
-}
-
-static octave_value
-el_mul (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
-
-  return octave_value (v1.complex_value () * v2.complex_matrix_value ());
-}
+DEFBINOP_OP (el_mul, complex, complex_matrix, *)
+DEFBINOP_FN (el_div, complex, complex_matrix, x_el_div)
+DEFBINOP_FN (el_pow, complex, complex_matrix, elem_xpow)
 
-static octave_value
-el_div (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
-
-  return x_el_div (v1.complex_value (), v2.complex_matrix_value ());
-}
-
-static octave_value
-el_pow (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
-
-  return elem_xpow (v1.complex_value (), v2.complex_matrix_value ());
-}
-
-static octave_value
-el_ldiv (const octave_value& a1, const octave_value& a2)
+DEFBINOP (el_ldiv, complex, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
   Complex d = v1.complex_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v2.complex_matrix_value () / d);
 }
 
-static octave_value
-el_and (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
-
-  return mx_el_and (v1.complex_value (), v2.complex_matrix_value ());
-}
+DEFBINOP_FN (el_and, complex, complex_matrix, mx_el_and)
+DEFBINOP_FN (el_or, complex, complex_matrix, mx_el_or)
 
-static octave_value
-el_or (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
-
-  return mx_el_or (v1.complex_value (), v2.complex_matrix_value ());
-}
-
-static octave_value *
-complex_matrix_conv (const octave_value& a)
+DEFCONV (complex_matrix_conv, complex, complex_matrix)
 {
   CAST_CONV_ARG (const octave_complex&);
 
   return new octave_complex_matrix (v.complex_matrix_value ());
 }
 
 void
 install_cs_cm_ops (void)
diff --git a/src/op-cs-cs.cc b/src/op-cs-cs.cc
--- a/src/op-cs-cs.cc
+++ b/src/op-cs-cs.cc
@@ -28,189 +28,137 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include "gripes.h"
 #include "ov.h"
 #include "ov-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-typeinfo.h"
-#include "op-cs-cs.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // complex scalar by complex scalar ops.
 
-static octave_value
-add (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_complex&);
-
-  return octave_value (v1.complex_value () + v2.complex_value ());
-}
-
-static octave_value
-sub (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_complex&);
+DEFBINOP_OP (add, complex, complex, +)
+DEFBINOP_OP (sub, complex, complex, -)
+DEFBINOP_OP (mul, complex, complex, *)
 
-  return octave_value (v1.complex_value () - v2.complex_value ());
-}
-
-static octave_value
-mul (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_complex&);
-
-  return octave_value (v1.complex_value () * v2.complex_value ());
-}
-
-static octave_value
-div (const octave_value& a1, const octave_value& a2)
+DEFBINOP (div, complex, complex)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex&);
 
   Complex d = v2.complex_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v1.complex_value () / d);
 }
 
-static octave_value
-pow (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_complex&);
+DEFBINOP_FN (pow, complex, complex, xpow)
 
-  return xpow (v1.complex_value (), v2.complex_value ());
-}
-
-static octave_value
-ldiv (const octave_value& a1, const octave_value& a2)
+DEFBINOP (ldiv, complex, complex)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex&);
 
   Complex d = v1.complex_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v2.complex_value () / d);
 }
 
-static octave_value
-lt (const octave_value& a1, const octave_value& a2)
+DEFBINOP (lt, complex, complex)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex&);
 
   return real (v1.complex_value ()) < real (v2.complex_value ());
 }
 
-static octave_value
-le (const octave_value& a1, const octave_value& a2)
+DEFBINOP (le, complex, complex)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex&);
 
   return real (v1.complex_value ()) <= real (v2.complex_value ());
 }
 
-static octave_value
-eq (const octave_value& a1, const octave_value& a2)
+DEFBINOP (eq, complex, complex)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex&);
 
   return v1.complex_value () == v2.complex_value ();
 }
 
-static octave_value
-ge (const octave_value& a1, const octave_value& a2)
+DEFBINOP (ge, complex, complex)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex&);
 
   return real (v1.complex_value ()) >= real (v2.complex_value ());
 }
 
-static octave_value
-gt (const octave_value& a1, const octave_value& a2)
+DEFBINOP (gt, complex, complex)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex&);
 
   return real (v1.complex_value ()) > real (v2.complex_value ());
 }
 
-static octave_value
-ne (const octave_value& a1, const octave_value& a2)
+DEFBINOP (ne, complex, complex)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex&);
 
   return v1.complex_value () != v2.complex_value ();
 }
 
-static octave_value
-el_mul (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_complex&);
+DEFBINOP_OP (el_mul, complex, complex, *)
 
-  return octave_value (v1.complex_value () * v2.complex_value ());
-}
-
-static octave_value
-el_div (const octave_value& a1, const octave_value& a2)
+DEFBINOP (el_div, complex, complex)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex&);
 
   Complex d = v2.complex_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v1.complex_value () / d);
 }
 
-static octave_value
-el_pow (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_complex&);
+DEFBINOP_FN (el_pow, complex, complex, xpow)
 
-  return xpow (v1.complex_value (), v2.complex_value ());
-}
-
-static octave_value
-el_ldiv (const octave_value& a1, const octave_value& a2)
+DEFBINOP (el_ldiv, complex, complex)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex&);
 
   Complex d = v1.complex_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v2.complex_value () / d);
 }
 
-static octave_value
-el_and (const octave_value& a1, const octave_value& a2)
+DEFBINOP (el_and, complex, complex)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex&);
 
   return v1.complex_value () != 0.0 && v2.complex_value () != 0.0;
 }
 
-static octave_value
-el_or (const octave_value& a1, const octave_value& a2)
+DEFBINOP (el_or, complex, complex)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex&);
 
   return v1.complex_value () != 0.0 || v2.complex_value () != 0.0;
 }
 
-static octave_value *
-complex_matrix_conv (const octave_value& a)
+DEFCONV (complex_matrix_conv, complex, complex_matrix)
 {
   CAST_CONV_ARG (const octave_complex&);
 
   return new octave_complex_matrix (v.complex_matrix_value ());
 }
 
 void
 install_cs_cs_ops (void)
diff --git a/src/op-cs-m.cc b/src/op-cs-m.cc
--- a/src/op-cs-m.cc
+++ b/src/op-cs-m.cc
@@ -32,178 +32,72 @@ Software Foundation, 59 Temple Place - S
 #include "mx-m-cs.h"
 
 #include "gripes.h"
 #include "ov.h"
 #include "ov-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-re-mat.h"
 #include "ov-typeinfo.h"
-#include "op-cs-m.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // complex scalar by matrix ops.
 
-static octave_value
-add (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
+DEFBINOP_OP (add, complex, matrix, +)
+DEFBINOP_OP (sub, complex, matrix, -)
+DEFBINOP_OP (mul, complex, matrix, *)
 
-  return octave_value (v1.complex_value () + v2.matrix_value ());
-}
-
-static octave_value
-sub (const octave_value& a1, const octave_value& a2)
+DEFBINOP (div, complex, matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
-
-  return octave_value (v1.complex_value () - v2.matrix_value ());
+  BINOP_NONCONFORMANT ("operator /");
 }
 
-static octave_value
-mul (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
-
-  return octave_value (v1.complex_value () * v2.matrix_value ());
-}
+DEFBINOP_FN (pow, complex, matrix, xpow)
 
-static octave_value
-div (const octave_value&, const octave_value& v2)
-{
-  gripe_nonconformant ("operator /", 1, 1, v2.rows (), v2.columns ());
-  return octave_value ();
-}
-
-static octave_value
-pow (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
-
-  return xpow (v1.complex_value (), v2.matrix_value ());
-}
-
-static octave_value
-ldiv (const octave_value& a1, const octave_value& a2)
+DEFBINOP (ldiv, complex, matrix)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
 
   Complex d = v1.complex_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v2.matrix_value () / d);
 }
 
-static octave_value
-lt (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
-
-  return mx_el_lt (v1.complex_value (), v2.matrix_value ());
-}
-
-static octave_value
-le (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
-
-  return mx_el_le (v1.complex_value (), v2.matrix_value ());
-}
-
-static octave_value
-eq (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
-
-  return mx_el_eq (v1.complex_value (), v2.matrix_value ());
-}
-
-static octave_value
-ge (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
-
-  return mx_el_ge (v1.complex_value (), v2.matrix_value ());
-}
-
-static octave_value
-gt (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
+DEFBINOP_FN (lt, complex, matrix, mx_el_lt)
+DEFBINOP_FN (le, complex, matrix, mx_el_le)
+DEFBINOP_FN (eq, complex, matrix, mx_el_eq)
+DEFBINOP_FN (ge, complex, matrix, mx_el_ge)
+DEFBINOP_FN (gt, complex, matrix, mx_el_gt)
+DEFBINOP_FN (ne, complex, matrix, mx_el_ne)
 
-  return mx_el_gt (v1.complex_value (), v2.matrix_value ());
-}
-
-static octave_value
-ne (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
-
-  return mx_el_ne (v1.complex_value (), v2.matrix_value ());
-}
-
-static octave_value
-el_mul (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
-
-  return octave_value (v1.complex_value () * v2.matrix_value ());
-}
+DEFBINOP_OP (el_mul, complex, matrix, *)
+DEFBINOP_FN (el_div, complex, matrix, x_el_div)
+DEFBINOP_FN (el_pow, complex, matrix, elem_xpow)
 
-static octave_value
-el_div (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
-
-  return x_el_div (v1.complex_value (), v2.matrix_value ());
-}
-
-static octave_value
-el_pow (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
-
-  return elem_xpow (v1.complex_value (), v2.matrix_value ());
-}
-
-static octave_value
-el_ldiv (const octave_value& a1, const octave_value& a2)
+DEFBINOP (el_ldiv, complex, matrix)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
 
   Complex d = v1.complex_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v2.matrix_value () / d);
 }
 
-static octave_value
-el_and (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
-
-  return mx_el_and (v1.complex_value (), v2.matrix_value ());
-}
+DEFBINOP_FN (el_and, complex, matrix, mx_el_and)
+DEFBINOP_FN (el_or, complex, matrix, mx_el_or)
 
-static octave_value
-el_or (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
-
-  return mx_el_or (v1.complex_value (), v2.matrix_value ());
-}
-
-static octave_value *
-complex_matrix_conv (const octave_value& a)
+DEFCONV (complex_matrix_conv, complex, complex_matrix)
 {
   CAST_CONV_ARG (const octave_complex&);
 
   return new octave_complex_matrix (v.complex_matrix_value ());
 }
 
 void
 install_cs_m_ops (void)
diff --git a/src/op-cs-s.cc b/src/op-cs-s.cc
--- a/src/op-cs-s.cc
+++ b/src/op-cs-s.cc
@@ -29,189 +29,137 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include "gripes.h"
 #include "ov.h"
 #include "ov-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-scalar.h"
 #include "ov-typeinfo.h"
-#include "op-cs-s.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // complex scalar by scalar ops.
 
-static octave_value
-add (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_scalar&);
-
-  return octave_value (v1.complex_value () + v2.double_value ());
-}
-
-static octave_value
-sub (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_scalar&);
+DEFBINOP_OP (add, complex, scalar, +)
+DEFBINOP_OP (sub, complex, scalar, -)
+DEFBINOP_OP (mul, complex, scalar, *)
 
-  return octave_value (v1.complex_value () - v2.double_value ());
-}
-
-static octave_value
-mul (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_scalar&);
-
-  return octave_value (v1.complex_value () * v2.double_value ());
-}
-
-static octave_value
-div (const octave_value& a1, const octave_value& a2)
+DEFBINOP (div, complex, scalar)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_scalar&);
 
   double d = v2.double_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v1.complex_value () / d);
 }
 
-static octave_value
-pow (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_scalar&);
+DEFBINOP_FN (pow, complex, scalar, xpow)
 
-  return xpow (v1.complex_value (), v2.double_value ());
-}
-
-static octave_value
-ldiv (const octave_value& a1, const octave_value& a2)
+DEFBINOP (ldiv, complex, scalar)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_scalar&);
 
   double d = v1.double_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v2.complex_value () / d);
 }
 
-static octave_value
-lt (const octave_value& a1, const octave_value& a2)
+DEFBINOP (lt, complex, scalar)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_scalar&);
 
   return real (v1.complex_value ()) < v2.double_value ();
 }
 
-static octave_value
-le (const octave_value& a1, const octave_value& a2)
+DEFBINOP (le, complex, scalar)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_scalar&);
 
   return real (v1.complex_value ()) <= v2.double_value ();
 }
 
-static octave_value
-eq (const octave_value& a1, const octave_value& a2)
+DEFBINOP (eq, complex, scalar)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_scalar&);
 
   return v1.complex_value () == v2.double_value ();
 }
 
-static octave_value
-ge (const octave_value& a1, const octave_value& a2)
+DEFBINOP (ge, complex, scalar)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_scalar&);
 
   return real (v1.complex_value ()) >= v2.double_value ();
 }
 
-static octave_value
-gt (const octave_value& a1, const octave_value& a2)
+DEFBINOP (gt, complex, scalar)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_scalar&);
 
   return real (v1.complex_value ()) > v2.double_value ();
 }
 
-static octave_value
-ne (const octave_value& a1, const octave_value& a2)
+DEFBINOP (ne, complex, scalar)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_scalar&);
 
   return v1.complex_value () != v2.double_value ();
 }
 
-static octave_value
-el_mul (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_scalar&);
+DEFBINOP_OP (el_mul, complex, scalar, *)
 
-  return octave_value (v1.complex_value () * v2.double_value ());
-}
-
-static octave_value
-el_div (const octave_value& a1, const octave_value& a2)
+DEFBINOP (el_div, complex, scalar)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_scalar&);
 
   double d = v2.double_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v1.complex_value () / d);
 }
 
-static octave_value
-el_pow (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_complex&, const octave_scalar&);
+DEFBINOP_FN (el_pow, complex, scalar, xpow)
 
-  return xpow (v1.complex_value (), v2.double_value ());
-}
-
-static octave_value
-el_ldiv (const octave_value& a1, const octave_value& a2)
+DEFBINOP (el_ldiv, complex, scalar)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_scalar&);
 
   double d = v1.double_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v2.complex_value () / d);
 }
 
-static octave_value
-el_and (const octave_value& a1, const octave_value& a2)
+DEFBINOP (el_and, complex, scalar)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_scalar&);
 
   return v1.complex_value () != 0.0 && v2.double_value ();
 }
 
-static octave_value
-el_or (const octave_value& a1, const octave_value& a2)
+DEFBINOP (el_or, complex, scalar)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_scalar&);
 
   return v1.complex_value () != 0.0 || v2.double_value ();
 }
 
-static octave_value *
-complex_matrix_conv (const octave_value& a)
+DEFCONV (complex_matrix_conv, complex, complex_matrix)
 {
   CAST_CONV_ARG (const octave_complex&);
 
   return new octave_complex_matrix (v.complex_matrix_value ());
 }
 
 void
 install_cs_s_ops (void)
diff --git a/src/op-m-cm.cc b/src/op-m-cm.cc
--- a/src/op-m-cm.cc
+++ b/src/op-m-cm.cc
@@ -31,168 +31,63 @@ Software Foundation, 59 Temple Place - S
 #include "mx-m-cm.h"
 #include "mx-cm-m.h"
 
 #include "gripes.h"
 #include "ov.h"
 #include "ov-re-mat.h"
 #include "ov-cx-mat.h"
 #include "ov-typeinfo.h"
-#include "op-m-cm.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // matrix by complex matrix ops.
 
-static octave_value
-add (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
-
-  return octave_value (v1.matrix_value () + v2.complex_matrix_value ());
-}
-
-static octave_value
-sub (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
+DEFBINOP_OP (add, matrix, complex_matrix, +)
+DEFBINOP_OP (sub, matrix, complex_matrix, -)
+DEFBINOP_OP (mul, matrix, complex_matrix, *)
 
-  return octave_value (v1.matrix_value () - v2.complex_matrix_value ());
-}
-
-static octave_value
-mul (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
-
-  return octave_value (v1.matrix_value () * v2.complex_matrix_value ());
-}
-
-static octave_value
-div (const octave_value& a1, const octave_value& a2)
+DEFBINOP (div, matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
   return xdiv (v1.matrix_value (), v2.complex_matrix_value ());
 }
 
-static octave_value
-pow (const octave_value&, const octave_value&)
+DEFBINOPX (pow, matrix, complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
-static octave_value
-ldiv (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
-
-  return xleftdiv (v1.matrix_value (), v2.complex_matrix_value ());
-}
-
-static octave_value
-lt (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
-
-  return mx_el_lt (v1.matrix_value (), v2.complex_matrix_value ());
-}
-
-static octave_value
-le (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
-
-  return mx_el_le (v1.matrix_value (), v2.complex_matrix_value ());
-}
-
-static octave_value
-eq (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
-
-  return mx_el_eq (v1.matrix_value (), v2.complex_matrix_value ());
-}
-
-static octave_value
-ge (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
-
-  return mx_el_ge (v1.matrix_value (), v2.complex_matrix_value ());
-}
+DEFBINOP_FN (ldiv, matrix, complex_matrix, xleftdiv)
 
-static octave_value
-gt (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
-
-  return mx_el_gt (v1.matrix_value (), v2.complex_matrix_value ());
-}
-
-static octave_value
-ne (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
-
-  return mx_el_ne (v1.matrix_value (), v2.complex_matrix_value ());
-}
-
-static octave_value
-el_mul (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
+DEFBINOP_FN (lt, matrix, complex_matrix, mx_el_lt)
+DEFBINOP_FN (le, matrix, complex_matrix, mx_el_le)
+DEFBINOP_FN (eq, matrix, complex_matrix, mx_el_eq)
+DEFBINOP_FN (ge, matrix, complex_matrix, mx_el_ge)
+DEFBINOP_FN (gt, matrix, complex_matrix, mx_el_gt)
+DEFBINOP_FN (ne, matrix, complex_matrix, mx_el_ne)
 
-  return product (v1.matrix_value (), v2.complex_matrix_value ());
-}
-
-static octave_value
-el_div (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
-
-  return quotient (v1.matrix_value (), v2.complex_matrix_value ());
-}
+DEFBINOP_FN (el_mul, matrix, complex_matrix, product)
+DEFBINOP_FN (el_div, matrix, complex_matrix, quotient)
+DEFBINOP_FN (el_pow, matrix, complex_matrix, elem_xpow)
 
-static octave_value
-el_pow (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
-
-  return elem_xpow (v1.matrix_value (), v2.complex_matrix_value ());
-}
-
-static octave_value
-el_ldiv (const octave_value& a1, const octave_value& a2)
+DEFBINOP (el_ldiv, matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
   return quotient (v2.complex_matrix_value (), v1.matrix_value ());
 }
 
-static octave_value
-el_and (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
-
-  return mx_el_and (v1.matrix_value (), v2.complex_matrix_value ());
-}
+DEFBINOP_FN (el_and, matrix, complex_matrix, mx_el_and)
+DEFBINOP_FN (el_or, matrix, complex_matrix, mx_el_or)
 
-static octave_value
-el_or (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
-
-  return mx_el_or (v1.matrix_value (), v2.complex_matrix_value ());
-}
-
-static octave_value *
-complex_matrix_conv (const octave_value& a)
+DEFCONV (complex_matrix_conv, matrix, complex_matrix)
 {
   CAST_CONV_ARG (const octave_matrix&);
 
   return new octave_complex_matrix (ComplexMatrix (v.matrix_value ()));
 }
 
 void
 install_m_cm_ops (void)
diff --git a/src/op-m-cs.cc b/src/op-m-cs.cc
--- a/src/op-m-cs.cc
+++ b/src/op-m-cs.cc
@@ -32,178 +32,79 @@ Software Foundation, 59 Temple Place - S
 #include "mx-cs-m.h"
 
 #include "gripes.h"
 #include "ov.h"
 #include "ov-re-mat.h"
 #include "ov-cx-mat.h"
 #include "ov-complex.h"
 #include "ov-typeinfo.h"
-#include "op-m-cs.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // matrix by complex scalar ops.
 
-static octave_value
-add (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
-
-  return octave_value (v1.matrix_value () + v2.complex_value ());
-}
-
-static octave_value
-sub (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
+DEFBINOP_OP (add, matrix, complex, +)
+DEFBINOP_OP (sub, matrix, complex, -)
+DEFBINOP_OP (mul, matrix, complex, *)
 
-  return octave_value (v1.matrix_value () - v2.complex_value ());
-}
-
-static octave_value
-mul (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
-
-  return octave_value (v1.matrix_value () * v2.complex_value ());
-}
-
-static octave_value
-div (const octave_value& a1, const octave_value& a2)
+DEFBINOP (div, matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
   Complex d = v2.complex_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v1.matrix_value () / d);
 }
 
-static octave_value
-pow (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
-
-  return xpow (v1.matrix_value (), v2.complex_value ());
-}
-
-static octave_value
-ldiv (const octave_value& v1, const octave_value&)
-{
-  gripe_nonconformant ("operator \\", v1.rows (), v1.columns (), 1, 1);
-  return octave_value ();
-}
+DEFBINOP_FN (pow, matrix, complex, xpow)
 
-static octave_value
-lt (const octave_value& a1, const octave_value& a2)
+DEFBINOP (ldiv, matrix, complex)
 {
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
-
-  return mx_el_lt (v1.matrix_value (), v2.complex_value ());
-}
-
-static octave_value
-le (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
-
-  return mx_el_le (v1.matrix_value (), v2.complex_value ());
+  BINOP_NONCONFORMANT ("operator \\");
 }
 
-static octave_value
-eq (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
-
-  return mx_el_eq (v1.matrix_value (), v2.complex_value ());
-}
-
-static octave_value
-ge (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
-
-  return mx_el_ge (v1.matrix_value (), v2.complex_value ());
-}
-
-static octave_value
-gt (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
+DEFBINOP_FN (lt, matrix, complex, mx_el_lt)
+DEFBINOP_FN (le, matrix, complex, mx_el_le)
+DEFBINOP_FN (eq, matrix, complex, mx_el_eq)
+DEFBINOP_FN (ge, matrix, complex, mx_el_ge)
+DEFBINOP_FN (gt, matrix, complex, mx_el_gt)
+DEFBINOP_FN (ne, matrix, complex, mx_el_ne)
 
-  return mx_el_gt (v1.matrix_value (), v2.complex_value ());
-}
-
-static octave_value
-ne (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
-
-  return mx_el_ne (v1.matrix_value (), v2.complex_value ());
-}
+DEFBINOP_OP (el_mul, matrix, complex, *)
 
-static octave_value
-el_mul (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
-
-  return octave_value (v1.matrix_value () * v2.complex_value ());
-}
-
-static octave_value
-el_div (const octave_value& a1, const octave_value& a2)
+DEFBINOP (el_div, matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
   Complex d = v2.complex_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v1.matrix_value () / d);
 }
 
-static octave_value
-el_pow (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
+DEFBINOP_FN (el_pow, matrix, complex, elem_xpow)
 
-  return elem_xpow (v1.matrix_value (), v2.complex_value ());
-}
-
-static octave_value
-el_ldiv (const octave_value& a1, const octave_value& a2)
+DEFBINOP (el_ldiv, matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
   return x_el_div (v2.complex_value (), v1.matrix_value ());
 }
 
-static octave_value
-el_and (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
-
-  return mx_el_and (v1.matrix_value (), v2.complex_value ());
-}
+DEFBINOP_FN (el_and, matrix, complex, mx_el_and)
+DEFBINOP_FN (el_or, matrix, complex, mx_el_or)
 
-static octave_value
-el_or (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
-
-  return mx_el_or (v1.matrix_value (), v2.complex_value ());
-}
-
-static octave_value *
-complex_matrix_conv (const octave_value& a)
+DEFCONV (complex_matrix_conv, matrix, complex_matrix)
 {
   CAST_CONV_ARG (const octave_matrix&);
 
   return new octave_complex_matrix (ComplexMatrix (v.matrix_value ()));
 }
 
 void
 install_m_cs_ops (void)
diff --git a/src/op-m-m.cc b/src/op-m-m.cc
--- a/src/op-m-m.cc
+++ b/src/op-m-m.cc
@@ -27,175 +27,63 @@ Software Foundation, 59 Temple Place - S
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "gripes.h"
 #include "ov.h"
 #include "ov-re-mat.h"
 #include "ov-typeinfo.h"
-#include "op-m-m.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // matrix by matrix ops.
 
-static octave_value
-add (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
-
-  return octave_value (v1.matrix_value () + v2.matrix_value ());
-}
-
-static octave_value
-sub (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
+DEFBINOP_OP (add, matrix, matrix, +)
+DEFBINOP_OP (sub, matrix, matrix, -)
+DEFBINOP_OP (mul, matrix, matrix, *)
 
-  return octave_value (v1.matrix_value () - v2.matrix_value ());
-}
-
-static octave_value
-mul (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
-
-  return octave_value (v1.matrix_value () * v2.matrix_value ());
-}
-
-static octave_value
-div (const octave_value& a1, const octave_value& a2)
+DEFBINOP (div, matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
   return xdiv (v1.matrix_value (), v2.matrix_value ());
 }
 
-static octave_value
-pow (const octave_value&, const octave_value&)
+DEFBINOPX (pow, matrix, matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
-static octave_value
-ldiv (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
-
-  return xleftdiv (v1.matrix_value (), v2.matrix_value ());
-}
-
-static octave_value
-lt (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
-
-  return mx_el_lt (v1.matrix_value (), v2.matrix_value ());
-}
-
-static octave_value
-le (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
-
-  return mx_el_le (v1.matrix_value (), v2.matrix_value ());
-}
-
-static octave_value
-eq (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
-
-  return mx_el_eq (v1.matrix_value (), v2.matrix_value ());
-}
-
-static octave_value
-ge (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
-
-  return mx_el_ge (v1.matrix_value (), v2.matrix_value ());
-}
+DEFBINOP_FN (ldiv, matrix, matrix, xleftdiv)
 
-static octave_value
-gt (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
-
-  return mx_el_gt (v1.matrix_value (), v2.matrix_value ());
-}
-
-static octave_value
-ne (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
-
-  return mx_el_ne (v1.matrix_value (), v2.matrix_value ());
-}
-
-static octave_value
-el_mul (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
+DEFBINOP_FN (lt, matrix, matrix, mx_el_lt)
+DEFBINOP_FN (le, matrix, matrix, mx_el_le)
+DEFBINOP_FN (eq, matrix, matrix, mx_el_eq)
+DEFBINOP_FN (ge, matrix, matrix, mx_el_ge)
+DEFBINOP_FN (gt, matrix, matrix, mx_el_gt)
+DEFBINOP_FN (ne, matrix, matrix, mx_el_ne)
 
-  return octave_value (product (v1.matrix_value (), v2.matrix_value ()));
-}
-
-static octave_value
-el_div (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
-
-  return octave_value (quotient (v1.matrix_value (), v2.matrix_value ()));
-}
+DEFBINOP_FN (el_mul, matrix, matrix, product)
+DEFBINOP_FN (el_div, matrix, matrix, quotient)
+DEFBINOP_FN (el_pow, matrix, matrix, elem_xpow)
 
-static octave_value
-el_pow (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
-
-  return elem_xpow (v1.matrix_value (), v2.matrix_value ());
-}
-
-static octave_value
-el_ldiv (const octave_value& a1, const octave_value& a2)
+DEFBINOP (el_ldiv, matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
   return octave_value (quotient (v2.matrix_value (), v1.matrix_value ()));
 }
 
-static octave_value
-el_and (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
-
-  return mx_el_and (v1.matrix_value (), v2.matrix_value ());
-}
-
-static octave_value
-el_or (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
+DEFBINOP_FN (el_and, matrix, matrix, mx_el_and)
+DEFBINOP_FN (el_or, matrix, matrix, mx_el_or)
 
-  return mx_el_or (v1.matrix_value (), v2.matrix_value ());
-}
-
-static octave_value
-assign (octave_value& a1, const octave_value_list& idx,
-	const octave_value& a2)
-{
-  CAST_BINOP_ARGS (octave_matrix&, const octave_matrix&);
-
-  v1.assign (idx, v2.matrix_value ());
-  return octave_value ();
-}
+DEFASSIGNOP_FN (assign, matrix, matrix, assign)
 
 void
 install_m_m_ops (void)
 {
   INSTALL_BINOP (add, octave_matrix, octave_matrix, add);
   INSTALL_BINOP (sub, octave_matrix, octave_matrix, sub);
   INSTALL_BINOP (mul, octave_matrix, octave_matrix, mul);
   INSTALL_BINOP (div, octave_matrix, octave_matrix, div);
diff --git a/src/op-m-s.cc b/src/op-m-s.cc
--- a/src/op-m-s.cc
+++ b/src/op-m-s.cc
@@ -28,185 +28,79 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include "gripes.h"
 #include "ov.h"
 #include "ov-re-mat.h"
 #include "ov-scalar.h"
 #include "ov-typeinfo.h"
-#include "op-m-s.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // matrix by scalar ops.
 
-static octave_value
-add (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
-
-  return octave_value (v1.matrix_value () + v2.double_value ());
-}
-
-static octave_value
-sub (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
+DEFBINOP_OP (add, matrix, scalar, +)
+DEFBINOP_OP (sub, matrix, scalar, -)
+DEFBINOP_OP (mul, matrix, scalar, *)
 
-  return octave_value (v1.matrix_value () - v2.double_value ());
-}
-
-static octave_value
-mul (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
-
-  return octave_value (v1.matrix_value () * v2.double_value ());
-}
-
-static octave_value
-div (const octave_value& a1, const octave_value& a2)
+DEFBINOP (div, matrix, scalar)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
 
   double d = v2.double_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v1.matrix_value () / d);
 }
 
-static octave_value
-pow (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
-
-  return xpow (v1.matrix_value (), v2.double_value ());
-}
-
-static octave_value
-ldiv (const octave_value& v1, const octave_value&)
-{
-  gripe_nonconformant ("operator \\", v1.rows (), v1.columns (), 1, 1);
-  return octave_value ();
-}
+DEFBINOP_FN (pow, matrix, scalar, xpow)
 
-static octave_value
-lt (const octave_value& a1, const octave_value& a2)
+DEFBINOP (ldiv, matrix, scalar)
 {
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
-
-  return mx_el_lt (v1.matrix_value (), v2.double_value ());
-}
-
-static octave_value
-le (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
-
-  return mx_el_le (v1.matrix_value (), v2.double_value ());
+  BINOP_NONCONFORMANT ("operator \\");
 }
 
-static octave_value
-eq (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
-
-  return mx_el_eq (v1.matrix_value (), v2.double_value ());
-}
-
-static octave_value
-ge (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
-
-  return mx_el_ge (v1.matrix_value (), v2.double_value ());
-}
-
-static octave_value
-gt (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
+DEFBINOP_FN (lt, matrix, scalar, mx_el_lt)
+DEFBINOP_FN (le, matrix, scalar, mx_el_le)
+DEFBINOP_FN (eq, matrix, scalar, mx_el_eq)
+DEFBINOP_FN (ge, matrix, scalar, mx_el_ge)
+DEFBINOP_FN (gt, matrix, scalar, mx_el_gt)
+DEFBINOP_FN (ne, matrix, scalar, mx_el_ne)
 
-  return mx_el_gt (v1.matrix_value (), v2.double_value ());
-}
-
-static octave_value
-ne (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
-
-  return mx_el_ne (v1.matrix_value (), v2.double_value ());
-}
+DEFBINOP_OP (el_mul, matrix, scalar, *)
 
-static octave_value
-el_mul (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
-
-  return octave_value (v1.matrix_value () * v2.double_value ());
-}
-
-static octave_value
-el_div (const octave_value& a1, const octave_value& a2)
+DEFBINOP (el_div, matrix, scalar)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
 
   double d = v2.double_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v1.matrix_value () / d);
 }
 
-static octave_value
-el_pow (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
+DEFBINOP_FN (el_pow, matrix, scalar, elem_xpow)
 
-  return elem_xpow (v1.matrix_value (), v2.double_value ());
-}
-
-static octave_value
-el_ldiv (const octave_value& a1, const octave_value& a2)
+DEFBINOP (el_ldiv, matrix, scalar)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
 
   return x_el_div (v2.double_value (), v1.matrix_value ());
 }
 
-static octave_value
-el_and (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
-
-  return mx_el_and (v1.matrix_value (), v2.double_value ());
-}
-
-static octave_value
-el_or (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
+DEFBINOP_FN (el_and, matrix, scalar, mx_el_and)
+DEFBINOP_FN (el_or, matrix, scalar, mx_el_or)
 
-  return mx_el_or (v1.matrix_value (), v2.double_value ());
-}
-
-static octave_value
-assign (octave_value& a1, const octave_value_list& idx,
-	const octave_value& a2)
-{
-  CAST_BINOP_ARGS (octave_matrix&, const octave_scalar&);
-
-  v1.assign (idx, v2.matrix_value ());
-  return octave_value ();
-}
+DEFASSIGNOP_FN (assign, matrix, scalar, assign)
 
 void
 install_m_s_ops (void)
 {
   INSTALL_BINOP (add, octave_matrix, octave_scalar, add);
   INSTALL_BINOP (sub, octave_matrix, octave_scalar, sub);
   INSTALL_BINOP (mul, octave_matrix, octave_scalar, mul);
   INSTALL_BINOP (div, octave_matrix, octave_scalar, div);
diff --git a/src/op-s-cm.cc b/src/op-s-cm.cc
--- a/src/op-s-cm.cc
+++ b/src/op-s-cm.cc
@@ -30,182 +30,87 @@ Software Foundation, 59 Temple Place - S
 
 #include "mx-s-cm.h"
 
 #include "gripes.h"
 #include "ov.h"
 #include "ov-scalar.h"
 #include "ov-cx-mat.h"
 #include "ov-typeinfo.h"
-#include "op-s-cm.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // scalar by complex matrix ops.
 
-static octave_value
-add (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
+DEFBINOP_OP (add, scalar, complex_matrix, +)
+DEFBINOP_OP (sub, scalar, complex_matrix, -)
+DEFBINOP_OP (mul, scalar, complex_matrix, *)
 
-  return octave_value (v1.double_value () + v2.complex_matrix_value ());
-}
-
-static octave_value
-sub (const octave_value& a1, const octave_value& a2)
+DEFBINOP (div, scalar, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
-
-  return octave_value (v1.double_value () - v2.complex_matrix_value ());
+  BINOP_NONCONFORMANT ("operator /");
 }
 
-static octave_value
-mul (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
-
-  return octave_value (v1.double_value () * v2.complex_matrix_value ());
-}
+DEFBINOP_FN (pow, scalar, complex_matrix, xpow)
 
-static octave_value
-div (const octave_value&, const octave_value& v2)
-{
-  gripe_nonconformant ("operator /", 1, 1, v2.rows (), v2.columns ());
-  return octave_value ();
-}
-
-static octave_value
-pow (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
-
-  return xpow (v1.double_value (), v2.complex_matrix_value ());
-}
-
-static octave_value
-ldiv (const octave_value& a1, const octave_value& a2)
+DEFBINOP (ldiv, scalar, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
   double d = v1.double_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v2.complex_matrix_value () / d);
 }
 
-static octave_value
-lt (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
-
-  return mx_el_lt (v1.double_value (), v2.complex_matrix_value ());
-}
-
-static octave_value
-le (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
-
-  return mx_el_le (v1.double_value (), v2.complex_matrix_value ());
-}
-
-static octave_value
-eq (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
-
-  return mx_el_eq (v1.double_value (), v2.complex_matrix_value ());
-}
-
-static octave_value
-ge (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
-
-  return mx_el_ge (v1.double_value (), v2.complex_matrix_value ());
-}
-
-static octave_value
-gt (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
+DEFBINOP_FN (lt, scalar, complex_matrix, mx_el_lt)
+DEFBINOP_FN (le, scalar, complex_matrix, mx_el_le)
+DEFBINOP_FN (eq, scalar, complex_matrix, mx_el_eq)
+DEFBINOP_FN (ge, scalar, complex_matrix, mx_el_ge)
+DEFBINOP_FN (gt, scalar, complex_matrix, mx_el_gt)
+DEFBINOP_FN (ne, scalar, complex_matrix, mx_el_ne)
 
-  return mx_el_gt (v1.double_value (), v2.complex_matrix_value ());
-}
-
-static octave_value
-ne (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
-
-  return mx_el_ne (v1.double_value (), v2.complex_matrix_value ());
-}
-
-static octave_value
-el_mul (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
-
-  return octave_value (v1.double_value () * v2.complex_matrix_value ());
-}
+DEFBINOP_OP (el_mul, scalar, complex_matrix, *)
+DEFBINOP_FN (el_div, scalar, complex_matrix, x_el_div)
+DEFBINOP_FN (el_pow, scalar, complex_matrix, elem_xpow)
 
-static octave_value
-el_div (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
-
-  return x_el_div (v1.double_value (), v2.complex_matrix_value ());
-}
-
-static octave_value
-el_pow (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
-
-  return elem_xpow (v1.double_value (), v2.complex_matrix_value ());
-}
-
-static octave_value
-el_ldiv (const octave_value& a1, const octave_value& a2)
+DEFBINOP (el_ldiv, scalar, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
   double d = v1.double_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v2.complex_matrix_value () / d);
 }
 
-static octave_value
-el_and (const octave_value& a1, const octave_value& a2)
+DEFBINOP (el_and, scalar, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
   return mx_el_and (v1.double_value (), v2.complex_matrix_value ());
 }
 
-static octave_value
-el_or (const octave_value& a1, const octave_value& a2)
+DEFBINOP (el_or, scalar, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
   return mx_el_or (v1.double_value (), v2.complex_matrix_value ());
 }
 
-static octave_value *
-complex_matrix_conv (const octave_value& a)
+DEFCONV (complex_matrix_conv, scalar, complex_matrix)
 {
   CAST_CONV_ARG (const octave_scalar&);
 
-  return new octave_complex_matrix (v.complex_matrix_value ());
+  return new octave_complex_matrix (ComplexMatrix (v.matrix_value ()));
 }
 
 void
 install_s_cm_ops (void)
 {
   INSTALL_BINOP (add, octave_scalar, octave_complex_matrix, add);
   INSTALL_BINOP (sub, octave_scalar, octave_complex_matrix, sub);
   INSTALL_BINOP (mul, octave_scalar, octave_complex_matrix, mul);
diff --git a/src/op-s-cs.cc b/src/op-s-cs.cc
--- a/src/op-s-cs.cc
+++ b/src/op-s-cs.cc
@@ -29,189 +29,137 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include "gripes.h"
 #include "ov.h"
 #include "ov-scalar.h"
 #include "ov-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-typeinfo.h"
-#include "op-s-cs.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // scalar by complex scalar ops.
 
-static octave_value
-add (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_complex&);
-
-  return octave_value (v1.double_value () + v2.complex_value ());
-}
-
-static octave_value
-sub (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_complex&);
+DEFBINOP_OP (add, scalar, complex, +)
+DEFBINOP_OP (sub, scalar, complex, -)
+DEFBINOP_OP (mul, scalar, complex, *)
 
-  return octave_value (v1.double_value () - v2.complex_value ());
-}
-
-static octave_value
-mul (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_complex&);
-
-  return octave_value (v1.double_value () * v2.complex_value ());
-}
-
-static octave_value
-div (const octave_value& a1, const octave_value& a2)
+DEFBINOP (div, scalar, complex)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex&);
 
   Complex d = v2.complex_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v1.double_value () / d);
 }
 
-static octave_value
-pow (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_complex&);
+DEFBINOP_FN (pow, scalar, complex, xpow)
 
-  return xpow (v1.double_value (), v2.complex_value ());
-}
-
-static octave_value
-ldiv (const octave_value& a1, const octave_value& a2)
+DEFBINOP (ldiv, scalar, complex)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex&);
 
   double d = v1.double_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v2.complex_value () / d);
 }
 
-static octave_value
-lt (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_complex&);
-
-  return octave_value (v1.double_value () < v2.double_value ());
-}
-
-static octave_value
-le (const octave_value& a1, const octave_value& a2)
+DEFBINOP (lt, scalar, complex)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex&);
 
-  return octave_value (v1.double_value () <= v2.double_value ());
+  return v1.double_value () < real (v2.complex_value ());
 }
 
-static octave_value
-eq (const octave_value& a1, const octave_value& a2)
+DEFBINOP (le, scalar, complex)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex&);
 
-  return octave_value (v1.double_value () == v2.complex_value ());
+  return v1.double_value () <= real (v2.complex_value ());
 }
 
-static octave_value
-ge (const octave_value& a1, const octave_value& a2)
+DEFBINOP (eq, scalar, complex)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex&);
 
-  return octave_value (v1.double_value () >= v2.double_value ());
+  return v1.double_value () == v2.complex_value ();
 }
 
-static octave_value
-gt (const octave_value& a1, const octave_value& a2)
+DEFBINOP (ge, scalar, complex)
+{
+  CAST_BINOP_ARGS (const octave_scalar&, const octave_complex&);
+
+  return v1.double_value () >= real (v2.complex_value ());
+}
+
+DEFBINOP (gt, scalar, complex)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex&);
 
-  return octave_value (v1.double_value () > v2.double_value ());
+  return v1.double_value () > real (v2.complex_value ());
 }
 
-static octave_value
-ne (const octave_value& a1, const octave_value& a2)
+DEFBINOP (ne, scalar, complex)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex&);
 
-  return octave_value (v1.double_value () != v2.complex_value ());
+  return v1.double_value () != v2.complex_value ();
 }
 
-static octave_value
-el_mul (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_complex&);
+DEFBINOP_OP (el_mul, scalar, complex, *)
 
-  return octave_value (v1.double_value () * v2.complex_value ());
-}
-
-static octave_value
-el_div (const octave_value& a1, const octave_value& a2)
+DEFBINOP (el_div, scalar, complex)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex&);
 
   Complex d = v2.complex_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v1.double_value () / d);
 }
 
-static octave_value
-el_pow (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_complex&);
+DEFBINOP_FN (el_pow, scalar, complex, xpow)
 
-  return xpow (v1.double_value (), v2.complex_value ());
-}
-
-static octave_value
-el_ldiv (const octave_value& a1, const octave_value& a2)
+DEFBINOP (el_ldiv, scalar, complex)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex&);
 
   double d = v1.double_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v2.complex_value () / d);
 }
 
-static octave_value
-el_and (const octave_value& a1, const octave_value& a2)
+DEFBINOP (el_and, scalar, complex)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex&);
 
   return octave_value (v1.double_value () && (v2.complex_value () != 0.0));
 }
 
-static octave_value
-el_or (const octave_value& a1, const octave_value& a2)
+DEFBINOP (el_or, scalar, complex)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex&);
 
   return octave_value (v1.double_value () || (v2.complex_value () != 0.0));
 }
 
-static octave_value *
-complex_matrix_conv (const octave_value& a)
+DEFCONV (complex_matrix_conv, scalar, complex_matrix)
 {
   CAST_CONV_ARG (const octave_scalar&);
 
   return new octave_complex_matrix (v.complex_matrix_value ());
 }
 
 void
 install_s_cs_ops (void)
diff --git a/src/op-s-m.cc b/src/op-s-m.cc
--- a/src/op-s-m.cc
+++ b/src/op-s-m.cc
@@ -28,178 +28,72 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include "gripes.h"
 #include "ov.h"
 #include "ov-scalar.h"
 #include "ov-re-mat.h"
 #include "ov-typeinfo.h"
-#include "op-s-m.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // scalar by matrix ops.
 
-static octave_value
-add (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
+DEFBINOP_OP (add, scalar, matrix, +)
+DEFBINOP_OP (sub, scalar, matrix, -)
+DEFBINOP_OP (mul, scalar, matrix, *)
 
-  return octave_value (v1.double_value () + v2.matrix_value ());
-}
-
-static octave_value
-sub (const octave_value& a1, const octave_value& a2)
+DEFBINOP (div, scalar, matrix)
 {
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
-
-  return octave_value (v1.double_value () - v2.matrix_value ());
+  BINOP_NONCONFORMANT ("operator /");
 }
 
-static octave_value
-mul (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
-
-  return octave_value (v1.double_value () * v2.matrix_value ());
-}
+DEFBINOP_FN (pow, scalar, matrix, xpow)
 
-static octave_value
-div (const octave_value&, const octave_value& v2)
-{
-  gripe_nonconformant ("operator /", 1, 1, v2.rows (), v2.columns ());
-  return octave_value ();
-}
-
-static octave_value
-pow (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
-
-  return xpow (v1.double_value (), v2.matrix_value ());
-}
-
-static octave_value
-ldiv (const octave_value& a1, const octave_value& a2)
+DEFBINOP (ldiv, scalar, matrix)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
 
   double d = v1.double_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v2.matrix_value () / d);
 }
 
-static octave_value
-lt (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
-
-  return mx_el_lt (v1.double_value (), v2.matrix_value ());
-}
-
-static octave_value
-le (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
-
-  return mx_el_le (v1.double_value (), v2.matrix_value ());
-}
-
-static octave_value
-eq (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
-
-  return mx_el_eq (v1.double_value (), v2.matrix_value ());
-}
-
-static octave_value
-ge (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
-
-  return mx_el_ge (v1.double_value (), v2.matrix_value ());
-}
-
-static octave_value
-gt (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
+DEFBINOP_FN (lt, scalar, matrix, mx_el_lt)
+DEFBINOP_FN (le, scalar, matrix, mx_el_le)
+DEFBINOP_FN (eq, scalar, matrix, mx_el_eq)
+DEFBINOP_FN (ge, scalar, matrix, mx_el_ge)
+DEFBINOP_FN (gt, scalar, matrix, mx_el_gt)
+DEFBINOP_FN (ne, scalar, matrix, mx_el_ne)
 
-  return mx_el_gt (v1.double_value (), v2.matrix_value ());
-}
-
-static octave_value
-ne (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
-
-  return mx_el_ne (v1.double_value (), v2.matrix_value ());
-}
-
-static octave_value
-el_mul (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
-
-  return octave_value (v1.double_value () * v2.matrix_value ());
-}
+DEFBINOP_OP (el_mul, scalar, matrix, *)
+DEFBINOP_FN (el_div, scalar, matrix, x_el_div)
+DEFBINOP_FN (el_pow, scalar, matrix, elem_xpow)
 
-static octave_value
-el_div (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
-
-  return x_el_div (v1.double_value (), v2.matrix_value ());
-}
-
-static octave_value
-el_pow (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
-
-  return elem_xpow (v1.double_value (), v2.matrix_value ());
-}
-
-static octave_value
-el_ldiv (const octave_value& a1, const octave_value& a2)
+DEFBINOP (el_ldiv, scalar, matrix)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
 
   double d = v1.double_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v2.matrix_value () / d);
 }
 
-static octave_value
-el_and (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
-
-  return mx_el_and (v1.double_value (), v2.matrix_value ());
-}
+DEFBINOP_FN (el_and, scalar, matrix, mx_el_and)
+DEFBINOP_FN (el_or, scalar, matrix, mx_el_or)
 
-static octave_value
-el_or (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
-
-  return mx_el_or (v1.double_value (), v2.matrix_value ());
-}
-
-static octave_value *
-matrix_conv (const octave_value& a)
+DEFCONV (matrix_conv, scalar, matrix)
 {
   CAST_CONV_ARG (const octave_scalar&);
 
   return new octave_matrix (v.matrix_value ());
 }
 
 void
 install_s_m_ops (void)
diff --git a/src/op-s-s.cc b/src/op-s-s.cc
--- a/src/op-s-s.cc
+++ b/src/op-s-s.cc
@@ -28,193 +28,106 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include "gripes.h"
 #include "ov.h"
 #include "ov-scalar.h"
 #include "ov-re-mat.h"
 #include "ov-typeinfo.h"
-#include "op-s-s.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // scalar by scalar ops.
 
-static octave_value
-add (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_scalar&);
-
-  return octave_value (v1.double_value () + v2.double_value ());
-}
-
-static octave_value
-sub (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_scalar&);
+DEFBINOP_OP (add, scalar, scalar, +)
+DEFBINOP_OP (sub, scalar, scalar, -)
+DEFBINOP_OP (mul, scalar, scalar, *)
 
-  return octave_value (v1.double_value () - v2.double_value ());
-}
-
-static octave_value
-mul (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_scalar&);
-
-  return octave_value (v1.double_value () * v2.double_value ());
-}
-
-static octave_value
-div (const octave_value& a1, const octave_value& a2)
+DEFBINOP (div, scalar, scalar)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_scalar&);
 
   double d = v2.double_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v1.double_value () / d);
 }
 
-static octave_value
-pow (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_scalar&);
+DEFBINOP_FN (pow, scalar, scalar, xpow)
 
-  return xpow (v1.double_value (), v2.double_value ());
-}
-
-static octave_value
-ldiv (const octave_value& a1, const octave_value& a2)
+DEFBINOP (ldiv, scalar, scalar)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_scalar&);
 
   double d = v1.double_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v2.double_value () / d);
 }
 
-static octave_value
-lt (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_scalar&);
-
-  return octave_value (v1.double_value () < v2.double_value ());
-}
-
-static octave_value
-le (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_scalar&);
-
-  return octave_value (v1.double_value () <= v2.double_value ());
-}
-
-static octave_value
-eq (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_scalar&);
-
-  return octave_value (v1.double_value () == v2.double_value ());
-}
-
-static octave_value
-ge (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_scalar&);
+DEFBINOP_OP (lt, scalar, scalar, <)
+DEFBINOP_OP (le, scalar, scalar, <=)
+DEFBINOP_OP (eq, scalar, scalar, ==)
+DEFBINOP_OP (ge, scalar, scalar, >=)
+DEFBINOP_OP (gt, scalar, scalar, >)
+DEFBINOP_OP (ne, scalar, scalar, !=)
 
-  return octave_value (v1.double_value () >= v2.double_value ());
-}
-
-static octave_value
-gt (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_scalar&);
-
-  return octave_value (v1.double_value () > v2.double_value ());
-}
+DEFBINOP_OP (el_mul, scalar, scalar, *)
 
-static octave_value
-ne (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_scalar&);
-
-  return octave_value (v1.double_value () != v2.double_value ());
-}
-
-static octave_value
-el_mul (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_scalar&);
-
-  return octave_value (v1.double_value () * v2.double_value ());
-}
-
-static octave_value
-el_div (const octave_value& a1, const octave_value& a2)
+DEFBINOP (el_div, scalar, scalar)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_scalar&);
 
   double d = v2.double_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v1.double_value () / d);
 }
 
-static octave_value
-el_pow (const octave_value& a1, const octave_value& a2)
-{
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_scalar&);
+DEFBINOP_FN (el_pow, scalar, scalar, xpow)
 
-  return xpow (v1.double_value (), v2.double_value ());
-}
-
-static octave_value
-el_ldiv (const octave_value& a1, const octave_value& a2)
+DEFBINOP (el_ldiv, scalar, scalar)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_scalar&);
 
   double d = v1.double_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v2.double_value () / d);
 }
 
-static octave_value
-el_and (const octave_value& a1, const octave_value& a2)
+DEFBINOP (el_and, scalar, scalar)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_scalar&);
 
   double result = v1.double_value () && v2.double_value ();
 
   return octave_value (result);
 }
 
-static octave_value
-el_or (const octave_value& a1, const octave_value& a2)
+DEFBINOP (el_or, scalar, scalar)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_scalar&);
 
   double result = v1.double_value () || v2.double_value ();
 
   return octave_value (result);
 }
 
-static octave_value *
-matrix_conv (const octave_value& a)
+DEFCONV (matrix_conv, scalar, matrix)
 {
   CAST_CONV_ARG (const octave_scalar&);
 
   return new octave_matrix (v.matrix_value ());
 }
 
 void
 install_s_s_ops (void)
diff --git a/src/op-str-str.cc b/src/op-str-str.cc
--- a/src/op-str-str.cc
+++ b/src/op-str-str.cc
@@ -31,18 +31,17 @@ Software Foundation, 59 Temple Place - S
 #include "gripes.h"
 #include "ov.h"
 #include "ov-str-mat.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 
 // string by string ops.
 
-static octave_value
-eq (const octave_value& a1, const octave_value& a2)
+DEFBINOP (eq, char_matrix_str, char_matrix_str)
 {
   CAST_BINOP_ARGS (const octave_char_matrix_str&,
 		   const octave_char_matrix_str&);
 
   charMatrix cm1 = v1.char_matrix_value ();
   charMatrix cm2 = v2.char_matrix_value ();
 
   if (cm1.rows () == 1 && cm1.columns () == 1)
@@ -62,18 +61,17 @@ eq (const octave_value& a1, const octave
 	MX_SC_BOOL_OP (charMatrix, m, cm1, char, c, cm2 (0, 0),
 		       c == m (i, j), 0.0);
       else
 	MX_MX_BOOL_OP (charMatrix, m1, cm1, charMatrix, m2, cm2,
 		       m1 (i, j) == m2 (i, j), "==", 0.0, 1.0);
     }
 }
 
-static octave_value
-ne (const octave_value& a1, const octave_value& a2)
+DEFBINOP (ne, char_matrix_str, char_matrix_str)
 {
   CAST_BINOP_ARGS (const octave_char_matrix_str&,
 		   const octave_char_matrix_str&);
 
   charMatrix cm1 = v1.char_matrix_value ();
   charMatrix cm2 = v2.char_matrix_value ();
 
   if (cm1.rows () == 1 && cm1.columns () == 1)
@@ -90,19 +88,17 @@ ne (const octave_value& a1, const octave
 	MX_SC_BOOL_OP (charMatrix, m, cm1, char, c, cm2 (0, 0),
 		       c != m (i, j), 1.0);
       else
 	MX_MX_BOOL_OP (charMatrix, m1, cm1, charMatrix, m2, cm2,
 		       m1 (i, j) != m2 (i, j), "!=", 1.0, 0.0);
     }
 }
 
-static octave_value
-assign (octave_value& a1, const octave_value_list& idx,
-	const octave_value& a2)
+DEFASSIGNOP (assign, char_matrix_str, char_matrix_str)
 {
   CAST_BINOP_ARGS (octave_char_matrix_str&, const octave_char_matrix_str&);
 
   v1.assign (idx, v2.char_matrix_value ());
   return octave_value ();
 }
 
 void
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -1069,28 +1069,31 @@ print_empty_matrix (ostream& os, int nr,
 
 static void
 pr_col_num_header (ostream& os, int total_width, int max_width,
 		   int lim, int col, int extra_indent)
 {
   if (total_width > max_width && Vsplit_long_rows)
     {
       if (col != 0 && ! compact_format)
-	os << "\n";
+	os << "\n\n";
 
       int num_cols = lim - col;
 
       os.form ("%*s", extra_indent, "");
 
       if (num_cols == 1)
 	os << " Column " << col + 1 << ":\n";
       else if (num_cols == 2)
 	os << " Columns " << col + 1 << " and " << lim << ":\n";
       else
 	os << " Columns " << col + 1 << " through " << lim << ":\n";
+
+      if (! compact_format)
+	os << "\n";
     }
 }
 
 void
 octave_print_internal (ostream& os, double d, bool pr_as_read_syntax)
 {
   if (plus_format)
     {
