# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1447520858 18000
#      Sat Nov 14 12:07:38 2015 -0500
# Node ID 85e5efae848af849f1232ba1cee4fc9d88f59728
# Parent  b6b16d8c8b57eb9f98f9dbf18a7c9033141d3f2f
eliminate more uses of error_state

* ov.h, ov.cc: Provide more value extractors that handle error messages.

* besselj.cc, daspk.cc, dasrt.cc, dassl.cc, file-io.cc, graphics.cc,
matrix_type.cc, ordschur.cc, utils.cc, __eigs__.cc,
__magick_read__.cc: Eliminate more uses of error_state.

diff --git a/libinterp/corefcn/besselj.cc b/libinterp/corefcn/besselj.cc
--- a/libinterp/corefcn/besselj.cc
+++ b/libinterp/corefcn/besselj.cc
@@ -121,281 +121,201 @@ do_bessel (enum bessel_type type, const 
 
       octave_value alpha_arg = args(0);
       octave_value x_arg = args(1);
 
       if (alpha_arg.is_single_type () || x_arg.is_single_type ())
         {
           if (alpha_arg.is_scalar_type ())
             {
-              float alpha = args(0).float_value ();
-
-              if (! error_state)
-                {
-                  if (x_arg.is_scalar_type ())
-                    {
-                      FloatComplex x = x_arg.float_complex_value ();
+              float alpha = args(0).xfloat_value ("%s: expecting scalar or matrix as first argument", fn);
 
-                      if (! error_state)
-                        {
-                          octave_idx_type ierr;
-                          octave_value result;
-
-                          DO_BESSEL (type, alpha, x, scaled, ierr, result);
-
-                          if (nargout > 1)
-                            retval(1) = static_cast<float> (ierr);
+              if (x_arg.is_scalar_type ())
+                {
+                  FloatComplex x = x_arg.xfloat_complex_value ("%s: expecting scalar or matrix as second argument", fn);
 
-                          retval(0) = result;
-                        }
-                      else
-                        gripe_bessel_arg (fn, "second");
-                    }
-                  else
-                    {
-                      FloatComplexNDArray x
-                        = x_arg.float_complex_array_value ();
+                  octave_idx_type ierr;
+                  octave_value result;
+
+                  DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
-                      if (! error_state)
-                        {
-                          Array<octave_idx_type> ierr;
-                          octave_value result;
-
-                          DO_BESSEL (type, alpha, x, scaled, ierr, result);
+                  if (nargout > 1)
+                    retval(1) = static_cast<float> (ierr);
 
-                          if (nargout > 1)
-                            retval(1) = NDArray (ierr);
-
-                          retval(0) = result;
-                        }
-                      else
-                        gripe_bessel_arg (fn, "second");
-                    }
+                  retval(0) = result;
                 }
               else
-                gripe_bessel_arg (fn, "first");
+                {
+                  FloatComplexNDArray x
+                    = x_arg.xfloat_complex_array_value ("%s: expecting scalar or matrix as second argument", fn);
+
+                  Array<octave_idx_type> ierr;
+                  octave_value result;
+
+                  DO_BESSEL (type, alpha, x, scaled, ierr, result);
+
+                  if (nargout > 1)
+                    retval(1) = NDArray (ierr);
+
+                  retval(0) = result;
+                }
             }
           else
             {
               dim_vector dv0 = args(0).dims ();
               dim_vector dv1 = args(1).dims ();
 
               bool args0_is_row_vector = (dv0(1) == dv0.numel ());
               bool args1_is_col_vector = (dv1(0) == dv1.numel ());
 
               if (args0_is_row_vector && args1_is_col_vector)
                 {
-                  FloatRowVector ralpha = args(0).float_row_vector_value ();
+                  FloatRowVector ralpha = args(0).xfloat_row_vector_value ("%s: expecting scalar or matrix as first argument", fn);
 
-                  if (! error_state)
-                    {
-                      FloatComplexColumnVector cx =
-                        x_arg.float_complex_column_vector_value ();
-
-                      if (! error_state)
-                        {
-                          Array<octave_idx_type> ierr;
-                          octave_value result;
+                  FloatComplexColumnVector cx =
+                    x_arg.xfloat_complex_column_vector_value ("%s: expecting scalar or matrix as second argument", fn);
 
-                          DO_BESSEL (type, ralpha, cx, scaled, ierr, result);
+                  Array<octave_idx_type> ierr;
+                  octave_value result;
 
-                          if (nargout > 1)
-                            retval(1) = NDArray (ierr);
+                  DO_BESSEL (type, ralpha, cx, scaled, ierr, result);
 
-                          retval(0) = result;
-                        }
-                      else
-                        gripe_bessel_arg (fn, "second");
-                    }
-                  else
-                    gripe_bessel_arg (fn, "first");
+                  if (nargout > 1)
+                    retval(1) = NDArray (ierr);
+
+                  retval(0) = result;
                 }
               else
                 {
-                  FloatNDArray alpha = args(0).float_array_value ();
-
-                  if (! error_state)
-                    {
-                      if (x_arg.is_scalar_type ())
-                        {
-                          FloatComplex x = x_arg.float_complex_value ();
+                  FloatNDArray alpha = args(0).xfloat_array_value ("%s: expecting scalar or matrix as first argument", fn);
 
-                          if (! error_state)
-                            {
-                              Array<octave_idx_type> ierr;
-                              octave_value result;
-
-                              DO_BESSEL (type, alpha, x, scaled, ierr, result);
-
-                              if (nargout > 1)
-                                retval(1) = NDArray (ierr);
+                  if (x_arg.is_scalar_type ())
+                    {
+                      FloatComplex x = x_arg.xfloat_complex_value ("%s: expecting scalar or matrix as second argument", fn);
 
-                              retval(0) = result;
-                            }
-                          else
-                            gripe_bessel_arg (fn, "second");
-                        }
-                      else
-                        {
-                          FloatComplexNDArray x
-                            = x_arg.float_complex_array_value ();
+                      Array<octave_idx_type> ierr;
+                      octave_value result;
+
+                      DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
-                          if (! error_state)
-                            {
-                              Array<octave_idx_type> ierr;
-                              octave_value result;
-
-                              DO_BESSEL (type, alpha, x, scaled, ierr, result);
+                      if (nargout > 1)
+                        retval(1) = NDArray (ierr);
 
-                              if (nargout > 1)
-                                retval(1) = NDArray (ierr);
-
-                              retval(0) = result;
-                            }
-                          else
-                            gripe_bessel_arg (fn, "second");
-                        }
+                      retval(0) = result;
                     }
                   else
-                    gripe_bessel_arg (fn, "first");
+                    {
+                      FloatComplexNDArray x
+                        = x_arg.xfloat_complex_array_value ("%s: expecting scalar or matrix as second argument", fn);
+
+                      Array<octave_idx_type> ierr;
+                      octave_value result;
+
+                      DO_BESSEL (type, alpha, x, scaled, ierr, result);
+
+                      if (nargout > 1)
+                        retval(1) = NDArray (ierr);
+
+                      retval(0) = result;
+                    }
                 }
             }
         }
       else
         {
           if (alpha_arg.is_scalar_type ())
             {
-              double alpha = args(0).double_value ();
-
-              if (! error_state)
-                {
-                  if (x_arg.is_scalar_type ())
-                    {
-                      Complex x = x_arg.complex_value ();
+              double alpha = args(0).xdouble_value ("%s: expecting scalar or matrix as first argument", fn);
 
-                      if (! error_state)
-                        {
-                          octave_idx_type ierr;
-                          octave_value result;
-
-                          DO_BESSEL (type, alpha, x, scaled, ierr, result);
-
-                          if (nargout > 1)
-                            retval(1) = static_cast<double> (ierr);
+              if (x_arg.is_scalar_type ())
+                {
+                  Complex x = x_arg.xcomplex_value ("%s: expecting scalar or matrix as second argument", fn);
 
-                          retval(0) = result;
-                        }
-                      else
-                        gripe_bessel_arg (fn, "second");
-                    }
-                  else
-                    {
-                      ComplexNDArray x = x_arg.complex_array_value ();
+                  octave_idx_type ierr;
+                  octave_value result;
+
+                  DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
-                      if (! error_state)
-                        {
-                          Array<octave_idx_type> ierr;
-                          octave_value result;
-
-                          DO_BESSEL (type, alpha, x, scaled, ierr, result);
+                  if (nargout > 1)
+                    retval(1) = static_cast<double> (ierr);
 
-                          if (nargout > 1)
-                            retval(1) = NDArray (ierr);
-
-                          retval(0) = result;
-                        }
-                      else
-                        gripe_bessel_arg (fn, "second");
-                    }
+                  retval(0) = result;
                 }
               else
-                gripe_bessel_arg (fn, "first");
+                {
+                  ComplexNDArray x = x_arg.xcomplex_array_value ("%s: expecting scalar or matrix as second argument", fn);
+
+                  Array<octave_idx_type> ierr;
+                  octave_value result;
+
+                  DO_BESSEL (type, alpha, x, scaled, ierr, result);
+
+                  if (nargout > 1)
+                    retval(1) = NDArray (ierr);
+
+                  retval(0) = result;
+                }
             }
           else
             {
               dim_vector dv0 = args(0).dims ();
               dim_vector dv1 = args(1).dims ();
 
               bool args0_is_row_vector = (dv0(1) == dv0.numel ());
               bool args1_is_col_vector = (dv1(0) == dv1.numel ());
 
               if (args0_is_row_vector && args1_is_col_vector)
                 {
-                  RowVector ralpha = args(0).row_vector_value ();
+                  RowVector ralpha = args(0).xrow_vector_value ("%s: expecting scalar or matrix as first argument", fn);
 
-                  if (! error_state)
-                    {
-                      ComplexColumnVector cx =
-                        x_arg.complex_column_vector_value ();
-
-                      if (! error_state)
-                        {
-                          Array<octave_idx_type> ierr;
-                          octave_value result;
+                  ComplexColumnVector cx =
+                    x_arg.xcomplex_column_vector_value ("%s: expecting scalar or matrix as second argument", fn);
 
-                          DO_BESSEL (type, ralpha, cx, scaled, ierr, result);
+                  Array<octave_idx_type> ierr;
+                  octave_value result;
 
-                          if (nargout > 1)
-                            retval(1) = NDArray (ierr);
+                  DO_BESSEL (type, ralpha, cx, scaled, ierr, result);
 
-                          retval(0) = result;
-                        }
-                      else
-                        gripe_bessel_arg (fn, "second");
-                    }
-                  else
-                    gripe_bessel_arg (fn, "first");
+                  if (nargout > 1)
+                    retval(1) = NDArray (ierr);
+
+                  retval(0) = result;
                 }
               else
                 {
-                  NDArray alpha = args(0).array_value ();
-
-                  if (! error_state)
-                    {
-                      if (x_arg.is_scalar_type ())
-                        {
-                          Complex x = x_arg.complex_value ();
+                  NDArray alpha = args(0).xarray_value ("%s: expecting scalar or matrix as first argument", fn);
 
-                          if (! error_state)
-                            {
-                              Array<octave_idx_type> ierr;
-                              octave_value result;
-
-                              DO_BESSEL (type, alpha, x, scaled, ierr, result);
-
-                              if (nargout > 1)
-                                retval(1) = NDArray (ierr);
+                  if (x_arg.is_scalar_type ())
+                    {
+                      Complex x = x_arg.xcomplex_value ("%s: expecting scalar or matrix as second argument", fn);
 
-                              retval(0) = result;
-                            }
-                          else
-                            gripe_bessel_arg (fn, "second");
-                        }
-                      else
-                        {
-                          ComplexNDArray x = x_arg.complex_array_value ();
+                      Array<octave_idx_type> ierr;
+                      octave_value result;
+
+                      DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
-                          if (! error_state)
-                            {
-                              Array<octave_idx_type> ierr;
-                              octave_value result;
-
-                              DO_BESSEL (type, alpha, x, scaled, ierr, result);
+                      if (nargout > 1)
+                        retval(1) = NDArray (ierr);
 
-                              if (nargout > 1)
-                                retval(1) = NDArray (ierr);
-
-                              retval(0) = result;
-                            }
-                          else
-                            gripe_bessel_arg (fn, "second");
-                        }
+                      retval(0) = result;
                     }
                   else
-                    gripe_bessel_arg (fn, "first");
+                    {
+                      ComplexNDArray x = x_arg.xcomplex_array_value ("%s: expecting scalar or matrix as second argument", fn);
+
+                      Array<octave_idx_type> ierr;
+                      octave_value result;
+
+                      DO_BESSEL (type, alpha, x, scaled, ierr, result);
+
+                      if (nargout > 1)
+                        retval(1) = NDArray (ierr);
+
+                      retval(0) = result;
+                    }
                 }
             }
         }
     }
   else
     print_usage ();
 
   return retval;
@@ -513,37 +433,32 @@ See besselj.\n\
   int nargin = args.length ();
 
   if (nargin == 2)
     {
       retval = do_bessel (BESSEL_H1, "besselh", args, nargout);
     }
   else if (nargin == 3 || nargin == 4)
     {
-      octave_idx_type kind = args(1).int_value ();
+      octave_idx_type kind = args(1).xint_value ("besselh: invalid value of K");
 
-      if (! error_state)
-        {
-          octave_value_list tmp_args;
+      octave_value_list tmp_args;
 
-          if (nargin == 4)
-            tmp_args(2) = args(3);
+      if (nargin == 4)
+        tmp_args(2) = args(3);
 
-          tmp_args(1) = args(2);
-          tmp_args(0) = args(0);
+      tmp_args(1) = args(2);
+      tmp_args(0) = args(0);
 
-          if (kind == 1)
-            retval = do_bessel (BESSEL_H1, "besselh", tmp_args, nargout);
-          else if (kind == 2)
-            retval = do_bessel (BESSEL_H2, "besselh", tmp_args, nargout);
-          else
-            error ("besselh: expecting K = 1 or 2");
-        }
+      if (kind == 1)
+        retval = do_bessel (BESSEL_H1, "besselh", tmp_args, nargout);
+      else if (kind == 2)
+        retval = do_bessel (BESSEL_H2, "besselh", tmp_args, nargout);
       else
-        error ("besselh: invalid value of K");
+        error ("besselh: expecting K = 1 or 2");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (airy, args, nargout,
@@ -600,72 +515,57 @@ return @code{NaN}.\n\
   if (nargin > 0 && nargin < 4)
     {
       bool scale = (nargin == 3);
 
       int kind = 0;
 
       if (nargin > 1)
         {
-          kind = args(0).int_value ();
+          kind = args(0).xint_value ("airy: K must be an integer value");
 
-          if (! error_state)
-            {
-              if (kind < 0 || kind > 3)
-                error ("airy: expecting K = 0, 1, 2, or 3");
-            }
-          else
-            error ("airy: K must be an integer value");
+          if (kind < 0 || kind > 3)
+            error ("airy: expecting K = 0, 1, 2, or 3");
         }
 
       int idx = nargin == 1 ? 0 : 1;
 
       if (args(idx).is_single_type ())
         {
-          FloatComplexNDArray z = args(idx).float_complex_array_value ();
+          FloatComplexNDArray z = args(idx).xfloat_complex_array_value ("airy: Z must be a complex matrix");
 
-          if (! error_state)
-            {
-              Array<octave_idx_type> ierr;
-              octave_value result;
+          Array<octave_idx_type> ierr;
+          octave_value result;
 
-              if (kind > 1)
-                result = biry (z, kind == 3, scale, ierr);
-              else
-                result = airy (z, kind == 1, scale, ierr);
+          if (kind > 1)
+            result = biry (z, kind == 3, scale, ierr);
+          else
+            result = airy (z, kind == 1, scale, ierr);
 
-              if (nargout > 1)
-                retval(1) = NDArray (ierr);
+          if (nargout > 1)
+            retval(1) = NDArray (ierr);
 
-              retval(0) = result;
-            }
-          else
-            error ("airy: Z must be a complex matrix");
+          retval(0) = result;
         }
       else
         {
-          ComplexNDArray z = args(idx).complex_array_value ();
+          ComplexNDArray z = args(idx).xcomplex_array_value ("airy: Z must be a complex matrix");
 
-          if (! error_state)
-            {
-              Array<octave_idx_type> ierr;
-              octave_value result;
+          Array<octave_idx_type> ierr;
+          octave_value result;
 
-              if (kind > 1)
-                result = biry (z, kind == 3, scale, ierr);
-              else
-                result = airy (z, kind == 1, scale, ierr);
+          if (kind > 1)
+            result = biry (z, kind == 3, scale, ierr);
+          else
+            result = airy (z, kind == 1, scale, ierr);
 
-              if (nargout > 1)
-                retval(1) = NDArray (ierr);
+          if (nargout > 1)
+            retval(1) = NDArray (ierr);
 
-              retval(0) = result;
-            }
-          else
-            error ("airy: Z must be a complex matrix");
+          retval(0) = result;
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
diff --git a/libinterp/corefcn/daspk.cc b/libinterp/corefcn/daspk.cc
--- a/libinterp/corefcn/daspk.cc
+++ b/libinterp/corefcn/daspk.cc
@@ -70,37 +70,31 @@ daspk_user_function (const ColumnVector&
   args(2) = t;
   args(1) = xdot;
   args(0) = x;
 
   if (daspk_fcn)
     {
       octave_value_list tmp = daspk_fcn->do_multi_index_op (1, args);
 
-      if (error_state)
-        {
-          gripe_user_supplied_eval ("daspk");
-          return retval;
-        }
-
       int tlen = tmp.length ();
       if (tlen > 0 && tmp(0).is_defined ())
         {
           if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
             {
               warning ("daspk: ignoring imaginary part returned from user-supplied function");
               warned_fcn_imaginary = true;
             }
 
-          retval = ColumnVector (tmp(0).vector_value ());
+          retval = tmp(0).vector_value ();
 
           if (tlen > 1)
             ires = tmp(1).int_value ();
 
-          if (error_state || retval.numel () == 0)
+          if (retval.numel () == 0)
             gripe_user_supplied_eval ("daspk");
         }
       else
         gripe_user_supplied_eval ("daspk");
     }
 
   return retval;
 }
@@ -119,34 +113,28 @@ daspk_user_jacobian (const ColumnVector&
   args(2) = t;
   args(1) = xdot;
   args(0) = x;
 
   if (daspk_jac)
     {
       octave_value_list tmp = daspk_jac->do_multi_index_op (1, args);
 
-      if (error_state)
-        {
-          gripe_user_supplied_eval ("daspk");
-          return retval;
-        }
-
       int tlen = tmp.length ();
       if (tlen > 0 && tmp(0).is_defined ())
         {
           if (! warned_jac_imaginary && tmp(0).is_complex_type ())
             {
               warning ("daspk: ignoring imaginary part returned from user-supplied jacobian function");
               warned_jac_imaginary = true;
             }
 
           retval = tmp(0).matrix_value ();
 
-          if (error_state || retval.numel () == 0)
+          if (retval.numel () == 0)
             gripe_user_supplied_eval ("daspk");
         }
       else
         gripe_user_supplied_eval ("daspk");
     }
 
   return retval;
 }
@@ -388,42 +376,30 @@ parameters for @code{daspk}.\n\
                             daspk_fcn = 0;
                           }
                       }
                   }
                 }
             }
         }
 
-      if (error_state || ! daspk_fcn)
+      if (! daspk_fcn)
         DASPK_ABORT ();
 
-      ColumnVector state = ColumnVector (args(1).vector_value ());
-
-      if (error_state)
-        DASPK_ABORT1 ("expecting state vector as second argument");
-
-      ColumnVector deriv (args(2).vector_value ());
+      ColumnVector state = args(1).xvector_value ("expecting state vector as second argument");
 
-      if (error_state)
-        DASPK_ABORT1 ("expecting derivative vector as third argument");
+      ColumnVector deriv = args(2).xvector_value ("expecting derivative vector as third argument");
 
-      ColumnVector out_times (args(3).vector_value ());
-
-      if (error_state)
-        DASPK_ABORT1 ("expecting output time vector as fourth argument");
+      ColumnVector out_times = args(3).xvector_value ("expecting output time vector as fourth argument");
 
       ColumnVector crit_times;
       int crit_times_set = 0;
       if (nargin > 4)
         {
-          crit_times = ColumnVector (args(4).vector_value ());
-
-          if (error_state)
-            DASPK_ABORT1 ("expecting critical time vector as fifth argument");
+          crit_times = args(4).xvector_value ("expecting critical time vector as fifth argument");
 
           crit_times_set = 1;
         }
 
       if (state.numel () != deriv.numel ())
         DASPK_ABORT1 ("x and xdot must have the same size");
 
       double tzero = out_times (0);
diff --git a/libinterp/corefcn/dasrt.cc b/libinterp/corefcn/dasrt.cc
--- a/libinterp/corefcn/dasrt.cc
+++ b/libinterp/corefcn/dasrt.cc
@@ -70,33 +70,27 @@ dasrt_user_f (const ColumnVector& x, con
   args(2) = t;
   args(1) = xdot;
   args(0) = x;
 
   if (dasrt_f)
     {
       octave_value_list tmp = dasrt_f->do_multi_index_op (1, args);
 
-      if (error_state)
-        {
-          gripe_user_supplied_eval ("dasrt");
-          return retval;
-        }
-
       if (tmp.length () > 0 && tmp(0).is_defined ())
         {
           if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
             {
               warning ("dasrt: ignoring imaginary part returned from user-supplied function");
               warned_fcn_imaginary = true;
             }
 
-          retval = ColumnVector (tmp(0).vector_value ());
+          retval = tmp(0).vector_value ();
 
-          if (error_state || retval.numel () == 0)
+          if (retval.numel () == 0)
             gripe_user_supplied_eval ("dasrt");
         }
       else
         gripe_user_supplied_eval ("dasrt");
     }
 
   return retval;
 }
@@ -110,33 +104,27 @@ dasrt_user_cf (const ColumnVector& x, do
 
   args(1) = t;
   args(0) = x;
 
   if (dasrt_cf)
     {
       octave_value_list tmp = dasrt_cf->do_multi_index_op (1, args);
 
-      if (error_state)
-        {
-          gripe_user_supplied_eval ("dasrt");
-          return retval;
-        }
-
       if (tmp.length () > 0 && tmp(0).is_defined ())
         {
           if (! warned_cf_imaginary && tmp(0).is_complex_type ())
             {
               warning ("dasrt: ignoring imaginary part returned from user-supplied constraint function");
               warned_cf_imaginary = true;
             }
 
-          retval = ColumnVector (tmp(0).vector_value ());
+          retval = tmp(0).vector_value ();
 
-          if (error_state || retval.numel () == 0)
+          if (retval.numel () == 0)
             gripe_user_supplied_eval ("dasrt");
         }
       else
         gripe_user_supplied_eval ("dasrt");
     }
 
   return retval;
 }
@@ -155,34 +143,28 @@ dasrt_user_j (const ColumnVector& x, con
   args(2) = t;
   args(1) = xdot;
   args(0) = x;
 
   if (dasrt_j)
     {
       octave_value_list tmp = dasrt_j->do_multi_index_op (1, args);
 
-      if (error_state)
-        {
-          gripe_user_supplied_eval ("dasrt");
-          return retval;
-        }
-
       int tlen = tmp.length ();
       if (tlen > 0 && tmp(0).is_defined ())
         {
           if (! warned_jac_imaginary && tmp(0).is_complex_type ())
             {
               warning ("dasrt: ignoring imaginary part returned from user-supplied jacobian function");
               warned_jac_imaginary = true;
             }
 
           retval = tmp(0).matrix_value ();
 
-          if (error_state || retval.numel () == 0)
+          if (retval.numel () == 0)
             gripe_user_supplied_eval ("dasrt");
         }
       else
         gripe_user_supplied_eval ("dasrt");
     }
 
   return retval;
 }
@@ -472,17 +454,17 @@ parameters for @code{dasrt}.\n\
 
             default:
               DASRT_ABORT1
                 ("first arg should be a string or 2-element string array");
             }
         }
     }
 
-  if (error_state || (! dasrt_f))
+  if (! dasrt_f)
     DASRT_ABORT;
 
   DAERTFunc func (dasrt_user_f);
 
   argp++;
 
   if (args(1).is_function_handle () || args(1).is_inline_function ())
     {
@@ -501,44 +483,34 @@ parameters for @code{dasrt}.\n\
       if (! dasrt_cf)
         DASRT_ABORT1 ("expecting function name as argument 2");
 
       argp++;
 
       func.set_constraint_function (dasrt_user_cf);
     }
 
-  ColumnVector state (args(argp++).vector_value ());
-
-  if (error_state)
-    DASRT_ABORT2 ("expecting state vector as argument %d", argp);
-
-  ColumnVector stateprime (args(argp++).vector_value ());
+  ColumnVector state = args(argp).xvector_value ("expecting state vector as argument %d", ++argp);
 
-  if (error_state)
-    DASRT_ABORT2 ("expecting time derivative of state vector as argument %d",
-                  argp);
+  ColumnVector stateprime = args(argp).xvector_value ("expecting time derivative of state vector as argument %d", argp);
+  argp++;
 
-  ColumnVector out_times (args(argp++).vector_value ());
-
-  if (error_state)
-    DASRT_ABORT2 ("expecting output time vector as %s argument %d", argp);
+  ColumnVector out_times = args(argp).xvector_value ("expecting output time vector as %s argument %d", argp);
+  argp++;
 
   double tzero = out_times (0);
 
   ColumnVector crit_times;
 
   bool crit_times_set = false;
 
   if (argp < nargin)
     {
-      crit_times = ColumnVector (args(argp++).vector_value ());
-
-      if (error_state)
-        DASRT_ABORT2 ("expecting critical time vector as argument %d", argp);
+      crit_times = args(argp).xvector_value ("expecting critical time vector as argument %d", argp);
+      argp++;
 
       crit_times_set = true;
     }
 
   if (dasrt_j)
     func.set_jacobian_function (dasrt_user_j);
 
   DASRT_result output;
diff --git a/libinterp/corefcn/dassl.cc b/libinterp/corefcn/dassl.cc
--- a/libinterp/corefcn/dassl.cc
+++ b/libinterp/corefcn/dassl.cc
@@ -70,37 +70,31 @@ dassl_user_function (const ColumnVector&
   args(2) = t;
   args(1) = xdot;
   args(0) = x;
 
   if (dassl_fcn)
     {
       octave_value_list tmp = dassl_fcn->do_multi_index_op (1, args);
 
-      if (error_state)
-        {
-          gripe_user_supplied_eval ("dassl");
-          return retval;
-        }
-
       int tlen = tmp.length ();
       if (tlen > 0 && tmp(0).is_defined ())
         {
           if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
             {
               warning ("dassl: ignoring imaginary part returned from user-supplied function");
               warned_fcn_imaginary = true;
             }
 
-          retval = ColumnVector (tmp(0).vector_value ());
+          retval = tmp(0).vector_value ();
 
           if (tlen > 1)
             ires = tmp(1).int_value ();
 
-          if (error_state || retval.numel () == 0)
+          if (retval.numel () == 0)
             gripe_user_supplied_eval ("dassl");
         }
       else
         gripe_user_supplied_eval ("dassl");
     }
 
   return retval;
 }
@@ -119,34 +113,28 @@ dassl_user_jacobian (const ColumnVector&
   args(2) = t;
   args(1) = xdot;
   args(0) = x;
 
   if (dassl_jac)
     {
       octave_value_list tmp = dassl_jac->do_multi_index_op (1, args);
 
-      if (error_state)
-        {
-          gripe_user_supplied_eval ("dassl");
-          return retval;
-        }
-
       int tlen = tmp.length ();
       if (tlen > 0 && tmp(0).is_defined ())
         {
           if (! warned_jac_imaginary && tmp(0).is_complex_type ())
             {
               warning ("dassl: ignoring imaginary part returned from user-supplied jacobian function");
               warned_jac_imaginary = true;
             }
 
           retval = tmp(0).matrix_value ();
 
-          if (error_state || retval.numel () == 0)
+          if (retval.numel () == 0)
             gripe_user_supplied_eval ("dassl");
         }
       else
         gripe_user_supplied_eval ("dassl");
     }
 
   return retval;
 }
@@ -389,42 +377,30 @@ parameters for @code{dassl}.\n\
                             dassl_fcn = 0;
                           }
                       }
                   }
                 }
             }
         }
 
-      if (error_state || ! dassl_fcn)
+      if (! dassl_fcn)
         DASSL_ABORT ();
 
-      ColumnVector state = ColumnVector (args(1).vector_value ());
-
-      if (error_state)
-        DASSL_ABORT1 ("expecting state vector as second argument");
-
-      ColumnVector deriv (args(2).vector_value ());
+      ColumnVector state = args(1).xvector_value ("expecting state vector as second argument");
 
-      if (error_state)
-        DASSL_ABORT1 ("expecting derivative vector as third argument");
+      ColumnVector deriv = args(2).xvector_value ("expecting derivative vector as third argument");
 
-      ColumnVector out_times (args(3).vector_value ());
-
-      if (error_state)
-        DASSL_ABORT1 ("expecting output time vector as fourth argument");
+      ColumnVector out_times = args(3).xvector_value ("expecting output time vector as fourth argument");
 
       ColumnVector crit_times;
       int crit_times_set = 0;
       if (nargin > 4)
         {
-          crit_times = ColumnVector (args(4).vector_value ());
-
-          if (error_state)
-            DASSL_ABORT1 ("expecting critical time vector as fifth argument");
+          crit_times = args(4).xvector_value ("expecting critical time vector as fifth argument");
 
           crit_times_set = 1;
         }
 
       if (state.numel () != deriv.numel ())
         DASSL_ABORT1 ("x and xdot must have the same size");
 
       double tzero = out_times (0);
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -1316,51 +1316,46 @@ static octave_value
 do_fread (octave_stream& os, const octave_value& size_arg,
           const octave_value& prec_arg, const octave_value& skip_arg,
           const octave_value& arch_arg, octave_idx_type& count)
 {
   octave_value retval;
 
   count = -1;
 
-  Array<double> size = size_arg.vector_value ();
+  Array<double> size = size_arg.xvector_value ("fread: invalid SIZE specified");
+
+  std::string prec = prec_arg.xstring_value ("fread: PRECISION must be a string");
+
+  int block_size = 1;
+  oct_data_conv::data_type input_type;
+  oct_data_conv::data_type output_type;
+
+  oct_data_conv::string_to_data_type (prec, block_size,
+                                      input_type, output_type);
 
   if (! error_state)
     {
-      std::string prec = prec_arg.xstring_value ("fread: PRECISION must be a string");
-
-      int block_size = 1;
-      oct_data_conv::data_type input_type;
-      oct_data_conv::data_type output_type;
-
-      oct_data_conv::string_to_data_type (prec, block_size,
-                                          input_type, output_type);
+      int skip = skip_arg.int_value (true);
 
       if (! error_state)
         {
-          int skip = skip_arg.int_value (true);
-
-          if (! error_state)
-            {
-              std::string arch = arch_arg.xstring_value ("fread: ARCH architecture type must be a string");
+          std::string arch = arch_arg.xstring_value ("fread: ARCH architecture type must be a string");
 
-              oct_mach_info::float_format flt_fmt
-                = oct_mach_info::string_to_float_format (arch);
+          oct_mach_info::float_format flt_fmt
+            = oct_mach_info::string_to_float_format (arch);
 
-              retval = os.read (size, block_size, input_type,
-                                output_type, skip, flt_fmt, count);
-            }
-          else
-            error ("fread: SKIP must be an integer");
+          retval = os.read (size, block_size, input_type,
+                            output_type, skip, flt_fmt, count);
         }
       else
-        error ("fread: invalid PRECISION specified");
+        error ("fread: SKIP must be an integer");
     }
   else
-    error ("fread: invalid SIZE specified");
+    error ("fread: invalid PRECISION specified");
 
   return retval;
 }
 
 DEFUN (fread, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} fread (@var{fid})\n\
 @deftypefnx {Built-in Function} {@var{val} =} fread (@var{fid}, @var{size})\n\
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -9634,17 +9634,17 @@ each individual object will be reset.\n\
 {
   int nargin = args.length ();
 
   if (nargin != 1)
     print_usage ();
   else
     {
       // get vector of graphics handles
-      ColumnVector hcv (args(0).vector_value ());
+      ColumnVector hcv = args(0).xvector_value ("reset: expecting graphics handle as first argument");
 
       // loop over graphics objects
       for (octave_idx_type n = 0; n < hcv.numel (); n++)
         gh_manager::get_object (hcv(n)).reset_default_properties ();
 
       Fdrawnow ();
     }
 
@@ -9843,114 +9843,109 @@ being @qcode{\"portrait\"}.\n\
 
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin > 0)
     {
       // get vector of graphics handles
-      ColumnVector hcv (args(0).vector_value ());
-
-      if (! error_state)
-        {
-          bool request_drawnow = false;
-
-          // loop over graphics objects
-          for (octave_idx_type n = 0; n < hcv.numel (); n++)
-            {
-              graphics_object go = gh_manager::get_object (hcv(n));
-
-              if (go)
+      ColumnVector hcv = args(0).xvector_value ("set: expecting graphics handle as first argument");
+
+      bool request_drawnow = false;
+
+      // loop over graphics objects
+      for (octave_idx_type n = 0; n < hcv.numel (); n++)
+        {
+          graphics_object go = gh_manager::get_object (hcv(n));
+
+          if (go)
+            {
+              if (nargin == 3
+                  && args(1).is_cellstr () && args(2).is_cell ())
                 {
-                  if (nargin == 3
-                      && args(1).is_cellstr () && args(2).is_cell ())
+                  if (args(2).cell_value ().rows () == 1)
+                    {
+                      go.set (args(1).cellstr_value (),
+                              args(2).cell_value (), 0);
+                    }
+                  else if (hcv.numel () == args(2).cell_value ().rows ())
+                    {
+                      go.set (args(1).cellstr_value (),
+                              args(2).cell_value (), n);
+                    }
+                  else
                     {
-                      if (args(2).cell_value ().rows () == 1)
-                        {
-                          go.set (args(1).cellstr_value (),
-                                  args(2).cell_value (), 0);
-                        }
-                      else if (hcv.numel () == args(2).cell_value ().rows ())
-                        {
-                          go.set (args(1).cellstr_value (),
-                                  args(2).cell_value (), n);
-                        }
+                      error ("set: number of graphics handles must match number of value rows (%d != %d)",
+                             hcv.numel (), args(2).cell_value ().rows ());
+                      break;
+
+                    }
+                }
+              else if (nargin == 2 && args(1).is_map ())
+                {
+                  go.set (args(1).map_value ());
+                }
+              else if (nargin == 2 && args(1).is_string ())
+                {
+                  std::string property = args(1).string_value ();
+
+                  octave_map pmap = go.values_as_struct ();
+
+                  if (go.has_readonly_property (property))
+                    if (nargout != 0)
+                      retval = Matrix ();
+                    else
+                      octave_stdout << "set: " << property
+                                    <<" is read-only" << std::endl;
+                  else if (pmap.isfield (property))
+                    {
+                      if (nargout != 0)
+                        retval = pmap.getfield (property)(0);
                       else
                         {
-                          error ("set: number of graphics handles must match number of value rows (%d != %d)",
-                                 hcv.numel (), args(2).cell_value ().rows ());
-                          break;
-
-                        }
-                    }
-                  else if (nargin == 2 && args(1).is_map ())
-                    {
-                      go.set (args(1).map_value ());
-                    }
-                  else if (nargin == 2 && args(1).is_string ())
-                    {
-                      std::string property = args(1).string_value ();
-
-                      octave_map pmap = go.values_as_struct ();
-
-                      if (go.has_readonly_property (property))
-                        if (nargout != 0)
-                          retval = Matrix ();
-                        else
-                          octave_stdout << "set: " << property
-                                        <<" is read-only" << std::endl;
-                      else if (pmap.isfield (property))
-                        {
-                          if (nargout != 0)
-                            retval = pmap.getfield (property)(0);
-                          else
-                            {
-                              std::string s = go.value_as_string (property);
-
-                              octave_stdout << s;
-                            }
-                        }
-                      else
-                        {
-                          error ("set: unknown property");
-                          break;
-                        }
-                    }
-                  else if (nargin == 1)
-                    {
-                      if (nargout != 0)
-                        retval = go.values_as_struct ();
-                      else
-                        {
-                          std::string s = go.values_as_string ();
+                          std::string s = go.value_as_string (property);
 
                           octave_stdout << s;
                         }
                     }
                   else
                     {
-                      go.set (args.splice (0, 1));
-                      request_drawnow = true;
+                      error ("set: unknown property");
+                      break;
+                    }
+                }
+              else if (nargin == 1)
+                {
+                  if (nargout != 0)
+                    retval = go.values_as_struct ();
+                  else
+                    {
+                      std::string s = go.values_as_string ();
+
+                      octave_stdout << s;
                     }
                 }
               else
                 {
-                  error ("set: invalid handle (= %g)", hcv(n));
-                  break;
+                  go.set (args.splice (0, 1));
+                  request_drawnow = true;
                 }
-
-              request_drawnow = true;
-            }
-
-          if (request_drawnow)
-            Vdrawnow_requested = true;
-        }
-      else
-        error ("set: expecting graphics handle as first argument");
+            }
+          else
+            {
+              error ("set: invalid handle (= %g)", hcv(n));
+              break;
+            }
+
+          request_drawnow = true;
+        }
+
+      if (request_drawnow)
+        Vdrawnow_requested = true;
     }
   else
     print_usage ();
 
   return retval;
 }
 
 static std::string
@@ -9995,98 +9990,93 @@ lists respectively.\n\
   if (nargin == 1 || nargin == 2)
     {
       if (args(0).is_empty ())
         {
           retval = Matrix ();
           return retval;
         }
 
-      ColumnVector hcv (args(0).vector_value ());
-
-      if (! error_state)
-        {
-          octave_idx_type len = hcv.numel ();
-
-          if (nargin == 1 && len > 1)
-            {
-              std::string typ0 = get_graphics_object_type (hcv(0));
-
-              for (octave_idx_type n = 1; n < len; n++)
+      ColumnVector hcv = args(0).xvector_value ("get: expecting graphics handle as first argument");
+
+      octave_idx_type len = hcv.numel ();
+
+      if (nargin == 1 && len > 1)
+        {
+          std::string typ0 = get_graphics_object_type (hcv(0));
+
+          for (octave_idx_type n = 1; n < len; n++)
+            {
+              std::string typ = get_graphics_object_type (hcv(n));
+
+              if (typ != typ0)
                 {
-                  std::string typ = get_graphics_object_type (hcv(n));
-
-                  if (typ != typ0)
+                  error ("get: vector of handles must all have same type");
+                  break;
+                }
+            }
+        }
+
+      if (nargin > 1 && args(1).is_cellstr ())
+        {
+          Array<std::string> plist = args(1).xcellstr_value ("get: expecting property name or cell array of property names as second argument");
+
+          octave_idx_type plen = plist.numel ();
+
+          use_cell_format = true;
+
+          vals.resize (dim_vector (len, plen));
+
+          for (octave_idx_type n = 0; n < len; n++)
+            {
+              graphics_object go = gh_manager::get_object (hcv(n));
+
+              if (go)
+                {
+                  for (octave_idx_type m = 0; m < plen; m++)
                     {
-                      error ("get: vector of handles must all have same type");
-                      break;
+                      caseless_str property = plist(m);
+
+                      vals(n, m) = go.get (property);
                     }
                 }
-            }
-
-          if (nargin > 1 && args(1).is_cellstr ())
-            {
-              Array<std::string> plist = args(1).xcellstr_value ("get: expecting property name or cell array of property names as second argument");
-
-              octave_idx_type plen = plist.numel ();
-
-              use_cell_format = true;
-
-              vals.resize (dim_vector (len, plen));
-
-              for (octave_idx_type n = 0; n < len; n++)
+              else
                 {
-                  graphics_object go = gh_manager::get_object (hcv(n));
-
-                  if (go)
-                    {
-                      for (octave_idx_type m = 0; m < plen; m++)
-                        {
-                          caseless_str property = plist(m);
-
-                          vals(n, m) = go.get (property);
-                        }
-                    }
-                  else
-                    {
-                      error ("get: invalid handle (= %g)", hcv(n));
-                      break;
-                    }
-                }
-            }
-          else
-            {
-              caseless_str property;
-
-              if (nargin > 1)
-                property = args(1).xstring_value ("get: expecting property name or cell array of property names as second argument");
-
-              vals.resize (dim_vector (len, 1));
-
-              for (octave_idx_type n = 0; n < len; n++)
-                {
-                  graphics_object go = gh_manager::get_object (hcv(n));
-
-                  if (go)
-                    {
-                      if (nargin == 1)
-                        vals(n) = go.get ();
-                      else
-                        vals(n) = go.get (property);
-                    }
-                  else
-                    {
-                      error ("get: invalid handle (= %g)", hcv(n));
-                      break;
-                    }
+                  error ("get: invalid handle (= %g)", hcv(n));
+                  break;
                 }
             }
         }
       else
-        error ("get: expecting graphics handle as first argument");
+        {
+          caseless_str property;
+
+          if (nargin > 1)
+            property = args(1).xstring_value ("get: expecting property name or cell array of property names as second argument");
+
+          vals.resize (dim_vector (len, 1));
+
+          for (octave_idx_type n = 0; n < len; n++)
+            {
+              graphics_object go = gh_manager::get_object (hcv(n));
+
+              if (go)
+                {
+                  if (nargin == 1)
+                    vals(n) = go.get ();
+                  else
+                    vals(n) = go.get (property);
+                }
+              else
+                {
+                  error ("get: invalid handle (= %g)", hcv(n));
+                  break;
+                }
+            }
+        }
     }
   else
     print_usage ();
 
   if (use_cell_format)
     retval = vals;
   else
     {
@@ -10131,39 +10121,34 @@ Undocumented internal function.\n\
   octave_value retval;
 
   Cell vals;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      ColumnVector hcv (args(0).vector_value ());
-
-      if (! error_state)
-        {
-          octave_idx_type len = hcv.numel ();
-
-          vals.resize (dim_vector (len, 1));
-
-          for (octave_idx_type n = 0; n < len; n++)
-            {
-              graphics_object go = gh_manager::get_object (hcv(n));
-
-              if (go)
-                vals(n) = go.get (true);
-              else
-                {
-                  error ("get: invalid handle (= %g)", hcv(n));
-                  break;
-                }
-            }
-        }
-      else
-        error ("get: expecting graphics handle as first argument");
+      ColumnVector hcv = args(0).xvector_value ("get: expecting graphics handle as first argument");
+
+      octave_idx_type len = hcv.numel ();
+
+      vals.resize (dim_vector (len, 1));
+
+      for (octave_idx_type n = 0; n < len; n++)
+        {
+          graphics_object go = gh_manager::get_object (hcv(n));
+
+          if (go)
+            vals(n) = go.get (true);
+          else
+            {
+              error ("get: invalid handle (= %g)", hcv(n));
+              break;
+            }
+        }
     }
   else
     print_usage ();
 
   octave_idx_type len = vals.numel ();
 
   if (len > 1)
     retval = vals;
diff --git a/libinterp/corefcn/matrix_type.cc b/libinterp/corefcn/matrix_type.cc
--- a/libinterp/corefcn/matrix_type.cc
+++ b/libinterp/corefcn/matrix_type.cc
@@ -271,37 +271,31 @@ LU@tie{}factorization.  Once the matrix 
               else if (str_typ == "unknown")
                 mattyp.invalidate_type ();
               else
                 error ("matrix_type: Unknown matrix type %s", str_typ.c_str ());
 
               if (nargin == 3
                   && (str_typ == "upper" || str_typ == "lower"))
                 {
-                  const ColumnVector perm =
-                    ColumnVector (args(2).vector_value ());
+                  const ColumnVector perm = args(2).vector_value ("matrix_type: Invalid permutation vector PERM");
 
-                  if (error_state)
+                  octave_idx_type len = perm.numel ();
+                  dim_vector dv = args(0).dims ();
+
+                  if (len != dv(0))
                     error ("matrix_type: Invalid permutation vector PERM");
                   else
                     {
-                      octave_idx_type len = perm.numel ();
-                      dim_vector dv = args(0).dims ();
+                      OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
 
-                      if (len != dv(0))
-                        error ("matrix_type: Invalid permutation vector PERM");
-                      else
-                        {
-                          OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
+                      for (octave_idx_type i = 0; i < len; i++)
+                        p[i] = static_cast<octave_idx_type> (perm (i)) - 1;
 
-                          for (octave_idx_type i = 0; i < len; i++)
-                            p[i] = static_cast<octave_idx_type> (perm (i)) - 1;
-
-                          mattyp.mark_as_permuted (len, p);
-                        }
+                      mattyp.mark_as_permuted (len, p);
                     }
                 }
               else if (nargin != 2
                        && str_typ != "banded positive definite"
                        && str_typ != "banded")
                 error ("matrix_type: Invalid number of arguments");
 
               // Set the matrix type
@@ -417,37 +411,31 @@ LU@tie{}factorization.  Once the matrix 
                 mattyp.mark_as_full ();
               else if (str_typ == "unknown")
                 mattyp.invalidate_type ();
               else
                 error ("matrix_type: Unknown matrix type %s", str_typ.c_str ());
 
               if (nargin == 3 && (str_typ == "upper" || str_typ == "lower"))
                 {
-                  const ColumnVector perm =
-                    ColumnVector (args(2).vector_value ());
+                  const ColumnVector perm = args(2).vector_value ("matrix_type: Invalid permutation vector PERM");
 
-                  if (error_state)
+                  octave_idx_type len = perm.numel ();
+                  dim_vector dv = args(0).dims ();
+
+                  if (len != dv(0))
                     error ("matrix_type: Invalid permutation vector PERM");
                   else
                     {
-                      octave_idx_type len = perm.numel ();
-                      dim_vector dv = args(0).dims ();
+                      OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
 
-                      if (len != dv(0))
-                        error ("matrix_type: Invalid permutation vector PERM");
-                      else
-                        {
-                          OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
+                      for (octave_idx_type i = 0; i < len; i++)
+                        p[i] = static_cast<octave_idx_type> (perm (i)) - 1;
 
-                          for (octave_idx_type i = 0; i < len; i++)
-                            p[i] = static_cast<octave_idx_type> (perm (i)) - 1;
-
-                          mattyp.mark_as_permuted (len, p);
-                        }
+                      mattyp.mark_as_permuted (len, p);
                     }
                 }
               else if (nargin != 2)
                 error ("matrix_type: Invalid number of arguments");
 
               // Set the matrix type
               if (args(0).is_single_type ())
                 {
diff --git a/libinterp/corefcn/ordschur.cc b/libinterp/corefcn/ordschur.cc
--- a/libinterp/corefcn/ordschur.cc
+++ b/libinterp/corefcn/ordschur.cc
@@ -111,22 +111,18 @@ is in the upper left corner, by doing:\n
   octave_value_list retval;
 
   if (nargin != 3)
     {
       print_usage ();
       return retval;
     }
 
-  const Array<octave_idx_type> sel = args(2).octave_idx_type_vector_value ();
-  if (error_state)
-    {
-      error ("ordschur: SELECT must be an array of integers");
-      return retval;
-    }
+  const Array<octave_idx_type> sel = args(2).octave_idx_type_vector_value ("ordschur: SELECT must be an array of integers");
+
   const octave_idx_type n = sel.numel ();
 
   const dim_vector dimU = args(0).dims ();
   const dim_vector dimS = args(1).dims ();
   if (n != dimU(0))
     {
       error ("ordschur: SELECT must have same length as the sides of U and S");
       return retval;
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -1089,22 +1089,19 @@ if @var{name} is not found.\n\
       if (args(0).is_string ())
         {
           std::string nm = args(0).string_value ();
 
           retval = octave_errno::lookup (nm);
         }
       else
         {
-          int val = args(0).int_value ();
+          int val = args(0).xint_value ("errno: argument must be string or integer");
 
-          if (! error_state)
-            retval = octave_errno::set (val);
-          else
-            error ("errno: argument must be string or integer");
+          retval = octave_errno::set (val);
         }
     }
   else if (nargin == 0)
     retval = octave_errno::get ();
   else
     print_usage ();
 
   return retval;
@@ -1240,23 +1237,20 @@ get_dimensions (const octave_value& a, c
 
   check_dimensions (nr, nc, warn_for);
 }
 
 void
 get_dimensions (const octave_value& a, const octave_value& b,
                 const char *warn_for, octave_idx_type& nr, octave_idx_type& nc)
 {
-  nr = a.is_empty () ? 0 : a.int_value ();
-  nc = b.is_empty () ? 0 : b.int_value ();
+  nr = a.is_empty () ? 0 : a.int_value ("%s: expecting two scalar arguments", warn_for);
+  nc = b.is_empty () ? 0 : b.int_value ("%s: expecting two scalar arguments", warn_for);
 
-  if (error_state)
-    error ("%s: expecting two scalar arguments", warn_for);
-  else
-    check_dimensions (nr, nc, warn_for);
+  check_dimensions (nr, nc, warn_for);
 }
 
 octave_idx_type
 dims_to_numel (const dim_vector& dims, const octave_value_list& idx_arg)
 {
   octave_idx_type retval;
 
   octave_idx_type len = idx_arg.length ();
diff --git a/libinterp/dldfcn/__eigs__.cc b/libinterp/dldfcn/__eigs__.cc
--- a/libinterp/dldfcn/__eigs__.cc
+++ b/libinterp/dldfcn/__eigs__.cc
@@ -299,98 +299,81 @@ Undocumented internal function.\n\
 
           // Use STL function to convert to upper case
           transform (typ.begin (), typ.end (), typ.begin (), toupper);
 
           sigma = 0.;
         }
       else
         {
-          sigma = args(2+arg_offset).complex_value ();
+          sigma = args(2+arg_offset).xcomplex_value ("eigs: SIGMA must be a scalar or a string");
 
-          if (! error_state)
-            have_sigma = true;
-          else
-            {
-              error ("eigs: SIGMA must be a scalar or a string");
-              return retval;
-            }
+          have_sigma = true;
         }
     }
 
   sigmar = std::real (sigma);
   sigmai = std::imag (sigma);
 
   if (nargin > (3+arg_offset))
     {
       if (args(3+arg_offset).is_map ())
         {
-          octave_scalar_map map = args(3+arg_offset).scalar_map_value ();
+          octave_scalar_map map = args(3+arg_offset).xscalar_map_value ("eigs: OPTS argument must be a scalar structure");
+
+          octave_value tmp;
 
-          if (! error_state)
+          // issym is ignored for complex matrix inputs
+          tmp = map.getfield ("issym");
+          if (tmp.is_defined () && !sym_tested)
             {
-              octave_value tmp;
+              symmetric = tmp.double_value () != 0.;
+              sym_tested = true;
+            }
 
-              // issym is ignored for complex matrix inputs
-              tmp = map.getfield ("issym");
-              if (tmp.is_defined () && !sym_tested)
-                {
-                  symmetric = tmp.double_value () != 0.;
-                  sym_tested = true;
-                }
+          // isreal is ignored if A is not a function
+          tmp = map.getfield ("isreal");
+          if (tmp.is_defined () && have_a_fun)
+            a_is_complex = ! (tmp.double_value () != 0.);
 
-              // isreal is ignored if A is not a function
-              tmp = map.getfield ("isreal");
-              if (tmp.is_defined () && have_a_fun)
-                a_is_complex = ! (tmp.double_value () != 0.);
+          tmp = map.getfield ("tol");
+          if (tmp.is_defined ())
+            tol = tmp.double_value ();
 
-              tmp = map.getfield ("tol");
-              if (tmp.is_defined ())
-                tol = tmp.double_value ();
-
-              tmp = map.getfield ("maxit");
-              if (tmp.is_defined ())
-                maxit = tmp.nint_value ();
+          tmp = map.getfield ("maxit");
+          if (tmp.is_defined ())
+            maxit = tmp.nint_value ();
 
-              tmp = map.getfield ("p");
-              if (tmp.is_defined ())
-                p = tmp.nint_value ();
-
-              tmp = map.getfield ("v0");
-              if (tmp.is_defined ())
-                {
-                  if (a_is_complex || b_is_complex)
-                    cresid = ComplexColumnVector (tmp.complex_vector_value ());
-                  else
-                    resid = ColumnVector (tmp.vector_value ());
-                }
+          tmp = map.getfield ("p");
+          if (tmp.is_defined ())
+            p = tmp.nint_value ();
 
-              tmp = map.getfield ("disp");
-              if (tmp.is_defined ())
-                disp = tmp.nint_value ();
-
-              tmp = map.getfield ("cholB");
-              if (tmp.is_defined ())
-                cholB = tmp.double_value () != 0.;
+          tmp = map.getfield ("v0");
+          if (tmp.is_defined ())
+            {
+              if (a_is_complex || b_is_complex)
+                cresid = ComplexColumnVector (tmp.complex_vector_value ());
+              else
+                resid = ColumnVector (tmp.vector_value ());
+            }
 
-              tmp = map.getfield ("permB");
-              if (tmp.is_defined ())
-                permB = ColumnVector (tmp.vector_value ()) - 1.0;
-            }
-          else
-            {
-              error ("eigs: OPTS argument must be a scalar structure");
-              return retval;
-            }
+          tmp = map.getfield ("disp");
+          if (tmp.is_defined ())
+            disp = tmp.nint_value ();
+
+          tmp = map.getfield ("cholB");
+          if (tmp.is_defined ())
+            cholB = tmp.double_value () != 0.;
+
+          tmp = map.getfield ("permB");
+          if (tmp.is_defined ())
+            permB = ColumnVector (tmp.vector_value ()) - 1.0;
         }
       else
-        {
-          error ("eigs: OPTS argument must be a structure");
-          return retval;
-        }
+        error ("eigs: OPTS argument must be a structure");
     }
 
   if (nargin > (4+arg_offset))
     {
       error ("eigs: incorrect number of arguments");
       return retval;
     }
 
diff --git a/libinterp/dldfcn/__magick_read__.cc b/libinterp/dldfcn/__magick_read__.cc
--- a/libinterp/dldfcn/__magick_read__.cc
+++ b/libinterp/dldfcn/__magick_read__.cc
@@ -765,22 +765,18 @@ Use @code{imread} instead.\n\
   if (indexes.is_string () && indexes.string_value () == "all")
     {
       frameidx.resize (dim_vector (1, nFrames));
       for (octave_idx_type i = 0; i < nFrames; i++)
         frameidx(i) = i;
     }
   else
     {
-      frameidx = indexes.int_vector_value ();
-      if (error_state)
-        {
-          error ("__magick_read__: invalid value for Index/Frame");
-          return output;
-        }
+      frameidx = indexes.xint_vector_value ("__magick_read__: invalid value for Index/Frame");
+
       // Fix indexes from base 1 to base 0, and at the same time, make
       // sure none of the indexes is outside the range of image number.
       const octave_idx_type n = frameidx.numel ();
       for (octave_idx_type i = 0; i < n; i++)
         {
           frameidx(i)--;
           if (frameidx(i) < 0 || frameidx(i) > nFrames - 1)
             {
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -1539,35 +1539,35 @@ octave_value::is_equal (const octave_val
       // Empty array also means a match.
       if (tmp.is_defined ())
         retval = tmp.is_true () || tmp.is_empty ();
     }
 
   return retval;
 }
 
-Cell
-octave_value::cell_value (void) const
-{
-  return rep->cell_value ();
-}
-
 // Define the idx_type_value function here instead of in ov.h to avoid
 // needing definitions for the SIZEOF_X macros in ov.h.
 
 octave_idx_type
 octave_value::idx_type_value (bool req_int, bool frc_str_conv) const
 {
 #if defined (USE_64_BIT_IDX_T)
   return int64_value (req_int, frc_str_conv);
 #else
   return int_value (req_int, frc_str_conv);
 #endif
 }
 
+Cell
+octave_value::cell_value (void) const
+{
+  return rep->cell_value ();
+}
+
 octave_map
 octave_value::map_value (void) const
 {
   return rep->map_value ();
 }
 
 octave_scalar_map
 octave_value::scalar_map_value (void) const
@@ -1909,20 +1909,126 @@ octave_value::float_complex_vector_value
           } \
  \
         throw; \
       } \
  \
     return retval; \
   }
 
-XVALUE_EXTRACTOR (Cell, xcell_value, cell_value)
+XVALUE_EXTRACTOR (short int, xshort_value, short_value)
+
+XVALUE_EXTRACTOR (unsigned short int, xushort_value, ushort_value)
+
+XVALUE_EXTRACTOR (int, xint_value, int_value)
+
+XVALUE_EXTRACTOR (unsigned int, xuint_value, uint_value)
+
+XVALUE_EXTRACTOR (int, xnint_value, nint_value)
+
+XVALUE_EXTRACTOR (long int, xlong_value, long_value)
+
+XVALUE_EXTRACTOR (unsigned long int, xulong_value, ulong_value)
+
+XVALUE_EXTRACTOR (int64_t, xint64_value, int64_value)
+
+XVALUE_EXTRACTOR (uint64_t, xuint64_value, uint64_value)
+
+XVALUE_EXTRACTOR (octave_idx_type, xidx_type_value, idx_type_value)
+
+XVALUE_EXTRACTOR (double, xdouble_value, double_value)
+XVALUE_EXTRACTOR (float, xfloat_value, float_value)
+
+XVALUE_EXTRACTOR (double, xscalar_value, scalar_value)
+XVALUE_EXTRACTOR (float, xfloat_scalar_value, float_scalar_value)
+
+XVALUE_EXTRACTOR (Matrix, xmatrix_value, matrix_value)
+XVALUE_EXTRACTOR (FloatMatrix, xfloat_matrix_value, float_matrix_value)
+
+XVALUE_EXTRACTOR (NDArray, xarray_value, array_value)
+XVALUE_EXTRACTOR (FloatNDArray, xfloat_array_value, float_array_value)
+
+XVALUE_EXTRACTOR (Complex, xcomplex_value, complex_value)
+XVALUE_EXTRACTOR (FloatComplex, xfloat_complex_value, float_complex_value)
+
+XVALUE_EXTRACTOR (ComplexMatrix, xcomplex_matrix_value, complex_matrix_value)
+XVALUE_EXTRACTOR (FloatComplexMatrix, xfloat_complex_matrix_value, float_complex_matrix_value)
+
+XVALUE_EXTRACTOR (ComplexNDArray, xcomplex_array_value, complex_array_value)
+XVALUE_EXTRACTOR (FloatComplexNDArray, xfloat_complex_array_value, float_complex_array_value)
+
+XVALUE_EXTRACTOR (bool, xbool_value, bool_value)
+XVALUE_EXTRACTOR (boolMatrix, xbool_matrix_value, bool_matrix_value)
+XVALUE_EXTRACTOR (boolNDArray, xbool_array_value, bool_array_value)
+
+XVALUE_EXTRACTOR (charMatrix, xchar_matrix_value, char_matrix_value)
+XVALUE_EXTRACTOR (charNDArray, xchar_array_value, char_array_value)
+
+XVALUE_EXTRACTOR (SparseMatrix, xsparse_matrix_value, sparse_matrix_value)
+XVALUE_EXTRACTOR (SparseComplexMatrix, xsparse_complex_matrix_value, sparse_complex_matrix_value)
+XVALUE_EXTRACTOR (SparseBoolMatrix, xsparse_bool_matrix_value, sparse_bool_matrix_value)
+
+XVALUE_EXTRACTOR (DiagMatrix, xdiag_matrix_value, diag_matrix_value)
+XVALUE_EXTRACTOR (FloatDiagMatrix, xfloat_diag_matrix_value, float_diag_matrix_value)
+XVALUE_EXTRACTOR (ComplexDiagMatrix, xcomplex_diag_matrix_value, complex_diag_matrix_value)
+XVALUE_EXTRACTOR (FloatComplexDiagMatrix, xfloat_complex_diag_matrix_value, float_complex_diag_matrix_value)
+
+XVALUE_EXTRACTOR (PermMatrix, xperm_matrix_value, perm_matrix_value)
+
+XVALUE_EXTRACTOR (octave_int8, xint8_scalar_value, int8_scalar_value)
+XVALUE_EXTRACTOR (octave_int16, xint16_scalar_value, int16_scalar_value)
+XVALUE_EXTRACTOR (octave_int32, xint32_scalar_value, int32_scalar_value)
+XVALUE_EXTRACTOR (octave_int64, xint64_scalar_value, int64_scalar_value)
+
+XVALUE_EXTRACTOR (octave_uint8, xuint8_scalar_value, uint8_scalar_value)
+XVALUE_EXTRACTOR (octave_uint16, xuint16_scalar_value, uint16_scalar_value)
+XVALUE_EXTRACTOR (octave_uint32, xuint32_scalar_value, uint32_scalar_value)
+XVALUE_EXTRACTOR (octave_uint64, xuint64_scalar_value, uint64_scalar_value)
+
+XVALUE_EXTRACTOR (int8NDArray, xint8_array_value, int8_array_value)
+XVALUE_EXTRACTOR (int16NDArray, xint16_array_value, int16_array_value)
+XVALUE_EXTRACTOR (int32NDArray, xint32_array_value, int32_array_value)
+XVALUE_EXTRACTOR (int64NDArray, xint64_array_value, int64_array_value)
+
+XVALUE_EXTRACTOR (uint8NDArray, xuint8_array_value, uint8_array_value)
+XVALUE_EXTRACTOR (uint16NDArray, xuint16_array_value, uint16_array_value)
+XVALUE_EXTRACTOR (uint32NDArray, xuint32_array_value, uint32_array_value)
+XVALUE_EXTRACTOR (uint64NDArray, xuint64_array_value, uint64_array_value)
+
 XVALUE_EXTRACTOR (std::string, xstring_value, rep->xstring_value)
+
+XVALUE_EXTRACTOR (Cell, xcell_value, cell_value)
 XVALUE_EXTRACTOR (Array<std::string>, xcellstr_value, cellstr_value)
 
+XVALUE_EXTRACTOR (Range, xrange_value, range_value)
+
+XVALUE_EXTRACTOR (octave_map, xmap_value, map_value)
+XVALUE_EXTRACTOR (octave_scalar_map, xscalar_map_value, scalar_map_value)
+
+XVALUE_EXTRACTOR (ColumnVector, xcolumn_vector_value, column_vector_value)
+XVALUE_EXTRACTOR (ComplexColumnVector, xcomplex_column_vector_value, complex_column_vector_value)
+
+XVALUE_EXTRACTOR (RowVector, xrow_vector_value, row_vector_value)
+XVALUE_EXTRACTOR (ComplexRowVector, xcomplex_row_vector_value, complex_row_vector_value)
+
+XVALUE_EXTRACTOR (FloatColumnVector, xfloat_column_vector_value, float_column_vector_value)
+XVALUE_EXTRACTOR (FloatComplexColumnVector, xfloat_complex_column_vector_value, float_complex_column_vector_value)
+
+XVALUE_EXTRACTOR (FloatRowVector, xfloat_row_vector_value, float_row_vector_value)
+XVALUE_EXTRACTOR (FloatComplexRowVector, xfloat_complex_row_vector_value, float_complex_row_vector_value)
+
+XVALUE_EXTRACTOR (Array<int>, xint_vector_value, int_vector_value)
+XVALUE_EXTRACTOR (Array<octave_idx_type>, xoctave_idx_type_vector_value, octave_idx_type_vector_value)
+
+XVALUE_EXTRACTOR (Array<double>, xvector_value, vector_value)
+XVALUE_EXTRACTOR (Array<Complex>, xcomplex_vector_value, complex_vector_value)
+
+XVALUE_EXTRACTOR (Array<float>, xfloat_vector_value, float_vector_value)
+XVALUE_EXTRACTOR (Array<FloatComplex>, xfloat_complex_vector_value, float_complex_vector_value)
+
 #undef XVALUE_EXTRACTOR
 
 octave_value
 octave_value::storable_value (void) const
 {
   octave_value retval = *this;
   if (is_null_value ())
     retval = octave_value (rep->empty_clone ());
diff --git a/libinterp/octave-value/ov.h b/libinterp/octave-value/ov.h
--- a/libinterp/octave-value/ov.h
+++ b/libinterp/octave-value/ov.h
@@ -763,18 +763,16 @@ public:
   { return rep->float_value (frc_str_conv); }
 
   double scalar_value (bool frc_str_conv = false) const
   { return rep->scalar_value (frc_str_conv); }
 
   float float_scalar_value (bool frc_str_conv = false) const
   { return rep->float_scalar_value (frc_str_conv); }
 
-  Cell cell_value (void) const;
-
   Matrix matrix_value (bool frc_str_conv = false) const
   { return rep->matrix_value (frc_str_conv); }
 
   FloatMatrix float_matrix_value (bool frc_str_conv = false) const
   { return rep->float_matrix_value (frc_str_conv); }
 
   NDArray array_value (bool frc_str_conv = false) const
   { return rep->array_value (frc_str_conv); }
@@ -886,21 +884,23 @@ public:
   { return rep->uint16_array_value (); }
 
   uint32NDArray uint32_array_value (void) const
   { return rep->uint32_array_value (); }
 
   uint64NDArray uint64_array_value (void) const
   { return rep->uint64_array_value (); }
 
+  std::string string_value (bool force = false) const
+  { return rep->string_value (force); }
+
   string_vector all_strings (bool pad = false) const
   { return rep->all_strings (pad); }
 
-  std::string string_value (bool force = false) const
-  { return rep->string_value (force); }
+  Cell cell_value (void) const;
 
   Array<std::string> cellstr_value (void) const
   { return rep->cellstr_value (); }
 
   Range range_value (void) const
   { return rep->range_value (); }
 
   octave_map map_value (void) const;
@@ -998,22 +998,166 @@ public:
   // conversions.  Throw an error if an object is the wrong type for
   // the requested value extraction.
   //
   // These functions are intended to provide a simple way to extract
   // values of specific types and display error messages that are more
   // meaningful than the generic "error: wrong type argument 'cell'"
   // message.
 
-  Cell xcell_value (const char *fmt, ...) const;
+  short int xshort_value (const char *fmt, ...) const;
+
+  unsigned short int xushort_value (const char *fmt, ...) const;
+
+  int xint_value (const char *fmt, ...) const;
+
+  unsigned int xuint_value (const char *fmt, ...) const;
+
+  int xnint_value (const char *fmt, ...) const;
+
+  long int xlong_value (const char *fmt, ...) const;
+
+  unsigned long int xulong_value (const char *fmt, ...) const;
+
+  int64_t xint64_value (const char *fmt, ...) const;
+
+  uint64_t xuint64_value (const char *fmt, ...) const;
+
+  octave_idx_type xidx_type_value (const char *fmt, ...) const;
+
+  double xdouble_value (const char *fmt, ...) const;
+
+  float xfloat_value (const char *fmt, ...) const;
+
+  double xscalar_value (const char *fmt, ...) const;
+
+  float xfloat_scalar_value (const char *fmt, ...) const;
+
+  Matrix xmatrix_value (const char *fmt, ...) const;
+
+  FloatMatrix xfloat_matrix_value (const char *fmt, ...) const;
+
+  NDArray xarray_value (const char *fmt, ...) const;
+
+  FloatNDArray xfloat_array_value (const char *fmt, ...) const;
+
+  Complex xcomplex_value (const char *fmt, ...) const;
+
+  FloatComplex xfloat_complex_value (const char *fmt, ...) const;
+
+  ComplexMatrix xcomplex_matrix_value (const char *fmt, ...) const;
+
+  FloatComplexMatrix xfloat_complex_matrix_value (const char *fmt, ...) const;
+
+  ComplexNDArray xcomplex_array_value (const char *fmt, ...) const;
+
+  FloatComplexNDArray xfloat_complex_array_value (const char *fmt, ...) const;
+
+  bool xbool_value (const char *fmt, ...) const;
+
+  boolMatrix xbool_matrix_value (const char *fmt, ...) const;
+
+  boolNDArray xbool_array_value (const char *fmt, ...) const;
+
+  charMatrix xchar_matrix_value (const char *fmt, ...) const;
+
+  charNDArray xchar_array_value (const char *fmt, ...) const;
+
+  SparseMatrix xsparse_matrix_value (const char *fmt, ...) const;
+
+  SparseComplexMatrix xsparse_complex_matrix_value (const char *fmt, ...) const;
+
+  SparseBoolMatrix xsparse_bool_matrix_value (const char *fmt, ...) const;
+
+  DiagMatrix xdiag_matrix_value (const char *fmt, ...) const;
+
+  FloatDiagMatrix xfloat_diag_matrix_value (const char *fmt, ...) const;
+
+  ComplexDiagMatrix xcomplex_diag_matrix_value (const char *fmt, ...) const;
+
+  FloatComplexDiagMatrix xfloat_complex_diag_matrix_value (const char *fmt, ...) const;
+
+  PermMatrix xperm_matrix_value (const char *fmt, ...) const;
+
+  octave_int8 xint8_scalar_value (const char *fmt, ...) const;
+
+  octave_int16 xint16_scalar_value (const char *fmt, ...) const;
+
+  octave_int32 xint32_scalar_value (const char *fmt, ...) const;
+
+  octave_int64 xint64_scalar_value (const char *fmt, ...) const;
+
+  octave_uint8 xuint8_scalar_value (const char *fmt, ...) const;
+
+  octave_uint16 xuint16_scalar_value (const char *fmt, ...) const;
+
+  octave_uint32 xuint32_scalar_value (const char *fmt, ...) const;
+
+  octave_uint64 xuint64_scalar_value (const char *fmt, ...) const;
+
+  int8NDArray xint8_array_value (const char *fmt, ...) const;
+
+  int16NDArray xint16_array_value (const char *fmt, ...) const;
+
+  int32NDArray xint32_array_value (const char *fmt, ...) const;
+
+  int64NDArray xint64_array_value (const char *fmt, ...) const;
+
+  uint8NDArray xuint8_array_value (const char *fmt, ...) const;
+
+  uint16NDArray xuint16_array_value (const char *fmt, ...) const;
+
+  uint32NDArray xuint32_array_value (const char *fmt, ...) const;
+
+  uint64NDArray xuint64_array_value (const char *fmt, ...) const;
 
   std::string xstring_value (const char *fmt, ...) const;
 
+  Cell xcell_value (const char *fmt, ...) const;
+
   Array<std::string> xcellstr_value (const char *fmt, ...) const;
 
+  Range xrange_value (const char *fmt, ...) const;
+
+  octave_map xmap_value (const char *fmt, ...) const;
+
+  octave_scalar_map xscalar_map_value (const char *fmt, ...) const;
+
+  ColumnVector xcolumn_vector_value (const char *fmt, ...) const;
+
+  ComplexColumnVector
+  xcomplex_column_vector_value (const char *fmt, ...) const;
+
+  RowVector xrow_vector_value (const char *fmt, ...) const;
+
+  ComplexRowVector xcomplex_row_vector_value (const char *fmt, ...) const;
+
+  FloatColumnVector xfloat_column_vector_value (const char *fmt, ...) const;
+
+  FloatComplexColumnVector
+  xfloat_complex_column_vector_value (const char *fmt, ...) const;
+
+  FloatRowVector xfloat_row_vector_value (const char *fmt, ...) const;
+
+  FloatComplexRowVector
+  xfloat_complex_row_vector_value (const char *fmt, ...) const;
+
+  Array<int> xint_vector_value (const char *fmt, ...) const;
+
+  Array<octave_idx_type>
+  xoctave_idx_type_vector_value (const char *fmt, ...) const;
+
+  Array<double> xvector_value (const char *fmt, ...) const;
+
+  Array<Complex> xcomplex_vector_value (const char *fmt, ...) const;
+
+  Array<float> xfloat_vector_value (const char *fmt, ...) const;
+
+  Array<FloatComplex> xfloat_complex_vector_value (const char *fmt, ...) const;
+
   // Possibly economize a lazy-indexed value.
 
   void maybe_economize (void)
   { rep->maybe_economize (); }
 
   // The following two hook conversions are called on any octave_value prior to
   // storing it to a "permanent" location, like a named variable, a cell or a
   // struct component, or a return value of a function.
