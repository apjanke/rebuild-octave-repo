# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1463635326 14400
#      Thu May 19 01:22:06 2016 -0400
# Node ID 0504351a45e6550f5ff39e85d90b351f9f6e63a8
# Parent  60212efcd9cbb05811e8cc559180e5ac21fe2c34
use namespace for file_stat classes

* file-stat.h, file-stat.cc: Put base_file_stat, file_stat, and
file_fstat in octave::sys namespace.  Change all uses.

diff --git a/libinterp/corefcn/__magick_read__.cc b/libinterp/corefcn/__magick_read__.cc
--- a/libinterp/corefcn/__magick_read__.cc
+++ b/libinterp/corefcn/__magick_read__.cc
@@ -1483,17 +1483,17 @@ Use @code{imwrite} instead.\n\
       imvec[i].quality (quality);
       imvec[i].animationDelay (delaytime(i));
       imvec[i].gifDisposeMethod (disposal_methods[disposalmethod(i)]);
     }
 
   // If writemode is set to append, read the image and append to it. Even
   // if set to append, make sure that something was read at all.
   const std::string writemode = options.getfield ("writemode").string_value ();
-  if (writemode == "append" && file_stat (filename).exists ())
+  if (writemode == "append" && octave::sys::file_stat (filename).exists ())
     {
       std::vector<Magick::Image> ini_imvec;
       read_file (filename, ini_imvec);
 
       if (ini_imvec.size () > 0)
         {
           ini_imvec.insert (ini_imvec.end (), imvec.begin (), imvec.end ());
           ini_imvec.swap (imvec);
@@ -1892,17 +1892,17 @@ Use @code{imfinfo} instead.\n\
   // the same for all images in the file. So we create a template, fill in
   // those values, and make a copy of the template for each image.
   octave_scalar_map template_info = (string_vector (fields));
 
   template_info.setfield ("Format", octave_value (format));
   // We can't actually get FormatVersion but even Matlab sometimes can't.
   template_info.setfield ("FormatVersion", octave_value (""));
 
-  const file_stat fs (filename);
+  const octave::sys::file_stat fs (filename);
   if (! fs)
     error ("imfinfo: error reading '%s': %s", filename.c_str (),
            fs.error ().c_str ());
 
   const octave::sys::localtime mtime (fs.mtime ());
   const std::string filetime = mtime.strftime ("%e-%b-%Y %H:%M:%S");
   template_info.setfield ("Filename",    octave_value (filename));
   template_info.setfield ("FileModDate", octave_value (filetime));
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -73,17 +73,17 @@ std::set<std::string> bp_table::caught_t
 std::set<std::string> bp_table::warnings_that_stop;
 
 // Read entire file called fname and return the contents as a string
 static std::string
 snarf_file (const std::string& fname)
 {
   std::string retval;
 
-  file_stat fs (fname);
+  octave::sys::file_stat fs (fname);
 
   if (fs)
     {
       size_t sz = fs.size ();
 
       std::ifstream file (fname.c_str (), std::ios::in | std::ios::binary);
 
       if (file)
diff --git a/libinterp/corefcn/dirfns.cc b/libinterp/corefcn/dirfns.cc
--- a/libinterp/corefcn/dirfns.cc
+++ b/libinterp/corefcn/dirfns.cc
@@ -220,17 +220,17 @@ Internal function called by mkdir.m.\n\
 
       dirname = octave::sys::file_ops::concat (parent, dir);
     }
   else if (nargin == 1)
     dirname = args(0).xstring_value ("mkdir: DIR must be a string");
 
   dirname = octave::sys::file_ops::tilde_expand (dirname);
 
-  file_stat fs (dirname);
+  octave::sys::file_stat fs (dirname);
 
   if (fs && fs.is_dir ())
     {
       // For Matlab compatibility, return true when directory already exists.
       return ovl (true, "directory exists", "mkdir");
     }
   else
     {
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -447,17 +447,17 @@ do_stream_open (const std::string& name,
 
   std::ios::openmode md = fopen_mode_to_ios_mode (mode);
 
   oct_mach_info::float_format flt_fmt =
     oct_mach_info::string_to_float_format (arch);
 
   std::string fname = octave::sys::file_ops::tilde_expand (name);
 
-  file_stat fs (fname);
+  octave::sys::file_stat fs (fname);
 
   if (! (md & std::ios::out))
     fname = find_data_file_in_load_path ("fopen", fname);
 
   if (! fs.is_dir ())
     {
 #if defined (HAVE_ZLIB)
       if (use_zlib)
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -10800,17 +10800,17 @@ undocumented.\n\
           else if (file[0] != '|')
             {
               size_t pos = file.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
               if (pos != std::string::npos)
                 {
                   std::string dirname = file.substr (0, pos+1);
 
-                  file_stat fs (dirname);
+                  octave::sys::file_stat fs (dirname);
 
                   if (! fs || ! fs.is_dir ())
                     error ("drawnow: nonexistent directory '%s'",
                            dirname.c_str ());
 
                 }
             }
 
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -50,17 +50,17 @@ load_path::hook_fcn_ptr load_path::add_h
 load_path::hook_fcn_ptr load_path::remove_hook = load_path::execute_pkg_del;
 std::string load_path::command_line_path;
 std::string load_path::sys_path;
 load_path::abs_dir_cache_type load_path::abs_dir_cache;
 
 void
 load_path::dir_info::update (void)
 {
-  file_stat fs (dir_name);
+  octave::sys::file_stat fs (dir_name);
 
   if (fs)
     {
       if (is_relative)
         {
           try
             {
               std::string abs_name = octave::sys::env::make_absolute (dir_name);
@@ -132,17 +132,17 @@ load_path::dir_info::is_package (const s
 
 void
 load_path::dir_info::initialize (void)
 {
   is_relative = ! octave::sys::env::absolute_pathname (dir_name);
 
   dir_time_last_checked = octave::sys::time (static_cast<time_t> (0));
 
-  file_stat fs (dir_name);
+  octave::sys::file_stat fs (dir_name);
 
   if (fs)
     {
       method_file_map.clear ();
       package_dir_map.clear ();
 
       dir_mtime = fs.mtime ();
       dir_time_last_checked = octave::sys::time ();
@@ -192,17 +192,17 @@ load_path::dir_info::get_file_list (cons
       octave_idx_type fcn_files_count = 0;
 
       for (octave_idx_type i = 0; i < len; i++)
         {
           std::string fname = flist[i];
 
           std::string full_name = octave::sys::file_ops::concat (d, fname);
 
-          file_stat fs (full_name);
+          octave::sys::file_stat fs (full_name);
 
           if (fs)
             {
               if (fs.is_dir ())
                 {
                   if (fname == "private")
                     get_private_file_map (full_name);
                   else if (fname[0] == '@')
@@ -301,17 +301,17 @@ load_path::dir_info::get_private_file_ma
 void
 load_path::dir_info::get_method_file_map (const std::string& d,
                                           const std::string& class_name)
 {
   method_file_map[class_name].method_file_map = get_fcn_files (d);
 
   std::string pd = octave::sys::file_ops::concat (d, "private");
 
-  file_stat fs (pd);
+  octave::sys::file_stat fs (pd);
 
   if (fs && fs.is_dir ())
     method_file_map[class_name].private_file_map = get_fcn_files (pd);
 }
 
 void
 load_path::dir_info::get_package_dir (const std::string& d,
                                       const std::string& package_name)
@@ -752,17 +752,17 @@ load_path::do_add (const std::string& di
   dir = strip_trailing_separators (dir);
 
   dir_info_list_iterator i = find_dir_info (dir);
 
   if (i != dir_info_list.end ())
     do_move (i, at_end);
   else
     {
-      file_stat fs (dir);
+      octave::sys::file_stat fs (dir);
 
       if (fs)
         {
           if (fs.is_dir ())
             {
               dir_info di (dir);
 
               if (at_end)
@@ -1305,17 +1305,17 @@ find_private_file (const std::string& fn
 
       std::string dir_name = curr_fcn->dir_name ();
 
       if (! dir_name.empty ())
         {
           std::string pfname = dir_name + octave::sys::file_ops::dir_sep_str ()
                                + "private" + octave::sys::file_ops::dir_sep_str () + fname;
 
-          file_stat fs (pfname);
+          octave::sys::file_stat fs (pfname);
 
           if (fs.exists () && fs.is_reg ())
             retval = pfname;
         }
     }
 
   return retval;
 }
@@ -1323,17 +1323,17 @@ find_private_file (const std::string& fn
 std::string
 load_path::do_find_file (const std::string& file) const
 {
   std::string retval;
 
   if (octave::sys::env::absolute_pathname (file)
       || octave::sys::env::rooted_relative_pathname (file))
     {
-      file_stat fs (file);
+      octave::sys::file_stat fs (file);
 
       return fs.exists () ? file : retval;
     }
   else
     {
       std::string tfile = find_private_file (file);
 
       if (! tfile.empty ())
@@ -1346,17 +1346,17 @@ load_path::do_find_file (const std::stri
       // element of the load path in turn.
 
       for (const_dir_info_list_iterator p = dir_info_list.begin ();
            p != dir_info_list.end ();
            p++)
         {
           std::string tfile = octave::sys::file_ops::concat (p->dir_name, file);
 
-          file_stat fs (tfile);
+          octave::sys::file_stat fs (tfile);
 
           if (fs.exists ())
             return tfile;
         }
     }
   else
     {
       // Look in cache.
@@ -1384,17 +1384,17 @@ std::string
 load_path::do_find_dir (const std::string& dir) const
 {
   std::string retval;
 
   if (dir.find_first_of (octave::sys::file_ops::dir_sep_chars ()) != std::string::npos
       && (octave::sys::env::absolute_pathname (dir)
           || octave::sys::env::rooted_relative_pathname (dir)))
     {
-      file_stat fs (dir);
+      octave::sys::file_stat fs (dir);
 
       if (fs.exists () && fs.is_dir ())
         return dir;
     }
   else
     {
       for (const_dir_info_list_iterator p = dir_info_list.begin ();
            p != dir_info_list.end ();
@@ -1411,17 +1411,17 @@ load_path::do_find_dir (const std::strin
             }
 
           size_t dir_len = dir.length ();
 
           if (dname_len > dir_len
               && octave::sys::file_ops::is_dir_sep (dname[dname_len - dir_len - 1])
               && dir == dname.substr (dname_len - dir_len))
             {
-              file_stat fs (p->dir_name);
+              octave::sys::file_stat fs (p->dir_name);
 
               if (fs.exists () && fs.is_dir ())
                 return p->dir_name;
             }
         }
     }
 
   return retval;
@@ -1431,17 +1431,17 @@ string_vector
 load_path::do_find_matching_dirs (const std::string& dir) const
 {
   std::list<std::string> retlist;
 
   if (dir.find_first_of (octave::sys::file_ops::dir_sep_chars ()) != std::string::npos
       && (octave::sys::env::absolute_pathname (dir)
           || octave::sys::env::rooted_relative_pathname (dir)))
     {
-      file_stat fs (dir);
+      octave::sys::file_stat fs (dir);
 
       if (fs.exists () && fs.is_dir ())
         retlist.push_back (dir);
     }
   else
     {
       for (const_dir_info_list_iterator p = dir_info_list.begin ();
            p != dir_info_list.end ();
@@ -1458,17 +1458,17 @@ load_path::do_find_matching_dirs (const 
             }
 
           size_t dir_len = dir.length ();
 
           if (dname_len > dir_len
               && octave::sys::file_ops::is_dir_sep (dname[dname_len - dir_len - 1])
               && dir == dname.substr (dname_len - dir_len))
             {
-              file_stat fs (p->dir_name);
+              octave::sys::file_stat fs (p->dir_name);
 
               if (fs.exists () && fs.is_dir ())
                 retlist.push_back (p->dir_name);
             }
         }
     }
 
   return retlist;
@@ -1491,30 +1491,30 @@ load_path::do_find_first_of (const strin
     {
       std::string file = flist[i];
 
       if (file.find_first_of (octave::sys::file_ops::dir_sep_chars ()) != std::string::npos)
         {
           if (octave::sys::env::absolute_pathname (file)
               || octave::sys::env::rooted_relative_pathname (file))
             {
-              file_stat fs (file);
+              octave::sys::file_stat fs (file);
 
               if (fs.exists ())
                 return file;
             }
           else
             {
               for (const_dir_info_list_iterator p = dir_info_list.begin ();
                    p != dir_info_list.end ();
                    p++)
                 {
                   std::string tfile = octave::sys::file_ops::concat (p->dir_name, file);
 
-                  file_stat fs (tfile);
+                  octave::sys::file_stat fs (tfile);
 
                   if (fs.exists ())
                     return tfile;
                 }
             }
         }
       else
         rel_flist[rel_flen++] = file;
@@ -1570,30 +1570,30 @@ load_path::do_find_all_first_of (const s
     {
       std::string file = flist[i];
 
       if (file.find_first_of (octave::sys::file_ops::dir_sep_chars ()) != std::string::npos)
         {
           if (octave::sys::env::absolute_pathname (file)
               || octave::sys::env::rooted_relative_pathname (file))
             {
-              file_stat fs (file);
+              octave::sys::file_stat fs (file);
 
               if (fs.exists ())
                 retlist.push_back (file);
             }
           else
             {
               for (const_dir_info_list_iterator p = dir_info_list.begin ();
                    p != dir_info_list.end ();
                    p++)
                 {
                   std::string tfile = octave::sys::file_ops::concat (p->dir_name, file);
 
-                  file_stat fs (tfile);
+                  octave::sys::file_stat fs (tfile);
 
                   if (fs.exists ())
                     retlist.push_back (tfile);
                 }
             }
         }
       else
         rel_flist[rel_flen++] = file;
@@ -2168,17 +2168,17 @@ genpath (const std::string& dirname, con
                   if (skip_p)
                     break;
                 }
 
               if (! skip_p)
                 {
                   std::string nm = octave::sys::file_ops::concat (dirname, elt);
 
-                  file_stat fs (nm);
+                  octave::sys::file_stat fs (nm);
 
                   if (fs && fs.is_dir ())
                     retval += dir_path::path_sep_str () + genpath (nm, skip);
                 }
             }
         }
     }
 
@@ -2206,17 +2206,17 @@ execute_pkg_add_or_del (const std::strin
 {
   if (! octave_interpreter_ready)
     return;
 
   unwind_protect frame;
 
   std::string file = octave::sys::file_ops::concat (dir, script_file);
 
-  file_stat fs (file);
+  octave::sys::file_stat fs (file);
 
   if (fs.exists ())
     source_file (file, "base");
 }
 
 void
 load_path::execute_pkg_add (const std::string& dir)
 {
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -497,24 +497,24 @@ find_file_to_load (const std::string& na
   size_t sep_pos = fname.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
   if (dot_pos == std::string::npos
       || (sep_pos != std::string::npos && dot_pos < sep_pos))
     {
       // Either no '.' in name or no '.' appears after last directory
       // separator.
 
-      file_stat fs (fname);
+      octave::sys::file_stat fs (fname);
 
       if (! (fs.exists () && fs.is_reg ()))
         fname = find_file_to_load (fname + ".mat", orig_name);
     }
   else
     {
-      file_stat fs (fname);
+      octave::sys::file_stat fs (fname);
 
       if (! (fs.exists () && fs.is_reg ()))
         {
           fname = "";
 
           error ("load: unable to find file %s", orig_name.c_str ());
         }
     }
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -871,17 +871,17 @@ read_mat5_binary_element (std::istream& 
                     // then the function points to a version of Octave
                     // or Matlab other than the running version. In that
                     // case we replace with the same function in the
                     // running version of Octave?
 
                     // First check if just replacing matlabroot is enough
                     std::string str = OCTAVE_EXEC_PREFIX +
                                       fpath.substr (mroot.length ());
-                    file_stat fs (str);
+                    octave::sys::file_stat fs (str);
 
                     if (fs.exists ())
                       {
                         size_t xpos
                           = str.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
                         std::string dir_name = str.substr (0, xpos);
 
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -330,17 +330,17 @@ out_of_date_check (octave_value& functio
                       time_t tp = ottp.unix_time ();
 
                       fcn->mark_fcn_file_up_to_date (octave::sys::time ());
 
                       if (! (Vignore_function_time_stamp == 2
                              || (Vignore_function_time_stamp
                                  && fcn->is_system_fcn_file ())))
                         {
-                          file_stat fs (ff);
+                          octave::sys::file_stat fs (ff);
 
                           if (fs)
                             {
                               if (fs.is_newer (tp))
                                 {
                                   retval = load_out_of_date_fcn (ff, dir_name,
                                                                  function,
                                                                  dispatch_type,
diff --git a/libinterp/corefcn/syscalls.cc b/libinterp/corefcn/syscalls.cc
--- a/libinterp/corefcn/syscalls.cc
+++ b/libinterp/corefcn/syscalls.cc
@@ -55,17 +55,17 @@ along with Octave; see the file COPYING.
 #include "oct-stdstrm.h"
 #include "oct-stream.h"
 #include "sysdep.h"
 #include "utils.h"
 #include "variables.h"
 #include "input.h"
 
 static octave_scalar_map
-mk_stat_map (const base_file_stat& fs)
+mk_stat_map (const base_octave::sys::file_stat& fs)
 {
   octave_scalar_map m;
 
   m.assign ("dev", static_cast<double> (fs.dev ()));
   m.assign ("ino", fs.ino ());
   m.assign ("mode", fs.mode ());
   m.assign ("modestr", fs.mode_as_string ());
   m.assign ("nlink", fs.nlink ());
@@ -84,17 +84,17 @@ mk_stat_map (const base_file_stat& fs)
 #if defined (HAVE_STRUCT_STAT_ST_BLOCKS)
   m.assign ("blocks", fs.blocks ());
 #endif
 
   return m;
 }
 
 static octave_value_list
-mk_stat_result (const base_file_stat& fs)
+mk_stat_result (const base_octave::sys::file_stat& fs)
 {
   if (fs)
     return ovl (octave_value (mk_stat_map (fs)), 0, "");
   else
     return ovl (Matrix (), -1, fs.error ());
 }
 
 DEFUNX ("dup2", Fdup2, args, ,
@@ -622,17 +622,17 @@ The function outputs are described in th
 @seealso{stat, symlink}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   std::string fname = args(0).xstring_value ("lstat: NAME must be a string");
 
-  file_stat fs (fname, false);
+  octave::sys::file_stat fs (fname, false);
 
   return mk_stat_result (fs);
 }
 
 // FIXME: This routine also exists verbatim in file-io.cc.
 //        Maybe change to be a general utility routine.
 static int
 convert (int x, int ibase, int obase)
@@ -855,17 +855,17 @@ For example:\n\
       file_fstat fs (fid);
 
       retval = mk_stat_result (fs);
     }
   else
     {
       std::string fname = args(0).xstring_value ("stat: NAME must be a string");
 
-      file_stat fs (fname);
+      octave::sys::file_stat fs (fname);
 
       retval = mk_stat_result (fs);
     }
 
   return retval;
 }
 
 DEFUNX ("S_ISREG", FS_ISREG, args, ,
@@ -878,17 +878,17 @@ The value of @var{mode} is assumed to be
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   double mode = args(0).xdouble_value ("S_ISREG: invalid MODE value");
 
-  return ovl (file_stat::is_reg (static_cast<mode_t> (mode)));
+  return ovl (octave::sys::file_stat::is_reg (static_cast<mode_t> (mode)));
 }
 
 DEFUNX ("S_ISDIR", FS_ISDIR, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {} S_ISDIR (@var{mode})\n\
 Return true if @var{mode} corresponds to a directory.\n\
 \n\
 The value of @var{mode} is assumed to be returned from a call to\n\
@@ -896,17 +896,17 @@ The value of @var{mode} is assumed to be
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   double mode = args(0).xdouble_value ("S_ISDIR: invalid MODE value");
 
-  return ovl (file_stat::is_dir (static_cast<mode_t> (mode)));
+  return ovl (octave::sys::file_stat::is_dir (static_cast<mode_t> (mode)));
 }
 
 DEFUNX ("S_ISCHR", FS_ISCHR, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {} S_ISCHR (@var{mode})\n\
 Return true if @var{mode} corresponds to a character device.\n\
 \n\
 The value of @var{mode} is assumed to be returned from a call to\n\
@@ -914,17 +914,17 @@ The value of @var{mode} is assumed to be
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   double mode = args(0).xdouble_value ("S_ISCHR: invalid MODE value");
 
-  return ovl (file_stat::is_chr (static_cast<mode_t> (mode)));
+  return ovl (octave::sys::file_stat::is_chr (static_cast<mode_t> (mode)));
 }
 
 DEFUNX ("S_ISBLK", FS_ISBLK, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {} S_ISBLK (@var{mode})\n\
 Return true if @var{mode} corresponds to a block device.\n\
 \n\
 The value of @var{mode} is assumed to be returned from a call to\n\
@@ -932,17 +932,17 @@ The value of @var{mode} is assumed to be
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   double mode = args(0).xdouble_value ("S_ISBLK: invalid MODE value");
 
-  return ovl (file_stat::is_blk (static_cast<mode_t> (mode)));
+  return ovl (octave::sys::file_stat::is_blk (static_cast<mode_t> (mode)));
 }
 
 DEFUNX ("S_ISFIFO", FS_ISFIFO, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {} S_ISFIFO (@var{mode})\n\
 Return true if @var{mode} corresponds to a fifo.\n\
 \n\
 The value of @var{mode} is assumed to be returned from a call to\n\
@@ -950,17 +950,17 @@ The value of @var{mode} is assumed to be
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   double mode = args(0).xdouble_value ("S_ISFIFO: invalid MODE value");
 
-  return ovl (file_stat::is_fifo (static_cast<mode_t> (mode)));
+  return ovl (octave::sys::file_stat::is_fifo (static_cast<mode_t> (mode)));
 }
 
 DEFUNX ("S_ISLNK", FS_ISLNK, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {} S_ISLNK (@var{mode})\n\
 Return true if @var{mode} corresponds to a symbolic link.\n\
 \n\
 The value of @var{mode} is assumed to be returned from a call to\n\
@@ -968,17 +968,17 @@ The value of @var{mode} is assumed to be
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   double mode = args(0).xdouble_value ("S_ISLNK: invalid MODE value");
 
-  return ovl (file_stat::is_lnk (static_cast<mode_t> (mode)));
+  return ovl (octave::sys::file_stat::is_lnk (static_cast<mode_t> (mode)));
 }
 
 DEFUNX ("S_ISSOCK", FS_ISSOCK, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {} S_ISSOCK (@var{mode})\n\
 Return true if @var{mode} corresponds to a socket.\n\
 \n\
 The value of @var{mode} is assumed to be returned from a call to\n\
@@ -986,17 +986,17 @@ The value of @var{mode} is assumed to be
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   double mode = args(0).xdouble_value ("S_ISSOCK: invalid MODE value");
 
-  return ovl (file_stat::is_sock (static_cast<mode_t> (mode)));
+  return ovl (octave::sys::file_stat::is_sock (static_cast<mode_t> (mode)));
 }
 
 DEFUN (gethostname, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} gethostname ()\n\
 Return the hostname of the system where Octave is running.\n\
 @end deftypefn")
 {
diff --git a/libinterp/corefcn/sysdep.cc b/libinterp/corefcn/sysdep.cc
--- a/libinterp/corefcn/sysdep.cc
+++ b/libinterp/corefcn/sysdep.cc
@@ -295,18 +295,18 @@ same_file_internal (const std::string& f
     }
 
   return retval;
 
 #else
 
   // POSIX Code
 
-  file_stat fs_file1 (file1);
-  file_stat fs_file2 (file2);
+  octave::sys::file_stat fs_file1 (file1);
+  octave::sys::file_stat fs_file2 (file2);
 
   return (fs_file1 && fs_file2
           && fs_file1.ino () == fs_file2.ino ()
           && fs_file1.dev () == fs_file2.dev ());
 
 #endif
 }
 
diff --git a/libinterp/corefcn/urlwrite.cc b/libinterp/corefcn/urlwrite.cc
--- a/libinterp/corefcn/urlwrite.cc
+++ b/libinterp/corefcn/urlwrite.cc
@@ -354,17 +354,17 @@ urlwrite (\"http://www.google.com/search
       if (param.numel () % 2 == 1)
         error ("urlwrite: number of elements in PARAM must be even");
     }
 
   // The file should only be deleted if it doesn't initially exist, we
   // create it, and the download fails.  We use unwind_protect to do
   // it so that the deletion happens no matter how we exit the function.
 
-  file_stat fs (filename);
+  octave::sys::file_stat fs (filename);
 
   std::ofstream ofile (filename.c_str (), std::ios::out | std::ios::binary);
 
   if (! ofile.is_open ())
     error ("urlwrite: unable to open file");
 
   unwind_protect_safe frame;
 
@@ -811,17 +811,17 @@ Undocumented internal function\n\
 
   glob_match pattern (octave::sys::file_ops::tilde_expand (pat));
   string_vector files = pattern.glob ();
 
   for (octave_idx_type i = 0; i < files.numel (); i++)
     {
       std::string file = files(i);
 
-      file_stat fs (file);
+      octave::sys::file_stat fs (file);
 
       if (! fs.exists ())
         error ("__ftp__mput: file does not exist");
 
       if (fs.is_dir ())
         {
           file_list.append (curl.mput_directory ("", file));
 
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -443,17 +443,17 @@ find_data_file_in_load_path  (const std:
   std::string fname = file;
 
   if (! (octave::sys::env::absolute_pathname (fname)
          || octave::sys::env::rooted_relative_pathname (fname)))
     {
       // Load path will also search "." first, but we don't want to
       // issue a warning if the file is found in the current directory,
       // so do an explicit check for that.
-      file_stat fs (fname);
+      octave::sys::file_stat fs (fname);
 
       bool local_file_ok
         = fs.exists () && (fs.is_reg () || ! require_regular_file);
 
       if (! local_file_ok)
         {
           // Not directly found; search load path.
           std::string tmp
@@ -480,17 +480,17 @@ fcn_file_in_path (const std::string& nam
   std::string retval;
 
   int len = name.length ();
 
   if (len > 0)
     {
       if (octave::sys::env::absolute_pathname (name))
         {
-          file_stat fs (name);
+          octave::sys::file_stat fs (name);
 
           if (fs.exists () && ! fs.is_dir ())
             retval = name;
         }
       else if (len > 2 && name[len - 2] == '.' && name[len - 1] == 'm')
         retval = load_path::find_fcn_file (name.substr (0, len-2));
       else
         {
@@ -514,17 +514,17 @@ contents_file_in_path (const std::string
 {
   std::string retval;
 
   if (dir.length () > 0)
     {
       std::string tcontents = octave::sys::file_ops::concat (load_path::find_dir (dir),
                                                 std::string ("Contents.m"));
 
-      file_stat fs (tcontents);
+      octave::sys::file_stat fs (tcontents);
 
       if (fs.exists ())
         retval = octave::sys::env::make_absolute (tcontents);
     }
 
   return retval;
 }
 
@@ -538,17 +538,17 @@ oct_file_in_path (const std::string& nam
   std::string retval;
 
   int len = name.length ();
 
   if (len > 0)
     {
       if (octave::sys::env::absolute_pathname (name))
         {
-          file_stat fs (name);
+          octave::sys::file_stat fs (name);
 
           if (fs.exists ())
             retval = name;
         }
       else if (len > 4 && name.find (".oct", len-5))
         retval = load_path::find_oct_file (name.substr (0, len-4));
       else
         retval = load_path::find_oct_file (name);
@@ -567,17 +567,17 @@ mex_file_in_path (const std::string& nam
   std::string retval;
 
   int len = name.length ();
 
   if (len > 0)
     {
       if (octave::sys::env::absolute_pathname (name))
         {
-          file_stat fs (name);
+          octave::sys::file_stat fs (name);
 
           if (fs.exists ())
             retval = name;
         }
       else if (len > 4 && name.find (".mex", len-5))
         retval = load_path::find_mex_file (name.substr (0, len-4));
       else
         retval = load_path::find_mex_file (name);
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -457,17 +457,17 @@ symbol_exist (const std::string& name, c
             }
         }
 
       file_name = file_in_path (name, "");
 
       if (file_name.empty ())
         file_name = name;
 
-      file_stat fs (file_name);
+      octave::sys::file_stat fs (file_name);
 
       if (fs)
         {
           if (search_any || search_file)
             {
               if (fs.is_dir ())
                 return 7;
 
diff --git a/libinterp/dldfcn/__init_gnuplot__.cc b/libinterp/dldfcn/__init_gnuplot__.cc
--- a/libinterp/dldfcn/__init_gnuplot__.cc
+++ b/libinterp/dldfcn/__init_gnuplot__.cc
@@ -173,25 +173,25 @@ have_gnuplot_binary (void)
   const std::string path = octave::sys::env::getenv ("PATH");
 
   octave_value_list tmp = feval ("gnuplot_binary", octave_value_list ());
   std::string gnuplot_binary = tmp(0).string_value ();
 
   string_vector args (gnuplot_binary);
   std::string gnuplot_path = search_path_for_file (path, args);
 
-  file_stat fs (gnuplot_path);
+  octave::sys::file_stat fs (gnuplot_path);
 
   if (! fs.exists () && ! exeext.empty ())
     {
       args[0] += exeext;
 
       gnuplot_path = search_path_for_file (path, args);
 
-      fs = file_stat (gnuplot_path);
+      fs = octave::sys::file_stat (gnuplot_path);
     }
 
   return fs.exists ();
 }
 
 // Initialize the gnuplot graphics toolkit.
 
 DEFUN_DLD (__init_gnuplot__, , , "")
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -261,17 +261,17 @@ octave_fcn_handle::set_fcn (const std::s
   if (octaveroot.length () != 0
       && fpath.length () >= octaveroot.length ()
       && fpath.substr (0, octaveroot.length ()) == octaveroot
       && OCTAVE_EXEC_PREFIX != octaveroot)
     {
       // First check if just replacing matlabroot is enough
       std::string str = OCTAVE_EXEC_PREFIX +
                         fpath.substr (octaveroot.length ());
-      file_stat fs (str);
+      octave::sys::file_stat fs (str);
 
       if (fs.exists ())
         {
           size_t xpos = str.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
           std::string dir_name = str.substr (0, xpos);
 
           octave_function *xfcn
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -428,17 +428,17 @@ initial_class_path (void)
 
   // find octave.jar file
   if (! retval.empty ())
     {
       std::string sep = octave::sys::file_ops::dir_sep_str ();
 
       std::string jar_file = java_dir + sep + "octave.jar";
 
-      file_stat jar_exists (jar_file);
+      octave::sys::file_stat jar_exists (jar_file);
 
       if (jar_exists)
         {
           // initialize static classpath to octave.jar
           retval = jar_file;
 
           // The base classpath has been set.
           // Try to find an optional file specifying classpaths in 3 places.
@@ -452,49 +452,49 @@ initial_class_path (void)
           // The filename is "javaclasspath.txt", but historically
           // has been "classpath.txt" so both are supported.
           std::string cp_list[] = {"javaclasspath.txt", "classpath.txt"};
 
           for (int i=0; i<2; i++)
             {
               std::string filename = cp_list[i];
               std::string cp_file = filename;
-              file_stat   cp_exists;
+              octave::sys::file_stat   cp_exists;
 
               // Try to find classpath file in the current directory.
 
-              cp_exists = file_stat (cp_file);
+              cp_exists = octave::sys::file_stat (cp_file);
               if (cp_exists)
                 {
                   // File found.  Add its contents to the static classpath.
                   std::string classpath = read_classpath_txt (cp_file);
                   retval.append (classpath);
                 }
 
               // Try to find classpath file in the user's home directory.
 
               if (cwd != home_dir)
                 {
                   cp_file = "~" + sep + filename;
                   cp_file = octave::sys::file_ops::tilde_expand (cp_file);
-                  cp_exists = file_stat (cp_file);
+                  cp_exists = octave::sys::file_stat (cp_file);
                   if (cp_exists)
                     {
                       // File found.  Add its contents to the static classpath.
                       std::string classpath = read_classpath_txt (cp_file);
                       retval.append (classpath);
                     }
                 }
 
               // Try to find classpath file in the Octave install directory.
 
               if (cwd != java_dir)
                 {
                   cp_file = java_dir + sep + filename;
-                  cp_exists = file_stat (cp_file);
+                  cp_exists = octave::sys::file_stat (cp_file);
                   if (cp_exists)
                     {
                       // File found.  Add its contents to the static classpath.
                       std::string classpath = read_classpath_txt (cp_file);
                       retval.append (classpath);
                     }
                 }
             }
diff --git a/libinterp/octave.cc b/libinterp/octave.cc
--- a/libinterp/octave.cc
+++ b/libinterp/octave.cc
@@ -391,17 +391,17 @@ execute_startup_files (void)
       std::string local_rc;
 
       if (! home_rc.empty ())
         {
           safe_source_file (home_rc, context, verbose, require_file);
 
           // Names alone are not enough.
 
-          file_stat fs_home_rc (home_rc);
+          octave::sys::file_stat fs_home_rc (home_rc);
 
           if (fs_home_rc)
             {
               // We want to check for curr_dir after executing home_rc
               // because doing that may change the working directory.
 
               local_rc = octave::sys::env::make_absolute (initfile);
 
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -3202,17 +3202,17 @@ octave_base_parser::frob_function (const
           else
             fcn->mark_as_class_method ();
 
           fcn->stash_dispatch_class (curr_class_name);
         }
 
       std::string nm = fcn->fcn_file_name ();
 
-      file_stat fs (nm);
+      octave::sys::file_stat fs (nm);
 
       if (fs && fs.is_newer (now))
         warning_with_id ("Octave:future-time-stamp",
                          "time stamp for '%s' is in the future", nm.c_str ());
     }
   else if (! input_from_tmp_history_file
            && ! lexer.force_script
            && lexer.reading_script_file
@@ -4491,17 +4491,17 @@ not loaded anymore during the current Oc
             {
               std::string fname = fcn->fcn_file_name ();
 
               if (! fname.empty ())
                 {
                   fname = octave::sys::env::make_absolute (fname);
                   fname = fname.substr (0, fname.find_last_of (octave::sys::file_ops::dir_sep_str ()) + 1);
 
-                  file_stat fs (fname + nm);
+                  octave::sys::file_stat fs (fname + nm);
 
                   if (fs.exists ())
                     {
                       nm = fname + nm;
                       found = true;
                     }
                 }
             }
diff --git a/liboctave/system/file-ops.cc b/liboctave/system/file-ops.cc
--- a/liboctave/system/file-ops.cc
+++ b/liboctave/system/file-ops.cc
@@ -590,17 +590,17 @@ namespace octave
 
               // Skip current directory and parent.
               if (nm == "." || nm == "..")
                 continue;
 
               std::string fullnm = name + octave::sys::file_ops::dir_sep_str () + nm;
 
               // Get info about the file.  Don't follow links.
-              file_stat fs (fullnm, false);
+              octave::sys::file_stat fs (fullnm, false);
 
               if (fs)
                 {
                   if (fs.is_dir ())
                     {
                       status = recursive_rmdir (fullnm, msg);
 
                       if (status < 0)
@@ -683,17 +683,17 @@ namespace octave
       msg = "";
 
       std::string retval;
 
       // get dir path to use for template
       std::string templatename;
       if (dir.empty ())
         templatename = octave::sys::env::get_temp_directory ();
-      else if (! file_stat (dir, false).is_dir ())
+      else if (! octave::sys::file_stat (dir, false).is_dir ())
         templatename = octave::sys::env::get_temp_directory ();
       else
         templatename = dir;
 
       // add dir sep char if it is not there
       if (*templatename.rbegin () != octave::sys::file_ops::dir_sep_char ())
         templatename += octave::sys::file_ops::dir_sep_char ();
 
diff --git a/liboctave/system/file-stat.cc b/liboctave/system/file-stat.cc
--- a/liboctave/system/file-stat.cc
+++ b/liboctave/system/file-stat.cc
@@ -31,253 +31,260 @@ along with Octave; see the file COPYING.
 #include <unistd.h>
 
 #include "filemode.h"
 
 #include "file-ops.h"
 #include "file-stat.h"
 #include "statdefs.h"
 
-// FIXME: the is_* and mode_as_string functions are only valid
-// for initialized objects.  If called for an object that is not
-// initialized, they should throw an exception.
-
-bool
-base_file_stat::is_blk (void) const
-{
-  return exists () && is_blk (fs_mode);
-}
-
-bool
-base_file_stat::is_chr (void) const
-{
-  return exists () && is_chr (fs_mode);
-}
-
-bool
-base_file_stat::is_dir (void) const
-{
-  return exists () && is_dir (fs_mode);
-}
-
-bool
-base_file_stat::is_fifo (void) const
-{
-  return exists () && is_fifo (fs_mode);
-}
-
-bool
-base_file_stat::is_lnk (void) const
-{
-  return exists () && is_lnk (fs_mode);
-}
-
-bool
-base_file_stat::is_reg (void) const
+namespace octave
 {
-  return exists () && is_reg (fs_mode);
-}
+  namespace sys
+  {
+    // FIXME: the is_* and mode_as_string functions are only valid
+    // for initialized objects.  If called for an object that is not
+    // initialized, they should throw an exception.
+
+    bool
+    base_file_stat::is_blk (void) const
+    {
+      return exists () && is_blk (m_mode);
+    }
+
+    bool
+    base_file_stat::is_chr (void) const
+    {
+      return exists () && is_chr (m_mode);
+    }
+
+    bool
+    base_file_stat::is_dir (void) const
+    {
+      return exists () && is_dir (m_mode);
+    }
 
-bool
-base_file_stat::is_sock (void) const
-{
-  return exists () && is_sock (fs_mode);
-}
+    bool
+    base_file_stat::is_fifo (void) const
+    {
+      return exists () && is_fifo (m_mode);
+    }
+
+    bool
+    base_file_stat::is_lnk (void) const
+    {
+      return exists () && is_lnk (m_mode);
+    }
 
-bool
-base_file_stat::is_blk (mode_t mode)
-{
+    bool
+    base_file_stat::is_reg (void) const
+    {
+      return exists () && is_reg (m_mode);
+    }
+
+    bool
+    base_file_stat::is_sock (void) const
+    {
+      return exists () && is_sock (m_mode);
+    }
+
+    bool
+    base_file_stat::is_blk (mode_t mode)
+    {
 #if defined (S_ISBLK)
-  return S_ISBLK (mode);
+      return S_ISBLK (mode);
 #else
-  return false;
+      return false;
 #endif
-}
+    }
 
-bool
-base_file_stat::is_chr (mode_t mode)
-{
+    bool
+    base_file_stat::is_chr (mode_t mode)
+    {
 #if defined (S_ISCHR)
-  return S_ISCHR (mode);
+      return S_ISCHR (mode);
 #else
-  return false;
-#endif
-}
-
-bool
-base_file_stat::is_dir (mode_t mode)
-{
-#if defined (S_ISDIR)
-  return S_ISDIR (mode);
-#else
-  return false;
+      return false;
 #endif
-}
+    }
 
-bool
-base_file_stat::is_fifo (mode_t mode)
-{
-#if defined (S_ISFIFO)
-  return S_ISFIFO (mode);
+    bool
+    base_file_stat::is_dir (mode_t mode)
+    {
+#if defined (S_ISDIR)
+      return S_ISDIR (mode);
 #else
-  return false;
+      return false;
 #endif
-}
+    }
 
-bool
-base_file_stat::is_lnk (mode_t mode)
-{
-#if defined (S_ISLNK)
-  return S_ISLNK (mode);
+    bool
+    base_file_stat::is_fifo (mode_t mode)
+    {
+#if defined (S_ISFIFO)
+      return S_ISFIFO (mode);
 #else
-  return false;
+      return false;
 #endif
-}
+    }
 
-bool
-base_file_stat::is_reg (mode_t mode)
-{
+    bool
+    base_file_stat::is_lnk (mode_t mode)
+    {
+#if defined (S_ISLNK)
+      return S_ISLNK (mode);
+#else
+      return false;
+#endif
+    }
+
+    bool
+    base_file_stat::is_reg (mode_t mode)
+    {
 #if defined (S_ISREG)
-  return S_ISREG (mode);
+      return S_ISREG (mode);
 #else
-  return false;
+      return false;
 #endif
-}
+    }
 
-bool
-base_file_stat::is_sock (mode_t mode)
-{
+    bool
+    base_file_stat::is_sock (mode_t mode)
+    {
 #if defined (S_ISSOCK)
-  return S_ISSOCK (mode);
+      return S_ISSOCK (mode);
 #else
-  return false;
+      return false;
 #endif
-}
+    }
 
-std::string
-base_file_stat::mode_as_string (void) const
-{
-  char buf[12];
+    std::string
+    base_file_stat::mode_as_string (void) const
+    {
+      char buf[12];
 
-  strmode (fs_mode, buf);
+      strmode (m_mode, buf);
 
-  return std::string (buf);
-}
+      return std::string (buf);
+    }
 
-// Has FILE been modified since TIME?  Returns 1 for yes, 0 for no,
-// and -1 for any error.
+    // Has FILE been modified since TIME?  Returns 1 for yes, 0 for no,
+    // and -1 for any error.
 
-int
-base_file_stat::is_newer (const std::string& file, const octave::sys::time& time)
-{
-  file_stat fs (file);
+    int
+    base_file_stat::is_newer (const std::string& file,
+                              const octave::sys::time& time)
+    {
+      file_stat fs (file);
 
-  return fs ? fs.is_newer (time) : -1;
-}
-
-// Private stuff:
+      return fs ? fs.is_newer (time) : -1;
+    }
 
-void
-file_stat::update_internal (bool force)
-{
-  if (! initialized || force)
+    // Private stuff:
+
+    void
+    file_stat::update_internal (bool force)
     {
-      initialized = false;
-      fail = false;
+      if (! initialized || force)
+        {
+          initialized = false;
+          fail = false;
 
-      std::string full_file_name = octave::sys::file_ops::tilde_expand (file_name);
+          std::string full_file_name = octave::sys::file_ops::tilde_expand (file_name);
 
 #if defined (__WIN32__)
-      // Remove trailing slash.
-      if (octave::sys::file_ops::is_dir_sep (full_file_name[full_file_name.length () - 1])
-          && full_file_name.length () != 1
-          && ! (full_file_name.length () == 3 && full_file_name[1] == ':'))
-        full_file_name.resize (full_file_name.length () - 1);
+          // Remove trailing slash.
+          if (octave::sys::file_ops::is_dir_sep (full_file_name[full_file_name.length () - 1])
+              && full_file_name.length () != 1
+              && ! (full_file_name.length () == 3 && full_file_name[1] == ':'))
+            full_file_name.resize (full_file_name.length () - 1);
 #endif
 
-      const char *cname = full_file_name.c_str ();
+          const char *cname = full_file_name.c_str ();
 
-      struct stat buf;
+          struct stat buf;
 
-      int status = follow_links
-                   ? stat (cname, &buf) : gnulib::lstat (cname, &buf);
+          int status = follow_links
+            ? stat (cname, &buf) : gnulib::lstat (cname, &buf);
 
-      if (status < 0)
-        {
-          fail = true;
-          errmsg = gnulib::strerror (errno);
-        }
-      else
-        {
-          fs_mode = buf.st_mode;
-          fs_ino = buf.st_ino;
-          fs_dev = buf.st_dev;
-          fs_nlink = buf.st_nlink;
-          fs_uid = buf.st_uid;
-          fs_gid = buf.st_gid;
-          fs_size = buf.st_size;
-          fs_atime = buf.st_atime;
-          fs_mtime = buf.st_mtime;
-          fs_ctime = buf.st_ctime;
+          if (status < 0)
+            {
+              fail = true;
+              errmsg = gnulib::strerror (errno);
+            }
+          else
+            {
+              m_mode = buf.st_mode;
+              m_ino = buf.st_ino;
+              m_dev = buf.st_dev;
+              m_nlink = buf.st_nlink;
+              m_uid = buf.st_uid;
+              m_gid = buf.st_gid;
+              m_size = buf.st_size;
+              m_atime = buf.st_atime;
+              m_mtime = buf.st_mtime;
+              m_ctime = buf.st_ctime;
 
 #if defined (HAVE_STRUCT_STAT_ST_RDEV)
-          fs_rdev = buf.st_rdev;
+              m_rdev = buf.st_rdev;
 #endif
 
 #if defined (HAVE_STRUCT_STAT_ST_BLKSIZE)
-          fs_blksize = buf.st_blksize;
+              m_blksize = buf.st_blksize;
 #endif
 
 #if defined (HAVE_STRUCT_STAT_ST_BLOCKS)
-          fs_blocks = buf.st_blocks;
+              m_blocks = buf.st_blocks;
 #endif
-        }
+            }
 
-      initialized = true;
+          initialized = true;
+        }
     }
-}
 
-void
-file_fstat::update_internal (bool force)
-{
-  if (! initialized || force)
+    void
+    file_fstat::update_internal (bool force)
     {
-      initialized = false;
-      fail = false;
+      if (! initialized || force)
+        {
+          initialized = false;
+          fail = false;
 
-      struct stat buf;
+          struct stat buf;
 
-      int status = gnulib::fstat (fid, &buf);
+          int status = gnulib::fstat (fid, &buf);
 
-      if (status < 0)
-        {
-          fail = true;
-          errmsg = gnulib::strerror (errno);
-        }
-      else
-        {
-          fs_mode = buf.st_mode;
-          fs_ino = buf.st_ino;
-          fs_dev = buf.st_dev;
-          fs_nlink = buf.st_nlink;
-          fs_uid = buf.st_uid;
-          fs_gid = buf.st_gid;
-          fs_size = buf.st_size;
-          fs_atime = buf.st_atime;
-          fs_mtime = buf.st_mtime;
-          fs_ctime = buf.st_ctime;
+          if (status < 0)
+            {
+              fail = true;
+              errmsg = gnulib::strerror (errno);
+            }
+          else
+            {
+              m_mode = buf.st_mode;
+              m_ino = buf.st_ino;
+              m_dev = buf.st_dev;
+              m_nlink = buf.st_nlink;
+              m_uid = buf.st_uid;
+              m_gid = buf.st_gid;
+              m_size = buf.st_size;
+              m_atime = buf.st_atime;
+              m_mtime = buf.st_mtime;
+              m_ctime = buf.st_ctime;
 
 #if defined (HAVE_STRUCT_STAT_ST_RDEV)
-          fs_rdev = buf.st_rdev;
+              m_rdev = buf.st_rdev;
 #endif
 
 #if defined (HAVE_STRUCT_STAT_ST_BLKSIZE)
-          fs_blksize = buf.st_blksize;
+              m_blksize = buf.st_blksize;
 #endif
 
 #if defined (HAVE_STRUCT_STAT_ST_BLOCKS)
-          fs_blocks = buf.st_blocks;
+              m_blocks = buf.st_blocks;
 #endif
-        }
+            }
 
-      initialized = true;
+          initialized = true;
+        }
     }
+  }
 }
diff --git a/liboctave/system/file-stat.h b/liboctave/system/file-stat.h
--- a/liboctave/system/file-stat.h
+++ b/liboctave/system/file-stat.h
@@ -26,291 +26,310 @@ along with Octave; see the file COPYING.
 #include "octave-config.h"
 
 #include <string>
 
 #include "oct-time.h"
 
 #include <sys/types.h>
 
-class
-OCTAVE_API
-base_file_stat
+namespace octave
 {
-public:
+  namespace sys
+  {
+    class
+    OCTAVE_API
+    base_file_stat
+    {
+    public:
 
-  base_file_stat (void)
-    : initialized (false), fail (false), errmsg (), fs_mode (),
-      fs_ino (), fs_dev (), fs_nlink (), fs_uid (), fs_gid (),
-      fs_size (), fs_atime (), fs_mtime (), fs_ctime (), fs_rdev (),
-      fs_blksize (), fs_blocks () { }
+      base_file_stat (void)
+        : initialized (false), fail (false), errmsg (), m_mode (),
+          m_ino (), m_dev (), m_nlink (), m_uid (), m_gid (),
+          m_size (), m_atime (), m_mtime (), m_ctime (), m_rdev (),
+          m_blksize (), m_blocks () { }
 
-  base_file_stat (const base_file_stat& fs)
-    : initialized (fs.initialized), fail (fs.fail), errmsg (fs.errmsg),
-      fs_mode (fs.fs_mode), fs_ino (fs.fs_ino), fs_dev (fs.fs_dev),
-      fs_nlink (fs.fs_nlink), fs_uid (fs.fs_uid), fs_gid (fs.fs_gid),
-      fs_size (fs.fs_size), fs_atime (fs.fs_atime), fs_mtime (fs.fs_mtime),
-      fs_ctime (fs.fs_ctime), fs_rdev (fs.fs_rdev),
-      fs_blksize (fs.fs_blksize), fs_blocks (fs.fs_blocks) { }
+      base_file_stat (const base_file_stat& fs)
+        : initialized (fs.initialized), fail (fs.fail), errmsg (fs.errmsg),
+          m_mode (fs.m_mode), m_ino (fs.m_ino), m_dev (fs.m_dev),
+          m_nlink (fs.m_nlink), m_uid (fs.m_uid), m_gid (fs.m_gid),
+          m_size (fs.m_size), m_atime (fs.m_atime), m_mtime (fs.m_mtime),
+          m_ctime (fs.m_ctime), m_rdev (fs.m_rdev),
+          m_blksize (fs.m_blksize), m_blocks (fs.m_blocks) { }
 
-  base_file_stat& operator = (const base_file_stat& fs)
-  {
-    if (this != &fs)
+      base_file_stat& operator = (const base_file_stat& fs)
+        {
+          if (this != &fs)
+            {
+              initialized = fs.initialized;
+              fail = fs.fail;
+              errmsg = fs.errmsg;
+              m_mode = fs.m_mode;
+              m_ino = fs.m_ino;
+              m_dev = fs.m_dev;
+              m_nlink = fs.m_nlink;
+              m_uid = fs.m_uid;
+              m_gid = fs.m_gid;
+              m_size = fs.m_size;
+              m_atime = fs.m_atime;
+              m_mtime = fs.m_mtime;
+              m_ctime = fs.m_ctime;
+              m_rdev = fs.m_rdev;
+              m_blksize = fs.m_blksize;
+              m_blocks = fs.m_blocks;
+            }
+
+          return *this;
+        }
+
+      // The minimum difference in file time stamp values.
+      // FIXME: This value should come from the filesystem itself.
+      //        How can we get that info?
+      octave::sys::time time_resolution (void) const
       {
-        initialized = fs.initialized;
-        fail = fs.fail;
-        errmsg = fs.errmsg;
-        fs_mode = fs.fs_mode;
-        fs_ino = fs.fs_ino;
-        fs_dev = fs.fs_dev;
-        fs_nlink = fs.fs_nlink;
-        fs_uid = fs.fs_uid;
-        fs_gid = fs.fs_gid;
-        fs_size = fs.fs_size;
-        fs_atime = fs.fs_atime;
-        fs_mtime = fs.fs_mtime;
-        fs_ctime = fs.fs_ctime;
-        fs_rdev = fs.fs_rdev;
-        fs_blksize = fs.fs_blksize;
-        fs_blocks = fs.fs_blocks;
+        static octave::sys::time resolution (1.0);
+        return resolution;
       }
 
-    return *this;
-  }
+      // File status and info.  The is_XXX functions will return false for
+      // file_stat objects that are not properly initialized.  The others
+      // should all return 0 (or the equivalent, for the given object)
+      // which is likely not meaningful.
 
-  // The minimum difference in file time stamp values.
-  // FIXME: This value should come from the filesystem itself.
-  //        How can we get that info?
-  octave::sys::time time_resolution (void) const
-  {
-    static octave::sys::time resolution (1.0);
-    return resolution;
-  }
-
-  // File status and info.  The is_XXX functions will return false for
-  // file_stat objects that are not properly initialized.  The others
-  // should all return 0 (or the equivalent, for the given object)
-  // which is likely not meaningful.
+      bool is_blk (void) const;
+      bool is_chr (void) const;
+      bool is_dir (void) const;
+      bool is_fifo (void) const;
+      bool is_lnk (void) const;
+      bool is_reg (void) const;
+      bool is_sock (void) const;
 
-  bool is_blk (void) const;
-  bool is_chr (void) const;
-  bool is_dir (void) const;
-  bool is_fifo (void) const;
-  bool is_lnk (void) const;
-  bool is_reg (void) const;
-  bool is_sock (void) const;
+      static bool is_blk (mode_t mode);
+      static bool is_chr (mode_t mode);
+      static bool is_dir (mode_t mode);
+      static bool is_fifo (mode_t mode);
+      static bool is_lnk (mode_t mode);
+      static bool is_reg (mode_t mode);
+      static bool is_sock (mode_t mode);
 
-  static bool is_blk (mode_t mode);
-  static bool is_chr (mode_t mode);
-  static bool is_dir (mode_t mode);
-  static bool is_fifo (mode_t mode);
-  static bool is_lnk (mode_t mode);
-  static bool is_reg (mode_t mode);
-  static bool is_sock (mode_t mode);
+      ino_t ino (void) const { return m_ino; }
+      dev_t dev (void) const { return m_dev; }
 
-  ino_t ino (void) const { return fs_ino; }
-  dev_t dev (void) const { return fs_dev; }
+      nlink_t nlink (void) const { return m_nlink; }
+
+      uid_t uid (void) const { return m_uid; }
+      gid_t gid (void) const { return m_gid; }
 
-  nlink_t nlink (void) const { return fs_nlink; }
+      off_t size (void) const { return m_size; }
 
-  uid_t uid (void) const { return fs_uid; }
-  gid_t gid (void) const { return fs_gid; }
-
-  off_t size (void) const { return fs_size; }
+      octave::sys::time atime (void) const { return m_atime; }
+      octave::sys::time mtime (void) const { return m_mtime; }
+      octave::sys::time ctime (void) const { return m_ctime; }
 
-  octave::sys::time atime (void) const { return fs_atime; }
-  octave::sys::time mtime (void) const { return fs_mtime; }
-  octave::sys::time ctime (void) const { return fs_ctime; }
+      dev_t rdev (void) const { return m_rdev; }
 
-  dev_t rdev (void) const { return fs_rdev; }
+      long blksize (void) const { return m_blksize; }
+      long blocks (void) const { return m_blocks; }
 
-  long blksize (void) const { return fs_blksize; }
-  long blocks (void) const { return fs_blocks; }
+      mode_t mode (void) const { return m_mode; }
 
-  mode_t mode (void) const { return fs_mode; }
+      std::string mode_as_string (void) const;
 
-  std::string mode_as_string (void) const;
+      bool ok (void) const { return initialized && ! fail; }
 
-  bool ok (void) const { return initialized && ! fail; }
+      operator bool () const { return ok (); }
 
-  operator bool () const { return ok (); }
+      bool exists (void) const { return ok (); }
 
-  bool exists (void) const { return ok (); }
-
-  std::string error (void) const { return ok () ? "" : errmsg; }
+      std::string error (void) const { return ok () ? "" : errmsg; }
 
-  // Has the file referenced by this object been modified since TIME?
-  bool is_newer (const octave::sys::time& time) const { return fs_mtime > time; }
+      // Has the file referenced by this object been modified since TIME?
+      bool is_newer (const octave::sys::time& time) const { return m_mtime > time; }
 
-  // It's nice to be able to hide the file_stat object if we don't
-  // really care about it.
-  static int is_newer (const std::string&, const octave::sys::time&);
+      // It's nice to be able to hide the file_stat object if we don't
+      // really care about it.
+      static int is_newer (const std::string&, const octave::sys::time&);
 
-protected:
-
-  virtual ~base_file_stat (void) { }
+    protected:
 
-  // TRUE means we have already called stat.
-  bool initialized;
+      virtual ~base_file_stat (void) { }
 
-  // TRUE means the stat for this file failed.
-  bool fail;
-
-  // If a failure occurs, this contains the system error text.
-  std::string errmsg;
+      // TRUE means we have already called stat.
+      bool initialized;
 
-  // file type and permissions
-  mode_t fs_mode;
+      // TRUE means the stat for this file failed.
+      bool fail;
 
-  // serial number
-  ino_t fs_ino;
+      // If a failure occurs, this contains the system error text.
+      std::string errmsg;
 
-  // device number
-  dev_t fs_dev;
+      // file type and permissions
+      mode_t m_mode;
 
-  // number of links
-  nlink_t fs_nlink;
+      // serial number
+      ino_t m_ino;
 
-  // user ID of owner
-  uid_t fs_uid;
-
-  // group ID of owner
-  gid_t fs_gid;
+      // device number
+      dev_t m_dev;
 
-  // size in bytes, for regular files
-  off_t fs_size;
+      // number of links
+      nlink_t m_nlink;
 
-  // time of last access
-  octave::sys::time fs_atime;
+      // user ID of owner
+      uid_t m_uid;
 
-  // time of last modification
-  octave::sys::time fs_mtime;
+      // group ID of owner
+      gid_t m_gid;
 
-  // time of last file status change
-  octave::sys::time fs_ctime;
+      // size in bytes, for regular files
+      off_t m_size;
 
-  // device number for special files
-  dev_t fs_rdev;
-
-  // best I/O block size
-  long fs_blksize;
+      // time of last access
+      octave::sys::time m_atime;
 
-  // number of 512-byte blocks allocated
-  long fs_blocks;
-};
+      // time of last modification
+      octave::sys::time m_mtime;
 
-class
-OCTAVE_API
-file_stat : public base_file_stat
-{
-public:
+      // time of last file status change
+      octave::sys::time m_ctime;
+
+      // device number for special files
+      dev_t m_rdev;
 
-  file_stat (const std::string& n = "", bool fl = true)
-    : base_file_stat (), file_name (n), follow_links (fl)
-  {
-    if (! file_name.empty ())
-      update_internal ();
-  }
+      // best I/O block size
+      long m_blksize;
+
+      // number of 512-byte blocks allocated
+      long m_blocks;
+    };
 
-  file_stat (const file_stat& fs)
-    : base_file_stat (fs), file_name (fs.file_name),
-      follow_links (fs.follow_links) { }
+    class
+    OCTAVE_API
+    file_stat : public base_file_stat
+    {
+    public:
 
-  file_stat& operator = (const file_stat& fs)
-  {
-    if (this != &fs)
+      file_stat (const std::string& n = "", bool fl = true)
+        : base_file_stat (), file_name (n), follow_links (fl)
       {
-        base_file_stat::operator = (fs);
-
-        file_name = fs.file_name;
-        follow_links = fs.follow_links;
+        if (! file_name.empty ())
+          update_internal ();
       }
 
-    return *this;
-  }
-
-  ~file_stat (void) { }
+      file_stat (const file_stat& fs)
+        : base_file_stat (fs), file_name (fs.file_name),
+        follow_links (fs.follow_links) { }
 
-  void get_stats (bool force = false)
-  {
-    if (! initialized || force)
-      update_internal (force);
-  }
+      file_stat& operator = (const file_stat& fs)
+        {
+          if (this != &fs)
+            {
+              base_file_stat::operator = (fs);
 
-  void get_stats (const std::string& n, bool force = false)
-  {
-    if (n != file_name || ! initialized || force)
-      {
-        initialized = false;
+              file_name = fs.file_name;
+              follow_links = fs.follow_links;
+            }
 
-        file_name = n;
+          return *this;
+        }
 
-        update_internal (force);
-      }
-  }
+      ~file_stat (void) { }
 
-private:
-
-  // Name of the file.
-  std::string file_name;
+      void get_stats (bool force = false)
+      {
+        if (! initialized || force)
+          update_internal (force);
+      }
 
-  // TRUE means follow symbolic links to the ultimate file (stat).
-  // FALSE means get information about the link itself (lstat).
-  bool follow_links;
+      void get_stats (const std::string& n, bool force = false)
+      {
+        if (n != file_name || ! initialized || force)
+          {
+            initialized = false;
+
+            file_name = n;
 
-  void update_internal (bool force = false);
-};
+            update_internal (force);
+          }
+      }
 
-class
-OCTAVE_API
-file_fstat : public base_file_stat
-{
-public:
+    private:
+
+      // Name of the file.
+      std::string file_name;
 
-  file_fstat (int n) : base_file_stat (), fid (n)
-  {
-    update_internal ();
-  }
+      // TRUE means follow symbolic links to the ultimate file (stat).
+      // FALSE means get information about the link itself (lstat).
+      bool follow_links;
 
-  file_fstat (const file_fstat& fs)
-    : base_file_stat (fs), fid (fs.fid) { }
+      void update_internal (bool force = false);
+    };
 
-  file_fstat& operator = (const file_fstat& fs)
-  {
-    if (this != &fs)
+    class
+    OCTAVE_API
+    file_fstat : public base_file_stat
+    {
+    public:
+
+      file_fstat (int n) : base_file_stat (), fid (n)
       {
-        base_file_stat::operator = (fs);
-
-        fid = fs.fid;
+        update_internal ();
       }
 
-    return *this;
-  }
+      file_fstat (const file_fstat& fs)
+        : base_file_stat (fs), fid (fs.fid) { }
 
-  ~file_fstat (void) { }
+      file_fstat& operator = (const file_fstat& fs)
+        {
+          if (this != &fs)
+            {
+              base_file_stat::operator = (fs);
+
+              fid = fs.fid;
+            }
 
-  void get_stats (bool force = false)
-  {
-    if (! initialized || force)
-      update_internal (force);
-  }
+          return *this;
+        }
+
+      ~file_fstat (void) { }
 
-  void get_stats (int n, bool force = false)
-  {
-    if (n != fid || ! initialized || force)
+      void get_stats (bool force = false)
+      {
+        if (! initialized || force)
+          update_internal (force);
+      }
+
+      void get_stats (int n, bool force = false)
       {
-        initialized = false;
+        if (n != fid || ! initialized || force)
+          {
+            initialized = false;
 
-        fid = n;
+            fid = n;
 
-        update_internal (force);
+            update_internal (force);
+          }
       }
-  }
+
+    private:
+
+      // Open file descriptor.
+      int fid;
 
-private:
+      void update_internal (bool force = false);
+    };
+  }
+}
+
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
-  // Open file descriptor.
-  int fid;
+OCTAVE_DEPRECATED ("use octave::sys::base_file_stat instead")
+typedef octave::sys::base_file_stat base_file_stat;
 
-  void update_internal (bool force = false);
-};
+OCTAVE_DEPRECATED ("use octave::sys::file_stat instead")
+typedef octave::sys::file_stat file_stat;
+
+OCTAVE_DEPRECATED ("use octave::sys::file_fstat instead")
+typedef octave::sys::file_fstat file_fstat;
 
 #endif
+
+#endif
diff --git a/liboctave/util/cmd-hist.cc b/liboctave/util/cmd-hist.cc
--- a/liboctave/util/cmd-hist.cc
+++ b/liboctave/util/cmd-hist.cc
@@ -389,17 +389,17 @@ gnu_history::do_append (const std::strin
 
               std::string f = f_arg;
 
               if (f.empty ())
                 f = xfile;
 
               if (! f.empty ())
                 {
-                  file_stat fs (f);
+                  octave::sys::file_stat fs (f);
 
                   if (! fs)
                     {
                       int tem;
 
                       tem = gnulib::open (f.c_str (), O_CREAT, 0666);
                       gnulib::close (tem);
                     }
diff --git a/liboctave/util/oct-glob.cc b/liboctave/util/oct-glob.cc
--- a/liboctave/util/oct-glob.cc
+++ b/liboctave/util/oct-glob.cc
@@ -37,17 +37,17 @@ along with Octave; see the file COPYING.
 // can include the glob.h file from gnulib, which defines glob to
 // be rpl_glob.  If we include glob.h in glob_match.cc, then it
 // transforms the glob_match::glob function to be glob_match::rpl_glob,
 // which is not what we want...
 
 static bool
 single_match_exists (const std::string& file)
 {
-  file_stat s (file);
+  octave::sys::file_stat s (file);
 
   return s.exists ();
 }
 
 namespace octave
 {
   namespace sys
   {
diff --git a/liboctave/util/oct-shlib.cc b/liboctave/util/oct-shlib.cc
--- a/liboctave/util/oct-shlib.cc
+++ b/liboctave/util/oct-shlib.cc
@@ -69,25 +69,25 @@ octave_shlib::shlib_rep::shlib_rep (cons
     (*current_liboctave_warning_with_id_handler)
       ("Octave:warn-future-time-stamp",
        "timestamp on file %s is in the future", file.c_str ());
 }
 
 bool
 octave_shlib::shlib_rep::is_out_of_date (void) const
 {
-  file_stat fs (file);
+  octave::sys::file_stat fs (file);
   return (fs && fs.is_newer (tm_loaded));
 }
 
 void
 octave_shlib::shlib_rep::fake_reload (void)
 {
   // We can't actually reload the library, but we'll pretend we did.
-  file_stat fs (file);
+  octave::sys::file_stat fs (file);
   if (fs && fs.is_newer (tm_loaded))
     {
       tm_loaded = fs.mtime ();
 
       (*current_liboctave_warning_with_id_handler)
         ("Octave:library-reload",
          "library %s not reloaded due to existing references", file.c_str ());
     }
diff --git a/liboctave/util/url-transfer.cc b/liboctave/util/url-transfer.cc
--- a/liboctave/util/url-transfer.cc
+++ b/liboctave/util/url-transfer.cc
@@ -51,17 +51,17 @@ base_url_transfer::delete_file (const st
   octave::sys::unlink (file);
 }
 
 void
 base_url_transfer::mget_directory (const std::string& directory,
                                    const std::string& target)
 {
   std::string sep = octave::sys::file_ops::dir_sep_str ();
-  file_stat fs (directory);
+  octave::sys::file_stat fs (directory);
 
   if (! fs || ! fs.is_dir ())
     {
       std::string msg;
       int status = octave::sys::mkdir (directory, 0777, msg);
 
       if (status < 0)
         {
@@ -156,17 +156,17 @@ base_url_transfer::mput_directory (const
           for (octave_idx_type i = 0; i < files.numel (); i++)
             {
               std::string file = files (i);
 
               if (file == "." || file == "..")
                 continue;
 
               std::string realfile = realdir + octave::sys::file_ops::dir_sep_str () + file;
-              file_stat fs (realfile);
+              octave::sys::file_stat fs (realfile);
 
               if (! fs.exists ())
                 {
                   ok = false;
                   errmsg = "__ftp__mput: file '" + realfile
                            + "' does not exist";
                   break;
                 }
