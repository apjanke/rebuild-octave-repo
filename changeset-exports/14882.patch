# HG changeset patch
# User Jordi Guti√©rrez Hermoso <jordigh@octave.org>
# Date 1342713180 14400
#      Thu Jul 19 11:53:00 2012 -0400
# Branch gui
# Node ID a31a090c16282258140ee9d7983671b7b2538553
# Parent  4daed35ff7764d29e8338907089a0698f65ad5b8
# Parent  02952657182eb7bbd1092d1237a0a5f66b24fafe
maint: periodic merge of default to gui

diff --git a/scripts/audio/lin2mu.m b/scripts/audio/lin2mu.m
--- a/scripts/audio/lin2mu.m
+++ b/scripts/audio/lin2mu.m
@@ -57,17 +57,17 @@ function y = lin2mu (x, n)
   if (n == 0)
     ## [-1,1] -> [-32768, 32768]
     x = 32768 * x;
   elseif (n != 16)
     x = 2^(16-n) .* x;
   endif
 
   ## Determine sign of x, set sign(0) = 1.
-  sig = sign(x) + (x == 0);
+  sig = sign (x) + (x == 0);
 
   ## Take absolute value of x, but force it to be smaller than 32636;
   ## add bias.
   x = min (abs (x), 32635) + 132;
 
   ## Find exponent and fraction of bineary representation.
   [f, e] = log2 (x);
 
diff --git a/scripts/audio/loadaudio.m b/scripts/audio/loadaudio.m
--- a/scripts/audio/loadaudio.m
+++ b/scripts/audio/loadaudio.m
@@ -58,17 +58,17 @@ function X = loadaudio (name, ext, bps)
   if (strcmp (ext, "lin") || strcmp (ext, "raw") || strcmp (ext, "pcm"))
     if (bps == 8)
       [Y, c] = fread (num, inf, "uchar");
       X = Y - 127;
     else
       [X, c] = fread (num, inf, "short");
     endif
   elseif (strcmp (ext, "mu") || strcmp (ext, "au")
-          || strcmp (ext, "snd") || strcmp(ext, "ul"))
+          || strcmp (ext, "snd") || strcmp (ext, "ul"))
     [Y, c] = fread (num, inf, "uchar");
     ## remove file header
     m = find (Y(1:64) == 0, 1, "last");
     if (! isempty (m))
       Y(1:m) = [];
     endif
     X = mu2lin (Y, bps);
   else
diff --git a/scripts/audio/wavread.m b/scripts/audio/wavread.m
--- a/scripts/audio/wavread.m
+++ b/scripts/audio/wavread.m
@@ -82,17 +82,17 @@ function [y, samples_per_sec, bits_per_s
       error ("wavread: file contains no WAVE signature");
     endif
     riff_pos = riff_pos + 4;
     riff_size = riff_size - 4;
 
     ## Find format chunk inside the RIFF chunk.
     fseek (fid, riff_pos, "bof");
     fmt_size = find_chunk (fid, "fmt ", riff_size);
-    fmt_pos = ftell(fid);
+    fmt_pos = ftell (fid);
     if (fmt_size == -1)
       error ("wavread: file contains no format chunk");
     endif
 
     ## Find data chunk inside the RIFF chunk.
     ## We don't assume that it comes after the format chunk.
     fseek (fid, riff_pos, "bof");
     data_size = find_chunk (fid, "data", riff_size);
@@ -191,17 +191,17 @@ function [y, samples_per_sec, bits_per_s
 
   ## Check data.
   if (mod (numel (yi), channels) != 0)
     error ("wavread: data in %s doesn't match the number of channels",
            filename);
   endif
 
   if (bits_per_sample == 24)
-    yi = reshape (yi, 3, rows(yi)/3)';
+    yi = reshape (yi, 3, rows (yi) / 3)';
     yi(yi(:,3) >= 128, 3) -= 256;
     yi = yi * [1; 256; 65536];
   endif
 
   if (format_tag == FORMAT_PCM)
     ## Normalize samples.
     switch (bits_per_sample)
       case 8
@@ -241,10 +241,10 @@ function chunk_size = find_chunk (fid, c
   endwhile
   if (! strcmp (id, chunk_id))
     chunk_size = -1;
   endif
 endfunction
 
 
 ## Mark file as tested.  Tests for wavread/wavwrite pair are in wavwrite.m.
-%!assert(1)
+%!assert (1)
 
diff --git a/scripts/general/accumarray.m b/scripts/general/accumarray.m
--- a/scripts/general/accumarray.m
+++ b/scripts/general/accumarray.m
@@ -365,17 +365,17 @@ function A = accumarray (subs, vals, sz 
       ## Set the reduced values.
       A(subs) = vals;
     endif
   endif
 endfunction
 
 
 %!assert (accumarray ([1;2;4;2;4],101:105), [101;206;0;208])
-%!assert (accumarray ([1,1,1;2,1,2;2,3,2;2,1,2;2,3,2],101:105), cat(3, [101,0,0;0,0,0],[0,0,0;206,0,208]))
+%!assert (accumarray ([1,1,1;2,1,2;2,3,2;2,1,2;2,3,2],101:105), cat (3, [101,0,0;0,0,0],[0,0,0;206,0,208]))
 %!assert (accumarray ([1,1,1;2,1,2;2,3,2;2,1,2;2,3,2],101:105,[],@(x)sin(sum(x))), sin (cat (3, [101,0,0;0,0,0],[0,0,0;206,0,208])))
 %!assert (accumarray ({[1 3 3 2 3 1 2 2 3 3 1 2],[3 4 2 1 4 3 4 2 2 4 3 4],[1 1 2 2 1 1 2 1 1 1 2 2]},101:112), cat (3, [0,0,207,0;0,108,0,0;0,109,0,317], [0,0,111,0;104,0,0,219;0,103,0,0]))
 %!assert (accumarray ([1,1;2,1;2,3;2,1;2,3],101:105,[2,4],@max,NaN), [101,NaN,NaN,NaN;104,NaN,105,NaN])
 %!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],101:105, [], @prod), [101, 0, 0; 10608, 0, 10815])
 %!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],101:105,[2 4],@prod,0,true), sparse ([1,2,2],[1,1,3],[101,10608,10815],2,4))
 %!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],1,[2,4]), [1,0,0,0;2,0,2,0])
 %!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],101:105,[2,4],@(x)length(x)>1), [false,false,false,false;true,false,true,false])
 %!assert (accumarray ([1; 2], [3; 4], [2, 1], @min, [], 0), [3; 4])
diff --git a/scripts/general/bicubic.m b/scripts/general/bicubic.m
--- a/scripts/general/bicubic.m
+++ b/scripts/general/bicubic.m
@@ -33,17 +33,17 @@
 ## Author: Hoxide Ma <hoxide_dirac@yahoo.com.cn>
 
 function zi = bicubic (x, y, z, xi, yi, extrapval, spline_alpha)
 
   if (nargin < 1 || nargin > 7)
     print_usage ();
   endif
 
-  if (nargin == 7 && isscalar(spline_alpha))
+  if (nargin == 7 && isscalar (spline_alpha))
     a = spline_alpha;
   else
     a = 0.5;
   endif
 
   if (nargin < 6)
     extrapval = NaN;
   endif
@@ -235,13 +235,13 @@ endfunction
 
 %!test
 %! x = linspace (1, -1, 10);
 %! [xx, yy] = meshgrid (x);
 %! z = cos (6 * xx) + sin (6 * yy);
 %! x = linspace (1, -1, 30);
 %! [xx2, yy2] = meshgrid (x);
 %! z1 = interp2 (xx, yy, z, xx2, yy2, "cubic");
-%! z2 = interp2 (fliplr(xx), flipud(yy), fliplr(flipud(z)),
-%!               fliplr(xx2), flipud(yy2), "cubic");
+%! z2 = interp2 (fliplr (xx), flipud (yy), fliplr (flipud(z)),
+%!               fliplr (xx2), flipud (yy2), "cubic");
 %! z2 = fliplr (flipud (z2));
 %! assert (z1, z2, 100 * eps ())
 
diff --git a/scripts/general/celldisp.m b/scripts/general/celldisp.m
--- a/scripts/general/celldisp.m
+++ b/scripts/general/celldisp.m
@@ -66,20 +66,20 @@ function celldisp (c, name)
     endif
   endfor
 endfunction
 
 function s = indices (dv, i)
   if (sum (dv != 1) > 1)
     c = cell (size (dv));
     [c{:}] = ind2sub (dv, i);
-    s = sprintf("%i,", c{:});
+    s = sprintf ("%i,", c{:});
     s(end) = [];
   else
-    s = sprintf("%i", i);
+    s = sprintf ("%i", i);
   endif
 endfunction
 
 
 %!demo
 %! c = {1, 2, {31, 32}};
 %! celldisp (c, "b")
 
diff --git a/scripts/general/colon.m b/scripts/general/colon.m
--- a/scripts/general/colon.m
+++ b/scripts/general/colon.m
@@ -30,16 +30,16 @@
 ## @end group
 ## @end example
 ##
 ## @seealso{class, subsref, subsasgn}
 ## @end deftypefn
 
 function r = colon (varargin)
   if (nargin != 0)
-    error ("colon: not defined for class \"%s\"", class(varargin{1}));
+    error ('colon: not defined for class "%s"', class (varargin{1}));
   endif
 endfunction
 
 
 %!error colon (1)
 
 ## FIXME -- what does colon () mean since it doesn't set a return value?
diff --git a/scripts/general/cplxpair.m b/scripts/general/cplxpair.m
--- a/scripts/general/cplxpair.m
+++ b/scripts/general/cplxpair.m
@@ -39,19 +39,19 @@
 ## @c Set example in small font to prevent overfull line
 ##
 ## @smallexample
 ## cplxpair (exp(2i*pi*[0:4]'/5)) == exp(2i*pi*[3; 2; 4; 1; 0]/5)
 ## @end smallexample
 ## @end deftypefn
 
 ## FIXME: subsort returned pairs by imaginary magnitude
-## FIXME: Why doesn't exp(2i*pi*[0:4]'/5) produce exact conjugates. Does
-## FIXME:    it in Matlab?  The reason is that complex pairs are supposed
-## FIXME:    to be exact conjugates, and not rely on a tolerance test.
+## FIXME: Why doesn't exp (2i*pi*[0:4]'/5) produce exact conjugates.  Does
+## FIXME: it in Matlab?  The reason is that complex pairs are supposed
+## FIXME: to be exact conjugates, and not rely on a tolerance test.
 
 ## 2006-05-12 David Bateman - Modified for NDArrays
 
 function y = cplxpair (z, tol, dim)
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
   endif
@@ -77,17 +77,17 @@ function y = cplxpair (z, tol, dim)
     while (dim < nd && orig_dims(dim+1) == 1)
       dim++;
     endwhile
     dim++;
     if (dim > nd)
       dim = 1;
     endif
   else
-    dim = floor(dim);
+    dim = floor (dim);
     if (dim < 1 || dim > nd)
       error ("cplxpair: invalid dimension along which to sort");
     endif
   endif
 
   ## Move dimension to treat first, and convert to a 2-D matrix.
   perm = [dim:nd, 1:dim-1];
   z = permute (z, perm);
@@ -100,17 +100,17 @@ function y = cplxpair (z, tol, dim)
   [q, idx] = sort (real (z), 1);
   z = z(idx + n * ones (n, 1) * [0:m-1]);
 
   ## Put the purely real values at the end of the returned list.
   cls = "double";
   if (isa (z, "single"))
     cls = "single";
   endif
-  [idxi, idxj] = find (abs (imag (z)) ./ (abs (z) + realmin(cls)) < tol);
+  [idxi, idxj] = find (abs (imag (z)) ./ (abs (z) + realmin (cls)) < tol);
   q = sparse (idxi, idxj, 1, n, m);
   nr = sum (q, 1);
   [q, idx] = sort (q, 1);
   z = z(idx);
   y = z;
 
   ## For each remaining z, place the value and its conjugate at the
   ## start of the returned list, and remove them from further
diff --git a/scripts/general/dblquad.m b/scripts/general/dblquad.m
--- a/scripts/general/dblquad.m
+++ b/scripts/general/dblquad.m
@@ -62,17 +62,17 @@ function q = dblquad (f, xa, xb, ya, yb,
     varargin = {};
   endif
 
   q = feval (quadf, @(y) inner (y, f, xa, xb, tol, quadf,
                                 varargin{:}), ya, yb, tol);
 endfunction
 
 function q = __dblquad_inner__ (y, f, xa, xb, tol, quadf, varargin)
-  q = zeros (size(y));
+  q = zeros (size (y));
   for i = 1 : length (y)
     q(i) = feval (quadf, @(x) f(x, y(i), varargin{:}), xa, xb, tol);
   endfor
 endfunction
 
 
 %% Nasty integrand to show quadcc off
 %!assert (dblquad (@(x,y) 1 ./ (x+y), 0, 1, 0, 1), 2*log (2), 1e-6)
diff --git a/scripts/general/divergence.m b/scripts/general/divergence.m
--- a/scripts/general/divergence.m
+++ b/scripts/general/divergence.m
@@ -76,18 +76,18 @@ function retval = divergence (varargin)
     if (!size_equal (varargin{fidx},varargin{fidx + 1}))
       error ("divergence: size of X and Y must match");
     elseif (ndims (varargin{fidx}) != 2)
       error ("divergence: expected two-dimensional matrices X and Y");
     elseif ((length (dx) != columns (varargin{fidx})) || (length (dy) != rows (varargin{fidx})))
       error ("divergence: size of dx and dy must match the respective dimension of X and Y");
     endif
 
-    retval = gradient(varargin{fidx}, dx, dy);
-    retval += gradient(varargin{fidx + 1}.', dy, dx).';
+    retval = gradient (varargin{fidx}, dx, dy);
+    retval += gradient (varargin{fidx + 1}.', dy, dx).';
 
   elseif ((nargin == 6) || (nargin == 3))
     if (!size_equal (varargin{fidx},varargin{fidx + 1},varargin{fidx + 2}))
       error ("divergence: size of X, Y, and Z must match");
     elseif (ndims (varargin{fidx}) != 3)
       error ("divergence: expected two-dimensional matrices X, Y, and Z");
     elseif ((length (dx) != size (varargin{fidx}, 2))
          || (length (dy) != size (varargin{fidx}, 1))
diff --git a/scripts/general/genvarname.m b/scripts/general/genvarname.m
--- a/scripts/general/genvarname.m
+++ b/scripts/general/genvarname.m
@@ -155,17 +155,17 @@ function varname = genvarname (str, excl
       ## if it is not unique and ends with a digit, add an underscore to
       ## make the variable name more readable ("x1_1" instead of "x11")
       str{i}(end+1) = "_";
     endif
     varname(i) = str(i);
     idx = 0;
     while (excluded)
       idx++;
-      varname{i} = sprintf("%s%d", str{i}, idx);
+      varname{i} = sprintf ("%s%d", str{i}, idx);
       excluded = any (strcmp (varname{i}, exclusions));
     endwhile
     exclusions(end+1) = varname(i);
   endfor
 
   if (strinput)
     varname = varname{1};
   endif
diff --git a/scripts/general/gradient.m b/scripts/general/gradient.m
--- a/scripts/general/gradient.m
+++ b/scripts/general/gradient.m
@@ -65,40 +65,40 @@
 ## Modified: David Bateman <dbateman@free.fr> Added NDArray support
 
 function varargout = gradient (m, varargin)
 
   if (nargin < 1)
     print_usage ();
   endif
 
-  nargout_with_ans = max(1,nargout);
+  nargout_with_ans = max (1,nargout);
   if (ismatrix (m))
     [varargout{1:nargout_with_ans}] = matrix_gradient (m, varargin{:});
   elseif (isa (m, "function_handle"))
     [varargout{1:nargout_with_ans}] = handle_gradient (m, varargin{:});
-  elseif (ischar(m))
+  elseif (ischar (m))
     [varargout{1:nargout_with_ans}] = handle_gradient (str2func (m), varargin{:});
   else
     error ("gradient: first input must be an array or a function");
   endif
 
 endfunction
 
 function varargout = matrix_gradient (m, varargin)
   transposed = false;
   if (isvector (m))
     ## make a row vector.
-    transposed = (size (m, 2) == 1);
+    transposed = (columns (m) == 1);
     m = m(:).';
   endif
 
   nd = ndims (m);
   sz = size (m);
-  if (length(sz) > 1)
+  if (length (sz) > 1)
     tmp = sz(1); sz(1) = sz(2); sz(2) = tmp;
   endif
 
   if (nargin > 2 && nargin != nd + 1)
     print_usage ();
   endif
 
   ## cell d stores a spacing vector for each dimension
@@ -276,17 +276,17 @@ endfunction
 %! assert (all (dY(:) == 0));
 %! assert (all (dZ(:) == 4));
 %! assert (all (dU(:) == 0));
 %! [dX,dY,dZ,dU] = gradient (U-j*1);
 %! assert (all (dX(:) == 0));
 %! assert (all (dY(:) == 0));
 %! assert (all (dZ(:) == 0));
 %! assert (all (dU(:) == 5));
-%! assert (size_equal(dX, dY, dZ, dU, X, Y, Z, U));
+%! assert (size_equal (dX, dY, dZ, dU, X, Y, Z, U));
 %! [dX,dY,dZ,dU] = gradient (U, 5.0);
 %! assert (all (dU(:) == 1));
 %! [dX,dY,dZ,dU] = gradient (U, 1.0, 2.0, 3.0, 2.5);
 %! assert (all (dU(:) == 2));
 
 %!test
 %! x = 0:10;
 %! f = @cos;
diff --git a/scripts/general/int2str.m b/scripts/general/int2str.m
--- a/scripts/general/int2str.m
+++ b/scripts/general/int2str.m
@@ -52,18 +52,18 @@ function retval = int2str (n)
     print_usage ();
   endif
 
   if (isempty (n))
     retval = '';
     return;
   endif
 
-  n = round (real(n));
-  sz = size(n);
+  n = round (real (n));
+  sz = size (n);
   nd = ndims (n);
   nc = columns (n);
   if (nc > 1)
     idx = repmat ({':'}, nd, 1);
     idx(2) = 1;
     ifmt = get_fmt (n(idx{:}), 0);
     idx(2) = 2:sz(2);
     rfmt = get_fmt (n(idx{:}), 2);
diff --git a/scripts/general/interp1.m b/scripts/general/interp1.m
--- a/scripts/general/interp1.m
+++ b/scripts/general/interp1.m
@@ -136,17 +136,17 @@ function yi = interp1 (x, y, varargin)
         endif
       endif
     endfor
   endif
 
   if (isempty (xi) && firstnumeric && ! ispp)
     xi = y;
     y = x;
-    x = 1:numel(y);
+    x = 1:numel (y);
   endif
 
   ## reshape matrices for convenience
   x = x(:);
   nx = rows (x);
   szx = size (xi);
   if (isvector (y))
     y = y(:);
@@ -199,17 +199,17 @@ function yi = interp1 (x, y, varargin)
       yi = ppval (pp, reshape (xi, szx));
     endif
   case "*nearest"
     pp = mkpp ([x(1), x(1)+[0.5:(nx-1)]*dx, x(nx)], shiftdim (y, 1), szy(2:end));
     pp.orient = "first";
     if (ispp)
       yi = pp;
     else
-      yi = ppval(pp, reshape (xi, szx));
+      yi = ppval (pp, reshape (xi, szx));
     endif
   case "linear"
     dy = diff (y);
     dx = diff (x);
     dx = repmat (dx, [1 size(dy)(2:end)]);
     coefs = [(dy./dx).'(:), y(1:nx-1, :).'(:)];
     xx = x;
 
@@ -220,29 +220,29 @@ function yi = interp1 (x, y, varargin)
     endif
 
     pp = mkpp (xx, coefs, szy(2:end));
     pp.orient = "first";
 
     if (ispp)
       yi = pp;
     else
-      yi = ppval(pp, reshape (xi, szx));
+      yi = ppval (pp, reshape (xi, szx));
     endif
 
   case "*linear"
     dy = diff (y);
     coefs = [(dy/dx).'(:), y(1:nx-1, :).'(:)];
     pp = mkpp (x, coefs, szy(2:end));
     pp.orient = "first";
 
     if (ispp)
       yi = pp;
     else
-      yi = ppval(pp, reshape (xi, szx));
+      yi = ppval (pp, reshape (xi, szx));
     endif
 
   case {"pchip", "*pchip", "cubic", "*cubic"}
     if (nx == 2 || starmethod)
       x = linspace (x(1), x(nx), ny);
     endif
 
     if (ispp)
@@ -253,17 +253,17 @@ function yi = interp1 (x, y, varargin)
       y = shiftdim (y, 1);
       yi = pchip (x, y, reshape (xi, szx));
       if (! isvector (y))
         yi = shiftdim (yi, 1);
       endif
     endif
   case {"spline", "*spline"}
     if (nx == 2 || starmethod)
-      x = linspace(x(1), x(nx), ny);
+      x = linspace (x(1), x(nx), ny);
     endif
 
     if (ispp)
       y = shiftdim (reshape (y, szy), 1);
       yi = spline (x, y);
       yi.orient = "first";
     else
       y = shiftdim (y, 1);
diff --git a/scripts/general/interp1q.m b/scripts/general/interp1q.m
--- a/scripts/general/interp1q.m
+++ b/scripts/general/interp1q.m
@@ -32,17 +32,17 @@
 ## execution time of this @code{interp1} if the size of the input arguments
 ## is relatively small.  Therefore, the benefit of using @code{interp1q}
 ## is relatively small.
 ## @seealso{interp1}
 ## @end deftypefn
 
 function yi = interp1q (x, y, xi)
   x = x(:);
-  nx = size (x, 1);
+  nx = rows (x);
   szy = size (y);
   y = y(:,:);
   [ny, nc] = size (y);
   szx = size (xi);
   xi = xi (:);
   dy = diff (y);
   dx = diff (x);
   idx = lookup (x, xi, "lr");
@@ -54,17 +54,17 @@ function yi = interp1q (x, y, xi)
     yi = reshape (yi, [max(szx), szy(2:end)]);
   else
     yi = reshape (yi, [szx, szy(2:end)]);
   endif
 endfunction
 
 
 %!shared xp, yp, xi, yi
-%! xp = [0:2:10].';   yp = sin(2*pi*xp/5);
+%! xp = [0:2:10].';   yp = sin (2*pi*xp/5);
 %! xi = [-1; 0; 2.2; 4; 6.6; 10; 11];
 %! yi = interp1 (xp,yp,xi);
 %!assert (interp1q (xp,yp, [min(xp)-1; max(xp)+1]), [NA; NA]);
 %!assert (interp1q (xp,yp,xp), yp, 100*eps);
 %!assert (isempty (interp1q (xp,yp,[])));
 %!assert (interp1q (xp,yp,xi), yi);
 %!assert (interp1q (xp,[yp,yp],xi), [yi, yi]);
 %!assert (interp1q (xp,yp,[xi,xi]), [yi, yi]);
diff --git a/scripts/general/interp2.m b/scripts/general/interp2.m
--- a/scripts/general/interp2.m
+++ b/scripts/general/interp2.m
@@ -372,17 +372,17 @@ function ZI = interp2 (varargin)
         AY0  = bc ((YI - L + 0));
         AX0  = bc ((XI - K + 0));
         AY_1 = bc ((YI - L - 1));
         AX_1 = bc ((XI - K - 1));
         AY_2 = bc ((YI - L - 2));
         AX_2 = bc ((XI - K - 2));
 
         ## Perform interpolation
-        sz = size(Z);
+        sz = size (Z);
         ZI = AY_2 .* AX_2 .* Z (sym_sub2ind (sz, L+2, K+2)) ...
            + AY_2 .* AX_1 .* Z (sym_sub2ind (sz, L+2, K+1)) ...
            + AY_2 .* AX0  .* Z (sym_sub2ind (sz, L+2, K))   ...
            + AY_2 .* AX1  .* Z (sym_sub2ind (sz, L+2, K-1)) ...
            + AY_1 .* AX_2 .* Z (sym_sub2ind (sz, L+1, K+2)) ...
            + AY_1 .* AX_1 .* Z (sym_sub2ind (sz, L+1, K+1)) ...
            + AY_1 .* AX0  .* Z (sym_sub2ind (sz, L+1, K))   ...
            + AY_1 .* AX1  .* Z (sym_sub2ind (sz, L+1, K-1)) ...
@@ -415,38 +415,38 @@ function ZI = interp2 (varargin)
 endfunction
 
 function b = isgriddata (X)
   d1 = diff (X, 1, 1);
   b = all (d1 (:) == 0);
 endfunction
 
 ## Compute the bicubic interpolation coefficients
-function o = bc(x)
-  x = abs(x);
-  o = zeros(size(x));
+function o = bc (x)
+  x = abs (x);
+  o = zeros (size (x));
   idx1 = (x < 1);
   idx2 = !idx1 & (x < 2);
   o(idx1) = 1 - 2.*x(idx1).^2 + x(idx1).^3;
   o(idx2) = 4 - 8.*x(idx2) + 5.*x(idx2).^2 - x(idx2).^3;
 endfunction
 
 ## This version of sub2ind behaves as if the data was symmetrically padded
-function ind = sym_sub2ind(sz, Y, X)
+function ind = sym_sub2ind (sz, Y, X)
   Y (Y < 1) = 1 - Y (Y < 1);
   while (any (Y (:) > 2 * sz (1)))
     Y (Y > 2 * sz (1)) = round (Y (Y > 2 * sz (1)) / 2);
   endwhile
   Y (Y > sz (1)) = 1 + 2 * sz (1) - Y (Y > sz (1));
   X (X < 1) = 1 - X (X < 1);
   while (any (X (:) > 2 * sz (2)))
     X (X > 2 * sz (2)) = round (X (X > 2 * sz (2)) / 2);
   endwhile
   X (X > sz (2)) = 1 + 2 * sz (2) - X (X > sz (2));
-  ind = sub2ind(sz, Y, X);
+  ind = sub2ind (sz, Y, X);
 endfunction
 
 
 %!demo
 %! clf;
 %! colormap ("default");
 %! A = [13,-1,12;5,4,3;1,6,2];
 %! x = [0,1,4];  y = [10,11,12];
diff --git a/scripts/general/interpn.m b/scripts/general/interpn.m
--- a/scripts/general/interpn.m
+++ b/scripts/general/interpn.m
@@ -193,18 +193,18 @@ function vi = interpn (varargin)
     if (size_equal (y{:}))
       ly = length (y{1});
       idx = cell (1, ly);
       q = cell (1, nd);
       for i = 1 : ly
         q(:) = i;
         idx {i} = q;
       endfor
-      vi = vi (cellfun (@(x) sub2ind (size(vi), x{:}), idx));
-      vi = reshape (vi, size(y{1}));
+      vi = vi (cellfun (@(x) sub2ind (size (vi), x{:}), idx));
+      vi = reshape (vi, size (y{1}));
     endif
   elseif (strcmp (method, "cubic"))
     error ("interpn: cubic interpolation not yet implemented");
   else
     error ("interpn: unrecognized interpolation METHOD");
   endif
 
 endfunction
diff --git a/scripts/general/loadobj.m b/scripts/general/loadobj.m
--- a/scripts/general/loadobj.m
+++ b/scripts/general/loadobj.m
@@ -32,10 +32,10 @@
 ## endfunction
 ## @end group
 ## @end example
 ##
 ## @seealso{saveobj, class}
 ## @end deftypefn
 
 function b = loadobj (a)
-  error ("loadobj: not defined for class \"%s\"", class(a));
+  error ('loadobj: not defined for class "%s"', class (a));
 endfunction
diff --git a/scripts/general/nthargout.m b/scripts/general/nthargout.m
--- a/scripts/general/nthargout.m
+++ b/scripts/general/nthargout.m
@@ -29,28 +29,28 @@
 ##
 ## The intended use @code{nthargout} is to avoid intermediate variables.
 ## For example, when finding the indices of the maximum entry of a
 ## matrix, the following two compositions of nthargout
 ##
 ## @example
 ## @group
 ## @var{m} = magic (5);
-## cell2mat (nthargout ([1, 2], @@ind2sub, size(@var{m}),
+## cell2mat (nthargout ([1, 2], @@ind2sub, size (@var{m}),
 ##                      nthargout (2, @@max, @var{m}(:))))
 ## @result{} 5   3
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## are completely equivalent to the following lines:
 ##
 ## @example
 ## @group
-## @var{m} = magic(5);
+## @var{m} = magic (5);
 ## [~, idx] = max (@var{M}(:));
 ## [i, j] = ind2sub (size (@var{m}), idx);
 ## [i, j]
 ## @result{} 5   3
 ## @end group
 ## @end example
 ##
 ## It can also be helpful to have all output arguments in a single cell
diff --git a/scripts/general/private/__isequal__.m b/scripts/general/private/__isequal__.m
--- a/scripts/general/private/__isequal__.m
+++ b/scripts/general/private/__isequal__.m
@@ -53,17 +53,17 @@ function t = __isequal__ (nans_compare_e
   endif
 
   l_v = nargin - 2;
 
   ## Generic tests.
 
   ## All arguments must either be of the same class or they must be
   ## numeric values.
-  t = (all (strcmp (class(x),
+  t = (all (strcmp (class (x),
                     cellfun ("class", varargin, "uniformoutput", false)))
        || ((isnumeric (x) || islogical (x))
            && all (cellfun ("isnumeric", varargin)
                    | cellfun ("islogical", varargin))));
 
   if (t)
     ## Test that everything has the same number of dimensions.
     s_x = size (x);
diff --git a/scripts/general/private/__splinen__.m b/scripts/general/private/__splinen__.m
--- a/scripts/general/private/__splinen__.m
+++ b/scripts/general/private/__splinen__.m
@@ -26,24 +26,24 @@
 ## FIXME: Allow arbitrary grids..
 
 function yi = __splinen__ (x, y, xi, extrapval, f)
   if (nargin != 5)
     error ("__splinen__: Incorrect number of arguments");
   endif
   ## ND isvector function.
   isvec = @(x) numel (x) == length (x);
-  if (!iscell (x) || length(x) < ndims(y) || any (! cellfun (isvec, x))
-      || !iscell (xi) || length(xi) < ndims(y) || any (! cellfun (isvec, xi)))
+  if (!iscell (x) || length (x) < ndims (y) || any (! cellfun (isvec, x))
+      || !iscell (xi) || length (xi) < ndims (y) || any (! cellfun (isvec, xi)))
     error ("__splinen__: %s: non gridded data or dimensions inconsistent", f);
   endif
   yi = y;
-  for i = length(x):-1:1
+  for i = length (x):-1:1
     yi = permute (spline (x{i}, yi, xi{i}(:)), [length(x),1:length(x)-1]);
   endfor
 
   [xi{:}] = ndgrid (cellfun (@(x) x(:), xi, "uniformoutput", false){:});
-  idx = zeros (size(xi{1}));
-  for i = 1 : length(x)
+  idx = zeros (size (xi{1}));
+  for i = 1 : length (x)
     idx |= xi{i} < min (x{i}(:)) | xi{i} > max (x{i}(:));
   endfor
   yi(idx) = extrapval;
 endfunction
diff --git a/scripts/general/quadgk.m b/scripts/general/quadgk.m
--- a/scripts/general/quadgk.m
+++ b/scripts/general/quadgk.m
@@ -157,17 +157,17 @@ function [q, err] = quadgk (f, a, b, var
           if (ischar (varargin{idx}))
             str = varargin{idx++};
             if (strcmpi (str, "reltol"))
               reltol = varargin{idx++};
             elseif (strcmpi (str, "abstol"))
               abstol = varargin{idx++};
             elseif (strcmpi (str, "waypoints"))
               waypoints = varargin{idx++} (:);
-              if (isreal(waypoints))
+              if (isreal (waypoints))
                 waypoints (waypoints < a | waypoints > b) = [];
               endif
             elseif (strcmpi (str, "maxintervalcount"))
               maxint = varargin{idx++};
             elseif (strcmpi (str, "trace"))
               trace = varargin{idx++};
             else
               error ("quadgk: unknown property %s", str);
@@ -185,32 +185,32 @@ function [q, err] = quadgk (f, a, b, var
     ## Convert function given as a string to a function handle
     if (ischar (f))
       f = @(x) feval (f, x);
     endif
 
     ## Use variable subsitution to weaken endpoint singularities and to
     ## perform integration with endpoints at infinity. No transform for
     ## contour integrals
-    if (iscomplex (a) || iscomplex (b) || iscomplex(waypoints))
+    if (iscomplex (a) || iscomplex (b) || iscomplex (waypoints))
       ## contour integral, no transform
       subs = [a; waypoints; b];
       h = sum (abs (diff (subs)));
       h0 = h;
       trans = @(t) t;
-    elseif (isinf (a) && isinf(b))
+    elseif (isinf (a) && isinf (b))
       ## Standard Infinite to finite integral transformation.
       ##   \int_{-\infinity_^\infinity f(x) dx = \int_-1^1 f (g(t)) g'(t) dt
       ## where
       ##   g(t)  = t / (1 - t^2)
       ##   g'(t) =  (1 + t^2) / (1 - t^2) ^ 2
       ## waypoint transform is then
       ##   t =  (2 * g(t)) ./ (1 + sqrt(1 + 4 * g(t) .^ 2))
       if (!isempty (waypoints))
-        trans = @(x) (2 * x) ./ (1 + sqrt(1 + 4 * x .^ 2));
+        trans = @(x) (2 * x) ./ (1 + sqrt (1 + 4 * x .^ 2));
         subs = [-1; trans(waypoints); 1];
       else
         subs = linspace (-1, 1, 11)';
       endif
       h = 2;
       h0 = b - a;
       trans = @(t) t ./ (1 - t.^2);
       f = @(t) f (t ./ (1 - t .^ 2)) .* (1 + t .^ 2) ./ ((1 - t .^ 2) .^ 2);
@@ -235,17 +235,17 @@ function [q, err] = quadgk (f, a, b, var
         subs = [-1; trans(tmp); 0];
       else
         subs = linspace (-1, 0, 11)';
       endif
       h = 1;
       h0 = b - a;
       trans = @(t) b - (t ./ (1 + t)).^2;
       f = @(s) - 2 * s .* f (b -  (s ./ (1 + s)) .^ 2) ./ ((1 + s) .^ 3);
-    elseif (isinf(b))
+    elseif (isinf (b))
       ## Formula defined in Shampine paper as two separate steps. One to
       ## weaken singularity at finite end, then a second to transform to
       ## a finite interval. The singularity weakening transform is
       ##   \int_a^\infinity f(x) dx = \int_0^\infinity f (a + t^2) 2 t dt
       ## and the finite interval transform is
       ##  \int_0^\infinity f(a + t^2)  2 t dt =
       ##           \int_0^1 f (a + g(s) ^ 2) 2 g(s) g'(s) ds
       ## where
@@ -276,17 +276,17 @@ function [q, err] = quadgk (f, a, b, var
       ## ignored. The third is
       ##  c = (-4*x + 2*(b+a)) / (b-a);
       ##  k = ((sqrt(c^2 - 4) + c)/2)^(1/3);
       ##  t = (sqrt(3)* 1i * (1 - k^2) - (1 + k^2)) / 2 / k;
       if (! isempty (waypoints))
         trans = @__quadgk_finite_waypoint__;
         subs = [-1; trans(waypoints, a, b); 1];
       else
-        subs = linspace(-1, 1, 11)';
+        subs = linspace (-1, 1, 11)';
       endif
       h = 2;
       h0 = b - a;
       trans = @(t) ((b - a) ./ 4) * t .* (3 - t.^2) + (b + a) ./ 2;
       f = @(t) f((b - a) ./ 4 .* t .* (3 - t.^2) + (b + a) ./ 2) .* ...
            3 .* (b - a) ./ 4 .* (1 - t.^2);
     endif
 
@@ -338,17 +338,17 @@ function [q, err] = quadgk (f, a, b, var
         ## If the global error estimate is meet exit
         if (err0 < tol)
           q = q0;
           err = err0;
           break;
         endif
 
         ## Accept the subintervals that meet the convergence criteria
-        idx = find (abs (q_errs) < tol .* abs(diff (subs, [], 2)) ./ h);
+        idx = find (abs (q_errs) < tol .* abs (diff (subs, [], 2)) ./ h);
         if (first)
           q = sum (q_subs (idx));
           err = sum (q_errs(idx));
           first = false;
         else
           q0 = q + sum (q_subs);
           err0 = err + sum (q_errs);
           q += sum (q_subs (idx));
@@ -357,17 +357,17 @@ function [q, err] = quadgk (f, a, b, var
         subs(idx,:) = [];
 
         ## If no remaining subintervals exit
         if (rows (subs) == 0)
           break;
         endif
 
         if (trace)
-          disp([rows(subs), err, q0]);
+          disp ([rows(subs), err, q0]);
         endif
 
         ## Split remaining subintervals in two
         mid = (subs(:,2) + subs(:,1)) ./ 2;
         subs = [subs(:,1), mid; mid, subs(:,2)];
 
         ## If the maximum subinterval count is met accept remaining
         ## subinterval and exit
@@ -377,17 +377,17 @@ function [q, err] = quadgk (f, a, b, var
           err += sum (q_errs);
           break;
         endif
 
         ## Evaluation of the integrand on the remaining subintervals
         [q_subs, q_errs] = __quadgk_eval__ (f, subs);
       endwhile
 
-      if (err > max (abstol, reltol * abs(q)))
+      if (err > max (abstol, reltol * abs (q)))
         warning ("quadgk: Error tolerance not met. Estimated error %g", err);
       endif
     unwind_protect_cleanup
       if (strcmp (warn_state.state, "on"))
         warning ("on", "Octave:divide-by-zero");
       endif
     end_unwind_protect
   endif
@@ -420,28 +420,28 @@ function [q, err] = __quadgk_eval__ (f, 
       diag ([0.1294849661688697e+00,  0.2797053914892767e+00, ...
              0.3818300505051889e+00,  0.4179591836734694e+00, ...
              0.3818300505051889e+00,  0.2797053914892767e+00, ...
              0.1294849661688697e+00]);
 
   halfwidth = diff (subs, [], 2) ./ 2;
   center = sum (subs, 2) ./ 2;;
   x = bsxfun (@plus, halfwidth * abscissa, center);
-  y = reshape (f (x(:)), size(x));
+  y = reshape (f (x(:)), size (x));
 
   ## This is faster than using bsxfun as the * operator can use a
   ## single BLAS call, rather than rows(sub) calls to the @times
   ## function.
   q = sum (y * weights15, 2) .* halfwidth;
   err = abs (sum (y(:,2:2:end) * weights7, 2) .* halfwidth - q);
 endfunction
 
 function t = __quadgk_finite_waypoint__ (x, a, b)
   c = (-4 .* x + 2.* (b + a)) ./ (b - a);
-  k = ((sqrt(c .^ 2 - 4) + c) ./ 2) .^ (1/3);
+  k = ((sqrt (c .^ 2 - 4) + c) ./ 2) .^ (1/3);
   t = real ((sqrt(3) .* 1i * (1 - k .^ 2) - (1 + k .^ 2)) ./ 2 ./ k);
 endfunction
 
 
 %!assert (quadgk (@sin,-pi,pi), 0, 1e-6)
 %!assert (quadgk (inline ("sin"),-pi,pi), 0, 1e-6)
 %!assert (quadgk ("sin",-pi,pi), 0, 1e-6)
 %!assert (quadgk (@sin,-pi,pi, "waypoints", 0, "MaxIntervalCount", 100, "reltol", 1e-3, "abstol", 1e-6, "trace", false), 0, 1e-6)
diff --git a/scripts/general/quadl.m b/scripts/general/quadl.m
--- a/scripts/general/quadl.m
+++ b/scripts/general/quadl.m
@@ -131,17 +131,17 @@ function q = quadl (f, a, b, tol = [], t
   if (erri2 != 0)
     R = erri1/erri2;
   else
     R = 1;
   endif
   if (R > 0 && R < 1)
     tol = tol/R;
   endif
-  is = s * abs(is) * tol/myeps;
+  is = s * abs (is) * tol/myeps;
   if (is == 0)
     is = b-a;
   endif
 
   q = adaptlobstp (f, a, b, fa, fb, is, trace, varargin{:});
 
 endfunction
 
@@ -157,17 +157,17 @@ endfunction
 
 function q = adaptlobstp (f, a, b, fa, fb, is, trace, varargin)
   global __quadl_recurse_done__;
   global __quadl_need_warning__;
 
   h = (b-a)/2;
   m = (a+b)/2;
   alpha = sqrt (2/3);
-  beta = 1 / sqrt(5);
+  beta = 1 / sqrt (5);
   mll = m-alpha*h;
   ml  = m-beta*h;
   mr  = m+beta*h;
   mrr = m+alpha*h;
   x = [mll, ml, m, mr, mrr];
   y = feval (f, x, varargin{:});
   fmll = y(1);
   fml  = y(2);
diff --git a/scripts/general/quadv.m b/scripts/general/quadv.m
--- a/scripts/general/quadv.m
+++ b/scripts/general/quadv.m
@@ -148,16 +148,16 @@ function [q, nfun, hmin] = simpsonstp (f
   endif
 endfunction
 
 
 %!assert (quadv (@sin, 0, 2 * pi), 0, 1e-5)
 %!assert (quadv (@sin, 0, pi), 2, 1e-5)
 
 %% Handles weak singularities at the edge
-%!assert (quadv (@(x) 1 ./ sqrt(x), 0, 1), 2, 1e-5)
+%!assert (quadv (@(x) 1 ./ sqrt (x), 0, 1), 2, 1e-5)
 
 %% Handles vector-valued functions
 %!assert (quadv (@(x) [(sin (x)), (sin (2 * x))], 0, pi), [2, 0], 1e-5)
 
 %% Handles matrix-valued functions
 %!assert (quadv (@(x) [ x, x, x; x, 1./sqrt(x), x; x, x, x ], 0, 1 ), [0.5, 0.5, 0.5; 0.5, 2, 0.5; 0.5, 0.5, 0.5], 1e-5)
 
diff --git a/scripts/general/rat.m b/scripts/general/rat.m
--- a/scripts/general/rat.m
+++ b/scripts/general/rat.m
@@ -31,60 +31,60 @@
 ## @end group
 ## @end example
 ##
 ## Called with two arguments returns the numerator and denominator separately
 ## as two matrices.
 ## @seealso{rats}
 ## @end deftypefn
 
-function [n,d] = rat(x,tol)
+function [n,d] = rat (x,tol)
 
   if (nargin != [1,2] || nargout > 2)
     print_usage ();
   endif
 
   y = x(:);
 
   ## Replace Inf with 0 while calculating ratios.
   y(isinf(y)) = 0;
 
   ## default norm
   if (nargin < 2)
-    tol = 1e-6 * norm(y,1);
+    tol = 1e-6 * norm (y,1);
   endif
 
   ## First step in the approximation is the integer portion
 
   ## First element in the continued fraction.
-  n = round(y);
-  d = ones(size(y));
+  n = round (y);
+  d = ones (size (y));
   frac = y-n;
-  lastn = ones(size(y));
-  lastd = zeros(size(y));
+  lastn = ones (size (y));
+  lastd = zeros (size (y));
 
-  nd = ndims(y);
+  nd = ndims (y);
   nsz = numel (y);
-  steps = zeros([nsz, 0]);
+  steps = zeros ([nsz, 0]);
 
   ## Grab new factors until all continued fractions converge.
   while (1)
     ## Determine which fractions have not yet converged.
-    idx = find(abs (y-n./d) >= tol);
-    if (isempty(idx))
+    idx = find (abs (y-n./d) >= tol);
+    if (isempty (idx))
       if (isempty (steps))
         steps = NaN (nsz, 1);
       endif
       break;
     endif
 
     ## Grab the next step in the continued fraction.
     flip = 1./frac(idx);
     ## Next element in the continued fraction.
-    step = round(flip);
+    step = round (flip);
 
     if (nargout < 2)
       tsteps = NaN (nsz, 1);
       tsteps (idx) = step;
       steps = [steps, tsteps];
     endif
 
     frac(idx) = flip-step;
@@ -95,33 +95,33 @@ function [n,d] = rat(x,tol)
     n(idx) = n(idx).*step + lastn(idx);
     d(idx) = d(idx).*step + lastd(idx);
     lastn = nextn;
     lastd = nextd;
   endwhile
 
   if (nargout == 2)
     ## Move the minus sign to the top.
-    n = n.*sign(d);
-    d = abs(d);
+    n = n .* sign (d);
+    d = abs (d);
 
     ## Return the same shape as you receive.
-    n = reshape(n, size(x));
-    d = reshape(d, size(x));
+    n = reshape (n, size (x));
+    d = reshape (d, size (x));
 
     ## Use 1/0 for Inf.
-    n(isinf(x)) = sign(x(isinf(x)));
-    d(isinf(x)) = 0;
+    n(isinf (x)) = sign (x(isinf (x)));
+    d(isinf (x)) = 0;
 
     ## Reshape the output.
     n = reshape (n, size (x));
     d = reshape (d, size (x));
   else
     n = "";
-    nsteps = size(steps, 2);
+    nsteps = columns (steps);
     for i = 1: nsz
       s = [int2str(y(i))," "];
       j = 1;
 
       while (true)
         step = steps(i, j++);
         if (isnan (step))
           break;
diff --git a/scripts/general/rot90.m b/scripts/general/rot90.m
--- a/scripts/general/rot90.m
+++ b/scripts/general/rot90.m
@@ -82,22 +82,22 @@ endfunction
 
 
 %!test
 %! x1 = [1, 2; 3, 4];
 %! x2 = [2, 4; 1, 3];
 %! x3 = [4, 3; 2, 1];
 %! x4 = [3, 1; 4, 2];
 %!
-%! assert(rot90 (x1), x2);
-%! assert(rot90 (x1, 2), x3);
-%! assert(rot90 (x1, 3), x4);
-%! assert(rot90 (x1, 4), x1);
-%! assert(rot90 (x1, 5), x2);
-%! assert(rot90 (x1, -1), x4);
+%! assert (rot90 (x1), x2);
+%! assert (rot90 (x1, 2), x3);
+%! assert (rot90 (x1, 3), x4);
+%! assert (rot90 (x1, 4), x1);
+%! assert (rot90 (x1, 5), x2);
+%! assert (rot90 (x1, -1), x4);
 
 %% Test input validation
 %!error rot90 ()
 %!error rot90 (1, 2, 3)
-%!error rot90 (1, ones(2))
+%!error rot90 (1, ones (2))
 %!error rot90 (1, 1.5)
 %!error rot90 (1, 1+i)
 
diff --git a/scripts/general/rotdim.m b/scripts/general/rotdim.m
--- a/scripts/general/rotdim.m
+++ b/scripts/general/rotdim.m
@@ -55,18 +55,18 @@
 ## @end deftypefn
 
 function y = rotdim (x, n, plane)
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
   endif
 
-  if (nargin > 1 && ! isempty(n))
-    if (!isscalar (n) || !isreal(n) || fix (n) != n)
+  if (nargin > 1 && ! isempty (n))
+    if (!isscalar (n) || !isreal (n) || fix (n) != n)
       error ("rotdim: N must be a scalar integer");
     endif
   else
     n = 1;
   endif
 
   nd = ndims (x);
   sz = size (x);
diff --git a/scripts/general/saveobj.m b/scripts/general/saveobj.m
--- a/scripts/general/saveobj.m
+++ b/scripts/general/saveobj.m
@@ -35,10 +35,10 @@
 ## endfunction
 ## @end group
 ## @end example
 ##
 ## @seealso{loadobj, class}
 ## @end deftypefn
 
 function b = saveobj (a)
-  error ("saveobj: not defined for class \"%s\"", class(a));
+  error ('saveobj: not defined for class "%s"', class (a));
 endfunction
diff --git a/scripts/general/subsindex.m b/scripts/general/subsindex.m
--- a/scripts/general/subsindex.m
+++ b/scripts/general/subsindex.m
@@ -55,11 +55,11 @@
 ## @result{} 1  2  3  4
 ## @end group
 ## @end example
 ##
 ## @seealso{class, subsref, subsasgn}
 ## @end deftypefn
 
 function idx = subsindex (a)
-  error ("subsindex: not defined for class \"%s\"", class(a));
+  error ("subsindex: not defined for class \"%s\"", class (a));
 endfunction
 
diff --git a/scripts/general/triplequad.m b/scripts/general/triplequad.m
--- a/scripts/general/triplequad.m
+++ b/scripts/general/triplequad.m
@@ -64,17 +64,17 @@ function q = triplequad (f, xa, xb, ya, 
     varargin = {};
   endif
 
   q = dblquad (@(y, z) inner (y, z, f, xa, xb, tol, quadf, varargin{:}), ya, yb, za, zb, tol);
 
 endfunction
 
 function q = __triplequad_inner__ (y, z, f, xa, xb, tol, quadf, varargin)
-  q = zeros (size(y));
+  q = zeros (size (y));
   for i = 1 : length (y)
     q(i) = feval (quadf, @(x) f (x, y(i), z, varargin{:}), xa, xb, tol);
   endfor
 endfunction
 
 
 %!assert (triplequad (@(x,y,z) exp (-x.^2 - y.^2 - z.^2) , -1, 1, -1, 1, -1, 1, [], @quadcc), pi^(3/2) * erf (1).^3, 1e-6)
 
diff --git a/scripts/geometry/delaunay3.m b/scripts/geometry/delaunay3.m
--- a/scripts/geometry/delaunay3.m
+++ b/scripts/geometry/delaunay3.m
@@ -49,17 +49,17 @@
 
 function tetr = delaunay3 (x, y, z, options)
 
   if (nargin < 3 || nargin > 4)
     print_usage ();
   endif
 
   if (! (isvector (x) && isvector (y) && isvector (z)
-         && length (x) == length (y) && length(x) == length (z)))
+         && length (x) == length (y) && length (x) == length (z)))
     error ("delaunay: X, Y, and Z must be the same size");
   elseif (nargin == 4 && ! (ischar (options) || iscellstr (options)))
     error ("delaunay3: OPTIONS must be a string or cell array of strings");
   endif
 
   if (nargin == 3)
     tetr = delaunayn ([x(:), y(:), z(:)]);
   else
diff --git a/scripts/geometry/griddata.m b/scripts/geometry/griddata.m
--- a/scripts/geometry/griddata.m
+++ b/scripts/geometry/griddata.m
@@ -173,19 +173,19 @@ endfunction
 %! z = sin (2*(x.^2 + y.^2));
 %! [xx,yy] = meshgrid (linspace (-1,1,32));
 %! griddata (x,y,z,xx,yy,"nearest");
 %! title ("nonuniform grid sampled at 1000 points with nearest neighbor");
 
 %!testif HAVE_QHULL
 %! [xx,yy] = meshgrid (linspace (-1,1,32));
 %! x = xx(:);
-%! x = x + 10*(2*round (rand (size(x))) - 1) * eps;
+%! x = x + 10*(2*round (rand (size (x))) - 1) * eps;
 %! y = yy(:);
-%! y = y + 10*(2*round (rand (size(y))) - 1) * eps;
+%! y = y + 10*(2*round (rand (size (y))) - 1) * eps;
 %! z = sin (2*(x.^2 + y.^2));
 %! zz = griddata (x,y,z,xx,yy,"linear");
 %! zz2 = sin (2*(xx.^2 + yy.^2));
 %! zz2(isnan (zz)) = NaN;
 %! assert (zz, zz2, 100*eps);
 
 %% Test input validation
 %!error griddata ()
diff --git a/scripts/geometry/inpolygon.m b/scripts/geometry/inpolygon.m
--- a/scripts/geometry/inpolygon.m
+++ b/scripts/geometry/inpolygon.m
@@ -49,19 +49,19 @@ function [in, on] = inpolygon (x, y, xv,
   elseif (! (isreal (xv) && isreal (yv) && isvector (xv) && isvector (yv)
              && size_equal (xv, yv)))
     error ("inpolygon: last two arguments must be real vectors of same size");
   endif
 
   npol = length (xv);
   do_boundary = (nargout >= 2);
 
-  in = zeros (size(x), "logical");
+  in = zeros (size (x), "logical");
   if (do_boundary)
-    on = zeros (size(x), "logical");
+    on = zeros (size (x), "logical");
   endif
 
   j = npol;
   for i = 1 : npol
     delta_xv = xv(j) - xv(i);
     delta_yv = yv(j) - yv(i);
     ## distance = [distance from (x,y) to edge] * length(edge)
     distance = delta_xv .* (y - yv(i)) - (x - xv(i)) .* delta_yv;
diff --git a/scripts/geometry/tsearchn.m b/scripts/geometry/tsearchn.m
--- a/scripts/geometry/tsearchn.m
+++ b/scripts/geometry/tsearchn.m
@@ -26,31 +26,31 @@
 ## @seealso{delaunay, delaunayn}
 ## @end deftypefn
 
 function [idx, p] = tsearchn (x, t, xi)
   if (nargin != 3)
     print_usage ();
   endif
 
-  nt = size (t, 1);
+  nt = rows (t);
   [m, n] = size (x);
-  mi = size (xi, 1);
+  mi = rows (xi);
   idx = NaN (mi, 1);
   p = NaN (mi, n + 1);
 
   ni = [1:mi].';
   for i = 1 : nt
     ## Only calculate the Barycentric coordinates for points that have not
     ## already been found in a triangle.
     b = cart2bary (x (t (i, :), :), xi(ni,:));
 
     ## Our points xi are in the current triangle if
-    ## (all(b >= 0) && all (b <= 1)). However as we impose that
-    ## sum(b,2) == 1 we only need to test all(b>=0). Note need to add
+    ## (all (b >= 0) && all (b <= 1)). However as we impose that
+    ## sum (b,2) == 1 we only need to test all(b>=0). Note need to add
     ## a small margin for rounding errors
     intri = all (b >= -1e-12, 2);
     idx(ni(intri)) = i;
     p(ni(intri),:) = b(intri, :);
     ni(intri) = [];
   endfor
 endfunction
 
@@ -64,27 +64,27 @@ function Beta = cart2bary (T, P)
   ##
   ## Where Beta is a N+1 vector of the barycentric coordinates. A criteria
   ## on Beta is that
   ##
   ## sum (Beta) == 1
   ##
   ## and therefore we can write the above as
   ##
-  ## P - T(end, :) = Beta(1:end-1) * (T(1:end-1,:) - ones(N,1) * T(end,:))
+  ## P - T(end, :) = Beta(1:end-1) * (T(1:end-1,:) - ones (N,1) * T(end,:))
   ##
   ## and then we can solve for Beta as
   ##
-  ## Beta(1:end-1) = (P - T(end,:)) / (T(1:end-1,:) - ones(N,1) * T(end,:))
-  ## Beta(end) = sum(Beta)
+  ## Beta(1:end-1) = (P - T(end,:)) / (T(1:end-1,:) - ones (N,1) * T(end,:))
+  ## Beta(end) = sum (Beta)
   ##
   ## Note below is generalize for multiple values of P, one per row.
   [M, N] = size (P);
-  Beta = (P - ones (M,1) * T(end,:)) / (T(1:end-1,:) - ones(N,1) * T(end,:));
-  Beta (:,end+1) = 1 - sum(Beta, 2);
+  Beta = (P - ones (M,1) * T(end,:)) / (T(1:end-1,:) - ones (N,1) * T(end,:));
+  Beta (:,end+1) = 1 - sum (Beta, 2);
 endfunction
 
 
 %!shared x, tri
 %! x = [-1,-1;-1,1;1,-1];
 %! tri = [1, 2, 3];
 %!test
 %! [idx, p] = tsearchn (x,tri,[-1,-1]);
diff --git a/scripts/geometry/voronoi.m b/scripts/geometry/voronoi.m
--- a/scripts/geometry/voronoi.m
+++ b/scripts/geometry/voronoi.m
@@ -32,17 +32,17 @@
 ##
 ## The @var{options} argument, which must be a string or cell array of strings,
 ## contains options passed to the underlying qhull command.
 ## See the documentation for the Qhull library for details
 ## @url{http://www.qhull.org/html/qh-quick.htm#options}.
 ##
 ## If a single output argument is requested then the Voronoi diagram will be
 ## plotted and a graphics handle @var{h} to the plot is returned.
-## [@var{vx}, @var{vy}] = voronoi(@dots{}) returns the Voronoi vertices
+## [@var{vx}, @var{vy}] = voronoi (@dots{}) returns the Voronoi vertices
 ## instead of plotting the diagram.
 ##
 ## @example
 ## @group
 ## x = rand (10, 1);
 ## y = rand (size (x));
 ## h = convhull (x, y);
 ## [vx, vy] = voronoi (x, y);
@@ -121,18 +121,18 @@ function [vx, vy] = voronoi (varargin)
   ymax = max (y(:));
   ymin = min (y(:));
   xdelta = xmax - xmin;
   ydelta = ymax - ymin;
   scale = 2;
 
   xbox = [xmin - scale * xdelta; xmin - scale * xdelta; ...
           xmax + scale * xdelta; xmax + scale * xdelta];
-  ybox = [xmin - scale * xdelta; xmax + scale * xdelta; ...
-          xmax + scale * xdelta; xmin - scale * xdelta];
+  ybox = [ymin - scale * ydelta; ymax + scale * ydelta; ...
+          ymax + scale * ydelta; ymin - scale * ydelta];
 
   [p, c, infi] = __voronoi__ ("voronoi",
                               [[x(:) ; xbox(:)], [y(:); ybox(:)]],
                               opts{:});
 
   idx = find (! infi);
   ll = length (idx);
   c = c(idx).';
@@ -141,17 +141,17 @@ function [vx, vy] = voronoi (varargin)
                              "uniformoutput", false));
 
   ## Identify the unique edges of the Voronoi diagram
   edges = sortrows (sort (edges).').';
   edges = edges (:, [(edges(1, 1: end - 1) != edges(1, 2 : end) | ...
                       edges(2, 1 :end - 1) != edges(2, 2 : end)), true]);
 
   ## Eliminate the edges of the diagram representing the box
-  poutside = (1 : rows(p)) ...
+  poutside = (1 : rows (p)) ...
       (p (:, 1) < xmin - xdelta | p (:, 1) > xmax + xdelta | ...
        p (:, 2) < ymin - ydelta | p (:, 2) > ymax + ydelta);
   edgeoutside = ismember (edges (1, :), poutside) & ...
       ismember (edges (2, :), poutside);
   edges (:, edgeoutside) = [];
 
   ## Get points of the diagram
   Vvx = reshape (p(edges, 1), size (edges));
@@ -175,13 +175,13 @@ endfunction
 
 %!demo
 %! voronoi (rand (10,1), rand (10,1));
 
 %!testif HAVE_QHULL
 %! phi = linspace (-pi, 3/4*pi, 8);
 %! [x,y] = pol2cart (phi, 1);
 %! [vx,vy] = voronoi (x,y);
-%! assert(vx(2,:), zeros (1, columns (vx)), eps);
-%! assert(vy(2,:), zeros (1, columns (vy)), eps);
+%! assert (vx(2,:), zeros (1, columns (vx)), eps);
+%! assert (vy(2,:), zeros (1, columns (vy)), eps);
 
 %% FIXME: Need input validation tests
 
diff --git a/scripts/help/get_first_help_sentence.m b/scripts/help/get_first_help_sentence.m
--- a/scripts/help/get_first_help_sentence.m
+++ b/scripts/help/get_first_help_sentence.m
@@ -100,21 +100,21 @@ function [text, status] = first_sentence
 
   ## Find, and remove, lines that start with @def. This should remove things
   ## such as @deftypefn, @deftypefnx, @defvar, etc.
   keep = true (size (help_text));
   def_idx = strfind (help_text, "@def");
   if (! isempty (def_idx))
     endl_idx = find (help_text == "\n");
     for k = 1:length (def_idx)
-      endl = endl_idx (find (endl_idx > def_idx(k), 1));
+      endl = endl_idx(find (endl_idx > def_idx(k), 1));
       if (isempty (endl))
-        keep (def_idx(k) : end) = false;
+        keep(def_idx(k):end) = false;
       else
-        keep (def_idx(k) : endl) = false;
+        keep(def_idx(k):endl) = false;
       endif
     endfor
 
     ## Remove the @end ... that corresponds to the @def we removed above
     def1 = def_idx(1);
     space_idx = find (help_text == " ");
     space_idx = space_idx (find (space_idx > def1, 1));
     bracket_idx = find (help_text == "{" | help_text == "}");
diff --git a/scripts/help/unimplemented.m b/scripts/help/unimplemented.m
--- a/scripts/help/unimplemented.m
+++ b/scripts/help/unimplemented.m
@@ -138,17 +138,16 @@ function list = missing_functions ()
   "cmunique",
   "colordef",
   "colormapeditor",
   "commandhistory",
   "commandwindow",
   "condeig",
   "coneplot",
   "contourslice",
-  "copyobj",
   "createClassFromWsdl",
   "createSoapMessage",
   "customverctrl",
   "daqread",
   "datacursormode",
   "datatipinfo",
   "dbmex",
   "dde23",
diff --git a/scripts/help/which.m b/scripts/help/which.m
--- a/scripts/help/which.m
+++ b/scripts/help/which.m
@@ -52,15 +52,15 @@ function varargout = which (varargin)
     print_usage ();
   endif
 
 endfunction
 
 
 %!test
 %! str = which ("ls");
-%! assert (str(end-17:end), strcat ("miscellaneous", filesep(), "ls.m"));
+%! assert (str(end-17:end), strcat ("miscellaneous", filesep (), "ls.m"));
 %!test
 %! str = which ("dot");
 %! assert (str(end-6:end), "dot.oct");
 
 %!assert (which ("_NO_SUCH_NAME_"), "")
 
diff --git a/scripts/image/gray2ind.m b/scripts/image/gray2ind.m
--- a/scripts/image/gray2ind.m
+++ b/scripts/image/gray2ind.m
@@ -30,17 +30,17 @@
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function [X, map] = gray2ind (I, n = 64)
   ## Check input
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
-  C = class(I);
+  C = class (I);
   if (! ismatrix (I) || ndims (I) != 2)
     error ("gray2ind: first input argument must be a gray scale image");
   endif
   if (! isscalar (n) || n < 0)
     error ("gray2ind: second input argument must be a positive integer");
   endif
   ints = {"uint8", "uint16", "int8", "int16"};
   floats = {"double", "single"};
diff --git a/scripts/image/image.m b/scripts/image/image.m
--- a/scripts/image/image.m
+++ b/scripts/image/image.m
@@ -130,22 +130,22 @@ function h = __img__ (x, y, img, varargi
   tmp = __go_image__ (ca, "cdata", img, "xdata", xdata, "ydata", ydata,
                     "cdatamapping", "direct", varargin {:});
 
   px = __image_pixel_size__ (tmp);
 
   if (xdata(2) < xdata(1))
     xdata = xdata(2:-1:1);
   elseif (xdata(2) == xdata(1))
-    xdata = xdata(1) + [0, size(img,2)-1];
+    xdata = xdata(1) + [0, columns(img)-1];
   endif
   if (ydata(2) < ydata(1))
     ydata = ydata(2:-1:1);
   elseif (ydata(2) == ydata(1))
-    ydata = ydata(1) + [0, size(img,1)-1];
+    ydata = ydata(1) + [0, rows(img)-1];
   endif
   xlim = xdata + [-px(1), px(1)];
   ylim = ydata + [-px(2), px(2)];
 
   ## FIXME -- how can we do this and also get the {x,y}limmode
   ## properties to remain "auto"?  I suppose this adjustment should
   ## happen automatically in axes::update_axis_limits instead of
   ## explicitly setting the values here.  But then what information is
diff --git a/scripts/image/imwrite.m b/scripts/image/imwrite.m
--- a/scripts/image/imwrite.m
+++ b/scripts/image/imwrite.m
@@ -157,17 +157,17 @@ function imwrite (img, varargin)
       endif
       if (nd != 2 && nd != 4)
         error ("imwrite: invalid size for indexed image");
       endif
     else
       error ("imwrite: %s: invalid class for indexed image data", img_class);
     endif
     if (isa (map, "double"))
-      if (ndims (map) != 2 || size (map, 2) != 3)
+      if (ndims (map) != 2 || columns (map) != 3)
         error ("imwrite: invalid size for colormap");
       endif
     else
       error ("imwrite: %s invalid class for indexed image colormap",
              class (map));
     endif
 
     ## FIXME -- we should really be writing indexed images here but
diff --git a/scripts/image/pink.m b/scripts/image/pink.m
--- a/scripts/image/pink.m
+++ b/scripts/image/pink.m
@@ -39,17 +39,17 @@ function map = pink (n)
     if (! isscalar (n))
       error ("pink: argument must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
-    map = sqrt([1/3, 1/3, 1/3]);
+    map = sqrt ([1/3, 1/3, 1/3]);
   elseif (n > 1)
     x = linspace (0, 1, n)';
     r = (x < 3/8) .* (14/9 * x) ...
       + (x >= 3/8) .* (2/3 * x + 1/3);
     g = (x < 3/8) .* (2/3 * x) ...
       + (x >= 3/8 & x < 3/4) .* (14/9 * x - 1/3) ...
       + (x >= 3/4) .* (2/3 * x + 1/3);
     b = (x < 3/4) .* (2/3 * x) ...
diff --git a/scripts/io/dlmwrite.m b/scripts/io/dlmwrite.m
--- a/scripts/io/dlmwrite.m
+++ b/scripts/io/dlmwrite.m
@@ -175,17 +175,17 @@ function dlmwrite (file, M, varargin)
       template = [precision, repmat([delim, precision], 1, columns(M)-1),...
                   newline];
     endif
     if (c > 0)
       template = [repmat(delim, 1, c), template];
     endif
     if (iscomplex (M))
       M = M.';
-      b = zeros (2*rows(M), columns (M));
+      b = zeros (2*rows (M), columns (M));
       b(1: 2 : end, :) = real (M);
       b(2: 2 : end, :) = imag (M);
       fprintf (fid, template, b);
     else
       fprintf (fid, template, M.');
     endif
     if (! isscalar (file))
       fclose (fid);
diff --git a/scripts/io/strread.m b/scripts/io/strread.m
--- a/scripts/io/strread.m
+++ b/scripts/io/strread.m
@@ -559,17 +559,17 @@ function varargout = strread (str, forma
       endif
       words = reshape (words, words_period, num_lines);
 
       ## 3. Do the column splitting on rectangular words array
       icol = 1; ii = 1;    # icol = current column, ii = current fmt_word
       while (ii <= num_words_per_line)
 
         ## Check if fmt_words(ii) contains a literal or fixed-width
-        if ((idf(ii) || idg(ii)) && (rows(words) < num_words_per_line))
+        if ((idf(ii) || idg(ii)) && (rows (words) < num_words_per_line))
           if (idf(ii))
             s = strfind (words(icol, 1), fmt_words{ii});
             if (isempty (s{:}))
               error ("strread: Literal '%s' not found in column %d", fmt_words{ii}, icol);
             endif
             s = s{:}(1);
             e = s(1) + length (fmt_words{ii}) - 1;
           endif
@@ -578,21 +578,21 @@ function varargout = strread (str, forma
             words(icol+1:end+1, :) = words(icol:end, :);
             ## Watch out for empty cells
             jptr = find (! cellfun ("isempty", words(icol, :)));
 
             ## Distinguish leading or trailing literals
             if (! idg(ii) && ! isempty (s) && s(1) == 1)
               ## Leading literal.  Assign literal to icol, paste rest in icol + 1
               ## Apply only to those cells that do have something beyond literal
-              jptr = find (cellfun("length", words(icol+1, jptr), ...
-                            "UniformOutput", false) > e(1));
+              jptr = find (cellfun ("length", words(icol+1, jptr), ...
+                                    "UniformOutput", false) > e(1));
               words(icol+1, :) = {""};
               words(icol+1, jptr) = cellfun ...
-                (@(x) substr(x, e(1)+1, length(x)-e(1)), words(icol, jptr), ...
+                (@(x) substr (x, e(1)+1, length (x) - e(1)), words(icol, jptr), ...
                 "UniformOutput", false);
               words(icol, jptr) = fmt_words{ii};
               fwptr = [fwptr(1:ii) (++fwptr(ii+1:end))];
 
             else
               if (! idg(ii) && ! isempty (strfind (fmt_words{ii-1}, "%s")))
                 ## Trailing literal.  If preceding format == '%s' this is an error
                 warning ("Ambiguous '%s' specifier next to literal in column %d", icol);
@@ -612,24 +612,24 @@ function varargout = strread (str, forma
                   fwptr = [fwptr(1:ii) (++fwptr(ii+1:end))];
                 endif
               else
                 ## FIXME: this assumes char(254)/char(255) won't occur in input!
                 clear wrds;
                 wrds(1:2:2*numel (words(icol, jptr))) = ...
                      strrep (words(icol, jptr), fmt_words{ii}, ...
                      [char(255) char(254)]);
-                wrds(2:2:2*numel (words(icol, jptr))-1) = char(255);
-                wrds = strsplit ([wrds{:}], char(255));
+                wrds(2:2:2*numel (words(icol, jptr))-1) = char (255);
+                wrds = strsplit ([wrds{:}], char (255));
                 words(icol, jptr) = ...
-                  wrds(find (cellfun ("isempty", strfind (wrds, char(254)))));
-                wrds(find (cellfun ("isempty", strfind (wrds, char(254))))) ...
-                   = char(255);
+                  wrds(find (cellfun ("isempty", strfind (wrds, char (254)))));
+                wrds(find (cellfun ("isempty", strfind (wrds, char (254))))) ...
+                   = char (255);
                 words(icol+1, jptr) = strsplit (strrep ([wrds{2:end}], ...
-                   char(254), fmt_words{ii}), char(255));
+                   char (254), fmt_words{ii}), char (255));
                 ## Former trailing literal may now be leading for next specifier
                 --ii;
                 fwptr = [fwptr(1:ii) (++fwptr(ii+1:end))];
               endif
             endif
           endif
 
         else
@@ -757,25 +757,25 @@ function out = split_by (text, sep, mult
   if (mult_dlms_s1)
     mult_dlms_s1 = true;
     ## FIXME: Should re-implement strsplit() function here in order
     ## to avoid strrep on megabytes of data.
     ## If \n is in sep collection we need to enclose it in text
     ## to avoid it being included in consecutive delim series
     enchr = ' ';
     ## However watch out if eol_char is also in delimiters
-    if (index (sep, eol_char)); enchr = char(255); endif
+    if (index (sep, eol_char)); enchr = char (255); endif
     text = strrep (text, eol_char, [enchr eol_char enchr]);
   else
     mult_dlms_s1 = false;
   endif
 
   ## Split text string along delimiters
   out = strsplit (text, sep, mult_dlms_s1);
-  if (index (sep, eol_char)); out = strrep (out, char(255), ''); endif
+  if (index (sep, eol_char)); out = strrep (out, char (255), ''); endif
   ## In case of trailing delimiter, strip stray last empty word
   if (!isempty (out) && any (sep == text(end)))
     out(end) = [];
   endif
 
   ## Empty cells converted to empty cellstrings.
   out(cellfun ("isempty", out)) = {""};
 
diff --git a/scripts/io/textread.m b/scripts/io/textread.m
--- a/scripts/io/textread.m
+++ b/scripts/io/textread.m
@@ -145,17 +145,17 @@ function varargout = textread (filename,
       eoi_pos = nblks * BUFLENGTH + count;
     else
       eoi_pos = (nblks * BUFLENGTH) + eoi(end + min (nlines, n_eoi) - n_eoi);
     endif
     fseek (fid, st_pos, "bof");
     str = fscanf (fid, "%c", eoi_pos);
   else
     fseek (fid, st_pos, "bof");
-    str = fread(fid, "char=>char").';
+    str = fread (fid, "char=>char").';
   endif
   fclose (fid);
  
   ## Set up default whitespace param value if needed
   if (isempty (find (strcmpi ("whitespace", varargin))))
     varargin(end+1:end+2) = {"whitespace", " \b\t"};
   endif
 
diff --git a/scripts/io/textscan.m b/scripts/io/textscan.m
--- a/scripts/io/textscan.m
+++ b/scripts/io/textscan.m
@@ -327,78 +327,78 @@ endfunction
 %! fmt = "%f miles/hr = %f kilometers/hr";
 %! c = textscan (str, fmt);
 %! assert (b(1,:)', c{1}, 1e-5);
 %! assert (b(2,:)', c{2}, 1e-5);
 
 %!test
 %! str = "13, 72, NA, str1, 25\r\n// Middle line\r\n36, na, 05, str3, 6";
 %! a = textscan (str, "%d %n %f %s %n", "delimiter", ",","treatAsEmpty", {"NA", "na"},"commentStyle", "//");
-%! assert (a{1}, int32([13; 36]));
+%! assert (a{1}, int32 ([13; 36]));
 %! assert (a{2}, [72; NaN]);
 %! assert (a{3}, [NaN; 5]);
 %! assert (a{4}, {"str1"; "str3"});
 %! assert (a{5}, [25; 6]);
 
 %!test
 %! str = "Km:10 = hhhBjjj miles16hour\r\n";
 %! str = [str "Km:15 = hhhJjjj miles241hour\r\n"];
 %! str = [str "Km:2 = hhhRjjj miles3hour\r\n"];
 %! str = [str "Km:25 = hhhZ\r\n"];
 %! fmt = "Km:%d = hhh%1sjjj miles%dhour";
 %! a = textscan (str, fmt, "delimiter", " ");
-%! assert (a{1}', int32([10 15 2 25]));
+%! assert (a{1}', int32 ([10 15 2 25]));
 %! assert (a{2}', {'B' 'J' 'R' 'Z'});
-%! assert (a{3}', int32([16 241 3 0]));
+%! assert (a{3}', int32 ([16 241 3 0]));
 
 %% Test with default endofline parameter
 %!test
 %! c = textscan ("L1\nL2", "%s");
 %! assert (c{:}, {"L1"; "L2"});
 
 %% Test with endofline parameter set to "" (empty) - newline should be in word
 %!test
 %! c = textscan ("L1\nL2", "%s", "endofline", "");
-%! assert (int8(c{:}{:}), int8([ 76,  49,  10,  76,  50 ]));
+%! assert (int8 (c{:}{:}), int8 ([ 76,  49,  10,  76,  50 ]));
 
 %!test
 %! # No delimiters at all besides EOL.  Skip fields, even empty fields
 %! str = "Text1Text2Text\nTextText4Text\nText57Text";
 %! c = textscan (str, "Text%*dText%dText");
 %! assert (c{1}, int32 ([2; 4; 0]));
 
 %!test
 %% CollectOutput test
 %! b = [10:10:100];
 %! b = [b; 8*b/5; 8*b*1000/5];
 %! str = sprintf ("%g miles/hr = %g (%g) kilometers (meters)/hr\n", b);
 %! fmt = "%f miles%s %s %f (%f) kilometers %*s";
 %! c = textscan (str, fmt, "collectoutput", 1);
-%! assert (size(c{3}), [10, 2]);
-%! assert (size(c{2}), [10, 2]);
+%! assert (size (c{3}), [10, 2]);
+%! assert (size (c{2}), [10, 2]);
 
 %!test
 %% CollectOutput test with uneven column length files
 %! b = [10:10:100];
 %! b = [b; 8*b/5; 8*b*1000/5];
 %! str = sprintf ("%g miles/hr = %g (%g) kilometers (meters)/hr\n", b);
 %! str = [str "110 miles/hr"];
 %! fmt = "%f miles%s %s %f (%f) kilometers %*s";
 %! c = textscan (str, fmt, "collectoutput", 1);
-%! assert (size(c{1}), [11, 1]);
-%! assert (size(c{3}), [11, 2]);
-%! assert (size(c{2}), [11, 2]);
+%! assert (size (c{1}), [11, 1]);
+%! assert (size (c{3}), [11, 2]);
+%! assert (size (c{2}), [11, 2]);
 %! assert (c{3}(end), NaN);
 %! assert (c{2}{11, 1}, "/hr");
 %! assert (isempty (c{2}{11, 2}), true);
 
 %% Test input validation
 %!error textscan ()
 %!error textscan (single (4))
 %!error textscan ({4})
 %!error <must be a string> textscan ("Hello World", 2)
 %!error <cannot provide position information> [C, pos] = textscan ("Hello World")
 %!error <character value required> textscan ("Hello World", '%s', 'EndOfLine', 3)
 
 %! Test incomplete first data line
 %! R = textscan (['Empty1' char(10)], 'Empty%d %f');
-%! assert (R{1}, int32(1));
-%! assert (isempty(R{2}), true);
+%! assert (R{1}, int32 (1));
+%! assert (isempty (R{2}), true);
diff --git a/scripts/linear-algebra/housh.m b/scripts/linear-algebra/housh.m
--- a/scripts/linear-algebra/housh.m
+++ b/scripts/linear-algebra/housh.m
@@ -18,18 +18,18 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{housv}, @var{beta}, @var{zer}] =} housh (@var{x}, @var{j}, @var{z})
 ## Compute Householder reflection vector @var{housv} to reflect @var{x}
 ## to be the j-th column of identity, i.e.,
 ##
 ## @example
 ## @group
-## (I - beta*housv*housv')x =  norm(x)*e(j) if x(j) < 0,
-## (I - beta*housv*housv')x = -norm(x)*e(j) if x(j) >= 0
+## (I - beta*housv*housv')x =  norm (x)*e(j) if x(j) < 0,
+## (I - beta*housv*housv')x = -norm (x)*e(j) if x(j) >= 0
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## Inputs
 ##
 ## @table @var
 ## @item x
@@ -61,17 +61,17 @@ function [housv, beta, zer] = housh (x, 
 
   if (nargin != 3)
     print_usage ();
   endif
 
   ## Check for valid inputs.
   if (! isvector (x) && ! isscalar (x))
     error ("housh: first input must be a vector");
-  elseif (! isscalar(j))
+  elseif (! isscalar (j))
     error ("housh: second argment must be an integer scalar");
   else
     housv = x;
     m = max (abs (housv));
     if (m != 0.0)
       housv = housv / m;
       alpha = norm (housv);
       if (alpha > z)
diff --git a/scripts/linear-algebra/ishermitian.m b/scripts/linear-algebra/ishermitian.m
--- a/scripts/linear-algebra/ishermitian.m
+++ b/scripts/linear-algebra/ishermitian.m
@@ -58,13 +58,13 @@ endfunction
 %!assert (! ishermitian ("test"))
 %!assert (ishermitian ([1, 2.1; 2, 1.1], 0.2))
 %!assert (ishermitian ([1, -2i; 2i, 1]))
 %!assert (! ishermitian ("t"))
 %!assert (! ishermitian (["te"; "et"]))
 
 %!test
 %! s.a = 1;
-%! assert(! ishermitian (s));
+%! assert (! ishermitian (s));
 
 %!error ishermitian ([1, 2; 2, 1], 0, 0)
 %!error ishermitian ()
 
diff --git a/scripts/linear-algebra/issymmetric.m b/scripts/linear-algebra/issymmetric.m
--- a/scripts/linear-algebra/issymmetric.m
+++ b/scripts/linear-algebra/issymmetric.m
@@ -57,13 +57,13 @@ endfunction
 %!assert (! (issymmetric ("test")))
 %!assert (issymmetric ([1, 2.1; 2, 1.1], 0.2))
 %!assert (issymmetric ([1, 2i; 2i, 1]))
 %!assert (! (issymmetric ("t")))
 %!assert (! (issymmetric (["te"; "et"])))
 
 %!test
 %! s.a = 1;
-%! assert(! issymmetric (s));
+%! assert (! issymmetric (s));
 
 %!error issymmetric ([1, 2; 2, 1], 0, 0)
 %!error issymmetric ()
 
diff --git a/scripts/linear-algebra/krylov.m b/scripts/linear-algebra/krylov.m
--- a/scripts/linear-algebra/krylov.m
+++ b/scripts/linear-algebra/krylov.m
@@ -29,17 +29,17 @@
 ##
 ## If @var{V} is a vector, then @var{h} contains the Hessenberg matrix
 ## such that @nospell{@xcode{a*u == u*h+rk*ek'}}, in which @code{rk =
 ## a*u(:,k)-u*h(:,k)}, and @nospell{@xcode{ek'}} is the vector
 ## @code{[0, 0, @dots{}, 1]} of length @code{k}.  Otherwise, @var{h} is
 ## meaningless.
 ##
 ## If @var{V} is a vector and @var{k} is greater than
-## @code{length(A)-1}, then @var{h} contains the Hessenberg matrix such
+## @code{length (A) - 1}, then @var{h} contains the Hessenberg matrix such
 ## that @code{a*u == u*h}.
 ##
 ## The value of @var{nu} is the dimension of the span of the Krylov
 ## subspace (based on @var{eps1}).
 ##
 ## If @var{b} is a vector and @var{k} is greater than @var{m-1}, then
 ## @var{h} contains the Hessenberg decomposition of @var{A}.
 ##
@@ -66,17 +66,17 @@ function [Uret, H, nu] = krylov (A, V, k
 
   if (nargin < 3 || nargin > 5)
     print_usage ();
   elseif (nargin < 5)
     ## Default permutation flag.
     pflg = 0;
   endif
 
-  if(nargin < 4)
+  if (nargin < 4)
     ## Default tolerance parameter.
     eps1 = defeps;
   endif
 
   if (isempty (eps1))
     eps1 = defeps;
   endif
 
@@ -110,24 +110,24 @@ function [Uret, H, nu] = krylov (A, V, k
   zidx = find (abm == 0);
 
   ## Set up vector of pivot points.
   pivot_vec = 1:na;
 
   iter = 0;
   alpha = [];
   nh = 0;
-  while (length(alpha) < na) && (columns(V) > 0) && (iter < k)
+  while (length (alpha) < na) && (columns (V) > 0) && (iter < k)
     iter++;
 
     ## Get orthogonal basis of V.
     jj = 1;
     while (jj <= columns (V) && length (alpha) < na)
       ## Index of next Householder reflection.
-      nu = length(alpha)+1;
+      nu = length (alpha)+1;
 
       short_pv = pivot_vec(nu:na);
       q = V(:,jj);
       short_q = q(short_pv);
 
       if (norm (short_q) < eps1)
         ## Insignificant column; delete.
         nv = columns (V);
diff --git a/scripts/linear-algebra/logm.m b/scripts/linear-algebra/logm.m
--- a/scripts/linear-algebra/logm.m
+++ b/scripts/linear-algebra/logm.m
@@ -99,17 +99,17 @@ function [s, iters] = logm (A, opt_iters
 
   if (m > 1)
     s = logm_pade_pf (s, m);
   endif
 
   s = 2^k * u * s * u';
 
   ## Remove small complex values (O(eps)) which may have entered calculation
-  if (real_eig && isreal(A))
+  if (real_eig && isreal (A))
     s = real (s);
   endif
 
   if (nargout == 2)
     iters = k;
   endif
 
 endfunction
diff --git a/scripts/linear-algebra/null.m b/scripts/linear-algebra/null.m
--- a/scripts/linear-algebra/null.m
+++ b/scripts/linear-algebra/null.m
@@ -62,19 +62,19 @@ function retval = null (A, tol)
       print_usage ();
     endif
 
     rank = sum (s > tol);
 
     if (rank < cols)
       retval = V (:, rank+1:cols);
       if (isa (A, "single"))
-        retval(abs (retval) < eps ("single")) = 0;
+        retval (abs (retval) < eps ("single")) = 0;
       else
-        retval(abs (retval) < eps) = 0;
+        retval (abs (retval) < eps) = 0;
       endif
     else
       retval = zeros (cols, 0);
     endif
   endif
 
 endfunction
 
diff --git a/scripts/linear-algebra/rref.m b/scripts/linear-algebra/rref.m
--- a/scripts/linear-algebra/rref.m
+++ b/scripts/linear-algebra/rref.m
@@ -57,30 +57,30 @@ function [A, k] = rref (A, tol)
   for c = 1:cols
     ## Find the pivot row
     [m, pivot] = max (abs (A(r:rows,c)));
     pivot = r + pivot - 1;
 
     if (m <= tol)
       ## Skip column c, making sure the approximately zero terms are
       ## actually zero.
-      A (r:rows, c) = zeros (rows-r+1, 1);
+      A(r:rows, c) = zeros (rows-r+1, 1);
     else
       ## keep track of bound variables
       used (1, c) = 1;
 
       ## Swap current row and pivot row
-      A ([pivot, r], c:cols) = A ([r, pivot], c:cols);
+      A([pivot, r], c:cols) = A([r, pivot], c:cols);
 
       ## Normalize pivot row
-      A (r, c:cols) = A (r, c:cols) / A (r, c);
+      A(r, c:cols) = A(r, c:cols) / A(r, c);
 
       ## Eliminate the current column
       ridx = [1:r-1, r+1:rows];
-      A (ridx, c:cols) = A (ridx, c:cols) - A (ridx, c) * A(r, c:cols);
+      A(ridx, c:cols) = A(ridx, c:cols) - A(ridx, c) * A(r, c:cols);
 
       ## Check if done
       if (r++ == rows)
         break;
       endif
     endif
   endfor
   k = find (used);
diff --git a/scripts/miscellaneous/compare_versions.m b/scripts/miscellaneous/compare_versions.m
--- a/scripts/miscellaneous/compare_versions.m
+++ b/scripts/miscellaneous/compare_versions.m
@@ -61,18 +61,18 @@
 ## @item
 ## "~="
 ## not equal
 ## @end itemize
 ##
 ## Note that version "1.1-test2" will compare as greater than
 ## "1.1-test10".  Also, since the numeric part is compared first, "a"
 ## compares less than "1a" because the second string starts with a
-## numeric part even though @code{double("a")} is greater than
-## @code{double("1").}
+## numeric part even though @code{double ("a")} is greater than
+## @code{double ("1").}
 ## @end deftypefn
 
 ## Author: Bill Denney <denney@seas.upenn.edu>
 
 function out = compare_versions (v1, v2, operator)
 
   if (nargin != 3)
     print_usage ();
@@ -84,43 +84,43 @@ function out = compare_versions (v1, v2,
   elseif (rows (v1) != 1 || rows (v2) != 1)
     error ("compare_versions: version numbers must be a single row");
   endif
 
   ## check and make sure that the operator is valid
   if (! ischar (operator))
     error ("compare_versions: OPERATOR must be a character string");
   elseif (numel (operator) > 2)
-    error("compare_versions: OPERATOR must be 1 or 2 characters long");
+    error ("compare_versions: OPERATOR must be 1 or 2 characters long");
   endif
 
   ## trim off any character data that is not part of a normal version
   ## number
   numbers = "0123456789.";
 
   v1firstchar = find (! ismember (v1, numbers), 1);
   v2firstchar = find (! ismember (v2, numbers), 1);
   if (! isempty (v1firstchar))
-    v1c = v1(v1firstchar:length(v1));
+    v1c = v1(v1firstchar:length (v1));
     v1nochar = v1(1:v1firstchar-1);
   else
     v1c = "";
     v1nochar = v1;
   endif
   if (! isempty (v2firstchar))
-    v2c = v2(v2firstchar:length(v2));
+    v2c = v2(v2firstchar:length (v2));
     v2nochar = v2(1:v2firstchar-1);
   else
     v2c = "";
     v2nochar = v2;
   endif
 
   v1n = str2num (char (strsplit (v1nochar, ".")));
   v2n = str2num (char (strsplit (v2nochar, ".")));
-  if ((isempty (v1n) && isempty (v1c)) || (isempty (v2n) && isempty(v2c)))
+  if ((isempty (v1n) && isempty (v1c)) || (isempty (v2n) && isempty (v2c)))
     error ("compare_versions: given version strings are not valid: %s %s",
            v1, v2);
   endif
 
   ## Assume that any additional elements would be 0 if one is longer
   ## than the other.
   maxnumlen = max ([length(v1n) length(v2n)]);
   if (length (v1n) < maxnumlen)
diff --git a/scripts/miscellaneous/copyfile.m b/scripts/miscellaneous/copyfile.m
--- a/scripts/miscellaneous/copyfile.m
+++ b/scripts/miscellaneous/copyfile.m
@@ -67,34 +67,34 @@ function [status, msg, msgid] = copyfile
 
     ## If f1 isn't a cellstr convert it to one.
     if (ischar (f1))
       f1 = cellstr (f1);
     endif
 
     ## If f1 has more than 1 element f2 must be a directory
     isdir = (exist (f2, "dir") != 0);
-    if (length(f1) > 1 && ! isdir)
+    if (length (f1) > 1 && ! isdir)
       error ("copyfile: when copying multiple files, second argument must be a directory");
     endif
 
     ## Protect the file name(s).
     f1 = glob (f1);
     if (isempty (f1))
       error ("copyfile: no files to move");
     endif
     p1 = sprintf ("\"%s\" ", f1{:});
     p2 = tilde_expand (f2);
 
-    if (isdir && length(p1) > max_cmd_line)
-      l2 = length(p2) + length (cmd) + 6;
-      while (! isempty(f1))
+    if (isdir && length (p1) > max_cmd_line)
+      l2 = length (p2) + length (cmd) + 6;
+      while (! isempty (f1))
         p1 = sprintf ("\"%s\" ", f1{1});
         f1(1) = [];
-        while (!isempty (f1) && (length(p1) + length(f1{1}) + l2 <
+        while (!isempty (f1) && (length (p1) + length (f1{1}) + l2 <
                                  max_cmd_line))
           p1 = sprintf ("%s\"%s\" ", p1, f1{1});
           f1(1) = [];
         endwhile
 
         if (ispc () && ! isunix ()
             && ! isempty (file_in_path (getenv ("PATH"), "cp.exe")))
           p1 = strrep (p1, "\\", "/");
diff --git a/scripts/miscellaneous/dump_prefs.m b/scripts/miscellaneous/dump_prefs.m
--- a/scripts/miscellaneous/dump_prefs.m
+++ b/scripts/miscellaneous/dump_prefs.m
@@ -77,17 +77,17 @@ function dump_prefs (file)
               "sighup_dumps_octave_core";
               "sigterm_dumps_octave_core";
               "silent_functions";
               "split_long_rows";
               "string_fill_char";
               "struct_levels_to_print";
               "suppress_verbose_help_message"];
 
-  for i = 1:rows(sym_list)
+  for i = 1:rows (sym_list)
     sym = deblank (sym_list(i,:));
     try
       val = feval (sym);
       if (isnumeric (val))
         val = sprintf ("%g", val);
       endif
       fprintf (file, "  %s = %s\n", sym, val);
     catch
diff --git a/scripts/miscellaneous/edit.m b/scripts/miscellaneous/edit.m
--- a/scripts/miscellaneous/edit.m
+++ b/scripts/miscellaneous/edit.m
@@ -67,17 +67,17 @@
 ## containing all fields and values.  Thus, @code{edit get all} returns
 ## a complete control structure.
 ## The following control fields are used:
 ##
 ## @table @samp
 ## @item editor
 ## This is the editor to use to modify the functions.  By default it uses
 ## Octave's @env{EDITOR} built-in function, which comes from
-## @code{getenv("EDITOR")} and defaults to @code{emacs}.  Use @code{%s}
+## @code{getenv ("EDITOR")} and defaults to @code{emacs}.  Use @code{%s}
 ## In place of the function name.  For example,
 ##
 ## @table @samp
 ## @item [EDITOR, " %s"]
 ## Use the editor which Octave uses for @code{edit_history}.
 ##
 ## @item "xedit %s &"
 ## pop up simple X11 editor in a separate window
@@ -174,31 +174,31 @@ function ret = edit (file, state)
     case "EMAIL"
       FUNCTION.EMAIL = state;
     case "LICENSE"
       FUNCTION.LICENSE = state;
     case "MODE"
       if (strcmp (state, "sync") || strcmp (state, "async"))
         FUNCTION.MODE = state;
       else
-        error('edit: expected "edit MODE sync|async"');
+        error ('edit: expected "edit MODE sync|async"');
       endif
     case "EDITINPLACE"
       if (ischar (state))
         if (strcmpi (state, "true"))
           state = true;
         elseif (strcmpi (state, "false"))
           state = false;
         else
           state = eval (state);
         endif
       endif
       FUNCTION.EDITINPLACE = state;
     case "GET"
-      if (isfield (FUNCTION, toupper(state)))
+      if (isfield (FUNCTION, toupper (state)))
         ret = FUNCTION.(toupper (state));
       else
         ret = FUNCTION;
       endif
     otherwise
       error ('edit: expected "edit EDITOR|HOME|AUTHOR|EMAIL|LICENSE|MODE val"');
     endswitch
     return
@@ -255,25 +255,25 @@ function ret = edit (file, state)
       ## No ".cc" at the end of the file, add to the list.
       filelist{end+1} = cat (2, file, ".cc");
     endif
   endif
 
   ## If the file includes a path, it may be an overloaded function.
   if (! strcmp (file, "@") && index (file, filesep))
     ## No "@" at the beginning of the file, add to the list.
-    numfiles = numel(filelist);
+    numfiles = numel (filelist);
     for n = 1:numfiles
       filelist{n+numfiles} = cat (2, "@", filelist{n});
     endfor
   endif
 
   ## Search the entire path for the 1st instance of a file in the list.
   fileandpath = "";
-  for n = 1:numel(filelist)
+  for n = 1:numel (filelist)
     filetoedit = file_in_path (path, filelist{n});
     if (! isempty (filetoedit))
       ## The path is explicitly included.
       fileandpath = filetoedit;
       break;
     endif
   endfor
 
@@ -319,17 +319,17 @@ function ret = edit (file, state)
       return;
   endswitch
 
   ## The file doesn't exist in path so create it, put in the function
   ## template and edit it.
 
   ## Guess the email name if it was not given.
   if (isempty (FUNCTION.EMAIL))
-    host = getenv("HOSTNAME");
+    host = getenv ("HOSTNAME");
     if (isempty (host) && ispc ())
       host = getenv ("COMPUTERNAME");
     endif
     if (isempty (host))
       [status, host] = system ("uname -n");
       ## trim newline from end of hostname
       if (! isempty (host))
         host = host(1:end-1);
@@ -438,21 +438,21 @@ SUCH DAMAGE.\
       ## code.
       if (any (exists == [2, 103]))
         body = type (name){1};
       else
         body = cstrcat ("function [ ret ] = ", name, " ()\n\nendfunction\n");
       endif
       if (isempty (head))
         comment = cstrcat ("## ", name, "\n\n",
-                          "## ", strrep (tail, "\n", "\n## "), "\n\n");
+                           "## ", strrep (tail, "\n", "\n## "), "\n\n");
       else
-        comment = cstrcat ("## ", strrep(head,"\n","\n## "), "\n\n", ...
-                          "## ", name, "\n\n", ...
-                          "## ", strrep (tail, "\n", "\n## "), "\n\n");
+        comment = cstrcat ("## ", strrep (head,"\n","\n## "), "\n\n", ...
+                           "## ", name, "\n\n", ...
+                           "## ", strrep (tail, "\n", "\n## "), "\n\n");
       endif
       text = cstrcat (comment, body);
   endswitch
 
   ## Write the initial file (if there is anything to write)
   fid = fopen (fileandpath, "wt");
   if (fid < 0)
     error ("edit: could not create %s", fileandpath);
diff --git a/scripts/miscellaneous/fileparts.m b/scripts/miscellaneous/fileparts.m
--- a/scripts/miscellaneous/fileparts.m
+++ b/scripts/miscellaneous/fileparts.m
@@ -29,17 +29,17 @@ function [directory, name, extension, ve
     if (ischar (filename))
       ds = strchr (filename, filesep ("all"), 1, "last");
       if (isempty (ds))
         ds = 0;
       endif
       es = rindex (filename, ".");
       ## These can be the same if they are both 0 (no dir or ext).
       if (es <= ds)
-        es = length(filename)+1;
+        es = length (filename)+1;
       endif
       if (ds == 0)
         directory = "";
       elseif (ds == 1)
         directory = filename(1);
       else
         directory = filename(1:ds-1);
       endif
diff --git a/scripts/miscellaneous/getappdata.m b/scripts/miscellaneous/getappdata.m
--- a/scripts/miscellaneous/getappdata.m
+++ b/scripts/miscellaneous/getappdata.m
@@ -28,17 +28,17 @@
 
 function val = getappdata (h, name)
 
   if (all (ishandle (h)) && nargin == 2 && ischar (name))
     ## FIXME - Is there a better way to handle non-existent appdata
     ## and missing fields?
     val = cell (numel (h), 1);
     appdata = struct ();
-    for nh = 1:numel(h)
+    for nh = 1:numel (h)
       try
         appdata = get (h(nh), "__appdata__");
       end_try_catch
       if (! isfield (appdata, name))
         appdata.(name) = [];
       endif
       val(nh) = {appdata.(name)};
     endfor
diff --git a/scripts/miscellaneous/isappdata.m b/scripts/miscellaneous/isappdata.m
--- a/scripts/miscellaneous/isappdata.m
+++ b/scripts/miscellaneous/isappdata.m
@@ -25,17 +25,17 @@
 ## Created: 2010-07-15
 
 function res = isappdata (h, name)
 
   if (! (all (ishandle (h)) && ischar (name)))
     error ("isappdata: invalid input");
   endif
 
-  for nh = 1:numel(h)
+  for nh = 1:numel (h)
     data = get (h(nh));
     if (isfield (data, "__appdata__") && isfield (data.__appdata__, name))
       res(nh) = true;
     else
       res(nh) = false;
     endif
   endfor
 
diff --git a/scripts/miscellaneous/movefile.m b/scripts/miscellaneous/movefile.m
--- a/scripts/miscellaneous/movefile.m
+++ b/scripts/miscellaneous/movefile.m
@@ -67,34 +67,34 @@ function [status, msg, msgid] = movefile
 
     ## If f1 isn't a cellstr convert it to one.
     if (ischar (f1))
       f1 = cellstr (f1);
     endif
 
     ## If f1 has more than 1 element f2 must be a directory
     isdir = (exist (f2, "dir") != 0);
-    if (length(f1) > 1 && ! isdir)
+    if (length (f1) > 1 && ! isdir)
       error ("movefile: when moving multiple files, second argument must be a directory");
     endif
 
     ## Protect the file name(s).
     f1 = glob (f1);
     if (isempty (f1))
       error ("movefile: no files to move");
     endif
     p1 = sprintf ("\"%s\" ", f1{:});
     p2 = tilde_expand (f2);
 
-    if (isdir && length(p1) > max_cmd_line)
-      l2 = length(p2) + length (cmd) + 6;
-      while (! isempty(f1))
+    if (isdir && length (p1) > max_cmd_line)
+      l2 = length (p2) + length (cmd) + 6;
+      while (! isempty (f1))
         p1 = sprintf ("\"%s\" ", f1{1});
         f1(1) = [];
-        while (!isempty (f1) && (length(p1) + length(f1{1}) + l2 <
+        while (!isempty (f1) && (length (p1) + length (f1{1}) + l2 <
                                  max_cmd_line))
           p1 = sprintf ("%s\"%s\" ", p1, f1{1});
           f1(1) = [];
         endwhile
 
         if (ispc () && ! isunix ()
             && ! isempty (file_in_path (getenv ("PATH"), "cp.exe")))
           p1 = strrep (p1, "\\", "/");
diff --git a/scripts/miscellaneous/orderfields.m b/scripts/miscellaneous/orderfields.m
--- a/scripts/miscellaneous/orderfields.m
+++ b/scripts/miscellaneous/orderfields.m
@@ -32,28 +32,28 @@
 ## The optional second output argument @var{p} is assigned the permutation
 ## vector
 ## which converts the original name order into the new name order.
 ##
 ## Examples:
 ##
 ## @example
 ## @group
-## s = struct("d", 4, "b", 2, "a", 1, "c", 3);
+## s = struct ("d", 4, "b", 2, "a", 1, "c", 3);
 ## t1 = orderfields (s)
 ##      @result{} t1 =
 ##         @{
 ##           a =  1
 ##           b =  2
 ##           c =  3
 ##           d =  4
 ##         @}
 ## @end group
 ## @group
-## t = struct("d", @{@}, "c", @{@}, "b", "a", @{@});
+## t = struct ("d", @{@}, "c", @{@}, "b", "a", @{@});
 ## t2 = orderfields (s, t)
 ##      @result{} t2 =
 ##         @{
 ##           d =  4
 ##           c =  3
 ##           b =  2
 ##           a =  1
 ##         @}
diff --git a/scripts/miscellaneous/parseparams.m b/scripts/miscellaneous/parseparams.m
--- a/scripts/miscellaneous/parseparams.m
+++ b/scripts/miscellaneous/parseparams.m
@@ -83,17 +83,17 @@ function [reg, varargout] = parseparams 
     varargout = defaults;
     if (i)
       ## Let's parse the properties.
       pnames = prop(1:2:end);
       values = prop(2:2:end);
       if (! size_equal (pnames, values) || ! all (strs(i:2:end)))
         error_as_caller ("options must be given as name-value pairs");
       endif
-      idx = lookup (toupper(names), toupper(pnames), "m");
+      idx = lookup (toupper (names), toupper (pnames), "m");
       if (! all (idx))
         error_as_caller ("unrecognized option: %s", pnames{find (idx == 0, 1)});
       else
         varargout(sidx(idx)) = values;
       endif
     endif
   endif
 
diff --git a/scripts/miscellaneous/private/__xzip__.m b/scripts/miscellaneous/private/__xzip__.m
--- a/scripts/miscellaneous/private/__xzip__.m
+++ b/scripts/miscellaneous/private/__xzip__.m
@@ -57,23 +57,23 @@ function entries = __xzip__ (commandname
     mkdir (outdir);
   endif
 
   cwd = pwd ();
   unwind_protect
     files = glob (files);
 
     ## Ignore any file with the compress extension
-    files(cellfun (@(x) length(x) > length(extension)
-      && strcmp (x((end - length(extension) + 1):end), extension),
+    files(cellfun (@(x) length (x) > length (extension)
+      && strcmp (x((end - length (extension) + 1):end), extension),
       files)) = [];
 
     copyfile (files, outdir);
 
-    [d, f] = myfileparts(files);
+    [d, f] = myfileparts (files);
 
     cd (outdir);
 
     cmd = sprintf (commandtemplate, sprintf (" %s", f{:}));
 
     [status, output] = system (cmd);
     if (status)
       error ("__xzip__: %s command failed with exit status = %d",
@@ -82,22 +82,22 @@ function entries = __xzip__ (commandname
 
     if (nargin == 5)
       if (nargout > 0)
         entries = cellfun(
             @(x) fullfile (outdir, sprintf ("%s.%s", x, extension)),
             f, "uniformoutput", false);
       endif
     else
-      movefile (cellfun(@(x) sprintf ("%s.%s", x, extension), f,
+      movefile (cellfun (@(x) sprintf ("%s.%s", x, extension), f,
                         "uniformoutput", false), cwd);
       if (nargout > 0)
         ## FIXME this does not work when you try to compress directories
-        entries  = cellfun(@(x) sprintf ("%s.%s", x, extension),
-                           files, "uniformoutput", false);
+        entries  = cellfun (@(x) sprintf ("%s.%s", x, extension),
+                            files, "uniformoutput", false);
       endif
     endif
 
   unwind_protect_cleanup
     cd (cwd);
     if (nargin == 4)
       confirm_recursive_rmdir (false, "local");
       rmdir (outdir, "s");
@@ -114,25 +114,25 @@ function [d, f] = myfileparts (files)
   d(idx) = "";
   f(idx) = files(idx);
 endfunction
 
 ## FIXME -- reinstate these tests if we invent a way to test private
 ## functions directly.
 ##
 ## %!error <extension has to be a string with finite length>
-## %!  __xzip__("gzip", "", "gzip -r %s", "bla");
+## %!  __xzip__ ("gzip", "", "gzip -r %s", "bla");
 ## %!error <no files to move>
-## %!  __xzip__("gzip", ".gz", "gzip -r %s", tmpnam);
+## %!  __xzip__ ("gzip", ".gz", "gzip -r %s", tmpnam);
 ## %!error <command failed with exit status>
 ## %!  # test __xzip__ with invalid compression command
 ## %!  unwind_protect
 ## %!    filename = tmpnam;
 ## %!    dummy    = 1;
-## %!    save(filename, "dummy");
+## %!    save (filename, "dummy");
 ## %!    dirname  = tmpnam;
-## %!    mkdir(dirname);
-## %!    entry = __xzip__("gzip", ".gz", "xxxzipxxx -r %s 2>/dev/null",
+## %!    mkdir (dirname);
+## %!    entry = __xzip__ ("gzip", ".gz", "xxxzipxxx -r %s 2>/dev/null",
 ## %!                     filename, dirname);
 ## %!  unwind_protect_cleanup
-## %!    delete(filename);
-## %!    rmdir(dirname);
+## %!    delete (filename);
+## %!    rmdir (dirname);
 ## %!  end_unwind_protect
diff --git a/scripts/miscellaneous/rmappdata.m b/scripts/miscellaneous/rmappdata.m
--- a/scripts/miscellaneous/rmappdata.m
+++ b/scripts/miscellaneous/rmappdata.m
@@ -24,17 +24,17 @@
 ## Created: 2010-07-15
 
 function rmappdata (h, varargin)
 
   if (! (all (ishandle (h)) && iscellstr (varargin)))
     error ("rmappdata: invalid input");
   endif
 
-  for nh = 1:numel(h)
+  for nh = 1:numel (h)
     appdata = get (h(nh), "__appdata__");
     appdata = rmfield (appdata, varargin);
     set (h(nh), "__appdata__", appdata);
   endfor
 
 endfunction
 
 
diff --git a/scripts/miscellaneous/setappdata.m b/scripts/miscellaneous/setappdata.m
--- a/scripts/miscellaneous/setappdata.m
+++ b/scripts/miscellaneous/setappdata.m
@@ -25,22 +25,22 @@
 ## Created: 2010-07-15
 
 function setappdata (h, varargin)
 
   if (! (all (ishandle (h)) && mod (numel (varargin), 2) == 0))
     error ("setappdata: invalid input");
   endif
 
-  for nh = 1:numel(h)
+  for nh = 1:numel (h)
     if (! isfield (get (h(nh)), "__appdata__"))
       addproperty ("__appdata__", h(nh), "any", struct ());
     endif
     appdata = get (h(nh), "__appdata__");
-    for narg = 1:2:numel(varargin)
+    for narg = 1:2:numel (varargin)
       if (iscellstr (varargin{narg}))
         ## Handle cell arrays like set() does.
         set (h(nh), "__appdata__", appdata);
         setappdata (h(nh), vertcat (varargin{narg}', varargin{narg+1}'){:});
         appdata = get (h(nh), "__appdata__");
       elseif (ischar (varargin{narg}))
         appdata.(varargin{narg}) = varargin{narg+1};
       else
diff --git a/scripts/miscellaneous/swapbytes.m b/scripts/miscellaneous/swapbytes.m
--- a/scripts/miscellaneous/swapbytes.m
+++ b/scripts/miscellaneous/swapbytes.m
@@ -47,17 +47,17 @@ function y = swapbytes (x)
       nb = 4;
     elseif (strcmp (clx, "int64") || strcmp (clx, "uint64")
             || strcmp (clx, "double"))
       nb = 8;
     else
       error ("swapbytes: invalid class of object");
     endif
     y = reshape (typecast (reshape (typecast (x(:), "uint8"), nb, numel (x))
-                           ([nb : -1 : 1], :) (:), clx), size(x));
+                           ([nb : -1 : 1], :) (:), clx), size (x));
   endif
 
 endfunction
 
 
 %!assert (double (swapbytes (uint16 (1:4))), [256 512 768 1024])
 %!error (swapbytes ())
 %!error (swapbytes (1, 2))
diff --git a/scripts/miscellaneous/unpack.m b/scripts/miscellaneous/unpack.m
--- a/scripts/miscellaneous/unpack.m
+++ b/scripts/miscellaneous/unpack.m
@@ -34,17 +34,17 @@
 
 function filelist = unpack (file, dir = ".", filetype = "")
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
   endif
 
   if (! ischar (file) && ! iscellstr (file))
-    error ("unpack: invalid input file class, %s", class(file));
+    error ("unpack: invalid input file class, %s", class (file));
   endif
 
   ## character arrays of more than one string must be treated as cell strings
   if (ischar (file) && ! isvector (file))
     file = cellstr (file);
   endif
 
   ## Recursively unpack cellstr arrays one file at a time
@@ -219,17 +219,17 @@ function filelist = unpack (file, dir = 
 endfunction
 
 function files = __parse_zip__ (output)
   ## Parse the output from zip and unzip.
 
   ## Skip first line which is Archive header
   output(1) = [];
   for i = 1:length (output)
-    files{i} = output{i}(14:length(output{i}));
+    files{i} = output{i}(14:length (output{i}));
   endfor
 endfunction
 
 function output = __parse_tar__ (output)
   ## This is a noop, but it makes things simpler for other cases.
 endfunction
 
 function files = __parse_gzip__ (output)
@@ -241,17 +241,17 @@ function files = __parse_gzip__ (output)
   ## the filename.
   for i = 1:length (output)
     colons = strfind (output{i}, ":");
     if (isempty (colons))
       warning ("unpack:parsing",
                "Unable to parse line (gzip missing colon):\n%s", output{i});
     else
       midcolon = colons(ceil (length (colons)/2));
-      thisstr = output{i}(midcolon+2:length(output{i}));
+      thisstr = output{i}(midcolon+2:length (output{i}));
       idx = index (thisstr, "with") + 5;
       if (isempty (idx))
         warning ("unpack:parsing",
                  "Unable to parse line (gzip missing with):\n%s", output{i});
       else
         files{i} = thisstr(idx:length (thisstr));
       endif
     endif
diff --git a/scripts/miscellaneous/ver.m b/scripts/miscellaneous/ver.m
--- a/scripts/miscellaneous/ver.m
+++ b/scripts/miscellaneous/ver.m
@@ -89,17 +89,17 @@ function varargout = ver (package = "")
                         ver_line2, octave_license, ver_line3, os_string, hbar);
 
     puts (ver_desc);
 
     pkg ("list");
   else
     if (! isempty (package))
       n = [];
-      for r = 1:numel(ret)
+      for r = 1:numel (ret)
         if (strcmpi (ret(r).Name, package))
           n = r;
           break;
         endif
       endfor
       ret = ret(n);
     endif
     varargout{1} = ret;
diff --git a/scripts/optimization/fminbnd.m b/scripts/optimization/fminbnd.m
--- a/scripts/optimization/fminbnd.m
+++ b/scripts/optimization/fminbnd.m
@@ -83,29 +83,29 @@ function [x, fval, info, output] = fminb
   endif
 
   ## The default exit flag if exceeded number of iterations.
   info = 0;
   niter = 0;
   nfev = 0;
   sqrteps = eps (class (xmin + xmax));
 
-  c = 0.5*(3-sqrt(5));
+  c = 0.5*(3 - sqrt (5));
   a = xmin; b = xmax;
   v = a + c*(b-a);
   w = x = v;
   e = 0;
   fv = fw = fval = fun (x);
   nfev++;
 
   while (niter < maxiter && nfev < maxfev)
     xm = 0.5*(a+b);
-    ## FIXME: the golden section search can actually get closer than sqrt(eps)...
-    ## sometimes. Sometimes not, it depends on the function. This is the strategy
-    ## from the Netlib code. Something yet smarter would be good.
+    ## FIXME: the golden section search can actually get closer than sqrt(eps)
+    ## sometimes.  Sometimes not, it depends on the function.  This is the
+    ## strategy from the Netlib code.  Something yet smarter would be good.
     tol = 2 * sqrteps * abs (x) + tolx / 3;
     if (abs (x - xm) <= (2*tol - 0.5*(b-a)))
       info = 1;
       break;
     endif
 
     if (abs (e) > tol)
       dogs = false;
diff --git a/scripts/optimization/fminunc.m b/scripts/optimization/fminunc.m
--- a/scripts/optimization/fminunc.m
+++ b/scripts/optimization/fminunc.m
@@ -255,17 +255,17 @@ function [x, fval, info, output, grad, h
         prered = -t/(abs (fval) + abs (fval + t));
         ratio = actred / prered;
       else
         prered = 0;
         ratio = 0;
       endif
 
       ## Update delta.
-      if (ratio < min(max(0.1, 0.8*lastratio), 0.9))
+      if (ratio < min (max (0.1, 0.8*lastratio), 0.9))
         delta *= decfac;
         decfac ^= 1.4142;
         if (delta <= 1e1*macheps*xn)
           ## Trust region became uselessly small.
           info = -3;
           break;
         endif
       else
diff --git a/scripts/optimization/fsolve.m b/scripts/optimization/fsolve.m
--- a/scripts/optimization/fsolve.m
+++ b/scripts/optimization/fsolve.m
@@ -322,17 +322,17 @@ function [x, fvec, info, output, fjac] =
         prered = 1 - (t/fn)^2;
         ratio = actred / prered;
       else
         prered = 0;
         ratio = 0;
       endif
 
       ## Update delta.
-      if (ratio < min(max(0.1, 0.8*lastratio), 0.9))
+      if (ratio < min (max (0.1, 0.8*lastratio), 0.9))
         nsuc = 0;
         nfail ++;
         delta *= decfac;
         decfac ^= 1.4142;
         if (delta <= 1e1*macheps*xn)
           ## Trust region became uselessly small.
           info = -3;
           break;
@@ -441,17 +441,17 @@ function [fx, jx] = guarded_eval (fun, x
     [fx, jx] = fun (x);
   else
     fx = fun (x);
     jx = [];
   endif
 
   if (! complexeqn && ! (isreal (fx) && isreal (jx)))
     error ("fsolve:notreal", "fsolve: non-real value encountered");
-  elseif (complexeqn && ! (isnumeric (fx) && isnumeric(jx)))
+  elseif (complexeqn && ! (isnumeric (fx) && isnumeric (jx)))
     error ("fsolve:notnum", "fsolve: non-numeric value encountered");
   elseif (any (isnan (fx(:))))
     error ("fsolve:isnan", "fsolve: NaN value encountered");
   elseif (any (isinf (fx(:))))
     error ("fsolve:isinf", "fsolve: Inf value encountered");
   endif
 endfunction
 
diff --git a/scripts/optimization/glpk.m b/scripts/optimization/glpk.m
--- a/scripts/optimization/glpk.m
+++ b/scripts/optimization/glpk.m
@@ -495,17 +495,17 @@ function [xopt, fmin, status, extra] = g
   c = c(:);
 
   ## 2) Matrix constraint
 
   if (isempty (A))
     error ("glpk: A cannot be an empty matrix");
     return;
   endif
-  [nc, nxa] = size(A);
+  [nc, nxa] = size (A);
   if (! isreal (A) || nxa != nx)
     error ("glpk: A must be a real valued %d by %d matrix", nc, nx);
     return;
   endif
 
   ## 3) RHS
 
   if (isempty (b))
diff --git a/scripts/optimization/lsqnonneg.m b/scripts/optimization/lsqnonneg.m
--- a/scripts/optimization/lsqnonneg.m
+++ b/scripts/optimization/lsqnonneg.m
@@ -34,17 +34,17 @@
 ## recognizes these options: @code{"MaxIter"}, @code{"TolX"}.
 ## For a description of these options, see @ref{doc-optimset,,optimset}.
 ##
 ## Outputs:
 ##
 ## @itemize @bullet
 ## @item resnorm
 ##
-## The squared 2-norm of the residual: norm(@var{c}*@var{x}-@var{d})^2
+## The squared 2-norm of the residual: norm (@var{c}*@var{x}-@var{d})^2
 ##
 ## @item residual
 ##
 ## The residual: @var{d}-@var{c}*@var{x}
 ##
 ## @item exitflag
 ##
 ## An indicator of convergence.  0 indicates that the iteration count
diff --git a/scripts/optimization/qp.m b/scripts/optimization/qp.m
--- a/scripts/optimization/qp.m
+++ b/scripts/optimization/qp.m
@@ -223,25 +223,25 @@ function [x, obj, INFO, lambda] = qp (x0
           Ain = [Ain; -eye(n)];
           bin = [bin; -ub];
         endif
       endif
 
       if (! isempty (lb) && ! isempty (ub))
         rtol = sqrt (eps);
         for i = 1:n
-          if (abs(lb (i) - ub(i)) < rtol*(1 + max (abs (lb(i) + ub(i)))))
+          if (abs (lb (i) - ub(i)) < rtol*(1 + max (abs (lb(i) + ub(i)))))
             ## These are actually an equality constraint
-            tmprow = zeros(1,n);
+            tmprow = zeros (1,n);
             tmprow(i) = 1;
             A = [A;tmprow];
             b = [b; 0.5*(lb(i) + ub(i))];
             n_eq = n_eq + 1;
           else
-            tmprow = zeros(1,n);
+            tmprow = zeros (1,n);
             tmprow(i) = 1;
             Ain = [Ain; tmprow; -tmprow];
             bin = [bin; lb(i); -ub(i)];
             n_in = n_in + 2;
           endif
         endfor
       endif
     endif
diff --git a/scripts/optimization/sqp.m b/scripts/optimization/sqp.m
--- a/scripts/optimization/sqp.m
+++ b/scripts/optimization/sqp.m
@@ -117,17 +117,17 @@
 ## of @var{x} will share the same bound.  If only one bound (lb, ub) is
 ## specified then the other will default to (-@var{realmax},
 ## +@var{realmax}).
 ##
 ## The seventh argument @var{maxiter} specifies the maximum number of
 ## iterations.  The default value is 100.
 ##
 ## The eighth argument @var{tol} specifies the tolerance for the
-## stopping criteria.  The default value is @code{sqrt(eps)}.
+## stopping criteria.  The default value is @code{sqrt (eps)}.
 ##
 ## The value returned in @var{info} may be one of the following:
 ##
 ## @table @asis
 ## @item 101
 ## The algorithm terminated normally.
 ## Either all constraints meet the requested tolerance, or the stepsize,
 ## @tex
diff --git a/scripts/pkg/private/configure_make.m b/scripts/pkg/private/configure_make.m
--- a/scripts/pkg/private/configure_make.m
+++ b/scripts/pkg/private/configure_make.m
@@ -53,29 +53,29 @@ function configure_make (desc, packdir, 
       endif
       [status, output] = shell (cstrcat ("cd '", src, "'; ", scenv,
                                          "./configure --prefix=\"",
                                          desc.dir, "\"", flags));
       if (status != 0)
         rmdir (desc.dir, "s");
         error ("the configure script returned the following error: %s", output);
       elseif (verbose)
-        printf("%s", output);
+        printf ("%s", output);
       endif
 
     endif
 
     ## Make.
     if (exist (fullfile (src, "Makefile"), "file"))
       [status, output] = shell (cstrcat (scenv, "make -C '", src, "'"));
       if (status != 0)
         rmdir (desc.dir, "s");
         error ("'make' returned the following error: %s", output);
       elseif (verbose)
-        printf("%s", output);
+        printf ("%s", output);
       endif
     endif
 
     ## Copy files to "inst" and "inst/arch" (this is instead of 'make
     ## install').
     files = fullfile (src, "FILES");
     instdir = fullfile (packdir, "inst");
     archdir = fullfile (packdir, "inst", getarch ());
diff --git a/scripts/pkg/private/copy_files.m b/scripts/pkg/private/copy_files.m
--- a/scripts/pkg/private/copy_files.m
+++ b/scripts/pkg/private/copy_files.m
@@ -106,17 +106,17 @@ function copy_files (desc, packdir, glob
   packinfo_copy_file ("COPYING", "required", packdir, packinfo, desc, octfiledir);
 
   packinfo_copy_file ("NEWS", "optional", packdir, packinfo, desc, octfiledir);
   packinfo_copy_file ("ONEWS", "optional", packdir, packinfo, desc, octfiledir);
   packinfo_copy_file ("ChangeLog", "optional", packdir, packinfo, desc, octfiledir);
 
   ## Is there an INDEX file to copy or should we generate one?
   index_file = fullfile (packdir, "INDEX");
-  if (exist(index_file, "file"))
+  if (exist (index_file, "file"))
     packinfo_copy_file ("INDEX", "required", packdir, packinfo, desc, octfiledir);
   else
     try
       write_index (desc, fullfile (packdir, "inst"),
                    fullfile (packinfo, "INDEX"), global_install);
     catch
       rmdir (desc.dir, "s");
       rmdir (octfiledir, "s");
diff --git a/scripts/pkg/private/describe.m b/scripts/pkg/private/describe.m
--- a/scripts/pkg/private/describe.m
+++ b/scripts/pkg/private/describe.m
@@ -40,17 +40,17 @@ function [pkg_desc_list, flag] = describ
     flag(1:num_pkgnames) = {"Not installed"};
   endif
 
   for i = 1:num_packages
     curr_name = installed_pkgs_lst{i}.name;
     if (describe_all)
       name_pos = i;
     else
-      name_pos = find(strcmp (curr_name, pkgnames));
+      name_pos = find (strcmp (curr_name, pkgnames));
     endif
 
     if (! isempty (name_pos))
       if (installed_pkgs_lst{i}.loaded)
         flag{name_pos} = "Loaded";
       else
         flag{name_pos} = "Not loaded";
       endif
diff --git a/scripts/pkg/private/get_description.m b/scripts/pkg/private/get_description.m
--- a/scripts/pkg/private/get_description.m
+++ b/scripts/pkg/private/get_description.m
@@ -30,17 +30,17 @@ function desc = get_description (filenam
   endif
 
   desc = struct ();
 
   line = fgetl (fid);
   while (line != -1)
     if (line(1) == "#")
       ## Comments, do nothing.
-    elseif (isspace(line(1)))
+    elseif (isspace (line(1)))
       ## Continuation lines
       if (exist ("keyword", "var") && isfield (desc, keyword))
         desc.(keyword) = cstrcat (desc.(keyword), " ", deblank (line));
       endif
     else
       ## Keyword/value pair
       colon = find (line == ":");
       if (length (colon) == 0)
diff --git a/scripts/pkg/private/get_forge_pkg.m b/scripts/pkg/private/get_forge_pkg.m
--- a/scripts/pkg/private/get_forge_pkg.m
+++ b/scripts/pkg/private/get_forge_pkg.m
@@ -41,17 +41,17 @@ function [ver, url] = get_forge_pkg (nam
   ## Try to download package's index page.
   [html, succ] = urlread (sprintf ("http://octave.sourceforge.net/%s/index.html", name));
   if (succ)
     ## Remove blanks for simpler matching.
     html(isspace(html)) = [];
     ## Good. Let's grep for the version.
     pat = "<tdclass=""package_table"">PackageVersion:</td><td>([\\d.]*)</td>";
     t = regexp (html, pat, "tokens");
-    if (isempty (t) || isempty(t{1}))
+    if (isempty (t) || isempty (t{1}))
       error ("get_forge_pkg: could not read version number from package's page");
     else
       ver = t{1}{1};
       if (nargout > 1)
         # Build download string.
         urlbase = "http://downloads.sourceforge.net/octave/%s-%s.tar.gz?download";
         url = sprintf (urlbase, name, ver);
         ## Verify that the string exists on the page.
diff --git a/scripts/pkg/private/install.m b/scripts/pkg/private/install.m
--- a/scripts/pkg/private/install.m
+++ b/scripts/pkg/private/install.m
@@ -46,17 +46,17 @@ function install (files, handle_deps, au
     packages = local_packages;
   endif
 
   ## Uncompress the packages and read the DESCRIPTION files.
   tmpdirs = packdirs = descriptions = {};
   try
     ## Warn about non existent files.
     for i = 1:length (files)
-      if (isempty (glob(files{i})))
+      if (isempty (glob (files{i})))
         warning ("file %s does not exist", files{i});
       endif
     endfor
 
     ## Unpack the package files and read the DESCRIPTION files.
     files = glob (files);
     packages_to_uninstall = [];
     for i = 1:length (files)
@@ -110,17 +110,17 @@ function install (files, handle_deps, au
 
         ## Read the DESCRIPTION file.
         filename = fullfile (packdir, "DESCRIPTION");
         desc = get_description (filename);
 
         ## Verify that package name corresponds with filename.
         [dummy, nm] = fileparts (tgz);
         if ((length (nm) >= length (desc.name))
-            && ! strcmp (desc.name, nm(1:length(desc.name))))
+            && ! strcmp (desc.name, nm(1:length (desc.name))))
           error ("package name '%s' doesn't correspond to its filename '%s'",
                  desc.name, nm);
         endif
 
         ## Set default installation directory.
         desc.dir = fullfile (prefix, cstrcat (desc.name, "-", desc.version));
 
         ## Set default architectire dependent installation directory.
@@ -148,25 +148,25 @@ function install (files, handle_deps, au
   end_try_catch
 
   ## Check dependencies.
   if (handle_deps)
     ok = true;
     error_text = "";
     for i = 1:length (descriptions)
       desc = descriptions{i};
-      idx2 = setdiff (1:length(descriptions), i);
+      idx2 = setdiff (1:length (descriptions), i);
       if (global_install)
         ## Global installation is not allowed to have dependencies on locally
         ## installed packages.
-        idx1 = setdiff (1:length(global_packages), packages_to_uninstall);
+        idx1 = setdiff (1:length (global_packages), packages_to_uninstall);
         pseudo_installed_packages = {global_packages{idx1}, ...
                                      descriptions{idx2}};
       else
-        idx1 = setdiff (1:length(local_packages), packages_to_uninstall);
+        idx1 = setdiff (1:length (local_packages), packages_to_uninstall);
         pseudo_installed_packages = {local_packages{idx1}, ...
                                      global_packages{:}, ...
                                      descriptions{idx2}};
       endif
       bad_deps = get_unsatisfied_deps (desc, pseudo_installed_packages);
       ## Are there any unsatisfied dependencies?
       if (! isempty (bad_deps))
         ok = false;
@@ -276,22 +276,22 @@ function install (files, handle_deps, au
       descriptions{i}.autoload = 0;
     endif
 
   endfor
 
   ## Add the packages to the package list.
   try
     if (global_install)
-      idx = setdiff (1:length(global_packages), packages_to_uninstall);
+      idx = setdiff (1:length (global_packages), packages_to_uninstall);
       global_packages = save_order ({global_packages{idx}, descriptions{:}});
       save (global_list, "global_packages");
       installed_pkgs_lst = {local_packages{:}, global_packages{:}};
     else
-      idx = setdiff (1:length(local_packages), packages_to_uninstall);
+      idx = setdiff (1:length (local_packages), packages_to_uninstall);
       local_packages = save_order ({local_packages{idx}, descriptions{:}});
       save (local_list, "local_packages");
       installed_pkgs_lst = {local_packages{:}, global_packages{:}};
     endif
   catch
     ## Something went wrong, delete tmpdirs.
     for i = 1:length (tmpdirs)
       rmdir (tmpdirs{i}, "s");
diff --git a/scripts/pkg/private/installed_packages.m b/scripts/pkg/private/installed_packages.m
--- a/scripts/pkg/private/installed_packages.m
+++ b/scripts/pkg/private/installed_packages.m
@@ -47,17 +47,17 @@ function [out1, out2] = installed_packag
       if (any (dup == j))
         continue;
       endif
       if (strcmp (installed_pkgs_lst{i}.name, installed_pkgs_lst{j}.name))
         dup = [dup, j];
       endif
     endfor
   endfor
-  if (! isempty(dup))
+  if (! isempty (dup))
     installed_pkgs_lst(dup) = [];
   endif
 
   ## Now check if the package is loaded.
   tmppath = strrep (path (), "\\", "/");
   for i = 1:length (installed_pkgs_lst)
     if (strfind (tmppath, strrep (installed_pkgs_lst{i}.dir, '\', '/')))
       installed_pkgs_lst{i}.loaded = true;
@@ -116,19 +116,19 @@ function [out1, out2] = installed_packag
   if (max_dir_length < 20)
      max_dir_length = Inf;
   endif
 
   h1 = postpad (h1, max_name_length + 1, " ");
   h2 = postpad (h2, max_version_length, " ");;
 
   ## Print a header.
-  header = sprintf("%s | %s | %s\n", h1, h2, h3);
+  header = sprintf ("%s | %s | %s\n", h1, h2, h3);
   printf (header);
-  tmp = sprintf (repmat ("-", 1, length(header)-1));
+  tmp = sprintf (repmat ("-", 1, length (header) - 1));
   tmp(length(h1)+2) = "+";
   tmp(length(h1)+length(h2)+5) = "+";
   printf ("%s\n", tmp);
 
   ## Print the packages.
   format = sprintf ("%%%ds %%1s| %%%ds | %%s\n", max_name_length,
                     max_version_length);
   [dummy, idx] = sort (names);
diff --git a/scripts/pkg/private/is_architecture_dependent.m b/scripts/pkg/private/is_architecture_dependent.m
--- a/scripts/pkg/private/is_architecture_dependent.m
+++ b/scripts/pkg/private/is_architecture_dependent.m
@@ -31,16 +31,16 @@ function dep = is_architecture_dependent
     if (ext(end) == "*")
       isglob = true;
       ext(end) = [];
     else
       isglob = false;
     endif
     pos = strfind (nm, ext);
     if (pos)
-      if (! isglob && (length(nm) - pos(end) != length(ext) - 1))
+      if (! isglob && (length (nm) - pos(end) != length (ext) - 1))
         continue;
       endif
       dep = true;
       break;
     endif
   endfor
 endfunction
diff --git a/scripts/pkg/private/load_package_dirs.m b/scripts/pkg/private/load_package_dirs.m
--- a/scripts/pkg/private/load_package_dirs.m
+++ b/scripts/pkg/private/load_package_dirs.m
@@ -31,17 +31,17 @@ function idx = load_package_dirs (lidx, 
       ## Insert this package at the front before recursing over dependencies.
       if (! any (idx == i))
         idx = [i, idx];
       endif
 
       if (handle_deps)
         deps = installed_pkgs_lst{i}.depends;
         if ((length (deps) > 1)
-            || (length (deps) == 1 && ! strcmp(deps{1}.package, "octave")))
+            || (length (deps) == 1 && ! strcmp (deps{1}.package, "octave")))
           tmplidx = [];
           for k = 1 : length (deps)
             for j = 1 : length (installed_pkgs_lst)
               if (strcmp (installed_pkgs_lst{j}.name, deps{k}.package))
                 if (! any (idx == j))
                   tmplidx (end + 1) = j;
                   break;
                 endif
diff --git a/scripts/pkg/private/print_package_description.m b/scripts/pkg/private/print_package_description.m
--- a/scripts/pkg/private/print_package_description.m
+++ b/scripts/pkg/private/print_package_description.m
@@ -26,20 +26,20 @@ function print_package_description (pkg_
                                     pkg_desc, status, verbose)
 
   printf ("---\nPackage name:\n\t%s\n", pkg_name);
   printf ("Version:\n\t%s\n", pkg_ver);
   printf ("Short description:\n\t%s\n", pkg_desc);
   printf ("Status:\n\t%s\n", status);
   if (verbose)
     printf ("---\nProvides:\n");
-    for i = 1:length(pkg_idx_struct)
+    for i = 1:length (pkg_idx_struct)
       if (! isempty (pkg_idx_struct{i}.functions))
         printf ("%s\n", pkg_idx_struct{i}.category);
-        for j = 1:length(pkg_idx_struct{i}.functions)
+        for j = 1:length (pkg_idx_struct{i}.functions)
           printf ("\t%s\n", pkg_idx_struct{i}.functions{j});
         endfor
       endif
     endfor
   endif
 
 endfunction
 
diff --git a/scripts/pkg/private/rebuild.m b/scripts/pkg/private/rebuild.m
--- a/scripts/pkg/private/rebuild.m
+++ b/scripts/pkg/private/rebuild.m
@@ -30,17 +30,17 @@ function descriptions = rebuild (prefix,
     endif
     ## the two first entries of dirlist are "." and ".."
     dirlist([1,2]) = [];
   else
     old_descriptions = installed_packages (list, list);
     wd = pwd ();
     unwind_protect
       cd (prefix);
-      dirlist = glob (cellfun(@(x) cstrcat(x, '-*'), files, 'uniformoutput', 0));
+      dirlist = glob (cellfun(@(x) cstrcat (x, '-*'), files, 'uniformoutput', 0));
     unwind_protect_cleanup
       cd (wd);
     end_unwind_protect
   endif
   descriptions = {};
   for k = 1:length (dirlist)
     descfile = fullfile (prefix, dirlist{k}, "packinfo", "DESCRIPTION");
     if (verbose)
diff --git a/scripts/pkg/private/repackage.m b/scripts/pkg/private/repackage.m
--- a/scripts/pkg/private/repackage.m
+++ b/scripts/pkg/private/repackage.m
@@ -21,17 +21,17 @@
 ## @deftypefn {Function File} {} repackage (@var{builddir}, @var{buildlist})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function repackage (builddir, buildlist)
   packages = installed_packages (buildlist, buildlist);
 
   wd = pwd ();
-  for i = 1 : length(packages)
+  for i = 1 : length (packages)
     pack = packages{i};
     unwind_protect
       cd (builddir);
       mkdir (pack.name);
       mkdir (fullfile (pack.name, "inst"));
       copyfile (fullfile (pack.dir, "*"), fullfile (pack.name, "inst"));
       movefile (fullfile (pack.name, "inst","packinfo", "*"), pack.name);
       if (exist (fullfile (pack.name, "inst","packinfo", ".autoload"), "file"))
diff --git a/scripts/pkg/private/save_order.m b/scripts/pkg/private/save_order.m
--- a/scripts/pkg/private/save_order.m
+++ b/scripts/pkg/private/save_order.m
@@ -19,20 +19,20 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{newdesc} =} save_order (@var{desc})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function newdesc = save_order (desc)
   newdesc = {};
-  for i = 1 : length(desc)
+  for i = 1 : length (desc)
     deps = desc{i}.depends;
     if (isempty (deps)
-        || (length (deps) == 1 && strcmp(deps{1}.package, "octave")))
+        || (length (deps) == 1 && strcmp (deps{1}.package, "octave")))
       newdesc {end + 1} = desc{i};
     else
       tmpdesc = {};
       for k = 1 : length (deps)
         for j = 1 : length (desc)
           if (strcmp (desc{j}.name, deps{k}.package))
             tmpdesc{end+1} = desc{j};
             break;
diff --git a/scripts/pkg/private/shell.m b/scripts/pkg/private/shell.m
--- a/scripts/pkg/private/shell.m
+++ b/scripts/pkg/private/shell.m
@@ -22,18 +22,18 @@
 ## Undocumented internal function.
 ## @end deftypefn
 
 function [status, output] = shell (cmd)
   persistent have_sh;
 
   cmd = strrep (cmd, "\\", "/");
   if (ispc () && ! isunix ())
-    if (isempty(have_sh))
-      if (system("sh.exe -c \"exit\""))
+    if (isempty (have_sh))
+      if (system ("sh.exe -c \"exit\""))
         have_sh = false;
       else
         have_sh = true;
       endif
     endif
     if (have_sh)
       [status, output] = system (cstrcat ("sh.exe -c \"", cmd, "\""));
     else
diff --git a/scripts/plot/allchild.m b/scripts/plot/allchild.m
--- a/scripts/plot/allchild.m
+++ b/scripts/plot/allchild.m
@@ -44,14 +44,14 @@ endfunction
 
 
 %!testif HAVE_FLTK
 %! toolkit = graphics_toolkit ();
 %! graphics_toolkit ("fltk");
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   l = line;
-%!   assert(get (allchild (hf),"type"),{"axes"; "uimenu"; "uimenu"; "uimenu"});
+%!   assert (get (allchild (hf),"type"),{"axes"; "uimenu"; "uimenu"; "uimenu"});
 %! unwind_protect_cleanup
 %!   close (hf);
 %!   graphics_toolkit (toolkit);
 %! end_unwind_protect
 
diff --git a/scripts/plot/ancestor.m b/scripts/plot/ancestor.m
--- a/scripts/plot/ancestor.m
+++ b/scripts/plot/ancestor.m
@@ -44,17 +44,17 @@ function p = ancestor (h, type, toplevel
       if (nargin == 3)
         if (ischar (toplevel) && strcmpi (toplevel, "toplevel"))
           look_first = false;
         else
           error ("ancestor: third argument must be \"toplevel\"");
         endif
       endif
       h = num2cell (h);
-      for nh = 1:numel(h)
+      for nh = 1:numel (h)
         while (true)
           if (isempty (h{nh}) || ! ishandle (h{nh}))
             break;
           endif
           if (any (strcmpi (get (h{nh}, "type"), type)))
             p{nh} = h{nh};
             if (look_first)
               break;
diff --git a/scripts/plot/area.m b/scripts/plot/area.m
--- a/scripts/plot/area.m
+++ b/scripts/plot/area.m
@@ -75,19 +75,19 @@ function h = area (varargin)
     if (nargin >= idx)
       args = {varargin{idx:end}};
     endif
     newplot ();
     if (isvector (y))
       y = y(:);
     endif
     if (isempty (x))
-      x = repmat ([1:size(y, 1)]', 1, size (y, 2));
+      x = repmat ([1:rows(y)]', 1, columns (y));
     elseif (isvector (x))
-      x = repmat (x(:),  1, size (y, 2));
+      x = repmat (x(:),  1, columns (y));
     endif
 
     oldax = gca ();
     unwind_protect
       axes (ax);
       tmp = __area__ (ax, x, y, bv, args{:});
     unwind_protect_cleanup
       axes (oldax);
@@ -102,17 +102,17 @@ function h = area (varargin)
 
 endfunction
 
 function retval = __area__ (ax, x, y, bv, varargin)
 
   y0 = bv * ones (1, rows (y));
   y0 = zeros (1, rows (y));
   retval = [];
-  for i = 1: size (y, 2);
+  for i = 1: columns (y);
     hg = hggroup ();
     retval = [retval; hg];
     args = __add_datasource__ ("area", hg, {"x", "y"}, varargin{:});
 
     x1 = x(:, 1).';
     y1 = y (:, i).';
     addproperty ("xdata", hg, "data", x1);
     addproperty ("ydata", hg, "data", y1);
diff --git a/scripts/plot/axes.m b/scripts/plot/axes.m
--- a/scripts/plot/axes.m
+++ b/scripts/plot/axes.m
@@ -38,17 +38,17 @@ function h = axes (varargin)
     endif
     tmp = __go_axes__ (cf, varargin{:});
     if (__is_handle_visible__ (tmp))
       set (ancestor (cf, "figure"), "currentaxes", tmp);
     endif
   else
     ## arg is axes handle.
     tmp = varargin{1};
-    if (length(tmp) == 1 && ishandle (tmp)
+    if (length (tmp) == 1 && ishandle (tmp)
         && strcmp (get (tmp, "type"), "axes"))
       if (__is_handle_visible__ (tmp))
         parent = ancestor (tmp, "figure");
         set (0, "currentfigure", parent);
         set (parent, "currentaxes", tmp);
       endif
     else
       error ("axes: expecting argument to be a scalar axes handle");
diff --git a/scripts/plot/axis.m b/scripts/plot/axis.m
--- a/scripts/plot/axis.m
+++ b/scripts/plot/axis.m
@@ -323,17 +323,17 @@ function lims = __get_tight_lims__ (ca, 
       data = {data};
     endif
     if (strcmp (scale, "log"))
       tmp = data;
       data = cellfun (@(x) x(x>0), tmp, "uniformoutput", false);
       n = cellfun (@isempty, data);
       data(n) = cellfun (@(x) x(x<0), tmp(n), "uniformoutput", false);
     endif
-    data = cellfun (@(x) x(isfinite(x)), data, "uniformoutput", false);
+    data = cellfun (@(x) x(isfinite (x)), data, "uniformoutput", false);
     data = data(! cellfun ("isempty", data));
     if (! isempty (data))
       lims_min = min (cellfun (@(x) min (x(:)), data(:)));
       lims_max = max (cellfun (@(x) max (x(:)), data(:)));
       lims = [lims_min, lims_max];
     else
       lims = [0, 1];
     endif
diff --git a/scripts/plot/clabel.m b/scripts/plot/clabel.m
--- a/scripts/plot/clabel.m
+++ b/scripts/plot/clabel.m
@@ -62,31 +62,31 @@ function retval = clabel (c, varargin)
   have_labelspacing = false;
 
   if (nargin < 1)
     print_usage ();
   elseif (nargin == 1)
     hparent = gca ();
   else
     arg = varargin{1};
-    if (isscalar (arg) && ishandle(arg)
+    if (isscalar (arg) && ishandle (arg)
         && strcmp (get (arg, "type"), "hggroup"))
       obj = get (arg);
       if (! isfield (obj, "contourmatrix"))
         error ("clabel: expecting the handle to be a contour group");
       endif
       hg = arg;
       have_hg = true;
       varargin(1) = [];
     else
       hparent = gca ();
     endif
   endif
 
-  if (length(varargin) > 0 && isnumeric (varargin{1}))
+  if (length (varargin) > 0 && isnumeric (varargin{1}))
     v = varargin{1}(:);
     varargin(1) = [];
   else
     v = [];
   endif
 
   for i = 1 : length (varargin) - 1
     arg = varargin{i};
diff --git a/scripts/plot/close.m b/scripts/plot/close.m
--- a/scripts/plot/close.m
+++ b/scripts/plot/close.m
@@ -41,17 +41,17 @@ function retval = close (arg1, arg2)
     if (! isempty (figs) && figs == 0)
       figs = [];
     endif
   elseif (nargin == 1)
     if (ischar (arg1) && strcmpi (arg1, "all"))
       close_all_figures (false);
     elseif (isfigure (arg1))
       figs = arg1;
-    elseif (isempty(arg1))
+    elseif (isempty (arg1))
       figs = [];
     else
       error ("close: expecting argument to be \"all\" or a figure handle");
     endif
   elseif (nargin == 2
           && ischar (arg1) && strcmpi (arg1, "all")
           && ischar (arg2) && strcmpi (arg2, "hidden"))
     close_all_figures (true);
diff --git a/scripts/plot/colorbar.m b/scripts/plot/colorbar.m
--- a/scripts/plot/colorbar.m
+++ b/scripts/plot/colorbar.m
@@ -58,17 +58,17 @@ function h = colorbar (varargin)
   ax = [];
   loc = "eastoutside";
   args = {};
   deleting = false;
 
   i = 1;
   while (i <= nargin)
     arg = varargin {i++};
-    if (ischar(arg))
+    if (ischar (arg))
       if (strcmpi (arg, "peer"))
         if (i > nargin)
           error ("colorbar: missing axes handle after \"peer\"");
         else
           ax = varargin{i++};
           if (!isscalar (ax) || ! ishandle (ax)
               || ! strcmp (get (ax, "type"), "axes"))
             error ("colorbar: expecting an axes handle following \"peer\"");
diff --git a/scripts/plot/comet.m b/scripts/plot/comet.m
--- a/scripts/plot/comet.m
+++ b/scripts/plot/comet.m
@@ -39,17 +39,17 @@
 function comet (varargin)
 
   [h, varargin, nargin] = __plt_get_axis_arg__ ("comet", varargin{:});
 
   if (nargin == 0)
     print_usage ();
   elseif (nargin == 1)
     y = varargin{1};
-    x = 1:numel(y);
+    x = 1:numel (y);
     p = 0.1;
   elseif (nargin == 2)
     x = varargin{1};
     y = varargin{2};
     p = 0.1;
   elseif (nargin == 3)
     x = varargin{1};
     y = varargin{2};
diff --git a/scripts/plot/comet3.m b/scripts/plot/comet3.m
--- a/scripts/plot/comet3.m
+++ b/scripts/plot/comet3.m
@@ -38,17 +38,17 @@
 function comet3 (varargin)
 
   [h, varargin, nargin] = __plt_get_axis_arg__ ("comet3", varargin{:});
 
   if (nargin == 0 || nargin == 2 || nargin > 4)
     print_usage ();
   elseif (nargin == 1)
     z = varargin{1};
-    x = y = 1:numel(z);
+    x = y = 1:numel (z);
     p = 0.1;
   elseif (nargin == 3)
     x = varargin{1};
     y = varargin{2};
     z = varargin{3};
     p = 0.1;
   elseif (nargin == 4)
     x = varargin{1};
diff --git a/scripts/plot/contour.m b/scripts/plot/contour.m
--- a/scripts/plot/contour.m
+++ b/scripts/plot/contour.m
@@ -78,17 +78,17 @@ endfunction
 %! contour (x, y, z);
 
 %!demo
 %! clf;
 %! colormap ('default');
 %! [theta, r] = meshgrid (linspace (0,2*pi,64), linspace (0,1,64));
 %! [X, Y] = pol2cart (theta, r);
 %! Z = sin (2*theta) .* (1-r);
-%! contour (X, Y, abs(Z), 10);
+%! contour (X, Y, abs (Z), 10);
 
 %!demo
 %! clf;
 %! colormap ('default');
 %! x = linspace (-2, 2);
 %! [x, y] = meshgrid (x);
 %! z = sqrt (x.^2 + y.^2) ./ (x.^2 + y.^2 + 1);
 %! contourf (x, y, z, [0.4, 0.4]);
diff --git a/scripts/plot/contourc.m b/scripts/plot/contourc.m
--- a/scripts/plot/contourc.m
+++ b/scripts/plot/contourc.m
@@ -96,40 +96,40 @@ function [cout, lev] = contourc (varargi
   else
     vv = unique (sort (vn));
   endif
 
   if (isvector (x) && isvector (y))
     c = __contourc__ (x(:)', y(:)', z, vv);
   else
     ## Indexes x,y for the purpose of __contourc__.
-    ii = 1:size (z,2);
-    jj = 1:size (z,1);
+    ii = 1:columns (z);
+    jj = 1:rows (z);
 
     ## Now call __contourc__ for the real work...
     c = __contourc__ (ii, jj, z, vv);
 
     ## Map the contour lines from index space (i,j) back
     ## to the original grid (x,y)
     i = 1;
 
-    while (i < size (c,2))
+    while (i < columns (c))
       clen = c(2, i);
       ind = i + [1 : clen];
 
       ci = c(1, ind);
       cj = c(2,ind);
 
       ## due to rounding errors some elements of ci and cj
       ## can fall out of the range of ii and jj and interp2 would
       ## return NA for those values.
       ## The permitted range is enforced here:
 
-      ci = max (ci, 1); ci = min (ci, size (z, 2));
-      cj = max (cj, 1); cj = min (cj, size (z, 1));
+      ci = max (ci, 1); ci = min (ci, columns (z));
+      cj = max (cj, 1); cj = min (cj, rows (z));
 
       c(1, ind) = interp2 (ii, jj, x, ci, cj);
       c(2, ind) = interp2 (ii, jj, y, ci, cj);
 
       i = i + clen + 1;
     endwhile
   endif
 
diff --git a/scripts/plot/copyobj.m b/scripts/plot/copyobj.m
new file mode 100644
--- /dev/null
+++ b/scripts/plot/copyobj.m
@@ -0,0 +1,127 @@
+## Copyright (C) 2012 pdiribarne
+##
+## This program is free software; you can redistribute it and/or modify
+## it under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or
+## (at your option) any later version.
+##
+## This program is distributed in the hope that it will be useful,
+## but WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+## GNU General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn   {Function File} {@var{hnew} =} copyobj (@var{horig})
+## @deftypefnx  {Function File} {@var{hnew} =} copyobj (@var{horig}, @var{hparent})
+## Constructs a copy of the object associated with handle @var{horig}
+## and returns a handle, @var{hnew}, to the new object.
+## If a parent handle @var{hparent} (root, figure, axes or hggroup) is specified,
+## the copied object will be created as a child to @var{hparent}.
+## @seealso{findobj, get, set, struct2hdl, hdl2struct}
+## @end deftypefn
+
+## Author: pdiribarne <pdiribarne@new-host.home>
+## Created: 2012-04-01
+
+function hout = copyobj (hin, hpar = 0)
+
+  partypes = {"root", "figure", "axes", "hggroup"};
+  othertypes = {"line", "patch", "surface", "image", "text"};
+  alltypes = [partypes othertypes];
+
+  if (! ishandle (hin) || nargin > 2)
+    print_usage ();
+  elseif (! ishandle (hpar))
+    hpar = figure (floor (hpar));
+  elseif (! any (strcmpi (get (hpar).type, partypes)))
+    print_usage ();
+  endif
+
+  ## compatibility of input handles
+  kididx = find (strcmp (alltypes, get (hin).type));
+  paridx = find (strcmp (alltypes, get (hpar).type));
+
+  if (kididx <= paridx)
+    error ("copyobj: %s object can't be children to %s.",
+           alltypes{kididx}, alltypes{paridx})
+  elseif nargin == 1
+    str = hdl2struct (hin);
+    hout = struct2hdl (str);
+  else
+    str = hdl2struct (hin);
+    hout = struct2hdl (str, hpar);
+  endif
+endfunction
+
+%!test
+%! h1 = figure ();
+%! set (h1, "visible", "off")
+%! x = 0:0.1:2*pi;
+%! y1 = sin (x);
+%! y2 = exp (x - 1);
+%! ax = plotyy (x,y1, x-1,y2, @plot, @semilogy);
+%! xlabel ("X");
+%! ylabel (ax(1), "Axis 1");
+%! ylabel (ax(2), "Axis 2");
+%! axes (ax(1));
+%! text (0.5, 0.5, "Left Axis", ...
+%!       "color", [0 0 1], "horizontalalignment", "center");
+%! axes (ax(2));
+%! text (4.5, 80, "Right Axis", ...
+%!       "color", [0 0.5 0], "horizontalalignment", "center");
+%! s1 = hdl2struct (h1);
+%! h2 = struct2hdl (s1);
+%! s2 = hdl2struct (h2);
+%! png1 = strcat (tmpnam (), ".png");
+%! png2 = strcat (tmpnam (), ".png");
+%! unwind_protect
+%!   print (h1, png1)
+%!   [img1, map1, alpha1] = imread (png1);
+%!   print (h2, png2)
+%!   [img2, map2, alpha2] = imread (png2);
+%! unwind_protect_cleanup
+%!   unlink (png1);
+%!   unlink (png2);
+%! end_unwind_protect
+%! assert (img1, img2)
+%! assert (map1, map2)
+%! assert (alpha1, alpha2)
+
+%!demo
+%! hdl = figure (1234);
+%! clf ()
+%! hold on
+%! x = 1:10;
+%! y = x.^2;
+%! dy = 2 * (.2 * x);
+%! y2 = (x - 3).^2;
+%! hg = errorbar (x, y, dy,'#~');
+%! set (hg, 'marker', '^', 'markerfacecolor', rand(1,3))
+%! plot (x, y2, 'ok-')
+%! legend ('errorbar', 'line')
+%! hout = copyobj (1234);
+
+%!demo
+%! hdl = figure (1234);
+%! clf ()
+%! subplot (2, 2, 1);
+%! hold on
+%! [C, H] = contourf (rand(10, 10));
+%! colorbar
+%! subplot (2, 2, 2);
+%! hold on
+%! quiver (rand(10, 10), rand(10, 10))
+%! subplot (2, 2, 3);
+%! colormap (jet (64))
+%! sombrero;
+%! colorbar('peer', gca, 'NorthOutside')
+%! subplot (2, 2, 4);
+%! imagesc (rand (30, 30));
+%! text (15, 15, 'Rotated text', ...
+%!      'HorizontAlalignment', 'Center', 'Rotation', 30);
+%! hout = copyobj (1234);
+
diff --git a/scripts/plot/cylinder.m b/scripts/plot/cylinder.m
--- a/scripts/plot/cylinder.m
+++ b/scripts/plot/cylinder.m
@@ -60,23 +60,23 @@ function [xx, yy, zz] = cylinder (vararg
   elseif (nargs == 2)
     r = args{1};
     n = args{2};
   else
     print_usage ();
   endif
 
   if (length (r) < 2)
-    error ("cylinder: length(R) must be larger than 2");
+    error ("cylinder: length (R) must be larger than 2");
   endif
 
   phi = linspace (0, 2*pi, n+1);
-  idx = 1:length(r);
-  [phi, idx] = meshgrid(phi, idx);
-  z = (idx - 1) / (length(r) - 1);
+  idx = 1:length (r);
+  [phi, idx] = meshgrid (phi, idx);
+  z = (idx - 1) / (length (r) - 1);
   r = r(idx);
   [x, y] = pol2cart (phi, r);
 
   if (nargout > 0)
     xx = x;
     yy = y;
     zz = z;
   else
diff --git a/scripts/plot/ezmesh.m b/scripts/plot/ezmesh.m
--- a/scripts/plot/ezmesh.m
+++ b/scripts/plot/ezmesh.m
@@ -53,19 +53,19 @@
 ## ezmesh (f, [-3, 3]);
 ## @end group
 ## @end example
 ##
 ## An example of a parametrically defined function is
 ##
 ## @example
 ## @group
-## fx = @@(s,t) cos (s) .* cos(t);
-## fy = @@(s,t) sin (s) .* cos(t);
-## fz = @@(s,t) sin(t);
+## fx = @@(s,t) cos (s) .* cos (t);
+## fy = @@(s,t) sin (s) .* cos (t);
+## fz = @@(s,t) sin (t);
 ## ezmesh (fx, fy, fz, [-pi, pi, -pi/2, pi/2], 20);
 ## @end group
 ## @end example
 ##
 ## @seealso{ezplot, ezmeshc, ezsurf, ezsurfc}
 ## @end deftypefn
 
 function retval = ezmesh (varargin)
@@ -87,13 +87,13 @@ endfunction
 %! clf;
 %! colormap ('default');
 %! f = @(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
 %! ezmesh (f, [-3, 3]);
 
 %!demo
 %! clf;
 %! colormap ('default');
-%! fx = @(s,t) cos (s) .* cos(t);
-%! fy = @(s,t) sin (s) .* cos(t);
+%! fx = @(s,t) cos (s) .* cos (t);
+%! fy = @(s,t) sin (s) .* cos (t);
 %! fz = @(s,t) sin (t);
 %! ezmesh (fx, fy, fz, [-pi,pi,-pi/2,pi/2], 20);
 
diff --git a/scripts/plot/ezsurf.m b/scripts/plot/ezsurf.m
--- a/scripts/plot/ezsurf.m
+++ b/scripts/plot/ezsurf.m
@@ -87,13 +87,13 @@ endfunction
 %! clf;
 %! colormap ('default');
 %! f = @(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
 %! ezsurf (f, [-3, 3]);
 
 %!demo
 %! clf;
 %! colormap ('default');
-%! fx = @(s,t) cos (s) .* cos(t);
-%! fy = @(s,t) sin (s) .* cos(t);
+%! fx = @(s,t) cos (s) .* cos (t);
+%! fy = @(s,t) sin (s) .* cos (t);
 %! fz = @(s,t) sin (t);
 %! ezsurf (fx, fy, fz, [-pi,pi,-pi/2,pi/2], 20);
 
diff --git a/scripts/plot/findobj.m b/scripts/plot/findobj.m
--- a/scripts/plot/findobj.m
+++ b/scripts/plot/findobj.m
@@ -141,17 +141,17 @@ function h = findobj (varargin)
         endif
       elseif (! strcmp (args{na}(1), "-"))
         ## Parameter/value pairs.
         if (na + 1 <= numel (args))
           pname{np} = args{na};
           na = na + 1;
           pvalue{np} = args{na};
           na = na + 1;
-          if (na <= numel(args))
+          if (na <= numel (args))
             if (ischar (args{na}))
               if (strcmpi (args{na}, "-and"))
                 logicaloperator{np} = "and";
                 na = na+1;
               elseif (strcmpi (args{na}, "-or"))
                 logicaloperator{np} = "or";
                 na = na+1;
               elseif (strcmpi (args{na}, "-xor"))
@@ -187,26 +187,26 @@ function h = findobj (varargin)
   numpairs = np - 1;
 
   ## Load all objects which qualify for being searched.
   idepth = 0;
   h = handles;
   while (numel (handles) && ! (idepth >= depth))
     children = [];
     for n = 1 : numel (handles)
-      children = union (children, get(handles(n), "children"));
+      children = union (children, get (handles(n), "children"));
     endfor
     handles = children;
     h = union (h, children);
     idepth = idepth + 1;
   endwhile
 
   keepers = ones (size (h));
   if (numpairs > 0)
-    for nh = 1 : numel(h)
+    for nh = 1 : numel (h)
       p = get (h (nh));
       for np = 1 : numpairs
         fields = fieldnames (p);
         fieldindex = find (strcmpi (fields, pname{np}), 1);
         if (numel (fieldindex))
           pname{np} = fields{fieldindex};
           if (property(np))
             match = 1;
diff --git a/scripts/plot/fplot.m b/scripts/plot/fplot.m
--- a/scripts/plot/fplot.m
+++ b/scripts/plot/fplot.m
@@ -75,17 +75,17 @@ function fplot (fn, limits, n, fmt)
     nam = fn;
   elseif (ischar (fn))
      fn = vectorize (inline (fn));
      nam = formula (fn);
   else
     error ("fplot: first input argument must be a function handle, inline function or string");
   endif
 
-  if (floor(n) != n)
+  if (floor (n) != n)
     tol = n;
     x0 = linspace (limits(1), limits(2), 5)';
     y0 = feval (fn, x0);
     err0 = Inf;
     n = 8;
     x = linspace (limits(1), limits(2), n)';
     y = feval (fn, x);
 
diff --git a/scripts/plot/hdl2struct.m b/scripts/plot/hdl2struct.m
new file mode 100644
--- /dev/null
+++ b/scripts/plot/hdl2struct.m
@@ -0,0 +1,166 @@
+## Copyright (C) 2012 pdiribarne
+##
+## This program is free software; you can redistribute it and/or modify
+## it under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or
+## (at your option) any later version.
+##
+## This program is distributed in the hope that it will be useful,
+## but WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+## GNU General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {@var{s} =} hdl2struct (@var{h})
+## Returns a structure, @var{s}, whose fields describe the properties
+## of the object, and its children, associated with the handle, @var{h}.
+## The fields of the structure, @var{s}, are "type", "handle", "properties",
+## "children" and "special".
+## @seealso{findobj, get, set, struct2hdl}
+## @end deftypefn
+
+## Author: pdiribarne <pdiribarne@new-host.home>
+## Created: 2012-03-04
+
+function hgS = hdl2struct (h)
+  if (nargin != 1 || !ishandle (h))
+    print_usage ();
+  endif
+
+  hiddenh = get (0, "showhiddenhandles");
+  if strcmp (hiddenh, "on")
+    set (0, "showhiddenhandles", "off");
+  endif
+
+  ## main object
+  main = get (h);
+  hgS.handle = h;
+  hgS.type =  main.type;
+  hgS.properties  = getprops (h);
+  hgS.children = [];
+  hgS.special = [];
+
+  ## sweep all children but legends, colorbars, uimenu and hggroup children
+  ## in reverse order
+  kids = main.children;
+  lg = findobj (h, "-depth", 1, "tag", "legend");
+  cb = findobj (h, "-depth", 1, "tag", "colorbar");
+  ui = findobj (h, "-depth", 1, "type", "uimenu");
+  nkids = length (kids);
+  ii = 0;
+  while nkids
+    if (! any (kids (nkids) == lg) && !any (kids (nkids) == cb)
+          && ! any (kids (nkids) == ui) && !strcmpi (main.type, "hggroup"))
+      ii++;
+      hgS.children(ii) = hdl2struct(kids(nkids));
+    endif
+    nkids--;
+  endwhile
+
+  ## add non "children" children objects (title, xlabel, ...) and
+  ## hggroup children and tag theim in "special"
+  special = [];
+  if (strcmpi (main.type, "hggroup"))
+    special = main.children;
+  endif
+  special = [special getspecial(h)];
+  nsp = length (special);
+  while nsp
+    ii++;
+    hgS.children(ii) = hdl2struct (special(nsp));
+    hgS.special(nsp) = ii;
+    nsp--;
+  endwhile
+
+  ## look for legends and colorbars among "main"'s brothers and add them
+  ## to the children list
+  if (strcmpi (main.type, "axes"))
+    par = main.parent;
+    lg = findobj (par, "-depth", 1, "tag", "legend");
+    if !isempty (lg)
+      idx = arrayfun (@(x) get(x).userdata.handle(end) == h, lg);
+      lg = lg(find(idx));
+    endif
+    nlg = length (lg);
+    if nlg == 1
+      ii++;
+      hgS.children(ii) = hdl2struct (lg);
+    elseif (nlg > 1)
+      error ("hdl2struct: more than one legend found")
+    endif
+
+    cb = findobj (par, "-depth", 1, "tag", "colorbar");
+    if (! isempty (cb))
+      idx = arrayfun (@(x) get(x).axes == h, cb);
+      cb = cb(find(idx));
+    endif
+
+    ncb = length (cb);
+    if (ncb == 1)
+      ii++;
+      hgS.children(ii) = hdl2struct(cb);
+    elseif (nlg > 1)
+      error ("hdl2struct: more than one colorbar found")
+    endif
+  endif
+
+  set (0, "showhiddenhandles", hiddenh);
+
+endfunction
+
+function hdlist = getspecial (h)
+  obj = get (h);
+  ## return handles to special children
+  fields = fieldnames (obj);
+  hdlist = [];
+
+  regkids = get ( h, "children");
+  set (0, "showhiddenhandles", "on")
+  allkids = get ( h, "children");
+  set (0, "showhiddenhandles", "off")
+  speckids = arrayfun (@(x) ! any (x == regkids), allkids);
+  hdlist = allkids (find (speckids));
+  hdlist = reshape (hdlist, 1, numel (hdlist));
+
+endfunction
+
+function prpstr = getprops (h)
+  obj = get (h);
+  ## get usefull properties rejecting readonly, children, handles ...
+  fields = fieldnames (obj);
+  hdlist = [];
+
+  forbid = {"beingdeleted", "busyaction", "buttondownfcn", ...
+            "children", "clipping", "createfcn", ...
+            "deletefcn", "handlevisibility", "hittest", ...
+            "interruptible", "parent", "selected" ,...
+            "selectionhighlight", "type", "__modified__", ...
+            "uicontextmenu", "__graphics_toolkit__", "currentaxes", ...
+            "currentcharacter", "currentobject","tightinset", ...
+            "currentpoint", "extent"};
+
+  nflds = length (fields);
+  ii = 0;
+  while nflds
+    prop = fields{nflds};
+    val = obj.(fields{nflds});
+    ii++;
+    if !any (strcmp (prop, forbid))
+      prpstr.(prop) = val;
+    endif
+    nflds--;
+  endwhile
+
+  ## hidden properties
+  hidden = {"autopos_tag", "looseinset"};
+  for ii = 1:numel (hidden)
+    if (isprop (h, hidden{ii}))
+      prpstr.(hidden{ii}) = get (h, hidden{ii});
+    endif
+  endfor
+endfunction
+
diff --git a/scripts/plot/hist.m b/scripts/plot/hist.m
--- a/scripts/plot/hist.m
+++ b/scripts/plot/hist.m
@@ -88,17 +88,17 @@ function [nn, xx] = hist (y, varargin)
   else
     error ("hist: first argument must be real valued");
   endif
 
   iarg = 1;
   if (nargin == 1 || ischar (varargin{iarg}))
     n = 10;
     x = [0.5:n]'/n;
-    x = x * (max_val - min_val) + ones(size(x)) * min_val;
+    x = x * (max_val - min_val) + ones (size (x)) * min_val;
   else
     ## nargin is either 2 or 3
     x = varargin{iarg++};
     if (isscalar (x))
       n = x;
       if (n <= 0)
         error ("hist: number of bins must be positive");
       endif
@@ -155,17 +155,17 @@ function [nn, xx] = hist (y, varargin)
   if (nargout > 0)
     if (arg_is_vector)
       nn = freq';
       xx = x';
     else
       nn = freq;
       xx = x;
     endif
-  elseif (size (freq, 2) != 1)
+  elseif (columns (freq) != 1)
     bar (x, freq, 0.8, varargin{iarg:end});
   else
     bar (x, freq, 1.0, varargin{iarg:end});
   endif
 
 endfunction
 
 
diff --git a/scripts/plot/isocolors.m b/scripts/plot/isocolors.m
--- a/scripts/plot/isocolors.m
+++ b/scripts/plot/isocolors.m
@@ -93,17 +93,17 @@
 ## @end example
 ##
 ## @seealso{isosurface, isonormals}
 ##
 ## @end deftypefn
 
 ## Author: Martin Helm <martin@mhelm.de>
 
-function varargout = isocolors(varargin)
+function varargout = isocolors (varargin)
   calc_rgb = false;
   switch (nargin)
     case 2
       c = varargin{1};
       vp = varargin{2};
       x = 1:size (c, 2);
       y = 1:size (c, 1);
       z = 1:size (c, 3);
@@ -129,27 +129,27 @@ function varargout = isocolors(varargin)
       z = varargin{3};
       R = varargin{4};
       G = varargin{5};
       B = varargin{6};
       vp = varargin{7};
     otherwise
       print_usage ();
   endswitch
-  if (ismatrix (vp) && size (vp,2) == 3)
+  if (ismatrix (vp) && columns (vp) == 3)
     pa = [];
     v = vp;
   elseif ( ishandle (vp) )
     pa = vp;
     v = get (pa, "Vertices");
   else
     error ("isocolors: last argument is not a vertex list or patch handle");
   endif
   if (calc_rgb)
-    new_col = zeros (size (v, 1), 3);
+    new_col = zeros (rows (v), 3);
     new_col(:,1) = __interp_cube__ (x, y, z, R, v, "values" );
     new_col(:,2) = __interp_cube__ (x, y, z, G, v, "values" );
     new_col(:,3) = __interp_cube__ (x, y, z, B, v, "values" );
   else
     new_col = __interp_cube__ (x, y, z, c, v, "values" );
   endif
   switch (nargout)
     case 0
diff --git a/scripts/plot/isonormals.m b/scripts/plot/isonormals.m
--- a/scripts/plot/isonormals.m
+++ b/scripts/plot/isonormals.m
@@ -90,17 +90,17 @@
 ## isofinish (p);
 ## @end smallexample
 ##
 ## @seealso{isosurface, isocolors}
 ## @end deftypefn
 
 ## Author: Martin Helm <martin@mhelm.de>
 
-function varargout = isonormals(varargin)
+function varargout = isonormals (varargin)
   na = nargin;
   negate = false;
   if (ischar (varargin{nargin}))
     na = nargin-1;
     if (strcmp (lower (varargin{nargin}), "negate"))
       negate = true;
     else
       error ("isonormals: Unknown option '%s'", varargin{nargin});
@@ -117,17 +117,17 @@ function varargout = isonormals(varargin
       x = varargin{1};
       y = varargin{2};
       z = varargin{3};
       c = varargin{4};
       vp = varargin{5};
     otherwise
       print_usage ();
   endswitch
-  if (ismatrix (vp) && size (vp,2) == 3)
+  if (ismatrix (vp) && columns (vp) == 3)
     pa = [];
     v = vp;
   elseif (ishandle (vp))
     pa = vp;
     v = get (pa, "Vertices");
   else
     error ("isonormals: Last argument is not a vertex list or a patch handle");
   endif
diff --git a/scripts/plot/isosurface.m b/scripts/plot/isosurface.m
--- a/scripts/plot/isosurface.m
+++ b/scripts/plot/isosurface.m
@@ -113,17 +113,17 @@
 ## # light ("Position", [1 1 5]);
 ## @end smallexample
 ##
 ## @seealso{isonormals, isocolors}
 ## @end deftypefn
 
 ## Author: Martin Helm <martin@mhelm.de>
 
-function varargout = isosurface(varargin)
+function varargout = isosurface (varargin)
 
   if (nargin < 2 || nargin > 8 || nargout > 3)
     print_usage ();
   endif
 
   calc_colors = false;
   f = v = c = [];
   verbose = false;
diff --git a/scripts/plot/isprop.m b/scripts/plot/isprop.m
--- a/scripts/plot/isprop.m
+++ b/scripts/plot/isprop.m
@@ -32,17 +32,17 @@ function res = isprop (h, prop)
 
   if (! all (ishandle (h)))
     error ("isprop: first input argument must be a handle");
   elseif (! ischar (prop))
     error ("isprop: second input argument must be string");
   endif
 
   res = false (size (h));
-  for n = 1:numel(res)
+  for n = 1:numel (res)
     res(n) = true;
     try
       v = get (h(n), prop);
     catch
       res(n) = false;
     end_try_catch
   endfor
 endfunction
diff --git a/scripts/plot/legend.m b/scripts/plot/legend.m
--- a/scripts/plot/legend.m
+++ b/scripts/plot/legend.m
@@ -140,17 +140,17 @@ function [hlegend2, hobjects2, hplot2, t
 
   if (nargin > 0 && all (ishandle (varargin{1})))
     kids = flipud (varargin{1}(:));
     varargin(1) = [];
   else
     kids = ca;
     kids (strcmp (get (ca, "tag"), "legend")) = [];
     if (isscalar (kids))
-      kids = get(kids, "children")(:);
+      kids = get (kids, "children")(:);
     else
       kids = flipud ([get(kids, "children"){:}](:));
     endif
   endif
   nargs = numel (varargin);
   nkids = numel (kids);
 
   orientation = "default";
@@ -210,17 +210,17 @@ function [hlegend2, hobjects2, hplot2, t
       warning ("legend: 'Best' not yet implemented for location specifier\n");
       position = "northeast";
     otherwise
       error ("legend: unrecognized legend position");
   endswitch
 
   hlegend = [];
   fkids = get (fig, "children");
-  for i = 1 : numel(fkids)
+  for i = 1 : numel (fkids)
     if (ishandle (fkids (i)) && strcmp (get (fkids (i), "type"), "axes")
         && (strcmp (get (fkids (i), "tag"), "legend")))
       udata = get (fkids (i), "userdata");
       if (! isempty (intersect (udata.handle, ca)))
         hlegend = fkids (i);
         break;
       endif
     endif
@@ -493,18 +493,18 @@ function [hlegend2, hobjects2, hplot2, t
 
       ## Length of line segments in the legend in points
       linelength = 15;
 
       ## Create the axis first
       ## FIXME hlegend should inherit properties from "ca"
       curaxes = get (fig, "currentaxes");
       unwind_protect
-        ud = ancestor(hplots, "axes");
-        if (!isscalar(ud))
+        ud = ancestor (hplots, "axes");
+        if (!isscalar (ud))
           ud = unique ([ud{:}]);
         endif
         if (isempty (hlegend))
           addprops = true;
           hlegend = axes ("tag", "legend", "userdata", struct ("handle", ud),
                           "box", box,
                           "xtick", [], "ytick", [],
                           "xticklabel", "", "yticklabel", "", "zticklabel", "",
@@ -702,23 +702,23 @@ function [hlegend2, hobjects2, hplot2, t
                          "color", color, "linestyle", "none", "marker", marker,
                          "markeredgecolor", get (hplots (k), "markeredgecolor"),
                          "markerfacecolor", get (hplots (k), "markerfacecolor"),
                          "markersize", get (hplots (k), "markersize"),
                          "userdata", hplots (k));
               hobjects = [hobjects, l1];
             endif
 
-            addlistener(hplots(k), "color", {@updateline, hlegend, linelength});
-            addlistener(hplots(k), "linestyle", {@updateline, hlegend, linelength});
-            addlistener(hplots(k), "marker", {@updateline, hlegend, linelength});
-            addlistener(hplots(k), "markeredgecolor", {@updateline, hlegend, linelength});
-            addlistener(hplots(k), "markerfacecolor", {@updateline, hlegend, linelength});
-            addlistener(hplots(k), "markersize", {@updateline, hlegend, linelength});
-            addlistener(hplots(k), "displayname", {@updateline, hlegend, linelength});
+            addlistener (hplots(k), "color", {@updateline, hlegend, linelength});
+            addlistener (hplots(k), "linestyle", {@updateline, hlegend, linelength});
+            addlistener (hplots(k), "marker", {@updateline, hlegend, linelength});
+            addlistener (hplots(k), "markeredgecolor", {@updateline, hlegend, linelength});
+            addlistener (hplots(k), "markerfacecolor", {@updateline, hlegend, linelength});
+            addlistener (hplots(k), "markersize", {@updateline, hlegend, linelength});
+            addlistener (hplots(k), "displayname", {@updateline, hlegend, linelength});
           case "patch"
             facecolor = get (hplots(k), "facecolor");
             edgecolor = get (hplots(k), "edgecolor");
             cdata = get (hplots(k), "cdata");
             if (! strcmp (facecolor, "none") || ! strcmp (edgecolor, "none"))
               p1 = patch ("xdata", ([0, linelength, linelength, 0] +
                                    xoffset + xk * xstep) / lpos(3),
                          "ydata", (lpos(4) - yoffset -
@@ -954,17 +954,17 @@ function updateline (h, d, hlegend, line
     hplots = [hplots, h];
     text_strings = {text_strings{:}, displayname};
     legend (hplots, text_strings);
   else
     if (! isempty (ll))
       ypos1 = get (ll,"ydata");
       xpos1 = get (ll,"xdata");
       ypos2 = ypos1(1);
-      xpos2 = sum(xpos1) / 2;
+      xpos2 = sum (xpos1) / 2;
       delete (ll);
       if (! isempty (lm))
         delete (lm);
       endif
     else
       ypos2 = get (lm,"ydata");
       xpos2 = get (lm,"xdata");
       ypos1 = [ypos2, ypos2];
diff --git a/scripts/plot/mesh.m b/scripts/plot/mesh.m
--- a/scripts/plot/mesh.m
+++ b/scripts/plot/mesh.m
@@ -60,26 +60,26 @@ function h = mesh (varargin)
     h = tmp;
   endif
 
 endfunction
 
 
 %!demo
 %! clf ();
-%! x = logspace(0,1,11);
+%! x = logspace (0,1,11);
 %! z = x'*x;
 %! mesh (x, x, z, z.^2);
 %! xlabel xlabel
 %! ylabel ylabel
 %! zlabel "linear scale"
 
 %!demo
 %! clf ();
-%! x = logspace(0,1,11);
+%! x = logspace (0,1,11);
 %! z = x'*x;
 %! mesh (x, x, z, z.^2);
 %! set (gca, "zscale", "log")
 %! xlabel xlabel
 %! ylabel ylabel
 %! zlabel "log scale"
 %! if (strcmp (get (gcf, "__graphics_toolkit__"), "gnuplot"))
 %!   title ({"Gnuplot: mesh color is wrong", "This a Gnuplot bug"})
diff --git a/scripts/plot/meshz.m b/scripts/plot/meshz.m
--- a/scripts/plot/meshz.m
+++ b/scripts/plot/meshz.m
@@ -63,20 +63,20 @@ function retval = meshz (varargin)
     x = [x(1, 1), x(1, :), x(1, end);
          x(:, 1), x, x(:, end);
          x(end, 1), x(end, :), x(end, end)];
     y = [y(1, 1), y(1, :), y(1, end);
          y(:, 1), y, y(:, end);
          y(end, 1), y(end, :), y(end, end)];
   endif
 
-  zref = min(z(isfinite(z)));
-  z = [zref .* ones(1, size(z, 2) + 2);
-       zref .* ones(size(z, 1), 1), z, zref .* ones(size(z, 1), 1);
-       zref.* ones(1, size(z, 2) + 2)];
+  zref = min (z(isfinite (z)));
+  z = [zref .* ones(1, columns(z) + 2);
+       zref .* ones(rows(z), 1), z, zref .* ones(rows(z), 1);
+       zref.* ones(1, columns(z) + 2)];
 
   oldh = gca ();
   unwind_protect
     axes (h);
     tmp = mesh (x, y, z, varargin{ioff:end});
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
diff --git a/scripts/plot/module.mk b/scripts/plot/module.mk
--- a/scripts/plot/module.mk
+++ b/scripts/plot/module.mk
@@ -75,16 +75,17 @@ plot_FCN_FILES = \
   plot/colstyle.m \
   plot/comet.m \
   plot/comet3.m \
   plot/compass.m \
   plot/contour.m \
   plot/contour3.m \
   plot/contourc.m \
   plot/contourf.m \
+  plot/copyobj.m \
   plot/cylinder.m \
   plot/daspect.m \
   plot/diffuse.m \
   plot/ellipsoid.m \
   plot/errorbar.m \
   plot/ezcontour.m \
   plot/ezcontourf.m \
   plot/ezmesh.m \
@@ -107,16 +108,17 @@ plot_FCN_FILES = \
   plot/gcf.m \
   plot/gco.m \
   plot/ginput.m \
   plot/graphics_toolkit.m \
   plot/grid.m \
   plot/gtext.m \
   plot/guidata.m \
   plot/guihandles.m \
+  plot/hdl2struct.m \
   plot/hggroup.m \
   plot/hidden.m \
   plot/hist.m \
   plot/hold.m \
   plot/isfigure.m \
   plot/ishghandle.m \
   plot/ishold.m \
   plot/isocolors.m \
@@ -167,16 +169,17 @@ plot_FCN_FILES = \
   plot/shrinkfaces.m \
   plot/slice.m \
   plot/sombrero.m \
   plot/specular.m \
   plot/sphere.m \
   plot/stairs.m \
   plot/stem.m \
   plot/stem3.m \
+  plot/struct2hdl.m \
   plot/subplot.m \
   plot/surf.m \
   plot/surface.m \
   plot/surfc.m \
   plot/surfl.m \
   plot/surfnorm.m \
   plot/tetramesh.m \
   plot/text.m \
diff --git a/scripts/plot/pareto.m b/scripts/plot/pareto.m
--- a/scripts/plot/pareto.m
+++ b/scripts/plot/pareto.m
@@ -69,30 +69,30 @@ function h = pareto (varargin)
     if (! iscell (y))
       if (ischar (y))
         y = cellstr (y);
       else
         y = cellfun ("num2str", num2cell (y), "uniformoutput", false);
       endif
     endif
   else
-    y = cellfun ("int2str", num2cell (1 : numel(x)),
+    y = cellfun ("int2str", num2cell (1 : numel (x)),
                  "uniformoutput", false);
   endif
 
   [x, idx] = sort (x, "descend");
   y = y (idx);
   cdf = cumsum (x);
-  maxcdf = max(cdf);
+  maxcdf = max (cdf);
   cdf = cdf ./ maxcdf;
   cdf95 = cdf - 0.95;
-  idx95 = find(sign(cdf95(1:end-1)) != sign(cdf95(2:end)))(1);
+  idx95 = find (sign (cdf95(1:end-1)) != sign (cdf95(2:end)))(1);
 
   [ax, hbar, hline] = plotyy (1 : idx95, x (1 : idx95),
-                              1 : length(cdf), 100 .* cdf,
+                              1 : length (cdf), 100 .* cdf,
                               @bar, @plot);
 
   axis (ax(1), [1 - 0.6, idx95 + 0.6, 0, maxcdf]);
   axis (ax(2), [1 - 0.6, idx95 + 0.6, 0, 100]);
   set (ax(2), "ytick", [0, 20, 40, 60, 80, 100],
        "yticklabel", {"0%", "20%", "40%", "60%", "80%", "100%"});
   set (ax(1), "xtick", 1 : idx95, "xticklabel", y (1: idx95));
   set (ax(2), "xtick", 1 : idx95, "xticklabel", y (1: idx95));
diff --git a/scripts/plot/pcolor.m b/scripts/plot/pcolor.m
--- a/scripts/plot/pcolor.m
+++ b/scripts/plot/pcolor.m
@@ -50,17 +50,17 @@
 ## Author: Kai Habel <kai.habel@gmx.de>
 
 function h = pcolor (x, y, c)
 
   newplot ();
 
   if (nargin == 1)
     c = x;
-    [nr, nc] = size(c);
+    [nr, nc] = size (c);
     z = zeros (nr, nc);
     [x, y] = meshgrid (1:nc, 1:nr);
   elseif (nargin == 3)
     z = zeros (size (c));
   else
     print_usage ();
   endif
 
diff --git a/scripts/plot/peaks.m b/scripts/plot/peaks.m
--- a/scripts/plot/peaks.m
+++ b/scripts/plot/peaks.m
@@ -64,19 +64,19 @@ function [X_out, Y_out, Z_out] = peaks (
 
   if (isvector (x) && isvector (y))
     [X, Y] = meshgrid (x, y);
   else
     X = x;
     Y = y;
   endif
 
-  Z = 3 * (1 - X) .^ 2 .* exp(- X .^ 2 - (Y + 1) .^ 2) ...
-      - 10 * (X / 5 - X .^ 3 - Y .^ 5) .* exp(- X .^ 2 - Y .^ 2) ...
-      - 1 / 3 * exp(- (X + 1) .^ 2 - Y .^ 2);
+  Z = 3 * (1 - X) .^ 2 .* exp (- X .^ 2 - (Y + 1) .^ 2) ...
+      - 10 * (X / 5 - X .^ 3 - Y .^ 5) .* exp (- X .^ 2 - Y .^ 2) ...
+      - 1 / 3 * exp (- (X + 1) .^ 2 - Y .^ 2);
 
   if (nargout == 0)
     surf (x, y, Z);
   elseif (nargout == 1)
     X_out = Z;
   else
     X_out = X;
     Y_out = Y;
diff --git a/scripts/plot/plot3.m b/scripts/plot/plot3.m
--- a/scripts/plot/plot3.m
+++ b/scripts/plot/plot3.m
@@ -116,20 +116,20 @@ function retval = plot3 (varargin)
         if (! y_set)
           if (! x_set)
             error ("plot3: needs x, [ y, [ z ] ]");
           else
             z = imag (x);
             y = real (x);
             y_set = 1;
             z_set = 1;
-            if (rows(x) > 1)
-              x = repmat ((1:rows(x))', 1, columns(x));
+            if (rows (x) > 1)
+              x = repmat ((1:rows (x))', 1, columns (x));
             else
-              x = 1:columns(x);
+              x = 1:columns (x);
             endif
           endif
         else
           z = imag (y);
           y = real (y);
           z_set = 1;
         endif
       endif
@@ -159,17 +159,17 @@ function retval = plot3 (varargin)
       if (isvector (x) && isvector (y))
         if (isvector (z))
           x = x(:);
           y = y(:);
           z = z(:);
         elseif (length (x) == rows (z) && length (y) == columns (z))
           [x, y] = meshgrid (x, y);
         else
-          error ("plot3: [length(x), length(y)] must match size(z)");
+          error ("plot3: [length(x), length(y)] must match size (z)");
         endif
       endif
 
       if (! size_equal (x, y, z))
         error ("plot3: x, y, and z must have the same shape");
       elseif (ndims (x) > 2)
         error ("plot3: x, y, and z must not have more than two dimensions");
       endif
@@ -213,17 +213,17 @@ function retval = plot3 (varargin)
       if (isvector (x) && isvector (y))
         if (isvector (z))
           x = x(:);
           y = y(:);
           z = z(:);
         elseif (length (x) == rows (z) && length (y) == columns (z))
           [x, y] = meshgrid (x, y);
         else
-          error ("plot3: [length(x), length(y)] must match size(z)");
+          error ("plot3: [length(x), length(y)] must match size (z)");
         endif
       endif
 
       if (! size_equal (x, y, z))
         error ("plot3: x, y, and z must have the same shape");
       elseif (ndims (x) > 2)
         error ("plot3: x, y, and z must not have more than two dimensions");
       endif
@@ -273,31 +273,31 @@ function retval = plot3 (varargin)
         z_set = 1;
       endif
     else
       z = imag (x);
       y = real (x);
       y_set = 1;
       z_set = 1;
       if (rows (x) > 1)
-        x = repmat ((1:rows (x))', 1, columns(x));
+        x = repmat ((1:rows (x))', 1, columns (x));
       else
-        x = 1:columns(x);
+        x = 1:columns (x);
       endif
     endif
 
     if (isvector (x) && isvector (y))
       if (isvector (z))
         x = x(:);
         y = y(:);
         z = z(:);
       elseif (length (x) == rows (z) && length (y) == columns (z))
         [x, y] = meshgrid (x, y);
       else
-        error ("plot3: [length(x), length(y)] must match size(z)");
+        error ("plot3: [length(x), length(y)] must match size (z)");
       endif
     endif
 
     if (! size_equal (x, y, z))
       error ("plot3: x, y, and z must have the same shape");
     elseif (ndims (x) > 2)
       error ("plot3: x, y, and z must not have more than two dimensions");
     endif
diff --git a/scripts/plot/plotmatrix.m b/scripts/plot/plotmatrix.m
--- a/scripts/plot/plotmatrix.m
+++ b/scripts/plot/plotmatrix.m
@@ -140,17 +140,17 @@ function [h, ax, p, pax, need_usage] = _
   elseif (nargin == 3)
     X = varargin{1};
     Y = varargin{2};
   else
     need_usage = true;
     returm;
   endif
 
-  if (rows(X) != rows(Y))
+  if (rows (X) != rows (Y))
     error ("plotmatrix: dimension mismatch in the arguments");
   endif
 
   [dummy, m] = size (X);
   [dummy, n] = size (Y);
 
   h = [];
   ax = [];
diff --git a/scripts/plot/plotyy.m b/scripts/plot/plotyy.m
--- a/scripts/plot/plotyy.m
+++ b/scripts/plot/plotyy.m
@@ -51,18 +51,18 @@
 ## ylabel (ax(2), "Axis 2");
 ## @end group
 ## @end example
 ## @end deftypefn
 
 function [Ax, H1, H2] = plotyy (varargin)
 
   ## Don't use __plt_get_axis_arg__ here as ax is a two vector for plotyy
-  if (nargin > 1 && length (varargin{1}) == 2 && ishandle(varargin{1}(1))
-      && ishandle(varargin{1}(2))
+  if (nargin > 1 && length (varargin{1}) == 2 && ishandle (varargin{1}(1))
+      && ishandle (varargin{1}(2))
       && all (floor (varargin{1}) != varargin{1}))
     obj1 = get (varargin{1}(1));
     obj2 = get (varargin{1}(2));
     if (strcmp (obj1.type, "axes") || strcmp (obj2.type, "axes"))
       ax = [obj1, obj2];
       varargin(1) = [];
       if (isempty (varargin))
         varargin = {};
@@ -106,17 +106,17 @@ function [Ax, H1, H2] = plotyy (varargin
   if (nargin < 4)
     print_usage ();
   endif
 
   unwind_protect
     [ax, h1, h2] = __plotyy__ (ax, varargin{:});
   unwind_protect_cleanup
     ## Only change back to the old axis if we didn't delete it
-    if (ishandle(oldh) && strcmp (get (oldh, "type"), "axes"))
+    if (ishandle (oldh) && strcmp (get (oldh, "type"), "axes"))
       axes (oldh);
     endif
   end_unwind_protect
 
   if (nargout > 0)
     Ax = ax;
     H1 = h1;
     H2 = h2;
@@ -133,32 +133,32 @@ function [ax, h1, h2] = __plotyy__ (ax, 
   if (nargin > 6)
     fun2 = varargin{2};
   else
     fun2 = fun1;
   endif
 
   xlim = [min([x1(:); x2(:)]), max([x1(:); x2(:)])];
 
-  if (ishandle(ax(1)) && strcmp (get (ax(1), "type"), "axes"))
+  if (ishandle (ax(1)) && strcmp (get (ax(1), "type"), "axes"))
     axes (ax(1));
   else
     ax(1) = axes ();
   endif
   newplot ();
   h1 = feval (fun1, x1, y1);
 
   set (ax(1), "ycolor", getcolor (h1(1)));
   set (ax(1), "xlim", xlim);
   set (ax(1), "color", "none");
 
   cf = gcf ();
   set (cf, "nextplot", "add");
 
-  if (ishandle(ax(2)) && strcmp (get (ax(2), "type"), "axes"))
+  if (ishandle (ax(2)) && strcmp (get (ax(2), "type"), "axes"))
     axes (ax(2));
   else
     ax(2) = axes ();
     set (ax(2), "nextplot", get (ax(1), "nextplot"))
   endif
   newplot ();
 
   colors = get (ax(1), "colororder");
diff --git a/scripts/plot/polar.m b/scripts/plot/polar.m
--- a/scripts/plot/polar.m
+++ b/scripts/plot/polar.m
@@ -50,31 +50,31 @@ function retval = polar (varargin)
       if (! ischar (varargin{3}))
         error ("polar: third argument must be a string");
       endif
       tmp = __plr2__ (h, varargin{:});
       maxr = max (varargin {2} (:));
     elseif (nargs == 2)
       if (ischar (varargin{2}))
         tmp = __plr1__ (h, varargin{:});
-        if (iscomplex(varargin{1}))
-          maxr = max (imag(varargin{1})(:));
+        if (iscomplex (varargin{1}))
+          maxr = max (imag (varargin{1})(:));
         else
           maxr = max (varargin{1}(:));
         endif
       else
         fmt = "";
         tmp = __plr2__ (h, varargin{:}, fmt);
         maxr = max (varargin {2} (:));
       endif
     elseif (nargs == 1)
       fmt = "";
       tmp = __plr1__ (h, varargin{:}, fmt);
-      if (iscomplex(varargin{1}))
-        maxr = max (imag(varargin{1})(:));
+      if (iscomplex (varargin{1}))
+        maxr = max (imag (varargin{1})(:));
       else
         maxr = max (varargin{1}(:));
       endif
     else
       print_usage ();
     endif
 
     set (h, "xlim", [-maxr, maxr], "ylim", [-maxr, maxr],
diff --git a/scripts/plot/print.m b/scripts/plot/print.m
--- a/scripts/plot/print.m
+++ b/scripts/plot/print.m
@@ -328,112 +328,112 @@ function print (varargin)
     props(3).h = opts.figure;
     props(3).name = "color";
     props(3).value{1} = get (props(3).h, props(3).name);
     set (props(3).h, "color", "none");
 
     if (opts.force_solid != 0)
       h = findall (opts.figure, "-property", "linestyle");
       m = numel (props);
-      for n = 1:numel(h)
+      for n = 1:numel (h)
         props(m+n).h = h(n);
         props(m+n).name = "linestyle";
         props(m+n).value = {get(h(n), "linestyle")};
       endfor
       if (opts.force_solid > 0)
         linestyle = "-";
       else
         linestyle = "--";
       endif
       set (h, "linestyle", linestyle);
     endif
 
     if (opts.use_color < 0
         && ! strcmp (get (opts.figure, "__graphics_toolkit__"), "gnuplot"))
       color_props = {"color", "facecolor", "edgecolor", "colormap"};
-      for c = 1:numel(color_props)
+      for c = 1:numel (color_props)
         h = findall (opts.figure, "-property", color_props{c});
         hnone = findall (opts.figure, color_props{c}, "none");
         h = setdiff (h, hnone);
         m = numel (props);
-        for n = 1:numel(h)
+        for n = 1:numel (h)
           if (ishandle (h(n)))
             ## Need to verify objects exist since callbacks may delete objects
             ## as the colors for others are modified.
             rgb = get (h(n), color_props{c});
             props(end+1).h = h(n);
             props(end).name = color_props{c};
             props(end).value = {get(h(n), color_props{c})};
             if (isnumeric (rgb))
               ## convert RGB color to RGB gray scale
-              xfer = repmat ([0.30, 0.59, 0.11], size (rgb, 1), 1);
+              xfer = repmat ([0.30, 0.59, 0.11], rows (rgb), 1);
               ggg = repmat (sum (xfer .* rgb, 2), 1, 3);
               set (h(n), color_props{c}, ggg);
             endif
           endif
         endfor
       endfor
     endif
 
     if (! isempty (opts.font) || ! isempty (opts.fontsize))
       h = findall (opts.figure, "-property", "fontname");
       m = numel (props);
-      for n = 1:numel(h)
+      for n = 1:numel (h)
         if (ishandle (h(n)))
           if (! isempty (opts.font))
             props(end+1).h = h(n);
             props(end).name = "fontname";
             props(end).value = {get(h(n), "fontname")};
           endif
         endif
         if (ishandle (h(n)))
           if (! isempty (opts.fontsize))
             props(end+1).h = h(n);
             props(end).name = "fontsize";
             props(end).value = {get(h(n), "fontsize")};
           endif
         endif
       endfor
       if (! isempty (opts.font))
-        set (h(ishandle(h)), "fontname", opts.font);
+        set (h(ishandle (h)), "fontname", opts.font);
       endif
       if (! isempty (opts.fontsize))
         if (ischar (opts.fontsize))
           fontsize = str2double (opts.fontsize);
         else
           fontsize = opts.fontsize;
         endif
         if (! isempty (opts.scalefontsize) && ! opt.scalefontsize != 1)
           ## This is done to work around the bbox being whole numbers.
           fontsize = fontsize * opts.scalefontsize;
         endif
-        set (h(ishandle(h)), "fontsize", fontsize);
+        set (h(ishandle (h)), "fontsize", fontsize);
       endif
     endif
 
     ## call the graphcis toolkit print script
     switch (get (opts.figure, "__graphics_toolkit__"))
     case "gnuplot"
       opts = __gnuplot_print__ (opts);
     otherwise
       opts = __fltk_print__ (opts);
     endswitch
 
   unwind_protect_cleanup
     ## restore modified properties
     if (isstruct (props))
-      for n = numel(props):-1:1
+      for n = numel (props):-1:1
         if (ishandle (props(n).h))
           set (props(n).h, props(n).name, props(n).value{1});
         endif
       endfor
     endif
 
     ## Unlink temporary files
-    for n = 1:numel(opts.unlink)
+    for n = 1:numel (opts.unlink)
       [status, output] = unlink (opts.unlink{n});
       if (status != 0)
         warning ("print.m: %s, '%s'", output, opts.unlink{n});
       endif
     endfor
   end_unwind_protect
 
   if (isfigure (orig_figure))
diff --git a/scripts/plot/private/__add_datasource__.m b/scripts/plot/private/__add_datasource__.m
--- a/scripts/plot/private/__add_datasource__.m
+++ b/scripts/plot/private/__add_datasource__.m
@@ -34,17 +34,17 @@ function newargs = __add_datasource__ (f
   for i = 1 : numel (data)
     addproperty (strcat (data{i}, "datasource"), h, "string", "");
   endfor
 
   i = 0;
   newargs = {};
   while (i < numel (varargin))
     arg = varargin{++i};
-    if (i != numel(varargin) && ischar (arg)
+    if (i != numel (varargin) && ischar (arg)
         && length (arg) > 9 && strcmpi (arg(end-9:end), "datasource"))
       arg = tolower (arg);
       val = varargin{++i};
       if (ischar (val))
         set (h, arg, val);
       else
         error ("%s: expecting data source to be a string", fcn);
       endif
diff --git a/scripts/plot/private/__add_default_menu__.m b/scripts/plot/private/__add_default_menu__.m
--- a/scripts/plot/private/__add_default_menu__.m
+++ b/scripts/plot/private/__add_default_menu__.m
@@ -93,17 +93,17 @@ function __save_as__ (caller)
 endfunction
 
 function autoscale_cb (h, e)
   axis ("auto");
   drawnow; #should not be required
 endfunction
 
 function guimode_cb (h, e)
-  lbl = get(h, "label");
-  if (strncmp(lbl, "Pan+Zoom", 8))
-    gui_mode("2D");
-  elseif (strncmp(lbl, "Rotate+Zoom", 11))
-    gui_mode("3D");
-  elseif (strncmp(lbl, "None", 4))
-    gui_mode("None");
+  lbl = get (h, "label");
+  if (strncmp (lbl, "Pan+Zoom", 8))
+    gui_mode ("2D");
+  elseif (strncmp (lbl, "Rotate+Zoom", 11))
+    gui_mode ("3D");
+  elseif (strncmp (lbl, "None", 4))
+    gui_mode ("None");
   endif
 endfunction
diff --git a/scripts/plot/private/__axes_limits__.m b/scripts/plot/private/__axes_limits__.m
--- a/scripts/plot/private/__axes_limits__.m
+++ b/scripts/plot/private/__axes_limits__.m
@@ -36,17 +36,17 @@ function retval = __axes_limits__ (fcn, 
 
     if (ischar (arg))
       if (strcmpi (arg, "mode"))
         retval = get (h, fcnmode);
       elseif (strcmpi (arg, "auto") ||  strcmpi (arg, "manual"))
         set (h, fcnmode, arg);
       endif
     else
-      if (!isnumeric (arg) && any (size(arg(:)) != [2, 1]))
+      if (!isnumeric (arg) && any (size (arg(:)) != [2, 1]))
         error ("%s: argument must be a 2 element vector", fcn);
       else
         if (arg(1) >= arg(2))
           error ("%s: axis limits must be increasing", fcn);
         else
           set (h, fcn, arg(:));
         endif
       endif
diff --git a/scripts/plot/private/__bar__.m b/scripts/plot/private/__bar__.m
--- a/scripts/plot/private/__bar__.m
+++ b/scripts/plot/private/__bar__.m
@@ -40,35 +40,35 @@ function varargout = __bar__ (vertical, 
     x = varargin{1};
     if (isvector (x))
       x = x(:);
     endif
     y = varargin{2};
     if (isvector (y))
       y = y(:);
     endif
-    if (size (x, 1) != size (y, 1))
+    if (rows (x) != rows (y))
       y = varargin{1};
       if (isvector (y))
         y = y(:);
       endif
-      x = [1:size(y,1)]';
+      x = [1:rows(y)]';
       idx = 2;
     else
       if (! isvector (x))
         error ("%s: x must be a vector", func);
       endif
       idx = 3;
     endif
   else
     y = varargin{1};
     if (isvector (y))
       y = y(:);
     endif
-    x = [1:size(y,1)]';
+    x = [1:rows(y)]';
     idx = 2;
   endif
 
   newargs = {};
   have_line_spec = false;
   while (idx <= nargin - 2)
     if (ischar (varargin{idx}) && strcmpi (varargin{idx}, "grouped"))
       group = true;
@@ -84,45 +84,45 @@ function varargout = __bar__ (vertical, 
           have_line_spec = true;
           ## FIXME: strange parse error requires semicolon to be spaced
           ##        away from closing ']' on next line.
           newargs = [{"facecolor", linespec.color}, newargs] ;
           idx++;
           continue;
         endif
       endif
-      if (isscalar(varargin{idx}))
+      if (isscalar (varargin{idx}))
         width = varargin{idx++};
       elseif (idx == nargin - 2)
         newargs = [newargs,varargin(idx++)];
       elseif (ischar (varargin{idx})
               && strcmpi (varargin{idx}, "basevalue")
               && isscalar (varargin{idx+1}))
         bv = varargin{idx+1};
         idx += 2;
       else
         newargs = [newargs,varargin(idx:idx+1)];
         idx += 2;
       endif
     endif
   endwhile
 
-  xlen = size (x, 1);
-  ylen = size (y, 1);
+  xlen = rows (x);
+  ylen = rows (y);
 
   if (xlen != ylen)
     error ("%s: length of x and y must be equal", func);
   endif
   if (any (x(2:end) < x(1:end-1)))
     error ("%s: x vector values must be in ascending order", func);
   endif
 
-  ycols = size (y, 2);
+  ycols = columns (y);
   if (numel (x) > 1)
-    cutoff = min (diff (double(x))) / 2;
+    cutoff = min (diff (double (x))) / 2;
   else
     cutoff = 1;
   endif
   if (group)
     delta_p = delta_m = repmat (cutoff * width / ycols, size (x));
   else
     delta_p = delta_m = repmat (cutoff * width, size (x));
   endif
@@ -134,17 +134,17 @@ function varargout = __bar__ (vertical, 
     offset = ((delta_p + delta_m) * [-(ycols - 1) / 2 : (ycols - 1) / 2]);
     xb(1:4:4*ylen,:) += offset;
     xb(2:4:4*ylen,:) += offset;
     xb(3:4:4*ylen,:) += offset;
     xb(4:4:4*ylen,:) += offset;
     y0 = zeros (size (y)) + bv;
     y1 = y;
   else
-    y1 = cumsum(y,2);
+    y1 = cumsum (y,2);
     y0 = [zeros(ylen,1)+bv, y1(:,1:end-1)];
   endif
 
   yb = zeros (4*ylen, ycols);
   yb(1:4:4*ylen,:) = y0;
   yb(2:4:4*ylen,:) = y1;
   yb(3:4:4*ylen,:) = y1;
   yb(4:4:4*ylen,:) = y0;
@@ -191,32 +191,32 @@ function tmp = bars (ax, vertical, x, y,
 
     if (vertical)
       if (! have_color_spec)
         if (ycols == 1)
           lev = clim(1);
         else
           lev = (i - 1) * (clim(2) - clim(1)) / (ycols - 1) - clim(1);
         endif
-        h = patch(xb(:,:,i), yb(:,:,i), "FaceColor", "flat",
-                  "cdata", lev, "parent", hg);
+        h = patch (xb(:,:,i), yb(:,:,i), "FaceColor", "flat",
+                   "cdata", lev, "parent", hg);
       else
-        h = patch(xb(:,:,i), yb(:,:,i), "parent", hg);
+        h = patch (xb(:,:,i), yb(:,:,i), "parent", hg);
       endif
     else
       if (! have_color_spec)
         if (ycols == 1)
           lev = clim(1);
         else
           lev = (i - 1) * (clim(2) - clim(1)) / (ycols - 1) - clim(1);
         endif
-        h = patch(yb(:,:,i), xb(:,:,i), "FaceColor", "flat",
-                  "cdata", lev, "parent", hg);
+        h = patch (yb(:,:,i), xb(:,:,i), "FaceColor", "flat",
+                   "cdata", lev, "parent", hg);
       else
-        h = patch(yb(:,:,i), xb(:,:,i), "parent", hg);
+        h = patch (yb(:,:,i), xb(:,:,i), "parent", hg);
       endif
     endif
 
     if (i == 1)
       x_axis_range = get (ax, "xlim");
       h_baseline = line (x_axis_range, [0, 0], "color", [0, 0, 0]);
       set (h_baseline, "handlevisibility", "off");
       set (h_baseline, "xliminclude", "off");
@@ -398,17 +398,17 @@ endfunction
 function update_group (h, d)
   persistent recursion = false;
 
   ## Don't allow recursion
   if (! recursion)
     unwind_protect
       recursion = true;
       hlist = get (h, "bargroup");
-      barwidth = get(h, "barwidth");
+      barwidth = get (h, "barwidth");
       barlayout = get (h, "barlayout");
       horizontal = get (h, "horizontal");
 
       ## To prevent recursion, only change if modified
       for hh = hlist(:)'
         if (hh != h)
           if (get (hh, "barwidth") != barwidth)
             set (hh, "barwidth", barwidth);
diff --git a/scripts/plot/private/__clabel__.m b/scripts/plot/private/__clabel__.m
--- a/scripts/plot/private/__clabel__.m
+++ b/scripts/plot/private/__clabel__.m
@@ -20,20 +20,20 @@
 ## @deftypefn {Function File} {@var{h} =} __clabel__ (@var{c}, @var{v}, @var{hparent}, @var{label_spacing}, @var{z}, @var{varargin})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function h = __clabel__ (c, v, hparent, label_spacing, z, varargin)
   ## FIXME
   ## Assume that the plot size is 4 by 3 inches.
   lims = axis ();
-  xspacing = 72 * 4 / abs(lims(1) - lims(2));
-  yspacing = 72 * 3 / abs(lims(3) - lims(4));
+  xspacing = 72 * 4 / abs (lims(1) - lims(2));
+  yspacing = 72 * 3 / abs (lims(3) - lims(4));
 
-  if (isscalar (hparent) && ishandle(hparent)
+  if (isscalar (hparent) && ishandle (hparent)
       && strcmp (get (hparent, "type"), "hggroup"))
     x = get (hparent, "xdata");
     xmin = min (x(:));
     xmax = max (x(:));
     y = get (hparent, "ydata");
     ymin = min (y(:));
     ymax = max (y(:));
   else
@@ -62,37 +62,37 @@ function h = __clabel__ (c, v, hparent, 
     if (!isempty (v) && ! any (find (clev == v)))
       i1 += clen+1;
       continue;
     endif
 
     p = c(:, i1+1:i1+clen) .* repmat ([xspacing; yspacing], 1, clen);
     d = sqrt (sumsq (diff (p, 1, 2)));
     cumd = cumsum (d);
-    td = sum(d);
+    td = sum (d);
     ntag = ceil (td / label_spacing);
 
     if (all (c(:,i1+1) == c(:,i1+clen)))
       Spacing = td / ntag;
       pos = Spacing / 2 + [0:ntag-1] * Spacing;
     else
-      pos = zeros(1, ntag);
+      pos = zeros (1, ntag);
       pos(1) = (td - label_spacing * (ntag - 1)) ./ 2;
       pos(2:ntag) = pos(1) + [1:ntag-1] * label_spacing;
     endif
 
     j1 = 2;
     tlabel = sprintf ("%g", clev);
     for i = 1 : ntag
       tagpos = pos(i);
 
       while (j1 < clen && cumd(j1) < tagpos)
         j1++;
       endwhile
-      tpos = sum(c(:,i1+j1-1:i1+j1), 2) ./ 2;
+      tpos = sum (c(:,i1+j1-1:i1+j1), 2) ./ 2;
 
       if (tpos(1) != xmin &&  tpos(1) != xmax
           && tpos(2) != ymin &&  tpos(2) != ymax)
         trot = 180 / pi * atan2 (diff (c(2,i1+j1-1:i1+j1)),
                                  diff (c(1,i1+j1-1:i1+j1)));
 
         if (ischar (z))
           ht = text (tpos(1), tpos(2), clev, tlabel, "rotation", trot,
@@ -107,9 +107,9 @@ function h = __clabel__ (c, v, hparent, 
                      "parent", hparent, "horizontalalignment", "center",
                      "userdata", clev, varargin{:});
         endif
         h = [h; ht];
       endif
     endfor
     i1 += clen+1;
   endwhile
-endfunction
\ No newline at end of file
+endfunction
diff --git a/scripts/plot/private/__contour__.m b/scripts/plot/private/__contour__.m
--- a/scripts/plot/private/__contour__.m
+++ b/scripts/plot/private/__contour__.m
@@ -74,20 +74,20 @@ function [c, hg] = __contour__ (varargin
         opts{end+1} = varargin{i};
         varargin(i) = [];
       endif
     else
       i++;
     endif
   endwhile
 
-  if (length(varargin) < 5)
+  if (length (varargin) < 5)
     z1 = varargin{3};
-    x1 = 1 : columns(z1);
-    y1 = 1 : rows(z1);
+    x1 = 1 : columns (z1);
+    y1 = 1 : rows (z1);
   else
     x1 = varargin{3};
     y1 = varargin{4};
     z1 = varargin{5};
   endif
   if (!ismatrix (z1) || isvector (z1) || isscalar (z1))
     error ("__contour__: z argument must be a matrix");
   endif
@@ -95,34 +95,34 @@ function [c, hg] = __contour__ (varargin
     vn = varargin {end};
     vnauto = false;
   else
     vnauto = true;
     vn = 10;
   endif
 
   if (isscalar (vn))
-    lvl = linspace (min (z1(!isinf(z1))), max (z1(!isinf(z1))),
+    lvl = linspace (min (z1(!isinf (z1))), max (z1(!isinf (z1))),
                     vn + 2)(1:end-1);
   else
     lvl = vn;
   endif
 
   if (strcmpi (filled, "on"))
     if (isvector (x1) || isvector (y1))
       [x1, y1] = meshgrid (x1, y1);
     endif
     [nr, nc] = size (z1);
-    x0 = prepad(x1, nc+1, 2 * x1(1, 1) - x1(1, 2), 2);
-    x0 = postpad(x0, nc+2, 2 * x1(1, nc) - x1(1, nc - 1), 2);
+    x0 = prepad (x1, nc+1, 2 * x1(1, 1) - x1(1, 2), 2);
+    x0 = postpad (x0, nc+2, 2 * x1(1, nc) - x1(1, nc - 1), 2);
     x0 = [x0(1, :); x0; x0(1, :)];
-    y0 = prepad(y1, nr+1, 2 * y1(1, 1) - y1(2, 1), 1);
-    y0 = postpad(y0, nr+2, 2 * y1(nr, 1) - y1(nr - 1, 1));
+    y0 = prepad (y1, nr+1, 2 * y1(1, 1) - y1(2, 1), 1);
+    y0 = postpad (y0, nr+2, 2 * y1(nr, 1) - y1(nr - 1, 1));
     y0 = [y0(:, 1), y0, y0(:, 1)];
-    z0 = -Inf(nr+2, nc+2);
+    z0 = -Inf (nr+2, nc+2);
     z0(2:nr+1, 2:nc+1) = z1;
     [c, lev] = contourc (x0, y0, z0, lvl);
   else
     [c, lev] = contourc (x1, y1, z1, lvl);
   endif
 
   hg = hggroup ();
   opts = __add_datasource__ ("__countour__", hg, {"x", "y", "z"}, opts{:});
@@ -206,17 +206,17 @@ function [c, hg] = __contour__ (varargin
   addlistener (hg, "linecolor", @update_line);
   addlistener (hg, "linestyle", @update_line);
   addlistener (hg, "linewidth", @update_line);
 
   addlistener (hg, "edgecolor", @update_edgecolor);
 
   add_patch_children (hg);
 
-  axis("tight");
+  axis ("tight");
 
   if (!isempty (opts))
     set (hg, opts{:});
   endif
 endfunction
 
 function add_patch_children (hg)
   c = get (hg, "contourmatrix");
@@ -253,17 +253,17 @@ function add_patch_children (hg)
 
     ## Handle for each level the case where we have (a) hole(s) in a patch.
     ## Those are to be filled with the color of level below or with the
     ## background colour.
     for k = 1:numel (lev)
       lvl_idx = find (abs (cont_lev - lev(k)) < lvl_eps);
       len = numel (lvl_idx);
       if (len > 1)
-        ## mark = logical(zeros(size(lvl_idx)));
+        ## mark = logical (zeros (size (lvl_idx)));
         mark = false (size (lvl_idx));
         a = 1;
         while (a < len)
           ## take 1st patch
           b = a + 1;
           pa_idx = lvl_idx(a);
           ## get pointer to contour start, and contour length
           curr_ct_idx = cont_idx(pa_idx);
@@ -278,17 +278,17 @@ function add_patch_children (hg)
           a++;
         endwhile
         if (numel (mark) > 0)
           ## All marked contours describe a hole in a larger contour of
           ## the same level and must be filled with colour of level below.
           ma_idx = lvl_idx(mark);
           if (k > 1)
             ## Find color of level below.
-            tmp = find(abs(cont_lev - lev(k - 1)) < lvl_eps);
+            tmp = find (abs (cont_lev - lev(k - 1)) < lvl_eps);
             lvl_bel_idx = tmp(1);
             ## Set color of patches found.
             cont_lev(ma_idx) = cont_lev(lvl_bel_idx);
           else
             ## Set lowest level contour to NaN.
             cont_lev(ma_idx) = NaN;
           endif
         endif
@@ -314,17 +314,17 @@ function add_patch_children (hg)
     for n = len:(-1):1
       idx = svec(n);
       ctmp = c(:, cont_idx(idx):cont_idx(idx) + cont_len(idx) - 1);
       if (all (ctmp(:,1) == ctmp(:,end)))
         ctmp(:, end) = [];
       else
         ## Special case unclosed contours
       endif
-      if (isnan(cont_lev(idx)))
+      if (isnan (cont_lev (idx)))
         fc = get (ca, "color");
         if (strcmp (fc, "none"))
           fc = get (ancestor (ca, "figure"), "color");
         endif
       else
         fc = "flat";
       endif
       h = [h; __go_patch__(ca, "xdata", ctmp(1, :)(:), "ydata", ctmp(2, :)(:),
@@ -453,39 +453,39 @@ function update_data (h, d)
     if (strcmpi (get (h, "fill"), "on"))
       X = get (h, "xdata");
       Y = get (h, "ydata");
       Z = get (h, "zdata");
       if (isvector (X) || isvector (Y))
         [X, Y] = meshgrid (X, Y);
       endif
       [nr, nc] = size (Z);
-      X0 = prepad(X, nc+1, 2 * X(1, 1) - X(1, 2), 2);
-      X0 = postpad(X0, nc+2, 2 * X(1, nc) - X(1, nc - 1), 2);
+      X0 = prepad (X, nc+1, 2 * X(1, 1) - X(1, 2), 2);
+      X0 = postpad (X0, nc+2, 2 * X(1, nc) - X(1, nc - 1), 2);
       X0 = [X0(1, :); X0; X0(1, :)];
-      Y0 = prepad(Y, nr+1, 2 * Y(1, 1) - Y(2, 1), 1);
-      Y0 = postpad(Y0, nr+2, 2 * Y(nr, 1) - Y(nr - 1, 1));
+      Y0 = prepad (Y, nr+1, 2 * Y(1, 1) - Y(2, 1), 1);
+      Y0 = postpad (Y0, nr+2, 2 * Y(nr, 1) - Y(nr - 1, 1));
       Y0 = [Y0(:, 1), Y0, Y0(:, 1)];
-      Z0 = -Inf(nr+2, nc+2);
+      Z0 = -Inf (nr+2, nc+2);
       Z0(2:nr+1, 2:nc+1) = Z;
       [c, lev] = contourc (X0, Y0, Z0, lvl);
     else
       [c, lev] = contourc (get (h, "xdata"), get (h, "ydata"),
                            get (h, "zdata"), lvl);
     endif
     set (h, "contourmatrix", c);
 
     if (strcmpi (get (h, "levellistmode"), "manual"))
       ## Do nothing
     elseif (strcmpi (get (h, "levelstepmode"), "manual"))
       set (h, "levellist", lev);
     else
       set (h, "levellist", lev);
       z = get (h, "zdata");
-      lvlstep = (max(z(:)) - min(z(:))) / 10;
+      lvlstep = (max (z(:)) - min (z(:))) / 10;
       set (h, "levelstep", lvlstep);
     endif
 
     add_patch_children (h);
     update_text (h, d);
   endif
 
   recursive = false;
diff --git a/scripts/plot/private/__errcomm__.m b/scripts/plot/private/__errcomm__.m
--- a/scripts/plot/private/__errcomm__.m
+++ b/scripts/plot/private/__errcomm__.m
@@ -29,17 +29,17 @@ function retval = __errcomm__ (caller, p
 
   if (nargin < 4)
     print_usage ();
   endif
 
   nargs = length (varargin);
   retval = [];
   k = 1;
-  data = cell(6,1);
+  data = cell (6,1);
   while (k <= nargs)
     a = varargin{k++};
     if (isvector (a))
       a = a(:);
     elseif (ismatrix (a))
       ;
     else
       usage ("%s (...)", caller);
diff --git a/scripts/plot/private/__errplot__.m b/scripts/plot/private/__errplot__.m
--- a/scripts/plot/private/__errplot__.m
+++ b/scripts/plot/private/__errplot__.m
@@ -66,17 +66,17 @@ function h = __errplot__ (fstr, p, varar
     if (isempty (fmt.marker) && isempty (fmt.linestyle))
       [fmt.linestyle, fmt.marker] = __next_line_style__ ();
     endif
     hl = [(__line__ (hg, "linestyle", fmt.linestyle, "marker", fmt.marker,
                    "color", fmt.color)),
           (__line__ (hg, "linestyle", "-", "marker", "none",
                    "color", fmt.color))];
 
-    switch (numel(varargin))
+    switch (numel (varargin))
       case 2
         ydata = varargin{1}(:,i);
         xdata = 1:numel (ydata);
         if (strcmp (ifmt, "xerr") || strcmp (ifmt, "box"))
           xldata = varargin{2}(:,i);
           xudata = ldata;
           ldata = [];
           udata = [];
@@ -227,27 +227,27 @@ function [xdata, ydata] = errorbar_data 
                                          xldata, xudata, ifmt,
                                          xscale, yscale)
   if (strcmp (xscale, "linear"))
     dx = 0.01 * (max (xdata(:)) - min (xdata(:)));
     xlo = xdata - dx;
     xhi = xdata + dx;
   else
     n = xdata > 0;
-    rx = exp(0.01 * (max (log(xdata(n))) - min (log(xdata(n)))));
+    rx = exp (0.01 * (max (log (xdata(n))) - min (log (xdata(n)))));
     xlo = xdata/rx;
     xhi = xdata*rx;
   endif
   if (strcmp (yscale, "linear"))
     dy = 0.01 * (max (ydata(:)) - min (ydata(:)));
     ylo = ydata - dy;
     yhi = ydata + dy;
   else
     n = ydata > 0;
-    ry = exp(0.01 * (max (log(ydata(n))) - min (log(ydata(n)))));
+    ry = exp (0.01 * (max (log (ydata(n))) - min (log (ydata(n)))));
     ylo = ydata/ry;
     yhi = ydata*ry;
   endif
   nans = NaN + xdata(:);
   if (strcmp (ifmt, "yerr"))
     xdata = [xdata, xdata, nans, ...
              xlo, xhi, nans, ...
              xlo, xhi, nans];
diff --git a/scripts/plot/private/__ezplot__.m b/scripts/plot/private/__ezplot__.m
--- a/scripts/plot/private/__ezplot__.m
+++ b/scripts/plot/private/__ezplot__.m
@@ -69,56 +69,56 @@ function [h, needusage] = __ezplot__ (pf
     endif
     if (isplot && length (argnames (fun)) == 2)
       nargs = 2;
     elseif (length (argnames (fun)) != nargs)
       error ("%s: excepting a function of %d arguments", func, nargs);
     endif
     fstr = formula (fun);
     if (isplot)
-      xarg = argnames(fun){1};
+      xarg = (argnames (fun)){1};
       if (nargs == 2)
-        yarg = argnames(fun){2};
+        yarg = (argnames (fun)){2};
       else
         yarg = "";
       endif
     elseif (isplot3)
       xarg = "x";
       yarg = "y";
     elseif (ispolar)
       xarg = "";
       yarg = "";
     else
-      xarg = argnames(fun){1};
-      yarg = argnames(fun){2};
+      xarg = (argnames (fun)){1};
+      yarg = (argnames (fun)){2};
     endif
   elseif (strcmp (typeinfo (fun), "inline function"))
     if (isplot && length (argnames (fun)) == 2)
       nargs = 2;
     elseif (length (argnames (fun)) != nargs)
       error ("%s: excepting a function of %d arguments", func, nargs);
     endif
     fun = vectorize (fun);
     fstr = formula (fun);
     if (isplot)
-      xarg = argnames(fun){1};
+      xarg = (argnames (fun)){1};
       if (nargs == 2)
-        yarg = argnames(fun){2};
+        yarg = (argnames (fun)){2};
       else
         yarg = "";
       endif
     elseif (isplot3)
       xarg = "x";
       yarg = "y";
     elseif (isplot || ispolar)
       xarg = "";
       yarg = "";
     else
-      xarg = argnames(fun)(1);
-      yarg = argnames(fun)(2);
+      xarg = (argnames (fun))(1);
+      yarg = (argnames (fun))(2);
     endif
   elseif (isa (fun, "function_handle"))
     fstr = func2str (fun);
     if (! isempty (strfind (fstr, ')')))
       args = regexp (substr (fstr, 3, strfind (fstr, ')')(1) - 3),
                      '(\w+)', 'tokens');
     fstr = substr (fstr, strfind (fstr, ')')(1) + 1);
     else
@@ -387,20 +387,20 @@ function [h, needusage] = __ezplot__ (pf
         if (length (X) > 4)
           d = XX(fix (7 * length (XX) / 8)) - XX(fix (length (XX) / 8));
           yrange = [max(XX(1) - d/8, XX(fix (length (XX) / 8)) - d), ...
                     min(XX(end) + d/8, XX(fix (7 * length (XX) / 8)) + d)];
         else
           yrange = [XX(1), XX(end)];
         endif
 
-        idx = 2 : length(Z);
+        idx = 2 : length (Z);
         idx = find (((Z(idx) > yrange(2) / 2) & (Z(idx-1) < yrange(1) / 2)) |
                  ((Z(idx) < yrange(1) / 2) & (Z(idx-1) > yrange (2) / 2)));
-        if (any(idx))
+        if (any (idx))
           Z(idx) = NaN;
         endif
       else
         Z = feval (fun, X, Y);
 
         ## Eliminate the singularities
         Z = __eliminate_sing__ (Z);
       endif
@@ -436,10 +436,10 @@ function [h, needusage] = __ezplot__ (pf
   unwind_protect_cleanup
     axes (oldax);
   end_unwind_protect
 
 endfunction
 
 function x = __eliminate_sing__ (x)
   x (isinf (x)) = NaN;
-  x (abs (del2 (x)) > 0.2 * (max(x(:)) - min(x(:)))) = NaN;
+  x (abs (del2 (x)) > 0.2 * (max (x(:)) - min (x(:)))) = NaN;
 endfunction
diff --git a/scripts/plot/private/__file_filter__.m b/scripts/plot/private/__file_filter__.m
--- a/scripts/plot/private/__file_filter__.m
+++ b/scripts/plot/private/__file_filter__.m
@@ -76,17 +76,17 @@ function name = __default_filtername__ (
       name = "C Source Files";
     case {"*.cc" "*.c++" "*.cpp"}
       name = "C++ Source Files";
     case "*.oct"
       name = "Octave Compiled Files";
   endswitch
 
   if (isempty (name))
-    extlist = strsplit(filterext, ";");
+    extlist = strsplit (filterext, ";");
     extlist = strrep (extlist, "*.", "");
     extlist = toupper (extlist);
     extlist(end+1, :) = repmat ({","}, 1, length (extlist));
     extlist = strcat (extlist{:});
     extlist = extlist(1:end-1);
     name = strcat (extlist, "-Files");
   endif
 
diff --git a/scripts/plot/private/__fltk_print__.m b/scripts/plot/private/__fltk_print__.m
--- a/scripts/plot/private/__fltk_print__.m
+++ b/scripts/plot/private/__fltk_print__.m
@@ -120,19 +120,19 @@ function opts = __fltk_print__ (opts)
     opts.ghostscript.output = opts.name;
     if (opts.send_to_printer)
       opts.unlink(strcmp (opts.unlink, opts.ghostscript.output)) = [];
       opts.ghostscript.output = "-";
     endif
     [cmd_gs, cmd_cleanup] = __ghostscript__ (opts.ghostscript);
     if (opts.send_to_printer || isempty (opts.name))
       cmd_lpr = opts.lpr_cmd (opts);
-      cmd = sprintf("%s | %s", cmd_gs, cmd_lpr);
+      cmd = sprintf ("%s | %s", cmd_gs, cmd_lpr);
     else
-      cmd = sprintf("%s", cmd_gs);
+      cmd = sprintf ("%s", cmd_gs);
     endif
     if (! isempty (cmd_cleanup))
       gl2ps_device = {"eps"};
       if (dos_shell)
         pipeline = {sprintf("%s & %s", cmd, cmd_cleanup)};
       else
         pipeline = {sprintf("%s ; %s", cmd, cmd_cleanup)};
       endif
@@ -154,21 +154,21 @@ function opts = __fltk_print__ (opts)
   if (iscell (vw))
     vw = vertcat (vw{:});
   endif
   is2D = all (abs (vw(:,2)) == 90);
   if (is2D)
     gl2ps_device{end} = [gl2ps_device{end}, "is2D"];
   endif
 
-  for n = 1:numel(pipeline)
+  for n = 1:numel (pipeline)
     if (opts.debug)
       fprintf ("fltk-pipeline: '%s'\n", pipeline{n});
     endif
-    drawnow (gl2ps_device{n}, strcat('|',pipeline{n}));
+    drawnow (gl2ps_device{n}, strcat ('|',pipeline{n}));
   endfor
 
   if (! isempty (strfind (opts.devopt, "standalone")))
     opts.latex_standalone (opts);
   endif
 
 endfunction
 
diff --git a/scripts/plot/private/__ghostscript__.m b/scripts/plot/private/__ghostscript__.m
--- a/scripts/plot/private/__ghostscript__.m
+++ b/scripts/plot/private/__ghostscript__.m
@@ -44,22 +44,22 @@ function [gs_cmd, cleanup_cmd] = __ghost
   offsetfile = "";
   offset_ps = {};
   cleanup_cmd = "";
 
   args = varargin;
   n = find (cellfun ("isclass", args, "struct"));
   if (! isempty (n))
     f = fieldnames (args{n});
-    for m = 1:numel(f)
+    for m = 1:numel (f)
       opts.(f{m}) = args{n}.(f{m});
     endfor
     args(n) = [];
   endif
-  for n = 1:2:numel(args)
+  for n = 1:2:numel (args)
     opts.(args{n}) = args{n+1};
   endfor
 
   if (isempty (opts.papersize))
     format_for_printer = false;
   else
     format_for_printer = true;
   endif
diff --git a/scripts/plot/private/__gnuplot_print__.m b/scripts/plot/private/__gnuplot_print__.m
--- a/scripts/plot/private/__gnuplot_print__.m
+++ b/scripts/plot/private/__gnuplot_print__.m
@@ -146,17 +146,17 @@ function opts = __gnuplot_print__ (opts)
     error (sprintf ("print:no%soutput", opts.devopt),
            "print.m: %s output is not available for the Gnuplot graphics toolkit",
            upper (opts.devopt));
   endswitch
 
 
   opts.pipeline = pipeline;
 
-  for n = 1:numel(pipeline)
+  for n = 1:numel (pipeline)
     if (opts.debug)
       fprintf ("gnuplot-pipeline: '%s'\n", pipeline{n});
     endif
     [status, output] = system (pipeline{n});
     if (status)
       fprintf ("%s\n%s\n%s\n",
                "---------- output begin ----------",
                output,
@@ -165,22 +165,22 @@ function opts = __gnuplot_print__ (opts)
     endif
   endfor
 
 endfunction
 
 function eps_drawnow (opts, epsfile, gp_opts)
   [h, fontsize] = get_figure_text_objs (opts);
   unwind_protect
-    for n = 1:numel(h)
+    for n = 1:numel (h)
       set (h(n), "fontsize", 2 * fontsize{n});
     endfor
     local_drawnow (sprintf ("postscript eps %s", gp_opts), epsfile, opts);
   unwind_protect_cleanup
-    for n = 1:numel(h)
+    for n = 1:numel (h)
       set (h(n), "fontsize", fontsize{n});
     endfor
   end_unwind_protect
 endfunction
 
 function local_drawnow (term, file, opts)
   if (opts.use_color < 0)
     mono = true;
@@ -191,17 +191,17 @@ function local_drawnow (term, file, opts
   if (isempty (opts.debug_file) || ! opts.debug)
     drawnow (term, file, mono);
   else
     drawnow (term, file, mono, opts.debug_file);
   endif
 endfunction
 
 function f = font_spec (opts, varargin)
-  for n = 1:2:numel(varargin)
+  for n = 1:2:numel (varargin)
     opts.(varargin{n}) = varargin{n+1};
   endfor
   f = "";
   switch (opts.devopt)
   case "cgm"
     if (! isempty (opts.font) && ! isempty (opts.fontsize))
       f = sprintf ("font ""%s,%d""", opts.font, opts.fontsize);
     elseif (! isempty (opts.font))
diff --git a/scripts/plot/private/__go_draw_axes__.m b/scripts/plot/private/__go_draw_axes__.m
--- a/scripts/plot/private/__go_draw_axes__.m
+++ b/scripts/plot/private/__go_draw_axes__.m
@@ -85,17 +85,17 @@ function __go_draw_axes__ (h, plot_strea
     endif
 
     if (strcmp (axis_obj.activepositionproperty, "position"))
       if (__gnuplot_has_feature__ ("screen_coordinates_for_{lrtb}margin"))
         if (nd == 2 || all (mod (axis_obj.view, 90) == 0))
           x = [1, 1];
         else
           ## 3D plots need to be sized down to fit in the window.
-          x = 1.0 ./ sqrt([2, 2.5]);
+          x = 1.0 ./ sqrt ([2, 2.5]);
         endif
         fprintf (plot_stream, "set tmargin screen %.15g;\n",
                  pos(2)+pos(4)/2+x(2)*pos(4)/2);
         fprintf (plot_stream, "set bmargin screen %.15g;\n",
                  pos(2)+pos(4)/2-x(2)*pos(4)/2);
         fprintf (plot_stream, "set lmargin screen %.15g;\n",
                  pos(1)+pos(3)/2-x(1)*pos(3)/2);
         fprintf (plot_stream, "set rmargin screen %.15g;\n",
@@ -490,23 +490,23 @@ function __go_draw_axes__ (h, plot_strea
           parametric(data_idx) = false;
           have_cdata(data_idx) = false;
           have_3d_patch(data_idx) = false;
 
           if (img_xdata(2) < img_xdata(1))
             img_xdata = img_xdata(2:-1:1);
             img_data = img_data(:,end:-1:1,:);
           elseif (img_xdata(1) == img_xdata(2))
-            img_xdata = img_xdata(1) + [0, size(img_data,2)-1];
+            img_xdata = img_xdata(1) + [0, columns(img_data)-1];
           endif
           if (img_ydata(2) < img_ydata(1))
             img_ydata = img_ydata(2:-1:1);
             img_data = img_data(end:-1:1,:,:);
           elseif (img_ydata(1) == img_ydata(2))
-            img_ydata = img_ydata(1) + [0, size(img_data,1)-1];
+            img_ydata = img_ydata(1) + [0, rows(img_data)-1];
           endif
 
           [y_dim, x_dim] = size (img_data(:,:,1));
           if (x_dim > 1)
             dx = abs (img_xdata(2)-img_xdata(1))/(x_dim-1);
           else
             x_dim = 2;
             img_data = [img_data, img_data];
@@ -569,17 +569,17 @@ function __go_draw_axes__ (h, plot_strea
             data{data_idx} = [xdat, ydat, zdat]';
             usingclause{data_idx} = sprintf ("record=%d using ($1):($2):($3)", numel (xdat));
             ## fputs (plot_stream, "set parametric;\n");
           else
             xdat = obj.xdata(:);
             ydat = obj.ydata(:);
             data{data_idx} = [xdat, ydat]';
             usingclause{data_idx} = sprintf ("record=%d using ($1):($2) axes %s%s",
-                                            rows(xdat), xaxisloc_using, yaxisloc_using);
+                                            rows (xdat), xaxisloc_using, yaxisloc_using);
           endif
 
           style = do_linestyle_command (obj, obj.color, data_idx, mono,
                                         plot_stream, errbars);
 
           withclause{data_idx} = sprintf ("with %s linestyle %d",
                                           style{1}, data_idx);
 
@@ -675,83 +675,83 @@ function __go_draw_axes__ (h, plot_strea
                  tmp = undo_string_escapes (__maybe_munge_text__ (enhanced, obj, "displayname"));
                  titlespec{local_idx} = cstrcat ("title \"", tmp, "\"");
                endif
                if (isfield (obj, "facecolor"))
                  if ((strncmp (obj.facecolor, "flat", 4)
                      || strncmp (obj.facecolor, "interp", 6))
                      && isfield (obj, "cdata"))
                    if (ndims (obj.cdata) == 2
-                       && (size (obj.cdata, 2) == nc
-                           && (size (obj.cdata, 1) == 1
-                               || size (obj.cdata, 1) == 3)))
+                       && (columns (obj.cdata) == nc
+                           && (rows (obj.cdata) == 1
+                               || rows (obj.cdata) == 3)))
                      ccol = cdat (:, i);
                    elseif (ndims (obj.cdata) == 2
-                       && (size (obj.cdata, 1) == nc
-                           && (size (obj.cdata, 2) == 1
-                               || size (obj.cdata, 2) == 3)))
+                       && (rows (obj.cdata) == nc
+                           && (columns (obj.cdata) == 1
+                               || columns (obj.cdata) == 3)))
                      ccol = cdat (i, :);
                    elseif (ndims (obj.cdata) == 3)
                      ccol = permute (cdat (:, i, :), [1, 3, 2]);
                    else
                      ccol = cdat;
                    endif
                    if (strncmp (obj.facecolor, "flat", 4))
                      if (isequal (size (ccol), [1, 3]))
                        ## RGB Triplet
                        color = ccol;
                      elseif (nd == 3 && numel (xcol) == 3)
                        ccdat = ccol;
                      else
                        if (cdatadirect)
                          r = round (ccol);
                        else
-                         r = 1 + round ((size (cmap, 1) - 1)
+                         r = 1 + round ((rows (cmap) - 1)
                                         * (ccol - clim(1))/(clim(2) - clim(1)));
                        endif
-                       r = max (1, min (r, size (cmap, 1)));
+                       r = max (1, min (r, rows (cmap)));
                        color = cmap(r, :);
                      endif
                    elseif (strncmp (obj.facecolor, "interp", 6))
                      if (nd == 3 && numel (xcol) == 3)
                        ccdat = ccol;
                        if (! isvector (ccdat))
-                         tmp = rows(cmap) + rows(addedcmap) + ...
+                         tmp = rows (cmap) + rows (addedcmap) + ...
                               [1 : rows(ccdat)];
                          addedcmap = [addedcmap; ccdat];
                          ccdat = tmp(:);
                        else
                          ccdat = ccdat(:);
                        endif
                      else
                        if (sum (diff (ccol)))
                          warning ("\"interp\" not supported, using 1st entry of cdata");
                        endif
                        if (cdatadirect)
                          r = round (ccol);
                        else
-                         r = 1 + round ((size (cmap, 1) - 1)
+                         r = 1 + round ((rows (cmap) - 1)
                                         * (ccol - clim(1))/(clim(2) - clim(1)));
                        endif
-                       r = max (1, min (r, size (cmap, 1)));
+                       r = max (1, min (r, rows (cmap)));
                        color = cmap(r(1),:);
                      endif
                    endif
                  elseif (isnumeric (obj.facecolor))
                    color = obj.facecolor;
                  else
                    color = [0, 1, 0];
                  endif
                else
                  color = [0, 1, 0];
                endif
 
                if (nd == 3 && numel (xcol) == 3)
                  if (isnan (ccdat))
-                   ccdat = (rows (cmap) + rows(addedcmap) + 1) * ones(3, 1);
+                   ccdat = (rows (cmap) + rows (addedcmap) + 1) * ones(3, 1);
                    addedcmap = [addedcmap; reshape(color, 1, 3)];
                  endif
                  data{data_3d_idx} = [data{data_3d_idx}, ...
                                       [[xcol; xcol(end)], [ycol; ycol(end)], ...
                                       [zcol; zcol(end)], [ccdat; ccdat(end)]]'];
                else
                  if (mono)
                    colorspec = "";
@@ -807,47 +807,47 @@ function __go_draw_axes__ (h, plot_strea
                else
                  ec = obj.edgecolor;
                endif
 
                if ((strncmp (ec, "flat", 4)
                     || strncmp (ec, "interp", 6))
                    && isfield (obj, "cdata"))
                  if (ndims (obj.cdata) == 2
-                     && (size (obj.cdata, 2) == nc
-                         && (size (obj.cdata, 1) == 1
-                             || size (obj.cdata, 1) == 3)))
+                     && (columns (obj.cdata) == nc
+                         && (rows (obj.cdata) == 1
+                             || rows (obj.cdata) == 3)))
                    ccol = cdat (:, i);
                  elseif (ndims (obj.cdata) == 2
-                         && (size (obj.cdata, 1) == nc
-                             && (size (obj.cdata, 2) == 1
-                                 || size (obj.cdata, 2) == 3)))
+                         && (rows (obj.cdata) == nc
+                             && (columns (obj.cdata) == 1
+                                 || columns (obj.cdata) == 3)))
                    ccol = cdat (i, :);
                  elseif (ndims (obj.cdata) == 3)
                    ccol = permute (cdat (:, i, :), [1, 3, 2]);
                  else
                    ccol = cdat;
                  endif
                  if (strncmp (ec, "flat", 4))
-                   if (numel(ccol) == 3)
+                   if (numel (ccol) == 3)
                      color = ccol;
                    else
                      if (isscalar (ccol))
-                       ccol = repmat(ccol, numel (xcol), 1);
+                       ccol = repmat (ccol, numel (xcol), 1);
                      endif
                      color = "flat";
                      have_cdata(data_idx) = true;
                    endif
                  elseif (strncmp (ec, "interp", 6))
-                   if (numel(ccol) == 3)
+                   if (numel (ccol) == 3)
                      warning ("\"interp\" not supported, using 1st entry of cdata");
                      color = ccol(1,:);
                    else
                      if (isscalar (ccol))
-                       ccol = repmat(ccol, numel (xcol), 1);
+                       ccol = repmat (ccol, numel (xcol), 1);
                      endif
                      color = "interp";
                      have_cdata(data_idx) = true;
                    endif
                  endif
                elseif (isnumeric (ec))
                  color = ec;
                else
@@ -872,17 +872,17 @@ function __go_draw_axes__ (h, plot_strea
                  otherwise
                    lt = "";
                endswitch
              else
                lt = "";
              endif
 
              if (isfield (obj, "linewidth"))
-               lw = sprintf("linewidth %f", obj.linewidth);
+               lw = sprintf ("linewidth %f", obj.linewidth);
              else
                lw  = "";
              endif
 
              [pt, pt2, obj] = gnuplot_pointtype (obj);
              if (! isempty (pt))
                pt = sprintf ("pointtype %s", pt);
              endif
@@ -918,17 +918,17 @@ function __go_draw_axes__ (h, plot_strea
                        && isequal (color, obj.markerfacecolor)))
                  style = strcat (style, "points");
                  if (isfield (obj, "markersize"))
                    if (length (mdat) == nc)
                      m = mdat(i);
                    else
                      m = mdat;
                    endif
-                   ps = sprintf("pointsize %f", m / 3);
+                   ps = sprintf ("pointsize %f", m / 3);
                  else
                    ps = "";
                  endif
 
                  tmpwith{sidx} = sprintf ("with %s %s %s %s %s %s",
                                           style, lw, pt2, lt, ps,
                                           colorspec);
                else
@@ -945,17 +945,17 @@ function __go_draw_axes__ (h, plot_strea
                  endif
                  style = "points";
                  if (isfield (obj, "markersize"))
                    if (length (mdat) == nc)
                      m = mdat(i);
                    else
                      m = mdat;
                    endif
-                   ps = sprintf("pointsize %f", m / 3);
+                   ps = sprintf ("pointsize %f", m / 3);
                  else
                    ps = "";
                  endif
                  tmpwith{sidx} = sprintf ("with %s %s %s %s %s %s",
                                           style, lw, pt2, lt, ps,
                                           colorspec);
                endif
              endif
@@ -972,27 +972,27 @@ function __go_draw_axes__ (h, plot_strea
                          || isempty (style)))
                    style = strcat (style, "points");
                    if (isfield (obj, "markersize"))
                      if (length (mdat) == nc)
                        m = mdat(i);
                      else
                        m = mdat;
                      endif
-                     ps = sprintf("pointsize %f", m / 3);
+                     ps = sprintf ("pointsize %f", m / 3);
                    else
                      ps = "";
                    endif
                    tmpwith{sidx} = sprintf ("with %s %s %s %s %s %s",
                                             style, lw, pt, lt, ps,
                                             colorspec);
                  endif
                else
                  if (!isempty (style))
-                   if (length(tmpwith) < sidx || isempty (tmpwith{sidx}))
+                   if (length (tmpwith) < sidx || isempty (tmpwith{sidx}))
                      tmpwith{sidx} = sprintf ("with %s %s %s %s",
                                               style, lw, lt,
                                               colorspec);
                    endif
                    sidx ++;
                  endif
 
                  if (!isempty (pt))
@@ -1007,17 +1007,17 @@ function __go_draw_axes__ (h, plot_strea
                    endif
                    style = "points";
                    if (isfield (obj, "markersize"))
                      if (length (mdat) == nc)
                        m = mdat(i);
                      else
                        m = mdat;
                      endif
-                     ps = sprintf("pointsize %f", m / 3);
+                     ps = sprintf ("pointsize %f", m / 3);
                    else
                      ps = "";
                    endif
                    tmpwith{sidx} = sprintf ("with %s %s %s %s %s %s",
                                             style, lw, pt, lt, ps,
                                             colorspec);
                  endif
                endif
@@ -1117,17 +1117,17 @@ function __go_draw_axes__ (h, plot_strea
             pm3didx = data_idx;
 
             xdat = obj.xdata;
             ydat = obj.ydata;
             zdat = obj.zdata;
             cdat = obj.cdata;
 
             err = false;
-            if (! size_equal(zdat, cdat))
+            if (! size_equal (zdat, cdat))
               err = true;
             endif
             if (isvector (xdat) && isvector (ydat) && ismatrix (zdat))
               if (rows (zdat) == length (ydat)
                   && columns (zdat) == length (xdat))
                 [xdat, ydat] = meshgrid (xdat, ydat);
               else
                 err = true;
@@ -1183,21 +1183,21 @@ function __go_draw_axes__ (h, plot_strea
               fputs (plot_stream, "unset pm3d\n");
               if (all (obj.facecolor == 1))
                 hidden_removal = true;
               endif
             elseif (facecolor_none_or_white)
               if (all (obj.facecolor == 1))
                 hidden_removal = true;
               endif
-              fputs(plot_stream,"unset pm3d;\n");
-              fputs(plot_stream,"set style increment user;\n");
+              fputs (plot_stream,"unset pm3d;\n");
+              fputs (plot_stream,"set style increment user;\n");
               withpm3d = false;
-              withclause{data_idx} = sprintf("with %s linestyle %d",
-                                             style{1}, data_idx);
+              withclause{data_idx} = sprintf ("with %s linestyle %d",
+                                              style{1}, data_idx);
               fputs (plot_stream, "unset pm3d\n");
             endif
 
             if (doing_interp_color)
               ## "depthorder" interferes with interpolation of colors.
               dord = "scansautomatic";
             else
               dord = "depthorder";
@@ -1262,17 +1262,17 @@ function __go_draw_axes__ (h, plot_strea
               have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
               titlespec{data_idx} = "title \"\"";
               usingclause{data_idx} = sprintf ("record=%dx%d using ($1):($2):($3)", ylen, xlen);
               data{data_idx} = zz;
               withclause{data_idx} = sprintf ("with %s linestyle %d",
                                               style{3}, data_idx);
             endif
             if (withpm3d && strncmp (style {1}, "linespoints", 11))
-              if (isempty(zz))
+              if (isempty (zz))
                 len = 3 * xlen;
                 zz = zeros (ylen, len);
                 k = 1;
                 for kk = 1:3:len
                   zz(:,kk)   = xdat(:,k);
                   zz(:,kk+1) = ydat(:,k);
                   zz(:,kk+2) = zdat(:,k);
                   k++;
@@ -1310,17 +1310,17 @@ function __go_draw_axes__ (h, plot_strea
             units = "";
           endif
 
           if (isnumeric (color))
             colorspec = get_text_colorspec (color, mono);
           endif
 
           if (ischar (obj.string))
-            num_lines = size (obj.string, 1);
+            num_lines = rows (obj.string);
           else
             num_lines = numel (obj.string);
           endif
           switch valign
             ## Text offset in characters. This relies on gnuplot for font metrics.
             case "top"
               dy = -0.5;
             case "cap"
@@ -1330,17 +1330,17 @@ function __go_draw_axes__ (h, plot_strea
             case "baseline"
               dy = 0.5 + (num_lines - 1);
             case "bottom"
               dy = 0.5 + (num_lines - 1);
           endswitch
           ## Gnuplot's Character units are different for x/y and vary with fontsize. The aspect ratio
           ## of 1:1.7 was determined by experiment to work for eps/ps/etc. For the MacOS aqua terminal
           ## a value of 2.5 is needed. However, the difference is barely noticable.
-          dx_and_dy = [(-dy * sind (angle)), (dy * cosd(angle))] .* [1.7 1];
+          dx_and_dy = [(-dy * sind (angle)), (dy * cosd (angle))] .* [1.7 1];
 
           ## FIXME - Multiline text produced the gnuplot "warning: ft_render: skipping glyph"
           if (nd == 3)
             ## This produces the desired vertical alignment in 3D.
             fprintf (plot_stream,
                      "set label \"%s\" at %s %.15e,%.15e,%.15e %s rotate by %f offset character %f,%f %s %s front %s;\n",
                      undo_string_escapes (label), units, lpos(1),
                      lpos(2), lpos(3), halign, angle, dx_and_dy, fontspec,
@@ -1371,17 +1371,17 @@ function __go_draw_axes__ (h, plot_strea
     ## This is need to prevent warnings for rotations in 3D plots, while
     ## allowing colorbars with contours.
     if (nd == 2 || (data_idx > 1 && !view_map))
       fputs (plot_stream, "set pm3d implicit;\n");
     else
       fputs (plot_stream, "set pm3d explicit;\n");
     endif
 
-    if (isnan(hidden_removal) || hidden_removal)
+    if (isnan (hidden_removal) || hidden_removal)
       fputs (plot_stream, "set hidden3d;\n");
     else
       fputs (plot_stream, "unset hidden3d;\n");
     endif
 
     have_data = (! (isempty (data) || all (cellfun ("isempty", data))));
 
     ## Note we don't use the [xy]2range of gnuplot as we don't use the
@@ -1420,27 +1420,27 @@ function __go_draw_axes__ (h, plot_strea
         zdir = "reverse";
       else
         zdir = "noreverse";
       endif
       fprintf (plot_stream, "set zrange [%.15e:%.15e] %s;\n", zlim, zdir);
     endif
 
     cmap = parent_figure_obj.colormap;
-    cmap_sz = rows(cmap);
+    cmap_sz = rows (cmap);
     if (! any (isinf (clim)))
       if (truecolor || ! cdatadirect)
-        if (rows(addedcmap) > 0)
+        if (rows (addedcmap) > 0)
           for i = 1:data_idx
             if (have_3d_patch(i))
               data{i}(end,:) = clim(2) * (data{i}(end, :) - 0.5) / cmap_sz;
              endif
           endfor
           fprintf (plot_stream, "set cbrange [%.15e:%.15e];\n", clim(1), clim(2) *
-                   (cmap_sz + rows(addedcmap)) / cmap_sz);
+                   (cmap_sz + rows (addedcmap)) / cmap_sz);
         else
           fprintf (plot_stream, "set cbrange [%.15e:%.15e];\n", clim);
         endif
       else
         fprintf (plot_stream, "set cbrange [1:%d];\n", cmap_sz +
                  rows (addedcmap));
       endif
     endif
@@ -1585,18 +1585,18 @@ function __go_draw_axes__ (h, plot_strea
       fprintf (plot_stream, "set key %s %s;\nset key %s %s %s %s %s;\n",
                inout, pos, box, reverse, horzvert, fontspec, colorspec);
     else
       fputs (plot_stream, "unset key;\n");
     endif
     fputs (plot_stream, "set style data lines;\n");
 
     cmap = [cmap; addedcmap];
-    cmap_sz = cmap_sz + rows(addedcmap);
-    if (length(cmap) > 0)
+    cmap_sz = cmap_sz + rows (addedcmap);
+    if (length (cmap) > 0)
       fprintf (plot_stream,
                "set palette positive color model RGB maxcolors %i;\n",
                cmap_sz);
       fprintf (plot_stream,
                "set palette file \"-\" binary record=%d using 1:2:3:4;\n",
                cmap_sz);
       fwrite (plot_stream, [1:cmap_sz; cmap.'], "float32");
       fwrite (plot_stream, "\n");
@@ -1624,17 +1624,17 @@ function __go_draw_axes__ (h, plot_strea
       if (have_3d_patch (1))
         fputs (plot_stream, "set pm3d depthorder\n");
         fprintf (plot_stream, "%s \"-\" %s %s %s \\\n", plot_cmd,
                  usingclause{1}, titlespec{1}, withclause{1});
       elseif (is_image_data (1))
         if (numel (is_image_data) > 1 && is_image_data(2))
           ## Remove terminating semicolon
           n = max (strfind (withclause{1}, ";"));
-          if (! isempty(n))
+          if (! isempty (n))
             withclause{1} = withclause{1}(1:n-1);
           endif
         endif
         fprintf (plot_stream, "%s \"-\" %s %s %s \\\n", plot_cmd,
                  usingclause{1}, titlespec{1}, withclause{1});
       else
         fprintf (plot_stream, "%s \"-\" binary format='%%float64' %s %s %s \\\n", plot_cmd,
                  usingclause{1}, titlespec{1}, withclause{1});
@@ -1652,17 +1652,17 @@ function __go_draw_axes__ (h, plot_strea
             endif
             if (fg_is_set)
               fputs (plot_stream, "unset obj 2; \\\n");
               fg_is_set = false;
             endif
             if (numel (is_image_data) > i && is_image_data(i+1))
               ## Remove terminating semicolon
               n = max (strfind (withclause{i}, ";"));
-              if (! isempty(n))
+              if (! isempty (n))
                 withclause{i} = withclause{i}(1:n-1);
               endif
             endif
             fprintf (plot_stream, "%s \"-\" %s %s %s \\\n", plot_cmd,
                      usingclause{i}, titlespec{i}, withclause{i});
           else
             ## For consecutive images continue with the same plot command
             fprintf (plot_stream, "%s \"-\" %s %s %s \\\n", ",",
@@ -1685,17 +1685,17 @@ function __go_draw_axes__ (h, plot_strea
         endif
       endfor
       fputs (plot_stream, ";\n");
       for i = 1:data_idx
         if (have_3d_patch (i))
           ## Can't write 3d patch data as binary as can't plot more than
           ## a single patch at a time and have to plot all patches together
           ## so that the gnuplot depth ordering is done correctly
-          for j = 1 : 4 : columns(data{i})
+          for j = 1 : 4 : columns (data{i})
             if (j != 1)
               fputs (plot_stream, "\n\n");
             endif
             fprintf (plot_stream, "%.15g %.15g %.15g %.15g\n", data{i}(:,j).');
             fprintf (plot_stream, "%.15g %.15g %.15g %.15g\n\n", data{i}(:,j+1).');
             fprintf (plot_stream, "%.15g %.15g %.15g %.15g\n", data{i}(:,j+2).');
             fprintf (plot_stream, "%.15g %.15g %.15g %.15g\n", data{i}(:,j+3).');
           endfor
@@ -1725,19 +1725,19 @@ function __go_draw_axes__ (h, plot_strea
 
   else
     print_usage ();
   endif
 
 endfunction
 
 function x = flip (x)
-  if (size (x, 1) == 1)
+  if (rows (x) == 1)
     x = fliplr (x);
-  elseif (size (x, 2) == 1 || ischar (x))
+  elseif (columns (x) == 1 || ischar (x))
     x = flipud (x);
   else
     x = flipud (fliplr (x));
   endif
 endfunction
 
 function fontspec = create_fontspec (f, s, gp_term)
   if (strcmp (f, "*") || strcmp (gp_term, "tikz"))
@@ -2092,17 +2092,17 @@ function do_tics (obj, plot_stream, ymir
              obj.interpreter, obj.zscale, obj.zsgn, gnuplot_term);
 endfunction
 
 function do_tics_1 (ticmode, tics, mtics, labelmode, labels, color, ax,
                     plot_stream, mirror, mono, axispos, tickdir, ticklength,
                     fontname, fontspec, interpreter, scale, sgn, gnuplot_term)
   persistent warned_latex = false;
   if (strcmpi (interpreter, "tex"))
-    for n = 1 : numel(labels)
+    for n = 1 : numel (labels)
       labels{n} = __tex2enhanced__ (labels{n}, fontname, false, false);
     endfor
   elseif (strcmpi (interpreter, "latex"))
     if (! warned_latex)
       warning ("latex markup not supported for tick marks");
       warned_latex = true;
     endif
   endif
@@ -2142,17 +2142,17 @@ function do_tics_1 (ticmode, tics, mtics
         if (mirror)
           fprintf (plot_stream, "set %stics %s %s %s mirror (", ax,
                    tickdir, ticklength, axispos);
         else
           fprintf (plot_stream, "set %stics %s %s %s nomirror (", ax,
                    tickdir, ticklength, axispos);
         endif
 
-        labels = regexprep(labels, '%', "%%");
+        labels = regexprep (labels, '%', "%%");
         for i = 1:ntics
           fprintf (plot_stream, " \"%s\" %.15g", labels{k++}, tics(i));
           if (i < ntics)
             fputs (plot_stream, ", ");
           endif
           if (k > nlabels)
             k = 1;
           endif
@@ -2201,17 +2201,17 @@ function do_tics_1 (ticmode, tics, mtics
 endfunction
 
 function ticklabel = ticklabel_to_cell (ticklabel)
   if (isnumeric (ticklabel))
     ## Use upto 5 significant digits
     ticklabel = num2str (ticklabel(:), 5);
   endif
   if (ischar (ticklabel))
-    if (size (ticklabel, 1) == 1 && any (ticklabel == "|"))
+    if (rows (ticklabel) == 1 && any (ticklabel == "|"))
       ticklabel = strsplit (ticklabel, "|");
     else
       ticklabel = cellstr (ticklabel);
     endif
   elseif (isempty (ticklabel))
     ticklabel = {""};
   else
     ticklabel = ticklabel;
@@ -2232,27 +2232,27 @@ function [f, s, fnt, it, bld] = get_font
     fnt = "{}";
   else
     fnt = t.fontname;
   endif
   f = fnt;
   it = false;
   bld = false;
   if (! isempty (t.fontweight) && strcmpi (t.fontweight, "bold"))
-    if (! isempty(t.fontangle)
+    if (! isempty (t.fontangle)
         && (strcmpi (t.fontangle, "italic")
             || strcmpi (t.fontangle, "oblique")))
       f = cstrcat (f, "-bolditalic");
       it = true;
       bld = true;
     else
       f = cstrcat (f, "-bold");
       bld = true;
     endif
-  elseif (! isempty(t.fontangle)
+  elseif (! isempty (t.fontangle)
           && (strcmpi (t.fontangle, "italic")
               || strcmpi (t.fontangle, "oblique")))
     f = cstrcat (f, "-italic");
     it = true;
   endif
   if (isempty (t.fontsize))
     s = 10;
   else
@@ -2271,34 +2271,34 @@ function [str, f, s] = __maybe_munge_tex
     s = 10;
     fnt = f;
     it = false;
     bld = false;
   endif
 
   ## The text object maybe multiline, and may be of any class
   str = getfield (obj, fld);
-  if (ischar (str) && size (str, 1) > 1)
+  if (ischar (str) && rows (str) > 1)
     str = cellstr (str);
   elseif (isnumeric (str))
     str = cellstr (num2str (str(:)));
   endif
   if (iscellstr (str))
-    for n = 1:numel(str)
+    for n = 1:numel (str)
       if (isnumeric (str{n}))
         str{n} = num2str (str{n});
       endif
     endfor
     str = sprintf ("%s\n", str{:})(1:end-1);
   endif
 
   if (enhanced)
     if (strcmpi (obj.interpreter, "tex"))
       if (iscellstr (str))
-        for n = 1:numel(str)
+        for n = 1:numel (str)
           str{n} = __tex2enhanced__ (str{n}, fnt, it, bld);
         endfor
       else
         str = __tex2enhanced__ (str, fnt, it, bld);
       endif
     elseif (strcmpi (obj.interpreter, "latex"))
       if (! warned_latex)
         warning ("latex markup not supported for text objects");
@@ -2312,49 +2312,49 @@ endfunction
 
 function str = no_super_sub_scripts (str)
   if (iscellstr (str))
     labels = str;
   else
     labels = cellstr (str);
   endif
   for marker = "_^" 
-    for m = 1 : numel(labels)
+    for m = 1 : numel (labels)
       n1 = strfind (labels{m}, sprintf ("\\%s", marker));
       n2 = strfind (labels{m}, marker);
       if (! isempty (n1))
         n1 = n1 + 1;
         n2 = setdiff (n2, n1);
       endif
-      for n = numel(n2):-1:1
+      for n = numel (n2):-1:1
         labels{m} = [labels{m}(1:n2(n)-1), "\\", labels{m}(n2(n):end)];
       endfor
     endfor
   endfor
   if (iscellstr (str))
     str = labels;
   else
     str = char (labels);
   endif
 endfunction
 
 function str = __tex2enhanced__ (str, fnt, it, bld)
   persistent sym = __setup_sym_table__ ();
   persistent flds = fieldnames (sym);
 
-  [s, e, m] = regexp(str,'\\\\([a-zA-Z]+|0)','start','end','matches');
+  [s, e, m] = regexp (str,'\\\\([a-zA-Z]+|0)','start','end','matches');
 
   for i = length (s) : -1 : 1
     ## special case for "\0"  and replace with "{/Symbol \306}'
     if (strncmp (m{i}, '\0', 2))
       str = cstrcat (str(1:s(i) - 1), '{/Symbol \306}', str(s(i) + 2:end));
     else
       f = m{i}(2:end);
       if (isfield (sym, f))
-        g = getfield(sym, f);
+        g = getfield (sym, f);
         ## FIXME The symbol font doesn't seem to support bold or italic
         ##if (bld)
         ##  if (it)
         ##    g = regexprep (g, '/Symbol', '/Symbol-bolditalic');
         ##  else
         ##    g = regexprep (g, '/Symbol', '/Symbol-bold');
         ##  endif
         ##elseif (it)
@@ -2364,142 +2364,142 @@ function str = __tex2enhanced__ (str, fn
       elseif (strncmp (f, "rm", 2))
         bld = false;
         it = false;
         str = cstrcat (str(1:s(i) - 1), '/', fnt, ' ', str(s(i) + 3:end));
       elseif (strncmp (f, "it", 2) || strncmp (f, "sl", 2))
         it = true;
         if (bld)
           str = cstrcat (str(1:s(i) - 1), '/', fnt, '-bolditalic ',
-                        str(s(i) + 3:end));
+                         str(s(i) + 3:end));
         else
           str = cstrcat (str(1:s(i) - 1), '/', fnt, '-italic ',
-                        str(s(i) + 3:end));
+                         str(s(i) + 3:end));
         endif
       elseif (strncmp (f, "bf", 2))
         bld = true;
         if (it)
           str = cstrcat (str(1:s(i) - 1), '/', fnt, '-bolditalic ',
-                        str(2(i) + 3:end));
+                         str(2(i) + 3:end));
         else
           str = cstrcat (str(1:s(i) - 1), '/', fnt, '-bold ',
-                        str(s(i) + 3:end));
+                         str(s(i) + 3:end));
         endif
       elseif (strcmpi (f, "color"))
         ## FIXME Ignore \color but remove trailing {} block as well
-        d = strfind(str(e(i) + 1:end),'}');
+        d = strfind (str(e(i) + 1:end),'}');
         if (isempty (d))
           warning ('syntax error in \color argument');
         else
           str = cstrcat (str(1:s(i) - 1), str(e(i) + d + 1:end));
         endif
-      elseif(strcmpi (f, "fontname"))
-        b1 = strfind(str(e(i) + 1:end),'{');
-        b2 = strfind(str(e(i) + 1:end),'}');
-        if (isempty(b1) || isempty(b2))
+      elseif (strcmpi (f, "fontname"))
+        b1 = strfind (str(e(i) + 1:end),'{');
+        b2 = strfind (str(e(i) + 1:end),'}');
+        if (isempty (b1) || isempty (b2))
           warning ('syntax error in \fontname argument');
         else
           str = cstrcat (str(1:s(i) - 1), '/',
-                        str(e(i)+b1(1) + 1:e(i)+b2(1)-1), '{}',
-                        str(e(i) + b2(1) + 1:end));
+                         str(e(i)+b1(1) + 1:e(i)+b2(1)-1), '{}',
+                         str(e(i) + b2(1) + 1:end));
         endif
-      elseif(strcmpi (f, "fontsize"))
-        b1 = strfind(str(e(i) + 1:end),'{');
-        b2 = strfind(str(e(i) + 1:end),'}');
-        if (isempty(b1) || isempty(b2))
+      elseif (strcmpi (f, "fontsize"))
+        b1 = strfind (str(e(i) + 1:end),'{');
+        b2 = strfind (str(e(i) + 1:end),'}');
+        if (isempty (b1) || isempty (b2))
           warning ('syntax error in \fontname argument');
         else
           str = cstrcat (str(1:s(i) - 1), '/=',
-                        str(e(i)+b1(1) + 1:e(i)+b2(1)-1), '{}',
-                        str(e(i) + b2(1) + 1:end));
+                         str(e(i)+b1(1) + 1:e(i)+b2(1)-1), '{}',
+                         str(e(i) + b2(1) + 1:end));
         endif
       else
         ## Last desperate attempt to treat the symbol. Look for things
         ## like \pix, that should be translated to the symbol Pi and x
         for j = 1 : length (flds)
           if (strncmp (flds{j}, f, length (flds{j})))
-            g = getfield(sym, flds{j});
+            g = getfield (sym, flds{j});
             ## FIXME The symbol font doesn't seem to support bold or italic
             ##if (bld)
             ##  if (it)
             ##    g = regexprep (g, '/Symbol', '/Symbol-bolditalic');
             ##  else
             ##    g = regexprep (g, '/Symbol', '/Symbol-bold');
             ##  endif
             ##elseif (it)
             ##  g = regexprep (g, '/Symbol', '/Symbol-italic');
             ##endif
             str = cstrcat (str(1:s(i) - 1), g,
-                          str(s(i) + length (flds{j}) + 1:end));
+                           str(s(i) + length (flds{j}) + 1:end));
             break;
           endif
         endfor
       endif
     endif
   endfor
 
   ## Prepend @ to things  things like _0^x or _{-100}^{100} for
   ## alignment But need to put the shorter of the two arguments first.
   ## Carful of nested {} and unprinted characters when defining
   ## shortest.. Don't have to worry about things like ^\theta as they
   ## are already converted to ^{/Symbol q}.
 
   ## FIXME -- This is a mess... Is it worth it just for a "@" character?
 
-  [s, m] = regexp(str,'[_\^]','start','matches');
+  [s, m] = regexp (str,'[_\^]','start','matches');
   i = 1;
   p = 0;
   while (i < length (s))
-    if (i < length(s))
+    if (i < length (s))
       if (str(s(i) + p + 1) == "{")
-        s1 = strfind(str(s(i) + p + 2:end),'{');
+        s1 = strfind (str(s(i) + p + 2:end),'{');
         si = 1;
-        l1 = strfind(str(s(i) + p + 1:end),'}');
+        l1 = strfind (str(s(i) + p + 1:end),'}');
         li = 1;
         while (li <= length (l1) && si <= length (s1))
           if (l1(li) < s1(si))
             if (li == si)
               break;
             endif
             li++;
           else
             si++;
           endif
         endwhile
-        l1 = l1 (min (length(l1), si));
+        l1 = l1 (min (length (l1), si));
         if (s(i) + l1 + 1 == s(i+1))
           if (str(s(i + 1) + p + 1) == "{")
-            s2 = strfind(str(s(i + 1) + p + 2:end),'{');
+            s2 = strfind (str(s(i + 1) + p + 2:end),'{');
             si = 1;
-            l2 = strfind(str(s(i + 1) + p + 1:end),'}');
+            l2 = strfind (str(s(i + 1) + p + 1:end),'}');
             li = 1;
             while (li <= length (l2) && si <= length (s2))
               if (l2(li) < s2(si))
                 if (li == si)
                   break;
                 endif
                 li++;
               else
                 si++;
               endif
             endwhile
-            l2 = l2 (min (length(l2), si));
+            l2 = l2 (min (length (l2), si));
             if (length_string (str(s(i)+p+2:s(i)+p+l1-1)) <=
-                length_string(str(s(i+1)+p+2:s(i+1)+p+l2-1)))
+                length_string (str(s(i+1)+p+2:s(i+1)+p+l2-1)))
               ## Shortest already first!
               str = cstrcat (str(1:s(i)+p-1), "@", str(s(i)+p:end));
             else
               ## Have to swap sub/super-script to get shortest first.
               str = cstrcat (str(1:s(i)+p-1), "@", str(s(i+1)+p:s(i+1)+p+l2),
-                            str(s(i)+p:s(i)+p+l1), str(s(i+1)+p+l2+1:end));
+                             str(s(i)+p:s(i)+p+l1), str(s(i+1)+p+l2+1:end));
             endif
           else
             ## Have to swap sub/super-script to get shortest first.
             str = cstrcat (str(1:s(i)+p-1), "@", str(s(i+1)+p:s(i+1)+p+1),
-                          str(s(i)+p:s(i)+p+l1), str(s(i+1)+p+2:end));
+                           str(s(i)+p:s(i)+p+l1), str(s(i+1)+p+2:end));
           endif
           i += 2;
           p ++;
         else
           i++;
         endif
       else
         if (s(i+1) == s(i) + 2)
@@ -2514,17 +2514,17 @@ function str = __tex2enhanced__ (str, fn
     else
       i ++;
     endif
   endwhile
 
 endfunction
 
 function l = length_string (s)
-  l = length (s) - length (strfind(s,'{')) - length (strfind(s,'}'));
+  l = length (s) - length (strfind (s,'{')) - length (strfind (s,'}'));
   m = regexp (s, '/([\w-]+|[\w-]+=\d+)', 'matches');
   if (!isempty (m))
     l = l - sum (cellfun ("length", m));
   endif
 endfunction
 
 function sym = __setup_sym_table__ ()
   ## Setup the translation table for TeX to gnuplot enhanced mode.
diff --git a/scripts/plot/private/__go_draw_figure__.m b/scripts/plot/private/__go_draw_figure__.m
--- a/scripts/plot/private/__go_draw_figure__.m
+++ b/scripts/plot/private/__go_draw_figure__.m
@@ -153,22 +153,22 @@ function __go_draw_figure__ (h, plot_str
                   endif
                   if (bg_is_set)
                     fprintf (plot_stream, "set border linecolor rgb \"#%02x%02x%02x\"\n", 255 * (1 - bg));
                   endif
                   ## Find if this axes has an associated legend axes and pass it
                   ## to __go_draw_axes__
                   hlegend = [];
                   fkids = get (h, "children");
-                  for j = 1 : numel(fkids)
+                  for j = 1 : numel (fkids)
                     if (ishandle (fkids (j))
                         && strcmp (get (fkids (j), "type"), "axes")
                         && (strcmp (get (fkids (j), "tag"), "legend")))
                       udata = get (fkids (j), "userdata");
-                      if (isscalar(udata.handle)
+                      if (isscalar (udata.handle)
                           && ! isempty (intersect (udata.handle, kids (i))))
                         hlegend = get (fkids (j));
                         break;
                       endif
                     endif
                   endfor
                   __go_draw_axes__ (kids(i), plot_stream, enhanced, mono,
                                     bg_is_set, fg_is_set, hlegend);
diff --git a/scripts/plot/private/__interp_cube__.m b/scripts/plot/private/__interp_cube__.m
--- a/scripts/plot/private/__interp_cube__.m
+++ b/scripts/plot/private/__interp_cube__.m
@@ -18,33 +18,33 @@
 ##
 ## Author: Martin Helm <martin@mhelm.de>
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{vxyz}, @var{idx}, @var{frac}] =} __interp_cube__ (@var{x}, @var{y}, @var{z}, @var{val}, @var{v})
 ## Undocumented internal function.
 ## @end deftypefn
 
-function [Vxyz, idx, frac] = __interp_cube__(x, y, z, val, v, req = "values" )
+function [Vxyz, idx, frac] = __interp_cube__ (x, y, z, val, v, req = "values" )
   if (ismatrix (x) && ndims (x) == 3 && ismatrix (y) && ndims (y) == 3 ...
        && ismatrix (z) && ndims (z) == 3 && size_equal (x, y, z, val))
     x = squeeze (x(1,:,1))(:);
     y = squeeze (y(:,1,1))(:);
     z = squeeze (z(1,1,:))(:);
   elseif (isvector (x) && isvector (y) && isvector (z) )
     x = x(:);
     y = y(:);
     z = z(:);
   else
-    error("__interp_cube__: X, Y, Z have wrong dimensions");
+    error ("__interp_cube__: X, Y, Z have wrong dimensions");
   endif
   if (size (val) != [length(x), length(y), length(z)])
     error ("__interp_cube__: VAL has wrong dimensions");
   endif
-  if (size (v, 2) != 3)
+  if (columns (v) != 3)
     error ( "v has to be N*3 matrix");
   endif
   if (!ischar (req))
    error ("__interp_cube__: Invalid request parameter use 'values', 'normals' or 'normals8'");
   endif
   if (isempty (v))
     Vxyz = idx = frac = [];
     return
@@ -96,17 +96,17 @@ function [Vxyz, idx, frac] = __interp_cu
       dz = [dz;dz(end)](idx(:,3));
       [Dx, Dy, Dz, idx, frac] = interp_cube_trilin_grad (x, y, z, val, v);
       Vxyz = [Dx./dx, Dy./dy, Dz./dz];
    otherwise
      error ("__interp_cube__: Invalid request type '%s', use 'values', 'normals' or 'normals8'", req);
   endswitch
 endfunction
 
-function [Vxyz, idx, frac] = interp_cube_trilin(x, y, z, val, v)
+function [Vxyz, idx, frac] = interp_cube_trilin (x, y, z, val, v)
   [idx, frac] = cube_idx (x(:), y(:), z(:), v);
   sval = size (val);
   i000 = sub2ind (sval, idx(:, 1), idx(:, 2), idx(:, 3));
   i100 = sub2ind (sval, idx(:, 1)+1, idx(:, 2), idx(:, 3));
   i010 = sub2ind (sval, idx(:, 1), idx(:, 2)+1, idx(:, 3));
   i001 = sub2ind (sval, idx(:, 1), idx(:, 2), idx(:, 3)+1);
   i101 = sub2ind (sval, idx(:, 1)+1, idx(:, 2), idx(:, 3)+1);
   i011 = sub2ind (sval, idx(:, 1), idx(:, 2)+1, idx(:, 3)+1);
@@ -121,17 +121,17 @@ function [Vxyz, idx, frac] = interp_cube
     val( i010 ) .* (1 .- Bx) .* By .* (1 .- Bz) .+ ...
     val( i001 ) .* (1 .- Bx) .* (1 .- By) .* Bz .+ ...
     val( i011 ) .* (1 .- Bx) .* By .* Bz .+ ...
     val( i101 ) .* Bx .* (1 .- By) .* Bz .+ ...
     val( i110 ) .* Bx .* By .* (1 .- Bz) .+ ...
     val( i111 ) .* Bx .* By .* Bz;
 endfunction
 
-function [Dx, Dy, Dz, idx, frac] = interp_cube_trilin_grad(x, y, z, val, v)
+function [Dx, Dy, Dz, idx, frac] = interp_cube_trilin_grad (x, y, z, val, v)
   [idx, frac] = cube_idx (x(:), y(:), z(:), v);
   sval = size (val);
   i000 = sub2ind (sval, idx(:, 1), idx(:, 2), idx(:, 3));
   i100 = sub2ind (sval, idx(:, 1)+1, idx(:, 2), idx(:, 3));
   i010 = sub2ind (sval, idx(:, 1), idx(:, 2)+1, idx(:, 3));
   i001 = sub2ind (sval, idx(:, 1), idx(:, 2), idx(:, 3)+1);
   i101 = sub2ind (sval, idx(:, 1)+1, idx(:, 2), idx(:, 3)+1);
   i011 = sub2ind (sval, idx(:, 1), idx(:, 2)+1, idx(:, 3)+1);
@@ -164,17 +164,17 @@ function [Dx, Dy, Dz, idx, frac] = inter
     val( i010 ) .* (1 .- Bx) .* By .* -1 .+ ...
     val( i001 ) .* (1 .- Bx) .* (1 .- By) .+ ...
     val( i011 ) .* (1 .- Bx) .* By + ...
     val( i101 ) .* Bx .* (1 .- By) .+ ...
     val( i110 ) .* Bx .* By .* -1 .+ ...
     val( i111 ) .* Bx .* By;
 endfunction
 
-function [idx, frac] = cube_idx(x, y, z, v)
+function [idx, frac] = cube_idx (x, y, z, v)
   idx = zeros (size (v));
   frac = zeros (size (v));
   idx(:, 2) = lookup (x(2:end-1), v(:, 1)) + 1;
   frac(:, 2) = (v(:, 1) - x(idx(:, 2)) )...
       ./ (x(idx(:, 2)+1) - x(idx(:, 2)));
   idx(:, 1) = lookup (y(2:end-1), v(:, 2)) + 1;
   frac(:, 1) = (v(:, 2) - y(idx(:, 1))) ...
       ./ (y(idx(:, 1)+1) - y(idx(:, 1)));
diff --git a/scripts/plot/private/__marching_cube__.m b/scripts/plot/private/__marching_cube__.m
--- a/scripts/plot/private/__marching_cube__.m
+++ b/scripts/plot/private/__marching_cube__.m
@@ -164,31 +164,31 @@ function [T, p, col] = __marching_cube__
     id_ = ccedge(id__, 2);
     [ix iy iz] = ind2sub (size (cc), id_);
     id_c = sub2ind (size (c), ix, iy, iz);
     id1 = id_c + offset(edges(jj, 1));
     id2 = id_c + offset(edges(jj, 2));
     if (calc_cols)
       pp(id__, 1:5, jj) = [vertex_interp(iso, xx(id1), yy(id1), zz(id1), ...
         xx(id2), yy(id2), zz(id2), c(id1), c(id2), colors(id1), colors(id2)), ...
-        (1:size (id_, 1))' + ix_offset ];
+        (1:rows (id_))' + ix_offset ];
     else
       pp(id__, 1:4, jj) = [vertex_interp(iso, xx(id1), yy(id1), zz(id1), ...
         xx(id2), yy(id2), zz(id2), c(id1), c(id2)), ...
-        (1:size (id_, 1))' + ix_offset ];
+        (1:rows (id_))' + ix_offset ];
     endif
-    ix_offset += size (id_, 1);
+    ix_offset += rows (id_);
   endfor
 
   ## phase III: calculate the triangulation from the point list
   T = [];
   tri = tri_table(cc(id)+1, :);
   for jj=1:3:15
     id_ = find (tri(:, jj)>0);
-    p = [id_, lindex*ones(size (id_, 1), 1),tri(id_, jj:jj+2)];
+    p = [id_, lindex*ones(rows (id_), 1),tri(id_, jj:jj+2)];
     if (!isempty (p))
       p1 = sub2ind (size (pp), p(:,1), p(:,2), p(:,3));
       p2 = sub2ind (size (pp), p(:,1), p(:,2), p(:,4));
       p3 = sub2ind (size (pp), p(:,1), p(:,2), p(:,5));
       T = [T; pp(p1), pp(p2), pp(p3)];
     endif
   endfor
 
@@ -200,17 +200,17 @@ function [T, p, col] = __marching_cube__
       p(pp(idp, lindex, jj), 1:3) = pp(idp, 1:3, jj);
       if (calc_cols)
         col(pp(idp, lindex, jj),1) = pp(idp, 4, jj);
       endif
     endif
   endfor
 endfunction
 
-function p = vertex_interp(isolevel,p1x, p1y, p1z,...
+function p = vertex_interp (isolevel,p1x, p1y, p1z,...
   p2x, p2y, p2z,valp1,valp2, col1, col2)
 
   if (nargin == 9)
     p = zeros (length (p1x), 3);
   elseif (nargin == 11)
     p = zeros (length (p1x), 4);
   else
     error ("__marching_cube__: wrong number of arguments");
diff --git a/scripts/plot/private/__patch__.m b/scripts/plot/private/__patch__.m
--- a/scripts/plot/private/__patch__.m
+++ b/scripts/plot/private/__patch__.m
@@ -35,22 +35,22 @@ function [h, failed] = __patch__ (p, var
   is_numeric_arg = cellfun (@isnumeric, varargin);
 
   if (isempty (varargin))
     args = {"xdata", [0; 1; 0], "ydata", [1; 1; 0], "facecolor", [0, 0, 0]};
     args = setvertexdata (args);
   elseif (isstruct (varargin{1}))
     if (isfield (varargin{1}, "vertices") && isfield (varargin{1}, "faces"))
       args{1} = "faces";
-      args{2} = getfield(varargin{1}, "faces");
+      args{2} = getfield (varargin{1}, "faces");
       args{3} = "vertices";
-      args{4} = getfield(varargin{1}, "vertices");
+      args{4} = getfield (varargin{1}, "vertices");
       args{5} = "facevertexcdata";
       if (isfield (varargin{1}, "facevertexcdata"))
-        args{6} = getfield(varargin{1}, "facevertexcdata");
+        args{6} = getfield (varargin{1}, "facevertexcdata");
       else
         args{6} = [];
       endif
       args = [args; varargin(2:end)];
       args = setdata (args);
     else
       failed = true;
     endif
@@ -92,31 +92,31 @@ function [h, failed] = __patch__ (p, var
 
       if (isvector (x))
         x = x(:);
         y = y(:);
         z = z(:);
         if (isnumeric (c))
           if (isvector (c) && numel (c) == numel (x))
             c = c(:);
-          elseif (size (c, 1) != numel (x) && size (c, 2) == numel (x))
+          elseif (rows (c) != numel (x) && columns (c) == numel (x))
             c = c.';
           endif
         endif
       endif
       args{1} = "xdata";
       args{2} = x;
       args{3} = "ydata";
       args{4} = y;
       args{5} = "zdata";
       args{6} = z;
 
       if (isnumeric (c))
 
-        if (ndims (c) == 3 && size (c, 2) == 1)
+        if (ndims (c) == 3 && columns (c) == 1)
           c = permute (c, [1, 3, 2]);
         endif
 
         if (isvector (c) && numel (c) == columns (x))
           if (isnan (c))
             args{7} = "facecolor";
             args{8} = [1, 1, 1];
             args{9} = "cdata";
@@ -131,24 +131,24 @@ function [h, failed] = __patch__ (p, var
           endif
         elseif (isvector (c) && numel (c) == 3)
           args{7} = "facecolor";
           args{8} = c;
           args{9} = "cdata";
           args{10} = [];
         elseif (ndims (c) == 3 && size (c, 3) == 3)
           ## CDATA is specified as RGB data
-          if ((size (c, 1) == 1 && size (c, 2) == 1) ...
-              || (size (c, 1) == 1 && size (c, 2) == columns (x)))
+          if ((rows (c) == 1 && columns (c) == 1) ...
+              || (rows (c) == 1 && columns (c) == columns (x)))
             ## Single patch color or per-face color
             args{7} = "facecolor";
             args{8} = "flat";
             args{9} = "cdata";
             args{10} = c;
-          elseif (size (c, 1) == rows (x) && size (c, 2) == columns (x))
+          elseif (rows (c) == rows (x) && columns (c) == columns (x))
             ## Per-vertex color
             args{7} = "facecolor";
             args{8} = "interp";
             args{9} = "cdata";
             agrs{10} = c;
           else
             error ("patch: color value not valid");
           endif
@@ -204,17 +204,17 @@ function [h, failed] = __patch__ (p, var
     addlistener (h, "cdata", @update_data);
 
     addlistener (h, "faces", @update_fvc);
     addlistener (h, "vertices", @update_fvc);
     addlistener (h, "facevertexcdata", @update_fvc);
   endif
 endfunction
 
-function args = delfields(args, flds)
+function args = delfields (args, flds)
   idx = cellfun (@(x) any (strcmpi (x, flds)), args);
   if (rows (idx) == 1)
     idx = idx | [false, idx(1:end-1)];
   else
     idx = idx | [false; idx(1:end-1)];
   endif
   args (idx) = [];
 endfunction
@@ -232,56 +232,56 @@ function args = setdata (args)
   endif
   idx = find (strcmpi (args, "vertices"), 1, "last") + 1;
   if (idx > nargs)
     vert = [];
   else
     vert = args {idx};
   endif
   idx = find (strcmpi (args, "facevertexcdata"), 1, "last") + 1;
-  if (isempty(idx) || idx > nargs)
+  if (isempty (idx) || idx > nargs)
     fvc = [];
   else
     fvc = args {idx};
   endif
   idx = find (strcmpi (args, "facecolor"), 1, "last") + 1;
-  if (isempty(idx) || idx > nargs)
+  if (isempty (idx) || idx > nargs)
     if (!isempty (fvc))
       fc = "flat";
     else
       fc = [0, 1, 0];
     endif
     args = {"facecolor", fc, args{:}};
   endif
 
-  nc = size (faces, 1);
+  nc = rows (faces);
   idx = faces .';
   t1 = isnan (idx);
   for i = find (any (t1))
     first_idx_in_column = find (t1(:,i), 1);
     idx(first_idx_in_column:end,i) = idx(first_idx_in_column-1,i);
   endfor
   x = reshape (vert(:,1)(idx), size (idx));
   y = reshape (vert(:,2)(idx), size (idx));
-  if (size(vert,2) > 2)
+  if (columns (vert) > 2)
     z = reshape (vert(:,3)(idx), size (idx));
   else
     z = [];
   endif
 
-  if (size(fvc, 1) == nc || size (fvc, 1) == 1)
+  if (rows (fvc) == nc || rows (fvc) == 1)
     c = reshape (fvc, [1, size(fvc)]);
   else
-    if (size(fvc, 2) == 3)
-      c = cat(3, reshape (fvc(idx, 1), size(idx)),
-              reshape (fvc(idx, 2), size(idx)),
-              reshape (fvc(idx, 3), size(idx)));
+    if (columns (fvc) == 3)
+      c = cat (3, reshape (fvc(idx, 1), size (idx)),
+               reshape (fvc(idx, 2), size (idx)),
+               reshape (fvc(idx, 3), size (idx)));
     elseif (isempty (fvc))
       c = [];
-    else ## if (size (fvc, 2) == 1)
+    else ## if (columnns (fvc) == 1)
       c = permute (fvc(faces), [2, 1]);
     endif
   endif
   args = {"xdata", x, "ydata", y, "zdata", z, "cdata", c, args{:}};
 endfunction
 
 function args = setvertexdata (args)
   args = delfields (args, {"vertices", "faces", "facevertexcdata"});
@@ -296,29 +296,29 @@ function args = setvertexdata (args)
   endif
   idx = find (strcmpi (args, "ydata"), 1, "last") + 1;
   if (idx > nargs)
     y = [];
   else
     y = args {idx};
   endif
   idx = find (strcmpi (args, "zdata"), 1, "last") + 1;
-  if (isempty(idx) || idx > nargs)
+  if (isempty (idx) || idx > nargs)
     z = [];
   else
     z = args {idx};
   endif
   idx = find (strcmpi (args, "cdata"), 1, "last") + 1;
-  if (isempty(idx) || idx > nargs)
+  if (isempty (idx) || idx > nargs)
     c = [];
   else
     c = args {idx};
   endif
   idx = find (strcmpi (args, "facecolor"), 1, "last") + 1;
-  if (isempty(idx) || idx > nargs)
+  if (isempty (idx) || idx > nargs)
     if (!isempty (c))
       fc = "flat";
     else
       fc = [0, 1, 0];
     endif
     args = {"facecolor", fc, args{:}};
   endif
 
@@ -327,21 +327,21 @@ function args = setvertexdata (args)
     nr = nc;
     nc = 1;
   endif
   if (!isempty (z))
     vert = [x(:), y(:), z(:)];
   else
     vert = [x(:), y(:)];
   endif
-  faces = reshape (1:numel(x), nr, nc);
+  faces = reshape (1:numel (x), nr, nc);
   faces = faces';
 
   if (ndims (c) == 3)
-    fvc = reshape (c, size (c, 1) * size (c, 2), size(c, 3));
+    fvc = reshape (c, rows (c) * columns (c), size (c, 3));
   else
     fvc = c(:);
   endif
 
   args = {"faces", faces, "vertices", vert, "facevertexcdata", fvc, args{:}};
 endfunction
 
 function update_data (h, d)
diff --git a/scripts/plot/private/__pie__.m b/scripts/plot/private/__pie__.m
--- a/scripts/plot/private/__pie__.m
+++ b/scripts/plot/private/__pie__.m
@@ -118,37 +118,37 @@ function hlist = __pie__ (caller, vararg
       ln = length (xn);
       zlvl = 0.35;
       sx = repmat (xoff + [0, - sind(xn), 0], [2 1]);
       sy = repmat (yoff + [0, cosd(xn), 0], [2 1]);
       sz = [zeros(1, ln + 2); zlvl * ones(1, ln + 2)];
       sc = i * ones (size (sz));
 
       hlist = [hlist;
-        patch(xoff + [0, - sind(xn)], yoff + [0, cosd(xn)], zeros (1, ln + 1), i);
-        surface(sx, sy, sz, sc);
-        patch(xoff + [0, - sind(xn)], yoff + [0, cosd(xn)], zlvl * ones (1, ln + 1), i);
-        text(xt, yt, zlvl, labels{i})];
+        patch (xoff + [0, - sind(xn)], yoff + [0, cosd(xn)], zeros (1, ln + 1), i);
+        surface (sx, sy, sz, sc);
+        patch (xoff + [0, - sind(xn)], yoff + [0, cosd(xn)], zlvl * ones (1, ln + 1), i);
+        text (xt, yt, zlvl, labels{i})];
 
     elseif (strncmp (caller, "pie", 3))
       if (xt > 0)
         align = "left";
       else
         align = "right";
       endif
 
       hlist = [hlist; patch(xoff + [0, - sind(xn)], yoff + [0, cosd(xn)], i);
-               text(xt, yt, labels{i}, "horizontalalignment", align)];
+               text (xt, yt, labels{i}, "horizontalalignment", align)];
 
     else
       error ("__pie__: unknown caller `%s'", caller);
     endif
   endfor
 
-  addlistener(gca, "view", {@update_text_pos, hlist});
+  addlistener (gca, "view", {@update_text_pos, hlist});
 
   if (strncmp (caller, "pie3", 4))
     axis ([-1.25, 1.25, -1.25, 1.25, -0.05, 0.4], "equal", "off");
     view (-37.5, 30);
   elseif (strncmp (caller, "pie", 3))
     axis ([-1.5, 1.5, -1.5, 1.5], "square", "off");
   endif
 endfunction
diff --git a/scripts/plot/private/__plt__.m b/scripts/plot/private/__plt__.m
--- a/scripts/plot/private/__plt__.m
+++ b/scripts/plot/private/__plt__.m
@@ -33,17 +33,17 @@ function retval = __plt__ (caller, h, va
 
     x_set = false;
     y_set = false;
     property_set = false;
     properties = {};
 
     hlegend = [];
     fkids = get (gcf (), "children");
-    for i = 1 : numel(fkids)
+    for i = 1 : numel (fkids)
       if (ishandle (fkids (i)) && strcmp (get (fkids (i), "type"), "axes")
           && (strcmp (get (fkids (i), "tag"), "legend")))
         udata = get (fkids (i), "userdata");
         if (! isempty (intersect (udata.handle, gca ())))
           hlegend = fkids (i);
           break;
         endif
       endif
diff --git a/scripts/plot/private/__print_parse_opts__.m b/scripts/plot/private/__print_parse_opts__.m
--- a/scripts/plot/private/__print_parse_opts__.m
+++ b/scripts/plot/private/__print_parse_opts__.m
@@ -72,17 +72,17 @@ function arg_st = __print_parse_opts__ (
   endif
   arg_st.unlink = {};
 
   if (nargin > 0 && isfigure (varargin{1}))
     arg_st.figure = varargin{1};
     varargin(1) = [];
   endif
 
-  for i = 1:numel(varargin)
+  for i = 1:numel (varargin)
     arg = strtrim (varargin{i});
     if (ischar (arg))
       if (strcmp (arg, "-color"))
         arg_st.use_color = 1;
       elseif (strcmp (arg, "-append"))
         arg_st.append_to_file = true;
       elseif (strcmp (arg, "-mono"))
         arg_st.use_color = -1;
@@ -564,17 +564,17 @@ function [papersize, paperposition] = gs
   else
     paperposition = convert2points (paperposition, paperunits);
   endif
 
   ## FIXME - This will be obsoleted by listeners for paper properties.
   ##         Papersize is tall when portrait,and wide when landscape.
   if ((papersize(1) > papersize(2) && strcmpi (paperorientation, "portrait"))
       || (papersize(1) < papersize(2) && strcmpi (paperorientation, "landscape")))
-    papersize = papersize ([2,1]);
+    papersize = papersize([2,1]);
     paperposition = paperposition([2,1,4,3]);
   endif
 
   if ((! strcmp (papertype, "<custom>")) && (strcmp (paperorientation, "portrait")))
     ## For portrait use the ghostscript name
     papersize = papertype;
     papersize(papersize=="-") = "";
     papersize = strrep (papersize, "us", "");
diff --git a/scripts/plot/private/__quiver__.m b/scripts/plot/private/__quiver__.m
--- a/scripts/plot/private/__quiver__.m
+++ b/scripts/plot/private/__quiver__.m
@@ -38,36 +38,36 @@ function hg = __quiver__ (varargin)
   endfor
 
   ioff = 3;
   if (nargin < (6 + is3d) || firstnonnumeric < (6 + is3d))
     u = varargin{ioff++};
     v = varargin{ioff++};
     if (is3d)
       w = varargin{ioff++};
-      [x, y, z] = meshgrid (1:size(u,2), 1:size(u,1), 1:max(size(w)));
+      [x, y, z] = meshgrid (1:columns (u), 1:rows (u), 1:max (size (w)));
     else
-      [x, y] = meshgrid (1:size(u,2), 1:size(u,1));
+      [x, y] = meshgrid (1:columns (u), 1:rows (u));
     endif
     if (nargin >= ioff && isnumeric (varargin{ioff})
         && isscalar (varargin{ioff}))
       autoscale = varargin{ioff++};
     endif
   else
     x = varargin{ioff++};
     y = varargin{ioff++};
     if (is3d)
       z = varargin{ioff++};
     endif
     u = varargin{ioff++};
     v = varargin{ioff++};
     if (is3d)
       w = varargin{ioff++};
       if (isvector (x) && isvector (y) && isvector (z)
-          && (! isvector (u) || ! isvector (v) || ! isvector(w)))
+          && (! isvector (u) || ! isvector (v) || ! isvector (w)))
         [x, y, z] = meshgrid (x, y, z);
       endif
     else
       if (isvector (x) && isvector (y) && (! isvector (u) || ! isvector (v)))
         [x, y] = meshgrid (x, y);
       endif
     endif
     if (nargin >= ioff && isnumeric (varargin{ioff})
@@ -107,29 +107,29 @@ function hg = __quiver__ (varargin)
 
   if (autoscale && numel (u) > 1)
     ## Scale the arrows to fit in the grid
     if (isvector (x))
       ny = nx = length (x);
     else
       [nx, ny] = size (x);
     endif
-    dx = (max(x(:)) - min(x(:))) ./ nx;
-    dy = (max(y(:)) - min(y(:))) ./ ny;
+    dx = (max (x(:)) - min (x(:))) ./ nx;
+    dy = (max (y(:)) - min (y(:))) ./ ny;
     if (is3d)
-      dz = (max(z(:)) - min(z(:))) ./ max (size (z));
+      dz = (max (z(:)) - min (z(:))) ./ max (size (z));
       len = max (sqrt (u(:).^2 + v(:).^2 + w(:).^2));
     else
       dz = 0;
       len = max (sqrt (u(:).^2 + v(:).^2));
     endif
     if (len > 0)
       sd = sqrt (dx.^2 + dy.^2 + dz.^2) / len;
       if (sd != 0)
-        s = sqrt(2) * autoscale * sd;
+        s = sqrt (2) * autoscale * sd;
       else # special case of identical points with multiple vectors
         s = autoscale;
       endif
       uu = s * u;
       vv = s * v;
       if (is3d)
         ww = s*w;
       endif
@@ -344,29 +344,29 @@ function update_data (h, d)
 
   if (strcmpi (get (h, "autoscale"), "on") && s != 0)
     ## Scale the arrows to fit in the grid
     if (isvector (x))
       ny = nx = length (x);
     else
       [nx, ny] = size (x);
     endif
-    dx = (max(x(:)) - min(x(:))) ./ nx;
-    dy = (max(y(:)) - min(y(:))) ./ ny;
+    dx = (max (x(:)) - min (x(:))) ./ nx;
+    dy = (max (y(:)) - min (y(:))) ./ ny;
     if (is3d)
-      dz = (max(z(:)) - min(z(:))) ./ max (size (z));
+      dz = (max (z(:)) - min (z(:))) ./ max (size (z));
       len = max (sqrt (u(:).^2 + v(:).^2 + w(:).^2));
     else
       dz = 0;
       len = max (sqrt (u(:).^2 + v(:).^2));
     endif
     if (len > 0)
       sd = sqrt (dx.^2 + dy.^2 + dz.^2) / len;
       if (sd != 0)
-        s *= sqrt(2) * sd;
+        s *= sqrt (2) * sd;
       endif
       u = s * u;
       v = s * v;
       if (is3d)
         w = s*w;
       endif
     endif
   endif
diff --git a/scripts/plot/private/__scatter__.m b/scripts/plot/private/__scatter__.m
--- a/scripts/plot/private/__scatter__.m
+++ b/scripts/plot/private/__scatter__.m
@@ -27,23 +27,23 @@ function hg = __scatter__ (varargin)
   nd = varargin{2};
   fcn = varargin{3};
   x = varargin{4}(:);
   y = varargin{5}(:);
   istart = 6;
 
   if (nd == 3)
     z = varargin{6}(:);
-    idx = isnan(x) | isnan (y) | isnan (z);
+    idx = isnan (x) | isnan (y) | isnan (z);
     x (idx) = [];
     y (idx) = [];
     z (idx) = [];
     istart = 7;
   else
-    idx = isnan(x) | isnan (y);
+    idx = isnan (x) | isnan (y);
     x (idx) = [];
     y (idx) = [];
     z = zeros (length (x), 0);
   endif
 
   firstnonnumeric = Inf;
   for i = istart:nargin
     if (! isnumeric (varargin{i}))
@@ -135,17 +135,17 @@ function hg = __scatter__ (varargin)
 
   one_explicit_color = ischar (c) || isequal (size (c), [1, 3]);
 
   if (numel (x) <= 100)
 
     ## For small number of points, we'll construct an object for each point.
 
     if (numel (s) == 1)
-      s = repmat (s, numel(x), 1);
+      s = repmat (s, numel (x), 1);
     endif
 
     if (one_explicit_color)
       for i = 1 : numel (x)
         if (filled)
           h = __go_patch__ (hg, "xdata", x(i), "ydata", y(i), "zdata", z(i,:),
                             "faces", 1, "vertices", [x(i), y(i), z(i,:)],
                             "facecolor", "none", "edgecolor", "none",
@@ -217,21 +217,21 @@ function hg = __scatter__ (varargin)
       endfor
 
     endif
   endif
 
   if (! ischar (c) && rows (c) > 1)
     ax = get (hg, "parent");
     clim = get (ax, "clim");
-    if (min(c(:)) < clim(1))
-      clim(1) = min(c(:));
+    if (min (c(:)) < clim(1))
+      clim(1) = min (c(:));
       set (ax, "clim", clim);
     endif
-    if (max(c(:)) > clim(2))
+    if (max (c(:)) > clim(2))
       set (ax, "clim", [clim(1), max(c(:))]);
     endif
   endif
 
   addproperty ("linewidth", hg, "patchlinewidth", 0.5);
   addproperty ("marker", hg, "patchmarker", marker);
   if (filled)
     addproperty ("markeredgecolor", hg, "patchmarkeredgecolor", "none");
@@ -254,58 +254,58 @@ function hg = __scatter__ (varargin)
   addlistener (hg, "markeredgecolor", @update_props);
 
   if (! isempty (newargs))
     set (hg, newargs{:});
   endif
 
 endfunction
 
-function h = render_size_color(hg, vert, s, c, marker, filled, isflat)
+function h = render_size_color (hg, vert, s, c, marker, filled, isflat)
   if (isscalar (s))
     x = vert(:,1);
     y = vert(:,2);
     z = vert(:,3:end);
     toolkit = get (ancestor (hg, "figure"), "__graphics_toolkit__");
     ## Does gnuplot only support triangles with different vertex colors ?
     ## TODO - Verify gnuplot can only support one color. If RGB triplets
     ##        can be assigned to each vertex, then fix __go_draw_axe__.m
     gnuplot_hack = (numel (x) > 1 && columns (c) == 3
                     && strcmp (toolkit, "gnuplot"));
     if (ischar (c) || ! isflat || gnuplot_hack)
       if (filled)
         h = __go_patch__ (hg, "xdata", x, "ydata", y, "zdata", z,
-                          "faces", 1:numel(x), "vertices", vert,
+                          "faces", 1:numel (x), "vertices", vert,
                           "facecolor", "none", "edgecolor", "none",
                           "marker", marker,
                           "markeredgecolor", "none",
                           "markerfacecolor", c(1,:),
                           "markersize", s, "linestyle", "none");
       else
         h = __go_patch__ (hg, "xdata", x, "ydata", y, "zdata", z,
-                          "faces", 1:numel(x), "vertices", vert,
+                          "faces", 1:numel (x), "vertices", vert,
                           "facecolor", "none", "edgecolor", "none",
                           "marker", marker,
                           "markeredgecolor", c(1,:),
                           "markerfacecolor", "none",
                           "markersize", s, "linestyle", "none");
       endif
     else
       if (filled)
         h = __go_patch__ (hg, "xdata", x, "ydata", y, "zdata", z,
-                          "faces", 1:numel(x), "vertices", vert,
+                          "faces", 1:numel (x), "vertices", vert,
                           "facecolor", "none", "edgecolor", "none",
                           "marker", marker, "markersize", s,
                           "markeredgecolor", "none",
                           "markerfacecolor", "flat",
                           "cdata", c, "facevertexcdata", c,
                           "linestyle", "none");
       else
         h = __go_patch__ (hg, "xdata", x, "ydata", y, "zdata", z,
-                          "faces", 1:numel(x), "vertices", vert,
+                          "faces", 1:numel (x), "vertices", vert,
                           "facecolor", "none", "edgecolor", "none",
                           "marker", marker, "markersize", s,
                           "markeredgecolor", "flat",
                           "markerfacecolor", "none",
                           "cdata", c, "facevertexcdata", c,
                           "linestyle", "none");
       endif
     endif
@@ -357,22 +357,22 @@ function update_data (h, d)
         set (hlist(i), "vertices", [x1(i), y1(i), z1(i)], "cdata", c1,
              "markersize", size1(i));
       endfor
     endif
   else
     if (isempty (z1))
       for i = 1 : length (hlist)
         set (hlist(i), "vertices", [x1(i), y1(i)], "cdata",
-             reshape(c1(i,:),[1, size(c1)(2:end)]),
+             reshape (c1(i,:),[1, size(c1)(2:end)]),
              "facevertexcdata", c1(i,:),
              "markersize", size1(i));
       endfor
     else
       for i = 1 : length (hlist)
         set (hlist(i), "vertices", [x1(i), y1(i), z1(i)], "cdata",
-             reshape(c1(i,:),[1, size(c1)(2:end)]),
+             reshape (c1(i,:),[1, size(c1)(2:end)]),
              "facevertexcdata", c1(i,:),
              "markersize", size1(i));
       endfor
     endif
   endif
 endfunction
diff --git a/scripts/plot/private/__stem__.m b/scripts/plot/private/__stem__.m
--- a/scripts/plot/private/__stem__.m
+++ b/scripts/plot/private/__stem__.m
@@ -142,17 +142,17 @@ function h = __stem__ (have_z, varargin)
 
       addlistener (hg, "xdata", @update_data);
       addlistener (hg, "ydata", @update_data);
       addlistener (hg, "zdata", @update_data);
 
       if (! isempty (args))
         set (hg, args{:});
       endif
-      if (i == 1 && !isempty(h_baseline))
+      if (i == 1 && ! isempty (h_baseline))
         set (h_baseline, "parent", get (hg, "parent"));
       endif
     endfor
 
   unwind_protect_cleanup
     set (ax, "nextplot", hold_state);
     axes (oldax);
   end_unwind_protect
@@ -291,17 +291,17 @@ function [x, y, z, dofill, lc, ls, mc, m
       else
         ## must be the real y data.
         x = varargin{1};
         y = varargin{2};
         if (! (ismatrix (x) && ismatrix (y)))
           error ("stem: X and Y must be matrices");
         endif
       endif
-    endif # if ischar(varargin{2})
+    endif # if ischar (varargin{2})
     if (! have_z)
       ## varargin{3} must be char.
       ## Check for "fill.
       if ((strcmpi (varargin{3}, "fill") || strcmpi (varargin{3}, "filled"))
           && fill_2)
         error ("stem: duplicate fill argument");
       elseif (strcmpi ("fill", varargin{3}) && linespec_2)
         ## Must be "fill".
@@ -431,17 +431,17 @@ endfunction
 function [lc, ls, mc, ms] = stem_line_spec (caller, str)
   if (! ischar (str))
     error ("%s: expecting argument to be \"fill\" or a string of specifiers",
            caller);
   endif
   [lc, ls, mc, ms] = set_default_values ();
   ## Parse the line specifier string.
   cur_props = __pltopt__ ("stem", str, false);
-  for i = 1:length(cur_props)
+  for i = 1:length (cur_props)
     if (isfield (cur_props(i), "color") && ! isempty (cur_props(i).color)); # means line color
       mc = lc = cur_props(i).color;
     elseif (isfield (cur_props(i), "linestyle"))
       ls = cur_props(i).linestyle;
       if (isempty (ls))
         ls = __next_line_style__ ();
       endif
     elseif (isfield (cur_props(i), "marker") && ! strcmpi (cur_props(i).marker, "none"))
@@ -503,17 +503,17 @@ function move_baseline (h, d)
   b0 = get (h, "basevalue");
   bl = get (h, "baseline");
 
   if (get (bl, "ydata") != [b0, b0])
     set (bl, "ydata", [b0, b0]);
   endif
 
   kids = get (h, "children");
-  yt = get(h, "ydata")(:)';
+  yt = get (h, "ydata")(:)';
   ny = length (yt);
   yt = [b0 * ones(1, ny); yt; NaN(1, ny)](:);
   set (kids(2), "ydata", yt);
 endfunction
 
 function update_props (h, d)
   kids = get (h, "children");
   set (kids(2), "color", get (h, "color"),
@@ -527,17 +527,17 @@ endfunction
 
 function update_data (h, d)
   x = get (h, "xdata");
   y = get (h, "ydata");
   z = get (h, "zdata");
 
   if (!isempty (z) && size_equal (x, y, z))
     error ("stem3: inconsistent size of x, y and z");
-  elseif (numel(x) != numel (y))
+  elseif (numel (x) != numel (y))
     error ("stem: inconsistent size of x and y");
   else
     bl = get (h, "basevalue");
     nx = numel (x);
     x = x(:)';
     xt = [x; x; NaN(1, nx)](:);
     if (! isempty (z))
       y = y(:)';
diff --git a/scripts/plot/private/__tight_eps_bbox__.m b/scripts/plot/private/__tight_eps_bbox__.m
--- a/scripts/plot/private/__tight_eps_bbox__.m
+++ b/scripts/plot/private/__tight_eps_bbox__.m
@@ -53,22 +53,22 @@ function bb = __tight_eps_bbox__ (opts, 
 
   ## Attempt to fix the bbox in place.
   fid = fopen (eps_file_name, "r+");
   unwind_protect
     bbox_replaced = false;
     looking_for_bbox = true;
     while (looking_for_bbox)
       current_line = fgetl (fid);
-      if (strncmpi (current_line, box_string, numel(box_string)))
+      if (strncmpi (current_line, box_string, numel (box_string)))
         line_length = numel (current_line);
         num_spaces = line_length - numel (tight_bbox_line);
         if (numel (current_line) >= numel (tight_bbox_line))
           new_line = tight_bbox_line;
-          new_line(end+1:numel(current_line)) = " ";
+          new_line(end+1:numel (current_line)) = " ";
           bbox_replaced = true;
           ## Back up to the beginning of the line (include EOL characters).
           if (ispc ())
             fseek (fid, -line_length-2, "cof");
           else
             fseek (fid, -line_length-1, "cof");
           endif
           count = fprintf (fid, "%s", new_line);
@@ -108,17 +108,17 @@ function bb = __tight_eps_bbox__ (opts, 
     end_unwind_protect
   endif
 
 endfunction
 
 function bbox_line = get_bbox (lines)
   box_string = "%%BoundingBox:";
   pattern = strcat (box_string, "[^%]*");
-  pattern = pattern(1:find(double(pattern)>32, 1, "last"));
+  pattern = pattern(1:find (double (pattern) > 32, 1, "last"));
   bbox_line = regexp (lines, pattern, "match");
   if (iscell (bbox_line))
     bbox_line = bbox_line{1};
   endif
   ## Remove the EOL characters.
-  bbox_line(double(bbox_line)<32) = "";
+  bbox_line(double (bbox_line) < 32) = "";
 endfunction
 
diff --git a/scripts/plot/private/__uigetdir_fltk__.m b/scripts/plot/private/__uigetdir_fltk__.m
--- a/scripts/plot/private/__uigetdir_fltk__.m
+++ b/scripts/plot/private/__uigetdir_fltk__.m
@@ -20,15 +20,15 @@
 ## @deftypefn {Function File} {@var{dirname} =} __uigetdir_fltk__ (@var{start_path}, @var{dialog_title})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Author: Michael Goffioul
 
 function dirname = __uigetdir_fltk__ (start_path, dialog_title)
 
-  if (exist("__fltk_uigetfile__") != 3)
+  if (exist ("__fltk_uigetfile__") != 3)
     error ("uigetdir: fltk graphics toolkit required");
   endif
 
   dirname = __fltk_uigetfile__ ("", dialog_title, start_path, [240, 120], "dir");
 
 endfunction
diff --git a/scripts/plot/private/__uigetfile_fltk__.m b/scripts/plot/private/__uigetfile_fltk__.m
--- a/scripts/plot/private/__uigetfile_fltk__.m
+++ b/scripts/plot/private/__uigetfile_fltk__.m
@@ -20,17 +20,17 @@
 ## @deftypefn {Function File} {[@var{fname}, @var{fpath}, @var{fltidx}] =} __uigetfile_fltk__ ()
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Author: Michael Goffioul
 
 function [retval, retpath, retindex] = __uigetfile_fltk__ (filters, title, defval, position, multiselect, defdir)
 
-  if (exist("__fltk_uigetfile__") != 3)
+  if (exist ("__fltk_uigetfile__") != 3)
     error ("uigetfile: fltk graphics toolkit required");
   endif
 
   filters = __fltk_file_filter__ (filters);
   if (length (defdir) > 0)
     defval = fullfile (defdir, defval);
   endif
   [retval, retpath, retindex] = __fltk_uigetfile__ (filters, title, defval, position, multiselect);
diff --git a/scripts/plot/private/__uiputfile_fltk__.m b/scripts/plot/private/__uiputfile_fltk__.m
--- a/scripts/plot/private/__uiputfile_fltk__.m
+++ b/scripts/plot/private/__uiputfile_fltk__.m
@@ -20,17 +20,17 @@
 ## @deftypefn {Function File} {[@var{fname}, @var{fpath}, @var{fltidx}] =} __uiputfile_fltk__ ()
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Author: Michael Goffioul
 
 function [retval, retpath, retindex] = __uiputfile_fltk__ (filters, title, defval, position, tag, defdir)
 
-  if (exist("__fltk_uigetfile__") != 3)
+  if (exist ("__fltk_uigetfile__") != 3)
     error ("uiputfile: fltk graphics toolkit required");
   endif
 
   filters = __fltk_file_filter__ (filters);
   if (length (defdir) > 0)
     defval = fullfile (defdir, defval);
   endif
   [retval, retpath, retindex] = __fltk_uigetfile__ (filters, title, defval, position, tag);
diff --git a/scripts/plot/quiver.m b/scripts/plot/quiver.m
--- a/scripts/plot/quiver.m
+++ b/scripts/plot/quiver.m
@@ -26,17 +26,17 @@
 ## @deftypefnx {Function File} {@var{h} =} quiver (@dots{})
 ##
 ## Plot the @code{(@var{u}, @var{v})} components of a vector field in
 ## an @code{(@var{x}, @var{y})} meshgrid.  If the grid is uniform, you can
 ## specify @var{x} and @var{y} as vectors.
 ##
 ## If @var{x} and @var{y} are undefined they are assumed to be
 ## @code{(1:@var{m}, 1:@var{n})} where @code{[@var{m}, @var{n}] =
-## size(@var{u})}.
+## size (@var{u})}.
 ##
 ## The variable @var{s} is a scalar defining a scaling factor to use for
 ## the arrows of the field relative to the mesh spacing.  A value of 0
 ## disables all scaling.  The default value is 1.
 ##
 ## The style to use for the plot can be defined with a line style @var{style}
 ## in a similar manner to the line styles used with the @code{plot} command.
 ## If a marker is specified then markers at the grid points of the vectors are
diff --git a/scripts/plot/quiver3.m b/scripts/plot/quiver3.m
--- a/scripts/plot/quiver3.m
+++ b/scripts/plot/quiver3.m
@@ -26,17 +26,17 @@
 ## @deftypefnx {Function File} {@var{h} =} quiver3 (@dots{})
 ##
 ## Plot the @code{(@var{u}, @var{v}, @var{w})} components of a vector field in
 ## an @code{(@var{x}, @var{y}), @var{z}} meshgrid.  If the grid is uniform, you
 ## can specify @var{x}, @var{y} @var{z} as vectors.
 ##
 ## If @var{x}, @var{y} and @var{z} are undefined they are assumed to be
 ## @code{(1:@var{m}, 1:@var{n}, 1:@var{p})} where @code{[@var{m}, @var{n}] =
-## size(@var{u})} and @code{@var{p} = max (size (@var{w}))}.
+## size (@var{u})} and @code{@var{p} = max (size (@var{w}))}.
 ##
 ## The variable @var{s} is a scalar defining a scaling factor to use for
 ##  the arrows of the field relative to the mesh spacing.  A value of 0
 ## disables all scaling.  The default value is 1.
 ##
 ## The style to use for the plot can be defined with a line style @var{style}
 ## in a similar manner to the line styles used with the @code{plot} command.
 ## If a marker is specified then markers at the grid points of the vectors are
diff --git a/scripts/plot/rectangle.m b/scripts/plot/rectangle.m
--- a/scripts/plot/rectangle.m
+++ b/scripts/plot/rectangle.m
@@ -67,17 +67,17 @@ function hg = __rectangle__ (hax, vararg
   iarg = 1;
   pos = [0, 0, 1, 1];
   curv2 = [0, 0];
   ec = [0, 0, 0];
   fc = "none";
 
   while (iarg < length (varargin))
     arg = varargin{iarg};
-    if (ischar(arg))
+    if (ischar (arg))
       if (strcmpi (arg, "position"))
         pos = varargin{iarg+1};
         varargin(iarg:iarg+1) = [];
         if (!isvector (pos) || numel (pos) != 4)
           error ("rectangle: position must be a 4 element vector");
         endif
       elseif (strcmpi (arg, "curvature"))
         curv2 = varargin{iarg+1};
diff --git a/scripts/plot/refreshdata.m b/scripts/plot/refreshdata.m
--- a/scripts/plot/refreshdata.m
+++ b/scripts/plot/refreshdata.m
@@ -77,17 +77,17 @@ function refreshdata (h, workspace)
 
   h = findall (h);
   objs = [];
   props = {};
 
   for i = 1 : numel (h)
     obj = get (h (i));
     fldnames = fieldnames (obj);
-    m = regexpi (fieldnames(obj), '^.+datasource$', "match");
+    m = regexpi (fieldnames (obj), '^.+datasource$', "match");
     idx = ! cellfun ("isempty", m);
     if (any (idx))
       tmp = m(idx);
       props = [props; {vertcat(tmp{:})}];
       objs  = [objs ; h(i)];
     endif
   endfor
 
diff --git a/scripts/plot/ribbon.m b/scripts/plot/ribbon.m
--- a/scripts/plot/ribbon.m
+++ b/scripts/plot/ribbon.m
@@ -18,17 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ribbon (@var{x}, @var{y}, @var{width})
 ## @deftypefnx {Function File} {} ribbon (@var{y})
 ## @deftypefnx {Function File} {@var{h} =} ribbon (@dots{})
 ## Plot a ribbon plot for the columns of @var{y} vs.  @var{x}.  The
 ## optional parameter @var{width} specifies the width of a single ribbon
 ## (default is 0.75).  If @var{x} is omitted, a vector containing the
-## row numbers is assumed (1:rows(Y)).
+## row numbers is assumed (1:rows (Y)).
 ##
 ## The optional return value @var{h} is a vector of graphics handles to
 ## the surface objects representing each ribbon.
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel at gmx.de>
 
 function h = ribbon (x, y, width = 0.75)
diff --git a/scripts/plot/rose.m b/scripts/plot/rose.m
--- a/scripts/plot/rose.m
+++ b/scripts/plot/rose.m
@@ -75,17 +75,17 @@ function [thout, rout] = rose (varargin)
   [nn, xx] = hist (th, x);
   xx = xx(:).';
   if (isvector (nn))
     nn = nn (:);
   endif
   x1 = xx(1:end-1) + diff (xx, 1) / 2;
   x1 = [x1 ; x1; x1; x1](:);
   th = [0; 0; x1; 2*pi ; 2*pi];
-  r = zeros (4 * size (nn, 1), size (nn, 2));
+  r = zeros (4 * rows (nn), columns (nn));
   r(2:4:end, :) = nn;
   r(3:4:end, :) = nn;
 
   if (nargout < 2)
     oldh = gca ();
     unwind_protect
       axes (h);
       newplot ();
diff --git a/scripts/plot/scatter.m b/scripts/plot/scatter.m
--- a/scripts/plot/scatter.m
+++ b/scripts/plot/scatter.m
@@ -45,17 +45,17 @@
 ## additional arguments are passed to the underlying patch command.
 ##
 ## The optional return value @var{h} provides a handle to the patch object
 ##
 ## @example
 ## @group
 ## x = randn (100, 1);
 ## y = randn (100, 1);
-## scatter (x, y, [], sqrt(x.^2 + y.^2));
+## scatter (x, y, [], sqrt (x.^2 + y.^2));
 ## @end group
 ## @end example
 ##
 ## @seealso{plot, patch, scatter3}
 ## @end deftypefn
 
 function retval = scatter (varargin)
 
diff --git a/scripts/plot/semilogy.m b/scripts/plot/semilogy.m
--- a/scripts/plot/semilogy.m
+++ b/scripts/plot/semilogy.m
@@ -42,17 +42,17 @@ function retval = semilogy (varargin)
   endif
 
   oldh = gca ();
   unwind_protect
     axes (h);
     newplot ();
 
     set (h, "yscale", "log");
-    if (any( strcmp (get (gca, "nextplot"), {"new", "replace"})))
+    if (any (strcmp (get (gca, "nextplot"), {"new", "replace"})))
       set (h, "yminortick", "on");
     endif
 
     tmp = __plt__ ("semilogy", h, varargin{:});
 
     if (nargout > 0)
       retval = tmp;
     endif
diff --git a/scripts/plot/shading.m b/scripts/plot/shading.m
--- a/scripts/plot/shading.m
+++ b/scripts/plot/shading.m
@@ -50,17 +50,17 @@ function shading (varargin)
 
   mode = varargin{1};
 
   h1 = findobj (ax, "type", "patch");
   h2 = findobj (ax, "type", "surface");
 
   obj = [h1(:); h2(:)];
 
-  for n = 1:numel(obj)
+  for n = 1:numel (obj)
     h = obj(n);
     if (strcmpi (mode, "flat"))
       set (h, "facecolor", "flat");
       set (h, "edgecolor", "none");
     elseif (strcmpi (mode, "interp"))
       set (h, "facecolor", "interp");
       set (h, "edgecolor", "none");
     elseif (strcmpi (mode, "faceted"))
diff --git a/scripts/plot/shrinkfaces.m b/scripts/plot/shrinkfaces.m
--- a/scripts/plot/shrinkfaces.m
+++ b/scripts/plot/shrinkfaces.m
@@ -99,36 +99,36 @@ function [nf, nv] = shrinkfaces (varargi
   else
     print_usage ();
   endif
   
   if (! isscalar (sf) || sf <= 0)
     error ("shrinkfaces: scale factor must be a positive scalar")
   endif
 
-  n = size (vertices, 2);
+  n = columns (vertices);
   if (n < 2 || n > 3)
     error ("shrinkfaces: only 2D and 3D patches are supported")
   endif
 
-  m = size (faces, 2);
+  m = columns (faces);
   if (m < 3)
     error ("shrinkfaces: faces must consist of at least 3 vertices")
   endif
 
   v = vertices(faces'(:), :);
-  if (isempty (colors) || size (colors, 1) == size (faces, 1))
+  if (isempty (colors) || rows (colors) == rows (faces))
     c = colors;
-  elseif (size (colors, 1) == size (vertices, 1))
+  elseif (rows (colors) == rows (vertices))
     c = colors(faces'(:), :);
   else
     ## Discard inconsistent color data.
     c = [];
   endif
-  sv = size (v, 1);
+  sv = rows (v);
   ## we have to deal with a probably very large number of vertices, so
   ## use sparse we use as midpoint (1/m, ..., 1/m) in generalized
   ## barycentric coordinates.
   midpoints = full (kron ( speye (sv / m), ones (m, m) / m) * sparse (v));
   v = sqrt (sf) * (v - midpoints) + midpoints;
   f = reshape (1:sv, m, sv / m)';
   
   switch (nargout)
diff --git a/scripts/plot/slice.m b/scripts/plot/slice.m
--- a/scripts/plot/slice.m
+++ b/scripts/plot/slice.m
@@ -99,70 +99,70 @@ function h = slice (varargin)
   elseif (nargs == 7)
     v = varargin{4};
     if (ndims (v) != 3)
       error ("slice: expect 3-dimensional array of values");
     endif
     x = varargin{1};
     y = varargin{2};
     z = varargin{3};
-    if (all ([isvector(x), isvector(y), isvector(z)]))
+    if (isvector (x) && isvector (y) && isvector (z)]))
       [x, y, z] = meshgrid (x, y, z);
     elseif (ndims (x) == 3 && size_equal (x, y, z))
       ## Do nothing.
     else
       error ("slice: X, Y, Z size mismatch");
     endif
     sx = varargin{5};
     sy = varargin{6};
     sz = varargin{7};
   else
     print_usage ();
   endif
 
   if (any ([isvector(sx), isvector(sy), isvector(sz)]))
     have_sval = true;
-  elseif (ndims(sx) == 2 && size_equal (sx, sy, sz))
+  elseif (ndims (sx) == 2 && size_equal (sx, sy, sz))
     have_sval = false;
   else
     error ("slice: dimensional mismatch for (XI, YI, ZI) or (SX, SY, SZ)");
   endif
 
   newplot ();
   ax = gca ();
   sidx = 1;
   maxv = max (v(:));
   minv = min (v(:));
   set (ax, "clim", [minv, maxv]);
 
   if (have_sval)
     ns = length (sx) + length (sy) + length (sz);
-    hs = zeros(ns,1);
+    hs = zeros (ns,1);
     [ny, nx, nz] = size (v);
-    if (length(sz) > 0)
-      for i = 1:length(sz)
+    if (length (sz) > 0)
+      for i = 1:length (sz)
         [xi, yi, zi] = meshgrid (squeeze (x(1,:,1)),
                                  squeeze (y(:,1,1)), sz(i));
         vz = squeeze (interp3 (x, y, z, v, xi, yi, zi, method));
         tmp(sidx++) = surface (xi, yi, sz(i) * ones (size (yi)), vz);
       endfor
     endif
 
     if (length (sy) > 0)
-      for i = length(sy):-1:1
+      for i = length (sy):-1:1
         [xi, yi, zi] = meshgrid (squeeze (x(1,:,1)), sy(i), squeeze (z(1,1,:)));
         vy = squeeze (interp3 (x, y, z, v, xi, yi, zi, method));
         tmp(sidx++) = surface (squeeze (xi),
                                squeeze (sy(i) * ones (size (zi))),
                                squeeze (zi), vy);
       endfor
     endif
 
     if (length (sx) > 0)
-      for i = length(sx):-1:1
+      for i = length (sx):-1:1
         [xi, yi, zi] = meshgrid (sx(i), squeeze (y(:,1,1)), squeeze (z(1,1,:)));
         vx = squeeze (interp3 (x, y, z, v, xi, yi, zi, method));
         tmp(sidx++) = surface (squeeze (sx(i) * ones (size (zi))),
                                squeeze (yi), squeeze(zi), vx);
       endfor
     endif
   else
     vi = interp3 (x, y, z, v, sx, sy, sz);
diff --git a/scripts/plot/stairs.m b/scripts/plot/stairs.m
--- a/scripts/plot/stairs.m
+++ b/scripts/plot/stairs.m
@@ -151,17 +151,17 @@ function [h, xs, ys] = __stairs__ (doplo
       endif
     endif
   endfor
 
   if (doplot)
     h = [];
     unwind_protect
       hold_state = get (gca (), "nextplot");
-      for i = 1 : size(y, 2)
+      for i = 1 : columns (y)
         hg = hggroup ();
         h = [h; hg];
         args = __add_datasource__ ("stairs", hg, {"x", "y"}, varargin{:});
 
         addproperty ("xdata", hg, "data", x(:,i).');
         addproperty ("ydata", hg, "data", y(:,i).');
 
         addlistener (hg, "xdata", @update_data);
diff --git a/scripts/plot/struct2hdl.m b/scripts/plot/struct2hdl.m
new file mode 100644
--- /dev/null
+++ b/scripts/plot/struct2hdl.m
@@ -0,0 +1,615 @@
+## Copyright (C) 2012 pdiribarne
+##
+## This program is free software; you can redistribute it and/or modify
+## it under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or
+## (at your option) any later version.
+##
+## This program is distributed in the hope that it will be useful,
+## but WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+## GNU General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {@var{h} =} struct2hdl (@var{s})
+## @deftypefnx {Function File} {@var{h} =} struct2hdl (@var{s}, @var{p})
+## @deftypefnx {Function File} {@var{h} =} struct2hdl (@var{s}, @var{p}, @var{hilev})
+## Constructs an object from the structure @var{s}. The structure must
+## contain the fields "handle", "type", "children", "properties", and
+## "special".  If the handle of an existing figure or axes is specified,
+## @var{p}, the new object will be created as a child to that object.
+## If no object handle is provided, then a new figure and the necessary
+## children will be constructed using the default object values from
+## the root figure.
+##
+## A third boolean argument @var{hilev} can be passed to specify wether
+## the function should try to preserve listeners/calbacks e.g for
+## legends or hggroups. Default is false.
+## @seealso{findobj, get, hdl2struct, set}
+## @end deftypefn
+
+## Author: pdiribarne <pdiribarne@new-host.home>
+## Created: 2012-03-04
+
+function [ h, matchout ] = struct2hdl (hgS, matchin=[], hilev = false)
+
+  fields = { "handle", "type", "children", "properties", "special"};
+  partypes = {"root", "figure", "axes", "hggroup"};
+  othertypes = {"line", "patch", "surface", "image", "text"};
+  alltypes = [partypes othertypes];
+
+  if (nargin > 3 || ! isstruct (hgS))
+    print_usage ();
+  elseif (! all (isfield (hgS, fields)))
+    print_usage ();
+  elseif (isscalar (matchin))
+    if (! ishandle (matchin))
+      error ("struct2hdl: argument #2 is not a handle to graphic object")
+    endif
+    if (any (strcmp (get (matchin).type, partypes)))
+      paridx = find (strcmp (get (matchin).type, alltypes));
+      kididx = find (strcmp (hgS.type, alltypes));
+      if (kididx <= paridx)
+        error ("struct2hdl: incompatible input handles")
+      endif
+    else
+      error ("struct2hdl: %s object can't be parent object", get (matchin).type)
+    endif
+    hpar = matchin;
+    matchin = [NaN; hpar];
+    ## create appropriate parent if needed
+    if (any (strcmp (hgS.type, othertypes)))
+      for ii = (paridx+1) : (numel (partypes)-1)
+        eval (["hpar = " partypes{ii} "(\"parent\", hpar);"]);
+        matchin = [matchin [NaN; hpar]];
+      endfor
+    elseif (any (strcmp (hgS.type, {"hggroup", "axes"})))
+      for ii = (paridx+1) : (kididx-1)
+        eval (["hpar = " partypes{ii} "(\"parent\", hpar);"]);
+        matchin = [matchin [NaN; hpar]];
+      endfor
+    else
+      par = NaN;
+    endif
+  elseif (isempty (matchin))
+    if (any (strcmp (hgS.type, othertypes)))
+      par = axes ();
+    elseif (any (strcmp (hgS.type, {"hggroup", "axes"})))
+      par = figure ();
+    else
+      par = NaN;
+    endif
+    matchin = [NaN; par];
+  endif
+  ## read parent (last column) in matchin and remove it if duplicate
+  par = matchin (2,end);
+  tst = find (matchin (2,:) == par);
+  if (numel (tst) > 1)
+    matchin = matchin (1:2, 1:(tst(end)-1));
+  endif
+
+  ## create object
+  if (strcmpi (hgS.type, "root"))
+    h = 0;
+    hgS.properties = rmfield (hgS.properties, ...
+                              {"callbackobject", "commandwindowsize", ...
+                               "screendepth", "screenpixelsperinch", ...
+                               "screensize"});
+  elseif (strcmpi (hgS.type, "figure"))
+    h = figure ();
+  elseif (strcmpi (hgS.type, "axes"))
+    ## legends and colorbars are "transformed" in normal axes
+    ## if hilev is not requested
+    if (! hilev)
+      if (strcmp (hgS.properties.tag, "legend"))
+        hgS.properties.tag = "";
+        hgS.properties.userdata = [];
+        par = gcf;
+      elseif (strcmp (hgS.properties.tag, "colorbar"))
+        hgS.properties.tag = "";
+        hgS.properties.userdata = [];
+        par = gcf;
+      endif
+    endif
+
+    [h, hgS] = createaxes (hgS, matchin, par);
+  elseif (strcmpi (hgS.type, "line"))
+    h = createline (hgS, par);
+  elseif (strcmpi (hgS.type, "patch"))
+    [h, hgS] = createpatch (hgS, par);
+  elseif (strcmpi (hgS.type, "text"))
+    h = createtext (hgS, par);
+  elseif (strcmpi (hgS.type, "image"))
+    h = createimage (hgS, par);
+  elseif (strcmpi (hgS.type, "surface"))
+    h = createsurface (hgS, par);
+  elseif (strcmpi (hgS.type, "hggroup"))
+    [h, hgS, matchin] = createhg (hgS, matchin, par, hilev);
+  endif
+
+  ## children
+  matchin = [matchin [hgS.handle; h]]; # [original; new]
+  kids = hgS.children;
+  nkids = length (kids);
+  ii = 0;
+  while nkids
+    ii++;
+    if (! any (ii == hgS.special))
+      [h2, matchin] = struct2hdl (hgS.children(ii),
+                                  [matchin [hgS.handle; h]], hilev);
+    endif
+    nkids--;
+  endwhile
+
+  ## paste properties
+  setprops (hgS, h, matchin, hilev);
+
+  matchout = matchin;
+
+endfunction
+
+function [h, hgSout] = createaxes (hgS, matchin, par);
+  ## regular axes
+  if (strcmpi (hgS.properties.tag, ""))
+    propval = {"position", hgS.properties.position};
+    hid = {"autopos_tag", "looseinset"};
+    for ii = 1:numel (hid)
+      prop = hid{ii};
+      if (isfield (hgS.properties, prop))
+        val = hgS.properties.(prop);
+        propval = [propval, prop, val];
+      endif
+    endfor
+    h = axes (propval{:}, "parent", par);
+
+    if isfield (hgS.properties, "__plotyy_axes__")
+      plty = hgS.properties.__plotyy_axes__;
+      addproperty ("__plotyy_axes__", h, "any")
+      tmp = [matchin [hgS.handle; h]];
+      tst = arrayfun (@(x) any (plty == x), tmp (1:2:end));
+      if sum (tst) == numel (plty)
+        for ii = 1:numel (plty)
+          plty(ii) = tmp (find (tmp == plty(ii)) + 1);
+        endfor
+        for ii = 1:numel (plty)
+          set (plty(ii), "__plotyy_axes__", plty);
+        endfor
+      endif
+      hgS.properties = rmfield (hgS.properties, "__plotyy_axes__");
+    endif
+
+    ## delete non-default and already set properties
+    fields = fieldnames (hgS.properties);
+    tst = cellfun (@(x) isprop (h, x), fields);
+    hgS.properties = rmfield (hgS.properties,  fields(find (tst == 0)));
+
+  elseif (strcmpi (hgS.properties.tag, "legend"))
+    ## legends
+    oldax = hgS.properties.userdata.handle;
+    idx = find (matchin == oldax);
+    newax = matchin(idx+1);
+    strings = {};
+    kids = hgS.children;
+    kids(hgS.special) = [];
+    oldh = unique (arrayfun (@(x) x.properties.userdata(end), kids));
+    for ii = 1:length (oldh)
+      idx = find (matchin(1:2:end) == oldh(ii)) * 2;
+      if (! isempty (idx))
+        newh(ii) = matchin (idx);
+        if (! strcmp (get (newh(ii), "type"), "hggroup"))
+          str = get (newh(ii), "displayname");
+          strings = [strings str];
+        else
+          str = get (get (newh(ii), "children")(1), "displayname");
+          strings = [strings str];
+        endif
+      else
+        error ("struct2hdl: didn't find a legend item")
+      endif
+    endfor
+    location = hgS.properties.location;
+    orientation = hgS.properties.orientation;
+    textpos = hgS.properties.textposition;
+    box = hgS.properties.box;
+
+    h = legend (newax, newh, strings, "location", location, ...
+                "orientation", orientation);
+    set (h, "textposition", textpos); # bug makes "textposition"
+                                # redefine the legend
+    h = legend (newax, newh, strings, "location", location, ...
+                "orientation", orientation);
+    ## box
+    if (strcmp (box, "on"))
+      legend boxon
+    endif
+
+    ## visibility
+    tst = arrayfun (@(x) strcmp (x.properties.visible, "on"), kids);
+    if !any (tst)
+      legend ("hide");
+    endif
+
+    ## remove all properties such as "textposition" that redefines
+    ## the entire legend. Also remove chidren
+    hgS.properties = rmfield (hgS.properties, ...
+                                {"userdata", "xlabel",...
+                                 "ylabel", "zlabel", "location", ...
+                                 "title", "string","orientation", ...
+                                 "visible", "textposition"});
+
+    hgS.children = [];
+
+  elseif (strcmpi (hgS.properties.tag, "colorbar"))
+    ## colorbar
+    oldax = hgS.properties.axes;
+    if (! isempty (idx = find (oldax == matchin)))
+      ax = matchin(idx+1);
+      location = hgS.properties.location;
+      h = colorbar ("peer", ax, location);
+      hgS.properties = rmfield (hgS.properties, ...
+                              {"userdata", "xlabel" ...
+                               "ylabel", "zlabel", ...
+                               "title", "axes"});
+      hgS.children= [];
+    else
+      error ("hdl2struct: didn't find an object")
+    endif
+  endif
+  hgSout = hgS;
+endfunction
+
+function [h] = createline (hgS, par);
+  h = line ("parent", par);
+  addmissingprops (h, hgS.properties);
+endfunction
+
+function [h, hgSout] = createpatch (hgS, par);
+  prp.faces = hgS.properties.faces;
+  prp.vertices = hgS.properties.vertices;
+  prp.facevertexcdata = hgS.properties.facevertexcdata;
+  h = patch (prp);
+  set (h, "parent", par);
+  hgS.properties = rmfield (hgS.properties,
+                            {"faces", "vertices", "facevertexcdata"});
+  addmissingprops (h, hgS.properties);
+  hgSout = hgS;
+endfunction
+
+function [h] = createtext (hgS, par);
+  h = text ("parent", par);
+  addmissingprops (h, hgS.properties)
+endfunction
+
+function [h] = createimage (hgS, par);
+  h = image ("parent", par);
+  addmissingprops (h, hgS.properties)
+endfunction
+
+function [h] = createsurface (hgS, par);
+  h = surface ("parent", par);
+  addmissingprops (h, hgS.properties)
+endfunction
+
+function [h, hgSout, matchout] = createhg (hgS, matchin, par, hilev)
+  ## Here we infer from properties the type of hggroup we should build
+  ## an call corresponding high level functions
+  ## We manually set "hold on" to avoid next hggroup be deleted
+  ## the proper value of axes "nextplot" will finally be recovered
+
+  hold on;
+  if (hilev)
+    [h, hgS, matchin] = createhg_hilev (hgS, matchin, par);
+    if (numel (hgS.children) != numel (get (h).children))
+      warning (["struct2hdl: couldn't infer the hggroup type. ", ...
+                "Will build objects but listener/callback functions ", ...
+                "will be lost"]);
+      if isfield (h, "bargroup")
+        delete (get (h).bargroup);
+      else
+        delete (h);
+      endif
+      h = hggroup ("parent", par);
+      addmissingprops (h, hgS.properties);
+      hgS.special = [];
+    else
+      oldkids = hgS.children;
+      newkids = get (h).children;
+      nkids = numel (oldkids);
+      ii = 1;
+      while nkids
+        matchin = [matchin [oldkids(ii++).handle; newkids(nkids--)]];
+      endwhile
+    endif
+  else
+    h = hggroup ("parent", par);
+    addmissingprops (h, hgS.properties);
+    hgS.special = [];
+  endif
+  hgSout = hgS;
+  matchout = matchin;
+endfunction
+
+function [h, hgSout, matchout] = createhg_hilev (hgS, matchin, par)
+  fields = hgS.properties;
+  if (isfield (fields, "contourmatrix"))
+    ## contours
+    xdata = hgS.properties.xdata;
+    ydata = hgS.properties.ydata;
+    zdata = hgS.properties.zdata;
+    levellist = hgS.properties.levellist;
+    textlist = hgS.properties.textlist;
+
+    ## contour creation
+    if (isempty (hgS.children(1).properties.zdata))
+      if (strcmpi (hgS.properties.fill, "on"))
+        [cm2, h] = contourf (xdata, ydata, zdata, levellist);
+      else
+        [cm2, h] = contour (xdata, ydata, zdata, levellist);
+      endif
+
+      ## labels
+      if (strcmpi (hgS.properties.showtext, "on"))
+        clabel (cm2, h, textlist);
+      endif
+    else
+      [cm2, h] = contour3 (xdata, ydata, zdata, levellist);
+    endif
+
+    ## delete already set properties and children
+    hgS.properties = rmfield (hgS.properties, ...
+                              {"xdata", "ydata", "zdata", ...
+                               "contourmatrix", "levellist", ...
+                               "fill", "labelspacing", ...
+                               "levellistmode", "levelstep", ...
+                               "levelstepmode", "textlist"...
+                               "textlistmode" , "textstep", ...
+                               "textstepmode", "zlevel", ...
+                               "zlevelmode"});
+
+  elseif (isfield (fields, "udata") && isfield (fields, "vdata"))
+    ## quiver
+    xdata = hgS.properties.xdata;
+    ydata = hgS.properties.ydata;
+
+    udata = hgS.properties.udata;
+    vdata = hgS.properties.vdata;
+
+    h = quiver (xdata, ydata, udata, vdata);
+
+    ## delete already set properties and children
+    hgS.properties = rmfield (hgS.properties, ...
+                              {"xdata", "ydata", "zdata", ...
+                               "xdatasource", "ydatasource", "zdatasource", ...
+                               "udata", "vdata", "wdata", ...
+                               "udatasource", "vdatasource", "wdatasource"});
+
+  elseif (isfield (fields, "format"))
+    ##errorbar
+    form = hgS.properties.format;
+    xdata = hgS.properties.xdata;
+    ydata = hgS.properties.ydata;
+    xldata = hgS.properties.xldata;
+    ldata = hgS.properties.ldata;
+    xudata = hgS.properties.xudata;
+    udata = hgS.properties.udata;
+
+    switch form
+      case "xerr"
+        h = errorbar (xdata, ydata, xldata, xudata, ">");
+      case "yerr"
+        h = errorbar (xdata, ydata, ldata, udata, "~");
+      case "xyerr"
+        h = errorbar (xdata, ydata, xldata, xudata, ldata, udata, "~>");
+      case "box"
+        h = errorbar (xdata, ydata, xldata, xudata, "#");
+      case "boxy"
+        h = errorbar (xdata, ydata, ldata, udata, "#~");
+      case "boxxy"
+        h = errorbar (xdata, ydata, xldata, xudata, ldata, udata, "#~>");
+      otherwise
+        error ("struct2hdl: couldn't guess the errorbar format")
+    endswitch
+    ## delete already set properties
+    hgS.properties = rmfield (hgS.properties, ...
+                              {"xdata", "ydata", ...
+                               "xldata", "ldata", ...
+                               "xudata", "udata", ...
+                               "xldatasource", "ldatasource", ...
+                               "xudatasource", "udatasource", ...
+                               "format"});
+
+  elseif (isfield (fields, "bargroup"))
+    ## bar plot
+    ## FIXME - here we don't have access to brothers so we first create all
+    ## the barseries of the bargroup (but the last), then retrieve information,
+    ## and rebuild the whole bargroup.
+    ## The duplicate are deleted after calling "setprops"
+
+    bargroup = hgS.properties.bargroup;
+    oldh = hgS.handle;
+
+    temp = arrayfun (@(x) any(x == bargroup), [matchin(1:2:end) oldh]);
+    tst = sum (temp) == length (bargroup);
+
+    if (isscalar (bargroup) || !tst)
+      xdata = hgS.properties.xdata;
+      ydata = hgS.properties.ydata;
+
+      h = bar (xdata, ydata);
+
+      ## delete already set properties,
+      hgS.properties = rmfield (hgS.properties, ...
+                                {"xdata", "ydata", ...
+                                 "xdatasource", "ydatasource", ...
+                                 "bargroup", ...
+                                 "barwidth", "baseline"});
+    else
+      xdata = [];
+      ydata = [];
+
+      ##build x/y matrix
+      nbar = length (bargroup);
+      tmp = struct ("handle", NaN,"type", "", "children", [], "special", []);
+      for ii = 1:(nbar - 1)
+        idx = find (matchin(1:2:end) == bargroup(ii)) * 2;
+        hdl = matchin (idx);
+        xdata = [xdata get(hdl).xdata];
+        ydata = [ydata get(hdl).ydata];
+        tmp.children(ii) = hdl2struct (hdl);
+      endfor
+
+      xdata = [xdata hgS.properties.xdata];
+      ydata = [ydata hgS.properties.ydata];
+      width = hgS.properties.barwidth;
+      h = bar (ydata, width);
+
+      ## replace previous handles in "match", copy props and delete redundant
+      for ii = 1:(nbar - 1)
+        props = tmp.children(ii).properties;
+        bl = props.baseline;
+        tmp.children(ii).properties = rmfield (props, {"baseline", "bargroup"});
+        setprops (tmp.children(ii), h(ii), matchin, 1);
+        delete (tmp.children(ii).handle);
+        delete (bl);
+        idxpar = find (matchin == tmp.children(ii).handle);
+        matchin (idxpar) = h(ii);
+        idxkid = idxpar - 2;
+        matchin (idxkid) = get (h(ii), "children");
+      endfor
+      matchin (2,((end-nbar+2):end)) = h (1:(end-1));
+      h = h (end);
+
+      ## delete already set properties ,
+      hgS.properties = rmfield (hgS.properties, ...
+                                {"xdata", "ydata", "bargroup"...
+                                 "barwidth", "baseline"});
+    endif
+  elseif (isfield (fields, "baseline"))
+    ## stem plot
+    xdata = hgS.properties.xdata;
+    ydata = hgS.properties.ydata;
+
+    h = stem (xdata, ydata);
+
+    ## delete already set properties,
+    hgS.properties = rmfield (hgS.properties, ...
+                              {"xdata", "ydata", ...
+                               "xdatasource", "ydatasource", ...
+                               "baseline"});
+  elseif (isfield (fields, "basevalue"))
+    ## area plot
+    xdata = hgS.properties.xdata;
+    ydata = hgS.properties.ydata;
+    level = hgS.properties.basevalue;
+
+    h = area (xdata, ydata, level);
+
+    ## delete already set properties,
+    hgS.properties = rmfield (hgS.properties, ...
+                              {"xdata", "ydata", ...
+                               "xdatasource", "ydatasource"});
+  else
+    warning ("struct2hdl: couldn't infer the hggroup type. Will build objects but listener/callback functions will be lost");
+    h = hggroup ("parent", par);
+    addmissingprops (h, hgS.properties);
+    hgS.special = [];           # children will be treated as normal children
+  endif
+  hgSout = hgS;
+  matchout = matchin;
+endfunction
+
+function setprops (hgS, h, matchin, hilev)
+  more off
+  if (strcmpi (hgS.properties.tag, ""))
+    specs = hgS.children(hgS.special);
+    hdls = arrayfun (@(x) x.handle, specs);
+    nh = length(hdls);
+    msg = "";
+    if (! nh)
+      set (h, hgS.properties);
+    else
+      ## Specials are objects that where automatically constructed with
+      ## current object. Among them are "x(yz)labels", "title", high
+      ## level hggroup children
+      fields = fieldnames (hgS.properties);
+      vals = struct2cell (hgS.properties);
+      idx = find (cellfun (@(x) valcomp(x, hdls) , vals));
+      hgS.properties = rmfield (hgS.properties, fields(idx));
+
+      ## set all properties but special handles
+      set (h, hgS.properties);
+
+      ## find  props with val == (one of special handles)
+      nf = length (idx);
+      fields = fields(idx);
+      vals = vals(idx);
+      while nf
+        field = fields{nf};
+        idx = find (hdls == vals{nf});
+        spec = specs(idx);
+        if (isprop (h, field))
+           h2 = get (h , field);
+           set (h2, spec.properties);
+        endif
+        nf--;
+      endwhile
+
+      ## If hggroup children  were created by high level functions,
+      ## copy only usefull properties.
+      if (hilev)
+        if (strcmpi (hgS.type, "hggroup"))
+          nold = numel (hgS.children);
+          nnew = numel (get(h).children);
+
+          if (nold == nnew)
+            hnew = get(h).children;
+            ii = 1;
+            while ii <= nnew
+              try
+                set (hnew (ii), "displayname", ...
+                     hgS.children(ii).properties.displayname);
+              catch
+                sprintf ("struct2hdl: couldn't set hggroup children #%d props.", ii)
+              end_try_catch
+              ii ++;
+            endwhile
+
+          else
+            error ("struct2hdl: non-conformant number of children in hgggroup")
+          endif
+        endif
+      endif
+    endif
+
+  elseif (strcmpi (hgS.properties.tag, "legend")
+          || strcmpi (hgS.properties.tag, "colorbar"))
+    set (h, hgS.properties);
+  endif
+
+endfunction
+
+function out = valcomp (x, hdls)
+  if (isfloat(x) && isscalar(x))
+    out = any (x == hdls);
+  else
+    out = 0;
+  endif
+endfunction
+
+function addmissingprops (h, props)
+  hid = {"autopos_tag", "looseinset"};
+  oldfields = fieldnames (props);
+  curfields = fieldnames (get (h));
+  missing = cellfun (@(x) !any (strcmp (x, curfields)), oldfields);
+  idx = find (missing);
+  for ii = 1:length(idx)
+    prop = oldfields{idx(ii)};
+    if (! any (strcmp (prop, hid)))
+      addproperty (prop, h, "any");
+    endif
+  endfor
+endfunction
diff --git a/scripts/plot/subplot.m b/scripts/plot/subplot.m
--- a/scripts/plot/subplot.m
+++ b/scripts/plot/subplot.m
@@ -308,17 +308,17 @@ function pos = subplot_position (rows, c
   yi = fix ((index(:)-1)/cols);
   xi = index(:) - yi*cols - 1;
   yi = (rows - 1) - yi;
 
   ## Lower left corner of the subplot, i.e. position(1:2)
   x0 = xi .* (width + margins.column) + margins.left;
   y0 = yi .* (height + margins.row) + margins.bottom;
 
-  if (numel(x0) > 1)
+  if (numel (x0) > 1)
     ## subplot (row, col, m:n)
     x1 = max (x0(:)) + width;
     y1 = max (y0(:)) + height;
     x0 = min (x0(:));
     y0 = min (y0(:));
     pos = [x0, y0, x1-x0, y1-y0];
   else
     ## subplot (row, col, num)
@@ -333,24 +333,24 @@ endfunction
 %! r = 3;
 %! c = 3;
 %! fmt = {'horizontalalignment', 'center', 'verticalalignment', 'middle'};
 %! for n = 1 : r*c
 %!   subplot (r, c, n);
 %!   xlabel (sprintf ('xlabel #%d', n));
 %!   ylabel (sprintf ('ylabel #%d', n));
 %!   title (sprintf ('title #%d', n));
-%!   text (0.5, 0.5, sprintf('subplot(%d,%d,%d)', r, c, n), fmt{:});
+%!   text (0.5, 0.5, sprintf ('subplot(%d,%d,%d)', r, c, n), fmt{:});
 %!   axis ([0 1 0 1]);
 %! end
 %! subplot (r, c, 1:3);
 %! xlabel (sprintf ('xlabel #%d:%d', 1, 3));
 %! ylabel (sprintf ('ylabel #%d:%d', 1, 3));
 %! title (sprintf ('title #%d:%d', 1, 3));
-%! text (0.5, 0.5, sprintf('subplot(%d,%d,%d:%d)', r, c, 1, 3), fmt{:});
+%! text (0.5, 0.5, sprintf ('subplot(%d,%d,%d:%d)', r, c, 1, 3), fmt{:});
 %! axis ([0 1 0 1]);
 
 %!demo
 %! clf;
 %! x = 0:1;
 %! for n = 1:4
 %!   subplot (2,2,n, 'align');
 %!   plot (x, x);
diff --git a/scripts/plot/surface.m b/scripts/plot/surface.m
--- a/scripts/plot/surface.m
+++ b/scripts/plot/surface.m
@@ -140,17 +140,17 @@ function [h, bad_usage] = __surface__ (a
       x = 1:nc;
       y = (1:nr)';
     else
       error ("surface: Z argument must be a matrix");
     endif
   elseif (firststring == 1)
     x = 1:3;
     y = (x).';
-    c = z = eye(3);
+    c = z = eye (3);
   else
     bad_usage = true;
   endif
 
   if (! bad_usage)
     ## Make a default surface object.
     other_args = {};
     if (firststring < nargin)
@@ -170,18 +170,18 @@ endfunction
 ## Functional tests for surface() are in surf.m, surfc.m, surfl.m, and pcolor.m
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   h = surface;
 %!   assert (findobj (hf, "type", "surface"), h);
 %!   assert (get (h, "xdata"), 1:3, eps);
 %!   assert (get (h, "ydata"), (1:3)', eps);
-%!   assert (get (h, "zdata"), eye(3));
-%!   assert (get (h, "cdata"), eye(3));
+%!   assert (get (h, "zdata"), eye (3));
+%!   assert (get (h, "cdata"), eye (3));
 %!   assert (get (h, "type"), "surface");
 %!   assert (get (h, "linestyle"), get (0, "defaultsurfacelinestyle"));
 %!   assert (get (h, "linewidth"), get (0, "defaultsurfacelinewidth"), eps);
 %!   assert (get (h, "marker"), get (0, "defaultsurfacemarker"));
 %!   assert (get (h, "markersize"), get (0, "defaultsurfacemarkersize"));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
diff --git a/scripts/plot/surfl.m b/scripts/plot/surfl.m
--- a/scripts/plot/surfl.m
+++ b/scripts/plot/surfl.m
@@ -146,17 +146,17 @@ function retval = surfl (varargin)
     vn = get (htmp, "vertexnormals");
     dar = get (h, "plotboxaspectratio");
     vn(:,:,1) *= dar(1);
     vn(:,:,2) *= dar(2);
     vn(:,:,3) *= dar(3);
 
     ## Normalize vn.
     vn = vn ./ repmat (sqrt (sumsq (vn, 3)), [1, 1, 3]);
-    [nr, nc] = size(get(htmp, "zdata"));
+    [nr, nc] = size (get (htmp, "zdata"));
 
     ## Ambient, diffuse, and specular term.
     cdata = (r(1) * ones (nr, nc)
              + r(2) * diffuse  (vn(:,:,1), vn(:,:,2), vn(:,:,3), lv)
              + r(3) * specular (vn(:,:,1), vn(:,:,2), vn(:,:,3), lv, vv, r(4)));
 
     set (htmp, "cdata", cdata ./ sum (r(1:3)));
 
diff --git a/scripts/plot/surfnorm.m b/scripts/plot/surfnorm.m
--- a/scripts/plot/surfnorm.m
+++ b/scripts/plot/surfnorm.m
@@ -22,18 +22,18 @@
 ## @deftypefnx {Function File} {[@var{nx}, @var{ny}, @var{nz}] =} surfnorm (@dots{})
 ## @deftypefnx {Function File} {} surfnorm (@var{h}, @dots{})
 ## Find the vectors normal to a meshgridded surface.  The meshed gridded
 ## surface is defined by @var{x}, @var{y}, and @var{z}.  If @var{x} and
 ## @var{y} are not defined, then it is assumed that they are given by
 ##
 ## @example
 ## @group
-## [@var{x}, @var{y}] = meshgrid (1:size (@var{z}, 1),
-##                    1:size (@var{z}, 2));
+## [@var{x}, @var{y}] = meshgrid (1:rows (@var{z}),
+##                    1:columns (@var{z}));
 ## @end group
 ## @end example
 ##
 ## If no return arguments are requested, a surface plot with the normal
 ## vectors to the surface is plotted.  Otherwise the components of the normal
 ## vectors at the mesh gridded points are returned in @var{nx}, @var{ny},
 ## and @var{nz}.
 ##
@@ -57,17 +57,17 @@ function [Nx, Ny, Nz] = surfnorm (vararg
                                                 varargin{:});
 
   if (nargin != 1 && nargin != 3)
     print_usage ();
   endif
 
   if (nargin == 1)
     z = varargin{1};
-    [x, y] = meshgrid (1:size(z,1), 1:size(z,2));
+    [x, y] = meshgrid (1:rows (z), 1:columns (z));
     ioff = 2;
   else
     x = varargin{1};
     y = varargin{2};
     z = varargin{3};
     ioff = 4;
   endif
 
@@ -91,19 +91,19 @@ function [Nx, Ny, Nz] = surfnorm (vararg
   u.x = xx(1:end-1,1:end-1) - xx(2:end,2:end);
   u.y = yy(1:end-1,1:end-1) - yy(2:end,2:end);
   u.z = zz(1:end-1,1:end-1) - zz(2:end,2:end);
   v.x = xx(1:end-1,2:end) - xx(2:end,1:end-1);
   v.y = yy(1:end-1,2:end) - yy(2:end,1:end-1);
   v.z = zz(1:end-1,2:end) - zz(2:end,1:end-1);
 
   c = cross ([u.x(:), u.y(:), u.z(:)], [v.x(:), v.y(:), v.z(:)]);
-  w.x = reshape (c(:,1), size(u.x));
-  w.y = reshape (c(:,2), size(u.y));
-  w.z = reshape (c(:,3), size(u.z));
+  w.x = reshape (c(:,1), size (u.x));
+  w.y = reshape (c(:,2), size (u.y));
+  w.z = reshape (c(:,3), size (u.z));
 
   ## Create normal vectors as mesh vectices from normals at mesh centers
   nx = (w.x(1:end-1,1:end-1) + w.x(1:end-1,2:end) +
         w.x(2:end,1:end-1) + w.x(2:end,2:end)) ./ 4;
   ny = (w.y(1:end-1,1:end-1) + w.y(1:end-1,2:end) +
         w.y(2:end,1:end-1) + w.y(2:end,2:end)) ./ 4;
   nz = (w.z(1:end-1,1:end-1) + w.z(1:end-1,2:end) +
         w.z(2:end,1:end-1) + w.z(2:end,2:end)) ./ 4;
diff --git a/scripts/plot/tetramesh.m b/scripts/plot/tetramesh.m
--- a/scripts/plot/tetramesh.m
+++ b/scripts/plot/tetramesh.m
@@ -65,17 +65,17 @@ function h = tetramesh (varargin)
   if (! ismatrix (X) || columns (X) != 3)
     error ("tetramesh: X must be a n-by-3 matrix");
   endif
 
   size_T = rows (T);
   colmap = colormap ();
   
   if (length (reg) < 3)
-    size_colmap = size (colmap, 1);
+    size_colmap = rows (colmap);
     C = mod ((1:size_T)' - 1, size_colmap) + 1;
     if (size_T < size_colmap && size_T > 1) 
       ## expand to the available range of colors
       C = floor ((C - 1) * (size_colmap - 1) / (size_T - 1)) + 1;
     endif
   else
     C = reg{3};
     if (! isvector (C) || size_T != length (C))
diff --git a/scripts/plot/text.m b/scripts/plot/text.m
--- a/scripts/plot/text.m
+++ b/scripts/plot/text.m
@@ -52,17 +52,17 @@ function h = text (varargin)
 
     label = varargin{offset};
     varargin(1:offset) = [];
 
     nx = numel (x);
     ny = numel (y);
     nz = numel (z);
     if (ischar (label) || isnumeric (label))
-      nt = size (label, 1);
+      nt = rows (label);
       if (nx > 1 && nt == 1)
         ## Mutiple text objects with same string
         label = repmat ({label}, [nx, 1]);
         nt = nx;
       elseif (nx > 1 && nt == nx)
         ## Mutiple text objects with different strings
         label = cellstr (label);
       elseif (ischar (label))
@@ -129,18 +129,18 @@ endfunction
 
 %!demo
 %! clf;
 %! ha = {'left', 'center', 'right'};
 %! va = {'bottom', 'middle', 'top'};
 %! x = [0.25 0.5 0.75];
 %! y = x;
 %! for t = 0:30:359;
-%!   for nh = 1:numel(ha)
-%!     for nv = 1:numel(va)
+%!   for nh = 1:numel (ha)
+%!     for nv = 1:numel (va)
 %!       text (x(nh), y(nv), 'Hello World', ...
 %!             'rotation', t, ...
 %!             'horizontalalignment', ha{nh}, ...
 %!             'verticalalignment', va{nv});
 %!     end
 %!   end
 %! end
 %! set (gca, 'xtick', [0.25, 0.5, 0.75], ...
diff --git a/scripts/plot/uigetfile.m b/scripts/plot/uigetfile.m
--- a/scripts/plot/uigetfile.m
+++ b/scripts/plot/uigetfile.m
@@ -76,17 +76,17 @@ function [retfile, retpath, retindex] = 
                defaulttoolkit);
     endif
   endif
 
   if (nargin > 7)
     error ("uigetfile: number of input arguments must be less than eight");
   endif
 
-  defaultvals = {cell(0, 2),         # File Filter
+  defaultvals = {cell (0, 2),        # File Filter
                  "Open File",        # Dialog Title
                  "",                 # Default file name
                  [240, 120],         # Dialog Position (pixel x/y)
                  "off",              # MultiSelect on/off
                  pwd};               # Default directory
 
   outargs = cell (6, 1);
   for i = 1 : 6
@@ -160,17 +160,17 @@ function [retfile, retpath, retindex] = 
     if (rem (nargin - stridx + 1, 2))
       error ("uigetfile: expecting property/value pairs");
     endif
 
     for i = stridx : 2 : nargin
       prop = varargin{i};
       val = varargin{i + 1};
       if (strncmp (tolower (prop), "position", 8))
-        if (ismatrix (val) && length(val) == 2)
+        if (ismatrix (val) && length (val) == 2)
           outargs{4} = val;
         else
           error ("uigetfile: expecting 2-element vector for position argument");
         endif
       elseif (strncmp (tolower (prop), "multiselect", 11))
         if (ischar (val))
           outargs{5} = tolower (val);
         else
diff --git a/scripts/plot/uiputfile.m b/scripts/plot/uiputfile.m
--- a/scripts/plot/uiputfile.m
+++ b/scripts/plot/uiputfile.m
@@ -25,31 +25,31 @@
 ## filter string(s) in one of the following formats:
 ##
 ## @table @code
 ## @item "/path/to/filename.ext"
 ## If a filename is given the file extension is
 ## extracted and used as filter.
 ## In addition the path is selected as current path and the filename is selected
 ## as default file.
-## Example: uiputfile("myfun.m");
+## Example: uiputfile ("myfun.m");
 ##
 ## @item "*.ext"
 ## A single file extension.
-## Example: uiputfile("*.ext");
+## Example: uiputfile ("*.ext");
 ##
 ## @item @{"*.ext","My Description"@}
 ## A 2-column cell array containing the file extension in the 1st column and
 ## a brief description in the 2nd column.
-## Example: uiputfile(@{"*.ext","My Description";"*.xyz","XYZ-Format"@});
+## Example: uiputfile (@{"*.ext","My Description";"*.xyz","XYZ-Format"@});
 ## @end table
 ##
 ## The filter string can also contain a semicolon separated list of filter
 ## extensions.
-## Example: uiputfile(@{"*.gif;*.png;*.jpg", "Supported Picture Formats"@});
+## Example: uiputfile (@{"*.gif;*.png;*.jpg", "Supported Picture Formats"@});
 ##
 ## @var{dialog_name} can be used to customize the dialog title.
 ## If @var{default_file} is given it is preselected in the GUI dialog.
 ## If, in addition, a path is given it is also used as current path.
 ## @end deftypefn
 
 ## Author: Kai Habel
 
@@ -67,24 +67,24 @@ function [retfile, retpath, retindex] = 
                defaulttoolkit);
     endif
   endif
 
   if (nargin > 3)
     print_usage ();
   endif
 
-  defaultvals = {cell(0, 2),     # File Filter
+  defaultvals = {cell (0, 2),    # File Filter
                  "Save File",    # Dialog Title
                  "",             # Default file name
                  [240, 120],     # Dialog Position (pixel x/y)
                  "create",
                  pwd};           # Default directory
 
-  outargs = cell(6, 1);
+  outargs = cell (6, 1);
   for i = 1 : 6
     outargs{i} = defaultvals{i};
   endfor
 
   if (nargin > 0)
     file_filter = varargin{1};
     [outargs{1}, outargs{3}, defdir] = __file_filter__ (file_filter);
     if (length (defdir) > 0)
diff --git a/scripts/plot/whitebg.m b/scripts/plot/whitebg.m
--- a/scripts/plot/whitebg.m
+++ b/scripts/plot/whitebg.m
@@ -69,17 +69,17 @@ function whitebg (varargin)
 
   axes = findall (fig, "type", "axes");
   if (isnan (color))
     ## Root figure. Set the default axes and figure properties so that
     ## subsequent plots have the new color scheme
     if (isroot)
       fac = get (0, "factory");
       fields = fieldnames (fac);
-      fieldindex = intersect (find (!cellfun ("isempty", regexp(fields, 'color'))), union (find (!cellfun ("isempty", regexp(fields, 'factoryaxes.*'))), find (!cellfun ("isempty", regexp(fields, 'factoryfigure.*')))));
+      fieldindex = intersect (find (!cellfun ("isempty", regexp (fields, 'color'))), union (find (!cellfun ("isempty", regexp (fields, 'factoryaxes.*'))), find (!cellfun ("isempty", regexp (fields, 'factoryfigure.*')))));
 
       ## Check whether the factory value has been replaced
       for nf = 1 : numel (fieldindex);
         defaultfield = strrep (fields {fieldindex (nf)}, "factory", "default");
         try
           defaultvalue = 1 - get (0, defaultfield {n});
         catch
           field = fields {fieldindex (nf)};
@@ -90,43 +90,43 @@ function whitebg (varargin)
     endif
 
     ## Load all objects which qualify for being searched.
     handles = fig;
     h = fig;
     while (numel (handles))
       children = [];
       for n = 1 : numel (handles)
-        children = union (children, get(handles(n), "children"));
+        children = union (children, get (handles(n), "children"));
       endfor
       handles = children;
       h = union (h, children);
     endwhile
 
-    for nh = 1 : numel(h)
+    for nh = 1 : numel (h)
       p = get (h (nh));
       fields = fieldnames (p);
-      fieldindex = find (!cellfun ("isempty", regexp(fields, 'color')));
+      fieldindex = find (!cellfun ("isempty", regexp (fields, 'color')));
       if (numel (fieldindex))
         for nf = 1 : numel (fieldindex);
           field = fields {fieldindex (nf)};
           c = subsref (p, struct ("type", ".", "subs", field));
-          if (! ischar(c) && columns(c) == 3)
+          if (! ischar (c) && columns (c) == 3)
             set (h (nh), field, 1 - c);
           endif
         endfor
       endif
 
       ## If h(nh) is a figure or axes invert default color properties
       typ = subsref (p, struct ("type", ".", "subs", "type"));
       if (strcmp (typ, "axes") || strcmp (typ, "figure"))
         def = get (h (nh), "default");
         fields = fieldnames (def);
         if (! isempty (fields))
-          fieldindex = find (!cellfun ("isempty", regexp(fields, 'color')));
+          fieldindex = find (!cellfun ("isempty", regexp (fields, 'color')));
           for nf = 1 : numel (fieldindex)
             defaultfield = fields {fieldindex (nf)};
             defaultvalue = 1 - subsref (def, struct ("type", ".", "subs", defaultfield));
             set (h (nh), defaultfield, defaultvalue);
           endfor
         endif
       endif
     endfor
diff --git a/scripts/polynomial/deconv.m b/scripts/polynomial/deconv.m
--- a/scripts/polynomial/deconv.m
+++ b/scripts/polynomial/deconv.m
@@ -35,17 +35,17 @@
 
 function [b, r] = deconv (y, a)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   if (! (isvector (y) && isvector (a)))
-    error("deconv: both arguments must be vectors");
+    error ("deconv: both arguments must be vectors");
   endif
 
   la = length (a);
   ly = length (y);
 
   lb = ly - la + 1;
 
   ## Ensure A is oriented as Y.
@@ -63,17 +63,17 @@ function [b, r] = deconv (y, a)
     b = 0;
   endif
 
   lc = la + length (b) - 1;
   if (ly == lc)
     r = y - conv (a, b);
   else
     ## Respect the orientation of Y"
-    if (size (y, 1) <= size (y, 2))
+    if (rows (y) <= columns (y))
       r = [(zeros (1, lc - ly)), y] - conv (a, b);
     else
       r = [(zeros (lc - ly, 1)); y] - conv (a, b);
     endif
     if (ly < la)
       ## Trim the remainder is equal to the length of Y.
       r = r(end-(length(y)-1):end);
     endif
diff --git a/scripts/polynomial/mkpp.m b/scripts/polynomial/mkpp.m
--- a/scripts/polynomial/mkpp.m
+++ b/scripts/polynomial/mkpp.m
@@ -91,24 +91,24 @@ endfunction
 %! legend ("control", "interp");
 
 %!shared b,c,pp
 %! b = 1:3; c = 1:24; pp = mkpp (b,c);
 %!assert (pp.pieces, 2)
 %!assert (pp.order, 12)
 %!assert (pp.dim, 1)
 %!assert (size (pp.coefs), [2,12])
-%! pp = mkpp(b,c,2);
+%! pp = mkpp (b,c,2);
 %!assert (pp.pieces, 2)
 %!assert (pp.order, 6)
 %!assert (pp.dim, 2)
 %!assert (size (pp.coefs), [4,6])
-%! pp = mkpp(b,c,3);
+%! pp = mkpp (b,c,3);
 %!assert (pp.pieces, 2)
 %!assert (pp.order, 4)
 %!assert (pp.dim, 3)
 %!assert (size (pp.coefs), [6,4])
-%! pp = mkpp(b,c,[2,3]);
+%! pp = mkpp (b,c,[2,3]);
 %!assert (pp.pieces, 2)
 %!assert (pp.order, 2)
 %!assert (pp.dim, [2,3])
 %!assert (size (pp.coefs), [12,2])
 
diff --git a/scripts/polynomial/pchip.m b/scripts/polynomial/pchip.m
--- a/scripts/polynomial/pchip.m
+++ b/scripts/polynomial/pchip.m
@@ -139,18 +139,18 @@ endfunction
 
 %!shared x, y, y2, pp, yi1, yi2, yi3
 %! x = 0:8;
 %! y = [1, 1, 1, 1, 0.5, 0, 0, 0, 0];
 %!assert (pchip (x,y,x), y)
 %!assert (pchip (x,y,x'), y')
 %!assert (pchip (x',y',x'), y')
 %!assert (pchip (x',y',x), y)
-%!assert (isempty (pchip(x',y',[])))
-%!assert (isempty (pchip(x,y,[])))
+%!assert (isempty (pchip (x',y',[])))
+%!assert (isempty (pchip (x,y,[])))
 %!assert (pchip (x,[y;y],x), [pchip(x,y,x);pchip(x,y,x)])
 %!assert (pchip (x,[y;y],x'), [pchip(x,y,x);pchip(x,y,x)])
 %!assert (pchip (x',[y;y],x), [pchip(x,y,x);pchip(x,y,x)])
 %!assert (pchip (x',[y;y],x'), [pchip(x,y,x);pchip(x,y,x)])
 %!test
 %! x = (0:8)*pi/4; y = [sin(x); cos(x)];
 %! y2(:,:,1) = y; y2(:,:,2) = y+1; y2(:,:,3) = y-1;
 %! pp = pchip (x, shiftdim (y2,2));
diff --git a/scripts/polynomial/polyaffine.m b/scripts/polynomial/polyaffine.m
--- a/scripts/polynomial/polyaffine.m
+++ b/scripts/polynomial/polyaffine.m
@@ -68,17 +68,17 @@ function g = polyaffine (f, mu)
 
 endfunction
 
 
 %!demo
 %! f = [1/5 4/5 -7/5 -2];
 %! g = polyaffine (f, [1, 1.2]);
 %! x = linspace (-4,4,100);
-%! plot (x,polyval(f, x), x,polyval(g, x));
+%! plot (x,polyval (f, x), x,polyval (g, x));
 %! legend ("original", "affine");
 %! axis ([-4 4 -3 5]);
 %! grid on;
 
 %!test
 %! f = [1/5 4/5 -7/5 -2];
 %! mu = [1, 1.2];
 %! g = polyaffine (f, mu);
diff --git a/scripts/polynomial/polyder.m b/scripts/polynomial/polyder.m
--- a/scripts/polynomial/polyder.m
+++ b/scripts/polynomial/polyder.m
@@ -55,17 +55,17 @@ function [q, d] = polyder (p, a)
           q = a * polyder (p);
         else
           q = conv (polyder (p), a) - conv (p, polyder (a));
           q = polyreduce (q);
         endif
 
         ## remove common factors from numerator and denominator
         x = polygcd (q, d);
-        if (length(x) != 1)
+        if (length (x) != 1)
           q = deconv (q, x);
           d = deconv (d, x);
         endif
 
         ## move all the gain into the numerator
         q = q/d(1);
         d = d/d(1);
       endif
diff --git a/scripts/polynomial/polygcd.m b/scripts/polynomial/polygcd.m
--- a/scripts/polynomial/polygcd.m
+++ b/scripts/polynomial/polygcd.m
@@ -18,28 +18,28 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{q} =} polygcd (@var{b}, @var{a})
 ## @deftypefnx {Function File} {@var{q} =} polygcd (@var{b}, @var{a}, @var{tol})
 ##
 ## Find the greatest common divisor of two polynomials.  This is equivalent
 ## to the polynomial found by multiplying together all the common roots.
 ## Together with deconv, you can reduce a ratio of two polynomials.
-## The tolerance @var{tol} defaults to @code{sqrt(eps)}.
+## The tolerance @var{tol} defaults to @code{sqrt (eps)}.
 ##
 ## @strong{Caution:} This is a numerically unstable algorithm and should not
 ## be used on large polynomials.
 ##
 ## Example code:
 ##
 ## @example
 ## @group
 ## polygcd (poly (1:8), poly (3:12)) - poly (3:8)
 ## @result{} [ 0, 0, 0, 0, 0, 0, 0 ]
-## deconv (poly (1:8), polygcd (poly (1:8), poly (3:12))) - poly(1:2)
+## deconv (poly (1:8), polygcd (poly (1:8), poly (3:12))) - poly (1:2)
 ## @result{} [ 0, 0, 0 ]
 ## @end group
 ## @end example
 ## @seealso{poly, roots, conv, deconv, residue}
 ## @end deftypefn
 
 function x = polygcd (b, a, tol)
 
diff --git a/scripts/polynomial/polyout.m b/scripts/polynomial/polyout.m
--- a/scripts/polynomial/polyout.m
+++ b/scripts/polynomial/polyout.m
@@ -71,17 +71,17 @@ function y = polyout (c, x)
 
       tmp = sprintf ("%s*%s^%d%s%s", tmp, x, n1-ii, ns, coeff (c(ii)));
 
     endfor
   else
     tmp = " ";
   endif
 
-  if(nargout == 0)
+  if (nargout == 0)
     disp (tmp);
   else
     y = tmp;
   endif
 
 endfunction
 
 function str = coeff (c)
diff --git a/scripts/polynomial/polyval.m b/scripts/polynomial/polyval.m
--- a/scripts/polynomial/polyval.m
+++ b/scripts/polynomial/polyval.m
@@ -119,19 +119,19 @@ endfunction
 %! assert (yn, y, sqrt (eps));
 
 %!test
 %! p = [0, 1, 0];
 %! x = 1:10;
 %! assert (x, polyval (p,x), eps);
 %! x = x(:);
 %! assert (x, polyval (p,x), eps);
-%! x = reshape(x, [2, 5]);
+%! x = reshape (x, [2, 5]);
 %! assert (x, polyval (p,x), eps);
-%! x = reshape(x, [5, 2]);
+%! x = reshape (x, [5, 2]);
 %! assert (x, polyval (p,x), eps);
 %! x = reshape (x, [1, 1, 5, 2]);
 %! assert (x, polyval (p,x), eps);
 
 %!test
 %! p = [1];
 %! x = 1:10;
 %! y = ones (size (x));
diff --git a/scripts/polynomial/ppint.m b/scripts/polynomial/ppint.m
--- a/scripts/polynomial/ppint.m
+++ b/scripts/polynomial/ppint.m
@@ -42,17 +42,17 @@ function ppi = ppint (pp, c)
     pi(:, k) = 0;
   else
     pi(:, k) = repmat (c(:), n, 1);
   endif
 
   ppi = mkpp (x, pi, d);
 
   tmp = -cumsum (ppjumps (ppi), length (d) + 1);
-  ppi.coefs(prod(d)+1:end, k) = tmp(:);
+  ppi.coefs(prod (d)+1 : end, k) = tmp(:);
 
 endfunction
 
 
 %!shared x,y,pp,ppi
 %! x = 0:8;
 %! y = [ ones(size(x)); x+1 ];
 %! pp = spline (x, y);
diff --git a/scripts/polynomial/ppjumps.m b/scripts/polynomial/ppjumps.m
--- a/scripts/polynomial/ppjumps.m
+++ b/scripts/polynomial/ppjumps.m
@@ -29,28 +29,28 @@ function jumps = ppjumps (pp)
     print_usage ();
   endif
 
   if (! (isstruct (pp) && strcmp (pp.form, "pp")))
     error ("ppjumps: PP must be a structure");
   endif
 
   ## Extract info.
-  [x, P, n, k, d] = unmkpp(pp);
+  [x, P, n, k, d] = unmkpp (pp);
   nd = length (d) + 1;
 
   ## Offsets.
-  dx = diff(x(1:n));
+  dx = diff (x(1:n));
   dx = repmat (dx, [prod(d), 1]);
   dx = reshape (dx, [d, n-1]);
   dx = shiftdim (dx, nd - 1);
 
   ## Use Horner scheme.
   if (k>1)
-    llim = shiftdim (reshape (P(1:(n-1) * prod(d), 1), [d, n-1]), nd - 1);
+    llim = shiftdim (reshape (P(1:(n-1) * prod (d), 1), [d, n-1]), nd - 1);
   endif
 
   for i = 2 : k;
     llim .*= dx;
     llim += shiftdim (reshape (P(1:(n-1) * prod (d), i), [d, n-1]), nd - 1);
   endfor
 
   rlim = shiftdim (ppval (pp, x(2:end-1)), nd - 1);
diff --git a/scripts/polynomial/ppval.m b/scripts/polynomial/ppval.m
--- a/scripts/polynomial/ppval.m
+++ b/scripts/polynomial/ppval.m
@@ -51,17 +51,17 @@ function yi = ppval (pp, xi)
   xn = numel (xi);
   idx = lookup (x, xi, "lr");
 
   P = reshape (P, [d, n * k]);
   P = shiftdim (P, nd);
   P = reshape (P, [n, k, d]);
   Pidx = P(idx(:), :);#2d matrix size x: coefs*prod(d) y: prod(sxi)
 
-  if (isvector(xi))
+  if (isvector (xi))
     Pidx = reshape (Pidx, [xn, k, d]);
     Pidx = shiftdim (Pidx, 1);
     dimvec = [d, xn];
   else
     Pidx = reshape (Pidx, [sxi, k, d]);
     Pidx = shiftdim (Pidx, length (sxi));
     dimvec = [d, sxi];
   endif
@@ -87,17 +87,17 @@ function yi = ppval (pp, xi)
   ## Adjust shape.
   if ((numel (xi) > 1) || (length (d) == 1))
     yi = reshape (shiftdim (yi, 1), dimvec);
   endif
 
   if (isvector (xi) && (d == 1))
     yi = reshape (yi, sxi);
   elseif (isfield (pp, "orient") && strcmp (pp.orient, "first"))
-    yi = shiftdim(yi, nd);
+    yi = shiftdim (yi, nd);
   endif
 
   ##
   #if (d == 1)
   #  yi = reshape (yi, sxi);
   #endif
 
 endfunction
diff --git a/scripts/polynomial/residue.m b/scripts/polynomial/residue.m
--- a/scripts/polynomial/residue.m
+++ b/scripts/polynomial/residue.m
@@ -247,17 +247,17 @@ function [r, p, k, e] = residue (b, a, v
   aorder = numel (a) - 1;
   border = aorder - 1;
 
   ## Construct a system of equations relating the individual
   ## contributions from each residue to the complete numerator.
 
   A = zeros (border+1, border+1);
   B = prepad (reshape (b, [numel(b), 1]), border+1, 0);
-  for ip = 1:numel(p)
+  for ip = 1:numel (p)
     ri = zeros (size (p));
     ri(ip) = 1;
     A(:,ip) = prepad (rresidue (ri, p, [], toler), border+1, 0).';
   endfor
 
   ## Solve for the residues.
 
   r = A \ B;
@@ -281,24 +281,24 @@ function [pnum, pden, e] = rresidue (r, 
     toler = [];
   endif
 
   if (nargin < 3)
     k = [];
   endif
 
   if (numel (e))
-    indx = 1:numel(p);
+    indx = 1:numel (p);
   else
     [e, indx] = mpoles (p, toler, 0);
     p = p (indx);
     r = r (indx);
   endif
 
-  indx = 1:numel(p);
+  indx = 1:numel (p);
 
   for n = indx
     pn = [1, -p(n)];
     if (n == 1)
       pden = pn;
     else
       pden = conv (pden, pn);
     endif
diff --git a/scripts/polynomial/roots.m b/scripts/polynomial/roots.m
--- a/scripts/polynomial/roots.m
+++ b/scripts/polynomial/roots.m
@@ -76,17 +76,17 @@
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 24 December 1993
 ## Adapted-By: jwe
 
 function r = roots (v)
 
   if (nargin != 1 || min (size (v)) > 1)
     print_usage ();
-  elseif (any (isnan(v) | isinf(v)))
+  elseif (any (isnan (v) | isinf (v)))
     error ("roots: inputs must not contain Inf or NaN");
   endif
 
   n = numel (v);
   v = v(:);
 
   ## If v = [ 0 ... 0 v(k+1) ... v(k+l) 0 ... 0 ], we can remove the
   ## leading k zeros and n - k - l roots of the polynomial are zero.
diff --git a/scripts/polynomial/spline.m b/scripts/polynomial/spline.m
--- a/scripts/polynomial/spline.m
+++ b/scripts/polynomial/spline.m
@@ -95,25 +95,25 @@ function ret = spline (x, y, xi)
   endif
 
   for k = (1:columns (a))(any (isnan (a)))
     ok = ! isnan (a(:,k));
     a(!ok,k) = spline (x(ok), a(ok,k), x(!ok));
   endfor
 
   complete = false;
-  if (size (a, 1) == n + 2)
+  if (rows (a) == n + 2)
     complete = true;
     dfs = a(1,:);
     dfe = a(end,:);
     a = a(2:end-1,:);
   endif
 
   if (! issorted (x))
-    [x, idx] = sort(x);
+    [x, idx] = sort (x);
     a = a(idx,:);
   endif
 
   b = c = zeros (size (a));
   h = diff (x);
   idx = ones (columns (a), 1);
 
   if (complete)
@@ -130,18 +130,18 @@ function ret = spline (x, y, xi)
       c = c(1:n-1,:);
       b = b(1:n-1,:);
       a = a(1:n-1,:);
     else
       g(1,:) = (a(2,:) - a(1,:)) / h(1) - dfs;
       g(2:n-1,:) = (a(3:n,:) - a(2:n-1,:)) ./ h(2:n-1) - ...
                    (a(2:n-1,:) - a(1:n-2,:)) ./ h(1:n-2);
       g(n,:) = dfe - (a(n,:) - a(n-1,:)) / h(n-1);
-      c = spdiags([[h/6;0],[h(1)/3;(h(1:n-2)+h(2:n-1))/3;h(n-1)/3],[0;h/6]],...
-                  [-1,0,1],n,n) \ (g / 2);
+      c = spdiags ([[h/6;0],[h(1)/3;(h(1:n-2)+h(2:n-1))/3;h(n-1)/3],[0;h/6]],...
+                   [-1,0,1],n,n) \ (g / 2);
       b(1:n-1,:) = diff (a) ./ h(1:n-1, idx) ...
         - h(1:n-1,idx) / 3 .* (c(2:n,:) + 2 * c(1:n-1,:));
       d = diff (c) ./ (3 * h(1:n-1, idx));
 
       d = d(1:n-1,:);
       c = c(1:n-1,:);
       b = b(1:n-1,:);
       a = a(1:n-1,:);
diff --git a/scripts/polynomial/splinefit.m b/scripts/polynomial/splinefit.m
--- a/scripts/polynomial/splinefit.m
+++ b/scripts/polynomial/splinefit.m
@@ -34,17 +34,17 @@
 ## @deftypefnx {Function File} {@var{pp} =} splinefit (@dots{}, "periodic", @var{periodic})
 ## @deftypefnx {Function File} {@var{pp} =} splinefit (@dots{}, "robust", @var{robust})
 ## @deftypefnx {Function File} {@var{pp} =} splinefit (@dots{}, "beta", @var{beta})
 ## @deftypefnx {Function File} {@var{pp} =} splinefit (@dots{}, "order", @var{order})
 ## @deftypefnx {Function File} {@var{pp} =} splinefit (@dots{}, "constraints", @var{constraints})
 ##
 ## The optional property @var{periodic} is a logical value which specifies
 ## whether a periodic boundary condition is applied to the spline.  The
-## length of the period is @code{max(@var{breaks})-min(@var{breaks})}.
+## length of the period is @code{max (@var{breaks}) - min (@var{breaks})}.
 ## The default value is @code{false}.
 ##
 ## The optional property @var{robust} is a logical value which specifies
 ## if robust fitting is to be applied to reduce the influence of outlying
 ## data points.  Three iterations of weighted least squares are performed.
 ## Weights are computed from previous residuals.  The sensitivity of outlier
 ## identification is controlled by the property @var{beta}.  The value of
 ## @var{beta} is stricted to the range, 0 < @var{beta} < 1.  The default
@@ -177,17 +177,17 @@ function pp = splinefit (x, y, breaks, v
       props = struct (varargin{:});
     catch
       print_usage ();
     end_try_catch
   else
     props = struct ();
   endif
   fields = fieldnames (props);
-  for f = 1:numel(fields)
+  for f = 1:numel (fields)
     if (! any (strcmp (fields{f},
                        {"periodic", "robust", "beta", "order", "constraints"})))
       error ("splinefit:invalidproperty",
              "unrecognized property '%s'", fields{f});
     endif
   endfor
   args = {};
   if (isfield (props, "periodic") && props.periodic)
diff --git a/scripts/prefs/addpref.m b/scripts/prefs/addpref.m
--- a/scripts/prefs/addpref.m
+++ b/scripts/prefs/addpref.m
@@ -40,17 +40,17 @@ function addpref (group, pref, val)
       if (ischar (pref))
         if (isfield (group, pref))
           error ("preference %s already exists in group %s", pref, group);
         else
           prefs.(group).(pref) = val;
         endif
       elseif (iscellstr (pref))
         if (size_equal (pref, val))
-          for i = 1:numel(pref)
+          for i = 1:numel (pref)
             if (isfield (group, pref{i}))
               error ("preference %s already exists in group %s",
                      pref{i}, group);
             else
               prefs.(group).(pref{i}) = val;
             endif
           endfor
         else
diff --git a/scripts/prefs/getpref.m b/scripts/prefs/getpref.m
--- a/scripts/prefs/getpref.m
+++ b/scripts/prefs/getpref.m
@@ -64,17 +64,17 @@ function retval = getpref (group, pref, 
         retval = grp.(pref);
       elseif (nargin == 3)
         retval = default;
       else
         error ("preference %s does not exist in group %s", pref, group);
       endif
     elseif (iscellstr (pref))
       if (nargin == 2 || size_equal (pref, default))
-        for i = 1:numel(pref)
+        for i = 1:numel (pref)
           if (isfield (grp, pref{i}))
             retval.(pref) = grp.(pref{i});
           elseif (nargin == 3)
             retval.(pref) = default{i};
           else
             error ("preference %s does not exist in group %s", pref{i}, group);
           endif
         endfor
diff --git a/scripts/prefs/setpref.m b/scripts/prefs/setpref.m
--- a/scripts/prefs/setpref.m
+++ b/scripts/prefs/setpref.m
@@ -38,17 +38,17 @@ function setpref (group, pref, val)
 
   if (nargin == 3)
     if (ischar (group))
       prefs = loadprefs ();
       if (ischar (pref))
         prefs.(group).(pref) = val;
       elseif (iscellstr (pref))
         if (size_equal (pref, val))
-          for i = 1:numel(pref)
+          for i = 1:numel (pref)
             prefs.(group).(pref{i}) = val;
           endfor
         else
           error ("size mismatch for pref and val");
         endif
       else
         error ("expecting pref to be a character string or cellstr");
       endif
diff --git a/scripts/set/intersect.m b/scripts/set/intersect.m
--- a/scripts/set/intersect.m
+++ b/scripts/set/intersect.m
@@ -70,17 +70,17 @@ function [c, ia, ib] = intersect (a, b, 
       len_a = length (a);
     endif
 
     if (nargout > 1)
       ia = ja(ic(ii));                  ## a(ia) == c
       ib = jb(ic(ii+1) - len_a);        ## b(ib) == c
     endif
 
-    if (nargin == 2 && (size (b, 1) == 1 || size (a, 1) == 1))
+    if (nargin == 2 && (rows (b) == 1 || rows (a) == 1))
       c = c.';
     endif
   endif
 
 endfunction
 
 
 %!# Test the routine for index vectors ia and ib
diff --git a/scripts/set/ismember.m b/scripts/set/ismember.m
--- a/scripts/set/ismember.m
+++ b/scripts/set/ismember.m
@@ -51,17 +51,17 @@
 ## With the optional third argument @code{"rows"}, and matrices
 ## @var{A} and @var{s} with the same number of columns, compare rows in
 ## @var{A} with the rows in @var{s}.
 ##
 ## @example
 ## @group
 ## a = [1:3; 5:7; 4:6];
 ## s = [0:2; 1:3; 2:4; 3:5; 4:6];
-## [tf, s_idx] = ismember(a, s, "rows")
+## [tf, s_idx] = ismember (a, s, "rows")
 ##      @result{} tf = logical ([1; 0; 1])
 ##      @result{} s_idx = [2; 0; 5];
 ## @end group
 ## @end example
 ##
 ## @seealso{unique, union, intersect, setxor, setdiff}
 ## @end deftypefn
 
@@ -180,22 +180,22 @@ endfunction
 %! assert (a_idx, 0);
 
 %!test
 %! [result, a_idx] = ismember ({}, {"a", "b"});
 %! assert (result, logical ([]))
 %! assert (a_idx, []);
 
 %!test
-%! [result, a_idx] = ismember([1 2 3 4 5], [3]);
+%! [result, a_idx] = ismember ([1 2 3 4 5], [3]);
 %! assert (result, logical ([0 0 1 0 0]))
 %! assert (a_idx , [0 0 1 0 0]);
 
 %!test
-%! [result, a_idx] = ismember([1 6], [1 2 3 4 5 1 6 1]);
+%! [result, a_idx] = ismember ([1 6], [1 2 3 4 5 1 6 1]);
 %! assert (result, [true true]);
 %! assert (a_idx(2), 7);
 
 %!test
 %! [result, a_idx] = ismember ([3,10,1], [0,1,2,3,4,5,6,7,8,9]);
 %! assert (result, [true false true]);
 %! assert (a_idx, [4, 0, 2]);
 
diff --git a/scripts/set/setdiff.m b/scripts/set/setdiff.m
--- a/scripts/set/setdiff.m
+++ b/scripts/set/setdiff.m
@@ -77,17 +77,17 @@ function [c, i] = setdiff (a, b, varargi
       else
         dups = find (dummy(1:end-1) == dummy(2:end));
       endif
       c(idx(dups)) = [];
       if (nargout > 1)
         i(idx(dups)) = [];
       endif
       ## Reshape if necessary.
-      if (size (c, 1) != 1 && size (b, 1) == 1)
+      if (rows (c) != 1 && rows (b) == 1)
         c = c.';
       endif
     endif
   endif
 
 endfunction
 
 
diff --git a/scripts/set/setxor.m b/scripts/set/setxor.m
--- a/scripts/set/setxor.m
+++ b/scripts/set/setxor.m
@@ -74,17 +74,17 @@ function [c, ia, ib] = setxor (a, b, var
         idx = find (strcmp (c(1:n-1), c(2:n)));
       else
         idx = find (c(1:n-1) == c(2:n));
       endif
       if (! isempty (idx))
         c([idx, idx+1]) = [];
         i([idx, idx+1]) = [];
       endif
-      if (size (a, 1) == 1 || size (b, 1) == 1)
+      if (rows (a) == 1 || rows (b) == 1)
         c = c.';
       endif
     endif
   endif
   if (nargout > 1)
     ia = ia(i(i <= na));
     ib = ib(i(i > na) - na);
   endif
@@ -93,10 +93,10 @@ endfunction
 
 
 %!assert (setxor ([1,2,3],[2,3,4]),[1,4])
 %!assert (setxor ({'a'}, {'a', 'b'}), {'b'})
 %!test
 %! a = [3, 1, 4, 1, 5];  b = [1, 2, 3, 4];
 %! [y, ia, ib] = setxor (a, b.');
 %! assert (y, [2, 5]);
-%! assert (y, sort([a(ia), b(ib)]));
+%! assert (y, sort ([a(ia), b(ib)]));
 
diff --git a/scripts/set/union.m b/scripts/set/union.m
--- a/scripts/set/union.m
+++ b/scripts/set/union.m
@@ -60,17 +60,17 @@ function [y, ia, ib] = union (a, b, vara
     print_usage ();
   endif
 
   [a, b] = validargs ("union", a, b, varargin{:});
 
   if (nargin == 2)
     y = [a(:); b(:)];
     na = numel (a); nb = numel (b);
-    if (size (a, 1) == 1 || size (b, 1) == 1)
+    if (rows (a) == 1 || rows (b) == 1)
       y = y.';
     endif
   else
     y = [a; b];
     na = rows (a); nb = rows (b);
   endif
 
   if (nargout == 1)
diff --git a/scripts/signal/arch_fit.m b/scripts/signal/arch_fit.m
--- a/scripts/signal/arch_fit.m
+++ b/scripts/signal/arch_fit.m
@@ -104,15 +104,15 @@ function [a, b] = arch_fit (y, x, p, ite
     X_tilde = x(1:T-p, :) .* (r * ones (1,k));
     e_tilde = e(1:T-p) .*s ./ r;
     delta_b = inv (X_tilde' * X_tilde) * X_tilde' * e_tilde;
     b   = b + gamma * delta_b;
     e   = y - x * b;
     esq = e .^ 2;
     Z   = autoreg_matrix (esq, p);
     h   = Z * a;
-    f   = esq ./ h - ones(T,1);
+    f   = esq ./ h - ones (T,1);
     Z_tilde = Z ./ (h * ones (1, p+1));
     delta_a = inv (Z_tilde' * Z_tilde) * Z_tilde' * f;
     a   = a + gamma * delta_a;
   endfor
 
 endfunction
diff --git a/scripts/signal/arch_rnd.m b/scripts/signal/arch_rnd.m
--- a/scripts/signal/arch_rnd.m
+++ b/scripts/signal/arch_rnd.m
@@ -66,17 +66,17 @@ function y = arch_rnd (a, b, t)
   endif
 
   lb = length (b);
   b  = reshape (b, 1, lb);
   if (lb == 1)
     b  = [b, 0];
     lb = lb + 1;
   endif
-  m  = max([la, lb]);
+  m  = max ([la, lb]);
 
   e  = zeros (t, 1);
   h  = zeros (t, 1);
   y  = zeros (t, 1);
 
   h(1) = a(1);
   e(1) = sqrt (h(1)) * randn;
   y(1) = b(1) + e(1);
diff --git a/scripts/signal/arch_test.m b/scripts/signal/arch_test.m
--- a/scripts/signal/arch_test.m
+++ b/scripts/signal/arch_test.m
@@ -75,19 +75,19 @@ function [pval, lm] = arch_test (y, x, p
     error ("arch_test: Y must be a vector");
   endif
   T   = length (y);
   y   = reshape (y, T, 1);
   [rx, cx] = size (x);
   if ((rx == 1) && (cx == 1))
     x = autoreg_matrix (y, x);
   elseif (! (rx == T))
-    error ("arch_test: either rows(X) == length(Y), or X is a scalar");
+    error ("arch_test: either rows (X) == length (Y), or X is a scalar");
   endif
-  if (! (isscalar(p) && (rem(p, 1) == 0) && (p > 0)))
+  if (! (isscalar (p) && (rem (p, 1) == 0) && (p > 0)))
     error ("arch_test: P must be a positive integer");
   endif
 
   [b, v_b, e] = ols (y, x);
   Z    = autoreg_matrix (e.^2, p);
   f    = e.^2 / v_b - ones (T, 1);
   f    = Z' * f;
   lm   = f' * inv (Z'*Z) * f / 2;
diff --git a/scripts/signal/autoreg_matrix.m b/scripts/signal/autoreg_matrix.m
--- a/scripts/signal/autoreg_matrix.m
+++ b/scripts/signal/autoreg_matrix.m
@@ -46,18 +46,18 @@ function X = autoreg_matrix (y, k)
     X(:, j+1) = [(zeros (j, 1)); y(1:T-j)];
   endfor
 
 endfunction
 
 
 %!test
 %! K = 4;
-%! A = zeros(1,K+1);
+%! A = zeros (1,K+1);
 %! A(1) = 1;
-%! B = eye(K+1);
+%! B = eye (K+1);
 %! B(:,1) = 1;
 %! assert (autoreg_matrix (A,K), B);
 
 %!error autoreg_matrix ()
 %!error autoreg_matrix (1)
 %!error autoreg_matrix (ones (4,1), 5)
 
diff --git a/scripts/signal/diffpara.m b/scripts/signal/diffpara.m
--- a/scripts/signal/diffpara.m
+++ b/scripts/signal/diffpara.m
@@ -44,17 +44,17 @@ function [d, dd] = diffpara (x, a, b)
   if ((nargin < 1) || (nargin > 3))
     print_usage ();
   else
     if (isvector (x))
       n = length (x);
       k = 1;
       x = reshape (x, n, 1);
     else
-      [n, k] = size(x);
+      [n, k] = size (x);
     endif
     if (nargin == 1)
       a = 0.5 * sqrt (n);
       b = 1.5 * sqrt (n);
     elseif (nargin == 2)
       b = a;
       a = 1;
     endif
diff --git a/scripts/signal/fftconv.m b/scripts/signal/fftconv.m
--- a/scripts/signal/fftconv.m
+++ b/scripts/signal/fftconv.m
@@ -62,18 +62,18 @@ function c = fftconv (x, y, n)
     endif
   endif
 
 endfunction
 
 
 %% FIXME: Borrow tests from conv.m.  May need a tolerance on the assert comparison
 %!test
-%!  x = ones(3,1);
-%!  y = ones(1,3);
+%!  x = ones (3,1);
+%!  y = ones (1,3);
 %!  b = 2;
 %!  c = 3;
 %!  assert (fftconv (x, x), [1; 2; 3; 2; 1], 5*eps);
 %!  assert (fftconv (y, y), [1, 2, 3, 2, 1], 5*eps);
 %!  assert (fftconv (x, y), [1, 2, 3, 2, 1], 5*eps);
 %!  assert (fftconv (y, x), [1; 2; 3; 2; 1], 5*eps);
 %!  assert (fftconv (c, x), [3; 3; 3], 5*eps);
 %!  assert (fftconv (c, y), [3, 3, 3], 5*eps);
diff --git a/scripts/signal/filter2.m b/scripts/signal/filter2.m
--- a/scripts/signal/filter2.m
+++ b/scripts/signal/filter2.m
@@ -47,12 +47,12 @@ function y = filter2 (b, x, shape)
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
   if (nargin < 3)
     shape = "same";
   endif
 
-  [nr, nc] = size(b);
+  [nr, nc] = size (b);
   y = conv2 (x, b(nr:-1:1, nc:-1:1), shape);
 endfunction
 
diff --git a/scripts/signal/hanning.m b/scripts/signal/hanning.m
--- a/scripts/signal/hanning.m
+++ b/scripts/signal/hanning.m
@@ -54,10 +54,10 @@ endfunction
 %!test
 %! N = 15;
 %! A = hanning (N);
 %! assert (A(ceil (N/2)), 1);
 
 %!error hanning ()
 %!error hanning (0.5)
 %!error hanning (-1)
-%!error hanning (ones(1,4))
+%!error hanning (ones (1,4))
 
diff --git a/scripts/signal/hurst.m b/scripts/signal/hurst.m
--- a/scripts/signal/hurst.m
+++ b/scripts/signal/hurst.m
@@ -37,12 +37,12 @@ function H = hurst (x)
   elseif (isvector (x))
     x = reshape (x, length (x), 1);
   endif
 
   [xr, xc] = size (x);
 
   s = std (x);
   w = cumsum (x - mean (x));
-  RS = (max(w) - min(w)) ./ s;
+  RS = (max (w) - min (w)) ./ s;
   H = log (RS) / log (xr);
 
 endfunction
diff --git a/scripts/signal/periodogram.m b/scripts/signal/periodogram.m
--- a/scripts/signal/periodogram.m
+++ b/scripts/signal/periodogram.m
@@ -35,17 +35,17 @@
 ## @itemize
 ## @item x: data; if real-valued a one-sided spectrum is estimated,
 ## if complex-valued or range indicates "@nospell{twosided}", the full
 ## spectrum is estimated.
 ##
 ## @item win: weight data with window, x.*win is used for further computation,
 ## if window is empty, a rectangular window is used.
 ##
-## @item nfft: number of frequency bins, default max(256, 2.^ceil(log2(length(x)))).
+## @item nfft: number of frequency bins, default max (256, 2.^ceil (log2 (length (x)))).
 ##
 ## @item Fs: sampling rate, default 1.
 ##
 ## @item range: "@nospell{onesided}" computes spectrum from [0..nfft/2+1].
 ## "@nospell{twosided}" computes spectrum from [0..nfft-1].  These strings
 ## can appear at any position in the list input arguments after window.
 ##
 ## @item Pxx: one-, or two-sided power spectrum.
@@ -103,17 +103,17 @@ function [pxx, f] = periodogram (x, vara
   if (ischar (fs))
     range = fs;
     fs = [];
   endif;
 
   if (!  isempty (window))
     if (all (size (x) == size (window)))
       x .*= window;
-    elseif (size (x, 1) == size (window, 1) && size (window, 2) == 1)
+    elseif (rows (x) == rows (window) && columns (window) == 1)
       x .*= window (:,ones (1,c));
     endif;
   endif
 
   if (numel (nfft)>1)
     error ("nfft must be scalar");
   endif
   if (isempty (nfft))
diff --git a/scripts/signal/private/triangle_sw.m b/scripts/signal/private/triangle_sw.m
--- a/scripts/signal/private/triangle_sw.m
+++ b/scripts/signal/private/triangle_sw.m
@@ -26,17 +26,17 @@
 ## Description: Triangular spectral window
 
 function retval = triangle_sw (n, b)
 
   if (nargin != 2)
     print_usage ();
   endif
 
-  retval = zeros(n,1);
+  retval = zeros (n,1);
   retval(1) = 1 / b;
 
   l = (2:n)' - 1;
   l = 2 * pi * l / n;
 
   retval(2:n) = b * (sin (l / (2*b)) ./ sin (l / 2)).^2;
 
 endfunction
diff --git a/scripts/signal/sinc.m b/scripts/signal/sinc.m
--- a/scripts/signal/sinc.m
+++ b/scripts/signal/sinc.m
@@ -18,17 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} sinc (@var{x})
 ## Return
 ## @tex
 ## $ \sin (\pi x)/(\pi x)$.
 ## @end tex
 ## @ifnottex
-##  sin(pi*x)/(pi*x).
+##  sin (pi*x) / (pi*x).
 ## @end ifnottex
 ## @end deftypefn
 
 ## Author: jwe ???
 
 function result = sinc (x)
 
   if (nargin != 1)
diff --git a/scripts/signal/spectral_xdf.m b/scripts/signal/spectral_xdf.m
--- a/scripts/signal/spectral_xdf.m
+++ b/scripts/signal/spectral_xdf.m
@@ -48,15 +48,15 @@ function retval = spectral_xdf (x, win, 
   else
     win = str2func (cstrcat (win, "_sw"));
     w = feval (win, xr, b);
   endif
 
   x = x - sum (x) / xr;
 
   retval = (abs (fft (x)) / xr).^2;
-  retval = real (ifft (fft(retval) .* fft(w)));
+  retval = real (ifft (fft (retval) .* fft (w)));
 
   retval = [(zeros (xr, 1)), retval];
   retval(:, 1) = (0 : xr-1)' / xr;
 
 endfunction
 
diff --git a/scripts/signal/spencer.m b/scripts/signal/spencer.m
--- a/scripts/signal/spencer.m
+++ b/scripts/signal/spencer.m
@@ -26,28 +26,28 @@
 ## Description: Apply Spencer's 15-point MA filter
 
 function retval = spencer (x)
 
   if (nargin != 1)
     print_usage ();
   endif
 
-  [xr, xc] = size(x);
+  [xr, xc] = size (x);
 
   n = xr;
   c = xc;
 
-  if (isvector(x))
-   n = length(x);
+  if (isvector (x))
+   n = length (x);
    c = 1;
-   x = reshape(x, n, 1);
+   x = reshape (x, n, 1);
   endif
 
   w = [-3, -6, -5, 3, 21, 46, 67, 74, 67, 46, 21, 3, -5, -6, -3] / 320;
 
   retval = fftfilt (w, x);
   retval = [zeros(7,c); retval(15:n,:); zeros(7,c);];
 
-  retval = reshape(retval, xr, xc);
+  retval = reshape (retval, xr, xc);
 
 endfunction
 
diff --git a/scripts/signal/stft.m b/scripts/signal/stft.m
--- a/scripts/signal/stft.m
+++ b/scripts/signal/stft.m
@@ -50,17 +50,17 @@
 ## entire STFT-matrix @var{y} and a 3-element vector @var{c} containing
 ## the window size, increment, and window type, which is needed by the
 ## synthesis function.
 ## @end deftypefn
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Description: Short-Time Fourier Transform
 
-function [y, c] = stft(x, win_size, inc, num_coef, win_type)
+function [y, c] = stft (x, win_size, inc, num_coef, win_type)
 
   ## Default values of unspecified arguments.
   if (nargin < 5)
     win_type = 1;
     if (nargin < 4)
       num_coef = 64;
       if (nargin < 3)
         inc = 24;
diff --git a/scripts/signal/synthesis.m b/scripts/signal/synthesis.m
--- a/scripts/signal/synthesis.m
+++ b/scripts/signal/synthesis.m
@@ -57,16 +57,16 @@ function x = synthesis (y, c)
     error ("synthesis: window_type must be 1, 2, or 3");
   endif
 
   z = real (ifft (y));
   st = fix ((w_size-inc) / 2);
   z = z(st:st+inc-1, :);
   w_coeff = w_coeff(st:st+inc-1);
 
-  nc = columns(z);
+  nc = columns (z);
   for i = 1:nc
     z(:, i) = z(:, i) ./ w_coeff;
   endfor
 
-  x = reshape(z, inc * nc, 1);
+  x = reshape (z, inc * nc, 1);
 
 endfunction
diff --git a/scripts/signal/unwrap.m b/scripts/signal/unwrap.m
--- a/scripts/signal/unwrap.m
+++ b/scripts/signal/unwrap.m
@@ -31,17 +31,17 @@
 ## Author: Bill Lash <lash@tellabs.com>
 
 function retval = unwrap (x, tol, dim)
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
   endif
 
-  if (!isnumeric(x))
+  if (!isnumeric (x))
     error ("unwrap: X must be a numeric matrix or vector");
   endif
 
   if (nargin < 2 || isempty (tol))
     tol = pi;
   endif
 
   ## Don't let anyone use a negative value for TOL.
@@ -73,29 +73,29 @@ function retval = unwrap (x, tol, dim)
   ## as large values, and the sign will show direction.
   idx = repmat ({':'}, nd, 1);
   idx{dim} = [1,1:m-1];
   d = x(idx{:}) - x;
 
   ## Find only the peaks, and multiply them by the appropriate amount
   ## of ranges so that there are kronecker deltas at each wrap point
   ## multiplied by the appropriate amount of range values.
-  p =  ceil(abs(d)./rng) .* rng .* (((d > tol) > 0) - ((d < -tol) > 0));
+  p =  ceil (abs (d)./rng) .* rng .* (((d > tol) > 0) - ((d < -tol) > 0));
 
   ## Now need to "integrate" this so that the deltas become steps.
   r = cumsum (p, dim);
 
   ## Now add the "steps" to the original data and put output in the
   ## same shape as originally.
   retval = x + r;
 
 endfunction
 
 
-%!function t = __xassert(a,b,tol)
+%!function t = __xassert (a,b,tol)
 %!  if (nargin == 1)
 %!    t = all (a(:));
 %!  else
 %!    if (nargin == 2)
 %!      tol = 0;
 %!    endif
 %!    if (any (size (a) != size (b)))
 %!      t = 0;
diff --git a/scripts/signal/yulewalker.m b/scripts/signal/yulewalker.m
--- a/scripts/signal/yulewalker.m
+++ b/scripts/signal/yulewalker.m
@@ -36,17 +36,17 @@ function [a, v] = yulewalker (c)
 
   p = length (c) - 1;
 
   if (columns (c) > 1)
     c = c';
   endif
 
   cp = c(2 : p+1);
-  CP = zeros(p, p);
+  CP = zeros (p, p);
 
   for i = 1:p
     for j = 1:p
       CP (i, j) = c (abs (i-j) + 1);
     endfor
   endfor
 
   a = inv (CP) * cp;
diff --git a/scripts/sparse/bicgstab.m b/scripts/sparse/bicgstab.m
--- a/scripts/sparse/bicgstab.m
+++ b/scripts/sparse/bicgstab.m
@@ -133,17 +133,17 @@ function [x, flag, relres, iter, resvec]
     endif
 
     norm_b = norm (b);
 
     res = b - Ax (x);
     rr = res;
 
     ## Vector of the residual norms for each iteration.
-    resvec = norm(res) / norm_b;
+    resvec = norm (res) / norm_b;
 
     ## Default behaviour we don't reach tolerance tol within maxit iterations.
     flag = 1;
 
     for iter = 1:maxit
       rho_1 = res' * rr;
 
       if (iter == 1)
diff --git a/scripts/sparse/gmres.m b/scripts/sparse/gmres.m
--- a/scripts/sparse/gmres.m
+++ b/scripts/sparse/gmres.m
@@ -219,17 +219,17 @@ endfunction
 %! A = spdiags ([[1./(2:2:2*(dim-1)) 0]; 1./(1:2:2*dim-1); [0 1./(2:2:2*(dim-1))]]', -1:1, dim, dim);
 %! A = A'*A;
 %! b = rand (dim, 1);
 %! [x, resvec] = gmres (@(x) A*x, b, dim, 1e-10, dim, @(x) x./diag (A), [], []);
 %! assert (x, A\b, 1e-9*norm (x, Inf));
 %! x = gmres (@(x) A*x, b, dim, 1e-10, 1e6, @(x) diag (diag (A)) \ x, [], []);
 %! assert (x, A\b, 1e-9*norm (x, Inf));
 %!test
-%! x = gmres (@(x) A*x, b, dim, 1e-10, 1e6, @(x) x./diag(A), [], []);
+%! x = gmres (@(x) A*x, b, dim, 1e-10, 1e6, @(x) x ./ diag (A), [], []);
 %! assert (x, A\b, 1e-7*norm (x, Inf));
 
 
 %!error gmres (1)
 %!error gmres (1,2,3,4,5,6,7,8,9)
 %!error <A must be> gmres ({1},2)
 %!error <A must be a function or matrix> gmres ({1},2)
 %!error <M1 must be a function or matrix> gmres (1,2,3,4,5,{6})
diff --git a/scripts/sparse/pcg.m b/scripts/sparse/pcg.m
--- a/scripts/sparse/pcg.m
+++ b/scripts/sparse/pcg.m
@@ -236,17 +236,17 @@ function [x, flag, relres, iter, resvec,
 
   if (nargin < 6 || isempty (m2))
      exist_m2 = 0;
   else
      exist_m2 = 1;
   endif
 
   if (nargin < 4 || isempty (maxit))
-    maxit = min (size (b, 1), 20);
+    maxit = min (rows (b), 20);
   endif
 
   maxit += 2;
 
   if (nargin < 3 || isempty (tol))
     tol = 1e-6;
   endif
 
@@ -270,17 +270,17 @@ function [x, flag, relres, iter, resvec,
   endif
 
   resvec(1,1) = norm (r);
   alpha = 1;
   iter = 2;
 
   while (resvec (iter-1,1) > tol * resvec (1,1) && iter < maxit)
     if (exist_m1)
-      if(isnumeric (m1))
+      if (isnumeric (m1))
         y = m1 \ r;
       else
         y = feval (m1, r, varargin{:});
       endif
     else
       y = r;
     endif
     if (exist_m2)
@@ -311,18 +311,18 @@ function [x, flag, relres, iter, resvec,
       ## Negative matrix.
       matrix_positive_definite = false;
     endif
     x += alpha * p;
     r -= alpha * w;
     if (nargout > 5 && iter > 2)
       T(iter-1:iter, iter-1:iter) = T(iter-1:iter, iter-1:iter) + ...
           [1 sqrt(beta); sqrt(beta) beta]./oldalpha;
-      ## EVS = eig(T(2:iter-1,2:iter-1));
-      ## fprintf(stderr,"PCG condest: %g (iteration: %d)\n", max(EVS)/min(EVS),iter);
+      ## EVS = eig (T(2:iter-1,2:iter-1));
+      ## fprintf (stderr,"PCG condest: %g (iteration: %d)\n", max (EVS)/min (EVS),iter);
     endif
     resvec (iter,1) = norm (r);
     iter++;
   endwhile
 
   if (nargout > 5)
     if (matrix_positive_definite)
       if (iter > 3)
diff --git a/scripts/sparse/pcr.m b/scripts/sparse/pcr.m
--- a/scripts/sparse/pcr.m
+++ b/scripts/sparse/pcr.m
@@ -247,17 +247,17 @@ function [x, flag, relres, iter, resvec]
       breakdown = true;
       break;
     endif
     lambda = b_top / b_bot;
 
     x += lambda*p;
     r -= lambda*q;
 
-    if (isnumeric(A))           # is A a matrix?
+    if (isnumeric (A))          # is A a matrix?
       t = A*s;
     else                        # then A should be a function!
       t = feval (A, s, varargin{:});
     endif
 
     alpha0 = (t'*s) / b_bot;
     alpha1 = (t'*s_old) / b_bot_old;
 
diff --git a/scripts/sparse/private/__sprand_impl__.m b/scripts/sparse/private/__sprand_impl__.m
--- a/scripts/sparse/private/__sprand_impl__.m
+++ b/scripts/sparse/private/__sprand_impl__.m
@@ -34,17 +34,17 @@ function S = __sprand_impl__ (varargin)
     m = varargin{1};
     randfun = varargin{2};
     [i, j] = find (m);
     [nr, nc] = size (m);
     S = sparse (i, j, randfun (size (i)), nr, nc);
     return;
   endif
 
-  [m, n, d, funname, randfun] = deal(varargin{:});
+  [m, n, d, funname, randfun] = deal (varargin{:});
 
   if (!(isscalar (m) && m == fix (m) && m > 0))
     error ("%s: M must be an integer greater than 0", funname);
   endif
 
   if (!(isscalar (n) && n == fix (n) && n > 0))
     error ("%s: N must be an integer greater than 0", funname);
   endif
@@ -55,9 +55,9 @@ function S = __sprand_impl__ (varargin)
 
   mn = m*n;
   k = round (d*mn);
   idx = randperm (mn, k);
 
   [i, j] = ind2sub ([m, n], idx);
   S = sparse (i, j, randfun (k, 1), m, n);
 
-endfunction
\ No newline at end of file
+endfunction
diff --git a/scripts/sparse/speye.m b/scripts/sparse/speye.m
--- a/scripts/sparse/speye.m
+++ b/scripts/sparse/speye.m
@@ -27,17 +27,17 @@
 ## Called with a single argument a square matrix of size @var{m} by
 ## @var{m} is created.  Otherwise a matrix of @var{m} by @var{n} is
 ## created.  If called with a single vector argument, this argument
 ## is taken to be the size of the matrix to create.
 ## @end deftypefn
 
 function s = speye (m, n)
   if (nargin == 1)
-    if (isvector (m) && length(m) == 2)
+    if (isvector (m) && length (m) == 2)
       n = m(2);
       m = m(1);
     elseif (isscalar (m))
       n = m;
     else
       error ("speye: invalid matrix dimension");
     endif
   else
diff --git a/scripts/sparse/spfun.m b/scripts/sparse/spfun.m
--- a/scripts/sparse/spfun.m
+++ b/scripts/sparse/spfun.m
@@ -32,17 +32,17 @@ function y = spfun (f, S)
   endif
 
   [i, j, v] = find (S);
   [m, n] = size (S);
 
   if (isa (f, "function_handle") || isa (f, "inline function"))
     y = sparse (i, j, f(v), m, n);
   else
-    y = sparse(i, j, feval (f, v), m, n);
+    y = sparse (i, j, feval (f, v), m, n);
   endif
 
 endfunction
 
 
 %!assert (spfun ("exp", [1,2;3,0]), sparse ([exp(1),exp(2);exp(3),0]))
 %!assert (spfun ("exp", sparse ([1,2;3,0])), sparse ([exp(1),exp(2);exp(3),0]))
 %!assert (spfun (@exp, [1,2;3,0]), sparse ([exp(1),exp(2);exp(3),0]))
diff --git a/scripts/sparse/sprandn.m b/scripts/sparse/sprandn.m
--- a/scripts/sparse/sprandn.m
+++ b/scripts/sparse/sprandn.m
@@ -58,17 +58,17 @@ endfunction
 %! [i, j] = find (s);
 %! assert (sort (i), [1 2 3]');
 %! assert (sort (j), [2 3 3]');
 
 %% Test input validation
 %!error sprandn ()
 %!error sprandn (1, 2)
 %!error sprandn (1, 2, 3, 4)
-%!error sprandn (ones(3), 3, 0.5)
+%!error sprandn (ones (3), 3, 0.5)
 %!error sprandn (3.5, 3, 0.5)
 %!error sprandn (0, 3, 0.5)
-%!error sprandn (3, ones(3), 0.5)
+%!error sprandn (3, ones (3), 0.5)
 %!error sprandn (3, 3.5, 0.5)
 %!error sprandn (3, 0, 0.5)
 %!error sprandn (3, 3, -1)
 %!error sprandn (3, 3, 2)
 
diff --git a/scripts/sparse/spstats.m b/scripts/sparse/spstats.m
--- a/scripts/sparse/spstats.m
+++ b/scripts/sparse/spstats.m
@@ -46,17 +46,17 @@ function [count, mean, var] = spstats (S
   [n, m] = size (S);
 
   count = sum (sparse (i, j, 1, n, m));
   if (nargout > 1)
     mean = sum (S) ./ count;
   endif
   if (nargout > 2)
     ## FIXME Variance with count = 0 or 1?
-    diff = S - sparse (i, j, mean(j), n, m);
+    diff = S - sparse (i, j, mean (j), n, m);
     var = sum (diff .* diff) ./ (count - 1);
   endif
 
 endfunction
 
 
 %!test
 %! [n,m,v] = spstats ([1 2 1 2 3 4],[2 2 1 1 1 1]);
diff --git a/scripts/sparse/svds.m b/scripts/sparse/svds.m
--- a/scripts/sparse/svds.m
+++ b/scripts/sparse/svds.m
@@ -80,30 +80,30 @@
 ##
 ## @example
 ## @group
 ## norm (@var{A}*@var{v} - @var{u}*@var{s}, 1) <= @var{tol} * norm (@var{A}, 1)
 ## @end group
 ## @end example
 ##
 ## @code{svds} is best for finding only a few singular values from a large
-## sparse matrix.  Otherwise, @code{svd (full(@var{A}))} will likely be more
+## sparse matrix.  Otherwise, @code{svd (full (@var{A}))} will likely be more
 ## efficient.
 ## @end deftypefn
 ## @seealso{svd, eigs}
 
 function [u, s, v, flag] = svds (A, k, sigma, opts)
 
   persistent root2 = sqrt (2);
 
   if (nargin < 1 || nargin > 4)
     print_usage ();
   endif
 
-  if (ndims(A) > 2)
+  if (ndims (A) > 2)
     error ("svds: A must be a 2D matrix");
   endif
 
   if (nargin < 4)
     opts.tol = 1e-10 / root2;
     opts.disp = 0;
     opts.maxit = 300;
   else
@@ -189,17 +189,17 @@ function [u, s, v, flag] = svds (A, k, s
     ## are artifacts of the way the matrix passed to eigs is formed. There
     ## is also the possibility that the value of sigma chosen is exactly
     ## a singular value, and in that case we're dead!! So have to rely on
     ## the warning from eigs. We exclude the singular values which are
     ## less than or equal to zero to within some tolerance scaled by the
     ## norm since if we don't we might end up with too many singular
     ## values.
     tol = norma * opts.tol;
-    ind = find(s > tol);
+    ind = find (s > tol);
     if (length (ind) < k)
       ## Too few eigenvalues returned.  Add in any zero eigenvalues of B,
       ## including the nominally negative ones.
       zind = find (abs (s) <= tol);
       p = min (length (zind), k - length (ind));
       ind = [ind; zind(1:p)];
     elseif (length (ind) > k)
       ## Too many eigenvalues returned.  Select according to criterium.
@@ -243,17 +243,17 @@ endfunction
 
 
 %!shared n, k, A, u, s, v, opts, rand_state, randn_state
 %! n = 100;
 %! k = 7;
 %! A = sparse ([3:n,1:n,1:(n-2)],[1:(n-2),1:n,3:n],[ones(1,n-2),0.4*n*ones(1,n),ones(1,n-2)]);
 %! [u,s,v] = svd (full (A));
 %! s = diag (s);
-%! [~, idx] = sort (abs(s));
+%! [~, idx] = sort (abs (s));
 %! s = s(idx);
 %! u = u(:, idx);
 %! v = v(:, idx);
 %! randn_state = randn ("state");
 %! rand_state = rand ("state");
 %! randn ("state", 42);      % Initialize to make normest function reproducible
 %! rand ("state", 42);
 %! opts.v0 = rand (2*n,1); % Initialize eigs ARPACK starting vector
@@ -267,17 +267,17 @@ endfunction
 %!
 %!testif HAVE_ARPACK, HAVE_UMFPACK
 %! [u2,s2,v2,flag] = svds (A,k,0,opts);
 %! s2 = diag (s2);
 %! assert (flag, !1);
 %! assert (s2, s(k:-1:1), 1e-10);
 %!
 %!testif HAVE_ARPACK, HAVE_UMFPACK
-%! idx = floor(n/2);
+%! idx = floor (n/2);
 %! % Don't put sigma right on a singular value or there are convergence issues
 %! sigma = 0.99*s(idx) + 0.01*s(idx+1);
 %! [u2,s2,v2,flag] = svds (A,k,sigma,opts);
 %! s2 = diag (s2);
 %! assert (flag, !1);
 %! assert (s2, s((idx+floor(k/2)):-1:(idx-floor(k/2))), 1e-10);
 %!
 %!testif HAVE_ARPACK
diff --git a/scripts/sparse/treelayout.m b/scripts/sparse/treelayout.m
--- a/scripts/sparse/treelayout.m
+++ b/scripts/sparse/treelayout.m
@@ -136,28 +136,28 @@ function [x_coordinate, y_coordinate, he
         idx = zeros (1, 0);
       endif
 
       ## Add to idx the vector of parent descendants.
       stk = [stk; [idx', ones(fliplr(size(idx))) * par_number]];
 
       ## We are in top level separator when we have one child and the
       ## flag is 1
-      if (columns(idx) == 1 && top_level == 1)
+      if (columns (idx) == 1 && top_level == 1)
         s++;
       else
         # We aren't in top level separator now.
         top_level = 0;
       endif
       ## If there is not any descendant of "parent node":
       if (stk(end,2) != par_number)
        left_most++;
        x_coordinate_r(par_number) = left_most;
        max_ht = min (max_ht, level);
-       if (length(stk) > 1 && find ((shift(stk,1)-stk) == 0) > 1
+       if (length (stk) > 1 && find ((shift (stk,1) - stk) == 0) > 1
            && stk(end,2) != stk(end-1,2))
           ## Return to the nearest branching the position to return
           ## position is the position on the stack, where should be
           ## started further search (there are two nodes which has the
           ## same parent node).
 
           position = (find ((shift (stk(:,2), 1) - stk(:,2)) == 0))(end) + 1;
           par_number_vec = stk(position:end,2);
diff --git a/scripts/sparse/treeplot.m b/scripts/sparse/treeplot.m
--- a/scripts/sparse/treeplot.m
+++ b/scripts/sparse/treeplot.m
@@ -111,23 +111,23 @@ function treeplot (tree, node_style = "k
       skelet = [skelet; ([ones(size(idx))*par_number; idx])(:)];
     endif
 
     ## If there is not any descendant of "parent node":
     if (stk(end,2) != par_number)
       left_most++;
       x_coordinate_r(par_number) = left_most;
       max_ht = min (max_ht, level);
-      if (length(stk) > 1 && find ((shift(stk,1)-stk) == 0) > 1
+      if (length (stk) > 1 && find ((shift (stk,1) - stk) == 0) > 1
           && stk(end,2) != stk(end-1,2))
         ## Return to the nearest branching the position to return
         ## position is the position on the stack, where should be
         ## started further search (there are two nodes which has the
         ## same parent node).
-        position = (find ((shift(stk(:,2),1)-stk(:,2)) == 0))(end) + 1;
+        position = (find ((shift (stk(:,2),1) - stk(:,2)) == 0))(end) + 1;
         par_number_vec = stk(position:end,2);
         ## The vector of removed nodes (the content of stack form
         ## position to end).
         skelet = [skelet; flipud(par_number_vec)];
         level += length (par_number_vec);
         ## The level have to be decreased.
         x_coordinate_r(par_number_vec) = left_most;
         stk(position:end,:) = [];
@@ -168,17 +168,17 @@ function treeplot (tree, node_style = "k
     ## Helping command - usable for plotting edges
     skelet = [skelet; 0];
 
     ## Draw graph edges.
     idx = find (skelet == 0);
 
     hold ("on");
     ## Plot each tree component in one loop.
-    for i = 2:length(idx)
+    for i = 2:length (idx)
       ## Tree component start.
       istart = idx(i-1) + 1;
       ## Tree component end.
       istop = idx(i) - 1;
       if (istop - istart < 1)
         continue;
       endif
       plot (x_coordinate(skelet(istart:istop)),
diff --git a/scripts/specfun/bessel.m b/scripts/specfun/bessel.m
--- a/scripts/specfun/bessel.m
+++ b/scripts/specfun/bessel.m
@@ -22,31 +22,31 @@
 ## @deftypefnx {Loadable Function} {[@var{i}, @var{ierr}] =} besseli (@var{alpha}, @var{x}, @var{opt})
 ## @deftypefnx {Loadable Function} {[@var{k}, @var{ierr}] =} besselk (@var{alpha}, @var{x}, @var{opt})
 ## @deftypefnx {Loadable Function} {[@var{h}, @var{ierr}] =} besselh (@var{alpha}, @var{k}, @var{x}, @var{opt})
 ## Compute Bessel or Hankel functions of various kinds:
 ##
 ## @table @code
 ## @item besselj
 ## Bessel functions of the first kind.  If the argument @var{opt} is supplied,
-## the result is multiplied by @code{exp(-abs(imag(x)))}.
+## the result is multiplied by @code{exp (-abs (imag (x)))}.
 ##
 ## @item bessely
 ## Bessel functions of the second kind.  If the argument @var{opt} is supplied,
-## the result is multiplied by @code{exp(-abs(imag(x)))}.
+## the result is multiplied by @code{exp (-abs (imag (x)))}.
 ##
 ## @item besseli
 ## Modified Bessel functions of the first kind.  If the argument @var{opt} is
 ## supplied,
-## the result is multiplied by @code{exp(-abs(real(x)))}.
+## the result is multiplied by @code{exp (-abs (real (x)))}.
 ##
 ## @item besselk
 ## Modified Bessel functions of the second kind.  If the argument @var{opt} is
 ## supplied,
-## the result is multiplied by @code{exp(x)}.
+## the result is multiplied by @code{exp (x)}.
 ##
 ## @item besselh
 ## Compute Hankel functions of the first (@var{k} = 1) or second (@var{k}
 ## = 2) kind.  If the argument @var{opt} is supplied, the result is multiplied
 ## by
 ## @code{exp (-I*@var{x})} for @var{k} = 1 or @code{exp (I*@var{x})} for
 ## @var{k} = 2.
 ## @end table
diff --git a/scripts/specfun/factor.m b/scripts/specfun/factor.m
--- a/scripts/specfun/factor.m
+++ b/scripts/specfun/factor.m
@@ -71,17 +71,17 @@ function [x, n] = factor (q)
     ## Reduce q.
     q = q / prod (p);
   endwhile
   x = sort (x);
 
   ## Determine muliplicity.
   if (nargout > 1)
     idx = find ([0, x] != [x, 0]);
-    x = x(idx(1:length(idx)-1));
+    x = x(idx(1:length (idx)-1));
     n = diff (idx);
   endif
 
 endfunction
 
 
 %!assert (factor (1), 1)
 %!test
diff --git a/scripts/specfun/legendre.m b/scripts/specfun/legendre.m
--- a/scripts/specfun/legendre.m
+++ b/scripts/specfun/legendre.m
@@ -191,17 +191,17 @@ function retval = legendre (n, x, normal
 
   ## Based on the recurrence relation below
   ##            m                 m              m
   ## (n-m+1) * P (x) = (2*n+1)*x*P (x)  - (n+1)*P (x)
   ##            n+1               n              n-1
   ## http://en.wikipedia.org/wiki/Associated_Legendre_function
 
   overflow = false;
-  retval = zeros([n+1, size(x)]);
+  retval = zeros ([n+1, size(x)]);
   for m = 1:n
     lpm1 = scale;
     lpm2 = (2*m-1) .* x .* scale;
     lpm3 = lpm2;
     for k = m+1:n
       lpm3a = (2*k-1) .* x .* lpm2;
       lpm3b = (k+m-2) .* lpm1;
       lpm3 = (lpm3a - lpm3b)/(k-m+1);
@@ -217,17 +217,17 @@ function retval = legendre (n, x, normal
     endfor
     retval(m,:) = lpm3(:);
     if (strcmp (normalization, "unnorm"))
       scale = -scale * (2*m-1);
     else
       ## normalization == "sch" or normalization == "norm"
       scale = scale / sqrt ((n-m+1)*(n+m))*(2*m-1);
     endif
-    scale = scale .* sqrt(1-x.^2);
+    scale = scale .* sqrt (1-x.^2);
   endfor
 
   retval(n+1,:) = scale(:);
 
   if (isvector (x))
   ## vector case is special
     retval = reshape (retval, n + 1, length (x));
   endif
diff --git a/scripts/specfun/perms.m b/scripts/specfun/perms.m
--- a/scripts/specfun/perms.m
+++ b/scripts/specfun/perms.m
@@ -19,17 +19,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} perms (@var{v})
 ##
 ## Generate all permutations of @var{v}, one row per permutation.  The
 ## result has size @code{factorial (@var{n}) * @var{n}}, where @var{n}
 ## is the length of @var{v}.
 ##
-## As an example, @code{perms([1, 2, 3])} returns the matrix
+## As an example, @code{perms ([1, 2, 3])} returns the matrix
 ##
 ## @example
 ## @group
 ##   1   2   3
 ##   2   1   3
 ##   1   3   2
 ##   2   3   1
 ##   3   1   2
@@ -47,17 +47,17 @@ function A = perms (v)
 
   if (n == 0)
     A = [];
   else
     A = v(1);
     for j = 2:n
       B = A;
       A = zeros (prod (2:j), n, class (v));
-      k = size (B, 1);
+      k = rows (B);
       idx = 1:k;
       for i = j:-1:1
         A(idx,1:i-1) = B(:,1:i-1);
         A(idx,i) = v(j);
         A(idx,i+1:j) = B(:,i:j-1);
         idx += k;
       endfor
     endfor
diff --git a/scripts/specfun/primes.m b/scripts/specfun/primes.m
--- a/scripts/specfun/primes.m
+++ b/scripts/specfun/primes.m
@@ -26,17 +26,17 @@
 ## Note that if you need a specific number of primes you can use the
 ## fact that the distance from one prime to the next is, on average,
 ## proportional to the logarithm of the prime.  Integrating, one finds
 ## that there are about @math{k} primes less than
 ## @tex
 ## $k \log (5 k)$.
 ## @end tex
 ## @ifnottex
-## k*log(5*k).
+## k*log (5*k).
 ## @end ifnottex
 ## @seealso{list_primes, isprime}
 ## @end deftypefn
 
 ## Author: Paul Kienzle
 ## Author: Francesco Potort√¨
 ## Author: Dirk Laurie
 
@@ -56,31 +56,31 @@ function x = primes (n)
     ## below this the more direct code below is faster.  At the limit
     ## of memory in Paul's machine, this saves .7 seconds out of 7 for
     ## n = 3e6.  Hardly worthwhile, but Dirk reports better numbers.
     lenm = floor ((n+1)/6);       # length of the 6n-1 sieve
     lenp = floor ((n-1)/6);       # length of the 6n+1 sieve
     sievem = true (1, lenm);      # assume every number of form 6n-1 is prime
     sievep = true (1, lenp);      # assume every number of form 6n+1 is prime
 
-    for i = 1:(sqrt(n)+1)/6       # check up to sqrt(n)
+    for i = 1:(sqrt (n)+1)/6      # check up to sqrt (n)
       if (sievem(i))              # if i is prime, eliminate multiples of i
         sievem(7*i-1:6*i-1:lenm) = false;
         sievep(5*i-1:6*i-1:lenp) = false;
       endif                       # if i is prime, eliminate multiples of i
       if (sievep(i))
         sievep(7*i+1:6*i+1:lenp) = false;
         sievem(5*i+1:6*i+1:lenm) = false;
       endif
     endfor
-    x = sort([2, 3, 6*find(sievem)-1, 6*find(sievep)+1]);
+    x = sort ([2, 3, 6*find(sievem)-1, 6*find(sievep)+1]);
   elseif (n > 352)                # nothing magical about 352; must be >2
     len = floor ((n-1)/2);        # length of the sieve
     sieve = true (1, len);        # assume every odd number is prime
-    for i = 1:(sqrt(n)-1)/2       # check up to sqrt(n)
+    for i = 1:(sqrt (n)-1)/2      # check up to sqrt (n)
       if (sieve(i))               # if i is prime, eliminate multiples of i
         sieve(3*i+1:2*i+1:len) = false; # do it
       endif
     endfor
     x = [2, 1+2*find(sieve)];     # primes remaining after sieve
   else
     a = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, ...
          53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, ...
diff --git a/scripts/special-matrix/magic.m b/scripts/special-matrix/magic.m
--- a/scripts/special-matrix/magic.m
+++ b/scripts/special-matrix/magic.m
@@ -21,17 +21,17 @@
 ##
 ## Create an @var{n}-by-@var{n} magic square.  A magic square is an arrangement
 ## of the integers @code{1:n^2} such that the row sums, column sums, and
 ## diagonal sums are all equal to the same value.
 ##
 ## Note: @var{n} must be greater than 2 for the magic square to exist.
 ## @end deftypefn
 
-function A = magic(n)
+function A = magic (n)
 
   if (nargin != 1)
     print_usage ();
   endif
 
   if (n != fix (n) || n < 0 || n == 2)
     error ("magic: N must be a positive integer not equal to 2");
   endif
diff --git a/scripts/special-matrix/toeplitz.m b/scripts/special-matrix/toeplitz.m
--- a/scripts/special-matrix/toeplitz.m
+++ b/scripts/special-matrix/toeplitz.m
@@ -100,18 +100,18 @@ function retval = toeplitz (c, r)
     r = r(:).';  ## enforce row vector
     cidx = find (c);
     ridx = find (r);
 
     ## Ignore the first element in r.
     ridx = ridx(ridx > 1);
 
     ## Form matrix.
-    retval = spdiags(repmat (c(cidx),nr,1),1-cidx,nr,nc) + ...
-             spdiags(repmat (r(ridx),nr,1),ridx-1,nr,nc);
+    retval = spdiags (repmat (c(cidx),nr,1),1-cidx,nr,nc) + ...
+             spdiags (repmat (r(ridx),nr,1),ridx-1,nr,nc);
   else
     ## Concatenate data into a single column vector.
     data = [r(end:-1:2)(:); c(:)];
 
     ## Get slices.
     slices = cellslices (data, nc:-1:1, nc+nr-1:-1:nr);
 
     ## Form matrix.
diff --git a/scripts/statistics/base/corr.m b/scripts/statistics/base/corr.m
--- a/scripts/statistics/base/corr.m
+++ b/scripts/statistics/base/corr.m
@@ -96,17 +96,17 @@ endfunction
 %!test
 %! x = single ([1:3]');
 %! y = single ([3:-1:1]');
 %! assert (corr (x, y), single (-1), 5*eps);
 %! assert (corr (x, flipud (y)), single (1), 5*eps);
 %! assert (corr ([x, y]), single ([1 -1; -1 1]), 5*eps);
 
 %!assert (corr (5), 1)
-%!assert (corr (single(5)), single(1))
+%!assert (corr (single (5)), single (1))
 
 %% Test input validation
 %!error corr ()
 %!error corr (1, 2, 3)
 %!error corr ([1; 2], ["A", "B"])
 %!error corr (ones (2,2,2))
 %!error corr (ones (2,2), ones (2,2,2))
 
diff --git a/scripts/statistics/base/cov.m b/scripts/statistics/base/cov.m
--- a/scripts/statistics/base/cov.m
+++ b/scripts/statistics/base/cov.m
@@ -139,25 +139,25 @@ endfunction
 %! assert (cov ([x, y]), single ([1 -1; -1 1]), 5*eps);
 
 %!test
 %! x = [1:5];
 %! c = cov (x);
 %! assert (isscalar (c));
 %! assert (c, 2.5);
 
-%!assert(cov (5), 0)
-%!assert(cov (single(5)), single(0))
+%!assert (cov (5), 0)
+%!assert (cov (single (5)), single (0))
 
 %!test
 %! x = [1:5];
 %! c = cov (x, 0);
-%! assert(c, 2.5);
+%! assert (c, 2.5);
 %! c = cov (x, 1);
-%! assert(c, 2);
+%! assert (c, 2);
 
 %% Test input validation
 %!error cov ()
 %!error cov (1, 2, 3, 4)
 %!error cov ([1; 2], ["A", "B"])
 %!error cov (ones (2,2,2))
 %!error cov (ones (2,2), ones (2,2,2))
 %!error cov (1, 3)
diff --git a/scripts/statistics/base/mean.m b/scripts/statistics/base/mean.m
--- a/scripts/statistics/base/mean.m
+++ b/scripts/statistics/base/mean.m
@@ -138,14 +138,14 @@ endfunction
 %!assert (mean (logical ([1 0 1 1])), 0.75)
 %!assert (mean (single ([1 0 1 1])), single (0.75))
 
 %% Test input validation
 %!error mean ()
 %!error mean (1, 2, 3, 4)
 %!error mean ({1:5})
 %!error mean (1, 2, 3)
-%!error mean (1, ones(2,2))
+%!error mean (1, ones (2,2))
 %!error mean (1, 1.5)
 %!error mean (1, 0)
 %!error mean (1, 3)
 %!error mean (1, "b")
 
diff --git a/scripts/statistics/base/median.m b/scripts/statistics/base/median.m
--- a/scripts/statistics/base/median.m
+++ b/scripts/statistics/base/median.m
@@ -112,12 +112,12 @@ endfunction
 %!assert (median (a, 4), x(:, :, :, 3));
 %!assert (median (b, 3), (y(:, :, 3, :) + y(:, :, 4, :))/2);
 
 %% Test input validation
 %!error median ()
 %!error median (1, 2, 3)
 %!error median ({1:5})
 %!error median (['A'; 'B'])
-%!error median (1, ones(2,2))
+%!error median (1, ones (2,2))
 %!error median (1, 1.5)
 %!error median (1, 0)
 
diff --git a/scripts/statistics/base/mode.m b/scripts/statistics/base/mode.m
--- a/scripts/statistics/base/mode.m
+++ b/scripts/statistics/base/mode.m
@@ -107,17 +107,17 @@ endfunction
 %! assert (f, [1;2;2;2;1]);
 %! assert (c, {[1;2;3;4;5];[2];[2;3];[2];[1;2;3;4;5]});
 %!test
 %! a = sprandn (32, 32, 0.05);
 %! [m, f, c] = mode (a);
 %! [m2, f2, c2] = mode (full (a));
 %! assert (m, sparse (m2));
 %! assert (f, sparse (f2));
-%! c_exp(1:length(a)) = { sparse (0) };
+%! c_exp(1:length (a)) = { sparse (0) };
 %! assert (c ,c_exp);
 %! assert (c2,c_exp );
 
 %!assert (mode ([2,3,1,2,3,4],1),[2,3,1,2,3,4])
 %!assert (mode ([2,3,1,2,3,4],2),2)
 %!assert (mode ([2,3,1,2,3,4]),2)
 %!assert (mode (single ([2,3,1,2,3,4])), single (2))
 %!assert (mode (int8 ([2,3,1,2,3,4])), int8 (2))
diff --git a/scripts/statistics/base/qqplot.m b/scripts/statistics/base/qqplot.m
--- a/scripts/statistics/base/qqplot.m
+++ b/scripts/statistics/base/qqplot.m
@@ -53,17 +53,17 @@
 ## Description: Perform a QQ-plot (quantile plot)
 
 function [q, s] = qqplot (x, dist, varargin)
 
   if (nargin < 1)
     print_usage ();
   endif
 
-  if (!(isnumeric (x) && isvector(x)))
+  if (!(isnumeric (x) && isvector (x)))
     error ("qqplot: X must be a numeric vector");
   endif
 
   if (nargin == 1)
     f = @stdnormal_inv;
   else
     if (   exist (invname = sprintf ("%sinv", dist))
         || exist (invname = sprintf ("%s_inv", dist)))
diff --git a/scripts/statistics/base/quantile.m b/scripts/statistics/base/quantile.m
--- a/scripts/statistics/base/quantile.m
+++ b/scripts/statistics/base/quantile.m
@@ -126,17 +126,17 @@ function q = quantile (x, p = [], dim = 
   endif
 
   if (!(isscalar (dim) && dim == fix (dim))
       || !(1 <= dim && dim <= ndims (x)))
     error ("quantile: DIM must be an integer and a valid dimension");
   endif
 
   ## Set the permutation vector.
-  perm = 1:ndims(x);
+  perm = 1:ndims (x);
   perm(1) = dim;
   perm(dim) = 1;
 
   ## Permute dim to the 1st index.
   x = permute (x, perm);
 
   ## Save the size of the permuted x N-d array.
   sx = size (x);
diff --git a/scripts/statistics/base/ranks.m b/scripts/statistics/base/ranks.m
--- a/scripts/statistics/base/ranks.m
+++ b/scripts/statistics/base/ranks.m
@@ -49,17 +49,17 @@ function y = ranks (x, dim)
   else
     if (!(isscalar (dim) && dim == fix (dim))
         || !(1 <= dim && dim <= nd))
       error ("ranks: DIM must be an integer and a valid dimension");
     endif
   endif
 
   if (sz(dim) == 1)
-    y = ones(sz);
+    y = ones (sz);
   else
     ## The algorithm works only on dim = 1, so permute if necesary.
     if (dim != 1)
       perm = [1 : nd];
       perm(1) = dim;
       perm(dim) = 1;
       x = permute (x, perm);
     endif
@@ -68,17 +68,17 @@ function y = ranks (x, dim)
     [xs, xi] = sort (x);
     eq_el = find (diff ([xs; infvec]) == 0);
     if (isempty (eq_el))
       [eq_el, y] = sort (xi);
     else
       runs = setdiff (eq_el, eq_el+1);
       len = diff (find (diff ([Inf; eq_el; -Inf]) != 1)) + 1;
       [eq_el, y] = sort (xi);
-      for i = 1 : length(runs)
+      for i = 1 : length (runs)
         y (xi (runs (i) + [0:(len(i)-1)]) + floor (runs (i) ./ sz(1))
            * sz(1)) = eq_el(runs(i)) + (len(i) - 1) / 2;
       endfor
     endif
     if (dim != 1)
       y = permute (y, perm);
     endif
   endif
diff --git a/scripts/statistics/base/zscore.m b/scripts/statistics/base/zscore.m
--- a/scripts/statistics/base/zscore.m
+++ b/scripts/statistics/base/zscore.m
@@ -47,18 +47,18 @@ function [z, mu, sigma] = zscore (x, opt
 
   if (! (isnumeric (x) || islogical (x)))
     error ("zscore: X must be a numeric vector or matrix");
   endif
 
   if (nargin < 2)
     opt = 0;
   else
-    if (opt != 0 && opt != 1 || ! isscalar(opt))
-      error("zscore: OPT must be empty, 0, or 1");
+    if (opt != 0 && opt != 1 || ! isscalar (opt))
+      error ("zscore: OPT must be empty, 0, or 1");
     endif
   endif
 
   nd = ndims (x);
   sz = size (x);
   if (nargin < 3)
     ## Find the first non-singleton dimension.
     (dim = find (sz > 1, 1)) || (dim = 1);
diff --git a/scripts/statistics/models/private/logistic_regression_likelihood.m b/scripts/statistics/models/private/logistic_regression_likelihood.m
--- a/scripts/statistics/models/private/logistic_regression_likelihood.m
+++ b/scripts/statistics/models/private/logistic_regression_likelihood.m
@@ -30,14 +30,14 @@
 function [g, g1, p, dev] = logistic_regression_likelihood (y, x, beta, z, z1)
 
   if (nargin != 5)
     print_usage ();
   endif
 
   e = exp ([z, x] * beta); e1 = exp ([z1, x] * beta);
   g = e ./ (1 + e); g1 = e1 ./ (1 + e1);
-  g = max (y == max (y), g); g1 = min (y > min(y), g1);
+  g = max (y == max (y), g); g1 = min (y > min (y), g1);
 
   p = g - g1;
   dev = -2 * sum (log (p));
 
 endfunction
diff --git a/scripts/statistics/tests/bartlett_test.m b/scripts/statistics/tests/bartlett_test.m
--- a/scripts/statistics/tests/bartlett_test.m
+++ b/scripts/statistics/tests/bartlett_test.m
@@ -56,12 +56,12 @@ function [pval, chisq, df] = bartlett_te
   f_tot = sum (f);
   v_tot = sum (f .* v) / f_tot;
   c     = 1 + (sum (1 ./ f) - 1 / f_tot) / (3 * (k - 1));
   chisq = (f_tot * log (v_tot) - sum (f .* log (v))) / c;
   df    = k;
   pval  = 1 - chi2cdf (chisq, df);
 
   if (nargout == 0)
-    printf("  pval: %g\n", pval);
+    printf ("  pval: %g\n", pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/chisquare_test_homogeneity.m b/scripts/statistics/tests/chisquare_test_homogeneity.m
--- a/scripts/statistics/tests/chisquare_test_homogeneity.m
+++ b/scripts/statistics/tests/chisquare_test_homogeneity.m
@@ -37,32 +37,32 @@
 ## Description: Chi-square test for homogeneity
 
 function [pval, chisq, df] = chisquare_test_homogeneity (x, y, c)
 
   if (nargin != 3)
     print_usage ();
   endif
 
-  if (! (isvector(x) && isvector(y) && isvector(c)))
+  if (! (isvector (x) && isvector (y) && isvector (c)))
     error ("chisquare_test_homogeneity: X, Y and C must be vectors");
   endif
   ## Now test c for strictly increasing entries
   df = length (c);
   if (any ((c(2 : df) - c(1 : (df - 1))) <= 0))
     error ("chisquare_test_homogeneity: C must be increasing");
   endif
 
   c     = [(reshape (c, 1, df)), Inf];
   l_x   = length (x);
   x     = reshape (x, l_x, 1);
   n_x   = sum (x * ones (1, df+1) < ones (l_x, 1) * c);
   l_y   = length (y);
   y     = reshape (y, l_y, 1);
-  n_y   = sum(y * ones (1, df+1) < ones (l_y, 1) * c);
+  n_y   = sum (y * ones (1, df+1) < ones (l_y, 1) * c);
   chisq = l_x * l_y * sum ((n_x/l_x - n_y/l_y).^2 ./ (n_x + n_y));
   pval  = 1 - chi2cdf (chisq, df);
 
   if (nargout == 0)
-    printf("  pval: %g\n", pval);
+    printf ("  pval: %g\n", pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/chisquare_test_independence.m b/scripts/statistics/tests/chisquare_test_independence.m
--- a/scripts/statistics/tests/chisquare_test_independence.m
+++ b/scripts/statistics/tests/chisquare_test_independence.m
@@ -42,12 +42,12 @@ function [pval, chisq, df] = chisquare_t
   df = (r - 1) * (s - 1);
   n = sum (sum (x));
   y = sum (x')' * sum (x) / n;
   x = (x - y) .^2 ./ y;
   chisq = sum (sum (x));
   pval  = 1 - chi2cdf (chisq, df);
 
   if (nargout == 0)
-    printf("  pval: %g\n", pval);
+    printf ("  pval: %g\n", pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/kolmogorov_smirnov_test.m b/scripts/statistics/tests/kolmogorov_smirnov_test.m
--- a/scripts/statistics/tests/kolmogorov_smirnov_test.m
+++ b/scripts/statistics/tests/kolmogorov_smirnov_test.m
@@ -23,17 +23,17 @@
 ## if F and G are the CDFs corresponding to the sample and dist,
 ## respectively, then the null is that F == G.
 ##
 ## The optional argument @var{params} contains a list of parameters of
 ## @var{dist}.  For example, to test whether a sample @var{x} comes from
 ## a uniform distribution on [2,4], use
 ##
 ## @example
-## kolmogorov_smirnov_test(x, "unif", 2, 4)
+## kolmogorov_smirnov_test (x, "unif", 2, 4)
 ## @end example
 ##
 ## @noindent
 ## @var{dist} can be any string for which a function @var{dist_cdf}
 ## that calculates the CDF of distribution @var{dist} exists.
 ##
 ## With the optional argument string @var{alt}, the alternative of
 ## interest can be selected.  If @var{alt} is @code{"!="} or
diff --git a/scripts/statistics/tests/run_test.m b/scripts/statistics/tests/run_test.m
--- a/scripts/statistics/tests/run_test.m
+++ b/scripts/statistics/tests/run_test.m
@@ -41,18 +41,18 @@ function [pval, chisq] = run_test (x)
       13568,   27139,   40721,  54281,  67852,  83685;
       18091,   36187,   54281,  72414,  90470, 111580;
       22615,   45234,   67852,  90470, 113262, 139476;
       27892,   55789,   83685, 111580, 139476, 172860];
 
   b = [1/6; 5/24; 11/120; 19/720; 29/5040; 1/840];
 
   n = rows (x);
-  r = run_count (x, 6) - n * b * ones (1, columns(x));
+  r = run_count (x, 6) - n * b * ones (1, columns (x));
 
   chisq = diag (r' * A * r)' / n;
   pval  = chi2cdf (chisq, 6);
 
   if (nargout == 0)
-    printf("pval: %g\n", pval);
+    printf ("pval: %g\n", pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/u_test.m b/scripts/statistics/tests/u_test.m
--- a/scripts/statistics/tests/u_test.m
+++ b/scripts/statistics/tests/u_test.m
@@ -61,17 +61,17 @@ function [pval, z] = u_test (x, y, alt)
 
   cdf  = stdnormal_cdf (z);
 
   if (nargin == 2)
     alt  = "!=";
   endif
 
   if (! ischar (alt))
-    error("u_test: ALT must be a string");
+    error ("u_test: ALT must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif (strcmp (alt, ">"))
     pval = cdf;
   elseif (strcmp (alt, "<"))
     pval = 1 - cdf;
   else
diff --git a/scripts/statistics/tests/wilcoxon_test.m b/scripts/statistics/tests/wilcoxon_test.m
--- a/scripts/statistics/tests/wilcoxon_test.m
+++ b/scripts/statistics/tests/wilcoxon_test.m
@@ -68,17 +68,17 @@ function [pval, z] = wilcoxon_test (x, y
 
   cdf = stdnormal_cdf (z);
 
   if (nargin == 2)
     alt = "!=";
   endif
 
   if (! ischar (alt))
-    error("wilcoxon_test: ALT must be a string");
+    error ("wilcoxon_test: ALT must be a string");
   elseif (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif (strcmp (alt, ">"))
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
     error ("wilcoxon_test: option %s not recognized", alt);
diff --git a/scripts/statistics/tests/z_test.m b/scripts/statistics/tests/z_test.m
--- a/scripts/statistics/tests/z_test.m
+++ b/scripts/statistics/tests/z_test.m
@@ -74,14 +74,14 @@ function [pval, z] = z_test (x, m, v, al
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
     error ("z_test: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
     s = cstrcat ("Z-test of mean(x) == %g against mean(x) %s %g,\n",
-                "with known var(x) == %g:\n",
-                "  pval = %g\n");
+                 "with known var(x) == %g:\n",
+                 "  pval = %g\n");
     printf (s, m, alt, m, v, pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/z_test_2.m b/scripts/statistics/tests/z_test_2.m
--- a/scripts/statistics/tests/z_test_2.m
+++ b/scripts/statistics/tests/z_test_2.m
@@ -43,17 +43,17 @@
 
 function [pval, z] = z_test_2 (x, y, v_x, v_y, alt)
 
   if ((nargin < 4) || (nargin > 5))
     print_usage ();
   endif
 
   if (! (isvector (x) && isvector (y)))
-    error("z_test_2: both X and Y must be vectors");
+    error ("z_test_2: both X and Y must be vectors");
   elseif (! (isscalar (v_x) && (v_x > 0)
              && isscalar (v_y) && (v_y > 0)))
     error ("z_test_2: both V_X and V_Y must be positive scalars");
   endif
 
   n_x  = length (x);
   n_y  = length (y);
   mu_x = sum (x) / n_x;
@@ -74,15 +74,15 @@ function [pval, z] = z_test_2 (x, y, v_x
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
     error ("z_test_2: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
     s = cstrcat ("Two-sample Z-test of mean(x) == mean(y) against ",
-                "mean(x) %s mean(y),\n",
-                "with known var(x) == %g and var(y) == %g:\n",
-                "  pval = %g\n");
+                 "mean(x) %s mean(y),\n",
+                 "with known var(x) == %g and var(y) == %g:\n",
+                 "  pval = %g\n");
     printf (s, alt, v_x, v_y, pval);
   endif
 
 endfunction
diff --git a/scripts/strings/bin2dec.m b/scripts/strings/bin2dec.m
--- a/scripts/strings/bin2dec.m
+++ b/scripts/strings/bin2dec.m
@@ -55,20 +55,20 @@ function d = bin2dec (s)
     print_usage ();
   endif
 
   d = base2dec (s, 2);
 
 endfunction
 
 
-%!assert(bin2dec ("0000"), 0)
-%!assert(bin2dec ("1110"), 14)
-%!assert(bin2dec ("11111111111111111111111111111111111111111111111111111"), 2^53-1)
-%!assert(bin2dec ({"1110", "1111"}), [14; 15])
+%!assert (bin2dec ("0000"), 0)
+%!assert (bin2dec ("1110"), 14)
+%!assert (bin2dec ("11111111111111111111111111111111111111111111111111111"), 2^53-1)
+%!assert (bin2dec ({"1110", "1111"}), [14; 15])
 %!assert (bin2dec ("1 0 1"), 5)
 %!assert (bin2dec (char ("1 0 1", "   1111")), [5; 15])
 
 %%Test input validation
 %!error bin2dec ()
 %!error bin2dec (1)
 %!error bin2dec ("1", 2)
 
diff --git a/scripts/strings/dec2base.m b/scripts/strings/dec2base.m
--- a/scripts/strings/dec2base.m
+++ b/scripts/strings/dec2base.m
@@ -156,12 +156,12 @@ endfunction
 %!error dec2base (1)
 %!error dec2base (1, 2, 3, 4)
 %!error dec2base ("A")
 %!error dec2base (2i)
 %!error dec2base (-1)
 %!error dec2base (1.1)
 %!error dec2base (1, "ABA")
 %!error dec2base (1, "A B")
-%!error dec2base (1, ones(2))
+%!error dec2base (1, ones (2))
 %!error dec2base (1, 1)
 %!error dec2base (1, 37)
 
diff --git a/scripts/strings/mat2str.m b/scripts/strings/mat2str.m
--- a/scripts/strings/mat2str.m
+++ b/scripts/strings/mat2str.m
@@ -36,17 +36,17 @@
 ## @example
 ## @group
 ## mat2str ([ -1/3 + i/7; 1/3 - i/7 ], [4 2])
 ##      @result{} "[-0.3333+0.14i;0.3333-0.14i]"
 ##
 ## mat2str ([ -1/3 +i/7; 1/3 -i/7 ], [4 2])
 ##      @result{} "[-0.3333+0i 0+0.14i;0.3333+0i -0-0.14i]"
 ##
-## mat2str (int16([1 -1]), "class")
+## mat2str (int16 ([1 -1]), "class")
 ##      @result{} "int16([1 -1])"
 ##
 ## mat2str (logical (eye (2)))
 ##      @result{} "[true false;false true]"
 ##
 ## isequal (x, eval (mat2str (x)))
 ##      @result{} 1
 ## @end group
@@ -138,10 +138,10 @@ endfunction
 %!assert (mat2str (true), "true")
 %!assert (mat2str (false), "false")
 %!assert (mat2str (logical (eye (2))), "[true false;false true]")
 
 %% Test input validation
 %!error mat2str ()
 %!error mat2str (1,2,3,4)
 %!error mat2str (["Hello"])
-%!error <X must be two dimensional> mat2str (ones(3,3,2))
+%!error <X must be two dimensional> mat2str (ones (3,3,2))
 
diff --git a/scripts/strings/strcat.m b/scripts/strings/strcat.m
--- a/scripts/strings/strcat.m
+++ b/scripts/strings/strcat.m
@@ -138,13 +138,13 @@ endfunction
 
 ## test for scalar strings with vector strings
 %!assert (strcat (["a"; "b"], "c"), ["ac"; "bc"])
 
 ## test with cells with strings of differing lengths
 %!assert (all (strcmp (strcat ({"a", "bb"}, "ccc"), {"accc", "bbccc"})))
 %!assert (all (strcmp (strcat ("a", {"bb", "ccc"}), {"abb", "accc"})))
 
-%!assert (strcat (1, 2), strcat (char(1), char(2)))
-%!assert (strcat ("", 2), strcat ([], char(2)))
+%!assert (strcat (1, 2), strcat (char (1), char (2)))
+%!assert (strcat ("", 2), strcat ([], char (2)))
 
 %!error strcat ()
 
diff --git a/scripts/strings/strchr.m b/scripts/strings/strchr.m
--- a/scripts/strings/strchr.m
+++ b/scripts/strings/strchr.m
@@ -48,17 +48,17 @@ function varargout = strchr (str, chars,
     mask = str == chars(1);
     for i = 2:length (chars)
       mask |= str == chars(i);
     endfor
   else
     ## Index the str into a mask of valid values.
     ## This is slower than it could be because of the +1 issue.
     f = false (256, 1);
-    f(uint8(chars)+1) = true;
+    f(uint8 (chars) + 1) = true;
     ## Default goes via double -- unnecessarily long.
     si = uint32 (str);
     ## in-place is faster than str+1
     ++si;
     mask = reshape (f(si), size (str));
   endif
 
   varargout = cell (1, nargout);
diff --git a/scripts/strings/strjust.m b/scripts/strings/strjust.m
--- a/scripts/strings/strjust.m
+++ b/scripts/strings/strjust.m
@@ -82,17 +82,17 @@ function y = strjust (s, pos = "right")
     mins = ones (nr, 1);
     mins(flipud (idx(:))) = flipud (jdx(:));
     maxs = repmat (nc, [nr, 1]);
     maxs(idx) = jdx;
     shift = floor ((nc + 1 - maxs - mins) / 2);
   endif
 
   ## Adjust the column indices.
-  jdx += shift(idx);
+  jdx += shift (idx);
 
   ## Create a blank matrix and position the nonblank characters.
   y = repmat (" ", nr, nc);
   y(sub2ind ([nr, nc], idx, jdx)) = s(nonbl);
 
 endfunction
 
 
diff --git a/scripts/strings/strtok.m b/scripts/strings/strtok.m
--- a/scripts/strings/strtok.m
+++ b/scripts/strings/strtok.m
@@ -70,17 +70,17 @@ function [tok, rem] = strtok (str, delim
       idx = str == delim(1);
       for i = 2:length (delim) 
         idx |= str == delim(i);
       endfor
     else
       ## Index the str into a mask of valid values.  Faster for large N.
       f = false (256, 1);
       ## This is slower than it could be because of the +1 issue.
-      f(uint8(delim)+1) = true;
+      f(uint8 (delim)+1) = true;
       ## Default goes via double -- unnecessarily long.
       si = uint32 (str);
       ## in-place is faster than str+1
       ++si;
       idx = f(si);
     endif
 
     idx_dlim = find (idx, 1);
@@ -141,17 +141,17 @@ endfunction
 %! while (1)
 %!   [t, s] = strtok (s, "+-*/");
 %!   printf ("<%s>", t);
 %!   if (isempty (s))
 %!     break;
 %!   endif
 %!   printf ("<%s>", s(1));
 %! endwhile
-%! printf("\n");
+%! printf ("\n");
 %! % ----------------------------------------------------
 %! % Demonstrates processing of an entire string split on
 %! % a variety of delimiters.  Tokens and delimiters are
 %! % printed one after another in angle brackets.
 
 %% Test the tokens for all cases
 %!assert (strtok (""), "");             # no string
 %!assert (strtok ("this"), "this");     # no delimiter in string
diff --git a/scripts/strings/substr.m b/scripts/strings/substr.m
--- a/scripts/strings/substr.m
+++ b/scripts/strings/substr.m
@@ -98,16 +98,16 @@ endfunction
 %!assert (substr ("This is a test string", -11, -7), "test")
 %!assert (substr ("This is a test string", 1, -7), "This is a test")
 %!assert (isempty (substr ("This is a test string", 1, 0)))
 
 %% Test input validation
 %!error substr ()
 %!error substr ("foo", 2, 3, 4)
 %!error substr (ones (5, 1), 1, 1)
-%!error substr ("foo", ones(2,2))
-%!error substr ("foo", 1, ones(2,2))
+%!error substr ("foo", ones (2,2))
+%!error substr ("foo", 1, ones (2,2))
 %!error substr ("foo", 0)
 %!error substr ("foo", 5)
 %!error substr ("foo", 1, 5)
 %!error substr ("foo", -1, 5)
 %!error substr ("foo", 2, -5)
 
diff --git a/scripts/strings/untabify.m b/scripts/strings/untabify.m
--- a/scripts/strings/untabify.m
+++ b/scripts/strings/untabify.m
@@ -77,20 +77,20 @@ function s = replace_tabs (t, tw)
   endif
 
   if (isempty (t))
     s = t;
   else
     nr = rows (t);
     sc = cell (nr, 1);
     for j = 1:nr
-      n = 1:numel(t(j,:));
+      n = 1:numel (t(j,:));
       m = find (t(j,:) == "\t");
       t(j,m) = " ";
-      for i = 1:numel(m)
+      for i = 1:numel (m)
         k = tw * ceil (n(m(i)) / tw);
         dn = k - n(m(i));
         n(m(i):end) += dn;
       endfor
       sc{j} = blanks (n(end));
       sc{j}(n) = t(j,:);
     endfor
     s = char (sc);
diff --git a/scripts/testfun/assert.m b/scripts/testfun/assert.m
--- a/scripts/testfun/assert.m
+++ b/scripts/testfun/assert.m
@@ -38,20 +38,20 @@
 ## Produce an error if observed is not the same as expected.  Note that
 ## @var{observed} and @var{expected} can be scalars, vectors, matrices,
 ## strings, cell arrays, or structures.
 ##
 ## @item assert (@var{observed}, @var{expected}, @var{tol})
 ## Produce an error if observed is not the same as expected but equality
 ## comparison for numeric data uses a tolerance @var{tol}.
 ## If @var{tol} is positive then it is an absolute tolerance which will produce
-## an error if @code{abs(@var{observed} - @var{expected}) > abs(@var{tol})}.
+## an error if @code{abs (@var{observed} - @var{expected}) > abs (@var{tol})}.
 ## If @var{tol} is negative then it is a relative tolerance which will produce
-## an error if @code{abs(@var{observed} - @var{expected}) >
-## abs(@var{tol} * @var{expected})}.  If @var{expected} is zero @var{tol} will
+## an error if @code{abs (@var{observed} - @var{expected}) >
+## abs (@var{tol} * @var{expected})}.  If @var{expected} is zero @var{tol} will
 ## always be interpreted as an absolute tolerance.
 ## @end table
 ## @seealso{test, fail, error}
 ## @end deftypefn
 
 ## FIXME: Output throttling: don't print out the entire 100x100 matrix,
 ## but instead give a summary; don't print out the whole list, just
 ## say what the first different element is, etc.  To do this, make
@@ -244,19 +244,19 @@ endfunction
 %!error assert (zeros (3,0), zeros (0,2))
 %!error assert (zeros (3,0), [])
 %!error <Dimensions don't match> assert (zeros (2,0,2), zeros (2,0))
 
 ## conditions
 %!assert (isempty ([]))
 %!assert (1)
 %!error assert (0)
-%!assert (ones(3,1))
-%!assert (ones(1,3))
-%!assert (ones(3,4))
+%!assert (ones (3,1))
+%!assert (ones (1,3))
+%!assert (ones (3,4))
 %!error assert ([1,0,1])
 %!error assert ([1;1;0])
 %!error assert ([1,0;1,1])
 
 ## scalars
 %!error assert (3, [3,3; 3,3])
 %!error assert ([3,3; 3,3], 3)
 %!assert (3, 3)
diff --git a/scripts/testfun/demo.m b/scripts/testfun/demo.m
--- a/scripts/testfun/demo.m
+++ b/scripts/testfun/demo.m
@@ -60,17 +60,17 @@
 ## between the sections, but this is discouraged.  Other techniques
 ## to avoid multiple initialization blocks include using multiple plots
 ## with a new @code{figure} command between each plot, or using @code{subplot}
 ## to put multiple plots in the same window.
 ##
 ## Also, because demo evaluates within a function context, you cannot
 ## define new functions inside a demo.  If you must have function blocks,
 ## rather than just anonymous functions or inline functions, you will have to
-## use @code{eval(example("function",n))} to see them.  Because eval only
+## use @code{eval (example ("function",n))} to see them.  Because eval only
 ## evaluates one line, or one statement if the statement crosses
 ## multiple lines, you must wrap your demo in "if 1 <demo stuff> endif"
 ## with the 'if' on the same line as 'demo'.  For example:
 ##
 ## @example
 ## @group
 ## %!demo if 1
 ## %!  function y=f(x)
@@ -107,17 +107,17 @@ function demo (name, n)
   elseif (n >= length (idx))
     warning ("only %d demos available for %s", length (idx) - 1, name);
     return;
   endif
 
   if (n > 0)
     doidx = n;
   else
-    doidx = 1:length(idx)-1;
+    doidx = 1:(length (idx) - 1);
   endif
   for i = 1:length (doidx)
     ## Pause between demos
     if (i > 1)
       input ("Press <enter> to continue: ", "s");
     endif
 
     ## Process each demo without failing
diff --git a/scripts/testfun/example.m b/scripts/testfun/example.m
--- a/scripts/testfun/example.m
+++ b/scripts/testfun/example.m
@@ -60,23 +60,23 @@ function [code_r, idx_r] = example (name
     else
       code_r = code;
       idx_r = idx;
     endif
   else
     if (n > 0)
       doidx = n;
     else
-      doidx = 1:length(idx)-1;
+      doidx = 1:length (idx) - 1;
     endif
     if (isempty (idx))
       warning ("no example available for %s", name);
       return;
-    elseif (n >= length(idx))
-      warning ("only %d examples available for %s", length(idx)-1, name);
+    elseif (n >= length (idx))
+      warning ("only %d examples available for %s", length (idx) - 1, name);
       return;
     endif
 
     for i = 1:length (doidx)
       block = code(idx(doidx(i)):idx(doidx(i)+1)-1);
       printf ("%s example %d:%s\n\n", name, doidx(i), block);
     endfor
   endif
diff --git a/scripts/testfun/fail.m b/scripts/testfun/fail.m
--- a/scripts/testfun/fail.m
+++ b/scripts/testfun/fail.m
@@ -39,17 +39,17 @@
 ##           expected <pattern>
 ##           but got <text of actual error>
 ## @end group
 ## @end example
 ##
 ## The angle brackets are not part of the output.
 ##
 ## Called with three arguments, the behavior is similar to
-## @code{fail(@var{code}, @var{pattern})}, but produces an error if no
+## @code{fail (@var{code}, @var{pattern})}, but produces an error if no
 ## warning is given during code execution or if the code fails.
 ## @seealso{assert}
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 
 function ret = fail (code, pattern, warning_pattern)
 
@@ -65,32 +65,32 @@ function ret = fail (code, pattern, warn
     pattern = "";
   endif
 
   ## match any nonempty message
   if (isempty (pattern))
     pattern = ".";
   endif
 
-  ## allow assert(fail())
+  ## allow assert (fail ())
   if (nargout)
     ret = 1;
   endif
 
   if (test_warning)
     ## Perform the warning test.
     ## Clear old warnings.
     lastwarn ();
     ## Make sure warnings are turned on.
     state = warning ("query", "quiet");
     warning ("on", "quiet");
     try
-      ## printf("lastwarn before %s: %s\n",code,lastwarn);
+      ## printf ("lastwarn before %s: %s\n",code,lastwarn);
       evalin ("caller", sprintf ("%s;", code));
-      ## printf("lastwarn after %s: %s\n",code,lastwarn);
+      ## printf ("lastwarn after %s: %s\n",code,lastwarn);
       ## Retrieve new warnings.
       err = lastwarn ();
       warning (state.state, "quiet");
       if (isempty (err))
         msg = sprintf ("expected warning <%s> but got none", pattern);
       else
         ## Transform "warning: ...\n" to "...".
         err([1:9, end]) = [];
@@ -126,20 +126,20 @@ function ret = fail (code, pattern, warn
 
   ## If we get here, then code didn't fail or error didn't match.
   error (msg);
 
 endfunction
 
 
 %!fail ("[1,2]*[2,3]", "nonconformant")
-%!fail ("fail('[1,2]*[2;3]', 'nonconformant')", "expected error <nonconformant> but got none")
-%!fail ("fail('[1,2]*[2,3]','usage:')", "expected error <usage:>\nbut got.*nonconformant")
-%!fail ("warning('test warning')", "warning", "test warning");
+%!fail ("fail ('[1,2]*[2;3]', 'nonconformant')", "expected error <nonconformant> but got none")
+%!fail ("fail ('[1,2]*[2,3]', 'usage:')", "expected error <usage:>\nbut got.*nonconformant")
+%!fail ("warning ('test warning')", "warning", "test warning");
 
-##% !fail ("warning('next test')",'warning','next test');  ## only allowed one warning test?!?
+##% !fail ("warning ('next test')",'warning','next test');  ## only allowed one warning test?!?
 
 %% Test that fail() itself will generate an error
 %!error fail ("1")
 %!error <undefined> fail ("a*[2;3]", "nonconformant")
 %!error <expected error>  fail ("a*[2,3]", "usage:")
-%!error <warning failure> fail ("warning('warning failure')", "warning", "success")
+%!error <warning failure> fail ("warning ('warning failure')", "warning", "success")
 
diff --git a/scripts/testfun/speed.m b/scripts/testfun/speed.m
--- a/scripts/testfun/speed.m
+++ b/scripts/testfun/speed.m
@@ -318,23 +318,23 @@ function [__order, __test_n, __tnew, __t
     order = round (10*p(1))/10;
     if (order >= 0.1)
       order = sprintf ("O(n^%g)", order);
     else
       order = "O(1)";
     endif
     v = polyval (p, log (__test_n(tailidx)));
 
-    loglog (__test_n(tailidx), exp(v)*1000, sprintf ("b;%s;", order));
+    loglog (__test_n(tailidx), exp (v) * 1000, sprintf ("b;%s;", order));
     title ({"Time Complexity", __f1});
     xlabel ("test length");
 
     ## Get base time to 1 digit of accuracy.
     dt = exp (p(2));
-    dt = floor (dt/10^floor(log10(dt)))*10^floor(log10(dt));
+    dt = floor (dt/10^floor (log10 (dt)))*10^floor (log10 (dt));
     if (log10 (dt) >= -0.5)
       time = sprintf ("%g s", dt);
     elseif (log10 (dt) >= -3.5)
       time = sprintf ("%g ms", dt*1e3);
     elseif (log10 (dt) >= -6.5)
       time = sprintf ("%g us", dt*1e6);
     else
       time = sprintf ("%g ns", dt*1e9);
@@ -374,17 +374,17 @@ endfunction
 %! disp (fstr_build);
 %! disp ("-----------------------");
 %!
 %! ## Eval functions strings to create them in the current context
 %! eval (fstr_build_orig);
 %! eval (fstr_build);
 %!
 %! disp ("Preallocated vector test.\nThis takes a little while...");
-%! speed("build (n)", "", 1000, "build_orig (n)");
+%! speed ("build (n)", "", 1000, "build_orig (n)");
 %! clear -f build build_orig
 %! disp ("-----------------------");
 %! disp ("Note how much faster it is to pre-allocate a vector.");
 %! disp ("Notice the peak speedup ratio.");
 
 %!demo
 %! fstr_build_orig = cstrcat (
 %!   "function x = build_orig (n)\n",
@@ -403,17 +403,17 @@ endfunction
 %! disp (fstr_build);
 %! disp ("-----------------------");
 %!
 %! ## Eval functions strings to create them in the current context
 %! eval (fstr_build_orig);
 %! eval (fstr_build);
 %!
 %! disp ("Vectorized test.\nThis takes a little while...");
-%! speed("build (n)", "", 1000, "build_orig (n)");
+%! speed ("build (n)", "", 1000, "build_orig (n)");
 %! clear -f build build_orig
 %! disp ("-----------------------");
 %! disp ("This time, the for loop is done away with entirely.");
 %! disp ("Notice how much bigger the speedup is than in example 1.");
 
 %!test
 %! [order, n, T_f1, T_f2] = speed ("airy (x)", "x = rand (n, 10)", [100, 1000]);
 %! assert (isstruct (order));
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -140,17 +140,17 @@ function [__ret1, __ret2, __ret3, __ret4
     fprintf (__fid, "# %s code for the test\n", __signal_block);
     fprintf (__fid, "# Search for the unexpected results in the file\n");
     fprintf (__fid, "# then page back to find the file name which caused it.\n");
     fprintf (__fid, "# The result may be an unexpected failure (in which\n");
     fprintf (__fid, "# case an error will be reported) or an unexpected\n");
     fprintf (__fid, "# success (in which case no error will be reported).\n");
     fflush (__fid);
     if (__close_fid)
-      fclose(__fid);
+      fclose (__fid);
     endif
     return;
   else
     error ("test: unknown flag '%s'", __flag);
   endif
 
   ## Locate the file to test.
   __file = file_in_loadpath (__name, "all");
@@ -179,17 +179,17 @@ function [__ret1, __ret2, __ret3, __ret4
         fprintf (__fid, "%s%s does not exist in path\n", __signal_empty, __name);
       endif
       fflush (__fid);
       if (nargout > 0)
         __ret1 = __ret2 = 0;
       endif
     endif
     if (__close_fid)
-      fclose(__fid);
+      fclose (__fid);
     endif
     return;
   endif
 
   ## Grab the test code from the file.
   __body = __extract_test_code (__file);
 
   if (isempty (__body))
@@ -199,22 +199,22 @@ function [__ret1, __ret2, __ret3, __ret4
     else
       fprintf (__fid, "%s%s has no tests available\n", __signal_empty, __file);
       fflush (__fid);
       if (nargout > 0)
         __ret1 = __ret2 = 0;
       endif
     endif
     if (__close_fid)
-      fclose(__fid);
+      fclose (__fid);
     endif
     return;
   else
     ## Add a dummy comment block to the end for ease of indexing.
-    if (__body (length(__body)) == "\n")
+    if (__body (length (__body)) == "\n")
       __body = sprintf ("\n%s#", __body);
     else
       __body = sprintf ("\n%s\n#", __body);
     endif
   endif
 
   ## Chop it up into blocks for evaluation.
   __lineidx = find (__body == "\n");
@@ -228,17 +228,17 @@ function [__ret1, __ret2, __ret3, __ret4
   ## Assume all tests will pass.
   __all_success = 1;
 
   ## Process each block separately, initially with no shared variables.
   __tests = __successes = 0;
   __shared = " ";
   __shared_r = " ";
   __clear = "";
-  for __i = 1:length(__blockidx)-1
+  for __i = 1:length (__blockidx)-1
 
     ## Extract the block.
     __block = __body(__blockidx(__i):__blockidx(__i+1)-2);
 
     ## Let the user/logfile know what is happening.
     if (__verbose)
       fprintf (__fid, "%s%s\n", __signal_block, __block);
       fflush (__fid);
@@ -246,17 +246,17 @@ function [__ret1, __ret2, __ret3, __ret4
 
     ## Split __block into __type and __code.
     __idx = find (! isletter (__block));
     if (isempty (__idx))
       __type = __block;
       __code = "";
     else
       __type = __block(1:__idx(1)-1);
-      __code = __block(__idx(1):length(__block));
+      __code = __block(__idx(1):length (__block));
     endif
 
     ## Assume the block will succeed.
     __success = 1;
     __msg = [];
 
 ### DEMO
 
@@ -265,21 +265,21 @@ function [__ret1, __ret2, __ret3, __ret4
     ## this __grabdemo mode, the demo block processor grabs all block
     ## types and skips those which aren't demo blocks.
 
     __isdemo = strcmp (__type, "demo");
     if (__grabdemo || __isdemo)
       __istest = 0;
 
       if (__grabdemo && __isdemo)
-        if (isempty(__demo_code))
+        if (isempty (__demo_code))
           __demo_code = __code;
           __demo_idx = [1, length(__demo_code)+1];
         else
-          __demo_code = cstrcat(__demo_code, __code);
+          __demo_code = cstrcat (__demo_code, __code);
           __demo_idx = [__demo_idx, length(__demo_code)+1];
         endif
 
       elseif (__rundemo && __isdemo)
         try
           ## process the code in an environment without variables
           eval (sprintf ("function __test__ ()\n%s\nendfunction", __code));
           __test__;
@@ -301,17 +301,17 @@ function [__ret1, __ret2, __ret3, __ret4
 
       ## Separate initialization code from variables.
       __idx = find (__code == "\n");
       if (isempty (__idx))
         __vars = __code;
         __code = "";
       else
         __vars = __code (1:__idx(1)-1);
-        __code = __code (__idx(1):length(__code));
+        __code = __code (__idx(1):length (__code));
       endif
 
       ## Strip comments off the variables.
       __idx = find (__vars == "%" | __vars == "#");
       if (! isempty (__idx))
         __vars = __vars(1:__idx(1)-1);
       endif
 
@@ -349,17 +349,17 @@ function [__ret1, __ret2, __ret3, __ret4
       if (isempty (__name_position))
         __success = 0;
         __msg = sprintf ("%stest failed: missing function name\n",
                          __signal_fail);
       else
         __name = __block(__name_position(1):__name_position(2));
         __code = __block;
         try
-          eval(__code); ## Define the function
+          eval (__code); ## Define the function
           __clear = sprintf ("%sclear %s;\n", __clear, __name);
         catch
           __success = 0;
           __msg = sprintf ("%stest failed: syntax error\n%s",
                            __signal_fail, lasterr ());
         end_try_catch
       endif
       __code = "";
@@ -377,17 +377,17 @@ function [__ret1, __ret2, __ret3, __ret4
     elseif (strcmp (__type, "assert") || strcmp (__type, "fail"))
       __istest = 1;
       ## Put the keyword back on the code.
       __code = __block;
       ## The code will be evaluated below as a test block.
 
 ### ERROR/WARNING
 
-    elseif (strcmp (__type, "error") || strcmp(__type, "warning"))
+    elseif (strcmp (__type, "error") || strcmp (__type, "warning"))
       __istest = 1;
       __warning = strcmp (__type, "warning");
       [__pattern, __id, __code] = getpattern (__code);
       if (__id)
         __patstr = ["id=",__id];
       else
         __patstr = ["<",__pattern,">"];
       endif
@@ -542,17 +542,17 @@ function [__ret1, __ret2, __ret3, __ret4
     if (__success == 0)
       __all_success = 0;
       ## Stop after one error if not in batch mode.
       if (! __batch)
         if (nargout > 0)
           __ret1 = __ret2 = 0;
         endif
         if (__close_fid)
-          fclose(__fid);
+          fclose (__fid);
         endif
         return;
       endif
     endif
     __tests += __istest;
     __successes += __success * __istest;
   endfor
   eval (__clear, "");
@@ -639,17 +639,17 @@ function msg = trimerr (msg, prefix)
     msg(1:idx+length(prefix)) = [];
   endif
   msg = trimleft (deblank (msg));
 endfunction
 
 ## Strip leading blanks from string.
 function str = trimleft (str)
   idx = find (isspace (str));
-  leading = find (idx == 1:length(idx));
+  leading = find (idx == 1:length (idx));
   if (! isempty (leading))
     str = str(leading(end)+1:end);
   endif
 endfunction
 
 ## Make a structure out of the named variables
 ## (based on Etienne Grossmann's tar function).
 function s = bundle (varargin)
@@ -661,56 +661,56 @@ endfunction
 function body = __extract_test_code (nm)
   fid = fopen (nm, "rt");
   body = [];
   if (fid >= 0)
     while (! feof (fid))
       ln = fgetl (fid);
       if (length (ln) >= 2 && strcmp (ln(1:2), "%!"))
         body = [body, "\n"];
-        if (length(ln) > 2)
+        if (length (ln) > 2)
           body = cstrcat (body, ln(3:end));
         endif
       endif
     endwhile
     fclose (fid);
   endif
 endfunction
 
 ### Test for test for missing features
 %!testif OCTAVE_SOURCE
 %! ## This test should be run
 %! assert (true);
 
 ### Disable this test to avoid spurious skipped test for "make check"
 % !testif HAVE_FOOBAR
 % ! ## missing feature. Fail if this test is run
-% ! error("Failed missing feature test");
+% ! error ("Failed missing feature test");
 
 ### Test for a known failure
-%!xtest error("This test is known to fail")
+%!xtest error ("This test is known to fail")
 
 ### example from toeplitz
 %!shared msg1,msg2
 %! msg1="C must be a vector";
 %! msg2="C and R must be vectors";
-%!fail ('toeplitz([])', msg1);
-%!fail ('toeplitz([1,2;3,4])', msg1);
-%!fail ('toeplitz([1,2],[])', msg2);
-%!fail ('toeplitz([1,2],[1,2;3,4])', msg2);
+%!fail ('toeplitz ([])', msg1);
+%!fail ('toeplitz ([1,2;3,4])', msg1);
+%!fail ('toeplitz ([1,2],[])', msg2);
+%!fail ('toeplitz ([1,2],[1,2;3,4])', msg2);
 %!fail ('toeplitz ([1,2;3,4],[1,2])', msg2);
 % !fail ('toeplitz','usage: toeplitz'); # usage doesn't generate an error
-% !fail ('toeplitz(1, 2, 3)', 'usage: toeplitz');
+% !fail ('toeplitz (1, 2, 3)', 'usage: toeplitz');
 %!test  assert (toeplitz ([1,2,3], [1,4]), [1,4; 2,1; 3,2]);
 %!demo  toeplitz ([1,2,3,4],[1,5,6])
 
 ### example from kron
 %!#error kron  # FIXME suppress these until we can handle output
 %!#error kron(1,2,3)
-%!test assert (isempty (kron ([], rand(3, 4))))
+%!test assert (isempty (kron ([], rand (3, 4))))
 %!test assert (isempty (kron (rand (3, 4), [])))
 %!test assert (isempty (kron ([], [])))
 %!shared A, B
 %!test
 %! A = [1, 2, 3; 4, 5, 6];
 %! B = [1, -1; 2, -2];
 %!assert (size (kron (zeros (3, 0), A)), [ 3*rows(A), 0 ])
 %!assert (size (kron (zeros (0, 3), A)), [ 0, 3*columns(A) ])
@@ -724,89 +724,89 @@ endfunction
 %!assert (kron ([1, 2; 3, 4], A), [ A, 2*A; 3*A, 4*A ])
 %!test
 %! res = [1,-1,2,-2,3,-3; 2,-2,4,-4,6,-6; 4,-4,5,-5,6,-6; 8,-8,10,-10,12,-12];
 %! assert (kron (A, B), res)
 
 ### an extended demo from specgram
 %!#demo
 %! ## Speech spectrogram
-%! [x, Fs] = auload(file_in_loadpath("sample.wav")); # audio file
-%! step = fix(5*Fs/1000);     # one spectral slice every 5 ms
-%! window = fix(40*Fs/1000);  # 40 ms data window
-%! fftn = 2^nextpow2(window); # next highest power of 2
-%! [S, f, t] = specgram(x, fftn, Fs, window, window-step);
-%! S = abs(S(2:fftn*4000/Fs,:)); # magnitude in range 0<f<=4000 Hz.
-%! S = S/max(max(S));         # normalize magnitude so that max is 0 dB.
-%! S = max(S, 10^(-40/10));   # clip below -40 dB.
-%! S = min(S, 10^(-3/10));    # clip above -3 dB.
-%! imagesc(flipud(20*log10(S)), 1);
+%! [x, Fs] = auload (file_in_loadpath ("sample.wav")); # audio file
+%! step = fix (5*Fs/1000);     # one spectral slice every 5 ms
+%! window = fix (40*Fs/1000);  # 40 ms data window
+%! fftn = 2^nextpow2 (window); # next highest power of 2
+%! [S, f, t] = specgram (x, fftn, Fs, window, window-step);
+%! S = abs (S (2:fftn*4000/Fs,:)); # magnitude in range 0<f<=4000 Hz.
+%! S = S/max(max(S));          # normalize magnitude so that max is 0 dB.
+%! S = max (S, 10^(-40/10));   # clip below -40 dB.
+%! S = min (S, 10^(-3/10));    # clip above -3 dB.
+%! imagesc (flipud (20*log10 (S)), 1);
 %! % you should now see a spectrogram in the image window
 
 
 ### now test test itself
 
 %!## usage and error testing
 % !fail ('test','usage.*test')           # no args, generates usage()
-% !fail ('test(1,2,3,4)','usage.*test')  # too many args, generates usage()
-%!fail ('test("test", "bogus")','unknown flag')      # incorrect args
+% !fail ('test (1,2,3,4)','usage.*test') # too many args, generates usage()
+%!fail ('test ("test", "bogus")','unknown flag')  # incorrect args
 %!fail ('garbage','garbage.*undefined')  # usage on nonexistent function should be
 
 %!error test                     # no args, generates usage()
-%!error test(1,2,3,4)            # too many args, generates usage()
-%!error <unknown flag> test("test", 'bogus');  # incorrect args, generates error()
+%!error test (1,2,3,4)           # too many args, generates usage()
+%!error <unknown flag> test ("test", 'bogus'); # incorrect args, generates error()
 %!error <garbage' undefined> garbage           # usage on nonexistent function should be
 
-%!error test("test", 'bogus');           # test without pattern
+%!error test ("test", 'bogus');  # test without pattern
 
 %!test
 %! lastwarn();            # clear last warning just in case
 
-%!warning <warning message> warning('warning message');
+%!warning <warning message> warning ('warning message');
 
 %!## test of shared variables
 %!shared a                # create a shared variable
 %!test   a=3;             # assign to a shared variable
-%!test   assert(a,3)      # variable should equal 3
+%!test   assert (a,3)     # variable should equal 3
 %!shared b,c              # replace shared variables
-%!test assert (!exist("a"));   # a no longer exists
-%!test assert (isempty(b));    # variables start off empty
+%!test assert (!exist ("a"));  # a no longer exists
+%!test assert (isempty (b));   # variables start off empty
 %!shared a,b,c            # recreate a shared variable
-%!test assert (isempty(a));    # value is empty even if it had a previous value
+%!test assert (isempty (a));   # value is empty even if it had a previous value
 %!test a=1; b=2; c=3;   # give values to all variables
 %!test assert ([a,b,c],[1,2,3]); # test all of them together
 %!test c=6;             # update a value
-%!test assert([a, b, c],[1, 2, 6]); # show that the update sticks
-%!shared                    # clear all shared variables
-%!test assert(!exist("a"))  # show that they are cleared
-%!shared a,b,c              # support for initializer shorthand
+%!test assert ([a, b, c],[1, 2, 6]); # show that the update sticks
+%!shared                     # clear all shared variables
+%!test assert (!exist ("a")) # show that they are cleared
+%!shared a,b,c               # support for initializer shorthand
 %! a=1; b=2; c=4;
 
-%!function x = __test_a(y)
+%!function x = __test_a (y)
 %! x = 2*y;
 %!endfunction
-%!assert(__test_a(2),4);       # Test a test function
+%!assert (__test_a (2),4);       # Test a test function
 
 %!function __test_a (y)
 %! x = 2*y;
 %!endfunction
 %!test
-%! __test_a(2);                # Test a test function with no return value
+%! __test_a (2);                # Test a test function with no return value
 
 %!function [x,z] = __test_a (y)
 %! x = 2*y;
 %! z = 3*y;
 %!endfunction
 %!test                   # Test a test function with multiple returns
-%! [x,z] = __test_a(3);
-%! assert(x,6);
-%! assert(z,9);
+%! [x,z] = __test_a (3);
+%! assert (x,6);
+%! assert (z,9);
 
 %!## test of assert block
-%!assert (isempty([]))      # support for test assert shorthand
+%!assert (isempty ([]))      # support for test assert shorthand
 
 %!## demo blocks
 %!demo                   # multiline demo block
 %! t = [0:0.01:2*pi]; x = sin (t);
 %! plot (t,x);
 %! % you should now see a sine wave in your figure window
 %!demo a=3               # single line demo blocks work too
 
diff --git a/scripts/time/now.m b/scripts/time/now.m
--- a/scripts/time/now.m
+++ b/scripts/time/now.m
@@ -42,17 +42,17 @@ function t = now ()
   t = datenum (clock ());
 
   ## The following doesn't work (e.g., one hour off on 2005-10-04):
   ##
   ##   seconds since 1970-1-1 corrected by seconds from GMT to local time
   ##   divided by 86400 sec/day plus day num for 1970-1-1
   ##   t = (time - mktime(gmtime(0)))/86400 + 719529;
   ##
-  ## mktime(gmtime(0)) does indeed return the offset from Greenwich to the
+  ## mktime (gmtime (0)) does indeed return the offset from Greenwich to the
   ## local time zone, but we need to account for daylight savings time
   ## changing by an hour the offset from CUT for part of the year.
 
 endfunction
 
 
 %!assert (isnumeric (now ()))
 %!assert (now () > 0)
diff --git a/src/DLD-FUNCTIONS/qz.cc b/src/DLD-FUNCTIONS/qz.cc
--- a/src/DLD-FUNCTIONS/qz.cc
+++ b/src/DLD-FUNCTIONS/qz.cc
@@ -529,17 +529,17 @@ compatibility with @sc{matlab}.\n\
 
   // First, declare variables used in both the real and complex case.
   Matrix QQ(nn,nn), ZZ(nn,nn), VR(nn,nn), VL(nn,nn);
   RowVector alphar(nn), alphai(nn), betar(nn);
   ComplexRowVector xalpha(nn), xbeta(nn);
   ComplexMatrix CQ(nn,nn), CZ(nn,nn), CVR(nn,nn), CVL(nn,nn);
   octave_idx_type ilo, ihi, info;
   char compq = (nargout >= 3 ? 'V' : 'N');
-  char compz = (nargout >= 4 ? 'V' : 'N');
+  char compz = ((nargout >= 4 || nargin == 3)? 'V' : 'N');
 
   // Initialize Q, Z to identity if we need either of them.
   if (compq == 'V' || compz == 'V')
     for (octave_idx_type ii = 0; ii < nn; ii++)
       for (octave_idx_type jj = 0; jj < nn; jj++)
         {
           OCTAVE_QUIT;
           QQ(ii,jj) = ZZ(ii,jj) = (ii == jj ? 1.0 : 0.0);
@@ -1177,17 +1177,22 @@ compatibility with @sc{matlab}.\n\
           if (complex_case)
             retval(3) = CZ;
           else
             retval(3) = ZZ;
         }
 
     case 3:
       if (nargin == 3)
-        retval(2) = CZ;
+        {
+          if (complex_case)
+            retval(2) = CZ;
+          else
+            retval(2) = ZZ;
+        }
       else
         {
           if (complex_case)
             retval(2) = CQ.hermitian ();
           else
             retval(2) = QQ.transpose ();
         }
 
@@ -1259,10 +1264,15 @@ compatibility with @sc{matlab}.\n\
 %! sz = length (lambda);
 %! observed = (b * v * diag ([lambda;0])) (:, 1:sz);
 %! assert ( (a*v) (:, 1:sz), observed, norm (observed) * 1e-14);
 %! observed = (diag ([lambda;0]) * w' * b) (1:sz, :);
 %! assert ( (w'*a) (1:sz, :) , observed, norm (observed) * 1e-13);
 %! assert (q * a * z, aa, norm (aa) * 1e-14);
 %! assert (q * b * z, bb, norm (bb) * 1e-14);
 
-## FIXME: Still need a test for third form of calling qz
+%!test
+%! A = [0, 0, -1, 0; 1, 0, 0, 0; -1, 0, -2, -1; 0, -1, 1, 0];
+%! B = [0, 0, 0, 0; 0, 1, 0, 0; 0, 0, 1, 0; 0, 0, 0, 1];
+%! [AA, BB, Q, Z1] = qz (A, B);
+%! [AA, BB, Z2] = qz (A, B, '-');
+%! assert (Z1, Z2);
 */
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -1374,17 +1374,17 @@ which will result in the prompt @samp{bo
 @samp{boris} logged in on the host @samp{kremvax.kgb.su}.  Note that two\n\
 backslashes are required to enter a backslash into a double-quoted\n\
 character string.  @xref{Strings}.\n\
 \n\
 You can also use ANSI escape sequences if your terminal supports them.\n\
 This can be useful for coloring the prompt.  For example,\n\
 \n\
 @example\n\
-PS1 (\"\\\\[\\\\033[01;31m\\\\]\\\\s:\\\\#> \\\\[\\\\033[0m\\]\")\n\
+PS1 (\"\\\\[\\\\033[01;31m\\\\]\\\\s:\\\\#> \\\\[\\\\033[0m\\\\]\")\n\
 @end example\n\
 \n\
 @noindent\n\
 will give the default Octave prompt a red coloring.\n\
 \n\
 When called from inside a function with the \"local\" option, the variable is\n\
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
diff --git a/src/ov-usr-fcn.cc b/src/ov-usr-fcn.cc
--- a/src/ov-usr-fcn.cc
+++ b/src/ov-usr-fcn.cc
@@ -256,20 +256,20 @@ octave_user_function::mark_as_system_fcn
       // We probably also don't need to get the library directory
       // every time, but since this function is only called when the
       // function file is parsed, it probably doesn't matter that
       // much.
 
       std::string ff_name = fcn_file_in_path (file_name);
 
       if (Vfcn_file_dir == ff_name.substr (0, Vfcn_file_dir.length ()))
-        system_fcn_file = 1;
+        system_fcn_file = true;
     }
   else
-    system_fcn_file = 0;
+    system_fcn_file = false;
 }
 
 bool
 octave_user_function::takes_varargs (void) const
 {
   return (param_list && param_list->takes_varargs ());
 }
 
diff --git a/src/pt-id.cc b/src/pt-id.cc
--- a/src/pt-id.cc
+++ b/src/pt-id.cc
@@ -44,20 +44,22 @@ tree_identifier::eval_undefined_error (v
   int l = line ();
   int c = column ();
 
   maybe_missing_function_hook (name ());
   if (error_state)
     return;
 
   if (l == -1 && c == -1)
-    ::error ("`%s' undefined", name ().c_str ());
+    ::error_with_id ("Octave:undefined-function",
+                     "`%s' undefined", name ().c_str ());
   else
-    ::error ("`%s' undefined near line %d column %d",
-             name ().c_str (), l, c);
+    ::error_with_id ("Octave:undefined-function",
+                     "`%s' undefined near line %d column %d",
+                     name ().c_str (), l, c);
 }
 
 octave_value_list
 tree_identifier::rvalue (int nargout)
 {
   octave_value_list retval;
 
   if (error_state)
