# HG changeset patch
# User Jacob Dawid <jacob.dawid@googlemail.com>
# Date 1302301426 -7200
#      Sat Apr 09 00:23:46 2011 +0200
# Node ID 7519e2efaf31021cd0a4efc071b94aa9c4b76efe
# Parent  6fd5e06285da5dd8a9c76a0097e31e89e68a6e70
Incorporated files from OctaveDE project.

diff --git a/gui//Quint.pro b/gui//Quint.pro
--- a/gui//Quint.pro
+++ b/gui//Quint.pro
@@ -7,40 +7,44 @@
 QT       += core gui webkit
 UI_DIR = ui-files
 MOC_DIR = moc-files
 OBJECTS_DIR = object-files
 TARGET = Quint
 TEMPLATE = app
 DEFINES += HAVE_POSIX_OPENPT
 INCLUDEPATH += src
-DESTDIR = bin
+DESTDIR = ../Quint/bin
 SOURCES +=\
         src/TerminalCharacterDecoder.cpp \
         src/KeyboardTranslator.cpp \
         src/Screen.cpp \
         src/History.cpp \
         src/BlockArray.cpp \
         src/konsole_wcwidth.cpp \
         src/ScreenWindow.cpp \
         src/Emulation.cpp \
         src/Vt102Emulation.cpp \
         src/TerminalDisplay.cpp \
         src/Filter.cpp \
         src/Pty.cpp \
         src/kpty.cpp \
+        src/kptyprocess.cpp \
+        src/kprocess.cpp \
+        src/kptydevice.cpp \
         src/k3process.cpp \
         src/k3processcontroller.cpp \
         src/Session.cpp \
         src/ShellCommand.cpp \
         src/QTerminalWidget.cpp \
         src/TerminalMdiSubWindow.cpp \
         src/MainWindow.cpp \
         src/Quint.cpp \
-	src/OctaveLink.cpp
+        src/OctaveLink.cpp \
+        src/ProcessInfo.cpp
 
 HEADERS += \
         src/TerminalCharacterDecoder.h \
         src/Character.h \
         src/CharacterColor.h \
         src/KeyboardTranslator.h \
         src/ExtendedDefaultTranslator.h \
         src/Screen.h \
@@ -51,24 +55,32 @@ HEADERS += \
         src/Emulation.h \
         src/Vt102Emulation.h \
         src/TerminalDisplay.h \
         src/Filter.h \
         src/LineFont.h \
         src/Pty.h \
         src/kpty.h \
         src/kpty_p.h \
+        src/kptyprocess.h \
+        src/kprocess.h \
+        src/kprocess_p.h \
+        src/kptydevice.h \
         src/k3process.h \
         src/k3processcontroller.h \
         src/Session.h \
         src/ShellCommand.h \
         src/QTerminalWidget.h \
         src/TerminalMdiSubWindow.h \
     	src/MainWindow.h \
-	src/OctaveLink.h
+        src/OctaveLink.h \
+        src/konsole_export.h \
+        src/ProcessInfo.h \
+        src/kpty_export.h \
+        src/kdecore_export.h
 
 INCFLAGS = -g3 $$system(mkoctfile -p INCFLAGS)
 LFLAGS = $$system(mkoctfile -p LFLAGS) \
          $$system(mkoctfile -p OCTAVE_LIBS) \
          $$system(mkoctfile -p LIBS)
 LIBS    += $$LFLAGS -loctave -loctinterp -lreadline
 QMAKE_CXXFLAGS  += $$INCFLAGS
 
diff --git a/gui//src/BlockArray.cpp b/gui//src/BlockArray.cpp
--- a/gui//src/BlockArray.cpp
+++ b/gui//src/BlockArray.cpp
@@ -1,43 +1,45 @@
 /*
     This file is part of Konsole, an X terminal.
-    Copyright (C) 2000 by Stephan Kulow <coolo@kde.org>
-
-    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+    Copyright 2000 by Stephan Kulow <coolo@kde.org>
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
 
     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
 
     You should have received a copy of the GNU General Public License
     along with this program; if not, write to the Free Software
     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
     02110-1301  USA.
-
 */
 
 // Own
 #include "BlockArray.h"
 
-#include <QtCore>
-
 // System
 #include <assert.h>
 #include <sys/mman.h>
 #include <sys/param.h>
 #include <unistd.h>
 #include <stdio.h>
 
+// KDE
+//#include <kde_file.h>
+//#include <kdebug.h>
+
+#define KDE_fseek ::fseek
+#define KDE_lseek ::lseek
+
 static int blocksize = 0;
 
 BlockArray::BlockArray()
     : size(0),
       current(size_t(-1)),
       index(size_t(-1)),
       lastmap(0),
       lastmap_index(size_t(-1)),
@@ -60,17 +62,17 @@ size_t BlockArray::append(Block *block)
 {
     if (!size)
         return size_t(-1);
 
     ++current;
     if (current >= size) current = 0;
 
     int rc;
-    rc = lseek(ion, current * blocksize, SEEK_SET); if (rc < 0) { perror("HistoryBuffer::add.seek"); setHistorySize(0); return size_t(-1); }
+    rc = KDE_lseek(ion, current * blocksize, SEEK_SET); if (rc < 0) { perror("HistoryBuffer::add.seek"); setHistorySize(0); return size_t(-1); }
     rc = write(ion, block, blocksize); if (rc < 0) { perror("HistoryBuffer::add.write"); setHistorySize(0); return size_t(-1); }
 
     length++;
     if (length > size) length = size;
 
     ++index;
 
     delete block;
@@ -108,17 +110,17 @@ const Block* BlockArray::at(size_t i)
 {
     if (i == index + 1)
         return lastblock;
 
     if (i == lastmap_index)
         return lastmap;
 
     if (i > index) {
-        qDebug() << "BlockArray::at() i > index\n";
+        //kDebug(1211) << "BlockArray::at() i > index\n";
         return 0;
     }
     
 //     if (index - i >= length) {
 //         kDebug(1211) << "BlockArray::at() index - i >= length\n";
 //         return 0;
 //     }
 
@@ -192,33 +194,34 @@ bool BlockArray::setHistorySize(size_t n
     }
 
     if (newsize > size) {
         increaseBuffer();
         size = newsize;
         return false;
     } else {
         decreaseBuffer(newsize);
-        ftruncate(ion, length*blocksize);
+        if (ftruncate(ion, length*blocksize) == -1)
+            perror("ftruncate");
         size = newsize;
 
         return true;
     }
 }
 
 void moveBlock(FILE *fion, int cursor, int newpos, char *buffer2)
 {
-    int res = fseek(fion, cursor * blocksize, SEEK_SET);
+    int res = KDE_fseek(fion, cursor * blocksize, SEEK_SET);
     if (res)
         perror("fseek");
     res = fread(buffer2, blocksize, 1, fion);
     if (res != 1)
         perror("fread");
 
-    res = fseek(fion, newpos * blocksize, SEEK_SET);
+    res = KDE_fseek(fion, newpos * blocksize, SEEK_SET);
     if (res)
         perror("fseek");
     res = fwrite(buffer2, blocksize, 1, fion);
     if (res != 1)
         perror("fwrite");
     //    printf("moving block %d to %d\n", cursor, newpos);
 }
 
@@ -287,40 +290,40 @@ void BlockArray::increaseBuffer()
     if (size % offset == 0) {
         bpr = size / offset;
         runs = offset;
     }
 
     FILE *fion = fdopen(dup(ion), "w+b");
     if (!fion) {
         perror("fdopen/dup");
-	delete [] buffer1;
-	delete [] buffer2;
+    delete [] buffer1;
+    delete [] buffer2;
         return;
     }
 
     int res;
     for (int i = 0; i < runs; i++)
     {
         // free one block in chain
         int firstblock = (offset + i) % size;
-        res = fseek(fion, firstblock * blocksize, SEEK_SET);
+        res = KDE_fseek(fion, firstblock * blocksize, SEEK_SET);
         if (res)
             perror("fseek");
         res = fread(buffer1, blocksize, 1, fion);
         if (res != 1)
             perror("fread");
         int newpos = 0;
         for (int j = 1, cursor=firstblock; j < bpr; j++)
         {
             cursor = (cursor + offset) % size;
             newpos = (cursor - offset + size) % size;
             moveBlock(fion, cursor, newpos, buffer2);
         }
-        res = fseek(fion, i * blocksize, SEEK_SET);
+        res = KDE_fseek(fion, i * blocksize, SEEK_SET);
         if (res)
             perror("fseek");
         res = fwrite(buffer1, blocksize, 1, fion);
         if (res != 1)
             perror("fwrite");
     }
     current = size - 1;
     length = size;
diff --git a/gui//src/BlockArray.h b/gui//src/BlockArray.h
--- a/gui//src/BlockArray.h
+++ b/gui//src/BlockArray.h
@@ -1,13 +1,11 @@
 /*
     This file is part of Konsole, an X terminal.
-    Copyright (C) 2000 by Stephan Kulow <coolo@kde.org>
-   
-    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+    Copyright 2000 by Stephan Kulow <coolo@kde.org>
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
 
     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -30,16 +28,17 @@
 #define BlockSize (1 << 12)
 #define ENTRIES   ((BlockSize - sizeof(size_t) ) / sizeof(unsigned char))
 
 struct Block {
     Block() { size = 0; }
     unsigned char data[ENTRIES];
     size_t size;
 };
+
 // ///////////////////////////////////////////////////////
 
 class BlockArray {
 public:
     /**
     * Creates a history file for holding
     * maximal size blocks. If more blocks
     * are requested, then it drops earlier
@@ -49,17 +48,17 @@ public:
 
     /// destructor
     ~BlockArray();
 
     /**
     * adds the Block at the end of history.
     * This may drop other blocks.
     *
-    * The ownership on the block is transfered.
+    * The ownership on the block is transferred.
     * An unique index number is returned for accessing
     * it later (if not yet dropped then)
     *
     * Note, that the block may be dropped completely
     * if history is turned off.
     */
     size_t append(Block *block);
 
@@ -108,10 +107,11 @@ private:
     size_t index;
 
     Block *lastmap;
     size_t lastmap_index;
     Block *lastblock;
 
     int ion;
     size_t length;
+
 };
 #endif
diff --git a/gui//src/Character.h b/gui//src/Character.h
--- a/gui//src/Character.h
+++ b/gui//src/Character.h
@@ -1,15 +1,13 @@
 /*
     This file is part of Konsole, KDE's terminal.
     
-    Copyright (C) 2007 by Robert Knight <robertknight@gmail.com>
-    Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
-
-    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+    Copyright 2007-2008 by Robert Knight <robertknight@gmail.com>
+    Copyright 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
 
     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -28,20 +26,20 @@
 // Qt
 #include <QtCore/QHash>
 
 // Local
 #include "CharacterColor.h"
 
 typedef unsigned char LineProperty;
 
-static const int LINE_DEFAULT		= 0;
-static const int LINE_WRAPPED 	 	= (1 << 0);
-static const int LINE_DOUBLEWIDTH  	= (1 << 1);
-static const int LINE_DOUBLEHEIGHT	= (1 << 2);
+static const int LINE_DEFAULT        = 0;
+static const int LINE_WRAPPED          = (1 << 0);
+static const int LINE_DOUBLEWIDTH      = (1 << 1);
+static const int LINE_DOUBLEHEIGHT    = (1 << 2);
 
 #define DEFAULT_RENDITION  0
 #define RE_BOLD            (1 << 0)
 #define RE_BLINK           (1 << 1)
 #define RE_UNDERLINE       (1 << 2)
 #define RE_REVERSE         (1 << 3) // Screen only
 #define RE_INTENSIVE       (1 << 3) // Widget only
 #define RE_CURSOR          (1 << 4)
@@ -96,19 +94,24 @@ public:
    * it is drawn with the specified @p palette.
    */
   bool   isTransparent(const ColorEntry* palette) const;
   /**
    * Returns true if this character should always be drawn in bold when
    * it is drawn with the specified @p palette, independent of whether
    * or not the character has the RE_BOLD rendition flag. 
    */
-  bool   isBold(const ColorEntry* base) const;
+  ColorEntry::FontWeight fontWeight(const ColorEntry* base) const;
   
   /** 
+   * returns true if the format (color, rendition flag) of the compared characters is equal
+   */
+  bool equalsFormat(const Character &other) const;
+
+  /** 
    * Compares two characters and returns true if they have the same unicode character value,
    * rendition and colors.
    */
   friend bool operator == (const Character& a, const Character& b);
   /**
    * Compares two characters and returns true if they have different unicode character values,
    * renditions or colors.
    */
@@ -134,22 +137,32 @@ inline bool operator != (const Character
 inline bool Character::isTransparent(const ColorEntry* base) const
 {
   return ((backgroundColor._colorSpace == COLOR_SPACE_DEFAULT) && 
           base[backgroundColor._u+0+(backgroundColor._v?BASE_COLORS:0)].transparent)
       || ((backgroundColor._colorSpace == COLOR_SPACE_SYSTEM) && 
           base[backgroundColor._u+2+(backgroundColor._v?BASE_COLORS:0)].transparent);
 }
 
-inline bool Character::isBold(const ColorEntry* base) const
+inline bool Character::equalsFormat(const Character& other) const
 {
-  return ((backgroundColor._colorSpace == COLOR_SPACE_DEFAULT) &&
-            base[backgroundColor._u+0+(backgroundColor._v?BASE_COLORS:0)].bold)
-      || ((backgroundColor._colorSpace == COLOR_SPACE_SYSTEM) &&
-            base[backgroundColor._u+2+(backgroundColor._v?BASE_COLORS:0)].bold);
+  return 
+    backgroundColor==other.backgroundColor &&
+    foregroundColor==other.foregroundColor &&
+    rendition==other.rendition;
+}	
+
+inline ColorEntry::FontWeight Character::fontWeight(const ColorEntry* base) const
+{
+    if (backgroundColor._colorSpace == COLOR_SPACE_DEFAULT)
+        return base[backgroundColor._u+0+(backgroundColor._v?BASE_COLORS:0)].fontWeight;
+    else if (backgroundColor._colorSpace == COLOR_SPACE_SYSTEM)
+        return base[backgroundColor._u+2+(backgroundColor._v?BASE_COLORS:0)].fontWeight;
+    else
+        return ColorEntry::UseCurrentFormat;
 }
 
 extern unsigned short vt100_graphics[32];
 
 
 /**
  * A table which stores sequences of unicode characters, referenced
  * by hash keys.  The hash key itself is the same size as a unicode
@@ -196,10 +209,12 @@ private:
     // character sequence 'unicodePoints' of size 'length'
     bool extendedCharMatch(ushort hash , ushort* unicodePoints , ushort length) const;
     // internal, maps hash keys to character sequence buffers.  The first ushort
     // in each value is the length of the buffer, followed by the ushorts in the buffer
     // themselves.
     QHash<ushort,ushort*> extendedCharTable;
 };
 
+Q_DECLARE_TYPEINFO(Character, Q_MOVABLE_TYPE);
+
 #endif // CHARACTER_H
 
diff --git a/gui//src/CharacterColor.h b/gui//src/CharacterColor.h
--- a/gui//src/CharacterColor.h
+++ b/gui//src/CharacterColor.h
@@ -1,15 +1,13 @@
 /*
     This file is part of Konsole, KDE's terminal.
     
-    Copyright (C) 2007 by Robert Knight <robertknight@gmail.com>
-    Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
-
-    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+    Copyright 2007-2008 by Robert Knight <robertknight@gmail.com>
+    Copyright 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
 
     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -23,70 +21,88 @@
 */
 
 #ifndef CHARACTERCOLOR_H
 #define CHARACTERCOLOR_H
 
 // Qt
 #include <QtGui/QColor>
 
+//#include <kdemacros.h>
+#define KDE_NO_EXPORT
+
 /** 
  * An entry in a terminal display's color palette. 
  *
  * A color palette is an array of 16 ColorEntry instances which map
  * system color indexes (from 0 to 15) into actual colors.
  *
  * Each entry can be set as bold, in which case any text
  * drawn using the color should be drawn in bold.  
  *
  * Each entry can also be transparent, in which case the terminal
  * display should avoid drawing the background for any characters
  * using the entry as a background.
  */
 class ColorEntry
 {
 public:
+  /** Specifies the weight to use when drawing text with this color. */
+  enum FontWeight 
+  {
+    /** Always draw text in this color with a bold weight. */
+    Bold,
+    /** Always draw text in this color with a normal weight. */
+    Normal,
+    /** 
+     * Use the current font weight set by the terminal application.  
+     * This is the default behavior.
+     */
+    UseCurrentFormat
+  };
+
   /** 
    * Constructs a new color palette entry.
    *
    * @param c The color value for this entry.
    * @param tr Specifies that the color should be transparent when used as a background color.
-   * @param b Specifies that text drawn with this color should be bold.
+   * @param weight Specifies the font weight to use when drawing text with this color. 
    */
-  ColorEntry(QColor c, bool tr, bool b) : color(c), transparent(tr), bold(b) {}
+  ColorEntry(QColor c, bool tr, FontWeight weight = UseCurrentFormat) 
+          : color(c), transparent(tr), fontWeight(weight) {}
 
   /**
    * Constructs a new color palette entry with an undefined color, and
    * with the transparent and bold flags set to false.
    */ 
-  ColorEntry() : transparent(false), bold(false) {} 
+  ColorEntry() : transparent(false), fontWeight(UseCurrentFormat) {} 
  
   /**
    * Sets the color, transparency and boldness of this color to those of @p rhs.
    */ 
   void operator=(const ColorEntry& rhs) 
   { 
        color = rhs.color; 
        transparent = rhs.transparent; 
-       bold = rhs.bold; 
+       fontWeight = rhs.fontWeight; 
   }
 
   /** The color value of this entry for display. */
   QColor color;
 
   /** 
    * If true character backgrounds using this color should be transparent. 
    * This is not applicable when the color is used to render text.
    */
   bool   transparent;
   /**
-   * If true characters drawn using this color should be bold.
+   * Specifies the font weight to use when drawing text with this color. 
    * This is not applicable when the color is used to draw a character's background.
    */
-  bool   bold;        
+  FontWeight fontWeight;        
 };
 
 
 // Attributed Character Representations ///////////////////////////////
 
 // Colors
 
 #define BASE_COLORS   (2+8)
@@ -94,35 +110,17 @@ public:
 #define TABLE_COLORS  (INTENSITIES*BASE_COLORS)
 
 #define DEFAULT_FORE_COLOR 0
 #define DEFAULT_BACK_COLOR 1
 
 //a standard set of colors using black text on a white background.
 //defined in TerminalDisplay.cpp
 
-static const ColorEntry base_color_table[TABLE_COLORS] =
-// The following are almost IBM standard color codes, with some slight
-// gamma correction for the dim colors to compensate for bright X screens.
-// It contains the 8 ansiterm/xterm colors in 2 intensities.
-{
-  // Fixme: could add faint colors here, also.
-  // normal
-  ColorEntry(QColor(0x00,0x00,0x00), 0, 0 ), ColorEntry( QColor(0xB2,0xB2,0xB2), 1, 0 ), // Dfore, Dback
-  ColorEntry(QColor(0x00,0x00,0x00), 0, 0 ), ColorEntry( QColor(0xB2,0x18,0x18), 0, 0 ), // Black, Red
-  ColorEntry(QColor(0x18,0xB2,0x18), 0, 0 ), ColorEntry( QColor(0xB2,0x68,0x18), 0, 0 ), // Green, Yellow
-  ColorEntry(QColor(0x18,0x18,0xB2), 0, 0 ), ColorEntry( QColor(0xB2,0x18,0xB2), 0, 0 ), // Blue, Magenta
-  ColorEntry(QColor(0x18,0xB2,0xB2), 0, 0 ), ColorEntry( QColor(0xB2,0xB2,0xB2), 0, 0 ), // Cyan, White
-  // intensiv
-  ColorEntry(QColor(0x00,0x00,0x00), 0, 1 ), ColorEntry( QColor(0xFF,0xFF,0xFF), 1, 0 ),
-  ColorEntry(QColor(0x68,0x68,0x68), 0, 0 ), ColorEntry( QColor(0xFF,0x54,0x54), 0, 0 ),
-  ColorEntry(QColor(0x54,0xFF,0x54), 0, 0 ), ColorEntry( QColor(0xFF,0xFF,0x54), 0, 0 ),
-  ColorEntry(QColor(0x54,0x54,0xFF), 0, 0 ), ColorEntry( QColor(0xFF,0x54,0xFF), 0, 0 ),
-  ColorEntry(QColor(0x54,0xFF,0xFF), 0, 0 ), ColorEntry( QColor(0xFF,0xFF,0xFF), 0, 0 )
-};
+extern const ColorEntry base_color_table[TABLE_COLORS] KDE_NO_EXPORT;
 
 /* CharacterColor is a union of the various color spaces.
 
    Assignment is as follows:
 
    Type  - Space        - Values
 
    0     - Undefined   - u:  0,      v:0        w:0
@@ -208,17 +206,17 @@ public:
    * system color.
    * 
    * This is only applicable if the color is using the COLOR_SPACE_DEFAULT or COLOR_SPACE_SYSTEM
    * color spaces.
    */
   void toggleIntensive();
 
   /** 
-   * Returns the color within the specified color @palette
+   * Returns the color within the specified color @p palette
    *
    * The @p palette is only used if this color is one of the 16 system colors, otherwise
    * it is ignored.
    */
   QColor color(const ColorEntry* palette) const;
  
   /** 
    * Compares two colors and returns true if they represent the same color value and
@@ -237,36 +235,36 @@ private:
   // bytes storing the character color 
   quint8 _u; 
   quint8 _v; 
   quint8 _w; 
 };
 
 inline bool operator == (const CharacterColor& a, const CharacterColor& b)
 { 
-  return *reinterpret_cast<const quint32*>(&a._colorSpace) == 
-         *reinterpret_cast<const quint32*>(&b._colorSpace);
+    return     a._colorSpace == b._colorSpace &&
+            a._u == b._u &&
+            a._v == b._v &&
+            a._w == b._w;
 }
-
 inline bool operator != (const CharacterColor& a, const CharacterColor& b)
 {
-  return *reinterpret_cast<const quint32*>(&a._colorSpace) != 
-         *reinterpret_cast<const quint32*>(&b._colorSpace);
+    return !operator==(a,b);
 }
 
 inline const QColor color256(quint8 u, const ColorEntry* base)
 {
   //   0.. 16: system colors
   if (u <   8) return base[u+2            ].color; u -= 8;
   if (u <   8) return base[u+2+BASE_COLORS].color; u -= 8;
 
   //  16..231: 6x6x6 rgb color cube
-  if (u < 216) return QColor(255*((u/36)%6)/5,
-                             255*((u/ 6)%6)/5,
-                             255*((u/ 1)%6)/5); u -= 216;
+  if (u < 216) return QColor(((u/36)%6) ? (40*((u/36)%6)+55) : 0,
+                             ((u/ 6)%6) ? (40*((u/ 6)%6)+55) : 0,
+                             ((u/ 1)%6) ? (40*((u/ 1)%6)+55) : 0); u -= 216;
   
   // 232..255: gray, leaving out black and white
   int gray = u*10+8; return QColor(gray,gray,gray);
 }
 
 inline QColor CharacterColor::color(const ColorEntry* base) const
 {
   switch (_colorSpace)
diff --git a/gui//src/Emulation.cpp b/gui//src/Emulation.cpp
--- a/gui//src/Emulation.cpp
+++ b/gui//src/Emulation.cpp
@@ -1,16 +1,12 @@
 /*
-    This file is part of Konsole, an X terminal.
-
-    Copyright (C) 2007 Robert Knight <robertknight@gmail.com> 
-    Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
-    Copyright (C) 1996 by Matthias Ettrich <ettrich@kde.org>
-
-    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+    Copyright 2007-2008 Robert Knight <robertknight@gmail.com> 
+    Copyright 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
+    Copyright 1996 by Matthias Ettrich <ettrich@kde.org>
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
 
     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -38,41 +34,32 @@
 #include <QtCore/QHash>
 #include <QtGui/QKeyEvent>
 #include <QtCore/QRegExp>
 #include <QtCore/QTextStream>
 #include <QtCore/QThread>
 
 #include <QtCore/QTime>
 
+// KDE
+//#include <kdebug.h>
+
 // Konsole
 #include "KeyboardTranslator.h"
 #include "Screen.h"
 #include "TerminalCharacterDecoder.h"
 #include "ScreenWindow.h"
 
-/* ------------------------------------------------------------------------- */
-/*                                                                           */
-/*                               Emulation                                  */
-/*                                                                           */
-/* ------------------------------------------------------------------------- */
-
-//#define CNTL(c) ((c)-'@')
-
-/*!
-*/
-
 Emulation::Emulation() :
   _currentScreen(0),
   _codec(0),
   _decoder(0),
   _keyTranslator(0),
   _usesMouse(false)
 {
-
   // create screens with a default size
   _screen[0] = new Screen(40,80);
   _screen[1] = new Screen(40,80);
   _currentScreen = _screen[0];
 
   QObject::connect(&_bulkTimer1, SIGNAL(timeout()), this, SLOT(showBulk()) );
   QObject::connect(&_bulkTimer2, SIGNAL(timeout()), this, SLOT(showBulk()) );
    
@@ -100,74 +87,65 @@ ScreenWindow* Emulation::createWindow()
     connect(window , SIGNAL(selectionChanged()),
             this , SLOT(bufferedUpdate()));
 
     connect(this , SIGNAL(outputChanged()),
             window , SLOT(notifyOutputChanged()) );
     return window;
 }
 
-/*!
-*/
-
 Emulation::~Emulation()
 {
   QListIterator<ScreenWindow*> windowIter(_windows);
 
   while (windowIter.hasNext())
   {
     delete windowIter.next();
   }
 
   delete _screen[0];
   delete _screen[1];
   delete _decoder;
 }
 
-/*! change between primary and alternate _screen
-*/
-
 void Emulation::setScreen(int n)
 {
   Screen *old = _currentScreen;
-  _currentScreen = _screen[n&1];
+  _currentScreen = _screen[n & 1];
   if (_currentScreen != old) 
   {
-     old->setBusySelecting(false);
-
-     // tell all windows onto this emulation to switch to the newly active _screen
-     QListIterator<ScreenWindow*> windowIter(_windows);
-     while ( windowIter.hasNext() )
-     {
-         windowIter.next()->setScreen(_currentScreen);
-     }
+     // tell all windows onto this emulation to switch to the newly active screen
+     foreach(ScreenWindow* window,_windows)
+         window->setScreen(_currentScreen);
   }
 }
 
 void Emulation::clearHistory()
 {
     _screen[0]->setScroll( _screen[0]->getScroll() , false );
 }
 void Emulation::setHistory(const HistoryType& t)
 {
   _screen[0]->setScroll(t);
 
   showBulk();
 }
 
-const HistoryType& Emulation::history()
+const HistoryType& Emulation::history() const
 {
   return _screen[0]->getScroll();
 }
 
 void Emulation::setCodec(const QTextCodec * qtc)
 {
-  Q_ASSERT( qtc );
+  if (qtc)
+      _codec = qtc;
+  else
+     setCodec(LocaleCodec);
 
-  _codec = qtc;
   delete _decoder;
   _decoder = _codec->makeDecoder();
 
   emit useUtf8Request(utf8());
 }
 
 void Emulation::setCodec(EmulationCodec codec)
 {
@@ -175,125 +153,101 @@ void Emulation::setCodec(EmulationCodec 
         setCodec( QTextCodec::codecForName("utf8") );
     else if ( codec == LocaleCodec )
         setCodec( QTextCodec::codecForLocale() );
 }
 
 void Emulation::setKeyBindings(const QString& name)
 {
   _keyTranslator = KeyboardTranslatorManager::instance()->findTranslator(name);
+  if (!_keyTranslator)
+  {
+      _keyTranslator = KeyboardTranslatorManager::instance()->defaultTranslator();
+  }
 }
 
-QString Emulation::keyBindings()
+QString Emulation::keyBindings() const
 {
   return _keyTranslator->name();
 }
 
-
-// Interpreting Codes ---------------------------------------------------------
-
-/*
-   This section deals with decoding the incoming character stream.
-   Decoding means here, that the stream is first separated into `tokens'
-   which are then mapped to a `meaning' provided as operations by the
-   `Screen' class.
-*/
-
-/*!
-*/
-
 void Emulation::receiveChar(int c)
 // process application unicode input to terminal
 // this is a trivial scanner
 {
   c &= 0xff;
   switch (c)
   {
-    case '\b'      : _currentScreen->BackSpace();                 break;
-    case '\t'      : _currentScreen->Tabulate();                  break;
-    case '\n'      : _currentScreen->NewLine();                   break;
-    case '\r'      : _currentScreen->Return();                    break;
+    case '\b'      : _currentScreen->backspace();                 break;
+    case '\t'      : _currentScreen->tab();                       break;
+    case '\n'      : _currentScreen->newLine();                   break;
+    case '\r'      : _currentScreen->toStartOfLine();             break;
     case 0x07      : emit stateSet(NOTIFYBELL);
                      break;
-    default        : _currentScreen->ShowCharacter(c);            break;
+    default        : _currentScreen->displayCharacter(c);         break;
   };
 }
 
-/* ------------------------------------------------------------------------- */
-/*                                                                           */
-/*                             Keyboard Handling                             */
-/*                                                                           */
-/* ------------------------------------------------------------------------- */
-
-/*!
-*/
-
 void Emulation::sendKeyEvent( QKeyEvent* ev )
 {
   emit stateSet(NOTIFYNORMAL);
   
   if (!ev->text().isEmpty())
   { // A block of text
     // Note that the text is proper unicode.
-    // We should do a conversion here, but since this
-    // routine will never be used, we simply emit plain ascii.
-    //emit sendBlock(ev->text().toAscii(),ev->text().length());
+    // We should do a conversion here
     emit sendData(ev->text().toUtf8(),ev->text().length());
   }
 }
 
 void Emulation::sendString(const char*,int)
 {
     // default implementation does nothing
 }
 
 void Emulation::sendMouseEvent(int /*buttons*/, int /*column*/, int /*row*/, int /*eventType*/)
 {
     // default implementation does nothing
 }
 
-// Unblocking, Byte to Unicode translation --------------------------------- --
-
 /*
    We are doing code conversion from locale to unicode first.
 TODO: Character composition from the old code.  See #96536
 */
 
 void Emulation::receiveData(const char* text, int length)
 {
-	emit stateSet(NOTIFYACTIVITY);
+    emit stateSet(NOTIFYACTIVITY);
 
-	bufferedUpdate();
-    	
+    bufferedUpdate();
+        
     QString unicodeText = _decoder->toUnicode(text,length);
 
-	//send characters to terminal emulator
-	for (int i=0;i<unicodeText.length();i++)
-	{
-		receiveChar(unicodeText[i].unicode());
-	}
+    //send characters to terminal emulator
+    for (int i=0;i<unicodeText.length();i++)
+        receiveChar(unicodeText[i].unicode());
 
-	//look for z-modem indicator
-	//-- someone who understands more about z-modems that I do may be able to move
-	//this check into the above for loop?
-	for (int i=0;i<length;i++)
-	{
-		if (text[i] == '\030')
-    		{
-      			if ((length-i-1 > 3) && (strncmp(text+i+1, "B00", 3) == 0))
-      				emit zmodemDetected();
-    		}
-	}
+    //look for z-modem indicator
+    //-- someone who understands more about z-modems that I do may be able to move
+    //this check into the above for loop?
+    for (int i=0;i<length;i++)
+    {
+        if (text[i] == '\030')
+        {
+            if ((length-i-1 > 3) && (strncmp(text+i+1, "B00", 3) == 0))
+                emit zmodemDetected();
+        }
+    }
 }
 
 //OLDER VERSION
 //This version of onRcvBlock was commented out because
-//	a)  It decoded incoming characters one-by-one, which is slow in the current version of Qt (4.2 tech preview)
-//	b)  It messed up decoding of non-ASCII characters, with the result that (for example) chinese characters
-//	    were not printed properly.
+//    a)  It decoded incoming characters one-by-one, which is slow in the current version of Qt (4.2 tech preview)
+//    b)  It messed up decoding of non-ASCII characters, with the result that (for example) chinese characters
+//        were not printed properly.
 //
 //There is something about stopping the _decoder if "we get a control code halfway a multi-byte sequence" (see below)
 //which hasn't been ported into the newer function (above).  Hopefully someone who understands this better
 //can find an alternative way of handling the check.  
 
 
 /*void Emulation::onRcvBlock(const char *s, int len)
 {
@@ -323,82 +277,37 @@ void Emulation::receiveData(const char* 
       if (result[j].characterategory() == QChar::Mark_NonSpacing)
          _currentScreen->compose(result.mid(j,1));
       else
          onRcvChar(result[j].unicode());
     }
     if (s[i] == '\030')
     {
       if ((len-i-1 > 3) && (strncmp(s+i+1, "B00", 3) == 0))
-      	emit zmodemDetected();
+          emit zmodemDetected();
     }
   }
 }*/
 
-// Selection --------------------------------------------------------------- --
-
-#if 0
-void Emulation::onSelectionBegin(const int x, const int y, const bool columnmode) {
-  if (!connected) return;
-  _currentScreen->setSelectionStart( x,y,columnmode);
-  showBulk();
-}
-
-void Emulation::onSelectionExtend(const int x, const int y) {
-  if (!connected) return;
-  _currentScreen->setSelectionEnd(x,y);
-  showBulk();
-}
-
-void Emulation::setSelection(const bool preserve_line_breaks) {
-  if (!connected) return;
-  QString t = _currentScreen->selectedText(preserve_line_breaks);
-  if (!t.isNull()) 
-  {
-    QListIterator< TerminalDisplay* > viewIter(_views);
-
-    while (viewIter.hasNext())    
-        viewIter.next()->setSelection(t);
-  }
-}
-
-void Emulation::testIsSelected(const int x, const int y, bool &selected)
-{
-  if (!connected) return;
-  selected=_currentScreen->isSelected(x,y);
-}
-
-void Emulation::clearSelection() {
-  if (!connected) return;
-  _currentScreen->clearSelection();
-  showBulk();
-}
-
-#endif 
-
 void Emulation::writeToStream( TerminalCharacterDecoder* _decoder , 
                                int startLine ,
                                int endLine) 
 {
-  _currentScreen->writeToStream(_decoder,startLine,endLine);
+  _currentScreen->writeLinesToStream(_decoder,startLine,endLine);
 }
 
-int Emulation::lineCount()
+int Emulation::lineCount() const
 {
     // sum number of lines currently on _screen plus number of lines in history
     return _currentScreen->getLines() + _currentScreen->getHistLines();
 }
 
-// Refreshing -------------------------------------------------------------- --
-
 #define BULK_TIMEOUT1 10
 #define BULK_TIMEOUT2 40
 
-/*!
-*/
 void Emulation::showBulk()
 {
     _bulkTimer1.stop();
     _bulkTimer2.stop();
 
     emit outputChanged();
 
     _currentScreen->resetScrolledLines();
@@ -411,36 +320,44 @@ void Emulation::bufferedUpdate()
    _bulkTimer1.start(BULK_TIMEOUT1);
    if (!_bulkTimer2.isActive())
    {
       _bulkTimer2.setSingleShot(true);
       _bulkTimer2.start(BULK_TIMEOUT2);
    }
 }
 
-char Emulation::getErase() const
+char Emulation::eraseChar() const
 {
   return '\b';
 }
 
 void Emulation::setImageSize(int lines, int columns)
 {
-  //kDebug() << "Resizing image to: " << lines << "by" << columns << QTime::currentTime().msec();
-  Q_ASSERT( lines > 0 );
-  Q_ASSERT( columns > 0 );
+  if ((lines < 1) || (columns < 1)) 
+    return;
+
+  QSize screenSize[2] = { QSize(_screen[0]->getColumns(),
+                                _screen[0]->getLines()),
+                          QSize(_screen[1]->getColumns(),
+                                _screen[1]->getLines()) };
+  QSize newSize(columns,lines);
+
+  if (newSize == screenSize[0] && newSize == screenSize[1])
+    return;    
 
   _screen[0]->resizeImage(lines,columns);
   _screen[1]->resizeImage(lines,columns);
 
   emit imageSizeChanged(lines,columns);
 
   bufferedUpdate();
 }
 
-QSize Emulation::imageSize()
+QSize Emulation::imageSize() const
 {
   return QSize(_currentScreen->getColumns(), _currentScreen->getLines());
 }
 
 ushort ExtendedCharTable::extendedCharHash(ushort* unicodePoints , ushort length) const
 {
     ushort hash = 0;
     for ( ushort i = 0 ; i < length ; i++ )
@@ -532,10 +449,8 @@ ExtendedCharTable::~ExtendedCharTable()
         delete[] iter.value();
     }
 }
 
 // global instance
 ExtendedCharTable ExtendedCharTable::instance;
 
 
-//#include "moc_Emulation.cpp"
-
diff --git a/gui//src/Emulation.h b/gui//src/Emulation.h
--- a/gui//src/Emulation.h
+++ b/gui//src/Emulation.h
@@ -1,15 +1,13 @@
 /*
     This file is part of Konsole, an X terminal.
     
-    Copyright (C) 2007 by Robert Knight <robertknight@gmail.com>
-    Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
-
-    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+    Copyright 2007-2008 by Robert Knight <robertknight@gmail.com>
+    Copyright 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
 
     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -25,20 +23,24 @@
 #ifndef EMULATION_H
 #define EMULATION_H
 
 // System
 #include <stdio.h>
 
 // Qt 
 #include <QtGui/QKeyEvent>
+//#include <QPointer>
 #include <QtCore/QTextCodec>
 #include <QtCore/QTextStream>
 #include <QtCore/QTimer>
 
+// Konsole
+#include "konsole_export.h"
+
 class KeyboardTranslator;
 class HistoryType;
 class Screen;
 class ScreenWindow;
 class TerminalCharacterDecoder;
 
 /** 
  * This enum describes the available states which 
@@ -109,17 +111,17 @@ enum
  * The emulation also maintains an activity state, which specifies whether
  * terminal is currently active ( when data is received ), normal
  * ( when the terminal is idle or receiving user input ) or trying
  * to alert the user ( also known as a "Bell" event ).  The stateSet() signal
  * is emitted whenever the activity state is set.  This can be used to determine
  * how long the emulation has been active/idle for and also respond to
  * a 'bell' event in different ways.
  */
-class Emulation : public QObject
+class KONSOLEPRIVATE_EXPORT Emulation : public QObject
 { 
 Q_OBJECT
 
 public:
  
    /** Constructs a new terminal emulation */ 
    Emulation();
   ~Emulation();
@@ -127,78 +129,78 @@ public:
   /**
    * Creates a new window onto the output from this emulation.  The contents
    * of the window are then rendered by views which are set to use this window using the
    * TerminalDisplay::setScreenWindow() method.
    */
   ScreenWindow* createWindow();
 
   /** Returns the size of the screen image which the emulation produces */
-  QSize imageSize();
+  QSize imageSize() const;
 
   /**
    * Returns the total number of lines, including those stored in the history.
    */ 
-  int lineCount();
+  int lineCount() const;
 
-  
   /** 
    * Sets the history store used by this emulation.  When new lines
    * are added to the output, older lines at the top of the screen are transferred to a history
    * store.   
    *
    * The number of lines which are kept and the storage location depend on the 
    * type of store.
    */
   void setHistory(const HistoryType&);
   /** Returns the history store used by this emulation.  See setHistory() */
-  const HistoryType& history();
+  const HistoryType& history() const;
   /** Clears the history scroll. */
   void clearHistory();
 
   /** 
    * Copies the output history from @p startLine to @p endLine 
    * into @p stream, using @p decoder to convert the terminal
    * characters into text. 
    *
    * @param decoder A decoder which converts lines of terminal characters with 
    * appearance attributes into output text.  PlainTextDecoder is the most commonly
    * used decoder.
-   * @param startLine The first
+   * @param startLine Index of first line to copy
+   * @param endLine Index of last line to copy
    */
   virtual void writeToStream(TerminalCharacterDecoder* decoder,int startLine,int endLine);
   
-  
   /** Returns the codec used to decode incoming characters.  See setCodec() */
-  const QTextCodec* codec() { return _codec; }
+  const QTextCodec* codec() const { return _codec; }
   /** Sets the codec used to decode incoming characters.  */
   void setCodec(const QTextCodec*);
 
   /** 
    * Convenience method.  
    * Returns true if the current codec used to decode incoming
    * characters is UTF-8
    */
-  bool utf8() { Q_ASSERT(_codec); return _codec->mibEnum() == 106; }
+  bool utf8() const
+  { Q_ASSERT(_codec); return _codec->mibEnum() == 106; }
   
 
   /** TODO Document me */
-  virtual char getErase() const;
+  virtual char eraseChar() const;
 
   /** 
    * Sets the key bindings used to key events
    * ( received through sendKeyEvent() ) into character
    * streams to send to the terminal.
    */
   void setKeyBindings(const QString& name);
   /** 
    * Returns the name of the emulation's current key bindings.
    * See setKeyBindings()
    */
-  QString keyBindings();
+  QString keyBindings() const;
 
   /** 
    * Copies the current image into the history and clears the screen.
    */
   virtual void clearEntireScreen() =0;
 
   /** Resets the state of the terminal. */
   virtual void reset() =0;
@@ -260,17 +262,17 @@ public slots:
 
 signals:
 
   /** 
    * Emitted when a buffer of data is ready to send to the 
    * standard input of the terminal.
    *
    * @param data The buffer of data ready to be sent
-   * @paran len The length of @p data in bytes
+   * @param len The length of @p data in bytes
    */
   void sendData(const char* data,int len);
 
   /** 
    * Requests that sending of input to the emulation
    * from the terminal process be suspended or resumed.
    *
    * @param suspend If true, requests that sending of 
@@ -347,17 +349,17 @@ signals:
    * the user-title of the session.    
    *
    * @param title Specifies what to change.
    * <ul>
    * <li>0 - Set window icon text and session title to @p newTitle</li>
    * <li>1 - Set window icon text to @p newTitle</li>
    * <li>2 - Set session title to @p newTitle</li>
    * <li>11 - Set the session's default background color to @p newTitle,
-   *         where @p newTitle can be an HTML-style string (#RRGGBB) or a named
+   *         where @p newTitle can be an HTML-style string ("#RRGGBB") or a named
    *         color (eg 'red', 'blue').  
    *         See http://doc.trolltech.com/4.2/qcolor.html#setNamedColor for more
    *         details.
    * </li>
    * <li>31 - Supposedly treats @p newTitle as a URL and opens it (NOT IMPLEMENTED)</li>
    * <li>32 - Sets the icon associated with the session.  @p newTitle is the name 
    *    of the icon to use, which can be the name of any icon in the current KDE icon
    *    theme (eg: 'konsole', 'kate', 'folder_home')</li>
@@ -381,21 +383,28 @@ signals:
    * by a string containing a series of name and value pairs is received.
    * This string can be parsed using a ProfileCommandParser instance.
    *
    * @param text A string expected to contain a series of key and value pairs in
    * the form:  name=value;name2=value2 ...
    */
   void profileChangeCommandReceived(const QString& text);
 
+  /** 
+   * Emitted when a flow control key combination ( Ctrl+S or Ctrl+Q ) is pressed.
+   * @param suspendKeyPressed True if Ctrl+S was pressed to suspend output or Ctrl+Q to
+   * resume output.
+   */
+  void flowControlKeyPressed(bool suspendKeyPressed);
+
 protected:
-  virtual void setMode  (int mode) = 0;
+  virtual void setMode(int mode) = 0;
   virtual void resetMode(int mode) = 0;
    
- /** 
+  /** 
    * Processes an incoming character.  See receiveData()
    * @p ch A unicode character code. 
    */
   virtual void receiveChar(int ch);
 
   /** 
    * Sets the active screen.  The terminal has two screens, primary and alternate.
    * The primary screen is used by default.  When certain interactive programs such
@@ -423,17 +432,16 @@ protected:
                             // 1 = alternate      ( used by vi , emacs etc.
                             //                      scrollbars are not enabled in this mode )
                             
   
   //decodes an incoming C-style character stream into a unicode QString using 
   //the current text codec.  (this allows for rendering of non-ASCII characters in text files etc.)
   const QTextCodec* _codec;
   QTextDecoder* _decoder;
-
   const KeyboardTranslator* _keyTranslator; // the keyboard layout
 
 protected slots:
   /** 
    * Schedules an update of attached views.
    * Repeated calls to bufferedUpdate() in close succession will result in only a single update,
    * much like the Qt buffered update of widgets. 
    */
@@ -443,16 +451,15 @@ private slots:
 
   // triggered by timer, causes the emulation to send an updated screen image to each
   // view
   void showBulk(); 
 
   void usesMouseChanged(bool usesMouse);
 
 private:
-
   bool _usesMouse;
   QTimer _bulkTimer1;
   QTimer _bulkTimer2;
   
 };
 
 #endif // ifndef EMULATION_H
diff --git a/gui//src/Filter.cpp b/gui//src/Filter.cpp
--- a/gui//src/Filter.cpp
+++ b/gui//src/Filter.cpp
@@ -1,12 +1,10 @@
 /*
-    Copyright (C) 2007 by Robert Knight <robertknight@gmail.com>
-
-    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+    Copyright 2007-2008 by Robert Knight <robertknight@gmail.com>
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
 
     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -25,22 +23,28 @@
 // System
 #include <iostream>
 
 // Qt
 #include <QtGui/QAction>
 #include <QtGui/QApplication>
 #include <QtGui/QClipboard>
 #include <QtCore/QString>
-
+#include <QtCore/QTextStream>
 #include <QtCore/QSharedData>
-#include <QtCore>
+#include <QtCore/QFile>
+
+// KDE
+//#include <KLocale>
+//#include <KRun>
 
 // Konsole
 #include "TerminalCharacterDecoder.h"
+#include "konsole_wcwidth.h"
+#include "konsole_export.h"
 
 FilterChain::~FilterChain()
 {
     QMutableListIterator<Filter*> iter(*this);
     
     while ( iter.hasNext() )
     {
         Filter* filter = iter.next();
@@ -121,29 +125,25 @@ TerminalImageFilterChain::TerminalImageF
 TerminalImageFilterChain::~TerminalImageFilterChain()
 {
     delete _buffer;
     delete _linePositions;
 }
 
 void TerminalImageFilterChain::setImage(const Character* const image , int lines , int columns, const QVector<LineProperty>& lineProperties)
 {
-//qDebug("%s %d", __FILE__, __LINE__);
     if (empty())
         return;
-//qDebug("%s %d", __FILE__, __LINE__);
 
     // reset all filters and hotspots
     reset();
-//qDebug("%s %d", __FILE__, __LINE__);
 
     PlainTextDecoder decoder;
     decoder.setTrailingWhitespace(false);
     
-//qDebug("%s %d", __FILE__, __LINE__);
     // setup new shared buffers for the filters to process on
     QString* newBuffer = new QString();
     QList<int>* newLinePositions = new QList<int>();
     setBuffer( newBuffer , newLinePositions );
 
     // free the old buffers
     delete _buffer;
     delete _linePositions;
@@ -165,20 +165,19 @@ void TerminalImageFilterChain::setImage(
         //
         // the downside is that links which are spread over more than one line are not
         // highlighted.  
         //
         // TODO - Use the "line wrapped" attribute associated with lines in a
         // terminal image to avoid adding this imaginary character for wrapped
         // lines
         if ( !(lineProperties.value(i,LINE_DEFAULT) & LINE_WRAPPED) )
-        	lineStream << QChar('\n');
+            lineStream << QChar('\n');
     }
     decoder.end();
-//    qDebug("%s %d", __FILE__, __LINE__);
 }
 
 Filter::Filter() :
 _linePositions(0),
 _buffer(0)
 {
 }
 
@@ -205,39 +204,38 @@ void Filter::setBuffer(const QString* bu
 void Filter::getLineColumn(int position , int& startLine , int& startColumn)
 {
     Q_ASSERT( _linePositions );
     Q_ASSERT( _buffer );
 
 
     for (int i = 0 ; i < _linePositions->count() ; i++)
     {
-        //kDebug() << "line position at " << i << " = " << _linePositions[i];
         int nextLine = 0;
 
         if ( i == _linePositions->count()-1 )
-        {
             nextLine = _buffer->length() + 1;
-        }
         else
-        {
             nextLine = _linePositions->value(i+1);
-        }
-
-       // kDebug() << "pos - " << position << " line pos(" << i<< ") " << _linePositions->value(i) << 
-       //     " next = " << nextLine << " buffer len = " << _buffer->length();
 
         if ( _linePositions->value(i) <= position && position < nextLine ) 
         {
             startLine = i;
-            startColumn = position - _linePositions->value(i);
+            startColumn = string_width(buffer()->mid(_linePositions->value(i),position - _linePositions->value(i)));
             return;
         }
     }
 }
+    
+
+/*void Filter::addLine(const QString& text)
+{
+    _linePositions << _buffer.length();
+    _buffer.append(text);
+}*/
 
 const QString* Filter::buffer()
 {
     return _buffer;
 }
 Filter::HotSpot::~HotSpot()
 {
 }
@@ -345,17 +343,20 @@ QStringList RegExpFilter::HotSpot::captu
 void RegExpFilter::setRegExp(const QRegExp& regExp) 
 {
     _searchText = regExp;
 }
 QRegExp RegExpFilter::regExp() const
 {
     return _searchText;
 }
-
+/*void RegExpFilter::reset(int)
+{
+    _buffer = QString();
+}*/
 void RegExpFilter::process()
 {
     int pos = 0;
     const QString* text = buffer();
 
     Q_ASSERT( text );
 
     // ignore any regular expressions which match an empty string.
@@ -365,40 +366,34 @@ void RegExpFilter::process()
         return;
 
     while(pos >= 0)
     {
         pos = _searchText.indexIn(*text,pos);
 
         if ( pos >= 0 )
         {
-
             int startLine = 0;
             int endLine = 0;
             int startColumn = 0;
             int endColumn = 0;
 
-            
-            //kDebug() << "pos from " << pos << " to " << pos + _searchText.matchedLength();
-            
             getLineColumn(pos,startLine,startColumn);
             getLineColumn(pos + _searchText.matchedLength(),endLine,endColumn);
 
-            //kDebug() << "start " << startLine << " / " << startColumn;
-            //kDebug() << "end " << endLine << " / " << endColumn;
-
             RegExpFilter::HotSpot* spot = newHotSpot(startLine,startColumn,
                                            endLine,endColumn);
             spot->setCapturedTexts(_searchText.capturedTexts());
 
             addHotSpot( spot );  
             pos += _searchText.matchedLength();
 
             // if matchedLength == 0, the program will get stuck in an infinite loop
-            Q_ASSERT( _searchText.matchedLength() > 0 );
+            if ( _searchText.matchedLength() == 0 )
+                pos = -1;
         }
     }    
 }
 
 RegExpFilter::HotSpot* RegExpFilter::newHotSpot(int startLine,int startColumn,
                                                 int endLine,int endColumn)
 {
     return new RegExpFilter::HotSpot(startLine,startColumn,
@@ -446,18 +441,16 @@ void UrlFilter::HotSpot::activate(QObjec
     QString url = capturedTexts().first();
 
     const UrlType kind = urlType();
 
     const QString& actionName = object ? object->objectName() : QString();
 
     if ( actionName == "copy-action" )
     {
-        //kDebug() << "Copying url to clipboard:" << url;
-
         QApplication::clipboard()->setText(url);
         return;
     }
 
     if ( !object || actionName == "open-action" )
     {
         if ( kind == StandardUrl )
         {
@@ -468,17 +461,17 @@ void UrlFilter::HotSpot::activate(QObjec
                 url.prepend("http://");
             }
         } 
         else if ( kind == Email )
         {
             url.prepend("mailto:");
         }
     
-//        new KRun(url,QApplication::activeWindow());
+        //new KRun(url,QApplication::activeWindow());
     }
 }
 
 // Note:  Altering these regular expressions can have a major effect on the performance of the filters 
 // used for finding URLs in the text, especially if they are very general and could match very long
 // pieces of text.
 // Please be careful when altering them.
 
@@ -514,30 +507,30 @@ QList<QAction*> UrlFilter::HotSpot::acti
 
     QAction* openAction = new QAction(_urlObject);
     QAction* copyAction = new QAction(_urlObject);;
 
     Q_ASSERT( kind == StandardUrl || kind == Email );
 
     if ( kind == StandardUrl )
     {
-        openAction->setText(("Open Link"));
-        copyAction->setText(("Copy Link Address"));
+        openAction->setText(i18n("Open Link"));
+        copyAction->setText(i18n("Copy Link Address"));
     }
     else if ( kind == Email )
     {
-        openAction->setText(("Send Email To..."));
-        copyAction->setText(("Copy Email Address"));
+        openAction->setText(i18n("Send Email To..."));
+        copyAction->setText(i18n("Copy Email Address"));
     }
 
     // object names are set here so that the hotspot performs the
     // correct action when activated() is called with the triggered
     // action passed as a parameter.
-    openAction->setObjectName("open-action");
-    copyAction->setObjectName("copy-action");
+    openAction->setObjectName( QLatin1String("open-action" ));
+    copyAction->setObjectName( QLatin1String("copy-action" ));
 
     QObject::connect( openAction , SIGNAL(triggered()) , _urlObject , SLOT(activated()) );
     QObject::connect( copyAction , SIGNAL(triggered()) , _urlObject , SLOT(activated()) );
 
     list << openAction;
     list << copyAction;
 
     return list; 
diff --git a/gui//src/Filter.h b/gui//src/Filter.h
--- a/gui//src/Filter.h
+++ b/gui//src/Filter.h
@@ -1,12 +1,10 @@
 /*
-    Copyright (C) 2007 by Robert Knight <robertknight@gmail.com>
-
-    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+    Copyright 2007-2008 by Robert Knight <robertknight@gmail.com>
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
 
     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -28,16 +26,17 @@
 #include <QtCore/QObject>
 #include <QtCore/QStringList>
 #include <QtCore/QHash>
 #include <QtCore/QRegExp>
 
 // Local
 #include "Character.h"
 
+
 /**
  * A filter processes blocks of text looking for certain patterns (such as URLs or keywords from a list)
  * and marks the areas which match the filter's patterns as 'hotspots'.
  *
  * Each hotspot has a type identifier associated with it ( such as a link or a highlighted section ),
  * and an action.  When the user performs some activity such as a mouse-click in a hotspot area ( the exact
  * action will depend on what is displaying the block of text which the filter is processing ), the hotspot's
  * activate() method should be called.  Depending on the type of hotspot this will trigger a suitable response.
@@ -362,17 +361,19 @@ public:
     virtual ~TerminalImageFilterChain();
 
     /**
      * Set the current terminal image to @p image.
      *
      * @param image The terminal image
      * @param lines The number of lines in the terminal image
      * @param columns The number of columns in the terminal image
+     * @param lineProperties The line properties to set for image
      */
     void setImage(const Character* const image , int lines , int columns,
-				  const QVector<LineProperty>& lineProperties);  
+                  const QVector<LineProperty>& lineProperties);  
 
 private:
     QString* _buffer;
     QList<int>* _linePositions;
 };
+
 #endif //FILTER_H
diff --git a/gui//src/KeyboardTranslator.cpp b/gui//src/KeyboardTranslator.cpp
--- a/gui//src/KeyboardTranslator.cpp
+++ b/gui//src/KeyboardTranslator.cpp
@@ -1,14 +1,12 @@
 /*
-    This source file was part of Konsole, a terminal emulator.
+    This source file is part of Konsole, a terminal emulator.
 
-    Copyright (C) 2007 by Robert Knight <robertknight@gmail.com>
-
-    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+    Copyright 2007-2008 by Robert Knight <robertknight@gmail.com>
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
 
     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -27,106 +25,108 @@
 // System
 #include <ctype.h>
 #include <stdio.h>
 
 // Qt
 #include <QtCore/QBuffer>
 #include <QtCore/QFile>
 #include <QtCore/QFileInfo>
-#include <QtCore>
-#include <QtGui>
-
-
-//this is for default REALLY fallback translator.
+#include <QtCore/QTextStream>
+#include <QtGui/QKeySequence>
+#include <QtCore/QDir>
+#include <QtCore/QStringList>
+#include <QtCore/QDebug>
+#include <QtCore/QDataStream>
 
-//const char* KeyboardTranslatorManager::defaultTranslatorText =
-//#include "DefaultTranslatorText.h"
-//;
+// KDE
+#include "konsole_export.h"
+//#include <KDebug>
+//#include <KLocale>
+//#include <KStandardDirs>
+//#include "kdebug.h"
 
-//and this is default now translator - default.keytab from original Konsole
-const char* KeyboardTranslatorManager::defaultTranslatorText = 
-#include "ExtendedDefaultTranslator.h"
-;
+const QByteArray KeyboardTranslatorManager::defaultTranslatorText(
+"keyboard \"Fallback Key Translator\"\n"
+"key Tab : \"\\t\""
+);
 
 KeyboardTranslatorManager::KeyboardTranslatorManager()
     : _haveLoadedAll(false)
 {
 }
 KeyboardTranslatorManager::~KeyboardTranslatorManager()
 {
-    qDeleteAll(_translators.values());
+    qDeleteAll(_translators);
 }
 QString KeyboardTranslatorManager::findTranslatorPath(const QString& name)
 {
-    return QString("kb-layouts/" + name + ".keytab");
+  return QString("kb-layouts/" + name + ".keytab");
+  // return KGlobal::dirs()->findResource("data","konsole/"+name+".keytab");
 }
 void KeyboardTranslatorManager::findTranslators()
 {
+  //QStringList list = KGlobal::dirs()->findAllResources("data",
+  //                                                     "konsole/*.keytab",
+  //                                                     KStandardDirs::NoDuplicates);
+
     QDir dir("kb-layouts/");
     QStringList filters;
     filters << "*.keytab";
     dir.setNameFilters(filters);
-    QStringList list = dir.entryList(filters); //(".keytab"); // = KGlobal::dirs()->findAllResources("data",
-                        //                                 "konsole/*.keytab",
-                        //                                 KStandardDirs::NoDuplicates);
-    list = dir.entryList(filters);
+    QStringList list = dir.entryList(filters);
+
     // add the name of each translator to the list and associated
     // the name with a null pointer to indicate that the translator
     // has not yet been loaded from disk
     QStringListIterator listIter(list);
     while (listIter.hasNext())
     {
         QString translatorPath = listIter.next();
 
         QString name = QFileInfo(translatorPath).baseName();
        
-        if ( !_translators.contains(name) ) {
+        if ( !_translators.contains(name) ) 
             _translators.insert(name,0);
-	}
     }
+
     _haveLoadedAll = true;
 }
 
 const KeyboardTranslator* KeyboardTranslatorManager::findTranslator(const QString& name)
 {
     if ( name.isEmpty() )
         return defaultTranslator();
 
-//here was smth wrong in original Konsole source 
-    findTranslators();
-
-    if ( _translators.contains(name) && _translators[name] != 0 ) {
+    if ( _translators.contains(name) && _translators[name] != 0 )
         return _translators[name];
-    }
 
     KeyboardTranslator* translator = loadTranslator(name);
 
     if ( translator != 0 )
         _translators[name] = translator;
-    else if ( !name.isEmpty() )
-        qWarning() << "Unable to load translator" << name;
+    //else if ( !name.isEmpty() )
+    //  kWarning() << "Unable to load translator" << name;
 
     return translator;
 }
 
 bool KeyboardTranslatorManager::saveTranslator(const KeyboardTranslator* translator)
 {
-    const QString path = ".keytab";// = KGlobal::dirs()->saveLocation("data","konsole/")+translator->name()
-//           +".keytab";
+  //const QString path = KGlobal::dirs()->saveLocation("data","konsole/")+translator->name()
+  //         +".keytab";
+  const QString path = ".keytab";
 
-    qDebug() << "Saving translator to" << path;
+    //kDebug() << "Saving translator to" << path;
 
     QFile destination(path);
-    
     if (!destination.open(QIODevice::WriteOnly | QIODevice::Text))
     {
-        qWarning() << "Unable to save keyboard translation:" 
-                   << destination.errorString();
-
+        //kWarning() << "Unable to save keyboard translation:"
+         //          << destination.errorString();
         return false;
     }
 
     {
         KeyboardTranslatorWriter writer(&destination);
         writer.writeHeader(translator->description());
     
         QListIterator<KeyboardTranslator::Entry> iter(translator->entries());
@@ -139,44 +139,44 @@ bool KeyboardTranslatorManager::saveTran
     return true;
 }
 
 KeyboardTranslator* KeyboardTranslatorManager::loadTranslator(const QString& name)
 {
     const QString& path = findTranslatorPath(name);
 
     QFile source(path); 
-    
     if (name.isEmpty() || !source.open(QIODevice::ReadOnly | QIODevice::Text))
         return 0;
 
     return loadTranslator(&source,name);
 }
 
 const KeyboardTranslator* KeyboardTranslatorManager::defaultTranslator()
 {
-    qDebug() << "Loading default translator from text";
-    QBuffer textBuffer;
-    textBuffer.setData(defaultTranslatorText,strlen(defaultTranslatorText));
-
-    if (!textBuffer.open(QIODevice::ReadOnly))
-        return 0;
-
-    return loadTranslator(&textBuffer,"fallback");
+    // Try to find the default.keytab file if it exists, otherwise
+    // fall back to the hard-coded one
+    const KeyboardTranslator* translator = findTranslator("default");
+    if (!translator)
+    {
+        QBuffer textBuffer;
+        textBuffer.setData(defaultTranslatorText);
+        textBuffer.open(QIODevice::ReadOnly);
+        translator = loadTranslator(&textBuffer,"fallback");
+    }
+    return translator;
 }
 
 KeyboardTranslator* KeyboardTranslatorManager::loadTranslator(QIODevice* source,const QString& name)
 {
     KeyboardTranslator* translator = new KeyboardTranslator(name);
     KeyboardTranslatorReader reader(source);
     translator->setDescription( reader.description() );
-    
-    while ( reader.hasNextEntry() ) {
+    while ( reader.hasNextEntry() )
         translator->addEntry(reader.nextEntry());
-    }	
 
     source->close();
 
     if ( !reader.parseError() )
     {
         return translator;
     }
     else
@@ -199,17 +199,16 @@ KeyboardTranslatorWriter::~KeyboardTrans
 }
 void KeyboardTranslatorWriter::writeHeader( const QString& description )
 {
     *_writer << "keyboard \"" << description << '\"' << '\n';
 }
 void KeyboardTranslatorWriter::writeEntry( const KeyboardTranslator::Entry& entry )
 {
     QString result;
-
     if ( entry.command() != KeyboardTranslator::NoCommand )
         result = entry.resultToString();
     else
         result = '\"' + entry.resultToString() + '\"';
 
     *_writer << "key " << entry.conditionToString() << " : " << result << '\n';
 }
 
@@ -235,24 +234,21 @@ void KeyboardTranslatorWriter::writeEntr
 
 KeyboardTranslatorReader::KeyboardTranslatorReader( QIODevice* source )
     : _source(source)
     , _hasNext(false)
 {
    // read input until we find the description
    while ( _description.isEmpty() && !source->atEnd() )
    {
-        const QList<Token>& tokens = tokenize( QString(source->readLine()) );
-   
+        QList<Token> tokens = tokenize( QString(source->readLine()) );
         if ( !tokens.isEmpty() && tokens.first().type == Token::TitleKeyword )
-        {
-            _description = (tokens[1].text.toUtf8());
-        }
+            _description = i18n(tokens[1].text.toLatin1().data());
    }
-
+   // read first entry (if any)
    readNext();
 }
 void KeyboardTranslatorReader::readNext() 
 {
     // find next entry
     while ( !_source->atEnd() )
     {
         const QList<Token>& tokens = tokenize( QString(_source->readLine()) );
@@ -278,18 +274,18 @@ void KeyboardTranslatorReader::readNext(
             // get text or command
             if ( tokens[2].type == Token::OutputText )
             {
                 text = tokens[2].text.toLocal8Bit();
             }
             else if ( tokens[2].type == Token::Command )
             {
                 // identify command
-				if (!parseAsCommand(tokens[2].text,command))
-					qWarning() << "Command" << tokens[2].text << "not understood.";
+               // if (!parseAsCommand(tokens[2].text,command))
+                //  kWarning() << "Command" << tokens[2].text << "not understood.";
             }
 
             KeyboardTranslator::Entry newEntry;
             newEntry.setKeyCode( keyCode );
             newEntry.setState( flags );
             newEntry.setStateMask( flagMask );
             newEntry.setModifiers( modifiers );
             newEntry.setModifierMask( modifierMask );
@@ -304,32 +300,32 @@ void KeyboardTranslatorReader::readNext(
         }
     } 
 
     _hasNext = false;
 }
 
 bool KeyboardTranslatorReader::parseAsCommand(const QString& text,KeyboardTranslator::Command& command) 
 {
-	if ( text.compare("erase",Qt::CaseInsensitive) == 0 )
-		command = KeyboardTranslator::EraseCommand;
+    if ( text.compare("erase",Qt::CaseInsensitive) == 0 )
+        command = KeyboardTranslator::EraseCommand;
     else if ( text.compare("scrollpageup",Qt::CaseInsensitive) == 0 )
         command = KeyboardTranslator::ScrollPageUpCommand;
     else if ( text.compare("scrollpagedown",Qt::CaseInsensitive) == 0 )
         command = KeyboardTranslator::ScrollPageDownCommand;
     else if ( text.compare("scrolllineup",Qt::CaseInsensitive) == 0 )
         command = KeyboardTranslator::ScrollLineUpCommand;
     else if ( text.compare("scrolllinedown",Qt::CaseInsensitive) == 0 )
         command = KeyboardTranslator::ScrollLineDownCommand;
     else if ( text.compare("scrolllock",Qt::CaseInsensitive) == 0 )
         command = KeyboardTranslator::ScrollLockCommand;
     else
-    	return false;
+        return false;
 
-	return true;
+    return true;
 }
 
 bool KeyboardTranslatorReader::decodeSequence(const QString& text,
                                               int& keyCode,
                                               Qt::KeyboardModifiers& modifiers,
                                               Qt::KeyboardModifiers& modifierMask,
                                               KeyboardTranslator::States& flags,
                                               KeyboardTranslator::States& flagMask)
@@ -341,23 +337,26 @@ bool KeyboardTranslatorReader::decodeSeq
     Qt::KeyboardModifiers tempModifiers = modifiers;
     Qt::KeyboardModifiers tempModifierMask = modifierMask;
     KeyboardTranslator::States tempFlags = flags;
     KeyboardTranslator::States tempFlagMask = flagMask;
 
     for ( int i = 0 ; i < text.count() ; i++ )
     {
         const QChar& ch = text[i];
+        bool isFirstLetter = i == 0;
         bool isLastLetter = ( i == text.count()-1 );
-
         endOfItem = true;
         if ( ch.isLetterOrNumber() )
         {
             endOfItem = false;
             buffer.append(ch);
+        } else if ( isFirstLetter )
+        {
+            buffer.append(ch);
         }
 
         if ( (endOfItem || isLastLetter) && !buffer.isEmpty() )
         {
             Qt::KeyboardModifier itemModifier = Qt::NoModifier;
             int itemKeyCode = 0;
             KeyboardTranslator::State itemFlag = KeyboardTranslator::NoState;
 
@@ -372,18 +371,18 @@ bool KeyboardTranslatorReader::decodeSeq
             {
                 tempFlagMask |= itemFlag;
 
                 if ( isWanted )
                     tempFlags |= itemFlag;
             }
             else if ( parseAsKeyCode(buffer,itemKeyCode) )
                 keyCode = itemKeyCode;
-            else
-                qDebug() << "Unable to parse key binding item:" << buffer;
+            //else
+          //      kWarning() << "Unable to parse key binding item:" << buffer;
 
             buffer.clear();
         }
 
         // check if this is a wanted / not-wanted flag and update the 
         // state ready for the next item
         if ( ch == '+' )
            isWanted = true;
@@ -404,50 +403,52 @@ bool KeyboardTranslatorReader::parseAsMo
     if ( item == "shift" )
         modifier = Qt::ShiftModifier;
     else if ( item == "ctrl" || item == "control" )
         modifier = Qt::ControlModifier;
     else if ( item == "alt" )
         modifier = Qt::AltModifier;
     else if ( item == "meta" )
         modifier = Qt::MetaModifier;
-	else if ( item == "keypad" )
-		modifier = Qt::KeypadModifier;
+    else if ( item == "keypad" )
+        modifier = Qt::KeypadModifier;
     else
         return false;
 
     return true;
 }
 bool KeyboardTranslatorReader::parseAsStateFlag(const QString& item , KeyboardTranslator::State& flag)
 {
-    if ( item == "appcukeys" )
+    if ( item == "appcukeys" || item == "appcursorkeys" )
         flag = KeyboardTranslator::CursorKeysState;
     else if ( item == "ansi" )
         flag = KeyboardTranslator::AnsiState;
     else if ( item == "newline" )
         flag = KeyboardTranslator::NewLineState;
     else if ( item == "appscreen" )
         flag = KeyboardTranslator::AlternateScreenState;
-    else if ( item == "anymod" )
+    else if ( item == "anymod" || item == "anymodifier" )
         flag = KeyboardTranslator::AnyModifierState;
+    else if ( item == "appkeypad" )
+        flag = KeyboardTranslator::ApplicationKeypadState;
     else
         return false;
 
     return true;
 }
 bool KeyboardTranslatorReader::parseAsKeyCode(const QString& item , int& keyCode)
 {
     QKeySequence sequence = QKeySequence::fromString(item);
     if ( !sequence.isEmpty() )
     {
         keyCode = sequence[0];
 
         if ( sequence.count() > 1 )
         {
-            qDebug() << "Unhandled key codes in sequence: " << item;
+            //kWarning() << "Unhandled key codes in sequence: " << item;
         }
     }
     // additional cases implemented for backwards compatibility with KDE 3
     else if ( item == "prior" )
         keyCode = Qt::Key_PageUp;
     else if ( item == "next" )
         keyCode = Qt::Key_PageDown;
     else
@@ -466,69 +467,76 @@ bool KeyboardTranslatorReader::hasNextEn
 }
 KeyboardTranslator::Entry KeyboardTranslatorReader::createEntry( const QString& condition , 
                                                                  const QString& result )
 {
     QString entryString("keyboard \"temporary\"\nkey ");
     entryString.append(condition);
     entryString.append(" : ");
 
-	// if 'result' is the name of a command then the entry result will be that command,
-	// otherwise the result will be treated as a string to echo when the key sequence
-	// specified by 'condition' is pressed
-	KeyboardTranslator::Command command;
-	if (parseAsCommand(result,command))
-    	entryString.append(result);
-	else
-		entryString.append('\"' + result + '\"');
+    // if 'result' is the name of a command then the entry result will be that command,
+    // otherwise the result will be treated as a string to echo when the key sequence
+    // specified by 'condition' is pressed
+    KeyboardTranslator::Command command;
+    if (parseAsCommand(result,command))
+        entryString.append(result);
+    else
+        entryString.append('\"' + result + '\"');
 
     QByteArray array = entryString.toUtf8();
-
-    KeyboardTranslator::Entry entry;
-
     QBuffer buffer(&array);
     buffer.open(QIODevice::ReadOnly);
     KeyboardTranslatorReader reader(&buffer);
 
+    KeyboardTranslator::Entry entry;
     if ( reader.hasNextEntry() )
         entry = reader.nextEntry();
 
     return entry;
 }
 
 KeyboardTranslator::Entry KeyboardTranslatorReader::nextEntry() 
 {
     Q_ASSERT( _hasNext );
-
-
     KeyboardTranslator::Entry entry = _nextEntry;
-
     readNext();
-
     return entry;
 }
 bool KeyboardTranslatorReader::parseError()
 {
     return false;
 }
 QList<KeyboardTranslatorReader::Token> KeyboardTranslatorReader::tokenize(const QString& line)
 {
-    QString text = line.simplified();
+    QString text = line;
 
-    // comment line: # comment
-    static QRegExp comment("\\#.*");
+    // remove comments 
+    bool inQuotes = false;
+    int commentPos = -1;
+    for (int i=text.length()-1;i>=0;i--)
+    {
+        QChar ch = text[i];
+        if (ch == '\"')
+            inQuotes = !inQuotes;
+        else if (ch == '#' && !inQuotes)
+            commentPos = i;
+    }
+    if (commentPos != -1)
+        text.remove(commentPos,text.length());
+
+    text = text.simplified();
+   
     // title line: keyboard "title"
     static QRegExp title("keyboard\\s+\"(.*)\"");
     // key line: key KeySequence : "output"
     // key line: key KeySequence : command
-    static QRegExp key("key\\s+([\\w\\+\\s\\-]+)\\s*:\\s*(\"(.*)\"|\\w+)");
+    static QRegExp key("key\\s+([\\w\\+\\s\\-\\*\\.]+)\\s*:\\s*(\"(.*)\"|\\w+)");
 
     QList<Token> list;
-
-    if ( text.isEmpty() || comment.exactMatch(text) )
+    if ( text.isEmpty() ) 
     {
         return list;
     }
 
     if ( title.exactMatch(text) )
     {
         Token titleToken = { Token::TitleKeyword , QString() };
         Token textToken = { Token::TitleText , title.capturedTexts()[1] };
@@ -548,21 +556,21 @@ QList<KeyboardTranslatorReader::Token> K
             Token commandToken = { Token::Command , key.capturedTexts()[2] };
             list << commandToken;    
         }   
         else
         {
             // capturedTexts()[3] is the output string
            Token outputToken = { Token::OutputText , key.capturedTexts()[3] };
            list << outputToken;
-        }     
+        }    
     }
     else
     {
-        qWarning() << "Line in keyboard translator file could not be understood:" << text;
+        //kWarning() << "Line in keyboard translator file could not be understood:" << text;
     }
 
     return list;
 }
 
 QList<QString> KeyboardTranslatorManager::allTranslators() 
 {
     if ( !_haveLoadedAll )
@@ -591,45 +599,41 @@ bool KeyboardTranslator::Entry::operator
            _state == rhs._state &&
            _stateMask == rhs._stateMask &&
            _command == rhs._command &&
            _text == rhs._text;
 }
 
 bool KeyboardTranslator::Entry::matches(int keyCode , 
                                         Qt::KeyboardModifiers modifiers,
-                                        States state) const
+                                        States testState) const
 {
     if ( _keyCode != keyCode )
         return false;
 
     if ( (modifiers & _modifierMask) != (_modifiers & _modifierMask) ) 
         return false;
 
     // if modifiers is non-zero, the 'any modifier' state is implicit
     if ( modifiers != 0 )
-        state |= AnyModifierState;
+        testState |= AnyModifierState;
 
-    if ( (state & _stateMask) != (_state & _stateMask) )
+    if ( (testState & _stateMask) != (_state & _stateMask) )
         return false;
 
     // special handling for the 'Any Modifier' state, which checks for the presence of 
     // any or no modifiers.  In this context, the 'keypad' modifier does not count.
     bool anyModifiersSet = modifiers != 0 && modifiers != Qt::KeypadModifier;
+    bool wantAnyModifier = _state & KeyboardTranslator::AnyModifierState;
     if ( _stateMask & KeyboardTranslator::AnyModifierState )
     {
-        // test fails if any modifier is required but none are set
-        if ( (_state & KeyboardTranslator::AnyModifierState) && !anyModifiersSet )
+        if ( wantAnyModifier != anyModifiersSet )
            return false;
-
-        // test fails if no modifier is allowed but one or more are set
-        if ( !(_state & KeyboardTranslator::AnyModifierState) && anyModifiersSet )
-            return false;
     }
-
+    
     return true;
 }
 QByteArray KeyboardTranslator::Entry::escapedText(bool expandWildCards,Qt::KeyboardModifiers modifiers) const
 {
     QByteArray result(text(expandWildCards,modifiers));
 
     for ( int i = 0 ; i < result.count() ; i++ )
     {
@@ -648,17 +652,17 @@ QByteArray KeyboardTranslator::Entry::es
                 // any character which is not printable is replaced by an equivalent
                 // \xhh escape sequence (where 'hh' are the corresponding hex digits)
                 if ( !QChar(ch).isPrint() )
                     replacement = 'x';
         }
 
         if ( replacement == 'x' )
         {
-            result.replace(i,1,"\\x"+QByteArray(1,ch).toInt(0, 16)); 
+            result.replace(i,1,"\\x"+QByteArray(1,ch).toHex()); 
         } else if ( replacement != 0 )
         {
             result.remove(i,1);
             result.insert(i,'\\');
             result.insert(i+1,replacement);
         }
     }
 
@@ -671,55 +675,54 @@ QByteArray KeyboardTranslator::Entry::un
     for ( int i = 0 ; i < result.count()-1 ; i++ )
     {
 
         QByteRef ch = result[i];
         if ( ch == '\\' )
         {
            char replacement[2] = {0,0};
            int charsToRemove = 2;
-		   bool escapedChar = true;
+           bool escapedChar = true;
 
            switch ( result[i+1] )
            {
               case 'E' : replacement[0] = 27; break;
               case 'b' : replacement[0] = 8 ; break;
               case 'f' : replacement[0] = 12; break;
               case 't' : replacement[0] = 9 ; break;
               case 'r' : replacement[0] = 13; break;
               case 'n' : replacement[0] = 10; break;
               case 'x' :
-			  {
+                 {
                     // format is \xh or \xhh where 'h' is a hexadecimal
                     // digit from 0-9 or A-F which should be replaced
                     // with the corresponding character value
                     char hexDigits[3] = {0};
 
                     if ( (i < result.count()-2) && isxdigit(result[i+2]) )
                             hexDigits[0] = result[i+2];
                     if ( (i < result.count()-3) && isxdigit(result[i+3]) )
                             hexDigits[1] = result[i+3];
 
-                    int charValue = 0;
+                    unsigned charValue = 0;
                     sscanf(hexDigits,"%x",&charValue);
-                    
-                    replacement[0] = (char)charValue; 
 
+                    replacement[0] = (char)charValue; 
                     charsToRemove = 2 + strlen(hexDigits);
-			  }
+                  }
               break;
-			  default:
-			  		escapedChar = false;
+              default:
+                  escapedChar = false;
            }
 
            if ( escapedChar )
                result.replace(i,charsToRemove,replacement);
         }
     }
-    
+
     return result;
 }
 
 void KeyboardTranslator::Entry::insertModifier( QString& item , int modifier ) const
 {
     if ( !(modifier & _modifierMask) )
         return;
 
@@ -731,18 +734,18 @@ void KeyboardTranslator::Entry::insertMo
     if ( modifier == Qt::ShiftModifier )
         item += "Shift";
     else if ( modifier == Qt::ControlModifier )
         item += "Ctrl";
     else if ( modifier == Qt::AltModifier )
         item += "Alt";
     else if ( modifier == Qt::MetaModifier )
         item += "Meta";
-	else if ( modifier == Qt::KeypadModifier )
-		item += "KeyPad";
+    else if ( modifier == Qt::KeypadModifier )
+        item += "KeyPad";
 }
 void KeyboardTranslator::Entry::insertState( QString& item , int state ) const
 {
     if ( !(state & _stateMask) )
         return;
 
     if ( state & _state )
         item += '+' ;
@@ -751,26 +754,28 @@ void KeyboardTranslator::Entry::insertSt
 
     if ( state == KeyboardTranslator::AlternateScreenState )
         item += "AppScreen";
     else if ( state == KeyboardTranslator::NewLineState )
         item += "NewLine";
     else if ( state == KeyboardTranslator::AnsiState )
         item += "Ansi";
     else if ( state == KeyboardTranslator::CursorKeysState )
-        item += "AppCuKeys";
+        item += "AppCursorKeys";
     else if ( state == KeyboardTranslator::AnyModifierState )
-        item += "AnyMod";
+        item += "AnyModifier";
+    else if ( state == KeyboardTranslator::ApplicationKeypadState )
+        item += "AppKeypad";
 }
 QString KeyboardTranslator::Entry::resultToString(bool expandWildCards,Qt::KeyboardModifiers modifiers) const
 {
     if ( !_text.isEmpty() )
         return escapedText(expandWildCards,modifiers);
-	else if ( _command == EraseCommand )
-		return "Erase";
+    else if ( _command == EraseCommand )
+        return "Erase";
     else if ( _command == ScrollPageUpCommand )
         return "ScrollPageUp";
     else if ( _command == ScrollPageDownCommand )
         return "ScrollPageDown";
     else if ( _command == ScrollLineUpCommand )
         return "ScrollLineUp";
     else if ( _command == ScrollLineDownCommand )
         return "ScrollLineDown";
@@ -778,28 +783,28 @@ QString KeyboardTranslator::Entry::resul
         return "ScrollLock";
 
     return QString();
 }
 QString KeyboardTranslator::Entry::conditionToString() const
 {
     QString result = QKeySequence(_keyCode).toString();
 
-    // add modifiers
     insertModifier( result , Qt::ShiftModifier );
     insertModifier( result , Qt::ControlModifier );
     insertModifier( result , Qt::AltModifier );
-    insertModifier( result , Qt::MetaModifier ); 
+    insertModifier( result , Qt::MetaModifier );
+    insertModifier( result , Qt::KeypadModifier );
 
-    // add states
     insertState( result , KeyboardTranslator::AlternateScreenState );
     insertState( result , KeyboardTranslator::NewLineState );
     insertState( result , KeyboardTranslator::AnsiState );
     insertState( result , KeyboardTranslator::CursorKeysState );
     insertState( result , KeyboardTranslator::AnyModifierState );
+    insertState( result , KeyboardTranslator::ApplicationKeypadState );
 
     return result;
 }
 
 KeyboardTranslator::KeyboardTranslator(const QString& name)
 : _name(name)
 {
 }
@@ -824,73 +829,149 @@ QString KeyboardTranslator::name() const
 QList<KeyboardTranslator::Entry> KeyboardTranslator::entries() const
 {
     return _entries.values();
 }
 
 void KeyboardTranslator::addEntry(const Entry& entry)
 {
     const int keyCode = entry.keyCode();
-    _entries.insertMulti(keyCode,entry);
+    _entries.insert(keyCode,entry);
 }
 void KeyboardTranslator::replaceEntry(const Entry& existing , const Entry& replacement)
 {
     if ( !existing.isNull() )
-        _entries.remove(existing.keyCode());
-    _entries.insertMulti(replacement.keyCode(),replacement);
+        _entries.remove(existing.keyCode(),existing);
+    _entries.insert(replacement.keyCode(),replacement);
 }
 void KeyboardTranslator::removeEntry(const Entry& entry)
 {
-    _entries.remove(entry.keyCode());
+    _entries.remove(entry.keyCode(),entry);
 }
 KeyboardTranslator::Entry KeyboardTranslator::findEntry(int keyCode, Qt::KeyboardModifiers modifiers, States state) const
 {
-    if ( _entries.contains(keyCode) )
+    foreach(const Entry& entry, _entries.values(keyCode))
     {
-        QList<Entry> entriesForKey = _entries.values(keyCode);
-        
-        QListIterator<Entry> iter(entriesForKey);
-
-        while (iter.hasNext())
-        {
-            const Entry& next = iter.next();
-            if ( next.matches(keyCode,modifiers,state) )
-                return next;
-        }
-
-        return Entry(); // entry not found
+        if ( entry.matches(keyCode,modifiers,state) )
+            return entry;
     }
-    else
-    {
-        return Entry();
-    }
-    
+    return Entry(); // entry not found
 }
 void KeyboardTranslatorManager::addTranslator(KeyboardTranslator* translator)
 {
     _translators.insert(translator->name(),translator);
 
-    if ( !saveTranslator(translator) )
-        qWarning() << "Unable to save translator" << translator->name()
-                   << "to disk.";
+  //  if ( !saveTranslator(translator) )
+  //      kWarning() << "Unable to save translator" << translator->name()
+    //               << "to disk.";
 }
 bool KeyboardTranslatorManager::deleteTranslator(const QString& name)
 {
     Q_ASSERT( _translators.contains(name) );
 
     // locate and delete
     QString path = findTranslatorPath(name);
     if ( QFile::remove(path) )
     {
         _translators.remove(name);
         return true; 
     }
     else
     {
-        qWarning() << "Failed to remove translator - " << path;
+        //kWarning() << "Failed to remove translator - " << path;
         return false;
     }
 }
+
+/**
+ * @internal
+ */
+typedef void (*KdeCleanUpFunction)();
+
+/**
+ * @internal
+ *
+ * Helper class for K_GLOBAL_STATIC to clean up the object on library unload or application
+ * shutdown.
+ */
+class KCleanUpGlobalStatic
+{
+    public:
+        KdeCleanUpFunction func;
+
+        inline ~KCleanUpGlobalStatic() { func(); }
+};
+
+
+
+#ifdef Q_CC_MSVC
+/**
+ * @internal
+ *
+ * MSVC seems to give anonymous structs the same name which fails at link time. So instead we name
+ * the struct and hope that by adding the line number to the name it's unique enough to never clash.
+ */
+# define K_GLOBAL_STATIC_STRUCT_NAME(NAME) _k_##NAME##__LINE__
+#else
+/**
+ * @internal
+ *
+ * Make the struct of the K_GLOBAL_STATIC anonymous.
+ */
+# define K_GLOBAL_STATIC_STRUCT_NAME(NAME)
+#endif
+
+
+
+#define K_GLOBAL_STATIC_WITH_ARGS(TYPE, NAME, ARGS)                            \
+static QBasicAtomicPointer<TYPE > _k_static_##NAME = Q_BASIC_ATOMIC_INITIALIZER(0); \
+static bool _k_static_##NAME##_destroyed;                                      \
+static struct K_GLOBAL_STATIC_STRUCT_NAME(NAME)                                \
+{                                                                              \
+    inline bool isDestroyed() const                                            \
+    {                                                                          \
+        return _k_static_##NAME##_destroyed;                                   \
+    }                                                                          \
+    inline bool exists() const                                                 \
+    {                                                                          \
+        return _k_static_##NAME != 0;                                          \
+    }                                                                          \
+    inline operator TYPE*()                                                    \
+    {                                                                          \
+        return operator->();                                                   \
+    }                                                                          \
+    inline TYPE *operator->()                                                  \
+    {                                                                          \
+        if (!_k_static_##NAME) {                                               \
+            if (isDestroyed()) {                                               \
+                qFatal("Fatal Error: Accessed global static '%s *%s()' after destruction. " \
+                       "Defined at %s:%d", #TYPE, #NAME, __FILE__, __LINE__);  \
+            }                                                                  \
+            TYPE *x = new TYPE ARGS;                                           \
+            if (!_k_static_##NAME.testAndSetOrdered(0, x)                      \
+                && _k_static_##NAME != x ) {                                   \
+                delete x;                                                      \
+            } else {                                                           \
+                static KCleanUpGlobalStatic cleanUpObject = { destroy };       \
+            }                                                                  \
+        }                                                                      \
+        return _k_static_##NAME;                                               \
+    }                                                                          \
+    inline TYPE &operator*()                                                   \
+    {                                                                          \
+        return *operator->();                                                  \
+    }                                                                          \
+    static void destroy()                                                      \
+    {                                                                          \
+        _k_static_##NAME##_destroyed = true;                                   \
+        TYPE *x = _k_static_##NAME;                                            \
+        _k_static_##NAME = 0;                                                  \
+        delete x;                                                              \
+    }                                                                          \
+} NAME;
+
+#define K_GLOBAL_STATIC(TYPE, NAME) K_GLOBAL_STATIC_WITH_ARGS(TYPE, NAME, ())
+
 K_GLOBAL_STATIC( KeyboardTranslatorManager , theKeyboardTranslatorManager )
 KeyboardTranslatorManager* KeyboardTranslatorManager::instance()
 {
     return theKeyboardTranslatorManager;
 }
diff --git a/gui//src/KeyboardTranslator.h b/gui//src/KeyboardTranslator.h
--- a/gui//src/KeyboardTranslator.h
+++ b/gui//src/KeyboardTranslator.h
@@ -1,14 +1,12 @@
 /*
     This source file is part of Konsole, a terminal emulator.
 
-    Copyright (C) 2007 by Robert Knight <robertknight@gmail.com>
-
-    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+    Copyright 2007-2008 by Robert Knight <robertknight@gmail.com>
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
 
     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -25,92 +23,19 @@
 #define KEYBOARDTRANSLATOR_H
 
 // Qt
 #include <QtCore/QHash>
 #include <QtCore/QList>
 #include <QtGui/QKeySequence>
 #include <QtCore/QMetaType>
 #include <QtCore/QVarLengthArray>
-#include <QtCore>
 
-typedef void (*CleanUpFunction)();
-
-/**
- * @internal
- *
- * Helper class for K_GLOBAL_STATIC to clean up the object on library unload or application
- * shutdown.
- */
-class CleanUpGlobalStatic
-{
-    public:
-        CleanUpFunction func;
-
-        inline ~CleanUpGlobalStatic() { func(); }
-};
-
-
-//these directives are taken from the heart of kdecore
-
-# define K_GLOBAL_STATIC_STRUCT_NAME(NAME)
-
-#if QT_VERSION < 0x040400
-# define Q_BASIC_ATOMIC_INITIALIZER     Q_ATOMIC_INIT
-# define testAndSetOrdered              testAndSet
-#endif
-
-#define K_GLOBAL_STATIC(TYPE, NAME) K_GLOBAL_STATIC_WITH_ARGS(TYPE, NAME, ())
-
-#define K_GLOBAL_STATIC_WITH_ARGS(TYPE, NAME, ARGS)                            \
-static QBasicAtomicPointer<TYPE > _k_static_##NAME = Q_BASIC_ATOMIC_INITIALIZER(0); \
-static bool _k_static_##NAME##_destroyed;                                      \
-static struct K_GLOBAL_STATIC_STRUCT_NAME(NAME)                                \
-{                                                                              \
-    bool isDestroyed()                                                         \
-    {                                                                          \
-        return _k_static_##NAME##_destroyed;                                   \
-    }                                                                          \
-    inline operator TYPE*()                                                    \
-    {                                                                          \
-        return operator->();                                                   \
-    }                                                                          \
-    inline TYPE *operator->()                                                  \
-    {                                                                          \
-        if (!_k_static_##NAME) {                                               \
-            if (isDestroyed()) {                                               \
-            qFatal("Fatal Error: Accessed global static '%s *%s()' after destruction. " \
-             "Defined at %s:%d", #TYPE, #NAME, __FILE__, __LINE__);		\
-	     }                                                                  \
-	     TYPE *x = new TYPE ARGS;                                           \
-	     if (!_k_static_##NAME.testAndSetOrdered(0, x)                      \
-	         && _k_static_##NAME != x ) {                                   \
-	         delete x;                                                      \
-	     } else { 								\
-		static CleanUpGlobalStatic cleanUpObject = { destroy };	\
-	     }   								\
-	 }                                                                      \
-         return _k_static_##NAME;                                               \
-    }            								\
-    inline TYPE &operator*()                                                   \
-    {                                                                          \
-        return *operator->();                                                  \
-    }                                                                          \
-    static void destroy()                                                      \
-    {                                                                          \
-        _k_static_##NAME##_destroyed = true;                                   \
-        TYPE *x = _k_static_##NAME;                                            \
-        _k_static_##NAME = 0;                                                  \
-        delete x;                                                              \
-    }                                                                          \
-} NAME;
-								
-								
-
-
+// Konsole
+#include "konsole_export.h"
 
 class QIODevice;
 class QTextStream;
 
 /** 
  * A convertor which maps between key sequences pressed by the user and the
  * character strings which should be sent to the terminal and commands
  * which should be invoked when those character sequences are pressed.
@@ -152,17 +77,19 @@ public:
          */
         CursorKeysState = 4,
         /**
          * Indicates that the alternate screen ( typically used by interactive programs
          * such as screen or vim ) is active 
          */
         AlternateScreenState = 8,
         /** Indicates that any of the modifier keys is active. */ 
-        AnyModifierState = 16
+        AnyModifierState = 16,
+        /** Indicates that the numpad is in application mode. */
+        ApplicationKeypadState = 32
     };
     Q_DECLARE_FLAGS(States,State)
 
     /**
      * This enum describes commands which are associated with particular key sequences.
      */
     enum Command
     {
@@ -175,18 +102,18 @@ public:
         /** Scroll the terminal display down one page */
         ScrollPageDownCommand = 4,
         /** Scroll the terminal display up one line */
         ScrollLineUpCommand = 8,
         /** Scroll the terminal display down one line */
         ScrollLineDownCommand = 16,
         /** Toggles scroll lock mode */
         ScrollLockCommand = 32,
-		/** Echos the operating system specific erase character. */
-		EraseCommand = 64
+        /** Echos the operating system specific erase character. */
+        EraseCommand = 64
     };
     Q_DECLARE_FLAGS(Commands,Command)
 
     /**
      * Represents an association between a key sequence pressed by the user
      * and the character sequence and commands associated with it for a particular
      * KeyboardTranslator.
      */
@@ -376,17 +303,17 @@ public:
      */
     void removeEntry(const Entry& entry);
 
     /** Returns a list of all entries in the translator. */
     QList<Entry> entries() const;
 
 private:
 
-    QHash<int,Entry> _entries; // entries in this keyboard translation,
+    QMultiHash<int,Entry> _entries; // entries in this keyboard translation,
                                                  // entries are indexed according to
                                                  // their keycode
     QString _name;
     QString _description;
 };
 Q_DECLARE_OPERATORS_FOR_FLAGS(KeyboardTranslator::States)
 Q_DECLARE_OPERATORS_FOR_FLAGS(KeyboardTranslator::Commands)
 
@@ -471,17 +398,17 @@ private:
                                 Qt::KeyboardModifiers& modifiers,
                                 Qt::KeyboardModifiers& modifierMask,
                                 KeyboardTranslator::States& state,
                                 KeyboardTranslator::States& stateFlags);
 
     static bool parseAsModifier(const QString& item , Qt::KeyboardModifier& modifier);
     static bool parseAsStateFlag(const QString& item , KeyboardTranslator::State& state);
     static bool parseAsKeyCode(const QString& item , int& keyCode);
-   	static bool parseAsCommand(const QString& text , KeyboardTranslator::Command& command);
+       static bool parseAsCommand(const QString& text , KeyboardTranslator::Command& command);
 
     QIODevice* _source;
     QString _description;
     KeyboardTranslator::Entry _nextEntry;
     bool _hasNext;
 };
 
 /** Writes a keyboard translation to disk. */
@@ -507,17 +434,17 @@ private:
     QIODevice* _destination;  
     QTextStream* _writer;
 };
 
 /**
  * Manages the keyboard translations available for use by terminal sessions,
  * see KeyboardTranslator.
  */
-class KeyboardTranslatorManager
+class KONSOLEPRIVATE_EXPORT KeyboardTranslatorManager
 {
 public:
     /** 
      * Constructs a new KeyboardTranslatorManager and loads the list of
      * available keyboard translations.
      *
      * The keyboard translations themselves are not loaded until they are
      * first requested via a call to findTranslator()
@@ -558,17 +485,17 @@ public:
      * translators is started.
      */
     QList<QString> allTranslators();
 
     /** Returns the global KeyboardTranslatorManager instance. */
    static KeyboardTranslatorManager* instance();
 
 private:
-    static const char* defaultTranslatorText;
+    static const QByteArray defaultTranslatorText;
     
     void findTranslators(); // locate the available translators
     KeyboardTranslator* loadTranslator(const QString& name); // loads the translator 
                                                              // with the given name
     KeyboardTranslator* loadTranslator(QIODevice* device,const QString& name);
 
     bool saveTranslator(const KeyboardTranslator* translator);
     QString findTranslatorPath(const QString& name);
diff --git a/gui//src/MainWindow.cpp b/gui//src/MainWindow.cpp
--- a/gui//src/MainWindow.cpp
+++ b/gui//src/MainWindow.cpp
@@ -19,16 +19,17 @@
 #include <QMenuBar>
 #include <QMenu>
 #include <QAction>
 #include <QtWebKit/QWebView>
 
 #include "MainWindow.h"
 #include "TerminalMdiSubWindow.h"
 
+
 MainWindow::MainWindow(QWidget *parent)
     : QMainWindow(parent) {
     constructWindow();
 
     loadWebPage("Online Manual", "http://www.gnu.org/software/octave/doc/interpreter/");
     showMaximized();
 }
 
diff --git a/gui//src/MainWindow.h b/gui//src/MainWindow.h
--- a/gui//src/MainWindow.h
+++ b/gui//src/MainWindow.h
@@ -17,16 +17,17 @@
  */
 
 #ifndef MAINWINDOW_H
 #define MAINWINDOW_H
 
 #include <QtGui/QMainWindow>
 #include <QMdiArea>
 
+
 /**
   * \class MainWindow
   *
   * Represents the main window.
   */
 class MainWindow : public QMainWindow
 {
     Q_OBJECT
diff --git a/gui//src/OctaveLink.cpp b/gui//src/OctaveLink.cpp
--- a/gui//src/OctaveLink.cpp
+++ b/gui//src/OctaveLink.cpp
@@ -123,56 +123,46 @@ int server_rl_event_hook_function(void)
 }
 
 bool server_rl_is_processing(void)
 {
   return oct_octave_server.isProcessing();
 }
 
 //*************************************************************************
-OctaveLink::OctaveLink()
-{
-  // Create the mutexes 
+OctaveLink::OctaveLink() {
   pthread_mutex_init(&m_serverMutex,NULL);
   pthread_mutex_init(&m_octaveLockMutex,NULL);
-
   m_previousHistoryLength = 0;
-
   m_isProcessingServerData = false;
 }
 
-
-//*************************************************************************
-OctaveLink::~OctaveLink()
-{
-
+OctaveLink::~OctaveLink() {
 }
 
 /*******************************************************************************
  *******************************************************************************
  * CLIENT SIDE FUNCTIONS
  *******************************************************************************
  *******************************************************************************/
 
 //*************************************************************************
-std::vector<OctaveLink::VariableMetaData> OctaveLink::variableInfoList(void)
-{
-  // Acquire the mutex
-  if( pthread_mutex_trylock( &m_serverMutex ) != 0 )
-    return std::vector<VariableMetaData>();
+std::vector<OctaveLink::VariableMetaData> OctaveLink::variableInfoList(void) {
+    // Acquire the mutex
+    if( pthread_mutex_trylock( &m_serverMutex ) != 0 )
+        return std::vector<VariableMetaData>();
 
-  // Copy the list of variable information
-  std::vector<VariableMetaData> retval( m_variableSymbolTableList.size() );
-  std::copy( m_variableSymbolTableList.begin(), m_variableSymbolTableList.end(), retval.begin() );
-  m_variableSymbolTableList = std::vector<VariableMetaData>();
+    // Copy the list of variable information
+    std::vector<VariableMetaData> retval( m_variableSymbolTableList.size() );
+    std::copy( m_variableSymbolTableList.begin(), m_variableSymbolTableList.end(), retval.begin() );
+    m_variableSymbolTableList = std::vector<VariableMetaData>();
 
-  // Release the mutex
-  pthread_mutex_unlock( &m_serverMutex );
-
-  return retval;
+    // Release the mutex
+    pthread_mutex_unlock( &m_serverMutex );
+    return retval;
 }
 
 
 //*************************************************************************
 std::vector<OctaveLink::RequestedVariable> OctaveLink::requestedVariables(void)
 {
   // Acquire the mutex
   if( pthread_mutex_trylock( &m_serverMutex ) != 0 )
@@ -369,18 +359,16 @@ int OctaveLink::processOctaveServerData(
   pthread_mutex_unlock( &m_serverMutex );
   m_isProcessingServerData = false;
 
 #ifndef __WIN32__
   gettimeofday(&stop, NULL);
   double elapsed = stop.tv_sec - start.tv_sec + 1E-6 * (stop.tv_usec - start.tv_usec);
   //octave_stdout << "SERVER ELAPSED: " << elapsed << std::endl;
 #endif
-
-
   return 0;
 }
 
 
 //*************************************************************************
 int OctaveLink::setVariableInfoList( void )
 {
   static std::vector<VariableMetaData> lastVars;
@@ -565,19 +553,16 @@ int OctaveLink::setBreakPointList( void 
 	  
 	  //	  octave_stdout << "BP reached at " << tmp.filename << ":" << tmp.line_number << std::endl;
 
           m_reachedBreakpoints.push_back (tmp);
         }
       else
         octave_stdout << " <unknown line>" << std::endl;
     }
-
-  
-
   return 0;
 }
 
 //*************************************************************************
 int OctaveLink::process_breakpoint_action (void)
 {
 
   if (Vdebugging)
@@ -660,16 +645,10 @@ int OctaveLink::processBreakpointAndRemo
   {
     std::string funcName = m_removedBreakpoints[i].fileName;
     bp_table::intmap lines;
     lines[0] = m_removedBreakpoints[i].lineNumber;
     bp_table::remove_breakpoint (funcName,lines);
     //octave_stdout << "Removing breakpoint: " << funcName << " : " << lines[0] << std::endl; 
   }
   m_removedBreakpoints = std::vector<BreakPoint>();
-
-  // Process modified breakpoints
-  // TODO:
-
-
-
   return 0;
 }
diff --git a/gui//src/ProcessInfo.cpp b/gui//src/ProcessInfo.cpp
new file mode 100644
--- /dev/null
+++ b/gui//src/ProcessInfo.cpp
@@ -0,0 +1,1121 @@
+/*
+    Copyright 2007-2008 by Robert Knight <robertknight@gmail.countm>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+// Own
+#include "ProcessInfo.h"
+//#include <config-konsole.h>
+
+// Unix
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <unistd.h>
+#include <pwd.h>
+
+// Qt
+//#include <KDebug>
+#include <QtCore/QDir>
+#include <QtCore/QFileInfo>
+#include <QtCore/QRegExp>
+#include <QtCore/QTextStream>
+#include <QtCore/QStringList>
+#include <QtCore/QSet>
+//#include "kdebug.h"
+
+// KDE
+#include "konsole_export.h"
+//#include <KConfigGroup>
+//#include <KGlobal>
+//#include <KSharedConfig>
+//#include <KUser>
+
+#if defined(Q_OS_MAC)
+#include <sys/sysctl.h>
+#include <libproc.h>
+#ifdef HAVE_SYS_PROC_INFO_H
+#include <sys/proc_info.h>
+#endif
+#ifdef HAVE_SYS_PROC_H
+#include <sys/proc.h>
+#endif
+//#include <kde_file.h>
+#define KDE_struct_stat struct stat
+#define KDE_stat ::stat
+#endif
+
+#if defined(Q_OS_FREEBSD)
+#include <sys/sysctl.h> //krazy:exclude=includes
+#include <sys/types.h>
+#include <sys/user.h>
+#include <sys/syslimits.h>
+#include <libutil.h>
+#endif
+
+ProcessInfo::ProcessInfo(int pid , bool enableEnvironmentRead)
+    : _fields( ARGUMENTS | ENVIRONMENT ) // arguments and environments
+                                         // are currently always valid,
+                                         // they just return an empty
+                                         // vector / map respectively
+                                         // if no arguments
+                                         // or environment bindings
+                                         // have been explicitly set
+    , _enableEnvironmentRead(enableEnvironmentRead)
+    , _pid(pid)
+    , _parentPid(0)
+    , _foregroundPid(0)
+    , _userId(0)
+    , _lastError(NoError)
+    , _userName(QString())
+    , _userHomeDir(QString())
+{
+}
+
+ProcessInfo::Error ProcessInfo::error() const { return _lastError; }
+void ProcessInfo::setError(Error error) { _lastError = error; }
+
+void ProcessInfo::update() 
+{
+    readProcessInfo(_pid,_enableEnvironmentRead);
+}
+
+QString ProcessInfo::validCurrentDir() const
+{
+   bool ok = false;
+
+   // read current dir, if an error occurs try the parent as the next
+   // best option
+   int currentPid = parentPid(&ok);
+   QString dir = currentDir(&ok);
+   while ( !ok && currentPid != 0 )
+   {
+       ProcessInfo* current = ProcessInfo::newInstance(currentPid);
+       current->update();
+       currentPid = current->parentPid(&ok); 
+       dir = current->currentDir(&ok);
+       delete current;
+   }
+
+   return dir;
+}
+
+QString ProcessInfo::format(const QString& input) const
+{
+   bool ok = false;
+
+   QString output(input);
+
+   // search for and replace known marker
+   output.replace("%u",userName());
+   output.replace("%n",name(&ok));
+   output.replace("%c",formatCommand(name(&ok),arguments(&ok),ShortCommandFormat));
+   output.replace("%C",formatCommand(name(&ok),arguments(&ok),LongCommandFormat));
+   
+   QString dir = validCurrentDir();
+   if (output.contains("%D"))
+   {
+      QString homeDir = userHomeDir();
+      QString tempDir = dir;
+      // Change User's Home Dir w/ ~ only at the beginning
+      if (tempDir.startsWith(homeDir))
+      {
+         tempDir.remove(0, homeDir.length());
+         tempDir.prepend('~');
+      }
+      output.replace("%D", tempDir);
+   }
+   output.replace("%d",formatShortDir(dir));
+   
+   // remove any remaining %[LETTER] sequences
+   // output.replace(QRegExp("%\\w"), QString());
+
+   return output;
+}
+
+QString ProcessInfo::formatCommand(const QString& name, 
+                                   const QVector<QString>& arguments,
+                                   CommandFormat format) const
+{
+    Q_UNUSED(name);
+    Q_UNUSED(format);
+
+    // TODO Implement me
+    return QStringList(QList<QString>::fromVector(arguments)).join(" ");
+}
+
+QSet<QString> ProcessInfo::_commonDirNames;
+
+QSet<QString> ProcessInfo::commonDirNames() 
+{
+  // JPS: Don't know of a good replacement for this in QT
+  /*
+    if ( _commonDirNames.isEmpty() )
+    {
+        KSharedConfigPtr config = KGlobal::config();
+        KConfigGroup configGroup = config->group("ProcessInfo");
+
+        QStringList defaults = QStringList() 
+                             << "src" << "build" << "debug" << "release" 
+                             << "bin" << "lib"   << "libs"  << "tmp" 
+                             << "doc" << "docs"  << "data"  << "share"
+                             << "examples" << "icons" << "pics" << "plugins" 
+                             << "tests" << "media" << "l10n" << "include" 
+                             << "includes" << "locale" << "ui";
+
+        _commonDirNames = QSet<QString>::fromList(configGroup.readEntry("CommonDirNames",defaults));
+
+    }
+  */
+    return _commonDirNames;
+}
+
+QString ProcessInfo::formatShortDir(const QString& input) const
+{
+    QString result;
+
+    QStringList parts = input.split( QDir::separator() );
+
+    // temporarily hard-coded
+    QSet<QString> dirNamesToShorten = commonDirNames();
+
+    QListIterator<QString> iter(parts);
+    iter.toBack();
+
+    // go backwards through the list of the path's parts
+    // adding abbreviations of common directory names
+    // and stopping when we reach a dir name which is not
+    // in the commonDirNames set
+    while ( iter.hasPrevious() )
+    {
+        QString part = iter.previous();
+
+        if ( dirNamesToShorten.contains(part) )
+        {
+            result.prepend(QDir::separator() + part[0]);
+        }
+        else
+        {
+            result.prepend(part);
+            break;
+        }
+    }
+
+    return result;
+}
+
+QVector<QString> ProcessInfo::arguments(bool* ok) const
+{
+    *ok = _fields & ARGUMENTS;
+
+    return _arguments;
+}
+
+QMap<QString,QString> ProcessInfo::environment(bool* ok) const
+{
+    *ok = _fields & ENVIRONMENT;
+
+    return _environment;
+}
+
+bool ProcessInfo::isValid() const
+{
+    return _fields & PROCESS_ID;
+}
+
+int ProcessInfo::pid(bool* ok) const
+{
+    *ok = _fields & PROCESS_ID;
+
+    return _pid;
+}
+
+int ProcessInfo::parentPid(bool* ok) const
+{
+    *ok = _fields & PARENT_PID;
+
+    return _parentPid;
+}
+
+int ProcessInfo::foregroundPid(bool* ok) const
+{
+    *ok = _fields & FOREGROUND_PID;
+
+    return _foregroundPid;
+}
+
+QString ProcessInfo::name(bool* ok) const
+{
+    *ok = _fields & NAME;
+
+    return _name;
+}
+
+int ProcessInfo::userId(bool* ok) const
+{
+    *ok = _fields & UID;
+
+    return _userId;
+}
+
+QString ProcessInfo::userName() const
+{
+    return _userName;
+}
+
+QString ProcessInfo::userHomeDir() const
+{
+    return _userHomeDir;
+}
+
+void ProcessInfo::setPid(int pid)
+{
+    _pid = pid;
+    _fields |= PROCESS_ID;
+}
+
+void ProcessInfo::setUserId(int uid)
+{
+    _userId = uid;
+    _fields |= UID;
+}
+
+void ProcessInfo::setUserName(const QString& name)
+{
+    _userName = name;
+    setUserHomeDir();
+}
+
+void ProcessInfo::setUserHomeDir()
+{
+    QString usersName = userName();
+    // JPS: I don't know a good QT replacement
+    //if (!usersName.isEmpty())
+    //    _userHomeDir = KUser(usersName).homeDir();
+    //else
+        _userHomeDir = QDir::homePath();
+}
+
+void ProcessInfo::setParentPid(int pid)
+{
+    _parentPid = pid;
+    _fields |= PARENT_PID;
+}
+void ProcessInfo::setForegroundPid(int pid)
+{
+    _foregroundPid = pid;
+    _fields |= FOREGROUND_PID;
+}
+
+QString ProcessInfo::currentDir(bool* ok) const
+{
+    if (ok)
+        *ok = _fields & CURRENT_DIR;
+
+    return _currentDir;
+}
+void ProcessInfo::setCurrentDir(const QString& dir)
+{
+    _fields |= CURRENT_DIR;
+    _currentDir = dir;
+}
+
+void ProcessInfo::setName(const QString& name)
+{
+    _name = name;
+    _fields |= NAME;
+}
+void ProcessInfo::addArgument(const QString& argument)
+{
+    _arguments << argument;    
+}
+
+void ProcessInfo::addEnvironmentBinding(const QString& name , const QString& value)
+{
+    _environment.insert(name,value);
+}
+
+void ProcessInfo::setFileError( QFile::FileError error )
+{
+    switch ( error )
+    {
+        case PermissionsError:
+            setError( PermissionsError );
+            break;
+        case NoError:
+            setError( NoError );
+            break;
+        default:
+            setError( UnknownError );
+    }
+}
+
+//
+// ProcessInfo::newInstance() is way at the bottom so it can see all of the
+// implementations of the UnixProcessInfo abstract class.
+//
+
+NullProcessInfo::NullProcessInfo(int pid,bool enableEnvironmentRead)
+    : ProcessInfo(pid,enableEnvironmentRead)
+{
+}
+
+bool NullProcessInfo::readProcessInfo(int /*pid*/ , bool /*enableEnvironmentRead*/)
+{
+    return false;
+}
+
+void NullProcessInfo::readUserName()
+{
+}
+
+UnixProcessInfo::UnixProcessInfo(int pid,bool enableEnvironmentRead)
+    : ProcessInfo(pid,enableEnvironmentRead)
+{
+}
+
+bool UnixProcessInfo::readProcessInfo(int pid , bool enableEnvironmentRead)
+{
+    bool ok = readProcInfo(pid);
+    if (ok)
+    {
+        ok |= readArguments(pid);
+        ok |= readCurrentDir(pid);
+        if ( enableEnvironmentRead )
+        {
+            ok |= readEnvironment(pid);
+        }
+    }
+    return ok;
+}
+
+void UnixProcessInfo::readUserName()
+{
+    bool ok = false;
+    int uid = userId(&ok);
+    if (!ok) return;
+
+    struct passwd passwdStruct;
+    struct passwd *getpwResult;
+    char *getpwBuffer;
+    long getpwBufferSize;
+    int getpwStatus;
+
+    getpwBufferSize = sysconf(_SC_GETPW_R_SIZE_MAX);
+    if (getpwBufferSize == -1)
+        getpwBufferSize = 16384;
+
+    getpwBuffer = new char[getpwBufferSize];
+    if (getpwBuffer == NULL)
+        return;
+    getpwStatus = getpwuid_r(uid, &passwdStruct, getpwBuffer, getpwBufferSize, &getpwResult);
+    if (getpwResult != NULL)
+        setUserName(QString(passwdStruct.pw_name));
+    else
+        setUserName(QString());
+    delete [] getpwBuffer;
+}
+
+
+class LinuxProcessInfo : public UnixProcessInfo
+{
+public:
+    LinuxProcessInfo(int pid, bool env) :
+        UnixProcessInfo(pid,env)
+    {
+    }
+
+private:
+    virtual bool readProcInfo(int pid)
+    {
+        // indicies of various fields within the process status file which
+        // contain various information about the process
+        const int PARENT_PID_FIELD = 3;
+        const int PROCESS_NAME_FIELD = 1;
+        const int GROUP_PROCESS_FIELD = 7;
+
+        QString parentPidString;
+        QString processNameString;
+        QString foregroundPidString;
+        QString uidLine;
+        QString uidString;
+        QStringList uidStrings;
+
+        // For user id read process status file ( /proc/<pid>/status )
+        //  Can not use getuid() due to it does not work for 'su'
+        QFile statusInfo( QString("/proc/%1/status").arg(pid) );
+        if ( statusInfo.open(QIODevice::ReadOnly) )
+        {
+            QTextStream stream(&statusInfo);
+            QString statusLine;
+            do {
+                statusLine = stream.readLine(0);
+                if (statusLine.startsWith(QLatin1String("Uid:")))
+                    uidLine = statusLine;
+            } while (!statusLine.isNull() && uidLine.isNull());
+
+            uidStrings << uidLine.split('\t', QString::SkipEmptyParts);
+            // Must be 5 entries: 'Uid: %d %d %d %d' and
+            // uid string must be less than 5 chars (uint)
+            if (uidStrings.size() == 5)
+                uidString = uidStrings[1];
+            if (uidString.size() > 5)
+                uidString.clear();
+
+            bool ok = false;
+            int uid = uidString.toInt(&ok);
+            if (ok)
+                setUserId(uid);
+            readUserName();
+        }
+        else
+        {
+            setFileError( statusInfo.error() );
+            return false;
+        }
+
+
+        // read process status file ( /proc/<pid/stat )
+        //
+        // the expected file format is a list of fields separated by spaces, using
+        // parenthesies to escape fields such as the process name which may itself contain
+        // spaces:
+        //
+        // FIELD FIELD (FIELD WITH SPACES) FIELD FIELD
+        //
+        QFile processInfo( QString("/proc/%1/stat").arg(pid) );
+        if ( processInfo.open(QIODevice::ReadOnly) )
+        {
+            QTextStream stream(&processInfo);
+            QString data = stream.readAll();
+
+            int stack = 0;
+            int field = 0;
+            int pos = 0;
+
+            while (pos < data.count())
+            {
+                QChar c = data[pos];
+
+                if ( c == '(' )
+                    stack++;
+                else if ( c == ')' )
+                    stack--;
+                else if ( stack == 0 && c == ' ' )
+                    field++;
+                else
+                {
+                    switch ( field )
+                    {
+                        case PARENT_PID_FIELD:
+                            parentPidString.append(c);
+                            break;
+                        case PROCESS_NAME_FIELD:
+                            processNameString.append(c);
+                            break;
+                        case GROUP_PROCESS_FIELD:
+                            foregroundPidString.append(c);
+                            break;
+                    }
+                }
+
+                pos++;
+            }
+        }
+        else
+        {
+            setFileError( processInfo.error() );
+            return false;
+        }
+
+        // check that data was read successfully
+        bool ok = false;
+        int foregroundPid = foregroundPidString.toInt(&ok);
+        if (ok)
+            setForegroundPid(foregroundPid);
+
+        int parentPid = parentPidString.toInt(&ok);
+        if (ok)
+            setParentPid(parentPid);
+
+        if (!processNameString.isEmpty())
+            setName(processNameString);
+
+        // update object state
+        setPid(pid);
+
+        return ok;
+    }
+
+    virtual bool readArguments(int pid)
+    {
+        // read command-line arguments file found at /proc/<pid>/cmdline
+        // the expected format is a list of strings delimited by null characters,
+        // and ending in a double null character pair.
+
+        QFile argumentsFile( QString("/proc/%1/cmdline").arg(pid) );
+        if ( argumentsFile.open(QIODevice::ReadOnly) )
+        {
+            QTextStream stream(&argumentsFile);
+            QString data = stream.readAll();
+
+            QStringList argList = data.split( QChar('\0') );
+
+            foreach ( const QString &entry , argList )
+            {
+                if (!entry.isEmpty())
+                    addArgument(entry);
+            }
+        }
+        else
+        {
+            setFileError( argumentsFile.error() );
+        }
+
+        return true;
+    }
+
+    virtual bool readCurrentDir(int pid)
+    {
+        QFileInfo info( QString("/proc/%1/cwd").arg(pid) );
+
+        const bool readable = info.isReadable();
+
+        if ( readable && info.isSymLink() )
+        {
+            setCurrentDir( info.symLinkTarget() );
+            return true;
+        }
+        else
+        {
+            if ( !readable )
+                setError( PermissionsError );
+            else
+                setError( UnknownError );
+
+            return false;
+        }
+    }
+
+    virtual bool readEnvironment(int pid)
+    {
+        // read environment bindings file found at /proc/<pid>/environ
+        // the expected format is a list of KEY=VALUE strings delimited by null
+        // characters and ending in a double null character pair.
+
+        QFile environmentFile( QString("/proc/%1/environ").arg(pid) );
+        if ( environmentFile.open(QIODevice::ReadOnly) )
+        {
+            QTextStream stream(&environmentFile);
+            QString data = stream.readAll();
+
+            QStringList bindingList = data.split( QChar('\0') );
+
+            foreach( const QString &entry , bindingList )
+            {
+                QString name;
+                QString value;
+
+                int splitPos = entry.indexOf('=');
+
+                if ( splitPos != -1 )
+                {
+                    name = entry.mid(0,splitPos);
+                    value = entry.mid(splitPos+1,-1);
+
+                    addEnvironmentBinding(name,value);
+                }
+            }
+        }
+        else
+        {
+            setFileError( environmentFile.error() );
+        }
+
+        return true;
+    }
+} ;
+
+#if defined(Q_OS_FREEBSD)
+class FreeBSDProcessInfo : public UnixProcessInfo
+{
+public:
+    FreeBSDProcessInfo(int pid, bool readEnvironment) :
+        UnixProcessInfo(pid, readEnvironment)
+    {
+    }
+
+private:
+    virtual bool readProcInfo(int pid)
+    {
+        int managementInfoBase[4];
+        size_t mibLength;
+        struct kinfo_proc* kInfoProc;
+
+        managementInfoBase[0] = CTL_KERN;
+        managementInfoBase[1] = KERN_PROC;
+        managementInfoBase[2] = KERN_PROC_PID;
+        managementInfoBase[3] = pid;
+
+        if (sysctl(managementInfoBase, 4, NULL, &mibLength, NULL, 0) == -1)
+            return false;
+
+        kInfoProc = new struct kinfo_proc [mibLength];
+
+        if (sysctl(managementInfoBase, 4, kInfoProc, &mibLength, NULL, 0) == -1)
+        {
+            delete [] kInfoProc;
+            return false;
+        }
+
+#if defined(__DragonFly__)
+        setName(kInfoProc->kp_comm);
+        setPid(kInfoProc->kp_pid);
+        setParentPid(kInfoProc->kp_ppid);
+        setForegroundPid(kInfoProc->kp_pgid);
+        setUserId(kInfoProc->kp_uid);
+#else
+        setName(kInfoProc->ki_comm);
+        setPid(kInfoProc->ki_pid);
+        setParentPid(kInfoProc->ki_ppid);
+        setForegroundPid(kInfoProc->ki_pgid);
+        setUserId(kInfoProc->ki_uid);
+#endif
+
+        readUserName();
+
+        delete [] kInfoProc;
+        return true;
+    }
+
+    virtual bool readArguments(int pid)
+    {
+        char args[ARG_MAX];
+        int managementInfoBase[4];
+        size_t len;
+
+        managementInfoBase[0] = CTL_KERN;
+        managementInfoBase[1] = KERN_PROC;
+        managementInfoBase[2] = KERN_PROC_PID;
+        managementInfoBase[3] = pid;
+
+        len = sizeof(args);
+        if (sysctl(managementInfoBase, 4, args, &len, NULL, 0) == -1)
+            return false;
+
+        const QStringList argumentList = QString(args).split(QChar('\0'));
+
+        for (QStringList::const_iterator it = argumentList.begin(); it != argumentList.end(); ++it)
+        {
+            addArgument(*it);
+        }
+
+        return true;
+    }
+
+    virtual bool readEnvironment(int pid)
+    {
+        // Not supported in FreeBSD?
+        return false;
+    }
+
+    virtual bool readCurrentDir(int pid)
+    {
+#if defined(__DragonFly__)
+        char buf[PATH_MAX];
+        int managementInfoBase[4];
+        size_t len;
+
+        managementInfoBase[0] = CTL_KERN;
+        managementInfoBase[1] = KERN_PROC;
+        managementInfoBase[2] = KERN_PROC_CWD;
+        managementInfoBase[3] = pid;
+
+        len = sizeof(buf);
+        if (sysctl(managementInfoBase, 4, buf, &len, NULL, 0) == -1)
+            return false;
+
+        setCurrentDir(buf);
+
+        return true;
+#else
+        int numrecords;
+        struct kinfo_file* info = 0;
+
+        info = kinfo_getfile(pid, &numrecords);
+
+        if (!info)
+            return false;
+
+        for (int i = 0; i < numrecords; ++i)
+        {
+            if (info[i].kf_fd == KF_FD_TYPE_CWD)
+            {
+                setCurrentDir(info[i].kf_path);
+
+                free(info);
+                return true;
+            }
+        }
+
+        free(info);
+        return false;
+#endif
+    }
+} ;
+#endif
+
+#if defined(Q_OS_MAC)
+class MacProcessInfo : public UnixProcessInfo
+{
+public:
+    MacProcessInfo(int pid, bool env) :
+        UnixProcessInfo(pid, env)
+    {
+    }
+
+private:
+    virtual bool readProcInfo(int pid)
+    {
+        int managementInfoBase[4];
+        size_t mibLength;
+        struct kinfo_proc* kInfoProc;
+        KDE_struct_stat statInfo;
+
+        // Find the tty device of 'pid' (Example: /dev/ttys001)
+        managementInfoBase[0] = CTL_KERN;
+        managementInfoBase[1] = KERN_PROC;
+        managementInfoBase[2] = KERN_PROC_PID;
+        managementInfoBase[3] = pid;
+
+        if (sysctl(managementInfoBase, 4, NULL, &mibLength, NULL, 0) == -1)
+        {
+            return false;
+        } 
+        else
+        {
+            kInfoProc = new struct kinfo_proc [mibLength];
+            if (sysctl(managementInfoBase, 4, kInfoProc, &mibLength, NULL, 0) == -1)
+            {
+                delete [] kInfoProc;
+                return false;
+            }
+            else
+            { 
+                QString deviceNumber = QString(devname(((&kInfoProc->kp_eproc)->e_tdev), S_IFCHR));
+                QString fullDeviceName =  QString("/dev/") + deviceNumber.rightJustified(3, '0');
+                delete [] kInfoProc;
+
+                QByteArray deviceName = fullDeviceName.toLatin1();
+                const char* ttyName = deviceName.data();
+
+                if (KDE_stat(ttyName, &statInfo) != 0)
+                    return false;
+
+                // Find all processes attached to ttyName
+                managementInfoBase[0] = CTL_KERN;
+                managementInfoBase[1] = KERN_PROC;
+                managementInfoBase[2] = KERN_PROC_TTY;
+                managementInfoBase[3] = statInfo.st_rdev;
+
+                mibLength = 0;
+                if (sysctl(managementInfoBase, sizeof(managementInfoBase)/sizeof(int), NULL, &mibLength, NULL, 0) == -1)
+                    return false;
+
+                kInfoProc = new struct kinfo_proc [mibLength];
+                if (sysctl(managementInfoBase, sizeof(managementInfoBase)/sizeof(int), kInfoProc, &mibLength, NULL, 0) == -1)
+                    return false;
+
+                // The foreground program is the first one
+                setName(QString(kInfoProc->kp_proc.p_comm));
+
+                delete [] kInfoProc;
+            }
+        }
+        return true;
+    }
+
+    virtual bool readArguments(int pid)
+    {
+        Q_UNUSED(pid);
+        return false;
+    }
+    virtual bool readCurrentDir(int pid)
+    {
+        struct proc_vnodepathinfo vpi;
+        int nb = proc_pidinfo(pid, PROC_PIDVNODEPATHINFO, 0, &vpi, sizeof(vpi));
+        if (nb == sizeof(vpi))
+        {
+            setCurrentDir(QString(vpi.pvi_cdir.vip_path));
+            return true;
+        }
+        return false;
+    }
+    virtual bool readEnvironment(int pid)
+    {
+        Q_UNUSED(pid);
+        return false;
+    }
+} ;
+#endif
+
+#ifdef Q_OS_SOLARIS
+    // The procfs structure definition requires off_t to be
+    // 32 bits, which only applies if FILE_OFFSET_BITS=32.
+    // Futz around here to get it to compile regardless,
+    // although some of the structure sizes might be wrong.
+    // Fortunately, the structures we actually use don't use
+    // off_t, and we're safe.
+    #if defined(_FILE_OFFSET_BITS) && (_FILE_OFFSET_BITS==64)
+        #undef _FILE_OFFSET_BITS
+    #endif
+    #include <procfs.h>
+#else
+    // On non-Solaris platforms, define a fake psinfo structure
+    // so that the SolarisProcessInfo class can be compiled
+    //
+    // That avoids the trap where you change the API and
+    // don't notice it in #ifdeffed platform-specific parts
+    // of the code.
+    struct psinfo {
+        int pr_ppid;
+        int pr_pgid;
+        char* pr_fname;
+        char* pr_psargs;
+    } ;
+    static const int PRARGSZ=1;
+#endif
+
+class SolarisProcessInfo : public UnixProcessInfo
+{
+public:
+    SolarisProcessInfo(int pid, bool readEnvironment) 
+    : UnixProcessInfo(pid,readEnvironment)
+    {
+    }
+private:
+    virtual bool readProcInfo(int pid)
+    {
+        QFile psinfo( QString("/proc/%1/psinfo").arg(pid) );
+        if ( psinfo.open( QIODevice::ReadOnly ) )
+        {
+            struct psinfo info;
+            if (psinfo.read((char *)&info,sizeof(info)) != sizeof(info))
+            {
+                return false;
+            }
+
+            setParentPid(info.pr_ppid);
+            setForegroundPid(info.pr_pgid);
+            setName(info.pr_fname);
+            setPid(pid);
+
+            // Bogus, because we're treating the arguments as one single string
+            info.pr_psargs[PRARGSZ-1]=0;
+            addArgument(info.pr_psargs);
+        }
+        return true;
+    }
+
+    virtual bool readArguments(int /*pid*/)
+    {
+        // Handled in readProcInfo()
+        return false;
+    }
+
+    virtual bool readEnvironment(int /*pid*/)
+    {
+        // Not supported in Solaris
+        return false;
+    }
+
+    virtual bool readCurrentDir(int pid)
+    {
+        QFileInfo info( QString("/proc/%1/path/cwd").arg(pid) );
+        const bool readable = info.isReadable();
+
+        if ( readable && info.isSymLink() )
+        {
+            setCurrentDir( info.symLinkTarget() );
+            return true;
+        }
+        else
+        {
+            if ( !readable )
+                setError( PermissionsError );
+            else
+                setError( UnknownError );
+
+            return false;
+        }
+    }
+} ;
+
+SSHProcessInfo::SSHProcessInfo(const ProcessInfo& process)
+ : _process(process)
+{
+    bool ok = false;
+
+    // check that this is a SSH process
+    const QString& name = _process.name(&ok);
+
+    if ( !ok || name != "ssh" )
+    {
+        //if ( !ok )
+        //    kWarning() << "Could not read process info";
+        //else
+        //    kWarning() << "Process is not a SSH process";
+
+        return;
+    }
+
+    // read arguments
+    const QVector<QString>& args = _process.arguments(&ok); 
+
+    // SSH options
+    // these are taken from the SSH manual ( accessed via 'man ssh' )
+    
+    // options which take no arguments
+    static const QString noOptionsArguments("1246AaCfgkMNnqsTtVvXxY"); 
+    // options which take one argument
+    static const QString singleOptionArguments("bcDeFiLlmOopRSw");
+
+    if ( ok )
+    {
+         // find the username, host and command arguments
+         //
+         // the username/host is assumed to be the first argument 
+         // which is not an option
+         // ( ie. does not start with a dash '-' character )
+         // or an argument to a previous option.
+         //
+         // the command, if specified, is assumed to be the argument following
+         // the username and host
+         //
+         // note that we skip the argument at index 0 because that is the
+         // program name ( expected to be 'ssh' in this case )
+         for ( int i = 1 ; i < args.count() ; i++ )
+         {
+            // if this argument is an option then skip it, plus any 
+            // following arguments which refer to this option
+            if ( args[i].startsWith('-') )
+            {
+                QChar argChar = ( args[i].length() > 1 ) ? args[i][1] : '\0';
+
+                if ( noOptionsArguments.contains(argChar) )
+                    continue;
+                else if ( singleOptionArguments.contains(argChar) )
+                {
+                    i++;
+                    continue;
+                }
+            }
+
+            // check whether the host has been found yet
+            // if not, this must be the username/host argument 
+            if ( _host.isEmpty() )
+            {
+                // check to see if only a hostname is specified, or whether
+                // both a username and host are specified ( in which case they
+                // are separated by an '@' character:  username@host )
+            
+                int separatorPosition = args[i].indexOf('@');
+                if ( separatorPosition != -1 )
+                {
+                    // username and host specified
+                    _user = args[i].left(separatorPosition);
+                    _host = args[i].mid(separatorPosition+1);
+                }
+                else
+                {
+                    // just the host specified
+                    _host = args[i];
+                }
+            }
+            else
+            {
+                // host has already been found, this must be the command argument
+                _command = args[i];
+            }
+
+         }
+    }
+    else
+    {
+        //kWarning() << "Could not read arguments";
+        
+        return;
+    }
+}
+
+QString SSHProcessInfo::userName() const
+{
+    return _user;
+}
+QString SSHProcessInfo::host() const
+{
+    return _host;
+}
+QString SSHProcessInfo::command() const
+{
+    return _command;
+}
+QString SSHProcessInfo::format(const QString& input) const
+{
+    QString output(input);
+   
+    // test whether host is an ip address
+    // in which case 'short host' and 'full host'
+    // markers in the input string are replaced with
+    // the full address
+    bool isIpAddress = false;
+   
+    struct in_addr address;
+    if ( inet_aton(_host.toLocal8Bit().constData(),&address) != 0 )
+        isIpAddress = true;
+    else
+        isIpAddress = false;
+
+    // search for and replace known markers
+    output.replace("%u",_user);
+
+    if ( isIpAddress )
+        output.replace("%h",_host);
+    else
+        output.replace("%h",_host.left(_host.indexOf('.')));
+    
+    output.replace("%H",_host);
+    output.replace("%c",_command);
+
+    return output;
+}
+
+ProcessInfo* ProcessInfo::newInstance(int pid,bool enableEnvironmentRead)
+{
+#ifdef Q_OS_LINUX
+    return new LinuxProcessInfo(pid,enableEnvironmentRead);
+#elif defined(Q_OS_SOLARIS)
+    return new SolarisProcessInfo(pid,enableEnvironmentRead);
+#elif defined(Q_OS_MAC)
+    return new MacProcessInfo(pid,enableEnvironmentRead);
+#elif defined(Q_OS_FREEBSD)
+    return new FreeBSDProcessInfo(pid,enableEnvironmentRead);
+#else
+    return new NullProcessInfo(pid,enableEnvironmentRead);
+#endif
+}
+
diff --git a/gui//src/ProcessInfo.h b/gui//src/ProcessInfo.h
new file mode 100644
--- /dev/null
+++ b/gui//src/ProcessInfo.h
@@ -0,0 +1,462 @@
+/*
+    Copyright 2007-2008 by Robert Knight <robertknight@gmail.com>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+#ifndef PROCESSINFO_H
+#define PROCESSINFO_H
+
+// Qt
+#include <QtCore/QFile>
+#include <QtCore/QMap>
+#include <QtCore/QString>
+#include <QtCore/QVector>
+
+/**
+ * Takes a snapshot of the state of a process and provides access to 
+ * information such as the process name, parent process,
+ * the foreground process in the controlling terminal,
+ * the arguments with which the process was started and the 
+ * environment.
+ *
+ * To create a new snapshot, construct a new ProcessInfo instance,
+ * using ProcessInfo::newInstance(),
+ * passing the process identifier of the process you are interested in.
+ *
+ * After creating a new instance, call the update() method to take a 
+ * snapshot of the current state of the process.
+ *
+ * Before calling any additional methods, check that the process state
+ * was read successfully using the isValid() method.
+ *
+ * Each accessor method which provides information about the process state ( such as pid(), 
+ * currentDir(), name() ) takes a pointer to a boolean as an argument.  If the information
+ * requested was read successfully then the boolean is set to true, otherwise it is set
+ * to false, in which case the return value from the function should be ignored.
+ * If this boolean is set to false, it may indicate an error reading the process information,
+ * or it may indicate that the information is not available on the current platform. 
+ *
+ * eg.
+ *
+ * @code
+ *   ProcessInfo* info = ProcessInfo::newInstance(pid);
+ *   info->update();
+ *
+ *   if ( info->isValid() )
+ *   {
+ *      bool ok;
+ *      QString value = info->name(&ok);
+ *
+ *      if ( ok ) kDebug() << "process name - " << name;
+ *      int parentPid = info->parentPid(&ok);
+ *      if ( ok ) kDebug() << "parent process - " << parentPid;
+ *      int foregroundPid = info->foregroundColororegroundPid(&ok);
+ *      if ( ok ) kDebug() << "foreground process - " << foregroundPid;
+ *   }
+ * @endcode
+ */
+class ProcessInfo
+{
+public:
+    /**
+     * Constructs a new instance of a suitable ProcessInfo sub-class for 
+     * the current platform which provides information about a given process.
+     *
+     * @param pid The pid of the process to examine
+     * @param readEnvironment Specifies whether environment bindings should
+     * be read.  If this is false, then environment() calls will
+     * always fail.  This is an optimization to avoid the overhead
+     * of reading the (potentially large) environment data when it
+     * is not required. 
+     */
+    static ProcessInfo* newInstance(int pid,bool readEnvironment = false);
+
+    virtual ~ProcessInfo() {}
+
+    /** 
+     * Updates the information about the process.  This must
+     * be called before attempting to use any of the accessor methods.
+     */
+    void update();
+
+    /** Returns true if the process state was read successfully. */ 
+    bool isValid() const;
+    /** 
+     * Returns the process id.  
+     *
+     * @param ok Set to true if the process id was read successfully or false otherwise 
+     */
+    int pid(bool* ok) const;
+    /** 
+     * Returns the id of the parent process id was read successfully or false otherwise
+     * 
+     * @param ok Set to true if the parent process id
+     */
+    int parentPid(bool* ok) const;
+    
+    /** 
+     * Returns the id of the current foreground process 
+     *
+     * NOTE:  Using the foregroundProcessGroup() method of the Pty
+     * instance associated with the terminal of interest is preferred
+     * over using this method.
+     *
+     * @param ok Set to true if the foreground process id was read successfully or false otherwise
+     */
+    int foregroundPid(bool* ok) const;
+    
+    /* Returns the user id of the process */
+    int userId(bool* ok) const;
+
+    /** Returns the user's name of the process */
+    QString userName() const;
+   
+    /** Returns the user's home directory of the process */
+    QString userHomeDir() const;
+
+    /** Returns the name of the current process */
+    QString name(bool* ok) const;
+   
+    /** 
+     * Returns the command-line arguments which the process
+     * was started with.
+     *
+     * The first argument is the name used to launch the process.
+     *
+     * @param ok Set to true if the arguments were read successfully or false otherwise.
+     */
+    QVector<QString> arguments(bool* ok) const;
+    /**
+     * Returns the environment bindings which the process
+     * was started with.
+     * In the returned map, the key is the name of the environment variable,
+     * and the value is the corresponding value.
+     *
+     * @param ok Set to true if the environment bindings were read successfully or false otherwise
+     */
+    QMap<QString,QString> environment(bool* ok) const;
+
+    /**
+     * Returns the current working directory of the process
+     *
+     * @param ok Set to true if the current working directory was read successfully or false otherwise
+     */
+    QString currentDir(bool* ok) const;
+
+    /**
+     * Returns the current working directory of the process (or its parent)
+     */
+    QString validCurrentDir() const;
+
+    /** Forces the user home directory to be calculated */
+    void setUserHomeDir();
+
+    /**
+     * Parses an input string, looking for markers beginning with a '%' 
+     * character and returns a string with the markers replaced
+     * with information from this process description.
+     * <br>
+     * The markers recognised are:
+     * <ul>
+     * <li> %u - Name of the user which owns the process. </li>
+     * <li> %n - Replaced with the name of the process.   </li>
+     * <li> %d - Replaced with the last part of the path name of the 
+     *      process' current working directory.
+     *      
+     *      (eg. if the current directory is '/home/bob' then
+     *      'bob' would be returned)
+     * </li>
+     * <li> %D - Replaced with the current working directory of the process. </li>
+     * </ul>
+     */
+    QString format(const QString& text) const;
+
+    /** 
+     * This enum describes the errors which can occur when trying to read 
+     * a process's information.
+     */
+    enum Error
+    {
+        /** No error occurred. */
+        NoError,
+        /** The nature of the error is unknown. */
+        UnknownError,
+        /** Konsole does not have permission to obtain the process information. */
+        PermissionsError
+    };
+
+    /**
+     * Returns the last error which occurred.
+     */
+    Error error() const;
+
+protected:
+    /**
+     * Constructs a new process instance.  You should not call the constructor
+     * of ProcessInfo or its subclasses directly.  Instead use the 
+     * static ProcessInfo::newInstance() method which will return
+     * a suitable ProcessInfo instance for the current platform.
+     */ 
+    explicit ProcessInfo(int pid , bool readEnvironment = false);
+
+    /** 
+     * This is called on construction to read the process state 
+     * Subclasses should reimplement this function to provide
+     * platform-specific process state reading functionality.
+     *
+     * When called, readProcessInfo() should attempt to read all
+     * of the necessary state information.  If the attempt is successful,
+     * it should set the process id using setPid(), and update
+     * the other relevant information using setParentPid(), setName(),
+     * setArguments() etc.
+     *
+     * Calls to isValid() will return true only if the process id
+     * has been set using setPid()
+     *
+     * @param pid The process id of the process to read
+     * @param readEnvironment Specifies whether the environment bindings
+     *                        for the process should be read
+     */
+    virtual bool readProcessInfo(int pid , bool readEnvironment) = 0;
+
+    /* Read the user name */
+    virtual void readUserName(void) = 0;
+
+    /** Sets the process id associated with this ProcessInfo instance */
+    void setPid(int pid);
+    /** Sets the parent process id as returned by parentPid() */
+    void setParentPid(int pid);
+    /** Sets the foreground process id as returend by foregroundPid() */
+    void setForegroundPid(int pid);
+    /** Sets the user id associated with this ProcessInfo instance */
+    void setUserId(int uid);
+    /** Sets the user name of the process as set by readUserName() */
+    void setUserName(const QString& name);
+    /** Sets the name of the process as returned by name() */
+    void setName(const QString& name);
+    /** Sets the current working directory for the process */
+    void setCurrentDir(const QString& dir);
+
+    /** Sets the error */
+    void setError( Error error );
+
+    /** Convenience method.  Sets the error based on a QFile error code. */ 
+    void setFileError( QFile::FileError error ); 
+
+    /** 
+     * Adds a commandline argument for the process, as returned
+     * by arguments()
+     */
+    void addArgument(const QString& argument);
+    /**
+     * Adds an environment binding for the process, as returned by
+     * environment()
+     *
+     * @param name The name of the environment variable, eg. "PATH"
+     * @param value The value of the environment variable, eg. "/bin"
+     */
+    void addEnvironmentBinding(const QString& name , const QString& value);
+
+private:
+    // takes a full directory path and returns a
+    // shortened version suitable for display in 
+    // space-constrained UI elements (eg. tabs)
+    QString formatShortDir(const QString& dirPath) const;
+
+    enum CommandFormat
+    {
+        ShortCommandFormat,
+        LongCommandFormat
+    };
+    // takes a process name and its arguments and produces formatted output
+    QString formatCommand(const QString& name , const QVector<QString>& arguments , 
+                          CommandFormat format) const;
+
+    // valid bits for _fields variable, ensure that
+    // _fields is changed to an int if more than 8 fields are added
+    enum FIELD_BITS
+    {
+        PROCESS_ID          = 1,
+        PARENT_PID          = 2,
+        FOREGROUND_PID      = 4,
+        ARGUMENTS           = 8,
+        ENVIRONMENT         = 16,
+        NAME                = 32,
+        CURRENT_DIR         = 64,
+        UID                 =128 
+    };
+
+    char _fields; // a bitmap indicating which fields are valid
+                  // used to set the "ok" parameters for the public
+                  // accessor functions
+
+    bool _enableEnvironmentRead; // specifies whether to read the environment
+                                 // bindings when update() is called
+    int _pid;  
+    int _parentPid;
+    int _foregroundPid;
+    int _userId;  
+
+    Error _lastError;
+
+    QString _name;
+    QString _userName;
+    QString _userHomeDir;
+    QString _currentDir;
+
+    QVector<QString> _arguments;
+    QMap<QString,QString> _environment;
+
+    static QSet<QString> commonDirNames();
+    static QSet<QString> _commonDirNames;
+};
+
+/** 
+ * Implementation of ProcessInfo which does nothing.
+ * Used on platforms where a suitable ProcessInfo subclass is not 
+ * available.
+ *
+ * isValid() will always return false for instances of NullProcessInfo
+ */
+class NullProcessInfo : public ProcessInfo
+{
+public:
+    /** 
+     * Constructs a new NullProcessInfo instance.
+     * See ProcessInfo::newInstance()
+     */
+    explicit NullProcessInfo(int pid,bool readEnvironment = false);
+protected:
+    virtual bool readProcessInfo(int pid,bool readEnvironment);
+    virtual void readUserName(void);
+};
+
+/**
+ * Implementation of ProcessInfo for Unix platforms which uses
+ * the /proc filesystem
+ */
+class UnixProcessInfo : public ProcessInfo
+{
+public:
+    /** 
+     * Constructs a new instance of UnixProcessInfo.
+     * See ProcessInfo::newInstance()
+     */
+    explicit UnixProcessInfo(int pid,bool readEnvironment = false);
+
+protected:
+    /** 
+     * Implementation of ProcessInfo::readProcessInfo(); calls the
+     * four private methods below in turn.
+     */
+    virtual bool readProcessInfo(int pid , bool readEnvironment);
+
+    virtual void readUserName(void);
+
+private:
+    /**
+     * Read the standard process information -- PID, parent PID, foreground PID.
+     * @param pid process ID to use
+     * @return true on success
+     */
+    virtual bool readProcInfo(int pid)=0;
+
+    /**
+     * Read the environment of the process. Sets _environment.
+     * @param pid process ID to use
+     * @return true on success
+     */
+    virtual bool readEnvironment(int pid)=0;
+
+    /**
+     * Determine what arguments were passed to the process. Sets _arguments.
+     * @param pid process ID to use
+     * @return true on success
+     */
+    virtual bool readArguments(int pid)=0;
+
+    /**
+     * Determine the current directory of the process.
+     * @param pid process ID to use
+     * @return true on success
+     */
+    virtual bool readCurrentDir(int pid)=0;
+};
+
+/** 
+ * Lightweight class which provides additional information about SSH processes.
+ */
+class SSHProcessInfo
+{
+public:
+    /** 
+     * Constructs a new SSHProcessInfo instance which provides additional
+     * information about the specified SSH process.
+     *
+     * @param process A ProcessInfo instance for a SSH process.
+     */
+    SSHProcessInfo(const ProcessInfo& process);
+
+    /** 
+     * Returns the user name which the user initially logged into on
+     * the remote computer.
+     */
+    QString userName() const;
+
+    /**
+     * Returns the host which the user has connected to.
+     */
+    QString host() const;
+
+    /** 
+     * Returns the command which the user specified to execute on the 
+     * remote computer when starting the SSH process.
+     */
+    QString command() const;
+
+    /**
+     * Operates in the same way as ProcessInfo::format(), except
+     * that the set of markers understood is different:
+     *
+     * %u - Replaced with user name which the user initially logged
+     *      into on the remote computer.
+     * %h - Replaced with the first part of the host name which
+     *      is connected to.
+     * %H - Replaced with the full host name of the computer which
+     *      is connected to.
+     * %c - Replaced with the command which the user specified
+     *      to execute when starting the SSH process.
+     */
+    QString format(const QString& input) const;
+
+private:
+    const ProcessInfo& _process;
+    QString _user;
+    QString _host;
+    QString _command;
+};
+
+#endif //PROCESSINFO_H
+
+/*
+  Local Variables:
+  mode: c++
+  c-file-style: "stroustrup"
+  indent-tabs-mode: nil
+  tab-width: 4
+  End:
+*/
diff --git a/gui//src/Pty.cpp b/gui//src/Pty.cpp
--- a/gui//src/Pty.cpp
+++ b/gui//src/Pty.cpp
@@ -1,13 +1,11 @@
 /*
     This file is part of Konsole, an X terminal.
-    Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
-
-    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+    Copyright 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
 
     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -16,111 +14,130 @@
 
     You should have received a copy of the GNU General Public License
     along with this program; if not, write to the Free Software
     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
     02110-1301  USA.
 */
 
 // Own
+#include "kprocess.h"
+#include "kptyprocess.h"
 #include "Pty.h"
 
 // System
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <unistd.h>
 #include <errno.h>
 #include <termios.h>
+#include <signal.h>
 
 // Qt
-#include <QtCore>
-#include "kpty.h"
+#include <QtCore/QStringList>
 
-void Pty::donePty()
-{
-  emit done(exitStatus());
-}
+// KDE
+//#include <KStandardDirs>
+//#include <KLocale>
+//#include <KDebug>
+//#include <KPty>
+//#include <KPtyDevice>
+//#include <kde_file.h>
+
+//#include "kdebug.h"
+
+#include "kpty.h"
+#include "kptydevice.h"
+
 
 void Pty::setWindowSize(int lines, int cols)
 {
   _windowColumns = cols;
   _windowLines = lines;
 
   if (pty()->masterFd() >= 0)
     pty()->setWinSize(lines, cols);
 }
 QSize Pty::windowSize() const
 {
     return QSize(_windowColumns,_windowLines);
 }
 
-void Pty::setXonXoff(bool enable)
+void Pty::setFlowControlEnabled(bool enable)
 {
   _xonXoff = enable;
 
   if (pty()->masterFd() >= 0)
   {
     struct ::termios ttmode;
     pty()->tcGetAttr(&ttmode);
     if (!enable)
       ttmode.c_iflag &= ~(IXOFF | IXON);
     else
       ttmode.c_iflag |= (IXOFF | IXON);
-    if (!pty()->tcSetAttr(&ttmode))
-      qWarning("Unable to set terminal attributes.");
+    //if (!pty()->tcSetAttr(&ttmode))
+    //  kWarning() << "Unable to set terminal attributes.";
   }
 }
+bool Pty::flowControlEnabled() const
+{
+    if (pty()->masterFd() >= 0)
+    {
+        struct ::termios ttmode;
+        pty()->tcGetAttr(&ttmode);
+        return ttmode.c_iflag & IXOFF &&
+               ttmode.c_iflag & IXON;
+    }  
+    //kWarning() << "Unable to get flow control status, terminal not connected.";
+    return false;
+}
 
 void Pty::setUtf8Mode(bool enable)
 {
 #ifdef IUTF8 // XXX not a reasonable place to check it.
   _utf8 = enable;
 
   if (pty()->masterFd() >= 0)
   {
     struct ::termios ttmode;
     pty()->tcGetAttr(&ttmode);
     if (!enable)
       ttmode.c_iflag &= ~IUTF8;
     else
       ttmode.c_iflag |= IUTF8;
-    if (!pty()->tcSetAttr(&ttmode))
-      qWarning("Unable to set terminal attributes.");
+   // if (!pty()->tcSetAttr(&ttmode))
+    //  kWarning() << "Unable to set terminal attributes.";
   }
 #endif
 }
 
 void Pty::setErase(char erase)
 {
   _eraseChar = erase;
   
   if (pty()->masterFd() >= 0)
   {
     struct ::termios ttmode;
-
     pty()->tcGetAttr(&ttmode);
-
     ttmode.c_cc[VERASE] = erase;
-
-    if (!pty()->tcSetAttr(&ttmode))
-      qWarning("Unable to set terminal attributes.");
-  }  
+    //if (!pty()->tcSetAttr(&ttmode))
+    //  kWarning() << "Unable to set terminal attributes.";
+  }
 }
 
 char Pty::erase() const
 {
-	if (pty()->masterFd() >= 0)
-	{
-		qDebug() << "Getting erase char";
-		struct ::termios ttyAttributes;
-		pty()->tcGetAttr(&ttyAttributes);
-		return ttyAttributes.c_cc[VERASE];
-	}
+    if (pty()->masterFd() >= 0)
+    {
+        struct ::termios ttyAttributes;
+        pty()->tcGetAttr(&ttyAttributes);
+        return ttyAttributes.c_cc[VERASE];
+    }
 
-	return _eraseChar;
+    return _eraseChar;
 }
 
 void Pty::addEnvironmentVariables(const QStringList& environment)
 {
     QListIterator<QString> iter(environment);
     while (iter.hasNext())
     {
         QString pair = iter.next();
@@ -128,186 +145,176 @@ void Pty::addEnvironmentVariables(const 
         // split on the first '=' character
         int pos = pair.indexOf('=');
         
         if ( pos >= 0 )
         {
             QString variable = pair.left(pos);
             QString value = pair.mid(pos+1);
 
-            //kDebug() << "Setting environment pair" << variable <<
-            //    " set to " << value;
-
-            setEnvironment(variable,value);
+            setEnv(variable,value);
         }
     }
 }
 
 int Pty::start(const QString& program, 
                const QStringList& programArguments, 
                const QStringList& environment, 
                ulong winid, 
-               bool addToUtmp
-//               const QString& dbusService, 
-//               const QString& dbusSession)
-		)
+               bool addToUtmp,
+               const QString& dbusService, 
+               const QString& dbusSession)
 {
-  clearArguments();
+  clearProgram();
 
-  setBinaryExecutable(program.toLatin1());
+  // For historical reasons, the first argument in programArguments is the 
+  // name of the program to execute, so create a list consisting of all
+  // but the first argument to pass to setProgram()
+  Q_ASSERT(programArguments.count() >= 1);
+  setProgram(program.toLatin1(),programArguments.mid(1));
 
   addEnvironmentVariables(environment);
 
-  QStringListIterator it( programArguments );
-  while (it.hasNext())
-    arguments.append( it.next().toUtf8() );
+  if ( !dbusService.isEmpty() )
+     setEnv("KONSOLE_DBUS_SERVICE",dbusService);
+  if ( !dbusSession.isEmpty() )
+     setEnv("KONSOLE_DBUS_SESSION", dbusSession);
 
-//  if ( !dbusService.isEmpty() )
-//     setEnvironment("KONSOLE_DBUS_SERVICE",dbusService);
-//  if ( !dbusSession.isEmpty() )
-//     setEnvironment("KONSOLE_DBUS_SESSION", dbusSession);
-
-  setEnvironment("WINDOWID", QString::number(winid));
+  setEnv("WINDOWID", QString::number(winid));
 
   // unless the LANGUAGE environment variable has been set explicitly
   // set it to a null string
   // this fixes the problem where KCatalog sets the LANGUAGE environment
   // variable during the application's startup to something which
   // differs from LANG,LC_* etc. and causes programs run from
-  // the terminal to display mesages in the wrong language
+  // the terminal to display messages in the wrong language
   //
   // this can happen if LANG contains a language which KDE
   // does not have a translation for
   //
   // BR:149300
-  if (!environment.contains("LANGUAGE"))
-      setEnvironment("LANGUAGE",QString());
+  setEnv("LANGUAGE",QString(),false /* do not overwrite existing value if any */);
 
-  setUsePty(All, addToUtmp);
+  setUseUtmp(addToUtmp);
 
-  pty()->open();
-  
   struct ::termios ttmode;
   pty()->tcGetAttr(&ttmode);
   if (!_xonXoff)
     ttmode.c_iflag &= ~(IXOFF | IXON);
   else
     ttmode.c_iflag |= (IXOFF | IXON);
 #ifdef IUTF8 // XXX not a reasonable place to check it.
   if (!_utf8)
     ttmode.c_iflag &= ~IUTF8;
   else
     ttmode.c_iflag |= IUTF8;
 #endif
 
   if (_eraseChar != 0)
-  	ttmode.c_cc[VERASE] = _eraseChar;
+      ttmode.c_cc[VERASE] = _eraseChar;
   
-  if (!pty()->tcSetAttr(&ttmode))
-    qWarning("Unable to set terminal attributes.");
+  //if (!pty()->tcSetAttr(&ttmode))
+  //  kWarning() << "Unable to set terminal attributes.";
   
   pty()->setWinSize(_windowLines, _windowColumns);
 
-  if ( K3Process::start(NotifyOnExit, (Communication) (Stdin | Stdout)) == false )
-     return -1;
+  KProcess::start();
 
-  resume(); // Start...
+  if (!waitForStarted())
+      return -1;
+
   return 0;
-
 }
 
 void Pty::setWriteable(bool writeable)
 {
+  //KDE_struct_stat sbuf;
   struct stat sbuf;
-  stat(pty()->ttyName(), &sbuf);
+  //KDE_stat(pty()->ttyName(), &sbuf);
+  ::stat(pty()->ttyName(), &sbuf);
   if (writeable)
     chmod(pty()->ttyName(), sbuf.st_mode | S_IWGRP);
   else
     chmod(pty()->ttyName(), sbuf.st_mode & ~(S_IWGRP|S_IWOTH));
 }
 
-Pty::Pty()
-    : _bufferFull(false),
-      _windowColumns(0),
-      _windowLines(0),
-      _eraseChar(0),
-      _xonXoff(true),
-      _utf8(true)
+Pty::Pty(int masterFd, QObject* parent)
+    : KPtyProcess(masterFd,parent)
+{
+    init();
+}
+Pty::Pty(QObject* parent)
+    : KPtyProcess(parent)
 {
-  connect(this, SIGNAL(receivedStdout(K3Process *, char *, int )),
-	  this, SLOT(dataReceived(K3Process *,char *, int)));
-  connect(this, SIGNAL(processExited(K3Process *)),
-          this, SLOT(donePty()));
-  connect(this, SIGNAL(wroteStdin(K3Process *)),
-          this, SLOT(writeReady()));
-  _pty = new KPty;
+    init();
+}
+void Pty::init()
+{
+  _windowColumns = 0;
+  _windowLines = 0;
+  _eraseChar = 0;
+  _xonXoff = true;
+  _utf8 =true;
 
-  setUsePty(All, false); // utmp will be overridden later
+  connect(pty(), SIGNAL(readyRead()) , this , SLOT(dataReceived()));
+  setPtyChannels(KPtyProcess::AllChannels);
 }
 
 Pty::~Pty()
 {
-    delete _pty;
-}
-
-void Pty::writeReady()
-{
-  _pendingSendJobs.erase(_pendingSendJobs.begin());
-  _bufferFull = false;
-  doSendJobs();
 }
 
-void Pty::doSendJobs() {
-  if(_pendingSendJobs.isEmpty())
-  {
-     emit bufferEmpty(); 
-     return;
-  }
+void Pty::sendData(const char* data, int length)
+{
+  if (!length)
+      return;
   
-  SendJob& job = _pendingSendJobs.first();
-
-  
-  if (!writeStdin( job.data(), job.length() ))
+  if (!pty()->write(data,length)) 
   {
-    qWarning("Pty::doSendJobs - Could not send input data to terminal process.");
+    //kWarning() << "Pty::doSendJobs - Could not send input data to terminal process.";
     return;
   }
-  _bufferFull = true;
-}
-
-void Pty::appendSendJob(const char* s, int len)
-{
-  _pendingSendJobs.append(SendJob(s,len));
 }
 
-void Pty::sendData(const char* s, int len)
+void Pty::dataReceived() 
 {
-  appendSendJob(s,len);
-  if (!_bufferFull)
-     doSendJobs();
-}
-
-void Pty::dataReceived(K3Process *,char *buf, int len)
-{
-  emit receivedData(buf,len);
+     QByteArray data = pty()->readAll();
+    emit receivedData(data.constData(),data.count());
 }
 
 void Pty::lockPty(bool lock)
 {
-  if (lock)
-    suspend();
-  else
-    resume();
+    Q_UNUSED(lock);
+
+// TODO: Support for locking the Pty
+  //if (lock)
+    //suspend();
+  //else
+    //resume();
 }
 
 int Pty::foregroundProcessGroup() const
 {
     int pid = tcgetpgrp(pty()->masterFd());
 
     if ( pid != -1 )
     {
         return pid;
     } 
 
     return 0;
 }
 
-//#include "moc_Pty.cpp"
+void Pty::setupChildProcess()
+{
+    KPtyProcess::setupChildProcess();
+    
+    // reset all signal handlers
+    // this ensures that terminal applications respond to 
+    // signals generated via key sequences such as Ctrl+C
+    // (which sends SIGINT)
+    struct sigaction action;
+    sigemptyset(&action.sa_mask);
+    action.sa_handler = SIG_DFL;
+    action.sa_flags = 0;
+    for (int signal=1;signal < NSIG; signal++)
+        sigaction(signal,&action,0L);
+}
diff --git a/gui//src/Pty.h b/gui//src/Pty.h
--- a/gui//src/Pty.h
+++ b/gui//src/Pty.h
@@ -1,15 +1,13 @@
 /*
     This file is part of Konsole, KDE's terminal emulator. 
     
-    Copyright (C) 2007 by Robert Knight <robertknight@gmail.com>
-    Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
-
-    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+    Copyright 2007-2008 by Robert Knight <robertknight@gmail.com>
+    Copyright 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
 
     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -24,49 +22,63 @@
 
 #ifndef PTY_H
 #define PTY_H
 
 // Qt
 #include <QtCore/QStringList>
 #include <QtCore/QVector>
 #include <QtCore/QList>
-#include <QtCore>
+#include <QtCore/QSize>
 
-#include "k3process.h"
+// KDE
+//#include <KPtyProcess>
+#include "kprocess.h"
+#include "kptyprocess.h"
+
+// Konsole
+#include "konsole_export.h"
 
 /**
  * The Pty class is used to start the terminal process, 
  * send data to it, receive data from it and manipulate 
  * various properties of the pseudo-teletype interface
  * used to communicate with the process.
  *
  * To use this class, construct an instance and connect
  * to the sendData slot and receivedData signal to
  * send data to or receive data from the process.
  *
  * To start the terminal process, call the start() method
  * with the program name and appropriate arguments. 
  */
-class Pty: public K3Process
+//class KONSOLEPRIVATE_EXPORT Pty: public KPtyProcess
+class KONSOLEPRIVATE_EXPORT Pty: public KPtyProcess
 {
 Q_OBJECT
 
   public:
     
     /** 
      * Constructs a new Pty.
      * 
      * Connect to the sendData() slot and receivedData() signal to prepare
      * for sending and receiving data from the terminal process.
      *
      * To start the terminal process, call the run() method with the 
      * name of the program to start and appropriate arguments.
      */
-    Pty();
+    explicit Pty(QObject* parent = 0);
+
+    /** 
+     * Construct a process using an open pty master.
+     * See KPtyProcess::KPtyProcess()
+     */
+    explicit Pty(int ptyMasterFd, QObject* parent = 0);
+
     ~Pty();
 
     /**
      * Starts the terminal process.  
      *
      * Returns 0 if the process was started successfully or non-zero
      * otherwise.
      *
@@ -83,61 +95,59 @@ Q_OBJECT
      * environment variable in the process's environment.
      * @param dbusSession Specifies the value of the KONSOLE_DBUS_SESSION
      * environment variable in the process's environment. 
      */
     int start( const QString& program, 
                const QStringList& arguments, 
                const QStringList& environment, 
                ulong winid, 
-               bool addToUtmp
-//               const QString& dbusService,
-//               const QString& dbusSession
+               bool addToUtmp,
+               const QString& dbusService,
+               const QString& dbusSession
              );
 
     /** TODO: Document me */
     void setWriteable(bool writeable);
 
     /** 
-     * Enables or disables Xon/Xoff flow control.
+     * Enables or disables Xon/Xoff flow control.  The flow control setting
+     * may be changed later by a terminal application, so flowControlEnabled()
+     * may not equal the value of @p on in the previous call to setFlowControlEnabled()
      */
-    void setXonXoff(bool on);
+    void setFlowControlEnabled(bool on);
+
+    /** Queries the terminal state and returns true if Xon/Xoff flow control is enabled. */
+    bool flowControlEnabled() const;
 
     /** 
      * Sets the size of the window (in lines and columns of characters) 
      * used by this teletype.
      */
     void setWindowSize(int lines, int cols);
     
     /** Returns the size of the window used by this teletype.  See setWindowSize() */
     QSize windowSize() const;
 
     /** TODO Document me */
     void setErase(char erase);
 
-	/** */
-	char erase() const;
+    /** */
+    char erase() const;
 
     /**
      * Returns the process id of the teletype's current foreground
      * process.  This is the process which is currently reading
      * input sent to the terminal via. sendData()
      *
      * If there is a problem reading the foreground process group,
      * 0 will be returned.
      */
     int foregroundProcessGroup() const;
    
-    /**
-     * Returns whether the buffer used to send data to the
-     * terminal process is full.
-     */
-    bool bufferFull() const { return _bufferFull; }
-
-
   public slots:
 
     /**
      * Put the pty into UTF-8 mode on systems which support it.
      */
     void setUtf8Mode(bool on);
 
     /**
@@ -158,79 +168,38 @@ Q_OBJECT
      * @param buffer Pointer to the data to send.
      * @param length Length of @p buffer.
      */
     void sendData(const char* buffer, int length);
 
   signals:
 
     /**
-     * Emitted when the terminal process terminates.
-     *
-     * @param exitCode The status code which the process exited with.
-     */
-    void done(int exitCode);
-
-    /**
      * Emitted when a new block of data is received from
      * the teletype.
      *
      * @param buffer Pointer to the data received.
      * @param length Length of @p buffer
      */
     void receivedData(const char* buffer, int length);
-    
-    /**
-     * Emitted when the buffer used to send data to the terminal
-     * process becomes empty, i.e. all data has been sent.
-     */
-    void bufferEmpty();
-    
+   
+  protected:
+      void setupChildProcess();
 
   private slots:
+    // called when data is received from the terminal process 
+    void dataReceived(); 
     
-    // called when terminal process exits
-    void donePty();
-    // called when data is received from the terminal process 
-    void dataReceived(K3Process*, char* buffer, int length);
-    // sends the first enqueued buffer of data to the
-    // terminal process
-    void doSendJobs();
-    // called when the terminal process is ready to
-    // receive more data
-    void writeReady();
+  private:
+      void init();
 
-  private:
     // takes a list of key=value pairs and adds them
     // to the environment for the process
     void addEnvironmentVariables(const QStringList& environment);
 
-    // enqueues a buffer of data to be sent to the 
-    // terminal process
-    void appendSendJob(const char* buffer, int length);
-   
-    // a buffer of data in the queue to be sent to the 
-    // terminal process 
-    class SendJob {
-	public:
-      		SendJob() {}
-      		SendJob(const char* b, int len) : buffer(len)
-		{
-			memcpy( buffer.data() , b , len );
-        }
-	
-		const char* data() const { return buffer.constData(); }
-		int length() const { return buffer.size(); }	
-	private:
-      		QVector<char> buffer;
-    };
-
-    QList<SendJob> _pendingSendJobs;
-    bool _bufferFull;
-
     int  _windowColumns; 
     int  _windowLines;
     char _eraseChar;
     bool _xonXoff;
     bool _utf8;
-    KPty *_pty;
 };
+
 #endif // PTY_H
diff --git a/gui//src/QTerminalWidget.cpp b/gui//src/QTerminalWidget.cpp
--- a/gui//src/QTerminalWidget.cpp
+++ b/gui//src/QTerminalWidget.cpp
@@ -118,43 +118,52 @@ void QTerminalWidget::setTerminalFont(QF
 
 void QTerminalWidget::setShellProgram(QString progname)
 {
     if (!m_impl->m_session)
 	return;
     m_impl->m_session->setProgram(progname);	
 }
 
+void QTerminalWidget::openTeletype(int fd)
+{
+  if ( m_impl->m_session->isRunning() )
+    return;
+
+  m_impl->m_session->openTeletype(fd);
+}
+
 void QTerminalWidget::setArgs(QStringList &args)
 {
     if (!m_impl->m_session)
 	return;
     m_impl->m_session->setArguments(args);	
 }
 
 void QTerminalWidget::setTextCodec(QTextCodec *codec)
 {
     if (!m_impl->m_session)
 	return;
     m_impl->m_session->setCodec(codec);	
 }
 
 void QTerminalWidget::setColorScheme(ColorScheme scheme)
 {
+    /*
     switch(scheme) {
         case WhiteOnBlack:
 		m_impl->m_terminalDisplay->setColorTable(whiteonblack_color_table);
 		break;		
         case GreenOnBlack:
 		m_impl->m_terminalDisplay->setColorTable(greenonblack_color_table);
 		break;
         case BlackOnLightYellow:
 		m_impl->m_terminalDisplay->setColorTable(blackonlightyellow_color_table);
 		break;
-    };
+    };*/
 }
 
 void QTerminalWidget::setSize(int h, int v)
 {
     if (!m_impl->m_terminalDisplay)
 	return;
     m_impl->m_terminalDisplay->setSize(h, v);
 }
diff --git a/gui//src/QTerminalWidget.h b/gui//src/QTerminalWidget.h
--- a/gui//src/QTerminalWidget.h
+++ b/gui//src/QTerminalWidget.h
@@ -50,16 +50,17 @@ public:
         ScrollBarLeft,
         ScrollBarRight
     };
 
     QTerminalWidget(int startnow = 1, QWidget *parent = 0);
     ~QTerminalWidget();
 
     void startShellProgram();
+    void openTeletype(int fd);
 
     /** Default is application font with family Monospace, size 10. */
     void setTerminalFont(QFont &font); 
     
     /**	Shell program, default is /bin/bash. */
     void setShellProgram(QString progname);
     
     /** Shell program args, default is none. */
diff --git a/gui//src/Quint.cpp b/gui//src/Quint.cpp
--- a/gui//src/Quint.cpp
+++ b/gui//src/Quint.cpp
@@ -14,16 +14,28 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include <QtGui/QApplication>
 #include "MainWindow.h"
 
+// System
+#include <termios.h>
+#include <sys/types.h>
+#include <signal.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+
+#include <iostream>
+#include "pty.h"
+#include <assert.h>
+#include "QTerminalWidget.h"
+
 int main(int argc, char *argv[])
 {
     QApplication a(argc, argv);
     MainWindow w;
     w.show();
 
     return a.exec();
 }
diff --git a/gui//src/Screen.cpp b/gui//src/Screen.cpp
--- a/gui//src/Screen.cpp
+++ b/gui//src/Screen.cpp
@@ -1,45 +1,48 @@
 /*
-    This file is part of Konsole, an X terminal.
-    Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
+   This file is part of Konsole, an X terminal.
 
-    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+   Copyright 2007-2008 by Robert Knight <robert.knight@gmail.com>
+   Copyright 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
 
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
 
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
 
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301  USA.
-*/
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+   02110-1301  USA.
+   */
 
 // Own
 #include "Screen.h"
 
 // Standard
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
 #include <assert.h>
 #include <string.h>
 #include <ctype.h>
 
 // Qt
 #include <QtCore/QTextStream>
 #include <QtCore/QDate>
 
+// KDE
+//#include <kdebug.h>
+
 // Konsole
 #include "konsole_wcwidth.h"
 #include "TerminalCharacterDecoder.h"
 
 //FIXME: this is emulation specific. Use false for xterm, true for ANSI.
 //FIXME: see if we can get this from terminfo.
 #define BS_CLEARS false
 
@@ -53,944 +56,774 @@
 //notably moveImage() and clearImage().
 //This macro converts from an X,Y position into an image offset.
 #ifndef loc
 #define loc(X,Y) ((Y)*columns+(X))
 #endif
 
 
 Character Screen::defaultChar = Character(' ',
-					  CharacterColor(COLOR_SPACE_DEFAULT,DEFAULT_FORE_COLOR),
-					  CharacterColor(COLOR_SPACE_DEFAULT,DEFAULT_BACK_COLOR),
-					  DEFAULT_RENDITION);
+        CharacterColor(COLOR_SPACE_DEFAULT,DEFAULT_FORE_COLOR),
+        CharacterColor(COLOR_SPACE_DEFAULT,DEFAULT_BACK_COLOR),
+        DEFAULT_RENDITION);
 
 //#define REVERSE_WRAPPED_LINES  // for wrapped line debug
 
-Screen::Screen(int l, int c)
-  : lines(l),
+    Screen::Screen(int l, int c)
+: lines(l),
     columns(c),
     screenLines(new ImageLine[lines+1] ),
     _scrolledLines(0),
     _droppedLines(0),
-    hist(new HistoryScrollNone()),
+    history(new HistoryScrollNone()),
     cuX(0), cuY(0),
-    cu_re(0),
-    tmargin(0), bmargin(0),
-    tabstops(0),
-    sel_begin(0), sel_TL(0), sel_BR(0),
-    sel_busy(false),
-    columnmode(false),
-    ef_fg(CharacterColor()), ef_bg(CharacterColor()), ef_re(0),
-    sa_cuX(0), sa_cuY(0),
-    sa_cu_re(0),
+    currentRendition(0),
+    _topMargin(0), _bottomMargin(0),
+    selBegin(0), selTopLeft(0), selBottomRight(0),
+    blockSelectionMode(false),
+    effectiveForeground(CharacterColor()), effectiveBackground(CharacterColor()), effectiveRendition(0),
     lastPos(-1)
 {
-  lineProperties.resize(lines+1);
-  for (int i=0;i<lines+1;i++)
-          lineProperties[i]=LINE_DEFAULT;
+    lineProperties.resize(lines+1);
+    for (int i=0;i<lines+1;i++)
+        lineProperties[i]=LINE_DEFAULT;
 
-  initTabStops();
-  clearSelection();
-  reset();
+    initTabStops();
+    clearSelection();
+    reset();
 }
 
 /*! Destructor
 */
 
 Screen::~Screen()
 {
-  delete[] screenLines;
-  delete[] tabstops;
-  delete hist;
+    delete[] screenLines;
+    delete history;
 }
 
-/* ------------------------------------------------------------------------- */
-/*                                                                           */
-/* Normalized                    Screen Operations                           */
-/*                                                                           */
-/* ------------------------------------------------------------------------- */
-
-// Cursor Setting --------------------------------------------------------------
-
-/*! \section Cursor
-
-    The `cursor' is a location within the screen that is implicitely used in
-    many operations. The operations within this section allow to manipulate
-    the cursor explicitly and to obtain it's value.
-
-    The position of the cursor is guarantied to be between (including) 0 and
-    `columns-1' and `lines-1'.
-*/
-
-/*!
-    Move the cursor up.
-
-    The cursor will not be moved beyond the top margin.
-*/
-
 void Screen::cursorUp(int n)
-//=CUU
+    //=CUU
 {
-  if (n == 0) n = 1; // Default
-  int stop = cuY < tmargin ? 0 : tmargin;
-  cuX = qMin(columns-1,cuX); // nowrap!
-  cuY = qMax(stop,cuY-n);
+    if (n == 0) n = 1; // Default
+    int stop = cuY < _topMargin ? 0 : _topMargin;
+    cuX = qMin(columns-1,cuX); // nowrap!
+    cuY = qMax(stop,cuY-n);
 }
 
-/*!
-    Move the cursor down.
-
-    The cursor will not be moved beyond the bottom margin.
-*/
-
 void Screen::cursorDown(int n)
-//=CUD
+    //=CUD
 {
-  if (n == 0) n = 1; // Default
-  int stop = cuY > bmargin ? lines-1 : bmargin;
-  cuX = qMin(columns-1,cuX); // nowrap!
-  cuY = qMin(stop,cuY+n);
+    if (n == 0) n = 1; // Default
+    int stop = cuY > _bottomMargin ? lines-1 : _bottomMargin;
+    cuX = qMin(columns-1,cuX); // nowrap!
+    cuY = qMin(stop,cuY+n);
 }
 
-/*!
-    Move the cursor left.
-
-    The cursor will not move beyond the first column.
-*/
-
 void Screen::cursorLeft(int n)
-//=CUB
+    //=CUB
 {
-  if (n == 0) n = 1; // Default
-  cuX = qMin(columns-1,cuX); // nowrap!
-  cuX = qMax(0,cuX-n);
+    if (n == 0) n = 1; // Default
+    cuX = qMin(columns-1,cuX); // nowrap!
+    cuX = qMax(0,cuX-n);
 }
 
-/*!
-    Move the cursor left.
-
-    The cursor will not move beyond the rightmost column.
-*/
-
 void Screen::cursorRight(int n)
-//=CUF
+    //=CUF
 {
-  if (n == 0) n = 1; // Default
-  cuX = qMin(columns-1,cuX+n);
+    if (n == 0) n = 1; // Default
+    cuX = qMin(columns-1,cuX+n);
 }
 
 void Screen::setMargins(int top, int bot)
-//=STBM
+    //=STBM
 {
-  if (top == 0) top = 1;      // Default
-  if (bot == 0) bot = lines;  // Default
-  top = top - 1;              // Adjust to internal lineno
-  bot = bot - 1;              // Adjust to internal lineno
-  if ( !( 0 <= top && top < bot && bot < lines ) )
-  { qDebug()<<" setRegion("<<top<<","<<bot<<") : bad range.";
-    return;                   // Default error action: ignore
-  }
-  tmargin = top;
-  bmargin = bot;
-  cuX = 0;
-  cuY = getMode(MODE_Origin) ? top : 0;
+    if (top == 0) top = 1;      // Default
+    if (bot == 0) bot = lines;  // Default
+    top = top - 1;              // Adjust to internal lineno
+    bot = bot - 1;              // Adjust to internal lineno
+    if ( !( 0 <= top && top < bot && bot < lines ) )
+    { //Debug()<<" setRegion("<<top<<","<<bot<<") : bad range.";
+        return;                   // Default error action: ignore
+    }
+    _topMargin = top;
+    _bottomMargin = bot;
+    cuX = 0;
+    cuY = getMode(MODE_Origin) ? top : 0;
 
 }
 
 int Screen::topMargin() const
 {
-    return tmargin;
+    return _topMargin;
 }
 int Screen::bottomMargin() const
 {
-    return bmargin;
+    return _bottomMargin;
 }
 
 void Screen::index()
-//=IND
+    //=IND
 {
-  if (cuY == bmargin)
-  {
-    scrollUp(1);
-  }
-  else if (cuY < lines-1)
-    cuY += 1;
+    if (cuY == _bottomMargin)
+        scrollUp(1);
+    else if (cuY < lines-1)
+        cuY += 1;
 }
 
 void Screen::reverseIndex()
-//=RI
+    //=RI
 {
-  if (cuY == tmargin)
-     scrollDown(tmargin,1);
-  else if (cuY > 0)
-    cuY -= 1;
+    if (cuY == _topMargin)
+        scrollDown(_topMargin,1);
+    else if (cuY > 0)
+        cuY -= 1;
 }
 
-/*!
-    Move the cursor to the begin of the next line.
-
-    If cursor is on bottom margin, the region between the
-    actual top and bottom margin is scrolled up.
-*/
-
-void Screen::NextLine()
-//=NEL
+void Screen::nextLine()
+    //=NEL
 {
-  Return(); index();
+    toStartOfLine(); index();
 }
 
 void Screen::eraseChars(int n)
 {
-  if (n == 0) n = 1; // Default
-  int p = qMax(0,qMin(cuX+n-1,columns-1));
-  clearImage(loc(cuX,cuY),loc(p,cuY),' ');
+    if (n == 0) n = 1; // Default
+    int p = qMax(0,qMin(cuX+n-1,columns-1));
+    clearImage(loc(cuX,cuY),loc(p,cuY),' ');
 }
 
 void Screen::deleteChars(int n)
 {
-  Q_ASSERT( n >= 0 );
+    Q_ASSERT( n >= 0 );
 
-  // always delete at least one char
-  if (n == 0) 
-      n = 1; 
+    // always delete at least one char
+    if (n == 0) 
+        n = 1; 
 
-  // if cursor is beyond the end of the line there is nothing to do
-  if ( cuX >= screenLines[cuY].count() )
-      return;
+    // if cursor is beyond the end of the line there is nothing to do
+    if ( cuX >= screenLines[cuY].count() )
+        return;
 
-  if ( cuX+n >= screenLines[cuY].count() ) 
-       n = screenLines[cuY].count() - 1 - cuX;
+    if ( cuX+n > screenLines[cuY].count() ) 
+        n = screenLines[cuY].count() - cuX;
 
-  Q_ASSERT( n >= 0 );
-  Q_ASSERT( cuX+n < screenLines[cuY].count() );
+    Q_ASSERT( n >= 0 );
+    Q_ASSERT( cuX+n <= screenLines[cuY].count() );
 
-  screenLines[cuY].remove(cuX,n);
+    screenLines[cuY].remove(cuX,n);
 }
 
 void Screen::insertChars(int n)
 {
-  if (n == 0) n = 1; // Default
+    if (n == 0) n = 1; // Default
 
-  if ( screenLines[cuY].size() < cuX )
-    screenLines[cuY].resize(cuX);
+    if ( screenLines[cuY].size() < cuX )
+        screenLines[cuY].resize(cuX);
 
-  screenLines[cuY].insert(cuX,n,' ');
+    screenLines[cuY].insert(cuX,n,' ');
 
-  if ( screenLines[cuY].count() > columns )
-      screenLines[cuY].resize(columns);
+    if ( screenLines[cuY].count() > columns )
+        screenLines[cuY].resize(columns);
 }
 
 void Screen::deleteLines(int n)
 {
-  if (n == 0) n = 1; // Default
-  scrollUp(cuY,n);
+    if (n == 0) n = 1; // Default
+    scrollUp(cuY,n);
 }
 
-/*! insert `n' lines at the cursor position.
-
-    The cursor is not moved by the operation.
-*/
-
 void Screen::insertLines(int n)
 {
-  if (n == 0) n = 1; // Default
-  scrollDown(cuY,n);
+    if (n == 0) n = 1; // Default
+    scrollDown(cuY,n);
 }
 
-// Mode Operations -----------------------------------------------------------
-
-/*! Set a specific mode. */
-
 void Screen::setMode(int m)
 {
-  currParm.mode[m] = true;
-  switch(m)
-  {
-    case MODE_Origin : cuX = 0; cuY = tmargin; break; //FIXME: home
-  }
+    currentModes[m] = true;
+    switch(m)
+    {
+        case MODE_Origin : cuX = 0; cuY = _topMargin; break; //FIXME: home
+    }
 }
 
-/*! Reset a specific mode. */
-
 void Screen::resetMode(int m)
 {
-  currParm.mode[m] = false;
-  switch(m)
-  {
-    case MODE_Origin : cuX = 0; cuY = 0; break; //FIXME: home
-  }
+    currentModes[m] = false;
+    switch(m)
+    {
+        case MODE_Origin : cuX = 0; cuY = 0; break; //FIXME: home
+    }
 }
 
-/*! Save a specific mode. */
-
 void Screen::saveMode(int m)
 {
-  saveParm.mode[m] = currParm.mode[m];
+    savedModes[m] = currentModes[m];
 }
 
-/*! Restore a specific mode. */
-
 void Screen::restoreMode(int m)
 {
-  currParm.mode[m] = saveParm.mode[m];
+    currentModes[m] = savedModes[m];
 }
 
 bool Screen::getMode(int m) const
 {
-  return currParm.mode[m];
+    return currentModes[m];
 }
 
 void Screen::saveCursor()
 {
-  sa_cuX     = cuX;
-  sa_cuY     = cuY;
-  sa_cu_re   = cu_re;
-  sa_cu_fg   = cu_fg;
-  sa_cu_bg   = cu_bg;
+    savedState.cursorColumn = cuX;
+    savedState.cursorLine  = cuY;
+    savedState.rendition = currentRendition;
+    savedState.foreground = currentForeground;
+    savedState.background = currentBackground;
 }
 
 void Screen::restoreCursor()
 {
-  cuX     = qMin(sa_cuX,columns-1);
-  cuY     = qMin(sa_cuY,lines-1);
-  cu_re   = sa_cu_re;
-  cu_fg   = sa_cu_fg;
-  cu_bg   = sa_cu_bg;
-  effectiveRendition();
+    cuX     = qMin(savedState.cursorColumn,columns-1);
+    cuY     = qMin(savedState.cursorLine,lines-1);
+    currentRendition   = savedState.rendition; 
+    currentForeground   = savedState.foreground;
+    currentBackground   = savedState.background;
+    updateEffectiveRendition();
 }
 
-/* ------------------------------------------------------------------------- */
-/*                                                                           */
-/*                             Screen Operations                             */
-/*                                                                           */
-/* ------------------------------------------------------------------------- */
-
-/*! Resize the screen image
-
-    The topmost left position is maintained, while lower lines
-    or right hand side columns might be removed or filled with
-    spaces to fit the new size.
-
-    The region setting is reset to the whole screen and the
-    tab positions reinitialized.
-
-    If the new image is narrower than the old image then text on lines
-    which extends past the end of the new image is preserved so that it becomes
-    visible again if the screen is later resized to make it larger.
-*/
-
 void Screen::resizeImage(int new_lines, int new_columns)
 {
-  if ((new_lines==lines) && (new_columns==columns)) return;
+    if ((new_lines==lines) && (new_columns==columns)) return;
 
-  if (cuY > new_lines-1)
-  { // attempt to preserve focus and lines
-    bmargin = lines-1; //FIXME: margin lost
-    for (int i = 0; i < cuY-(new_lines-1); i++)
-    {
-      addHistLine(); scrollUp(0,1);
+    if (cuY > new_lines-1)
+    { // attempt to preserve focus and lines
+        _bottomMargin = lines-1; //FIXME: margin lost
+        for (int i = 0; i < cuY-(new_lines-1); i++)
+        {
+            addHistLine(); scrollUp(0,1);
+        }
     }
-  }
+
+    // create new screen lines and copy from old to new
+
+    ImageLine* newScreenLines = new ImageLine[new_lines+1];
+    for (int i=0; i < qMin(lines-1,new_lines+1) ;i++)
+        newScreenLines[i]=screenLines[i];
+    for (int i=lines;(i > 0) && (i<new_lines+1);i++)
+        newScreenLines[i].resize( new_columns );
 
-  // create new screen lines and copy from old to new
-  
-   ImageLine* newScreenLines = new ImageLine[new_lines+1];
-   for (int i=0; i < qMin(lines-1,new_lines+1) ;i++)
-           newScreenLines[i]=screenLines[i];
-   for (int i=lines;(i > 0) && (i<new_lines+1);i++)
-           newScreenLines[i].resize( new_columns );
-   
-  lineProperties.resize(new_lines+1);
-  for (int i=lines;(i > 0) && (i<new_lines+1);i++)
-          lineProperties[i] = LINE_DEFAULT;
+    lineProperties.resize(new_lines+1);
+    for (int i=lines;(i > 0) && (i<new_lines+1);i++)
+        lineProperties[i] = LINE_DEFAULT;
+
+    clearSelection();
+
+    delete[] screenLines; 
+    screenLines = newScreenLines;
 
-  clearSelection();
- 
-  delete[] screenLines; 
-  screenLines = newScreenLines;
+    lines = new_lines;
+    columns = new_columns;
+    cuX = qMin(cuX,columns-1);
+    cuY = qMin(cuY,lines-1);
 
-  lines = new_lines;
-  columns = new_columns;
-  cuX = qMin(cuX,columns-1);
-  cuY = qMin(cuY,lines-1);
-
-  // FIXME: try to keep values, evtl.
-  tmargin=0;
-  bmargin=lines-1;
-  initTabStops();
-  clearSelection();
+    // FIXME: try to keep values, evtl.
+    _topMargin=0;
+    _bottomMargin=lines-1;
+    initTabStops();
+    clearSelection();
 }
 
 void Screen::setDefaultMargins()
 {
-	tmargin = 0;
-	bmargin = lines-1;
+    _topMargin = 0;
+    _bottomMargin = lines-1;
 }
 
 
 /*
    Clarifying rendition here and in the display.
 
    currently, the display's color table is
-     0       1       2 .. 9    10 .. 17
-     dft_fg, dft_bg, dim 0..7, intensive 0..7
+   0       1       2 .. 9    10 .. 17
+   dft_fg, dft_bg, dim 0..7, intensive 0..7
 
-   cu_fg, cu_bg contain values 0..8;
+   currentForeground, currentBackground contain values 0..8;
    - 0    = default color
    - 1..8 = ansi specified color
 
    re_fg, re_bg contain values 0..17
    due to the TerminalDisplay's color table
 
    rendition attributes are
 
-      attr           widget screen
-      -------------- ------ ------
-      RE_UNDERLINE     XX     XX    affects foreground only
-      RE_BLINK         XX     XX    affects foreground only
-      RE_BOLD          XX     XX    affects foreground only
-      RE_REVERSE       --     XX
-      RE_TRANSPARENT   XX     --    affects background only
-      RE_INTENSIVE     XX     --    affects foreground only
+   attr           widget screen
+   -------------- ------ ------
+   RE_UNDERLINE     XX     XX    affects foreground only
+   RE_BLINK         XX     XX    affects foreground only
+   RE_BOLD          XX     XX    affects foreground only
+   RE_REVERSE       --     XX
+   RE_TRANSPARENT   XX     --    affects background only
+   RE_INTENSIVE     XX     --    affects foreground only
 
    Note that RE_BOLD is used in both widget
    and screen rendition. Since xterm/vt102
    is to poor to distinguish between bold
    (which is a font attribute) and intensive
    (which is a color attribute), we translate
    this and RE_BOLD in falls eventually appart
    into RE_BOLD and RE_INTENSIVE.
-*/
+   */
 
 void Screen::reverseRendition(Character& p) const
 { 
-	CharacterColor f = p.foregroundColor; 
-	CharacterColor b = p.backgroundColor;
-  	
-	p.foregroundColor = b; 
-	p.backgroundColor = f; //p->r &= ~RE_TRANSPARENT;
+    CharacterColor f = p.foregroundColor; 
+    CharacterColor b = p.backgroundColor;
+
+    p.foregroundColor = b; 
+    p.backgroundColor = f; //p->r &= ~RE_TRANSPARENT;
 }
 
-void Screen::effectiveRendition()
-// calculate rendition
+void Screen::updateEffectiveRendition()
 {
-  //copy "current rendition" straight into "effective rendition", which is then later copied directly
-  //into the image[] array which holds the characters and their appearance properties.
-  //- The old version below filtered out all attributes other than underline and blink at this stage,
-  //so that they would not be copied into the image[] array and hence would not be visible by TerminalDisplay
-  //which actually paints the screen using the information from the image[] array.  
-  //I don't know why it did this, but I'm fairly sure it was the wrong thing to do.  The net result
-  //was that bold text wasn't printed in bold by Konsole.
-  ef_re = cu_re;
-  
-  //OLD VERSION:
-  //ef_re = cu_re & (RE_UNDERLINE | RE_BLINK);
-  
-  if (cu_re & RE_REVERSE)
-  {
-    ef_fg = cu_bg;
-    ef_bg = cu_fg;
-  }
-  else
-  {
-    ef_fg = cu_fg;
-    ef_bg = cu_bg;
-  }
- 
-  if (cu_re & RE_BOLD)
-    ef_fg.toggleIntensive();
+    effectiveRendition = currentRendition;
+    if (currentRendition & RE_REVERSE)
+    {
+        effectiveForeground = currentBackground;
+        effectiveBackground = currentForeground;
+    }
+    else
+    {
+        effectiveForeground = currentForeground;
+        effectiveBackground = currentBackground;
+    }
+
+    if (currentRendition & RE_BOLD)
+        effectiveForeground.toggleIntensive();
 }
 
-/*!
-    returns the image.
-
-    Get the size of the image by \sa getLines and \sa getColumns.
-
-    NOTE that the image returned by this function must later be
-    freed.
-
-*/
-
 void Screen::copyFromHistory(Character* dest, int startLine, int count) const
 {
-  Q_ASSERT( startLine >= 0 && count > 0 && startLine + count <= hist->getLines() );
+    Q_ASSERT( startLine >= 0 && count > 0 && startLine + count <= history->getLines() );
 
-  for (int line = startLine; line < startLine + count; line++) 
-  {
-    const int length = qMin(columns,hist->getLineLen(line));
-    const int destLineOffset  = (line-startLine)*columns;
+    for (int line = startLine; line < startLine + count; line++) 
+    {
+        const int length = qMin(columns,history->getLineLen(line));
+        const int destLineOffset  = (line-startLine)*columns;
 
-    hist->getCells(line,0,length,dest + destLineOffset);
+        history->getCells(line,0,length,dest + destLineOffset);
+
+        for (int column = length; column < columns; column++) 
+            dest[destLineOffset+column] = defaultChar;
 
-    for (int column = length; column < columns; column++) 
-		dest[destLineOffset+column] = defaultChar;
-    
-	// invert selected text
-	if (sel_begin !=-1)
-	{
-    	for (int column = 0; column < columns; column++)
-    	{
-        	if (isSelected(column,line)) 
-			{
-          		reverseRendition(dest[destLineOffset + column]); 
-    		}
-  		}
-	}
-  }
+        // invert selected text
+        if (selBegin !=-1)
+        {
+            for (int column = 0; column < columns; column++)
+            {
+                if (isSelected(column,line)) 
+                {
+                    reverseRendition(dest[destLineOffset + column]); 
+                }
+            }
+        }
+    }
 }
 
 void Screen::copyFromScreen(Character* dest , int startLine , int count) const
 {
-	Q_ASSERT( startLine >= 0 && count > 0 && startLine + count <= lines );
+    Q_ASSERT( startLine >= 0 && count > 0 && startLine + count <= lines );
 
     for (int line = startLine; line < (startLine+count) ; line++)
     {
-       int srcLineStartIndex  = line*columns;
-	   int destLineStartIndex = (line-startLine)*columns;
+        int srcLineStartIndex  = line*columns;
+        int destLineStartIndex = (line-startLine)*columns;
 
-       for (int column = 0; column < columns; column++)
-       { 
-		 int srcIndex = srcLineStartIndex + column; 
-		 int destIndex = destLineStartIndex + column;
+        for (int column = 0; column < columns; column++)
+        { 
+            int srcIndex = srcLineStartIndex + column; 
+            int destIndex = destLineStartIndex + column;
 
-         dest[destIndex] = screenLines[srcIndex/columns].value(srcIndex%columns,defaultChar);
+            dest[destIndex] = screenLines[srcIndex/columns].value(srcIndex%columns,defaultChar);
 
-	     // invert selected text
-         if (sel_begin != -1 && isSelected(column,line + hist->getLines()))
-           reverseRendition(dest[destIndex]); 
-       }
+            // invert selected text
+            if (selBegin != -1 && isSelected(column,line + history->getLines()))
+                reverseRendition(dest[destIndex]); 
+        }
 
     }
 }
 
 void Screen::getImage( Character* dest, int size, int startLine, int endLine ) const
 {
-  Q_ASSERT( startLine >= 0 ); 
-  Q_ASSERT( endLine >= startLine && endLine < hist->getLines() + lines );
+    Q_ASSERT( startLine >= 0 );
+    Q_ASSERT( endLine >= startLine && endLine < history->getLines() + lines );
+
+    const int mergedLines = endLine - startLine + 1;
 
-  const int mergedLines = endLine - startLine + 1;
+    Q_ASSERT( size >= mergedLines * columns ); 
+    Q_UNUSED( size );
 
-  Q_ASSERT( size >= mergedLines * columns ); 
+    const int linesInHistoryBuffer = qBound(0,history->getLines()-startLine,mergedLines);
+    const int linesInScreenBuffer = mergedLines - linesInHistoryBuffer;
 
-  const int linesInHistoryBuffer = qBound(0,hist->getLines()-startLine,mergedLines);
-  const int linesInScreenBuffer = mergedLines - linesInHistoryBuffer;
+    // copy lines from history buffer
+    if (linesInHistoryBuffer > 0)
+        copyFromHistory(dest,startLine,linesInHistoryBuffer); 
 
-  // copy lines from history buffer
-  if (linesInHistoryBuffer > 0) {
-  	copyFromHistory(dest,startLine,linesInHistoryBuffer); 
+    // copy lines from screen buffer
+    if (linesInScreenBuffer > 0)
+        copyFromScreen(dest + linesInHistoryBuffer*columns,
+                startLine + linesInHistoryBuffer - history->getLines(),
+                linesInScreenBuffer);
+
+    // invert display when in screen mode
+    if (getMode(MODE_Screen))
+    {
+        for (int i = 0; i < mergedLines*columns; i++)
+            reverseRendition(dest[i]); // for reverse display
     }
 
-  // copy lines from screen buffer
-  if (linesInScreenBuffer > 0) {
-  	copyFromScreen(dest + linesInHistoryBuffer*columns,
-				   startLine + linesInHistoryBuffer - hist->getLines(),
-				   linesInScreenBuffer);
-    }				
- 
-  // invert display when in screen mode
-  if (getMode(MODE_Screen))
-  {  
-    for (int i = 0; i < mergedLines*columns; i++)
-      reverseRendition(dest[i]); // for reverse display
-  }
-
-  // mark the character at the current cursor position
-  int cursorIndex = loc(cuX, cuY + linesInHistoryBuffer);
-  if(getMode(MODE_Cursor) && cursorIndex < columns*mergedLines)
-    dest[cursorIndex].rendition |= RE_CURSOR;
+    // mark the character at the current cursor position
+    int cursorIndex = loc(cuX, cuY + linesInHistoryBuffer);
+    if(getMode(MODE_Cursor) && cursorIndex < columns*mergedLines)
+        dest[cursorIndex].rendition |= RE_CURSOR;
 }
 
 QVector<LineProperty> Screen::getLineProperties( int startLine , int endLine ) const
 {
-  Q_ASSERT( startLine >= 0 ); 
-  Q_ASSERT( endLine >= startLine && endLine < hist->getLines() + lines );
+    Q_ASSERT( startLine >= 0 ); 
+    Q_ASSERT( endLine >= startLine && endLine < history->getLines() + lines );
 
-	const int mergedLines = endLine-startLine+1;
-	const int linesInHistory = qBound(0,hist->getLines()-startLine,mergedLines);
-  const int linesInScreen = mergedLines - linesInHistory;
+    const int mergedLines = endLine-startLine+1;
+    const int linesInHistory = qBound(0,history->getLines()-startLine,mergedLines);
+    const int linesInScreen = mergedLines - linesInHistory;
 
-  QVector<LineProperty> result(mergedLines);
-  int index = 0;
+    QVector<LineProperty> result(mergedLines);
+    int index = 0;
 
-  // copy properties for lines in history
-  for (int line = startLine; line < startLine + linesInHistory; line++) 
-  {
-		//TODO Support for line properties other than wrapped lines
-	  if (hist->isWrappedLine(line))
-	  {
-	  	result[index] = (LineProperty)(result[index] | LINE_WRAPPED);
-	  }
-    index++;
-  }
-  
-  // copy properties for lines in screen buffer
-  const int firstScreenLine = startLine + linesInHistory - hist->getLines();
-  for (int line = firstScreenLine; line < firstScreenLine+linesInScreen; line++)
-	{
-    result[index]=lineProperties[line];
-  	index++;
-	}
+    // copy properties for lines in history
+    for (int line = startLine; line < startLine + linesInHistory; line++) 
+    {
+        //TODO Support for line properties other than wrapped lines
+        if (history->isWrappedLine(line))
+        {
+            result[index] = (LineProperty)(result[index] | LINE_WRAPPED);
+        }
+        index++;
+    }
 
-  return result;
-}
+    // copy properties for lines in screen buffer
+    const int firstScreenLine = startLine + linesInHistory - history->getLines();
+    for (int line = firstScreenLine; line < firstScreenLine+linesInScreen; line++)
+    {
+        result[index]=lineProperties[line];
+        index++;
+    }
 
-/*!
-*/
+    return result;
+}
 
 void Screen::reset(bool clearScreen)
 {
     setMode(MODE_Wrap  ); saveMode(MODE_Wrap  );  // wrap at end of margin
-  resetMode(MODE_Origin); saveMode(MODE_Origin);  // position refere to [1,1]
-  resetMode(MODE_Insert); saveMode(MODE_Insert);  // overstroke
+    resetMode(MODE_Origin); saveMode(MODE_Origin);  // position refere to [1,1]
+    resetMode(MODE_Insert); saveMode(MODE_Insert);  // overstroke
     setMode(MODE_Cursor);                         // cursor visible
-  resetMode(MODE_Screen);                         // screen not inverse
-  resetMode(MODE_NewLine);
-
-  tmargin=0;
-  bmargin=lines-1;
+    resetMode(MODE_Screen);                         // screen not inverse
+    resetMode(MODE_NewLine);
 
-  setDefaultRendition();
-  saveCursor();
+    _topMargin=0;
+    _bottomMargin=lines-1;
 
-  if ( clearScreen )
-    clear();
+    setDefaultRendition();
+    saveCursor();
+
+    if ( clearScreen )
+        clear();
 }
 
-/*! Clear the entire screen and home the cursor.
-*/
-
 void Screen::clear()
 {
-  clearEntireScreen();
-  home();
+    clearEntireScreen();
+    home();
 }
 
-void Screen::BackSpace()
+void Screen::backspace()
 {
-  cuX = qMin(columns-1,cuX); // nowrap!
-  cuX = qMax(0,cuX-1);
- // if (BS_CLEARS) image[loc(cuX,cuY)].character = ' ';
+    cuX = qMin(columns-1,cuX); // nowrap!
+    cuX = qMax(0,cuX-1);
 
-  if (screenLines[cuY].size() < cuX+1)
-          screenLines[cuY].resize(cuX+1);
+    if (screenLines[cuY].size() < cuX+1)
+        screenLines[cuY].resize(cuX+1);
 
-  if (BS_CLEARS) screenLines[cuY][cuX].character = ' ';
+    if (BS_CLEARS) 
+        screenLines[cuY][cuX].character = ' ';
 }
 
-void Screen::Tabulate(int n)
+void Screen::tab(int n)
 {
-  // note that TAB is a format effector (does not write ' ');
-  if (n == 0) n = 1;
-  while((n > 0) && (cuX < columns-1))
-  {
-    cursorRight(1); while((cuX < columns-1) && !tabstops[cuX]) cursorRight(1);
-    n--;
-  }
+    // note that TAB is a format effector (does not write ' ');
+    if (n == 0) n = 1;
+    while((n > 0) && (cuX < columns-1))
+    {
+        cursorRight(1); 
+        while((cuX < columns-1) && !tabStops[cuX]) 
+            cursorRight(1);
+        n--;
+    }
 }
 
-void Screen::backTabulate(int n)
+void Screen::backtab(int n)
 {
-  // note that TAB is a format effector (does not write ' ');
-  if (n == 0) n = 1;
-  while((n > 0) && (cuX > 0))
-  {
-     cursorLeft(1); while((cuX > 0) && !tabstops[cuX]) cursorLeft(1);
-     n--;
-  }
+    // note that TAB is a format effector (does not write ' ');
+    if (n == 0) n = 1;
+    while((n > 0) && (cuX > 0))
+    {
+        cursorLeft(1); while((cuX > 0) && !tabStops[cuX]) cursorLeft(1);
+        n--;
+    }
 }
 
 void Screen::clearTabStops()
 {
-  for (int i = 0; i < columns; i++) tabstops[i] = false;
+    for (int i = 0; i < columns; i++) tabStops[i] = false;
 }
 
 void Screen::changeTabStop(bool set)
 {
-  if (cuX >= columns) return;
-  tabstops[cuX] = set;
+    if (cuX >= columns) return;
+    tabStops[cuX] = set;
 }
 
 void Screen::initTabStops()
 {
-  delete[] tabstops;
-  tabstops = new bool[columns];
+    tabStops.resize(columns);
 
-  // Arrg! The 1st tabstop has to be one longer than the other.
-  // i.e. the kids start counting from 0 instead of 1.
-  // Other programs might behave correctly. Be aware.
-  for (int i = 0; i < columns; i++) tabstops[i] = (i%8 == 0 && i != 0);
+    // Arrg! The 1st tabstop has to be one longer than the other.
+    // i.e. the kids start counting from 0 instead of 1.
+    // Other programs might behave correctly. Be aware.
+    for (int i = 0; i < columns; i++) 
+        tabStops[i] = (i%8 == 0 && i != 0);
 }
 
-/*!
-   This behaves either as IND (Screen::Index) or as NEL (Screen::NextLine)
-   depending on the NewLine Mode (LNM). This mode also
-   affects the key sequence returned for newline ([CR]LF).
-*/
-
-void Screen::NewLine()
+void Screen::newLine()
 {
-  if (getMode(MODE_NewLine)) Return();
-  index();
+    if (getMode(MODE_NewLine)) 
+        toStartOfLine();
+    index();
 }
 
-/*! put `c' literally onto the screen at the current cursor position.
-
-    VT100 uses the convention to produce an automatic newline (am)
-    with the *first* character that would fall onto the next line (xenl).
-*/
-
 void Screen::checkSelection(int from, int to)
 {
-  if (sel_begin == -1) return;
-  int scr_TL = loc(0, hist->getLines());
-  //Clear entire selection if it overlaps region [from, to]
-  if ( (sel_BR > (from+scr_TL) )&&(sel_TL < (to+scr_TL)) )
-  {
-    clearSelection();
-  }
+    if (selBegin == -1) 
+        return;
+    int scr_TL = loc(0, history->getLines());
+    //Clear entire selection if it overlaps region [from, to]
+    if ( (selBottomRight >= (from+scr_TL)) && (selTopLeft <= (to+scr_TL)) )
+        clearSelection();
 }
 
-void Screen::ShowCharacter(unsigned short c)
+void Screen::displayCharacter(unsigned short c)
 {
-  // Note that VT100 does wrapping BEFORE putting the character.
-  // This has impact on the assumption of valid cursor positions.
-  // We indicate the fact that a newline has to be triggered by
-  // putting the cursor one right to the last column of the screen.
+    // Note that VT100 does wrapping BEFORE putting the character.
+    // This has impact on the assumption of valid cursor positions.
+    // We indicate the fact that a newline has to be triggered by
+    // putting the cursor one right to the last column of the screen.
 
-  int w = konsole_wcwidth(c);
-
-  if (w <= 0)
-     return;
+    int w = konsole_wcwidth(c);
+    if (w <= 0)
+        return;
 
-  if (cuX+w > columns) {
-    if (getMode(MODE_Wrap)) {
-      lineProperties[cuY] = (LineProperty)(lineProperties[cuY] | LINE_WRAPPED);
-      NextLine();
+    if (cuX+w > columns) {
+        if (getMode(MODE_Wrap)) {
+            lineProperties[cuY] = (LineProperty)(lineProperties[cuY] | LINE_WRAPPED);
+            nextLine();
+        }
+        else
+            cuX = columns-w;
     }
-    else
-      cuX = columns-w;
-  }
 
-  // ensure current line vector has enough elements
-  int size = screenLines[cuY].size();
-  if (size == 0 && cuY > 0)
-  {
-          screenLines[cuY].resize( qMax(screenLines[cuY-1].size() , cuX+w) );
-  }
-  else
-  {
+    // ensure current line vector has enough elements
+    int size = screenLines[cuY].size();
     if (size < cuX+w)
     {
-          screenLines[cuY].resize(cuX+w);
+        screenLines[cuY].resize(cuX+w);
     }
-  }
 
-  if (getMode(MODE_Insert)) insertChars(w);
+    if (getMode(MODE_Insert)) insertChars(w);
 
-  lastPos = loc(cuX,cuY);
+    lastPos = loc(cuX,cuY);
 
-  // check if selection is still valid.
-  checkSelection(cuX,cuY);
+    // check if selection is still valid.
+    checkSelection(lastPos, lastPos);
 
-  Character& currentChar = screenLines[cuY][cuX];
+    Character& currentChar = screenLines[cuY][cuX];
 
-  currentChar.character = c;
-  currentChar.foregroundColor = ef_fg;
-  currentChar.backgroundColor = ef_bg;
-  currentChar.rendition = ef_re;
+    currentChar.character = c;
+    currentChar.foregroundColor = effectiveForeground;
+    currentChar.backgroundColor = effectiveBackground;
+    currentChar.rendition = effectiveRendition;
 
-  int i = 0;
-  int newCursorX = cuX + w--;
-  while(w)
-  {
-     i++;
-   
-     if ( screenLines[cuY].size() < cuX + i + 1 )
-         screenLines[cuY].resize(cuX+i+1);
-     
-     Character& ch = screenLines[cuY][cuX + i];
-     ch.character = 0;
-     ch.foregroundColor = ef_fg;
-     ch.backgroundColor = ef_bg;
-     ch.rendition = ef_re;
+    int i = 0;
+    int newCursorX = cuX + w--;
+    while(w)
+    {
+        i++;
+
+        if ( screenLines[cuY].size() < cuX + i + 1 )
+            screenLines[cuY].resize(cuX+i+1);
 
-     w--;
-  }
-  cuX = newCursorX;
+        Character& ch = screenLines[cuY][cuX + i];
+        ch.character = 0;
+        ch.foregroundColor = effectiveForeground;
+        ch.backgroundColor = effectiveBackground;
+        ch.rendition = effectiveRendition;
+
+        w--;
+    }
+    cuX = newCursorX;
 }
 
 void Screen::compose(const QString& /*compose*/)
 {
-   Q_ASSERT( 0 /*Not implemented yet*/ );
+    Q_ASSERT( 0 /*Not implemented yet*/ );
+
+    /*  if (lastPos == -1)
+        return;
 
-/*  if (lastPos == -1)
-     return;
-     
-  QChar c(image[lastPos].character);
-  compose.prepend(c);
-  //compose.compose(); ### FIXME!
-  image[lastPos].character = compose[0].unicode();*/
+        QChar c(image[lastPos].character);
+        compose.prepend(c);
+    //compose.compose(); ### FIXME!
+    image[lastPos].character = compose[0].unicode();*/
 }
 
 int Screen::scrolledLines() const
 {
-        return _scrolledLines;
+    return _scrolledLines;
 }
 int Screen::droppedLines() const
 {
     return _droppedLines;
 }
 void Screen::resetDroppedLines()
 {
     _droppedLines = 0;
 }
 void Screen::resetScrolledLines()
 {
-    //kDebug() << "scrolled lines reset";
-
     _scrolledLines = 0;
 }
 
-// Region commands -------------------------------------------------------------
-
 void Screen::scrollUp(int n)
 {
-   if (n == 0) n = 1; // Default
-   if (tmargin == 0) addHistLine(); // hist.history
-   scrollUp(tmargin, n);
+    if (n == 0) n = 1; // Default
+    if (_topMargin == 0) addHistLine(); // history.history
+    scrollUp(_topMargin, n);
 }
 
-/*! scroll up `n' lines within current region.
-    The `n' new lines are cleared.
-    \sa setRegion \sa scrollDown
-*/
-
 QRect Screen::lastScrolledRegion() const
 {
     return _lastScrolledRegion;
 }
 
 void Screen::scrollUp(int from, int n)
 {
-  if (n <= 0 || from + n > bmargin) return;
+    if (n <= 0 || from + n > _bottomMargin) return;
 
-  _scrolledLines -= n;
-  _lastScrolledRegion = QRect(0,tmargin,columns-1,(bmargin-tmargin));
+    _scrolledLines -= n;
+    _lastScrolledRegion = QRect(0,_topMargin,columns-1,(_bottomMargin-_topMargin));
 
-  //FIXME: make sure `tmargin', `bmargin', `from', `n' is in bounds.
-  moveImage(loc(0,from),loc(0,from+n),loc(columns-1,bmargin));
-  clearImage(loc(0,bmargin-n+1),loc(columns-1,bmargin),' ');
+    //FIXME: make sure `topMargin', `bottomMargin', `from', `n' is in bounds.
+    moveImage(loc(0,from),loc(0,from+n),loc(columns-1,_bottomMargin));
+    clearImage(loc(0,_bottomMargin-n+1),loc(columns-1,_bottomMargin),' ');
 }
 
 void Screen::scrollDown(int n)
 {
-   if (n == 0) n = 1; // Default
-   scrollDown(tmargin, n);
+    if (n == 0) n = 1; // Default
+    scrollDown(_topMargin, n);
 }
 
-/*! scroll down `n' lines within current region.
-    The `n' new lines are cleared.
-    \sa setRegion \sa scrollUp
-*/
-
 void Screen::scrollDown(int from, int n)
 {
-
-  //kDebug() << "Screen::scrollDown( from: " << from << " , n: " << n << ")";
-  
-  _scrolledLines += n;
+    _scrolledLines += n;
 
-//FIXME: make sure `tmargin', `bmargin', `from', `n' is in bounds.
-  if (n <= 0) return;
-  if (from > bmargin) return;
-  if (from + n > bmargin) n = bmargin - from;
-  moveImage(loc(0,from+n),loc(0,from),loc(columns-1,bmargin-n));
-  clearImage(loc(0,from),loc(columns-1,from+n-1),' ');
+    //FIXME: make sure `topMargin', `bottomMargin', `from', `n' is in bounds.
+    if (n <= 0) 
+        return;
+    if (from > _bottomMargin) 
+        return;
+    if (from + n > _bottomMargin) 
+        n = _bottomMargin - from;
+    moveImage(loc(0,from+n),loc(0,from),loc(columns-1,_bottomMargin-n));
+    clearImage(loc(0,from),loc(columns-1,from+n-1),' ');
 }
 
 void Screen::setCursorYX(int y, int x)
 {
-  setCursorY(y); setCursorX(x);
+    setCursorY(y); setCursorX(x);
 }
 
 void Screen::setCursorX(int x)
 {
-  if (x == 0) x = 1; // Default
-  x -= 1; // Adjust
-  cuX = qMax(0,qMin(columns-1, x));
+    if (x == 0) x = 1; // Default
+    x -= 1; // Adjust
+    cuX = qMax(0,qMin(columns-1, x));
 }
 
 void Screen::setCursorY(int y)
 {
-  if (y == 0) y = 1; // Default
-  y -= 1; // Adjust
-  cuY = qMax(0,qMin(lines  -1, y + (getMode(MODE_Origin) ? tmargin : 0) ));
+    if (y == 0) y = 1; // Default
+    y -= 1; // Adjust
+    cuY = qMax(0,qMin(lines  -1, y + (getMode(MODE_Origin) ? _topMargin : 0) ));
 }
 
 void Screen::home()
 {
-  cuX = 0;
-  cuY = 0;
+    cuX = 0;
+    cuY = 0;
 }
 
-void Screen::Return()
+void Screen::toStartOfLine()
 {
-  cuX = 0;
+    cuX = 0;
 }
 
 int Screen::getCursorX() const
 {
-  return cuX;
+    return cuX;
 }
 
 int Screen::getCursorY() const
 {
-  return cuY;
+    return cuY;
 }
 
-// Erasing ---------------------------------------------------------------------
-
-/*! \section Erasing
-
-    This group of operations erase parts of the screen contents by filling
-    it with spaces colored due to the current rendition settings.
-
-    Althought the cursor position is involved in most of these operations,
-    it is never modified by them.
-*/
-
-/*! fill screen between (including) `loca' (start) and `loce' (end) with spaces.
-
-    This is an internal helper functions. The parameter types are internal
-    addresses of within the screen image and make use of the way how the
-    screen matrix is mapped to the image vector.
-*/
-
 void Screen::clearImage(int loca, int loce, char c)
 { 
-  int scr_TL=loc(0,hist->getLines());
-  //FIXME: check positions
+    int scr_TL=loc(0,history->getLines());
+    //FIXME: check positions
 
-  //Clear entire selection if it overlaps region to be moved...
-  if ( (sel_BR > (loca+scr_TL) )&&(sel_TL < (loce+scr_TL)) )
-  {
-    clearSelection();
-  }
+    //Clear entire selection if it overlaps region to be moved...
+    if ( (selBottomRight > (loca+scr_TL) )&&(selTopLeft < (loce+scr_TL)) )
+    {
+        clearSelection();
+    }
 
-  int topLine = loca/columns;
-  int bottomLine = loce/columns;
+    int topLine = loca/columns;
+    int bottomLine = loce/columns;
+
+    Character clearCh(c,currentForeground,currentBackground,DEFAULT_RENDITION);
 
-  Character clearCh(c,cu_fg,cu_bg,DEFAULT_RENDITION);
-  
-  //if the character being used to clear the area is the same as the
-  //default character, the affected lines can simply be shrunk.
-  bool isDefaultCh = (clearCh == Character());
+    //if the character being used to clear the area is the same as the
+    //default character, the affected lines can simply be shrunk.
+    bool isDefaultCh = (clearCh == Character());
 
-  for (int y=topLine;y<=bottomLine;y++)
-  {
+    for (int y=topLine;y<=bottomLine;y++)
+    {
         lineProperties[y] = 0;
 
         int endCol = ( y == bottomLine) ? loce%columns : columns-1;
         int startCol = ( y == topLine ) ? loca%columns : 0;
 
         QVector<Character>& line = screenLines[y];
 
         if ( isDefaultCh && endCol == columns-1 )
@@ -1001,565 +834,525 @@ void Screen::clearImage(int loca, int lo
         {
             if (line.size() < endCol + 1)
                 line.resize(endCol+1);
 
             Character* data = line.data();
             for (int i=startCol;i<=endCol;i++)
                 data[i]=clearCh;
         }
-  }
+    }
 }
 
-/*! move image between (including) `sourceBegin' and `sourceEnd' to 'dest'.
-    
-    The 'dest', 'sourceBegin' and 'sourceEnd' parameters can be generated using
-    the loc(column,line) macro.
-
-NOTE:  moveImage() can only move whole lines.
-
-    This is an internal helper functions. The parameter types are internal
-    addresses of within the screen image and make use of the way how the
-    screen matrix is mapped to the image vector.
-*/
-
 void Screen::moveImage(int dest, int sourceBegin, int sourceEnd)
 {
-  //kDebug() << "moving image from (" << (sourceBegin/columns) 
-  //    << "," << (sourceEnd/columns) << ") to " <<
-  //    (dest/columns);
+    Q_ASSERT( sourceBegin <= sourceEnd );
 
-  Q_ASSERT( sourceBegin <= sourceEnd );
- 
-  int lines=(sourceEnd-sourceBegin)/columns;
+    int lines=(sourceEnd-sourceBegin)/columns;
 
-  //move screen image and line properties:
-  //the source and destination areas of the image may overlap, 
-  //so it matters that we do the copy in the right order - 
-  //forwards if dest < sourceBegin or backwards otherwise.
-  //(search the web for 'memmove implementation' for details)
-  if (dest < sourceBegin)
-  {
-    for (int i=0;i<=lines;i++)
+    //move screen image and line properties:
+    //the source and destination areas of the image may overlap, 
+    //so it matters that we do the copy in the right order - 
+    //forwards if dest < sourceBegin or backwards otherwise.
+    //(search the web for 'memmove implementation' for details)
+    if (dest < sourceBegin)
+    {
+        for (int i=0;i<=lines;i++)
+        {
+            screenLines[ (dest/columns)+i ] = screenLines[ (sourceBegin/columns)+i ];
+            lineProperties[(dest/columns)+i]=lineProperties[(sourceBegin/columns)+i];
+        }
+    }
+    else
     {
-        screenLines[ (dest/columns)+i ] = screenLines[ (sourceBegin/columns)+i ];
-        lineProperties[(dest/columns)+i]=lineProperties[(sourceBegin/columns)+i];
+        for (int i=lines;i>=0;i--)
+        {
+            screenLines[ (dest/columns)+i ] = screenLines[ (sourceBegin/columns)+i ];
+            lineProperties[(dest/columns)+i]=lineProperties[(sourceBegin/columns)+i];
+        }
     }
-  }
-  else
-  {
-    for (int i=lines;i>=0;i--)
+
+    if (lastPos != -1)
     {
-        screenLines[ (dest/columns)+i ] = screenLines[ (sourceBegin/columns)+i ];
-        lineProperties[(dest/columns)+i]=lineProperties[(sourceBegin/columns)+i];
+        int diff = dest - sourceBegin; // Scroll by this amount
+        lastPos += diff;
+        if ((lastPos < 0) || (lastPos >= (lines*columns)))
+            lastPos = -1;
     }
-  }
 
-  if (lastPos != -1)
-  {
-     int diff = dest - sourceBegin; // Scroll by this amount
-     lastPos += diff;
-     if ((lastPos < 0) || (lastPos >= (lines*columns)))
-        lastPos = -1;
-  }
-     
-  // Adjust selection to follow scroll.
-  if (sel_begin != -1)
-  {
-     bool beginIsTL = (sel_begin == sel_TL);
-     int diff = dest - sourceBegin; // Scroll by this amount
-     int scr_TL=loc(0,hist->getLines());
-     int srca = sourceBegin+scr_TL; // Translate index from screen to global
-     int srce = sourceEnd+scr_TL; // Translate index from screen to global
-     int desta = srca+diff;
-     int deste = srce+diff;
+    // Adjust selection to follow scroll.
+    if (selBegin != -1)
+    {
+        bool beginIsTL = (selBegin == selTopLeft);
+        int diff = dest - sourceBegin; // Scroll by this amount
+        int scr_TL=loc(0,history->getLines());
+        int srca = sourceBegin+scr_TL; // Translate index from screen to global
+        int srce = sourceEnd+scr_TL; // Translate index from screen to global
+        int desta = srca+diff;
+        int deste = srce+diff;
+
+        if ((selTopLeft >= srca) && (selTopLeft <= srce))
+            selTopLeft += diff;
+        else if ((selTopLeft >= desta) && (selTopLeft <= deste))
+            selBottomRight = -1; // Clear selection (see below)
 
-     if ((sel_TL >= srca) && (sel_TL <= srce))
-        sel_TL += diff;
-     else if ((sel_TL >= desta) && (sel_TL <= deste))
-        sel_BR = -1; // Clear selection (see below)
-
-     if ((sel_BR >= srca) && (sel_BR <= srce))
-        sel_BR += diff;
-     else if ((sel_BR >= desta) && (sel_BR <= deste))
-        sel_BR = -1; // Clear selection (see below)
+        if ((selBottomRight >= srca) && (selBottomRight <= srce))
+            selBottomRight += diff;
+        else if ((selBottomRight >= desta) && (selBottomRight <= deste))
+            selBottomRight = -1; // Clear selection (see below)
 
-     if (sel_BR < 0)
-     {
-        clearSelection();
-     }
-     else
-     {
-        if (sel_TL < 0)
-           sel_TL = 0;
-     }
+        if (selBottomRight < 0)
+        {
+            clearSelection();
+        }
+        else
+        {
+            if (selTopLeft < 0)
+                selTopLeft = 0;
+        }
 
-     if (beginIsTL)
-        sel_begin = sel_TL;
-     else
-        sel_begin = sel_BR;
-  }
+        if (beginIsTL)
+            selBegin = selTopLeft;
+        else
+            selBegin = selBottomRight;
+    }
 }
 
 void Screen::clearToEndOfScreen()
 {
-  clearImage(loc(cuX,cuY),loc(columns-1,lines-1),' ');
+    clearImage(loc(cuX,cuY),loc(columns-1,lines-1),' ');
 }
 
 void Screen::clearToBeginOfScreen()
 {
-  clearImage(loc(0,0),loc(cuX,cuY),' ');
+    clearImage(loc(0,0),loc(cuX,cuY),' ');
 }
 
 void Screen::clearEntireScreen()
 {
-  // Add entire screen to history
-  for (int i = 0; i < (lines-1); i++)
-  {
-    addHistLine(); scrollUp(0,1);
-  }
+    // Add entire screen to history
+    for (int i = 0; i < (lines-1); i++)
+    {
+        addHistLine(); scrollUp(0,1);
+    }
 
-  clearImage(loc(0,0),loc(columns-1,lines-1),' ');
+    clearImage(loc(0,0),loc(columns-1,lines-1),' ');
 }
 
 /*! fill screen with 'E'
-    This is to aid screen alignment
-*/
+  This is to aid screen alignment
+  */
 
 void Screen::helpAlign()
 {
-  clearImage(loc(0,0),loc(columns-1,lines-1),'E');
+    clearImage(loc(0,0),loc(columns-1,lines-1),'E');
 }
 
 void Screen::clearToEndOfLine()
 {
-  clearImage(loc(cuX,cuY),loc(columns-1,cuY),' ');
+    clearImage(loc(cuX,cuY),loc(columns-1,cuY),' ');
 }
 
 void Screen::clearToBeginOfLine()
 {
-  clearImage(loc(0,cuY),loc(cuX,cuY),' ');
+    clearImage(loc(0,cuY),loc(cuX,cuY),' ');
 }
 
 void Screen::clearEntireLine()
 {
-  clearImage(loc(0,cuY),loc(columns-1,cuY),' ');
+    clearImage(loc(0,cuY),loc(columns-1,cuY),' ');
 }
 
 void Screen::setRendition(int re)
 {
-  cu_re |= re;
-  effectiveRendition();
+    currentRendition |= re;
+    updateEffectiveRendition();
 }
 
 void Screen::resetRendition(int re)
 {
-  cu_re &= ~re;
-  effectiveRendition();
+    currentRendition &= ~re;
+    updateEffectiveRendition();
 }
 
 void Screen::setDefaultRendition()
 {
-  setForeColor(COLOR_SPACE_DEFAULT,DEFAULT_FORE_COLOR);
-  setBackColor(COLOR_SPACE_DEFAULT,DEFAULT_BACK_COLOR);
-  cu_re   = DEFAULT_RENDITION;
-  effectiveRendition();
+    setForeColor(COLOR_SPACE_DEFAULT,DEFAULT_FORE_COLOR);
+    setBackColor(COLOR_SPACE_DEFAULT,DEFAULT_BACK_COLOR);
+    currentRendition   = DEFAULT_RENDITION;
+    updateEffectiveRendition();
 }
 
 void Screen::setForeColor(int space, int color)
 {
-  cu_fg = CharacterColor(space, color);
+    currentForeground = CharacterColor(space, color);
 
-  if ( cu_fg.isValid() ) 
-    effectiveRendition();
-  else 
-    setForeColor(COLOR_SPACE_DEFAULT,DEFAULT_FORE_COLOR);
+    if ( currentForeground.isValid() ) 
+        updateEffectiveRendition();
+    else 
+        setForeColor(COLOR_SPACE_DEFAULT,DEFAULT_FORE_COLOR);
 }
 
 void Screen::setBackColor(int space, int color)
 {
-  cu_bg = CharacterColor(space, color);
+    currentBackground = CharacterColor(space, color);
 
-  if ( cu_bg.isValid() ) 
-    effectiveRendition();
-  else
-    setBackColor(COLOR_SPACE_DEFAULT,DEFAULT_BACK_COLOR);
+    if ( currentBackground.isValid() ) 
+        updateEffectiveRendition();
+    else
+        setBackColor(COLOR_SPACE_DEFAULT,DEFAULT_BACK_COLOR);
 }
 
-/* ------------------------------------------------------------------------- */
-/*                                                                           */
-/*                            Marking & Selection                            */
-/*                                                                           */
-/* ------------------------------------------------------------------------- */
-
-void Screen::clearSelection()
+void Screen::clearSelection() 
 {
-  sel_BR = -1;
-  sel_TL = -1;
-  sel_begin = -1;
+    selBottomRight = -1;
+    selTopLeft = -1;
+    selBegin = -1;
 }
 
-void Screen::getSelectionStart(int& column , int& line)
+void Screen::getSelectionStart(int& column , int& line) const
 {
-    if ( sel_TL != -1 )
+    if ( selTopLeft != -1 )
     {
-        column = sel_TL % columns;
-        line = sel_TL / columns; 
+        column = selTopLeft % columns;
+        line = selTopLeft / columns; 
     }
     else
     {
         column = cuX + getHistLines();
         line = cuY + getHistLines();
     }
 }
-void Screen::getSelectionEnd(int& column , int& line)
+void Screen::getSelectionEnd(int& column , int& line) const
 {
-    if ( sel_BR != -1 )
+    if ( selBottomRight != -1 )
     {
-        column = sel_BR % columns;
-        line = sel_BR / columns;
+        column = selBottomRight % columns;
+        line = selBottomRight / columns;
     }
     else
     {
         column = cuX + getHistLines();
         line = cuY + getHistLines();
     } 
 }
-void Screen::setSelectionStart(/*const ScreenCursor& viewCursor ,*/ const int x, const int y, const bool mode)
+void Screen::setSelectionStart(const int x, const int y, const bool mode)
 {
-//  kDebug(1211) << "setSelBeginXY(" << x << "," << y << ")";
-  sel_begin = loc(x,y); //+histCursor) ;
+    selBegin = loc(x,y); 
+    /* FIXME, HACK to correct for x too far to the right... */
+    if (x == columns) selBegin--;
 
-  /* FIXME, HACK to correct for x too far to the right... */
-  if (x == columns) sel_begin--;
-
-  sel_BR = sel_begin;
-  sel_TL = sel_begin;
-  columnmode = mode;
+    selBottomRight = selBegin;
+    selTopLeft = selBegin;
+    blockSelectionMode = mode;
 }
 
 void Screen::setSelectionEnd( const int x, const int y)
 {
-//  kDebug(1211) << "setSelExtentXY(" << x << "," << y << ")";
-  if (sel_begin == -1) return;
-  int l =  loc(x,y); // + histCursor);
+    if (selBegin == -1) 
+        return;
+
+    int endPos =  loc(x,y); 
+
+    if (endPos < selBegin)
+    {
+        selTopLeft = endPos;
+        selBottomRight = selBegin;
+    }
+    else
+    {
+        /* FIXME, HACK to correct for x too far to the right... */
+        if (x == columns) 
+            endPos--;
 
-  if (l < sel_begin)
-  {
-    sel_TL = l;
-    sel_BR = sel_begin;
-  }
-  else
-  {
-    /* FIXME, HACK to correct for x too far to the right... */
-    if (x == columns) l--;
+        selTopLeft = selBegin;
+        selBottomRight = endPos;
+    }
 
-    sel_TL = sel_begin;
-    sel_BR = l;
-  }
+    // Normalize the selection in column mode
+    if (blockSelectionMode)
+    {
+        int topRow = selTopLeft / columns;
+        int topColumn = selTopLeft % columns;
+        int bottomRow = selBottomRight / columns;
+        int bottomColumn = selBottomRight % columns;
+
+        selTopLeft = loc(qMin(topColumn,bottomColumn),topRow);
+        selBottomRight = loc(qMax(topColumn,bottomColumn),bottomRow);
+    }
 }
 
 bool Screen::isSelected( const int x,const int y) const
 {
-  if (columnmode) {
-    int sel_Left,sel_Right;
-    if ( sel_TL % columns < sel_BR % columns ) {
-      sel_Left = sel_TL; sel_Right = sel_BR;
-    } else {
-      sel_Left = sel_BR; sel_Right = sel_TL;
+    bool columnInSelection = true;
+    if (blockSelectionMode)
+    {
+        columnInSelection = x >= (selTopLeft % columns) &&
+            x <= (selBottomRight % columns);
     }
-    return ( x >= sel_Left % columns ) && ( x <= sel_Right % columns ) &&
-           ( y >= sel_TL / columns ) && ( y <= sel_BR / columns );
-            //( y+histCursor >= sel_TL / columns ) && ( y+histCursor <= sel_BR / columns );
-  }
-  else {
-  //int pos = loc(x,y+histCursor);
-  int pos = loc(x,y);
-  return ( pos >= sel_TL && pos <= sel_BR );
-  }
+
+    int pos = loc(x,y);
+    return pos >= selTopLeft && pos <= selBottomRight && columnInSelection;
 }
 
-QString Screen::selectedText(bool preserveLineBreaks)
+QString Screen::selectedText(bool preserveLineBreaks) const
 {
-  QString result;
-  QTextStream stream(&result, QIODevice::ReadWrite);
-  
-  PlainTextDecoder decoder;
-  decoder.begin(&stream);
-  writeSelectionToStream(&decoder , preserveLineBreaks);
-  decoder.end();
-  
-  return result;
+    QString result;
+    QTextStream stream(&result, QIODevice::ReadWrite);
+
+    PlainTextDecoder decoder;
+    decoder.begin(&stream);
+    writeSelectionToStream(&decoder , preserveLineBreaks);
+    decoder.end();
+
+    return result;
 }
 
 bool Screen::isSelectionValid() const
 {
-    return ( sel_TL >= 0 && sel_BR >= 0 );
+    return selTopLeft >= 0 && selBottomRight >= 0;
 }
 
 void Screen::writeSelectionToStream(TerminalCharacterDecoder* decoder , 
-                                    bool preserveLineBreaks)
+        bool preserveLineBreaks) const
 {
-    // do nothing if selection is invalid
-    if ( !isSelectionValid() )
+    if (!isSelectionValid())
         return;
+    writeToStream(decoder,selTopLeft,selBottomRight,preserveLineBreaks);
+}
 
-	int top = sel_TL / columns;	
-	int left = sel_TL % columns;
+void Screen::writeToStream(TerminalCharacterDecoder* decoder, 
+        int startIndex, int endIndex,
+        bool preserveLineBreaks) const
+{
+    int top = startIndex / columns;    
+    int left = startIndex % columns;
 
-	int bottom = sel_BR / columns;
-	int right = sel_BR % columns;
+    int bottom = endIndex / columns;
+    int right = endIndex % columns;
 
     Q_ASSERT( top >= 0 && left >= 0 && bottom >= 0 && right >= 0 );
 
-    //kDebug() << "sel_TL = " << sel_TL;
-    //kDebug() << "columns = " << columns;
+    for (int y=top;y<=bottom;y++)
+    {
+        int start = 0;
+        if ( y == top || blockSelectionMode ) start = left;
+
+        int count = -1;
+        if ( y == bottom || blockSelectionMode ) count = right - start + 1;
 
-	for (int y=top;y<=bottom;y++)
-	{
-			int start = 0;
-			if ( y == top || columnmode ) start = left;
-		
-			int count = -1;
-			if ( y == bottom || columnmode ) count = right - start + 1;
+        const bool appendNewLine = ( y != bottom );
+        int copied = copyLineToStream( y,
+                start,
+                count,
+                decoder, 
+                appendNewLine,
+                preserveLineBreaks );
 
-            const bool appendNewLine = ( y != bottom );
-			copyLineToStream( y,
-                              start,
-                              count,
-                              decoder, 
-                              appendNewLine,
-                              preserveLineBreaks );
-	}	
+        // if the selection goes beyond the end of the last line then
+        // append a new line character.
+        //
+        // this makes it possible to 'select' a trailing new line character after
+        // the text on a line.  
+        if ( y == bottom && 
+                copied < count    )
+        {
+            Character newLineChar('\n');
+            decoder->decodeLine(&newLineChar,1,0);
+        }
+    }    
 }
 
-
-void Screen::copyLineToStream(int line , 
-                              int start, 
-                              int count,
-                              TerminalCharacterDecoder* decoder,
-                              bool appendNewLine,
-                              bool preserveLineBreaks)
+int Screen::copyLineToStream(int line , 
+        int start, 
+        int count,
+        TerminalCharacterDecoder* decoder,
+        bool appendNewLine,
+        bool preserveLineBreaks) const
 {
-		//buffer to hold characters for decoding
-		//the buffer is static to avoid initialising every 
-        //element on each call to copyLineToStream
-		//(which is unnecessary since all elements will be overwritten anyway)
-		static const int MAX_CHARS = 1024;
-		static Character characterBuffer[MAX_CHARS];
-		
-		assert( count < MAX_CHARS );
-
-        LineProperty currentLineProperties = 0;
+    //buffer to hold characters for decoding
+    //the buffer is static to avoid initialising every 
+    //element on each call to copyLineToStream
+    //(which is unnecessary since all elements will be overwritten anyway)
+    static const int MAX_CHARS = 1024;
+    static Character characterBuffer[MAX_CHARS];
 
-		//determine if the line is in the history buffer or the screen image
-		if (line < hist->getLines())
-		{
-            const int lineLength = hist->getLineLen(line);
-
-            // ensure that start position is before end of line
-            start = qMin(start,qMax(0,lineLength-1));
+    assert( count < MAX_CHARS );
 
-			//retrieve line from history buffer
-			if (count == -1)
-            {
-					count = lineLength-start;
-            }
-			else
-            {
-					count = qMin(start+count,lineLength)-start;
-            }
-
-            // safety checks
-            assert( start >= 0 );
-            assert( count >= 0 );    
-            assert( (start+count) <= hist->getLineLen(line) );
-
-			hist->getCells(line,start,count,characterBuffer);
+    LineProperty currentLineProperties = 0;
 
-            if ( hist->isWrappedLine(line) )
-                currentLineProperties |= LINE_WRAPPED;
-		}
-		else
-		{
-			if ( count == -1 )
-					count = columns - start;
-
-            assert( count >= 0 );
+    //determine if the line is in the history buffer or the screen image
+    if (line < history->getLines())
+    {
+        const int lineLength = history->getLineLen(line);
 
-            const int screenLine = line-hist->getLines();
-
-            Character* data = screenLines[screenLine].data();
-            int length = screenLines[screenLine].count();
-
-			//retrieve line from screen image
-			for (int i=start;i < qMin(start+count,length);i++)
-			{
-			    characterBuffer[i-start] = data[i];
-            }
+        // ensure that start position is before end of line
+        start = qMin(start,qMax(0,lineLength-1));
 
-            // count cannot be any greater than length
-			count = qBound(0,count,length-start);
-
-            Q_ASSERT( screenLine < lineProperties.count() );
-            currentLineProperties |= lineProperties[screenLine]; 
-		}
-
-		//do not decode trailing whitespace characters
-		for (int i=count-1 ; i >= 0; i--)
-				if (QChar(characterBuffer[i].character).isSpace())
-						count--;
-				else
-						break;
-
-        // add new line character at end
-        const bool omitLineBreak = (currentLineProperties & LINE_WRAPPED) ||
-                                   !preserveLineBreaks;
-
-        if ( !omitLineBreak && appendNewLine && (count+1 < MAX_CHARS) )
+        // retrieve line from history buffer.  It is assumed
+        // that the history buffer does not store trailing white space
+        // at the end of the line, so it does not need to be trimmed here 
+        if (count == -1)
         {
-            characterBuffer[count] = '\n';
-            count++;
+            count = lineLength-start;
+        }
+        else
+        {
+            count = qMin(start+count,lineLength)-start;
         }
 
-		//decode line and write to text stream	
-		decoder->decodeLine( (Character*) characterBuffer , 
-                             count, currentLineProperties );
+        // safety checks
+        assert( start >= 0 );
+        assert( count >= 0 );    
+        assert( (start+count) <= history->getLineLen(line) );
+
+        history->getCells(line,start,count,characterBuffer);
+
+        if ( history->isWrappedLine(line) )
+            currentLineProperties |= LINE_WRAPPED;
+    }
+    else
+    {
+        if ( count == -1 )
+            count = columns - start;
+
+        assert( count >= 0 );
+
+        const int screenLine = line-history->getLines();
+
+        Character* data = screenLines[screenLine].data();
+        int length = screenLines[screenLine].count();
+
+        //retrieve line from screen image
+        for (int i=start;i < qMin(start+count,length);i++)
+        {
+            characterBuffer[i-start] = data[i];
+        }
+
+        // count cannot be any greater than length
+        count = qBound(0,count,length-start);
+
+        Q_ASSERT( screenLine < lineProperties.count() );
+        currentLineProperties |= lineProperties[screenLine]; 
+    }
+
+    // add new line character at end
+    const bool omitLineBreak = (currentLineProperties & LINE_WRAPPED) ||
+        !preserveLineBreaks;
+
+    if ( !omitLineBreak && appendNewLine && (count+1 < MAX_CHARS) )
+    {
+        characterBuffer[count] = '\n';
+        count++;
+    }
+
+    //decode line and write to text stream    
+    decoder->decodeLine( (Character*) characterBuffer , 
+            count, currentLineProperties );
+
+    return count;
 }
 
-// Method below has been removed because of its reliance on 'histCursor'
-// and I want to restrict the methods which have knowledge of the scroll position
-// to just those which deal with selection and supplying final screen images.
-//
-/*void Screen::writeToStream(QTextStream* stream , TerminalCharacterDecoder* decoder) {
-  sel_begin = 0;
-  sel_BR = sel_begin;
-  sel_TL = sel_begin;
-  setSelectionEnd(columns-1,lines-1+hist->getLines()-histCursor);
-  
-  writeSelectionToStream(stream,decoder);
-  
-  clearSelection();
-}*/
-
-void Screen::writeToStream(TerminalCharacterDecoder* decoder, int from, int to)
+void Screen::writeLinesToStream(TerminalCharacterDecoder* decoder, int fromLine, int toLine) const
 {
-	sel_begin = loc(0,from);
-	sel_TL = sel_begin;
-	sel_BR = loc(columns-1,to);
-	writeSelectionToStream(decoder);
-	clearSelection();
-}
-
-QString Screen::getHistoryLine(int no)
-{
-  sel_begin = loc(0,no);
-  sel_TL = sel_begin;
-  sel_BR = loc(columns-1,no);
-  return selectedText(false);
+    writeToStream(decoder,loc(0,fromLine),loc(columns-1,toLine));
 }
 
 void Screen::addHistLine()
 {
-  // add line to history buffer
-  // we have to take care about scrolling, too...
+    // add line to history buffer
+    // we have to take care about scrolling, too...
 
-  if (hasScroll())
-  {
-    int oldHistLines = hist->getLines();
+    if (hasScroll())
+    {
+        int oldHistLines = history->getLines();
 
-    hist->addCellsVector(screenLines[0]);
-    hist->addLine( lineProperties[0] & LINE_WRAPPED );
+        history->addCellsVector(screenLines[0]);
+        history->addLine( lineProperties[0] & LINE_WRAPPED );
+
+        int newHistLines = history->getLines();
 
-    int newHistLines = hist->getLines();
+        bool beginIsTL = (selBegin == selTopLeft);
 
-    bool beginIsTL = (sel_begin == sel_TL);
+        // If the history is full, increment the count
+        // of dropped lines
+        if ( newHistLines == oldHistLines )
+            _droppedLines++;
 
-    // If the history is full, increment the count
-    // of dropped lines
-    if ( newHistLines == oldHistLines )
-        _droppedLines++;
+        // Adjust selection for the new point of reference
+        if (newHistLines > oldHistLines)
+        {
+            if (selBegin != -1)
+            {
+                selTopLeft += columns;
+                selBottomRight += columns;
+            }
+        }
+
+        if (selBegin != -1)
+        {
+            // Scroll selection in history up
+            int top_BR = loc(0, 1+newHistLines);
 
-    // Adjust selection for the new point of reference
-    if (newHistLines > oldHistLines)
-    {
-       if (sel_begin != -1)
-       {
-          sel_TL += columns;
-          sel_BR += columns;
-       }
+            if (selTopLeft < top_BR)
+                selTopLeft -= columns;
+
+            if (selBottomRight < top_BR)
+                selBottomRight -= columns;
+
+            if (selBottomRight < 0)
+                clearSelection();
+            else
+            {
+                if (selTopLeft < 0)
+                    selTopLeft = 0;
+            }
+
+            if (beginIsTL)
+                selBegin = selTopLeft;
+            else
+                selBegin = selBottomRight;
+        }
     }
 
-    if (sel_begin != -1)
-    {
-       // Scroll selection in history up
-       int top_BR = loc(0, 1+newHistLines);
-
-       if (sel_TL < top_BR)
-          sel_TL -= columns;
-
-       if (sel_BR < top_BR)
-          sel_BR -= columns;
-
-       if (sel_BR < 0)
-       {
-          clearSelection();
-       }
-       else
-       {
-          if (sel_TL < 0)
-             sel_TL = 0;
-       }
-
-       if (beginIsTL)
-          sel_begin = sel_TL;
-       else
-          sel_begin = sel_BR;
-    }
-  }
-
 }
 
-int Screen::getHistLines()
+int Screen::getHistLines() const
 {
-  return hist->getLines();
+    return history->getLines();
 }
 
 void Screen::setScroll(const HistoryType& t , bool copyPreviousScroll)
 {
-  clearSelection();
+    clearSelection();
 
-  if ( copyPreviousScroll )
-    hist = t.scroll(hist);
-  else
-  {
-      HistoryScroll* oldScroll = hist;
-      hist = t.scroll(0);
-      delete oldScroll;
-  }
+    if ( copyPreviousScroll )
+        history = t.scroll(history);
+    else
+    {
+        HistoryScroll* oldScroll = history;
+        history = t.scroll(0);
+        delete oldScroll;
+    }
 }
 
-bool Screen::hasScroll()
+bool Screen::hasScroll() const
 {
-  return hist->hasScroll();
+    return history->hasScroll();
 }
 
-const HistoryType& Screen::getScroll()
+const HistoryType& Screen::getScroll() const
 {
-  return hist->getType();
+    return history->getType();
 }
 
 void Screen::setLineProperty(LineProperty property , bool enable)
 {
-	if ( enable )
-	{
-		lineProperties[cuY] = (LineProperty)(lineProperties[cuY] | property);
-	}
-	else
-	{
-		lineProperties[cuY] = (LineProperty)(lineProperties[cuY] & ~property);
-	}
+    if ( enable )
+        lineProperties[cuY] = (LineProperty)(lineProperties[cuY] | property);
+    else
+        lineProperties[cuY] = (LineProperty)(lineProperties[cuY] & ~property);
 }
 void Screen::fillWithDefaultChar(Character* dest, int count)
 {
-	for (int i=0;i<count;i++)
-		dest[i] = defaultChar;
+    for (int i=0;i<count;i++)
+        dest[i] = defaultChar;
 }
diff --git a/gui//src/Screen.h b/gui//src/Screen.h
--- a/gui//src/Screen.h
+++ b/gui//src/Screen.h
@@ -1,15 +1,13 @@
 /*
     This file is part of Konsole, KDE's terminal.
 
-    Copyright (C) 2007 by Robert Knight <robertknight@gmail.com>
-    Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
-
-    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+    Copyright 2007-2008 by Robert Knight <robertknight@gmail.com>
+    Copyright 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
 
     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -37,21 +35,16 @@
 #define MODE_Origin    0
 #define MODE_Wrap      1
 #define MODE_Insert    2
 #define MODE_Screen    3
 #define MODE_Cursor    4
 #define MODE_NewLine   5
 #define MODES_SCREEN   6
 
-struct ScreenParm
-{
-  int mode[MODES_SCREEN];
-};
-
 class TerminalCharacterDecoder;
 
 /**
     \brief An image of characters with associated attributes.
 
     The terminal emulation ( Emulation ) receives a serial stream of
     characters from the program currently running in the terminal.
     From this stream it creates an image of characters which is ultimately
@@ -64,50 +57,62 @@ class TerminalCharacterDecoder;
 
     The number of lines of output history which are kept in addition to the current
     screen image depends on the history scroll being used to store the output.  
     The scroll is specified using setScroll()
     The output history can be retrieved using writeToStream()
 
     The screen image has a selection associated with it, specified using 
     setSelectionStart() and setSelectionEnd().  The selected text can be retrieved
-    using selectedText().  When getImage() is used to retrieve the the visible image,
+    using selectedText().  When getImage() is used to retrieve the visible image,
     characters which are part of the selection have their colours inverted.   
 */
 class Screen
 {
 public:
     /** Construct a new screen image of size @p lines by @p columns. */
     Screen(int lines, int columns);
     ~Screen();
 
     // VT100/2 Operations 
     // Cursor Movement
     
-    /** Move the cursor up by @p n lines. */
-    void cursorUp    (int n);
-    /** Move the cursor down by @p n lines. */
-    void cursorDown  (int n);
-    /** Move the cursor to the left by @p n columns. */
-    void cursorLeft  (int n);
-    /** Move the cursor to the right by @p n columns. */
-    void cursorRight (int n);
+    /** 
+     * Move the cursor up by @p n lines.  The cursor will stop at the 
+     * top margin.
+     */
+    void cursorUp(int n);
+    /** 
+     * Move the cursor down by @p n lines.  The cursor will stop at the
+     * bottom margin.
+     */
+    void cursorDown(int n);
+    /** 
+     * Move the cursor to the left by @p n columns.
+     * The cursor will stop at the first column.
+     */
+    void cursorLeft(int n);
+    /** 
+     * Move the cursor to the right by @p n columns.
+     * The cursor will stop at the right-most column.
+     */
+    void cursorRight(int n);
     /** Position the cursor on line @p y. */
-    void setCursorY  (int y);
+    void setCursorY(int y);
     /** Position the cursor at column @p x. */
-    void setCursorX  (int x);
+    void setCursorX(int x);
     /** Position the cursor at line @p y, column @p x. */
-    void setCursorYX (int y, int x);
+    void setCursorYX(int y, int x);
     /**
      * Sets the margins for scrolling the screen.
      *
      * @param topLine The top line of the new scrolling margin. 
      * @param bottomLine The bottom line of the new scrolling margin. 
      */
-    void setMargins  (int topLine , int bottomLine);
+    void setMargins(int topLine , int bottomLine);
     /** Returns the top line of the scrolling region. */ 
     int topMargin() const;
     /** Returns the bottom line of the scrolling region. */
     int bottomMargin() const;
 
     /** 
      * Resets the scrolling margins back to the top and bottom lines
      * of the screen.
@@ -117,29 +122,29 @@ public:
     /** 
      * Moves the cursor down one line, if the MODE_NewLine mode 
      * flag is enabled then the cursor is returned to the leftmost
      * column first.
      *
      * Equivalent to NextLine() if the MODE_NewLine flag is set
      * or index() otherwise. 
      */
-    void NewLine     ();
+    void newLine();
     /**
      * Moves the cursor down one line and positions it at the beginning
-     * of the line.
+     * of the line.  Equivalent to calling Return() followed by index()
      */
-    void NextLine    ();
+    void nextLine();
 
     /** 
      * Move the cursor down one line.  If the cursor is on the bottom
      * line of the scrolling region (as returned by bottomMargin()) the
      * scrolling region is scrolled up by one line instead.
      */
-    void index       ();
+    void index();
     /**
      * Move the cursor up one line.  If the cursor is on the top line
      * of the scrolling region (as returned by topMargin()) the scrolling
      * region is scrolled down by one line instead.
      */
     void reverseIndex();
     
     /** 
@@ -149,93 +154,88 @@ public:
      */ 
     void scrollUp(int n);
     /**
      * Scroll the scrolling region of the screen down by @p n lines.
      * The scrolling region is initially the whole screen, but can be changed
      * using setMargins()
      */
     void scrollDown(int n);
-    
     /** 
      * Moves the cursor to the beginning of the current line. 
      * Equivalent to setCursorX(0)
      */
-    void Return      ();
+    void toStartOfLine();
     /** 
      * Moves the cursor one column to the left and erases the character
      * at the new cursor position.
      */
-    void BackSpace   ();
-    /** 
-     * Moves the cursor @p n tab-stops to the right.
-     */
-    void Tabulate    (int n = 1);
-    /** 
-     * Moves the cursor @p n tab-stops to the left. 
-     */
-    void backTabulate(int n);
+    void backspace();
+    /** Moves the cursor @p n tab-stops to the right. */
+    void tab(int n = 1);
+    /** Moves the cursor @p n tab-stops to the left. */
+    void backtab(int n);
     
     // Editing
     
     /** 
      * Erase @p n characters beginning from the current cursor position. 
      * This is equivalent to over-writing @p n characters starting with the current
      * cursor position with spaces.
      * If @p n is 0 then one character is erased. 
      */
-    void eraseChars  (int n);
+    void eraseChars(int n);
     /** 
      * Delete @p n characters beginning from the current cursor position. 
      * If @p n is 0 then one character is deleted. 
      */
-    void deleteChars (int n);
+    void deleteChars(int n);
     /**
      * Insert @p n blank characters beginning from the current cursor position.
      * The position of the cursor is not altered.  
      * If @p n is 0 then one character is inserted.
      */
-    void insertChars (int n);
+    void insertChars(int n);
     /** 
      * Removes @p n lines beginning from the current cursor position.
      * The position of the cursor is not altered.
      * If @p n is 0 then one line is removed.
      */
-    void deleteLines (int n);
+    void deleteLines(int n);
     /**
      * Inserts @p lines beginning from the current cursor position.
      * The position of the cursor is not altered.
      * If @p n is 0 then one line is inserted.
      */
-    void insertLines (int n);
+    void insertLines(int n);
     /** Clears all the tab stops. */
     void clearTabStops();
     /**  Sets or removes a tab stop at the cursor's current column. */ 
     void changeTabStop(bool set);
    
     /** Resets (clears) the specified screen @p mode. */
-    void resetMode   (int mode);
+    void resetMode(int mode);
     /** Sets (enables) the specified screen @p mode. */
-    void setMode     (int mode);
+    void setMode(int mode);
     /** 
      * Saves the state of the specified screen @p mode.  It can be restored
      * using restoreMode()
      */
-    void saveMode    (int mode);
+    void saveMode(int mode);
     /** Restores the state of a screen @p mode saved by calling saveMode() */
-    void restoreMode (int mode);
+    void restoreMode(int mode);
     /** Returns whether the specified screen @p mode is enabled or not .*/
-    bool getMode     (int mode) const;
+    bool getMode(int mode) const;
    
     /** 
-     * Saves the current position and appearence (text color and style) of the cursor. 
+     * Saves the current position and appearance (text color and style) of the cursor. 
      * It can be restored by calling restoreCursor() 
      */ 
-    void saveCursor  ();
-    /** Restores the position and appearence of the cursor.  See saveCursor() */
+    void saveCursor();
+    /** Restores the position and appearance of the cursor.  See saveCursor() */
     void restoreCursor();
    
     /** Clear the whole screen, moving the current screen contents into the history first. */ 
     void clearEntireScreen();
     /** 
      * Clear the area of the screen from the current cursor position to the end of 
      * the screen.
      */
@@ -248,64 +248,66 @@ public:
     /** Clears the whole of the line on which the cursor is currently positioned. */
     void clearEntireLine();
     /** Clears from the current cursor position to the end of the line. */
     void clearToEndOfLine();
     /** Clears from the current cursor position to the beginning of the line. */
     void clearToBeginOfLine();
     
     /** Fills the entire screen with the letter 'E' */
-    void helpAlign   ();
+    void helpAlign();
        
     /** 
-     * Enables the given @p rendition flag.  Rendition flags control the appearence 
+     * Enables the given @p rendition flag.  Rendition flags control the appearance 
      * of characters on the screen.
      *
      * @see Character::rendition
      */  
-    void setRendition  (int rendition);
+    void setRendition(int rendition);
     /**
-     * Disables the given @p rendition flag.  Rendition flags control the appearence
+     * Disables the given @p rendition flag.  Rendition flags control the appearance
      * of characters on the screen.
      *
      * @see Character::rendition
      */
     void resetRendition(int rendition);
     
     /** 
      * Sets the cursor's foreground color.
      * @param space The color space used by the @p color argument
      * @param color The new foreground color.  The meaning of this depends on
      * the color @p space used.
      *
      * @see CharacterColor
      */
-    void setForeColor  (int space, int color);
+    void setForeColor(int space, int color);
     /**
      * Sets the cursor's background color.
      * @param space The color space used by the @p color argumnet.
      * @param color The new background color.  The meaning of this depends on
      * the color @p space used.
      *
      * @see CharacterColor
      */
-    void setBackColor  (int space, int color);
+    void setBackColor(int space, int color);
     /** 
      * Resets the cursor's color back to the default and sets the 
      * character's rendition flags back to the default settings.
      */
     void setDefaultRendition();
     
     /** Returns the column which the cursor is positioned at. */
     int  getCursorX() const;
     /** Returns the line which the cursor is positioned on. */
     int  getCursorY() const;
    
-	/** TODO Document me */ 
-	void clear();
+    /** Clear the entire screen and move the cursor to the home position.
+     * Equivalent to calling clearEntireScreen() followed by home().
+     */
+    void clear();
     /** 
      * Sets the position of the cursor to the 'home' position at the top-left
      * corner of the screen (0,0) 
      */
     void home();
     /**
      * Resets the state of the screen.  This resets the various screen modes
      * back to their default states.  The cursor style and colors are reset
@@ -331,29 +333,30 @@ public:
      * If the cursor is currently positioned at the right-edge of the screen and
      * line wrapping is enabled then the character is added at the start of a new 
      * line below the current one.
      *
      * If the MODE_Insert screen mode is currently enabled then the character 
      * is inserted at the current cursor position, otherwise it will replace the 
      * character already at the current cursor position.  
      */ 
-    void ShowCharacter(unsigned short c);
+    void displayCharacter(unsigned short c);
     
     // Do composition with last shown character FIXME: Not implemented yet for KDE 4
     void compose(const QString& compose);
     
     /** 
      * Resizes the image to a new fixed size of @p new_lines by @p new_columns.  
      * In the case that @p new_columns is smaller than the current number of columns,
      * existing lines are not truncated.  This prevents characters from being lost
      * if the terminal display is resized smaller and then larger again.
      *
-     * (note that in versions of Konsole prior to KDE 4, existing lines were
-     *  truncated when making the screen image smaller)
+     * The top and bottom margins are reset to the top and bottom of the new 
+     * screen size.  Tab stops are also reset and the current selection is
+     * cleared.
      */
     void resizeImage(int new_lines, int new_columns);
     
     /**
      * Returns the current screen image.  
      * The result is an array of Characters of size [getLines()][getColumns()] which
      * must be freed by the caller after use.
      *
@@ -366,132 +369,137 @@ public:
 
     /** 
      * Returns the additional attributes associated with lines in the image.
      * The most important attribute is LINE_WRAPPED which specifies that the 
      * line is wrapped,
      * other attributes control the size of characters in the line.
      */
     QVector<LineProperty> getLineProperties( int startLine , int endLine ) const;
-	
+    
 
     /** Return the number of lines. */
-    int  getLines()   { return lines; }
+    int getLines() const   
+    { return lines; }
     /** Return the number of columns. */
-    int  getColumns() { return columns; }
+    int getColumns() const 
+    { return columns; }
     /** Return the number of lines in the history buffer. */
-    int  getHistLines ();
+    int getHistLines() const;
     /** 
      * Sets the type of storage used to keep lines in the history. 
      * If @p copyPreviousScroll is true then the contents of the previous 
      * history buffer are copied into the new scroll.
      */
     void setScroll(const HistoryType& , bool copyPreviousScroll = true);
     /** Returns the type of storage used to keep lines in the history. */
-    const HistoryType& getScroll();
+    const HistoryType& getScroll() const;
     /** 
      * Returns true if this screen keeps lines that are scrolled off the screen
      * in a history buffer.
      */
-    bool hasScroll();
+    bool hasScroll() const;
 
     /** 
      * Sets the start of the selection.
      *
      * @param column The column index of the first character in the selection.
      * @param line The line index of the first character in the selection.
-     * @param columnmode True if the selection is in column mode.
+     * @param blockSelectionMode True if the selection is in column mode.
      */
-    void setSelectionStart(const int column, const int line, const bool columnmode);
+    void setSelectionStart(const int column, const int line, const bool blockSelectionMode);
     
     /**
      * Sets the end of the current selection.
      *
      * @param column The column index of the last character in the selection.
      * @param line The line index of the last character in the selection. 
      */ 
     void setSelectionEnd(const int column, const int line);
    
     /**
      * Retrieves the start of the selection or the cursor position if there
      * is no selection.
      */
-    void getSelectionStart(int& column , int& line);
+    void getSelectionStart(int& column , int& line) const;
     
     /**
      * Retrieves the end of the selection or the cursor position if there
      * is no selection.
      */
-    void getSelectionEnd(int& column , int& line);
+    void getSelectionEnd(int& column , int& line) const;
 
     /** Clears the current selection */
     void clearSelection();
 
-    void setBusySelecting(bool busy) { sel_busy = busy; }
-
     /** 
- 	 * 	Returns true if the character at (@p column, @p line) is part of the
- 	 *  current selection. 
- 	 */ 
+      *  Returns true if the character at (@p column, @p line) is part of the
+      *  current selection. 
+      */ 
     bool isSelected(const int column,const int line) const;
 
     /** 
      * Convenience method.  Returns the currently selected text. 
      * @param preserveLineBreaks Specifies whether new line characters should 
      * be inserted into the returned text at the end of each terminal line.
      */
-    QString selectedText(bool preserveLineBreaks);
-	    
-	/**
-	 * Copies part of the output to a stream.
-	 *
-	 * @param decoder A decoder which coverts terminal characters into text
-	 * @param from The first line in the history to retrieve
-	 * @param to The last line in the history to retrieve
-	 */
-	void writeToStream(TerminalCharacterDecoder* decoder, int from, int to);
+    QString selectedText(bool preserveLineBreaks) const;
+        
+    /**
+     * Copies part of the output to a stream.
+     *
+     * @param decoder A decoder which converts terminal characters into text
+     * @param fromLine The first line in the history to retrieve
+     * @param toLine The last line in the history to retrieve
+     */
+    void writeLinesToStream(TerminalCharacterDecoder* decoder, int fromLine, int toLine) const;
+
+    /**
+     * Copies the selected characters, set using @see setSelBeginXY and @see setSelExtentXY
+     * into a stream.
+     *
+     * @param decoder A decoder which converts terminal characters into text.  
+     * PlainTextDecoder is the most commonly used decoder which converts characters 
+     * into plain text with no formatting.
+     * @param preserveLineBreaks Specifies whether new line characters should 
+     * be inserted into the returned text at the end of each terminal line. 
+     */
+    void writeSelectionToStream(TerminalCharacterDecoder* decoder , bool
+                                preserveLineBreaks = true) const;
+
+    /**
+     * Checks if the text between from and to is inside the current
+     * selection. If this is the case, the selection is cleared. The
+     * from and to are coordinates in the current viewable window.
+     * The loc(x,y) macro can be used to generate these values from a
+     * column,line pair.
+     *
+     * @param from The start of the area to check.
+     * @param to The end of the area to check
+     */
+    void checkSelection(int from, int to);
 
     /** 
-     * Sets the selection to line @p no in the history and returns
-     * the text of that line from the history buffer.
+     * Sets or clears an attribute of the current line.
+     * 
+     * @param property The attribute to set or clear
+     * Possible properties are:
+     * LINE_WRAPPED:     Specifies that the line is wrapped.
+     * LINE_DOUBLEWIDTH: Specifies that the characters in the current line
+     *                   should be double the normal width.
+     * LINE_DOUBLEHEIGHT:Specifies that the characters in the current line 
+     *                   should be double the normal height.
+     *                   Double-height lines are formed of two lines containing the same characters,
+     *                   with both having the LINE_DOUBLEHEIGHT attribute.
+     *                   This allows other parts of the code to work on the
+     *                   assumption that all lines are the same height.
+     *
+     * @param enable true to apply the attribute to the current line or false to remove it
      */
-    QString getHistoryLine(int no);
-
-	/**
-	 * Copies the selected characters, set using @see setSelBeginXY and @see setSelExtentXY
-	 * into a stream.
-	 *
-	 * @param decoder A decoder which converts terminal characters into text.  
-	 * PlainTextDecoder is the most commonly used decoder which coverts characters 
-	 * into plain text with no formatting.
-     * @param preserveLineBreaks Specifies whether new line characters should 
-     * be inserted into the returned text at the end of each terminal line. 
-	 */
-	void writeSelectionToStream(TerminalCharacterDecoder* decoder , bool
-                                preserveLineBreaks = true);
-
-    /** TODO Document me */
-    void checkSelection(int from, int to);
-
-	/** 
-	 * Sets or clears an attribute of the current line.
-	 * 
-	 * @param property The attribute to set or clear
-	 * Possible properties are:
-	 * LINE_WRAPPED:	 Specifies that the line is wrapped.
-	 * LINE_DOUBLEWIDTH: Specifies that the characters in the current line should be double the normal width.
-	 * LINE_DOUBLEHEIGHT:Specifies that the characters in the current line should be double the normal height.
-     *                   Double-height lines are formed of two lines containing the same characters,
-     *                   with both having the LINE_DOUBLEHEIGHT attribute.  This allows other parts of the 
-     *                   code to work on the assumption that all lines are the same height.
-	 *
-	 * @param enable true to apply the attribute to the current line or false to remove it
-	 */
-	void setLineProperty(LineProperty property , bool enable);
-
+    void setLineProperty(LineProperty property , bool enable);
 
     /** 
      * Returns the number of lines that the image has been scrolled up or down by,
      * since the last call to resetScrolledLines().
      *
      * a positive return value indicates that the image has been scrolled up,
      * a negative return value indicates that the image has been scrolled down. 
      */
@@ -523,133 +531,140 @@ public:
     int droppedLines() const;
 
     /**
      * Resets the count of the number of lines dropped from
      * the history.
      */
     void resetDroppedLines();
 
-	/** 
- 	 * Fills the buffer @p dest with @p count instances of the default (ie. blank)
- 	 * Character style.
- 	 */
-	static void fillWithDefaultChar(Character* dest, int count);
+    /** 
+      * Fills the buffer @p dest with @p count instances of the default (ie. blank)
+      * Character style.
+      */
+    static void fillWithDefaultChar(Character* dest, int count);
 
 private: 
 
-	//copies a line of text from the screen or history into a stream using a 
-	//specified character decoder
-	//line - the line number to copy, from 0 (the earliest line in the history) up to 
-	//		 hist->getLines() + lines - 1
-	//start - the first column on the line to copy
-	//count - the number of characters on the line to copy
-	//decoder - a decoder which coverts terminal characters (an Character array) into text
+    //copies a line of text from the screen or history into a stream using a 
+    //specified character decoder.  Returns the number of lines actually copied,
+    //which may be less than 'count' if (start+count) is more than the number of characters on
+    //the line 
+    //
+    //line - the line number to copy, from 0 (the earliest line in the history) up to 
+    //         history->getLines() + lines - 1
+    //start - the first column on the line to copy
+    //count - the number of characters on the line to copy
+    //decoder - a decoder which converts terminal characters (an Character array) into text
     //appendNewLine - if true a new line character (\n) is appended to the end of the line
-	void copyLineToStream(int line, 
+    int  copyLineToStream(int line, 
                           int start, 
                           int count, 
                           TerminalCharacterDecoder* decoder,
                           bool appendNewLine,
-                          bool preserveLineBreaks);
-	
+                          bool preserveLineBreaks) const;
+    
     //fills a section of the screen image with the character 'c'
     //the parameters are specified as offsets from the start of the screen image.
     //the loc(x,y) macro can be used to generate these values from a column,line pair.
     void clearImage(int loca, int loce, char c);
 
     //move screen image between 'sourceBegin' and 'sourceEnd' to 'dest'.
     //the parameters are specified as offsets from the start of the screen image.
     //the loc(x,y) macro can be used to generate these values from a column,line pair.
+    //
+    //NOTE: moveImage() can only move whole lines
     void moveImage(int dest, int sourceBegin, int sourceEnd);
-    
+    // scroll up 'i' lines in current region, clearing the bottom 'i' lines 
     void scrollUp(int from, int i);
+    // scroll down 'i' lines in current region, clearing the top 'i' lines
     void scrollDown(int from, int i);
 
     void addHistLine();
 
     void initTabStops();
 
-    void effectiveRendition();
+    void updateEffectiveRendition();
     void reverseRendition(Character& p) const;
 
     bool isSelectionValid() const;
-
-	// copies 'count' lines from the screen buffer into 'dest',
-	// starting from 'startLine', where 0 is the first line in the screen buffer
-	void copyFromScreen(Character* dest, int startLine, int count) const;
-	// copies 'count' lines from the history buffer into 'dest',
-	// starting from 'startLine', where 0 is the first line in the history
-	void copyFromHistory(Character* dest, int startLine, int count) const;
+    // copies text from 'startIndex' to 'endIndex' to a stream
+    // startIndex and endIndex are positions generated using the loc(x,y) macro
+    void writeToStream(TerminalCharacterDecoder* decoder, int startIndex, 
+                       int endIndex, bool preserveLineBreaks = true) const;
+    // copies 'count' lines from the screen buffer into 'dest',
+    // starting from 'startLine', where 0 is the first line in the screen buffer
+    void copyFromScreen(Character* dest, int startLine, int count) const;
+    // copies 'count' lines from the history buffer into 'dest',
+    // starting from 'startLine', where 0 is the first line in the history
+    void copyFromHistory(Character* dest, int startLine, int count) const;
 
 
     // screen image ----------------
     int lines;
     int columns;
 
     typedef QVector<Character> ImageLine;      // [0..columns]
     ImageLine*          screenLines;    // [lines]
 
     int _scrolledLines;
     QRect _lastScrolledRegion;
 
     int _droppedLines;
 
     QVarLengthArray<LineProperty,64> lineProperties;    
-	
+    
     // history buffer ---------------
-    HistoryScroll *hist;
+    HistoryScroll* history;
     
     // cursor location
     int cuX;
     int cuY;
 
     // cursor color and rendition info
-    CharacterColor cu_fg;      // foreground
-    CharacterColor cu_bg;      // background
-    quint8 cu_re;      // rendition
+    CharacterColor currentForeground;
+    CharacterColor currentBackground;
+    quint8 currentRendition; 
 
     // margins ----------------
-    int tmargin;      // top margin
-    int bmargin;      // bottom margin
+    int _topMargin;
+    int _bottomMargin;
 
     // states ----------------
-    ScreenParm currParm;
+    int currentModes[MODES_SCREEN];
+    int savedModes[MODES_SCREEN];
 
     // ----------------------------
 
-    bool* tabstops;
+    QBitArray tabStops;
 
     // selection -------------------
-    int sel_begin; // The first location selected.
-    int sel_TL;    // TopLeft Location.
-    int sel_BR;    // Bottom Right Location.
-    bool sel_busy; // Busy making a selection.
-    bool columnmode;  // Column selection mode
+    int selBegin; // The first location selected.
+    int selTopLeft;    // TopLeft Location.
+    int selBottomRight;    // Bottom Right Location.
+    bool blockSelectionMode;  // Column selection mode
 
     // effective colors and rendition ------------
-    CharacterColor ef_fg;      // These are derived from
-    CharacterColor ef_bg;      // the cu_* variables above
-    quint8 ef_re;      // to speed up operation
-
-    //
-    // save cursor, rendition & states ------------
-    // 
+    CharacterColor effectiveForeground; // These are derived from
+    CharacterColor effectiveBackground; // the cu_* variables above
+    quint8 effectiveRendition;          // to speed up operation
 
-    // cursor location
-    int sa_cuX;
-    int sa_cuY;
+    class SavedState  
+    {
+    public:
+        SavedState()
+        : cursorColumn(0),cursorLine(0),rendition(0) {}
 
-    // rendition info
-    quint8 sa_cu_re;
-    CharacterColor sa_cu_fg;
-    CharacterColor sa_cu_bg;
-    
+        int cursorColumn;
+        int cursorLine;
+        quint8 rendition;
+        CharacterColor foreground;
+        CharacterColor background;
+    };
+    SavedState savedState;
+        
     // last position where we added a character
     int lastPos;
 
-    // modes
-    ScreenParm saveParm;
-
     static Character defaultChar;
 };
 
 #endif // SCREEN_H
diff --git a/gui//src/Session.cpp b/gui//src/Session.cpp
--- a/gui//src/Session.cpp
+++ b/gui//src/Session.cpp
@@ -1,15 +1,14 @@
 /*
     This file is part of Konsole
 
-    Copyright (C) 2006-2007 by Robert Knight <robertknight@gmail.com>
-    Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
-
-    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+    Copyright 2006-2008 by Robert Knight <robertknight@gmail.com>
+    Copyright 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
+    Copyright 2009 by Thomas Dreibholz <dreibh@iem.uni-due.de>
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
 
     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -17,87 +16,177 @@
     GNU General Public License for more details.
 
     You should have received a copy of the GNU General Public License
     along with this program; if not, write to the Free Software
     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
     02110-1301  USA.
 */
 
+// Own
+#include "Session.h"
+
 // Standard
 #include <assert.h>
 #include <stdlib.h>
+#include <signal.h>
 
 // Qt
 #include <QtGui/QApplication>
 #include <QtCore/QByteRef>
 #include <QtCore/QDir>
 #include <QtCore/QFile>
 #include <QtCore/QRegExp>
 #include <QtCore/QStringList>
-#include <QtCore>
+//#include <QtDBus/QtDBus>
+#include <QtCore/QDate>
+
 
-// Own
-#include "Session.h"
+// KDE
+//#include <KDebug>
+//#include <KLocale>
+//#include <KMessageBox>
+//#include <KNotification>
+//#include <KProcess>
+//#include <KRun>
+//#include <kshell.h>
+//#include <KStandardDirs>
+//#include <KPtyDevice>
+//#include <KUrl>
+#include "kprocess.h"
+#include "kptydevice.h"
+//#include "kdebug.h"
+
+// Konsole
+//#include <config-konsole.h>
+//#include <sessionadaptor.h>
+
+#include "ProcessInfo.h"
 #include "Pty.h"
 #include "TerminalDisplay.h"
 #include "ShellCommand.h"
 #include "Vt102Emulation.h"
+//#include "ZModemDialog.h"
 
 int Session::lastSessionId = 0;
 
-Session::Session() :
-    _shellProcess(0)
+// HACK This is copied out of QUuid::createUuid with reseeding forced.
+// Required because color schemes repeatedly seed the RNG...
+// ...with a constant.
+QUuid createUuid()
+{
+    static const int intbits = sizeof(int)*8;
+    static int randbits = 0;
+    if (!randbits)
+    {
+        int max = RAND_MAX;
+        do { ++randbits; } while ((max=max>>1));
+    }
+
+    qsrand(uint(QDateTime::currentDateTime().toTime_t()));
+    qrand(); // Skip first
+
+    QUuid result;
+    uint *data = &(result.data1);
+    int chunks = 16 / sizeof(uint);
+    while (chunks--) {
+        uint randNumber = 0;
+        for (int filled = 0; filled < intbits; filled += randbits)
+            randNumber |= qrand()<<filled;
+         *(data+chunks) = randNumber;
+    }
+
+    result.data4[0] = (result.data4[0] & 0x3F) | 0x80;        // UV_DCE
+    result.data3 = (result.data3 & 0x0FFF) | 0x4000;        // UV_Random
+
+    return result;
+}
+
+Session::Session(QObject* parent) :
+   QObject(parent)
+   , _shellProcess(0)
    , _emulation(0)
    , _monitorActivity(false)
    , _monitorSilence(false)
    , _notifiedActivity(false)
    , _autoClose(true)
    , _wantedClose(false)
    , _silenceSeconds(10)
-   , _addToUtmp(false)  // disabled by default because of a bug encountered on certain systems
-                        // which caused Konsole to hang when closing a tab and then opening a new
-                        // one.  A 'QProcess destroyed while still running' warning was being
-                        // printed to the terminal.  Likely a problem in KPty::logout() 
-                        // or KPty::login() which uses a QProcess to start /usr/bin/utempter 
+   , _addToUtmp(true)  
    , _flowControl(true)
    , _fullScripting(false)
    , _sessionId(0)
+   , _sessionProcessInfo(0)
+   , _foregroundProcessInfo(0)
+   , _foregroundPid(0)
+   //, _zmodemBusy(false)
+   //, _zmodemProc(0)
+   //, _zmodemProgress(0)
    , _hasDarkBackground(false)
 {
+    _uniqueIdentifier = createUuid();
+
+    //prepare DBus communication
+    //new SessionAdaptor(this);
     _sessionId = ++lastSessionId;
-    //create teletype for I/O with shell process
-    _shellProcess = new Pty();
+    
+    // JPS: commented out for lack of DBUS support by default on OSX
+    //QDBusConnection::sessionBus().registerObject(QLatin1String("/Sessions/")+QString::number(_sessionId), this);
 
     //create emulation backend
     _emulation = new Vt102Emulation();
 
     connect( _emulation, SIGNAL( titleChanged( int, const QString & ) ),
            this, SLOT( setUserTitle( int, const QString & ) ) );
     connect( _emulation, SIGNAL( stateSet(int) ),
            this, SLOT( activityStateSet(int) ) );
+    //connect( _emulation, SIGNAL( zmodemDetected() ), this ,
+    //        SLOT( fireZModemDetected() ) );
     connect( _emulation, SIGNAL( changeTabTextColorRequest( int ) ),
            this, SIGNAL( changeTabTextColorRequest( int ) ) );
     connect( _emulation, SIGNAL(profileChangeCommandReceived(const QString&)),
            this, SIGNAL( profileChangeCommandReceived(const QString&)) );
-    //connect teletype to emulation backend
+    connect( _emulation, SIGNAL(flowControlKeyPressed(bool)) , this, 
+             SLOT(updateFlowControlState(bool)) );
+
+    //create new teletype for I/O with shell process
+    openTeletype(-1);
+
+    //setup timer for monitoring session activity
+    _monitorTimer = new QTimer(this);
+    _monitorTimer->setSingleShot(true);
+    connect(_monitorTimer, SIGNAL(timeout()), this, SLOT(monitorTimerDone()));
+}
+
+void Session::openTeletype(int fd)
+{
+    if (_shellProcess && isRunning())
+    {
+        //kWarning() << "Attempted to open teletype in a running session.";
+        return;
+    }
+
+    delete _shellProcess;
+
+    if (fd < 0)
+        _shellProcess = new Pty();
+    else
+        _shellProcess = new Pty(fd);
+
     _shellProcess->setUtf8Mode(_emulation->utf8());
 
+    //connect teletype to emulation backend
     connect( _shellProcess,SIGNAL(receivedData(const char*,int)),this,
             SLOT(onReceiveBlock(const char*,int)) );
     connect( _emulation,SIGNAL(sendData(const char*,int)),_shellProcess,
             SLOT(sendData(const char*,int)) );
     connect( _emulation,SIGNAL(lockPtyRequest(bool)),_shellProcess,SLOT(lockPty(bool)) );
     connect( _emulation,SIGNAL(useUtf8Request(bool)),_shellProcess,SLOT(setUtf8Mode(bool)) );
-    connect( _shellProcess,SIGNAL(done(int)), this, SLOT(done(int)) );
-
-    //setup timer for monitoring session activity
-    _monitorTimer = new QTimer(this);
-    _monitorTimer->setSingleShot(true);
-    connect(_monitorTimer, SIGNAL(timeout()), this, SLOT(monitorTimerDone()));
+    connect( _shellProcess,SIGNAL(finished(int,QProcess::ExitStatus)), this, SLOT(done(int)) );
+    connect( _emulation,SIGNAL(imageSizeChanged(int,int)),this,SLOT(updateWindowSize(int,int)) );
 }
 
 WId Session::windowId() const
 {
     // Returns a window ID for this session which is used
     // to set the WINDOWID environment variable in the shell
     // process.
     //
@@ -129,37 +218,66 @@ void Session::setDarkBackground(bool dar
     _hasDarkBackground = darkBackground;
 }
 bool Session::hasDarkBackground() const
 {
     return _hasDarkBackground;
 }
 bool Session::isRunning() const
 {
-    return _shellProcess->isRunning();
+    return _shellProcess->state() == QProcess::Running;
 }
 
 void Session::setCodec(QTextCodec* codec)
 {
     emulation()->setCodec(codec);
 }
 
+bool Session::setCodec(QByteArray name)
+{
+    QTextCodec *codec = QTextCodec::codecForName(name);
+    if (codec) {
+        setCodec(codec);
+        return true;
+    }
+    return false;
+}
+
+QByteArray Session::codec()
+{
+    return _emulation->codec()->name();
+}
+
 void Session::setProgram(const QString& program)
 {
     _program = ShellCommand::expand(program);
 }
 void Session::setInitialWorkingDirectory(const QString& dir)
 {
-    _initialWorkingDir = ShellCommand::expand(dir);
+  //_initialWorkingDir = KShell::tildeExpand(ShellCommand::expand(dir));
+  _initialWorkingDir = ShellCommand::expand(dir);
 }
 void Session::setArguments(const QStringList& arguments)
 {
     _arguments = ShellCommand::expand(arguments);
 }
 
+QString Session::currentWorkingDirectory()
+{
+    // only returned cached value
+    if (_currentWorkingDir.isEmpty()) updateWorkingDirectory();
+    return _currentWorkingDir;
+}
+ProcessInfo* Session::updateWorkingDirectory()
+{
+    ProcessInfo *process = getProcessInfo();
+    _currentWorkingDir = process->validCurrentDir();
+    return process;
+}
+
 QList<TerminalDisplay*> Session::views() const
 {
     return _views;
 }
 
 void Session::addView(TerminalDisplay* widget)
 {
      Q_ASSERT( !_views.contains(widget) );
@@ -187,193 +305,269 @@ void Session::addView(TerminalDisplay* w
     }
 
     //connect view signals and slots
     QObject::connect( widget ,SIGNAL(changedContentSizeSignal(int,int)),this,
                     SLOT(onViewSizeChange(int,int)));
 
     QObject::connect( widget ,SIGNAL(destroyed(QObject*)) , this ,
                     SLOT(viewDestroyed(QObject*)) );
-
-    QObject::connect(this, SIGNAL(finished()), widget, SLOT(close()));		    
-    
 }
 
 void Session::viewDestroyed(QObject* view)
 {
     TerminalDisplay* display = (TerminalDisplay*)view;
 
     Q_ASSERT( _views.contains(display) );
 
     removeView(display);
 }
 
 void Session::removeView(TerminalDisplay* widget)
 {
     _views.removeAll(widget);
 
-	disconnect(widget,0,this,0);
+    disconnect(widget,0,this,0);
 
     if ( _emulation != 0 )
     {
         // disconnect
         //  - key presses signals from widget
         //  - mouse activity signals from widget
         //  - string sending signals from widget
         //
         //  ... and any other signals connected in addView()
         disconnect( widget, 0, _emulation, 0);
 
         // disconnect state change signals emitted by emulation
         disconnect( _emulation , 0 , widget , 0);
     }
 
-	// close the session automatically when the last view is removed
-	if ( _views.count() == 0 )
-	{
-		close();
-	}
+    // close the session automatically when the last view is removed
+    if ( _views.count() == 0 )
+    {
+        close();
+    }
+}
+
+QString Session::checkProgram(const QString& program) const
+{
+  // Upon a KPty error, there is no description on what that error was...
+  // Check to see if the given program is executable.
+  QString exec = QFile::encodeName(program);
+
+  if (exec.isEmpty())
+      return QString();
+
+  // if 'exec' is not specified, fall back to default shell.  if that 
+  // is not set then fall back to /bin/sh
+  if ( exec.isEmpty() )
+      exec = qgetenv("SHELL");
+  if ( exec.isEmpty() )
+        exec = "/bin/sh";
+
+  // JPS: commented out to get rid of KShell and KRun
+  /*
+  exec = KRun::binaryName(exec, false);
+  exec = KShell::tildeExpand(exec);
+  QString pexec = KGlobal::dirs()->findExe(exec);
+  if ( pexec.isEmpty() ) 
+  {
+      kError() << i18n("Could not find binary: ") << exec;
+    return QString();
+  }
+
+  return exec;
+  */
+  return program;
+}
+
+void Session::terminalWarning(const QString& message)
+{
+  //static const QByteArray warningText = i18nc("@info:shell Alert the user with red color text", "Warning: ").toLocal8Bit(); 
+  static const QByteArray warningText = i18nc("@info:shell Alert the user with red color text", "Warning: "); 
+    QByteArray messageText = message.toLocal8Bit();
+
+    static const char redPenOn[] = "\033[1m\033[31m";
+    static const char redPenOff[] = "\033[0m";
+
+    _emulation->receiveData(redPenOn,strlen(redPenOn));
+    _emulation->receiveData("\n\r\n\r",4);
+    _emulation->receiveData(warningText.constData(),strlen(warningText.constData()));
+    _emulation->receiveData(messageText.constData(),strlen(messageText.constData()));
+    _emulation->receiveData("\n\r\n\r",4);
+    _emulation->receiveData(redPenOff,strlen(redPenOff));
+}
+
+QString Session::shellSessionId() const
+{
+    QString friendlyUuid(_uniqueIdentifier.toString());
+    friendlyUuid.remove('-').remove('{').remove('}');
+
+    return friendlyUuid;
 }
 
 void Session::run()
 {
   //check that everything is in place to run the session
   if (_program.isEmpty())
-      qDebug() << "Session::run() - program to run not set.";
+  {
+      //kWarning() << "Session::run() - program to run not set.";
+  }
   if (_arguments.isEmpty())
-      qDebug() << "Session::run() - no command line arguments specified.";
-
-  // Upon a KPty error, there is no description on what that error was...
-  // Check to see if the given program is executable.
-  QString exec = QFile::encodeName(_program);
-
-  // if 'exec' is not specified, fall back to default shell.  if that 
-  // is not set then fall back to /bin/sh
-  if ( exec.isEmpty() )
-      exec = getenv("SHELL");
-  if ( exec.isEmpty() )
-  	  exec = "/bin/sh";
-
-  // if no arguments are specified, fall back to shell
-  QStringList arguments =  _arguments.join(QChar(' ')).isEmpty() ?
-                                    QStringList() << exec : _arguments;
-  QString pexec = exec;
-
-  if ( pexec.isEmpty() ) {
-    qDebug()<<"can not execute "<<exec<<endl;
-    QTimer::singleShot(1, this, SIGNAL(finished()));
-    return;
+  {
+      //kWarning() << "Session::run() - no command line arguments specified.";
+  }
+  if (_uniqueIdentifier.isNull())
+  {
+      _uniqueIdentifier = createUuid();
   }
 
-  QString cwd_save = QDir::currentPath();
+  const int CHOICE_COUNT = 3;
+  QString programs[CHOICE_COUNT] = {_program,qgetenv("SHELL"),"/bin/sh"};
+  QString exec;
+  int choice = 0;
+  while (choice < CHOICE_COUNT)
+  {
+    exec = checkProgram(programs[choice]);
+    if (exec.isEmpty())
+        choice++;
+    else
+        break;
+  }
+
+  // if a program was specified via setProgram(), but it couldn't be found, print a warning
+  if (choice != 0 && choice < CHOICE_COUNT && !_program.isEmpty())
+  {
+    QString msg;
+    QTextStream msgStream(&msg);
+    msgStream << "Could not find '" << _program << "', starting '" << exec << "' instead. Please check your profile settings.";
+    terminalWarning(msg);
+    //terminalWarning(i18n("Could not find '%1', starting '%2' instead.  Please check your profile settings.",_program.toLatin1().data(),exec.toLatin1().data())); 
+  }
+  // if none of the choices are available, print a warning
+  else if (choice == CHOICE_COUNT)
+  {
+      terminalWarning(i18n("Could not find an interactive shell to start."));
+      return;
+  }
+  
+  // if no arguments are specified, fall back to program name
+  QStringList arguments = _arguments.join(QChar(' ')).isEmpty() ?
+                                                   QStringList() << exec : _arguments;
+
+  // JPS: commented out for lack of DBUS support by default on OSX
+  QString dbusService = ""; //QDBusConnection::sessionBus().baseService();
   if (!_initialWorkingDir.isEmpty())
     _shellProcess->setWorkingDirectory(_initialWorkingDir);
   else
     _shellProcess->setWorkingDirectory(QDir::homePath());
 
-  _shellProcess->setXonXoff(_flowControl);
-  _shellProcess->setErase(_emulation->getErase());
+  _shellProcess->setFlowControlEnabled(_flowControl);
+  _shellProcess->setErase(_emulation->eraseChar());
 
   // this is not strictly accurate use of the COLORFGBG variable.  This does not
   // tell the terminal exactly which colors are being used, but instead approximates
   // the color scheme as "black on white" or "white on black" depending on whether
   // the background color is deemed dark or not
   QString backgroundColorHint = _hasDarkBackground ? "COLORFGBG=15;0" : "COLORFGBG=0;15";
+  _environment << backgroundColorHint;
+  _environment << QString("SHELL_SESSION_ID=%1").arg(shellSessionId());
 
-  int result = _shellProcess->start(QFile::encodeName(_program),
+  int result = _shellProcess->start(exec,
                                   arguments,
-                                  _environment << backgroundColorHint,
+                                  _environment,
                                   windowId(),
-                                  _addToUtmp);
+                                  _addToUtmp,
+                                  dbusService,
+                                  (QLatin1String("/Sessions/") +
+                                   QString::number(_sessionId)));
 
   if (result < 0)
   {
+    QString msg;
+    QTextStream msgStream(&msg);
+    msgStream << QString("Could not start program '") << exec << QString("' with arguments '") << arguments.join(" ") << QString("'.");
+    terminalWarning (msg);
+    //      terminalWarning(i18n("Could not start program '%1' with arguments '%2'.", exec.toLatin1().data(), arguments.join(" ").toLatin1().data()));
     return;
   }
 
   _shellProcess->setWriteable(false);  // We are reachable via kwrited.
 
   emit started();
 }
 
 void Session::setUserTitle( int what, const QString &caption )
 {
     //set to true if anything is actually changed (eg. old _nameTitle != new _nameTitle )
-	bool modified = false;
+    bool modified = false;
 
-    // (btw: what=0 changes _userTitle and icon, what=1 only icon, what=2 only _nameTitle
-    if ((what == 0) || (what == 2)) 
+    if ((what == IconNameAndWindowTitle) || (what == WindowTitle)) 
     {
-       	if ( _userTitle != caption ) {
-			_userTitle = caption;
-			modified = true;
-		}
+           if ( _userTitle != caption ) {
+            _userTitle = caption;
+            modified = true;
+        }
     }
 
-    if ((what == 0) || (what == 1))
-	{
-		if ( _iconText != caption ) {
-       		_iconText = caption;
-			modified = true;
-		}
-	}
+    if ((what == IconNameAndWindowTitle) || (what == IconName))
+    {
+        if ( _iconText != caption ) {
+               _iconText = caption;
+            modified = true;
+        }
+    }
 
-    if (what == 11) 
+    if (what == TextColor || what == BackgroundColor) 
     {
       QString colorString = caption.section(';',0,0);
-      qDebug() << __FILE__ << __LINE__ << ": setting background colour to " << colorString;
-      QColor backColor = QColor(colorString);
-      if (backColor.isValid()){// change color via \033]11;Color\007
-          if (backColor != _modifiedBackground)
-          {
-              _modifiedBackground = backColor;
-
-              // bail out here until the code to connect the terminal display
-              // to the changeBackgroundColor() signal has been written
-              // and tested - just so we don't forget to do this.
-              Q_ASSERT( 0 );
-
-              emit changeBackgroundColorRequest(backColor);
-          }
+      QColor color = QColor(colorString);
+      if (color.isValid())
+      {
+          if (what == TextColor)
+                  emit changeForegroundColorRequest(color);
+          else
+                  emit changeBackgroundColorRequest(color);
       }
     }
 
-	if (what == 30) 
+    if (what == SessionName) 
     {
-		if ( _nameTitle != caption ) {
-       		setTitle(Session::NameRole,caption);
-			return;
-		}
-	}
+        if ( _nameTitle != caption ) {
+               setTitle(Session::NameRole,caption);
+            return;
+        }
+    }
 
     if (what == 31) 
     {
        QString cwd=caption;
        cwd=cwd.replace( QRegExp("^~"), QDir::homePath() );
        emit openUrlRequest(cwd);
-	}
+    }
 
     // change icon via \033]32;Icon\007
     if (what == 32) 
     { 
-    	if ( _iconName != caption ) {
-	   		_iconName = caption;
+        if ( _iconName != caption ) {
+               _iconName = caption;
 
-			modified = true;
-		}
+            modified = true;
+        }
     }
 
-    if (what == 50) 
+    if (what == ProfileChange) 
     {
         emit profileChangeCommandReceived(caption);
         return;
     }
 
-	if ( modified )
-    	emit titleChanged();
+    if ( modified )
+        emit titleChanged();
 }
 
 QString Session::userTitle() const
 {
     return _userTitle;
 }
 void Session::setTabTitleFormat(TabTitleContext context , const QString& format)
 {
@@ -389,47 +583,74 @@ QString Session::tabTitleFormat(TabTitle
     else if ( context == RemoteTabTitle )
         return _remoteTabTitleFormat;
 
     return QString();
 }
 
 void Session::monitorTimerDone()
 {
+  //FIXME: The idea here is that the notification popup will appear to tell the user than output from
+  //the terminal has stopped and the popup will disappear when the user activates the session.
+  //
+  //This breaks with the addition of multiple views of a session.  The popup should disappear
+  //when any of the views of the session becomes active
+  
+
+  //FIXME: Make message text for this notification and the activity notification more descriptive.    
   if (_monitorSilence) {
-  emit stateChanged(NOTIFYSILENCE);
+    //KNotification::event("Silence", i18n("Silence in session '%1'", _nameTitle), QPixmap(),
+    //                QApplication::activeWindow(),
+    //                KNotification::CloseWhenWidgetActivated);
+    emit stateChanged(NOTIFYSILENCE);
   }
   else
   {
     emit stateChanged(NOTIFYNORMAL);
   }
 
   _notifiedActivity=false;
 }
-
+void Session::updateFlowControlState(bool suspended)
+{
+    if (suspended)
+    {
+        if (flowControlEnabled())
+        {
+            foreach(TerminalDisplay* display,_views)
+            {
+                if (display->flowControlWarningEnabled())
+                    display->outputSuspended(true);
+            }
+        }
+    } 
+    else
+    {
+        foreach(TerminalDisplay* display,_views)
+            display->outputSuspended(false);
+    }   
+}
 void Session::activityStateSet(int state)
 {
   if (state==NOTIFYBELL)
   {
-      QString s; s.sprintf("Bell in session '%s'",_nameTitle.toAscii().data());
-      
-      emit bellRequest( s );
+      emit bellRequest( i18n("Bell in session '%1'",_nameTitle.toLatin1().data()) );
   }
   else if (state==NOTIFYACTIVITY)
   {
     if (_monitorSilence) {
       _monitorTimer->start(_silenceSeconds*1000);
     }
 
     if ( _monitorActivity ) {
       //FIXME:  See comments in Session::monitorTimerDone()
       if (!_notifiedActivity) {
-//        KNotification::event("Activity", ("Activity in session '%1'", _nameTitle), QPixmap(),
-//                        QApplication::activeWindow(),
-//        KNotification::CloseWhenWidgetActivated);
+        //KNotification::event("Activity", i18n("Activity in session '%1'", _nameTitle), QPixmap(),
+        //                QApplication::activeWindow(),
+        //KNotification::CloseWhenWidgetActivated);
         _notifiedActivity=true;
       }
     }
   }
 
   if ( state==NOTIFYACTIVITY && !_monitorActivity )
           state = NOTIFYNORMAL;
   if ( state==NOTIFYSILENCE && !_monitorSilence )
@@ -437,20 +658,16 @@ void Session::activityStateSet(int state
 
   emit stateChanged(state);
 }
 
 void Session::onViewSizeChange(int /*height*/, int /*width*/)
 {
   updateTerminalSize();
 }
-void Session::onEmulationSizeChange(int lines , int columns)
-{
-  setSize( QSize(lines,columns) );
-}
 
 void Session::updateTerminalSize()
 {
     QListIterator<TerminalDisplay*> viewIter(_views);
 
     int minLines = -1;
     int minColumns = -1;
 
@@ -465,27 +682,31 @@ void Session::updateTerminalSize()
     {
         TerminalDisplay* view = viewIter.next();
         if ( view->isHidden() == false &&
              view->lines() >= VIEW_LINES_THRESHOLD &&
              view->columns() >= VIEW_COLUMNS_THRESHOLD )
         {
             minLines = (minLines == -1) ? view->lines() : qMin( minLines , view->lines() );
             minColumns = (minColumns == -1) ? view->columns() : qMin( minColumns , view->columns() );
+            view->processFilters();
         }
     }
 
     // backend emulation must have a _terminal of at least 1 column x 1 line in size
     if ( minLines > 0 && minColumns > 0 )
     {
         _emulation->setImageSize( minLines , minColumns );
-        _shellProcess->setWindowSize( minLines , minColumns );
     }
 }
-
+void Session::updateWindowSize(int lines, int columns)
+{
+    Q_ASSERT(lines > 0 && columns > 0);
+    _shellProcess->setWindowSize(lines,columns);
+}
 void Session::refresh()
 {
     // attempt to get the shell process to redraw the display
     //
     // this requires the program running in the shell
     // to cooperate by sending an update in response to
     // a window size change
     //
@@ -497,80 +718,112 @@ void Session::refresh()
     // if there is a more 'correct' way to do this, please
     // send an email with method or patches to konsole-devel@kde.org
 
     const QSize existingSize = _shellProcess->windowSize();
     _shellProcess->setWindowSize(existingSize.height(),existingSize.width()+1);
     _shellProcess->setWindowSize(existingSize.height(),existingSize.width());
 }
 
-bool Session::sendSignal(int signal)
+bool Session::kill(int signal)
 {
-  return _shellProcess->kill(signal);
+    int result = ::kill(_shellProcess->pid(),signal);    
+    
+    if ( result == 0 )
+    {
+        _shellProcess->waitForFinished();
+        return true;
+    }
+    else
+        return false;
 }
 
 void Session::close()
 {
   _autoClose = true;
   _wantedClose = true;
-  if (!_shellProcess->isRunning() || !sendSignal(SIGHUP))
+
+  if (!isRunning() || !kill(SIGHUP))
   {
+     if (isRunning())
+     {
+        //kWarning() << "Process" << _shellProcess->pid() << "did not respond to SIGHUP";
+
+        // close the pty and wait to see if the process finishes.  If it does,
+        // the done() slot will have been called so we can return.  Otherwise,
+        // emit the finished() signal regardless
+        _shellProcess->pty()->close();
+        if (_shellProcess->waitForFinished(3000))
+            return;
+
+        //kWarning() << "Unable to kill process" << _shellProcess->pid();
+     }
+
      // Forced close.
      QTimer::singleShot(1, this, SIGNAL(finished()));
   }
 }
 
 void Session::sendText(const QString &text) const
 {
   _emulation->sendText(text);
 }
 
-Session::~Session()
+void Session::sendMouseEvent(int buttons, int column, int line, int eventType)
 {
-  delete _emulation;
-  delete _shellProcess;
+    _emulation->sendMouseEvent(buttons, column, line, eventType);
 }
 
-void Session::setProfileKey(const QString& key)
+Session::~Session()
 {
-    _profileKey = key;
-    emit profileChanged(key);
+  if (_foregroundProcessInfo)
+      delete _foregroundProcessInfo;
+  if (_sessionProcessInfo)
+      delete _sessionProcessInfo;
+  delete _emulation;
+  delete _shellProcess;
+  //delete _zmodemProc;
 }
-QString Session::profileKey() const { return _profileKey; }
 
 void Session::done(int exitStatus)
 {
   if (!_autoClose)
   {
-    _userTitle = ("<Finished>");
+    _userTitle = i18n("@info:shell This session is done", "Finished");
     emit titleChanged();
     return;
   }
-  if (!_wantedClose && (exitStatus || _shellProcess->signalled()))
+
+  QString message;
+  QTextStream msgStream(&message);
+  if (!_wantedClose || exitStatus != 0)
   {
-    QString message;
-
-    if (_shellProcess->normalExit())
-      message.sprintf ("Session '%s' exited with status %d.", _nameTitle.toAscii().data(), exitStatus);
-    else if (_shellProcess->signalled())
+    if (_shellProcess->exitStatus() == QProcess::NormalExit)
     {
-      if (_shellProcess->coreDumped())
-      {    
+      msgStream << "Program '" << _program << "' exited with statis " << exitStatus << ".";
+      //message = i18n("Program '%1' exited with status %2.", _program.toLatin1().data(), exitStatus);
 
-        message.sprintf("Session '%s' exited with signal %d and dumped core.", _nameTitle.toAscii().data(), _shellProcess->exitSignal());
-      }
-      else { 
-        message.sprintf("Session '%s' exited with signal %d.", _nameTitle.toAscii().data(), _shellProcess->exitSignal());
-      }
     }
     else
-        message.sprintf ("Session '%s' exited unexpectedly.", _nameTitle.toAscii().data());
+    {
+      msgStream << "Program '" << _program << "' crashed.";
+      //message = i18n("Program '%1' crashed.", _program.toLatin1().data());
+	
+    }
 
+    //FIXME: See comments in Session::monitorTimerDone()
+    //KNotification::event("Finished", message , QPixmap(),
+    //                     QApplication::activeWindow(),
+    //                     KNotification::CloseWhenWidgetActivated);
   }
-  emit finished();
+
+  if ( !_wantedClose && _shellProcess->exitStatus() != QProcess::NormalExit )
+      terminalWarning(message);
+  else
+        emit finished();
 }
 
 Emulation* Session::emulation() const
 {
   return _emulation;
 }
 
 QString Session::keyBindings() const
@@ -616,16 +869,133 @@ QString Session::title(TitleRole role) c
     if ( role == NameRole )
         return _nameTitle;
     else if ( role == DisplayedTitleRole )
         return _displayTitle;
     else
         return QString();
 }
 
+ProcessInfo* Session::getProcessInfo()
+{
+    ProcessInfo* process;
+
+    if (isForegroundProcessActive())
+        process = _foregroundProcessInfo;
+    else
+    {
+        updateSessionProcessInfo();
+        process = _sessionProcessInfo;
+    }
+
+    return process;
+}
+
+void Session::updateSessionProcessInfo()
+{
+    Q_ASSERT(_shellProcess);
+    if (!_sessionProcessInfo)
+    {
+        _sessionProcessInfo = ProcessInfo::newInstance(processId());
+        _sessionProcessInfo->setUserHomeDir();
+    }
+    _sessionProcessInfo->update();
+}
+
+bool Session::updateForegroundProcessInfo()
+{
+    bool valid = (_foregroundProcessInfo != 0);
+
+    // has foreground process changed?
+    Q_ASSERT(_shellProcess);
+    int pid = _shellProcess->foregroundProcessGroup();
+    if (pid != _foregroundPid)
+    {
+        if (valid)
+            delete _foregroundProcessInfo;
+        _foregroundProcessInfo = ProcessInfo::newInstance(pid);
+        _foregroundPid = pid;
+        valid = true;
+    }
+
+    if (valid)
+    {
+        _foregroundProcessInfo->update();
+        valid = _foregroundProcessInfo->isValid();
+    }
+
+    return valid;
+}
+
+bool Session::isRemote()
+{
+    ProcessInfo* process = getProcessInfo();
+
+    bool ok = false;
+    return ( process->name(&ok) == "ssh" && ok );
+}
+
+QString Session::getDynamicTitle()
+{
+    // update current directory from process
+    ProcessInfo* process = updateWorkingDirectory();
+
+    // format tab titles using process info
+    bool ok = false;
+    QString title;
+    if ( process->name(&ok) == "ssh" && ok )
+    {
+        SSHProcessInfo sshInfo(*process);
+        title = sshInfo.format(tabTitleFormat(Session::RemoteTabTitle));
+    }
+    else
+        title = process->format(tabTitleFormat(Session::LocalTabTitle));
+
+    return title;
+}
+
+/*
+KUrl Session::getUrl()
+{
+    QString path;
+    
+    updateSessionProcessInfo();
+    if (_sessionProcessInfo->isValid())
+    {
+        bool ok = false;
+
+        // check if foreground process is bookmark-able
+        if (isForegroundProcessActive())
+        {
+            // for remote connections, save the user and host
+            // bright ideas to get the directory at the other end are welcome :)
+            if (_foregroundProcessInfo->name(&ok) == "ssh" && ok)
+            {
+                SSHProcessInfo sshInfo(*_foregroundProcessInfo);
+                path = "ssh://" + sshInfo.userName() + '@' + sshInfo.host();
+            }
+            else
+            {
+                path = _foregroundProcessInfo->currentDir(&ok);
+                if (!ok)
+                    path.clear();
+            }
+        }
+        else // otherwise use the current working directory of the shell process
+        {
+            path = _sessionProcessInfo->currentDir(&ok);
+            if (!ok)
+                path.clear();
+        }
+    }
+
+    return KUrl(path);
+}
+*/
+
 void Session::setIconName(const QString& iconName)
 {
     if ( iconName != _iconName )
     {
         _iconName = iconName;
         emit titleChanged();
     }
 }
@@ -709,31 +1079,146 @@ void Session::setMonitorSilenceSeconds(i
 
 void Session::setAddToUtmp(bool set)
 {
   _addToUtmp = set;
 }
 
 void Session::setFlowControlEnabled(bool enabled)
 {
-  if (_flowControl == enabled)
-  	return;
-
   _flowControl = enabled;
 
   if (_shellProcess)  
-	_shellProcess->setXonXoff(_flowControl);
-  
+    _shellProcess->setFlowControlEnabled(_flowControl);
   emit flowControlEnabledChanged(enabled);
 }
 bool Session::flowControlEnabled() const
 {
-	return _flowControl;
+    if (_shellProcess)
+            return _shellProcess->flowControlEnabled();
+    else
+            return _flowControl;
+}
+
+/*
+void Session::fireZModemDetected()
+{
+  if (!_zmodemBusy)
+  {
+    QTimer::singleShot(10, this, SIGNAL(zmodemDetected()));
+    _zmodemBusy = true;
+  }
+}
+
+void Session::cancelZModem()
+{
+  _shellProcess->sendData("\030\030\030\030", 4); // Abort
+  _zmodemBusy = false;
+}
+
+void Session::startZModem(const QString &zmodem, const QString &dir, const QStringList &list)
+{
+  _zmodemBusy = true;
+  _zmodemProc = new KProcess();
+  _zmodemProc->setOutputChannelMode( KProcess::SeparateChannels );
+
+  *_zmodemProc << zmodem << "-v" << list;
+
+  if (!dir.isEmpty())
+     _zmodemProc->setWorkingDirectory(dir);
+
+  connect(_zmodemProc,SIGNAL (readyReadStandardOutput()),
+          this, SLOT(zmodemReadAndSendBlock()));
+  connect(_zmodemProc,SIGNAL (readyReadStandardError()),
+          this, SLOT(zmodemReadStatus()));
+  connect(_zmodemProc,SIGNAL (finished(int,QProcess::ExitStatus)),
+          this, SLOT(zmodemFinished()));
+
+  _zmodemProc->start();
+  
+  disconnect( _shellProcess,SIGNAL(receivedData(const char*,int)), this, SLOT(onReceiveBlock(const char*,int)) );
+  connect( _shellProcess,SIGNAL(receivedData(const char*,int)), this, SLOT(zmodemRcvBlock(const char*,int)) );
+
+  _zmodemProgress = new ZModemDialog(QApplication::activeWindow(), false,
+                                    i18n("ZModem Progress"));
+
+  connect(_zmodemProgress, SIGNAL(user1Clicked()),
+          this, SLOT(zmodemFinished()));
+
+  _zmodemProgress->show();
 }
 
+void Session::zmodemReadAndSendBlock()
+{
+  _zmodemProc->setReadChannel( QProcess::StandardOutput );
+  QByteArray data = _zmodemProc->readAll();
+
+  if ( data.count() == 0 )
+      return;
+
+  _shellProcess->sendData(data.constData(),data.count());
+}
+
+void Session::zmodemReadStatus()
+{
+  _zmodemProc->setReadChannel( QProcess::StandardError );
+  QByteArray msg = _zmodemProc->readAll();
+  while(!msg.isEmpty())
+  {
+     int i = msg.indexOf('\015');
+     int j = msg.indexOf('\012');
+     QByteArray txt;
+     if ((i != -1) && ((j == -1) || (i < j)))
+     {
+       msg = msg.mid(i+1);
+     }
+     else if (j != -1)
+     {
+       txt = msg.left(j);
+       msg = msg.mid(j+1);
+     }
+     else
+     {
+       txt = msg;
+       msg.truncate(0);
+     }
+     if (!txt.isEmpty())
+       _zmodemProgress->addProgressText(QString::fromLocal8Bit(txt));
+  }
+}
+
+void Session::zmodemRcvBlock(const char *data, int len)
+{
+  QByteArray ba( data, len );
+
+  _zmodemProc->write( ba );
+}
+
+void Session::zmodemFinished()
+{
+  // zmodemFinished() is called by QProcess's finished() and
+  //    ZModemDialog's user1Clicked(). Therefore, an invocation by
+  //    user1Clicked() will recursively invoke this function again
+  //    when the KProcess is deleted!
+  if (_zmodemProc) {
+    KProcess* process = _zmodemProc;
+    _zmodemProc = 0;   // Set _zmodemProc to 0 avoid recursive invocations!
+    _zmodemBusy = false;
+    delete process;    // Now, the KProcess may be disposed safely.
+
+    disconnect( _shellProcess,SIGNAL(receivedData(const char*,int)), this ,SLOT(zmodemRcvBlock(const char*,int)) );
+    connect( _shellProcess,SIGNAL(receivedData(const char*,int)), this, SLOT(onReceiveBlock(const char*,int)) );
+
+    _shellProcess->sendData("\030\030\030\030", 4); // Abort
+    _shellProcess->sendData("\001\013\n", 3); // Try to get prompt back
+    _zmodemProgress->transferDone();
+  }
+}
+*/
+
 void Session::onReceiveBlock( const char* buf, int len )
 {
     _emulation->receiveData( buf, len );
     emit receivedData( QString::fromLatin1( buf, len ) );
 }
 
 QSize Session::size()
 {
@@ -742,129 +1227,199 @@ QSize Session::size()
 
 void Session::setSize(const QSize& size)
 {
   if ((size.width() <= 1) || (size.height() <= 1))
      return;
 
   emit resizeRequest(size);
 }
-int Session::foregroundProcessId() const
-{
-    return _shellProcess->foregroundProcessGroup();
-}
 int Session::processId() const
 {
     return _shellProcess->pid();
 }
 
-SessionGroup::SessionGroup()
-    : _masterMode(0)
+void Session::setTitle(int role , const QString& title)
+{
+    switch (role) {
+    case (0):
+        this->setTitle(Session::NameRole, title);
+        break;
+    case (1):
+        this->setTitle(Session::DisplayedTitleRole, title);
+        break;
+    }
+}
+
+QString Session::title(int role) const
+{
+    switch (role) {
+    case (0):
+        return this->title(Session::NameRole);
+    case (1):
+        return this->title(Session::DisplayedTitleRole);
+    default:
+        return QString();
+    }
+}
+
+void Session::setTabTitleFormat(int context , const QString& format)
+{
+    switch (context) {
+    case (0):
+        this->setTabTitleFormat(Session::LocalTabTitle, format);
+        break;
+    case (1):
+        this->setTabTitleFormat(Session::RemoteTabTitle, format);
+        break;
+    }
+}
+
+QString Session::tabTitleFormat(int context) const
+{
+    switch (context) {
+    case (0):
+        return this->tabTitleFormat(Session::LocalTabTitle);
+    case (1):
+        return this->tabTitleFormat(Session::RemoteTabTitle);
+    default:
+        return QString();
+    }
+}
+
+int Session::foregroundProcessId()
+{
+    int pid;
+
+    bool ok = false;
+    pid = getProcessInfo()->pid(&ok);
+    if (!ok)
+        pid = -1;
+
+    return pid;
+}
+
+bool Session::isForegroundProcessActive()
+{
+    // foreground process info is always updated after this
+    return updateForegroundProcessInfo() && (processId() != _foregroundPid);
+}
+
+QString Session::foregroundProcessName()
+{
+    QString name;
+
+    if (updateForegroundProcessInfo()) 
+    {
+        bool ok = false;
+        name = _foregroundProcessInfo->name(&ok);
+        if (!ok)
+            name.clear();
+    }
+
+    return name;
+}
+
+/*
+void Session::saveSession(KConfigGroup& group)
+{
+    group.writePathEntry("WorkingDir", currentWorkingDirectory());
+    group.writeEntry("LocalTab",       tabTitleFormat(LocalTabTitle));
+    group.writeEntry("RemoteTab",      tabTitleFormat(RemoteTabTitle));
+    group.writeEntry("SessionGuid",    _uniqueIdentifier.toString());
+    group.writeEntry("Encoding",       QString(codec()));
+}
+
+void Session::restoreSession(KConfigGroup& group)
+{
+    QString value;
+
+    value = group.readPathEntry("WorkingDir", QString());
+    if (!value.isEmpty()) setInitialWorkingDirectory(value);
+    value = group.readEntry("LocalTab");
+    if (!value.isEmpty()) setTabTitleFormat(LocalTabTitle, value);
+    value = group.readEntry("RemoteTab");
+    if (!value.isEmpty()) setTabTitleFormat(RemoteTabTitle, value);
+    value = group.readEntry("SessionGuid");
+    if (!value.isEmpty()) _uniqueIdentifier = QUuid(value);
+    value = group.readEntry("Encoding");
+    if (!value.isEmpty()) setCodec(value.toUtf8());
+}
+*/
+
+SessionGroup::SessionGroup(QObject* parent)
+    : QObject(parent), _masterMode(0)
 {
 }
 SessionGroup::~SessionGroup()
 {
-    // disconnect all
-    connectAll(false);
 }
 int SessionGroup::masterMode() const { return _masterMode; }
 QList<Session*> SessionGroup::sessions() const { return _sessions.keys(); }
 bool SessionGroup::masterStatus(Session* session) const { return _sessions[session]; }
 
 void SessionGroup::addSession(Session* session)
 {
+    connect(session,SIGNAL(finished()),this,SLOT(sessionFinished()));
     _sessions.insert(session,false);
-
-    QListIterator<Session*> masterIter(masters());
-
-    while ( masterIter.hasNext() )
-        connectPair(masterIter.next(),session);
 }
 void SessionGroup::removeSession(Session* session)
 {
+    disconnect(session,SIGNAL(finished()),this,SLOT(sessionFinished()));
     setMasterStatus(session,false);
-
-    QListIterator<Session*> masterIter(masters());
-
-    while ( masterIter.hasNext() )
-        disconnectPair(masterIter.next(),session);
-
     _sessions.remove(session);
 }
+void SessionGroup::sessionFinished()
+{
+    Session* session = qobject_cast<Session*>(sender());
+    Q_ASSERT(session);
+    removeSession(session);
+}
 void SessionGroup::setMasterMode(int mode)
 {
    _masterMode = mode;
-
-   connectAll(false);
-   connectAll(true);
 }
 QList<Session*> SessionGroup::masters() const
 {
     return _sessions.keys(true);
 }
-void SessionGroup::connectAll(bool connect)
-{
-    QListIterator<Session*> masterIter(masters());
-
-    while ( masterIter.hasNext() )
-    {
-        Session* master = masterIter.next();
-
-        QListIterator<Session*> otherIter(_sessions.keys());
-        while ( otherIter.hasNext() )
-        {
-            Session* other = otherIter.next();
-
-            if ( other != master )
-            {
-                if ( connect )
-                    connectPair(master,other);
-                else
-                    disconnectPair(master,other);
-            }
-        }
-    }
-}
 void SessionGroup::setMasterStatus(Session* session , bool master)
 {
-    bool wasMaster = _sessions[session];
+    const bool wasMaster = _sessions[session];
+
+    if (wasMaster == master) {
+        // No status change -> nothing to do.
+        return;
+    }
     _sessions[session] = master;
 
-    if (    !wasMaster && !master
-         || wasMaster && master )
-      return;
-
-    QListIterator<Session*> iter(_sessions.keys());
-    while ( iter.hasNext() )
-    {
-        Session* other = iter.next();
-
-        if ( other != session )
-        {
-            if ( master )
-                connectPair(session,other);
-            else
-                disconnectPair(session,other);
-        }
+    if(master) {
+        connect( session->emulation() , SIGNAL(sendData(const char*,int)) , this,
+                 SLOT(forwardData(const char*,int)) );
+    }
+    else {
+        disconnect( session->emulation() , SIGNAL(sendData(const char*,int)) , this,
+                    SLOT(forwardData(const char*,int)) );
     }
 }
-void SessionGroup::connectPair(Session* master , Session* other)
+void SessionGroup::forwardData(const char* data, int size)
 {
-//    qDebug() << k_funcinfo;
-
-    if ( _masterMode & CopyInputToAll )
-    {
-        qDebug() << "Connection session " << master->nameTitle() << "to" << other->nameTitle();
-
-        connect( master->emulation() , SIGNAL(sendData(const char*,int)) , other->emulation() ,
-                 SLOT(sendString(const char*,int)) );
+    static bool _inForwardData = false;
+    if(_inForwardData) {   // Avoid recursive calls among session groups!
+       // A recursive call happens when a master in group A calls forwardData()
+       // in group B. If one of the destination sessions in group B is also a
+       // master of a group including the master session of group A, this would
+       // again call forwardData() in group A, and so on.
+       return;
     }
+    
+    _inForwardData = true;
+    QListIterator<Session*> iter(_sessions.keys());
+    while(iter.hasNext()) {
+        Session* other = iter.next();
+        if(!_sessions[other]) {
+           other->emulation()->sendString(data, size);
+        }
+    }
+    _inForwardData = false;
 }
-void SessionGroup::disconnectPair(Session* master , Session* other)
-{
-    if ( _masterMode & CopyInputToAll )
-    {
-        qDebug() << "Disconnecting session " << master->nameTitle() << "from" << other->nameTitle();
 
-        disconnect( master->emulation() , SIGNAL(sendData(const char*,int)) , other->emulation() ,
-                SLOT(sendString(const char*,int)) );
-    }
-}
+
diff --git a/gui//src/Session.h b/gui//src/Session.h
--- a/gui//src/Session.h
+++ b/gui//src/Session.h
@@ -1,15 +1,14 @@
 /*
     This file is part of Konsole, an X terminal.
 
-    Copyright (C) 2007 by Robert Knight <robertknight@gmail.com>
-    Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
-
-    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+    Copyright 2007-2008 by Robert Knight <robertknight@gmail.com>
+    Copyright 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
+    Copyright 2009 by Thomas Dreibholz <dreibh@iem.uni-due.de>
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
 
     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -22,41 +21,51 @@
     02110-1301  USA.
 */
 
 #ifndef SESSION_H
 #define SESSION_H
 
 // Qt
 #include <QtCore/QStringList>
-#include <QtCore>
+#include <QtCore/QByteRef>
+#include <QtCore/QSize>
+#include <QUuid>
 #include <QWidget>
 
+// KDE
+//#include <KApplication>
+//#include <KMainWindow>
+#include "konsole_export.h"
+
 // Konsole
 #include "History.h"
 
 class KProcess;
+class KUrl;
 class Emulation;
 class Pty;
+class ProcessInfo;
 class TerminalDisplay;
-
+  //class ZModemDialog;
 /**
  * Represents a terminal session consisting of a pseudo-teletype and a terminal emulation.
  * The pseudo-teletype (or PTY) handles I/O between the terminal process and Konsole.
  * The terminal emulation ( Emulation and subclasses ) processes the output stream from the
  * PTY and produces a character image which is then shown on views connected to the session.
  *
  * Each Session can be connected to one or more views by using the addView() method.
  * The attached views can then display output from the program running in the terminal
  * or send input to the program in the terminal in the form of keypresses and mouse
  * activity.
  */
 class Session : public QObject
 {
 Q_OBJECT
+Q_CLASSINFO("D-Bus Interface", "org.kde.konsole.Session")
 
 public:
   Q_PROPERTY(QString name READ nameTitle)
   Q_PROPERTY(int processId READ processId)
   Q_PROPERTY(QString keyBindings READ keyBindings WRITE setKeyBindings)
   Q_PROPERTY(QSize size READ size WRITE setSize)
 
   /**
@@ -65,40 +74,38 @@ public:
    * To start the terminal process, call the run() method,
    * after specifying the program and arguments
    * using setProgram() and setArguments()
    *
    * If no program or arguments are specified explicitly, the Session
    * falls back to using the program specified in the SHELL environment
    * variable.
    */
-  Session();
+  explicit Session(QObject* parent = 0);
   ~Session();
 
+  /** 
+   * Connect to an existing terminal.  When a new Session() is constructed it 
+   * automatically searches for and opens a new teletype.  If you want to 
+   * use an existing teletype (given its file descriptor) call this after
+   * constructing the session.
+   *
+   * Calling openTeletype() while a session is running has no effect.
+   *
+   * @param masterFd The file descriptor of the pseudo-teletype master (See KPtyProcess::KPtyProcess())
+   */
+  void openTeletype(int masterFd);
+
   /**
    * Returns true if the session is currently running.  This will be true
    * after run() has been called successfully.
    */
   bool isRunning() const;
 
   /**
-   * Sets the profile associated with this session.
-   *
-   * @param profileKey A key which can be used to obtain the current
-   * profile settings from the SessionManager
-   */
-  void setProfileKey(const QString& profileKey);
-  /**
-   * Returns the profile key associated with this session.
-   * This can be passed to the SessionManager to obtain the current
-   * profile settings.
-   */
-  QString profileKey() const;
-
-  /**
    * Adds a new view for this session.
    *
    * The viewing widget will display the output from the terminal and
    * input from the viewing widget (key presses, mouse activity etc.)
    * will be sent to the terminal.
    *
    * Views can be removed using removeView().  The session is automatically
    * closed when the last view is removed.
@@ -119,51 +126,40 @@ public:
   QList<TerminalDisplay*> views() const;
 
   /**
    * Returns the terminal emulation instance being used to encode / decode
    * characters to / from the process.
    */
   Emulation*  emulation() const;
 
-  /**
-   * Returns the environment of this session as a list of strings like
-   * VARIABLE=VALUE
-   */
-  QStringList environment() const;
-  /**
-   * Sets the environment for this session.
-   * @p environment should be a list of strings like
-   * VARIABLE=VALUE
-   */
-  void setEnvironment(const QStringList& environment);
-
   /** Returns the unique ID for this session. */
   int sessionId() const;
 
   /**
-   * Return the session title set by the user (ie. the program running
-   * in the terminal), or an empty string if the user has not set a custom title
-   */
-  QString userTitle() const;
-
-  /**
    * This enum describes the contexts for which separate
    * tab title formats may be specified.
    */
   enum TabTitleContext
   {
     /** Default tab title format */
     LocalTabTitle,
     /**
      * Tab title format used session currently contains
      * a connection to a remote computer (via SSH)
      */
     RemoteTabTitle
   };
+
+  /**
+   * Returns true if the session currently contains a connection to a 
+   * remote computer.  It currently supports ssh.
+   */
+  bool isRemote();
+
   /**
    * Sets the format used by this session for tab titles.
    *
    * @param context The context whoose format should be set.
    * @param format The tab title format.  This may be a mixture
    * of plain text and dynamic elements denoted by a '%' character
    * followed by a letter.  (eg. %d for directory).  The dynamic
    * elements available depend on the @p context
@@ -191,16 +187,21 @@ public:
 
   /**
    * Sets the initial working directory for the session when it is run
    * This has no effect once the session has been started.
    */
   void setInitialWorkingDirectory( const QString& dir );
 
   /**
+   * Returns the current directory of the foreground process in the session
+   */
+  QString currentWorkingDirectory();
+
+  /**
    * Sets the type of history store used by this session.
    * Lines of output produced by the terminal are added
    * to the history store.  The type of history store
    * used affects the number of lines which can be
    * remembered before they are lost and the storage
    * (in memory, on-disk etc.) used.
    */
   void setHistoryType(const HistoryType& type);
@@ -209,42 +210,16 @@ public:
    */
   const HistoryType& historyType() const;
   /**
    * Clears the history store used by this session.
    */
   void clearHistory();
 
   /**
-   * Enables monitoring for activity in the session.
-   * This will cause notifySessionState() to be emitted
-   * with the NOTIFYACTIVITY state flag when output is
-   * received from the terminal.
-   */
-  void setMonitorActivity(bool);
-  /** Returns true if monitoring for activity is enabled. */
-  bool isMonitorActivity() const;
-
-  /**
-   * Enables monitoring for silence in the session.
-   * This will cause notifySessionState() to be emitted
-   * with the NOTIFYSILENCE state flag when output is not
-   * received from the terminal for a certain period of
-   * time, specified with setMonitorSilenceSeconds()
-   */
-  void setMonitorSilence(bool);
-  /**
-   * Returns true if monitoring for inactivity (silence)
-   * in the session is enabled.
-   */
-  bool isMonitorSilence()  const;
-  /** See setMonitorSilence() */
-  void setMonitorSilenceSeconds(int seconds);
-
-  /**
    * Sets the key bindings used by this session.  The bindings
    * specify how input key sequences are translated into
    * the character stream which is sent to the terminal.
    *
    * @param id The name of the key bindings to use.  The
    * names of available key bindings can be determined using the
    * KeyboardTranslatorManager class.
    */
@@ -258,85 +233,74 @@ public:
   enum TitleRole
   {
       /** The name of the session. */
       NameRole,
       /** The title of the session which is displayed in tabs etc. */
       DisplayedTitleRole
   };
 
-  /** Sets the session's title for the specified @p role to @p title. */
-  void setTitle(TitleRole role , const QString& title);
-  /** Returns the session's title for the specified @p role. */
-  QString title(TitleRole role) const;
+  /**
+   * Return the session title set by the user (ie. the program running
+   * in the terminal), or an empty string if the user has not set a custom title
+   */
+  QString userTitle() const;
+
   /** Convenience method used to read the name property.  Returns title(Session::NameRole). */
   QString nameTitle() const { return title(Session::NameRole); }
+  /** Returns a title generated from tab format and process information. */
+  QString getDynamicTitle();
 
   /** Sets the name of the icon associated with this session. */
   void setIconName(const QString& iconName);
   /** Returns the name of the icon associated with this session. */
   QString iconName() const;
 
+  /** Return URL for the session. */
+  //KUrl getUrl();
+
   /** Sets the text of the icon associated with this session. */
   void setIconText(const QString& iconText);
   /** Returns the text of the icon associated with this session. */
   QString iconText() const;
 
-  /** Specifies whether a utmp entry should be created for the pty used by this session. */
-  void setAddToUtmp(bool);
+  /** Sets the session's title for the specified @p role to @p title. */
+  void setTitle(TitleRole role , const QString& title);
+
+  /** Returns the session's title for the specified @p role. */
+  QString title(TitleRole role) const;
 
-  /** Sends the specified @p signal to the terminal process. */
-  bool sendSignal(int signal);
+  /** 
+   * Specifies whether a utmp entry should be created for the pty used by this session.
+   * If true, KPty::login() is called when the session is started.
+   */
+  void setAddToUtmp(bool);
 
   /**
    * Specifies whether to close the session automatically when the terminal
    * process terminates.
    */
   void setAutoClose(bool b) { _autoClose = b; }
 
-  /**
-   * Sets whether flow control is enabled for this terminal
-   * session.
-   */
-  void setFlowControlEnabled(bool enabled);
-
-  /** Returns whether flow control is enabled for this terminal session. */
-  bool flowControlEnabled() const;
+  /** Returns true if the user has started a program in the session. */
+  bool isForegroundProcessActive();
 
-  /**
-   * Sends @p text to the current foreground terminal program.
-   */
-  void sendText(const QString& text) const;
-
-  /**
-   * Returns the process id of the terminal process.
-   * This is the id used by the system API to refer to the process.
-   */
-  int processId() const;
-
-  /**
-   * Returns the process id of the terminal's foreground process.
-   * This is initially the same as processId() but can change
-   * as the user starts other programs inside the terminal.
-   */
-  int foregroundProcessId() const;
+  /** Returns the name of the current foreground process. */
+  QString foregroundProcessName();
 
   /** Returns the terminal session's window size in lines and columns. */
   QSize size();
   /**
    * Emits a request to resize the session to accommodate
    * the specified window size.
    *
    * @param size The size in lines and columns to request.
    */
   void setSize(const QSize& size);
 
-  /** Sets the text codec used by this session's terminal emulation. */
-  void setCodec(QTextCodec* codec);
-
   /**
    * Sets whether the session has a dark background or not.  The session
    * uses this information to set the COLORFGBG variable in the process's
    * environment, which allows the programs running in the terminal to determine
    * whether the background is light or dark and use appropriate colors by default.
    *
    * This has no effect once the session is running.
    */
@@ -348,38 +312,192 @@ public:
   bool hasDarkBackground() const;
 
   /**
    * Attempts to get the shell program to redraw the current display area.
    * This can be used after clearing the screen, for example, to get the
    * shell to redraw the prompt line.
    */
   void refresh();
+
+  //  void startZModem(const QString &rz, const QString &dir, const QStringList &list);
+  //  void cancelZModem();
+  //  bool isZModemBusy() { return _zmodemBusy; }
+
+ /** 
+   * Possible values of the @p what parameter for setUserTitle()
+   * See "Operating System Controls" section on http://rtfm.etla.org/xterm/ctlseq.html 
+   */
+  enum UserTitleChange
+  {
+      IconNameAndWindowTitle     = 0,
+    IconName                 = 1,
+    WindowTitle                = 2,
+    TextColor                = 10,
+    BackgroundColor            = 11,
+    SessionName                = 30,
+    ProfileChange            = 50     // this clashes with Xterm's font change command
+  };
+
+  // Sets the text codec used by this sessions terminal emulation.
+  void setCodec(QTextCodec* codec);
+
+  // session management
+  //void saveSession(KConfigGroup& group);
+  //void restoreSession(KConfigGroup& group);
+
 public slots:
 
   /**
    * Starts the terminal session.
    *
    * This creates the terminal process and connects the teletype to it.
    */
   void run();
 
   /**
+   * Returns the environment of this session as a list of strings like
+   * VARIABLE=VALUE
+   */
+  Q_SCRIPTABLE QStringList environment() const;
+
+  /**
+   * Sets the environment for this session.
+   * @p environment should be a list of strings like
+   * VARIABLE=VALUE
+   */
+  Q_SCRIPTABLE void setEnvironment(const QStringList& environment);
+
+  /**
    * Closes the terminal session.  This sends a hangup signal
-   * (SIGHUP) to the terminal process and causes the done(Session*)
-   * signal to be emitted.
+   * (SIGHUP) to the terminal process and causes the finished()  
+   * signal to be emitted.  If the process does not respond to the SIGHUP signal
+   * then the terminal connection (the pty) is closed and Konsole waits for the 
+   * process to exit.
    */
-  void close();
+  Q_SCRIPTABLE void close();
 
   /**
    * Changes the session title or other customizable aspects of the terminal
    * emulation display. For a list of what may be changed see the
    * Emulation::titleChanged() signal.
+   *
+   * @param what The feature being changed.  Value is one of UserTitleChange
+   * @param caption The text part of the terminal command
    */
-  void setUserTitle( int, const QString &caption );
+  void setUserTitle( int what , const QString &caption );
+
+  /**
+   * Enables monitoring for activity in the session.
+   * This will cause notifySessionState() to be emitted
+   * with the NOTIFYACTIVITY state flag when output is
+   * received from the terminal.
+   */
+  Q_SCRIPTABLE void setMonitorActivity(bool);
+
+  /** Returns true if monitoring for activity is enabled. */
+  Q_SCRIPTABLE bool isMonitorActivity() const;
+
+  /**
+   * Enables monitoring for silence in the session.
+   * This will cause notifySessionState() to be emitted
+   * with the NOTIFYSILENCE state flag when output is not
+   * received from the terminal for a certain period of
+   * time, specified with setMonitorSilenceSeconds()
+   */
+  Q_SCRIPTABLE void setMonitorSilence(bool);
+
+  /**
+   * Returns true if monitoring for inactivity (silence)
+   * in the session is enabled.
+   */
+  Q_SCRIPTABLE bool isMonitorSilence() const;
+
+  /** See setMonitorSilence() */
+  Q_SCRIPTABLE void setMonitorSilenceSeconds(int seconds);
+
+  /**
+   * Sets whether flow control is enabled for this terminal
+   * session.
+   */
+  Q_SCRIPTABLE void setFlowControlEnabled(bool enabled);
+
+  /** Returns whether flow control is enabled for this terminal session. */
+  Q_SCRIPTABLE bool flowControlEnabled() const;
+
+  /**
+   * Sends @p text to the current foreground terminal program.
+   */
+  Q_SCRIPTABLE void sendText(const QString& text) const;
+
+   /**
+    * Sends a mouse event of type @p eventType emitted by button
+    * @p buttons on @p column/@p line to the current foreground
+    * terminal program
+    */
+   Q_SCRIPTABLE void sendMouseEvent(int buttons, int column, int line, int eventType);
+
+   /**
+   * Returns the process id of the terminal process.
+   * This is the id used by the system API to refer to the process.
+   */
+  Q_SCRIPTABLE int processId() const;
+
+  /**
+   * Returns the process id of the terminal's foreground process.
+   * This is initially the same as processId() but can change
+   * as the user starts other programs inside the terminal.
+   */
+  Q_SCRIPTABLE int foregroundProcessId();
+
+  /** Sets the text codec used by this sessions terminal emulation.
+    * Overloaded to accept a QByteArray for convenience since DBus
+    * does not accept QTextCodec directky.
+    */
+  Q_SCRIPTABLE bool setCodec(QByteArray codec);
+
+  /** Returns the codec used to decode incoming characters in this
+   * terminal emulation
+   */
+  Q_SCRIPTABLE QByteArray codec();
+
+  /** Sets the session's title for the specified @p role to @p title.
+   *  This is an overloaded member function for setTitle(TitleRole, QString)
+   *  provided for convenience since enum data types may not be
+   *  exported directly through DBus
+   */
+  Q_SCRIPTABLE void setTitle(int role, const QString& title);
+
+  /** Returns the session's title for the specified @p role.
+   * This is an overloaded member function for  setTitle(TitleRole)
+   * provided for convenience since enum data types may not be
+   * exported directly through DBus
+   */
+  Q_SCRIPTABLE QString title(int role) const;
+
+  /** Returns the "friendly" version of the QUuid of this session.
+  * This is a QUuid with the braces and dashes removed, so it cannot be
+  * used to construct a new QUuid. The same text appears in the
+  * SHELL_SESSION_ID environment variable.
+  */
+  Q_SCRIPTABLE QString shellSessionId() const;
+
+  /** Sets the session's tab title format for the specified @p context to @p format.
+   *  This is an overloaded member function for setTabTitleFormat(TabTitleContext, QString)
+   *  provided for convenience since enum data types may not be
+   *  exported directly through DBus
+   */
+  Q_SCRIPTABLE void setTabTitleFormat(int context, const QString& format);
+
+  /** Returns the session's tab title format for the specified @p context.
+   * This is an overloaded member function for tabTitleFormat(TitleRole)
+   * provided for convenience since enum data types may not be
+   * exported directly through DBus
+   */
+  Q_SCRIPTABLE QString tabTitleFormat(int context) const;
 
 signals:
 
   /** Emitted when the terminal process starts. */
   void started();
 
   /**
    * Emitted when the terminal process exits.
@@ -389,19 +507,16 @@ signals:
   /**
    * Emitted when output is received from the terminal process.
    */
   void receivedData( const QString& text );
 
   /** Emitted when the session's title has changed. */
   void titleChanged();
 
-  /** Emitted when the session's profile has changed. */
-  void profileChanged(const QString& profile);
-
   /**
    * Emitted when the activity state of this session changes.
    *
    * @param state The new state of the session.  This may be one
    * of NOTIFYNORMAL, NOTIFYSILENCE or NOTIFYACTIVITY
    */
   void stateChanged(int state);
 
@@ -416,20 +531,28 @@ signals:
    */
   void changeTabTextColorRequest(int);
 
   /**
    * Requests that the background color of views on this session
    * should be changed.
    */
   void changeBackgroundColorRequest(const QColor&);
+  /** 
+   * Requests that the text color of views on this session should
+   * be changed to @p color.
+   */
+  void changeForegroundColorRequest(const QColor&);
 
   /** TODO: Document me. */
   void openUrlRequest(const QString& url);
 
+  /** TODO: Document me. */
+  //void zmodemDetected();
+
   /**
    * Emitted when the terminal process requests a change
    * in the size of the terminal window.
    *
    * @param size The requested window size in terms of lines and columns.
    */
   void resizeRequest(const QSize& size);
 
@@ -446,33 +569,53 @@ signals:
   *
   * @param enabled True if flow control is enabled or false otherwise.
   */
   void flowControlEnabledChanged(bool enabled);
 
 private slots:
   void done(int);
 
+  //  void fireZModemDetected();
+
   void onReceiveBlock( const char* buffer, int len );
   void monitorTimerDone();
 
   void onViewSizeChange(int height, int width);
-  void onEmulationSizeChange(int lines , int columns);
 
   void activityStateSet(int);
 
   //automatically detach views from sessions when view is destroyed
   void viewDestroyed(QObject* view);
 
+  //void zmodemReadStatus();
+  //void zmodemReadAndSendBlock();
+  //void zmodemRcvBlock(const char *data, int len);
+  //void zmodemFinished();
+
+  void updateFlowControlState(bool suspended);
+  void updateWindowSize(int lines, int columns);
 private:
 
   void updateTerminalSize();
   WId windowId() const;
+  bool kill(int signal);
+  // print a warning message in the terminal.  This is used
+  // if the program fails to start, or if the shell exits in 
+  // an unsuccessful manner
+  void terminalWarning(const QString& message);
+  // checks that the binary 'program' is available and can be executed
+  // returns the binary name if available or an empty string otherwise
+  QString checkProgram(const QString& program) const;
+  ProcessInfo* getProcessInfo();
+  void updateSessionProcessInfo();
+  bool updateForegroundProcessInfo();
+  ProcessInfo* updateWorkingDirectory();
 
-  int            _uniqueIdentifier;
+  QUuid            _uniqueIdentifier; // SHELL_SESSION_ID
 
   Pty*          _shellProcess;
   Emulation*    _emulation;
 
   QList<TerminalDisplay*> _views;
 
   bool           _monitorActivity;
   bool           _monitorSilence;
@@ -499,16 +642,28 @@ private:
 
   QString        _program;
   QStringList    _arguments;
 
   QStringList    _environment;
   int            _sessionId;
 
   QString        _initialWorkingDir;
+  QString        _currentWorkingDir;
+
+  ProcessInfo*   _sessionProcessInfo;
+  ProcessInfo*   _foregroundProcessInfo;
+  int            _foregroundPid;
+
+  // ZModem
+  //  bool           _zmodemBusy;
+  //  KProcess*      _zmodemProc;
+  //  ZModemDialog*  _zmodemProgress;
+
+  // Color/Font Changes by ESC Sequences
 
   QColor         _modifiedBackground; // as set by: echo -en '\033]11;Color\007
 
   QString        _profileKey;
 
   bool _hasDarkBackground;
 
   static int lastSessionId;
@@ -522,17 +677,17 @@ private:
  * by the masterMode() flags.
  */
 class SessionGroup : public QObject
 {
 Q_OBJECT
 
 public:
     /** Constructs an empty session group. */
-    SessionGroup();
+    SessionGroup(QObject* parent);
     /** Destroys the session group and removes all connections between master and slave sessions. */
     ~SessionGroup();
 
     /** Adds a session to the group. */
     void addSession( Session* session );
     /** Removes a session from the group. */
     void removeSession( Session* session );
 
@@ -572,20 +727,31 @@ public:
      */
     void setMasterMode( int mode );
     /**
      * Returns a bitwise OR of the active MasterMode flags for this group.
      * See setMasterMode()
      */
     int masterMode() const;
 
+private slots:
+    void sessionFinished();
+    void forwardData(const char* data, int size);
+
 private:
-    void connectPair(Session* master , Session* other);
-    void disconnectPair(Session* master , Session* other);
-    void connectAll(bool connect);
     QList<Session*> masters() const;
 
     // maps sessions to their master status
     QHash<Session*,bool> _sessions;
 
     int _masterMode;
 };
+
 #endif
+
+/*
+  Local Variables:
+  mode: c++
+  c-file-style: "stroustrup"
+  indent-tabs-mode: nil
+  tab-width: 4
+  End:
+*/
diff --git a/gui//src/TerminalCharacterDecoder.cpp b/gui//src/TerminalCharacterDecoder.cpp
--- a/gui//src/TerminalCharacterDecoder.cpp
+++ b/gui//src/TerminalCharacterDecoder.cpp
@@ -1,15 +1,13 @@
 /*
     This file is part of Konsole, an X terminal.
     
-    Copyright (C) 2006 by Robert Knight <robertknight@gmail.com>
+    Copyright 2006-2008 by Robert Knight <robertknight@gmail.com>
     
-    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
-
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU Lesser General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
 
     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
@@ -22,90 +20,114 @@
 */
 
 // Own
 #include "TerminalCharacterDecoder.h"
 
 // Qt
 #include <QtCore/QTextStream>
 
+// KDE
+//#include <kdebug.h>
+
+// Konsole
+#include "konsole_wcwidth.h"
+
 PlainTextDecoder::PlainTextDecoder()
  : _output(0)
  , _includeTrailingWhitespace(true)
+ , _recordLinePositions(false)
 {
 
 }
 void PlainTextDecoder::setTrailingWhitespace(bool enable)
 {
     _includeTrailingWhitespace = enable;
 }
 bool PlainTextDecoder::trailingWhitespace() const
 {
     return _includeTrailingWhitespace;
 }
 void PlainTextDecoder::begin(QTextStream* output)
 {
-   _output = output; 
+   _output = output;
+   if (!_linePositions.isEmpty())
+       _linePositions.clear();
 }
 void PlainTextDecoder::end()
 {
     _output = 0;
 }
+
+void PlainTextDecoder::setRecordLinePositions(bool record)
+{
+    _recordLinePositions = record;
+}
+QList<int> PlainTextDecoder::linePositions() const
+{
+    return _linePositions;
+}
 void PlainTextDecoder::decodeLine(const Character* const characters, int count, LineProperty /*properties*/
-							 )
+                             )
 {
     Q_ASSERT( _output );
 
-	//TODO should we ignore or respect the LINE_WRAPPED line property?
+    if (_recordLinePositions && _output->string())
+    {
+        int pos = _output->string()->count();
+        _linePositions << pos;
+    }
 
-	//note:  we build up a QString and send it to the text stream rather writing into the text
-	//stream a character at a time because it is more efficient.
-	//(since QTextStream always deals with QStrings internally anyway)
-	QString plainText;
-	plainText.reserve(count);
+    //TODO should we ignore or respect the LINE_WRAPPED line property?
+
+    //note:  we build up a QString and send it to the text stream rather writing into the text
+    //stream a character at a time because it is more efficient.
+    //(since QTextStream always deals with QStrings internally anyway)
+    QString plainText;
+    plainText.reserve(count);
    
     int outputCount = count;
 
     // if inclusion of trailing whitespace is disabled then find the end of the
     // line
     if ( !_includeTrailingWhitespace )
     {
         for (int i = count-1 ; i >= 0 ; i--)
         {
             if ( characters[i].character != ' '  )
                 break;
             else
                 outputCount--;
         }
     }
-
-	for (int i=0;i<outputCount;i++)
-	{
-		plainText.append( QChar(characters[i].character) );
-	}
-
-	*_output << plainText;
+    
+    for (int i=0;i<outputCount;)
+    {
+        plainText.append( QChar(characters[i].character) );
+        i += qMax(1,konsole_wcwidth(characters[i].character));
+    }
+    *_output << plainText;
 }
 
 HTMLDecoder::HTMLDecoder() :
         _output(0)
-	   ,_colorTable(base_color_table)
+    ,_colorTable(base_color_table)
        ,_innerSpanOpen(false)
        ,_lastRendition(DEFAULT_RENDITION)
 {
-	
+    
 }
 
 void HTMLDecoder::begin(QTextStream* output)
 {
     _output = output;
 
     QString text;
 
-	//open monospace span
+    //open monospace span
     openSpan(text,"font-family:monospace");
 
     *output << text;
 }
 
 void HTMLDecoder::end()
 {
     Q_ASSERT( _output );
@@ -116,108 +138,113 @@ void HTMLDecoder::end()
 
     *_output << text;
 
     _output = 0;
 
 }
 
 //TODO: Support for LineProperty (mainly double width , double height)
-void HTMLDecoder::decodeLine(const Character* const characters, int count, LineProperty)
+void HTMLDecoder::decodeLine(const Character* const characters, int count, LineProperty /*properties*/
+                            )
 {
     Q_ASSERT( _output );
 
-	QString text;
+    QString text;
 
-	int spaceCount = 0;
-		
-	for (int i=0;i<count;i++)
-	{
-		QChar ch(characters[i].character);
+    int spaceCount = 0;
+        
+    for (int i=0;i<count;i++)
+    {
+        QChar ch(characters[i].character);
 
-		//check if appearance of character is different from previous char
-		if ( characters[i].rendition != _lastRendition  ||
-		     characters[i].foregroundColor != _lastForeColor  ||
-			 characters[i].backgroundColor != _lastBackColor )
-		{
-			if ( _innerSpanOpen )
-					closeSpan(text);
+        //check if appearance of character is different from previous char
+        if ( characters[i].rendition != _lastRendition  ||
+             characters[i].foregroundColor != _lastForeColor  ||
+             characters[i].backgroundColor != _lastBackColor )
+        {
+            if ( _innerSpanOpen )
+                    closeSpan(text);
 
-			_lastRendition = characters[i].rendition;
-			_lastForeColor = characters[i].foregroundColor;
-			_lastBackColor = characters[i].backgroundColor;
-			
-			//build up style string
-			QString style;
+            _lastRendition = characters[i].rendition;
+            _lastForeColor = characters[i].foregroundColor;
+            _lastBackColor = characters[i].backgroundColor;
+            
+            //build up style string
+            QString style;
 
-			if ( _lastRendition & RE_BOLD ||
-                             (_colorTable && characters[i].isBold(_colorTable)) )
-					style.append("font-weight:bold;");
-
+            bool useBold;
+            ColorEntry::FontWeight weight = characters[i].fontWeight(_colorTable);
+            if (weight == ColorEntry::UseCurrentFormat)
+                useBold = _lastRendition & RE_BOLD;
+            else
+                useBold = weight == ColorEntry::Bold;
+            
+            if (useBold)
+                style.append("font-weight:bold;");
 
-			if ( _lastRendition & RE_UNDERLINE )
-					style.append("font-decoration:underline;");
-		
-			//colours - a colour table must have been defined first
-			if ( _colorTable )	
-			{
-				style.append( QString("color:%1;").arg(_lastForeColor.color(_colorTable).name() ) );
+            if ( _lastRendition & RE_UNDERLINE )
+                    style.append("font-decoration:underline;");
+        
+            //colours - a colour table must have been defined first
+            if ( _colorTable )    
+            {
+                style.append( QString("color:%1;").arg(_lastForeColor.color(_colorTable).name() ) );
 
-				if (!characters[i].isTransparent(_colorTable))
-				{
-					style.append( QString("background-color:%1;").arg(_lastBackColor.color(_colorTable).name() ) );
-				}
-			}
-		
-			//open the span with the current style	
-			openSpan(text,style);
-			_innerSpanOpen = true;
-		}
+                if (!characters[i].isTransparent(_colorTable))
+                {
+                    style.append( QString("background-color:%1;").arg(_lastBackColor.color(_colorTable).name() ) );
+                }
+            }
+        
+            //open the span with the current style    
+            openSpan(text,style);
+            _innerSpanOpen = true;
+        }
 
-		//handle whitespace
-		if (ch.isSpace())
-			spaceCount++;
-		else
-			spaceCount = 0;
-		
+        //handle whitespace
+        if (ch.isSpace())
+            spaceCount++;
+        else
+            spaceCount = 0;
+        
 
-		//output current character
-		if (spaceCount < 2)
-		{
-			//escape HTML tag characters and just display others as they are
-			if ( ch == '<' )
-				text.append("&lt;");
-			else if (ch == '>')
-					text.append("&gt;");
-			else	
-					text.append(ch);
-		}
-		else
-		{
-			text.append("&nbsp;"); //HTML truncates multiple spaces, so use a space marker instead
-		}
-		
-	}
+        //output current character
+        if (spaceCount < 2)
+        {
+            //escape HTML tag characters and just display others as they are
+            if ( ch == '<' )
+                text.append("&lt;");
+            else if (ch == '>')
+                    text.append("&gt;");
+            else    
+                    text.append(ch);
+        }
+        else
+        {
+            text.append("&nbsp;"); //HTML truncates multiple spaces, so use a space marker instead
+        }
+        
+    }
 
-	//close any remaining open inner spans
-	if ( _innerSpanOpen )
-		closeSpan(text);
+    //close any remaining open inner spans
+    if ( _innerSpanOpen )
+        closeSpan(text);
 
-	//start new line
-	text.append("<br>");
-	
-	*_output << text;
+    //start new line
+    text.append("<br>");
+    
+    *_output << text;
 }
-
 void HTMLDecoder::openSpan(QString& text , const QString& style)
 {
-	text.append( QString("<span style=\"%1\">").arg(style) );
+    text.append( QString("<span style=\"%1\">").arg(style) );
 }
 
 void HTMLDecoder::closeSpan(QString& text)
 {
-	text.append("</span>");
+    text.append("</span>");
 }
 
 void HTMLDecoder::setColorTable(const ColorEntry* table)
 {
-	_colorTable = table;
+    _colorTable = table;
 }
diff --git a/gui//src/TerminalCharacterDecoder.h b/gui//src/TerminalCharacterDecoder.h
--- a/gui//src/TerminalCharacterDecoder.h
+++ b/gui//src/TerminalCharacterDecoder.h
@@ -1,15 +1,13 @@
 /*
     This file is part of Konsole, an X terminal.
     
-    Copyright (C) 2006-7 by Robert Knight <robertknight@gmail.com>
+    Copyright 2006-2008 by Robert Knight <robertknight@gmail.com>
     
-    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
-
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU Lesser General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
 
     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
@@ -21,113 +19,127 @@
     02110-1301  USA.
 */
 
 #ifndef TERMINAL_CHARACTER_DECODER_H
 #define TERMINAL_CHARACTER_DECODER_H
 
 #include "Character.h"
 
+#include <QList>
+
 class QTextStream;
 
 /**
  * Base class for terminal character decoders
  *
  * The decoder converts lines of terminal characters which consist of a unicode character, foreground
  * and background colours and other appearance-related properties into text strings.
  *
  * Derived classes may produce either plain text with no other colour or appearance information, or
  * they may produce text which incorporates these additional properties. 
  */
 class TerminalCharacterDecoder
 {
 public:
-	virtual ~TerminalCharacterDecoder() {}
+    virtual ~TerminalCharacterDecoder() {}
 
     /** Begin decoding characters.  The resulting text is appended to @p output. */
     virtual void begin(QTextStream* output) = 0;
     /** End decoding. */
     virtual void end() = 0;
 
-	/**
-	 * Converts a line of terminal characters with associated properties into a text string
-	 * and writes the string into an output QTextStream.
-	 *
-	 * @param characters An array of characters of length @p count.
-	 * @param properties Additional properties which affect all characters in the line
-	 * @param output The output stream which receives the decoded text
-	 */
-	virtual void decodeLine(const Character* const characters, 
-							int count,
-							LineProperty properties) = 0; 
+    /**
+     * Converts a line of terminal characters with associated properties into a text string
+     * and writes the string into an output QTextStream.
+     *
+     * @param characters An array of characters of length @p count.
+     * @param count The number of characters
+     * @param properties Additional properties which affect all characters in the line
+     */
+    virtual void decodeLine(const Character* const characters, 
+                            int count,
+                            LineProperty properties) = 0; 
 };
 
 /**
  * A terminal character decoder which produces plain text, ignoring colours and other appearance-related
  * properties of the original characters.
  */
 class PlainTextDecoder : public TerminalCharacterDecoder
 {
 public:
-	PlainTextDecoder(); 
+    PlainTextDecoder(); 
 
     /** 
      * Set whether trailing whitespace at the end of lines should be included 
      * in the output.
      * Defaults to true.
      */
     void setTrailingWhitespace(bool enable);
     /**
      * Returns whether trailing whitespace at the end of lines is included
      * in the output.
      */
     bool trailingWhitespace() const;
+    /** 
+     * Returns of character positions in the output stream
+     * at which new lines where added.  Returns an empty if setTrackLinePositions() is false or if 
+     * the output device is not a string.
+     */
+    QList<int> linePositions() const;
+    /** Enables recording of character positions at which new lines are added.  See linePositions() */
+    void setRecordLinePositions(bool record);
 
     virtual void begin(QTextStream* output);
     virtual void end();
 
-	virtual void decodeLine(const Character* const characters,
-							int count,
-							LineProperty properties);	
+    virtual void decodeLine(const Character* const characters,
+                            int count,
+                            LineProperty properties);    
 
     
 private:
     QTextStream* _output;
     bool _includeTrailingWhitespace;
+
+    bool _recordLinePositions;
+    QList<int> _linePositions;
 };
 
 /**
  * A terminal character decoder which produces pretty HTML markup
  */
 class HTMLDecoder : public TerminalCharacterDecoder
 {
 public:
-	/** 
-	 * Constructs an HTML decoder using a default black-on-white color scheme.
-	 */
-	HTMLDecoder();
+    /** 
+     * Constructs an HTML decoder using a default black-on-white color scheme.
+     */
+    HTMLDecoder();
 
-	/**
-	 * Sets the colour table which the decoder uses to produce the HTML colour codes in its
-	 * output
-	 */
-	void setColorTable( const ColorEntry* table );
-		
-	virtual void decodeLine(const Character* const characters,
-							int count,
-							LineProperty properties);
+    /**
+     * Sets the colour table which the decoder uses to produce the HTML colour codes in its
+     * output
+     */
+    void setColorTable( const ColorEntry* table );
+        
+    virtual void decodeLine(const Character* const characters,
+                            int count,
+                            LineProperty properties);
 
     virtual void begin(QTextStream* output);
     virtual void end();
 
 private:
-	void openSpan(QString& text , const QString& style);
-	void closeSpan(QString& text);
+    void openSpan(QString& text , const QString& style);
+    void closeSpan(QString& text);
 
     QTextStream* _output;
-	const ColorEntry* _colorTable;
+    const ColorEntry* _colorTable;
     bool _innerSpanOpen; 
-	quint8 _lastRendition;
-	CharacterColor _lastForeColor;
-	CharacterColor _lastBackColor;
+    quint8 _lastRendition;
+    CharacterColor _lastForeColor;
+    CharacterColor _lastBackColor;
 
 };
+
 #endif
diff --git a/gui//src/TerminalDisplay.cpp b/gui//src/TerminalDisplay.cpp
--- a/gui//src/TerminalDisplay.cpp
+++ b/gui//src/TerminalDisplay.cpp
@@ -1,16 +1,14 @@
 /*
     This file is part of Konsole, a terminal emulator for KDE.
     
-    Copyright (C) 2006-7 by Robert Knight <robertknight@gmail.com>
-    Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
+    Copyright 2006-2008 by Robert Knight <robertknight@gmail.com>
+    Copyright 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
     
-    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
-
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
 
     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
@@ -35,41 +33,80 @@
 #include <QtCore/QFile>
 #include <QtGui/QGridLayout>
 #include <QtGui/QLabel>
 #include <QtGui/QLayout>
 #include <QtGui/QPainter>
 #include <QtGui/QPixmap>
 #include <QtGui/QScrollBar>
 #include <QtGui/QStyle>
-#include <QtCore>
-#include <QtGui>
-
+#include <QtCore/QTimer>
+#include <QtGui/QToolTip>
+#include <QtCore/QTextStream>
+
+// KDE
+//#include <kshell.h>
+//#include <KColorScheme>
+//#include <KCursor>
+//#include <kdebug.h>
+//#include <KLocale>
+//#include <KMenu>
+//#include <KNotification>
+//#include <KGlobalSettings>
+//#include <KShortcut>
+//#include <KIO/NetAccess>
+//#include "kdebug.h"
+
+// Konsole
+//#include <config-apps.h>
 #include "Filter.h"
 #include "konsole_wcwidth.h"
 #include "ScreenWindow.h"
 #include "TerminalCharacterDecoder.h"
-#include "ColorTables.h"
 
 #ifndef loc
 #define loc(X,Y) ((Y)*_columns+(X))
 #endif
 
 #define yMouseScroll 1
 
 #define REPCHAR   "ABCDEFGHIJKLMNOPQRSTUVWXYZ" \
                   "abcdefgjijklmnopqrstuvwxyz" \
                   "0123456789./+@"
 
+const ColorEntry base_color_table[TABLE_COLORS] =
+// The following are almost IBM standard color codes, with some slight
+// gamma correction for the dim colors to compensate for bright X screens.
+// It contains the 8 ansiterm/xterm colors in 2 intensities.
+{
+  // Fixme: could add faint colors here, also.
+  // normal
+  ColorEntry(QColor(0x00,0x00,0x00), 0), ColorEntry( QColor(0xB2,0xB2,0xB2), 1), // Dfore, Dback
+  ColorEntry(QColor(0x00,0x00,0x00), 0), ColorEntry( QColor(0xB2,0x18,0x18), 0), // Black, Red
+  ColorEntry(QColor(0x18,0xB2,0x18), 0), ColorEntry( QColor(0xB2,0x68,0x18), 0), // Green, Yellow
+  ColorEntry(QColor(0x18,0x18,0xB2), 0), ColorEntry( QColor(0xB2,0x18,0xB2), 0), // Blue, Magenta
+  ColorEntry(QColor(0x18,0xB2,0xB2), 0), ColorEntry( QColor(0xB2,0xB2,0xB2), 0), // Cyan, White
+  // intensiv
+  ColorEntry(QColor(0x00,0x00,0x00), 0), ColorEntry( QColor(0xFF,0xFF,0xFF), 1),
+  ColorEntry(QColor(0x68,0x68,0x68), 0), ColorEntry( QColor(0xFF,0x54,0x54), 0),
+  ColorEntry(QColor(0x54,0xFF,0x54), 0), ColorEntry( QColor(0xFF,0xFF,0x54), 0),
+  ColorEntry(QColor(0x54,0x54,0xFF), 0), ColorEntry( QColor(0xFF,0x54,0xFF), 0),
+  ColorEntry(QColor(0x54,0xFF,0xFF), 0), ColorEntry( QColor(0xFF,0xFF,0xFF), 0)
+};
+
 // scroll increment used when dragging selection at top/bottom of window.
 
 // static
 bool TerminalDisplay::_antialiasText = true;
 bool TerminalDisplay::HAVE_TRANSPARENCY = false;
 
+// we use this to force QPainter to display text in LTR mode
+// more information can be found in: http://unicode.org/reports/tr9/ 
+const QChar LTR_OVERRIDE_CHAR( 0x202D );
+
 /* ------------------------------------------------------------------------- */
 /*                                                                           */
 /*                                Colors                                     */
 /*                                                                           */
 /* ------------------------------------------------------------------------- */
 
 /* Note that we use ANSI color order (bgr), while IBMPC color order is (rgb)
 
@@ -90,41 +127,53 @@ void TerminalDisplay::setScreenWindow(Sc
     {
         disconnect( _screenWindow , 0 , this , 0 );
     }
 
     _screenWindow = window;
 
     if ( window )
     {
+
+// TODO: Determine if this is an issue.
 //#warning "The order here is not specified - does it matter whether updateImage or updateLineProperties comes first?"
         connect( _screenWindow , SIGNAL(outputChanged()) , this , SLOT(updateLineProperties()) );
         connect( _screenWindow , SIGNAL(outputChanged()) , this , SLOT(updateImage()) );
-	window->setWindowLines(_lines);
+        window->setWindowLines(_lines);
     }
 }
 
 const ColorEntry* TerminalDisplay::colorTable() const
 {
   return _colorTable;
 }
-
+void TerminalDisplay::setBackgroundColor(const QColor& color)
+{
+    _colorTable[DEFAULT_BACK_COLOR].color = color;
+    QPalette p = palette();
+      p.setColor( backgroundRole(), color ); 
+      setPalette( p );
+
+      // Avoid propagating the palette change to the scroll bar 
+      _scrollBar->setPalette( QApplication::palette() );  
+
+    update();
+}
+void TerminalDisplay::setForegroundColor(const QColor& color)
+{
+    _colorTable[DEFAULT_FORE_COLOR].color = color;
+
+    update();
+}
 void TerminalDisplay::setColorTable(const ColorEntry table[])
 {
   for (int i = 0; i < TABLE_COLORS; i++)
       _colorTable[i] = table[i];
 
-  QPalette p = palette();
-  p.setColor( backgroundRole(), _colorTable[DEFAULT_BACK_COLOR].color );
-  setPalette( p );
-
-  // Avoid propagating the palette change to the scroll bar 
-  _scrollBar->setPalette( QApplication::palette() );  
-
-  update();
+  setBackgroundColor(_colorTable[DEFAULT_BACK_COLOR].color);
 }
 
 /* ------------------------------------------------------------------------- */
 /*                                                                           */
 /*                                   Font                                    */
 /*                                                                           */
 /* ------------------------------------------------------------------------- */
 
@@ -138,36 +187,35 @@ void TerminalDisplay::setColorTable(cons
    We treat non-iso10646 fonts as VT100 extended and do the requiered mapping
    from unicode to 0x00..0x1f. The remaining translation is then left to the
    QCodec.
 */
 
 static inline bool isLineChar(quint16 c) { return ((c & 0xFF80) == 0x2500);}
 static inline bool isLineCharString(const QString& string)
 {
-		return (string.length() > 0) && (isLineChar(string.at(0).unicode()));
+        return (string.length() > 0) && (isLineChar(string.at(0).unicode()));
 }
-						
+                        
 
 // assert for i in [0..31] : vt100extended(vt100_graphics[i]) == i.
 
 unsigned short vt100_graphics[32] =
 { // 0/8     1/9    2/10    3/11    4/12    5/13    6/14    7/15
   0x0020, 0x25C6, 0x2592, 0x2409, 0x240c, 0x240d, 0x240a, 0x00b0,
   0x00b1, 0x2424, 0x240b, 0x2518, 0x2510, 0x250c, 0x2514, 0x253c,
   0xF800, 0xF801, 0x2500, 0xF803, 0xF804, 0x251c, 0x2524, 0x2534,
   0x252c, 0x2502, 0x2264, 0x2265, 0x03C0, 0x2260, 0x00A3, 0x00b7
 };
 
 void TerminalDisplay::fontChange(const QFont&)
 {
   QFontMetrics fm(font());
   _fontHeight = fm.height() + _lineSpacing;
 
-
   // waba TerminalDisplay 1.123:
   // "Base character width on widest ASCII character. This prevents too wide
   //  characters in the presence of double wide (e.g. Japanese) characters."
   // Get the width from representative normal width characters
   _fontWidth = qRound((double)fm.width(REPCHAR)/(double)strlen(REPCHAR));
 
   _fixedFont = true;
 
@@ -192,16 +240,21 @@ void TerminalDisplay::fontChange(const Q
 }
 
 void TerminalDisplay::setVTFont(const QFont& f)
 {
   QFont font = f;
 
   QFontMetrics metrics(font);
 
+  if ( !QFontInfo(font).fixedPitch() )
+  {
+      //kWarning() << "Using an unsupported variable-width font in the terminal.  This may produce display errors.";
+  }
+
   if ( metrics.height() < height() && metrics.maxWidth() < width() )
   {
     // hint that text should be drawn without anti-aliasing.  
     // depending on the user's font configuration, this may not be respected
     if (!_antialiasText)
         font.setStyleStrategy( QFont::NoAntialias );
  
     // experimental optimization.  Konsole assumes that the terminal is using a 
@@ -228,16 +281,17 @@ void TerminalDisplay::setFont(const QFon
 TerminalDisplay::TerminalDisplay(QWidget *parent)
 :QWidget(parent)
 ,_screenWindow(0)
 ,_allowBell(true)
 ,_gridLayout(0)
 ,_fontHeight(1)
 ,_fontWidth(1)
 ,_fontAscent(1)
+,_boldIntense(true)
 ,_lines(1)
 ,_columns(1)
 ,_usedLines(1)
 ,_usedColumns(1)
 ,_contentHeight(1)
 ,_contentWidth(1)
 ,_image(0)
 ,_randomSeed(0)
@@ -249,19 +303,21 @@ TerminalDisplay::TerminalDisplay(QWidget
 ,_wordSelectionMode(false)
 ,_lineSelectionMode(false)
 ,_preserveLineBreaks(false)
 ,_columnSelectionMode(false)
 ,_scrollbarLocation(NoScrollBar)
 ,_wordCharacters(":@-./_~")
 ,_bellMode(SystemBeepBell)
 ,_blinking(false)
+,_hasBlinker(false)
 ,_cursorBlinking(false)
 ,_hasBlinkingCursor(false)
-,_ctrlDrag(false)
+,_allowBlinkingText(true)
+,_ctrlDrag(true)
 ,_tripleClickMode(SelectWholeLine)
 ,_isFixedSize(false)
 ,_possibleTripleClick(false)
 ,_resizeWidget(0)
 ,_resizeTimer(0)
 ,_flowControlWarningEnabled(false)
 ,_outputSuspendedLabel(0)
 ,_lineSpacing(0)
@@ -281,55 +337,55 @@ TerminalDisplay::TerminalDisplay(QWidget
   _leftMargin = DEFAULT_LEFT_MARGIN;
 
   // create scroll bar for scrolling output up and down
   // set the scroll bar's slider to occupy the whole area of the scroll bar initially
   _scrollBar = new QScrollBar(this);
   setScroll(0,0); 
   _scrollBar->setCursor( Qt::ArrowCursor );
   connect(_scrollBar, SIGNAL(valueChanged(int)), this, 
-  					  SLOT(scrollBarPositionChanged(int)));
+                        SLOT(scrollBarPositionChanged(int)));
 
   // setup timers for blinking cursor and text
   _blinkTimer   = new QTimer(this);
   connect(_blinkTimer, SIGNAL(timeout()), this, SLOT(blinkEvent()));
   _blinkCursorTimer   = new QTimer(this);
   connect(_blinkCursorTimer, SIGNAL(timeout()), this, SLOT(blinkCursorEvent()));
 
-//  QCursor::setAutoHideCursor( this, true );
+  //KCursor::setAutoHideCursor( this, true );
   
   setUsesMouse(true);
-  setColorTable(whiteonblack_color_table); 
-//  setColorTable(blackonlightyellow_color_table); 
+  setColorTable(base_color_table);
   setMouseTracking(true);
 
   // Enable drag and drop 
   setAcceptDrops(true); // attempt
   dragInfo.state = diNone;
 
   setFocusPolicy( Qt::WheelFocus );
 
   // enable input method support
   setAttribute(Qt::WA_InputMethodEnabled, true);
 
   // this is an important optimization, it tells Qt
   // that TerminalDisplay will handle repainting its entire area.
   setAttribute(Qt::WA_OpaquePaintEvent);
 
   _gridLayout = new QGridLayout(this);
-  _gridLayout->setMargin(0);
+  _gridLayout->setContentsMargins(0, 0, 0, 0);
 
   setLayout( _gridLayout ); 
 
-  //set up a warning message when the user presses Ctrl+S to avoid confusion
-  connect( this,SIGNAL(flowControlKeyPressed(bool)),this,SLOT(outputSuspended(bool)) );
+  new AutoScrollHandler(this);
 }
 
 TerminalDisplay::~TerminalDisplay()
 {
+  disconnect(_blinkTimer);
+  disconnect(_blinkCursorTimer);
   qApp->removeEventFilter( this );
   
   delete[] _image;
 
   delete _gridLayout;
   delete _outputSuspendedLabel;
   delete _filterChain;
 }
@@ -451,36 +507,36 @@ static void drawLineChar(QPainter& paint
         paint.drawPoint(cx-1, cy+1);
     if (toDraw & Int32)
         paint.drawPoint(cx, cy+1);
     if (toDraw & Int33)
         paint.drawPoint(cx+1, cy+1);
 
 }
 
-void TerminalDisplay::drawLineCharString(	QPainter& painter, int x, int y, const QString& str, 
-									const Character* attributes)
+void TerminalDisplay::drawLineCharString(    QPainter& painter, int x, int y, const QString& str, 
+                                    const Character* attributes)
 {
-		const QPen& currentPen = painter.pen();
-		
-		if ( attributes->rendition & RE_BOLD )
-		{
-			QPen boldPen(currentPen);
-			boldPen.setWidth(3);
-			painter.setPen( boldPen );
-		}	
-		
-		for (int i=0 ; i < str.length(); i++)
-		{
-			uchar code = str[i].cell();
-        	if (LineChars[code])
-            	drawLineChar(painter, x + (_fontWidth*i), y, _fontWidth, _fontHeight, code);
-		}
-
-		painter.setPen( currentPen );
+        const QPen& currentPen = painter.pen();
+        
+        if ( (attributes->rendition & RE_BOLD) && _boldIntense )
+        {
+            QPen boldPen(currentPen);
+            boldPen.setWidth(3);
+            painter.setPen( boldPen );
+        }    
+        
+        for (int i=0 ; i < str.length(); i++)
+        {
+            uchar code = str[i].cell();
+            if (LineChars[code])
+                drawLineChar(painter, x + (_fontWidth*i), y, _fontWidth, _fontHeight, code);
+        }
+
+        painter.setPen( currentPen );
 }
 
 void TerminalDisplay::setKeyboardCursorShape(KeyboardCursorShape shape)
 {
     _cursorShape = shape;
 }
 TerminalDisplay::KeyboardCursorShape TerminalDisplay::keyboardCursorShape() const
 {
@@ -504,24 +560,24 @@ QColor TerminalDisplay::keyboardCursorCo
 
 void TerminalDisplay::setOpacity(qreal opacity)
 {
     QColor color(_blendColor);
     color.setAlphaF(opacity);
 
     // enable automatic background filling to prevent the display
     // flickering if there is no transparency
-    if ( color.alpha() == 255 ) 
+    /*if ( color.alpha() == 255 ) 
     {
         setAutoFillBackground(true);
     }
     else
     {
         setAutoFillBackground(false);
-    }
+    }*/
 
     _blendColor = color.rgba();
 }
 
 void TerminalDisplay::drawBackground(QPainter& painter, const QRect& rect, const QColor& backgroundColor, bool useOpacitySetting )
 {
         // the area of the widget showing the contents of the terminal display is drawn
         // using the background color from the color scheme set with setColorTable()
@@ -542,19 +598,18 @@ void TerminalDisplay::drawBackground(QPa
             QColor color(backgroundColor);
             color.setAlpha(qAlpha(_blendColor));
 
             painter.save();
             painter.setCompositionMode(QPainter::CompositionMode_Source);
             painter.fillRect(contentsRect, color);
             painter.restore();
         } 
-        else {
-	    painter.fillRect(contentsRect, backgroundColor);
-	}
+        else
+            painter.fillRect(contentsRect, backgroundColor);
 
         painter.fillRect(scrollBarArea,_scrollBar->palette().background());
 }
 
 void TerminalDisplay::drawCursor(QPainter& painter, 
                                  const QRect& rect,
                                  const QColor& foregroundColor,
                                  const QColor& /*backgroundColor*/,
@@ -562,34 +617,33 @@ void TerminalDisplay::drawCursor(QPainte
 {
     QRect cursorRect = rect;
     cursorRect.setHeight(_fontHeight - _lineSpacing - 1);
     
     if (!_cursorBlinking)
     {
        if ( _cursorColor.isValid() )
            painter.setPen(_cursorColor);
-       else {
-    	    painter.setPen(foregroundColor);
-	}
+       else
+           painter.setPen(foregroundColor);
 
        if ( _cursorShape == BlockCursor )
        {
             // draw the cursor outline, adjusting the area so that
             // it is draw entirely inside 'rect'
             int penWidth = qMax(1,painter.pen().width());
 
             painter.drawRect(cursorRect.adjusted(penWidth/2,
                                                  penWidth/2,
                                                  - penWidth/2 - penWidth%2,
                                                  - penWidth/2 - penWidth%2));
             if ( hasFocus() )
             {
                 painter.fillRect(cursorRect, _cursorColor.isValid() ? _cursorColor : foregroundColor);
-	    
+            
                 if ( !_cursorColor.isValid() )
                 {
                     // invert the colour used to draw the text to ensure that the character at
                     // the cursor position is readable
                     invertCharacterColor = true;
                 }
             }
        }
@@ -613,119 +667,169 @@ void TerminalDisplay::drawCharacters(QPa
                                      const Character* style,
                                      bool invertCharacterColor)
 {
     // don't draw text which is currently blinking
     if ( _blinking && (style->rendition & RE_BLINK) )
             return;
    
     // setup bold and underline
-    bool useBold = style->rendition & RE_BOLD || style->isBold(_colorTable) || font().bold();
+    bool useBold;
+    ColorEntry::FontWeight weight = style->fontWeight(_colorTable);    
+    if (weight == ColorEntry::UseCurrentFormat)
+        useBold = ((style->rendition & RE_BOLD) && _boldIntense) || font().bold();
+    else
+        useBold = (weight == ColorEntry::Bold) ? true : false;
     bool useUnderline = style->rendition & RE_UNDERLINE || font().underline();
 
     QFont font = painter.font();
     if (    font.bold() != useBold 
          || font.underline() != useUnderline )
     {
        font.setBold(useBold);
        font.setUnderline(useUnderline);
        painter.setFont(font);
     }
 
+    // setup pen
     const CharacterColor& textColor = ( invertCharacterColor ? style->backgroundColor : style->foregroundColor );
     const QColor color = textColor.color(_colorTable);
-
     QPen pen = painter.pen();
     if ( pen.color() != color )
     {
         pen.setColor(color);
         painter.setPen(color);
     }
+
     // draw text
-    if ( isLineCharString(text) ) {
-	  	drawLineCharString(painter,rect.x(),rect.y(),text,style);
-    }
+    if ( isLineCharString(text) )
+        drawLineCharString(painter,rect.x(),rect.y(),text,style);
     else
-	{
-		// the drawText(rect,flags,string) overload is used here with null flags
-		// instead of drawText(rect,string) because the (rect,string) overload causes 
-		// the application's default layout direction to be used instead of 
-		// the widget-specific layout direction, which should always be
-		// Qt::LeftToRight for this widget
-        painter.drawText(rect,0,text);
-	}
+    {
+        // the drawText(rect,flags,string) overload is used here with null flags
+        // instead of drawText(rect,string) because the (rect,string) overload causes 
+        // the application's default layout direction to be used instead of 
+        // the widget-specific layout direction, which should always be
+        // Qt::LeftToRight for this widget
+    // This was discussed in: http://lists.kde.org/?t=120552223600002&r=1&w=2
+        if (_bidiEnabled)
+            painter.drawText(rect,0,text);
+        else
+            painter.drawText(rect,0,LTR_OVERRIDE_CHAR+text);
+    }
 }
 
 void TerminalDisplay::drawTextFragment(QPainter& painter , 
                                        const QRect& rect,
                                        const QString& text, 
                                        const Character* style)
 {
     painter.save();
 
     // setup painter 
     const QColor foregroundColor = style->foregroundColor.color(_colorTable);
     const QColor backgroundColor = style->backgroundColor.color(_colorTable);
     
     // draw background if different from the display's background color
     if ( backgroundColor != palette().background().color() )
-        drawBackground(painter,rect,backgroundColor, false /* do not use transparency */);
+        drawBackground(painter,rect,backgroundColor,
+                       false /* do not use transparency */);
 
     // draw cursor shape if the current character is the cursor
     // this may alter the foreground and background colors
     bool invertCharacterColor = false;
-
     if ( style->rendition & RE_CURSOR )
         drawCursor(painter,rect,foregroundColor,backgroundColor,invertCharacterColor);
+
     // draw text
     drawCharacters(painter,rect,text,style,invertCharacterColor);
 
     painter.restore();
 }
 
 void TerminalDisplay::setRandomSeed(uint randomSeed) { _randomSeed = randomSeed; }
 uint TerminalDisplay::randomSeed() const { return _randomSeed; }
 
+#if 0
+/*!
+    Set XIM Position
+*/
+void TerminalDisplay::setCursorPos(const int curx, const int cury)
+{
+    QPoint tL  = contentsRect().topLeft();
+    int    tLx = tL.x();
+    int    tLy = tL.y();
+
+    int xpos, ypos;
+    ypos = _topMargin + tLy + _fontHeight*(cury-1) + _fontAscent;
+    xpos = _leftMargin + tLx + _fontWidth*curx;
+    //setMicroFocusHint(xpos, ypos, 0, _fontHeight); //### ???
+    // fprintf(stderr, "x/y = %d/%d\txpos/ypos = %d/%d\n", curx, cury, xpos, ypos);
+    _cursorLine = cury;
+    _cursorCol = curx;
+}
+#endif
+
 // scrolls the image by 'lines', down if lines > 0 or up otherwise.
 //
 // the terminal emulation keeps track of the scrolling of the character 
 // image as it receives input, and when the view is updated, it calls scrollImage() 
 // with the final scroll amount.  this improves performance because scrolling the 
 // display is much cheaper than re-rendering all the text for the 
 // part of the image which has moved up or down.  
 // Instead only new lines have to be drawn
-//
-// note:  it is important that the area of the display which is 
-// scrolled aligns properly with the character grid - 
-// which has a top left point at (_leftMargin,_topMargin) , 
-// a cell width of _fontWidth and a cell height of _fontHeight).    
 void TerminalDisplay::scrollImage(int lines , const QRect& screenWindowRegion)
 {
-	// if the flow control warning is enabled this will interfere with the 
-	// scrolling optimisations and cause artifacts.  the simple solution here
-	// is to just disable the optimisation whilst it is visible
-	if ( _outputSuspendedLabel && _outputSuspendedLabel->isVisible() ) {
-		return;
-	}
+    // if the flow control warning is enabled this will interfere with the 
+    // scrolling optimizations and cause artifacts.  the simple solution here
+    // is to just disable the optimization whilst it is visible
+    if ( _outputSuspendedLabel && _outputSuspendedLabel->isVisible() )
+        return;
 
     // constrain the region to the display
     // the bottom of the region is capped to the number of lines in the display's
     // internal image - 2, so that the height of 'region' is strictly less
     // than the height of the internal image.
     QRect region = screenWindowRegion;
     region.setBottom( qMin(region.bottom(),this->_lines-2) ); 
 
+    // return if there is nothing to do
     if (    lines == 0 
          || _image == 0
          || !region.isValid() 
          || (region.top() + abs(lines)) >= region.bottom() 
          || this->_lines <= region.height() ) return;
 
+    // hide terminal size label to prevent it being scrolled
+    if (_resizeWidget && _resizeWidget->isVisible())
+        _resizeWidget->hide();
+
+    // Note:  With Qt 4.4 the left edge of the scrolled area must be at 0
+    // to get the correct (newly exposed) part of the widget repainted.
+    //
+    // The right edge must be before the left edge of the scroll bar to 
+    // avoid triggering a repaint of the entire widget, the distance is 
+    // given by SCROLLBAR_CONTENT_GAP
+    //
+    // Set the QT_FLUSH_PAINT environment variable to '1' before starting the
+    // application to monitor repainting.
+    //
+    int scrollBarWidth = _scrollBar->isHidden() ? 0 : _scrollBar->width();
+    const int SCROLLBAR_CONTENT_GAP = 1;
     QRect scrollRect;
-
+    if ( _scrollbarLocation == ScrollBarLeft )
+    {
+        scrollRect.setLeft(scrollBarWidth+SCROLLBAR_CONTENT_GAP);
+        scrollRect.setRight(width());
+    }
+    else
+    {
+        scrollRect.setLeft(0);
+        scrollRect.setRight(width() - scrollBarWidth - SCROLLBAR_CONTENT_GAP);
+    }
     void* firstCharPos = &_image[ region.top() * this->_columns ];
     void* lastCharPos = &_image[ (region.top() + abs(lines)) * this->_columns ];
 
     int top = _topMargin + (region.top() * _fontHeight);
     int linesToMove = region.height() - abs(lines);
     int bytesToMove = linesToMove * 
                       this->_columns *
                       sizeof(Character);
@@ -740,111 +844,127 @@ void TerminalDisplay::scrollImage(int li
         Q_ASSERT( (char*)lastCharPos + bytesToMove < 
                   (char*)(_image + (this->_lines * this->_columns)) );
         
         Q_ASSERT( (lines*this->_columns) < _imageSize ); 
 
         //scroll internal image down
         memmove( firstCharPos , lastCharPos , bytesToMove ); 
       
-        //set region of display to scroll, making sure that
-        //the region aligns correctly to the character grid 
-        scrollRect = QRect( _leftMargin , top, 
-                            this->_usedColumns * _fontWidth , 
-                            linesToMove * _fontHeight );
+        //set region of display to scroll
+        scrollRect.setTop(top);
     }
     else
     {
         // check that the memory areas that we are going to move are valid
         Q_ASSERT( (char*)firstCharPos + bytesToMove < 
                   (char*)(_image + (this->_lines * this->_columns)) );
 
         //scroll internal image up
         memmove( lastCharPos , firstCharPos , bytesToMove ); 
      
-        //set region of the display to scroll, making sure that
-        //the region aligns correctly to the character grid
-        QPoint topPoint( _leftMargin , top + abs(lines)*_fontHeight );
-
-        scrollRect = QRect( topPoint ,
-                     QSize( this->_usedColumns*_fontWidth , 
-                            linesToMove * _fontHeight ));
+        //set region of the display to scroll
+        scrollRect.setTop(top + abs(lines) * _fontHeight); 
     }
+    scrollRect.setHeight(linesToMove * _fontHeight );
+
+    Q_ASSERT(scrollRect.isValid() && !scrollRect.isEmpty());
 
     //scroll the display vertically to match internal _image
     scroll( 0 , _fontHeight * (-lines) , scrollRect );
 }
 
 QRegion TerminalDisplay::hotSpotRegion() const 
 {
-	QRegion region;
-	foreach( Filter::HotSpot* hotSpot , _filterChain->hotSpots() )
-	{
-		QRect rect;
-		rect.setLeft(hotSpot->startColumn());
-		rect.setTop(hotSpot->startLine());
-		rect.setRight(hotSpot->endColumn());
-		rect.setBottom(hotSpot->endLine());
-
-		region |= imageToWidget(rect); 
-	}
-	return region;
+    QRegion region;
+    foreach( Filter::HotSpot* hotSpot , _filterChain->hotSpots() )
+    {
+        QRect r;
+        if (hotSpot->startLine()==hotSpot->endLine()) {
+            r.setLeft(hotSpot->startColumn());
+            r.setTop(hotSpot->startLine());
+            r.setRight(hotSpot->endColumn());
+            r.setBottom(hotSpot->endLine());
+            region |= imageToWidget(r);;
+        } else {
+            r.setLeft(hotSpot->startColumn());
+            r.setTop(hotSpot->startLine());
+            r.setRight(_columns);
+            r.setBottom(hotSpot->startLine());
+            region |= imageToWidget(r);;
+            for ( int line = hotSpot->startLine()+1 ; line < hotSpot->endLine() ; line++ ) {
+                r.setLeft(0);
+                r.setTop(line);
+                r.setRight(_columns);
+                r.setBottom(line);
+                region |= imageToWidget(r);;
+            }
+            r.setLeft(0);
+            r.setTop(hotSpot->endLine());
+            r.setRight(hotSpot->endColumn());
+            r.setBottom(hotSpot->endLine());
+            region |= imageToWidget(r);;
+        }
+    }
+    return region;
 }
 
 void TerminalDisplay::processFilters() 
 {
-	if (!_screenWindow)
-		return;
-
-	QRegion preUpdateHotSpots = hotSpotRegion();
-
-	// use _screenWindow->getImage() here rather than _image because
-	// other classes may call processFilters() when this display's
-	// ScreenWindow emits a scrolled() signal - which will happen before
-	// updateImage() is called on the display and therefore _image is 
-	// out of date at this point
-	_filterChain->setImage( _screenWindow->getImage(),
-							_screenWindow->windowLines(),
-							_screenWindow->windowColumns(),
-							_screenWindow->getLineProperties() );
+    if (!_screenWindow)
+        return;
+
+    QRegion preUpdateHotSpots = hotSpotRegion();
+
+    // use _screenWindow->getImage() here rather than _image because
+    // other classes may call processFilters() when this display's
+    // ScreenWindow emits a scrolled() signal - which will happen before
+    // updateImage() is called on the display and therefore _image is 
+    // out of date at this point
+    _filterChain->setImage( _screenWindow->getImage(),
+                            _screenWindow->windowLines(),
+                            _screenWindow->windowColumns(),
+                            _screenWindow->getLineProperties() );
     _filterChain->process();
 
-	QRegion postUpdateHotSpots = hotSpotRegion();
-
-	update( preUpdateHotSpots | postUpdateHotSpots );
+    QRegion postUpdateHotSpots = hotSpotRegion();
+
+    update( preUpdateHotSpots | postUpdateHotSpots );
 }
 
 void TerminalDisplay::updateImage() 
 {
   if ( !_screenWindow )
       return;
 
   // optimization - scroll the existing image where possible and 
   // avoid expensive text drawing for parts of the image that 
   // can simply be moved up or down
   scrollImage( _screenWindow->scrollCount() ,
                _screenWindow->scrollRegion() );
   _screenWindow->resetScrollCount();
 
+  if (!_image) {
+     // Create _image.
+     // The emitted changedContentSizeSignal also leads to getImage being recreated, so do this first.
+     updateImageSize();
+  }
+
   Character* const newimg = _screenWindow->getImage();
   int lines = _screenWindow->windowLines();
   int columns = _screenWindow->windowColumns();
 
   setScroll( _screenWindow->currentLine() , _screenWindow->lineCount() );
 
-  if (!_image)
-     updateImageSize(); // Create _image
-
   Q_ASSERT( this->_usedLines <= this->_lines );
   Q_ASSERT( this->_usedColumns <= this->_columns );
 
   int y,x,len;
 
   QPoint tL  = contentsRect().topLeft();
-
   int    tLx = tL.x();
   int    tLy = tL.y();
   _hasBlinker = false;
 
   CharacterColor cf;       // undefined
   CharacterColor _clipboard;       // undefined
   int cr  = -1;   // undefined
 
@@ -855,38 +975,38 @@ void TerminalDisplay::updateImage()
   char *dirtyMask = new char[columnsToUpdate+2]; 
   QRegion dirtyRegion;
 
   // debugging variable, this records the number of lines that are found to
   // be 'dirty' ( ie. have changed from the old _image to the new _image ) and
   // which therefore need to be repainted
   int dirtyLineCount = 0;
 
-  for (y = 0; y < linesToUpdate; y++)
+  for (y = 0; y < linesToUpdate; ++y)
   {
     const Character*       currentLine = &_image[y*this->_columns];
     const Character* const newLine = &newimg[y*columns];
 
     bool updateLine = false;
     
     // The dirty mask indicates which characters need repainting. We also
     // mark surrounding neighbours dirty, in case the character exceeds
     // its cell boundaries
     memset(dirtyMask, 0, columnsToUpdate+2);
    
-    for( x = 0 ; x < columnsToUpdate ; x++)
+    for( x = 0 ; x < columnsToUpdate ; ++x)
     {
         if ( newLine[x] != currentLine[x] ) 
         {
             dirtyMask[x] = true;
         }
     }
 
     if (!_resizing) // not while _resizing, we're expecting a paintEvent
-    for (x = 0; x < columnsToUpdate; x++)
+    for (x = 0; x < columnsToUpdate; ++x)
     {
       _hasBlinker |= (newLine[x].rendition & RE_BLINK);
     
       // Start drawing if this character or the next one differs.
       // We also take the next one into account to handle the situation
       // where characters exceed their cell width.
       if (dirtyMask[x])
       {
@@ -896,24 +1016,24 @@ void TerminalDisplay::updateImage()
         int p = 0;
         disstrU[p++] = c; //fontMap(c);
         bool lineDraw = isLineChar(c);
         bool doubleWidth = (x+1 == columnsToUpdate) ? false : (newLine[x+1].character == 0);
         cr = newLine[x].rendition;
         _clipboard = newLine[x].backgroundColor;
         if (newLine[x].foregroundColor != cf) cf = newLine[x].foregroundColor;
         int lln = columnsToUpdate - x;
-        for (len = 1; len < lln; len++)
+        for (len = 1; len < lln; ++len)
         {
             const Character& ch = newLine[x+len];
 
             if (!ch.character)
                 continue; // Skip trailing part of multi-col chars.
 
-			bool nextIsDoubleWidth = (x+len+1 == columnsToUpdate) ? false : (newLine[x+len+1].character == 0);
+            bool nextIsDoubleWidth = (x+len+1 == columnsToUpdate) ? false : (newLine[x+len+1].character == 0);
 
             if (  ch.foregroundColor != cf || 
                   ch.backgroundColor != _clipboard || 
                   ch.rendition != cr ||
                   !dirtyMask[x+len] || 
                   isLineChar(c) != lineDraw || 
                   nextIsDoubleWidth != doubleWidth )
             break;
@@ -924,43 +1044,43 @@ void TerminalDisplay::updateImage()
         QString unistr(disstrU, p);
 
         bool saveFixedFont = _fixedFont;
         if (lineDraw)
            _fixedFont = false;
         if (doubleWidth)
            _fixedFont = false;
 
-		updateLine = true;
-
-		_fixedFont = saveFixedFont;
+        updateLine = true;
+
+        _fixedFont = saveFixedFont;
         x += len - 1;
       }
       
     }
 
-	//both the top and bottom halves of double height _lines must always be redrawn
-	//although both top and bottom halves contain the same characters, only 
+    //both the top and bottom halves of double height _lines must always be redrawn
+    //although both top and bottom halves contain the same characters, only 
     //the top one is actually 
-	//drawn.
+    //drawn.
     if (_lineProperties.count() > y)
         updateLine |= (_lineProperties[y] & LINE_DOUBLEHEIGHT);
 
     // if the characters on the line are different in the old and the new _image
     // then this line must be repainted.    
     if (updateLine)
     {
         dirtyLineCount++;
 
         // add the area occupied by this line to the region which needs to be
         // repainted
         QRect dirtyRect = QRect( _leftMargin+tLx , 
                                  _topMargin+tLy+_fontHeight*y , 
                                  _fontWidth * columnsToUpdate , 
-                                 _fontHeight ); 	
+                                 _fontHeight );     
 
         dirtyRegion |= dirtyRect;
     }
 
     // replace the line of characters in the old _image with the 
     // current line of the new _image 
     memcpy((void*)currentLine,(const void*)newLine,columnsToUpdate*sizeof(Character));
   }
@@ -985,96 +1105,130 @@ void TerminalDisplay::updateImage()
   }
   _usedColumns = columnsToUpdate;
 
   dirtyRegion |= _inputMethodData.previousPreeditRect;
 
   // update the parts of the display which have changed
   update(dirtyRegion);
 
-  if ( _hasBlinker && !_blinkTimer->isActive()) _blinkTimer->start( BLINK_DELAY ); 
+  if ( _hasBlinker && !_blinkTimer->isActive()) _blinkTimer->start( TEXT_BLINK_DELAY ); 
   if (!_hasBlinker && _blinkTimer->isActive()) { _blinkTimer->stop(); _blinking = false; }
   delete[] dirtyMask;
   delete[] disstrU;
 
 }
 
 void TerminalDisplay::showResizeNotification()
 {
   if (_terminalSizeHint && isVisible())
   {
      if (_terminalSizeStartup) {
-       		_terminalSizeStartup=false;
+               _terminalSizeStartup=false;
        return;
      }
      if (!_resizeWidget)
      {
-        _resizeWidget = new QLabel(("Size: XXX x XXX"), this);
-        _resizeWidget->setMinimumWidth(_resizeWidget->fontMetrics().width(("Size: XXX x XXX")));
+        _resizeWidget = new QLabel(i18n("Size: XXX x XXX"), this);
+        _resizeWidget->setMinimumWidth(_resizeWidget->fontMetrics().width(i18n("Size: XXX x XXX")));
         _resizeWidget->setMinimumHeight(_resizeWidget->sizeHint().height());
-		_resizeWidget->setAlignment(Qt::AlignCenter);
+        _resizeWidget->setAlignment(Qt::AlignCenter);
 
         _resizeWidget->setStyleSheet("background-color:palette(window);border-style:solid;border-width:1px;border-color:palette(dark)");
 
-		_resizeTimer = new QTimer(this);
-		_resizeTimer->setSingleShot(true);
+        _resizeTimer = new QTimer(this);
+        _resizeTimer->setSingleShot(true);
         connect(_resizeTimer, SIGNAL(timeout()), _resizeWidget, SLOT(hide()));
-
      }
-     QString sizeStr;
-     sizeStr.sprintf("Size: %d x %d", _columns, _lines);
+     QString sizeStr = i18n("Size: %1 x %2", _columns, _lines);
      _resizeWidget->setText(sizeStr);
      _resizeWidget->move((width()-_resizeWidget->width())/2,
                          (height()-_resizeWidget->height())/2+20);
      _resizeWidget->show();
      _resizeTimer->start(1000);
   }
 }
 
 void TerminalDisplay::setBlinkingCursor(bool blink)
 {
   _hasBlinkingCursor=blink;
   
   if (blink && !_blinkCursorTimer->isActive()) 
-      _blinkCursorTimer->start(BLINK_DELAY);
+      _blinkCursorTimer->start(QApplication::cursorFlashTime() / 2);
   
   if (!blink && _blinkCursorTimer->isActive()) 
   {
     _blinkCursorTimer->stop();
     if (_cursorBlinking)
       blinkCursorEvent();
     else
       _cursorBlinking = false;
   }
 }
 
+void TerminalDisplay::setBlinkingTextEnabled(bool blink)
+{
+    _allowBlinkingText = blink;
+
+    if (blink && !_blinkTimer->isActive()) 
+        _blinkTimer->start(TEXT_BLINK_DELAY);
+  
+    if (!blink && _blinkTimer->isActive()) 
+    {
+        _blinkTimer->stop();
+        _blinking = false;
+    }
+}
+
+void TerminalDisplay::focusOutEvent(QFocusEvent*)
+{
+    // trigger a repaint of the cursor so that it is both visible (in case
+    // it was hidden during blinking)
+    // and drawn in a focused out state
+    _cursorBlinking = false;
+    updateCursor();
+
+    _blinkCursorTimer->stop();
+    if (_blinking)
+        blinkEvent();
+
+    _blinkTimer->stop();
+}
+void TerminalDisplay::focusInEvent(QFocusEvent*)
+{
+    if (_hasBlinkingCursor)
+    {
+        _blinkCursorTimer->start();
+    }
+    updateCursor();
+
+    if (_hasBlinker)
+        _blinkTimer->start();
+}
+
 void TerminalDisplay::paintEvent( QPaintEvent* pe )
 {
-//qDebug("%s %d paintEvent", __FILE__, __LINE__);
   QPainter paint(this);
 
-  foreach (QRect rect, (pe->region() & contentsRect()).rects())
+  foreach (const QRect &rect, (pe->region() & contentsRect()).rects())
   {
-    drawBackground(paint,rect,palette().background().color(),	true /* use opacity setting */);
-    drawContents(paint, rect);    
+    drawBackground(paint,rect,palette().background().color(),
+                    true /* use opacity setting */);
+    drawContents(paint, rect);
   }
-//    drawBackground(paint,contentsRect(),palette().background().color(),	true /* use opacity setting */);
-//    drawContents(paint, contentsRect());    
   drawInputMethodPreeditString(paint,preeditRect());
   paintFilters(paint);
-
-  paint.end();
 }
 
 QPoint TerminalDisplay::cursorPosition() const
 {
-	if (_screenWindow)
-		return _screenWindow->cursorPosition();
-	else
-		return QPoint(0,0);
+    if (_screenWindow)
+        return _screenWindow->cursorPosition();
+    else
+        return QPoint(0,0);
 }
 
 QRect TerminalDisplay::preeditRect() const
 {
     const int preeditLength = string_width(_inputMethodData.preeditString);
 
     if ( preeditLength == 0 )
         return QRect();
@@ -1082,19 +1236,19 @@ QRect TerminalDisplay::preeditRect() con
     return QRect(_leftMargin + _fontWidth*cursorPosition().x(),
                  _topMargin + _fontHeight*cursorPosition().y(),
                  _fontWidth*preeditLength,
                  _fontHeight);
 }   
 
 void TerminalDisplay::drawInputMethodPreeditString(QPainter& painter , const QRect& rect)
 {
-    if ( _inputMethodData.preeditString.isEmpty() ) {
+    if ( _inputMethodData.preeditString.isEmpty() )
         return;
-    }
+
     const QPoint cursorPos = cursorPosition(); 
 
     bool invertColors = false;
     const QColor background = _colorTable[DEFAULT_BACK_COLOR].color;
     const QColor foreground = _colorTable[DEFAULT_FORE_COLOR].color;
     const Character* style = &_image[loc(cursorPos.x(),cursorPos.y())];
 
     drawBackground(painter,rect,background,true);
@@ -1106,37 +1260,67 @@ void TerminalDisplay::drawInputMethodPre
 
 FilterChain* TerminalDisplay::filterChain() const
 {
     return _filterChain;
 }
 
 void TerminalDisplay::paintFilters(QPainter& painter)
 {
-//qDebug("%s %d paintFilters", __FILE__, __LINE__);
-
     // get color of character under mouse and use it to draw
     // lines for filters
     QPoint cursorPos = mapFromGlobal(QCursor::pos());
     int cursorLine;
     int cursorColumn;
+    int scrollBarWidth = (_scrollbarLocation == ScrollBarLeft) ? _scrollBar->width() : 0;
+
     getCharacterPosition( cursorPos , cursorLine , cursorColumn );
     Character cursorCharacter = _image[loc(cursorColumn,cursorLine)];
 
     painter.setPen( QPen(cursorCharacter.foregroundColor.color(colorTable())) );
 
     // iterate over hotspots identified by the display's currently active filters 
     // and draw appropriate visuals to indicate the presence of the hotspot
 
     QList<Filter::HotSpot*> spots = _filterChain->hotSpots();
     QListIterator<Filter::HotSpot*> iter(spots);
     while (iter.hasNext())
     {
         Filter::HotSpot* spot = iter.next();
 
+        QRegion region;
+        if ( spot->type() == Filter::HotSpot::Link ) {
+            QRect r;
+            if (spot->startLine()==spot->endLine()) {
+                r.setCoords( spot->startColumn()*_fontWidth + 1 + scrollBarWidth, 
+                             spot->startLine()*_fontHeight + 1,
+                             (spot->endColumn()-1)*_fontWidth - 1 + scrollBarWidth, 
+                             (spot->endLine()+1)*_fontHeight - 1 ); 
+                region |= r;
+            } else {
+                r.setCoords( spot->startColumn()*_fontWidth + 1 + scrollBarWidth, 
+                             spot->startLine()*_fontHeight + 1,
+                             (_columns-1)*_fontWidth - 1 + scrollBarWidth, 
+                             (spot->startLine()+1)*_fontHeight - 1 ); 
+                region |= r;
+                for ( int line = spot->startLine()+1 ; line < spot->endLine() ; line++ ) {
+                    r.setCoords( 0*_fontWidth + 1 + scrollBarWidth, 
+                                 line*_fontHeight + 1,
+                                 (_columns-1)*_fontWidth - 1 + scrollBarWidth,
+                                 (line+1)*_fontHeight - 1 ); 
+                    region |= r;
+                }
+                r.setCoords( 0*_fontWidth + 1 + scrollBarWidth,
+                             spot->endLine()*_fontHeight + 1,
+                             (spot->endColumn()-1)*_fontWidth - 1 + scrollBarWidth,
+                             (spot->endLine()+1)*_fontHeight - 1 ); 
+                region |= r;
+            }
+        }
+
         for ( int line = spot->startLine() ; line <= spot->endLine() ; line++ )
         {
             int startColumn = 0;
             int endColumn = _columns-1; // TODO use number of _columns which are actually 
                                         // occupied on this line rather than the width of the 
                                         // display in _columns
 
             // ignore whitespace at the end of the lines
@@ -1157,74 +1341,74 @@ void TerminalDisplay::paintFilters(QPain
             // we do not overdraw adjacent
             // hotspots
             //
             // subtracting one pixel from all sides also prevents an edge case where
             // moving the mouse outside a link could still leave it underlined 
             // because the check below for the position of the cursor
             // finds it on the border of the target area
             QRect r;
-            r.setCoords( startColumn*_fontWidth + 1, line*_fontHeight + 1,
-                             endColumn*_fontWidth - 1, (line+1)*_fontHeight - 1 ); 
-                                                                           
+            r.setCoords( startColumn*_fontWidth + 1 + scrollBarWidth,
+                         line*_fontHeight + 1,
+                         endColumn*_fontWidth - 1 + scrollBarWidth,
+                         (line+1)*_fontHeight - 1 ); 
             // Underline link hotspots 
             if ( spot->type() == Filter::HotSpot::Link )
             {
                 QFontMetrics metrics(font());
         
                 // find the baseline (which is the invisible line that the characters in the font sit on,
                 // with some having tails dangling below)
                 int baseline = r.bottom() - metrics.descent();
                 // find the position of the underline below that
                 int underlinePos = baseline + metrics.underlinePos();
-
-                if ( r.contains( mapFromGlobal(QCursor::pos()) ) )
+                if ( region.contains( mapFromGlobal(QCursor::pos()) ) ){
                     painter.drawLine( r.left() , underlinePos , 
                                       r.right() , underlinePos );
+                }
             }
             // Marker hotspots simply have a transparent rectanglular shape
             // drawn on top of them
             else if ( spot->type() == Filter::HotSpot::Marker )
             {
             //TODO - Do not use a hardcoded colour for this
                 painter.fillRect(r,QBrush(QColor(255,0,0,120)));
             }
         }
     }
 }
 void TerminalDisplay::drawContents(QPainter &paint, const QRect &rect)
 {
-//qDebug("%s %d drawContents and rect x=%d y=%d w=%d h=%d", __FILE__, __LINE__, rect.x(), rect.y(),rect.width(),rect.height());
-
   QPoint tL  = contentsRect().topLeft();
-//  int    tLx = tL.x();
+  int    tLx = tL.x();
   int    tLy = tL.y();
 
-  int tLx = (_contentWidth - _usedColumns * _fontWidth)/2;
-//  int tLy = (_contentHeight - _usedLines * _fontHeight)/2; 
-//qDebug("%d %d %d %d", tLx, tLy, _contentWidth, _usedColumns * _fontWidth);  
-
   int lux = qMin(_usedColumns-1, qMax(0,(rect.left()   - tLx - _leftMargin ) / _fontWidth));
-  int luy = qMin(_usedLines-1,  qMax(0, (rect.top()    - tLy - _topMargin  ) / _fontHeight));
-  int rlx = qMin(_usedColumns-1, qMax(0, (rect.right()  - tLx - _leftMargin ) / _fontWidth));
-  int rly = qMin(_usedLines-1,  qMax(0, (rect.bottom() - tLy - _topMargin  ) / _fontHeight));
+  int luy = qMin(_usedLines-1,  qMax(0,(rect.top()    - tLy - _topMargin  ) / _fontHeight));
+  int rlx = qMin(_usedColumns-1, qMax(0,(rect.right()  - tLx - _leftMargin ) / _fontWidth));
+  int rly = qMin(_usedLines-1,  qMax(0,(rect.bottom() - tLy - _topMargin  ) / _fontHeight));
 
   const int bufferSize = _usedColumns;
-  QChar *disstrU = new QChar[bufferSize];
+  QString unistr;
+  unistr.reserve(bufferSize);
   for (int y = luy; y <= rly; y++)
   {
     quint16 c = _image[loc(lux,y)].character;
     int x = lux;
     if(!c && x)
       x--; // Search for start of multi-column character
     for (; x <= rlx; x++)
     {
       int len = 1;
       int p = 0;
 
+      // reset our buffer to the maximal size
+      unistr.resize(bufferSize);
+      QChar *disstrU = unistr.data();
+
       // is this a single character or a sequence of characters ?
       if ( _image[loc(x,y)].rendition & RE_EXTENDED_CHAR )
       {
         // sequence of characters
         ushort extendedCharLength = 0;
         ushort* chars = ExtendedCharTable::instance
                             .lookupExtendedChar(_image[loc(x,y)].charSequence,extendedCharLength);
         for ( int index = 0 ; index < extendedCharLength ; index++ ) 
@@ -1244,139 +1428,139 @@ void TerminalDisplay::drawContents(QPain
         }
       }
 
       bool lineDraw = isLineChar(c);
       bool doubleWidth = (_image[ qMin(loc(x,y)+1,_imageSize) ].character == 0);
       CharacterColor currentForeground = _image[loc(x,y)].foregroundColor;
       CharacterColor currentBackground = _image[loc(x,y)].backgroundColor;
       quint8 currentRendition = _image[loc(x,y)].rendition;
-	  
+      
       while (x+len <= rlx &&
              _image[loc(x+len,y)].foregroundColor == currentForeground &&
              _image[loc(x+len,y)].backgroundColor == currentBackground &&
              _image[loc(x+len,y)].rendition == currentRendition &&
              (_image[ qMin(loc(x+len,y)+1,_imageSize) ].character == 0) == doubleWidth &&
              isLineChar( c = _image[loc(x+len,y)].character) == lineDraw) // Assignment!
       {
         if (c)
           disstrU[p++] = c; //fontMap(c);
         if (doubleWidth) // assert((_image[loc(x+len,y)+1].character == 0)), see above if condition
           len++; // Skip trailing part of multi-column character
         len++;
       }
       if ((x+len < _usedColumns) && (!_image[loc(x+len,y)].character))
         len++; // Adjust for trailing part of multi-column character
 
-   	     bool save__fixedFont = _fixedFont;
+            bool save__fixedFont = _fixedFont;
          if (lineDraw)
             _fixedFont = false;
          if (doubleWidth)
             _fixedFont = false;
-         QString unistr(disstrU,p);
-		 
-		 if (y < _lineProperties.size())
-		 {
-			if (_lineProperties[y] & LINE_DOUBLEWIDTH) {
-				paint.scale(2,1);
-			}
-			
-			if (_lineProperties[y] & LINE_DOUBLEHEIGHT) {
-  		 		paint.scale(1,2);
-			}
-		 }
-
-		 //calculate the area in which the text will be drawn
-		 QRect textArea = QRect( _leftMargin+tLx+_fontWidth*x , 
-					_topMargin+tLy+_fontHeight*y , 
-					_fontWidth*len, 
-					_fontHeight);
-		
-		 //move the calculated area to take account of scaling applied to the painter.
-		 //the position of the area from the origin (0,0) is scaled 
+         unistr.resize(p);
+
+         // Create a text scaling matrix for double width and double height lines.
+         QMatrix textScale;
+
+         if (y < _lineProperties.size())
+         {
+            if (_lineProperties[y] & LINE_DOUBLEWIDTH)
+                textScale.scale(2,1);
+
+            if (_lineProperties[y] & LINE_DOUBLEHEIGHT)
+                textScale.scale(1,2);
+         }
+
+         //Apply text scaling matrix.
+         paint.setWorldMatrix(textScale, true);
+
+         //calculate the area in which the text will be drawn
+         QRect textArea = QRect( _leftMargin+tLx+_fontWidth*x , _topMargin+tLy+_fontHeight*y , _fontWidth*len , _fontHeight);
+        
+         //move the calculated area to take account of scaling applied to the painter.
+         //the position of the area from the origin (0,0) is scaled 
          //by the opposite of whatever
-		 //transformation has been applied to the painter.  this ensures that 
-		 //painting does actually start from textArea.topLeft() 
-         //(instead of textArea.topLeft() * painter-scale)	
-		 QMatrix inverted = paint.matrix().inverted();
-//		 textArea.moveTopLeft( inverted.map(textArea.topLeft()) );
-		 textArea.moveCenter( inverted.map(textArea.center()) );
-
-		 
-		 //paint text fragment
-         drawTextFragment(	paint,
-                		    textArea,
-                		    unistr, 
-					    	&_image[loc(x,y)] ); //, 
-						    //0, 
-						    //!_isPrinting );
+         //transformation has been applied to the painter.  this ensures that 
+         //painting does actually start from textArea.topLeft() 
+         //(instead of textArea.topLeft() * painter-scale)    
+         textArea.moveTopLeft( textScale.inverted().map(textArea.topLeft()) );
          
-		 _fixedFont = save__fixedFont;
+         //paint text fragment
+         drawTextFragment(    paint,
+                            textArea,
+                            unistr, 
+                            &_image[loc(x,y)] ); //, 
+                            //0, 
+                            //!_isPrinting );
+         
+         _fixedFont = save__fixedFont;
      
-		 //reset back to single-width, single-height _lines 
-		 paint.resetMatrix();
-
-		 if (y < _lineProperties.size()-1)
-		 {
-			//double-height _lines are represented by two adjacent _lines 
+         //reset back to single-width, single-height _lines 
+         paint.setWorldMatrix(textScale.inverted(), true);
+
+         if (y < _lineProperties.size()-1)
+         {
+            //double-height _lines are represented by two adjacent _lines 
             //containing the same characters
-			//both _lines will have the LINE_DOUBLEHEIGHT attribute.  
+            //both _lines will have the LINE_DOUBLEHEIGHT attribute.  
             //If the current line has the LINE_DOUBLEHEIGHT attribute, 
             //we can therefore skip the next line
-			if (_lineProperties[y] & LINE_DOUBLEHEIGHT)
-				y++;
-		 }
-		 
-	    x += len - 1;
+            if (_lineProperties[y] & LINE_DOUBLEHEIGHT)
+                y++;
+         }
+         
+        x += len - 1;
     }
   }
-  delete [] disstrU;
 }
 
 void TerminalDisplay::blinkEvent()
 {
+  if (!_allowBlinkingText) return;
+
   _blinking = !_blinking;
 
-  //TODO:  Optimise to only repaint the areas of the widget 
+  //TODO:  Optimize to only repaint the areas of the widget 
   // where there is blinking text
   // rather than repainting the whole widget.
   update();
 }
 
 QRect TerminalDisplay::imageToWidget(const QRect& imageArea) const
 {
-//qDebug("%s %d imageToWidget", __FILE__, __LINE__);
     QRect result;
     result.setLeft( _leftMargin + _fontWidth * imageArea.left() );
     result.setTop( _topMargin + _fontHeight * imageArea.top() );
     result.setWidth( _fontWidth * imageArea.width() );
     result.setHeight( _fontHeight * imageArea.height() );
 
     return result;
 }
 
+void TerminalDisplay::updateCursor()
+{
+  QRect cursorRect = imageToWidget( QRect(cursorPosition(),QSize(1,1)) ); 
+  update(cursorRect);
+}
+
 void TerminalDisplay::blinkCursorEvent()
 {
   _cursorBlinking = !_cursorBlinking;
-
-  QRect cursorRect = imageToWidget( QRect(cursorPosition(),QSize(1,1)) ); 
-
-  update(cursorRect);
+  updateCursor();
 }
 
 /* ------------------------------------------------------------------------- */
 /*                                                                           */
 /*                                  Resizing                                 */
 /*                                                                           */
 /* ------------------------------------------------------------------------- */
 
 void TerminalDisplay::resizeEvent(QResizeEvent*)
 {
   updateImageSize();
-  updateImage();
 }
 
 void TerminalDisplay::propagateSize()
 {
   if (_isFixedSize)
   {
      setSize(_columns, _lines);
      QWidget::setFixedSize(sizeHint());
@@ -1385,56 +1569,53 @@ void TerminalDisplay::propagateSize()
      return;
   }
   if (_image)
      updateImageSize();
 }
 
 void TerminalDisplay::updateImageSize()
 {
-//qDebug("%s %d updateImageSize", __FILE__, __LINE__);
   Character* oldimg = _image;
   int oldlin = _lines;
   int oldcol = _columns;
 
   makeImage();
-
   
   // copy the old image to reduce flicker
   int lines = qMin(oldlin,_lines);
   int columns = qMin(oldcol,_columns);
 
   if (oldimg)
   {
     for (int line = 0; line < lines; line++) 
     {
       memcpy((void*)&_image[_columns*line],
              (void*)&oldimg[oldcol*line],columns*sizeof(Character));
     }
     delete[] oldimg;
   }
 
   if (_screenWindow)
-  	_screenWindow->setWindowLines(_lines);
+      _screenWindow->setWindowLines(_lines);
 
   _resizing = (oldlin!=_lines) || (oldcol!=_columns);
 
   if ( _resizing )
   {
-  	showResizeNotification();
+      showResizeNotification();
     emit changedContentSizeSignal(_contentHeight, _contentWidth); // expose resizeEvent
   }
   
   _resizing = false;
 }
 
 //showEvent and hideEvent are reimplemented here so that it appears to other classes that the 
 //display has been resized when the display is hidden or shown.
 //
-//this allows  
 //TODO: Perhaps it would be better to have separate signals for show and hide instead of using
 //the same signal as the one for a content size change 
 void TerminalDisplay::showEvent(QShowEvent*)
 {
     emit changedContentSizeSignal(_contentHeight,_contentWidth);
 }
 void TerminalDisplay::hideEvent(QHideEvent*)
 {
@@ -1461,17 +1642,16 @@ void TerminalDisplay::scrollBarPositionC
   const bool atEndOfOutput = (_scrollBar->value() == _scrollBar->maximum());
   _screenWindow->setTrackOutput( atEndOfOutput );
 
   updateImage();
 }
 
 void TerminalDisplay::setScroll(int cursor, int slines)
 {
-//qDebug("%s %d setScroll", __FILE__, __LINE__);
   // update _scrollBar if the range or value has changed,
   // otherwise return
   //
   // setting the range or value of a _scrollBar will always trigger
   // a repaint, so it should be avoided if it is not necessary
   if ( _scrollBar->minimum() == 0                 &&
        _scrollBar->maximum() == (slines - _lines) &&
        _scrollBar->value()   == cursor )
@@ -1484,19 +1664,18 @@ void TerminalDisplay::setScroll(int curs
   _scrollBar->setSingleStep(1);
   _scrollBar->setPageStep(_lines);
   _scrollBar->setValue(cursor);
   connect(_scrollBar, SIGNAL(valueChanged(int)), this, SLOT(scrollBarPositionChanged(int)));
 }
 
 void TerminalDisplay::setScrollBarPosition(ScrollBarPosition position)
 {
-  if (_scrollbarLocation == position) {
-//      return; 
-  }
+  if (_scrollbarLocation == position) 
+      return; 
  
   if ( position == NoScrollBar )
      _scrollBar->hide();
   else 
      _scrollBar->show(); 
 
   _topMargin = _leftMargin = 1;
   _scrollbarLocation = position;
@@ -1569,24 +1748,19 @@ void TerminalDisplay::mousePressEvent(QM
     if ( _mouseMarks || (!_mouseMarks && (ev->modifiers() & Qt::ShiftModifier)) )
       emitSelection(true,ev->modifiers() & Qt::ControlModifier);
     else
       emit mouseSignal( 1, charColumn +1, charLine +1 +_scrollBar->value() -_scrollBar->maximum() , 0);
   }
   else if ( ev->button() == Qt::RightButton )
   {
     if (_mouseMarks || (ev->modifiers() & Qt::ShiftModifier)) 
-    {
-        emit configureRequest( this, 
-                               ev->modifiers() & (Qt::ShiftModifier|Qt::ControlModifier), 
-                               ev->pos()
-                             );
-    }
+        emit configureRequest(ev->pos());
     else
-      emit mouseSignal( 2, charColumn +1, charLine +1 +_scrollBar->value() -_scrollBar->maximum() , 0);
+        emit mouseSignal( 2, charColumn +1, charLine +1 +_scrollBar->value() -_scrollBar->maximum() , 0);
   }
 }
 
 QList<QAction*> TerminalDisplay::filterActions(const QPoint& position)
 {
   int charLine, charColumn;
   getCharacterPosition(position,charLine,charColumn);
 
@@ -1594,70 +1768,93 @@ QList<QAction*> TerminalDisplay::filterA
 
   return spot ? spot->actions() : QList<QAction*>();
 }
 
 void TerminalDisplay::mouseMoveEvent(QMouseEvent* ev)
 {
   int charLine = 0;
   int charColumn = 0;
+  int scrollBarWidth = (_scrollbarLocation == ScrollBarLeft) ? _scrollBar->width() : 0;
 
   getCharacterPosition(ev->pos(),charLine,charColumn); 
 
   // handle filters
   // change link hot-spot appearance on mouse-over
   Filter::HotSpot* spot = _filterChain->hotSpotAt(charLine,charColumn);
   if ( spot && spot->type() == Filter::HotSpot::Link)
   {
-    QRect previousHotspotArea = _mouseOverHotspotArea;
-    _mouseOverHotspotArea.setCoords( qMin(spot->startColumn() , spot->endColumn()) * _fontWidth,
-                                     spot->startLine() * _fontHeight,
-                                     qMax(spot->startColumn() , spot->endColumn()) * _fontHeight,
-                                     (spot->endLine()+1) * _fontHeight );
-
+    QRegion previousHotspotArea = _mouseOverHotspotArea;
+    _mouseOverHotspotArea = QRegion();
+    QRect r;
+    if (spot->startLine()==spot->endLine()) {
+        r.setCoords( spot->startColumn()*_fontWidth + scrollBarWidth, 
+                     spot->startLine()*_fontHeight,
+                     spot->endColumn()*_fontWidth + scrollBarWidth, 
+                     (spot->endLine()+1)*_fontHeight - 1 ); 
+        _mouseOverHotspotArea |= r;
+    } else {
+        r.setCoords( spot->startColumn()*_fontWidth + scrollBarWidth,
+                     spot->startLine()*_fontHeight,
+                     _columns*_fontWidth - 1 + scrollBarWidth,
+                     (spot->startLine()+1)*_fontHeight ); 
+        _mouseOverHotspotArea |= r;
+        for ( int line = spot->startLine()+1 ; line < spot->endLine() ; line++ ) {
+            r.setCoords( 0*_fontWidth + scrollBarWidth, 
+                         line*_fontHeight,
+                         _columns*_fontWidth + scrollBarWidth,
+                         (line+1)*_fontHeight ); 
+            _mouseOverHotspotArea |= r;
+        }
+        r.setCoords( 0*_fontWidth + scrollBarWidth, 
+                     spot->endLine()*_fontHeight,
+                     spot->endColumn()*_fontWidth + scrollBarWidth, 
+                     (spot->endLine()+1)*_fontHeight ); 
+        _mouseOverHotspotArea |= r;
+    }
     // display tooltips when mousing over links
     // TODO: Extend this to work with filter types other than links
     const QString& tooltip = spot->tooltip();
     if ( !tooltip.isEmpty() )
     {
-        QToolTip::showText( mapToGlobal(ev->pos()) , tooltip , this , _mouseOverHotspotArea );
+        QToolTip::showText( mapToGlobal(ev->pos()) , tooltip , this , _mouseOverHotspotArea.boundingRect() );
     }
 
     update( _mouseOverHotspotArea | previousHotspotArea );
   }
-  else if ( _mouseOverHotspotArea.isValid() )
+  else if ( !_mouseOverHotspotArea.isEmpty() )
   {
         update( _mouseOverHotspotArea );
         // set hotspot area to an invalid rectangle
-        _mouseOverHotspotArea = QRect();
+        _mouseOverHotspotArea = QRegion();
   }
   
   // for auto-hiding the cursor, we need mouseTracking
   if (ev->buttons() == Qt::NoButton ) return;
 
   // if the terminal is interested in mouse movements 
   // then emit a mouse movement signal, unless the shift
   // key is being held down, which overrides this.
   if (!_mouseMarks && !(ev->modifiers() & Qt::ShiftModifier))
   {
-	int button = 3;
-	if (ev->buttons() & Qt::LeftButton)
-		button = 0;
-	if (ev->buttons() & Qt::MidButton)
-		button = 1;
-	if (ev->buttons() & Qt::RightButton)
-		button = 2;
+    int button = 3;
+    if (ev->buttons() & Qt::LeftButton)
+        button = 0;
+    if (ev->buttons() & Qt::MidButton)
+        button = 1;
+    if (ev->buttons() & Qt::RightButton)
+        button = 2;
 
         
         emit mouseSignal( button, 
                         charColumn + 1,
                         charLine + 1 +_scrollBar->value() -_scrollBar->maximum(),
-			 1 );
+             1 );
       
-	return;
+    return;
   }
       
   if (dragInfo.state == diPending) 
   {
     // we had a mouse down, but haven't confirmed a drag yet
     // if the mouse has moved sufficiently, we will confirm
 
    int distance = 10; //KGlobalSettings::dndEventDelay();
@@ -1682,23 +1879,16 @@ void TerminalDisplay::mouseMoveEvent(QMo
   if (_actSel == 0) return;
 
  // don't extend selection while pasting
   if (ev->buttons() & Qt::MidButton) return;
 
   extendSelection( ev->pos() );
 }
 
-#if 0
-void TerminalDisplay::setSelectionEnd()
-{
-  extendSelection( _configureRequestPoint );
-}
-#endif
-
 void TerminalDisplay::extendSelection( const QPoint& position )
 {
   QPoint pos = position;
 
   if ( !_screenWindow )
       return;
 
   //if ( !contentsRect().contains(ev->pos()) ) return;
@@ -1706,34 +1896,38 @@ void TerminalDisplay::extendSelection( c
   int    tLx = tL.x();
   int    tLy = tL.y();
   int    scroll = _scrollBar->value();
 
   // we're in the process of moving the mouse with the left button pressed
   // the mouse cursor will kept caught within the bounds of the text in
   // this widget.
 
-  // Adjust position within text area bounds. See FIXME above.
+  int linesBeyondWidget = 0;
+
+  QRect textBounds(tLx + _leftMargin,
+                     tLy + _topMargin,
+                   _usedColumns*_fontWidth-1,
+                   _usedLines*_fontHeight-1);
+
+  // Adjust position within text area bounds.
   QPoint oldpos = pos;
-  if ( pos.x() < tLx+_leftMargin )                  
-      pos.setX( tLx+_leftMargin );
-  if ( pos.x() > tLx+_leftMargin+_usedColumns*_fontWidth-1 ) 
-      pos.setX( tLx+_leftMargin+_usedColumns*_fontWidth );
-  if ( pos.y() < tLy+_topMargin )                   
-      pos.setY( tLy+_topMargin );
-  if ( pos.y() > tLy+_topMargin+_usedLines*_fontHeight-1 )    
-      pos.setY( tLy+_topMargin+_usedLines*_fontHeight-1 );
-
-  if ( pos.y() == tLy+_topMargin+_usedLines*_fontHeight-1 )
+ 
+  pos.setX( qBound(textBounds.left(),pos.x(),textBounds.right()) );
+  pos.setY( qBound(textBounds.top(),pos.y(),textBounds.bottom()) );
+
+  if ( oldpos.y() > textBounds.bottom() ) 
   {
-    _scrollBar->setValue(_scrollBar->value()+yMouseScroll); // scrollforward
+      linesBeyondWidget = (oldpos.y()-textBounds.bottom()) / _fontHeight;
+    _scrollBar->setValue(_scrollBar->value()+linesBeyondWidget+1); // scrollforward
   }
-  if ( pos.y() == tLy+_topMargin )
+  if ( oldpos.y() < textBounds.top() )
   {
-    _scrollBar->setValue(_scrollBar->value()-yMouseScroll); // scrollback
+      linesBeyondWidget = (textBounds.top()-oldpos.y()) / _fontHeight;
+    _scrollBar->setValue(_scrollBar->value()-linesBeyondWidget-1); // history
   }
 
   int charColumn = 0;
   int charLine = 0;
   getCharacterPosition(pos,charLine,charColumn);
 
   QPoint here = QPoint(charColumn,charLine); //QPoint((pos.x()-tLx-_leftMargin+(_fontWidth/2))/_fontWidth,(pos.y()-tLy-_topMargin)/_fontHeight);
   QPoint ohere;
@@ -1742,41 +1936,41 @@ void TerminalDisplay::extendSelection( c
   QPoint _pntSelCorr = _pntSel;
   _pntSelCorr.ry() -= _scrollBar->value();
   bool swapping = false;
 
   if ( _wordSelectionMode )
   {
     // Extend to word boundaries
     int i;
-    int selClass;
+    QChar selClass;
 
     bool left_not_right = ( here.y() < _iPntSelCorr.y() ||
-	   here.y() == _iPntSelCorr.y() && here.x() < _iPntSelCorr.x() );
+       ( here.y() == _iPntSelCorr.y() && here.x() < _iPntSelCorr.x() ) );
     bool old_left_not_right = ( _pntSelCorr.y() < _iPntSelCorr.y() ||
-	   _pntSelCorr.y() == _iPntSelCorr.y() && _pntSelCorr.x() < _iPntSelCorr.x() );
+       ( _pntSelCorr.y() == _iPntSelCorr.y() && _pntSelCorr.x() < _iPntSelCorr.x() ) );
     swapping = left_not_right != old_left_not_right;
 
     // Find left (left_not_right ? from here : from start)
     QPoint left = left_not_right ? here : _iPntSelCorr;
     i = loc(left.x(),left.y());
     if (i>=0 && i<=_imageSize) {
       selClass = charClass(_image[i].character);
       while ( ((left.x()>0) || (left.y()>0 && (_lineProperties[left.y()-1] & LINE_WRAPPED) )) 
-					  && charClass(_image[i-1].character) == selClass )
+                      && charClass(_image[i-1].character) == selClass )
       { i--; if (left.x()>0) left.rx()--; else {left.rx()=_usedColumns-1; left.ry()--;} }
     }
 
     // Find left (left_not_right ? from start : from here)
     QPoint right = left_not_right ? _iPntSelCorr : here;
     i = loc(right.x(),right.y());
     if (i>=0 && i<=_imageSize) {
       selClass = charClass(_image[i].character);
       while( ((right.x()<_usedColumns-1) || (right.y()<_usedLines-1 && (_lineProperties[right.y()] & LINE_WRAPPED) )) 
-					  && charClass(_image[i+1].character) == selClass )
+                      && charClass(_image[i+1].character) == selClass )
       { i++; if (right.x()<_usedColumns-1) right.rx()++; else {right.rx()=0; right.ry()++; } }
     }
 
     // Pick which is start (ohere) and which is extension (here)
     if ( left_not_right )
     {
       here = left; ohere = right;
     }
@@ -1819,44 +2013,44 @@ void TerminalDisplay::extendSelection( c
 
     ohere.rx()++;
   }
 
   int offset = 0;
   if ( !_wordSelectionMode && !_lineSelectionMode )
   {
     int i;
-    int selClass;
+    QChar selClass;
 
     bool left_not_right = ( here.y() < _iPntSelCorr.y() ||
-	   here.y() == _iPntSelCorr.y() && here.x() < _iPntSelCorr.x() );
+       ( here.y() == _iPntSelCorr.y() && here.x() < _iPntSelCorr.x() ) );
     bool old_left_not_right = ( _pntSelCorr.y() < _iPntSelCorr.y() ||
-	   _pntSelCorr.y() == _iPntSelCorr.y() && _pntSelCorr.x() < _iPntSelCorr.x() );
+       ( _pntSelCorr.y() == _iPntSelCorr.y() && _pntSelCorr.x() < _iPntSelCorr.x() ) );
     swapping = left_not_right != old_left_not_right;
 
     // Find left (left_not_right ? from here : from start)
     QPoint left = left_not_right ? here : _iPntSelCorr;
 
     // Find left (left_not_right ? from start : from here)
     QPoint right = left_not_right ? _iPntSelCorr : here;
     if ( right.x() > 0 && !_columnSelectionMode )
     {
       i = loc(right.x(),right.y());
       if (i>=0 && i<=_imageSize) {
         selClass = charClass(_image[i-1].character);
-        if (selClass == ' ')
+       /* if (selClass == ' ')
         {
           while ( right.x() < _usedColumns-1 && charClass(_image[i+1].character) == selClass && (right.y()<_usedLines-1) && 
-						  !(_lineProperties[right.y()] & LINE_WRAPPED))
+                          !(_lineProperties[right.y()] & LINE_WRAPPED))
           { i++; right.rx()++; }
           if (right.x() < _usedColumns-1)
             right = left_not_right ? _iPntSelCorr : here;
           else
             right.rx()++;  // will be balanced later because of offset=-1;
-        }
+        }*/
       }
     }
 
     // Pick which is start (ohere) and which is extension (here)
     if ( left_not_right )
     {
       here = left; ohere = right; offset = 0;
     }
@@ -1946,17 +2140,16 @@ void TerminalDisplay::mouseReleaseEvent(
                       charColumn + 1, 
                       charLine + 1 +_scrollBar->value() -_scrollBar->maximum() , 
                       0);
   }
 }
 
 void TerminalDisplay::getCharacterPosition(const QPoint& widgetPoint,int& line,int& column) const
 {
-
     column = (widgetPoint.x() + _fontWidth/2 -contentsRect().left()-_leftMargin) / _fontWidth;
     line = (widgetPoint.y()-contentsRect().top()-_topMargin) / _fontHeight;
 
     if ( line < 0 )
         line = 0;
     if ( column < 0 )
         column = 0;
 
@@ -2009,22 +2202,22 @@ void TerminalDisplay::mouseDoubleClickEv
   QPoint endSel = pos;
   int i = loc(bgnSel.x(),bgnSel.y());
   _iPntSel = bgnSel;
   _iPntSel.ry() += _scrollBar->value();
 
   _wordSelectionMode = true;
 
   // find word boundaries...
-  int selClass = charClass(_image[i].character);
+  QChar selClass = charClass(_image[i].character);
   {
      // find the start of the word
      int x = bgnSel.x();
      while ( ((x>0) || (bgnSel.y()>0 && (_lineProperties[bgnSel.y()-1] & LINE_WRAPPED) )) 
-					 && charClass(_image[i-1].character) == selClass )
+                     && charClass(_image[i-1].character) == selClass )
      {  
        i--; 
        if (x>0) 
            x--; 
        else 
        {
            x=_usedColumns-1; 
            bgnSel.ry()--;
@@ -2033,17 +2226,17 @@ void TerminalDisplay::mouseDoubleClickEv
 
      bgnSel.setX(x);
      _screenWindow->setSelectionStart( bgnSel.x() , bgnSel.y() , false );
 
      // find the end of the word
      i = loc( endSel.x(), endSel.y() );
      x = endSel.x();
      while( ((x<_usedColumns-1) || (endSel.y()<_usedLines-1 && (_lineProperties[endSel.y()] & LINE_WRAPPED) )) 
-					 && charClass(_image[i+1].character) == selClass )
+                     && charClass(_image[i+1].character) == selClass )
      { 
          i++; 
          if (x<_usedColumns-1) 
              x++; 
          else 
          {  
              x=0; 
              endSel.ry()++; 
@@ -2070,20 +2263,49 @@ void TerminalDisplay::mouseDoubleClickEv
                      SLOT(tripleClickTimeout()));
 }
 
 void TerminalDisplay::wheelEvent( QWheelEvent* ev )
 {
   if (ev->orientation() != Qt::Vertical)
     return;
 
+  // if the terminal program is not interested mouse events
+  // then send the event to the scrollbar if the slider has room to move
+  // or otherwise send simulated up / down key presses to the terminal program
+  // for the benefit of programs such as 'less'
   if ( _mouseMarks )
-    _scrollBar->event(ev);
+  {
+    bool canScroll = _scrollBar->maximum() > 0;
+      if (canScroll)
+        _scrollBar->event(ev);
+    else
+    {
+        // assume that each Up / Down key event will cause the terminal application
+        // to scroll by one line.  
+        //
+        // to get a reasonable scrolling speed, scroll by one line for every 5 degrees
+        // of mouse wheel rotation.  Mouse wheels typically move in steps of 15 degrees,
+        // giving a scroll of 3 lines
+        int key = ev->delta() > 0 ? Qt::Key_Up : Qt::Key_Down;
+
+        // QWheelEvent::delta() gives rotation in eighths of a degree
+        int wheelDegrees = ev->delta() / 8;
+        int linesToScroll = abs(wheelDegrees) / 5;
+
+        QKeyEvent keyScrollEvent(QEvent::KeyPress,key,Qt::NoModifier);
+
+        for (int i=0;i<linesToScroll;i++)
+            emit keyPressedSignal(&keyScrollEvent);
+    }
+  }
   else
   {
+    // terminal program wants notification of mouse activity
+    
     int charLine;
     int charColumn;
     getCharacterPosition( ev->pos() , charLine , charColumn );
     
     emit mouseSignal( ev->delta() > 0 ? 4 : 5, 
                       charColumn + 1, 
                       charLine + 1 +_scrollBar->value() -_scrollBar->maximum() , 
                       0);
@@ -2113,17 +2335,17 @@ void TerminalDisplay::mouseTripleClickEv
   emit isBusySelecting(true); // Keep it steady...
 
   while (_iPntSel.y()>0 && (_lineProperties[_iPntSel.y()-1] & LINE_WRAPPED) )
     _iPntSel.ry()--;
   
   if (_tripleClickMode == SelectForwardsFromCursor) {
     // find word boundary start
     int i = loc(_iPntSel.x(),_iPntSel.y());
-    int selClass = charClass(_image[i].character);
+    QChar selClass = charClass(_image[i].character);
     int x = _iPntSel.x();
     
     while ( ((x>0) || 
              (_iPntSel.y()>0 && (_lineProperties[_iPntSel.y()-1] & LINE_WRAPPED) )
             ) 
             && charClass(_image[i-1].character) == selClass )
     {
         i--; 
@@ -2159,31 +2381,29 @@ bool TerminalDisplay::focusNextPrevChild
 {
   if (next)
     return false; // This disables changing the active part in konqueror
                   // when pressing Tab
   return QWidget::focusNextPrevChild( next );
 }
 
 
-int TerminalDisplay::charClass(quint16 ch) const
+QChar TerminalDisplay::charClass(QChar qch) const
 {
-    QChar qch=QChar(ch);
     if ( qch.isSpace() ) return ' ';
 
     if ( qch.isLetterOrNumber() || _wordCharacters.contains(qch, Qt::CaseInsensitive ) )
     return 'a';
 
-    // Everything else is weird
-    return 1;
+    return qch;
 }
 
 void TerminalDisplay::setWordCharacters(const QString& wc)
 {
-	_wordCharacters = wc;
+    _wordCharacters = wc;
 }
 
 void TerminalDisplay::setUsesMouse(bool on)
 {
   _mouseMarks = on;
   setCursor( _mouseMarks ? Qt::IBeamCursor : Qt::ArrowCursor );
 }
 bool TerminalDisplay::usesMouse() const
@@ -2206,17 +2426,17 @@ void TerminalDisplay::emitSelection(bool
 
   // Paste Clipboard by simulating keypress events
   QString text = QApplication::clipboard()->text(useXselection ? QClipboard::Selection :
                                                                  QClipboard::Clipboard);
   if(appendReturn)
     text.append("\r");
   if ( ! text.isEmpty() )
   {
-    text.replace("\n", "\r");
+    text.replace('\n', '\r');
     QKeyEvent e(QEvent::KeyPress, 0, Qt::NoModifier, text);
     emit keyPressedSignal(&e); // expose as a big fat keypress event
     
     _screenWindow->clearSelection();
   }
 }
 
 void TerminalDisplay::setSelection(const QString& t)
@@ -2225,17 +2445,18 @@ void TerminalDisplay::setSelection(const
 }
 
 void TerminalDisplay::copyClipboard()
 {
   if ( !_screenWindow )
       return;
 
   QString text = _screenWindow->selectedText(_preserveLineBreaks);
-  QApplication::clipboard()->setText(text);
+  if (!text.isEmpty())
+    QApplication::clipboard()->setText(text);
 }
 
 void TerminalDisplay::pasteClipboard()
 {
   emitSelection(false,false);
 }
 
 void TerminalDisplay::pasteSelection()
@@ -2246,93 +2467,70 @@ void TerminalDisplay::pasteSelection()
 /* ------------------------------------------------------------------------- */
 /*                                                                           */
 /*                                Keyboard                                   */
 /*                                                                           */
 /* ------------------------------------------------------------------------- */
 
 void TerminalDisplay::setFlowControlWarningEnabled( bool enable )
 {
-	_flowControlWarningEnabled = enable;
-	
-	// if the dialog is currently visible and the flow control warning has 
-	// been disabled then hide the dialog
-	if (!enable)
-		outputSuspended(false);
+    _flowControlWarningEnabled = enable;
+    
+    // if the dialog is currently visible and the flow control warning has 
+    // been disabled then hide the dialog
+    if (!enable)
+        outputSuspended(false);
 }
 
 void TerminalDisplay::keyPressEvent( QKeyEvent* event )
 {
-//qDebug("%s %d keyPressEvent and key is %d", __FILE__, __LINE__, event->key());
-
     bool emitKeyPressSignal = true;
 
-    // XonXoff flow control
-    if (event->modifiers() & Qt::ControlModifier && _flowControlWarningEnabled)
-	{
-		if ( event->key() == Qt::Key_S ) {
-		//qDebug("%s %d keyPressEvent, output suspended", __FILE__, __LINE__);
-				emit flowControlKeyPressed(true /*output suspended*/);
-		}
-		else if ( event->key() == Qt::Key_Q ) {
-		//qDebug("%s %d keyPressEvent, output enabled", __FILE__, __LINE__);
-				emit flowControlKeyPressed(false /*output enabled*/);
-		}
-	}
-
     // Keyboard-based navigation
     if ( event->modifiers() == Qt::ShiftModifier )
     {
         bool update = true;
 
         if ( event->key() == Qt::Key_PageUp )
         {
-	    //qDebug("%s %d pageup", __FILE__, __LINE__);
             _screenWindow->scrollBy( ScreenWindow::ScrollPages , -1 );
         }
         else if ( event->key() == Qt::Key_PageDown )
         {
-	    //qDebug("%s %d pagedown", __FILE__, __LINE__);
             _screenWindow->scrollBy( ScreenWindow::ScrollPages , 1 );
         }
         else if ( event->key() == Qt::Key_Up )
         {
-	    //qDebug("%s %d keyup", __FILE__, __LINE__);	
             _screenWindow->scrollBy( ScreenWindow::ScrollLines , -1 );
         }
         else if ( event->key() == Qt::Key_Down )
         {
-	    //qDebug("%s %d keydown", __FILE__, __LINE__);	
             _screenWindow->scrollBy( ScreenWindow::ScrollLines , 1 );
         }
-        else {
+        else
             update = false;
-	}
 
         if ( update )
         {
-	    //qDebug("%s %d updating", __FILE__, __LINE__);	
             _screenWindow->setTrackOutput( _screenWindow->atEndOfOutput() );
             
             updateLineProperties();
             updateImage();
 
             // do not send key press to terminal
             emitKeyPressSignal = false;
         }
     }
-    
-    _screenWindow->setTrackOutput( true );
-    
+
     _actSel=0; // Key stroke implies a screen update, so TerminalDisplay won't
               // know where the current selection is.
 
     if (_hasBlinkingCursor) 
     {
-      _blinkCursorTimer->start(BLINK_DELAY);
+      _blinkCursorTimer->start(QApplication::cursorFlashTime() / 2);
       if (_cursorBlinking)
         blinkCursorEvent();
       else
         _cursorBlinking = false;
     }
 
     if ( emitKeyPressSignal )
         emit keyPressedSignal(event);
@@ -2375,89 +2573,121 @@ QVariant TerminalDisplay::inputMethodQue
                 decoder.decodeLine(&_image[loc(0,cursorPos.y())],_usedColumns,_lineProperties[cursorPos.y()]);
                 decoder.end();
                 return lineText;
             }
             break;
         case Qt::ImCurrentSelection:
                 return QString();
             break;
+        default:
+            break;
     }
 
     return QVariant();
 }
 
-bool TerminalDisplay::event( QEvent *e )
+bool TerminalDisplay::handleShortcutOverrideEvent(QKeyEvent* keyEvent)
 {
-  if ( e->type() == QEvent::ShortcutOverride )
-  {
-    QKeyEvent* keyEvent = static_cast<QKeyEvent *>( e );
-
-    // a check to see if keyEvent->text() is empty is used
-    // to avoid intercepting the press of the modifier key on its own.
-    //
-    // this is important as it allows a press and release of the Alt key
-    // on its own to focus the menu bar, making it possible to
-    // work with the menu without using the mouse
-    if ( (keyEvent->modifiers() == Qt::AltModifier) && 
-         !keyEvent->text().isEmpty() )
+    int modifiers = keyEvent->modifiers();
+
+    //  When a possible shortcut combination is pressed, 
+    //  emit the overrideShortcutCheck() signal to allow the host
+    //  to decide whether the terminal should override it or not.
+    if (modifiers != Qt::NoModifier) 
     {
-    	keyEvent->accept();
-      	return true;
+        int modifierCount = 0;
+        unsigned int currentModifier = Qt::ShiftModifier;
+
+        while (currentModifier <= Qt::KeypadModifier)
+        {
+            if (modifiers & currentModifier)
+                modifierCount++;
+            currentModifier <<= 1;
+        }
+        if (modifierCount < 2) 
+        {
+            bool override = false;
+            emit overrideShortcutCheck(keyEvent,override);
+            if (override)
+            {
+                keyEvent->accept();
+                return true;
+            }
+        }
     }
 
     // Override any of the following shortcuts because
     // they are needed by the terminal
-    int keyCode = keyEvent->key() | keyEvent->modifiers();
+    int keyCode = keyEvent->key() | modifiers;
     switch ( keyCode )
     {
       // list is taken from the QLineEdit::event() code
       case Qt::Key_Tab:
       case Qt::Key_Delete:
       case Qt::Key_Home:
       case Qt::Key_End:
       case Qt::Key_Backspace:
       case Qt::Key_Left:
       case Qt::Key_Right:
         keyEvent->accept();
         return true;
     }
+    return false;
+}
+
+bool TerminalDisplay::event(QEvent* event)
+{
+  bool eventHandled = false;
+  switch (event->type())
+  {
+    case QEvent::ShortcutOverride:
+        eventHandled = handleShortcutOverrideEvent((QKeyEvent*)event);
+        break;
+    case QEvent::PaletteChange:
+    case QEvent::ApplicationPaletteChange:
+        _scrollBar->setPalette( QApplication::palette() );
+        break;
+    default:
+        break;
   }
-  return QWidget::event( e );
+  return eventHandled ? true : QWidget::event(event); 
 }
 
 void TerminalDisplay::setBellMode(int mode)
 {
   _bellMode=mode;
 }
 
 void TerminalDisplay::enableBell()
 {
     _allowBell = true;
 }
 
-void TerminalDisplay::bell(const QString&)
+void TerminalDisplay::bell(const QString& message)
 {
   if (_bellMode==NoBell) return;
 
   //limit the rate at which bells can occur 
   //...mainly for sound effects where rapid bells in sequence 
   //produce a horrible noise
   if ( _allowBell )
   {
     _allowBell = false;
     QTimer::singleShot(500,this,SLOT(enableBell()));
  
     if (_bellMode==SystemBeepBell) 
     {
-//        KNotification::beep();
+      // TODO: This will need added back in at some point
+      //KNotification::beep();
     } 
     else if (_bellMode==NotifyBell) 
     {
-//        KNotification::event("BellVisible", message,QPixmap(),this);
+      // TODO: This will need added back in at some point
+      //KNotification::event("BellVisible", message,QPixmap(),this);
     } 
     else if (_bellMode==VisualBell) 
     {
         swapColorTable();
         QTimer::singleShot(200,this,SLOT(swapColorTable()));
     }
   }
 }
@@ -2482,18 +2712,17 @@ void TerminalDisplay::clearImage()
     _image[i].backgroundColor = CharacterColor(COLOR_SPACE_DEFAULT,
                                                DEFAULT_BACK_COLOR);
     _image[i].rendition = DEFAULT_RENDITION;
   }
 }
 
 void TerminalDisplay::calcGeometry()
 {
-  _scrollBar->resize(QApplication::style()->pixelMetric(QStyle::PM_ScrollBarExtent),
-                    contentsRect().height());
+  _scrollBar->resize(_scrollBar->sizeHint().width(), contentsRect().height());
   switch(_scrollbarLocation)
   {
     case NoScrollBar :
      _leftMargin = DEFAULT_LEFT_MARGIN;
      _contentWidth = contentsRect().width() - 2 * DEFAULT_LEFT_MARGIN;
      break;
     case ScrollBarLeft :
      _leftMargin = DEFAULT_LEFT_MARGIN + _scrollBar->width();
@@ -2504,58 +2733,56 @@ void TerminalDisplay::calcGeometry()
      _leftMargin = DEFAULT_LEFT_MARGIN;
      _contentWidth = contentsRect().width()  - 2 * DEFAULT_LEFT_MARGIN - _scrollBar->width();
      _scrollBar->move(contentsRect().topRight() - QPoint(_scrollBar->width()-1,0));
      break;
   }
 
   _topMargin = DEFAULT_TOP_MARGIN;
   _contentHeight = contentsRect().height() - 2 * DEFAULT_TOP_MARGIN + /* mysterious */ 1;
-
+   
   if (!_isFixedSize)
   {
      // ensure that display is always at least one column wide
      _columns = qMax(1,_contentWidth / _fontWidth);
      _usedColumns = qMin(_usedColumns,_columns);
      
      // ensure that display is always at least one line high
      _lines = qMax(1,_contentHeight / _fontHeight);
      _usedLines = qMin(_usedLines,_lines);
   }
 }
 
 void TerminalDisplay::makeImage()
 {
-//qDebug("%s %d makeImage", __FILE__, __LINE__);
   calcGeometry();
 
   // confirm that array will be of non-zero size, since the painting code 
   // assumes a non-zero array length
   Q_ASSERT( _lines > 0 && _columns > 0 );
   Q_ASSERT( _usedLines <= _lines && _usedColumns <= _columns );
 
   _imageSize=_lines*_columns;
   
   // We over-commit one character so that we can be more relaxed in dealing with
   // certain boundary conditions: _image[_imageSize] is a valid but unused position
   _image = new Character[_imageSize+1];
 
   clearImage();
 }
 
-// calculate the needed size
+// calculate the needed size, this must be synced with calcGeometry()
 void TerminalDisplay::setSize(int columns, int lines)
 {
-  //FIXME - Not quite correct, a small amount of additional space
-  // will be used for margins, the scrollbar etc.
-  // we need to allow for this so that '_size' does allow
-  // enough room for the specified number of columns and lines to fit
-
-  QSize newSize = QSize( columns * _fontWidth  ,
-				 lines * _fontHeight   );
+  int scrollBarWidth = _scrollBar->isHidden() ? 0 : _scrollBar->sizeHint().width();
+  int horizontalMargin = 2 * DEFAULT_LEFT_MARGIN;
+  int verticalMargin = 2 * DEFAULT_TOP_MARGIN;
+
+  QSize newSize = QSize( horizontalMargin + scrollBarWidth + (columns * _fontWidth)  ,
+                 verticalMargin + (lines * _fontHeight)   );
 
   if ( newSize != size() )
   {
     _size = newSize;
     updateGeometry();
   }
 }
 
@@ -2593,20 +2820,21 @@ QSize TerminalDisplay::sizeHint() const
 void TerminalDisplay::dragEnterEvent(QDragEnterEvent* event)
 {
   if (event->mimeData()->hasFormat("text/plain"))
       event->acceptProposedAction();
 }
 
 void TerminalDisplay::dropEvent(QDropEvent* event)
 {
-//  KUrl::List urls = KUrl::List::fromMimeData(event->mimeData());
+  //KUrl::List urls = KUrl::List::fromMimeData(event->mimeData());
 
   QString dropText;
-/*  if (!urls.isEmpty()) 
+  /*
+  if (!urls.isEmpty()) 
   {
     for ( int i = 0 ; i < urls.count() ; i++ ) 
     {
         KUrl url = KIO::NetAccess::mostLocalUrl( urls[i] , 0 );
         QString urlText;
 
         if (url.isLocalFile())
             urlText = url.path(); 
@@ -2622,17 +2850,18 @@ void TerminalDisplay::dropEvent(QDropEve
         if ( i != urls.count()-1 ) 
             dropText += ' ';
     }
   }
   else 
   {
     dropText = event->mimeData()->text();
   }
-*/
+  */
+
   if(event->mimeData()->hasFormat("text/plain")) 
   {
     emit sendStringToEmu(dropText.toLocal8Bit());
   }
 }
 
 void TerminalDisplay::doDrag()
 {
@@ -2642,62 +2871,114 @@ void TerminalDisplay::doDrag()
   mimeData->setText(QApplication::clipboard()->text(QClipboard::Selection));
   dragInfo.dragObject->setMimeData(mimeData);
   dragInfo.dragObject->start(Qt::CopyAction);
   // Don't delete the QTextDrag object.  Qt will delete it when it's done with it.
 }
 
 void TerminalDisplay::outputSuspended(bool suspended)
 {
-	//create the label when this function is first called
-	if (!_outputSuspendedLabel)
-	{
+    //create the label when this function is first called
+    if (!_outputSuspendedLabel)
+    {
             //This label includes a link to an English language website
             //describing the 'flow control' (Xon/Xoff) feature found in almost 
             //all terminal emulators.
             //If there isn't a suitable article available in the target language the link
             //can simply be removed.
-			_outputSuspendedLabel = new QLabel( ("<qt>Output has been "
-                                                "<a href=\"http://en.wikipedia.org/wiki/XON\">suspended</a>"
+            _outputSuspendedLabel = new QLabel( i18n("<qt>Output has been "
+                                                "<a href=\"http://en.wikipedia.org/wiki/Flow_control\">suspended</a>"
                                                 " by pressing Ctrl+S."
-											   "  Press <b>Ctrl+Q</b> to resume.</qt>"),
-											   this );
+                                               "  Press <b>Ctrl+Q</b> to resume.</qt>"),
+                                               this );
 
             QPalette palette(_outputSuspendedLabel->palette());
-	    
-	    palette.setColor(QPalette::Normal, QPalette::WindowText, QColor(Qt::white));
-	    palette.setColor(QPalette::Normal, QPalette::Window, QColor(Qt::black));
-//            KColorScheme::adjustForeground(palette,KColorScheme::NeutralText);
-//		KColorScheme::adjustBackground(palette,KColorScheme::NeutralBackground);
-    	    _outputSuspendedLabel->setPalette(palette);
-	    _outputSuspendedLabel->setAutoFillBackground(true);
-	    _outputSuspendedLabel->setBackgroundRole(QPalette::Base);
-	    _outputSuspendedLabel->setFont(QApplication::font());
-            _outputSuspendedLabel->setMargin(5);
+            //KColorScheme::adjustBackground(palette,KColorScheme::NeutralBackground);
+            _outputSuspendedLabel->setPalette(palette);
+            _outputSuspendedLabel->setAutoFillBackground(true);
+            _outputSuspendedLabel->setBackgroundRole(QPalette::Base);
+            _outputSuspendedLabel->setFont(QApplication::font());
+            _outputSuspendedLabel->setContentsMargins(5, 5, 5, 5);
 
             //enable activation of "Xon/Xoff" link in label
             _outputSuspendedLabel->setTextInteractionFlags(Qt::LinksAccessibleByMouse | 
                                                           Qt::LinksAccessibleByKeyboard);
             _outputSuspendedLabel->setOpenExternalLinks(true);
             _outputSuspendedLabel->setVisible(false);
 
             _gridLayout->addWidget(_outputSuspendedLabel);       
             _gridLayout->addItem( new QSpacerItem(0,0,QSizePolicy::Expanding,
                                                       QSizePolicy::Expanding),
                                  1,0);
 
     }
 
-	_outputSuspendedLabel->setVisible(suspended);
+    _outputSuspendedLabel->setVisible(suspended);
 }
 
 uint TerminalDisplay::lineSpacing() const
 {
   return _lineSpacing;
 }
 
 void TerminalDisplay::setLineSpacing(uint i)
 {
   _lineSpacing = i;
   setVTFont(font()); // Trigger an update.
 }
 
-//#include "moc_TerminalDisplay.cpp"
+AutoScrollHandler::AutoScrollHandler(QWidget* parent)
+: QObject(parent)
+, _timerId(0)
+{
+    parent->installEventFilter(this);
+}
+void AutoScrollHandler::timerEvent(QTimerEvent* event)
+{
+    if (event->timerId() != _timerId)
+        return;
+
+    QMouseEvent mouseEvent(    QEvent::MouseMove,
+                              widget()->mapFromGlobal(QCursor::pos()),
+                              Qt::NoButton,
+                              Qt::LeftButton,
+                              Qt::NoModifier);
+
+    QApplication::sendEvent(widget(),&mouseEvent);    
+}
+bool AutoScrollHandler::eventFilter(QObject* watched,QEvent* event)
+{
+    Q_ASSERT( watched == parent() );
+    Q_UNUSED( watched );
+
+    QMouseEvent* mouseEvent = (QMouseEvent*)event;
+    switch (event->type())
+    {
+        case QEvent::MouseMove:
+        {
+            bool mouseInWidget = widget()->rect().contains(mouseEvent->pos());
+
+            if (mouseInWidget)
+            {
+                if (_timerId)
+                    killTimer(_timerId);
+                _timerId = 0;
+            }
+            else
+            {
+                if (!_timerId && (mouseEvent->buttons() & Qt::LeftButton))
+                    _timerId = startTimer(100);
+            }
+                break;
+        }
+        case QEvent::MouseButtonRelease:
+            if (_timerId && (mouseEvent->buttons() & ~Qt::LeftButton))
+            {
+                killTimer(_timerId);
+                _timerId = 0;
+            }
+        break;
+        default:
+        break;
+    };
+
+    return false;
+}
diff --git a/gui//src/TerminalDisplay.h b/gui//src/TerminalDisplay.h
--- a/gui//src/TerminalDisplay.h
+++ b/gui//src/TerminalDisplay.h
@@ -1,13 +1,11 @@
 /*
-    Copyright (C) 2007 by Robert Knight <robertknight@gmail.com>
-    Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
-
-    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+    Copyright 2007-2008 by Robert Knight <robertknight@gmail.com>
+    Copyright 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
 
     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -26,46 +24,48 @@
 // Qt
 #include <QtGui/QColor>
 #include <QtCore/QPointer>
 #include <QtGui/QWidget>
 
 // Konsole
 #include "Filter.h"
 #include "Character.h"
-#include "ColorTables.h"
+#include "konsole_export.h"
 
 class QDrag;
 class QDragEnterEvent;
 class QDropEvent;
 class QLabel;
 class QTimer;
 class QEvent;
-class QFrame;
 class QGridLayout;
 class QKeyEvent;
 class QScrollBar;
 class QShowEvent;
 class QHideEvent;
+class QTimerEvent;
 class QWidget;
 
+class KMenu;
+
 extern unsigned short vt100_graphics[32];
 
 class ScreenWindow;
 
 /**
  * A widget which displays output from a terminal emulation and sends input keypresses and mouse activity
  * to the terminal.
  *
  * When the terminal emulation receives new output from the program running in the terminal, 
  * it will update the display by calling updateImage().
  *
  * TODO More documentation
  */
-class TerminalDisplay : public QWidget
+class KONSOLEPRIVATE_EXPORT TerminalDisplay : public QWidget
 {
    Q_OBJECT
 
 public:
     /** Constructs a new terminal display widget with the specified parent. */
     TerminalDisplay(QWidget *parent=0);
     virtual ~TerminalDisplay();
 
@@ -148,33 +148,36 @@ public:
      */
     QList<QAction*> filterActions(const QPoint& position);
 
     /** Returns true if the cursor is set to blink or false otherwise. */
     bool blinkingCursor() { return _hasBlinkingCursor; }
     /** Specifies whether or not the cursor blinks. */
     void setBlinkingCursor(bool blink);
 
+    /** Specifies whether or not text can blink. */
+    void setBlinkingTextEnabled(bool blink);
+
     void setCtrlDrag(bool enable) { _ctrlDrag=enable; }
     bool ctrlDrag() { return _ctrlDrag; }
 
-	/** 
+    /** 
      *  This enum describes the methods for selecting text when
- 	 *  the user triple-clicks within the display. 
- 	 */
-	enum TripleClickMode
-	{
-		/** Select the whole line underneath the cursor. */
-		SelectWholeLine,
-		/** Select from the current cursor position to the end of the line. */
-		SelectForwardsFromCursor
-	};
-    /** Sets how the text is selected when the user triple clicks within the display. */	
+      *  the user triple-clicks within the display. 
+      */
+    enum TripleClickMode
+    {
+        /** Select the whole line underneath the cursor. */
+        SelectWholeLine,
+        /** Select from the current cursor position to the end of the line. */
+        SelectForwardsFromCursor
+    };
+    /** Sets how the text is selected when the user triple clicks within the display. */    
     void setTripleClickMode(TripleClickMode mode) { _tripleClickMode = mode; }
-	/** See setTripleClickSelectionMode() */
+    /** See setTripleClickSelectionMode() */
     TripleClickMode tripleClickMode() { return _tripleClickMode; }
 
     void setLineSpacing(uint);
     uint lineSpacing() const;
 
     void emitSelection(bool useXselection,bool appendReturn);
 
     /**
@@ -343,16 +346,26 @@ public:
      * Specified whether anti-aliasing of text in the terminal display
      * is enabled or not.  Defaults to enabled.
      */
     static void setAntialias( bool antialias ) { _antialiasText = antialias; }
     /** 
      * Returns true if anti-aliasing of text in the terminal is enabled.
      */
     static bool antialias()                 { return _antialiasText;   }
+
+    /**
+     * Specifies whether characters with intense colors should be rendered
+     * as bold. Defaults to true.
+     */
+    void setBoldIntense(bool value) { _boldIntense = value; }
+    /**
+     * Returns true if characters with intense colors are rendered in bold.
+     */
+    bool getBoldIntense() { return _boldIntense; }
     
     /**
      * Sets whether or not the current height and width of the 
      * terminal in lines and columns is displayed whilst the widget
      * is being resized.
      */
     void setTerminalSizeHint(bool on) { _terminalSizeHint=on; }
     /** 
@@ -364,17 +377,24 @@ public:
     /** 
      * Sets whether the terminal size display is shown briefly
      * after the widget is first shown.
      *
      * See setTerminalSizeHint() , isTerminalSizeHint()
      */
     void setTerminalSizeStartup(bool on) { _terminalSizeStartup=on; }
 
+    /**
+     * Sets the status of the BiDi rendering inside the terminal display.
+     * Defaults to disabled.
+     */
     void setBidiEnabled(bool set) { _bidiEnabled=set; }
+    /**
+     * Returns the status of the BiDi rendering in this widget.
+     */
     bool isBidiEnabled() { return _bidiEnabled; }
 
     /**
      * Sets the terminal screen section which is displayed in this widget.
      * When updateImage() is called, the display fetches the latest character image from the
      * the associated terminal screen window.
      *
      * In terms of the model-view paradigm, the ScreenWindow is the model which is rendered
@@ -407,31 +427,37 @@ public slots:
      */
     void pasteClipboard();
     /**
      * Pastes the content of the selection into the
      * display.
      */
     void pasteSelection();
 
-	/** 
- 	  * Changes whether the flow control warning box should be shown when the flow control
- 	  * stop key (Ctrl+S) are pressed.
- 	  */
-	void setFlowControlWarningEnabled(bool enabled);
-	
+    /** 
+       * Changes whether the flow control warning box should be shown when the flow control
+       * stop key (Ctrl+S) are pressed.
+       */
+    void setFlowControlWarningEnabled(bool enabled);
     /** 
-	 * Causes the widget to display or hide a message informing the user that terminal
-	 * output has been suspended (by using the flow control key combination Ctrl+S)
-	 *
-	 * @param suspended True if terminal output has been suspended and the warning message should
-	 *				 	be shown or false to indicate that terminal output has been resumed and that
-	 *				 	the warning message should disappear.
-	 */ 
-	void outputSuspended(bool suspended);
+     * Returns true if the flow control warning box is enabled. 
+     * See outputSuspended() and setFlowControlWarningEnabled()
+     */
+    bool flowControlWarningEnabled() const
+    { return _flowControlWarningEnabled; }
+
+    /** 
+     * Causes the widget to display or hide a message informing the user that terminal
+     * output has been suspended (by using the flow control key combination Ctrl+S)
+     *
+     * @param suspended True if terminal output has been suspended and the warning message should
+     *                     be shown or false to indicate that terminal output has been resumed and that
+     *                     the warning message should disappear.
+     */ 
+    void outputSuspended(bool suspended);
 
     /**
      * Sets whether the program whoose output is being displayed in the view
      * is interested in mouse events.
      *
      * If this is set to true, mouse signals will be emitted by the view when the user clicks, drags
      * or otherwise moves the mouse inside the view.
      * The user interaction needed to create selections will also change, and the user will be required
@@ -448,31 +474,35 @@ public slots:
     bool usesMouse() const;
 
     /** 
      * Shows a notification that a bell event has occurred in the terminal.
      * TODO: More documentation here
      */
     void bell(const QString& message);
 
+    /** 
+     * Sets the background of the display to the specified color. 
+     * @see setColorTable(), setForegroundColor() 
+     */
+    void setBackgroundColor(const QColor& color);
+
+    /** 
+     * Sets the text of the display to the specified color. 
+     * @see setColorTable(), setBackgroundColor()
+     */
+    void setForegroundColor(const QColor& color);
+
 signals:
 
     /**
      * Emitted when the user presses a key whilst the terminal widget has focus.
      */
     void keyPressedSignal(QKeyEvent *e);
 
-    /**
-     * Emitted when the user presses the suspend or resume flow control key combinations 
-     * 
-     * @param suspend true if the user pressed Ctrl+S (the suspend output key combination) or
-     * false if the user pressed Ctrl+Q (the resume output key combination)
-     */
-    void flowControlKeyPressed(bool suspend);
-    
     /** 
      * A mouse event occurred.
      * @param button The mouse button (0 for left button, 1 for middle button, 2 for right button, 3 for release)
      * @param column The character column where the event occurred
      * @param line The character row where the event occurred
      * @param eventType The type of event.  0 for a mouse press / release or 1 for mouse motion
      */
     void mouseSignal(int button, int column, int line, int eventType);
@@ -480,32 +510,44 @@ signals:
     void changedContentSizeSignal(int height, int width);
 
     /** 
      * Emitted when the user right clicks on the display, or right-clicks with the Shift
      * key held down if usesMouse() is true.
      *
      * This can be used to display a context menu.
      */
-    void configureRequest( TerminalDisplay*, int state, const QPoint& position );
+    void configureRequest(const QPoint& position);
+
+    /**
+     * When a shortcut which is also a valid terminal key sequence is pressed while 
+     * the terminal widget  has focus, this signal is emitted to allow the host to decide 
+     * whether the shortcut should be overridden.  
+     * When the shortcut is overridden, the key sequence will be sent to the terminal emulation instead
+     * and the action associated with the shortcut will not be triggered.
+     *
+     * @p override is set to false by default and the shortcut will be triggered as normal.
+     */
+    void overrideShortcutCheck(QKeyEvent* keyEvent,bool& override);
 
    void isBusySelecting(bool);
    void sendStringToEmu(const char*);
 
 protected:
     virtual bool event( QEvent * );
 
     virtual void paintEvent( QPaintEvent * );
 
     virtual void showEvent(QShowEvent*);
     virtual void hideEvent(QHideEvent*);
     virtual void resizeEvent(QResizeEvent*);
 
     virtual void fontChange(const QFont &font);
-
+    virtual void focusInEvent(QFocusEvent* event);
+    virtual void focusOutEvent(QFocusEvent* event);
     virtual void keyPressEvent(QKeyEvent* event);
     virtual void mouseDoubleClickEvent(QMouseEvent* ev);
     virtual void mousePressEvent( QMouseEvent* );
     virtual void mouseReleaseEvent( QMouseEvent* );
     virtual void mouseMoveEvent( QMouseEvent* );
     virtual void extendSelection( const QPoint& pos );
     virtual void wheelEvent( QWheelEvent* );
 
@@ -518,17 +560,23 @@ protected:
     enum DragState { diNone, diPending, diDragging };
 
     struct _dragInfo {
       DragState       state;
       QPoint          start;
       QDrag           *dragObject;
     } dragInfo;
 
-    virtual int charClass(quint16) const;
+    // classifies the 'ch' into one of three categories
+    // and returns a character to indicate which category it is in
+    //
+    //     - A space (returns ' ') 
+    //     - Part of a word (returns 'a')
+    //     - Other characters (returns the input character)
+    QChar charClass(QChar ch) const;
 
     void clearImage();
 
     void mouseTripleClickEvent(QMouseEvent* ev);
 
     // reimplemented
     virtual void inputMethodEvent ( QInputMethodEvent* event );
     virtual QVariant inputMethodQuery( Qt::InputMethodQuery query ) const;
@@ -560,25 +608,25 @@ private:
     // has a common color and style
     void drawTextFragment(QPainter& painter, const QRect& rect, 
                           const QString& text, const Character* style); 
     // draws the background for a text fragment
     // if useOpacitySetting is true then the color's alpha value will be set to
     // the display's transparency (set with setOpacity()), otherwise the background
     // will be drawn fully opaque
     void drawBackground(QPainter& painter, const QRect& rect, const QColor& color,
-						bool useOpacitySetting);
+                        bool useOpacitySetting);
     // draws the cursor character
     void drawCursor(QPainter& painter, const QRect& rect , const QColor& foregroundColor, 
                                        const QColor& backgroundColor , bool& invertColors);
     // draws the characters or line graphics in a text fragment
     void drawCharacters(QPainter& painter, const QRect& rect,  const QString& text, 
                                            const Character* style, bool invertCharacterColor);
     // draws a string of line graphics
-	void drawLineCharString(QPainter& painter, int x, int y, 
+    void drawLineCharString(QPainter& painter, int x, int y, 
                             const QString& str, const Character* attributes);
 
     // draws the preedit string for input methods
     void drawInputMethodPreeditString(QPainter& painter , const QRect& rect);
 
     // --
 
     // maps an area in the character image to an area on the widget 
@@ -605,35 +653,41 @@ private:
 
     void calcGeometry();
     void propagateSize();
     void updateImageSize();
     void makeImage();
     
     void paintFilters(QPainter& painter);
 
-	// returns a region covering all of the areas of the widget which contain
-	// a hotspot
-	QRegion hotSpotRegion() const;
+    // returns a region covering all of the areas of the widget which contain
+    // a hotspot
+    QRegion hotSpotRegion() const;
 
-	// returns the position of the cursor in columns and lines
-	QPoint cursorPosition() const;
+    // returns the position of the cursor in columns and lines
+    QPoint cursorPosition() const;
+
+    // redraws the cursor
+    void updateCursor();
+
+    bool handleShortcutOverrideEvent(QKeyEvent* event);
 
     // the window onto the terminal screen which this display
     // is currently showing.  
     QPointer<ScreenWindow> _screenWindow;
 
     bool _allowBell;
 
     QGridLayout* _gridLayout;
 
     bool _fixedFont; // has fixed pitch
     int  _fontHeight;     // height
     int  _fontWidth;     // width
     int  _fontAscent;     // ascend
+    bool _boldIntense;   // Whether intense colors should be rendered with bold font
 
     int _leftMargin;    // offset
     int _topMargin;    // offset
 
     int _lines;      // the number of lines that can be displayed in the widget
     int _columns;    // the number of columns that can be displayed in the widget
     
     int _usedLines;  // the number of lines that are actually being used, this will be less
@@ -675,51 +729,52 @@ private:
     ScrollBarPosition _scrollbarLocation;
     QString     _wordCharacters;
     int         _bellMode;
 
     bool _blinking;   // hide text in paintEvent
     bool _hasBlinker; // has characters to blink
     bool _cursorBlinking;     // hide cursor in paintEvent
     bool _hasBlinkingCursor;  // has blinking cursor enabled
+    bool _allowBlinkingText;  // allow text to blink
     bool _ctrlDrag;           // require Ctrl key for drag
     TripleClickMode _tripleClickMode;
     bool _isFixedSize; //Columns / lines are locked.
     QTimer* _blinkTimer;  // active when hasBlinker
     QTimer* _blinkCursorTimer;  // active when hasBlinkingCursor
 
-//    KMenu* _drop;
+    KMenu* _drop;
     QString _dropText;
     int _dndFileCount;
 
     bool _possibleTripleClick;  // is set in mouseDoubleClickEvent and deleted
                                // after QApplication::doubleClickInterval() delay
 
 
     QLabel* _resizeWidget;
     QTimer* _resizeTimer;
 
-	bool _flowControlWarningEnabled;
+    bool _flowControlWarningEnabled;
 
     //widgets related to the warning message that appears when the user presses Ctrl+S to suspend
     //terminal output - informing them what has happened and how to resume output
     QLabel* _outputSuspendedLabel; 
-    	
+        
     uint _lineSpacing;
 
     bool _colorsInverted; // true during visual bell
 
     QSize _size;
-	
+    
     QRgb _blendColor;
 
     // list of filters currently applied to the display.  used for links and
     // search highlight
     TerminalImageFilterChain* _filterChain;
-    QRect _mouseOverHotspotArea;
+    QRegion _mouseOverHotspotArea;
 
     KeyboardCursorShape _cursorShape;
 
     // custom cursor color.  if this is invalid then the foreground
     // color of the character under the cursor is used
     QColor _cursorColor;  
 
 
@@ -728,19 +783,35 @@ private:
         QString preeditString;
         QRect previousPreeditRect;
     };
     InputMethodData _inputMethodData;
 
     static bool _antialiasText;   // do we antialias or not
 
     //the delay in milliseconds between redrawing blinking text
-    static const int BLINK_DELAY = 500;
-	static const int DEFAULT_LEFT_MARGIN = 1;
-	static const int DEFAULT_TOP_MARGIN = 1;
+    static const int TEXT_BLINK_DELAY = 500;
+    static const int DEFAULT_LEFT_MARGIN = 1;
+    static const int DEFAULT_TOP_MARGIN = 1;
 
 public:
     static void setTransparencyEnabled(bool enable)
     {
         HAVE_TRANSPARENCY = enable;
     }
 };
+
+class AutoScrollHandler : public QObject
+{
+Q_OBJECT
+
+public:
+    AutoScrollHandler(QWidget* parent);
+protected:
+    virtual void timerEvent(QTimerEvent* event);
+    virtual bool eventFilter(QObject* watched,QEvent* event);
+private:
+    QWidget* widget() const { return static_cast<QWidget*>(parent()); }
+    int _timerId;
+};
+
+
 #endif // TERMINALDISPLAY_H
diff --git a/gui//src/TerminalMdiSubWindow.cpp b/gui//src/TerminalMdiSubWindow.cpp
--- a/gui//src/TerminalMdiSubWindow.cpp
+++ b/gui//src/TerminalMdiSubWindow.cpp
@@ -1,19 +1,70 @@
 #include "TerminalMdiSubWindow.h"
 #include <QHBoxLayout>
 #include <QVBoxLayout>
 
+bool is_inside_main_loop = false;
+bool is_cleanup_complete = false;
+
+extern bool quit_allowed;
+bool threadRunning = true;
+void * octave_main_wrapper(void *ptr)
+{
+  //MainWindow *mainWindow = (MainWindow*)ptr;
+
+  int argc = 3;
+  const char* argv[] = {"octave", "-i", "--line-editing"};
+  octave_main(argc,(char**)argv,1);
+  switch_to_buffer (create_buffer (get_input_from_stdin ()));
+  quit_allowed = true;
+
+  is_inside_main_loop = true;
+  main_loop();
+  is_inside_main_loop = false;
+
+  if (!is_cleanup_complete)
+    clean_up_and_exit(0);
+  return 0;
+}
+
 TerminalMdiSubWindow::TerminalMdiSubWindow(QWidget *parent)
     : QMdiSubWindow(parent),
-      m_terminalWidget(0) {
+      m_terminalWidget(0),
+      isRunning(true) {
+    establishOctaveLink();
     constructWindow();
 }
 
+TerminalMdiSubWindow::~TerminalMdiSubWindow() {
+    delete m_octaveLink;
+    isRunning = false;
+}
+
+void TerminalMdiSubWindow::establishOctaveLink() {
+    m_octaveLink = new OctaveLink();
+    pthread_create(&octave_thread, NULL, octave_main_wrapper, (void*)this);
+    pthread_create(&octave_monitor_thread, 0, TerminalMdiSubWindow::octave_monitor, this);
+    command_editor::add_event_hook(server_rl_event_hook_function);
+}
+
 void TerminalMdiSubWindow::constructWindow() {
+/*
+    int fdm;
+    int fds;
+
+    if ( openpty (&fdm, &fds, 0, 0, 0) < 0 )
+      {
+        fprintf (stderr, "oops!\n");
+      }
+
+    dup2 (fds, 0);
+    dup2 (fds, 1);
+    dup2 (fds, 2);
+*/
     setWindowTitle("Octave Session");
     resize(900, 600);
     setWidget(new QWidget(this));
 
     QVBoxLayout *vBoxLayout = new QVBoxLayout();
 
         QWidget *hWidget = new QWidget();
         QHBoxLayout *hBoxLayout = new QHBoxLayout();
@@ -46,8 +97,80 @@ void TerminalMdiSubWindow::constructWind
 
     vBoxLayout->addWidget(hWidget);
     vBoxLayout->addWidget(m_statusBar);
     vBoxLayout->setMargin(2);
     widget()->setLayout(vBoxLayout);
 
     m_statusBar->showMessage("Ready.");
 }
+
+bool ui_can_interrupt = true;
+void* TerminalMdiSubWindow::octave_monitor(void *octaveUI)
+{
+  TerminalMdiSubWindow* oui = (TerminalMdiSubWindow*)octaveUI;
+
+  while ( oui->isRunning )
+  {
+    // collect all the variable info
+    std::vector<OctaveLink::VariableMetaData> variables = oct_octave_server.variableInfoList();
+    if ( variables.size() > 0 )
+    {
+      qDebug("Update variables.");
+      //oui->mVariablesTreeView.clearRows();
+      //oui->mVariablesTreeView.addVariables(variables);
+    }
+
+    // Check whether any requested variables have been returned
+    std::vector<OctaveLink::RequestedVariable> reqVars = oct_octave_server.requestedVariables();
+    for(std::vector<OctaveLink::RequestedVariable>::iterator it = reqVars.begin() ;
+                                 it != reqVars.end() ;
+                                 it++ )
+    {
+      std::cout << "Requested variable returned: " << (*it).name << std::endl;
+    }
+
+    // collect history info
+    string_vector historyList = oct_octave_server.getHistoryList();
+    if( historyList.length() > 0 )
+    {
+      qDebug("Update history.");
+      //oui->mHistoryTreeView.addRows(historyList);
+      //oui->historyListWidget->addRows(historyList);
+    }
+
+    // Put a marker in each buffer at the proper location
+    int status = 0;
+    std::vector<OctaveLink::BreakPoint> bps = oct_octave_server.breakPointList(status);
+    if (status==0)
+    {
+      //MEditor::GetInstance()->process_breakpoint_list (bps);
+    }
+
+    // Find out if a breakpoint is hit
+    static bool line_number = -1;
+    bool is_bp_hit = oct_octave_server.isBreakpointReached(status);
+    if (status==0 && is_bp_hit)
+    {
+      std::vector<OctaveLink::BreakPoint> hit_breakpoint = oct_octave_server.reachedBreakpoint();
+      if (hit_breakpoint.size() > 0 && (hit_breakpoint[0].lineNumber != line_number))
+        {
+          //MEditor::GetInstance()->remove_hit_breakpoint_marker ();
+          //MEditor::GetInstance()->add_breakpoint_marker(hit_breakpoint[0], BP_MARKER_TYPE_HIT);
+          line_number = hit_breakpoint[0].lineNumber;
+      }
+    }
+    else if (status==0 && line_number>0)
+    {
+      //MEditor::GetInstance()->remove_hit_breakpoint_marker ();
+      line_number = -1;
+    }
+
+    if( global_command == 0 )
+      ui_can_interrupt = true;
+
+    usleep(100000);
+  }
+
+  //oui->threadEnded = 1;
+  std::cout << "Thread ended" << std::endl;
+  return 0;
+}
diff --git a/gui//src/TerminalMdiSubWindow.h b/gui//src/TerminalMdiSubWindow.h
--- a/gui//src/TerminalMdiSubWindow.h
+++ b/gui//src/TerminalMdiSubWindow.h
@@ -1,25 +1,89 @@
 #ifndef TERMINALMDISUBWINDOW_H
 #define TERMINALMDISUBWINDOW_H
 
 #include <QMdiSubWindow>
 #include <QTreeView>
 #include <QListView>
 #include <QStatusBar>
 #include "QTerminalWidget.h"
+#include "OctaveLink.h"
+
+
+// Octave includes
+#undef PACKAGE_BUGREPORT
+#undef PACKAGE_NAME
+#undef PACKAGE_STRING
+#undef PACKAGE_TARNAME
+#undef PACKAGE_VERSION
+#undef PACKAGE_URL
+#include "octave/config.h"
+
+#include "octave/debug.h"
+#include "octave/octave.h"
+#include "octave/symtab.h"
+#include "octave/parse.h"
+#include "octave/unwind-prot.h"
+#include "octave/toplev.h"
+#include "octave/load-path.h"
+#include "octave/error.h"
+#include "octave/quit.h"
+#include "octave/variables.h"
+#include "octave/sighandlers.h"
+#include "octave/sysdep.h"
+#include "octave/str-vec.h"
+#include "octave/cmd-hist.h"
+#include "octave/cmd-edit.h"
+#include "octave/oct-env.h"
+#include "octave/symtab.h"
+#include "cmd-edit.h"
+
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+extern OCTINTERP_API YY_BUFFER_STATE create_buffer (FILE *f);
+extern OCTINTERP_API void switch_to_buffer (YY_BUFFER_STATE buf);
+extern OCTINTERP_API FILE *get_input_from_stdin (void);
+
+// System
+#include <termios.h>
+#include <sys/types.h>
+#include <signal.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+
+#include <iostream>
+#include <vector>
+#include "pty.h"
 
 class TerminalMdiSubWindow : public QMdiSubWindow {
     Q_OBJECT
 public:
+    /**
+     * Stops the monitor thread.
+     */
+    void stopMonitorRunning(void) { this->isRunning = false; }
+
+    /**
+     * Checks if the monitor thread is currently running.
+     */
+    bool isMonitorRunning() { return this->isRunning; }
+
+    static void* octave_monitor(void *octaveUI);
     TerminalMdiSubWindow(QWidget *parent = 0);
+    ~TerminalMdiSubWindow();
 
 private slots:
 
 private:
+    void establishOctaveLink();
     void constructWindow();
     QTerminalWidget *m_terminalWidget;
     QTreeView *m_variableView;
     QListView *m_commandHistoryView;
     QStatusBar *m_statusBar;
-};
+    OctaveLink *m_octaveLink;
 
+    // Threads for running octave and managing the data interaction
+    pthread_t octave_thread;
+    pthread_t octave_monitor_thread;
+    bool isRunning;
+};
 #endif // TERMINALMDISUBWINDOW_H
diff --git a/gui//src/Vt102Emulation.cpp b/gui//src/Vt102Emulation.cpp
--- a/gui//src/Vt102Emulation.cpp
+++ b/gui//src/Vt102Emulation.cpp
@@ -1,13 +1,13 @@
 /*
     This file is part of Konsole, an X terminal.
-    Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
-
-    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+    
+    Copyright 2007-2008 by Robert Knight <robert.knight@gmail.com>
+    Copyright 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
 
     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -18,112 +18,77 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
     02110-1301  USA.
 */
 
 // Own
 #include "Vt102Emulation.h"
 
+// XKB
 //#include <config-konsole.h>
 
-
-#if defined(__osf__) || defined(__APPLE__)
-#define AVOID_XKB
-#endif
-
 // this allows konsole to be compiled without XKB and XTEST extensions
 // even though it might be available on a particular system.
 #if defined(AVOID_XKB)
-#undef HAVE_XKB
+    #undef HAVE_XKB
+#endif
+
+#if defined(HAVE_XKB)
+    void scrolllock_set_off();
+    void scrolllock_set_on();
 #endif
 
 // Standard 
 #include <stdio.h>
 #include <unistd.h>
 #include <assert.h>
 
 // Qt
 #include <QtCore/QEvent>
 #include <QtGui/QKeyEvent>
 #include <QtCore/QByteRef>
 
+// KDE
+//#include <kdebug.h>
+//#include <klocale.h>
+
 // Konsole
 #include "KeyboardTranslator.h"
 #include "Screen.h"
 
-#if defined(HAVE_XKB)
-void scrolllock_set_off();
-void scrolllock_set_on();
-#endif
-
-/* VT102 Terminal Emulation
-
-   This class puts together the screens, the pty and the widget to a
-   complete terminal emulation. Beside combining it's componentes, it
-   handles the emulations's protocol.
-
-   This module consists of the following sections:
-
-   - Constructor/Destructor
-   - Incoming Bytes Event pipeline
-   - Outgoing Bytes
-     - Mouse Events
-     - Keyboard Events
-   - Modes and Charset State
-   - Diagnostics
-*/
-
-/* ------------------------------------------------------------------------- */
-/*                                                                           */
-/*                       Constructor / Destructor                            */
-/*                                                                           */
-/* ------------------------------------------------------------------------- */
-
-
 Vt102Emulation::Vt102Emulation() 
     : Emulation(),
      _titleUpdateTimer(new QTimer(this))
 {
   _titleUpdateTimer->setSingleShot(true);
-
   QObject::connect(_titleUpdateTimer , SIGNAL(timeout()) , this , SLOT(updateTitle()));
 
   initTokenizer();
   reset();
 }
 
 Vt102Emulation::~Vt102Emulation()
-{
-}
+{}
 
 void Vt102Emulation::clearEntireScreen()
 {
   _currentScreen->clearEntireScreen();
-
   bufferedUpdate(); 
 }
 
 void Vt102Emulation::reset()
 {
-  //kDebug(1211)<<"Vt102Emulation::reset() resetToken()";
-  resetToken();
-  //kDebug(1211)<<"Vt102Emulation::reset() resetModes()";
+  resetTokenizer();
   resetModes();
-  //kDebug(1211)<<"Vt102Emulation::reset() resetCharSet()";
   resetCharset(0);
-  //kDebug(1211)<<"Vt102Emulation::reset() reset screen0()";
   _screen[0]->reset();
-  //kDebug(1211)<<"Vt102Emulation::reset() resetCharSet()";
   resetCharset(1);
-  //kDebug(1211)<<"Vt102Emulation::reset() reset _screen 1";
   _screen[1]->reset();
-  //kDebug(1211)<<"Vt102Emulation::reset() setCodec()";
   setCodec(LocaleCodec);
-  //kDebug(1211)<<"Vt102Emulation::reset() done";
  
   bufferedUpdate();
 }
 
 /* ------------------------------------------------------------------------- */
 /*                                                                           */
 /*                     Processing the incoming byte stream                   */
 /*                                                                           */
@@ -135,17 +100,17 @@ void Vt102Emulation::reset()
    Decoding means here, that the stream is first separated into `tokens'
    which are then mapped to a `meaning' provided as operations by the
    `Screen' class or by the emulation class itself.
 
    The pipeline proceeds as follows:
 
    - Tokenizing the ESC codes (onReceiveChar)
    - VT100 code page translation of plain characters (applyCharset)
-   - Interpretation of ESC codes (tau)
+   - Interpretation of ESC codes (processToken)
 
    The escape codes and their meaning are described in the
    technical reference of this program.
 */
 
 // Tokens ------------------------------------------------------------------ --
 
 /*
@@ -165,228 +130,290 @@ void Vt102Emulation::reset()
    - ESC_DE     - Escape codes of the form <ESC><any of `()+*#%'> C
    - CSI_PN     - Escape codes of the form <ESC>'['     {Pn} ';' {Pn} C
    - CSI_PS     - Escape codes of the form <ESC>'['     {Pn} ';' ...  C
    - CSI_PR     - Escape codes of the form <ESC>'[' '?' {Pn} ';' ...  C
    - CSI_PE     - Escape codes of the form <ESC>'[' '!' {Pn} ';' ...  C
    - VT52       - VT52 escape codes
                   - <ESC><Chr>
                   - <ESC>'Y'{Pc}{Pc}
-   - XTE_HA     - Xterm hacks              <ESC>`]' {Pn} `;' {Text} <BEL>
-                  note that this is handled differently
+   - XTE_HA     - Xterm window/terminal attribute commands 
+                  of the form <ESC>`]' {Pn} `;' {Text} <BEL>
+                  (Note that these are handled differently to the other formats)
 
    The last two forms allow list of arguments. Since the elements of
    the lists are treated individually the same way, they are passed
    as individual tokens to the interpretation. Further, because the
    meaning of the parameters are names (althought represented as numbers),
    they are includes within the token ('N').
 
 */
 
-#define TY_CONSTR(T,A,N) ( ((((int)N) & 0xffff) << 16) | ((((int)A) & 0xff) << 8) | (((int)T) & 0xff) )
+#define TY_CONSTRUCT(T,A,N) ( ((((int)N) & 0xffff) << 16) | ((((int)A) & 0xff) << 8) | (((int)T) & 0xff) )
 
-#define TY_CHR(   )     TY_CONSTR(0,0,0)
-#define TY_CTL(A  )     TY_CONSTR(1,A,0)
-#define TY_ESC(A  )     TY_CONSTR(2,A,0)
-#define TY_ESC_CS(A,B)  TY_CONSTR(3,A,B)
-#define TY_ESC_DE(A  )  TY_CONSTR(4,A,0)
-#define TY_CSI_PS(A,N)  TY_CONSTR(5,A,N)
-#define TY_CSI_PN(A  )  TY_CONSTR(6,A,0)
-#define TY_CSI_PR(A,N)  TY_CONSTR(7,A,N)
+#define TY_CHR(   )     TY_CONSTRUCT(0,0,0)
+#define TY_CTL(A  )     TY_CONSTRUCT(1,A,0)
+#define TY_ESC(A  )     TY_CONSTRUCT(2,A,0)
+#define TY_ESC_CS(A,B)  TY_CONSTRUCT(3,A,B)
+#define TY_ESC_DE(A  )  TY_CONSTRUCT(4,A,0)
+#define TY_CSI_PS(A,N)  TY_CONSTRUCT(5,A,N)
+#define TY_CSI_PN(A  )  TY_CONSTRUCT(6,A,0)
+#define TY_CSI_PR(A,N)  TY_CONSTRUCT(7,A,N)
 
-#define TY_VT52(A  )    TY_CONSTR(8,A,0)
+#define TY_VT52(A)    TY_CONSTRUCT(8,A,0)
+#define TY_CSI_PG(A)  TY_CONSTRUCT(9,A,0)
+#define TY_CSI_PE(A)  TY_CONSTRUCT(10,A,0)
 
-#define TY_CSI_PG(A  )  TY_CONSTR(9,A,0)
-
-#define TY_CSI_PE(A  )  TY_CONSTR(10,A,0)
+#define MAX_ARGUMENT 4096
 
 // Tokenizer --------------------------------------------------------------- --
 
-/* The tokenizers state
+/* The tokenizer's state
 
-   The state is represented by the buffer (pbuf, ppos),
+   The state is represented by the buffer (tokenBuffer, tokenBufferPos),
    and accompanied by decoded arguments kept in (argv,argc).
    Note that they are kept internal in the tokenizer.
 */
 
-void Vt102Emulation::resetToken()
+void Vt102Emulation::resetTokenizer()
 {
-  ppos = 0; argc = 0; argv[0] = 0; argv[1] = 0;
+  tokenBufferPos = 0; 
+  argc = 0; 
+  argv[0] = 0; 
+  argv[1] = 0;
 }
 
-void Vt102Emulation::addDigit(int dig)
+void Vt102Emulation::addDigit(int digit)
 {
-  argv[argc] = 10*argv[argc] + dig;
+  if (argv[argc] < MAX_ARGUMENT)
+      argv[argc] = 10*argv[argc] + digit;
 }
 
 void Vt102Emulation::addArgument()
 {
   argc = qMin(argc+1,MAXARGS-1);
   argv[argc] = 0;
 }
 
-void Vt102Emulation::pushToToken(int cc)
+void Vt102Emulation::addToCurrentToken(int cc)
 {
-  pbuf[ppos] = cc;
-  ppos = qMin(ppos+1,MAXPBUF-1);
+  tokenBuffer[tokenBufferPos] = cc;
+  tokenBufferPos = qMin(tokenBufferPos+1,MAX_TOKEN_LENGTH-1);
 }
 
-// Character Classes used while decoding
+// Character Class flags used while decoding
 
-#define CTL  1
-#define CHR  2
-#define CPN  4
-#define DIG  8
-#define SCS 16
-#define GRP 32
-#define CPS 64
+#define CTL  1  // Control character
+#define CHR  2  // Printable character
+#define CPN  4  // TODO: Document me 
+#define DIG  8  // Digit
+#define SCS 16  // TODO: Document me  
+#define GRP 32  // TODO: Document me
+#define CPS 64  // Character which indicates end of window resize
+                // escape sequence '\e[8;<row>;<col>t'
 
 void Vt102Emulation::initTokenizer()
-{ int i; quint8* s;
-  for(i =  0;                      i < 256; i++) tbl[ i]  = 0;
-  for(i =  0;                      i <  32; i++) tbl[ i] |= CTL;
-  for(i = 32;                      i < 256; i++) tbl[ i] |= CHR;
-  for(s = (quint8*)"@ABCDGHILMPSTXZcdfry"; *s; s++) tbl[*s] |= CPN;
-// resize = \e[8;<row>;<col>t
-  for(s = (quint8*)"t"; *s; s++) tbl[*s] |= CPS;
-  for(s = (quint8*)"0123456789"        ; *s; s++) tbl[*s] |= DIG;
-  for(s = (quint8*)"()+*%"             ; *s; s++) tbl[*s] |= SCS;
-  for(s = (quint8*)"()+*#[]%"          ; *s; s++) tbl[*s] |= GRP;
-  resetToken();
+{ 
+  int i; 
+  quint8* s;
+  for(i = 0;i < 256; ++i) 
+    charClass[i] = 0;
+  for(i = 0;i < 32; ++i) 
+    charClass[i] |= CTL;
+  for(i = 32;i < 256; ++i) 
+    charClass[i] |= CHR;
+  for(s = (quint8*)"@ABCDGHILMPSTXZcdfry"; *s; ++s) 
+    charClass[*s] |= CPN;
+  // resize = \e[8;<row>;<col>t
+  for(s = (quint8*)"t"; *s; ++s) 
+    charClass[*s] |= CPS;
+  for(s = (quint8*)"0123456789"; *s; ++s) 
+    charClass[*s] |= DIG;
+  for(s = (quint8*)"()+*%"; *s; ++s) 
+    charClass[*s] |= SCS;
+  for(s = (quint8*)"()+*#[]%"; *s; ++s) 
+    charClass[*s] |= GRP;
+
+  resetTokenizer();
 }
 
 /* Ok, here comes the nasty part of the decoder.
 
    Instead of keeping an explicit state, we deduce it from the
    token scanned so far. It is then immediately combined with
    the current character to form a scanning decision.
 
    This is done by the following defines.
 
    - P is the length of the token scanned so far.
    - L (often P-1) is the position on which contents we base a decision.
-   - C is a character or a group of characters (taken from 'tbl').
+   - C is a character or a group of characters (taken from 'charClass').
+   
+   - 'cc' is the current character
+   - 's' is a pointer to the start of the token buffer
+   - 'p' is the current position within the token buffer 
 
    Note that they need to applied in proper order.
 */
 
-#define lec(P,L,C) (p == (P) &&                     s[(L)]         == (C))
-#define lun(     ) (p ==  1  &&                       cc           >= 32 )
-#define les(P,L,C) (p == (P) && s[L] < 256  && (tbl[s[(L)]] & (C)) == (C))
-#define eec(C)     (p >=  3  &&        cc                          == (C))
-#define ees(C)     (p >=  3  && cc < 256 &&    (tbl[  cc  ] & (C)) == (C))
-#define eps(C)     (p >=  3  && s[2] != '?' && s[2] != '!' && s[2] != '>' && cc < 256 && (tbl[  cc  ] & (C)) == (C))
-#define epp( )     (p >=  3  && s[2] == '?'                              )
-#define epe( )     (p >=  3  && s[2] == '!'                              )
-#define egt(     ) (p >=  3  && s[2] == '>'                              )
-#define Xpe        (ppos>=2  && pbuf[1] == ']'                           )
-#define Xte        (Xpe                        &&     cc           ==  7 )
-#define ces(C)     (            cc < 256 &&    (tbl[  cc  ] & (C)) == (C) && !Xte)
+#define lec(P,L,C) (p == (P) && s[(L)] == (C))
+#define lun(     ) (p ==  1  && cc >= 32 )
+#define les(P,L,C) (p == (P) && s[L] < 256 && (charClass[s[(L)]] & (C)) == (C))
+#define eec(C)     (p >=  3  && cc == (C))
+#define ees(C)     (p >=  3  && cc < 256 && (charClass[cc] & (C)) == (C))
+#define eps(C)     (p >=  3  && s[2] != '?' && s[2] != '!' && s[2] != '>' && cc < 256 && (charClass[cc] & (C)) == (C))
+#define epp( )     (p >=  3  && s[2] == '?')
+#define epe( )     (p >=  3  && s[2] == '!')
+#define egt( )     (p >=  3  && s[2] == '>')
+#define Xpe        (tokenBufferPos >= 2 && tokenBuffer[1] == ']')
+#define Xte        (Xpe      && cc ==  7 )
+#define ces(C)     (cc < 256 && (charClass[cc] & (C)) == (C) && !Xte)
 
 #define ESC 27
 #define CNTL(c) ((c)-'@')
 
 // process an incoming unicode character
-
 void Vt102Emulation::receiveChar(int cc)
 { 
-  int i;
-  if (cc == 127) return; //VT100: ignore.
+  if (cc == 127) 
+    return; //VT100: ignore.
 
-  if (ces(    CTL))
-  { // DEC HACK ALERT! Control Characters are allowed *within* esc sequences in VT100
-    // This means, they do neither a resetToken nor a pushToToken. Some of them, do
+  if (ces(CTL))
+  { 
+    // DEC HACK ALERT! Control Characters are allowed *within* esc sequences in VT100
+    // This means, they do neither a resetTokenizer() nor a pushToToken(). Some of them, do
     // of course. Guess this originates from a weakly layered handling of the X-on
     // X-off protocol, which comes really below this level.
-    if (cc == CNTL('X') || cc == CNTL('Z') || cc == ESC) resetToken(); //VT100: CAN or SUB
-    if (cc != ESC)    { tau( TY_CTL(cc+'@' ),   0,  0); return; }
+    if (cc == CNTL('X') || cc == CNTL('Z') || cc == ESC) 
+        resetTokenizer(); //VT100: CAN or SUB
+    if (cc != ESC)    
+    { 
+        processToken(TY_CTL(cc+'@' ),0,0); 
+        return; 
+    }
+  }
+  // advance the state
+  addToCurrentToken(cc); 
+
+  int* s = tokenBuffer;
+  int  p = tokenBufferPos;
+
+  if (getMode(MODE_Ansi)) 
+  {
+    if (lec(1,0,ESC)) { return; }
+    if (lec(1,0,ESC+128)) { s[0] = ESC; receiveChar('['); return; }
+    if (les(2,1,GRP)) { return; }
+    if (Xte         ) { processWindowAttributeChange(); resetTokenizer(); return; }
+    if (Xpe         ) { return; }
+    if (lec(3,2,'?')) { return; }
+    if (lec(3,2,'>')) { return; }
+    if (lec(3,2,'!')) { return; }
+    if (lun(       )) { processToken( TY_CHR(), applyCharset(cc), 0);   resetTokenizer(); return; }
+    if (lec(2,0,ESC)) { processToken( TY_ESC(s[1]), 0, 0);              resetTokenizer(); return; }
+    if (les(3,1,SCS)) { processToken( TY_ESC_CS(s[1],s[2]), 0, 0);      resetTokenizer(); return; }
+    if (lec(3,1,'#')) { processToken( TY_ESC_DE(s[2]), 0, 0);           resetTokenizer(); return; }
+    if (eps(    CPN)) { processToken( TY_CSI_PN(cc), argv[0],argv[1]);  resetTokenizer(); return; }
+
+    // resize = \e[8;<row>;<col>t
+    if (eps(CPS)) 
+    { 
+        processToken( TY_CSI_PS(cc, argv[0]), argv[1], argv[2]);   
+        resetTokenizer(); 
+        return; 
+    }
+
+    if (epe(   )) { processToken( TY_CSI_PE(cc), 0, 0); resetTokenizer(); return; }
+    if (ees(DIG)) { addDigit(cc-'0'); return; }
+    if (eec(';')) { addArgument();    return; }
+    for (int i=0;i<=argc;i++)
+    {
+        if (epp())  
+            processToken( TY_CSI_PR(cc,argv[i]), 0, 0);
+        else if (egt())   
+            processToken( TY_CSI_PG(cc), 0, 0); // spec. case for ESC]>0c or ESC]>c
+        else if (cc == 'm' && argc - i >= 4 && (argv[i] == 38 || argv[i] == 48) && argv[i+1] == 2)
+        { 
+            // ESC[ ... 48;2;<red>;<green>;<blue> ... m -or- ESC[ ... 38;2;<red>;<green>;<blue> ... m
+            i += 2;
+            processToken( TY_CSI_PS(cc, argv[i-2]), COLOR_SPACE_RGB, (argv[i] << 16) | (argv[i+1] << 8) | argv[i+2]);
+            i += 2;
+        }
+        else if (cc == 'm' && argc - i >= 2 && (argv[i] == 38 || argv[i] == 48) && argv[i+1] == 5)
+        { 
+            // ESC[ ... 48;5;<index> ... m -or- ESC[ ... 38;5;<index> ... m
+            i += 2;
+            processToken( TY_CSI_PS(cc, argv[i-2]), COLOR_SPACE_256, argv[i]);
+        }
+        else
+            processToken( TY_CSI_PS(cc,argv[i]), 0, 0);
+    }
+    resetTokenizer();
+  }
+  else 
+  {
+    // VT52 Mode
+    if (lec(1,0,ESC))                                                      
+        return;
+    if (les(1,0,CHR)) 
+    { 
+        processToken( TY_CHR(), s[0], 0); 
+        resetTokenizer(); 
+        return; 
+    }
+    if (lec(2,1,'Y'))                                                      
+        return;
+    if (lec(3,1,'Y'))                                                      
+        return;
+    if (p < 4) 
+    { 
+        processToken( TY_VT52(s[1] ), 0, 0); 
+        resetTokenizer(); 
+        return; 
+    }
+    processToken( TY_VT52(s[1]), s[2], s[3]); 
+    resetTokenizer(); 
+    return;
+  }
+}
+void Vt102Emulation::processWindowAttributeChange()
+{
+  // Describes the window or terminal session attribute to change
+  // See Session::UserTitleChange for possible values
+  int attributeToChange = 0;
+  int i;
+  for (i = 2; i < tokenBufferPos     && 
+              tokenBuffer[i] >= '0'  && 
+              tokenBuffer[i] <= '9'; i++)
+  {
+    attributeToChange = 10 * attributeToChange + (tokenBuffer[i]-'0');
   }
 
-  pushToToken(cc); // advance the state
-
-  int* s = pbuf;
-  int  p = ppos;
-
-  if (getMode(MODE_Ansi)) // decide on proper action
-  {
-    if (lec(1,0,ESC)) {                                                       return; }
-    if (lec(1,0,ESC+128)) { s[0] = ESC; receiveChar('[');                   return; }
-    if (les(2,1,GRP)) {                                                       return; }
-    if (Xte         ) { XtermHack();                            resetToken(); return; }
-    if (Xpe         ) {                                                       return; }
-    if (lec(3,2,'?')) {                                                       return; }
-    if (lec(3,2,'>')) {                                                       return; }
-    if (lec(3,2,'!')) {                                                       return; }
-    if (lun(       )) { tau( TY_CHR(), applyCharset(cc), 0); resetToken(); return; }
-    if (lec(2,0,ESC)) { tau( TY_ESC(s[1]),   0,  0);       resetToken(); return; }
-    if (les(3,1,SCS)) { tau( TY_ESC_CS(s[1],s[2]),   0,  0);  resetToken(); return; }
-    if (lec(3,1,'#')) { tau( TY_ESC_DE(s[2]),   0,  0);       resetToken(); return; }
-    if (eps(    CPN)) { tau( TY_CSI_PN(cc), argv[0],argv[1]);   resetToken(); return; }
-
-// resize = \e[8;<row>;<col>t
-    if (eps(    CPS)) { tau( TY_CSI_PS(cc, argv[0]), argv[1], argv[2]);   resetToken(); return; }
-
-    if (epe(       )) { tau( TY_CSI_PE(cc),     0,  0);       resetToken(); return; }
-    if (ees(    DIG)) { addDigit(cc-'0');                                     return; }
-    if (eec(    ';')) { addArgument();                                        return; }
-    for (i=0;i<=argc;i++)
-    if ( epp(     ))  { tau( TY_CSI_PR(cc,argv[i]),   0,  0); }
-    else if(egt(    ))   { tau( TY_CSI_PG(cc     ),   0,  0); } // spec. case for ESC]>0c or ESC]>c
-    else if (cc == 'm' && argc - i >= 4 && (argv[i] == 38 || argv[i] == 48) && argv[i+1] == 2)
-    { // ESC[ ... 48;2;<red>;<green>;<blue> ... m -or- ESC[ ... 38;2;<red>;<green>;<blue> ... m
-      i += 2;
-      tau( TY_CSI_PS(cc, argv[i-2]), COLOR_SPACE_RGB, (argv[i] << 16) | (argv[i+1] << 8) | argv[i+2]);
-      i += 2;
-    }
-    else if (cc == 'm' && argc - i >= 2 && (argv[i] == 38 || argv[i] == 48) && argv[i+1] == 5)
-    { // ESC[ ... 48;5;<index> ... m -or- ESC[ ... 38;5;<index> ... m
-      i += 2;
-      tau( TY_CSI_PS(cc, argv[i-2]), COLOR_SPACE_256, argv[i]);
-    }
-    else              { tau( TY_CSI_PS(cc,argv[i]),   0,  0); }
-    resetToken();
+  if (tokenBuffer[i] != ';') 
+  { 
+    reportDecodingError(); 
+    return; 
   }
-  else // mode VT52
-  {
-    if (lec(1,0,ESC))                                                      return;
-    if (les(1,0,CHR)) { tau( TY_CHR(       ), s[0],  0); resetToken(); return; }
-    if (lec(2,1,'Y'))                                                      return;
-    if (lec(3,1,'Y'))                                                      return;
-    if (p < 4)        { tau( TY_VT52(s[1]   ),   0,  0); resetToken(); return; }
-                        tau( TY_VT52(s[1]   ), s[2],s[3]); resetToken(); return;
-  }
-}
-
-void Vt102Emulation::XtermHack()
-{ int i,arg = 0;
-  for (i = 2; i < ppos && '0'<=pbuf[i] && pbuf[i]<'9' ; i++)
-    arg = 10*arg + (pbuf[i]-'0');
-  if (pbuf[i] != ';') { ReportErrorToken(); return; }
-  QChar *str = new QChar[ppos-i-2];
-  for (int j = 0; j < ppos-i-2; j++) str[j] = pbuf[i+1+j];
-  QString unistr(str,ppos-i-2);
   
-  // arg == 1 doesn't change the title. In XTerm it only changes the icon name
-  // (btw: arg=0 changes title and icon, arg=1 only icon, arg=2 only title
-//  emit changeTitle(arg,unistr);
-  _pendingTitleUpdates[arg] = unistr;
+  QString newValue;
+  newValue.reserve(tokenBufferPos-i-2);
+  for (int j = 0; j < tokenBufferPos-i-2; j++)
+    newValue[j] = tokenBuffer[i+1+j];
+ 
+  _pendingTitleUpdates[attributeToChange] = newValue;
   _titleUpdateTimer->start(20);
-
-  delete [] str;
 }
 
 void Vt102Emulation::updateTitle()
 {
-	QListIterator<int> iter( _pendingTitleUpdates.keys() );
-	while (iter.hasNext()) {
-		int arg = iter.next();
-		emit titleChanged( arg , _pendingTitleUpdates[arg] );	
-	}
-
-    _pendingTitleUpdates.clear();	
+    QListIterator<int> iter( _pendingTitleUpdates.keys() );
+    while (iter.hasNext()) {
+        int arg = iter.next();
+        emit titleChanged( arg , _pendingTitleUpdates[arg] );    
+    }
+    _pendingTitleUpdates.clear();    
 }
 
 // Interpreting Codes ---------------------------------------------------------
 
 /*
    Now that the incoming character stream is properly tokenized,
    meaning is assigned to them. These are either operations of
    the current _screen, or of the emulation class itself.
@@ -397,95 +424,63 @@ void Vt102Emulation::updateTitle()
    Likewise, the operations assigned to, come with up to two
    arguments. One could consider to make up a proper table
    from the function below.
 
    The technical reference manual provides more information
    about this mapping.
 */
 
-void Vt102Emulation::tau( int token, int p, int q )
-{
-#if 0
-int N = (token>>0)&0xff;
-int A = (token>>8)&0xff;
-switch( N )
+void Vt102Emulation::processToken(int token, int p, int q)
 {
-   case 0: printf("%c", (p < 128) ? p : '?');
-           break;
-   case 1: if (A == 'J') printf("\r");
-           else if (A == 'M') printf("\n");
-           else printf("CTL-%c ", (token>>8)&0xff);
-           break;
-   case 2: printf("ESC-%c ", (token>>8)&0xff);
-           break;
-   case 3: printf("ESC_CS-%c-%c ", (token>>8)&0xff, (token>>16)&0xff);
-           break;
-   case 4: printf("ESC_DE-%c ", (token>>8)&0xff);
-           break;
-   case 5: printf("CSI-PS-%c-%d", (token>>8)&0xff, (token>>16)&0xff );
-           break;
-   case 6: printf("CSI-PN-%c [%d]", (token>>8)&0xff, p);
-           break;
-   case 7: printf("CSI-PR-%c-%d", (token>>8)&0xff, (token>>16)&0xff );
-           break;
-   case 8: printf("VT52-%c", (token>>8)&0xff);
-           break;
-   case 9: printf("CSI-PG-%c", (token>>8)&0xff);
-           break;
-   case 10: printf("CSI-PE-%c", (token>>8)&0xff);
-           break;
-}
-#endif
-
   switch (token)
   {
 
-    case TY_CHR(         ) : _currentScreen->ShowCharacter        (p         ); break; //UTF16
+    case TY_CHR(         ) : _currentScreen->displayCharacter     (p         ); break; //UTF16
 
     //             127 DEL    : ignored on input
 
     case TY_CTL('@'      ) : /* NUL: ignored                      */ break;
     case TY_CTL('A'      ) : /* SOH: ignored                      */ break;
     case TY_CTL('B'      ) : /* STX: ignored                      */ break;
     case TY_CTL('C'      ) : /* ETX: ignored                      */ break;
     case TY_CTL('D'      ) : /* EOT: ignored                      */ break;
     case TY_CTL('E'      ) :      reportAnswerBack     (          ); break; //VT100
     case TY_CTL('F'      ) : /* ACK: ignored                      */ break;
     case TY_CTL('G'      ) : emit stateSet(NOTIFYBELL);
                                 break; //VT100
-    case TY_CTL('H'      ) : _currentScreen->BackSpace            (          ); break; //VT100
-    case TY_CTL('I'      ) : _currentScreen->Tabulate             (          ); break; //VT100
-    case TY_CTL('J'      ) : _currentScreen->NewLine              (          ); break; //VT100
-    case TY_CTL('K'      ) : _currentScreen->NewLine              (          ); break; //VT100
-    case TY_CTL('L'      ) : _currentScreen->NewLine              (          ); break; //VT100
-    case TY_CTL('M'      ) : _currentScreen->Return               (          ); break; //VT100
+    case TY_CTL('H'      ) : _currentScreen->backspace            (          ); break; //VT100
+    case TY_CTL('I'      ) : _currentScreen->tab                  (          ); break; //VT100
+    case TY_CTL('J'      ) : _currentScreen->newLine              (          ); break; //VT100
+    case TY_CTL('K'      ) : _currentScreen->newLine              (          ); break; //VT100
+    case TY_CTL('L'      ) : _currentScreen->newLine              (          ); break; //VT100
+    case TY_CTL('M'      ) : _currentScreen->toStartOfLine        (          ); break; //VT100
 
     case TY_CTL('N'      ) :      useCharset           (         1); break; //VT100
     case TY_CTL('O'      ) :      useCharset           (         0); break; //VT100
 
     case TY_CTL('P'      ) : /* DLE: ignored                      */ break;
     case TY_CTL('Q'      ) : /* DC1: XON continue                 */ break; //VT100
     case TY_CTL('R'      ) : /* DC2: ignored                      */ break;
     case TY_CTL('S'      ) : /* DC3: XOFF halt                    */ break; //VT100
     case TY_CTL('T'      ) : /* DC4: ignored                      */ break;
     case TY_CTL('U'      ) : /* NAK: ignored                      */ break;
     case TY_CTL('V'      ) : /* SYN: ignored                      */ break;
     case TY_CTL('W'      ) : /* ETB: ignored                      */ break;
-    case TY_CTL('X'      ) : _currentScreen->ShowCharacter        (    0x2592); break; //VT100
+    case TY_CTL('X'      ) : _currentScreen->displayCharacter     (    0x2592); break; //VT100
     case TY_CTL('Y'      ) : /* EM : ignored                      */ break;
-    case TY_CTL('Z'      ) : _currentScreen->ShowCharacter        (    0x2592); break; //VT100
+    case TY_CTL('Z'      ) : _currentScreen->displayCharacter     (    0x2592); break; //VT100
     case TY_CTL('['      ) : /* ESC: cannot be seen here.         */ break;
     case TY_CTL('\\'     ) : /* FS : ignored                      */ break;
     case TY_CTL(']'      ) : /* GS : ignored                      */ break;
     case TY_CTL('^'      ) : /* RS : ignored                      */ break;
     case TY_CTL('_'      ) : /* US : ignored                      */ break;
 
     case TY_ESC('D'      ) : _currentScreen->index                (          ); break; //VT100
-    case TY_ESC('E'      ) : _currentScreen->NextLine             (          ); break; //VT100
+    case TY_ESC('E'      ) : _currentScreen->nextLine             (          ); break; //VT100
     case TY_ESC('H'      ) : _currentScreen->changeTabStop        (true      ); break; //VT100
     case TY_ESC('M'      ) : _currentScreen->reverseIndex         (          ); break; //VT100
     case TY_ESC('Z'      ) :      reportTerminalType   (          ); break;
     case TY_ESC('c'      ) :      reset                (          ); break;
 
     case TY_ESC('n'      ) :      useCharset           (         2); break;
     case TY_ESC('o'      ) :      useCharset           (         3); break;
     case TY_ESC('7'      ) :      saveCursor           (          ); break;
@@ -510,45 +505,46 @@ switch( N )
     case TY_ESC_CS('+', '0') :      setCharset           (3,    '0'); break; //VT100
     case TY_ESC_CS('+', 'A') :      setCharset           (3,    'A'); break; //VT100
     case TY_ESC_CS('+', 'B') :      setCharset           (3,    'B'); break; //VT100
 
     case TY_ESC_CS('%', 'G') :      setCodec             (Utf8Codec   ); break; //LINUX
     case TY_ESC_CS('%', '@') :      setCodec             (LocaleCodec ); break; //LINUX
 
     case TY_ESC_DE('3'      ) : /* Double height line, top half    */ 
-								_currentScreen->setLineProperty( LINE_DOUBLEWIDTH , true );
-								_currentScreen->setLineProperty( LINE_DOUBLEHEIGHT , true );
-									break;
+                                _currentScreen->setLineProperty( LINE_DOUBLEWIDTH , true );
+                                _currentScreen->setLineProperty( LINE_DOUBLEHEIGHT , true );
+                                    break;
     case TY_ESC_DE('4'      ) : /* Double height line, bottom half */ 
-								_currentScreen->setLineProperty( LINE_DOUBLEWIDTH , true );
-								_currentScreen->setLineProperty( LINE_DOUBLEHEIGHT , true );
-									break;
+                                _currentScreen->setLineProperty( LINE_DOUBLEWIDTH , true );
+                                _currentScreen->setLineProperty( LINE_DOUBLEHEIGHT , true );
+                                    break;
     case TY_ESC_DE('5'      ) : /* Single width, single height line*/
-								_currentScreen->setLineProperty( LINE_DOUBLEWIDTH , false);
-								_currentScreen->setLineProperty( LINE_DOUBLEHEIGHT , false);
-								break;
+                                _currentScreen->setLineProperty( LINE_DOUBLEWIDTH , false);
+                                _currentScreen->setLineProperty( LINE_DOUBLEHEIGHT , false);
+                                break;
     case TY_ESC_DE('6'      ) : /* Double width, single height line*/ 
-							    _currentScreen->setLineProperty( LINE_DOUBLEWIDTH , true);	
-								_currentScreen->setLineProperty( LINE_DOUBLEHEIGHT , false);
-								break;
+                                _currentScreen->setLineProperty( LINE_DOUBLEWIDTH , true);    
+                                _currentScreen->setLineProperty( LINE_DOUBLEHEIGHT , false);
+                                break;
     case TY_ESC_DE('8'      ) : _currentScreen->helpAlign            (          ); break;
 
 // resize = \e[8;<row>;<col>t
-    case TY_CSI_PS('t',   8) : setImageSize( q /* colums */, p /* lines */ );    break;
+    case TY_CSI_PS('t',   8) : setImageSize( q /* columns */, p /* lines */ );    break;
 
 // change tab text color : \e[28;<color>t  color: 0-16,777,215
     case TY_CSI_PS('t',   28) : emit changeTabTextColorRequest      ( p        );          break;
 
     case TY_CSI_PS('K',   0) : _currentScreen->clearToEndOfLine     (          ); break;
     case TY_CSI_PS('K',   1) : _currentScreen->clearToBeginOfLine   (          ); break;
     case TY_CSI_PS('K',   2) : _currentScreen->clearEntireLine      (          ); break;
     case TY_CSI_PS('J',   0) : _currentScreen->clearToEndOfScreen   (          ); break;
     case TY_CSI_PS('J',   1) : _currentScreen->clearToBeginOfScreen (          ); break;
     case TY_CSI_PS('J',   2) : _currentScreen->clearEntireScreen    (          ); break;
+    case TY_CSI_PS('J',      3) : clearHistory();                            break;
     case TY_CSI_PS('g',   0) : _currentScreen->changeTabStop        (false     ); break; //VT100
     case TY_CSI_PS('g',   3) : _currentScreen->clearTabStops        (          ); break; //VT100
     case TY_CSI_PS('h',   4) : _currentScreen->    setMode      (MODE_Insert   ); break;
     case TY_CSI_PS('h',  20) :          setMode      (MODE_NewLine  ); break;
     case TY_CSI_PS('i',   0) : /* IGNORE: attached printer          */ break; //VT100
     case TY_CSI_PS('l',   4) : _currentScreen->  resetMode      (MODE_Insert   ); break;
     case TY_CSI_PS('l',  20) :        resetMode      (MODE_NewLine  ); break;
     case TY_CSI_PS('s',   0) :      saveCursor           (          ); break;
@@ -623,39 +619,39 @@ switch( N )
 
     case TY_CSI_PN('@'      ) : _currentScreen->insertChars          (p         ); break;
     case TY_CSI_PN('A'      ) : _currentScreen->cursorUp             (p         ); break; //VT100
     case TY_CSI_PN('B'      ) : _currentScreen->cursorDown           (p         ); break; //VT100
     case TY_CSI_PN('C'      ) : _currentScreen->cursorRight          (p         ); break; //VT100
     case TY_CSI_PN('D'      ) : _currentScreen->cursorLeft           (p         ); break; //VT100
     case TY_CSI_PN('G'      ) : _currentScreen->setCursorX           (p         ); break; //LINUX
     case TY_CSI_PN('H'      ) : _currentScreen->setCursorYX          (p,      q); break; //VT100
-    case TY_CSI_PN('I'      ) : _currentScreen->Tabulate             (p         ); break;
+    case TY_CSI_PN('I'      ) : _currentScreen->tab                  (p         ); break;
     case TY_CSI_PN('L'      ) : _currentScreen->insertLines          (p         ); break;
     case TY_CSI_PN('M'      ) : _currentScreen->deleteLines          (p         ); break;
     case TY_CSI_PN('P'      ) : _currentScreen->deleteChars          (p         ); break;
     case TY_CSI_PN('S'      ) : _currentScreen->scrollUp             (p         ); break;
     case TY_CSI_PN('T'      ) : _currentScreen->scrollDown           (p         ); break;
     case TY_CSI_PN('X'      ) : _currentScreen->eraseChars           (p         ); break;
-    case TY_CSI_PN('Z'      ) : _currentScreen->backTabulate         (p         ); break;
+    case TY_CSI_PN('Z'      ) : _currentScreen->backtab              (p         ); break;
     case TY_CSI_PN('c'      ) :      reportTerminalType   (          ); break; //VT100
     case TY_CSI_PN('d'      ) : _currentScreen->setCursorY           (p         ); break; //LINUX
     case TY_CSI_PN('f'      ) : _currentScreen->setCursorYX          (p,      q); break; //VT100
     case TY_CSI_PN('r'      ) :      setMargins           (p,      q); break; //VT100
     case TY_CSI_PN('y'      ) : /* IGNORED: Confidence test          */ break; //VT100
 
     case TY_CSI_PR('h',   1) :          setMode      (MODE_AppCuKeys); break; //VT100
     case TY_CSI_PR('l',   1) :        resetMode      (MODE_AppCuKeys); break; //VT100
     case TY_CSI_PR('s',   1) :         saveMode      (MODE_AppCuKeys); break; //FIXME
     case TY_CSI_PR('r',   1) :      restoreMode      (MODE_AppCuKeys); break; //FIXME
 
     case TY_CSI_PR('l',   2) :        resetMode      (MODE_Ansi     ); break; //VT100
 
-    case TY_CSI_PR('h',   3) : clearScreenAndSetColumns(132);          break; //VT100
-    case TY_CSI_PR('l',   3) : clearScreenAndSetColumns(80);           break; //VT100
+    case TY_CSI_PR('h',   3) :          setMode      (MODE_132Columns);break; //VT100
+    case TY_CSI_PR('l',   3) :        resetMode      (MODE_132Columns);break; //VT100
 
     case TY_CSI_PR('h',   4) : /* IGNORED: soft scrolling           */ break; //VT100
     case TY_CSI_PR('l',   4) : /* IGNORED: soft scrolling           */ break; //VT100
 
     case TY_CSI_PR('h',   5) : _currentScreen->    setMode      (MODE_Screen   ); break; //VT100
     case TY_CSI_PR('l',   5) : _currentScreen->  resetMode      (MODE_Screen   ); break; //VT100
 
     case TY_CSI_PR('h',   6) : _currentScreen->    setMode      (MODE_Origin   ); break; //VT100
@@ -683,16 +679,19 @@ switch( N )
     case TY_CSI_PR('s',  12) : /* IGNORED: Cursor blink             */ break; //att610
     case TY_CSI_PR('r',  12) : /* IGNORED: Cursor blink             */ break; //att610
 
     case TY_CSI_PR('h',  25) :          setMode      (MODE_Cursor   ); break; //VT100
     case TY_CSI_PR('l',  25) :        resetMode      (MODE_Cursor   ); break; //VT100
     case TY_CSI_PR('s',  25) :         saveMode      (MODE_Cursor   ); break; //VT100
     case TY_CSI_PR('r',  25) :      restoreMode      (MODE_Cursor   ); break; //VT100
 
+    case TY_CSI_PR('h',  40) :         setMode(MODE_Allow132Columns ); break; // XTERM
+    case TY_CSI_PR('l',  40) :       resetMode(MODE_Allow132Columns ); break; // XTERM
+
     case TY_CSI_PR('h',  41) : /* IGNORED: obsolete more(1) fix     */ break; //XTERM
     case TY_CSI_PR('l',  41) : /* IGNORED: obsolete more(1) fix     */ break; //XTERM
     case TY_CSI_PR('s',  41) : /* IGNORED: obsolete more(1) fix     */ break; //XTERM
     case TY_CSI_PR('r',  41) : /* IGNORED: obsolete more(1) fix     */ break; //XTERM
 
     case TY_CSI_PR('h',  47) :          setMode      (MODE_AppScreen); break; //VT100
     case TY_CSI_PR('l',  47) :        resetMode      (MODE_AppScreen); break; //VT100
     case TY_CSI_PR('s',  47) :         saveMode      (MODE_AppScreen); break; //XTERM
@@ -732,16 +731,18 @@ switch( N )
     case TY_CSI_PR('s', 1002) :         saveMode      (MODE_Mouse1002); break; //XTERM
     case TY_CSI_PR('r', 1002) :      restoreMode      (MODE_Mouse1002); break; //XTERM
 
     case TY_CSI_PR('h', 1003) :          setMode      (MODE_Mouse1003); break; //XTERM
     case TY_CSI_PR('l', 1003) :        resetMode      (MODE_Mouse1003); break; //XTERM
     case TY_CSI_PR('s', 1003) :         saveMode      (MODE_Mouse1003); break; //XTERM
     case TY_CSI_PR('r', 1003) :      restoreMode      (MODE_Mouse1003); break; //XTERM
 
+    case TY_CSI_PR('h', 1034) : /* IGNORED: 8bitinput activation     */ break; //XTERM
+
     case TY_CSI_PR('h', 1047) :          setMode      (MODE_AppScreen); break; //XTERM
     case TY_CSI_PR('l', 1047) : _screen[1]->clearEntireScreen(); resetMode(MODE_AppScreen); break; //XTERM
     case TY_CSI_PR('s', 1047) :         saveMode      (MODE_AppScreen); break; //XTERM
     case TY_CSI_PR('r', 1047) :      restoreMode      (MODE_AppScreen); break; //XTERM
 
     //FIXME: Unitoken: save translations
     case TY_CSI_PR('h', 1048) :      saveCursor           (          ); break; //XTERM
     case TY_CSI_PR('l', 1048) :      restoreCursor        (          ); break; //XTERM
@@ -772,182 +773,150 @@ switch( N )
     case TY_VT52('Y'      ) : _currentScreen->setCursorYX          (p-31,q-31 ); break; //VT52
     case TY_VT52('Z'      ) :      reportTerminalType   (           ); break; //VT52
     case TY_VT52('<'      ) :          setMode      (MODE_Ansi     ); break; //VT52
     case TY_VT52('='      ) :          setMode      (MODE_AppKeyPad); break; //VT52
     case TY_VT52('>'      ) :        resetMode      (MODE_AppKeyPad); break; //VT52
 
     case TY_CSI_PG('c'      ) :  reportSecondaryAttributes(          ); break; //VT100
 
-    default : ReportErrorToken();    break;
+    default: 
+        reportDecodingError();    
+        break;
   };
 }
 
 void Vt102Emulation::clearScreenAndSetColumns(int columnCount)
 {
     setImageSize(_currentScreen->getLines(),columnCount); 
     clearEntireScreen();
     setDefaultMargins(); 
     _currentScreen->setCursorYX(0,0);
 }
 
-/* ------------------------------------------------------------------------- */
-/*                                                                           */
-/*                          Terminal to Host protocol                        */
-/*                                                                           */
-/* ------------------------------------------------------------------------- */
-
-/* 
-   Outgoing bytes originate from several sources:
-
-   - Replies to Enquieries.
-   - Mouse Events
-   - Keyboard Events
-*/
-
-/*!
-*/
-
 void Vt102Emulation::sendString(const char* s , int length)
 {
   if ( length >= 0 )
     emit sendData(s,length);
   else
     emit sendData(s,strlen(s));
 }
 
-// Replies ----------------------------------------------------------------- --
-
-// This section copes with replies send as response to an enquiery control code.
-
-/*!
-*/
-
 void Vt102Emulation::reportCursorPosition()
-{ char tmp[20];
+{ 
+  char tmp[20];
   sprintf(tmp,"\033[%d;%dR",_currentScreen->getCursorY()+1,_currentScreen->getCursorX()+1);
   sendString(tmp);
 }
 
-/*
-   What follows here is rather obsolete and faked stuff.
-   The correspondent enquieries are neverthenless issued.
-*/
-
-/*!
-*/
-
 void Vt102Emulation::reportTerminalType()
 {
   // Primary device attribute response (Request was: ^[[0c or ^[[c (from TT321 Users Guide))
-  //   VT220:  ^[[?63;1;2;3;6;7;8c   (list deps on emul. capabilities)
-  //   VT100:  ^[[?1;2c
-  //   VT101:  ^[[?1;0c
-  //   VT102:  ^[[?6v
+  // VT220:  ^[[?63;1;2;3;6;7;8c   (list deps on emul. capabilities)
+  // VT100:  ^[[?1;2c
+  // VT101:  ^[[?1;0c
+  // VT102:  ^[[?6v
   if (getMode(MODE_Ansi))
-    sendString("\033[?1;2c");     // I'm a VT100
+    sendString("\033[?1;2c"); // I'm a VT100
   else
-    sendString("\033/Z");         // I'm a VT52
+    sendString("\033/Z"); // I'm a VT52
 }
 
 void Vt102Emulation::reportSecondaryAttributes()
 {
   // Seconday device attribute response (Request was: ^[[>0c or ^[[>c)
   if (getMode(MODE_Ansi))
     sendString("\033[>0;115;0c"); // Why 115?  ;)
   else
     sendString("\033/Z");         // FIXME I don't think VT52 knows about it but kept for
                                   // konsoles backward compatibility.
 }
 
 void Vt102Emulation::reportTerminalParms(int p)
 // DECREPTPARM
-{ char tmp[100];
+{ 
+  char tmp[100];
   sprintf(tmp,"\033[%d;1;1;112;112;1;0x",p); // not really true.
   sendString(tmp);
 }
 
-/*!
-*/
-
 void Vt102Emulation::reportStatus()
 {
   sendString("\033[0n"); //VT100. Device status report. 0 = Ready.
 }
 
-/*!
-*/
-
-#define ANSWER_BACK "" // This is really obsolete VT100 stuff.
-
 void Vt102Emulation::reportAnswerBack()
 {
+  // FIXME - Test this with VTTEST
+  // This is really obsolete VT100 stuff.
+  const char* ANSWER_BACK = "";
   sendString(ANSWER_BACK);
 }
 
-// Mouse Handling ---------------------------------------------------------- --
-
 /*!
-    Mouse clicks are possibly reported to the client
-    application if it has issued interest in them.
-    They are normally consumed by the widget for copy
-    and paste, but may be propagated from the widget
-    when gui->setMouseMarks is set via setMode(MODE_Mouse1000).
-
-    `x',`y' are 1-based.
-    `ev' (event) indicates the button pressed (0-2)
-                 or a general mouse release (3).
+    `cx',`cy' are 1-based.
+    `eventType' indicates the button pressed (0-2)
+                or a general mouse release (3).
 
     eventType represents the kind of mouse action that occurred:
-    	0 = Mouse button press or release
-	1 = Mouse drag
+        0 = Mouse button press or release
+        1 = Mouse drag
 */
 
 void Vt102Emulation::sendMouseEvent( int cb, int cx, int cy , int eventType )
-{ char tmp[20];
-  if (  cx<1 || cy<1 ) return;
+{ 
+  if (cx < 1 || cy < 1) 
+    return;
+
   // normal buttons are passed as 0x20 + button,
   // mouse wheel (buttons 4,5) as 0x5c + button
-  if (cb >= 4) cb += 0x3c;
+  if (cb >= 4) 
+    cb += 0x3c;
 
   //Mouse motion handling
-  if ( (getMode(MODE_Mouse1002) || getMode(MODE_Mouse1003)) && eventType == 1 )
-	  cb += 0x20; //add 32 to signify motion event
+  if ((getMode(MODE_Mouse1002) || getMode(MODE_Mouse1003)) && eventType == 1)
+      cb += 0x20; //add 32 to signify motion event
 
-  sprintf(tmp,"\033[M%c%c%c",cb+0x20,cx+0x20,cy+0x20);
-  sendString(tmp);
+  char command[20];
+  sprintf(command,"\033[M%c%c%c",cb+0x20,cx+0x20,cy+0x20);
+  sendString(command);
 }
 
-// Keyboard Handling ------------------------------------------------------- --
-
-#define encodeMode(M,B) BITS(B,getMode(M))
-#define encodeStat(M,B) BITS(B,((ev->modifiers() & (M)) == (M)))
-
 void Vt102Emulation::sendText( const QString& text )
 {
-  if (!text.isEmpty()) {
+  if (!text.isEmpty()) 
+  {
     QKeyEvent event(QEvent::KeyPress, 
                     0, 
                     Qt::NoModifier, 
                     text);
     sendKeyEvent(&event); // expose as a big fat keypress event
   }
-
 }
-
 void Vt102Emulation::sendKeyEvent( QKeyEvent* event )
 {
     Qt::KeyboardModifiers modifiers = event->modifiers();
     KeyboardTranslator::States states = KeyboardTranslator::NoState;
 
     // get current states
-    if ( getMode(MODE_NewLine)  ) states |= KeyboardTranslator::NewLineState;
-    if ( getMode(MODE_Ansi)     ) states |= KeyboardTranslator::AnsiState;
-    if ( getMode(MODE_AppCuKeys)) states |= KeyboardTranslator::CursorKeysState;
-    if ( getMode(MODE_AppScreen)) states |= KeyboardTranslator::AlternateScreenState;
+    if (getMode(MODE_NewLine)  ) states |= KeyboardTranslator::NewLineState;
+    if (getMode(MODE_Ansi)     ) states |= KeyboardTranslator::AnsiState;
+    if (getMode(MODE_AppCuKeys)) states |= KeyboardTranslator::CursorKeysState;
+    if (getMode(MODE_AppScreen)) states |= KeyboardTranslator::AlternateScreenState;
+    if (getMode(MODE_AppKeyPad) && (modifiers & Qt::KeypadModifier)) 
+        states |= KeyboardTranslator::ApplicationKeypadState;
+
+    // check flow control state
+    if (modifiers & Qt::ControlModifier)
+    {
+        if (event->key() == Qt::Key_S)
+            emit flowControlKeyPressed(true);
+        else if (event->key() == Qt::Key_Q)
+            emit flowControlKeyPressed(false);
+    }
 
     // lookup key binding
     if ( _keyTranslator )
     {
     KeyboardTranslator::Entry entry = _keyTranslator->findEntry( 
                                                 event->key() , 
                                                 modifiers,
                                                 states );
@@ -955,48 +924,49 @@ void Vt102Emulation::sendKeyEvent( QKeyE
         // send result to terminal
         QByteArray textToSend;
 
         // special handling for the Alt (aka. Meta) modifier.  pressing
         // Alt+[Character] results in Esc+[Character] being sent
         // (unless there is an entry defined for this particular combination
         //  in the keyboard modifier)
         bool wantsAltModifier = entry.modifiers() & entry.modifierMask() & Qt::AltModifier;
-		bool wantsAnyModifier = entry.state() & entry.stateMask() & KeyboardTranslator::AnyModifierState;
+        bool wantsAnyModifier = entry.state() & 
+                                entry.stateMask() & KeyboardTranslator::AnyModifierState;
 
         if ( modifiers & Qt::AltModifier && !(wantsAltModifier || wantsAnyModifier) 
              && !event->text().isEmpty() )
         {
             textToSend.prepend("\033");
         }
 
         if ( entry.command() != KeyboardTranslator::NoCommand )
         {
-			if (entry.command() & KeyboardTranslator::EraseCommand)
-				textToSend += getErase();
+            if (entry.command() & KeyboardTranslator::EraseCommand)
+                textToSend += eraseChar();
+
             // TODO command handling
         }
         else if ( !entry.text().isEmpty() ) 
         {
             textToSend += _codec->fromUnicode(entry.text(true,modifiers));
         }
         else
             textToSend += _codec->fromUnicode(event->text());
 
         sendData( textToSend.constData() , textToSend.length() );
     }
     else
     {
         // print an error message to the terminal if no key translator has been
         // set
-        QString translatorError =  ("No keyboard translator available.  "
+        QString translatorError =  i18n("No keyboard translator available.  "
                                          "The information needed to convert key presses "
                                          "into characters to send to the terminal " 
                                          "is missing.");
-
         reset();
         receiveData( translatorError.toAscii().constData() , translatorError.count() );
     }
 }
 
 /* ------------------------------------------------------------------------- */
 /*                                                                           */
 /*                                VT100 Charsets                             */
@@ -1023,36 +993,36 @@ void Vt102Emulation::sendKeyEvent( QKeyE
 
 #define CHARSET _charset[_currentScreen==_screen[1]]
 
 // Apply current character map.
 
 unsigned short Vt102Emulation::applyCharset(unsigned short c)
 {
   if (CHARSET.graphic && 0x5f <= c && c <= 0x7e) return vt100_graphics[c-0x5f];
-  if (CHARSET.pound                && c == '#' ) return 0xa3; //This mode is obsolete
+  if (CHARSET.pound && c == '#' ) return 0xa3; //This mode is obsolete
   return c;
 }
 
 /*
    "Charset" related part of the emulation state.
-   This configures the VT100 _charset filter.
+   This configures the VT100 charset filter.
 
    While most operation work on the current _screen,
    the following two are different.
 */
 
 void Vt102Emulation::resetCharset(int scrno)
 {
-  _charset[scrno].cu_cs   = 0;
+  _charset[scrno].cu_cs = 0;
   strncpy(_charset[scrno].charset,"BBBB",4);
   _charset[scrno].sa_graphic = false;
-  _charset[scrno].sa_pound   = false;
+  _charset[scrno].sa_pound = false;
   _charset[scrno].graphic = false;
-  _charset[scrno].pound   = false;
+  _charset[scrno].pound = false;
 }
 
 void Vt102Emulation::setCharset(int n, int cs) // on both screens.
 {
   _charset[0].charset[n&3] = cs; useCharset(_charset[0].cu_cs);
   _charset[1].charset[n&3] = cs; useCharset(_charset[1].cu_cs);
 }
 
@@ -1066,40 +1036,36 @@ void Vt102Emulation::useCharset(int n)
 {
   CHARSET.cu_cs   = n&3;
   CHARSET.graphic = (CHARSET.charset[n&3] == '0');
   CHARSET.pound   = (CHARSET.charset[n&3] == 'A'); //This mode is obsolete
 }
 
 void Vt102Emulation::setDefaultMargins()
 {
-	_screen[0]->setDefaultMargins();
-	_screen[1]->setDefaultMargins();
+    _screen[0]->setDefaultMargins();
+    _screen[1]->setDefaultMargins();
 }
 
 void Vt102Emulation::setMargins(int t, int b)
 {
   _screen[0]->setMargins(t, b);
   _screen[1]->setMargins(t, b);
 }
 
-/*! Save the cursor position and the rendition attribute settings. */
-
 void Vt102Emulation::saveCursor()
 {
   CHARSET.sa_graphic = CHARSET.graphic;
   CHARSET.sa_pound   = CHARSET.pound; //This mode is obsolete
   // we are not clear about these
   //sa_charset = charsets[cScreen->_charset];
   //sa_charset_num = cScreen->_charset;
   _currentScreen->saveCursor();
 }
 
-/*! Restore the cursor position and the rendition attribute settings. */
-
 void Vt102Emulation::restoreCursor()
 {
   CHARSET.graphic = CHARSET.sa_graphic;
   CHARSET.pound   = CHARSET.sa_pound; //This mode is obsolete
   _currentScreen->restoreCursor();
 }
 
 /* ------------------------------------------------------------------------- */
@@ -1119,136 +1085,135 @@ void Vt102Emulation::restoreCursor()
 
    We decided on the precise precise extend, somehow.
 */
 
 // "Mode" related part of the state. These are all booleans.
 
 void Vt102Emulation::resetModes()
 {
-  resetMode(MODE_Mouse1000); saveMode(MODE_Mouse1000);
-  resetMode(MODE_Mouse1001); saveMode(MODE_Mouse1001);
-  resetMode(MODE_Mouse1002); saveMode(MODE_Mouse1002);
-  resetMode(MODE_Mouse1003); saveMode(MODE_Mouse1003);
+  // MODE_Allow132Columns is not reset here
+  // to match Xterm's behaviour (see Xterm's VTReset() function)
 
-  resetMode(MODE_AppScreen); saveMode(MODE_AppScreen);
-  // here come obsolete modes
-  resetMode(MODE_AppCuKeys); saveMode(MODE_AppCuKeys);
-  resetMode(MODE_NewLine  );
-    setMode(MODE_Ansi     );
+  resetMode(MODE_132Columns); saveMode(MODE_132Columns);
+  resetMode(MODE_Mouse1000);  saveMode(MODE_Mouse1000);
+  resetMode(MODE_Mouse1001);  saveMode(MODE_Mouse1001);
+  resetMode(MODE_Mouse1002);  saveMode(MODE_Mouse1002);
+  resetMode(MODE_Mouse1003);  saveMode(MODE_Mouse1003);
+
+  resetMode(MODE_AppScreen);  saveMode(MODE_AppScreen);
+  resetMode(MODE_AppCuKeys);  saveMode(MODE_AppCuKeys);
+  resetMode(MODE_AppKeyPad);  saveMode(MODE_AppKeyPad);
+  resetMode(MODE_NewLine);
+  setMode(MODE_Ansi);
 }
 
 void Vt102Emulation::setMode(int m)
 {
-  _currParm.mode[m] = true;
+  _currentModes.mode[m] = true;
   switch (m)
   {
+    case MODE_132Columns:
+        if (getMode(MODE_Allow132Columns))
+            clearScreenAndSetColumns(132);
+        else
+            _currentModes.mode[m] = false;
+        break;
     case MODE_Mouse1000:
     case MODE_Mouse1001:
     case MODE_Mouse1002:
     case MODE_Mouse1003:
- 	    emit programUsesMouseChanged(false); 
+         emit programUsesMouseChanged(false); 
     break;
 
     case MODE_AppScreen : _screen[1]->clearSelection();
                           setScreen(1);
     break;
   }
   if (m < MODES_SCREEN || m == MODE_NewLine)
   {
     _screen[0]->setMode(m);
     _screen[1]->setMode(m);
   }
 }
 
 void Vt102Emulation::resetMode(int m)
 {
-  _currParm.mode[m] = false;
+  _currentModes.mode[m] = false;
   switch (m)
   {
+    case MODE_132Columns:
+        if (getMode(MODE_Allow132Columns))
+            clearScreenAndSetColumns(80);
+        break;
     case MODE_Mouse1000 : 
     case MODE_Mouse1001 :
     case MODE_Mouse1002 :
     case MODE_Mouse1003 :
-	    emit programUsesMouseChanged(true); 
+        emit programUsesMouseChanged(true); 
     break;
 
-    case MODE_AppScreen : _screen[0]->clearSelection();
-                          setScreen(0);
+    case MODE_AppScreen : 
+        _screen[0]->clearSelection();
+        setScreen(0);
     break;
   }
   if (m < MODES_SCREEN || m == MODE_NewLine)
   {
     _screen[0]->resetMode(m);
     _screen[1]->resetMode(m);
   }
 }
 
 void Vt102Emulation::saveMode(int m)
 {
-  _saveParm.mode[m] = _currParm.mode[m];
+  _savedModes.mode[m] = _currentModes.mode[m];
 }
 
 void Vt102Emulation::restoreMode(int m)
 {
-  if (_saveParm.mode[m]) 
+  if (_savedModes.mode[m]) 
       setMode(m); 
   else 
       resetMode(m);
 }
 
 bool Vt102Emulation::getMode(int m)
 {
-  return _currParm.mode[m];
+  return _currentModes.mode[m];
 }
 
-char Vt102Emulation::getErase() const
+char Vt102Emulation::eraseChar() const
 {
   KeyboardTranslator::Entry entry = _keyTranslator->findEntry(
                                             Qt::Key_Backspace,
                                             0,
                                             0);
   if ( entry.text().count() > 0 )
       return entry.text()[0];
   else
       return '\b';
 }
 
-/* ------------------------------------------------------------------------- */
-/*                                                                           */
-/*                               Diagnostic                                  */
-/*                                                                           */
-/* ------------------------------------------------------------------------- */
-
-/*! shows the contents of the scan buffer.
-
-    This functions is used for diagnostics. It is called by \e ReportErrorToken
-    to inform about strings that cannot be decoded or handled by the emulation.
-
-    \sa ReportErrorToken
-*/
-
+// print contents of the scan buffer
 static void hexdump(int* s, int len)
 { int i;
   for (i = 0; i < len; i++)
   {
     if (s[i] == '\\')
       printf("\\\\");
     else
     if ((s[i]) > 32 && s[i] < 127)
       printf("%c",s[i]);
     else
       printf("\\%04x(hex)",s[i]);
   }
 }
 
-void Vt102Emulation::scan_buffer_report()
+void Vt102Emulation::reportDecodingError()
 {
-  if (ppos == 0 || ppos == 1 && (pbuf[0] & 0xff) >= 32) return;
-  printf("token: "); hexdump(pbuf,ppos); printf("\n");
+  if (tokenBufferPos == 0 || ( tokenBufferPos == 1 && (tokenBuffer[0] & 0xff) >= 32) ) 
+    return;
+  printf("Undecodable sequence: "); 
+  hexdump(tokenBuffer,tokenBufferPos); 
+  printf("\n");
 }
 
-void Vt102Emulation::ReportErrorToken()
-{
-#ifndef NDEBUG
-  printf("undecodable "); scan_buffer_report();
-#endif
-}
diff --git a/gui//src/Vt102Emulation.h b/gui//src/Vt102Emulation.h
--- a/gui//src/Vt102Emulation.h
+++ b/gui//src/Vt102Emulation.h
@@ -1,15 +1,13 @@
 /*
     This file is part of Konsole, an X terminal.
     
-    Copyright (C) 2007 by Robert Knight <robertknight@gmail.com>
-    Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
-
-    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+    Copyright 2007-2008 by Robert Knight <robertknight@gmail.com>
+    Copyright 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
 
     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 2 of the License, or
     (at your option) any later version.
 
     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -32,30 +30,27 @@
 #include <QtGui/QKeyEvent>
 #include <QtCore/QHash>
 #include <QtCore/QTimer>
 
 // Konsole
 #include "Emulation.h"
 #include "Screen.h"
 
-#define MODE_AppScreen (MODES_SCREEN+0)
-#define MODE_AppCuKeys (MODES_SCREEN+1)
-#define MODE_AppKeyPad (MODES_SCREEN+2)
-#define MODE_Mouse1000 (MODES_SCREEN+3)
-#define MODE_Mouse1001 (MODES_SCREEN+4)
-#define MODE_Mouse1002 (MODES_SCREEN+5)
-#define MODE_Mouse1003 (MODES_SCREEN+6)
-#define MODE_Ansi      (MODES_SCREEN+7)
-#define MODE_total     (MODES_SCREEN+8)
-
-struct DECpar
-{
-  bool mode[MODE_total];
-};
+#define MODE_AppScreen       (MODES_SCREEN+0)   // Mode #1
+#define MODE_AppCuKeys       (MODES_SCREEN+1)   // Application cursor keys (DECCKM)
+#define MODE_AppKeyPad       (MODES_SCREEN+2)   // 
+#define MODE_Mouse1000       (MODES_SCREEN+3)   // Send mouse X,Y position on press and release
+#define MODE_Mouse1001       (MODES_SCREEN+4)   // Use Hilight mouse tracking
+#define MODE_Mouse1002       (MODES_SCREEN+5)   // Use cell motion mouse tracking
+#define MODE_Mouse1003       (MODES_SCREEN+6)   // Use all motion mouse tracking 
+#define MODE_Ansi            (MODES_SCREEN+7)   // Use US Ascii for character sets G0-G3 (DECANM) 
+#define MODE_132Columns      (MODES_SCREEN+8)   // 80 <-> 132 column mode switch (DECCOLM)
+#define MODE_Allow132Columns (MODES_SCREEN+9)   // Allow DECCOLM mode
+#define MODE_total           (MODES_SCREEN+10)
 
 struct CharCodes
 {
   // coding info
   char charset[4]; //
   int  cu_cs;      // actual charset.
   bool graphic;    // Some VT100 tricks
   bool pound  ;    // Some VT100 tricks
@@ -73,52 +68,43 @@ struct CharCodes
  * sequences. 
  *
  */
 class Vt102Emulation : public Emulation
 { 
 Q_OBJECT
 
 public:
-
   /** Constructs a new emulation */
   Vt102Emulation();
   ~Vt102Emulation();
   
-  // reimplemented
+  // reimplemented from Emulation
   virtual void clearEntireScreen();
   virtual void reset();
-  
-  // reimplemented
-  virtual char getErase() const;
+  virtual char eraseChar() const;
   
 public slots: 
-
-  // reimplemented 
+  // reimplemented from Emulation 
   virtual void sendString(const char*,int length = -1);
   virtual void sendText(const QString& text);
   virtual void sendKeyEvent(QKeyEvent*);
-  virtual void sendMouseEvent( int buttons, int column, int line , int eventType );
+  virtual void sendMouseEvent(int buttons, int column, int line, int eventType);
   
 protected:
-  // reimplemented
-  virtual void setMode    (int mode);
-  virtual void resetMode  (int mode);
-
-  // reimplemented 
+  // reimplemented from Emulation
+  virtual void setMode(int mode);
+  virtual void resetMode(int mode);
   virtual void receiveChar(int cc);
   
-
 private slots:
-		
   //causes changeTitle() to be emitted for each (int,QString) pair in pendingTitleUpdates
   //used to buffer multiple title updates
   void updateTitle();
 
-
 private:
   unsigned short applyCharset(unsigned short c);
   void setCharset(int n, int cs);
   void useCharset(int n);
   void setAndUseCharset(int n, int cs);
   void saveCursor();
   void restoreCursor();
   void resetCharset(int scrno);
@@ -129,36 +115,40 @@ private:
 
   // returns true if 'mode' is set or false otherwise
   bool getMode    (int mode);
   // saves the current boolean value of 'mode'
   void saveMode   (int mode);
   // restores the boolean value of 'mode' 
   void restoreMode(int mode);
   // resets all modes
+  // (except MODE_Allow132Columns)
   void resetModes();
 
-  void resetToken();
-#define MAXPBUF 80
-  void pushToToken(int cc);
-  int pbuf[MAXPBUF]; //FIXME: overflow?
-  int ppos;
+  void resetTokenizer();
+  #define MAX_TOKEN_LENGTH 80
+  void addToCurrentToken(int cc);
+  int tokenBuffer[MAX_TOKEN_LENGTH]; //FIXME: overflow?
+  int tokenBufferPos;
 #define MAXARGS 15
   void addDigit(int dig);
   void addArgument();
   int argv[MAXARGS];
   int argc;
   void initTokenizer();
-  int tbl[256];
 
-  void scan_buffer_report(); //FIXME: rename
-  void ReportErrorToken();   //FIXME: rename
+  // Set of flags for each of the ASCII characters which indicates
+  // what category they fall into (printable character, control, digit etc.)
+  // for the purposes of decoding terminal output
+  int charClass[256];
 
-  void tau(int code, int p, int q);
-  void XtermHack();
+  void reportDecodingError(); 
+
+  void processToken(int code, int p, int q);
+  void processWindowAttributeChange();
 
   void reportTerminalType();
   void reportSecondaryAttributes();
   void reportStatus();
   void reportAnswerBack();
   void reportCursorPosition();
   void reportTerminalParms(int p);
 
@@ -166,21 +156,31 @@ private:
   void scrollLock(const bool lock);
 
   // clears the screen and resizes it to the specified
   // number of columns
   void clearScreenAndSetColumns(int columnCount);
 
   CharCodes _charset[2];
 
-  DECpar _currParm;
-  DECpar _saveParm;
+  class TerminalState
+  {
+  public:
+    // Initializes all modes to false
+    TerminalState()
+    { memset(&mode,false,MODE_total * sizeof(bool)); }
+
+    bool mode[MODE_total];
+  };
+
+  TerminalState _currentModes;
+  TerminalState _savedModes;
 
   //hash table and timer for buffering calls to the session instance 
   //to update the name of the session
   //or window title.
   //these calls occur when certain escape sequences are seen in the 
   //output from the terminal
   QHash<int,QString> _pendingTitleUpdates;
   QTimer* _titleUpdateTimer;
-  
 };
+
 #endif // VT102EMULATION_H
diff --git a/gui//src/k3process.cpp b/gui//src/k3process.cpp
--- a/gui//src/k3process.cpp
+++ b/gui//src/k3process.cpp
@@ -59,17 +59,18 @@
 #include <string.h>
 #include <unistd.h>
 #include <pwd.h>
 #include <grp.h>
 
 #include <QtCore/QMap>
 #include <QtCore/QFile>
 #include <QtCore/QSocketNotifier>
-
+#include <QStringList>
+#include <QDebug>
 //#include <kdebug.h>
 //#include <kstandarddirs.h>
 //#include <kuser.h>
 
 
 //////////////////
 // private data //
 //////////////////
diff --git a/gui//src/kdecore_export.h b/gui//src/kdecore_export.h
new file mode 100644
--- /dev/null
+++ b/gui//src/kdecore_export.h
@@ -0,0 +1,46 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2007 David Faure <faure@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef KDECORE_EXPORT_H
+#define KDECORE_EXPORT_H
+
+/* needed for KDE_EXPORT and KDE_IMPORT macros */
+//#include <kdemacros.h>
+#define KDE_EXPORT
+#define KDE_IMPORT
+#define KDE_DEPRECATED
+
+#ifndef KDECORE_EXPORT
+# if defined(KDELIBS_STATIC_LIBS)
+   /* No export/import for static libraries */
+#  define KDECORE_EXPORT
+# elif defined(MAKE_KDECORE_LIB)
+   /* We are building this library */ 
+#  define KDECORE_EXPORT KDE_EXPORT
+# else
+   /* We are using this library */ 
+#  define KDECORE_EXPORT KDE_IMPORT
+# endif
+#endif
+
+# ifndef KDECORE_EXPORT_DEPRECATED
+#  define KDECORE_EXPORT_DEPRECATED KDE_DEPRECATED KDECORE_EXPORT
+# endif
+
+#endif
diff --git a/gui//src/konsole_export.h b/gui//src/konsole_export.h
new file mode 100644
--- /dev/null
+++ b/gui//src/konsole_export.h
@@ -0,0 +1,67 @@
+/*
+    This file is part of the KDE project
+    Copyright (C) 2009 Patrick Spendrin <ps_ml@gmx.de>
+
+    This library is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+#ifndef KONSOLE_EXPORT_H
+#define KONSOLE_EXPORT_H
+
+/* needed for KDE_EXPORT macros */
+//#include <kdemacros.h>
+#include <QtCore/qglobal.h>
+#define KDE_EXPORT
+#define KDE_IMPORT
+
+#ifndef KONSOLEPRIVATE_EXPORT
+# if defined(MAKE_KONSOLEPRIVATE_LIB)
+   /* We are building this library */
+#  define KONSOLEPRIVATE_EXPORT KDE_EXPORT
+# else
+   /* We are using this library */
+#  define KONSOLEPRIVATE_EXPORT KDE_IMPORT
+# endif
+#endif
+
+#include <iostream>
+//#define kWarning(x) std::cout
+
+#include <stdio.h>
+
+//#define i18n 
+inline QString i18n(char *buff,...)
+{
+  char msg[2048];
+    va_list arglist;
+
+    va_start(arglist,buff);
+
+    snprintf(msg,2048,buff, arglist);
+
+    va_end(arglist);
+
+    return QString(msg);
+}
+
+#define i18nc 
+
+
+//#define KDE_fseek ::fseek
+//#define KDE_lseek ::lseek
+
+
+#endif
diff --git a/gui//src/kprocess.cpp b/gui//src/kprocess.cpp
new file mode 100644
--- /dev/null
+++ b/gui//src/kprocess.cpp
@@ -0,0 +1,416 @@
+/*
+    This file is part of the KDE libraries
+
+    Copyright (C) 2007 Oswald Buddenhagen <ossi@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#include "kprocess_p.h"
+
+//#include <kstandarddirs.h>
+//#include <kshell.h>
+//#ifdef Q_OS_WIN
+//# include <kshell_p.h>
+//#endif
+
+#include <qfile.h>
+
+#ifdef Q_OS_WIN
+# include <windows.h>
+#else
+# include <unistd.h>
+# include <errno.h>
+#endif
+
+#ifndef Q_OS_WIN
+# define STD_OUTPUT_HANDLE 1
+# define STD_ERROR_HANDLE 2
+#endif
+
+#ifdef _WIN32_WCE
+#include <stdio.h>
+#endif
+
+void KProcessPrivate::writeAll(const QByteArray &buf, int fd)
+{
+#ifdef Q_OS_WIN
+#ifndef _WIN32_WCE
+    HANDLE h = GetStdHandle(fd);
+    if (h) {
+        DWORD wr;
+        WriteFile(h, buf.data(), buf.size(), &wr, 0);
+    }
+#else
+    fwrite(buf.data(), 1, buf.size(), (FILE*)fd);
+#endif
+#else
+    int off = 0;
+    do {
+        int ret = ::write(fd, buf.data() + off, buf.size() - off);
+        if (ret < 0) {
+            if (errno != EINTR)
+                return;
+        } else {
+            off += ret;
+        }
+    } while (off < buf.size());
+#endif
+}
+
+void KProcessPrivate::forwardStd(KProcess::ProcessChannel good, int fd)
+{
+    Q_Q(KProcess);
+
+    QProcess::ProcessChannel oc = q->readChannel();
+    q->setReadChannel(good);
+    writeAll(q->readAll(), fd);
+    q->setReadChannel(oc);
+}
+
+void KProcessPrivate::_k_forwardStdout()
+{
+#ifndef _WIN32_WCE
+    forwardStd(KProcess::StandardOutput, STD_OUTPUT_HANDLE);
+#else
+    forwardStd(KProcess::StandardOutput, (int)stdout);
+#endif
+}
+
+void KProcessPrivate::_k_forwardStderr()
+{
+#ifndef _WIN32_WCE
+    forwardStd(KProcess::StandardError, STD_ERROR_HANDLE);
+#else
+    forwardStd(KProcess::StandardError, (int)stderr);
+#endif
+}
+
+/////////////////////////////
+// public member functions //
+/////////////////////////////
+
+KProcess::KProcess(QObject *parent) :
+    QProcess(parent),
+    d_ptr(new KProcessPrivate)
+{
+    d_ptr->q_ptr = this;
+    setOutputChannelMode(ForwardedChannels);
+}
+
+KProcess::KProcess(KProcessPrivate *d, QObject *parent) :
+    QProcess(parent),
+    d_ptr(d)
+{
+    d_ptr->q_ptr = this;
+    setOutputChannelMode(ForwardedChannels);
+}
+
+KProcess::~KProcess()
+{
+    delete d_ptr;
+}
+
+void KProcess::setOutputChannelMode(OutputChannelMode mode)
+{
+    Q_D(KProcess);
+
+    d->outputChannelMode = mode;
+    disconnect(this, SIGNAL(readyReadStandardOutput()));
+    disconnect(this, SIGNAL(readyReadStandardError()));
+    switch (mode) {
+    case OnlyStdoutChannel:
+        connect(this, SIGNAL(readyReadStandardError()), SLOT(_k_forwardStderr()));
+        break;
+    case OnlyStderrChannel:
+        connect(this, SIGNAL(readyReadStandardOutput()), SLOT(_k_forwardStdout()));
+        break;
+    default:
+        QProcess::setProcessChannelMode((ProcessChannelMode)mode);
+        return;
+    }
+    QProcess::setProcessChannelMode(QProcess::SeparateChannels);
+}
+
+KProcess::OutputChannelMode KProcess::outputChannelMode() const
+{
+    Q_D(const KProcess);
+
+    return d->outputChannelMode;
+}
+
+void KProcess::setNextOpenMode(QIODevice::OpenMode mode)
+{
+    Q_D(KProcess);
+
+    d->openMode = mode;
+}
+
+#define DUMMYENV "_KPROCESS_DUMMY_="
+
+void KProcess::clearEnvironment()
+{
+    setEnvironment(QStringList() << QString::fromLatin1(DUMMYENV));
+}
+
+void KProcess::setEnv(const QString &name, const QString &value, bool overwrite)
+{
+    QStringList env = environment();
+    if (env.isEmpty()) {
+        env = systemEnvironment();
+        env.removeAll(QString::fromLatin1(DUMMYENV));
+    }
+    QString fname(name);
+    fname.append(QLatin1Char('='));
+    for (QStringList::Iterator it = env.begin(); it != env.end(); ++it)
+        if ((*it).startsWith(fname)) {
+            if (overwrite) {
+                *it = fname.append(value);
+                setEnvironment(env);
+            }
+            return;
+        }
+    env.append(fname.append(value));
+    setEnvironment(env);
+}
+
+void KProcess::unsetEnv(const QString &name)
+{
+    QStringList env = environment();
+    if (env.isEmpty()) {
+        env = systemEnvironment();
+        env.removeAll(QString::fromLatin1(DUMMYENV));
+    }
+    QString fname(name);
+    fname.append(QLatin1Char('='));
+    for (QStringList::Iterator it = env.begin(); it != env.end(); ++it)
+        if ((*it).startsWith(fname)) {
+            env.erase(it);
+            if (env.isEmpty())
+                env.append(QString::fromLatin1(DUMMYENV));
+            setEnvironment(env);
+            return;
+        }
+}
+
+void KProcess::setProgram(const QString &exe, const QStringList &args)
+{
+    Q_D(KProcess);
+
+    d->prog = exe;
+    d->args = args;
+#ifdef Q_OS_WIN
+    setNativeArguments(QString());
+#endif
+}
+
+void KProcess::setProgram(const QStringList &argv)
+{
+    Q_D(KProcess);
+
+    Q_ASSERT( !argv.isEmpty() );
+    d->args = argv;
+    d->prog = d->args.takeFirst();
+#ifdef Q_OS_WIN
+    setNativeArguments(QString());
+#endif
+}
+
+KProcess &KProcess::operator<<(const QString &arg)
+{
+    Q_D(KProcess);
+
+    if (d->prog.isEmpty())
+        d->prog = arg;
+    else
+        d->args << arg;
+    return *this;
+}
+
+KProcess &KProcess::operator<<(const QStringList &args)
+{
+    Q_D(KProcess);
+
+    if (d->prog.isEmpty())
+        setProgram(args);
+    else
+        d->args << args;
+    return *this;
+}
+
+void KProcess::clearProgram()
+{
+    Q_D(KProcess);
+
+    d->prog.clear();
+    d->args.clear();
+#ifdef Q_OS_WIN
+    setNativeArguments(QString());
+#endif
+}
+
+void KProcess::setShellCommand(const QString &cmd)
+{
+    Q_D(KProcess);
+
+    // JPS: commented out because I didn't want to pull in KShell also.  It
+    // seems this is mostly for handling program arguments, which I won't be
+    // using.
+    /*
+    KShell::Errors err;
+    d->args = KShell::splitArgs(
+            cmd, KShell::AbortOnMeta | KShell::TildeExpand, &err);
+    if (err == KShell::NoError && !d->args.isEmpty()) {
+        d->prog = KStandardDirs::findExe(d->args[0]);
+        if (!d->prog.isEmpty()) {
+            d->args.removeFirst();
+#ifdef Q_OS_WIN
+            setNativeArguments(QString());
+#endif
+            return;
+        }
+    }
+    */
+
+    d->args.clear();
+
+#ifdef Q_OS_UNIX
+// #ifdef NON_FREE // ... as they ship non-POSIX /bin/sh
+# if !defined(__linux__) && !defined(__FreeBSD__) && !defined(__NetBSD__) && !defined(__OpenBSD__) && !defined(__DragonFly__) && !defined(__GNU__)
+    // If /bin/sh is a symlink, we can be pretty sure that it points to a
+    // POSIX shell - the original bourne shell is about the only non-POSIX
+    // shell still in use and it is always installed natively as /bin/sh.
+    /*
+    d->prog = QFile::symLinkTarget(QString::fromLatin1("/bin/sh"));
+    if (d->prog.isEmpty()) {
+        // Try some known POSIX shells.
+        d->prog = KStandardDirs::findExe(QString::fromLatin1("ksh"));
+        if (d->prog.isEmpty()) {
+            d->prog = KStandardDirs::findExe(QString::fromLatin1("ash"));
+            if (d->prog.isEmpty()) {
+                d->prog = KStandardDirs::findExe(QString::fromLatin1("bash"));
+                if (d->prog.isEmpty()) {
+                    d->prog = KStandardDirs::findExe(QString::fromLatin1("zsh"));
+                    if (d->prog.isEmpty())
+                        // We're pretty much screwed, to be honest ...
+                        d->prog = QString::fromLatin1("/bin/sh");
+                }
+            }
+        }
+     }
+*/
+# else
+    d->prog = QString::fromLatin1("/bin/sh");
+# endif
+
+    d->args << QString::fromLatin1("-c") << cmd;
+#else // Q_OS_UNIX
+    // KMacroExpander::expandMacrosShellQuote(), KShell::quoteArg() and
+    // KShell::joinArgs() may generate these for security reasons.
+    setEnv(PERCENT_VARIABLE, QLatin1String("%"));
+
+#ifndef _WIN32_WCE
+    WCHAR sysdir[MAX_PATH + 1];
+    UINT size = GetSystemDirectoryW(sysdir, MAX_PATH + 1);
+    d->prog = QString::fromUtf16((const ushort *) sysdir, size);
+    d->prog += QLatin1String("\\cmd.exe");
+    setNativeArguments(QLatin1String("/V:OFF /S /C \"") + cmd + QLatin1Char('"'));
+#else
+    d->prog = QLatin1String("\\windows\\cmd.exe");
+    setNativeArguments(QLatin1String("/S /C \"") + cmd + QLatin1Char('"'));
+#endif
+#endif
+}
+
+QStringList KProcess::program() const
+{
+    Q_D(const KProcess);
+
+    QStringList argv = d->args;
+    argv.prepend(d->prog);
+    return argv;
+}
+
+void KProcess::start()
+{
+    Q_D(KProcess);
+
+    QProcess::start(d->prog, d->args, d->openMode);
+}
+
+int KProcess::execute(int msecs)
+{
+    start();
+    if (!waitForFinished(msecs)) {
+        kill();
+        waitForFinished(-1);
+        return -2;
+    }
+    return (exitStatus() == QProcess::NormalExit) ? exitCode() : -1;
+}
+
+// static
+int KProcess::execute(const QString &exe, const QStringList &args, int msecs)
+{
+    KProcess p;
+    p.setProgram(exe, args);
+    return p.execute(msecs);
+}
+
+// static
+int KProcess::execute(const QStringList &argv, int msecs)
+{
+    KProcess p;
+    p.setProgram(argv);
+    return p.execute(msecs);
+}
+
+int KProcess::startDetached()
+{
+    Q_D(KProcess);
+
+    qint64 pid;
+    if (!QProcess::startDetached(d->prog, d->args, workingDirectory(), &pid))
+        return 0;
+    return (int) pid;
+}
+
+// static
+int KProcess::startDetached(const QString &exe, const QStringList &args)
+{
+    qint64 pid;
+    if (!QProcess::startDetached(exe, args, QString(), &pid))
+        return 0;
+    return (int) pid;
+}
+
+// static
+int KProcess::startDetached(const QStringList &argv)
+{
+    QStringList args = argv;
+    QString prog = args.takeFirst();
+    return startDetached(prog, args);
+}
+
+int KProcess::pid() const
+{
+#ifdef Q_OS_UNIX
+    return (int) QProcess::pid();
+#else
+    return QProcess::pid() ? QProcess::pid()->dwProcessId : 0;
+#endif
+}
+
diff --git a/gui//src/kprocess.h b/gui//src/kprocess.h
new file mode 100644
--- /dev/null
+++ b/gui//src/kprocess.h
@@ -0,0 +1,341 @@
+/*
+    This file is part of the KDE libraries
+
+    Copyright (C) 2007 Oswald Buddenhagen <ossi@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef KPROCESS_H
+#define KPROCESS_H
+
+#include "kdecore_export.h"
+
+#include <QtCore/QProcess>
+
+class KProcessPrivate;
+
+/**
+ * \class KProcess kprocess.h <KProcess>
+ * 
+ * Child process invocation, monitoring and control.
+ *
+ * This class extends QProcess by some useful functionality, overrides
+ * some defaults with saner values and wraps parts of the API into a more
+ * accessible one.
+ * This is the preferred way of spawning child processes in KDE; don't
+ * use QProcess directly.
+ *
+ * @author Oswald Buddenhagen <ossi@kde.org>
+ **/
+class KProcess : public QProcess
+{
+    Q_OBJECT
+    Q_DECLARE_PRIVATE(KProcess)
+
+public:
+
+    /**
+     * Modes in which the output channels can be opened.
+     */
+    enum OutputChannelMode {
+        SeparateChannels = QProcess::SeparateChannels,
+            /**< Standard output and standard error are handled by KProcess
+                 as separate channels */
+        MergedChannels = QProcess::MergedChannels,
+            /**< Standard output and standard error are handled by KProcess
+                 as one channel */
+        ForwardedChannels = QProcess::ForwardedChannels,
+            /**< Both standard output and standard error are forwarded
+                 to the parent process' respective channel */
+        OnlyStdoutChannel,
+            /**< Only standard output is handled; standard error is forwarded */
+        OnlyStderrChannel  /**< Only standard error is handled; standard output is forwarded */
+    };
+
+    /**
+     * Constructor
+     */
+    explicit KProcess(QObject *parent = 0);
+
+    /**
+     * Destructor
+     */
+    virtual ~KProcess();
+
+    /**
+     * Set how to handle the output channels of the child process.
+     *
+     * The default is ForwardedChannels, which is unlike in QProcess.
+     * Do not request more than you actually handle, as this output is
+     * simply lost otherwise.
+     *
+     * This function must be called before starting the process.
+     *
+     * @param mode the output channel handling mode
+     */
+    void setOutputChannelMode(OutputChannelMode mode);
+
+    /**
+     * Query how the output channels of the child process are handled.
+     *
+     * @return the output channel handling mode
+     */
+    OutputChannelMode outputChannelMode() const;
+
+    /**
+     * Set the QIODevice open mode the process will be opened in.
+     *
+     * This function must be called before starting the process, obviously.
+     *
+     * @param mode the open mode. Note that this mode is automatically
+     *   "reduced" according to the channel modes and redirections.
+     *   The default is QIODevice::ReadWrite.
+     */
+    void setNextOpenMode(QIODevice::OpenMode mode);
+
+    /**
+     * Adds the variable @p name to the process' environment.
+     *
+     * This function must be called before starting the process.
+     *
+     * @param name the name of the environment variable
+     * @param value the new value for the environment variable
+     * @param overwrite if @c false and the environment variable is already
+     *   set, the old value will be preserved
+     */
+    void setEnv(const QString &name, const QString &value, bool overwrite = true);
+
+    /**
+     * Removes the variable @p name from the process' environment.
+     *
+     * This function must be called before starting the process.
+     *
+     * @param name the name of the environment variable
+     */
+    void unsetEnv(const QString &name);
+
+    /**
+     * Empties the process' environment.
+     *
+     * Note that LD_LIBRARY_PATH/DYLD_LIBRARY_PATH is automatically added
+     * on *NIX.
+     *
+     * This function must be called before starting the process.
+     */
+    void clearEnvironment();
+
+    /**
+     * Set the program and the command line arguments.
+     *
+     * This function must be called before starting the process, obviously.
+     *
+     * @param exe the program to execute
+     * @param args the command line arguments for the program,
+     *   one per list element
+     */
+    void setProgram(const QString &exe, const QStringList &args = QStringList());
+
+    /**
+     * @overload
+     *
+     * @param argv the program to execute and the command line arguments
+     *   for the program, one per list element
+     */
+    void setProgram(const QStringList &argv);
+
+    /**
+     * Append an element to the command line argument list for this process.
+     *
+     * If no executable is set yet, it will be set instead.
+     *
+     * For example, doing an "ls -l /usr/local/bin" can be achieved by:
+     *  \code
+     *  KProcess p;
+     *  p << "ls" << "-l" << "/usr/local/bin";
+     *  ...
+     *  \endcode
+     *
+     * This function must be called before starting the process, obviously.
+     *
+     * @param arg the argument to add
+     * @return a reference to this KProcess
+     */
+    KProcess &operator<<(const QString& arg);
+
+    /**
+     * @overload
+     *
+     * @param args the arguments to add
+     * @return a reference to this KProcess
+     */
+    KProcess &operator<<(const QStringList& args);
+
+    /**
+     * Clear the program and command line argument list.
+     */
+    void clearProgram();
+
+    /**
+     * Set a command to execute through a shell (a POSIX sh on *NIX
+     * and cmd.exe on Windows).
+     *
+     * Using this for anything but user-supplied commands is usually a bad
+     * idea, as the command's syntax depends on the platform.
+     * Redirections including pipes, etc. are better handled by the
+     * respective functions provided by QProcess.
+     *
+     * If KProcess determines that the command does not really need a
+     * shell, it will trasparently execute it without one for performance
+     * reasons.
+     *
+     * This function must be called before starting the process, obviously.
+     *
+     * @param cmd the command to execute through a shell.
+     *   The caller must make sure that all filenames etc. are properly
+     *   quoted when passed as argument. Failure to do so often results in
+     *   serious security holes. See KShell::quoteArg().
+     */
+    void setShellCommand(const QString &cmd);
+
+    /**
+     * Obtain the currently set program and arguments.
+     *
+     * @return a list, the first element being the program, the remaining ones
+     *  being command line arguments to the program.
+     */
+    QStringList program() const;
+
+    /**
+     * Start the process.
+     *
+     * @see QProcess::start(const QString &, const QStringList &, OpenMode)
+     */
+    void start();
+
+    /**
+     * Start the process, wait for it to finish, and return the exit code.
+     *
+     * This method is roughly equivalent to the sequence:
+     * <code>
+     *   start();
+     *   waitForFinished(msecs);
+     *   return exitCode();
+     * </code>
+     *
+     * Unlike the other execute() variants this method is not static,
+     * so the process can be parametrized properly and talked to.
+     *
+     * @param msecs time to wait for process to exit before killing it
+     * @return -2 if the process could not be started, -1 if it crashed,
+     *  otherwise its exit code
+     */
+    int execute(int msecs = -1);
+
+    /**
+     * @overload
+     *
+     * @param exe the program to execute
+     * @param args the command line arguments for the program,
+     *   one per list element
+     * @param msecs time to wait for process to exit before killing it
+     * @return -2 if the process could not be started, -1 if it crashed,
+     *  otherwise its exit code
+     */
+    static int execute(const QString &exe, const QStringList &args = QStringList(), int msecs = -1);
+
+    /**
+     * @overload
+     *
+     * @param argv the program to execute and the command line arguments
+     *   for the program, one per list element
+     * @param msecs time to wait for process to exit before killing it
+     * @return -2 if the process could not be started, -1 if it crashed,
+     *  otherwise its exit code
+     */
+    static int execute(const QStringList &argv, int msecs = -1);
+
+    /**
+     * Start the process and detach from it. See QProcess::startDetached()
+     * for details.
+     *
+     * Unlike the other startDetached() variants this method is not static,
+     * so the process can be parametrized properly.
+     * @note Currently, only the setProgram()/setShellCommand() and
+     * setWorkingDirectory() parametrizations are supported.
+     *
+     * The KProcess object may be re-used immediately after calling this
+     * function.
+     *
+     * @return the PID of the started process or 0 on error
+     */
+    int startDetached();
+
+    /**
+     * @overload
+     *
+     * @param exe the program to start
+     * @param args the command line arguments for the program,
+     *   one per list element
+     * @return the PID of the started process or 0 on error
+     */
+    static int startDetached(const QString &exe, const QStringList &args = QStringList());
+
+    /**
+     * @overload
+     *
+     * @param argv the program to start and the command line arguments
+     *   for the program, one per list element
+     * @return the PID of the started process or 0 on error
+     */
+    static int startDetached(const QStringList &argv);
+
+    /**
+     * Obtain the process' ID as known to the system.
+     *
+     * Unlike with QProcess::pid(), this is a real PID also on Windows.
+     *
+     * This function can be called only while the process is running.
+     * It cannot be applied to detached processes.
+     *
+     * @return the process ID
+     */
+    int pid() const;
+
+protected:
+    /**
+     * @internal
+     */
+    KProcess(KProcessPrivate *d, QObject *parent);
+
+    /**
+     * @internal
+     */
+    KProcessPrivate * const d_ptr;
+
+private:
+    // hide those
+    using QProcess::setReadChannelMode;
+    using QProcess::readChannelMode;
+    using QProcess::setProcessChannelMode;
+    using QProcess::processChannelMode;
+
+    Q_PRIVATE_SLOT(d_func(), void _k_forwardStdout())
+    Q_PRIVATE_SLOT(d_func(), void _k_forwardStderr())
+};
+
+#endif
+
diff --git a/gui//src/kprocess_p.h b/gui//src/kprocess_p.h
new file mode 100644
--- /dev/null
+++ b/gui//src/kprocess_p.h
@@ -0,0 +1,48 @@
+/*
+    This file is part of the KDE libraries
+
+    Copyright (C) 2007 Oswald Buddenhagen <ossi@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef KPROCESS_P_H
+#define KPROCESS_P_H
+
+#include "kprocess.h"
+
+class KProcessPrivate {
+    Q_DECLARE_PUBLIC(KProcess)
+protected:
+    KProcessPrivate() :
+        openMode(QIODevice::ReadWrite)
+    {
+    }
+    void writeAll(const QByteArray &buf, int fd);
+    void forwardStd(KProcess::ProcessChannel good, int fd);
+    void _k_forwardStdout();
+    void _k_forwardStderr();
+
+    QString prog;
+    QStringList args;
+    KProcess::OutputChannelMode outputChannelMode;
+    QIODevice::OpenMode openMode;
+
+    KProcess *q_ptr;
+};
+
+
+#endif
diff --git a/gui//src/kpty.cpp b/gui//src/kpty.cpp
--- a/gui//src/kpty.cpp
+++ b/gui//src/kpty.cpp
@@ -1,15 +1,15 @@
 /*
 
    This file is part of the KDE libraries
    Copyright (C) 2002 Waldo Bastian <bastian@kde.org>
-   Copyright (C) 2002-2003,2007 Oswald Buddenhagen <ossi@kde.org>
-
-    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+   Copyright (C) 2002-2003,2007-2008 Oswald Buddenhagen <ossi@kde.org>
+   Copyright (C) 2010 KDE e.V. <kde-ev-board@kde.org>
+     Author Adriaan de Groot <groot@kde.org>
 
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.
 
    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -19,16 +19,18 @@
    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.
 */
 
 #include "kpty_p.h"
 
+//#include <config.h>
+
 #ifdef __sgi
 #define __svr4__
 #endif
 
 #ifdef __osf__
 #define _OSF_SOURCE
 #include <float.h>
 #endif
@@ -66,16 +68,19 @@
 #endif
 
 #ifdef HAVE_LIBUTIL_H
 # include <libutil.h>
 #elif defined(HAVE_UTIL_H)
 # include <util.h>
 #endif
 
+#define HAVE_UTMPX
+#define _UTMPX_COMPAT
+
 #ifdef HAVE_UTEMPTER
 extern "C" {
 # include <utempter.h>
 }
 #else
 # include <utmp.h>
 # ifdef HAVE_UTMPX
 #  include <utmpx.h>
@@ -105,73 +110,81 @@ extern "C" {
 #ifdef HAVE_SYS_STROPTS_H
 # include <sys/stropts.h>	// Defines I_PUSH
 # define _NEW_TTY_CTRL
 #endif
 
 #if defined (__FreeBSD__) || defined (__NetBSD__) || defined (__OpenBSD__) || defined (__bsdi__) || defined(__APPLE__) || defined (__DragonFly__)
 # define _tcgetattr(fd, ttmode) ioctl(fd, TIOCGETA, (char *)ttmode)
 #else
-# if defined(_HPUX_SOURCE) || defined(__Lynx__) || defined (__CYGWIN__)
+# if defined(_HPUX_SOURCE) || defined(__Lynx__) || defined (__CYGWIN__) || defined(__sun)
 #  define _tcgetattr(fd, ttmode) tcgetattr(fd, ttmode)
 # else
 #  define _tcgetattr(fd, ttmode) ioctl(fd, TCGETS, (char *)ttmode)
 # endif
 #endif
 
 #if defined (__FreeBSD__) || defined (__NetBSD__) || defined (__OpenBSD__) || defined (__bsdi__) || defined(__APPLE__) || defined (__DragonFly__)
 # define _tcsetattr(fd, ttmode) ioctl(fd, TIOCSETA, (char *)ttmode)
 #else
-# if defined(_HPUX_SOURCE) || defined(__CYGWIN__)
+# if defined(_HPUX_SOURCE) || defined(__CYGWIN__) || defined(__sun)
 #  define _tcsetattr(fd, ttmode) tcsetattr(fd, TCSANOW, ttmode)
 # else
 #  define _tcsetattr(fd, ttmode) ioctl(fd, TCSETS, (char *)ttmode)
 # endif
 #endif
 
 //#include <kdebug.h>
 //#include <kstandarddirs.h>	// findExe
-
-#include <QtCore>
+//#include <kde_file.h>
 
-// not defined on HP-UX for example
-#ifndef CTRL
-# define CTRL(x) ((x) & 037)
-#endif
+#include <QtCore/Q_PID>
 
 #define TTY_GROUP "tty"
 
+#ifndef PATH_MAX
+# ifdef MAXPATHLEN
+#  define PATH_MAX MAXPATHLEN
+# else
+#  define PATH_MAX 1024
+# endif
+#endif
+
 ///////////////////////
 // private functions //
 ///////////////////////
 
 //////////////////
 // private data //
 //////////////////
 
-KPtyPrivate::KPtyPrivate() :
-    masterFd(-1), slaveFd(-1)
+KPtyPrivate::KPtyPrivate(KPty* parent) :
+    masterFd(-1), slaveFd(-1), ownMaster(true), q_ptr(parent)
 {
 }
 
-bool KPtyPrivate::chownpty(bool)
+KPtyPrivate::~KPtyPrivate()
 {
-//    return !QProcess::execute(KStandardDirs::findExe("kgrantpty"),
-//        QStringList() << (grant?"--grant":"--revoke") << QString::number(masterFd));
-    return true;
 }
 
+#ifndef HAVE_OPENPTY
+bool KPtyPrivate::chownpty(bool grant)
+{
+    return !QProcess::execute(KStandardDirs::findExe("kgrantpty"),
+        QStringList() << (grant?"--grant":"--revoke") << QString::number(masterFd));
+}
+#endif
+
 /////////////////////////////
 // public member functions //
 /////////////////////////////
 
 KPty::KPty() :
-    d_ptr(new KPtyPrivate)
+    d_ptr(new KPtyPrivate(this))
 {
-    d_ptr->q_ptr = this;
 }
 
 KPty::KPty(KPtyPrivate *d) :
     d_ptr(d)
 {
     d_ptr->q_ptr = this;
 }
 
@@ -183,33 +196,35 @@ KPty::~KPty()
 
 bool KPty::open()
 {
   Q_D(KPty);
 
   if (d->masterFd >= 0)
     return true;
 
+  d->ownMaster = true;
+
   QByteArray ptyName;
 
   // Find a master pty that we can open ////////////////////////////////
 
   // Because not all the pty animals are created equal, they want to
   // be opened by several different methods.
 
   // We try, as we know them, one by one.
 
 #ifdef HAVE_OPENPTY
 
   char ptsn[PATH_MAX];
   if (::openpty( &d->masterFd, &d->slaveFd, ptsn, 0, 0))
   {
     d->masterFd = -1;
     d->slaveFd = -1;
-    kWarning(175) << "Can't open a pseudo teletype";
+    //kWarning(175) << "Can't open a pseudo teletype";
     return false;
   }
   d->ttyName = ptsn;
 
 #else
 
 #ifdef HAVE__GETPTY // irix
 
@@ -221,38 +236,38 @@ bool KPty::open()
 
 #elif defined(HAVE_PTSNAME) || defined(TIOCGPTN)
 
 #ifdef HAVE_POSIX_OPENPT
   d->masterFd = ::posix_openpt(O_RDWR|O_NOCTTY);
 #elif defined(HAVE_GETPT)
   d->masterFd = ::getpt();
 #elif defined(PTM_DEVICE)
-  d->masterFd = ::open(PTM_DEVICE, O_RDWR|O_NOCTTY);
+  //d->masterFd = KDE_open(PTM_DEVICE, O_RDWR|O_NOCTTY);
+d->masterFd = ::open(PTM_DEVICE, O_RDWR|O_NOCTTY);
 #else
 # error No method to open a PTY master detected.
 #endif
-
   if (d->masterFd >= 0)
   {
- 
 #ifdef HAVE_PTSNAME
     char *ptsn = ptsname(d->masterFd);
     if (ptsn) {
         d->ttyName = ptsn;
 #else
     int ptyno;
     if (!ioctl(d->masterFd, TIOCGPTN, &ptyno)) {
-        d->ttyName = QByteArray("/dev/pts/") + QByteArray::number(ptyno);
+        char buf[32];
+        sprintf(buf, "/dev/pts/%d", ptyno);
+        d->ttyName = buf;
 #endif
 #ifdef HAVE_GRANTPT
         if (!grantpt(d->masterFd))
            goto grantedpt;
 #else
-
         goto gotpty;
 #endif
     }
     ::close(d->masterFd);
     d->masterFd = -1;
   }
 #endif // HAVE_PTSNAME || TIOCGPTN
 
@@ -294,105 +309,177 @@ bool KPty::open()
           goto gotpty;
         }
         ::close(d->masterFd);
         d->masterFd = -1;
       }
     }
   }
 
-  qWarning() << "Can't open a pseudo teletype";
+  //kWarning(175) << "Can't open a pseudo teletype";
   return false;
 
  gotpty:
-  struct stat st;
-  if (stat(d->ttyName.data(), &st)) {
+  KDE_struct_stat st;
+  if (KDE_stat(d->ttyName.data(), &st))
     return false; // this just cannot happen ... *cough*  Yeah right, I just
                   // had it happen when pty #349 was allocated.  I guess
                   // there was some sort of leak?  I only had a few open.
-    }
   if (((st.st_uid != getuid()) ||
        (st.st_mode & (S_IRGRP|S_IXGRP|S_IROTH|S_IWOTH|S_IXOTH))) &&
       !d->chownpty(true))
   {
-    qWarning()
+
+    /*kWarning(175)
       << "chownpty failed for device " << ptyName << "::" << d->ttyName
       << "\nThis means the communication can be eavesdropped." << endl;
-  }
+*/  
+}
 
-#if defined (HAVE__GETPTY) || defined (HAVE_GRANTPT)
  grantedpt:
-#endif 
 
 #ifdef HAVE_REVOKE
   revoke(d->ttyName.data());
 #endif
 
 #ifdef HAVE_UNLOCKPT
   unlockpt(d->masterFd);
 #elif defined(TIOCSPTLCK)
   int flag = 0;
   ioctl(d->masterFd, TIOCSPTLCK, &flag);
 #endif
 
   d->slaveFd = ::open(d->ttyName.data(), O_RDWR | O_NOCTTY);
   if (d->slaveFd < 0)
   {
-    qWarning() << "Can't open slave pseudo teletype";
+    //kWarning(175) << "Can't open slave pseudo teletype";
     ::close(d->masterFd);
     d->masterFd = -1;
     return false;
   }
 
-#if (defined(__svr4__) || defined(__sgi__))
-  // Solaris
-  ioctl(d->slaveFd, I_PUSH, "ptem");
-  ioctl(d->slaveFd, I_PUSH, "ldterm");
+#if (defined(__svr4__) || defined(__sgi__) || defined(Q_OS_SOLARIS))
+  // Solaris uses STREAMS for terminal handling. It is possible
+  // for the pty handling modules to be left off the stream; in that
+  // case push them on. ioctl(fd, I_FIND, ...) is documented to return
+  // 1 if the module is on the stream already.
+  {
+    static const char *pt = "ptem";
+    static const char *ld = "ldterm";
+    if (ioctl(d->slaveFd, I_FIND, pt) == 0)
+      ioctl(d->slaveFd, I_PUSH, pt);
+    if (ioctl(d->slaveFd, I_FIND, ld) == 0)
+      ioctl(d->slaveFd, I_PUSH, ld);
+  }
 #endif
 
 #endif /* HAVE_OPENPTY */
 
   fcntl(d->masterFd, F_SETFD, FD_CLOEXEC);
   fcntl(d->slaveFd, F_SETFD, FD_CLOEXEC);
 
   return true;
 }
 
+bool KPty::open(int fd)
+{
+#if !defined(HAVE_PTSNAME) && !defined(TIOCGPTN)
+    //kWarning(175) << "Unsupported attempt to open pty with fd" << fd;
+    return false;
+#else
+    Q_D(KPty);
+
+    if (d->masterFd >= 0) {
+        //kWarning(175) << "Attempting to open an already open pty";
+        return false;
+    }
+
+    d->ownMaster = false;
+
+# ifdef HAVE_PTSNAME
+    char *ptsn = ptsname(fd);
+    if (ptsn) {
+        d->ttyName = ptsn;
+# else
+    int ptyno;
+    if (!ioctl(fd, TIOCGPTN, &ptyno)) {
+        char buf[32];
+        sprintf(buf, "/dev/pts/%d", ptyno);
+        d->ttyName = buf;
+# endif
+    } else {
+        //kWarning(175) << "Failed to determine pty slave device for fd" << fd;
+        return false;
+    }
+
+    d->masterFd = fd;
+    if (!openSlave()) {
+        d->masterFd = -1;
+        return false;
+    }
+
+    return true;
+#endif
+}
+
 void KPty::closeSlave()
 {
     Q_D(KPty);
 
     if (d->slaveFd < 0)
         return;
     ::close(d->slaveFd);
     d->slaveFd = -1;
 }
 
+bool KPty::openSlave()
+{
+    Q_D(KPty);
+
+    if (d->slaveFd >= 0)
+        return true;
+    if (d->masterFd < 0) {
+        //kWarning(175) << "Attempting to open pty slave while master is closed";
+        return false;
+    }
+    d->slaveFd = ::open(d->ttyName.data(), O_RDWR | O_NOCTTY);
+    if (d->slaveFd < 0) {
+        //kWarning(175) << "Can't open slave pseudo teletype";
+        return false;
+    }
+    fcntl(d->slaveFd, F_SETFD, FD_CLOEXEC);
+    return true;
+}
+
 void KPty::close()
 {
-   Q_D(KPty);
+    Q_D(KPty);
 
-   if (d->masterFd < 0)
-      return;
-   closeSlave();
-   // don't bother resetting unix98 pty, it will go away after closing master anyway.
-   if (memcmp(d->ttyName.data(), "/dev/pts/", 9)) {
-      if (!geteuid()) {
-         struct stat st;
-         if (!stat(d->ttyName.data(), &st)) {
-            chown(d->ttyName.data(), 0, st.st_gid == getgid() ? 0 : -1);
-            chmod(d->ttyName.data(), S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH);
-         }
-      } else {
-         fcntl(d->masterFd, F_SETFD, 0);
-         d->chownpty(false);
-      }
-   }
-   ::close(d->masterFd);
-   d->masterFd = -1;
+    if (d->masterFd < 0)
+        return;
+    closeSlave();
+    if (d->ownMaster) {
+#ifndef HAVE_OPENPTY
+        // don't bother resetting unix98 pty, it will go away after closing master anyway.
+        if (memcmp(d->ttyName.data(), "/dev/pts/", 9)) {
+            if (!geteuid()) {
+                struct stat st;
+                if (!stat(d->ttyName.data(), &st)) {
+                    chown(d->ttyName.data(), 0, st.st_gid == getgid() ? 0 : -1);
+                    chmod(d->ttyName.data(), S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH);
+                }
+            } else {
+                fcntl(d->masterFd, F_SETFD, 0);
+                d->chownpty(false);
+            }
+        }
+#endif
+        ::close(d->masterFd);
+    }
+    d->masterFd = -1;
 }
 
 void KPty::setCTty()
 {
     Q_D(KPty);
 
     // Setup job control //////////////////////////////////
 
@@ -400,17 +487,17 @@ void KPty::setCTty()
     // and get rid of the old controlling terminal.
     setsid();
 
     // make our slave pty the new controlling terminal.
 #ifdef TIOCSCTTY
     ioctl(d->slaveFd, TIOCSCTTY, 0);
 #else
     // __svr4__ hack: the first tty opened after setsid() becomes controlling tty
-    ::close(::open(d->ttyName, O_WRONLY, 0));
+    ::close(open(d->ttyName, O_WRONLY, 0));
 #endif
 
     // make our new process group the foreground group on the pty
     int pgrp = getpid();
 #if defined(_POSIX_VERSION) || defined(__svr4__)
     tcsetpgrp(d->slaveFd, pgrp);
 #elif defined(TIOCSPGRP)
     ioctl(d->slaveFd, TIOCSPGRP, (char *)&pgrp);
@@ -452,17 +539,18 @@ void KPty::login(const char *user, const
 #  ifdef HAVE_STRUCT_UTMP_UT_ID
     strncpy(l_struct.ut_id,
             str_ptr + strlen(str_ptr) - sizeof(l_struct.ut_id),
             sizeof(l_struct.ut_id));
 #  endif
 # endif
 
 # ifdef HAVE_UTMPX
-    gettimeofday(&l_struct.ut_tv, 0);
+    //gettimeofday(&l_struct.ut_tv, 0);
+    gettimeofday((struct timeval *)&l_struct.ut_tv, 0);
 # else
     l_struct.ut_time = time(0);
 # endif
 
 # ifdef HAVE_LOGIN
 #  ifdef HAVE_LOGINX
     ::loginx(&l_struct);
 #  else
@@ -478,17 +566,17 @@ void KPty::login(const char *user, const
     l_struct.ut_session = getsid(0);
 #   endif
 #  endif
 #  ifdef HAVE_UTMPX
     utmpxname(_PATH_UTMPX);
     setutxent();
     pututxline(&l_struct);
     endutxent();
-    updwtmpx(_PATH_WTMPX, &l_struct);
+    //updwtmpx(_PATH_WTMPX, &l_struct);
 #  else
     utmpname(_PATH_UTMP);
     setutent();
     pututline(&l_struct);
     endutent();
     updwtmp(_PATH_WTMP, &l_struct);
 #  endif
 # endif
@@ -543,44 +631,48 @@ void KPty::logout()
         memset(ut->ut_host, 0, sizeof(*ut->ut_host));
 #  ifdef HAVE_STRUCT_UTMP_UT_SYSLEN
         ut->ut_syslen = 0;
 #  endif
 #  ifdef HAVE_STRUCT_UTMP_UT_TYPE
         ut->ut_type = DEAD_PROCESS;
 #  endif
 #  ifdef HAVE_UTMPX
-        gettimeofday(ut->ut_tv, 0);
+        //gettimeofday(&(ut->ut_tv), 0);
+	gettimeofday((struct timeval *)&(ut->ut_tv), 0);
         pututxline(ut);
     }
     endutxent();
 #  else
         ut->ut_time = time(0);
         pututline(ut);
     }
     endutent();
 #  endif
 # endif
 #endif
 }
 
-// XXX Supposedly, tc[gs]etattr do not work with the master on Solaris.
-// Please verify.
-
 bool KPty::tcGetAttr(struct ::termios *ttmode) const
 {
     Q_D(const KPty);
 
+#ifdef Q_OS_SOLARIS
+    if (_tcgetattr(d->slaveFd, ttmode) == 0) return true;
+#endif
     return _tcgetattr(d->masterFd, ttmode) == 0;
 }
 
 bool KPty::tcSetAttr(struct ::termios *ttmode)
 {
     Q_D(KPty);
 
+#ifdef Q_OS_SOLARIS
+    if (_tcsetattr(d->slaveFd, ttmode) == 0) return true;
+#endif
     return _tcsetattr(d->masterFd, ttmode) == 0;
 }
 
 bool KPty::setWinSize(int lines, int columns)
 {
     Q_D(KPty);
 
     struct winsize winSize;
diff --git a/gui//src/kpty.h b/gui//src/kpty.h
--- a/gui//src/kpty.h
+++ b/gui//src/kpty.h
@@ -1,14 +1,12 @@
 /* This file is part of the KDE libraries
 
     Copyright (C) 2003,2007 Oswald Buddenhagen <ossi@kde.org>
 
-    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
-
     This library is free software; you can redistribute it and/or
     modify it under the terms of the GNU Library General Public
     License as published by the Free Software Foundation; either
     version 2 of the License, or (at your option) any later version.
 
     This library is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
@@ -17,18 +15,18 @@
     You should have received a copy of the GNU Library General Public License
     along with this library; see the file COPYING.LIB.  If not, write to
     the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
     Boston, MA 02110-1301, USA.
 */
 
 #ifndef kpty_h
 #define kpty_h
-
-#include <QtCore>
+#include <QtCore/qglobal.h>
+//#include "kpty_export.h"
 
 struct KPtyPrivate;
 struct termios;
 
 /**
  * Provides primitives for opening & closing a pseudo TTY pair, assigning the
  * controlling TTY, utmp registration and setting various terminal attributes.
  */
@@ -53,16 +51,26 @@ public:
   /**
    * Create a pty master/slave pair.
    *
    * @return true if a pty pair was successfully opened
    */
   bool open();
 
   /**
+   * Open using an existing pty master.
+   *
+   * @param fd an open pty master file descriptor.
+   *   The ownership of the fd remains with the caller;
+   *   it will not be automatically closed at any point.
+   * @return true if a pty pair was successfully opened
+   */
+  bool open(int fd);
+
+  /**
    * Close the pty master/slave pair.
    */
   void close();
 
   /**
    * Close the pty slave descriptor.
    *
    * When creating the pty, KPty also opens the slave and keeps it open.
@@ -72,16 +80,25 @@ public:
    * pipe-alike behavior might be desired.
    *
    * After this function was called, slaveFd() and setCTty() cannot be
    * used.
    */
   void closeSlave();
 
   /**
+   * Open the pty slave descriptor.
+   *
+   * This undoes the effect of closeSlave().
+   *
+   * @return true if the pty slave was successfully opened
+   */
+  bool openSlave();
+
+  /**
    * Creates a new session and process group and makes this pty the
    * controlling tty.
    */
   void setCTty();
 
   /**
    * Creates an utmp entry for the tty.
    * This function must be called after calling setCTty and
diff --git a/gui//src/kpty_export.h b/gui//src/kpty_export.h
new file mode 100644
--- /dev/null
+++ b/gui//src/kpty_export.h
@@ -0,0 +1,46 @@
+/*  This file is part of the KDE project
+    Copyright (C) 2007 David Faure <faure@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef KPTY_EXPORT_H
+#define KPTY_EXPORT_H
+
+/* needed for KDE_EXPORT and KDE_IMPORT macros */
+//#include <kdemacros.h>
+#include <QtCore/qglobal.h>
+#define KDE_EXPORT
+#define KDE_IMPORT
+
+#ifndef KPTY_EXPORT
+# if defined(KDELIBS_STATIC_LIBS)
+   /* No export/import for static libraries */
+#  define KPTY_EXPORT
+# elif defined(MAKE_KDECORE_LIB)
+   /* We are building this library */ 
+#  define KPTY_EXPORT KDE_EXPORT
+# else
+   /* We are using this library */ 
+#  define KPTY_EXPORT KDE_IMPORT
+# endif
+#endif
+
+# ifndef KPTY_EXPORT_DEPRECATED
+#  define KPTY_EXPORT_DEPRECATED KDE_DEPRECATED KPTY_EXPORT
+# endif
+
+#endif
diff --git a/gui//src/kpty_p.h b/gui//src/kpty_p.h
--- a/gui//src/kpty_p.h
+++ b/gui//src/kpty_p.h
@@ -1,14 +1,12 @@
 /* This file is part of the KDE libraries
 
     Copyright (C) 2003,2007 Oswald Buddenhagen <ossi@kde.org>
 
-    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
-
     This library is free software; you can redistribute it and/or
     modify it under the terms of the GNU Library General Public
     License as published by the Free Software Foundation; either
     version 2 of the License, or (at your option) any later version.
 
     This library is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
@@ -20,25 +18,42 @@
     Boston, MA 02110-1301, USA.
 */
 
 #ifndef kpty_p_h
 #define kpty_p_h
 
 #include "kpty.h"
 
+//#include <config-pty.h>
+#if defined(Q_OS_MAC)
+#define HAVE_UTIL_H
+#define HAVE_UTMPX
+#define _UTMPX_COMPAT
+#define HAVE_PTSNAME
+#define HAVE_SYS_TIME_H
+#else
+#define HAVE_PTY_H
+#endif
+
+#define HAVE_OPENPTY
+
 #include <QtCore/QByteArray>
 
 struct KPtyPrivate {
     Q_DECLARE_PUBLIC(KPty)
 
-    KPtyPrivate();
+    KPtyPrivate(KPty* parent);
+    virtual ~KPtyPrivate();
+#ifndef HAVE_OPENPTY
     bool chownpty(bool grant);
+#endif
 
     int masterFd;
     int slaveFd;
+    bool ownMaster:1;
 
     QByteArray ttyName;
 
     KPty *q_ptr;
 };
 
 #endif
diff --git a/gui//src/kptydevice.cpp b/gui//src/kptydevice.cpp
new file mode 100644
--- /dev/null
+++ b/gui//src/kptydevice.cpp
@@ -0,0 +1,614 @@
+/*
+
+   This file is part of the KDE libraries
+   Copyright (C) 2007 Oswald Buddenhagen <ossi@kde.org>
+   Copyright (C) 2010 KDE e.V. <kde-ev-board@kde.org>
+     Author Adriaan de Groot <groot@kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#include "kptydevice.h"
+#include "kpty_p.h"
+
+//#include <config.h>
+//#include <config-pty.h>
+
+#define i18n
+
+#include <QtCore/QSocketNotifier>
+
+//#include <klocale.h>
+
+#include <unistd.h>
+#include <errno.h>
+#include <signal.h>
+#include <termios.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#ifdef HAVE_SYS_FILIO_H
+# include <sys/filio.h>
+#endif
+#ifdef HAVE_SYS_TIME_H
+# include <sys/time.h>
+#endif
+
+#if defined(Q_OS_FREEBSD) || defined(Q_OS_MAC)
+  // "the other end's output queue size" - kinda braindead, huh?
+# define PTY_BYTES_AVAILABLE TIOCOUTQ
+#elif defined(TIOCINQ)
+  // "our end's input queue size"
+# define PTY_BYTES_AVAILABLE TIOCINQ
+#else
+  // likewise. more generic ioctl (theoretically)
+# define PTY_BYTES_AVAILABLE FIONREAD
+#endif
+
+#define KMAXINT ((int)(~0U >> 1))
+
+/////////////////////////////////////////////////////
+// Helper. Remove when QRingBuffer becomes public. //
+/////////////////////////////////////////////////////
+
+#include <QtCore/qbytearray.h>
+#include <QtCore/qlinkedlist.h>
+
+#define CHUNKSIZE 4096
+
+class KRingBuffer
+{
+public:
+    KRingBuffer()
+    {
+        clear();
+    }
+
+    void clear()
+    {
+        buffers.clear();
+        QByteArray tmp;
+        tmp.resize(CHUNKSIZE);
+        buffers << tmp;
+        head = tail = 0;
+        totalSize = 0;
+    }
+
+    inline bool isEmpty() const
+    {
+        return buffers.count() == 1 && !tail;
+    }
+
+    inline int size() const
+    {
+        return totalSize;
+    }
+
+    inline int readSize() const
+    {
+        return (buffers.count() == 1 ? tail : buffers.first().size()) - head;
+    }
+
+    inline const char *readPointer() const
+    {
+        Q_ASSERT(totalSize > 0);
+        return buffers.first().constData() + head;
+    }
+
+    void free(int bytes)
+    {
+        totalSize -= bytes;
+        Q_ASSERT(totalSize >= 0);
+
+        forever {
+            int nbs = readSize();
+
+            if (bytes < nbs) {
+                head += bytes;
+                if (head == tail && buffers.count() == 1) {
+                    buffers.first().resize(CHUNKSIZE);
+                    head = tail = 0;
+                }
+                break;
+            }
+
+            bytes -= nbs;
+            if (buffers.count() == 1) {
+                buffers.first().resize(CHUNKSIZE);
+                head = tail = 0;
+                break;
+            }
+
+            buffers.removeFirst();
+            head = 0;
+        }
+    }
+
+    char *reserve(int bytes)
+    {
+        totalSize += bytes;
+
+        char *ptr;
+        if (tail + bytes <= buffers.last().size()) {
+            ptr = buffers.last().data() + tail;
+            tail += bytes;
+        } else {
+            buffers.last().resize(tail);
+            QByteArray tmp;
+            tmp.resize(qMax(CHUNKSIZE, bytes));
+            ptr = tmp.data();
+            buffers << tmp;
+            tail = bytes;
+        }
+        return ptr;
+    }
+
+    // release a trailing part of the last reservation
+    inline void unreserve(int bytes)
+    {
+        totalSize -= bytes;
+        tail -= bytes;
+    }
+
+    inline void write(const char *data, int len)
+    {
+        memcpy(reserve(len), data, len);
+    }
+
+    // Find the first occurrence of c and return the index after it.
+    // If c is not found until maxLength, maxLength is returned, provided
+    // it is smaller than the buffer size. Otherwise -1 is returned.
+    int indexAfter(char c, int maxLength = KMAXINT) const
+    {
+        int index = 0;
+        int start = head;
+        QLinkedList<QByteArray>::ConstIterator it = buffers.begin();
+        forever {
+            if (!maxLength)
+                return index;
+            if (index == size())
+                return -1;
+            const QByteArray &buf = *it;
+            ++it;
+            int len = qMin((it == buffers.end() ? tail : buf.size()) - start,
+                           maxLength);
+            const char *ptr = buf.data() + start;
+            if (const char *rptr = (const char *)memchr(ptr, c, len))
+                return index + (rptr - ptr) + 1;
+            index += len;
+            maxLength -= len;
+            start = 0;
+        }
+    }
+
+    inline int lineSize(int maxLength = KMAXINT) const
+    {
+        return indexAfter('\n', maxLength);
+    }
+
+    inline bool canReadLine() const
+    {
+        return lineSize() != -1;
+    }
+
+    int read(char *data, int maxLength)
+    {
+        int bytesToRead = qMin(size(), maxLength);
+        int readSoFar = 0;
+        while (readSoFar < bytesToRead) {
+            const char *ptr = readPointer();
+            int bs = qMin(bytesToRead - readSoFar, readSize());
+            memcpy(data + readSoFar, ptr, bs);
+            readSoFar += bs;
+            free(bs);
+        }
+        return readSoFar;
+    }
+
+    int readLine(char *data, int maxLength)
+    {
+        return read(data, lineSize(qMin(maxLength, size())));
+    }
+
+private:
+    QLinkedList<QByteArray> buffers;
+    int head, tail;
+    int totalSize;
+};
+
+//////////////////
+// private data //
+//////////////////
+
+// Lifted from Qt. I don't think they would mind. ;)
+// Re-lift again from Qt whenever a proper replacement for pthread_once appears
+static void qt_ignore_sigpipe()
+{
+    static QBasicAtomicInt atom = Q_BASIC_ATOMIC_INITIALIZER(0);
+    if (atom.testAndSetRelaxed(0, 1)) {
+        struct sigaction noaction;
+        memset(&noaction, 0, sizeof(noaction));
+        noaction.sa_handler = SIG_IGN;
+        sigaction(SIGPIPE, &noaction, 0);
+    }
+}
+
+#define NO_INTR(ret,func) do { ret = func; } while (ret < 0 && errno == EINTR)
+
+struct KPtyDevicePrivate : public KPtyPrivate {
+    Q_DECLARE_PUBLIC(KPtyDevice)
+
+    KPtyDevicePrivate(KPty* parent) :
+        KPtyPrivate(parent),
+        emittedReadyRead(false), emittedBytesWritten(false),
+        readNotifier(0), writeNotifier(0)
+    {
+    }
+
+    bool _k_canRead();
+    bool _k_canWrite();
+
+    bool doWait(int msecs, bool reading);
+    void finishOpen(QIODevice::OpenMode mode);
+
+    bool emittedReadyRead;
+    bool emittedBytesWritten;
+    QSocketNotifier *readNotifier;
+    QSocketNotifier *writeNotifier;
+    KRingBuffer readBuffer;
+    KRingBuffer writeBuffer;
+};
+
+bool KPtyDevicePrivate::_k_canRead()
+{
+    Q_Q(KPtyDevice);
+    qint64 readBytes = 0;
+
+#ifdef Q_OS_IRIX // this should use a config define, but how to check it?
+    size_t available;
+#else
+    int available;
+#endif
+    if (!::ioctl(q->masterFd(), PTY_BYTES_AVAILABLE, (char *) &available)) {
+#ifdef Q_OS_SOLARIS
+        // A Pty is a STREAMS module, and those can be activated
+        // with 0 bytes available. This happens either when ^C is
+        // pressed, or when an application does an explicit write(a,b,0)
+        // which happens in experiments fairly often. When 0 bytes are
+        // available, you must read those 0 bytes to clear the STREAMS
+        // module, but we don't want to hit the !readBytes case further down.
+        if (!available) {
+            char c;
+            // Read the 0-byte STREAMS message
+            NO_INTR(readBytes, read(q->masterFd(), &c, 0));
+            // Should return 0 bytes read; -1 is error
+            if (readBytes < 0) {
+                readNotifier->setEnabled(false);
+                emit q->readEof();
+                return false;
+            }
+            return true;
+        }
+#endif
+
+        char *ptr = readBuffer.reserve(available);
+#ifdef Q_OS_SOLARIS
+        // Even if available > 0, it is possible for read()
+        // to return 0 on Solaris, due to 0-byte writes in the stream.
+        // Ignore them and keep reading until we hit *some* data.
+        // In Solaris it is possible to have 15 bytes available
+        // and to (say) get 0, 0, 6, 0 and 9 bytes in subsequent reads.
+        // Because the stream is set to O_NONBLOCK in finishOpen(),
+        // an EOF read will return -1.
+        readBytes = 0;
+        while (!readBytes)
+#endif
+        // Useless block braces except in Solaris
+        {
+          NO_INTR(readBytes, read(q->masterFd(), ptr, available));
+        }
+        if (readBytes < 0) {
+            readBuffer.unreserve(available);
+            q->setErrorString(i18n("Error reading from PTY"));
+            return false;
+        }
+        readBuffer.unreserve(available - readBytes); // *should* be a no-op
+    }
+
+    if (!readBytes) {
+        readNotifier->setEnabled(false);
+        emit q->readEof();
+        return false;
+    } else {
+        if (!emittedReadyRead) {
+            emittedReadyRead = true;
+            emit q->readyRead();
+            emittedReadyRead = false;
+        }
+        return true;
+    }
+}
+
+bool KPtyDevicePrivate::_k_canWrite()
+{
+    Q_Q(KPtyDevice);
+
+    writeNotifier->setEnabled(false);
+    if (writeBuffer.isEmpty())
+        return false;
+
+    qt_ignore_sigpipe();
+    int wroteBytes;
+    NO_INTR(wroteBytes,
+            write(q->masterFd(),
+                  writeBuffer.readPointer(), writeBuffer.readSize()));
+    if (wroteBytes < 0) {
+        q->setErrorString(i18n("Error writing to PTY"));
+        return false;
+    }
+    writeBuffer.free(wroteBytes);
+
+    if (!emittedBytesWritten) {
+        emittedBytesWritten = true;
+        emit q->bytesWritten(wroteBytes);
+        emittedBytesWritten = false;
+    }
+
+    if (!writeBuffer.isEmpty())
+        writeNotifier->setEnabled(true);
+    return true;
+}
+
+#ifndef timeradd
+// Lifted from GLIBC
+# define timeradd(a, b, result) \
+    do { \
+        (result)->tv_sec = (a)->tv_sec + (b)->tv_sec; \
+        (result)->tv_usec = (a)->tv_usec + (b)->tv_usec; \
+        if ((result)->tv_usec >= 1000000) { \
+            ++(result)->tv_sec; \
+            (result)->tv_usec -= 1000000; \
+        } \
+    } while (0)
+# define timersub(a, b, result) \
+    do { \
+        (result)->tv_sec = (a)->tv_sec - (b)->tv_sec; \
+        (result)->tv_usec = (a)->tv_usec - (b)->tv_usec; \
+        if ((result)->tv_usec < 0) { \
+            --(result)->tv_sec; \
+            (result)->tv_usec += 1000000; \
+        } \
+    } while (0)
+#endif
+
+bool KPtyDevicePrivate::doWait(int msecs, bool reading)
+{
+    Q_Q(KPtyDevice);
+#ifndef __linux__
+    struct timeval etv;
+#endif
+    struct timeval tv, *tvp;
+
+    if (msecs < 0)
+        tvp = 0;
+    else {
+        tv.tv_sec = msecs / 1000;
+        tv.tv_usec = (msecs % 1000) * 1000;
+#ifndef __linux__
+        gettimeofday(&etv, 0);
+        timeradd(&tv, &etv, &etv);
+#endif
+        tvp = &tv;
+    }
+
+    while (reading ? readNotifier->isEnabled() : !writeBuffer.isEmpty()) {
+        fd_set rfds;
+        fd_set wfds;
+
+        FD_ZERO(&rfds);
+        FD_ZERO(&wfds);
+
+        if (readNotifier->isEnabled())
+            FD_SET(q->masterFd(), &rfds);
+        if (!writeBuffer.isEmpty())
+            FD_SET(q->masterFd(), &wfds);
+
+#ifndef __linux__
+        if (tvp) {
+            gettimeofday(&tv, 0);
+            timersub(&etv, &tv, &tv);
+            if (tv.tv_sec < 0)
+                tv.tv_sec = tv.tv_usec = 0;
+        }
+#endif
+
+        switch (select(q->masterFd() + 1, &rfds, &wfds, 0, tvp)) {
+        case -1:
+            if (errno == EINTR)
+                break;
+            return false;
+        case 0:
+            q->setErrorString(i18n("PTY operation timed out"));
+            return false;
+        default:
+            if (FD_ISSET(q->masterFd(), &rfds)) {
+                bool canRead = _k_canRead();
+                if (reading && canRead)
+                    return true;
+            }
+            if (FD_ISSET(q->masterFd(), &wfds)) {
+                bool canWrite = _k_canWrite();
+                if (!reading)
+                    return canWrite;
+            }
+            break;
+        }
+    }
+    return false;
+}
+
+void KPtyDevicePrivate::finishOpen(QIODevice::OpenMode mode)
+{
+    Q_Q(KPtyDevice);
+
+    q->QIODevice::open(mode);
+    fcntl(q->masterFd(), F_SETFL, O_NONBLOCK);
+    readBuffer.clear();
+    readNotifier = new QSocketNotifier(q->masterFd(), QSocketNotifier::Read, q);
+    writeNotifier = new QSocketNotifier(q->masterFd(), QSocketNotifier::Write, q);
+    QObject::connect(readNotifier, SIGNAL(activated(int)), q, SLOT(_k_canRead()));
+    QObject::connect(writeNotifier, SIGNAL(activated(int)), q, SLOT(_k_canWrite()));
+    readNotifier->setEnabled(true);
+}
+
+/////////////////////////////
+// public member functions //
+/////////////////////////////
+
+KPtyDevice::KPtyDevice(QObject *parent) :
+    QIODevice(parent),
+    KPty(new KPtyDevicePrivate(this))
+{
+}
+
+KPtyDevice::~KPtyDevice()
+{
+    close();
+}
+
+bool KPtyDevice::open(OpenMode mode)
+{
+    Q_D(KPtyDevice);
+
+    if (masterFd() >= 0)
+        return true;
+
+    if (!KPty::open()) {
+        setErrorString(i18n("Error opening PTY"));
+        return false;
+    }
+
+    d->finishOpen(mode);
+
+    return true;
+}
+
+bool KPtyDevice::open(int fd, OpenMode mode)
+{
+    Q_D(KPtyDevice);
+
+    if (!KPty::open(fd)) {
+        setErrorString(i18n("Error opening PTY"));
+        return false;
+    }
+
+    d->finishOpen(mode);
+
+    return true;
+}
+
+void KPtyDevice::close()
+{
+    Q_D(KPtyDevice);
+
+    if (masterFd() < 0)
+        return;
+
+    delete d->readNotifier;
+    delete d->writeNotifier;
+
+    QIODevice::close();
+
+    KPty::close();
+}
+
+bool KPtyDevice::isSequential() const
+{
+    return true;
+}
+
+bool KPtyDevice::canReadLine() const
+{
+    Q_D(const KPtyDevice);
+    return QIODevice::canReadLine() || d->readBuffer.canReadLine();
+}
+
+bool KPtyDevice::atEnd() const
+{
+    Q_D(const KPtyDevice);
+    return QIODevice::atEnd() && d->readBuffer.isEmpty();
+}
+
+qint64 KPtyDevice::bytesAvailable() const
+{
+    Q_D(const KPtyDevice);
+    return QIODevice::bytesAvailable() + d->readBuffer.size();
+}
+
+qint64 KPtyDevice::bytesToWrite() const
+{
+    Q_D(const KPtyDevice);
+    return d->writeBuffer.size();
+}
+
+bool KPtyDevice::waitForReadyRead(int msecs)
+{
+    Q_D(KPtyDevice);
+    return d->doWait(msecs, true);
+}
+
+bool KPtyDevice::waitForBytesWritten(int msecs)
+{
+    Q_D(KPtyDevice);
+    return d->doWait(msecs, false);
+}
+
+void KPtyDevice::setSuspended(bool suspended)
+{
+    Q_D(KPtyDevice);
+    d->readNotifier->setEnabled(!suspended);
+}
+
+bool KPtyDevice::isSuspended() const
+{
+    Q_D(const KPtyDevice);
+    return !d->readNotifier->isEnabled();
+}
+
+// protected
+qint64 KPtyDevice::readData(char *data, qint64 maxlen)
+{
+    Q_D(KPtyDevice);
+    return d->readBuffer.read(data, (int)qMin<qint64>(maxlen, KMAXINT));
+}
+
+// protected
+qint64 KPtyDevice::readLineData(char *data, qint64 maxlen)
+{
+    Q_D(KPtyDevice);
+    return d->readBuffer.readLine(data, (int)qMin<qint64>(maxlen, KMAXINT));
+}
+
+// protected
+qint64 KPtyDevice::writeData(const char *data, qint64 len)
+{
+    Q_D(KPtyDevice);
+    Q_ASSERT(len <= KMAXINT);
+
+    d->writeBuffer.write(data, len);
+    d->writeNotifier->setEnabled(true);
+    return len;
+}
+
diff --git a/gui//src/kptydevice.h b/gui//src/kptydevice.h
new file mode 100644
--- /dev/null
+++ b/gui//src/kptydevice.h
@@ -0,0 +1,156 @@
+/* This file is part of the KDE libraries
+
+    Copyright (C) 2007 Oswald Buddenhagen <ossi@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef kptydev_h
+#define kptydev_h
+
+#include "kpty.h"
+
+#include <QtCore/QIODevice>
+
+struct KPtyDevicePrivate;
+
+#define Q_DECLARE_PRIVATE_MI(Class, SuperClass) \
+    inline Class##Private* d_func() { return reinterpret_cast<Class##Private *>(SuperClass::d_ptr); } \
+    inline const Class##Private* d_func() const { return reinterpret_cast<const Class##Private *>(SuperClass::d_ptr); } \
+    friend class Class##Private;
+
+/**
+ * Encapsulates KPty into a QIODevice, so it can be used with Q*Stream, etc.
+ */
+class KPtyDevice : public QIODevice, public KPty { //krazy:exclude=dpointer (via macro)
+    Q_OBJECT
+    Q_DECLARE_PRIVATE_MI(KPtyDevice, KPty)
+
+public:
+
+    /**
+     * Constructor
+     */
+    KPtyDevice(QObject *parent = 0);
+
+    /**
+     * Destructor:
+     *
+     *  If the pty is still open, it will be closed. Note, however, that
+     *  an utmp registration is @em not undone.
+     */
+    virtual ~KPtyDevice();
+
+    /**
+     * Create a pty master/slave pair.
+     *
+     * @return true if a pty pair was successfully opened
+     */
+    virtual bool open(OpenMode mode = ReadWrite | Unbuffered);
+
+    /**
+     * Open using an existing pty master. The ownership of the fd
+     * remains with the caller, i.e., close() will not close the fd.
+     *
+     * This is useful if you wish to attach a secondary "controller" to an
+     * existing pty device such as a terminal widget.
+     * Note that you will need to use setSuspended() on both devices to
+     * control which one gets the incoming data from the pty.
+     *
+     * @param fd an open pty master file descriptor.
+     * @param mode the device mode to open the pty with.
+     * @return true if a pty pair was successfully opened
+     */
+    bool open(int fd, OpenMode mode = ReadWrite | Unbuffered);
+
+    /**
+     * Close the pty master/slave pair.
+     */
+    virtual void close();
+
+    /**
+     * Sets whether the KPtyDevice monitors the pty for incoming data.
+     *
+     * When the KPtyDevice is suspended, it will no longer attempt to buffer
+     * data that becomes available from the pty and it will not emit any
+     * signals.
+     *
+     * Do not use on closed ptys.
+     * After a call to open(), the pty is not suspended. If you need to
+     * ensure that no data is read, call this function before the main loop
+     * is entered again (i.e., immediately after opening the pty).
+     */
+    void setSuspended(bool suspended);
+
+    /**
+     * Returns true if the KPtyDevice is not monitoring the pty for incoming
+     * data.
+     *
+     * Do not use on closed ptys.
+     *
+     * See setSuspended()
+     */
+    bool isSuspended() const;
+
+    /**
+     * @return always true
+     */
+    virtual bool isSequential() const;
+
+    /**
+     * @reimp
+     */
+    bool canReadLine() const;
+
+    /**
+     * @reimp
+     */
+    bool atEnd() const;
+
+    /**
+     * @reimp
+     */
+    qint64 bytesAvailable() const;
+
+    /**
+     * @reimp
+     */
+    qint64 bytesToWrite() const;
+
+    bool waitForBytesWritten(int msecs = -1);
+    bool waitForReadyRead(int msecs = -1);
+
+
+Q_SIGNALS:
+    /**
+     * Emitted when EOF is read from the PTY.
+     *
+     * Data may still remain in the buffers.
+     */
+    void readEof();
+
+protected:
+    virtual qint64 readData(char *data, qint64 maxSize);
+    virtual qint64 readLineData(char *data, qint64 maxSize);
+    virtual qint64 writeData(const char *data, qint64 maxSize);
+
+private:
+    Q_PRIVATE_SLOT(d_func(), bool _k_canRead())
+    Q_PRIVATE_SLOT(d_func(), bool _k_canWrite())
+};
+
+#endif
+
diff --git a/gui//src/kptyprocess.cpp b/gui//src/kptyprocess.cpp
new file mode 100644
--- /dev/null
+++ b/gui//src/kptyprocess.cpp
@@ -0,0 +1,138 @@
+/*
+
+    This file is part of the KDE libraries
+
+    Copyright (C) 2007 Oswald Buddenhagen <ossi@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+#include "kptyprocess.h"
+#include "kprocess_p.h"
+
+//#include <kuser.h>
+#include "kptydevice.h"
+
+#include <stdlib.h>
+#include <unistd.h>
+
+//////////////////
+// private data //
+//////////////////
+
+struct KPtyProcessPrivate : KProcessPrivate {
+    KPtyProcessPrivate() :
+        ptyChannels(KPtyProcess::NoChannels),
+        addUtmp(false)
+    {
+    }
+
+    void _k_onStateChanged(QProcess::ProcessState newState)
+    {
+        if (newState == QProcess::NotRunning && addUtmp)
+            pty->logout();
+    }
+
+    KPtyDevice *pty;
+    KPtyProcess::PtyChannels ptyChannels;
+    bool addUtmp : 1;
+};
+
+KPtyProcess::KPtyProcess(QObject *parent) :
+    KProcess(new KPtyProcessPrivate, parent)
+{
+    Q_D(KPtyProcess);
+
+    d->pty = new KPtyDevice(this);
+    d->pty->open();
+    connect(this, SIGNAL(stateChanged(QProcess::ProcessState)),
+            SLOT(_k_onStateChanged(QProcess::ProcessState)));
+}
+
+KPtyProcess::KPtyProcess(int ptyMasterFd, QObject *parent) :
+    KProcess(new KPtyProcessPrivate, parent)
+{
+    Q_D(KPtyProcess);
+
+    d->pty = new KPtyDevice(this);
+    d->pty->open(ptyMasterFd);
+    connect(this, SIGNAL(stateChanged(QProcess::ProcessState)),
+            SLOT(_k_onStateChanged(QProcess::ProcessState)));
+}
+
+KPtyProcess::~KPtyProcess()
+{
+    Q_D(KPtyProcess);
+
+    if (state() != QProcess::NotRunning && d->addUtmp) {
+        d->pty->logout();
+        disconnect(SIGNAL(stateChanged(QProcess::ProcessState)),
+                   this, SLOT(_k_onStateChanged(QProcess::ProcessState)));
+    }
+    delete d->pty;
+}
+
+void KPtyProcess::setPtyChannels(PtyChannels channels)
+{
+    Q_D(KPtyProcess);
+
+    d->ptyChannels = channels;
+}
+
+KPtyProcess::PtyChannels KPtyProcess::ptyChannels() const
+{
+    Q_D(const KPtyProcess);
+
+    return d->ptyChannels;
+}
+
+void KPtyProcess::setUseUtmp(bool value)
+{
+    Q_D(KPtyProcess);
+
+    d->addUtmp = value;
+}
+
+bool KPtyProcess::isUseUtmp() const
+{
+    Q_D(const KPtyProcess);
+
+    return d->addUtmp;
+}
+
+KPtyDevice *KPtyProcess::pty() const
+{
+    Q_D(const KPtyProcess);
+
+    return d->pty;
+}
+
+void KPtyProcess::setupChildProcess()
+{
+    Q_D(KPtyProcess);
+
+    d->pty->setCTty();
+    if (d->addUtmp)
+      d->pty->login(getenv("USER"), getenv("DISPLAY"));
+      //d->pty->login(KUser(KUser::UseRealUserID).loginName().toLocal8Bit().data(), qgetenv("DISPLAY"));
+    if (d->ptyChannels & StdinChannel)
+        dup2(d->pty->slaveFd(), 0);
+    if (d->ptyChannels & StdoutChannel)
+        dup2(d->pty->slaveFd(), 1);
+    if (d->ptyChannels & StderrChannel)
+        dup2(d->pty->slaveFd(), 2);
+
+    KProcess::setupChildProcess();
+}
diff --git a/gui//src/kptyprocess.h b/gui//src/kptyprocess.h
new file mode 100644
--- /dev/null
+++ b/gui//src/kptyprocess.h
@@ -0,0 +1,138 @@
+/*
+    This file is part of the KDE libraries
+
+    Copyright (C) 2007 Oswald Buddenhagen <ossi@kde.org>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef KPTYPROCESS_H
+#define KPTYPROCESS_H
+
+#include "kprocess.h"
+
+#include "kpty_export.h"
+
+class KPtyDevice;
+
+struct KPtyProcessPrivate;
+/**
+ * This class extends KProcess by support for PTYs (pseudo TTYs).
+ *
+ * The PTY is opened as soon as the class is instantiated. Verify that
+ * it was opened successfully by checking that pty()->masterFd() is not -1.
+ *
+ * The PTY is always made the process' controlling TTY.
+ * Utmp registration and connecting the stdio handles to the PTY are optional.
+ *
+ * No attempt to integrate with QProcess' waitFor*() functions was made,
+ * for it is impossible. Note that execute() does not work with the PTY, too.
+ * Use the PTY device's waitFor*() functions or use it asynchronously.
+ *
+ * @author Oswald Buddenhagen <ossi@kde.org>
+ */
+class KPtyProcess : public KProcess
+{
+    Q_OBJECT
+    Q_DECLARE_PRIVATE(KPtyProcess)
+
+public:
+    enum PtyChannelFlag {
+        NoChannels = 0, /**< The PTY is not connected to any channel. */
+        StdinChannel = 1, /**< Connect PTY to stdin. */
+        StdoutChannel = 2, /**< Connect PTY to stdout. */
+        StderrChannel = 4, /**< Connect PTY to stderr. */
+        AllOutputChannels = 6, /**< Connect PTY to all output channels. */
+        AllChannels = 7 /**< Connect PTY to all channels. */
+    };
+
+    Q_DECLARE_FLAGS(PtyChannels, PtyChannelFlag)
+
+    /**
+     * Constructor
+     */
+    explicit KPtyProcess(QObject *parent = 0);
+
+    /**
+     * Construct a process using an open pty master.
+     *
+     * @param ptyMasterFd an open pty master file descriptor.
+     *   The process does not take ownership of the descriptor;
+     *   it will not be automatically closed at any point.
+     */
+    KPtyProcess(int ptyMasterFd, QObject *parent = 0);
+
+    /**
+     * Destructor
+     */
+    virtual ~KPtyProcess();
+
+    /**
+     * Set to which channels the PTY should be assigned.
+     *
+     * This function must be called before starting the process.
+     *
+     * @param channels the output channel handling mode
+     */
+    void setPtyChannels(PtyChannels channels);
+
+    /**
+     * Query to which channels the PTY is assigned.
+     *
+     * @return the output channel handling mode
+     */
+    PtyChannels ptyChannels() const;
+
+    /**
+     * Set whether to register the process as a TTY login in utmp.
+     *
+     * Utmp is disabled by default.
+     * It should enabled for interactively fed processes, like terminal
+     * emulations.
+     *
+     * This function must be called before starting the process.
+     *
+     * @param value whether to register in utmp.
+     */
+    void setUseUtmp(bool value);
+
+    /**
+     * Get whether to register the process as a TTY login in utmp.
+     *
+     * @return whether to register in utmp
+     */
+    bool isUseUtmp() const;
+
+    /**
+     * Get the PTY device of this process.
+     *
+     * @return the PTY device
+     */
+    KPtyDevice *pty() const;
+
+protected:
+    /**
+     * @reimp
+     */
+    virtual void setupChildProcess();
+
+private:
+    Q_PRIVATE_SLOT(d_func(), void _k_onStateChanged(QProcess::ProcessState))
+};
+
+Q_DECLARE_OPERATORS_FOR_FLAGS(KPtyProcess::PtyChannels)
+
+#endif
