# HG changeset patch
# User Jaroslav Hajek <highegg@gmail.com>
# Date 1262780321 -3600
#      Wed Jan 06 13:18:41 2010 +0100
# Node ID 2cd940306a0695817e78f105a0848c1e2cb4c725
# Parent  64a06079cae44481dff6f3503eae51c06e7c921a
make unwind_protect frames local

diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,75 @@
+2010-01-06  Jaroslav Hajek  <highegg@gmail.com>
+
+	* unwind_protect.h, unwind_protect.cc (unwind_protect): Rewrite.
+	Remove obsolete macros. Use a simple linked list.
+
+	* debug.cc (Fdbwhere): Update to new unwind_protect style.
+	* dynamic-ld.cc (octave_dynamic_loader::do_load_oct,
+	  octave_dynamic_loader::do_load_mex): Ditto.
+	* error.cc (Flasterror, Flasterr, error_2, warning_1): Ditto.
+	* graphics.cc (base_graphics_object::remove_all_listeners,
+	  axes::update_axis_limits, gh_manager::do_execute_callback,
+	  Fdrawnow): Ditto.
+	* help.cc (raw_help_from_file): Ditto.
+	* input.cc (do_keyboard, Fkeyboard, get_debug_input): Ditto.
+	* load-path.cc (load_path::do_set, execute_pkg_add_or_del,
+	* ls-mat4.cc (save_mat_binary_data): Ditto.
+	* ls-mat5.cc (read_mat5_binary_element): Ditto.
+	* mex.cc (call_mex, mexGetVariable): Ditto.
+	* oct-hist.cc (do_edit_history, do_run_history): Ditto.
+	* octave.cc (execute_startup_files, execute_eval_option_code, 
+	  execute_command_line_file): Ditto.
+	* ov-builtin.cc (octave_builtin::do_multi_index_op): Ditto.
+	* ov-class.cc (octave_class::subsasgn, octave_class::print_raw):
+	Ditto.
+	* ov-fcn-handle.cc (octave_fcn_handle::load_ascii,
+	octave_fcn_handle::load_binary, octave_fcn_handle::load_hdf5): Ditto.
+	* ov-list.cc (octave_list::print_raw): Ditto.
+	* ov-mex-fcn.cc (octave_mex_function::do_multi_index_op): Ditto.
+	* ov-struct.cc (octave_struct::print_raw): Ditto.
+	* ov-usr-fcn.cc (octave_user_script::do_multi_index_op,
+	  octave_user_function::do_multi_index_op): Ditto.
+	* pager.cc (flush_octave_stdout): Ditto.
+	* pr-output.cc (Frats): Ditto.
+	* pt-arg-list.cc (tree_argument_list::convert_to_const_vector): Ditto.
+
+	* pt-eval.cc (tree_evaluator::visit_simple_for_command,
+	tree_evaluator::visit_complex_for_command,
+	tree_evaluator::visit_while_command,
+	tree_evaluator::visit_do_until_command): Update to new unwind_protect
+	style.
+	(do_catch_code): Remove.
+	(tree_evaluator::visit_try_catch_command): Simplify. Don't register
+	catch code for unwind_protect.
+	(tree_evaluator::do_unwind_protect_cleanup_code): Make a
+	tree_evaluator method. Update to new unwind_protect style.
+	(tree_evaluator::visit_unwind_protect_command): Use explicit try/catch
+	handling rather than inserting unsafe code into unwind_protect.
+
+	* pt-eval.h (tree_evaluator::do_unwind_protect_cleanup_code): New decl.
+	* toplev.cc (main_loop): Update to new unwind_protect style.
+	  (run_command_and_return_output): Ditto.
+	* utils.cc (Fisindex): Ditto.
+	* variables.cc (generate_struct_completions, safe_symbol_lookup,
+	do_who): Ditto.
+
+	* DLD-FUNCTIONS/cellfun.cc (Fcellfun): Ditto.
+	* DLD-FUNCTIONS/daspk.cc (Fdaspk): Ditto.
+	* DLD-FUNCTIONS/dasrt.cc (Fdasrt): Ditto.
+	* DLD-FUNCTIONS/dassl.cc (Fdassl): Ditto.
+	* DLD-FUNCTIONS/eigs.cc (Feigs): Ditto.
+	* DLD-FUNCTIONS/lsode.cc (Flsode): Ditto.
+	* DLD-FUNCTIONS/quad.cc (Fquad): Ditto.
+	* DLD-FUNCTIONS/rand.cc (Frandn, Frande, Frandg, Frandp): Ditto.
+	* DLD-FUNCTIONS/typecast.cc (get_data_and_bytesize, Ftypecast): Ditto.
+	* DLD-FUNCTIONS/urlwrite.cc (Furlwrite, mput_directory, 
+	getallfiles, F__ftp_mget__): Ditto.
+
 2010-01-05  Jaroslav Hajek  <highegg@gmail.com>
 
 	* Cell.cc (Cell::cellstr_value): New method.
 	* Cell.h (Cell::cellstr_value): Declare it.
 
 	* ov-cell.h (octave_cell::cellstr_cache): Declare as autopointer.
 	(octave_cell::clear_cellstr_cache): Move here.
 	* ov-cell.cc (octave_cell::is_cellstr): Only allocate the pointer, but
diff --git a/src/DLD-FUNCTIONS/cellfun.cc b/src/DLD-FUNCTIONS/cellfun.cc
--- a/src/DLD-FUNCTIONS/cellfun.cc
+++ b/src/DLD-FUNCTIONS/cellfun.cc
@@ -472,18 +472,18 @@ cellfun (@@factorial, @{-1,2@},'ErrorHan
     }
 
   if (error_state || ! retval.empty ())
     return retval;
 
   if (func.is_function_handle () || func.is_inline_function ()
       || func.is_function ())
     {
-      unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
-      unwind_protect::protect_var (buffer_error_messages);
+      unwind_protect frame;
+      frame.protect_var (buffer_error_messages);
 
       bool uniform_output = true;
       octave_value error_handler;
 
       while (nargin > 3 && args(nargin-2).is_string())
         {
           std::string arg = args(nargin-2).string_value();
 
@@ -535,24 +535,24 @@ cellfun (@@factorial, @{-1,2@},'ErrorHan
       // This is to prevent copy-on-write.
       const Cell *cinputs = inputs;
 
       octave_idx_type k = 1;
 
       dim_vector fdims (1, 1);
 
       if (error_state)
-        goto cellfun_err;
+        return octave_value_list ();
 
       for (int j = 0; j < nargin; j++)
         {
           if (! args(j+1).is_cell ())
             {
               error ("cellfun: arguments must be cells");
-              goto cellfun_err;
+              return octave_value_list ();
             }
 
           inputs[j] = args(j+1).cell_value ();
           mask[j] = inputs[j].numel () != 1;
           if (! mask[j])
             inputlist(j) = cinputs[j](0);
         }
 
@@ -562,17 +562,17 @@ cellfun (@@factorial, @{-1,2@},'ErrorHan
             {
               fdims = inputs[j].dims ();
               k = inputs[j].numel ();
               for (int i = j+1; i < nargin; i++)
                 {
                   if (mask[i] && inputs[i].dims () != fdims)
                     {
                       error ("cellfun: Dimensions mismatch.");
-                      goto cellfun_err;
+                      return octave_value_list ();
                     }
                 }
               break;
             }
         }
 
       if (error_handler.is_defined ())
         buffer_error_messages++;
@@ -600,28 +600,28 @@ cellfun (@@factorial, @{-1,2@},'ErrorHan
                   octave_value_list errlist = inputlist;
                   errlist.prepend (msg);
                   buffer_error_messages--;
                   error_state = 0;
                   tmp = error_handler.do_multi_index_op (nargout, errlist);
                   buffer_error_messages++;
 
                   if (error_state)
-                    goto cellfun_err;
+                    return octave_value_list ();
                 }
 
               if (error_state)
-                goto cellfun_err;
+                return octave_value_list ();
 
               if (tmp.length () < nargout1)
                 {
                   if (tmp.length () < nargout)
                     {
                       error ("cellfun: too many output arguments");
-                      goto cellfun_err;
+                      return octave_value_list ();
                     }
                   else
                     nargout1 = 0;
                 }
 
               if (count == 0)
                 {
                   for (int j = 0; j < nargout1; j++)
@@ -692,48 +692,42 @@ cellfun (@@factorial, @{-1,2@},'ErrorHan
                   octave_value_list errlist = inputlist;
                   errlist.prepend (msg);
                   buffer_error_messages--;
                   error_state = 0;
                   tmp = error_handler.do_multi_index_op (nargout, errlist);
                   buffer_error_messages++;
 
                   if (error_state)
-                    goto cellfun_err;
+                    return octave_value_list ();
                 }
 
               if (error_state)
-                goto cellfun_err;
+                return octave_value_list ();
 
               if (tmp.length () < nargout1)
                 {
                   if (tmp.length () < nargout)
                     {
                       error ("cellfun: too many output arguments");
-                      goto cellfun_err;
+                      return octave_value_list ();
                     }
                   else
                     nargout1 = 0;
                 }
 
 
               for (int j = 0; j < nargout1; j++)
                 results[j](count) = tmp(j);
             }
 
           retval.resize(nargout1);
           for (int j = 0; j < nargout1; j++)
             retval(j) = results[j];
         }
-
-cellfun_err:
-      if (error_state)
-        retval = octave_value_list();
-
-      unwind_protect::run_frame (uwp_frame);
     }
   else
     error ("cellfun: first argument must be a string or function handle");
 
   return retval;
 }
 
 /*
diff --git a/src/DLD-FUNCTIONS/daspk.cc b/src/DLD-FUNCTIONS/daspk.cc
--- a/src/DLD-FUNCTIONS/daspk.cc
+++ b/src/DLD-FUNCTIONS/daspk.cc
@@ -148,22 +148,17 @@ daspk_user_jacobian (const ColumnVector&
       else
 	gripe_user_supplied_eval ("daspk");
     }
 
   return retval;
 }
 
 #define DASPK_ABORT() \
-  do \
-    { \
-      unwind_protect::run_frame (uwp_frame); \
-      return retval; \
-    } \
-  while (0)
+  return retval
 
 #define DASPK_ABORT1(msg) \
   do \
     { \
       ::error ("daspk: " msg); \
       DASPK_ABORT (); \
     } \
   while (0)
@@ -275,19 +270,19 @@ parameters for @code{daspk}.\n\
 @seealso{dassl}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   warned_fcn_imaginary = false;
   warned_jac_imaginary = false;
 
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+  unwind_protect frame;
 
-  unwind_protect::protect_var (call_depth);
+  frame.protect_var (call_depth);
   call_depth++;
 
   if (call_depth > 1)
     DASPK_ABORT1 ("invalid recursive call");
 
   int nargin = args.length ();
 
   if (nargin > 3 && nargin < 6)
@@ -475,18 +470,16 @@ parameters for @code{daspk}.\n\
 	      if (nargout < 3)
 		error ("daspk: %s", msg.c_str ());
 	    }
 	}
     }
   else
     print_usage ();
 
-  unwind_protect::run_frame (uwp_frame);
-
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/DLD-FUNCTIONS/dasrt.cc b/src/DLD-FUNCTIONS/dasrt.cc
--- a/src/DLD-FUNCTIONS/dasrt.cc
+++ b/src/DLD-FUNCTIONS/dasrt.cc
@@ -183,22 +183,17 @@ dasrt_user_j (const ColumnVector& x, con
       else
 	gripe_user_supplied_eval ("dasrt");
     }
 
   return retval;
 }
 
 #define DASRT_ABORT \
-  do \
-    { \
-      unwind_protect::run_frame (uwp_frame); \
-      return retval; \
-    } \
-  while (0)
+  return retval
 
 #define DASRT_ABORT1(msg) \
   do \
     { \
       ::error ("dasrt: " msg); \
       DASRT_ABORT; \
     } \
   while (0)
@@ -348,32 +343,31 @@ parameters for @code{dasrt}.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   warned_fcn_imaginary = false;
   warned_jac_imaginary = false;
   warned_cf_imaginary = false;
 
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+  unwind_protect frame;
 
-  unwind_protect::protect_var (call_depth);
+  frame.protect_var (call_depth);
   call_depth++;
 
   if (call_depth > 1)
     DASRT_ABORT1 ("invalid recursive call");
 
   int argp = 0;
 
   int nargin = args.length ();
 
   if (nargin < 4 || nargin > 6)
     {
       print_usage ();
-      unwind_protect::run_frame (uwp_frame);
       return retval;
     }
 
   std::string fcn_name, fname, jac_name, jname;
   dasrt_f = 0;
   dasrt_j = 0;
   dasrt_cf = 0;
 
@@ -582,18 +576,16 @@ parameters for @code{dasrt}.\n\
 	  retval(1) = Matrix ();
 	  retval(0) = Matrix ();
 
 	  if (nargout < 4)
 	    error ("dasrt: %s", msg.c_str ());
 	}
     }
 
-  unwind_protect::run_frame (uwp_frame);
-
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/DLD-FUNCTIONS/dassl.cc b/src/DLD-FUNCTIONS/dassl.cc
--- a/src/DLD-FUNCTIONS/dassl.cc
+++ b/src/DLD-FUNCTIONS/dassl.cc
@@ -148,22 +148,17 @@ dassl_user_jacobian (const ColumnVector&
       else
 	gripe_user_supplied_eval ("dassl");
     }
 
   return retval;
 }
 
 #define DASSL_ABORT() \
-  do \
-    { \
-      unwind_protect::run_frame (uwp_frame); \
-      return retval; \
-    } \
-  while (0)
+  return retval
 
 #define DASSL_ABORT1(msg) \
   do \
     { \
       ::error ("dassl: " msg); \
       DASSL_ABORT (); \
     } \
   while (0)
@@ -276,19 +271,19 @@ parameters for @code{dassl}.\n\
 @seealso{daspk, dasrt, lsode}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   warned_fcn_imaginary = false;
   warned_jac_imaginary = false;
 
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+  unwind_protect frame;
 
-  unwind_protect::protect_var (call_depth);
+  frame.protect_var (call_depth);
   call_depth++;
 
   if (call_depth > 1)
     DASSL_ABORT1 ("invalid recursive call");
 
   int nargin = args.length ();
 
   if (nargin > 3 && nargin < 6 && nargout < 5)
@@ -477,18 +472,16 @@ parameters for @code{dassl}.\n\
 	      if (nargout < 3)
 		error ("dassl: %s", msg.c_str ());
 	    }
 	}
     }
   else
     print_usage ();
 
-  unwind_protect::run_frame (uwp_frame);
-
   return retval;
 }
 
 /*
 
 %% dassl-1.m
 %%
 %% Test dassl() function
diff --git a/src/DLD-FUNCTIONS/eigs.cc b/src/DLD-FUNCTIONS/eigs.cc
--- a/src/DLD-FUNCTIONS/eigs.cc
+++ b/src/DLD-FUNCTIONS/eigs.cc
@@ -335,27 +335,26 @@ K Maschhoff, D Sorensen and C Yang.  For
   octave_idx_type p = -1;
   ColumnVector resid;
   ComplexColumnVector cresid;
   octave_idx_type info = 1;
   char bmat = 'I';
 
   warned_imaginary = false;
 
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+  unwind_protect frame;
 
-  unwind_protect::protect_var (call_depth);
+  frame.protect_var (call_depth);
   call_depth++;
 
   if (call_depth > 1)
     {
       error ("eigs: invalid recursive call");
       if (fcn_name.length())
 	clear_function (fcn_name);
-      unwind_protect::run_frame (uwp_frame);
       return retval;
     }
 
   if (nargin == 0)
     print_usage ();
   else if (args(0).is_function_handle () || args(0).is_inline_function ()
 	   || args(0).is_string ())
     {
@@ -731,18 +730,16 @@ K Maschhoff, D Sorensen and C Yang.  For
 	warning ("eigs: None of the %d requested eigenvalues converged", k);
       else if (nconv < k)
 	warning ("eigs: Only %d of the %d requested eigenvalues converged", 
 		 nconv, k);
     }
 
   if (! fcn_name.empty ())
     clear_function (fcn_name);
-
-  unwind_protect::run_frame (uwp_frame);
 #else
   error ("eigs: not available in this version of Octave");
 #endif
 
   return retval;
 }
 
 /* #### SPARSE MATRIX VERSIONS #### */
diff --git a/src/DLD-FUNCTIONS/lsode.cc b/src/DLD-FUNCTIONS/lsode.cc
--- a/src/DLD-FUNCTIONS/lsode.cc
+++ b/src/DLD-FUNCTIONS/lsode.cc
@@ -134,22 +134,17 @@ lsode_user_jacobian (const ColumnVector&
       else
 	gripe_user_supplied_eval ("lsode");
     }
 
   return retval;
 }
 
 #define LSODE_ABORT() \
-  do \
-    { \
-      unwind_protect::run_frame (uwp_frame); \
-      return retval; \
-    } \
-  while (0)
+  return retval
  
 #define LSODE_ABORT1(msg) \
   do \
     { \
       ::error ("lsode: " msg); \
       LSODE_ABORT (); \
     } \
   while (0)
@@ -275,19 +270,19 @@ parameters for @code{lsode}.\n\
 @seealso{daspk, dassl, dasrt}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   warned_fcn_imaginary = false;
   warned_jac_imaginary = false;
 
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+  unwind_protect frame;
 
-  unwind_protect::protect_var (call_depth);
+  frame.protect_var (call_depth);
   call_depth++;
 
   if (call_depth > 1)
     LSODE_ABORT1 ("invalid recursive call");
 
   int nargin = args.length ();
 
   if (nargin > 2 && nargin < 5 && nargout < 4)
@@ -468,18 +463,16 @@ parameters for @code{lsode}.\n\
 	      if (nargout < 2)
 		error ("lsode: %s", msg.c_str ());
 	    }
 	}
     }
   else
     print_usage ();
 
-  unwind_protect::run_frame (uwp_frame);
-
   return retval;
 }
 
 /*
 
 %% dassl-1.m
 %%
 %% Test lsode() function
diff --git a/src/DLD-FUNCTIONS/quad.cc b/src/DLD-FUNCTIONS/quad.cc
--- a/src/DLD-FUNCTIONS/quad.cc
+++ b/src/DLD-FUNCTIONS/quad.cc
@@ -148,17 +148,16 @@ quad_float_user_function (float x)
   return retval;
 }
 
 #define QUAD_ABORT() \
   do \
     { \
       if (fcn_name.length()) \
 	clear_function (fcn_name); \
-      unwind_protect::run_frame (uwp_frame); \
       return retval; \
     } \
   while (0)
 
 #define QUAD_ABORT1(msg) \
   do \
     { \
       ::error ("quad: " msg); \
@@ -216,19 +215,19 @@ cannot be called recursively.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   std::string fcn_name;
 
   warned_imaginary = false;
 
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+  unwind_protect frame;
 
-  unwind_protect::protect_var (call_depth);
+  frame.protect_var (call_depth);
   call_depth++;
 
   if (call_depth > 1)
     QUAD_ABORT1 ("invalid recursive call");
 
   int nargin = args.length ();
 
   if (nargin > 2 && nargin < 6 && nargout < 5)
@@ -466,18 +465,16 @@ cannot be called recursively.\n\
 	}
 
       if (fcn_name.length())
 	clear_function (fcn_name);
     }
   else
     print_usage ();
 
-  unwind_protect::run_frame (uwp_frame);
-
   return retval;
 }
 
 /*
 
 %!function y = f (x) 
 %! y = x + 1;
 %!test
diff --git a/src/DLD-FUNCTIONS/rand.cc b/src/DLD-FUNCTIONS/rand.cc
--- a/src/DLD-FUNCTIONS/rand.cc
+++ b/src/DLD-FUNCTIONS/rand.cc
@@ -459,17 +459,17 @@ keyword \"state\" should be used to rese
 %!   assert(kurtosis(x),-6/5,0.0094);
 %! endif
 */
 
 
 static std::string current_distribution = octave_rand::distribution ();
 
 static void
-reset_rand_generator (void *)
+reset_rand_generator (void)
 {
   octave_rand::distribution (current_distribution);
 }
 
 DEFUN_DLD (randn, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} randn (@var{x})\n\
 @deftypefnx {Loadable Function} {} randn (@var{n}, @var{m})\n\
@@ -487,34 +487,32 @@ J. Statistical Software, vol 5, 2000,\n\
 \n\
 @seealso{rand, rande, randg, randp}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+  unwind_protect frame;
 
   // This relies on the fact that elements are popped from the unwind
   // stack in the reverse of the order they are pushed
   // (i.e. current_distribution will be reset before calling
   // reset_rand_generator()).
 
-  unwind_protect::add (reset_rand_generator, 0);
-  unwind_protect::protect_var (current_distribution);
+  frame.add_fcn (reset_rand_generator);
+  frame.protect_var (current_distribution);
 
   current_distribution = "normal";
 
   octave_rand::distribution (current_distribution);
 
   retval = do_rand (args, nargin, "randn");
 
-  unwind_protect::run_frame (uwp_frame);
-
   return retval;
 }
 
 /*
 %!test
 %! % Test fixed state
 %! randn("state",1);
 %! assert (randn(1,6), [-2.666521678978671 -0.7381719971724564 1.507903992673601 0.6019427189162239 -0.450661261143348 -0.7054431351574116],1e-6);
@@ -560,34 +558,32 @@ J. Statistical Software, vol 5, 2000,\n\
 @url{http://www.jstatsoft.org/v05/i08/})\n\
 @seealso{rand, randn, randg, randp}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+  unwind_protect frame;
 
   // This relies on the fact that elements are popped from the unwind
   // stack in the reverse of the order they are pushed
   // (i.e. current_distribution will be reset before calling
   // reset_rand_generator()).
 
-  unwind_protect::add (reset_rand_generator, 0);
-  unwind_protect::protect_var (current_distribution);
+  frame.add_fcn (reset_rand_generator);
+  frame.protect_var (current_distribution);
 
   current_distribution = "exponential";
 
   octave_rand::distribution (current_distribution);
 
   retval = do_rand (args, nargin, "rande");
 
-  unwind_protect::run_frame (uwp_frame);
-
   return retval;
 }
 
 /*
 %!test
 %! % Test fixed state
 %! rande("state",1);
 %! assert (rande(1,6), [3.602973885835625 0.1386190677555021 0.6743112889616958 0.4512830847258422 0.7255744741233175 0.3415969205292291],1e-6);
@@ -692,33 +688,31 @@ r = r / sum (r)\n\
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 1)
     error ("randg: insufficient arguments");
   else
     {
-      unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+      unwind_protect frame;
 
       // This relies on the fact that elements are popped from the unwind
       // stack in the reverse of the order they are pushed
       // (i.e. current_distribution will be reset before calling
       // reset_rand_generator()).
 
-      unwind_protect::add (reset_rand_generator, 0);
-      unwind_protect::protect_var (current_distribution);
+      frame.add_fcn (reset_rand_generator);
+      frame.protect_var (current_distribution);
 
       current_distribution = "gamma";
 
       octave_rand::distribution (current_distribution);
 
       retval = do_rand (args, nargin, "randg", true);
-
-      unwind_protect::run_frame (uwp_frame);
     }
 
   return retval;
 }
 
 /*
 %!test
 %! randg("state",12)
@@ -906,33 +900,31 @@ D 50 p1284, 1994\n\
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 1)
     error ("randp: insufficient arguments");
   else
     {
-      unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+      unwind_protect frame;
 
       // This relies on the fact that elements are popped from the unwind
       // stack in the reverse of the order they are pushed
       // (i.e. current_distribution will be reset before calling
       // reset_rand_generator()).
 
-      unwind_protect::add (reset_rand_generator, 0);
-      unwind_protect::protect_var (current_distribution);
+      frame.add_fcn (reset_rand_generator);
+      frame.protect_var (current_distribution);
 
       current_distribution = "poisson";
 
       octave_rand::distribution (current_distribution);
 
       retval = do_rand (args, nargin, "randp", true);
-
-      unwind_protect::run_frame (uwp_frame);
     }
 
   return retval;
 }
 
 /*
 %!test
 %! randp("state",12)
diff --git a/src/DLD-FUNCTIONS/typecast.cc b/src/DLD-FUNCTIONS/typecast.cc
--- a/src/DLD-FUNCTIONS/typecast.cc
+++ b/src/DLD-FUNCTIONS/typecast.cc
@@ -44,21 +44,22 @@ get_vec_dims (const dim_vector& old_dims
     return dim_vector (n, 1);
 }
 
 template <class ArrayType>
 static void 
 get_data_and_bytesize (const ArrayType& array,
                        const void *& data,
                        octave_idx_type& byte_size,
-                       dim_vector& old_dims)
+                       dim_vector& old_dims,
+                       unwind_protect& frame)
 {
   // The array given may be a temporary, constructed from a scalar or sparse
   // array. This will ensure the data will be deallocated after we exit.
-  unwind_protect::add_delete (new ArrayType (array));
+  frame.add_delete (new ArrayType (array));
 
   data = reinterpret_cast<const void *> (array.data ());
   byte_size = array.byte_size ();
 
   old_dims = array.dims ();
 }
 
 template <class ArrayType>
@@ -132,60 +133,61 @@ typecast (@var{x}, 'uint8')\n\
 @end example\n\
 @seealso{cast, swapbytes}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 2)
     {
+      unwind_protect frame;
       const void *data = 0;
       octave_idx_type byte_size = 0;
       dim_vector old_dims;
 
       octave_value array = args(0);
 
       if (array.is_bool_type ())
-        get_data_and_bytesize (array.bool_array_value (), data, byte_size, old_dims);
+        get_data_and_bytesize (array.bool_array_value (), data, byte_size, old_dims, frame);
       else if (array.is_string ())
-        get_data_and_bytesize (array.char_array_value (), data, byte_size, old_dims);
+        get_data_and_bytesize (array.char_array_value (), data, byte_size, old_dims, frame);
       else if (array.is_integer_type ())
         {
           if (array.is_int8_type ())
-            get_data_and_bytesize (array.int8_array_value (), data, byte_size, old_dims);
+            get_data_and_bytesize (array.int8_array_value (), data, byte_size, old_dims, frame);
           else if (array.is_int16_type ())
-            get_data_and_bytesize (array.int16_array_value (), data, byte_size, old_dims);
+            get_data_and_bytesize (array.int16_array_value (), data, byte_size, old_dims, frame);
           else if (array.is_int32_type ())
-            get_data_and_bytesize (array.int32_array_value (), data, byte_size, old_dims);
+            get_data_and_bytesize (array.int32_array_value (), data, byte_size, old_dims, frame);
           else if (array.is_int64_type ())
-            get_data_and_bytesize (array.int64_array_value (), data, byte_size, old_dims);
+            get_data_and_bytesize (array.int64_array_value (), data, byte_size, old_dims, frame);
           else if (array.is_uint8_type ())
-            get_data_and_bytesize (array.uint8_array_value (), data, byte_size, old_dims);
+            get_data_and_bytesize (array.uint8_array_value (), data, byte_size, old_dims, frame);
           else if (array.is_uint16_type ())
-            get_data_and_bytesize (array.uint16_array_value (), data, byte_size, old_dims);
+            get_data_and_bytesize (array.uint16_array_value (), data, byte_size, old_dims, frame);
           else if (array.is_uint32_type ())
-            get_data_and_bytesize (array.uint32_array_value (), data, byte_size, old_dims);
+            get_data_and_bytesize (array.uint32_array_value (), data, byte_size, old_dims, frame);
           else if (array.is_uint64_type ())
-            get_data_and_bytesize (array.uint64_array_value (), data, byte_size, old_dims);
+            get_data_and_bytesize (array.uint64_array_value (), data, byte_size, old_dims, frame);
           else
             assert (0);
         }
       else if (array.is_complex_type ())
         {
           if (array.is_single_type ())
-            get_data_and_bytesize (array.float_complex_array_value (), data, byte_size, old_dims);
+            get_data_and_bytesize (array.float_complex_array_value (), data, byte_size, old_dims, frame);
           else
-            get_data_and_bytesize (array.complex_array_value (), data, byte_size, old_dims);
+            get_data_and_bytesize (array.complex_array_value (), data, byte_size, old_dims, frame);
         }
       else if (array.is_real_type ())
         {
           if (array.is_single_type ())
-            get_data_and_bytesize (array.float_array_value (), data, byte_size, old_dims);
+            get_data_and_bytesize (array.float_array_value (), data, byte_size, old_dims, frame);
           else
-            get_data_and_bytesize (array.array_value (), data, byte_size, old_dims);
+            get_data_and_bytesize (array.array_value (), data, byte_size, old_dims, frame);
         }
       else
         error ("typecast: invalid input class: %s", array.class_name ().c_str ());
 
       std::string numclass = args(1).string_value ();
 
       if (error_state || numclass.size () == 0)
         ;
diff --git a/src/DLD-FUNCTIONS/urlwrite.cc b/src/DLD-FUNCTIONS/urlwrite.cc
--- a/src/DLD-FUNCTIONS/urlwrite.cc
+++ b/src/DLD-FUNCTIONS/urlwrite.cc
@@ -799,29 +799,29 @@ urlwrite (\"http://www.google.com/search
   std::ofstream ofile (filename.c_str(), std::ios::out | std::ios::binary);
 
   if (! ofile.is_open ())
     {
       error ("urlwrite: unable to open file");
       return retval;
     }
 
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+  unwind_protect_safe frame;
 
-  unwind_protect::add_fcn (cleanup_urlwrite, filename);
+  frame.add_fcn (cleanup_urlwrite, filename);
 
   bool res;
   curl_handle curl = curl_handle (url, method, param, ofile, res);
 
   ofile.close ();
 
   if (!error_state)
-    unwind_protect::discard_frame (uwp_frame);
+    frame.discard ();
   else
-    unwind_protect::run_frame (uwp_frame);
+    frame.run ();
 
   if (nargout > 0)
     {
       if (res)
 	{
 	  retval(2) = std::string ();
 	  retval(1) = true;
 	  retval(0) = octave_env::make_absolute (filename, octave_env::getcwd ());
@@ -1421,20 +1421,19 @@ mput_directory (const curl_handle& curl,
     warning ("__ftp_mput__: can not create the remote directory ""%s""",
 	     (base.length() == 0 ? dir : base + 
 	      file_ops::dir_sep_str () + dir).c_str ());
 
   curl.cwd (dir);
 
   if (! error_state)
     {
-      unwind_protect::frame_id_t uwp_frame = 
-	unwind_protect::begin_frame ();
+      unwind_protect_safe frame;
 
-      unwind_protect::add_fcn (reset_path, curl);
+      frame.add_fcn (reset_path, curl);
 
       std::string realdir = base.length() == 0 ? dir : base + 
 			 file_ops::dir_sep_str () + dir;
 
       dir_entry dirlist (realdir);
 
       if (dirlist)
 	{
@@ -1486,18 +1485,16 @@ mput_directory (const curl_handle& curl,
 
 		  retval.append (realfile);
 		}
 	    }
 	}
       else
 	error ("__ftp_mput__: can not read the directory ""%s""", 
 	       realdir.c_str());
-
-      unwind_protect::run_frame (uwp_frame);
     }
 
   return retval;
 }
 #endif
 
 DEFUN_DLD (__ftp_mput__, args, nargout,
   "-*- texinfo -*-\n\
@@ -1597,22 +1594,21 @@ getallfiles (const curl_handle& curl, co
     }
 
   if (! error_state)
     {
       curl.cwd (dir);
 
       if (! error_state)
 	{
-	  unwind_protect::frame_id_t uwp_frame = 
-	    unwind_protect::begin_frame ();
+          unwind_protect_safe frame;
 
-	  unwind_protect::add_fcn (reset_path, curl);
+	  frame.add_fcn (reset_path, curl);
 
-	    string_vector sv = curl.list ();
+          string_vector sv = curl.list ();
 
 	  for (octave_idx_type i = 0; i < sv.length (); i++)
 	    {
 	      time_t ftime;
 	      bool fisdir;
 	      double fsize;
 		      
 	      curl.get_fileinfo (sv(i), fsize, ftime, fisdir);
@@ -1627,36 +1623,33 @@ getallfiles (const curl_handle& curl, co
 				       std::ios::binary);
 
 		  if (! ofile.is_open ())
 		    {
 		      error ("__ftp_mget__: unable to open file");
 		      break;
 		    }
 
-		  unwind_protect::frame_id_t uwp_frame2 = 
-		    unwind_protect::begin_frame ();
+                  unwind_protect_safe frame2;
 
-		  unwind_protect::add_fcn (delete_file, realfile);
+		  frame2.add_fcn (delete_file, realfile);
 
 		  curl.get (sv(i), ofile);
 
 		  ofile.close ();
 
 		  if (!error_state)
-		    unwind_protect::discard_frame (uwp_frame2);
+		    frame2.discard ();
 		  else
-		    unwind_protect::run_frame (uwp_frame2);
+		    frame2.run ();
 		}
 
 	      if (error_state)
 		break;
 	    }
-
-	  unwind_protect::run_frame (uwp_frame);
 	}
     }
 }
 #endif
 
 DEFUN_DLD (__ftp_mget__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_mget__ (@var{handle}, @var{files})\n\
@@ -1708,29 +1701,28 @@ Undocumented internal function\n\
 					       std::ios::binary);
 
 			  if (! ofile.is_open ())
 			    {
 			      error ("__ftp_mget__: unable to open file");
 			      break;
 			    }
 
-			  unwind_protect::frame_id_t uwp_frame = 
-			    unwind_protect::begin_frame ();
+                          unwind_protect_safe frame;
 
-			  unwind_protect::add_fcn (delete_file, target + sv(i));
+			  frame.add_fcn (delete_file, target + sv(i));
 
 			  curl.get (sv(i), ofile);
 
 			  ofile.close ();
 
 			  if (!error_state)
-			    unwind_protect::discard_frame (uwp_frame);
+			    frame.discard ();
 			  else
-			    unwind_protect::run_frame (uwp_frame);
+			    frame.run ();
 			}
 
 		      if (error_state)
 			break;
 		    }
 		}
 	      if (n == 0)
 		error ("__ftp_mget__: file not found");
diff --git a/src/debug.cc b/src/debug.cc
--- a/src/debug.cc
+++ b/src/debug.cc
@@ -656,20 +656,20 @@ Show where we are in the code\n\
 	{
 	  have_file = false;
 
 	  name = dbg_fcn->name ();
 	}
 
       octave_stdout << name << ":";
 
-      unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+      unwind_protect frame;
 
-      unwind_protect::add_fcn (octave_call_stack::restore_frame, 
-			       octave_call_stack::current_frame ());
+      frame.add_fcn (octave_call_stack::restore_frame, 
+                     octave_call_stack::current_frame ());
 
       // Skip the frame assigned to the dbwhere function.
       octave_call_stack::goto_frame_relative (0);
 
       int l = octave_call_stack::current_line ();
 
       if (l > 0)
 	{
@@ -687,18 +687,16 @@ Show where we are in the code\n\
 	      std::string line = get_file_line (name, l);
 
 	      if (! line.empty ())
 		octave_stdout << l << ": " << line << std::endl;
 	    }
 	}
       else
 	octave_stdout << " (unknown line)\n";
-
-      unwind_protect::run_frame (uwp_frame);
     }
   else
     error ("dbwhere: must be inside of a user function to use dbwhere\n");
 
   return retval;
 }
 
 // Copied and modified from the do_type command in help.cc
@@ -855,17 +853,17 @@ DEFUN (dbstack, args, nargout,
 @deftypefn {Loadable Function} {[@var{stack}, @var{idx}]} dbstack (@var{n})\n\
 Print or return current stack information.  With optional argument\n\
 @var{n}, omit the @var{n} innermost stack frames.\n\
 @seealso{dbclear, dbstatus, dbstop}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+  unwind_protect frame;
 
   octave_idx_type curr_frame = -1;
 
   size_t nskip = 0;
 
   if (args.length () == 1)
     {
       int n = 0;
@@ -919,18 +917,16 @@ Print or return current stack informatio
 	}
       else
 	{
 	  retval(1) = curr_frame < 0 ? 1 : curr_frame + 1;
 	  retval(0) = stk;
 	}
     }
 
-  unwind_protect::run_frame (uwp_frame);
-
   return retval;
 }
 
 static void
 do_dbupdown (const octave_value_list& args, const std::string& who)
 {
   int n = 1;
 
diff --git a/src/dynamic-ld.cc b/src/dynamic-ld.cc
--- a/src/dynamic-ld.cc
+++ b/src/dynamic-ld.cc
@@ -329,19 +329,19 @@ clear (octave_shlib& oct_file)
 
 octave_function *
 octave_dynamic_loader::do_load_oct (const std::string& fcn_name,
 				    const std::string& file_name,
 				    bool relative)
 {
   octave_function *retval = 0;
 
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+  unwind_protect frame;
 
-  unwind_protect::protect_var (octave_dynamic_loader::doing_load);
+  frame.protect_var (octave_dynamic_loader::doing_load);
 
   doing_load = true;
 
   octave_shlib oct_file = octave_shlib_list::find_file (file_name);
 
   if (oct_file && oct_file.is_out_of_date ())
     clear (oct_file);
 
@@ -379,31 +379,29 @@ octave_dynamic_loader::do_load_oct (cons
 			 fcn_name.c_str ());
 	    }
 	}
       else
 	::error ("%s is not a valid shared library",
 		 file_name.c_str ());
     }
   
-  unwind_protect::run_frame (uwp_frame);
-
   return retval;
 }
 
 octave_function *
 octave_dynamic_loader::do_load_mex (const std::string& fcn_name,
 				    const std::string& file_name,
 				    bool relative)
 {
   octave_function *retval = 0;
 
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+  unwind_protect frame;
 
-  unwind_protect::protect_var (octave_dynamic_loader::doing_load);
+  frame.protect_var (octave_dynamic_loader::doing_load);
 
   doing_load = true;
 
   octave_shlib mex_file = octave_shlib_list::find_file (file_name);
 
   if (mex_file && mex_file.is_out_of_date ())
     clear (mex_file);
 
@@ -450,18 +448,16 @@ octave_dynamic_loader::do_load_mex (cons
 	    ::error ("failed to install .mex file function `%s'",
 		     fcn_name.c_str ());
   	}
       else
 	::error ("%s is not a valid shared library",
 		 file_name.c_str ());
     }
 
-  unwind_protect::run_frame (uwp_frame);
-
   return retval;
 }
 
 bool
 octave_dynamic_loader::do_remove_oct (const std::string& fcn_name,
 				      octave_shlib& shl)
 {
   bool retval = false;
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -481,26 +481,25 @@ error_2 (const char *id, const char *fmt
   int init_state = error_state;
 
   error_1 (std::cerr, "error", id, fmt, args, with_cfn);
 
   if ((interactive || forced_interactive)
       && Vdebug_on_error && init_state == 0
       && octave_call_stack::caller_user_code ())
     {
-      unwind_protect::protect_var (Vdebug_on_error);
+      unwind_protect frame;
+      frame.protect_var (Vdebug_on_error);
       Vdebug_on_error = false;
 
       error_state = 0;
 
       pr_where ("error");
 
       do_keyboard (octave_value_list ());
-
-      unwind_protect::run ();
     }
 }
 
 void
 verror (const char *fmt, va_list args)
 {
   error_2 ("", fmt, args);
 }
@@ -672,22 +671,21 @@ warning_1 (const char *id, const char *f
 	pr_where ("warning");
 
       warning_state = 1;
 
       if ((interactive || forced_interactive)
 	  && Vdebug_on_warning
 	  && octave_call_stack::caller_user_code ())
 	{
-	  unwind_protect::protect_var (Vdebug_on_warning);
+          unwind_protect frame;
+	  frame.protect_var (Vdebug_on_warning);
 	  Vdebug_on_warning = false;
 
 	  do_keyboard (octave_value_list ());
-
-	  unwind_protect::run ();
 	}
     }
 }
 
 void
 vwarning (const char *fmt, va_list args)
 {
   warning_1 ("", fmt, args);
@@ -1519,19 +1517,19 @@ set to their default values.\n\
 \n\
 If @code{lasterror} is called with the argument 'reset', all values take\n\
 their default values.\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length();
 
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+  unwind_protect frame;
 
-  unwind_protect::protect_var (error_state);
+  frame.protect_var (error_state);
   error_state = 0;
 
   if (nargin < 2)
     {
       Octave_map err;
 
       err.assign ("message", Vlast_error_message);
       err.assign ("identifier", Vlast_error_id);
@@ -1626,34 +1624,32 @@ their default values.\n\
 	}
 
       if (! error_state)
 	retval = err;
     }
   else
     print_usage ();
 
-  unwind_protect::run_frame (uwp_frame);
-
   return retval;  
 }
 
 DEFUN (lasterr, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{msg}, @var{msgid}] =} lasterr (@var{msg}, @var{msgid})\n\
 Without any arguments, return the last error message.  With one\n\
 argument, set the last error message to @var{msg}.  With two arguments,\n\
 also set the last message identifier.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+  unwind_protect frame;
 
-  unwind_protect::protect_var (error_state);
+  frame.protect_var (error_state);
   error_state = 0;
 
   int argc = args.length () + 1;
 
   if (argc < 4)
     {
       string_vector argv = args.make_argv ("lasterr");
 
@@ -1675,18 +1671,16 @@ also set the last message identifier.\n\
 	    }
 	}
       else
 	error ("lasterr: expecting arguments to be character strings");
     }
   else
     print_usage ();
 
-  unwind_protect::run_frame (uwp_frame);
-
   return retval;  
 }
 
 // For backward compatibility.
 DEFALIAS (error_text, lasterr);
 DEFALIAS (__error_text__, lasterr);
 
 DEFUN (lastwarn, args, nargout,
diff --git a/src/graphics.cc b/src/graphics.cc
--- a/src/graphics.cc
+++ b/src/graphics.cc
@@ -2285,29 +2285,27 @@ base_graphics_object::remove_all_listene
   Octave_map m = get (true).map_value ();
 
   for (Octave_map::const_iterator pa = m.begin (); pa != m.end (); pa++)
     {
       // FIXME -- there has to be a better way.  I think we want to
       // ask whether it is OK to delete the listener for the given
       // property.  How can we know in advance that it will be OK?
 
-      unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
-
-      unwind_protect::protect_var (discard_error_messages);
-      unwind_protect::protect_var (error_state);
+      unwind_protect frame;
+
+      frame.protect_var (discard_error_messages);
+      frame.protect_var (error_state);
 
       discard_error_messages = true;
 
       property p = get_properties ().get_property (pa->first);
 
       if (! error_state && p.ok ())
 	p.delete_listener ();
-
-      unwind_protect::run_frame (uwp_frame);
     }
 }
 
 // ---------------------------------------------------------------------
 
 #include "graphics-props.cc"
 
 // ---------------------------------------------------------------------
@@ -3854,17 +3852,19 @@ axes::update_axis_limits (const std::str
 	  limits(0) = min_val;
 	  limits(1) = max_val;
 
 	  update_type = 'a';
 	}
 
     }
 
-  unwind_protect::protect_var (updating_axis_limits);
+  unwind_protect frame;
+  frame.protect_var (updating_axis_limits);
+
   updating_axis_limits = true;
 
   switch (update_type)
     {
     case 'x':
       xproperties.set_xlim (limits);
       xproperties.set_xlimmode ("auto");
       xproperties.update_xlim ();
@@ -3892,18 +3892,16 @@ axes::update_axis_limits (const std::str
       xproperties.set_alimmode ("auto");
       break;
 
     default:
       break;
     }
 
   xproperties.update_transform ();
-
-  unwind_protect::run ();
 }
 
 inline
 double force_in_range (const double x, const double lower, const double upper)
 {
   if (x < lower)
     { return lower; }
   else if (x > upper)
@@ -4496,18 +4494,18 @@ gh_manager::do_execute_callback (const g
   octave_function *fcn = 0;
 
   args(0) = h.as_octave_value ();
   if (data.is_defined ())
     args(1) = data;
   else
     args(1) = Matrix ();
 
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
-  unwind_protect::add_fcn (gh_manager::restore_gcbo);
+  unwind_protect_safe frame;
+  frame.add_fcn (gh_manager::restore_gcbo);
 
   if (true)
     {
       gh_manager::autolock guard;
   
       callback_objects.push_front (get_object (h));
       xset_gcbo (h);
     }
@@ -4546,18 +4544,16 @@ gh_manager::do_execute_callback (const g
       error ("trying to execute non-executable object (class = %s)",
 	     nm.c_str ());
     }
 
   if (fcn && ! error_state)
     feval (fcn, args);
   
   END_INTERRUPT_WITH_EXCEPTIONS;
-
-  unwind_protect::run_frame (uwp_frame);
 }
 
 void
 gh_manager::do_post_event (const graphics_event& e)
 {
   event_queue.push_back (e);
 
   command_editor::add_event_hook (gh_manager::process_events);
@@ -5376,20 +5372,20 @@ undocumented.\n\
 {
   static int drawnow_executing = 0;
   static bool __go_close_all_registered__ = false;
 
   octave_value retval;
 
   gh_manager::lock ();
 
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
-  unwind_protect::protect_var (Vdrawnow_requested, false);
-
-  unwind_protect::protect_var (drawnow_executing);
+  unwind_protect frame;
+  frame.protect_var (Vdrawnow_requested, false);
+
+  frame.protect_var (drawnow_executing);
 
   if (++drawnow_executing <= 1)
     {
       if (! __go_close_all_registered__)
 	{
 	  octave_add_atexit_function ("__go_close_all__");
 
 	  __go_close_all_registered__ = true;
@@ -5514,18 +5510,16 @@ undocumented.\n\
 	    }
 	  else
 	    error ("drawnow: invalid terminal, expected a string value");
 	}
       else
 	print_usage ();
     }
 
-  unwind_protect::run_frame (uwp_frame);
-
   gh_manager::unlock ();
 
   return retval;
 }
 
 DEFUN (addlistener, args, ,
    "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} addlistener (@var{h}, @var{prop}, @var{fcn})\n\
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -661,23 +661,22 @@ raw_help_from_symbol_table (const std::s
 
 static bool
 raw_help_from_file (const std::string& nm, std::string& h, 
 		    std::string& file, bool& symbol_found)
 {
   bool retval = false;
 
   // FIXME -- this is a bit of a kluge...
-  unwind_protect::protect_var (reading_script_file);
+  unwind_protect frame;
+  frame.protect_var (reading_script_file);
   reading_script_file = true;
 
   h = get_help_from_file (nm, symbol_found, file);
 
-  unwind_protect::run ();
-
   if (h.length () > 0)
     retval = true;
 
   return retval;
 }
 
 static bool
 raw_help_from_map (const std::string& nm, std::string& h, 
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -681,74 +681,75 @@ get_debug_input (const std::string& prom
 	}
     }
 
   std::string msg = buf.str ();
 
   if (! msg.empty ())
     std::cerr << msg << std::endl;
 
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+  unwind_protect frame;
 
-  unwind_protect::protect_var (VPS1);
+  frame.protect_var (VPS1);
   VPS1 = prompt;
 
   if (stdin_is_tty)
     {
       if (! (interactive || forced_interactive)
           || (reading_fcn_file
               || reading_classdef_file
               || reading_script_file
               || get_input_from_eval_string
               || input_from_startup_file
               || input_from_command_line_file))
         {
-          unwind_protect::protect_var (forced_interactive);
+          frame.protect_var (forced_interactive);
           forced_interactive = true;
 
-          unwind_protect::protect_var (reading_fcn_file);
+          frame.protect_var (reading_fcn_file);
           reading_fcn_file = false;
 
-          unwind_protect::protect_var (reading_classdef_file);
+          frame.protect_var (reading_classdef_file);
           reading_classdef_file = false;
 
-          unwind_protect::protect_var (reading_script_file);
+          frame.protect_var (reading_script_file);
           reading_script_file = false;
 
-          unwind_protect::protect_var (input_from_startup_file);
+          frame.protect_var (input_from_startup_file);
           input_from_startup_file = false;
 
-          unwind_protect::protect_var (input_from_command_line_file);
+          frame.protect_var (input_from_command_line_file);
           input_from_command_line_file = false;
 
-          unwind_protect::protect_var (get_input_from_eval_string);
+          frame.protect_var (get_input_from_eval_string);
           get_input_from_eval_string = false;
 
           YY_BUFFER_STATE old_buf = current_buffer ();
           YY_BUFFER_STATE new_buf = create_buffer (get_input_from_stdin ());
 
-          unwind_protect::add_fcn (switch_to_buffer, old_buf);
-          unwind_protect::add_fcn (delete_buffer, new_buf);
+          // FIXME: are these safe?
+          frame.add_fcn (switch_to_buffer, old_buf);
+          frame.add_fcn (delete_buffer, new_buf);
 
           switch_to_buffer (new_buf);
         }
 
       while (Vdebugging)
         {
           reset_error_handler ();
 
           reset_parser ();
 
           // Save current value of global_command.
-          unwind_protect::protect_var (global_command);
+          frame.protect_var (global_command);
 
           // Do this with an unwind-protect cleanup function so that the
           // forced variables will be unmarked in the event of an interrupt.
           symbol_table::scope_id scope = symbol_table::top_scope ();
-          unwind_protect::add_fcn (symbol_table::unmark_forced_variables, scope);
+          frame.add_fcn (symbol_table::unmark_forced_variables, scope);
 
           // This is the same as yyparse in parse.y.
           int retval = octave_parse ();
 
           if (retval == 0 && global_command)
             {
               global_command->accept (*current_evaluator);
 
@@ -762,28 +763,24 @@ get_debug_input (const std::string& prom
               //
               // global_command = 0;
 
               if (octave_completion_matches_called)
                 octave_completion_matches_called = false;
             }
 
           // Unmark forced variables.
-          unwind_protect::run ();
-
           // Restore previous value of global_command.
-          unwind_protect::run ();
+          frame.run_top (2);
 
           OCTAVE_QUIT;
         }
     }
   else
     warning ("invalid attempt to debug script read from stdin");
-
-  unwind_protect::run_frame (uwp_frame);
 }
 
 // If the user simply hits return, this will produce an empty matrix.
 
 static octave_value_list
 get_user_input (const octave_value_list& args, int nargout)
 {
   octave_value_list retval;
@@ -955,30 +952,30 @@ octave_value
 do_keyboard (const octave_value_list& args)
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   assert (nargin == 0 || nargin == 1);
 
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+  unwind_protect frame;
 
   // FIXME -- we shouldn't need both the
   // command_history object and the
   // Vsaving_history variable...
   command_history::ignore_entries (false);
 
-  unwind_protect::add_fcn (command_history::ignore_entries, ! Vsaving_history);
+  frame.add_fcn (command_history::ignore_entries, ! Vsaving_history);
 
-  unwind_protect::protect_var (Vsaving_history);
-  unwind_protect::protect_var (Vdebugging);
+  frame.protect_var (Vsaving_history);
+  frame.protect_var (Vdebugging);
 
-  unwind_protect::add_fcn (octave_call_stack::restore_frame, 
-                           octave_call_stack::current_frame ());
+  frame.add_fcn (octave_call_stack::restore_frame, 
+                 octave_call_stack::current_frame ());
 
   // FIXME -- probably we just want to print one line, not the
   // entire statement, which might span many lines...
   //
   // tree_print_code tpc (octave_stdout);
   // stmt.accept (tpc);
 
   Vsaving_history = true;
@@ -986,18 +983,16 @@ do_keyboard (const octave_value_list& ar
 
   std::string prompt = "debug> ";
   if (nargin > 0)
     prompt = args(0).string_value ();
 
   if (! error_state)
     get_debug_input (prompt);
 
-  unwind_protect::run_frame (uwp_frame);
-
   return retval;
 }
 
 DEFUN (keyboard, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} keyboard ()\n\
 @deftypefnx {Built-in Function} {} keyboard (@var{prompt})\n\
 This function is normally used for simple debugging.  When the\n\
@@ -1014,25 +1009,24 @@ If @code{keyboard} is invoked without ar
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 0 || nargin == 1)
     {
-      unwind_protect::add_fcn (octave_call_stack::restore_frame, 
-			       octave_call_stack::current_frame ());
+      unwind_protect frame;
+      frame.add_fcn (octave_call_stack::restore_frame, 
+                     octave_call_stack::current_frame ());
 
       // Skip the frame assigned to the keyboard function.
       octave_call_stack::goto_frame_relative (0);
 
       do_keyboard (args);
-
-      unwind_protect::run ();
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (echo, args, ,
diff --git a/src/load-path.cc b/src/load-path.cc
--- a/src/load-path.cc
+++ b/src/load-path.cc
@@ -557,30 +557,30 @@ split_path (const std::string& p)
 
 void
 load_path::do_set (const std::string& p, bool warn)
 {
   std::list<std::string> elts = split_path (p);
 
   // Temporarily disable add hook.
 
-  unwind_protect::protect_var (add_hook);
+  unwind_protect frame;
+  frame.protect_var (add_hook);
 
   add_hook = 0;
 
   do_clear ();
 
   for (std::list<std::string>::const_iterator i = elts.begin ();
        i != elts.end ();
        i++)
     do_append (*i, warn);
 
   // Restore add hook and execute for all newly added directories.
-
-  unwind_protect::run ();
+  frame.run_top ();
 
   for (dir_info_list_iterator i = dir_info_list.begin ();
        i != dir_info_list.end ();
        i++)
     {
       if (add_hook)
 	add_hook (i->dir_name);
     }
@@ -1815,30 +1815,28 @@ genpath (const std::string& dirname, con
 
 static void
 execute_pkg_add_or_del (const std::string& dir,
 			const std::string& script_file)
 {
   if (! octave_interpreter_ready)
     return;
 
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
-
-  unwind_protect::protect_var (input_from_startup_file);
+  unwind_protect frame;
+
+  frame.protect_var (input_from_startup_file);
 
   input_from_startup_file = true;
 
   std::string file = file_ops::concat (dir, script_file);
 
   file_stat fs (file);
 
   if (fs.exists ())
     source_file (file, "base");
-
-  unwind_protect::run_frame (uwp_frame);
 }
 
 void
 execute_pkg_add (const std::string& dir)
 {
   execute_pkg_add_or_del (dir, "PKG_ADD");
 }
 
diff --git a/src/ls-mat4.cc b/src/ls-mat4.cc
--- a/src/ls-mat4.cc
+++ b/src/ls-mat4.cc
@@ -487,17 +487,17 @@ save_mat_binary_data (std::ostream& os, 
 
   int32_t name_len = name.length () + 1;
 
   os.write (reinterpret_cast<char *> (&name_len), 4);
   os << name << '\0';
 
   if (tc.is_string ())
     {
-      unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+      unwind_protect frame;
 
       charMatrix chm = tc.char_matrix_value ();
 
       octave_idx_type nrow = chm.rows ();
       octave_idx_type ncol = chm.cols ();
 	
       OCTAVE_LOCAL_BUFFER (double, buf, ncol*nrow);
 	
@@ -505,18 +505,16 @@ save_mat_binary_data (std::ostream& os, 
       	{
 	  std::string tstr = chm.row_as_string (i);
 	  const char *s = tstr.data ();
 	  
 	  for (octave_idx_type j = 0; j < ncol; j++)
 	    buf[j*nrow+i] = static_cast<double> (*s++ & 0x00FF);
        	}
       os.write (reinterpret_cast<char *> (buf), nrow*ncol*sizeof(double));
-      
-      unwind_protect::run_frame (uwp_frame);
     }
   else if (tc.is_range ())
     {
       Range r = tc.range_value ();
       double base = r.base ();
       double inc = r.inc ();
       octave_idx_type nel = r.nelem ();
       for (octave_idx_type i = 0; i < nel; i++)
diff --git a/src/ls-mat5.cc b/src/ls-mat5.cc
--- a/src/ls-mat5.cc
+++ b/src/ls-mat5.cc
@@ -864,28 +864,28 @@ read_mat5_binary_element (std::istream& 
 	    Octave_map m2 = m1.contents("workspace")(0).map_value();
 	    uint32NDArray MCOS = m2.contents("MCOS")(0).uint32_array_value();
 	    octave_idx_type off = static_cast<octave_idx_type>(MCOS(4).double_value ());
 	    m2 = subsys_ov.map_value();
 	    m2 = m2.contents("MCOS")(0).map_value();
 	    tc2 = m2.contents("MCOS")(0).cell_value()(1 + off).cell_value()(1);
 	    m2 = tc2.map_value();
 
-	    unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+	    unwind_protect_safe frame;
 
 	    // Set up temporary scope to use for evaluating the text
 	    // that defines the anonymous function.
 
 	    symbol_table::scope_id local_scope = symbol_table::alloc_scope ();
-	    unwind_protect::add_fcn (symbol_table::erase_scope, local_scope);
+	    frame.add_fcn (symbol_table::erase_scope, local_scope);
 
 	    symbol_table::set_scope (local_scope);
 
 	    octave_call_stack::push (local_scope, 0);
-	    unwind_protect::add_fcn (octave_call_stack::pop);
+	    frame.add_fcn (octave_call_stack::pop);
 
 	    if (m2.nfields() > 0)
 	      {
 		octave_value tmp;
       
 		for (Octave_map::iterator p0 = m2.begin() ; 
 		     p0 != m2.end(); p0++)
 		  {
@@ -914,17 +914,17 @@ read_mat5_binary_element (std::istream& 
 		  }
 	      }
 	    else
 	      {
 		error ("load: failed to load anonymous function handle");
 		goto skip_ahead;
 	      }
 
-	    unwind_protect::run_frame (uwp_frame);
+	    frame.run ();
 	  }
 	else
 	  {
 	    error ("load: invalid function handle type");
 	    goto skip_ahead;
 	  }
       }
       break;
diff --git a/src/mex.cc b/src/mex.cc
--- a/src/mex.cc
+++ b/src/mex.cc
@@ -3033,24 +3033,24 @@ call_mex (bool have_fmex, void *f, const
   for (int i = 0; i < nargin; i++)
     argin[i] = 0;
 
   int nout = nargout == 0 ? 1 : nargout;
   OCTAVE_LOCAL_BUFFER (mxArray *, argout, nout);
   for (int i = 0; i < nout; i++)
     argout[i] = 0;
 
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+  unwind_protect_safe frame;
 
   // Save old mex pointer.
-  unwind_protect::protect_var (mex_context);
+  frame.protect_var (mex_context);
 
   mex context (curr_mex_fcn);
 
-  unwind_protect::add (mex::cleanup, static_cast<void *> (&context));
+  frame.add (mex::cleanup, static_cast<void *> (&context));
 
   for (int i = 0; i < nargin; i++)
     argin[i] = context.make_value (args(i));
 
   if (setjmp (context.jump) == 0)
     {
       mex_context = &context;
 
@@ -3085,17 +3085,17 @@ call_mex (bool have_fmex, void *f, const
 
       retval.resize (nargout);
 
       for (int i = 0; i < nargout; i++)
 	retval(i) = mxArray::as_octave_value (argout[i]);
     }
 
   // Clean up mex resources.
-  unwind_protect::run_frame (uwp_frame);
+  frame.run ();
 
   return retval;
 }
 
 // C interface to mex functions:
 
 const char *
 mexFunctionName (void)
@@ -3265,37 +3265,35 @@ mexGetVariable (const char *space, const
   octave_value val;
 
   if (! strcmp (space, "global"))
     val = get_global_value (name);
   else
     {
       // FIXME -- should this be in variables.cc?
 
-      unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+      unwind_protect frame;
 
       bool caller = ! strcmp (space, "caller");
       bool base = ! strcmp (space, "base");
 
       if (caller || base)
 	{
 	  if (caller)
 	    octave_call_stack::goto_caller_frame ();
 	  else
 	    octave_call_stack::goto_base_frame ();
 
 	  if (! error_state)
-	    unwind_protect::add_fcn (octave_call_stack::pop);
+	    frame.add_fcn (octave_call_stack::pop);
 
 	  val = symbol_table::varval (name);
 	}
       else
 	mexErrMsgTxt ("mexGetVariable: symbol table does not exist");
-
-      unwind_protect::run_frame (uwp_frame);
     }
 
   if (val.is_defined ())
     {
       retval = mex_context->make_value (val);
 
       retval->set_name (name);
     }
@@ -3325,37 +3323,35 @@ mexPutVariable (const char *space, const
     return 1;
 
   if (! strcmp (space, "global"))
     set_global_value (name, mxArray::as_octave_value (ptr));
   else
     {
       // FIXME -- should this be in variables.cc?
 
-      unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+      unwind_protect frame;
 
       bool caller = ! strcmp (space, "caller");
       bool base = ! strcmp (space, "base");
 
       if (caller || base)
 	{
 	  if (caller)
 	    octave_call_stack::goto_caller_frame ();
 	  else
 	    octave_call_stack::goto_base_frame ();
 
 	  if (! error_state)
-	    unwind_protect::add_fcn (octave_call_stack::pop);
+	    frame.add_fcn (octave_call_stack::pop);
 
 	  symbol_table::varref (name) = mxArray::as_octave_value (ptr);
 	}
       else
 	mexErrMsgTxt ("mexPutVariable: symbol table does not exist");
-
-      unwind_protect::run_frame (uwp_frame);
     }
 
   return 0;
 }
 
 void
 mexMakeArrayPersistent (mxArray *ptr)
 {
diff --git a/src/oct-hist.cc b/src/oct-hist.cc
--- a/src/oct-hist.cc
+++ b/src/oct-hist.cc
@@ -419,16 +419,21 @@ mk_tmp_hist_file (int argc, const string
 	file << hlist[i] << "\n";
     }
 
   file.close ();
 
   return name;
 }
 
+static void unlink_cleanup (const char *file)
+{
+  unlink (file);
+}
+
 static void
 do_edit_history (int argc, const string_vector& argv)
 {
   std::string name = mk_tmp_hist_file (argc, argv, 0, "edit_history");
 
   if (name.empty ())
     return;
 
@@ -475,62 +480,49 @@ do_edit_history (int argc, const string_
 	edit_history_add_hist (line);
     }
 
   file.close ();
 
   // Turn on command echo, so the output from this will make better
   // sense.
 
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+  unwind_protect frame;
 
-  unwind_protect::protect_var (Vecho_executing_commands);
-  unwind_protect::protect_var (input_from_tmp_history_file);
+  frame.add_fcn (unlink_cleanup, name.c_str ());
+  frame.protect_var (Vecho_executing_commands);
+  frame.protect_var (input_from_tmp_history_file);
 
   Vecho_executing_commands = ECHO_CMD_LINE;
   input_from_tmp_history_file = true;
 
   source_file (name);
-
-  unwind_protect::run_frame (uwp_frame);
-
-  // Delete the temporary file.  Should probably be done with an
-  // unwind_protect.
-
-  unlink (name.c_str ());
 }
 
 static void
 do_run_history (int argc, const string_vector& argv)
 {
   std::string name = mk_tmp_hist_file (argc, argv, 1, "run_history");
 
   if (name.empty ())
     return;
 
   // Turn on command echo so the output from this will make better
   // sense.
 
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+  unwind_protect frame;
 
-  unwind_protect::protect_var (Vecho_executing_commands);
-  unwind_protect::protect_var (input_from_tmp_history_file);
+  frame.add_fcn (unlink_cleanup, name.c_str ());
+  frame.protect_var (Vecho_executing_commands);
+  frame.protect_var (input_from_tmp_history_file);
 
   Vecho_executing_commands = ECHO_CMD_LINE;
   input_from_tmp_history_file = true;
 
   source_file (name);
-
-  unwind_protect::run_frame (uwp_frame);
-
-  // Delete the temporary file.
-
-  // FIXME -- should probably be done using an unwind_protect.
-
-  unlink (name.c_str ());
 }
 
 void
 initialize_history (bool read_history_file)
 {
   command_history::set_file (Vhistory_file);
   command_history::set_size (Vhistory_size);
 
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -286,19 +286,19 @@ initialize_version_info (void)
   F__version_info__ (args, 0);
 }
 
 // Initialize by reading startup files.
 
 static void
 execute_startup_files (void)
 {
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+  unwind_protect frame;
 
-  unwind_protect::protect_var (input_from_startup_file);
+  frame.protect_var (input_from_startup_file);
 
   input_from_startup_file = true;
 
   std::string context;
 
   bool verbose = (verbose_flag && ! inhibit_startup_message);
 
   bool require_file = false;
@@ -362,38 +362,36 @@ execute_startup_files (void)
 	      std::string curr_dir = octave_env::getcwd ();
 
 	      local_rc = octave_env::make_absolute (initfile, curr_dir);
 	    }
 
 	  source_file (local_rc, context, verbose, require_file);
 	}
     }
-
-  unwind_protect::run_frame (uwp_frame);
 }
 
 static int
 execute_eval_option_code (const std::string& code)
 {
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+  unwind_protect frame;
 
   octave_save_signal_mask ();
 
   can_interrupt = true;
 
   octave_signal_hook = octave_signal_handler;
-  octave_interrupt_hook = unwind_protect::run_all;
-  octave_bad_alloc_hook = unwind_protect::run_all;
+  octave_interrupt_hook = 0;
+  octave_bad_alloc_hook = 0;
 
   octave_catch_interrupts ();
 
   octave_initialized = true;
 
-  unwind_protect::protect_var (interactive);
+  frame.protect_var (interactive);
 
   interactive = false;
 
   int parse_status = 0;
 
   try
     {
       eval_string (code, false, parse_status, 0);
@@ -406,47 +404,45 @@ execute_eval_option_code (const std::str
         clean_up_and_exit (exit_status);
     }
   catch (std::bad_alloc)
     {
       std::cerr << "error: memory exhausted or requested size too large for range of Octave's index type -- eval failed"
 		<< std::endl;
     }
 
-  unwind_protect::run_frame (uwp_frame);
-
   return parse_status;
 }
 
 static void
 execute_command_line_file (const std::string& fname)
 {
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+  unwind_protect frame;
 
   octave_save_signal_mask ();
 
   can_interrupt = true;
 
   octave_signal_hook = octave_signal_handler;
-  octave_interrupt_hook = unwind_protect::run_all;
-  octave_bad_alloc_hook = unwind_protect::run_all;
+  octave_interrupt_hook = 0;
+  octave_bad_alloc_hook = 0;
 
   octave_catch_interrupts ();
 
   octave_initialized = true;
 
-  unwind_protect::protect_var (interactive);
-  unwind_protect::protect_var (reading_script_file);
-  unwind_protect::protect_var (input_from_command_line_file);
+  frame.protect_var (interactive);
+  frame.protect_var (reading_script_file);
+  frame.protect_var (input_from_command_line_file);
 
-  unwind_protect::protect_var (curr_fcn_file_name);
-  unwind_protect::protect_var (curr_fcn_file_full_name);
+  frame.protect_var (curr_fcn_file_name);
+  frame.protect_var (curr_fcn_file_full_name);
 
-  unwind_protect::protect_var (octave_program_invocation_name);
-  unwind_protect::protect_var (octave_program_name);
+  frame.protect_var (octave_program_invocation_name);
+  frame.protect_var (octave_program_name);
 
   interactive = false;
   reading_script_file = true;
   input_from_command_line_file = true;
 
   curr_fcn_file_name = fname;
   curr_fcn_file_full_name = curr_fcn_file_name;
 
@@ -474,18 +470,16 @@ execute_command_line_file (const std::st
       if (quitting_gracefully)
         clean_up_and_exit (exit_status);
     }
   catch (std::bad_alloc)
     {
       std::cerr << "error: memory exhausted or requested size too large for range of Octave's index type -- execution of "
 		<< fname << " failed" << std::endl;
     }
- 
-  unwind_protect::run_frame (uwp_frame);
 }
 
 // Usage message with extra help.
 
 static void
 verbose_usage (void)
 {
   std::cout << OCTAVE_NAME_VERSION_COPYRIGHT_COPYING_AND_WARRANTY "\n\
diff --git a/src/ov-builtin.cc b/src/ov-builtin.cc
--- a/src/ov-builtin.cc
+++ b/src/ov-builtin.cc
@@ -91,35 +91,33 @@ octave_builtin::do_multi_index_op (int n
 
   if (error_state)
     return retval;
 
   if (args.has_magic_colon ())
     ::error ("invalid use of colon in function argument list");
   else
     {
-      unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+      unwind_protect frame;
 
       octave_call_stack::push (this);
 
-      unwind_protect::add_fcn (octave_call_stack::pop);
+      frame.add_fcn (octave_call_stack::pop);
 
       try
 	{
 	  retval = (*f) (args, nargout);
           // Do not allow null values to be returned from functions.
           // FIXME -- perhaps true builtins should be allowed?
           retval.make_storable_values ();
 	}
       catch (octave_execution_exception)
 	{
 	  gripe_library_execution_error ();
 	}
-
-      unwind_protect::run_frame (uwp_frame);
     }
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/ov-class.cc b/src/ov-class.cc
--- a/src/ov-class.cc
+++ b/src/ov-class.cc
@@ -573,22 +573,21 @@ octave_class::subsasgn (const std::strin
           // copies anywhere. If it does, things will not break but the
           // optimization won't work.
 
           octave_value_list tmp;
 
           if (obsolete_copies == 0 && meth.is_user_function ()
               && meth.user_function_value ()->subsasgn_optimization_ok ())
             {
-              unwind_protect::protect_var (obsolete_copies);
+              unwind_protect frame;
+              frame.protect_var (obsolete_copies);
               obsolete_copies = 2;
 
               tmp = feval (meth.function_value (), args);
-
-              unwind_protect::run ();
             }
           else
             tmp = feval (meth.function_value (), args);
 
 	  // FIXME -- should the subsasgn method be able to return
 	  // more than one value?
 
 	  if (tmp.length () > 1)
@@ -978,25 +977,23 @@ void
 octave_class::print (std::ostream& os, bool) const
 {
   print_raw (os);
 }
 
 void
 octave_class::print_raw (std::ostream& os, bool) const
 {
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+  unwind_protect frame;
 
-  unwind_protect::protect_var (Vstruct_levels_to_print);
+  frame.protect_var (Vstruct_levels_to_print);
 
   indent (os);
   os << "  <class " << class_name () << ">";
   newline (os);
-
-  unwind_protect::run_frame (uwp_frame);
 }
 
 bool
 octave_class::print_name_tag (std::ostream& os, const std::string& name) const
 {
   bool retval = false;
 
   indent (os);
diff --git a/src/ov-fcn-handle.cc b/src/ov-fcn-handle.cc
--- a/src/ov-fcn-handle.cc
+++ b/src/ov-fcn-handle.cc
@@ -374,28 +374,28 @@ octave_fcn_handle::load_ascii (std::istr
 	  // Get a line of text whitespace characters included, leaving
 	  // newline in the stream.
 	  buf = read_until_newline (is, true);
 
 	}
 
       pos = is.tellg ();
 
-      unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+      unwind_protect_safe frame;
 
       // Set up temporary scope to use for evaluating the text that
       // defines the anonymous function.
 
       symbol_table::scope_id local_scope = symbol_table::alloc_scope ();
-      unwind_protect::add_fcn (symbol_table::erase_scope, local_scope);
+      frame.add_fcn (symbol_table::erase_scope, local_scope);
 
       symbol_table::set_scope (local_scope);
 
       octave_call_stack::push (local_scope, 0);
-      unwind_protect::add_fcn (octave_call_stack::pop);
+      frame.add_fcn (octave_call_stack::pop);
 
       octave_idx_type len = 0;
 
       if (extract_keyword (is, "length", len, true) && len >= 0)
 	{
 	  if (len > 0)
 	    {
 	      for (octave_idx_type i = 0; i < len; i++)
@@ -445,18 +445,16 @@ octave_fcn_handle::load_ascii (std::istr
 	      else
 		success = false;
 	    }
 	  else
 	    success = false;
 	}
       else
 	success = false;
-
-      unwind_protect::run_frame (uwp_frame);
     }
   else
     success = set_fcn (octaveroot, fpath);
 
   return success;
 }
 
 bool
@@ -555,28 +553,28 @@ octave_fcn_handle::load_binary (std::ist
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
 	return false;
       if (swap)
 	swap_bytes<4> (&tmp);
 
       OCTAVE_LOCAL_BUFFER (char, ctmp2, tmp+1);
       is.get (ctmp2, tmp+1, 0);
 
-      unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+      unwind_protect_safe frame;
 
       // Set up temporary scope to use for evaluating the text that
       // defines the anonymous function.
 
       symbol_table::scope_id local_scope = symbol_table::alloc_scope ();
-      unwind_protect::add_fcn (symbol_table::erase_scope, local_scope);	      
+      frame.add_fcn (symbol_table::erase_scope, local_scope);	      
 
       symbol_table::set_scope (local_scope);
 
       octave_call_stack::push (local_scope, 0);
-      unwind_protect::add_fcn (octave_call_stack::pop);
+      frame.add_fcn (octave_call_stack::pop);
 
       if (len > 0)
 	{
 	  for (octave_idx_type i = 0; i < len; i++)
 	    {
 	      octave_value t2;
 	      bool dummy;
 	      std::string doc;
@@ -615,18 +613,16 @@ octave_fcn_handle::load_binary (std::ist
 		    symbol_table::cache_name (uf->scope (), nm);
 		}
 	      else
 		success = false;
 	    }
 	  else
 	    success = false;
 	}
-
-      unwind_protect::run_frame (uwp_frame);
     }
   else
     {
       std::string octaveroot;
       std::string fpath;
 
       if (nm.find_first_of ("\n") != std::string::npos)
 	{
@@ -1052,28 +1048,28 @@ octave_fcn_handle::load_hdf5 (hid_t loc_
 
       // restore error reporting:
 #if HAVE_HDF5_18
       H5Eset_auto (H5E_DEFAULT, err_func, err_func_data);
 #else
       H5Eset_auto (err_func, err_func_data);
 #endif
 
-      unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+      unwind_protect_safe frame;
 
       // Set up temporary scope to use for evaluating the text that
       // defines the anonymous function.
 
       symbol_table::scope_id local_scope = symbol_table::alloc_scope ();
-      unwind_protect::add_fcn (symbol_table::erase_scope, local_scope);
+      frame.add_fcn (symbol_table::erase_scope, local_scope);
 
       symbol_table::set_scope (local_scope);
 
       octave_call_stack::push (local_scope, 0);
-      unwind_protect::add_fcn (octave_call_stack::pop);
+      frame.add_fcn (octave_call_stack::pop);
 
       if (len > 0 && success)
 	{
 	  hsize_t num_obj = 0;
 #if HAVE_HDF5_18
 	  data_hid = H5Gopen (group_hid, "symbol table", H5P_DEFAULT); 
 #else
 	  data_hid = H5Gopen (group_hid, "symbol table"); 
@@ -1127,17 +1123,17 @@ octave_fcn_handle::load_hdf5 (hid_t loc_
 		}
 	      else
 		success = false;
 	    }
 	  else
 	    success = false;
 	}
 
-      unwind_protect::run_frame (uwp_frame);
+      frame.run ();
     }
   else
     {
       std::string octaveroot;
       std::string fpath;
 
       // we have to pull some shenanigans here to make sure
       // HDF5 doesn't print out all sorts of error messages if we
diff --git a/src/ov-list.cc b/src/ov-list.cc
--- a/src/ov-list.cc
+++ b/src/ov-list.cc
@@ -288,17 +288,17 @@ void
 octave_list::print (std::ostream& os, bool) const
 {
   print_raw (os);
 }
 
 void
 octave_list::print_raw (std::ostream& os, bool) const
 {
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+  unwind_protect frame;
 
   octave_idx_type n = data.length ();
 
   if (n > 0)
     {
       indent (os);
       os << "(";
       newline (os);
@@ -320,18 +320,16 @@ octave_list::print_raw (std::ostream& os
 
       indent (os);
       os << ")";
     }
   else
     os << "()";
 
   newline (os);
-
-  unwind_protect::run_frame (uwp_frame);
 }
 
 bool
 octave_list::print_name_tag (std::ostream& os, const std::string& name) const
 {
   indent (os);
   if (data.length () == 0)
     os << name << " = ";
diff --git a/src/ov-mex-fcn.cc b/src/ov-mex-fcn.cc
--- a/src/ov-mex-fcn.cc
+++ b/src/ov-mex-fcn.cc
@@ -134,32 +134,30 @@ octave_mex_function::do_multi_index_op (
 
   if (error_state)
     return retval;
 
   if (args.has_magic_colon ())
     ::error ("invalid use of colon in function argument list");
   else
     {
-      unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+      unwind_protect frame;
 
       octave_call_stack::push (this);
 
-      unwind_protect::add_fcn (octave_call_stack::pop);
+      frame.add_fcn (octave_call_stack::pop);
 
       try
 	{
 	  retval = call_mex (have_fmex, mex_fcn_ptr, args, nargout, this);
 	}
       catch (octave_execution_exception)
 	{
 	  gripe_library_execution_error ();
 	}
-
-      unwind_protect::run_frame (uwp_frame);
     }
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -575,19 +575,19 @@ void
 octave_struct::print (std::ostream& os, bool) const
 {
   print_raw (os);
 }
 
 void
 octave_struct::print_raw (std::ostream& os, bool) const
 {
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+  unwind_protect frame;
 
-  unwind_protect::protect_var (Vstruct_levels_to_print);
+  frame.protect_var (Vstruct_levels_to_print);
 
   if (Vstruct_levels_to_print >= 0)
     {
       bool print_keys_only = Vstruct_levels_to_print-- == 0;
 
       indent (os);
       os << "{";
       newline (os);
@@ -642,18 +642,16 @@ octave_struct::print_raw (std::ostream& 
       newline (os);
     }
   else
     {
       indent (os);
       os << "<structure>";
       newline (os);
     }
-
-  unwind_protect::run_frame (uwp_frame);
 }
 
 bool
 octave_struct::print_name_tag (std::ostream& os, const std::string& name) const
 {
   bool retval = false;
 
   indent (os);
diff --git a/src/ov-usr-fcn.cc b/src/ov-usr-fcn.cc
--- a/src/ov-usr-fcn.cc
+++ b/src/ov-usr-fcn.cc
@@ -109,34 +109,34 @@ octave_user_script::subsref (const std::
 }
 
 octave_value_list
 octave_user_script::do_multi_index_op (int nargout,
 				       const octave_value_list& args)
 {
   octave_value_list retval;
 
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+  unwind_protect frame;
 
   if (! error_state)
     {
       if (args.length () == 0 && nargout == 0)
 	{
 	  if (cmd_list)
 	    {
-	      unwind_protect::protect_var (call_depth);
+	      frame.protect_var (call_depth);
 	      call_depth++;
 
 	      if (call_depth < Vmax_recursion_depth)
 		{
 		  octave_call_stack::push (this);
 
-                  unwind_protect::add_fcn (octave_call_stack::pop);
+                  frame.add_fcn (octave_call_stack::pop);
 
-		  unwind_protect::protect_var (tree_evaluator::in_fcn_or_script_body);
+		  frame.protect_var (tree_evaluator::in_fcn_or_script_body);
 		  tree_evaluator::in_fcn_or_script_body = true;
 
 		  cmd_list->accept (*current_evaluator);
 
 		  if (tree_return_command::returning)
 		    tree_return_command::returning = 0;
 
 		  if (tree_break_command::breaking)
@@ -148,18 +148,16 @@ octave_user_script::do_multi_index_op (i
 	      else
 		::error ("max_recursion_limit exceeded");
     	    }
 	}
       else
 	error ("invalid call to script %s", file_name.c_str ());
     }
 
-  unwind_protect::run_frame (uwp_frame);
-
   return retval;
 }
 
 void
 octave_user_script::accept (tree_walker& tw)
 {
   tw.visit_octave_user_script (*this);
 }
@@ -329,161 +327,149 @@ octave_user_function::do_multi_index_op 
   if (error_state)
     return retval;
 
   if (! cmd_list)
     return retval;
 
   int nargin = args.length ();
 
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+  unwind_protect frame;
 
-  unwind_protect::protect_var (call_depth);
+  frame.protect_var (call_depth);
   call_depth++;
 
   if (call_depth >= Vmax_recursion_depth)
     {
       ::error ("max_recursion_limit exceeded");
-      unwind_protect::run_frame (uwp_frame);
       return retval;
     }
 
   // Save old and set current symbol table context, for
   // eval_undefined_error().
 
   octave_call_stack::push (this, local_scope, call_depth);
-  unwind_protect::add_fcn (octave_call_stack::pop);
+  frame.add_fcn (octave_call_stack::pop);
 
   if (call_depth > 0)
     {
       symbol_table::push_context ();
 
-      unwind_protect::add_fcn (symbol_table::pop_context);
+      frame.add_fcn (symbol_table::pop_context);
     }
 
   string_vector arg_names = args.name_tags ();
 
   if (param_list && ! param_list->varargs_only ())
     {
       param_list->define_from_arg_vector (args);
       if (error_state)
-	goto abort;
+        return retval;
     }
 
   // Force parameter list to be undefined when this function exits.
   // Doing so decrements the reference counts on the values of local
   // variables that are also named function parameters.
 
   if (param_list)
-    unwind_protect::add_method (param_list, 
-                                &tree_parameter_list::undefine);
+    frame.add_method (param_list, &tree_parameter_list::undefine);
 
   // Force return list to be undefined when this function exits.
   // Doing so decrements the reference counts on the values of local
   // variables that are also named values returned by this function.
 
   if (ret_list)
-    unwind_protect::add_method (ret_list, 
-                                &tree_parameter_list::undefine);
+    frame.add_method (ret_list, &tree_parameter_list::undefine);
 
   if (call_depth == 0)
     {
       // Force symbols to be undefined again when this function
       // exits.
       //
       // This cleanup function is added to the unwind_protect stack
       // after the calls to clear the parameter lists so that local
       // variables will be cleared before the parameter lists are
       // cleared.  That way, any function parameters that have been
       // declared global will be unmarked as global before they are
       // undefined by the clear_param_list cleanup function.
 
-      unwind_protect::add_fcn (symbol_table::clear_variables);
+      frame.add_fcn (symbol_table::clear_variables);
     }
 
-  // The following code is in a separate scope to avoid warnings from
-  // G++ about `goto abort' crossing the initialization of some
-  // variables.
+  bind_automatic_vars (arg_names, nargin, nargout, all_va_args (args));
 
-  {
-    bind_automatic_vars (arg_names, nargin, nargout, all_va_args (args));
+  bool echo_commands = (Vecho_executing_commands & ECHO_FUNCTIONS);
 
-    bool echo_commands = (Vecho_executing_commands & ECHO_FUNCTIONS);
+  if (echo_commands)
+    print_code_function_header ();
 
-    if (echo_commands)
-      print_code_function_header ();
-
-    // Evaluate the commands that make up the function.
+  // Evaluate the commands that make up the function.
 
-    unwind_protect::protect_var (tree_evaluator::in_fcn_or_script_body);
-    tree_evaluator::in_fcn_or_script_body = true;
+  frame.protect_var (tree_evaluator::in_fcn_or_script_body);
+  tree_evaluator::in_fcn_or_script_body = true;
 
-    bool special_expr = (is_inline_function ()
-			 || cmd_list->is_anon_function_body ());
+  bool special_expr = (is_inline_function ()
+                       || cmd_list->is_anon_function_body ());
 
-    if (special_expr)
-      {
-	assert (cmd_list->length () == 1);
+  if (special_expr)
+    {
+      assert (cmd_list->length () == 1);
 
-	tree_statement *stmt = 0;
+      tree_statement *stmt = 0;
 
-	if ((stmt = cmd_list->front ())
-	    && stmt->is_expression ())
-	  {
-	    tree_expression *expr = stmt->expression ();
+      if ((stmt = cmd_list->front ())
+          && stmt->is_expression ())
+        {
+          tree_expression *expr = stmt->expression ();
 
-	    retval = expr->rvalue (nargout);
-	  }
-      }
-    else
-      cmd_list->accept (*current_evaluator);
+          retval = expr->rvalue (nargout);
+        }
+    }
+  else
+    cmd_list->accept (*current_evaluator);
 
-    if (echo_commands)
-      print_code_function_trailer ();
+  if (echo_commands)
+    print_code_function_trailer ();
 
-    if (tree_return_command::returning)
-      tree_return_command::returning = 0;
+  if (tree_return_command::returning)
+    tree_return_command::returning = 0;
 
-    if (tree_break_command::breaking)
-      tree_break_command::breaking--;
+  if (tree_break_command::breaking)
+    tree_break_command::breaking--;
 
-    if (error_state)
-      {
-	octave_call_stack::backtrace_error_message ();
-	goto abort;
-      }
-    
-    // Copy return values out.
+  if (error_state)
+    {
+      octave_call_stack::backtrace_error_message ();
+      return retval;
+    }
+  
+  // Copy return values out.
 
-    if (ret_list && ! special_expr)
-      {
-	ret_list->initialize_undefined_elements (my_name, nargout, Matrix ());
-
-	Cell varargout;
+  if (ret_list && ! special_expr)
+    {
+      ret_list->initialize_undefined_elements (my_name, nargout, Matrix ());
 
-	if (ret_list->takes_varargs ())
-	  {
-	    octave_value varargout_varval = symbol_table::varval ("varargout");
+      Cell varargout;
 
-	    if (varargout_varval.is_defined ())
-	      {
-		varargout = varargout_varval.cell_value ();
+      if (ret_list->takes_varargs ())
+        {
+          octave_value varargout_varval = symbol_table::varval ("varargout");
 
-		if (error_state)
-		  error ("expecting varargout to be a cell array object");
-	      }
-	  }
+          if (varargout_varval.is_defined ())
+            {
+              varargout = varargout_varval.cell_value ();
 
-	if (! error_state)
-	  retval = ret_list->convert_to_const_vector (nargout, varargout);
-      }
-  }
+              if (error_state)
+                error ("expecting varargout to be a cell array object");
+            }
+        }
 
- abort:
-  unwind_protect::run_frame (uwp_frame);
+      if (! error_state)
+        retval = ret_list->convert_to_const_vector (nargout, varargout);
+    }
 
   return retval;
 }
 
 void
 octave_user_function::accept (tree_walker& tw)
 {
   tw.visit_octave_user_function (*this);
diff --git a/src/pager.cc b/src/pager.cc
--- a/src/pager.cc
+++ b/src/pager.cc
@@ -359,29 +359,27 @@ octave_diary_stream::stream (void)
   return *instance;
 }
 
 void
 flush_octave_stdout (void)
 {
   if (! flushing_output_to_pager)
     {
-      unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+      unwind_protect frame;
 
-      unwind_protect::protect_var (really_flush_to_pager);
-      unwind_protect::protect_var (flushing_output_to_pager);
+      frame.protect_var (really_flush_to_pager);
+      frame.protect_var (flushing_output_to_pager);
 
       really_flush_to_pager = true;
       flushing_output_to_pager = true;
 
       octave_stdout.flush ();
 
       clear_external_pager ();
-
-      unwind_protect::run_frame (uwp_frame);
     }
 }
 
 static void
 close_diary_file (void)
 {
   // Try to flush the current buffer to the diary now, so that things
   // like
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -3200,32 +3200,32 @@ representing the elements of @var{x}.  B
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2 || nargout > 1)
     print_usage ();
   else
     {
-      unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
-
-      unwind_protect::protect_var (rat_string_len);
+      unwind_protect frame;
+
+      frame.protect_var (rat_string_len);
 
       rat_string_len = 9;
 
       if (nargin == 2)
 	rat_string_len = args(1).nint_value ();
 
       if (! error_state)
 	{
 	  octave_value arg = args(0);
 
 	  if (arg.is_numeric_type ())
 	    {
-	      unwind_protect::protect_var (rat_format);
+	      frame.protect_var (rat_format);
 
 	      rat_format = true;
 
 	      std::ostringstream buf;
 	      args(0).print (buf);
 	      std::string s = buf.str ();
 
 	      std::list<std::string> lst;
@@ -3249,18 +3249,16 @@ representing the elements of @var{x}.  B
 		    }
 		}
 
 	      retval = string_vector (lst);
 	    }
 	  else
 	    error ("rats: expecting numeric input");
 	}
-
-      unwind_protect::run_frame (uwp_frame);
     }
 
   return retval;
 }
 
 DEFUN (disp, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} disp (@var{x})\n\
diff --git a/src/pt-arg-list.cc b/src/pt-arg-list.cc
--- a/src/pt-arg-list.cc
+++ b/src/pt-arg-list.cc
@@ -158,36 +158,36 @@ tree_argument_list::convert_to_const_vec
   // END doesn't make sense for functions.  Maybe we need a different
   // way of asking an octave_value object this question?
 
   bool stash_object = (list_includes_magic_end
 		       && object
 		       && ! (object->is_function ()
 			     || object->is_function_handle ()));
   
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+  unwind_protect frame;
 
   if (stash_object)
     {
-      unwind_protect::protect_var (indexed_object);
+      frame.protect_var (indexed_object);
 
       indexed_object = object;
     }
 
   int len = length ();
 
   std::list<octave_value_list> args;
 
   iterator p = begin ();
   for (int k = 0; k < len; k++)
     {
       if (stash_object)
 	{
-	  unwind_protect::protect_var (index_position);
-	  unwind_protect::protect_var (num_indices);
+	  frame.protect_var (index_position);
+	  frame.protect_var (num_indices);
 
 	  index_position = k;
 	  num_indices = len;
 	}
 
       tree_expression *elt = *p++;
 
       if (elt)
@@ -210,18 +210,16 @@ tree_argument_list::convert_to_const_vec
 	}
       else
 	{
 	  args.push_back (octave_value ());
 	  break;
 	}
     }
 
-  unwind_protect::run_frame (uwp_frame);
-
   return args;
 }
 
 std::list<octave_lvalue>
 tree_argument_list::lvalue_list (void)
 {
   std::list<octave_lvalue> retval;
 
diff --git a/src/pt-eval.cc b/src/pt-eval.cc
--- a/src/pt-eval.cc
+++ b/src/pt-eval.cc
@@ -274,36 +274,36 @@ void
 tree_evaluator::visit_simple_for_command (tree_simple_for_command& cmd)
 {
   if (error_state)
     return;
 
   if (debug_mode)
     do_breakpoint (cmd.is_breakpoint ());
 
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+  unwind_protect frame;
 
-  unwind_protect::protect_var (in_loop_command);
+  frame.protect_var (in_loop_command);
 
   in_loop_command = true;
 
   tree_expression *expr = cmd.control_expr ();
 
   octave_value rhs = expr->rvalue1 ();
 
   if (error_state || rhs.is_undefined ())
-    goto cleanup;
+    return;
 
   {
     tree_expression *lhs = cmd.left_hand_side ();
 
     octave_lvalue ult = lhs->lvalue ();
 
     if (error_state)
-      goto cleanup;
+      return;
 
     tree_statement_list *loop_body = cmd.body ();
 
     if (rhs.is_range ())
       {
 	Range rng = rhs.range_value ();
 
 	octave_idx_type steps = rng.nelem ();
@@ -382,42 +382,39 @@ tree_evaluator::visit_simple_for_command
           }
       }
     else
       {
 	::error ("invalid type in for loop expression near line %d, column %d",
 		 cmd.line (), cmd.column ());
       }
   }
-
- cleanup:
-  unwind_protect::run_frame (uwp_frame);
 }
 
 void
 tree_evaluator::visit_complex_for_command (tree_complex_for_command& cmd)
 {
   if (error_state)
     return;
 
   if (debug_mode)
     do_breakpoint (cmd.is_breakpoint ());
 
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+  unwind_protect frame;
 
-  unwind_protect::protect_var (in_loop_command);
+  frame.protect_var (in_loop_command);
 
   in_loop_command = true;
 
   tree_expression *expr = cmd.control_expr ();
 
   octave_value rhs = expr->rvalue1 ();
 
   if (error_state || rhs.is_undefined ())
-    goto cleanup;
+    return;
 
   if (rhs.is_map ())
     {
       // Cycle through structure elements.  First element of id_list
       // is set to value and the second is set to the name of the
       // structure element.
 
       tree_argument_list *lhs = cmd.left_hand_side ();
@@ -457,19 +454,16 @@ tree_evaluator::visit_complex_for_comman
 	    loop_body->accept (*this);
 
 	  if (quit_loop_now ())
 	    break;
 	}
     }
   else
     error ("in statement `for [X, Y] = VAL', VAL must be a structure");
-
- cleanup:
-  unwind_protect::run_frame (uwp_frame);
 }
 
 void
 tree_evaluator::visit_octave_user_script (octave_user_script&)
 {
   panic_impossible ();
 }
 
@@ -814,120 +808,88 @@ tree_evaluator::visit_switch_command (tr
 	    }
 	}
     }
   else
     ::error ("missing value in switch command near line %d, column %d",
 	     cmd.line (), cmd.column ());
 }
 
-static void
-do_catch_code (tree_statement_list *list)
-{
-  // Is it safe to call OCTAVE_QUIT here?  We are already running
-  // something on the unwind_protect stack, but the element for this
-  // action would have already been popped from the top of the stack,
-  // so we should not be attempting to run it again.
-
-  OCTAVE_QUIT;
-
-  // If we are interrupting immediately, or if an interrupt is in
-  // progress (octave_interrupt_state < 0), then we don't want to run
-  // the catch code (it should only run on errors, not interrupts).
-
-  // If octave_interrupt_state is positive, an interrupt is pending.
-  // The only way that could happen would be for the interrupt to
-  // come in after the OCTAVE_QUIT above and before the if statement
-  // below -- it's possible, but unlikely.  In any case, we should
-  // probably let the catch code throw the exception because we don't
-  // want to skip that and potentially run some other code.  For
-  // example, an error may have originally brought us here for some
-  // cleanup operation and we shouldn't skip that.
-
-  if (octave_interrupt_immediately || octave_interrupt_state < 0)
-    return;
-
-  // Set up for letting the user print any messages from errors that
-  // occurred in the body of the try_catch statement.
-
-  buffer_error_messages--;
-
-  if (list)
-    list->accept (*current_evaluator);
-}
-
 void
 tree_evaluator::visit_try_catch_command (tree_try_catch_command& cmd)
 {
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+  unwind_protect frame;
   
-  unwind_protect::protect_var (buffer_error_messages);
-  unwind_protect::protect_var (Vdebug_on_error);
-  unwind_protect::protect_var (Vdebug_on_warning);
+  frame.protect_var (buffer_error_messages);
+  frame.protect_var (Vdebug_on_error);
+  frame.protect_var (Vdebug_on_warning);
 
   buffer_error_messages++;
   Vdebug_on_error = false;
   Vdebug_on_warning = false;
 
   tree_statement_list *catch_code = cmd.cleanup ();
 
-  unwind_protect::add_fcn (do_catch_code, catch_code);
+  // The catch code is *not* added to unwind_protect stack; it doesn't need
+  // to be run on interrupts.
 
   tree_statement_list *try_code = cmd.body ();
 
   if (try_code)
-    try_code->accept (*this);
+    {
+      try_code->accept (*this);
+      // FIXME: should std::bad_alloc be handled here?
+    }
 
-  if (catch_code && error_state)
-    {
-      error_state = 0;
-      unwind_protect::run_frame (uwp_frame);
-    }
-  else
+  if (error_state)
     {
       error_state = 0;
 
-      // Unwind stack elements must be cleared or run in the reverse
-      // order in which they were added to the stack.
+      if (catch_code)
+        {
+          // Set up for letting the user print any messages from errors that
+          // occurred in the body of the try_catch statement.
 
-      // For clearing the do_catch_code cleanup function.
-      unwind_protect::discard ();
+          buffer_error_messages--;
 
-      // Run the rest of the frame.
-      unwind_protect::run_frame (uwp_frame);
+          if (catch_code)
+            catch_code->accept (*this);
+        }
     }
 }
 
-static void
-do_unwind_protect_cleanup_code (tree_statement_list *list)
+void
+tree_evaluator::do_unwind_protect_cleanup_code (tree_statement_list *list)
 {
-  unwind_protect::protect_var (octave_interrupt_state);
+  unwind_protect frame;
+
+  frame.protect_var (octave_interrupt_state);
   octave_interrupt_state = 0;
 
   // We want to run the cleanup code without error_state being set,
   // but we need to restore its value, so that any errors encountered
   // in the first part of the unwind_protect are not completely
   // ignored.
 
-  unwind_protect::protect_var (error_state);
+  frame.protect_var (error_state);
   error_state = 0;
 
   // Similarly, if we have seen a return or break statement, allow all
   // the cleanup code to run before returning or handling the break.
   // We don't have to worry about continue statements because they can
   // only occur in loops.
 
-  unwind_protect::protect_var (tree_return_command::returning);
+  frame.protect_var (tree_return_command::returning);
   tree_return_command::returning = 0;
 
-  unwind_protect::protect_var (tree_break_command::breaking);
+  frame.protect_var (tree_break_command::breaking);
   tree_break_command::breaking = 0;
 
   if (list)
-    list->accept (*current_evaluator);
+    list->accept (*this);
 
   // The unwind_protects are popped off the stack in the reverse of
   // the order they are pushed on.
 
   // FIXME -- these statements say that if we see a break or
   // return statement in the cleanup block, that we want to use the
   // new value of the breaking or returning flag instead of restoring
   // the previous value.  Is that the right thing to do?  I think so.
@@ -948,61 +910,72 @@ do_unwind_protect_cleanup_code (tree_sta
   // If we reset the value of the breaking flag, both the returning
   // flag and the breaking flag will be set, and we shouldn't have
   // both.  So, use the most recent one.  If there is no return or
   // break in the cleanup block, the values should be reset to
   // whatever they were when the cleanup block was entered.
 
   if (tree_break_command::breaking || tree_return_command::returning)
     {
-      unwind_protect::discard ();
-      unwind_protect::discard ();
+      frame.discard_top (2);
     }
   else
     {
-      unwind_protect::run ();
-      unwind_protect::run ();
+      frame.run_top (2);
     }
 
   // We don't want to ignore errors that occur in the cleanup code, so
   // if an error is encountered there, leave error_state alone.
   // Otherwise, set it back to what it was before.
 
   if (error_state)
-    unwind_protect::discard ();
+    frame.discard_top ();
   else
-    unwind_protect::run ();
+    frame.run_top ();
 
-  unwind_protect::run ();
+  frame.run ();
 }
 
 void
 tree_evaluator::visit_unwind_protect_command (tree_unwind_protect_command& cmd)
 {
   tree_statement_list *cleanup_code = cmd.cleanup ();
 
-  unwind_protect::add_fcn (do_unwind_protect_cleanup_code, cleanup_code);
-
   tree_statement_list *unwind_protect_code = cmd.body ();
 
   if (unwind_protect_code)
-    unwind_protect_code->accept (*this);
+    {
+      try
+        {
+          unwind_protect_code->accept (*this);
+        }
+      catch (...)
+        {
+          // Run the cleanup code on exceptions, so that it is run even in case
+          // of interrupt or out-of-memory.
+          do_unwind_protect_cleanup_code (cleanup_code);
+          // FIXME: should error_state be checked here?
+          // We want to rethrow the exception, even if error_state is set, so
+          // that interrupts continue.
+          throw;
+        }
 
-  unwind_protect::run ();
+      do_unwind_protect_cleanup_code (cleanup_code);
+    }
 }
 
 void
 tree_evaluator::visit_while_command (tree_while_command& cmd)
 {
   if (error_state)
     return;
 
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+  unwind_protect frame;
 
-  unwind_protect::protect_var (in_loop_command);
+  frame.protect_var (in_loop_command);
 
   in_loop_command = true;
 
   tree_expression *expr = cmd.condition ();
 
   if (! expr)
     panic_impossible ();
 
@@ -1015,39 +988,36 @@ tree_evaluator::visit_while_command (tre
 	{
 	  tree_statement_list *loop_body = cmd.body ();
 
 	  if (loop_body)
 	    {
 	      loop_body->accept (*this);
 
 	      if (error_state)
-		goto cleanup;
+                return;
 	    }
 
 	  if (quit_loop_now ())
 	    break;
 	}
       else
 	break;
     }
-
- cleanup:
-  unwind_protect::run_frame (uwp_frame);
 }
 
 void
 tree_evaluator::visit_do_until_command (tree_do_until_command& cmd)
 {
   if (error_state)
     return;
 
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+  unwind_protect frame;
 
-  unwind_protect::protect_var (in_loop_command);
+  frame.protect_var (in_loop_command);
 
   in_loop_command = true;
 
   tree_expression *expr = cmd.condition ();
 
   if (! expr)
     panic_impossible ();
 
@@ -1055,31 +1025,28 @@ tree_evaluator::visit_do_until_command (
     {
       tree_statement_list *loop_body = cmd.body ();
 
       if (loop_body)
 	{
 	  loop_body->accept (*this);
 
 	  if (error_state)
-	    goto cleanup;
+            return;
 	}
 
       if (quit_loop_now ())
 	break;
 
       if (debug_mode)
 	do_breakpoint (cmd.is_breakpoint ());
 
       if (expr->is_logically_true ("do-until"))
 	break;
     }
-
- cleanup:
-  unwind_protect::run_frame (uwp_frame);
 }
 
 void
 tree_evaluator::do_breakpoint (tree_statement& stmt) const
 {
   do_breakpoint (stmt.is_breakpoint (), stmt.is_end_of_fcn_or_script ());
 }
 
diff --git a/src/pt-eval.h b/src/pt-eval.h
--- a/src/pt-eval.h
+++ b/src/pt-eval.h
@@ -121,16 +121,18 @@ public:
   void visit_switch_case (tree_switch_case&);
 
   void visit_switch_case_list (tree_switch_case_list&);
 
   void visit_switch_command (tree_switch_command&);
 
   void visit_try_catch_command (tree_try_catch_command&);
 
+  void do_unwind_protect_cleanup_code (tree_statement_list *list);
+
   void visit_unwind_protect_command (tree_unwind_protect_command&);
 
   void visit_while_command (tree_while_command&);
 
   void visit_do_until_command (tree_do_until_command&);
 
   // If > 0, stop executing at the (N-1)th stopping point, counting
   //         from the the current execution point in the current frame.
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -535,41 +535,41 @@ recover_from_exception (void)
 int
 main_loop (void)
 {
   octave_save_signal_mask ();
 
   can_interrupt = true;
 
   octave_signal_hook = octave_signal_handler;
-  octave_interrupt_hook = unwind_protect::run_all;
-  octave_bad_alloc_hook = unwind_protect::run_all;
+  octave_interrupt_hook = 0;
+  octave_bad_alloc_hook = 0;
 
   octave_catch_interrupts ();
 
   octave_initialized = true;
 
   // The big loop.
 
   int retval = 0;
   do
     {
       try
 	{
-	  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+	  unwind_protect frame;
 
 	  reset_error_handler ();
 
 	  reset_parser ();
 
 	  // Do this with an unwind-protect cleanup function so that
 	  // the forced variables will be unmarked in the event of an
 	  // interrupt.
 	  symbol_table::scope_id scope = symbol_table::top_scope ();
-	  unwind_protect::add_fcn (symbol_table::unmark_forced_variables, scope);
+	  frame.add_fcn (symbol_table::unmark_forced_variables, scope);
 
 	  // This is the same as yyparse in parse.y.
 	  retval = octave_parse ();
 
 	  if (retval == 0)
 	    {
 	      if (global_command)
 		{
@@ -611,18 +611,16 @@ main_loop (void)
 			octave_completion_matches_called = false;	    
 		      else
 			command_editor::increment_current_command_number ();
 		    }
 		}
 	      else if (parser_end_of_input)
 		break;
 	    }
-
-	  unwind_protect::run_frame (uwp_frame);
 	}
       catch (octave_interrupt_exception)
 	{
 	  recover_from_exception ();
           octave_stdout << "\n";
           if (quitting_gracefully)
             {
               clean_up_and_exit (exit_status);
@@ -792,17 +790,18 @@ static octave_value_list
 run_command_and_return_output (const std::string& cmd_str)
 {
   octave_value_list retval;
 
   iprocstream *cmd = new iprocstream (cmd_str.c_str ());
 
   if (cmd)
     {
-      unwind_protect::add (cleanup_iprocstream, cmd);
+      unwind_protect frame;
+      frame.add (cleanup_iprocstream, cmd);
 
       if (*cmd)
 	{
 	  int fid = cmd->file_number ();
 
 	  std::ostringstream output_buf;
 
 	  char ch;
@@ -830,18 +829,16 @@ run_command_and_return_output (const std
 	  if (WIFEXITED (cmd_status))
 	    cmd_status = WEXITSTATUS (cmd_status);
 	  else
 	    cmd_status = 127;
 
 	  retval(0) = cmd_status;
 	  retval(1) = output_buf.str ();
 	}
-
-      unwind_protect::run ();
     }
   else
     error ("unable to start subprocess for `%s'", cmd_str.c_str ());
 
   return retval;
 }
 
 enum system_exec_type { et_sync, et_async };
@@ -885,17 +882,17 @@ command that was written to the standard
 \n\
 @noindent\n\
 will set the variable @code{output} to the string @samp{foo}, and the\n\
 variable @code{status} to the integer @samp{2}.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+  unwind_protect frame;
 
   int nargin = args.length ();
 
   if (nargin > 0 && nargin < 4)
     {
       bool return_output = (nargout > 1 || nargin > 1);
 
       std::string cmd_str = args(0).string_value ();
@@ -988,18 +985,16 @@ variable @code{status} to the integer @s
 
 	      retval(0) = status;
 	    }
 	}
     }
   else
     print_usage ();
 
-  unwind_protect::run_frame (uwp_frame);
-
   return retval;
 }
 
 DEFALIAS (shell_cmd, system);
 
 // FIXME -- this should really be static, but that causes
 // problems on some systems.
 std::list<std::string> octave_atexit_functions;
diff --git a/src/unwind-prot.cc b/src/unwind-prot.cc
--- a/src/unwind-prot.cc
+++ b/src/unwind-prot.cc
@@ -28,51 +28,19 @@ along with Octave; see the file COPYING.
 
 #include <cstddef>
 #include <cstring>
 
 #include "error.h"
 #include "unwind-prot.h"
 #include "utils.h"
 
-std::stack<unwind_protect::elem *> unwind_protect::elt_list;
-
-std::stack<std::pair <std::string, unwind_protect::frame_id_t> > unwind_protect::tag_list;
-
-void
-unwind_protect::begin_frame (const std::string& tag)
-{
-  tag_list.push (std::make_pair (tag, begin_frame ()));
-}
-
-void
-unwind_protect::run_frame (const std::string& tag)
+void unwind_protect_safe::gripe_exception (void)
 {
-  while (! tag_list.empty ())
-    {
-      std::pair<std::string, frame_id_t> top = tag_list.top ();
-      tag_list.pop ();
-
-      run_frame (top.second);
-      if (top.first == tag)
-        break;
-    }
-}
-
-void
-unwind_protect::discard_frame (const std::string& tag)
-{
-  while (! tag_list.empty ())
-    {
-      std::pair<std::string, frame_id_t> top = tag_list.top ();
-      tag_list.pop ();
-
-      run_frame (top.second);
-      if (top.first == tag)
-        break;
-    }
+  // FIXME: can this throw an exception?
+  error ("internal: unhandled exception in unwind_protect handler");
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/unwind-prot.h b/src/unwind-prot.h
--- a/src/unwind-prot.h
+++ b/src/unwind-prot.h
@@ -1,13 +1,13 @@
 /*
 
 Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 2000, 2002, 2004,
               2005, 2006, 2007, 2008 John W. Eaton
-Copyright (C) 2009 VZLU Prague
+Copyright (C) 2009, 2010 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -23,31 +23,36 @@ along with Octave; see the file COPYING.
 */
 
 #if !defined (octave_unwind_prot_h)
 #define octave_unwind_prot_h 1
 
 #include <cstddef>
 
 #include <string>
-#include <stack>
 #include <memory>
 
+// This class allows registering cleanup actions.
 class
 OCTINTERP_API
 unwind_protect
 {
 public:
 
   // A generic unwind_protect element. Knows how to run itself and discard itself.
+  // Also, contains a pointer to the next element.
   class elem
   {
+    elem *next;
+
   public:
     virtual void run (void) { }
     virtual ~elem (void) { }
+
+    friend class unwind_protect;
   };
 
   // An element that merely runs a void (*)(void) function.
   
   class fcn_elem : public elem
   {
   public:
     fcn_elem (void (*fptr) (void))
@@ -117,162 +122,159 @@ public:
       : e_ptr (ptr) { }
 
     void run (void) { delete e_ptr; }
 
   private:
     T *e_ptr;
   };
 
-  typedef size_t frame_id_t;
-
-  // Generic. Users may subclass elem to provide their own cleanup.
-  static void add (elem *el)
-    {
-      elt_list.push (el);
-    }
-
-  static bool empty (void)
-    { return elt_list.empty (); }
+  unwind_protect (void) : head () { }
 
-  static void run (void)
-    {
-      // Use auto_ptr, so that even if the following run () call throws an
-      // exception, we still clean up the element.
-      std::auto_ptr<elem> elt (elt_list.top ());
-      elt_list.pop ();
-
-      elt->run ();
-    }
-
-  static void discard (void)
-    {
-      // No need to use ato_ptr here.
-      elem *elt = elt_list.top ();
-      elt_list.pop ();
-
-      delete elt;
-    }
-
-  static frame_id_t begin_frame ()
+  void add (elem *new_elem)
     {
-      return elt_list.size ();
-    }
-
-  static void run_frame (frame_id_t frame_id)
-    {
-      while (elt_list.size () > frame_id)
-        run ();
-    }
-
-  static void discard_frame (frame_id_t frame_id)
-    {
-      while (elt_list.size () > frame_id)
-        discard ();
-    }
-
-  // String tags are deprecated. Use the above trio.
-
-  static void begin_frame (const std::string& tag) GCC_ATTR_DEPRECATED;
-
-  static void run_frame (const std::string& tag) GCC_ATTR_DEPRECATED;
-
-  static void discard_frame (const std::string& tag) GCC_ATTR_DEPRECATED;
-
-  static void run_all (void)
-    { 
-      run_frame (0);
-      while (! tag_list.empty ())
-        tag_list.pop ();
-    }
-
-  static void discard_all (void)
-    { 
-      discard_frame (0);
-      while (! tag_list.empty ())
-        tag_list.pop ();
+      new_elem->next = head;
+      head = new_elem;
     }
 
   // For backward compatibility.
-  static void add (void (*fcn) (void *), void *ptr = 0)
+  void add (void (*fcn) (void *), void *ptr = 0)
     {
-      elt_list.push (new fcn_arg_elem<void *> (fcn, ptr));
+      add (new fcn_arg_elem<void *> (fcn, ptr));
     }
 
   // Call to void func (void).
-  static void add_fcn (void (*fcn) (void))
+  void add_fcn (void (*fcn) (void))
     {
-      elt_list.push (new fcn_elem (fcn));
+      add (new fcn_elem (fcn));
     }
 
   // Call to void func (T).
   template <class T>
-  static void add_fcn (void (*action) (T), T val)
+  void add_fcn (void (*action) (T), T val)
     {
-      elt_list.push (new fcn_arg_elem<T> (action, val));
+      add (new fcn_arg_elem<T> (action, val));
     }
 
   // Call to T::method (void).
   template <class T>
-  static void add_method (T *obj, void (T::*method) (void))
+  void add_method (T *obj, void (T::*method) (void))
     {
-      elt_list.push (new method_elem<T> (obj, method));
+      add (new method_elem<T> (obj, method));
     }
 
   // Call to delete (T*).
 
   template <class T>
-  static void add_delete (T *obj)
+  void add_delete (T *obj)
     {
-      elt_list.push (new delete_ptr_elem<T> (obj));
+      add (new delete_ptr_elem<T> (obj));
     }
 
   // Protect any variable.
   template <class T>
-  static void protect_var (T& var)
+  void protect_var (T& var)
     {
-      elt_list.push (new restore_var_elem<T> (var, var));
+      add (new restore_var_elem<T> (var, var));
     }
 
   // Protect any variable, value given.
   template <class T>
-  static void protect_var (T& var, const T& val)
+  void protect_var (T& var, const T& val)
+    {
+      add (new restore_var_elem<T> (var, val));
+    }
+
+  operator bool (void) const 
+    { 
+      return head != 0; 
+    }
+
+  void run_top (void) 
+    { 
+      if (head)
+        {
+          // No leak on exception!
+          std::auto_ptr<elem> ptr (head);
+          head = ptr->next;
+          ptr->run ();
+        }
+    }
+
+  void run_top (int num) 
+    { 
+      while (num-- > 0)
+        run_top ();
+    }
+
+  void discard_top (void)
     {
-      elt_list.push (new restore_var_elem<T> (var, val));
+      if (head)
+        {
+          elem *ptr = head;
+          head = ptr->next;
+          delete ptr;
+        }
+    }
+
+  void discard_top (int num) 
+    { 
+      while (num-- > 0)
+        discard_top ();
+    }
+
+  void run (void)
+    {
+      while (head)
+        run_top ();
+    }
+
+  void discard (void)
+    {
+      while (head)
+        discard_top ();
+    }
+
+  // Destructor should not raise an exception, so all actions registered should
+  // be exception-safe (but setting error_state is allowed). If you're not sure,
+  // see unwind_protect_safe.
+  ~unwind_protect (void)
+    {
+      run ();
     }
 
 private:
 
-  static std::stack<elem *> elt_list;
-
-  static std::stack<std::pair <std::string, frame_id_t> > tag_list;
+  elem *head;
 };
 
-// Backward compatibility macros. Avoid them; use protect_var directly.
-
-#define unwind_protect_bool(b) \
-  unwind_protect::protect_var (b)
+// Like unwind_protect, but this one will guard against the possibility of seeing
+// an exception (or interrupt) in the cleanup actions. Not that we can do much about
+// it, but at least we won't crash.
 
-#define unwind_protect_int(i) \
-  unwind_protect::protect_var (i)
-
-#define unwind_protect_size_t(i) \
-  unwind_protect::protect_var (i)
+class unwind_protect_safe : public unwind_protect
+{
+  static void gripe_exception (void);
 
-#define unwind_protect_str(s) \
-  unwind_protect::protect_var (s)
-
-#define unwind_protect_ptr(p) \
-  unwind_protect::protect_var (p)
-
-#define unwind_protect_fptr(p) \
-  unwind_protect::protect_var (p)
-
-#define unwind_protect_const_ptr(p) \
-  unwind_protect::protect_var (p)
+public:
+  ~unwind_protect_safe (void)
+    {
+      while (*this)
+        {
+          try
+            {
+              run_top ();
+            }
+          catch (...) // Yes, the black hole. Remember we're in a dtor.
+            {
+              gripe_exception ();
+            }
+        }
+    }
+};
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -1363,19 +1363,19 @@ subsequent indexing will not perform the
 
   if (nargin == 2)
     n = args(1).idx_type_value ();
   else if (nargin != 1)
     print_usage ();
 
   if (! error_state)
     {
-      unwind_protect::frame_id_t uwp = unwind_protect::begin_frame ();
-      unwind_protect::protect_var (error_state);
-      unwind_protect::protect_var (discard_error_messages);
+      unwind_protect frame;
+      frame.protect_var (error_state);
+      frame.protect_var (discard_error_messages);
       discard_error_messages = true;
 
       try
         {
           idx_vector idx = args(0).index_vector ();
           if (! error_state)
             {
               if (nargin == 2)
@@ -1385,18 +1385,16 @@ subsequent indexing will not perform the
             }
           else
             retval = false;
         }
       catch (octave_execution_exception)
         {
           retval = false;
         }
-
-      unwind_protect::run_frame (uwp);
     }
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -262,30 +262,30 @@ generate_struct_completions (const std::
 
       if (pos != std::string::npos)
 	base_name = base_name.substr (0, pos);
 
       if (is_variable (base_name))
 	{
 	  int parse_status;
 
-	  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+	  unwind_protect frame;
 
-	  unwind_protect::protect_var (error_state);
-	  unwind_protect::protect_var (warning_state);
+	  frame.protect_var (error_state);
+	  frame.protect_var (warning_state);
 
-	  unwind_protect::protect_var (discard_error_messages);
-	  unwind_protect::protect_var (discard_warning_messages);
+	  frame.protect_var (discard_error_messages);
+	  frame.protect_var (discard_warning_messages);
 
 	  discard_error_messages = true;
 	  discard_warning_messages = true;
 
 	  octave_value tmp = eval_string (prefix, true, parse_status);
 
-	  unwind_protect::run_frame (uwp_frame);
+	  frame.run ();
 
 	  if (tmp.is_defined () && tmp.is_map ())
 	    names = tmp.map_keys ();
 	}
     }
 
   return names;
 }
@@ -304,26 +304,26 @@ looks_like_struct (const std::string& te
 
 #if 0
   symbol_record *sr = curr_sym_tab->lookup (text);
 
   if (sr && ! sr->is_function ())
     {
       int parse_status;
 
-      unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+      unwind_protect frame;
 
-      unwind_protect::protect_var (discard_error_messages);
-      unwind_protect::protect_var (error_state);
+      frame.protect_var (discard_error_messages);
+      frame.protect_var (error_state);
 
       discard_error_messages = true;
 
       octave_value tmp = eval_string (text, true, parse_status);
 
-      unwind_protect::run_frame (uwp_frame);
+      frame.run ();
 
       retval = (tmp.is_defined () && tmp.is_map ());
     }
 #endif
 
   return retval;
 }
 
@@ -378,32 +378,30 @@ This function has been deprecated.  Use 
   return do_isglobal (args);
 }
 
 static octave_value
 safe_symbol_lookup (const std::string& symbol_name)
 {
   octave_value retval;
 
-  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+  unwind_protect frame;
   
-  unwind_protect::protect_var (buffer_error_messages);
-  unwind_protect::protect_var (Vdebug_on_error);
-  unwind_protect::protect_var (Vdebug_on_warning);
+  frame.protect_var (buffer_error_messages);
+  frame.protect_var (Vdebug_on_error);
+  frame.protect_var (Vdebug_on_warning);
 
   buffer_error_messages++;
   Vdebug_on_error = false;
   Vdebug_on_warning = false;
 
   retval = symbol_table::find (symbol_name);
 
   error_state = 0;
 
-  unwind_protect::run_frame (uwp_frame);
-
   return retval;
 }
 
 int
 symbol_exist (const std::string& name, const std::string& type)
 {
   int retval = 0;
 
@@ -1420,41 +1418,39 @@ do_who (int argc, const string_vector& a
 	  // implement this option there so that the variables are never 
 	  // stored at all.
 	  if (i == argc - 1)
 	    error ("whos: -file argument must be followed by a file name");
 	  else
 	    {
 	      std::string nm = argv [i + 1];
 
-	      unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+	      unwind_protect frame;
 
 	      // Set up temporary scope.
 
 	      symbol_table::scope_id tmp_scope = symbol_table::alloc_scope ();
-	      unwind_protect::add_fcn (symbol_table::erase_scope, tmp_scope);
+	      frame.add_fcn (symbol_table::erase_scope, tmp_scope);
 
 	      symbol_table::set_scope (tmp_scope);
 
 	      octave_call_stack::push (tmp_scope, 0);
-	      unwind_protect::add_fcn (octave_call_stack::pop);
+	      frame.add_fcn (octave_call_stack::pop);
 
-	      unwind_protect::add_fcn (symbol_table::clear_variables);
+	      frame.add_fcn (symbol_table::clear_variables);
 
 	      feval ("load", octave_value (nm), 0);
 
 	      if (! error_state)
 		{
 		  std::string newmsg = std::string ("Variables in the file ") + 
 		    nm + ":\n\n";
 
 		  retval =  do_who (i, argv, return_list, verbose, newmsg);
 		}
-
-	      unwind_protect::run_frame (uwp_frame);
 	    }
 
 	  return retval;
 	}
       else if (argv[i] == "-regexp")
 	have_regexp = true;
       else if (argv[i] == "global")
 	global_only = true;
