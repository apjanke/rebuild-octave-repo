# HG changeset patch
# User jwe
# Date 913259192 0
#      Thu Dec 10 03:06:32 1998 +0000
# Node ID 28aba52a2368f60aa73273ecbdf3ecc2534201db
# Parent  dbcc24961c444ad6ab8eac1d59fead867fca0a14
[project @ 1998-12-10 03:06:31 by jwe]

diff --git a/scripts/control/DEMOcontrol.m b/scripts/control/DEMOcontrol.m
--- a/scripts/control/DEMOcontrol.m
+++ b/scripts/control/DEMOcontrol.m
@@ -16,17 +16,17 @@
 # along with Octave; see the file COPYING.  If not, write to the Free
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 function DEMOcontrol()
 # Controls toolbox demo.
 # Demo programs: bddemo.m, frdemo.m, analdemo.m, moddmeo.m, rldemo.m
 #  
 # Written by David Clem August 15, 1994
-# $Revision: 2.0.0.0 $    
+# $Revision: 2.0.0.2 $    
 
   disp(' O C T A V E    C O N T R O L   S Y S T E M S   T O O L B O X')
 
   while (1)
     clc
     k = 0;
     while (k > 8 || k < 1),
       k = menu("Octave Controls System Toolbox Demo", ...
diff --git a/scripts/control/abcddim.m b/scripts/control/abcddim.m
--- a/scripts/control/abcddim.m
+++ b/scripts/control/abcddim.m
@@ -30,21 +30,27 @@ function [n, m, p] = abcddim (a, b, c, d
 # Note: n = 0 (pure gain block) is returned without warning.
 #
 # Returns n = m = p = -1 if the system is not compatible.
 #
 # See also: is_abcd
 
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
 # a s hodel: modified to accept pure-gain systems aug 1996
-# $Revision: 1.16 $
+# $Revision: 1.17 $
 # $Log: abcddim.m,v $
-# Revision 1.16  1998-12-09 18:42:12  jwe
+# Revision 1.17  1998-12-10 03:06:31  jwe
 # *** empty log message ***
 #
+# Revision 2.0.0.2  1998/12/08  23:29:21  hodel
+# Octave-Marsyas Interface updated for signals-as-lists
+#
+# Revision 2.0.0.1  1998/12/08  21:40:44  hodel
+# Dummy version to match ftp.eng.auburn.edu version number
+#
 # Revision 2.0.0.0  1998/12/08  21:36:51  hodel
 # Branch for beta release patches
 #
 # Revision 2.0  1998/12/08  21:34:56  hodel
 # Initial beta release of signals-as-lists rewrite;
 # sysdimensions now takes opt as an argument
 #
 # Revision 2.0.0.1  1998/12/08  20:54:18  hodel
diff --git a/scripts/control/abcddims.m b/scripts/control/abcddims.m
--- a/scripts/control/abcddims.m
+++ b/scripts/control/abcddims.m
@@ -19,16 +19,16 @@
 function [y,my,ny] = abcddims (x)
 
 # Usage: [y,my,ny] = abcddims (x)
 #
 # Used internally in abcddim.  If x is a zero-size matrix, both dimensions
 # get set to 0.  my and ny are the row and column dimensions of the result.
 
 # Written by A. S. Hodel (scotte@eng.auburn.edu) Feb 1997
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   y = x;
   if(isempty(y))
     y = [];
   endif
   [my,ny] = size(y);
 endfunction
diff --git a/scripts/control/analdemo.m b/scripts/control/analdemo.m
--- a/scripts/control/analdemo.m
+++ b/scripts/control/analdemo.m
@@ -15,17 +15,17 @@
 # You should have received a copy of the GNU General Public License 
 # along with Octave; see the file COPYING.  If not, write to the Free 
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function analdemo()
 # Octave Controls toolbox demo: State Space analysis demo
 # Written by David Clem August 15, 1994
 # Updated by John Ingram December 1996
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
   
   while (1)
     clc
     k=0;
     while(k > 8 || k < 1)
       k = menu("Octave State Space Analysis Demo", ...
         "System grammians (gram, dgram)", ...
         "System zeros (tzero)", ...
diff --git a/scripts/control/are.m b/scripts/control/are.m
--- a/scripts/control/are.m
+++ b/scripts/control/are.m
@@ -30,17 +30,17 @@ function x = are (a, b, c, opt)
 # Solution method: apply Laub's Schur method (IEEE Trans. Auto. Contr,
 # 1979) to the appropriate Hamiltonian matrix.
 #
 # opt is an option passed to the eigenvalue balancing routine default is "B".
 #
 # See also: balance
 
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
-# $Revision: 1.19 $
+# $Revision: 1.20 $
 
   if (nargin == 3 || nargin == 4)
     if (nargin == 4)
       if (! (strcmp (opt, "N") || strcmp (opt, "P") ...
 	     || strcmp (opt, "S") || strcmp (opt, "B") ...
 	     || strcmp (opt, "n") || strcmp (opt, "p") ...
 	     || strcmp (opt, "s") || strcmp (opt, "b")))
 	warning ("are: opt has an invalid value; setting to B");
diff --git a/scripts/control/bode.m b/scripts/control/bode.m
--- a/scripts/control/bode.m
+++ b/scripts/control/bode.m
@@ -52,18 +52,24 @@ function [mag,phase,w] = bode(sys,w,outp
 # ||G(jw)|| or ||G(exp(jwT))|| and phase information is not computed.
 
 # Written by John Ingram  July 10th, 1996
 # Based on previous code
 # By R. Bruce Tenison, July 13, 1994
 # Modified by David Clem November 13, 1994
 # again by A. S. Hodel July 1995 (smart plot range, etc.)
 # Modified by Kai P. Mueller September 28, 1997 (multiplot mode)
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 # $Log: bode.m,v $
+# Revision 2.0.0.2  1998/12/08  23:29:23  hodel
+# Octave-Marsyas Interface updated for signals-as-lists
+#
+# Revision 2.0.0.1  1998/12/08  21:40:45  hodel
+# Dummy version to match ftp.eng.auburn.edu version number
+#
 # Revision 2.0.0.0  1998/12/08  21:36:52  hodel
 # Branch for beta release patches
 #
 # Revision 2.0  1998/12/08  21:34:57  hodel
 # Initial beta release of signals-as-lists rewrite;
 # sysdimensions now takes opt as an argument
 #
 # Revision 2.0.0.1  1998/12/08  20:54:19  hodel
diff --git a/scripts/control/bode_bounds.m b/scripts/control/bode_bounds.m
--- a/scripts/control/bode_bounds.m
+++ b/scripts/control/bode_bounds.m
@@ -19,17 +19,17 @@
 function [wmin,wmax] = bode_bounds(zer,pol,DIGITAL,tsam)
 # function [wmin,wmax] = bode_bounds(zer,pol,DIGITAL{,tsam})
 # get default range of frequencies for system zeros and poles
 #
 # frequency range is the interval [10^wmin,10^wmax]
 #
 # used internally in freqresp
 
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   # make sure zer,pol are row vectors
   if(!isempty(pol)) pol = reshape(pol,1,length(pol)); endif
   if(!isempty(zer)) zer = reshape(zer,1,length(zer)); endif
 
 # check for natural frequencies away from omega = 0
   if (DIGITAL)
     # The 2nd conditions prevents log(0) in the next log command
diff --git a/scripts/control/buildssic.m b/scripts/control/buildssic.m
--- a/scripts/control/buildssic.m
+++ b/scripts/control/buildssic.m
@@ -103,17 +103,17 @@ function [sys] = buildssic(Clst,Ulst,Ols
 #
 #     GW = buildssic([1 4;2 4;3 1],[3],[2 3 5],[3 4],G,W1,W2,One);
 #
 # where "One" is a unity gain (auxillary) function with order 0.
 # (e.g. One = ugain(1);)
 #
 
 # Written by Kai Mueller April 1998
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   if((nargin < 5) || (nargin > 12))
     usage("[sys] = buildssic(Clst,Ulst,Olst,Ilst,s1,s2,s3,s4,s5,s6,s7,s8)");
   endif
   if (nargin >= 5)
     if (!is_struct(s1))
       error("---> s1 must be a structed system.");
     endif
diff --git a/scripts/control/c2d.m b/scripts/control/c2d.m
--- a/scripts/control/c2d.m
+++ b/scripts/control/c2d.m
@@ -44,17 +44,17 @@ function dsys = c2d (sys, opt, T)
 #
 #   x[n+1] = Ad x[n] + Bd u[n]
 #
 # Note: This function adds _d to the names of the new discrete states.   
 
 # Written by R.B. Tenison (btenison@eng.auburn.edu)
 # October 1993
 # Updated by John Ingram for system data structure August 1996
-# $Revision: 1.14 $
+# $Revision: 1.15 $
 
   save_val = implicit_str_to_num_ok;	# save for later
   implicit_str_to_num_ok = 1;
 
 # parse input arguments
   if(nargin < 1 | nargin > 3)
     usage("dsys=c2d(sys[,T])");
   elseif (!is_struct(sys))
diff --git a/scripts/control/com2str.m b/scripts/control/com2str.m
--- a/scripts/control/com2str.m
+++ b/scripts/control/com2str.m
@@ -20,17 +20,17 @@ function retval = com2str(zz,flg)
 # usage retval = com2str(zz{,flg})
 #  
 # convert complex number to a string
 # zz: complex number
 # flg: format flag
 #      0 (default):            -1, 0, 1,   1i,   1 + 0.5i
 #      1 (for use with zpout): -1, 0, + 1, + 1i, + 1 + 0.5i
 #
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   if (nargin < 1 | nargin > 2)
     usage("com2str(zz{,flg})");
   endif
   if(nargin == 1)
     flg = 0;
   endif
  
diff --git a/scripts/control/controldemo.m b/scripts/control/controldemo.m
--- a/scripts/control/controldemo.m
+++ b/scripts/control/controldemo.m
@@ -16,17 +16,17 @@
 # along with Octave; see the file COPYING.  If not, write to the Free
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 function DEMOcontrol()
 # Controls toolbox demo.
 # Demo programs: bddemo.m, frdemo.m, analdemo.m, moddmeo.m, rldemo.m
 #  
 # Written by David Clem August 15, 1994
-# $Revision: 2.0.0.0 $    
+# $Revision: 2.0.0.2 $    
 
   disp(' O C T A V E    C O N T R O L   S Y S T E M S   T O O L B O X')
 
   while (1)
     clc
     k = 0;
     while (k > 8 || k < 1),
       k = menu("Octave Controls System Toolbox Demo", ...
diff --git a/scripts/control/ctrb.m b/scripts/control/ctrb.m
--- a/scripts/control/ctrb.m
+++ b/scripts/control/ctrb.m
@@ -30,17 +30,17 @@ function Qs = ctrb(sys, b)
   #       The numerical properties of is_controllable()
   #       are much better for controllability tests.
   # See also: obsv, is_observable, is_controllable
   # ------------------------------------------------------
 
   # Written by Kai P. Mueller November 4, 1997
   # based on is_controllable.m of Scottedward Hodel
   # modified by
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
 
   if (nargin == 2)
     a = sys;
   elseif (nargin == 1 && is_struct(sys))
     sysupdate(sys,"ss");
     [a,b] = sys2ss(sys);
   else
     usage("ctrb(sys [, b])")
diff --git a/scripts/control/d2c.m b/scripts/control/d2c.m
--- a/scripts/control/d2c.m
+++ b/scripts/control/d2c.m
@@ -48,17 +48,17 @@ function csys = d2c(sys,opt)
 #        .
 #        x = A1 x + B1 u
 #
 # The sample time used is that of the system. (see syschtsam).
   
 # Written by R. Bruce Tenison August 23, 1994
 # Updated by John Ingram for system data structure  August 1996
 # SYS_INTERNAL accesses members of system data structure
-# $Revision: 2.0.0.0 $ 
+# $Revision: 2.0.0.2 $ 
 
   save_val = implicit_str_to_num_ok;	# save for later
   implicit_str_to_num_ok = 1;
 
   if( (nargin != 1) & (nargin != 2) )
     usage("csys = d2c(sys[,tol]), csys = d2c(sys,opt)");
   elseif (!is_struct(sys))
     error("sys must be in system data structure");
diff --git a/scripts/control/damp.m b/scripts/control/damp.m
--- a/scripts/control/damp.m
+++ b/scripts/control/damp.m
@@ -24,17 +24,17 @@ function damp(p, tsam)
 #      If p is a system, tsam must not be specified.
 #      If p is a matrix and tsam is specified, eigenvalues
 #      of p are assumed to be in z-domain.
 #
 # See also: eig
 
 # Written by Kai P. Mueller September 29, 1997.
 # Update
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   # assume a continuous system
   DIGITAL = 0;
   if(nargin < 1 || nargin > 2)
     usage("damp(p,[ tsamp])")
   endif
   if(is_struct(p))
     if (nargin != 1)
diff --git a/scripts/control/dare.m b/scripts/control/dare.m
--- a/scripts/control/dare.m
+++ b/scripts/control/dare.m
@@ -42,17 +42,17 @@
 ## opt is an option passed to the eigenvalue balancing routine default
 ## is "B".
 ##
 ## See also: balance, are
 
 ## Author: A. S. Hodel <scotte@eng.auburn.edu>
 ## Created: August 1993
 ## Adapted-By: jwe
-## $Revision: 1.16 $
+## $Revision: 1.17 $
 
 function x = dare (a, b, c, r, opt)
 
   if (nargin == 4 | nargin == 5)
     if (nargin == 5)
       if (opt != "N" || opt != "P" || opt != "S" || opt != "B")
 	warning ("dare: opt has an invalid value -- setting to B");
 	opt = "B";
diff --git a/scripts/control/dcgain.m b/scripts/control/dcgain.m
--- a/scripts/control/dcgain.m
+++ b/scripts/control/dcgain.m
@@ -21,17 +21,17 @@ function gm = dcgain(sys, tol)
 #      Returns dc-gain matrix. If dc-gain is infinity
 #      an empty matrix is returned.
 #      The argument tol is an optional tolerance for the condition
 #      number of A-Matrix in sys (default tol = 1.0e-10)
 #      Prints a warning message of the system is unstable.
 #
 
 # Written by Kai P Mueller (mueller@ifr.ing.tu-bs.de) October 1, 1997
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   if((nargin < 1) || (nargin > 2) || (nargout > 1))
     usage("[gm, ok] = dcgain(sys[, tol])");
   endif
   if(!is_struct(sys))
     error("dcgain: first argument is not a system data structure.")
   endif
   sys = sysupdate(sys, "ss");
diff --git a/scripts/control/dezero.m b/scripts/control/dezero.m
--- a/scripts/control/dezero.m
+++ b/scripts/control/dezero.m
@@ -21,17 +21,17 @@
 ##
 ## Remove trailing blank entries and all zero entries from the string s.
 
 ## Author: Kurt Hornik <Kurt.Hornik@ci.tuwien.ac.at>
 ## Adapted-By: jwe
 ## Adapted from deblank by A. S. Hodel (a.s.hodel@eng.auburn.edu)
 ## 	(the name dezero is a reference to the Fermilab D0 experiment,
 ##      where my sister did her PhD research) 
-## $Revision: 2.0.0.0 $
+## $Revision: 2.0.0.2 $
 
 function t = dezero (s)
 
   # delete the next line if you're stubbornly going to use dezero.
   error("dezero is no longer supported.");
 
   if (nargin != 1)
     usage ("dezero (s)");
diff --git a/scripts/control/dgkfdemo.m b/scripts/control/dgkfdemo.m
--- a/scripts/control/dgkfdemo.m
+++ b/scripts/control/dgkfdemo.m
@@ -14,17 +14,17 @@
 # 
 # You should have received a copy of the GNU General Public License 
 # along with Octave; see the file COPYING.  If not, write to the Free 
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function dgkfdemo()
 # Octave Controls toolbox demo: H2/Hinfinity options demos
 # Written by A. S. Hodel June 1995
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
  
   save_val = page_screen_output;
   page_screen_output = 1;
   while (1)
     clc
     menuopt=0;
     while(menuopt > 10 || menuopt < 1)
       menuopt = menu('Octave H2/Hinfinity options demo', ...
diff --git a/scripts/control/dgram.m b/scripts/control/dgram.m
--- a/scripts/control/dgram.m
+++ b/scripts/control/dgram.m
@@ -20,13 +20,13 @@ function m = dgram(a,b)
   # m = dgram(a,b)
   # Return controllability grammian of discrete time system
   #
   #  x(k+1) = a x(k) + b u(k)
   #
   # a m a' - m + b*b' = 0 
 
   # Written by A. S. Hodel July 1995
-  # $Revision: 1.12 $
+  # $Revision: 1.13 $
 
   # let dlyap do the error checking...
   m = dlyap(a,b*b');
 endfunction
diff --git a/scripts/control/dhinfdemo.m b/scripts/control/dhinfdemo.m
--- a/scripts/control/dhinfdemo.m
+++ b/scripts/control/dhinfdemo.m
@@ -35,17 +35,17 @@
 #	    -----| K |<-------
 #	         +---+
 #
 #	W1 and W2 are the robustness and performancs weighting
 #       functions
 
 # K. Mueller, <mueller@ifr.ing.tu-bs.de>
 # Technical University of Braunschweig, IfR
-# $Revision: 2.0.0.0 $  $Date: 1998/12/08 21:36:55 $
+# $Revision: 2.0.0.2 $  $Date: 1998/12/08 23:29:27 $
 #
 
 echo off
 disp(" ");
 disp("    --------------------------------------------------");
 disp("    Discrete H_infinity optimal control for the plant:");
 disp(" ");
 disp("	                   0.39958z + 0.14700");
diff --git a/scripts/control/dlqe.m b/scripts/control/dlqe.m
--- a/scripts/control/dlqe.m
+++ b/scripts/control/dlqe.m
@@ -40,17 +40,17 @@ function [l, m, p, e] = dlqe (a, g, c, s
 #   m = Ricatti equation solution
 #   p = the estimate error covariance after the measurement update
 #   e = closed loop poles of (A - L C)
 
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August, 1993.
 # Modified for discrete time by R. Bruce Tenison (btenison@eng.auburn.edu)
 # October, 1993
 
-# $Revision: 1.15 $
+# $Revision: 1.16 $
 
   if (nargin != 5 && nargin != 6)
     error ("dlqe: invalid number of arguments");
   endif
 
 # The problem is dual to the regulator design, so transform to dlqr call.
 
   if (nargin == 5)
diff --git a/scripts/control/dlqg.m b/scripts/control/dlqg.m
--- a/scripts/control/dlqg.m
+++ b/scripts/control/dlqg.m
@@ -42,17 +42,17 @@ function [K,Q,P,Ee,Er] = dlqg(A,B,C,G,Si
 #  A,B,C,G, or Sys: state space representation of system.  
 #  Sigw, Sigv: covariance matrices of independent Gaussian noise processes 
 #      (as above)
 #  Q, R: state, control weighting matrices for dlqr call respectively.  
 #
 # See also: lqg, dlqe, dlqr
 
 # Written by A. S. Hodel August 1995
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
 warning("dlqg: obsolete. use lqg instead (system data structure format)");
 
 if (nargin == 5)
   # system data structure format
   
   # check that it really is system data structure
   if(! is_struct(A) )
diff --git a/scripts/control/dlqr.m b/scripts/control/dlqr.m
--- a/scripts/control/dlqr.m
+++ b/scripts/control/dlqr.m
@@ -41,17 +41,17 @@ function [k, p, e] = dlqr (a, b, q, r, s
 # References:
 #   Anderson and Moore, Optimal Control: Linear Quadratic Methods,
 #     Prentice-Hall, 1990, pp. 56-58
 #   Kuo, Digital Control Systems, Harcourt Brace Jovanovich, 1992, 
 #     section 11-5-2.
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
 # Converted to discrete time by R. B. Tenison
 # (btenison@eng.auburn.edu) October 1993
-# $Revision: 1.16 $
+# $Revision: 1.17 $
 
   if (nargin != 4 && nargin != 5)
     error ("dlqr: invalid number of arguments");
   endif
 
 # Check a.
   if ((n = is_square (a)) == 0)
     error ("dlqr: requires 1st parameter(a) to be square");
diff --git a/scripts/control/dlyap.m b/scripts/control/dlyap.m
--- a/scripts/control/dlyap.m
+++ b/scripts/control/dlyap.m
@@ -29,17 +29,17 @@ function x = dlyap (a, b)
 # or
 #
 #  a' x a - x + b' b = 0
 #
 # whichever is appropriate.  Uses Schur decomposition as in Kitagawa
 # (1977).
 
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
-# $Revision: 1.14 $
+# $Revision: 1.15 $
 
   if ((n = is_square (a)) == 0)
     warning ("dlyap: a must be square");
   endif
 
   if ((m = is_square (b)) == 0)
     [n1, m] = size (b);
     if (n1 == n)
diff --git a/scripts/control/fir2sys.m b/scripts/control/fir2sys.m
--- a/scripts/control/fir2sys.m
+++ b/scripts/control/fir2sys.m
@@ -27,17 +27,17 @@ function sys = fir2sys (num,tsam,inname,
   #   inname: name of input signal 
   #   outname: name of output signal
   # outputs:  sys (system data structure)
    
   #  Written by R. Bruce Tenison  July 29, 1994
   #  Name changed to TF2SYS July 1995
   #  updated for new system data structure format July 1996
   # adapted from tf2sys july 1996
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
 
   save_val = implicit_str_to_num_ok;
   implicit_str_to_num_ok = 1;
 
   #  Test for the correct number of input arguments
   if (nargin < 1 | nargin > 4)
     usage('sys=fir2sys(num[,tsam,inname,outname])');
   endif
diff --git a/scripts/control/frdemo.m b/scripts/control/frdemo.m
--- a/scripts/control/frdemo.m
+++ b/scripts/control/frdemo.m
@@ -15,17 +15,17 @@
 # You should have received a copy of the GNU General Public License 
 # along with Octave; see the file COPYING.  If not, write to the Free 
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function frdemo()
 # Octave Controls toolbox demo: Frequency Response demo
 # Written by David Clem August 15, 1994 
 
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 # a s hodel: updated to match new order of ss2zp outputs
 # J Ingram:  updated for system data structure format August 1996
 
   disp("")
   clc
   j = 0;
   while (j != 4)
     disp("");
diff --git a/scripts/control/freqchkw.m b/scripts/control/freqchkw.m
--- a/scripts/control/freqchkw.m
+++ b/scripts/control/freqchkw.m
@@ -16,17 +16,17 @@
 # along with Octave; see the file COPYING.  If not, write to the Free 
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function USEW = freqchkw(w)
   # function USEW = freqchkw(w)
   # used by freqresp to check that input frequency vector is legal
 
   # A S Hodel July 1996
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
 
   if(isempty(w))
     USEW = 0;
   elseif(!is_vector(w))
     error(["w (",num2str(rows(w)),"x",num2str(columns(w)), ...
       "): must be [], a vector or a scalar"]);
   elseif( (max(abs(imag(w))) != 0) && (min(real(w)) <= 0) )
     error("w must have real positive entries");
diff --git a/scripts/control/freqresp.m b/scripts/control/freqresp.m
--- a/scripts/control/freqresp.m
+++ b/scripts/control/freqresp.m
@@ -23,17 +23,17 @@ function [ff,w] = freqresp(sys,USEW,w);
   # USEW returned by freqchkw 
   # w: optional, must be present if USEW is given
   #
   # returns: ff = vector of finite G(j*w) entries (or || G(j*w) || for MIMO)
   #          w = vector of frequencies used
   #      ff and w are both returned as row vectors
 
   #  Written by: R. Bruce Tenison July 11, 1994
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
   # SYS_INTERNAL accesses members of system data structure
 
   save_val = empty_list_elements_ok;
   empty_list_elements_ok = 1;
 
   # Check Args
   if( (nargin < 2) || (nargin > 4) )
     usage ("[ff,w] = freqresp(sys,USEW{,w})");
diff --git a/scripts/control/gram.m b/scripts/control/gram.m
--- a/scripts/control/gram.m
+++ b/scripts/control/gram.m
@@ -20,13 +20,13 @@ function m = gram(a,b)
   # m = gram(a,b)
   # Return controllability grammian of continuous time system
   #
   #  dx/dt = a x + b u
   #
   # a m + a' + b*b' = 0 
 
   # Written by A. S. Hodel 
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
 
   # let lyap do the error checking...
   m = lyap(a,b*b');
 endfunction
diff --git a/scripts/control/h2norm.m b/scripts/control/h2norm.m
--- a/scripts/control/h2norm.m
+++ b/scripts/control/h2norm.m
@@ -25,17 +25,17 @@ function h2gain = h2norm(sys)
   #
   # Reference:
   # Doyle, Glover, Khargonekar, Francis, "State Space Solutions to Standard
   # H2 and Hinf Control Problems", IEEE TAC August 1989
   #
 
   # A. S. Hodel Aug 1995
   # updated for system data structure by John Ingram November 1996
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
 
   if((nargin != 1))
     usage("h2gain = h2norm(sys)");
   elseif(!is_struct(sys))
     error("Sys must be in system data structure");
   end
   dflg = is_digital(sys);
 
diff --git a/scripts/control/h2syn.m b/scripts/control/h2syn.m
--- a/scripts/control/h2syn.m
+++ b/scripts/control/h2syn.m
@@ -37,17 +37,17 @@ function [K,gain, Kc, Kf, Pc,  Pf] = h2s
   #    Kc: full information control (system data structure)
   #    Kf: state estimator (system data structure)
   #       WARNING: incorporation of the is_dgkf nonsingular transformations
   #       Ru and Ry into Kc and Kf has not been tested.  
   #    Pc: ARE solution matrix for regulator subproblem
   #    Pf: ARE solution matrix for filter subproblem
 
   # Updated for System structure December 1996 by John Ingram
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
 
   if ((nargin < 3) | (nargin > 4))
     usage("[K,gain, Kc, Kf, Pc, Pf] = h2syn(Asys,nu,ny[,tol])");
   elseif(nargin == 3 )
     [chkdgkf,dgs] = is_dgkf(Asys,nu,ny);
   elseif(nargin == 4)
     [chkdgkf,dgs] = is_dgkf(Asys,nu,ny,tol);
   endif
diff --git a/scripts/control/hinf_ctr.m b/scripts/control/hinf_ctr.m
--- a/scripts/control/hinf_ctr.m
+++ b/scripts/control/hinf_ctr.m
@@ -26,21 +26,21 @@ function K = hinf_ctr(dgs,F,H,Z,g)
   #           F, H:         feedback and filter gain (not partitioned)
   #           g:            final gamma value
   # outputs: 
   #           controller K (system data structure)
   #
   # Do not attempt to use this at home; no argument checking performed.
 
   # A. S. Hodel August 1995
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
   # Revised by Kai P Mueller April 1998 to solve the general H_infinity
   # problem using unitary transformations Q (on w and z)
   # and non-singular transformations R (on u and y).
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
 
   nw = dgs.nw;
   nu = dgs.nu;
   nz = dgs.nz;
   ny = dgs.ny;
   d22nz = dgs.Dyu_nz;
   
   B1  = dgs.Bw;
diff --git a/scripts/control/hinfdemo.m b/scripts/control/hinfdemo.m
--- a/scripts/control/hinfdemo.m
+++ b/scripts/control/hinfdemo.m
@@ -94,17 +94,17 @@
 #	    -----| K |<-------
 #	         +---+
 #
 #	W1 and W2 are the robustness and performancs weighting
 #       functions
 
 
 # Kai P. Mueller 30-APR-1998 <mueller@ifr.ing.tu-bs.de
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
 yn = [];
 while (length(yn) < 1)
   yn = input(" * [s]iso, [m]imo, or [d]iscrete design? [no default]: ","S");
 endwhile
 if ((yn(1) == "s") | (yn(1) == 'S'))
   sys_type = 1;
 elseif ((yn(1) == "m") | (yn(1) == 'M'))
diff --git a/scripts/control/hinfnorm.m b/scripts/control/hinfnorm.m
--- a/scripts/control/hinfnorm.m
+++ b/scripts/control/hinfnorm.m
@@ -34,17 +34,17 @@ function [g gmin gmax] = hinfnorm(sys,to
   #       Default: 1e-9
   #
   # References:
   # Doyle, Glover, Khargonekar, Francis, "State space solutions to standard
   #    H2 and Hinf control problems", IEEE TAC August 1989
   # Iglesias and Glover, "State-Space approach to discrete-time Hinf control,"
   #    Int. J. Control, vol 54, #5, 1991
   # Zhou, Doyle, Glover, "Robust and Optimal Control," Prentice-Hall, 1996
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
 
   if((nargin == 0) || (nargin > 4))
     usage("[g gmin gmax] = hinfnorm(sys[,tol,gmin,gmax,ptol])");
   elseif(!is_struct(sys))
     error("Sys must be a system data structure");
   endif
 
   # set defaults where applicable
diff --git a/scripts/control/hinfsyn.m b/scripts/control/hinfsyn.m
--- a/scripts/control/hinfsyn.m
+++ b/scripts/control/hinfsyn.m
@@ -51,22 +51,22 @@ function [K,g,GW,Xinf,Yinf] = hinfsyn(As
   #        g:   designed gain value
   #       GW:   closed loop system
   #     Xinf:   ARE solution matrix for regulator subproblem
   #     Yinf:   ARE solution matrix for filter subproblem
 
 
   # A. S. Hodel August 1995
   # Updated for Packed system structures December 1996 by John Ingram
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
   #
   # Revised by Kai P Mueller April 1998 to solve the general H_infinity
   # problem using unitary transformations Q (on w and z)
   # and non-singular transformations R (on u and y).
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
 
   old_page_val = page_screen_output;
   page_screen_output = 0;
 
   if( (nargin < 1) | (nargin > 8) )
     usage("[K,g,GW,Xinf,Yinf] = hinfsyn(Asys,nu,ny,gmin,gmax,gtol,ptol,tol)");
   endif
   # set default arguments
diff --git a/scripts/control/hinfsyn_chk.m b/scripts/control/hinfsyn_chk.m
--- a/scripts/control/hinfsyn_chk.m
+++ b/scripts/control/hinfsyn_chk.m
@@ -30,17 +30,17 @@ function [retval,Pc,Pf] = hinfsyn_chk(A,
   # outputs: 
   #   retval: = 1 if g exceeds optimal Hinf closed loop gain, else 0
   #   Pc: solution of "regulator" H-inf ARE
   #   Pf: solution of "filter" H-inf ARE
   #
   # Do not attempt to use this at home; no argument checking performed.
 
   # A. S. Hodel August 1995
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
 
   Pc = Pf = [];
 
   # Construct the two Hamiltonians
   g2 = 1/(g*g);
   Hc = [ A ,  g2*B1*B1' - B2*B2'; -C1'*C1 , -A'];
   Hf = [ A' , g2*C1'*C1 - C2'*C2; -B1*B1' , -A];
 
diff --git a/scripts/control/impulse.m b/scripts/control/impulse.m
--- a/scripts/control/impulse.m
+++ b/scripts/control/impulse.m
@@ -31,17 +31,17 @@ function [y, t] = impulse(sys, inp, tsto
 # When the step function is invoked with the output parameter y
 # a plot is not displayed.
 #
 # See also: step, stepimp
 
 # Written by Kai P. Mueller October 2, 1997
 # based on lsim.m of Scottedward Hodel
 # modified by
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   if((nargin < 1) || (nargin > 4))
     usage("[y, u] = impulse(sys[, inp, tstop, n])");
   endif
 
   if(nargout > 2)
     usage("[y, u] = impulse(sys[, inp, tstop, n])");
   endif
diff --git a/scripts/control/is_abcd.m b/scripts/control/is_abcd.m
--- a/scripts/control/is_abcd.m
+++ b/scripts/control/is_abcd.m
@@ -24,17 +24,17 @@ function retval = is_abcd(a, b, c, d)
   # The matrices b, c, or d may be omitted.
   # ------------------------------------------------------
   # 
   # see also: abcddim
 
   # Written by Kai P. Mueller November 4, 1997
   # based on is_controllable.m of Scottedward Hodel
   # modified by
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
 
   retval = 0;
   switch (nargin)
     case (1)
       # A only
       [na, ma] = size(a);
       if (na != ma)
         disp("Matrix A ist not square.")
diff --git a/scripts/control/is_controllable.m b/scripts/control/is_controllable.m
--- a/scripts/control/is_controllable.m
+++ b/scripts/control/is_controllable.m
@@ -32,17 +32,17 @@ function [retval,U] = is_controllable (a
 # tol is a roundoff paramter, set to 10*eps if omitted.
 #
 # See also: size, rows, columns, length, is_matrix, is_scalar, is_vector
 #     is_observable, is_stabilizable, is_detectable, krylov, krylovb
 
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August, 1993.
 # Updated by A. S. Hodel (scotte@eng.auburn.edu) Aubust, 1995 to use krylovb 
 # Updated by John Ingram (ingraje@eng.auburn.edu) July, 1996 for packed systems
-# $Revision: 1.15 $
+# $Revision: 1.16 $
 
   deftol = 1;    # assume default tolerance
   if(nargin < 1 | nargin > 3)
     usage("[retval,U] = %s\n\t%s", "is_controllable(a {, b ,tol})", ...
 	"is_controllable(sys{,tol})");
   elseif(is_struct(a))
     # system structure passed.
     sys = sysupdate(a,"ss");
diff --git a/scripts/control/is_detectable.m b/scripts/control/is_detectable.m
--- a/scripts/control/is_detectable.m
+++ b/scripts/control/is_detectable.m
@@ -26,17 +26,17 @@ function [retval,U] = is_detectable (a,c
 #
 # Returns 1 if the system, a, is detectable, 1 if the pair (a, c) is 
 # detectable, or 0 if not.
 #
 # See also: size, rows, columns, length, is_matrix, is_scalar, is_vector.
 
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
 # Updated by John Ingram (ingraje@eng.auburn.edu) July 1996.
-# $Revision: 2.0.0.0 $ 
+# $Revision: 2.0.0.2 $ 
 
   if( nargin < 1) 
     usage("[retval,U] = is_detectable(a , c {, tol})");
   elseif(is_struct(a))
     # system form
     if(nargin == 2)
       tol = c;
     elseif(nargin > 2)
diff --git a/scripts/control/is_dgkf.m b/scripts/control/is_dgkf.m
--- a/scripts/control/is_dgkf.m
+++ b/scripts/control/is_dgkf.m
@@ -65,17 +65,17 @@ function [retval,dgkf_struct] = is_dgkf(
   #     and relations to risk sensitivity,"
   #     Systems & Control Letters 11, Oct. 1988, pp 167-172.
   # [4] P. A. Iglesias and K. Glover, "State-space approach to discrete-time
   #     H-infinity control."  Int. J. Control, 1991, V. 54, #5, 1031-1073.
   #
   
   #  Written by A. S. Hodel
   #  Updated by John Ingram July 1996 to accept structured systems
-  #  $Revision: 2.0.0.0 $
+  #  $Revision: 2.0.0.2 $
   #
   # Revised by Kai P Mueller April 1998 to solve the general H_infinity
   # problem using unitary transformations Q (on w and z)
   # and non-singular transformations R (on u and y) such
   # that the Dzu and Dyw matrices of the transformed plant
   #
   #    ~
   #    P  (the variable Asys here)
@@ -87,17 +87,17 @@ function [retval,dgkf_struct] = is_dgkf(
   #     12   12  12  12
   #
   #    ~            T
   #    D  = R   D   Q   = [ 0 I ] or [ I ].
   #     21   21  21  21
   #
   # This transformation together with the algorithm in [1] solves
   # the general problem (see [2] for example). 
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
 
   if (nargin < 3) | (nargin > 4)
     usage("[retval,dgkf_struct] = is_dgkf(Asys,nu,ny{,tol})");
   elseif (! is_scalar(nu) | ! is_scalar(ny) )
     error("is_dgkf: arguments 2 and 3 must be scalars")
   elseif (! is_struct(Asys) )
     error("Argument 1 must be a system data structure");
   endif
diff --git a/scripts/control/is_digital.m b/scripts/control/is_digital.m
--- a/scripts/control/is_digital.m
+++ b/scripts/control/is_digital.m
@@ -17,17 +17,17 @@
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function DIGITAL = is_digital(sys)
 # function DIGITAL = is_digital(sys)
 # retrurn nonzero if system is digital
 # exits with an error of sys is a mixed (continuous and discrete) system
 
 # a s hodel July 1996
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 # SYS_INTERNAL accesses members of system structure
 
   # checked for sampled data system (mixed)
   # discrete system
   sysyd = sysgetsignals(sys,"yd");
   [nn,nz] = sysdimensions(sys);
   cont = sum(sysyd == 0) + nn;
   tsam = sysgettsam(sys);
diff --git a/scripts/control/is_observable.m b/scripts/control/is_observable.m
--- a/scripts/control/is_observable.m
+++ b/scripts/control/is_observable.m
@@ -26,17 +26,17 @@ function [retval,U] = is_observable (a,c
 #
 # Returns 1 if the system, a, is observable, 1 if the pair (a, c) is 
 # observable, or 0 if not.
 #
 # See also: size, rows, columns, length, is_matrix, is_scalar, is_vector.
 
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
 # Updated by John Ingram (ingraje@eng.auburn.edu) July 1996.
-# $Revision: 1.15 $ 
+# $Revision: 1.16 $ 
 
   if( nargin < 1) 
     usage("[retval,U] = is_observable(a , c {, tol})");
   elseif(is_struct(a))
     # system form
     if(nargin == 2)
       tol = c;
     elseif(nargin > 2)
diff --git a/scripts/control/is_sample.m b/scripts/control/is_sample.m
--- a/scripts/control/is_sample.m
+++ b/scripts/control/is_sample.m
@@ -17,13 +17,13 @@
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function out = is_sample(Ts)
 #
 # out = is_sample(Ts): return true if Ts is a legal sampling time
 # (real,scalar, > 0)
 
 # A. S. Hodel July 1995
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
 out = (is_scalar(Ts) && (Ts == abs(Ts)) && (Ts != 0) );
 
 endfunction
diff --git a/scripts/control/is_siso.m b/scripts/control/is_siso.m
--- a/scripts/control/is_siso.m
+++ b/scripts/control/is_siso.m
@@ -16,17 +16,17 @@
 # along with Octave; see the file COPYING.  If not, write to the Free 
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function  SISO = is_siso(sys)
 # function SISO = is_siso(sys)
 # return nonzero if the system sys is single-input, single-output.
 
 # a s hodel July 1996, 1998
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 # SYS_INTERNAL accesses members of system structure
 
   if(nargin != 1)
     usage("SISO = is_siso(sys)");
   elseif( !is_struct(sys))
     error("input must be a system structure (see ss2sys, tf2sys, zp2sys)");
   endif
 
diff --git a/scripts/control/is_stabilizable.m b/scripts/control/is_stabilizable.m
--- a/scripts/control/is_stabilizable.m
+++ b/scripts/control/is_stabilizable.m
@@ -33,17 +33,17 @@ function [retval,U] = is_stabilizable (a
 # tol is a roundoff paramter, set to 200*eps if omitted.
 #
 # See also: size, rows, columns, length, is_matrix, is_scalar, is_vector
 #     is_observable, is_stabilizable, is_detectable
 
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August, 1993.
 # Updated by A. S. Hodel (scotte@eng.auburn.edu) Aubust, 1995 to use krylovb 
 # Updated by John Ingram (ingraje@eng.auburn.edu) July, 1996 to accept systems
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   if(nargin < 1)        usage("[retval,U] = is_stabilizable(a {, b ,tol})");
   elseif(is_struct(a))
     # sustem passed.
     if(nargin == 2)
       tol = b;          % get tolerance
     elseif(nargin > 2)
       usage("[retval,U] = is_stabilizable(sys{,tol})");
diff --git a/scripts/control/is_stable.m b/scripts/control/is_stable.m
--- a/scripts/control/is_stable.m
+++ b/scripts/control/is_stable.m
@@ -28,17 +28,17 @@ function retval = is_stable (a, tol, dis
 #         0: stable if eig(a) in open LHP (default)
 #
 # See also: size, rows, columns, length, is_matrix, is_scalar, is_vector
 #     is_observable, is_stabilizable, is_detectable, krylov, krylovb
 
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August, 1993.
 # Updated by John Ingram (ingraje@eng.auburn.edu) July, 1996 for systems
 # Updated to simpler form by a.s.hodel 1998
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   if( (nargin < 1) | (nargin > 3) )   usage("is_stable(a {,tol,disc})");
   elseif(is_struct(a))
     # system was passed
     if(nargin < 3)			disc = is_digital(a);
     elseif(disc != is_digital(a))
       warning("is_stable: disc =%d does not match system",disc)
     endif
diff --git a/scripts/control/jet707.m b/scripts/control/jet707.m
--- a/scripts/control/jet707.m
+++ b/scripts/control/jet707.m
@@ -23,17 +23,17 @@ function outsys = jet707()
   # System inputs:   (1) thrust   and (2) elevator angle
   # System outputs:  (1) airspeed and (2) pitch angle
   # Ref: R. Brockhaus: Flugregelung (Flight Control), Springer, 1994
   #
   # see also: ord2
 
   # Written by Kai P. Mueller September 28, 1997
   # Updates
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
 
   if (nargin != 0)
     usage("outsys = jet707()")
   endif
   if (nargin > 1)
     usage("outsys = jet707()")
   endif
 
diff --git a/scripts/control/lqe.m b/scripts/control/lqe.m
--- a/scripts/control/lqe.m
+++ b/scripts/control/lqe.m
@@ -35,17 +35,17 @@ function [k, p, e] = lqe (a, g, c, sigw,
 #
 # Returns:
 #
 #   k = observer gain, (A - K C) is stable
 #   p = solution of algebraic Riccati equation
 #   e = closed loop poles of (A - K C)
 
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August, 1993.
-# $Revision: 1.15 $
+# $Revision: 1.16 $
 
   if ( (nargin != 5) && (nargin != 6))
     error ("lqe: invalid number of arguments");
   endif
 
 # The problem is dual to the regulator design, so transform to lqr
 # call.
 
diff --git a/scripts/control/lqg.m b/scripts/control/lqg.m
--- a/scripts/control/lqg.m
+++ b/scripts/control/lqg.m
@@ -43,17 +43,17 @@ function [K,Q1,P1,Ee,Er] = lqg(sys,Sigw,
 #    Q: Solution of estimation algebraic Riccati equation
 #    Ee: estimator poles
 #    Es: controller poles
 #
 # See also: h2syn, lqe, lqr
 
 # Written by A. S. Hodel August 1995; revised for new system format
 # August 1996
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
 sav_val = implicit_str_to_num_ok;
 implicit_str_to_num_ok = 1;
 
 if ( (nargin < 5) | (nargin > 6))
   usage("[K,Q1,P1,Ee,Er] = lqg(sys,Sigw, Sigv,Q,R{,input_list})");
 
 elseif(!is_struct(sys) )
diff --git a/scripts/control/lqr.m b/scripts/control/lqr.m
--- a/scripts/control/lqr.m
+++ b/scripts/control/lqr.m
@@ -42,17 +42,17 @@ function [k, p, e] = lqr (a, b, q, r, s)
 #   k = state feedback gain, (A - B K) is stable and minimizes the
 #       cost functional
 #   p = solution of algebraic Riccati equation
 #   e = closed loop poles of (A - B K)
 #
 # reference: Anderson and Moore, OPTIMAL CONTROL: LINEAR QUADRATIC METHODS,
 # Prentice-Hall, 1990, pp. 56-58
 
-# $Revision: 1.14 $
+# $Revision: 1.15 $
 
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
 
   # disp("lqr: entry");
 
   if ((nargin != 4) && (nargin != 5))
     error ("lqr: invalid number of arguments");
   endif
diff --git a/scripts/control/lsim.m b/scripts/control/lsim.m
--- a/scripts/control/lsim.m
+++ b/scripts/control/lsim.m
@@ -30,17 +30,17 @@ function [y,x] = lsim(sys,u,t,x0)
 #
 # When the lsim function is invoked with output parameters:
 # [y,x] = lsim(sys,u,t,[x0])
 # a plot is not displayed, however, the data is returned in y = system output
 # and x = system states.
 
 # Written by David Clem, A. S. Hodel July 1995
 # modified by John Ingram for system format August 1996
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
 
   if((nargin < 3)||(nargin > 4))
     usage("[y,x] = lsim(sys,u,t[,x0])");
   endif
 
   if(!is_struct(sys))
     error("sys must be in system data structure");
diff --git a/scripts/control/ltifr.m b/scripts/control/ltifr.m
--- a/scripts/control/ltifr.m
+++ b/scripts/control/ltifr.m
@@ -27,17 +27,17 @@ function out = ltifr(a,b,w)
   # this function takes the system matrices, A and B and
   # returns:               -1
   #          G(s) = (jw I-A) B
   #
   # for complex frequencies s = jw. 
 
   # R. B. Tenison, D. Clem, A. S. Hodel, July 1995
   # updated by John Ingram August 1996 for system format
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
   
   if ((nargin < 2) || (nargin > 3))
     error("incorrect number of input arguments");
   endif
 
   if (nargin == 2)
     sys = a;
     w = b;
diff --git a/scripts/control/mb.m b/scripts/control/mb.m
--- a/scripts/control/mb.m
+++ b/scripts/control/mb.m
@@ -1,12 +1,12 @@
 # I think that this m-file can be deleted
 # a.s.hodel@eng.auburn.edu - 4 Dec. 1998
 
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
 Ap = [0 1;1960 0];
 Bp = [0;-6261];
 Cp = [1 0];
 Dp = 0;
 
 Gp = ss2sys(Ap,Bp,Cp,Dp,0,2,0,[],"delta_i","delta_y");
 Gp = syssetsignals(Gp,"st","delta_x1",1);
diff --git a/scripts/control/minfo.m b/scripts/control/minfo.m
--- a/scripts/control/minfo.m
+++ b/scripts/control/minfo.m
@@ -28,17 +28,17 @@ function [systype, nout, nin, ncstates, 
   #      nout is the number of outputs of the system
   #      nin is the number of inputs of the system
   #      ncstates is the number of continuous states of the system
   #	 ndstates is the number of discrete states of the system
 
   # Written by R. Bruce Tenison July 29, 1994
   # Modified by David Clem November 13, 1994
   # Modified by A. S. Hodel July 1995
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
 
   warning("minfo: obsolete.  Use sys2ss, sys2tf, or sys2zp.");
     
   if (nargin ~= 1 )
     disp('MINFO: Wrong number of arguments')
     systype = nout = nin = ncstates = ndstates = [];
   endif
   
diff --git a/scripts/control/moddemo.m b/scripts/control/moddemo.m
--- a/scripts/control/moddemo.m
+++ b/scripts/control/moddemo.m
@@ -15,17 +15,17 @@
 # You should have received a copy of the GNU General Public License 
 # along with Octave; see the file COPYING.  If not, write to the Free 
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function moddemo()
 # Octave Controls toolbox demo: Model Manipulations demo
 # Written by David Clem August 15, 1994
 
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 # a s hodel: updated to reflect updated output order in ss2zp
 
   while (1)
     clc
     disp('Octave Model Manipulations Demo')
     disp('=======================================')
     disp('  1)  Perform continuous to discrete time conversion (c2d)')
     disp('  2)  Convert from state space to zero / pole form (ss2zp)')
diff --git a/scripts/control/nichols.m b/scripts/control/nichols.m
--- a/scripts/control/nichols.m
+++ b/scripts/control/nichols.m
@@ -89,24 +89,22 @@ function [mag,phase,w] = nichols(sys,w,o
     if(is_digital(sys))
       tistr = "(exp(jwT)) ";
     else
       tistr = "(jw)";
     endif
     xlabel("Phase (deg)");
     ylabel("Gain in dB");
     if(is_siso(sys))
-      title(["Nichols plot of |[Y/U]",tistr,"|, u=", inname, ...
-	", y=",outname]);
+      title(["Nichols plot of |[Y/U]",tistr,"|, u=", ...
+	sysgetsignals(sys,"in",1,1), ", y=",sysgetsignals(sys,"out",1,1)]);
     else
       title([ "||Y(", tistr, ")/U(", tistr, ")||"]);
-      disp("MIMO plot from")
-      outlist(inname,"	");
-      disp("to")
-      outlist(outname,"	");
+      printf("MIMO plot from\n%s\nto\n%s\n",outlist(inname,"	"), ...
+        outlist(outname,"	"));
     endif
     md = 20*log10(mag);
     axvec = axis2dlim([vec(phase),vec(md)]);
     axis(axvec);
     plot(phase,md);
     mag = phase = w = [];
   endif
 endfunction
diff --git a/scripts/control/obsv.m b/scripts/control/obsv.m
--- a/scripts/control/obsv.m
+++ b/scripts/control/obsv.m
@@ -34,17 +34,17 @@ function Qb = obsv(sys, c)
   # Note: obsv() forms the observability matrix.
   #       The numerical properties of is_observable()
   #       are much better for observability tests.
   # See also:  ctrb, is_observable, is_controllable
   # ------------------------------------------------------
 
   # Written by Kai P. Mueller November 4, 1997
   # modified by
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
 
   if (nargin == 2)
     a = sys;
   elseif (nargin == 1 && is_struct(sys))
     sysupdate(sys,"ss");
     [a,b,c] = sys2ss(sys);
   else
     usage("obsv(sys [, c])")
diff --git a/scripts/control/ord2.m b/scripts/control/ord2.m
--- a/scripts/control/ord2.m
+++ b/scripts/control/ord2.m
@@ -33,17 +33,17 @@ function outsys = ord2(nfreq, damp, gain
   #      G = | |             |, |   |, [ 0  gain ], 0 |
   #          | \   w       0 /  \ 0 /                 |
   #          \                                        /
   #
   # See also: jet707 (MIMO example, Boeing 707-321 aircraft model)
 
   # Written by Kai P. Mueller September 28, 1997
   # Updates
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
 
   if(nargin != 2 & nargin != 3)
     usage("outsys = ord2(nfreq, damp[, gain])")
   endif
   if (nargout > 1)
     usage("outsys = ord2(nfreq, damp[, gain])")
   endif
   if (nargin == 2)
diff --git a/scripts/control/outlist.m b/scripts/control/outlist.m
--- a/scripts/control/outlist.m
+++ b/scripts/control/outlist.m
@@ -29,17 +29,17 @@ function str_val = outlist(name_list,tab
 #           (used by sysout; minimal checking of this argument)
 #	   yd = [] => all continuous
 #       ilist: index numbers to print with names
 #	  default: 1:length(name_list)
 # outputs:
 #   prints the list to the screen, numbering each string in order.
 
 # A. S. Hodel Dec. 1995, 1998
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
 #save for restore later
 save_empty = empty_list_elements_ok;
 empty_list_elements_ok = 1;
 
 if( nargin < 1 | nargin > 4 )
   usage("str_val = outlist(x[,tabchar,yd,ilist])");
 endif
diff --git a/scripts/control/packsys.m b/scripts/control/packsys.m
--- a/scripts/control/packsys.m
+++ b/scripts/control/packsys.m
@@ -27,17 +27,17 @@ function Asys = packsys(a,b,c,d,dflg)
   #   dflg: 0 (continuous time)
   #
   # Note: discrete-state sampling time is not included!
   #
   
   # Written by R. Bruce Tenison  July 29, 1994
   # Modified by David Clem November 13, 1994
   # Modified by A. S. Hodel April 1995
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
 
   warning("packsys is obsolete!  Use ss2sys instead.");
   
   if (nargin < 3 || nargin > 5)
     disp("packsys: Invalid number of arguments")
   endif
 
   # check dflg
diff --git a/scripts/control/parallel.m b/scripts/control/parallel.m
--- a/scripts/control/parallel.m
+++ b/scripts/control/parallel.m
@@ -28,17 +28,17 @@ function sysp = parallel(Asys,Bsys)
 #         |--->|----> | Bsys |--->|----> y2
 #              |      --------    |
 #              --------------------
 #                   Ksys
 
 # Written by David Clem August 15, 1994
 # completely rewritten Oct 1996 a s hodel
 # SYS_INTERNAL accesses members of system structure
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   if(nargin != 2)
     usage("sysp = parallel(Asys,Bsys)");
   endif
   if(! is_struct(Asys) )
     error("1st input argument is not a system data structure")
   elseif (! is_struct(Bsys) )
     error("2nd input argument is not a system data structure")
diff --git a/scripts/control/place.m b/scripts/control/place.m
--- a/scripts/control/place.m
+++ b/scripts/control/place.m
@@ -35,17 +35,17 @@ function K = place(sys, P)
 %	      E-Mail: daniel@dea.icai.upco.es
 %
 %	      Phone: 34-1-5422800   Fax: 34-1-5596569
 %
 % Algorithm taken from "The Control Handbook", IEEE press pp. 209-212
 #
 # code adaped by A.S.Hodel (a.s.hodel@eng.auburn.edu) for use in controls
 # toolbox
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   sav_val = empty_list_elements_ok;
   empty_list_elements_ok = 1;
   #
   # check arguments
   #
   if(!is_struct(sys))
     error("sys must be in system data structure format (see ss2sys)");
diff --git a/scripts/control/polyout.m b/scripts/control/polyout.m
--- a/scripts/control/polyout.m
+++ b/scripts/control/polyout.m
@@ -25,17 +25,17 @@ function y = polyout(c,x)
 # in a string or to the screen (if y is omitted)
 # x defaults to the string "s"
 #
 #  SEE ALSO: polyval, polyvalm, poly, roots, conv, deconv, residue, 
 #	filter, polyderiv, polyinteg
 
 # Written by A. Scottedward Hodel (scotte@eng.auburn.edu) May 1995)
 # Nov 1998: Correctly handles complex coefficients
-# $Revision: 2.0.0.0 $ 
+# $Revision: 2.0.0.2 $ 
   
   if (nargin < 1 ) || (nargin > 2) || (nargout < 0 ) || (nargout > 1)
     usage("[y = ] polyout(c,[x])");
   endif
 
   if (!is_vector(c))
     error("polyout: first argument must be a vector");
   endif
diff --git a/scripts/control/prompt.m b/scripts/control/prompt.m
--- a/scripts/control/prompt.m
+++ b/scripts/control/prompt.m
@@ -18,17 +18,17 @@
  
 function prompt(str)
 # function prompt([str])
 # Prompt user to continue
 # str: input string. Default value: "\n ---- Press a key to continue ---"
 # Written by David Clem August 15, 1994
 # Modified A. S. Hodel June 1995
 
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
 if(nargin > 1)
   usage("prompt([str])");
 elseif(nargin == 0)
   str = "\n ---- Press a key to continue ---";
 elseif ( !isstr(str) )
   error("prompt: input must be a string");
 endif
diff --git a/scripts/control/rldemo.m b/scripts/control/rldemo.m
--- a/scripts/control/rldemo.m
+++ b/scripts/control/rldemo.m
@@ -15,17 +15,17 @@
 # You should have received a copy of the GNU General Public License 
 # along with Octave; see the file COPYING.  If not, write to the Free 
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function rldemo()
 # Octave Controls toolbox demo: Root Locus demo
 # Written by David Clem August 15, 1994
 # Updated by John Ingram December 1996
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   while (1)
     clc
     k = menu("Octave Root Locus Demo", ...
     	"Display continuous system's open loop poles and zeros (pzmap)", ...
     	"Display discrete system's open loop poles and zeros (pzmap)", ...
     	"Display root locus diagram of SISO continuous system (rlocus)", ...
     	"Display root locus diagram of SISO discrete system (rlocus)", ...	
diff --git a/scripts/control/rlocus.m b/scripts/control/rlocus.m
--- a/scripts/control/rlocus.m
+++ b/scripts/control/rlocus.m
@@ -37,17 +37,17 @@ function [rldata,k_break,rlpol,gvec,real
   #        corresponding to to gain gvec(ii)
   #   gvec: gains used to compute root locus
   #   real_ax_pts: breakpoints of the real axis locus.
   
   # Convert the input to a transfer function if necessary
   # Written by Clem and Tenison
   # Updated by Kristi McGowan July 1996 for intelligent gain selection
   # Updated by John Ingram July 1996 for systems
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
   
   if (nargin < 1) | (nargin > 4)
     usage("rlocus(sys[,inc,mink,maxk])");
   endif
   
   [num,den] = sys2tf(sys);		# extract numerator/denom polyomials
   lnum = length(num);      lden = length(den);
   if(lden < 2)
diff --git a/scripts/control/rotg.m b/scripts/control/rotg.m
--- a/scripts/control/rotg.m
+++ b/scripts/control/rotg.m
@@ -17,12 +17,12 @@
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function [c,s] = rotg(a,b)
   #function [c,s] = rotg(a,b)
   # givens rotation calculation
   #
   # NOTE: Use [c,s] = givens(a,b) instead.
 
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
 
   [c,s] = givens(a,b);
 endfunction
diff --git a/scripts/control/run_cmd.m b/scripts/control/run_cmd.m
--- a/scripts/control/run_cmd.m
+++ b/scripts/control/run_cmd.m
@@ -1,12 +1,12 @@
 # run_cmd: short script used in demos
 # prints string cmd to the screen, then executes after a pause
 
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
 disp(["Command: ",cmd])
 puts("Press a key to execute command");
 fflush(stdout);
 kbhit();
 disp("  executing");
 fflush(stdout);
 eval(cmd);
diff --git a/scripts/control/series.m b/scripts/control/series.m
--- a/scripts/control/series.m
+++ b/scripts/control/series.m
@@ -33,17 +33,17 @@ function [a,b,c,d] = series(a1,b1,c1,d1,
 # outputs of system 2.
 #
 # Type of input: system data structure
 # Command:       syst=series(syst1,syst2)
 # Forms the series representation of the two mu system arguments.
 # Written by David Clem August 15, 1994
 
 # If two arguments input, take care of mu system case
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   warning("series is superseded by sysmult; use sysmult instead.")
 
   muflag = 0;
   if(nargin == 2)
     temp=b1;
     [a1,b1,c1,d1]=sys2ss(a1);
     [a2,b2,c2,d2]=sys2ss(temp);
diff --git a/scripts/control/sortcom.m b/scripts/control/sortcom.m
--- a/scripts/control/sortcom.m
+++ b/scripts/control/sortcom.m
@@ -27,17 +27,17 @@ function [yy,idx] = sortcom(xx,opt)
 #  if opt != "im" then values with common real part/magnitude are
 #     sorted by imaginary part, i.e. a - jb followed by a + jb. 
 #     [Complex conjugate pairs may not be grouped consecutively if more than 2
 #     numbers share a common real part/magnitude]
 # yy: sorted values
 # idx: permutation vector: yy = xx(idx)
 
 # Written by A. S. Hodel June 1995
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   if( nargin < 1 | nargin > 2 )
      usage("yy = sortcom(xx[,opt]");
   elseif( !(is_vector(xx) | isempty(xx) ))
     error("sortcom: first argument must be a vector");
   endif
 
   if(nargin == 1)         opt = "re";
diff --git a/scripts/control/ss2sys.m b/scripts/control/ss2sys.m
--- a/scripts/control/ss2sys.m
+++ b/scripts/control/ss2sys.m
@@ -67,17 +67,17 @@ function  retsys = ss2sys  (a,b,c,d,tsam
   #  ------------------------------------------------------
   #  outputs   | outname(cout,:) | outname(outlist,:)     |
   #  ------------------------------------------------------
   #
   #  where cout = list if indices in 1:rows(p) not contained in outlist.
   #
 
   #  Written by John Ingram (ingraje@eng.auburn.edu)  July 20, 1996
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.1 $
 
   save_val = implicit_str_to_num_ok;	# save for later
   implicit_str_to_num_ok = 1;
 
   #  Test for correct number of inputs
   if ((nargin < 3) | (nargin > 11))
     usage("retsys = ss2sys  (a,b,c{,d,tsam,n,nz,stname,inname,outname,outlist})");
   endif
@@ -163,14 +163,14 @@ function  retsys = ss2sys  (a,b,c,d,tsam
     if(!isempty(outname)) retsys = syssetsignals(retsys,"out",outname); endif
   endif
 
   # set up yd
   if(nargin < 11)
     retsys = syssetsignals(retsys,"yd",ones(1,p)*(tsam > 0));
   else
     if(!isempty(outlist)) 
-      retsys = syssetsignals(retsys,"yd",outlist,ones(size(outlist)));
+      retsys = syssetsignals(retsys,"yd",ones(size(outlist)),outlist);
     endif
   endif
 
   implicit_str_to_num_ok = save_val;	# restore value
 endfunction
diff --git a/scripts/control/ss2tf.m b/scripts/control/ss2tf.m
--- a/scripts/control/ss2tf.m
+++ b/scripts/control/ss2tf.m
@@ -29,17 +29,17 @@ function [num,den] = ss2tf(a,b,c,d)
 #                num(s)
 #          G(s)=-------
 #                den(s)
 #
 # used internally in system data structure manipulations
 
 # Written by R. Bruce Tenison (June 24, 1994) btenison@eng.auburn.edu
 # a s hodel: modified to allow for pure gain blocks Aug 1996
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
 # Check args
   [n,m,p] = abcddim(a,b,c,d);
   if (n == -1)
     num = [];
     den = [];
     error("ss2tf: Non compatible matrix arguments");
   elseif ( (m != 1) | (p != 1))
diff --git a/scripts/control/ss2zp.m b/scripts/control/ss2zp.m
--- a/scripts/control/ss2zp.m
+++ b/scripts/control/ss2zp.m
@@ -22,17 +22,17 @@ function [zer,pol,k] = ss2zp(a,b,c,d)
 # [pol,zer,k] = ss2zp(a,b,c,d) returns the poles and zeros of the state space 
 # system (a,b,c,d).  K is a gain associated with the zeros.
 #
 # used internally in system data structure manipulations
 
 # Written by David Clem August 15, 1994
 # Hodel: changed order of output arguments to zer, pol, k. July 1996
 # a s hodel: added argument checking, allow for pure gain blocks aug 1996
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   if(nargin != 4)
     usage("[zer,pol,k] = ss2zp(a,b,c,d)");
   endif
 
   [n,m,p] = abcddim(a,b,c,d);
   if (n == -1)
     error("ss2tf: Non compatible matrix arguments");
diff --git a/scripts/control/starp.m b/scripts/control/starp.m
--- a/scripts/control/starp.m
+++ b/scripts/control/starp.m
@@ -41,17 +41,17 @@ function [sys] = starp(P, K, ny, nu);
 # If ny and nu "consume" all inputs and outputs of K then the result
 # is a lower fractional transformation. If ny and nu "consume" all
 # inputs and outputs of P then the result is an upper fractional
 # transformation.
 #
 # ny and/or nu may be negative (= negative feedback)
 
 # Written by Kai Mueller May 1998
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   if((nargin != 2) && (nargin != 4))
     usage("[sys] = starp(P, K, ny, nu)");
   endif
   if (!is_struct(P))
     error("---> P must be in system data structure");
   endif
   if (!is_struct(K))
diff --git a/scripts/control/step.m b/scripts/control/step.m
--- a/scripts/control/step.m
+++ b/scripts/control/step.m
@@ -31,17 +31,17 @@ function [y, t] = step(sys, inp, tstop, 
 # When the step function is invoked with the output parameter y
 # a plot is not displayed.
 #
 # See also: impulse, stepimp
 
 # Written by Kai P. Mueller September 30, 1997
 # based on lsim.m of Scottedward Hodel
 # modified by
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   if((nargin < 1) || (nargin > 4))
     usage("[y, u] = step(sys[, inp, tstop, n])");
   endif
 
   if(nargout > 2)
     usage("[y, u] = step(sys[, inp, tstop, n])");
   endif
diff --git a/scripts/control/stepimp.m b/scripts/control/stepimp.m
--- a/scripts/control/stepimp.m
+++ b/scripts/control/stepimp.m
@@ -26,17 +26,17 @@ function [y, t] = stepimp(sitype, sys, i
 #
 # Limited argument checking; "do not attempt to do this at home".
 # Use step or impulse instead.
 #
 # See also:  step, impulse
 
 # Written by Kai P. Mueller October 2, 1997
 # based on lsim.m of Scottedward Hodel
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   if (sitype == 1)         IMPULSE = 0;
   elseif (sitype == 2)     IMPULSE = 1;
   else		   	   error("stepimp: illegal sitype argument.")
   endif
   sys = sysupdate(sys,"ss");
 
   USE_DEF = 0;   # default tstop and n if we have to give up
diff --git a/scripts/control/strappend.m b/scripts/control/strappend.m
--- a/scripts/control/strappend.m
+++ b/scripts/control/strappend.m
@@ -18,18 +18,20 @@
  
 function retval = strappend(strlist,suffix);
   # retval = strappend(strlist,suffix);
   # append string suffix to each string in the list of strings strlist
   
   if(nargin != 2 | nargout > 1)
     usage(" retval = strappend(strlist,suffix)");
   elseif(!is_signal_list(strlist))
+    strlist
     error("strlist must be a list of strings (see is_signal_list)");
-  elseif(!(isstr(suffix) & is_vector(suffix)))
+  elseif(!(isstr(suffix) & rows(suffix) == 1))
+    suffix
     error("suffix must be a single string");
   endif
 
   retval = list();
   for ii=1:length(strlist)
     retval(ii) = sprintf("%s%s",nth(strlist,ii),suffix);
   endfor
 
diff --git a/scripts/control/swap.m b/scripts/control/swap.m
--- a/scripts/control/swap.m
+++ b/scripts/control/swap.m
@@ -17,14 +17,14 @@
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function [a1,b1] = swap(a,b)
   # [a1,b1] = swap(a,b)
   # interchange a and b
 
   # A. S. Hodel July 24 1992
   # Conversion to Octave R. Bruce Tenison July 4, 1994
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
 
   a1 = b;
   b1 = a;
 endfunction
 
diff --git a/scripts/control/swapcols.m b/scripts/control/swapcols.m
--- a/scripts/control/swapcols.m
+++ b/scripts/control/swapcols.m
@@ -17,15 +17,15 @@
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function B = swapcols(A)
   # function B = swapcols(A)
   # permute columns of A into reverse order
   
   # A. S. Hodel July 23, 1992
   # Conversion to Octave R. Bruce Tenison July 4, 1994
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
 
   m = length(A(1,:));
   idx = m:-1:1;
   B = A(:,idx);
 endfunction
 
diff --git a/scripts/control/swaprows.m b/scripts/control/swaprows.m
--- a/scripts/control/swaprows.m
+++ b/scripts/control/swaprows.m
@@ -17,15 +17,15 @@
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function B = swaprows(A)
   # function B = swaprows(A)
   # permute rows of A into reverse order
 
   # A. S. Hodel July 23, 1992
   # Conversion to Octave R. Bruce Tenison July 4, 1994
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
   
   m = rows(A);
   idx = m:-1:1;
   B = A(idx,:);
 endfunction
 
diff --git a/scripts/control/sys2fir.m b/scripts/control/sys2fir.m
--- a/scripts/control/sys2fir.m
+++ b/scripts/control/sys2fir.m
@@ -15,17 +15,17 @@
 # You should have received a copy of the GNU General Public License 
 # along with Octave; see the file COPYING.  If not, write to the Free 
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function [c,tsam,inname,outname] = sys2fir(sys)
 # function [c,tsam,inname,outname] = sys2fir(sys)
 # extract fir system from system data structure
 
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 # a s hodel July 1996
 
   # let sys2tf do most of the work
 
   [num,den,tsam,inname,outname] = sys2tf(sys);
 
   alph = den(1);			# scale to get monic denominator
   den = den/alph;
diff --git a/scripts/control/sys2ss.m b/scripts/control/sys2ss.m
--- a/scripts/control/sys2ss.m
+++ b/scripts/control/sys2ss.m
@@ -36,17 +36,17 @@ function [a,b,c,d,tsam,n,nz,stname,innam
   #          inputs, and outputs, respectively
   #    yd: binary vector; yd(ii) is nonzero if output y is discrete.
   # 
   # A warning message is printed if the system is a mixed 
   # continuous/discrete system.
 
   # Written by David Clem August 19, 1994
   # Updates by John Ingram July 14, 1996
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
 
   if(nargin != 1)
     usage("[a,b,c,d,tsam,n,nz,stname,inname,outname,yd] = sys2ss(sys)")
   endif
 
   if (nargout > 11)
     warning(["sys2ss: ",num2str(nargout)," out arguments exceeds max=11"])
     usage("[a,b,c,d,tsam,n,nz,stname,inname,outname,yd] = sys2ss(sys)")
diff --git a/scripts/control/sys2tf.m b/scripts/control/sys2tf.m
--- a/scripts/control/sys2tf.m
+++ b/scripts/control/sys2tf.m
@@ -26,17 +26,17 @@ function [num,den,tsam,inname,outname] =
 #                den(s)
 #
 # The user can also have the sampling time (TSAM), the name of the input 
 # (INNAME), and the output name (OUTNAME)
 
 # Written by R. Bruce Tenison (June 24, 1994) btenison@eng.auburn.edu
 # modified to make sys2tf by A. S. Hodel Aug 1995
 # modified again for updated system format by John Ingram July 1996
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   if(nargin != 1)
     usage("[num,den,tsam,inname,outname] = sys2tf(Asys)");
   endif
 
   if( !is_struct(Asys))
     error("Asys must be a system data structure (see ss2sys, tf2sys, zp2sys)");
   elseif (! is_siso(Asys) )
diff --git a/scripts/control/sys2zp.m b/scripts/control/sys2zp.m
--- a/scripts/control/sys2zp.m
+++ b/scripts/control/sys2zp.m
@@ -24,17 +24,17 @@ function [zer,pol,k,tsam,inname,outname]
 # outputs:
 #   zer: vector of system zeros
 #   pol: vector of system poles
 #   k: scalar leading coefficient
 #   tsam: sampling period. default: 0 (continuous system)
 #   inname, outname: input/output signal names (strings)
 
 # Created by John Ingram July 15 1996
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   if(nargin != 1)
     usage("[zer,pol,k,tsam,inname,outname] = sys2zp(sys)");
   elseif( !is_struct(sys))
     error("sysconnect: sys must be in system data structure form")
   elseif (! is_siso(sys) )
     [n, nz, m, p] = sysdimensions(sys);
     error(["system is not SISO (",num2str(m)," inputs, ...
diff --git a/scripts/control/sysadd.m b/scripts/control/sysadd.m
--- a/scripts/control/sysadd.m
+++ b/scripts/control/sysadd.m
@@ -31,17 +31,17 @@ function sys = sysadd(Gsys,Hsys)
 #             ----|  Gsys  |---
 #        u   |    ----------  +|         
 #        -----                (_)----> y
 #            |     ________   +|
 #             ----|  Hsys  |---
 #                  --------
 
 # Written by John Ingram July 1996
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   save_val = implicit_str_to_num_ok;	# save for later
   implicit_str_to_num_ok = 1;
 
   if(nargin != 2)
     usage("sysadd:  [sys] = sysysadd(Gsys,Hsys)");
   endif
 
diff --git a/scripts/control/sysappend.m b/scripts/control/sysappend.m
--- a/scripts/control/sysappend.m
+++ b/scripts/control/sysappend.m
@@ -43,17 +43,17 @@ function retsys = sysappend(sys,b,c,d,ou
   # outputs are be assigned default names.  
   # yd is a vector of length rows(c), and indicates which new outputs are
   # discrete (yd(ii) = 1) and which are continuous (yd(ii) = 0).
   # Default value for yd is:
   #     sys = continuous or mixed: yd = zeros(1,rows(c))
   #     sys = discrete:            yd = ones(1,rows(c))
   
   # written by John Ingram August 1996
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
   
   sav_implicit_str_to_num_ok = implicit_str_to_num_ok;	# save for later
   sav_empty_list_elements_ok = empty_list_elements_ok;
 
   empty_list_elements_ok = 1;                implicit_str_to_num_ok = 1;
   
   # check input arguments
   if ( (nargin < 2) | (nargin > 7) | (!is_struct(sys)))
diff --git a/scripts/control/syschnames.m b/scripts/control/syschnames.m
--- a/scripts/control/syschnames.m
+++ b/scripts/control/syschnames.m
@@ -35,13 +35,13 @@ function retsys = syschnames(sys,opt,lis
 #              names corresponding to the lists above.  To
 # 	       change yd, use a vector.  Set the name to 0 for continuous, 
 #	       or 1 for discrete.
 # outputs:
 #    retsys=sys with appropriate signal names changed 
 #            (or yd values, where appropriate)
 
 # Written by John Ingram August 1996; updated by A. S. Hodel 1998
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   retsys = syssetsignals(sys,opt,names,list);
 
 endfunction
diff --git a/scripts/control/syschtsam.m b/scripts/control/syschtsam.m
--- a/scripts/control/syschtsam.m
+++ b/scripts/control/syschtsam.m
@@ -18,17 +18,17 @@
  
 function retsys = syschtsam(sys,tsam)
 #
 # retsys = syschtsam(sys,tsam);
 #
 # This function changes the sampling time (tsam) of the system.
 
 # Written by John Ingram August 1996
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   if (nargin != 2)
     usage("retsys = syschtsam(sys,tsam)");
   elseif (!is_struct(sys))
     error("sys must be in system data structure form");
   elseif(!is_scalar(tsam))
     disp("syschtsam:")
     tsam
diff --git a/scripts/control/sysconnect.m b/scripts/control/sysconnect.m
--- a/scripts/control/sysconnect.m
+++ b/scripts/control/sysconnect.m
@@ -45,17 +45,17 @@ function sys = sysconnect(sys,output_lis
 #                |                             |
 #                -------------------------------
 #
 # The input that has the summing junction added to it has an * added to the end 
 # of the input name.
 
 # A. S. Hodel August 1995
 # modified by John Ingram July 1996
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   save_val = implicit_str_to_num_ok;	# save for later
   implicit_str_to_num_ok = 1;
 
   if( (nargin < 3) | (nargin > 5) )
     usage("retsys = sysconnect(sys,output_list,input_list[,order,tol])");
   endif
 
diff --git a/scripts/control/syscont.m b/scripts/control/syscont.m
--- a/scripts/control/syscont.m
+++ b/scripts/control/syscont.m
@@ -24,17 +24,17 @@ function [csys,Acd,Ccd] = syscont(sys)
 # outputs: csys is the purely continuous input/output connections of
 #               sys
 #          Acd, Ccd: connections from discrete states to continuous states,
 #               discrete states to continuous outputs, respectively.
 #
 # returns csys empty if no continuous/continous path exists
 
 # Written by John Ingram August 1996
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   save_val = implicit_str_to_num_ok;	# save for later
   save_empty = empty_list_elements_ok;
   empty_list_elements_ok = implicit_str_to_num_ok = 1;
 
   if (nargin != 1)
     usage("[csys,Acd,Ccd,Dcd] = syscont(sys)");
   elseif (!is_struct(sys))
diff --git a/scripts/control/sysdefstname.m b/scripts/control/sysdefstname.m
--- a/scripts/control/sysdefstname.m
+++ b/scripts/control/sysdefstname.m
@@ -16,17 +16,17 @@
 # along with Octave; see the file COPYING.  If not, write to the Free 
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function stname = sysdefstname(n,nz)
 # function stname = sysdefstname(n,nz)
 # return default state names given n, nz
 # used internally, minimal argument checking
 
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   stname = list();
   if(n > 0)
     for ii = 1:n
       stname(ii) = sprintf("x_%d",ii);
     endfor
   endif
  
diff --git a/scripts/control/sysdisc.m b/scripts/control/sysdisc.m
--- a/scripts/control/sysdisc.m
+++ b/scripts/control/sysdisc.m
@@ -21,17 +21,17 @@ function [dsys,Adc,Cdc] = sysdisc(sys)
 # inputs: sys = system data structure
 # outputs:
 #    dsys: purely discrete portion of sys (returned empty if there is
 #          no purely discrete path from inputs to outputs)
 #    Adc, Cdc: connections from continuous states to discrete states/discrete
 #    outputs, respectively.
 #
 
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   save_val = implicit_str_to_num_ok;	# save for later
   save_empty = empty_list_elements_ok;
   empty_list_elements_ok = implicit_str_to_num_ok = 1;
 
 
   if (nargin != 1)
     usage("[dsys,Adc,Cdc] = sysdisc(sys)");
diff --git a/scripts/control/sysdup.m b/scripts/control/sysdup.m
--- a/scripts/control/sysdup.m
+++ b/scripts/control/sysdup.m
@@ -38,17 +38,17 @@ function retsys = sysdup(Asys,output_lis
 #                      |       Asys       |
 #                      |                  |
 #     u2 ------------->|                  |----->y2 
 #     (input_list)     |                  |      (output_list)
 #                      --------------------     
 
 # A. S. Hodel August 1995
 # modified by John Ingram July 1996
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   save_val = implicit_str_to_num_ok;	# save for later
   implicit_str_to_num_ok = 1;
 
   if( nargin != 3)
     usage("retsys = sysdup(Asys,output_list,input_list)");
   endif
 
diff --git a/scripts/control/sysgettsam.m b/scripts/control/sysgettsam.m
--- a/scripts/control/sysgettsam.m
+++ b/scripts/control/sysgettsam.m
@@ -1,13 +1,13 @@
 function T = sysgettsam(sys)
 # T = sysgettsam(sys)
 # return the sampling time of the system
 
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
 if(!is_struct(sys))
   usage("T = sysgettsam(sys)");
 endif
 
 T = sys.tsam;
 
 endfunction
diff --git a/scripts/control/sysgroup.m b/scripts/control/sysgroup.m
--- a/scripts/control/sysgroup.m
+++ b/scripts/control/sysgroup.m
@@ -35,17 +35,17 @@ function sys = sysgroup(Asys,Bsys)
 # 
 # The function also rearranges the A,B,C matrices so that the 
 # continuous states come first and the discrete states come last.
 # If there are duplicate names, the second name has a unique suffix appended
 # on to the end of the name.
 
 # A. S. Hodel August 1995
 # modified by John Ingram July 1996
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   save_val = implicit_str_to_num_ok;	# save for later
   implicit_str_to_num_ok = 1;
 
   save_emp = empty_list_elements_ok;
   empty_list_elements_ok = 1;
 
   if(nargin ~= 2)
diff --git a/scripts/control/sysgroupn.m b/scripts/control/sysgroupn.m
--- a/scripts/control/sysgroupn.m
+++ b/scripts/control/sysgroupn.m
@@ -23,17 +23,17 @@ function names = sysgroupn(names,kind)
 #   names: list of signal names
 #   kind: kind of signal name (used for diagnostic message purposes only)
 # outputs:
 #   returns names with unique suffixes added; diagnostic warning
 #      message is printed to inform the user of the new signal name
 #
 #  used internally in sysgroup
 
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   # check for duplicate names
   l = length(names);
   ii = 1;
   while(ii < l-1)
     st1 = nth(names,ii);
     jj = ii+1;
     while ( jj < l)
diff --git a/scripts/control/sysmult.m b/scripts/control/sysmult.m
--- a/scripts/control/sysmult.m
+++ b/scripts/control/sysmult.m
@@ -31,17 +31,17 @@ function [sys] = sysmult(Asys,Bsys)
 #         ----------     ----------
 #
 # A warning occurs if there is direct feed-through
 # from an input of Bsys or a continuous state of Bsys through a discrete 
 # output of Bsys to a continuous state or output in Asys (system data structure form 
 # does not recognize discrete inputs)
 
 # Written by John Ingram July 1996
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   save_val = implicit_str_to_num_ok;	# save for later
   implicit_str_to_num_ok = 1;
 
   if(nargin != 2)
     usage("sysmult:  [sys] = sysmult(Asys,Bsys)");
   endif
 
diff --git a/scripts/control/sysout.m b/scripts/control/sysout.m
--- a/scripts/control/sysout.m
+++ b/scripts/control/sysout.m
@@ -23,17 +23,17 @@ function retsys = sysout(sys,opt)
 # sys: system data structure
 # opt: []: primary system form (default)
 #      "ss": state space form
 #      "tf": transfer function form
 #      "zp": zero-pole form
 #      "all": all of the above
 
 # Written by A S Hodel: 1995-1996
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
 # save for restoring at end of routine
 save_val = implicit_str_to_num_ok;
 implicit_str_to_num_ok = 1;
 
 if( (nargin < 1) || (nargin > 2) )
   usage("sysout(sys[,opt])");
 endif
diff --git a/scripts/control/sysprune.m b/scripts/control/sysprune.m
--- a/scripts/control/sysprune.m
+++ b/scripts/control/sysprune.m
@@ -33,17 +33,17 @@ function sys = sysprune(sys,output_list,
 #    (input_list)      |       Asys       | (output_list)
 #                      |                  |
 #   u2 (deleted) |---->|                  |----| y2  (deleted)
 #                      |                  |    
 #                      --------------------    
 
 # A. S. Hodel August 1995
 # Updated by John Ingram 7-15-96
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   if( nargin != 3  )
     usage("retsys = sysprune(sys,output_list,input_list)");
   endif
 
   # default: no action
   [nn,nz,mm,pp] = sysdimensions(sys);
   if(isempty(output_list))
diff --git a/scripts/control/sysreorder.m b/scripts/control/sysreorder.m
--- a/scripts/control/sysreorder.m
+++ b/scripts/control/sysreorder.m
@@ -23,17 +23,17 @@ function pv = sysreorder(vlen,list)
 #         list: a subset of {1:vlen}
 # pv: a permutation vector to order elements of [1:vlen] in -list-
 #         to the end of a vector
 # used internally by sysconnect to permute vector elements to their
 # desired locations.  No user-serviceable parts inside; do not attempt
 # to use this at home!
 
 # A. S. Hodel, Aug 1995
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
   
   #disp('sysreorder: entry')
   
   pv = 1:vlen;
   # make it a row vector
   list = reshape(list,1,length(list));
   A = pv'*ones(size(list));
   B = ones(size(pv'))*list;
diff --git a/scripts/control/sysrepdemo.m b/scripts/control/sysrepdemo.m
--- a/scripts/control/sysrepdemo.m
+++ b/scripts/control/sysrepdemo.m
@@ -18,17 +18,17 @@
  
 function sysrepdemo()
 
 # Octave Controls toolbox demo: System representation
 
 # Written by A. S. Hodel June 1995
 # Revised Aug 1995 for system data structure format
 
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   save_val = page_screen_output;
   page_screen_output = 1;
 
   disp('System representation demo:')
   num = [5 -1];
   denom = [1 -2 6];
   a = b = c = [];
diff --git a/scripts/control/sysscale.m b/scripts/control/sysscale.m
--- a/scripts/control/sysscale.m
+++ b/scripts/control/sysscale.m
@@ -34,17 +34,17 @@ function sys = sysscale(sys,outscale,ins
 # are not square, then default names will be given to the inputs and/or
 # outputs.
 #
 # A warning message is printed if outscale attempts to add continuous
 # system outputs to discrete system outputs; otherwise yd is set appropriately
 
 # A. S. Hodel August 1995
 # modified by John Ingram 7-15-96
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   if( (nargin < 3) || (nargin > 5)  )
     usage("retsys = sysscale(Asys,output_list,input_list{,inname,outname})");
   elseif (!is_struct(sys))
     error("sys must be a structured system");
   endif
 
   [nn,nz,mm,pp] = sysdimensions(sys);
diff --git a/scripts/control/syssub.m b/scripts/control/syssub.m
--- a/scripts/control/syssub.m
+++ b/scripts/control/syssub.m
@@ -31,17 +31,17 @@ function sys = syssub(Gsys,Hsys)
 #             ----|  Gsys  |---
 #        u   |    ----------  +|         
 #        -----                (_)----> y
 #            |     ________   -|
 #             ----|  Hsys  |---
 #                  --------
 
 # Written by John Ingram July 1996
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   save_val = implicit_str_to_num_ok;	# save for later
   implicit_str_to_num_ok = 1;
 
   if(nargin != 2)
     usage("syssub:  [sys] = syssub(Gsys,Hsys)");
   endif
 
diff --git a/scripts/control/sysupdate.m b/scripts/control/sysupdate.m
--- a/scripts/control/sysupdate.m
+++ b/scripts/control/sysupdate.m
@@ -29,17 +29,17 @@ function sys = sysupdate(sys,opt)
 #     if requested data in sys is already up to date then retsys=sys.
 #
 # conversion to tf or zp exits with an error if the system is
 # mixed continuous/digital
 #
 # see also: tf2sys, ss2sys, zp2sys, sysout, sys2ss, sys2tf, sys2zp
 
 # Written by John Ingram  7-9-96
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   # check for correct number of inputs 
   if (nargin != 2)
     usage("newsys = sysupdate(sys,opt)");
   elseif(! is_struct(sys) )
    error("1st argument must be system data structure")
   elseif(! (strcmp(opt,"tf") + strcmp(opt,"zp") + ...
 	strcmp(opt,"ss") + strcmp(opt,"all")) )
diff --git a/scripts/control/tf2ss.m b/scripts/control/tf2ss.m
--- a/scripts/control/tf2ss.m
+++ b/scripts/control/tf2ss.m
@@ -34,17 +34,17 @@ function [a,b,c,d] = tf2ss(num,den)
   # may contain as many rows as there are outputs of the system 'y'.
   # The state space system matrices obtained from this function will be
   # in controllable canonical form as described in "Modern Control Theory",
   # [Brogan, 1991].
 
 
   # Written by R. Bruce Tenison (June 22, 1994) btenison@eng.auburn.edu
   # mod A S Hodel July, Aug  1995
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
 
   if(nargin != 2)        error("tf2ss: wrong number of input arguments")
   elseif(isempty(num))   error("tf2ss: empty numerator");
   elseif(isempty(den))   error("tf2ss: empy denominator");
   elseif(!is_vector(num)) 
     error(sprintf("num(%dx%d) must be a vector",rows(num),columns(num)));
   elseif(!is_vector(den)) 
     error(sprintf("den(%dx%d) must be a vector",rows(den),columns(den)));
diff --git a/scripts/control/tf2sys.m b/scripts/control/tf2sys.m
--- a/scripts/control/tf2sys.m
+++ b/scripts/control/tf2sys.m
@@ -24,17 +24,17 @@ function outsys = tf2sys(num,den,tsam,in
   #   num, den: coefficients of numerator/denominator polynomials
   #   tsam: sampling interval. default: 0 (continuous time)
   #   inname, outname: input/output signal names (string variables)
   # outputs: sys = system data structure
    
   #  Written by R. Bruce Tenison  July 29, 1994
   #  Name changed to TF2SYS July 1995
   #  updated for new system data structure format July 1996
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
 
   save_val = implicit_str_to_num_ok;
   implicit_str_to_num_ok = 1;
 
   #  Test for the correct number of input arguments
   if ((nargin < 2) || (nargin > 5))
     usage('outsys=tf2sys(num,den[,tsam,inname,outname])');
     return
diff --git a/scripts/control/tf2sysl.m b/scripts/control/tf2sysl.m
--- a/scripts/control/tf2sysl.m
+++ b/scripts/control/tf2sysl.m
@@ -17,17 +17,17 @@
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function vec = tf2sysl(vec)
 # vec = tf2sysl(vec)
 #
 # used internally in tf2sys
 # strip leading zero coefficients to get the true polynomial length
 
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
 while( (length(vec) > 1) & (vec(1) == 0) )
   vec = vec(2:length(vec));
 endwhile
 if(vec(1) == 0)
   warning("tf2sys: polynomial has no nonzero coefficients!")
 endif
 
diff --git a/scripts/control/tf2zp.m b/scripts/control/tf2zp.m
--- a/scripts/control/tf2zp.m
+++ b/scripts/control/tf2zp.m
@@ -18,17 +18,17 @@
  
 function [zer,pol,k] = tf2zp(num,den)
 # Converts transfer functions to poles / zeros.
 #
 # [zer,pol,k] = tf2zp(num,den) returns the zeros and poles of the SISO system
 # defined by num/den.  K is a gain associated with the system zeros.
 
 # Written by A. S. Hodel, etc.
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   if(nargin == 2)
     if(length(den) > 1)          pol = roots(den);
     else                         pol=[];                   endif
     if(length(num) > 1)         zer = roots(num);
     else                        zer=[];                    endif
   else                    error("Incorrect number of input arguments");
   endif
diff --git a/scripts/control/tfout.m b/scripts/control/tfout.m
--- a/scripts/control/tfout.m
+++ b/scripts/control/tfout.m
@@ -23,17 +23,17 @@ function tfout(num,denom,x)
 # print formatted transfer function num(s)/d(s) 
 # to the screen
 # x defaults to the string "s"
 #
 #  SEE ALSO: polyval, polyvalm, poly, roots, conv, deconv, residue, 
 #	filter, polyderiv, polyinteg, polyout
 
 # Written by A. Scottedward Hodel (scotte@eng.auburn.edu) June 1995)
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
   
   save_val = implicit_str_to_num_ok;
   save_empty = empty_list_elements_ok;
   empty_list_elements_ok = implicit_str_to_num_ok = 1;
   
   if (nargin < 2 ) | (nargin > 3) | (nargout != 0 ) 
     usage("tfout(num,denom[,x])");
   endif
diff --git a/scripts/control/tzero.m b/scripts/control/tzero.m
--- a/scripts/control/tzero.m
+++ b/scripts/control/tzero.m
@@ -34,17 +34,17 @@ function [zer, gain] = tzero(A,B,C,D)
   #   zer: transmission zeros of the system
   #   gain: leading coefficient (pole-zero form) of SISO transfer function
   #         returns gain=0 if system is multivariable
   # References:
   # Hodel, "Computation of Zeros with Balancing," 1992 Lin. Alg. Appl.
   
   # R. Bruce Tenison July 4, 1994
   # A. S. Hodel Aug 1995: allow for MIMO and system data structures
-  # $Revision: 1.17 $ 
+  # $Revision: 1.18 $ 
 
   # get A,B,C,D and Asys variables, regardless of initial form
   if(nargin == 4)
     Asys = ss2sys(A,B,C,D);
   elseif( (nargin == 1) && (! is_struct(A)))
     usage("[zer,gain] = tzero(A,B,C,D) or zer = tzero(Asys)");
   elseif(nargin != 1)
     usage("[zer,gain] = tzero(A,B,C,D) or zer = tzero(Asys)");
diff --git a/scripts/control/tzero2.m b/scripts/control/tzero2.m
--- a/scripts/control/tzero2.m
+++ b/scripts/control/tzero2.m
@@ -22,17 +22,17 @@ function zr = tzero2 (a, b, c, d, bal)
 #
 # Compute the transmission zeros of a, b, c, d.
 #
 # bal = balancing option (see balance); default is "B".
 #
 # Needs to incorporate mvzero algorithm to isolate finite zeros.
 
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   if (nargin == 4)
     bal = "B";
   elseif (nargin != 5)
     error ("tzero: illegal number of arguments");
   endif
 
   [n, m, p] = abcddim (a, b, c, d);
diff --git a/scripts/control/ugain.m b/scripts/control/ugain.m
--- a/scripts/control/ugain.m
+++ b/scripts/control/ugain.m
@@ -23,15 +23,15 @@ function outsys = ugain(n)
   # complex systems from simple systems with buildssic.
   # Watch out if you are forming sampled systems since "ugain"
   # does not contain a sampling period.  
   #
   # See also: hinfdemo (MIMO H_infinty example, Boeing 707-321 aircraft model)
 
   # Written by Kai P. Mueller April, 1998
   # Updates
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
 
   if((nargin != 1) || (nargout > 1))
     usage("outsys = ugain(n)")
   endif
   outsys = ss2sys([],[],[],eye(n));
 endfunction
diff --git a/scripts/control/unpacksys.m b/scripts/control/unpacksys.m
--- a/scripts/control/unpacksys.m
+++ b/scripts/control/unpacksys.m
@@ -16,15 +16,15 @@
 # along with Octave; see the file COPYING.  If not, write to the Free 
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function [a,b,c,d] = unpacksys(syst)
   # [a,b,c,d] = unpacksys(sys)
   # Obsolete.  Use sys2ss instead.
 
   # Written by David Clem August 19, 1994
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
 
   warning("unpacksys obsolete; calling sys2ss");
   [a,b,c,d] = sys2ss(syst);
 
 endfunction
 
diff --git a/scripts/control/wgt1o.m b/scripts/control/wgt1o.m
--- a/scripts/control/wgt1o.m
+++ b/scripts/control/wgt1o.m
@@ -25,17 +25,17 @@ function wsys = wgt1o(vl, vh, fc)
 # These function are part of thye augmented plant P (see hinfdemo
 # for an applicattion example).
 #
 # vl = Gain @ low frequencies
 # vh = Gain @ high frequencies
 # fc = Corner frequency (in Hz, *not* in rad/sec)
 
 # Written by Kai P. Mueller September 30, 1997
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   if (nargin != 3)
     usage("wsys = wgt1o(vl, vh, fc)");
   endif
 
   if(nargout > 1)
     usage("wsys = wgt1o(vl, vh, fc)");
   endif
diff --git a/scripts/control/zgfmul.m b/scripts/control/zgfmul.m
--- a/scripts/control/zgfmul.m
+++ b/scripts/control/zgfmul.m
@@ -25,17 +25,17 @@ function y = zgfmul(a,b,c,d,x)
   #
   # References:
   # ZGEP: Hodel, "Computation of Zeros with Balancing," Linear algebra and
   #    its Applications, 1993
   # Generalized CG: Golub and Van Loan, "Matrix Computations, 2nd ed" 1989
   
   # A. S. Hodel July 24 1992
   # Conversion to Octave July 3, 1994
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
   
   [n,m] = size(b);
   [p,m1] = size(c);
   nm = n+m;
   y = zeros(nm+p,1);
 
   # construct F column by column
   for jj=1:n
diff --git a/scripts/control/zgfslv.m b/scripts/control/zgfslv.m
--- a/scripts/control/zgfslv.m
+++ b/scripts/control/zgfslv.m
@@ -17,17 +17,17 @@
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function x = zgfslv(n,m,p,b)
   # x = zgfslv(n,m,p,b)
   # solve system of equations for dense zgep problem
   
   # Written by A. Scotte Hodel
   # Converted to Octave by R Bruce Tenison, July 3, 1994
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
 
   nmp = n+m+p;
   gam1 = (2*n)+m+p;    gam2 = n+p;     gam3 = n+m;
 
   G1 = givens(sqrt(m),-sqrt(p))';
   G2 = givens(m+p,sqrt(n*(m+p)))';
 
   x = b;
diff --git a/scripts/control/zginit.m b/scripts/control/zginit.m
--- a/scripts/control/zginit.m
+++ b/scripts/control/zginit.m
@@ -24,17 +24,17 @@ function zz = zginit(a,b,c,d)
   # called by zgepbal
   # References:
   # ZGEP: Hodel, "Computation of Zeros with Balancing," Linear Algebra and
   #              its Applications, 1993
   # Generalized CG: Golub and Van Loan, "Matrix Computations, 2nd ed" 1989
   
   # A. S. Hodel July 24 1992
   # Conversion to Octave by R. Bruce Tenison, July 3, 1994
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
 
   [nn,mm] = size(b);
   [pp,mm] = size(d);
 
   nmp = nn+mm+pp;
 
   # set up log vector zz
   zz = zeros(nmp,1);
diff --git a/scripts/control/zgpbal.m b/scripts/control/zgpbal.m
--- a/scripts/control/zgpbal.m
+++ b/scripts/control/zgpbal.m
@@ -33,17 +33,17 @@ function [retsys] = zgpbal(Asys)
   # zgpbal should be followed by zgpred
   # References:
   # ZGEP: Hodel, "Computation of Zeros with Balancing," 1992, Linear Algebra
   # and its Applications
   # Generalized CG: Golub and Van Loan, "Matrix Computations, 2nd ed" 1989
   
   # A. S. Hodel July 24 1992
   # Conversion to Octave by R. Bruce Tenison July 3, 1994
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
 
   if( (nargin != 1) | (!is_struct(Asys)))
     usage("retsys = zgpbal(Asys)");
   endif
 
   Asys = sysupdate(Asys,"ss");
   [a,b,c,d] = sys2ss(Asys);
 
diff --git a/scripts/control/zgreduce.m b/scripts/control/zgreduce.m
--- a/scripts/control/zgreduce.m
+++ b/scripts/control/zgreduce.m
@@ -18,17 +18,17 @@
  
 function retsys = zgreduce(Asys,meps)
 # function retsys = zgreduce(Asys,meps)
 # implementation of procedure REDUCE in (Emami-Naeini and Van Dooren, 
 # Automatica, # 1982).
 #
 # used internally in tzero; minimal argument checking performed
 
-#$Revision: 2.0.0.0 $
+#$Revision: 2.0.0.2 $
 # SYS_INTERNAL accesses members of system data structure
 
 is_digital(Asys);		# make sure it's pure digital/continuous
 
 exit_1 = 0;			# exit_1 = 1 or 2 on exit of loop
 
 if(Asys.n + Asys.nz == 0)
   exit_1 = 2;			# there are no finite zeros
diff --git a/scripts/control/zgrownorm.m b/scripts/control/zgrownorm.m
--- a/scripts/control/zgrownorm.m
+++ b/scripts/control/zgrownorm.m
@@ -17,17 +17,17 @@
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
 function [sig, tau] = zgrownorm(mat,meps)
 # function [nonz, zer] = zgrownorm(mat,meps)
 # used internally in tzero
 # returns nonz = number of rows of mat whose two norm exceeds meps
 #         zer = number of rows of mat whose two norm is less than meps
 
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   rownorm = [];
   for ii=1:rows(mat)
     rownorm(ii) = norm(mat(ii,:));
   endfor
   sig = sum(rownorm > meps);
   tau = sum(rownorm <= meps);
 
diff --git a/scripts/control/zgscal.m b/scripts/control/zgscal.m
--- a/scripts/control/zgscal.m
+++ b/scripts/control/zgscal.m
@@ -23,17 +23,17 @@ function x = zgscal(a,b,c,d,z,n,m,p)
   # called by zgepbal
   #
   # References:
   # ZGEP: Hodel, "Computation of Zeros with Balancing," 1992, submitted to  LAA
   # Generalized CG: Golub and Van Loan, "Matrix Computations, 2nd ed" 1989
   
   # A. S. Hodel July 24 1992
   # Conversion to Octave R. Bruce Tenison July 3, 1994
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
 
   #**************************************************************************
   #initialize parameters:
   #  Givens rotations, diagonalized 2x2 block of F, gcg vector initialization
   #**************************************************************************
   nmp = n+m+p;
   
   #x_0 = x_{-1} = 0, r_0 = z
diff --git a/scripts/control/zgsgiv.m b/scripts/control/zgsgiv.m
--- a/scripts/control/zgsgiv.m
+++ b/scripts/control/zgsgiv.m
@@ -18,15 +18,15 @@
  
 function [a,b] = zgsgiv(c,s,a,b)
   # [a,b] = zgsgiv(c,s,a,b)
   # apply givens rotation c,s to row vectors a,b
   # No longer used in zero-balancing (zgpbal); kept for backward compatibility
   
   # A. S. Hodel July 29, 1992
   # Convertion to Octave by R. Bruce Tenison July 3, 1994
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
 
   t1 = c*a + s*b;
   t2 = -s*a + c*b;
   a = t1;
   b = t2;
 endfunction
diff --git a/scripts/control/zgshsr.m b/scripts/control/zgshsr.m
--- a/scripts/control/zgshsr.m
+++ b/scripts/control/zgshsr.m
@@ -19,17 +19,17 @@
 function x = zgshsr(y)
   # x = zgshsr(y)
   # apply householder vector based on e^(m) to 
   # (column vector) y.
   # Called by zgfslv
 
   # A. S. Hodel July 24, 1992
   # Conversion to Octave by R. Bruce Tenison July 3, 1994
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
 
   if(!is_vector(y))
     error(sprintf("y(%dx%d) must be a vector",rows(y),columns(y)));
   endif
   x = vec(y);
   m = length(x);
   if (m>1)
     beta = (1 + sqrt(m))*x(1) + sum(x(2:m));
diff --git a/scripts/control/zp2ss.m b/scripts/control/zp2ss.m
--- a/scripts/control/zp2ss.m
+++ b/scripts/control/zp2ss.m
@@ -34,17 +34,17 @@ function [a,b,c,d] = zp2ss(zer,pol,k)
 # is obtained from a vector of zeros and a vector of poles via the
 # function call [a,b,c,d] = zp2ss(zer,pol,k).  The vectors 'zer' and 
 # 'pol' may either be row or column vectors.  Each zero and pole that
 # has an imaginary part must have a conjugate in the list.
 # The number of poles must at least equal the number of zeros.
 # k is a gain that is associated with the zero vector.
 
 # Written by David Clem August 15, 1994
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 
   sav_val = empty_list_elements_ok;
   empty_list_elements_ok = 1;
 
   if(nargin != 3)
     error("Incorrect number of input arguments");
   endif
  
diff --git a/scripts/control/zp2ssg2.m b/scripts/control/zp2ssg2.m
--- a/scripts/control/zp2ssg2.m
+++ b/scripts/control/zp2ssg2.m
@@ -18,17 +18,17 @@
  
 function [poly,rvals] = zp2ssg2(rvals)
 # [poly,rvals] = zp2ssg2(rvals)
 #
 #  used internally in zp2ss
 # extract 2 values from rvals (if possible) and construct
 # a polynomial with those roots.
 
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 # A. S. Hodel Aug 1996
 
 # locate imaginary roots (if any)
 cidx = find(imag(rvals));
 
 if(!isempty(cidx))
   # select first complex root, omit from cidx
   r1i = cidx(1);      r1 = rvals(r1i);     cidx = complement(r1i,cidx);
diff --git a/scripts/control/zp2sys.m b/scripts/control/zp2sys.m
--- a/scripts/control/zp2sys.m
+++ b/scripts/control/zp2sys.m
@@ -23,17 +23,17 @@ function  outsys = zp2sys (zer,pol,k,tsa
   #   zer: vector of system zeros
   #   pol: vector of system poles
   #   k: scalar leading coefficient
   #   tsam: sampling period. default: 0 (continuous system)
   #   inname, outname: input/output signal names (strings)
   # outputs: sys: system data structure
 
   #  Modified by John Ingram  July 20, 1996  
-  # $Revision: 2.0.0.0 $
+  # $Revision: 2.0.0.2 $
 
   save_val = implicit_str_to_num_ok;	# save for restoring later
   implicit_str_to_num_ok = 1;
 
   #  Test for the correct number of input arguments
   if ((nargin < 3) || (nargin > 6))
     usage("outsys = zp2sys(zer,pol,k[,tsam,inname,outname])");
   endif
diff --git a/scripts/control/zp2tf.m b/scripts/control/zp2tf.m
--- a/scripts/control/zp2tf.m
+++ b/scripts/control/zp2tf.m
@@ -27,17 +27,17 @@ function [num,den] = zp2tf(zer,pol,k)
 # Forms the transfer function num/den from
 # the vectors of poles and zeros.  K is a scalar gain associated with the
 # zeros.
 
 # Find out whether data was entered as a row or a column vector and
 # convert to a column vector if necessary
 # Written by A. S. Hodel with help from students Ingram, McGowan.
 # a.s.hodel@eng.auburn.edu
-# $Revision: 2.0.0.0 $
+# $Revision: 2.0.0.2 $
 #
 
   [rp,cp] = size(pol);
   [rz,cz] = size(zer);
 
   if(!(is_vector(zer) | isempty(zer)) )
     error(sprintf("zer(%dx%d) must be a vector",rz,cz));
   elseif(!(is_vector(pol) | isempty(pol)) )
