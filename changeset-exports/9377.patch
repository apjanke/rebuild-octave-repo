# HG changeset patch
# User Jaroslav Hajek <highegg@gmail.com>
# Date 1245738133 -7200
#      Tue Jun 23 08:22:13 2009 +0200
# Node ID 610bf90fce2a2e2db0b268addaac3c8638b99d0d
# Parent  d58086453171b5a476cbb809b91e3fd4b3a453ce
update unwind_protect usage everywhere

diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,44 @@
+2009-06-23  Jaroslav Hajek  <highegg@gmail.com>
+
+	* DLD-FUNCTIONS/cellfun.cc: Modernize unwind_protect usage.
+	* DLD-FUNCTIONS/daspk.cc: Ditto.
+	* DLD-FUNCTIONS/dasrt.cc: Ditto.
+	* DLD-FUNCTIONS/dassl.cc: Ditto.
+	* DLD-FUNCTIONS/eigs.cc: Ditto.
+	* DLD-FUNCTIONS/lsode.cc: Ditto.
+	* DLD-FUNCTIONS/quad.cc: Ditto.
+	* DLD-FUNCTIONS/rand.cc: Ditto.
+	* debug.cc: Ditto.
+	* dynamic-ld.cc: Ditto.
+	* error.cc: Ditto.
+	* graphics.cc: Ditto.
+	* help.cc: Ditto.
+	* input.cc: Ditto.
+	* load-path.cc: Ditto.
+	* ls-mat4.cc: Ditto.
+	* ls-mat5.cc: Ditto.
+	* mex.cc: Ditto.
+	* oct-hist.cc: Ditto.
+	* octave.cc: Ditto.
+	* ov-builtin.cc: Ditto.
+	* ov-class.cc: Ditto.
+	* ov-fcn-handle.cc: Ditto.
+	* ov-list.cc: Ditto.
+	* ov-mex-fcn.cc: Ditto.
+	* ov-struct.cc: Ditto.
+	* ov-usr-fcn.cc: Ditto.
+	* pager.cc: Ditto.
+	* pr-output.cc: Ditto.
+	* pt-arg-list.cc: Ditto.
+	* pt-eval.cc: Ditto.
+	* toplev.cc: Ditto.
+	* variables.cc: Ditto.
+
 2009-06-22  Jaroslav Hajek  <highegg@gmail.com>
 
 	* unwind-prot.h (unwind_protect): Rewrite.
 	(unwind_protect::protect_var): New class.
 	(unwind_protect::protect_mem): New class.
 	* unwind-prot.cc (unwind_protect): Rewrite.
 	* pt-eval.cc (tree_evaluator::visit_try_catch_command): Delete frame
 	properly.
diff --git a/src/DLD-FUNCTIONS/cellfun.cc b/src/DLD-FUNCTIONS/cellfun.cc
--- a/src/DLD-FUNCTIONS/cellfun.cc
+++ b/src/DLD-FUNCTIONS/cellfun.cc
@@ -384,18 +384,18 @@ cellfun (@@factorial, @{-1,2@},'ErrorHan
           
           retval(0) = result;
         }
       else
         error ("not enough arguments for `isclass'");
     }
   else 
     {
-      unwind_protect::begin_frame ("Fcellfun");
-      unwind_protect_int (buffer_error_messages);
+      unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+      unwind_protect::protect_var (buffer_error_messages);
 
       std::string fcn_name;
       
       if (! func)
 	{
 	  fcn_name = unique_symbol_name ("__cellfun_fcn_");
 	  std::string fname = "function y = ";
 	  fname.append (fcn_name);
@@ -626,17 +626,17 @@ cellfun (@@factorial, @{-1,2@},'ErrorHan
 
 	  if (! fcn_name.empty ())
 	    clear_function (fcn_name);
 
 	  if (! err_name.empty ())
 	    clear_function (err_name);
 	}
 
-      unwind_protect::run_frame ("Fcellfun");
+      unwind_protect::run_frame (uwp_frame);
     }
 
   return retval;
 }
 
 /*
 
 %% Test function to check the "Errorhandler" option
diff --git a/src/DLD-FUNCTIONS/daspk.cc b/src/DLD-FUNCTIONS/daspk.cc
--- a/src/DLD-FUNCTIONS/daspk.cc
+++ b/src/DLD-FUNCTIONS/daspk.cc
@@ -150,17 +150,17 @@ daspk_user_jacobian (const ColumnVector&
     }
 
   return retval;
 }
 
 #define DASPK_ABORT() \
   do \
     { \
-      unwind_protect::run_frame ("Fdaspk"); \
+      unwind_protect::run_frame (uwp_frame); \
       return retval; \
     } \
   while (0)
 
 #define DASPK_ABORT1(msg) \
   do \
     { \
       ::error ("daspk: " msg); \
@@ -275,19 +275,19 @@ parameters for @code{daspk}.\n\
 @seealso{dassl}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   warned_fcn_imaginary = false;
   warned_jac_imaginary = false;
 
-  unwind_protect::begin_frame ("Fdaspk");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
-  unwind_protect_int (call_depth);
+  unwind_protect::protect_var (call_depth);
   call_depth++;
 
   if (call_depth > 1)
     DASPK_ABORT1 ("invalid recursive call");
 
   int nargin = args.length ();
 
   if (nargin > 3 && nargin < 6)
@@ -475,17 +475,17 @@ parameters for @code{daspk}.\n\
 	      if (nargout < 3)
 		error ("daspk: %s", msg.c_str ());
 	    }
 	}
     }
   else
     print_usage ();
 
-  unwind_protect::run_frame ("Fdaspk");
+  unwind_protect::run_frame (uwp_frame);
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/DLD-FUNCTIONS/dasrt.cc b/src/DLD-FUNCTIONS/dasrt.cc
--- a/src/DLD-FUNCTIONS/dasrt.cc
+++ b/src/DLD-FUNCTIONS/dasrt.cc
@@ -185,17 +185,17 @@ dasrt_user_j (const ColumnVector& x, con
     }
 
   return retval;
 }
 
 #define DASRT_ABORT \
   do \
     { \
-      unwind_protect::run_frame ("Fdasrt"); \
+      unwind_protect::run_frame (uwp_frame); \
       return retval; \
     } \
   while (0)
 
 #define DASRT_ABORT1(msg) \
   do \
     { \
       ::error ("dasrt: " msg); \
@@ -348,32 +348,32 @@ parameters for @code{dasrt}.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   warned_fcn_imaginary = false;
   warned_jac_imaginary = false;
   warned_cf_imaginary = false;
 
-  unwind_protect::begin_frame ("Fdasrt");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
-  unwind_protect_int (call_depth);
+  unwind_protect::protect_var (call_depth);
   call_depth++;
 
   if (call_depth > 1)
     DASRT_ABORT1 ("invalid recursive call");
 
   int argp = 0;
 
   int nargin = args.length ();
 
   if (nargin < 4 || nargin > 6)
     {
       print_usage ();
-      unwind_protect::run_frame ("Fdasrt");
+      unwind_protect::run_frame (uwp_frame);
       return retval;
     }
 
   std::string fcn_name, fname, jac_name, jname;
   dasrt_f = 0;
   dasrt_j = 0;
   dasrt_cf = 0;
 
@@ -582,17 +582,17 @@ parameters for @code{dasrt}.\n\
 	  retval(1) = Matrix ();
 	  retval(0) = Matrix ();
 
 	  if (nargout < 4)
 	    error ("dasrt: %s", msg.c_str ());
 	}
     }
 
-  unwind_protect::run_frame ("Fdasrt");
+  unwind_protect::run_frame (uwp_frame);
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/DLD-FUNCTIONS/dassl.cc b/src/DLD-FUNCTIONS/dassl.cc
--- a/src/DLD-FUNCTIONS/dassl.cc
+++ b/src/DLD-FUNCTIONS/dassl.cc
@@ -150,17 +150,17 @@ dassl_user_jacobian (const ColumnVector&
     }
 
   return retval;
 }
 
 #define DASSL_ABORT() \
   do \
     { \
-      unwind_protect::run_frame ("Fdassl"); \
+      unwind_protect::run_frame (uwp_frame); \
       return retval; \
     } \
   while (0)
 
 #define DASSL_ABORT1(msg) \
   do \
     { \
       ::error ("dassl: " msg); \
@@ -280,19 +280,19 @@ parameters for @code{dassl}.\n\
 @seealso{daspk, dasrt, lsode}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   warned_fcn_imaginary = false;
   warned_jac_imaginary = false;
 
-  unwind_protect::begin_frame ("Fdassl");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
-  unwind_protect_int (call_depth);
+  unwind_protect::protect_var (call_depth);
   call_depth++;
 
   if (call_depth > 1)
     DASSL_ABORT1 ("invalid recursive call");
 
   int nargin = args.length ();
 
   if (nargin > 3 && nargin < 6 && nargout < 5)
@@ -481,17 +481,17 @@ parameters for @code{dassl}.\n\
 	      if (nargout < 3)
 		error ("dassl: %s", msg.c_str ());
 	    }
 	}
     }
   else
     print_usage ();
 
-  unwind_protect::run_frame ("Fdassl");
+  unwind_protect::run_frame (uwp_frame);
 
   return retval;
 }
 
 /*
 
 %% dassl-1.m
 %%
diff --git a/src/DLD-FUNCTIONS/eigs.cc b/src/DLD-FUNCTIONS/eigs.cc
--- a/src/DLD-FUNCTIONS/eigs.cc
+++ b/src/DLD-FUNCTIONS/eigs.cc
@@ -341,27 +341,27 @@ K Maschhoff, D Sorensen and C Yang.  For
   octave_idx_type p = -1;
   ColumnVector resid;
   ComplexColumnVector cresid;
   octave_idx_type info = 1;
   char bmat = 'I';
 
   warned_imaginary = false;
 
-  unwind_protect::begin_frame ("Feigs");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
-  unwind_protect_int (call_depth);
+  unwind_protect::protect_var (call_depth);
   call_depth++;
 
   if (call_depth > 1)
     {
       error ("eigs: invalid recursive call");
       if (fcn_name.length())
 	clear_function (fcn_name);
-      unwind_protect::run_frame ("Feigs");
+      unwind_protect::run_frame (uwp_frame);
       return retval;
     }
 
   if (nargin == 0)
     print_usage ();
   else if (args(0).is_function_handle () || args(0).is_inline_function ()
 	   || args(0).is_string ())
     {
@@ -736,17 +736,17 @@ K Maschhoff, D Sorensen and C Yang.  For
       else if (nconv < k)
 	warning ("eigs: Only %d of the %d requested eigenvalues converged", 
 		 nconv, k);
     }
 
   if (! fcn_name.empty ())
     clear_function (fcn_name);
 
-  unwind_protect::run_frame ("Feigs");
+  unwind_protect::run_frame (uwp_frame);
 #else
   error ("eigs: not available in this version of Octave");
 #endif
 
   return retval;
 }
 
 /* #### SPARSE MATRIX VERSIONS #### */
diff --git a/src/DLD-FUNCTIONS/lsode.cc b/src/DLD-FUNCTIONS/lsode.cc
--- a/src/DLD-FUNCTIONS/lsode.cc
+++ b/src/DLD-FUNCTIONS/lsode.cc
@@ -136,17 +136,17 @@ lsode_user_jacobian (const ColumnVector&
     }
 
   return retval;
 }
 
 #define LSODE_ABORT() \
   do \
     { \
-      unwind_protect::run_frame ("Flsode"); \
+      unwind_protect::run_frame (uwp_frame); \
       return retval; \
     } \
   while (0)
  
 #define LSODE_ABORT1(msg) \
   do \
     { \
       ::error ("lsode: " msg); \
@@ -275,19 +275,19 @@ parameters for @code{lsode}.\n\
 @seealso{daspk, dassl, dasrt}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   warned_fcn_imaginary = false;
   warned_jac_imaginary = false;
 
-  unwind_protect::begin_frame ("Flsode");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
-  unwind_protect_int (call_depth);
+  unwind_protect::protect_var (call_depth);
   call_depth++;
 
   if (call_depth > 1)
     LSODE_ABORT1 ("invalid recursive call");
 
   int nargin = args.length ();
 
   if (nargin > 2 && nargin < 5 && nargout < 4)
@@ -468,17 +468,17 @@ parameters for @code{lsode}.\n\
 	      if (nargout < 2)
 		error ("lsode: %s", msg.c_str ());
 	    }
 	}
     }
   else
     print_usage ();
 
-  unwind_protect::run_frame ("Flsode");
+  unwind_protect::run_frame (uwp_frame);
 
   return retval;
 }
 
 /*
 
 %% dassl-1.m
 %%
diff --git a/src/DLD-FUNCTIONS/quad.cc b/src/DLD-FUNCTIONS/quad.cc
--- a/src/DLD-FUNCTIONS/quad.cc
+++ b/src/DLD-FUNCTIONS/quad.cc
@@ -148,17 +148,17 @@ quad_float_user_function (float x)
   return retval;
 }
 
 #define QUAD_ABORT() \
   do \
     { \
       if (fcn_name.length()) \
 	clear_function (fcn_name); \
-      unwind_protect::run_frame ("Fquad"); \
+      unwind_protect::run_frame (uwp_frame); \
       return retval; \
     } \
   while (0)
 
 #define QUAD_ABORT1(msg) \
   do \
     { \
       ::error ("quad: " msg); \
@@ -216,19 +216,19 @@ cannot be called recursively.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   std::string fcn_name;
 
   warned_imaginary = false;
 
-  unwind_protect::begin_frame ("Fquad");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
-  unwind_protect_int (call_depth);
+  unwind_protect::protect_var (call_depth);
   call_depth++;
 
   if (call_depth > 1)
     QUAD_ABORT1 ("invalid recursive call");
 
   int nargin = args.length ();
 
   if (nargin > 2 && nargin < 6 && nargout < 5)
@@ -466,17 +466,17 @@ cannot be called recursively.\n\
 	}
 
       if (fcn_name.length())
 	clear_function (fcn_name);
     }
   else
     print_usage ();
 
-  unwind_protect::run_frame ("Fquad");
+  unwind_protect::run_frame (uwp_frame);
 
   return retval;
 }
 
 /*
 
 %!function y = f (x) 
 %! y = x + 1;
diff --git a/src/DLD-FUNCTIONS/rand.cc b/src/DLD-FUNCTIONS/rand.cc
--- a/src/DLD-FUNCTIONS/rand.cc
+++ b/src/DLD-FUNCTIONS/rand.cc
@@ -485,33 +485,33 @@ J. Statistical Software, vol 5, 2000,\n\
 \n\
 @seealso{rand, rande, randg, randp}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
-  unwind_protect::begin_frame ("randn");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
   // This relies on the fact that elements are popped from the unwind
   // stack in the reverse of the order they are pushed
   // (i.e. current_distribution will be reset before calling
   // reset_rand_generator()).
 
   unwind_protect::add (reset_rand_generator, 0);
-  unwind_protect_str (current_distribution);
+  unwind_protect::protect_var (current_distribution);
 
   current_distribution = "normal";
 
   octave_rand::distribution (current_distribution);
 
   retval = do_rand (args, nargin, "randn");
 
-  unwind_protect::run_frame ("randn");
+  unwind_protect::run_frame (uwp_frame);
 
   return retval;
 }
 
 /*
 %!test
 %! % Test fixed state
 %! randn("state",1);
@@ -558,33 +558,33 @@ J. Statistical Software, vol 5, 2000,\n\
 @url{http://www.jstatsoft.org/v05/i08/})\n\
 @seealso{rand, randn, randg, randp}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
-  unwind_protect::begin_frame ("rande");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
   // This relies on the fact that elements are popped from the unwind
   // stack in the reverse of the order they are pushed
   // (i.e. current_distribution will be reset before calling
   // reset_rand_generator()).
 
   unwind_protect::add (reset_rand_generator, 0);
-  unwind_protect_str (current_distribution);
+  unwind_protect::protect_var (current_distribution);
 
   current_distribution = "exponential";
 
   octave_rand::distribution (current_distribution);
 
   retval = do_rand (args, nargin, "rande");
 
-  unwind_protect::run_frame ("rande");
+  unwind_protect::run_frame (uwp_frame);
 
   return retval;
 }
 
 /*
 %!test
 %! % Test fixed state
 %! rande("state",1);
@@ -690,33 +690,33 @@ r = r / sum (r)\n\
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 1)
     error ("randg: insufficient arguments");
   else
     {
-      unwind_protect::begin_frame ("randg");
+      unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
       // This relies on the fact that elements are popped from the unwind
       // stack in the reverse of the order they are pushed
       // (i.e. current_distribution will be reset before calling
       // reset_rand_generator()).
 
       unwind_protect::add (reset_rand_generator, 0);
-      unwind_protect_str (current_distribution);
+      unwind_protect::protect_var (current_distribution);
 
       current_distribution = "gamma";
 
       octave_rand::distribution (current_distribution);
 
       retval = do_rand (args, nargin, "randg", true);
 
-      unwind_protect::run_frame ("randg");
+      unwind_protect::run_frame (uwp_frame);
     }
 
   return retval;
 }
 
 /*
 %!test
 %! randg("state",12)
@@ -904,33 +904,33 @@ D 50 p1284, 1994\n\
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 1)
     error ("randp: insufficient arguments");
   else
     {
-      unwind_protect::begin_frame ("randp");
+      unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
       // This relies on the fact that elements are popped from the unwind
       // stack in the reverse of the order they are pushed
       // (i.e. current_distribution will be reset before calling
       // reset_rand_generator()).
 
       unwind_protect::add (reset_rand_generator, 0);
-      unwind_protect_str (current_distribution);
+      unwind_protect::protect_var (current_distribution);
 
       current_distribution = "poisson";
 
       octave_rand::distribution (current_distribution);
 
       retval = do_rand (args, nargin, "randp", true);
 
-      unwind_protect::run_frame ("randp");
+      unwind_protect::run_frame (uwp_frame);
     }
 
   return retval;
 }
 
 /*
 %!test
 %! randp("state",12)
diff --git a/src/debug.cc b/src/debug.cc
--- a/src/debug.cc
+++ b/src/debug.cc
@@ -845,17 +845,17 @@ DEFUN (dbstack, args, nargout,
 @deftypefn {Loadable Function} {[@var{stack}, @var{idx}]} dbstack (@var{n})\n\
 Print or return current stack information.  With optional argument\n\
 @var{n}, omit the @var{n} innermost stack frames.\n\
 @seealso{dbclear, dbstatus, dbstop}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  unwind_protect::begin_frame ("Fdbstack");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
   octave_idx_type curr_frame = -1;
 
   size_t nskip = 0;
 
   if (args.length () == 1)
     {
       int n = 0;
@@ -909,17 +909,17 @@ Print or return current stack informatio
 	}
       else
 	{
 	  retval(1) = curr_frame < 0 ? 1 : curr_frame + 1;
 	  retval(0) = stk;
 	}
     }
 
-  unwind_protect::run_frame ("Fdbstack");
+  unwind_protect::run_frame (uwp_frame);
 
   return retval;
 }
 
 static void
 do_dbupdown (const octave_value_list& args, const std::string& who)
 {
   int n = 1;
diff --git a/src/dynamic-ld.cc b/src/dynamic-ld.cc
--- a/src/dynamic-ld.cc
+++ b/src/dynamic-ld.cc
@@ -325,19 +325,19 @@ clear (octave_shlib& oct_file)
 
 octave_function *
 octave_dynamic_loader::do_load_oct (const std::string& fcn_name,
 				    const std::string& file_name,
 				    bool relative)
 {
   octave_function *retval = 0;
 
-  unwind_protect::begin_frame ("octave_dynamic_loader::do_load");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
-  unwind_protect_bool (octave_dynamic_loader::doing_load);
+  unwind_protect::protect_var (octave_dynamic_loader::doing_load);
 
   doing_load = true;
 
   octave_shlib oct_file = octave_shlib_list::find_file (file_name);
 
   if (oct_file && oct_file.is_out_of_date ())
     clear (oct_file);
 
@@ -380,31 +380,31 @@ octave_dynamic_loader::do_load_oct (cons
 			 fcn_name.c_str ());
 	    }
 	}
       else
 	::error ("%s is not a valid shared library",
 		 file_name.c_str ());
     }
   
-  unwind_protect::run_frame ("octave_dynamic_loader::do_load");
+  unwind_protect::run_frame (uwp_frame);
 
   return retval;
 }
 
 octave_function *
 octave_dynamic_loader::do_load_mex (const std::string& fcn_name,
 				    const std::string& file_name,
 				    bool relative)
 {
   octave_function *retval = 0;
 
-  unwind_protect::begin_frame ("octave_dynamic_loader::do_load");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
-  unwind_protect_bool (octave_dynamic_loader::doing_load);
+  unwind_protect::protect_var (octave_dynamic_loader::doing_load);
 
   doing_load = true;
 
   octave_shlib mex_file = octave_shlib_list::find_file (file_name);
 
   if (mex_file && mex_file.is_out_of_date ())
     clear (mex_file);
 
@@ -456,17 +456,17 @@ octave_dynamic_loader::do_load_mex (cons
 	    ::error ("failed to install .mex file function `%s'",
 		     fcn_name.c_str ());
   	}
       else
 	::error ("%s is not a valid shared library",
 		 file_name.c_str ());
     }
 
-  unwind_protect::run_frame ("octave_dynamic_loader::do_load");
+  unwind_protect::run_frame (uwp_frame);
 
   return retval;
 }
 
 bool
 octave_dynamic_loader::do_remove_oct (const std::string& fcn_name,
 				      octave_shlib& shl)
 {
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -448,17 +448,17 @@ error_2 (const char *id, const char *fmt
   int init_state = error_state;
 
   error_1 (std::cerr, "error", id, fmt, args);
 
   if ((interactive || forced_interactive)
       && Vdebug_on_error && init_state == 0
       && octave_call_stack::caller_user_code ())
     {
-      unwind_protect_bool (Vdebug_on_error);
+      unwind_protect::protect_var (Vdebug_on_error);
       Vdebug_on_error = false;
 
       error_state = 0;
 
       pr_where ("error");
 
       do_keyboard (octave_value_list ());
 
@@ -609,17 +609,17 @@ warning_1 (const char *id, const char *f
 	pr_where ("warning");
 
       warning_state = 1;
 
       if ((interactive || forced_interactive)
 	  && Vdebug_on_warning
 	  && octave_call_stack::caller_user_code ())
 	{
-	  unwind_protect_bool (Vdebug_on_warning);
+	  unwind_protect::protect_var (Vdebug_on_warning);
 	  Vdebug_on_warning = false;
 
 	  do_keyboard (octave_value_list ());
 
 	  unwind_protect::run ();
 	}
     }
 }
@@ -1446,19 +1446,19 @@ set to their default values.\n\
 \n\
 If @code{lasterror} is called with the argument 'reset', all values take\n\
 their default values.\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length();
 
-  unwind_protect::begin_frame ("Flasterror");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
-  unwind_protect_int (error_state);
+  unwind_protect::protect_var (error_state);
   error_state = 0;
 
   if (nargin < 2)
     {
       Octave_map err;
 
       err.assign ("message", Vlast_error_message);
       err.assign ("identifier", Vlast_error_id);
@@ -1553,34 +1553,34 @@ their default values.\n\
 	}
 
       if (! error_state)
 	retval = err;
     }
   else
     print_usage ();
 
-  unwind_protect::run_frame ("Flasterror");
+  unwind_protect::run_frame (uwp_frame);
 
   return retval;  
 }
 
 DEFUN (lasterr, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{msg}, @var{msgid}] =} lasterr (@var{msg}, @var{msgid})\n\
 Without any arguments, return the last error message.  With one\n\
 argument, set the last error message to @var{msg}.  With two arguments,\n\
 also set the last message identifier.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  unwind_protect::begin_frame ("Flasterr");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
-  unwind_protect_int (error_state);
+  unwind_protect::protect_var (error_state);
   error_state = 0;
 
   int argc = args.length () + 1;
 
   if (argc < 4)
     {
       string_vector argv = args.make_argv ("lasterr");
 
@@ -1602,17 +1602,17 @@ also set the last message identifier.\n\
 	    }
 	}
       else
 	error ("lasterr: expecting arguments to be character strings");
     }
   else
     print_usage ();
 
-  unwind_protect::run_frame ("Flasterr");
+  unwind_protect::run_frame (uwp_frame);
 
   return retval;  
 }
 
 // For backward compatibility.
 DEFALIAS (error_text, lasterr);
 DEFALIAS (__error_text__, lasterr);
 
diff --git a/src/graphics.cc b/src/graphics.cc
--- a/src/graphics.cc
+++ b/src/graphics.cc
@@ -1782,26 +1782,26 @@ base_properties::get_property_dynamic (c
     return it->second;
 }
 
 bool
 base_properties::has_property (const caseless_str& name)
 {
   property p;
 
-  unwind_protect::begin_frame("base_properties::has_property");
-
-  unwind_protect_bool (discard_error_messages);
-  unwind_protect_int (error_state);
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+
+  unwind_protect::protect_var (discard_error_messages);
+  unwind_protect::protect_var (error_state);
 
   discard_error_messages = true;
 
   p = get_property (name);
 
-  unwind_protect::run_frame ("base_properties::has_property");
+  unwind_protect::run_frame (uwp_frame);
 
   return (p.ok ());
 }
 
 void
 base_properties::remove_child (const graphics_handle& h)
 {
   octave_idx_type k = -1;
@@ -3633,17 +3633,17 @@ axes::update_axis_limits (const std::str
 	  limits(0) = min_val;
 	  limits(1) = max_val;
 
 	  update_type = 'a';
 	}
 
     }
 
-  unwind_protect_bool (updating_axis_limits);
+  unwind_protect::protect_var (updating_axis_limits);
   updating_axis_limits = true;
 
   switch (update_type)
     {
     case 'x':
       xproperties.set_xlim (limits);
       xproperties.set_xlimmode ("auto");
       xproperties.update_xlim ();
@@ -4184,17 +4184,17 @@ gh_manager::do_execute_callback (const g
   octave_function *fcn = 0;
 
   args(0) = h.as_octave_value ();
   if (data.is_defined ())
     args(1) = data;
   else
     args(1) = Matrix ();
 
-  unwind_protect::begin_frame ("execute_callback");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
   unwind_protect::add (gh_manager::restore_gcbo);
 
   if (true)
     {
       gh_manager::autolock guard;
   
       callback_objects.push_front (get_object (h));
       xset_gcbo (h);
@@ -4235,17 +4235,17 @@ gh_manager::do_execute_callback (const g
 	     nm.c_str ());
     }
 
   if (fcn && ! error_state)
     feval (fcn, args);
   
   END_INTERRUPT_WITH_EXCEPTIONS;
 
-  unwind_protect::run_frame ("execute_callback");
+  unwind_protect::run_frame (uwp_frame);
 }
 
 void
 gh_manager::do_post_event (const graphics_event& e)
 {
   event_queue.push_back (e);
 
   command_editor::add_event_hook (gh_manager::process_events);
@@ -5010,20 +5010,20 @@ undocumented.\n\
 {
   static int drawnow_executing = 0;
   static bool __go_close_all_registered__ = false;
 
   octave_value retval;
 
   gh_manager::lock ();
 
-  unwind_protect::begin_frame ("Fdrawnow");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
   unwind_protect::add (clear_drawnow_request);
 
-  unwind_protect_int (drawnow_executing);
+  unwind_protect::protect_var (drawnow_executing);
 
   if (++drawnow_executing <= 1)
     {
       if (! __go_close_all_registered__)
 	{
 	  octave_add_atexit_function ("__go_close_all__");
 
 	  __go_close_all_registered__ = true;
@@ -5148,17 +5148,17 @@ undocumented.\n\
 	    }
 	  else
 	    error ("drawnow: invalid terminal, expected a string value");
 	}
       else
 	print_usage ();
     }
 
-  unwind_protect::run_frame ("Fdrawnow");
+  unwind_protect::run_frame (uwp_frame);
 
   gh_manager::unlock ();
 
   return retval;
 }
 
 DEFUN (addlistener, args, ,
    "-*- texinfo -*-\n\
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -661,17 +661,17 @@ raw_help_from_symbol_table (const std::s
 
 static bool
 raw_help_from_file (const std::string& nm, std::string& h, 
 		    std::string& file, bool& symbol_found)
 {
   bool retval = false;
 
   // FIXME -- this is a bit of a kluge...
-  unwind_protect_bool (reading_script_file);
+  unwind_protect::protect_var (reading_script_file);
   reading_script_file = true;
 
   h = get_help_from_file (nm, symbol_found, file);
 
   unwind_protect::run ();
 
   if (h.length () > 0)
     retval = true;
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -647,29 +647,29 @@ get_debug_input (const std::string& prom
   if (! msg.empty ())
     {
       if (! Vgud_mode)
 	std::cerr << "keyboard: ";
 
       std::cerr << msg << std::endl;
     }
 
-  unwind_protect::begin_frame ("get_debug_input");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
-  unwind_protect_str (VPS1);
+  unwind_protect::protect_var (VPS1);
   VPS1 = prompt;
 
   while (Vdebugging)
     {
       reset_error_handler ();
 
       reset_parser ();
 
       // Save current value of global_command.
-      unwind_protect_ptr (global_command);
+      unwind_protect::protect_var (global_command);
 
       // Do this with an unwind-protect cleanup function so that the
       // forced variables will be unmarked in the event of an interrupt.
       symbol_table::scope_id scope = symbol_table::top_scope ();
       unwind_protect::add (symbol_table::unmark_forced_variables, &scope);
 
       // This is the same as yyparse in parse.y.
       int retval = octave_parse ();
@@ -696,17 +696,17 @@ get_debug_input (const std::string& prom
       unwind_protect::run ();
 
       // Restore previous value of global_command.
       unwind_protect::run ();
 
       OCTAVE_QUIT;
     }
 
-  unwind_protect::run_frame ("get_debug_input");
+  unwind_protect::run_frame (uwp_frame);
 }
 
 // If the user simply hits return, this will produce an empty matrix.
 
 static octave_value_list
 get_user_input (const octave_value_list& args, int nargout)
 {
   octave_value_list retval;
@@ -892,43 +892,43 @@ octave_value
 do_keyboard (const octave_value_list& args)
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   assert (nargin == 0 || nargin == 1);
 
-  unwind_protect::begin_frame ("do_keyboard");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
   // FIXME -- we shouldn't need both the
   // command_history object and the
   // Vsaving_history variable...
   command_history::ignore_entries (false);
 
   unwind_protect::add (restore_command_history, 0);
 
-  unwind_protect_bool (Vsaving_history);
-  unwind_protect_bool (Vdebugging);
+  unwind_protect::protect_var (Vsaving_history);
+  unwind_protect::protect_var (Vdebugging);
 
   saved_frame = octave_call_stack::current_frame ();
   unwind_protect::add (restore_frame);
-  unwind_protect_size_t (saved_frame);
+  unwind_protect::protect_var (saved_frame);
 
   Vsaving_history = true;
   Vdebugging = true;
 
   std::string prompt = "debug> ";
   if (nargin > 0)
     prompt = args(0).string_value ();
 
   if (! error_state)
     get_debug_input (prompt);
 
-  unwind_protect::run_frame ("do_keyboard");
+  unwind_protect::run_frame (uwp_frame);
 
   return retval;
 }
 
 DEFUN (keyboard, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} keyboard ()\n\
 @deftypefnx {Built-in Function} {} keyboard (@var{prompt})\n\
@@ -948,17 +948,17 @@ If @code{keyboard} is invoked without ar
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 0 || nargin == 1)
     {
       saved_frame = octave_call_stack::current_frame ();
       unwind_protect::add (restore_frame);
-      unwind_protect_size_t (saved_frame);
+      unwind_protect::protect_var (saved_frame);
 
       // Skip the frame assigned to the keyboard function.
       octave_call_stack::goto_frame (1);
 
       do_keyboard (args);
 
       unwind_protect::run ();
     }
diff --git a/src/load-path.cc b/src/load-path.cc
--- a/src/load-path.cc
+++ b/src/load-path.cc
@@ -552,17 +552,17 @@ split_path (const std::string& p)
 
 void
 load_path::do_set (const std::string& p, bool warn)
 {
   std::list<std::string> elts = split_path (p);
 
   // Temporarily disable add hook.
 
-  unwind_protect_fptr (add_hook);
+  unwind_protect::protect_var (add_hook);
 
   add_hook = 0;
 
   do_clear ();
 
   for (std::list<std::string>::const_iterator i = elts.begin ();
        i != elts.end ();
        i++)
@@ -1776,30 +1776,30 @@ genpath (const std::string& dirname, con
 
 static void
 execute_pkg_add_or_del (const std::string& dir,
 			const std::string& script_file)
 {
   if (! octave_interpreter_ready)
     return;
 
-  unwind_protect::begin_frame ("execute_pkg_add_or_del");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
-  unwind_protect_bool (input_from_startup_file);
+  unwind_protect::protect_var (input_from_startup_file);
 
   input_from_startup_file = true;
 
   std::string file = file_ops::concat (dir, script_file);
 
   file_stat fs (file);
 
   if (fs.exists ())
     source_file (file, "base");
 
-  unwind_protect::run_frame ("execute_pkg_add_or_del");
+  unwind_protect::run_frame (uwp_frame);
 }
 
 void
 execute_pkg_add (const std::string& dir)
 {
   execute_pkg_add_or_del (dir, "PKG_ADD");
 }
 
diff --git a/src/ls-mat4.cc b/src/ls-mat4.cc
--- a/src/ls-mat4.cc
+++ b/src/ls-mat4.cc
@@ -487,17 +487,17 @@ save_mat_binary_data (std::ostream& os, 
 
   int32_t name_len = name.length () + 1;
 
   os.write (reinterpret_cast<char *> (&name_len), 4);
   os << name << '\0';
 
   if (tc.is_string ())
     {
-      unwind_protect::begin_frame ("save_mat_binary_data");
+      unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
       charMatrix chm = tc.char_matrix_value ();
 
       octave_idx_type nrow = chm.rows ();
       octave_idx_type ncol = chm.cols ();
 	
       OCTAVE_LOCAL_BUFFER (double, buf, ncol*nrow);
 	
@@ -506,17 +506,17 @@ save_mat_binary_data (std::ostream& os, 
 	  std::string tstr = chm.row_as_string (i);
 	  const char *s = tstr.data ();
 	  
 	  for (octave_idx_type j = 0; j < ncol; j++)
 	    buf[j*nrow+i] = static_cast<double> (*s++ & 0x00FF);
        	}
       os.write (reinterpret_cast<char *> (buf), nrow*ncol*sizeof(double));
       
-      unwind_protect::run_frame ("save_mat_binary_data");
+      unwind_protect::run_frame (uwp_frame);
     }
   else if (tc.is_range ())
     {
       Range r = tc.range_value ();
       double base = r.base ();
       double inc = r.inc ();
       octave_idx_type nel = r.nelem ();
       for (octave_idx_type i = 0; i < nel; i++)
diff --git a/src/ls-mat5.cc b/src/ls-mat5.cc
--- a/src/ls-mat5.cc
+++ b/src/ls-mat5.cc
@@ -864,17 +864,17 @@ read_mat5_binary_element (std::istream& 
 	    Octave_map m2 = m1.contents("workspace")(0).map_value();
 	    uint32NDArray MCOS = m2.contents("MCOS")(0).uint32_array_value();
 	    octave_idx_type off = static_cast<octave_idx_type>(MCOS(4).double_value ());
 	    m2 = subsys_ov.map_value();
 	    m2 = m2.contents("MCOS")(0).map_value();
 	    tc2 = m2.contents("MCOS")(0).cell_value()(1 + off).cell_value()(1);
 	    m2 = tc2.map_value();
 
-	    unwind_protect::begin_frame ("anon_mat5_load");
+	    unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
 	    // Set up temporary scope to use for evaluating the text
 	    // that defines the anonymous function.
 
 	    symbol_table::scope_id local_scope = symbol_table::alloc_scope ();
 	    unwind_protect::add (symbol_table::erase_scope, &local_scope);
 
 	    symbol_table::set_scope (local_scope);
@@ -914,17 +914,17 @@ read_mat5_binary_element (std::istream& 
 		  }
 	      }
 	    else
 	      {
 		error ("load: failed to load anonymous function handle");
 		goto skip_ahead;
 	      }
 
-	    unwind_protect::run_frame ("anon_mat5_load");
+	    unwind_protect::run_frame (uwp_frame);
 	  }
 	else
 	  {
 	    error ("load: invalid function handle type");
 	    goto skip_ahead;
 	  }
       }
       break;
diff --git a/src/mex.cc b/src/mex.cc
--- a/src/mex.cc
+++ b/src/mex.cc
@@ -3033,20 +3033,20 @@ call_mex (bool have_fmex, void *f, const
   for (int i = 0; i < nargin; i++)
     argin[i] = 0;
 
   int nout = nargout == 0 ? 1 : nargout;
   OCTAVE_LOCAL_BUFFER (mxArray *, argout, nout);
   for (int i = 0; i < nout; i++)
     argout[i] = 0;
 
-  unwind_protect::begin_frame ("call_mex");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
   // Save old mex pointer.
-  unwind_protect_ptr (mex_context);
+  unwind_protect::protect_var (mex_context);
 
   mex context (curr_mex_fcn);
 
   unwind_protect::add (mex::cleanup, static_cast<void *> (&context));
 
   for (int i = 0; i < nargin; i++)
     argin[i] = context.make_value (args(i));
 
@@ -3085,17 +3085,17 @@ call_mex (bool have_fmex, void *f, const
 
       retval.resize (nargout);
 
       for (int i = 0; i < nargout; i++)
 	retval(i) = mxArray::as_octave_value (argout[i]);
     }
 
   // Clean up mex resources.
-  unwind_protect::run_frame ("call_mex");
+  unwind_protect::run_frame (uwp_frame);
 
   return retval;
 }
 
 // C interface to mex functions:
 
 const char *
 mexFunctionName (void)
@@ -3265,17 +3265,17 @@ mexGetVariable (const char *space, const
   octave_value val;
 
   if (! strcmp (space, "global"))
     val = get_global_value (name);
   else
     {
       // FIXME -- should this be in variables.cc?
 
-      unwind_protect::begin_frame ("mexGetVariable");
+      unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
       bool caller = ! strcmp (space, "caller");
       bool base = ! strcmp (space, "base");
 
       if (caller || base)
 	{
 	  if (caller)
 	    octave_call_stack::goto_caller_frame ();
@@ -3285,17 +3285,17 @@ mexGetVariable (const char *space, const
 	  if (! error_state)
 	    unwind_protect::add (octave_call_stack::unwind_pop);
 
 	  val = symbol_table::varval (name);
 	}
       else
 	mexErrMsgTxt ("mexGetVariable: symbol table does not exist");
 
-      unwind_protect::run_frame ("mexGetVariable");
+      unwind_protect::run_frame (uwp_frame);
     }
 
   if (val.is_defined ())
     {
       retval = mex_context->make_value (val);
 
       retval->set_name (name);
     }
@@ -3325,17 +3325,17 @@ mexPutVariable (const char *space, const
     return 1;
 
   if (! strcmp (space, "global"))
     set_global_value (name, mxArray::as_octave_value (ptr));
   else
     {
       // FIXME -- should this be in variables.cc?
 
-      unwind_protect::begin_frame ("mexPutVariable");
+      unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
       bool caller = ! strcmp (space, "caller");
       bool base = ! strcmp (space, "base");
 
       if (caller || base)
 	{
 	  if (caller)
 	    octave_call_stack::goto_caller_frame ();
@@ -3345,17 +3345,17 @@ mexPutVariable (const char *space, const
 	  if (! error_state)
 	    unwind_protect::add (octave_call_stack::unwind_pop);
 
 	  symbol_table::varref (name) = mxArray::as_octave_value (ptr);
 	}
       else
 	mexErrMsgTxt ("mexPutVariable: symbol table does not exist");
 
-      unwind_protect::run_frame ("mexPutVariable");
+      unwind_protect::run_frame (uwp_frame);
     }
 
   return 0;
 }
 
 void
 mexMakeArrayPersistent (mxArray *ptr)
 {
diff --git a/src/oct-hist.cc b/src/oct-hist.cc
--- a/src/oct-hist.cc
+++ b/src/oct-hist.cc
@@ -475,27 +475,27 @@ do_edit_history (int argc, const string_
 	edit_history_add_hist (line);
     }
 
   file.close ();
 
   // Turn on command echo, so the output from this will make better
   // sense.
 
-  unwind_protect::begin_frame ("do_edit_history");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
-  unwind_protect_int (Vecho_executing_commands);
-  unwind_protect_bool (input_from_tmp_history_file);
+  unwind_protect::protect_var (Vecho_executing_commands);
+  unwind_protect::protect_var (input_from_tmp_history_file);
 
   Vecho_executing_commands = ECHO_CMD_LINE;
   input_from_tmp_history_file = true;
 
   source_file (name);
 
-  unwind_protect::run_frame ("do_edit_history");
+  unwind_protect::run_frame (uwp_frame);
 
   // Delete the temporary file.  Should probably be done with an
   // unwind_protect.
 
   unlink (name.c_str ());
 }
 
 static void
@@ -504,27 +504,27 @@ do_run_history (int argc, const string_v
   std::string name = mk_tmp_hist_file (argc, argv, 1, "run_history");
 
   if (name.empty ())
     return;
 
   // Turn on command echo so the output from this will make better
   // sense.
 
-  unwind_protect::begin_frame ("do_run_history");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
-  unwind_protect_int (Vecho_executing_commands);
-  unwind_protect_bool (input_from_tmp_history_file);
+  unwind_protect::protect_var (Vecho_executing_commands);
+  unwind_protect::protect_var (input_from_tmp_history_file);
 
   Vecho_executing_commands = ECHO_CMD_LINE;
   input_from_tmp_history_file = true;
 
   source_file (name);
 
-  unwind_protect::run_frame ("do_run_history");
+  unwind_protect::run_frame (uwp_frame);
 
   // Delete the temporary file.
 
   // FIXME -- should probably be done using an unwind_protect.
 
   unlink (name.c_str ());
 }
 
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -286,19 +286,19 @@ initialize_version_info (void)
   F__version_info__ (args, 0);
 }
 
 // Initialize by reading startup files.
 
 static void
 execute_startup_files (void)
 {
-  unwind_protect::begin_frame ("execute_startup_files");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
-  unwind_protect_bool (input_from_startup_file);
+  unwind_protect::protect_var (input_from_startup_file);
 
   input_from_startup_file = true;
 
   std::string context;
 
   bool verbose = (verbose_flag && ! inhibit_startup_message);
 
   bool require_file = false;
@@ -363,93 +363,93 @@ execute_startup_files (void)
 
 	      local_rc = octave_env::make_absolute (initfile, curr_dir);
 	    }
 
 	  source_file (local_rc, context, verbose, require_file);
 	}
     }
 
-  unwind_protect::run_frame ("execute_startup_files");
+  unwind_protect::run_frame (uwp_frame);
 }
 
 static int
 execute_eval_option_code (const std::string& code)
 {
-  unwind_protect::begin_frame ("execute_eval_option_code");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
   octave_save_signal_mask ();
 
   can_interrupt = true;
 
   octave_signal_hook = octave_signal_handler;
   octave_interrupt_hook = unwind_protect::run_all;
   octave_bad_alloc_hook = unwind_protect::run_all;
 
   octave_catch_interrupts ();
 
   octave_initialized = true;
 
-  unwind_protect_bool (interactive);
+  unwind_protect::protect_var (interactive);
 
   interactive = false;
 
   int parse_status = 0;
 
   try
     {
       eval_string (code, false, parse_status, 0);
     }
   catch (octave_quit_exception e)
     {
-      unwind_protect::run_frame ("execute_eval_option_code");
+      unwind_protect::run_frame (uwp_frame);
       clean_up_and_exit (e.status);
     }
   catch (octave_interrupt_exception)
     {
       recover_from_exception ();
       octave_stdout << "\n";
     }
   catch (std::bad_alloc)
     {
       std::cerr << "error: memory exhausted or requested size too large for range of Octave's index type -- eval failed"
 		<< std::endl;
     }
 
-  unwind_protect::run_frame ("execute_eval_option_code");
+  unwind_protect::run_frame (uwp_frame);
 
   return parse_status;
 }
 
 static void
 execute_command_line_file (const std::string& fname)
 {
-  unwind_protect::begin_frame ("execute_command_line_file");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
   octave_save_signal_mask ();
 
   can_interrupt = true;
 
   octave_signal_hook = octave_signal_handler;
   octave_interrupt_hook = unwind_protect::run_all;
   octave_bad_alloc_hook = unwind_protect::run_all;
 
   octave_catch_interrupts ();
 
   octave_initialized = true;
 
-  unwind_protect_bool (interactive);
-  unwind_protect_bool (reading_script_file);
-  unwind_protect_bool (input_from_command_line_file);
+  unwind_protect::protect_var (interactive);
+  unwind_protect::protect_var (reading_script_file);
+  unwind_protect::protect_var (input_from_command_line_file);
 
-  unwind_protect_str (curr_fcn_file_name);
-  unwind_protect_str (curr_fcn_file_full_name);
+  unwind_protect::protect_var (curr_fcn_file_name);
+  unwind_protect::protect_var (curr_fcn_file_full_name);
 
-  unwind_protect_str (octave_program_invocation_name);
-  unwind_protect_str (octave_program_name);
+  unwind_protect::protect_var (octave_program_invocation_name);
+  unwind_protect::protect_var (octave_program_name);
 
   interactive = false;
   reading_script_file = true;
   input_from_command_line_file = true;
 
   curr_fcn_file_name = fname;
   curr_fcn_file_full_name = curr_fcn_file_name;
 
@@ -467,31 +467,31 @@ execute_command_line_file (const std::st
       std::string context;
       bool verbose = false;
       bool require_file = true;
 
       source_file (fname, context, verbose, require_file, "octave");
     }
   catch (octave_quit_exception e)
     {
-      unwind_protect::run_frame ("execute_command_line_file");
+      unwind_protect::run_frame (uwp_frame);
       clean_up_and_exit (e.status);
     }
   catch (octave_interrupt_exception)
     {
       recover_from_exception ();
       octave_stdout << "\n";
     }
   catch (std::bad_alloc)
     {
       std::cerr << "error: memory exhausted or requested size too large for range of Octave's index type -- execution of "
 		<< fname << " failed" << std::endl;
     }
  
-  unwind_protect::run_frame ("execute_command_line_file");
+  unwind_protect::run_frame (uwp_frame);
 }
 
 // Usage message with extra help.
 
 static void
 verbose_usage (void)
 {
   std::cout << OCTAVE_NAME_VERSION_COPYRIGHT_COPYING_AND_WARRANTY "\n\
diff --git a/src/ov-builtin.cc b/src/ov-builtin.cc
--- a/src/ov-builtin.cc
+++ b/src/ov-builtin.cc
@@ -91,17 +91,17 @@ octave_builtin::do_multi_index_op (int n
 
   if (error_state)
     return retval;
 
   if (args.has_magic_colon ())
     ::error ("invalid use of colon in function argument list");
   else
     {
-      unwind_protect::begin_frame ("builtin_func_eval");
+      unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
       octave_call_stack::push (this);
 
       unwind_protect::add (octave_call_stack::unwind_pop, 0);
 
       try
 	{
 	  retval = (*f) (args, nargout);
@@ -109,17 +109,17 @@ octave_builtin::do_multi_index_op (int n
           // FIXME -- perhaps true builtins should be allowed?
           retval.make_storable_values ();
 	}
       catch (octave_execution_exception)
 	{
 	  gripe_library_execution_error ();
 	}
 
-      unwind_protect::run_frame ("builtin_func_eval");
+      unwind_protect::run_frame (uwp_frame);
     }
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/ov-class.cc b/src/ov-class.cc
--- a/src/ov-class.cc
+++ b/src/ov-class.cc
@@ -875,25 +875,25 @@ void
 octave_class::print (std::ostream& os, bool) const
 {
   print_raw (os);
 }
 
 void
 octave_class::print_raw (std::ostream& os, bool) const
 {
-  unwind_protect::begin_frame ("octave_class_print");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
-  unwind_protect_int (Vstruct_levels_to_print);
+  unwind_protect::protect_var (Vstruct_levels_to_print);
 
   indent (os);
   os << "  <class " << class_name () << ">";
   newline (os);
 
-  unwind_protect::run_frame ("octave_class_print");
+  unwind_protect::run_frame (uwp_frame);
 }
 
 bool
 octave_class::print_name_tag (std::ostream& os, const std::string& name) const
 {
   bool retval = false;
 
   indent (os);
diff --git a/src/ov-fcn-handle.cc b/src/ov-fcn-handle.cc
--- a/src/ov-fcn-handle.cc
+++ b/src/ov-fcn-handle.cc
@@ -308,17 +308,17 @@ octave_fcn_handle::load_ascii (std::istr
 	  // Get a line of text whitespace characters included, leaving
 	  // newline in the stream.
 	  buf = read_until_newline (is, true);
 
 	}
 
       pos = is.tellg ();
 
-      unwind_protect::begin_frame ("anon_ascii_load");
+      unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
       // Set up temporary scope to use for evaluating the text that
       // defines the anonymous function.
 
       symbol_table::scope_id local_scope = symbol_table::alloc_scope ();
       unwind_protect::add (symbol_table::erase_scope, &local_scope);
 
       symbol_table::set_scope (local_scope);
@@ -380,17 +380,17 @@ octave_fcn_handle::load_ascii (std::istr
 		success = false;
 	    }
 	  else
 	    success = false;
 	}
       else
 	success = false;
 
-      unwind_protect::run_frame ("anon_ascii_load");
+      unwind_protect::run_frame (uwp_frame);
     }
   else
     success = set_fcn (octaveroot, fpath);
 
   return success;
 }
 
 bool
@@ -489,17 +489,17 @@ octave_fcn_handle::load_binary (std::ist
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
 	return false;
       if (swap)
 	swap_bytes<4> (&tmp);
 
       OCTAVE_LOCAL_BUFFER (char, ctmp2, tmp+1);
       is.get (ctmp2, tmp+1, 0);
 
-      unwind_protect::begin_frame ("anon_binary_load");
+      unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
       // Set up temporary scope to use for evaluating the text that
       // defines the anonymous function.
 
       symbol_table::scope_id local_scope = symbol_table::alloc_scope ();
       unwind_protect::add (symbol_table::erase_scope, &local_scope);	      
 
       symbol_table::set_scope (local_scope);
@@ -550,17 +550,17 @@ octave_fcn_handle::load_binary (std::ist
 		}
 	      else
 		success = false;
 	    }
 	  else
 	    success = false;
 	}
 
-      unwind_protect::run_frame ("anon_binary_load");
+      unwind_protect::run_frame (uwp_frame);
     }
   else
     {
       std::string octaveroot;
       std::string fpath;
 
       if (nm.find_first_of ("\n") != std::string::npos)
 	{
@@ -934,17 +934,17 @@ octave_fcn_handle::load_hdf5 (hid_t loc_
 	    success = false;
 
 	  H5Aclose (attr_id);
 	}
 
       // restore error reporting:
       H5Eset_auto (err_func, err_func_data);
 
-      unwind_protect::begin_frame ("anon_hdf5_load");
+      unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
       // Set up temporary scope to use for evaluating the text that
       // defines the anonymous function.
 
       symbol_table::scope_id local_scope = symbol_table::alloc_scope ();
       unwind_protect::add (symbol_table::erase_scope, &local_scope);
 
       symbol_table::set_scope (local_scope);
@@ -1010,17 +1010,17 @@ octave_fcn_handle::load_hdf5 (hid_t loc_
 		}
 	      else
 		success = false;
 	    }
 	  else
 	    success = false;
 	}
 
-      unwind_protect::run_frame ("anon_hdf5_load");
+      unwind_protect::run_frame (uwp_frame);
     }
   else
     {
       std::string octaveroot;
       std::string fpath;
 
       // we have to pull some shenanigans here to make sure
       // HDF5 doesn't print out all sorts of error messages if we
diff --git a/src/ov-list.cc b/src/ov-list.cc
--- a/src/ov-list.cc
+++ b/src/ov-list.cc
@@ -288,17 +288,17 @@ void
 octave_list::print (std::ostream& os, bool) const
 {
   print_raw (os);
 }
 
 void
 octave_list::print_raw (std::ostream& os, bool) const
 {
-  unwind_protect::begin_frame ("octave_list_print");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
   octave_idx_type n = data.length ();
 
   if (n > 0)
     {
       indent (os);
       os << "(";
       newline (os);
@@ -321,17 +321,17 @@ octave_list::print_raw (std::ostream& os
       indent (os);
       os << ")";
     }
   else
     os << "()";
 
   newline (os);
 
-  unwind_protect::run_frame ("octave_list_print");
+  unwind_protect::run_frame (uwp_frame);
 }
 
 bool
 octave_list::print_name_tag (std::ostream& os, const std::string& name) const
 {
   indent (os);
   if (data.length () == 0)
     os << name << " = ";
diff --git a/src/ov-mex-fcn.cc b/src/ov-mex-fcn.cc
--- a/src/ov-mex-fcn.cc
+++ b/src/ov-mex-fcn.cc
@@ -134,32 +134,32 @@ octave_mex_function::do_multi_index_op (
 
   if (error_state)
     return retval;
 
   if (args.has_magic_colon ())
     ::error ("invalid use of colon in function argument list");
   else
     {
-      unwind_protect::begin_frame ("mex_func_eval");
+      unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
       octave_call_stack::push (this);
 
       unwind_protect::add (octave_call_stack::unwind_pop, 0);
 
       try
 	{
 	  retval = call_mex (have_fmex, mex_fcn_ptr, args, nargout, this);
 	}
       catch (octave_execution_exception)
 	{
 	  gripe_library_execution_error ();
 	}
 
-      unwind_protect::run_frame ("mex_func_eval");
+      unwind_protect::run_frame (uwp_frame);
     }
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -575,19 +575,19 @@ void
 octave_struct::print (std::ostream& os, bool) const
 {
   print_raw (os);
 }
 
 void
 octave_struct::print_raw (std::ostream& os, bool) const
 {
-  unwind_protect::begin_frame ("octave_struct_print");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
-  unwind_protect_int (Vstruct_levels_to_print);
+  unwind_protect::protect_var (Vstruct_levels_to_print);
 
   if (Vstruct_levels_to_print >= 0)
     {
       bool print_keys_only = Vstruct_levels_to_print-- == 0;
 
       indent (os);
       os << "{";
       newline (os);
@@ -643,17 +643,17 @@ octave_struct::print_raw (std::ostream& 
     }
   else
     {
       indent (os);
       os << "<structure>";
       newline (os);
     }
 
-  unwind_protect::run_frame ("octave_struct_print");
+  unwind_protect::run_frame (uwp_frame);
 }
 
 bool
 octave_struct::print_name_tag (std::ostream& os, const std::string& name) const
 {
   bool retval = false;
 
   indent (os);
diff --git a/src/ov-usr-fcn.cc b/src/ov-usr-fcn.cc
--- a/src/ov-usr-fcn.cc
+++ b/src/ov-usr-fcn.cc
@@ -106,34 +106,34 @@ octave_user_script::subsref (const std::
 }
 
 octave_value_list
 octave_user_script::do_multi_index_op (int nargout,
 				       const octave_value_list& args)
 {
   octave_value_list retval;
 
-  unwind_protect::begin_frame ("user_script_eval");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
   if (! error_state)
     {
       if (args.length () == 0 && nargout == 0)
 	{
 	  if (cmd_list)
 	    {
-	      unwind_protect_int (call_depth);
+	      unwind_protect::protect_var (call_depth);
 	      call_depth++;
 
 	      if (call_depth < Vmax_recursion_depth)
 		{
 		  octave_call_stack::push (this);
 
 		  unwind_protect::add (octave_call_stack::unwind_pop, 0);
 
-		  unwind_protect_bool (tree_evaluator::in_fcn_or_script_body);
+		  unwind_protect::protect_var (tree_evaluator::in_fcn_or_script_body);
 		  tree_evaluator::in_fcn_or_script_body = true;
 
 		  cmd_list->accept (*current_evaluator);
 
 		  if (tree_return_command::returning)
 		    tree_return_command::returning = 0;
 
 		  if (tree_break_command::breaking)
@@ -145,17 +145,17 @@ octave_user_script::do_multi_index_op (i
 	      else
 		::error ("max_recursion_limit exceeded");
     	    }
 	}
       else
 	error ("invalid call to script");
     }
 
-  unwind_protect::run_frame ("user_script_eval");
+  unwind_protect::run_frame (uwp_frame);
 
   return retval;
 }
 
 void
 octave_user_script::accept (tree_walker& tw)
 {
   tw.visit_octave_user_script (*this);
@@ -341,25 +341,25 @@ octave_user_function::do_multi_index_op 
   if (error_state)
     return retval;
 
   if (! cmd_list)
     return retval;
 
   int nargin = args.length ();
 
-  unwind_protect::begin_frame ("user_func_eval");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
-  unwind_protect_int (call_depth);
+  unwind_protect::protect_var (call_depth);
   call_depth++;
 
   if (call_depth >= Vmax_recursion_depth)
     {
       ::error ("max_recursion_limit exceeded");
-      unwind_protect::run_frame ("user_func_eval");
+      unwind_protect::run_frame (uwp_frame);
       return retval;
     }
 
   // Save old and set current symbol table context, for
   // eval_undefined_error().
 
   octave_call_stack::push (this, local_scope, call_depth);
   unwind_protect::add (octave_call_stack::unwind_pop, 0);
@@ -374,17 +374,17 @@ octave_user_function::do_multi_index_op 
   // Save and restore args passed for recursive calls.
 
   save_args_passed (args);
 
   unwind_protect::add (::restore_args_passed, this);
 
   string_vector arg_names = args.name_tags ();
 
-  unwind_protect_int (num_args_passed);
+  unwind_protect::protect_var (num_args_passed);
   num_args_passed = nargin;
 
   if (param_list && ! param_list->varargs_only ())
     {
       param_list->define_from_arg_vector (args);
       if (error_state)
 	goto abort;
     }
@@ -425,17 +425,17 @@ octave_user_function::do_multi_index_op 
 
     bool echo_commands = (Vecho_executing_commands & ECHO_FUNCTIONS);
 
     if (echo_commands)
       print_code_function_header ();
 
     // Evaluate the commands that make up the function.
 
-    unwind_protect_bool (tree_evaluator::in_fcn_or_script_body);
+    unwind_protect::protect_var (tree_evaluator::in_fcn_or_script_body);
     tree_evaluator::in_fcn_or_script_body = true;
 
     bool special_expr = (is_inline_function ()
 			 || cmd_list->is_anon_function_body ());
 
     if (special_expr)
       {
 	assert (cmd_list->length () == 1);
@@ -490,17 +490,17 @@ octave_user_function::do_multi_index_op 
 	  }
 
 	if (! error_state)
 	  retval = ret_list->convert_to_const_vector (varargout);
       }
   }
 
  abort:
-  unwind_protect::run_frame ("user_func_eval");
+  unwind_protect::run_frame (uwp_frame);
 
   return retval;
 }
 
 void
 octave_user_function::accept (tree_walker& tw)
 {
   tw.visit_octave_user_function (*this);
diff --git a/src/pager.cc b/src/pager.cc
--- a/src/pager.cc
+++ b/src/pager.cc
@@ -359,29 +359,29 @@ octave_diary_stream::stream (void)
   return *instance;
 }
 
 void
 flush_octave_stdout (void)
 {
   if (! flushing_output_to_pager)
     {
-      unwind_protect::begin_frame ("flush_octave_stdout");
+      unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
-      unwind_protect_bool (really_flush_to_pager);
-      unwind_protect_bool (flushing_output_to_pager);
+      unwind_protect::protect_var (really_flush_to_pager);
+      unwind_protect::protect_var (flushing_output_to_pager);
 
       really_flush_to_pager = true;
       flushing_output_to_pager = true;
 
       octave_stdout.flush ();
 
       clear_external_pager ();
 
-      unwind_protect::run_frame ("flush_octave_stdout");
+      unwind_protect::run_frame (uwp_frame);
     }
 }
 
 static void
 close_diary_file (void)
 {
   // Try to flush the current buffer to the diary now, so that things
   // like
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -3199,32 +3199,32 @@ representing the elements of @var{x}.  B
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2 || nargout > 1)
     print_usage ();
   else
     {
-      unwind_protect::begin_frame ("Frats");
-
-      unwind_protect_int (rat_string_len);
+      unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+
+      unwind_protect::protect_var (rat_string_len);
 
       rat_string_len = 9;
 
       if (nargin == 2)
 	rat_string_len = args(1).nint_value ();
 
       if (! error_state)
 	{
 	  octave_value arg = args(0);
 
 	  if (arg.is_numeric_type ())
 	    {
-	      unwind_protect_bool (rat_format);
+	      unwind_protect::protect_var (rat_format);
 
 	      rat_format = true;
 
 	      std::ostringstream buf;
 	      args(0).print (buf);
 	      std::string s = buf.str ();
 
 	      std::list<std::string> lst;
@@ -3249,17 +3249,17 @@ representing the elements of @var{x}.  B
 		}
 
 	      retval = string_vector (lst);
 	    }
 	  else
 	    error ("rats: expecting numeric input");
 	}
 
-      unwind_protect::run_frame ("Frats");
+      unwind_protect::run_frame (uwp_frame);
     }
 
   return retval;
 }
 
 DEFUN (disp, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} disp (@var{x})\n\
diff --git a/src/pt-arg-list.cc b/src/pt-arg-list.cc
--- a/src/pt-arg-list.cc
+++ b/src/pt-arg-list.cc
@@ -157,37 +157,39 @@ tree_argument_list::convert_to_const_vec
 {
   // END doesn't make sense for functions.  Maybe we need a different
   // way of asking an octave_value object this question?
 
   bool stash_object = (list_includes_magic_end
 		       && object
 		       && ! (object->is_function ()
 			     || object->is_function_handle ()));
+  
+  unwind_protect::frame_id_t uwp_frame;
 
   if (stash_object)
     {
-      unwind_protect::begin_frame ("convert_to_const_vector");
+      uwp_frame = unwind_protect::begin_frame ();
 
-      unwind_protect_const_ptr (indexed_object);
+      unwind_protect::protect_var (indexed_object);
 
       indexed_object = object;
     }
 
   int len = length ();
 
   std::list<octave_value_list> args;
 
   iterator p = begin ();
   for (int k = 0; k < len; k++)
     {
       if (stash_object)
 	{
-	  unwind_protect_int (index_position);
-	  unwind_protect_int (num_indices);
+	  unwind_protect::protect_var (index_position);
+	  unwind_protect::protect_var (num_indices);
 
 	  index_position = k;
 	  num_indices = len;
 	}
 
       tree_expression *elt = *p++;
 
       if (elt)
@@ -211,17 +213,17 @@ tree_argument_list::convert_to_const_vec
       else
 	{
 	  args.push_back (octave_value ());
 	  break;
 	}
     }
 
   if (stash_object)
-    unwind_protect::run_frame ("convert_to_const_vector");
+    unwind_protect::run_frame (uwp_frame);
 
   return args;
 }
 
 std::list<octave_lvalue>
 tree_argument_list::lvalue_list (void)
 {
   std::list<octave_lvalue> retval;
diff --git a/src/pt-eval.cc b/src/pt-eval.cc
--- a/src/pt-eval.cc
+++ b/src/pt-eval.cc
@@ -277,19 +277,19 @@ void
 tree_evaluator::visit_simple_for_command (tree_simple_for_command& cmd)
 {
   if (error_state)
     return;
 
   if (debug_mode)
     do_breakpoint (cmd.is_breakpoint (), cmd.line (), cmd.column ());
 
-  unwind_protect::begin_frame ("tree_evaluator::visit_simple_for_command");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
-  unwind_protect_bool (in_loop_command);
+  unwind_protect::protect_var (in_loop_command);
 
   in_loop_command = true;
 
   tree_expression *expr = cmd.control_expr ();
 
   octave_value rhs = expr->rvalue1 ();
 
   if (error_state || rhs.is_undefined ())
@@ -387,31 +387,31 @@ tree_evaluator::visit_simple_for_command
     else
       {
 	::error ("invalid type in for loop expression near line %d, column %d",
 		 cmd.line (), cmd.column ());
       }
   }
 
  cleanup:
-  unwind_protect::run_frame ("tree_evaluator::visit_simple_for_command");
+  unwind_protect::run_frame (uwp_frame);
 }
 
 void
 tree_evaluator::visit_complex_for_command (tree_complex_for_command& cmd)
 {
   if (error_state)
     return;
 
   if (debug_mode)
     do_breakpoint (cmd.is_breakpoint (), cmd.line (), cmd.column ());
 
-  unwind_protect::begin_frame ("tree_evaluator::visit_complex_for_command");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
-  unwind_protect_bool (in_loop_command);
+  unwind_protect::protect_var (in_loop_command);
 
   in_loop_command = true;
 
   tree_expression *expr = cmd.control_expr ();
 
   octave_value rhs = expr->rvalue1 ();
 
   if (error_state || rhs.is_undefined ())
@@ -458,17 +458,17 @@ tree_evaluator::visit_complex_for_comman
 	  if (quit_loop_now ())
 	    break;
 	}
     }
   else
     error ("in statement `for [X, Y] = VAL', VAL must be a structure");
 
  cleanup:
-  unwind_protect::run_frame ("tree_evaluator::visit_complex_for_command");
+  unwind_protect::run_frame (uwp_frame);
 }
 
 void
 tree_evaluator::visit_octave_user_script (octave_user_script&)
 {
   panic_impossible ();
 }
 
@@ -854,21 +854,21 @@ do_catch_code (void *ptr)
 
   if (list)
     list->accept (*current_evaluator);
 }
 
 void
 tree_evaluator::visit_try_catch_command (tree_try_catch_command& cmd)
 {
-  unwind_protect::begin_frame ("tree_evaluator::visit_try_catch_command");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
   
-  unwind_protect_int (buffer_error_messages);
-  unwind_protect_bool (Vdebug_on_error);
-  unwind_protect_bool (Vdebug_on_warning);
+  unwind_protect::protect_var (buffer_error_messages);
+  unwind_protect::protect_var (Vdebug_on_error);
+  unwind_protect::protect_var (Vdebug_on_warning);
 
   buffer_error_messages++;
   Vdebug_on_error = false;
   Vdebug_on_warning = false;
 
   tree_statement_list *catch_code = cmd.cleanup ();
 
   unwind_protect::add (do_catch_code, catch_code);
@@ -876,17 +876,17 @@ tree_evaluator::visit_try_catch_command 
   tree_statement_list *try_code = cmd.body ();
 
   if (try_code)
     try_code->accept (*this);
 
   if (catch_code && error_state)
     {
       error_state = 0;
-      unwind_protect::run_frame ("tree_evaluator::visit_try_catch_command");
+      unwind_protect::run_frame (uwp_frame);
     }
   else
     {
       error_state = 0;
 
       // Unwind stack elements must be cleared or run in the reverse
       // order in which they were added to the stack.
 
@@ -895,45 +895,45 @@ tree_evaluator::visit_try_catch_command 
 
       // For restoring Vdebug_on_warning, Vdebug_on_error, and
       // buffer_error_messages.
       unwind_protect::run ();
       unwind_protect::run ();
       unwind_protect::run ();
 
       // Also clear the frame marker.
-      unwind_protect::run_frame ("tree_evaluator::visit_try_catch_command");
+      unwind_protect::run_frame (uwp_frame);
     }
 }
 
 static void
 do_unwind_protect_cleanup_code (void *ptr)
 {
   tree_statement_list *list = static_cast<tree_statement_list *> (ptr);
 
   // We want to run the cleanup code without error_state being set,
   // but we need to restore its value, so that any errors encountered
   // in the first part of the unwind_protect are not completely
   // ignored.
 
-  unwind_protect_int (error_state);
+  unwind_protect::protect_var (error_state);
   error_state = 0;
 
-  unwind_protect_int (octave_interrupt_state);
+  unwind_protect::protect_var (octave_interrupt_state);
   octave_interrupt_state = 0;
 
   // Similarly, if we have seen a return or break statement, allow all
   // the cleanup code to run before returning or handling the break.
   // We don't have to worry about continue statements because they can
   // only occur in loops.
 
-  unwind_protect_int (tree_return_command::returning);
+  unwind_protect::protect_var (tree_return_command::returning);
   tree_return_command::returning = 0;
 
-  unwind_protect_int (tree_break_command::breaking);
+  unwind_protect::protect_var (tree_break_command::breaking);
   tree_break_command::breaking = 0;
 
   if (list)
     list->accept (*current_evaluator);
 
   // The unwind_protects are popped off the stack in the reverse of
   // the order they are pushed on.
 
@@ -998,19 +998,19 @@ tree_evaluator::visit_unwind_protect_com
 }
 
 void
 tree_evaluator::visit_while_command (tree_while_command& cmd)
 {
   if (error_state)
     return;
 
-  unwind_protect::begin_frame ("tree_evaluator::visit_while_command");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
-  unwind_protect_bool (in_loop_command);
+  unwind_protect::protect_var (in_loop_command);
 
   in_loop_command = true;
 
   tree_expression *expr = cmd.condition ();
 
   if (! expr)
     panic_impossible ();
 
@@ -1037,28 +1037,28 @@ tree_evaluator::visit_while_command (tre
 	  if (quit_loop_now ())
 	    break;
 	}
       else
 	break;
     }
 
  cleanup:
-  unwind_protect::run_frame ("tree_evaluator::visit_while_command");
+  unwind_protect::run_frame (uwp_frame);
 }
 
 void
 tree_evaluator::visit_do_until_command (tree_do_until_command& cmd)
 {
   if (error_state)
     return;
 
-  unwind_protect::begin_frame ("tree_evaluator::visit_do_until_command");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
-  unwind_protect_bool (in_loop_command);
+  unwind_protect::protect_var (in_loop_command);
 
   in_loop_command = true;
 
   tree_expression *expr = cmd.condition ();
 
   if (! expr)
     panic_impossible ();
 
@@ -1083,17 +1083,17 @@ tree_evaluator::visit_do_until_command (
       if (debug_mode)
 	do_breakpoint (cmd.is_breakpoint (), l, c);
 
       if (expr->is_logically_true ("do-until"))
 	break;
     }
 
  cleanup:
-  unwind_protect::run_frame ("tree_evaluator::visit_do_until_command");
+  unwind_protect::run_frame (uwp_frame);
 }
 
 void
 tree_evaluator::do_breakpoint (tree_statement& stmt) const
 {
   do_breakpoint (stmt.is_breakpoint (), stmt.line (), stmt.column (),
 		 stmt.is_end_of_fcn_or_script ());
 }
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -543,17 +543,17 @@ main_loop (void)
 
   // The big loop.
 
   int retval = 0;
   do
     {
       try
 	{
-	  unwind_protect::begin_frame ("main_loop");
+	  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
 	  reset_error_handler ();
 
 	  reset_parser ();
 
 	  // Do this with an unwind-protect cleanup function so that
 	  // the forced variables will be unmarked in the event of an
 	  // interrupt.
@@ -606,17 +606,17 @@ main_loop (void)
 		      else
 			command_editor::increment_current_command_number ();
 		    }
 		}
 	      else if (parser_end_of_input)
 		break;
 	    }
 
-	  unwind_protect::run_frame ("main_loop");
+	  unwind_protect::run_frame (uwp_frame);
 	}
       catch (octave_quit_exception e)
         {
           unwind_protect::run_all ();
           clean_up_and_exit (e.status);
         }
       catch (octave_interrupt_exception)
 	{
@@ -852,17 +852,17 @@ command that was written to the standard
 \n\
 @noindent\n\
 will set the variable @code{output} to the string @samp{foo}, and the\n\
 variable @code{status} to the integer @samp{2}.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  unwind_protect::begin_frame ("Fsystem");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
   int nargin = args.length ();
 
   if (nargin > 0 && nargin < 4)
     {
       bool return_output = (nargout > 1 || nargin > 1);
 
       std::string cmd_str = args(0).string_value ();
@@ -955,17 +955,17 @@ variable @code{status} to the integer @s
 
 	      retval(0) = status;
 	    }
 	}
     }
   else
     print_usage ();
 
-  unwind_protect::run_frame ("Fsystem");
+  unwind_protect::run_frame (uwp_frame);
 
   return retval;
 }
 
 DEFALIAS (shell_cmd, system);
 
 // FIXME -- this should really be static, but that causes
 // problems on some systems.
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -259,30 +259,30 @@ generate_struct_completions (const std::
 
       if (pos != std::string::npos)
 	base_name = base_name.substr (0, pos);
 
       if (is_variable (base_name))
 	{
 	  int parse_status;
 
-	  unwind_protect::begin_frame ("generate_struct_completions");
+	  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
-	  unwind_protect_int (error_state);
-	  unwind_protect_int (warning_state);
+	  unwind_protect::protect_var (error_state);
+	  unwind_protect::protect_var (warning_state);
 
-	  unwind_protect_bool (discard_error_messages);
-	  unwind_protect_bool (discard_warning_messages);
+	  unwind_protect::protect_var (discard_error_messages);
+	  unwind_protect::protect_var (discard_warning_messages);
 
 	  discard_error_messages = true;
 	  discard_warning_messages = true;
 
 	  octave_value tmp = eval_string (prefix, true, parse_status);
 
-	  unwind_protect::run_frame ("generate_struct_completions");
+	  unwind_protect::run_frame (uwp_frame);
 
 	  if (tmp.is_defined () && tmp.is_map ())
 	    names = tmp.map_keys ();
 	}
     }
 
   return names;
 }
@@ -301,26 +301,26 @@ looks_like_struct (const std::string& te
 
 #if 0
   symbol_record *sr = curr_sym_tab->lookup (text);
 
   if (sr && ! sr->is_function ())
     {
       int parse_status;
 
-      unwind_protect::begin_frame ("looks_like_struct");
+      unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
-      unwind_protect_bool (discard_error_messages);
-      unwind_protect_int (error_state);
+      unwind_protect::protect_var (discard_error_messages);
+      unwind_protect::protect_var (error_state);
 
       discard_error_messages = true;
 
       octave_value tmp = eval_string (text, true, parse_status);
 
-      unwind_protect::run_frame ("looks_like_struct");
+      unwind_protect::run_frame (uwp_frame);
 
       retval = (tmp.is_defined () && tmp.is_map ());
     }
 #endif
 
   return retval;
 }
 
@@ -1379,17 +1379,17 @@ do_who (int argc, const string_vector& a
 	  // implement this option there so that the variables are never 
 	  // stored at all.
 	  if (i == argc - 1)
 	    error ("whos: -file argument must be followed by a file name");
 	  else
 	    {
 	      std::string nm = argv [i + 1];
 
-	      unwind_protect::begin_frame ("do_who_file");
+	      unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
 	      // Set up temporary scope.
 
 	      symbol_table::scope_id tmp_scope = symbol_table::alloc_scope ();
 	      unwind_protect::add (symbol_table::erase_scope, &tmp_scope);
 
 	      symbol_table::set_scope (tmp_scope);
 
@@ -1403,17 +1403,17 @@ do_who (int argc, const string_vector& a
 	      if (! error_state)
 		{
 		  std::string newmsg = std::string ("Variables in the file ") + 
 		    nm + ":\n\n";
 
 		  retval =  do_who (i, argv, return_list, verbose, newmsg);
 		}
 
-	      unwind_protect::run_frame ("do_who_file");
+	      unwind_protect::run_frame (uwp_frame);
 	    }
 
 	  return retval;
 	}
       else if (argv[i] == "-regexp")
 	have_regexp = true;
       else if (argv[i] == "global")
 	global_only = true;
