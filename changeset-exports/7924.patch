# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1215813568 14400
#      Fri Jul 11 17:59:28 2008 -0400
# Node ID 4976f66d469b51185e96b2df7f1f48eefb602331
# Parent  c3d21b9b94b679db93ba863f721171f36b74f248
miscellaneous cleanup

diff --git a/liboctave/Array-d.cc b/liboctave/Array-d.cc
--- a/liboctave/Array-d.cc
+++ b/liboctave/Array-d.cc
@@ -134,27 +134,29 @@ Array<double>::sort (octave_idx_type dim
 	  // things up.
 
 	  if (lo_ieee_signbit (octave_NaN))
 	    {
 	      if (mode == ASCENDING)
 		{
 		  octave_idx_type i = 0;
 		  double *vtmp = reinterpret_cast<double *> (p);
-		  while (xisnan (vtmp[i++]) && i < ns);
+		  while (xisnan (vtmp[i++]) && i < ns)
+		    /* do nothing */;
 		  for (octave_idx_type l = 0; l < ns - i + 1; l++)
 		    vtmp[l] = vtmp[l+i-1];
 		  for (octave_idx_type l = ns - i + 1; l < ns; l++)
 		    vtmp[l] = octave_NaN;
 		}
 	      else
 		{
 		  octave_idx_type i = ns;
 		  double *vtmp = reinterpret_cast<double *> (p);
-		  while (xisnan (vtmp[--i]) && i > 0);
+		  while (xisnan (vtmp[--i]) && i > 0)
+		    /* do nothing */;
 		  for (octave_idx_type l = i; l >= 0; l--)
 		    vtmp[l-i+ns-1] = vtmp[l];
 		  for (octave_idx_type l = 0; l < ns - i - 1; l++)
 		    vtmp[l] = octave_NaN;
 		}
 	    }
 
 	  p += ns;
@@ -194,26 +196,28 @@ Array<double>::sort (octave_idx_type dim
 	  // to the end. If it will be sorted to the beginning,
 	  // fix things up.
 
 	  if (lo_ieee_signbit (octave_NaN))
 	    {
 	      if (mode == ASCENDING)
 		{
 		   octave_idx_type i = 0;
-		  while (xisnan (v[i++*stride + offset]) && i < ns);
+		  while (xisnan (v[i++*stride + offset]) && i < ns)
+		    /* do nothing */;
 		  for (octave_idx_type l = 0; l < ns - i + 1; l++)
 		    v[l*stride + offset] = v[(l+i-1)*stride + offset];
 		  for (octave_idx_type l = ns - i + 1; l < ns; l++)
 		    v[l*stride + offset] = octave_NaN;
 		}
 	      else
 		{
 		   octave_idx_type i = ns;
-		  while (xisnan (v[--i*stride + offset]) && i > 0);
+		  while (xisnan (v[--i*stride + offset]) && i > 0)
+		    /* do nothing */;
 		  for (octave_idx_type l = i; l >= 0; l--)
 		    v[(l-i+ns-1)*stride + offset] = v[l*stride + offset];
 		  for (octave_idx_type l = 0; l < ns - i - 1; l++)
 		    v[l*stride + offset] = octave_NaN;
 		}
 	    }
 	}
     }
@@ -298,17 +302,18 @@ Array<double>::sort (Array<octave_idx_ty
       // to the beginning of the vector and the other to the end.
       // If it will be sorted to the beginning, fix things up.
 
       if (lo_ieee_signbit (octave_NaN))
 	{
 	  if (mode == ASCENDING)
 	    {
 	      octave_idx_type i = 0;
-	      while (xisnan (v[i++*stride+offset]) && i < ns);
+	      while (xisnan (v[i++*stride+offset]) && i < ns)
+		/* do nothing */;
 	      OCTAVE_LOCAL_BUFFER (double, itmp, i - 1);
 	      for (octave_idx_type l = 0; l < i -1; l++)
 		itmp[l] = sidx(l*stride + offset);
 	      for (octave_idx_type l = 0; l < ns - i + 1; l++)
 		{
 		  v[l*stride + offset] = v[(l+i-1)*stride + offset];
 		  sidx(l*stride + offset) = sidx((l+i-1)*stride + offset);
 		}
@@ -317,17 +322,18 @@ Array<double>::sort (Array<octave_idx_ty
 		  v[l*stride + offset] = octave_NaN;
 		  sidx(l*stride + offset) = 
 		    static_cast<octave_idx_type>(itmp[k]);
 		}
 	    }
 	  else 
 	    {
 	      octave_idx_type i = ns;
-	      while (xisnan (v[--i*stride+offset]) && i > 0);
+	      while (xisnan (v[--i*stride+offset]) && i > 0)
+		/* do nothing */;
 	      OCTAVE_LOCAL_BUFFER (double, itmp, ns - i - 1);
 	      for (octave_idx_type l = 0; l < ns - i -1; l++)
 		itmp[l] = sidx((l+i+1)*stride + offset);
 	      for (octave_idx_type l = i; l >= 0; l--)
 		{
 		  v[(l-i+ns-1)*stride + offset] = v[l*stride + offset];
 		  sidx((l-i+ns-1)*stride + offset) = sidx(l*stride + offset);
 		}
diff --git a/liboctave/Array-f.cc b/liboctave/Array-f.cc
--- a/liboctave/Array-f.cc
+++ b/liboctave/Array-f.cc
@@ -134,27 +134,29 @@ Array<float>::sort (octave_idx_type dim,
 	  // things up.
 
 	  if (lo_ieee_signbit (octave_Float_NaN))
 	    {
 	      if (mode == ASCENDING)
 		{
 		  octave_idx_type i = 0;
 		  float *vtmp = reinterpret_cast<float *> (p);
-		  while (xisnan (vtmp[i++]) && i < ns);
+		  while (xisnan (vtmp[i++]) && i < ns)
+		    /* do nothing */;
 		  for (octave_idx_type l = 0; l < ns - i + 1; l++)
 		    vtmp[l] = vtmp[l+i-1];
 		  for (octave_idx_type l = ns - i + 1; l < ns; l++)
 		    vtmp[l] = octave_Float_NaN;
 		}
 	      else
 		{
 		  octave_idx_type i = ns;
 		  float *vtmp = reinterpret_cast<float *> (p);
-		  while (xisnan (vtmp[--i]) && i > 0);
+		  while (xisnan (vtmp[--i]) && i > 0)
+		    /* do nothing */;
 		  for (octave_idx_type l = i; l >= 0; l--)
 		    vtmp[l-i+ns-1] = vtmp[l];
 		  for (octave_idx_type l = 0; l < ns - i - 1; l++)
 		    vtmp[l] = octave_Float_NaN;
 		}
 	    }
 
 	  p += ns;
@@ -194,26 +196,28 @@ Array<float>::sort (octave_idx_type dim,
 	  // to the end. If it will be sorted to the beginning,
 	  // fix things up.
 
 	  if (lo_ieee_signbit (octave_Float_NaN))
 	    {
 	      if (mode == ASCENDING)
 		{
 		   octave_idx_type i = 0;
-		  while (xisnan (v[i++*stride + offset]) && i < ns);
+		  while (xisnan (v[i++*stride + offset]) && i < ns)
+		    /* do nothing */;
 		  for (octave_idx_type l = 0; l < ns - i + 1; l++)
 		    v[l*stride + offset] = v[(l+i-1)*stride + offset];
 		  for (octave_idx_type l = ns - i + 1; l < ns; l++)
 		    v[l*stride + offset] = octave_Float_NaN;
 		}
 	      else
 		{
 		   octave_idx_type i = ns;
-		  while (xisnan (v[--i*stride + offset]) && i > 0);
+		  while (xisnan (v[--i*stride + offset]) && i > 0)
+		    /* do nothing */;
 		  for (octave_idx_type l = i; l >= 0; l--)
 		    v[(l-i+ns-1)*stride + offset] = v[l*stride + offset];
 		  for (octave_idx_type l = 0; l < ns - i - 1; l++)
 		    v[l*stride + offset] = octave_Float_NaN;
 		}
 	    }
 	}
     }
@@ -298,17 +302,18 @@ Array<float>::sort (Array<octave_idx_typ
       // to the beginning of the vector and the other to the end.
       // If it will be sorted to the beginning, fix things up.
 
       if (lo_ieee_signbit (octave_Float_NaN))
 	{
 	  if (mode == ASCENDING)
 	    {
 	      octave_idx_type i = 0;
-	      while (xisnan (v[i++*stride+offset]) && i < ns);
+	      while (xisnan (v[i++*stride+offset]) && i < ns)
+		/* do nothing */;
 	      OCTAVE_LOCAL_BUFFER (float, itmp, i - 1);
 	      for (octave_idx_type l = 0; l < i -1; l++)
 		itmp[l] = sidx(l*stride + offset);
 	      for (octave_idx_type l = 0; l < ns - i + 1; l++)
 		{
 		  v[l*stride + offset] = v[(l+i-1)*stride + offset];
 		  sidx(l*stride + offset) = sidx((l+i-1)*stride + offset);
 		}
@@ -317,17 +322,18 @@ Array<float>::sort (Array<octave_idx_typ
 		  v[l*stride + offset] = octave_Float_NaN;
 		  sidx(l*stride + offset) = 
 		    static_cast<octave_idx_type>(itmp[k]);
 		}
 	    }
 	  else 
 	    {
 	      octave_idx_type i = ns;
-	      while (xisnan (v[--i*stride+offset]) && i > 0);
+	      while (xisnan (v[--i*stride+offset]) && i > 0)
+		/* do nothing */;
 	      OCTAVE_LOCAL_BUFFER (float, itmp, ns - i - 1);
 	      for (octave_idx_type l = 0; l < ns - i -1; l++)
 		itmp[l] = sidx((l+i+1)*stride + offset);
 	      for (octave_idx_type l = i; l >= 0; l--)
 		{
 		  v[(l-i+ns-1)*stride + offset] = v[l*stride + offset];
 		  sidx((l-i+ns-1)*stride + offset) = sidx(l*stride + offset);
 		}
diff --git a/liboctave/Array-util.cc b/liboctave/Array-util.cc
--- a/liboctave/Array-util.cc
+++ b/liboctave/Array-util.cc
@@ -134,28 +134,28 @@ is_scalar (const dim_vector& dim)
   return retval;
 }
 
 bool
 is_vector (const dim_vector& dim)
 {
   int m = 0;
   int n = dim.length ();
-  bool retval = true;
 
   if (n == 0)
     m = 2;
   else
     {
       for (int i = 0; i < n; i ++)
 	if (dim (i) > 1)
 	  m++;
 	else if (dim(i) < 1)
 	  m += 2;
     }
+
   return (m < 2);
 }
 
 bool
 any_ones (const Array<octave_idx_type>& arr)
 {
   bool retval = false;
 
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,10 +1,29 @@
 2008-07-11  John W. Eaton  <jwe@octave.org>
 
+	* dDiagMatrix.cc (DiagMatrix::diag): Return empty ColumnVector if
+	number of rows or columns is 0.
+	* fDiagMatrix.cc (FloatDiagMatrix::diag): Likewise.
+
+	* Array-util.cc (is_vector): Avoid GCC warning.
+	* Array-f.cc (Array<float>::sort): Likewise.
+	* Array-d.cc (Array<double>::sort): Likewise.
+	* dbleQR.cc (QR::QR (const Matrix&, const Matrix&)): Likewise.
+	* CmplxQR.cc (ComplexQR::ComplexQR (const ComplexMatrix&, const
+	ComplexMatrix&)): Likewise.
+	* floatQR.cc (FloatQR::FloatQR (const FloatMatrix&, const
+	FloatMatrix&)): Likewise.
+	* fCmplxQR.cc (FloatComplexQR::FloatComplexQR (const
+	FloatComplexMatrix&, const FloatComplexMatrix&)): Likewise.
+	* Quad.cc (IndefQuad::do_integrate (octave_idx_type&,
+	octave_idx_type&, float&), FloatIndefQuad::do_integrate,
+	DefQuad::do_integrate octave_idx_type&, octave_idx_type&, float&,
+	FloatIndefQuad::do_integrate): Likewise.
+
 	* mx-op-defs.h (MS_BOOL_OP, SM_BOOL_OP, MM_BOOL_OP, NDS_BOOL_OP,
 	SND_BOOL_OP, NDND_BOOL_OP): Detect NaN values.
 	* Array-util.cc (gripe_nan_to_logical_conversion): New function.
 	* Array-util.h: Provide decl.
 	* oct-inttypes.h (xisnan (octave_int<T>)): New function.
 	* lo-mappers.h (xisnan (bool), xisnan (char)): New inline functions.
 
 	* CMatrix.cc, CNDArray.cc, CSparse.cc, dMatrix.cc, dNDArray.cc,
diff --git a/liboctave/CmplxQR.cc b/liboctave/CmplxQR.cc
--- a/liboctave/CmplxQR.cc
+++ b/liboctave/CmplxQR.cc
@@ -154,26 +154,26 @@ ComplexQR::init (const ComplexMatrix& a,
       F77_XFCN (zungqr, ZUNGQR, (m, n2, min_mn, tmp_data, m, ptau,
 				 pwork2, lwork, info));
 
       q = A_fact;
       q.resize (m, n2);
     }
 }
 
-ComplexQR::ComplexQR (const ComplexMatrix &q, const ComplexMatrix& r)
+ComplexQR::ComplexQR (const ComplexMatrix& q_arg, const ComplexMatrix& r_arg)
 {
-  if (q.columns () != r.rows ()) 
+  if (q_arg.columns () != r_arg.rows ()) 
     {
       (*current_liboctave_error_handler) ("QR dimensions mismatch");
       return;
     }
 
-  this->q = q;
-  this->r = r;
+  this->q = q_arg;
+  this->r = r_arg;
 }
 
 void
 ComplexQR::update (const ComplexMatrix& u, const ComplexMatrix& v)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
diff --git a/liboctave/Quad.cc b/liboctave/Quad.cc
--- a/liboctave/Quad.cc
+++ b/liboctave/Quad.cc
@@ -155,17 +155,17 @@ DefQuad::do_integrate (octave_idx_type& 
 			   npts, points, abs_tol, rel_tol, result,
 			   abserr, neval, ier, leniw, lenw, last,
 			   piwork, pwork));
 
   return result;
 }
 
 float
-DefQuad::do_integrate (octave_idx_type& ier, octave_idx_type& neval, float& abserr)
+DefQuad::do_integrate (octave_idx_type&, octave_idx_type&, float&)
 {
   (*current_liboctave_error_handler) ("incorrect integration function called");
   return 0.0;
 }
 
 double
 IndefQuad::do_integrate (octave_idx_type& ier, octave_idx_type& neval, double& abserr)
 {
@@ -208,24 +208,24 @@ IndefQuad::do_integrate (octave_idx_type
   F77_XFCN (dqagi, DQAGI, (user_function, bound, inf, abs_tol, rel_tol,
 			   result, abserr, neval, ier, leniw, lenw,
 			   last, piwork, pwork));
 
   return result;
 }
 
 float
-IndefQuad::do_integrate (octave_idx_type& ier, octave_idx_type& neval, float& abserr)
+IndefQuad::do_integrate (octave_idx_type&, octave_idx_type&, float&)
 {
   (*current_liboctave_error_handler) ("incorrect integration function called");
   return 0.0;
 }
 
 double
-FloatDefQuad::do_integrate (octave_idx_type& ier, octave_idx_type& neval, double& abserr)
+FloatDefQuad::do_integrate (octave_idx_type&, octave_idx_type&, double&)
 {
   (*current_liboctave_error_handler) ("incorrect integration function called");
   return 0.0;
 }
 
 float
 FloatDefQuad::do_integrate (octave_idx_type& ier, octave_idx_type& neval, float& abserr)
 {
@@ -251,17 +251,17 @@ FloatDefQuad::do_integrate (octave_idx_t
 			 npts, points, abs_tol, rel_tol, result,
 			 abserr, neval, ier, leniw, lenw, last,
 			 piwork, pwork));
 
   return result;
 }
 
 double
-FloatIndefQuad::do_integrate (octave_idx_type& ier, octave_idx_type& neval, double& abserr)
+FloatIndefQuad::do_integrate (octave_idx_type&, octave_idx_type&, double&)
 {
   (*current_liboctave_error_handler) ("incorrect integration function called");
   return 0.0;
 }
 
 float
 FloatIndefQuad::do_integrate (octave_idx_type& ier, octave_idx_type& neval, float& abserr)
 {
diff --git a/liboctave/dDiagMatrix.cc b/liboctave/dDiagMatrix.cc
--- a/liboctave/dDiagMatrix.cc
+++ b/liboctave/dDiagMatrix.cc
@@ -338,28 +338,29 @@ operator * (const DiagMatrix& a, const D
   return c;
 }
 
 // other operations
 
 ColumnVector
 DiagMatrix::diag (octave_idx_type k) const
 {
+  ColumnVector d;
+
   octave_idx_type nnr = rows ();
   octave_idx_type nnc = cols ();
 
-  if (nnr == 0  || nnc == 0)
+  if (nnr == 0 || nnc == 0)
+    return d;
     
   if (k > 0)
     nnc -= k;
   else if (k < 0)
     nnr += k;
 
-  ColumnVector d;
-
   if (nnr > 0 && nnc > 0)
     {
       octave_idx_type ndiag = (nnr < nnc) ? nnr : nnc;
 
       d.resize (ndiag);
 
       if (k > 0)
 	{
diff --git a/liboctave/dbleQR.cc b/liboctave/dbleQR.cc
--- a/liboctave/dbleQR.cc
+++ b/liboctave/dbleQR.cc
@@ -143,26 +143,26 @@ QR::init (const Matrix& a, QR::type qr_t
       F77_XFCN (dorgqr, DORGQR, (m, n2, min_mn, tmp_data, m, ptau,
 				 pwork2, lwork, info));
 
       q = A_fact;
       q.resize (m, n2);
     }
 }
 
-QR::QR (const Matrix& q, const Matrix& r)
+QR::QR (const Matrix& q_arg, const Matrix& r_arg)
 {
-  if (q.columns () != r.rows ()) 
+  if (q_arg.columns () != r_arg.rows ()) 
     {
       (*current_liboctave_error_handler) ("QR dimensions mismatch");
       return;
     }
 
-  this->q = q;
-  this->r = r;
+  this->q = q_arg;
+  this->r = r_arg;
 }
 
 void
 QR::update (const Matrix& u, const Matrix& v)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
diff --git a/liboctave/fCmplxQR.cc b/liboctave/fCmplxQR.cc
--- a/liboctave/fCmplxQR.cc
+++ b/liboctave/fCmplxQR.cc
@@ -154,26 +154,26 @@ FloatComplexQR::init (const FloatComplex
       F77_XFCN (cungqr, CUNGQR, (m, n2, min_mn, tmp_data, m, ptau,
 				 pwork2, lwork, info));
 
       q = A_fact;
       q.resize (m, n2);
     }
 }
 
-FloatComplexQR::FloatComplexQR (const FloatComplexMatrix &q, const FloatComplexMatrix& r)
+FloatComplexQR::FloatComplexQR (const FloatComplexMatrix& q_arg, const FloatComplexMatrix& r_arg)
 {
-  if (q.columns () != r.rows ()) 
+  if (q_arg.columns () != r_arg.rows ()) 
     {
       (*current_liboctave_error_handler) ("QR dimensions mismatch");
       return;
     }
 
-  this->q = q;
-  this->r = r;
+  this->q = q_arg;
+  this->r = r_arg;
 }
 
 void
 FloatComplexQR::update (const FloatComplexMatrix& u, const FloatComplexMatrix& v)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
diff --git a/liboctave/fDiagMatrix.cc b/liboctave/fDiagMatrix.cc
--- a/liboctave/fDiagMatrix.cc
+++ b/liboctave/fDiagMatrix.cc
@@ -338,28 +338,29 @@ operator * (const FloatDiagMatrix& a, co
   return c;
 }
 
 // other operations
 
 FloatColumnVector
 FloatDiagMatrix::diag (octave_idx_type k) const
 {
+  FloatColumnVector d;
+
   octave_idx_type nnr = rows ();
   octave_idx_type nnc = cols ();
 
   if (nnr == 0  || nnc == 0)
+    return d;
     
   if (k > 0)
     nnc -= k;
   else if (k < 0)
     nnr += k;
 
-  FloatColumnVector d;
-
   if (nnr > 0 && nnc > 0)
     {
       octave_idx_type ndiag = (nnr < nnc) ? nnr : nnc;
 
       d.resize (ndiag);
 
       if (k > 0)
 	{
diff --git a/liboctave/floatQR.cc b/liboctave/floatQR.cc
--- a/liboctave/floatQR.cc
+++ b/liboctave/floatQR.cc
@@ -143,26 +143,26 @@ FloatQR::init (const FloatMatrix& a, QR:
       F77_XFCN (sorgqr, SORGQR, (m, n2, min_mn, tmp_data, m, ptau,
 				 pwork2, lwork, info));
 
       q = A_fact;
       q.resize (m, n2);
     }
 }
 
-FloatQR::FloatQR (const FloatMatrix& q, const FloatMatrix& r)
+FloatQR::FloatQR (const FloatMatrix& q_arg, const FloatMatrix& r_arg)
 {
-  if (q.columns () != r.rows ()) 
+  if (q_arg.columns () != r_arg.rows ()) 
     {
       (*current_liboctave_error_handler) ("QR dimensions mismatch");
       return;
     }
 
-  this->q = q;
-  this->r = r;
+  this->q = q_arg;
+  this->r = r_arg;
 }
 
 void
 FloatQR::update (const FloatMatrix& u, const FloatMatrix& v)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,10 +1,35 @@
 2008-07-11  John W. Eaton  <jwe@octave.org>
 
+	* syscalls.cc (const_value): Delete arg NM.  Change all uses.
+
+	* DLD-FUNCTIONS/fft.cc (do_fft): Avoid GCC warning.
+	* DLD-FUNCTIONS/fft2.cc (do_fft2): Likewise.
+	* DLD-FUNCTIONS/fftn.cc (do_fftn): Likewise.
+	* DLD-FUNCTIONS/qr.cc (Fqrshift): Likewise.
+	* DLD-FUNCTIONS/lookup.cc (Flookup): Likewise.
+	* gl-render.cc (opengl_renderer::draw): Likewise.
+	* graphics.cc (axes::update_axis_limits,
+	hggroup::update_axis_limits, Favailable_backends):
+	Likewise.
+	* pt-cmd.cc (tree_no_op_command::dup, tree_function_def::dup):
+	Likewise.
+	* pt-const.cc (tree_constant::dup): Likewise.
+	* pt-id.cc (tree_identifier::dup): Likewise.
+	* pt-jump.cc (tree_break_command::dup, tree_continue_command::dup,
+	tree_return_command::dup): Likewise.
+
+	* DLD-FUNCTIONS/colamd.cc: Style fixes.
+	(tree_postorder): Rename from TreePostorder.
+	(tree_postorder, coletree): Avoid GCC warnings.
+
+	* DLD-FUNCTIONS/chol.cc (Fchol): Avoid GCC warnings.
+	(Fcholdelete, Fcholshift): Delete unused arg nargout.
+
 	* toplev.cc, toplev.h (octave_call_stack::caller_user_function,
 	octave_call_stack::caller_user_script,
 	octave_call_stack::do_caller_user_function,
 	octave_call_stack::do_caller_user_script):
 	Delete functions and decls. 
 
 	* defun.cc (print_usage): Call octave_call_stack::caller_user_code,
 	not octave_call_stack::caller_user_function.
diff --git a/src/DLD-FUNCTIONS/chol.cc b/src/DLD-FUNCTIONS/chol.cc
--- a/src/DLD-FUNCTIONS/chol.cc
+++ b/src/DLD-FUNCTIONS/chol.cc
@@ -176,20 +176,22 @@ sparse matrices.\n\
 	    {
 	      SparseMatrix m = arg.sparse_matrix_value ();
 
 	      if (! error_state)
 		{
 		  octave_idx_type info;
 		  SparseCHOL fact (m, info, natural);
 		  if (nargout == 3)
-		    if (vecout)
-		      retval(2) = fact.perm ();
-		    else
-		      retval(2) = fact.Q();
+		    {
+		      if (vecout)
+			retval(2) = fact.perm ();
+		      else
+			retval(2) = fact.Q();
+		    }
 
 		  if (nargout > 1 || info == 0)
 		    {
 		      retval(1) = fact.P();
 		      if (LLt)
 			retval(0) = fact.L();
 		      else
 			retval(0) = fact.R();
@@ -203,20 +205,22 @@ sparse matrices.\n\
 	      SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
 
 	      if (! error_state)
 		{
 		  octave_idx_type info;
 		  SparseComplexCHOL fact (m, info, natural);
 
 		  if (nargout == 3)
-		    if (vecout)
-		      retval(2) = fact.perm ();
-		    else
-		      retval(2) = fact.Q();
+		    {
+		      if (vecout)
+			retval(2) = fact.perm ();
+		      else
+			retval(2) = fact.Q();
+		    }
 	  
 		  if (nargout > 1 || info == 0)
 		    {
 		      retval(1) = fact.P();
 		      if (LLt)
 			retval(0) = fact.L();
 		      else
 			retval(0) = fact.R();
@@ -979,17 +983,17 @@ If @var{info} is not present, an error m
 %! j = 3; p = [1:j-1, j+1:5];
 %! R1 = cholinsert(R,j,u2); A1 = R1'*R1;
 %! 
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(A1(p,p) - single(Ac),Inf) < 1e1*eps('single'))
 %! 
 */
 
-DEFUN_DLD (choldelete, args, nargout,
+DEFUN_DLD (choldelete, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{R1} =} choldelete (@var{R}, @var{j})\n\
 Given a Cholesky@tie{}factorization of a real symmetric or complex hermitian\n\
 positive definite matrix @w{@var{A} = @var{R}'*@var{R}}, @var{R}@tie{}upper triangular,\n\
 return the QR@tie{}factorization of @w{A(p,p)}, where @w{p = [1:j-1,j+1:n+1]}.\n\
 @seealso{chol, cholupdate, cholinsert}\n\
 @end deftypefn")
 {
@@ -1111,17 +1115,17 @@ return the QR@tie{}factorization of @w{A
 %! 
 %! j = 3; p = [1:j-1,j+1:4];
 %! R1 = choldelete(R,j);
 %! 
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(R1'*R1 - single(Ac(p,p)),Inf) < 1e1*eps('single'))
 */
 
-DEFUN_DLD (cholshift, args, nargout,
+DEFUN_DLD (cholshift, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{R1} =} cholshift (@var{R}, @var{i}, @var{j})\n\
 Given a Cholesky@tie{}factorization of a real symmetric or complex hermitian\n\
 positive definite matrix @w{@var{A} = @var{R}'*@var{R}}, @var{R}@tie{}upper triangular,\n\
 return the QR@tie{}factorization of\n\
 @w{@var{A}(p,p)}, where @w{p} is the permutation @*\n\
 @code{p = [1:i-1, shift(i:j, 1), j+1:n]} if @w{@var{i} < @var{j}} @*\n\
  or @*\n\
diff --git a/src/DLD-FUNCTIONS/colamd.cc b/src/DLD-FUNCTIONS/colamd.cc
--- a/src/DLD-FUNCTIONS/colamd.cc
+++ b/src/DLD-FUNCTIONS/colamd.cc
@@ -48,19 +48,19 @@ along with Octave; see the file COPYING.
 #define SYMAMD_NAME(name) symamd_l ## name
 #else
 #define COLAMD_NAME(name) colamd ## name
 #define SYMAMD_NAME(name) symamd ## name
 #endif
 
 // The symmetric column elimination tree code take from the Davis LDL code. 
 // Copyright given elsewhere in this file.
-static 
-void symetree (const octave_idx_type *ridx, const octave_idx_type *cidx, 
-	       octave_idx_type *Parent, octave_idx_type *P, octave_idx_type n)
+static void
+symetree (const octave_idx_type *ridx, const octave_idx_type *cidx, 
+	  octave_idx_type *Parent, octave_idx_type *P, octave_idx_type n)
 {
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Flag, n);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Pinv, (P ? n : 0));
   if (P)
     // If P is present then compute Pinv, the inverse of P
     for (octave_idx_type k = 0 ; k < n ; k++)
       Pinv [P [k]] = k ;
 
@@ -86,90 +86,98 @@ void symetree (const octave_idx_type *ri
 		  Flag [i] = k ;	// mark i as visited
 		}
 	    }
 	}
     }
 }
 
 // The elimination tree post-ordering code below is taken from SuperLU
-static inline
-octave_idx_type make_set (octave_idx_type i, octave_idx_type *pp)
+static inline octave_idx_type
+make_set (octave_idx_type i, octave_idx_type *pp)
 {
   pp[i] = i;
   return i;
 }
 
-static inline
-octave_idx_type link (octave_idx_type s, octave_idx_type t, octave_idx_type *pp)
+static inline octave_idx_type
+link (octave_idx_type s, octave_idx_type t, octave_idx_type *pp)
 {
   pp[s] = t;
   return t;
 }
 
-static inline
-octave_idx_type find (octave_idx_type i, octave_idx_type *pp)
+static inline octave_idx_type
+find (octave_idx_type i, octave_idx_type *pp)
 {
   register octave_idx_type p, gp;
     
   p = pp[i];
   gp = pp[p];
-  while (gp != p) {
-    pp[i] = gp;
-    i = gp;
-    p = pp[i];
-    gp = pp[p];
-  }
-  return (p);
+
+  while (gp != p)
+    {
+      pp[i] = gp;
+      i = gp;
+      p = pp[i];
+      gp = pp[p];
+    }
+
+  return p;
 }
 
-static
-octave_idx_type etdfs (octave_idx_type v, octave_idx_type *first_kid, 
-		       octave_idx_type *next_kid, octave_idx_type *post, 
-		       octave_idx_type postnum)
+static octave_idx_type
+etdfs (octave_idx_type v, octave_idx_type *first_kid, 
+       octave_idx_type *next_kid, octave_idx_type *post, 
+       octave_idx_type postnum)
 {
-  for (octave_idx_type w = first_kid[v]; w != -1; w = next_kid[w]) {
+  for (octave_idx_type w = first_kid[v]; w != -1; w = next_kid[w])
     postnum = etdfs (w, first_kid, next_kid, post, postnum);
-  }
+
   post[postnum++] = v;
 
   return postnum;
 }
 
-static
-void TreePostorder(octave_idx_type n, octave_idx_type *parent, octave_idx_type *post)
+static void
+tree_postorder (octave_idx_type n, octave_idx_type *parent,
+		octave_idx_type *post)
 {
   // Allocate storage for working arrays and results
   OCTAVE_LOCAL_BUFFER (octave_idx_type, first_kid, n+1);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, next_kid, n+1);
 
   // Set up structure describing children
-  for (octave_idx_type v = 0; v <= n; first_kid[v++] = -1);
+  for (octave_idx_type v = 0; v <= n; first_kid[v++] = -1)
+    /* do nothing */;
+
   for (octave_idx_type v = n-1; v >= 0; v--) 
     {
       octave_idx_type dad = parent[v];
       next_kid[v] = first_kid[dad];
       first_kid[dad] = v;
     }
 
   // Depth-first search from dummy root vertex #n
   etdfs (n, first_kid, next_kid, post, 0);
 }
 
-static 
-void coletree (const octave_idx_type *ridx, const octave_idx_type *colbeg,
-	       octave_idx_type *colend, octave_idx_type *parent, 
-	       octave_idx_type nr, octave_idx_type nc)
+static void
+coletree (const octave_idx_type *ridx, const octave_idx_type *colbeg,
+	  octave_idx_type *colend, octave_idx_type *parent, 
+	  octave_idx_type nr, octave_idx_type nc)
 {
   OCTAVE_LOCAL_BUFFER (octave_idx_type, root, nc);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, pp, nc);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, firstcol, nr);
 
   // Compute firstcol[row] = first nonzero column in row
-  for (octave_idx_type row = 0; row < nr; firstcol[row++] = nc);
+  for (octave_idx_type row = 0; row < nr; firstcol[row++] = nc)
+    /* do nothing */;
+
   for (octave_idx_type col = 0; col < nc; col++) 
     for (octave_idx_type p = colbeg[col]; p < colend[col]; p++) 
       {
 	octave_idx_type row = ridx[p];
 	if (firstcol[row] > col)
 	  firstcol[row] = col;
       }
 
@@ -395,24 +403,24 @@ Ng, Oak Ridge National Laboratory. (see\
 	{
 	  colbeg[i] = cidx[p[i]];
 	  colend[i] = cidx[p[i]+1];
 	}
 
       coletree (ridx, colbeg, colend, etree, n_row, n_col);
 
       // Calculate the tree post-ordering
-      TreePostorder (n_col, etree, colbeg);
+      tree_postorder (n_col, etree, colbeg);
 
       // return the permutation vector
       NDArray out_perm (dim_vector (1, n_col));
       for (octave_idx_type i = 0; i < n_col; i++)
 	out_perm(i) = p [colbeg [i]] + 1;
 
-      retval (0) = out_perm;
+      retval(0) = out_perm;
 
       // print stats if spumoni > 0
       if (spumoni > 0)
 	COLAMD_NAME (_report) (stats) ;
 
       // Return the stats vector
       if (nargout == 2)
 	{
@@ -592,24 +600,24 @@ Ng, Oak Ridge National Laboratory. (see\
 	}
 
       // column elimination tree post-ordering
       OCTAVE_LOCAL_BUFFER (octave_idx_type, etree, n_col + 1);
       symetree (ridx, cidx, etree, perm, n_col);
 
       // Calculate the tree post-ordering
       OCTAVE_LOCAL_BUFFER (octave_idx_type, post, n_col + 1);
-      TreePostorder (n_col, etree, post);
+      tree_postorder (n_col, etree, post);
 
       // return the permutation vector
       NDArray out_perm (dim_vector (1, n_col));
       for (octave_idx_type i = 0; i < n_col; i++)
 	out_perm(i) = perm [post [i]] + 1;
 
-      retval (0) = out_perm;
+      retval(0) = out_perm;
 
       // print stats if spumoni > 0
       if (spumoni > 0)
 	SYMAMD_NAME (_report) (stats) ;
 
       // Return the stats vector
       if (nargout == 2)
 	{
@@ -702,27 +710,28 @@ permutations on the tree.\n\
 		is_sym = false;
 	    }
 	  else
 	    {
 	      error ("etree: second argument must be a string");
 	      return retval;
 	    }
 	}
+
       // column elimination tree post-ordering (reuse variables)
       OCTAVE_LOCAL_BUFFER (octave_idx_type, etree, n_col + 1);
-      
 
       if (is_sym)
 	{
 	  if (n_row != n_col)
 	    {
 	      error ("etree: matrix is marked as symmetric, but not square");
 	      return retval;
 	    }
+
 	  symetree (ridx, cidx, etree, 0, n_col);
 	}
       else
 	{
 	  OCTAVE_LOCAL_BUFFER (octave_idx_type, colbeg, n_col);
 	  OCTAVE_LOCAL_BUFFER (octave_idx_type, colend, n_col);
 
 	  for (octave_idx_type i = 0; i < n_col; i++)
@@ -734,33 +743,33 @@ permutations on the tree.\n\
 	  coletree (ridx, colbeg, colend, etree, n_row, n_col);
 	}
 
       NDArray tree (dim_vector (1, n_col));
       for (octave_idx_type i = 0; i < n_col; i++)
 	// We flag a root with n_col while Matlab does it with zero
 	// Convert for matlab compatiable output
 	if (etree[i] == n_col)
-	  tree (i) = 0;
+	  tree(i) = 0;
 	else
-	  tree (i) = etree[i] + 1;
+	  tree(i) = etree[i] + 1;
 
-      retval (0) = tree;
+      retval(0) = tree;
 
       if (nargout == 2)
 	{
 	  // Calculate the tree post-ordering
 	  OCTAVE_LOCAL_BUFFER (octave_idx_type, post, n_col + 1);
-	  TreePostorder (n_col, etree, post);
+	  tree_postorder (n_col, etree, post);
 
 	  NDArray postorder (dim_vector (1, n_col));
 	  for (octave_idx_type i = 0; i < n_col; i++)
-	    postorder (i) = post[i] + 1;
+	    postorder(i) = post[i] + 1;
 
-	  retval (1) = postorder;
+	  retval(1) = postorder;
 	}
     }
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/DLD-FUNCTIONS/fft.cc b/src/DLD-FUNCTIONS/fft.cc
--- a/src/DLD-FUNCTIONS/fft.cc
+++ b/src/DLD-FUNCTIONS/fft.cc
@@ -110,20 +110,22 @@ do_fft (const octave_value_list &args, c
     }
 
   if (n_points < 0)
     n_points = dims (dim);
   else
     dims (dim) = n_points;
 
   if (dims.any_zero () || n_points == 0)
-    if (arg.is_single_type ())
-      return octave_value (FloatNDArray (dims));
-    else
-      return octave_value (NDArray (dims));
+    {
+      if (arg.is_single_type ())
+	return octave_value (FloatNDArray (dims));
+      else
+	return octave_value (NDArray (dims));
+    }
 
   if (arg.is_single_type ())
     {
       if (arg.is_real_type ())
 	{
 	  FloatNDArray nda = arg.float_array_value ();
 
 	  if (! error_state)
diff --git a/src/DLD-FUNCTIONS/fft2.cc b/src/DLD-FUNCTIONS/fft2.cc
--- a/src/DLD-FUNCTIONS/fft2.cc
+++ b/src/DLD-FUNCTIONS/fft2.cc
@@ -101,20 +101,22 @@ do_fft2 (const octave_value_list &args, 
     dims (0) = n_rows;
 
   if (n_cols < 0)
     n_cols = dims (1);
   else
     dims (1) = n_cols;
 
   if (dims.all_zero () || n_rows == 0 || n_cols == 0)
-    if (arg.is_single_type ())
-      return octave_value (FloatMatrix ());
-    else
-      return octave_value (Matrix ());
+    {
+      if (arg.is_single_type ())
+	return octave_value (FloatMatrix ());
+      else
+	return octave_value (Matrix ());
+    }
 
   if (arg.is_single_type ())
     {
       if (arg.is_real_type ())
 	{
 	  FloatNDArray nda = arg.float_array_value ();
 
 	  if (! error_state)
diff --git a/src/DLD-FUNCTIONS/fftn.cc b/src/DLD-FUNCTIONS/fftn.cc
--- a/src/DLD-FUNCTIONS/fftn.cc
+++ b/src/DLD-FUNCTIONS/fftn.cc
@@ -83,20 +83,22 @@ do_fftn (const octave_value_list &args, 
 	    }
 	}
     }
 
   if (error_state)
     return retval;
 
   if (dims.all_zero ())
-    if (arg.is_single_type ())
-      return octave_value (FloatMatrix ());
-    else
-      return octave_value (Matrix ());
+    {
+      if (arg.is_single_type ())
+	return octave_value (FloatMatrix ());
+      else
+	return octave_value (Matrix ());
+    }
 
   if (arg.is_single_type ())
     {
       if (arg.is_real_type ())
 	{
 	  FloatNDArray nda = arg.float_array_value ();
 
 	  if (! error_state)
diff --git a/src/DLD-FUNCTIONS/lookup.cc b/src/DLD-FUNCTIONS/lookup.cc
--- a/src/DLD-FUNCTIONS/lookup.cc
+++ b/src/DLD-FUNCTIONS/lookup.cc
@@ -223,17 +223,17 @@ For string lookup, 'i' indicates case-in
       retval(0) = NDArray (idx);
     }
   else if (str_case)
     {
       Cell table = argtable.cell_value ();
       
       bool (*ov_str_comp) (const octave_value&, const octave_value&);
 
-      bool icase = false, desc;
+      bool icase = false;
 
       // check for case-insensitive option
       if (nargin == 3)
         {
           std::string opt = args(2).string_value ();
           icase = contains_char (opt, 'i');
         }
 
diff --git a/src/DLD-FUNCTIONS/qr.cc b/src/DLD-FUNCTIONS/qr.cc
--- a/src/DLD-FUNCTIONS/qr.cc
+++ b/src/DLD-FUNCTIONS/qr.cc
@@ -1424,17 +1424,16 @@ of @w{@var{A}(:,p)}, where @w{p} is the 
   octave_value argq = args(0);
   octave_value argr = args(1);
   octave_value argi = args(2);
   octave_value argj = args(3);
 
   if (argq.is_matrix_type () && argr.is_matrix_type () 
       && argi.is_real_scalar () && argj.is_real_scalar ())
     {
-      octave_idx_type m = argq.rows ();
       octave_idx_type n = argr.columns ();
       octave_idx_type k = argq.columns ();
 
       if (argr.rows () == k)
         {
           octave_idx_type i = argi.scalar_value ();
           octave_idx_type j = argj.scalar_value ();
           if (i > 1 && i <= n && j > 1 && j <= n)
diff --git a/src/gl-render.cc b/src/gl-render.cc
--- a/src/gl-render.cc
+++ b/src/gl-render.cc
@@ -2293,17 +2293,17 @@ opengl_renderer::draw (const patch::prop
 
   if (fa_mode > 0 || ea_mode > 0)
     {
       // FIXME: retrieve alpha data from patch object
       //a = props.get_alpha_data ();
       has_facealpha = ((a.numel () > 0) && (a.rows () == f.rows ()));
     }
 
-  octave_idx_type fr = f.rows (), fc = f.columns ();
+  octave_idx_type fr = f.rows ();
   std::vector<vertex_data> vdata (f.numel ());
 
   for (int i = 0; i < nf; i++)
     for (int j = 0; j < count_f(i); j++)
       {
 	int idx = int (f(i,j) - 1);
 
 	Matrix vv (1, 3, 0.0);
diff --git a/src/graphics.cc b/src/graphics.cc
--- a/src/graphics.cc
+++ b/src/graphics.cc
@@ -3155,18 +3155,16 @@ static bool updating_axis_limits = false
 void
 axes::update_axis_limits (const std::string& axis_type)
 {
   if (updating_axis_limits)
     return;
 
   Matrix kids = xproperties.get_children ();
 
-  octave_idx_type n = kids.numel ();
-
   double min_val = octave_Inf;
   double max_val = -octave_Inf;
   double min_pos = octave_Inf;
 
   char update_type = 0;
 
   Matrix limits;
 
@@ -3486,18 +3484,16 @@ surface::properties::update_normals (voi
 
 // ---------------------------------------------------------------------
 
 void
 hggroup::update_axis_limits (const std::string& axis_type)
 {
   Matrix kids = xproperties.get_children ();
 
-  octave_idx_type n = kids.numel ();
-
   double min_val = octave_Inf;
   double max_val = -octave_Inf;
   double min_pos = octave_Inf;
 
   char update_type = 0;
 
   if (axis_type == "xlim")
     {
@@ -4167,17 +4163,17 @@ DEFUN (__go_figure_handles__, , ,
    "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __go_figure_handles__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   return octave_value (gh_manager::figure_handle_list ());
 }
 
-DEFUN (available_backends, args, ,
+DEFUN (available_backends, , ,
    "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} available_backends ()\n\
 Returns resgistered graphics backends.\n\
 @end deftypefn")
 {
   return octave_value (graphics_backend::available_backends_list ());
 }
 
diff --git a/src/pt-cmd.cc b/src/pt-cmd.cc
--- a/src/pt-cmd.cc
+++ b/src/pt-cmd.cc
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 
 #include "pt-cmd.h"
 #include "pt-walk.h"
 
 // No-op.
 
 tree_command *
 tree_no_op_command::dup (symbol_table::scope_id,
-			 symbol_table::context_id context)
+			 symbol_table::context_id /*context*/)
 {
   return new tree_no_op_command (orig_cmd, line (), column ());
 }
 
 void
 tree_no_op_command::accept (tree_walker& tw)
 {
   tw.visit_no_op_command (*this);
@@ -60,17 +60,17 @@ tree_function_def::eval (void)
       // function is cleared.
 
       symbol_table::varref (nm) = octave_value ();
     }
 }
 
 tree_command *
 tree_function_def::dup (symbol_table::scope_id,
-			symbol_table::context_id context)
+			symbol_table::context_id /*context*/)
 {
   return new tree_function_def (fcn, line (), column ());
 }
 
 void
 tree_function_def::accept (tree_walker& tw)
 {
   tw.visit_function_def (*this);
diff --git a/src/pt-const.cc b/src/pt-const.cc
--- a/src/pt-const.cc
+++ b/src/pt-const.cc
@@ -67,17 +67,17 @@ tree_constant::rvalue (int nargout)
   else
     retval = rvalue ();
 
   return retval;
 }
 
 tree_expression *
 tree_constant::dup (symbol_table::scope_id,
-		    symbol_table::context_id context)
+		    symbol_table::context_id /*context*/)
 {
   tree_constant *new_tc
     = new tree_constant (val, orig_text, line (), column ());
 
   new_tc->copy_base (*this);
 
   return new_tc;
 }
diff --git a/src/pt-id.cc b/src/pt-id.cc
--- a/src/pt-id.cc
+++ b/src/pt-id.cc
@@ -115,17 +115,17 @@ tree_identifier::rvalue (void)
 octave_lvalue
 tree_identifier::lvalue (void)
 {
   return octave_lvalue (&(xsym().varref ()));
 }
 
 tree_identifier *
 tree_identifier::dup (symbol_table::scope_id sc,
-		      symbol_table::context_id context)
+		      symbol_table::context_id /*context*/)
 {
   // The new tree_identifier object contains a symbol_record
   // entry from the duplicated scope.
 
   // FIXME -- is this the best way?
   symbol_table::symbol_record new_sym
     = symbol_table::find_symbol (xsym().name (), sc);
 
diff --git a/src/pt-jump.cc b/src/pt-jump.cc
--- a/src/pt-jump.cc
+++ b/src/pt-jump.cc
@@ -45,17 +45,17 @@ tree_break_command::eval (void)
   MAYBE_DO_BREAKPOINT;
 
   if (! error_state)
     breaking = 1;
 }
 
 tree_command *
 tree_break_command::dup (symbol_table::scope_id,
-			 symbol_table::context_id context)
+			 symbol_table::context_id /*context*/)
 {
   return new tree_break_command (line (), column ());
 }
 
 void
 tree_break_command::accept (tree_walker& tw)
 {
   tw.visit_break_command (*this);
@@ -72,17 +72,17 @@ tree_continue_command::eval (void)
   MAYBE_DO_BREAKPOINT;
 
   if (! error_state)
     continuing = 1;
 }
 
 tree_command *
 tree_continue_command::dup (symbol_table::scope_id,
-			    symbol_table::context_id context)
+			    symbol_table::context_id /*context*/)
 {
   return new tree_continue_command (line (), column ());
 }
 
 void
 tree_continue_command::accept (tree_walker& tw)
 {
   tw.visit_continue_command (*this);
@@ -99,17 +99,17 @@ tree_return_command::eval (void)
   MAYBE_DO_BREAKPOINT;
 
   if (! error_state)
     returning = 1;
 }
 
 tree_command *
 tree_return_command::dup (symbol_table::scope_id,
-			  symbol_table::context_id context)
+			  symbol_table::context_id /*context*/)
 {
   return new tree_return_command (line (), column ());
 }
 
 void
 tree_return_command::accept (tree_walker& tw)
 {
   tw.visit_return_command (*this);
diff --git a/src/syscalls.cc b/src/syscalls.cc
--- a/src/syscalls.cc
+++ b/src/syscalls.cc
@@ -1591,17 +1591,17 @@ Return the canonical name of file @var{n
     }
   else
     print_usage ();
 
   return retval;
 }
 
 static octave_value
-const_value (const char *nm, const octave_value_list& args, int val)
+const_value (const octave_value_list& args, int val)
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     retval = val;
   else
@@ -1618,257 +1618,257 @@ const_value (const char *nm, const octav
 DEFUNX ("F_DUPFD", FF_DUPFD, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} F_DUPFD ()\n\
 Return the value required to request that @code{fcntl} return a\n\
 duplicate file descriptor.\n\
 @seealso{fcntl, F_GETFD, F_GETFL, F_SETFD, F_SETFL}\n\
 @end deftypefn")
 {
-  return const_value ("F_DUPFD", args, F_DUPFD);
+  return const_value (args, F_DUPFD);
 }
 #endif
 
 #if defined (F_GETFD)
 DEFUNX ("F_GETFD", FF_GETFD, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} F_GETFD ()\n\
 Return the value required to request that @code{fcntl} to return the\n\
 file descriptor flags.\n\
 @seealso{fcntl, F_DUPFD, F_GETFL, F_SETFD, F_SETFL}\n\
 @end deftypefn")
 {
-  return const_value ("F_GETFD", args, F_GETFD);
+  return const_value (args, F_GETFD);
 }
 #endif
 
 #if defined (F_GETFL)
 DEFUNX ("F_GETFL", FF_GETFL, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} F_GETFL ()\n\
 Return the value required to request that @code{fcntl} to return the\n\
 file status flags.\n\
 @seealso{fcntl, F_DUPFD, F_GETFD, F_SETFD, F_SETFL}\n\
 @end deftypefn")
 {
-  return const_value ("F_GETFL", args, F_GETFL);
+  return const_value (args, F_GETFL);
 }
 #endif
 
 #if defined (F_SETFD)
 DEFUNX ("F_SETFD", FF_SETFD, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} F_SETFD ()\n\
 Return the value required to request that @code{fcntl} to set the file\n\
 descriptor flags.\n\
 @seealso{fcntl, F_DUPFD, F_GETFD, F_GETFL, F_SETFL}\n\
 @end deftypefn")
 {
-  return const_value ("F_SETFD", args, F_SETFD);
+  return const_value (args, F_SETFD);
 }
 #endif
 
 #if defined (F_SETFL)
 DEFUNX ("F_SETFL", FF_SETFL, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} F_SETFL ()\n\
 Return the value required to request that @code{fcntl} to set the file\n\
 status flags.\n\
 @seealso{fcntl, F_DUPFD, F_GETFD, F_GETFL, F_SETFD}\n\
 @end deftypefn")
 {
-  return const_value ("F_SETFL", args, F_SETFL);
+  return const_value (args, F_SETFL);
 }
 #endif
 
 #if defined (O_APPEND)
 DEFUNX ("O_APPEND", FO_APPEND, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_APPEND ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate each write operation appends,\n\
 or that may be passed to @code{fcntl} to set the write mode to append.\
 @seealso{fcntl, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
-  return const_value ("O_APPEND", args, O_APPEND);
+  return const_value (args, O_APPEND);
 }
 #endif
 
 #if defined (O_ASYNC)
 DEFUNX ("O_ASYNC", FO_ASYNC, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_ASYNC ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate asynchronous I/O.\n\
 @seealso{fcntl, O_APPEND, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
-  return const_value ("O_ASYNC", args, O_ASYNC);
+  return const_value (args, O_ASYNC);
 }
 #endif
 
 #if defined (O_CREAT)
 DEFUNX ("O_CREAT", FO_CREAT, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_CREAT ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that a file should be\n\
 created if it does not exist.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
-  return const_value ("O_CREAT", args, O_CREAT);
+  return const_value (args, O_CREAT);
 }
 #endif
 
 #if defined (O_EXCL)
 DEFUNX ("O_EXCL", FO_EXCL, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_EXCL ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that file locking is used.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
-  return const_value ("O_EXCL", args, O_EXCL);
+  return const_value (args, O_EXCL);
 }
 #endif
 
 #if defined (O_NONBLOCK)
 DEFUNX ("O_NONBLOCK", FO_NONBLOCK, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_NONBLOCK ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that non-blocking I/O is in use,\n\
 or that may be passsed to @code{fcntl} to set non-blocking I/O.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
-  return const_value ("O_NONBLOCK", args, O_NONBLOCK);
+  return const_value (args, O_NONBLOCK);
 }
 #endif
 
 #if defined (O_RDONLY)
 DEFUNX ("O_RDONLY", FO_RDONLY, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_RDONLY ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that a file is open for\n\
 reading only.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
-  return const_value ("O_RDONLY", args, O_RDONLY);
+  return const_value (args, O_RDONLY);
 }
 #endif
 
 #if defined (O_RDWR)
 DEFUNX ("O_RDWR", FO_RDWR, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_RDWR ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that a file is open for both\n\
 reading and writing.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
-  return const_value ("O_RDWR", args, O_RDWR);
+  return const_value (args, O_RDWR);
 }
 #endif
 
 #if defined (O_SYNC)
 DEFUNX ("O_SYNC", FO_SYNC, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_SYNC ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that a file is open for\n\
 synchronous I/O.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
-  return const_value ("O_SYNC", args, O_SYNC);
+  return const_value (args, O_SYNC);
 }
 #endif
 
 #if defined (O_TRUNC)
 DEFUNX ("O_TRUNC", FO_TRUNC, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Variable} O_TRUNC ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that if file exists, it should\n\
 be truncated when writing.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_WRONLY}\n\
 @end deftypefn")
 {
-  return const_value ("O_TRUNC", args, O_TRUNC);
+  return const_value (args, O_TRUNC);
 }
 #endif
 
 #if defined (O_WRONLY)
 DEFUNX ("O_WRONLY", FO_WRONLY, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_WRONLY ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that a file is open for\n\
 writing only.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC}\n\
 @end deftypefn")
 {
-  return const_value ("O_WRONLY", args, O_WRONLY);
+  return const_value (args, O_WRONLY);
 }
 #endif
 
 #if !defined (WNOHANG)
 #define WNOHANG 0
 #endif
 
 DEFUNX ("WNOHANG", FWNOHANG, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} WNOHANG ()\n\
 Return the numerical value of the option argument that may be\n\
 passed to @code{waitpid} to indicate that it should return its\n\
 status immediately instead of waiting for a process to exit.\n\
 @seealso{waitpid, WUNTRACED, WCONTINUE}\n\
 @end deftypefn")
 {
-  return const_value ("WNOHANG", args, WNOHANG);
+  return const_value (args, WNOHANG);
 }
 
 #if !defined (WUNTRACED)
 #define WUNTRACED 0
 #endif
 
 DEFUNX ("WUNTRACED", FWUNTRACED, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} WUNTRACED ()\n\
 Return the numerical value of the option argument that may be\n\
 passed to @code{waitpid} to indicate that it should also return\n\
 if the child process has stopped but is not traced via the\n\
 @code{ptrace} system call\n\
 @seealso{waitpid, WNOHANG, WCONTINUE}\n\
 @end deftypefn")
 {
-  return const_value ("WUNTRACED", args, WUNTRACED);
+  return const_value (args, WUNTRACED);
 }
 
 #if !defined (WCONTINUE)
 #define WCONTINUE 0
 #endif
 
 DEFUNX ("WCONTINUE", FWCONTINUE, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} WCONINTUE ()\n\
 Return the numerical value of the option argument that may be\n\
 passed to @code{waitpid} to indicate that it should also return\n\
 if a stopped child has been resumed by delivery of a @code{SIGCONT}\n\
 signal.\n\
 @seealso{waitpid, WNOHANG, WUNTRACED}\n\
 @end deftypefn")
 {
-  return const_value ("WCONTINUE", args, WCONTINUE);
+  return const_value (args, WCONTINUE);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
