# HG changeset patch
# User Kai T. Ohlhus <k.ohlhus@gmail.com>
# Date 1480686729 -3600
#      Fri Dec 02 14:52:09 2016 +0100
# Node ID d5b58e234c37b40a4a24dfb3e8f5aa663eccacf1
# Parent  f9fdd2f6651435f9e66789207e290a4c1ab5fd1e
lex.h: Remove wrapper class "token_cache" for std::deque.

* libinterp/parse-tree/lex.h: Remove wrapper class "token_cache".  It contains
lots of never used functions and it all boild down to the basic usage of
std::deque in combination with checks for emptyness.  The size restriction
is now managed by the STL container (as it would happen anyway, because
std::deque was wrapped).

* libinterp/parse-tree/lex.h: Update the only usages of that class and clarify
the code mostly to single lines.

diff --git a/libinterp/parse-tree/lex.h b/libinterp/parse-tree/lex.h
--- a/libinterp/parse-tree/lex.h
+++ b/libinterp/parse-tree/lex.h
@@ -172,98 +172,16 @@ namespace octave
           context.pop ();
       }
 
     private:
 
       std::stack<int> context;
     };
 
-    class token_cache
-    {
-    public:
-
-      // Store an "unlimited" number of tokens.
-      token_cache (size_t sz_arg = std::numeric_limits<size_t>::max ())
-        : buffer (), sz (sz_arg)
-      { }
-
-      void push (token *tok)
-      {
-        if (buffer.size () == sz)
-          pop ();
-
-        buffer.push_front (tok);
-      }
-
-      void pop (void)
-      {
-        if (! empty ())
-          {
-            delete buffer.back ();
-            buffer.pop_back ();
-          }
-      }
-
-      // Direct access.
-      token *at (size_t n)
-      {
-        return empty () ? 0 : buffer.at (n);
-      }
-
-      const token *at (size_t n) const
-      {
-        return empty () ? 0 : buffer.at (n);
-      }
-
-      // Most recently pushed.
-      token *front (void)
-      {
-        return empty () ? 0 : buffer.front ();
-      }
-
-      const token *front (void) const
-      {
-        return empty () ? 0 : buffer.front ();
-      }
-
-      token *back (void)
-      {
-        return empty () ? 0 : buffer.back ();
-      }
-
-      const token *back (void) const
-      {
-        return empty () ? 0 : buffer.back ();
-      }
-
-      // Number of elements currently in the buffer, max of sz.
-      size_t size (void) const { return buffer.size (); }
-
-      bool empty (void) const { return buffer.empty (); }
-
-      void clear (void)
-      {
-        while (! empty ())
-          pop ();
-      }
-
-    private:
-
-      std::deque<token *> buffer;
-
-      size_t sz;
-
-      // No copying!
-
-      token_cache (const token_cache&);
-
-      token_cache& operator = (const token_cache&);
-    };
-
     lexical_feedback (void)
       : end_of_input (false), at_beginning_of_statement (true),
         looking_at_anon_fcn_args (false), looking_at_return_list (false),
         looking_at_parameter_list (false), looking_at_decl_list (false),
         looking_at_initializer_expression (false),
         looking_at_matrix_or_assign_lhs (false),
         looking_for_object_index (false),
         looking_at_indirect_ref (false), parsing_class_method (false),
@@ -447,17 +365,17 @@ namespace octave
     // Track current symbol table scope and context.
     symbol_table_context symtab_context;
 
     // is the closest nesting level a square bracket, squiggly brace,
     // a paren, or an anonymous function body?
     bbp_nesting_level nesting_level;
 
     // Tokens generated by the lexer.
-    token_cache tokens;
+    std::deque<token *> tokens;
 
   private:
 
     // No copying!
 
     lexical_feedback (const lexical_feedback&);
 
     lexical_feedback& operator = (const lexical_feedback&);
@@ -847,9 +765,8 @@ namespace octave
 
     push_lexer (const push_lexer&);
 
     push_lexer& operator = (const push_lexer&);
   };
 }
 
 #endif
-
diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -2140,40 +2140,36 @@ namespace octave
     symtab_context.clear ();
     nesting_level.reset ();
     tokens.clear ();
   }
 
   int
   lexical_feedback::previous_token_value (void) const
   {
-    const token *tok = tokens.front ();
-    return tok ? tok->token_value () : 0;
+    return tokens.empty () ? 0 : tokens.front ()->token_value ();
   }
 
   bool
   lexical_feedback::previous_token_value_is (int tok_val) const
   {
-    const token *tok = tokens.front ();
-    return tok ? tok->token_value_is (tok_val) : false;
+    return tokens.empty () ? false : tokens.front ()->token_value_is (tok_val);
   }
 
   void
   lexical_feedback::mark_previous_token_trailing_space (void)
   {
-    token *tok = tokens.front ();
-    if (tok && ! previous_token_value_is ('\n'))
-      tok->mark_trailing_space ();
+    if (! tokens.empty () && ! previous_token_value_is ('\n'))
+      tokens.front ()->mark_trailing_space ();
   }
 
   bool
   lexical_feedback::space_follows_previous_token (void) const
   {
-    const token *tok = tokens.front ();
-    return tok ? tok->space_follows_token () : false;
+    return tokens.empty () ? false : tokens.front ()->space_follows_token ();
   }
 
   bool
   lexical_feedback::previous_token_is_binop (void) const
   {
     int tok = previous_token_value ();
 
     return (tok == '+' || tok == '-' || tok == '@'
@@ -2189,34 +2185,35 @@ namespace octave
             || tok == EXPR_OR_OR || tok == LEFTDIV || tok == LEFTDIV_EQ
             || tok == MUL_EQ || tok == OR_EQ || tok == POW
             || tok == POW_EQ || tok == SUB_EQ);
   }
 
   bool
   lexical_feedback::previous_token_is_keyword (void) const
   {
-    const token *tok = tokens.front ();
-    return tok ? tok->is_keyword () : false;
+    return tokens.empty () ? false : tokens.front ()->is_keyword ();
   }
 
   bool
   lexical_feedback::previous_token_may_be_command (void) const
   {
-    const token *tok = tokens.front ();
-    return tok ? tok->may_be_command () : false;
+    return tokens.empty () ? false : tokens.front ()->may_be_command ();
   }
 
   void
   lexical_feedback::maybe_mark_previous_token_as_variable (void)
   {
-    token *tok = tokens.front ();
-
-    if (tok && tok->is_symbol ())
-      pending_local_variables.insert (tok->symbol_name ());
+    if (! tokens.empty ())
+    {
+      token *tok = tokens.front ();
+
+      if (tok->is_symbol ())
+        pending_local_variables.insert (tok->symbol_name ());
+    }
   }
 
   void
   lexical_feedback::mark_as_variables (const std::list<std::string>& lst)
   {
     for (std::list<std::string>::const_iterator p = lst.begin ();
          p != lst.end (); p++)
       {
@@ -3198,17 +3195,17 @@ namespace octave
     warn_language_extension (t + " used as operator");
   }
 
   void
   base_lexer::push_token (token *tok)
   {
     YYSTYPE *lval = yyget_lval (scanner);
     lval->tok_val = tok;
-    tokens.push (tok);
+    tokens.push_front (tok);
   }
 
   token *
   base_lexer::current_token (void)
   {
     YYSTYPE *lval = yyget_lval (scanner);
     return lval->tok_val;
   }
