# HG changeset patch
# User Rik <rik@octave.org>
# Date 1482470570 28800
#      Thu Dec 22 21:22:50 2016 -0800
# Node ID c3428bb9aca9a0f8bc5351a2ab4b6211e8d17c06
# Parent  8133da976602da67b0a7515faaf6a755d87aef6f
ode15i.m, ode15s.m: Follow Octave coding conventions.

* ode15i.m, ode15s.m: Use double quotes instead of single quotes.  Wrap lines >
80 characters.  Simplify calls to error() by placing name of field in error
string rather than using '%s'.  Use space between function name and opening
parenthesis.  End fail() lines with semicolon.

diff --git a/scripts/ode/ode15i.m b/scripts/ode/ode15i.m
--- a/scripts/ode/ode15i.m
+++ b/scripts/ode/ode15i.m
@@ -23,17 +23,18 @@
 ## @deftypefnx {} {@var{solution} =} ode15i (@dots{})
 ##
 ## Solve a set of full-implicit Ordinary Differential Equations and
 ## Differential Algebraic Equations (DAEs) of index 1, with the variable-step,
 ## variable order BDF (Backward Differentiation Formula) method, which
 ## ranges from order 1 to 5.
 ##
 ## @var{fun} is a function handle, inline function, or string containing the
-## name of the function that defines the ODE: @code{f(@var{t},@var{y},@var{yp})}.
+## name of the function that defines the ODE:
+## @code{f(@var{t},@var{y},@var{yp})}.
 ## The function must accept three inputs where the first is time @var{t}, the
 ## second is a column vector of unknowns @var{y} and the third is a column
 ## vector of unknowns @var{yp}.
 ##
 ## @var{trange} specifies the time interval over which the ODE will be
 ## evaluated.  Typically, it is a two-element vector specifying the initial and
 ## final times (@code{[tinit, tfinal]}).  If there are more than two elements
 ## then the solution will also be evaluated at these intermediate time.
@@ -87,17 +88,17 @@
 ## [@var{t},@var{y}] = ode15i (@@robertsidae, [0 1e3], [1; 0; 0], [-1e-4; 1e-4; 0]);
 ## @end group
 ## @end example
 ## @seealso{decic, odeset, odeget}
 ## @end deftypefn
 
 function varargout = ode15i (fun, trange, y0, yp0, varargin)
 
-  solver = 'ode15i';
+  solver = "ode15i";
 
   if (nargin < 4)
     print_usage ();
   endif
 
   n = numel (y0);
 
   if (nargin > 4)
@@ -113,126 +114,123 @@ function varargout = ode15i (fun, trange
     if (ischar (options.Jacobian))
       try
         options.Jacobian = str2func (options.Jacobian);
       catch
         warning (lasterr);
       end_try_catch
       if (! isa (options.Jacobian, "function_handle"))
         error ("Octave:invalid-input-arg",
-               [solver ": invalid value assigned to field '%s'"], "Jacobian");
+               [solver ": invalid value assigned to field 'Jacobian'"]);
       endif
     endif
   endif
 
   if (! isempty (options.OutputFcn))
     if (ischar (options.OutputFcn))
       try
         options.OutputFcn = str2func (options.OutputFcn);
       catch
         warning (lasterr);
       end_try_catch
       if (! isa (options.OutputFcn, "function_handle"))
         error ("Octave:invalid-input-arg",
-               [solver ": invalid value assigned to field '%s'"], "OutputFcn");
+               [solver ": invalid value assigned to field 'OutputFcn'");
       endif
     endif
   endif
 
   if (! isempty (options.Events))
     if (ischar (options.Events))
       try
         options.Events = str2func (options.Events);
       catch
         warning (lasterr);
       end_try_catch
-      if (! isa (options.Events, "function_handle") && ! ismatrix (options.Events))
+      if (! isa (options.Events, "function_handle")
+          && ! ismatrix (options.Events))
         error ("Octave:invalid-input-arg",
-               [solver ": invalid value assigned to field '%s'"], "Events");
+               [solver ": invalid value assigned to field 'Events'");
       endif
     endif
   endif
 
-  [defaults, classes, attributes] = ...
-  odedefaults (n, trange(1), trange(end));
+  [defaults, classes, attributes] = odedefaults (n, trange(1), trange(end));
 
   persistent ignorefields = {"NonNegative", "Mass", ...
                              "MStateDependence", "MvPattern", ...
                              "MassSingular", "InitialSlope", "BDF"};
 
   defaults   = rmfield (defaults, ignorefields);
   classes    = rmfield (classes, ignorefields);
   attributes = rmfield (attributes, ignorefields);
 
-  classes        = odeset (classes, 'Vectorized', {});
-  attributes     = ...
-  odeset (attributes, 'Jacobian', {}, 'Vectorized', {});
+  classes    = odeset (classes, "Vectorized", {});
+  attributes = odeset (attributes, "Jacobian", {}, "Vectorized", {});
 
-  options = ...
-  odemergeopts ("ode15i", options, defaults,
-                classes, attributes, solver);
+  options = odemergeopts ("ode15i", options, defaults,
+                          classes, attributes, solver);
 
   ## Jacobian
   options.havejac       = false;
   options.havejacsparse = false;
   options.havejacfun    = false;
 
   if (! isempty (options.Jacobian))
     options.havejac = true;
     if (iscell (options.Jacobian))
       if (numel (options.Jacobian) == 2)
-        if (issparse (options.Jacobian{1}) && issparse (options.Jacobian{2})) ## Jac is sparse cell
-          options.havejacsparse = true;
+        if (issparse (options.Jacobian{1}) && issparse (options.Jacobian{2}))
+          options.havejacsparse = true;  # Jac is sparse cell
         endif
 
         if (any (size (options.Jacobian{1}) != [n n])
             || any (size (options.Jacobian{2}) != [n n])
             || ! isnumeric (options.Jacobian{1})
             || ! isnumeric (options.Jacobian{2})
             || ! isreal (options.Jacobian{1})
             || ! isreal (options.Jacobian{2}))
           error ("Octave:invalid-input-arg",
-               [solver ": invalid value assigned to field '%s'"], "Jacobian");
+                 [solver ": invalid value assigned to field 'Jacobian'");
         endif
       else
         error ("Octave:invalid-input-arg",
-               [solver ": invalid value assigned to field '%s'"], "Jacobian");
+               [solver ": invalid value assigned to field 'Jacobian'");
       endif
 
     elseif (isa (options.Jacobian, "function_handle"))
       options.havejacfun = true;
       if (nargin (options.Jacobian) == 3)
         [A, B] = options.Jacobian (trange(1), y0, yp0);
         if (issparse (A) && issparse (B))
-          options.havejacsparse = true;  ## Jac is sparse fun
+          options.havejacsparse = true;  # Jac is sparse fun
         endif
 
         if (any (size (A) != [n n]) || any (size (B) != [n n])
             || ! isnumeric (A) || ! isnumeric (B) || ! isreal (A)
             || ! isreal (B))
           error ("Octave:invalid-input-arg",
-               [solver ": invalid value assigned to field '%s'"], "Jacobian");
+                 [solver ": invalid value assigned to field 'Jacobian'");
         endif
       else
         error ("Octave:invalid-input-arg",
-               [solver ": invalid value assigned to field '%s'"], "Jacobian");
+               [solver ": invalid value assigned to field 'Jacobian'");
       endif
     else
         error ("Octave:invalid-input-arg",
-               [solver ": invalid value assigned to field '%s'"], "Jacobian");
+               [solver ": invalid value assigned to field 'Jacobian'");
     endif
   endif
 
   ## Abstol and Reltol
-
   options.haveabstolvec = false;
 
   if (numel (options.AbsTol) != 1 && numel (options.AbsTol) != n)
     error ("Octave:invalid-input-arg",
-           [solver ": invalid value assigned to field '%s'"], "AbsTol");
+           [solver ": invalid value assigned to field 'AbsTol'");
 
   elseif (numel (options.AbsTol) == n)
     options.haveabstolvec = true;
   endif
 
   ## Stats
   options.havestats = false;
   if (strcmp (options.Stats, "on"))
@@ -255,26 +253,24 @@ function varargout = ode15i (fun, trange
   options.haveoutputselection = ! isempty (options.OutputSel);
   if (options.haveoutputselection)
     options.OutputSel = options.OutputSel - 1;
   endif
 
   ## Events
   options.haveeventfunction = ! isempty (options.Events);
 
-
   [t, y, te, ye, ie] = __ode15__ (fun, trange, y0, yp0, options);
 
-
   if (nargout == 2)
     varargout{1} = t;
     varargout{2} = y;
   elseif (nargout == 1)
-    varargout{1}.x = t;    # Time stamps are saved in field x
-    varargout{1}.y = y;    # Results are saved in field y
+    varargout{1}.x = t;  # Time stamps are saved in field x
+    varargout{1}.y = y;  # Results are saved in field y
     varargout{1}.solver = solver;
     if (options.haveeventfunction)
       varargout{1}.xe = te;  # Time info when an event occurred
       varargout{1}.ye = ye;  # Results when an event occurred
       varargout{1}.ie = ie;  # Index info which event occurred
     endif
   elseif (nargout == 5)
     varargout = cell (1,5);
@@ -284,89 +280,89 @@ function varargout = ode15i (fun, trange
       varargout{3} = te;  # Time info when an event occurred
       varargout{4} = ye;  # Results when an event occurred
       varargout{5} = ie;  # Index info which event occurred
     endif
   endif
 
 endfunction
 
+
 %!demo
-%!
-%! ##Solve Robertson's equations with ode15i
+%! ## Solve Robertson's equations with ode15i
 %! fun = @(t, y, yp) [-(yp(1) + 0.04*y(1) - 1e4*y(2)*y(3));
 %!                    -(yp(2) - 0.04*y(1) + 1e4*y(2)*y(3) + 3e7*y(2)^2);
 %!                    y(1) + y(2) + y(3) - 1];
 %!
-%! opt = odeset ('RelTol',1e-4, 'AbsTol', [1e-8, 1e-14, 1e-6]);
+%! opt = odeset ("RelTol", 1e-4, "AbsTol", [1e-8, 1e-14, 1e-6]);
 %! y0 = [1; 0; 0];
 %! yp0 = [-1e-4; 1e-4; 0];
 %! tspan = [0 4*logspace(-6, 6)];
 %!
 %! [t, y] = ode15i (fun, tspan, y0, yp0, opt);
 %!
-%! y (:,2) = 1e4 * y (:, 2);
+%! y(:,2) = 1e4 * y(:, 2);
 %! figure (2);
-%! semilogx (t, y, 'o')
-%! xlabel ('time');
-%! ylabel ('species concentration');
-%! title ('Robertson DAE problem with a Conservation Law');
-%! legend ('y1', 'y2', 'y3');
+%! semilogx (t, y, "o");
+%! xlabel ("time");
+%! ylabel ("species concentration");
+%! title ("Robertson DAE problem with a Conservation Law");
+%! legend ("y1", "y2", "y3");
 
 %!function res = rob (t, y, yp)
 %!  res =[-(yp(1) + 0.04*y(1) - 1e4*y(2)*y(3));
 %!        -(yp(2) - 0.04*y(1) + 1e4*y(2)*y(3) + 3e7*y(2)^2);
 %!        y(1) + y(2) + y(3) - 1];
 %!endfunction
 %!
-%!function ref = fref()
+%!function ref = fref ()
 %!  ref = [100, 0.617234887614937, 0.000006153591397, 0.382758958793666];
 %!endfunction
 %!
-%!function ref2 = fref2()
+%!function ref2 = fref2 ()
 %!  ref2 = [4e6 0 0 1];
 %!endfunction
 %!
-%!function [DFDY, DFDYP] = jacfundense(t, y, yp)
+%!function [DFDY, DFDYP] = jacfundense (t, y, yp)
 %!  DFDY = [-0.04,           1e4*y(3),  1e4*y(2);
 %!           0.04, -1e4*y(3)-6e7*y(2), -1e4*y(2);
 %!              1,                  1,         1];
 %!  DFDYP = [-1,  0, 0;
 %!            0, -1, 0;
 %!            0,  0, 0];
 %!endfunction
 %!
-%!function [DFDY, DFDYP] = jacfunsparse(t, y, yp)
+%!function [DFDY, DFDYP] = jacfunsparse (t, y, yp)
 %!  DFDY = sparse ([-0.04,           1e4*y(3),  1e4*y(2);
 %!                   0.04, -1e4*y(3)-6e7*y(2), -1e4*y(2);
 %!                      1,                  1,         1]);
 %!  DFDYP = sparse ([-1,  0, 0;
 %!                    0, -1, 0;
 %!                    0,  0, 0]);
 %!endfunction
 %!
-%!function [DFDY, DFDYP] = jacwrong(t, y, yp)
+%!function [DFDY, DFDYP] = jacwrong (t, y, yp)
 %!  DFDY = [-0.04,           1e4*y(3);
 %!           0.04, -1e4*y(3)-6e7*y(2)];
 %!  DFDYP = [-1,  0;
 %!            0, -1];
 %!endfunction
 %!
-%!function [DFDY, DFDYP, A] = jacwrong2(t, y, yp)
+%!function [DFDY, DFDYP, A] = jacwrong2 (t, y, yp)
 %!  DFDY = [-0.04,           1e4*y(3),  1e4*y(2);
 %!           0.04, -1e4*y(3)-6e7*y(2), -1e4*y(2);
 %!              1,                  1,         1];
 %!  DFDYP = [-1,  0, 0;
 %!            0, -1, 0;
 %!            0,  0, 0];
 %!  A = DFDY;
 %!endfunction
 %!
 %!function [val, isterminal, direction] = ff (t, y, yp)
-%!  isterminal = [0 1];
+%!  isterminal = [0, 1];
 %!  if (t < 1e1)
 %!    val = [-1, -2];
 %!  else
 %!    val = [1, 3];
 %!  endif
 %!
 %!  direction = [1, 0];
 %!endfunction
@@ -375,17 +371,17 @@ endfunction
 %!testif HAVE_SUNDIALS
 %! ref = 0.049787079136413;
 %! ff = @(t, u, udot)  udot + 3 * u;
 %! [t, y] = ode15i (ff, 0:1, 1, -3);
 %! assert ([t(end), y(end)], [1, ref], 1e-3);
 
 ## function passed as string
 %!testif HAVE_SUNDIALS
-%! [t, y] = ode15i ('rob', [0, 100, 200], [1; 0; 0], [-1e-4; 1e-4; 0]);
+%! [t, y] = ode15i ("rob", [0, 100, 200], [1; 0; 0], [-1e-4; 1e-4; 0]);
 %! assert ([t(2), y(2,:)], fref, 1e-3);
 
 ##  solve in intermidiate step
 %!testif HAVE_SUNDIALS
 %! [t, y] = ode15i (@rob, [0, 100, 200], [1; 0; 0], [-1e-4; 1e-4; 0]);
 %! assert ([t(2), y(2,:)], fref, 1e-3);
 
 ## numel(trange) = 2 final value
@@ -398,17 +394,17 @@ endfunction
 %! opt = odeset();
 %! [t, y] = ode15i (@rob, [0, 1e6, 2e6, 3e6, 4e6], [1; 0; 0],
 %!                  [-1e-4; 1e-4; 0], opt);
 %! assert ([t(end), y(end,:)], fref2, 1e-3);
 %! opt = odeset();
 
 ## Without options
 %!testif HAVE_SUNDIALS
-%! [t, y] = ode15i (@rob, [0, 1e6, 2e6, 3e6, 4e6], [1; 0; 0], [-1e-4; 1e-4; 0]);
+%! [t, y] = ode15i (@rob, [0, 1e6, 2e6, 3e6, 4e6], [1; 0; 0],[-1e-4; 1e-4; 0]);
 %! assert ([t(end), y(end,:)], fref2, 1e-3);
 
 ## InitialStep option
 %!testif HAVE_SUNDIALS
 %! opt = odeset ("InitialStep", 1e-8);
 %! [t, y] = ode15i (@rob, [0, 100], [1; 0; 0], [-1e-4; 1e-4; 0], opt);
 %! assert (t(2)-t(1), 1e-8, 1e-9);
 
@@ -451,17 +447,17 @@ endfunction
 ## Jacobian fun dense
 %!testif HAVE_SUNDIALS
 %! opt = odeset ("Jacobian", @jacfundense);
 %! [t, y] = ode15i (@rob, [0, 100], [1; 0; 0], [-1e-4; 1e-4; 0], opt);
 %! assert ([t(end), y(end,:)], fref, 1e-3);
 
 ## Jacobian fun dense as string
 %!testif HAVE_SUNDIALS
-%! opt = odeset ("Jacobian", 'jacfundense');
+%! opt = odeset ("Jacobian", "jacfundense");
 %! [t, y] = ode15i (@rob, [0, 100], [1; 0; 0], [-1e-4; 1e-4; 0], opt);
 %! assert ([t(end), y(end,:)], fref, 1e-3);
 
 ## Jacobian fun sparse
 %!testif HAVE_SUNDIALS
 %! opt = odeset ("Jacobian", @jacfunsparse, "AbsTol", 1e-7, "RelTol", 1e-7);
 %! [t, y] = ode15i (@rob, [0, 100], [1; 0; 0], [-1e-4; 1e-4; 0], opt);
 %! assert ([t(end), y(end,:)], fref, 1e-3);
@@ -473,43 +469,43 @@ endfunction
 %! [t, y] = ode15i (@rob, [0, 100], [1; 0; 0], [-1e-4; 1e-4; 0]);
 %! [t2, y2] = ode15i (@rob, [100, 0], Yref', YPref);
 %! assert ([t2(end), y2(end,:)], [0, 1, 0, 0], 2e-2);
 
 ## Solve in backward direction with MaxStep option
 #%!testif HAVE_SUNDIALS
 %! YPref = [-0.001135972751027; -0.000000027483627; 0.001136000234654];
 %! Yref = [0.617234887614937, 0.000006153591397, 0.382758958793666];
-%! opt = odeset ('MaxStep', 1e-2);
+%! opt = odeset ("MaxStep", 1e-2);
 %! [t, y] = ode15i (@rob, [0, 100], [1; 0; 0], [-1e-4; 1e-4; 0]);
 %! [t2, y2] = ode15i (@rob, [100, 0], Yref', YPref, opt);
 %! assert ([t2(end), y2(end,:)], [0, 1, 0, 0], 2e-2);
 %! assert (t2(9)-t2(10), 1e-2, 1e-2);
 
-## Solve in backward direction starting  with intermidiate step
+## Solve in backward direction starting with intermediate step
 #%!testif HAVE_SUNDIALS
 %! YPref = [-0.001135972751027; -0.000000027483627; 0.001136000234654];
 %! Yref = [0.617234887614937, 0.000006153591397, 0.382758958793666];
 %! [t, y] = ode15i (@rob, [0, 100], [1; 0; 0], [-1e-4; 1e-4; 0]);
 %! [t2, y2] = ode15i (@rob, [100, 5, 0], Yref', YPref);
 %! assert ([t2(end), y2(end,:)], [0, 1, 0, 0], 2e-2);
 
 ## Refine
 %!testif HAVE_SUNDIALS
 %! opt = odeset ("Refine", 3);
 %! [t, y] = ode15i (@rob, [0, 100], [1; 0; 0], [-1e-4; 1e-4; 0]);
 %! [t2, y2] = ode15i (@rob, [0, 100], [1; 0; 0], [-1e-4; 1e-4; 0], opt);
-%! assert (numel(t2), numel(t)*3, 3);
+%! assert (numel (t2), numel (t) * 3, 3);
 
 ## Refine ignored if numel (trange) > 2
 %!testif HAVE_SUNDIALS
 %! opt = odeset ("Refine", 3);
 %! [t, y] = ode15i (@rob, [0, 10, 100], [1; 0; 0], [-1e-4; 1e-4; 0]);
 %! [t2, y2] = ode15i (@rob, [0, 10, 100], [1; 0; 0], [-1e-4; 1e-4; 0], opt);
-%! assert (numel(t2), numel(t));
+%! assert (numel (t2), numel (t));
 
 ## Events option add further elements in sol
 %!testif HAVE_SUNDIALS
 %! opt = odeset ("Events", @ff);
 %! sol = ode15i (@rob, [0, 100], [1; 0; 0], [-1e-4; 1e-4; 0], opt);
 %! assert (isfield (sol, "ie"));
 %! assert (sol.ie, [0;1]);
 %! assert (isfield (sol, "xe"));
@@ -522,134 +518,128 @@ endfunction
 %! [t, y, te, ye, ie] = ode15i (@rob, [0, 100], [1; 0; 0],
 %!                              [-1e-4; 1e-4; 0], opt);
 %! assert ([t(end), te', ie'], [10, 10, 10, 0, 1], [1, 0.2, 0.2, 0, 0]);
 
 ## Jacobian fun wrong dimension
 %!testif HAVE_SUNDIALS
 %! opt = odeset ("Jacobian", @jacwrong);
 %! fail ("[t, y] = ode15i (@rob, [0, 4e6], [1; 0; 0], [-1e-4; 1e-4; 0], opt)",
-%!       "ode15i: invalid value assigned to field 'Jacobian'")
+%!       "ode15i: invalid value assigned to field 'Jacobian'");
 
 ## Jacobian cell dense wrong dimension
 %!testif HAVE_SUNDIALS
 %! DFDY = [-0.04, 1;
 %!          0.04, 1];
 %! DFDYP = [-1,  0, 0;
 %!           0, -1, 0;
 %!           0,  0, 0];
 %! opt = odeset ("Jacobian", {DFDY, DFDYP});
 %! fail ("[t, y] = ode15i (@rob, [0, 4e6], [1; 0; 0], [-1e-4; 1e-4; 0], opt)",
-%!       "invalid value assigned to field 'Jacobian'")
+%!       "invalid value assigned to field 'Jacobian'");
 
 ## Jacobian cell sparse wrong dimension
 %!testif HAVE_SUNDIALS
 %! DFDY = sparse ([-0.04, 1;
 %!                  0.04, 1]);
 %! DFDYP = sparse ([-1,  0, 0;
 %!                   0, -1, 0;
 %!                   0,  0, 0]);
 %! opt = odeset ("Jacobian", {DFDY, DFDYP});
 %! fail ("[t, y] = ode15i (@rob, [0, 4e6], [1; 0; 0], [-1e-4; 1e-4; 0], opt)",
-%!       "invalid value assigned to field 'Jacobian'")
+%!       "invalid value assigned to field 'Jacobian'");
 
 ## Jacobian cell wrong number of matrices
 %!testif HAVE_SUNDIALS
 %! A = [1 2 3; 4 5 6; 7 8 9];
 %! opt = odeset ("Jacobian", {A,A,A});
 %! fail ("[t, y] = ode15i (@rob, [0, 4e6], [1; 0; 0], [-1e-4; 1e-4; 0], opt)",
-%!       "invalid value assigned to field 'Jacobian'")
+%!       "invalid value assigned to field 'Jacobian'");
 
 ## Jacobian single matrix
 %!testif HAVE_SUNDIALS
 %! opt = odeset ("Jacobian", [1 2 3; 4 5 6; 7 8 9]);
 %! fail ("[t, y] = ode15i (@rob, [0, 4e6], [1; 0; 0], [-1e-4; 1e-4; 0], opt)",
-%!       "invalid value assigned to field 'Jacobian'")
+%!       "invalid value assigned to field 'Jacobian'");
 
 ## Jacobian single matrix wrong dimension
 %!testif HAVE_SUNDIALS
 %! opt = odeset ("Jacobian", [1 2 3; 4 5 6]);
 %! fail ("[t, y] = ode15i (@rob, [0, 4e6], [1; 0; 0], [-1e-4; 1e-4; 0], opt)",
-%!       "invalid value assigned to field 'Jacobian'")
+%!       "invalid value assigned to field 'Jacobian'");
 
 ## Jacobian strange field
 ## FIXME: we need a better way to silence the warning from odeset.
 %!testif HAVE_SUNDIALS
 %! saved_opts = warning ();
 %! warning ("off", "all");
 %! opt = odeset ("Jacobian", "foo");
 %! fail ("[t, y] = ode15i (@rob, [0, 4e6], [1; 0; 0], [-1e-4; 1e-4; 0], opt)",
-%!       "invalid value assigned to field 'Jacobian'")
+%!       "invalid value assigned to field 'Jacobian'");
 %! warning (saved_opts);
 
 %!function ydot = fun (t, y, yp)
 %!  ydot = [y - yp];
 %!endfunction
 
 %!testif HAVE_SUNDIALS
-%! fail ("ode15i ()",
-%!       "Invalid call to ode15i")
+%! fail ("ode15i ()", "Invalid call to ode15i");
 
 %!testif HAVE_SUNDIALS
-%! fail ("ode15i (1)",
-%!       "Invalid call to ode15i")
+%! fail ("ode15i (1)", "Invalid call to ode15i");
 
 %!testif HAVE_SUNDIALS
-%! fail ("ode15i (1, 1)",
-%!       "Invalid call to ode15i")
+%! fail ("ode15i (1, 1)", "Invalid call to ode15i");
 
 %!testif HAVE_SUNDIALS
-%! fail ("ode15i (1, 1, 1)",
-%!       "Invalid call to ode15i")
+%! fail ("ode15i (1, 1, 1)", "Invalid call to ode15i");
 
 %!testif HAVE_SUNDIALS
-%! fail ("ode15i (1, 1, 1, 1)",
-%!       "ode15i: fun must be of class:")
+%! fail ("ode15i (1, 1, 1, 1)", "ode15i: fun must be of class:");
 
 %!testif HAVE_SUNDIALS
-%! fail ("ode15i (1, 1, 1, 1, 1)",
-%!       "ode15i: fun must be of class:")
+%! fail ("ode15i (1, 1, 1, 1, 1)", "ode15i: fun must be of class:");
 
 %!testif HAVE_SUNDIALS
-%! fail ("ode15i (1, 1, 1, 1, 1, 1)",
-%!       "ode15i: fun must be of class:")
+%! fail ("ode15i (1, 1, 1, 1, 1, 1)", "ode15i: fun must be of class:");
 
 %!testif HAVE_SUNDIALS
 %! fail ("ode15i (@fun, 1, 1, 1)",
-%!       "ode15i: invalid value assigned to field 'trange'")
+%!       "ode15i: invalid value assigned to field 'trange'");
 
 %!testif HAVE_SUNDIALS
 %! fail ("ode15i (@fun, [1, 1], 1, 1)",
-%!       "ode15i: invalid value assigned to field 'trange'")
+%!       "ode15i: invalid value assigned to field 'trange'");
 
 %!testif HAVE_SUNDIALS
 %! fail ("ode15i (@fun, [1, 2], 1, [1, 2])",
-%!       "ode15i: y0 must have 2 elements")
+%!       "ode15i: y0 must have 2 elements");
 
 %!testif HAVE_SUNDIALS
-%! opt = odeset ('RelTol', "foo");
+%! opt = odeset ("RelTol", "foo");
 %! fail ("[t, y] = ode15i (@fun, [0, 2], 2, 2, opt)",
-%!       "ode15i: RelTol must be of class:")
+%!       "ode15i: RelTol must be of class:");
 
 %!testif HAVE_SUNDIALS
-%! opt = odeset ('RelTol', [1, 2]);
+%! opt = odeset ("RelTol", [1, 2]);
 %! fail ("[t, y] = ode15i (@fun, [0, 2], 2, 2, opt)",
-%!       "ode15i: RelTol must be scalar")
+%!       "ode15i: RelTol must be scalar");
 
 %!testif HAVE_SUNDIALS
-%! opt = odeset ('RelTol', -2);
+%! opt = odeset ("RelTol", -2);
 %! fail ("[t, y] = ode15i (@fun, [0, 2], 2, 2, opt)",
-%!       "ode15i: RelTol must be positive")
+%!       "ode15i: RelTol must be positive");
+
+%!testif HAVE_SUNDIALS
+%! opt = odeset ("AbsTol", "foo");
+%! fail ("[t, y] = ode15i (@fun, [0, 2], 2, 2, opt)",
+%!       "ode15i: AbsTol must be of class:");
 
 %!testif HAVE_SUNDIALS
-%! opt = odeset ('AbsTol', "foo");
+%! opt = odeset ("AbsTol", -1);
 %! fail ("[t, y] = ode15i (@fun, [0, 2], 2, 2, opt)",
-%!       "ode15i: AbsTol must be of class:")
+%!       "ode15i: AbsTol must be positive");
 
 %!testif HAVE_SUNDIALS
-%! opt = odeset ('AbsTol', -1);
+%! opt = odeset ("AbsTol", [1, 1, 1]);
 %! fail ("[t, y] = ode15i (@fun, [0, 2], 2, 2, opt)",
-%!       "ode15i: AbsTol must be positive")
+%!       "ode15i: invalid value assigned to field 'AbsTol'");
 
-%!testif HAVE_SUNDIALS
-%! opt = odeset ('AbsTol', [1, 1, 1]);
-%! fail ("[t, y] = ode15i (@fun, [0, 2], 2, 2, opt)",
-%!       "ode15i: invalid value assigned to field 'AbsTol'")
diff --git a/scripts/ode/ode15s.m b/scripts/ode/ode15s.m
--- a/scripts/ode/ode15s.m
+++ b/scripts/ode/ode15s.m
@@ -80,17 +80,17 @@
 ## [@var{t},@var{y}] = ode15s (@@robertsidae, [0 1e3], [1; 0; 0], opt);
 ## @end group
 ## @end example
 ## @seealso{decic, odeset, odeget}
 ## @end deftypefn
 
 function varargout = ode15s (fun, trange, y0, varargin)
 
-  solver = 'ode15s';
+  solver = "ode15s";
 
   if (nargin < 3)
     print_usage ();
   endif
 
   ## Check fun, trange, y0, yp0
   fun = check_default_input (fun, trange, solver, y0);
 
@@ -106,31 +106,31 @@ function varargout = ode15s (fun, trange
     if (ischar (options.Mass))
       try
         options.Mass = str2func (options.Mass);
       catch
         warning (lasterr);
       end_try_catch
       if (! isa (options.Mass, "function_handle"))
         error ("Octave:invalid-input-arg",
-               [solver ": invalid value assigned to field '%s'"], "Mass");
+               [solver ": invalid value assigned to field 'Mass'"]);
       endif
     endif
   endif
 
   if (! isempty (options.Jacobian))
     if (ischar (options.Jacobian))
       try
         options.Jacobian = str2func (options.Jacobian);
       catch
         warning (lasterr);
       end_try_catch
       if (! isa (options.Jacobian, "function_handle"))
         error ("Octave:invalid-input-arg",
-               [solver ": invalid value assigned to field '%s'"], "Jacobian");
+               [solver ": invalid value assigned to field 'Jacobian'"]);
       endif
     endif
   endif
 
   if (! isempty (options.OutputFcn))
     if (ischar (options.OutputFcn))
       try
         options.OutputFcn = str2func (options.OutputFcn);
@@ -148,113 +148,107 @@ function varargout = ode15s (fun, trange
     if (ischar (options.Events))
       try
         options.Events = str2func (options.Events);
       catch
         warning (lasterr);
       end_try_catch
       if (! isa (options.Events, "function_handle"))
         error ("Octave:invalid-input-arg",
-               [solver ": invalid value assigned to field '%s'"], "Events");
+               [solver ": invalid value assigned to field 'Events'"]);
       endif
     endif
   endif
 
-
-  [defaults, classes, attributes] = ...
-  odedefaults (n, trange(1), trange(end));
+  [defaults, classes, attributes] = odedefaults (n, trange(1), trange(end));
 
-  classes    = odeset (classes, 'Vectorized', {});
-  attributes = odeset (attributes, 'Jacobian', {}, 'Vectorized', {});
+  classes    = odeset (classes, "Vectorized", {});
+  attributes = odeset (attributes, "Jacobian", {}, "Vectorized", {});
 
-  options = ...
-  odemergeopts ("ode15s", options, defaults,
-                classes, attributes, solver);
+  options = odemergeopts ("ode15s", options, defaults,
+                          classes, attributes, solver);
 
   ## Mass
-
   options.havemassfun    = false;
   options.havestatedep   = false;
   options.havetimedep    = false;
   options.havemasssparse = false;
 
   if (! isempty (options.Mass))
     if (isa (options.Mass, "function_handle"))
       options.havemassfun = true;
       if (nargin (options.Mass) == 2)
         options.havestatedep = true;
         M = options.Mass (trange(1), y0);
         options.havemasssparse = issparse (M);
         if (any (size (M) != [n n]) || ! isnumeric (M) || ! isreal (M))
           error ("Octave:invalid-input-arg",
-               [solver ": invalid value assigned to field '%s'"], "Mass");
+                 [solver ": invalid value assigned to field 'Mass'");
         endif
       elseif (nargin (options.Mass) == 1)
         options.havetimedep = true;
         M = options.Mass (trange(1));
         options.havemasssparse = issparse (M);
         if (any (size (M) != [n n]) || ! isnumeric (M) || ! isreal (M))
           error ("Octave:invalid-input-arg",
-               [solver ": invalid value assigned to field '%s'"], "Mass");
+                 [solver ": invalid value assigned to field 'Mass'");
         endif
       else
         error ("Octave:invalid-input-arg",
-                [solver ": invalid value assigned to field '%s'"], "Mass");
+               [solver ": invalid value assigned to field 'Mass'");
       endif
     elseif (ismatrix (options.Mass))
       options.havemasssparse = issparse (options.Mass);
       if (any (size (options.Mass) != [n n]) ||
           ! isnumeric (options.Mass) || ! isreal (options.Mass))
         error ("Octave:invalid-input-arg",
-                [solver ": invalid value assigned to field '%s'"], "Mass");
+               [solver ": invalid value assigned to field 'Mass'");
       endif
     else
       error ("Octave:invalid-input-arg",
-              [solver ": invalid value assigned to field '%s'"], "Mass");
+             [solver ": invalid value assigned to field 'Mass'");
     endif
   endif
 
-
   ## Jacobian
   options.havejac       = false;
   options.havejacsparse = false;
   options.havejacfun    = false;
 
   if (! isempty (options.Jacobian))
     options.havejac = true;
     if (isa (options.Jacobian, "function_handle"))
       options.havejacfun = true;
       if (nargin (options.Jacobian) == 2)
         [A] = options.Jacobian (trange(1), y0);
         if (issparse (A))
-          options.havejacsparse = true;  ## Jac is sparse fun
+          options.havejacsparse = true;  # Jac is sparse fun
         endif
         if (any (size (A) != [n n]) || ! isnumeric (A) || ! isreal (A))
           error ("Octave:invalid-input-arg",
-               [solver ": invalid value assigned to field '%s'"], "Jacobian");
+                 [solver ": invalid value assigned to field 'Jacobian'");
         endif
       else
         error ("Octave:invalid-input-arg",
-               [solver ": invalid value assigned to field '%s'"], "Jacobian");
+               [solver ": invalid value assigned to field 'Jacobian'");
       endif
     elseif (ismatrix (options.Jacobian))
       if (issparse (options.Jacobian))
-        options.havejacsparse = true;            ## Jac is sparse matrix
+        options.havejacsparse = true;    # Jac is sparse matrix
       endif
       if (! issquare (options.Jacobian))
         error ("Octave:invalid-input-arg",
-               [solver ": invalid value assigned to field '%s'"], "Jacobian");
+               [solver ": invalid value assigned to field 'Jacobian'");
       endif
     else
       error ("Octave:invalid-input-arg",
-             [solver ": invalid value assigned to field '%s'"], "Jacobian");
+             [solver ": invalid value assigned to field 'Jacobian'");
     endif
   endif
 
-
   ## Derivative of M(t,y) for implicit problem not implemented yet
   if (! isempty (options.Mass) && ! isempty (options.Jacobian))
     if (options.MStateDependence != "none" || options.havestatedep == true)
       options.havejac = false;
       options.Jacobian = [];
       warning ("ode15s:mass_state_dependent_provided",
               ["with MStateDependence != 'none' an internal", ...
                " approximation of Jacobian Matrix will be used.", ...
@@ -278,26 +272,22 @@ function varargout = ode15s (fun, trange
                                                   options.havejacfun);
       options.havejacfun = true;
     else   ## All matrices are constant
       options.Jacobian = {[- options.Jacobian], [options.Mass]};
 
     endif
   endif
 
-
-
   ## Abstol and Reltol
-
   options.haveabstolvec = false;
 
   if (numel (options.AbsTol) != 1 && numel (options.AbsTol) != n)
     error ("Octave:invalid-input-arg",
-           [solver ": invalid value assigned to field '%s'"], "AbsTol");
-
+           [solver ": invalid value assigned to field 'AbsTol'");
   elseif (numel (options.AbsTol) == n)
     options.haveabstolvec = true;
   endif
 
   ## Stats
   options.havestats = false;
   if (strcmp (options.Stats, "on"))
     options.havestats = true;
@@ -321,29 +311,28 @@ function varargout = ode15s (fun, trange
     options.OutputSel = options.OutputSel - 1;
   endif
 
   ## Events
   options.haveeventfunction = ! isempty (options.Events);
 
   yp0 = options.InitialSlope;
 
-
   [t, y, te, ye, ie] = __ode15__ (@ (t, y, yp) wrap (t, y, yp, options.Mass,
                                                      options.havetimedep,
                                                      options.havestatedep,
                                                      fun),
                                   trange, y0, yp0, options);
 
   if (nargout == 2)
     varargout{1} = t;
     varargout{2} = y;
   elseif (nargout == 1)
-    varargout{1}.x = t;    # Time stamps are saved in field x
-    varargout{1}.y = y;    # Results are saved in field y
+    varargout{1}.x = t;  # Time stamps are saved in field x
+    varargout{1}.y = y;  # Results are saved in field y
     varargout{1}.solver = solver;
     if (options.haveeventfunction)
       varargout{1}.xe = te;  # Time info when an event occurred
       varargout{1}.ye = ye;  # Results when an event occurred
       varargout{1}.ie = ie;  # Index info which event occurred
     endif
   elseif (nargout == 5)
     varargout = cell (1,5);
@@ -387,225 +376,224 @@ function [jac, jact] = wrapjacfun (t, y,
   else
     jact = speye (numel (y));
   endif
 
 endfunction
 
 
 %!demo
-%!
-%! ##Solve Robertson's equations with ode15s
+%! ## Solve Robertson's equations with ode15s
 %! fun = @ (t, y) [-0.04*y(1) + 1e4*y(2).*y(3);
 %!                  0.04*y(1) - 1e4*y(2).*y(3) - 3e7*y(2).^2;
 %!                  y(1) + y(2) + y(3) - 1 ];
 %!
 %! y0 = [1; 0; 0];
 %! tspan = [0 4*logspace(-6, 6)];
 %! M = [1 0 0; 0 1 0; 0 0 0];
 %!
-%! options = odeset ('RelTol', 1e-4, 'AbsTol', [1e-6 1e-10 1e-6],
-%!                   'MStateDependence', 'none', 'Mass', M);
+%! options = odeset ("RelTol", 1e-4, "AbsTol", [1e-6 1e-10 1e-6],
+%!                   "MStateDependence", "none", "Mass", M);
 %!
 %! [t, y] = ode15s (fun, tspan, y0, options);
 %!
-%! y (:,2) = 1e4 * y (:,2);
+%! y(:,2) = 1e4 * y(:,2);
 %! figure (2);
-%! semilogx (t, y, 'o')
-%! xlabel ('time');
-%! ylabel ('species concentration');
-%! title ('Robertson DAE problem with a Conservation Law');
-%! legend ('y1', 'y2', 'y3');
+%! semilogx (t, y, "o");
+%! xlabel ("time");
+%! ylabel ("species concentration");
+%! title ("Robertson DAE problem with a Conservation Law");
+%! legend ("y1", "y2", "y3");
 
-%!function ydot = fpol (t, y)  # The Van der Pol
-%! ydot = [y(2); (1 - y(1)^2) * y(2) - y(1)];
+%!function ydot = fpol (t, y)  # Van der Pol equation
+%!  ydot = [y(2); (1 - y(1)^2) * y(2) - y(1)];
 %!endfunction
 %!
 %!function ref = fref ()       # The computed reference sol
-%! ref = [0.32331666704577, -1.83297456798624];
+%!  ref = [0.32331666704577, -1.83297456798624];
 %!endfunction
 %!
-%!function jac = fjac (t, y)  # its Jacobian
-%! jac = [0, 1; -1 - 2 * y(1) * y(2), 1 - y(1)^2];
+%!function jac = fjac (t, y)   # its Jacobian
+%!  jac = [0, 1; -1 - 2 * y(1) * y(2), 1 - y(1)^2];
 %!endfunction
 %!
-%!function jac = fjcc (t, y)  # sparse type
-%! jac = sparse ([0, 1; -1 - 2 * y(1) * y(2), 1 - y(1)^2]);
+%!function jac = fjcc (t, y)   # sparse type
+%!  jac = sparse ([0, 1; -1 - 2 * y(1) * y(2), 1 - y(1)^2]);
 %!endfunction
 %!
 %!function mas = fmas (t, y)
-%! mas = [1, 0; 0, 1];             # Dummy mass matrix for tests
+%!  mas = [1, 0; 0, 1];           # Dummy mass matrix for tests
 %!endfunction
 %!
 %!function mas = fmsa (t, y)
-%! mas = sparse ([1, 0; 0, 1]);    # A sparse dummy matrix
+%!  mas = sparse ([1, 0; 0, 1]);  # A sparse dummy matrix
 %!endfunction
 %!
 %!function res = rob (t, y)
-%! res = [-0.04*y(1) + 1e4*y(2).*y(3);
-%!         0.04*y(1) - 1e4*y(2).*y(3) - 3e7*y(2).^2;
-%!         y(1) + y(2) + y(3) - 1 ];
+%!  res = [-0.04*y(1) + 1e4*y(2).*y(3);
+%!          0.04*y(1) - 1e4*y(2).*y(3) - 3e7*y(2).^2;
+%!          y(1) + y(2) + y(3) - 1 ];
 %!endfunction
 %!
-%!function refrob = frefrob()
-%! refrob = [100, 0.617234887614937, 0.000006153591397, 0.382758958793666];
+%!function refrob = frefrob ()
+%!  refrob = [100, 0.617234887614937, 0.000006153591397, 0.382758958793666];
 %!endfunction
 %!
 %!function [val, isterminal, direction] = feve (t, y)
-%!  isterminal = [0 1];
+%!  isterminal = [0, 1];
 %!  if (t < 1e1)
 %!    val = [-1, -2];
 %!  else
-%!    val = [1 3];
+%!    val = [1, 3];
 %!  endif
 %!
-%!  direction = [1 0];
+%!  direction = [1, 0];
 %!endfunction
 %!
 %!function masrob = massdensefunstate (t, y)
-%! masrob = [1 0 0; 0 1 0; 0 0 0];
+%!  masrob = [1 0 0; 0 1 0; 0 0 0];
 %!endfunction
 %!
 %!function masrob = masssparsefunstate (t, y)
-%! masrob = sparse([1 0 0; 0 1 0; 0 0 0]);
+%!  masrob = sparse ([1 0 0; 0 1 0; 0 0 0]);
 %!endfunction
 %!
 %!function masrob = massdensefuntime (t)
-%! masrob = [1 0 0; 0 1 0; 0 0 0];
+%!  masrob = [1 0 0; 0 1 0; 0 0 0];
 %!endfunction
 %!
 %!function masrob = masssparsefuntime (t)
-%! masrob = sparse([1 0 0; 0 1 0; 0 0 0]);
+%!  masrob = sparse ([1 0 0; 0 1 0; 0 0 0]);
 %!endfunction
 %!
 %!function jac = jacfundense (t, y)
 %!  jac = [-0.04,           1e4*y(3),  1e4*y(2);
-%!           0.04, -1e4*y(3)-6e7*y(2), -1e4*y(2);
-%!              1,                  1,         1];
+%!          0.04, -1e4*y(3)-6e7*y(2), -1e4*y(2);
+%!             1,                  1,         1];
 %!endfunction
 %!
 %!function jac = jacfunsparse (t, y)
 %!  jac = sparse([-0.04,           1e4*y(3),  1e4*y(2);
 %!                 0.04, -1e4*y(3)-6e7*y(2), -1e4*y(2);
 %!                    1,                  1,         1]);
 %!endfunction
 
 %!testif HAVE_SUNDIALS
 %! opt = odeset ("MStateDependence", "none",
-%!                "Mass", [1 0 0; 0 1 0; 0 0 0]);
+%!               "Mass", [1 0 0; 0 1 0; 0 0 0]);
 %! [t, y] = ode15s (@rob,[0 100], [1;0;0], opt);
 %! assert ([t(end), y(end,:)], frefrob, 1e-3);
 
 %!testif HAVE_SUNDIALS
 %! opt = odeset ("MStateDependence", "none",
-%!                "Mass", sparse([1 0 0; 0 1 0; 0 0 0]));
+%!               "Mass", sparse ([1 0 0; 0 1 0; 0 0 0]));
 %! [t, y] = ode15s (@rob,[0 100], [1;0;0], opt);
 %! assert ([t(end), y(end,:)], frefrob, 1e-3);
 
 %!testif HAVE_SUNDIALS
 %! opt = odeset ("MStateDependence", "none",
-%!                "Mass", @massdensefunstate);
+%!               "Mass", @massdensefunstate);
 %! [t, y] = ode15s (@rob,[0 100], [1;0;0], opt);
 %! assert ([t(end), y(end,:)], frefrob, 1e-3);
 
 %!testif HAVE_SUNDIALS
 %! opt = odeset ("MStateDependence", "none",
-%!                "Mass", @masssparsefunstate);
+%!               "Mass", @masssparsefunstate);
 %! [t, y] = ode15s (@rob,[0 100], [1;0;0], opt);
 %! assert ([t(end), y(end,:)], frefrob, 1e-3);
 
 %!testif HAVE_SUNDIALS
 %! opt = odeset ("MStateDependence", "none",
-%!                "Mass", 'massdensefuntime');
+%!               "Mass", "massdensefuntime");
 %! [t, y] = ode15s (@rob,[0 100], [1;0;0], opt);
 %! assert ([t(end), y(end,:)], frefrob, 1e-3);
 
 %!testif HAVE_SUNDIALS
-%!  opt = odeset ("MStateDependence", "none",
-%!                "Mass", [1 0 0; 0 1 0; 0 0 0],
-%!                "Jacobian", 'jacfundense');
+%! opt = odeset ("MStateDependence", "none",
+%!               "Mass", [1 0 0; 0 1 0; 0 0 0],
+%!               "Jacobian", "jacfundense");
 %! [t, y] = ode15s (@rob,[0 100], [1;0;0], opt);
 %! assert ([t(end), y(end,:)], frefrob, 1e-3);
 
 %!testif HAVE_SUNDIALS
 %! opt = odeset ("MStateDependence", "none",
-%!                "Mass", sparse([1 0 0; 0 1 0; 0 0 0]),
-%!                "Jacobian", @jacfundense);
+%!               "Mass", sparse ([1 0 0; 0 1 0; 0 0 0]),
+%!               "Jacobian", @jacfundense);
 %! [t, y] = ode15s (@rob,[0 100], [1;0;0], opt);
 %! assert ([t(end), y(end,:)], frefrob, 1e-3);
 
 %!testif HAVE_SUNDIALS
 %! warning ("off", "ode15s:mass_state_dependent_provided", "local");
-%!  opt = odeset ("MStateDependence", "none",
-%!                "Mass", @massdensefunstate,
-%!                "Jacobian", @jacfundense);
+%! opt = odeset ("MStateDependence", "none",
+%!               "Mass", @massdensefunstate,
+%!               "Jacobian", @jacfundense);
 %! [t, y] = ode15s (@rob,[0 100], [1;0;0], opt);
 %! assert ([t(end), y(end,:)], frefrob, 1e-3);
 
 %!testif HAVE_SUNDIALS
 %! warning ("off", "ode15s:mass_state_dependent_provided", "local");
-%!  opt = odeset ("MStateDependence", "none",
-%!                "Mass", @masssparsefunstate,
-%!                "Jacobian", @jacfundense);
+%! opt = odeset ("MStateDependence", "none",
+%!               "Mass", @masssparsefunstate,
+%!               "Jacobian", @jacfundense);
 %! [t, y] = ode15s (@rob,[0 100], [1;0;0], opt);
 %! assert ([t(end), y(end,:)], frefrob, 1e-3);
 
 %!testif HAVE_SUNDIALS
-%!  opt = odeset ("MStateDependence", "none",
-%!                "Mass", @massdensefuntime,
-%!                "Jacobian", @jacfundense);
+%! opt = odeset ("MStateDependence", "none",
+%!               "Mass", @massdensefuntime,
+%!               "Jacobian", @jacfundense);
 %! [t, y] = ode15s (@rob,[0 100], [1;0;0], opt);
 %! assert ([t(end), y(end,:)], frefrob, 1e-3);
-%!  opt = odeset ("MStateDependence", "none",
-%!                "Mass", 'masssparsefuntime',
-%!                "Jacobian", 'jacfundense');
+%! opt = odeset ("MStateDependence", "none",
+%!               "Mass", "masssparsefuntime",
+%!               "Jacobian", "jacfundense");
 %! [t, y] = ode15s (@rob,[0 100], [1;0;0], opt);
 %! assert ([t(end), y(end,:)], frefrob, 1e-3);
 
 %!testif HAVE_SUNDIALS
-%!  opt = odeset ("MStateDependence", "none",
-%!                "Mass", [1 0 0; 0 1 0; 0 0 0],
-%!                "Jacobian", @jacfunsparse);
+%! opt = odeset ("MStateDependence", "none",
+%!               "Mass", [1 0 0; 0 1 0; 0 0 0],
+%!               "Jacobian", @jacfunsparse);
 %! [t, y] = ode15s (@rob,[0 100], [1;0;0], opt);
 %! assert ([t(end), y(end,:)], frefrob, 1e-3);
 
 %!testif HAVE_SUNDIALS
-%!  opt = odeset ("MStateDependence", "none",
-%!                "Mass", sparse([1 0 0; 0 1 0; 0 0 0]),
+%! opt = odeset ("MStateDependence", "none",
+%!               "Mass", sparse ([1 0 0; 0 1 0; 0 0 0]),
 %!               "Jacobian", @jacfunsparse);
 %! [t, y] = ode15s (@rob,[0 100], [1;0;0], opt);
 %! assert ([t(end), y(end,:)], frefrob, 1e-3);
 
 %!testif HAVE_SUNDIALS
 %! warning ("off", "ode15s:mass_state_dependent_provided", "local");
-%!  opt = odeset ("MStateDependence", "none",
-%!                "Mass", @massdensefunstate,
-%!                "Jacobian", @jacfunsparse);
+%! opt = odeset ("MStateDependence", "none",
+%!               "Mass", @massdensefunstate,
+%!               "Jacobian", @jacfunsparse);
 %! [t, y] = ode15s (@rob,[0 100], [1;0;0], opt);
 %! assert ([t(end), y(end,:)], frefrob, 1e-3);
 
 %!testif HAVE_SUNDIALS
 %! warning ("off", "ode15s:mass_state_dependent_provided", "local");
-%!  opt = odeset ("MStateDependence", "none",
-%!                "Mass", @masssparsefunstate,
-%!                "Jacobian", @jacfunsparse);
+%! opt = odeset ("MStateDependence", "none",
+%!               "Mass", @masssparsefunstate,
+%!               "Jacobian", @jacfunsparse);
 %! [t, y] = ode15s (@rob,[0 100], [1;0;0], opt);
 %! assert ([t(end), y(end,:)], frefrob, 1e-3);
 
 %!testif HAVE_SUNDIALS
-%!  opt = odeset ("MStateDependence", "none",
-%!                "Mass", @massdensefuntime,
-%!                "Jacobian", @jacfunsparse);
+%! opt = odeset ("MStateDependence", "none",
+%!               "Mass", @massdensefuntime,
+%!               "Jacobian", @jacfunsparse);
 %! [t, y] = ode15s (@rob,[0 100], [1;0;0], opt);
 %! assert ([t(end), y(end,:)], frefrob, 1e-3);
 
 %!testif HAVE_SUNDIALS
-%!  opt = odeset ("MStateDependence", "none",
-%!                "Mass", @masssparsefuntime,
-%!                "Jacobian", @jacfunsparse);
+%! opt = odeset ("MStateDependence", "none",
+%!               "Mass", @masssparsefuntime,
+%!               "Jacobian", @jacfunsparse);
 %! [t, y] = ode15s (@rob,[0 100], [1;0;0], opt);
 %! assert ([t(end), y(end,:)], frefrob, 1e-3);
 
 ## two output arguments
 %!testif HAVE_SUNDIALS
 %! [t, y] = ode15s (@fpol, [0 2], [2 0]);
 %! assert ([t(end), y(end,:)], [2, fref], 1e-2);
 
@@ -620,23 +608,23 @@ endfunction
 %! ref = [0, 14.77810590694212];
 %! [t, y] = ode15s (@(t,y) y, [-2 0], 2);
 %! assert ([t(end), y(end,:)], ref, 5e-2);
 
 ## InitialStep option
 %!testif HAVE_SUNDIALS
 %! opt = odeset ("InitialStep", 1e-8);
 %! [t, y] = ode15s (@fpol, [0 0.2], [2 0], opt);
-%! assert ([t(2)-t(1)], [1e-8], 1e-9);
+%! assert (t(2)-t(1), 1e-8, 1e-9);
 
 ## MaxStep option
 %!testif HAVE_SUNDIALS
 %! opt = odeset ("MaxStep", 1e-3);
 %! sol = ode15s (@fpol, [0 0.2], [2 0], opt);
-%! assert ([sol.x(5)-sol.x(4)], [1e-3], 1e-3);
+%! assert (sol.x(5)-sol.x(4), 1e-3, 1e-3);
 
 ## Solve in backward direction starting at t=0
 %!testif HAVE_SUNDIALS
 %! ref = [-1.205364552835178, 0.951542399860817];
 %! sol = ode15s (@fpol, [0 -2], [2 0]);
 %! assert ([sol.x(end), sol.y(end,:)], [-2, ref], 5e-3);
 
 ## Solve in backward direction starting at t=2
@@ -657,17 +645,17 @@ endfunction
 %! sol = ode15s (@(t,y) y, [-2 0], 2);
 %! assert ([sol.x(end), sol.y(end,:)], ref, 5e-2);
 
 ## Solve in backward direction starting at t=0 with MaxStep option
 %!testif HAVE_SUNDIALS
 %! ref = [-1.205364552835178, 0.951542399860817];
 %! opt = odeset ("MaxStep", 1e-3);
 %! sol = ode15s (@fpol, [0 -2], [2 0], opt);
-%! assert ([abs(sol.x(8)-sol.x(7))], [1e-3], 1e-3);
+%! assert (abs (sol.x(8)-sol.x(7)), 1e-3, 1e-3);
 %! assert ([sol.x(end), sol.y(end,:)], [-2, ref], 1e-3);
 
 ## AbsTol option
 %!testif HAVE_SUNDIALS
 %! opt = odeset ("AbsTol", 1e-5);
 %! sol = ode15s (@fpol, [0 2], [2 0], opt);
 %! assert ([sol.x(end), sol.y(end,:)], [2, fref], 4e-3);
 
@@ -692,43 +680,43 @@ endfunction
 ## Mass option as matrix
 %!testif HAVE_SUNDIALS
 %! opt = odeset ("Mass", eye (2,2), "MStateDependence", "none");
 %! sol = ode15s (@fpol, [0 2], [2 0], opt);
 %! assert ([sol.x(end), sol.y(end,:)], [2, fref], 3e-3);
 
 ## Mass option as sparse matrix
 %!testif HAVE_SUNDIALS
-%! opt = odeset ("Mass", sparse (eye (2,2)), "MStateDependence", "none");
+%! opt = odeset ("Mass", speye (2)), "MStateDependence", "none");
 %! sol = ode15s (@fpol, [0 2], [2 0], opt);
 %! assert ([sol.x(end), sol.y(end,:)], [2, fref], 3e-3);
 
 ## Mass option as function and sparse matrix
 %!testif HAVE_SUNDIALS
-%! opt = odeset ("Mass", 'fmsa', "MStateDependence", "none");
+%! opt = odeset ("Mass", "fmsa", "MStateDependence", "none");
 %! sol = ode15s (@fpol, [0 2], [2 0], opt);
 %! assert ([sol.x(end), sol.y(end,:)], [2, fref], 3e-3);
 
 ## Refine
 %!testif HAVE_SUNDIALS
 %! opt2 = odeset ("Refine", 3, "Mass", @massdensefunstate,
 %!                "MStateDependence", "none");
 %! opt1 = odeset ("Mass", @massdensefunstate, "MStateDependence", "none");
 %! [t, y] = ode15s (@rob,[0 100], [1;0;0], opt1);
 %! [t2, y2] = ode15s (@rob,[0 100], [1;0;0], opt2);
-%! assert ([numel(t2)], numel(t)*3, 3);
+%! assert (numel (t2), numel (t) * 3, 3);
 
 ## Refine ignored if numel (trange) > 2
 %!testif HAVE_SUNDIALS
-%! opt2 = odeset ("Refine", 3, "Mass", 'massdensefunstate',
+%! opt2 = odeset ("Refine", 3, "Mass", "massdensefunstate",
 %!                "MStateDependence", "none");
 %! opt1 = odeset ("Mass", @massdensefunstate, "MStateDependence", "none");
-%! [t, y] = ode15s ('rob',[0 10 100], [1;0;0], opt1);
-%! [t2, y2] = ode15s ('rob',[0 10 100], [1;0;0], opt2);
-%! assert ([numel(t2)], numel(t));
+%! [t, y] = ode15s ("rob", [0 10 100], [1;0;0], opt1);
+%! [t2, y2] = ode15s ("rob", [0 10 100], [1;0;0], opt2);
+%! assert (numel (t2), numel (t));
 
 ## Events option add further elements in sol
 %!testif HAVE_SUNDIALS
 %! opt = odeset ("Events", @feve, "Mass", @massdensefunstate,
 %!               "MStateDependence", "none");
 %! sol = ode15s (@rob,[0 100], [1;0;0], opt);
 %! assert (isfield (sol, "ie"));
 %! assert (sol.ie, [0;1]);
@@ -737,8 +725,9 @@ endfunction
 %! assert (sol.x(end), 10, 1);
 
 ## Events option, five output arguments
 %!testif HAVE_SUNDIALS
 %! opt = odeset ("Events", @feve, "Mass", @massdensefunstate,
 %!               "MStateDependence", "none");
 %! [t, y, te, ye, ie] = ode15s (@rob,[0 100], [1;0;0], opt);
 %! assert ([t(end), te', ie'], [10, 10, 10, 0, 1], [1, 0.5, 0.5, 0, 0]);
+
