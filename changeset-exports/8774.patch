# HG changeset patch
# User Jaroslav Hajek <highegg@gmail.com>
# Date 1234856280 -3600
#      Tue Feb 17 08:38:00 2009 +0100
# Node ID b756ce0002dba3de70d680eea856e997822a7a89
# Parent  9e3111d203c0d3c1899dfa6a4956b0a43d2acf0b
split implementation and interface in mx-op-defs and MArray-defs

diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -51,16 +51,17 @@ along with Octave; see the file COPYING.
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "mx-cm-dm.h"
 #include "mx-dm-cm.h"
 #include "mx-cm-s.h"
 #include "mx-inlines.cc"
+#include "mx-op-defs.h"
 #include "oct-cmplx.h"
 #include "oct-norm.h"
 
 #if defined (HAVE_FFTW3)
 #include "oct-fftw.h"
 #endif
 
 // Fortran functions we call.
diff --git a/liboctave/CMatrix.h b/liboctave/CMatrix.h
--- a/liboctave/CMatrix.h
+++ b/liboctave/CMatrix.h
@@ -24,17 +24,17 @@ along with Octave; see the file COPYING.
 #if !defined (octave_ComplexMatrix_h)
 #define octave_ComplexMatrix_h 1
 
 #include "MArray2.h"
 #include "MDiagArray2.h"
 #include "MatrixType.h"
 
 #include "mx-defs.h"
-#include "mx-op-defs.h"
+#include "mx-op-decl.h"
 #include "oct-cmplx.h"
 #include "DET.h"
 
 class
 OCTAVE_API
 ComplexMatrix : public MArray2<Complex>
 {
 public:
diff --git a/liboctave/CNDArray.cc b/liboctave/CNDArray.cc
--- a/liboctave/CNDArray.cc
+++ b/liboctave/CNDArray.cc
@@ -32,16 +32,17 @@ along with Octave; see the file COPYING.
 #include "Array-util.h"
 #include "CNDArray.h"
 #include "mx-base.h"
 #include "f77-fcn.h"
 #include "functor.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "oct-locbuf.h"
+#include "mx-op-defs.h"
 
 #if defined (HAVE_FFTW3)
 #include "oct-fftw.h"
 #else
 extern "C"
 {
   // Note that the original complex fft routines were not written for
   // double complex arguments.  They have been modified by adding an
diff --git a/liboctave/CNDArray.h b/liboctave/CNDArray.h
--- a/liboctave/CNDArray.h
+++ b/liboctave/CNDArray.h
@@ -22,17 +22,17 @@ along with Octave; see the file COPYING.
 
 #if !defined (octave_ComplexNDArray_h)
 #define octave_ComplexNDArray_h 1
 
 #include "MArrayN.h"
 #include "CMatrix.h"
 
 #include "mx-defs.h"
-#include "mx-op-defs.h"
+#include "mx-op-decl.h"
 
 class
 OCTAVE_API
 ComplexNDArray : public MArrayN<Complex>
 {
 public:
 
   ComplexNDArray (void) : MArrayN<Complex> () { }
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,31 @@
+2009-02-17  Jaroslav Hajek  <highegg@gmail.com>
+
+	* MArray-defs.h: Move declarative part to MArray-decl.h
+	* MArray-decl.h: New source.
+
+	* mx-op-defs.h: Move declarative part to mx-op-decl.h.
+	* mx-op-decl.h: New source.
+
+	* Makefile.in: Include new sources in build.
+	* mk-ops.awk: Include mx-op-decl.h in headers, mx-op-defs in .cc
+	files.
+
+	* CMatrix.cc, CMatrix.h, CNDArray.cc, CNDArray.h, MArray.h, MArray2.h,
+	MArrayN.h, MDiagArray2.h, boolMatrix.cc, boolMatrix.h, boolNDArray.cc,
+	boolNDArray.h, chMatrix.cc, chMatrix.h, chNDArray.cc, chNDArray.h,
+	dMatrix.cc, dMatrix.h, dNDArray.cc, dNDArray.h, fCMatrix.cc,
+	fCMatrix.h, fCNDArray.cc, fCNDArray.h, fMatrix.cc, fMatrix.h,
+	fNDArray.cc, fNDArray.h, int16NDArray.cc, int16NDArray.h,
+	int32NDArray.cc, int32NDArray.h, int64NDArray.cc, int64NDArray.h,
+	int8NDArray.cc, int8NDArray.h, uint16NDArray.cc, uint16NDArray.h,
+	uint32NDArray.cc, uint32NDArray.h, uint64NDArray.cc, uint64NDArray.h,
+	uint8NDArray.cc, uint8NDArray.h: Ditto.
+
 2009-02-16  Jaroslav Hajek  <highegg@gmail.com>
 
 	* Array.cc (Array<T>::assign (const idx_vector& i,
 	const idx_vector& j,...)): Fix invalid dimension inquiry.
 
 2009-02-16  Jaroslav Hajek  <highegg@gmail.com>
 	
 	* mx-inlines.cc (OP_ROW_SHORT_CIRCUIT): New macro.
diff --git a/liboctave/MArray-decl.h b/liboctave/MArray-decl.h
new file mode 100644
--- /dev/null
+++ b/liboctave/MArray-decl.h
@@ -0,0 +1,249 @@
+/*
+
+Copyright (C) 1996, 1999, 2000, 2003, 2005, 2006, 2007 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#if !defined (octave_MArray_decl_h)
+#define octave_MArray_decl_h 1
+
+// A macro that can be used to declare and instantiate OP= operators.
+#define MARRAY_OP_ASSIGN_DECL(A_T, E_T, OP, PFX, API, LTGT, RHS_T) \
+  PFX API A_T<E_T>& \
+  operator OP LTGT (A_T<E_T>&, const RHS_T&)
+
+// All the OP= operators that we care about.
+#define MARRAY_OP_ASSIGN_DECLS(A_T, E_T, PFX, API, LTGT, RHS_T) \
+  MARRAY_OP_ASSIGN_DECL (A_T, E_T, +=, PFX, API, LTGT, RHS_T); \
+  MARRAY_OP_ASSIGN_DECL (A_T, E_T, -=, PFX, API, LTGT, RHS_T);
+
+// Generate forward declarations for OP= operators.
+#define MARRAY_OP_ASSIGN_FWD_DECLS(A_T, RHS_T, API) \
+  MARRAY_OP_ASSIGN_DECLS (A_T, T, template <typename T>, API, , RHS_T)
+
+// Generate friend declarations for the OP= operators.
+#define MARRAY_OP_ASSIGN_FRIENDS(A_T, RHS_T, API) \
+  MARRAY_OP_ASSIGN_DECLS (A_T, T, friend, API, <>, RHS_T)
+
+// A function that can be used to forward OP= operations from derived
+// classes back to us.
+#define MARRAY_OP_ASSIGN_FWD_FCN(R, F, T, C_X, X_T, C_Y, Y_T) \
+  inline R \
+  F (X_T& x, const Y_T& y) \
+  { \
+    return R (F (C_X (x), C_Y (y))); \
+  }
+
+// All the OP= operators that we care about forwarding.
+#define MARRAY_OP_ASSIGN_FWD_DEFS(R, T, C_X, X_T, C_Y, Y_T) \
+  MARRAY_OP_ASSIGN_FWD_FCN (R, operator +=, T, C_X, X_T, C_Y, Y_T) \
+  MARRAY_OP_ASSIGN_FWD_FCN (R, operator -=, T, C_X, X_T, C_Y, Y_T)
+
+// A macro that can be used to declare and instantiate unary operators.
+#define MARRAY_UNOP(A_T, E_T, F, PFX, API, LTGT) \
+  PFX API A_T<E_T> \
+  F LTGT (const A_T<E_T>&)
+
+// All the unary operators that we care about.
+#define MARRAY_UNOP_DECLS(A_T, E_T, PFX, API, LTGT) \
+  MARRAY_UNOP (A_T, E_T, operator +, PFX, API, LTGT); \
+  MARRAY_UNOP (A_T, E_T, operator -, PFX, API, LTGT);
+
+// Generate forward declarations for unary operators.
+#define MARRAY_UNOP_FWD_DECLS(A_T, API) \
+  MARRAY_UNOP_DECLS (A_T, T, template <typename T>, API, )
+
+// Generate friend declarations for the unary operators.
+#define MARRAY_UNOP_FRIENDS(A_T, API) \
+  MARRAY_UNOP_DECLS (A_T, T, friend, API, <>)
+
+// A function that can be used to forward unary operations from derived
+// classes back to us.
+#define MARRAY_UNOP_FWD_FCN(R, F, T, C_X, X_T) \
+  inline R \
+  F (const X_T& x) \
+  { \
+    return R (F (C_X (x))); \
+  }
+
+// All the unary operators that we care about forwarding.
+#define MARRAY_UNOP_FWD_DEFS(R, T, C_X, X_T) \
+  MARRAY_UNOP_FWD_FCN (R, operator +, T, C_X, X_T) \
+  MARRAY_UNOP_FWD_FCN (R, operator -, T, C_X, X_T)
+
+// A macro that can be used to declare and instantiate binary operators.
+#define MARRAY_BINOP_DECL(A_T, E_T, F, PFX, API, LTGT, X_T, Y_T) \
+  PFX API A_T<E_T> \
+  F LTGT (const X_T&, const Y_T&)
+
+// All the binary operators that we care about.  We have two
+// sets of macros since the MArray OP MArray operations use functions
+// (product and quotient) instead of operators (*, /).
+#define MARRAY_BINOP_DECLS(A_T, E_T, PFX, API, LTGT, X_T, Y_T) \
+  MARRAY_BINOP_DECL (A_T, E_T, operator +, PFX, API, LTGT, X_T, Y_T); \
+  MARRAY_BINOP_DECL (A_T, E_T, operator -, PFX, API, LTGT, X_T, Y_T); \
+  MARRAY_BINOP_DECL (A_T, E_T, operator *, PFX, API, LTGT, X_T, Y_T); \
+  MARRAY_BINOP_DECL (A_T, E_T, operator /, PFX, API, LTGT, X_T, Y_T);
+
+#define MARRAY_AA_BINOP_DECLS(A_T, E_T, PFX, API, LTGT) \
+  MARRAY_BINOP_DECL (A_T, E_T, operator +, PFX, API, LTGT, A_T<E_T>, A_T<E_T>); \
+  MARRAY_BINOP_DECL (A_T, E_T, operator -, PFX, API, LTGT, A_T<E_T>, A_T<E_T>); \
+  MARRAY_BINOP_DECL (A_T, E_T, quotient,   PFX, API, LTGT, A_T<E_T>, A_T<E_T>); \
+  MARRAY_BINOP_DECL (A_T, E_T, product,    PFX, API, LTGT, A_T<E_T>, A_T<E_T>);
+
+#define MDIAGARRAY2_DAS_BINOP_DECLS(A_T, E_T, PFX, API, LTGT, X_T, Y_T) \
+  MARRAY_BINOP_DECL (A_T, E_T, operator *, PFX, API, LTGT, X_T, Y_T); \
+  MARRAY_BINOP_DECL (A_T, E_T, operator /, PFX, API, LTGT, X_T, Y_T);
+
+#define MDIAGARRAY2_SDA_BINOP_DECLS(A_T, E_T, PFX, API, LTGT, X_T, Y_T) \
+  MARRAY_BINOP_DECL (A_T, E_T, operator *, PFX, API, LTGT, X_T, Y_T);
+
+#define MDIAGARRAY2_DADA_BINOP_DECLS(A_T, E_T, PFX, API, LTGT) \
+  MARRAY_BINOP_DECL (A_T, E_T, operator +, PFX, API, LTGT, A_T<E_T>, A_T<E_T>); \
+  MARRAY_BINOP_DECL (A_T, E_T, operator -, PFX, API, LTGT, A_T<E_T>, A_T<E_T>); \
+  MARRAY_BINOP_DECL (A_T, E_T, product,    PFX, API, LTGT, A_T<E_T>, A_T<E_T>);
+
+// Generate forward declarations for binary operators.
+#define MARRAY_BINOP_FWD_DECLS(A_T, API) \
+  MARRAY_BINOP_DECLS (A_T, T, template <typename T>, API, , A_T<T>, T) \
+  MARRAY_BINOP_DECLS (A_T, T, template <typename T>, API, , T, A_T<T>) \
+  MARRAY_AA_BINOP_DECLS (A_T, T, template <typename T>, API, )
+
+#define MDIAGARRAY2_BINOP_FWD_DECLS(A_T, API) \
+  MDIAGARRAY2_DAS_BINOP_DECLS (A_T, T, template <typename T>, API, , A_T<T>, T) \
+  MDIAGARRAY2_SDA_BINOP_DECLS (A_T, T, template <typename T>, API, , T, A_T<T>) \
+  MDIAGARRAY2_DADA_BINOP_DECLS (A_T, T, template <typename T>, API, )
+
+// Generate friend declarations for the binary operators.
+#define MARRAY_BINOP_FRIENDS(A_T, API) \
+  MARRAY_BINOP_DECLS (A_T, T, friend, API, <>, A_T<T>, T) \
+  MARRAY_BINOP_DECLS (A_T, T, friend, API, <>, T, A_T<T>) \
+  MARRAY_AA_BINOP_DECLS (A_T, T, friend, API, <>)
+
+#define MDIAGARRAY2_BINOP_FRIENDS(A_T, API) \
+  MDIAGARRAY2_DAS_BINOP_DECLS (A_T, T, friend, API, <>, A_T<T>, T) \
+  MDIAGARRAY2_SDA_BINOP_DECLS (A_T, T, friend, API, <>, T, A_T<T>) \
+  MDIAGARRAY2_DADA_BINOP_DECLS (A_T, T, friend, API, <>)
+
+// A function that can be used to forward binary operations from derived
+// classes back to us.
+#define MARRAY_BINOP_FWD_FCN(R, F, T, C_X, X_T, C_Y, Y_T) \
+  inline R \
+  F (const X_T& x, const Y_T& y) \
+  { \
+    return R (F (C_X (x), C_Y (y))); \
+  }
+
+// The binary operators that we care about forwarding.  We have two
+// sets of macros since the MArray OP MArray operations use functions
+// (product and quotient) instead of operators (*, /).
+#define MARRAY_BINOP_FWD_DEFS(R, T, C_X, X_T, C_Y, Y_T) \
+  MARRAY_BINOP_FWD_FCN (R, operator +, T, C_X, X_T, C_Y, Y_T) \
+  MARRAY_BINOP_FWD_FCN (R, operator -, T, C_X, X_T, C_Y, Y_T) \
+  MARRAY_BINOP_FWD_FCN (R, operator *, T, C_X, X_T, C_Y, Y_T) \
+  MARRAY_BINOP_FWD_FCN (R, operator /, T, C_X, X_T, C_Y, Y_T)
+
+#define MARRAY_AA_BINOP_FWD_DEFS(R, T, C_X, X_T, C_Y, Y_T) \
+  MARRAY_BINOP_FWD_FCN (R, operator +, T, C_X, X_T, C_Y, Y_T) \
+  MARRAY_BINOP_FWD_FCN (R, operator -, T, C_X, X_T, C_Y, Y_T) \
+  MARRAY_BINOP_FWD_FCN (R, product,    T, C_X, X_T, C_Y, Y_T) \
+  MARRAY_BINOP_FWD_FCN (R, quotient,   T, C_X, X_T, C_Y, Y_T)
+
+#define MDIAGARRAY2_DAS_BINOP_FWD_DEFS(R, T, C_X, X_T, C_Y, Y_T) \
+  MARRAY_BINOP_FWD_FCN (R, operator *, T, C_X, X_T, C_Y, Y_T) \
+  MARRAY_BINOP_FWD_FCN (R, operator /, T, C_X, X_T, C_Y, Y_T)
+
+#define MDIAGARRAY2_SDA_BINOP_FWD_DEFS(R, T, C_X, X_T, C_Y, Y_T) \
+  MARRAY_BINOP_FWD_FCN (R, operator *, T, C_X, X_T, C_Y, Y_T)
+
+#define MDIAGARRAY2_DADA_BINOP_FWD_DEFS(R, T, C_X, X_T, C_Y, Y_T) \
+  MARRAY_BINOP_FWD_FCN (R, operator +, T, C_X, X_T, C_Y, Y_T) \
+  MARRAY_BINOP_FWD_FCN (R, operator -, T, C_X, X_T, C_Y, Y_T) \
+  MARRAY_BINOP_FWD_FCN (R, product,    T, C_X, X_T, C_Y, Y_T)
+
+// Forward declarations for the MArray operators.
+#define MARRAY_OPS_FORWARD_DECLS(A_T, API) \
+  template <class T> \
+  class A_T; \
+ \
+  MARRAY_OP_ASSIGN_FWD_DECLS (A_T, T, API) \
+  MARRAY_OP_ASSIGN_FWD_DECLS (A_T, A_T<T>, API) \
+  MARRAY_UNOP_FWD_DECLS (A_T, API) \
+  MARRAY_BINOP_FWD_DECLS (A_T, API)
+
+#define MDIAGARRAY2_OPS_FORWARD_DECLS(A_T, API) \
+  template <class T> \
+  class A_T; \
+ \
+  MARRAY_OP_ASSIGN_FWD_DECLS (A_T, A_T<T>, API) \
+  MARRAY_UNOP_FWD_DECLS (A_T, API) \
+  MDIAGARRAY2_BINOP_FWD_DECLS (A_T, API)
+
+// Friend declarations for the MArray operators.
+#define MARRAY_OPS_FRIEND_DECLS(A_T, API) \
+  MARRAY_OP_ASSIGN_FRIENDS (A_T, T, API) \
+  MARRAY_OP_ASSIGN_FRIENDS (A_T, A_T<T>, API) \
+  MARRAY_UNOP_FRIENDS (A_T, API) \
+  MARRAY_BINOP_FRIENDS (A_T, API)
+
+#define MDIAGARRAY2_OPS_FRIEND_DECLS(A_T, API) \
+  MARRAY_OP_ASSIGN_FRIENDS (A_T, A_T<T>, API) \
+  MARRAY_UNOP_FRIENDS (A_T, API) \
+  MDIAGARRAY2_BINOP_FRIENDS (A_T, API)
+
+// Define all the MArray forwarding functions for return type R and
+// MArray element type T
+#define MARRAY_FORWARD_DEFS(B, R, T) \
+  MARRAY_OP_ASSIGN_FWD_DEFS \
+    (R, T, dynamic_cast<B<T>&>, R, , T) \
+ \
+  MARRAY_OP_ASSIGN_FWD_DEFS \
+    (R, T, \
+     dynamic_cast<B<T>&>, R, dynamic_cast<const B<T>&>, R) \
+ \
+  MARRAY_UNOP_FWD_DEFS \
+    (R, T, dynamic_cast<const B<T>&>, R) \
+ \
+  MARRAY_BINOP_FWD_DEFS \
+    (R, T, dynamic_cast<const B<T>&>, R, , T) \
+ \
+  MARRAY_BINOP_FWD_DEFS \
+    (R, T, , T, dynamic_cast<const B<T>&>, R) \
+ \
+  MARRAY_AA_BINOP_FWD_DEFS \
+    (R, T, dynamic_cast<const B<T>&>, R, dynamic_cast<const B<T>&>, R)
+
+#define MDIAGARRAY2_FORWARD_DEFS(B, R, T) \
+  MARRAY_OP_ASSIGN_FWD_DEFS \
+    (R, T, \
+     dynamic_cast<B<T>&>, R, dynamic_cast<const B<T>&>, R) \
+ \
+  MARRAY_UNOP_FWD_DEFS \
+    (R, T, dynamic_cast<const B<T>&>, R) \
+ \
+  MDIAGARRAY2_DAS_BINOP_FWD_DEFS \
+    (R, T, dynamic_cast<const B<T>&>, R, , T) \
+ \
+  MDIAGARRAY2_SDA_BINOP_FWD_DEFS \
+    (R, T, , T, dynamic_cast<const B<T>&>, R) \
+ \
+  MDIAGARRAY2_DADA_BINOP_FWD_DEFS \
+    (R, T, dynamic_cast<const B<T>&>, R, dynamic_cast<const B<T>&>, R)
+
+#endif
diff --git a/liboctave/MArray-defs.h b/liboctave/MArray-defs.h
--- a/liboctave/MArray-defs.h
+++ b/liboctave/MArray-defs.h
@@ -67,219 +67,35 @@ along with Octave; see the file COPYING.
     { \
       T *a_tmp = a.fortran_vec (); \
       const T *b_tmp = b.data (); \
       for (octave_idx_type i = 0; i < l; i++) \
 	a_tmp[i] OP b_tmp[i]; \
     } \
   while (0)
 
-// A macro that can be used to declare and instantiate OP= operators.
-#define MARRAY_OP_ASSIGN_DECL(A_T, E_T, OP, PFX, API, LTGT, RHS_T) \
-  PFX API A_T<E_T>& \
-  operator OP LTGT (A_T<E_T>&, const RHS_T&)
-
-// All the OP= operators that we care about.
-#define MARRAY_OP_ASSIGN_DECLS(A_T, E_T, PFX, API, LTGT, RHS_T) \
-  MARRAY_OP_ASSIGN_DECL (A_T, E_T, +=, PFX, API, LTGT, RHS_T); \
-  MARRAY_OP_ASSIGN_DECL (A_T, E_T, -=, PFX, API, LTGT, RHS_T);
-
-// Generate forward declarations for OP= operators.
-#define MARRAY_OP_ASSIGN_FWD_DECLS(A_T, RHS_T, API) \
-  MARRAY_OP_ASSIGN_DECLS (A_T, T, template <typename T>, API, , RHS_T)
-
-// Generate friend declarations for the OP= operators.
-#define MARRAY_OP_ASSIGN_FRIENDS(A_T, RHS_T, API) \
-  MARRAY_OP_ASSIGN_DECLS (A_T, T, friend, API, <>, RHS_T)
-
 // Instantiate the OP= operators.
 #define MARRAY_OP_ASSIGN_DEFS(A_T, E_T, RHS_T, API) \
   MARRAY_OP_ASSIGN_DECLS (A_T, E_T, template, API, , RHS_T)
 
-// A function that can be used to forward OP= operations from derived
-// classes back to us.
-#define MARRAY_OP_ASSIGN_FWD_FCN(R, F, T, C_X, X_T, C_Y, Y_T) \
-  inline R \
-  F (X_T& x, const Y_T& y) \
-  { \
-    return R (F (C_X (x), C_Y (y))); \
-  }
-
-// All the OP= operators that we care about forwarding.
-#define MARRAY_OP_ASSIGN_FWD_DEFS(R, T, C_X, X_T, C_Y, Y_T) \
-  MARRAY_OP_ASSIGN_FWD_FCN (R, operator +=, T, C_X, X_T, C_Y, Y_T) \
-  MARRAY_OP_ASSIGN_FWD_FCN (R, operator -=, T, C_X, X_T, C_Y, Y_T)
-
-// A macro that can be used to declare and instantiate unary operators.
-#define MARRAY_UNOP(A_T, E_T, F, PFX, API, LTGT) \
-  PFX API A_T<E_T> \
-  F LTGT (const A_T<E_T>&)
-
-// All the unary operators that we care about.
-#define MARRAY_UNOP_DECLS(A_T, E_T, PFX, API, LTGT) \
-  MARRAY_UNOP (A_T, E_T, operator +, PFX, API, LTGT); \
-  MARRAY_UNOP (A_T, E_T, operator -, PFX, API, LTGT);
-
-// Generate forward declarations for unary operators.
-#define MARRAY_UNOP_FWD_DECLS(A_T, API) \
-  MARRAY_UNOP_DECLS (A_T, T, template <typename T>, API, )
-
-// Generate friend declarations for the unary operators.
-#define MARRAY_UNOP_FRIENDS(A_T, API) \
-  MARRAY_UNOP_DECLS (A_T, T, friend, API, <>)
-
 // Instantiate the unary operators.
 #define MARRAY_UNOP_DEFS(A_T, E_T, API) \
   MARRAY_UNOP_DECLS (A_T, E_T, template, API, )
 
-// A function that can be used to forward unary operations from derived
-// classes back to us.
-#define MARRAY_UNOP_FWD_FCN(R, F, T, C_X, X_T) \
-  inline R \
-  F (const X_T& x) \
-  { \
-    return R (F (C_X (x))); \
-  }
-
-// All the unary operators that we care about forwarding.
-#define MARRAY_UNOP_FWD_DEFS(R, T, C_X, X_T) \
-  MARRAY_UNOP_FWD_FCN (R, operator +, T, C_X, X_T) \
-  MARRAY_UNOP_FWD_FCN (R, operator -, T, C_X, X_T)
-
-// A macro that can be used to declare and instantiate binary operators.
-#define MARRAY_BINOP_DECL(A_T, E_T, F, PFX, API, LTGT, X_T, Y_T) \
-  PFX API A_T<E_T> \
-  F LTGT (const X_T&, const Y_T&)
-
-// All the binary operators that we care about.  We have two
-// sets of macros since the MArray OP MArray operations use functions
-// (product and quotient) instead of operators (*, /).
-#define MARRAY_BINOP_DECLS(A_T, E_T, PFX, API, LTGT, X_T, Y_T) \
-  MARRAY_BINOP_DECL (A_T, E_T, operator +, PFX, API, LTGT, X_T, Y_T); \
-  MARRAY_BINOP_DECL (A_T, E_T, operator -, PFX, API, LTGT, X_T, Y_T); \
-  MARRAY_BINOP_DECL (A_T, E_T, operator *, PFX, API, LTGT, X_T, Y_T); \
-  MARRAY_BINOP_DECL (A_T, E_T, operator /, PFX, API, LTGT, X_T, Y_T);
-
-#define MARRAY_AA_BINOP_DECLS(A_T, E_T, PFX, API, LTGT) \
-  MARRAY_BINOP_DECL (A_T, E_T, operator +, PFX, API, LTGT, A_T<E_T>, A_T<E_T>); \
-  MARRAY_BINOP_DECL (A_T, E_T, operator -, PFX, API, LTGT, A_T<E_T>, A_T<E_T>); \
-  MARRAY_BINOP_DECL (A_T, E_T, quotient,   PFX, API, LTGT, A_T<E_T>, A_T<E_T>); \
-  MARRAY_BINOP_DECL (A_T, E_T, product,    PFX, API, LTGT, A_T<E_T>, A_T<E_T>);
-
-#define MDIAGARRAY2_DAS_BINOP_DECLS(A_T, E_T, PFX, API, LTGT, X_T, Y_T) \
-  MARRAY_BINOP_DECL (A_T, E_T, operator *, PFX, API, LTGT, X_T, Y_T); \
-  MARRAY_BINOP_DECL (A_T, E_T, operator /, PFX, API, LTGT, X_T, Y_T);
-
-#define MDIAGARRAY2_SDA_BINOP_DECLS(A_T, E_T, PFX, API, LTGT, X_T, Y_T) \
-  MARRAY_BINOP_DECL (A_T, E_T, operator *, PFX, API, LTGT, X_T, Y_T);
-
-#define MDIAGARRAY2_DADA_BINOP_DECLS(A_T, E_T, PFX, API, LTGT) \
-  MARRAY_BINOP_DECL (A_T, E_T, operator +, PFX, API, LTGT, A_T<E_T>, A_T<E_T>); \
-  MARRAY_BINOP_DECL (A_T, E_T, operator -, PFX, API, LTGT, A_T<E_T>, A_T<E_T>); \
-  MARRAY_BINOP_DECL (A_T, E_T, product,    PFX, API, LTGT, A_T<E_T>, A_T<E_T>);
-
-// Generate forward declarations for binary operators.
-#define MARRAY_BINOP_FWD_DECLS(A_T, API) \
-  MARRAY_BINOP_DECLS (A_T, T, template <typename T>, API, , A_T<T>, T) \
-  MARRAY_BINOP_DECLS (A_T, T, template <typename T>, API, , T, A_T<T>) \
-  MARRAY_AA_BINOP_DECLS (A_T, T, template <typename T>, API, )
-
-#define MDIAGARRAY2_BINOP_FWD_DECLS(A_T, API) \
-  MDIAGARRAY2_DAS_BINOP_DECLS (A_T, T, template <typename T>, API, , A_T<T>, T) \
-  MDIAGARRAY2_SDA_BINOP_DECLS (A_T, T, template <typename T>, API, , T, A_T<T>) \
-  MDIAGARRAY2_DADA_BINOP_DECLS (A_T, T, template <typename T>, API, )
-
-// Generate friend declarations for the binary operators.
-#define MARRAY_BINOP_FRIENDS(A_T, API) \
-  MARRAY_BINOP_DECLS (A_T, T, friend, API, <>, A_T<T>, T) \
-  MARRAY_BINOP_DECLS (A_T, T, friend, API, <>, T, A_T<T>) \
-  MARRAY_AA_BINOP_DECLS (A_T, T, friend, API, <>)
-
-#define MDIAGARRAY2_BINOP_FRIENDS(A_T, API) \
-  MDIAGARRAY2_DAS_BINOP_DECLS (A_T, T, friend, API, <>, A_T<T>, T) \
-  MDIAGARRAY2_SDA_BINOP_DECLS (A_T, T, friend, API, <>, T, A_T<T>) \
-  MDIAGARRAY2_DADA_BINOP_DECLS (A_T, T, friend, API, <>)
-
 // Instantiate the binary operators.
 #define MARRAY_BINOP_DEFS(A_T, E_T, API) \
   MARRAY_BINOP_DECLS (A_T, E_T, template, API, , A_T<E_T>, E_T) \
   MARRAY_BINOP_DECLS (A_T, E_T, template, API, , E_T, A_T<E_T>) \
   MARRAY_AA_BINOP_DECLS (A_T, E_T, template, API, )
 
 #define MDIAGARRAY2_BINOP_DEFS(A_T, E_T, API) \
   MDIAGARRAY2_DAS_BINOP_DECLS (A_T, E_T, template, API, , A_T<E_T>, E_T) \
   MDIAGARRAY2_SDA_BINOP_DECLS (A_T, E_T, template, API, , E_T, A_T<E_T>) \
   MDIAGARRAY2_DADA_BINOP_DECLS (A_T, E_T, template, API, )
 
-// A function that can be used to forward binary operations from derived
-// classes back to us.
-#define MARRAY_BINOP_FWD_FCN(R, F, T, C_X, X_T, C_Y, Y_T) \
-  inline R \
-  F (const X_T& x, const Y_T& y) \
-  { \
-    return R (F (C_X (x), C_Y (y))); \
-  }
-
-// The binary operators that we care about forwarding.  We have two
-// sets of macros since the MArray OP MArray operations use functions
-// (product and quotient) instead of operators (*, /).
-#define MARRAY_BINOP_FWD_DEFS(R, T, C_X, X_T, C_Y, Y_T) \
-  MARRAY_BINOP_FWD_FCN (R, operator +, T, C_X, X_T, C_Y, Y_T) \
-  MARRAY_BINOP_FWD_FCN (R, operator -, T, C_X, X_T, C_Y, Y_T) \
-  MARRAY_BINOP_FWD_FCN (R, operator *, T, C_X, X_T, C_Y, Y_T) \
-  MARRAY_BINOP_FWD_FCN (R, operator /, T, C_X, X_T, C_Y, Y_T)
-
-#define MARRAY_AA_BINOP_FWD_DEFS(R, T, C_X, X_T, C_Y, Y_T) \
-  MARRAY_BINOP_FWD_FCN (R, operator +, T, C_X, X_T, C_Y, Y_T) \
-  MARRAY_BINOP_FWD_FCN (R, operator -, T, C_X, X_T, C_Y, Y_T) \
-  MARRAY_BINOP_FWD_FCN (R, product,    T, C_X, X_T, C_Y, Y_T) \
-  MARRAY_BINOP_FWD_FCN (R, quotient,   T, C_X, X_T, C_Y, Y_T)
-
-#define MDIAGARRAY2_DAS_BINOP_FWD_DEFS(R, T, C_X, X_T, C_Y, Y_T) \
-  MARRAY_BINOP_FWD_FCN (R, operator *, T, C_X, X_T, C_Y, Y_T) \
-  MARRAY_BINOP_FWD_FCN (R, operator /, T, C_X, X_T, C_Y, Y_T)
-
-#define MDIAGARRAY2_SDA_BINOP_FWD_DEFS(R, T, C_X, X_T, C_Y, Y_T) \
-  MARRAY_BINOP_FWD_FCN (R, operator *, T, C_X, X_T, C_Y, Y_T)
-
-#define MDIAGARRAY2_DADA_BINOP_FWD_DEFS(R, T, C_X, X_T, C_Y, Y_T) \
-  MARRAY_BINOP_FWD_FCN (R, operator +, T, C_X, X_T, C_Y, Y_T) \
-  MARRAY_BINOP_FWD_FCN (R, operator -, T, C_X, X_T, C_Y, Y_T) \
-  MARRAY_BINOP_FWD_FCN (R, product,    T, C_X, X_T, C_Y, Y_T)
-
-// Forward declarations for the MArray operators.
-#define MARRAY_OPS_FORWARD_DECLS(A_T, API) \
-  template <class T> \
-  class A_T; \
- \
-  MARRAY_OP_ASSIGN_FWD_DECLS (A_T, T, API) \
-  MARRAY_OP_ASSIGN_FWD_DECLS (A_T, A_T<T>, API) \
-  MARRAY_UNOP_FWD_DECLS (A_T, API) \
-  MARRAY_BINOP_FWD_DECLS (A_T, API)
-
-#define MDIAGARRAY2_OPS_FORWARD_DECLS(A_T, API) \
-  template <class T> \
-  class A_T; \
- \
-  MARRAY_OP_ASSIGN_FWD_DECLS (A_T, A_T<T>, API) \
-  MARRAY_UNOP_FWD_DECLS (A_T, API) \
-  MDIAGARRAY2_BINOP_FWD_DECLS (A_T, API)
-
-// Friend declarations for the MArray operators.
-#define MARRAY_OPS_FRIEND_DECLS(A_T, API) \
-  MARRAY_OP_ASSIGN_FRIENDS (A_T, T, API) \
-  MARRAY_OP_ASSIGN_FRIENDS (A_T, A_T<T>, API) \
-  MARRAY_UNOP_FRIENDS (A_T, API) \
-  MARRAY_BINOP_FRIENDS (A_T, API)
-
-#define MDIAGARRAY2_OPS_FRIEND_DECLS(A_T, API) \
-  MARRAY_OP_ASSIGN_FRIENDS (A_T, A_T<T>, API) \
-  MARRAY_UNOP_FRIENDS (A_T, API) \
-  MDIAGARRAY2_BINOP_FRIENDS (A_T, API)
-
 // The following macros are for external use.
 
 // Instantiate all the MArray friends for MArray element type T.
 #define INSTANTIATE_MARRAY_FRIENDS(T, API) \
   MARRAY_OP_ASSIGN_DEFS (MArray, T, T, API) \
   MARRAY_OP_ASSIGN_DEFS (MArray, T, MArray<T>, API) \
   MARRAY_UNOP_DEFS (MArray, T, API) \
   MARRAY_BINOP_DEFS (MArray, T, API)
@@ -299,50 +115,11 @@ along with Octave; see the file COPYING.
   MARRAY_BINOP_DEFS (MArrayN, T, API)
 
 // Instantiate all the MDiagArray2 friends for MDiagArray2 element type T.
 #define INSTANTIATE_MDIAGARRAY2_FRIENDS(T, API) \
   MARRAY_OP_ASSIGN_DEFS (MDiagArray2, T, MDiagArray2<T>, API) \
   MARRAY_UNOP_DEFS (MDiagArray2, T, API) \
   MDIAGARRAY2_BINOP_DEFS (MDiagArray2, T, API)
 
-// Define all the MArray forwarding functions for return type R and
-// MArray element type T
-#define MARRAY_FORWARD_DEFS(B, R, T) \
-  MARRAY_OP_ASSIGN_FWD_DEFS \
-    (R, T, dynamic_cast<B<T>&>, R, , T) \
- \
-  MARRAY_OP_ASSIGN_FWD_DEFS \
-    (R, T, \
-     dynamic_cast<B<T>&>, R, dynamic_cast<const B<T>&>, R) \
- \
-  MARRAY_UNOP_FWD_DEFS \
-    (R, T, dynamic_cast<const B<T>&>, R) \
- \
-  MARRAY_BINOP_FWD_DEFS \
-    (R, T, dynamic_cast<const B<T>&>, R, , T) \
- \
-  MARRAY_BINOP_FWD_DEFS \
-    (R, T, , T, dynamic_cast<const B<T>&>, R) \
- \
-  MARRAY_AA_BINOP_FWD_DEFS \
-    (R, T, dynamic_cast<const B<T>&>, R, dynamic_cast<const B<T>&>, R)
-
-#define MDIAGARRAY2_FORWARD_DEFS(B, R, T) \
-  MARRAY_OP_ASSIGN_FWD_DEFS \
-    (R, T, \
-     dynamic_cast<B<T>&>, R, dynamic_cast<const B<T>&>, R) \
- \
-  MARRAY_UNOP_FWD_DEFS \
-    (R, T, dynamic_cast<const B<T>&>, R) \
- \
-  MDIAGARRAY2_DAS_BINOP_FWD_DEFS \
-    (R, T, dynamic_cast<const B<T>&>, R, , T) \
- \
-  MDIAGARRAY2_SDA_BINOP_FWD_DEFS \
-    (R, T, , T, dynamic_cast<const B<T>&>, R) \
- \
-  MDIAGARRAY2_DADA_BINOP_FWD_DEFS \
-    (R, T, dynamic_cast<const B<T>&>, R, dynamic_cast<const B<T>&>, R)
-
 // Now we have all the definitions we need.
 
 #endif
diff --git a/liboctave/MArray.h b/liboctave/MArray.h
--- a/liboctave/MArray.h
+++ b/liboctave/MArray.h
@@ -26,17 +26,17 @@ along with Octave; see the file COPYING.
 #define octave_MArray_h 1
 
 #include "Array.h"
 
 // One dimensional array with math ops.
 
 // But first, some preprocessor abuse...
 
-#include "MArray-defs.h"
+#include "MArray-decl.h"
 
 MARRAY_OPS_FORWARD_DECLS (MArray, )
 
 template <class T>
 class
 MArray : public Array<T>
 {
 protected:
diff --git a/liboctave/MArray2.h b/liboctave/MArray2.h
--- a/liboctave/MArray2.h
+++ b/liboctave/MArray2.h
@@ -26,17 +26,17 @@ along with Octave; see the file COPYING.
 #define octave_MArray2_h 1
 
 #include "Array2.h"
 
 // Two dimensional array with math ops.
 
 // But first, some preprocessor abuse...
 
-#include "MArray-defs.h"
+#include "MArray-decl.h"
 
 MARRAY_OPS_FORWARD_DECLS (MArray2, )
 
 template <class T>
 class
 MArray2 : public Array2<T>
 {
 protected:
diff --git a/liboctave/MArrayN.h b/liboctave/MArrayN.h
--- a/liboctave/MArrayN.h
+++ b/liboctave/MArrayN.h
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 #include "ArrayN.h"
 #include "MArray2.h"
 #include "dim-vector.h"
 
 // N-dimensional array with math ops.
 
 // But first, some preprocessor abuse...
 
-#include "MArray-defs.h"
+#include "MArray-decl.h"
 
 MARRAY_OPS_FORWARD_DECLS (MArrayN, )
 
 template <class T>
 class
 MArrayN : public ArrayN<T>
 {
 protected:
diff --git a/liboctave/MDiagArray2.h b/liboctave/MDiagArray2.h
--- a/liboctave/MDiagArray2.h
+++ b/liboctave/MDiagArray2.h
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 #include "DiagArray2.h"
 #include "MArray2.h"
 #include "MArray.h"
 
 // Two dimensional diagonal array with math ops.
 
 // But first, some preprocessor abuse...
 
-#include "MArray-defs.h"
+#include "MArray-decl.h"
 
 MDIAGARRAY2_OPS_FORWARD_DECLS (MDiagArray2, )
 
 template <class T>
 class
 MDiagArray2 : public DiagArray2<T>
 {
 protected:
diff --git a/liboctave/Makefile.in b/liboctave/Makefile.in
--- a/liboctave/Makefile.in
+++ b/liboctave/Makefile.in
@@ -36,21 +36,21 @@ DLL_CXXDEFS = @OCTAVE_DLL_DEFS@
 
 LINK_DEPS = \
   -L../libcruft -L. $(RLD_FLAG) \
   $(LIBCRUFT) $(CHOLMOD_LIBS) $(UMFPACK_LIBS)  $(AMD_LIBS) \
   $(CAMD_LIBS) $(COLAMD_LIBS) $(CCOLAMD_LIBS) $(CXSPARSE_LIBS) \
   $(ARPACK_LIBS) $(QRUPDATE_LIBS) $(BLAS_LIBS) $(FFTW_LIBS) $(LIBREADLINE) $(LIBGLOB) $(REGEX_LIBS) $(LIBS) $(FLIBS)
 
 MATRIX_INC := Array.h Array2.h Array3.h ArrayN.h DiagArray2.h \
-	Array-util.h ArrayN-idx.h MArray-defs.h \
+	Array-util.h ArrayN-idx.h MArray-decl.h MArray-defs.h \
 	MArray.h MArray2.h MDiagArray2.h Matrix.h MArrayN.h \
-	base-lu.h base-aepbal.h dim-vector.h mx-base.h mx-op-defs.h \
-	mx-defs.h mx-ext.h CColVector.h CDiagMatrix.h CMatrix.h \
-	CNDArray.h CRowVector.h CmplxAEPBAL.h CmplxCHOL.h \
+	base-lu.h base-aepbal.h dim-vector.h mx-base.h mx-op-decl.h \
+	mx-op-defs.h mx-defs.h mx-ext.h CColVector.h CDiagMatrix.h \
+	CMatrix.h CNDArray.h CRowVector.h CmplxAEPBAL.h CmplxCHOL.h \
 	CmplxGEPBAL.h CmplxHESS.h CmplxLU.h CmplxQR.h CmplxQRP.h \
 	CmplxSCHUR.h CmplxSVD.h EIG.h fEIG.h boolMatrix.h boolNDArray.h \
 	chMatrix.h chNDArray.h dColVector.h dDiagMatrix.h dMatrix.h \
 	dNDArray.h dRowVector.h dbleAEPBAL.h dbleCHOL.h DET.h \
 	dbleGEPBAL.h dbleHESS.h dbleLU.h dbleQR.h dbleQRP.h dbleSCHUR.h \
 	dbleSVD.h boolSparse.h CSparse.h dSparse.h MSparse-defs.h MSparse.h \
 	Sparse.h sparse-base-lu.h SparseCmplxLU.h SparsedbleLU.h \
 	sparse-base-chol.h SparseCmplxCHOL.h \
diff --git a/liboctave/boolMatrix.cc b/liboctave/boolMatrix.cc
--- a/liboctave/boolMatrix.cc
+++ b/liboctave/boolMatrix.cc
@@ -28,16 +28,17 @@ along with Octave; see the file COPYING.
 
 #include <iostream>
 
 #include "Array-util.h"
 #include "lo-error.h"
 #include "str-vec.h"
 #include "mx-base.h"
 #include "mx-inlines.cc"
+#include "mx-op-defs.h"
 
 // boolMatrix class.
 
 bool
 boolMatrix::operator == (const boolMatrix& a) const
 {
   if (rows () != a.rows () || cols () != a.cols ())
     return 0;
diff --git a/liboctave/boolMatrix.h b/liboctave/boolMatrix.h
--- a/liboctave/boolMatrix.h
+++ b/liboctave/boolMatrix.h
@@ -22,17 +22,17 @@ along with Octave; see the file COPYING.
 */
 
 #if !defined (octave_boolMatrix_int_h)
 #define octave_boolMatrix_int_h 1
 
 #include "Array2.h"
 
 #include "mx-defs.h"
-#include "mx-op-defs.h"
+#include "mx-op-decl.h"
 
 class
 OCTAVE_API
 boolMatrix : public Array2<bool>
 {
 public:
 
   boolMatrix (void) : Array2<bool> () { }
diff --git a/liboctave/boolNDArray.cc b/liboctave/boolNDArray.cc
--- a/liboctave/boolNDArray.cc
+++ b/liboctave/boolNDArray.cc
@@ -24,16 +24,17 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "Array-util.h"
 #include "CNDArray.h"
 #include "mx-base.h"
 #include "lo-ieee.h"
+#include "mx-op-defs.h"
 
 // unary operations
 
 boolNDArray
 boolNDArray::operator ! (void) const
 {
   boolNDArray b (dims ());
 
diff --git a/liboctave/boolNDArray.h b/liboctave/boolNDArray.h
--- a/liboctave/boolNDArray.h
+++ b/liboctave/boolNDArray.h
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 */
 
 #if !defined (octave_boolNDArray_h)
 #define octave_boolNDArray_h 1
 
 #include "ArrayN.h"
 
 #include "mx-defs.h"
-#include "mx-op-defs.h"
+#include "mx-op-decl.h"
 
 #include "boolMatrix.h"
 
 class
 OCTAVE_API
 boolNDArray : public ArrayN<bool>
 {
 public:
diff --git a/liboctave/chMatrix.cc b/liboctave/chMatrix.cc
--- a/liboctave/chMatrix.cc
+++ b/liboctave/chMatrix.cc
@@ -30,16 +30,17 @@ along with Octave; see the file COPYING.
 
 #include <iostream>
 #include <string>
 
 #include "lo-error.h"
 #include "str-vec.h"
 #include "mx-base.h"
 #include "mx-inlines.cc"
+#include "mx-op-defs.h"
 
 // charMatrix class.
 
 charMatrix::charMatrix (char c)
   : MArray2<char> ()
 {
   octave_idx_type nc = 1;
   octave_idx_type nr = 1;
diff --git a/liboctave/chMatrix.h b/liboctave/chMatrix.h
--- a/liboctave/chMatrix.h
+++ b/liboctave/chMatrix.h
@@ -24,17 +24,17 @@ along with Octave; see the file COPYING.
 #if !defined (octave_chMatrix_int_h)
 #define octave_chMatrix_int_h 1
 
 #include <string>
 
 #include "MArray2.h"
 
 #include "mx-defs.h"
-#include "mx-op-defs.h"
+#include "mx-op-decl.h"
 #include "str-vec.h"
 
 class
 OCTAVE_API
 charMatrix : public MArray2<char>
 {
 friend class ComplexMatrix;
 
diff --git a/liboctave/chNDArray.cc b/liboctave/chNDArray.cc
--- a/liboctave/chNDArray.cc
+++ b/liboctave/chNDArray.cc
@@ -25,16 +25,17 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include "Array-util.h"
 #include "chNDArray.h"
 #include "mx-base.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
+#include "mx-op-defs.h"
 
 // FIXME -- this is not quite the right thing.
 
 boolNDArray
 charNDArray::all (int dim) const
 {
   return do_mx_red_op<boolMatrix> (*this, dim, mx_inline_all);
 }
diff --git a/liboctave/chNDArray.h b/liboctave/chNDArray.h
--- a/liboctave/chNDArray.h
+++ b/liboctave/chNDArray.h
@@ -22,17 +22,17 @@ along with Octave; see the file COPYING.
 
 #if !defined (octave_charNDArray_h)
 #define octave_charNDArray_h 1
 
 #include "MArrayN.h"
 #include "chMatrix.h"
 
 #include "mx-defs.h"
-#include "mx-op-defs.h"
+#include "mx-op-decl.h"
 
 class
 OCTAVE_API
 charNDArray : public MArrayN<char>
 {
 public:
 
   charNDArray (void) : MArrayN<char> () { }
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -46,16 +46,17 @@ along with Octave; see the file COPYING.
 #include "oct-locbuf.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "mx-m-dm.h"
 #include "mx-dm-m.h"
 #include "mx-inlines.cc"
+#include "mx-op-defs.h"
 #include "oct-cmplx.h"
 #include "oct-norm.h"
 #include "quit.h"
 
 #if defined (HAVE_FFTW3)
 #include "oct-fftw.h"
 #endif
 
diff --git a/liboctave/dMatrix.h b/liboctave/dMatrix.h
--- a/liboctave/dMatrix.h
+++ b/liboctave/dMatrix.h
@@ -24,17 +24,17 @@ along with Octave; see the file COPYING.
 #if !defined (octave_Matrix_int_h)
 #define octave_Matrix_int_h 1
 
 #include "MArray2.h"
 #include "MDiagArray2.h"
 #include "MatrixType.h"
 
 #include "mx-defs.h"
-#include "mx-op-defs.h"
+#include "mx-op-decl.h"
 #include "DET.h"
 
 class
 OCTAVE_API
 Matrix : public MArray2<double>
 {
 public:
 
diff --git a/liboctave/dNDArray.cc b/liboctave/dNDArray.cc
--- a/liboctave/dNDArray.cc
+++ b/liboctave/dNDArray.cc
@@ -33,16 +33,17 @@ along with Octave; see the file COPYING.
 #include "dNDArray.h"
 #include "functor.h"
 #include "mx-base.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "oct-locbuf.h"
+#include "mx-op-defs.h"
 
 #if defined (HAVE_FFTW3)
 #include "oct-fftw.h"
 #endif
 
 NDArray::NDArray (const Array<octave_idx_type>& a, bool zero_based,
 		  bool negative_to_nan)
 {
diff --git a/liboctave/dNDArray.h b/liboctave/dNDArray.h
--- a/liboctave/dNDArray.h
+++ b/liboctave/dNDArray.h
@@ -23,17 +23,17 @@ along with Octave; see the file COPYING.
 #if !defined (octave_NDArray_h)
 #define octave_NDArray_h 1
 
 #include "MArrayN.h"
 #include "dMatrix.h"
 #include "intNDArray.h"
 
 #include "mx-defs.h"
-#include "mx-op-defs.h"
+#include "mx-op-decl.h"
 
 class
 OCTAVE_API
 NDArray : public MArrayN<double>
 {
 public:
 
   NDArray (void) : MArrayN<double> () { }
diff --git a/liboctave/fCMatrix.cc b/liboctave/fCMatrix.cc
--- a/liboctave/fCMatrix.cc
+++ b/liboctave/fCMatrix.cc
@@ -50,16 +50,17 @@ along with Octave; see the file COPYING.
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "mx-fcm-fdm.h"
 #include "mx-fdm-fcm.h"
 #include "mx-fcm-fs.h"
 #include "mx-inlines.cc"
+#include "mx-op-defs.h"
 #include "oct-cmplx.h"
 #include "oct-norm.h"
 
 #if defined (HAVE_FFTW3)
 #include "oct-fftw.h"
 #endif
 
 // Fortran functions we call.
diff --git a/liboctave/fCMatrix.h b/liboctave/fCMatrix.h
--- a/liboctave/fCMatrix.h
+++ b/liboctave/fCMatrix.h
@@ -24,17 +24,17 @@ along with Octave; see the file COPYING.
 #if !defined (octave_FloatComplexMatrix_h)
 #define octave_FloatComplexMatrix_h 1
 
 #include "MArray2.h"
 #include "MDiagArray2.h"
 #include "MatrixType.h"
 
 #include "mx-defs.h"
-#include "mx-op-defs.h"
+#include "mx-op-decl.h"
 #include "oct-cmplx.h"
 #include "DET.h"
 
 class
 OCTAVE_API
 FloatComplexMatrix : public MArray2<FloatComplex>
 {
 public:
diff --git a/liboctave/fCNDArray.cc b/liboctave/fCNDArray.cc
--- a/liboctave/fCNDArray.cc
+++ b/liboctave/fCNDArray.cc
@@ -32,16 +32,17 @@ along with Octave; see the file COPYING.
 #include "Array-util.h"
 #include "fCNDArray.h"
 #include "mx-base.h"
 #include "f77-fcn.h"
 #include "functor.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "oct-locbuf.h"
+#include "mx-op-defs.h"
 
 #if defined (HAVE_FFTW3)
 #include "oct-fftw.h"
 #else
 extern "C"
 {
   F77_RET_T
   F77_FUNC (cffti, CFFTI) (const octave_idx_type&, FloatComplex*);
diff --git a/liboctave/fCNDArray.h b/liboctave/fCNDArray.h
--- a/liboctave/fCNDArray.h
+++ b/liboctave/fCNDArray.h
@@ -22,17 +22,17 @@ along with Octave; see the file COPYING.
 
 #if !defined (octave_FloatComplexNDArray_h)
 #define octave_FloatComplexNDArray_h 1
 
 #include "MArrayN.h"
 #include "fCMatrix.h"
 
 #include "mx-defs.h"
-#include "mx-op-defs.h"
+#include "mx-op-decl.h"
 
 class
 OCTAVE_API
 FloatComplexNDArray : public MArrayN<FloatComplex>
 {
 public:
 
   FloatComplexNDArray (void) : MArrayN<FloatComplex> () { }
diff --git a/liboctave/fMatrix.cc b/liboctave/fMatrix.cc
--- a/liboctave/fMatrix.cc
+++ b/liboctave/fMatrix.cc
@@ -45,16 +45,17 @@ along with Octave; see the file COPYING.
 #include "oct-locbuf.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "mx-fm-fdm.h"
 #include "mx-fdm-fm.h"
 #include "mx-inlines.cc"
+#include "mx-op-defs.h"
 #include "oct-cmplx.h"
 #include "oct-norm.h"
 #include "quit.h"
 
 #if defined (HAVE_FFTW3)
 #include "oct-fftw.h"
 #endif
 
diff --git a/liboctave/fMatrix.h b/liboctave/fMatrix.h
--- a/liboctave/fMatrix.h
+++ b/liboctave/fMatrix.h
@@ -24,17 +24,17 @@ along with Octave; see the file COPYING.
 #if !defined (octave_FloatMatrix_int_h)
 #define octave_FloatMatrix_int_h 1
 
 #include "MArray2.h"
 #include "MDiagArray2.h"
 #include "MatrixType.h"
 
 #include "mx-defs.h"
-#include "mx-op-defs.h"
+#include "mx-op-decl.h"
 #include "DET.h"
 
 class
 OCTAVE_API
 FloatMatrix : public MArray2<float>
 {
 public:
 
diff --git a/liboctave/fNDArray.cc b/liboctave/fNDArray.cc
--- a/liboctave/fNDArray.cc
+++ b/liboctave/fNDArray.cc
@@ -33,16 +33,17 @@ along with Octave; see the file COPYING.
 #include "fNDArray.h"
 #include "functor.h"
 #include "mx-base.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "oct-locbuf.h"
+#include "mx-op-defs.h"
 
 #if defined (HAVE_FFTW3)
 #include "oct-fftw.h"
 
 FloatComplexNDArray
 FloatNDArray::fourier (int dim) const
 {
   dim_vector dv = dims ();
diff --git a/liboctave/fNDArray.h b/liboctave/fNDArray.h
--- a/liboctave/fNDArray.h
+++ b/liboctave/fNDArray.h
@@ -23,17 +23,17 @@ along with Octave; see the file COPYING.
 #if !defined (octave_FloatNDArray_h)
 #define octave_FloatNDArray_h 1
 
 #include "MArrayN.h"
 #include "fMatrix.h"
 #include "intNDArray.h"
 
 #include "mx-defs.h"
-#include "mx-op-defs.h"
+#include "mx-op-decl.h"
 
 class
 OCTAVE_API
 FloatNDArray : public MArrayN<float>
 {
 public:
 
   FloatNDArray (void) : MArrayN<float> () { }
diff --git a/liboctave/int16NDArray.cc b/liboctave/int16NDArray.cc
--- a/liboctave/int16NDArray.cc
+++ b/liboctave/int16NDArray.cc
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "int16NDArray.h"
-
+#include "mx-op-defs.h"
 #include "intNDArray.cc"
 
 template class OCTAVE_API intNDArray<octave_int16>;
 
 template OCTAVE_API
 std::ostream&
 operator << (std::ostream& os, const intNDArray<octave_int16>& a);
 
diff --git a/liboctave/int16NDArray.h b/liboctave/int16NDArray.h
--- a/liboctave/int16NDArray.h
+++ b/liboctave/int16NDArray.h
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_int16NDArray_h)
 #define octave_int16NDArray_h 1
 
 #include "intNDArray.h"
-#include "mx-op-defs.h"
+#include "mx-op-decl.h"
 #include "oct-inttypes.h"
 
 typedef intNDArray<octave_int16> int16NDArray;
 
 NDS_CMP_OP_DECLS (int16NDArray, octave_int16, OCTAVE_API)
 NDS_BOOL_OP_DECLS (int16NDArray, octave_int16, OCTAVE_API)
 
 SND_CMP_OP_DECLS (octave_int16, int16NDArray, OCTAVE_API)
diff --git a/liboctave/int32NDArray.cc b/liboctave/int32NDArray.cc
--- a/liboctave/int32NDArray.cc
+++ b/liboctave/int32NDArray.cc
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "int32NDArray.h"
-
+#include "mx-op-defs.h"
 #include "intNDArray.cc"
 
 template class OCTAVE_API intNDArray<octave_int32>;
 
 template OCTAVE_API
 std::ostream&
 operator << (std::ostream& os, const intNDArray<octave_int32>& a);
 
diff --git a/liboctave/int32NDArray.h b/liboctave/int32NDArray.h
--- a/liboctave/int32NDArray.h
+++ b/liboctave/int32NDArray.h
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_int32NDArray_h)
 #define octave_int32NDArray_h 1
 
 #include "intNDArray.h"
-#include "mx-op-defs.h"
+#include "mx-op-decl.h"
 #include "oct-inttypes.h"
 
 typedef intNDArray<octave_int32> int32NDArray;
 
 NDS_CMP_OP_DECLS (int32NDArray, octave_int32, OCTAVE_API)
 NDS_BOOL_OP_DECLS (int32NDArray, octave_int32, OCTAVE_API)
 
 SND_CMP_OP_DECLS (octave_int32, int32NDArray, OCTAVE_API)
diff --git a/liboctave/int64NDArray.cc b/liboctave/int64NDArray.cc
--- a/liboctave/int64NDArray.cc
+++ b/liboctave/int64NDArray.cc
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "int64NDArray.h"
-
+#include "mx-op-defs.h"
 #include "intNDArray.cc"
 
 template class OCTAVE_API intNDArray<octave_int64>;
 
 template OCTAVE_API
 std::ostream&
 operator << (std::ostream& os, const intNDArray<octave_int64>& a);
 
diff --git a/liboctave/int64NDArray.h b/liboctave/int64NDArray.h
--- a/liboctave/int64NDArray.h
+++ b/liboctave/int64NDArray.h
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_int64NDArray_h)
 #define octave_int64NDArray_h 1
 
 #include "intNDArray.h"
-#include "mx-op-defs.h"
+#include "mx-op-decl.h"
 #include "oct-inttypes.h"
 
 typedef intNDArray<octave_int64> int64NDArray;
 
 NDS_CMP_OP_DECLS (int64NDArray, octave_int64, OCTAVE_API)
 NDS_BOOL_OP_DECLS (int64NDArray, octave_int64, OCTAVE_API)
 
 SND_CMP_OP_DECLS (octave_int64, int64NDArray, OCTAVE_API)
diff --git a/liboctave/int8NDArray.cc b/liboctave/int8NDArray.cc
--- a/liboctave/int8NDArray.cc
+++ b/liboctave/int8NDArray.cc
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "int8NDArray.h"
-
+#include "mx-op-defs.h"
 #include "intNDArray.cc"
 
 template class OCTAVE_API intNDArray<octave_int8>;
 
 template OCTAVE_API
 std::ostream&
 operator << (std::ostream& os, const intNDArray<octave_int8>& a);
 
diff --git a/liboctave/int8NDArray.h b/liboctave/int8NDArray.h
--- a/liboctave/int8NDArray.h
+++ b/liboctave/int8NDArray.h
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_int8NDArray_h)
 #define octave_int8NDArray_h 1
 
 #include "intNDArray.h"
-#include "mx-op-defs.h"
+#include "mx-op-decl.h"
 #include "oct-inttypes.h"
 
 typedef intNDArray<octave_int8> int8NDArray;
 
 NDS_CMP_OP_DECLS (int8NDArray, octave_int8, OCTAVE_API)
 NDS_BOOL_OP_DECLS (int8NDArray, octave_int8, OCTAVE_API)
 
 SND_CMP_OP_DECLS (octave_int8, int8NDArray, OCTAVE_API)
diff --git a/liboctave/mk-ops.awk b/liboctave/mk-ops.awk
--- a/liboctave/mk-ops.awk
+++ b/liboctave/mk-ops.awk
@@ -157,17 +157,17 @@ BEGIN {
           if (rhs_header && ! (rhs_header == lhs_header || rhs_header == result_header))
 	    {
 	      if (result_fwd_decl_ok)
 	        printf ("class %s\n", rhs_type) >> h_file;
 	      else
 	        printf ("#include \"%s\"\n", rhs_header) >> h_file;
 	    }
 
-          printf ("#include \"mx-op-defs.h\"\n") >> h_file;
+          printf ("#include \"mx-op-decl.h\"\n") >> h_file;
 
           if (bin_ops)
             printf ("%s%s_BIN_OP_DECLS (%s, %s, %s, OCTAVE_API)\n", lhs_class,
 		    rhs_class, result_type, lhs_type, rhs_type) >> h_file
 
           if (cmp_ops)
             printf ("%s%s_CMP_OP_DECLS (%s, %s, OCTAVE_API)\n", lhs_class,
 		    rhs_class, lhs_type, rhs_type) >> h_file
@@ -187,16 +187,18 @@ BEGIN {
 	  print "#ifdef HAVE_CONFIG_H" >> cc_file;
 	  print "#include <config.h>" >> cc_file;
 	  print "#endif" >> cc_file;
 
 	  print "#include \"Array-util.h\"" >> cc_file;
 
 	  printf ("#include \"%s\"\n", h_file) >> cc_file;
 
+          printf ("#include \"mx-op-defs.h\"\n") >> cc_file;
+
 	  for (i in bool_headers)
 	    {
 	      printf ("#include \"%s\"\n", bool_headers[i]) >> cc_file;
 	      delete bool_headers[i];
 	    }
 
           if (result_header)
 	    printf ("#include \"%s\"\n", result_header) >> cc_file;
diff --git a/liboctave/mx-op-decl.h b/liboctave/mx-op-decl.h
new file mode 100644
--- /dev/null
+++ b/liboctave/mx-op-decl.h
@@ -0,0 +1,300 @@
+/*
+
+Copyright (C) 1996, 1997, 1998, 2000, 2001, 2003, 2004, 2005, 2006,
+              2007 John W. Eaton
+Copyright (C) 2008, 2009 Jaroslav Hajek
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#if !defined (octave_mx_op_decl_h)
+#define octave_mx_op_decl_h 1
+
+#include "oct-types.h"
+
+#define BIN_OP_DECL(R, OP, X, Y, API) \
+  extern API R OP (const X&, const Y&)
+
+class boolMatrix;
+class boolNDArray;
+
+#define CMP_OP_DECL(OP, X, Y, API) \
+  extern API boolMatrix OP (const X&, const Y&)
+
+#define NDCMP_OP_DECL(OP, X, Y, API) \
+  extern API boolNDArray OP (const X&, const Y&)
+
+#define BOOL_OP_DECL(OP, X, Y, API) \
+  extern API boolMatrix OP (const X&, const Y&)
+
+#define NDBOOL_OP_DECL(OP, X, Y, API) \
+  extern API boolNDArray OP (const X&, const Y&)
+
+// vector by scalar operations.
+
+#define VS_BIN_OP_DECLS(R, V, S, API) \
+  BIN_OP_DECL (R, operator +, V, S, API); \
+  BIN_OP_DECL (R, operator -, V, S, API); \
+  BIN_OP_DECL (R, operator *, V, S, API); \
+  BIN_OP_DECL (R, operator /, V, S, API);
+
+#define VS_OP_DECLS(R, V, S, API) \
+  VS_BIN_OP_DECLS(R, V, S, API)
+
+// scalar by vector by operations.
+
+#define SV_BIN_OP_DECLS(R, S, V, API) \
+  BIN_OP_DECL (R, operator +, S, V, API); \
+  BIN_OP_DECL (R, operator -, S, V, API); \
+  BIN_OP_DECL (R, operator *, S, V, API); \
+  BIN_OP_DECL (R, operator /, S, V, API);
+
+#define SV_OP_DECLS(R, S, V, API) \
+  SV_BIN_OP_DECLS(R, S, V, API)
+
+// vector by vector operations.
+
+#define VV_BIN_OP_DECLS(R, V1, V2, API) \
+  BIN_OP_DECL (R, operator +, V1, V2, API); \
+  BIN_OP_DECL (R, operator -, V1, V2, API); \
+  BIN_OP_DECL (R, product,    V1, V2, API); \
+  BIN_OP_DECL (R, quotient,   V1, V2, API);
+
+#define VV_OP_DECLS(R, V1, V2, API) \
+  VV_BIN_OP_DECLS(R, V1, V2, API)
+
+// matrix by scalar operations.
+
+#define MS_BIN_OP_DECLS(R, M, S, API) \
+  BIN_OP_DECL (R, operator +, M, S, API); \
+  BIN_OP_DECL (R, operator -, M, S, API); \
+  BIN_OP_DECL (R, operator *, M, S, API); \
+  BIN_OP_DECL (R, operator /, M, S, API);
+
+#define MS_CMP_OP_DECLS(M, S, API) \
+  CMP_OP_DECL (mx_el_lt, M, S, API); \
+  CMP_OP_DECL (mx_el_le, M, S, API); \
+  CMP_OP_DECL (mx_el_ge, M, S, API); \
+  CMP_OP_DECL (mx_el_gt, M, S, API); \
+  CMP_OP_DECL (mx_el_eq, M, S, API); \
+  CMP_OP_DECL (mx_el_ne, M, S, API);
+
+#define MS_BOOL_OP_DECLS(M, S, API) \
+  BOOL_OP_DECL (mx_el_and, M, S, API); \
+  BOOL_OP_DECL (mx_el_or,  M, S, API); \
+
+#define MS_OP_DECLS(R, M, S, API) \
+  MS_BIN_OP_DECLS (R, M, S, API) \
+  MS_CMP_OP_DECLS (M, S, API) \
+  MS_BOOL_OP_DECLS (M, S, API) \
+
+// scalar by matrix operations.
+
+#define SM_BIN_OP_DECLS(R, S, M, API) \
+  BIN_OP_DECL (R, operator +, S, M, API); \
+  BIN_OP_DECL (R, operator -, S, M, API); \
+  BIN_OP_DECL (R, operator *, S, M, API); \
+  BIN_OP_DECL (R, operator /, S, M, API);
+
+#define SM_CMP_OP_DECLS(S, M, API) \
+  CMP_OP_DECL (mx_el_lt, S, M, API); \
+  CMP_OP_DECL (mx_el_le, S, M, API); \
+  CMP_OP_DECL (mx_el_ge, S, M, API); \
+  CMP_OP_DECL (mx_el_gt, S, M, API); \
+  CMP_OP_DECL (mx_el_eq, S, M, API); \
+  CMP_OP_DECL (mx_el_ne, S, M, API);
+
+#define SM_BOOL_OP_DECLS(S, M, API) \
+  BOOL_OP_DECL (mx_el_and, S, M, API); \
+  BOOL_OP_DECL (mx_el_or,  S, M, API); \
+
+#define SM_OP_DECLS(R, S, M, API) \
+  SM_BIN_OP_DECLS (R, S, M, API) \
+  SM_CMP_OP_DECLS (S, M, API) \
+  SM_BOOL_OP_DECLS (S, M, API) \
+
+// matrix by matrix operations.
+
+#define MM_BIN_OP_DECLS(R, M1, M2, API) \
+  BIN_OP_DECL (R, operator +, M1, M2, API); \
+  BIN_OP_DECL (R, operator -, M1, M2, API); \
+  BIN_OP_DECL (R, product,    M1, M2, API); \
+  BIN_OP_DECL (R, quotient,   M1, M2, API);
+
+#define MM_CMP_OP_DECLS(M1, M2, API) \
+  CMP_OP_DECL (mx_el_lt, M1, M2, API); \
+  CMP_OP_DECL (mx_el_le, M1, M2, API); \
+  CMP_OP_DECL (mx_el_ge, M1, M2, API); \
+  CMP_OP_DECL (mx_el_gt, M1, M2, API); \
+  CMP_OP_DECL (mx_el_eq, M1, M2, API); \
+  CMP_OP_DECL (mx_el_ne, M1, M2, API);
+
+#define MM_BOOL_OP_DECLS(M1, M2, API) \
+  BOOL_OP_DECL (mx_el_and, M1, M2, API); \
+  BOOL_OP_DECL (mx_el_or,  M1, M2, API);
+
+#define MM_OP_DECLS(R, M1, M2, API) \
+  MM_BIN_OP_DECLS (R, M1, M2, API) \
+  MM_CMP_OP_DECLS (M1, M2, API) \
+  MM_BOOL_OP_DECLS (M1, M2, API)
+
+// N-d matrix by scalar operations.
+
+#define NDS_BIN_OP_DECLS(R, ND, S, API) \
+  BIN_OP_DECL (R, operator +, ND, S, API); \
+  BIN_OP_DECL (R, operator -, ND, S, API); \
+  BIN_OP_DECL (R, operator *, ND, S, API); \
+  BIN_OP_DECL (R, operator /, ND, S, API);
+
+#define NDS_CMP_OP_DECLS(ND, S, API) \
+  NDCMP_OP_DECL (mx_el_lt, ND, S, API); \
+  NDCMP_OP_DECL (mx_el_le, ND, S, API); \
+  NDCMP_OP_DECL (mx_el_ge, ND, S, API); \
+  NDCMP_OP_DECL (mx_el_gt, ND, S, API); \
+  NDCMP_OP_DECL (mx_el_eq, ND, S, API); \
+  NDCMP_OP_DECL (mx_el_ne, ND, S, API);
+
+#define NDS_BOOL_OP_DECLS(ND, S, API) \
+  NDBOOL_OP_DECL (mx_el_and, ND, S, API); \
+  NDBOOL_OP_DECL (mx_el_or,  ND, S, API);
+
+#define NDS_OP_DECLS(R, ND, S, API) \
+  NDS_BIN_OP_DECLS (R, ND, S, API) \
+  NDS_CMP_OP_DECLS (ND, S, API) \
+  NDS_BOOL_OP_DECLS (ND, S, API)
+
+// scalar by N-d matrix operations.
+
+#define SND_BIN_OP_DECLS(R, S, ND, API) \
+  BIN_OP_DECL (R, operator +, S, ND, API); \
+  BIN_OP_DECL (R, operator -, S, ND, API); \
+  BIN_OP_DECL (R, operator *, S, ND, API); \
+  BIN_OP_DECL (R, operator /, S, ND, API);
+
+#define SND_CMP_OP_DECLS(S, ND, API) \
+  NDCMP_OP_DECL (mx_el_lt, S, ND, API); \
+  NDCMP_OP_DECL (mx_el_le, S, ND, API); \
+  NDCMP_OP_DECL (mx_el_ge, S, ND, API); \
+  NDCMP_OP_DECL (mx_el_gt, S, ND, API); \
+  NDCMP_OP_DECL (mx_el_eq, S, ND, API); \
+  NDCMP_OP_DECL (mx_el_ne, S, ND, API);
+
+#define SND_BOOL_OP_DECLS(S, ND, API) \
+  NDBOOL_OP_DECL (mx_el_and, S, ND, API); \
+  NDBOOL_OP_DECL (mx_el_or,  S, ND, API);
+
+#define SND_OP_DECLS(R, S, ND, API) \
+  SND_BIN_OP_DECLS (R, S, ND, API) \
+  SND_CMP_OP_DECLS (S, ND, API) \
+  SND_BOOL_OP_DECLS (S, ND, API)
+
+// N-d matrix by N-d matrix operations.
+
+#define NDND_BIN_OP_DECLS(R, ND1, ND2, API) \
+  BIN_OP_DECL (R, operator +, ND1, ND2, API); \
+  BIN_OP_DECL (R, operator -, ND1, ND2, API); \
+  BIN_OP_DECL (R, product,    ND1, ND2, API); \
+  BIN_OP_DECL (R, quotient,   ND1, ND2, API);
+
+#define NDND_CMP_OP_DECLS(ND1, ND2, API) \
+  NDCMP_OP_DECL (mx_el_lt, ND1, ND2, API); \
+  NDCMP_OP_DECL (mx_el_le, ND1, ND2, API); \
+  NDCMP_OP_DECL (mx_el_ge, ND1, ND2, API); \
+  NDCMP_OP_DECL (mx_el_gt, ND1, ND2, API); \
+  NDCMP_OP_DECL (mx_el_eq, ND1, ND2, API); \
+  NDCMP_OP_DECL (mx_el_ne, ND1, ND2, API);
+
+#define NDND_BOOL_OP_DECLS(ND1, ND2, API) \
+  NDBOOL_OP_DECL (mx_el_and, ND1, ND2, API); \
+  NDBOOL_OP_DECL (mx_el_or,  ND1, ND2, API);
+
+#define NDND_OP_DECLS(R, ND1, ND2, API) \
+  NDND_BIN_OP_DECLS (R, ND1, ND2, API) \
+  NDND_CMP_OP_DECLS (ND1, ND2, API) \
+  NDND_BOOL_OP_DECLS (ND1, ND2, API)
+
+// scalar by diagonal matrix operations.
+
+#define SDM_BIN_OP_DECLS(R, S, DM, API) \
+  BIN_OP_DECL (R, operator +, S, DM, API); \
+  BIN_OP_DECL (R, operator -, S, DM, API);
+
+#define SDM_OP_DECLS(R, S, DM, API) \
+  SDM_BIN_OP_DECLS(R, S, DM, API)
+
+// diagonal matrix by scalar operations.
+
+#define DMS_BIN_OP_DECLS(R, DM, S, API) \
+  BIN_OP_DECL (R, operator +, DM, S, API); \
+  BIN_OP_DECL (R, operator -, DM, S, API);
+
+#define DMS_OP_DECLS(R, DM, S, API) \
+  DMS_BIN_OP_DECLS(R, DM, S, API)
+
+// matrix by diagonal matrix operations.
+
+#define MDM_BIN_OP_DECLS(R, M, DM, API) \
+  BIN_OP_DECL (R, operator +, M, DM, API); \
+  BIN_OP_DECL (R, operator -, M, DM, API); \
+  BIN_OP_DECL (R, operator *, M, DM, API);
+
+#define MDM_OP_DECLS(R, M, DM, API) \
+  MDM_BIN_OP_DECLS(R, M, DM, API)
+
+// diagonal matrix by matrix operations.
+
+#define DMM_BIN_OP_DECLS(R, DM, M, API) \
+  BIN_OP_DECL (R, operator +, DM, M, API); \
+  BIN_OP_DECL (R, operator -, DM, M, API); \
+  BIN_OP_DECL (R, operator *, DM, M, API);
+
+#define DMM_OP_DECLS(R, DM, M, API) \
+  DMM_BIN_OP_DECLS(R, DM, M, API)
+
+// diagonal matrix by diagonal matrix operations.
+
+#define DMDM_BIN_OP_DECLS(R, DM1, DM2, API) \
+  BIN_OP_DECL (R, operator +, DM1, DM2, API); \
+  BIN_OP_DECL (R, operator -, DM1, DM2, API); \
+  BIN_OP_DECL (R, product, DM1, DM2, API);
+
+#define DMDM_OP_DECLS(R, DM1, DM2, API) \
+  DMDM_BIN_OP_DECLS (R, DM1, DM2, API)
+
+// scalar by N-d array min/max ops
+
+#define MINMAX_DECLS(T) \
+  extern OCTAVE_API T ## NDArray min (octave_ ## T d, const T ## NDArray& m); \
+  extern OCTAVE_API T ## NDArray min (const T ## NDArray& m, octave_ ## T d); \
+  extern OCTAVE_API T ## NDArray min (const T ## NDArray& a,  \
+				       const T ## NDArray& b); \
+  extern OCTAVE_API T ## NDArray max (octave_ ## T d, const T ## NDArray& m); \
+  extern OCTAVE_API T ## NDArray max (const T ## NDArray& m, octave_ ## T d); \
+  extern OCTAVE_API T ## NDArray max (const T ## NDArray& a, \
+				       const T ## NDArray& b);
+
+// permutation matrix by matrix ops and vice versa
+
+#define PMM_BIN_OP_DECLS(R, PM, M, API) \
+  BIN_OP_DECL (R, operator *, PM, M, API);
+
+#define MPM_BIN_OP_DECLS(R, M, PM, API) \
+  BIN_OP_DECL (R, operator *, M, PM, API);
+
+#endif
+
diff --git a/liboctave/mx-op-defs.h b/liboctave/mx-op-defs.h
--- a/liboctave/mx-op-defs.h
+++ b/liboctave/mx-op-defs.h
@@ -20,45 +20,21 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_mx_op_defs_h)
 #define octave_mx_op_defs_h 1
 
-#include "oct-types.h"
+#include "mx-op-decl.h"
 #include "mx-inlines.cc"
 
-#define BIN_OP_DECL(R, OP, X, Y, API) \
-  extern API R OP (const X&, const Y&)
-
-class boolMatrix;
-class boolNDArray;
-
-#define CMP_OP_DECL(OP, X, Y, API) \
-  extern API boolMatrix OP (const X&, const Y&)
-
-#define NDCMP_OP_DECL(OP, X, Y, API) \
-  extern API boolNDArray OP (const X&, const Y&)
-
-#define BOOL_OP_DECL(OP, X, Y, API) \
-  extern API boolMatrix OP (const X&, const Y&)
-
-#define NDBOOL_OP_DECL(OP, X, Y, API) \
-  extern API boolNDArray OP (const X&, const Y&)
-
 // vector by scalar operations.
 
-#define VS_BIN_OP_DECLS(R, V, S, API) \
-  BIN_OP_DECL (R, operator +, V, S, API); \
-  BIN_OP_DECL (R, operator -, V, S, API); \
-  BIN_OP_DECL (R, operator *, V, S, API); \
-  BIN_OP_DECL (R, operator /, V, S, API);
-
 #define VS_BIN_OP(R, F, OP, V, S) \
   R \
   F (const V& v, const S& s) \
   { \
     octave_idx_type len = v.length (); \
  \
     R r (len); \
  \
@@ -69,27 +45,18 @@ class boolNDArray;
   }
 
 #define VS_BIN_OPS(R, V, S) \
   VS_BIN_OP (R, operator +, +, V, S) \
   VS_BIN_OP (R, operator -, -, V, S) \
   VS_BIN_OP (R, operator *, *, V, S) \
   VS_BIN_OP (R, operator /, /, V, S)
 
-#define VS_OP_DECLS(R, V, S, API) \
-  VS_BIN_OP_DECLS(R, V, S, API)
-
 // scalar by vector by operations.
 
-#define SV_BIN_OP_DECLS(R, S, V, API) \
-  BIN_OP_DECL (R, operator +, S, V, API); \
-  BIN_OP_DECL (R, operator -, S, V, API); \
-  BIN_OP_DECL (R, operator *, S, V, API); \
-  BIN_OP_DECL (R, operator /, S, V, API);
-
 #define SV_BIN_OP(R, F, OP, S, V) \
   R \
   F (const S& s, const V& v) \
   { \
     octave_idx_type len = v.length (); \
  \
     R r (len); \
  \
@@ -100,27 +67,18 @@ class boolNDArray;
   }
 
 #define SV_BIN_OPS(R, S, V) \
   SV_BIN_OP (R, operator +, +, S, V) \
   SV_BIN_OP (R, operator -, -, S, V) \
   SV_BIN_OP (R, operator *, *, S, V) \
   SV_BIN_OP (R, operator /, /, S, V)
 
-#define SV_OP_DECLS(R, S, V, API) \
-  SV_BIN_OP_DECLS(R, S, V, API)
-
 // vector by vector operations.
 
-#define VV_BIN_OP_DECLS(R, V1, V2, API) \
-  BIN_OP_DECL (R, operator +, V1, V2, API); \
-  BIN_OP_DECL (R, operator -, V1, V2, API); \
-  BIN_OP_DECL (R, product,    V1, V2, API); \
-  BIN_OP_DECL (R, quotient,   V1, V2, API);
-
 #define VV_BIN_OP(R, F, OP, V1, V2) \
   R \
   F (const V1& v1, const V2& v2) \
   { \
     R r; \
  \
     octave_idx_type v1_len = v1.length (); \
     octave_idx_type v2_len = v2.length (); \
@@ -139,27 +97,18 @@ class boolNDArray;
   }
 
 #define VV_BIN_OPS(R, V1, V2) \
   VV_BIN_OP (R, operator +, +, V1, V2) \
   VV_BIN_OP (R, operator -, -, V1, V2) \
   VV_BIN_OP (R, product,    *, V1, V2) \
   VV_BIN_OP (R, quotient,   /, V1, V2)
 
-#define VV_OP_DECLS(R, V1, V2, API) \
-  VV_BIN_OP_DECLS(R, V1, V2, API)
-
 // matrix by scalar operations.
 
-#define MS_BIN_OP_DECLS(R, M, S, API) \
-  BIN_OP_DECL (R, operator +, M, S, API); \
-  BIN_OP_DECL (R, operator -, M, S, API); \
-  BIN_OP_DECL (R, operator *, M, S, API); \
-  BIN_OP_DECL (R, operator /, M, S, API);
-
 #define MS_BIN_OP(R, OP, M, S, F) \
   R \
   OP (const M& m, const S& s) \
   { \
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
  \
     R r (nr, nc); \
@@ -171,24 +120,16 @@ class boolNDArray;
   }
 
 #define MS_BIN_OPS(R, M, S) \
   MS_BIN_OP (R, operator +, M, S, mx_inline_add) \
   MS_BIN_OP (R, operator -, M, S, mx_inline_subtract) \
   MS_BIN_OP (R, operator *, M, S, mx_inline_multiply) \
   MS_BIN_OP (R, operator /, M, S, mx_inline_divide)
 
-#define MS_CMP_OP_DECLS(M, S, API) \
-  CMP_OP_DECL (mx_el_lt, M, S, API); \
-  CMP_OP_DECL (mx_el_le, M, S, API); \
-  CMP_OP_DECL (mx_el_ge, M, S, API); \
-  CMP_OP_DECL (mx_el_gt, M, S, API); \
-  CMP_OP_DECL (mx_el_eq, M, S, API); \
-  CMP_OP_DECL (mx_el_ne, M, S, API);
-
 #define MS_CMP_OP(F, OP, M, MC, S, SC) \
   boolMatrix \
   F (const M& m, const S& s) \
   { \
     boolMatrix r; \
  \
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
@@ -208,20 +149,16 @@ class boolNDArray;
 #define MS_CMP_OPS(M, CM, S, CS) \
   MS_CMP_OP (mx_el_lt, <,  M, CM, S, CS) \
   MS_CMP_OP (mx_el_le, <=, M, CM, S, CS) \
   MS_CMP_OP (mx_el_ge, >=, M, CM, S, CS) \
   MS_CMP_OP (mx_el_gt, >,  M, CM, S, CS) \
   MS_CMP_OP (mx_el_eq, ==, M,   , S,   ) \
   MS_CMP_OP (mx_el_ne, !=, M,   , S,   )
 
-#define MS_BOOL_OP_DECLS(M, S, API) \
-  BOOL_OP_DECL (mx_el_and, M, S, API); \
-  BOOL_OP_DECL (mx_el_or,  M, S, API); \
-
 #define MS_BOOL_OP(F, OP, M, S, LHS_ZERO, RHS_ZERO) \
   boolMatrix \
   F (const M& m, const S& s) \
   { \
     boolMatrix r; \
  \
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
@@ -252,29 +189,18 @@ class boolNDArray;
 
 #define MS_BOOL_OPS2(M, S, LHS_ZERO, RHS_ZERO) \
   MS_BOOL_OP (mx_el_and, &&, M, S, LHS_ZERO, RHS_ZERO) \
   MS_BOOL_OP (mx_el_or,  ||, M, S, LHS_ZERO, RHS_ZERO)
 
 #define MS_BOOL_OPS(M, S, ZERO) \
   MS_BOOL_OPS2(M, S, ZERO, ZERO)
 
-#define MS_OP_DECLS(R, M, S, API) \
-  MS_BIN_OP_DECLS (R, M, S, API) \
-  MS_CMP_OP_DECLS (M, S, API) \
-  MS_BOOL_OP_DECLS (M, S, API) \
-
 // scalar by matrix operations.
 
-#define SM_BIN_OP_DECLS(R, S, M, API) \
-  BIN_OP_DECL (R, operator +, S, M, API); \
-  BIN_OP_DECL (R, operator -, S, M, API); \
-  BIN_OP_DECL (R, operator *, S, M, API); \
-  BIN_OP_DECL (R, operator /, S, M, API);
-
 #define SM_BIN_OP(R, OP, S, M, F) \
   R \
   OP (const S& s, const M& m) \
   { \
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
  \
     R r (nr, nc); \
@@ -286,24 +212,16 @@ class boolNDArray;
   }
 
 #define SM_BIN_OPS(R, S, M) \
   SM_BIN_OP (R, operator +, S, M, mx_inline_add) \
   SM_BIN_OP (R, operator -, S, M, mx_inline_subtract) \
   SM_BIN_OP (R, operator *, S, M, mx_inline_multiply) \
   SM_BIN_OP (R, operator /, S, M, mx_inline_divide)
 
-#define SM_CMP_OP_DECLS(S, M, API) \
-  CMP_OP_DECL (mx_el_lt, S, M, API); \
-  CMP_OP_DECL (mx_el_le, S, M, API); \
-  CMP_OP_DECL (mx_el_ge, S, M, API); \
-  CMP_OP_DECL (mx_el_gt, S, M, API); \
-  CMP_OP_DECL (mx_el_eq, S, M, API); \
-  CMP_OP_DECL (mx_el_ne, S, M, API);
-
 #define SM_CMP_OP(F, OP, S, SC, M, MC) \
   boolMatrix \
   F (const S& s, const M& m) \
   { \
     boolMatrix r; \
  \
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
@@ -323,20 +241,16 @@ class boolNDArray;
 #define SM_CMP_OPS(S, CS, M, CM) \
   SM_CMP_OP (mx_el_lt, <,  S, CS, M, CM) \
   SM_CMP_OP (mx_el_le, <=, S, CS, M, CM) \
   SM_CMP_OP (mx_el_ge, >=, S, CS, M, CM) \
   SM_CMP_OP (mx_el_gt, >,  S, CS, M, CM) \
   SM_CMP_OP (mx_el_eq, ==, S,   , M,   ) \
   SM_CMP_OP (mx_el_ne, !=, S,   , M,   )
 
-#define SM_BOOL_OP_DECLS(S, M, API) \
-  BOOL_OP_DECL (mx_el_and, S, M, API); \
-  BOOL_OP_DECL (mx_el_or,  S, M, API); \
-
 #define SM_BOOL_OP(F, OP, S, M, LHS_ZERO, RHS_ZERO) \
   boolMatrix \
   F (const S& s, const M& m) \
   { \
     boolMatrix r; \
  \
     octave_idx_type nr = m.rows (); \
     octave_idx_type nc = m.cols (); \
@@ -366,29 +280,18 @@ class boolNDArray;
 
 #define SM_BOOL_OPS2(S, M, LHS_ZERO, RHS_ZERO) \
   SM_BOOL_OP (mx_el_and, &&, S, M, LHS_ZERO, RHS_ZERO) \
   SM_BOOL_OP (mx_el_or,  ||, S, M, LHS_ZERO, RHS_ZERO)
 
 #define SM_BOOL_OPS(S, M, ZERO) \
   SM_BOOL_OPS2(S, M, ZERO, ZERO)
 
-#define SM_OP_DECLS(R, S, M, API) \
-  SM_BIN_OP_DECLS (R, S, M, API) \
-  SM_CMP_OP_DECLS (S, M, API) \
-  SM_BOOL_OP_DECLS (S, M, API) \
-
 // matrix by matrix operations.
 
-#define MM_BIN_OP_DECLS(R, M1, M2, API) \
-  BIN_OP_DECL (R, operator +, M1, M2, API); \
-  BIN_OP_DECL (R, operator -, M1, M2, API); \
-  BIN_OP_DECL (R, product,    M1, M2, API); \
-  BIN_OP_DECL (R, quotient,   M1, M2, API);
-
 #define MM_BIN_OP(R, OP, M1, M2, F) \
   R \
   OP (const M1& m1, const M2& m2) \
   { \
     R r; \
  \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
@@ -410,24 +313,16 @@ class boolNDArray;
   }
 
 #define MM_BIN_OPS(R, M1, M2) \
   MM_BIN_OP (R, operator +, M1, M2, mx_inline_add) \
   MM_BIN_OP (R, operator -, M1, M2, mx_inline_subtract) \
   MM_BIN_OP (R, product,    M1, M2, mx_inline_multiply) \
   MM_BIN_OP (R, quotient,   M1, M2, mx_inline_divide)
 
-#define MM_CMP_OP_DECLS(M1, M2, API) \
-  CMP_OP_DECL (mx_el_lt, M1, M2, API); \
-  CMP_OP_DECL (mx_el_le, M1, M2, API); \
-  CMP_OP_DECL (mx_el_ge, M1, M2, API); \
-  CMP_OP_DECL (mx_el_gt, M1, M2, API); \
-  CMP_OP_DECL (mx_el_eq, M1, M2, API); \
-  CMP_OP_DECL (mx_el_ne, M1, M2, API);
-
 #define MM_CMP_OP(F, OP, M1, C1, M2, C2) \
   boolMatrix \
   F (const M1& m1, const M2& m2) \
   { \
     boolMatrix r; \
  \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
@@ -452,20 +347,16 @@ class boolNDArray;
 #define MM_CMP_OPS(M1, C1, M2, C2) \
   MM_CMP_OP (mx_el_lt, <,  M1, C1, M2, C2) \
   MM_CMP_OP (mx_el_le, <=, M1, C1, M2, C2) \
   MM_CMP_OP (mx_el_ge, >=, M1, C1, M2, C2) \
   MM_CMP_OP (mx_el_gt, >,  M1, C1, M2, C2) \
   MM_CMP_OP (mx_el_eq, ==, M1,   , M2,   ) \
   MM_CMP_OP (mx_el_ne, !=, M1,   , M2,   )
 
-#define MM_BOOL_OP_DECLS(M1, M2, API) \
-  BOOL_OP_DECL (mx_el_and, M1, M2, API); \
-  BOOL_OP_DECL (mx_el_or,  M1, M2, API);
-
 #define MM_BOOL_OP(F, OP, M1, M2, LHS_ZERO, RHS_ZERO) \
   boolMatrix \
   F (const M1& m1, const M2& m2) \
   { \
     boolMatrix r; \
  \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
@@ -502,29 +393,18 @@ class boolNDArray;
 
 #define MM_BOOL_OPS2(M1, M2, LHS_ZERO, RHS_ZERO) \
   MM_BOOL_OP (mx_el_and, &&, M1, M2, LHS_ZERO, RHS_ZERO) \
   MM_BOOL_OP (mx_el_or,  ||, M1, M2, LHS_ZERO, RHS_ZERO)
 
 #define MM_BOOL_OPS(M1, M2, ZERO) \
   MM_BOOL_OPS2(M1, M2, ZERO, ZERO)
 
-#define MM_OP_DECLS(R, M1, M2, API) \
-  MM_BIN_OP_DECLS (R, M1, M2, API) \
-  MM_CMP_OP_DECLS (M1, M2, API) \
-  MM_BOOL_OP_DECLS (M1, M2, API)
-
 // N-d matrix by scalar operations.
 
-#define NDS_BIN_OP_DECLS(R, ND, S, API) \
-  BIN_OP_DECL (R, operator +, ND, S, API); \
-  BIN_OP_DECL (R, operator -, ND, S, API); \
-  BIN_OP_DECL (R, operator *, ND, S, API); \
-  BIN_OP_DECL (R, operator /, ND, S, API);
-
 #define NDS_BIN_OP(R, OP, ND, S, F) \
   R \
   OP (const ND& m, const S& s) \
   { \
     R r (m.dims ()); \
  \
     octave_idx_type len = m.length (); \
  \
@@ -535,24 +415,16 @@ class boolNDArray;
   }
 
 #define NDS_BIN_OPS(R, ND, S) \
   NDS_BIN_OP (R, operator +, ND, S, mx_inline_add) \
   NDS_BIN_OP (R, operator -, ND, S, mx_inline_subtract) \
   NDS_BIN_OP (R, operator *, ND, S, mx_inline_multiply) \
   NDS_BIN_OP (R, operator /, ND, S, mx_inline_divide)
 
-#define NDS_CMP_OP_DECLS(ND, S, API) \
-  NDCMP_OP_DECL (mx_el_lt, ND, S, API); \
-  NDCMP_OP_DECL (mx_el_le, ND, S, API); \
-  NDCMP_OP_DECL (mx_el_ge, ND, S, API); \
-  NDCMP_OP_DECL (mx_el_gt, ND, S, API); \
-  NDCMP_OP_DECL (mx_el_eq, ND, S, API); \
-  NDCMP_OP_DECL (mx_el_ne, ND, S, API);
-
 #define NDS_CMP_OP(F, OP, ND, NDC, S, SC) \
   boolNDArray \
   F (const ND& m, const S& s) \
   { \
     boolNDArray r; \
  \
     octave_idx_type len = m.length (); \
  \
@@ -615,20 +487,16 @@ class boolNDArray;
 #define NDS_CMP_OPS2(ND, NDC, S, SC, SPEC1, SPEC2) \
   NDS_CMP_OP2 (mx_el_lt, <,  ND, NDC, S, SC, SPEC1, SPEC2) \
   NDS_CMP_OP2 (mx_el_le, <=, ND, NDC, S, SC, SPEC1, SPEC2) \
   NDS_CMP_OP2 (mx_el_ge, >=, ND, NDC, S, SC, SPEC1, SPEC2) \
   NDS_CMP_OP2 (mx_el_gt, >,  ND, NDC, S, SC, SPEC1, SPEC2) \
   NDS_CMP_OP2 (mx_el_eq, ==, ND,    , S,   , SPEC1, SPEC2) \
   NDS_CMP_OP2 (mx_el_ne, !=, ND,    , S,   , SPEC1, SPEC2)
 
-#define NDS_BOOL_OP_DECLS(ND, S, API) \
-  NDBOOL_OP_DECL (mx_el_and, ND, S, API); \
-  NDBOOL_OP_DECL (mx_el_or,  ND, S, API);
-
 #define NDS_BOOL_OP(F, OP, ND, S, LHS_ZERO, RHS_ZERO) \
   boolNDArray \
   F (const ND& m, const S& s) \
   { \
     boolNDArray r; \
  \
     octave_idx_type len = m.length (); \
  \
@@ -656,29 +524,18 @@ class boolNDArray;
 
 #define NDS_BOOL_OPS2(ND, S, LHS_ZERO, RHS_ZERO) \
   NDS_BOOL_OP (mx_el_and, &&, ND, S, LHS_ZERO, RHS_ZERO) \
   NDS_BOOL_OP (mx_el_or,  ||, ND, S, LHS_ZERO, RHS_ZERO)
 
 #define NDS_BOOL_OPS(ND, S, ZERO) \
   NDS_BOOL_OPS2(ND, S, ZERO, ZERO)
 
-#define NDS_OP_DECLS(R, ND, S, API) \
-  NDS_BIN_OP_DECLS (R, ND, S, API) \
-  NDS_CMP_OP_DECLS (ND, S, API) \
-  NDS_BOOL_OP_DECLS (ND, S, API)
-
 // scalar by N-d matrix operations.
 
-#define SND_BIN_OP_DECLS(R, S, ND, API) \
-  BIN_OP_DECL (R, operator +, S, ND, API); \
-  BIN_OP_DECL (R, operator -, S, ND, API); \
-  BIN_OP_DECL (R, operator *, S, ND, API); \
-  BIN_OP_DECL (R, operator /, S, ND, API);
-
 #define SND_BIN_OP(R, OP, S, ND, F) \
   R \
   OP (const S& s, const ND& m) \
   { \
     R r (m.dims ()); \
  \
     octave_idx_type len = m.length (); \
  \
@@ -689,24 +546,16 @@ class boolNDArray;
   }
 
 #define SND_BIN_OPS(R, S, ND) \
   SND_BIN_OP (R, operator +, S, ND, mx_inline_add) \
   SND_BIN_OP (R, operator -, S, ND, mx_inline_subtract) \
   SND_BIN_OP (R, operator *, S, ND, mx_inline_multiply) \
   SND_BIN_OP (R, operator /, S, ND, mx_inline_divide)
 
-#define SND_CMP_OP_DECLS(S, ND, API) \
-  NDCMP_OP_DECL (mx_el_lt, S, ND, API); \
-  NDCMP_OP_DECL (mx_el_le, S, ND, API); \
-  NDCMP_OP_DECL (mx_el_ge, S, ND, API); \
-  NDCMP_OP_DECL (mx_el_gt, S, ND, API); \
-  NDCMP_OP_DECL (mx_el_eq, S, ND, API); \
-  NDCMP_OP_DECL (mx_el_ne, S, ND, API);
-
 #define SND_CMP_OP(F, OP, S, SC, ND, NDC) \
   boolNDArray \
   F (const S& s, const ND& m) \
   { \
     boolNDArray r; \
  \
     octave_idx_type len = m.length (); \
  \
@@ -769,20 +618,16 @@ class boolNDArray;
 #define SND_CMP_OPS2(S, CS, ND, CND, SPEC1, SPEC2) \
   SND_CMP_OP2 (mx_el_lt, <,  S, CS, ND, CND, SPEC1, SPEC2) \
   SND_CMP_OP2 (mx_el_le, <=, S, CS, ND, CND, SPEC1, SPEC2) \
   SND_CMP_OP2 (mx_el_ge, >=, S, CS, ND, CND, SPEC1, SPEC2) \
   SND_CMP_OP2 (mx_el_gt, >,  S, CS, ND, CND, SPEC1, SPEC2) \
   SND_CMP_OP2 (mx_el_eq, ==, S,   , ND,    , SPEC1, SPEC2) \
   SND_CMP_OP2 (mx_el_ne, !=, S,   , ND,    , SPEC1, SPEC2)
 
-#define SND_BOOL_OP_DECLS(S, ND, API) \
-  NDBOOL_OP_DECL (mx_el_and, S, ND, API); \
-  NDBOOL_OP_DECL (mx_el_or,  S, ND, API);
-
 #define SND_BOOL_OP(F, OP, S, ND, LHS_ZERO, RHS_ZERO) \
   boolNDArray \
   F (const S& s, const ND& m) \
   { \
     boolNDArray r; \
  \
     octave_idx_type len = m.length (); \
  \
@@ -810,29 +655,18 @@ class boolNDArray;
 
 #define SND_BOOL_OPS2(S, ND, LHS_ZERO, RHS_ZERO) \
   SND_BOOL_OP (mx_el_and, &&, S, ND, LHS_ZERO, RHS_ZERO) \
   SND_BOOL_OP (mx_el_or,  ||, S, ND, LHS_ZERO, RHS_ZERO)
 
 #define SND_BOOL_OPS(S, ND, ZERO) \
   SND_BOOL_OPS2(S, ND, ZERO, ZERO)
 
-#define SND_OP_DECLS(R, S, ND, API) \
-  SND_BIN_OP_DECLS (R, S, ND, API) \
-  SND_CMP_OP_DECLS (S, ND, API) \
-  SND_BOOL_OP_DECLS (S, ND, API)
-
 // N-d matrix by N-d matrix operations.
 
-#define NDND_BIN_OP_DECLS(R, ND1, ND2, API) \
-  BIN_OP_DECL (R, operator +, ND1, ND2, API); \
-  BIN_OP_DECL (R, operator -, ND1, ND2, API); \
-  BIN_OP_DECL (R, product,    ND1, ND2, API); \
-  BIN_OP_DECL (R, quotient,   ND1, ND2, API);
-
 #define NDND_BIN_OP(R, OP, ND1, ND2, F) \
   R \
   OP (const ND1& m1, const ND2& m2) \
   { \
     R r; \
  \
     dim_vector m1_dims = m1.dims (); \
     dim_vector m2_dims = m2.dims (); \
@@ -853,24 +687,16 @@ class boolNDArray;
   }
 
 #define NDND_BIN_OPS(R, ND1, ND2) \
   NDND_BIN_OP (R, operator +, ND1, ND2, mx_inline_add) \
   NDND_BIN_OP (R, operator -, ND1, ND2, mx_inline_subtract) \
   NDND_BIN_OP (R, product,    ND1, ND2, mx_inline_multiply) \
   NDND_BIN_OP (R, quotient,   ND1, ND2, mx_inline_divide)
 
-#define NDND_CMP_OP_DECLS(ND1, ND2, API) \
-  NDCMP_OP_DECL (mx_el_lt, ND1, ND2, API); \
-  NDCMP_OP_DECL (mx_el_le, ND1, ND2, API); \
-  NDCMP_OP_DECL (mx_el_ge, ND1, ND2, API); \
-  NDCMP_OP_DECL (mx_el_gt, ND1, ND2, API); \
-  NDCMP_OP_DECL (mx_el_eq, ND1, ND2, API); \
-  NDCMP_OP_DECL (mx_el_ne, ND1, ND2, API);
-
 #define NDND_CMP_OP(F, OP, ND1, C1, ND2, C2) \
   boolNDArray \
   F (const ND1& m1, const ND2& m2) \
   { \
     boolNDArray r; \
  \
     dim_vector m1_dims = m1.dims (); \
     dim_vector m2_dims = m2.dims (); \
@@ -891,20 +717,16 @@ class boolNDArray;
 #define NDND_CMP_OPS(ND1, C1, ND2, C2) \
   NDND_CMP_OP (mx_el_lt, <,  ND1, C1, ND2, C2) \
   NDND_CMP_OP (mx_el_le, <=, ND1, C1, ND2, C2) \
   NDND_CMP_OP (mx_el_ge, >=, ND1, C1, ND2, C2) \
   NDND_CMP_OP (mx_el_gt, >,  ND1, C1, ND2, C2) \
   NDND_CMP_OP (mx_el_eq, ==, ND1,   , ND2,   ) \
   NDND_CMP_OP (mx_el_ne, !=, ND1,   , ND2,   )
 
-#define NDND_BOOL_OP_DECLS(ND1, ND2, API) \
-  NDBOOL_OP_DECL (mx_el_and, ND1, ND2, API); \
-  NDBOOL_OP_DECL (mx_el_or,  ND1, ND2, API);
-
 #define NDND_BOOL_OP(F, OP, ND1, ND2, LHS_ZERO, RHS_ZERO) \
   boolNDArray \
   F (const ND1& m1, const ND2& m2) \
   { \
     boolNDArray r; \
  \
     dim_vector m1_dims = m1.dims (); \
     dim_vector m2_dims = m2.dims (); \
@@ -933,27 +755,18 @@ class boolNDArray;
 
 #define NDND_BOOL_OPS2(ND1, ND2, LHS_ZERO, RHS_ZERO) \
   NDND_BOOL_OP (mx_el_and, &&, ND1, ND2, LHS_ZERO, RHS_ZERO) \
   NDND_BOOL_OP (mx_el_or,  ||, ND1, ND2, LHS_ZERO, RHS_ZERO)
 
 #define NDND_BOOL_OPS(ND1, ND2, ZERO) \
   NDND_BOOL_OPS2(ND1, ND2, ZERO, ZERO)
 
-#define NDND_OP_DECLS(R, ND1, ND2, API) \
-  NDND_BIN_OP_DECLS (R, ND1, ND2, API) \
-  NDND_CMP_OP_DECLS (ND1, ND2, API) \
-  NDND_BOOL_OP_DECLS (ND1, ND2, API)
-
 // scalar by diagonal matrix operations.
 
-#define SDM_BIN_OP_DECLS(R, S, DM, API) \
-  BIN_OP_DECL (R, operator +, S, DM, API); \
-  BIN_OP_DECL (R, operator -, S, DM, API);
-
 #define SDM_BIN_OP(R, OP, S, DM, OPEQ) \
   R \
   OP (const S& s, const DM& dm) \
   { \
     octave_idx_type nr = dm.rows (); \
     octave_idx_type nc = dm.cols (); \
  \
     R r (nr, nc, s); \
@@ -963,25 +776,18 @@ class boolNDArray;
  \
     return r; \
 }
 
 #define SDM_BIN_OPS(R, S, DM) \
   SDM_BIN_OP (R, operator +, S, DM, +=) \
   SDM_BIN_OP (R, operator -, S, DM, -=)
 
-#define SDM_OP_DECLS(R, S, DM, API) \
-  SDM_BIN_OP_DECLS(R, S, DM, API)
-
 // diagonal matrix by scalar operations.
 
-#define DMS_BIN_OP_DECLS(R, DM, S, API) \
-  BIN_OP_DECL (R, operator +, DM, S, API); \
-  BIN_OP_DECL (R, operator -, DM, S, API);
-
 #define DMS_BIN_OP(R, OP, DM, S, SGN) \
   R \
   OP (const DM& dm, const S& s) \
   { \
     octave_idx_type nr = dm.rows (); \
     octave_idx_type nc = dm.cols (); \
  \
     R r (nr, nc, SGN s); \
@@ -991,26 +797,18 @@ class boolNDArray;
  \
     return r; \
   }
 
 #define DMS_BIN_OPS(R, DM, S) \
   DMS_BIN_OP (R, operator +, DM, S, ) \
   DMS_BIN_OP (R, operator -, DM, S, -)
 
-#define DMS_OP_DECLS(R, DM, S, API) \
-  DMS_BIN_OP_DECLS(R, DM, S, API)
-
 // matrix by diagonal matrix operations.
 
-#define MDM_BIN_OP_DECLS(R, M, DM, API) \
-  BIN_OP_DECL (R, operator +, M, DM, API); \
-  BIN_OP_DECL (R, operator -, M, DM, API); \
-  BIN_OP_DECL (R, operator *, M, DM, API);
-
 #define MDM_BIN_OP(R, OP, M, DM, OPEQ) \
 R \
 OP (const M& m, const DM& dm) \
 { \
   R r; \
  \
   octave_idx_type m_nr = m.rows (); \
   octave_idx_type m_nc = m.cols (); \
@@ -1071,26 +869,18 @@ operator * (const M& m, const DM& dm) \
   return r; \
 }
 
 #define MDM_BIN_OPS(R, M, DM, R_ZERO) \
   MDM_BIN_OP (R, operator +, M, DM, +=) \
   MDM_BIN_OP (R, operator -, M, DM, -=) \
   MDM_MULTIPLY_OP (R, M, DM, R_ZERO)
 
-#define MDM_OP_DECLS(R, M, DM, API) \
-  MDM_BIN_OP_DECLS(R, M, DM, API)
-
 // diagonal matrix by matrix operations.
 
-#define DMM_BIN_OP_DECLS(R, DM, M, API) \
-  BIN_OP_DECL (R, operator +, DM, M, API); \
-  BIN_OP_DECL (R, operator -, DM, M, API); \
-  BIN_OP_DECL (R, operator *, DM, M, API);
-
 #define DMM_BIN_OP(R, OP, DM, M, OPEQ, PREOP) \
 R \
 OP (const DM& dm, const M& m) \
 { \
   R r; \
  \
   octave_idx_type dm_nr = dm.rows (); \
   octave_idx_type dm_nc = dm.cols (); \
@@ -1152,26 +942,18 @@ operator * (const DM& dm, const M& m) \
   return r; \
 }
 
 #define DMM_BIN_OPS(R, DM, M, R_ZERO) \
   DMM_BIN_OP (R, operator +, DM, M, +=, ) \
   DMM_BIN_OP (R, operator -, DM, M, +=, -) \
   DMM_MULTIPLY_OP (R, DM, M, R_ZERO)
 
-#define DMM_OP_DECLS(R, DM, M, API) \
-  DMM_BIN_OP_DECLS(R, DM, M, API)
-
 // diagonal matrix by diagonal matrix operations.
 
-#define DMDM_BIN_OP_DECLS(R, DM1, DM2, API) \
-  BIN_OP_DECL (R, operator +, DM1, DM2, API); \
-  BIN_OP_DECL (R, operator -, DM1, DM2, API); \
-  BIN_OP_DECL (R, product, DM1, DM2, API);
-
 #define DMDM_BIN_OP(R, OP, DM1, DM2, F) \
   R \
   OP (const DM1& dm1, const DM2& dm2) \
   { \
     R r; \
  \
     octave_idx_type dm1_nr = dm1.rows (); \
     octave_idx_type dm1_nc = dm1.cols (); \
@@ -1193,20 +975,17 @@ operator * (const DM& dm, const M& m) \
     return r; \
   }
 
 #define DMDM_BIN_OPS(R, DM1, DM2) \
   DMDM_BIN_OP (R, operator +, DM1, DM2, mx_inline_add) \
   DMDM_BIN_OP (R, operator -, DM1, DM2, mx_inline_subtract) \
   DMDM_BIN_OP (R, product,    DM1, DM2, mx_inline_multiply)
 
-#define DMDM_OP_DECLS(R, DM1, DM2, API) \
-  DMDM_BIN_OP_DECLS (R, DM1, DM2, API)
-
-#endif
+// scalar by N-d array min/max ops
 
 #define SND_MINMAX_FCN(FCN, OP, T) \
 T ## NDArray \
 FCN (octave_ ## T d, const T ## NDArray& m) \
 { \
   dim_vector dv = m.dims (); \
   octave_idx_type nel = dv.numel (); \
 \
@@ -1276,25 +1055,17 @@ FCN (const T ## NDArray& a, const T ## N
 #define MINMAX_FCNS(T) \
   SND_MINMAX_FCN (min, <, T) \
   NDS_MINMAX_FCN (min, <, T) \
   NDND_MINMAX_FCN (min, <, T) \
   SND_MINMAX_FCN (max, >, T) \
   NDS_MINMAX_FCN (max, >, T) \
   NDND_MINMAX_FCN (max, >, T)
 
-#define MINMAX_DECLS(T) \
-  extern OCTAVE_API T ## NDArray min (octave_ ## T d, const T ## NDArray& m); \
-  extern OCTAVE_API T ## NDArray min (const T ## NDArray& m, octave_ ## T d); \
-  extern OCTAVE_API T ## NDArray min (const T ## NDArray& a,  \
-				       const T ## NDArray& b); \
-  extern OCTAVE_API T ## NDArray max (octave_ ## T d, const T ## NDArray& m); \
-  extern OCTAVE_API T ## NDArray max (const T ## NDArray& m, octave_ ## T d); \
-  extern OCTAVE_API T ## NDArray max (const T ## NDArray& a, \
-				       const T ## NDArray& b);
+// permutation matrix by matrix ops and vice versa
 
 #define PMM_MULTIPLY_OP(PM, M) \
 M operator * (const PM& p, const M& x) \
 { \
   octave_idx_type nr = x.rows (), nc = x.columns (); \
   M result; \
   if (p.columns () != nr) \
     gripe_nonconformant ("operator *", p.rows (), p.columns (), nr, nc); \
@@ -1328,26 +1099,22 @@ M operator * (const M& x, const PM& p) \
           result = M (nr, nc); \
           result.assign (idx_vector::colon, p.pvec (), x); \
         } \
     } \
   \
   return result; \
 }
 
-#define PMM_BIN_OP_DECLS(R, PM, M, API) \
-  BIN_OP_DECL (R, operator *, PM, M, API);
-
 #define PMM_BIN_OPS(R, PM, M) \
   PMM_MULTIPLY_OP(PM, M);
 
-#define MPM_BIN_OP_DECLS(R, M, PM, API) \
-  BIN_OP_DECL (R, operator *, M, PM, API);
-
 #define MPM_BIN_OPS(R, M, PM) \
   MPM_MULTIPLY_OP(M, PM);
 
+#endif
+
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/uint16NDArray.cc b/liboctave/uint16NDArray.cc
--- a/liboctave/uint16NDArray.cc
+++ b/liboctave/uint16NDArray.cc
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "uint16NDArray.h"
-
+#include "mx-op-defs.h"
 #include "intNDArray.cc"
 
 template class OCTAVE_API intNDArray<octave_uint16>;
 
 template OCTAVE_API
 std::ostream&
 operator << (std::ostream& os, const intNDArray<octave_uint16>& a);
 
diff --git a/liboctave/uint16NDArray.h b/liboctave/uint16NDArray.h
--- a/liboctave/uint16NDArray.h
+++ b/liboctave/uint16NDArray.h
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_uint16NDArray_h)
 #define octave_uint16NDArray_h 1
 
 #include "intNDArray.h"
-#include "mx-op-defs.h"
+#include "mx-op-decl.h"
 #include "oct-inttypes.h"
 
 typedef intNDArray<octave_uint16> uint16NDArray;
 
 NDS_CMP_OP_DECLS (uint16NDArray, octave_uint16, OCTAVE_API)
 NDS_BOOL_OP_DECLS (uint16NDArray, octave_uint16, OCTAVE_API)
 
 SND_CMP_OP_DECLS (octave_uint16, uint16NDArray, OCTAVE_API)
diff --git a/liboctave/uint32NDArray.cc b/liboctave/uint32NDArray.cc
--- a/liboctave/uint32NDArray.cc
+++ b/liboctave/uint32NDArray.cc
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "uint32NDArray.h"
-
+#include "mx-op-defs.h"
 #include "intNDArray.cc"
 
 template class OCTAVE_API intNDArray<octave_uint32>;
 
 template OCTAVE_API
 std::ostream&
 operator << (std::ostream& os, const intNDArray<octave_uint32>& a);
 
diff --git a/liboctave/uint32NDArray.h b/liboctave/uint32NDArray.h
--- a/liboctave/uint32NDArray.h
+++ b/liboctave/uint32NDArray.h
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_uint32NDArray_h)
 #define octave_uint32NDArray_h 1
 
 #include "intNDArray.h"
-#include "mx-op-defs.h"
+#include "mx-op-decl.h"
 #include "oct-inttypes.h"
 
 typedef intNDArray<octave_uint32> uint32NDArray;
 
 NDS_CMP_OP_DECLS (uint32NDArray, octave_uint32, OCTAVE_API)
 NDS_BOOL_OP_DECLS (uint32NDArray, octave_uint32, OCTAVE_API)
 
 SND_CMP_OP_DECLS (octave_uint32, uint32NDArray, OCTAVE_API)
diff --git a/liboctave/uint64NDArray.cc b/liboctave/uint64NDArray.cc
--- a/liboctave/uint64NDArray.cc
+++ b/liboctave/uint64NDArray.cc
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "uint64NDArray.h"
-
+#include "mx-op-defs.h"
 #include "intNDArray.cc"
 
 template class OCTAVE_API intNDArray<octave_uint64>;
 
 template OCTAVE_API
 std::ostream&
 operator << (std::ostream& os, const intNDArray<octave_uint64>& a);
 
diff --git a/liboctave/uint64NDArray.h b/liboctave/uint64NDArray.h
--- a/liboctave/uint64NDArray.h
+++ b/liboctave/uint64NDArray.h
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_uint64NDArray_h)
 #define octave_uint64NDArray_h 1
 
 #include "intNDArray.h"
-#include "mx-op-defs.h"
+#include "mx-op-decl.h"
 #include "oct-inttypes.h"
 
 typedef intNDArray<octave_uint64> uint64NDArray;
 
 NDS_CMP_OP_DECLS (uint64NDArray, octave_uint64, OCTAVE_API)
 NDS_BOOL_OP_DECLS (uint64NDArray, octave_uint64, OCTAVE_API)
 
 SND_CMP_OP_DECLS (octave_uint64, uint64NDArray, OCTAVE_API)
diff --git a/liboctave/uint8NDArray.cc b/liboctave/uint8NDArray.cc
--- a/liboctave/uint8NDArray.cc
+++ b/liboctave/uint8NDArray.cc
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "uint8NDArray.h"
-
+#include "mx-op-defs.h"
 #include "intNDArray.cc"
 
 template class OCTAVE_API intNDArray<octave_uint8>;
 
 template OCTAVE_API
 std::ostream&
 operator << (std::ostream& os, const intNDArray<octave_uint8>& a);
 
diff --git a/liboctave/uint8NDArray.h b/liboctave/uint8NDArray.h
--- a/liboctave/uint8NDArray.h
+++ b/liboctave/uint8NDArray.h
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_uint8NDArray_h)
 #define octave_uint8NDArray_h 1
 
 #include "intNDArray.h"
-#include "mx-op-defs.h"
+#include "mx-op-decl.h"
 #include "oct-inttypes.h"
 
 typedef intNDArray<octave_uint8> uint8NDArray;
 
 NDS_CMP_OP_DECLS (uint8NDArray, octave_uint8, OCTAVE_API)
 NDS_BOOL_OP_DECLS (uint8NDArray, octave_uint8, OCTAVE_API)
 
 SND_CMP_OP_DECLS (octave_uint8, uint8NDArray, OCTAVE_API)
