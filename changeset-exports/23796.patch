# HG changeset patch
# User Rik <rik@octave.org>
# Date 1501111591 25200
#      Wed Jul 26 16:26:31 2017 -0700
# Node ID 4f12819a634fa25971c155656ade2363c1e9b9ab
# Parent  980f39c3ab90dd169f17691467d663fd625d22e4
Use C++11 nullptr rather than 0 in code (bug #51565).

* mk-opts.pl, BlockArray.cpp, KeyboardTranslator.cpp, Screen.cpp,
TerminalCharacterDecoder.cpp, TerminalView.cpp, Vt102Emulation.cpp, dialog.cc,
find-files-dialog.cc, file-editor-tab.cc, main-window.cc, ls-hdf5.cc,
oct-procbuf.h, oct-stream.cc, oct-tex-lexer.in.ll, zfstream.cc, ov-builtin.h,
ov-fcn-handle.cc, ov-typeinfo.h, ov-usr-fcn.h, options-usage.h, lex.ll,
oct-parse.in.yy, pt-loop.h, Array.cc, CSparse.cc, Sparse.h, dSparse.cc,
fCMatrix.cc, idx-vector.cc, idx-vector.h, sparse-chol.cc, cmd-edit.cc,
oct-sort.cc, main.in.cc:
Use C++11 nullptr rather than 0 in code (bug #51565).

diff --git a/build-aux/mk-opts.pl b/build-aux/mk-opts.pl
--- a/build-aux/mk-opts.pl
+++ b/build-aux/mk-opts.pl
@@ -577,30 +577,30 @@ sub emit_struct_def
 sub emit_option_table_entry
 {
   my ($i, $empty) = @_;
 
   my $k;
 
   if ($empty)
     {
-      print "  { 0,\n";
+      print "  { nullptr,\n";
     }
   else
     {
       print "  { \"$NAME[$i]\",\n";
     }
 
   my $n = scalar $#{$KW_TOK[$i]};
   print "    {";
   for $k (0 .. $MAX_TOKENS)
     {
       if ($empty or $k > $n)
         {
-          print " 0,";
+          print " nullptr,";
         }
       else
         {
           print " \"$KW_TOK[$i][$k]\",";
         }
     }
   print " },\n";
 
diff --git a/libgui/qterminal/libqterminal/unix/BlockArray.cpp b/libgui/qterminal/libqterminal/unix/BlockArray.cpp
--- a/libgui/qterminal/libqterminal/unix/BlockArray.cpp
+++ b/libgui/qterminal/libqterminal/unix/BlockArray.cpp
@@ -35,19 +35,19 @@
 
 
 static int blocksize = 0;
 
 BlockArray::BlockArray()
     : size(0),
       current(size_t(-1)),
       index(size_t(-1)),
-      lastmap(0),
+      lastmap(nullptr),
       lastmap_index(size_t(-1)),
-      lastblock(0), ion(-1),
+      lastblock(nullptr), ion(-1),
       length(0)
 {
     // lastmap_index = index = current = size_t(-1);
     if (blocksize == 0)
         blocksize = ((sizeof(Block) / getpagesize()) + 1) * getpagesize();
 
 }
 
@@ -123,19 +123,19 @@ const Block* BlockArray::at(size_t i)
 //         return 0;
 //     }
 
     size_t j = i; // (current - (index - i) + (index/size+1)*size) % size ;
 
     assert(j < size);
     unmap();
 
-    Block *block = (Block*)mmap(0, blocksize, PROT_READ, MAP_PRIVATE, ion, j * blocksize);
+    Block *block = (Block*)mmap(nullptr, blocksize, PROT_READ, MAP_PRIVATE, ion, j * blocksize);
 
-    if (block == (Block*)-1) { perror("mmap"); return 0; }
+    if (block == (Block*)-1) { perror("mmap"); return nullptr; }
 
     lastmap = block;
     lastmap_index = i;
 
     return block;
 }
 
 void BlockArray::unmap()
diff --git a/libgui/qterminal/libqterminal/unix/KeyboardTranslator.cpp b/libgui/qterminal/libqterminal/unix/KeyboardTranslator.cpp
--- a/libgui/qterminal/libqterminal/unix/KeyboardTranslator.cpp
+++ b/libgui/qterminal/libqterminal/unix/KeyboardTranslator.cpp
@@ -648,17 +648,17 @@ QByteArray KeyboardTranslator::Entry::es
             // any character which is not printable is replaced by an equivalent
             // \xhh escape sequence (where 'hh' are the corresponding hex digits)
             if ( !QChar(ch).isPrint() )
                 replacement = 'x';
         }
 
         if ( replacement == 'x' )
         {
-          result.replace(i,1,"\\x"+QByteArray::number(QByteArray(1,ch).toInt(0, 16)));
+          result.replace(i,1,"\\x"+QByteArray::number(QByteArray(1,ch).toInt(nullptr, 16)));
         } else if ( replacement != 0 )
         {
             result.remove(i,1);
             result.insert(i,'\\');
             result.insert(i+1,replacement);
         }
     }
 
diff --git a/libgui/qterminal/libqterminal/unix/Screen.cpp b/libgui/qterminal/libqterminal/unix/Screen.cpp
--- a/libgui/qterminal/libqterminal/unix/Screen.cpp
+++ b/libgui/qterminal/libqterminal/unix/Screen.cpp
@@ -69,17 +69,17 @@ Screen::Screen(int l, int c)
     columns(c),
     screenLines(new ImageLine[lines+1] ),
     _scrolledLines(0),
     _droppedLines(0),
     hist(new HistoryScrollNone()),
     cuX(0), cuY(0),
     cu_re(0),
     tmargin(0), bmargin(0),
-    tabstops(0),
+    tabstops(nullptr),
     sel_begin(0), sel_TL(0), sel_BR(0),
     sel_busy(false),
     columnmode(false),
     ef_fg(CharacterColor()), ef_bg(CharacterColor()), ef_re(0),
     sa_cuX(0), sa_cuY(0),
     sa_cu_re(0),
     lastPos(-1)
 {
diff --git a/libgui/qterminal/libqterminal/unix/TerminalCharacterDecoder.cpp b/libgui/qterminal/libqterminal/unix/TerminalCharacterDecoder.cpp
--- a/libgui/qterminal/libqterminal/unix/TerminalCharacterDecoder.cpp
+++ b/libgui/qterminal/libqterminal/unix/TerminalCharacterDecoder.cpp
@@ -42,17 +42,17 @@ bool PlainTextDecoder::trailingWhitespac
     return _includeTrailingWhitespace;
 }
 void PlainTextDecoder::begin(QTextStream* output)
 {
    _output = output;
 }
 void PlainTextDecoder::end()
 {
-    _output = 0;
+    _output = nullptr;
 }
 void PlainTextDecoder::decodeLine(const Character* const characters, int count, LineProperty /*properties*/
 							 )
 {
     Q_ASSERT( _output );
 
 	//TODO should we ignore or respect the LINE_WRAPPED line property?
 
diff --git a/libgui/qterminal/libqterminal/unix/TerminalView.cpp b/libgui/qterminal/libqterminal/unix/TerminalView.cpp
--- a/libgui/qterminal/libqterminal/unix/TerminalView.cpp
+++ b/libgui/qterminal/libqterminal/unix/TerminalView.cpp
@@ -232,29 +232,29 @@ void TerminalView::setFont(const QFont &
 /* ------------------------------------------------------------------------- */
 /*                                                                           */
 /*                         Constructor / Destructor                          */
 /*                                                                           */
 /* ------------------------------------------------------------------------- */
 
 TerminalView::TerminalView(QWidget *parent)
   :QWidget(parent)
-  ,_screenWindow(0)
+  ,_screenWindow(nullptr)
   ,_allowBell(true)
-  ,_gridLayout(0)
+  ,_gridLayout(nullptr)
   ,_fontHeight(1)
   ,_fontWidth(1)
   ,_fontAscent(1)
   ,_lines(1)
   ,_columns(1)
   ,_usedLines(1)
   ,_usedColumns(1)
   ,_contentHeight(1)
   ,_contentWidth(1)
-  ,_image(0)
+  ,_image(nullptr)
   ,_randomSeed(0)
   ,_resizing(false)
   ,_terminalSizeHint(false)
   ,_terminalSizeStartup(true)
   ,_actSel(0)
   ,_wordSelectionMode(false)
   ,_lineSelectionMode(false)
   ,_preserveLineBreaks(false)
@@ -264,19 +264,19 @@ TerminalView::TerminalView(QWidget *pare
   ,_bellMode(SystemBeepBell)
   ,_blinking(false)
   ,_cursorBlinking(false)
   ,_hasBlinkingCursor(false)
   ,_ctrlDrag(false)
   ,_tripleClickMode(SelectWholeLine)
   ,_isFixedSize(false)
   ,_possibleTripleClick(false)
-  ,_resizeWidget(0)
-  ,_resizeTimer(0)
-  ,_outputSuspendedLabel(0)
+  ,_resizeWidget(nullptr)
+  ,_resizeTimer(nullptr)
+  ,_outputSuspendedLabel(nullptr)
   ,_lineSpacing(0)
   ,_colorsInverted(false)
   ,_blendColor(qRgba(0,0,0,0xff))
   ,_filterChain(new TerminalImageFilterChain())
   ,_cursorShape(BlockCursor)
   ,_readonly(false)
 {
   // terminal applications are not designed with Right-To-Left in mind,
diff --git a/libgui/qterminal/libqterminal/unix/Vt102Emulation.cpp b/libgui/qterminal/libqterminal/unix/Vt102Emulation.cpp
--- a/libgui/qterminal/libqterminal/unix/Vt102Emulation.cpp
+++ b/libgui/qterminal/libqterminal/unix/Vt102Emulation.cpp
@@ -1208,18 +1208,18 @@ bool Vt102Emulation::getMode(int m)
 {
   return _currParm.mode[m];
 }
 
 char Vt102Emulation::getErase() const
 {
   KeyboardTranslator::Entry entry = _keyTranslator->findEntry(
                                             Qt::Key_Backspace,
-                                            0,
-                                            0);
+                                            nullptr,
+                                            nullptr);
   if ( entry.text().count() > 0 )
       return entry.text()[0];
   else
       return '\b';
 }
 
 /* ------------------------------------------------------------------------- */
 /*                                                                           */
diff --git a/libgui/src/dialog.cc b/libgui/src/dialog.cc
--- a/libgui/src/dialog.cc
+++ b/libgui/src/dialog.cc
@@ -129,17 +129,17 @@ QUIWidgetCreator::filedialog_finished (c
 
 MessageDialog::MessageDialog (const QString& message,
                               const QString& title,
                               const QString& qsicon,
                               const QStringList& qsbutton,
                               const QString& defbutton,
                               const QStringList& role)
   : QMessageBox (QMessageBox::NoIcon, title.isEmpty () ? " " : title,
-                 message, 0, nullptr)
+                 message, nullptr, nullptr)
 {
   // Create a NonModal message.
   setWindowModality (Qt::NonModal);
 
   // Interpret the icon string, because enumeration QMessageBox::Icon can't
   // easily be made to pass through a signal.
   QMessageBox::Icon eicon = QMessageBox::NoIcon;
   if (qsicon == "error")
diff --git a/libgui/src/find-files-dialog.cc b/libgui/src/find-files-dialog.cc
--- a/libgui/src/find-files-dialog.cc
+++ b/libgui/src/find-files-dialog.cc
@@ -47,17 +47,17 @@ along with Octave; see the file COPYING.
 #include "resource-manager.h"
 
 find_files_dialog::find_files_dialog (QWidget *p)
   : QDialog (p)
 {
   setWindowTitle (tr ("Find Files"));
   setWindowIcon (resource_manager::icon ("edit-find"));
 
-  _dir_iterator = 0;
+  _dir_iterator = nullptr;
 
   _timer = new QTimer (this);
   connect (_timer, SIGNAL (timeout ()), this, SLOT (look_for_files ()));
 
   QSettings *settings = resource_manager::get_settings ();
 
   QLabel *file_name_label = new QLabel (tr ("Named:"));
   _file_name_edit = new QLineEdit;
diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -482,17 +482,17 @@ file_editor_tab::valid_file_name (const 
 // file on disk.  This function gives the user the option
 // to save before creating the breakpoint.
 bool
 file_editor_tab::unchanged_or_saved (void)
 {
   bool retval = true;
   if (_edit_area->isModified ())
     {
-      int ans = QMessageBox::question (0, tr ("Octave Editor"),
+      int ans = QMessageBox::question (nullptr, tr ("Octave Editor"),
                   tr ("Cannot add breakpoint to modified file.\n"
                       "Save and add breakpoint, or cancel?"),
                   QMessageBox::Save | QMessageBox::Cancel, QMessageBox::Save);
 
       if (ans == QMessageBox::Save)
         save_file (_file_name, false);
       else
         retval = false;
@@ -747,17 +747,17 @@ file_editor_tab::update_lexer_settings (
                   keyword = QString (lexer->keywords (i));          // get list
                   keyword_list = keyword.split (QRegExp ("\\s+"));  // split
                   for (j = 0; j < keyword_list.size (); j++)        // add to API
                     _lexer_apis->add (keyword_list.at (j));
                 }
             }
 
           // disconnect slot for saving prepared info if already connected
-          disconnect (_lexer_apis, SIGNAL (apiPreparationFinished ()), 0, 0);
+          disconnect (_lexer_apis, SIGNAL (apiPreparationFinished ()), nullptr, nullptr);
           // check whether path for prepared info exists or can be created
           if (QDir ("/").mkpath (prep_apis_path))
             {
               // path exists, apis info can be saved there
               connect (_lexer_apis, SIGNAL (apiPreparationFinished ()),
                        this, SLOT (save_apis_info ()));
             }
 
@@ -1848,17 +1848,17 @@ file_editor_tab::exit_debug_and_clear (c
   octave::call_stack& cs
     = octave::__get_call_stack__ ("file_editor_tab::exit_debug_and_clear");
   octave_map stk = cs.backtrace (nskip, curr_frame, false);
   Cell names = stk.contents ("name");
   for (octave_idx_type i = names.numel () - 1; i >= 0; i--)
     {
       if (names(i).string_value () == base_name)
         {
-          int ans = QMessageBox::question (0, tr ("Debug or Save"),
+          int ans = QMessageBox::question (nullptr, tr ("Debug or Save"),
              tr ("This file is currently being executed.\n"
                           "Quit debugging and save?"),
               QMessageBox::Save | QMessageBox::Cancel);
 
           if (ans == QMessageBox::Save)
             {
               emit execute_command_in_terminal_signal ("dbquit");
               // Wait until dbquit has actually occurred
@@ -1926,17 +1926,17 @@ file_editor_tab::save_file (const QStrin
         _file_system_watcher.addPath (file_to_save);
 
       // Create a NonModal message about error.
       QMessageBox *msgBox
         = new QMessageBox (QMessageBox::Critical,
                            tr ("Octave Editor"),
                            tr ("Could not open file %1 for write:\n%2.").
                            arg (file_to_save).arg (file.errorString ()),
-                           QMessageBox::Ok, 0);
+                           QMessageBox::Ok, nullptr);
       show_dialog (msgBox, false);
 
       return;
     }
 
   // save the contents into the file
 
   _encoding = _new_encoding;    // consider a possible new encoding
@@ -2138,17 +2138,17 @@ bool
 file_editor_tab::check_valid_identifier (QString file_name)
 {
   QFileInfo file = QFileInfo (file_name);
   QString base_name = file.baseName ();
 
   if ((file.suffix () == "m")
       && (! valid_identifier (base_name.toStdString ())))
     {
-      int ans = QMessageBox::question (0, tr ("Octave Editor"),
+      int ans = QMessageBox::question (nullptr, tr ("Octave Editor"),
          tr ("\"%1\"\n"
              "is not a valid identifier.\n\n"
              "If you keep this filename, you will not be able to\n"
              "call your script using its name as an Octave command.\n\n"
              "Do you want to choose another name?").arg (base_name),
           QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes);
 
       if (ans == QMessageBox::Yes)
@@ -2158,17 +2158,17 @@ file_editor_tab::check_valid_identifier 
   return false;
 }
 
 bool
 file_editor_tab::check_valid_codec (QTextCodec *codec)
 {
   if (! codec->canEncode (_edit_area->text ()))
     {
-      int ans = QMessageBox::warning (0,
+      int ans = QMessageBox::warning (nullptr,
             tr ("Octave Editor"),
             tr ("The current editor contents can not be encoded\n"
                 "with the selected codec %1.\n"
                 "Using it will result in data loss!\n\n"
                 "Do you want to chose another codec?").arg (_encoding),
             QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes);
 
       if (ans == QMessageBox::Yes)
@@ -2280,17 +2280,17 @@ file_editor_tab::file_has_changed (const
       // parent because it may be deleted depending upon the response.
       // Instead, change the _edit_area to read only.
       QMessageBox *msgBox
         = new QMessageBox (QMessageBox::Warning, tr ("Octave Editor"),
                            tr ("It seems that the file\n"
                                "%1\n"
                                "has been deleted or renamed. Do you want to save it now?%2").
                            arg (_file_name).arg (modified),
-                           QMessageBox::Save | QMessageBox::Close, 0);
+                           QMessageBox::Save | QMessageBox::Close, nullptr);
 
       _edit_area->setReadOnly (true);
 
       connect (msgBox, SIGNAL (finished (int)),
                this, SLOT (handle_file_resave_answer (int)));
 
       msgBox->setWindowModality (Qt::WindowModal);
       msgBox->setAttribute (Qt::WA_DeleteOnClose);
@@ -2373,17 +2373,17 @@ file_editor_tab::notice_settings (const 
       _edit_area->setMarginLineNumbers (2, true);
       auto_margin_width ();
       connect (_edit_area, SIGNAL (linesChanged ()),
                this, SLOT (auto_margin_width ()));
     }
   else
     {
       _edit_area->setMarginLineNumbers (2, false);
-      disconnect (_edit_area, SIGNAL (linesChanged ()), 0, 0);
+      disconnect (_edit_area, SIGNAL (linesChanged ()), nullptr, nullptr);
     }
 
   _smart_indent = settings->value ("editor/auto_indent",true).toBool ();
   _edit_area->setAutoIndent (_smart_indent);
   _edit_area->setTabIndents
         (settings->value ("editor/tab_indents_line",false).toBool ());
   _edit_area->setBackspaceUnindents
         (settings->value ("editor/backspace_unindents_line",false).toBool ());
diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -178,17 +178,17 @@ main_window::main_window (QWidget *p, oc
   if (! editor_window)
     _active_editor = _external_editor;
 
   QSettings *settings = resource_manager::get_settings ();
 
   bool connect_to_web = true;
   QDateTime last_checked;
   int serial = 0;
-  _active_dock = 0;
+  _active_dock = nullptr;
 
   if (settings)
     {
       connect_to_web
         = settings->value ("news/allow_web_connection", true).toBool ();
 
       last_checked
         = settings->value ("news/last_time_checked", QDateTime ()).toDateTime ();
diff --git a/libinterp/corefcn/ls-hdf5.cc b/libinterp/corefcn/ls-hdf5.cc
--- a/libinterp/corefcn/ls-hdf5.cc
+++ b/libinterp/corefcn/ls-hdf5.cc
@@ -230,20 +230,20 @@ hdf5_check_attr (octave_hdf5_id loc_id, 
   H5E_auto_t err_func;
   void *err_func_data;
 
   // turn off error reporting temporarily, but save the error
   // reporting function:
 
 #if defined (HAVE_HDF5_18)
   H5Eget_auto (octave_H5E_DEFAULT, &err_func, &err_func_data);
-  H5Eset_auto (octave_H5E_DEFAULT, 0, nullptr);
+  H5Eset_auto (octave_H5E_DEFAULT, nullptr, nullptr);
 #else
   H5Eget_auto (&err_func, &err_func_data);
-  H5Eset_auto (0, nullptr);
+  H5Eset_auto (nullptr, nullptr);
 #endif
 
   hid_t attr_id = H5Aopen_name (loc_id, attr_name);
 
   if (attr_id >= 0)
     {
       // successful
       retval = true;
@@ -278,20 +278,20 @@ hdf5_get_scalar_attr (octave_hdf5_id loc
   H5E_auto_t err_func;
   void *err_func_data;
 
   // turn off error reporting temporarily, but save the error
   // reporting function:
 
 #if defined (HAVE_HDF5_18)
   H5Eget_auto (octave_H5E_DEFAULT, &err_func, &err_func_data);
-  H5Eset_auto (octave_H5E_DEFAULT, 0, nullptr);
+  H5Eset_auto (octave_H5E_DEFAULT, nullptr, nullptr);
 #else
   H5Eget_auto (&err_func, &err_func_data);
-  H5Eset_auto (0, nullptr);
+  H5Eset_auto (nullptr, nullptr);
 #endif
 
   hid_t attr_id = H5Aopen_name (loc_id, attr_name);
 
   if (attr_id >= 0)
     {
       hid_t space_id = H5Aget_space (attr_id);
 
diff --git a/libinterp/corefcn/oct-procbuf.h b/libinterp/corefcn/oct-procbuf.h
--- a/libinterp/corefcn/oct-procbuf.h
+++ b/libinterp/corefcn/oct-procbuf.h
@@ -33,21 +33,21 @@ along with Octave; see the file COPYING.
 #include "c-file-ptr-stream.h"
 
 class
 octave_procbuf : public c_file_ptr_buf
 {
 public:
 
   octave_procbuf (void)
-    : c_file_ptr_buf (0), wstatus (-1), open_p (false), proc_pid (-1),
+    : c_file_ptr_buf (nullptr), wstatus (-1), open_p (false), proc_pid (-1),
       next (nullptr) { }
 
   octave_procbuf (const char *command, int mode)
-    : c_file_ptr_buf (0), wstatus (-1), open_p (false), proc_pid (-1),
+    : c_file_ptr_buf (nullptr), wstatus (-1), open_p (false), proc_pid (-1),
       next (nullptr) { open (command, mode); }
 
   // No copying!
 
   octave_procbuf (const octave_procbuf&) = delete;
 
   octave_procbuf& operator = (const octave_procbuf&) = delete;
 
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -313,17 +313,17 @@ namespace octave
     const scanf_format_elt * current (void) const
     {
       return length () > 0 ? fmt_elts[curr_idx] : nullptr;
     }
 
     const scanf_format_elt * next (bool cycle = true)
     {
       static scanf_format_elt dummy
-        (0, 0, false, scanf_format_elt::null, '\0', "");
+        (nullptr, 0, false, scanf_format_elt::null, '\0', "");
 
       curr_idx++;
 
       if (curr_idx >= length ())
         {
           if (cycle)
             curr_idx = 0;
           else
diff --git a/libinterp/corefcn/oct-tex-lexer.in.ll b/libinterp/corefcn/oct-tex-lexer.in.ll
--- a/libinterp/corefcn/oct-tex-lexer.in.ll
+++ b/libinterp/corefcn/oct-tex-lexer.in.ll
@@ -30,16 +30,17 @@ along with Octave; see the file COPYING.
 #pragma GCC diagnostic ignored "-Wunused-function"
 
 // Disable these warnings for code that is generated by flex, including
 // pattern rules.  Push the current state so we can restore the warning
 // state prior to functions we define at the bottom of the file.
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wold-style-cast"
 #pragma GCC diagnostic ignored "-Wsign-compare"
+#pragma GCC diagnostic ignored "-Wzero-as-null-pointer-constant"
 #endif
 
 // Define away the deprecated register storage class specifier to avoid
 // potential warnings about it.
 #if ! defined (register)
 #  define register
 #endif
 
@@ -215,33 +216,33 @@ text_parser_tex::init_lexer (const std::
     octave_tex_lex_init (&scanner);
 
   if (scanner)
     {
       if (buffer_state)
         {
           octave_tex__delete_buffer (reinterpret_cast<YY_BUFFER_STATE> (buffer_state),
                                      scanner);
-          buffer_state = 0;
+          buffer_state = nullptr;
         }
 
       buffer_state = octave_tex__scan_bytes (s.data (), s.length (), scanner);
     }
 
   return (scanner && buffer_state);
 }
 
 void
 text_parser_tex::destroy_lexer (void)
 {
   if (buffer_state)
     {
       octave_tex__delete_buffer (reinterpret_cast<YY_BUFFER_STATE> (buffer_state),
                                  scanner);
-      buffer_state = 0;
+      buffer_state = nullptr;
     }
 
   if (scanner)
     {
       octave_tex_lex_destroy (scanner);
-      scanner = 0;
+      scanner = nullptr;
     }
 }
diff --git a/libinterp/corefcn/zfstream.cc b/libinterp/corefcn/zfstream.cc
--- a/libinterp/corefcn/zfstream.cc
+++ b/libinterp/corefcn/zfstream.cc
@@ -411,17 +411,17 @@ gzfilebuf::enable_buffer ()
         }
       else
         {
           // Even in "unbuffered" case, (small?) get buffer is still required
           buffer_size = SMALLBUFSIZE;
           buffer = new char_type [buffer_size];
           this->setg (buffer, buffer, buffer);
           // "Unbuffered" means no put buffer
-          this->setp (0, 0);
+          this->setp (nullptr, nullptr);
         }
     }
   else
     {
       // If buffer already allocated, reset buffer pointers just to make sure no
       // stale chars are lying around
       this->setg (buffer, buffer, buffer);
       this->setp (buffer, buffer + buffer_size - 1);
@@ -435,27 +435,27 @@ gzfilebuf::disable_buffer ()
   // If internal buffer exists, deallocate it
   if (own_buffer && buffer)
     {
       // Preserve unbuffered status by zeroing size
       if (! this->pbase ())
         buffer_size = 0;
       delete[] buffer;
       buffer = nullptr;
-      this->setg (0, 0, 0);
-      this->setp (0, 0);
+      this->setg (nullptr, nullptr, nullptr);
+      this->setp (nullptr, nullptr);
     }
   else
     {
       // Reset buffer pointers to initial state if external buffer exists
       this->setg (buffer, buffer, buffer);
       if (buffer)
         this->setp (buffer, buffer + buffer_size - 1);
       else
-        this->setp (0, 0);
+        this->setp (nullptr, nullptr);
     }
 }
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
 // Seek functions
 gzfilebuf::pos_type
 gzfilebuf::seekoff (off_type off, std::ios_base::seekdir way,
diff --git a/libinterp/octave-value/ov-builtin.h b/libinterp/octave-value/ov-builtin.h
--- a/libinterp/octave-value/ov-builtin.h
+++ b/libinterp/octave-value/ov-builtin.h
@@ -45,38 +45,38 @@ namespace octave
 // Builtin functions.
 
 class
 OCTINTERP_API
 octave_builtin : public octave_function
 {
 public:
 
-  octave_builtin (void) : octave_function (), f (0), file (), jtype (nullptr) { }
+  octave_builtin (void) : octave_function (), f (nullptr), file (), jtype (nullptr) { }
 
   typedef octave_value_list (*meth) (octave::interpreter&,
                                      const octave_value_list&, int);
 
   typedef octave_value_list (*fcn) (const octave_value_list&, int);
 
   octave_builtin (fcn ff, const std::string& nm = "",
                   const std::string& ds = "")
-    : octave_function (nm, ds), f (ff), m (0), file (), jtype (nullptr) { }
+    : octave_function (nm, ds), f (ff), m (nullptr), file (), jtype (nullptr) { }
 
   octave_builtin (meth mm, const std::string& nm = "",
                   const std::string& ds = "")
-    : octave_function (nm, ds), f (0), m (mm), file (), jtype (nullptr) { }
+    : octave_function (nm, ds), f (nullptr), m (mm), file (), jtype (nullptr) { }
 
   octave_builtin (fcn ff, const std::string& nm, const std::string& fnm,
                   const std::string& ds)
-    : octave_function (nm, ds), f (ff), m (0), file (fnm), jtype (nullptr) { }
+    : octave_function (nm, ds), f (ff), m (nullptr), file (fnm), jtype (nullptr) { }
 
   octave_builtin (meth mm, const std::string& nm, const std::string& fnm,
                   const std::string& ds)
-    : octave_function (nm, ds), f (0), m (mm), file (fnm), jtype (nullptr) { }
+    : octave_function (nm, ds), f (nullptr), m (mm), file (fnm), jtype (nullptr) { }
 
   // No copying!
 
   octave_builtin (const octave_builtin& ob) = delete;
 
   octave_builtin& operator = (const octave_builtin& ob) = delete;
 
   ~octave_builtin (void) = default;
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -1118,20 +1118,20 @@ octave_fcn_handle::load_hdf5 (octave_hdf
 
       H5E_auto_t err_func;
       void *err_func_data;
 
       // turn off error reporting temporarily, but save the error
       // reporting function:
 #if defined (HAVE_HDF5_18)
       H5Eget_auto (octave_H5E_DEFAULT, &err_func, &err_func_data);
-      H5Eset_auto (octave_H5E_DEFAULT, 0, nullptr);
+      H5Eset_auto (octave_H5E_DEFAULT, nullptr, nullptr);
 #else
       H5Eget_auto (&err_func, &err_func_data);
-      H5Eset_auto (0, nullptr);
+      H5Eset_auto (nullptr, nullptr);
 #endif
 
       hid_t attr_id = H5Aopen_name (group_hid, "SYMBOL_TABLE");
 
       if (attr_id >= 0)
         {
           if (H5Aread (attr_id, H5T_NATIVE_IDX, &len) < 0)
             success = false;
@@ -1234,20 +1234,20 @@ octave_fcn_handle::load_hdf5 (octave_hdf
 
       H5E_auto_t err_func;
       void *err_func_data;
 
       // turn off error reporting temporarily, but save the error
       // reporting function:
 #if defined (HAVE_HDF5_18)
       H5Eget_auto (octave_H5E_DEFAULT, &err_func, &err_func_data);
-      H5Eset_auto (octave_H5E_DEFAULT, 0, nullptr);
+      H5Eset_auto (octave_H5E_DEFAULT, nullptr, nullptr);
 #else
       H5Eget_auto (&err_func, &err_func_data);
-      H5Eset_auto (0, nullptr);
+      H5Eset_auto (nullptr, nullptr);
 #endif
 
       hid_t attr_id = H5Aopen_name (group_hid, "OCTAVEROOT");
       if (attr_id >= 0)
         {
           H5Tclose (type_hid);
           type_hid = H5Aget_type (attr_id);
           type_class_hid = H5Tget_class (type_hid);
diff --git a/libinterp/octave-value/ov-typeinfo.h b/libinterp/octave-value/ov-typeinfo.h
--- a/libinterp/octave-value/ov-typeinfo.h
+++ b/libinterp/octave-value/ov-typeinfo.h
@@ -188,26 +188,26 @@ public:
     return instance->do_installed_type_info ();
   }
 
 protected:
 
   octave_value_typeinfo (void)
     : num_types (0), types (dim_vector (init_tab_sz, 1), ""),
       vals (dim_vector (init_tab_sz, 1)),
-      unary_class_ops (dim_vector (octave_value::num_unary_ops, 1), 0),
-      unary_ops (dim_vector (octave_value::num_unary_ops, init_tab_sz), 0),
-      non_const_unary_ops (dim_vector (octave_value::num_unary_ops, init_tab_sz), 0),
-      binary_class_ops (dim_vector (octave_value::num_binary_ops, 1), 0),
-      binary_ops (dim_vector (octave_value::num_binary_ops, init_tab_sz, init_tab_sz), 0),
-      compound_binary_class_ops (dim_vector (octave_value::num_compound_binary_ops, 1), 0),
-      compound_binary_ops (dim_vector (octave_value::num_compound_binary_ops, init_tab_sz, init_tab_sz), 0),
-      cat_ops (dim_vector (init_tab_sz, init_tab_sz), 0),
-      assign_ops (dim_vector (octave_value::num_assign_ops, init_tab_sz, init_tab_sz), 0),
-      assignany_ops (dim_vector (octave_value::num_assign_ops, init_tab_sz), 0),
+      unary_class_ops (dim_vector (octave_value::num_unary_ops, 1), nullptr),
+      unary_ops (dim_vector (octave_value::num_unary_ops, init_tab_sz), nullptr),
+      non_const_unary_ops (dim_vector (octave_value::num_unary_ops, init_tab_sz), nullptr),
+      binary_class_ops (dim_vector (octave_value::num_binary_ops, 1), nullptr),
+      binary_ops (dim_vector (octave_value::num_binary_ops, init_tab_sz, init_tab_sz), nullptr),
+      compound_binary_class_ops (dim_vector (octave_value::num_compound_binary_ops, 1), nullptr),
+      compound_binary_ops (dim_vector (octave_value::num_compound_binary_ops, init_tab_sz, init_tab_sz), nullptr),
+      cat_ops (dim_vector (init_tab_sz, init_tab_sz), nullptr),
+      assign_ops (dim_vector (octave_value::num_assign_ops, init_tab_sz, init_tab_sz), nullptr),
+      assignany_ops (dim_vector (octave_value::num_assign_ops, init_tab_sz), nullptr),
       pref_assign_conv (dim_vector (init_tab_sz, init_tab_sz), -1),
       widening_ops (dim_vector (init_tab_sz, init_tab_sz), nullptr)  { }
 
   // No copying!
 
   octave_value_typeinfo (const octave_value_typeinfo&) = delete;
 
   octave_value_typeinfo& operator = (const octave_value_typeinfo&) = delete;
diff --git a/libinterp/octave-value/ov-usr-fcn.h b/libinterp/octave-value/ov-usr-fcn.h
--- a/libinterp/octave-value/ov-usr-fcn.h
+++ b/libinterp/octave-value/ov-usr-fcn.h
@@ -57,17 +57,17 @@ class jit_function_info;
 
 class
 octave_user_code : public octave_function
 {
 protected:
 
   octave_user_code (const std::string& nm,
                     const std::string& ds = "")
-    : octave_function (nm, ds), curr_unwind_protect_frame (0),
+    : octave_function (nm, ds), curr_unwind_protect_frame (nullptr),
       m_file_info (nullptr)
   { }
 
 public:
 
   octave_user_code (void)
     : octave_function () { }
 
diff --git a/libinterp/options-usage.h b/libinterp/options-usage.h
--- a/libinterp/options-usage.h
+++ b/libinterp/options-usage.h
@@ -41,16 +41,23 @@ static const char *usage_string =
        [--path path] [--persist] [--silent] [--traditional]\n\
        [--verbose] [--version] [file]";
 
 // This is here so that it's more likely that the usage message and
 // the real set of options will agree.  Note: the '+' must come first
 // to prevent getopt from permuting arguments!
 static const char *short_opts = "+HWVdfhip:qvx";
 
+
+#if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
+// Disable warning temporarily
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wzero-as-null-pointer-constant"
+#endif
+
 // Long options.  See the comments in getopt.h for the meanings of the
 // fields in this structure.
 #define BUILT_IN_DOCSTRINGS_FILE_OPTION 1
 #define DOC_CACHE_FILE_OPTION 2
 #define EVAL_OPTION 3
 #define EXEC_PATH_OPTION 4
 #define FORCE_GUI_OPTION 5
 #define IMAGE_PATH_OPTION 6
@@ -99,16 +106,21 @@ struct octave_getopt_options long_opts[]
   { "silent",                   octave_no_arg,       0, 'q' },
   { "texi-macros-file",         octave_required_arg, 0, TEXI_MACROS_FILE_OPTION },
   { "traditional",              octave_no_arg,       0, TRADITIONAL_OPTION },
   { "verbose",                  octave_no_arg,       0, 'V' },
   { "version",                  octave_no_arg,       0, 'v' },
   { 0,                          0,                   0, 0 }
 };
 
+#if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
+// Restore prevailing warning state for remainder of the file.
+#pragma GCC diagnostic pop
+#endif
+
 // Usage message with extra help.
 
 static void
 octave_print_verbose_usage_and_exit (void)
 {
   std::cout << octave_name_version_copyright_copying_and_warranty ()
             << "\n\
 \n\
diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -41,16 +41,18 @@ object) relevant global values before an
 #pragma GCC diagnostic ignored "-Wunused-function"
 
 // Disable these warnings for code that is generated by flex, including
 // pattern rules.  Push the current state so we can restore the warning
 // state prior to functions we define at the bottom of the file.
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wold-style-cast"
 #pragma GCC diagnostic ignored "-Wsign-compare"
+#pragma GCC diagnostic ignored "-Wzero-as-null-pointer-constant"
+
 #endif
 
 // Define away the deprecated register storage class specifier to avoid
 // potential warnings about it.
 #if ! defined (register)
 #  define register
 #endif
 
@@ -1968,17 +1970,17 @@ namespace octave
     // Parsing function names like "set.property_name" inside
     // classdef-style class definitions is simplified by handling the
     // "set" and "get" portions of the names using the same mechanism
     // as is used for keywords.  However, they are not really keywords
     // in the language, so omit them from the list of possible
     // keywords.  Likewise for "enumeration", "events", "methods", and
     // "properties".
 
-    return (octave_kw_hash::in_word_set (s.c_str (), s.length ()) != 0
+    return (octave_kw_hash::in_word_set (s.c_str (), s.length ()) != nullptr
             && ! (s == "set" || s == "get"
                   || s == "enumeration" || s == "events"
                   || s == "methods" || s == "properties"));
   }
 }
 
 DEFUN (iskeyword, args, ,
        doc: /* -*- texinfo -*-
@@ -2116,17 +2118,17 @@ namespace octave
       return frame_stack.front ();
   }
 
   symbol_table::scope *
   lexical_feedback::symbol_table_context::parent_scope (void) const
   {
     size_t sz = size ();
 
-    return sz > 1 ? frame_stack[1] : (sz == 1 ? frame_stack[0] : 0);
+    return sz > 1 ? frame_stack[1] : (sz == 1 ? frame_stack[0] : nullptr);
   }
 
   lexical_feedback::~lexical_feedback (void)
   {
     tokens.clear ();
   }
 
   void
@@ -2548,17 +2550,17 @@ namespace octave
 
     if (kw)
       {
         bool previous_at_bos = at_beginning_of_statement;
 
         // May be reset to true for some token types.
         at_beginning_of_statement = false;
 
-        token *tok_val = 0;
+        token *tok_val = nullptr;
 
         switch (kw->kw_id)
           {
           case break_kw:
           case catch_kw:
           case continue_kw:
           case else_kw:
           case otherwise_kw:
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -377,39 +377,39 @@ static void yyerror (octave::base_parser
 %%
 
 // ==============================
 // Statements and statement lists
 // ==============================
 
 input           : simple_list '\n'
                   {
-                    $$ = 0;
+                    $$ = nullptr;
                     parser.m_stmt_list = $1;
                     YYACCEPT;
                   }
                 | simple_list END_OF_INPUT
                   {
-                    $$ = 0;
+                    $$ = nullptr;
                     lexer.end_of_input = true;
                     parser.m_stmt_list = $1;
                     YYACCEPT;
                   }
                 | parse_error
                   {
-                    $$ = 0;
+                    $$ = nullptr;
                     YYABORT;
                   }
                 ;
 
 simple_list     : opt_sep_no_nl
                   {
                     YYUSE ($1);
 
-                    $$ = 0;
+                    $$ = nullptr;
                   }
                 | simple_list1 opt_sep_no_nl
                   { $$ = parser.set_stmt_print_flag ($1, $2, false); }
                 ;
 
 simple_list1    : statement
                   { $$ = parser.make_statement_list ($1); }
                 | simple_list1 sep_no_nl statement
@@ -537,59 +537,59 @@ constant        : NUM
                   { $$ = $1; }
                 ;
 
 matrix          : '[' matrix_rows ']'
                   { $$ = parser.finish_matrix ($2); }
                 ;
 
 matrix_rows     : cell_or_matrix_row
-                  { $$ = $1 ? new octave::tree_matrix ($1) : 0; }
+                  { $$ = $1 ? new octave::tree_matrix ($1) : nullptr; }
                 | matrix_rows ';' cell_or_matrix_row
                   {
                     if ($1)
                       {
                         if ($3)
                           $1->append ($3);
 
                         $$ = $1;
                       }
                     else
-                      $$ = $3 ? new octave::tree_matrix ($3) : 0;
+                      $$ = $3 ? new octave::tree_matrix ($3) : nullptr;
                   }
                 ;
 
 cell            : '{' cell_rows '}'
                   { $$ = parser.finish_cell ($2); }
                 ;
 
 cell_rows       : cell_or_matrix_row
-                  { $$ = $1 ? new octave::tree_cell ($1) : 0; }
+                  { $$ = $1 ? new octave::tree_cell ($1) : nullptr; }
                 | cell_rows ';' cell_or_matrix_row
                   {
                     if ($1)
                       {
                         if ($3)
                           $1->append ($3);
 
                         $$ = $1;
                       }
                     else
-                      $$ = $3 ? new octave::tree_cell ($3) : 0;
+                      $$ = $3 ? new octave::tree_cell ($3) : nullptr;
                   }
                 ;
 
 // tree_argument_list objects can't be empty or have leading or trailing
 // commas, but those are all allowed in matrix and cell array rows.
 
 cell_or_matrix_row
                 : // empty
-                  { $$ = 0; }
+                  { $$ = nullptr; }
                 | ','
-                  { $$ = 0; }
+                  { $$ = nullptr; }
                 | arg_list
                   { $$ = $1; }
                 | arg_list ','
                   { $$ = $1; }
                 | ',' arg_list
                   { $$ = $2; }
                 | ',' arg_list ','
                   { $$ = $2; }
@@ -680,17 +680,17 @@ indirect_ref_op : '.'
 oper_expr       : primary_expr
                   { $$ = $1; }
                 | oper_expr PLUS_PLUS
                   { $$ = parser.make_postfix_op (PLUS_PLUS, $1, $2); }
                 | oper_expr MINUS_MINUS
                   { $$ = parser.make_postfix_op (MINUS_MINUS, $1, $2); }
                 | oper_expr '(' ')'
                   {
-                    $$ = parser.make_index_expression ($1, 0, '(');
+                    $$ = parser.make_index_expression ($1, nullptr, '(');
                     if (! $$)
                       {
                         // make_index_expression deleted $1.
                         YYABORT;
                       }
                   }
                 | oper_expr '(' arg_list ')'
                   {
@@ -698,17 +698,17 @@ oper_expr       : primary_expr
                     if (! $$)
                       {
                         // make_index_expression deleted $1 and $3.
                         YYABORT;
                       }
                   }
                 | oper_expr '{' '}'
                   {
-                    $$ = parser.make_index_expression ($1, 0, '{');
+                    $$ = parser.make_index_expression ($1, nullptr, '{');
                     if (! $$)
                       {
                         // make_index_expression deleted $1.
                         YYABORT;
                       }
                   }
                 | oper_expr '{' arg_list '}'
                   {
@@ -766,17 +766,17 @@ oper_expr       : primary_expr
 power_expr      : primary_expr
                   { $$ = $1; }
                 | power_expr PLUS_PLUS
                   { $$ = parser.make_postfix_op (PLUS_PLUS, $1, $2); }
                 | power_expr MINUS_MINUS
                   { $$ = parser.make_postfix_op (MINUS_MINUS, $1, $2); }
                 | power_expr '(' ')'
                   {
-                    $$ = parser.make_index_expression ($1, 0, '(');
+                    $$ = parser.make_index_expression ($1, nullptr, '(');
                     if (! $$)
                       {
                         // make_index_expression deleted $1.
                         YYABORT;
                       }
                   }
                 | power_expr '(' arg_list ')'
                   {
@@ -784,17 +784,17 @@ power_expr      : primary_expr
                     if (! $$)
                       {
                         // make_index_expression deleted $1 and $3.
                         YYABORT;
                       }
                   }
                 | power_expr '{' '}'
                   {
-                    $$ = parser.make_index_expression ($1, 0, '{');
+                    $$ = parser.make_index_expression ($1, nullptr, '{');
                     if (! $$)
                       {
                         // make_index_expression deleted $1.
                         YYABORT;
                       }
                   }
                 | power_expr '{' arg_list '}'
                   {
@@ -1154,42 +1154,42 @@ loop_command    : WHILE stash_comment ex
 
                     $$ = parser.make_do_until_command ($5, $4, $6, $2);
                   }
                 | FOR stash_comment assign_lhs '=' expression stmt_begin opt_sep opt_list END
                   {
                     YYUSE ($4);
                     YYUSE ($7);
 
-                    if (! ($$ = parser.make_for_command (FOR, $1, $3, $5, 0,
-                                                         $8, $9, $2)))
+                    if (! ($$ = parser.make_for_command (FOR, $1, $3, $5,
+                                                         nullptr, $8, $9, $2)))
                       {
                         // make_for_command deleted $3, $5, and $8.
                         YYABORT;
                       }
                   }
                 | FOR stash_comment '(' assign_lhs '=' expression ')' opt_sep opt_list END
                   {
                     YYUSE ($5);
                     YYUSE ($8);
 
-                    if (! ($$ = parser.make_for_command (FOR, $1, $4, $6, 0,
-                                                         $9, $10, $2)))
+                    if (! ($$ = parser.make_for_command (FOR, $1, $4, $6,
+                                                         nullptr, $9, $10, $2)))
                       {
                         // make_for_command deleted $4, $6, and $9.
                         YYABORT;
                       }
                   }
                 | PARFOR stash_comment assign_lhs '=' expression stmt_begin opt_sep opt_list END
                   {
                     YYUSE ($4);
                     YYUSE ($7);
 
                     if (! ($$ = parser.make_for_command (PARFOR, $1, $3, $5,
-                                                         0, $8, $9, $2)))
+                                                         nullptr, $8, $9, $2)))
                       {
                         // make_for_command deleted $3, $5, and $8.
                         YYABORT;
                       }
                   }
                 | PARFOR stash_comment '(' assign_lhs '=' expression ',' expression ')' opt_sep opt_list END
                   {
                     YYUSE ($5);
@@ -1248,17 +1248,18 @@ except_command  : UNWIND stash_comment o
                         // make_try_command deleted $4 and $8.
                         YYABORT;
                       }
                   }
                 | TRY stash_comment opt_sep opt_list END
                   {
                     YYUSE ($3);
 
-                    if (! ($$ = parser.make_try_command ($1, $4, 0, 0, $5, $2, 0)))
+                    if (! ($$ = parser.make_try_command ($1, $4, 0, nullptr,
+                                                         $5, $2, nullptr)))
                       {
                         // make_try_command deleted $4.
                         YYABORT;
                       }
                   }
                 ;
 
 // ===========================================
@@ -1315,38 +1316,38 @@ param_list_end  : ')'
                   {
                     $$ = 0;
                     lexer.looking_at_parameter_list = false;
                     lexer.looking_for_object_index = false;
                   }
                 ;
 
 opt_param_list  : // empty
-                  { $$ = 0; }
+                  { $$ = nullptr; }
                 | param_list
                   { $$ = $1; }
                 ;
 
 param_list      : param_list_beg param_list1 param_list_end
                   {
                     if ($2)
                       lexer.mark_as_variables ($2->variable_names ());
 
                     $$ = $2;
                   }
                 | param_list_beg error
                   {
-                    $$ = 0;
+                    $$ = nullptr;
                     parser.bison_error ("invalid parameter list");
                     YYABORT;
                   }
                 ;
 
 param_list1     : // empty
-                  { $$ = 0; }
+                  { $$ = nullptr; }
                 | param_list2
                   {
                     $1->mark_as_formal_parameters ();
 
                     if (parser.validate_param_list ($1, octave::tree_parameter_list::in))
                       {
                         lexer.mark_as_variables ($1->variable_names ());
                         $$ = $1;
@@ -1456,28 +1457,28 @@ file            : INPUT_FILE opt_nl opt_
                         octave::tree_statement *end_of_script
                           = parser.make_end ("endscript", true,
                                              lexer.input_line_number,
                                              lexer.current_input_column);
 
                         parser.make_script ($3, end_of_script);
                       }
 
-                    $$ = 0;
+                    $$ = nullptr;
                   }
                 | INPUT_FILE opt_nl classdef parsing_local_fcns opt_sep opt_fcn_list END_OF_INPUT
                   {
                     YYUSE ($2);
                     YYUSE ($5);
                     YYUSE ($6);
 
                     if (lexer.reading_classdef_file)
                       parser.m_classdef_object = $3;
 
-                    $$ = 0;
+                    $$ = nullptr;
                   }
                 ;
 
 // ===================
 // Function definition
 // ===================
 
 function_beg    : push_fcn_symtab FCN
@@ -1581,17 +1582,17 @@ function_end    : END
                   }
                 ;
 
 function        : function_beg stash_comment fcn_name
                   opt_param_list opt_sep opt_list function_end
                   {
                     YYUSE ($5);
 
-                    $$ = parser.make_function ($1, 0, $3, $4, $6, $7, $2);
+                    $$ = parser.make_function ($1, nullptr, $3, $4, $6, $7, $2);
                   }
                 | function_beg stash_comment return_list '=' fcn_name
                   opt_param_list opt_sep opt_list function_end
                   {
                     YYUSE ($4);
                     YYUSE ($7);
 
                     $$ = parser.make_function ($1, $3, $5, $6, $8, $9, $2);
@@ -1606,17 +1607,17 @@ classdef_beg    : CLASSDEF
                   {
                     if (! lexer.reading_classdef_file)
                       {
                         parser.bison_error ("classdef must appear inside a file containing only a class definition");
                         YYABORT;
                       }
 
                     // Create invalid parent scope.
-                    lexer.symtab_context.push (0);
+                    lexer.symtab_context.push (nullptr);
                     lexer.parsing_classdef = true;
                     $$ = $1;
                   }
                 ;
 
 classdef        : classdef_beg stash_comment opt_attr_list identifier opt_superclass_list opt_sep class_body opt_sep END
                   {
                     YYUSE ($6);
@@ -1631,26 +1632,27 @@ classdef        : classdef_beg stash_com
                       }
                   }
                 | classdef_beg stash_comment opt_attr_list identifier opt_superclass_list opt_sep END
                   {
                     YYUSE ($6);
 
                     lexer.parsing_classdef = false;
 
-                    if (! ($$ = parser.make_classdef ($1, $3, $4, $5, 0, $7, $2)))
+                    if (! ($$ = parser.make_classdef ($1, $3, $4, $5, nullptr,
+                                                      $7, $2)))
                       {
                         // make_classdef deleted $3, $4, and $5.
                         YYABORT;
                       }
                   }
                 ;
 
 opt_attr_list   : // empty
-                  { $$ = 0; }
+                  { $$ = nullptr; }
                 | '(' attr_list ')'
                   { $$ = $2; }
                 ;
 
 attr_list       : attr
                   { $$ = new octave::tree_classdef_attribute_list ($1); }
                 | attr_list ',' attr
                   {
@@ -1673,17 +1675,17 @@ attr            : identifier
                     YYUSE ($1);
 
                     $$ = new octave::tree_classdef_attribute ($2, false);
                   }
                 ;
 
 opt_superclass_list
                 : // empty
-                  { $$ = 0; }
+                  { $$ = nullptr; }
                 | superclass_list
                   { $$ = $1; }
                 ;
 
 superclass_list : EXPR_LT
                   {
                     YYUSE ($1);
 
@@ -1759,17 +1761,17 @@ properties_block
                         YYABORT;
                       }
                   }
                 | PROPERTIES stash_comment opt_attr_list opt_sep END
                   {
                     YYUSE ($4);
 
                     if (! ($$ = parser.make_classdef_properties_block
-                           ($1, $3, 0, $5, $2)))
+                           ($1, $3, nullptr, $5, $2)))
                       {
                         // make_classdef_properties_block delete $3.
                         YYABORT;
                       }
                   }
                 ;
 
 property_list
@@ -1807,39 +1809,39 @@ methods_block   : METHODS stash_comment 
                         YYABORT;
                       }
                   }
                 | METHODS stash_comment opt_attr_list opt_sep END
                   {
                     YYUSE ($4);
 
                     if (! ($$ = parser.make_classdef_methods_block
-                           ($1, $3, 0, $5, $2)))
+                           ($1, $3, nullptr, $5, $2)))
                       {
                         // make_classdef_methods_block deleted $3.
                         YYABORT;
                       }
                   }
                 ;
                 ;
 
 method_decl1    : identifier
                   {
-                    if (! ($$ = parser.start_classdef_external_method ($1, 0)))
+                    if (! ($$ = parser.start_classdef_external_method ($1, nullptr)))
                       YYABORT;
                   }
                 | identifier param_list
                   {
                     if (! ($$ = parser.start_classdef_external_method ($1, $2)))
                       YYABORT;
                   }
                 ;
 
 method_decl     : stash_comment method_decl1
-                  { $$ = parser.finish_classdef_external_method ($2, 0, $1); }
+                  { $$ = parser.finish_classdef_external_method ($2, nullptr, $1); }
                 | stash_comment return_list '='
                   {
                     YYUSE ($3);
 
                     lexer.defining_func++;
                     lexer.parsed_function_name.push (false);
                   }
                   method_decl1
@@ -1930,17 +1932,17 @@ enum_block      : ENUMERATION stash_comm
                         YYABORT;
                       }
                   }
                 | ENUMERATION stash_comment opt_attr_list opt_sep END
                   {
                     YYUSE ($4);
 
                     if (! ($$ = parser.make_classdef_enum_block
-                           ($1, $3, 0, $5, $2)))
+                           ($1, $3, nullptr, $5, $2)))
                       {
                         // make_classdef_enum_block deleted $3.
                         YYABORT;
                       }
                   }
                 ;
 
 enum_list       : class_enum
@@ -2115,17 +2117,17 @@ namespace octave
       m_info.back().second = name;
 
     return true;
   }
 
   symbol_table::scope *
   base_parser::parent_scope_info::parent_scope (void) const
   {
-    return size () > 1 ? m_info[size()-2].first : 0;
+    return size () > 1 ? m_info[size()-2].first : nullptr;
   }
 
   std::string
   base_parser::parent_scope_info::parent_name (void) const
   {
     return m_info[size()-2].second;
   }
 
@@ -2134,20 +2136,21 @@ namespace octave
     m_info.clear ();
     m_all_names.clear ();
   }
 
   base_parser::base_parser (base_lexer& lxr)
     : m_endfunction_found (false), m_autoloading (false),
       m_fcn_file_from_relative_lookup (false),
       m_parsing_subfunctions (false), m_parsing_local_functions (false),
-      m_max_fcn_depth (0), m_curr_fcn_depth (0), m_primary_fcn_scope (0),
+      m_max_fcn_depth (0), m_curr_fcn_depth (0), m_primary_fcn_scope (nullptr),
       m_curr_class_name (), m_curr_package_name (), m_function_scopes (),
-      m_primary_fcn_ptr (0), m_subfunction_names (), m_classdef_object (0),
-      m_stmt_list (0), m_lexer (lxr), m_parser_state (yypstate_new ())
+      m_primary_fcn_ptr (nullptr), m_subfunction_names (),
+      m_classdef_object (nullptr), m_stmt_list (nullptr), m_lexer (lxr),
+      m_parser_state (yypstate_new ())
   { }
 
   base_parser::~base_parser (void)
   {
     delete m_stmt_list;
 
     delete &m_lexer;
 
@@ -2167,25 +2170,27 @@ namespace octave
   {
     m_endfunction_found = false;
     m_autoloading = false;
     m_fcn_file_from_relative_lookup = false;
     m_parsing_subfunctions = false;
     m_parsing_local_functions = false;
     m_max_fcn_depth = 0;
     m_curr_fcn_depth = 0;
-    m_primary_fcn_scope = 0;
+    m_primary_fcn_scope = nullptr;
     m_curr_class_name = "";
     m_curr_package_name = "";
     m_function_scopes.clear ();
-    m_primary_fcn_ptr  = 0;
+    m_primary_fcn_ptr  = nullptr;
     m_subfunction_names.clear ();
+    // FIXME: What about m_classdef_object?  Shouldn't this be required?
+    // m_classdef_object = nullptr;
 
     delete m_stmt_list;
-    m_stmt_list = 0;
+    m_stmt_list = nullptr;
 
     m_lexer.reset ();
 
     yypstate_delete (static_cast<yypstate *> (m_parser_state));
     m_parser_state = yypstate_new ();
   }
 }
 
@@ -2326,17 +2331,17 @@ namespace octave
   // Make a constant.
 
   tree_constant *
   base_parser::make_constant (int op, token *tok_val)
   {
     int l = tok_val->line ();
     int c = tok_val->column ();
 
-    tree_constant *retval = 0;
+    tree_constant *retval = nullptr;
 
     switch (op)
       {
       case NUM:
         {
           octave_value tmp (tok_val->number ());
           retval = new tree_constant (tmp, l, c);
           retval->stash_original_text (tok_val->text_rep ());
@@ -2698,17 +2703,17 @@ namespace octave
   tree_command *
   base_parser::make_unwind_command (token *unwind_tok,
                                     tree_statement_list *body,
                                     tree_statement_list *cleanup_stmts,
                                     token *end_tok,
                                     comment_list *lc,
                                     comment_list *mc)
   {
-    tree_command *retval = 0;
+    tree_command *retval = nullptr;
 
     if (end_token_ok (end_tok, token::unwind_protect_end))
       {
         comment_list *tc = m_lexer.comment_buf.get_comment ();
 
         int l = unwind_tok->line ();
         int c = unwind_tok->column ();
 
@@ -2732,42 +2737,42 @@ namespace octave
   base_parser::make_try_command (token *try_tok,
                                  tree_statement_list *body,
                                  char catch_sep,
                                  tree_statement_list *cleanup_stmts,
                                  token *end_tok,
                                  comment_list *lc,
                                  comment_list *mc)
   {
-    tree_command *retval = 0;
+    tree_command *retval = nullptr;
 
     if (end_token_ok (end_tok, token::try_catch_end))
       {
         comment_list *tc = m_lexer.comment_buf.get_comment ();
 
         int l = try_tok->line ();
         int c = try_tok->column ();
 
-        tree_identifier *id = 0;
+        tree_identifier *id = nullptr;
 
         if (! catch_sep && cleanup_stmts && ! cleanup_stmts->empty ())
           {
             tree_statement *stmt = cleanup_stmts->front ();
 
             if (stmt)
               {
                 tree_expression *expr = stmt->expression ();
 
                 if (expr && expr->is_identifier ())
                   {
                     id = dynamic_cast<tree_identifier *> (expr);
 
                     cleanup_stmts->pop_front ();
 
-                    stmt->set_expression (0);
+                    stmt->set_expression (nullptr);
                     delete stmt;
                   }
               }
           }
 
         retval = new tree_try_catch_command (body, cleanup_stmts, id,
                                              lc, mc, tc, l, c);
       }
@@ -2843,17 +2848,17 @@ namespace octave
   base_parser::make_for_command (int tok_id, token *for_tok,
                                  tree_argument_list *lhs,
                                  tree_expression *expr,
                                  tree_expression *maxproc,
                                  tree_statement_list *body,
                                  token *end_tok,
                                  comment_list *lc)
   {
-    tree_command *retval = 0;
+    tree_command *retval = nullptr;
 
     bool parfor = tok_id == PARFOR;
 
     if (end_token_ok (end_tok, parfor ? token::parfor_end : token::for_end))
       {
         expr->mark_as_for_cmd_expr ();
 
         comment_list *tc = m_lexer.comment_buf.get_comment ();
@@ -2907,17 +2912,17 @@ namespace octave
   base_parser::make_break_command (token *break_tok)
   {
     int l = break_tok->line ();
     int c = break_tok->column ();
 
     if (! m_lexer.looping)
       {
         bison_error ("break must appear in a loop in the same file as loop command");
-        return 0;
+        return nullptr;
       }
     else
       return new tree_break_command (l, c);
   }
 
   // Build a continue command.
 
   tree_command *
@@ -2956,17 +2961,17 @@ namespace octave
   // Finish an if command.
 
   tree_if_command *
   base_parser::finish_if_command (token *if_tok,
                                   tree_if_command_list *list,
                                   token *end_tok,
                                   comment_list *lc)
   {
-    tree_if_command *retval = 0;
+    tree_if_command *retval = nullptr;
 
     if (end_token_ok (end_tok, token::if_end))
       {
         comment_list *tc = m_lexer.comment_buf.get_comment ();
 
         int l = if_tok->line ();
         int c = if_tok->column ();
 
@@ -3013,17 +3018,17 @@ namespace octave
 
   tree_switch_command *
   base_parser::finish_switch_command (token *switch_tok,
                                       tree_expression *expr,
                                       tree_switch_case_list *list,
                                       token *end_tok,
                                       comment_list *lc)
   {
-    tree_switch_command *retval = 0;
+    tree_switch_command *retval = nullptr;
 
     if (end_token_ok (end_tok, token::switch_end))
       {
         comment_list *tc = m_lexer.comment_buf.get_comment ();
 
         int l = switch_tok->line ();
         int c = switch_tok->column ();
 
@@ -3142,17 +3147,17 @@ namespace octave
         // Multiple assignments like [x,y] OP= rhs are only valid for
         // '=', not '+=', etc.
 
         delete lhs;
         delete rhs;
 
         bison_error ("computed multiple assignment not allowed", l, c);
 
-        return 0;
+        return nullptr;
       }
 
     if (lhs->is_simple_assign_lhs ())
       {
         // We are looking at a simple assignment statement like x = rhs;
 
         tree_expression *tmp = lhs->remove_front ();
 
@@ -3162,17 +3167,17 @@ namespace octave
             std::string kw = tmp->name ();
 
             delete tmp;
             delete lhs;
             delete rhs;
 
             bison_error ("invalid assignment to keyword \"" + kw + "\"", l, c);
 
-            return 0;
+            return nullptr;
           }
 
         delete lhs;
 
         return new tree_simple_assignment (tmp, rhs, false, l, c, t);
       }
     else
       {
@@ -3183,17 +3188,17 @@ namespace octave
             if (is_keyword (kw))
               {
                 delete lhs;
                 delete rhs;
 
                 bison_error ("invalid assignment to keyword \"" + kw + "\"",
                              l, c);
 
-                return 0;
+                return nullptr;
               }
           }
 
         return new tree_multi_assignment (lhs, rhs, false, l, c);
       }
   }
 
   // Define a script.
@@ -3231,17 +3236,17 @@ namespace octave
   base_parser::make_function (token *fcn_tok,
                               tree_parameter_list *ret_list,
                               tree_identifier *id,
                               tree_parameter_list *param_list,
                               tree_statement_list *body,
                               tree_statement *end_fcn_stmt,
                               comment_list *lc)
   {
-    tree_function_def *retval = 0;
+    tree_function_def *retval = nullptr;
 
     int l = fcn_tok->line ();
     int c = fcn_tok->column ();
 
     octave_user_function *tmp_fcn
       = start_function (id, param_list, body, end_fcn_stmt);
 
     retval = finish_function (ret_list, tmp_fcn, lc, l, c);
@@ -3275,17 +3280,17 @@ namespace octave
 
     if (! body)
       body = new tree_statement_list ();
 
     body->append (end_fcn_stmt);
 
     octave_user_function *fcn
       = new octave_user_function (m_lexer.symtab_context.curr_scope (),
-                                  param_list, 0, body);
+                                  param_list, nullptr, body);
 
     if (fcn)
       {
         comment_list *tc = m_lexer.comment_buf.get_comment ();
 
         fcn->stash_trailing_comment (tc);
         fcn->stash_fcn_end_location (end_fcn_stmt->line (),
                                      end_fcn_stmt->column ());
@@ -3394,17 +3399,17 @@ namespace octave
   }
 
   tree_function_def *
   base_parser::finish_function (tree_parameter_list *ret_list,
                                 octave_user_function *fcn,
                                 comment_list *lc,
                                 int l, int c)
   {
-    tree_function_def *retval = 0;
+    tree_function_def *retval = nullptr;
 
     if (ret_list)
       ret_list->mark_as_formal_parameters ();
 
     if (fcn)
       {
         std::string nm = fcn->name ();
         std::string file = fcn->fcn_file_name ();
@@ -3538,17 +3543,17 @@ namespace octave
   tree_classdef *
   base_parser::make_classdef (token *tok_val,
                               tree_classdef_attribute_list *a,
                               tree_identifier *id,
                               tree_classdef_superclass_list *sc,
                               tree_classdef_body *body, token *end_tok,
                               comment_list *lc)
   {
-    tree_classdef *retval = 0;
+    tree_classdef *retval = nullptr;
 
     m_lexer.symtab_context.pop ();
 
     std::string cls_name = id->name ();
 
     std::string nm = m_lexer.fcn_file_name;
 
     size_t pos = nm.find_last_of (sys::file_ops::dir_sep_chars ());
@@ -3597,17 +3602,17 @@ namespace octave
 
   tree_classdef_properties_block *
   base_parser::make_classdef_properties_block (token *tok_val,
                                                tree_classdef_attribute_list *a,
                                                tree_classdef_property_list *plist,
                                                token *end_tok,
                                                comment_list *lc)
   {
-    tree_classdef_properties_block *retval = 0;
+    tree_classdef_properties_block *retval = nullptr;
 
     if (end_token_ok (end_tok, token::properties_end))
       {
         comment_list *tc = m_lexer.comment_buf.get_comment ();
 
         int l = tok_val->line ();
         int c = tok_val->column ();
 
@@ -3629,17 +3634,17 @@ namespace octave
 
   tree_classdef_methods_block *
   base_parser::make_classdef_methods_block (token *tok_val,
                                             tree_classdef_attribute_list *a,
                                             tree_classdef_methods_list *mlist,
                                             token *end_tok,
                                             comment_list *lc)
   {
-    tree_classdef_methods_block *retval = 0;
+    tree_classdef_methods_block *retval = nullptr;
 
     if (end_token_ok (end_tok, token::methods_end))
       {
         comment_list *tc = m_lexer.comment_buf.get_comment ();
 
         int l = tok_val->line ();
         int c = tok_val->column ();
 
@@ -3661,17 +3666,17 @@ namespace octave
 
   tree_classdef_events_block *
   base_parser::make_classdef_events_block (token *tok_val,
                                            tree_classdef_attribute_list *a,
                                            tree_classdef_events_list *elist,
                                            token *end_tok,
                                            comment_list *lc)
   {
-    tree_classdef_events_block *retval = 0;
+    tree_classdef_events_block *retval = nullptr;
 
     if (end_token_ok (end_tok, token::events_end))
       {
         comment_list *tc = m_lexer.comment_buf.get_comment ();
 
         int l = tok_val->line ();
         int c = tok_val->column ();
 
@@ -3693,17 +3698,17 @@ namespace octave
 
   tree_classdef_enum_block *
   base_parser::make_classdef_enum_block (token *tok_val,
                                          tree_classdef_attribute_list *a,
                                          tree_classdef_enum_list *elist,
                                          token *end_tok,
                                          comment_list *lc)
   {
-    tree_classdef_enum_block *retval = 0;
+    tree_classdef_enum_block *retval = nullptr;
 
     if (end_token_ok (end_tok, token::enumeration_end))
       {
         comment_list *tc = m_lexer.comment_buf.get_comment ();
 
         int l = tok_val->line ();
         int c = tok_val->column ();
 
@@ -3722,17 +3727,17 @@ namespace octave
 
     return retval;
   }
 
   octave_user_function*
   base_parser::start_classdef_external_method (tree_identifier *id,
                                                tree_parameter_list *pl)
   {
-    octave_user_function* retval = 0;
+    octave_user_function* retval = nullptr;
 
     // External methods are only allowed within @-folders. In this case,
     // m_curr_class_name will be non-empty.
 
     if (! m_curr_class_name.empty ())
       {
 
         std::string mname = id->name ();
@@ -3744,17 +3749,17 @@ namespace octave
 
         if (mname.find_first_of (".") == std::string::npos
             && mname != "delete"
             && mname != m_curr_class_name)
           {
             // Create a dummy function that is used until the real method
             // is loaded.
 
-            retval = new octave_user_function (0, pl);
+            retval = new octave_user_function (nullptr, pl);
 
             retval->stash_function_name (mname);
 
             int l = id->line ();
             int c = id->column ();
 
             retval->stash_fcn_location (l, c);
           }
@@ -3791,17 +3796,17 @@ namespace octave
 
   // Make an index expression.
 
   tree_index_expression *
   base_parser::make_index_expression (tree_expression *expr,
                                       tree_argument_list *args,
                                       char type)
   {
-    tree_index_expression *retval = 0;
+    tree_index_expression *retval = nullptr;
 
     if (args && args->has_magic_tilde ())
       {
         delete expr;
         delete args;
 
         bison_error ("invalid use of empty argument (~) in index expression");
       }
@@ -3830,17 +3835,17 @@ namespace octave
   }
 
   // Make an indirect reference expression.
 
   tree_index_expression *
   base_parser::make_indirect_ref (tree_expression *expr,
                                   const std::string& elt)
   {
-    tree_index_expression *retval = 0;
+    tree_index_expression *retval = nullptr;
 
     int l = expr->line ();
     int c = expr->column ();
 
     if (! expr->is_postfix_indexed ())
       expr->set_postfix_index ('.');
 
     if (expr->is_index_expression ())
@@ -3860,17 +3865,17 @@ namespace octave
   }
 
   // Make an indirect reference expression with dynamic field name.
 
   tree_index_expression *
   base_parser::make_indirect_ref (tree_expression *expr,
                                   tree_expression *elt)
   {
-    tree_index_expression *retval = 0;
+    tree_index_expression *retval = nullptr;
 
     int l = expr->line ();
     int c = expr->column ();
 
     if (! expr->is_postfix_indexed ())
       expr->set_postfix_index ('.');
 
     if (expr->is_index_expression ())
@@ -3890,17 +3895,17 @@ namespace octave
   }
 
   // Make a declaration command.
 
   tree_decl_command *
   base_parser::make_decl_command (int tok, token *tok_val,
                                   tree_decl_init_list *lst)
   {
-    tree_decl_command *retval = 0;
+    tree_decl_command *retval = nullptr;
 
     int l = tok_val->line ();
     int c = tok_val->column ();
 
     switch (tok)
       {
       case GLOBAL:
         {
@@ -4017,17 +4022,17 @@ namespace octave
       }
 
     return retval;
   }
 
   tree_argument_list *
   base_parser::validate_matrix_for_assignment (tree_expression *e)
   {
-    tree_argument_list *retval = 0;
+    tree_argument_list *retval = nullptr;
 
     if (e->is_constant ())
       {
         tree_evaluator& tw
           = __get_evaluator__ ("validate_matrix_for_assignment");
 
         octave_value ov = tw.evaluate (e);
 
@@ -4037,17 +4042,17 @@ namespace octave
           bison_error ("invalid empty left hand side of assignment");
         else
           bison_error ("invalid constant left hand side of assignment");
       }
     else
       {
         bool is_simple_assign = true;
 
-        tree_argument_list *tmp = 0;
+        tree_argument_list *tmp = nullptr;
 
         if (e->is_matrix ())
           {
             tree_matrix *mat = dynamic_cast<tree_matrix *> (e);
 
             if (mat && mat->size () == 1)
               {
                 tmp = mat->front ();
@@ -4398,30 +4403,30 @@ parse_fcn_file (const std::string& full_
                 const std::string& package_name, bool require_file,
                 bool force_script, bool autoload, bool relative_lookup,
                 const std::string& warn_for)
 {
   octave_value retval;
 
   octave::unwind_protect frame;
 
-  octave_function *fcn_ptr = 0;
+  octave_function *fcn_ptr = nullptr;
 
   // Open function file and parse.
 
   FILE *in_stream = octave::command_editor::get_input_stream ();
 
   frame.add_fcn (octave::command_editor::set_input_stream, in_stream);
 
   frame.add_fcn (octave::command_history::ignore_entries,
                  octave::command_history::ignoring_entries ());
 
   octave::command_history::ignore_entries ();
 
-  FILE *ffile = 0;
+  FILE *ffile = nullptr;
 
   if (! full_file.empty ())
     ffile = std::fopen (full_file.c_str (), "rb");
 
   if (ffile)
     {
       frame.add_fcn (safe_fclose, ffile);
 
@@ -4464,17 +4469,17 @@ parse_fcn_file (const std::string& full_
 
               fcn_ptr
                 = parser.m_classdef_object->make_meta_class (interp, is_at_folder);
               if (fcn_ptr)
                 retval = octave_value (fcn_ptr);
 
               delete (parser.m_classdef_object);
 
-              parser.m_classdef_object = 0;
+              parser.m_classdef_object = nullptr;
             }
           else if (fcn_ptr)
             {
               retval = octave_value (fcn_ptr);
 
               fcn_ptr->maybe_relocate_end ();
 
               if (parser.m_parsing_subfunctions)
@@ -5284,17 +5289,17 @@ namespace octave
         parser.reset ();
 
         parse_status = parser.run ();
 
         if (parse_status == 0)
           {
             if (parser.m_stmt_list)
               {
-                tree_statement *stmt = 0;
+                tree_statement *stmt = nullptr;
 
                 tree_evaluator& tw = __get_evaluator__ ("eval_string");
 
                 if (parser.m_stmt_list->length () == 1
                     && (stmt = parser.m_stmt_list->front ())
                     && stmt->is_expression ())
                   {
                     tree_expression *expr = stmt->expression ();
@@ -5364,17 +5369,17 @@ namespace octave
   }
 
   void
   cleanup_statement_list (tree_statement_list **lst)
   {
     if (*lst)
       {
         delete *lst;
-        *lst = 0;
+        *lst = nullptr;
       }
   }
 }
 
 DEFUN (eval, args, nargout,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {} eval (@var{try})
 @deftypefnx {} {} eval (@var{try}, @var{catch})
diff --git a/libinterp/parse-tree/pt-loop.h b/libinterp/parse-tree/pt-loop.h
--- a/libinterp/parse-tree/pt-loop.h
+++ b/libinterp/parse-tree/pt-loop.h
@@ -168,18 +168,19 @@ namespace octave
 
   // For.
 
   class tree_simple_for_command : public tree_command
   {
   public:
 
     tree_simple_for_command (int l = -1, int c = -1)
-      : tree_command (l, c), parallel (false), lhs (0), expr (0),
-        maxproc (0), list (nullptr), lead_comm (nullptr), trail_comm (nullptr)
+      : tree_command (l, c), parallel (false), lhs (nullptr), expr (nullptr),
+        maxproc (nullptr), list (nullptr), lead_comm (nullptr),
+        trail_comm (nullptr)
 #if defined (HAVE_LLVM)
       , compiled (nullptr)
 #endif
     { }
 
     tree_simple_for_command (bool parallel_arg, tree_expression *le,
                              tree_expression *re,
                              tree_expression *maxproc_arg,
diff --git a/liboctave/array/Array.cc b/liboctave/array/Array.cc
--- a/liboctave/array/Array.cc
+++ b/liboctave/array/Array.cc
@@ -2020,17 +2020,17 @@ typename Array<T>::compare_fcn_type
 safe_comparator (sortmode mode, const Array<T>& /* a */,
                  bool /* allow_chk */)
 {
   if (mode == ASCENDING)
     return octave_sort<T>::ascending_compare;
   else if (mode == DESCENDING)
     return octave_sort<T>::descending_compare;
   else
-    return 0;
+    return nullptr;
 }
 
 template <typename T>
 sortmode
 Array<T>::issorted (sortmode mode) const
 {
   octave_sort<T> lsort;
 
@@ -2482,17 +2482,17 @@ Array<T>::nth_element (const idx_vector&
   template <> sortmode                                                  \
   Array<T>::issorted (sortmode) const                                  \
   {                                                                     \
     return UNSORTED;                                                    \
   }                                                                     \
   Array<T>::compare_fcn_type                                            \
   safe_comparator (sortmode, const Array<T>&, bool)                     \
   {                                                                     \
-    return 0;                                                           \
+    return nullptr;                                                     \
   }                                                                     \
   template <> Array<octave_idx_type>                                    \
   Array<T>::sort_rows_idx (sortmode) const                              \
   {                                                                     \
     return Array<octave_idx_type> ();                                   \
   }                                                                     \
   template <> sortmode                                                  \
   Array<T>::is_sorted_rows (sortmode) const                             \
diff --git a/liboctave/array/CSparse.cc b/liboctave/array/CSparse.cc
--- a/liboctave/array/CSparse.cc
+++ b/liboctave/array/CSparse.cc
@@ -1111,26 +1111,26 @@ SparseComplexMatrix::determinant (octave
       const octave_idx_type *Ap = cidx ();
       const octave_idx_type *Ai = ridx ();
       const Complex *Ax = data ();
 
       UMFPACK_ZNAME (report_matrix) (nr, nc,
                                      octave::to_suitesparse_intptr (Ap),
                                      octave::to_suitesparse_intptr (Ai),
                                      reinterpret_cast<const double *> (Ax),
-                                     0, 1, control);
+                                     nullptr, 1, control);
 
       void *Symbolic;
       Matrix Info (1, UMFPACK_INFO);
       double *info = Info.fortran_vec ();
       int status = UMFPACK_ZNAME (qsymbolic) (nr, nc,
                                               octave::to_suitesparse_intptr (Ap),
                                               octave::to_suitesparse_intptr (Ai),
                                               reinterpret_cast<const double *> (Ax),
-                                              0, 0, &Symbolic, control, info);
+                                              nullptr, nullptr, &Symbolic, control, info);
 
       if (status < 0)
         {
           UMFPACK_ZNAME (report_status) (control, status);
           UMFPACK_ZNAME (report_info) (control, info);
 
           UMFPACK_ZNAME (free_symbolic) (&Symbolic);
 
@@ -1141,17 +1141,17 @@ SparseComplexMatrix::determinant (octave
         {
           UMFPACK_ZNAME (report_symbolic) (Symbolic, control);
 
           void *Numeric;
           status
             = UMFPACK_ZNAME (numeric) (octave::to_suitesparse_intptr (Ap),
                                        octave::to_suitesparse_intptr (Ai),
                                        reinterpret_cast<const double *> (Ax),
-                                       0, Symbolic, &Numeric, control, info);
+                                       nullptr, Symbolic, &Numeric, control, info);
           UMFPACK_ZNAME (free_symbolic) (&Symbolic);
 
           rcond = Info (UMFPACK_RCOND);
 
           if (status < 0)
             {
               UMFPACK_ZNAME (report_status) (control, status);
               UMFPACK_ZNAME (report_info) (control, info);
@@ -1162,17 +1162,17 @@ SparseComplexMatrix::determinant (octave
                 ("SparseComplexMatrix::determinant numeric factorization failed");
             }
           else
             {
               UMFPACK_ZNAME (report_numeric) (Numeric, control);
 
               double c10[2], e10;
 
-              status = UMFPACK_ZNAME (get_determinant) (c10, 0, &e10,
+              status = UMFPACK_ZNAME (get_determinant) (c10, nullptr, &e10,
                                                         Numeric, info);
 
               if (status < 0)
                 {
                   UMFPACK_ZNAME (report_status) (control, status);
                   UMFPACK_ZNAME (report_info) (control, info);
 
                   (*current_liboctave_error_handler)
@@ -5549,26 +5549,26 @@ SparseComplexMatrix::factorize (octave_i
   const Complex *Ax = data ();
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   UMFPACK_ZNAME (report_matrix) (nr, nc,
                                  octave::to_suitesparse_intptr (Ap),
                                  octave::to_suitesparse_intptr (Ai),
                                  reinterpret_cast<const double *> (Ax),
-                                 0, 1, control);
+                                 nullptr, 1, control);
 
   void *Symbolic;
   Info = Matrix (1, UMFPACK_INFO);
   double *info = Info.fortran_vec ();
   int status = UMFPACK_ZNAME (qsymbolic) (nr, nc,
                                           octave::to_suitesparse_intptr (Ap),
                                           octave::to_suitesparse_intptr (Ai),
                                           reinterpret_cast<const double *> (Ax),
-                                          0, 0, &Symbolic, control, info);
+                                          nullptr, nullptr, &Symbolic, control, info);
 
   if (status < 0)
     {
       UMFPACK_ZNAME (report_status) (control, status);
       UMFPACK_ZNAME (report_info) (control, info);
 
       UMFPACK_ZNAME (free_symbolic) (&Symbolic);
 
@@ -5579,17 +5579,17 @@ SparseComplexMatrix::factorize (octave_i
     }
   else
     {
       UMFPACK_ZNAME (report_symbolic) (Symbolic, control);
 
       status = UMFPACK_ZNAME (numeric) (octave::to_suitesparse_intptr (Ap),
                                         octave::to_suitesparse_intptr (Ai),
                                         reinterpret_cast<const double *> (Ax),
-                                        0, Symbolic, &Numeric, control, info);
+                                        nullptr, Symbolic, &Numeric, control, info);
       UMFPACK_ZNAME (free_symbolic) (&Symbolic);
 
       if (calc_cond)
         rcond = Info (UMFPACK_RCOND);
       else
         rcond = 1.;
       volatile double rcond_plus_one = rcond + 1.0;
 
@@ -5699,17 +5699,17 @@ SparseComplexMatrix::fsolve (MatrixType&
           A->nrow = nr;
           A->ncol = nc;
 
           A->p = cidx ();
           A->i = ridx ();
           A->nzmax = nnz ();
           A->packed = true;
           A->sorted = true;
-          A->nz = 0;
+          A->nz = nullptr;
 #if defined (OCTAVE_ENABLE_64)
           A->itype = CHOLMOD_LONG;
 #else
           A->itype = CHOLMOD_INT;
 #endif
           A->dtype = CHOLMOD_DOUBLE;
           A->stype = 1;
           A->xtype = CHOLMOD_COMPLEX;
@@ -5830,19 +5830,19 @@ SparseComplexMatrix::fsolve (MatrixType&
 
               for (octave_idx_type j = 0, iidx = 0; j < b_nc; j++, iidx += b_nr)
                 {
 #if defined (UMFPACK_SEPARATE_SPLIT)
                   status = UMFPACK_ZNAME (solve) (UMFPACK_A,
                                                   octave::to_suitesparse_intptr (Ap),
                                                   octave::to_suitesparse_intptr (Ai),
                                                   reinterpret_cast<const double *> (Ax),
-                                                  0,
+                                                  nullptr,
                                                   reinterpret_cast<double *> (&Xx[iidx]),
-                                                  0,
+                                                  nullptr,
                                                   &Bx[iidx], Bz, Numeric,
                                                   control, info);
 #else
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     Bz[i] = b.elem (i, j);
 
                   status = UMFPACK_ZNAME (solve) (UMFPACK_A,
                                                   octave::to_suitesparse_intptr (Ap),
@@ -5951,17 +5951,17 @@ SparseComplexMatrix::fsolve (MatrixType&
           A->nrow = nr;
           A->ncol = nc;
 
           A->p = cidx ();
           A->i = ridx ();
           A->nzmax = nnz ();
           A->packed = true;
           A->sorted = true;
-          A->nz = 0;
+          A->nz = nullptr;
 #if defined (OCTAVE_ENABLE_64)
           A->itype = CHOLMOD_LONG;
 #else
           A->itype = CHOLMOD_INT;
 #endif
           A->dtype = CHOLMOD_DOUBLE;
           A->stype = 1;
           A->xtype = CHOLMOD_COMPLEX;
@@ -5975,17 +5975,17 @@ SparseComplexMatrix::fsolve (MatrixType&
           cholmod_sparse *B = &Bstore;
           B->nrow = b.rows ();
           B->ncol = b.cols ();
           B->p = b.cidx ();
           B->i = b.ridx ();
           B->nzmax = b.nnz ();
           B->packed = true;
           B->sorted = true;
-          B->nz = 0;
+          B->nz = nullptr;
 #if defined (OCTAVE_ENABLE_64)
           B->itype = CHOLMOD_LONG;
 #else
           B->itype = CHOLMOD_INT;
 #endif
           B->dtype = CHOLMOD_DOUBLE;
           B->stype = 0;
           B->xtype = CHOLMOD_REAL;
@@ -6110,19 +6110,19 @@ SparseComplexMatrix::fsolve (MatrixType&
 #if defined (UMFPACK_SEPARATE_SPLIT)
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     Bx[i] = b.elem (i, j);
 
                   status = UMFPACK_ZNAME (solve) (UMFPACK_A,
                                                   octave::to_suitesparse_intptr (Ap),
                                                   octave::to_suitesparse_intptr (Ai),
                                                   reinterpret_cast<const double *> (Ax),
-                                                  0,
+                                                  nullptr,
                                                   reinterpret_cast<double *> (Xx),
-                                                  0,
+                                                  nullptr,
                                                   Bx, Bz, Numeric, control,
                                                   info);
 #else
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     Bz[i] = b.elem (i, j);
 
                   status = UMFPACK_ZNAME (solve) (UMFPACK_A,
                                                   octave::to_suitesparse_intptr (Ap),
@@ -6252,17 +6252,17 @@ SparseComplexMatrix::fsolve (MatrixType&
           A->nrow = nr;
           A->ncol = nc;
 
           A->p = cidx ();
           A->i = ridx ();
           A->nzmax = nnz ();
           A->packed = true;
           A->sorted = true;
-          A->nz = 0;
+          A->nz = nullptr;
 #if defined (OCTAVE_ENABLE_64)
           A->itype = CHOLMOD_LONG;
 #else
           A->itype = CHOLMOD_INT;
 #endif
           A->dtype = CHOLMOD_DOUBLE;
           A->stype = 1;
           A->xtype = CHOLMOD_COMPLEX;
@@ -6377,21 +6377,21 @@ SparseComplexMatrix::fsolve (MatrixType&
 
               for (octave_idx_type j = 0, iidx = 0; j < b_nc; j++, iidx += b_nr)
                 {
                   status =
                     UMFPACK_ZNAME (solve) (UMFPACK_A,
                                            octave::to_suitesparse_intptr (Ap),
                                            octave::to_suitesparse_intptr (Ai),
                                            reinterpret_cast<const double *> (Ax),
-                                           0,
+                                           nullptr,
                                            reinterpret_cast<double *> (&Xx[iidx]),
-                                           0,
+                                           nullptr,
                                            reinterpret_cast<const double *> (&Bx[iidx]),
-                                           0, Numeric, control, info);
+                                           nullptr, Numeric, control, info);
 
                   if (status < 0)
                     {
                       UMFPACK_ZNAME (report_status) (control, status);
 
                       // FIXME: Should this be a warning?
                       (*current_liboctave_error_handler)
                         ("SparseComplexMatrix::solve solve failed");
@@ -6483,17 +6483,17 @@ SparseComplexMatrix::fsolve (MatrixType&
           A->nrow = nr;
           A->ncol = nc;
 
           A->p = cidx ();
           A->i = ridx ();
           A->nzmax = nnz ();
           A->packed = true;
           A->sorted = true;
-          A->nz = 0;
+          A->nz = nullptr;
 #if defined (OCTAVE_ENABLE_64)
           A->itype = CHOLMOD_LONG;
 #else
           A->itype = CHOLMOD_INT;
 #endif
           A->dtype = CHOLMOD_DOUBLE;
           A->stype = 1;
           A->xtype = CHOLMOD_COMPLEX;
@@ -6507,17 +6507,17 @@ SparseComplexMatrix::fsolve (MatrixType&
           cholmod_sparse *B = &Bstore;
           B->nrow = b.rows ();
           B->ncol = b.cols ();
           B->p = b.cidx ();
           B->i = b.ridx ();
           B->nzmax = b.nnz ();
           B->packed = true;
           B->sorted = true;
-          B->nz = 0;
+          B->nz = nullptr;
 #if defined (OCTAVE_ENABLE_64)
           B->itype = CHOLMOD_LONG;
 #else
           B->itype = CHOLMOD_INT;
 #endif
           B->dtype = CHOLMOD_DOUBLE;
           B->stype = 0;
           B->xtype = CHOLMOD_COMPLEX;
@@ -6633,21 +6633,21 @@ SparseComplexMatrix::fsolve (MatrixType&
                 {
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     Bx[i] = b(i,j);
 
                   status = UMFPACK_ZNAME (solve) (UMFPACK_A,
                                                   octave::to_suitesparse_intptr (Ap),
                                                   octave::to_suitesparse_intptr (Ai),
                                                   reinterpret_cast<const double *> (Ax),
-                                                  0,
+                                                  nullptr,
                                                   reinterpret_cast<double *> (Xx),
-                                                  0,
+                                                  nullptr,
                                                   reinterpret_cast<double *> (Bx),
-                                                  0, Numeric, control, info);
+                                                  nullptr, Numeric, control, info);
 
                   if (status < 0)
                     {
                       UMFPACK_ZNAME (report_status) (control, status);
 
                       // FIXME: Should this be a warning?
                       (*current_liboctave_error_handler)
                         ("SparseComplexMatrix::solve solve failed");
@@ -6716,32 +6716,32 @@ SparseComplexMatrix::fsolve (MatrixType&
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (MatrixType& mattype, const Matrix& b) const
 {
   octave_idx_type info;
   double rcond;
-  return solve (mattype, b, info, rcond, 0);
+  return solve (mattype, b, info, rcond, nullptr);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (MatrixType& mattype, const Matrix& b,
                             octave_idx_type& info) const
 {
   double rcond;
-  return solve (mattype, b, info, rcond, 0);
+  return solve (mattype, b, info, rcond, nullptr);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (MatrixType& mattype, const Matrix& b,
                             octave_idx_type& info, double& rcond) const
 {
-  return solve (mattype, b, info, rcond, 0);
+  return solve (mattype, b, info, rcond, nullptr);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (MatrixType& mattype, const Matrix& b,
                             octave_idx_type& err, double& rcond,
                             solve_singularity_handler sing_handler,
                             bool singular_fallback) const
 {
@@ -6781,32 +6781,32 @@ SparseComplexMatrix::solve (MatrixType& 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (MatrixType& mattype, const SparseMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
-  return solve (mattype, b, info, rcond, 0);
+  return solve (mattype, b, info, rcond, nullptr);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (MatrixType& mattype, const SparseMatrix& b,
                             octave_idx_type& info) const
 {
   double rcond;
-  return solve (mattype, b, info, rcond, 0);
+  return solve (mattype, b, info, rcond, nullptr);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (MatrixType& mattype, const SparseMatrix& b,
                             octave_idx_type& info, double& rcond) const
 {
-  return solve (mattype, b, info, rcond, 0);
+  return solve (mattype, b, info, rcond, nullptr);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (MatrixType& mattype, const SparseMatrix& b,
                             octave_idx_type& err, double& rcond,
                             solve_singularity_handler sing_handler,
                             bool singular_fallback) const
 {
@@ -6846,32 +6846,32 @@ SparseComplexMatrix::solve (MatrixType& 
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (MatrixType& mattype, const ComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
-  return solve (mattype, b, info, rcond, 0);
+  return solve (mattype, b, info, rcond, nullptr);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (MatrixType& mattype, const ComplexMatrix& b,
                             octave_idx_type& info) const
 {
   double rcond;
-  return solve (mattype, b, info, rcond, 0);
+  return solve (mattype, b, info, rcond, nullptr);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (MatrixType& mattype, const ComplexMatrix& b,
                             octave_idx_type& info, double& rcond) const
 {
-  return solve (mattype, b, info, rcond, 0);
+  return solve (mattype, b, info, rcond, nullptr);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (MatrixType& mattype, const ComplexMatrix& b,
                             octave_idx_type& err, double& rcond,
                             solve_singularity_handler sing_handler,
                             bool singular_fallback) const
 {
@@ -6912,32 +6912,32 @@ SparseComplexMatrix::solve (MatrixType& 
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (MatrixType& mattype,
                             const SparseComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
-  return solve (mattype, b, info, rcond, 0);
+  return solve (mattype, b, info, rcond, nullptr);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (MatrixType& mattype, const SparseComplexMatrix& b,
                             octave_idx_type& info) const
 {
   double rcond;
-  return solve (mattype, b, info, rcond, 0);
+  return solve (mattype, b, info, rcond, nullptr);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (MatrixType& mattype, const SparseComplexMatrix& b,
                             octave_idx_type& info, double& rcond) const
 {
-  return solve (mattype, b, info, rcond, 0);
+  return solve (mattype, b, info, rcond, nullptr);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (MatrixType& mattype, const SparseComplexMatrix& b,
                             octave_idx_type& err, double& rcond,
                             solve_singularity_handler sing_handler,
                             bool singular_fallback) const
 {
@@ -6991,17 +6991,17 @@ SparseComplexMatrix::solve (MatrixType& 
   double rcond;
   return solve (mattype, b, info, rcond);
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (MatrixType& mattype, const ColumnVector& b,
                             octave_idx_type& info, double& rcond) const
 {
-  return solve (mattype, b, info, rcond, 0);
+  return solve (mattype, b, info, rcond, nullptr);
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (MatrixType& mattype, const ColumnVector& b,
                             octave_idx_type& info, double& rcond,
                             solve_singularity_handler sing_handler) const
 {
   Matrix tmp (b);
@@ -7010,32 +7010,32 @@ SparseComplexMatrix::solve (MatrixType& 
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (MatrixType& mattype,
                             const ComplexColumnVector& b) const
 {
   octave_idx_type info;
   double rcond;
-  return solve (mattype, b, info, rcond, 0);
+  return solve (mattype, b, info, rcond, nullptr);
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (MatrixType& mattype, const ComplexColumnVector& b,
                             octave_idx_type& info) const
 {
   double rcond;
-  return solve (mattype, b, info, rcond, 0);
+  return solve (mattype, b, info, rcond, nullptr);
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (MatrixType& mattype, const ComplexColumnVector& b,
                             octave_idx_type& info, double& rcond) const
 {
-  return solve (mattype, b, info, rcond, 0);
+  return solve (mattype, b, info, rcond, nullptr);
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (MatrixType& mattype, const ComplexColumnVector& b,
                             octave_idx_type& info, double& rcond,
                             solve_singularity_handler sing_handler) const
 {
   ComplexMatrix tmp (b);
@@ -7043,119 +7043,119 @@ SparseComplexMatrix::solve (MatrixType& 
                 sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (const Matrix& b) const
 {
   octave_idx_type info;
   double rcond;
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcond, nullptr);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (const Matrix& b, octave_idx_type& info) const
 {
   double rcond;
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcond, nullptr);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (const Matrix& b, octave_idx_type& info,
                             double& rcond) const
 {
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcond, nullptr);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (const Matrix& b, octave_idx_type& err,
                             double& rcond,
                             solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcond, nullptr);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseMatrix& b,
                             octave_idx_type& info) const
 {
   double rcond;
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcond, nullptr);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseMatrix& b,
                             octave_idx_type& info, double& rcond) const
 {
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcond, nullptr);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseMatrix& b,
                             octave_idx_type& err, double& rcond,
                             solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (const ComplexMatrix& b,
                             octave_idx_type& info) const
 {
   double rcond;
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcond, nullptr);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (const ComplexMatrix& b,
                             octave_idx_type& info, double& rcond) const
 {
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcond, nullptr);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (const ComplexMatrix& b,
                             octave_idx_type& err, double& rcond,
                             solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcond, nullptr);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseComplexMatrix& b,
                             octave_idx_type& info) const
 {
   double rcond;
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcond, nullptr);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseComplexMatrix& b,
                             octave_idx_type& info, double& rcond) const
 {
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcond, nullptr);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseComplexMatrix& b,
                             octave_idx_type& err, double& rcond,
                             solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
@@ -7175,17 +7175,17 @@ SparseComplexMatrix::solve (const Column
   double rcond;
   return solve (b, info, rcond);
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info,
                             double& rcond) const
 {
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcond, nullptr);
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info,
                             double& rcond,
                             solve_singularity_handler sing_handler) const
 {
   Matrix tmp (b);
@@ -7193,32 +7193,32 @@ SparseComplexMatrix::solve (const Column
                 sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (const ComplexColumnVector& b) const
 {
   octave_idx_type info;
   double rcond;
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcond, nullptr);
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (const ComplexColumnVector& b,
                             octave_idx_type& info) const
 {
   double rcond;
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcond, nullptr);
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info,
                             double& rcond) const
 {
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcond, nullptr);
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info,
                             double& rcond,
                             solve_singularity_handler sing_handler) const
 {
   ComplexMatrix tmp (b);
diff --git a/liboctave/array/Sparse.h b/liboctave/array/Sparse.h
--- a/liboctave/array/Sparse.h
+++ b/liboctave/array/Sparse.h
@@ -63,23 +63,23 @@ protected:
     octave_idx_type *r;
     octave_idx_type *c;
     octave_idx_type nzmx;
     octave_idx_type nrows;
     octave_idx_type ncols;
     octave::refcount<int> count;
 
     SparseRep (void)
-      : d (0), r (0), c (new octave_idx_type [1] {}), nzmx (0), nrows (0),
-        ncols (0), count (1)
+      : d (nullptr), r (nullptr), c (new octave_idx_type [1] {}),
+        nzmx (0), nrows (0), ncols (0), count (1)
     { }
 
     SparseRep (octave_idx_type n)
-      : d (0), r (0), c (new octave_idx_type [n+1] {}), nzmx (0), nrows (n),
-        ncols (n), count (1)
+      : d (nullptr), r (nullptr), c (new octave_idx_type [n+1] {}),
+        nzmx (0), nrows (n), ncols (n), count (1)
     { }
 
     SparseRep (octave_idx_type nr, octave_idx_type nc, octave_idx_type nz = 0)
       : d (nz > 0 ? new T [nz] {} : nullptr),
         r (nz > 0 ? new octave_idx_type [nz] {} : nullptr),
         c (new octave_idx_type [nc+1] {}), nzmx (nz), nrows (nr),
         ncols (nc), count (1)
     { }
diff --git a/liboctave/array/dSparse.cc b/liboctave/array/dSparse.cc
--- a/liboctave/array/dSparse.cc
+++ b/liboctave/array/dSparse.cc
@@ -1057,17 +1057,17 @@ SparseMatrix::determinant (octave_idx_ty
                                      Ax, 1, control);
 
       void *Symbolic;
       Matrix Info (1, UMFPACK_INFO);
       double *info = Info.fortran_vec ();
       int status = UMFPACK_DNAME (qsymbolic) (nr, nc,
                                               octave::to_suitesparse_intptr (Ap),
                                               octave::to_suitesparse_intptr (Ai),
-                                              Ax, 0, &Symbolic, control, info);
+                                              Ax, nullptr, &Symbolic, control, info);
 
       if (status < 0)
         {
           UMFPACK_DNAME (report_status) (control, status);
           UMFPACK_DNAME (report_info) (control, info);
 
           UMFPACK_DNAME (free_symbolic) (&Symbolic);
 
@@ -5609,17 +5609,17 @@ SparseMatrix::factorize (octave_idx_type
                                  Ax, 1, control);
 
   void *Symbolic;
   Info = Matrix (1, UMFPACK_INFO);
   double *info = Info.fortran_vec ();
   int status = UMFPACK_DNAME (qsymbolic) (nr, nc,
                                           octave::to_suitesparse_intptr (Ap),
                                           octave::to_suitesparse_intptr (Ai),
-                                          Ax, 0, &Symbolic, control, info);
+                                          Ax, nullptr, &Symbolic, control, info);
 
   if (status < 0)
     {
       UMFPACK_DNAME (report_status) (control, status);
       UMFPACK_DNAME (report_info) (control, info);
 
       UMFPACK_DNAME (free_symbolic) (&Symbolic);
 
@@ -5750,17 +5750,17 @@ SparseMatrix::fsolve (MatrixType& mattyp
           A->nrow = nr;
           A->ncol = nc;
 
           A->p = cidx ();
           A->i = ridx ();
           A->nzmax = nnz ();
           A->packed = true;
           A->sorted = true;
-          A->nz = 0;
+          A->nz = nullptr;
 #if defined (OCTAVE_ENABLE_64)
           A->itype = CHOLMOD_LONG;
 #else
           A->itype = CHOLMOD_INT;
 #endif
           A->dtype = CHOLMOD_DOUBLE;
           A->stype = 1;
           A->xtype = CHOLMOD_REAL;
@@ -5975,17 +5975,17 @@ SparseMatrix::fsolve (MatrixType& mattyp
           A->nrow = nr;
           A->ncol = nc;
 
           A->p = cidx ();
           A->i = ridx ();
           A->nzmax = nnz ();
           A->packed = true;
           A->sorted = true;
-          A->nz = 0;
+          A->nz = nullptr;
 #if defined (OCTAVE_ENABLE_64)
           A->itype = CHOLMOD_LONG;
 #else
           A->itype = CHOLMOD_INT;
 #endif
           A->dtype = CHOLMOD_DOUBLE;
           A->stype = 1;
           A->xtype = CHOLMOD_REAL;
@@ -5999,17 +5999,17 @@ SparseMatrix::fsolve (MatrixType& mattyp
           cholmod_sparse *B = &Bstore;
           B->nrow = b.rows ();
           B->ncol = b.cols ();
           B->p = b.cidx ();
           B->i = b.ridx ();
           B->nzmax = b.nnz ();
           B->packed = true;
           B->sorted = true;
-          B->nz = 0;
+          B->nz = nullptr;
 #if defined (OCTAVE_ENABLE_64)
           B->itype = CHOLMOD_LONG;
 #else
           B->itype = CHOLMOD_INT;
 #endif
           B->dtype = CHOLMOD_DOUBLE;
           B->stype = 0;
           B->xtype = CHOLMOD_REAL;
@@ -6246,17 +6246,17 @@ SparseMatrix::fsolve (MatrixType& mattyp
           A->nrow = nr;
           A->ncol = nc;
 
           A->p = cidx ();
           A->i = ridx ();
           A->nzmax = nnz ();
           A->packed = true;
           A->sorted = true;
-          A->nz = 0;
+          A->nz = nullptr;
 #if defined (OCTAVE_ENABLE_64)
           A->itype = CHOLMOD_LONG;
 #else
           A->itype = CHOLMOD_INT;
 #endif
           A->dtype = CHOLMOD_DOUBLE;
           A->stype = 1;
           A->xtype = CHOLMOD_REAL;
@@ -6491,17 +6491,17 @@ SparseMatrix::fsolve (MatrixType& mattyp
           A->nrow = nr;
           A->ncol = nc;
 
           A->p = cidx ();
           A->i = ridx ();
           A->nzmax = nnz ();
           A->packed = true;
           A->sorted = true;
-          A->nz = 0;
+          A->nz = nullptr;
 #if defined (OCTAVE_ENABLE_64)
           A->itype = CHOLMOD_LONG;
 #else
           A->itype = CHOLMOD_INT;
 #endif
           A->dtype = CHOLMOD_DOUBLE;
           A->stype = 1;
           A->xtype = CHOLMOD_REAL;
@@ -6515,17 +6515,17 @@ SparseMatrix::fsolve (MatrixType& mattyp
           cholmod_sparse *B = &Bstore;
           B->nrow = b.rows ();
           B->ncol = b.cols ();
           B->p = b.cidx ();
           B->i = b.ridx ();
           B->nzmax = b.nnz ();
           B->packed = true;
           B->sorted = true;
-          B->nz = 0;
+          B->nz = nullptr;
 #if defined (OCTAVE_ENABLE_64)
           B->itype = CHOLMOD_LONG;
 #else
           B->itype = CHOLMOD_INT;
 #endif
           B->dtype = CHOLMOD_DOUBLE;
           B->stype = 0;
           B->xtype = CHOLMOD_COMPLEX;
@@ -6716,32 +6716,32 @@ SparseMatrix::fsolve (MatrixType& mattyp
   return retval;
 }
 
 Matrix
 SparseMatrix::solve (MatrixType& mattype, const Matrix& b) const
 {
   octave_idx_type info;
   double rcond;
-  return solve (mattype, b, info, rcond, 0);
+  return solve (mattype, b, info, rcond, nullptr);
 }
 
 Matrix
 SparseMatrix::solve (MatrixType& mattype, const Matrix& b,
                      octave_idx_type& info) const
 {
   double rcond;
-  return solve (mattype, b, info, rcond, 0);
+  return solve (mattype, b, info, rcond, nullptr);
 }
 
 Matrix
 SparseMatrix::solve (MatrixType& mattype, const Matrix& b,
                      octave_idx_type& info, double& rcond) const
 {
-  return solve (mattype, b, info, rcond, 0);
+  return solve (mattype, b, info, rcond, nullptr);
 }
 
 Matrix
 SparseMatrix::solve (MatrixType& mattype, const Matrix& b, octave_idx_type& err,
                      double& rcond, solve_singularity_handler sing_handler,
                      bool singular_fallback) const
 {
   Matrix retval;
@@ -6781,32 +6781,32 @@ SparseMatrix::solve (MatrixType& mattype
   return retval;
 }
 
 SparseMatrix
 SparseMatrix::solve (MatrixType& mattype, const SparseMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
-  return solve (mattype, b, info, rcond, 0);
+  return solve (mattype, b, info, rcond, nullptr);
 }
 
 SparseMatrix
 SparseMatrix::solve (MatrixType& mattype, const SparseMatrix& b,
                      octave_idx_type& info) const
 {
   double rcond;
-  return solve (mattype, b, info, rcond, 0);
+  return solve (mattype, b, info, rcond, nullptr);
 }
 
 SparseMatrix
 SparseMatrix::solve (MatrixType& mattype, const SparseMatrix& b,
                      octave_idx_type& info, double& rcond) const
 {
-  return solve (mattype, b, info, rcond, 0);
+  return solve (mattype, b, info, rcond, nullptr);
 }
 
 SparseMatrix
 SparseMatrix::solve (MatrixType& mattype, const SparseMatrix& b,
                      octave_idx_type& err, double& rcond,
                      solve_singularity_handler sing_handler,
                      bool singular_fallback) const
 {
@@ -6846,32 +6846,32 @@ SparseMatrix::solve (MatrixType& mattype
   return retval;
 }
 
 ComplexMatrix
 SparseMatrix::solve (MatrixType& mattype, const ComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
-  return solve (mattype, b, info, rcond, 0);
+  return solve (mattype, b, info, rcond, nullptr);
 }
 
 ComplexMatrix
 SparseMatrix::solve (MatrixType& mattype, const ComplexMatrix& b,
                      octave_idx_type& info) const
 {
   double rcond;
-  return solve (mattype, b, info, rcond, 0);
+  return solve (mattype, b, info, rcond, nullptr);
 }
 
 ComplexMatrix
 SparseMatrix::solve (MatrixType& mattype, const ComplexMatrix& b,
                      octave_idx_type& info, double& rcond) const
 {
-  return solve (mattype, b, info, rcond, 0);
+  return solve (mattype, b, info, rcond, nullptr);
 }
 
 ComplexMatrix
 SparseMatrix::solve (MatrixType& mattype, const ComplexMatrix& b,
                      octave_idx_type& err, double& rcond,
                      solve_singularity_handler sing_handler,
                      bool singular_fallback) const
 {
@@ -6911,32 +6911,32 @@ SparseMatrix::solve (MatrixType& mattype
   return retval;
 }
 
 SparseComplexMatrix
 SparseMatrix::solve (MatrixType& mattype, const SparseComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
-  return solve (mattype, b, info, rcond, 0);
+  return solve (mattype, b, info, rcond, nullptr);
 }
 
 SparseComplexMatrix
 SparseMatrix::solve (MatrixType& mattype, const SparseComplexMatrix& b,
                      octave_idx_type& info) const
 {
   double rcond;
-  return solve (mattype, b, info, rcond, 0);
+  return solve (mattype, b, info, rcond, nullptr);
 }
 
 SparseComplexMatrix
 SparseMatrix::solve (MatrixType& mattype, const SparseComplexMatrix& b,
                      octave_idx_type& info, double& rcond) const
 {
-  return solve (mattype, b, info, rcond, 0);
+  return solve (mattype, b, info, rcond, nullptr);
 }
 
 SparseComplexMatrix
 SparseMatrix::solve (MatrixType& mattype, const SparseComplexMatrix& b,
                      octave_idx_type& err, double& rcond,
                      solve_singularity_handler sing_handler,
                      bool singular_fallback) const
 {
@@ -6990,17 +6990,17 @@ SparseMatrix::solve (MatrixType& mattype
   double rcond;
   return solve (mattype, b, info, rcond);
 }
 
 ColumnVector
 SparseMatrix::solve (MatrixType& mattype, const ColumnVector& b,
                      octave_idx_type& info, double& rcond) const
 {
-  return solve (mattype, b, info, rcond, 0);
+  return solve (mattype, b, info, rcond, nullptr);
 }
 
 ColumnVector
 SparseMatrix::solve (MatrixType& mattype, const ColumnVector& b,
                      octave_idx_type& info, double& rcond,
                      solve_singularity_handler sing_handler) const
 {
   Matrix tmp (b);
@@ -7008,33 +7008,33 @@ SparseMatrix::solve (MatrixType& mattype
                 sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 ComplexColumnVector
 SparseMatrix::solve (MatrixType& mattype, const ComplexColumnVector& b) const
 {
   octave_idx_type info;
   double rcond;
-  return solve (mattype, b, info, rcond, 0);
+  return solve (mattype, b, info, rcond, nullptr);
 }
 
 ComplexColumnVector
 SparseMatrix::solve (MatrixType& mattype, const ComplexColumnVector& b,
                      octave_idx_type& info) const
 {
   double rcond;
-  return solve (mattype, b, info, rcond, 0);
+  return solve (mattype, b, info, rcond, nullptr);
 }
 
 ComplexColumnVector
 SparseMatrix::solve (MatrixType& mattype, const ComplexColumnVector& b,
                      octave_idx_type& info,
                      double& rcond) const
 {
-  return solve (mattype, b, info, rcond, 0);
+  return solve (mattype, b, info, rcond, nullptr);
 }
 
 ComplexColumnVector
 SparseMatrix::solve (MatrixType& mattype, const ComplexColumnVector& b,
                      octave_idx_type& info, double& rcond,
                      solve_singularity_handler sing_handler) const
 {
   ComplexMatrix tmp (b);
@@ -7042,115 +7042,115 @@ SparseMatrix::solve (MatrixType& mattype
                 sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 Matrix
 SparseMatrix::solve (const Matrix& b) const
 {
   octave_idx_type info;
   double rcond;
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcond, nullptr);
 }
 
 Matrix
 SparseMatrix::solve (const Matrix& b, octave_idx_type& info) const
 {
   double rcond;
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcond, nullptr);
 }
 
 Matrix
 SparseMatrix::solve (const Matrix& b, octave_idx_type& info,
                      double& rcond) const
 {
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcond, nullptr);
 }
 
 Matrix
 SparseMatrix::solve (const Matrix& b, octave_idx_type& err, double& rcond,
                      solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 SparseMatrix
 SparseMatrix::solve (const SparseMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcond, nullptr);
 }
 
 SparseMatrix
 SparseMatrix::solve (const SparseMatrix& b,
                      octave_idx_type& info) const
 {
   double rcond;
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcond, nullptr);
 }
 
 SparseMatrix
 SparseMatrix::solve (const SparseMatrix& b,
                      octave_idx_type& info, double& rcond) const
 {
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcond, nullptr);
 }
 
 SparseMatrix
 SparseMatrix::solve (const SparseMatrix& b, octave_idx_type& err, double& rcond,
                      solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 ComplexMatrix
 SparseMatrix::solve (const ComplexMatrix& b, octave_idx_type& info) const
 {
   double rcond;
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcond, nullptr);
 }
 
 ComplexMatrix
 SparseMatrix::solve (const ComplexMatrix& b, octave_idx_type& info,
                      double& rcond) const
 {
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcond, nullptr);
 }
 
 ComplexMatrix
 SparseMatrix::solve (const ComplexMatrix& b, octave_idx_type& err,
                      double& rcond,
                      solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 SparseComplexMatrix
 SparseMatrix::solve (const SparseComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcond, nullptr);
 }
 
 SparseComplexMatrix
 SparseMatrix::solve (const SparseComplexMatrix& b, octave_idx_type& info) const
 {
   double rcond;
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcond, nullptr);
 }
 
 SparseComplexMatrix
 SparseMatrix::solve (const SparseComplexMatrix& b, octave_idx_type& info,
                      double& rcond) const
 {
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcond, nullptr);
 }
 
 SparseComplexMatrix
 SparseMatrix::solve (const SparseComplexMatrix& b,
                      octave_idx_type& err, double& rcond,
                      solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
@@ -7170,17 +7170,17 @@ SparseMatrix::solve (const ColumnVector&
   double rcond;
   return solve (b, info, rcond);
 }
 
 ColumnVector
 SparseMatrix::solve (const ColumnVector& b, octave_idx_type& info,
                      double& rcond) const
 {
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcond, nullptr);
 }
 
 ColumnVector
 SparseMatrix::solve (const ColumnVector& b, octave_idx_type& info,
                      double& rcond,
                      solve_singularity_handler sing_handler) const
 {
   Matrix tmp (b);
@@ -7188,31 +7188,31 @@ SparseMatrix::solve (const ColumnVector&
                 sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 ComplexColumnVector
 SparseMatrix::solve (const ComplexColumnVector& b) const
 {
   octave_idx_type info;
   double rcond;
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcond, nullptr);
 }
 
 ComplexColumnVector
 SparseMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info) const
 {
   double rcond;
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcond, nullptr);
 }
 
 ComplexColumnVector
 SparseMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info,
                      double& rcond) const
 {
-  return solve (b, info, rcond, 0);
+  return solve (b, info, rcond, nullptr);
 }
 
 ComplexColumnVector
 SparseMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info,
                      double& rcond,
                      solve_singularity_handler sing_handler) const
 {
   ComplexMatrix tmp (b);
diff --git a/liboctave/array/fCMatrix.cc b/liboctave/array/fCMatrix.cc
--- a/liboctave/array/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -2077,32 +2077,32 @@ FloatComplexMatrix::fsolve (MatrixType& 
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (MatrixType& mattype, const FloatMatrix& b) const
 {
   octave_idx_type info;
   float rcon;
-  return solve (mattype, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, nullptr);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (MatrixType& mattype, const FloatMatrix& b,
                            octave_idx_type& info) const
 {
   float rcon;
-  return solve (mattype, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, nullptr);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (MatrixType& mattype, const FloatMatrix& b,
                            octave_idx_type& info, float& rcon) const
 {
-  return solve (mattype, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, nullptr);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (MatrixType& mattype, const FloatMatrix& b,
                            octave_idx_type& info, float& rcon,
                            solve_singularity_handler sing_handler,
                            bool singular_fallback, blas_trans_type transt) const
 {
@@ -2112,32 +2112,32 @@ FloatComplexMatrix::solve (MatrixType& m
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (MatrixType& mattype,
                            const FloatComplexMatrix& b) const
 {
   octave_idx_type info;
   float rcon;
-  return solve (mattype, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, nullptr);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (MatrixType& mattype, const FloatComplexMatrix& b,
                            octave_idx_type& info) const
 {
   float rcon;
-  return solve (mattype, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, nullptr);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (MatrixType& mattype, const FloatComplexMatrix& b,
                            octave_idx_type& info, float& rcon) const
 {
-  return solve (mattype, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, nullptr);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (MatrixType& mattype, const FloatComplexMatrix& b,
                            octave_idx_type& info, float& rcon,
                            solve_singularity_handler sing_handler,
                            bool singular_fallback,
                            blas_trans_type transt) const
@@ -2176,32 +2176,32 @@ FloatComplexMatrix::solve (MatrixType& m
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType& mattype,
                            const FloatColumnVector& b) const
 {
   octave_idx_type info;
   float rcon;
-  return solve (mattype, FloatComplexColumnVector (b), info, rcon, 0);
+  return solve (mattype, FloatComplexColumnVector (b), info, rcon, nullptr);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType& mattype, const FloatColumnVector& b,
                            octave_idx_type& info) const
 {
   float rcon;
-  return solve (mattype, FloatComplexColumnVector (b), info, rcon, 0);
+  return solve (mattype, FloatComplexColumnVector (b), info, rcon, nullptr);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType& mattype, const FloatColumnVector& b,
                            octave_idx_type& info, float& rcon) const
 {
-  return solve (mattype, FloatComplexColumnVector (b), info, rcon, 0);
+  return solve (mattype, FloatComplexColumnVector (b), info, rcon, nullptr);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType& mattype, const FloatColumnVector& b,
                            octave_idx_type& info, float& rcon,
                            solve_singularity_handler sing_handler,
                            blas_trans_type transt) const
 {
@@ -2210,34 +2210,34 @@ FloatComplexMatrix::solve (MatrixType& m
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType& mattype,
                            const FloatComplexColumnVector& b) const
 {
   octave_idx_type info;
   float rcon;
-  return solve (mattype, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, nullptr);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType& mattype,
                            const FloatComplexColumnVector& b,
                            octave_idx_type& info) const
 {
   float rcon;
-  return solve (mattype, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, nullptr);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType& mattype,
                            const FloatComplexColumnVector& b,
                            octave_idx_type& info, float& rcon) const
 {
-  return solve (mattype, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, nullptr);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType& mattype,
                            const FloatComplexColumnVector& b,
                            octave_idx_type& info, float& rcon,
                            solve_singularity_handler sing_handler,
                            blas_trans_type transt) const
@@ -2248,31 +2248,31 @@ FloatComplexMatrix::solve (MatrixType& m
   return tmp.column (static_cast<octave_idx_type> (0));
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (const FloatMatrix& b) const
 {
   octave_idx_type info;
   float rcon;
-  return solve (b, info, rcon, 0);
+  return solve (b, info, rcon, nullptr);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (const FloatMatrix& b, octave_idx_type& info) const
 {
   float rcon;
-  return solve (b, info, rcon, 0);
+  return solve (b, info, rcon, nullptr);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (const FloatMatrix& b, octave_idx_type& info,
                            float& rcon) const
 {
-  return solve (b, info, rcon, 0);
+  return solve (b, info, rcon, nullptr);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (const FloatMatrix& b, octave_idx_type& info,
                            float& rcon,
                            solve_singularity_handler sing_handler,
                            blas_trans_type transt) const
 {
@@ -2280,32 +2280,32 @@ FloatComplexMatrix::solve (const FloatMa
   return solve (tmp, info, rcon, sing_handler, transt);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (const FloatComplexMatrix& b) const
 {
   octave_idx_type info;
   float rcon;
-  return solve (b, info, rcon, 0);
+  return solve (b, info, rcon, nullptr);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (const FloatComplexMatrix& b,
                            octave_idx_type& info) const
 {
   float rcon;
-  return solve (b, info, rcon, 0);
+  return solve (b, info, rcon, nullptr);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (const FloatComplexMatrix& b, octave_idx_type& info,
                            float& rcon) const
 {
-  return solve (b, info, rcon, 0);
+  return solve (b, info, rcon, nullptr);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (const FloatComplexMatrix& b, octave_idx_type& info,
                            float& rcon,
                            solve_singularity_handler sing_handler,
                            blas_trans_type transt) const
 {
@@ -2313,25 +2313,25 @@ FloatComplexMatrix::solve (const FloatCo
   return solve (mattype, b, info, rcon, sing_handler, true, transt);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (const FloatColumnVector& b) const
 {
   octave_idx_type info;
   float rcon;
-  return solve (FloatComplexColumnVector (b), info, rcon, 0);
+  return solve (FloatComplexColumnVector (b), info, rcon, nullptr);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (const FloatColumnVector& b,
                            octave_idx_type& info) const
 {
   float rcon;
-  return solve (FloatComplexColumnVector (b), info, rcon, 0);
+  return solve (FloatComplexColumnVector (b), info, rcon, nullptr);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (const FloatColumnVector& b, octave_idx_type& info,
                            float& rcon) const
 {
   return solve (FloatComplexColumnVector (b), info, rcon, 0);
 }
@@ -2345,33 +2345,33 @@ FloatComplexMatrix::solve (const FloatCo
   return solve (FloatComplexColumnVector (b), info, rcon, sing_handler, transt);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (const FloatComplexColumnVector& b) const
 {
   octave_idx_type info;
   float rcon;
-  return solve (b, info, rcon, 0);
+  return solve (b, info, rcon, nullptr);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (const FloatComplexColumnVector& b,
                            octave_idx_type& info) const
 {
   float rcon;
-  return solve (b, info, rcon, 0);
+  return solve (b, info, rcon, nullptr);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (const FloatComplexColumnVector& b,
                            octave_idx_type& info,
                            float& rcon) const
 {
-  return solve (b, info, rcon, 0);
+  return solve (b, info, rcon, nullptr);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (const FloatComplexColumnVector& b,
                            octave_idx_type& info,
                            float& rcon,
                            solve_singularity_handler sing_handler,
                            blas_trans_type transt) const
diff --git a/liboctave/array/idx-vector.cc b/liboctave/array/idx-vector.cc
--- a/liboctave/array/idx-vector.cc
+++ b/liboctave/array/idx-vector.cc
@@ -310,17 +310,17 @@ idx_vector::idx_scalar_rep::unconvert (v
 Array<octave_idx_type>
 idx_vector::idx_scalar_rep::as_array (void)
 {
   return Array<octave_idx_type> (dim_vector (1, 1), data);
 }
 
 template <typename T>
 idx_vector::idx_vector_rep::idx_vector_rep (const Array<T>& nda)
-  : idx_base_rep (), data (0), len (nda.numel ()), ext (0),
+  : idx_base_rep (), data (nullptr), len (nda.numel ()), ext (0),
     aowner (nullptr), orig_dims (nda.dims ())
 {
   if (len != 0)
     {
       std::unique_ptr<octave_idx_type []> d (new octave_idx_type [len]);
 
       for (octave_idx_type i = 0; i < len; i++)
         d[i] = convert_index (nda.xelem (i), err, ext);
@@ -367,31 +367,32 @@ idx_vector::idx_vector_rep::idx_vector_r
         if (data[i] > max)
           max = data[i];
 
       ext = max + 1;
     }
 }
 
 idx_vector::idx_vector_rep::idx_vector_rep (bool b)
-  : idx_base_rep (), data (0), len (b ? 1 : 0), ext (0), aowner (nullptr),
-    orig_dims (len, len)
+  : idx_base_rep (), data (nullptr), len (b ? 1 : 0), ext (0),
+    aowner (nullptr), orig_dims (len, len)
 {
   if (len != 0)
     {
       octave_idx_type *d = new octave_idx_type [1];
       d[0] = 0;
       data = d;
       ext = 1;
     }
 }
 
 idx_vector::idx_vector_rep::idx_vector_rep (const Array<bool>& bnda,
                                             octave_idx_type nnz)
-  : idx_base_rep (), data (0), len (nnz), ext (0), aowner (nullptr), orig_dims ()
+  : idx_base_rep (), data (nullptr), len (nnz), ext (0), aowner (nullptr),
+    orig_dims ()
 {
   if (nnz < 0)
     len = bnda.nnz ();
 
   const dim_vector dv = bnda.dims ();
 
   orig_dims = dv.make_nd_vector (len);
 
@@ -408,18 +409,18 @@ idx_vector::idx_vector_rep::idx_vector_r
 
       data = d;
 
       ext = d[k-1] + 1;
     }
 }
 
 idx_vector::idx_vector_rep::idx_vector_rep (const Sparse<bool>& bnda)
-  : idx_base_rep (), data (0), len (bnda.nnz ()), ext (0), aowner (nullptr),
-    orig_dims ()
+  : idx_base_rep (), data (nullptr), len (bnda.nnz ()), ext (0),
+    aowner (nullptr), orig_dims ()
 {
   const dim_vector dv = bnda.dims ();
 
   orig_dims = dv.make_nd_vector (len);
 
   if (len != 0)
     {
       octave_idx_type *d = new octave_idx_type [len];
@@ -635,31 +636,31 @@ idx_vector::idx_vector_rep::as_array (vo
       data = retval.fortran_vec ();
       aowner = new Array<octave_idx_type> (retval);
 
       return retval;
     }
 }
 
 idx_vector::idx_mask_rep::idx_mask_rep (bool b)
-  : idx_base_rep (), data (0), len (b ? 1 : 0), ext (0),
+  : idx_base_rep (), data (nullptr), len (b ? 1 : 0), ext (0),
     lsti (-1), lste (-1), aowner (nullptr), orig_dims (len, len)
 {
   if (len != 0)
     {
       bool *d = new bool [1];
       d[0] = true;
       data = d;
       ext = 1;
     }
 }
 
 idx_vector::idx_mask_rep::idx_mask_rep (const Array<bool>& bnda,
                                         octave_idx_type nnz)
-  : idx_base_rep (), data (0), len (nnz), ext (bnda.numel ()),
+  : idx_base_rep (), data (nullptr), len (nnz), ext (bnda.numel ()),
     lsti (-1), lste (-1), aowner (nullptr), orig_dims ()
 {
   if (nnz < 0)
     len = bnda.nnz ();
 
   // We truncate the extent as much as possible.  For Matlab
   // compatibility, but maybe it's not a bad idea anyway.
   while (ext > 0 && ! bnda(ext-1))
diff --git a/liboctave/array/idx-vector.h b/liboctave/array/idx-vector.h
--- a/liboctave/array/idx-vector.h
+++ b/liboctave/array/idx-vector.h
@@ -277,17 +277,17 @@ private:
   };
 
   // The integer vector index.
   class OCTAVE_API idx_vector_rep : public idx_base_rep
   {
   public:
 
     idx_vector_rep (void)
-      : data (0), len (0), ext (0), aowner (nullptr), orig_dims ()
+      : data (nullptr), len (0), ext (0), aowner (nullptr), orig_dims ()
     { }
 
     // Direct constructor.
     idx_vector_rep (octave_idx_type *_data, octave_idx_type _len,
                     octave_idx_type _ext, const dim_vector& od, direct)
       : idx_base_rep (), data (_data), len (_len), ext (_ext),
         aowner (nullptr), orig_dims (od)
     { }
diff --git a/liboctave/numeric/sparse-chol.cc b/liboctave/numeric/sparse-chol.cc
--- a/liboctave/numeric/sparse-chol.cc
+++ b/liboctave/numeric/sparse-chol.cc
@@ -264,17 +264,17 @@ namespace octave
       ac->nrow = a_nr;
       ac->ncol = a_nc;
 
       ac->p = a.cidx ();
       ac->i = a.ridx ();
       ac->nzmax = a.nnz ();
       ac->packed = true;
       ac->sorted = true;
-      ac->nz = 0;
+      ac->nz = nullptr;
 #if defined (OCTAVE_ENABLE_64)
       ac->itype = CHOLMOD_LONG;
 #else
       ac->itype = CHOLMOD_INT;
 #endif
       ac->dtype = CHOLMOD_DOUBLE;
       ac->stype = 1;
       ac->xtype = get_xtype<chol_elt> ();
diff --git a/liboctave/util/cmd-edit.cc b/liboctave/util/cmd-edit.cc
--- a/liboctave/util/cmd-edit.cc
+++ b/liboctave/util/cmd-edit.cc
@@ -1372,17 +1372,17 @@ namespace octave
     if (instance_ok ())
       instance->do_set_user_accept_line_function (f);
   }
 
   command_editor::completion_fcn
   command_editor::get_completion_function (void)
   {
     return (instance_ok ())
-           ? instance->do_get_completion_function () : 0;
+           ? instance->do_get_completion_function () : nullptr;
   }
 
   command_editor::quoting_fcn
   command_editor::get_quoting_function (void)
   {
     return (instance_ok ())
            ? instance->do_get_quoting_function () : nullptr;
   }
diff --git a/liboctave/util/oct-sort.cc b/liboctave/util/oct-sort.cc
--- a/liboctave/util/oct-sort.cc
+++ b/liboctave/util/oct-sort.cc
@@ -136,17 +136,17 @@ template <typename T>
 void
 octave_sort<T>::set_compare (sortmode mode)
 {
   if (mode == ASCENDING)
     compare = ascending_compare;
   else if (mode == DESCENDING)
     compare = descending_compare;
   else
-    compare = 0;
+    compare = nullptr;
 }
 
 template <typename T>
 template <typename Comp>
 void
 octave_sort<T>::binarysort (T *data, octave_idx_type nel,
                             octave_idx_type start, Comp comp)
 {
diff --git a/src/main.in.cc b/src/main.in.cc
--- a/src/main.in.cc
+++ b/src/main.in.cc
@@ -181,17 +181,17 @@ octave_exec (const std::string& file, ch
 
   return status;
 }
 
 static char *
 strsave (const char *s)
 {
   if (! s)
-    return 0;
+    return nullptr;
 
   int len = strlen (s);
   char *tmp = new char [len+1];
   tmp = strcpy (tmp, s);
   return tmp;
 }
 
 int
@@ -285,17 +285,17 @@ main (int argc, char **argv)
               }
 
           new_argv[k++] = argv[i];
         }
       else
         new_argv[k++] = argv[i];
     }
 
-  new_argv[k] = 0;
+  new_argv[k] = nullptr;
 
   if (no_display)
     {
       start_gui = false;
       gui_libs = false;
 
       file = octave_cli;
     }
