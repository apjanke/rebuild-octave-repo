# HG changeset patch
# User Jacob Dawid <jacob.dawid@googlemail.com>
# Date 1327354025 -3600
#      Mon Jan 23 22:27:05 2012 +0100
# Node ID a89e968265e84be4def1be658a6560325e6a619e
# Parent  3524352c7382ca0c7b8a292834ce1da322e70db5
Intermediate commit.

diff --git a/libqterminal/Pty.cpp b/libqterminal/Pty.cpp
--- a/libqterminal/Pty.cpp
+++ b/libqterminal/Pty.cpp
@@ -147,18 +147,20 @@ void Pty::addEnvironmentVariables(const 
         }
     }
 }
 
 int Pty::start(const QString& program, 
                const QStringList& programArguments, 
                const QStringList& environment, 
                ulong winid, 
-               bool addToUtmp
-//               const QString& dbusService, 
+               bool addToUtmp,
+               int masterFd,
+               int slaveFd
+//               const QString& dbusService,
 //               const QString& dbusSession)
 		)
 {
   clearArguments();
 
   setBinaryExecutable(program.toLatin1());
 
   addEnvironmentVariables(environment);
@@ -183,17 +185,17 @@ int Pty::start(const QString& program,
   //
   // this can happen if LANG contains a language which KDE
   // does not have a translation for
   //
   // BR:149300
   if (!environment.contains("LANGUAGE"))
       setEnvironment("LANGUAGE",QString());
 
-  setUsePty(All, addToUtmp);
+  setUsePty(All, addToUtmp, masterFd, slaveFd);
 
   pty()->open();
   
   struct ::termios ttmode;
   pty()->tcGetAttr(&ttmode);
   if (!_xonXoff)
     ttmode.c_iflag &= ~(IXOFF | IXON);
   else
@@ -242,17 +244,36 @@ Pty::Pty()
   connect(this, SIGNAL(receivedStdout(K3Process *, char *, int )),
 	  this, SLOT(dataReceived(K3Process *,char *, int)));
   connect(this, SIGNAL(processExited(K3Process *)),
           this, SLOT(donePty()));
   connect(this, SIGNAL(wroteStdin(K3Process *)),
           this, SLOT(writeReady()));
   _pty = new KPty;
 
-  setUsePty(All, false); // utmp will be overridden later
+  setUsePty(All, false, -1, -1); // utmp will be overridden later
+}
+
+Pty::Pty(int masterFd, int slaveFd)
+    : _bufferFull(false),
+      _windowColumns(0),
+      _windowLines(0),
+      _eraseChar(0),
+      _xonXoff(true),
+      _utf8(true)
+{
+  connect(this, SIGNAL(receivedStdout(K3Process *, char *, int )),
+          this, SLOT(dataReceived(K3Process *,char *, int)));
+  connect(this, SIGNAL(processExited(K3Process *)),
+          this, SLOT(donePty()));
+  connect(this, SIGNAL(wroteStdin(K3Process *)),
+          this, SLOT(writeReady()));
+  _pty = new KPty(masterFd, slaveFd);
+
+  setUsePty(All, false, masterFd, slaveFd); // utmp will be overridden later
 }
 
 Pty::~Pty()
 {
     delete _pty;
 }
 
 void Pty::writeReady()
diff --git a/libqterminal/Pty.h b/libqterminal/Pty.h
--- a/libqterminal/Pty.h
+++ b/libqterminal/Pty.h
@@ -61,16 +61,18 @@ Q_OBJECT
      * 
      * Connect to the sendData() slot and receivedData() signal to prepare
      * for sending and receiving data from the terminal process.
      *
      * To start the terminal process, call the run() method with the 
      * name of the program to start and appropriate arguments.
      */
     Pty();
+    Pty(int masterFd, int slaveFd);
+
     ~Pty();
 
     /**
      * Starts the terminal process.  
      *
      * Returns 0 if the process was started successfully or non-zero
      * otherwise.
      *
@@ -87,17 +89,19 @@ Q_OBJECT
      * environment variable in the process's environment.
      * @param dbusSession Specifies the value of the KONSOLE_DBUS_SESSION
      * environment variable in the process's environment. 
      */
     int start( const QString& program, 
                const QStringList& arguments, 
                const QStringList& environment, 
                ulong winid, 
-               bool addToUtmp
+               bool addToUtmp,
+               int masterFd,
+               int slaveFd
 //               const QString& dbusService,
 //               const QString& dbusSession
              );
 
     /** TODO: Document me */
     void setWriteable(bool writeable);
 
     /** 
diff --git a/libqterminal/QTerminal.cpp b/libqterminal/QTerminal.cpp
--- a/libqterminal/QTerminal.cpp
+++ b/libqterminal/QTerminal.cpp
@@ -13,32 +13,41 @@
     You should have received a copy of the GNU Library General Public License
     along with this library; see the file COPYING.LIB.  If not, write to
     the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
     Boston, MA 02110-1301, USA.
 */
 						
 
 #include "QTerminal.h"
+#include "pty.h"
 
 using namespace Konsole;
 
 QTerminal::QTerminal(QWidget *parent)
     : QWidget(parent) {
     init();
     
     setFocus(Qt::OtherFocusReason);
     m_terminalDisplay->resize(this->size());
     
     this->setFocusProxy(m_terminalDisplay);
 }
 
 void QTerminal::init()
 {
-    m_session = new Session();
+    int fdm;
+    int fds;
+    openpty (&fdm, &fds, 0, 0, 0);
+
+    dup2 (fds, 0);
+    dup2 (fds, 1);
+    dup2 (fds, 2);
+
+    m_session = new Session(fdm, fds);
 
     m_session->setTitle(Session::NameRole, "QTermWidget");
     m_session->setProgram("/bin/bash");
     QStringList args("");
     m_session->setArguments(args);
     m_session->setAutoClose(true);
     m_session->setCodec(QTextCodec::codecForName("UTF-8"));
     m_session->setFlowControlEnabled(true);
diff --git a/libqterminal/Session.cpp b/libqterminal/Session.cpp
--- a/libqterminal/Session.cpp
+++ b/libqterminal/Session.cpp
@@ -42,70 +42,77 @@
 #include "TerminalDisplay.h"
 #include "ShellCommand.h"
 #include "Vt102Emulation.h"
 
 using namespace Konsole;
 
 int Session::lastSessionId = 0;
 
-Session::Session() :
+Session::Session(int masterFd, int slaveFd) :
     _shellProcess(0)
-   , _emulation(0)
-   , _monitorActivity(false)
-   , _monitorSilence(false)
-   , _notifiedActivity(false)
-   , _autoClose(true)
-   , _wantedClose(false)
-   , _silenceSeconds(10)
-   , _addToUtmp(false)  // disabled by default because of a bug encountered on certain systems
-                        // which caused Konsole to hang when closing a tab and then opening a new
-                        // one.  A 'QProcess destroyed while still running' warning was being
-                        // printed to the terminal.  Likely a problem in KPty::logout() 
-                        // or KPty::login() which uses a QProcess to start /usr/bin/utempter 
-   , _flowControl(true)
-   , _fullScripting(false)
-   , _sessionId(0)
-//   , _zmodemBusy(false)
-//   , _zmodemProc(0)
-//   , _zmodemProgress(0)
-   , _hasDarkBackground(false)
+  , _emulation(0)
+  , _monitorActivity(false)
+  , _monitorSilence(false)
+  , _notifiedActivity(false)
+  , _autoClose(true)
+  , _wantedClose(false)
+  , _silenceSeconds(10)
+  , _addToUtmp(false)  // disabled by default because of a bug encountered on certain systems
+  // which caused Konsole to hang when closing a tab and then opening a new
+  // one.  A 'QProcess destroyed while still running' warning was being
+  // printed to the terminal.  Likely a problem in KPty::logout()
+  // or KPty::login() which uses a QProcess to start /usr/bin/utempter
+  , _flowControl(true)
+  , _fullScripting(false)
+  , _sessionId(0)
+  //   , _zmodemBusy(false)
+  //   , _zmodemProc(0)
+  //   , _zmodemProgress(0)
+  , _hasDarkBackground(false)
 {
+    _masterFd = masterFd;
+    _slaveFd = slaveFd;
+
     //prepare DBus communication
-//    new SessionAdaptor(this);
+    //    new SessionAdaptor(this);
     _sessionId = ++lastSessionId;
-//    QDBusConnection::sessionBus().registerObject(QLatin1String("/Sessions/")+QString::number(_sessionId), this);
+    //    QDBusConnection::sessionBus().registerObject(QLatin1String("/Sessions/")+QString::number(_sessionId), this);
 
     //create teletype for I/O with shell process
-    _shellProcess = new Pty();
+    if(_masterFd >= 0) {
+        _shellProcess = new Pty(_masterFd, _slaveFd);
+    } else {
+        _shellProcess = new Pty();
+    }
 
     //create emulation backend
     _emulation = new Vt102Emulation();
 
     connect( _emulation, SIGNAL( titleChanged( int, const QString & ) ),
-           this, SLOT( setUserTitle( int, const QString & ) ) );
+             this, SLOT( setUserTitle( int, const QString & ) ) );
     connect( _emulation, SIGNAL( stateSet(int) ),
-           this, SLOT( activityStateSet(int) ) );
-//    connect( _emulation, SIGNAL( zmodemDetected() ), this ,
-//            SLOT( fireZModemDetected() ) );
+             this, SLOT( activityStateSet(int) ) );
+    //    connect( _emulation, SIGNAL( zmodemDetected() ), this ,
+    //            SLOT( fireZModemDetected() ) );
     connect( _emulation, SIGNAL( changeTabTextColorRequest( int ) ),
-           this, SIGNAL( changeTabTextColorRequest( int ) ) );
+             this, SIGNAL( changeTabTextColorRequest( int ) ) );
     connect( _emulation, SIGNAL(profileChangeCommandReceived(const QString&)),
-           this, SIGNAL( profileChangeCommandReceived(const QString&)) );
+             this, SIGNAL( profileChangeCommandReceived(const QString&)) );
     // TODO
     // connect( _emulation,SIGNAL(imageSizeChanged(int,int)) , this ,
     //        SLOT(onEmulationSizeChange(int,int)) );
 
     //connect teletype to emulation backend
     _shellProcess->setUtf8Mode(_emulation->utf8());
 
     connect( _shellProcess,SIGNAL(receivedData(const char*,int)),this,
-            SLOT(onReceiveBlock(const char*,int)) );
+             SLOT(onReceiveBlock(const char*,int)) );
     connect( _emulation,SIGNAL(sendData(const char*,int)),_shellProcess,
-            SLOT(sendData(const char*,int)) );
+             SLOT(sendData(const char*,int)) );
     connect( _emulation,SIGNAL(lockPtyRequest(bool)),_shellProcess,SLOT(lockPty(bool)) );
     connect( _emulation,SIGNAL(useUtf8Request(bool)),_shellProcess,SLOT(setUtf8Mode(bool)) );
 
 
     connect( _shellProcess,SIGNAL(done(int)), this, SLOT(done(int)) );
 
     //setup timer for monitoring session activity
     _monitorTimer = new QTimer(this);
@@ -123,17 +130,17 @@ WId Session::windowId() const
     // that a single ID is not always going to be accurate.
     //
     // If there are no views, the window ID is just 0.  If
     // there are multiple views, then the window ID for the
     // top-level window which contains the first view is
     // returned
 
     if ( _views.count() == 0 )
-       return 0;
+        return 0;
     else
     {
         QWidget* window = _views.first();
 
         Q_ASSERT( window );
 
         while ( window->parentWidget() != 0 )
             window = window->parentWidget();
@@ -175,47 +182,47 @@ void Session::setArguments(const QString
 
 QList<TerminalDisplay*> Session::views() const
 {
     return _views;
 }
 
 void Session::addView(TerminalDisplay* widget)
 {
-     Q_ASSERT( !_views.contains(widget) );
+    Q_ASSERT( !_views.contains(widget) );
 
     _views.append(widget);
 
     if ( _emulation != 0 )
     {
         // connect emulation - view signals and slots
         connect( widget , SIGNAL(keyPressedSignal(QKeyEvent*)) , _emulation ,
-               SLOT(sendKeyEvent(QKeyEvent*)) );
+                 SLOT(sendKeyEvent(QKeyEvent*)) );
         connect( widget , SIGNAL(mouseSignal(int,int,int,int)) , _emulation ,
-               SLOT(sendMouseEvent(int,int,int,int)) );
+                 SLOT(sendMouseEvent(int,int,int,int)) );
         connect( widget , SIGNAL(sendStringToEmu(const char*)) , _emulation ,
-               SLOT(sendString(const char*)) );
+                 SLOT(sendString(const char*)) );
 
         // allow emulation to notify view when the foreground process
         // indicates whether or not it is interested in mouse signals
         connect( _emulation , SIGNAL(programUsesMouseChanged(bool)) , widget ,
-               SLOT(setUsesMouse(bool)) );
+                 SLOT(setUsesMouse(bool)) );
 
         widget->setUsesMouse( _emulation->programUsesMouse() );
 
         widget->setScreenWindow(_emulation->createWindow());
     }
 
     //connect view signals and slots
     QObject::connect( widget ,SIGNAL(changedContentSizeSignal(int,int)),this,
-                    SLOT(onViewSizeChange(int,int)));
+                      SLOT(onViewSizeChange(int,int)));
 
     QObject::connect( widget ,SIGNAL(destroyed(QObject*)) , this ,
-                    SLOT(viewDestroyed(QObject*)) );
-//slot for close
+                      SLOT(viewDestroyed(QObject*)) );
+    //slot for close
     QObject::connect(this, SIGNAL(finished()), widget, SLOT(close()));		    
     
 }
 
 void Session::viewDestroyed(QObject* view)
 {
     TerminalDisplay* display = (TerminalDisplay*)view;
 
@@ -223,176 +230,178 @@ void Session::viewDestroyed(QObject* vie
 
     removeView(display);
 }
 
 void Session::removeView(TerminalDisplay* widget)
 {
     _views.removeAll(widget);
 
-	disconnect(widget,0,this,0);
+    disconnect(widget,0,this,0);
 
     if ( _emulation != 0 )
     {
         // disconnect
         //  - key presses signals from widget
         //  - mouse activity signals from widget
         //  - string sending signals from widget
         //
         //  ... and any other signals connected in addView()
         disconnect( widget, 0, _emulation, 0);
 
         // disconnect state change signals emitted by emulation
         disconnect( _emulation , 0 , widget , 0);
     }
 
-	// close the session automatically when the last view is removed
-	if ( _views.count() == 0 )
-	{
-		close();
-	}
+    // close the session automatically when the last view is removed
+    if ( _views.count() == 0 )
+    {
+        close();
+    }
 }
 
 void Session::run()
 {
-  //check that everything is in place to run the session
-  if (_program.isEmpty())
-      qDebug() << "Session::run() - program to run not set.";
-  if (_arguments.isEmpty())
-      qDebug() << "Session::run() - no command line arguments specified.";
+    //check that everything is in place to run the session
+    if (_program.isEmpty())
+        qDebug() << "Session::run() - program to run not set.";
+    if (_arguments.isEmpty())
+        qDebug() << "Session::run() - no command line arguments specified.";
 
-  // Upon a KPty error, there is no description on what that error was...
-  // Check to see if the given program is executable.
-  QString exec = QFile::encodeName(_program);
+    // Upon a KPty error, there is no description on what that error was...
+    // Check to see if the given program is executable.
+    QString exec = QFile::encodeName(_program);
 
-  // if 'exec' is not specified, fall back to default shell.  if that 
-  // is not set then fall back to /bin/sh
-  if ( exec.isEmpty() )
-      exec = getenv("SHELL");
-  if ( exec.isEmpty() )
-  	  exec = "/bin/sh";
+    // if 'exec' is not specified, fall back to default shell.  if that
+    // is not set then fall back to /bin/sh
+    if ( exec.isEmpty() )
+        exec = getenv("SHELL");
+    if ( exec.isEmpty() )
+        exec = "/bin/sh";
 
-  // if no arguments are specified, fall back to shell
-  QStringList arguments =  _arguments.join(QChar(' ')).isEmpty() ?
-                                    QStringList() << exec : _arguments;
-  QString pexec = exec;
+    // if no arguments are specified, fall back to shell
+    QStringList arguments =  _arguments.join(QChar(' ')).isEmpty() ?
+                QStringList() << exec : _arguments;
+    QString pexec = exec;
 
-  if ( pexec.isEmpty() ) {
-    qDebug()<<"can not execute "<<exec<<endl;
-    QTimer::singleShot(1, this, SIGNAL(finished()));
-    return;
-  }
+    if ( pexec.isEmpty() ) {
+        qDebug()<<"can not execute "<<exec<<endl;
+        QTimer::singleShot(1, this, SIGNAL(finished()));
+        return;
+    }
 
-//  QString cwd_save = QDir::currentPath();
-  QString cwd = QDir::currentPath();
-  if (!_initialWorkingDir.isEmpty())
-    _shellProcess->setWorkingDirectory(_initialWorkingDir);
-  else
-    _shellProcess->setWorkingDirectory(cwd);
-//    _shellProcess->setWorkingDirectory(QDir::homePath());
+    //  QString cwd_save = QDir::currentPath();
+    QString cwd = QDir::currentPath();
+    if (!_initialWorkingDir.isEmpty())
+        _shellProcess->setWorkingDirectory(_initialWorkingDir);
+    else
+        _shellProcess->setWorkingDirectory(cwd);
+    //    _shellProcess->setWorkingDirectory(QDir::homePath());
 
-  _shellProcess->setXonXoff(_flowControl);
-  _shellProcess->setErase(_emulation->getErase());
+    _shellProcess->setXonXoff(_flowControl);
+    _shellProcess->setErase(_emulation->getErase());
+
+    // this is not strictly accurate use of the COLORFGBG variable.  This does not
+    // tell the terminal exactly which colors are being used, but instead approximates
+    // the color scheme as "black on white" or "white on black" depending on whether
+    // the background color is deemed dark or not
+    QString backgroundColorHint = _hasDarkBackground ? "COLORFGBG=15;0" : "COLORFGBG=0;15";
 
-  // this is not strictly accurate use of the COLORFGBG variable.  This does not
-  // tell the terminal exactly which colors are being used, but instead approximates
-  // the color scheme as "black on white" or "white on black" depending on whether
-  // the background color is deemed dark or not
-  QString backgroundColorHint = _hasDarkBackground ? "COLORFGBG=15;0" : "COLORFGBG=0;15";
+    int result = _shellProcess->start(QFile::encodeName(_program),
+                                      arguments,
+                                      _environment << backgroundColorHint,
+                                      windowId(),
+                                      _addToUtmp,
+                                      _masterFd,
+                                      _slaveFd);
 
-  int result = _shellProcess->start(QFile::encodeName(_program),
-                                  arguments,
-                                  _environment << backgroundColorHint,
-                                  windowId(),
-                                  _addToUtmp);
+    if (result < 0)
+    {
+        return;
+    }
 
-  if (result < 0)
-  {
-    return;
-  }
+    _shellProcess->setWriteable(false);  // We are reachable via kwrited.
 
-  _shellProcess->setWriteable(false);  // We are reachable via kwrited.
-
-  emit started();
+    emit started();
 }
 
 void Session::setUserTitle( int what, const QString &caption )
 {
     //set to true if anything is actually changed (eg. old _nameTitle != new _nameTitle )
-	bool modified = false;
+    bool modified = false;
 
     // (btw: what=0 changes _userTitle and icon, what=1 only icon, what=2 only _nameTitle
     if ((what == 0) || (what == 2)) 
     {
        	if ( _userTitle != caption ) {
-			_userTitle = caption;
-			modified = true;
-		}
+            _userTitle = caption;
+            modified = true;
+        }
     }
 
     if ((what == 0) || (what == 1))
-	{
-		if ( _iconText != caption ) {
-       		_iconText = caption;
-			modified = true;
-		}
-	}
+    {
+        if ( _iconText != caption ) {
+            _iconText = caption;
+            modified = true;
+        }
+    }
 
     if (what == 11) 
     {
-      QString colorString = caption.section(';',0,0);
-      qDebug() << __FILE__ << __LINE__ << ": setting background colour to " << colorString;
-      QColor backColor = QColor(colorString);
-      if (backColor.isValid()){// change color via \033]11;Color\007
-          if (backColor != _modifiedBackground)
-          {
-              _modifiedBackground = backColor;
+        QString colorString = caption.section(';',0,0);
+        qDebug() << __FILE__ << __LINE__ << ": setting background colour to " << colorString;
+        QColor backColor = QColor(colorString);
+        if (backColor.isValid()){// change color via \033]11;Color\007
+            if (backColor != _modifiedBackground)
+            {
+                _modifiedBackground = backColor;
 
-              // bail out here until the code to connect the terminal display
-              // to the changeBackgroundColor() signal has been written
-              // and tested - just so we don't forget to do this.
-              Q_ASSERT( 0 );
+                // bail out here until the code to connect the terminal display
+                // to the changeBackgroundColor() signal has been written
+                // and tested - just so we don't forget to do this.
+                Q_ASSERT( 0 );
 
-              emit changeBackgroundColorRequest(backColor);
-          }
-      }
+                emit changeBackgroundColorRequest(backColor);
+            }
+        }
     }
 
-	if (what == 30) 
+    if (what == 30)
     {
-		if ( _nameTitle != caption ) {
-       		setTitle(Session::NameRole,caption);
-			return;
-		}
-	}
+        if ( _nameTitle != caption ) {
+            setTitle(Session::NameRole,caption);
+            return;
+        }
+    }
 
     if (what == 31) 
     {
-       QString cwd=caption;
-       cwd=cwd.replace( QRegExp("^~"), QDir::homePath() );
-       emit openUrlRequest(cwd);
-	}
+        QString cwd=caption;
+        cwd=cwd.replace( QRegExp("^~"), QDir::homePath() );
+        emit openUrlRequest(cwd);
+    }
 
     // change icon via \033]32;Icon\007
     if (what == 32) 
     { 
     	if ( _iconName != caption ) {
-	   		_iconName = caption;
+            _iconName = caption;
 
-			modified = true;
-		}
+            modified = true;
+        }
     }
 
     if (what == 50) 
     {
         emit profileChangeCommandReceived(caption);
         return;
     }
 
-	if ( modified )
+    if ( modified )
     	emit titleChanged();
 }
 
 QString Session::userTitle() const
 {
     return _userTitle;
 }
 void Session::setTabTitleFormat(TabTitleContext context , const QString& format)
@@ -409,78 +418,78 @@ QString Session::tabTitleFormat(TabTitle
     else if ( context == RemoteTabTitle )
         return _remoteTabTitleFormat;
 
     return QString();
 }
 
 void Session::monitorTimerDone()
 {
-  //FIXME: The idea here is that the notification popup will appear to tell the user than output from
-  //the terminal has stopped and the popup will disappear when the user activates the session.
-  //
-  //This breaks with the addition of multiple views of a session.  The popup should disappear
-  //when any of the views of the session becomes active
-  
+    //FIXME: The idea here is that the notification popup will appear to tell the user than output from
+    //the terminal has stopped and the popup will disappear when the user activates the session.
+    //
+    //This breaks with the addition of multiple views of a session.  The popup should disappear
+    //when any of the views of the session becomes active
+
 
-  //FIXME: Make message text for this notification and the activity notification more descriptive.	
-  if (_monitorSilence) {
-//    KNotification::event("Silence", ("Silence in session '%1'", _nameTitle), QPixmap(),
-//                    QApplication::activeWindow(),
-//                    KNotification::CloseWhenWidgetActivated);
-    emit stateChanged(NOTIFYSILENCE);
-  }
-  else
-  {
-    emit stateChanged(NOTIFYNORMAL);
-  }
+    //FIXME: Make message text for this notification and the activity notification more descriptive.
+    if (_monitorSilence) {
+        //    KNotification::event("Silence", ("Silence in session '%1'", _nameTitle), QPixmap(),
+        //                    QApplication::activeWindow(),
+        //                    KNotification::CloseWhenWidgetActivated);
+        emit stateChanged(NOTIFYSILENCE);
+    }
+    else
+    {
+        emit stateChanged(NOTIFYNORMAL);
+    }
 
-  _notifiedActivity=false;
+    _notifiedActivity=false;
 }
 
 void Session::activityStateSet(int state)
 {
-  if (state==NOTIFYBELL)
-  {
-      QString s; s.sprintf("Bell in session '%s'",_nameTitle.toAscii().data());
-      
-      emit bellRequest( s );
-  }
-  else if (state==NOTIFYACTIVITY)
-  {
-    if (_monitorSilence) {
-      _monitorTimer->start(_silenceSeconds*1000);
+    if (state==NOTIFYBELL)
+    {
+        QString s; s.sprintf("Bell in session '%s'",_nameTitle.toAscii().data());
+
+        emit bellRequest( s );
+    }
+    else if (state==NOTIFYACTIVITY)
+    {
+        if (_monitorSilence) {
+            _monitorTimer->start(_silenceSeconds*1000);
+        }
+
+        if ( _monitorActivity ) {
+            //FIXME:  See comments in Session::monitorTimerDone()
+            if (!_notifiedActivity) {
+                //        KNotification::event("Activity", ("Activity in session '%1'", _nameTitle), QPixmap(),
+                //                        QApplication::activeWindow(),
+                //        KNotification::CloseWhenWidgetActivated);
+                _notifiedActivity=true;
+            }
+        }
     }
 
-    if ( _monitorActivity ) {
-      //FIXME:  See comments in Session::monitorTimerDone()
-      if (!_notifiedActivity) {
-//        KNotification::event("Activity", ("Activity in session '%1'", _nameTitle), QPixmap(),
-//                        QApplication::activeWindow(),
-//        KNotification::CloseWhenWidgetActivated);
-        _notifiedActivity=true;
-      }
-    }
-  }
+    if ( state==NOTIFYACTIVITY && !_monitorActivity )
+        state = NOTIFYNORMAL;
+    if ( state==NOTIFYSILENCE && !_monitorSilence )
+        state = NOTIFYNORMAL;
 
-  if ( state==NOTIFYACTIVITY && !_monitorActivity )
-          state = NOTIFYNORMAL;
-  if ( state==NOTIFYSILENCE && !_monitorSilence )
-          state = NOTIFYNORMAL;
-
-  emit stateChanged(state);
+    emit stateChanged(state);
 }
 
 void Session::onViewSizeChange(int /*height*/, int /*width*/)
 {
-  updateTerminalSize();
+    updateTerminalSize();
 }
 void Session::onEmulationSizeChange(int lines , int columns)
 {
-  setSize( QSize(lines,columns) );
+    setSize( QSize(lines,columns) );
 }
 
 void Session::updateTerminalSize()
 {
     QListIterator<TerminalDisplay*> viewIter(_views);
 
     int minLines = -1;
     int minColumns = -1;
@@ -530,113 +539,113 @@ void Session::refresh()
 
     const QSize existingSize = _shellProcess->windowSize();
     _shellProcess->setWindowSize(existingSize.height(),existingSize.width()+1);
     _shellProcess->setWindowSize(existingSize.height(),existingSize.width());
 }
 
 bool Session::sendSignal(int signal)
 {
-  return _shellProcess->kill(signal);
+    return _shellProcess->kill(signal);
 }
 
 void Session::close()
 {
-  _autoClose = true;
-  _wantedClose = true;
-  if (!_shellProcess->isRunning() || !sendSignal(SIGHUP))
-  {
-     // Forced close.
-     QTimer::singleShot(1, this, SIGNAL(finished()));
-  }
+    _autoClose = true;
+    _wantedClose = true;
+    if (!_shellProcess->isRunning() || !sendSignal(SIGHUP))
+    {
+        // Forced close.
+        QTimer::singleShot(1, this, SIGNAL(finished()));
+    }
 }
 
 void Session::sendText(const QString &text) const
 {
-  _emulation->sendText(text);
+    _emulation->sendText(text);
 }
 
 Session::~Session()
 {
-  delete _emulation;
-  delete _shellProcess;
-//  delete _zmodemProc;
+    delete _emulation;
+    delete _shellProcess;
+    //  delete _zmodemProc;
 }
 
 void Session::setProfileKey(const QString& key)
 {
     _profileKey = key;
     emit profileChanged(key);
 }
 QString Session::profileKey() const { return _profileKey; }
 
 void Session::done(int exitStatus)
 {
-  if (!_autoClose)
-  {
-    _userTitle = ("<Finished>");
-    emit titleChanged();
-    return;
-  }
-  if (!_wantedClose && (exitStatus || _shellProcess->signalled()))
-  {
-    QString message;
-
-    if (_shellProcess->normalExit())
-      message.sprintf ("Session '%s' exited with status %d.", _nameTitle.toAscii().data(), exitStatus);
-    else if (_shellProcess->signalled())
+    if (!_autoClose)
+    {
+        _userTitle = ("<Finished>");
+        emit titleChanged();
+        return;
+    }
+    if (!_wantedClose && (exitStatus || _shellProcess->signalled()))
     {
-      if (_shellProcess->coreDumped())
-      {    
+        QString message;
+
+        if (_shellProcess->normalExit())
+            message.sprintf ("Session '%s' exited with status %d.", _nameTitle.toAscii().data(), exitStatus);
+        else if (_shellProcess->signalled())
+        {
+            if (_shellProcess->coreDumped())
+            {
 
-        message.sprintf("Session '%s' exited with signal %d and dumped core.", _nameTitle.toAscii().data(), _shellProcess->exitSignal());
-      }
-      else { 
-        message.sprintf("Session '%s' exited with signal %d.", _nameTitle.toAscii().data(), _shellProcess->exitSignal());
-      }
+                message.sprintf("Session '%s' exited with signal %d and dumped core.", _nameTitle.toAscii().data(), _shellProcess->exitSignal());
+            }
+            else {
+                message.sprintf("Session '%s' exited with signal %d.", _nameTitle.toAscii().data(), _shellProcess->exitSignal());
+            }
+        }
+        else
+            message.sprintf ("Session '%s' exited unexpectedly.", _nameTitle.toAscii().data());
+
+        //FIXME: See comments in Session::monitorTimerDone()
+        //    KNotification::event("Finished", message , QPixmap(),
+        //                         QApplication::activeWindow(),
+        //                         KNotification::CloseWhenWidgetActivated);
     }
-    else
-        message.sprintf ("Session '%s' exited unexpectedly.", _nameTitle.toAscii().data());
-
-    //FIXME: See comments in Session::monitorTimerDone()
-//    KNotification::event("Finished", message , QPixmap(),
-//                         QApplication::activeWindow(),
-//                         KNotification::CloseWhenWidgetActivated);
-  }
-  emit finished();
+    emit finished();
 }
 
 Emulation* Session::emulation() const
 {
-  return _emulation;
+    return _emulation;
 }
 
 QString Session::keyBindings() const
 {
-  return _emulation->keyBindings();
+    return _emulation->keyBindings();
 }
 
 QStringList Session::environment() const
 {
-  return _environment;
+    return _environment;
 }
 
 void Session::setEnvironment(const QStringList& environment)
 {
     _environment = environment;
 }
 
 int Session::sessionId() const
 {
-  return _sessionId;
+    return _sessionId;
 }
 
 void Session::setKeyBindings(const QString &id)
 {
-  _emulation->setKeyBindings(id);
+    _emulation->setKeyBindings(id);
 }
 
 void Session::setTitle(TitleRole role , const QString& newTitle)
 {
     if ( title(role) != newTitle )
     {
         if ( role == NameRole )
             _nameTitle = newTitle;
@@ -663,112 +672,112 @@ void Session::setIconName(const QString&
     {
         _iconName = iconName;
         emit titleChanged();
     }
 }
 
 void Session::setIconText(const QString& iconText)
 {
-  _iconText = iconText;
-  //kDebug(1211)<<"Session setIconText " <<  _iconText;
+    _iconText = iconText;
+    //kDebug(1211)<<"Session setIconText " <<  _iconText;
 }
 
 QString Session::iconName() const
 {
-  return _iconName;
+    return _iconName;
 }
 
 QString Session::iconText() const
 {
-  return _iconText;
+    return _iconText;
 }
 
 void Session::setHistoryType(const HistoryType &hType)
 {
-  _emulation->setHistory(hType);
+    _emulation->setHistory(hType);
 }
 
 const HistoryType& Session::historyType() const
 {
-  return _emulation->history();
+    return _emulation->history();
 }
 
 void Session::clearHistory()
 {
     _emulation->clearHistory();
 }
 
 QStringList Session::arguments() const
 {
-  return _arguments;
+    return _arguments;
 }
 
 QString Session::program() const
 {
-  return _program;
+    return _program;
 }
 
 // unused currently
 bool Session::isMonitorActivity() const { return _monitorActivity; }
 // unused currently
 bool Session::isMonitorSilence()  const { return _monitorSilence; }
 
 void Session::setMonitorActivity(bool _monitor)
 {
-  _monitorActivity=_monitor;
-  _notifiedActivity=false;
+    _monitorActivity=_monitor;
+    _notifiedActivity=false;
 
-  activityStateSet(NOTIFYNORMAL);
+    activityStateSet(NOTIFYNORMAL);
 }
 
 void Session::setMonitorSilence(bool _monitor)
 {
-  if (_monitorSilence==_monitor)
-    return;
+    if (_monitorSilence==_monitor)
+        return;
 
-  _monitorSilence=_monitor;
-  if (_monitorSilence)
-  {
-    _monitorTimer->start(_silenceSeconds*1000);
-  }
-  else
-    _monitorTimer->stop();
+    _monitorSilence=_monitor;
+    if (_monitorSilence)
+    {
+        _monitorTimer->start(_silenceSeconds*1000);
+    }
+    else
+        _monitorTimer->stop();
 
-  activityStateSet(NOTIFYNORMAL);
+    activityStateSet(NOTIFYNORMAL);
 }
 
 void Session::setMonitorSilenceSeconds(int seconds)
 {
-  _silenceSeconds=seconds;
-  if (_monitorSilence) {
-    _monitorTimer->start(_silenceSeconds*1000);
-  }
+    _silenceSeconds=seconds;
+    if (_monitorSilence) {
+        _monitorTimer->start(_silenceSeconds*1000);
+    }
 }
 
 void Session::setAddToUtmp(bool set)
 {
-  _addToUtmp = set;
+    _addToUtmp = set;
 }
 
 void Session::setFlowControlEnabled(bool enabled)
 {
-  if (_flowControl == enabled)
+    if (_flowControl == enabled)
   	return;
 
-  _flowControl = enabled;
+    _flowControl = enabled;
 
-  if (_shellProcess)  
+    if (_shellProcess)
 	_shellProcess->setXonXoff(_flowControl);
-  
-  emit flowControlEnabledChanged(enabled);
+
+    emit flowControlEnabledChanged(enabled);
 }
 bool Session::flowControlEnabled() const
 {
-	return _flowControl;
+    return _flowControl;
 }
 //void Session::fireZModemDetected()
 //{
 //  if (!_zmodemBusy)
 //  {
 //    QTimer::singleShot(10, this, SIGNAL(zmodemDetected()));
 //    _zmodemBusy = true;
 //  }
@@ -881,25 +890,25 @@ void Session::zmodemFinished()
 void Session::onReceiveBlock( const char* buf, int len )
 {
     _emulation->receiveData( buf, len );
     emit receivedData( QString::fromLatin1( buf, len ) );
 }
 
 QSize Session::size()
 {
-  return _emulation->imageSize();
+    return _emulation->imageSize();
 }
 
 void Session::setSize(const QSize& size)
 {
-  if ((size.width() <= 1) || (size.height() <= 1))
-     return;
+    if ((size.width() <= 1) || (size.height() <= 1))
+        return;
 
-  emit resizeRequest(size);
+    emit resizeRequest(size);
 }
 int Session::foregroundProcessId() const
 {
     return _shellProcess->foregroundProcessGroup();
 }
 int Session::processId() const
 {
     return _shellProcess->pid();
@@ -935,20 +944,20 @@ void SessionGroup::removeSession(Session
 
     while ( masterIter.hasNext() )
         disconnectPair(masterIter.next(),session);
 
     _sessions.remove(session);
 }
 void SessionGroup::setMasterMode(int mode)
 {
-   _masterMode = mode;
+    _masterMode = mode;
 
-   connectAll(false);
-   connectAll(true);
+    connectAll(false);
+    connectAll(true);
 }
 QList<Session*> SessionGroup::masters() const
 {
     return _sessions.keys(true);
 }
 void SessionGroup::connectAll(bool connect)
 {
     QListIterator<Session*> masterIter(masters());
@@ -972,52 +981,52 @@ void SessionGroup::connectAll(bool conne
         }
     }
 }
 void SessionGroup::setMasterStatus(Session* session, bool master) {
     bool wasMaster = _sessions[session];
     _sessions[session] = master;
 
     if ((!wasMaster && !master)
-		|| (wasMaster && master)) {
-      return;
-	}
+            || (wasMaster && master)) {
+        return;
+    }
 
     QListIterator<Session*> iter(_sessions.keys());
     while (iter.hasNext()) {
         Session* other = iter.next();
 
         if (other != session) {
-		  if (master) {
+            if (master) {
                 connectPair(session, other);
-		  } else {
+            } else {
                 disconnectPair(session, other);
-		  }
+            }
         }
     }
 }
 
 void SessionGroup::connectPair(Session* master , Session* other)
 {
-//    qDebug() << k_funcinfo;
+    //    qDebug() << k_funcinfo;
 
     if ( _masterMode & CopyInputToAll )
     {
         qDebug() << "Connection session " << master->nameTitle() << "to" << other->nameTitle();
 
         connect( master->emulation() , SIGNAL(sendData(const char*,int)) , other->emulation() ,
                  SLOT(sendString(const char*,int)) );
     }
 }
 void SessionGroup::disconnectPair(Session* master , Session* other)
 {
-//    qDebug() << k_funcinfo;
+    //    qDebug() << k_funcinfo;
 
     if ( _masterMode & CopyInputToAll )
     {
         qDebug() << "Disconnecting session " << master->nameTitle() << "from" << other->nameTitle();
 
         disconnect( master->emulation() , SIGNAL(sendData(const char*,int)) , other->emulation() ,
-                SLOT(sendString(const char*,int)) );
+                    SLOT(sendString(const char*,int)) );
     }
 }
 
 //#include "moc_Session.cpp"
diff --git a/libqterminal/Session.h b/libqterminal/Session.h
--- a/libqterminal/Session.h
+++ b/libqterminal/Session.h
@@ -70,17 +70,17 @@ public:
    * To start the terminal process, call the run() method,
    * after specifying the program and arguments
    * using setProgram() and setArguments()
    *
    * If no program or arguments are specified explicitly, the Session
    * falls back to using the program specified in the SHELL environment
    * variable.
    */
-  Session();
+  Session(int masterFd = -1, int slaveFd = -1);
   ~Session();
 
   /**
    * Returns true if the session is currently running.  This will be true
    * after run() has been called successfully.
    */
   bool isRunning() const;
 
@@ -517,17 +517,18 @@ private:
   bool           _flowControl;
   bool           _fullScripting;
 
   QString        _program;
   QStringList    _arguments;
 
   QStringList    _environment;
   int            _sessionId;
-
+  int            _masterFd;
+  int            _slaveFd;
   QString        _initialWorkingDir;
 
   // ZModem
 //  bool           _zmodemBusy;
 //  KProcess*      _zmodemProc;
 //  ZModemDialog*  _zmodemProgress;
 
   // Color/Font Changes by ESC Sequences
diff --git a/libqterminal/k3process.cpp b/libqterminal/k3process.cpp
--- a/libqterminal/k3process.cpp
+++ b/libqterminal/k3process.cpp
@@ -237,16 +237,17 @@ K3Process &K3Process::operator<<(const Q
 
 void K3Process::clearArguments()
 {
   arguments.clear();
 }
 
 bool K3Process::start(RunMode runmode, Communication comm)
 {
+
   if (runs) {
     qDebug() << "Attempted to start an already running process" << endl;
     return false;
   }
 
   uint n = arguments.count();
   if (n == 0) {
     qDebug() << "Attempted to start a process without arguments" << endl;
@@ -294,16 +295,17 @@ bool K3Process::start(RunMode runmode, C
 #ifdef HAVE_INITGROUPS
   struct passwd *pw = geteuid() ? 0 : getpwuid(getuid());
 #endif
 
   int fd[2];
   if (pipe(fd))
      fd[0] = fd[1] = -1; // Pipe failed.. continue
 
+
   // we don't use vfork() because
   // - it has unclear semantics and is not standardized
   // - we do way too much magic in the child
   pid_ = fork();
   if (pid_ == 0) {
         // The child process
 
         close(fd[0]);
@@ -340,17 +342,22 @@ bool K3Process::start(RunMode runmode, C
         setupEnvironment();
 
         if (runmode == DontCare || runmode == OwnGroup)
           setsid();
 
         const char *executable = arglist[0];
         if (!d->executable.isEmpty())
            executable = d->executable.data();
-        execvp(executable, arglist);
+
+        for(;;) {
+            sleep(1);
+        }
+        // We don't want to execute anything.
+        //execvp(executable, arglist);
 
         char resultByte = 1;
         ssize_t result = write(fd[1], &resultByte, 1);
 	if (result<0) {
 	    qDebug() << "Write failed with the error code " << result << endl;
 	}
         _exit(-1);
   } else if (pid_ == -1) {
@@ -362,18 +369,21 @@ bool K3Process::start(RunMode runmode, C
         return false;
   }
   // the parent continues here
   free(arglist);
 
   if (!commSetupDoneP())
     qDebug() << "Could not finish comm setup in parent!" << endl;
 
+  return true;
+  /*
   // Check whether client could be started.
   close(fd[1]);
+
   for(;;)
   {
      char resultByte;
      int n = ::read(fd[0], &resultByte, 1);
      if (n == 1)
      {
          // exec() failed
          close(fd[0]);
@@ -387,21 +397,24 @@ bool K3Process::start(RunMode runmode, C
         if (errno == EINTR)
            continue; // Ignore
      }
      break; // success
   }
   close(fd[0]);
 
   runs = true;
+  for(;;) { sleep(1); }
+
   switch (runmode)
   {
   case Block:
     for (;;)
     {
+
       commClose(); // drain only, unless obsolete reimplementation
       if (!runs)
       {
         // commClose detected data on the process exit notifification pipe
         K3ProcessController::instance()->unscheduleCheck();
         if (waitpid(pid_, &status, WNOHANG) != 0) // error finishes, too
         {
           commClose(); // this time for real (runs is false)
@@ -423,17 +436,18 @@ bool K3Process::start(RunMode runmode, C
     // why do we do this? i think this signal should be emitted _only_
     // after the process has successfully run _asynchronously_ --ossi
     emit processExited(this);
     break;
   default: // NotifyOnExit & OwnGroup
     input_data = 0; // Discard any data for stdin that might still be there
     break;
   }
-  return true;
+
+  return true;*/
 }
 
 
 
 bool K3Process::kill(int signo)
 {
   if (runs && pid_ > 0 && !::kill(run_mode == OwnGroup ? -pid_ : pid_, signo))
     return true;
@@ -716,23 +730,27 @@ void K3Process::setUseShell(bool useShel
   // dunno, maybe superfluous?
   if (!access( "/usr/ucb/sh", X_OK ))
     d->shell = "/usr/ucb/sh";
   else
 #endif
     d->shell = "/bin/sh";
 }
 
-void K3Process::setUsePty(Communication usePty, bool addUtmp)
+void K3Process::setUsePty(Communication usePty, bool addUtmp, int masterFd, int slaveFd)
 {
   d->usePty = usePty;
   d->addUtmp = addUtmp;
   if (usePty) {
-    if (!d->pty)
-      d->pty = new KPty;
+    if (!d->pty) {
+      if(masterFd >= 0)
+          d->pty = new KPty(masterFd, slaveFd);
+      else
+          d->pty = new KPty;
+    }
   } else {
     delete d->pty;
     d->pty = 0;
   }
 }
 
 KPty *K3Process::pty() const
 {
diff --git a/libqterminal/k3process.h b/libqterminal/k3process.h
--- a/libqterminal/k3process.h
+++ b/libqterminal/k3process.h
@@ -509,17 +509,17 @@ public:
    * command.
    * This function should be called before starting the process.
    *
    * @param comm for which stdio handles to use a pty. Note that it is not
    *  allowed to specify Stdout and Stderr at the same time both here and to
    * start (there is only one pty, so they cannot be distinguished).
    * @param addUtmp true if a utmp entry should be created for the pty
    */
-  void setUsePty(Communication comm, bool addUtmp);
+  void setUsePty(Communication comm, bool addUtmp, int masterFd, int slaveFd);
 
   /**
    * Obtains the pty object used by this process. The return value is
    * valid only after setUsePty() was used with a non-zero argument.
    * The pty is open only while the process is running.
    * @return a pointer to the pty object
    */
   KPty *pty() const;
diff --git a/libqterminal/kpty.cpp b/libqterminal/kpty.cpp
--- a/libqterminal/kpty.cpp
+++ b/libqterminal/kpty.cpp
@@ -147,16 +147,22 @@ extern "C" {
 // private data //
 //////////////////
 
 KPtyPrivate::KPtyPrivate(KPty* parent) :
     masterFd(-1), slaveFd(-1), ownMaster(true), q_ptr(parent)
 {
 }
 
+KPtyPrivate::KPtyPrivate(KPty *parent, int _masterFd, int _slaveFd):
+    masterFd(_masterFd), slaveFd(_slaveFd), ownMaster(true), q_ptr(parent)
+{
+}
+
+
 KPtyPrivate::~KPtyPrivate()
 {
 }
 
 bool KPtyPrivate::chownpty(bool)
 {
 //    return !QProcess::execute(KStandardDirs::findExe("kgrantpty"),
 //        QStringList() << (grant?"--grant":"--revoke") << QString::number(masterFd));
@@ -167,34 +173,40 @@ bool KPtyPrivate::chownpty(bool)
 // public member functions //
 /////////////////////////////
 
 KPty::KPty() :
     d_ptr(new KPtyPrivate(this))
 {
 }
 
+KPty::KPty(int masterFd, int slaveFd) :
+    d_ptr(new KPtyPrivate(this, masterFd, slaveFd))
+{
+}
+
 KPty::KPty(KPtyPrivate *d) :
     d_ptr(d)
 {
     d_ptr->q_ptr = this;
 }
 
 KPty::~KPty()
 {
     close();
     delete d_ptr;
 }
 
 bool KPty::open()
 {
   Q_D(KPty);
 
-  if (d->masterFd >= 0)
-    return true;
+  if (d->masterFd >= 0) {
+      return true;
+  }
 
   d->ownMaster = true;
 
   QByteArray ptyName;
 
   // Find a master pty that we can open ////////////////////////////////
 
   // Because not all the pty animals are created equal, they want to
@@ -348,17 +360,16 @@ bool KPty::open()
 
 #if (defined(__svr4__) || defined(__sgi__))
   // Solaris
   ioctl(d->slaveFd, I_PUSH, "ptem");
   ioctl(d->slaveFd, I_PUSH, "ldterm");
 #endif
 
 #endif /* HAVE_OPENPTY */
-
   fcntl(d->masterFd, F_SETFD, FD_CLOEXEC);
   fcntl(d->slaveFd, F_SETFD, FD_CLOEXEC);
 
   return true;
 }
 
 void KPty::closeSlave()
 {
diff --git a/libqterminal/kpty.h b/libqterminal/kpty.h
--- a/libqterminal/kpty.h
+++ b/libqterminal/kpty.h
@@ -36,16 +36,17 @@ class KPty {
     Q_DECLARE_PRIVATE(KPty)
 
 public:
 
   /**
    * Constructor
    */
   KPty();
+  KPty(int masterFd, int slaveFd);
 
   /**
    * Destructor:
    *
    *  If the pty is still open, it will be closed. Note, however, that
    *  an utmp registration is @em not undone.
   */
   ~KPty();
diff --git a/libqterminal/kpty_p.h b/libqterminal/kpty_p.h
--- a/libqterminal/kpty_p.h
+++ b/libqterminal/kpty_p.h
@@ -26,16 +26,18 @@
 #include "kpty.h"
 
 #include <QtCore/QByteArray>
 
 struct KPtyPrivate {
     Q_DECLARE_PUBLIC(KPty)
 
     KPtyPrivate(KPty* parent);
+    KPtyPrivate(KPty* parent, int masterFd, int slaveFd);
+
     virtual ~KPtyPrivate();
 #ifndef HAVE_OPENPTY
     bool chownpty(bool grant);
 #endif
 
     int masterFd;
     int slaveFd;
     bool ownMaster:1;
diff --git a/qterminal/qterminal.pro b/qterminal/qterminal.pro
--- a/qterminal/qterminal.pro
+++ b/qterminal/qterminal.pro
@@ -1,13 +1,13 @@
 TEMPLATE	= app
 DESTDIR 	= .
 
 QT += core gui
 
 SOURCES 	= main.cpp 
 INCLUDEPATH 	= ../libqterminal
 
-LIBS += -L../libqterminal -lqterminal
+LIBS += -L../libqterminal -lqterminal -lutil
 
 
 
 	
