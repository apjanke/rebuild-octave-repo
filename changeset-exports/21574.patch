# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1459529869 14400
#      Fri Apr 01 12:57:49 2016 -0400
# Node ID ae4d7dfea337ca2af6216cf72758ef899fb9adf6
# Parent  feac06371be1871391a0de26d2d9b6a075be2e91
# Parent  f3f8e1d3e39937f8fde12082f170e8aa5b466bdc
maint: merge stable to default.

diff --git a/libinterp/corefcn/Cell.cc b/libinterp/corefcn/Cell.cc
--- a/libinterp/corefcn/Cell.cc
+++ b/libinterp/corefcn/Cell.cc
@@ -334,16 +334,23 @@ Cell::map (ctype_mapper fcn) const
   const octave_value *p = data ();
 
   for (octave_idx_type i = 0; i < numel (); i++)
     r[i] = ((p++)->*fcn) ();
 
   return retval;
 }
 
+octave_value
+Cell::resize_fill_value (void) const
+{
+  static octave_value rfv = octave_value (Matrix ());
+  return rfv;
+}
+
 Cell
 Cell::diag (octave_idx_type k) const
 {
   return Array<octave_value>::diag (k);
 }
 
 Cell
 Cell::diag (octave_idx_type m, octave_idx_type n) const
diff --git a/libinterp/corefcn/Cell.h b/libinterp/corefcn/Cell.h
--- a/libinterp/corefcn/Cell.h
+++ b/libinterp/corefcn/Cell.h
@@ -106,21 +106,17 @@ public:
 
   Cell& insert (const Cell& a, octave_idx_type r, octave_idx_type c);
   Cell& insert (const Cell& a, const Array<octave_idx_type>& ra_idx);
 
   // FIXME
   bool any_element_is_nan (void) const { return false; }
   bool is_true (void) const { return false; }
 
-  octave_value resize_fill_value (void) const
-  {
-    static Matrix rfv;
-    return rfv;
-  }
+  octave_value resize_fill_value (void) const;
 
   Cell diag (octave_idx_type k = 0) const;
 
   Cell diag (octave_idx_type m, octave_idx_type n) const;
 
   Cell xisalnum (void) const { return map (&octave_value::xisalnum); }
   Cell xisalpha (void) const { return map (&octave_value::xisalpha); }
   Cell xisascii (void) const { return map (&octave_value::xisascii); }
diff --git a/libinterp/corefcn/oct-map.cc b/libinterp/corefcn/oct-map.cc
--- a/libinterp/corefcn/oct-map.cc
+++ b/libinterp/corefcn/oct-map.cc
@@ -28,16 +28,23 @@ along with Octave; see the file COPYING.
 #include "Array-util.h"
 #include "error.h"
 #include "oct-locbuf.h"
 #include "str-vec.h"
 
 #include "oct-map.h"
 #include "utils.h"
 
+octave_fields::fields_rep *
+octave_fields::nil_rep (void)
+{
+  static fields_rep nr;
+  return &nr;
+}
+
 octave_fields::octave_fields (const string_vector& fields)
   : rep (new fields_rep)
 {
   octave_idx_type n = fields.numel ();
   for (octave_idx_type i = 0; i < n; i++)
     (*rep)[fields(i)] = i;
 }
 
diff --git a/libinterp/corefcn/oct-map.h b/libinterp/corefcn/oct-map.h
--- a/libinterp/corefcn/oct-map.h
+++ b/libinterp/corefcn/oct-map.h
@@ -48,21 +48,17 @@ octave_fields
     octave_refcount<int> count;
 
   private:
     fields_rep& operator = (const fields_rep&); // no assignment!
   };
 
   fields_rep *rep;
 
-  static fields_rep *nil_rep (void)
-  {
-    static fields_rep nr;
-    return &nr;
-  }
+  static fields_rep *nil_rep (void);
 
 public:
 
   octave_fields (void) : rep (nil_rep ()) { rep->count++; }
   octave_fields (const string_vector&);
   octave_fields (const char * const *);
 
   ~octave_fields (void)
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -44,16 +44,18 @@ along with Octave; see the file COPYING.
 #include "pager.h"
 #include "parse.h"
 #include "pt-arg-list.h"
 #include "pt-pr-code.h"
 #include "symtab.h"
 #include "unwind-prot.h"
 #include "utils.h"
 
+octave_value symbol_table::dummy_octave_value;
+
 symbol_table *symbol_table::instance = 0;
 
 symbol_table::scope_id_cache *symbol_table::scope_id_cache::instance = 0;
 
 std::map<symbol_table::scope_id, symbol_table*> symbol_table::all_instances;
 
 std::map<std::string, octave_value> symbol_table::global_table;
 
@@ -146,16 +148,18 @@ symbol_table::symbol_record::find (const
                 rep->finfo = get_fcn_info (name ());
             }
         }
     }
 
   return retval;
 }
 
+symbol_table::symbol_record symbol_table::dummy_symbol_record;
+
 static void
 split_name_with_package (const std::string& name, std::string& fname,
                          std::string& pname)
 {
   size_t pos = name.rfind ('.');
 
   fname.clear ();
   pname.clear ();
diff --git a/libinterp/corefcn/symtab.h b/libinterp/corefcn/symtab.h
--- a/libinterp/corefcn/symtab.h
+++ b/libinterp/corefcn/symtab.h
@@ -44,16 +44,18 @@ class octave_user_function;
 #include "ov.h"
 
 class
 OCTINTERP_API
 symbol_table
 {
 public:
 
+  static octave_value dummy_octave_value;
+
   typedef int scope_id;
   typedef size_t context_id;
 
   class
   scope_id_cache
   {
   protected:
 
@@ -257,22 +259,20 @@ public:
             symbol_table::global_table_iterator p
               = symbol_table::global_table.find (name);
 
             return (p == symbol_table::global_table.end ())
                    ? symbol_table::global_table[name] : p->second;
           }
         else if (is_persistent ())
           {
-            static octave_value foobar;
-
             symbol_table *inst
               = symbol_table::get_instance (symbol_table::current_scope ());
 
-            return inst ? inst->do_persistent_varref (name) : foobar;
+            return inst ? inst->do_persistent_varref (name) : dummy_octave_value;
           }
         else
           {
             if (context == xdefault_context)
               context = active_context ();
 
             context_id n = value_stack.size ();
             while (n++ <= context)
@@ -649,16 +649,18 @@ public:
 
   private:
 
     symbol_record_rep *rep;
 
     symbol_record (symbol_record_rep *new_rep) : rep (new_rep) { }
   };
 
+  static symbol_record dummy_symbol_record;
+
   // Always access a symbol from the current scope.
   // Useful for scripts, as they may be executed in more than one scope.
   class
   symbol_reference
   {
   public:
 
     symbol_reference (void) : scope (-1) { }
@@ -1305,21 +1307,19 @@ public:
         bool local_funcs = true);
 
   static octave_value builtin_find (const std::string& name);
 
   // Insert a new name in the table.
   static symbol_record& insert (const std::string& name,
                                 scope_id scope = xcurrent_scope)
   {
-    static symbol_record foobar;
-
     symbol_table *inst = get_instance (scope);
 
-    return inst ? inst->do_insert (name) : foobar;
+    return inst ? inst->do_insert (name) : symbol_table::dummy_symbol_record;
   }
 
   static void rename (const std::string& old_name,
                       const std::string& new_name,
                       scope_id scope = xcurrent_scope)
   {
     symbol_table *inst = get_instance (scope);
 
@@ -1328,34 +1328,30 @@ public:
   }
 
   static void assign (const std::string& name,
                       const octave_value& value = octave_value (),
                       scope_id scope = xcurrent_scope,
                       context_id context = xdefault_context,
                       bool force_add = false)
   {
-    static octave_value foobar;
-
     symbol_table *inst = get_instance (scope);
 
     if (inst)
       inst->do_assign (name, value, context, force_add);
   }
 
   OCTAVE_DEPRECATED ("use 'assign' instead")
   static octave_value&
   varref (const std::string& name, scope_id scope = xcurrent_scope,
           context_id context = xdefault_context, bool force_add = false)
   {
-    static octave_value foobar;
-
     symbol_table *inst = get_instance (scope);
 
-    return inst ? inst->do_varref (name, context, force_add) : foobar;
+    return inst ? inst->do_varref (name, context, force_add) : dummy_octave_value;
   }
 
   // Convenience function to simplify
   // octave_user_function::bind_automatic_vars
 
   static void force_assign (const std::string& name,
                             const octave_value& value = octave_value (),
                             scope_id scope = xcurrent_scope,
@@ -1364,21 +1360,19 @@ public:
     assign (name, value, scope, context, true);
   }
 
   OCTAVE_DEPRECATED ("use 'force_assign' instead")
   static octave_value&
   force_varref (const std::string& name, scope_id scope = xcurrent_scope,
                 context_id context = xdefault_context)
   {
-    static octave_value foobar;
-
     symbol_table *inst = get_instance (scope);
 
-    return inst ? inst->do_varref (name, context, true) : foobar;
+    return inst ? inst->do_varref (name, context, true) : dummy_octave_value;
   }
 
   static octave_value varval (const std::string& name,
                               scope_id scope = xcurrent_scope,
                               context_id context = xdefault_context)
   {
     symbol_table *inst = get_instance (scope);
 
@@ -1422,21 +1416,19 @@ public:
   {
     assign (name, value, top_scope (), 0);
   }
 
   OCTAVE_DEPRECATED ("use 'top_level_assign' instead")
   static octave_value&
   top_level_varref (const std::string& name)
   {
-    static octave_value foobar;
-
     symbol_table *inst = get_instance (top_scope ());
 
-    return inst ? inst->do_varref (name, 0, true) : foobar;
+    return inst ? inst->do_varref (name, 0, true) : dummy_octave_value;
   }
 
   static octave_value
   top_level_varval (const std::string& name)
   {
     return varval (name, top_scope (), 0);
   }
 
@@ -1449,21 +1441,19 @@ public:
     if (inst)
       inst->do_persistent_assign (name, value);
   }
 
   OCTAVE_DEPRECATED ("use 'persistent_assign' instead")
   static octave_value&
   persistent_varref (const std::string& name)
   {
-    static octave_value foobar;
-
     symbol_table *inst = get_instance (xcurrent_scope);
 
-    return inst ? inst->do_persistent_varref (name) : foobar;
+    return inst ? inst->do_persistent_varref (name) : dummy_octave_value;
   }
 
   static octave_value persistent_varval (const std::string& name)
   {
     symbol_table *inst = get_instance (xcurrent_scope);
 
     return inst ? inst->do_persistent_varval (name) : octave_value ();
   }
diff --git a/libinterp/octave-value/ov-base-scalar.cc b/libinterp/octave-value/ov-base-scalar.cc
--- a/libinterp/octave-value/ov-base-scalar.cc
+++ b/libinterp/octave-value/ov-base-scalar.cc
@@ -95,16 +95,24 @@ octave_base_scalar<ST>::subsasgn (const 
     default:
       panic_impossible ();
     }
 
   return retval;
 }
 
 template <typename ST>
+dim_vector
+octave_base_scalar<ST>::dims (void) const
+{
+  static dim_vector dv (1, 1);
+  return dv;
+}
+
+template <typename ST>
 octave_value
 octave_base_scalar<ST>::permute (const Array<int>& vec, bool inv) const
 {
   return Array<ST> (dim_vector (1, 1), scalar).permute (vec, inv);
 }
 
 template <typename ST>
 octave_value
diff --git a/libinterp/octave-value/ov-base-scalar.h b/libinterp/octave-value/ov-base-scalar.h
--- a/libinterp/octave-value/ov-base-scalar.h
+++ b/libinterp/octave-value/ov-base-scalar.h
@@ -74,17 +74,17 @@ public:
 
   octave_value_list do_multi_index_op (int, const octave_value_list& idx)
   { return do_index_op (idx); }
 
   bool is_constant (void) const { return true; }
 
   bool is_defined (void) const { return true; }
 
-  dim_vector dims (void) const { static dim_vector dv (1, 1); return dv; }
+  dim_vector dims (void) const;
 
   octave_idx_type numel (void) const { return 1; }
 
   int ndims (void) const { return 2; }
 
   octave_idx_type nnz (void) const { return (scalar != ST ()) ? 1 : 0; }
 
   octave_value permute (const Array<int>&, bool = false) const;
diff --git a/libinterp/octave-value/ov-bool.cc b/libinterp/octave-value/ov-bool.cc
--- a/libinterp/octave-value/ov-bool.cc
+++ b/libinterp/octave-value/ov-bool.cc
@@ -40,16 +40,22 @@ along with Octave; see the file COPYING.
 #include "ov-base-scalar.cc"
 #include "ov-re-mat.h"
 #include "ov-scalar.h"
 #include "pr-output.h"
 
 #include "ls-oct-text.h"
 #include "ls-hdf5.h"
 
+// Prevent implicit instantiations on some systems (Windows, others?)
+// that can lead to duplicate definitions of static data members.
+
+extern template class OCTINTERP_API octave_base_scalar<double>;
+
+
 template class octave_base_scalar<bool>;
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_bool, "bool", "logical");
 
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -38,18 +38,16 @@ along with Octave; see the file COPYING.
 #include "pt-funcall.h"
 #include "pt-misc.h"
 #include "pt-stmt.h"
 #include "pt-walk.h"
 #include "singleton-cleanup.h"
 #include "symtab.h"
 #include "toplev.h"
 
-#include "Array.cc"
-
 // Define to 1 to enable debugging statements.
 #define DEBUG_TRACE 0
 
 OCTAVE_NORETURN static
 void
 err_method_access (const std::string& from, const cdef_method& meth)
 {
   octave_value acc = meth.get ("Access");
diff --git a/libinterp/octave-value/ov-complex.cc b/libinterp/octave-value/ov-complex.cc
--- a/libinterp/octave-value/ov-complex.cc
+++ b/libinterp/octave-value/ov-complex.cc
@@ -45,16 +45,23 @@ along with Octave; see the file COPYING.
 #include "ov-scalar.h"
 #include "errwarn.h"
 #include "pr-output.h"
 #include "ops.h"
 
 #include "ls-oct-text.h"
 #include "ls-hdf5.h"
 
+// Prevent implicit instantiations on some systems (Windows, others?)
+// that can lead to duplicate definitions of static data members.
+
+extern template class OCTINTERP_API octave_base_scalar<double>;
+extern template class OCTINTERP_API octave_base_scalar<FloatComplex>;
+
+
 template class octave_base_scalar<Complex>;
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_complex,
                                      "complex scalar", "double");
 
 // Complain if a complex value is used as a subscript.
 
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -221,16 +221,23 @@ octave_fcn_handle::do_multi_index_op (in
         retval = fcn.do_multi_index_op (nargout, args, lvalue_list);
       else
         error ("%s: no longer valid function handle", nm.c_str ());
     }
 
   return retval;
 }
 
+dim_vector
+octave_fcn_handle::dims (void) const
+{
+  static dim_vector dv (1, 1);
+  return dv;
+}
+
 bool
 octave_fcn_handle::is_equal_to (const octave_fcn_handle& h) const
 {
   bool retval = fcn.is_copy_of (h.fcn) && (has_overloads == h.has_overloads);
   retval = retval && (overloads.size () == h.overloads.size ());
 
   if (retval && has_overloads)
     {
diff --git a/libinterp/octave-value/ov-fcn-handle.h b/libinterp/octave-value/ov-fcn-handle.h
--- a/libinterp/octave-value/ov-fcn-handle.h
+++ b/libinterp/octave-value/ov-fcn-handle.h
@@ -101,17 +101,17 @@ public:
   bool is_defined (void) const { return true; }
 
   bool is_function_handle (void) const { return true; }
 
   builtin_type_t builtin_type (void) const { return btyp_func_handle; }
 
   bool is_overloaded (void) const { return has_overloads; }
 
-  dim_vector dims (void) const { static dim_vector dv (1, 1); return dv; }
+  dim_vector dims (void) const;
 
   octave_function *function_value (bool = false)
   { return fcn.function_value (); }
 
   octave_user_function *user_function_value (bool = false)
   { return fcn.user_function_value (); }
 
   octave_fcn_handle *fcn_handle_value (bool = false) { return this; }
diff --git a/libinterp/octave-value/ov-flt-complex.cc b/libinterp/octave-value/ov-flt-complex.cc
--- a/libinterp/octave-value/ov-flt-complex.cc
+++ b/libinterp/octave-value/ov-flt-complex.cc
@@ -44,16 +44,22 @@ along with Octave; see the file COPYING.
 #include "ov-flt-complex.h"
 #include "errwarn.h"
 #include "pr-output.h"
 #include "ops.h"
 
 #include "ls-oct-text.h"
 #include "ls-hdf5.h"
 
+// Prevent implicit instantiations on some systems (Windows, others?)
+// that can lead to duplicate definitions of static data members.
+
+extern template class OCTINTERP_API octave_base_scalar<float>;
+
+
 template class octave_base_scalar<FloatComplex>;
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_float_complex,
                                      "float complex scalar", "single");
 
 octave_base_value *
 octave_float_complex::try_narrowing_conversion (void)
diff --git a/libinterp/octave-value/ov-int16.cc b/libinterp/octave-value/ov-int16.cc
--- a/libinterp/octave-value/ov-int16.cc
+++ b/libinterp/octave-value/ov-int16.cc
@@ -51,16 +51,22 @@ along with Octave; see the file COPYING.
 #include "pr-output.h"
 #include "variables.h"
 
 #include "byte-swap.h"
 #include "ls-oct-text.h"
 #include "ls-utils.h"
 #include "ls-hdf5.h"
 
+// Prevent implicit instantiations on some systems (Windows, others?)
+// that can lead to duplicate definitions of static data members.
+
+extern template class OCTINTERP_API octave_base_scalar<double>;
+
+
 template class octave_base_matrix<int16NDArray>;
 
 template class octave_base_int_matrix<int16NDArray>;
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int16_matrix,
                                      "int16 matrix", "int16");
 
diff --git a/libinterp/octave-value/ov-int32.cc b/libinterp/octave-value/ov-int32.cc
--- a/libinterp/octave-value/ov-int32.cc
+++ b/libinterp/octave-value/ov-int32.cc
@@ -51,16 +51,22 @@ along with Octave; see the file COPYING.
 #include "pr-output.h"
 #include "variables.h"
 
 #include "byte-swap.h"
 #include "ls-oct-text.h"
 #include "ls-utils.h"
 #include "ls-hdf5.h"
 
+// Prevent implicit instantiations on some systems (Windows, others?)
+// that can lead to duplicate definitions of static data members.
+
+extern template class OCTINTERP_API octave_base_scalar<double>;
+
+
 template class octave_base_matrix<int32NDArray>;
 
 template class octave_base_int_matrix<int32NDArray>;
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int32_matrix,
                                      "int32 matrix", "int32");
 
diff --git a/libinterp/octave-value/ov-int64.cc b/libinterp/octave-value/ov-int64.cc
--- a/libinterp/octave-value/ov-int64.cc
+++ b/libinterp/octave-value/ov-int64.cc
@@ -51,16 +51,22 @@ along with Octave; see the file COPYING.
 #include "pr-output.h"
 #include "variables.h"
 
 #include "byte-swap.h"
 #include "ls-oct-text.h"
 #include "ls-utils.h"
 #include "ls-hdf5.h"
 
+// Prevent implicit instantiations on some systems (Windows, others?)
+// that can lead to duplicate definitions of static data members.
+
+extern template class OCTINTERP_API octave_base_scalar<double>;
+
+
 template class octave_base_matrix<int64NDArray>;
 
 template class octave_base_int_matrix<int64NDArray>;
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int64_matrix,
                                      "int64 matrix", "int64");
 
diff --git a/libinterp/octave-value/ov-int8.cc b/libinterp/octave-value/ov-int8.cc
--- a/libinterp/octave-value/ov-int8.cc
+++ b/libinterp/octave-value/ov-int8.cc
@@ -51,16 +51,22 @@ along with Octave; see the file COPYING.
 #include "pr-output.h"
 #include "variables.h"
 
 #include "byte-swap.h"
 #include "ls-oct-text.h"
 #include "ls-utils.h"
 #include "ls-hdf5.h"
 
+// Prevent implicit instantiations on some systems (Windows, others?)
+// that can lead to duplicate definitions of static data members.
+
+extern template class OCTINTERP_API octave_base_scalar<double>;
+
+
 template class octave_base_matrix<int8NDArray>;
 
 template class octave_base_int_matrix<int8NDArray>;
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int8_matrix,
                                      "int8 matrix", "int8");
 
diff --git a/libinterp/octave-value/ov-scalar.cc b/libinterp/octave-value/ov-scalar.cc
--- a/libinterp/octave-value/ov-scalar.cc
+++ b/libinterp/octave-value/ov-scalar.cc
@@ -47,16 +47,22 @@ along with Octave; see the file COPYING.
 #include "pr-output.h"
 #include "xdiv.h"
 #include "xpow.h"
 #include "ops.h"
 
 #include "ls-oct-text.h"
 #include "ls-hdf5.h"
 
+// Prevent implicit instantiations on some systems (Windows, others?)
+// that can lead to duplicate definitions of static data members.
+
+extern template class OCTINTERP_API octave_base_scalar<float>;
+
+
 template class octave_base_scalar<double>;
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_scalar, "scalar", "double");
 
 static octave_base_value *
 default_numeric_demotion_function (const octave_base_value& a)
 {
diff --git a/libinterp/octave-value/ov-uint16.cc b/libinterp/octave-value/ov-uint16.cc
--- a/libinterp/octave-value/ov-uint16.cc
+++ b/libinterp/octave-value/ov-uint16.cc
@@ -51,16 +51,22 @@ along with Octave; see the file COPYING.
 #include "pr-output.h"
 #include "variables.h"
 
 #include "byte-swap.h"
 #include "ls-oct-text.h"
 #include "ls-utils.h"
 #include "ls-hdf5.h"
 
+// Prevent implicit instantiations on some systems (Windows, others?)
+// that can lead to duplicate definitions of static data members.
+
+extern template class OCTINTERP_API octave_base_scalar<double>;
+
+
 template class octave_base_matrix<uint16NDArray>;
 
 template class octave_base_int_matrix<uint16NDArray>;
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint16_matrix,
                                      "uint16 matrix", "uint16");
 
diff --git a/libinterp/octave-value/ov-uint32.cc b/libinterp/octave-value/ov-uint32.cc
--- a/libinterp/octave-value/ov-uint32.cc
+++ b/libinterp/octave-value/ov-uint32.cc
@@ -51,16 +51,22 @@ along with Octave; see the file COPYING.
 #include "pr-output.h"
 #include "variables.h"
 
 #include "byte-swap.h"
 #include "ls-oct-text.h"
 #include "ls-utils.h"
 #include "ls-hdf5.h"
 
+// Prevent implicit instantiations on some systems (Windows, others?)
+// that can lead to duplicate definitions of static data members.
+
+extern template class OCTINTERP_API octave_base_scalar<double>;
+
+
 template class octave_base_matrix<uint32NDArray>;
 
 template class octave_base_int_matrix<uint32NDArray>;
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint32_matrix,
                                      "uint32 matrix", "uint32");
 
diff --git a/libinterp/octave-value/ov-uint64.cc b/libinterp/octave-value/ov-uint64.cc
--- a/libinterp/octave-value/ov-uint64.cc
+++ b/libinterp/octave-value/ov-uint64.cc
@@ -51,16 +51,22 @@ along with Octave; see the file COPYING.
 #include "pr-output.h"
 #include "variables.h"
 
 #include "byte-swap.h"
 #include "ls-oct-text.h"
 #include "ls-utils.h"
 #include "ls-hdf5.h"
 
+// Prevent implicit instantiations on some systems (Windows, others?)
+// that can lead to duplicate definitions of static data members.
+
+extern template class OCTINTERP_API octave_base_scalar<double>;
+
+
 template class octave_base_matrix<uint64NDArray>;
 
 template class octave_base_int_matrix<uint64NDArray>;
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint64_matrix,
                                      "uint64 matrix", "uint64");
 
diff --git a/libinterp/octave-value/ov-uint8.cc b/libinterp/octave-value/ov-uint8.cc
--- a/libinterp/octave-value/ov-uint8.cc
+++ b/libinterp/octave-value/ov-uint8.cc
@@ -51,16 +51,22 @@ along with Octave; see the file COPYING.
 #include "pr-output.h"
 #include "variables.h"
 
 #include "byte-swap.h"
 #include "ls-oct-text.h"
 #include "ls-utils.h"
 #include "ls-hdf5.h"
 
+// Prevent implicit instantiations on some systems (Windows, others?)
+// that can lead to duplicate definitions of static data members.
+
+extern template class OCTINTERP_API octave_base_scalar<double>;
+
+
 template class octave_base_matrix<uint8NDArray>;
 
 template class octave_base_int_matrix<uint8NDArray>;
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint8_matrix,
                                      "uint8 matrix", "uint8");
 
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -103,16 +103,23 @@ static bool Vdisable_permutation_matrix 
 // If TRUE, don't create special range objects.
 
 static bool Vdisable_range = false;
 
 // FIXME
 
 // Octave's value type.
 
+octave_base_value *
+octave_value::nil_rep (void)
+{
+  static octave_base_value nr;
+  return &nr;
+}
+
 std::string
 octave_value::unary_op_as_string (unary_op op)
 {
   switch (op)
     {
     case op_not:
       return "!";
 
diff --git a/libinterp/octave-value/ov.h b/libinterp/octave-value/ov.h
--- a/libinterp/octave-value/ov.h
+++ b/libinterp/octave-value/ov.h
@@ -162,19 +162,18 @@ public:
   static std::string assign_op_as_string (assign_op);
 
   static octave_value empty_conv (const std::string& type,
                                   const octave_value& rhs = octave_value ());
 
   enum magic_colon { magic_colon_t };
 
   octave_value (void)
+    : rep (nil_rep ())
   {
-    static octave_base_value nil_rep;
-    rep = &nil_rep;
     rep->count++;
   }
 
   octave_value (short int i);
   octave_value (unsigned short int i);
   octave_value (int i);
   octave_value (unsigned int i);
   octave_value (long int i);
@@ -1420,16 +1419,18 @@ public:
 
 protected:
 
   // The real representation.
   octave_base_value *rep;
 
 private:
 
+  static octave_base_value *nil_rep (void);
+
   assign_op unary_op_to_assign_op (unary_op op);
 
   binary_op op_eq_to_binary_op (assign_op op);
 
   // This declaration protects against constructing octave_value from
   // const octave_base_value* which actually silently calls octave_value (bool).
   octave_value (const octave_base_value *);
 
diff --git a/libinterp/template-inst/Array-jit.cc b/libinterp/template-inst/Array-jit.cc
--- a/libinterp/template-inst/Array-jit.cc
+++ b/libinterp/template-inst/Array-jit.cc
@@ -26,19 +26,23 @@ along with Octave; see the file COPYING.
 #  include "config.h"
 #endif
 
 #ifdef HAVE_LLVM
 
 #include "Array.h"
 #include "Array.cc"
 
-extern template class OCTAVE_API Array<octave_idx_type>;
+#include "jit-ir.h"
 
-#include "jit-ir.h"
+// Prevent implicit instantiations on some systems (Windows, others?)
+// that can lead to duplicate definitions of static data members.
+
+extern template class OCTAVE_API Array<idx_vector>;
+extern template class OCTAVE_API Array<octave_idx_type>;
 
 NO_INSTANTIATE_ARRAY_SORT (jit_function);
 
 INSTANTIATE_ARRAY (jit_function, OCTINTERP_API);
 
 #ifdef Cell_h
 #  error Must not include Cell.h in Array-jit.h
 #  error This causes problems on MSVC
diff --git a/libinterp/template-inst/Array-tc.cc b/libinterp/template-inst/Array-tc.cc
--- a/libinterp/template-inst/Array-tc.cc
+++ b/libinterp/template-inst/Array-tc.cc
@@ -25,14 +25,30 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #  include "config.h"
 #endif
 
 #include "Array.h"
 #include "Array.cc"
 
 #include "ov.h"
+#include "ov-classdef.h"
 
 #include "oct-sort.cc"
 
-NO_INSTANTIATE_ARRAY_SORT (octave_value);
+// Prevent implicit instantiations on some systems (Windows, others?)
+// that can lead to duplicate definitions of static data members.
 
+extern template class OCTAVE_API Array<Complex>;
+extern template class OCTAVE_API Array<FloatComplex>;
+extern template class OCTAVE_API Array<bool>;
+extern template class OCTAVE_API Array<char>;
+extern template class OCTAVE_API Array<double>;
+extern template class OCTAVE_API Array<float>;
+extern template class OCTAVE_API Array<idx_vector>;
+extern template class OCTAVE_API Array<octave_idx_type>;
+extern template class OCTAVE_API Array<std::string>;
+
+NO_INSTANTIATE_ARRAY_SORT (octave_value);
 INSTANTIATE_ARRAY (octave_value, OCTINTERP_API);
+
+NO_INSTANTIATE_ARRAY_SORT (cdef_object);
+INSTANTIATE_ARRAY (cdef_object, OCTINTERP_API);
diff --git a/liboctave/array/Array-C.cc b/liboctave/array/Array-C.cc
--- a/liboctave/array/Array-C.cc
+++ b/liboctave/array/Array-C.cc
@@ -29,16 +29,22 @@ along with Octave; see the file COPYING.
 
 #include "oct-cmplx.h"
 #include "lo-mappers.h"
 
 #include "Array.h"
 #include "Array.cc"
 #include "oct-sort.cc"
 
+// Prevent implicit instantiations on some systems (Windows, others?)
+// that can lead to duplicate definitions of static data members.
+
+extern template class OCTAVE_API Array<idx_vector>;
+extern template class OCTAVE_API Array<octave_idx_type>;
+
 template <>
 inline bool
 sort_isnan<Complex> (const Complex& x)
 {
   return xisnan (x);
 }
 
 // Sort Criteria: 1) isnan, 2) magnitude of z, 3) phase of z in range (-pi, pi]
diff --git a/liboctave/array/Array-b.cc b/liboctave/array/Array-b.cc
--- a/liboctave/array/Array-b.cc
+++ b/liboctave/array/Array-b.cc
@@ -23,20 +23,27 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #  include "config.h"
 #endif
 
 // Instantiate Arrays of bool values.
 
 #include "Array.h"
 #include "Array.cc"
+
 #define INLINE_ASCENDING_SORT 1
 #define INLINE_DESCENDING_SORT 1
 #include "oct-sort.cc"
 
+// Prevent implicit instantiations on some systems (Windows, others?)
+// that can lead to duplicate definitions of static data members.
+
+extern template class OCTAVE_API Array<idx_vector>;
+extern template class OCTAVE_API Array<octave_idx_type>;
+
 // Specialize bool sorting (aka stable partitioning).
 
 template <bool desc>
 static void do_bool_partition (bool *data, octave_idx_type nel)
 {
   octave_idx_type k = 0;
   for (octave_idx_type i = 0; i < nel; i++)
     if (data[i] == desc)
diff --git a/liboctave/array/Array-ch.cc b/liboctave/array/Array-ch.cc
--- a/liboctave/array/Array-ch.cc
+++ b/liboctave/array/Array-ch.cc
@@ -23,20 +23,27 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #  include "config.h"
 #endif
 
 // Instantiate Arrays of char values.
 
 #include "Array.h"
 #include "Array.cc"
+
 #define INLINE_ASCENDING_SORT 1
 #define INLINE_DESCENDING_SORT 1
 #include "oct-sort.cc"
 
+// Prevent implicit instantiations on some systems (Windows, others?)
+// that can lead to duplicate definitions of static data members.
+
+extern template class OCTAVE_API Array<idx_vector>;
+extern template class OCTAVE_API Array<octave_idx_type>;
+
 template class OCTAVE_API octave_sort<char>;
 
 INSTANTIATE_ARRAY (char, OCTAVE_API);
 
 template OCTAVE_API std::ostream& operator << (std::ostream&,
                                                const Array<char>&);
 
 #include "DiagArray2.h"
diff --git a/liboctave/array/Array-d.cc b/liboctave/array/Array-d.cc
--- a/liboctave/array/Array-d.cc
+++ b/liboctave/array/Array-d.cc
@@ -31,16 +31,22 @@ along with Octave; see the file COPYING.
 #include "Array.h"
 #include "Array.cc"
 #include "oct-locbuf.h"
 
 #define INLINE_ASCENDING_SORT 1
 #define INLINE_DESCENDING_SORT 1
 #include "oct-sort.cc"
 
+// Prevent implicit instantiations on some systems (Windows, others?)
+// that can lead to duplicate definitions of static data members.
+
+extern template class OCTAVE_API Array<idx_vector>;
+extern template class OCTAVE_API Array<octave_idx_type>;
+
 template <>
 inline bool
 sort_isnan<double> (double x)
 {
   return xisnan (x);
 }
 
 static bool
diff --git a/liboctave/array/Array-f.cc b/liboctave/array/Array-f.cc
--- a/liboctave/array/Array-f.cc
+++ b/liboctave/array/Array-f.cc
@@ -31,16 +31,22 @@ along with Octave; see the file COPYING.
 #include "Array.h"
 #include "Array.cc"
 #include "oct-locbuf.h"
 
 #define INLINE_ASCENDING_SORT 1
 #define INLINE_DESCENDING_SORT 1
 #include "oct-sort.cc"
 
+// Prevent implicit instantiations on some systems (Windows, others?)
+// that can lead to duplicate definitions of static data members.
+
+extern template class OCTAVE_API Array<idx_vector>;
+extern template class OCTAVE_API Array<octave_idx_type>;
+
 template <>
 inline bool
 sort_isnan<float> (float x)
 {
   return xisnan (x);
 }
 
 static bool
diff --git a/liboctave/array/Array-fC.cc b/liboctave/array/Array-fC.cc
--- a/liboctave/array/Array-fC.cc
+++ b/liboctave/array/Array-fC.cc
@@ -29,16 +29,22 @@ along with Octave; see the file COPYING.
 
 #include "oct-cmplx.h"
 #include "lo-mappers.h"
 
 #include "Array.h"
 #include "Array.cc"
 #include "oct-sort.cc"
 
+// Prevent implicit instantiations on some systems (Windows, others?)
+// that can lead to duplicate definitions of static data members.
+
+extern template class OCTAVE_API Array<idx_vector>;
+extern template class OCTAVE_API Array<octave_idx_type>;
+
 template <>
 inline bool
 sort_isnan<FloatComplex> (const FloatComplex& x)
 {
   return xisnan (x);
 }
 
 // Sort Criteria: 1) isnan, 2) magnitude of z, 3) phase of z in range (-pi, pi]
diff --git a/liboctave/array/Array-i.cc b/liboctave/array/Array-i.cc
--- a/liboctave/array/Array-i.cc
+++ b/liboctave/array/Array-i.cc
@@ -30,16 +30,21 @@ along with Octave; see the file COPYING.
 
 #include "Array.h"
 #include "Array.cc"
 
 #define INLINE_ASCENDING_SORT 1
 #define INLINE_DESCENDING_SORT 1
 #include "oct-sort.cc"
 
+// Prevent implicit instantiations on some systems (Windows, others?)
+// that can lead to duplicate definitions of static data members.
+
+extern template class OCTAVE_API Array<idx_vector>;
+
 template class OCTAVE_API octave_sort<int>;
 template class OCTAVE_API octave_sort<long>;
 #if defined (OCTAVE_HAVE_LONG_LONG_INT)
 template class OCTAVE_API octave_sort<long long>;
 #endif
 
 INSTANTIATE_ARRAY (int, OCTAVE_API);
 INSTANTIATE_ARRAY (long, OCTAVE_API);
diff --git a/liboctave/array/Array-idx-vec.cc b/liboctave/array/Array-idx-vec.cc
--- a/liboctave/array/Array-idx-vec.cc
+++ b/liboctave/array/Array-idx-vec.cc
@@ -26,11 +26,16 @@ along with Octave; see the file COPYING.
 
 // Instantiate Arrays of integer values.
 
 #include "idx-vector.h"
 
 #include "Array.h"
 #include "Array.cc"
 
+// Prevent implicit instantiations on some systems (Windows, others?)
+// that can lead to duplicate definitions of static data members.
+
+extern template class OCTAVE_API Array<octave_idx_type>;
+
 NO_INSTANTIATE_ARRAY_SORT (idx_vector);
 
 INSTANTIATE_ARRAY (idx_vector, OCTAVE_API);
diff --git a/liboctave/array/Array-s.cc b/liboctave/array/Array-s.cc
--- a/liboctave/array/Array-s.cc
+++ b/liboctave/array/Array-s.cc
@@ -28,16 +28,22 @@ along with Octave; see the file COPYING.
 
 #include "Array.h"
 #include "Array.cc"
 
 #define INLINE_ASCENDING_SORT 1
 #define INLINE_DESCENDING_SORT 1
 #include "oct-sort.cc"
 
+// Prevent implicit instantiations on some systems (Windows, others?)
+// that can lead to duplicate definitions of static data members.
+
+extern template class OCTAVE_API Array<idx_vector>;
+extern template class OCTAVE_API Array<octave_idx_type>;
+
 template class OCTAVE_API octave_sort<short>;
 
 INSTANTIATE_ARRAY (short, OCTAVE_API);
 
 #include "DiagArray2.h"
 #include "DiagArray2.cc"
 
 template class DiagArray2<short>;
diff --git a/liboctave/array/Array-str.cc b/liboctave/array/Array-str.cc
--- a/liboctave/array/Array-str.cc
+++ b/liboctave/array/Array-str.cc
@@ -25,13 +25,20 @@ along with Octave; see the file COPYING.
 #endif
 
 #include <string>
 
 // Instantiate Arrays of strings.
 
 #include "Array.h"
 #include "Array.cc"
+
 #include "oct-sort.cc"
 
+// Prevent implicit instantiations on some systems (Windows, others?)
+// that can lead to duplicate definitions of static data members.
+
+extern template class OCTAVE_API Array<idx_vector>;
+extern template class OCTAVE_API Array<octave_idx_type>;
+
 template class OCTAVE_API octave_sort<std::string>;
 
 INSTANTIATE_ARRAY (std::string, OCTAVE_API);
diff --git a/liboctave/array/Array-voidp.cc b/liboctave/array/Array-voidp.cc
--- a/liboctave/array/Array-voidp.cc
+++ b/liboctave/array/Array-voidp.cc
@@ -26,11 +26,17 @@ along with Octave; see the file COPYING.
 
 #include <string>
 
 // Instantiate Arrays of void *.
 
 #include "Array.h"
 #include "Array.cc"
 
+// Prevent implicit instantiations on some systems (Windows, others?)
+// that can lead to duplicate definitions of static data members.
+
+extern template class OCTAVE_API Array<idx_vector>;
+extern template class OCTAVE_API Array<octave_idx_type>;
+
 NO_INSTANTIATE_ARRAY_SORT (void *);
 
 INSTANTIATE_ARRAY (void *, OCTAVE_API);
diff --git a/liboctave/array/Array.cc b/liboctave/array/Array.cc
--- a/liboctave/array/Array.cc
+++ b/liboctave/array/Array.cc
@@ -40,16 +40,24 @@ along with Octave; see the file COPYING.
 #include "idx-vector.h"
 #include "lo-error.h"
 #include "oct-locbuf.h"
 
 // One dimensional array class.  Handles the reference counting for
 // all the derived classes.
 
 template <typename T>
+typename Array<T>::ArrayRep *
+Array<T>::nil_rep (void)
+{
+  static ArrayRep nr;
+  return &nr;
+}
+
+template <typename T>
 Array<T>::Array (const Array<T>& a, const dim_vector& dv)
   : dimensions (dv), rep (a.rep),
     slice_data (a.slice_data), slice_len (a.slice_len)
 {
   if (dimensions.safe_numel () != a.numel ())
     {
       std::string dimensions_str = a.dimensions.str ();
       std::string new_dims_str = dimensions.str ();
diff --git a/liboctave/array/Array.h b/liboctave/array/Array.h
--- a/liboctave/array/Array.h
+++ b/liboctave/array/Array.h
@@ -146,25 +146,17 @@ protected:
     : dimensions (dv), rep(a.rep), slice_data (a.slice_data+l), slice_len (u-l)
   {
     rep->count++;
     dimensions.chop_trailing_singletons ();
   }
 
 private:
 
-  typename Array<T>::ArrayRep *nil_rep (void) const
-  {
-    // NR was originally allocated with new, but that does not seem
-    // to be necessary since it will never be deleted.  So just use
-    // a static object instead.
-
-    static typename Array<T>::ArrayRep nr;
-    return &nr;
-  }
+  static typename Array<T>::ArrayRep *nil_rep (void);
 
 protected:
 
   //! For jit support
   Array (T *sdata, octave_idx_type slen, octave_idx_type *adims, void *arep)
     : dimensions (adims),
       rep (reinterpret_cast<typename Array<T>::ArrayRep *> (arep)),
       slice_data (sdata), slice_len (slen) { }
diff --git a/liboctave/array/DiagArray2.cc b/liboctave/array/DiagArray2.cc
--- a/liboctave/array/DiagArray2.cc
+++ b/liboctave/array/DiagArray2.cc
@@ -84,16 +84,32 @@ DiagArray2<T>
 DiagArray2<T>::hermitian (T (* fcn) (const T&)) const
 {
   return DiagArray2<T> (Array<T>::template map<T> (fcn), d2, d1);
 }
 
 // A two-dimensional array with diagonal elements only.
 
 template <typename T>
+T&
+DiagArray2<T>::elem (octave_idx_type r, octave_idx_type c)
+{
+  static T zero (0);
+  return (r == c) ? Array<T>::elem (r) : zero;
+}
+
+template <typename T>
+T&
+DiagArray2<T>::checkelem (octave_idx_type r, octave_idx_type c)
+{
+  static T zero (0);
+  return check_idx (r, c) ? elem (r, c) : zero;
+}
+
+template <typename T>
 void
 DiagArray2<T>::resize (octave_idx_type r, octave_idx_type c,
                        const T& rfv)
 {
   if (r < 0 || c < 0)
     (*current_liboctave_error_handler) ("can't resize to negative dimensions");
 
   if (r != dim1 () || c != dim2 ())
diff --git a/liboctave/array/DiagArray2.h b/liboctave/array/DiagArray2.h
--- a/liboctave/array/DiagArray2.h
+++ b/liboctave/array/DiagArray2.h
@@ -111,21 +111,17 @@ public:
   // Warning: the non-const two-index versions will silently ignore assignments
   // to off-diagonal elements.
 
   T elem (octave_idx_type r, octave_idx_type c) const
   {
     return (r == c) ? Array<T>::elem (r) : T (0);
   }
 
-  T& elem (octave_idx_type r, octave_idx_type c)
-  {
-    static T zero (0);
-    return (r == c) ? Array<T>::elem (r) : zero;
-  }
+  T& elem (octave_idx_type r, octave_idx_type c);
 
   T dgelem (octave_idx_type i) const
   { return Array<T>::elem (i); }
 
   T& dgelem (octave_idx_type i)
   { return Array<T>::elem (i); }
 
   T checkelem (octave_idx_type r, octave_idx_type c) const
@@ -137,21 +133,17 @@ public:
   {
 #if defined (OCTAVE_ENABLE_BOUNDS_CHECK)
     return checkelem (r, c);
 #else
     return elem (r, c);
 #endif
   }
 
-  T& checkelem (octave_idx_type r, octave_idx_type c)
-  {
-    static T zero (0);
-    return check_idx (r, c) ? elem (r, c) : zero;
-  }
+  T& checkelem (octave_idx_type r, octave_idx_type c);
 
   T& operator () (octave_idx_type r, octave_idx_type c)
   {
 #if defined (OCTAVE_ENABLE_BOUNDS_CHECK)
     return checkelem (r, c);
 #else
     return elem (r, c);
 #endif
diff --git a/liboctave/array/Sparse.cc b/liboctave/array/Sparse.cc
--- a/liboctave/array/Sparse.cc
+++ b/liboctave/array/Sparse.cc
@@ -48,16 +48,24 @@ along with Octave; see the file COPYING.
 #include "sparse-sort.h"
 #include "sparse-util.h"
 #include "oct-spparms.h"
 #include "mx-inlines.cc"
 
 #include "PermMatrix.h"
 
 template <typename T>
+typename Sparse<T>::SparseRep *
+Sparse<T>::nil_rep (void)
+{
+  static typename Sparse<T>::SparseRep nr;
+  return &nr;
+}
+
+template <typename T>
 Sparse<T>::Sparse (const PermMatrix& a)
   : rep (new typename Sparse<T>::SparseRep (a.rows (), a.cols (), a.rows ())),
     dimensions (dim_vector (a.rows (), a.cols ()))
 {
   octave_idx_type n = a.rows ();
   for (octave_idx_type i = 0; i <= n; i++)
     cidx (i) = i;
 
diff --git a/liboctave/array/Sparse.h b/liboctave/array/Sparse.h
--- a/liboctave/array/Sparse.h
+++ b/liboctave/array/Sparse.h
@@ -164,21 +164,17 @@ public:
   // should not access these data members directly!
 
   typename Sparse<T>::SparseRep *rep;
 
   dim_vector dimensions;
 
 private:
 
-  typename Sparse<T>::SparseRep *nil_rep (void) const
-  {
-    static typename Sparse<T>::SparseRep nr;
-    return &nr;
-  }
+  static typename Sparse<T>::SparseRep *nil_rep (void);
 
 public:
 
   Sparse (void)
     : rep (nil_rep ()), dimensions (dim_vector(0,0))
   {
     rep->count++;
   }
diff --git a/liboctave/array/dim-vector.cc b/liboctave/array/dim-vector.cc
--- a/liboctave/array/dim-vector.cc
+++ b/liboctave/array/dim-vector.cc
@@ -24,16 +24,23 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #  include "config.h"
 #endif
 
 #include <iostream>
 
 #include "dim-vector.h"
 
+octave_idx_type *
+dim_vector::nil_rep (void)
+{
+  static dim_vector zv (0, 0);
+  return zv.rep;
+}
+
 // The maximum allowed value for a dimension extent. This will normally be a
 // tiny bit off the maximum value of octave_idx_type.
 // Currently 1 is subtracted to allow safe conversion of any 2D Array into
 // Sparse, but this offset may change in the future.
 octave_idx_type
 dim_vector::dim_max (void)
 {
   return std::numeric_limits<octave_idx_type>::max () - 1;
diff --git a/liboctave/array/dim-vector.h b/liboctave/array/dim-vector.h
--- a/liboctave/array/dim-vector.h
+++ b/liboctave/array/dim-vector.h
@@ -271,21 +271,17 @@ public:
   // WARNING: Only call by jit
   octave_idx_type *to_jit (void) const
   {
     return rep;
   }
 
 private:
 
-  static octave_idx_type *nil_rep (void)
-  {
-    static dim_vector zv (0, 0);
-    return zv.rep;
-  }
+  static octave_idx_type *nil_rep (void);
 
 public:
 
   static octave_idx_type dim_max (void);
 
   explicit dim_vector (void) : rep (nil_rep ())
   { OCTREFCOUNT_ATOMIC_INCREMENT (&(count())); }
 
diff --git a/liboctave/array/idx-vector.cc b/liboctave/array/idx-vector.cc
--- a/liboctave/array/idx-vector.cc
+++ b/liboctave/array/idx-vector.cc
@@ -49,16 +49,31 @@ err_invalid_range (void)
 
 static void
 err_index_out_of_range (void)
 {
   (*current_liboctave_error_handler)
     ("internal error: idx_vector index out of range");
 }
 
+idx_vector::idx_vector_rep *
+idx_vector::nil_rep (void)
+{
+  static idx_vector_rep ivr;
+  return &ivr;
+}
+
+idx_vector::idx_vector_rep *
+idx_vector::err_rep (void)
+{
+  static idx_vector_rep ivr;
+  ivr.err = true;
+  return &ivr;
+}
+
 Array<octave_idx_type>
 idx_vector::idx_base_rep::as_array (void)
 {
   (*current_liboctave_error_handler)
     ("internal error: as_array not allowed for this index class");
 
   // Never actually executed, but required to silence compiler warning
   return Array<octave_idx_type> ();
diff --git a/liboctave/array/idx-vector.h b/liboctave/array/idx-vector.h
--- a/liboctave/array/idx-vector.h
+++ b/liboctave/array/idx-vector.h
@@ -428,29 +428,20 @@ private:
 
     dim_vector orig_dims;
   };
 
   idx_vector (idx_base_rep *r) : rep (r) { }
 
   // The shared empty vector representation (for fast default
   // constructor).
-  static idx_vector_rep *nil_rep (void)
-  {
-    static idx_vector_rep ivr;
-    return &ivr;
-  }
+  static idx_vector_rep *nil_rep (void);
 
   // The shared empty vector representation with the error flag set.
-  static idx_vector_rep *err_rep (void)
-  {
-    static idx_vector_rep ivr;
-    ivr.err = true;
-    return &ivr;
-  }
+  static idx_vector_rep *err_rep (void);
 
   // If there was an error in constructing the rep, replace it with
   // empty vector for safety.
   void chkerr (void)
   {
     if (rep->err)
       {
         if (--rep->count == 0)
diff --git a/liboctave/util/oct-inttypes.cc b/liboctave/util/oct-inttypes.cc
--- a/liboctave/util/oct-inttypes.cc
+++ b/liboctave/util/oct-inttypes.cc
@@ -47,16 +47,67 @@ DECLARE_OCTAVE_INT_TYPENAME (int8_t, "in
 DECLARE_OCTAVE_INT_TYPENAME (int16_t, "int16")
 DECLARE_OCTAVE_INT_TYPENAME (int32_t, "int32")
 DECLARE_OCTAVE_INT_TYPENAME (int64_t, "int64")
 DECLARE_OCTAVE_INT_TYPENAME (uint8_t, "uint8")
 DECLARE_OCTAVE_INT_TYPENAME (uint16_t, "uint16")
 DECLARE_OCTAVE_INT_TYPENAME (uint32_t, "uint32")
 DECLARE_OCTAVE_INT_TYPENAME (uint64_t, "uint64")
 
+template <class T>
+template <class S>
+T
+octave_int_base<T>::convert_real (const S& value)
+{
+  // Compute proper thresholds.
+  static const S thmin = compute_threshold (static_cast<S> (min_val ()),
+                                            min_val ());
+  static const S thmax = compute_threshold (static_cast<S> (max_val ()),
+                                            max_val ());
+  if (xisnan (value))
+    {
+      return static_cast<T> (0);
+    }
+  else if (value < thmin)
+    {
+      return min_val ();
+    }
+  else if (value > thmax)
+    {
+      return max_val ();
+    }
+  else
+    {
+      S rvalue = xround (value);
+      return static_cast<T> (rvalue);
+    }
+}
+
+#define INSTANTIATE_CONVERT_REAL_1(T, S) \
+  template \
+  OCTAVE_API \
+  T \
+  octave_int_base<T>::convert_real (const S&)
+
+#define INSTANTIATE_CONVERT_REAL(S) \
+  INSTANTIATE_CONVERT_REAL_1 (int8_t, S); \
+  INSTANTIATE_CONVERT_REAL_1 (uint8_t, S); \
+  INSTANTIATE_CONVERT_REAL_1 (int16_t, S); \
+  INSTANTIATE_CONVERT_REAL_1 (uint16_t, S); \
+  INSTANTIATE_CONVERT_REAL_1 (int32_t, S); \
+  INSTANTIATE_CONVERT_REAL_1 (uint32_t, S); \
+  INSTANTIATE_CONVERT_REAL_1 (int64_t, S); \
+  INSTANTIATE_CONVERT_REAL_1 (uint64_t, S)
+
+INSTANTIATE_CONVERT_REAL (double);
+INSTANTIATE_CONVERT_REAL (float);
+#if defined (OCTAVE_INT_USE_LONG_DOUBLE)
+INSTANTIATE_CONVERT_REAL (long double);
+#endif
+
 #ifdef OCTAVE_INT_USE_LONG_DOUBLE
 
 #ifdef OCTAVE_ENSURE_LONG_DOUBLE_OPERATIONS_ARE_NOT_TRUNCATED
 
 #define DEFINE_OCTAVE_LONG_DOUBLE_CMP_OP_TEMPLATES(T) \
   template <typename xop> \
   bool \
   octave_int_cmp_op::external_mop (double x, T y) \
diff --git a/liboctave/util/oct-inttypes.h b/liboctave/util/oct-inttypes.h
--- a/liboctave/util/oct-inttypes.h
+++ b/liboctave/util/oct-inttypes.h
@@ -312,44 +312,21 @@ private:
     // If val is even, but orig_val is odd, we're one unit off.
     if (orig_val % 2 && val / 2 == xround (val / 2))
       // FIXME: is this always correct?
       val *= (static_cast<S> (1) - (std::numeric_limits<S>::epsilon () / 2));
     return val;
   }
 
 public:
+
   // Convert a real number (check NaN and non-int).
   template <typename S>
   static T
-  convert_real (const S& value)
-  {
-    // Compute proper thresholds.
-    static const S thmin = compute_threshold (static_cast<S> (min_val ()),
-                           min_val ());
-    static const S thmax = compute_threshold (static_cast<S> (max_val ()),
-                           max_val ());
-    if (xisnan (value))
-      {
-        return static_cast<T> (0);
-      }
-    else if (value < thmin)
-      {
-        return min_val ();
-      }
-    else if (value > thmax)
-      {
-        return max_val ();
-      }
-    else
-      {
-        S rvalue = xround (value);
-        return static_cast<T> (rvalue);
-      }
-  }
+  convert_real (const S& value);
 };
 
 // Saturated (homogeneous) integer arithmetics. The signed and unsigned
 // implementations are significantly different, so we implement another layer
 // and completely specialize. Arithmetics inherits from octave_int_base so that
 // it can use its exceptions and truncation functions.
 
 template <typename T, bool is_signed>
