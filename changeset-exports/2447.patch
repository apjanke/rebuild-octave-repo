# HG changeset patch
# User jwe
# Date 846704346 0
#      Wed Oct 30 19:39:06 1996 +0000
# Node ID e46137c067816f2f3694565a4206b900a66db096
# Parent  b241766f293ae766a49fda9a6546aee773d0914f
[project @ 1996-10-30 19:39:03 by jwe]

diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,10 +1,15 @@
 Wed Oct 30 01:06:19 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
+	* ov-ch-mat.cc, ov-struct.cc, ov-struct.h, pr-output.cc,
+	pt-cmd.cc, pt-const.cc, pt-const.h, pt-fcn.cc, pt-fvc-base.cc,
+	pt-fvc-base.h, pt-fvc.cc, pt-fvc.h, rand.cc, sighandlers.cc,
+	variables.cc, variables.h: Delete unused code.
+
 	* octave.cc: Only include pwd.h if HAVE_PWD_H.
 
 	* oct-strstrm.h: Include <string>, not <string.h>.
 
 	* defaults.cc, dirfns.cc, file-io.cc, help.cc, input.cc,
  	oct-hist.cc, oct-procbuf.cc, oct-procbuf.h, octave.cc, pager.h,
  	procstream.h, pt-misc.cc, pt-plot.cc, sighandlers.cc, strftime.c,
  	syscalls.cc, sysdep.cc, syswait.h, toplev.cc, utils.cc,
diff --git a/src/ov-ch-mat.cc b/src/ov-ch-mat.cc
--- a/src/ov-ch-mat.cc
+++ b/src/ov-ch-mat.cc
@@ -53,22 +53,16 @@ octave_char_matrix::valid_as_zero_index 
   return false;
 }
 
 bool
 octave_char_matrix::is_true (void) const
 {
   // XXX FIXME XXX
   return false;
-
-#if 0
-    Matrix m = (matrix.all ()) . all ();
-
-  return (m.rows () == 1 && m.columns () == 1 && m (0, 0) != 0.0);
-#endif
 }
 
 double
 octave_char_matrix::double_value (bool) const
 {
   double retval = octave_NaN;
 
   if ((rows () == 1 && columns () == 1)
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -53,111 +53,18 @@ octave_struct::struct_elt_val (const str
 
   return retval;
 }
 
 octave_value&
 octave_struct::struct_elt_ref (const string& nm)
 {
   return map [nm];
-
-#if 0
-  static octave_value fooval;
-
-  Pix idx = map.seek (nm);
-
-  if (idx)
-    return map.contents (idx);
-  else if (insert)
-    return map [nm];
-  else
-    error ("structure has no member `%s'", nm.c_str ());
-
-  return fooval;
-#endif
 }
 
-#if 0
-octave_value&
-octave_struct::lookup_map_element (const string& name, bool insert,
-				   bool silent)
-{
-  static octave_value fooval;
-
-  Pix idx = map.seek (name);
-
-  if (idx)
-    return map.contents (idx);
-  else if (insert)
-    return map [name];
-  else if (! silent)
-    error ("structure has no member `%s'", name.c_str ());
-
-  return fooval;
-}
-
-octave_value
-octave_struct::lookup_map_element (const string& ref, bool insert,
-				   bool silent)
-{
-  octave_value retval;
-
-  if (! ref.empty ())
-    {
-      SLList<string> list;
-
-      size_t beg = 0;
-      size_t end;
-
-      do
-	{
-	  end = ref.find ('.', beg);
-
-	  string tmp = (end == NPOS)
-	    ? ref.substr (beg) : ref.substr (beg, end - beg);
-
-	  list.append (tmp);
-	}
-      while (end != NPOS && (beg = end + 1));
-
-      retval = lookup_map_element (list, insert, silent);
-    }
-
-  return retval;
-}
-
-octave_value
-octave_struct::lookup_map_element (SLList<string>& list, bool insert,
-				   bool silent)
-{
-  octave_value retval;
-
-  Pix p = list.first ();
-
-  while (p)
-    {
-      string elt = list (p);
-
-      list.next (p);
-
-      octave_value tmp = lookup_map_element (elt, insert, silent);
-
-      if (error_state)
-	break;
-
-      tmp_rep = tmp.rep;
-
-      if (! p)
-	retval = tmp;
-    }
-
-  return retval;
-}
-#endif
-
 void
 octave_struct::print (ostream& os)
 {
   // XXX FIXME XXX -- would be nice to print the output in some
   // standard order.  Maybe all substructures first, maybe
   // alphabetize entries, etc.
 
   begin_unwind_frame ("octave_struct_print");
diff --git a/src/ov-struct.h b/src/ov-struct.h
--- a/src/ov-struct.h
+++ b/src/ov-struct.h
@@ -74,123 +74,36 @@ public:
   octave_value struct_elt_val (const string& nm, bool silent) const;
 
   octave_value& struct_elt_ref (const string& nm);
 
   bool is_defined (void) const { return true; }
 
   bool is_map (void) const { return true; }
 
-#if 0
-  double double_value (bool) const
-  Matrix matrix_value (bool frc_str_conv = false) const;
-  Complex complex_value (bool frc_str_conv = false) const;
-  ComplexMatrix complex_matrix_value (bool frc_str_conv = false) const;
-  charMatrix char_matrix_value (bool frc_str_conv = false) const;
-  charMatrix all_strings (void) const;
-  string string_value (void) const;
-  Range range_value (void) const
-#endif
-
   Octave_map map_value (void) const { return map; }
 
-#if 0
-  octave_value& lookup_map_element (const string& name,
-				    bool insert = false,
-				    bool silent = false);
-
-  octave_value& lookup_map_element (SLList<string>& name,
-				    bool insert = false,
-				    bool silent = false);
-
-  ColumnVector vector_value (bool frc_str_conv = false,
-			     bool frc_vec_conv = false) const;
-
-  ComplexColumnVector
-  complex_vector_value (bool frc_str_conv = false,
-			bool frc_vec_conv = false) const;
-
-  octave_value convert_to_str (void) const;
-
-  void convert_to_row_or_column_vector (void);
-
-  void maybe_mutate (void);
-#endif
-
   void print (ostream& os);
 
   int type_id (void) const { return t_id; }
 
   string type_name (void) const { return t_name; }
 
   static int static_type_id (void) { return t_id; }
 
   static void register_type (void)
     { t_id = octave_value_typeinfo::register_type (t_name); }
 
-#if 0
-  // Binary and unary operations.
-
-  friend octave_value do_binary_op (octave_value& a, octave_value& b,
-				    tree_expression::type t);
-
-  friend octave_value do_unary_op (octave_value& a,
-				   tree_expression::type t);
-
-  // We want to eliminate this.
-
-  constant_type const_type (void) const { return type_tag; }
-
-  // We want to get rid of these too:
-
-  void force_numeric (bool frc_str_conv = false);
-  octave_value make_numeric (bool frc_str_conv = false) const;
-
-  // But not this.
-
-  void convert_to_matrix_type (bool make_complex);
-
-  // Indexing and assignment.
-
-  void clear_index (void);
-
-  // void set_index (double d);
-  void set_index (const Range& r);
-  void set_index (const ColumnVector& v);
-  void set_index (const Matrix& m);
-  void set_index (char c);
-
-  void set_index (const octave_value_list& args,
-		  bool rhs_is_complex = false);
-
-  octave_value do_index (const octave_value_list& args);
-
-  void maybe_widen (constant_type t);
-
-  void assign (octave_value& rhs, const octave_value_list& args);
-
-  bool print_as_scalar (void);
-
-  bool print_as_structure (void);
-#endif
-
 private:
 
   Octave_map map;
 
   static int t_id;
 
   static const string t_name;
-
-#if 0
-  // For custom memory management.
-  // XXX FIXME XXX -- maybe this should be inherited (use void* and cast).
-
-  octave_base_value *freeptr;
-#endif
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -1096,21 +1096,16 @@ octave_print_internal (ostream& os, doub
 
 void
 octave_print_internal (ostream& os, const Matrix& m, bool pr_as_read_syntax,
 		       int extra_indent)
 {
   int nr = m.rows ();
   int nc = m.columns ();
 
-#if 0
-  if (nr == 1 && nc == 1 && ! pr_as_read_syntax)
-    octave_print_internal (os, m (0, 0), pr_as_read_syntax);
-  else
-#endif
   if (nr == 0 || nc == 0)
     print_empty_matrix (os, nr, nc, pr_as_read_syntax);
   else if (plus_format && ! pr_as_read_syntax)
     {
       for (int i = 0; i < nr; i++)
 	{
 	  for (int j = 0; j < nc; j++)
 	    {
@@ -1253,21 +1248,16 @@ octave_print_internal (ostream& os, cons
 
 void
 octave_print_internal (ostream& os, const ComplexMatrix& cm,
 		       bool pr_as_read_syntax, int extra_indent)
 {
   int nr = cm.rows ();
   int nc = cm.columns ();
 
-#if 0
-  if (nr == 1 && nc == 1 && ! pr_as_read_syntax)
-    octave_print_internal (os, cm (0, 0), pr_as_read_syntax);
-  else
-#endif
  if (nr == 0 || nc == 0)
     print_empty_matrix (os, nr, nc, pr_as_read_syntax);
   else if (plus_format && ! pr_as_read_syntax)
     {
       for (int i = 0; i < nr; i++)
 	{
 	  for (int j = 0; j < nc; j++)
 	    {
diff --git a/src/pt-cmd.cc b/src/pt-cmd.cc
--- a/src/pt-cmd.cc
+++ b/src/pt-cmd.cc
@@ -66,44 +66,16 @@ quit_loop_now (void)
   bool quit = (returning || breaking || continuing);
 
   if (breaking)
     breaking--;
 
   return quit;
 }
 
-// But first, some extra functions used by the tree classes.
-
-// We seem to have no use for this now.  Maybe it will be needed at
-// some future date, so here it is.
-#if 0
-
-// Convert a linked list of trees to a vector of pointers to trees.
-
-static tree **
-list_to_vector (tree *list, int& len)
-{
-  len = list->length () + 1;
-
-  tree **args = new tree * [len];
-
-  // args[0] may eventually hold something useful, like the function
-  // name.
-
-  tree *tmp_list = list;
-  for (int k = 1; k < len; k++)
-    {
-      args[k] = tmp_list;
-      tmp_list = tmp_list->next_elem ();
-    }
-  return args;
-}
-#endif
-
 // Global.
 
 tree_global_command::~tree_global_command (void)
 {
   delete init_list;
 }
 
 void
diff --git a/src/pt-const.cc b/src/pt-const.cc
--- a/src/pt-const.cc
+++ b/src/pt-const.cc
@@ -66,35 +66,16 @@ tree_constant::map_value (void) const
   return val.map_value ();
 }
 
 void
 tree_constant::print (void)
 {
 }
 
-#if 0
-octave_value
-tree_constant::assign_map_element (SLList<string>&, const octave_value&)
-{
-  octave_value retval;
-  error ("tree_constant::assign_map_element(): not implemented");
-  return retval;
-}
-
-octave_value
-tree_constant::assign_map_element (SLList<string>&, const octave_value_list&,
-				   const octave_value&)
-{
-  octave_value retval;
-  error ("tree_constant::assign_map_element(): not implemented");
-  return retval;
-}
-#endif
-
 octave_value
 tree_constant::eval (bool print_result)
 {
   if (print_result)
     val.print ();
 
   return val;
 }
@@ -129,1729 +110,13 @@ tree_constant::lookup_map_element (SLLis
 }
 
 void
 tree_constant::accept (tree_walker& tw)
 {
   tw.visit_constant (*this);
 }
 
-#if 0
-
-#ifndef OCT_VAL_REP
-#define OCT_VAL_REP octave_value::octave_value_rep
-#endif
-
-#ifndef MAX
-#define MAX(a,b) ((a) > (b) ? (a) : (b))
-#endif
-
-#ifndef OCT_VAL_REP
-#define OCT_VAL_REP octave_value::octave_value_rep
-#endif
-
-#ifndef MAX
-#define MAX(a,b) ((a) > (b) ? (a) : (b))
-#endif
-
-// The following three variables could be made static members of the
-// OCT_VAL_REP class.
-
-// Pointer to the blocks of memory we manage.
-static OCT_VAL_REP *tc_rep_newlist = 0;
-
-// Multiplier for allocating new blocks.
-static const int tc_rep_newlist_grow_size = 128;
-
-// XXX FIXME XXX -- these should be member functions.
-
-static bool
-any_element_is_complex (const ComplexMatrix& a)
-{
-  int nr = a.rows ();
-  int nc = a.columns ();
-
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
-      if (imag (a (i, j)) != 0.0)
-	return true;
-
-  return false;
-}
-
-static bool
-any_element_is_complex (const ComplexDiagMatrix& d)
-{
-  int len = d.length ();
-
-  for (int i = 0; i < len; i++)
-    if (imag (d (i, i)) != 0.0)
-      return true;
-
-  return false;
-}
-
-static bool
-any_element_is_complex (const ComplexRowVector& v)
-{
-  int len = v.length ();
-
-  for (int i = 0; i < len; i++)
-    if (imag (v (i)) != 0.0)
-      return true;
-
-  return false;
-}
-
-static bool
-any_element_is_complex (const ComplexColumnVector& v)
-{
-  int len = v.length ();
-
-  for (int i = 0; i < len; i++)
-    if (imag (v (i)) != 0.0)
-      return true;
-
-  return false;
-}
-
-// The following three variables could be made static members of the
-// octave_value class.
-
-// Pointer to the blocks of memory we manage.
-static octave_value *tc_newlist = 0;
-
-// Multiplier for allocating new blocks.
-static const int tc_newlist_grow_size = 128;
-
-Octave_map
-octave_value::map_value (void) const
-{
-  return rep->map_value ();
-}
-
-octave_value::~octave_value (void)
-{
-#if defined (MDEBUG)
-  cerr << "~octave_value: rep: " << rep
-       << " rep->count: " << rep->count << "\n";
-#endif
-
-  if (--rep->count <= 0)
-    {
-      delete rep;
-      rep = 0;
-    }
-}
-
-void *
-octave_value::operator new (size_t size)
-{
-  assert (size == sizeof (octave_value));
-
-  if (! tc_newlist)
-    {
-      int block_size = tc_newlist_grow_size * sizeof (octave_value);
-      tc_newlist = (octave_value *) new char [block_size];
-
-      int i = 0;
-
-      for (i = 0; i < tc_newlist_grow_size - 1; i++)
-	tc_newlist[i].freeptr = &tc_newlist[i+1];
-
-      tc_newlist[i].freeptr = 0;
-    }
-
-  octave_value *tmp = tc_newlist;
-  tc_newlist = tc_newlist->freeptr;
-  return tmp;
-}
-
-void
-octave_value::operator delete (void *p, size_t /* size */)
-{
-  octave_value *tmp = (octave_value *) p;
-  tmp->freeptr = tc_newlist;
-  tc_newlist = tmp;
-}
-
-// Simple assignment.
-
-octave_value
-octave_value::operator = (const octave_value& a)
-{
-  if (rep != a.rep)
-    {
-      if (--rep->count <= 0)
-	delete rep;
-      rep = a.rep;
-      rep->count++;
-    }
-  return *this;  
-}
-
-// Simple structure assignment.
-
-void
-octave_value::make_unique (void)
-{
-  if (rep->count > 1)
-    {
-      --rep->count;
-      rep = new octave_value_rep (*rep);
-      rep->count = 1;
-    }
-
-  if (rep->is_map ())
-    {
-      for (Pix p = rep->a_map->first (); p != 0; rep->a_map->next (p))
-	{
-	  rep->a_map->contents (p) . make_unique ();
-	}
-    }
-}
-
-octave_value::octave_value_rep *
-octave_value::make_unique_map (void)
-{
-  if (! rep->is_map ())
-    {
-      if (--rep->count <= 0)
-	delete rep;
-
-      Octave_map m;
-      rep = new octave_value_rep (m);
-      rep->count = 1;
-    }
-
-  make_unique ();
-
-  return rep;
-}
-
-octave_value
-octave_value::assign_map_element (SLList<string>& list,
-				   octave_value& rhs)
-{
-  octave_value_rep *tmp_rep = make_unique_map ();
-
-  if (rhs.is_map ())
-    rhs.make_unique ();
-
-  Pix p = list.first ();
-  while (p)
-    {
-      string elt = list (p);
-
-      list.next (p);
-
-      octave_value& tmp = tmp_rep->lookup_map_element (elt, 1);
-
-      if (! p)
-	{
-	  tmp = rhs;
-	  return tmp;
-	}
-
-      tmp_rep = tmp.make_unique_map ();
-    }
-
-  return octave_value ();
-}
-
-// Indexed structure assignment.
-
-octave_value
-octave_value::assign_map_element (SLList<string>& list,
-				   octave_value& rhs,
-				   const octave_value_list& args)
-{
-  octave_value_rep *tmp_rep = make_unique_map ();
-
-  if (rhs.is_map ())
-    rhs.make_unique ();
-
-  Pix p = list.first ();
-  while (p)
-    {
-      string elt = list (p);
-
-      list.next (p);
-
-      octave_value& tmp = tmp_rep->lookup_map_element (elt, 1);
-
-      if (! p)
-	{
-	  tmp.assign (rhs, args);
-	  return tmp;
-	}
-
-      tmp_rep = tmp.make_unique_map ();
-    }
-
-  return octave_value ();
-}
-
-octave_value_list
-octave_value::eval (bool print, int, const octave_value_list& args)
-{
-  octave_value_list retval;
-
-  if (args.length () > 0)
-    retval(0) = rep->do_index (args);
-  else
-    retval(0) = *this;
-
-  if (retval(0).is_defined ())
-    retval(0).eval (print);
-
-  return retval;
-}
-
-void *
-OCT_VAL_REP::operator new (size_t size)
-{
-  assert (size == sizeof (OCT_VAL_REP));
-
-  if (! tc_rep_newlist)
-    {
-      int block_size = tc_rep_newlist_grow_size * sizeof (OCT_VAL_REP);
-      tc_rep_newlist = (OCT_VAL_REP *) new char [block_size];
-
-      int i = 0;
-
-      for (i = 0; i < tc_rep_newlist_grow_size - 1; i++)
-	tc_rep_newlist[i].freeptr = &tc_rep_newlist[i+1];
-
-      tc_rep_newlist[i].freeptr = 0;
-    }
-
-  OCT_VAL_REP *tmp = tc_rep_newlist;
-  tc_rep_newlist = tc_rep_newlist->freeptr;
-  return tmp;
-}
-
-void
-OCT_VAL_REP::operator delete (void *p, size_t /* size */)
-{
-  OCT_VAL_REP *tmp = (OCT_VAL_REP *) p;
-  tmp->freeptr = tc_rep_newlist;
-  tc_rep_newlist = tmp;
-}
-
-octave_value
-OCT_VAL_REP::all (void) const
-{
-  octave_value retval;
-
-  if (error_state)
-    return retval;
-
-  if (! is_numeric_type ())
-    {
-      octave_value tmp = make_numeric ();
-
-      if (error_state)
-	return retval;
-
-      return tmp.all ();
-    }
-
-  switch (type_tag)
-    {
-    default:
-      gripe_wrong_type_arg ("all", *this);
-      break;
-    }
-
-  return retval;
-}
-
-octave_value
-OCT_VAL_REP::any (void) const
-{
-  octave_value retval;
-
-  if (error_state)
-    return retval;
-
-  if (! is_numeric_type ())
-    {
-      octave_value tmp = make_numeric ();
-
-      if (error_state)
-	return retval;
-
-      return tmp.any ();
-    }
-
-  switch (type_tag)
-    {
-    default:
-      gripe_wrong_type_arg ("any", *this);
-      break;
-    }
-
-  return retval;
-}
-
-// XXX FIXME XXX -- we need a better way of handling conversions.
-
-double
-OCT_VAL_REP::double_value (bool force_string_conv) const
-{
-  double retval = octave_NaN;
-
-  switch (type_tag)
-    {
-    case char_matrix_constant_str:
-      {
-	int flag = force_string_conv;
-	if (! flag)
-	  flag = Vimplicit_str_to_num_ok;
-
-	if (flag < 0)
-	  gripe_implicit_conversion ("string", "real scalar");
-
-	int len = char_matrix->rows ();
-	if (flag
-	    && ((char_matrix->rows () == 1 && len == 1)
-		|| (len > 1 && Vdo_fortran_indexing)))
-	  retval = toascii ((int) (*char_matrix) (0, 0));
-	else
-	  gripe_invalid_conversion ("string", "real scalar");
-      }
-      break;
-
-    default:
-      gripe_invalid_conversion (type_name (), "real scalar");
-      break;
-    }
-
-  return retval;
-}
-
-Matrix
-OCT_VAL_REP::matrix_value (bool force_string_conv) const
-{
-  Matrix retval;
-
-  switch (type_tag)
-    {
-    case char_matrix_constant:
-      retval = Matrix (*char_matrix);
-      break;
-
-    case char_matrix_constant_str:
-      {
-	int flag = force_string_conv;
-	if (! flag)
-	  flag = Vimplicit_str_to_num_ok;
-
-	if (flag < 0)
-	  gripe_implicit_conversion ("string", "real matrix");
-
-	if (flag)
-	  retval = Matrix (*char_matrix);
-	else
-	  gripe_invalid_conversion ("string", "real matrix");
-      }
-      break;
-
-    default:
-      gripe_invalid_conversion (type_name (), "real matrix");
-      break;
-    }
-
-  return retval;
-}
-
-Complex
-OCT_VAL_REP::complex_value (bool force_string_conv) const
-{
-  Complex retval (octave_NaN, octave_NaN);
-
-  switch (type_tag)
-    {
-    case char_matrix_constant:
-      {
-	int len = char_matrix->cols ();
-	if ((char_matrix->rows () == 1 && len == 1)
-	    || (len > 1 && Vdo_fortran_indexing))
-	  retval = toascii ((int) (*char_matrix) (0, 0));
-	else
-	  gripe_invalid_conversion ("char matrix", "complex scalar");
-      }
-      break;
-
-    case char_matrix_constant_str:
-      {
-	int flag = force_string_conv;
-	if (! flag)
-	  flag = Vimplicit_str_to_num_ok;
-
-	if (flag < 0)
-	  gripe_implicit_conversion ("string", "complex scalar");
-
-	int len = char_matrix->cols ();
-	if (flag
-	    && ((char_matrix->rows () == 1 && len == 1)
-		|| (len > 1 && Vdo_fortran_indexing)))
-	  retval = toascii ((int) (*char_matrix) (0, 0));
-	else
-	  gripe_invalid_conversion ("string", "complex scalar");
-      }
-      break;
-
-    default:
-      gripe_invalid_conversion (type_name (), "complex scalar");
-      break;
-    }
-
-  return retval;
-}
-
-ComplexMatrix
-OCT_VAL_REP::complex_matrix_value (bool force_string_conv) const
-{
-  ComplexMatrix retval;
-
-  switch (type_tag)
-    {
-    case char_matrix_constant:
-      retval = ComplexMatrix (*char_matrix);
-      break;
-
-    case char_matrix_constant_str:
-      {
-	int flag = force_string_conv;
-	if (! flag)
-	  flag = Vimplicit_str_to_num_ok;
-
-	if (flag < 0)
-	  gripe_implicit_conversion ("string", "complex matrix");
-
-	if (flag)
-	  retval = ComplexMatrix (*char_matrix);
-	else
-	  gripe_invalid_conversion ("complex", "real matrix");
-      }
-      break;
-
-    default:
-      gripe_invalid_conversion (type_name (), "complex matrix");
-      break;
-    }
-
-  return retval;
-}
-
-// XXX FIXME XXX -- this needs to try to do some conversions...
-
-charMatrix
-OCT_VAL_REP::char_matrix_value (bool force_string_conv) const
-{
-  charMatrix retval;
-
-  int flag = force_string_conv;
-  if (! flag)
-    flag = Vimplicit_str_to_num_ok;
-
-  switch (type_tag)
-    {
-    case char_matrix_constant:
-    case char_matrix_constant_str:
-      retval = *char_matrix;
-      break;
-
-    default:
-      if (! (rows () == 0 && columns () == 0))
-	gripe_invalid_conversion (type_name (), "string");
-      break;
-    }
-
-  return retval;
-}
-
-charMatrix
-OCT_VAL_REP::all_strings (void) const
-{
-  if (type_tag == char_matrix_constant_str)
-    return *char_matrix;
-  else
-    {
-      gripe_invalid_conversion (type_name (), "string");
-      return 0;
-    }
-}
-
-string
-OCT_VAL_REP::string_value (void) const
-{
-  string retval;
-
-  if (type_tag == char_matrix_constant_str)
-    retval = char_matrix->row_as_string (0);  // XXX FIXME??? XXX
-  else
-    gripe_invalid_conversion (type_name (), "string");
-
-  return retval;
-}
-
-Octave_map
-OCT_VAL_REP::map_value (void) const
-{
-  assert (type_tag == map_constant);
-  return *a_map;
-}
-
-// This could be made more efficient by doing all the work here rather
-// than relying on matrix_value() to do any possible type conversions.
-
-ColumnVector
-OCT_VAL_REP::vector_value (bool force_string_conv,
-		      bool force_vector_conversion) const
-{
-  ColumnVector retval;
-
-  Matrix m = matrix_value (force_string_conv);
-
-  if (error_state)
-    return retval;
-
-  int nr = m.rows ();
-  int nc = m.columns ();
-  if (nr == 1)
-    {
-      retval.resize (nc);
-      for (int i = 0; i < nc; i++)
-	retval (i) = m (0, i);
-    }
-  else if (nc == 1)
-    {
-      retval.resize (nr);
-      for (int i = 0; i < nr; i++)
-	retval (i) = m (i, 0);
-    }
-  else if (nr > 0 && nc > 0
-	   && (Vdo_fortran_indexing || force_vector_conversion))
-    {
-      retval.resize (nr * nc);
-      int k = 0;
-      for (int j = 0; j < nc; j++)
-	for (int i = 0; i < nr; i++)
-	  retval (k++) = m (i, j);
-    }
-  else
-    gripe_invalid_conversion ("real matrix", "real vector");
-
-  return retval;
-}
-
-// This could be made more efficient by doing all the work here rather
-// than relying on complex_matrix_value() to do any possible type
-// conversions.
-
-ComplexColumnVector
-OCT_VAL_REP::complex_vector_value (bool force_string_conv,
-			      bool force_vector_conversion) const
-{
-  ComplexColumnVector retval;
-
-  ComplexMatrix m = complex_matrix_value (force_string_conv);
-
-  if (error_state)
-    return retval;
-
-  int nr = m.rows ();
-  int nc = m.columns ();
-  if (nr == 1)
-    {
-      retval.resize (nc);
-      for (int i = 0; i < nc; i++)
-	retval (i) = m (0, i);
-    }
-  else if (nc == 1)
-    {
-      retval.resize (nr);
-      for (int i = 0; i < nr; i++)
-	retval (i) = m (i, 0);
-    }
-  else if (nr > 0 && nc > 0
-	   && (Vdo_fortran_indexing || force_vector_conversion))
-    {
-      retval.resize (nr * nc);
-      int k = 0;
-      for (int j = 0; j < nc; j++)
-	for (int i = 0; i < nr; i++)
-	  retval (k++) = m (i, j);
-    }
-  else
-    gripe_invalid_conversion ("complex matrix", "complex vector");
-
-  return retval;
-}
-
-octave_value
-OCT_VAL_REP::convert_to_str (void) const
-{
-  octave_value retval;
-
-  switch (type_tag)
-    {
-    case complex_scalar_constant:
-    case scalar_constant:
-      {
-	double d = double_value ();
-
-	if (xisnan (d))
-	  {
-	    ::error ("invalid conversion from NaN to character");
-	    return retval;
-	  }
-	else
-	  {
-	    // XXX FIXME XXX -- warn about out of range conversions?
-
-	    int i = NINT (d);
-	    char s[2];
-	    s[0] = (char) i;
-	    s[1] = '\0';
-	    retval = octave_value (s, 1);
-	  }
-      }
-      break;
-
-    case complex_matrix_constant:
-    case matrix_constant:
-      {
-	if (rows () == 0 && columns () == 0)
-	  {
-	    char s = '\0';
-	    retval = octave_value (&s, 1);
-	  }
-	else
-	  {
-	    Matrix m = matrix_value ();
-
-	    int nr = m.rows ();
-	    int nc = m.columns ();
-
-	    if (nr == 0 || nc == 0)
-	      {
-		char s = '\0';
-		retval = octave_value (&s, 1);
-	      }
-	    else
-	      {
-		charMatrix chm (nr, nc);
-
-		for (int j = 0; j < nc; j++)
-		  {
-		    for (int i = 0; i < nr; i++)
-		      {
-			double d = m (i, j);
-
-			if (xisnan (d))
-			  {
-			    ::error ("invalid conversion from NaN to character");
-			    return retval;
-			  }
-			else
-			  {
-			    // XXX FIXME XXX -- warn about out of
-			    // range conversions?
-
-			    int ival = NINT (d);
-			    chm (i, j) = (char) ival;
-			  }
-		      }
-		  }
-
-		retval = octave_value (chm, 1);
-	      }
-	  }
-      }
-      break;
-
-    case range_constant:
-      {
-	Range r = range_value ();
-	double b = r.base ();
-	double incr = r.inc ();
-	int nel = r.nelem ();
-	char *s = new char [nel+1];
-	s[nel] = '\0';
-	for (int i = 0; i < nel; i++)
-	  {
-	    double d = b + i * incr;
-
-	    if (xisnan (d))
-	      {
-		::error ("invalid conversion from NaN to character");
-		delete [] s;
-		return retval;
-	      }
-	    else
-	      {
-		// XXX FIXME XXX -- warn about out of range
-		// conversions?
-
-		int ival = NINT (d);
-		s[i] = (char) ival;
-	      }
-	  }
-	retval = octave_value (s, 1);
-	delete [] s;
-      }
-      break;
-
-    case char_matrix_constant:
-      retval = octave_value (*char_matrix, 1);
-      break;
-
-    case char_matrix_constant_str:
-      retval = octave_value (*char_matrix, 1);
-      break;
-
-    default:
-      gripe_invalid_conversion (type_name (), "string");
-      break;
-    }
-
-  return retval;
-}
-
-void
-OCT_VAL_REP::convert_to_row_or_column_vector (void)
-{
-  assert (type_tag == matrix_constant || type_tag == complex_matrix_constant);
-
-  int nr = rows ();
-  int nc = columns ();
-
-  if (nr == 1 || nc == 1)
-    return;
-
-  int len = nr * nc;
-
-  assert (len > 0);
-
-  int new_nr = 1;
-  int new_nc = 1;
-
-  if (Vprefer_column_vectors)
-    new_nr = len;
-  else
-    new_nc = len;
-
-  if (type_tag == matrix_constant)
-    {
-      Matrix *m = new Matrix (new_nr, new_nc);
-
-      double *cop_out = matrix->fortran_vec ();
-
-      for (int i = 0; i < len; i++)
-	{
-	  if (new_nr == 1)
-	    (*m) (0, i) = *cop_out++;
-	  else
-	    (*m) (i, 0) = *cop_out++;
-	}
-
-      delete matrix;
-      matrix = m;
-    }
-  else
-    {
-      ComplexMatrix *cm = new ComplexMatrix (new_nr, new_nc);
-
-      Complex *cop_out = complex_matrix->fortran_vec ();
-
-      for (int i = 0; i < len; i++)
-	{
-	  if (new_nr == 1)
-	    (*cm) (0, i) = *cop_out++;
-	  else
-	    (*cm) (i, 0) = *cop_out++;
-	}
-
-      delete complex_matrix;
-      complex_matrix = cm;
-    }
-}
-
-void
-OCT_VAL_REP::convert_to_matrix_type (bool make_complex)
-{
-  switch (type_tag)
-    {
-    case complex_scalar_constant:
-      {
-	Complex *old_complex = complex_scalar;
-	complex_matrix = new ComplexMatrix (1, 1, *complex_scalar);
-	type_tag = complex_matrix_constant;
-	delete old_complex;
-      }
-      break;
-
-    case scalar_constant:
-      {
-	if (make_complex)
-	  {
-	    complex_matrix = new ComplexMatrix (1, 1, scalar);
-	    type_tag = complex_matrix_constant;
-	  }
-	else
-	  {
-	    matrix = new Matrix (1, 1, scalar);
-	    type_tag = matrix_constant;
-	  }
-      }
-      break;
-
-    case unknown_constant:
-      {
-	if (make_complex)
-	  {
-	    complex_matrix = new ComplexMatrix ();
-	    type_tag = complex_matrix_constant;
-	  }
-	else
-	  {
-	    matrix = new Matrix ();
-	    type_tag = matrix_constant;
-	  }
-      }
-      break;
-
-    case range_constant:
-      {
-	if (make_complex)
-	  {
-	    ComplexMatrix *tmp = new ComplexMatrix (range->matrix_value ());
-	    delete range;
-	    complex_matrix = tmp;
-	    type_tag = complex_matrix_constant;
-	  }
-	else
-	  {
-	    Matrix *tmp = new Matrix (range->matrix_value ());
-	    delete range;
-	    matrix = tmp;
-	    type_tag = matrix_constant;
-	  }
-      }
-      break;
-
-    default:
-      panic_impossible ();
-      break;
-    }
-}
-
-void
-OCT_VAL_REP::force_numeric (bool force_string_conv)
-{
-  switch (type_tag)
-    {
-    case scalar_constant:
-    case matrix_constant:
-    case complex_scalar_constant:
-    case complex_matrix_constant:
-    case char_matrix_constant:
-      break;
-
-    case char_matrix_constant_str:
-      {
-	if (! force_string_conv && ! Vimplicit_str_to_num_ok)
-	  {
-	    ::error ("string to numeric conversion failed --\
- default conversion turned off");
-	    return;
-	  }
-
-	int nr = char_matrix->rows ();
-	int nc = char_matrix->cols ();
-
-	if (nr == 1 && nc == 1)
-	  {
-	    type_tag = scalar_constant;
-	    double tmp = toascii ((int) (*char_matrix) (0, 0));
-	    delete char_matrix;
-	    scalar = tmp;
-	  }
-	else if (nr == 0 || nc == 0)
-	  {
-	    delete char_matrix;
-	    type_tag = matrix_constant;
-	    matrix = new Matrix (0, 0);
-	  }
-	else if (nr > 0 && nc > 0)
-	  {
-	    type_tag = matrix_constant;
-
-	    Matrix *tm = new Matrix (nr, nc);
-
-	    for (int i = 0; i < nr; i++)
-	      {
-		for (int j = 0; j < nc; j++)
-		  {
-		    int c = (int) (*char_matrix) (i, j);
-		    (*tm) (i, j) = toascii (c);
-		  }
-	      }
-	    delete char_matrix;
-	    matrix = tm;
-	  }
-	else
-	  panic_impossible ();
-      }
-      break;
-
-    case range_constant:
-      {
-	int len = range->nelem ();
-	if (len > 1)
-	  {
-	    type_tag = matrix_constant;
-	    Matrix *tm = new Matrix (1, len);
-	    double b = range->base ();
-	    double increment = range->inc ();
-	    for (int i = 0; i < len; i++)
-	      (*tm) (0, i) = b + i * increment;
-	    delete range;
-	    matrix = tm;
-	  }
-	else if (len == 1)
-	  {
-	    type_tag = scalar_constant;
-	    scalar = range->base ();
-	  }
-      }
-      break;
-
-    default:
-      gripe_invalid_conversion (type_name (), "numeric type");
-      break;
-    }
-}
-
-octave_value
-OCT_VAL_REP::make_numeric (bool force_string_conv) const
-{
-  octave_value retval;
-
-  switch (type_tag)
-    {
-    case scalar_constant:
-      retval = scalar;
-      break;
-
-    case matrix_constant:
-      retval = *matrix;
-      break;
-
-    case complex_scalar_constant:
-      retval = *complex_scalar;
-      break;
-
-    case complex_matrix_constant:
-      retval = *complex_matrix;
-      break;
-
-    case char_matrix_constant:
-      retval = *char_matrix;
-      break;
-
-    case char_matrix_constant_str:
-      {
-	int flag = force_string_conv;
-	if (! flag)
-	  flag = Vimplicit_str_to_num_ok;
-
-	if (flag < 0)
-	  gripe_implicit_conversion ("string", "char matrix");
-
-	if (flag)
-	  {
-	    retval = octave_value (*char_matrix, true);
-	    retval.force_numeric (force_string_conv);
-	  }
-	else
-	  gripe_invalid_conversion ("string", "char matrix");
-      }
-      break;
-
-    case range_constant:
-      retval = *range;
-      retval.force_numeric (force_string_conv);
-      break;
-
-    default:
-      gripe_invalid_conversion (type_name (), "numeric value");
-      break;
-    }
-
-  return retval;
-}
-
-void
-OCT_VAL_REP::maybe_mutate (void)
-{
-  switch (type_tag)
-    {
-    case complex_scalar_constant:
-      if (::imag (*complex_scalar) == 0.0)
-	{
-	  double d = ::real (*complex_scalar);
-	  delete complex_scalar;
-	  scalar = d;
-	  type_tag = scalar_constant;
-	}
-      break;
-
-    case complex_matrix_constant:
-      if (! any_element_is_complex (*complex_matrix))
-	{
-	  Matrix *m = new Matrix (::real (*complex_matrix));
-	  delete complex_matrix;
-	  matrix = m;
-	  type_tag = matrix_constant;
-	}
-      break;
-
-    default:
-      break;
-    }
-
-  // Avoid calling rows() and columns() for things like magic_colon.
-
-  int nr = 1;
-  int nc = 1;
-  if (type_tag == matrix_constant
-      || type_tag == complex_matrix_constant
-      || type_tag == range_constant)
-    {
-      nr = rows ();
-      nc = columns ();
-    }
-
-  switch (type_tag)
-    {
-    case matrix_constant:
-      if (nr == 1 && nc == 1)
-	{
-	  double d = (*matrix) (0, 0);
-	  delete matrix;
-	  scalar = d;
-	  type_tag = scalar_constant;
-	}
-      break;
-
-    case complex_matrix_constant:
-      if (nr == 1 && nc == 1)
-	{
-	  Complex c = (*complex_matrix) (0, 0);
-	  delete complex_matrix;
-	  complex_scalar = new Complex (c);
-	  type_tag = complex_scalar_constant;
-	}
-      break;
-
-    case range_constant:
-      if (nr == 1 && nc == 1)
-	{
-	  double d = range->base ();
-	  delete range;
-	  scalar = d;
-	  type_tag = scalar_constant;
-	}
-      break;
-
-    default:
-      break;
-    }
-}
-
-void
-OCT_VAL_REP::print (ostream& output_buf)
-{
-  if (error_state)
-    return;
-
-    case map_constant:
-      {
-	// XXX FIXME XXX -- would be nice to print the output in some
-	// standard order.  Maybe all substructures first, maybe
-	// alphabetize entries, etc.
-
-	begin_unwind_frame ("OCT_VAL_REP_print");
-
-	unwind_protect_int (struct_indent);
-	unwind_protect_int (Vstruct_levels_to_print);
-
-	if (Vstruct_levels_to_print-- > 0)
-	  {
-	    output_buf.form ("\n%*s{\n", struct_indent, "");
-
-	    increment_struct_indent ();
-
-	    Pix p = a_map->first ();
-
-	    while (p)
-	      {
-		bool pad_after = false;
-
-		string key = a_map->key (p);
-		octave_value val = a_map->contents (p);
-
-		a_map->next (p);
-
-		output_buf.form ("%*s%s =", struct_indent,
-				 "", key.c_str ());
-
-		if (val.print_as_scalar ())
-		  output_buf << " ";
-		else if (val.print_as_structure ())
-		  {
-		    if (p)
-		      pad_after = true;
-		  }
-		else
-		  {
-		    if (p)
-		      pad_after = true;
-
-		    output_buf << "\n\n";
-		  }
-
-		val.print (output_buf);
-
-		if (pad_after)
-		  output_buf << "\n";
-	      }
-
-	    decrement_struct_indent ();
-
-	    output_buf.form ("%*s%s", struct_indent, "", "}\n");
-	  }
-	else
-	  output_buf << " <structure>\n";
-
-	run_unwind_frame ("OCT_VAL_REP_print");
-      }
-      break;
-}
-
-// Indexing operations for the tree-constant representation class.
-
-void
-OCT_VAL_REP::clear_index (void)
-{
-  switch (type_tag)
-    {
-    case matrix_constant:
-      matrix->clear_index ();
-      break;
-
-    case OCT_VAL_REP::complex_matrix_constant:
-      complex_matrix->clear_index ();
-      break;
-
-    case char_matrix_constant:
-    case char_matrix_constant_str:
-      char_matrix->clear_index ();
-      break;
-
-    default:
-      panic_impossible ();
-      break;
-    }
-}
-
-#if 0
-void
-OCT_VAL_REP::set_index (double d)
-{
-  switch (type_tag)
-    {
-    case matrix_constant:
-      matrix->set_index (d);
-      break;
-
-    case OCT_VAL_REP::complex_matrix_constant:
-      complex_matrix->set_index (d);
-      break;
-
-    case OCT_VAL_REP::char_matrix_constant:
-    case OCT_VAL_REP::char_matrix_constant_str:
-      char_matrix->set_index (d);
-      break;
-
-    default:
-      panic_impossible ();
-      break;
-    }
-}
-#endif
-
-void
-OCT_VAL_REP::set_index (const Range& r)
-{
-  switch (type_tag)
-    {
-    case matrix_constant:
-      matrix->set_index (r);
-      break;
-
-    case OCT_VAL_REP::complex_matrix_constant:
-      complex_matrix->set_index (r);
-      break;
-
-    case OCT_VAL_REP::char_matrix_constant:
-    case OCT_VAL_REP::char_matrix_constant_str:
-      char_matrix->set_index (r);
-      break;
-
-    default:
-      panic_impossible ();
-      break;
-    }
-}
-
-void
-OCT_VAL_REP::set_index (const ColumnVector& v)
-{
-  switch (type_tag)
-    {
-    case matrix_constant:
-      matrix->set_index (v);
-      break;
-
-    case OCT_VAL_REP::complex_matrix_constant:
-      complex_matrix->set_index (v);
-      break;
-
-    case OCT_VAL_REP::char_matrix_constant:
-    case OCT_VAL_REP::char_matrix_constant_str:
-      char_matrix->set_index (v);
-      break;
-
-    default:
-      panic_impossible ();
-      break;
-    }
-}
-
-void
-OCT_VAL_REP::set_index (const Matrix& m)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-
-  if (nr <= 1 || nc <= 1
-      || Vdo_fortran_indexing)
-    {
-      switch (type_tag)
-	{
-	case matrix_constant:
-	  matrix->set_index (m);
-	  break;
-
-	case OCT_VAL_REP::complex_matrix_constant:
-	  complex_matrix->set_index (m);
-	  break;
-
-	case OCT_VAL_REP::char_matrix_constant:
-	case OCT_VAL_REP::char_matrix_constant_str:
-	  char_matrix->set_index (m);
-	  break;
-
-	default:
-	  panic_impossible ();
-	  break;
-	}
-    }
-  else
-    ::error ("invalid matrix used as index");
-}
-
-// XXX FIXME XXX -- this should probably be handled some other way...
-// The arg here is expected to be ':'.
-void
-OCT_VAL_REP::set_index (char c)
-{
-  switch (type_tag)
-    {
-    case matrix_constant:
-      matrix->set_index (c);
-      break;
-
-    case OCT_VAL_REP::complex_matrix_constant:
-      complex_matrix->set_index (c);
-      break;
-
-    case OCT_VAL_REP::char_matrix_constant:
-    case OCT_VAL_REP::char_matrix_constant_str:
-      char_matrix->set_index (c);
-      break;
-
-    default:
-      panic_impossible ();
-      break;
-    }
-}
-
-void
-OCT_VAL_REP::set_index (const octave_value_list& args, bool rhs_is_complex)
-{
-  // XXX FIXME XXX -- it's not good that we have to list all the types
-  // that can be indexed here.
-
-  switch (type_tag)
-    {
-    case unknown_constant:
-    case scalar_constant:
-    case complex_scalar_constant:
-    case range_constant:
-      convert_to_matrix_type (rhs_is_complex);
-      break;
-
-    case matrix_constant:
-    case complex_matrix_constant:
-    case char_matrix_constant:
-    case char_matrix_constant_str:
-      break;
-
-    default:
-      ::error ("indexing %s type not implemented", type_name ());
-      break;
-    }
-
-  if (! error_state)
-    {
-      int n = args.length ();
-
-      for (int i = 0; i < n; i++)
-	{
-	  octave_value arg = args (i);
-
-	  switch (arg.const_type ())
-	    {
-	    case range_constant:
-	      set_index (arg.range_value ());
-	      break;
-
-	    case magic_colon:
-	      set_index (':');
-	      break;
-
-	    default:
-	      set_index (arg.matrix_value ());
-	      break;
-	    }
-
-	  if (error_state)
-	    {
-	      clear_index ();
-	      break;
-	    }
-	}
-    }
-}
-
-static inline bool
-valid_scalar_indices (const octave_value_list& args)
-{
-  int nargin = args.length ();
-
-  for (int i = 0; i < nargin; i++)
-    if (! args(i).valid_as_scalar_index ())
-      return false;
-
-  return true;
-}
-
-octave_value
-OCT_VAL_REP::do_index (const octave_value_list& args)
-{
-  octave_value retval;
-
-  if (error_state)
-    return retval;
-
-  bool originally_scalar_type = is_scalar_type ();
-
-  if (originally_scalar_type && valid_scalar_indices (args))
-    {
-      switch (type_tag)
-	{
-	case scalar_constant:
-	  retval = scalar;
-	  break;
-
-	case complex_scalar_constant:
-	  retval = *complex_scalar;
-	  break;
-
-	default:
-	  panic_impossible ();
-	  break;
-	}
-    }
-  else
-    {
-      set_index (args);
-
-      if (! error_state)
-	{
-	  switch (type_tag)
-	    {
-	    case range_constant:
-	      force_numeric ();
-	      // Fall through...
-
-	    case matrix_constant:
-	      retval = Matrix (matrix->value ());
-	      break;
-
-	    case complex_matrix_constant:
-	      retval = ComplexMatrix (complex_matrix->value ());
-	      break;
-
-	    case char_matrix_constant:
-	      retval = charMatrix (char_matrix->value ());
-	      break;
-
-	    case char_matrix_constant_str:
-	      {
-		// Kluge to prevent s([]) from turning into a string
-		// with no rows...
-		charMatrix tmp (char_matrix->value ());
-
-		if (tmp.rows () == 0 && tmp.columns () == 0)
-		  tmp.resize (1, 0);
-
-		retval = octave_value (tmp, 1);
-	      }
-	      break;
-
-	    default:
-	      error ("can't index %s variables", type_name ());
-	      break;
-	    }
-
-	  // We may have converted this value from a scalar to a
-	  // matrix to allow indexing to work.
-
-	  if (! error_state)
-	    maybe_mutate ();
-	}
-    }
-
-  return retval;
-}
-
-void
-OCT_VAL_REP::maybe_widen (OCT_VAL_REP::constant_type rhs_type)
-{
-  switch (type_tag)
-    {
-    case matrix_constant:
-      switch (rhs_type)
-	{
-	case complex_scalar_constant:
-	case complex_matrix_constant:
-	  {
-	    ComplexMatrix *cm = new ComplexMatrix (*matrix);
-	    delete matrix;
-	    complex_matrix = cm;
-	    type_tag = complex_matrix_constant;
-	  }
-	  break;
-
-	default:
-	  break;
-	}
-      break;
-
-    case char_matrix_constant:
-      switch (rhs_type)
-	{
-	case scalar_constant:
-	case matrix_constant:
-	  {
-	    Matrix *m = new Matrix (*char_matrix);
-	    delete matrix;
-	    matrix = m;
-	    type_tag = matrix_constant;
-	  }
-	  break;
-
-	case complex_scalar_constant:
-	case complex_matrix_constant:
-	  {
-	    ComplexMatrix *cm = new ComplexMatrix (*char_matrix);
-	    delete matrix;
-	    complex_matrix = cm;
-	    type_tag = complex_matrix_constant;
-	  }
-	  break;
-
-	default:
-	  break;
-	}
-      break;
-
-    default:
-      break;
-    }
-}
-
-// Assignment operations for the tree-constant representation class.
-
-// Top-level tree-constant function that handles assignments.  Only
-// decide if the left-hand side is currently a scalar or a matrix and
-// hand off to other functions to do the real work.
-
-// XXX FIXME XXX -- need some other way to make these functions
-// visible here (they should be in some header file...)
-
-extern void assign (Array2<Complex>&, const Array2<Complex>&);
-extern void assign (Array2<Complex>&, const Array2<double>&);
-extern void assign (Array2<Complex>&, const Array2<char>&);
-
-extern void assign (Array2<double>&, const Array2<double>&);
-extern void assign (Array2<double>&, const Array2<char>&);
-
-extern void assign (Array2<char>&, const Array2<char>&);
-
-void
-OCT_VAL_REP::assign (octave_value& rhs, const octave_value_list& args)
-{
-  // XXX FIXME XXX -- we should probably have special cases for rhs
-  // being a range type, since converting to a matrix can waste a lot
-  // of memory.
-
-  octave_value rhs_tmp = rhs;
-
-  if (! (is_string ()
-	 && (rhs_tmp.is_string ()
-	     || rhs_tmp.is_zero_by_zero ())))
-    {
-      rhs_tmp = rhs_tmp.make_numeric ();
-
-      if (error_state)
-	return;
-    }
-
-  if (rhs_tmp.is_string
-      && rhs_tmp.rows () == 1
-      && rhs_tmp.columns () == 0)
-    {
-      rhs_tmp = rhs_tmp.make_numeric (1);
-
-      if (error_state)
-	return;
-    }
-
-  // An assignment to a range will normally require a conversion to a
-  // vector in the end anyway, since it will normally destroy the
-  // equally-spaced property of the range elements.  This is not as
-  // memory efficient as possible, but it is much simpler than writing
-  // additional indexing and assignment functions especially for
-  // Ranges.
-
-  if (is_defined () && ! (is_numeric_type () || is_string ()))
-    {
-      force_numeric ();
-
-      if (error_state)
-	return;
-    }
-
-  if (! rhs_tmp.is_zero_by_zero ())
-    {
-      maybe_widen (rhs_tmp.const_type ());
-
-      if (error_state)
-	return;
-    }
-
-  set_index (args, rhs_tmp.is_complex_type ());
-
-  if (error_state)
-    return;
-
-  switch (type_tag)
-    {
-    case complex_matrix_constant:
-      {
-	switch (rhs_tmp.const_type ())
-	  {
-	  case complex_scalar_constant:
-	  case complex_matrix_constant:
-	    ::assign (*complex_matrix, rhs_tmp.complex_matrix_value ());
-	    break;
-
-	  case scalar_constant:
-	  case matrix_constant:
-	    ::assign (*complex_matrix, rhs_tmp.matrix_value ());
-	    break;
-
-	  default:
-	    panic_impossible ();;
-	    break;
-	  }
-      }
-      break;
-
-    case scalar_constant:
-    case matrix_constant:
-      {
-	switch (rhs_tmp.const_type ())
-	  {
-	  case scalar_constant:
-	  case matrix_constant:
-	    ::assign (*matrix, rhs_tmp.matrix_value ());
-	    break;
-
-	  case char_matrix_constant:
-	    ::assign (*matrix, rhs_tmp.char_matrix_value ());
-	    break;
-
-	  default:
-	    panic_impossible ();
-	    break;
-	  }
-      }
-      break;
-
-    case char_matrix_constant:
-      ::assign (*char_matrix, rhs_tmp.char_matrix_value ());
-      break;
-
-    case char_matrix_constant_str:
-      ::assign (*char_matrix, rhs_tmp.char_matrix_value ());
-      if (char_matrix->rows () == 0 && char_matrix->columns () == 0)
-	char_matrix->resize (1, 0);
-      break;
-
-    default:
-      panic_impossible ();
-      break;
-    }
-
-  // Do the right thing for assignments like `x(1) = pi' when x is
-  // undefined before the assignment.
-
-  if (is_matrix_type () || is_range ())
-    maybe_mutate ();
-}
-
-#endif
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/pt-const.h b/src/pt-const.h
--- a/src/pt-const.h
+++ b/src/pt-const.h
@@ -178,29 +178,16 @@ public:
     }
 
   octave_value assign (const octave_value_list& idx, const octave_value& rhs)
     {
       val.assign (idx, rhs);
       return val;
     }
 
-#if 0
-  // Simple structure assignment.
-
-  octave_value assign_map_element (SLList<string>& list,
-				   const octave_value& rhs);
-
-  // Indexed structure assignment.
-
-  octave_value assign_map_element (SLList<string>& list,
-				   const octave_value_list& args,
-				   const octave_value& rhs);
-#endif
-
   // Type.  It would be nice to eliminate the need for this.
 
   bool is_constant (void) const { return true; }
 
   // Size.
 
   int rows (void) const { return val.rows (); }
   int columns (void) const { return val.columns (); }
@@ -358,44 +345,27 @@ public:
   string type_name (void) const { return val.type_name (); }
 
 private:
 
   octave_value val;
 
   string orig_text;
 
-#if 0
-  octave_value_rep *make_unique_map (void);
-
-  // We want to eliminate this, or at least make it private.
-
-  octave_value_rep::constant_type const_type (void) const
-    { return rep->const_type (); }
-#endif
-
   void convert_to_matrix_type (bool make_complex)
     { val.convert_to_matrix_type (make_complex); }
 
   // Can we make these go away?
 
   // These need better names, since a range really is a numeric type.
 
   void force_numeric (bool frc_str_conv = false)
     { val.force_numeric (frc_str_conv); }
 
   octave_value make_numeric (bool frc_str_conv = false) const;
-#if 0
-    {
-      if (is_numeric_type ())
-	return *this;
-      else
-	return rep->make_numeric (frc_str_conv);
-    }
-#endif
 
   bool print_as_scalar (void) { return val.print_as_scalar (); }
 
   bool print_as_structure (void) { return val.print_as_structure (); }
 };
 
 #endif
 
diff --git a/src/pt-fcn.cc b/src/pt-fcn.cc
--- a/src/pt-fcn.cc
+++ b/src/pt-fcn.cc
@@ -86,25 +86,16 @@ tree_function::~tree_function (void)
 {
   delete param_list;
   delete ret_list;
   delete sym_tab;
   delete cmd_list;
   delete vr_list;
 }
 
-#if 0
-tree_function *
-tree_function::define (tree statement_list *t)
-{
-  cmd_list = t;
-  return this;
-}
-#endif
-
 tree_function *
 tree_function::define_param_list (tree_parameter_list *t)
 {
   param_list = t;
 
   if (param_list)
     {
       num_named_args = param_list->length ();
diff --git a/src/pt-fvc-base.cc b/src/pt-fvc-base.cc
--- a/src/pt-fvc-base.cc
+++ b/src/pt-fvc-base.cc
@@ -34,26 +34,16 @@ Software Foundation, 59 Temple Place - S
 
 #include "error.h"
 #include "oct-obj.h"
 #include "ov.h"
 #include "pt-fvc-base.h"
 
 // A base class for objects that can be evaluated with argument lists.
 
-#if 0
-octave_value&
-tree_fvc::assign (const octave_value_list&, const octave_value&)
-{
-  static octave_value foo;
-  panic_impossible ();
-  return foo;
-}
-#endif
-
 string
 tree_fvc::name (void) const
 {
   string retval;
   panic_impossible ();
   return retval;
 }
 
@@ -64,34 +54,16 @@ tree_fvc::increment (void)
 }
 
 void
 tree_fvc::decrement (void)
 {
   panic_impossible ();
 }
 
-#if 0
-octave_value
-tree_fvc::lookup_map_element (SLList<string>&, bool, bool)
-{
-  static octave_value retval;
-
-  int l = line ();
-  int c = column ();
-
-  if (l == -1 && c == -1)
-    ::error ("invalid structure reference");
-  else
-    ::error ("invalid structure reference near line %d column %d", l, c);
-
-  return retval;
-}
-#endif
-
 time_t
 tree_fvc::time_parsed (void)
 {
   panic_impossible ();
   return 0;
 }
 
 int
diff --git a/src/pt-fvc-base.h b/src/pt-fvc-base.h
--- a/src/pt-fvc-base.h
+++ b/src/pt-fvc-base.h
@@ -47,33 +47,22 @@ tree_fvc : public tree_multi_val_ret
 {
 public:
 
   tree_fvc (int l = -1, int c = -1)
     : tree_multi_val_ret (l, c) { }
 
   ~tree_fvc (void) { }
 
-#if 0
-  virtual octave_value& assign (const octave_value_list& args,
-				const octave_value& t); 
-#endif
-
   virtual string name (void) const;
 
   virtual void increment (void);
 
   virtual void decrement (void);
 
-#if 0
-  virtual octave_value lookup_map_element (SLList<string>& list,
-					    bool insert = false,
-					    bool silent = false);
-#endif
-
   virtual string fcn_file_name (void)
     { return string (); }
 
   virtual time_t time_parsed (void);
 
   virtual bool is_system_fcn_file (void) const
     { return false; }
 
diff --git a/src/pt-fvc.cc b/src/pt-fvc.cc
--- a/src/pt-fvc.cc
+++ b/src/pt-fvc.cc
@@ -197,97 +197,16 @@ tree_identifier::assign (const octave_va
 		sym->define (tmp);
 	    }
 	}
     }
 
   return retval;
 }
 
-#if 0
-octave_value
-tree_identifier::assign (SLList<string> list, const octave_value& rhs)
-{
-  octave_value retval;
-
-  if (rhs.is_defined ())
-    {
-      if (sym->is_function ())
-	sym->clear ();
-
-      tree_fvc *curr_val = sym->def ();
-
-      tree_constant *tmp = 0;
-      if (curr_val && curr_val->is_constant ())
-	tmp = (tree_constant *) curr_val;
-      else
-	{
-	  tmp = new tree_constant ();
-	  if (! sym->define (tmp))
-	    {
-	      delete tmp;
-	      tmp = 0;
-	    }
-	}
-
-      if (tmp)
-	retval = tmp->assign_map_element (list, rhs);
-    }
-
-  return retval;
-}
-
-octave_value
-tree_identifier::assign (SLList<string> list, const octave_value_list& args,
-			 const octave_value& rhs)
-{
-  octave_value retval;
-
-  if (rhs.is_defined ())
-    {
-      if (sym->is_function ())
-	sym->clear ();
-
-      if (sym->is_variable () && sym->is_defined ())
-	{
-	  tree_fvc *curr_val = sym->def ();
-
-	  tree_constant *tmp;
-	  if (curr_val && curr_val->is_constant ())
-	    tmp = (tree_constant *) curr_val;
-	  else
-	    panic_impossible ();
-
-	  retval = tmp->assign_map_element (list, args, rhs);
-	}
-      else
-	{
-	  assert (! sym->is_defined ());
-
-	  if (! Vresize_on_range_error)
-	    {
-	      ::error ("indexed assignment to previously undefined variables");
-	      ::error ("is only possible when resize_on_range_error is true");
-	    }
-	  else
-	    {
-	      tree_constant *tmp = new tree_constant ();
-
-	      retval = tmp->assign_map_element (list, args, rhs);
-
-	      if (retval.is_defined ())
-		sym->define (tmp);
-	    }
-	}
-    }
-
-  return retval;
-}
-#endif
-
 bool
 tree_identifier::is_defined (void)
 {
   return (sym && sym->is_defined ());
 }
 
 void
 tree_identifier::increment (void)
@@ -517,35 +436,16 @@ tree_indirect_ref::name (void) const
 
       retval.append (".");
       retval.append (nm);
     }
 	
   return retval;
 }
 
-#if 0
-octave_value
-tree_indirect_ref::assign (const octave_value& t)
-{
-  octave_value& tmp = reference ();
-
-  return tmp = t;
-}
-
-octave_value
-tree_indirect_ref::assign (const octave_value_list& args,
-			   const octave_value& t)
-{
-  octave_value& tmp = reference ();
-
-  return tmp.assign (args, t);
-}
-#endif
-
 octave_value
 tree_indirect_ref::eval (bool print)
 {
   octave_value retval;
 
   if (is_identifier_only ())
     retval = id->eval (print);
   else
@@ -646,35 +546,16 @@ tree_indirect_ref::reference (void)
 	{
 	  static octave_value foo;
 	  panic_impossible ();
 	  return foo;
 	}
     }
 }
 
-#if 0
- if (indir)
-    {
-      octave_value& retval = indir->reference ();
-
-      if (! error_state)
-	retval = retval.map_elt_reference (nm);
-
-      return retval;
-    }
-  else
-    {
-      static octave_value foo;
-      panic_impossible ();
-      return foo;
-    }
-}
-#endif
-
 // Builtin functions.
 
 tree_builtin::tree_builtin (const string& nm)
 {
   is_mapper = 0;
   fcn = 0;
   my_name = nm;
 }
diff --git a/src/pt-fvc.h b/src/pt-fvc.h
--- a/src/pt-fvc.h
+++ b/src/pt-fvc.h
@@ -66,22 +66,16 @@ public:
   tree_identifier *define (tree_constant *t);
   tree_identifier *define (tree_function *t);
 
   void document (const string& s);
 
   octave_value assign (const octave_value& t);
   octave_value assign (const octave_value_list& args, const octave_value& t);
 
-#if 0
-  octave_value assign (SLList<string> list, const octave_value& t);
-  octave_value assign (SLList<string> list, const octave_value_list& args,
-		       const octave_value& t);
-#endif
-
   bool is_defined (void);
 
   void increment (void);
 
   void decrement (void);
 
   tree_fvc *do_lookup (bool& script_file_executed, bool exec_script = true);
 
@@ -89,17 +83,18 @@ public:
 
   void mark_as_formal_parameter (void);
 
   void mark_for_possible_ans_assign (void)
     { maybe_do_ans_assign = true; }
 
   octave_value eval (bool print);
 
-  octave_value_list eval (bool print, int nargout, const octave_value_list& args);
+  octave_value_list eval (bool print, int nargout,
+			  const octave_value_list& args); 
 
   void eval_undefined_error (void);
 
   void accept (tree_walker& tw);
 
   octave_value value (void) const;
 
   octave_value& reference (void);
@@ -162,21 +157,16 @@ public:
       maybe_do_ans_assign = true;
 
       if (is_identifier_only ())
 	id->mark_for_possible_ans_assign ();
     }
 
   string name (void) const;
 
-#if 0
-  octave_value& assign (const octave_value& t);
-  octave_value& assign (const octave_value_list& args, const octave_value& t);
-#endif
-
   octave_value eval (bool print);
 
   octave_value_list eval (bool print, int nargout,
 			  const octave_value_list& args);
 
   octave_value value (void) const;
   octave_value& reference (void);
 
diff --git a/src/rand.cc b/src/rand.cc
--- a/src/rand.cc
+++ b/src/rand.cc
@@ -119,33 +119,28 @@ curr_rand_dist (void)
 // Make the random number generator give us a different sequence every
 // time we start octave unless we specifically set the seed.  The
 // technique used below will cycle monthly, but it it does seem to
 // work ok to give fairly different seeds each time Octave starts.
 
 static void
 do_initialization (void)
 {
-#if 0
-  int s0 = 1234567890;
-  int s1 = 123456789;
-#else
   time_t now;
   struct tm *tm;
  
   time (&now);
   tm = localtime (&now);
  
   int hour = tm->tm_hour + 1;
   int minute = tm->tm_min + 1;
   int second = tm->tm_sec + 1;
 
   int s0 = tm->tm_mday * hour * minute * second;
   int s1 = hour * minute * second;
-#endif
 
   s0 = force_to_fit_range (s0, 1, 2147483563);
   s1 = force_to_fit_range (s1, 1, 2147483399);
 
   F77_FCN (setall, SETALL) (s0, s1);
 
   initialized = 1;
 }
diff --git a/src/sighandlers.cc b/src/sighandlers.cc
--- a/src/sighandlers.cc
+++ b/src/sighandlers.cc
@@ -74,26 +74,16 @@ octave_save_signal_mask (void)
 void
 octave_restore_signal_mask (void)
 {
 #if defined (HAVE_POSIX_SIGNALS)
   sigprocmask (SIG_SETMASK, &octave_signal_mask, 0);
 #endif
 }
 
-#if 0
-void
-ignore_sigchld (void)
-{
-#if defined (SIGCHLD)
-  octave_set_signal_handler (SIGCHLD, SIG_IGN);
-#endif
-}
-#endif
-
 static void
 my_friendly_exit (const char *sig_name, int sig_number)
 {
   error ("%s -- stopping myself...", sig_name);
 
   save_user_variables ();
 
   clean_up_and_exit (sig_number);
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -1364,35 +1364,16 @@ alias_builtin (const string& alias, cons
     sr_alias->alias (sr_name);
   else
     panic ("can't find symbol record for builtin function `%s'",
 	   alias.c_str ());
 }
 
 // Defining variables.
 
-#if 0
-void
-bind_nargin_and_nargout (symbol_table *sym_tab, int nargin, int nargout)
-{
-  octave_value *tmp;
-  symbol_record *sr;
-
-  sr = sym_tab->lookup ("nargin", 1, 0);
-  sr->unprotect ();
-  tmp = new octave_value (nargin);
-  sr->define (tmp);
-
-  sr = sym_tab->lookup ("nargout", 1, 0);
-  sr->unprotect ();
-  tmp = new octave_value (nargout);
-  sr->define (tmp);
-}
-#endif
-
 void
 bind_ans (const octave_value& val, int print)
 {
   static symbol_record *sr = global_sym_tab->lookup ("ans", 1, 0);
 
   tree_identifier *ans_id = new tree_identifier (sr);
   tree_constant *tmp = new tree_constant (val);
 
diff --git a/src/variables.h b/src/variables.h
--- a/src/variables.h
+++ b/src/variables.h
@@ -139,21 +139,16 @@ extern void install_builtin_variable (co
 extern void
 install_builtin_variable_as_function (const string& name,
 				      const octave_value& val,
 				      int protect = 0, int eternal = 0,
 				      const string& help = string ());
 
 extern void alias_builtin (const string& alias, const string& name);
 
-#if 0
-extern void bind_nargin_and_nargout (symbol_table *sym_tab,
-				     int nargin, int nargout);
-#endif
-
 extern void bind_ans (const octave_value& val, int print);
 
 extern void bind_global_error_variable (void);
 
 extern void clear_global_error_variable (void *);
 
 extern void bind_builtin_variable (const string&, const octave_value&,
 				   int protect = 0, int eternal = 0,
