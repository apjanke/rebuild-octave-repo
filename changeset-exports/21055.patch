# HG changeset patch
# User Rik <rik@octave.org>
# Date 1452711742 28800
#      Wed Jan 13 11:02:22 2016 -0800
# Node ID 5e00ed38a58bd2d6cce46554210016e44ee23fb8
# Parent  221847e5f4880a72117fe9d11f29508ebd3e6b4a
maint: Replace if/error/else paradigm with just if/error.

* __ilu__.cc, data.cc, file-io.cc, graphics.cc, graphics.in.h, ls-mat5.cc,
lu.cc, octave-link.cc, regexp.cc, schur.cc, spparms.cc, sub2ind.cc,
syscalls.cc, toplev.cc, variables.cc, xpow.cc, audiodevinfo.cc, ccolamd.cc,
ov-builtin.cc, ov-classdef.cc, ov-intx.h, ov-lazy-idx.cc, ov-mex-fcn.cc,
op-int.h, lex.ll, oct-parse.in.yy, pt-binop.cc, pt-cbinop.cc, pt-const.cc,
pt-decl.h, pt-fcn-handle.cc, pt-unop.cc, CollocWt.cc:
Replace if/error/else paradigm with just if/error.

diff --git a/libinterp/corefcn/__ilu__.cc b/libinterp/corefcn/__ilu__.cc
--- a/libinterp/corefcn/__ilu__.cc
+++ b/libinterp/corefcn/__ilu__.cc
@@ -356,16 +356,17 @@ void ilu_crout (octave_matrix_t& sm_l, o
 
 
       total_len_u += w_len_u;
       total_len_l += w_len_l;
       // Check if there are too many elements to be indexed with
       // octave_idx_type type due to fill-in during the process.
       if (total_len_l < 0 || total_len_u < 0)
         error ("ilu: integer overflow.  Too many fill-in elements in L or U");
+
       cidx_u[k+1] = cidx_u[k] - cidx_u[0] + w_len_u;
       cidx_l[k+1] = cidx_l[k] - cidx_l[0] + w_len_l;
 
       // The tricky part of the algorithm.  The arrays pointing to the first
       // working element of each column in the next iteration (Lfirst) or
       // the first working element of each row (Ufirst) are updated.  Also the
       // arrays working as lists cols_list and rows_list are filled with
       // indices pointing to Ufirst and Lfirst respectively.
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -921,16 +921,18 @@ negative numbers or when the values are 
 ## Bug #45587
 %!assert (signbit (mod (-0, 0)))
 %!assert (! signbit (mod (0, -0)))
 
 ## Bug #42627
 %!assert (mod (0.94, 0.01), 0.0)
 */
 
+// FIXME: Macros NATIVE_REDUCTION_1 and NATIVE_REDUCTION seem to be unused.
+//        Checked 1/23/2016.  They should probably be removed for clarity.
 // FIXME: Need to convert reduction functions of this file for single precision
 
 #define NATIVE_REDUCTION_1(FCN, TYPE, DIM) \
   (arg.is_ ## TYPE ## _type ()) \
     { \
       TYPE ## NDArray tmp = arg. TYPE ##_array_value (); \
  \
       retval = tmp.FCN (DIM); \
@@ -948,17 +950,18 @@ negative numbers or when the values are 
       std::string str = args(nargin - 1).string_value (); \
  \
       if (str == "native") \
         isnative = true; \
       else if (str == "double") \
         isdouble = true; \
       else \
         error ("sum: unrecognized string argument"); \
-      nargin --; \
+ \
+      nargin--; \
     } \
  \
   if (nargin < 1 || nargin > 2) \
     print_usage (); \
  \
   octave_value retval; \
  \
   octave_value arg = args(0); \
@@ -1229,16 +1232,17 @@ See @code{sum} for an explanation of the
       std::string str = args(nargin - 1).string_value ();
 
       if (str == "native")
         isnative = true;
       else if (str == "double")
         isdouble = true;
       else
         error ("cumsum: unrecognized string argument");
+
       nargin --;
     }
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   int dim = -1;
   if (nargin == 2)
@@ -1514,16 +1518,17 @@ in double precision even for single prec
       std::string str = args(nargin - 1).string_value ();
 
       if (str == "native")
         isnative = true;
       else if (str == "double")
         isdouble = true;
       else
         error ("prod: unrecognized type argument '%s'", str.c_str ());
+
       nargin --;
     }
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   octave_value retval;
 
@@ -2112,16 +2117,17 @@ do_cat (const octave_value_list& xargs, 
               tmp = do_cat_op (tmp, args(j), ra_idx);
 
               dim_vector dv_tmp = args(j).dims ();
 
               if (dim >= dv_len)
                 {
                   if (j > 1)
                     error ("%s: indexing error", fname.c_str ());
+
                   break;
                 }
               else
                 ra_idx(dim) += (dim < dv_tmp.length () ? dv_tmp(dim) : 1);
             }
           retval = tmp;
         }
     }
@@ -2989,16 +2995,17 @@ inputs, @qcode{\"extra\"} is the same as
       if (str == "native")
         isnative = true;
       else if (str == "double")
         isdouble = true;
       else if (str == "extra")
         isextra = true;
       else
         error ("sum: unrecognized type argument '%s'", str.c_str ());
+
       nargin --;
     }
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   int dim = -1;
   if (nargin == 2)
@@ -5610,16 +5617,17 @@ compute the norms of each column and ret
       else if (str == "rows")
         strflag = sfrows;
       else if (str == "fro")
         strflag = sffrob;
       else if (str == "inf")
         strflag = sfinf;
       else
         error ("norm: unrecognized option: %s", str.c_str ());
+
       // we've handled the last parameter, so act as if it was removed
       nargin --;
     }
 
   octave_value p_arg = (nargin > 1) ? args(1) : octave_value (2);
 
   if (p_arg.is_empty ())
     p_arg = octave_value (2);
@@ -7257,57 +7265,54 @@ do_merge (const Array<bool>& mask,
 {
   typedef typename NDT::element_type T;
   dim_vector dv = mask.dims ();
   NDT retval (dv);
 
   bool tscl = tval.numel () == 1;
   bool fscl = fval.numel () == 1;
 
-  if ((! tscl && tval.dims () != dv)
-      || (! fscl && fval.dims () != dv))
+  if ((! tscl && tval.dims () != dv) || (! fscl && fval.dims () != dv))
     error ("merge: MASK, TVAL, and FVAL dimensions must match");
-  else
+
+  T *rv = retval.fortran_vec ();
+  octave_idx_type n = retval.numel ();
+
+  const T *tv = tval.data ();
+  const T *fv = fval.data ();
+  const bool *mv = mask.data ();
+
+  if (tscl)
     {
-      T *rv = retval.fortran_vec ();
-      octave_idx_type n = retval.numel ();
-
-      const T *tv = tval.data ();
-      const T *fv = fval.data ();
-      const bool *mv = mask.data ();
-
-      if (tscl)
+      if (fscl)
         {
-          if (fscl)
-            {
-              T ts = tv[0];
-              T fs = fv[0];
-              for (octave_idx_type i = 0; i < n; i++)
-                rv[i] = mv[i] ? ts : fs;
-            }
-          else
-            {
-              T ts = tv[0];
-              for (octave_idx_type i = 0; i < n; i++)
-                rv[i] = mv[i] ? ts : fv[i];
-            }
+          T ts = tv[0];
+          T fs = fv[0];
+          for (octave_idx_type i = 0; i < n; i++)
+            rv[i] = mv[i] ? ts : fs;
         }
       else
         {
-          if (fscl)
-            {
-              T fs = fv[0];
-              for (octave_idx_type i = 0; i < n; i++)
-                rv[i] = mv[i] ? tv[i] : fs;
-            }
-          else
-            {
-              for (octave_idx_type i = 0; i < n; i++)
-                rv[i] = mv[i] ? tv[i] : fv[i];
-            }
+          T ts = tv[0];
+          for (octave_idx_type i = 0; i < n; i++)
+            rv[i] = mv[i] ? ts : fv[i];
+        }
+    }
+  else
+    {
+      if (fscl)
+        {
+          T fs = fv[0];
+          for (octave_idx_type i = 0; i < n; i++)
+            rv[i] = mv[i] ? tv[i] : fs;
+        }
+      else
+        {
+          for (octave_idx_type i = 0; i < n; i++)
+            rv[i] = mv[i] ? tv[i] : fv[i];
         }
     }
 
   return retval;
 }
 
 #define MAKE_INT_BRANCH(INTX) \
   else if (tval.is_ ## INTX ## _type () && fval.is_ ## INTX ## _type ()) \
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -1866,28 +1866,28 @@ static int
 convert (int x, int ibase, int obase)
 {
   int retval = 0;
 
   int tmp = x % obase;
 
   if (tmp > ibase - 1)
     error ("umask: invalid digit");
-  else
+
+  retval = tmp;
+  int mult = ibase;
+  while ((x = (x - tmp) / obase))
     {
-      retval = tmp;
-      int mult = ibase;
-      while ((x = (x - tmp) / obase))
-        {
-          tmp = x % obase;
-          if (tmp > ibase - 1)
-            error ("umask: invalid digit");
-          retval += mult * tmp;
-          mult *= ibase;
-        }
+      tmp = x % obase;
+
+      if (tmp > ibase - 1)
+        error ("umask: invalid digit");
+
+      retval += mult * tmp;
+      mult *= ibase;
     }
 
   return retval;
 }
 
 DEFUNX ("umask", Fumask, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {} umask (@var{mask})\n\
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -8724,16 +8724,17 @@ uicontrol::properties::update_units (voi
   cached_units = get_units ();
 }
 
 void
 uicontrol::properties::set_style (const octave_value& st)
 {
   if (! get___object__ ().is_empty ())
     error ("set: cannot change the style of a uicontrol object after creation.");
+
   style = st;
 }
 
 Matrix
 uicontrol::properties::get_boundingbox (bool,
                                         const Matrix& parent_pix_size) const
 {
   Matrix pos = get_position ().matrix_value ();
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -2725,16 +2725,17 @@ public:
   {
     error ("base_graphics_object::get_defaults: invalid graphics object");
   }
 
   virtual property_list get_defaults_list (void) const
   {
     if (! valid_object ())
       error ("base_graphics_object::get_defaults_list: invalid graphics object");
+
     return property_list ();
   }
 
   virtual octave_value get_factory_defaults (void) const
   {
     error ("base_graphics_object::get_factory_defaults: invalid graphics object");
   }
 
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -1489,16 +1489,17 @@ read_mat5_binary_file_header (std::istre
   if (magic == 0x4d49)
     swap = 0;
   else if (magic == 0x494d)
     swap = 1;
   else
     {
       if (! quiet)
         error ("load: can't read binary file");
+
       return -1;
     }
 
   if (! swap)                   // version number is inverse swapped!
     version = ((version >> 8) & 0xff) + ((version & 0xff) << 8);
 
   if (version != 1 && ! quiet)
     warning ("load: found version %d binary MAT file, "
diff --git a/libinterp/corefcn/lu.cc b/libinterp/corefcn/lu.cc
--- a/libinterp/corefcn/lu.cc
+++ b/libinterp/corefcn/lu.cc
@@ -162,18 +162,18 @@ information.\n\
             vecout = true;
           else
             error ("lu: unrecognized string argument");
         }
       else
         {
           if (! issparse)
             error ("lu: can not define pivoting threshold THRES for full matrices");
+
           Matrix tmp = args(n++).matrix_value ();
-
           if (tmp.numel () == 1)
             {
               thres.resize (1,2);
               thres(0) = tmp(0);
               thres(1) = tmp(0);
             }
           else if (tmp.numel () == 2)
             thres = tmp;
diff --git a/libinterp/corefcn/octave-link.cc b/libinterp/corefcn/octave-link.cc
--- a/libinterp/corefcn/octave-link.cc
+++ b/libinterp/corefcn/octave-link.cc
@@ -69,18 +69,18 @@ octave_link::set_workspace (void)
 // class octave_link, or 0 to disconnect the link.  It is the
 // responsibility of the caller to delete obj.
 
 void
 octave_link::connect_link (octave_link* obj)
 {
   if (obj && instance)
     error ("octave_link is already linked!");
-  else
-    instance = obj;
+
+  instance = obj;
 }
 
 void
 octave_link::do_generate_events (void)
 {
 }
 
 void
diff --git a/libinterp/corefcn/regexp.cc b/libinterp/corefcn/regexp.cc
--- a/libinterp/corefcn/regexp.cc
+++ b/libinterp/corefcn/regexp.cc
@@ -570,35 +570,32 @@ octcellregexp (const octave_value_list &
                                                      case_insensitive);
 
                   for (int j = 0; j < nargout; j++)
                     newretval[j](i) = tmp(j);
                 }
             }
           else if (cellstr.numel () == cellpat.numel ())
             {
-
               if (cellstr.dims () != cellpat.dims ())
                 error ("%s: inconsistent cell array dimensions", who.c_str ());
-              else
-                {
-                  for (int j = 0; j < nargout; j++)
-                    newretval[j].resize (cellstr.dims ());
+
+              for (int j = 0; j < nargout; j++)
+                newretval[j].resize (cellstr.dims ());
 
-                  for (octave_idx_type i = 0; i < cellstr.numel (); i++)
-                    {
-                      new_args(0) = cellstr(i);
-                      new_args(1) = cellpat(i);
+              for (octave_idx_type i = 0; i < cellstr.numel (); i++)
+                {
+                  new_args(0) = cellstr(i);
+                  new_args(1) = cellpat(i);
 
-                      octave_value_list tmp = octregexp (new_args, nargout, who,
-                                                         case_insensitive);
+                  octave_value_list tmp = octregexp (new_args, nargout, who,
+                                                     case_insensitive);
 
-                      for (int j = 0; j < nargout; j++)
-                        newretval[j](i) = tmp(j);
-                    }
+                  for (int j = 0; j < nargout; j++)
+                    newretval[j](i) = tmp(j);
                 }
             }
           else
             error ("regexp: cell array arguments must be scalar or equal size");
         }
       else
         {
           for (int j = 0; j < nargout; j++)
diff --git a/libinterp/corefcn/schur.cc b/libinterp/corefcn/schur.cc
--- a/libinterp/corefcn/schur.cc
+++ b/libinterp/corefcn/schur.cc
@@ -296,17 +296,16 @@ Note also that @var{U} and @var{T} are n
   if (! args(0).is_numeric_type ())
     gripe_wrong_type_arg ("rsf2csf", args(0));
   else if (! args(1).is_numeric_type ())
     gripe_wrong_type_arg ("rsf2csf", args(1));
   else if (args(0).is_complex_type () || args(1).is_complex_type ())
     error ("rsf2csf: UR and TR must be real matrices");
   else
     {
-
       if (args(0).is_single_type () || args(1).is_single_type ())
         {
           FloatMatrix u = args(0).float_matrix_value ();
           FloatMatrix t = args(1).float_matrix_value ();
 
           FloatComplexSCHUR cs (FloatSCHUR (t, u));
 
           retval = ovl (cs.unitary_matrix (), cs.schur_matrix ());
diff --git a/libinterp/corefcn/spparms.cc b/libinterp/corefcn/spparms.cc
--- a/libinterp/corefcn/spparms.cc
+++ b/libinterp/corefcn/spparms.cc
@@ -142,28 +142,27 @@ longer running time.\n\
             }
           else if (str == "tight")
             octave_sparse_params::tight ();
           else
             {
               double val = octave_sparse_params::get_key (str);
               if (xisnan (val))
                 error ("spparms: KEY not recognized");
-              else
-                retval = ovl (val);
+
+              retval = ovl (val);
             }
         }
       else
         {
           NDArray vals = args(0).xarray_value ("spparms: input must be a string or a vector");
-
           if (vals.numel () > OCTAVE_SPARSE_CONTROLS_SIZE)
             error ("spparms: too many elements in vector VALS");
-          else
-            octave_sparse_params::set_vals (vals);
+
+          octave_sparse_params::set_vals (vals);
         }
     }
   else if (nargin == 2)
     {
       std::string str = args(0).xstring_value ("spparms: first argument must be a string");
 
       double val = args(1).xdouble_value ("spparms: second argument must be a real scalar");
 
diff --git a/libinterp/corefcn/sub2ind.cc b/libinterp/corefcn/sub2ind.cc
--- a/libinterp/corefcn/sub2ind.cc
+++ b/libinterp/corefcn/sub2ind.cc
@@ -38,28 +38,26 @@ static dim_vector
 get_dim_vector (const octave_value& val, const char *name)
 {
   RowVector dimsv = val.row_vector_value (false, true);
   dim_vector dv;
   octave_idx_type n = dimsv.numel ();
 
   if (n < 1)
     error ("%s: dimension vector DIMS must not be empty", name);
-  else
+
+  dv.resize (std::max (n, static_cast<octave_idx_type> (2)));
+  dv(1) = 1;
+  for (octave_idx_type i = 0; i < n; i++)
     {
-      dv.resize (std::max (n, static_cast<octave_idx_type> (2)));
-      dv(1) = 1;
-      for (octave_idx_type i = 0; i < n; i++)
-        {
-          octave_idx_type ii = dimsv(i);
-          if (ii == dimsv(i) && ii >= 0)
-            dv(i) = ii;
-          else
-            error ("%s: dimension vector DIMS must contain integers", name);
-        }
+      octave_idx_type ii = dimsv(i);
+      if (ii == dimsv(i) && ii >= 0)
+        dv(i) = ii;
+      else
+        error ("%s: dimension vector DIMS must contain integers", name);
     }
 
   return dv;
 }
 
 DEFUN (sub2ind, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{ind} =} sub2ind (@var{dims}, @var{i}, @var{j})\n\
diff --git a/libinterp/corefcn/syscalls.cc b/libinterp/corefcn/syscalls.cc
--- a/libinterp/corefcn/syscalls.cc
+++ b/libinterp/corefcn/syscalls.cc
@@ -635,28 +635,28 @@ static int
 convert (int x, int ibase, int obase)
 {
   int retval = 0;
 
   int tmp = x % obase;
 
   if (tmp > ibase - 1)
     error ("mkfifo: invalid digit");
-  else
+
+  retval = tmp;
+  int mult = ibase;
+  while ((x = (x - tmp) / obase))
     {
-      retval = tmp;
-      int mult = ibase;
-      while ((x = (x - tmp) / obase))
-        {
-          tmp = x % obase;
-          if (tmp > ibase - 1)
-            error ("mkfifo: invalid digit");
-          retval += mult * tmp;
-          mult *= ibase;
-        }
+      tmp = x % obase;
+
+      if (tmp > ibase - 1)
+        error ("mkfifo: invalid digit");
+
+      retval += mult * tmp;
+      mult *= ibase;
     }
 
   return retval;
 }
 
 DEFUNX ("mkfifo", Fmkfifo, args, ,
         "-*- texinfo -*-\n\
 @deftypefn  {} {@var{err} =} mkfifo (@var{name}, @var{mode})\n\
diff --git a/libinterp/corefcn/toplev.cc b/libinterp/corefcn/toplev.cc
--- a/libinterp/corefcn/toplev.cc
+++ b/libinterp/corefcn/toplev.cc
@@ -833,37 +833,35 @@ to run using @code{atexit}.\n\
   // Confirm OK to shutdown.  Note: A dynamic function installation similar
   // to overriding polymorphism for which the GUI can install its own "quit"
   // yet call this base "quit" could be nice.  No link would be needed here.
   if (! octave_link::confirm_shutdown ())
     return retval;
 
   if (! quit_allowed)
     error ("quit: not supported in embedded mode");
-  else
+
+  if (args.length () > 0)
     {
-      if (args.length () > 0)
-        {
-          int tmp = args(0).nint_value ();
+      int tmp = args(0).nint_value ();
 
-          exit_status = tmp;
-        }
+      exit_status = tmp;
+    }
 
-      // Instead of simply calling exit, we simulate an interrupt
-      // with a request to exit cleanly so that no matter where the
-      // call to quit occurs, we will run the unwind_protect stack,
-      // clear the OCTAVE_LOCAL_BUFFER allocations, etc. before
-      // exiting.
+  // Instead of simply calling exit, we simulate an interrupt
+  // with a request to exit cleanly so that no matter where the
+  // call to quit occurs, we will run the unwind_protect stack,
+  // clear the OCTAVE_LOCAL_BUFFER allocations, etc. before
+  // exiting.
 
-      quitting_gracefully = true;
+  quitting_gracefully = true;
 
-      octave_interrupt_state = -1;
+  octave_interrupt_state = -1;
 
-      octave_throw_interrupt_exception ();
-    }
+  octave_throw_interrupt_exception ();
 
   return retval;
 }
 
 DEFALIAS (exit, quit);
 
 DEFUN (warranty, , ,
        "-*- texinfo -*-\n\
@@ -1073,19 +1071,17 @@ command shell that is started to run the
       // FIXME: maybe this should go in sysdep.cc?
 #ifdef HAVE_FORK
       pid_t pid = fork ();
 
       if (pid < 0)
         error ("system: fork failed -- can't create child process");
       else if (pid == 0)
         {
-          // FIXME: should probably replace this
-          // call with something portable.
-
+          // FIXME: should probably replace this call with something portable.
           execl (SHELL_PATH, "sh", "-c", cmd_str.c_str (),
                  static_cast<void *> (0));
 
           panic_impossible ();
         }
       else
         retval(0) = pid;
 #elif defined (__WIN32__)
@@ -1093,22 +1089,20 @@ command shell that is started to run the
       PROCESS_INFORMATION pi;
       ZeroMemory (&si, sizeof (si));
       ZeroMemory (&pi, sizeof (pi));
       OCTAVE_LOCAL_BUFFER (char, xcmd_str, cmd_str.length ()+1);
       strcpy (xcmd_str, cmd_str.c_str ());
 
       if (! CreateProcess (0, xcmd_str, 0, 0, FALSE, 0, 0, 0, &si, &pi))
         error ("system: CreateProcess failed -- can't create child process");
-      else
-        {
-          retval(0) = pi.dwProcessId;
-          CloseHandle (pi.hProcess);
-          CloseHandle (pi.hThread);
-        }
+
+      retval(0) = pi.dwProcessId;
+      CloseHandle (pi.hProcess);
+      CloseHandle (pi.hThread);
 #else
       error ("system: asynchronous system calls are not supported");
 #endif
     }
   else if (return_output)
     retval = run_command_and_return_output (cmd_str);
   else
     {
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -839,18 +839,17 @@ set_internal_variable (int& var, const o
 
   if (nargin == 1)
     {
       int ival = args(0).xint_value ("%s: argument must be an integer value", nm);
 
       if (ival < minval)
         error ("%s: arg must be greater than %d", nm, minval);
       else if (ival > maxval)
-        error ("%s: arg must be less than or equal to %d",
-               nm, maxval);
+        error ("%s: arg must be less than or equal to %d", nm, maxval);
       else
         var = ival;
     }
 
   return retval;
 }
 
 octave_value
@@ -1606,41 +1605,39 @@ do_who (int argc, const string_vector& a
           // FIXME: This is an inefficient manner to implement this as the
           // variables are loaded in to a temporary context and then treated.
           // It would be better to refecat symbol_info_list to not store the
           // symbol records and then use it in load-save.cc (do_load) to
           // implement this option there so that the variables are never
           // stored at all.
           if (i == argc - 1)
             error ("whos: -file argument must be followed by a filename");
-          else
-            {
-              std::string nm = argv[i + 1];
-
-              unwind_protect frame;
-
-              // Set up temporary scope.
-
-              symbol_table::scope_id tmp_scope = symbol_table::alloc_scope ();
-              frame.add_fcn (symbol_table::erase_scope, tmp_scope);
-
-              symbol_table::set_scope (tmp_scope);
-
-              octave_call_stack::push (tmp_scope, 0);
-              frame.add_fcn (octave_call_stack::pop);
-
-              frame.add_fcn (symbol_table::clear_variables);
-
-              feval ("load", octave_value (nm), 0);
-
-              std::string newmsg = std::string ("Variables in the file ")
-                + nm + ":\n\n";
-
-              retval =  do_who (i, argv, return_list, verbose, newmsg);
-            }
+
+          std::string nm = argv[i + 1];
+
+          unwind_protect frame;
+
+          // Set up temporary scope.
+
+          symbol_table::scope_id tmp_scope = symbol_table::alloc_scope ();
+          frame.add_fcn (symbol_table::erase_scope, tmp_scope);
+
+          symbol_table::set_scope (tmp_scope);
+
+          octave_call_stack::push (tmp_scope, 0);
+          frame.add_fcn (octave_call_stack::pop);
+
+          frame.add_fcn (symbol_table::clear_variables);
+
+          feval ("load", octave_value (nm), 0);
+
+          std::string newmsg = std::string ("Variables in the file ")
+            + nm + ":\n\n";
+
+          retval =  do_who (i, argv, return_list, verbose, newmsg);
 
           return retval;
         }
       else if (argv[i] == "-regexp")
         have_regexp = true;
       else if (argv[i] == "global")
         global_only = true;
       else if (argv[i][0] == '-')
diff --git a/libinterp/corefcn/xpow.cc b/libinterp/corefcn/xpow.cc
--- a/libinterp/corefcn/xpow.cc
+++ b/libinterp/corefcn/xpow.cc
@@ -105,45 +105,43 @@ xpow (double a, const Matrix& b)
 {
   octave_value retval;
 
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for x^A, A must be a square matrix. Use .^ for elementwise power.");
-  else
+
+  try
     {
-      try
+      EIG b_eig (b);
+
+      ComplexColumnVector lambda (b_eig.eigenvalues ());
+      ComplexMatrix Q (b_eig.eigenvectors ());
+
+      for (octave_idx_type i = 0; i < nr; i++)
         {
-          EIG b_eig (b);
-
-          ComplexColumnVector lambda (b_eig.eigenvalues ());
-          ComplexMatrix Q (b_eig.eigenvectors ());
-
-          for (octave_idx_type i = 0; i < nr; i++)
-            {
-              Complex elt = lambda(i);
-              if (std::imag (elt) == 0.0)
-                lambda(i) = std::pow (a, std::real (elt));
-              else
-                lambda(i) = std::pow (a, elt);
-            }
-          ComplexDiagMatrix D (lambda);
-
-          ComplexMatrix C = Q * D * Q.inverse ();
-          if (a > 0)
-            retval = real (C);
+          Complex elt = lambda(i);
+          if (std::imag (elt) == 0.0)
+            lambda(i) = std::pow (a, std::real (elt));
           else
-            retval = C;
+            lambda(i) = std::pow (a, elt);
         }
-      catch (const octave_execution_exception&)
-        {
-          gripe_failed_diagonalization ();
-        }
+      ComplexDiagMatrix D (lambda);
+
+      ComplexMatrix C = Q * D * Q.inverse ();
+      if (a > 0)
+        retval = real (C);
+      else
+        retval = C;
+    }
+  catch (const octave_execution_exception&)
+    {
+      gripe_failed_diagonalization ();
     }
 
   return retval;
 }
 
 // -*- 3 -*-
 octave_value
 xpow (double a, const Complex& b)
@@ -158,127 +156,123 @@ xpow (double a, const ComplexMatrix& b)
 {
   octave_value retval;
 
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for x^A, A must be a square matrix. Use .^ for elementwise power.");
-  else
+
+  EIG b_eig (b);
+
+  try
     {
-      EIG b_eig (b);
-
-      try
+      ComplexColumnVector lambda (b_eig.eigenvalues ());
+      ComplexMatrix Q (b_eig.eigenvectors ());
+
+      for (octave_idx_type i = 0; i < nr; i++)
         {
-          ComplexColumnVector lambda (b_eig.eigenvalues ());
-          ComplexMatrix Q (b_eig.eigenvectors ());
-
-          for (octave_idx_type i = 0; i < nr; i++)
-            {
-              Complex elt = lambda(i);
-              if (std::imag (elt) == 0.0)
-                lambda(i) = std::pow (a, std::real (elt));
-              else
-                lambda(i) = std::pow (a, elt);
-            }
-          ComplexDiagMatrix D (lambda);
-
-          retval = ComplexMatrix (Q * D * Q.inverse ());
+          Complex elt = lambda(i);
+          if (std::imag (elt) == 0.0)
+            lambda(i) = std::pow (a, std::real (elt));
+          else
+            lambda(i) = std::pow (a, elt);
         }
-      catch (const octave_execution_exception&)
-        {
-          gripe_failed_diagonalization ();
-        }
+      ComplexDiagMatrix D (lambda);
+
+      retval = ComplexMatrix (Q * D * Q.inverse ());
+    }
+  catch (const octave_execution_exception&)
+    {
+      gripe_failed_diagonalization ();
     }
 
   return retval;
 }
 
 // -*- 5 -*-
 octave_value
 xpow (const Matrix& a, double b)
 {
   octave_value retval;
 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for A^b, A must be a square matrix. Use .^ for elementwise power.");
-  else
+
+  if (static_cast<int> (b) == b)
     {
-      if (static_cast<int> (b) == b)
+      int btmp = static_cast<int> (b);
+      if (btmp == 0)
         {
-          int btmp = static_cast<int> (b);
-          if (btmp == 0)
-            {
-              retval = DiagMatrix (nr, nr, 1.0);
-            }
-          else
-            {
-              // Too much copying?
-              // FIXME: we shouldn't do this if the exponent is large...
-
-              Matrix atmp;
-              if (btmp < 0)
-                {
-                  btmp = -btmp;
-
-                  octave_idx_type info;
-                  double rcond = 0.0;
-                  MatrixType mattype (a);
-
-                  atmp = a.inverse (mattype, info, rcond, 1);
-
-                  if (info == -1)
-                    warning ("inverse: matrix singular to machine\
- precision, rcond = %g", rcond);
-                }
-              else
-                atmp = a;
-
-              Matrix result (atmp);
-
-              btmp--;
-
-              while (btmp > 0)
-                {
-                  if (btmp & 1)
-                    result = result * atmp;
-
-                  btmp >>= 1;
-
-                  if (btmp > 0)
-                    atmp = atmp * atmp;
-                }
-
-              retval = result;
-            }
+          retval = DiagMatrix (nr, nr, 1.0);
         }
       else
         {
-          EIG a_eig (a);
-
-          try
+          // Too much copying?
+          // FIXME: we shouldn't do this if the exponent is large...
+
+          Matrix atmp;
+          if (btmp < 0)
+            {
+              btmp = -btmp;
+
+              octave_idx_type info;
+              double rcond = 0.0;
+              MatrixType mattype (a);
+
+              atmp = a.inverse (mattype, info, rcond, 1);
+
+              if (info == -1)
+                warning ("inverse: matrix singular to machine\
+precision, rcond = %g", rcond);
+            }
+          else
+            atmp = a;
+
+          Matrix result (atmp);
+
+          btmp--;
+
+          while (btmp > 0)
             {
-              ComplexColumnVector lambda (a_eig.eigenvalues ());
-              ComplexMatrix Q (a_eig.eigenvectors ());
-
-              for (octave_idx_type i = 0; i < nr; i++)
-                lambda(i) = std::pow (lambda(i), b);
-
-              ComplexDiagMatrix D (lambda);
-
-              retval = ComplexMatrix (Q * D * Q.inverse ());
+              if (btmp & 1)
+                result = result * atmp;
+
+              btmp >>= 1;
+
+              if (btmp > 0)
+                atmp = atmp * atmp;
             }
-          catch (const octave_execution_exception&)
-            {
-              gripe_failed_diagonalization ();
-            }
+
+          retval = result;
+        }
+    }
+  else
+    {
+      EIG a_eig (a);
+
+      try
+        {
+          ComplexColumnVector lambda (a_eig.eigenvalues ());
+          ComplexMatrix Q (a_eig.eigenvectors ());
+
+          for (octave_idx_type i = 0; i < nr; i++)
+            lambda(i) = std::pow (lambda(i), b);
+
+          ComplexDiagMatrix D (lambda);
+
+          retval = ComplexMatrix (Q * D * Q.inverse ());
+        }
+      catch (const octave_execution_exception&)
+        {
+          gripe_failed_diagonalization ();
         }
     }
 
   return retval;
 }
 
 // -*- 5d -*-
 octave_value
@@ -286,32 +280,30 @@ xpow (const DiagMatrix& a, double b)
 {
   octave_value retval;
 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for A^b, A must be a square matrix. Use .^ for elementwise power.");
+
+  if (static_cast<int> (b) == b)
+    {
+      DiagMatrix r (nr, nc);
+      for (octave_idx_type i = 0; i < nc; i++)
+        r.dgelem (i) = std::pow (a.dgelem (i), b);
+      retval = r;
+    }
   else
     {
-      if (static_cast<int> (b) == b)
-        {
-          DiagMatrix r (nr, nc);
-          for (octave_idx_type i = 0; i < nc; i++)
-            r.dgelem (i) = std::pow (a.dgelem (i), b);
-          retval = r;
-        }
-      else
-        {
-          ComplexDiagMatrix r (nr, nc);
-          for (octave_idx_type i = 0; i < nc; i++)
-            r.dgelem (i) = std::pow (static_cast<Complex> (a.dgelem (i)), b);
-          retval = r;
-        }
+      ComplexDiagMatrix r (nr, nc);
+      for (octave_idx_type i = 0; i < nc; i++)
+        r.dgelem (i) = std::pow (static_cast<Complex> (a.dgelem (i)), b);
+      retval = r;
     }
 
   return retval;
 }
 
 // -*- 5p -*-
 octave_value
 xpow (const PermMatrix& a, double b)
@@ -330,36 +322,34 @@ xpow (const Matrix& a, const Complex& b)
 {
   octave_value retval;
 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for A^b, A must be a square matrix. Use .^ for elementwise power.");
-  else
+
+  EIG a_eig (a);
+
+  try
     {
-      EIG a_eig (a);
-
-      try
-        {
-          ComplexColumnVector lambda (a_eig.eigenvalues ());
-          ComplexMatrix Q (a_eig.eigenvectors ());
-
-          for (octave_idx_type i = 0; i < nr; i++)
-            lambda(i) = std::pow (lambda(i), b);
-
-          ComplexDiagMatrix D (lambda);
-
-          retval = ComplexMatrix (Q * D * Q.inverse ());
-        }
-      catch (const octave_execution_exception&)
-        {
-          gripe_failed_diagonalization ();
-        }
+      ComplexColumnVector lambda (a_eig.eigenvalues ());
+      ComplexMatrix Q (a_eig.eigenvectors ());
+
+      for (octave_idx_type i = 0; i < nr; i++)
+        lambda(i) = std::pow (lambda(i), b);
+
+      ComplexDiagMatrix D (lambda);
+
+      retval = ComplexMatrix (Q * D * Q.inverse ());
+    }
+  catch (const octave_execution_exception&)
+    {
+      gripe_failed_diagonalization ();
     }
 
   return retval;
 }
 
 // -*- 7 -*-
 octave_value
 xpow (const Complex& a, double b)
@@ -380,41 +370,39 @@ xpow (const Complex& a, const Matrix& b)
 {
   octave_value retval;
 
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for x^A, A must be a square matrix. Use .^ for elementwise power.");
-  else
+
+  EIG b_eig (b);
+
+  try
     {
-      EIG b_eig (b);
-
-      try
+      ComplexColumnVector lambda (b_eig.eigenvalues ());
+      ComplexMatrix Q (b_eig.eigenvectors ());
+
+      for (octave_idx_type i = 0; i < nr; i++)
         {
-          ComplexColumnVector lambda (b_eig.eigenvalues ());
-          ComplexMatrix Q (b_eig.eigenvectors ());
-
-          for (octave_idx_type i = 0; i < nr; i++)
-            {
-              Complex elt = lambda(i);
-              if (std::imag (elt) == 0.0)
-                lambda(i) = std::pow (a, std::real (elt));
-              else
-                lambda(i) = std::pow (a, elt);
-            }
-          ComplexDiagMatrix D (lambda);
-
-          retval = ComplexMatrix (Q * D * Q.inverse ());
+          Complex elt = lambda(i);
+          if (std::imag (elt) == 0.0)
+            lambda(i) = std::pow (a, std::real (elt));
+          else
+            lambda(i) = std::pow (a, elt);
         }
-      catch (const octave_execution_exception&)
-        {
-          gripe_failed_diagonalization ();
-        }
+      ComplexDiagMatrix D (lambda);
+
+      retval = ComplexMatrix (Q * D * Q.inverse ());
+    }
+  catch (const octave_execution_exception&)
+    {
+      gripe_failed_diagonalization ();
     }
 
   return retval;
 }
 
 // -*- 9 -*-
 octave_value
 xpow (const Complex& a, const Complex& b)
@@ -430,144 +418,104 @@ xpow (const Complex& a, const ComplexMat
 {
   octave_value retval;
 
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for x^A, A must be a square matrix. Use .^ for elementwise power.");
-  else
+
+  EIG b_eig (b);
+
+  try
     {
-      EIG b_eig (b);
-
-      try
+      ComplexColumnVector lambda (b_eig.eigenvalues ());
+      ComplexMatrix Q (b_eig.eigenvectors ());
+
+      for (octave_idx_type i = 0; i < nr; i++)
         {
-          ComplexColumnVector lambda (b_eig.eigenvalues ());
-          ComplexMatrix Q (b_eig.eigenvectors ());
-
-          for (octave_idx_type i = 0; i < nr; i++)
-            {
-              Complex elt = lambda(i);
-              if (std::imag (elt) == 0.0)
-                lambda(i) = std::pow (a, std::real (elt));
-              else
-                lambda(i) = std::pow (a, elt);
-            }
-          ComplexDiagMatrix D (lambda);
-
-          retval = ComplexMatrix (Q * D * Q.inverse ());
+          Complex elt = lambda(i);
+          if (std::imag (elt) == 0.0)
+            lambda(i) = std::pow (a, std::real (elt));
+          else
+            lambda(i) = std::pow (a, elt);
         }
-      catch (const octave_execution_exception&)
-        {
-          gripe_failed_diagonalization ();
-        }
+      ComplexDiagMatrix D (lambda);
+
+      retval = ComplexMatrix (Q * D * Q.inverse ());
+    }
+  catch (const octave_execution_exception&)
+    {
+      gripe_failed_diagonalization ();
     }
 
   return retval;
 }
 
 // -*- 11 -*-
 octave_value
 xpow (const ComplexMatrix& a, double b)
 {
   octave_value retval;
 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for A^b, A must be a square matrix. Use .^ for elementwise power.");
-  else
+
+  if (static_cast<int> (b) == b)
     {
-      if (static_cast<int> (b) == b)
+      int btmp = static_cast<int> (b);
+      if (btmp == 0)
         {
-          int btmp = static_cast<int> (b);
-          if (btmp == 0)
-            {
-              retval = DiagMatrix (nr, nr, 1.0);
-            }
-          else
-            {
-              // Too much copying?
-              // FIXME: we shouldn't do this if the exponent is large...
-
-              ComplexMatrix atmp;
-              if (btmp < 0)
-                {
-                  btmp = -btmp;
-
-                  octave_idx_type info;
-                  double rcond = 0.0;
-                  MatrixType mattype (a);
-
-                  atmp = a.inverse (mattype, info, rcond, 1);
-
-                  if (info == -1)
-                    warning ("inverse: matrix singular to machine\
- precision, rcond = %g", rcond);
-                }
-              else
-                atmp = a;
-
-              ComplexMatrix result (atmp);
-
-              btmp--;
-
-              while (btmp > 0)
-                {
-                  if (btmp & 1)
-                    result = result * atmp;
-
-                  btmp >>= 1;
-
-                  if (btmp > 0)
-                    atmp = atmp * atmp;
-                }
-
-              retval = result;
-            }
+          retval = DiagMatrix (nr, nr, 1.0);
         }
       else
         {
-          EIG a_eig (a);
-
-          try
+          // Too much copying?
+          // FIXME: we shouldn't do this if the exponent is large...
+
+          ComplexMatrix atmp;
+          if (btmp < 0)
             {
-              ComplexColumnVector lambda (a_eig.eigenvalues ());
-              ComplexMatrix Q (a_eig.eigenvectors ());
-
-              for (octave_idx_type i = 0; i < nr; i++)
-                lambda(i) = std::pow (lambda(i), b);
-
-              ComplexDiagMatrix D (lambda);
-
-              retval = ComplexMatrix (Q * D * Q.inverse ());
+              btmp = -btmp;
+
+              octave_idx_type info;
+              double rcond = 0.0;
+              MatrixType mattype (a);
+
+              atmp = a.inverse (mattype, info, rcond, 1);
+
+              if (info == -1)
+                warning ("inverse: matrix singular to machine\
+precision, rcond = %g", rcond);
             }
-          catch (const octave_execution_exception&)
+          else
+            atmp = a;
+
+          ComplexMatrix result (atmp);
+
+          btmp--;
+
+          while (btmp > 0)
             {
-              gripe_failed_diagonalization ();
+              if (btmp & 1)
+                result = result * atmp;
+
+              btmp >>= 1;
+
+              if (btmp > 0)
+                atmp = atmp * atmp;
             }
+
+          retval = result;
         }
     }
-
-  return retval;
-}
-
-// -*- 12 -*-
-octave_value
-xpow (const ComplexMatrix& a, const Complex& b)
-{
-  octave_value retval;
-
-  octave_idx_type nr = a.rows ();
-  octave_idx_type nc = a.cols ();
-
-  if (nr == 0 || nc == 0 || nr != nc)
-    error ("for A^b, A must be a square matrix. Use .^ for elementwise power.");
   else
     {
       EIG a_eig (a);
 
       try
         {
           ComplexColumnVector lambda (a_eig.eigenvalues ());
           ComplexMatrix Q (a_eig.eigenvectors ());
@@ -583,34 +531,66 @@ xpow (const ComplexMatrix& a, const Comp
         {
           gripe_failed_diagonalization ();
         }
     }
 
   return retval;
 }
 
+// -*- 12 -*-
+octave_value
+xpow (const ComplexMatrix& a, const Complex& b)
+{
+  octave_value retval;
+
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
+
+  if (nr == 0 || nc == 0 || nr != nc)
+    error ("for A^b, A must be a square matrix. Use .^ for elementwise power.");
+
+  EIG a_eig (a);
+
+  try
+    {
+      ComplexColumnVector lambda (a_eig.eigenvalues ());
+      ComplexMatrix Q (a_eig.eigenvectors ());
+
+      for (octave_idx_type i = 0; i < nr; i++)
+        lambda(i) = std::pow (lambda(i), b);
+
+      ComplexDiagMatrix D (lambda);
+
+      retval = ComplexMatrix (Q * D * Q.inverse ());
+    }
+  catch (const octave_execution_exception&)
+    {
+      gripe_failed_diagonalization ();
+    }
+
+  return retval;
+}
+
 // -*- 12d -*-
 octave_value
 xpow (const ComplexDiagMatrix& a, const Complex& b)
 {
   octave_value retval;
 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for A^b, A must be a square matrix. Use .^ for elementwise power.");
-  else
-    {
-      ComplexDiagMatrix r (nr, nc);
-      for (octave_idx_type i = 0; i < nc; i++)
-        r(i, i) = std::pow (a(i, i), b);
-      retval = r;
-    }
+
+  ComplexDiagMatrix r (nr, nc);
+  for (octave_idx_type i = 0; i < nc; i++)
+    r(i, i) = std::pow (a(i, i), b);
+  retval = r;
 
   return retval;
 }
 
 // mixed
 octave_value
 xpow (const ComplexDiagMatrix& a, double b)
 {
@@ -1542,46 +1522,44 @@ xpow (float a, const FloatMatrix& b)
 {
   octave_value retval;
 
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for x^A, A must be a square matrix. Use .^ for elementwise power.");
-  else
+
+  FloatEIG b_eig (b);
+
+  try
     {
-      FloatEIG b_eig (b);
-
-      try
+      FloatComplexColumnVector lambda (b_eig.eigenvalues ());
+      FloatComplexMatrix Q (b_eig.eigenvectors ());
+
+      for (octave_idx_type i = 0; i < nr; i++)
         {
-          FloatComplexColumnVector lambda (b_eig.eigenvalues ());
-          FloatComplexMatrix Q (b_eig.eigenvectors ());
-
-          for (octave_idx_type i = 0; i < nr; i++)
-            {
-              FloatComplex elt = lambda(i);
-              if (std::imag (elt) == 0.0)
-                lambda(i) = std::pow (a, std::real (elt));
-              else
-                lambda(i) = std::pow (a, elt);
-            }
-          FloatComplexDiagMatrix D (lambda);
-
-          FloatComplexMatrix C = Q * D * Q.inverse ();
-
-          if (a > 0)
-            retval = real (C);
+          FloatComplex elt = lambda(i);
+          if (std::imag (elt) == 0.0)
+            lambda(i) = std::pow (a, std::real (elt));
           else
-            retval = C;
+            lambda(i) = std::pow (a, elt);
         }
-      catch (const octave_execution_exception&)
-        {
-          gripe_failed_diagonalization ();
-        }
+      FloatComplexDiagMatrix D (lambda);
+
+      FloatComplexMatrix C = Q * D * Q.inverse ();
+
+      if (a > 0)
+        retval = real (C);
+      else
+        retval = C;
+    }
+  catch (const octave_execution_exception&)
+    {
+      gripe_failed_diagonalization ();
     }
 
   return retval;
 }
 
 // -*- 3 -*-
 octave_value
 xpow (float a, const FloatComplex& b)
@@ -1596,177 +1574,104 @@ xpow (float a, const FloatComplexMatrix&
 {
   octave_value retval;
 
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for x^A, A must be a square matrix. Use .^ for elementwise power.");
-  else
+
+  FloatEIG b_eig (b);
+
+  try
     {
-      FloatEIG b_eig (b);
-
-      try
+      FloatComplexColumnVector lambda (b_eig.eigenvalues ());
+      FloatComplexMatrix Q (b_eig.eigenvectors ());
+
+      for (octave_idx_type i = 0; i < nr; i++)
         {
-          FloatComplexColumnVector lambda (b_eig.eigenvalues ());
-          FloatComplexMatrix Q (b_eig.eigenvectors ());
-
-          for (octave_idx_type i = 0; i < nr; i++)
-            {
-              FloatComplex elt = lambda(i);
-              if (std::imag (elt) == 0.0)
-                lambda(i) = std::pow (a, std::real (elt));
-              else
-                lambda(i) = std::pow (a, elt);
-            }
-          FloatComplexDiagMatrix D (lambda);
-
-          retval = FloatComplexMatrix (Q * D * Q.inverse ());
+          FloatComplex elt = lambda(i);
+          if (std::imag (elt) == 0.0)
+            lambda(i) = std::pow (a, std::real (elt));
+          else
+            lambda(i) = std::pow (a, elt);
         }
-      catch (const octave_execution_exception&)
-        {
-          gripe_failed_diagonalization ();
-        }
+      FloatComplexDiagMatrix D (lambda);
+
+      retval = FloatComplexMatrix (Q * D * Q.inverse ());
+    }
+  catch (const octave_execution_exception&)
+    {
+      gripe_failed_diagonalization ();
     }
 
   return retval;
 }
 
 // -*- 5 -*-
 octave_value
 xpow (const FloatMatrix& a, float b)
 {
   octave_value retval;
 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for A^b, A must be a square matrix. Use .^ for elementwise power.");
-  else
+
+  if (static_cast<int> (b) == b)
     {
-      if (static_cast<int> (b) == b)
+      int btmp = static_cast<int> (b);
+      if (btmp == 0)
         {
-          int btmp = static_cast<int> (b);
-          if (btmp == 0)
-            {
-              retval = FloatDiagMatrix (nr, nr, 1.0);
-            }
-          else
-            {
-              // Too much copying?
-              // FIXME: we shouldn't do this if the exponent is large...
-
-              FloatMatrix atmp;
-              if (btmp < 0)
-                {
-                  btmp = -btmp;
-
-                  octave_idx_type info;
-                  float rcond = 0.0;
-                  MatrixType mattype (a);
-
-                  atmp = a.inverse (mattype, info, rcond, 1);
-
-                  if (info == -1)
-                    warning ("inverse: matrix singular to machine\
- precision, rcond = %g", rcond);
-                }
-              else
-                atmp = a;
-
-              FloatMatrix result (atmp);
-
-              btmp--;
-
-              while (btmp > 0)
-                {
-                  if (btmp & 1)
-                    result = result * atmp;
-
-                  btmp >>= 1;
-
-                  if (btmp > 0)
-                    atmp = atmp * atmp;
-                }
-
-              retval = result;
-            }
+          retval = FloatDiagMatrix (nr, nr, 1.0);
         }
       else
         {
-          FloatEIG a_eig (a);
-
-          try
+          // Too much copying?
+          // FIXME: we shouldn't do this if the exponent is large...
+
+          FloatMatrix atmp;
+          if (btmp < 0)
             {
-              FloatComplexColumnVector lambda (a_eig.eigenvalues ());
-              FloatComplexMatrix Q (a_eig.eigenvectors ());
-
-              for (octave_idx_type i = 0; i < nr; i++)
-                lambda(i) = std::pow (lambda(i), b);
-
-              FloatComplexDiagMatrix D (lambda);
-
-              retval = FloatComplexMatrix (Q * D * Q.inverse ());
+              btmp = -btmp;
+
+              octave_idx_type info;
+              float rcond = 0.0;
+              MatrixType mattype (a);
+
+              atmp = a.inverse (mattype, info, rcond, 1);
+
+              if (info == -1)
+                warning ("inverse: matrix singular to machine\
+precision, rcond = %g", rcond);
             }
-          catch (const octave_execution_exception&)
+          else
+            atmp = a;
+
+          FloatMatrix result (atmp);
+
+          btmp--;
+
+          while (btmp > 0)
             {
-              gripe_failed_diagonalization ();
+              if (btmp & 1)
+                result = result * atmp;
+
+              btmp >>= 1;
+
+              if (btmp > 0)
+                atmp = atmp * atmp;
             }
+
+          retval = result;
         }
     }
-
-  return retval;
-}
-
-// -*- 5d -*-
-octave_value
-xpow (const FloatDiagMatrix& a, float b)
-{
-  octave_value retval;
-
-  octave_idx_type nr = a.rows ();
-  octave_idx_type nc = a.cols ();
-
-  if (nr == 0 || nc == 0 || nr != nc)
-    error ("for A^b, A must be a square matrix. Use .^ for elementwise power.");
-  else
-    {
-      if (static_cast<int> (b) == b)
-        {
-          FloatDiagMatrix r (nr, nc);
-          for (octave_idx_type i = 0; i < nc; i++)
-            r.dgelem (i) = std::pow (a.dgelem (i), b);
-          retval = r;
-        }
-      else
-        {
-          FloatComplexDiagMatrix r (nr, nc);
-          for (octave_idx_type i = 0; i < nc; i++)
-            r.dgelem (i) = std::pow (static_cast<FloatComplex> (a.dgelem (i)),
-                                                                b);
-          retval = r;
-        }
-    }
-
-  return retval;
-}
-
-// -*- 6 -*-
-octave_value
-xpow (const FloatMatrix& a, const FloatComplex& b)
-{
-  octave_value retval;
-
-  octave_idx_type nr = a.rows ();
-  octave_idx_type nc = a.cols ();
-
-  if (nr == 0 || nc == 0 || nr != nc)
-    error ("for A^b, A must be a square matrix. Use .^ for elementwise power.");
   else
     {
       FloatEIG a_eig (a);
 
       try
         {
           FloatComplexColumnVector lambda (a_eig.eigenvalues ());
           FloatComplexMatrix Q (a_eig.eigenvectors ());
@@ -1782,16 +1687,81 @@ xpow (const FloatMatrix& a, const FloatC
         {
           gripe_failed_diagonalization ();
         }
     }
 
   return retval;
 }
 
+// -*- 5d -*-
+octave_value
+xpow (const FloatDiagMatrix& a, float b)
+{
+  octave_value retval;
+
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
+
+  if (nr == 0 || nc == 0 || nr != nc)
+    error ("for A^b, A must be a square matrix. Use .^ for elementwise power.");
+
+  if (static_cast<int> (b) == b)
+    {
+      FloatDiagMatrix r (nr, nc);
+      for (octave_idx_type i = 0; i < nc; i++)
+        r.dgelem (i) = std::pow (a.dgelem (i), b);
+      retval = r;
+    }
+  else
+    {
+      FloatComplexDiagMatrix r (nr, nc);
+      for (octave_idx_type i = 0; i < nc; i++)
+        r.dgelem (i) = std::pow (static_cast<FloatComplex> (a.dgelem (i)),
+                                                            b);
+      retval = r;
+    }
+
+  return retval;
+}
+
+// -*- 6 -*-
+octave_value
+xpow (const FloatMatrix& a, const FloatComplex& b)
+{
+  octave_value retval;
+
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
+
+  if (nr == 0 || nc == 0 || nr != nc)
+    error ("for A^b, A must be a square matrix. Use .^ for elementwise power.");
+
+  FloatEIG a_eig (a);
+
+  try
+    {
+      FloatComplexColumnVector lambda (a_eig.eigenvalues ());
+      FloatComplexMatrix Q (a_eig.eigenvectors ());
+
+      for (octave_idx_type i = 0; i < nr; i++)
+        lambda(i) = std::pow (lambda(i), b);
+
+      FloatComplexDiagMatrix D (lambda);
+
+      retval = FloatComplexMatrix (Q * D * Q.inverse ());
+    }
+  catch (const octave_execution_exception&)
+    {
+      gripe_failed_diagonalization ();
+    }
+
+  return retval;
+}
+
 // -*- 7 -*-
 octave_value
 xpow (const FloatComplex& a, float b)
 {
   FloatComplex result;
 
   if (xisint (b))
     result = std::pow (a, static_cast<int> (b));
@@ -1807,41 +1777,39 @@ xpow (const FloatComplex& a, const Float
 {
   octave_value retval;
 
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for x^A, A must be a square matrix. Use .^ for elementwise power.");
-  else
+
+  FloatEIG b_eig (b);
+
+  try
     {
-      FloatEIG b_eig (b);
-
-      try
+      FloatComplexColumnVector lambda (b_eig.eigenvalues ());
+      FloatComplexMatrix Q (b_eig.eigenvectors ());
+
+      for (octave_idx_type i = 0; i < nr; i++)
         {
-          FloatComplexColumnVector lambda (b_eig.eigenvalues ());
-          FloatComplexMatrix Q (b_eig.eigenvectors ());
-
-          for (octave_idx_type i = 0; i < nr; i++)
-            {
-              FloatComplex elt = lambda(i);
-              if (std::imag (elt) == 0.0)
-                lambda(i) = std::pow (a, std::real (elt));
-              else
-                lambda(i) = std::pow (a, elt);
-            }
-          FloatComplexDiagMatrix D (lambda);
-
-          retval = FloatComplexMatrix (Q * D * Q.inverse ());
+          FloatComplex elt = lambda(i);
+          if (std::imag (elt) == 0.0)
+            lambda(i) = std::pow (a, std::real (elt));
+          else
+            lambda(i) = std::pow (a, elt);
         }
-      catch (const octave_execution_exception&)
-        {
-          gripe_failed_diagonalization ();
-        }
+      FloatComplexDiagMatrix D (lambda);
+
+      retval = FloatComplexMatrix (Q * D * Q.inverse ());
+    }
+  catch (const octave_execution_exception&)
+    {
+      gripe_failed_diagonalization ();
     }
 
   return retval;
 }
 
 // -*- 9 -*-
 octave_value
 xpow (const FloatComplex& a, const FloatComplex& b)
@@ -1857,144 +1825,104 @@ xpow (const FloatComplex& a, const Float
 {
   octave_value retval;
 
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for x^A, A must be a square matrix. Use .^ for elementwise power.");
-  else
+
+  FloatEIG b_eig (b);
+
+  try
     {
-      FloatEIG b_eig (b);
-
-      try
+      FloatComplexColumnVector lambda (b_eig.eigenvalues ());
+      FloatComplexMatrix Q (b_eig.eigenvectors ());
+
+      for (octave_idx_type i = 0; i < nr; i++)
         {
-          FloatComplexColumnVector lambda (b_eig.eigenvalues ());
-          FloatComplexMatrix Q (b_eig.eigenvectors ());
-
-          for (octave_idx_type i = 0; i < nr; i++)
-            {
-              FloatComplex elt = lambda(i);
-              if (std::imag (elt) == 0.0)
-                lambda(i) = std::pow (a, std::real (elt));
-              else
-                lambda(i) = std::pow (a, elt);
-            }
-          FloatComplexDiagMatrix D (lambda);
-
-          retval = FloatComplexMatrix (Q * D * Q.inverse ());
+          FloatComplex elt = lambda(i);
+          if (std::imag (elt) == 0.0)
+            lambda(i) = std::pow (a, std::real (elt));
+          else
+            lambda(i) = std::pow (a, elt);
         }
-      catch (const octave_execution_exception&)
-        {
-          gripe_failed_diagonalization ();
-        }
+      FloatComplexDiagMatrix D (lambda);
+
+      retval = FloatComplexMatrix (Q * D * Q.inverse ());
+    }
+  catch (const octave_execution_exception&)
+    {
+      gripe_failed_diagonalization ();
     }
 
   return retval;
 }
 
 // -*- 11 -*-
 octave_value
 xpow (const FloatComplexMatrix& a, float b)
 {
   octave_value retval;
 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for A^b, A must be a square matrix. Use .^ for elementwise power.");
-  else
+
+  if (static_cast<int> (b) == b)
     {
-      if (static_cast<int> (b) == b)
+      int btmp = static_cast<int> (b);
+      if (btmp == 0)
         {
-          int btmp = static_cast<int> (b);
-          if (btmp == 0)
-            {
-              retval = FloatDiagMatrix (nr, nr, 1.0);
-            }
-          else
-            {
-              // Too much copying?
-              // FIXME: we shouldn't do this if the exponent is large...
-
-              FloatComplexMatrix atmp;
-              if (btmp < 0)
-                {
-                  btmp = -btmp;
-
-                  octave_idx_type info;
-                  float rcond = 0.0;
-                  MatrixType mattype (a);
-
-                  atmp = a.inverse (mattype, info, rcond, 1);
-
-                  if (info == -1)
-                    warning ("inverse: matrix singular to machine\
- precision, rcond = %g", rcond);
-                }
-              else
-                atmp = a;
-
-              FloatComplexMatrix result (atmp);
-
-              btmp--;
-
-              while (btmp > 0)
-                {
-                  if (btmp & 1)
-                    result = result * atmp;
-
-                  btmp >>= 1;
-
-                  if (btmp > 0)
-                    atmp = atmp * atmp;
-                }
-
-              retval = result;
-            }
+          retval = FloatDiagMatrix (nr, nr, 1.0);
         }
       else
         {
-          FloatEIG a_eig (a);
-
-          try
+          // Too much copying?
+          // FIXME: we shouldn't do this if the exponent is large...
+
+          FloatComplexMatrix atmp;
+          if (btmp < 0)
             {
-              FloatComplexColumnVector lambda (a_eig.eigenvalues ());
-              FloatComplexMatrix Q (a_eig.eigenvectors ());
-
-              for (octave_idx_type i = 0; i < nr; i++)
-                lambda(i) = std::pow (lambda(i), b);
-
-              FloatComplexDiagMatrix D (lambda);
-
-              retval = FloatComplexMatrix (Q * D * Q.inverse ());
+              btmp = -btmp;
+
+              octave_idx_type info;
+              float rcond = 0.0;
+              MatrixType mattype (a);
+
+              atmp = a.inverse (mattype, info, rcond, 1);
+
+              if (info == -1)
+                warning ("inverse: matrix singular to machine\
+precision, rcond = %g", rcond);
             }
-          catch (const octave_execution_exception&)
+          else
+            atmp = a;
+
+          FloatComplexMatrix result (atmp);
+
+          btmp--;
+
+          while (btmp > 0)
             {
-              gripe_failed_diagonalization ();
+              if (btmp & 1)
+                result = result * atmp;
+
+              btmp >>= 1;
+
+              if (btmp > 0)
+                atmp = atmp * atmp;
             }
+
+          retval = result;
         }
     }
-
-  return retval;
-}
-
-// -*- 12 -*-
-octave_value
-xpow (const FloatComplexMatrix& a, const FloatComplex& b)
-{
-  octave_value retval;
-
-  octave_idx_type nr = a.rows ();
-  octave_idx_type nc = a.cols ();
-
-  if (nr == 0 || nc == 0 || nr != nc)
-    error ("for A^b, A must be a square matrix. Use .^ for elementwise power.");
   else
     {
       FloatEIG a_eig (a);
 
       try
         {
           FloatComplexColumnVector lambda (a_eig.eigenvalues ());
           FloatComplexMatrix Q (a_eig.eigenvectors ());
@@ -2010,34 +1938,66 @@ xpow (const FloatComplexMatrix& a, const
         {
           gripe_failed_diagonalization ();
         }
     }
 
   return retval;
 }
 
+// -*- 12 -*-
+octave_value
+xpow (const FloatComplexMatrix& a, const FloatComplex& b)
+{
+  octave_value retval;
+
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
+
+  if (nr == 0 || nc == 0 || nr != nc)
+    error ("for A^b, A must be a square matrix. Use .^ for elementwise power.");
+
+  FloatEIG a_eig (a);
+
+  try
+    {
+      FloatComplexColumnVector lambda (a_eig.eigenvalues ());
+      FloatComplexMatrix Q (a_eig.eigenvectors ());
+
+      for (octave_idx_type i = 0; i < nr; i++)
+        lambda(i) = std::pow (lambda(i), b);
+
+      FloatComplexDiagMatrix D (lambda);
+
+      retval = FloatComplexMatrix (Q * D * Q.inverse ());
+    }
+  catch (const octave_execution_exception&)
+    {
+      gripe_failed_diagonalization ();
+    }
+
+  return retval;
+}
+
 // -*- 12d -*-
 octave_value
 xpow (const FloatComplexDiagMatrix& a, const FloatComplex& b)
 {
   octave_value retval;
 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for A^b, A must be a square matrix. Use .^ for elementwise power.");
-  else
-    {
-      FloatComplexDiagMatrix r (nr, nc);
-      for (octave_idx_type i = 0; i < nc; i++)
-        r(i, i) = std::pow (a(i, i), b);
-      retval = r;
-    }
+
+  FloatComplexDiagMatrix r (nr, nc);
+  for (octave_idx_type i = 0; i < nc; i++)
+    r(i, i) = std::pow (a(i, i), b);
+  retval = r;
 
   return retval;
 }
 
 // mixed
 octave_value
 xpow (const FloatComplexDiagMatrix& a, float b)
 {
diff --git a/libinterp/dldfcn/audiodevinfo.cc b/libinterp/dldfcn/audiodevinfo.cc
--- a/libinterp/dldfcn/audiodevinfo.cc
+++ b/libinterp/dldfcn/audiodevinfo.cc
@@ -2163,19 +2163,18 @@ Undocumented internal function.\n\
   if (! recorder)
     error ("__player_audioplayer__: Couldn't instantiate new audioplayer");
 
   bool is_function = (args(0).is_string () || args(0).is_function_handle ()
                       || args(0).is_inline_function ());
 
   if (is_function)
     error ("audioplayer: callbacks not yet implemented");
-  else
-    recorder->set_y (args(0));
-
+
+  recorder->set_y (args(0));
   recorder->set_fs (args(1).int_value ());
 
   switch (nargin)
     {
     case 3:
       recorder->set_nbits (args(2).int_value ());
       break;
 
diff --git a/libinterp/dldfcn/ccolamd.cc b/libinterp/dldfcn/ccolamd.cc
--- a/libinterp/dldfcn/ccolamd.cc
+++ b/libinterp/dldfcn/ccolamd.cc
@@ -275,25 +275,24 @@ ccolamd, csymamd, amd, colamd, symamd, a
       octave_idx_type cslen = in_cmember.numel ();
       OCTAVE_LOCAL_BUFFER (octave_idx_type, cmember, cslen);
       for (octave_idx_type i = 0; i < cslen; i++)
         // convert cmember from 1-based to 0-based
         cmember[i] = static_cast<octave_idx_type>(in_cmember(i) - 1);
 
       if (cslen != n_col)
         error ("ccolamd: CMEMBER must be of length equal to #cols of A");
-      else
-        // Order the columns (destroys A)
-        if (! CCOLAMD_NAME () (n_row, n_col, Alen, A, p,
-                               knobs, stats, cmember))
-          {
-            CCOLAMD_NAME (_report) (stats) ;
 
-            error ("ccolamd: internal error!");
-          }
+      // Order the columns (destroys A)
+      if (! CCOLAMD_NAME () (n_row, n_col, Alen, A, p, knobs, stats, cmember))
+        {
+          CCOLAMD_NAME (_report) (stats) ;
+
+          error ("ccolamd: internal error!");
+        }
     }
   else
     {
       // Order the columns (destroys A)
       if (! CCOLAMD_NAME () (n_row, n_col, Alen, A, p, knobs, stats, 0))
         {
           CCOLAMD_NAME (_report) (stats) ;
 
@@ -508,18 +507,19 @@ ccolamd, csymamd, amd, colamd, symamd, a
       octave_idx_type cslen = in_cmember.numel ();
       OCTAVE_LOCAL_BUFFER (octave_idx_type, cmember, cslen);
       for (octave_idx_type i = 0; i < cslen; i++)
         // convert cmember from 1-based to 0-based
         cmember[i] = static_cast<octave_idx_type>(in_cmember(i) - 1);
 
       if (cslen != n_col)
         error ("csymamd: CMEMBER must be of length equal to #cols of A");
-      else if (! CSYMAMD_NAME () (n_col, ridx, cidx, perm, knobs, stats,
-                                 &calloc, &free, cmember, -1))
+
+      if (! CSYMAMD_NAME () (n_col, ridx, cidx, perm, knobs, stats,
+                             &calloc, &free, cmember, -1))
         {
           CSYMAMD_NAME (_report) (stats) ;
 
           error ("csymamd: internal error!") ;
         }
     }
   else
     {
diff --git a/libinterp/octave-value/ov-builtin.cc b/libinterp/octave-value/ov-builtin.cc
--- a/libinterp/octave-value/ov-builtin.cc
+++ b/libinterp/octave-value/ov-builtin.cc
@@ -102,47 +102,45 @@ octave_builtin::do_multi_index_op (int n
 octave_value_list
 octave_builtin::do_multi_index_op (int nargout, const octave_value_list& args,
                                    const std::list<octave_lvalue> *lvalue_list)
 {
   octave_value_list retval;
 
   if (args.has_magic_colon ())
     error ("invalid use of colon in function argument list");
-  else
-    {
-      unwind_protect frame;
+
+  unwind_protect frame;
 
-      octave_call_stack::push (this);
+  octave_call_stack::push (this);
 
-      frame.add_fcn (octave_call_stack::pop);
+  frame.add_fcn (octave_call_stack::pop);
 
-      if (lvalue_list || curr_lvalue_list)
-        {
-          frame.protect_var (curr_lvalue_list);
-          curr_lvalue_list = lvalue_list;
-        }
+  if (lvalue_list || curr_lvalue_list)
+    {
+      frame.protect_var (curr_lvalue_list);
+      curr_lvalue_list = lvalue_list;
+    }
 
-      BEGIN_PROFILER_BLOCK (octave_builtin)
+  BEGIN_PROFILER_BLOCK (octave_builtin)
 
-        retval = (*f) (args, nargout);
-      // Do not allow null values to be returned from functions.
-      // FIXME: perhaps true builtins should be allowed?
-      retval.make_storable_values ();
-      // Fix the case of a single undefined value.
-      // This happens when a compiled function uses
-      //   octave_value retval;
-      // instead of
-      //   octave_value_list retval;
-      // the idiom is very common, so we solve that here.
-      if (retval.length () == 1 && retval.xelem (0).is_undefined ())
-        retval.clear ();
+    retval = (*f) (args, nargout);
+  // Do not allow null values to be returned from functions.
+  // FIXME: perhaps true builtins should be allowed?
+  retval.make_storable_values ();
+  // Fix the case of a single undefined value.
+  // This happens when a compiled function uses
+  //   octave_value retval;
+  // instead of
+  //   octave_value_list retval;
+  // the idiom is very common, so we solve that here.
+  if (retval.length () == 1 && retval.xelem (0).is_undefined ())
+    retval.clear ();
 
-      END_PROFILER_BLOCK
-    }
+  END_PROFILER_BLOCK
 
   return retval;
 }
 
 jit_type *
 octave_builtin::to_jit (void) const
 {
   return jtype;
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -1162,18 +1162,18 @@ public:
 
     if (in_constructor)
       {
         if (! is_direct_superclass (cls, ctx))
           error ("`%s' is not a direct superclass of `%s'",
                  cname.c_str (), ctx.get_name ().c_str ());
 
         if (! is_constructed_object (mname))
-          error ("cannot call superclass constructor with "
-                 "variable `%s'", mname.c_str ());
+          error ("cannot call superclass constructor with variable `%s'",
+                 mname.c_str ());
 
         octave_value sym = symbol_table::varval (mname);
 
         cls.run_constructor (to_cdef_ref (sym), idx);
 
         retval(0) = sym;
       }
     else
@@ -1669,26 +1669,25 @@ cdef_object_array::subsasgn (const std::
                   // Rethrow to allow more info to be reported later.
                   e.set_pos_if_unset (ival.length (), i+1);
                   throw;
                 }
 
               is_scalar = is_scalar && iv(i).is_scalar ();
 
               if (! is_scalar)
-                error ("subsasgn: invalid indexing for object array "
-                       "assignment, the index must reference a single "
-                       "object in the array.");
+                error ("subsasgn: invalid indexing for object array assignment"
+                       ", the index must reference a single object in the "
+                       "array.");
             }
 
           Array<cdef_object> a = array.index (iv, true);
 
           if (a.numel () != 1)
-            error ("subsasgn: invalid indexing for object array "
-                   "assignment");
+            error ("subsasgn: invalid indexing for object array assignment");
 
           cdef_object obj = a(0);
 
           int ignore_copies = 0;
 
           // If the object in 'a' is not valid, this means the index
           // was out-of-bound and we need to create a new object.
 
@@ -1708,18 +1707,18 @@ cdef_object_array::subsasgn (const std::
           octave_value tmp = obj.subsasgn (type.substr (1), next_idx,
                                            rhs, ignore_copies);
 
           cdef_object robj = to_cdef (tmp);
 
           if (! robj.ok ()
               || robj.is_array ()
               || robj.get_class () != get_class ())
-            error ("subasgn: invalid assignment into array of %s "
-                   "objects", class_name ().c_str ());
+            error ("subasgn: invalid assignment into array of %s objects",
+                   class_name ().c_str ());
 
           // Small optimization, when dealing with handle
           // objects, we don't need to re-assign the result
           // of subsasgn back into the array.
 
           if (! robj.is (a(0)))
             {
               Array<cdef_object> rhs_a (dim_vector (1, 1),
diff --git a/libinterp/octave-value/ov-intx.h b/libinterp/octave-value/ov-intx.h
--- a/libinterp/octave-value/ov-intx.h
+++ b/libinterp/octave-value/ov-intx.h
@@ -141,78 +141,74 @@ public:
 
   Matrix
   matrix_value (bool = false) const
   {
     Matrix retval;
     dim_vector dv = dims ();
     if (dv.length () > 2)
       error ("invalid conversion of %s to Matrix", type_name ().c_str ());
-    else
-      {
-        retval = Matrix (dv(0), dv(1));
-        double *vec = retval.fortran_vec ();
-        octave_idx_type nel = matrix.numel ();
-        for (octave_idx_type i = 0; i < nel; i++)
-          vec[i] = matrix(i).double_value ();
-      }
+
+    retval = Matrix (dv(0), dv(1));
+    double *vec = retval.fortran_vec ();
+    octave_idx_type nel = matrix.numel ();
+    for (octave_idx_type i = 0; i < nel; i++)
+      vec[i] = matrix(i).double_value ();
+
     return retval;
   }
 
   FloatMatrix
   float_matrix_value (bool = false) const
   {
     FloatMatrix retval;
     dim_vector dv = dims ();
     if (dv.length () > 2)
       error ("invalid conversion of %s to FloatMatrix", type_name ().c_str ());
-    else
-      {
-        retval = FloatMatrix (dv(0), dv(1));
-        float *vec = retval.fortran_vec ();
-        octave_idx_type nel = matrix.numel ();
-        for (octave_idx_type i = 0; i < nel; i++)
-          vec[i] = matrix(i).float_value ();
-      }
+
+    retval = FloatMatrix (dv(0), dv(1));
+    float *vec = retval.fortran_vec ();
+    octave_idx_type nel = matrix.numel ();
+    for (octave_idx_type i = 0; i < nel; i++)
+      vec[i] = matrix(i).float_value ();
+
     return retval;
   }
 
   ComplexMatrix
   complex_matrix_value (bool = false) const
   {
     ComplexMatrix retval;
     dim_vector dv = dims ();
     if (dv.length () > 2)
       error ("invalid conversion of %s to Matrix", type_name ().c_str ());
-    else
-      {
-        retval = ComplexMatrix (dv(0), dv(1));
-        Complex *vec = retval.fortran_vec ();
-        octave_idx_type nel = matrix.numel ();
-        for (octave_idx_type i = 0; i < nel; i++)
-          vec[i] = Complex (matrix(i).double_value ());
-      }
+
+    retval = ComplexMatrix (dv(0), dv(1));
+    Complex *vec = retval.fortran_vec ();
+    octave_idx_type nel = matrix.numel ();
+    for (octave_idx_type i = 0; i < nel; i++)
+      vec[i] = Complex (matrix(i).double_value ());
+
     return retval;
   }
 
   FloatComplexMatrix
   float_complex_matrix_value (bool = false) const
   {
     FloatComplexMatrix retval;
     dim_vector dv = dims ();
     if (dv.length () > 2)
       error ("invalid conversion of %s to FloatMatrix", type_name ().c_str ());
-    else
-      {
-        retval = FloatComplexMatrix (dv(0), dv(1));
-        FloatComplex *vec = retval.fortran_vec ();
-        octave_idx_type nel = matrix.numel ();
-        for (octave_idx_type i = 0; i < nel; i++)
-          vec[i] = FloatComplex (matrix(i).float_value ());
-      }
+
+    retval = FloatComplexMatrix (dv(0), dv(1));
+    FloatComplex *vec = retval.fortran_vec ();
+    octave_idx_type nel = matrix.numel ();
+    for (octave_idx_type i = 0; i < nel; i++)
+      vec[i] = FloatComplex (matrix(i).float_value ());
+
     return retval;
   }
 
   NDArray
   array_value (bool = false) const
   {
     NDArray retval (matrix.dims ());
     double *vec = retval.fortran_vec ();
diff --git a/libinterp/octave-value/ov-lazy-idx.cc b/libinterp/octave-value/ov-lazy-idx.cc
--- a/libinterp/octave-value/ov-lazy-idx.cc
+++ b/libinterp/octave-value/ov-lazy-idx.cc
@@ -164,21 +164,20 @@ bool octave_lazy_index::save_ascii (std:
   return save_text_data (os, make_value (), value_save_tag, false, 0);
 }
 
 bool octave_lazy_index::load_ascii (std::istream& is)
 {
   bool dummy;
 
   std::string nm = read_text_data (is, "", dummy, value, 0);
-
   if (nm != value_save_tag)
     error ("lazy_index: corrupted data on load");
-  else
-    index = value.index_vector ();
+
+  index = value.index_vector ();
 
   return true;
 }
 
 
 bool octave_lazy_index::save_binary (std::ostream& os, bool& save_as_floats)
 {
   return save_binary_data (os, make_value (), value_save_tag,
@@ -186,18 +185,16 @@ bool octave_lazy_index::save_binary (std
 }
 
 bool octave_lazy_index::load_binary (std::istream& is, bool swap,
                                      oct_mach_info::float_format fmt)
 {
   bool dummy;
   std::string doc;
 
-  std::string nm = read_binary_data (is, swap, fmt, "",
-                                     dummy, value, doc);
-
+  std::string nm = read_binary_data (is, swap, fmt, "", dummy, value, doc);
   if (nm != value_save_tag)
     error ("lazy_index: corrupted data on load");
-  else
-    index = value.index_vector ();
+
+  index = value.index_vector ();
 
   return true;
 }
diff --git a/libinterp/octave-value/ov-mex-fcn.cc b/libinterp/octave-value/ov-mex-fcn.cc
--- a/libinterp/octave-value/ov-mex-fcn.cc
+++ b/libinterp/octave-value/ov-mex-fcn.cc
@@ -129,25 +129,23 @@ call_mex (bool have_fmex, void *f, const
 octave_value_list
 octave_mex_function::do_multi_index_op (int nargout,
                                         const octave_value_list& args)
 {
   octave_value_list retval;
 
   if (args.has_magic_colon ())
     error ("invalid use of colon in function argument list");
-  else
-    {
-      unwind_protect frame;
 
-      octave_call_stack::push (this);
+  unwind_protect frame;
+
+  octave_call_stack::push (this);
 
-      frame.add_fcn (octave_call_stack::pop);
+  frame.add_fcn (octave_call_stack::pop);
 
-      BEGIN_PROFILER_BLOCK (octave_mex_function)
+  BEGIN_PROFILER_BLOCK (octave_mex_function)
 
-        retval = call_mex (have_fmex, mex_fcn_ptr, args, nargout, this);
+    retval = call_mex (have_fmex, mex_fcn_ptr, args, nargout, this);
 
-      END_PROFILER_BLOCK
-    }
+  END_PROFILER_BLOCK
 
   return retval;
 }
diff --git a/libinterp/operators/op-int.h b/libinterp/operators/op-int.h
--- a/libinterp/operators/op-int.h
+++ b/libinterp/operators/op-int.h
@@ -624,18 +624,18 @@ octave_value elem_xpow (FloatNDArray a, 
   } \
  \
   DEFUNOP (m_transpose, TYPE ## _matrix) \
   { \
     CAST_UNOP_ARG (const octave_ ## TYPE ## _matrix&); \
  \
     if (v.ndims () > 2) \
       error ("transpose not defined for N-D objects"); \
-    else \
-      return octave_value (v.TYPE ## _array_value ().transpose ()); \
+ \
+    return octave_value (v.TYPE ## _array_value ().transpose ()); \
   } \
  \
   DEFNCUNOP_METHOD (m_incr, TYPE ## _matrix, increment) \
   DEFNCUNOP_METHOD (m_decr, TYPE ## _matrix, decrement) \
   DEFNCUNOP_METHOD (m_changesign, TYPE ## _matrix, changesign)
 
 // matrix by matrix ops.
 #define OCTAVE_MM_INT_ARITH_OPS(PFX, T1, T2, T3)        \
diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -1725,16 +1725,17 @@ ANY_INCLUDING_NL (.|{NL})
     else
       {
         curr_lexer->current_input_column++;
 
         error ("invalid character '%s' (ASCII %d) near line %d, column %d",
                undo_string_escape (static_cast<char> (c)), c,
                curr_lexer->input_line_number, curr_lexer->current_input_column);
 
+        // FIXME: This is no longer reachable now that error is exception based.
         return LEXICAL_ERROR;
       }
   }
 
 %{
 #if defined (HAVE_PRAGMA_GCC_DIAGNOSTIC)
 // Disable this warning for code that is generated by flex.
 #pragma GCC diagnostic push
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -3735,19 +3735,19 @@ octave_base_parser::validate_array_list 
   for (tree_array_list::iterator i = al->begin (); i != al->end (); i++)
     {
       tree_argument_list *row = *i;
 
       if (row && row->has_magic_tilde ())
         {
           retval = false;
           if (e->is_matrix ())
-             bison_error ("invalid use of tilde (~) in matrix expression");
-           else
-             bison_error ("invalid use of tilde (~) in cell expression");
+            bison_error ("invalid use of tilde (~) in matrix expression");
+          else
+            bison_error ("invalid use of tilde (~) in cell expression");
           break;
         }
     }
 
   return retval;
 }
 
 tree_argument_list *
diff --git a/libinterp/parse-tree/pt-binop.cc b/libinterp/parse-tree/pt-binop.cc
--- a/libinterp/parse-tree/pt-binop.cc
+++ b/libinterp/parse-tree/pt-binop.cc
@@ -42,19 +42,19 @@ static bool Vdo_braindead_shortcircuit_e
 
 octave_value_list
 tree_binary_expression::rvalue (int nargout)
 {
   octave_value_list retval;
 
   if (nargout > 1)
     error ("binary operator '%s': invalid number of output arguments",
-           oper () . c_str ());
-  else
-    retval = rvalue1 (nargout);
+           oper ().c_str ());
+
+  retval = rvalue1 (nargout);
 
   return retval;
 }
 
 void
 tree_binary_expression::matlab_style_short_circuit_warning (const char *op)
 {
   warning_with_id ("Octave:possible-matlab-short-circuit-operator",
@@ -172,19 +172,19 @@ tree_binary_expression::accept (tree_wal
 
 octave_value_list
 tree_boolean_expression::rvalue (int nargout)
 {
   octave_value_list retval;
 
   if (nargout > 1)
     error ("binary operator '%s': invalid number of output arguments",
-           oper () . c_str ());
-  else
-    retval = rvalue1 (nargout);
+           oper ().c_str ());
+
+  retval = rvalue1 (nargout);
 
   return retval;
 }
 
 octave_value
 tree_boolean_expression::rvalue1 (int)
 {
   octave_value retval;
diff --git a/libinterp/parse-tree/pt-cbinop.cc b/libinterp/parse-tree/pt-cbinop.cc
--- a/libinterp/parse-tree/pt-cbinop.cc
+++ b/libinterp/parse-tree/pt-cbinop.cc
@@ -34,19 +34,19 @@ along with Octave; see the file COPYING.
 
 octave_value_list
 tree_compound_binary_expression::rvalue (int nargout)
 {
   octave_value_list retval;
 
   if (nargout > 1)
     error ("binary operator '%s': invalid number of output arguments",
-           oper () . c_str ());
-  else
-    retval = rvalue1 (nargout);
+           oper ().c_str ());
+
+  retval = rvalue1 (nargout);
 
   return retval;
 }
 
 octave_value
 tree_compound_binary_expression::rvalue1 (int)
 {
   octave_value retval;
diff --git a/libinterp/parse-tree/pt-const.cc b/libinterp/parse-tree/pt-const.cc
--- a/libinterp/parse-tree/pt-const.cc
+++ b/libinterp/parse-tree/pt-const.cc
@@ -57,18 +57,18 @@ tree_constant::print_raw (std::ostream& 
 
 octave_value_list
 tree_constant::rvalue (int nargout)
 {
   octave_value_list retval;
 
   if (nargout > 1)
     error ("invalid number of output arguments for constant expression");
-  else
-    retval = rvalue1 (nargout);
+
+  retval = rvalue1 (nargout);
 
   return retval;
 }
 
 tree_expression *
 tree_constant::dup (symbol_table::scope_id,
                     symbol_table::context_id) const
 {
diff --git a/libinterp/parse-tree/pt-decl.h b/libinterp/parse-tree/pt-decl.h
--- a/libinterp/parse-tree/pt-decl.h
+++ b/libinterp/parse-tree/pt-decl.h
@@ -69,18 +69,18 @@ public:
   }
 
   octave_value_list rvalue (int nargout)
   {
     octave_value_list retval;
 
     if (nargout > 1)
       error ("invalid number of output arguments in declaration list");
-    else
-      retval = rvalue1 (nargout);
+
+    retval = rvalue1 (nargout);
 
     return retval;
   }
 
   octave_lvalue lvalue (void) { return id ? id->lvalue () : octave_lvalue (); }
 
   tree_identifier *ident (void) { return id; }
 
diff --git a/libinterp/parse-tree/pt-fcn-handle.cc b/libinterp/parse-tree/pt-fcn-handle.cc
--- a/libinterp/parse-tree/pt-fcn-handle.cc
+++ b/libinterp/parse-tree/pt-fcn-handle.cc
@@ -57,18 +57,18 @@ tree_fcn_handle::rvalue1 (int)
 
 octave_value_list
 tree_fcn_handle::rvalue (int nargout)
 {
   octave_value_list retval;
 
   if (nargout > 1)
     error ("invalid number of output arguments for function handle expression");
-  else
-    retval = rvalue1 (nargout);
+
+  retval = rvalue1 (nargout);
 
   return retval;
 }
 
 tree_expression *
 tree_fcn_handle::dup (symbol_table::scope_id,
                       symbol_table::context_id) const
 {
@@ -176,18 +176,18 @@ intentional, so don't change it.
 
 octave_value_list
 tree_anon_fcn_handle::rvalue (int nargout)
 {
   octave_value_list retval;
 
   if (nargout > 1)
     error ("invalid number of output arguments for anonymous function handle expression");
-  else
-    retval = rvalue1 (nargout);
+
+  retval = rvalue1 (nargout);
 
   return retval;
 }
 
 tree_expression *
 tree_anon_fcn_handle::dup (symbol_table::scope_id,
                            symbol_table::context_id) const
 {
diff --git a/libinterp/parse-tree/pt-unop.cc b/libinterp/parse-tree/pt-unop.cc
--- a/libinterp/parse-tree/pt-unop.cc
+++ b/libinterp/parse-tree/pt-unop.cc
@@ -45,19 +45,19 @@ tree_unary_expression::oper (void) const
 
 octave_value_list
 tree_prefix_expression::rvalue (int nargout)
 {
   octave_value_list retval;
 
   if (nargout > 1)
     error ("prefix operator '%s': invalid number of output arguments",
-           oper () . c_str ());
-  else
-    retval = rvalue1 (nargout);
+           oper ().c_str ());
+
+  retval = rvalue1 (nargout);
 
   return retval;
 }
 
 octave_value
 tree_prefix_expression::rvalue1 (int)
 {
   octave_value retval;
@@ -122,19 +122,19 @@ tree_prefix_expression::accept (tree_wal
 
 octave_value_list
 tree_postfix_expression::rvalue (int nargout)
 {
   octave_value_list retval;
 
   if (nargout > 1)
     error ("postfix operator '%s': invalid number of output arguments",
-           oper () . c_str ());
-  else
-    retval = rvalue1 (nargout);
+           oper ().c_str ());
+
+  retval = rvalue1 (nargout);
 
   return retval;
 }
 
 octave_value
 tree_postfix_expression::rvalue1 (int)
 {
   octave_value retval;
diff --git a/liboctave/numeric/CollocWt.cc b/liboctave/numeric/CollocWt.cc
--- a/liboctave/numeric/CollocWt.cc
+++ b/liboctave/numeric/CollocWt.cc
@@ -377,34 +377,28 @@ CollocWt::error (const char* msg)
 {
   (*current_liboctave_error_handler) ("CollocWt: fatal error '%s'", msg);
 }
 
 CollocWt&
 CollocWt::set_left (double val)
 {
   if (val >= rb)
-    {
-      error ("CollocWt: left bound greater than right bound");
-      return *this;
-    }
+    error ("CollocWt: left bound greater than right bound");
 
   lb = val;
   initialized = 0;
   return *this;
 }
 
 CollocWt&
 CollocWt::set_right (double val)
 {
   if (val <= lb)
-    {
-      error ("CollocWt: right bound less than left bound");
-      return *this;
-    }
+    error ("CollocWt: right bound less than left bound");
 
   rb = val;
   initialized = 0;
   return *this;
 }
 
 void
 CollocWt::init (void)
@@ -416,20 +410,17 @@ CollocWt::init (void)
     {
       error ("CollocWt: width less than or equal to zero");
       return;
     }
 
   octave_idx_type nt = n + inc_left + inc_right;
 
   if (nt < 0)
-    {
-      error ("CollocWt: total number of collocation points less than zero");
-      return;
-    }
+    error ("CollocWt: total number of collocation points less than zero");
   else if (nt == 0)
     return;
 
   Array<double> dif1 (dim_vector (nt, 1));
   double *pdif1 = dif1.fortran_vec ();
 
   Array<double> dif2 (dim_vector (nt, 1));
   double *pdif2 = dif2.fortran_vec ();
