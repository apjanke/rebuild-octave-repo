# HG changeset patch
# User Kai T. Ohlhus <k.ohlhus@gmail.com>
# Date 1548164048 -3600
#      Tue Jan 22 14:34:08 2019 +0100
# Node ID cc0d942d0e20dee755c065ff85f470b47b931210
# Parent  a7d56e0a5c8c93e30044de2e682f64d7fdc72621
Remove inconsistent warning "Octave:divide-by-zero" (bug #46650).

* libinterp/corefcn/errwarn.h (warn_divide_by_zero),
  libinterp/corefcn/errwarn.cc (warn_divide_by_zero): Deprecate function
  "warn_divide_by_zero", and leave implementation empty for a few releases.

* libinterp/corefcn/error.cc: Use different id for test.

* examples/code/make_int.cc: No longer advertise "warn_divide_by_zero" in the
  examples.

* libinterp/operators/op-*-*.cc: Remove unused header "errwarn.h".  Remove check
for scalar zero divisor including the warning.

* libinterp/operators/op-dms-template.cc (gripe_if_zero): Remove function.

* scripts/general/quadgk.m, scripts/general/quadv.m,
  scripts/statistics/kurtosis.m, scripts/statistics/mean.m,
  scripts/statistics/skewness.m: No longer need to turn off unused warning.

* scripts/help/warning_ids.m: Remove documentation of "Octave:divide-by-zero".

* test/jit.tst, test/mk-sparse-tst.sh, test/prefer.tst: Remove warning
  "Octave:divide-by-zero".

diff --git a/examples/code/make_int.cc b/examples/code/make_int.cc
--- a/examples/code/make_int.cc
+++ b/examples/code/make_int.cc
@@ -7,17 +7,16 @@
 #include <string>
 
 #include <octave/lo-mappers.h>
 #include <octave/lo-utils.h>
 #include <octave/mx-base.h>
 #include <octave/str-vec.h>
 
 #include <octave/defun-dld.h>
-#include <octave/errwarn.h>
 #include <octave/interpreter.h>
 #include <octave/ops.h>
 #include <octave/ov-base.h>
 #include <octave/ov-scalar.h>
 #include <octave/ov-typeinfo.h>
 #include <octave/ov.h>
 #include <octave/ovl.h>
 #include <octave/pager.h>
@@ -156,84 +155,59 @@ DEFBINOP_OP (add, integer, integer, +)
 DEFBINOP_OP (sub, integer, integer, -)
 DEFBINOP_OP (mul, integer, integer, *)
 
 DEFBINOP (div, integer, integer)
 {
   const octave_integer& v1 = dynamic_cast<const octave_integer&> (a1);
   const octave_integer& v2 = dynamic_cast<const octave_integer&> (a2);
 
-  int d = v2.integer_value ();
-
-  if (d == 0)
-    warn_divide_by_zero ();
-
-  return new octave_integer (v1.integer_value () / d);
+  return new octave_integer (v1.integer_value () / v2.integer_value ());
 }
 
 
 DEFBINOP (i_s_div, integer, scalar)
 {
   const octave_integer& v1 = dynamic_cast<const octave_integer&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
-  double d = v2.double_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return new octave_scalar (v1.double_value () / d);
+  return new octave_scalar (v1.double_value () / v2.double_value ());
 }
 
 DEFBINOP (ldiv, integer, integer)
 {
   const octave_integer& v1 = dynamic_cast<const octave_integer&> (a1);
   const octave_integer& v2 = dynamic_cast<const octave_integer&> (a2);
 
-  int d = v1.integer_value ();
-
-  if (d == 0)
-    warn_divide_by_zero ();
-
-  return new octave_integer (v2.integer_value () / d);
+  return new octave_integer (v2.integer_value () / v1.integer_value ());
 }
 
 DEFBINOP_OP (lt, integer, integer, <)
 DEFBINOP_OP (le, integer, integer, <=)
 DEFBINOP_OP (eq, integer, integer, ==)
 DEFBINOP_OP (ge, integer, integer, >=)
 DEFBINOP_OP (gt, integer, integer, >)
 DEFBINOP_OP (ne, integer, integer, !=)
 
 DEFBINOP_OP (el_mul, integer, integer, !=)
 
 DEFBINOP (el_div, integer, integer)
 {
   const octave_integer& v1 = dynamic_cast<const octave_integer&> (a1);
   const octave_integer& v2 = dynamic_cast<const octave_integer&> (a2);
 
-  int d = v2.integer_value ();
-
-  if (d == 0)
-    warn_divide_by_zero ();
-
-  return new octave_integer (v1.integer_value () / d);
+  return new octave_integer (v1.integer_value () / v2.integer_value ());
 }
 
 DEFBINOP (el_ldiv, integer, integer)
 {
   const octave_integer& v1 = dynamic_cast<const octave_integer&> (a1);
   const octave_integer& v2 = dynamic_cast<const octave_integer&> (a2);
 
-  int d = v1.integer_value ();
-
-  if (d == 0)
-    warn_divide_by_zero ();
-
-  return new octave_integer (v2.integer_value () / d);
+  return new octave_integer (v2.integer_value () / v1.integer_value ());
 }
 
 DEFBINOP_OP (el_and, integer, integer, &&)
 DEFBINOP_OP (el_or, integer, integer, ||)
 
 DEFMETHOD_DLD (make_int, interp, args, ,
                "int_val = make_int (val)\n\
 \n\
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -988,17 +988,17 @@ handle_message (error_fun f, const char 
 
       if (arg.is_defined ())
         {
           if (arg.isempty ())
             return retval;
           else if (arg.is_string ())
             {
               tmpstr = arg.string_value ();  // 2-stage assignment required
-              msg = tmpstr.c_str ();         // in order to generate pointer  
+              msg = tmpstr.c_str ();         // in order to generate pointer
                                              // to valid memory.
             }
         }
     }
 
   // Ugh.
 
   size_t len = strlen (msg);
@@ -1814,17 +1814,17 @@ expansion use a second backslash before 
 /*
 %!test <*45753>
 %! warning ("error");
 %! assert (! isempty (help ("warning")));
 */
 
 /*
 %!test <*51997>
-%! id = "Octave:divide-by-zero";
+%! id = "Octave:logical-conversion";
 %! current = warning ("query", id);
 %! current_all = warning ();
 %! previous = warning (current_all);
 %! assert (previous, current_all);
 %! previous = warning (current);
 %! assert (previous, current);
 %! previous = warning (current.state, id);
 %! assert (previous, current);
diff --git a/libinterp/corefcn/errwarn.cc b/libinterp/corefcn/errwarn.cc
--- a/libinterp/corefcn/errwarn.cc
+++ b/libinterp/corefcn/errwarn.cc
@@ -319,22 +319,16 @@ warn_disabled_feature (const std::string
     warning ("%s: support for %s was unavailable or disabled when %s was built",
              fcn.c_str (), feature.c_str (), pkg.c_str ());
   else
     warning ("support for %s was unavailable or disabled when %s was built",
              feature.c_str (), pkg.c_str ());
 }
 
 void
-warn_divide_by_zero (void)
-{
-  warning_with_id ("Octave:divide-by-zero", "division by zero");
-}
-
-void
 warn_empty_arg (const char *name)
 {
   warning ("%s: argument is empty matrix", name);
 }
 
 void
 warn_implicit_conversion (const char *id, const char *from, const char *to)
 {
diff --git a/libinterp/corefcn/errwarn.h b/libinterp/corefcn/errwarn.h
--- a/libinterp/corefcn/errwarn.h
+++ b/libinterp/corefcn/errwarn.h
@@ -159,19 +159,16 @@ warn_complex_cmp (void);
 OCTINTERP_API extern void
 warn_data_file_in_path (const std::string& fcn, const std::string& file);
 
 OCTINTERP_API extern void
 warn_disabled_feature (const std::string& fcn, const std::string& feature,
                        const std::string& pkg = "Octave");
 
 OCTINTERP_API extern void
-warn_divide_by_zero (void);
-
-OCTINTERP_API extern void
 warn_empty_arg (const char *name);
 
 OCTINTERP_API extern void
 warn_implicit_conversion (const char *id, const char *from, const char *to);
 
 OCTINTERP_API extern void
 warn_implicit_conversion (const std::string& id, const std::string& from,
                           const std::string& to);
@@ -180,9 +177,16 @@ OCTINTERP_API extern void
 warn_invalid_value_specified (const char *name);
 
 OCTINTERP_API extern void
 warn_logical_conversion (void);
 
 OCTINTERP_API extern void
 warn_wrong_type_arg (const char *name, const octave_value& tc);
 
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
+
+OCTAVE_DEPRECATED (6, "do not use 'Octave:divide-by-zero'")
+OCTINTERP_API extern void warn_divide_by_zero (void) {}
+
 #endif
+
+#endif
diff --git a/libinterp/operators/op-cm-cs.cc b/libinterp/operators/op-cm-cs.cc
--- a/libinterp/operators/op-cm-cs.cc
+++ b/libinterp/operators/op-cm-cs.cc
@@ -19,17 +19,16 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-complex.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
@@ -42,22 +41,17 @@ DEFNDBINOP_OP (sub, complex_matrix, comp
 DEFNDBINOP_OP (mul, complex_matrix, complex, complex_array, complex, *)
 
 DEFBINOP (div, complex_matrix, complex)
 {
   const octave_complex_matrix& v1
     = dynamic_cast<const octave_complex_matrix&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
-  Complex d = v2.complex_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v1.complex_array_value () / d);
+  return octave_value (v1.complex_array_value () / v2.complex_value ());
 }
 
 DEFBINOP_FN (pow, complex_matrix, complex, xpow)
 
 DEFBINOP (ldiv, complex_matrix, complex)
 {
   const octave_complex_matrix& v1
     = dynamic_cast<const octave_complex_matrix&> (a1);
@@ -88,22 +82,17 @@ DEFNDCMPLXCMPOP_FN (ne, complex_matrix, 
 DEFNDBINOP_OP (el_mul, complex_matrix, complex, complex_array, complex, *)
 
 DEFBINOP (el_div, complex_matrix, complex)
 {
   const octave_complex_matrix& v1
     = dynamic_cast<const octave_complex_matrix&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
-  Complex d = v2.complex_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v1.complex_array_value () / d);
+  return octave_value (v1.complex_array_value () / v2.complex_value ());
 }
 
 DEFNDBINOP_FN (el_pow, complex_matrix, complex, complex_array, complex,
                elem_xpow)
 
 DEFBINOP (el_ldiv, complex_matrix, complex)
 {
   const octave_complex_matrix& v1
diff --git a/libinterp/operators/op-cm-s.cc b/libinterp/operators/op-cm-s.cc
--- a/libinterp/operators/op-cm-s.cc
+++ b/libinterp/operators/op-cm-s.cc
@@ -22,17 +22,16 @@ along with Octave; see the file COPYING.
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include "mx-cm-s.h"
 #include "mx-cnda-s.h"
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-cx-mat.h"
 #include "ov-re-mat.h"
 #include "ov-scalar.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
@@ -45,22 +44,17 @@ DEFNDBINOP_OP (sub, complex_matrix, scal
 DEFNDBINOP_OP (mul, complex_matrix, scalar, complex_array, scalar, *)
 
 DEFBINOP (div, complex_matrix, scalar)
 {
   const octave_complex_matrix& v1
     = dynamic_cast<const octave_complex_matrix&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
-  double d = v2.double_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v1.complex_array_value () / d);
+  return octave_value (v1.complex_array_value () / v2.double_value ());
 }
 
 DEFBINOP_FN (pow, complex_matrix, scalar, xpow)
 
 DEFBINOP (ldiv, complex_matrix, scalar)
 {
   const octave_complex_matrix& v1
     = dynamic_cast<const octave_complex_matrix&> (a1);
@@ -86,22 +80,17 @@ DEFNDCMPLXCMPOP_FN (ne, complex_matrix, 
 DEFNDBINOP_OP (el_mul, complex_matrix, scalar, complex_array, scalar, *)
 
 DEFBINOP (el_div, complex_matrix, scalar)
 {
   const octave_complex_matrix& v1
     = dynamic_cast<const octave_complex_matrix&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
-  double d = v2.double_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v1.complex_array_value () / d);
+  return octave_value (v1.complex_array_value () / v2.double_value ());
 }
 
 DEFNDBINOP_FN (el_pow, complex_matrix, scalar, complex_array, scalar, elem_xpow)
 
 DEFBINOP (el_ldiv, complex_matrix, scalar)
 {
   const octave_complex_matrix& v1
     = dynamic_cast<const octave_complex_matrix&> (a1);
diff --git a/libinterp/operators/op-cm-scm.cc b/libinterp/operators/op-cm-scm.cc
--- a/libinterp/operators/op-cm-scm.cc
+++ b/libinterp/operators/op-cm-scm.cc
@@ -20,17 +20,16 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-cx-mat.h"
 #include "ops.h"
 #include "xdiv.h"
 
 #include "sparse-xpow.h"
@@ -49,24 +48,17 @@ DEFBINOP_OP (mul, complex_matrix, sparse
 DEFBINOP (div, complex_matrix, sparse_complex_matrix)
 {
   const octave_complex_matrix& v1
     = dynamic_cast<const octave_complex_matrix&> (a1);
   const octave_sparse_complex_matrix& v2
     = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
-    {
-      Complex d = v2.complex_value ();
-
-      if (d == 0.0)
-        warn_divide_by_zero ();
-
-      return octave_value (v1.complex_array_value () / d);
-    }
+    return octave_value (v1.complex_array_value () / v2.complex_value ());
   else
     {
       MatrixType typ = v2.matrix_type ();
 
       ComplexMatrix ret = xdiv (v1.complex_matrix_value (),
                                 v2.sparse_complex_matrix_value (), typ);
 
       v2.matrix_type (typ);
diff --git a/libinterp/operators/op-cm-sm.cc b/libinterp/operators/op-cm-sm.cc
--- a/libinterp/operators/op-cm-sm.cc
+++ b/libinterp/operators/op-cm-sm.cc
@@ -20,17 +20,16 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-cx-mat.h"
 #include "ops.h"
 #include "xdiv.h"
 
 #include "sparse-xpow.h"
@@ -49,24 +48,17 @@ DEFBINOP_OP (mul, complex_matrix, sparse
 DEFBINOP (div, complex_matrix, sparse_matrix)
 {
   const octave_complex_matrix& v1
     = dynamic_cast<const octave_complex_matrix&> (a1);
   const octave_sparse_matrix& v2
     = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
-    {
-      double d = v2.scalar_value ();
-
-      if (d == 0.0)
-        warn_divide_by_zero ();
-
-      return octave_value (v1.complex_array_value () / d);
-    }
+    return octave_value (v1.complex_array_value () / v2.scalar_value ());
   else
     {
       MatrixType typ = v2.matrix_type ();
 
       ComplexMatrix ret = xdiv (v1.complex_matrix_value (),
                                 v2.sparse_matrix_value (), typ);
 
       v2.matrix_type (typ);
diff --git a/libinterp/operators/op-cs-cm.cc b/libinterp/operators/op-cs-cm.cc
--- a/libinterp/operators/op-cs-cm.cc
+++ b/libinterp/operators/op-cs-cm.cc
@@ -19,17 +19,16 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
@@ -59,22 +58,17 @@ DEFBINOP (div, complex, complex_matrix)
 DEFBINOP_FN (pow, complex, complex_matrix, xpow)
 
 DEFBINOP (ldiv, complex, complex_matrix)
 {
   const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
   const octave_complex_matrix& v2
     = dynamic_cast<const octave_complex_matrix&> (a2);
 
-  Complex d = v1.complex_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v2.complex_array_value () / d);
+  return octave_value (v2.complex_array_value () / v1.complex_value ());
 }
 
 DEFNDCMPLXCMPOP_FN (lt, complex, complex_matrix, complex, complex_array,
                     mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, complex, complex_matrix, complex, complex_array,
                     mx_el_le)
 DEFNDCMPLXCMPOP_FN (eq, complex, complex_matrix, complex, complex_array,
                     mx_el_eq)
@@ -92,22 +86,17 @@ DEFNDBINOP_FN (el_pow, complex, complex_
                elem_xpow)
 
 DEFBINOP (el_ldiv, complex, complex_matrix)
 {
   const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
   const octave_complex_matrix& v2
     = dynamic_cast<const octave_complex_matrix&> (a2);
 
-  Complex d = v1.complex_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v2.complex_array_value () / d);
+  return octave_value (v2.complex_array_value () / v1.complex_value ());
 }
 
 DEFNDBINOP_FN (el_and, complex, complex_matrix, complex, complex_array,
                mx_el_and)
 DEFNDBINOP_FN (el_or,  complex, complex_matrix, complex, complex_array,
                mx_el_or)
 
 DEFNDCATOP_FN (cs_cm, complex, complex_matrix, complex_array, complex_array,
diff --git a/libinterp/operators/op-cs-cs.cc b/libinterp/operators/op-cs-cs.cc
--- a/libinterp/operators/op-cs-cs.cc
+++ b/libinterp/operators/op-cs-cs.cc
@@ -21,17 +21,16 @@ along with Octave; see the file COPYING.
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include "Array-util.h"
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-typeinfo.h"
 #include "ov-null-mat.h"
 #include "ops.h"
@@ -70,74 +69,54 @@ DEFBINOP_OP (add, complex, complex, +)
 DEFBINOP_OP (sub, complex, complex, -)
 DEFBINOP_OP (mul, complex, complex, *)
 
 DEFBINOP (div, complex, complex)
 {
   const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
-  Complex d = v2.complex_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v1.complex_value () / d);
+  return octave_value (v1.complex_value () / v2.complex_value ());
 }
 
 DEFBINOP_FN (pow, complex, complex, xpow)
 
 DEFBINOP (ldiv, complex, complex)
 {
   const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
-  Complex d = v1.complex_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v2.complex_value () / d);
+  return octave_value (v2.complex_value () / v1.complex_value ());
 }
 
 DEFCMPLXCMPOP_OP (lt, complex, complex, <)
 DEFCMPLXCMPOP_OP (le, complex, complex, <=)
 DEFCMPLXCMPOP_OP (eq, complex, complex, ==)
 DEFCMPLXCMPOP_OP (ge, complex, complex, >=)
 DEFCMPLXCMPOP_OP (gt, complex, complex, >)
 DEFCMPLXCMPOP_OP (ne, complex, complex, !=)
 
 DEFBINOP_OP (el_mul, complex, complex, *)
 
 DEFBINOP (el_div, complex, complex)
 {
   const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
-  Complex d = v2.complex_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v1.complex_value () / d);
+  return octave_value (v1.complex_value () / v2.complex_value ());
 }
 
 DEFBINOP_FN (el_pow, complex, complex, xpow)
 
 DEFBINOP (el_ldiv, complex, complex)
 {
   const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
-  Complex d = v1.complex_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v2.complex_value () / d);
+  return octave_value (v2.complex_value () / v1.complex_value ());
 }
 
 DEFBINOP (el_and, complex, complex)
 {
   const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   return v1.complex_value () != 0.0 && v2.complex_value () != 0.0;
diff --git a/libinterp/operators/op-cs-m.cc b/libinterp/operators/op-cs-m.cc
--- a/libinterp/operators/op-cs-m.cc
+++ b/libinterp/operators/op-cs-m.cc
@@ -24,17 +24,16 @@ along with Octave; see the file COPYING.
 #  include "config.h"
 #endif
 
 #include "mx-cs-nda.h"
 #include "mx-nda-cs.h"
 #include "mx-cs-nda.h"
 #include "mx-nda-cs.h"
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-re-mat.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
@@ -63,22 +62,17 @@ DEFBINOP (div, complex, matrix)
 
 DEFBINOP_FN (pow, complex, matrix, xpow)
 
 DEFBINOP (ldiv, complex, matrix)
 {
   const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
   const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
 
-  Complex d = v1.complex_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v2.array_value () / d);
+  return octave_value (v2.array_value () / v1.complex_value ());
 }
 
 DEFNDCMPLXCMPOP_FN (lt, complex, matrix, complex, array, mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, complex, matrix, complex, array, mx_el_le)
 DEFNDCMPLXCMPOP_FN (eq, complex, matrix, complex, array, mx_el_eq)
 DEFNDCMPLXCMPOP_FN (ge, complex, matrix, complex, array, mx_el_ge)
 DEFNDCMPLXCMPOP_FN (gt, complex, matrix, complex, array, mx_el_gt)
 DEFNDCMPLXCMPOP_FN (ne, complex, matrix, complex, array, mx_el_ne)
@@ -87,22 +81,17 @@ DEFNDBINOP_OP (el_mul, complex, matrix, 
 DEFNDBINOP_FN (el_div, complex, matrix, complex, array, x_el_div)
 DEFNDBINOP_FN (el_pow, complex, matrix, complex, array, elem_xpow)
 
 DEFBINOP (el_ldiv, complex, matrix)
 {
   const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
   const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
 
-  Complex d = v1.complex_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v2.array_value () / d);
+  return octave_value (v2.array_value () / v1.complex_value ());
 }
 
 DEFNDBINOP_FN (el_and, complex, matrix, complex, array, mx_el_and)
 DEFNDBINOP_FN (el_or,  complex, matrix, complex, array, mx_el_or)
 
 DEFNDCATOP_FN (cs_m, complex, matrix, complex_array, array, concat)
 
 void
diff --git a/libinterp/operators/op-cs-s.cc b/libinterp/operators/op-cs-s.cc
--- a/libinterp/operators/op-cs-s.cc
+++ b/libinterp/operators/op-cs-s.cc
@@ -19,17 +19,16 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-scalar.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
@@ -41,74 +40,54 @@ DEFBINOP_OP (add, complex, scalar, +)
 DEFBINOP_OP (sub, complex, scalar, -)
 DEFBINOP_OP (mul, complex, scalar, *)
 
 DEFBINOP (div, complex, scalar)
 {
   const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
-  double d = v2.double_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v1.complex_value () / d);
+  return octave_value (v1.complex_value () / v2.double_value ());
 }
 
 DEFBINOP_FN (pow, complex, scalar, xpow)
 
 DEFBINOP (ldiv, complex, scalar)
 {
   const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
-  Complex d = v1.complex_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v2.double_value () / d);
+  return octave_value (v2.double_value () / v1.complex_value ());
 }
 
 DEFCMPLXCMPOP_OP (lt, complex, scalar, <)
 DEFCMPLXCMPOP_OP (le, complex, scalar, <=)
 DEFCMPLXCMPOP_OP (eq, complex, scalar, ==)
 DEFCMPLXCMPOP_OP (ge, complex, scalar, >=)
 DEFCMPLXCMPOP_OP (gt, complex, scalar, >)
 DEFCMPLXCMPOP_OP (ne, complex, scalar, !=)
 
 DEFBINOP_OP (el_mul, complex, scalar, *)
 
 DEFBINOP (el_div, complex, scalar)
 {
   const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
-  double d = v2.double_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v1.complex_value () / d);
+  return octave_value (v1.complex_value () / v2.double_value ());
 }
 
 DEFBINOP_FN (el_pow, complex, scalar, xpow)
 
 DEFBINOP (el_ldiv, complex, scalar)
 {
   const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
-  Complex d = v1.complex_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v2.double_value () / d);
+  return octave_value (v2.double_value () / v1.complex_value ());
 }
 
 DEFBINOP (el_and, complex, scalar)
 {
   const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   return v1.complex_value () != 0.0 && v2.double_value ();
diff --git a/libinterp/operators/op-cs-scm.cc b/libinterp/operators/op-cs-scm.cc
--- a/libinterp/operators/op-cs-scm.cc
+++ b/libinterp/operators/op-cs-scm.cc
@@ -20,17 +20,16 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-cx-mat.h"
 #include "ov-complex.h"
 #include "ops.h"
 #include "xpow.h"
 
@@ -46,24 +45,18 @@ DEFBINOP_OP (mul, complex, sparse_comple
 
 DEFBINOP (div, complex, sparse_complex_matrix)
 {
   const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
   const octave_sparse_complex_matrix& v2
     = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
-    {
-      Complex d = v2.complex_value ();
-
-      if (d == 0.0)
-        warn_divide_by_zero ();
-
-      return octave_value (SparseComplexMatrix (1, 1, v1.complex_value () / d));
-    }
+    return octave_value (SparseComplexMatrix (1, 1, v1.complex_value ()
+                                                  / v2.complex_value ()));
   else
     {
       MatrixType typ = v2.matrix_type ();
       ComplexMatrix m1 = ComplexMatrix (1, 1, v1.complex_value ());
       SparseComplexMatrix m2 = v2.sparse_complex_matrix_value ();
       ComplexMatrix ret = xdiv (m1, m2, typ);
       v2.matrix_type (typ);
       return ret;
@@ -79,22 +72,17 @@ DEFBINOP (pow, complex, sparse_complex_m
 }
 
 DEFBINOP (ldiv, complex, sparse_complex_matrix)
 {
   const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
   const octave_sparse_complex_matrix& v2
     = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
-  Complex d = v1.complex_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v2.sparse_complex_matrix_value () / d);
+  return octave_value (v2.sparse_complex_matrix_value () / v1.complex_value ());
 }
 
 DEFBINOP_FN (lt, complex, sparse_complex_matrix, mx_el_lt)
 DEFBINOP_FN (le, complex, sparse_complex_matrix, mx_el_le)
 DEFBINOP_FN (eq, complex, sparse_complex_matrix, mx_el_eq)
 DEFBINOP_FN (ge, complex, sparse_complex_matrix, mx_el_ge)
 DEFBINOP_FN (gt, complex, sparse_complex_matrix, mx_el_gt)
 DEFBINOP_FN (ne, complex, sparse_complex_matrix, mx_el_ne)
@@ -105,25 +93,17 @@ DEFBINOP_FN (el_div, complex, sparse_com
 DEFBINOP_FN (el_pow, complex, sparse_complex_matrix, elem_xpow)
 
 DEFBINOP (el_ldiv, complex, sparse_complex_matrix)
 {
   const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
   const octave_sparse_complex_matrix& v2
     = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
-  Complex d = v1.complex_value ();
-  octave_value retval;
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  retval = octave_value (v2.sparse_complex_matrix_value () / d);
-
-  return retval;
+  return octave_value (v2.sparse_complex_matrix_value () / v1.complex_value ());
 }
 
 DEFBINOP_FN (el_and, complex, sparse_complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  complex, sparse_complex_matrix, mx_el_or)
 
 DEFCATOP (cs_scm, complex, sparse_complex_matrix)
 {
   octave_complex& v1 = dynamic_cast<octave_complex&> (a1);
diff --git a/libinterp/operators/op-cs-sm.cc b/libinterp/operators/op-cs-sm.cc
--- a/libinterp/operators/op-cs-sm.cc
+++ b/libinterp/operators/op-cs-sm.cc
@@ -20,17 +20,16 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-complex.h"
 #include "ops.h"
 #include "xpow.h"
 
 #include "sparse-xpow.h"
@@ -47,24 +46,17 @@ DEFBINOP_OP (sub, complex, sparse_matrix
 DEFBINOP_OP (mul, complex, sparse_matrix, *)
 
 DEFBINOP (div, complex, sparse_matrix)
 {
   const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
   const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
-    {
-      double d = v2.scalar_value ();
-
-      if (d == 0.0)
-        warn_divide_by_zero ();
-
-      return octave_value (SparseComplexMatrix (1, 1, v1.complex_value () / d));
-    }
+    return octave_value (SparseComplexMatrix (1, 1, v1.complex_value () / v2.scalar_value ()));
   else
     {
       MatrixType typ = v2.matrix_type ();
       ComplexMatrix m1 = ComplexMatrix (1, 1, v1.complex_value ());
       SparseMatrix m2 = v2.sparse_matrix_value ();
       ComplexMatrix ret = xdiv (m1, m2, typ);
       v2.matrix_type (typ);
       return ret;
@@ -78,25 +70,17 @@ DEFBINOP (pow, complex, sparse_matrix)
   return xpow (v1.complex_value (), v2.matrix_value ());
 }
 
 DEFBINOP (ldiv, complex, sparse_matrix)
 {
   const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
   const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
 
-  Complex d = v1.complex_value ();
-  octave_value retval;
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  retval = octave_value (v2.sparse_matrix_value () / d);
-
-  return retval;
+  return octave_value (v2.sparse_matrix_value () / v1.complex_value ());
 }
 
 DEFBINOP_FN (lt, complex, sparse_matrix, mx_el_lt)
 DEFBINOP_FN (le, complex, sparse_matrix, mx_el_le)
 DEFBINOP_FN (eq, complex, sparse_matrix, mx_el_eq)
 DEFBINOP_FN (ge, complex, sparse_matrix, mx_el_ge)
 DEFBINOP_FN (gt, complex, sparse_matrix, mx_el_gt)
 DEFBINOP_FN (ne, complex, sparse_matrix, mx_el_ne)
@@ -105,25 +89,17 @@ DEFBINOP_OP (el_mul, complex, sparse_mat
 DEFBINOP_FN (el_div, complex, sparse_matrix, x_el_div)
 DEFBINOP_FN (el_pow, complex, sparse_matrix, elem_xpow)
 
 DEFBINOP (el_ldiv, complex, sparse_matrix)
 {
   const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
   const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
 
-  Complex d = v1.complex_value ();
-  octave_value retval;
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  retval = octave_value (v2.sparse_matrix_value () / d);
-
-  return retval;
+  return octave_value (v2.sparse_matrix_value () / v1.complex_value ());
 }
 
 DEFBINOP_FN (el_and, complex, sparse_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  complex, sparse_matrix, mx_el_or)
 
 DEFCATOP (cs_sm, sparse_matrix, complex)
 {
   octave_complex& v1 = dynamic_cast<octave_complex&> (a1);
@@ -131,18 +107,17 @@ DEFCATOP (cs_sm, sparse_matrix, complex)
   SparseComplexMatrix tmp (1, 1, v1.complex_value ());
   return octave_value (tmp. concat (v2.sparse_matrix_value (), ra_idx));
 }
 
 DEFCONV (sparse_matrix_conv, complex, sparse_matrix)
 {
   const octave_complex& v = dynamic_cast<const octave_complex&> (a);
 
-  return new octave_sparse_matrix
-         (SparseMatrix (v.matrix_value ()));
+  return new octave_sparse_matrix (SparseMatrix (v.matrix_value ()));
 }
 
 void
 install_cs_sm_ops (octave::type_info& ti)
 {
   INSTALL_BINOP_TI (ti, op_add, octave_complex, octave_sparse_matrix, add);
   INSTALL_BINOP_TI (ti, op_sub, octave_complex, octave_sparse_matrix, sub);
   INSTALL_BINOP_TI (ti, op_mul, octave_complex, octave_sparse_matrix, mul);
diff --git a/libinterp/operators/op-dm-scm.cc b/libinterp/operators/op-dm-scm.cc
--- a/libinterp/operators/op-dm-scm.cc
+++ b/libinterp/operators/op-dm-scm.cc
@@ -28,17 +28,16 @@ along with Octave; see the file COPYING.
 #include "mx-s-cm.h"
 
 #include "mx-dm-cs.h"
 #include "mx-cs-dm.h"
 
 #include "mx-m-cs.h"
 #include "mx-cs-m.h"
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 
 #include "ov-re-diag.h"
 #include "ov-cx-diag.h"
 #include "ov-re-sparse.h"
@@ -367,72 +366,51 @@ DEFBINOP (mul_scm_cdm, sparse_complex_ma
 
 DEFBINOP (div_scm_dm, sparse_complex_matrix, diag_matrix)
 {
   const octave_sparse_complex_matrix& v1
     = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
   const octave_diag_matrix& v2 = dynamic_cast<const octave_diag_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
-    {
-      double d = v2.scalar_value ();
-
-      if (d == 0.0)
-        warn_divide_by_zero ();
-
-      return octave_value (v1.sparse_complex_matrix_value () / d);
-    }
+    return octave_value (v1.sparse_complex_matrix_value () / v2.scalar_value ());
   else
     {
       MatrixType typ = v2.matrix_type ();
       return xdiv (v1.sparse_complex_matrix_value (),
                    v2.diag_matrix_value (), typ);
     }
 }
 
 DEFBINOP (div_sm_cdm, sparse_matrix, complex_diag_matrix)
 {
   const octave_sparse_matrix& v1
     = dynamic_cast<const octave_sparse_matrix&> (a1);
   const octave_complex_diag_matrix& v2
     = dynamic_cast<const octave_complex_diag_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
-    {
-      std::complex<double> d = v2.complex_value ();
-
-      if (d == 0.0)
-        warn_divide_by_zero ();
-
-      return octave_value (v1.sparse_matrix_value () / d);
-    }
+    return octave_value (v1.sparse_matrix_value () / v2.complex_value ());
   else
     {
       MatrixType typ = v2.matrix_type ();
       return xdiv (v1.sparse_matrix_value (),
                    v2.complex_diag_matrix_value (), typ);
     }
 }
 
 DEFBINOP (div_scm_cdm, sparse_complex_matrix, complex_diag_matrix)
 {
   const octave_sparse_complex_matrix& v1
     = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
   const octave_complex_diag_matrix& v2
     = dynamic_cast<const octave_complex_diag_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
-    {
-      std::complex<double> d = v2.complex_value ();
-
-      if (d == 0.0)
-        warn_divide_by_zero ();
-
-      return octave_value (v1.sparse_complex_matrix_value () / d);
-    }
+    return octave_value (v1.sparse_complex_matrix_value () / v2.complex_value ());
   else
     {
       MatrixType typ = v2.matrix_type ();
       return xdiv (v1.sparse_complex_matrix_value (),
                    v2.complex_diag_matrix_value (), typ);
     }
 }
 
diff --git a/libinterp/operators/op-dm-sm.cc b/libinterp/operators/op-dm-sm.cc
--- a/libinterp/operators/op-dm-sm.cc
+++ b/libinterp/operators/op-dm-sm.cc
@@ -19,17 +19,16 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 
 #include "ov-re-diag.h"
 #include "ov-re-sparse.h"
 
@@ -131,24 +130,17 @@ DEFBINOP (mul_sm_dm, sparse_matrix, diag
 }
 
 DEFBINOP (div_sm_dm, sparse_matrix, diag_matrix)
 {
   const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
   const octave_diag_matrix& v2 = dynamic_cast<const octave_diag_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
-    {
-      double d = v2.scalar_value ();
-
-      if (d == 0.0)
-        warn_divide_by_zero ();
-
-      return octave_value (v1.sparse_matrix_value () / d);
-    }
+    return octave_value (v1.sparse_matrix_value () / v2.scalar_value ());
   else
     {
       MatrixType typ = v2.matrix_type ();
       return xdiv (v1.sparse_matrix_value (), v2.diag_matrix_value (), typ);
     }
 }
 
 DEFBINOP (add_sm_dm, sparse_matrix, diag_matrix)
diff --git a/libinterp/operators/op-dms-template.cc b/libinterp/operators/op-dms-template.cc
--- a/libinterp/operators/op-dms-template.cc
+++ b/libinterp/operators/op-dms-template.cc
@@ -20,17 +20,16 @@ along with Octave; see the file COPYING.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include "ops.h"
-#include "errwarn.h"
 #include "xpow.h"
 #include SINCLUDE
 #include MINCLUDE
 
 // matrix by diag matrix ops.
 
 #if ! defined (SCALARV)
 #  define SCALARV SCALAR
@@ -43,40 +42,30 @@ along with Octave; see the file COPYING.
 DEFNDBINOP_OP (sdmmul, SCALAR, MATRIX, SCALARV, MATRIXV, *)
 DEFNDBINOP_OP (dmsmul, MATRIX, SCALAR, MATRIXV, SCALARV, *)
 
 #define OCTAVE_MATRIX CONCAT2(octave_, MATRIX)
 #define OCTAVE_SCALAR CONCAT2(octave_, SCALAR)
 #define MATRIX_VALUE CONCAT2(MATRIXV, _value)
 #define SCALAR_VALUE CONCAT2(SCALARV, _value)
 
-template <typename T>
-static T
-gripe_if_zero (T x)
-{
-  if (x == T ())
-    warn_divide_by_zero ();
-
-  return x;
-}
-
 DEFBINOP (dmsdiv, MATRIX, SCALAR)
 {
   const OCTAVE_MATRIX& v1 = dynamic_cast<const OCTAVE_MATRIX&> (a1);
   const OCTAVE_SCALAR& v2 = dynamic_cast<const OCTAVE_SCALAR&> (a2);
 
-  return v1.MATRIX_VALUE () / gripe_if_zero (v2.SCALAR_VALUE ());
+  return v1.MATRIX_VALUE () / v2.SCALAR_VALUE ();
 }
 
 DEFBINOP (sdmldiv, SCALAR, MATRIX)
 {
   const OCTAVE_SCALAR& v1 = dynamic_cast<const OCTAVE_SCALAR&> (a1);
   const OCTAVE_MATRIX& v2 = dynamic_cast<const OCTAVE_MATRIX&> (a2);
 
-  return v2.MATRIX_VALUE () / gripe_if_zero (v1.SCALAR_VALUE ());
+  return v2.MATRIX_VALUE () / v1.SCALAR_VALUE ();
 }
 
 DEFBINOP (dmspow, MATRIX, SCALAR)
 {
   const OCTAVE_MATRIX& v1 = dynamic_cast<const OCTAVE_MATRIX&> (a1);
   const OCTAVE_SCALAR& v2 = dynamic_cast<const OCTAVE_SCALAR&> (a2);
 
   return xpow (v1.MATRIX_VALUE (), v2.SCALAR_VALUE ());
diff --git a/libinterp/operators/op-fcm-fcs.cc b/libinterp/operators/op-fcm-fcs.cc
--- a/libinterp/operators/op-fcm-fcs.cc
+++ b/libinterp/operators/op-fcm-fcs.cc
@@ -19,17 +19,16 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-flt-complex.h"
 #include "ov-complex.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
@@ -47,22 +46,17 @@ DEFNDBINOP_OP (mul, float_complex_matrix
 
 DEFBINOP (div, float_complex_matrix, float_complex)
 {
   const octave_float_complex_matrix& v1
     = dynamic_cast<const octave_float_complex_matrix&> (a1);
   const octave_float_complex& v2
     = dynamic_cast<const octave_float_complex&> (a2);
 
-  FloatComplex d = v2.float_complex_value ();
-
-  if (d == 0.0f)
-    warn_divide_by_zero ();
-
-  return octave_value (v1.float_complex_array_value () / d);
+  return octave_value (v1.float_complex_array_value () / v2.float_complex_value ());
 }
 
 DEFBINOP_FN (pow, float_complex_matrix, float_complex, xpow)
 
 DEFBINOP (ldiv, float_complex_matrix, float_complex)
 {
   const octave_float_complex_matrix& v1
     = dynamic_cast<const octave_float_complex_matrix&> (a1);
@@ -96,22 +90,17 @@ DEFNDBINOP_OP (el_mul, float_complex_mat
 
 DEFBINOP (el_div, float_complex_matrix, float_complex)
 {
   const octave_float_complex_matrix& v1
     = dynamic_cast<const octave_float_complex_matrix&> (a1);
   const octave_float_complex& v2
     = dynamic_cast<const octave_float_complex&> (a2);
 
-  FloatComplex d = v2.float_complex_value ();
-
-  if (d == 0.0f)
-    warn_divide_by_zero ();
-
-  return octave_value (v1.float_complex_array_value () / d);
+  return octave_value (v1.float_complex_array_value () / v2.float_complex_value ());
 }
 
 DEFNDBINOP_FN (el_pow, float_complex_matrix, float_complex,
                float_complex_array, float_complex, elem_xpow)
 
 DEFBINOP (el_ldiv, float_complex_matrix, float_complex)
 {
   const octave_float_complex_matrix& v1
diff --git a/libinterp/operators/op-fcm-fs.cc b/libinterp/operators/op-fcm-fs.cc
--- a/libinterp/operators/op-fcm-fs.cc
+++ b/libinterp/operators/op-fcm-fs.cc
@@ -21,17 +21,16 @@ along with Octave; see the file COPYING.
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include "mx-fcnda-fs.h"
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-flt-re-mat.h"
 #include "ov-float.h"
 #include "ov-scalar.h"
 #include "ov-typeinfo.h"
@@ -50,22 +49,17 @@ DEFNDBINOP_OP (mul, float_complex_matrix
 
 DEFBINOP (div, float_complex_matrix, float)
 {
   const octave_float_complex_matrix& v1
     = dynamic_cast<const octave_float_complex_matrix&> (a1);
   const octave_float_scalar& v2
     = dynamic_cast<const octave_float_scalar&> (a2);
 
-  float d = v2.float_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v1.float_complex_array_value () / d);
+  return octave_value (v1.float_complex_array_value () / v2.float_value ());
 }
 
 DEFBINOP_FN (pow, float_complex_matrix, float_scalar, xpow)
 
 DEFBINOP (ldiv, float_complex_matrix, float)
 {
   const octave_float_complex_matrix& v1
     = dynamic_cast<const octave_float_complex_matrix&> (a1);
@@ -100,22 +94,17 @@ DEFNDBINOP_OP (el_mul, float_complex_mat
 
 DEFBINOP (el_div, float_complex_matrix, float)
 {
   const octave_float_complex_matrix& v1
     = dynamic_cast<const octave_float_complex_matrix&> (a1);
   const octave_float_scalar& v2
     = dynamic_cast<const octave_float_scalar&> (a2);
 
-  float d = v2.float_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v1.float_complex_array_value () / d);
+  return octave_value (v1.float_complex_array_value () / v2.float_value ());
 }
 
 DEFNDBINOP_FN (el_pow, float_complex_matrix, float_scalar, float_complex_array,
                float_scalar, elem_xpow)
 
 DEFBINOP (el_ldiv, float_complex_matrix, float)
 {
   const octave_float_complex_matrix& v1
diff --git a/libinterp/operators/op-fcs-fcm.cc b/libinterp/operators/op-fcs-fcm.cc
--- a/libinterp/operators/op-fcs-fcm.cc
+++ b/libinterp/operators/op-fcs-fcm.cc
@@ -19,17 +19,16 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-complex.h"
 #include "ov-flt-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
@@ -66,22 +65,17 @@ DEFBINOP_FN (pow, float_complex, float_c
 
 DEFBINOP (ldiv, float_complex, float_complex_matrix)
 {
   const octave_float_complex& v1
     = dynamic_cast<const octave_float_complex&> (a1);
   const octave_float_complex_matrix& v2
     = dynamic_cast<const octave_float_complex_matrix&> (a2);
 
-  FloatComplex d = v1.float_complex_value ();
-
-  if (d == 0.0f)
-    warn_divide_by_zero ();
-
-  return octave_value (v2.float_complex_array_value () / d);
+  return octave_value (v2.float_complex_array_value () / v1.float_complex_value ());
 }
 
 DEFNDCMPLXCMPOP_FN (lt, float_complex, float_complex_matrix, float_complex,
                     float_complex_array, mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, float_complex, float_complex_matrix, float_complex,
                     float_complex_array, mx_el_le)
 DEFNDCMPLXCMPOP_FN (eq, float_complex, float_complex_matrix, float_complex,
                     float_complex_array, mx_el_eq)
@@ -101,22 +95,17 @@ DEFNDBINOP_FN (el_pow, float_complex, fl
 
 DEFBINOP (el_ldiv, float_complex, float_complex_matrix)
 {
   const octave_float_complex& v1
     = dynamic_cast<const octave_float_complex&> (a1);
   const octave_float_complex_matrix& v2
     = dynamic_cast<const octave_float_complex_matrix&> (a2);
 
-  FloatComplex d = v1.float_complex_value ();
-
-  if (d == 0.0f)
-    warn_divide_by_zero ();
-
-  return octave_value (v2.float_complex_array_value () / d);
+  return octave_value (v2.float_complex_array_value () / v1.float_complex_value ());
 }
 
 DEFNDBINOP_FN (el_and, float_complex, float_complex_matrix, float_complex,
                float_complex_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_complex, float_complex_matrix, float_complex,
                float_complex_array, mx_el_or)
 
 DEFNDCATOP_FN (fcs_fcm, float_complex, float_complex_matrix,
diff --git a/libinterp/operators/op-fcs-fcs.cc b/libinterp/operators/op-fcs-fcs.cc
--- a/libinterp/operators/op-fcs-fcs.cc
+++ b/libinterp/operators/op-fcs-fcs.cc
@@ -19,17 +19,16 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-complex.h"
 #include "ov-flt-complex.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-typeinfo.h"
 #include "ov-null-mat.h"
 #include "ops.h"
@@ -68,74 +67,54 @@ DEFBINOP_OP (add, float_complex, float_c
 DEFBINOP_OP (sub, float_complex, float_complex, -)
 DEFBINOP_OP (mul, float_complex, float_complex, *)
 
 DEFBINOP (div, float_complex, float_complex)
 {
   const octave_float_complex& v1 = dynamic_cast<const octave_float_complex&> (a1);
   const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
 
-  FloatComplex d = v2.float_complex_value ();
-
-  if (d == 0.0f)
-    warn_divide_by_zero ();
-
-  return octave_value (v1.float_complex_value () / d);
+  return octave_value (v1.float_complex_value () / v2.float_complex_value ());
 }
 
 DEFBINOP_FN (pow, float_complex, float_complex, xpow)
 
 DEFBINOP (ldiv, float_complex, float_complex)
 {
   const octave_float_complex& v1 = dynamic_cast<const octave_float_complex&> (a1);
   const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
 
-  FloatComplex d = v1.float_complex_value ();
-
-  if (d == 0.0f)
-    warn_divide_by_zero ();
-
-  return octave_value (v2.float_complex_value () / d);
+  return octave_value (v2.float_complex_value () / v1.float_complex_value ());
 }
 
 DEFCMPLXCMPOP_OP (lt, float_complex, float_complex, <)
 DEFCMPLXCMPOP_OP (le, float_complex, float_complex, <=)
 DEFCMPLXCMPOP_OP (eq, float_complex, float_complex, ==)
 DEFCMPLXCMPOP_OP (ge, float_complex, float_complex, >=)
 DEFCMPLXCMPOP_OP (gt, float_complex, float_complex, >)
 DEFCMPLXCMPOP_OP (ne, float_complex, float_complex, !=)
 
 DEFBINOP_OP (el_mul, float_complex, float_complex, *)
 
 DEFBINOP (el_div, float_complex, float_complex)
 {
   const octave_float_complex& v1 = dynamic_cast<const octave_float_complex&> (a1);
   const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
 
-  FloatComplex d = v2.float_complex_value ();
-
-  if (d == 0.0f)
-    warn_divide_by_zero ();
-
-  return octave_value (v1.float_complex_value () / d);
+  return octave_value (v1.float_complex_value () / v2.float_complex_value ());
 }
 
 DEFBINOP_FN (el_pow, float_complex, float_complex, xpow)
 
 DEFBINOP (el_ldiv, float_complex, float_complex)
 {
   const octave_float_complex& v1 = dynamic_cast<const octave_float_complex&> (a1);
   const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
 
-  FloatComplex d = v1.float_complex_value ();
-
-  if (d == 0.0f)
-    warn_divide_by_zero ();
-
-  return octave_value (v2.float_complex_value () / d);
+  return octave_value (v2.float_complex_value () / v1.float_complex_value ());
 }
 
 DEFBINOP (el_and, float_complex, float_complex)
 {
   const octave_float_complex& v1 = dynamic_cast<const octave_float_complex&> (a1);
   const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
 
   return (v1.float_complex_value () != 0.0f
diff --git a/libinterp/operators/op-fcs-fm.cc b/libinterp/operators/op-fcs-fm.cc
--- a/libinterp/operators/op-fcs-fm.cc
+++ b/libinterp/operators/op-fcs-fm.cc
@@ -22,17 +22,16 @@ along with Octave; see the file COPYING.
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include "mx-fcs-fnda.h"
 #include "mx-fnda-fcs.h"
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-complex.h"
 #include "ov-flt-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-flt-re-mat.h"
 #include "ov-re-mat.h"
@@ -64,22 +63,17 @@ DEFBINOP (div, float_complex, float_matr
 
 DEFBINOP_FN (pow, float_complex, float_matrix, xpow)
 
 DEFBINOP (ldiv, float_complex, float_matrix)
 {
   const octave_float_complex& v1 = dynamic_cast<const octave_float_complex&> (a1);
   const octave_float_matrix& v2 = dynamic_cast<const octave_float_matrix&> (a2);
 
-  FloatComplex d = v1.float_complex_value ();
-
-  if (d == 0.0f)
-    warn_divide_by_zero ();
-
-  return octave_value (v2.float_array_value () / d);
+  return octave_value (v2.float_array_value () / v1.float_complex_value ());
 }
 
 DEFNDCMPLXCMPOP_FN (lt, float_complex, float_matrix, float_complex,
                     float_array, mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, float_complex, float_matrix, float_complex,
                     float_array, mx_el_le)
 DEFNDCMPLXCMPOP_FN (eq, float_complex, float_matrix, float_complex,
                     float_array, mx_el_eq)
@@ -97,22 +91,17 @@ DEFNDBINOP_FN (el_div, float_complex, fl
 DEFNDBINOP_FN (el_pow, float_complex, float_matrix, float_complex,
                float_array, elem_xpow)
 
 DEFBINOP (el_ldiv, float_complex, float_matrix)
 {
   const octave_float_complex& v1 = dynamic_cast<const octave_float_complex&> (a1);
   const octave_float_matrix& v2 = dynamic_cast<const octave_float_matrix&> (a2);
 
-  FloatComplex d = v1.float_complex_value ();
-
-  if (d == 0.0f)
-    warn_divide_by_zero ();
-
-  return octave_value (v2.float_array_value () / d);
+  return octave_value (v2.float_array_value () / v1.float_complex_value ());
 }
 
 DEFNDBINOP_FN (el_and, float_complex, float_matrix, float_complex,
                float_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_complex, float_matrix, float_complex,
                float_array, mx_el_or)
 
 DEFNDCATOP_FN (fcs_fm, float_complex, float_matrix, float_complex_array,
diff --git a/libinterp/operators/op-fcs-fs.cc b/libinterp/operators/op-fcs-fs.cc
--- a/libinterp/operators/op-fcs-fs.cc
+++ b/libinterp/operators/op-fcs-fs.cc
@@ -19,17 +19,16 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-complex.h"
 #include "ov-flt-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-float.h"
 #include "ov-scalar.h"
@@ -44,74 +43,54 @@ DEFBINOP_OP (add, float_complex, float_s
 DEFBINOP_OP (sub, float_complex, float_scalar, -)
 DEFBINOP_OP (mul, float_complex, float_scalar, *)
 
 DEFBINOP (div, float_complex, float)
 {
   const octave_float_complex& v1 = dynamic_cast<const octave_float_complex&> (a1);
   const octave_float_scalar& v2 = dynamic_cast<const octave_float_scalar&> (a2);
 
-  float d = v2.float_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v1.float_complex_value () / d);
+  return octave_value (v1.float_complex_value () / v2.float_value ());
 }
 
 DEFBINOP_FN (pow, float_complex, float_scalar, xpow)
 
 DEFBINOP (ldiv, float_complex, float)
 {
   const octave_float_complex& v1 = dynamic_cast<const octave_float_complex&> (a1);
   const octave_float_scalar& v2 = dynamic_cast<const octave_float_scalar&> (a2);
 
-  FloatComplex d = v1.float_complex_value ();
-
-  if (d == 0.0f)
-    warn_divide_by_zero ();
-
-  return octave_value (v2.float_value () / d);
+  return octave_value (v2.float_value () / v1.float_complex_value ());
 }
 
 DEFCMPLXCMPOP_OP (lt, float_complex, float_scalar, <)
 DEFCMPLXCMPOP_OP (le, float_complex, float_scalar, <=)
 DEFCMPLXCMPOP_OP (eq, float_complex, float_scalar, ==)
 DEFCMPLXCMPOP_OP (ge, float_complex, float_scalar, >=)
 DEFCMPLXCMPOP_OP (gt, float_complex, float_scalar, >)
 DEFCMPLXCMPOP_OP (ne, float_complex, float_scalar, !=)
 
 DEFBINOP_OP (el_mul, float_complex, float_scalar, *)
 
 DEFBINOP (el_div, float_complex, float)
 {
   const octave_float_complex& v1 = dynamic_cast<const octave_float_complex&> (a1);
   const octave_float_scalar& v2 = dynamic_cast<const octave_float_scalar&> (a2);
 
-  float d = v2.float_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v1.float_complex_value () / d);
+  return octave_value (v1.float_complex_value () / v2.float_value ());
 }
 
 DEFBINOP_FN (el_pow, float_complex, float_scalar, xpow)
 
 DEFBINOP (el_ldiv, float_complex, float)
 {
   const octave_float_complex& v1 = dynamic_cast<const octave_float_complex&> (a1);
   const octave_float_scalar& v2 = dynamic_cast<const octave_float_scalar&> (a2);
 
-  FloatComplex d = v1.float_complex_value ();
-
-  if (d == 0.0f)
-    warn_divide_by_zero ();
-
-  return octave_value (v2.float_value () / d);
+  return octave_value (v2.float_value () / v1.float_complex_value ());
 }
 
 DEFBINOP (el_and, float_complex, float)
 {
   const octave_float_complex& v1 = dynamic_cast<const octave_float_complex&> (a1);
   const octave_float_scalar& v2 = dynamic_cast<const octave_float_scalar&> (a2);
 
   return (v1.float_complex_value () != 0.0f && v2.float_value ());
diff --git a/libinterp/operators/op-fm-fcs.cc b/libinterp/operators/op-fm-fcs.cc
--- a/libinterp/operators/op-fm-fcs.cc
+++ b/libinterp/operators/op-fm-fcs.cc
@@ -24,17 +24,16 @@ along with Octave; see the file COPYING.
 #  include "config.h"
 #endif
 
 #include "mx-fm-fcs.h"
 #include "mx-fcs-fm.h"
 #include "mx-fnda-fcs.h"
 #include "mx-fcs-fnda.h"
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-re-mat.h"
 #include "ov-flt-re-mat.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-flt-complex.h"
 #include "ov-complex.h"
@@ -49,22 +48,17 @@ DEFNDBINOP_OP (add, float_matrix, float_
 DEFNDBINOP_OP (sub, float_matrix, float_complex, float_array, float_complex, -)
 DEFNDBINOP_OP (mul, float_matrix, float_complex, float_array, float_complex, *)
 
 DEFBINOP (div, float_matrix, float_complex)
 {
   const octave_float_matrix& v1 = dynamic_cast<const octave_float_matrix&> (a1);
   const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
 
-  FloatComplex d = v2.float_complex_value ();
-
-  if (d == 0.0f)
-    warn_divide_by_zero ();
-
-  return octave_value (v1.float_array_value () / d);
+  return octave_value (v1.float_array_value () / v2.float_complex_value ());
 }
 
 DEFBINOP_FN (pow, float_matrix, float_complex, xpow)
 
 DEFBINOP (ldiv, float_matrix, float_complex)
 {
   const octave_float_matrix& v1 = dynamic_cast<const octave_float_matrix&> (a1);
   const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
@@ -95,22 +89,17 @@ DEFNDCMPLXCMPOP_FN (ne, float_matrix, fl
 DEFNDBINOP_OP (el_mul, float_matrix, float_complex, float_array,
                float_complex, *)
 
 DEFBINOP (el_div, float_matrix, float_complex)
 {
   const octave_float_matrix& v1 = dynamic_cast<const octave_float_matrix&> (a1);
   const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
 
-  FloatComplex d = v2.float_complex_value ();
-
-  if (d == 0.0f)
-    warn_divide_by_zero ();
-
-  return octave_value (v1.float_array_value () / d);
+  return octave_value (v1.float_array_value () / v2.float_complex_value ());
 }
 
 DEFNDBINOP_FN (el_pow, float_matrix, float_complex, float_array,
                float_complex, elem_xpow)
 
 DEFBINOP (el_ldiv, float_matrix, flaot_complex)
 {
   const octave_float_matrix& v1 = dynamic_cast<const octave_float_matrix&> (a1);
diff --git a/libinterp/operators/op-fm-fs.cc b/libinterp/operators/op-fm-fs.cc
--- a/libinterp/operators/op-fm-fs.cc
+++ b/libinterp/operators/op-fm-fs.cc
@@ -19,17 +19,16 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-flt-re-mat.h"
 #include "ov-float.h"
 #include "ov-scalar.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
@@ -41,22 +40,17 @@ DEFNDBINOP_OP (add, float_matrix, float_
 DEFNDBINOP_OP (sub, float_matrix, float_scalar, float_array, float_scalar, -)
 DEFNDBINOP_OP (mul, float_matrix, float_scalar, float_array, float_scalar, *)
 
 DEFBINOP (div, float_matrix, float)
 {
   const octave_float_matrix& v1 = dynamic_cast<const octave_float_matrix&> (a1);
   const octave_float_scalar& v2 = dynamic_cast<const octave_float_scalar&> (a2);
 
-  float d = v2.float_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v1.float_array_value () / d);
+  return octave_value (v1.float_array_value () / v2.float_value ());
 }
 
 DEFBINOP_FN (pow, float_matrix, float_scalar, xpow)
 
 DEFBINOP (ldiv, float_matrix, float)
 {
   const octave_float_matrix& v1 = dynamic_cast<const octave_float_matrix&> (a1);
   const octave_float_scalar& v2 = dynamic_cast<const octave_float_scalar&> (a2);
@@ -86,22 +80,17 @@ DEFNDBINOP_FN (ne, float_matrix, float_s
 
 DEFNDBINOP_OP (el_mul, float_matrix, float_scalar, float_array, float_scalar, *)
 
 DEFBINOP (el_div, float_matrix, float)
 {
   const octave_float_matrix& v1 = dynamic_cast<const octave_float_matrix&> (a1);
   const octave_float_scalar& v2 = dynamic_cast<const octave_float_scalar&> (a2);
 
-  float d = v2.float_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v1.float_array_value () / d);
+  return octave_value (v1.float_array_value () / v2.float_value ());
 }
 
 DEFNDBINOP_FN (el_pow, float_matrix, float_scalar, float_array,
                float_scalar, elem_xpow)
 
 DEFBINOP (el_ldiv, float_matrix, float)
 {
   const octave_float_matrix& v1 = dynamic_cast<const octave_float_matrix&> (a1);
diff --git a/libinterp/operators/op-fs-fcm.cc b/libinterp/operators/op-fs-fcm.cc
--- a/libinterp/operators/op-fs-fcm.cc
+++ b/libinterp/operators/op-fs-fcm.cc
@@ -24,17 +24,16 @@ along with Octave; see the file COPYING.
 #  include "config.h"
 #endif
 
 #include "mx-fs-fcm.h"
 #include "mx-fcm-fs.h"
 #include "mx-fs-fcnda.h"
 #include "mx-fcnda-fs.h"
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-scalar.h"
 #include "ov-float.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-flt-re-mat.h"
 #include "ov-typeinfo.h"
@@ -72,22 +71,17 @@ DEFBINOP_FN (pow, float_scalar, float_co
 
 DEFBINOP (ldiv, float_scalar, float_complex_matrix)
 {
   const octave_float_scalar& v1
     = dynamic_cast<const octave_float_scalar&> (a1);
   const octave_float_complex_matrix& v2
     = dynamic_cast<const octave_float_complex_matrix&> (a2);
 
-  float d = v1.float_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v2.float_complex_array_value () / d);
+  return octave_value (v2.float_complex_array_value () / v1.float_value ());
 }
 
 DEFNDCMPLXCMPOP_FN (lt, float_scalar, float_complex_matrix, float_scalar,
                     float_complex_array, mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, float_scalar, float_complex_matrix, float_scalar,
                     float_complex_array, mx_el_le)
 DEFNDCMPLXCMPOP_FN (eq, float_scalar, float_complex_matrix, float_scalar,
                     float_complex_array, mx_el_eq)
@@ -107,22 +101,17 @@ DEFNDBINOP_FN (el_pow, float_scalar, flo
 
 DEFBINOP (el_ldiv, float_scalar, float_complex_matrix)
 {
   const octave_float_scalar& v1
     = dynamic_cast<const octave_float_scalar&> (a1);
   const octave_float_complex_matrix& v2
     = dynamic_cast<const octave_float_complex_matrix&> (a2);
 
-  float d = v1.float_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v2.float_complex_array_value () / d);
+  return octave_value (v2.float_complex_array_value () / v1.float_value ());
 }
 
 DEFNDBINOP_FN (el_and, float_scalar, float_complex_matrix, float_scalar,
                float_complex_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_scalar, float_complex_matrix, float_scalar,
                float_complex_array, mx_el_or)
 
 DEFNDCATOP_FN (fs_fcm, float_scalar, float_complex_matrix, float_array,
diff --git a/libinterp/operators/op-fs-fcs.cc b/libinterp/operators/op-fs-fcs.cc
--- a/libinterp/operators/op-fs-fcs.cc
+++ b/libinterp/operators/op-fs-fcs.cc
@@ -19,17 +19,16 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-scalar.h"
 #include "ov-float.h"
 #include "ov-flt-complex.h"
 #include "ov-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
@@ -44,74 +43,54 @@ DEFBINOP_OP (add, float_scalar, float_co
 DEFBINOP_OP (sub, float_scalar, float_complex, -)
 DEFBINOP_OP (mul, float_scalar, float_complex, *)
 
 DEFBINOP (div, float_scalar, float_complex)
 {
   const octave_float_scalar& v1 = dynamic_cast<const octave_float_scalar&> (a1);
   const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
 
-  FloatComplex d = v2.float_complex_value ();
-
-  if (d == 0.0f)
-    warn_divide_by_zero ();
-
-  return octave_value (v1.float_value () / d);
+  return octave_value (v1.float_value () / v2.float_complex_value ());
 }
 
 DEFBINOP_FN (pow, float_scalar, float_complex, xpow)
 
 DEFBINOP (ldiv, float_scalar, float_complex)
 {
   const octave_float_scalar& v1 = dynamic_cast<const octave_float_scalar&> (a1);
   const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
 
-  float d = v1.float_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v2.float_complex_value () / d);
+  return octave_value (v2.float_complex_value () / v1.float_value ());
 }
 
 DEFCMPLXCMPOP_OP (lt, float_scalar, float_complex, <)
 DEFCMPLXCMPOP_OP (le, float_scalar, float_complex, <=)
 DEFCMPLXCMPOP_OP (eq, float_scalar, float_complex, ==)
 DEFCMPLXCMPOP_OP (ge, float_scalar, float_complex, >=)
 DEFCMPLXCMPOP_OP (gt, float_scalar, float_complex, >)
 DEFCMPLXCMPOP_OP (ne, float_scalar, float_complex, !=)
 
 DEFBINOP_OP (el_mul, float_scalar, float_complex, *)
 
 DEFBINOP (el_div, float_scalar, float_complex)
 {
   const octave_float_scalar& v1 = dynamic_cast<const octave_float_scalar&> (a1);
   const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
 
-  FloatComplex d = v2.float_complex_value ();
-
-  if (d == 0.0f)
-    warn_divide_by_zero ();
-
-  return octave_value (v1.float_value () / d);
+  return octave_value (v1.float_value () / v2.float_complex_value ());
 }
 
 DEFBINOP_FN (el_pow, float_scalar, float_complex, xpow)
 
 DEFBINOP (el_ldiv, float_scalar, float_complex)
 {
   const octave_float_scalar& v1 = dynamic_cast<const octave_float_scalar&> (a1);
   const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
 
-  float d = v1.float_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v2.float_complex_value () / d);
+  return octave_value (v2.float_complex_value () / v1.float_value ());
 }
 
 DEFBINOP (el_and, float_scalar, float_complex)
 {
   const octave_float_scalar& v1 = dynamic_cast<const octave_float_scalar&> (a1);
   const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
 
   return octave_value (v1.float_scalar_value ()
diff --git a/libinterp/operators/op-fs-fm.cc b/libinterp/operators/op-fs-fm.cc
--- a/libinterp/operators/op-fs-fm.cc
+++ b/libinterp/operators/op-fs-fm.cc
@@ -19,17 +19,16 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-scalar.h"
 #include "ov-float.h"
 #include "ov-re-mat.h"
 #include "ov-flt-re-mat.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
@@ -59,22 +58,17 @@ DEFBINOP (div, float_scalar, float_matri
 
 DEFBINOP_FN (pow, float_scalar, float_matrix, xpow)
 
 DEFBINOP (ldiv, float_scalar, float_matrix)
 {
   const octave_float_scalar& v1 = dynamic_cast<const octave_float_scalar&> (a1);
   const octave_float_matrix& v2 = dynamic_cast<const octave_float_matrix&> (a2);
 
-  float d = v1.float_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v2.float_array_value () / d);
+  return octave_value (v2.float_array_value () / v1.float_value ());
 }
 
 DEFNDBINOP_FN (lt, float_scalar, float_matrix, float_scalar,
                float_array, mx_el_lt)
 DEFNDBINOP_FN (le, float_scalar, float_matrix, float_scalar,
                float_array, mx_el_le)
 DEFNDBINOP_FN (eq, float_scalar, float_matrix, float_scalar,
                float_array, mx_el_eq)
@@ -92,22 +86,17 @@ DEFNDBINOP_FN (el_div, float_scalar, flo
 DEFNDBINOP_FN (el_pow, float_scalar, float_matrix, float_scalar,
                float_array, elem_xpow)
 
 DEFBINOP (el_ldiv, float_scalar, float_matrix)
 {
   const octave_float_scalar& v1 = dynamic_cast<const octave_float_scalar&> (a1);
   const octave_float_matrix& v2 = dynamic_cast<const octave_float_matrix&> (a2);
 
-  float d = v1.float_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v2.float_array_value () / d);
+  return octave_value (v2.float_array_value () / v1.float_value ());
 }
 
 DEFNDBINOP_FN (el_and, float_scalar, float_matrix, float_scalar,
                float_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_scalar, float_matrix, float_scalar,
                float_array, mx_el_or)
 
 DEFNDCATOP_FN (fs_fm, float_scalar, float_matrix, float_array,
diff --git a/libinterp/operators/op-fs-fs.cc b/libinterp/operators/op-fs-fs.cc
--- a/libinterp/operators/op-fs-fs.cc
+++ b/libinterp/operators/op-fs-fs.cc
@@ -21,17 +21,16 @@ along with Octave; see the file COPYING.
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include "Array-util.h"
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-scalar.h"
 #include "ov-float.h"
 #include "ov-flt-re-mat.h"
 #include "ov-typeinfo.h"
 #include "ov-null-mat.h"
 #include "ops.h"
@@ -64,74 +63,54 @@ DEFBINOP_OP (add, float_scalar, float_sc
 DEFBINOP_OP (sub, float_scalar, float_scalar, -)
 DEFBINOP_OP (mul, float_scalar, float_scalar, *)
 
 DEFBINOP (div, float_scalar, float_scalar)
 {
   const octave_float_scalar& v1 = dynamic_cast<const octave_float_scalar&> (a1);
   const octave_float_scalar& v2 = dynamic_cast<const octave_float_scalar&> (a2);
 
-  float d = v2.float_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v1.float_value () / d);
+  return octave_value (v1.float_value () / v2.float_value ());
 }
 
 DEFBINOP_FN (pow, float_scalar, float_scalar, xpow)
 
 DEFBINOP (ldiv, float_scalar, float_scalar)
 {
   const octave_float_scalar& v1 = dynamic_cast<const octave_float_scalar&> (a1);
   const octave_float_scalar& v2 = dynamic_cast<const octave_float_scalar&> (a2);
 
-  float d = v1.float_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v2.float_value () / d);
+  return octave_value (v2.float_value () / v1.float_value ());
 }
 
 DEFBINOP_OP (lt, float_scalar, float_scalar, <)
 DEFBINOP_OP (le, float_scalar, float_scalar, <=)
 DEFBINOP_OP (eq, float_scalar, float_scalar, ==)
 DEFBINOP_OP (ge, float_scalar, float_scalar, >=)
 DEFBINOP_OP (gt, float_scalar, float_scalar, >)
 DEFBINOP_OP (ne, float_scalar, float_scalar, !=)
 
 DEFBINOP_OP (el_mul, float_scalar, float_scalar, *)
 
 DEFBINOP (el_div, float_scalar, float_scalar)
 {
   const octave_float_scalar& v1 = dynamic_cast<const octave_float_scalar&> (a1);
   const octave_float_scalar& v2 = dynamic_cast<const octave_float_scalar&> (a2);
 
-  float d = v2.float_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v1.float_value () / d);
+  return octave_value (v1.float_value () / v2.float_value ());
 }
 
 DEFBINOP_FN (el_pow, float_scalar, float_scalar, xpow)
 
 DEFBINOP (el_ldiv, float_scalar, float_scalar)
 {
   const octave_float_scalar& v1 = dynamic_cast<const octave_float_scalar&> (a1);
   const octave_float_scalar& v2 = dynamic_cast<const octave_float_scalar&> (a2);
 
-  float d = v1.float_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v2.float_value () / d);
+  return octave_value (v2.float_value () / v1.float_value ());
 }
 
 DEFSCALARBOOLOP_OP (el_and, float_scalar, float_scalar, &&)
 DEFSCALARBOOLOP_OP (el_or, float_scalar, float_scalar, ||)
 
 DEFNDCATOP_FN (fs_fs, float_scalar, float_scalar, float_array, float_array,
                concat)
 DEFNDCATOP_FN (s_fs, scalar, float_scalar, float_array, float_array, concat)
diff --git a/libinterp/operators/op-int.h b/libinterp/operators/op-int.h
--- a/libinterp/operators/op-int.h
+++ b/libinterp/operators/op-int.h
@@ -193,63 +193,47 @@ along with Octave; see the file COPYING.
   DEFINTBINOP_OP (PFX ## _sub, T1 ## scalar, T2 ## scalar, -, T3)       \
   DEFINTBINOP_OP (PFX ## _mul, T1 ## scalar, T2 ## scalar, *, T3)       \
                                                                         \
   DEFBINOP (PFX ## _div, T1 ## scalar, T2 ## scalar)                    \
   {                                                                     \
     const octave_ ## T1 ## scalar& v1 = dynamic_cast<const octave_ ## T1 ## scalar&> (a1); \
     const octave_ ## T2 ## scalar& v2 = dynamic_cast<const octave_ ## T2 ## scalar&> (a2); \
                                                                         \
-    if (! v2.T2 ## scalar_value ())                                     \
-      warn_divide_by_zero ();                                           \
-                                                                        \
-    octave_value retval = octave_value (v1.T1 ## scalar_value () / v2.T2 ## scalar_value ()); \
-    return retval;                                                      \
+    return octave_value (v1.T1 ## scalar_value () / v2.T2 ## scalar_value ()); \
   }                                                                     \
                                                                         \
   DEFINTBINOP_FN (PFX ## _pow, T1 ## scalar, T2 ## scalar, xpow, T3, ^) \
                                                                         \
   DEFBINOP (PFX ## _ldiv, T1 ## scalar, T2 ## scalar)                   \
   {                                                                     \
     const octave_ ## T1 ## scalar& v1 = dynamic_cast<const octave_ ## T1 ## scalar&> (a1); \
     const octave_ ## T2 ## scalar& v2 = dynamic_cast<const octave_ ## T2 ## scalar&> (a2); \
                                                                         \
-    if (! v1.T1 ## scalar_value ())                                     \
-      warn_divide_by_zero ();                                           \
-                                                                        \
-    octave_value retval = octave_value (v2.T2 ## scalar_value () / v1.T1 ## scalar_value ()); \
-    return retval;                                                      \
+    return octave_value (v2.T2 ## scalar_value () / v1.T1 ## scalar_value ()); \
   }                                                                     \
                                                                         \
   DEFINTBINOP_OP (PFX ## _el_mul, T1 ## scalar, T2 ## scalar, *, T3)    \
                                                                         \
   DEFBINOP (PFX ## _el_div, T1 ## scalar, T2 ## scalar)                 \
   {                                                                     \
     const octave_ ## T1 ## scalar& v1 = dynamic_cast<const octave_ ## T1 ## scalar&> (a1); \
     const octave_ ## T2 ## scalar& v2 = dynamic_cast<const octave_ ## T2 ## scalar&> (a2); \
                                                                         \
-    if (! v2.T2 ## scalar_value ())                                     \
-      warn_divide_by_zero ();                                           \
-                                                                        \
-    octave_value retval = octave_value (v1.T1 ## scalar_value () / v2.T2 ## scalar_value ()); \
-    return retval;                                                      \
+    return octave_value (v1.T1 ## scalar_value () / v2.T2 ## scalar_value ()); \
   }                                                                     \
                                                                         \
   DEFINTBINOP_FN (PFX ## _el_pow, T1 ## scalar, T2 ## scalar, xpow, T3, .^) \
                                                                         \
   DEFBINOP (PFX ## _el_ldiv, T1 ## scalar, T2 ## scalar)                \
   {                                                                     \
     const octave_ ## T1 ## scalar& v1 = dynamic_cast<const octave_ ## T1 ## scalar&> (a1); \
     const octave_ ## T2 ## scalar& v2 = dynamic_cast<const octave_ ## T2 ## scalar&> (a2); \
                                                                         \
-    if (! v1.T1 ## scalar_value ())                                     \
-      warn_divide_by_zero ();                                           \
-                                                                        \
-    octave_value retval = octave_value (v2.T2 ## scalar_value () / v1.T1 ## scalar_value ()); \
-    return retval;                                                      \
+    return octave_value (v2.T2 ## scalar_value () / v1.T1 ## scalar_value ()); \
   }
 
 #define OCTAVE_SS_INT_BOOL_OPS(PFX, T1, T2, Z1, Z2)                     \
   DEFBINOP (PFX ## _el_and, T2, T2)                                     \
   {                                                                     \
     const octave_ ## T1 ## scalar& v1 = dynamic_cast<const octave_ ## T1 ## scalar&> (a1); \
     const octave_ ## T2 ## scalar& v2 = dynamic_cast<const octave_ ## T2 ## scalar&> (a2); \
                                                                         \
@@ -342,21 +326,17 @@ along with Octave; see the file COPYING.
                                                                         \
   /* DEFBINOP_FN (PFX ## _pow, TS ## scalar, TM ## matrix, xpow) */     \
                                                                         \
   DEFBINOP (PFX ## _ldiv, TS ## scalar, TM ## matrix)                   \
   {                                                                     \
    const octave_ ## TS ## scalar& v1 = dynamic_cast<const octave_ ## TS ## scalar&> (a1); \
    const octave_ ## TM ## matrix& v2 = dynamic_cast<const octave_ ## TM ## matrix&> (a2); \
                                                                         \
-   if (! v1.TS ## scalar_value ())                                      \
-     warn_divide_by_zero ();                                            \
-                                                                        \
-   octave_value retval = octave_value (v2.TM ## array_value () / v1.TS ## scalar_value ()); \
-   return retval;                                                       \
+   return octave_value (v2.TM ## array_value () / v1.TS ## scalar_value ()); \
    }                                                                    \
                                                                         \
   DEFINTNDBINOP_OP (PFX ## _el_mul, TS ## scalar, TM ## matrix, TS ## scalar, TM ## array, *, TI) \
   DEFBINOP (PFX ## _el_div, TS ## scalar, TM ## matrix)                 \
   {                                                                     \
    const octave_ ## TS ## scalar& v1 = dynamic_cast<const octave_ ## TS ## scalar&> (a1); \
    const octave_ ## TM ## matrix& v2 = dynamic_cast<const octave_ ## TM ## matrix&> (a2); \
                                                                         \
@@ -366,21 +346,17 @@ along with Octave; see the file COPYING.
                                                                         \
   DEFINTNDBINOP_FN (PFX ## _el_pow, TS ## scalar, TM ## matrix, TS ## scalar, TM ## array, elem_xpow, TI, .^) \
                                                                         \
   DEFBINOP (PFX ## _el_ldiv, TS ## scalar, TM ## matrix)                \
   {                                                                     \
    const octave_ ## TS ## scalar& v1 = dynamic_cast<const octave_ ## TS ## scalar&> (a1); \
    const octave_ ## TM ## matrix& v2 = dynamic_cast<const octave_ ## TM ## matrix&> (a2); \
                                                                         \
-   if (! v1.TS ## scalar_value ())                                      \
-     warn_divide_by_zero ();                                            \
-                                                                        \
-   octave_value retval = octave_value (v2.TM ## array_value () / v1.TS ## scalar_value ()); \
-   return retval;                                                       \
+   return octave_value (v2.TM ## array_value () / v1.TS ## scalar_value ()); \
    }
 
 #define OCTAVE_SM_INT_CMP_OPS(PFX, TS, TM)                              \
   DEFNDBINOP_FN (PFX ## _lt, TS ## scalar, TM ## matrix, TS ## scalar, TM ## array, mx_el_lt) \
   DEFNDBINOP_FN (PFX ## _le, TS ## scalar, TM ## matrix, TS ## scalar, TM ## array, mx_el_le) \
   DEFNDBINOP_FN (PFX ## _eq, TS ## scalar, TM ## matrix, TS ## scalar, TM ## array, mx_el_eq) \
   DEFNDBINOP_FN (PFX ## _ge, TS ## scalar, TM ## matrix, TS ## scalar, TM ## array, mx_el_ge) \
   DEFNDBINOP_FN (PFX ## _gt, TS ## scalar, TM ## matrix, TS ## scalar, TM ## array, mx_el_gt) \
@@ -489,21 +465,17 @@ along with Octave; see the file COPYING.
   DEFINTNDBINOP_OP (PFX ## _sub, TM ## matrix, TS ## scalar, TM ## array, TS ## scalar, -, TI) \
   DEFINTNDBINOP_OP (PFX ## _mul, TM ## matrix, TS ## scalar, TM ## array, TS ## scalar, *, TI) \
                                                                         \
   DEFBINOP (PFX ## _div, TM ## matrix, TS ## scalar)                    \
   {                                                                     \
     const octave_ ## TM ## matrix& v1 = dynamic_cast<const octave_ ## TM ## matrix&> (a1); \
     const octave_ ## TS ## scalar& v2 = dynamic_cast<const octave_ ## TS ## scalar&> (a2); \
                                                                         \
-    if (! v2.TS ## scalar_value ())                                     \
-      warn_divide_by_zero ();                                           \
-                                                                        \
-    octave_value retval = octave_value (v1.TM ## array_value () / v2.TS ## scalar_value ()); \
-    return retval;                                                      \
+    return octave_value (v1.TM ## array_value () / v2.TS ## scalar_value ()); \
   }                                                                     \
                                                                         \
   /* DEFBINOP_FN (PFX ## _pow, TM ## matrix, TS ## scalar, xpow) */     \
                                                                         \
   /* DEFBINOP (PFX ## _ldiv, TM ## matrix, TS ## scalar) */             \
   /* { */                                                               \
   /* const octave_ ## TM ## matrix& v1 = dynamic_cast<const octave_ ## TM ## matrix&> (a1); */ \
   /* const octave_ ## TS ## scalar& v2 = dynamic_cast<const octave_ ## TS ## scalar&> (a2); */ \
@@ -516,21 +488,17 @@ along with Octave; see the file COPYING.
                                                                         \
   DEFINTNDBINOP_OP (PFX ## _el_mul, TM ## matrix, TS ## scalar, TM ## array, TS ## scalar, *, TI) \
                                                                         \
   DEFBINOP (PFX ## _el_div, TM ## matrix, TS ## scalar)                 \
   {                                                                     \
     const octave_ ## TM ## matrix& v1 = dynamic_cast<const octave_ ## TM ## matrix&> (a1); \
     const octave_ ## TS ## scalar& v2 = dynamic_cast<const octave_ ## TS ## scalar&> (a2); \
                                                                         \
-    if (! v2.TS ## scalar_value ())                                     \
-      warn_divide_by_zero ();                                           \
-                                                                        \
-    octave_value retval = octave_value (v1.TM ## array_value () / v2.TS ## scalar_value ()); \
-    return retval;                                                      \
+    return octave_value (v1.TM ## array_value () / v2.TS ## scalar_value ()); \
   }                                                                     \
                                                                         \
   DEFINTNDBINOP_FN (PFX ## _el_pow, TM ## matrix, TS ## scalar, TM ## array, TS ## scalar, elem_xpow, TI, .^) \
                                                                         \
   DEFBINOP (PFX ## _el_ldiv, TM ## matrix, TS ## scalar)                \
   {                                                                     \
     const octave_ ## TM ## matrix& v1 = dynamic_cast<const octave_ ## TM ## matrix&> (a1); \
     const octave_ ## TS ## scalar& v2 = dynamic_cast<const octave_ ## TS ## scalar&> (a2); \
diff --git a/libinterp/operators/op-m-cs.cc b/libinterp/operators/op-m-cs.cc
--- a/libinterp/operators/op-m-cs.cc
+++ b/libinterp/operators/op-m-cs.cc
@@ -24,17 +24,16 @@ along with Octave; see the file COPYING.
 #  include "config.h"
 #endif
 
 #include "mx-m-cs.h"
 #include "mx-cs-m.h"
 #include "mx-nda-cs.h"
 #include "mx-cs-nda.h"
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-re-mat.h"
 #include "ov-flt-re-mat.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-complex.h"
 #include "ov-typeinfo.h"
@@ -48,22 +47,17 @@ DEFNDBINOP_OP (add, matrix, complex, arr
 DEFNDBINOP_OP (sub, matrix, complex, array, complex, -)
 DEFNDBINOP_OP (mul, matrix, complex, array, complex, *)
 
 DEFBINOP (div, matrix, complex)
 {
   const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
-  Complex d = v2.complex_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v1.array_value () / d);
+  return octave_value (v1.array_value () / v2.complex_value ());
 }
 
 DEFBINOP_FN (pow, matrix, complex, xpow)
 
 DEFBINOP (ldiv, matrix, complex)
 {
   const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
@@ -87,22 +81,17 @@ DEFNDCMPLXCMPOP_FN (ne, matrix, complex,
 
 DEFNDBINOP_OP (el_mul, matrix, complex, array, complex, *)
 
 DEFBINOP (el_div, matrix, complex)
 {
   const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
-  Complex d = v2.complex_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v1.array_value () / d);
+  return octave_value (v1.array_value () / v2.complex_value ());
 }
 
 DEFNDBINOP_FN (el_pow, matrix, complex, array, complex, elem_xpow)
 
 DEFBINOP (el_ldiv, matrix, complex)
 {
   const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
diff --git a/libinterp/operators/op-m-s.cc b/libinterp/operators/op-m-s.cc
--- a/libinterp/operators/op-m-s.cc
+++ b/libinterp/operators/op-m-s.cc
@@ -19,17 +19,16 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-re-mat.h"
 #include "ov-flt-re-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-scalar.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
@@ -42,22 +41,17 @@ DEFNDBINOP_OP (add, matrix, scalar, arra
 DEFNDBINOP_OP (sub, matrix, scalar, array, scalar, -)
 DEFNDBINOP_OP (mul, matrix, scalar, array, scalar, *)
 
 DEFBINOP (div, matrix, scalar)
 {
   const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
-  double d = v2.double_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v1.array_value () / d);
+  return octave_value (v1.array_value () / v2.double_value ());
 }
 
 DEFBINOP_FN (pow, matrix, scalar, xpow)
 
 DEFBINOP (ldiv, matrix, scalar)
 {
   const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
@@ -81,22 +75,17 @@ DEFNDBINOP_FN (ne, matrix, scalar, array
 
 DEFNDBINOP_OP (el_mul, matrix, scalar, array, scalar, *)
 
 DEFBINOP (el_div, matrix, scalar)
 {
   const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
-  double d = v2.double_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v1.array_value () / d);
+  return octave_value (v1.array_value () / v2.double_value ());
 }
 
 DEFNDBINOP_FN (el_pow, matrix, scalar, array, scalar, elem_xpow)
 
 DEFBINOP (el_ldiv, matrix, scalar)
 {
   const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
diff --git a/libinterp/operators/op-m-scm.cc b/libinterp/operators/op-m-scm.cc
--- a/libinterp/operators/op-m-scm.cc
+++ b/libinterp/operators/op-m-scm.cc
@@ -20,17 +20,16 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-re-mat.h"
 #include "ov-cx-mat.h"
 #include "ops.h"
 #include "xdiv.h"
 
@@ -49,24 +48,17 @@ DEFBINOP_OP (mul, matrix, sparse_complex
 
 DEFBINOP (div, matrix, sparse_complex_matrix)
 {
   const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
   const octave_sparse_complex_matrix& v2
     = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
-    {
-      Complex d = v2.complex_value ();
-
-      if (d == 0.0)
-        warn_divide_by_zero ();
-
-      return octave_value (v1.array_value () / d);
-    }
+    return octave_value (v1.array_value () / v2.complex_value ());
   else
     {
       MatrixType typ = v2.matrix_type ();
 
       ComplexMatrix ret = xdiv (v1.matrix_value (),
                                 v2.sparse_complex_matrix_value (), typ);
 
       v2.matrix_type (typ);
diff --git a/libinterp/operators/op-m-sm.cc b/libinterp/operators/op-m-sm.cc
--- a/libinterp/operators/op-m-sm.cc
+++ b/libinterp/operators/op-m-sm.cc
@@ -20,17 +20,16 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-re-mat.h"
 #include "ops.h"
 #include "xdiv.h"
 
 #include "sparse-xpow.h"
@@ -47,24 +46,17 @@ DEFBINOP_OP (sub, matrix, sparse_matrix,
 DEFBINOP_OP (mul, matrix, sparse_matrix, *)
 
 DEFBINOP (div, matrix, sparse_matrix)
 {
   const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
   const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
-    {
-      double d = v2.scalar_value ();
-
-      if (d == 0.0)
-        warn_divide_by_zero ();
-
-      return octave_value (v1.array_value () / d);
-    }
+    return octave_value (v1.array_value () / v2.scalar_value ());
   else
     {
       MatrixType typ = v2.matrix_type ();
 
       Matrix ret = xdiv (v1.matrix_value (), v2.sparse_matrix_value (), typ);
 
       v2.matrix_type (typ);
       return ret;
diff --git a/libinterp/operators/op-s-cm.cc b/libinterp/operators/op-s-cm.cc
--- a/libinterp/operators/op-s-cm.cc
+++ b/libinterp/operators/op-s-cm.cc
@@ -24,17 +24,16 @@ along with Octave; see the file COPYING.
 #  include "config.h"
 #endif
 
 #include "mx-s-cm.h"
 #include "mx-cm-s.h"
 #include "mx-s-cnda.h"
 #include "mx-cnda-s.h"
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-scalar.h"
 #include "ov-float.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-re-mat.h"
 #include "ov-typeinfo.h"
@@ -67,22 +66,17 @@ DEFBINOP (div, scalar, complex_matrix)
 DEFBINOP_FN (pow, scalar, complex_matrix, xpow)
 
 DEFBINOP (ldiv, scalar, complex_matrix)
 {
   const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
   const octave_complex_matrix& v2
     = dynamic_cast<const octave_complex_matrix&> (a2);
 
-  double d = v1.double_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v2.complex_array_value () / d);
+  return octave_value (v2.complex_array_value () / v1.double_value ());
 }
 
 DEFNDCMPLXCMPOP_FN (lt, scalar, complex_matrix, scalar, complex_array, mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, scalar, complex_matrix, scalar, complex_array, mx_el_le)
 DEFNDCMPLXCMPOP_FN (eq, scalar, complex_matrix, scalar, complex_array, mx_el_eq)
 DEFNDCMPLXCMPOP_FN (ge, scalar, complex_matrix, scalar, complex_array, mx_el_ge)
 DEFNDCMPLXCMPOP_FN (gt, scalar, complex_matrix, scalar, complex_array, mx_el_gt)
 DEFNDCMPLXCMPOP_FN (ne, scalar, complex_matrix, scalar, complex_array, mx_el_ne)
@@ -92,22 +86,17 @@ DEFNDBINOP_FN (el_div, scalar, complex_m
 DEFNDBINOP_FN (el_pow, scalar, complex_matrix, scalar, complex_array, elem_xpow)
 
 DEFBINOP (el_ldiv, scalar, complex_matrix)
 {
   const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
   const octave_complex_matrix& v2
     = dynamic_cast<const octave_complex_matrix&> (a2);
 
-  double d = v1.double_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v2.complex_array_value () / d);
+  return octave_value (v2.complex_array_value () / v1.double_value ());
 }
 
 DEFNDBINOP_FN (el_and, scalar, complex_matrix, scalar, complex_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  scalar, complex_matrix, scalar, complex_array, mx_el_or)
 
 DEFNDCATOP_FN (s_cm, scalar, complex_matrix, array, complex_array, concat)
 
 DEFCONV (complex_matrix_conv, scalar, complex_matrix)
diff --git a/libinterp/operators/op-s-cs.cc b/libinterp/operators/op-s-cs.cc
--- a/libinterp/operators/op-s-cs.cc
+++ b/libinterp/operators/op-s-cs.cc
@@ -19,17 +19,16 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-scalar.h"
 #include "ov-float.h"
 #include "ov-complex.h"
 #include "ov-cx-mat.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-typeinfo.h"
@@ -43,74 +42,54 @@ DEFBINOP_OP (add, scalar, complex, +)
 DEFBINOP_OP (sub, scalar, complex, -)
 DEFBINOP_OP (mul, scalar, complex, *)
 
 DEFBINOP (div, scalar, complex)
 {
   const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
-  Complex d = v2.complex_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v1.double_value () / d);
+  return octave_value (v1.double_value () / v2.complex_value ());
 }
 
 DEFBINOP_FN (pow, scalar, complex, xpow)
 
 DEFBINOP (ldiv, scalar, complex)
 {
   const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
-  double d = v1.double_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v2.complex_value () / d);
+  return octave_value (v2.complex_value () / v1.double_value ());
 }
 
 DEFCMPLXCMPOP_OP (lt, scalar, complex, <)
 DEFCMPLXCMPOP_OP (le, scalar, complex, <=)
 DEFCMPLXCMPOP_OP (eq, scalar, complex, ==)
 DEFCMPLXCMPOP_OP (ge, scalar, complex, >=)
 DEFCMPLXCMPOP_OP (gt, scalar, complex, >)
 DEFCMPLXCMPOP_OP (ne, scalar, complex, !=)
 
 DEFBINOP_OP (el_mul, scalar, complex, *)
 
 DEFBINOP (el_div, scalar, complex)
 {
   const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
-  Complex d = v2.complex_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v1.double_value () / d);
+  return octave_value (v1.double_value () / v2.complex_value ());
 }
 
 DEFBINOP_FN (el_pow, scalar, complex, xpow)
 
 DEFBINOP (el_ldiv, scalar, complex)
 {
   const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
-  double d = v1.double_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v2.complex_value () / d);
+  return octave_value (v2.complex_value () / v1.double_value ());
 }
 
 DEFBINOP (el_and, scalar, complex)
 {
   const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   return octave_value (v1.double_value () && (v2.complex_value () != 0.0));
diff --git a/libinterp/operators/op-s-m.cc b/libinterp/operators/op-s-m.cc
--- a/libinterp/operators/op-s-m.cc
+++ b/libinterp/operators/op-s-m.cc
@@ -19,17 +19,16 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-scalar.h"
 #include "ov-float.h"
 #include "ov-re-mat.h"
 #include "ov-flt-re-mat.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
@@ -59,22 +58,17 @@ DEFBINOP (div, scalar, matrix)
 
 DEFBINOP_FN (pow, scalar, matrix, xpow)
 
 DEFBINOP (ldiv, scalar, matrix)
 {
   const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
   const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
 
-  double d = v1.double_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v2.array_value () / d);
+  return octave_value (v2.array_value () / v1.double_value ());
 }
 
 DEFNDBINOP_FN (lt, scalar, matrix, scalar, array, mx_el_lt)
 DEFNDBINOP_FN (le, scalar, matrix, scalar, array, mx_el_le)
 DEFNDBINOP_FN (eq, scalar, matrix, scalar, array, mx_el_eq)
 DEFNDBINOP_FN (ge, scalar, matrix, scalar, array, mx_el_ge)
 DEFNDBINOP_FN (gt, scalar, matrix, scalar, array, mx_el_gt)
 DEFNDBINOP_FN (ne, scalar, matrix, scalar, array, mx_el_ne)
@@ -83,22 +77,17 @@ DEFNDBINOP_OP (el_mul, scalar, matrix, s
 DEFNDBINOP_FN (el_div, scalar, matrix, scalar, array, x_el_div)
 DEFNDBINOP_FN (el_pow, scalar, matrix, scalar, array, elem_xpow)
 
 DEFBINOP (el_ldiv, scalar, matrix)
 {
   const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
   const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
 
-  double d = v1.double_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v2.array_value () / d);
+  return octave_value (v2.array_value () / v1.double_value ());
 }
 
 DEFNDBINOP_FN (el_and, scalar, matrix, scalar, array, mx_el_and)
 DEFNDBINOP_FN (el_or,  scalar, matrix, scalar, array, mx_el_or)
 
 DEFNDCATOP_FN (s_m, scalar, matrix, array, array, concat)
 
 DEFCONV (matrix_conv, scalar, matrix)
diff --git a/libinterp/operators/op-s-s.cc b/libinterp/operators/op-s-s.cc
--- a/libinterp/operators/op-s-s.cc
+++ b/libinterp/operators/op-s-s.cc
@@ -21,17 +21,16 @@ along with Octave; see the file COPYING.
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include "Array-util.h"
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-scalar.h"
 #include "ov-float.h"
 #include "ov-re-mat.h"
 #include "ov-flt-re-mat.h"
 #include "ov-typeinfo.h"
 #include "ov-null-mat.h"
@@ -65,74 +64,54 @@ DEFBINOP_OP (add, scalar, scalar, +)
 DEFBINOP_OP (sub, scalar, scalar, -)
 DEFBINOP_OP (mul, scalar, scalar, *)
 
 DEFBINOP (div, scalar, scalar)
 {
   const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
-  double d = v2.double_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v1.double_value () / d);
+  return octave_value (v1.double_value () / v2.double_value ());
 }
 
 DEFBINOP_FN (pow, scalar, scalar, xpow)
 
 DEFBINOP (ldiv, scalar, scalar)
 {
   const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
-  double d = v1.double_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v2.double_value () / d);
+  return octave_value (v2.double_value () / v1.double_value ());
 }
 
 DEFBINOP_OP (lt, scalar, scalar, <)
 DEFBINOP_OP (le, scalar, scalar, <=)
 DEFBINOP_OP (eq, scalar, scalar, ==)
 DEFBINOP_OP (ge, scalar, scalar, >=)
 DEFBINOP_OP (gt, scalar, scalar, >)
 DEFBINOP_OP (ne, scalar, scalar, !=)
 
 DEFBINOP_OP (el_mul, scalar, scalar, *)
 
 DEFBINOP (el_div, scalar, scalar)
 {
   const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
-  double d = v2.double_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v1.double_value () / d);
+  return octave_value (v1.double_value () / v2.double_value ());
 }
 
 DEFBINOP_FN (el_pow, scalar, scalar, xpow)
 
 DEFBINOP (el_ldiv, scalar, scalar)
 {
   const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
-  double d = v1.double_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  return octave_value (v2.double_value () / d);
+  return octave_value (v2.double_value () / v1.double_value ());
 }
 
 DEFSCALARBOOLOP_OP (el_and, scalar, scalar, &&)
 DEFSCALARBOOLOP_OP (el_or, scalar, scalar, ||)
 
 DEFNDCATOP_FN (s_s, scalar, scalar, array, array, concat)
 
 void
diff --git a/libinterp/operators/op-s-scm.cc b/libinterp/operators/op-s-scm.cc
--- a/libinterp/operators/op-s-scm.cc
+++ b/libinterp/operators/op-s-scm.cc
@@ -20,17 +20,16 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-cx-mat.h"
 #include "ov-scalar.h"
 #include "ops.h"
 #include "xpow.h"
 
@@ -49,24 +48,18 @@ DEFBINOP_OP (mul, scalar, sparse_complex
 
 DEFBINOP (div, scalar, sparse_complex_matrix)
 {
   const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
   const octave_sparse_complex_matrix& v2
     = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
-    {
-      Complex d = v2.complex_value ();
-
-      if (d == 0.0)
-        warn_divide_by_zero ();
-
-      return octave_value (SparseComplexMatrix (1, 1, v1.scalar_value () / d));
-    }
+    return octave_value (SparseComplexMatrix (1, 1, v1.scalar_value ()
+                                                  / v2.complex_value ()));
   else
     {
       MatrixType typ = v2.matrix_type ();
       Matrix m1 = Matrix (1, 1, v1.scalar_value ());
       SparseComplexMatrix m2 = v2.sparse_complex_matrix_value ();
       ComplexMatrix ret = xdiv (m1, m2, typ);
       v2.matrix_type (typ);
       return ret;
@@ -82,25 +75,17 @@ DEFBINOP (pow, scalar, sparse_complex_ma
 }
 
 DEFBINOP (ldiv, scalar, sparse_complex_matrix)
 {
   const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
   const octave_sparse_complex_matrix& v2
     = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
-  double d = v1.double_value ();
-  octave_value retval;
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  retval = octave_value (v2.sparse_complex_matrix_value () / d);
-
-  return retval;
+  return octave_value (v2.sparse_complex_matrix_value () / v1.double_value ());
 }
 
 DEFBINOP_FN (lt, scalar, sparse_complex_matrix, mx_el_lt)
 DEFBINOP_FN (le, scalar, sparse_complex_matrix, mx_el_le)
 DEFBINOP_FN (eq, scalar, sparse_complex_matrix, mx_el_eq)
 DEFBINOP_FN (ge, scalar, sparse_complex_matrix, mx_el_ge)
 DEFBINOP_FN (gt, scalar, sparse_complex_matrix, mx_el_gt)
 DEFBINOP_FN (ne, scalar, sparse_complex_matrix, mx_el_ne)
@@ -110,25 +95,17 @@ DEFBINOP_FN (el_div, scalar, sparse_comp
 DEFBINOP_FN (el_pow, scalar, sparse_complex_matrix, elem_xpow)
 
 DEFBINOP (el_ldiv, scalar, sparse_complex_matrix)
 {
   const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
   const octave_sparse_complex_matrix& v2
     = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
-  double d = v1.double_value ();
-  octave_value retval;
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  retval = octave_value (v2.sparse_complex_matrix_value () / d);
-
-  return retval;
+  return octave_value (v2.sparse_complex_matrix_value () / v1.double_value ());
 }
 
 DEFBINOP_FN (el_and, scalar, sparse_complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or, scalar, sparse_complex_matrix, mx_el_or)
 
 DEFCATOP (s_scm, scalar, sparse_compelx_matrix)
 {
   octave_scalar& v1 = dynamic_cast<octave_scalar&> (a1);
diff --git a/libinterp/operators/op-s-sm.cc b/libinterp/operators/op-s-sm.cc
--- a/libinterp/operators/op-s-sm.cc
+++ b/libinterp/operators/op-s-sm.cc
@@ -20,17 +20,16 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-scalar.h"
 #include "ops.h"
 #include "xpow.h"
 
 #include "sparse-xpow.h"
@@ -44,24 +43,17 @@ DEFBINOP_OP (sub, scalar, sparse_matrix,
 DEFBINOP_OP (mul, scalar, sparse_matrix, *)
 
 DEFBINOP (div, scalar, sparse_matrix)
 {
   const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
   const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
-    {
-      double d = v2.scalar_value ();
-
-      if (d == 0.0)
-        warn_divide_by_zero ();
-
-      return octave_value (SparseMatrix (1, 1, v1.scalar_value () / d));
-    }
+    return octave_value (SparseMatrix (1, 1, v1.scalar_value () / v2.scalar_value ()));
   else
     {
       MatrixType typ = v2.matrix_type ();
       Matrix m1 = Matrix (1, 1, v1.double_value ());
       SparseMatrix m2 = v2.sparse_matrix_value ();
       Matrix ret = xdiv (m1, m2, typ);
       v2.matrix_type (typ);
       return ret;
@@ -75,25 +67,17 @@ DEFBINOP (pow, scalar, sparse_matrix)
   return xpow (v1.scalar_value (), v2.matrix_value ());
 }
 
 DEFBINOP (ldiv, scalar, sparse_matrix)
 {
   const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
   const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
 
-  double d = v1.double_value ();
-  octave_value retval;
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  retval = octave_value (v2.sparse_matrix_value () / d);
-
-  return retval;
+  return octave_value (v2.sparse_matrix_value () / v1.double_value ());
 }
 
 DEFBINOP_FN (lt, scalar, sparse_matrix, mx_el_lt)
 DEFBINOP_FN (le, scalar, sparse_matrix, mx_el_le)
 DEFBINOP_FN (eq, scalar, sparse_matrix, mx_el_eq)
 DEFBINOP_FN (ge, scalar, sparse_matrix, mx_el_ge)
 DEFBINOP_FN (gt, scalar, sparse_matrix, mx_el_gt)
 DEFBINOP_FN (ne, scalar, sparse_matrix, mx_el_ne)
@@ -102,25 +86,17 @@ DEFBINOP_OP (el_mul, scalar, sparse_matr
 DEFBINOP_FN (el_div, scalar, sparse_matrix, x_el_div)
 DEFBINOP_FN (el_pow, scalar, sparse_matrix, elem_xpow)
 
 DEFBINOP (el_ldiv, scalar, sparse_matrix)
 {
   const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
   const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
 
-  double d = v1.double_value ();
-  octave_value retval;
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  retval = octave_value (v2.sparse_matrix_value () / d);
-
-  return retval;
+  return octave_value (v2.sparse_matrix_value () / v1.double_value ());
 }
 
 DEFBINOP_FN (el_and, scalar, sparse_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  scalar, sparse_matrix, mx_el_or)
 
 DEFCATOP (s_sm, scalar, sparse_matrix)
 {
   octave_scalar& v1 = dynamic_cast<octave_scalar&> (a1);
diff --git a/libinterp/operators/op-scm-cm.cc b/libinterp/operators/op-scm-cm.cc
--- a/libinterp/operators/op-scm-cm.cc
+++ b/libinterp/operators/op-scm-cm.cc
@@ -20,17 +20,16 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-cx-mat.h"
 #include "ops.h"
 #include "xdiv.h"
 
 #include "sparse-xpow.h"
@@ -69,24 +68,17 @@ DEFBINOPX (pow, sparse_complex_matrix, c
 DEFBINOP (ldiv, sparse_complex_matrix, complex_matrix)
 {
   const octave_sparse_complex_matrix& v1
     = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
   const octave_complex_matrix& v2
     = dynamic_cast<const octave_complex_matrix&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
-    {
-      Complex d = v1.complex_value ();
-
-      if (d == 0.0)
-        warn_divide_by_zero ();
-
-      return octave_value (v2.complex_array_value () / d);
-    }
+    return octave_value (v2.complex_array_value () / v1.complex_value ());
   else
     {
       MatrixType typ = v1.matrix_type ();
 
       ComplexMatrix ret = xleftdiv (v1.sparse_complex_matrix_value (),
                                     v2.complex_matrix_value (), typ);
 
       v1.matrix_type (typ);
diff --git a/libinterp/operators/op-scm-cs.cc b/libinterp/operators/op-scm-cs.cc
--- a/libinterp/operators/op-scm-cs.cc
+++ b/libinterp/operators/op-scm-cs.cc
@@ -20,17 +20,16 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-cx-mat.h"
 #include "ov-complex.h"
 #include "ops.h"
 #include "xpow.h"
 
@@ -45,25 +44,17 @@ DEFBINOP_OP (sub, sparse_complex_matrix,
 DEFBINOP_OP (mul, sparse_complex_matrix, complex, *)
 
 DEFBINOP (div, sparse_complex_matrix, complex)
 {
   const octave_sparse_complex_matrix& v1
     = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
-  Complex d = v2.complex_value ();
-  octave_value retval;
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  retval = octave_value (v1.sparse_complex_matrix_value () / d);
-
-  return retval;
+  return octave_value (v1.sparse_complex_matrix_value () / v2.complex_value ());
 }
 
 DEFBINOP (pow, sparse_complex_matrix, complex)
 {
   const octave_sparse_complex_matrix& v1
     = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
   return xpow (v1.complex_matrix_value (), v2.complex_value ());
@@ -71,24 +62,18 @@ DEFBINOP (pow, sparse_complex_matrix, co
 
 DEFBINOP (ldiv, sparse_complex_matrix, complex)
 {
   const octave_sparse_complex_matrix& v1
     = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
-    {
-      Complex d = v1.complex_value ();
-
-      if (d == 0.0)
-        warn_divide_by_zero ();
-
-      return octave_value (SparseComplexMatrix (1, 1, v2.complex_value () / d));
-    }
+    return octave_value (SparseComplexMatrix (1, 1, v2.complex_value ()
+                                                  / v1.complex_value ()));
   else
     {
       MatrixType typ = v1.matrix_type ();
       SparseComplexMatrix m1 = v1.sparse_complex_matrix_value ();
       ComplexMatrix m2 = ComplexMatrix (1, 1, v2.complex_value ());
       ComplexMatrix ret = xleftdiv (m1, m2, typ);
       v1.matrix_type (typ);
       return ret;
@@ -105,26 +90,17 @@ DEFBINOP_FN (ne, sparse_complex_matrix, 
 DEFBINOP_OP (el_mul, sparse_complex_matrix, complex, *)
 
 DEFBINOP (el_div, sparse_complex_matrix, complex)
 {
   const octave_sparse_complex_matrix& v1
     = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
-  octave_value retval;
-
-  Complex d = v2.complex_value ();
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  retval = octave_value (v1.sparse_complex_matrix_value () / d);
-
-  return retval;
+  return octave_value (v1.sparse_complex_matrix_value () / v2.complex_value ());
 }
 
 DEFBINOP_FN (el_pow, sparse_complex_matrix, complex, elem_xpow)
 
 DEFBINOP (el_ldiv, sparse_complex_matrix, complex)
 {
   const octave_sparse_complex_matrix& v1
     = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
diff --git a/libinterp/operators/op-scm-m.cc b/libinterp/operators/op-scm-m.cc
--- a/libinterp/operators/op-scm-m.cc
+++ b/libinterp/operators/op-scm-m.cc
@@ -20,17 +20,16 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-re-mat.h"
 #include "ov-cx-mat.h"
 #include "ops.h"
 #include "xdiv.h"
 
@@ -68,24 +67,17 @@ DEFBINOPX (pow, sparse_complex_matrix, m
 
 DEFBINOP (ldiv, sparse_complex_matrix, matrix)
 {
   const octave_sparse_complex_matrix& v1
     = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
   const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
-    {
-      Complex d = v1.complex_value ();
-
-      if (d == 0.0)
-        warn_divide_by_zero ();
-
-      return octave_value (v2.array_value () / d);
-    }
+    return octave_value (v2.array_value () / v1.complex_value ());
   else
     {
       MatrixType typ = v1.matrix_type ();
 
       ComplexMatrix ret = xleftdiv (v1.sparse_complex_matrix_value (),
                                     v2.matrix_value (), typ);
 
       v1.matrix_type (typ);
diff --git a/libinterp/operators/op-scm-s.cc b/libinterp/operators/op-scm-s.cc
--- a/libinterp/operators/op-scm-s.cc
+++ b/libinterp/operators/op-scm-s.cc
@@ -20,17 +20,16 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-cx-mat.h"
 #include "ov-scalar.h"
 #include "ops.h"
 #include "xpow.h"
 
@@ -48,25 +47,17 @@ DEFBINOP_OP (sub, sparse_complex_matrix,
 DEFBINOP_OP (mul, sparse_complex_matrix, scalar, *)
 
 DEFBINOP (div, sparse_complex_matrix, scalar)
 {
   const octave_sparse_complex_matrix& v1
     = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
-  double d = v2.double_value ();
-  octave_value retval;
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  retval = octave_value (v1.sparse_complex_matrix_value () / d);
-
-  return retval;
+  return octave_value (v1.sparse_complex_matrix_value () / v2.double_value ());
 }
 
 DEFBINOP (pow, sparse_complex_matrix, scalar)
 {
   const octave_sparse_complex_matrix& v1
     = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
@@ -79,24 +70,18 @@ DEFBINOP (pow, sparse_complex_matrix, sc
 
 DEFBINOP (ldiv, sparse_complex_matrix, scalar)
 {
   const octave_sparse_complex_matrix& v1
     = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
-    {
-      Complex d = v1.complex_value ();
-
-      if (d == 0.0)
-        warn_divide_by_zero ();
-
-      return octave_value (SparseComplexMatrix (1, 1, v2.scalar_value () / d));
-    }
+    return octave_value (SparseComplexMatrix (1, 1, v2.scalar_value ()
+                                                  / v1.complex_value ()));
   else
     {
       MatrixType typ = v1.matrix_type ();
       SparseComplexMatrix m1 = v1.sparse_complex_matrix_value ();
       Matrix m2 = Matrix (1, 1, v2.scalar_value ());
       ComplexMatrix ret = xleftdiv (m1, m2, typ);
       v1.matrix_type (typ);
       return ret;
@@ -113,25 +98,17 @@ DEFBINOP_FN (ne, sparse_complex_matrix, 
 DEFBINOP_OP (el_mul, sparse_complex_matrix, scalar, *)
 
 DEFBINOP (el_div, sparse_complex_matrix, scalar)
 {
   const octave_sparse_complex_matrix& v1
     = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
-  double d = v2.double_value ();
-  octave_value retval;
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  retval = octave_value (v1.sparse_complex_matrix_value () / d);
-
-  return retval;
+  return octave_value (v1.sparse_complex_matrix_value () / v2.double_value ());
 }
 
 DEFBINOP_FN (el_pow, sparse_complex_matrix, scalar, elem_xpow)
 
 DEFBINOP (el_ldiv, sparse_complex_matrix, scalar)
 {
   const octave_sparse_complex_matrix& v1
     = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
diff --git a/libinterp/operators/op-scm-scm.cc b/libinterp/operators/op-scm-scm.cc
--- a/libinterp/operators/op-scm-scm.cc
+++ b/libinterp/operators/op-scm-scm.cc
@@ -20,34 +20,28 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-null-mat.h"
 #include "ops.h"
 
 #include "sparse-xdiv.h"
 #include "sparse-xpow.h"
+#include "ov-cx-mat.h"
+#include "ov-cx-sparse.h"
 #include "ov-re-sparse.h"
-#include "ov-cx-sparse.h"
 
-#include "errwarn.h"
-#include "ovl.h"
-#include "ov.h"
-#include "ov-cx-mat.h"
-#include "ov-typeinfo.h"
-#include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // unary sparse complex matrix ops.
 
 DEFUNOP_OP (not, sparse_complex_matrix, !)
 DEFUNOP_OP (uplus, sparse_complex_matrix, /* no-op */)
 DEFUNOP_OP (uminus, sparse_complex_matrix, -)
@@ -65,57 +59,32 @@ DEFUNOP (hermitian, sparse_complex_matri
 {
   const octave_sparse_complex_matrix& v
     = dynamic_cast<const octave_sparse_complex_matrix&> (a);
   return octave_value
          (v.sparse_complex_matrix_value ().hermitian (),
           v.matrix_type ().transpose ());
 }
 
-#if 0
-DEFUNOP (incr, sparse_complex_matrix)
-{
-  const octave_sparse_complex_matrix& v
-    = dynamic_cast<const octave_sparse_complex_matrix&> (a);
-
-  return octave_value (v.complex_matrix_value () .increment ());
-}
-
-DEFUNOP (decr, sparse_complex_matrix)
-{
-  const octave_sparse_complex_matrix& v
-    = dynamic_cast<const octave_sparse_complex_matrix&> (a);
-
-  return octave_value (v.complex_matrix_value () .decrement ());
-}
-#endif
-
 // complex matrix by complex matrix ops.
 
 DEFBINOP_OP (add, sparse_complex_matrix, sparse_complex_matrix, +)
 DEFBINOP_OP (sub, sparse_complex_matrix, sparse_complex_matrix, -)
 
 DEFBINOP_OP (mul, sparse_complex_matrix, sparse_complex_matrix, *)
 
 DEFBINOP (div, sparse_complex_matrix, sparse_complex_matrix)
 {
   const octave_sparse_complex_matrix& v1
     = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
   const octave_sparse_complex_matrix& v2
     = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
-    {
-      Complex d = v2.complex_value ();
-
-      if (d == 0.0)
-        warn_divide_by_zero ();
-
-      return octave_value (v1.sparse_complex_matrix_value () / d);
-    }
+    return octave_value (v1.sparse_complex_matrix_value () / v2.complex_value ());
   else
     {
       MatrixType typ = v2.matrix_type ();
       SparseComplexMatrix ret = xdiv (v1.sparse_complex_matrix_value (),
                                       v2.sparse_complex_matrix_value (), typ);
 
       v2.matrix_type (typ);
       return ret;
@@ -130,24 +99,17 @@ DEFBINOPX (pow, sparse_complex_matrix, s
 DEFBINOP (ldiv, sparse_complex_matrix, sparse_complex_matrix)
 {
   const octave_sparse_complex_matrix& v1
     = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
   const octave_sparse_complex_matrix& v2
     = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
-    {
-      Complex d = v1.complex_value ();
-
-      if (d == 0.0)
-        warn_divide_by_zero ();
-
-      return octave_value (v2.sparse_complex_matrix_value () / d);
-    }
+    return octave_value (v2.sparse_complex_matrix_value () / v1.complex_value ());
   else
     {
       MatrixType typ = v1.matrix_type ();
 
       SparseComplexMatrix ret =
         xleftdiv (v1.sparse_complex_matrix_value (),
                   v2.sparse_complex_matrix_value (), typ);
 
@@ -191,21 +153,16 @@ void
 install_scm_scm_ops (octave::type_info& ti)
 {
   INSTALL_UNOP_TI (ti, op_not, octave_sparse_complex_matrix, not);
   INSTALL_UNOP_TI (ti, op_uplus, octave_sparse_complex_matrix, uplus);
   INSTALL_UNOP_TI (ti, op_uminus, octave_sparse_complex_matrix, uminus);
   INSTALL_UNOP_TI (ti, op_transpose, octave_sparse_complex_matrix, transpose);
   INSTALL_UNOP_TI (ti, op_hermitian, octave_sparse_complex_matrix, hermitian);
 
-#if 0
-  INSTALL_NCUNOP_TI (ti, op_incr, octave_sparse_complex_matrix, incr);
-  INSTALL_NCUNOP_TI (ti, op_decr, octave_sparse_complex_matrix, decr);
-#endif
-
   INSTALL_BINOP_TI (ti, op_add, octave_sparse_complex_matrix,
                     octave_sparse_complex_matrix, add);
   INSTALL_BINOP_TI (ti, op_sub, octave_sparse_complex_matrix,
                     octave_sparse_complex_matrix, sub);
   INSTALL_BINOP_TI (ti, op_mul, octave_sparse_complex_matrix,
                     octave_sparse_complex_matrix, mul);
   INSTALL_BINOP_TI (ti, op_div, octave_sparse_complex_matrix,
                     octave_sparse_complex_matrix, div);
diff --git a/libinterp/operators/op-scm-sm.cc b/libinterp/operators/op-scm-sm.cc
--- a/libinterp/operators/op-scm-sm.cc
+++ b/libinterp/operators/op-scm-sm.cc
@@ -20,17 +20,16 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 
 #include "sparse-xdiv.h"
 #include "sparse-xpow.h"
 #include "smx-sm-scm.h"
@@ -48,24 +47,17 @@ DEFBINOP_OP (mul, sparse_complex_matrix,
 DEFBINOP (div, sparse_complex_matrix, sparse_matrix)
 {
   const octave_sparse_complex_matrix& v1
     = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
   const octave_sparse_matrix& v2
     = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
-    {
-      double d = v2.scalar_value ();
-
-      if (d == 0.0)
-        warn_divide_by_zero ();
-
-      return octave_value (v1.sparse_complex_matrix_value () / d);
-    }
+    return octave_value (v1.sparse_complex_matrix_value () / v2.scalar_value ());
   else
     {
       MatrixType typ = v2.matrix_type ();
       SparseComplexMatrix ret = xdiv (v1.sparse_complex_matrix_value (),
                                       v2.sparse_matrix_value (), typ);
 
       v2.matrix_type (typ);
       return ret;
@@ -80,24 +72,17 @@ DEFBINOPX (pow, sparse_complex_matrix, s
 DEFBINOP (ldiv, sparse_complex_matrix, sparse_matrix)
 {
   const octave_sparse_complex_matrix& v1
     = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
   const octave_sparse_matrix& v2
     = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
-    {
-      Complex d = v1.complex_value ();
-
-      if (d == 0.0)
-        warn_divide_by_zero ();
-
-      return octave_value (v2.sparse_matrix_value () / d);
-    }
+    return octave_value (v2.sparse_matrix_value () / v1.complex_value ());
   else
     {
       MatrixType typ = v1.matrix_type ();
 
       SparseComplexMatrix ret = xleftdiv (v1.sparse_complex_matrix_value (),
                                           v2.sparse_matrix_value (), typ);
 
       v1.matrix_type (typ);
diff --git a/libinterp/operators/op-sm-cm.cc b/libinterp/operators/op-sm-cm.cc
--- a/libinterp/operators/op-sm-cm.cc
+++ b/libinterp/operators/op-sm-cm.cc
@@ -20,17 +20,16 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-cx-mat.h"
 #include "ops.h"
 #include "xdiv.h"
 
 #include "sparse-xpow.h"
@@ -69,24 +68,17 @@ DEFBINOPX (pow, sparse_matrix, complex_m
 DEFBINOP (ldiv, sparse_matrix, complex_matrix)
 {
   const octave_sparse_matrix& v1
     = dynamic_cast<const octave_sparse_matrix&> (a1);
   const octave_complex_matrix& v2
     = dynamic_cast<const octave_complex_matrix&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
-    {
-      double d = v1.scalar_value ();
-
-      if (d == 0.0)
-        warn_divide_by_zero ();
-
-      return octave_value (v2.complex_array_value () / d);
-    }
+    return octave_value (v2.complex_array_value () / v1.scalar_value ());
   else
     {
       MatrixType typ = v1.matrix_type ();
 
       ComplexMatrix ret = xleftdiv (v1.sparse_matrix_value (),
                                     v2.complex_matrix_value (), typ);
 
       v1.matrix_type (typ);
diff --git a/libinterp/operators/op-sm-cs.cc b/libinterp/operators/op-sm-cs.cc
--- a/libinterp/operators/op-sm-cs.cc
+++ b/libinterp/operators/op-sm-cs.cc
@@ -20,17 +20,16 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-complex.h"
 #include "ops.h"
 #include "xpow.h"
 
 #include "sparse-xpow.h"
@@ -46,48 +45,34 @@ DEFBINOP_OP (add, sparse_matrix, complex
 DEFBINOP_OP (sub, sparse_matrix, complex, -)
 DEFBINOP_OP (mul, sparse_matrix, complex, *)
 
 DEFBINOP (div, sparse_matrix, complex)
 {
   const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
-  Complex d = v2.complex_value ();
-  octave_value retval;
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  retval = octave_value (v1.sparse_matrix_value () / d);
-
-  return retval;
+  return octave_value (v1.sparse_matrix_value () / v2.complex_value ());
 }
 
 DEFBINOP (pow, sparse_matrix, complex)
 {
   const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
   return xpow (v1.matrix_value (), v2.complex_value ());
 }
 
 DEFBINOP (ldiv, sparse_matrix, complex)
 {
   const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
-    {
-      double d = v1.scalar_value ();
-
-      if (d == 0.0)
-        warn_divide_by_zero ();
-
-      return octave_value (SparseComplexMatrix (1, 1, v2.complex_value () / d));
-    }
+    return octave_value (SparseComplexMatrix (1, 1, v2.complex_value ()
+                                                  / v1.scalar_value ()));
   else
     {
       MatrixType typ = v1.matrix_type ();
       SparseMatrix m1 = v1.sparse_matrix_value ();
       ComplexMatrix m2 = ComplexMatrix (1, 1, v2.complex_value ());
       ComplexMatrix ret = xleftdiv (m1, m2, typ);
       v1.matrix_type (typ);
       return ret;
@@ -103,25 +88,17 @@ DEFBINOP_FN (ne, sparse_matrix, complex,
 
 DEFBINOP_OP (el_mul, sparse_matrix, complex, *)
 
 DEFBINOP (el_div, sparse_matrix, complex)
 {
   const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
-  Complex d = v2.complex_value ();
-  octave_value retval;
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  retval = octave_value (v1.sparse_matrix_value () / d);
-
-  return retval;
+  return octave_value (v1.sparse_matrix_value () / v2.complex_value ());
 }
 
 DEFBINOP_FN (el_pow, sparse_matrix, complex, elem_xpow)
 
 DEFBINOP (el_ldiv, sparse_matrix, complex)
 {
   const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
   const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
diff --git a/libinterp/operators/op-sm-m.cc b/libinterp/operators/op-sm-m.cc
--- a/libinterp/operators/op-sm-m.cc
+++ b/libinterp/operators/op-sm-m.cc
@@ -20,17 +20,16 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-re-mat.h"
 #include "ops.h"
 #include "xdiv.h"
 
 #include "sparse-xpow.h"
@@ -64,24 +63,17 @@ DEFBINOPX (pow, sparse_matrix, matrix)
 }
 
 DEFBINOP (ldiv, sparse_matrix, matrix)
 {
   const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
   const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
-    {
-      double d = v1.scalar_value ();
-
-      if (d == 0.0)
-        warn_divide_by_zero ();
-
-      return octave_value (v2.array_value () / d);
-    }
+    return octave_value (v2.array_value () / v1.scalar_value ());
   else
     {
       MatrixType typ = v1.matrix_type ();
 
       Matrix ret = xleftdiv (v1.sparse_matrix_value (),
                              v2.matrix_value (), typ);
 
       v1.matrix_type (typ);
diff --git a/libinterp/operators/op-sm-s.cc b/libinterp/operators/op-sm-s.cc
--- a/libinterp/operators/op-sm-s.cc
+++ b/libinterp/operators/op-sm-s.cc
@@ -20,17 +20,16 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-scalar.h"
 #include "ops.h"
 #include "xpow.h"
 
 #include "sparse-xpow.h"
@@ -43,25 +42,17 @@ DEFBINOP_OP (add, sparse_matrix, scalar,
 DEFBINOP_OP (sub, sparse_matrix, scalar, -)
 DEFBINOP_OP (mul, sparse_matrix, scalar, *)
 
 DEFBINOP (div, sparse_matrix, scalar)
 {
   const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
-  double d = v2.double_value ();
-  octave_value retval;
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  retval = octave_value (v1.sparse_matrix_value () / d);
-
-  return retval;
+  return octave_value (v1.sparse_matrix_value () / v2.double_value ());
 }
 
 DEFBINOP (pow, sparse_matrix, scalar)
 {
   const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   double tmp = v2.scalar_value ();
@@ -72,24 +63,17 @@ DEFBINOP (pow, sparse_matrix, scalar)
 }
 
 DEFBINOP (ldiv, sparse_matrix, scalar)
 {
   const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
-    {
-      double d = v1.scalar_value ();
-
-      if (d == 0.0)
-        warn_divide_by_zero ();
-
-      return octave_value (SparseMatrix(1, 1, v2.scalar_value () / d));
-    }
+    return octave_value (SparseMatrix(1, 1, v2.scalar_value () / v1.scalar_value ()));
   else
     {
       MatrixType typ = v1.matrix_type ();
       SparseMatrix m1 = v1.sparse_matrix_value ();
       Matrix m2 = Matrix (1, 1, v2.scalar_value ());
       Matrix ret = xleftdiv (m1, m2, typ);
       v1.matrix_type (typ);
       return ret;
@@ -105,25 +89,17 @@ DEFBINOP_FN (ne, sparse_matrix, scalar, 
 
 DEFBINOP_OP (el_mul, sparse_matrix, scalar, *)
 
 DEFBINOP (el_div, sparse_matrix, scalar)
 {
   const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
-  double d = v2.double_value ();
-  octave_value retval;
-
-  if (d == 0.0)
-    warn_divide_by_zero ();
-
-  retval = octave_value (v1.sparse_matrix_value () / d);
-
-  return retval;
+  return octave_value (v1.sparse_matrix_value () / v2.double_value ());
 }
 
 DEFBINOP_FN (el_pow, sparse_matrix, scalar, elem_xpow)
 
 DEFBINOP (el_ldiv, sparse_matrix, scalar)
 {
   const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
   const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
diff --git a/libinterp/operators/op-sm-scm.cc b/libinterp/operators/op-sm-scm.cc
--- a/libinterp/operators/op-sm-scm.cc
+++ b/libinterp/operators/op-sm-scm.cc
@@ -20,17 +20,16 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 
 #include "sparse-xdiv.h"
 #include "sparse-xpow.h"
 #include "smx-sm-scm.h"
@@ -48,24 +47,17 @@ DEFBINOP_OP (mul, sparse_matrix, sparse_
 DEFBINOP (div, sparse_matrix, sparse_complex_matrix)
 {
   const octave_sparse_matrix& v1
     = dynamic_cast<const octave_sparse_matrix&> (a1);
   const octave_sparse_complex_matrix& v2
     = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
-    {
-      Complex d = v2.complex_value ();
-
-      if (d == 0.0)
-        warn_divide_by_zero ();
-
-      return octave_value (v1.sparse_matrix_value () / d);
-    }
+    return octave_value (v1.sparse_matrix_value () / v2.complex_value ());
   else
     {
       MatrixType typ = v2.matrix_type ();
       SparseComplexMatrix ret = xdiv (v1.sparse_matrix_value (),
                                       v2.sparse_complex_matrix_value (), typ);
 
       v2.matrix_type (typ);
       return ret;
@@ -80,24 +72,17 @@ DEFBINOPX (pow, sparse_matrix, sparse_co
 DEFBINOP (ldiv, sparse_matrix, sparse_complex_matrix)
 {
   const octave_sparse_matrix& v1
     = dynamic_cast<const octave_sparse_matrix&> (a1);
   const octave_sparse_complex_matrix& v2
     = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
-    {
-      double d = v1.scalar_value ();
-
-      if (d == 0.0)
-        warn_divide_by_zero ();
-
-      return octave_value (v2.sparse_complex_matrix_value () / d);
-    }
+    return octave_value (v2.sparse_complex_matrix_value () / v1.scalar_value ());
   else
     {
       MatrixType typ = v1.matrix_type ();
 
       SparseComplexMatrix ret =
         xleftdiv (v1.sparse_matrix_value (),
                   v2.sparse_complex_matrix_value (), typ);
 
diff --git a/libinterp/operators/op-sm-sm.cc b/libinterp/operators/op-sm-sm.cc
--- a/libinterp/operators/op-sm-sm.cc
+++ b/libinterp/operators/op-sm-sm.cc
@@ -20,17 +20,16 @@ along with Octave; see the file COPYING.
 <https://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "errwarn.h"
 #include "ovl.h"
 #include "ov.h"
 #include "ov-typeinfo.h"
 #include "ov-re-mat.h"
 #include "ov-null-mat.h"
 #include "ops.h"
 
 #include "sparse-xpow.h"
@@ -71,24 +70,17 @@ oct_binop_sub (const octave_base_value& 
 DEFBINOP_OP (mul, sparse_matrix, sparse_matrix, *)
 
 DEFBINOP (div, sparse_matrix, sparse_matrix)
 {
   const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
   const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
-    {
-      double d = v2.scalar_value ();
-
-      if (d == 0.0)
-        warn_divide_by_zero ();
-
-      return octave_value (v1.sparse_matrix_value () / d);
-    }
+    return octave_value (v1.sparse_matrix_value () / v2.scalar_value ());
   else
     {
       MatrixType typ = v2.matrix_type ();
       SparseMatrix ret = xdiv (v1.sparse_matrix_value (),
                                v2.sparse_matrix_value (), typ);
 
       v2.matrix_type (typ);
       return ret;
@@ -101,24 +93,17 @@ DEFBINOPX (pow, sparse_matrix, sparse_ma
 }
 
 DEFBINOP (ldiv, sparse_matrix, sparse_matrix)
 {
   const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
   const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
-    {
-      double d = v1.double_value ();
-
-      if (d == 0.0)
-        warn_divide_by_zero ();
-
-      return octave_value (v2.sparse_matrix_value () / d);
-    }
+    return octave_value (v2.sparse_matrix_value () / v1.double_value ());
   else
     {
       MatrixType typ = v1.matrix_type ();
 
       SparseMatrix ret = xleftdiv (v1.sparse_matrix_value (),
                                    v2.sparse_matrix_value (), typ);
 
       v1.matrix_type (typ);
diff --git a/libinterp/parse-tree/jit-typeinfo.cc b/libinterp/parse-tree/jit-typeinfo.cc
--- a/libinterp/parse-tree/jit-typeinfo.cc
+++ b/libinterp/parse-tree/jit-typeinfo.cc
@@ -381,20 +381,16 @@ namespace octave
       return Complex (lhs.real () * rhs.real (), 0);
 
     return lhs * rhs;
   }
 
   extern "C" Complex
   octave_jit_complex_div (Complex lhs, Complex rhs)
   {
-    // see src/OPERATORS/op-cs-cs.cc
-    if (rhs == 0.0)
-      warn_divide_by_zero ();
-
     return lhs / rhs;
   }
 
   // FIXME: CP form src/xpow.cc
   static inline int
   xisint (double x)
   {
     return (math::x_nint (x) == x
@@ -1350,20 +1346,16 @@ namespace octave
 
     add_binary_fcmp (m_scalar, octave_value::op_lt, llvm::CmpInst::FCMP_ULT);
     add_binary_fcmp (m_scalar, octave_value::op_le, llvm::CmpInst::FCMP_ULE);
     add_binary_fcmp (m_scalar, octave_value::op_eq, llvm::CmpInst::FCMP_UEQ);
     add_binary_fcmp (m_scalar, octave_value::op_ge, llvm::CmpInst::FCMP_UGE);
     add_binary_fcmp (m_scalar, octave_value::op_gt, llvm::CmpInst::FCMP_UGT);
     add_binary_fcmp (m_scalar, octave_value::op_ne, llvm::CmpInst::FCMP_UNE);
 
-    jit_function gripe_div0 = create_external (JIT_FN (warn_divide_by_zero),
-                                               nullptr);
-    gripe_div0.mark_can_error ();
-
     // divide is annoying because it might error
     fn = create_internal ("octave_jit_div_scalar_scalar", m_scalar, m_scalar,
                           m_scalar);
     fn.mark_can_error ();
 
     llvm::BasicBlock *body = fn.new_block ();
     m_builder.SetInsertPoint (body);
     {
@@ -1371,17 +1363,16 @@ namespace octave
       llvm::BasicBlock *normal_block = fn.new_block ("normal");
 
       llvm::Value *zero = llvm::ConstantFP::get (m_scalar_t, 0);
       llvm::Value *check = m_builder.CreateFCmpUEQ (zero,
                                                     fn.argument (m_builder, 1));
       m_builder.CreateCondBr (check, warn_block, normal_block);
 
       m_builder.SetInsertPoint (warn_block);
-      gripe_div0.call (m_builder);
       m_builder.CreateBr (normal_block);
 
       m_builder.SetInsertPoint (normal_block);
       llvm::Value *ret = m_builder.CreateFDiv (fn.argument (m_builder, 0),
                                                fn.argument (m_builder, 1));
       fn.do_return (m_builder, ret);
     }
     m_binary_ops[octave_value::op_div].add_overload (fn);
diff --git a/scripts/general/quadgk.m b/scripts/general/quadgk.m
--- a/scripts/general/quadgk.m
+++ b/scripts/general/quadgk.m
@@ -313,20 +313,16 @@ function [q, err] = quadgk (f, a, b, var
 
   ## Split interval into at least 10 subinterval with a 15 point
   ## Gauss-Kronrod rule giving a minimum of 150 function evaluations.
   while (length (subs) < 11)
     subs = [subs' ; subs(1:end-1)' + diff(subs') ./ 2, NaN](:)(1 : end - 1);
   endwhile
   subs = [subs(1:end-1), subs(2:end)];
 
-  ## Singularity will cause divide by zero warnings.
-  ## Turn off warning locally for quadgk function only.
-  warning ("off", "Octave:divide-by-zero", "local");
-
   warn_id = "Octave:quadgk:warning-termination";
 
   if (issingle)
     eps1 = eps ("single");
   else
     eps1 = eps ("double");
   endif
 
diff --git a/scripts/general/quadv.m b/scripts/general/quadv.m
--- a/scripts/general/quadv.m
+++ b/scripts/general/quadv.m
@@ -147,27 +147,23 @@ function [q, nfun, hmin] = simpsonstp (f
 
 endfunction
 
 
 %!assert (quadv (@sin, 0, 2*pi), 0, 1e-6)
 %!assert (quadv (@sin, 0, pi), 2, 1e-6)
 
 ## Test weak singularities at the edge
-%!test
-%! warning ("off", "Octave:divide-by-zero", "local");
-%! assert (quadv (@(x) 1 ./ sqrt (x), 0, 1), 2, 2e-6);
+%!assert (quadv (@(x) 1 ./ sqrt (x), 0, 1), 2, 2e-6);
 
 ## Test vector-valued functions
 %!assert (quadv (@(x) [(sin (x)), (sin (2 * x))], 0, pi), [2, 0], 1e-6)
 
 ## Test matrix-valued functions
-%!test
-%! warning ("off", "Octave:divide-by-zero", "local");
-%! assert (quadv (@(x) [ x,x,x; x,1./sqrt(x),x; x,x,x ], 0, 1),
-%!         [0.5,0.5,0.5; 0.5,2,0.5; 0.5,0.5,0.5], 2e-6);
+%!assert (quadv (@(x) [ x,x,x; x,1./sqrt(x),x; x,x,x ], 0, 1),
+%!        [0.5,0.5,0.5; 0.5,2,0.5; 0.5,0.5,0.5], 2e-6);
 
 ## Test input validation
 %!error quadv ()
 %!error quadv (@sin)
 %!error quadv (@sin,1)
 %!error <TOL must be a scalar> quadv (@sin,0,1, ones (2,2))
 %!error <TOL must be .* .=0> quadv (@sin,0,1, -1)
diff --git a/scripts/help/warning_ids.m b/scripts/help/warning_ids.m
--- a/scripts/help/warning_ids.m
+++ b/scripts/help/warning_ids.m
@@ -153,21 +153,16 @@
 ## By default, the @code{Octave:deprecated-keyword} warning is enabled.
 ##
 ## @item Octave:deprecated-property
 ## If the @code{Octave:deprecated-property} warning is enabled, a
 ## warning is issued when Octave encounters a graphics property that
 ## is obsolete and scheduled for removal from Octave.
 ## By default, the @code{Octave:deprecated-property} warning is enabled.
 ##
-## @item Octave:divide-by-zero
-## If the @code{Octave:divide-by-zero} warning is enabled, a
-## warning is issued when Octave encounters a division by zero.
-## By default, the @code{Octave:divide-by-zero} warning is enabled.
-##
 ## @item Octave:eigs:UnconvergedEigenvalues
 ## If the @code{Octave:eigs:UnconvergedEigenvalues} warning is enabled then
 ## the eigs function will issue a warning if the number of calculated
 ## eigenvalues is less than the number of requested eigenvalues.
 ## By default, the @code{Octave:eigs:UnconvergedEigenvalues} warning is
 ## enabled.
 ##
 ## @item Octave:erase:chararray
diff --git a/scripts/statistics/kurtosis.m b/scripts/statistics/kurtosis.m
--- a/scripts/statistics/kurtosis.m
+++ b/scripts/statistics/kurtosis.m
@@ -148,19 +148,18 @@ endfunction
 %!assert (kurtosis ([1:5 10; 1:5 10],  0, 2), 5.4377317925288901 * [1; 1], 8 * eps)
 %!assert (kurtosis ([1:5 10; 1:5 10],  1, 2), 2.9786509002956195 * [1; 1], 8 * eps)
 %!assert (kurtosis ([1:5 10; 1:5 10], [], 2), 2.9786509002956195 * [1; 1], 8 * eps)
 
 ## Test behavior on single input
 %!assert (kurtosis (single ([1:5 10])), single (2.9786513), eps ("single"))
 %!assert (kurtosis (single ([1 2]), 0), single (NaN))
 
-## Verify no "divide-by-zero" warnings
+## Verify no warnings
 %!test
-%! warning ("on", "Octave:divide-by-zero", "local");
 %! lastwarn ("");  # clear last warning
 %! kurtosis (1);
 %! assert (lastwarn (), "");
 
 ## Test input validation
 %!error kurtosis ()
 %!error kurtosis (1, 2, 3)
 %!error <X must be a numeric vector or matrix> kurtosis (['A'; 'B'])
diff --git a/scripts/statistics/mean.m b/scripts/statistics/mean.m
--- a/scripts/statistics/mean.m
+++ b/scripts/statistics/mean.m
@@ -137,20 +137,16 @@ function y = mean (x, varargin)
     case 0
       mean_type = "a";
     case 1
       mean_type = varargin{mean_type_mask};
     otherwise
       print_usage ();
   endswitch
 
-  ## FIXME: Delete this when the "divide-by-zero" warning is
-  ##        removed in Octave 6.0.
-  warning ("off", "Octave:divide-by-zero", "local");
-
   ## The actual mean computation
   n = size (x, dim);
   switch (mean_type)
     case "a"
       y = sum (x, dim) / n;
     case "g"
       if (all (x(:) >= 0))
         y = exp (sum (log (x), dim) ./ n);
diff --git a/scripts/statistics/skewness.m b/scripts/statistics/skewness.m
--- a/scripts/statistics/skewness.m
+++ b/scripts/statistics/skewness.m
@@ -147,19 +147,18 @@ endfunction
 %!assert (skewness ([1:5 10; 1:5 10],  0, 2), 1.439590274527954 * [1; 1], eps)
 %!assert (skewness ([1:5 10; 1:5 10],  1, 2), 1.051328089232020 * [1; 1], 2*eps)
 %!assert (skewness ([1:5 10; 1:5 10], [], 2), 1.051328089232020 * [1; 1], 2*eps)
 
 ## Test behavior on single input
 %!assert (skewness (single ([1:5 10])), single (1.0513283), eps ("single"))
 %!assert (skewness (single ([1 2]), 0), single (NaN))
 
-## Verify no "divide-by-zero" warnings
+## Verify no warnings
 %!test
-%! warning ("on", "Octave:divide-by-zero", "local");
 %! lastwarn ("");  # clear last warning
 %! skewness (1);
 %! assert (lastwarn (), "");
 
 ## Test input validation
 %!error skewness ()
 %!error skewness (1, 2, 3)
 %!error <X must be a numeric vector or matrix> skewness (['A'; 'B'])
diff --git a/test/jit.tst b/test/jit.tst
--- a/test/jit.tst
+++ b/test/jit.tst
@@ -372,25 +372,21 @@
 %!   i0 = i0 + 1;
 %! endwhile
 %! expected = ones (ndim, ndim, ndim, ndim);
 %! assert (all (m == expected));
 %! assert (result == sum (expected (:)));
 %! assert (jit_failcnt, 0);
 
 %!function test_divide ()
-%! state = warning ("query", "Octave:divide-by-zero").state;
 %! unwind_protect
-%!   warning ("error", "Octave:divide-by-zero");
 %!   for i=1:1e5
 %!     a = 1;
 %!     a / 0;
 %!   endfor
-%! unwind_protect_cleanup
-%!   warning (state, "Octave:divide-by-zero");
 %! end_unwind_protect
 %!endfunction
 
 # %!testif HAVE_LLVM
 # %! jit_failcnt (0);
 # %! lasterr ("");
 # %! try
 # %!   test_divide ();
diff --git a/test/mk-sparse-tst.sh b/test/mk-sparse-tst.sh
--- a/test/mk-sparse-tst.sh
+++ b/test/mk-sparse-tst.sh
@@ -204,22 +204,17 @@ gen_specific_tests() {
     cat <<EOF
 %!assert (nnz (sparse ([-1,realmin,realmin]).^1.5), 1)
 %!assert (nnz (sparse ([-1,realmin,realmin,1]).^1.5), 2)
 
 ## Make sure scalar v==0 doesn't confuse matters
 %!assert (nnz (sparse (1,1,0)), 0)
 %!assert (nnz (sparse (eye (3))*0), 0)
 %!assert (nnz (sparse (eye (3))-sparse (eye (3))), 0)
-
-%!test
-%! wdbz = warning ("query", "Octave:divide-by-zero");
-%! warning ("off", "Octave:divide-by-zero");
-%! assert (full (sparse (eye (3))/0), full (eye (3)/0));
-%! warning (wdbz.state, "Octave:divide-by-zero");
+%!assert (full (sparse (eye (3))/0), full (eye (3)/0));
 
 EOF
 }
 
 
 # =======================================================
 # Main function definition
 
diff --git a/test/prefer.tst b/test/prefer.tst
--- a/test/prefer.tst
+++ b/test/prefer.tst
@@ -171,20 +171,14 @@
 
 %!test
 %! watv = warning ("query", "Octave:assign-as-truth-value");
 %! warning ("on", "Octave:assign-as-truth-value");
 %! fail ("if (x = 1) 1; endif", "warning", "assignment used as truth value");
 %! warning (watv.state, "Octave:assign-as-truth-value");
 
 %!test
-%! wdbz = warning ("query", "Octave:divide-by-zero");
-%! warning ("off", "Octave:divide-by-zero");
 %! assert (isinf (1/0));
-%! warning (wdbz.state, "Octave:divide-by-zero");
 
 %!test
-%! wdbz = warning ("query", "Octave:divide-by-zero");
-%! warning ("on", "Octave:divide-by-zero");
 %! a = 1;
 %! b = 0;
-%! fail ("isinf (a/b);", "warning", "division by zero");
-%! warning (wdbz.state, "Octave:divide-by-zero");
+%! assert (isinf (a/b));
