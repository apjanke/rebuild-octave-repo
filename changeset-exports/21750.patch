# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1463701377 14400
#      Thu May 19 19:42:57 2016 -0400
# Node ID 6720e5a220baca9b78e7c8478debbb3560ff8b19
# Parent  742a52668c4dcee5cd213f0c155d2dd39c55e4a5
use namespace for octave_shlib class

* oct-shlib.h, oct-shlib.cc: Put octave_shlib in octave namespace and
rename to dyamic_library.  Change all uses.

diff --git a/libinterp/corefcn/defun-int.h b/libinterp/corefcn/defun-int.h
--- a/libinterp/corefcn/defun-int.h
+++ b/libinterp/corefcn/defun-int.h
@@ -42,41 +42,41 @@ extern OCTINTERP_API void check_version 
 
 extern OCTINTERP_API void
 install_builtin_function (octave_builtin::fcn f, const std::string& name,
                           const std::string& file, const std::string& doc,
                           bool can_hide_function = true);
 
 extern OCTINTERP_API void
 install_dld_function (octave_dld_function::fcn f, const std::string& name,
-                      const octave_shlib& shl, const std::string& doc,
+                      const octave::dynamic_library& shl, const std::string& doc,
                       bool relative = false);
 
 extern OCTINTERP_API void
 install_mex_function (void *fptr, bool fmex, const std::string& name,
-                      const octave_shlib& shl, bool relative = false);
+                      const octave::dynamic_library& shl, bool relative = false);
 
 extern OCTINTERP_API void
 alias_builtin (const std::string& alias, const std::string& name);
 
 // Gets the shlib of the currently executing DLD function, if any.
-extern OCTINTERP_API octave_shlib
+extern OCTINTERP_API octave::dynamic_library
 get_current_shlib (void);
 
 // This is a convenience class that calls the above function automatically at
 // construction time. When deriving new classes, you can either use it as a
 // field or as a parent (with multiple inheritance).
 
-class octave_auto_shlib : public octave_shlib
+class octave_auto_shlib : public octave::dynamic_library
 {
 public:
   octave_auto_shlib (void)
-    : octave_shlib (get_current_shlib ()) { }
-  octave_auto_shlib (const octave_shlib& shl)
-    : octave_shlib (shl) { }
+    : octave::dynamic_library (get_current_shlib ()) { }
+  octave_auto_shlib (const octave::dynamic_library& shl)
+    : octave::dynamic_library (shl) { }
 };
 
 extern OCTINTERP_API bool
 defun_isargout (int, int);
 
 extern OCTINTERP_API void
 defun_isargout (int, int, bool *);
 
@@ -86,29 +86,29 @@ defun_isargout (int, int, bool *);
 
 #define DECLARE_FUN(name, args_name, nargout_name) \
   DECLARE_FUNX (F ## name, args_name, nargout_name)
 
 // Define the code that will be used to insert the new function into
 // the symbol table.  We look for this name instead of the actual
 // function so that we can easily install the doc std::string too.
 
-typedef bool (*octave_dld_fcn_installer) (const octave_shlib&, bool relative);
+typedef bool (*octave_dld_fcn_installer) (const octave::dynamic_library&, bool relative);
 
 typedef octave_function *
-  (*octave_dld_fcn_getter) (const octave_shlib&, bool relative);
+  (*octave_dld_fcn_getter) (const octave::dynamic_library&, bool relative);
 
 #define DEFINE_FUN_INSTALLER_FUN(name, doc) \
   DEFINE_FUNX_INSTALLER_FUN(#name, F ## name, G ## name, doc)
 
 #define DEFINE_FUNX_INSTALLER_FUN(name, fname, gname, doc) \
   extern "C" \
   OCTAVE_EXPORT \
   octave_function * \
-  gname (const octave_shlib& shl, bool relative) \
+  gname (const octave::dynamic_library& shl, bool relative) \
   { \
     check_version (OCTAVE_API_VERSION, name); \
  \
     octave_dld_function *fcn = octave_dld_function::create (fname, shl, name, doc); \
  \
     if (relative) \
       fcn->mark_relative (); \
  \
diff --git a/libinterp/corefcn/defun.cc b/libinterp/corefcn/defun.cc
--- a/libinterp/corefcn/defun.cc
+++ b/libinterp/corefcn/defun.cc
@@ -85,32 +85,32 @@ install_builtin_function (octave_builtin
 {
   octave_value fcn (new octave_builtin (f, name, file, doc));
 
   symbol_table::install_built_in_function (name, fcn);
 }
 
 void
 install_dld_function (octave_dld_function::fcn f, const std::string& name,
-                      const octave_shlib& shl, const std::string& doc,
+                      const octave::dynamic_library& shl, const std::string& doc,
                       bool relative)
 {
   octave_dld_function *fcn = new octave_dld_function (f, shl, name, doc);
 
   if (relative)
     fcn->mark_relative ();
 
   octave_value fval (fcn);
 
   symbol_table::install_built_in_function (name, fval);
 }
 
 void
 install_mex_function (void *fptr, bool fmex, const std::string& name,
-                      const octave_shlib& shl, bool relative)
+                      const octave::dynamic_library& shl, bool relative)
 {
   octave_mex_function *fcn = new octave_mex_function (fptr, fmex, shl, name);
 
   if (relative)
     fcn->mark_relative ();
 
   octave_value fval (fcn);
 
@@ -118,20 +118,20 @@ install_mex_function (void *fptr, bool f
 }
 
 void
 alias_builtin (const std::string& alias, const std::string& name)
 {
   symbol_table::alias_built_in_function (alias, name);
 }
 
-octave_shlib
+octave::dynamic_library
 get_current_shlib (void)
 {
-  octave_shlib retval;
+  octave::dynamic_library retval;
 
   octave_function *curr_fcn = octave_call_stack::current ();
   if (curr_fcn)
     {
       if (curr_fcn->is_dld_function ())
         {
           octave_dld_function *dld
             = dynamic_cast<octave_dld_function *> (curr_fcn);
diff --git a/libinterp/corefcn/dynamic-ld.cc b/libinterp/corefcn/dynamic-ld.cc
--- a/libinterp/corefcn/dynamic-ld.cc
+++ b/libinterp/corefcn/dynamic-ld.cc
@@ -47,88 +47,88 @@ along with Octave; see the file COPYING.
 #define STRINGIFY(s) STRINGIFY1(s)
 #define STRINGIFY1(s) #s
 
 class
 octave_shlib_list
 {
 public:
 
-  typedef std::list<octave_shlib>::iterator iterator;
-  typedef std::list<octave_shlib>::const_iterator const_iterator;
+  typedef std::list<octave::dynamic_library>::iterator iterator;
+  typedef std::list<octave::dynamic_library>::const_iterator const_iterator;
 
-  static void append (const octave_shlib& shl);
+  static void append (const octave::dynamic_library& shl);
 
-  static void remove (octave_shlib& shl, octave_shlib::close_hook cl_hook = 0);
+  static void remove (octave::dynamic_library& shl, octave::dynamic_library::close_hook cl_hook = 0);
 
-  static octave_shlib find_file (const std::string& file_name);
+  static octave::dynamic_library find_file (const std::string& file_name);
 
   static void display (void);
 
 private:
 
   octave_shlib_list (void) : lib_list () { }
 
   ~octave_shlib_list (void) { }
 
-  void do_append (const octave_shlib& shl);
+  void do_append (const octave::dynamic_library& shl);
 
-  void do_remove (octave_shlib& shl, octave_shlib::close_hook cl_hook = 0);
+  void do_remove (octave::dynamic_library& shl, octave::dynamic_library::close_hook cl_hook = 0);
 
-  octave_shlib do_find_file (const std::string& file_name) const;
+  octave::dynamic_library do_find_file (const std::string& file_name) const;
 
   void do_display (void) const;
 
   static octave_shlib_list *instance;
 
   static void cleanup_instance (void) { delete instance; instance = 0; }
 
   static bool instance_ok (void);
 
   // List of libraries we have loaded.
-  std::list<octave_shlib> lib_list;
+  std::list<octave::dynamic_library> lib_list;
 
   // No copying!
 
   octave_shlib_list (const octave_shlib_list&);
 
   octave_shlib_list& operator = (const octave_shlib_list&);
 };
 
 octave_shlib_list *octave_shlib_list::instance = 0;
 
 void
-octave_shlib_list::do_append (const octave_shlib& shl)
+octave_shlib_list::do_append (const octave::dynamic_library& shl)
 {
   lib_list.push_back (shl);
 }
 
 void
-octave_shlib_list::do_remove (octave_shlib& shl,
-                              octave_shlib::close_hook cl_hook)
+octave_shlib_list::do_remove (octave::dynamic_library& shl,
+                              octave::dynamic_library::close_hook cl_hook)
 {
   for (iterator p = lib_list.begin (); p != lib_list.end (); p++)
     {
       if (*p == shl)
         {
           // Erase first to avoid potentially invalidating the pointer by the
           // following hooks.
           lib_list.erase (p);
 
           shl.close (cl_hook);
 
           break;
         }
     }
 }
 
-octave_shlib
+octave::dynamic_library
 octave_shlib_list::do_find_file (const std::string& file_name) const
 {
-  octave_shlib retval;
+  octave::dynamic_library retval;
 
   for (const_iterator p = lib_list.begin (); p != lib_list.end (); p++)
     {
       if (p->file_name () == file_name)
         {
           retval = *p;
           break;
         }
@@ -160,35 +160,35 @@ octave_shlib_list::instance_ok (void)
 
   if (! instance)
     error ("unable to create shared library list object!");
 
   return retval;
 }
 
 void
-octave_shlib_list::append (const octave_shlib& shl)
+octave_shlib_list::append (const octave::dynamic_library& shl)
 {
   if (instance_ok ())
     instance->do_append (shl);
 }
 
 void
-octave_shlib_list::remove (octave_shlib& shl,
-                           octave_shlib::close_hook cl_hook)
+octave_shlib_list::remove (octave::dynamic_library& shl,
+                           octave::dynamic_library::close_hook cl_hook)
 {
   if (instance_ok ())
     instance->do_remove (shl, cl_hook);
 }
 
-octave_shlib
+octave::dynamic_library
 octave_shlib_list::find_file (const std::string& file_name)
 {
   return (instance_ok ())
-         ? instance->do_find_file (file_name) : octave_shlib ();
+         ? instance->do_find_file (file_name) : octave::dynamic_library ();
 }
 
 void
 octave_shlib_list::display (void)
 {
   if (instance_ok ())
     instance->do_display ();
 }
@@ -221,17 +221,17 @@ static void
 do_clear_function (const std::string& fcn_name)
 {
   warning_with_id ("Octave:reload-forces-clear", "  %s", fcn_name.c_str ());
 
   symbol_table::clear_dld_function (fcn_name);
 }
 
 static void
-clear (octave_shlib& oct_file)
+clear (octave::dynamic_library& oct_file)
 {
   if (oct_file.number_of_functions_loaded () > 1)
     {
       warning_with_id ("Octave:reload-forces-clear",
                        "reloading %s clears the following functions:",
                        oct_file.file_name ().c_str ());
 
       octave_shlib_list::remove (oct_file, do_clear_function);
@@ -248,17 +248,17 @@ octave_dynamic_loader::do_load_oct (cons
   octave_function *retval = 0;
 
   octave::unwind_protect frame;
 
   frame.protect_var (octave_dynamic_loader::doing_load);
 
   doing_load = true;
 
-  octave_shlib oct_file = octave_shlib_list::find_file (file_name);
+  octave::dynamic_library oct_file = octave_shlib_list::find_file (file_name);
 
   if (oct_file && oct_file.is_out_of_date ())
     clear (oct_file);
 
   if (! oct_file)
     {
       oct_file.open (file_name);
 
@@ -302,17 +302,17 @@ octave_dynamic_loader::do_load_mex (cons
   octave_function *retval = 0;
 
   octave::unwind_protect frame;
 
   frame.protect_var (octave_dynamic_loader::doing_load);
 
   doing_load = true;
 
-  octave_shlib mex_file = octave_shlib_list::find_file (file_name);
+  octave::dynamic_library mex_file = octave_shlib_list::find_file (file_name);
 
   if (mex_file && mex_file.is_out_of_date ())
     clear (mex_file);
 
   if (! mex_file)
     {
       mex_file.open (file_name);
 
@@ -350,17 +350,17 @@ octave_dynamic_loader::do_load_mex (cons
   else
     error ("failed to install .mex file function '%s'", fcn_name.c_str ());
 
   return retval;
 }
 
 bool
 octave_dynamic_loader::do_remove_oct (const std::string& fcn_name,
-                                      octave_shlib& shl)
+                                      octave::dynamic_library& shl)
 {
   bool retval = false;
 
   // We don't need to do anything if this is called because we are in
   // the process of reloading a .oct file that has changed.
 
   if (! doing_load)
     {
@@ -370,17 +370,17 @@ octave_dynamic_loader::do_remove_oct (co
         octave_shlib_list::remove (shl);
     }
 
   return retval;
 }
 
 bool
 octave_dynamic_loader::do_remove_mex (const std::string& fcn_name,
-                                      octave_shlib& shl)
+                                      octave::dynamic_library& shl)
 {
   bool retval = false;
 
   // We don't need to do anything if this is called because we are in
   // the process of reloading a .oct file that has changed.
 
   if (! doing_load)
     {
@@ -408,24 +408,24 @@ octave_dynamic_loader::load_mex (const s
                                  bool relative)
 {
   return (instance_ok ())
          ? instance->do_load_mex (fcn_name, file_name, relative) : 0;
 }
 
 bool
 octave_dynamic_loader::remove_oct (const std::string& fcn_name,
-                                   octave_shlib& shl)
+                                   octave::dynamic_library& shl)
 {
   return (instance_ok ()) ? instance->do_remove_oct (fcn_name, shl) : false;
 }
 
 bool
 octave_dynamic_loader::remove_mex (const std::string& fcn_name,
-                                   octave_shlib& shl)
+                                   octave::dynamic_library& shl)
 {
   return (instance_ok ()) ? instance->do_remove_mex (fcn_name, shl) : false;
 }
 
 std::string
 octave_dynamic_loader::name_mangler (const std::string& name)
 {
   return "G" + name;
diff --git a/libinterp/corefcn/dynamic-ld.h b/libinterp/corefcn/dynamic-ld.h
--- a/libinterp/corefcn/dynamic-ld.h
+++ b/libinterp/corefcn/dynamic-ld.h
@@ -47,19 +47,19 @@ public:
             const std::string& file_name = "",
             bool relative = false);
 
   static octave_function *
   load_mex (const std::string& fcn_name,
             const std::string& file_name = "",
             bool relative = false);
 
-  static bool remove_oct (const std::string& fcn_name, octave_shlib& shl);
+  static bool remove_oct (const std::string& fcn_name, octave::dynamic_library& shl);
 
-  static bool remove_mex (const std::string& fcn_name, octave_shlib& shl);
+  static bool remove_mex (const std::string& fcn_name, octave::dynamic_library& shl);
 
 private:
 
   // No copying!
 
   octave_dynamic_loader (const octave_dynamic_loader&);
 
   octave_dynamic_loader& operator = (const octave_dynamic_loader&);
@@ -75,19 +75,19 @@ private:
                const std::string& file_name = "",
                bool relative = false);
 
   octave_function *
   do_load_mex (const std::string& fcn_name,
                const std::string& file_name = "",
                bool relative = false);
 
-  bool do_remove_oct (const std::string& fcn_name, octave_shlib& shl);
+  bool do_remove_oct (const std::string& fcn_name, octave::dynamic_library& shl);
 
-  bool do_remove_mex (const std::string& fcn_name, octave_shlib& shl);
+  bool do_remove_mex (const std::string& fcn_name, octave::dynamic_library& shl);
 
   static bool doing_load;
 
 protected:
 
   static std::string name_mangler (const std::string& name);
 
   static std::string name_uscore_mangler (const std::string& name);
diff --git a/libinterp/octave-value/ov-dld-fcn.cc b/libinterp/octave-value/ov-dld-fcn.cc
--- a/libinterp/octave-value/ov-dld-fcn.cc
+++ b/libinterp/octave-value/ov-dld-fcn.cc
@@ -35,17 +35,17 @@ along with Octave; see the file COPYING.
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_dld_function,
                                      "dynamically-linked function",
                                      "dynamically-linked function");
 
 
 octave_dld_function::octave_dld_function
-  (octave_builtin::fcn ff, const octave_shlib& shl,
+  (octave_builtin::fcn ff, const octave::dynamic_library& shl,
    const std::string& nm, const std::string& ds)
   : octave_builtin (ff, nm, ds), sh_lib (shl)
 {
   mark_fcn_file_up_to_date (time_parsed ());
 
   std::string file_name = fcn_file_name ();
 
   system_fcn_file
@@ -77,13 +77,13 @@ octave_dld_function::time_parsed (void) 
 //       been fully deleted; indeed, MSVC attaches auto-generated code
 //       (scalar deleting destructor) to objects created in a dynamic
 //       module, and this code will be executed in the dynamic module
 //       context at object deletion; unloading the dynamic module
 //       before objects have been deleted will make the "delete" code
 //       of objects to point to an invalid code segment.
 
 octave_dld_function*
-octave_dld_function::create (octave_builtin::fcn ff, const octave_shlib& shl,
+octave_dld_function::create (octave_builtin::fcn ff, const octave::dynamic_library& shl,
                              const std::string& nm, const std::string& ds)
 {
   return new octave_dld_function (ff, shl, nm, ds);
 }
diff --git a/libinterp/octave-value/ov-dld-fcn.h b/libinterp/octave-value/ov-dld-fcn.h
--- a/libinterp/octave-value/ov-dld-fcn.h
+++ b/libinterp/octave-value/ov-dld-fcn.h
@@ -28,34 +28,32 @@ along with Octave; see the file COPYING.
 #include <string>
 
 #include "oct-shlib.h"
 
 #include "ov-fcn.h"
 #include "ov-builtin.h"
 #include "ov-typeinfo.h"
 
-class octave_shlib;
-
 class octave_value;
 class octave_value_list;
 
 // Dynamically-linked functions.
 
 class
 OCTINTERP_API
 octave_dld_function : public octave_builtin
 {
 public:
 
   octave_dld_function (void)
     : sh_lib (), t_checked (), system_fcn_file ()
   { }
 
-  octave_dld_function (octave_builtin::fcn ff, const octave_shlib& shl,
+  octave_dld_function (octave_builtin::fcn ff, const octave::dynamic_library& shl,
                        const std::string& nm = "",
                        const std::string& ds = "");
 
   ~octave_dld_function (void);
 
   void mark_fcn_file_up_to_date (const octave::sys::time& t) { t_checked = t; }
 
   std::string fcn_file_name (void) const;
@@ -66,26 +64,26 @@ public:
 
   bool is_system_fcn_file (void) const { return system_fcn_file; }
 
   bool is_builtin_function (void) const { return false; }
 
   bool is_dld_function (void) const { return true; }
 
   static octave_dld_function* create (octave_builtin::fcn ff,
-                                      const octave_shlib& shl,
+                                      const octave::dynamic_library& shl,
                                       const std::string& nm = "",
                                       const std::string& ds = "");
 
-  octave_shlib get_shlib (void) const
+  octave::dynamic_library get_shlib (void) const
   { return sh_lib; }
 
 private:
 
-  octave_shlib sh_lib;
+  octave::dynamic_library sh_lib;
 
   // The time the file was last checked to see if it needs to be
   // parsed again.
   mutable octave::sys::time t_checked;
 
   // True if this function came from a file that is considered to be a
   // system function.  This affects whether we check the time stamp
   // on the file to see if it has changed.
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -170,17 +170,17 @@ extern "C"
   JNIEXPORT jboolean JNICALL
   Java_org_octave_Octave_needThreadedInvokation (JNIEnv *, jclass);
 }
 
 static JavaVM *jvm = 0;
 static bool jvm_attached = false;
 
 // Need to keep hold of the shared library handle until exit.
-static octave_shlib jvm_lib;
+static octave::dynamic_library jvm_lib;
 
 static std::map<int,octave_value> listener_map;
 static std::map<int,octave_value> octave_ref_map;
 static int octave_java_refcount = 0;
 static long octave_thread_ID = -1;
 
 bool Vjava_matrix_autoconversion = false;
 bool Vjava_unsigned_autoconversion = true;
@@ -605,17 +605,17 @@ initialize_jvm (void)
 #  endif
 
 #endif
 
   jsize nVMs = 0;
 
 #if ! defined (__APPLE__) && ! defined (__MACH__)
 
-  octave_shlib lib (jvm_lib_path);
+  octave::dynamic_library lib (jvm_lib_path);
 
   if (! lib)
     error ("unable to load Java Runtime Environment from %s",
            jvm_lib_path.c_str ());
 
 #if defined (__WIN32__)
 
   set_dll_directory ();
@@ -636,17 +636,17 @@ initialize_jvm (void)
   if (! get_vm)
     error ("unable to find JNI_GetCreatedJavaVMs in %s", jvm_lib_path.c_str ());
 
   if (get_vm (&jvm, 1, &nVMs) == 0 && nVMs > 0)
 
 #else
 
   // FIXME: There exists a problem on the Mac platform that
-  //   octave_shlib lib (jvm_lib_path)
+  //   octave::dynamic_library lib (jvm_lib_path)
   // doesn't work with 'not-bundled' *.oct files.
 
   if (JNI_GetCreatedJavaVMs (&jvm, 1, &nVMs) == 0 && nVMs > 0)
 
 #endif
 
     {
       // At least one JVM exists, try to attach to it
diff --git a/libinterp/octave-value/ov-mex-fcn.cc b/libinterp/octave-value/ov-mex-fcn.cc
--- a/libinterp/octave-value/ov-mex-fcn.cc
+++ b/libinterp/octave-value/ov-mex-fcn.cc
@@ -37,17 +37,17 @@ along with Octave; see the file COPYING.
 #include "toplev.h"
 #include "unwind-prot.h"
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_mex_function,
                                      "mex function", "mex function");
 
 octave_mex_function::octave_mex_function
-  (void *fptr, bool fmex, const octave_shlib& shl,
+  (void *fptr, bool fmex, const octave::dynamic_library& shl,
    const std::string& nm)
   : octave_function (nm), mex_fcn_ptr (fptr), exit_fcn_ptr (0),
     have_fmex (fmex), sh_lib (shl)
 {
   mark_fcn_file_up_to_date (time_parsed ());
 
   std::string file_name = fcn_file_name ();
 
diff --git a/libinterp/octave-value/ov-mex-fcn.h b/libinterp/octave-value/ov-mex-fcn.h
--- a/libinterp/octave-value/ov-mex-fcn.h
+++ b/libinterp/octave-value/ov-mex-fcn.h
@@ -28,33 +28,31 @@ along with Octave; see the file COPYING.
 #include <string>
 
 #include "oct-shlib.h"
 
 #include "ov-fcn.h"
 #include "ov-builtin.h"
 #include "ov-typeinfo.h"
 
-class octave_shlib;
-
 class octave_value;
 class octave_value_list;
 
 // Dynamically-linked functions.
 
 class
 octave_mex_function : public octave_function
 {
 public:
 
   octave_mex_function (void)
     : mex_fcn_ptr (), exit_fcn_ptr (), have_fmex (), sh_lib (),
       t_checked (), system_fcn_file () { }
 
-  octave_mex_function (void *fptr, bool fmex, const octave_shlib& shl,
+  octave_mex_function (void *fptr, bool fmex, const octave::dynamic_library& shl,
                        const std::string& nm = "");
 
   ~octave_mex_function (void);
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx)
   {
     octave_value_list tmp = subsref (type, idx, 1);
@@ -83,28 +81,28 @@ public:
 
   bool is_mex_function (void) const { return true; }
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args);
 
   void atexit (void (*fcn) (void)) { exit_fcn_ptr = fcn; }
 
-  octave_shlib get_shlib (void) const
+  octave::dynamic_library get_shlib (void) const
   { return sh_lib; }
 
 private:
 
   void *mex_fcn_ptr;
 
   void (*exit_fcn_ptr) (void);
 
   bool have_fmex;
 
-  octave_shlib sh_lib;
+  octave::dynamic_library sh_lib;
 
   // The time the file was last checked to see if it needs to be
   // parsed again.
   mutable octave::sys::time t_checked;
 
   // True if this function came from a file that is considered to be a
   // system function.  This affects whether we check the time stamp
   // on the file to see if it has changed.
diff --git a/liboctave/util/oct-shlib.cc b/liboctave/util/oct-shlib.cc
--- a/liboctave/util/oct-shlib.cc
+++ b/liboctave/util/oct-shlib.cc
@@ -55,461 +55,464 @@ extern int dlclose (void *);
 #endif
 }
 
 #include "file-stat.h"
 #include "lo-error.h"
 #include "oct-shlib.h"
 #include "str-vec.h"
 
-octave_shlib::shlib_rep::shlib_rep (const std::string& f)
-  : count (1), file (f), tm_loaded (), fcn_names ()
-{
-  instances[f] = this;
-
-  if (is_out_of_date ())
-    (*current_liboctave_warning_with_id_handler)
-      ("Octave:warn-future-time-stamp",
-       "timestamp on file %s is in the future", file.c_str ());
-}
-
-bool
-octave_shlib::shlib_rep::is_out_of_date (void) const
-{
-  octave::sys::file_stat fs (file);
-  return (fs && fs.is_newer (tm_loaded));
-}
-
-void
-octave_shlib::shlib_rep::fake_reload (void)
-{
-  // We can't actually reload the library, but we'll pretend we did.
-  octave::sys::file_stat fs (file);
-  if (fs && fs.is_newer (tm_loaded))
-    {
-      tm_loaded = fs.mtime ();
-
-      (*current_liboctave_warning_with_id_handler)
-        ("Octave:library-reload",
-         "library %s not reloaded due to existing references", file.c_str ());
-    }
-}
-
-octave_shlib::shlib_rep *
-octave_shlib::shlib_rep::get_instance (const std::string& f, bool fake)
+namespace octave
 {
-  shlib_rep *retval = 0;
-  std::map<std::string, shlib_rep *>::iterator p = instances.find (f);
-  if (p != instances.end ())
-    {
-      retval = p->second;
-      retval->count++;
-      if (fake)
-        retval->fake_reload ();
-    }
-  else
-    retval = new_instance (f);
+  dynamic_library::dynlib_rep::dynlib_rep (const std::string& f)
+    : count (1), file (f), tm_loaded (), fcn_names ()
+  {
+    instances[f] = this;
+
+    if (is_out_of_date ())
+      (*current_liboctave_warning_with_id_handler)
+        ("Octave:warn-future-time-stamp",
+         "timestamp on file %s is in the future", file.c_str ());
+  }
 
-  return retval;
-}
+  bool
+  dynamic_library::dynlib_rep::is_out_of_date (void) const
+  {
+    octave::sys::file_stat fs (file);
+    return (fs && fs.is_newer (tm_loaded));
+  }
 
-void
-octave_shlib::shlib_rep::add_fcn_name (const std::string& name)
-{
-  fcn_names_iterator p = fcn_names.find (name);
+  void
+  dynamic_library::dynlib_rep::fake_reload (void)
+  {
+    // We can't actually reload the library, but we'll pretend we did.
+    octave::sys::file_stat fs (file);
+    if (fs && fs.is_newer (tm_loaded))
+      {
+        tm_loaded = fs.mtime ();
 
-  if (p == fcn_names.end ())
-    fcn_names[name] = 1;
-  else
-    ++(p->second);
-}
+        (*current_liboctave_warning_with_id_handler)
+          ("Octave:library-reload",
+           "library %s not reloaded due to existing references", file.c_str ());
+      }
+  }
 
-bool
-octave_shlib::shlib_rep::remove_fcn_name (const std::string& fcn_name)
-{
-  bool retval = false;
+  dynamic_library::dynlib_rep *
+  dynamic_library::dynlib_rep::get_instance (const std::string& f, bool fake)
+  {
+    dynlib_rep *retval = 0;
+    std::map<std::string, dynlib_rep *>::iterator p = instances.find (f);
+    if (p != instances.end ())
+      {
+        retval = p->second;
+        retval->count++;
+        if (fake)
+          retval->fake_reload ();
+      }
+    else
+      retval = new_instance (f);
 
-  fcn_names_iterator p = fcn_names.find (fcn_name);
+    return retval;
+  }
 
-  if (p != fcn_names.end () && --(p->second) == 0)
-    {
-      fcn_names.erase (fcn_name);
-      retval = true;
-    }
+  void
+  dynamic_library::dynlib_rep::add_fcn_name (const std::string& name)
+  {
+    fcn_names_iterator p = fcn_names.find (name);
+
+    if (p == fcn_names.end ())
+      fcn_names[name] = 1;
+    else
+      ++(p->second);
+  }
 
-  return retval;
-}
+  bool
+  dynamic_library::dynlib_rep::remove_fcn_name (const std::string& fcn_name)
+  {
+    bool retval = false;
+
+    fcn_names_iterator p = fcn_names.find (fcn_name);
+
+    if (p != fcn_names.end () && --(p->second) == 0)
+      {
+        fcn_names.erase (fcn_name);
+        retval = true;
+      }
 
-void
-octave_shlib::shlib_rep::do_close_hook (octave_shlib::close_hook cl_hook)
-{
-  for (fcn_names_iterator p = fcn_names.begin (); p != fcn_names.end (); p++)
-    cl_hook (p->first);
+    return retval;
+  }
 
-  fcn_names.clear ();
-}
+  void
+  dynamic_library::dynlib_rep::do_close_hook (dynamic_library::close_hook cl_hook)
+  {
+    for (fcn_names_iterator p = fcn_names.begin (); p != fcn_names.end (); p++)
+      cl_hook (p->first);
 
-std::map<std::string, octave_shlib::shlib_rep *> octave_shlib::shlib_rep::instances;
+    fcn_names.clear ();
+  }
 
-octave_shlib::shlib_rep octave_shlib::nil_rep;
+  std::map<std::string, dynamic_library::dynlib_rep *> dynamic_library::dynlib_rep::instances;
+
+  dynamic_library::dynlib_rep dynamic_library::nil_rep;
 
 #if defined (HAVE_DLOPEN_API)
 
-class
-octave_dlopen_shlib : public octave_shlib::shlib_rep
-{
-public:
+  class
+  octave_dlopen_shlib : public dynamic_library::dynlib_rep
+  {
+  public:
 
-  octave_dlopen_shlib (const std::string& f);
+    octave_dlopen_shlib (const std::string& f);
 
-  ~octave_dlopen_shlib (void);
+    ~octave_dlopen_shlib (void);
 
-  void *search (const std::string& name,
-                octave_shlib::name_mangler mangler = 0);
+    void *search (const std::string& name,
+                  dynamic_library::name_mangler mangler = 0);
 
-  // FIXME: this is possibly redundant because failure to open a library will
-  // normally throw an exception, avoiding the construction of an invalid
-  // library. Leave it here for possible future use.
+    // FIXME: this is possibly redundant because failure to open a library will
+    // normally throw an exception, avoiding the construction of an invalid
+    // library. Leave it here for possible future use.
 
-  bool is_open (void) const { return (library != 0); }
+    bool is_open (void) const { return (library != 0); }
 
-private:
+  private:
 
-  // No copying!
+    // No copying!
 
-  octave_dlopen_shlib (const octave_dlopen_shlib&);
+    octave_dlopen_shlib (const octave_dlopen_shlib&);
 
-  octave_dlopen_shlib& operator = (const octave_dlopen_shlib&);
+    octave_dlopen_shlib& operator = (const octave_dlopen_shlib&);
 
-  void *library;
-};
+    void *library;
+  };
 
-octave_dlopen_shlib::octave_dlopen_shlib (const std::string& f)
-  : octave_shlib::shlib_rep (f), library (0)
-{
-  int flags = 0;
+  octave_dlopen_shlib::octave_dlopen_shlib (const std::string& f)
+    : dynamic_library::dynlib_rep (f), library (0)
+  {
+    int flags = 0;
 
-  // Use RTLD_NOW to resolve all symbols before dlopen returns.
-  // By using this option, dlopen will detect errors and Octave
-  // won't exit if there are unresolved symbols in the file we are
-  // loading, and we may even get a useful diagnostic.
+    // Use RTLD_NOW to resolve all symbols before dlopen returns.
+    // By using this option, dlopen will detect errors and Octave
+    // won't exit if there are unresolved symbols in the file we are
+    // loading, and we may even get a useful diagnostic.
 #  if defined (RTLD_NOW)
-  flags |= RTLD_NOW;
+    flags |= RTLD_NOW;
 #  endif
 
-  // Use RTLD_GLOBAL to export symbols from loaded objects so they are
-  // available to other subsequently loaded libraries.
+    // Use RTLD_GLOBAL to export symbols from loaded objects so they are
+    // available to other subsequently loaded libraries.
 #  if defined (RTLD_GLOBAL)
-  flags |= RTLD_GLOBAL;
+    flags |= RTLD_GLOBAL;
 #  endif
 
-  library = dlopen (file.c_str (), flags);
+    library = dlopen (file.c_str (), flags);
 
-  if (! library)
-    {
-      const char *msg = dlerror ();
+    if (! library)
+      {
+        const char *msg = dlerror ();
 
-      if (msg)
-        (*current_liboctave_error_handler) ("%s: failed to load: %s",
-                                            file.c_str (), msg);
-      else
-        (*current_liboctave_error_handler) ("%s: failed to load",
-                                            file.c_str ());
-    }
-}
+        if (msg)
+          (*current_liboctave_error_handler) ("%s: failed to load: %s",
+                                              file.c_str (), msg);
+        else
+          (*current_liboctave_error_handler) ("%s: failed to load",
+                                              file.c_str ());
+      }
+  }
 
-octave_dlopen_shlib::~octave_dlopen_shlib (void)
-{
-  if (library)
-    dlclose (library);
-}
+  octave_dlopen_shlib::~octave_dlopen_shlib (void)
+  {
+    if (library)
+      dlclose (library);
+  }
 
-void *
-octave_dlopen_shlib::search (const std::string& name,
-                             octave_shlib::name_mangler mangler)
-{
-  void *function = 0;
+  void *
+  octave_dlopen_shlib::search (const std::string& name,
+                               dynamic_library::name_mangler mangler)
+  {
+    void *function = 0;
 
-  if (! is_open ())
-    (*current_liboctave_error_handler)
-      ("shared library %s is not open", file.c_str ());
+    if (! is_open ())
+      (*current_liboctave_error_handler)
+        ("shared library %s is not open", file.c_str ());
 
-  std::string sym_name = name;
+    std::string sym_name = name;
 
-  if (mangler)
-    sym_name = mangler (name);
+    if (mangler)
+      sym_name = mangler (name);
 
-  function = dlsym (library, sym_name.c_str ());
+    function = dlsym (library, sym_name.c_str ());
 
-  return function;
-}
+    return function;
+  }
 
 #elif defined (HAVE_SHL_LOAD_API)
 
-class
-octave_shl_load_shlib : public octave_shlib::shlib_rep
-{
-public:
+  class
+  octave_shl_load_shlib : public dynamic_library::dynlib_rep
+  {
+  public:
 
-  octave_shl_load_shlib (const std::string& f);
+    octave_shl_load_shlib (const std::string& f);
 
-  ~octave_shl_load_shlib (void);
+    ~octave_shl_load_shlib (void);
 
-  void *search (const std::string& name,
-                octave_shlib::name_mangler mangler = 0);
+    void *search (const std::string& name,
+                  dynamic_library::name_mangler mangler = 0);
 
-  bool is_open (void) const { return (library != 0); }
+    bool is_open (void) const { return (library != 0); }
 
-private:
+  private:
 
-  // No copying!
+    // No copying!
 
-  octave_shl_load_shlib (const octave_shl_load_shlib&);
+    octave_shl_load_shlib (const octave_shl_load_shlib&);
 
-  octave_shl_load_shlib& operator = (const octave_shl_load_shlib&);
+    octave_shl_load_shlib& operator = (const octave_shl_load_shlib&);
 
-  shl_t library;
-};
+    shl_t library;
+  };
 
-octave_shl_load_shlib::octave_shl_load_shlib (const std::string& f)
-  : octave_shlib::shlib_rep (f), library (0)
-{
-  file = f;
+  octave_shl_load_shlib::octave_shl_load_shlib (const std::string& f)
+    : dynamic_library::dynlib_rep (f), library (0)
+  {
+    file = f;
 
-  library = shl_load (file.c_str (), BIND_IMMEDIATE, 0L);
+    library = shl_load (file.c_str (), BIND_IMMEDIATE, 0L);
 
-  if (! library)
-    {
-      using namespace std;  // FIXME: Why have this line?
-      (*current_liboctave_error_handler) ("%s", gnulib::strerror (errno));
-    }
-}
+    if (! library)
+      {
+        using namespace std;  // FIXME: Why have this line?
+        (*current_liboctave_error_handler) ("%s", gnulib::strerror (errno));
+      }
+  }
 
-octave_shl_load_shlib::~octave_shl_load_shlib (void)
-{
-  if (library)
-    shl_unload (library);
-}
+  octave_shl_load_shlib::~octave_shl_load_shlib (void)
+  {
+    if (library)
+      shl_unload (library);
+  }
 
-void *
-octave_shl_load_shlib::search (const std::string& name,
-                               octave_shlib::name_mangler mangler)
-{
-  void *function = 0;
+  void *
+  octave_shl_load_shlib::search (const std::string& name,
+                                 dynamic_library::name_mangler mangler)
+  {
+    void *function = 0;
 
-  if (! is_open ())
-    (*current_liboctave_error_handler)
-      ("shared library %s is not open", file.c_str ());
+    if (! is_open ())
+      (*current_liboctave_error_handler)
+        ("shared library %s is not open", file.c_str ());
 
-  std::string sym_name = name;
+    std::string sym_name = name;
 
-  if (mangler)
-    sym_name = mangler (name);
+    if (mangler)
+      sym_name = mangler (name);
 
-  int status = shl_findsym (&library, sym_name.c_str (),
-                            TYPE_UNDEFINED, &function);
+    int status = shl_findsym (&library, sym_name.c_str (),
+                              TYPE_UNDEFINED, &function);
 
-  return function;
-}
+    return function;
+  }
 
 #elif defined (HAVE_LOADLIBRARY_API)
 
-class
-octave_w32_shlib: public octave_shlib::shlib_rep
-{
-public:
+  class
+  octave_w32_shlib: public dynamic_library::dynlib_rep
+  {
+  public:
 
-  octave_w32_shlib (const std::string& f);
+    octave_w32_shlib (const std::string& f);
 
-  ~octave_w32_shlib (void);
+    ~octave_w32_shlib (void);
 
-  void *search (const std::string& name,
-                octave_shlib::name_mangler mangler = 0);
+    void *search (const std::string& name,
+                  dynamic_library::name_mangler mangler = 0);
 
-  bool is_open (void) const { return (handle != 0); }
+    bool is_open (void) const { return (handle != 0); }
 
-private:
+  private:
 
-  // No copying!
+    // No copying!
 
-  octave_w32_shlib (const octave_w32_shlib&);
+    octave_w32_shlib (const octave_w32_shlib&);
 
-  octave_w32_shlib& operator = (const octave_w32_shlib&);
+    octave_w32_shlib& operator = (const octave_w32_shlib&);
 
-  HINSTANCE handle;
-};
+    HINSTANCE handle;
+  };
 
-octave_w32_shlib::octave_w32_shlib (const std::string& f)
-  : octave_shlib::shlib_rep (f), handle (0)
-{
-  handle = LoadLibrary (file.c_str ());
+  octave_w32_shlib::octave_w32_shlib (const std::string& f)
+    : dynamic_library::dynlib_rep (f), handle (0)
+  {
+    handle = LoadLibrary (file.c_str ());
 
-  if (! handle)
-    {
-      DWORD lastError = GetLastError ();
-      const char *msg;
+    if (! handle)
+      {
+        DWORD lastError = GetLastError ();
+        const char *msg;
 
-      switch (lastError)
-        {
-        case ERROR_MOD_NOT_FOUND:
-        case ERROR_DLL_NOT_FOUND:
-          msg = "could not find library or dependencies";
-          break;
+        switch (lastError)
+          {
+          case ERROR_MOD_NOT_FOUND:
+          case ERROR_DLL_NOT_FOUND:
+            msg = "could not find library or dependencies";
+            break;
 
-        case ERROR_INVALID_DLL:
-          msg = "library or its dependencies are damaged";
-          break;
+          case ERROR_INVALID_DLL:
+            msg = "library or its dependencies are damaged";
+            break;
 
-        case ERROR_DLL_INIT_FAILED:
-          msg = "library initialization routine failed";
-          break;
+          case ERROR_DLL_INIT_FAILED:
+            msg = "library initialization routine failed";
+            break;
 
-        default:
-          msg = "library open failed";
-        }
+          default:
+            msg = "library open failed";
+          }
 
-      (*current_liboctave_error_handler) ("%s: %s", msg, file.c_str ());
-    }
-}
+        (*current_liboctave_error_handler) ("%s: %s", msg, file.c_str ());
+      }
+  }
 
-octave_w32_shlib::~octave_w32_shlib (void)
-{
-  if (handle)
-    FreeLibrary (handle);
-}
+  octave_w32_shlib::~octave_w32_shlib (void)
+  {
+    if (handle)
+      FreeLibrary (handle);
+  }
 
-void *
-octave_w32_shlib::search (const std::string& name,
-                          octave_shlib::name_mangler mangler)
-{
-  void *function = 0;
+  void *
+  octave_w32_shlib::search (const std::string& name,
+                            dynamic_library::name_mangler mangler)
+  {
+    void *function = 0;
 
-  if (! is_open ())
-    (*current_liboctave_error_handler)
-      ("shared library %s is not open", file.c_str ());
+    if (! is_open ())
+      (*current_liboctave_error_handler)
+        ("shared library %s is not open", file.c_str ());
 
-  std::string sym_name = name;
+    std::string sym_name = name;
 
-  if (mangler)
-    sym_name = mangler (name);
+    if (mangler)
+      sym_name = mangler (name);
 
-  function = reinterpret_cast<void *> (GetProcAddress (handle,
-                                                       sym_name.c_str ()));
+    function = reinterpret_cast<void *> (GetProcAddress (handle,
+                                                         sym_name.c_str ()));
 
-  return function;
-}
+    return function;
+  }
 
 #elif defined (HAVE_DYLD_API)
 
-class
-octave_dyld_shlib : public octave_shlib::shlib_rep
-{
-public:
+  class
+  octave_dyld_shlib : public dynamic_library::dynlib_rep
+  {
+  public:
 
-  octave_dyld_shlib (void);
+    octave_dyld_shlib (void);
 
-  ~octave_dyld_shlib (void);
+    ~octave_dyld_shlib (void);
 
-  void open (const std::string& f);
+    void open (const std::string& f);
 
-  void *search (const std::string& name,
-                octave_shlib::name_mangler mangler = 0);
+    void *search (const std::string& name,
+                  dynamic_library::name_mangler mangler = 0);
 
-  void close (octave_shlib::close_hook cl_hook = 0);
+    void close (dynamic_library::close_hook cl_hook = 0);
 
-  bool is_open (void) const {return (handle != 0); }
+    bool is_open (void) const {return (handle != 0); }
 
-private:
+  private:
 
-  // No copying!
+    // No copying!
 
-  octave_dyld_shlib (const octave_dyld_shlib&);
+    octave_dyld_shlib (const octave_dyld_shlib&);
 
-  octave_dyld_shlib& operator = (const octave_dyld_shlib&);
+    octave_dyld_shlib& operator = (const octave_dyld_shlib&);
 
-  NSObjectFileImage img;
-  NSModule handle;
-};
+    NSObjectFileImage img;
+    NSModule handle;
+  };
 
-octave_dyld_shlib::octave_dyld_shlib (const std::string& f)
-  : octave_shlib::shlib_rep (f), handle (0)
-{
-  int returnCode = NSCreateObjectFileImageFromFile (file.c_str (), &img);
+  octave_dyld_shlib::octave_dyld_shlib (const std::string& f)
+    : dynamic_library::dynlib_rep (f), handle (0)
+  {
+    int returnCode = NSCreateObjectFileImageFromFile (file.c_str (), &img);
 
-  if (NSObjectFileImageSuccess != returnCode)
-    {
-      (*current_liboctave_error_handler)
-        ("got NSObjectFileImageReturnCode %d", returnCode);
+    if (NSObjectFileImageSuccess != returnCode)
+      {
+        (*current_liboctave_error_handler)
+          ("got NSObjectFileImageReturnCode %d", returnCode);
 
-      // FIXME: should use NSLinkEditError () to get
-      //        more info on what went wrong.
-    }
+        // FIXME: should use NSLinkEditError () to get
+        //        more info on what went wrong.
+      }
 
-  handle = NSLinkModule (img, file.c_str (),
-                         (NSLINKMODULE_OPTION_RETURN_ON_ERROR
-                          | NSLINKMODULE_OPTION_PRIVATE));
-  if (! handle)
-    {
-      NSLinkEditErrors ler;
-      int lerno;
-      const char *file2;
-      const char *errstr = 0;
+    handle = NSLinkModule (img, file.c_str (),
+                           (NSLINKMODULE_OPTION_RETURN_ON_ERROR
+                            | NSLINKMODULE_OPTION_PRIVATE));
+    if (! handle)
+      {
+        NSLinkEditErrors ler;
+        int lerno;
+        const char *file2;
+        const char *errstr = 0;
 
-      NSLinkEditError (&ler, &lerno, &file2, &errstr);
+        NSLinkEditError (&ler, &lerno, &file2, &errstr);
 
-      if (! errstr)
-        errstr = "unspecified error";
+        if (! errstr)
+          errstr = "unspecified error";
 
-      (*current_liboctave_error_handler) ("%s: %s", file.c_str (), errstr);
-    }
-}
+        (*current_liboctave_error_handler) ("%s: %s", file.c_str (), errstr);
+      }
+  }
 
-octave_dyld_shlib::~octave_dyld_shlib (void)
-{
-  if (handle)
-    NSUnLinkModule (handle, NSUNLINKMODULE_OPTION_RESET_LAZY_REFERENCES);
+  octave_dyld_shlib::~octave_dyld_shlib (void)
+  {
+    if (handle)
+      NSUnLinkModule (handle, NSUNLINKMODULE_OPTION_RESET_LAZY_REFERENCES);
 
-  NSDestroyObjectFileImage (img);
-}
+    NSDestroyObjectFileImage (img);
+  }
 
-void *
-octave_dyld_shlib::search (const std::string& name,
-                           octave_shlib::name_mangler mangler)
-{
-  void *function = 0;
+  void *
+  octave_dyld_shlib::search (const std::string& name,
+                             dynamic_library::name_mangler mangler)
+  {
+    void *function = 0;
 
-  if (! is_open ())
-    (*current_liboctave_error_handler)
-      ("bundle %s is not open", file.c_str ());
+    if (! is_open ())
+      (*current_liboctave_error_handler)
+        ("bundle %s is not open", file.c_str ());
 
-  std::string sym_name = name;
+    std::string sym_name = name;
 
-  if (mangler)
-    sym_name = mangler (name);
+    if (mangler)
+      sym_name = mangler (name);
 
-  NSSymbol symbol = NSLookupSymbolInModule (handle, sym_name.c_str ());
+    NSSymbol symbol = NSLookupSymbolInModule (handle, sym_name.c_str ());
 
-  if (symbol)
-    {
-      function = NSAddressOfSymbol (symbol);
-    }
+    if (symbol)
+      {
+        function = NSAddressOfSymbol (symbol);
+      }
 
-  return function;
-}
+    return function;
+  }
 
 #endif
 
-octave_shlib::shlib_rep *
-octave_shlib::shlib_rep::new_instance (const std::string& f)
-{
+  dynamic_library::dynlib_rep *
+  dynamic_library::dynlib_rep::new_instance (const std::string& f)
+  {
 #if defined (HAVE_DLOPEN_API)
-  return new octave_dlopen_shlib (f);
+    return new octave_dlopen_shlib (f);
 #elif defined (HAVE_SHL_LOAD_API)
-  return new octave_shl_load_shlib (f);
+    return new octave_shl_load_shlib (f);
 #elif defined (HAVE_LOADLIBRARY_API)
-  return new octave_w32_shlib (f);
+    return new octave_w32_shlib (f);
 #elif defined (HAVE_DYLD_API)
-  return new octave_dyld_shlib (f);
+    return new octave_dyld_shlib (f);
 #else
-  (*current_liboctave_error_handler)
-    ("support for dynamically loaded libraries was unavailable or disabled when liboctave was built");
+    (*current_liboctave_error_handler)
+      ("support for dynamically loaded libraries was unavailable or disabled when liboctave was built");
 #endif
+  }
 }
diff --git a/liboctave/util/oct-shlib.h b/liboctave/util/oct-shlib.h
--- a/liboctave/util/oct-shlib.h
+++ b/liboctave/util/oct-shlib.h
@@ -27,168 +27,178 @@ along with Octave; see the file COPYING.
 #include "octave-config.h"
 
 #include <string>
 #include <map>
 
 #include "oct-time.h"
 #include "oct-refcount.h"
 
-class
-OCTAVE_API
-octave_shlib
+namespace octave
 {
-public: // FIXME: make this class private?
+  class
+  OCTAVE_API
+  dynamic_library
+  {
+  public: // FIXME: make this class private?
 
-  typedef std::string (*name_mangler) (const std::string&);
-  typedef void (*close_hook) (const std::string&);
+    typedef std::string (*name_mangler) (const std::string&);
+    typedef void (*close_hook) (const std::string&);
 
-  class shlib_rep
-  {
-  public:
+    class dynlib_rep
+    {
+    public:
+
+      dynlib_rep (void)
+        : count (1), file (), tm_loaded (time_t ()), fcn_names () { }
+
+    protected:
 
-    shlib_rep (void)
-      : count (1), file (), tm_loaded (time_t ()), fcn_names () { }
+      dynlib_rep (const std::string& f);
+
+    public:
 
-  protected:
-
-    shlib_rep (const std::string& f);
+      virtual ~dynlib_rep (void)
+      {
+        instances.erase (file);
+      }
 
-  public:
+      virtual bool is_open (void) const
+      { return false; }
 
-    virtual ~shlib_rep (void)
-    {
-      instances.erase (file);
-    }
+      virtual void *search (const std::string&, name_mangler = 0)
+      { return 0; }
+
+      bool is_out_of_date (void) const;
+
+      // This method will be overridden conditionally.
+      static dynlib_rep *new_instance (const std::string& f);
 
-    virtual bool is_open (void) const
-    { return false; }
+      static dynlib_rep *get_instance (const std::string& f, bool fake);
+
+      octave::sys::time time_loaded (void) const
+      { return tm_loaded; }
 
-    virtual void *search (const std::string&, name_mangler = 0)
-    { return 0; }
+      std::string file_name (void) const
+      { return file; }
+
+      size_t num_fcn_names (void) const { return fcn_names.size (); }
 
-    bool is_out_of_date (void) const;
+      void add_fcn_name (const std::string&);
+
+      bool remove_fcn_name (const std::string&);
 
-    // This method will be overridden conditionally.
-    static shlib_rep *new_instance (const std::string& f);
+      void do_close_hook (close_hook cl_hook);
 
-    static shlib_rep *get_instance (const std::string& f, bool fake);
+    public:
+
+      octave_refcount<int> count;
 
-    octave::sys::time time_loaded (void) const
-    { return tm_loaded; }
+    protected:
 
-    std::string file_name (void) const
-    { return file; }
+      void fake_reload (void);
+
+      std::string file;
+      octave::sys::time tm_loaded;
 
-    size_t num_fcn_names (void) const { return fcn_names.size (); }
+      // Set of hooked function names.
+      typedef std::map<std::string, size_t>::iterator fcn_names_iterator;
+      typedef std::map<std::string, size_t>::const_iterator fcn_names_const_iterator;
 
-    void add_fcn_name (const std::string&);
+      std::map<std::string, size_t> fcn_names;
 
-    bool remove_fcn_name (const std::string&);
+      static std::map<std::string, dynlib_rep *> instances;
+    };
 
-    void do_close_hook (close_hook cl_hook);
+  private:
+
+    static dynlib_rep nil_rep;
 
   public:
 
-    octave_refcount<int> count;
-
-  protected:
-
-    void fake_reload (void);
-
-    std::string file;
-    octave::sys::time tm_loaded;
-
-    // Set of hooked function names.
-    typedef std::map<std::string, size_t>::iterator fcn_names_iterator;
-    typedef std::map<std::string, size_t>::const_iterator fcn_names_const_iterator;
-
-    std::map<std::string, size_t> fcn_names;
-
-    static std::map<std::string, shlib_rep *> instances;
-  };
-
-private:
-
-  static shlib_rep nil_rep;
+    dynamic_library (void) : rep (&nil_rep) { rep->count++; }
 
-public:
-
-  octave_shlib (void) : rep (&nil_rep) { rep->count++; }
-
-  octave_shlib (const std::string& f, bool fake = true)
-    : rep (shlib_rep::get_instance (f, fake)) { }
+    dynamic_library (const std::string& f, bool fake = true)
+      : rep (dynlib_rep::get_instance (f, fake)) { }
 
-  ~octave_shlib (void)
-  {
-    if (--rep->count == 0)
-      delete rep;
-  }
-
-  octave_shlib (const octave_shlib& sl)
-    : rep (sl.rep)
-  {
-    rep->count++;
-  }
-
-  octave_shlib& operator = (const octave_shlib& sl)
-  {
-    if (rep != sl.rep)
+    ~dynamic_library (void)
       {
         if (--rep->count == 0)
           delete rep;
+      }
 
-        rep = sl.rep;
+    dynamic_library (const dynamic_library& sl)
+      : rep (sl.rep)
+      {
         rep->count++;
       }
 
-    return *this;
-  }
+    dynamic_library& operator = (const dynamic_library& sl)
+      {
+        if (rep != sl.rep)
+          {
+            if (--rep->count == 0)
+              delete rep;
 
-  bool operator == (const octave_shlib& sl) const
-  { return (rep == sl.rep); }
+            rep = sl.rep;
+            rep->count++;
+          }
 
-  operator bool () const { return rep->is_open (); }
-
-  void open (const std::string& f)
-  { *this = octave_shlib (f); }
+        return *this;
+      }
 
-  void close (close_hook cl_hook = 0)
-  {
-    if (cl_hook)
-      rep->do_close_hook (cl_hook);
+    bool operator == (const dynamic_library& sl) const
+    { return (rep == sl.rep); }
+
+    operator bool () const { return rep->is_open (); }
+
+    void open (const std::string& f)
+    { *this = dynamic_library (f); }
 
-    *this = octave_shlib ();
-  }
+    void close (close_hook cl_hook = 0)
+    {
+      if (cl_hook)
+        rep->do_close_hook (cl_hook);
 
-  void *search (const std::string& nm, name_mangler mangler = 0) const
-  {
-    void *f = rep->search (nm, mangler);
-    if (f)
-      rep->add_fcn_name (nm);
+      *this = dynamic_library ();
+    }
 
-    return f;
-  }
+    void *search (const std::string& nm, name_mangler mangler = 0) const
+    {
+      void *f = rep->search (nm, mangler);
+      if (f)
+        rep->add_fcn_name (nm);
 
-  void add (const std::string& name)
-  { rep->add_fcn_name (name); }
+      return f;
+    }
 
-  bool remove (const std::string& name)
-  { return rep->remove_fcn_name (name); }
+    void add (const std::string& name)
+    { rep->add_fcn_name (name); }
 
-  size_t number_of_functions_loaded (void) const
-  { return rep->num_fcn_names (); }
+    bool remove (const std::string& name)
+    { return rep->remove_fcn_name (name); }
+
+    size_t number_of_functions_loaded (void) const
+    { return rep->num_fcn_names (); }
 
-  bool is_out_of_date (void) const
-  { return rep->is_out_of_date (); }
+    bool is_out_of_date (void) const
+    { return rep->is_out_of_date (); }
 
-  std::string file_name (void) const
-  { return rep->file_name (); }
+    std::string file_name (void) const
+    { return rep->file_name (); }
+
+    octave::sys::time time_loaded (void) const
+    { return rep->time_loaded (); }
 
-  octave::sys::time time_loaded (void) const
-  { return rep->time_loaded (); }
+  private:
 
-private:
+    dynlib_rep *rep;
+  };
+}
 
-  shlib_rep *rep;
-};
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
+
+OCTAVE_DEPRECATED ("use octave::dynamic_library instead")
+typedef octave::dynamic_library octave_shlib;
 
 #endif
+
+#endif
