# HG changeset patch
# User CarnÃ« Draug <carandraug@octave.org>
# Date 1432431697 -3600
#      Sun May 24 02:41:37 2015 +0100
# Node ID 00cf2847355d9ee3c167ed7e71400b4860ce31ac
# Parent  9f484edd8767da34dc26fbab1e9970205734ad1c
Deprecate Array::nelem() and Range::nelem() in favour of ::numel().

* liboctave/array/Array.h (Array::nelem) deprecate in favour of numel().
  (Array::capacity, Array:: length): change to call numel() directly. These
  methods will be deprecated soon.
* liboctave/array/PermMatrix.h (PermMatrix::nelem): deprecate in favour of
  numel().
* liboctave/array/Range.h (Range::numel) new method to replace nelem().
  (Range::nelem) deprecate in favour of the new method numel.
* liboctave/array/Sparse.h (Sparse::nelem) deprecate in favour of nzmax().
  This one is secially bad because unlike the other classes, it is different
  from numel().
* libinterp/corefcn/debug.cc, libinterp/corefcn/jit-typeinfo.cc,
  libinterp/corefcn/ls-mat4.cc, libinterp/corefcn/lu.cc,
  libinterp/corefcn/luinc.cc, libinterp/corefcn/max.cc,
  libinterp/corefcn/pr-output.cc, libinterp/corefcn/rand.cc,
  libinterp/corefcn/xpow.cc, libinterp/dldfcn/__magick_read__.cc,
  libinterp/dldfcn/audioread.cc, libinterp/octave-value/ov-base-int.cc,
  libinterp/octave-value/ov-bool-mat.cc, libinterp/octave-value/ov-flt-re-mat.cc,
  libinterp/octave-value/ov-perm.cc, libinterp/octave-value/ov-range.cc,
  libinterp/octave-value/ov-range.h, libinterp/octave-value/ov-re-mat.cc,
  libinterp/parse-tree/pt-eval.cc, liboctave/array/Array.cc,
  liboctave/array/CNDArray.cc, liboctave/array/Range.cc,
  liboctave/array/dNDArray.cc, liboctave/array/fCNDArray.cc,
  liboctave/array/fNDArray.cc, liboctave/array/idx-vector.cc,
  liboctave/array/intNDArray.cc, liboctave/numeric/SparseCmplxLU.cc,
  liboctave/numeric/SparsedbleLU.cc: replace use of nelem() with numel().

diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -258,17 +258,17 @@ parse_dbfunction_params (const char *who
         octave_stdout << who << ": skipping struct input" << std::endl;
       else
         {
           const NDArray arg = args(i).array_value ();
 
           if (error_state)
             break;
 
-          for (octave_idx_type j = 0; j < arg.nelem (); j++)
+          for (octave_idx_type j = 0; j < arg.numel (); j++)
             {
               int line = static_cast<int> (arg.elem (j));
               if (error_state)
                 break;
               lines[list_idx++] = line;
             }
 
           if (error_state)
diff --git a/libinterp/corefcn/jit-typeinfo.cc b/libinterp/corefcn/jit-typeinfo.cc
--- a/libinterp/corefcn/jit-typeinfo.cc
+++ b/libinterp/corefcn/jit-typeinfo.cc
@@ -252,17 +252,17 @@ octave_jit_gindex_range (int nd, int dim
     }
 }
 
 extern "C" jit_matrix
 octave_jit_paren_subsasgn_impl (jit_matrix *mat, octave_idx_type index,
                                 double value)
 {
   NDArray *array = mat->array;
-  if (array->nelem () < index)
+  if (array->numel () < index)
     array->resize1 (index);
 
   double *data = array->fortran_vec ();
   data[index - 1] = value;
 
   mat->update ();
   return *mat;
 }
diff --git a/libinterp/corefcn/ls-mat4.cc b/libinterp/corefcn/ls-mat4.cc
--- a/libinterp/corefcn/ls-mat4.cc
+++ b/libinterp/corefcn/ls-mat4.cc
@@ -493,17 +493,17 @@ save_mat_binary_data (std::ostream& os, 
                                 sizeof (double);
       os.write (reinterpret_cast<char *> (buf), n_bytes);
     }
   else if (tc.is_range ())
     {
       Range r = tc.range_value ();
       double base = r.base ();
       double inc = r.inc ();
-      octave_idx_type nel = r.nelem ();
+      octave_idx_type nel = r.numel ();
       for (octave_idx_type i = 0; i < nel; i++)
         {
           double x = base + i * inc;
           os.write (reinterpret_cast<char *> (&x), 8);
         }
     }
   else if (tc.is_real_scalar ())
     {
diff --git a/libinterp/corefcn/lu.cc b/libinterp/corefcn/lu.cc
--- a/libinterp/corefcn/lu.cc
+++ b/libinterp/corefcn/lu.cc
@@ -172,23 +172,23 @@ information.\n\
       else
         {
           Matrix tmp = args(n++).matrix_value ();
 
           if (! error_state)
             {
               if (!issparse)
                 error ("lu: can not define pivoting threshold THRES for full matrices");
-              else if (tmp.nelem () == 1)
+              else if (tmp.numel () == 1)
                 {
                   thres.resize (1,2);
                   thres(0) = tmp(0);
                   thres(1) = tmp(0);
                 }
-              else if (tmp.nelem () == 2)
+              else if (tmp.numel () == 2)
                 thres = tmp;
               else
                 error ("lu: expecting 2-element vector for THRES");
             }
         }
     }
 
   octave_value arg = args(0);
diff --git a/libinterp/corefcn/luinc.cc b/libinterp/corefcn/luinc.cc
--- a/libinterp/corefcn/luinc.cc
+++ b/libinterp/corefcn/luinc.cc
@@ -149,22 +149,22 @@ values of @var{p} @var{q} as vector valu
                   udiag = (val == 0. ? false : true);
                 }
 
               tmp = map.getfield ("thresh");
               if (tmp.is_defined ())
                 {
                   thresh = tmp.matrix_value ();
 
-                  if (thresh.nelem () == 1)
+                  if (thresh.numel () == 1)
                     {
                       thresh.resize (1,2);
                       thresh(1) = thresh(0);
                     }
-                  else if (thresh.nelem () != 2)
+                  else if (thresh.numel () != 2)
                     {
                       error ("luinc: expecting 2-element vector for thresh");
                       return retval;
                     }
                 }
             }
           else
             {
diff --git a/libinterp/corefcn/max.cc b/libinterp/corefcn/max.cc
--- a/libinterp/corefcn/max.cc
+++ b/libinterp/corefcn/max.cc
@@ -266,35 +266,35 @@ do_minmax_body (const octave_value_list&
 
       switch (arg.builtin_type ())
         {
         case btyp_double:
           {
             if (arg.is_range () && (dim == -1 || dim == 1))
               {
                 Range range = arg.range_value ();
-                if (range.nelem () < 1)
+                if (range.numel () < 1)
                   {
                     retval(0) = arg;
                     if (nargout > 1)
                       retval(1) = arg;
                   }
                 else if (ismin)
                   {
                     retval(0) = range.min ();
                     if (nargout > 1)
                       retval(1) = static_cast<double>
-                                  (range.inc () < 0 ? range.nelem () : 1);
+                                  (range.inc () < 0 ? range.numel () : 1);
                   }
                 else
                   {
                     retval(0) = range.max ();
                     if (nargout > 1)
                       retval(1) = static_cast<double>
-                                  (range.inc () >= 0 ? range.nelem () : 1);
+                                  (range.inc () >= 0 ? range.numel () : 1);
                   }
               }
             else if (arg.is_sparse_type ())
               retval = do_minmax_red_op<SparseMatrix> (arg, nargout, dim,
                                                        ismin);
             else
               retval = do_minmax_red_op<NDArray> (arg, nargout, dim, ismin);
             break;
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -2659,17 +2659,17 @@ octave_print_internal (std::ostream& os,
 
 void
 octave_print_internal (std::ostream& os, const Range& r,
                        bool pr_as_read_syntax, int extra_indent)
 {
   double base = r.base ();
   double increment = r.inc ();
   double limit = r.limit ();
-  octave_idx_type num_elem = r.nelem ();
+  octave_idx_type num_elem = r.numel ();
 
   if (plus_format && ! pr_as_read_syntax)
     {
       for (octave_idx_type i = 0; i < num_elem; i++)
         {
           octave_quit ();
 
           double val = base + i * increment;
diff --git a/libinterp/corefcn/rand.cc b/libinterp/corefcn/rand.cc
--- a/libinterp/corefcn/rand.cc
+++ b/libinterp/corefcn/rand.cc
@@ -185,17 +185,17 @@ do_rand (const octave_value_list& args, 
               }
           }
         else if (tmp.is_range ())
           {
             Range r = tmp.range_value ();
 
             if (r.all_elements_are_ints ())
               {
-                octave_idx_type n = r.nelem ();
+                octave_idx_type n = r.numel ();
 
                 dims.resize (n);
 
                 octave_idx_type base = NINTbig (r.base ());
                 octave_idx_type incr = NINTbig (r.inc ());
 
                 for (octave_idx_type i = 0; i < n; i++)
                   {
diff --git a/libinterp/corefcn/xpow.cc b/libinterp/corefcn/xpow.cc
--- a/libinterp/corefcn/xpow.cc
+++ b/libinterp/corefcn/xpow.cc
@@ -700,20 +700,20 @@ same_sign (double a, double b)
 
 octave_value
 elem_xpow (double a, const Range& r)
 {
   octave_value retval;
 
   // Only optimize powers with ranges that are integer and monotonic in
   // magnitude.
-  if (r.nelem () > 1 && r.all_elements_are_ints ()
+  if (r.numel () > 1 && r.all_elements_are_ints ()
       && same_sign (r.base (), r.limit ()))
     {
-      octave_idx_type n = r.nelem ();
+      octave_idx_type n = r.numel ();
       Matrix result (1, n);
       if (same_sign (r.base (), r.inc ()))
         {
           double base = std::pow (a, r.base ());
           double inc = std::pow (a, r.inc ());
           result(0) = base;
           for (octave_idx_type i = 1; i < n; i++)
             result(i) = (base *= inc);
@@ -935,20 +935,20 @@ elem_xpow (const Complex& a, const Compl
 
 octave_value
 elem_xpow (const Complex& a, const Range& r)
 {
   octave_value retval;
 
   // Only optimize powers with ranges that are integer and monotonic in
   // magnitude.
-  if (r.nelem () > 1 && r.all_elements_are_ints ()
+  if (r.numel () > 1 && r.all_elements_are_ints ()
       && same_sign (r.base (), r.limit ()))
     {
-      octave_idx_type n = r.nelem ();
+      octave_idx_type n = r.numel ();
       ComplexMatrix result (1, n);
 
       if (same_sign (r.base (), r.inc ()))
         {
           Complex base = std::pow (a, r.base ());
           Complex inc = std::pow (a, r.inc ());
           result(0) = base;
           for (octave_idx_type i = 1; i < n; i++)
diff --git a/libinterp/dldfcn/__magick_read__.cc b/libinterp/dldfcn/__magick_read__.cc
--- a/libinterp/dldfcn/__magick_read__.cc
+++ b/libinterp/dldfcn/__magick_read__.cc
@@ -172,18 +172,18 @@ calculate_region (const octave_scalar_ma
   region["col_cache"] = region["col_end"] - region["col_start"] +1;
 
   // How much we have to shift in the memory when doing the loops.
   region["row_shift"] = region["col_cache"] * rows.inc ();
   region["col_shift"] = region["col_cache"] *
                         (region["row_cache"] + rows.inc () -1) - cols.inc ();
 
   // The actual height and width of the output image
-  region["row_out"] = rows.nelem ();
-  region["col_out"] = cols.nelem ();
+  region["row_out"] = rows.numel ();
+  region["col_out"] = cols.numel ();
 
   return region;
 }
 
 static octave_value_list
 read_maps (Magick::Image& img)
 {
   // can't call colorMapSize on const Magick::Image
@@ -771,17 +771,17 @@ Use @code{imread} instead.\n\
       frameidx = indexes.int_vector_value ();
       if (error_state)
         {
           error ("__magick_read__: invalid value for Index/Frame");
           return output;
         }
       // Fix indexes from base 1 to base 0, and at the same time, make
       // sure none of the indexes is outside the range of image number.
-      const octave_idx_type n = frameidx.nelem ();
+      const octave_idx_type n = frameidx.numel ();
       for (octave_idx_type i = 0; i < n; i++)
         {
           frameidx(i)--;
           if (frameidx(i) < 0 || frameidx(i) > nFrames - 1)
             {
               // We do this check inside the loop because frameidx does not
               // need to be ordered (this is a feature and even allows for
               // some frames to be read multiple times).
@@ -793,17 +793,17 @@ Use @code{imread} instead.\n\
 
   // Check that all frames have the same size. We don't do this at the same
   // time we decode the image because that's done in many different places,
   // to cover the different types of images which would lead to a lot of
   // copy and paste.
   {
     const unsigned int nRows = imvec[frameidx(0)].rows ();
     const unsigned int nCols = imvec[frameidx(0)].columns ();
-    const octave_idx_type n = frameidx.nelem ();
+    const octave_idx_type n = frameidx.numel ();
     for (octave_idx_type frame = 0; frame < n; frame++)
       {
         if (nRows != imvec[frameidx(frame)].rows ()
             || nCols != imvec[frameidx(frame)].columns ())
           {
             error ("imread: all frames must have the same size but frame %i is different",
                    frameidx(frame) +1);
             return output;
diff --git a/libinterp/dldfcn/audioread.cc b/libinterp/dldfcn/audioread.cc
--- a/libinterp/dldfcn/audioread.cc
+++ b/libinterp/dldfcn/audioread.cc
@@ -110,17 +110,17 @@ is stored in the audio file.\n\
 
   if ((nargin == 2 && ! args(1).is_string ()) || nargin == 3)
     {
       RowVector range = args(1).row_vector_value ();
 
       if (error_state)
         return retval;
 
-      if (range.nelem () != 2)
+      if (range.numel () != 2)
         {
           error ("audioread: invalid specification for range of frames");
           return retval;
         }
 
       double dstart = xisinf (range(0)) ? info.frames : range(0);
       double dend = xisinf (range(1)) ? info.frames : range(1);
 
diff --git a/libinterp/octave-value/ov-base-int.cc b/libinterp/octave-value/ov-base-int.cc
--- a/libinterp/octave-value/ov-base-int.cc
+++ b/libinterp/octave-value/ov-base-int.cc
@@ -124,17 +124,17 @@ struct octave_base_int_helper_traits<uns
 
 
 template <class T>
 octave_base_value *
 octave_base_int_matrix<T>::try_narrowing_conversion (void)
 {
   octave_base_value *retval = 0;
 
-  if (this->matrix.nelem () == 1)
+  if (this->matrix.numel () == 1)
     retval = new typename octave_value_int_traits<T>::scalar_type
                (this->matrix (0));
 
   return retval;
 }
 
 template <class T>
 octave_value
diff --git a/libinterp/octave-value/ov-bool-mat.cc b/libinterp/octave-value/ov-bool-mat.cc
--- a/libinterp/octave-value/ov-bool-mat.cc
+++ b/libinterp/octave-value/ov-bool-mat.cc
@@ -247,17 +247,17 @@ octave_bool_matrix::load_ascii (std::ist
                     matrix = btmp;
                   else
                     {
                       NDArray tmp(dv);
                       is >> tmp;
 
                       if (is)
                         {
-                          for (octave_idx_type i = 0; i < btmp.nelem (); i++)
+                          for (octave_idx_type i = 0; i < btmp.numel (); i++)
                             btmp.elem (i) = (tmp.elem (i) != 0.);
 
                           matrix = btmp;
                         }
                       else
                         {
                           error ("load: failed to load matrix constant");
                           success = false;
@@ -339,17 +339,17 @@ octave_bool_matrix::save_binary (std::os
   for (int i = 0; i < d.length (); i++)
     {
       tmp = d(i);
       os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
   boolNDArray m = bool_array_value ();
   bool *mtmp = m.fortran_vec ();
-  octave_idx_type nel = m.nelem ();
+  octave_idx_type nel = m.numel ();
   OCTAVE_LOCAL_BUFFER (char, htmp, nel);
 
   for (octave_idx_type i = 0; i < nel; i++)
     htmp[i] = (mtmp[i] ? 1 : 0);
 
   os.write (htmp, nel);
 
   return true;
@@ -443,17 +443,17 @@ octave_bool_matrix::save_hdf5 (octave_hd
                         H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
 
-  octave_idx_type nel = m.nelem ();
+  octave_idx_type nel = m.numel ();
   bool *mtmp = m.fortran_vec ();
   OCTAVE_LOCAL_BUFFER (hbool_t, htmp, nel);
 
   for (octave_idx_type i = 0; i < nel; i++)
     htmp[i] = mtmp[i];
 
   retval = H5Dwrite (data_hid, H5T_NATIVE_HBOOL, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, htmp) >= 0;
diff --git a/libinterp/octave-value/ov-flt-re-mat.cc b/libinterp/octave-value/ov-flt-re-mat.cc
--- a/libinterp/octave-value/ov-flt-re-mat.cc
+++ b/libinterp/octave-value/ov-flt-re-mat.cc
@@ -75,17 +75,17 @@ template class octave_base_matrix<FloatN
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_float_matrix, "float matrix",
                                      "single");
 
 octave_base_value *
 octave_float_matrix::try_narrowing_conversion (void)
 {
   octave_base_value *retval = 0;
 
-  if (matrix.nelem () == 1)
+  if (matrix.numel () == 1)
     retval = new octave_float_scalar (matrix (0));
 
   return retval;
 }
 
 double
 octave_float_matrix::double_value (bool) const
 {
diff --git a/libinterp/octave-value/ov-perm.cc b/libinterp/octave-value/ov-perm.cc
--- a/libinterp/octave-value/ov-perm.cc
+++ b/libinterp/octave-value/ov-perm.cc
@@ -434,17 +434,17 @@ octave_perm_matrix::numeric_conversion_f
                                             octave_matrix::static_type_id ());
 }
 
 octave_base_value *
 octave_perm_matrix::try_narrowing_conversion (void)
 {
   octave_base_value *retval = 0;
 
-  if (matrix.nelem () == 1)
+  if (matrix.numel () == 1)
     retval = new octave_scalar (matrix (0, 0));
 
   return retval;
 }
 
 octave_value
 octave_perm_matrix::fast_elem_extract (octave_idx_type n) const
 {
diff --git a/libinterp/octave-value/ov-range.cc b/libinterp/octave-value/ov-range.cc
--- a/libinterp/octave-value/ov-range.cc
+++ b/libinterp/octave-value/ov-range.cc
@@ -67,17 +67,17 @@ octave_range::numeric_conversion_functio
                                             octave_matrix::static_type_id ());
 }
 
 octave_base_value *
 octave_range::try_narrowing_conversion (void)
 {
   octave_base_value *retval = 0;
 
-  switch (range.nelem ())
+  switch (range.numel ())
     {
     case 1:
       retval = new octave_scalar (range.base ());
       break;
 
     case 0:
       retval = new octave_matrix (Matrix (1, 0));
       break;
@@ -126,17 +126,17 @@ octave_range::do_index_op (const octave_
   if (idx.length () == 1 && ! resize_ok)
     {
       octave_value retval;
 
       // The range can handle a single subscript.
       idx_vector i = idx(0).index_vector ();
       if (! error_state)
         {
-          if (i.is_scalar () && i(0) < range.nelem ())
+          if (i.is_scalar () && i(0) < range.numel ())
             retval = range.elem (i(0));
           else
             retval = range.index (i);
         }
 
       return retval;
     }
   else
@@ -168,17 +168,17 @@ octave_range::index_vector (bool require
     }
 }
 
 double
 octave_range::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
-  octave_idx_type nel = range.nelem ();
+  octave_idx_type nel = range.numel ();
 
   if (nel > 0)
     {
       gripe_implicit_conversion ("Octave:array-to-scalar",
                                  "range", "real scalar");
 
       retval = range.base ();
     }
@@ -188,17 +188,17 @@ octave_range::double_value (bool) const
   return retval;
 }
 
 float
 octave_range::float_value (bool) const
 {
   float retval = lo_ieee_float_nan_value ();
 
-  octave_idx_type nel = range.nelem ();
+  octave_idx_type nel = range.numel ();
 
   if (nel > 0)
     {
       gripe_implicit_conversion ("Octave:array-to-scalar",
                                  "range", "real scalar");
 
       retval = range.base ();
     }
@@ -259,17 +259,17 @@ octave_range::diag (octave_idx_type m, o
   return mat.diag (m, n);
 }
 
 bool
 octave_range::is_true (void) const
 {
   bool retval = false;
 
-  if (range.nelem () != 0)
+  if (range.numel () != 0)
     {
       // FIXME: this is a potential waste of memory.
 
       Matrix m ((range.matrix_value () . all ()) . all ());
 
       retval = (m.rows () == 1 && m.columns () == 1 && m (0, 0) != 0.0);
     }
 
@@ -278,17 +278,17 @@ octave_range::is_true (void) const
 
 Complex
 octave_range::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
-  octave_idx_type nel = range.nelem ();
+  octave_idx_type nel = range.numel ();
 
   if (nel > 0)
     {
       gripe_implicit_conversion ("Octave:array-to-scalar",
                                  "range", "complex scalar");
 
       retval = range.base ();
     }
@@ -300,17 +300,17 @@ octave_range::complex_value (bool) const
 
 FloatComplex
 octave_range::float_complex_value (bool) const
 {
   float tmp = lo_ieee_float_nan_value ();
 
   FloatComplex retval (tmp, tmp);
 
-  octave_idx_type nel = range.nelem ();
+  octave_idx_type nel = range.numel ();
 
   if (nel > 0)
     {
       gripe_implicit_conversion ("Octave:array-to-scalar",
                                  "range", "complex scalar");
 
       retval = range.base ();
     }
@@ -365,17 +365,17 @@ octave_range::print_raw (std::ostream& o
                          current_print_indent_level ());
 }
 
 bool
 octave_range::print_name_tag (std::ostream& os, const std::string& name) const
 {
   bool retval = false;
 
-  octave_idx_type n = range.nelem ();
+  octave_idx_type n = range.numel ();
 
   indent (os);
 
   if (n == 0 || n == 1)
     os << name << " = ";
   else
     {
       os << name << " =";
@@ -387,17 +387,17 @@ octave_range::print_name_tag (std::ostre
     }
 
   return retval;
 }
 
 void
 octave_range::short_disp (std::ostream& os) const
 {
-  octave_idx_type len = range.nelem ();
+  octave_idx_type len = range.numel ();
 
   if (len == 0)
     os << "[]";
   else
     {
       os << range.base () << ":";
 
       if (len > 1)
@@ -429,17 +429,17 @@ skip_comments (std::istream& is)
 
 bool
 octave_range::save_ascii (std::ostream& os)
 {
   Range r = range_value ();
   double base = r.base ();
   double limit = r.limit ();
   double inc = r.inc ();
-  octave_idx_type len = r.nelem ();
+  octave_idx_type len = r.numel ();
 
   if (inc != 0)
     os << "# base, limit, increment\n";
   else
     os << "# base, length, increment\n";
 
   octave_write_double (os, base);
   os << " ";
@@ -482,17 +482,17 @@ octave_range::save_binary (std::ostream&
 {
   char tmp = LS_DOUBLE;
   os.write (reinterpret_cast<char *> (&tmp), 1);
   Range r = range_value ();
   double bas = r.base ();
   double lim = r.limit ();
   double inc = r.inc ();
   if (inc == 0)
-    lim = r.nelem ();
+    lim = r.numel ();
 
   os.write (reinterpret_cast<char *> (&bas), 8);
   os.write (reinterpret_cast<char *> (&lim), 8);
   os.write (reinterpret_cast<char *> (&inc), 8);
 
   return true;
 }
 
@@ -578,23 +578,23 @@ octave_range::save_hdf5 (octave_hdf5_id 
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       return false;
     }
 
   Range r = range_value ();
   double range_vals[3];
   range_vals[0] = r.base ();
-  range_vals[1] = r.inc () != 0 ? r.limit () : r.nelem ();
+  range_vals[1] = r.inc () != 0 ? r.limit () : r.numel ();
   range_vals[2] = r.inc ();
 
   if (H5Dwrite (data_hid, type_hid, H5S_ALL, H5S_ALL, H5P_DEFAULT,
                 range_vals) >= 0)
     {
-      octave_idx_type nel = r.nelem ();
+      octave_idx_type nel = r.numel ();
       retval = hdf5_add_scalar_attr (data_hid, H5T_NATIVE_IDX,
                                      "OCTAVE_RANGE_NELEM", &nel) >= 0;
     }
   else
     retval = false;
 
   H5Dclose (data_hid);
   H5Tclose (type_hid);
@@ -688,17 +688,17 @@ octave_range::as_mxArray (void) const
     pr[i] = p[i];
 
   return retval;
 }
 
 octave_value
 octave_range::fast_elem_extract (octave_idx_type n) const
 {
-  return (n < range.nelem ()) ? octave_value (range.elem (n))
+  return (n < range.numel ()) ? octave_value (range.elem (n))
                               : octave_value ();
 }
 
 DEFUN (allow_noninteger_range_as_index, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} allow_noninteger_range_as_index ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} allow_noninteger_range_as_index (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} allow_noninteger_range_as_index (@var{new_val}, \"local\")\n\
diff --git a/libinterp/octave-value/ov-range.h b/libinterp/octave-value/ov-range.h
--- a/libinterp/octave-value/ov-range.h
+++ b/libinterp/octave-value/ov-range.h
@@ -53,24 +53,24 @@ octave_range : public octave_base_value
 public:
 
   octave_range (void)
     : octave_base_value (), range (), idx_cache () { }
 
   octave_range (double base, double limit, double inc)
     : octave_base_value (), range (base, limit, inc), idx_cache ()
   {
-    if (range.nelem () < 0)
+    if (range.numel () < 0)
       ::error ("invalid range");
   }
 
   octave_range (const Range& r)
     : octave_base_value (), range (r), idx_cache ()
   {
-    if (range.nelem () < 0 && range.nelem () != -2)
+    if (range.numel () < 0 && range.numel () != -2)
       ::error ("invalid range");
   }
 
   octave_range (const octave_range& r)
     : octave_base_value (), range (r.range),
       idx_cache (r.idx_cache ? new idx_vector (*r.idx_cache) : 0)
   { }
 
@@ -102,17 +102,17 @@ public:
 
   octave_value do_index_op (const octave_value_list& idx,
                             bool resize_ok = false);
 
   idx_vector index_vector (bool require_integers = false) const;
 
   dim_vector dims (void) const
   {
-    octave_idx_type n = range.nelem ();
+    octave_idx_type n = range.numel ();
     return dim_vector (n > 0, n);
   }
 
   octave_value resize (const dim_vector& dv, bool fill = false) const;
 
 
   size_t byte_size (void) const { return 3 * sizeof (double); }
 
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -90,17 +90,17 @@ octave_matrix::numeric_demotion_function
             octave_float_matrix::static_type_id ());
 }
 
 octave_base_value *
 octave_matrix::try_narrowing_conversion (void)
 {
   octave_base_value *retval = 0;
 
-  if (matrix.nelem () == 1)
+  if (matrix.numel () == 1)
     retval = new octave_scalar (matrix (0));
 
   return retval;
 }
 
 double
 octave_matrix::double_value (bool) const
 {
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -332,17 +332,17 @@ tree_evaluator::visit_simple_for_command
       return;
 
     tree_statement_list *loop_body = cmd.body ();
 
     if (rhs.is_range ())
       {
         Range rng = rhs.range_value ();
 
-        octave_idx_type steps = rng.nelem ();
+        octave_idx_type steps = rng.numel ();
 
         for (octave_idx_type i = 0; i < steps; i++)
           {
             octave_value val (rng.elem (i));
 
             ult.assign (octave_value::op_asn_eq, val);
 
             if (! error_state && loop_body)
diff --git a/liboctave/array/Array.cc b/liboctave/array/Array.cc
--- a/liboctave/array/Array.cc
+++ b/liboctave/array/Array.cc
@@ -2226,33 +2226,33 @@ Array<T>::lookup (const Array<T>& values
   return idx;
 }
 
 template <class T>
 octave_idx_type
 Array<T>::nnz (void) const
 {
   const T *src = data ();
-  octave_idx_type nel = nelem ();
+  octave_idx_type nel = numel ();
   octave_idx_type retval = 0;
   const T zero = T ();
   for (octave_idx_type i = 0; i < nel; i++)
     if (src[i] != zero)
       retval++;
 
   return retval;
 }
 
 template <class T>
 Array<octave_idx_type>
 Array<T>::find (octave_idx_type n, bool backward) const
 {
   Array<octave_idx_type> retval;
   const T *src = data ();
-  octave_idx_type nel = nelem ();
+  octave_idx_type nel = numel ();
   const T zero = T ();
   if (n < 0 || n >= nel)
     {
       // We want all elements, which means we'll almost surely need
       // to resize. So count first, then allocate array of exact size.
       octave_idx_type cnt = 0;
       for (octave_idx_type i = 0; i < nel; i++)
         cnt += src[i] != zero;
diff --git a/liboctave/array/Array.h b/liboctave/array/Array.h
--- a/liboctave/array/Array.h
+++ b/liboctave/array/Array.h
@@ -247,37 +247,40 @@ public:
   void clear (const dim_vector& dv);
 
   void clear (octave_idx_type r, octave_idx_type c)
   { clear (dim_vector (r, c)); }
 
   // Number of elements in the array. These are all synonyms.
   //@{
   //! Number of elements in the array.
-  //! Synonymous with length(), nelem(), and numel().
-  octave_idx_type capacity (void) const { return slice_len; }
+  //! Synonymous with numel().
+  octave_idx_type capacity (void) const { return numel (); }
 
   //! Number of elements in the array.
-  /*! Synonymous with capacity(), nelem(), and numel().
+  /*! Synonymous with capacity() and numel().
+
+      @note This method is deprecated in favour of numel().
 
       @note
       This is @em not the same as @c %length() at the Octave interpreter.
       At the Octave interpreter, the function @c %length() returns the
       length of the greatest dimension.  This method returns the total
       number of elements.
    */
-  octave_idx_type length (void) const { return capacity (); }
+  octave_idx_type length (void) const { return numel (); }
 
   //! Number of elements in the array.
-  //! Synonymous with capacity(), length(), and numel().
-  octave_idx_type nelem (void) const { return capacity (); }
+  //! Synonymous with capacity() and numel().
+  //! @note This method is deprecated in favour of numel().
+  GCC_ATTR_DEPRECATED octave_idx_type nelem (void) const { return numel (); }
 
   //! Number of elements in the array.
-  //! Synonymous with capacity(), length(), and nelem().
-  octave_idx_type numel (void) const { return nelem (); }
+  //! Synonymous with capacity().
+  octave_idx_type numel (void) const { return slice_len; }
   //@}
 
   //! Return the array as a column vector.
   Array<T> as_column (void) const
   {
     Array<T> retval (*this);
     if (dimensions.length () != 2 || dimensions(1) != 1)
       retval.dimensions = dim_vector (numel (), 1);
diff --git a/liboctave/array/CNDArray.cc b/liboctave/array/CNDArray.cc
--- a/liboctave/array/CNDArray.cc
+++ b/liboctave/array/CNDArray.cc
@@ -530,17 +530,17 @@ ComplexNDArray::all_elements_are_real (v
 
 // Return nonzero if any element of CM has a non-integer real or
 // imaginary part.  Also extract the largest and smallest (real or
 // imaginary) values and return them in MAX_VAL and MIN_VAL.
 
 bool
 ComplexNDArray::all_integers (double& max_val, double& min_val) const
 {
-  octave_idx_type nel = nelem ();
+  octave_idx_type nel = numel ();
 
   if (nel > 0)
     {
       Complex val = elem (0);
 
       double r_val = std::real (val);
       double i_val = std::imag (val);
 
@@ -841,31 +841,31 @@ ComplexNDArray::diag (octave_idx_type m,
 {
   return MArray<Complex>::diag (m, n);
 }
 
 // This contains no information on the array structure !!!
 std::ostream&
 operator << (std::ostream& os, const ComplexNDArray& a)
 {
-  octave_idx_type nel = a.nelem ();
+  octave_idx_type nel = a.numel ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       os << " ";
       octave_write_complex (os, a.elem (i));
       os << "\n";
     }
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, ComplexNDArray& a)
 {
-  octave_idx_type nel = a.nelem ();
+  octave_idx_type nel = a.numel ();
 
   if (nel > 0)
     {
       Complex tmp;
       for (octave_idx_type i = 0; i < nel; i++)
         {
           tmp = octave_read_value<Complex> (is);
           if (is)
diff --git a/liboctave/array/PermMatrix.h b/liboctave/array/PermMatrix.h
--- a/liboctave/array/PermMatrix.h
+++ b/liboctave/array/PermMatrix.h
@@ -56,18 +56,18 @@ public:
   octave_idx_type cols (void) const { return dim2 (); }
   octave_idx_type columns (void) const { return dim2 (); }
 
   octave_idx_type perm_length (void) const
   { return Array<octave_idx_type>::length (); }
   // FIXME: a dangerous ambiguity?
   octave_idx_type length (void) const
   { return perm_length (); }
-  octave_idx_type nelem (void) const { return dim1 () * dim2 (); }
-  octave_idx_type numel (void) const { return nelem (); }
+  GCC_ATTR_DEPRECATED octave_idx_type nelem (void) const { return numel (); }
+  octave_idx_type numel (void) const { return dim1 () * dim2 (); }
 
   size_t byte_size (void) const
   { return Array<octave_idx_type>::byte_size (); }
 
   dim_vector dims (void) const { return dim_vector (dim1 (), dim2 ()); }
 
   const Array<octave_idx_type>& col_perm_vec (void) const
   { return *this; }
diff --git a/liboctave/array/Range.cc b/liboctave/array/Range.cc
--- a/liboctave/array/Range.cc
+++ b/liboctave/array/Range.cc
@@ -39,61 +39,61 @@ along with Octave; see the file COPYING.
 bool
 Range::all_elements_are_ints (void) const
 {
   // If the base and increment are ints, the final value in the range
   // will also be an integer, even if the limit is not. If there is one
   // or fewer elements only the base needs to be an integer
 
   return (! (xisnan (rng_base) || xisnan (rng_inc))
-          && (NINTbig (rng_base) == rng_base || rng_nelem < 1)
-          && (NINTbig (rng_inc) == rng_inc || rng_nelem <= 1));
+          && (NINTbig (rng_base) == rng_base || rng_numel < 1)
+          && (NINTbig (rng_inc) == rng_inc || rng_numel <= 1));
 }
 
 Matrix
 Range::matrix_value (void) const
 {
-  if (rng_nelem > 0 && cache.nelem () == 0)
+  if (rng_numel > 0 && cache.numel () == 0)
     {
-      cache.resize (1, rng_nelem);
+      cache.resize (1, rng_numel);
       double b = rng_base;
       double increment = rng_inc;
-      if (rng_nelem > 0)
+      if (rng_numel > 0)
         {
           // The first element must always be *exactly* the base.
           // E.g, -0 would otherwise become +0 in the loop (-0 + 0*increment).
           cache(0) = b;
-          for (octave_idx_type i = 1; i < rng_nelem; i++)
+          for (octave_idx_type i = 1; i < rng_numel; i++)
             cache(i) = b + i * increment;
         }
 
       // On some machines (x86 with extended precision floating point
       // arithmetic, for example) it is possible that we can overshoot
       // the limit by approximately the machine precision even though
       // we were very careful in our calculation of the number of
       // elements.  The tests need equality (>= rng_limit or <= rng_limit)
       // to have expressions like -5:1:-0 result in a -0 endpoint.
 
-      if ((rng_inc > 0 && cache(rng_nelem-1) >= rng_limit)
-          || (rng_inc < 0 && cache(rng_nelem-1) <= rng_limit))
-        cache(rng_nelem-1) = rng_limit;
+      if ((rng_inc > 0 && cache(rng_numel-1) >= rng_limit)
+          || (rng_inc < 0 && cache(rng_numel-1) <= rng_limit))
+        cache(rng_numel-1) = rng_limit;
     }
 
   return cache;
 }
 
 double
 Range::checkelem (octave_idx_type i) const
 {
-  if (i < 0 || i >= rng_nelem)
-    gripe_index_out_of_range (1, 1, i+1, rng_nelem);
+  if (i < 0 || i >= rng_numel)
+    gripe_index_out_of_range (1, 1, i+1, rng_numel);
 
   if (i == 0)
     return rng_base;
-  else if (i < rng_nelem - 1)
+  else if (i < rng_numel - 1)
     return rng_base + i * rng_inc;
   else
     {
       double end = rng_base + i * rng_inc;
       if ((rng_inc > 0 && end >= rng_limit)
           || (rng_inc < 0 && end <= rng_limit))
         return rng_limit;
       else
@@ -104,17 +104,17 @@ Range::checkelem (octave_idx_type i) con
 double
 Range::elem (octave_idx_type i) const
 {
 #if defined (BOUNDS_CHECKING)
   return checkelem (i);
 #else
   if (i == 0)
     return rng_base;
-  else if (i < rng_nelem - 1)
+  else if (i < rng_numel - 1)
     return rng_base + i * rng_inc;
   else
     {
       double end = rng_base + i * rng_inc;
       if ((rng_inc > 0 && end >= rng_limit)
           || (rng_inc < 0 && end <= rng_limit))
         return rng_limit;
       else
@@ -153,21 +153,21 @@ private:
 
 };
 
 Array<double>
 Range::index (const idx_vector& i) const
 {
   Array<double> retval;
 
-  octave_idx_type n = rng_nelem;
+  octave_idx_type n = rng_numel;
 
   if (i.is_colon ())
     {
-      retval = matrix_value ().reshape (dim_vector (rng_nelem, 1));
+      retval = matrix_value ().reshape (dim_vector (rng_numel, 1));
     }
   else
     {
       if (i.extent (n) != n)
         gripe_index_out_of_range (1, 1, i.extent (n), n); // throws
 
       dim_vector rd = i.orig_dimensions ();
       octave_idx_type il = i.length (n);
@@ -176,55 +176,55 @@ Range::index (const idx_vector& i) const
       if (n != 1 && rd.is_vector ())
         rd = dim_vector (1, il);
 
       retval.clear (rd);
 
       // idx_vector loop across all values in i,
       // executing __rangeidx_helper (i) for each i
       i.loop (n, __rangeidx_helper (retval.fortran_vec (),
-                                    rng_base, rng_inc, rng_limit, rng_nelem));
+                                    rng_base, rng_inc, rng_limit, rng_numel));
     }
 
   return retval;
 }
 
-// NOTE: max and min only return useful values if nelem > 0.
-//       do_minmax_body() in max.cc avoids calling Range::min/max if nelem == 0.
+// NOTE: max and min only return useful values if numel > 0.
+//       do_minmax_body() in max.cc avoids calling Range::min/max if numel == 0.
 
 double
 Range::min (void) const
 {
   double retval = 0.0;
-  if (rng_nelem > 0)
+  if (rng_numel > 0)
     {
       if (rng_inc > 0)
         retval = rng_base;
       else
         {
-          retval = rng_base + (rng_nelem - 1) * rng_inc;
+          retval = rng_base + (rng_numel - 1) * rng_inc;
 
           // See the note in the matrix_value method above.
           if (retval <= rng_limit)
             retval = rng_limit;
         }
 
     }
   return retval;
 }
 
 double
 Range::max (void) const
 {
   double retval = 0.0;
-  if (rng_nelem > 0)
+  if (rng_numel > 0)
     {
       if (rng_inc > 0)
         {
-          retval = rng_base + (rng_nelem - 1) * rng_inc;
+          retval = rng_base + (rng_numel - 1) * rng_inc;
 
           // See the note in the matrix_value method above.
           if (retval >= rng_limit)
             retval = rng_limit;
         }
       else
         retval = rng_base;
     }
@@ -250,17 +250,17 @@ Range::sort_internal (bool ascending)
       rng_inc = -rng_inc;
       clear_cache ();
     }
 }
 
 void
 Range::sort_internal (Array<octave_idx_type>& sidx, bool ascending)
 {
-  octave_idx_type nel = nelem ();
+  octave_idx_type nel = numel ();
 
   sidx.resize (dim_vector (1, nel));
 
   octave_idx_type *psidx = sidx.fortran_vec ();
 
   bool reverse = false;
 
   if (ascending && rng_base > rng_limit && rng_inc < 0.0)
@@ -331,32 +331,32 @@ Range::sort (Array<octave_idx_type>& sid
     (*current_liboctave_error_handler) ("Range::sort: invalid dimension");
 
   return retval;
 }
 
 sortmode
 Range::is_sorted (sortmode mode) const
 {
-  if (rng_nelem > 1 && rng_inc > 0)
+  if (rng_numel > 1 && rng_inc > 0)
     mode = (mode == DESCENDING) ? UNSORTED : ASCENDING;
-  else if (rng_nelem > 1 && rng_inc < 0)
+  else if (rng_numel > 1 && rng_inc < 0)
     mode = (mode == ASCENDING) ? UNSORTED : DESCENDING;
   else
     mode = mode ? mode : ASCENDING;
 
   return mode;
 }
 
 std::ostream&
 operator << (std::ostream& os, const Range& a)
 {
   double b = a.base ();
   double increment = a.inc ();
-  octave_idx_type num_elem = a.nelem ();
+  octave_idx_type num_elem = a.numel ();
 
   if (num_elem > 1)
     {
       // First element must be the base *exactly* (-0).
       os << b << " ";
       for (octave_idx_type i = 1; i < num_elem-1; i++)
         os << b + i * increment << " ";
     }
@@ -372,78 +372,78 @@ operator >> (std::istream& is, Range& a)
 {
   is >> a.rng_base;
   if (is)
     {
       is >> a.rng_limit;
       if (is)
         {
           is >> a.rng_inc;
-          a.rng_nelem = a.nelem_internal ();
+          a.rng_numel = a.numel_internal ();
         }
     }
 
   return is;
 }
 
 Range
 operator - (const Range& r)
 {
-  return Range (-r.base (), -r.limit (), -r.inc (), r.nelem ());
+  return Range (-r.base (), -r.limit (), -r.inc (), r.numel ());
 }
 
 Range operator + (double x, const Range& r)
 {
-  Range result (x + r.base (), x + r.limit (), r.inc (), r.nelem ());
-  if (result.rng_nelem < 0)
+  Range result (x + r.base (), x + r.limit (), r.inc (), r.numel ());
+  if (result.rng_numel < 0)
     result.cache = x + r.matrix_value ();
 
   return result;
 }
 
 Range operator + (const Range& r, double x)
 {
-  Range result (r.base () + x, r.limit () + x, r.inc (), r.nelem ());
-  if (result.rng_nelem < 0)
+  Range result (r.base () + x, r.limit () + x, r.inc (), r.numel ());
+  if (result.rng_numel < 0)
     result.cache = r.matrix_value () + x;
 
   return result;
 }
 
 Range operator - (double x, const Range& r)
 {
-  Range result (x - r.base (), x - r.limit (), -r.inc (), r.nelem ());
-  if (result.rng_nelem < 0)
+  Range result (x - r.base (), x - r.limit (), -r.inc (), r.numel ());
+  if (result.rng_numel < 0)
     result.cache = x - r.matrix_value ();
 
   return result;
 }
 
 Range operator - (const Range& r, double x)
 {
-  Range result (r.base () - x, r.limit () - x, r.inc (), r.nelem ());
-  if (result.rng_nelem < 0)
+  Range result (r.base () - x, r.limit () - x, r.inc (), r.numel ());
+  if (result.rng_numel < 0)
     result.cache = r.matrix_value () - x;
 
   return result;
 }
 
 Range operator * (double x, const Range& r)
 {
-  Range result (x * r.base (), x * r.limit (), x * r.inc (), r.nelem ());
-  if (result.rng_nelem < 0)
+  Range result (x * r.base (), x * r.limit (), x * r.inc (), r.numel ());
+  if (result.rng_numel < 0)
     result.cache = x * r.matrix_value ();
 
   return result;
 }
 
 Range operator * (const Range& r, double x)
 {
-  Range result (r.base () * x, r.limit () * x, r.inc () * x, r.nelem ());
-  if (result.rng_nelem < 0)
+  Range result (r.base () * x, r.limit () * x, r.inc () * x, r.numel ());
+  if (result.rng_numel < 0)
     result.cache = r.matrix_value () * x;
 
   return result;
 }
 
 
 // C  See Knuth, Art Of Computer Programming, Vol. 1, Problem 1.2.4-5.
 // C
@@ -519,17 +519,17 @@ teq (double u, double v,
 {
   double tu = fabs (u);
   double tv = fabs (v);
 
   return fabs (u - v) < ((tu > tv ? tu : tv) * ct);
 }
 
 octave_idx_type
-Range::nelem_internal (void) const
+Range::numel_internal (void) const
 {
   octave_idx_type retval = -1;
 
   if (rng_inc == 0
       || (rng_limit > rng_base && rng_inc < 0)
       || (rng_limit < rng_base && rng_inc > 0))
     {
       retval = 0;
diff --git a/liboctave/array/Range.h b/liboctave/array/Range.h
--- a/liboctave/array/Range.h
+++ b/liboctave/array/Range.h
@@ -30,43 +30,44 @@ along with Octave; see the file COPYING.
 
 class
 OCTAVE_API
 Range
 {
 public:
 
   Range (void)
-    : rng_base (0), rng_limit (0), rng_inc (0), rng_nelem (0), cache (1, 0) { }
+    : rng_base (0), rng_limit (0), rng_inc (0), rng_numel (0), cache (1, 0) { }
 
   Range (const Range& r)
     : rng_base (r.rng_base), rng_limit (r.rng_limit), rng_inc (r.rng_inc),
-      rng_nelem (r.rng_nelem), cache (r.cache) { }
+      rng_numel (r.rng_numel), cache (r.cache) { }
 
   Range (double b, double l)
     : rng_base (b), rng_limit (l), rng_inc (1),
-      rng_nelem (nelem_internal ()), cache () { }
+      rng_numel (numel_internal ()), cache () { }
 
   Range (double b, double l, double i)
     : rng_base (b), rng_limit (l), rng_inc (i),
-      rng_nelem (nelem_internal ()), cache () { }
+      rng_numel (numel_internal ()), cache () { }
 
   // For operators' usage (to preserve element count).
   Range (double b, double i, octave_idx_type n)
     : rng_base (b), rng_limit (b + (n-1) * i), rng_inc (i),
-      rng_nelem (n), cache ()
+      rng_numel (n), cache ()
   {
     if (! xfinite (b) || ! xfinite (i) || ! xfinite (rng_limit))
-      rng_nelem = -2;
+      rng_numel = -2;
   }
 
   double base (void) const { return rng_base; }
   double limit (void) const { return rng_limit; }
   double inc (void) const { return rng_inc; }
-  octave_idx_type nelem (void) const { return rng_nelem; }
+  GCC_ATTR_DEPRECATED octave_idx_type nelem (void) const { return numel (); }
+  octave_idx_type numel (void) const { return rng_numel; }
 
   bool all_elements_are_ints (void) const;
 
   Matrix matrix_value (void) const;
 
   double min (void) const;
   double max (void) const;
 
@@ -132,33 +133,33 @@ public:
   void print_range (void);
 
 private:
 
   double rng_base;
   double rng_limit;
   double rng_inc;
 
-  octave_idx_type rng_nelem;
+  octave_idx_type rng_numel;
 
   mutable Matrix cache;
 
-  octave_idx_type nelem_internal (void) const;
+  octave_idx_type numel_internal (void) const;
 
   void clear_cache (void) const { cache.resize (0, 0); }
 
 protected:
 
   // For operators' usage (to allow all values to be set directly).
   Range (double b, double l, double i, octave_idx_type n)
     : rng_base (b), rng_limit (l), rng_inc (i),
-      rng_nelem (n), cache ()
+      rng_numel (n), cache ()
   {
     if (! xfinite (b) || ! xfinite (i) || ! xfinite (l))
-      rng_nelem = -2;
+      rng_numel = -2;
   }
 };
 
 extern OCTAVE_API Range operator - (const Range& r);
 
 extern OCTAVE_API Range operator + (double x, const Range& r);
 
 extern OCTAVE_API Range operator + (const Range& r, double x);
diff --git a/liboctave/array/Sparse.h b/liboctave/array/Sparse.h
--- a/liboctave/array/Sparse.h
+++ b/liboctave/array/Sparse.h
@@ -249,17 +249,17 @@ public:
 
   // Querying the number of elements (incl. zeros) may overflow the index type,
   // so don't do it unless you really need it.
   octave_idx_type numel (void) const
   {
     return dimensions.safe_numel ();
   }
 
-  octave_idx_type nelem (void) const { return capacity (); }
+  GCC_ATTR_DEPRECATED octave_idx_type nelem (void) const { return capacity (); }
   octave_idx_type length (void) const { return numel (); }
 
   octave_idx_type dim1 (void) const { return dimensions(0); }
   octave_idx_type dim2 (void) const { return dimensions(1); }
 
   octave_idx_type rows (void) const { return dim1 (); }
   octave_idx_type cols (void) const { return dim2 (); }
   octave_idx_type columns (void) const { return dim2 (); }
diff --git a/liboctave/array/dNDArray.cc b/liboctave/array/dNDArray.cc
--- a/liboctave/array/dNDArray.cc
+++ b/liboctave/array/dNDArray.cc
@@ -591,17 +591,17 @@ NDArray::all_elements_are_int_or_inf_or_
 }
 
 // Return nonzero if any element of M is not an integer.  Also extract
 // the largest and smallest values and return them in MAX_VAL and MIN_VAL.
 
 bool
 NDArray::all_integers (double& max_val, double& min_val) const
 {
-  octave_idx_type nel = nelem ();
+  octave_idx_type nel = numel ();
 
   if (nel > 0)
     {
       max_val = elem (0);
       min_val = elem (0);
     }
   else
     return false;
@@ -867,31 +867,31 @@ NDArray::diag (octave_idx_type m, octave
 {
   return MArray<double>::diag (m, n);
 }
 
 // This contains no information on the array structure !!!
 std::ostream&
 operator << (std::ostream& os, const NDArray& a)
 {
-  octave_idx_type nel = a.nelem ();
+  octave_idx_type nel = a.numel ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       os << " ";
       octave_write_double (os, a.elem (i));
       os << "\n";
     }
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, NDArray& a)
 {
-  octave_idx_type nel = a.nelem ();
+  octave_idx_type nel = a.numel ();
 
   if (nel > 0)
     {
       double tmp;
       for (octave_idx_type i = 0; i < nel; i++)
         {
           tmp = octave_read_value<double> (is);
           if (is)
diff --git a/liboctave/array/fCNDArray.cc b/liboctave/array/fCNDArray.cc
--- a/liboctave/array/fCNDArray.cc
+++ b/liboctave/array/fCNDArray.cc
@@ -527,17 +527,17 @@ FloatComplexNDArray::all_elements_are_re
 
 // Return nonzero if any element of CM has a non-integer real or
 // imaginary part.  Also extract the largest and smallest (real or
 // imaginary) values and return them in MAX_VAL and MIN_VAL.
 
 bool
 FloatComplexNDArray::all_integers (float& max_val, float& min_val) const
 {
-  octave_idx_type nel = nelem ();
+  octave_idx_type nel = numel ();
 
   if (nel > 0)
     {
       FloatComplex val = elem (0);
 
       float r_val = std::real (val);
       float i_val = std::imag (val);
 
@@ -852,31 +852,31 @@ FloatComplexNDArray::diag (octave_idx_ty
 {
   return MArray<FloatComplex>::diag (m, n);
 }
 
 // This contains no information on the array structure !!!
 std::ostream&
 operator << (std::ostream& os, const FloatComplexNDArray& a)
 {
-  octave_idx_type nel = a.nelem ();
+  octave_idx_type nel = a.numel ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       os << " ";
       octave_write_complex (os, a.elem (i));
       os << "\n";
     }
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, FloatComplexNDArray& a)
 {
-  octave_idx_type nel = a.nelem ();
+  octave_idx_type nel = a.numel ();
 
   if (nel > 0)
     {
       FloatComplex tmp;
       for (octave_idx_type i = 0; i < nel; i++)
         {
           tmp = octave_read_value<FloatComplex> (is);
           if (is)
diff --git a/liboctave/array/fNDArray.cc b/liboctave/array/fNDArray.cc
--- a/liboctave/array/fNDArray.cc
+++ b/liboctave/array/fNDArray.cc
@@ -551,17 +551,17 @@ FloatNDArray::all_elements_are_int_or_in
 }
 
 // Return nonzero if any element of M is not an integer.  Also extract
 // the largest and smallest values and return them in MAX_VAL and MIN_VAL.
 
 bool
 FloatNDArray::all_integers (float& max_val, float& min_val) const
 {
-  octave_idx_type nel = nelem ();
+  octave_idx_type nel = numel ();
 
   if (nel > 0)
     {
       max_val = elem (0);
       min_val = elem (0);
     }
   else
     return false;
@@ -838,31 +838,31 @@ FloatNDArray::diag (octave_idx_type m, o
 {
   return MArray<float>::diag (m, n);
 }
 
 // This contains no information on the array structure !!!
 std::ostream&
 operator << (std::ostream& os, const FloatNDArray& a)
 {
-  octave_idx_type nel = a.nelem ();
+  octave_idx_type nel = a.numel ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       os << " ";
       octave_write_float (os, a.elem (i));
       os << "\n";
     }
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, FloatNDArray& a)
 {
-  octave_idx_type nel = a.nelem ();
+  octave_idx_type nel = a.numel ();
 
   if (nel > 0)
     {
       float tmp;
       for (octave_idx_type i = 0; i < nel; i++)
         {
           tmp = octave_read_value<float> (is);
           if (is)
diff --git a/liboctave/array/idx-vector.cc b/liboctave/array/idx-vector.cc
--- a/liboctave/array/idx-vector.cc
+++ b/liboctave/array/idx-vector.cc
@@ -116,17 +116,17 @@ idx_vector::idx_range_rep::idx_range_rep
   else if (start < 0 || (step < 0 && start + (len-1)*step < 0))
     {
       gripe_invalid_index ();
       err = true;
     }
 }
 
 idx_vector::idx_range_rep::idx_range_rep (const Range& r)
-  : start (0), len (r.nelem ()), step (1)
+  : start (0), len (r.numel ()), step (1)
 {
   if (len < 0)
     {
       gripe_invalid_range ();
       err = true;
     }
   else if (len > 0)
     {
diff --git a/liboctave/array/intNDArray.cc b/liboctave/array/intNDArray.cc
--- a/liboctave/array/intNDArray.cc
+++ b/liboctave/array/intNDArray.cc
@@ -44,17 +44,17 @@ intNDArray<T>::operator ! (void) const
 
   return b;
 }
 
 template <class T>
 bool
 intNDArray<T>::any_element_not_one_or_zero (void) const
 {
-  octave_idx_type nel = this->nelem ();
+  octave_idx_type nel = this->numel ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       T val = this->elem (i);
 
       if (val != 0.0 && val != 1.0)
         return true;
     }
@@ -138,29 +138,29 @@ intNDArray<T>::insert (const intNDArray<
 }
 
 // This contains no information on the array structure !!!
 
 template <class T>
 std::ostream&
 operator << (std::ostream& os, const intNDArray<T>& a)
 {
-  octave_idx_type nel = a.nelem ();
+  octave_idx_type nel = a.numel ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     os << " " << a.elem (i) << "\n";
 
   return os;
 }
 
 template <class T>
 std::istream&
 operator >> (std::istream& is, intNDArray<T>& a)
 {
-  octave_idx_type nel = a.nelem ();
+  octave_idx_type nel = a.numel ();
 
   if (nel > 0)
     {
       T tmp;
 
       for (octave_idx_type i = 0; i < nel; i++)
         {
           is >> tmp;
@@ -178,33 +178,33 @@ done:
 }
 
 // FIXME: should abs and signum just be mapper functions?
 
 template <class T>
 intNDArray<T>
 intNDArray<T>::abs (void) const
 {
-  octave_idx_type nel = this->nelem ();
+  octave_idx_type nel = this->numel ();
   intNDArray<T> ret (this->dims ());
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       T val = this->elem (i);
       ret.xelem (i) = val.abs ();
     }
 
   return ret;
 }
 
 template <class T>
 intNDArray<T>
 intNDArray<T>::signum (void) const
 {
-  octave_idx_type nel = this->nelem ();
+  octave_idx_type nel = this->numel ();
   intNDArray<T> ret (this->dims ());
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       T val = this->elem (i);
       ret.xelem (i) = val.signum ();
     }
 
diff --git a/liboctave/numeric/SparseCmplxLU.cc b/liboctave/numeric/SparseCmplxLU.cc
--- a/liboctave/numeric/SparseCmplxLU.cc
+++ b/liboctave/numeric/SparseCmplxLU.cc
@@ -53,17 +53,17 @@ SparseComplexLU::SparseComplexLU (const 
   // Setup the control parameters
   Matrix Control (UMFPACK_CONTROL, 1);
   double *control = Control.fortran_vec ();
   UMFPACK_ZNAME (defaults) (control);
 
   double tmp = octave_sparse_params::get_key ("spumoni");
   if (!xisnan (tmp))
     Control (UMFPACK_PRL) = tmp;
-  if (piv_thres.nelem () == 2)
+  if (piv_thres.numel () == 2)
     {
       tmp = (piv_thres (0) > 1. ? 1. : piv_thres (0));
       if (!xisnan (tmp))
         Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
       tmp = (piv_thres (1) > 1. ? 1. : piv_thres (1));
       if (!xisnan (tmp))
         Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
     }
@@ -262,17 +262,17 @@ SparseComplexLU::SparseComplexLU (const 
       // Setup the control parameters
       Matrix Control (UMFPACK_CONTROL, 1);
       double *control = Control.fortran_vec ();
       UMFPACK_ZNAME (defaults) (control);
 
       double tmp = octave_sparse_params::get_key ("spumoni");
       if (!xisnan (tmp))
         Control (UMFPACK_PRL) = tmp;
-      if (piv_thres.nelem () == 2)
+      if (piv_thres.numel () == 2)
         {
           tmp = (piv_thres (0) > 1. ? 1. : piv_thres (0));
           if (!xisnan (tmp))
             Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
           tmp = (piv_thres (1) > 1. ? 1. : piv_thres (1));
           if (!xisnan (tmp))
             Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
         }
diff --git a/liboctave/numeric/SparsedbleLU.cc b/liboctave/numeric/SparsedbleLU.cc
--- a/liboctave/numeric/SparsedbleLU.cc
+++ b/liboctave/numeric/SparsedbleLU.cc
@@ -52,17 +52,17 @@ SparseLU::SparseLU (const SparseMatrix& 
   Matrix Control (UMFPACK_CONTROL, 1);
   double *control = Control.fortran_vec ();
   UMFPACK_DNAME (defaults) (control);
 
   double tmp = octave_sparse_params::get_key ("spumoni");
   if (!xisnan (tmp))
     Control (UMFPACK_PRL) = tmp;
 
-  if (piv_thres.nelem () == 2)
+  if (piv_thres.numel () == 2)
     {
       tmp = (piv_thres (0) > 1. ? 1. : piv_thres (0));
       if (!xisnan (tmp))
         Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
       tmp = (piv_thres (1) > 1. ? 1. : piv_thres (1));
       if (!xisnan (tmp))
         Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
     }
@@ -248,17 +248,17 @@ SparseLU::SparseLU (const SparseMatrix& 
       Matrix Control (UMFPACK_CONTROL, 1);
       double *control = Control.fortran_vec ();
       UMFPACK_DNAME (defaults) (control);
 
       double tmp = octave_sparse_params::get_key ("spumoni");
       if (!xisnan (tmp))
         Control (UMFPACK_PRL) = tmp;
 
-      if (piv_thres.nelem () == 2)
+      if (piv_thres.numel () == 2)
         {
           tmp = (piv_thres (0) > 1. ? 1. : piv_thres (0));
           if (!xisnan (tmp))
             Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
           tmp = (piv_thres (1) > 1. ? 1. : piv_thres (1));
           if (!xisnan (tmp))
             Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
         }
