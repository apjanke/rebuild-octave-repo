# HG changeset patch
# User jwe
# Date 1039210159 0
#      Fri Dec 06 21:29:19 2002 +0000
# Node ID 23d06c9e1eddf408e77fcbc8ade3be5b35b17b5b
# Parent  4a392a01e51a3120508ec011e8271fab05946ee9
[project @ 2002-12-06 21:29:17 by jwe]

diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,13 @@
+2002-12-06  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* oct-alloc.h (DECLARE_OCTAVE_ALLOCATOR): Also declare and define
+	a placement operator new.
+
 2002-12-03  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* Matrix.h: Include mx-ops.h too.
 	* mx-ops.h: New file.
 
 2002-11-20  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* DASRT.cc, DASRT.h, Array.cc, ArrayN.h, Array.h, Array2.cc,
diff --git a/liboctave/oct-alloc.h b/liboctave/oct-alloc.h
--- a/liboctave/oct-alloc.h
+++ b/liboctave/oct-alloc.h
@@ -56,16 +56,18 @@ private:
   size_t item_size;
 
   // How to grow the free list.
   bool grow (void);
 };
 
 #define DECLARE_OCTAVE_ALLOCATOR \
   public: \
+    void *operator new (size_t size, void *p) \
+      { return ::operator new (size, p); } \
     void *operator new (size_t size) { return allocator.alloc (size); } \
     void operator delete (void *p, size_t size) { allocator.free (p, size); } \
   private: \
     static octave_allocator allocator;
 
 #define DEFINE_OCTAVE_ALLOCATOR(t) \
   octave_allocator t::allocator (sizeof (t))
 
diff --git a/src/BaseSLList.cc b/src/BaseSLList.cc
deleted file mode 100644
--- a/src/BaseSLList.cc
+++ /dev/null
@@ -1,257 +0,0 @@
-// This may look like C code, but it is really -*- C++ -*-
-/* 
-Copyright (C) 1988, 1992 Free Software Foundation
-    written by Doug Lea (dl@rocky.oswego.edu)
-
-This file is part of the GNU C++ Library.  This library is free
-software; you can redistribute it and/or modify it under the terms of
-the GNU Library General Public License as published by the Free
-Software Foundation; either version 2 of the License, or (at your
-option) any later version.  This library is distributed in the hope
-that it will be useful, but WITHOUT ANY WARRANTY; without even the
-implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
-PURPOSE.  See the GNU Library General Public License for more details.
-You should have received a copy of the GNU Library General Public
-License along with this library; if not, write to the Free Software
-Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
-*/
-
-#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
-#pragma implementation
-#endif
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <climits>
-
-#include "BaseSLList.h"
-
-#include "error.h"
-
-void BaseSLList::error(const char* msg) const
-{
-  ::error ("SLList: %s", msg);
-}
-
-int BaseSLList::length() const
-{
-  int l = 0;
-  BaseSLNode* t = last;
-  if (t != 0) do { ++l; t = t->tl; } while (t != last);
-  return l;
-}
-
-void BaseSLList::clear()
-{
-  if (last == 0)
-    return;
-
-  BaseSLNode* p = last->tl;
-  last->tl = 0;
-  last = 0;
-
-  while (p != 0)
-  {
-    BaseSLNode* nxt = p->tl;
-    delete_node(p);
-    p = nxt;
-  }
-}
-
-
-// Note:  This is an internal method.  It does *not* free old contents!
-
-void BaseSLList::copy(const BaseSLList& a)
-{
-  if (a.last == 0)
-    last = 0;
-  else
-  {
-    BaseSLNode* p = a.last->tl;
-    BaseSLNode* h = copy_node(p->item());
-    last = h;
-    for (;;)
-    {
-      if (p == a.last)
-      {
-        last->tl = h;
-        return;
-      }
-      p = p->tl;
-      BaseSLNode* n = copy_node(p->item());
-      last->tl = n;
-      last = n;
-    }
-  }
-}
-
-BaseSLList& BaseSLList::operator = (const BaseSLList& a)
-{
-  if (last != a.last)
-  {
-    clear();
-    copy(a);
-  }
-  return *this;
-}
-
-Pix BaseSLList::prepend(const void *datum)
-{
-  return prepend(copy_node(datum));
-}
-
-
-Pix BaseSLList::prepend(BaseSLNode* t)
-{
-  if (t == 0) return 0;
-  if (last == 0)
-    t->tl = last = t;
-  else
-  {
-    t->tl = last->tl;
-    last->tl = t;
-  }
-  return Pix(t);
-}
-
-
-Pix BaseSLList::append(const void *datum)
-{
-  return append(copy_node(datum));
-}
-
-Pix BaseSLList::append(BaseSLNode* t)
-{
-  if (t == 0) return 0;
-  if (last == 0)
-    t->tl = last = t;
-  else
-  {
-    t->tl = last->tl;
-    last->tl = t;
-    last = t;
-  }
-  return Pix(t);
-}
-
-void BaseSLList::join(BaseSLList& b)
-{
-  BaseSLNode* t = b.last;
-  b.last = 0;
-  if (last == 0)
-    last = t;
-  else if (t != 0)
-  {
-    BaseSLNode* f = last->tl;
-    last->tl = t->tl;
-    t->tl = f;
-    last = t;
-  }
-}
-
-Pix BaseSLList::ins_after(Pix p, const void *datum)
-{
-  BaseSLNode* u = (BaseSLNode*)p;
-  BaseSLNode* t = copy_node(datum);
-  if (last == 0)
-    t->tl = last = t;
-  else if (u == 0) // ins_after 0 means prepend
-  {
-    t->tl = last->tl;
-    last->tl = t;
-  }
-  else
-  {
-    t->tl = u->tl;
-    u->tl = t;
-    if (u == last) 
-      last = t;
-  }
-  return Pix(t);
-}
-
-void BaseSLList::del_after(Pix p)
-{
-  BaseSLNode* u = (BaseSLNode*)p;
-  if (last == 0 || u == last) error("cannot del_after last");
-  if (u == 0) u = last; // del_after 0 means delete first
-  BaseSLNode* t = u->tl;
-  if (u == t)
-    last = 0;
-  else
-  {
-    u->tl = t->tl;
-    if (last == t)
-      last = u;
-  }
-  delete_node(t);
-}
-
-int BaseSLList::owns(Pix p) const
-{
-  BaseSLNode* t = last;
-  if (t != 0 && p != 0)
-  {
-    do
-    {
-      if (Pix(t) == p) return 1;
-      t = t->tl;
-    } while (t != last);
-  }
-  return 0;
-}
-
-int BaseSLList::remove_front(void *dst, int signal_error)
-{
-  if (last)
-  {
-    BaseSLNode* t = last->tl;
-    copy_item(dst, t->item());
-    if (t == last)
-      last = 0;
-    else
-      last->tl = t->tl;
-    delete_node(t);
-    return 1;
-  }
-  if (signal_error)
-    error("remove_front of empty list");
-  return 0;
-}
-
-void BaseSLList::del_front()
-{
-  if (last == 0) error("del_front of empty list");
-  BaseSLNode* t = last->tl;
-  if (t == last)
-    last = 0;
-  else
-    last->tl = t->tl;
-  delete_node(t);
-}
-
-int BaseSLList::OK() const
-{
-  int v = 1;
-  if (last != 0)
-  {
-    BaseSLNode* t = last;
-    long count = LONG_MAX;      // Lots of chances to find last!
-    do
-    {
-      count--;
-      t = t->tl;
-    } while (count > 0 && t != last);
-    v &= count > 0;
-  }
-  if (!v) error("invariant failure");
-  return v;
-}
-
-/*
-;;; Local Variables: ***
-;;; mode: C++ ***
-;;; End: ***
-*/
diff --git a/src/BaseSLList.h b/src/BaseSLList.h
deleted file mode 100644
--- a/src/BaseSLList.h
+++ /dev/null
@@ -1,75 +0,0 @@
-// This may look like C code, but it is really -*- C++ -*-
-/* 
-Copyright (C) 1988, 1992 Free Software Foundation
-    written by Doug Lea (dl@rocky.oswego.edu)
-
-This file is part of the GNU C++ Library.  This library is free
-software; you can redistribute it and/or modify it under the terms of
-the GNU Library General Public License as published by the Free
-Software Foundation; either version 2 of the License, or (at your
-option) any later version.  This library is distributed in the hope
-that it will be useful, but WITHOUT ANY WARRANTY; without even the
-implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
-PURPOSE.  See the GNU Library General Public License for more details.
-You should have received a copy of the GNU Library General Public
-License along with this library; if not, write to the Free Software
-Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
-*/
-
-#ifndef _BaseSLList_h
-#define _BaseSLList_h 1
-
-#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
-#pragma interface
-#endif
-
-#undef OK
-
-#include <Pix.h>
-
-struct BaseSLNode
-{
-   union {
-     struct BaseSLNode *tl;
-     double dummy;  /* To force correct alignment */
-   };
-   void *item() {return (void*)(this+1);} // Return ((SLNode<T>*)this)->hd
-};
-
-class
-BaseSLList
-{
-  protected:
-    BaseSLNode *last;
-    virtual void delete_node(BaseSLNode*node) = 0;
-    virtual BaseSLNode* copy_node(const void* datum) = 0;
-    virtual void copy_item(void *dst, void *src) = 0;
-    virtual ~BaseSLList() { }
-    BaseSLList() { last = 0; }
-    void copy(const BaseSLList&);
-    BaseSLList& operator = (const BaseSLList& a);
-    Pix ins_after(Pix p, const void *datum);
-    Pix prepend(const void *datum);
-    Pix append(const void *datum);
-    int remove_front(void *dst, int signal_error = 0);
-    void join(BaseSLList&);
-  public:
-    int length() const;
-    int empty() const { return last == 0; }
-    void clear();
-    Pix                   prepend(BaseSLNode*);
-    Pix                   append(BaseSLNode*);
-    int                   OK() const;
-    void                  error(const char* msg) const;
-    void                  del_after(Pix p);
-    int                   owns(Pix p) const;
-    void                  del_front();
-};
-
-#endif
-
-/*
-;;; Local Variables: ***
-;;; mode: C++ ***
-;;; End: ***
-*/
diff --git a/src/Cell.h b/src/Cell.h
--- a/src/Cell.h
+++ b/src/Cell.h
@@ -41,17 +41,17 @@ Cell : public Array2<octave_value>
 public:
 
   Cell (void)
     : Array2<octave_value> () { }
 
   Cell (const octave_value& val)
     : Array2<octave_value> (1, 1, val) { }
 
-  Cell (int n, int m, const octave_value& val = octave_value ())
+  Cell (int n, int m, const octave_value& val = resize_fill_value ())
     : Array2<octave_value> (n, m, val) { }
 
   Cell (const Array2<octave_value>& c)
     : Array2<octave_value> (c) { }
 
   Cell (const Array<octave_value>& c, int nr, int nc)
     : Array2<octave_value> (c, nr, nc) { }
 
@@ -64,17 +64,17 @@ public:
   boolMatrix all (int dim = 0) const { return boolMatrix (); }
 
   // XXX FIXME XXX
   boolMatrix any (int dim = 0) const { return boolMatrix (); }
 
   // XXX FIXME XXX
   bool is_true (void) const { return false; }
 
-  static octave_value resize_fill_value (void) { return octave_value (); }
+  static octave_value resize_fill_value (void) { return Matrix (); }
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,78 @@
+2002-12-06  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* pt-mat.cc (class tm_row_const::tm_row_const_rep): Derive from
+	octave_base_list instead of SLList.  Fix tm_row_const member
+	functions as needed, change all uses.
+	(class tm_const): Derive from octave_base_list, not SLList.  Fix
+	member functions as needed, change all uses.
+	* pt-mat.h (class tree_matrix): Derive from octave_base_list
+	instead of including SLList object as data member.  Fix member
+	functions as needed, change all uses.
+
+	* pt-idx.h (tree_index_expression::args,
+	tree_index_expression::arg_nm, tree_index_expression::dyn_field):
+	Now std::list, not SLList.  Fix member functions as needed, change
+	all uses.
+
+	* oct-map.h (Octave_map::map): Now std::map instead of CHMap.
+	Fix member functions as needed, change all uses.
+
+	* oct-lvalue.h (octave_lvalue::idx): Now std::list instead of
+	SLList object.  Fix member functions as needed, change all uses.
+
+	* dynamic-ld.cc (octave_shlib_list::lib_list): Now std::list
+	instead of DLList object.  Fix member functions as needed, change
+	all uses.
+
+	* ov.h (octave_value::subsref, octave_value::subsasgn):
+	Index arg is not std::list, not SLList.  Change all derived
+	classes, all uses.
+
+	* pt-stmt.h (tree_statement_list): Derive from base_octave_list
+	object instead of including SLList object as data member.  Fix
+	member functions as needed, change all uses.
+	* pt-select.h (tree_switch_case_list): Likewise.
+	(tree_if_command_list): Likewise.
+	* pt-misc.h (tree_parameter_list, tree_return_list,
+	tree_va_return_list): Likewise.
+	* pt-plot.h (subplot_list): Likewise.
+	* pt-mat.h (tree_matrix): Likewise.
+	* pt-decl.h (tree_decl_init_list): Likewise.
+	* pt-arg-list.h (tree_argument_list): Likewise.
+	* comment-list.h (octave_comment_list): Likewise.
+
+	* BaseSLList.cc, DLList.cc, Map.cc, SLList.cc, SLStack.cc,
+	Stack.cc: Delete.
+	* Makefile.in (DIST_SRC): Delete them from the list.
+
+	* BaseSLList.h, DLList.h, Map.h, Pix.h, SLList.h, SLStack.h,
+	Stack.h: Delete
+	* Makefile.in (INCLUDES): Delete them from the list.
+
+	* Map-oct-obj.cc, SLList-expr.cc, SLList-misc.cc, SLList-plot.cc,
+	SLList-tc.cc, SLList-tm.cc: Delete.
+	* Makefile.in (TI_XSRC): Delete them from the list.
+
+	* ov-base-mat.cc (octave_base_matrix::assign): Pass
+	MT::resize_fill_value () as third arg for ::assign.	
+
+	* Cell.h (Cell::resize_fill_value): Use empty Matrix object, not
+	undefined octave_value object.
+	(Cell::Cell (int, int, const octave_value&)): Use
+	resize_fill_value () as default value, not undefined octave_value
+	object.
+
+2002-12-05  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* Makefile.in (DEFUN_PATTERN): Make it work for DEFCMD too.
+
+	* base-list.h: New file.
+
 2002-12-04  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* toplev.cc (octave_interpreter_ready): New global variable.
 	* toplev.h: Provide decl.
 
 	* octave.cc (octave_main): Call execute_default_pkg_add_files just
 	before executing startup files.  Set octave_interpreter_ready to
 	true before calling execute_default_pkg_add_files.
diff --git a/src/DLList.cc b/src/DLList.cc
deleted file mode 100644
--- a/src/DLList.cc
+++ /dev/null
@@ -1,331 +0,0 @@
-// This may look like C code, but it is really -*- C++ -*-
-/* 
-Copyright (C) 1988 Free Software Foundation
-    written by Doug Lea (dl@rocky.oswego.edu)
-
-This file is part of the GNU C++ Library.  This library is free
-software; you can redistribute it and/or modify it under the terms of
-the GNU Library General Public License as published by the Free
-Software Foundation; either version 2 of the License, or (at your
-option) any later version.  This library is distributed in the hope
-that it will be useful, but WITHOUT ANY WARRANTY; without even the
-implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
-PURPOSE.  See the GNU Library General Public License for more details.
-You should have received a copy of the GNU Library General Public
-License along with this library; if not, write to the Free Software
-Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
-*/
-
-#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
-#pragma implementation
-#endif
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <climits>
-
-#include "DLList.h"
-
-#include "error.h"
-
-void BaseDLList::error(const char* msg) const
-{
-  ::error ("DLList: %s", msg);
-}
-
-int BaseDLList::length() const
-{
-  int l = 0;
-  BaseDLNode* t = h;
-  if (t != 0) do { ++l; t = t->fd; } while (t != h);
-  return l;
-}
-
-// Note:  This is an internal method.  It does *not* free old contents!
-
-void BaseDLList::copy(const BaseDLList& a)
-{
-  if (a.h == 0)
-    h = 0;
-  else
-  {
-    BaseDLNode* p = a.h;
-    BaseDLNode* t = copy_node(p->item());
-    h = t;
-    p = p->fd;
-    while (p != a.h)
-    {
-      BaseDLNode* n = copy_node(p->item());
-      t->fd = n;
-      n->bk = t;
-      t = n;
-      p = p->fd;
-    }
-    t->fd = h;
-    h->bk = t;
-    return;
-  }
-}
-
-void BaseDLList::clear()
-{
-  if (h == 0)
-    return;
-
-  BaseDLNode* p = h->fd;
-  h->fd = 0;
-  h = 0;
-
-  while (p != 0)
-  {
-    BaseDLNode* nxt = p->fd;
-    delete_node(p);
-    p = nxt;
-  }
-}
-
-BaseDLList& BaseDLList::operator = (const BaseDLList& a)
-{
-  if (h != a.h)
-  {
-    clear();
-    copy(a);
-  }
-  return *this;
-}
-
-
-Pix BaseDLList::prepend(const void *datum)
-{
-  BaseDLNode* t = copy_node(datum);
-  if (h == 0)
-    t->fd = t->bk = h = t;
-  else
-  {
-    t->fd = h;
-    t->bk = h->bk;
-    h->bk->fd = t;
-    h->bk = t;
-    h = t;
-  }
-  return Pix(t);
-}
-
-Pix BaseDLList::append(const void *datum)
-{
-  BaseDLNode* t = copy_node(datum);
-  if (h == 0)
-    t->fd = t->bk = h = t;
-  else
-  {
-    t->bk = h->bk;
-    t->bk->fd = t;
-    t->fd = h;
-    h->bk = t;
-  }
-  return Pix(t);
-}
-
-Pix BaseDLList::ins_after(Pix p, const void *datum)
-{
-  if (p == 0) return prepend(datum);
-  BaseDLNode* u = (BaseDLNode*) p;
-  BaseDLNode* t = copy_node(datum);
-  t->bk = u;
-  t->fd = u->fd;
-  u->fd->bk = t;
-  u->fd = t;
-  return Pix(t);
-}
-
-Pix BaseDLList::ins_before(Pix p, const void *datum)
-{
-  if (p == 0) error("null Pix");
-  BaseDLNode* u = (BaseDLNode*) p;
-  BaseDLNode* t = copy_node(datum);
-  t->bk = u->bk;
-  t->fd = u;
-  u->bk->fd = t;
-  u->bk = t;
-  if (u == h) h = t;
-  return Pix(t);
-}
-
-void BaseDLList::join(BaseDLList& b)
-{
-  BaseDLNode* t = b.h;
-  b.h = 0;
-  if (h == 0)
-    h = t;
-  else if (t != 0)
-  {
-    BaseDLNode* l = t->bk;
-    h->bk->fd = t;
-    t->bk = h->bk;
-    h->bk = l;
-    l->fd = h;
-  }
-}
-
-int BaseDLList::owns(Pix p) const
-{
-  BaseDLNode* t = h;
-  if (t != 0 && p != 0)
-  {
-    do
-    {
-      if (Pix(t) == p) return 1;
-      t = t->fd;
-    } while (t != h);
-  }
-  return 0;
-}
-
-void BaseDLList::del(Pix& p, int dir)
-{
-  if (p == 0) error("null Pix");
-  BaseDLNode* t = (BaseDLNode*) p;
-  if (t->fd == t)
-  {
-    h = 0;
-    p = 0;
-  }
-  else
-  {
-    if (dir < 0)
-    {
-      if (t == h)
-        p = 0;
-      else
-        p = Pix(t->bk);
-    }
-    else
-    {
-      if (t == h->bk)
-        p = 0;
-      else
-        p = Pix(t->fd);
-    }
-    t->bk->fd = t->fd;
-    t->fd->bk = t->bk;
-    if (t == h) h = t->fd;
-  }
-  delete_node(t);
-}
-
-void BaseDLList::del_after(Pix& p)
-{
-  if (p == 0)
-  {
-    del_front();
-    return;
-  }
-
-  BaseDLNode* b = (BaseDLNode*) p;
-  BaseDLNode* t = b->fd;
-
-  if (b == t)
-  {
-    h = 0;
-    p = 0;
-  }
-  else
-  {
-    t->bk->fd = t->fd;
-    t->fd->bk = t->bk;
-    if (t == h) h = t->fd;
-  }
-  delete_node(t);
-}
-
-void BaseDLList::remove_front(void *dst)
-{
-  if (h == 0)
-    error("remove_front of empty list");
-  else {
-      BaseDLNode* t = h;
-      copy_item(dst, t->item());
-      if (h->fd == h)
-	  h = 0;
-      else
-	  {
-	      h->fd->bk = h->bk;
-	      h->bk->fd = h->fd;
-	      h = h->fd;
-	  }
-      delete_node(t);
-  }
-}
-
-void BaseDLList::del_front()
-{
-  if (h == 0)
-    error("del_front of empty list");
-  BaseDLNode* t = h;
-  if (h->fd == h)
-    h = 0;
-  else
-  {
-    h->fd->bk = h->bk;
-    h->bk->fd = h->fd;
-    h = h->fd;
-  }
-  delete_node(t);
-}
-
-void BaseDLList::remove_rear(void *dst)
-{
-  if (h == 0)
-    error("remove_rear of empty list");
-  else
-    {
-      BaseDLNode* t = h->bk;
-      copy_item(dst, t->item());
-      if (h->fd == h)
-	h = 0;
-      else
-	{
-	  t->fd->bk = t->bk;
-	  t->bk->fd = t->fd;
-        }
-      delete_node(t);
-    }
-}
-
-void BaseDLList::del_rear()
-{
-  if (h == 0)
-    error("del_rear of empty list");
-  BaseDLNode* t = h->bk;
-  if (h->fd == h)
-    h = 0;
-  else
-  {
-    t->fd->bk = t->bk;
-    t->bk->fd = t->fd;
-  }
-  delete_node(t);
-}
-
-
-int BaseDLList::OK() const
-{
-  int v = 1;
-  if (h != 0)
-  {
-    BaseDLNode* t = h;
-    long count = LONG_MAX;      // Lots of chances to find h!
-    do
-    {
-      count--;
-      v &= t->bk->fd == t;
-      v &= t->fd->bk == t;
-      t = t->fd;
-    } while (v && count > 0 && t != h);
-    v &= count > 0;
-  }
-  if (!v) error("invariant failure");
-  return v;
-}
diff --git a/src/DLList.h b/src/DLList.h
deleted file mode 100644
--- a/src/DLList.h
+++ /dev/null
@@ -1,145 +0,0 @@
-// This may look like C code, but it is really -*- C++ -*-
-/* 
-Copyright (C) 1988 Free Software Foundation
-    written by Doug Lea (dl@rocky.oswego.edu)
-
-This file is part of the GNU C++ Library.  This library is free
-software; you can redistribute it and/or modify it under the terms of
-the GNU Library General Public License as published by the Free
-Software Foundation; either version 2 of the License, or (at your
-option) any later version.  This library is distributed in the hope
-that it will be useful, but WITHOUT ANY WARRANTY; without even the
-implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
-PURPOSE.  See the GNU Library General Public License for more details.
-You should have received a copy of the GNU Library General Public
-License along with this library; if not, write to the Free Software
-Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
-*/
-
-
-#ifndef _DLList_h
-#define _DLList_h 1
-
-#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
-#pragma interface
-#endif
-
-#undef OK
-
-#include <Pix.h>
-
-struct BaseDLNode {
-    BaseDLNode *bk;
-    BaseDLNode *fd;
-    void *item() {return (void*)(this+1);} //Return ((DLNode<T>*)this)->hd
-};
-
-template<class T>
-class
-DLNode : public BaseDLNode
-{
-  public:
-    T hd;
-    DLNode() { }
-    DLNode(const T& h, DLNode* p = 0, DLNode* n = 0)
-        : hd(h) { bk = p; fd = n; }
-    ~DLNode() { }
-};
-
-class
-BaseDLList
-{
-  protected:
-    BaseDLNode *h;
-
-    BaseDLList() { h = 0; }
-    void copy(const BaseDLList&);
-    BaseDLList& operator= (const BaseDLList& a);
-    virtual void delete_node(BaseDLNode*node) = 0;
-    virtual BaseDLNode* copy_node(const void* datum) = 0;
-    virtual void copy_item(void *dst, void *src) = 0;
-    virtual ~BaseDLList() { }
-
-    Pix                   prepend(const void*);
-    Pix                   append(const void*);
-    Pix ins_after(Pix p, const void *datum);
-    Pix ins_before(Pix p, const void *datum);
-    void remove_front(void *dst);
-    void remove_rear(void *dst);
-    void join(BaseDLList&);
-
-  public:
-    int                   empty() const { return h == 0; }
-    int                   length() const;
-    void                  clear();
-    void                  error(const char* msg) const;
-    int                   owns(Pix p) const;
-    int                   OK() const;
-    void                  del(Pix& p, int dir = 1);
-    void                  del_after(Pix& p);
-    void                  del_front();
-    void                  del_rear();
-};
-
-template <class T>
-class
-DLList : public BaseDLList
-{
-    //friend class          <T>DLListTrav;
-
-    virtual void delete_node(BaseDLNode *node) { delete (DLNode<T>*)node; }
-    virtual BaseDLNode* copy_node(const void *datum)
-	{ return new DLNode<T>(*(const T*)datum); }
-    virtual void copy_item(void *dst, void *src) { *(T*)dst = *(T*)src; }
-
-  public:
-    DLList() : BaseDLList() { }
-    DLList(const DLList<T>& a) : BaseDLList() { copy(a); }
-
-    DLList<T>&            operator = (const DLList<T>& a)
-	{ BaseDLList::operator=((const BaseDLList&) a); return *this; }
-    virtual ~DLList() { clear(); }
-
-    Pix prepend(const T& item) {return BaseDLList::prepend(&item);}
-    Pix append(const T& item) {return BaseDLList::append(&item);}
-
-    void join(DLList<T>& a) { BaseDLList::join(a); }
-
-    T& front() {
-	if (h == 0) error("front: empty list");
-	return ((DLNode<T>*)h)->hd; }
-    T& rear() {
-	if (h == 0) error("rear: empty list");
-	return ((DLNode<T>*)h->bk)->hd;
-    }
-    const T& front() const {
-	if (h == 0) error("front: empty list");
-	return ((DLNode<T>*)h)->hd; }
-    const T& rear() const {
-	if (h == 0) error("rear: empty list");
-	return ((DLNode<T>*)h->bk)->hd;
-    }
-    T remove_front() { T dst; BaseDLList::remove_front(&dst); return dst; }
-    T remove_rear() { T dst; BaseDLList::remove_rear(&dst); return dst; }
-
-    T&                  operator () (Pix p) {
-	if (p == 0) error("null Pix");
-	return ((DLNode<T>*)p)->hd;
-    }
-    const T&              operator () (Pix p) const {
-	if (p == 0) error("null Pix");
-	return ((DLNode<T>*)p)->hd;
-    }
-    Pix                   first() const { return Pix(h); }
-    Pix                   last()  const { return (h == 0) ? 0 : Pix(h->bk); }
-    void                  next(Pix& p) const
-	{ p = (p == 0 || h == 0 || p == h->bk)? 0 : Pix(((DLNode<T>*)p)->fd); }
-    void                  prev(Pix& p) const
-	{ p = (p == 0 || p == h)? 0 : Pix(((DLNode<T>*)p)->bk); }
-    Pix ins_after(Pix p, const T& item)
-      {return BaseDLList::ins_after(p, &item); }
-    Pix ins_before(Pix p, const T& item)
-      {return BaseDLList::ins_before(p, &item);}
-};
-
-#endif
diff --git a/src/Makefile.in b/src/Makefile.in
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -74,29 +74,27 @@ OV_INCLUDES := ov-re-mat.h ov-cx-mat.h o
 	ov-base-nd-array.h ov-re-nd-array.h ov-typeinfo.h
 
 PT_INCLUDES := pt.h pt-all.h pt-arg-list.h pt-assign.h pt-binop.h \
         pt-bp.h	pt-cell.h pt-check.h pt-cmd.h pt-colon.h pt-const.h \
 	pt-decl.h pt-except.h pt-exp.h pt-id.h pt-idx.h \
 	pt-jump.h pt-loop.h pt-mat.h pt-misc.h pt-plot.h \
 	pt-pr-code.h pt-select.h pt-stmt.h pt-unop.h pt-walk.h \
 
-INCLUDES := BaseSLList.h Cell.h DLList.h Map.h Pix.h SLList.h \
-	SLStack.h Stack.h c-file-ptr-stream.h comment-list.h defun-dld.h \
+INCLUDES := Cell.h c-file-ptr-stream.h comment-list.h defun-dld.h \
 	defun-int.h defun.h dirfns.h dynamic-ld.h error.h file-io.h \
 	fn-cache.h gripes.h help.h input.h lex.h load-save.h \
 	oct-fstrm.h oct-hist.h oct-iostrm.h oct-map.h oct-obj.h \
 	oct-prcstrm.h oct-procbuf.h oct-stdstrm.h \
 	oct-stream.h oct-strstrm.h oct-lvalue.h oct.h octave.h \
 	ops.h pager.h parse.h pr-output.h procstream.h sighandlers.h \
 	siglist.h symtab.h sysdep.h token.h toplev.h unwind-prot.h utils.h \
 	variables.h version.h xdiv.h xpow.h $(OV_INCLUDES) $(PT_INCLUDES)
 
-TI_XSRC := Array-oc.cc Array-os.cc Array-sym.cc Array-tc.cc Map-oct-obj.cc \
-	SLList-expr.cc SLList-misc.cc SLList-plot.cc SLList-tc.cc SLList-tm.cc
+TI_XSRC := Array-oc.cc Array-os.cc Array-sym.cc Array-tc.cc
 
 TI_SRC := $(addprefix TEMPLATE-INST/, $(TI_XSRC))
 
 OP_XSRC := op-b-b.cc op-bm-b.cc op-bm-bm.cc op-cell.cc \
 	op-chm.cc op-cm-cm.cc op-cm-cs.cc op-cm-m.cc \
 	op-cm-s.cc op-cs-cm.cc op-cs-cs.cc op-cs-m.cc \
 	op-cs-s.cc op-fil-b.cc op-fil-bm.cc op-fil-cm.cc \
 	op-fil-cs.cc op-fil-m.cc op-fil-s.cc op-fil-lis.cc \
@@ -116,18 +114,17 @@ OV_SRC := ov-base.cc ov-base-mat.cc ov-b
 	ov-typeinfo.cc
 
 PT_SRC := pt.cc pt-arg-list.cc pt-assign.cc pt-bp.cc pt-binop.cc pt-cell.cc \
 	pt-check.cc pt-cmd.cc pt-colon.cc pt-const.cc pt-decl.cc \
 	pt-except.cc pt-exp.cc pt-id.cc pt-idx.cc pt-jump.cc \
 	pt-loop.cc pt-mat.cc pt-misc.cc pt-plot.cc pt-pr-code.cc \
 	pt-select.cc pt-stmt.cc pt-unop.cc
 
-DIST_SRC := BaseSLList.cc Cell.cc DLList.cc Map.cc SLList.cc \
-	SLStack.cc Stack.cc c-file-ptr-stream.cc comment-list.cc \
+DIST_SRC := Cell.cc c-file-ptr-stream.cc comment-list.cc \
 	cutils.c data.cc debug.cc defaults.cc defun.cc dirfns.cc \
 	dynamic-ld.cc error.cc file-io.cc fn-cache.cc gripes.cc \
 	help.cc input.cc lex.l load-save.cc main.c mappers.cc \
 	matherr.c oct-fstrm.cc oct-hist.cc oct-iostrm.cc \
 	oct-map.cc oct-obj.cc oct-prcstrm.cc oct-procbuf.cc \
 	oct-stdstrm.cc oct-stream.cc \
 	oct-strstrm.cc oct-lvalue.cc pager.cc parse.y \
 	pr-output.cc procstream.cc sighandlers.cc \
@@ -161,17 +158,17 @@ DEP_3 := $(patsubst %.l, %.cc, $(DEP_4))
 DEP_2 := $(patsubst %.y, %.cc, $(DEP_3))
 DEP_1 := $(patsubst %.c, %.d, $(DEP_2))
 MAKEDEPS := $(patsubst %.cc, %.d, $(DEP_1))
 
 # Some stupid egreps don't like empty elements in alternation patterns,
 # so we have to repeat ourselves because some stupid egreps don't like
 # empty elements in alternation patterns.
 
-DEFUN_PATTERN = "^[ \t]*DEFU(N|N_DLD|N_TEXT|N_MAPPER)[ \t]*\\("
+DEFUN_PATTERN = "^[ \t]*DEF(CMD|UN|UN_DLD|UN_TEXT|UN_MAPPER)[ \t]*\\("
 
 DLD_DEF_FILES := $(patsubst %.cc, %.df, $(DLD_XSRC))
 
 DEF_4 := $(addprefix $(srcdir)/, $(SOURCES))
 DEF_3 := $(notdir $(shell egrep -l $(DEFUN_PATTERN) $(DEF_4)))
 DEF_2 := $(patsubst %.y, %.df, $(DEF_3))
 DEF_1 := $(patsubst %.l, %.df, $(DEF_2))
 DEF_FILES := $(patsubst %.cc, %.df, $(DEF_1)) $(DLD_DEF_FILES)
diff --git a/src/Map.cc b/src/Map.cc
deleted file mode 100644
--- a/src/Map.cc
+++ /dev/null
@@ -1,303 +0,0 @@
-/*
-
-Copyright (C) 1996, 1997 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 2, or (at your option) any
-later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, write to the Free
-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-
-/*
-
-The classes in this file are derived from the old `genclass' versions
-of Map and CHMap from libg++, originally:
-
-  Copyright (C) 1988 Free Software Foundation
-    written by Doug Lea (dl@rocky.oswego.edu)
-
-and distributed under the terms of the GNU Library General Public
-License as published by the Free Software Foundation.
-
-*/
-
-#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
-#pragma implementation
-#endif
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <iostream>
-
-#include "Map.h"
-
-template <class C>
-unsigned int
-CHMap<C>::hash (const std::string& str) const
-{
-  unsigned h = 0;
-  for (unsigned i = 0; i < str.length (); i++)
-    h = h * 33 + str[i];
-  return h;
-}
-
-template <class C>
-Pix
-Map<C>::seek (const std::string& item) const
-{
-  Pix i = 0;
-
-  for (i = first (); i != 0 && key (i) != item; next (i))
-    ; // Skip items until match found.
-
-  return i;
-}
-
-template <class C>
-int
-Map<C>::owns (Pix idx) const
-{
-  if (idx == 0)
-    return 0;
-
-  for (Pix i = first (); i != 0; next (i))
-    if (i == idx)
-      return 1;
-
-  return 0;
-}
-
-template <class C>
-void
-Map<C>::clear (void)
-{
-  Pix i = first ();
-  while (i != 0)
-    {
-      del (key (i));
-      i = first ();
-    }
-}
-
-template <class C>
-int
-Map<C>::contains (const std::string& item) const
-{
-  return seek (item) != 0;
-}
-
-template <class C>
-void
-Map<C>::error (const std::string& msg) const
-{
-  std::cerr << "Map: " << msg << "\n";
-}
-
-// CHMap class.
-
-#define index_to_CHptr(i) (X_CAST (void *, (i << 1) + 1))
-
-template <class C>
-CHMap<C>::CHMap (const C& dflt, unsigned int sz) : Map<C> (dflt)
-{
-  tab = new CHNode<C>* [size = sz];
-  for (unsigned int i = 0; i < size; ++i)
-    tab[i] = static_cast<CHNode<C> *> (index_to_CHptr (i+1));
-  count = 0;
-}
-
-template <class C>
-CHMap<C>::CHMap (const CHMap& a) : Map<C> (a.def)
-{
-  tab = new CHNode<C>* [size = a.size];
-  for (unsigned int i = 0; i < size; ++i)
-    tab[i] = static_cast<CHNode<C> *> (index_to_CHptr (i+1));
-  count = 0;
-  for (Pix p = a.first (); p; a.next (p))
-    (*this) [a.key (p)] = a.contents (p);
-}
-
-template <class C>
-CHMap<C>&
-CHMap<C>::operator = (const CHMap& a)
-{
-  Map<C>::operator = (*this);
-
-  unsigned int old_size = a.size;
-
-  CHNode<C> **old_tab = tab;
-  old_size = a.size;
-
-  size = old_size;
-  tab = new CHNode<C>* [size];
-
-  for (unsigned int i = 0; i < size; ++i)
-    tab[i] = static_cast<CHNode<C> *> (index_to_CHptr (i+1));
-
-  for (Pix p = a.first (); p; a.next (p))
-    (*this) [a.key (p)] = a.contents (p);
-
-  for (unsigned int i = 0; i < old_size; ++i)
-    {
-      CHNode<C> *p = old_tab[i];
-      old_tab[i] = static_cast<CHNode<C> *> (index_to_CHptr (i+1));
-      while (p->goodCHptr ())
-	{
-	  CHNode<C> *nxt = p->tl;
-	  delete p;
-	  p = nxt;
-	}
-    }
-  delete [] old_tab;
-
-  return *this;
-}
-
-template <class C>
-Pix
-CHMap<C>::seek (const std::string& key) const
-{
-  unsigned int h = hash (key) % size;
-
-  for (CHNode<C> *t = tab[h]; t->goodCHptr (); t = t->tl)
-    if (key == t->hd)
-      return Pix (t);
-
-  return 0;
-}
-
-template <class C>
-C&
-CHMap<C>::operator [] (const std::string& item)
-{
-  unsigned int h = hash (item) % size;
-
-  CHNode<C> *t = 0;
-  for (t = tab[h]; t->goodCHptr (); t = t->tl)
-    if (item == t->hd)
-      return t->cont;
-
-  t = new CHNode<C> (item, def, tab[h]);
-  tab[h] = t;
-  ++count;
-  return t->cont;
-}
-
-template <class C>
-void
-CHMap<C>::del (const std::string& key)
-{
-  unsigned int h = hash (key) % size;
-
-  CHNode<C> *t = tab[h];
-  CHNode<C> *trail = t;
-  while (t->goodCHptr ())
-    {
-      if (key == t->hd)
-	{
-	  if (trail == t)
-	    tab[h] = t->tl;
-	  else
-	    trail->tl = t->tl;
-	  delete t;
-	  --count;
-	  return;
-	}
-      trail = t;
-      t = t->tl;
-    }
-}
-
-template <class C>
-void
-CHMap<C>::clear (void)
-{
-  for (unsigned int i = 0; i < size; ++i)
-    {
-      CHNode<C> *p = tab[i];
-      tab[i] = static_cast<CHNode<C> *> (index_to_CHptr (i+1));
-      while (p->goodCHptr ())
-	{
-	  CHNode<C> *nxt = p->tl;
-	  delete p;
-	  p = nxt;
-	}
-    }
-  count = 0;
-}
-
-template <class C>
-Pix
-CHMap<C>::first (void) const
-{
-  for (unsigned int i = 0; i < size; ++i)
-    if (tab[i]->goodCHptr ())
-      return Pix (tab[i]);
-  return 0;
-}
-
-template <class C>
-void
-CHMap<C>::next (Pix& p) const
-{
-  CHNode<C> *t = (static_cast<CHNode<C> *> (p))->tl;
-  if (t->goodCHptr ())
-    p = Pix (t);
-  else
-    {
-      for (unsigned int i = t->CHptr_to_index (); i < size; ++i)
-	{
-	  if (tab[i]->goodCHptr ())
-	    {
-	      p =  Pix (tab[i]);
-	      return;
-	    }
-	}
-      p = 0;
-    }
-}
-
-template <class C>
-int
-CHMap<C>::OK (void) const
-{
-  int v = tab != 0;
-  int n = 0;
-
-  for (unsigned int i = 0; i < size; ++i)
-    {
-      CHNode<C> *p = 0;
-
-      for (p = tab[i]; p->goodCHptr (); p = p->tl)
-	++n;
-
-      v &= p->CHptr_to_index () == i + 1;
-    }
-
-  v &= count == n;
-
-  if (! v)
-    error ("invariant failure");
-
-  return v;
-}
-
-/*
-;;; Local Variables: ***
-;;; mode: C++ ***
-;;; End: ***
-*/
diff --git a/src/Map.h b/src/Map.h
deleted file mode 100644
--- a/src/Map.h
+++ /dev/null
@@ -1,188 +0,0 @@
-/*
-
-Copyright (C) 1996, 1997 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 2, or (at your option) any
-later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, write to the Free
-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-
-/*
-
-The classes in this file are derived from the old `genclass' versions
-of Map and CHMap from libg++, originally:
-
-  Copyright (C) 1988 Free Software Foundation
-    written by Doug Lea (dl@rocky.oswego.edu)
-
-and distributed under the terms of the GNU Library General Public
-License as published by the Free Software Foundation.
-
-*/
-
-#if ! defined (octave_Map_h)
-#define octave_Map_h 1
-
-#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
-#pragma interface
-#endif
-
-#include <string>
-
-#include <Pix.h>
-
-template <class C>
-class
-Map
-{
-protected:
-  int count;
-  C def;
-
-public:
-  Map (const C& dflt) : count (0), def (dflt) { }
-
-  Map (const Map& m) : count (m.count), def (m.def) { }
-
-  Map& operator = (const Map& m)
-    {
-      count = m.count;
-      def = m.def;
-
-      return *this;
-    }
-
-  virtual ~Map (void) { }
-
-  int length (void) const { return count; }	// current number of items
-  int empty (void) const { return count == 0; }
-
-  virtual int contains (const std::string& key) const;  // is key mapped?
-
-  virtual void clear (void);			// delete all items
-	      
-  virtual C& operator [] (const std::string& key) = 0;  // access contents by key
-
-  virtual void del (const std::string& key) = 0;	// delete entry
-	      
-  virtual Pix first (void) const = 0;		// Pix of first item or 0
-  virtual void next (Pix& i) const = 0;		// advance to next or 0
-  virtual std::string key (Pix i) const = 0;		// access key at i
-  virtual C& contents (Pix i) const = 0;	// access contents at i
-
-  virtual int owns (Pix i) const;		// is i a valid Pix  ?
-  virtual Pix seek (const std::string& key) const;	// Pix of key
-
-  C& dflt (void) { return def; }		// access default val
-
-  void error (const std::string& msg) const;
-
-  virtual int OK (void) const = 0;		// rep invariant
-};
-
-template <class C>
-struct CHNode
-{
-  CHNode *tl;
-  std::string hd;
-  C cont;
-
-  CHNode (void) : tl (0), hd (), cont () { }
-
-  CHNode (const std::string& h, const C& c, CHNode *t = 0)
-    : tl (t), hd (h), cont (c) { }
-
-  ~CHNode (void) { }
-
-  // The nodes are linked together serially via a version of a trick
-  // used in some vtables: odd pointers are actually links to the next
-  // table entry.  Not terrible, but not wonderful either.
-
-  int goodCHptr (void)
-    { return ((((unsigned long) this) & 1) == 0); }
-
-  unsigned int CHptr_to_index (void)
-    { return (((unsigned long) this) >> 1); }
-};
-
-#ifndef DEFAULT_INITIAL_CAPACITY
-#define DEFAULT_INITIAL_CAPACITY 8
-#endif
-
-template <class C>
-class
-CHMap : public Map<C>
-{
-protected:
-  CHNode<C> **tab;
-  unsigned int size;
-
-public:
-  CHMap (const C& dflt, unsigned int sz = DEFAULT_INITIAL_CAPACITY);
-
-  CHMap (const CHMap& a);
-
-  CHMap& operator = (const CHMap& a);
-
-  ~CHMap (void)
-    {
-      clear ();
-      delete [] tab;
-    }
-
-  C& operator [] (const std::string& key);
-
-  void del (const std::string& key);
-
-  Pix first (void) const;
-  void next (Pix& i) const;
-
-  std::string key (Pix p) const
-    {
-      if (p == 0)
-	error ("null Pix");
-
-      return ((CHNode<C> *) p)->hd;
-    }
-
-  C& contents (Pix p) const
-    {
-      if (p == 0)
-	error ("null Pix");
-
-      return ((CHNode<C> *) p)->cont;
-    }
-
-  Pix seek (const std::string& key) const;
-
-  int contains (const std::string& key) const
-    {
-      return seek (key) != 0;
-    }
-
-  void clear (void);
-  int  OK (void) const;
-
-  unsigned int hash (const std::string& str) const;
-};
-
-#endif
-
-/*
-;;; Local Variables: ***
-;;; mode: C++ ***
-;;; End: ***
-*/
diff --git a/src/Pix.h b/src/Pix.h
deleted file mode 100644
--- a/src/Pix.h
+++ /dev/null
@@ -1,5 +0,0 @@
-
-#ifndef _Pix_h
-#define _Pix_h 1
-typedef void* Pix;
-#endif
diff --git a/src/SLList.cc b/src/SLList.cc
deleted file mode 100644
--- a/src/SLList.cc
+++ /dev/null
@@ -1,39 +0,0 @@
-// This may look like C code, but it is really -*- C++ -*-
-/* 
-Copyright (C) 1988, 1992 Free Software Foundation
-    written by Doug Lea (dl@rocky.oswego.edu)
-
-This file is part of the GNU C++ Library.  This library is free
-software; you can redistribute it and/or modify it under the terms of
-the GNU Library General Public License as published by the Free
-Software Foundation; either version 2 of the License, or (at your
-option) any later version.  This library is distributed in the hope
-that it will be useful, but WITHOUT ANY WARRANTY; without even the
-implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
-PURPOSE.  See the GNU Library General Public License for more details.
-You should have received a copy of the GNU Library General Public
-License along with this library; if not, write to the Free Software
-Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
-*/
-
-#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
-#pragma implementation
-#endif
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "SLList.h"
-
-template <class T>
-SLList<T>::~SLList (void)
-{
-  clear();
-}
-
-/*
-;;; Local Variables: ***
-;;; mode: C++ ***
-;;; End: ***
-*/
diff --git a/src/SLList.h b/src/SLList.h
deleted file mode 100644
--- a/src/SLList.h
+++ /dev/null
@@ -1,99 +0,0 @@
-// This may look like C code, but it is really -*- C++ -*-
-/* 
-Copyright (C) 1988, 1992 Free Software Foundation
-    written by Doug Lea (dl@rocky.oswego.edu)
-
-This file is part of the GNU C++ Library.  This library is free
-software; you can redistribute it and/or modify it under the terms of
-the GNU Library General Public License as published by the Free
-Software Foundation; either version 2 of the License, or (at your
-option) any later version.  This library is distributed in the hope
-that it will be useful, but WITHOUT ANY WARRANTY; without even the
-implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
-PURPOSE.  See the GNU Library General Public License for more details.
-You should have received a copy of the GNU Library General Public
-License along with this library; if not, write to the Free Software
-Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
-*/
-
-#ifndef _SLList_h
-#define _SLList_h 1
-
-#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
-#pragma interface
-#endif
-
-#include <Pix.h>
-
-#include "BaseSLList.h"
-
-template<class T>
-class
-SLNode : public BaseSLNode
-{
-  public:
-    T                    hd; // Data part of node
-                         SLNode() { }
-                         SLNode(const T& h, SLNode* t = 0)
-			     : hd(h) { tl = t; }
-                         ~SLNode() { }
-};
-
-template <class T>
-class
-SLList : public BaseSLList
-{
-  private:
-    virtual void delete_node(BaseSLNode *node) { delete (SLNode<T>*)node; }
-    virtual BaseSLNode* copy_node(const void *datum)
-	{ return new SLNode<T>(*(const T*)datum); }
-    virtual void copy_item(void *dst, void *src) { *(T*)dst = *(T*)src; }
-
-public:
-    SLList() : BaseSLList() { }
-    SLList(const SLList<T>& a) : BaseSLList() { copy(a); }
-    SLList<T>&            operator = (const SLList<T>& a)
-	{ BaseSLList::operator=((const BaseSLList&) a); return *this; }
-    ~SLList (void);
-
-    Pix prepend(const T& item) {return BaseSLList::prepend(&item);}
-    Pix append(const T& item) {return BaseSLList::append(&item);}
-    Pix prepend(SLNode<T>* node) {return BaseSLList::prepend(node);}
-    Pix append(SLNode<T>* node) {return BaseSLList::append(node);}
-
-    T& operator () (Pix p) {
-	if (p == 0) error("null Pix");
-	return ((SLNode<T>*)(p))->hd; }
-    const T& operator () (Pix p) const {
-	if (p == 0) error("null Pix");
-	return ((SLNode<T>*)(p))->hd; }
-    inline Pix first() const { return (last == 0) ? 0 : Pix(last->tl); }
-    void next(Pix& p) const
-	{ p = (p == 0 || p == last) ? 0 : Pix(((SLNode<T>*)(p))->tl); }
-    Pix ins_after(Pix p, const T& item)
-      { return BaseSLList::ins_after(p, &item); }
-    void join(SLList<T>& a) { BaseSLList::join(a); }
-    
-    T& front() {
-	if (last == 0) error("front: empty list");
-	return ((SLNode<T>*)last->tl)->hd; }
-    T& rear() {
-	if (last == 0) error("rear: empty list");
-	return ((SLNode<T>*)last)->hd; }
-    const T& front() const {
-	if (last == 0) error("front: empty list");
-	return ((SLNode<T>*)last->tl)->hd; }
-    const T& rear() const {
-	if (last == 0) error("rear: empty list");
-	return ((SLNode<T>*)last)->hd; }
-    int remove_front(T& x) { return BaseSLList::remove_front(&x); }
-    T remove_front() { T dst; BaseSLList::remove_front(&dst, 1); return dst; }
-};
-
-#endif
-
-/*
-;;; Local Variables: ***
-;;; mode: C++ ***
-;;; End: ***
-*/
diff --git a/src/SLStack.cc b/src/SLStack.cc
deleted file mode 100644
--- a/src/SLStack.cc
+++ /dev/null
@@ -1,43 +0,0 @@
-// This may look like C code, but it is really -*- C++ -*-
-/* 
-Copyright (C) 1988, 1992 Free Software Foundation
-    written by Doug Lea (dl@rocky.oswego.edu)
-
-This file is part of the GNU C++ Library.  This library is free
-software; you can redistribute it and/or modify it under the terms of
-the GNU Library General Public License as published by the Free
-Software Foundation; either version 2 of the License, or (at your
-option) any later version.  This library is distributed in the hope
-that it will be useful, but WITHOUT ANY WARRANTY; without even the
-implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
-PURPOSE.  See the GNU Library General Public License for more details.
-You should have received a copy of the GNU Library General Public
-License along with this library; if not, write to the Free Software
-Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
-*/
-
-#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
-#pragma implementation
-#endif
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "SLStack.h"
-
-template <class T>
-SLStack<T>&
-SLStack<T>::operator = (const SLStack<T>& s)
-{
-  if (this != &s)
-    p = s.p;
-
-  return *this;
-}
-
-/*
-;;; Local Variables: ***
-;;; mode: C++ ***
-;;; End: ***
-*/
diff --git a/src/SLStack.h b/src/SLStack.h
deleted file mode 100644
--- a/src/SLStack.h
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
-
-Copyright (C) 1996, 1997 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 2, or (at your option) any
-later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, write to the Free
-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-
-/*
-
-The classes in this file are derived from the old `genclass' version
-of SLStack from libg++, originally:
-
-  Copyright (C) 1988 Free Software Foundation
-    written by Doug Lea (dl@rocky.oswego.edu)
-
-and distributed under the terms of the GNU Library General Public
-License as published by the Free Software Foundation.
-
-*/
-
-#if !defined (_SLStack_h)
-#define _SLStack_h 1
-
-#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
-#pragma interface
-#endif
-
-#include "SLList.h"
-#include "Stack.h"
-
-template <class T>
-class
-SLStack : public Stack<T>
-{
-private:
-
-  SLList<T> p;
-
-public:
-
-  SLStack (void) : p () { }
-
-  SLStack (const SLStack<T>& s) : p (s.p) { }
-
-  ~SLStack (void) { }
-
-  SLStack<T>& operator = (const SLStack<T>& s);
-
-  void push (const T& item) { p.prepend (item); }
-
-  T pop (void) { return p.remove_front (); }
-
-  T& top (void) { return p.front (); }
-
-  void del_top (void) { p.del_front (); }
-
-  int empty (void) { return p.empty (); }
-
-  int full (void) { return 0; }
-
-  int length (void) { return p.length (); }
-
-  void clear (void) { p.clear (); }
-
-  int OK (void) { return p.OK (); }
-};
-
-#endif
-
-/*
-;;; Local Variables: ***
-;;; mode: C++ ***
-;;; End: ***
-*/
diff --git a/src/Stack.cc b/src/Stack.cc
deleted file mode 100644
--- a/src/Stack.cc
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
-
-Copyright (C) 1996, 1997 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 2, or (at your option) any
-later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, write to the Free
-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-
-#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
-#pragma implementation
-#endif
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <iostream>
-
-#include "Stack.h"
-
-template <class T>
-void
-Stack<T>::error (const char *msg)
-{
-  std::cerr << msg;
-}
-
-/*
-;;; Local Variables: ***
-;;; mode: C++ ***
-;;; End: ***
-*/
diff --git a/src/Stack.h b/src/Stack.h
deleted file mode 100644
--- a/src/Stack.h
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
-
-Copyright (C) 1996, 1997 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 2, or (at your option) any
-later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, write to the Free
-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-
-/*
-
-The classes in this file are derived from the old `genclass' version
-of Stack from libg++, originally:
-
-  Copyright (C) 1988 Free Software Foundation
-    written by Doug Lea (dl@rocky.oswego.edu)
-
-and distributed under the terms of the GNU Library General Public
-License as published by the Free Software Foundation.
-
-*/
-
-#if !defined (_Stack_h)
-#define _Stack_h 1
-
-#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
-#pragma interface
-#endif
-
-template <class T>
-class
-Stack
-{
- public:
-
-  Stack (void) { }
-
-  virtual ~Stack (void) { }
-
-  virtual void push (const T& item) = 0;
-
-  virtual T pop (void) = 0;
-  virtual T& top (void) = 0; 
-
-  virtual void del_top (void) = 0;
-
-  virtual int empty (void) = 0;
-  virtual int full (void) = 0;
-  virtual int length (void) = 0;
-
-  virtual void clear (void) = 0;
-
-  void error (const char *msg);
-
-  virtual int OK (void) = 0;
-};
-
-#endif
diff --git a/src/TEMPLATE-INST/Map-oct-obj.cc b/src/TEMPLATE-INST/Map-oct-obj.cc
deleted file mode 100644
--- a/src/TEMPLATE-INST/Map-oct-obj.cc
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
-
-Copyright (C) 2002 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 2, or (at your option) any
-later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, write to the Free
-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-
-// Instantiate Maps of octave_value_lists.
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "Map.h"
-#include "Map.cc"
-
-#include "oct-obj.h"
-
-template class Map<octave_value_list>;
-template class CHNode<octave_value_list>;
-template class CHMap<octave_value_list>;
-
-/*
-;;; Local Variables: ***
-;;; mode: C++ ***
-;;; End: ***
-*/
diff --git a/src/TEMPLATE-INST/SLList-expr.cc b/src/TEMPLATE-INST/SLList-expr.cc
deleted file mode 100644
--- a/src/TEMPLATE-INST/SLList-expr.cc
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
-
-Copyright (C) 1996, 1997 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 2, or (at your option) any
-later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, write to the Free
-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-
-// Instantiate Lists of various values.
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "SLList.h"
-#include "SLList.cc"
-
-#include "oct-obj.h"
-#include "pt-exp.h"
-#include "pt-id.h"
-#include "pt-idx.h"
-
-template class SLNode<tree_expression *>;
-template class SLList<tree_expression *>;
-
-template class SLNode<tree_identifier *>;
-template class SLList<tree_identifier *>;
-
-template class SLNode<tree_index_expression *>;
-template class SLList<tree_index_expression *>;
-
-/*
-;;; Local Variables: ***
-;;; mode: C++ ***
-;;; End: ***
-*/
diff --git a/src/TEMPLATE-INST/SLList-misc.cc b/src/TEMPLATE-INST/SLList-misc.cc
deleted file mode 100644
--- a/src/TEMPLATE-INST/SLList-misc.cc
+++ /dev/null
@@ -1,57 +0,0 @@
-/*
-
-Copyright (C) 1996, 1997 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 2, or (at your option) any
-later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, write to the Free
-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-
-// Instantiate Lists of various values.
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "SLList.h"
-#include "SLList.cc"
-
-#include "ov.h"
-#include "pt-arg-list.h"
-#include "pt-decl.h"
-#include "pt-select.h"
-#include "pt-stmt.h"
-
-template class SLNode<tree_argument_list *>;
-template class SLList<tree_argument_list *>;
-
-template class SLNode<tree_statement *>;
-template class SLList<tree_statement *>;
-
-template class SLNode<tree_if_clause *>;
-template class SLList<tree_if_clause *>;
-
-template class SLList<tree_switch_case *>;
-template class SLNode<tree_switch_case *>;
-
-template class SLList<tree_decl_elt *>;
-template class SLNode<tree_decl_elt *>;
-
-/*
-;;; Local Variables: ***
-;;; mode: C++ ***
-;;; End: ***
-*/
diff --git a/src/TEMPLATE-INST/SLList-plot.cc b/src/TEMPLATE-INST/SLList-plot.cc
deleted file mode 100644
--- a/src/TEMPLATE-INST/SLList-plot.cc
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
-
-Copyright (C) 1996, 1997 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 2, or (at your option) any
-later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, write to the Free
-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-
-// Instantiate Lists of various values.
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "SLList.h"
-#include "SLList.cc"
-
-#include "ov.h"
-#include "pt-plot.h"
-
-template class SLNode<subplot *>;
-template class SLList<subplot *>;
-
-/*
-;;; Local Variables: ***
-;;; mode: C++ ***
-;;; End: ***
-*/
diff --git a/src/TEMPLATE-INST/SLList-tc.cc b/src/TEMPLATE-INST/SLList-tc.cc
deleted file mode 100644
--- a/src/TEMPLATE-INST/SLList-tc.cc
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
-
-Copyright (C) 1996, 1997 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 2, or (at your option) any
-later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, write to the Free
-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-
-// Instantiate Lists of various values.
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "SLList.h"
-#include "SLList.cc"
-
-#include "oct-obj.h"
-
-template class SLNode<octave_value>;
-template class SLList<octave_value>;
-
-/*
-;;; Local Variables: ***
-;;; mode: C++ ***
-;;; End: ***
-*/
diff --git a/src/TEMPLATE-INST/SLList-tm.cc b/src/TEMPLATE-INST/SLList-tm.cc
deleted file mode 100644
--- a/src/TEMPLATE-INST/SLList-tm.cc
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
-
-Copyright (C) 1996, 1997 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 2, or (at your option) any
-later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, write to the Free
-Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-
-*/
-
-// Instantiate Stacks of tree_matrix* values.
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include "SLList.h"
-#include "SLList.cc"
-
-#include "oct-obj.h"
-#include "pt-mat.h"
-
-template class SLNode<tree_matrix *>;
-template class SLList<tree_matrix *>;
-
-/*
-;;; Local Variables: ***
-;;; mode: C++ ***
-;;; End: ***
-*/
diff --git a/src/comment-list.cc b/src/comment-list.cc
--- a/src/comment-list.cc
+++ b/src/comment-list.cc
@@ -28,21 +28,16 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include "lo-utils.h"
 
 #include "comment-list.h"
 #include "error.h"
 
-#include "SLList.h"
-#include "SLList.cc"
-
-template class SLList<octave_comment_elt>;
-
 octave_comment_buffer *octave_comment_buffer::instance = 0;
 
 bool
 octave_comment_buffer::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
diff --git a/src/comment-list.h b/src/comment-list.h
--- a/src/comment-list.h
+++ b/src/comment-list.h
@@ -24,17 +24,17 @@ Software Foundation, 59 Temple Place - S
 #define octave_comment_list_h 1
 
 #if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
 #pragma interface
 #endif
 
 #include <string>
 
-#include <SLList.h>
+#include <base-list.h>
 
 extern std::string get_comment_text (void);
 
 extern char *get_comment_text_c_str (void);
 
 extern void save_comment_text (const std::string& text);
 
 class
@@ -80,53 +80,26 @@ private:
   // The text of the comment.
   std::string txt;
 
   // The type of comment.
   comment_type typ;
 };
 
 class
-octave_comment_list
+octave_comment_list : public octave_base_list<octave_comment_elt>
 {
 public:
 
-  octave_comment_list (void) : lst () { }
-
-  ~octave_comment_list (void) { }
+  void append (const octave_comment_elt& elt)
+    { octave_base_list<octave_comment_elt>::append (elt); }
 
   void append (const std::string& s,
 	       octave_comment_elt::comment_type t = octave_comment_elt::unknown)
-    { lst.append (octave_comment_elt (s, t)); }
-
-  octave_comment_list (const octave_comment_list& ocb)
-    : lst (ocb.lst) { }
-
-  octave_comment_list& operator = (const octave_comment_list& ocb)
-    {
-      if (this != &ocb)
-	lst = ocb.lst;
-
-      return *this;
-    }
-
-  int length (void) const { return lst.length (); }
-
-  octave_comment_elt& operator () (Pix p) { return lst (p); }
-
-  const octave_comment_elt& operator () (Pix p) const { return lst (p); }
-
-  Pix first (void) const { return lst.first (); }
-
-  void next (Pix& p) const { return lst.next (p); }
-
-private:
-
-  // The list of comments.
-  SLList<octave_comment_elt> lst;
+    { append (octave_comment_elt (s, t)); }
 };
 
 class
 octave_comment_buffer
 {
 public:
 
   octave_comment_buffer (void)
diff --git a/src/dynamic-ld.cc b/src/dynamic-ld.cc
--- a/src/dynamic-ld.cc
+++ b/src/dynamic-ld.cc
@@ -19,37 +19,34 @@ along with Octave; see the file COPYING.
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include <list>
+
 #include "oct-time.h"
 #include "file-stat.h"
 
-#include "DLList.h"
-
 #include <defaults.h>
 
 #include "defun.h"
 #include "dynamic-ld.h"
 #include "parse.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
 // TRUE means we print a warning if reloading a .oct file forces other
 // functions to be cleared.
 static bool Vwarn_reload_forces_clear;
 
-template class DLNode<octave_shlib>;
-template class DLList<octave_shlib>;
-
 class
 octave_shlib_list
 {
 public:
 
   static void append (const octave_shlib& shl);
 
   static void remove (octave_shlib& shl);
@@ -70,64 +67,69 @@ private:
   void *do_search (const std::string& fcn_name, octave_shlib& shl,
 		   octave_shlib::name_mangler mangler = 0);
 
   static octave_shlib_list *instance;
 
   static bool instance_ok (void);
 
   // List of libraries we have loaded.
-  DLList<octave_shlib> lib_list;
+  std::list<octave_shlib> lib_list;
 
   // No copying!
 
   octave_shlib_list (const octave_shlib_list&);
 
   octave_shlib_list& operator = (const octave_shlib_list&);
 };
 
 octave_shlib_list *octave_shlib_list::instance = 0;
 
 void
 octave_shlib_list::do_append (const octave_shlib& shl)
 {
-  lib_list.append (shl);
+  lib_list.push_back (shl);
 }
 
 void
 octave_shlib_list::do_remove (octave_shlib& shl)
 {
-  for (Pix p = lib_list.first (); p != 0; lib_list.next (p))
+  
+  for (std::list<octave_shlib>::iterator p = lib_list.begin ();
+       p != lib_list.end ();
+       p++)
     {
-      if (lib_list(p) == shl)
+      if (*p == shl)
 	{
 	  shl.close ();
 
-	  lib_list.del (p);
+	  lib_list.erase (p);
 
 	  break;
 	}
     }
 }
 
 void *
 octave_shlib_list::do_search (const std::string& fcn_name, octave_shlib& shl,
 			      octave_shlib::name_mangler mangler)
 {
   void *function = 0;
 
   shl = octave_shlib ();
 
-  for (Pix p = lib_list.first (); p != 0; lib_list.next (p))
+  for (std::list<octave_shlib>::iterator p = lib_list.begin ();
+       p != lib_list.end ();
+       p++)
     {
-      function = lib_list(p).search (fcn_name, mangler);
+      function = p->search (fcn_name, mangler);
 
       if (function)
 	{
-	  shl = lib_list(p);
+	  shl = *p;
 
 	  break;
 	}
     }
 
   return function;
 }
 
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -3850,27 +3850,26 @@ add_hdf5_data (hid_t loc_id, const octav
       data_id = H5Gcreate (loc_id, name.c_str (), 0);
       if (data_id < 0)
 	goto error_cleanup;
 
       data_is_group = 1;
 
       // recursively add each element of the structure to this group
       Octave_map m = tc.map_value ();
-      Pix i = m.first ();
-      while (i)
+      Octave_map::iterator i = m.begin ();
+      while (i != m.end ())
 	{
 	  bool retval2 = add_hdf5_data (data_id, 
 					m.contents (i), m.key (i), "",
 					false, save_as_floats);
 	  if (! retval2)
 	    goto error_cleanup;
 
-	  // advance i to next element, or 0
-	  m.next (i);
+	  i++;
 	}
     }
   else
     {
       gripe_wrong_type_arg ("save", tc, false);
       goto error_cleanup;
     }
 
@@ -4191,40 +4190,39 @@ save_mat5_binary_element (std::ostream& 
 	  m = ::imag (m_cmplx);
 	}
     }
   else if (tc.is_map ()) 
     {
       // an Octave structure */
       // recursively write each element of the structure
       Octave_map m = tc.map_value ();
-      Pix i;
 
       {
 	char buf[32];
 	FOUR_BYTE_INT maxfieldnamelength = 32;
 	int fieldcnt = 0;
 
-	for (i = m.first (); i; m.next (i))
+	for (Octave_map::iterator i = m.begin (); i != m.end (); i++)
 	  fieldcnt++;
 
 	write_mat5_tag (os, miINT32, 4);
 	os.write ((char *)&maxfieldnamelength, 4);
 	write_mat5_tag (os, miINT8, fieldcnt*32);
-	 
-	for (i = m.first (); i; m.next (i))
+
+	for (Octave_map::iterator i = m.begin (); i != m.end (); i++)
 	  {
 	    // write the name of each element
 	    std::string tstr = m.key (i);
 	    memset (buf, 0, 32);
 	    strncpy (buf, tstr.c_str (), 31); // only 31 char names permitted
 	    os.write (buf, 32);
 	  }
 
-	for (i = m.first (); i; m.next (i))
+	for (Octave_map::iterator i = m.begin (); i != m.end (); i++)
 	  {
 	    // write the data of each element
 	    bool retval2 = save_mat5_binary_element (os, m.contents (i), "",
 						     mark_as_global,
 						     save_as_floats);
 
 	    if (! retval2)
 	      goto error_cleanup;
diff --git a/src/oct-lvalue.cc b/src/oct-lvalue.cc
--- a/src/oct-lvalue.cc
+++ b/src/oct-lvalue.cc
@@ -37,17 +37,17 @@ octave_lvalue::assign (octave_value::ass
 		    : val->assign (op, type, idx, rhs));
 
   if (! (error_state || (chg_fcn && chg_fcn () < 0)))
     *val = tmp;
 }
 
 void
 octave_lvalue::set_index (const std::string& t,
-			  const SLList<octave_value_list>& i)
+			  const std::list<octave_value_list>& i)
 {
   if (! index_set)
     {
       type = t;
       idx = i;
       index_set = true;
     }
   else
diff --git a/src/oct-lvalue.h b/src/oct-lvalue.h
--- a/src/oct-lvalue.h
+++ b/src/oct-lvalue.h
@@ -23,18 +23,16 @@ Software Foundation, 59 Temple Place - S
 #if !defined (octave_lvalue_h)
 #define octave_lvalue_h 1
 
 class octave_value;
 class octave_value_list;
 
 #include <string>
 
-#include "SLList.h"
-
 #include "oct-obj.h"
 #include "pt-idx.h"
 #include "symtab.h"
 
 // XXX FIXME XXX -- eliminate the following kluge?
 
 // This variable is used when creating dummy octave_lvalue objects.
 static octave_value dummy_val;
@@ -73,32 +71,32 @@ public:
   bool is_undefined (void) { return val->is_undefined (); }
 
   bool is_map (void) { return val->is_map (); }
 
   void define (const octave_value& v) { *val = v; }
 
   void assign (octave_value::assign_op, const octave_value&);
 
-  void set_index (const std::string& t, const SLList<octave_value_list>& i);
+  void set_index (const std::string& t, const std::list<octave_value_list>& i);
 
   void clear_index (void) { type = std::string (); idx.clear (); }
 
   void do_unary_op (octave_value::unary_op op);
 
   octave_value value (void)
     { return idx.empty () ? *val : val->subsref (type, idx); }
 
 private:
 
   octave_value *val;
 
   std::string type;
 
-  SLList<octave_value_list> idx;
+  std::list<octave_value_list> idx;
 
   symbol_record::change_function chg_fcn;
 
   bool index_set;
 };
 
 #endif
 
diff --git a/src/oct-map.cc b/src/oct-map.cc
--- a/src/oct-map.cc
+++ b/src/oct-map.cc
@@ -32,41 +32,41 @@ Software Foundation, 59 Temple Place - S
 #include "str-vec.h"
 
 #include "oct-map.h"
 #include "utils.h"
 
 octave_value_list
 Octave_map::operator [] (const std::string& key) const
 {
-  Pix p = map.seek (key);
+  const_iterator p = seek (key);
 
-  return p ? map.contents (p) : octave_value_list ();
+  return p != end () ? p->second : octave_value_list ();
 }
 
 string_vector
 Octave_map::keys (void) const
 {
   int len = length ();
 
   string_vector names (len);
 
   int i = 0;
-  for (Pix p = first (); p != 0; next (p))
+  for (const_iterator p = begin (); p != end (); p++)
     names[i++] = key (p);
 
   return names;
 }
 
 int
 Octave_map::array_length (void) const
 {
   if (array_len == 0 && length () != 0)
     {
-      Pix p = first ();
+      const_iterator p = begin ();
       array_len = contents(p).length ();
     }
 
   return array_len;
 }
 
 static string_vector
 equiv_keys (const Octave_map& a, const Octave_map& b)
@@ -137,52 +137,52 @@ Octave_map::assign (const idx_vector& id
       int len = array_length ();
 
       if (rhs_len < len)
 	{
 	  tmp.resize (len, fill_value);
 	}
       else if (rhs_len > len)
 	{
-	  for (Pix p = first (); p != 0; next (p))
+	  for (iterator p = begin (); p != end (); p++)
 	    contents(p).resize (rhs_len, fill_value);
 
 	  array_len = rhs_len;
 	}
 
       map[key] = tmp;
     }
 
   return *this;
 }
 
 Octave_map&
 Octave_map::assign (const std::string& key, const octave_value_list& rhs)
 {
-  if (map.empty ())
+  if (empty ())
     map[key] = rhs;
   else
     {
-      octave_value_list tmp = map.contents (map.first ());
+      octave_value_list tmp = contents (begin ());
 
       if (tmp.length () == rhs.length ())
 	map[key] = rhs;
       else
 	error ("invalid structure assignment");
     }
 
   return *this;
 }
 
 Octave_map
 Octave_map::index (idx_vector& idx)
 {
   Octave_map retval;
 
-  for (Pix p = first (); p != 0; next (p))
+  for (iterator p = begin (); p != end (); p++)
     {
       octave_value_list tmp = contents(p).index (idx);
 
       if (error_state)
 	break;
 
       retval[key(p)] = tmp;
     }
diff --git a/src/oct-map.h b/src/oct-map.h
--- a/src/oct-map.h
+++ b/src/oct-map.h
@@ -22,30 +22,34 @@ Software Foundation, 59 Temple Place - S
 
 #if !defined (octave_oct_map_h)
 #define octave_oct_map_h 1
 
 #if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
 #pragma interface
 #endif
 
-#include "Map.h"
+#include <map>
 
 #include "oct-obj.h"
 
 class string_vector;
 
 class
 Octave_map
 {
  public:
-  Octave_map (void) : map (octave_value_list ()), array_len (0) { }
+
+  typedef std::map<std::string, octave_value_list>::iterator iterator;
+  typedef std::map<std::string, octave_value_list>::const_iterator const_iterator;
+
+  Octave_map (void) : map (), array_len (0) { }
 
   Octave_map (const std::string& key, const octave_value& value)
-    : map (octave_value_list ()), array_len (1)
+    : map (), array_len (1)
       {
 	map[key] = octave_value_list (value);
       }
 
   Octave_map (const Octave_map& m)
     : map (m.map), array_len (m.array_len) { }
 
   Octave_map& operator = (const Octave_map& m)
@@ -56,36 +60,49 @@ Octave_map
 	  array_len = m.array_len;
 	}
       return *this;
     }
 
   ~Octave_map (void) { }
 
   // This is the number of keys.
-  int length (void) const { return map.length (); }
+  int length (void) const { return map.size (); }
 
   int empty (void) const { return map.empty (); }
 
   octave_value_list& operator [] (const std::string& key) { return map[key]; }
 
   octave_value_list operator [] (const std::string& key) const;
 
-  void del (const std::string& key) { map.del (key); }
+  void del (const std::string& key)
+    {
+      iterator p = map.find (key);
+      if (p != map.end ())
+	map.erase (p);
+    }
 
-  Pix first (void) const { return map.first (); }
-  void next (Pix& i) const { map.next (i); }
+  iterator begin (void) { return iterator (map.begin ()); }
+  const_iterator begin (void) const { return const_iterator (map.begin ()); }
+
+  iterator end (void) { return iterator (map.end ()); }
+  const_iterator end (void) const { return const_iterator (map.end ()); }
 
-  std::string key (Pix p) const { return map.key (p); }
+  std::string key (const_iterator p) const { return p->first; }
 
-  octave_value_list& contents (Pix p) const { return map.contents (p); }
+  octave_value_list& contents (const_iterator p)
+    { return operator [] (key(p)); }
 
-  Pix seek (const std::string& key) const { return map.seek (key); }
+  octave_value_list contents (const_iterator p) const
+    { return operator [] (key(p)); }
 
-  int contains (const std::string& key) const { return map.contains (key); }
+  const_iterator seek (const std::string& key) const { return map.find (key); }
+
+  int contains (const std::string& key) const
+    { return (seek (key) != map.end ()); }
 
   void clear (void) { map.clear (); }
 
   string_vector keys (void) const;
 
   int rows (void) const { return 1; }
 
   int columns (void) const { return array_length (); }
@@ -99,17 +116,17 @@ Octave_map
 
   Octave_map& assign (const std::string& key, const octave_value_list& rhs);
 
   Octave_map index (idx_vector& idx);
 
 private:
 
   // The map of names to values.
-  CHMap<octave_value_list> map;
+  std::map<std::string, octave_value_list> map;
 
   // The current size of this struct array;
   mutable int array_len;
 };
 
 #endif
 
 /*
diff --git a/src/ov-base-mat.cc b/src/ov-base-mat.cc
--- a/src/ov-base-mat.cc
+++ b/src/ov-base-mat.cc
@@ -35,17 +35,17 @@ Software Foundation, 59 Temple Place - S
 #include "oct-map.h"
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "pr-output.h"
 
 template <class MT>
 octave_value
 octave_base_matrix<MT>::subsref (const std::string type,
-				 const SLList<octave_value_list>& idx)
+				 const std::list<octave_value_list>& idx)
 {
   octave_value retval;
 
   switch (type[0])
     {
     case '(':
       retval = do_index_op (idx.front ());
       break;
@@ -63,17 +63,17 @@ octave_base_matrix<MT>::subsref (const s
     }
 
   return retval.next_subsref (type, idx);
 }
 
 template <class MT>
 octave_value
 octave_base_matrix<MT>::subsasgn (const std::string type,
-				  const SLList<octave_value_list>& idx,
+				  const std::list<octave_value_list>& idx,
 				  const octave_value& rhs)
 {
   octave_value retval;
 
   switch (type[0])
     {
     case '(':
       {
@@ -139,48 +139,43 @@ octave_base_matrix<MT>::do_index_op (con
 	       len, n.c_str ());
       }
       break;
     }
 
   return retval;
 }
 
-#if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
-template <class MT>
-extern void assign (MT&, const MT&);
-#endif
-
 template <class MT>
 void
 octave_base_matrix<MT>::assign (const octave_value_list& idx, const MT& rhs)
 {
   int len = idx.length ();
 
   switch (len)
     {
     case 2:
       {
 	idx_vector i = idx (0).index_vector ();
 	idx_vector j = idx (1).index_vector ();
 
 	matrix.set_index (i);
 	matrix.set_index (j);
 
-	::assign (matrix, rhs);
+	::assign (matrix, rhs, MT::resize_fill_value ());
       }
       break;
 
     case 1:
       {
 	idx_vector i = idx (0).index_vector ();
 
 	matrix.set_index (i);
 
-	::assign (matrix, rhs);
+	::assign (matrix, rhs, MT::resize_fill_value ());
       }
       break;
 
     default:
       error ("invalid number of indices (%d) for indexed assignment",
 	     len);
       break;
     }
diff --git a/src/ov-base-mat.h b/src/ov-base-mat.h
--- a/src/ov-base-mat.h
+++ b/src/ov-base-mat.h
@@ -62,20 +62,20 @@ public:
     : octave_base_value (), matrix (m.matrix) { }
 
   ~octave_base_matrix (void) { }
 
   octave_value *clone (void) const { return new octave_base_matrix (*this); }
   octave_value *empty_clone (void) const { return new octave_base_matrix (); }
 
   octave_value subsref (const std::string type,
-			const SLList<octave_value_list>& idx);
+			const std::list<octave_value_list>& idx);
 
   octave_value subsasgn (const std::string type,
-			 const SLList<octave_value_list>& idx,
+			 const std::list<octave_value_list>& idx,
 			 const octave_value& rhs);
 
   octave_value do_index_op (const octave_value_list& idx, int resize_ok);
 
   octave_value do_index_op (const octave_value_list& idx)
     { return do_index_op (idx, 0); }
 
   void assign (const octave_value_list& idx, const MT& rhs);
diff --git a/src/ov-base-scalar.cc b/src/ov-base-scalar.cc
--- a/src/ov-base-scalar.cc
+++ b/src/ov-base-scalar.cc
@@ -35,17 +35,17 @@ Software Foundation, 59 Temple Place - S
 #include "ov-cx-mat.h"
 #include "ov-re-mat.h"
 #include "ov-base-scalar.h"
 #include "pr-output.h"
 
 template <class ST>
 octave_value
 octave_base_scalar<ST>::subsref (const std::string type,
-				 const SLList<octave_value_list>& idx)
+				 const std::list<octave_value_list>& idx)
 {
   octave_value retval;
 
   switch (type[0])
     {
     case '(':
       retval = do_index_op (idx.front ());
       break;
@@ -63,17 +63,17 @@ octave_base_scalar<ST>::subsref (const s
     }
 
   return retval.next_subsref (type, idx);
 }
 
 template <class ST>
 octave_value
 octave_base_scalar<ST>::subsasgn (const std::string type,
-				  const SLList<octave_value_list>& idx,
+				  const std::list<octave_value_list>& idx,
 				  const octave_value& rhs)
 {
   octave_value retval;
 
   switch (type[0])
     {
     case '(':
       {
diff --git a/src/ov-base-scalar.h b/src/ov-base-scalar.h
--- a/src/ov-base-scalar.h
+++ b/src/ov-base-scalar.h
@@ -55,20 +55,20 @@ public:
     : octave_base_value (), scalar (s) { }
 
   octave_base_scalar (const octave_base_scalar& s)
     : octave_base_value (), scalar (s.scalar) { }
 
   ~octave_base_scalar (void) { }
 
   octave_value subsref (const std::string type,
-			const SLList<octave_value_list>& idx);
+			const std::list<octave_value_list>& idx);
 
   octave_value subsasgn (const std::string type,
-			 const SLList<octave_value_list>& idx,
+			 const std::list<octave_value_list>& idx,
 			 const octave_value& rhs);
 
   int rows (void) const { return 1; }
 
   int columns (void) const { return 1; }
 
   int length (void) const { return 1; }
 
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -49,26 +49,26 @@ Software Foundation, 59 Temple Place - S
 #include "ov-scalar.h"
 #include "ov-str-mat.h"
 #include "variables.h"
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_base_value, "<unknown type>");
 
 octave_value
 octave_base_value::subsref (const std::string,
-			    const SLList<octave_value_list>&)
+			    const std::list<octave_value_list>&)
 {
   std::string nm = type_name ();
   error ("can't perform indexing operations for %s type", nm.c_str ());
   return octave_value ();
 }
 
 octave_value_list
 octave_base_value::subsref (const std::string,
-			    const SLList<octave_value_list>&, int)
+			    const std::list<octave_value_list>&, int)
 {
   std::string nm = type_name ();
   error ("can't perform indexing operations for %s type", nm.c_str ());
   return octave_value ();
 }
 
 octave_value
 octave_base_value::do_index_op (const octave_value_list&, int)
@@ -91,17 +91,17 @@ octave_base_value::index_vector (void) c
 {
   std::string nm = type_name ();
   error ("%s type invalid as index value", nm.c_str ());
   return idx_vector ();
 }
 
 octave_value
 octave_base_value::subsasgn (const std::string type,
-			     const SLList<octave_value_list>& idx,
+			     const std::list<octave_value_list>& idx,
 			     const octave_value& rhs)
 {
   octave_value retval;
 
   if (is_defined ())
     {
       if (is_numeric_type ())
 	{
diff --git a/src/ov-base.h b/src/ov-base.h
--- a/src/ov-base.h
+++ b/src/ov-base.h
@@ -67,34 +67,34 @@ public:
 
   type_conv_fcn numeric_conversion_function (void) const
     { return static_cast<type_conv_fcn> (0); }
 
   octave_value *try_narrowing_conversion (void)
     { return static_cast<octave_value *> (0); }
 
   octave_value subsref (const std::string type,
-			const SLList<octave_value_list>& idx);
+			const std::list<octave_value_list>& idx);
 
   octave_value_list subsref (const std::string type,
-			     const SLList<octave_value_list>& idx,
+			     const std::list<octave_value_list>& idx,
 			     int nargout);
 
   octave_value do_index_op (const octave_value_list& idx, int resize_ok);
 
   octave_value do_index_op (const octave_value_list& idx)
     { return do_index_op (idx, 0); }
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& idx);
 
   idx_vector index_vector (void) const;
 
   octave_value subsasgn (const std::string type,
-			 const SLList<octave_value_list>& idx,
+			 const std::list<octave_value_list>& idx,
 			 const octave_value& rhs);
 
   int rows (void) const { return -1; }
 
   int columns (void) const { return -1; }
 
   int length (void) const { return -1; }
 
diff --git a/src/ov-builtin.cc b/src/ov-builtin.cc
--- a/src/ov-builtin.cc
+++ b/src/ov-builtin.cc
@@ -48,17 +48,17 @@ any_arg_is_magic_colon (const octave_val
     if (args(i).is_magic_colon ())
       return true;
 
   return false;
 }
 
 octave_value_list
 octave_builtin::subsref (const std::string type,
-			 const SLList<octave_value_list>& idx,
+			 const std::list<octave_value_list>& idx,
 			 int nargout)
 {
   octave_value_list retval;
 
   switch (type[0])
     {
     case '(':
       retval = do_multi_index_op (nargout, idx.front ());
@@ -81,17 +81,17 @@ octave_builtin::subsref (const std::stri
   // octave_user_function::subsref.
   //
   // XXX FIXME XXX -- Note that if a function call returns multiple
   // values, and there is further indexing to perform, then we are
   // ignoring all but the first value.  Is this really what we want to
   // do?  If it is not, then what should happen for stat("file").size,
   // for exmaple?
 
-  if (idx.length () > 1)
+  if (idx.size () > 1)
     retval = retval(0).next_subsref (type, idx);
 
   return retval;
 }
 
 octave_value_list
 octave_builtin::do_multi_index_op (int nargout, const octave_value_list& args)
 {
diff --git a/src/ov-builtin.h b/src/ov-builtin.h
--- a/src/ov-builtin.h
+++ b/src/ov-builtin.h
@@ -46,17 +46,17 @@ public:
 
   octave_builtin (fcn ff, const std::string& nm = std::string (),
 		  const std::string& ds = std::string ())
     : octave_function (nm, ds), f (ff) { }
 
   ~octave_builtin (void) { }
 
   octave_value_list subsref (const std::string type,
-			     const SLList<octave_value_list>& idx,
+			     const std::list<octave_value_list>& idx,
 			     int nargout);
 
   octave_function *function_value (bool) { return this; }
 
   bool is_builtin_function (void) const { return true; }
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args);
diff --git a/src/ov-cell.cc b/src/ov-cell.cc
--- a/src/ov-cell.cc
+++ b/src/ov-cell.cc
@@ -48,17 +48,17 @@ Software Foundation, 59 Temple Place - S
 template class octave_base_matrix<Cell>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_cell);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_cell, "cell");
 
 octave_value
 octave_cell::subsref (const std::string type,
-		      const SLList<octave_value_list>& idx)
+		      const std::list<octave_value_list>& idx)
 {
   octave_value retval;
 
   switch (type[0])
     {
     case '(':
       retval = do_index_op (idx.front ());
       break;
@@ -99,17 +99,17 @@ octave_cell::subsref (const std::string 
       panic_impossible ();
     }
 
   return retval.next_subsref (type, idx);
 }
 
 octave_value
 octave_cell::subsasgn (const std::string type,
-		       const SLList<octave_value_list>& idx,
+		       const std::list<octave_value_list>& idx,
 		       const octave_value& rhs)
 {
   octave_value retval;
 
   int n = type.length ();
 
   octave_value t_rhs = rhs;
 
@@ -121,19 +121,19 @@ octave_cell::subsasgn (const std::string
 	  {
 	    octave_value tmp = do_index_op (idx.front (), true);
 
 	    if (! tmp.is_defined ())
 	      tmp = octave_value::empty_conv (type.substr (1), rhs);
 
 	    if (! error_state)
 	      {
-		SLList<octave_value_list> next_idx (idx);
+		std::list<octave_value_list> next_idx (idx);
 
-		next_idx.remove_front ();
+		next_idx.erase (next_idx.begin ());
 
 		t_rhs = tmp.subsasgn (type.substr (1), next_idx, rhs);
 	      }
 	  }
 	  break;
 
 	case '{':
 	  {
@@ -143,19 +143,19 @@ octave_cell::subsasgn (const std::string
 	      tmp = octave_value::empty_conv (type.substr (1), rhs);
 
 	    Cell tcell = tmp.cell_value ();
 
 	    if (! error_state && tcell.length () == 1)
 	      {
 		tmp = tcell(0,0);
 
-		SLList<octave_value_list> next_idx (idx);
+		std::list<octave_value_list> next_idx (idx);
 
-		next_idx.remove_front ();
+		next_idx.erase (next_idx.begin ());
 
 		t_rhs = tmp.subsasgn (type.substr (1), next_idx, rhs);
 	      }
 	  }
 	  break;
 
 	case '.':
 	  {
diff --git a/src/ov-cell.h b/src/ov-cell.h
--- a/src/ov-cell.h
+++ b/src/ov-cell.h
@@ -69,20 +69,20 @@ public:
   octave_value *clone (void) const { return new octave_cell (*this); }
   octave_value *empty_clone (void) const { return new octave_cell (); }
 
 #if 0
   octave_value *try_narrowing_conversion (void);
 #endif
 
   octave_value subsref (const std::string type,
-			const SLList<octave_value_list>& idx);
+			const std::list<octave_value_list>& idx);
 
   octave_value subsasgn (const std::string type,
-			 const SLList<octave_value_list>& idx,
+			 const std::list<octave_value_list>& idx,
 			 const octave_value& rhs);
 
   bool is_defined (void) const { return true; }
 
   bool is_cell (void) const { return true; }
 
   Cell cell_value (void) const { return matrix; }
 
diff --git a/src/ov-cs-list.cc b/src/ov-cs-list.cc
--- a/src/ov-cs-list.cc
+++ b/src/ov-cs-list.cc
@@ -41,17 +41,17 @@ Software Foundation, 59 Temple Place - S
 DEFINE_OCTAVE_ALLOCATOR (octave_cs_list);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_cs_list, "cs-list");
 
 #if 0
 
 octave_value
 octave_list::subsref (const std::string type,
-		      const SLList<octave_value_list>& idx)
+		      const std::list<octave_value_list>& idx)
 {
   octave_value retval;
 
   switch (type[0])
     {
     case '(':
       {
 	octave_value_list tmp_idx = idx.front ();
@@ -113,17 +113,17 @@ octave_list::do_index_op (const octave_v
   else
     error ("lists may only be indexed by a single scalar");
 
   return retval;
 }
 
 octave_value
 octave_list::subsasgn (const std::string type,
-		       const SLList<octave_value_list>& idx,
+		       const std::list<octave_value_list>& idx,
 		       const octave_value& rhs)
 {
   octave_value retval;
 
   int n = type.length ();
 
   octave_value t_rhs = rhs;
 
@@ -135,19 +135,19 @@ octave_list::subsasgn (const std::string
 	  {
 	    octave_value tmp = do_index_op (idx.front (), true);
 
 	    if (! tmp.is_defined ())
 	      tmp = octave_value::empty_conv (type.substr (1), rhs);
 
 	    if (! error_state)
 	      {
-		SLList<octave_value_list> next_idx (idx);
+		std::list<octave_value_list> next_idx (idx);
 
-		next_idx.remove_front ();
+		next_idx.erase (next_idx.begin ());
 
 		t_rhs = tmp.subsasgn (type.substr (1), next_idx, rhs);
 	      }
 	  }
 	  break;
 
 	case '{':
 	case '.':
diff --git a/src/ov-cs-list.h b/src/ov-cs-list.h
--- a/src/ov-cs-list.h
+++ b/src/ov-cs-list.h
@@ -61,22 +61,22 @@ public:
 
   ~octave_cs_list (void) { }
 
   octave_value *clone (void) const { return new octave_cs_list (*this); }
   octave_value *empty_clone (void) const { return new octave_cs_list (); }
 
 #if 0
   octave_value subsref (const std::string type,
-			const SLList<octave_value_list>& idx);
+			const std::list<octave_value_list>& idx);
 
   octave_value do_index_op (const octave_value_list& idx, int resize_ok);
 
   octave_value subsasgn (const std::string type,
-			 const SLList<octave_value_list>& idx,
+			 const std::list<octave_value_list>& idx,
 			 const octave_value& rhs);
 
   void assign (const octave_value_list& idx, const octave_value& rhs);
 
   int length (void) const { return lst.length (); }
 
   bool is_defined (void) const { return true; }
 
diff --git a/src/ov-list.cc b/src/ov-list.cc
--- a/src/ov-list.cc
+++ b/src/ov-list.cc
@@ -39,17 +39,17 @@ Software Foundation, 59 Temple Place - S
 #include "unwind-prot.h"
 
 DEFINE_OCTAVE_ALLOCATOR (octave_list);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_list, "list");
 
 octave_value
 octave_list::subsref (const std::string type,
-		      const SLList<octave_value_list>& idx)
+		      const std::list<octave_value_list>& idx)
 {
   octave_value retval;
 
   switch (type[0])
     {
     case '(':
       {
 	octave_value_list tmp_idx = idx.front ();
@@ -111,17 +111,17 @@ octave_list::do_index_op (const octave_v
   else
     error ("lists may only be indexed by a single scalar");
 
   return retval;
 }
 
 octave_value
 octave_list::subsasgn (const std::string type,
-		       const SLList<octave_value_list>& idx,
+		       const std::list<octave_value_list>& idx,
 		       const octave_value& rhs)
 {
   octave_value retval;
 
   int n = type.length ();
 
   octave_value t_rhs = rhs;
 
@@ -133,19 +133,19 @@ octave_list::subsasgn (const std::string
 	  {
 	    octave_value tmp = do_index_op (idx.front (), true);
 
 	    if (! tmp.is_defined ())
 	      tmp = octave_value::empty_conv (type.substr (1), rhs);
 
 	    if (! error_state)
 	      {
-		SLList<octave_value_list> next_idx (idx);
+		std::list<octave_value_list> next_idx (idx);
 
-		next_idx.remove_front ();
+		next_idx.erase (next_idx.begin ());
 
 		t_rhs = tmp.subsasgn (type.substr (1), next_idx, rhs);
 	      }
 	  }
 	  break;
 
 	case '{':
 	case '.':
diff --git a/src/ov-list.h b/src/ov-list.h
--- a/src/ov-list.h
+++ b/src/ov-list.h
@@ -60,22 +60,22 @@ public:
     : octave_base_value (), lst (l.lst) { }
 
   ~octave_list (void) { }
 
   octave_value *clone (void) const { return new octave_list (*this); }
   octave_value *empty_clone (void) const { return new octave_list (); }
 
   octave_value subsref (const std::string type,
-			const SLList<octave_value_list>& idx);
+			const std::list<octave_value_list>& idx);
 
   octave_value do_index_op (const octave_value_list& idx, int resize_ok);
 
   octave_value subsasgn (const std::string type,
-			 const SLList<octave_value_list>& idx,
+			 const std::list<octave_value_list>& idx,
 			 const octave_value& rhs);
 
   void assign (const octave_value_list& idx, const octave_value& rhs);
 
   int length (void) const { return lst.length (); }
 
   bool is_defined (void) const { return true; }
 
diff --git a/src/ov-mapper.cc b/src/ov-mapper.cc
--- a/src/ov-mapper.cc
+++ b/src/ov-mapper.cc
@@ -240,17 +240,17 @@ octave_mapper::apply (const octave_value
   else
     gripe_wrong_type_arg ("mapper", arg);
 
   return retval;
 }
 
 octave_value_list
 octave_mapper::subsref (const std::string type,
-			const SLList<octave_value_list>& idx,
+			const std::list<octave_value_list>& idx,
 			int nargout)
 {
   octave_value_list retval;
 
   switch (type[0])
     {
     case '(':
       retval = do_multi_index_op (nargout, idx.front ());
diff --git a/src/ov-mapper.h b/src/ov-mapper.h
--- a/src/ov-mapper.h
+++ b/src/ov-mapper.h
@@ -62,17 +62,17 @@ public:
       lower_limit (ll), upper_limit (ul), ch_map_flag (cmf),
       can_ret_cmplx_for_real (crcfr) { }
 
   ~octave_mapper (void) { }
 
   octave_function *function_value (bool) { return this; }
 
   octave_value_list subsref (const std::string type,
-			     const SLList<octave_value_list>& idx,
+			     const std::list<octave_value_list>& idx,
 			     int nargout);
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args);
 
 private:
 
   octave_mapper (void);
diff --git a/src/ov-range.cc b/src/ov-range.cc
--- a/src/ov-range.cc
+++ b/src/ov-range.cc
@@ -78,17 +78,17 @@ octave_range::try_narrowing_conversion (
       break;
     }
 
   return retval;
 }
 
 octave_value
 octave_range::subsref (const std::string type,
-		       const SLList<octave_value_list>& idx)
+		       const std::list<octave_value_list>& idx)
 {
   octave_value retval;
 
   switch (type[0])
     {
     case '(':
       retval = do_index_op (idx.front ());
       break;
diff --git a/src/ov-range.h b/src/ov-range.h
--- a/src/ov-range.h
+++ b/src/ov-range.h
@@ -35,17 +35,16 @@ Software Foundation, 59 Temple Place - S
 #include "Range.h"
 
 #include "lo-mappers.h"
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "oct-alloc.h"
 #include "str-vec.h"
 
-#include "SLList.h"
 #include "error.h"
 #include "ov-base.h"
 #include "ov-typeinfo.h"
 
 class Octave_map;
 class octave_value_list;
 
 class tree_walker;
@@ -82,17 +81,17 @@ public:
   octave_value *clone (void) const { return new octave_range (*this); }
   octave_value *empty_clone (void) const { return new octave_range (); }
 
   type_conv_fcn numeric_conversion_function (void) const;
 
   octave_value *try_narrowing_conversion (void);
 
   octave_value subsref (const std::string type,
-			const SLList<octave_value_list>& idx);
+			const std::list<octave_value_list>& idx);
 
   octave_value do_index_op (const octave_value_list& idx, int resize_ok);
 
   octave_value do_index_op (const octave_value_list& idx)
     { return do_index_op (idx, 0); }
 
   idx_vector index_vector (void) const { return idx_vector (range); }
 
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -46,19 +46,19 @@ octave_value_list
 octave_struct::dotref (const octave_value_list& idx)
 {
   octave_value_list retval;
 
   assert (idx.length () == 1);
 
   std::string nm = idx(0).string_value ();
 
-  Pix p = map.seek (nm);
+  Octave_map::const_iterator p = map.seek (nm);
 
-  if (p)
+  if (p != map.end ())
     retval = map.contents (p);
   else
     error ("structure has no member `%s'", nm.c_str ());
 
   return retval;
 }
 
 static void
@@ -82,31 +82,30 @@ gripe_invalid_index_type (const std::str
 static void
 gripe_failed_assignment (void)
 {
   error ("assignment to structure element failed");
 }
 
 octave_value
 octave_struct::subsref (const std::string type,
-			const SLList<octave_value_list>& idx)
+			const std::list<octave_value_list>& idx)
 {
   octave_value retval;
 
   int skip = 1;
 
   switch (type[0])
     {
     case '(':
       {
 	if (type.length () > 1 && type[1] == '.')
 	  {
-	    Pix p = idx.first ();
-	    idx.next (p);
-	    octave_value_list key_idx = idx(p);
+	    std::list<octave_value_list>::const_iterator p = idx.begin ();
+	    octave_value_list key_idx = *++p;
 
 	    octave_value_list tmp = dotref (key_idx);
 
 	    if (! error_state)
 	      {
 		octave_value_list t_idx = idx.front ();
 
 		if (t_idx.length () == 1)
@@ -178,40 +177,39 @@ octave_struct::numeric_conv (const octav
   else
     gripe_invalid_index_for_assignment ();
 
   return retval;
 }
 
 octave_value
 octave_struct::subsasgn (const std::string type,
-			 const SLList<octave_value_list>& idx,
+			 const std::list<octave_value_list>& idx,
 			 const octave_value& rhs)
 {
   octave_value retval;
 
   int n = type.length ();
 
   octave_value t_rhs = rhs;
 
   if (n > 1 && ! (type.length () == 2 && type[0] == '(' && type[1] == '.'))
     {
       switch (type[0])
 	{
 	case '(':
 	  {
 	    if (type.length () > 1 && type[1] == '.')
 	      {
-		Pix p = idx.first ();
-		octave_value_list t_idx = idx(p);
+		std::list<octave_value_list>::const_iterator p = idx.begin ();
+		octave_value_list t_idx = *p;
 
 		if (t_idx.length () == 1)
 		  {
-		    idx.next (p);
-		    octave_value_list key_idx = idx(p);
+		    octave_value_list key_idx = *++p;
 
 		    assert (key_idx.length () == 1);
 
 		    std::string key = key_idx(0).string_value ();
 
 		    octave_value u;
 
 		    if (! map.contains (key))
@@ -226,23 +224,23 @@ octave_struct::subsasgn (const std::stri
 
 			octave_value_list map_elt = map_val.index (i, true);
 
 			u = numeric_conv (map_elt, type.substr (2));
 		      }
 
 		    if (! error_state)
 		      {
-			SLList<octave_value_list> next_idx (idx);
+			std::list<octave_value_list> next_idx (idx);
 
 			// We handled two index elements, so subsasgn to
 			// needs to skip both of them.
 
-			next_idx.remove_front ();
-			next_idx.remove_front ();
+			next_idx.erase (next_idx.begin ());
+			next_idx.erase (next_idx.begin ());
 
 			u.make_unique ();
 
 			t_rhs = u.subsasgn (type.substr (2), next_idx, rhs);
 		      }
 		  }
 		else
 		  gripe_invalid_index_for_assignment ();
@@ -268,19 +266,19 @@ octave_struct::subsasgn (const std::stri
 	      {
 		octave_value_list map_val = map[key];
 
 		u = numeric_conv (map_val, type.substr (1));
 	      }
 
 	    if (! error_state)
 	      {
-		SLList<octave_value_list> next_idx (idx);
+		std::list<octave_value_list> next_idx (idx);
 
-		next_idx.remove_front ();
+		next_idx.erase (next_idx.begin ());
 
 		u.make_unique ();
 
 		t_rhs = u.subsasgn (type.substr (1), next_idx, rhs);
 	      }
 	  }
 	  break;
 
@@ -296,19 +294,18 @@ octave_struct::subsasgn (const std::stri
   if (! error_state)
     {
       switch (type[0])
 	{
 	case '(':
 	  {
 	    if (n > 1 && type[1] == '.')
 	      {
-		Pix p = idx.first ();
-		idx.next (p);
-		octave_value_list key_idx = idx(p);
+		std::list<octave_value_list>::const_iterator p = idx.begin ();
+		octave_value_list key_idx = *++p;
 
 		assert (key_idx.length () == 1);
 
 		std::string key = key_idx(0).string_value ();
 
 		if (! error_state)
 		  {
 		    octave_value_list t_idx = idx.front ();
@@ -413,17 +410,17 @@ octave_struct::print_raw (std::ostream& 
       indent (os);
       os << "{";
       newline (os);
 
       increment_indent_level ();
 
       int n = map.array_length ();
 
-      for (Pix p = map.first (); p; map.next (p))
+      for (Octave_map::const_iterator p = map.begin (); p != map.end (); p++)
 	{
 	  std::string key = map.key (p);
 	  octave_value_list val = map.contents (p);
 
 	  octave_value tmp = (n == 1) ? val(0) : octave_value (val);
 
 	  if (print_keys_only)
 	    {
diff --git a/src/ov-struct.h b/src/ov-struct.h
--- a/src/ov-struct.h
+++ b/src/ov-struct.h
@@ -65,23 +65,23 @@ public:
   ~octave_struct (void) { }
 
   octave_value *clone (void) const { return new octave_struct (*this); }
   octave_value *empty_clone (void) const { return new octave_struct (); }
 
   octave_value_list dotref (const octave_value_list& idx);
 
   octave_value subsref (const std::string type,
-			const SLList<octave_value_list>& idx);
+			const std::list<octave_value_list>& idx);
 
   static octave_value numeric_conv (const octave_value_list& val,
 				    const std::string& type);
 
   octave_value subsasgn (const std::string type,
-			 const SLList<octave_value_list>& idx,
+			 const std::list<octave_value_list>& idx,
 			 const octave_value& rhs);
 
   int rows (void) const { return map.rows (); }
 
   int columns (void) const { return map.columns (); }
 
   int length (void) const
   {
diff --git a/src/ov-usr-fcn.cc b/src/ov-usr-fcn.cc
--- a/src/ov-usr-fcn.cc
+++ b/src/ov-usr-fcn.cc
@@ -279,17 +279,17 @@ clear_symbol_table (void *table)
 }
 
 static void
 clear_param_list (void *lst)
 {
   tree_parameter_list *tmp = static_cast<tree_parameter_list *> (lst);
 
   if (tmp)
-    tmp->clear ();
+    tmp->undefine ();
 }
 
 static void
 restore_args_passed (void *fcn)
 {
   octave_user_function *tmp = static_cast<octave_user_function *> (fcn);
 
   if (tmp)
@@ -300,17 +300,17 @@ static void
 unprotect_function (void *sr_arg)
 {
   symbol_record *sr = static_cast<symbol_record *> (sr_arg);
   sr->unprotect ();
 }
 
 octave_value_list
 octave_user_function::subsref (const std::string type,
-			       const SLList<octave_value_list>& idx,
+			       const std::list<octave_value_list>& idx,
 			       int nargout)
 {
   octave_value_list retval;
 
   switch (type[0])
     {
     case '(':
       retval = do_multi_index_op (nargout, idx.front ());
@@ -327,17 +327,17 @@ octave_user_function::subsref (const std
     default:
       panic_impossible ();
     }
 
   // XXX FIXME XXX -- perhaps there should be an
   // octave_value_list::next_subsref member function?  See also
   // octave_builtin::subsref.
 
-  if (idx.length () > 1)
+  if (idx.size () > 1)
     retval = retval(0).next_subsref (type, idx);
 
   return retval;
 }
 
 octave_value_list
 octave_user_function::do_multi_index_op (int nargout,
 					 const octave_value_list& args)
diff --git a/src/ov-usr-fcn.h b/src/ov-usr-fcn.h
--- a/src/ov-usr-fcn.h
+++ b/src/ov-usr-fcn.h
@@ -135,17 +135,17 @@ public:
       else
 	{
 	  args_passed = saved_args.top ();
 	  saved_args.pop ();
 	}
     }
 
   octave_value_list subsref (const std::string type,
-			     const SLList<octave_value_list>& idx,
+			     const std::list<octave_value_list>& idx,
 			     int nargout);
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args);
 
   void traceback_error (void);
 
   tree_parameter_list *parameter_list (void) { return param_list; }
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -563,36 +563,36 @@ octave_value::maybe_mutate (void)
 
       rep = tmp;
       rep->count = 1;
     }    
 }
 
 octave_value_list
 octave_value::subsref (const std::string type,
-		       const SLList<octave_value_list>& idx, int nargout)
+		       const std::list<octave_value_list>& idx, int nargout)
 {
   if (is_constant ())
     return rep->subsref (type, idx);
   else
     return rep->subsref (type, idx, nargout);
 }
 
 octave_value
 octave_value::next_subsref (const std::string type,
-			    const SLList<octave_value_list>& idx,
+			    const std::list<octave_value_list>& idx,
 			    int skip) 
 {
   assert (skip > 0);
 
-  if (idx.length () > skip)
+  if (idx.size () > skip)
     {
-      SLList<octave_value_list> new_idx (idx);
+      std::list<octave_value_list> new_idx (idx);
       for (int i = 0; i < skip; i++)
-	new_idx.remove_front ();
+	new_idx.erase (new_idx.begin ());
       return subsref (type.substr (skip), new_idx);
     }
   else
     return *this;
 }
 
 octave_value_list
 octave_value::do_multi_index_op (int nargout, const octave_value_list& idx)
@@ -624,25 +624,25 @@ gripe_assign_failed_or_no_method (const 
 				  const std::string& tn2)
 {
   error ("assignment failed, or no method for `%s %s %s'",
 	 tn1.c_str (), on.c_str (), tn2.c_str ());
 }
 
 octave_value
 octave_value::subsasgn (const std::string type,
-			const SLList<octave_value_list>& idx,
+			const std::list<octave_value_list>& idx,
 			const octave_value& rhs)
 {
   return rep->subsasgn (type, idx, rhs);
 }
 
 octave_value
 octave_value::assign (assign_op op, const std::string type,
-		      const SLList<octave_value_list>& idx,
+		      const std::list<octave_value_list>& idx,
 		      const octave_value& rhs)
 {
   octave_value retval;
 
   make_unique ();
 
   octave_value t_rhs = rhs;
 
@@ -1075,17 +1075,17 @@ gripe_assign_conversion_failed (const st
 				const std::string& tn2)
 {
   error ("type conversion for assignment of `%s' to indexed `%s' failed",
 	 tn2.c_str (), tn1.c_str ());
 }
 
 octave_value
 octave_value::numeric_assign (const std::string type,
-			      const SLList<octave_value_list>& idx,
+			      const std::list<octave_value_list>& idx,
 			      const octave_value& rhs)
 {
   octave_value retval;
 
   int t_lhs = type_id ();
   int t_rhs = rhs.type_id ();
 
   assign_op_fcn f
@@ -1428,17 +1428,17 @@ gripe_unary_op_failed_or_no_method (cons
 void
 octave_value::do_non_const_unary_op (unary_op op, const octave_value_list& idx)
 {
   abort ();
 }
 
 octave_value
 octave_value::do_non_const_unary_op (unary_op op, const std::string type,
-				     const SLList<octave_value_list>& idx)
+				     const std::list<octave_value_list>& idx)
 {
   octave_value retval;
 
   if (idx.empty ())
     {
       do_non_const_unary_op (op);
 
       retval = *this;
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -26,25 +26,24 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
 #pragma interface
 #endif
 
 #include <cstdlib>
 
 #include <iostream>
 #include <string>
+#include <list>
 
 #include "Range.h"
 #include "idx-vector.h"
 #include "mx-base.h"
 #include "oct-alloc.h"
 #include "str-vec.h"
 
-#include "SLList.h"
-
 class Cell;
 class Octave_map;
 class octave_stream;
 class octave_function;
 class octave_value_list;
 class octave_lvalue;
 
 // Constants.
@@ -239,52 +238,52 @@ public:
     { return rep->numeric_conversion_function (); }
 
   void maybe_mutate (void);
 
   virtual octave_value *try_narrowing_conversion (void)
     { return rep->try_narrowing_conversion (); }
 
   virtual octave_value subsref (const std::string type,
-				const SLList<octave_value_list>& idx)
+				const std::list<octave_value_list>& idx)
     { return rep->subsref (type, idx); }
 
   octave_value subsref (const std::string type, const octave_value_list& idx)
     {
-      SLList<octave_value_list> i;
+      std::list<octave_value_list> i;
 
-      i.append (idx);
+      i.push_back (idx);
 
       return rep->subsref (type, i);
     }
 
   virtual octave_value_list subsref (const std::string type,
-				     const SLList<octave_value_list>& idx,
+				     const std::list<octave_value_list>& idx,
     				     int nargout);
 
   octave_value next_subsref (const std::string type, const
-			     SLList<octave_value_list>& idx,
+			     std::list<octave_value_list>& idx,
 			     int skip = 1);
 
   virtual octave_value do_index_op (const octave_value_list& idx,
 				    int resize_ok)
     { return rep->do_index_op (idx, resize_ok); }
 
   octave_value do_index_op (const octave_value_list& idx)
     { return do_index_op (idx, 0); }
 
   virtual octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& idx);
 
   virtual octave_value subsasgn (const std::string type,
-				 const SLList<octave_value_list>& idx,
+				 const std::list<octave_value_list>& idx,
 				 const octave_value& rhs);
 
   octave_value assign (assign_op op, const std::string type,
-		       const SLList<octave_value_list>& idx,
+		       const std::list<octave_value_list>& idx,
 		       const octave_value& rhs);
 
   const octave_value& assign (assign_op, const octave_value& rhs);
 
   virtual idx_vector index_vector (void) const
     { return rep->index_vector (); }
 
   // Size.
@@ -524,17 +523,17 @@ public:
   friend octave_value do_unary_op (unary_op op,
 				   const octave_value& a);
 
   const octave_value& do_non_const_unary_op (unary_op op);
 
   void do_non_const_unary_op (unary_op op, const octave_value_list& idx);
 
   octave_value do_non_const_unary_op (unary_op op, const std::string type,
-				      const SLList<octave_value_list>& idx);
+				      const std::list<octave_value_list>& idx);
 
   friend octave_value do_binary_op (binary_op op,
 				    const octave_value& a,
 				    const octave_value& b);
 
   const octave_value& get_rep (void) const { return *rep; }
 
   virtual void print_info (std::ostream& os,
@@ -542,17 +541,17 @@ public:
 
 protected:
 
   octave_value (const octave_xvalue&) : rep (0) { }
 
   // This should only be called for derived types.
 
   octave_value numeric_assign (const std::string type,
-			       const SLList<octave_value_list>& idx,
+			       const std::list<octave_value_list>& idx,
 			       const octave_value& rhs);
 
   void reset_indent_level (void) const
     { curr_print_indent_level = 0; }
 
   void increment_indent_level (void) const
     { curr_print_indent_level += 2; }
 
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -2781,34 +2781,34 @@ finish_cell (tree_cell *c)
   return c;
 }
 
 static void
 maybe_warn_missing_semi (tree_statement_list *t)
 {
   if (lexer_flags.defining_func && Vwarn_missing_semicolon)
     {
-      tree_statement *tmp = t->rear();
+      tree_statement *tmp = t->back();
 
       if (tmp->is_expression ())
 	warning ("missing semicolon near line %d, column %d in file `%s'",
 		 tmp->line (), tmp->column (),
 		 curr_fcn_file_full_name.c_str ());
     }
 }
 
 static void
 set_stmt_print_flag (tree_statement_list *list, char sep,
 		     bool warn_missing_semi)
 {
   switch (sep)
     {
     case ';':
       {
-	tree_statement *tmp = list->rear ();
+	tree_statement *tmp = list->back ();
 	tmp->set_print_flag (0);
       }
       break;
 
     case 0:
     case ',':
     case '\n':
       if (warn_missing_semi)
diff --git a/src/pt-arg-list.cc b/src/pt-arg-list.cc
--- a/src/pt-arg-list.cc
+++ b/src/pt-arg-list.cc
@@ -42,48 +42,49 @@ Software Foundation, 59 Temple Place - S
 #include "pt-pr-code.h"
 #include "pt-walk.h"
 #include "toplev.h"
 
 // Argument lists.
 
 tree_argument_list::~tree_argument_list (void)
 {
-  while (! lst.empty ())
+  while (! empty ())
     {
-      tree_expression *t = lst.remove_front ();
-      delete t;
+      iterator p = begin ();
+      delete *p;
+      erase (p);
     }
 }
 
 int
 tree_argument_list::nargout_count (void) const
 {
   int retval = 0;
 
-  for (Pix p = lst.first (); p != 0; lst.next (p))
+  for (const_iterator p = begin (); p != end (); p++)
     {
-      tree_expression *elt = lst (p);
+      tree_expression *elt = *p;
 
       // XXX FIXME XXX -- need to be able to determine whether elt is
       // an expression that could evaluate to a cs-list object, and if
       // so, how many elements are in that list.  Ugly!
 
       retval++;
     }
 
   return retval;
 }
 
 bool
 tree_argument_list::all_elements_are_constant (void) const
 {
-  for (Pix p = lst.first (); p != 0; lst.next (p))
+  for (const_iterator p = begin (); p != end (); p++)
     {
-      tree_expression *elt = lst (p);
+      tree_expression *elt = *p;
 
       if (! elt->is_constant ())
 	return false;
     }
 
   return true;
 }
 
@@ -95,21 +96,21 @@ tree_argument_list::convert_to_const_vec
   // XXX FIXME XXX -- would be nice to know in advance how largs args
   // needs to be even when we have a list containing an all_va_args
   // token.
 
   octave_value_list args;
   int args_len = len;
   args.resize (args_len);
 
-  Pix p = lst.first ();
+  iterator p = begin ();
   int j = 0;
   for (int k = 0; k < len; k++)
     {
-      tree_expression *elt = lst (p);
+      tree_expression *elt = *p++;
 
       if (elt)
 	{
 	  octave_value tmp = elt->rvalue ();
 
 	  if (error_state)
 	    {
 	      ::error ("evaluating argument list element number %d", k+1);
@@ -144,17 +145,16 @@ tree_argument_list::convert_to_const_vec
 		  args_len += n - 1;
 		  args.resize (args_len);
 		  for (int i = 0; i < n; i++)
 		    args(j++) = tl(i);
 		}
 	      else
 		args(j++) = tmp;
 	    }
-	  next (p);
 	}
       else
 	{
 	  args(j++) = octave_value ();
 	  break;
 	}
     }
 
@@ -167,19 +167,19 @@ string_vector
 tree_argument_list::get_arg_names (void) const
 {
   int len = length ();
 
   string_vector retval (len);
 
   int k = 0;
 
-  for (Pix p = lst.first (); p; lst.next (p))
+  for (const_iterator p = begin (); p != end (); p++)
     {
-      tree_expression *elt = lst (p);
+      tree_expression *elt = *p;
 
       retval(k++) = elt->str_print_code ();
     }
 
   return retval;
 }
 
 void
diff --git a/src/pt-arg-list.h b/src/pt-arg-list.h
--- a/src/pt-arg-list.h
+++ b/src/pt-arg-list.h
@@ -22,74 +22,60 @@ Software Foundation, 59 Temple Place - S
 
 #if !defined (octave_tree_arg_list_h)
 #define octave_tree_arg_list_h 1
 
 #if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
 #pragma interface
 #endif
 
-#include <SLList.h>
-
 class octave_value_list;
 
 class tree_expression;
 
 class tree_walker;
 
 #include "str-vec.h"
 
+#include "base-list.h"
+
 // Argument lists.  Used to hold the list of expressions that are the
 // arguments in a function call or index expression.
 
 class
-tree_argument_list
+tree_argument_list : public octave_base_list<tree_expression *>
 {
 public:
 
-  tree_argument_list (void)
-    : lst () { }
+  tree_argument_list (void) { }
 
-  tree_argument_list (tree_expression *t)
-    : lst () { lst.append (t); }
+  tree_argument_list (tree_expression *t) { append (t); }
 
   ~tree_argument_list (void);
 
-  int length (void) const { return lst.length (); }
-
-  void append (tree_expression *&s) { lst.append (s); }
-  void append (tree_expression * const &s) { lst.append (s); }
-
-  tree_expression *&operator () (Pix p) { return lst (p); }
-
-  tree_expression * const &operator () (Pix p) const { return lst (p); }
-
-  Pix first (void) const { return lst.first (); }
-
-  void next (Pix& p) const { return lst.next (p); }
-
-  int remove_front (tree_expression *x) { return lst.remove_front (x); }
-
-  tree_expression *remove_front (void) { return lst.remove_front (); }
+  tree_expression *remove_front (void)
+    {
+      iterator p = begin ();
+      tree_expression *retval = *p;
+      erase (p);
+      return retval;
+    }
 
   int nargout_count (void) const;
 
   bool all_elements_are_constant (void) const;
 
   octave_value_list convert_to_const_vector (void);
 
   string_vector get_arg_names (void) const;
 
   void accept (tree_walker& tw);
 
 private:
 
-  // The list of argument list elements.
-  SLList<tree_expression *> lst;
-
   // No copying!
 
   tree_argument_list (const tree_argument_list&);
 
   tree_argument_list& operator = (const tree_argument_list&);
 };
 
 #endif
diff --git a/src/pt-assign.cc b/src/pt-assign.cc
--- a/src/pt-assign.cc
+++ b/src/pt-assign.cc
@@ -225,19 +225,21 @@ tree_multi_assignment::rvalue (int)
       else
 	{
 	  int k = 0;
 
 	  int n = rhs_val.length ();
 
 	  retval.resize (n, octave_value ());
 
-	  for (Pix p = lhs->first (); p != 0; lhs->next (p))
+	  for (tree_argument_list::iterator p = lhs->begin ();
+	       p != lhs->end ();
+	       p++)
 	    {
-	      tree_expression *lhs_elt = lhs->operator () (p);
+	      tree_expression *lhs_elt = *p;
 
 	      if (lhs_elt)
 		{
 		  octave_lvalue ult = lhs_elt->lvalue ();
 
 		  if (error_state)
 		    eval_error ();
 		  else if (k < n)
diff --git a/src/pt-bp.cc b/src/pt-bp.cc
--- a/src/pt-bp.cc
+++ b/src/pt-bp.cc
@@ -109,19 +109,19 @@ tree_breakpoint::visit_do_until_command 
 }
 
 void 
 tree_breakpoint::visit_argument_list (tree_argument_list& lst)
 {
   if (found)
     return;
 
-  for (Pix p = lst.first (); p != 0; lst.next (p))
+  for (tree_argument_list::iterator p = lst.begin (); p != lst.end (); p++)
     {
-      tree_expression *elt = lst(p);
+      tree_expression *elt = *p;
 
       if (elt)
 	elt->accept (*this);
     }
 }
 
 void 
 tree_breakpoint::visit_binary_expression (tree_binary_expression& expr)
@@ -215,19 +215,19 @@ tree_breakpoint::visit_decl_elt (tree_de
 }
 
 void 
 tree_breakpoint::visit_decl_init_list (tree_decl_init_list& lst)
 {
   if (found)
     return;
 
-  for (Pix p = lst.first (); p != 0; lst.next (p))
+  for (tree_decl_init_list::iterator p = lst.begin (); p != lst.end (); p++)
     {
-      tree_decl_elt *elt = lst(p);
+      tree_decl_elt *elt = *p;
 
       if (elt)
 	elt->accept (*this);
     }
 }
 
 void 
 tree_breakpoint::visit_simple_for_command (tree_simple_for_command& cmd)
@@ -329,19 +329,19 @@ tree_breakpoint::visit_if_command (tree_
 }
 
 void
 tree_breakpoint::visit_if_command_list (tree_if_command_list& lst)
 {
   if (found)
     return;
 
-  for (Pix p = lst.first (); p != 0; lst.next (p))
+  for (tree_if_command_list::iterator p = lst.begin (); p != lst.end (); p++)
     {
-      tree_if_clause *elt = lst(p);
+      tree_if_clause *elt = *p;
 
       if (elt)
 	elt->accept (*this);
     }
 }
 
 void 
 tree_breakpoint::visit_index_expression (tree_index_expression& cmd)
@@ -349,59 +349,60 @@ tree_breakpoint::visit_index_expression 
   if (found)
     return;
 
   tree_expression *expr = cmd.expression ();
 
   if (expr && expr->line () >= line)
     take_action (*expr);
 
-  SLList<tree_argument_list *> lst = cmd.arg_lists ();
+  std::list<tree_argument_list *> lst = cmd.arg_lists ();
+
 
   if (! lst.empty ())
     {
-      for (Pix p = lst.first (); p != 0; lst.next (p))
+      for (std::list<tree_argument_list *>::iterator p = lst.begin ();
+	   p != lst.end ();
+	   p++)
 	{
-	  tree_argument_list *elt = lst(p);
+	  tree_argument_list *elt = *p;
 
 	  elt->accept (*this);
 	}
     }
 }
 
 void 
 tree_breakpoint::visit_matrix (tree_matrix& mat)
 {
   if (found)
     return;
 
-  Pix p = mat.first ();
+  tree_matrix::iterator p = mat.begin ();
 
-  while (p)
+  while (p != mat.end ())
     {
-      tree_argument_list *elt = mat(p);
-      mat.next (p);
+      tree_argument_list *elt = *p++;
 
       if (elt)
 	elt->accept (*this);
     }
 }
 
 void 
 tree_breakpoint::visit_cell (tree_cell& cell)
 {
   if (found)
     return;
 
-  Pix p = cell.first ();
+  tree_cell::iterator p = cell.begin ();
 
-  while (p)
+  while (p != cell.end ())
     {
-      tree_argument_list *elt = cell (p);
-      cell.next (p);
+      tree_argument_list *elt = *p++;
 
       if (elt)
 	elt->accept (*this);
     }
 }
 
 void 
 tree_breakpoint::visit_multi_assignment (tree_multi_assignment& expr)
@@ -441,22 +442,21 @@ tree_breakpoint::visit_constant (tree_co
 }
 
 void 
 tree_breakpoint::visit_parameter_list (tree_parameter_list& lst)
 {
   if (found)
     return;
 
-  Pix p = lst.first ();
+  tree_parameter_list::iterator p = lst.begin ();
 
-  while (p)
+  while (p != lst.end ())
     {
-      tree_identifier *elt = lst(p);
-      lst.next (p);
+      tree_identifier *elt = *p++;
 
       if (elt)
 	elt->accept (*this);
     }
 }
 
 void 
 tree_breakpoint::visit_plot_command (tree_plot_command& cmd)
@@ -524,22 +524,21 @@ tree_breakpoint::visit_return_command (t
 }
 
 void
 tree_breakpoint::visit_return_list (tree_return_list& lst)
 {
   if (found)
     return;
 
-  Pix p = lst.first ();
+  tree_return_list::iterator p = lst.begin ();
 
-  while (p)
+  while (p != lst.end ())
     {
-      tree_index_expression *elt = lst(p);
-      lst.next (p);
+      tree_index_expression *elt = *p++;
 
       if (elt)
 	elt->accept (*this);
     }
 }
 
 void 
 tree_breakpoint::visit_simple_assignment (tree_simple_assignment& expr)
@@ -572,19 +571,19 @@ tree_breakpoint::visit_statement (tree_s
 }
 
 void
 tree_breakpoint::visit_statement_list (tree_statement_list& lst)
 {
   if (found)
     return;
 
-  for (Pix p = lst.first (); p != 0; lst.next (p))
+  for (tree_statement_list::iterator p = lst.begin (); p != lst.end (); p++)
     {
-      tree_statement *elt = lst(p);
+      tree_statement *elt = *p;
 
       if (elt)
 	elt->accept (*this);
     }
 }
 
 void 
 tree_breakpoint::visit_subplot (subplot& cmd)
@@ -631,26 +630,24 @@ tree_breakpoint::visit_switch_case (tree
 }
 
 void 
 tree_breakpoint::visit_switch_case_list (tree_switch_case_list& lst)
 {
   if (found)
     return;
 
-  Pix p = lst.first ();
+  tree_switch_case_list::iterator p = lst.begin ();
 
-  while (p)
+  while (p != lst.end ())
     {
-      tree_switch_case *elt = lst(p);
+      tree_switch_case *elt = *p++;
 
       if (elt)
 	elt->accept (*this);
-
-      lst.next (p);
     }
 }
 
 
 void 
 tree_breakpoint::visit_switch_command (tree_switch_command& cmd)
 {
   if (found)
diff --git a/src/pt-cell.cc b/src/pt-cell.cc
--- a/src/pt-cell.cc
+++ b/src/pt-cell.cc
@@ -48,36 +48,36 @@ tree_cell::rvalue (void)
 {
   octave_value retval;
 
   MAYBE_DO_BREAKPOINT;
 
   int nr = length ();
   int nc = -1;
 
-  for (Pix p = first (); p != 0; next (p))
+  for (iterator p = begin (); p != end (); p++)
     {
-      tree_argument_list *elt = this->operator () (p);
+      tree_argument_list *elt = *p;
 
       if (nc < 0)
 	nc = elt->length ();
       else if (nc != elt->length ())
 	{
 	  ::error ("number of columns must match");
 	  return retval;
 	}
     }
 
   Cell val (nr, nc);
 
   int i = 0;
 
-  for (Pix p = first (); p != 0; next (p))
+  for (iterator p = begin (); p != end (); p++)
     {
-      tree_argument_list *elt = this->operator () (p);
+      tree_argument_list *elt = *p;
 
       octave_value_list row = elt->convert_to_const_vector ();
       
       for (int j = 0; j < nc; j++)
 	val(i,j) = row(j);
 
       i++;
     }
diff --git a/src/pt-cell.h b/src/pt-cell.h
--- a/src/pt-cell.h
+++ b/src/pt-cell.h
@@ -30,18 +30,16 @@ Software Foundation, 59 Temple Place - S
 #include <iostream>
 
 class octave_value;
 class octave_value_list;
 class tree_argument_list;
 
 class tree_walker;
 
-#include <SLList.h>
-
 #include "pt-mat.h"
 
 // General cells.
 
 class
 tree_cell : public tree_matrix
 {
 public:
diff --git a/src/pt-check.cc b/src/pt-check.cc
--- a/src/pt-check.cc
+++ b/src/pt-check.cc
@@ -31,23 +31,21 @@ Software Foundation, 59 Temple Place - S
 #include "error.h"
 #include "input.h"
 #include "ov-usr-fcn.h"
 #include "pt-all.h"
 
 void
 tree_checker::visit_argument_list (tree_argument_list& lst)
 {
-  Pix p = lst.first ();
+  tree_argument_list::iterator p = lst.begin ();
 
-  while (p)
+  while (p != lst.end ())
     {
-      tree_expression *elt = lst (p);
-
-      lst.next (p);
+      tree_expression *elt = *p++;
 
       if (elt)
 	{
 	  if (do_lvalue_check && ! elt->lvalue_ok ())
 	    gripe ("invalid lvalue in multiple assignment", elt->line ());
 	}
     }
 }
@@ -116,23 +114,21 @@ tree_checker::visit_decl_elt (tree_decl_
 
   if (expr)
     expr->accept (*this);
 }
 
 void
 tree_checker::visit_decl_init_list (tree_decl_init_list& lst)
 {
-  Pix p = lst.first ();
+  tree_decl_init_list::iterator p = lst.begin ();
 
-  while (p)
+  while (p != lst.end ())
     {
-      tree_decl_elt *elt = lst (p);
-
-      lst.next (p);
+      tree_decl_elt *elt = *p++;
 
       if (elt)
 	elt->accept (*this);
     }
 }
 
 void
 tree_checker::visit_simple_for_command (tree_simple_for_command& cmd)
@@ -222,62 +218,70 @@ tree_checker::visit_if_command (tree_if_
 
   if (list)
     list->accept (*this);
 }
 
 void
 tree_checker::visit_if_command_list (tree_if_command_list& lst)
 {
-  Pix p = lst.first ();
+  tree_if_command_list::iterator p = lst.begin ();
 
-  while (p)
+  while (p != lst.end ())
     {
-      tree_if_clause *elt = lst (p);
+      tree_if_clause *elt = *p++;
 
       if (elt)
 	elt->accept (*this);
-
-      lst.next (p);
     }
 }
 
 void
 tree_checker::visit_index_expression (tree_index_expression& expr)
 {
   tree_expression *e = expr.expression ();
 
   if (e)
     e->accept (*this);
 
-  SLList<tree_argument_list *> lst = expr.arg_lists ();
+  std::list<tree_argument_list *> lst = expr.arg_lists ();
 
-  Pix p = lst.first ();
+  std::list<tree_argument_list *>::iterator p = lst.begin ();
 
-  while (p)
+  while (p != lst.end ())
     {
-      tree_argument_list *elt = lst (p);
+      tree_argument_list *elt = *p++;
 
       if (elt)
 	elt->accept (*this);
-
-      lst.next (p);
     }
 }
 
 void
 tree_checker::visit_matrix (tree_matrix& lst)
 {
-  Pix p = lst.first ();
+  tree_matrix::iterator p = lst.begin ();
 
-  while (p)
+  while (p != lst.end ())
     {
-      tree_argument_list *elt = lst (p);
+      tree_argument_list *elt = *p++;
+
+      if (elt)
+	elt->accept (*this);
+    }
+}
 
-      lst.next (p);
+void
+tree_checker::visit_cell (tree_cell& lst)
+{
+  tree_matrix::iterator p = lst.begin ();
+
+  while (p != lst.end ())
+    {
+      tree_argument_list *elt = *p++;
 
       if (elt)
 	elt->accept (*this);
     }
 }
 
 void
 tree_checker::visit_multi_assignment (tree_multi_assignment& expr)
@@ -307,23 +311,21 @@ tree_checker::visit_no_op_command (tree_
 void
 tree_checker::visit_constant (tree_constant& /* val */)
 {
 }
 
 void
 tree_checker::visit_parameter_list (tree_parameter_list& lst)
 {
-  Pix p = lst.first ();
+  tree_parameter_list::iterator p = lst.begin ();
 
-  while (p)
+  while (p != lst.end ())
     {
-      tree_identifier *elt = lst (p);
-
-      lst.next (p);
+      tree_identifier *elt = *p++;
 
       if (elt)
 	elt->accept (*this);
     }
 }
 
 void
 tree_checker::visit_plot_command (tree_plot_command& cmd)
@@ -393,23 +395,21 @@ tree_checker::visit_prefix_expression (t
 void
 tree_checker::visit_return_command (tree_return_command&)
 {
 }
 
 void
 tree_checker::visit_return_list (tree_return_list& lst)
 {
-  Pix p = lst.first ();
+  tree_return_list::iterator p = lst.begin ();
 
-  while (p)
+  while (p != lst.end ())
     {
-      tree_index_expression *elt = lst (p);
-
-      lst.next (p);
+      tree_index_expression *elt = *p++;
 
       if (elt)
 	elt->accept (*this);
     }
 }
 
 void
 tree_checker::visit_simple_assignment (tree_simple_assignment& expr)
@@ -442,19 +442,19 @@ tree_checker::visit_statement (tree_stat
       if (expr)
 	expr->accept (*this);
     }
 }
 
 void
 tree_checker::visit_statement_list (tree_statement_list& lst)
 {
-  for (Pix p = lst.first (); p != 0; lst.next (p))
+  for (tree_statement_list::iterator p = lst.begin (); p != lst.end (); p++)
     {
-      tree_statement *elt = lst (p);
+      tree_statement *elt = *p;
 
       if (elt)
 	elt->accept (*this);
     }
 }
 
 void
 tree_checker::visit_subplot (subplot& cmd)
@@ -478,23 +478,21 @@ tree_checker::visit_subplot (subplot& cm
 
   if (sp_style_clause)
     sp_style_clause->accept (*this);
 }
 
 void
 tree_checker::visit_subplot_list (subplot_list& lst)
 {
-  Pix p = lst.first ();
+  subplot_list::iterator p = lst.begin ();
 
-  while (p)
+  while (p != lst.end ())
     {
-      subplot *elt = lst (p);
-
-      lst.next (p);
+      subplot *elt = *p++;
 
       if (elt)
 	elt->accept (*this);
     }
 }
 
 void
 tree_checker::visit_subplot_style (subplot_style& cmd)
@@ -546,26 +544,24 @@ tree_checker::visit_switch_case (tree_sw
 
   if (list)
     list->accept (*this);
 }
 
 void
 tree_checker::visit_switch_case_list (tree_switch_case_list& lst)
 {
-  Pix p = lst.first ();
+  tree_switch_case_list::iterator p = lst.begin ();
 
-  while (p)
+  while (p != lst.end ())
     {
-      tree_switch_case *elt = lst (p);
+      tree_switch_case *elt = *p++;
 
       if (elt)
 	elt->accept (*this);
-
-      lst.next (p);
     }
 }
 
 void
 tree_checker::visit_switch_command (tree_switch_command& cmd)
 {
   tree_expression *expr = cmd.switch_value ();
 
diff --git a/src/pt-check.h b/src/pt-check.h
--- a/src/pt-check.h
+++ b/src/pt-check.h
@@ -70,16 +70,18 @@ public:
   void visit_if_command (tree_if_command&);
 
   void visit_if_command_list (tree_if_command_list&);
 
   void visit_index_expression (tree_index_expression&);
 
   void visit_matrix (tree_matrix&);
 
+  void visit_cell (tree_cell&);
+
   void visit_multi_assignment (tree_multi_assignment&);
 
   void visit_no_op_command (tree_no_op_command&);
 
   void visit_constant (tree_constant&);
 
   void visit_parameter_list (tree_parameter_list&);
 
diff --git a/src/pt-decl.cc b/src/pt-decl.cc
--- a/src/pt-decl.cc
+++ b/src/pt-decl.cc
@@ -58,19 +58,21 @@ tree_decl_elt::accept (tree_walker& tw)
   tw.visit_decl_elt (*this);
 }
 
 // Initializer lists for declaration statements.
 
 void
 tree_decl_init_list::eval (tree_decl_elt::eval_fcn f)
 {
-  for (Pix p = first (); p != 0; next (p))
+  for (iterator p = begin (); p != end (); p++)
     {
-      f (*(this->operator () (p)));
+      tree_decl_elt *elt = *p;
+
+      f (*elt);
 
       if (error_state)
 	break;
     }
 }
 
 void
 tree_decl_init_list::accept (tree_walker& tw)
diff --git a/src/pt-decl.h b/src/pt-decl.h
--- a/src/pt-decl.h
+++ b/src/pt-decl.h
@@ -22,25 +22,24 @@ Software Foundation, 59 Temple Place - S
 
 #if !defined (octave_tree_decl_h)
 #define octave_tree_decl_h 1
 
 #if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
 #pragma interface
 #endif
 
-#include <SLList.h>
-
 class tree_expression;
 class tree_identifier;
 
 class tree_walker;
 
 #include <string>
 
+#include "base-list.h"
 #include "pt-cmd.h"
 
 // List of expressions that make up a declaration statement.
 
 class
 tree_decl_elt
 {
 public:
@@ -71,55 +70,40 @@ private:
   // No copying!
 
   tree_decl_elt (const tree_decl_elt&);
 
   tree_decl_elt& operator = (const tree_decl_elt&);
 };
 
 class
-tree_decl_init_list
+tree_decl_init_list : public octave_base_list<tree_decl_elt *>
 {
 public:
 
-  tree_decl_init_list (void)
-    : lst () { }
+  tree_decl_init_list (void) { }
 
-  tree_decl_init_list (tree_decl_elt *t)
-    : lst () { lst.append (t); }
+  tree_decl_init_list (tree_decl_elt *t) { append (t); }
 
   ~tree_decl_init_list (void)
     {
-      while (! lst.empty ())
+      while (! empty ())
 	{
-	  tree_decl_elt *t = lst.remove_front ();
-	  delete t;
+	  iterator p = begin ();
+	  delete *p;
+	  erase (p);
 	}
     }
 
-  void append (tree_decl_elt *&s) { lst.append (s); }
-  void append (tree_decl_elt * const &s) { lst.append (s); }
-
-  tree_decl_elt *&operator () (Pix p) { return lst (p); }
-
-  tree_decl_elt * const &operator () (Pix p) const { return lst (p); }
-
-  Pix first (void) const { return lst.first (); }
-
-  void next (Pix& p) const { return lst.next (p); }
-
   void eval (tree_decl_elt::eval_fcn);
 
   void accept (tree_walker& tw);
 
 private:
 
-  // The list of variables/initializers.
-  SLList<tree_decl_elt *> lst;
-
   // No copying!
 
   tree_decl_init_list (const tree_decl_init_list&);
 
   tree_decl_init_list& operator = (const tree_decl_init_list&);
 };
 
 // Base class for declaration commands -- global, static, etc.
diff --git a/src/pt-idx.cc b/src/pt-idx.cc
--- a/src/pt-idx.cc
+++ b/src/pt-idx.cc
@@ -37,21 +37,16 @@ Software Foundation, 59 Temple Place - S
 #include "pager.h"
 #include "pt-arg-list.h"
 #include "pt-bp.h"
 #include "pt-idx.h"
 #include "pt-walk.h"
 #include "utils.h"
 #include "variables.h"
 
-#include "SLList.cc"
-
-template class SLNode<string_vector>;
-template class SLList<string_vector>;
-
 // Index expressions.
 
 tree_index_expression::tree_index_expression (tree_expression *e,
 					      tree_argument_list *lst,
 					      int l, int c, char t)
   : tree_expression (l, c), expr (e), args (), type (),
     arg_nm (), dyn_field ()
 {
@@ -74,48 +69,49 @@ tree_index_expression::tree_index_expres
     arg_nm (), dyn_field ()
 {
   append (df);
 }
 
 void
 tree_index_expression::append (tree_argument_list *lst, char t)
 {
-  args.append (lst);
+  args.push_back (lst);
   type.append (1, t);
-  arg_nm.append (lst ? lst->get_arg_names () : string_vector ());
-  dyn_field.append (static_cast<tree_expression *> (0));
+  arg_nm.push_back (lst ? lst->get_arg_names () : string_vector ());
+  dyn_field.push_back (static_cast<tree_expression *> (0));
 }
 
 void
 tree_index_expression::append (const std::string& n)
 {
-  args.append (static_cast<tree_argument_list *> (0));
+  args.push_back (static_cast<tree_argument_list *> (0));
   type.append (".");
-  arg_nm.append (n);
-  dyn_field.append (static_cast<tree_expression *> (0));
+  arg_nm.push_back (n);
+  dyn_field.push_back (static_cast<tree_expression *> (0));
 }
 
 void
 tree_index_expression::append (tree_expression *df)
 {
-  args.append (static_cast<tree_argument_list *> (0));
+  args.push_back (static_cast<tree_argument_list *> (0));
   type.append (".");
-  arg_nm.append ("");
-  dyn_field.append (df);
+  arg_nm.push_back ("");
+  dyn_field.push_back (df);
 }
 
 tree_index_expression::~tree_index_expression (void)
 {
   delete expr;
 
   while (! args.empty ())
     {
-      tree_argument_list *t = args.remove_front ();
-      delete t;
+      std::list<tree_argument_list *>::iterator p = args.begin ();
+      delete *p;
+      args.erase (p);
     }
 }
 
 // This is useful for printing the name of the variable in an indexed
 // assignment.
 
 std::string
 tree_index_expression::name (void) const
@@ -166,23 +162,25 @@ make_value_list (tree_argument_list *arg
       if (n > 0)
 	retval.stash_name_tags (arg_nm);
     }
 
   return retval;
 }
 
 std::string
-tree_index_expression::get_struct_index (Pix p_arg_nm, Pix p_dyn_field) const
+tree_index_expression::get_struct_index
+  (std::list<string_vector>::const_iterator p_arg_nm,
+   std::list<tree_expression *>::const_iterator p_dyn_field) const
 {
-  std::string fn = arg_nm(p_arg_nm)(0);
+  std::string fn = (*p_arg_nm)(0);
 
   if (fn.empty ())
     {
-      tree_expression *df = dyn_field (p_dyn_field);
+      tree_expression *df = *p_dyn_field;
 
       if (df)
 	{
 	  octave_value t = df->rvalue ();
 
 	  if (! error_state)
 	    {
 	      fn = t.string_value ();
@@ -196,37 +194,37 @@ tree_index_expression::get_struct_index 
     }
 
   return fn;
 }
 
 Octave_map
 tree_index_expression::make_arg_struct (void) const
 {
-  int n = args.length ();
+  int n = args.size ();
 
   octave_value_list subs_list (n, octave_value ());
   octave_value_list type_list (n, octave_value ());
 
-  Pix p_args = args.first ();
-  Pix p_arg_nm = arg_nm.first ();
-  Pix p_dyn_field = dyn_field.first ();
+  std::list<tree_argument_list *>::const_iterator p_args = args.begin ();
+  std::list<string_vector>::const_iterator p_arg_nm = arg_nm.begin ();
+  std::list<tree_expression *>::const_iterator p_dyn_field = dyn_field.begin ();
 
   Octave_map m;
 
   for (int i = 0; i < n; i++)
     {
       switch (type[i])
 	{
 	case '(':
-	  subs_list(i) = make_subs_cell (args(p_args), arg_nm(p_arg_nm));
+	  subs_list(i) = make_subs_cell (*p_args, *p_arg_nm);
 	  break;
 
 	case '{':
-	  subs_list(i) = make_subs_cell (args(p_args), arg_nm(p_arg_nm));
+	  subs_list(i) = make_subs_cell (*p_args, *p_arg_nm);
 	  break;
 
 	case '.':
 	  {
 	    subs_list(i) = get_struct_index (p_arg_nm, p_dyn_field);
 
 	    if (error_state)
 	      eval_error ();
@@ -235,19 +233,19 @@ tree_index_expression::make_arg_struct (
 
 	default:
 	  panic_impossible ();
 	}
 
       if (error_state)
 	return m;
 
-      args.next (p_args);
-      arg_nm.next (p_arg_nm);
-      dyn_field.next (p_dyn_field);
+      p_args++;
+      p_arg_nm++;
+      p_dyn_field++;
     }
 
   m ["subs"] = subs_list;
   m ["type"] = type_list;
 
   return m;
 }
 
@@ -258,55 +256,55 @@ tree_index_expression::rvalue (int nargo
 
   if (error_state)
     return retval;
 
   octave_value tmp = expr->rvalue ();
 
   if (! error_state)
     {
-      SLList<octave_value_list> idx;
+      std::list<octave_value_list> idx;
 
-      int n = args.length ();
+      int n = args.size ();
 
-      Pix p_args = args.first ();
-      Pix p_arg_nm = arg_nm.first ();
-      Pix p_dyn_field = dyn_field.first ();
+      std::list<tree_argument_list *>::iterator p_args = args.begin ();
+      std::list<string_vector>::iterator p_arg_nm = arg_nm.begin ();
+      std::list<tree_expression *>::iterator p_dyn_field = dyn_field.begin ();
 
       for (int i = 0; i < n; i++)
 	{
 	  switch (type[i])
 	    {
 	    case '(':
-	      idx.append (make_value_list (args(p_args), arg_nm(p_arg_nm)));
+	      idx.push_back (make_value_list (*p_args, *p_arg_nm));
 	      break;
 
 	    case '{':
-	      idx.append (make_value_list (args(p_args), arg_nm(p_arg_nm)));
+	      idx.push_back (make_value_list (*p_args, *p_arg_nm));
 	      break;
 
 	    case '.':
 	      {
-		idx.append (get_struct_index (p_arg_nm, p_dyn_field));
+		idx.push_back (get_struct_index (p_arg_nm, p_dyn_field));
 
 		if (error_state)
 		  eval_error ();
 	      }
 	      break;
 
 	    default:
 	      panic_impossible ();
 	    }
 
 	  if (error_state)
 	    break;
 
-	  args.next (p_args);
-	  arg_nm.next (p_arg_nm);
-	  dyn_field.next (p_dyn_field);
+	  p_args++;
+	  p_arg_nm++;
+	  p_dyn_field++;
 	}
 
       if (! error_state)
 	retval = tmp.subsref (type, idx, nargout);
     }
 
   return retval;
 }
@@ -324,55 +322,55 @@ tree_index_expression::rvalue (void)
   return retval;
 }
 
 octave_lvalue
 tree_index_expression::lvalue (void)
 {
   octave_lvalue retval;
 
-  SLList<octave_value_list> idx;
+  std::list<octave_value_list> idx;
 
-  int n = args.length ();
+  int n = args.size ();
 
-  Pix p_args = args.first ();
-  Pix p_arg_nm = arg_nm.first ();
-  Pix p_dyn_field = dyn_field.first ();
+  std::list<tree_argument_list *>::iterator p_args = args.begin ();
+  std::list<string_vector>::iterator p_arg_nm = arg_nm.begin ();
+  std::list<tree_expression *>::iterator p_dyn_field = dyn_field.begin ();
 
   for (int i = 0; i < n; i++)
     {
       switch (type[i])
 	{
 	case '(':
-	  idx.append (make_value_list (args(p_args), arg_nm(p_arg_nm)));
+	  idx.push_back (make_value_list (*p_args, *p_arg_nm));
 	  break;
 
 	case '{':
-	  idx.append (make_value_list (args(p_args), arg_nm(p_arg_nm)));
+	  idx.push_back (make_value_list (*p_args, *p_arg_nm));
 	  break;
 
 	case '.':
 	  {
-	    idx.append (get_struct_index (p_arg_nm, p_dyn_field));
+	    idx.push_back (get_struct_index (p_arg_nm, p_dyn_field));
 
 	    if (error_state)
 	      eval_error ();
 	  }
 	  break;
 
 	default:
 	  panic_impossible ();
 	}
 
       if (error_state)
 	break;
 
-      args.next (p_args);
-      arg_nm.next (p_arg_nm);
-      dyn_field.next (p_dyn_field);
+      p_args++;
+      p_arg_nm++;
+      p_dyn_field++;
     }
 
   if (! error_state)
     {
       retval = expr->lvalue ();
 
       if (! error_state)
 	retval.set_index (type, idx);
diff --git a/src/pt-idx.h b/src/pt-idx.h
--- a/src/pt-idx.h
+++ b/src/pt-idx.h
@@ -22,26 +22,27 @@ Software Foundation, 59 Temple Place - S
 
 #if !defined (octave_tree_index_h)
 #define octave_tree_index_h 1
 
 #if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
 #pragma interface
 #endif
 
+#include <list>
+
 class tree_argument_list;
 
 class tree_walker;
 
 class Octave_map;
 class octave_value;
 class octave_value_list;
 class octave_lvalue;
 
-#include "SLList.h"
 #include "str-vec.h"
 
 #include "pt-exp.h"
 
 // Index expressions.
 
 class
 tree_index_expression : public tree_expression
@@ -66,21 +67,21 @@ public:
   void append (tree_expression *df);
 
   bool is_index_expression (void) const { return true; }
 
   std::string name (void) const;
 
   tree_expression *expression (void) { return expr; }
 
-  SLList<tree_argument_list *> arg_lists (void) { return args; }
+  std::list<tree_argument_list *> arg_lists (void) { return args; }
 
   std::string type_tags (void) { return type; }
 
-  SLList<string_vector> arg_names (void) { return arg_nm; }
+  std::list<string_vector> arg_names (void) { return arg_nm; }
 
   bool lvalue_ok (void) const { return expr->lvalue_ok (); }
 
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
@@ -92,31 +93,34 @@ public:
   void accept (tree_walker& tw);
 
 private:
 
   // The LHS of this index expression.
   tree_expression *expr;
 
   // The indices (only valid if type == paren || type == brace).
-  SLList<tree_argument_list *> args;
+  std::list<tree_argument_list *> args;
 
   // The type of this index expression.
   std::string type;
 
   // The names of the arguments.  Used for constant struct element
   // references.
-  SLList<string_vector> arg_nm;
+  std::list<string_vector> arg_nm;
 
   // The list of dynamic field names, if any.
-  SLList<tree_expression *> dyn_field;
+  std::list<tree_expression *> dyn_field;
 
   Octave_map make_arg_struct (void) const;
 
-  std::string get_struct_index (Pix p_arg_nm, Pix p_dyn_field) const;
+  std::string
+  get_struct_index
+    (std::list<string_vector>::const_iterator p_arg_nm,
+     std::list<tree_expression *>::const_iterator p_dyn_field) const; 
 
   // No copying!
 
   tree_index_expression (const tree_index_expression&);
 
   tree_index_expression& operator = (const tree_index_expression&);
 };
 
diff --git a/src/pt-loop.cc b/src/pt-loop.cc
--- a/src/pt-loop.cc
+++ b/src/pt-loop.cc
@@ -368,17 +368,19 @@ tree_simple_for_command::eval (void)
 	    else
 	      DO_LOOP (cm_tmp.extract (0, i, nr-1, i));
 	  }
       }
     else if (rhs.is_map ())
       {
 	Octave_map tmp_val (rhs.map_value ());
 
-	for (Pix p = tmp_val.first (); p != 0; tmp_val.next (p))
+	for (Octave_map::iterator p = tmp_val.begin ();
+	     p != tmp_val.end ();
+	     p++)
 	  {
 	    MAYBE_DO_BREAKPOINT;
 
 	    octave_value_list val_lst = tmp_val.contents (p);
 
 	    octave_value val
 	      = (val_lst.length () == 1) ? val_lst(0) : octave_value (val_lst);
 
@@ -471,31 +473,29 @@ tree_complex_for_command::eval (void)
     }
 
   if (rhs.is_map ())
     {
       // Cycle through structure elements.  First element of id_list
       // is set to value and the second is set to the name of the
       // structure element.
 
-      Pix p = lhs->first ();
-      tree_expression *elt = lhs->operator () (p);
+      tree_argument_list::iterator p = lhs->begin ();
+      tree_expression *elt = *p++;
       octave_lvalue val_ref = elt->lvalue ();
-
-      lhs->next (p);
-      elt = lhs->operator () (p);
+      elt = *p;
       octave_lvalue key_ref = elt->lvalue ();
 
       Octave_map tmp_val (rhs.map_value ());
 
-      for (p = tmp_val.first (); p != 0; tmp_val.next (p))
+      for (Octave_map::iterator q = tmp_val.begin (); q != tmp_val.end (); p++)
 	{
-	  octave_value key = tmp_val.key (p);
+	  octave_value key = tmp_val.key (q);
 
-	  octave_value_list val_lst = tmp_val.contents (p);
+	  octave_value_list val_lst = tmp_val.contents (q);
 
 	  int n = tmp_val.array_length ();
 
 	  octave_value val = (n == 1) ? val_lst(0) : octave_value (val_lst);
 
 	  MAYBE_DO_BREAKPOINT;
 
 	  bool quit = false;
diff --git a/src/pt-mat.cc b/src/pt-mat.cc
--- a/src/pt-mat.cc
+++ b/src/pt-mat.cc
@@ -61,27 +61,27 @@ char Vstring_fill_char = ' ';
 // But first, some internal classes that make our job much easier.
 
 class
 tm_row_const
 {
 private:
 
   class
-  tm_row_const_rep : public SLList<octave_value>
+  tm_row_const_rep : public octave_base_list<octave_value>
   {
   public:
 
     tm_row_const_rep (void)
-      : SLList<octave_value> (), count (1), nr (0), nc (0),
+      : count (1), nr (0), nc (0),
 	all_str (false), some_str (false), is_cmplx (false),
 	all_mt (true), ok (false) { }
 
     tm_row_const_rep (const tree_argument_list& row)
-      : SLList<octave_value> (), count (1), nr (0), nc (0),
+      : count (1), nr (0), nc (0),
 	all_str (false), some_str (false), is_cmplx (false),
 	all_mt (true), ok (false)
     { init (row); }
 
     ~tm_row_const_rep (void) { }
 
     int count;
 
@@ -106,16 +106,19 @@ private:
     void eval_error (const char *msg, int l, int c,
 		     int x = -1, int y = -1) const;
 
     void eval_warning (const char *msg, int l, int c) const;
   };
 
 public:
 
+  typedef tm_row_const_rep::iterator iterator;
+  typedef tm_row_const_rep::const_iterator const_iterator;
+
   tm_row_const (void)
     : rep (0) { }
 
   tm_row_const (const tree_argument_list& row)
     : rep (new tm_row_const_rep (row)) { }
 
   tm_row_const (const tm_row_const& x)
     : rep (x.rep)
@@ -149,41 +152,41 @@ public:
   int rows (void) { return rep->nr; }
   int cols (void) { return rep->nc; }
 
   bool all_strings_p (void) const { return rep->all_str; }
   bool some_strings_p (void) const { return rep->some_str; }
   bool complex_p (void) const { return rep->is_cmplx; }
   bool all_empty_p (void) const { return rep->all_mt; }
 
-  octave_value& operator () (Pix p) { return rep->operator () (p); }
-
-  const octave_value& operator () (Pix p) const
-    { return rep->operator () (p); }
+  operator bool () const { return (rep && rep->ok); }
 
-  Pix first (void) const { return rep->first (); }
-  void next (Pix& p) const { rep->next (p); }
-  
-  operator bool () const { return (rep && rep->ok); }
+  iterator begin (void) { return rep->begin (); }
+  const_iterator begin (void) const { return rep->begin (); }
+
+  iterator end (void) { return rep->end (); }
+  const_iterator end (void) const { return rep->end (); }
 
 private:
 
   tm_row_const_rep *rep;
 };
 
 void
 tm_row_const::tm_row_const_rep::init (const tree_argument_list& row)
 {
   all_str = true;
 
   bool first_elem = true;
 
-  for (Pix p = row.first (); p != 0; row.next (p))
+  for (tree_argument_list::const_iterator p = row.begin ();
+       p != row.end ();
+       p++)
     {
-      tree_expression *elt = row (p);
+      tree_expression *elt = *p;
 
       octave_value tmp = elt->rvalue ();
 
       if (error_state || tmp.is_undefined ())
 	break;
       else
 	{
 	  int this_elt_nr = tmp.rows ();
@@ -262,29 +265,23 @@ tm_row_const::tm_row_const_rep::eval_war
 					      int c) const
 {
   if (l == -1 && c == -1)
     ::warning ("%s", msg);
   else
     ::warning ("%s near line %d, column %d", msg, l, c);
 }
 
-#include "SLList.h"
-#include "SLList.cc"
-
-template class SLNode<tm_row_const>;
-template class SLList<tm_row_const>;
-
 class
-tm_const : public SLList<tm_row_const>
+tm_const : public octave_base_list<tm_row_const>
 {
 public:
 
   tm_const (const tree_matrix& tm)
-    : SLList<tm_row_const> (), nr (0), nc (0),
+    : nr (0), nc (0),
       all_str (false), some_str (false), is_cmplx (false),
       all_mt (true), ok (false)
       { init (tm); }
 
   ~tm_const (void) { }
 
   int rows (void) const { return nr; }
   int cols (void) const { return nc; }
@@ -324,19 +321,19 @@ tm_const::init (const tree_matrix& tm)
 
   bool first_elem = true;
 
   // Just eval and figure out if what we have is complex or all
   // strings.  We can't check columns until we know that this is a
   // numeric matrix -- collections of strings can have elements of
   // different lengths.
 
-  for (Pix p = tm.first (); p != 0; tm.next (p))
+  for (tree_matrix::const_iterator p = tm.begin (); p != tm.end (); p++)
     {
-      tree_argument_list *elt = tm (p);
+      tree_argument_list *elt = *p;
 
       tm_row_const tmp (*elt);
 
       if (tmp)
 	{
 	  if (all_str && ! tmp.all_strings_p ())
 	    all_str = false;
 
@@ -352,19 +349,19 @@ tm_const::init (const tree_matrix& tm)
 	  append (tmp);
 	}
       else
 	break;
     }
 
   if (! error_state)
     {
-      for (Pix p = first (); p != 0; next (p))
+      for (iterator p = begin (); p != end (); p++)
 	{
-	  tm_row_const elt = this->operator () (p);
+	  tm_row_const elt = *p;
 
 	  int this_elt_nr = elt.rows ();
 	  int this_elt_nc = elt.cols ();
 
 	  if (this_elt_nr == 0 || this_elt_nc == 0)
 	    {
 	      if (Vempty_list_elements_ok < 0)
 		warning ("empty matrix found in matrix list");
@@ -401,29 +398,30 @@ tm_const::init (const tree_matrix& tm)
 	}
     }
 
   ok = ! error_state;
 }
 
 tree_matrix::~tree_matrix (void)
 {
-  while (! lst.empty ())
+  while (! empty ())
     {
-      tree_argument_list *t = lst.remove_front ();
-      delete t;
+      iterator p = begin ();
+      delete *p;
+      erase (p);
     }
 }
 
 bool
 tree_matrix::all_elements_are_constant (void) const
 {
-  for (Pix p = lst.first (); p != 0; lst.next (p))
+  for (const_iterator p = begin (); p != end (); p++)
     {
-      tree_argument_list *elt = lst (p);
+      tree_argument_list *elt = *p;
 
       if (! elt->all_elements_are_constant ())
 	return false;
     }
 
   return true;
 }
 
@@ -483,25 +481,25 @@ tree_matrix::rvalue (void)
 	chm.resize (nr, nc, Vstring_fill_char);
       else if (found_complex)
 	cm.resize (nr, nc, 0.0);
       else
 	m.resize (nr, nc, 0.0);
 
       int put_row = 0;
 
-      for (Pix p = tmp.first (); p != 0; tmp.next (p))
+      for (tm_const::iterator p = tmp.begin (); p != tmp.end (); p++)
 	{
 	  int put_col = 0;
 
-	  tm_row_const row = tmp (p);
+	  tm_row_const row = *p;
 
-	  for (Pix q = row.first (); q != 0; row.next (q))
+	  for (tm_row_const::iterator q = row.begin (); q != row.end (); q++)
 	    {
-	      octave_value elt = row (q);
+	      octave_value elt = *q;
 
 	      if (found_complex)
 		{
 		  if (elt.is_real_scalar ())
 		    cm (put_row, put_col) = elt.double_value ();
 		  else if (elt.is_real_matrix () || elt.is_range ())
 		    cm.insert (elt.matrix_value (), put_row, put_col);
 		  else if (elt.is_complex_scalar ())
diff --git a/src/pt-mat.h b/src/pt-mat.h
--- a/src/pt-mat.h
+++ b/src/pt-mat.h
@@ -30,65 +30,49 @@ Software Foundation, 59 Temple Place - S
 #include <iostream>
 
 class octave_value;
 class octave_value_list;
 class tree_argument_list;
 
 class tree_walker;
 
-#include <SLList.h>
-
+#include "base-list.h"
 #include "pt-exp.h"
 
 // General matrices.  This allows us to construct matrices from
 // other matrices, variables, and functions.
 
 class
-tree_matrix : public tree_expression
+tree_matrix : public tree_expression,
+	      public octave_base_list<tree_argument_list *>
 {
 public:
 
   tree_matrix (tree_argument_list *row = 0, int line = -1, int column = -1)
-    : tree_expression (line, column), lst ()
+    : tree_expression (line, column)
   {
     if (row)
-      lst.append (row);
+      append (row);
   }
 
   ~tree_matrix (void);
 
-  int length (void) const { return lst.length (); }
-
-  void append (tree_argument_list *&s) { lst.append (s); }
-  void append (tree_argument_list * const &s) { lst.append (s); }
-
-  tree_argument_list *&operator () (Pix p) { return lst (p); }
-
-  tree_argument_list * const &operator () (Pix p) const { return lst (p); }
-
-  Pix first (void) const { return lst.first (); }
-
-  void next (Pix& p) const { return lst.next (p); }
-
   bool all_elements_are_constant (void) const;
 
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
   void accept (tree_walker& tw);
 
 private:
 
-  // The list matrix elements for this row.
-  SLList<tree_argument_list *> lst;
-
   // No copying!
 
   tree_matrix (const tree_matrix&);
 
   tree_matrix& operator = (const tree_matrix&);
 };
 
 // The character to fill with when creating string arrays.
diff --git a/src/pt-misc.cc b/src/pt-misc.cc
--- a/src/pt-misc.cc
+++ b/src/pt-misc.cc
@@ -23,53 +23,52 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <SLList.h>
-
 #include "error.h"
 #include "ov.h"
 #include "oct-lvalue.h"
 #include "pt-id.h"
 #include "pt-idx.h"
 #include "pt-misc.h"
 #include "pt-walk.h"
 
 // Parameter lists.
 
 tree_parameter_list::~tree_parameter_list (void)
 {
-  while (! lst.empty ())
+  while (! empty ())
     {
-      tree_identifier *t = lst.remove_front ();
-      delete t;
+      iterator p = begin ();
+      delete *p;
+      erase (p);
     }
 }
 
 void
 tree_parameter_list::mark_as_formal_parameters (void)
 {
-  for (Pix p = lst.first (); p != 0; lst.next (p))
+  for (iterator p = begin (); p != end (); p++)
     {
-      tree_identifier *elt = lst (p);
+      tree_identifier *elt = *p;
       elt->mark_as_formal_parameter ();
     }
 }
 
 void
 tree_parameter_list::initialize_undefined_elements (octave_value& val)
 {
-  for (Pix p = lst.first (); p != 0; lst.next (p))
+  for (iterator p = begin (); p != end (); p++)
     {
-      tree_identifier *elt = lst (p);
+      tree_identifier *elt = *p;
 
       if (! elt->is_defined ())
 	{
 	  octave_lvalue tmp = elt->lvalue ();
 
 	  tmp.assign (octave_value::op_asn_eq, val);
 	}
     }
@@ -80,103 +79,98 @@ tree_parameter_list::define_from_arg_vec
 {
   int nargin = args.length ();
 
   if (nargin <= 0)
     return;
 
   int expected_nargin = length ();
 
-  Pix p = lst.first ();
+  iterator p = begin ();
 
   for (int i = 0; i < expected_nargin; i++)
     {
-      tree_identifier *elt = lst (p);
+      tree_identifier *elt = *p++;
 
       octave_lvalue ref = elt->lvalue ();
 
       if (i < nargin)
 	{
 	  if (args(i).is_defined () && args(i).is_magic_colon ())
 	    {
 	      ::error ("invalid use of colon in function argument list");
 	      return;
 	    }
 
 	  ref.assign (octave_value::op_asn_eq, args(i));
 	}
       else
 	ref.assign (octave_value::op_asn_eq, octave_value ());
-
-      lst.next (p);
     }
 }
 
 void
-tree_parameter_list::clear (void)
+tree_parameter_list::undefine (void)
 {
   int len = length ();
 
-  Pix p = lst.first ();
+  iterator p = begin ();
 
   for (int i = 0; i < len; i++)
     {
-      tree_identifier *elt = lst (p);
+      tree_identifier *elt = *p++;
 
       octave_lvalue ref = elt->lvalue ();
 
       ref.assign (octave_value::op_asn_eq, octave_value ());
-
-      lst.next (p);
     }
 }
 
 octave_value_list
 tree_parameter_list::convert_to_const_vector (tree_va_return_list *vr_list)
 {
   int nout = length ();
 
   if (vr_list)
     nout += vr_list->length ();
 
   octave_value_list retval;
   retval.resize (nout);
 
   int i = 0;
 
-  for (Pix p = lst.first (); p != 0; lst.next (p))
+  for (iterator p = begin (); p != end (); p++)
     {
-      tree_identifier *elt = this->operator () (p);
+      tree_identifier *elt = *p;
 
       if (elt->is_defined ())
-	retval(i) = elt->rvalue ();
-
-      i++;
+	retval(i++) = elt->rvalue ();
     }
 
   if (vr_list)
     {
-      for (Pix p = vr_list->first (); p != 0; vr_list->next (p))
+      for (tree_va_return_list::iterator p = vr_list->begin ();
+	   p != vr_list->end ();
+	   p++)
 	{
-	  retval(i) = vr_list->operator () (p);
-	  i++;
+	  retval(i++) = *p;
 	}
     }
 
   return retval;
 }
 
 bool
 tree_parameter_list::is_defined (void)
 {
   bool status = true;
 
-  for (Pix p = lst.first (); p != 0; lst.next (p))
+  for (iterator p = begin (); p != end (); p++)
     {
-      tree_identifier *elt = lst (p);
+      tree_identifier *elt = *p;
 
       if (! elt->is_defined ())
 	{
 	  status = false;
 	  break;
 	}
     }
 
@@ -188,20 +182,21 @@ tree_parameter_list::accept (tree_walker
 {
   tw.visit_parameter_list (*this);
 }
 
 // Return lists.
 
 tree_return_list::~tree_return_list (void)
 {
-  while (! lst.empty ())
+  while (! empty ())
     {
-      tree_index_expression *t = lst.remove_front ();
-      delete t;
+      iterator p = begin ();
+      delete *p;
+      erase (p);
     }
 }
 
 void
 tree_return_list::accept (tree_walker& tw)
 {
   tw.visit_return_list (*this);
 }
diff --git a/src/pt-misc.h b/src/pt-misc.h
--- a/src/pt-misc.h
+++ b/src/pt-misc.h
@@ -22,165 +22,113 @@ Software Foundation, 59 Temple Place - S
 
 #if !defined (octave_tree_misc_h)
 #define octave_tree_misc_h 1
 
 #if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
 #pragma interface
 #endif
 
-#include <SLList.h>
-
 class octave_value;
 class octave_value_list;
 
 class tree_identifier;
 class tree_index_expression;
 class tree_va_return_list;
 
 class tree_walker;
 
+#include "base-list.h"
+
 // Parameter lists.  Used to hold the list of input and output
 // parameters in a function definition.  Elements are identifiers
 // only.
 
 class
-tree_parameter_list
+tree_parameter_list : public octave_base_list<tree_identifier *>
 {
 public:
 
   tree_parameter_list (void)
-    : lst (), marked_for_varargs (0) { }
+    : marked_for_varargs (0) { }
 
   tree_parameter_list (tree_identifier *t)
-    : lst (), marked_for_varargs (0) { lst.append (t); }
+    : marked_for_varargs (0) { append (t); }
 
   ~tree_parameter_list (void);
 
-  int length (void) const { return lst.length (); }
-
-  void append (tree_identifier *&s) { lst.append (s); }
-  void append (tree_identifier * const &s) { lst.append (s); }
-
-  tree_identifier *&operator () (Pix p) { return lst (p); }
-
-  tree_identifier * const &operator () (Pix p) const { return lst (p); }
-
-  Pix first (void) const { return lst.first (); }
-
-  void next (Pix& p) const { return lst.next (p); }
-
   void mark_as_formal_parameters (void);
 
   void mark_varargs (void) { marked_for_varargs = 1; }
 
   bool takes_varargs (void) const { return marked_for_varargs != 0; }
 
   void mark_varargs_only (void) { marked_for_varargs = -1; }
 
   bool varargs_only (void) { return (marked_for_varargs < 0); }
 
   void initialize_undefined_elements (octave_value& val);
 
   void define_from_arg_vector (const octave_value_list& args);
 
-  void clear (void);
+  void undefine (void);
 
   bool is_defined (void);
 
   octave_value_list convert_to_const_vector (tree_va_return_list *vr_list);
 
   void accept (tree_walker& tw);
 
 private:
 
-  // The list of identifiers in the parameter list.
-  SLList<tree_identifier *> lst;
-
   int marked_for_varargs;
 
   // No copying!
 
   tree_parameter_list (const tree_parameter_list&);
 
   tree_parameter_list& operator = (const tree_parameter_list&);
 };
 
 // Return lists.  Used to hold the right hand sides of multiple
 // assignment expressions.
 
 class
-tree_return_list
+tree_return_list : public octave_base_list<tree_index_expression *>
 {
 public:
 
-  tree_return_list (void)
-    : lst () { }
+  tree_return_list (void) { }
 
-  tree_return_list (tree_index_expression *t)
-    : lst () { lst.append (t); }
+  tree_return_list (tree_index_expression *t) { append (t); }
 
   ~tree_return_list (void);
 
-  void append (tree_index_expression *&s) { lst.append (s); }
-  void append (tree_index_expression * const &s) { lst.append (s); }
-
-  tree_index_expression *&operator () (Pix p) { return lst (p); }
-
-  tree_index_expression * const &operator () (Pix p) const { return lst (p); }
-
-  Pix first (void) const { return lst.first (); }
-
-  void next (Pix& p) const { return lst.next (p); }
-
   void accept (tree_walker& tw);
 
 private:
 
-  // The list of expressions in the return list.
-  SLList<tree_index_expression *> lst;
-
   // No copying!
 
   tree_return_list (const tree_return_list&);
 
   tree_return_list& operator = (const tree_return_list&);
 };
 
 class
-tree_va_return_list
+tree_va_return_list : public octave_base_list<octave_value>
 {
 public:
 
-  tree_va_return_list (void) : lst () { }
+  tree_va_return_list (void) { }
 
   ~tree_va_return_list (void) { }
 
-  int length (void) const { return lst.length (); }
-
-  void clear (void) { lst.clear (); }
-
-  int empty (void) const { return lst.empty (); }
-
-  void append (octave_value& s) { lst.append (s); }
-  void append (const octave_value& s) { lst.append (s); }
-
-  octave_value& operator () (Pix p) { return lst (p); }
-
-  const octave_value& operator () (Pix p) const { return lst (p); }
-
-  Pix first (void) const { return lst.first (); }
-
-  void next (Pix& p) const { return lst.next (p); }
-
 private:
 
-  // The list of values in the va return list.
-  SLList<octave_value> lst;
-
   // No copying!
 
   tree_va_return_list (const tree_va_return_list&);
 
   tree_va_return_list& operator = (const tree_va_return_list&);
 };
 
 #endif
diff --git a/src/pt-plot.cc b/src/pt-plot.cc
--- a/src/pt-plot.cc
+++ b/src/pt-plot.cc
@@ -810,37 +810,28 @@ subplot::print (int ndim, OSSTREAM& plot
 }
 
 void
 subplot::accept (tree_walker& tw)
 {
   tw.visit_subplot (*this);
 }
 
-subplot_list::~subplot_list (void)
-{
-  while (! lst.empty ())
-    {
-      subplot *t = lst.remove_front ();
-      delete t;
-    }
-}
-
 int
 subplot_list::print (int ndim, OSSTREAM& plot_buf)
 {
   int status = 0;
 
-  for (Pix p = lst.first (); p != 0; lst.next (p))
+  for (iterator p = begin (); p != end (); p++)
     {
-      subplot *elt = lst (p);
+      subplot *elt = *p;
 
       plot_line_count++;
 
-      if (p != first ())
+      if (p != begin ())
 	plot_buf << ",\\\n  ";
 
       status = elt->print (ndim, plot_buf);
 
       if (status < 0)
 	break;
     }
 
diff --git a/src/pt-plot.h b/src/pt-plot.h
--- a/src/pt-plot.h
+++ b/src/pt-plot.h
@@ -40,20 +40,19 @@ class subplot_style;
 class subplot_axes;
 class subplot;
 class subplot_list;
 
 class tree_walker;
 
 #include <string>
 
-#include <SLList.h>
-
 #include "dColVector.h"
 
+#include "base-list.h"
 #include "pt-cmd.h"
 
 class
 tree_plot_command : public tree_command
 {
 public:
 
   tree_plot_command (subplot_list *plt = 0, plot_limits *rng = 0, int nd = 0)
@@ -391,48 +390,40 @@ private:
   // No copying!
 
   subplot (const subplot&);
 
   subplot& operator = (const subplot&);
 };
 
 class
-subplot_list
+subplot_list : public octave_base_list<subplot *>
 {
 public:
 
-  subplot_list (void)
-    : lst () { }
+  subplot_list (void) { }
 
-  subplot_list (subplot *t)
-    : lst () { lst.append (t); }
-
-  ~subplot_list (void);
+  subplot_list (subplot *t) { append (t); }
 
-  void append (subplot *&s) { lst.append (s); }
-  void append (subplot * const &s) { lst.append (s); }
-
-  subplot *&operator () (Pix p) { return lst (p); }
-
-  subplot * const &operator () (Pix p) const { return lst (p); }
-
-  Pix first (void) const { return lst.first (); }
-
-  void next (Pix& p) const { return lst.next (p); }
+  ~subplot_list (void)
+    {
+      while (! empty ())
+	{
+	  iterator p = begin ();
+	  delete *p;
+	  erase (p);
+	}
+    }
 
   int print (int ndim, OSSTREAM& plot_buf);
 
   void accept (tree_walker& tw);
 
 private:
 
-  // The list of subplot commands.
-  SLList<subplot *> lst;
-
   // No copying!
 
   subplot_list (const subplot_list&);
 
   subplot_list& operator = (const subplot_list&);
 };
 
 extern std::string save_in_tmp_file (octave_value& t, int ndim = 2,
diff --git a/src/pt-pr-code.cc b/src/pt-pr-code.cc
--- a/src/pt-pr-code.cc
+++ b/src/pt-pr-code.cc
@@ -36,29 +36,27 @@ Software Foundation, 59 Temple Place - S
 #include "error.h"
 #include "ov-usr-fcn.h"
 #include "pr-output.h"
 #include "pt-all.h"
 
 void
 tree_print_code::visit_argument_list (tree_argument_list& lst)
 {
-  Pix p = lst.first ();
+  tree_argument_list::iterator p = lst.begin ();
 
-  while (p)
+  while (p != lst.end ())
     {
-      tree_expression *elt = lst (p);
-
-      lst.next (p);
+      tree_expression *elt = *p++;
 
       if (elt)
 	{
 	  elt->accept (*this);
 
-	  if (p)
+	  if (p != lst.end ())
 	    os << ", ";
 	}
     }
 }
 
 void
 tree_print_code::visit_binary_expression (tree_binary_expression& expr)
 {
@@ -159,29 +157,27 @@ tree_print_code::visit_decl_elt (tree_de
 
       expr->accept (*this);
     }
 }
 
 void
 tree_print_code::visit_decl_init_list (tree_decl_init_list& lst)
 {
-  Pix p = lst.first ();
+  tree_decl_init_list::iterator p = lst.begin ();
 
-  while (p)
+  while (p != lst.end ())
     {
-      tree_decl_elt *elt = lst (p);
-
-      lst.next (p);
+      tree_decl_elt *elt = *p++;
 
       if (elt)
 	{
 	  elt->accept (*this);
 
-	  if (p)
+	  if (p != lst.end ())
 	    os << ", ";
 	}
     }
 }
 
 void
 tree_print_code::visit_simple_for_command (tree_simple_for_command& cmd)
 {
@@ -431,23 +427,23 @@ tree_print_code::visit_if_command (tree_
   indent ();
 
   os << "endif";
 }
 
 void
 tree_print_code::visit_if_command_list (tree_if_command_list& lst)
 {
-  Pix p = lst.first ();
+  tree_if_command_list::iterator p = lst.begin ();
 
   bool first_elt = true;
 
-  while (p)
+  while (p != lst.end ())
     {
-      tree_if_clause *elt = lst (p);
+      tree_if_clause *elt = *p++;
 
       if (elt)
 	{
 	  if (! first_elt)
 	    {
 	      print_indented_comment (elt->leading_comment ());
 
 	      indent ();
@@ -457,17 +453,16 @@ tree_print_code::visit_if_command_list (
 	      else
 		os << "elseif ";
 	    }
 
 	  elt->accept (*this);
 	}
 
       first_elt = false;
-      lst.next (p);
     }
 }
 
 void
 tree_print_code::visit_index_expression (tree_index_expression& expr)
 {
   indent ();
 
@@ -479,90 +474,88 @@ tree_print_code::visit_index_expression 
 
   if (e)
     {
       e->accept (*this);
 
       expr_has_parens = e->is_postfix_indexed ();
     }
 
-  SLList<tree_argument_list *> arg_lists = expr.arg_lists ();
+  std::list<tree_argument_list *> arg_lists = expr.arg_lists ();
   std::string type_tags = expr.type_tags ();
-  SLList<string_vector> arg_names = expr.arg_names ();
+  std::list<string_vector> arg_names = expr.arg_names ();
 
   int n = type_tags.length ();
 
-  Pix arg_lists_p = arg_lists.first ();
-  Pix arg_names_p = arg_names.first ();
+  std::list<tree_argument_list *>::iterator p_arg_lists = arg_lists.begin ();
+  std::list<string_vector>::iterator p_arg_names = arg_names.begin ();
 
   for (int i = 0; i < n; i++)
     {
       switch (type_tags[i])
 	{
 	case '(':
 	  {
 	    os << " (";
-	    tree_argument_list *l = arg_lists (arg_lists_p);
+	    tree_argument_list *l = *p_arg_lists;
 	    if (l)
 	      l->accept (*this);
 	    os << ")";
 	  }
 	  break;
 	    
 	case '{':
 	  {
 	    os << " {";
-	    tree_argument_list *l = arg_lists (arg_lists_p);
+	    tree_argument_list *l = *p_arg_lists;
 	    if (l)
 	      l->accept (*this);
 	    os << "}";
 	  }
 	  break;
 	    
 	case '.':
 	  {
-	    string_vector nm = arg_names (arg_names_p);
+	    string_vector nm = *p_arg_names;
 	    assert (nm.length () == 1);
 	    os << "." << nm(0);
 	  }
 	  break;
 
 	default:
 	  panic_impossible ();
 	}
 
-      arg_lists.next (arg_lists_p);
-      arg_names.next (arg_names_p);
+      p_arg_lists++;
+      p_arg_names++;
     }
 
   print_parens (expr, ")");
 }
 
 void
 tree_print_code::visit_matrix (tree_matrix& lst)
 {
   indent ();
 
   print_parens (lst, "(");
 
   os << "[";
 
-  Pix p = lst.first ();
+  tree_matrix::iterator p = lst.begin ();
 
-  while (p)
+  while (p != lst.end ())
     {
-      tree_argument_list *elt = lst (p);
-
-      lst.next (p);
+      tree_argument_list *elt = *p++;
 
       if (elt)
 	{
 	  elt->accept (*this);
 
-	  if (p)
+	  if (p != lst.end ())
 	    os << "; ";
 	}
     }
 
   os << "]";
 
   print_parens (lst, ")");
 }
@@ -571,29 +564,27 @@ void
 tree_print_code::visit_cell (tree_cell& lst)
 {
   indent ();
 
   print_parens (lst, "(");
 
   os << "{";
 
-  Pix p = lst.first ();
+  tree_cell::iterator p = lst.begin ();
 
-  while (p)
+  while (p != lst.end ())
     {
-      tree_argument_list *elt = lst (p);
-
-      lst.next (p);
+      tree_argument_list *elt = *p++;
 
       if (elt)
 	{
 	  elt->accept (*this);
 
-	  if (p)
+	  if (p != lst.end ())
 	    os << "; ";
 	}
     }
 
   os << "}";
 
   print_parens (lst, ")");
 }
@@ -648,29 +639,27 @@ tree_print_code::visit_constant (tree_co
   val.print_raw (os, true, print_original_text);
 
   print_parens (val, ")");
 }
 
 void
 tree_print_code::visit_parameter_list (tree_parameter_list& lst)
 {
-  Pix p = lst.first ();
+  tree_parameter_list::iterator p = lst.begin ();
 
-  while (p)
+  while (p != lst.end ())
     {
-      tree_identifier *elt = lst (p);
-
-      lst.next (p);
+      tree_identifier *elt = *p++;
 
       if (elt)
 	{
 	  elt->accept (*this);
 
-	  if (p)
+	  if (p != lst.end ())
 	    os << ", ";
 	}
     }
 }
 
 void
 tree_print_code::visit_plot_command (tree_plot_command& cmd)
 {
@@ -787,29 +776,27 @@ tree_print_code::visit_return_command (t
   indent ();
 
   os << "return";
 }
 
 void
 tree_print_code::visit_return_list (tree_return_list& lst)
 {
-  Pix p = lst.first ();
+  tree_return_list::iterator p = lst.begin ();
 
-  while (p)
+  while (p != lst.end ())
     {
-      tree_index_expression *elt = lst (p);
-
-      lst.next (p);
+      tree_index_expression *elt = *p++;
 
       if (elt)
 	{
 	  elt->accept (*this);
 
-	  if (p)
+	  if (p != lst.end ())
 	    os << ", ";
 	}
     }
 }
 
 void
 tree_print_code::visit_simple_assignment (tree_simple_assignment& expr)
 {
@@ -862,19 +849,19 @@ tree_print_code::visit_statement (tree_s
 	  newline ();
 	}
     }
 }
 
 void
 tree_print_code::visit_statement_list (tree_statement_list& lst)
 {
-  for (Pix p = lst.first (); p != 0; lst.next (p))
+  for (tree_statement_list::iterator p = lst.begin (); p != lst.end (); p++)
     {
-      tree_statement *elt = lst (p);
+      tree_statement *elt = *p;
 
       if (elt)
 	elt->accept (*this);
     }
 }
 
 void
 tree_print_code::visit_subplot (subplot& cmd)
@@ -913,29 +900,27 @@ void
 tree_print_code::visit_subplot_axes (subplot_axes& cmd)
 {
   os << " axes " << cmd.axes ();
 }
 
 void
 tree_print_code::visit_subplot_list (subplot_list& lst)
 {
-  Pix p = lst.first ();
+  subplot_list::iterator p = lst.begin ();
 
-  while (p)
+  while (p != lst.end ())
     {
-      subplot *elt = lst (p);
-
-      lst.next (p);
+      subplot *elt = *p++;
 
       if (elt)
 	{
 	  elt->accept (*this);
 
-	  if (p)
+	  if (p != lst.end ())
 	    os << ",";
 	}
     }
 }
 
 void
 tree_print_code::visit_subplot_style (subplot_style& cmd)
 {
@@ -1020,26 +1005,24 @@ tree_print_code::visit_switch_case (tree
 
       decrement_indent_level ();
     }
 }
 
 void
 tree_print_code::visit_switch_case_list (tree_switch_case_list& lst)
 {
-  Pix p = lst.first ();
+  tree_switch_case_list::iterator p = lst.begin ();
 
-  while (p)
+  while (p != lst.end ())
     {
-      tree_switch_case *elt = lst (p);
+      tree_switch_case *elt = *p++;
 
       if (elt)
 	elt->accept (*this);
-
-      lst.next (p);
     }
 }
 
 void
 tree_print_code::visit_switch_command (tree_switch_command& cmd)
 {
   print_comment_list (cmd.leading_comment ());
 
@@ -1342,27 +1325,25 @@ tree_print_code::print_comment_elt (cons
     newline ();
 }
 
 void
 tree_print_code::print_comment_list (octave_comment_list *comment_list)
 {
   if (comment_list)
     {
-      Pix p = comment_list->first ();
+      octave_comment_list::iterator p = comment_list->begin ();
 
-      while (p)
+      while (p != comment_list->end ())
 	{
-	  octave_comment_elt elt = comment_list->operator () (p);
+	  octave_comment_elt elt = *p++;
 
 	  print_comment_elt (elt);
 
-	  comment_list->next (p);
-
-	  if (p)
+	  if (p != comment_list->end ())
 	    newline ();
 	}
     }
 }
 
 void
 tree_print_code::print_indented_comment (octave_comment_list *comment_list)
 {
diff --git a/src/pt-select.cc b/src/pt-select.cc
--- a/src/pt-select.cc
+++ b/src/pt-select.cc
@@ -68,19 +68,19 @@ tree_if_clause::accept (tree_walker& tw)
   tw.visit_if_clause (*this);
 }
 
 // List of if commands.
 
 void
 tree_if_command_list::eval (void)
 {
-  for (Pix p = lst.first (); p != 0; lst.next (p))
+  for (iterator p = begin (); p != end (); p++)
     {
-      tree_if_clause *t = lst (p);
+      tree_if_clause *t = *p;
 
       if (t->eval () || error_state)
 	break;
     }
 }
 
 void
 tree_if_command_list::accept (tree_walker& tw)
@@ -225,19 +225,19 @@ tree_switch_case::accept (tree_walker& t
   tw.visit_switch_case (*this);
 }
 
 // List of switch cases.
 
 void
 tree_switch_case_list::eval (const octave_value& val)
 {
-  for (Pix p = lst.first (); p != 0; lst.next (p))
+  for (iterator p = begin (); p != end (); p++)
     {
-      tree_switch_case *t = lst (p);
+      tree_switch_case *t = *p;
 
       if (t->eval (val) || error_state)
 	break;
     }
 }
 
 void
 tree_switch_case_list::accept (tree_walker& tw)
diff --git a/src/pt-select.h b/src/pt-select.h
--- a/src/pt-select.h
+++ b/src/pt-select.h
@@ -22,23 +22,22 @@ Software Foundation, 59 Temple Place - S
 
 #if !defined (octave_tree_select_h)
 #define octave_tree_select_h 1
 
 #if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
 #pragma interface
 #endif
 
-#include <SLList.h>
-
 class expression;
 class tree_statement_list;
 
 class tree_walker;
 
+#include "base-list.h"
 #include "comment-list.h"
 #include "pt-cmd.h"
 
 // If.
 
 class
 tree_if_clause
 {
@@ -83,55 +82,40 @@ private:
   // No copying!
 
   tree_if_clause (const tree_if_clause&);
 
   tree_if_clause& operator = (const tree_if_clause&);
 };
 
 class
-tree_if_command_list
+tree_if_command_list : public octave_base_list<tree_if_clause *>
 {
 public:
 
-  tree_if_command_list (void)
-    : lst () { }
+  tree_if_command_list (void) { }
 
-  tree_if_command_list (tree_if_clause *t)
-    : lst () { lst.append (t); }
+  tree_if_command_list (tree_if_clause *t) { append (t); }
 
   ~tree_if_command_list (void)
     {
-      while (! lst.empty ())
+      while (! empty ())
 	{
-	  tree_if_clause *t = lst.remove_front ();
-	  delete t;
+	  iterator p = begin ();
+	  delete *p;
+	  erase (p);
 	}
     }
 
-  void append (tree_if_clause *&s) { lst.append (s); }
-  void append (tree_if_clause * const &s) { lst.append (s); }
-
-  tree_if_clause *&operator () (Pix p) { return lst (p); }
-
-  tree_if_clause * const &operator () (Pix p) const { return lst (p); }
-
-  Pix first (void) const { return lst.first (); }
-
-  void next (Pix& p) const { return lst.next (p); }
-
   void eval (void);
 
   void accept (tree_walker& tw);
 
 private:
 
-  // The list of if/elseif clauses.
-  SLList<tree_if_clause *> lst;
-
   // No copying!
 
   tree_if_command_list (const tree_if_command_list&);
 
   tree_if_command_list& operator = (const tree_if_command_list&);
 };
 
 class
@@ -225,55 +209,40 @@ private:
   // No copying!
 
   tree_switch_case (const tree_switch_case&);
 
   tree_switch_case& operator = (const tree_switch_case&);
 };
 
 class
-tree_switch_case_list
+tree_switch_case_list : public octave_base_list<tree_switch_case *>
 {
 public:
 
-  tree_switch_case_list (void)
-    : lst () { }
+  tree_switch_case_list (void) { }
 
-  tree_switch_case_list (tree_switch_case *t)
-    : lst () { lst.append (t); }
+  tree_switch_case_list (tree_switch_case *t) { append (t); }
 
   ~tree_switch_case_list (void)
     {
-      while (! lst.empty ())
+      while (! empty ())
 	{
-	  tree_switch_case *t = lst.remove_front ();
-	  delete t;
+	  iterator p = begin ();
+	  delete *p;
+	  erase (p);
 	}
     }
 
-  void append (tree_switch_case *&s) { lst.append (s); }
-  void append (tree_switch_case * const &s) { lst.append (s); }
-
-  tree_switch_case *&operator () (Pix p) { return lst (p); }
-
-  tree_switch_case * const &operator () (Pix p) const { return lst (p); }
-
-  Pix first (void) const { return lst.first (); }
-
-  void next (Pix& p) const { return lst.next (p); }
-
   void eval (const octave_value& val);
 
   void accept (tree_walker& tw);
 
 private:
 
-  // The list of switch cases.
-  SLList<tree_switch_case *> lst;
-
   // No copying!
 
   tree_switch_case_list (const tree_switch_case_list&);
 
   tree_switch_case_list& operator = (const tree_switch_case_list&);
 };
 
 class
diff --git a/src/pt-stmt.cc b/src/pt-stmt.cc
--- a/src/pt-stmt.cc
+++ b/src/pt-stmt.cc
@@ -23,18 +23,16 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <SLList.h>
-
 #include "quit.h"
 
 #include "defun.h"
 #include "error.h"
 #include "ov.h"
 #include "oct-lvalue.h"
 #include "input.h"
 #include "pager.h"
@@ -154,19 +152,19 @@ tree_statement::accept (tree_walker& tw)
 octave_value_list
 tree_statement_list::eval (bool silent, int nargout)
 {
   octave_value_list retval;
 
   if (error_state)
     return retval;
 
-  for (Pix p = lst.first (); p != 0; lst.next (p))
+  for (iterator p = begin (); p != end (); p++)
     {
-      tree_statement *elt = lst (p);
+      tree_statement *elt = *p;
 
       if (elt)
 	{
 	  OCTAVE_QUIT;
 
 	  retval = elt->eval (silent, nargout, function_body);
 
 	  if (error_state)
diff --git a/src/pt-stmt.h b/src/pt-stmt.h
--- a/src/pt-stmt.h
+++ b/src/pt-stmt.h
@@ -22,25 +22,24 @@ Software Foundation, 59 Temple Place - S
 
 #if !defined (octave_tree_stmt_h)
 #define octave_tree_stmt_h 1
 
 #if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
 #pragma interface
 #endif
 
-#include <SLList.h>
-
 class octave_value_list;
 
 class tree_command;
 class tree_expression;
 
 class tree_walker;
 
+#include "base-list.h"
 #include "comment-list.h"
 
 // A statement is either a command to execute or an expression to
 // evaluate.
 
 class
 tree_statement
 {
@@ -100,69 +99,50 @@ private:
   tree_statement (const tree_statement&);
 
   tree_statement& operator = (const tree_statement&);
 };
 
 // A list of statements to evaluate.
 
 class
-tree_statement_list
+tree_statement_list : public octave_base_list<tree_statement *>
 {
 public:
 
   tree_statement_list (void)
-    : lst (), function_body (false) { }
+    : function_body (false) { }
 
   tree_statement_list (tree_statement *s)
-    : lst (), function_body (false) { lst.append (s); }
+    : function_body (false) { append (s); }
 
   ~tree_statement_list (void)
     {
-      while (! lst.empty ())
+      while (! empty ())
 	{
-	  tree_statement *t = lst.remove_front ();
-	  delete t;
+	  iterator p = begin ();
+	  delete *p;
+	  erase (p);
 	}
     }
 
-  void append (tree_statement *&s) { lst.append (s); }
-  void append (tree_statement * const &s) { lst.append (s); }
-
-  tree_statement *&operator () (Pix p) { return lst (p); }
-
-  tree_statement * const &operator () (Pix p) const { return lst (p); }
-
-  Pix first (void) const { return lst.first (); }
-
-  void next (Pix& p) const { return lst.next (p); }
-
-  tree_statement *front (void) { return lst.front (); }
-  tree_statement *rear (void) { return lst.rear (); }
-
-  const tree_statement *front (void) const { return lst.front (); }
-  const tree_statement *rear (void) const { return lst.rear (); }
-
   void mark_as_function_body (void) { function_body = true; }
 
   octave_value_list eval (bool silent = false, int nargout = 0);
 
   int set_breakpoint (int line);
 
   void delete_breakpoint (int line);
 
   octave_value_list list_breakpoints (void);
 
   void accept (tree_walker& tw);
 
 private:
 
-  // List of statements to evaluate.
-  SLList<tree_statement *> lst;
-
   // Does this list of statements make up the body of a function?
   bool function_body;
 
   // No copying!
 
   tree_statement_list (const tree_statement_list&);
 
   tree_statement_list& operator = (const tree_statement_list&);
