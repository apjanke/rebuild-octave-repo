# HG changeset patch
# User Rik <rik@octave.org>
# Date 1497327503 25200
#      Mon Jun 12 21:18:23 2017 -0700
# Node ID c3075ae020e1c0477a0e466588377db2ac7fc2cb
# Parent  2230f9e10fb36acd1c21f9f7d864612b3563bbd2
maint: Deprecate is_complex_type and replace with iscomplex.

* ov.h (is_complex_type): Use OCTAVE_DEPRECATED macro around function.
* ov.h (iscomplex): New function.

* __ichol__.cc, __ilu__.cc, balance.cc, bsxfun.cc, cellfun.cc, conv2.cc,
daspk.cc, dasrt.cc, dassl.cc, data.cc, det.cc, dot.cc, fft.cc, fft2.cc,
fftn.cc, filter.cc, find.cc, givens.cc, graphics.cc, gsvd.cc, hess.cc,
hex2num.cc, inv.cc, kron.cc, lookup.cc, ls-mat-ascii.cc, ls-mat4.cc,
ls-mat5.cc, lsode.cc, lu.cc, matrix_type.cc, mex.cc, mgorth.cc, ordschur.cc,
pinv.cc, psi.cc, quad.cc, qz.cc, rcond.cc, schur.cc, sparse-xpow.cc, sparse.cc,
sqrtm.cc, svd.cc, sylvester.cc, symtab.cc, typecast.cc, variables.cc, xnorm.cc,
__eigs__.cc, amd.cc, ccolamd.cc, chol.cc, colamd.cc, qr.cc, symbfact.cc,
ov-base.h, ov-complex.h, ov-cx-diag.h, ov-cx-mat.h, ov-cx-sparse.h,
ov-flt-complex.h, ov-flt-cx-diag.h, ov-flt-cx-mat.h, jit-typeinfo.cc,
pt-tm-const.cc: Replace instances of is_complex_type with iscomplex.

diff --git a/libinterp/corefcn/__ichol__.cc b/libinterp/corefcn/__ichol__.cc
--- a/libinterp/corefcn/__ichol__.cc
+++ b/libinterp/corefcn/__ichol__.cc
@@ -190,17 +190,17 @@ Undocumented internal function.
   if (args.length () != 2)
     print_usage ();
 
   std::string michol = args(1).string_value ();
 
   // In ICHOL0 algorithm the zero-pattern of the input matrix is preserved
   // so its structure does not change during the algorithm.  The same input
   // matrix is used to build the output matrix due to that fact.
-  if (! args(0).is_complex_type ())
+  if (! args(0).iscomplex ())
     {
       SparseMatrix sm = Ftril (args(0))(0).sparse_matrix_value ();
       ichol_0 <SparseMatrix, double, ichol_mult_real,
                ichol_checkpivot_real> (sm, michol);
       return ovl (sm);
     }
   else
     {
@@ -417,17 +417,17 @@ Undocumented internal function.
 @end deftypefn */)
 {
   if (args.length () != 3)
     print_usage ();
 
   double droptol = args(1).double_value ();
   std::string michol = args(2).string_value ();
 
-  if (! args(0).is_complex_type ())
+  if (! args(0).iscomplex ())
     {
       SparseMatrix L;
       SparseMatrix sm_l = Ftril (args(0))(0).sparse_matrix_value ();
       ichol_t <SparseMatrix,
                double, ichol_mult_real, ichol_checkpivot_real>
                (sm_l, L, xcolnorms (sm_l, 1).fortran_vec (), droptol, michol);
 
       return ovl (L);
diff --git a/libinterp/corefcn/__ilu__.cc b/libinterp/corefcn/__ilu__.cc
--- a/libinterp/corefcn/__ilu__.cc
+++ b/libinterp/corefcn/__ilu__.cc
@@ -148,17 +148,17 @@ Undocumented internal function.
   octave_value_list retval (2);
 
   std::string milu = args(1).string_value ();
 
   // In ILU0 algorithm the zero-pattern of the input matrix is preserved so
   // its structure does not change during the algorithm.  The same input
   // matrix is used to build the output matrix due to that fact.
   octave_value_list arg_list;
-  if (! args(0).is_complex_type ())
+  if (! args(0).iscomplex ())
     {
       SparseMatrix sm = args(0).sparse_matrix_value ();
       SparseMatrix speye (DiagMatrix (sm.cols (), sm.cols (), 1.0));
 
       ilu_0 <SparseMatrix, double> (sm, milu);
 
       retval(0) = speye + Ftril (ovl (sm, -1))(0).sparse_matrix_value ();
       retval(1) = Ftriu (ovl (sm))(0).sparse_matrix_value ();
@@ -467,17 +467,17 @@ Undocumented internal function.
 @end deftypefn */)
 {
   if (args.length () != 3)
     print_usage ();
 
   double droptol = args(1).double_value ();
   std::string milu = args(2).string_value ();
 
-  if (! args(0).is_complex_type ())
+  if (! args(0).iscomplex ())
     {
       SparseMatrix sm = args(0).sparse_matrix_value ();
       SparseMatrix sm_u = Ftriu (ovl (sm))(0).sparse_matrix_value ();
       SparseMatrix sm_l = Ftril (ovl (sm, -1))(0).sparse_matrix_value ();
       SparseMatrix U, L;
 
       ilu_crout <SparseMatrix, double> (sm_l, sm_u, L, U,
                                         xcolnorms (sm).fortran_vec (),
@@ -908,17 +908,17 @@ Undocumented internal function.
   octave_value_list retval;
   double droptol = args(1).double_value ();
   double thresh = args(2).double_value ();
   std::string milu = args(3).string_value ();
   double udiag = args(4).double_value ();
 
   octave_value_list arg_list;
   octave_idx_type nnz_u, nnz_l;
-  if (! args(0).is_complex_type ())
+  if (! args(0).iscomplex ())
     {
       SparseMatrix sm = args(0).sparse_matrix_value ();
       SparseMatrix U, L;
       nnz_u = (Ftriu (ovl (sm))(0).sparse_matrix_value ()).nnz ();
       nnz_l = (Ftril (ovl (sm, -1))(0).sparse_matrix_value ()).nnz ();
       Array <double> rc_norm;
       if (milu == "row")
         rc_norm = xrownorms (sm);
diff --git a/libinterp/corefcn/balance.cc b/libinterp/corefcn/balance.cc
--- a/libinterp/corefcn/balance.cc
+++ b/libinterp/corefcn/balance.cc
@@ -103,18 +103,18 @@ Generalized eigenvalue problem balancing
   octave_idx_type nn = args(0).rows ();
 
   if (nn != args(0).columns ())
     err_square_matrix_required ("balance", "A");
 
   bool isfloat = args(0).is_single_type ()
                  || (! AEPcase && args(1).is_single_type ());
 
-  bool complex_case = args(0).is_complex_type ()
-                      || (! AEPcase && args(1).is_complex_type ());
+  bool complex_case = args(0).iscomplex ()
+                      || (! AEPcase && args(1).iscomplex ());
 
   // Extract argument 1 parameter for both AEP and GEP.
   Matrix aa;
   ComplexMatrix caa;
   FloatMatrix faa;
   FloatComplexMatrix fcaa;
 
   if (isfloat)
diff --git a/libinterp/corefcn/bsxfun.cc b/libinterp/corefcn/bsxfun.cc
--- a/libinterp/corefcn/bsxfun.cc
+++ b/libinterp/corefcn/bsxfun.cc
@@ -541,17 +541,17 @@ dimensionality as the other array.
                             {
                               have_FloatComplexNDArray = false;
                               C = result_FloatComplexNDArray;
                             }
                           C = do_cat_op (C, tmp(0), ra_idx);
                         }
                       else if (tmp(0).is_double_type ())
                         {
-                          if (tmp(0).is_complex_type ()
+                          if (tmp(0).iscomplex ()
                               && have_FloatNDArray)
                             {
                               result_ComplexNDArray =
                                 ComplexNDArray (result_FloatNDArray);
                               result_ComplexNDArray.insert
                                 (tmp(0).complex_array_value (), ra_idx);
                               have_FloatComplexNDArray = false;
                               have_ComplexNDArray = true;
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -1802,17 +1802,17 @@ num2cell ([1,2;3,4],1)
             retval = do_num2cell (array.uint8_array_value (), dimv);
           else if (array.is_uint16_type ())
             retval = do_num2cell (array.uint16_array_value (), dimv);
           else if (array.is_uint32_type ())
             retval = do_num2cell (array.uint32_array_value (), dimv);
           else if (array.is_uint64_type ())
             retval = do_num2cell (array.uint64_array_value (), dimv);
         }
-      else if (array.is_complex_type ())
+      else if (array.iscomplex ())
         {
           if (array.is_single_type ())
             retval = do_num2cell (array.float_complex_array_value (), dimv);
           else
             retval = do_num2cell (array.complex_array_value (), dimv);
         }
       else
         {
@@ -2299,17 +2299,17 @@ slicing is done along the first non-sing
                                          lb, ub, dim);
           else if (x.is_uint32_type ())
             retcell = do_cellslices_nda (x.uint32_array_value (),
                                          lb, ub, dim);
           else if (x.is_uint64_type ())
             retcell = do_cellslices_nda (x.uint64_array_value (),
                                          lb, ub, dim);
         }
-      else if (x.is_complex_type ())
+      else if (x.iscomplex ())
         {
           if (x.is_single_type ())
             retcell = do_cellslices_nda (x.float_complex_array_value (),
                                          lb, ub, dim);
           else
             retcell = do_cellslices_nda (x.complex_array_value (),
                                          lb, ub, dim);
         }
diff --git a/libinterp/corefcn/conv2.cc b/libinterp/corefcn/conv2.cc
--- a/libinterp/corefcn/conv2.cc
+++ b/libinterp/corefcn/conv2.cc
@@ -105,18 +105,18 @@ When the third argument is a matrix, ret
       // If user requests separable, check first two params are vectors
       if (! (1 == args(0).rows () || 1 == args(0).columns ())
           || ! (1 == args(1).rows () || 1 == args(1).columns ()))
         error ("conv2: arguments must be vectors for separable option");
 
       if (args(0).is_single_type () || args(1).is_single_type ()
           || args(2).is_single_type ())
         {
-          if (args(0).is_complex_type () || args(1).is_complex_type ()
-              || args(2).is_complex_type ())
+          if (args(0).iscomplex () || args(1).iscomplex ()
+              || args(2).iscomplex ())
             {
               FloatComplexMatrix a (args(2).float_complex_matrix_value ());
               if (args(1).is_real_type () && args(2).is_real_type ())
                 {
                   FloatColumnVector v1 (args(0).float_vector_value ());
                   FloatRowVector v2 (args(1).float_vector_value ());
                   retval = convn (a, v1, v2, ct);
                 }
@@ -132,18 +132,18 @@ When the third argument is a matrix, ret
               FloatColumnVector v1 (args(0).float_vector_value ());
               FloatRowVector v2 (args(1).float_vector_value ());
               FloatMatrix a (args(2).float_matrix_value ());
               retval = convn (a, v1, v2, ct);
             }
         }
       else
         {
-          if (args(0).is_complex_type () || args(1).is_complex_type ()
-              || args(2).is_complex_type ())
+          if (args(0).iscomplex () || args(1).iscomplex ()
+              || args(2).iscomplex ())
             {
               ComplexMatrix a (args(2).complex_matrix_value ());
               if (args(1).is_real_type () && args(2).is_real_type ())
                 {
                   ColumnVector v1 (args(0).vector_value ());
                   RowVector v2 (args(1).vector_value ());
                   retval = convn (a, v1, v2, ct);
                 }
@@ -162,17 +162,17 @@ When the third argument is a matrix, ret
               retval = convn (a, v1, v2, ct);
             }
         }
     } // if (separable)
   else
     {
       if (args(0).is_single_type () || args(1).is_single_type ())
         {
-          if (args(0).is_complex_type () || args(1).is_complex_type ())
+          if (args(0).iscomplex () || args(1).iscomplex ())
             {
               FloatComplexMatrix a (args(0).float_complex_matrix_value ());
               if (args(1).is_real_type ())
                 {
                   FloatMatrix b (args(1).float_matrix_value ());
                   retval = convn (a, b, ct);
                 }
               else
@@ -185,17 +185,17 @@ When the third argument is a matrix, ret
             {
               FloatMatrix a (args(0).float_matrix_value ());
               FloatMatrix b (args(1).float_matrix_value ());
               retval = convn (a, b, ct);
             }
         }
       else
         {
-          if (args(0).is_complex_type () || args(1).is_complex_type ())
+          if (args(0).iscomplex () || args(1).iscomplex ())
             {
               ComplexMatrix a (args(0).complex_matrix_value ());
               if (args(1).is_real_type ())
                 {
                   Matrix b (args(1).matrix_value ());
                   retval = convn (a, b, ct);
                 }
               else
@@ -327,17 +327,17 @@ The size of the result is @code{max (siz
     ct = convn_valid;
   else
     error ("convn: SHAPE type not valid");
 
   octave_value retval;
 
   if (args(0).is_single_type () || args(1).is_single_type ())
     {
-      if (args(0).is_complex_type () || args(1).is_complex_type ())
+      if (args(0).iscomplex () || args(1).iscomplex ())
         {
           FloatComplexNDArray a (args(0).float_complex_array_value ());
           if (args(1).is_real_type ())
             {
               FloatNDArray b (args(1).float_array_value ());
               retval = convn (a, b, ct);
             }
           else
@@ -350,17 +350,17 @@ The size of the result is @code{max (siz
         {
           FloatNDArray a (args(0).float_array_value ());
           FloatNDArray b (args(1).float_array_value ());
           retval = convn (a, b, ct);
         }
     }
   else
     {
-      if (args(0).is_complex_type () || args(1).is_complex_type ())
+      if (args(0).iscomplex () || args(1).iscomplex ())
         {
           ComplexNDArray a (args(0).complex_array_value ());
           if (args(1).is_real_type ())
             {
               NDArray b (args(1).array_value ());
               retval = convn (a, b, ct);
             }
           else
diff --git a/libinterp/corefcn/daspk.cc b/libinterp/corefcn/daspk.cc
--- a/libinterp/corefcn/daspk.cc
+++ b/libinterp/corefcn/daspk.cc
@@ -84,17 +84,17 @@ daspk_user_function (const ColumnVector&
         {
           err_user_supplied_eval (e, "daspk");
         }
 
       int tlen = tmp.length ();
       if (tlen == 0 || ! tmp(0).is_defined ())
         err_user_supplied_eval ("daspk");
 
-      if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
+      if (! warned_fcn_imaginary && tmp(0).iscomplex ())
         {
           warning ("daspk: ignoring imaginary part returned from user-supplied function");
           warned_fcn_imaginary = true;
         }
 
       retval = tmp(0).vector_value ();
 
       if (tlen > 1)
@@ -134,17 +134,17 @@ daspk_user_jacobian (const ColumnVector&
         {
           err_user_supplied_eval (e, "daspk");
         }
 
       int tlen = tmp.length ();
       if (tlen == 0 || ! tmp(0).is_defined ())
         err_user_supplied_eval ("daspk");
 
-      if (! warned_jac_imaginary && tmp(0).is_complex_type ())
+      if (! warned_jac_imaginary && tmp(0).iscomplex ())
         {
           warning ("daspk: ignoring imaginary part returned from user-supplied jacobian function");
           warned_jac_imaginary = true;
         }
 
       retval = tmp(0).matrix_value ();
 
       if (retval.isempty ())
diff --git a/libinterp/corefcn/dasrt.cc b/libinterp/corefcn/dasrt.cc
--- a/libinterp/corefcn/dasrt.cc
+++ b/libinterp/corefcn/dasrt.cc
@@ -82,17 +82,17 @@ dasrt_user_f (const ColumnVector& x, con
       catch (octave::execution_exception& e)
         {
           err_user_supplied_eval (e, "dasrt");
         }
 
       if (tmp.empty () || ! tmp(0).is_defined ())
         err_user_supplied_eval ("dasrt");
 
-      if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
+      if (! warned_fcn_imaginary && tmp(0).iscomplex ())
         {
           warning ("dasrt: ignoring imaginary part returned from user-supplied function");
           warned_fcn_imaginary = true;
         }
 
       retval = tmp(0).vector_value ();
 
       if (retval.isempty ())
@@ -123,17 +123,17 @@ dasrt_user_cf (const ColumnVector& x, do
       catch (octave::execution_exception& e)
         {
           err_user_supplied_eval (e, "dasrt");
         }
 
       if (tmp.empty () || ! tmp(0).is_defined ())
         err_user_supplied_eval ("dasrt");
 
-      if (! warned_cf_imaginary && tmp(0).is_complex_type ())
+      if (! warned_cf_imaginary && tmp(0).iscomplex ())
         {
           warning ("dasrt: ignoring imaginary part returned from user-supplied constraint function");
           warned_cf_imaginary = true;
         }
 
       retval = tmp(0).vector_value ();
 
       if (retval.isempty ())
@@ -170,17 +170,17 @@ dasrt_user_j (const ColumnVector& x, con
         {
           err_user_supplied_eval (e, "dasrt");
         }
 
       int tlen = tmp.length ();
       if (tlen == 0 || ! tmp(0).is_defined ())
         err_user_supplied_eval ("dasrt");
 
-      if (! warned_jac_imaginary && tmp(0).is_complex_type ())
+      if (! warned_jac_imaginary && tmp(0).iscomplex ())
         {
           warning ("dasrt: ignoring imaginary part returned from user-supplied jacobian function");
           warned_jac_imaginary = true;
         }
 
       retval = tmp(0).matrix_value ();
 
       if (retval.isempty ())
diff --git a/libinterp/corefcn/dassl.cc b/libinterp/corefcn/dassl.cc
--- a/libinterp/corefcn/dassl.cc
+++ b/libinterp/corefcn/dassl.cc
@@ -84,17 +84,17 @@ dassl_user_function (const ColumnVector&
         {
           err_user_supplied_eval (e, "dassl");
         }
 
       int tlen = tmp.length ();
       if (tlen == 0 || ! tmp(0).is_defined ())
         err_user_supplied_eval ("dassl");
 
-      if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
+      if (! warned_fcn_imaginary && tmp(0).iscomplex ())
         {
           warning ("dassl: ignoring imaginary part returned from user-supplied function");
           warned_fcn_imaginary = true;
         }
 
       retval = tmp(0).vector_value ();
 
       if (tlen > 1)
@@ -134,17 +134,17 @@ dassl_user_jacobian (const ColumnVector&
         {
           err_user_supplied_eval (e, "dassl");
         }
 
       int tlen = tmp.length ();
       if (tlen == 0 || ! tmp(0).is_defined ())
         err_user_supplied_eval ("dassl");
 
-      if (! warned_jac_imaginary && tmp(0).is_complex_type ())
+      if (! warned_jac_imaginary && tmp(0).iscomplex ())
         {
           warning ("dassl: ignoring imaginary part returned from user-supplied jacobian function");
           warned_jac_imaginary = true;
         }
 
       retval = tmp(0).matrix_value ();
 
       if (retval.isempty ())
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -221,17 +221,17 @@ This function is equivalent to @code{arg
   octave_value retval;
 
   if (! args(0).is_numeric_type ())
     err_wrong_type_arg ("atan2", args(0));
 
   if (! args(1).is_numeric_type ())
     err_wrong_type_arg ("atan2", args(1));
 
-  if (args(0).is_complex_type () || args(1).is_complex_type ())
+  if (args(0).iscomplex () || args(1).iscomplex ())
     error ("atan2: not defined for complex numbers");
 
   if (args(0).is_single_type () || args(1).is_single_type ())
     {
       if (args(0).is_scalar_type () && args(1).is_scalar_type ())
         retval = atan2f (args(0).float_value (), args(1).float_value ());
       else
         {
@@ -329,19 +329,19 @@ do_hypot (const octave_value& x, const o
 
   octave_value arg0 = x;
   octave_value arg1 = y;
   if (! arg0.is_numeric_type ())
     err_wrong_type_arg ("hypot", arg0);
   if (! arg1.is_numeric_type ())
     err_wrong_type_arg ("hypot", arg1);
 
-  if (arg0.is_complex_type ())
+  if (arg0.iscomplex ())
     arg0 = arg0.abs ();
-  if (arg1.is_complex_type ())
+  if (arg1.iscomplex ())
     arg1 = arg1.abs ();
 
   if (arg0.is_single_type () || arg1.is_single_type ())
     {
       if (arg0.is_scalar_type () && arg1.is_scalar_type ())
         retval = hypotf (arg0.float_value (), arg1.float_value ());
       else
         {
@@ -503,17 +503,17 @@ and @var{e} is an integer.  If
         {
           FloatNDArray f;
           FloatNDArray x = args(0).float_array_value ();
           // FIXME: should E be an int value?
           FloatMatrix e;
           map_2_xlog2 (x, f, e);
           retval = ovl (f, e);
         }
-      else if (args(0).is_complex_type ())
+      else if (args(0).iscomplex ())
         {
           FloatComplexNDArray f;
           FloatComplexNDArray x = args(0).float_complex_array_value ();
           // FIXME: should E be an int value?
           FloatNDArray e;
           map_2_xlog2 (x, f, e);
           retval = ovl (f, e);
         }
@@ -522,17 +522,17 @@ and @var{e} is an integer.  If
     {
       NDArray f;
       NDArray x = args(0).array_value ();
       // FIXME: should E be an int value?
       Matrix e;
       map_2_xlog2 (x, f, e);
       retval = ovl (f, e);
     }
-  else if (args(0).is_complex_type ())
+  else if (args(0).iscomplex ())
     {
       ComplexNDArray f;
       ComplexNDArray x = args(0).complex_array_value ();
       // FIXME: should E be an int value?
       NDArray e;
       map_2_xlog2 (x, f, e);
       retval = ovl (f, e);
     }
@@ -603,17 +603,17 @@ periodic, @code{mod} is a better choice.
   octave_value retval;
 
   if (! args(0).is_numeric_type ())
     err_wrong_type_arg ("rem", args(0));
 
   if (! args(1).is_numeric_type ())
     err_wrong_type_arg ("rem", args(1));
 
-  if (args(0).is_complex_type () || args(1).is_complex_type ())
+  if (args(0).iscomplex () || args(1).iscomplex ())
     error ("rem: not defined for complex numbers");
 
   if (args(0).isinteger () || args(1).isinteger ())
     {
       builtin_type_t btyp0 = args(0).builtin_type ();
       builtin_type_t btyp1 = args(1).builtin_type ();
       if (btyp0 == btyp_double || btyp0 == btyp_float)
         btyp0 = btyp1;
@@ -782,17 +782,17 @@ negative numbers or when the values are 
   octave_value retval;
 
   if (! args(0).is_numeric_type ())
     err_wrong_type_arg ("mod", args(0));
 
   if (! args(1).is_numeric_type ())
     err_wrong_type_arg ("mod", args(1));
 
-  if (args(0).is_complex_type () || args(1).is_complex_type ())
+  if (args(0).iscomplex () || args(1).iscomplex ())
     error ("mod: not defined for complex numbers");
 
   if (args(0).isinteger () || args(1).isinteger ())
     {
       builtin_type_t btyp0 = args(0).builtin_type ();
       builtin_type_t btyp1 = args(1).builtin_type ();
       if (btyp0 == btyp_double || btyp0 == btyp_float)
         btyp0 = btyp1;
@@ -942,17 +942,17 @@ negative numbers or when the values are 
         }                                                               \
       else                                                              \
         {                                                               \
           NDArray tmp = arg.array_value ();                             \
                                                                         \
           retval = tmp.FCN (dim);                                       \
         }                                                               \
     }                                                                   \
-  else if (arg.is_complex_type ())                                      \
+  else if (arg.iscomplex ())                                      \
     {                                                                   \
       if (arg.is_sparse_type ())                                        \
         {                                                               \
           SparseComplexMatrix tmp = arg.sparse_complex_matrix_value (); \
                                                                         \
           retval = tmp.FCN (dim);                                       \
         }                                                               \
       else if (arg.is_single_type ())                                   \
@@ -1795,17 +1795,17 @@ do_cat (const octave_value_list& xargs, 
           if (all_strings_p && ! args(i).is_string ())
             all_strings_p = false;
           if (all_sq_strings_p && ! args(i).is_sq_string ())
             all_sq_strings_p = false;
           if (all_dq_strings_p && ! args(i).is_dq_string ())
             all_dq_strings_p = false;
           if (all_real_p && ! args(i).is_real_type ())
             all_real_p = false;
-          if (all_cmplx_p && ! (args(i).is_complex_type ()
+          if (all_cmplx_p && ! (args(i).iscomplex ()
                                 || args(i).is_real_type ()))
             all_cmplx_p = false;
           if (! any_sparse_p && args(i).is_sparse_type ())
             any_sparse_p = true;
           if (! any_cell_p && args(i).iscell ())
             any_cell_p = true;
           if (! any_class_p && args(i).is_object ())
             any_class_p = true;
@@ -3190,17 +3190,17 @@ DEFUN (iscomplex, args, ,
 @deftypefn {} {} iscomplex (@var{x})
 Return true if @var{x} is a complex-valued numeric object.
 @seealso{isreal, isnumeric, islogical, ischar, isfloat, isa}
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
-  return ovl (args(0).is_complex_type ());
+  return ovl (args(0).iscomplex ());
 }
 
 DEFUN (isfloat, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} isfloat (@var{x})
 Return true if @var{x} is a floating-point numeric object.
 
 Objects of class double or single are floating-point objects.
@@ -3246,17 +3246,17 @@ complex ([1, 2], [3, 4])
     print_usage ();
 
   octave_value retval;
 
   if (nargin == 1)
     {
       octave_value arg = args(0);
 
-      if (arg.is_complex_type ())
+      if (arg.iscomplex ())
         retval = arg;
       else
         {
           if (arg.is_sparse_type ())
             {
               SparseComplexMatrix val = arg.xsparse_complex_matrix_value ("complex: invalid conversion");
 
               retval = octave_value (new octave_sparse_complex_matrix (val));
@@ -5128,24 +5128,24 @@ if fewer than two values are requested.
 
   if (! isvector1 || ! isvector2)
     error ("linspace: A, B must be scalars or vectors");
 
   octave_value retval;
 
   if (arg_1.is_single_type () || arg_2.is_single_type ())
     {
-      if (arg_1.is_complex_type () || arg_2.is_complex_type ())
+      if (arg_1.iscomplex () || arg_2.iscomplex ())
         retval = do_linspace<FloatComplexMatrix> (arg_1, arg_2, npoints);
       else
         retval = do_linspace<FloatMatrix> (arg_1, arg_2, npoints);
     }
   else
     {
-      if (arg_1.is_complex_type () || arg_2.is_complex_type ())
+      if (arg_1.iscomplex () || arg_2.iscomplex ())
         retval = do_linspace<ComplexMatrix> (arg_1, arg_2, npoints);
       else
         retval = do_linspace<Matrix> (arg_1, arg_2, npoints);
     }
 
   return retval;
 }
 
@@ -6982,26 +6982,26 @@ Undocumented internal function.
         {
           Range r = vals.range_value ();
           if (r.inc () == 0)
             vals = r.base ();
         }
 
       if (vals.is_single_type ())
         {
-          if (vals.is_complex_type ())
+          if (vals.iscomplex ())
             retval = do_accumarray_sum (idx,
                                         vals.float_complex_array_value (),
                                         n);
           else
             retval = do_accumarray_sum (idx, vals.float_array_value (), n);
         }
       else if (vals.is_numeric_type () || vals.islogical ())
         {
-          if (vals.is_complex_type ())
+          if (vals.iscomplex ())
             retval = do_accumarray_sum (idx,
                                         vals.complex_array_value (),
                                         n);
           else
             retval = do_accumarray_sum (idx, vals.array_value (), n);
         }
       else
         err_wrong_type_arg ("accumarray", vals);
@@ -7202,27 +7202,27 @@ Undocumented internal function.
       octave_idx_type n = -1;
       if (nargin == 4)
         n = args(3).idx_type_value (true);
 
       octave_value vals = args(1);
 
       if (vals.is_single_type ())
         {
-          if (vals.is_complex_type ())
+          if (vals.iscomplex ())
             retval = do_accumdim_sum (idx,
                                       vals.float_complex_array_value (),
                                       dim, n);
           else
             retval = do_accumdim_sum (idx, vals.float_array_value (),
                                       dim, n);
         }
       else if (vals.is_numeric_type () || vals.islogical ())
         {
-          if (vals.is_complex_type ())
+          if (vals.iscomplex ())
             retval = do_accumdim_sum (idx, vals.complex_array_value (),
                                       dim, n);
           else
             retval = do_accumdim_sum (idx, vals.array_value (), dim, n);
         }
       else
         err_wrong_type_arg ("accumdim", vals);
     }
@@ -7344,28 +7344,28 @@ converted to logical.
     {
       boolNDArray mask = mask_val.bool_array_value ();
 
       octave_value tval = args(1);
       octave_value fval = args(2);
 
       if (tval.is_double_type () && fval.is_double_type ())
         {
-          if (tval.is_complex_type () || fval.is_complex_type ())
+          if (tval.iscomplex () || fval.iscomplex ())
             retval = do_merge (mask,
                                tval.complex_array_value (),
                                fval.complex_array_value ());
           else
             retval = do_merge (mask,
                                tval.array_value (),
                                fval.array_value ());
         }
       else if (tval.is_single_type () && fval.is_single_type ())
         {
-          if (tval.is_complex_type () || fval.is_complex_type ())
+          if (tval.iscomplex () || fval.iscomplex ())
             retval = do_merge (mask,
                                tval.float_complex_array_value (),
                                fval.float_complex_array_value ());
           else
             retval = do_merge (mask,
                                tval.float_array_value (),
                                fval.float_array_value ());
         }
@@ -7501,32 +7501,32 @@ do_diff (const octave_value& array, octa
         retval = array.uint32_array_value ().diff (order, dim);
       else if (array.is_uint64_type ())
         retval = array.uint64_array_value ().diff (order, dim);
       else
         panic_impossible ();
     }
   else if (array.is_sparse_type ())
     {
-      if (array.is_complex_type ())
+      if (array.iscomplex ())
         retval = do_sparse_diff (array.sparse_complex_matrix_value (),
                                  order, dim);
       else
         retval = do_sparse_diff (array.sparse_matrix_value (), order, dim);
     }
   else if (array.is_single_type ())
     {
-      if (array.is_complex_type ())
+      if (array.iscomplex ())
         retval = array.float_complex_array_value ().diff (order, dim);
       else
         retval = array.float_array_value ().diff (order, dim);
     }
   else
     {
-      if (array.is_complex_type ())
+      if (array.iscomplex ())
         retval = array.complex_array_value ().diff (order, dim);
       else
         retval = array.array_value ().diff (order, dim);
     }
 
   return retval;
 }
 
@@ -7733,17 +7733,17 @@ Encode a double matrix or array @var{x} 
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
   if (! args(0).is_numeric_type ())
     error ("base64_encode: encoding is supported only for numeric arrays");
 
-  if (args(0).is_complex_type () || args(0).is_sparse_type ())
+  if (args(0).iscomplex () || args(0).is_sparse_type ())
     error ("base64_encode: encoding complex or sparse data is not supported");
 
   octave_value_list retval;
 
   if (args(0).isinteger ())
     {
 #define MAKE_INT_BRANCH(X)                                               \
       if (args(0).is_ ## X ## _type ())                                  \
diff --git a/libinterp/corefcn/det.cc b/libinterp/corefcn/det.cc
--- a/libinterp/corefcn/det.cc
+++ b/libinterp/corefcn/det.cc
@@ -79,17 +79,17 @@ For that, use any of the condition numbe
 
   bool isfloat = arg.is_single_type ();
 
   if (arg.is_diag_matrix ())
     {
       if (nargout <= 1)
         retval.resize (1);
 
-      if (arg.is_complex_type ())
+      if (arg.iscomplex ())
         {
           if (isfloat)
             {
               retval(0) = arg.float_complex_diag_matrix_value ()
                           .determinant ().value ();
               if (nargout > 1)
                 retval(1) = arg.float_complex_diag_matrix_value ().rcond ();
             }
@@ -139,17 +139,17 @@ For that, use any of the condition numbe
           MAYBE_CAST (rep, octave_float_matrix);
           MatrixType mtype = (rep ? rep -> matrix_type () : MatrixType ());
           FloatDET det = m.determinant (mtype, info, rcond);
           retval(0) = (info == -1 ? 0.0f : det.value ());
           retval(1) = rcond;
           if (rep)
             rep->matrix_type (mtype);
         }
-      else if (arg.is_complex_type ())
+      else if (arg.iscomplex ())
         {
           octave_idx_type info;
           float rcond = 0.0;
           // Always compute rcond, so we can detect singular matrices.
           FloatComplexMatrix m = arg.float_complex_matrix_value ();
 
           MAYBE_CAST (rep, octave_float_complex_matrix);
           MatrixType mtype = (rep ? rep -> matrix_type () : MatrixType ());
@@ -184,17 +184,17 @@ For that, use any of the condition numbe
                                       : MatrixType ());
               DET det = m.determinant (mtype, info, rcond);
               retval(0) = (info == -1 ? 0.0 : det.value ());
               retval(1) = rcond;
               if (rep)
                 rep->matrix_type (mtype);
             }
         }
-      else if (arg.is_complex_type ())
+      else if (arg.iscomplex ())
         {
           octave_idx_type info;
           double rcond = 0.0;
           // Always compute rcond, so we can detect singular matrices.
           if (arg.is_sparse_type ())
             {
               SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
 
diff --git a/libinterp/corefcn/dot.cc b/libinterp/corefcn/dot.cc
--- a/libinterp/corefcn/dot.cc
+++ b/libinterp/corefcn/dot.cc
@@ -117,17 +117,17 @@ but avoids forming a temporary array and
   else
     dim = args(2).int_value (true) - 1;
 
   if (dim < 0)
     error ("dot: DIM must be a valid dimension");
 
   F77_INT m, n, k;
   dim_vector dimz;
-  if (argx.is_complex_type () || argy.is_complex_type ())
+  if (argx.iscomplex () || argy.iscomplex ())
     {
       if (argx.is_single_type () || argy.is_single_type ())
         {
           FloatComplexNDArray x = argx.float_complex_array_value ();
           FloatComplexNDArray y = argy.float_complex_array_value ();
           get_red_dims (dimx, dimy, dim, dimz, m, n, k);
           FloatComplexNDArray z (dimz);
 
@@ -275,17 +275,17 @@ endfor
       tmp_np *= dimz(i);
     }
   F77_INT np = octave::to_f77_int (tmp_np);
 
   if (! match)
     error ("blkmm: A and B dimensions don't match: (%s) and (%s)",
            dimx.str ().c_str (), dimy.str ().c_str ());
 
-  if (argx.is_complex_type () || argy.is_complex_type ())
+  if (argx.iscomplex () || argy.iscomplex ())
     {
       if (argx.is_single_type () || argy.is_single_type ())
         {
           FloatComplexNDArray x = argx.float_complex_array_value ();
           FloatComplexNDArray y = argy.float_complex_array_value ();
           FloatComplexNDArray z (dimz);
 
           F77_XFCN (cmatm3, CMATM3, (m, n, k, np,
diff --git a/libinterp/corefcn/fft.cc b/libinterp/corefcn/fft.cc
--- a/libinterp/corefcn/fft.cc
+++ b/libinterp/corefcn/fft.cc
@@ -141,17 +141,17 @@ do_fft (const octave_value_list& args, c
     {
       if (arg.is_real_type ())
         {
           NDArray nda = arg.array_value ();
 
           nda.resize (dims, 0.0);
           retval = (type != 0 ? nda.ifourier (dim) : nda.fourier (dim));
         }
-      else if (arg.is_complex_type ())
+      else if (arg.iscomplex ())
         {
           ComplexNDArray cnda = arg.complex_array_value ();
 
           cnda.resize (dims, 0.0);
           retval = (type != 0 ? cnda.ifourier (dim) : cnda.fourier (dim));
         }
       else
         err_wrong_type_arg (fcn, arg);
diff --git a/libinterp/corefcn/fft2.cc b/libinterp/corefcn/fft2.cc
--- a/libinterp/corefcn/fft2.cc
+++ b/libinterp/corefcn/fft2.cc
@@ -120,17 +120,17 @@ do_fft2 (const octave_value_list& args, 
     {
       if (arg.is_real_type ())
         {
           NDArray nda = arg.array_value ();
 
           nda.resize (dims, 0.0);
           retval = (type != 0 ? nda.ifourier2d () : nda.fourier2d ());
         }
-      else if (arg.is_complex_type ())
+      else if (arg.iscomplex ())
         {
           ComplexNDArray cnda = arg.complex_array_value ();
 
           cnda.resize (dims, 0.0);
           retval = (type != 0 ? cnda.ifourier2d () : cnda.fourier2d ());
         }
       else
         err_wrong_type_arg (fcn, arg);
diff --git a/libinterp/corefcn/fftn.cc b/libinterp/corefcn/fftn.cc
--- a/libinterp/corefcn/fftn.cc
+++ b/libinterp/corefcn/fftn.cc
@@ -106,17 +106,17 @@ do_fftn (const octave_value_list& args, 
     {
       if (arg.is_real_type ())
         {
           NDArray nda = arg.array_value ();
 
           nda.resize (dims, 0.0);
           retval = (type != 0 ? nda.ifourierNd () : nda.fourierNd ());
         }
-      else if (arg.is_complex_type ())
+      else if (arg.iscomplex ())
         {
           ComplexNDArray cnda = arg.complex_array_value ();
 
           cnda.resize (dims, 0.0);
           retval = (type != 0 ? cnda.ifourierNd () : cnda.fourierNd ());
         }
       else
         err_wrong_type_arg (fcn, arg);
diff --git a/libinterp/corefcn/filter.cc b/libinterp/corefcn/filter.cc
--- a/libinterp/corefcn/filter.cc
+++ b/libinterp/corefcn/filter.cc
@@ -352,20 +352,20 @@ H(z) = ---------------------
   const char *a_b_errmsg = "filter: A and B must be vectors";
   const char *x_si_errmsg = "filter: X and SI must be arrays";
 
   bool isfloat = (args(0).is_single_type ()
                   || args(1).is_single_type ()
                   || args(2).is_single_type ()
                   || (nargin >= 4 && args(3).is_single_type ()));
 
-  if (args(0).is_complex_type ()
-      || args(1).is_complex_type ()
-      || args(2).is_complex_type ()
-      || (nargin >= 4 && args(3).is_complex_type ()))
+  if (args(0).iscomplex ()
+      || args(1).iscomplex ()
+      || args(2).iscomplex ()
+      || (nargin >= 4 && args(3).iscomplex ()))
     {
       if (isfloat)
         {
           FloatComplexColumnVector b = args(0).xfloat_complex_vector_value (a_b_errmsg);
           FloatComplexColumnVector a = args(1).xfloat_complex_vector_value (a_b_errmsg);
           FloatComplexNDArray x = args(2).xfloat_complex_array_value (x_si_errmsg);
 
           FloatComplexNDArray si;
diff --git a/libinterp/corefcn/find.cc b/libinterp/corefcn/find.cc
--- a/libinterp/corefcn/find.cc
+++ b/libinterp/corefcn/find.cc
@@ -475,17 +475,17 @@ b = sparse (i, j, v, sz(1), sz(2));
   else if (arg.is_sparse_type ())
     {
       if (arg.is_real_type ())
         {
           SparseMatrix v = arg.sparse_matrix_value ();
 
           retval = find_nonzero_elem_idx (v, nargout, n_to_find, direction);
         }
-      else if (arg.is_complex_type ())
+      else if (arg.iscomplex ())
         {
           SparseComplexMatrix v = arg.sparse_complex_matrix_value ();
 
           retval = find_nonzero_elem_idx (v, nargout, n_to_find, direction);
         }
       else
         err_wrong_type_arg ("find", arg);
     }
@@ -504,30 +504,30 @@ b = sparse (i, j, v, sz(1), sz(2));
   else if (arg.is_single_type ())
     {
       if (arg.is_real_type ())
         {
           FloatNDArray nda = arg.float_array_value ();
 
           retval = find_nonzero_elem_idx (nda, nargout, n_to_find, direction);
         }
-      else if (arg.is_complex_type ())
+      else if (arg.iscomplex ())
         {
           FloatComplexNDArray cnda = arg.float_complex_array_value ();
 
           retval = find_nonzero_elem_idx (cnda, nargout, n_to_find, direction);
         }
     }
   else if (arg.is_real_type ())
     {
       NDArray nda = arg.array_value ();
 
       retval = find_nonzero_elem_idx (nda, nargout, n_to_find, direction);
     }
-  else if (arg.is_complex_type ())
+  else if (arg.iscomplex ())
     {
       ComplexNDArray cnda = arg.complex_array_value ();
 
       retval = find_nonzero_elem_idx (cnda, nargout, n_to_find, direction);
     }
   else
     err_wrong_type_arg ("find", arg);
 
diff --git a/libinterp/corefcn/givens.cc b/libinterp/corefcn/givens.cc
--- a/libinterp/corefcn/givens.cc
+++ b/libinterp/corefcn/givens.cc
@@ -76,17 +76,17 @@ givens (1, 1)
 {
   if (args.length () != 2)
     print_usage ();
 
   octave_value_list retval;
 
   if (args(0).is_single_type () || args(1).is_single_type ())
     {
-      if (args(0).is_complex_type () || args(1).is_complex_type ())
+      if (args(0).iscomplex () || args(1).iscomplex ())
         {
           FloatComplex cx = args(0).float_complex_value ();
           FloatComplex cy = args(1).float_complex_value ();
 
           FloatComplexMatrix result = Givens (cx, cy);
 
           switch (nargout)
             {
@@ -117,17 +117,17 @@ givens (1, 1)
             case 2:
               retval = ovl (result(0, 0), result(0, 1));
               break;
             }
         }
     }
   else
     {
-      if (args(0).is_complex_type () || args(1).is_complex_type ())
+      if (args(0).iscomplex () || args(1).iscomplex ())
         {
           Complex cx = args(0).complex_value ();
           Complex cy = args(1).complex_value ();
 
           ComplexMatrix result = Givens (cx, cy);
 
           switch (nargout)
             {
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -1413,17 +1413,17 @@ array_property::validate (const octave_v
   if (type_constraints.size () > 0)
     {
       if (type_constraints.find (v.class_name ()) != type_constraints.end ())
         xok = true;
 
       // check if complex is allowed (it's also of class "double", so
       // checking that alone is not enough to ensure real type)
       if (type_constraints.find ("real") != type_constraints.end ()
-          && v.is_complex_type ())
+          && v.iscomplex ())
         xok = false;
     }
   else
     xok = v.is_numeric_type () || v.is_bool_scalar ();
 
   if (xok)
     {
       if (size_constraints.size () == 0)
diff --git a/libinterp/corefcn/gsvd.cc b/libinterp/corefcn/gsvd.cc
--- a/libinterp/corefcn/gsvd.cc
+++ b/libinterp/corefcn/gsvd.cc
@@ -217,17 +217,17 @@ and zggsvd routines.
 
               if (tmpA.any_element_is_inf_or_nan ())
                 error ("gsvd: A cannot have Inf or NaN values");
               if (tmpB.any_element_is_inf_or_nan ())
                 error ("gsvd: B cannot have Inf or NaN values");
 
               retval = do_gsvd (tmpA, tmpB, nargout, true);
             }
-          else if (argA.is_complex_type () || argB.is_complex_type ())
+          else if (argA.iscomplex () || argB.iscomplex ())
             {
               FloatComplexMatrix ctmpA = argA.xfloat_complex_matrix_value ("gsvd: A must be a real or complex matrix");
               FloatComplexMatrix ctmpB = argB.xfloat_complex_matrix_value ("gsvd: B must be a real or complex matrix");
 
               if (ctmpA.any_element_is_inf_or_nan ())
                 error ("gsvd: A cannot have Inf or NaN values");
               if (ctmpB.any_element_is_inf_or_nan ())
                 error ("gsvd: B cannot have Inf or NaN values");
@@ -246,17 +246,17 @@ and zggsvd routines.
 
               if (tmpA.any_element_is_inf_or_nan ())
                 error ("gsvd: A cannot have Inf or NaN values");
               if (tmpB.any_element_is_inf_or_nan ())
                 error ("gsvd: B cannot have Inf or NaN values");
 
               retval = do_gsvd (tmpA, tmpB, nargout);
             }
-          else if (argA.is_complex_type () || argB.is_complex_type ())
+          else if (argA.iscomplex () || argB.iscomplex ())
             {
               ComplexMatrix ctmpA = argA.xcomplex_matrix_value ("gsvd: A must be a real or complex matrix");
               ComplexMatrix ctmpB = argB.xcomplex_matrix_value ("gsvd: B must be a real or complex matrix");
 
               if (ctmpA.any_element_is_inf_or_nan ())
                 error ("gsvd: A cannot have Inf or NaN values");
               if (ctmpB.any_element_is_inf_or_nan ())
                 error ("gsvd: B cannot have Inf or NaN values");
diff --git a/libinterp/corefcn/hess.cc b/libinterp/corefcn/hess.cc
--- a/libinterp/corefcn/hess.cc
+++ b/libinterp/corefcn/hess.cc
@@ -82,17 +82,17 @@ IEEE Transactions on Automatic Control, 
           octave::math::hess<FloatMatrix> result (tmp);
 
           if (nargout <= 1)
             retval = ovl (result.hess_matrix ());
           else
             retval = ovl (result.unitary_hess_matrix (),
                           result.hess_matrix ());
         }
-      else if (arg.is_complex_type ())
+      else if (arg.iscomplex ())
         {
           FloatComplexMatrix ctmp = arg.float_complex_matrix_value ();
 
           octave::math::hess<FloatComplexMatrix> result (ctmp);
 
           if (nargout <= 1)
             retval = ovl (result.hess_matrix ());
           else
@@ -109,17 +109,17 @@ IEEE Transactions on Automatic Control, 
           octave::math::hess<Matrix> result (tmp);
 
           if (nargout <= 1)
             retval = ovl (result.hess_matrix ());
           else
             retval = ovl (result.unitary_hess_matrix (),
                           result.hess_matrix ());
         }
-      else if (arg.is_complex_type ())
+      else if (arg.iscomplex ())
         {
           ComplexMatrix ctmp = arg.complex_matrix_value ();
 
           octave::math::hess<ComplexMatrix> result (ctmp);
 
           if (nargout <= 1)
             retval = ovl (result.hess_matrix ());
           else
diff --git a/libinterp/corefcn/hex2num.cc b/libinterp/corefcn/hex2num.cc
--- a/libinterp/corefcn/hex2num.cc
+++ b/libinterp/corefcn/hex2num.cc
@@ -312,17 +312,17 @@ strings instead of a character array.
       if (opt == "cell")
         as_cell = true;
       else
         error ("num2hex: unrecognized option '%s'", opt.c_str ());
     }
 
   octave_value val = args(0);
 
-  if (val.is_complex_type ())
+  if (val.iscomplex ())
     error ("num2hex: N must be real");
 
   Cell result;
 
   // We always use big-endian order for hex digits.
   bool is_float = val.is_single_type () || val.is_double_type ();
   bool swap_bytes = is_little_endian (is_float);
 
diff --git a/libinterp/corefcn/inv.cc b/libinterp/corefcn/inv.cc
--- a/libinterp/corefcn/inv.cc
+++ b/libinterp/corefcn/inv.cc
@@ -73,17 +73,17 @@ sparse matrix if possible.
   double rcond = 0.0;
   float frcond = 0.0;
   bool isfloat = arg.is_single_type ();
 
   if (arg.is_diag_matrix ())
     {
       rcond = 1.0;
       frcond = 1.0f;
-      if (arg.is_complex_type ())
+      if (arg.iscomplex ())
         {
           if (isfloat)
             {
               result = arg.float_complex_diag_matrix_value ().inverse (info);
               if (nargout > 1)
                 frcond = arg.float_complex_diag_matrix_value ().rcond ();
             }
           else
@@ -120,17 +120,17 @@ sparse matrix if possible.
       if (arg.is_real_type ())
         {
           FloatMatrix m = arg.float_matrix_value ();
 
           MatrixType mattyp = args(0).matrix_type ();
           result = m.inverse (mattyp, info, frcond, 1);
           args(0).matrix_type (mattyp);
         }
-      else if (arg.is_complex_type ())
+      else if (arg.iscomplex ())
         {
           FloatComplexMatrix m = arg.float_complex_matrix_value ();
 
           MatrixType mattyp = args(0).matrix_type ();
           result = m.inverse (mattyp, info, frcond, 1);
           args(0).matrix_type (mattyp);
         }
     }
@@ -150,17 +150,17 @@ sparse matrix if possible.
             {
               Matrix m = arg.matrix_value ();
 
               MatrixType mattyp = args(0).matrix_type ();
               result = m.inverse (mattyp, info, rcond, 1);
               args(0).matrix_type (mattyp);
             }
         }
-      else if (arg.is_complex_type ())
+      else if (arg.iscomplex ())
         {
           if (arg.is_sparse_type ())
             {
               SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
 
               MatrixType mattyp = args(0).matrix_type ();
               result = m.inverse (mattyp, info, rcond, 1);
               args(0).matrix_type (mattyp);
diff --git a/libinterp/corefcn/kron.cc b/libinterp/corefcn/kron.cc
--- a/libinterp/corefcn/kron.cc
+++ b/libinterp/corefcn/kron.cc
@@ -163,17 +163,17 @@ do_kron (const octave_value& a, const oc
 octave_value
 dispatch_kron (const octave_value& a, const octave_value& b)
 {
   octave_value retval;
   if (a.is_perm_matrix () && b.is_perm_matrix ())
     retval = do_kron<PermMatrix, PermMatrix> (a, b);
   else if (a.is_sparse_type () || b.is_sparse_type ())
     {
-      if (a.is_complex_type () || b.is_complex_type ())
+      if (a.iscomplex () || b.iscomplex ())
         retval = do_kron<SparseComplexMatrix, SparseComplexMatrix> (a, b);
       else
         retval = do_kron<SparseMatrix, SparseMatrix> (a, b);
     }
   else if (a.is_diag_matrix ())
     {
       if (b.is_diag_matrix () && a.rows () == a.columns ()
           && b.rows () == b.columns ())
@@ -188,47 +188,47 @@ dispatch_kron (const octave_value& a, co
           // diag ([1,2], 3) is modified to return a diagonal matrix
           // object instead of a full matrix object).
 
           octave_value tmp = dispatch_kron (a.diag (), b.diag ());
           retval = tmp.diag ();
         }
       else if (a.is_single_type () || b.is_single_type ())
         {
-          if (a.is_complex_type ())
+          if (a.iscomplex ())
             retval = do_kron<FloatComplexDiagMatrix, FloatComplexMatrix> (a, b);
-          else if (b.is_complex_type ())
+          else if (b.iscomplex ())
             retval = do_kron<FloatDiagMatrix, FloatComplexMatrix> (a, b);
           else
             retval = do_kron<FloatDiagMatrix, FloatMatrix> (a, b);
         }
       else
         {
-          if (a.is_complex_type ())
+          if (a.iscomplex ())
             retval = do_kron<ComplexDiagMatrix, ComplexMatrix> (a, b);
-          else if (b.is_complex_type ())
+          else if (b.iscomplex ())
             retval = do_kron<DiagMatrix, ComplexMatrix> (a, b);
           else
             retval = do_kron<DiagMatrix, Matrix> (a, b);
         }
     }
   else if (a.is_single_type () || b.is_single_type ())
     {
-      if (a.is_complex_type ())
+      if (a.iscomplex ())
         retval = do_kron<FloatComplexMatrix, FloatComplexMatrix> (a, b);
-      else if (b.is_complex_type ())
+      else if (b.iscomplex ())
         retval = do_kron<FloatMatrix, FloatComplexMatrix> (a, b);
       else
         retval = do_kron<FloatMatrix, FloatMatrix> (a, b);
     }
   else
     {
-      if (a.is_complex_type ())
+      if (a.iscomplex ())
         retval = do_kron<ComplexMatrix, ComplexMatrix> (a, b);
-      else if (b.is_complex_type ())
+      else if (b.iscomplex ())
         retval = do_kron<Matrix, ComplexMatrix> (a, b);
       else
         retval = do_kron<Matrix, Matrix> (a, b);
     }
   return retval;
 }
 
 
diff --git a/libinterp/corefcn/lookup.cc b/libinterp/corefcn/lookup.cc
--- a/libinterp/corefcn/lookup.cc
+++ b/libinterp/corefcn/lookup.cc
@@ -276,20 +276,20 @@ at most n-1).
     error ("lookup: only one of m or b can be specified");
   else if (str_case && (left_inf || right_inf))
     error ("lookup: l, r are not recognized for string lookups");
 
   if (num_case)
     {
       // In the case of a complex array, absolute values will be used for
       // compatibility (though it's not too meaningful).
-      if (table.is_complex_type ())
+      if (table.iscomplex ())
         table = table.abs ();
 
-      if (y.is_complex_type ())
+      if (y.iscomplex ())
         y = y.abs ();
 
       Array<octave_idx_type> idx;
 
       // PS: I learned this from data.cc
       if INT_ARRAY_LOOKUP (int8)
       else if INT_ARRAY_LOOKUP (int16)
       else if INT_ARRAY_LOOKUP (int32)
diff --git a/libinterp/corefcn/ls-mat-ascii.cc b/libinterp/corefcn/ls-mat-ascii.cc
--- a/libinterp/corefcn/ls-mat-ascii.cc
+++ b/libinterp/corefcn/ls-mat-ascii.cc
@@ -338,17 +338,17 @@ read_mat_ascii_data (std::istream& is, c
 }
 
 bool
 save_mat_ascii_data (std::ostream& os, const octave_value& val,
                      int precision, bool tabs)
 {
   bool success = true;
 
-  if (val.is_complex_type ())
+  if (val.iscomplex ())
     warning ("save: omitting imaginary part for ASCII file");
 
   Matrix m;
 
   try
     {
       m = val.matrix_value (true);
     }
diff --git a/libinterp/corefcn/ls-mat4.cc b/libinterp/corefcn/ls-mat4.cc
--- a/libinterp/corefcn/ls-mat4.cc
+++ b/libinterp/corefcn/ls-mat4.cc
@@ -409,28 +409,28 @@ save_mat_binary_data (std::ostream& os, 
   int32_t nc = tc.columns ();
 
   if (tc.is_sparse_type ())
     {
       len = tc.nnz ();
       uint32_t nnz = len + 1;
       os.write (reinterpret_cast<char *> (&nnz), 4);
 
-      uint32_t iscmplx = (tc.is_complex_type () ? 4 : 3);
+      uint32_t iscmplx = (tc.iscomplex () ? 4 : 3);
       os.write (reinterpret_cast<char *> (&iscmplx), 4);
 
       uint32_t tmp = 0;
       os.write (reinterpret_cast<char *> (&tmp), 4);
     }
   else
     {
       os.write (reinterpret_cast<char *> (&nr), 4);
       os.write (reinterpret_cast<char *> (&nc), 4);
 
-      int32_t imag = (tc.is_complex_type () ? 1 : 0);
+      int32_t imag = (tc.iscomplex () ? 1 : 0);
       os.write (reinterpret_cast<char *> (&imag), 4);
 
       len = nr * nc;
     }
 
   // LEN includes the terminating character, and the file is also
   // supposed to include it.
 
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -2070,17 +2070,17 @@ save_mat5_element_length (const octave_v
     {
       charNDArray chm = tc.char_array_value ();
       ret += 8;
       if (chm.numel () > 2)
         ret += PAD (2 * chm.numel ());
     }
   else if (tc.is_sparse_type ())
     {
-      if (tc.is_complex_type ())
+      if (tc.iscomplex ())
         {
           const SparseComplexMatrix m = tc.sparse_complex_matrix_value ();
           octave_idx_type nc = m.cols ();
           octave_idx_type nnz = m.nnz ();
 
           ret += 16 + save_mat5_array_length (m.data (), nnz, save_as_floats);
           if (nnz > 1)
             ret += PAD (nnz * sizeof (int32_t));
@@ -2256,17 +2256,17 @@ save_mat5_binary_element (std::ostream& 
         }
     }
 
   if (tc.is_sparse_type ())
     {
       octave_idx_type nnz;
       octave_idx_type nc;
 
-      if (tc.is_complex_type ())
+      if (tc.iscomplex ())
         {
           SparseComplexMatrix scm = tc.sparse_complex_matrix_value ();
           nnz = scm.nzmax ();
           nc = scm.cols ();
         }
       else
         {
           SparseMatrix sm = tc.sparse_matrix_value ();
@@ -2445,17 +2445,17 @@ save_mat5_binary_element (std::ostream& 
       if (paddedlength > len)
         {
           static char padbuf[9]="\x00\x00\x00\x00\x00\x00\x00\x00";
           os.write (padbuf, paddedlength - len);
         }
     }
   else if (tc.is_sparse_type ())
     {
-      if (tc.is_complex_type ())
+      if (tc.iscomplex ())
         {
           const SparseComplexMatrix m = tc.sparse_complex_matrix_value ();
           octave_idx_type nnz = m.nnz ();
           octave_idx_type nc = m.cols ();
 
           write_mat5_sparse_index_vector (os, m.ridx (), nnz);
           write_mat5_sparse_index_vector (os, m.cidx (), nc + 1);
 
diff --git a/libinterp/corefcn/lsode.cc b/libinterp/corefcn/lsode.cc
--- a/libinterp/corefcn/lsode.cc
+++ b/libinterp/corefcn/lsode.cc
@@ -80,17 +80,17 @@ lsode_user_function (const ColumnVector&
       catch (octave::execution_exception& e)
         {
           err_user_supplied_eval (e, "lsode");
         }
 
       if (tmp.empty () || ! tmp(0).is_defined ())
         err_user_supplied_eval ("lsode");
 
-      if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
+      if (! warned_fcn_imaginary && tmp(0).iscomplex ())
         {
           warning ("lsode: ignoring imaginary part returned from user-supplied function");
           warned_fcn_imaginary = true;
         }
 
       retval = tmp(0).xvector_value ("lsode: expecting user supplied function to return numeric vector");
 
       if (retval.isempty ())
@@ -120,17 +120,17 @@ lsode_user_jacobian (const ColumnVector&
       catch (octave::execution_exception& e)
         {
           err_user_supplied_eval (e, "lsode");
         }
 
       if (tmp.empty () || ! tmp(0).is_defined ())
         err_user_supplied_eval ("lsode");
 
-      if (! warned_jac_imaginary && tmp(0).is_complex_type ())
+      if (! warned_jac_imaginary && tmp(0).iscomplex ())
         {
           warning ("lsode: ignoring imaginary part returned from user-supplied jacobian function");
           warned_jac_imaginary = true;
         }
 
       retval = tmp(0).xmatrix_value ("lsode: expecting user supplied jacobian function to return numeric array");
 
       if (retval.isempty ())
diff --git a/libinterp/corefcn/lu.cc b/libinterp/corefcn/lu.cc
--- a/libinterp/corefcn/lu.cc
+++ b/libinterp/corefcn/lu.cc
@@ -250,17 +250,17 @@ permutation information.
                   retval(2) = fact.Pr_mat ();
                   retval(3) = fact.Pc_mat ();
                 }
 
               if (scale)
                 retval(4) = fact.R ();
             }
         }
-      else if (arg.is_complex_type ())
+      else if (arg.iscomplex ())
         {
           SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
 
           if (nargout < 4)
             {
               ColumnVector Qinit (nc);
               for (octave_idx_type i = 0; i < nc; i++)
                 Qinit(i) = i;
@@ -396,17 +396,17 @@ permutation information.
                     else
                       retval = ovl (get_lu_l (fact), get_lu_u (fact),
                                     fact.P ());
                   }
                   break;
                 }
             }
         }
-      else if (arg.is_complex_type ())
+      else if (arg.iscomplex ())
         {
           if (arg.is_single_type ())
             {
               FloatComplexMatrix m = arg.float_complex_matrix_value ();
 
               octave::math::lu<FloatComplexMatrix> fact (m);
 
               switch (nargout)
diff --git a/libinterp/corefcn/matrix_type.cc b/libinterp/corefcn/matrix_type.cc
--- a/libinterp/corefcn/matrix_type.cc
+++ b/libinterp/corefcn/matrix_type.cc
@@ -142,17 +142,17 @@ LU@tie{}factorization.  Once the matrix 
         retval = args(0);
     }
   else if (args(0).is_sparse_type ())
     {
       if (nargin == 1)
         {
           MatrixType mattyp;
 
-          if (args(0).is_complex_type ())
+          if (args(0).iscomplex ())
             {
               mattyp = args(0).matrix_type ();
 
               if (mattyp.is_unknown () && autocomp)
                 {
                   SparseComplexMatrix m =
                     args(0).sparse_complex_matrix_value ();
 
@@ -282,31 +282,31 @@ LU@tie{}factorization.  Once the matrix 
               mattyp.mark_as_permuted (len, p);
             }
           else if (nargin != 2
                    && str_typ != "banded positive definite"
                    && str_typ != "banded")
             error ("matrix_type: Invalid number of arguments");
 
           // Set the matrix type
-          if (args(0).is_complex_type ())
+          if (args(0).iscomplex ())
             retval = octave_value (args(0).sparse_complex_matrix_value (),
                                    mattyp);
           else
             retval = octave_value (args(0).sparse_matrix_value (),
                                    mattyp);
         }
     }
   else
     {
       if (nargin == 1)
         {
           MatrixType mattyp;
 
-          if (args(0).is_complex_type ())
+          if (args(0).iscomplex ())
             {
               mattyp = args(0).matrix_type ();
 
               if (mattyp.is_unknown () && autocomp)
                 {
                   if (args(0).is_single_type ())
                     {
                       FloatComplexMatrix m;
@@ -419,26 +419,26 @@ LU@tie{}factorization.  Once the matrix 
               mattyp.mark_as_permuted (len, p);
             }
           else if (nargin != 2)
             error ("matrix_type: Invalid number of arguments");
 
           // Set the matrix type
           if (args(0).is_single_type ())
             {
-              if (args(0).is_complex_type ())
+              if (args(0).iscomplex ())
                 retval = octave_value (args(0).float_complex_matrix_value (),
                                        mattyp);
               else
                 retval = octave_value (args(0).float_matrix_value (),
                                        mattyp);
             }
           else
             {
-              if (args(0).is_complex_type ())
+              if (args(0).iscomplex ())
                 retval = octave_value (args(0).complex_matrix_value (),
                                        mattyp);
               else
                 retval = octave_value (args(0).matrix_value (), mattyp);
             }
         }
     }
 
diff --git a/libinterp/corefcn/mex.cc b/libinterp/corefcn/mex.cc
--- a/libinterp/corefcn/mex.cc
+++ b/libinterp/corefcn/mex.cc
@@ -213,17 +213,17 @@ public:
   }
 
   bool is_octave_value (void) const { return true; }
 
   int iscell (void) const { return val.iscell (); }
 
   int is_char (void) const { return val.is_string (); }
 
-  int is_complex (void) const { return val.is_complex_type (); }
+  int is_complex (void) const { return val.iscomplex (); }
 
   int is_double (void) const { return val.is_double_type (); }
 
   int is_function_handle (void) const { return val.is_function_handle (); }
 
   int is_int16 (void) const { return val.is_int16_type (); }
 
   int is_int32 (void) const { return val.is_int32_type (); }
diff --git a/libinterp/corefcn/mgorth.cc b/libinterp/corefcn/mgorth.cc
--- a/libinterp/corefcn/mgorth.cc
+++ b/libinterp/corefcn/mgorth.cc
@@ -78,17 +78,17 @@ On exit, @var{y} is a unit vector such t
     error ("mgorth: V should be a matrix, and X a column vector with"
            " the same number of rows as V.");
 
   if (! arg_x.is_numeric_type () && ! arg_v.is_numeric_type ())
     error ("mgorth: X and V must be numeric");
 
   octave_value_list retval;
 
-  bool iscomplex = (arg_x.is_complex_type () || arg_v.is_complex_type ());
+  bool iscomplex = (arg_x.iscomplex () || arg_v.iscomplex ());
   if (arg_x.is_single_type () || arg_v.is_single_type ())
     {
       if (iscomplex)
         {
           FloatComplexColumnVector x
             = arg_x.float_complex_column_vector_value ();
           FloatComplexMatrix V = arg_v.float_complex_matrix_value ();
           FloatComplexRowVector h;
diff --git a/libinterp/corefcn/ordschur.cc b/libinterp/corefcn/ordschur.cc
--- a/libinterp/corefcn/ordschur.cc
+++ b/libinterp/corefcn/ordschur.cc
@@ -89,18 +89,18 @@ is in the upper left corner, by doing:
   else if (sel_n != dimU(0) || sel_n != dimS(0) || sel_n != dimU(1)
            || sel_n != dimS(1))
     error ("ordschur: U and S must be square and of equal sizes");
 
   octave_value_list retval;
 
   const bool double_type  = args(0).is_double_type ()
                             || args(1).is_double_type ();
-  const bool complex_type = args(0).is_complex_type ()
-                            || args(1).is_complex_type ();
+  const bool complex_type = args(0).iscomplex ()
+                            || args(1).iscomplex ();
 
 #define PREPARE_ARGS(TYPE, TYPE_M, TYPE_COND)                           \
   TYPE ## Matrix U = args(0).x ## TYPE_M ## _value                      \
     ("ordschur: U and S must be real or complex floating point matrices"); \
   TYPE ## Matrix S = args(1).x ## TYPE_M ## _value                      \
     ("ordschur: U and S must be real or complex floating point matrices"); \
   TYPE ## Matrix w (dim_vector (n, 1));                                 \
   TYPE ## Matrix work (dim_vector (n, 1));                              \
diff --git a/libinterp/corefcn/pinv.cc b/libinterp/corefcn/pinv.cc
--- a/libinterp/corefcn/pinv.cc
+++ b/libinterp/corefcn/pinv.cc
@@ -112,17 +112,17 @@ where @code{sigma_max (@var{x})} is the 
         error ("pinv: TOL must be greater than zero");
 
       if (arg.is_real_type ())
         {
           FloatMatrix m = arg.float_matrix_value ();
 
           retval = m.pseudo_inverse (tol);
         }
-      else if (arg.is_complex_type ())
+      else if (arg.iscomplex ())
         {
           FloatComplexMatrix m = arg.float_complex_matrix_value ();
 
           retval = m.pseudo_inverse (tol);
         }
       else
         err_wrong_type_arg ("pinv", arg);
     }
@@ -136,17 +136,17 @@ where @code{sigma_max (@var{x})} is the 
         error ("pinv: TOL must be greater than zero");
 
       if (arg.is_real_type ())
         {
           Matrix m = arg.matrix_value ();
 
           retval = m.pseudo_inverse (tol);
         }
-      else if (arg.is_complex_type ())
+      else if (arg.iscomplex ())
         {
           ComplexMatrix m = arg.complex_matrix_value ();
 
           retval = m.pseudo_inverse (tol);
         }
       else
         err_wrong_type_arg ("pinv", arg);
     }
diff --git a/libinterp/corefcn/psi.cc b/libinterp/corefcn/psi.cc
--- a/libinterp/corefcn/psi.cc
+++ b/libinterp/corefcn/psi.cc
@@ -91,17 +91,17 @@ can have any value real or complex value
           E *psi_zv = psi_z.fortran_vec ();                     \
           const octave_idx_type n = z.numel ();                 \
           for (octave_idx_type i = 0; i < n; i++)               \
             *psi_zv++ = octave::math::psi (*zv++);              \
                                                                 \
           retval = psi_z;                                       \
         }
 
-      if (oct_z.is_complex_type ())
+      if (oct_z.iscomplex ())
         {
           FLOAT_BRANCH(double, Complex, complex_, Complex)
           else FLOAT_BRANCH(single, FloatComplex, float_complex_, FloatComplex)
           else
             error ("psi: Z must be a floating point");
         }
       else
         {
diff --git a/libinterp/corefcn/quad.cc b/libinterp/corefcn/quad.cc
--- a/libinterp/corefcn/quad.cc
+++ b/libinterp/corefcn/quad.cc
@@ -77,17 +77,17 @@ quad_user_function (double x)
       catch (octave::execution_exception& e)
         {
           err_user_supplied_eval (e, "quad");
         }
 
       if (! tmp.length () || ! tmp(0).is_defined ())
         err_user_supplied_eval ("quad");
 
-      if (! warned_imaginary && tmp(0).is_complex_type ())
+      if (! warned_imaginary && tmp(0).iscomplex ())
         {
           warning ("quad: ignoring imaginary part returned from user-supplied function");
           warned_imaginary = true;
         }
 
       retval = tmp(0).xdouble_value ("quad: expecting user supplied function to return numeric value");
     }
 
@@ -113,17 +113,17 @@ quad_float_user_function (float x)
       catch (octave::execution_exception& e)
         {
           err_user_supplied_eval (e, "quad");
         }
 
       if (! tmp.length () || ! tmp(0).is_defined ())
         err_user_supplied_eval ("quad");
 
-      if (! warned_imaginary && tmp(0).is_complex_type ())
+      if (! warned_imaginary && tmp(0).iscomplex ())
         {
           warning ("quad: ignoring imaginary part returned from user-supplied function");
           warned_imaginary = true;
         }
 
       retval = tmp(0).xfloat_value ("quad: expecting user supplied function to return numeric value");
     }
 
diff --git a/libinterp/corefcn/qz.cc b/libinterp/corefcn/qz.cc
--- a/libinterp/corefcn/qz.cc
+++ b/libinterp/corefcn/qz.cc
@@ -320,17 +320,17 @@ Note: @code{qz} performs permutation bal
     }
   else if (nc != nn)
     err_square_matrix_required ("qz", "A");
 
   // Matrix A: get value.
   Matrix aa;
   ComplexMatrix caa;
 
-  if (args(0).is_complex_type ())
+  if (args(0).iscomplex ())
     caa = args(0).complex_matrix_value ();
   else
     aa = args(0).matrix_value ();
 
 #if defined (DEBUG)
   std::cout << "qz: check matrix B" << std::endl;
 #endif
 
@@ -339,26 +339,26 @@ Note: @code{qz} performs permutation bal
   F77_INT b_nc = octave::to_f77_int (args(1).columns ());
 
   if (nn != b_nc || nn != b_nr)
     err_nonconformant ();
 
   Matrix bb;
   ComplexMatrix cbb;
 
-  if (args(1).is_complex_type ())
+  if (args(1).iscomplex ())
     cbb = args(1).complex_matrix_value ();
   else
     bb = args(1).matrix_value ();
 
   // Both matrices loaded, now check whether to calculate complex or real val.
 
   // declared volatile to avoid compiler warnings about long jumps vforks.
   volatile bool complex_case
-    = (args(0).is_complex_type () || args(1).is_complex_type ());
+    = (args(0).iscomplex () || args(1).iscomplex ());
 
   if (nargin == 3 && complex_case)
     error ("qz: cannot re-order complex qz decomposition");
 
   // First, declare variables used in both the real and complex cases.
   // FIXME: There are a lot of excess variables declared.
   //        Probably a better way to handle this.
   Matrix QQ (nn,nn), ZZ (nn,nn), VR (nn,nn), VL (nn,nn);
diff --git a/libinterp/corefcn/rcond.cc b/libinterp/corefcn/rcond.cc
--- a/libinterp/corefcn/rcond.cc
+++ b/libinterp/corefcn/rcond.cc
@@ -50,32 +50,32 @@ instead.
 
   octave_value retval;
 
   if (args(0).is_sparse_type ())
     error ("rcond: for sparse matrices use 'rcond (full (a))' or 'condest (a)' instead");
 
   if (args(0).is_single_type ())
     {
-      if (args(0).is_complex_type ())
+      if (args(0).iscomplex ())
         {
           FloatComplexMatrix m = args(0).float_complex_matrix_value ();
           MatrixType mattyp;
           retval = m.rcond (mattyp);
           args(0).matrix_type (mattyp);
         }
       else
         {
           FloatMatrix m = args(0).float_matrix_value ();
           MatrixType mattyp;
           retval = m.rcond (mattyp);
           args(0).matrix_type (mattyp);
         }
     }
-  else if (args(0).is_complex_type ())
+  else if (args(0).iscomplex ())
     {
       ComplexMatrix m = args(0).complex_matrix_value ();
       MatrixType mattyp;
       retval = m.rcond (mattyp);
       args(0).matrix_type (mattyp);
     }
   else
     {
diff --git a/libinterp/corefcn/schur.cc b/libinterp/corefcn/schur.cc
--- a/libinterp/corefcn/schur.cc
+++ b/libinterp/corefcn/schur.cc
@@ -288,17 +288,17 @@ Note also that @var{U} and @var{T} are n
 {
   if (args.length () != 2 || nargout > 2)
     print_usage ();
 
   if (! args(0).is_numeric_type ())
     err_wrong_type_arg ("rsf2csf", args(0));
   if (! args(1).is_numeric_type ())
     err_wrong_type_arg ("rsf2csf", args(1));
-  if (args(0).is_complex_type () || args(1).is_complex_type ())
+  if (args(0).iscomplex () || args(1).iscomplex ())
     error ("rsf2csf: UR and TR must be real matrices");
 
   if (args(0).is_single_type () || args(1).is_single_type ())
     {
       FloatMatrix u = args(0).float_matrix_value ();
       FloatMatrix t = args(1).float_matrix_value ();
 
       octave::math::schur<FloatComplexMatrix> cs
diff --git a/libinterp/corefcn/sparse-xpow.cc b/libinterp/corefcn/sparse-xpow.cc
--- a/libinterp/corefcn/sparse-xpow.cc
+++ b/libinterp/corefcn/sparse-xpow.cc
@@ -226,17 +226,17 @@ xpow (const SparseComplexMatrix& a, doub
 // in practice?
 
 template <typename S, typename SM>
 inline octave_value
 scalar_xpow (const S& a, const SM& b)
 {
   octave_value val = elem_xpow (a, b);
 
-  if (val.is_complex_type ())
+  if (val.iscomplex ())
     return SparseComplexMatrix (val.complex_matrix_value ());
   else
     return SparseMatrix (val.matrix_value ());
 }
 
 /*
 %!assert (sparse (2) .^ [3, 4], sparse ([8, 16]))
 %!assert <47775> (sparse (2i) .^ [3, 4], sparse ([-0-8i, 16]))
diff --git a/libinterp/corefcn/sparse.cc b/libinterp/corefcn/sparse.cc
--- a/libinterp/corefcn/sparse.cc
+++ b/libinterp/corefcn/sparse.cc
@@ -134,17 +134,17 @@ Compressed Column Sparse (rows = 3, cols
   frame.protect_var (Vsparse_auto_mutate);
   Vsparse_auto_mutate = false;
 
   if (nargin == 1)
     {
       octave_value arg = args(0);
       if (arg.islogical ())
         retval = arg.sparse_bool_matrix_value ();
-      else if (arg.is_complex_type ())
+      else if (arg.iscomplex ())
         retval = arg.sparse_complex_matrix_value ();
       else if (arg.is_numeric_type ())
         retval = arg.sparse_matrix_value ();
       else
         err_wrong_type_arg ("sparse", arg);
     }
   else if (nargin == 2)
     {
@@ -195,17 +195,17 @@ Compressed Column Sparse (rows = 3, cols
         {
           idx_vector i = args(0).index_vector ();
           k = 1;
           idx_vector j = args(1).index_vector ();
 
           if (args(2).islogical ())
             retval = SparseBoolMatrix (args(2).bool_array_value (), i,j,
                                        m, n, summation, nzmax);
-          else if (args(2).is_complex_type ())
+          else if (args(2).iscomplex ())
             retval = SparseComplexMatrix (args(2).complex_array_value(),
                                           i, j, m, n, summation, nzmax);
           else if (args(2).is_numeric_type ())
             retval = SparseMatrix (args(2).array_value (), i, j,
                                    m, n, summation, nzmax);
           else
             err_wrong_type_arg ("sparse", args(2));
         }
diff --git a/libinterp/corefcn/sqrtm.cc b/libinterp/corefcn/sqrtm.cc
--- a/libinterp/corefcn/sqrtm.cc
+++ b/libinterp/corefcn/sqrtm.cc
@@ -89,17 +89,17 @@ template <typename Matrix, typename Comp
 static octave_value
 do_sqrtm (const octave_value& arg)
 {
 
   octave_value retval;
 
   MatrixType mt = arg.matrix_type ();
 
-  bool iscomplex = arg.is_complex_type ();
+  bool iscomplex = arg.iscomplex ();
 
   typedef typename Matrix::element_type real_type;
 
   real_type cutoff = 0;
   real_type one = 1;
   real_type eps = std::numeric_limits<real_type>::epsilon ();
 
   if (! iscomplex)
diff --git a/libinterp/corefcn/svd.cc b/libinterp/corefcn/svd.cc
--- a/libinterp/corefcn/svd.cc
+++ b/libinterp/corefcn/svd.cc
@@ -196,17 +196,17 @@ and may be less accurate for some matric
 
           if (nargout == 0 || nargout == 1)
             retval(0) = sigma.extract_diag ();
           else
             retval = ovl (result.left_singular_matrix (),
                           sigma,
                           result.right_singular_matrix ());
         }
-      else if (arg.is_complex_type ())
+      else if (arg.iscomplex ())
         {
           FloatComplexMatrix ctmp = arg.float_complex_matrix_value ();
 
           if (ctmp.any_element_is_inf_or_nan ())
             error ("svd: cannot take SVD of matrix containing Inf or NaN values");
 
           octave::math::svd<FloatComplexMatrix> result
             (ctmp,
@@ -241,17 +241,17 @@ and may be less accurate for some matric
 
           if (nargout == 0 || nargout == 1)
             retval(0) = sigma.extract_diag ();
           else
             retval = ovl (result.left_singular_matrix (),
                           sigma,
                           result.right_singular_matrix ());
         }
-      else if (arg.is_complex_type ())
+      else if (arg.iscomplex ())
         {
           ComplexMatrix ctmp = arg.complex_matrix_value ();
 
           if (ctmp.any_element_is_inf_or_nan ())
             error ("svd: cannot take SVD of matrix containing Inf or NaN values");
 
           octave::math::svd<ComplexMatrix> result
             (ctmp,
diff --git a/libinterp/corefcn/sylvester.cc b/libinterp/corefcn/sylvester.cc
--- a/libinterp/corefcn/sylvester.cc
+++ b/libinterp/corefcn/sylvester.cc
@@ -95,19 +95,19 @@ sylvester ([1, 2; 3, 4], [5, 6; 7, 8], [
     err_square_matrix_required ("sylvester", "A");
   if (b_nr != b_nc)
     err_square_matrix_required ("sylvester", "B");
   if (a_nr != c_nr || b_nr != c_nc)
     err_nonconformant ();
 
   if (isfloat)
     {
-      if (arg_a.is_complex_type ()
-          || arg_b.is_complex_type ()
-          || arg_c.is_complex_type ())
+      if (arg_a.iscomplex ()
+          || arg_b.iscomplex ()
+          || arg_c.iscomplex ())
         {
           // Do everything in complex arithmetic;
 
           FloatComplexMatrix ca = arg_a.float_complex_matrix_value ();
           FloatComplexMatrix cb = arg_b.float_complex_matrix_value ();
           FloatComplexMatrix cc = arg_c.float_complex_matrix_value ();
 
           retval = Sylvester (ca, cb, cc);
@@ -120,19 +120,19 @@ sylvester ([1, 2; 3, 4], [5, 6; 7, 8], [
           FloatMatrix cb = arg_b.float_matrix_value ();
           FloatMatrix cc = arg_c.float_matrix_value ();
 
           retval = Sylvester (ca, cb, cc);
         }
     }
   else
     {
-      if (arg_a.is_complex_type ()
-          || arg_b.is_complex_type ()
-          || arg_c.is_complex_type ())
+      if (arg_a.iscomplex ()
+          || arg_b.iscomplex ()
+          || arg_c.iscomplex ())
         {
           // Do everything in complex arithmetic;
 
           ComplexMatrix ca = arg_a.complex_matrix_value ();
           ComplexMatrix cb = arg_b.complex_matrix_value ();
           ComplexMatrix cc = arg_c.complex_matrix_value ();
 
           retval = Sylvester (ca, cb, cc);
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -1610,17 +1610,17 @@ symbol_table::do_workspace_info (void) c
                 storage = 'i';
 
               std::ostringstream buf;
               val.short_disp (buf);
               std::string short_disp_str = buf.str ();
 
               workspace_element elt (storage, nm, val.class_name (),
                                      short_disp_str, dv.str (),
-                                     val.is_complex_type ());
+                                     val.iscomplex ());
 
               retval.push_back (elt);
             }
         }
     }
 
   return retval;
 }
diff --git a/libinterp/corefcn/typecast.cc b/libinterp/corefcn/typecast.cc
--- a/libinterp/corefcn/typecast.cc
+++ b/libinterp/corefcn/typecast.cc
@@ -180,17 +180,17 @@ typecast (@var{x}, "uint8")
         get_data_and_bytesize (array.uint32_array_value (), data, byte_size,
                                old_dims, frame);
       else if (array.is_uint64_type ())
         get_data_and_bytesize (array.uint64_array_value (), data, byte_size,
                                old_dims, frame);
       else
         assert (0);
     }
-  else if (array.is_complex_type ())
+  else if (array.iscomplex ())
     {
       if (array.is_single_type ())
         get_data_and_bytesize (array.float_complex_array_value (), data,
                                byte_size, old_dims, frame);
       else
         get_data_and_bytesize (array.complex_array_value (), data,
                                byte_size, old_dims, frame);
     }
@@ -513,17 +513,17 @@ column vector.
         retval = do_bitunpack (array.uint16_array_value ());
       else if (array.is_uint32_type ())
         retval = do_bitunpack (array.uint32_array_value ());
       else if (array.is_uint64_type ())
         retval = do_bitunpack (array.uint64_array_value ());
       else
         assert (0);
     }
-  else if (array.is_complex_type ())
+  else if (array.iscomplex ())
     {
       if (array.is_single_type ())
         retval = do_bitunpack (array.float_complex_array_value ());
       else
         retval = do_bitunpack (array.complex_array_value ());
     }
   else if (array.is_real_type ())
     {
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -1154,17 +1154,17 @@ private:
   struct symbol_info
   {
     symbol_info (const symbol_table::symbol_record& sr,
                  const std::string& expr_str = "",
                  const octave_value& expr_val = octave_value ())
       : name (expr_str.empty () ? sr.name () : expr_str),
         varval (expr_val.is_undefined () ? sr.varval () : expr_val),
         is_automatic (sr.is_automatic ()),
-        is_complex (varval.is_complex_type ()),
+        is_complex (varval.iscomplex ()),
         is_formal (sr.is_formal ()),
         is_global (sr.is_global ()),
         is_persistent (sr.is_persistent ())
     { }
 
     void display_line (std::ostream& os,
                        const std::list<whos_parameter>& params) const
     {
@@ -1360,17 +1360,17 @@ public:
         persistent_info(j) = si.is_persistent;
 
         octave_value val = si.varval;
 
         size_info(j) = val.size ();
         bytes_info(j) = val.byte_size ();
         class_info(j) = val.class_name ();
         sparse_info(j) = val.is_sparse_type ();
-        complex_info(j) = val.is_complex_type ();
+        complex_info(j) = val.iscomplex ();
         nesting_info(j) = ni;
       }
 
     octave_map info;
 
     info.assign ("name", name_info);
     info.assign ("size", size_info);
     info.assign ("bytes", bytes_info);
diff --git a/libinterp/corefcn/xnorm.cc b/libinterp/corefcn/xnorm.cc
--- a/libinterp/corefcn/xnorm.cc
+++ b/libinterp/corefcn/xnorm.cc
@@ -32,17 +32,17 @@ along with Octave; see the file COPYING.
 #include "ov.h"
 #include "xnorm.h"
 
 octave_value xnorm (const octave_value& x, const octave_value& p)
 {
   octave_value retval;
 
   bool isvector = (x.columns () == 1 || x.rows () == 1);
-  bool iscomplex = x.is_complex_type ();
+  bool iscomplex = x.iscomplex ();
   bool issparse = x.is_sparse_type ();
   bool isfloat = x.is_single_type ();
 
   if (! isfloat && ! x.is_double_type ())
     err_wrong_type_arg ("xnorm", x);
 
   if (x.isempty ())
     retval = octave_value (0);
@@ -88,17 +88,17 @@ octave_value xnorm (const octave_value& 
 
   return retval;
 }
 
 octave_value xcolnorms (const octave_value& x, const octave_value& p)
 {
   octave_value retval;
 
-  bool iscomplex = x.is_complex_type ();
+  bool iscomplex = x.iscomplex ();
   bool issparse = x.is_sparse_type ();
   bool isfloat = x.is_single_type ();
 
   if (! isfloat && ! x.is_double_type ())
     err_wrong_type_arg ("xcolnorms", x);
 
   if (issparse)
     {
@@ -127,17 +127,17 @@ octave_value xcolnorms (const octave_val
 
   return retval;
 }
 
 octave_value xrownorms (const octave_value& x, const octave_value& p)
 {
   octave_value retval;
 
-  bool iscomplex = x.is_complex_type ();
+  bool iscomplex = x.iscomplex ();
   bool issparse = x.is_sparse_type ();
   bool isfloat = x.is_single_type ();
 
   if (! isfloat && ! x.is_double_type ())
     err_wrong_type_arg ("xrownorms", x);
 
   if (issparse)
     {
@@ -166,17 +166,17 @@ octave_value xrownorms (const octave_val
 
   return retval;
 }
 
 octave_value xfrobnorm (const octave_value& x)
 {
   octave_value retval;
 
-  bool iscomplex = x.is_complex_type ();
+  bool iscomplex = x.iscomplex ();
   bool issparse = x.is_sparse_type ();
   bool isfloat = x.is_single_type ();
 
   if (! isfloat && ! x.is_double_type ())
     err_wrong_type_arg ("xfrobnorm", x);
 
   if (issparse)
     {
diff --git a/libinterp/dldfcn/__eigs__.cc b/libinterp/dldfcn/__eigs__.cc
--- a/libinterp/dldfcn/__eigs__.cc
+++ b/libinterp/dldfcn/__eigs__.cc
@@ -69,17 +69,17 @@ eigs_func (const ColumnVector& x, int& e
         }
       catch (octave::execution_exception& e)
         {
           err_user_supplied_eval (e, "eigs");
         }
 
       if (tmp.length () && tmp(0).is_defined ())
         {
-          if (! warned_imaginary && tmp(0).is_complex_type ())
+          if (! warned_imaginary && tmp(0).iscomplex ())
             {
               warning ("eigs: ignoring imaginary part returned from user-supplied function");
               warned_imaginary = true;
             }
 
           retval = tmp(0).xvector_value ("eigs: evaluation of user-supplied function failed");
         }
       else
@@ -225,17 +225,17 @@ Undocumented internal function.
         error ("eigs: incorrect number of arguments");
 
       n = args(1).nint_value ();
       arg_offset = 1;
       have_a_fun = true;
     }
   else
     {
-      if (args(0).is_complex_type ())
+      if (args(0).iscomplex ())
         {
           if (args(0).is_sparse_type ())
             {
               ascm = (args(0).sparse_complex_matrix_value ());
               a_is_sparse = true;
             }
           else
             acm = (args(0).complex_matrix_value ());
@@ -257,17 +257,17 @@ Undocumented internal function.
         }
     }
 
   // Note hold off reading B until later to avoid issues of double
   // copies of the matrix if B is full/real while A is complex.
   if (nargin > 1 + arg_offset
       && ! (args(1 + arg_offset).is_real_scalar ()))
     {
-      if (args(1+arg_offset).is_complex_type ())
+      if (args(1+arg_offset).iscomplex ())
         {
           b_arg = 1+arg_offset;
           have_b = true;
           b_is_complex = true;
           arg_offset++;
         }
       else
         {
diff --git a/libinterp/dldfcn/amd.cc b/libinterp/dldfcn/amd.cc
--- a/libinterp/dldfcn/amd.cc
+++ b/libinterp/dldfcn/amd.cc
@@ -85,17 +85,17 @@ The author of the code itself is Timothy
 
   octave_idx_type n_row, n_col;
   const octave::suitesparse_integer *ridx, *cidx;
   SparseMatrix sm;
   SparseComplexMatrix scm;
 
   if (args(0).is_sparse_type ())
     {
-      if (args(0).is_complex_type ())
+      if (args(0).iscomplex ())
         {
           scm = args(0).sparse_complex_matrix_value ();
           n_row = scm.rows ();
           n_col = scm.cols ();
           ridx = octave::to_suitesparse_intptr (scm.xridx ());
           cidx = octave::to_suitesparse_intptr (scm.xcidx ());
         }
       else
@@ -104,17 +104,17 @@ The author of the code itself is Timothy
           n_row = sm.rows ();
           n_col = sm.cols ();
           ridx = octave::to_suitesparse_intptr (sm.xridx ());
           cidx = octave::to_suitesparse_intptr (sm.xcidx ());
         }
     }
   else
     {
-      if (args(0).is_complex_type ())
+      if (args(0).iscomplex ())
         sm = SparseMatrix (real (args(0).complex_matrix_value ()));
       else
         sm = SparseMatrix (args(0).matrix_value ());
 
       n_row = sm.rows ();
       n_col = sm.cols ();
       ridx = octave::to_suitesparse_intptr (sm.xridx ());
       cidx = octave::to_suitesparse_intptr (sm.xcidx ());
diff --git a/libinterp/dldfcn/ccolamd.cc b/libinterp/dldfcn/ccolamd.cc
--- a/libinterp/dldfcn/ccolamd.cc
+++ b/libinterp/dldfcn/ccolamd.cc
@@ -208,17 +208,17 @@ ccolamd, csymamd, amd, colamd, symamd, a
 
   octave_idx_type n_row, n_col, nnz;
   octave_idx_type *ridx, *cidx;
   SparseComplexMatrix scm;
   SparseMatrix sm;
 
   if (args(0).is_sparse_type ())
     {
-      if (args(0).is_complex_type ())
+      if (args(0).iscomplex ())
         {
           scm = args(0).sparse_complex_matrix_value ();
           n_row = scm.rows ();
           n_col = scm.cols ();
           nnz = scm.nnz ();
           ridx = scm.xridx ();
           cidx = scm.xcidx ();
         }
@@ -230,17 +230,17 @@ ccolamd, csymamd, amd, colamd, symamd, a
           n_col = sm.cols ();
           nnz = sm.nnz ();
           ridx = sm.xridx ();
           cidx = sm.xcidx ();
         }
     }
   else
     {
-      if (args(0).is_complex_type ())
+      if (args(0).iscomplex ())
         sm = SparseMatrix (real (args(0).complex_matrix_value ()));
       else
         sm = SparseMatrix (args(0).matrix_value ());
 
       n_row = sm.rows ();
       n_col = sm.cols ();
       nnz = sm.nnz ();
       ridx = sm.xridx ();
@@ -452,17 +452,17 @@ ccolamd, csymamd, amd, colamd, symamd, a
 
   octave_idx_type n_row, n_col;
   octave_idx_type *ridx, *cidx;
   SparseMatrix sm;
   SparseComplexMatrix scm;
 
   if (args(0).is_sparse_type ())
     {
-      if (args(0).is_complex_type ())
+      if (args(0).iscomplex ())
         {
           scm = args(0).sparse_complex_matrix_value ();
           n_row = scm.rows ();
           n_col = scm.cols ();
           ridx = scm.xridx ();
           cidx = scm.xcidx ();
         }
       else
@@ -471,17 +471,17 @@ ccolamd, csymamd, amd, colamd, symamd, a
           n_row = sm.rows ();
           n_col = sm.cols ();
           ridx = sm.xridx ();
           cidx = sm.xcidx ();
         }
     }
   else
     {
-      if (args(0).is_complex_type ())
+      if (args(0).iscomplex ())
         sm = SparseMatrix (real (args(0).complex_matrix_value ()));
       else
         sm = SparseMatrix (args(0).matrix_value ());
 
       n_row = sm.rows ();
       n_col = sm.cols ();
       ridx = sm.xridx ();
       cidx = sm.xcidx ();
diff --git a/libinterp/dldfcn/chol.cc b/libinterp/dldfcn/chol.cc
--- a/libinterp/dldfcn/chol.cc
+++ b/libinterp/dldfcn/chol.cc
@@ -205,17 +205,17 @@ sparse matrices.
               if (LLt)
                 retval(0) = fact.L ();
               else
                 retval(0) = fact.R ();
             }
           else
             error ("chol: input matrix must be positive definite");
         }
-      else if (arg.is_complex_type ())
+      else if (arg.iscomplex ())
         {
           SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
 
           octave::math::sparse_chol<SparseComplexMatrix> fact (m, info, natural, force);
 
           if (nargout == 3)
             {
               if (vecout)
@@ -250,17 +250,17 @@ sparse matrices.
 
           octave::math::chol<FloatMatrix> fact (m, info, LLt != true);
 
           if (nargout == 2 || info == 0)
             retval = ovl (get_chol (fact), info);
           else
             error ("chol: input matrix must be positive definite");
         }
-      else if (arg.is_complex_type ())
+      else if (arg.iscomplex ())
         {
           FloatComplexMatrix m = arg.float_complex_matrix_value ();
 
           octave_idx_type info;
 
           octave::math::chol<FloatComplexMatrix> fact (m, info, LLt != true);
 
           if (nargout == 2 || info == 0)
@@ -283,17 +283,17 @@ sparse matrices.
 
           octave::math::chol<Matrix> fact (m, info, LLt != true);
 
           if (nargout == 2 || info == 0)
             retval = ovl (get_chol (fact), info);
           else
             error ("chol: input matrix must be positive definite");
         }
-      else if (arg.is_complex_type ())
+      else if (arg.iscomplex ())
         {
           ComplexMatrix m = arg.complex_matrix_value ();
 
           octave_idx_type info;
 
           octave::math::chol<ComplexMatrix> fact (m, info, LLt != true);
 
           if (nargout == 2 || info == 0)
@@ -384,17 +384,17 @@ the Cholesky@tie{}factorization.
 
               octave::math::sparse_chol<SparseMatrix> chol (m, info);
 
               if (info == 0)
                 retval = chol.inverse ();
               else
                 error ("cholinv: A must be positive definite");
             }
-          else if (arg.is_complex_type ())
+          else if (arg.iscomplex ())
             {
               SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
 
               octave::math::sparse_chol<SparseComplexMatrix> chol (m, info);
 
               if (info == 0)
                 retval = chol.inverse ();
               else
@@ -411,17 +411,17 @@ the Cholesky@tie{}factorization.
 
               octave_idx_type info;
               octave::math::chol<FloatMatrix> chol (m, info);
               if (info == 0)
                 retval = chol.inverse ();
               else
                 error ("cholinv: A must be positive definite");
             }
-          else if (arg.is_complex_type ())
+          else if (arg.iscomplex ())
             {
               FloatComplexMatrix m = arg.float_complex_matrix_value ();
 
               octave_idx_type info;
               octave::math::chol<FloatComplexMatrix> chol (m, info);
               if (info == 0)
                 retval = chol.inverse ();
               else
@@ -438,17 +438,17 @@ the Cholesky@tie{}factorization.
 
               octave_idx_type info;
               octave::math::chol<Matrix> chol (m, info);
               if (info == 0)
                 retval = chol.inverse ();
               else
                 error ("cholinv: A must be positive definite");
             }
-          else if (arg.is_complex_type ())
+          else if (arg.iscomplex ())
             {
               ComplexMatrix m = arg.complex_matrix_value ();
 
               octave_idx_type info;
               octave::math::chol<ComplexMatrix> chol (m, info);
               if (info == 0)
                 retval = chol.inverse ();
               else
@@ -506,34 +506,34 @@ diagonal elements.  @code{chol2inv (@var
       if (arg.is_sparse_type ())
         {
           if (arg.is_real_type ())
             {
               SparseMatrix r = arg.sparse_matrix_value ();
 
               retval = octave::math::chol2inv (r);
             }
-          else if (arg.is_complex_type ())
+          else if (arg.iscomplex ())
             {
               SparseComplexMatrix r = arg.sparse_complex_matrix_value ();
 
               retval = octave::math::chol2inv (r);
             }
           else
             err_wrong_type_arg ("chol2inv", arg);
         }
       else if (arg.is_single_type ())
         {
           if (arg.is_real_type ())
             {
               FloatMatrix r = arg.float_matrix_value ();
 
               retval = octave::math::chol2inv (r);
             }
-          else if (arg.is_complex_type ())
+          else if (arg.iscomplex ())
             {
               FloatComplexMatrix r = arg.float_complex_matrix_value ();
 
               retval = octave::math::chol2inv (r);
             }
           else
             err_wrong_type_arg ("chol2inv", arg);
 
@@ -541,17 +541,17 @@ diagonal elements.  @code{chol2inv (@var
       else
         {
           if (arg.is_real_type ())
             {
               Matrix r = arg.matrix_value ();
 
               retval = octave::math::chol2inv (r);
             }
-          else if (arg.is_complex_type ())
+          else if (arg.iscomplex ())
             {
               ComplexMatrix r = arg.complex_matrix_value ();
 
               retval = octave::math::chol2inv (r);
             }
           else
             err_wrong_type_arg ("chol2inv", arg);
         }
diff --git a/libinterp/dldfcn/colamd.cc b/libinterp/dldfcn/colamd.cc
--- a/libinterp/dldfcn/colamd.cc
+++ b/libinterp/dldfcn/colamd.cc
@@ -330,17 +330,17 @@ Xerox PARC, and @nospell{Esmond Ng}, Oak
 
   octave_idx_type n_row, n_col, nnz;
   octave_idx_type *ridx, *cidx;
   SparseComplexMatrix scm;
   SparseMatrix sm;
 
   if (args(0).is_sparse_type ())
     {
-      if (args(0).is_complex_type ())
+      if (args(0).iscomplex ())
         {
           scm = args(0).sparse_complex_matrix_value ();
           n_row = scm.rows ();
           n_col = scm.cols ();
           nnz = scm.nnz ();
           ridx = scm.xridx ();
           cidx = scm.xcidx ();
         }
@@ -352,17 +352,17 @@ Xerox PARC, and @nospell{Esmond Ng}, Oak
           n_col = sm.cols ();
           nnz = sm.nnz ();
           ridx = sm.xridx ();
           cidx = sm.xcidx ();
         }
     }
   else
     {
-      if (args(0).is_complex_type ())
+      if (args(0).iscomplex ())
         sm = SparseMatrix (real (args(0).complex_matrix_value ()));
       else
         sm = SparseMatrix (args(0).matrix_value ());
 
       n_row = sm.rows ();
       n_col = sm.cols ();
       nnz = sm.nnz ();
       ridx = sm.xridx ();
@@ -540,17 +540,17 @@ Xerox PARC, and @nospell{Esmond Ng}, Oak
 
   octave_idx_type n_row, n_col;
   octave_idx_type *ridx, *cidx;
   SparseMatrix sm;
   SparseComplexMatrix scm;
 
   if (args(0).is_sparse_type ())
     {
-      if (args(0).is_complex_type ())
+      if (args(0).iscomplex ())
         {
           scm = args(0).sparse_complex_matrix_value ();
           n_row = scm.rows ();
           n_col = scm.cols ();
           ridx = scm.xridx ();
           cidx = scm.xcidx ();
         }
       else
@@ -559,17 +559,17 @@ Xerox PARC, and @nospell{Esmond Ng}, Oak
           n_row = sm.rows ();
           n_col = sm.cols ();
           ridx = sm.xridx ();
           cidx = sm.xcidx ();
         }
     }
   else
     {
-      if (args(0).is_complex_type ())
+      if (args(0).iscomplex ())
         sm = SparseMatrix (real (args(0).complex_matrix_value ()));
       else
         sm = SparseMatrix (args(0).matrix_value ());
 
       n_row = sm.rows ();
       n_col = sm.cols ();
       ridx = sm.xridx ();
       cidx = sm.xcidx ();
@@ -665,17 +665,17 @@ permutations on the tree.
   octave_idx_type n_row = 0;
   octave_idx_type n_col = 0;
   octave_idx_type *ridx = nullptr;
   octave_idx_type *cidx = nullptr;
 
   if (args(0).is_sparse_type ())
     error ("etree: S must be a sparse matrix");
 
-  if (args(0).is_complex_type ())
+  if (args(0).iscomplex ())
     {
       SparseComplexMatrix scm = args(0).sparse_complex_matrix_value ();
 
       n_row = scm.rows ();
       n_col = scm.cols ();
       ridx = scm.xridx ();
       cidx = scm.xcidx ();
     }
diff --git a/libinterp/dldfcn/qr.cc b/libinterp/dldfcn/qr.cc
--- a/libinterp/dldfcn/qr.cc
+++ b/libinterp/dldfcn/qr.cc
@@ -229,17 +229,17 @@ permutation vector instead of a permutat
 
   octave_value arg = args(0);
 
   bool economy = false;
   bool is_cmplx = false;
   bool have_b = 0;
   bool vector_p = 0;
 
-  if (arg.is_complex_type ())
+  if (arg.iscomplex ())
     is_cmplx = true;
   if (nargin > 1)
     {
       have_b = true;
       if (args(nargin-1).is_scalar_type ())
         {
           int val = args(nargin-1).int_value ();
           if (val == 0)
@@ -259,17 +259,17 @@ permutation vector instead of a permutat
                    args(nargin-1).string_value ().c_str ());
           have_b = (nargin > 2);
         }
       else if (! args(nargin-1).is_matrix_type ())
         err_wrong_type_arg ("qr", args(nargin-1));
       else if (nargin == 3)   // should be caught by is_scalar_type or is_string
         print_usage ();
 
-      if (have_b && args(1).is_complex_type ())
+      if (have_b && args(1).iscomplex ())
         is_cmplx = true;
     }
 
   if (arg.is_sparse_type ())
     {
       if (nargout > 2)
         error ("qr: Permutation output is not supported for sparse input");
 
@@ -351,17 +351,17 @@ permutation vector instead of a permutat
                     if (type == octave::math::qr<FloatMatrix>::economy || vector_p)
                       retval = ovl (fact.Q (), get_qr_r (fact), fact.Pvec ());
                     else
                       retval = ovl (fact.Q (), get_qr_r (fact), fact.P ());
                   }
                   break;
                 }
             }
-          else if (arg.is_complex_type ())
+          else if (arg.iscomplex ())
             {
               octave::math::qr<FloatComplexMatrix>::type type
                 = qr_type<FloatComplexMatrix> (nargin, nargout);
 
               FloatComplexMatrix m = arg.float_complex_matrix_value ();
 
               switch (nargout)
                 {
@@ -435,17 +435,17 @@ permutation vector instead of a permutat
                     if (type == octave::math::qr<Matrix>::economy || vector_p)
                       retval = ovl (fact.Q (), get_qr_r (fact), fact.Pvec ());
                     else
                       retval = ovl (fact.Q (), get_qr_r (fact), fact.P ());
                   }
                   break;
                 }
             }
-          else if (arg.is_complex_type ())
+          else if (arg.iscomplex ())
             {
               octave::math::qr<ComplexMatrix>::type type
                 = qr_type<ComplexMatrix> (nargin, nargout);
 
               ComplexMatrix m = arg.complex_matrix_value ();
 
               switch (nargout)
                 {
diff --git a/libinterp/dldfcn/symbfact.cc b/libinterp/dldfcn/symbfact.cc
--- a/libinterp/dldfcn/symbfact.cc
+++ b/libinterp/dldfcn/symbfact.cc
@@ -139,17 +139,17 @@ Cholesky@tie{}factorization as determine
       A->p = a.cidx ();
       A->i = a.ridx ();
       A->nzmax = a.nnz ();
       A->xtype = CHOLMOD_REAL;
 
       if (a.rows () > 0 && a.cols () > 0)
         A->x = a.data ();
     }
-  else if (args(0).is_complex_type ())
+  else if (args(0).iscomplex ())
     {
       const SparseComplexMatrix a = args(0).sparse_complex_matrix_value ();
       A->nrow = a.rows ();
       A->ncol = a.cols ();
       A->p = a.cidx ();
       A->i = a.ridx ();
       A->nzmax = a.nnz ();
       A->xtype = CHOLMOD_COMPLEX;
diff --git a/libinterp/octave-value/ov-base.h b/libinterp/octave-value/ov-base.h
--- a/libinterp/octave-value/ov-base.h
+++ b/libinterp/octave-value/ov-base.h
@@ -410,17 +410,17 @@ public:
   virtual bool is_uint64_type (void) const { return false; }
 
   virtual bool islogical (void) const { return false; }
 
   virtual bool isinteger (void) const { return false; }
 
   virtual bool is_real_type (void) const { return false; }
 
-  virtual bool is_complex_type (void) const { return false; }
+  virtual bool iscomplex (void) const { return false; }
 
   // Would be nice to get rid of the next four functions:
 
   virtual bool is_scalar_type (void) const { return false; }
 
   virtual bool is_matrix_type (void) const { return false; }
 
   virtual bool is_numeric_type (void) const { return false; }
diff --git a/libinterp/octave-value/ov-complex.h b/libinterp/octave-value/ov-complex.h
--- a/libinterp/octave-value/ov-complex.h
+++ b/libinterp/octave-value/ov-complex.h
@@ -87,17 +87,17 @@ public:
             && ! (lo_ieee_isnan (scalar.real ())
                   || lo_ieee_isnan (scalar.imag ())));
   }
 
   builtin_type_t builtin_type (void) const { return btyp_complex; }
 
   bool is_complex_scalar (void) const { return true; }
 
-  bool is_complex_type (void) const { return true; }
+  bool iscomplex (void) const { return true; }
 
   bool is_double_type (void) const { return true; }
 
   bool is_float_type (void) const { return true; }
 
   double double_value (bool = false) const;
 
   float float_value (bool = false) const;
diff --git a/libinterp/octave-value/ov-cx-diag.h b/libinterp/octave-value/ov-cx-diag.h
--- a/libinterp/octave-value/ov-cx-diag.h
+++ b/libinterp/octave-value/ov-cx-diag.h
@@ -60,17 +60,17 @@ public:
   type_conv_info numeric_demotion_function (void) const;
 
   octave_base_value * try_narrowing_conversion (void);
 
   builtin_type_t builtin_type (void) const { return btyp_complex; }
 
   bool is_complex_matrix (void) const { return true; }
 
-  bool is_complex_type (void) const { return true; }
+  bool iscomplex (void) const { return true; }
 
   bool is_double_type (void) const { return true; }
 
   bool is_float_type (void) const { return true; }
 
   DiagMatrix diag_matrix_value (bool = false) const;
 
   FloatDiagMatrix float_diag_matrix_value (bool = false) const;
diff --git a/libinterp/octave-value/ov-cx-mat.h b/libinterp/octave-value/ov-cx-mat.h
--- a/libinterp/octave-value/ov-cx-mat.h
+++ b/libinterp/octave-value/ov-cx-mat.h
@@ -89,17 +89,17 @@ public:
   type_conv_info numeric_demotion_function (void) const;
 
   octave_base_value * try_narrowing_conversion (void);
 
   builtin_type_t builtin_type (void) const { return btyp_complex; }
 
   bool is_complex_matrix (void) const { return true; }
 
-  bool is_complex_type (void) const { return true; }
+  bool iscomplex (void) const { return true; }
 
   bool is_double_type (void) const { return true; }
 
   bool is_float_type (void) const { return true; }
 
   double double_value (bool = false) const;
 
   float float_value (bool = false) const;
diff --git a/libinterp/octave-value/ov-cx-sparse.h b/libinterp/octave-value/ov-cx-sparse.h
--- a/libinterp/octave-value/ov-cx-sparse.h
+++ b/libinterp/octave-value/ov-cx-sparse.h
@@ -92,17 +92,17 @@ public:
   { return new octave_sparse_complex_matrix (); }
 
   octave_base_value * try_narrowing_conversion (void);
 
   builtin_type_t builtin_type (void) const { return btyp_complex; }
 
   bool is_complex_matrix (void) const { return true; }
 
-  bool is_complex_type (void) const { return true; }
+  bool iscomplex (void) const { return true; }
 
   bool is_double_type (void) const { return true; }
 
   bool is_float_type (void) const { return true; }
 
   double double_value (bool = false) const;
 
   double scalar_value (bool frc_str_conv = false) const
diff --git a/libinterp/octave-value/ov-flt-complex.h b/libinterp/octave-value/ov-flt-complex.h
--- a/libinterp/octave-value/ov-flt-complex.h
+++ b/libinterp/octave-value/ov-flt-complex.h
@@ -83,17 +83,17 @@ public:
             && ! (lo_ieee_isnan (scalar.real ())
                   || lo_ieee_isnan (scalar.imag ())));
   }
 
   builtin_type_t builtin_type (void) const { return btyp_float_complex; }
 
   bool is_complex_scalar (void) const { return true; }
 
-  bool is_complex_type (void) const { return true; }
+  bool iscomplex (void) const { return true; }
 
   bool is_single_type (void) const { return true; }
 
   bool is_float_type (void) const { return true; }
 
   double double_value (bool = false) const;
 
   float float_value (bool = false) const;
diff --git a/libinterp/octave-value/ov-flt-cx-diag.h b/libinterp/octave-value/ov-flt-cx-diag.h
--- a/libinterp/octave-value/ov-flt-cx-diag.h
+++ b/libinterp/octave-value/ov-flt-cx-diag.h
@@ -58,17 +58,17 @@ public:
   type_conv_info numeric_conversion_function (void) const;
 
   octave_base_value * try_narrowing_conversion (void);
 
   builtin_type_t builtin_type (void) const { return btyp_float_complex; }
 
   bool is_complex_matrix (void) const { return true; }
 
-  bool is_complex_type (void) const { return true; }
+  bool iscomplex (void) const { return true; }
 
   bool is_single_type (void) const { return true; }
 
   bool is_float_type (void) const { return true; }
 
   DiagMatrix diag_matrix_value (bool = false) const;
 
   FloatDiagMatrix float_diag_matrix_value (bool = false) const;
diff --git a/libinterp/octave-value/ov-flt-cx-mat.h b/libinterp/octave-value/ov-flt-cx-mat.h
--- a/libinterp/octave-value/ov-flt-cx-mat.h
+++ b/libinterp/octave-value/ov-flt-cx-mat.h
@@ -87,17 +87,17 @@ public:
   { return new octave_float_complex_matrix (); }
 
   octave_base_value * try_narrowing_conversion (void);
 
   builtin_type_t builtin_type (void) const { return btyp_float_complex; }
 
   bool is_complex_matrix (void) const { return true; }
 
-  bool is_complex_type (void) const { return true; }
+  bool iscomplex (void) const { return true; }
 
   bool is_single_type (void) const { return true; }
 
   bool is_float_type (void) const { return true; }
 
   double double_value (bool = false) const;
 
   float float_value (bool = false) const;
diff --git a/libinterp/octave-value/ov.h b/libinterp/octave-value/ov.h
--- a/libinterp/octave-value/ov.h
+++ b/libinterp/octave-value/ov.h
@@ -672,18 +672,22 @@ public:
 
   OCTAVE_DEPRECATED ("use 'isinteger' instead")
   bool is_integer_type (void) const
   { return rep->isinteger (); }
 
   bool is_real_type (void) const
   { return rep->is_real_type (); }
 
+  bool iscomplex (void) const
+  { return rep->iscomplex (); }
+
+  OCTAVE_DEPRECATED ("use 'iscomplex' instead")
   bool is_complex_type (void) const
-  { return rep->is_complex_type (); }
+  { return rep->iscomplex (); }
 
   bool is_scalar_type (void) const
   { return rep->is_scalar_type (); }
 
   bool is_matrix_type (void) const
   { return rep->is_matrix_type (); }
 
   bool is_numeric_type (void) const
diff --git a/libinterp/parse-tree/jit-typeinfo.cc b/libinterp/parse-tree/jit-typeinfo.cc
--- a/libinterp/parse-tree/jit-typeinfo.cc
+++ b/libinterp/parse-tree/jit-typeinfo.cc
@@ -2213,17 +2213,17 @@ jit_typeinfo::do_type_of (const octave_v
         = dynamic_cast<octave_builtin *> (ov.internal_rep ());
       return builtin && builtin->to_jit () ? builtin->to_jit ()
                                            : unknown_function;
     }
 
   if (ov.is_range ())
     return get_range ();
 
-  if (ov.is_double_type () && ! ov.is_complex_type ())
+  if (ov.is_double_type () && ! ov.iscomplex ())
     {
       if (ov.is_real_scalar ())
         return get_scalar ();
 
       if (ov.is_matrix_type ())
         return get_matrix ();
     }
 
diff --git a/libinterp/parse-tree/pt-tm-const.cc b/libinterp/parse-tree/pt-tm-const.cc
--- a/libinterp/parse-tree/pt-tm-const.cc
+++ b/libinterp/parse-tree/pt-tm-const.cc
@@ -97,17 +97,17 @@ namespace octave
       all_dq_str = false;
 
     if (! some_str && val.is_string ())
       some_str = true;
 
     if (all_real && ! val.is_real_type ())
       all_real = false;
 
-    if (all_cmplx && ! (val.is_complex_type () || val.is_real_type ()))
+    if (all_cmplx && ! (val.iscomplex () || val.is_real_type ()))
       all_cmplx = false;
 
     if (! any_cell && val.iscell ())
       any_cell = true;
 
     if (! any_sparse && val.is_sparse_type ())
       any_sparse = true;
 
