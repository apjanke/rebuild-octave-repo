# HG changeset patch
# User dbateman
# Date 1140473132 0
#      Mon Feb 20 22:05:32 2006 +0000
# Node ID 512d0d11ae396e0e3bb79818f59e7ab9e5dfabea
# Parent  489a475073d7b80c8b1f85884a18a51c30740847
[project @ 2006-02-20 22:05:30 by dbateman]

diff --git a/liboctave/CSparse.cc b/liboctave/CSparse.cc
--- a/liboctave/CSparse.cc
+++ b/liboctave/CSparse.cc
@@ -1102,49 +1102,52 @@ SparseComplexMatrix::determinant (octave
 #else
   (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::dsolve (SparseType &mattype, const Matrix& b, octave_idx_type& err, 
+SparseComplexMatrix::dsolve (SparseType &mattype, const Matrix& b,
+			     octave_idx_type& err, 
 			     double& rcond, solve_singularity_handler) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
+  octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr == 0 || nc == 0 || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Diagonal ||
 	  typ == SparseType::Permuted_Diagonal)
 	{
-	  retval.resize (b.rows (), b.cols());
+	  retval.resize (nc, b.cols(), Complex(0.,0.));
 	  if (typ == SparseType::Diagonal)
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
-	      for (octave_idx_type i = 0; i < nr; i++)
-		retval(i,j) = b(i,j) / data (i);
+		for (octave_idx_type i = 0; i < nm; i++)
+		  retval(i,j) = b(i,j) / data (i);
 	  else
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
-	      for (octave_idx_type i = 0; i < nr; i++)
-		retval(i,j) = b(ridx(i),j) / data (i);
+	      for (octave_idx_type k = 0; k < nc; k++)
+		for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+		  retval(k,j) = b(ridx(i),j) / data (i);
 	    
 	  double dmax = 0., dmin = octave_Inf; 
-	  for (octave_idx_type i = 0; i < nr; i++)
+	  for (octave_idx_type i = 0; i < nm; i++)
 	    {
 	      double tmp = std::abs(data(i));
 	      if (tmp > dmax)
 		dmax = tmp;
 	      if (tmp < dmin)
 		dmin = tmp;
 	    }
 	  rcond = dmin / dmax;
@@ -1153,77 +1156,79 @@ SparseComplexMatrix::dsolve (SparseType 
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::dsolve (SparseType &mattype, const SparseMatrix& b,
-		       octave_idx_type& err, double& rcond, solve_singularity_handler) const
+			     octave_idx_type& err, double& rcond, 
+			     solve_singularity_handler) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
+  octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr == 0 || nc == 0 || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Diagonal ||
 	  typ == SparseType::Permuted_Diagonal)
 	{
-	  octave_idx_type b_nr = b.rows ();
 	  octave_idx_type b_nc = b.cols ();
 	  octave_idx_type b_nz = b.nzmax ();
-	  retval = SparseComplexMatrix (b_nr, b_nc, b_nz);
+	  retval = SparseComplexMatrix (nc, b_nc, b_nz);
 
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  if (typ == SparseType::Diagonal)
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      {
 		for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		  {
 		    retval.xridx (ii) = b.ridx(i);
 		    retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
 		  }
 		retval.xcidx(j+1) = ii;
 	      }
 	  else
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      {
-		for (octave_idx_type i = 0; i < nr; i++)
-		  {
-		    bool found = false;
-		    octave_idx_type k;
-		    for (k = b.cidx(j); k < b.cidx(j+1); k++)
-		      if (ridx(i) == b.ridx(k))
+		for (octave_idx_type l = 0; l < nc; l++)
+		  for (octave_idx_type i = cidx(l); i < cidx(l+1); i++)
+		    {
+		      bool found = false;
+		      octave_idx_type k;
+		      for (k = b.cidx(j); k < b.cidx(j+1); k++)
+			if (ridx(i) == b.ridx(k))
+			  {
+			    found = true;
+			    break;
+			  }
+		      if (found)
 			{
-			  found = true;
-			  break;
+			  retval.xridx (ii) = l;
+			  retval.xdata (ii++) = b.data(k) / data (i);
 			}
-		    if (found)
-		      {
-			retval.xridx (ii) = i;
-			retval.xdata (ii++) = b.data(k) / data (i);
-		      }
-		  }
+		    }
 		retval.xcidx(j+1) = ii;
 	      }
 	    
 	  double dmax = 0., dmin = octave_Inf; 
-	  for (octave_idx_type i = 0; i < nr; i++)
+	  for (octave_idx_type i = 0; i < nm; i++)
 	    {
 	      double tmp = std::abs(data(i));
 	      if (tmp > dmax)
 		dmax = tmp;
 	      if (tmp < dmin)
 		dmin = tmp;
 	    }
 	  rcond = dmin / dmax;
@@ -1232,45 +1237,48 @@ SparseComplexMatrix::dsolve (SparseType 
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::dsolve (SparseType &mattype, const ComplexMatrix& b,
-		     octave_idx_type& err, double& rcond, solve_singularity_handler) const
+			     octave_idx_type& err, double& rcond, 
+			     solve_singularity_handler) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
+  octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr == 0 || nc == 0 || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Diagonal ||
 	  typ == SparseType::Permuted_Diagonal)
 	{
-	  retval.resize (b.rows (), b.cols());
+	  retval.resize (nc, b.cols(), Complex(0.,0.));
 	  if (typ == SparseType::Diagonal)
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
-	      for (octave_idx_type i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nm; i++)
 		retval(i,j) = b(i,j) / data (i);
 	  else
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
-	      for (octave_idx_type i = 0; i < nr; i++)
-		retval(i,j) = b(ridx(i),j) / data (i);
+	      for (octave_idx_type k = 0; k < nc; k++)
+		for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+		  retval(k,j) = b(ridx(i),j) / data (i);
 	    
 	  double dmax = 0., dmin = octave_Inf; 
 	  for (octave_idx_type i = 0; i < nr; i++)
 	    {
 	      double tmp = std::abs(data(i));
 	      if (tmp > dmax)
 		dmax = tmp;
 	      if (tmp < dmin)
@@ -1282,78 +1290,79 @@ SparseComplexMatrix::dsolve (SparseType 
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::dsolve (SparseType &mattype, const SparseComplexMatrix& b,
-		     octave_idx_type& err, double& rcond, 
-		     solve_singularity_handler) const
+			     octave_idx_type& err, double& rcond, 
+			     solve_singularity_handler) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
+  octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr == 0 || nc == 0 || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Diagonal ||
 	  typ == SparseType::Permuted_Diagonal)
 	{
-	  octave_idx_type b_nr = b.rows ();
 	  octave_idx_type b_nc = b.cols ();
 	  octave_idx_type b_nz = b.nzmax ();
-	  retval = SparseComplexMatrix (b_nr, b_nc, b_nz);
+	  retval = SparseComplexMatrix (nc, b_nc, b_nz);
 
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  if (typ == SparseType::Diagonal)
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      {
 		for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		  {
 		    retval.xridx (ii) = b.ridx(i);
 		    retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
 		  }
 		retval.xcidx(j+1) = ii;
 	      }
 	  else
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      {
-		for (octave_idx_type i = 0; i < nr; i++)
-		  {
-		    bool found = false;
-		    octave_idx_type k;
-		    for (k = b.cidx(j); k < b.cidx(j+1); k++)
-		      if (ridx(i) == b.ridx(k))
+		for (octave_idx_type l = 0; l < nc; l++)
+		  for (octave_idx_type i = cidx(l); i < cidx(l+1); i++)
+		    {
+		      bool found = false;
+		      octave_idx_type k;
+		      for (k = b.cidx(j); k < b.cidx(j+1); k++)
+			if (ridx(i) == b.ridx(k))
+			  {
+			    found = true;
+			    break;
+			  }
+		      if (found)
 			{
-			  found = true;
-			  break;
+			  retval.xridx (ii) = l;
+			  retval.xdata (ii++) = b.data(k) / data (i);
 			}
-		    if (found)
-		      {
-			retval.xridx (ii) = i;
-			retval.xdata (ii++) = b.data(k) / data (i);
-		      }
-		  }
+		    }
 		retval.xcidx(j+1) = ii;
 	      }
 	    
 	  double dmax = 0., dmin = octave_Inf; 
-	  for (octave_idx_type i = 0; i < nr; i++)
+	  for (octave_idx_type i = 0; i < nm; i++)
 	    {
 	      double tmp = std::abs(data(i));
 	      if (tmp > dmax)
 		dmax = tmp;
 	      if (tmp < dmin)
 		dmin = tmp;
 	    }
 	  rcond = dmin / dmax;
@@ -1361,65 +1370,68 @@ SparseComplexMatrix::dsolve (SparseType 
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::utsolve (SparseType &mattype, const Matrix& b, octave_idx_type& err, 
-		       double& rcond,
-		       solve_singularity_handler sing_handler) const
+SparseComplexMatrix::utsolve (SparseType &mattype, const Matrix& b,
+			      octave_idx_type& err, double& rcond,
+			      solve_singularity_handler sing_handler) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
+  octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr == 0 || nc == 0 || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Permuted_Upper ||
 	  typ == SparseType::Upper)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
-	  octave_idx_type b_cols = b.cols ();
+	  octave_idx_type b_nc = b.cols ();
 	  rcond = 0.;
 
 	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (octave_idx_type j = 0; j < nr; j++)
+	  for (octave_idx_type j = 0; j < nc; j++)
 	    {
 	      double atmp = 0.;
 	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += std::abs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
 	  if (typ == SparseType::Permuted_Upper)
 	    {
-	      retval.resize (nr, b_cols);
+	      retval.resize (nc, b_nc);
 	      octave_idx_type *perm = mattype.triangular_perm ();
 	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
 
-	      for (octave_idx_type j = 0; j < b_cols; j++)
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = b(i,j);
-
-		  for (octave_idx_type k = nr-1; k >= 0; k--)
+		  for (octave_idx_type i = nr; i < nc; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type k = nc-1; k >= 0; k--)
 		    {
 		      octave_idx_type kidx = perm[k];
 
 		      if (work[k] != 0.)
 			{
 			  if (ridx(cidx(kidx+1)-1) != k)
 			    {
 			      err = -2;
@@ -1432,22 +1444,22 @@ SparseComplexMatrix::utsolve (SparseType
 			       i < cidx(kidx+1)-1; i++)
 			    {
 			      octave_idx_type iidx = ridx(i);
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nc; i++)
 		    retval (perm[i], j) = work[i];
 		}
 
 	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nm; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
 		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
@@ -1472,48 +1484,52 @@ SparseComplexMatrix::utsolve (SparseType
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
 	  else
 	    {
-	      retval = ComplexMatrix (b);
-	      Complex *x_vec = retval.fortran_vec ();
-
-	      for (octave_idx_type j = 0; j < b_cols; j++)
+	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+	      retval.resize (nc, b_nc);
+
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  octave_idx_type offset = j * nr;
-		  for (octave_idx_type k = nr-1; k >= 0; k--)
+		  for (octave_idx_type i = 0; i < nr; i++)
+		    work[i] = b(i,j);
+		  for (octave_idx_type i = nr; i < nc; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type k = nc-1; k >= 0; k--)
 		    {
-		      if (x_vec[k+offset] != 0.)
+		      if (work[k] != 0.)
 			{
 			  if (ridx(cidx(k+1)-1) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
-			  Complex tmp = x_vec[k+offset] / 
-			    data(cidx(k+1)-1);
-			  x_vec[k+offset] = tmp;
+			  Complex tmp = work[k] / data(cidx(k+1)-1);
+			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
 			    {
 			      octave_idx_type iidx = ridx(i);
-			      x_vec[iidx+offset] = 
-				x_vec[iidx+offset] - tmp * data(i);
+			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
+
+		  for (octave_idx_type i = 0; i < nc; i++)
+		    retval.xelem (i, j) = work[i];
 		}
 
 	      // Calculation of 1-norm of inv(*this)
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-	      for (octave_idx_type i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nm; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
 		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
@@ -1570,76 +1586,76 @@ SparseComplexMatrix::utsolve (SparseType
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::utsolve (SparseType &mattype, const SparseMatrix& b,
-			octave_idx_type& err, double& rcond, 
-			solve_singularity_handler sing_handler) const
+			      octave_idx_type& err, double& rcond, 
+			      solve_singularity_handler sing_handler) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
+  octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr == 0 || nc == 0 || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Permuted_Upper ||
 	  typ == SparseType::Upper)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  rcond = 0.;
 
 	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (octave_idx_type j = 0; j < nr; j++)
+	  for (octave_idx_type j = 0; j < nc; j++)
 	    {
 	      double atmp = 0.;
 	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += std::abs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
-	  octave_idx_type b_nr = b.rows ();
 	  octave_idx_type b_nc = b.cols ();
 	  octave_idx_type b_nz = b.nzmax ();
-	  retval = SparseComplexMatrix (b_nr, b_nc, b_nz);
+	  retval = SparseComplexMatrix (nc, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Upper)
 	    {
 	      octave_idx_type *perm = mattype.triangular_perm ();
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-
-	      OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nr);
-	      for (octave_idx_type i = 0; i < nr; i++)
+	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+
+	      OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nc);
+	      for (octave_idx_type i = 0; i < nc; i++)
 		rperm[perm[i]] = i;
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nm; i++)
 		    work[i] = 0.;
 		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[b.ridx(i)] = b.data(i);
 
-		  for (octave_idx_type k = nr-1; k >= 0; k--)
+		  for (octave_idx_type k = nc-1; k >= 0; k--)
 		    {
 		      octave_idx_type kidx = perm[k];
 
 		      if (work[k] != 0.)
 			{
 			  if (ridx(cidx(kidx+1)-1) != k)
 			    {
 			      err = -2;
@@ -1655,41 +1671,41 @@ SparseComplexMatrix::utsolve (SparseType
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
 		  octave_idx_type new_nnz = 0;
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nc; i++)
 		    if (work[i] != 0.)
 		      new_nnz++;
 
 		  if (ii + new_nnz > x_nz)
 		    {
 		      // Resize the sparse matrix
 		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nc; i++)
 		    if (work[rperm[i]] != 0.)
 		      {
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[rperm[i]];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nm; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
 		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
@@ -1714,26 +1730,26 @@ SparseComplexMatrix::utsolve (SparseType
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
 	  else
 	    {
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
+	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nm; i++)
 		    work[i] = 0.;
 		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[b.ridx(i)] = b.data(i);
 
-		  for (octave_idx_type k = nr-1; k >= 0; k--)
+		  for (octave_idx_type k = nc-1; k >= 0; k--)
 		    {
 		      if (work[k] != 0.)
 			{
 			  if (ridx(cidx(k+1)-1) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
@@ -1746,41 +1762,41 @@ SparseComplexMatrix::utsolve (SparseType
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
 		  octave_idx_type new_nnz = 0;
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nc; i++)
 		    if (work[i] != 0.)
 		      new_nnz++;
 
 		  if (ii + new_nnz > x_nz)
 		    {
 		      // Resize the sparse matrix
 		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nc; i++)
 		    if (work[i] != 0.)
 		      {
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[i];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nm; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
 		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
@@ -1836,26 +1852,27 @@ SparseComplexMatrix::utsolve (SparseType
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::utsolve (SparseType &mattype, const ComplexMatrix& b,
-		     octave_idx_type& err, double& rcond, 
-		     solve_singularity_handler sing_handler) const
+			      octave_idx_type& err, double& rcond, 
+			      solve_singularity_handler sing_handler) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
+  octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr == 0 || nc == 0 || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
@@ -1863,37 +1880,39 @@ SparseComplexMatrix::utsolve (SparseType
 	  typ == SparseType::Upper)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  octave_idx_type b_nc = b.cols ();
 	  rcond = 0.;
 
 	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (octave_idx_type j = 0; j < nr; j++)
+	  for (octave_idx_type j = 0; j < nc; j++)
 	    {
 	      double atmp = 0.;
 	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += std::abs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
 	  if (typ == SparseType::Permuted_Upper)
 	    {
-	      retval.resize (nr, b_nc);
+	      retval.resize (nc, b_nc);
 	      octave_idx_type *perm = mattype.triangular_perm ();
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
+	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = b(i,j);
-
-		  for (octave_idx_type k = nr-1; k >= 0; k--)
+		  for (octave_idx_type i = nr; i < nc; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type k = nc-1; k >= 0; k--)
 		    {
 		      octave_idx_type kidx = perm[k];
 
 		      if (work[k] != 0.)
 			{
 			  if (ridx(cidx(kidx+1)-1) != k)
 			    {
 			      err = -2;
@@ -1906,22 +1925,22 @@ SparseComplexMatrix::utsolve (SparseType
 			       i < cidx(kidx+1)-1; i++)
 			    {
 			      octave_idx_type iidx = ridx(i);
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nc; i++)
 		    retval (perm[i], j) = work[i];
 		}
 
 	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nm; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
 		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
@@ -1946,48 +1965,52 @@ SparseComplexMatrix::utsolve (SparseType
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
 	  else
 	    {
-	      retval = b;
-	      Complex *x_vec = retval.fortran_vec ();
+	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+	      retval.resize (nc, b_nc);
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  octave_idx_type offset = j * nr;
-		  for (octave_idx_type k = nr-1; k >= 0; k--)
+		  for (octave_idx_type i = 0; i < nr; i++)
+		    work[i] = b(i,j);
+		  for (octave_idx_type i = nr; i < nc; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type k = nc-1; k >= 0; k--)
 		    {
-		      if (x_vec[k+offset] != 0.)
+		      if (work[k] != 0.)
 			{
 			  if (ridx(cidx(k+1)-1) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
-			  Complex tmp = x_vec[k+offset] / 
-			    data(cidx(k+1)-1);
-			  x_vec[k+offset] = tmp;
+			  Complex tmp = work[k] / data(cidx(k+1)-1);
+			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
 			    {
 			      octave_idx_type iidx = ridx(i);
-			      x_vec[iidx+offset] = 
-				x_vec[iidx+offset] - tmp * data(i);
+			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
+
+		  for (octave_idx_type i = 0; i < nc; i++)
+		    retval.xelem (i, j) = work[i];
 		}
 
 	      // Calculation of 1-norm of inv(*this)
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-	      for (octave_idx_type i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nm; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
 		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
@@ -2044,76 +2067,76 @@ SparseComplexMatrix::utsolve (SparseType
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::utsolve (SparseType &mattype, const SparseComplexMatrix& b,
-		     octave_idx_type& err, double& rcond, 
-		     solve_singularity_handler sing_handler) const
+			      octave_idx_type& err, double& rcond, 
+			      solve_singularity_handler sing_handler) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
+  octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr == 0 || nc == 0 || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == SparseType::Permuted_Upper ||
 	  typ == SparseType::Upper)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  rcond = 0.;
 
 	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (octave_idx_type j = 0; j < nr; j++)
+	  for (octave_idx_type j = 0; j < nc; j++)
 	    {
 	      double atmp = 0.;
 	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += std::abs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
-	  octave_idx_type b_nr = b.rows ();
 	  octave_idx_type b_nc = b.cols ();
 	  octave_idx_type b_nz = b.nzmax ();
-	  retval = SparseComplexMatrix (b_nr, b_nc, b_nz);
+	  retval = SparseComplexMatrix (nc, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Upper)
 	    {
 	      octave_idx_type *perm = mattype.triangular_perm ();
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-
-	      OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nr);
-	      for (octave_idx_type i = 0; i < nr; i++)
+	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+
+	      OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nc);
+	      for (octave_idx_type i = 0; i < nc; i++)
 		rperm[perm[i]] = i;
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nm; i++)
 		    work[i] = 0.;
 		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[b.ridx(i)] = b.data(i);
 
-		  for (octave_idx_type k = nr-1; k >= 0; k--)
+		  for (octave_idx_type k = nc-1; k >= 0; k--)
 		    {
 		      octave_idx_type kidx = perm[k];
 
 		      if (work[k] != 0.)
 			{
 			  if (ridx(cidx(kidx+1)-1) != k)
 			    {
 			      err = -2;
@@ -2129,41 +2152,41 @@ SparseComplexMatrix::utsolve (SparseType
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
 		  octave_idx_type new_nnz = 0;
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nc; i++)
 		    if (work[i] != 0.)
 		      new_nnz++;
 
 		  if (ii + new_nnz > x_nz)
 		    {
 		      // Resize the sparse matrix
 		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nc; i++)
 		    if (work[rperm[i]] != 0.)
 		      {
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[rperm[i]];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nm; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
 		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
@@ -2188,21 +2211,21 @@ SparseComplexMatrix::utsolve (SparseType
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
 	  else
 	    {
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
+	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nm; i++)
 		    work[i] = 0.;
 		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[b.ridx(i)] = b.data(i);
 
 		  for (octave_idx_type k = nr-1; k >= 0; k--)
 		    {
 		      if (work[k] != 0.)
 			{
@@ -2220,41 +2243,41 @@ SparseComplexMatrix::utsolve (SparseType
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
 		  octave_idx_type new_nnz = 0;
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nc; i++)
 		    if (work[i] != 0.)
 		      new_nnz++;
 
 		  if (ii + new_nnz > x_nz)
 		    {
 		      // Resize the sparse matrix
 		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nc; i++)
 		    if (work[i] != 0.)
 		      {
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[i];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nm; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
 		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
@@ -2310,64 +2333,68 @@ SparseComplexMatrix::utsolve (SparseType
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::ltsolve (SparseType &mattype, const Matrix& b, octave_idx_type& err, 
-		   double& rcond, solve_singularity_handler sing_handler) const
+SparseComplexMatrix::ltsolve (SparseType &mattype, const Matrix& b, 
+			      octave_idx_type& err, double& rcond, 
+			      solve_singularity_handler sing_handler) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
+  octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr == 0 || nc == 0 || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == SparseType::Permuted_Lower ||
 	  typ == SparseType::Lower)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
-	  octave_idx_type b_cols = b.cols ();
+	  octave_idx_type b_nc = b.cols ();
 	  rcond = 0.;
 
 	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (octave_idx_type j = 0; j < nr; j++)
+	  for (octave_idx_type j = 0; j < nc; j++)
 	    {
 	      double atmp = 0.;
 	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += std::abs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
 	  if (typ == SparseType::Permuted_Lower)
 	    {
-	      retval.resize (b.rows (), b.cols ());
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
+	      retval.resize (nc, b_nc);
+	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 	      octave_idx_type *perm = mattype.triangular_perm ();
 
-	      for (octave_idx_type j = 0; j < b_cols; j++)
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    work[i] = 0.;
 		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[perm[i]] = b(i,j);
 
-		  for (octave_idx_type k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nc; k++)
 		    {
 		      if (work[k] != 0.)
 			{
 			  octave_idx_type minr = nr;
 			  octave_idx_type mini = 0;
 
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    if (perm[ridx(i)] < minr)
@@ -2390,29 +2417,29 @@ SparseComplexMatrix::ltsolve (SparseType
 				continue;
 
 			      octave_idx_type iidx = perm[ridx(i)];
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nc; i++)
 		    retval (i, j) = work[i];
 		}
 
 	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nm; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
-		  for (octave_idx_type k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nc; k++)
 		    {
 		      if (work[k] != 0.)
 			{
 			  octave_idx_type minr = nr;
 			  octave_idx_type mini = 0;
 
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    if (perm[ridx(i)] < minr)
@@ -2430,81 +2457,83 @@ SparseComplexMatrix::ltsolve (SparseType
 
 			      octave_idx_type iidx = perm[ridx(i)];
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  double atmp = 0;
-		  for (octave_idx_type i = j; i < nr; i++)
+		  for (octave_idx_type i = j; i < nc; i++)
 		    {
 		      atmp += std::abs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
 	  else
 	    {
-	      retval = ComplexMatrix (b);
-	      Complex *x_vec = retval.fortran_vec ();
-
-	      for (octave_idx_type j = 0; j < b_cols; j++)
+	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+	      retval.resize (nc, b_nc, 0.);
+
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  octave_idx_type offset = j * nr;
-		  for (octave_idx_type k = 0; k < nr; k++)
+		  for (octave_idx_type i = 0; i < nr; i++)
+		    work[i] = b(i,j);
+		  for (octave_idx_type i = nr; i < nc; i++)
+		    work[i] = 0.;
+		  for (octave_idx_type k = 0; k < nc; k++)
 		    {
-		      if (x_vec[k+offset] != 0.)
+		      if (work[k] != 0.)
 			{
 			  if (ridx(cidx(k)) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
-			  Complex tmp = x_vec[k+offset] / 
-			    data(cidx(k));
-			  x_vec[k+offset] = tmp;
+			  Complex tmp = work[k] / data(cidx(k));
+			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
 			    {
 			      octave_idx_type iidx = ridx(i);
-			      x_vec[iidx+offset] = 
-				x_vec[iidx+offset] - tmp * data(i);
+			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
+		  for (octave_idx_type i = 0; i < nc; i++)
+		    retval.xelem (i, j) = work[i];
 		}
 
 	      // Calculation of 1-norm of inv(*this)
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-	      for (octave_idx_type i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nm; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
-		  for (octave_idx_type k = j; k < nr; k++)
+		  for (octave_idx_type k = j; k < nc; k++)
 		    {
 
 		      if (work[k] != 0.)
 			{
 			  Complex tmp = work[k] / data(cidx(k));
 			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
 			    {
 			      octave_idx_type iidx = ridx(i);
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (octave_idx_type i = j; i < nr; i++)
+		  for (octave_idx_type i = j; i < nc; i++)
 		    {
 		      atmp += std::abs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
@@ -2540,72 +2569,73 @@ SparseComplexMatrix::ltsolve (SparseType
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::ltsolve (SparseType &mattype, const SparseMatrix& b, 
-			octave_idx_type& err, double& rcond, 
-			solve_singularity_handler sing_handler) const
+			      octave_idx_type& err, double& rcond, 
+			      solve_singularity_handler sing_handler) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
+  octave_idx_type nm = (nc > nr ? nc : nr);
+
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr == 0 || nc == 0 || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == SparseType::Permuted_Lower ||
 	  typ == SparseType::Lower)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  rcond = 0.;
 
 	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (octave_idx_type j = 0; j < nr; j++)
+	  for (octave_idx_type j = 0; j < nc; j++)
 	    {
 	      double atmp = 0.;
 	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += std::abs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
-	  octave_idx_type b_nr = b.rows ();
 	  octave_idx_type b_nc = b.cols ();
 	  octave_idx_type b_nz = b.nzmax ();
-	  retval = SparseComplexMatrix (b_nr, b_nc, b_nz);
+	  retval = SparseComplexMatrix (nc, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Lower)
 	    {
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
+	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 	      octave_idx_type *perm = mattype.triangular_perm ();
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nm; i++)
 		    work[i] = 0.;
 		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[perm[b.ridx(i)]] = b.data(i);
 
-		  for (octave_idx_type k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nc; k++)
 		    {
 		      if (work[k] != 0.)
 			{
 			  octave_idx_type minr = nr;
 			  octave_idx_type mini = 0;
 
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    if (perm[ridx(i)] < minr)
@@ -2631,48 +2661,48 @@ SparseComplexMatrix::ltsolve (SparseType
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
 		  octave_idx_type new_nnz = 0;
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nc; i++)
 		    if (work[i] != 0.)
 		      new_nnz++;
 
 		  if (ii + new_nnz > x_nz)
 		    {
 		      // Resize the sparse matrix
 		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nc; i++)
 		    if (work[i] != 0.)
 		      {
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[i];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nm; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
-		  for (octave_idx_type k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nc; k++)
 		    {
 		      if (work[k] != 0.)
 			{
 			  octave_idx_type minr = nr;
 			  octave_idx_type mini = 0;
 
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    if (perm[ridx(i)] < minr)
@@ -2690,37 +2720,37 @@ SparseComplexMatrix::ltsolve (SparseType
 
 			      octave_idx_type iidx = perm[ridx(i)];
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  double atmp = 0;
-		  for (octave_idx_type i = j; i < nr; i++)
+		  for (octave_idx_type i = j; i < nc; i++)
 		    {
 		      atmp += std::abs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
 	  else
 	    {
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
+	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nm; i++)
 		    work[i] = 0.;
 		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[b.ridx(i)] = b.data(i);
 
-		  for (octave_idx_type k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nc; k++)
 		    {
 		      if (work[k] != 0.)
 			{
 			  if (ridx(cidx(k)) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
@@ -2733,63 +2763,63 @@ SparseComplexMatrix::ltsolve (SparseType
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
 		  octave_idx_type new_nnz = 0;
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nc; i++)
 		    if (work[i] != 0.)
 		      new_nnz++;
 
 		  if (ii + new_nnz > x_nz)
 		    {
 		      // Resize the sparse matrix
 		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nc; i++)
 		    if (work[i] != 0.)
 		      {
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[i];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nm; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
-		  for (octave_idx_type k = j; k < nr; k++)
+		  for (octave_idx_type k = j; k < nc; k++)
 		    {
 
 		      if (work[k] != 0.)
 			{
 			  Complex tmp = work[k] / data(cidx(k));
 			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
 			    {
 			      octave_idx_type iidx = ridx(i);
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (octave_idx_type i = j; i < nr; i++)
+		  for (octave_idx_type i = j; i < nc; i++)
 		    {
 		      atmp += std::abs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 
@@ -2826,26 +2856,27 @@ SparseComplexMatrix::ltsolve (SparseType
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::ltsolve (SparseType &mattype, const ComplexMatrix& b,
-			octave_idx_type& err, double& rcond,
-			solve_singularity_handler sing_handler) const
+			      octave_idx_type& err, double& rcond,
+			      solve_singularity_handler sing_handler) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
+  octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr == 0 || nc == 0 || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
@@ -2853,37 +2884,39 @@ SparseComplexMatrix::ltsolve (SparseType
 	  typ == SparseType::Lower)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  octave_idx_type b_nc = b.cols ();
 	  rcond = 0.;
 
 	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (octave_idx_type j = 0; j < nr; j++)
+	  for (octave_idx_type j = 0; j < nc; j++)
 	    {
 	      double atmp = 0.;
 	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += std::abs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
 	  if (typ == SparseType::Permuted_Lower)
 	    {
-	      retval.resize (b.rows (), b.cols ());
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
+	      retval.resize (nc, b_nc);
+	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 	      octave_idx_type *perm = mattype.triangular_perm ();
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    work[i] = 0.;
 		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[perm[i]] = b(i,j);
 
-		  for (octave_idx_type k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nc; k++)
 		    {
 		      if (work[k] != 0.)
 			{
 			  octave_idx_type minr = nr;
 			  octave_idx_type mini = 0;
 
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    if (perm[ridx(i)] < minr)
@@ -2906,29 +2939,29 @@ SparseComplexMatrix::ltsolve (SparseType
 				continue;
 
 			      octave_idx_type iidx = perm[ridx(i)];
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nc; i++)
 		    retval (i, j) = work[i];
 		}
 
 	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nm; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
-		  for (octave_idx_type k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nc; k++)
 		    {
 		      if (work[k] != 0.)
 			{
 			  octave_idx_type minr = nr;
 			  octave_idx_type mini = 0;
 
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    if (perm[ridx(i)] < minr)
@@ -2946,81 +2979,86 @@ SparseComplexMatrix::ltsolve (SparseType
 
 			      octave_idx_type iidx = perm[ridx(i)];
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  double atmp = 0;
-		  for (octave_idx_type i = j; i < nr; i++)
+		  for (octave_idx_type i = j; i < nc; i++)
 		    {
 		      atmp += std::abs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
 	  else
 	    {
-	      retval = b;
-	      Complex *x_vec = retval.fortran_vec ();
+	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
+	      retval.resize (nc, b_nc, 0.);
+
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  octave_idx_type offset = j * nr;
-		  for (octave_idx_type k = 0; k < nr; k++)
+		  for (octave_idx_type i = 0; i < nr; i++)
+		    work[i] = b(i,j);
+		  for (octave_idx_type i = nr; i < nc; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type k = 0; k < nc; k++)
 		    {
-		      if (x_vec[k+offset] != 0.)
+		      if (work[k] != 0.)
 			{
 			  if (ridx(cidx(k)) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
-			  Complex tmp = x_vec[k+offset] / 
-			    data(cidx(k));
-			  x_vec[k+offset] = tmp;
+			  Complex tmp = work[k] / data(cidx(k));
+			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
 			    {
 			      octave_idx_type iidx = ridx(i);
-			      x_vec[iidx+offset] = 
-				x_vec[iidx+offset] - tmp * data(i);
+			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
+
+		  for (octave_idx_type i = 0; i < nc; i++)
+		    retval.xelem (i, j) = work[i];
 		}
 
 	      // Calculation of 1-norm of inv(*this)
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
-	      for (octave_idx_type i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nm; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
-		  for (octave_idx_type k = j; k < nr; k++)
+		  for (octave_idx_type k = j; k < nc; k++)
 		    {
 
 		      if (work[k] != 0.)
 			{
 			  Complex tmp = work[k] / data(cidx(k));
 			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
 			    {
 			      octave_idx_type iidx = ridx(i);
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (octave_idx_type i = j; i < nr; i++)
+		  for (octave_idx_type i = j; i < nc; i++)
 		    {
 		      atmp += std::abs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 
@@ -3057,72 +3095,72 @@ SparseComplexMatrix::ltsolve (SparseType
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::ltsolve (SparseType &mattype, const SparseComplexMatrix& b,
-		     octave_idx_type& err, double& rcond, 
-		     solve_singularity_handler sing_handler) const
+			      octave_idx_type& err, double& rcond, 
+			      solve_singularity_handler sing_handler) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
+  octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr == 0 || nc == 0 || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == SparseType::Permuted_Lower ||
 	  typ == SparseType::Lower)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  rcond = 0.;
 
 	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (octave_idx_type j = 0; j < nr; j++)
+	  for (octave_idx_type j = 0; j < nc; j++)
 	    {
 	      double atmp = 0.;
 	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += std::abs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
-	  octave_idx_type b_nr = b.rows ();
 	  octave_idx_type b_nc = b.cols ();
 	  octave_idx_type b_nz = b.nzmax ();
-	  retval = SparseComplexMatrix (b_nr, b_nc, b_nz);
+	  retval = SparseComplexMatrix (nc, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Lower)
 	    {
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
+	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 	      octave_idx_type *perm = mattype.triangular_perm ();
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nm; i++)
 		    work[i] = 0.;
 		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[perm[b.ridx(i)]] = b.data(i);
 
-		  for (octave_idx_type k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nc; k++)
 		    {
 		      if (work[k] != 0.)
 			{
 			  octave_idx_type minr = nr;
 			  octave_idx_type mini = 0;
 
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    if (perm[ridx(i)] < minr)
@@ -3148,48 +3186,48 @@ SparseComplexMatrix::ltsolve (SparseType
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
 		  octave_idx_type new_nnz = 0;
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nc; i++)
 		    if (work[i] != 0.)
 		      new_nnz++;
 
 		  if (ii + new_nnz > x_nz)
 		    {
 		      // Resize the sparse matrix
 		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nc; i++)
 		    if (work[i] != 0.)
 		      {
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[i];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nm; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
-		  for (octave_idx_type k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nc; k++)
 		    {
 		      if (work[k] != 0.)
 			{
 			  octave_idx_type minr = nr;
 			  octave_idx_type mini = 0;
 
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    if (perm[ridx(i)] < minr)
@@ -3207,37 +3245,37 @@ SparseComplexMatrix::ltsolve (SparseType
 
 			      octave_idx_type iidx = perm[ridx(i)];
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  double atmp = 0;
-		  for (octave_idx_type i = j; i < nr; i++)
+		  for (octave_idx_type i = j; i < nc; i++)
 		    {
 		      atmp += std::abs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
 	  else
 	    {
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
+	      OCTAVE_LOCAL_BUFFER (Complex, work, nm);
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nm; i++)
 		    work[i] = 0.;
 		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[b.ridx(i)] = b.data(i);
 
-		  for (octave_idx_type k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nc; k++)
 		    {
 		      if (work[k] != 0.)
 			{
 			  if (ridx(cidx(k)) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
@@ -3250,63 +3288,63 @@ SparseComplexMatrix::ltsolve (SparseType
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
 		  octave_idx_type new_nnz = 0;
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nc; i++)
 		    if (work[i] != 0.)
 		      new_nnz++;
 
 		  if (ii + new_nnz > x_nz)
 		    {
 		      // Resize the sparse matrix
 		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nc; i++)
 		    if (work[i] != 0.)
 		      {
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[i];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nm; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
-		  for (octave_idx_type k = j; k < nr; k++)
+		  for (octave_idx_type k = j; k < nc; k++)
 		    {
 
 		      if (work[k] != 0.)
 			{
 			  Complex tmp = work[k] / data(cidx(k));
 			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
 			    {
 			      octave_idx_type iidx = ridx(i);
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (octave_idx_type i = j; i < nr; i++)
+		  for (octave_idx_type i = j; i < nc; i++)
 		    {
 		      atmp += std::abs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 
@@ -4117,17 +4155,17 @@ SparseComplexMatrix::bsolve (SparseType 
 
 	  for (octave_idx_type j = 0; j < nc; j++)
 	    for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	      m_band(ridx(i) - j + n_lower + n_upper, j) = data(i);
 
 	  Array<octave_idx_type> ipvt (nr);
 	  octave_idx_type *pipvt = ipvt.fortran_vec ();
 
-	  F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
+	  F77_XFCN (zgbtrf, ZGBTRF, (nr, nc, n_lower, n_upper, tmp_data, 
 				     ldm, pipvt, err));
 	    
 	  if (f77_exception_encountered)
 	    (*current_liboctave_error_handler) 
 	      ("unrecoverable error in zgbtrf");
 	  else
 	    {
 	      // Throw-away extra info LAPACK gives so as to not 
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,22 @@
+2006-02-20  David Bateman  <dbateman@free.fr>
+
+	* dSparse.cc (dsolve, utsolve, ltsolve): Remove restriction that 
+	matrix must be square in diagonal, permuted diagonal, triangular
+	and permuted triangular back/forward substitution code. Change
+	ambiguous use of no. rows and columns.
+	* CSParse.cc (dsolve, utsolve, ltsolve): ditto.
+	* SparseType.cc (SparseType::SparseType(const SparseMatrix&),
+	SparseType::SparseType(const SparseComplexMatrix&)): Recognize
+	rectangular diagonal, permuted diagonal, triangular and permuted
+	triangular matrices.
+	* Sparse.cc (Sparse<T>::Sparse (octave_idx_type, octave_idx_type, T)):
+	Treat case where third argument is zero.
+
 2006-02-15  John W. Eaton  <jwe@octave.org>
 
 	* kpse.cc: Do define ST_NLINK_TRICK for Cygwin systems.
 	(do_subdir) [ST_NLINK_TRICK]: Check links != 2 instead of links > 2. 
 
 	* getopt.c: Use __CYGWIN__ instead of __CYGWIN32__.
 
 2006-02-13  David Bateman  <dbateman@free.fr>
diff --git a/liboctave/Sparse.cc b/liboctave/Sparse.cc
--- a/liboctave/Sparse.cc
+++ b/liboctave/Sparse.cc
@@ -217,30 +217,39 @@ Sparse<T>::Sparse (const Sparse<U>& a)
 	}
       for (octave_idx_type i = 0; i < nc + 1; i++)
 	xcidx (i) = a.cidx (i);
     }
 }
 
 template <class T>
 Sparse<T>::Sparse (octave_idx_type nr, octave_idx_type nc, T val)
-  : rep (new typename Sparse<T>::SparseRep (nr, nc, nr*nc)),
-    dimensions (dim_vector (nr, nc)), idx (0), idx_count (0)
+  : dimensions (dim_vector (nr, nc)), idx (0), idx_count (0)
 { 
-
-  octave_idx_type ii = 0;
-  xcidx (0) = 0;
-  for (octave_idx_type j = 0; j < nc; j++)
+  if (val != T ())
     {
-      for (octave_idx_type i = 0; i < nr; i++)
+      rep = new typename Sparse<T>::SparseRep (nr, nc, nr*nc);
+
+      octave_idx_type ii = 0;
+      xcidx (0) = 0;
+      for (octave_idx_type j = 0; j < nc; j++)
 	{
-	  xdata (ii) = val;
-	  xridx (ii++) = i;
-	} 
-      xcidx (j+1) = ii;
+	  for (octave_idx_type i = 0; i < nr; i++)
+	    {
+	      xdata (ii) = val;
+	      xridx (ii++) = i;
+	    } 
+	  xcidx (j+1) = ii;
+	}
+    }
+  else
+    {
+      rep = new typename Sparse<T>::SparseRep (nr, nc, 0);
+      for (octave_idx_type j = 0; j < nc+1; j++)
+	xcidx(j) = 0;
     }
 }
 
 template <class T>
 Sparse<T>::Sparse (const dim_vector& dv)
   : dimensions (dv), idx (0), idx_count (0)
 { 
   if (dv.length() != 2)
diff --git a/liboctave/SparseType.cc b/liboctave/SparseType.cc
--- a/liboctave/SparseType.cc
+++ b/liboctave/SparseType.cc
@@ -50,220 +50,230 @@ SparseType::SparseType (const SparseType
 	perm[i] = a.perm[i];
     }
 }
 
 SparseType::SparseType (const SparseMatrix &a)
 {
   octave_idx_type nrows = a.rows ();
   octave_idx_type ncols = a.cols ();
+  octave_idx_type nm = (ncols < nrows ? ncols : nrows);
   octave_idx_type nnz = a.nzmax ();
 
   if (Voctave_sparse_controls.get_key ("spumoni") != 0.)
     (*current_liboctave_warning_handler) 
       ("Calculating Sparse Matrix Type");
 
   nperm = 0;
 
-  if (nrows != ncols)
-    typ = SparseType::Rectangular;
-  else
+  sp_bandden = Voctave_sparse_controls.get_key ("bandden");
+  bool maybe_hermitian = false;
+  typ = SparseType::Full;
+
+  if (nnz == nm)
     {
-      sp_bandden = Voctave_sparse_controls.get_key ("bandden");
-      bool maybe_hermitian = false;
-      typ = SparseType::Full;
-
-      if (nnz == ncols)
+      matrix_type tmp_typ = SparseType::Diagonal;
+      octave_idx_type i;
+      // Maybe the matrix is diagonal
+      for (i = 0; i < nm; i++)
 	{
-	  matrix_type tmp_typ = SparseType::Diagonal;
-	  octave_idx_type i;
-	  // Maybe the matrix is diagonal
-	  for (i = 0; i < ncols; i++)
+	  if (a.cidx(i+1) != a.cidx(i) + 1)
+	    {
+	      tmp_typ = SparseType::Full;
+	      break;
+	    }
+	  if (a.ridx(i) != i)
 	    {
-	      if (a.cidx(i+1) != a.cidx(i) + 1)
+	      tmp_typ = SparseType::Permuted_Diagonal;
+	      break;
+	    }
+	}
+	  
+      if (tmp_typ == SparseType::Permuted_Diagonal)
+	{
+	  bool found [nrows];
+
+	  for (octave_idx_type j = 0; j < i; j++)
+	    found [j] = true;
+	  for (octave_idx_type j = i; j < nrows; j++)
+	    found [j] = false;
+	      
+	  for (octave_idx_type j = i; j < nm; j++)
+	    {
+	      if ((a.cidx(j+1) > a.cidx(j) + 1)  || 
+		  ((a.cidx(j+1) == a.cidx(j) + 1) && found [a.ridx(j)]))
 		{
-		  tmp_typ = Full;
-		  break;
-		}
-	      if (a.ridx(i) != i)
-		{
-		  tmp_typ = SparseType::Permuted_Diagonal;
+		  tmp_typ = SparseType::Full;
 		  break;
 		}
+	      found [a.ridx(j)] = true;
 	    }
-	  
-	  if (tmp_typ == SparseType::Permuted_Diagonal)
-	    {
-	      bool found [ncols];
+	}
+      typ = tmp_typ;
+    }
 
-	      for (octave_idx_type j = 0; j < i; j++)
-		found [j] = true;
-	      for (octave_idx_type j = i; j < ncols; j++)
-		found [j] = false;
-	      
-	      for (octave_idx_type j = i; j < ncols; j++)
-		{
-		  if ((a.cidx(j+1) != a.cidx(j) + 1) || found [a.ridx(j)])
-		    {
-		      tmp_typ = Full;
-		      break;
-		    }
-		  found [a.ridx(j)] = true;
-		}
-	    }
-	  typ = tmp_typ;
-	}
-
-      if (typ == SparseType::Full)
+  if (typ == SparseType::Full)
+    {
+      // Search for banded, upper and lower triangular matrices
+      bool singular = false;
+      upper_band = 0;
+      lower_band = 0;
+      for (octave_idx_type j = 0; j < ncols; j++)
 	{
-	  // Search for banded, upper and lower triangular matrices
-	  bool singular = false;
-	  upper_band = 0;
-	  lower_band = 0;
-	  for (octave_idx_type j = 0; j < ncols; j++)
+	  bool zero_on_diagonal = false;
+	  if (j < nrows)
 	    {
-	      bool zero_on_diagonal = true;
+	      zero_on_diagonal = true;
 	      for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
 		if (a.ridx(i) == j)
 		  {
 		    zero_on_diagonal = false;
 		    break;
 		  }
-
-	      if (zero_on_diagonal)
-		{
-		  singular = true;
-		  break;
-		}
+	    }
 
-	      if (a.cidx(j+1) - a.cidx(j) > 0)
-		{
-		  octave_idx_type ru = a.ridx(a.cidx(j));
-		  octave_idx_type rl = a.ridx(a.cidx(j+1)-1);
-
-		  if (j - ru > upper_band)
-		    upper_band = j - ru;
-		  
-		  if (rl - j > lower_band)
-		    lower_band = rl - j;
-		}
+	  if (zero_on_diagonal)
+	    {
+	      singular = true;
+	      break;
 	    }
 
-	  if (!singular)
+	  if (a.cidx(j+1) != a.cidx(j))
 	    {
-	      bandden = double (nnz) /
-		(double (ncols) * (double (lower_band) +
-				double (upper_band)) -
-		 0.5 * double (upper_band + 1) * double (upper_band) -
-		 0.5 * double (lower_band + 1) * double (lower_band));
+	      octave_idx_type ru = a.ridx(a.cidx(j));
+	      octave_idx_type rl = a.ridx(a.cidx(j+1)-1);
+
+	      if (j - ru > upper_band)
+		upper_band = j - ru;
+		  
+	      if (rl - j > lower_band)
+		lower_band = rl - j;
+	    }
+	}
 
-	      if (sp_bandden != 1. && bandden > sp_bandden)
-		{
-		  if (upper_band == 1 && lower_band == 1)
-		    typ = SparseType::Tridiagonal;
-		  else
-		    typ = SparseType::Banded;
+      if (!singular)
+	{
+	  bandden = double (nnz) /
+	    (double (ncols) * (double (lower_band) +
+			       double (upper_band)) -
+	     0.5 * double (upper_band + 1) * double (upper_band) -
+	     0.5 * double (lower_band + 1) * double (lower_band));
+
+	  if (nrows == ncols && sp_bandden != 1. && bandden > sp_bandden)
+	    {
+	      if (upper_band == 1 && lower_band == 1)
+		typ = SparseType::Tridiagonal;
+	      else
+		typ = SparseType::Banded;
 
-		  octave_idx_type nnz_in_band = (upper_band + lower_band + 1) * nrows -
-		    (1 + upper_band) * upper_band / 2 -
-		    (1 + lower_band) * lower_band / 2;
-		  if (nnz_in_band == nnz)
-		    dense = true;
-		  else 
-		    dense = false;
+	      octave_idx_type nnz_in_band = 
+		(upper_band + lower_band + 1) * nrows -
+		(1 + upper_band) * upper_band / 2 -
+		(1 + lower_band) * lower_band / 2;
+	      if (nnz_in_band == nnz)
+		dense = true;
+	      else 
+		dense = false;
+	    }
+	  else if (upper_band == 0)
+	    typ = SparseType::Lower;
+	  else if (lower_band == 0)
+	    typ = SparseType::Upper;
+
+	  if (upper_band == lower_band && nrows == ncols)
+	    maybe_hermitian = true;
+	}
+
+      if (typ == SparseType::Full)
+	{
+	  // Search for a permuted triangular matrix, and test if
+	  // permutation is singular
+
+	  // XXX FIXME XXX
+	  // Perhaps this should be based on a dmperm algorithm
+	  bool found = false;
+
+	  nperm = ncols;
+	  perm = new octave_idx_type [nperm];
+
+	  for (octave_idx_type i = 0; i < nm; i++)
+	    {
+	      found = false;
+
+	      for (octave_idx_type j = 0; j < ncols; j++)
+		{
+
+		  if ((a.cidx(j+1) - a.cidx(j)) > 0 && 
+		      a.ridx(a.cidx(j+1)-1) == i)
+		    {
+		      perm [i] = j;
+		      found = true;
+		      break;
+		    }
 		}
-	      else if (upper_band == 0)
-		typ = SparseType::Lower;
-	      else if (lower_band == 0)
-		typ = SparseType::Upper;
 
-	      if (upper_band == lower_band)
-		maybe_hermitian = true;
+	      if (!found)
+		break;
 	    }
 
-	  if (typ == SparseType::Full)
+	  if (found)
+	    typ = SparseType::Permuted_Upper;
+	  else
 	    {
-	      // Search for a permuted triangular matrix, and test if
-	      // permutation is singular
-
-	      // XXX FIXME XXX Perhaps this should be based on a dmperm algorithm
-	      bool found = false;
-
+	      delete [] perm;
 	      nperm = nrows;
 	      perm = new octave_idx_type [nperm];
+	      OCTAVE_LOCAL_BUFFER (octave_idx_type, tmp, nperm);
 
 	      for (octave_idx_type i = 0; i < nperm; i++)
 		{
-		  found = false;
-
-		  for (octave_idx_type j = 0; j < ncols; j++)
-		    {
-
-		      if ((a.cidx(j+1) - a.cidx(j)) > 0 && 
-			  a.ridx(a.cidx(j+1)-1) == i)
-			{
-			  perm [i] = j;
-			  found = true;
-			  break;
-			}
-		    }
-
-		  if (!found)
-		    break;
+		  perm [i] = -1;
+		  tmp [i] = -1;
 		}
 
+	      for (octave_idx_type j = 0; j < ncols; j++)
+		for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+		  perm [a.ridx(i)] = j;
+  
+	      found = true;
+	      for (octave_idx_type i = 0; i < nperm; i++)
+		if (perm[i] == -1)
+		  {
+		    found = false;
+		    break;
+		  }
+		else
+		  {
+		    tmp[perm[i]] = 1;
+		  }
+
 	      if (found)
-		typ = SparseType::Permuted_Upper;
-	      else
-		{
-		  OCTAVE_LOCAL_BUFFER (octave_idx_type, tmp, nperm);
-
-		  for (octave_idx_type i = 0; i < nperm; i++)
+		for (octave_idx_type i = 0; i < nm; i++)
+		  if (tmp[i] == -1)
 		    {
-		      perm [i] = -1;
-		      tmp [i] = -1;
+		      found = false;
+		      break;
 		    }
 
-		  for (octave_idx_type j = 0; j < ncols; j++)
-		    for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
-		      perm [a.ridx(i)] = j;
-  
-		  found = true;
-		  for (octave_idx_type i = 0; i < nperm; i++)
-		    if (perm[i] == -1)
-		      {
-			found = false;
-			break;
-		      }
-		    else
-		      {
-			tmp[perm[i]] = 1;
-		      }
-
-		  if (found)
-		    for (octave_idx_type i = 0; i < nperm; i++)
-		      if (tmp[i] == -1)
-			{
-			  found = false;
-			  break;
-			}
-
-		  if (found)
-		    typ = SparseType::Permuted_Lower;
-		  else
-		    {
-		      delete [] perm;
-		      nperm = 0;
-		    }
+	      if (found)
+		typ = SparseType::Permuted_Lower;
+	      else
+		{
+		  delete [] perm;
+		  nperm = 0;
 		}
 	    }
 	}
 
-      if (maybe_hermitian && (typ == Full || typ == Tridiagonal || 
-			      typ == Banded))
+      if (typ == SparseType::Full && ncols != nrows)
+	typ = SparseType::Rectangular;
+
+      if (maybe_hermitian && (typ == SparseType::Full || 
+			      typ == SparseType::Tridiagonal || 
+			      typ == SparseType::Banded))
 	{
 	  // Check for symmetry, with positive real diagonal, which
 	  // has a very good chance of being symmetric positive
 	  // definite..
 	  bool is_herm = true;
 
 	  for (octave_idx_type j = 0; j < ncols; j++)
 	    {
@@ -306,235 +316,245 @@ SparseType::SparseType (const SparseMatr
 		{
 		  is_herm = false;
 		  break;
 		} 
 	    }
 
 	  if (is_herm)
 	    {
-	      if (typ == Full)
-		typ = Hermitian;
-	      else if (typ == Banded)
-		typ = Banded_Hermitian;
+	      if (typ == SparseType::Full)
+		typ = SparseType::Hermitian;
+	      else if (typ == SparseType::Banded)
+		typ = SparseType::Banded_Hermitian;
 	      else
-		typ = Tridiagonal_Hermitian;
+		typ = SparseType::Tridiagonal_Hermitian;
 	    }
 	}
     }
 }
 
 SparseType::SparseType (const SparseComplexMatrix &a)
 {
   octave_idx_type nrows = a.rows ();
   octave_idx_type ncols = a.cols ();
+  octave_idx_type nm = (ncols < nrows ? ncols : nrows);
   octave_idx_type nnz = a.nzmax ();
 
   if (Voctave_sparse_controls.get_key ("spumoni") != 0.)
     (*current_liboctave_warning_handler) 
       ("Calculating Sparse Matrix Type");
 
   nperm = 0;
 
-  if (nrows != ncols)
-    typ = SparseType::Rectangular;
-  else
+  sp_bandden = Voctave_sparse_controls.get_key ("bandden");
+  bool maybe_hermitian = false;
+  typ = SparseType::Full;
+
+  if (nnz == nm)
     {
-      sp_bandden = Voctave_sparse_controls.get_key ("bandden");
-      bool maybe_hermitian = false;
-      typ = SparseType::Full;
-
-      if (nnz == ncols)
+      matrix_type tmp_typ = SparseType::Diagonal;
+      octave_idx_type i;
+      // Maybe the matrix is diagonal
+      for (i = 0; i < nm; i++)
 	{
-	  matrix_type tmp_typ = SparseType::Diagonal;
-	  octave_idx_type i;
-	  // Maybe the matrix is diagonal
-	  for (i = 0; i < ncols; i++)
+	  if (a.cidx(i+1) != a.cidx(i) + 1)
+	    {
+	      tmp_typ = SparseType::Full;
+	      break;
+	    }
+	  if (a.ridx(i) != i)
 	    {
-	      if (a.cidx(i+1) != a.cidx(i) + 1)
+	      tmp_typ = SparseType::Permuted_Diagonal;
+	      break;
+	    }
+	}
+	  
+      if (tmp_typ == SparseType::Permuted_Diagonal)
+	{
+	  bool found [nrows];
+
+	  for (octave_idx_type j = 0; j < i; j++)
+	    found [j] = true;
+	  for (octave_idx_type j = i; j < nrows; j++)
+	    found [j] = false;
+	      
+	  for (octave_idx_type j = i; j < nm; j++)
+	    {
+	      if ((a.cidx(j+1) > a.cidx(j) + 1)  || 
+		  ((a.cidx(j+1) == a.cidx(j) + 1) && found [a.ridx(j)]))
 		{
-		  tmp_typ = Full;
-		  break;
-		}
-	      if (a.ridx(i) != i)
-		{
-		  tmp_typ = SparseType::Permuted_Diagonal;
+		  tmp_typ = SparseType::Full;
 		  break;
 		}
+	      found [a.ridx(j)] = true;
 	    }
-	  
-	  if (tmp_typ == SparseType::Permuted_Diagonal)
-	    {
-	      bool found [ncols];
+	}
+      typ = tmp_typ;
+    }
 
-	      for (octave_idx_type j = 0; j < i; j++)
-		found [j] = true;
-	      for (octave_idx_type j = i; j < ncols; j++)
-		found [j] = false;
-	      
-	      for (octave_idx_type j = i; j < ncols; j++)
-		{
-		  if ((a.cidx(j+1) != a.cidx(j) + 1) || found [a.ridx(j)])
-		    {
-		      tmp_typ = Full;
-		      break;
-		    }
-		  found [a.ridx(j)] = true;
-		}
-	    }
-	  typ = tmp_typ;
-	}
-
-      if (typ == Full)
+  if (typ == SparseType::Full)
+    {
+      // Search for banded, upper and lower triangular matrices
+      bool singular = false;
+      upper_band = 0;
+      lower_band = 0;
+      for (octave_idx_type j = 0; j < ncols; j++)
 	{
-	  // Search for banded, upper and lower triangular matrices
-	  bool singular = false;
-	  upper_band = 0;
-	  lower_band = 0;
-	  for (octave_idx_type j = 0; j < ncols; j++)
+	  bool zero_on_diagonal = false;
+	  if (j < nrows)
 	    {
-	      bool zero_on_diagonal = true;
+	      zero_on_diagonal = true;
 	      for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
 		if (a.ridx(i) == j)
 		  {
 		    zero_on_diagonal = false;
 		    break;
 		  }
-
-	      if (zero_on_diagonal)
-		{
-		  singular = true;
-		  break;
-		}
+	    }
 
-	      if (a.cidx(j+1) - a.cidx(j) > 0)
-		{
-		  octave_idx_type ru = a.ridx(a.cidx(j));
-		  octave_idx_type rl = a.ridx(a.cidx(j+1)-1);
-
-		  if (j - ru > upper_band)
-		    upper_band = j - ru;
-		  
-		  if (rl - j > lower_band)
-		    lower_band = rl - j;
-		}
+	  if (zero_on_diagonal)
+	    {
+	      singular = true;
+	      break;
 	    }
 
-	  if (!singular)
+	  if (a.cidx(j+1) != a.cidx(j))
 	    {
-	      bandden = double (nnz) /
-		(double (ncols) * (double (lower_band) +
-				double (upper_band)) -
-		 0.5 * double (upper_band + 1) * double (upper_band) -
-		 0.5 * double (lower_band + 1) * double (lower_band));
+	      octave_idx_type ru = a.ridx(a.cidx(j));
+	      octave_idx_type rl = a.ridx(a.cidx(j+1)-1);
+
+	      if (j - ru > upper_band)
+		upper_band = j - ru;
+		  
+	      if (rl - j > lower_band)
+		lower_band = rl - j;
+	    }
+	}
 
-	      if (sp_bandden != 1. && bandden > sp_bandden)
-		{
-		  if (upper_band == 1 && lower_band == 1)
-		    typ = SparseType::Tridiagonal;
-		  else
-		    typ = SparseType::Banded;
+      if (!singular)
+	{
+	  bandden = double (nnz) /
+	    (double (ncols) * (double (lower_band) +
+			       double (upper_band)) -
+	     0.5 * double (upper_band + 1) * double (upper_band) -
+	     0.5 * double (lower_band + 1) * double (lower_band));
+
+	  if (nrows == ncols && sp_bandden != 1. && bandden > sp_bandden)
+	    {
+	      if (upper_band == 1 && lower_band == 1)
+		typ = SparseType::Tridiagonal;
+	      else
+		typ = SparseType::Banded;
 
-		  octave_idx_type nnz_in_band = (upper_band + lower_band + 1) * nrows -
-		    (1 + upper_band) * upper_band / 2 -
-		    (1 + lower_band) * lower_band / 2;
-		  if (nnz_in_band == nnz)
-		    dense = true;
-		  else 
-		    dense = false;
+	      octave_idx_type nnz_in_band = 
+		(upper_band + lower_band + 1) * nrows -
+		(1 + upper_band) * upper_band / 2 -
+		(1 + lower_band) * lower_band / 2;
+	      if (nnz_in_band == nnz)
+		dense = true;
+	      else 
+		dense = false;
+	    }
+	  else if (upper_band == 0)
+	    typ = SparseType::Lower;
+	  else if (lower_band == 0)
+	    typ = SparseType::Upper;
+
+	  if (upper_band == lower_band && nrows == ncols)
+	    maybe_hermitian = true;
+	}
+
+      if (typ == SparseType::Full)
+	{
+	  // Search for a permuted triangular matrix, and test if
+	  // permutation is singular
+
+	  // XXX FIXME XXX
+	  // Perhaps this should be based on a dmperm algorithm
+	  bool found = false;
+
+	  nperm = ncols;
+	  perm = new octave_idx_type [nperm];
+
+	  for (octave_idx_type i = 0; i < nm; i++)
+	    {
+	      found = false;
+
+	      for (octave_idx_type j = 0; j < ncols; j++)
+		{
+
+		  if ((a.cidx(j+1) - a.cidx(j)) > 0 && 
+		      a.ridx(a.cidx(j+1)-1) == i)
+		    {
+		      perm [i] = j;
+		      found = true;
+		      break;
+		    }
 		}
-	      else if (upper_band == 0)
-		typ = SparseType::Lower;
-	      else if (lower_band == 0)
-		typ = SparseType::Upper;
 
-	      if (upper_band == lower_band)
-		maybe_hermitian = true;
+	      if (!found)
+		break;
 	    }
 
-	  if (typ == Full)
+	  if (found)
+	    typ = SparseType::Permuted_Upper;
+	  else
 	    {
-	      // Search for a permuted triangular matrix, and test if
-	      // permutation is singular
-
-	      // XXX FIXME XXX Perhaps this should be based on a dmperm algorithm
-	      bool found = false;
-
+	      delete [] perm;
 	      nperm = nrows;
 	      perm = new octave_idx_type [nperm];
+	      OCTAVE_LOCAL_BUFFER (octave_idx_type, tmp, nperm);
 
 	      for (octave_idx_type i = 0; i < nperm; i++)
 		{
-		  found = false;
-
-		  for (octave_idx_type j = 0; j < ncols; j++)
-		    {
-
-		      if ((a.cidx(j+1) - a.cidx(j)) > 0 && 
-			  a.ridx(a.cidx(j+1)-1) == i)
-			{
-			  perm [i] = j;
-			  found = true;
-			  break;
-			}
-		    }
-
-		  if (!found)
-		    break;
+		  perm [i] = -1;
+		  tmp [i] = -1;
 		}
 
+	      for (octave_idx_type j = 0; j < ncols; j++)
+		for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
+		  perm [a.ridx(i)] = j;
+  
+	      found = true;
+	      for (octave_idx_type i = 0; i < nperm; i++)
+		if (perm[i] == -1)
+		  {
+		    found = false;
+		    break;
+		  }
+		else
+		  {
+		    tmp[perm[i]] = 1;
+		  }
+
 	      if (found)
-		typ = SparseType::Permuted_Upper;
-	      else
-		{
-		  OCTAVE_LOCAL_BUFFER (octave_idx_type, tmp, nperm);
-
-		  for (octave_idx_type i = 0; i < nperm; i++)
+		for (octave_idx_type i = 0; i < nm; i++)
+		  if (tmp[i] == -1)
 		    {
-		      perm [i] = -1;
-		      tmp [i] = -1;
+		      found = false;
+		      break;
 		    }
 
-		  for (octave_idx_type j = 0; j < ncols; j++)
-		    for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
-		      perm [a.ridx(i)] = j;
-  
-		  found = true;
-		  for (octave_idx_type i = 0; i < nperm; i++)
-		    if (perm[i] == -1)
-		      {
-			found = false;
-			break;
-		      }
-		    else
-		      {
-			tmp[perm[i]] = 1;
-		      }
-
-		  if (found)
-		    for (octave_idx_type i = 0; i < nperm; i++)
-		      if (tmp[i] == -1)
-			{
-			  found = false;
-			  break;
-			}
-
-		  if (found)
-		    typ = SparseType::Permuted_Lower;
-		  else
-		    {
-		      delete [] perm;
-		      nperm = 0;
-		    }
+	      if (found)
+		typ = SparseType::Permuted_Lower;
+	      else
+		{
+		  delete [] perm;
+		  nperm = 0;
 		}
 	    }
 	}
 
-      if (maybe_hermitian && (typ == Full || typ == Tridiagonal || 
-			      typ == Banded))
+      if (typ == SparseType::Full && ncols != nrows)
+	typ = SparseType::Rectangular;
+
+      if (maybe_hermitian && (typ == SparseType::Full || 
+			      typ == SparseType::Tridiagonal || 
+			      typ == SparseType::Banded))
 	{
 	  // Check for symmetry, with positive real diagonal, which
 	  // has a very good chance of being symmetric positive
 	  // definite..
 	  bool is_herm = true;
 
 	  for (octave_idx_type j = 0; j < ncols; j++)
 	    {
@@ -577,22 +597,22 @@ SparseType::SparseType (const SparseComp
 		{
 		  is_herm = false;
 		  break;
 		} 
 	    }
 
 	  if (is_herm)
 	    {
-	      if (typ == Full)
-		typ = Hermitian;
-	      else if (typ == Banded)
-		typ = Banded_Hermitian;
+	      if (typ == SparseType::Full)
+		typ = SparseType::Hermitian;
+	      else if (typ == SparseType::Banded)
+		typ = SparseType::Banded_Hermitian;
 	      else
-		typ = Tridiagonal_Hermitian;
+		typ = SparseType::Tridiagonal_Hermitian;
 	    }
 	}
     }
 }
 
 SparseType::SparseType (const matrix_type t) : typ (SparseType::Unknown), 
 					       nperm (0)
 {
@@ -884,19 +904,19 @@ SparseType
 SparseType::transpose (void) const
 {
   SparseType retval (*this);
   if (typ == SparseType::Upper)
     retval.typ = SparseType::Lower;
   else if (typ == SparseType::Permuted_Upper)
     retval.typ = SparseType::Permuted_Lower;
   else if (typ == SparseType::Lower)
-    retval.typ = Upper;
+    retval.typ = SparseType::Upper;
   else if (typ == SparseType::Permuted_Lower)
-    retval.typ = Permuted_Upper;
+    retval.typ = SparseType::Permuted_Upper;
   else if (typ == SparseType::Banded)
     {
       retval.upper_band = lower_band;
       retval.lower_band = upper_band;
     }
 
   return retval;
 }
diff --git a/liboctave/dSparse.cc b/liboctave/dSparse.cc
--- a/liboctave/dSparse.cc
+++ b/liboctave/dSparse.cc
@@ -1189,42 +1189,44 @@ SparseMatrix::determinant (octave_idx_ty
 Matrix
 SparseMatrix::dsolve (SparseType &mattype, const Matrix& b, octave_idx_type& err, 
 		      double& rcond, solve_singularity_handler) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
+  octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr == 0 || nc == 0 || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Diagonal ||
 	  typ == SparseType::Permuted_Diagonal)
 	{
-	  retval.resize (b.rows (), b.cols());
+	  retval.resize (nc, b.cols(), 0.);
 	  if (typ == SparseType::Diagonal)
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
-	      for (octave_idx_type i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nm; i++)
 		retval(i,j) = b(i,j) / data (i);
 	  else
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
-	      for (octave_idx_type i = 0; i < nr; i++)
-		retval(i,j) = b(ridx(i),j) / data (i);
-	    
+	      for (octave_idx_type k = 0; k < nc; k++)
+		for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+		  retval(k,j) = b(ridx(i),j) / data (i);
+
 	  double dmax = 0., dmin = octave_Inf; 
-	  for (octave_idx_type i = 0; i < nr; i++)
+	  for (octave_idx_type i = 0; i < nm; i++)
 	    {
 	      double tmp = fabs(data(i));
 	      if (tmp > dmax)
 		dmax = tmp;
 	      if (tmp < dmin)
 		dmin = tmp;
 	    }
 	  rcond = dmin / dmax;
@@ -1232,78 +1234,80 @@ SparseMatrix::dsolve (SparseType &mattyp
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseMatrix
-SparseMatrix::dsolve (SparseType &mattype, const SparseMatrix& b, octave_idx_type& err, 
-		     double& rcond, solve_singularity_handler) const
+SparseMatrix::dsolve (SparseType &mattype, const SparseMatrix& b, 
+		      octave_idx_type& err, 
+		      double& rcond, solve_singularity_handler) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
+  octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr == 0 || nc == 0 || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Diagonal ||
 	  typ == SparseType::Permuted_Diagonal)
 	{
-	  octave_idx_type b_nr = b.rows ();
 	  octave_idx_type b_nc = b.cols ();
 	  octave_idx_type b_nz = b.nzmax ();
-	  retval = SparseMatrix (b_nr, b_nc, b_nz);
+	  retval = SparseMatrix (nc, b_nc, b_nz);
 
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  if (typ == SparseType::Diagonal)
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      {
 		for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		  {
 		    retval.xridx (ii) = b.ridx(i);
 		    retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
 		  }
 		retval.xcidx(j+1) = ii;
 	      }
 	  else
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      {
-		for (octave_idx_type i = 0; i < nr; i++)
-		  {
-		    bool found = false;
-		    octave_idx_type k;
-		    for (k = b.cidx(j); k < b.cidx(j+1); k++)
-		      if (ridx(i) == b.ridx(k))
+		for (octave_idx_type l = 0; l < nc; l++)
+		  for (octave_idx_type i = cidx(l); i < cidx(l+1); i++)
+		    {
+		      bool found = false;
+		      octave_idx_type k;
+		      for (k = b.cidx(j); k < b.cidx(j+1); k++)
+			if (ridx(i) == b.ridx(k))
+			  {
+			    found = true;
+			    break;
+			  }
+		      if (found)
 			{
-			  found = true;
-			  break;
+			  retval.xridx (ii) = l;
+			  retval.xdata (ii++) = b.data(k) / data (i);
 			}
-		    if (found)
-		      {
-			retval.xridx (ii) = i;
-			retval.xdata (ii++) = b.data(k) / data (i);
-		      }
-		  }
+		    }
 		retval.xcidx(j+1) = ii;
 	      }
-	    
+
 	  double dmax = 0., dmin = octave_Inf; 
-	  for (octave_idx_type i = 0; i < nr; i++)
+	  for (octave_idx_type i = 0; i < nm; i++)
 	    {
 	      double tmp = fabs(data(i));
 	      if (tmp > dmax)
 		dmax = tmp;
 	      if (tmp < dmin)
 		dmin = tmp;
 	    }
 	  rcond = dmin / dmax;
@@ -1311,49 +1315,52 @@ SparseMatrix::dsolve (SparseType &mattyp
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseMatrix::dsolve (SparseType &mattype, const ComplexMatrix& b, octave_idx_type& err, 
-		     double& rcond, solve_singularity_handler) const
+SparseMatrix::dsolve (SparseType &mattype, const ComplexMatrix& b,
+		      octave_idx_type& err, 
+		      double& rcond, solve_singularity_handler) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
+  octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr == 0 || nc == 0 || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Diagonal ||
 	  typ == SparseType::Permuted_Diagonal)
 	{
-	  retval.resize (b.rows (), b.cols());
+	  retval.resize (nc, b.cols(), 0);
 	  if (typ == SparseType::Diagonal)
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
-	      for (octave_idx_type i = 0; i < nr; i++)
-		retval(i,j) = b(i,j) / data (i);
+		for (octave_idx_type i = 0; i < nm; i++)
+		  retval(i,j) = b(i,j) / data (i);
 	  else
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
-	      for (octave_idx_type i = 0; i < nr; i++)
-		retval(i,j) = b(ridx(i),j) / data (i);
+	      for (octave_idx_type k = 0; k < nc; k++)
+		for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
+		  retval(k,j) = b(ridx(i),j) / data (i);
 	    
 	  double dmax = 0., dmin = octave_Inf; 
-	  for (octave_idx_type i = 0; i < nr; i++)
+	  for (octave_idx_type i = 0; i < nm; i++)
 	    {
 	      double tmp = fabs(data(i));
 	      if (tmp > dmax)
 		dmax = tmp;
 	      if (tmp < dmin)
 		dmin = tmp;
 	    }
 	  rcond = dmin / dmax;
@@ -1369,71 +1376,72 @@ SparseComplexMatrix
 SparseMatrix::dsolve (SparseType &mattype, const SparseComplexMatrix& b,
 		     octave_idx_type& err, double& rcond, 
 		     solve_singularity_handler) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
+  octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr == 0 || nc == 0 || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Diagonal ||
 	  typ == SparseType::Permuted_Diagonal)
 	{
-	  octave_idx_type b_nr = b.rows ();
 	  octave_idx_type b_nc = b.cols ();
 	  octave_idx_type b_nz = b.nzmax ();
-	  retval = SparseComplexMatrix (b_nr, b_nc, b_nz);
+	  retval = SparseComplexMatrix (nc, b_nc, b_nz);
 
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  if (typ == SparseType::Diagonal)
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      {
 		for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		  {
 		    retval.xridx (ii) = b.ridx(i);
 		    retval.xdata (ii++) = b.data(i) / data (b.ridx (i));
 		  }
 		retval.xcidx(j+1) = ii;
 	      }
 	  else
 	    for (octave_idx_type j = 0; j < b.cols(); j++)
 	      {
-		for (octave_idx_type i = 0; i < nr; i++)
-		  {
-		    bool found = false;
-		    octave_idx_type k;
-		    for (k = b.cidx(j); k < b.cidx(j+1); k++)
-		      if (ridx(i) == b.ridx(k))
+		for (octave_idx_type l = 0; l < nc; l++)
+		  for (octave_idx_type i = cidx(l); i < cidx(l+1); i++)
+		    {
+		      bool found = false;
+		      octave_idx_type k;
+		      for (k = b.cidx(j); k < b.cidx(j+1); k++)
+			if (ridx(i) == b.ridx(k))
+			  {
+			    found = true;
+			    break;
+			  }
+		      if (found)
 			{
-			  found = true;
-			  break;
+			  retval.xridx (ii) = l;
+			  retval.xdata (ii++) = b.data(k) / data (i);
 			}
-		    if (found)
-		      {
-			retval.xridx (ii) = i;
-			retval.xdata (ii++) = b.data(k) / data (i);
-		      }
-		  }
+		    }
 		retval.xcidx(j+1) = ii;
 	      }
 	    
 	  double dmax = 0., dmin = octave_Inf; 
-	  for (octave_idx_type i = 0; i < nr; i++)
+	  for (octave_idx_type i = 0; i < nm; i++)
 	    {
 	      double tmp = fabs(data(i));
 	      if (tmp > dmax)
 		dmax = tmp;
 	      if (tmp < dmin)
 		dmin = tmp;
 	    }
 	  rcond = dmin / dmax;
@@ -1441,65 +1449,68 @@ SparseMatrix::dsolve (SparseType &mattyp
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 Matrix
-SparseMatrix::utsolve (SparseType &mattype, const Matrix& b, octave_idx_type& err, 
-		       double& rcond,
+SparseMatrix::utsolve (SparseType &mattype, const Matrix& b,
+		       octave_idx_type& err, double& rcond,
 		       solve_singularity_handler sing_handler) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
+  octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr == 0 || nc == 0 || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Permuted_Upper ||
 	  typ == SparseType::Upper)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
-	  octave_idx_type b_cols = b.cols ();
+	  octave_idx_type b_nc = b.cols ();
 	  rcond = 0.;
 
 	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (octave_idx_type j = 0; j < nr; j++)
+	  for (octave_idx_type j = 0; j < nc; j++)
 	    {
 	      double atmp = 0.;
 	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += fabs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
 	  if (typ == SparseType::Permuted_Upper)
 	    {
-	      retval.resize (nr, b_cols);
+	      retval.resize (nc, b_nc);
 	      octave_idx_type *perm = mattype.triangular_perm ();
-	      OCTAVE_LOCAL_BUFFER (double, work, nr);
-
-	      for (octave_idx_type j = 0; j < b_cols; j++)
+	      OCTAVE_LOCAL_BUFFER (double, work, nm);
+
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[i] = b(i,j);
-
-		  for (octave_idx_type k = nr-1; k >= 0; k--)
+		  for (octave_idx_type i = nr; i < nc; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type k = nc-1; k >= 0; k--)
 		    {
 		      octave_idx_type kidx = perm[k];
 
 		      if (work[k] != 0.)
 			{
 			  if (ridx(cidx(kidx+1)-1) != k)
 			    {
 			      err = -2;
@@ -1512,22 +1523,22 @@ SparseMatrix::utsolve (SparseType &matty
 			       i < cidx(kidx+1)-1; i++)
 			    {
 			      octave_idx_type iidx = ridx(i);
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    retval (perm[i], j) = work[i];
+		  for (octave_idx_type i = 0; i < nc; i++)
+		    retval.xelem (perm[i], j) = work[i];
 		}
 
 	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nm; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
 		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
@@ -1551,48 +1562,52 @@ SparseMatrix::utsolve (SparseType &matty
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
 	  else
 	    {
-	      retval = b;
-	      double *x_vec = retval.fortran_vec ();
-
-	      for (octave_idx_type j = 0; j < b_cols; j++)
+	      OCTAVE_LOCAL_BUFFER (double, work, nm);
+	      retval.resize (nc, b_nc);
+
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  octave_idx_type offset = j * nr;
-		  for (octave_idx_type k = nr-1; k >= 0; k--)
+		  for (octave_idx_type i = 0; i < nr; i++)
+		    work[i] = b(i,j);
+		  for (octave_idx_type i = nr; i < nc; i++)
+		    work[i] = 0.;
+
+		  for (octave_idx_type k = nc-1; k >= 0; k--)
 		    {
-		      if (x_vec[k+offset] != 0.)
+		      if (work[k] != 0.)
 			{
 			  if (ridx(cidx(k+1)-1) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
-			  double tmp = x_vec[k+offset] / 
-			    data(cidx(k+1)-1);
-			  x_vec[k+offset] = tmp;
+			  double tmp = work[k] / data(cidx(k+1)-1);
+			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
 			    {
 			      octave_idx_type iidx = ridx(i);
-			      x_vec[iidx+offset] = 
-				x_vec[iidx+offset] - tmp * data(i);
+			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
+
+		  for (octave_idx_type i = 0; i < nc; i++)
+		    retval.xelem (i, j) = work[i];
 		}
 
 	      // Calculation of 1-norm of inv(*this)
-	      OCTAVE_LOCAL_BUFFER (double, work, nr);
-	      for (octave_idx_type i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nm; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
 		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
@@ -1648,76 +1663,77 @@ SparseMatrix::utsolve (SparseType &matty
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseMatrix
-SparseMatrix::utsolve (SparseType &mattype, const SparseMatrix& b, octave_idx_type& err, 
-		     double& rcond, solve_singularity_handler sing_handler) const
+SparseMatrix::utsolve (SparseType &mattype, const SparseMatrix& b,
+		       octave_idx_type& err, double& rcond, 
+		       solve_singularity_handler sing_handler) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
+  octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr == 0 || nc == 0 || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
 
       if (typ == SparseType::Permuted_Upper ||
 	  typ == SparseType::Upper)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  rcond = 0.;
 
 	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (octave_idx_type j = 0; j < nr; j++)
+	  for (octave_idx_type j = 0; j < nc; j++)
 	    {
 	      double atmp = 0.;
 	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += fabs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
-	  octave_idx_type b_nr = b.rows ();
 	  octave_idx_type b_nc = b.cols ();
 	  octave_idx_type b_nz = b.nzmax ();
-	  retval = SparseMatrix (b_nr, b_nc, b_nz);
+	  retval = SparseMatrix (nc, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Upper)
 	    {
 	      octave_idx_type *perm = mattype.triangular_perm ();
-	      OCTAVE_LOCAL_BUFFER (double, work, nr);
-
-	      OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nr);
-	      for (octave_idx_type i = 0; i < nr; i++)
+	      OCTAVE_LOCAL_BUFFER (double, work, nm);
+
+	      OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nc);
+	      for (octave_idx_type i = 0; i < nc; i++)
 		rperm[perm[i]] = i;
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nm; i++)
 		    work[i] = 0.;
 		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[b.ridx(i)] = b.data(i);
 
-		  for (octave_idx_type k = nr-1; k >= 0; k--)
+		  for (octave_idx_type k = nc-1; k >= 0; k--)
 		    {
 		      octave_idx_type kidx = perm[k];
 
 		      if (work[k] != 0.)
 			{
 			  if (ridx(cidx(kidx+1)-1) != k)
 			    {
 			      err = -2;
@@ -1733,41 +1749,41 @@ SparseMatrix::utsolve (SparseType &matty
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
 		  octave_idx_type new_nnz = 0;
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nc; i++)
 		    if (work[i] != 0.)
 		      new_nnz++;
 
 		  if (ii + new_nnz > x_nz)
 		    {
 		      // Resize the sparse matrix
 		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nc; i++)
 		    if (work[rperm[i]] != 0.)
 		      {
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[rperm[i]];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nm; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
 		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
@@ -1791,26 +1807,26 @@ SparseMatrix::utsolve (SparseType &matty
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
 	  else
 	    {
-	      OCTAVE_LOCAL_BUFFER (double, work, nr);
+	      OCTAVE_LOCAL_BUFFER (double, work, nm);
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nm; i++)
 		    work[i] = 0.;
 		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[b.ridx(i)] = b.data(i);
 
-		  for (octave_idx_type k = nr-1; k >= 0; k--)
+		  for (octave_idx_type k = nc-1; k >= 0; k--)
 		    {
 		      if (work[k] != 0.)
 			{
 			  if (ridx(cidx(k+1)-1) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
@@ -1823,41 +1839,41 @@ SparseMatrix::utsolve (SparseType &matty
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
 		  octave_idx_type new_nnz = 0;
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nc; i++)
 		    if (work[i] != 0.)
 		      new_nnz++;
 
 		  if (ii + new_nnz > x_nz)
 		    {
 		      // Resize the sparse matrix
 		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nc; i++)
 		    if (work[i] != 0.)
 		      {
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[i];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nm; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
 		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
@@ -1912,26 +1928,28 @@ SparseMatrix::utsolve (SparseType &matty
 	}
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
   return retval;
 }
 
 ComplexMatrix
-SparseMatrix::utsolve (SparseType &mattype, const ComplexMatrix& b, octave_idx_type& err, 
-		     double& rcond, solve_singularity_handler sing_handler) const
+SparseMatrix::utsolve (SparseType &mattype, const ComplexMatrix& b, 
+		       octave_idx_type& err, double& rcond, 
+		       solve_singularity_handler sing_handler) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
+  octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr == 0 || nc == 0 || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
@@ -1939,37 +1957,39 @@ SparseMatrix::utsolve (SparseType &matty
 	  typ == SparseType::Upper)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  octave_idx_type b_nc = b.cols ();
 	  rcond = 0.;
 
 	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (octave_idx_type j = 0; j < nr; j++)
+	  for (octave_idx_type j = 0; j < nc; j++)
 	    {
 	      double atmp = 0.;
 	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += fabs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
 	  if (typ == SparseType::Permuted_Upper)
 	    {
-	      retval.resize (nr, b_nc);
+	      retval.resize (nc, b_nc);
 	      octave_idx_type *perm = mattype.triangular_perm ();
-	      OCTAVE_LOCAL_BUFFER (Complex, cwork, nr);
+	      OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
 		  for (octave_idx_type i = 0; i < nr; i++)
 		    cwork[i] = b(i,j);
-
-		  for (octave_idx_type k = nr-1; k >= 0; k--)
+		  for (octave_idx_type i = nr; i < nc; i++)
+		    cwork[i] = 0.;
+
+		  for (octave_idx_type k = nc-1; k >= 0; k--)
 		    {
 		      octave_idx_type kidx = perm[k];
 
 		      if (cwork[k] != 0.)
 			{
 			  if (ridx(cidx(kidx+1)-1) != k)
 			    {
 			      err = -2;
@@ -1982,23 +2002,23 @@ SparseMatrix::utsolve (SparseType &matty
 			       i < cidx(kidx+1)-1; i++)
 			    {
 			      octave_idx_type iidx = ridx(i);
 			      cwork[iidx] = cwork[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    retval (perm[i], j) = cwork[i];
+		  for (octave_idx_type i = 0; i < nc; i++)
+		    retval.xelem (perm[i], j) = cwork[i];
 		}
 
 	      // Calculation of 1-norm of inv(*this)
-	      OCTAVE_LOCAL_BUFFER (double, work, nr);
-	      for (octave_idx_type i = 0; i < nr; i++)
+	      OCTAVE_LOCAL_BUFFER (double, work, nm);
+	      for (octave_idx_type i = 0; i < nm; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
 		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
@@ -2022,48 +2042,53 @@ SparseMatrix::utsolve (SparseType &matty
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
 	  else
 	    {
-	      retval = b;
-	      Complex *x_vec = retval.fortran_vec ();
+	      OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
+	      retval.resize (nc, b_nc);
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  octave_idx_type offset = j * nr;
-		  for (octave_idx_type k = nr-1; k >= 0; k--)
+		  for (octave_idx_type i = 0; i < nr; i++)
+		    cwork[i] = b(i,j);
+		  for (octave_idx_type i = nr; i < nc; i++)
+		    cwork[i] = 0.;
+
+		  for (octave_idx_type k = nc-1; k >= 0; k--)
 		    {
-		      if (x_vec[k+offset] != 0.)
+		      if (cwork[k] != 0.)
 			{
 			  if (ridx(cidx(k+1)-1) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
-			  Complex tmp = x_vec[k+offset] / 
-			    data(cidx(k+1)-1);
-			  x_vec[k+offset] = tmp;
+			  Complex tmp = cwork[k] / data(cidx(k+1)-1);
+			  cwork[k] = tmp;
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
 			    {
 			      octave_idx_type iidx = ridx(i);
-			      x_vec[iidx+offset] = 
-				x_vec[iidx+offset] - tmp * data(i);
+			      cwork[iidx] = cwork[iidx] - tmp  * data(i);
 			    }
 			}
 		    }
+
+		  for (octave_idx_type i = 0; i < nc; i++)
+		    retval.xelem (i, j) = cwork[i];
 		}
 
 	      // Calculation of 1-norm of inv(*this)
-	      OCTAVE_LOCAL_BUFFER (double, work, nr);
-	      for (octave_idx_type i = 0; i < nr; i++)
+	      OCTAVE_LOCAL_BUFFER (double, work, nm);
+	      for (octave_idx_type i = 0; i < nm; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
 		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
@@ -2120,76 +2145,76 @@ SparseMatrix::utsolve (SparseType &matty
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseMatrix::utsolve (SparseType &mattype, const SparseComplexMatrix& b,
-		     octave_idx_type& err, double& rcond, 
-		     solve_singularity_handler sing_handler) const
+		       octave_idx_type& err, double& rcond, 
+		       solve_singularity_handler sing_handler) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
+  octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr == 0 || nc == 0 || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == SparseType::Permuted_Upper ||
 	  typ == SparseType::Upper)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  rcond = 0.;
 
 	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (octave_idx_type j = 0; j < nr; j++)
+	  for (octave_idx_type j = 0; j < nc; j++)
 	    {
 	      double atmp = 0.;
 	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += fabs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
-	  octave_idx_type b_nr = b.rows ();
 	  octave_idx_type b_nc = b.cols ();
 	  octave_idx_type b_nz = b.nzmax ();
-	  retval = SparseComplexMatrix (b_nr, b_nc, b_nz);
+	  retval = SparseComplexMatrix (nc, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Upper)
 	    {
 	      octave_idx_type *perm = mattype.triangular_perm ();
-	      OCTAVE_LOCAL_BUFFER (Complex, cwork, nr);
-
-	      OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nr);
-	      for (octave_idx_type i = 0; i < nr; i++)
+	      OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
+
+	      OCTAVE_LOCAL_BUFFER (octave_idx_type, rperm, nc);
+	      for (octave_idx_type i = 0; i < nc; i++)
 		rperm[perm[i]] = i;
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nm; i++)
 		    cwork[i] = 0.;
 		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    cwork[b.ridx(i)] = b.data(i);
 
-		  for (octave_idx_type k = nr-1; k >= 0; k--)
+		  for (octave_idx_type k = nc-1; k >= 0; k--)
 		    {
 		      octave_idx_type kidx = perm[k];
 
 		      if (cwork[k] != 0.)
 			{
 			  if (ridx(cidx(kidx+1)-1) != k)
 			    {
 			      err = -2;
@@ -2205,42 +2230,42 @@ SparseMatrix::utsolve (SparseType &matty
 			      cwork[iidx] = cwork[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
 		  octave_idx_type new_nnz = 0;
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nc; i++)
 		    if (cwork[i] != 0.)
 		      new_nnz++;
 
 		  if (ii + new_nnz > x_nz)
 		    {
 		      // Resize the sparse matrix
 		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nc; i++)
 		    if (cwork[rperm[i]] != 0.)
 		      {
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = cwork[rperm[i]];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
-	      OCTAVE_LOCAL_BUFFER (double, work, nr);
-	      for (octave_idx_type i = 0; i < nr; i++)
+	      OCTAVE_LOCAL_BUFFER (double, work, nm);
+	      for (octave_idx_type i = 0; i < nm; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
 		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
@@ -2264,98 +2289,98 @@ SparseMatrix::utsolve (SparseType &matty
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
 	  else
 	    {
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
+	      OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    work[i] = 0.;
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    cwork[i] = 0.;
 		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-		    work[b.ridx(i)] = b.data(i);
-
-		  for (octave_idx_type k = nr-1; k >= 0; k--)
+		    cwork[b.ridx(i)] = b.data(i);
+
+		  for (octave_idx_type k = nc-1; k >= 0; k--)
 		    {
-		      if (work[k] != 0.)
+		      if (cwork[k] != 0.)
 			{
 			  if (ridx(cidx(k+1)-1) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
-			  Complex tmp = work[k] / data(cidx(k+1)-1);
-			  work[k] = tmp;
+			  Complex tmp = cwork[k] / data(cidx(k+1)-1);
+			  cwork[k] = tmp;
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
 			    {
 			      octave_idx_type iidx = ridx(i);
-			      work[iidx] = work[iidx] - tmp * data(i);
+			      cwork[iidx] = cwork[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
 		  octave_idx_type new_nnz = 0;
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    if (work[i] != 0.)
+		  for (octave_idx_type i = 0; i < nc; i++)
+		    if (cwork[i] != 0.)
 		      new_nnz++;
 
 		  if (ii + new_nnz > x_nz)
 		    {
 		      // Resize the sparse matrix
 		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    if (work[i] != 0.)
+		  for (octave_idx_type i = 0; i < nc; i++)
+		    if (cwork[i] != 0.)
 		      {
 			retval.xridx(ii) = i;
-			retval.xdata(ii++) = work[i];
+			retval.xdata(ii++) = cwork[i];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
-	      OCTAVE_LOCAL_BUFFER (double, work2, nr);
-	      for (octave_idx_type i = 0; i < nr; i++)
-		work2[i] = 0.;
+	      OCTAVE_LOCAL_BUFFER (double, work, nm);
+	      for (octave_idx_type i = 0; i < nm; i++)
+		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
-		  work2[j] = 1.;
+		  work[j] = 1.;
 
 		  for (octave_idx_type k = j; k >= 0; k--)
 		    {
-		      if (work2[k] != 0.)
+		      if (work[k] != 0.)
 			{
-			  double tmp = work2[k] / data(cidx(k+1)-1);
-			  work2[k] = tmp;
+			  double tmp = work[k] / data(cidx(k+1)-1);
+			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
 			    {
 			      octave_idx_type iidx = ridx(i);
-			      work2[iidx] = work2[iidx] - tmp * data(i);
+			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
 		  for (octave_idx_type i = 0; i < j+1; i++)
 		    {
-		      atmp += fabs(work2[i]);
-		      work2[i] = 0.;
+		      atmp += fabs(work[i]);
+		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
 
 	  rcond = 1. / ainvnorm / anorm;
 
@@ -2387,65 +2412,69 @@ SparseMatrix::utsolve (SparseType &matty
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 Matrix
-SparseMatrix::ltsolve (SparseType &mattype, const Matrix& b, octave_idx_type& err, 
-		       double& rcond,
+SparseMatrix::ltsolve (SparseType &mattype, const Matrix& b,
+		       octave_idx_type& err, double& rcond,
 		       solve_singularity_handler sing_handler) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
+  octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr == 0 || nc == 0 || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == SparseType::Permuted_Lower ||
 	  typ == SparseType::Lower)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
-	  octave_idx_type b_cols = b.cols ();
+	  octave_idx_type b_nc = b.cols ();
 	  rcond = 0.;
 
 	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (octave_idx_type j = 0; j < nr; j++)
+	  for (octave_idx_type j = 0; j < nc; j++)
 	    {
 	      double atmp = 0.;
 	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += fabs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
 	  if (typ == SparseType::Permuted_Lower)
 	    {
-	      retval.resize (b.rows (), b.cols ());
-	      OCTAVE_LOCAL_BUFFER (double, work, nr);
+	      retval.resize (nc, b_nc);
+	      OCTAVE_LOCAL_BUFFER (double, work, nm);
 	      octave_idx_type *perm = mattype.triangular_perm ();
 
-	      for (octave_idx_type j = 0; j < b_cols; j++)
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
+		  if (nc > nr)
+		    for (octave_idx_type i = 0; i < nm; i++)
+		      work[i] = 0.;
 		  for (octave_idx_type i = 0; i < nr; i++)
 		    work[perm[i]] = b(i,j);
 
-		  for (octave_idx_type k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nc; k++)
 		    {
 		      if (work[k] != 0.)
 			{
 			  octave_idx_type minr = nr;
 			  octave_idx_type mini = 0;
 
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    if (perm[ridx(i)] < minr)
@@ -2468,29 +2497,29 @@ SparseMatrix::ltsolve (SparseType &matty
 				continue;
 
 			      octave_idx_type iidx = perm[ridx(i)];
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nc; i++)
 		    retval (i, j) = work[i];
 		}
 
 	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nm; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
-		  for (octave_idx_type k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nc; k++)
 		    {
 		      if (work[k] != 0.)
 			{
 			  octave_idx_type minr = nr;
 			  octave_idx_type mini = 0;
 
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    if (perm[ridx(i)] < minr)
@@ -2508,81 +2537,85 @@ SparseMatrix::ltsolve (SparseType &matty
 
 			      octave_idx_type iidx = perm[ridx(i)];
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  double atmp = 0;
-		  for (octave_idx_type i = j; i < nr; i++)
+		  for (octave_idx_type i = j; i < nc; i++)
 		    {
 		      atmp += fabs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
 	  else
 	    {
-	      retval = b;
-	      double *x_vec = retval.fortran_vec ();
-
-	      for (octave_idx_type j = 0; j < b_cols; j++)
+	      OCTAVE_LOCAL_BUFFER (double, work, nm);
+	      retval.resize (nc, b_nc, 0.);
+
+	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  octave_idx_type offset = j * nr;
-		  for (octave_idx_type k = 0; k < nr; k++)
+		  for (octave_idx_type i = 0; i < nr; i++)
+		    work[i] = b(i,j);
+		  for (octave_idx_type i = nr; i < nc; i++)
+		    work[i] = 0.;
+		  for (octave_idx_type k = 0; k < nc; k++)
 		    {
-		      if (x_vec[k+offset] != 0.)
+		      if (work[k] != 0.)
 			{
 			  if (ridx(cidx(k)) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
-			  double tmp = x_vec[k+offset] / 
-			    data(cidx(k));
-			  x_vec[k+offset] = tmp;
-			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
+			  double tmp = work[k] / data(cidx(k));
+			  work[k] = tmp;
+			  for (octave_idx_type i = cidx(k)+1; 
+			       i < cidx(k+1); i++)
 			    {
 			      octave_idx_type iidx = ridx(i);
-			      x_vec[iidx+offset] = 
-				x_vec[iidx+offset] - tmp * data(i);
+			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
+
+		  for (octave_idx_type i = 0; i < nc; i++)
+		    retval.xelem (i, j) = work[i];
 		}
 
 	      // Calculation of 1-norm of inv(*this)
-	      OCTAVE_LOCAL_BUFFER (double, work, nr);
-	      for (octave_idx_type i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nm; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
-		  for (octave_idx_type k = j; k < nr; k++)
+		  for (octave_idx_type k = j; k < nc; k++)
 		    {
 
 		      if (work[k] != 0.)
 			{
 			  double tmp = work[k] / data(cidx(k));
 			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
 			    {
 			      octave_idx_type iidx = ridx(i);
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (octave_idx_type i = j; i < nr; i++)
+		  for (octave_idx_type i = j; i < nc; i++)
 		    {
 		      atmp += fabs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 
@@ -2618,43 +2651,45 @@ SparseMatrix::ltsolve (SparseType &matty
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseMatrix
-SparseMatrix::ltsolve (SparseType &mattype, const SparseMatrix& b, octave_idx_type& err, 
-		     double& rcond, solve_singularity_handler sing_handler) const
+SparseMatrix::ltsolve (SparseType &mattype, const SparseMatrix& b, 
+		       octave_idx_type& err, double& rcond, 
+		       solve_singularity_handler sing_handler) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
+  octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr == 0 || nc == 0 || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == SparseType::Permuted_Lower ||
 	  typ == SparseType::Lower)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  rcond = 0.;
 
 	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (octave_idx_type j = 0; j < nr; j++)
+	  for (octave_idx_type j = 0; j < nc; j++)
 	    {
 	      double atmp = 0.;
 	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += fabs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
@@ -2668,22 +2703,22 @@ SparseMatrix::ltsolve (SparseType &matty
 
 	  if (typ == SparseType::Permuted_Lower)
 	    {
 	      OCTAVE_LOCAL_BUFFER (double, work, nr);
 	      octave_idx_type *perm = mattype.triangular_perm ();
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nm; i++)
 		    work[i] = 0.;
 		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[perm[b.ridx(i)]] = b.data(i);
 
-		  for (octave_idx_type k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nc; k++)
 		    {
 		      if (work[k] != 0.)
 			{
 			  octave_idx_type minr = nr;
 			  octave_idx_type mini = 0;
 
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    if (perm[ridx(i)] < minr)
@@ -2709,48 +2744,48 @@ SparseMatrix::ltsolve (SparseType &matty
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
 		  octave_idx_type new_nnz = 0;
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nc; i++)
 		    if (work[i] != 0.)
 		      new_nnz++;
 
 		  if (ii + new_nnz > x_nz)
 		    {
 		      // Resize the sparse matrix
 		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nc; i++)
 		    if (work[i] != 0.)
 		      {
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[i];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nm; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
-		  for (octave_idx_type k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nc; k++)
 		    {
 		      if (work[k] != 0.)
 			{
 			  octave_idx_type minr = nr;
 			  octave_idx_type mini = 0;
 
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    if (perm[ridx(i)] < minr)
@@ -2783,22 +2818,22 @@ SparseMatrix::ltsolve (SparseType &matty
 		}
 	    }
 	  else
 	    {
 	      OCTAVE_LOCAL_BUFFER (double, work, nr);
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nm; i++)
 		    work[i] = 0.;
 		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    work[b.ridx(i)] = b.data(i);
 
-		  for (octave_idx_type k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nc; k++)
 		    {
 		      if (work[k] != 0.)
 			{
 			  if (ridx(cidx(k)) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
@@ -2811,63 +2846,63 @@ SparseMatrix::ltsolve (SparseType &matty
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
 		  octave_idx_type new_nnz = 0;
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nc; i++)
 		    if (work[i] != 0.)
 		      new_nnz++;
 
 		  if (ii + new_nnz > x_nz)
 		    {
 		      // Resize the sparse matrix
 		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nc; i++)
 		    if (work[i] != 0.)
 		      {
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = work[i];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
-	      for (octave_idx_type i = 0; i < nr; i++)
+	      for (octave_idx_type i = 0; i < nm; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
-		  for (octave_idx_type k = j; k < nr; k++)
+		  for (octave_idx_type k = j; k < nc; k++)
 		    {
 
 		      if (work[k] != 0.)
 			{
 			  double tmp = work[k] / data(cidx(k));
 			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
 			    {
 			      octave_idx_type iidx = ridx(i);
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (octave_idx_type i = j; i < nr; i++)
+		  for (octave_idx_type i = j; i < nc; i++)
 		    {
 		      atmp += fabs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 
@@ -2903,26 +2938,28 @@ SparseMatrix::ltsolve (SparseType &matty
       else
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseMatrix::ltsolve (SparseType &mattype, const ComplexMatrix& b, octave_idx_type& err, 
-		     double& rcond, solve_singularity_handler sing_handler) const
+SparseMatrix::ltsolve (SparseType &mattype, const ComplexMatrix& b, 
+		       octave_idx_type& err, double& rcond, 
+		       solve_singularity_handler sing_handler) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
+  octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr == 0 || nc == 0 || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
@@ -2930,37 +2967,39 @@ SparseMatrix::ltsolve (SparseType &matty
 	  typ == SparseType::Lower)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  octave_idx_type b_nc = b.cols ();
 	  rcond = 0.;
 
 	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (octave_idx_type j = 0; j < nr; j++)
+	  for (octave_idx_type j = 0; j < nc; j++)
 	    {
 	      double atmp = 0.;
 	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += fabs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
 	  if (typ == SparseType::Permuted_Lower)
 	    {
-	      retval.resize (b.rows (), b.cols ());
+	      retval.resize (nc, b_nc);
 	      OCTAVE_LOCAL_BUFFER (Complex, cwork, nr);
 	      octave_idx_type *perm = mattype.triangular_perm ();
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    cwork[i] = 0.;
 		  for (octave_idx_type i = 0; i < nr; i++)
 		    cwork[perm[i]] = b(i,j);
 
-		  for (octave_idx_type k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nc; k++)
 		    {
 		      if (cwork[k] != 0.)
 			{
 			  octave_idx_type minr = nr;
 			  octave_idx_type mini = 0;
 
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    if (perm[ridx(i)] < minr)
@@ -2983,30 +3022,30 @@ SparseMatrix::ltsolve (SparseType &matty
 				continue;
 
 			      octave_idx_type iidx = perm[ridx(i)];
 			      cwork[iidx] = cwork[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nc; i++)
 		    retval (i, j) = cwork[i];
 		}
 
 	      // Calculation of 1-norm of inv(*this)
-	      OCTAVE_LOCAL_BUFFER (double, work, nr);
-	      for (octave_idx_type i = 0; i < nr; i++)
+	      OCTAVE_LOCAL_BUFFER (double, work, nm);
+	      for (octave_idx_type i = 0; i < nm; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
-		  for (octave_idx_type k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nc; k++)
 		    {
 		      if (work[k] != 0.)
 			{
 			  octave_idx_type minr = nr;
 			  octave_idx_type mini = 0;
 
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    if (perm[ridx(i)] < minr)
@@ -3024,81 +3063,86 @@ SparseMatrix::ltsolve (SparseType &matty
 
 			      octave_idx_type iidx = perm[ridx(i)];
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  double atmp = 0;
-		  for (octave_idx_type i = j; i < nr; i++)
+		  for (octave_idx_type i = j; i < nc; i++)
 		    {
 		      atmp += fabs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
 	  else
 	    {
-	      retval = b;
-	      Complex *x_vec = retval.fortran_vec ();
+	      OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
+	      retval.resize (nc, b_nc, 0.);
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  octave_idx_type offset = j * nr;
-		  for (octave_idx_type k = 0; k < nr; k++)
+		  for (octave_idx_type i = 0; i < nr; i++)
+		    cwork[i] = b(i,j);
+		  for (octave_idx_type i = nr; i < nc; i++)
+		    cwork[i] = 0.;
+
+		  for (octave_idx_type k = 0; k < nc; k++)
 		    {
-		      if (x_vec[k+offset] != 0.)
+		      if (cwork[k] != 0.)
 			{
 			  if (ridx(cidx(k)) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
-			  Complex tmp = x_vec[k+offset] / 
-			    data(cidx(k));
-			  x_vec[k+offset] = tmp;
+			  Complex tmp = cwork[k] / data(cidx(k));
+			  cwork[k] = tmp;
 			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
 			    {
 			      octave_idx_type iidx = ridx(i);
-			      x_vec[iidx+offset] = 
-				x_vec[iidx+offset] - tmp * data(i);
+			      cwork[iidx] = cwork[iidx] - tmp * data(i);
 			    }
 			}
 		    }
+
+		  for (octave_idx_type i = 0; i < nc; i++)
+		    retval.xelem (i, j) = cwork[i];
 		}
 
 	      // Calculation of 1-norm of inv(*this)
-	      OCTAVE_LOCAL_BUFFER (double, work, nr);
-	      for (octave_idx_type i = 0; i < nr; i++)
+	      OCTAVE_LOCAL_BUFFER (double, work, nm);
+	      for (octave_idx_type i = 0; i < nm; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
-		  for (octave_idx_type k = j; k < nr; k++)
+		  for (octave_idx_type k = j; k < nc; k++)
 		    {
 
 		      if (work[k] != 0.)
 			{
 			  double tmp = work[k] / data(cidx(k));
 			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
 			    {
 			      octave_idx_type iidx = ridx(i);
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (octave_idx_type i = j; i < nr; i++)
+		  for (octave_idx_type i = j; i < nc; i++)
 		    {
 		      atmp += fabs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 
@@ -3135,72 +3179,72 @@ SparseMatrix::ltsolve (SparseType &matty
 	(*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseMatrix::ltsolve (SparseType &mattype, const SparseComplexMatrix& b,
-		     octave_idx_type& err, double& rcond, 
-		     solve_singularity_handler sing_handler) const
+		       octave_idx_type& err, double& rcond, 
+		       solve_singularity_handler sing_handler) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
+  octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
 
-  if (nr == 0 || nc == 0 || nr != nc || nr != b.rows ())
+  if (nr == 0 || nc == 0 || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
       
       if (typ == SparseType::Permuted_Lower ||
 	  typ == SparseType::Lower)
 	{
 	  double anorm = 0.;
 	  double ainvnorm = 0.;
 	  rcond = 0.;
 
 	  // Calculate the 1-norm of matrix for rcond calculation
-	  for (octave_idx_type j = 0; j < nr; j++)
+	  for (octave_idx_type j = 0; j < nc; j++)
 	    {
 	      double atmp = 0.;
 	      for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 		atmp += fabs(data(i));
 	      if (atmp > anorm)
 		anorm = atmp;
 	    }
 
-	  octave_idx_type b_nr = b.rows ();
 	  octave_idx_type b_nc = b.cols ();
 	  octave_idx_type b_nz = b.nzmax ();
-	  retval = SparseComplexMatrix (b_nr, b_nc, b_nz);
+	  retval = SparseComplexMatrix (nc, b_nc, b_nz);
 	  retval.xcidx(0) = 0;
 	  octave_idx_type ii = 0;
 	  octave_idx_type x_nz = b_nz;
 
 	  if (typ == SparseType::Permuted_Lower)
 	    {
-	      OCTAVE_LOCAL_BUFFER (Complex, cwork, nr);
+	      OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
 	      octave_idx_type *perm = mattype.triangular_perm ();
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nm; i++)
 		    cwork[i] = 0.;
 		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
 		    cwork[perm[b.ridx(i)]] = b.data(i);
 
-		  for (octave_idx_type k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nc; k++)
 		    {
 		      if (cwork[k] != 0.)
 			{
 			  octave_idx_type minr = nr;
 			  octave_idx_type mini = 0;
 
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    if (perm[ridx(i)] < minr)
@@ -3226,49 +3270,49 @@ SparseMatrix::ltsolve (SparseType &matty
 			      cwork[iidx] = cwork[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
 		  octave_idx_type new_nnz = 0;
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nc; i++)
 		    if (cwork[i] != 0.)
 		      new_nnz++;
 
 		  if (ii + new_nnz > x_nz)
 		    {
 		      // Resize the sparse matrix
 		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
-		  for (octave_idx_type i = 0; i < nr; i++)
+		  for (octave_idx_type i = 0; i < nc; i++)
 		    if (cwork[i] != 0.)
 		      {
 			retval.xridx(ii) = i;
 			retval.xdata(ii++) = cwork[i];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
-	      OCTAVE_LOCAL_BUFFER (double, work, nr);
-	      for (octave_idx_type i = 0; i < nr; i++)
+	      OCTAVE_LOCAL_BUFFER (double, work, nm);
+	      for (octave_idx_type i = 0; i < nm; i++)
 		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
 		  work[j] = 1.;
 
-		  for (octave_idx_type k = 0; k < nr; k++)
+		  for (octave_idx_type k = 0; k < nc; k++)
 		    {
 		      if (work[k] != 0.)
 			{
 			  octave_idx_type minr = nr;
 			  octave_idx_type mini = 0;
 
 			  for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
 			    if (perm[ridx(i)] < minr)
@@ -3286,110 +3330,110 @@ SparseMatrix::ltsolve (SparseType &matty
 
 			      octave_idx_type iidx = perm[ridx(i)];
 			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  double atmp = 0;
-		  for (octave_idx_type i = j; i < nr; i++)
+		  for (octave_idx_type i = j; i < nc; i++)
 		    {
 		      atmp += fabs(work[i]);
 		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 	    }
 	  else
 	    {
-	      OCTAVE_LOCAL_BUFFER (Complex, work, nr);
+	      OCTAVE_LOCAL_BUFFER (Complex, cwork, nm);
 
 	      for (octave_idx_type j = 0; j < b_nc; j++)
 		{
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    work[i] = 0.;
+		  for (octave_idx_type i = 0; i < nm; i++)
+		    cwork[i] = 0.;
 		  for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
-		    work[b.ridx(i)] = b.data(i);
-
-		  for (octave_idx_type k = 0; k < nr; k++)
+		    cwork[b.ridx(i)] = b.data(i);
+
+		  for (octave_idx_type k = 0; k < nc; k++)
 		    {
-		      if (work[k] != 0.)
+		      if (cwork[k] != 0.)
 			{
 			  if (ridx(cidx(k)) != k)
 			    {
 			      err = -2;
 			      goto triangular_error;
 			    }			    
 
-			  Complex tmp = work[k] / data(cidx(k));
-			  work[k] = tmp;
+			  Complex tmp = cwork[k] / data(cidx(k));
+			  cwork[k] = tmp;
 			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
 			    {
 			      octave_idx_type iidx = ridx(i);
-			      work[iidx] = work[iidx] - tmp * data(i);
+			      cwork[iidx] = cwork[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 
 		  // Count non-zeros in work vector and adjust space in
 		  // retval if needed
 		  octave_idx_type new_nnz = 0;
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    if (work[i] != 0.)
+		  for (octave_idx_type i = 0; i < nc; i++)
+		    if (cwork[i] != 0.)
 		      new_nnz++;
 
 		  if (ii + new_nnz > x_nz)
 		    {
 		      // Resize the sparse matrix
 		      octave_idx_type sz = new_nnz * (b_nc - j) + x_nz;
 		      retval.change_capacity (sz);
 		      x_nz = sz;
 		    }
 
-		  for (octave_idx_type i = 0; i < nr; i++)
-		    if (work[i] != 0.)
+		  for (octave_idx_type i = 0; i < nc; i++)
+		    if (cwork[i] != 0.)
 		      {
 			retval.xridx(ii) = i;
-			retval.xdata(ii++) = work[i];
+			retval.xdata(ii++) = cwork[i];
 		      }
 		  retval.xcidx(j+1) = ii;
 		}
 
 	      retval.maybe_compress ();
 
 	      // Calculation of 1-norm of inv(*this)
-	      OCTAVE_LOCAL_BUFFER (double, work2, nr);
-	      for (octave_idx_type i = 0; i < nr; i++)
-		work2[i] = 0.;
+	      OCTAVE_LOCAL_BUFFER (double, work, nm);
+	      for (octave_idx_type i = 0; i < nm; i++)
+		work[i] = 0.;
 
 	      for (octave_idx_type j = 0; j < nr; j++)
 		{
-		  work2[j] = 1.;
-
-		  for (octave_idx_type k = j; k < nr; k++)
+		  work[j] = 1.;
+
+		  for (octave_idx_type k = j; k < nc; k++)
 		    {
 
-		      if (work2[k] != 0.)
+		      if (work[k] != 0.)
 			{
-			  double tmp = work2[k] / data(cidx(k));
-			  work2[k] = tmp;
+			  double tmp = work[k] / data(cidx(k));
+			  work[k] = tmp;
 			  for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
 			    {
 			      octave_idx_type iidx = ridx(i);
-			      work2[iidx] = work2[iidx] - tmp * data(i);
+			      work[iidx] = work[iidx] - tmp * data(i);
 			    }
 			}
 		    }
 		  double atmp = 0;
-		  for (octave_idx_type i = j; i < nr; i++)
+		  for (octave_idx_type i = j; i < nc; i++)
 		    {
-		      atmp += fabs(work2[i]);
-		      work2[i] = 0.;
+		      atmp += fabs(work[i]);
+		      work[i] = 0.;
 		    }
 		  if (atmp > ainvnorm)
 		    ainvnorm = atmp;
 		}
 
 	    }
 
 	  rcond = 1. / ainvnorm / anorm;
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,21 @@
+2006-02-20  David Bateman  <dbateman@free.fr>
+
+	* pt-mat.cc (class tm_row_const): Add any_sparse bool variable.
+	(tm_row_const::tm_row_const_rep::do_init_element): Initialize
+	any_sparse variable if any matrice is sparse.
+	(class tm_const): Add any_sparse bool variable.
+	(tm_const::init): Initialize any_sparse variable.
+	(tree_matrix::rvalue): If any matrix is sparse use sparse matrix
+	as initial matrix for concatenation
+	* DLD-FUNCTIONS/matrix_type.cc: Add tests for new rectangular
+	diagonal, permuted diagonal, triangular and permuted triangular
+	matrices
+
 2006-02-20  John W. Eaton  <jwe@octave.org>
 
 	* toplev.cc (__builtin_delete, __builtin_new): Use std::cerr for
 	messages instead of std::cout.
 	(main_loop, do_octave_atexit): Use octave_stdout, not std::cout.
 
 2006-02-15  John W. Eaton  <jwe@octave.org>
 
diff --git a/src/DLD-FUNCTIONS/matrix_type.cc b/src/DLD-FUNCTIONS/matrix_type.cc
--- a/src/DLD-FUNCTIONS/matrix_type.cc
+++ b/src/DLD-FUNCTIONS/matrix_type.cc
@@ -311,17 +311,29 @@ matrix type.\n\
 %! a = spdiags(randn(10,4),[-2:1],10,10);
 %! assert(matrix_type(a),"Banded");
 %! assert(matrix_type(a'*a),"Banded Positive Definite");
 %! spparms("bandden",bnd);
 %!test
 %! a=[speye(10,10),[sparse(9,1);1];-1,sparse(1,9),1];
 %! assert(matrix_type(a),"Full");
 %! assert(matrix_type(a'*a),"Positive Definite");
-%!assert(matrix_type(speye(10,11)),"Rectangular");
+%!assert(matrix_type(speye(10,11)),"Diagonal");
+%!assert(matrix_type(speye(10,11)([2:10,1],:)),"Permuted Diagonal");
+%!assert(matrix_type(speye(11,10)),"Diagonal");
+%!assert(matrix_type(speye(11,10)([2:11,1],:)),"Permuted Diagonal");
+%!assert(matrix_type([[speye(10,10);sparse(1,10)],[[1,1];sparse(9,2);[1,1]]]),"Upper");
+%!assert(matrix_type([[speye(10,10);sparse(1,10)],[[1,1];sparse(9,2);[1,1]]](:,[2,1,3:12])),"Permuted Upper");
+%!assert(matrix_type([speye(11,9),[1;sparse(8,1);1;0]]),"Upper");
+%!assert(matrix_type([speye(11,9),[1;sparse(8,1);1;0]](:,[2,1,3:10])),"Permuted Upper");
+%!assert(matrix_type([speye(10,10),sparse(10,1);[1;1],sparse(2,9),[1;1]]),"Lower");
+%!assert(matrix_type([speye(10,10),sparse(10,1);[1;1],sparse(2,9),[1;1]]([2,1,3:12],:)),"Permuted Lower");
+%!assert(matrix_type([speye(9,11);[1,sparse(1,8),1,0]]),"Lower");
+%!assert(matrix_type([speye(9,11);[1,sparse(1,8),1,0]]([2,1,3:10],:)),"Permuted Lower");
+%!assert(matrix_type(spdiags(randn(10,4),[-2:1],10,9)),"Rectangular")
 
 %!assert(matrix_type(1i*speye(10,10)),"Diagonal");
 %!assert(matrix_type(1i*speye(10,10)([2:10,1],:)),"Permuted Diagonal");
 %!assert(matrix_type([[speye(10,10);sparse(1,10)],[1i;sparse(9,1);1]]),"Upper");
 %!assert(matrix_type([[speye(10,10);sparse(1,10)],[1i;sparse(9,1);1]](:,[2,1,3:11])),"Permuted Upper");
 %!assert(matrix_type([speye(10,10),sparse(10,1);1i,sparse(1,9),1]),"Lower");
 %!assert(matrix_type([speye(10,10),sparse(10,1);1i,sparse(1,9),1]([2,1,3:11],:)),"Permuted Lower");
 %!test
@@ -337,17 +349,29 @@ matrix type.\n\
 %! assert(matrix_type(spdiags(1i*randn(10,4),[-2:1],10,10)),"Banded");
 %! a = 1i*randn(9,2);a=[[a;[0,0]],ones(10,1),[[0;-a(:,2)],[0;0;-a(1:8,1)]]];
 %! assert(matrix_type(spdiags(a,[-2:2],10,10)),"Banded Positive Definite");
 %! spparms("bandden",bnd);
 %!test
 %! a=[speye(10,10),[sparse(9,1);1i];-1,sparse(1,9),1];
 %! assert(matrix_type(a),"Full");
 %! assert(matrix_type(a'*a),"Positive Definite");
-%!assert(matrix_type(speye(10,11)),"Rectangular");
+%!assert(matrix_type(1i*speye(10,11)),"Diagonal");
+%!assert(matrix_type(1i*speye(10,11)([2:10,1],:)),"Permuted Diagonal");
+%!assert(matrix_type(1i*speye(11,10)),"Diagonal");
+%!assert(matrix_type(1i*speye(11,10)([2:11,1],:)),"Permuted Diagonal");
+%!assert(matrix_type([[speye(10,10);sparse(1,10)],[[1i,1i];sparse(9,2);[1i,1i]]]),"Upper");
+%!assert(matrix_type([[speye(10,10);sparse(1,10)],[[1i,1i];sparse(9,2);[1i,1i]]](:,[2,1,3:12])),"Permuted Upper");
+%!assert(matrix_type([speye(11,9),[1i;sparse(8,1);1i;0]]),"Upper");
+%!assert(matrix_type([speye(11,9),[1i;sparse(8,1);1i;0]](:,[2,1,3:10])),"Permuted Upper");
+%!assert(matrix_type([speye(10,10),sparse(10,1);[1i;1i],sparse(2,9),[1i;1i]]),"Lower");
+%!assert(matrix_type([speye(10,10),sparse(10,1);[1i;1i],sparse(2,9),[1i;1i]]([2,1,3:12],:)),"Permuted Lower");
+%!assert(matrix_type([speye(9,11);[1i,sparse(1,8),1i,0]]),"Lower");
+%!assert(matrix_type([speye(9,11);[1i,sparse(1,8),1i,0]]([2,1,3:10],:)),"Permuted Lower");
+%!assert(matrix_type(1i*spdiags(randn(10,4),[-2:1],10,9)),"Rectangular")
 
 %!test
 %! a = matrix_type(spdiags(randn(10,3),[-1,0,1],10,10),"Singular");
 %! assert(matrix_type(a),"Singular");
 
 */
 
 /*
diff --git a/src/pt-mat.cc b/src/pt-mat.cc
--- a/src/pt-mat.cc
+++ b/src/pt-mat.cc
@@ -36,16 +36,19 @@ 02110-1301, USA.
 #include "pt-bp.h"
 #include "pt-exp.h"
 #include "pt-mat.h"
 #include "pt-walk.h"
 #include "utils.h"
 #include "ov.h"
 #include "variables.h"
 
+#include "ov-re-sparse.h"
+#include "ov-cx-sparse.h"
+
 // If TRUE, print a warning message for empty elements in a matrix list.
 static bool Vwarn_empty_list_elements;
 
 // The character to fill with when creating string arrays.
 char Vstring_fill_char = ' ';
 
 // Warn if concatenating double and single quoted strings.
 char Vwarn_string_concat = false;
@@ -65,40 +68,41 @@ private:
   tm_row_const_rep : public octave_base_list<octave_value>
   {
   public:
 
     tm_row_const_rep (void)
       : count (1), dv (0, 0), all_str (false),
 	all_sq_str (false), all_dq_str (false),
 	some_str (false), all_real (false), all_cmplx (false),
-	all_mt (true), class_nm (octave_base_value::static_class_name ()),
-	ok (false)
+	all_mt (true), any_sparse (false),
+	class_nm (octave_base_value::static_class_name ()), ok (false)
     { }
 
     tm_row_const_rep (const tree_argument_list& row)
       : count (1), dv (0, 0), all_str (false), all_sq_str (false),
 	some_str (false), all_real (false), all_cmplx (false),
-	all_mt (true), class_nm (octave_base_value::static_class_name ()),
-	ok (false)
+	all_mt (true), any_sparse (false),
+	class_nm (octave_base_value::static_class_name ()), ok (false)
     { init (row); }
 
     ~tm_row_const_rep (void) { }
 
     int count;
 
     dim_vector dv;
 
     bool all_str;
     bool all_sq_str;
     bool all_dq_str;
     bool some_str;
     bool all_real;
     bool all_cmplx;
     bool all_mt;
+    bool any_sparse;
 
     std::string class_nm;
 
     bool ok;
 
     bool do_init_element (tree_expression *, const octave_value&, bool&);
 
     void init (const tree_argument_list&);
@@ -162,16 +166,17 @@ public:
 
   bool all_strings_p (void) const { return rep->all_str; }
   bool all_sq_strings_p (void) const { return rep->all_sq_str; }
   bool all_dq_strings_p (void) const { return rep->all_dq_str; }
   bool some_strings_p (void) const { return rep->some_str; }
   bool all_real_p (void) const { return rep->all_real; }
   bool all_complex_p (void) const { return rep->all_cmplx; }
   bool all_empty_p (void) const { return rep->all_mt; }
+  bool any_sparse_p (void) const { return rep->any_sparse; }
 
   std::string class_name (void) const { return rep->class_nm; }
 
   operator bool () const { return (rep && rep->ok); }
 
   iterator begin (void) { return rep->begin (); }
   const_iterator begin (void) const { return rep->begin (); }
 
@@ -336,27 +341,31 @@ tm_row_const::tm_row_const_rep::do_init_
     some_str = true;
 
   if (all_real && ! val.is_real_type ())
     all_real = false;
 
   if (all_cmplx && ! (val.is_complex_type () || val.is_real_type ()))
     all_cmplx = false;
 
+  if (!any_sparse && val.class_name() == "sparse")
+    any_sparse = true;
+
   return true;
 }
 
 void
 tm_row_const::tm_row_const_rep::init (const tree_argument_list& row)
 {
   all_str = true;
   all_sq_str = true;
   all_dq_str = true;
   all_real = true;
   all_cmplx = true;
+  any_sparse = false;
 
   bool first_elem = true;
 
   for (tree_argument_list::const_iterator p = row.begin ();
        p != row.end ();
        p++)
     {
       OCTAVE_QUIT;
@@ -427,50 +436,52 @@ tm_row_const::tm_row_const_rep::eval_war
 class
 tm_const : public octave_base_list<tm_row_const>
 {
 public:
 
   tm_const (const tree_matrix& tm)
     : dv (0, 0), all_str (false), all_sq_str (false), all_dq_str (false),
       some_str (false), all_real (false), all_cmplx (false),
-      all_mt (true), class_nm (octave_base_value::static_class_name ()),
-      ok (false)
+      all_mt (true), any_sparse (false),
+      class_nm (octave_base_value::static_class_name ()), ok (false)
   { init (tm); }
 
   ~tm_const (void) { }
 
   octave_idx_type rows (void) const { return dv.elem (0); }
   octave_idx_type cols (void) const { return dv.elem (1); }
 
   dim_vector dims (void) const { return dv; }
 
   bool all_strings_p (void) const { return all_str; }
   bool all_sq_strings_p (void) const { return all_sq_str; }
   bool all_dq_strings_p (void) const { return all_dq_str; }
   bool some_strings_p (void) const { return some_str; }
   bool all_real_p (void) const { return all_real; }
   bool all_complex_p (void) const { return all_cmplx; }
   bool all_empty_p (void) const { return all_mt; }
+  bool any_sparse_p (void) const { return any_sparse; }
 
   std::string class_name (void) const { return class_nm; }
 
   operator bool () const { return ok; }
 
 private:
 
   dim_vector dv;
 
   bool all_str;
   bool all_sq_str;
   bool all_dq_str;
   bool some_str;
   bool all_real;
   bool all_cmplx;
   bool all_mt;
+  bool any_sparse;
 
   std::string class_nm;
 
   bool ok;
 
   tm_const (void);
 
   tm_const (const tm_const&);
@@ -483,16 +494,17 @@ private:
 void
 tm_const::init (const tree_matrix& tm)
 {
   all_str = true;
   all_sq_str = true;
   all_dq_str = true;
   all_real = true;
   all_cmplx = true;
+  any_sparse = false;
 
   bool first_elem = true;
 
   // Just eval and figure out if what we have is complex or all
   // strings.  We can't check columns until we know that this is a
   // numeric matrix -- collections of strings can have elements of
   // different lengths.
 
@@ -522,16 +534,19 @@ tm_const::init (const tree_matrix& tm)
 	    all_real = false;
 
 	  if (all_cmplx && ! tmp.all_complex_p ())
 	    all_cmplx = false;
 
 	  if (all_mt && ! tmp.all_empty_p ())
 	    all_mt = false;
 
+	  if (!any_sparse && tmp.any_sparse_p ())
+	    any_sparse = true;
+
 	  append (tmp);
 	}
       else
 	break;
     }
 
   if (! error_state)
     {
@@ -749,29 +764,31 @@ tree_matrix::rvalue (void)
   octave_value retval;
 
   bool all_strings_p = false;
   bool all_sq_strings_p = false;
   bool all_dq_strings_p = false;
   bool all_empty_p = false;
   bool all_real_p = false;
   bool all_complex_p = false;
+  bool any_sparse_p = false;
   bool frc_str_conv = false;
 
   tm_const tmp (*this);
 
   if (tmp)
     {
       dim_vector dv = tmp.dims ();
       all_strings_p = tmp.all_strings_p ();
       all_sq_strings_p = tmp.all_sq_strings_p ();
       all_dq_strings_p = tmp.all_dq_strings_p ();
       all_empty_p = tmp.all_empty_p ();
       all_real_p = tmp.all_real_p ();
       all_complex_p = tmp.all_complex_p ();
+      any_sparse_p = tmp.any_sparse_p ();
       frc_str_conv = tmp.some_strings_p ();
 
       // Try to speed up the common cases.
 
       std::string result_type = tmp.class_name ();
 
       if (result_type == "double")
 	{
@@ -831,40 +848,52 @@ tree_matrix::rvalue (void)
 	  // and then directly resize. However, for some types there
 	  // might be some additional setup needed, and so this should
 	  // be avoided.
 
 	  octave_value ctmp;
 
 	  // Find the first non-empty object
 
-	  for (tm_const::iterator p = tmp.begin (); p != tmp.end (); p++)
+	  if (any_sparse_p)
 	    {
-	      OCTAVE_QUIT;
-
-	      tm_row_const row = *p;
-
-	      for (tm_row_const::iterator q = row.begin (); 
-		   q != row.end (); q++)
+	      // Start with sparse matrix to avoid issues memory issues
+	      // with things like [ones(1,4),sprandn(1e8,4,1e-4)]
+	      if (all_real_p)
+		ctmp = octave_sparse_matrix ().resize (dv); 
+	      else
+		ctmp = octave_sparse_complex_matrix ().resize (dv); 
+	    }
+	  else
+	    {
+	      for (tm_const::iterator p = tmp.begin (); p != tmp.end (); p++)
 		{
 		  OCTAVE_QUIT;
 
-		  ctmp = *q;
+		  tm_row_const row = *p;
 
-		  if (! ctmp.all_zero_dims ())
-		    goto found_non_empty;
-		}
-	    }
+		  for (tm_row_const::iterator q = row.begin (); 
+		       q != row.end (); q++)
+		    {
+		      OCTAVE_QUIT;
+
+		      ctmp = *q;
 
-	  ctmp = (*(tmp.begin() -> begin()));
+		      if (! ctmp.all_zero_dims ())
+			goto found_non_empty;
+		    }
+		}
 
-	found_non_empty:
+	      ctmp = (*(tmp.begin() -> begin()));
+
+	    found_non_empty:
 
-	  if (! all_empty_p)
-	    ctmp = ctmp.resize (dim_vector (0,0)).resize (dv);
+	      if (! all_empty_p)
+		ctmp = ctmp.resize (dim_vector (0,0)).resize (dv);
+	    }
 
 	  if (! error_state)
 	    {
 	      // Now, extract the values from the individual elements and
 	      // insert them in the result matrix.
 
 	      int dv_len = dv.length ();
 	      Array<int> ra_idx (dv_len > 1 ? dv_len : 2, 0);
diff --git a/test/ChangeLog b/test/ChangeLog
--- a/test/ChangeLog
+++ b/test/ChangeLog
@@ -1,11 +1,17 @@
+2006-02-20  David Bateman  <dbateman@free.fr>
+
+	* build_spase_tests.sh: Add tests for ldiv tests for rectangular
+	diagonal, permuted diagonal, triangular and permuted triangular
+	matrices.
+
 2006-02-09  David Bateman  <dbateman@free.fr>
 
-        * test/build_sparse_tests.sh: Add tests for sparse QR solvers.
+        * build_sparse_tests.sh: Add tests for sparse QR solvers.
 
 2006-01-21  David Bateman  <dbateman@free.fr>
 
         * build_sparsetest.sh: Add new un-ordered indexing, assignment and
         deletion tests.
 
 2006-01-13  Bill Denney  <bill@givebillmoney.com>
 
diff --git a/test/build_sparse_tests.sh b/test/build_sparse_tests.sh
--- a/test/build_sparse_tests.sh
+++ b/test/build_sparse_tests.sh
@@ -853,20 +853,16 @@ gen_save_tests() {
 %! unlink(savefile);
 %! assert(as_save,sparse(af));
 EOF
 }
 
 # =============================================================
 # Specific solver tests for matrices that will test all of the solver
 # code. Uses alpha and beta
-#
-# Note these tests can still fail with a singular matrix, as sprandn
-# is used and QR solvers not implemented. However, that should happen
-# rarely
 gen_solver_tests() {
 
 if $preset; then
   cat >>$TESTS <<EOF
 %! n=8;
 %! lf=diag(1:n);lf(n-1,1)=0.5*alpha;lf(n,2)=0.25*alpha;ls=sparse(lf);
 %! uf=diag(1:n);uf(1,n-1)=2*alpha;uf(2,n)=alpha;us=sparse(uf);
 %! ts=spdiags(ones(n,3),-1:1,n,n)+diag(1:n); tf = full(ts);
@@ -924,20 +920,100 @@ cat >>$TESTS <<EOF
 %! b = randn(sz)+1i*randn(sz); x = a \ b;  
 %! assert (a * x, b, feps);
 %! b = sprandn(sz(1),sz(2),0.2); x = a \b;
 %! assert (sparse(a * x), b, feps);
 %! b = sprandn(sz(1),sz(2),0.2)+1i*sprandn(sz(1),sz(2),0.2); x = a \b; 
 %! assert (sparse(a * x), b, feps);
 %!test
 %! a = alpha*sprandn(10,11,0.2)+speye(10,11); f(a,[10,2],1e-10);
-%! ## Test this by forcing matrix_type
+%! ## Test this by forcing matrix_type, as can't get a certain 
+%! ## result for over-determined systems.
 %! a = alpha*sprandn(10,10,0.2)+speye(10,10); matrix_type(a, "Singular");
 %! f(a,[10,2],1e-10);
 
+%% Rectanguar solver tests that don't use QR
+
+%!test
+%! ds = alpha * spdiags([1:11]',0,10,11);
+%! df = full(ds);
+%! xf = beta * ones(10,1);
+%! xs = speye(10,10);
+%!assert(ds\xf,df\xf,100*eps)
+%!assert(ds\xs,sparse(df\xs,true),100*eps)
+%!test
+%! pds = ds([2,1,3:10],:);
+%! pdf = full(pds);
+%!assert(pds\xf,pdf\xf,100*eps)
+%!assert(pds\xs,sparse(pdf\xs,true),100*eps)
+%!test
+%! ds = alpha * spdiags([1:11]',0,11,10);
+%! df = full(ds);
+%! xf = beta * ones(11,1);
+%! xs = speye(11,11);
+%!assert(ds\xf,df\xf,100*eps)
+%!assert(ds\xs,sparse(df\xs,true),100*eps)
+%!test
+%! pds = ds([2,1,3:11],:);
+%! pdf = full(pds);
+%!assert(pds\xf,pdf\xf,100*eps)
+%!assert(pds\xs,sparse(pdf\xs,true),100*eps)
+%!test
+%! us = alpha*[[speye(10,10);sparse(1,10)],[[1,1];sparse(9,2);[1,1]]];
+%!assert(us*(us\xf),xf,100*eps)
+%!assert(us*(us\xs),xs,100*eps)
+%!test
+%! pus = us(:,[2,1,3:12]);
+%!assert(pus*(pus\xf),xf,100*eps)
+%!assert(pus*(pus\xs),xs,100*eps)
+%!test
+%! us = alpha*[speye(11,9),[1;sparse(8,1);1;0]];
+%!test
+%! [c,r] = spqr (us, xf);
+%! assert(us\xf,r\c,100*eps)
+%!test
+%! [c,r] = spqr (us, xs);
+%! assert(us\xs,r\c,100*eps)
+%!test
+%! pus = us(:,[1:8,10,9]);
+%!test
+%! [c,r] = spqr (pus, xf);
+%! assert(pus\xf,r\c,100*eps)
+%!test
+%! [c,r] = spqr (pus, xs);
+%! assert(pus\xs,r\c,100*eps)
+%!test
+%! ls = alpha*[speye(9,11);[1,sparse(1,8),1,0]];
+%! xf = beta * ones(10,1);
+%! xs = speye(10,10);
+%!assert(ls*(ls\xf),xf,100*eps)
+%!assert(ls*(ls\xs),xs,100*eps)
+%!test
+%! pls = ls([1:8,10,9],:);
+%!assert(pls*(pls\xf),xf,100*eps)
+%!assert(pls*(pls\xs),xs,100*eps)
+%!test
+%! ls = alpha*[speye(10,10),sparse(10,1);[1;1],sparse(2,9),[1;1]];
+%! xf = beta * ones(12,1);
+%! xs = speye(12,12);
+%!test
+%! [c,r] = spqr (ls, xf);
+%! assert(ls\xf,r\c,100*eps)
+%!test
+%! [c,r] = spqr (ls, xs);
+%! assert(ls\xs,r\c,100*eps)
+%!test
+%! pls = ls(:,[1:8,10,9]);
+%!test
+%! [c,r] = spqr (pls, xf);
+%! assert(pls\xf,r\c,100*eps)
+%!test
+%! [c,r] = spqr (pls, xs);
+%! assert(pls\xs,r\c,100*eps)
+
 EOF
 }
 
 
 # =============================================================
 # Putting it all together: defining the combined tests
 
 
