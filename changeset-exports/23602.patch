# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1497455614 14400
#      Wed Jun 14 11:53:34 2017 -0400
# Node ID 214cb58ccc1cef53c0e896edda5a9a178d4b9157
# Parent  a3898679d4598820532fdf3eead5242f2a9b47fc
use pointer to scope instead of scope id

Eliminate symbol table scope ID and the global list of all scopes
indexed by numeric ID.  Function scope data is now only accessible
from the function itself, or by asking a scope for its parent scope
(if it exists).

The top-level and global scopes are now regular data members of the
symbol table class instead of being static.

Symbol table scopes are now created in the lexer when parsing a
function begins and stored in the function object when finishing the
construction of function object.  If an error occurs while parsing a
function, the list of any pending scopes is deleted.

diff --git a/libinterp/corefcn/call-stack.cc b/libinterp/corefcn/call-stack.cc
--- a/libinterp/corefcn/call-stack.cc
+++ b/libinterp/corefcn/call-stack.cc
@@ -82,17 +82,19 @@ namespace octave
       return false;
     else
       return true;
   }
 
   call_stack::call_stack (interpreter& interp)
     : cs (), curr_frame (0), m_interpreter (interp)
   {
-    push (0, symbol_table::top_scope (), 0);
+    symbol_table& symtab = m_interpreter.get_symbol_table ();
+
+    push (0, symtab.top_scope (), 0);
   }
 
   int
   call_stack::current_line (void) const
   {
     int retval = -1;
 
     if (! cs.empty ())
diff --git a/libinterp/corefcn/call-stack.h b/libinterp/corefcn/call-stack.h
--- a/libinterp/corefcn/call-stack.h
+++ b/libinterp/corefcn/call-stack.h
@@ -47,17 +47,17 @@ namespace octave
 
     class stack_frame
     {
     public:
 
       friend class call_stack;
 
       stack_frame (octave_function *fcn = nullptr,
-                   symbol_table::scope_id scope = 0,
+                   symbol_table::scope *scope = 0,
                    symbol_table::context_id context = 0, size_t prev = 0)
         : m_fcn (fcn), m_line (-1), m_column (-1), m_scope (scope),
           m_context (context), m_prev (prev)
       { }
 
       stack_frame (const stack_frame& elt)
         : m_fcn (elt.m_fcn), m_line (elt.m_line), m_column (elt.m_column),
           m_scope (elt.m_scope), m_context (elt.m_context), m_prev (elt.m_prev)
@@ -73,17 +73,17 @@ namespace octave
 
       bool operator == (const stack_frame& rhs) const;
 
     private:
 
       octave_function *m_fcn;
       int m_line;
       int m_column;
-      symbol_table::scope_id m_scope;
+      symbol_table::scope *m_scope;
       symbol_table::context_id m_context;
       size_t m_prev;
     };
 
     typedef std::deque<stack_frame>::iterator iterator;
     typedef std::deque<stack_frame>::const_iterator const_iterator;
 
     typedef std::deque<stack_frame>::reverse_iterator reverse_iterator;
@@ -119,17 +119,17 @@ namespace octave
     }
 
     size_t current_frame (void) const { return curr_frame; }
 
     size_t size (void) const { return cs.size (); }
 
     size_t num_user_code_frames (octave_idx_type& curr_user_frame) const;
 
-    symbol_table::scope_id current_scope (void) const
+    symbol_table::scope *current_scope (void) const
     {
       return (curr_frame > 0 && curr_frame < cs.size ()
               ? cs[curr_frame].m_scope : 0);
     }
 
     symbol_table::context_id current_context (void) const
     {
       return (curr_frame > 0 && curr_frame < cs.size ()
@@ -174,34 +174,34 @@ namespace octave
 
     void push (octave_function *fcn)
     {
       symbol_table& symtab = m_interpreter.get_symbol_table ();
 
       push (fcn, symtab.current_scope (), symtab.current_context ());
     }
 
-    void push (octave_function *fcn, symbol_table::scope_id scope,
+    void push (octave_function *fcn, symbol_table::scope *scope,
                symbol_table::context_id context)
     {
       size_t prev_frame = curr_frame;
       curr_frame = cs.size ();
       cs.push_back (stack_frame (fcn, scope, context, prev_frame));
 
       symbol_table& symtab = m_interpreter.get_symbol_table ();
 
       symtab.set_scope_and_context (scope, context);
     }
 
     void push (void)
     {
       push (nullptr);
     }
 
-    void push (symbol_table::scope_id scope, symbol_table::context_id context)
+    void push (symbol_table::scope *scope, symbol_table::context_id context)
     {
       push (nullptr, scope, context);
     }
 
     void set_location (int l, int c)
     {
       if (! cs.empty ())
         {
diff --git a/libinterp/corefcn/interpreter-private.cc b/libinterp/corefcn/interpreter-private.cc
--- a/libinterp/corefcn/interpreter-private.cc
+++ b/libinterp/corefcn/interpreter-private.cc
@@ -57,17 +57,17 @@ namespace octave
 
   symbol_table& __get_symbol_table__ (const std::string& who)
   {
     interpreter& interp = __get_interpreter__ (who);
 
     return interp.get_symbol_table ();
   }
 
-  symbol_table::scope_id __get_current_scope__ (const std::string& who)
+  symbol_table::scope *__get_current_scope__ (const std::string& who)
   {
     symbol_table& symtab = __get_symbol_table__ (who);
 
     return symtab.current_scope ();
   }
 
   tree_evaluator& __get_evaluator__ (const std::string& who)
   {
diff --git a/libinterp/corefcn/interpreter-private.h b/libinterp/corefcn/interpreter-private.h
--- a/libinterp/corefcn/interpreter-private.h
+++ b/libinterp/corefcn/interpreter-private.h
@@ -37,16 +37,16 @@ namespace octave
   class tree_evaluator;
 
   extern interpreter& __get_interpreter__ (const std::string& who);
 
   extern load_path& __get_load_path__ (const std::string& who);
 
   extern symbol_table& __get_symbol_table__ (const std::string& who);
 
-  extern symbol_table::scope_id __get_current_scope__ (const std::string& who);
+  extern symbol_table::scope *__get_current_scope__ (const std::string& who);
 
   extern tree_evaluator& __get_evaluator__ (const std::string& who);
 
   extern call_stack& __get_call_stack__ (const std::string& who);
 }
 
 #endif
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -951,17 +951,17 @@ do_save (std::ostream& os, const octave_
 }
 
 // Save the info from SR on stream OS in the format specified by FMT.
 
 void
 do_save (std::ostream& os, const symbol_table::symbol_record& sr,
          load_save_format fmt, bool save_as_floats)
 {
-  octave_value val = sr.varval ();
+  octave_value val = sr.varval (0);
 
   if (val.is_defined ())
     {
       std::string name = sr.name ();
       std::string help;
       bool global = sr.is_global ();
 
       do_save (os, val, name, help, global, fmt, save_as_floats);
@@ -1317,23 +1317,23 @@ static void
 dump_octave_core (std::ostream& os, const char *fname, load_save_format fmt,
                   bool save_as_floats)
 {
   write_header (os, fmt);
 
   symbol_table& symtab = octave::__get_symbol_table__ ("dump_octave_core");
 
   std::list<symbol_table::symbol_record> vars
-    = symtab.all_variables (symbol_table::top_scope (), 0);
+    = symtab.all_variables (symtab.top_scope (), 0);
 
   double save_mem_size = 0;
 
   for (const auto& var : vars)
     {
-      octave_value val = var.varval ();
+      octave_value val = var.varval (0);
 
       if (val.is_defined ())
         {
           std::string name = var.name ();
           std::string help;
           bool global = var.is_global ();
 
           double val_size = val.byte_size () / 1024;
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -978,37 +978,36 @@ read_mat5_binary_element (std::istream& 
             octave::unwind_protect_safe frame;
 
             // Set up temporary scope to use for evaluating the text
             // that defines the anonymous function.
 
             symbol_table& symtab
               = octave::__get_symbol_table__ ("read_mat5_binary_element");
 
-            symbol_table::scope_id local_scope = symtab.alloc_scope ();
-            frame.add_method (symtab, &symbol_table::erase_scope, local_scope);
-
-            symtab.set_scope (local_scope);
+            symbol_table::scope local_scope;
+
+            symtab.set_scope (&local_scope);
 
             octave::call_stack& cs
               = octave::__get_call_stack__ ("read_mat5_binary_element");
-            cs.push (local_scope, 0);
+            cs.push (&local_scope, 0);
             frame.add_method (cs, &octave::call_stack::pop);
 
             if (m2.nfields () > 0)
               {
                 octave_value tmp;
 
                 for (octave_map::iterator p0 = m2.begin () ;
                      p0 != m2.end (); p0++)
                   {
                     std::string key = m2.key (p0);
                     octave_value val = m2.contents (p0);
 
-                    symtab.assign (key, val, local_scope, 0);
+                    local_scope.assign (key, val, 0);
                   }
               }
 
             int parse_status;
             octave_value anon_fcn_handle =
               octave::eval_string (fname.substr (4), true, parse_status);
 
             if (parse_status != 0)
diff --git a/libinterp/corefcn/oct-lvalue.cc b/libinterp/corefcn/oct-lvalue.cc
--- a/libinterp/corefcn/oct-lvalue.cc
+++ b/libinterp/corefcn/oct-lvalue.cc
@@ -29,20 +29,22 @@ along with Octave; see the file COPYING.
 #include "oct-lvalue.h"
 #include "ov.h"
 
 void
 octave_lvalue::assign (octave_value::assign_op op, const octave_value& rhs)
 {
   if (! is_black_hole ())
     {
+      symbol_table::context_id context = sym.context ();
+
       if (idx.empty ())
-        sym->assign (op, rhs);
+        sym->assign (op, rhs, context);
       else
-        sym->assign (op, type, idx, rhs);
+        sym->assign (op, type, idx, rhs, context);
     }
 }
 
 void
 octave_lvalue::set_index (const std::string& t,
                           const std::list<octave_value_list>& i)
 {
   if (! idx.empty ())
@@ -67,31 +69,35 @@ octave_lvalue::index_is_empty (void) con
   return retval;
 }
 
 void
 octave_lvalue::do_unary_op (octave_value::unary_op op)
 {
   if (! is_black_hole ())
     {
+      symbol_table::context_id context = sym.context ();
+
       if (idx.empty ())
-        sym->do_non_const_unary_op (op);
+        sym->do_non_const_unary_op (op, context);
       else
-        sym->do_non_const_unary_op (op, type, idx);
+        sym->do_non_const_unary_op (op, type, idx, context);
     }
 }
 
 octave_value
 octave_lvalue::value (void) const
 {
   octave_value retval;
 
   if (! is_black_hole ())
     {
-      octave_value val = sym->varval ();
+      symbol_table::context_id context = sym.context ();
+
+      octave_value val = sym->varval (context);
 
       if (idx.empty ())
         retval = val;
       else
         {
           if (val.is_constant ())
             retval = val.subsref (type, idx);
           else
diff --git a/libinterp/corefcn/oct-lvalue.h b/libinterp/corefcn/oct-lvalue.h
--- a/libinterp/corefcn/oct-lvalue.h
+++ b/libinterp/corefcn/oct-lvalue.h
@@ -61,30 +61,38 @@ public:
   }
 
   ~octave_lvalue (void) = default;
 
   bool is_black_hole (void) const { return sym.is_black_hole (); }
 
   bool is_defined (void) const
   {
-    return ! is_black_hole () && sym->is_defined ();
+    symbol_table::context_id context = sym.context ();
+    return ! is_black_hole () && sym->is_defined (context);
   }
 
   bool is_undefined (void) const
   {
-    return is_black_hole () || sym->is_undefined ();
+    symbol_table::context_id context = sym.context ();
+    return is_black_hole () || sym->is_undefined (context);
   }
 
   bool isstruct (void) const
   {
     return value().isstruct ();
   }
 
-  void define (const octave_value& v) { sym->assign (v); }
+  void define (const octave_value& v)
+  {
+    symbol_table::scope *scope = sym.scope ();
+    symbol_table::context_id context = sym.context ();
+
+    sym->assign (v, context);
+  }
 
   void assign (octave_value::assign_op, const octave_value&);
 
   void numel (octave_idx_type n) { nel = n; }
 
   octave_idx_type numel (void) const { return nel; }
 
   void set_index (const std::string& t, const std::list<octave_value_list>& i);
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -47,56 +47,54 @@ along with Octave; see the file COPYING.
 #include "parse.h"
 #include "pt-pr-code.h"
 #include "symtab.h"
 #include "unwind-prot.h"
 #include "utils.h"
 
 octave_value symbol_table::dummy_octave_value;
 
-symbol_table::context_id symbol_table::xcurrent_context = 0;
-
 // Should Octave always check to see if function files have changed
 // since they were last compiled?
 static int Vignore_function_time_stamp = 1;
 
 void
-symbol_table::symbol_record::symbol_record_rep::clear (scope_id sid)
+symbol_table::symbol_record::symbol_record_rep::clear (const scope *sid)
 {
   if (! (is_hidden () || is_inherited ())
       && sid == decl_scope ())
     {
       if (is_global ())
         unmark_global ();
 
+      symbol_table& symtab
+        = octave::__get_symbol_table__ ("symbol_table::symbol_record::symbol_record_rep::clear");
+
       if (is_persistent ())
         {
-          symbol_table& symtab
-            = octave::__get_symbol_table__ ("symbol_table::symbol_record::symbol_record_rep::clear");
-
-          symtab.persistent_assign (name, varval ());
+          symtab.persistent_assign (name, varval (symtab.current_context ()));
 
           unmark_persistent ();
         }
 
-      assign (octave_value ());
+      assign (octave_value (), symtab.current_context ());
     }
 }
 
 void
 symbol_table::symbol_record::symbol_record_rep::init_persistent (void)
 {
-  if (! is_defined ())
+  symbol_table& symtab
+    = octave::__get_symbol_table__ ("symbol_table::symbol_record::symbol_record_rep::init_persistent");
+
+  if (! is_defined (symtab.current_context ()))
     {
       mark_persistent ();
 
-      symbol_table& symtab
-        = octave::__get_symbol_table__ ("symbol_table::symbol_record::symbol_record_rep::init_persistent");
-
-      assign (symtab.persistent_varval (name));
+      assign (symtab.persistent_varval (name), symtab.current_context ());
     }
   // FIXME: this causes trouble with recursive calls.
   // else
   //   error ("unable to declare existing variable persistent");
 }
 
 void
 symbol_table::symbol_record::symbol_record_rep::erase_persistent (void)
@@ -105,35 +103,35 @@ symbol_table::symbol_record::symbol_reco
 
   symbol_table& symtab
     = octave::__get_symbol_table__ ("symbol_table::symbol_record::symbol_record_rep::erase_persistent");
 
 
   symtab.erase_persistent (name);
 }
 
-symbol_table::context_id
-symbol_table::symbol_record::symbol_record_rep::active_context (void) const
+symbol_table::symbol_record::symbol_record_rep *
+symbol_table::symbol_record::symbol_record_rep::dup (scope *new_scope) const
 {
-  octave_user_function *fcn = curr_fcn;
+  symbol_table& symtab
+    = octave::__get_symbol_table__ ("symbol_table::symbol_record::symbol_record_rep::dup");
 
-  // FIXME: If active_context () == -1, then it does not make much
-  // sense to use this symbol_record.  This means an attempt at accessing
-  // a variable from a function that has not been called yet is
-  // happening.  This should be cleared up when an implementing closures.
-
-  return (fcn && fcn->active_context () != static_cast<context_id> (-1)
-          ? fcn->active_context () : xcurrent_context);
+  return new symbol_record_rep (new_scope, name,
+                                varval (symtab.current_context ()),
+                                storage_class);
 }
 
 void
 symbol_table::symbol_record::symbol_record_rep::dump
   (std::ostream& os, const std::string& prefix) const
 {
-  octave_value val = varval ();
+  symbol_table& symtab
+    = octave::__get_symbol_table__ ("symbol_table::symbol_record::symbol_record_rep::dump");
+
+  octave_value val = varval (symtab.current_context ());
 
   os << prefix << name;
 
   if (val.is_defined ())
     {
       os << " ["
          << (is_local () ? "l" : "")
          << (is_automatic () ? "a" : "")
@@ -163,17 +161,17 @@ symbol_table::symbol_record::symbol_reco
 }
 
 octave_value&
 symbol_table::symbol_record::symbol_record_rep::xpersistent_varref (void)
 {
   symbol_table& symtab
     = octave::__get_symbol_table__ ("symbol_table::symbol_record::symbol_record_rep::xpersistent_varref");
 
-  scope *s = symtab.get_scope (symtab.current_scope ());
+  scope *s = symtab.current_scope ();
 
   return s ? s->persistent_varref (name) : dummy_octave_value;
 }
 
 octave_value
 symbol_table::symbol_record::symbol_record_rep::xglobal_varval (void) const
 {
   symbol_table& symtab
@@ -189,31 +187,32 @@ symbol_table::symbol_record::symbol_reco
     = octave::__get_symbol_table__ ("symbol_table::symbol_record::symbol_record_rep::xpersistent_varval");
 
   return symtab.persistent_varval (name);
 }
 
 symbol_table::symbol_record::symbol_record (void)
   : rep (new symbol_record_rep (octave::__get_current_scope__ ("symbol_record"),
                                 "", octave_value (), local))
+
 { }
 
 octave_value
 symbol_table::symbol_record::find (const octave_value_list& args) const
 {
   octave_value retval;
 
   symbol_table& symtab
     = octave::__get_symbol_table__ ("symbol_table::symbol_record::find");
 
   if (is_global ())
     retval = symtab.global_varval (name ());
   else
     {
-      retval = varval ();
+      retval = varval (symtab.current_context ());
 
       if (retval.is_undefined ())
         {
 #if 0
           // Use cached fcn_info pointer if possible.
           if (rep->finfo)
             retval = rep->finfo->find (args);
           else
@@ -230,38 +229,40 @@ symbol_table::symbol_record::find (const
 #endif
             }
         }
     }
 
   return retval;
 }
 
-symbol_table::symbol_record symbol_table::dummy_symbol_record = symbol_table::symbol_record (symbol_table::xtop_scope);
+symbol_table::symbol_record
+symbol_table::dummy_symbol_record (static_cast<symbol_table::scope*> (nullptr));
 
 symbol_table::symbol_reference::symbol_reference (const symbol_record& record)
-  : m_scope (-1), m_sym (record)
+  : m_scope (0), m_context (0),m_sym (record)
 {
   symbol_table& symtab = octave::__get_symbol_table__ ("symbol_reference");
 
   m_scope = symtab.current_scope ();
 }
 
 void
 symbol_table::symbol_reference::update (void) const
 {
-  symbol_table& symtab = octave::__get_symbol_table__ ("symbol_reference::update");
+  symbol_table::scope *curr_scope
+    = octave::__get_current_scope__ ("symbol_reference::update");
 
-  scope_id curr_scope = symtab.current_scope ();
-
-  if (m_scope != curr_scope || ! m_sym.is_valid ())
+  if (curr_scope && (m_scope != curr_scope || ! m_sym.is_valid ()))
     {
       m_scope = curr_scope;
-      m_sym = symtab.insert (m_sym.name ());
+      m_sym = m_scope->insert (m_sym.name ());  // ???
     }
+
+  m_context = m_scope ? m_scope->current_context () : 0;
 }
 
 static void
 split_name_with_package (const std::string& name, std::string& fname,
                          std::string& pname)
 {
   size_t pos = name.rfind ('.');
 
@@ -1077,24 +1078,22 @@ symbol_table::fcn_info::fcn_info_rep::x_
             }
         }
     }
 
   // Subfunction.  I think it only makes sense to check for
   // subfunctions if we are currently executing a function defined
   // from a .m file.
 
-  symbol_table::scope_id current_scope
+  symbol_table::scope *curr_scope
     = octave::__get_current_scope__ ("symbol_table::fcn_info::fcn_info_rep::x_builtin_find");
 
-  scope *s = symtab.get_scope (current_scope);
-
-  if (s)
+  if (curr_scope)
     {
-      octave_value val = s->find_subfunction (name);
+      octave_value val = curr_scope->find_subfunction (name);
 
       if (val.is_defined ())
         return val;
     }
 
   return octave_value ();
 }
 
@@ -1337,29 +1336,26 @@ symbol_table::fcn_info::fcn_info_rep::du
            << " [" << str_val.first << "]\n";
     }
 }
 
 octave_value
 symbol_table::find (const std::string& name, const octave_value_list& args,
                     bool skip_variables, bool local_funcs)
 {
-  scope *s = get_scope (m_current_scope);
-
-  return (s
-          ? s->find (name, args, skip_variables, local_funcs)
+  return (m_current_scope
+          ? m_current_scope->find (name, args, skip_variables, local_funcs)
           : octave_value ());
 }
 
 octave_value
 symbol_table::builtin_find (const std::string& name)
 {
-  scope *s = get_scope (m_current_scope);
-
-  return s ? s->builtin_find (name) : octave_value ();
+  return (m_current_scope
+          ? m_current_scope->builtin_find (name) : octave_value ());
 }
 
 octave_value
 symbol_table::find_function (const std::string& name,
                              const octave_value_list& args, bool local_funcs)
 {
   octave_value retval;
 
@@ -1380,30 +1376,30 @@ symbol_table::find_function (const std::
     {
       size_t pos = name.find_first_of (Vfilemarker);
 
       if (pos == std::string::npos)
         retval = find (name, args, true, local_funcs);
       else
         {
           std::string fcn_scope = name.substr (0, pos);
-          scope_id stored_scope = m_current_scope;
-          m_current_scope = xtop_scope;
+          scope *stored_scope = m_current_scope;
+          m_current_scope = m_top_scope;
           octave_value parent = find_function (name.substr (0, pos),
                                                octave_value_list (), false);
 
           if (parent.is_defined ())
             {
               octave_function *parent_fcn = parent.function_value ();
 
               if (parent_fcn)
                 {
                   m_current_scope = parent_fcn->scope ();
 
-                  if (m_current_scope > 1)
+                  if (m_current_scope && m_current_scope != m_top_scope)
                     retval = find_function (name.substr (pos + 1), args);
                 }
             }
 
           m_current_scope = stored_scope;
         }
     }
 
@@ -1419,55 +1415,53 @@ symbol_table::find_submethod (const std:
 
   std::string full_name = "@" + dispatch_type +
                           octave::sys::file_ops::dir_sep_str () + name;
   size_t pos = full_name.find_first_of (Vfilemarker);
 
   if (pos != std::string::npos)
     {
       std::string fcn_scope = full_name.substr (0, pos);
-      scope_id stored_scope = m_current_scope;
-      m_current_scope = xtop_scope;
+      scope *stored_scope = m_current_scope;
+      m_current_scope = m_top_scope;
       octave_value parent = find_function (full_name.substr (0, pos),
                                            octave_value_list (), false);
       if (parent.is_defined ())
         {
           octave_function *parent_fcn = parent.function_value ();
 
           if (parent_fcn)
             {
               m_current_scope = parent_fcn->scope ();
 
-              if (m_current_scope > 1)
+              if (m_current_scope && m_current_scope != m_top_scope)
                 fcn = find_function (full_name.substr (pos + 1),
                                      octave_value_list ());
             }
         }
 
       m_current_scope = stored_scope;
     }
 
   return fcn;
 }
 
 void
-symbol_table::dump (std::ostream& os, scope_id sid)
+symbol_table::dump (std::ostream& os, scope *sid)
 {
-  if (sid == xglobal_scope)
+  if (sid == m_global_scope)
     dump_global (os);
   else
     {
-      scope *s = get_scope (sid, false);
-
-      if (s)
+      if (sid)
         {
-          os << "*** dumping symbol table scope " << sid
-             << " (" << s->name () << ")\n\n";
+          os << "*** dumping symbol table scope ("
+             << sid->name () << ")\n\n";
 
-          s->dump (os);
+          sid->dump (os);
         }
     }
 }
 
 void
 symbol_table::dump_global (std::ostream& os)
 {
   if (! m_global_symbols.empty ())
@@ -1505,17 +1499,16 @@ void
 symbol_table::cleanup (void)
 {
   clear_all (true);
 
   m_global_symbols.clear ();
   m_fcn_table.clear ();
   m_class_precedence_table.clear ();
   m_parent_map.clear ();
-  m_all_scopes.clear ();
 }
 
 octave_value
 symbol_table::scope::find (const std::string& name,
                            const octave_value_list& args,
                            bool skip_variables, bool local_funcs)
 {
   octave_value retval;
@@ -1532,17 +1525,17 @@ symbol_table::scope::find (const std::st
       if (p != m_symbols.end ())
         {
           symbol_record sr = p->second;
 
           if (sr.is_global ())
             return symtab.global_varval (name);
           else
             {
-              octave_value val = sr.varval ();
+              octave_value val = sr.varval (m_context);
 
               if (val.is_defined ())
                 return val;
             }
         }
     }
 
   if (local_funcs)
@@ -1660,17 +1653,17 @@ symbol_table::scope::workspace_info (voi
 
   for (const auto& nm_sr : m_symbols)
     {
       std::string nm = nm_sr.first;
       symbol_record sr = nm_sr.second;
 
       if (! sr.is_hidden ())
         {
-          octave_value val = sr.varval ();
+          octave_value val = sr.varval (m_context);
 
           if (val.is_defined ())
             {
               // FIXME: fix size for objects, see kluge in variables.cc
               //dim_vector dv = val.dims ();
               octave_value tmp = val;
               Matrix sz = tmp.size ();
               dim_vector dv = dim_vector::alloc (sz.numel ());
@@ -1755,20 +1748,17 @@ symbol_table::scope::install_subfunction
                                           bool is_nested)
 {
   m_subfunctions[name] = fval;
 
   // This can be simpler once the scope object is stored in the function
   // object...
   octave_user_function *fcn = fval.user_function_value ();
 
-  symbol_table& symtab
-    = octave::__get_symbol_table__ ("symbol_table::scope::install_subfunction");
-
-  scope *fcn_scope = symtab.get_scope (fcn->scope ());
+  scope *fcn_scope = fcn->scope ();
 
   fcn_scope->set_parent (this);
 
   if (is_nested)
     {
       m_children.push_back (fcn_scope);
 
       fcn->mark_as_nested_function ();
@@ -1964,54 +1954,63 @@ Undocumented internal function.
   symbol_table& symtab = interp.get_symbol_table ();
 
   if (nargin == 0)
     {
       symtab.dump_functions (octave_stdout);
 
       symtab.dump_global (octave_stdout);
 
-      std::list<symbol_table::scope_id> lst = symtab.scopes ();
+      // This won't work now...
+#if 0
+      std::list<symbol_table::scope*> lst = symtab.scopes ();
 
-      for (const auto& scope_id : lst)
-        symtab.dump (octave_stdout, scope_id);
+      for (auto *scp : lst)
+        symtab.dump (octave_stdout, scp);
+#endif
     }
   else
     {
       octave_value arg = args(0);
 
       if (arg.is_string ())
         {
           std::string s_arg = arg.string_value ();
 
           if (s_arg == "scopes")
             {
-              std::list<symbol_table::scope_id> lst = symtab.scopes ();
+              // This won't work now...
+#if 0
+              std::list<symbol_table::scope*> lst = symtab.scopes ();
 
               RowVector v (lst.size ());
 
               octave_idx_type k = 0;
 
-              for (const auto& sid : lst)
+              for (auto *sid : lst)
                 v.xelem (k++) = sid;
 
               retval = v;
+#endif
             }
           else if (s_arg == "functions")
             {
               symtab.dump_functions (octave_stdout);
             }
           else
             error ("__dump_symtab_info__: string argument must be \"functions\" or \"scopes\"");
         }
       else
         {
+          // This won't work now...
+#if 0
           int sid = arg.xint_value ("__dump_symtab_info__: first argument must be string or scope id");
 
           symtab.dump (octave_stdout, sid);
+#endif
         }
     }
 
   return retval;
 }
 
 DEFMETHOD (__get_cmdline_fcn_txt__, interp, args, ,
            doc: /* -*- texinfo -*-
diff --git a/libinterp/corefcn/symtab.h b/libinterp/corefcn/symtab.h
--- a/libinterp/corefcn/symtab.h
+++ b/libinterp/corefcn/symtab.h
@@ -47,100 +47,23 @@ class octave_user_function;
 class
 OCTINTERP_API
 symbol_table
 {
 public:
 
   static octave_value dummy_octave_value;
 
-  typedef int scope_id;
   typedef size_t context_id;
 
   class scope;
 
-  class scope_id_cache
-  {
-  public:
-
-    typedef std::set<scope_id>::iterator set_iterator;
-    typedef std::set<scope_id>::const_iterator set_const_iterator;
-
-    // We start with 2 because we allocate 0 for the global symbols
-    // and 1 for the top-level workspace.
-
-    scope_id_cache (void)
-      : m_next_available (2), m_in_use (), m_free_list () { }
-
-    // No copying!
-
-    scope_id_cache (const scope_id_cache&) = delete;
-
-    scope_id_cache& operator = (const scope_id_cache&) = delete;
-
-    ~scope_id_cache (void) = default;
-
-    scope_id alloc (void)
-    {
-      scope_id retval;
-
-      set_iterator p = m_free_list.begin ();
-
-      if (p != m_free_list.end ())
-        {
-          retval = *p;
-          m_free_list.erase (p);
-        }
-      else
-        retval = m_next_available++;
-
-      m_in_use.insert (retval);
-
-      return retval;
-    }
-
-    void free (scope_id sid)
-    {
-      set_iterator p = m_in_use.find (sid);
-
-      if (p == m_in_use.end ())
-        error ("free_scope: scope %d not found!", sid);
-
-      m_in_use.erase (p);
-      m_free_list.insert (sid);
-    }
-
-    std::list<scope_id> scopes (void) const
-    {
-      std::list<scope_id> retval;
-
-      for (const auto& scope_id : m_in_use)
-        retval.push_back (scope_id);
-
-      retval.sort ();
-
-      return retval;
-    }
-
-  private:
-
-    // The next available scope not in the free list.
-    scope_id m_next_available;
-
-    // The set of scope IDs that are currently allocated.
-    std::set<scope_id> m_in_use;
-
-    // The set of scope IDs that are currently available.
-    std::set<scope_id> m_free_list;
-  };
-
   class fcn_info;
 
-  class
-  symbol_record
+  class symbol_record
   {
   public:
 
     // generic variable
     static const unsigned int local = 1;
 
     // varargin, argn, .nargin., .nargout.
     // (FIXME: is this really used now?)
@@ -162,110 +85,102 @@ public:
     static const unsigned int persistent = 64;
 
     // this symbol may NOT become a variable.
     // (symbol added to a static workspace)
     static const unsigned int added_static = 128;
 
   private:
 
-    class
-    symbol_record_rep
+    class symbol_record_rep
     {
     public:
 
-      symbol_record_rep (scope_id sid, const std::string& nm,
+      symbol_record_rep (scope *s, const std::string& nm,
                          const octave_value& v, unsigned int sc)
-        : m_decl_scope (sid), curr_fcn (0), name (nm), value_stack (),
+        : m_decl_scope (s), curr_fcn (0), name (nm), value_stack (),
           storage_class (sc), /* finfo (), */ valid (true), count (1)
       {
         value_stack.push_back (v);
       }
 
       // No copying!
 
       symbol_record_rep (const symbol_record_rep& ov) = delete;
 
       symbol_record_rep& operator = (const symbol_record_rep&) = delete;
 
       ~symbol_record_rep (void) = default;
 
-      void assign (const octave_value& value,
-                   context_id context = xdefault_context)
+      void assign (const octave_value& value, context_id context)
       {
         varref (context) = value;
       }
 
       void assign (octave_value::assign_op op,
                    const std::string& type,
                    const std::list<octave_value_list>& idx,
                    const octave_value& value,
-                   context_id context = xdefault_context)
+                   context_id context)
       {
         varref(context).assign (op, type, idx, value);
       }
 
       void assign (octave_value::assign_op op, const octave_value& value,
-                   context_id context = xdefault_context)
+                   context_id context)
       {
         varref(context).assign (op, value);
       }
 
       void do_non_const_unary_op (octave_value::unary_op op,
-                                  context_id context = xdefault_context)
+                                  context_id context)
       {
         varref(context).do_non_const_unary_op (op);
       }
 
       void do_non_const_unary_op (octave_value::unary_op op,
                                   const std::string& type,
                                   const std::list<octave_value_list>& idx,
-                                  context_id context = xdefault_context)
+                                  context_id context)
       {
         varref(context).do_non_const_unary_op (op, type, idx);
       }
 
-      octave_value& varref (context_id context = xdefault_context)
+      octave_value& varref (context_id context)
       {
         if (is_global ())
           return xglobal_varref ();
         else if (is_persistent ())
           return xpersistent_varref ();
         else
           {
-            if (context == xdefault_context)
-              context = active_context ();
-
             context_id n = value_stack.size ();
             while (n++ <= context)
               value_stack.push_back (octave_value ());
 
             return value_stack[context];
           }
       }
 
-      octave_value varval (context_id context = xdefault_context) const
+      octave_value varval (context_id context) const
       {
         if (is_global ())
           return xglobal_varval ();
         else if (is_persistent ())
           return xpersistent_varval ();
         else
           {
-            if (context == xdefault_context)
-              context = active_context ();
-
             if (context < value_stack.size ())
               return value_stack[context];
             else
               return octave_value ();
           }
       }
 
-      void push_context (scope_id sid)
+      void push_context (scope *sid)
       {
         if (! (is_persistent () || is_global ())
             && sid == decl_scope ())
           value_stack.push_back (octave_value ());
       }
 
       // If pop_context returns 0, we are out of values and this element
       // of the symbol table should be deleted.  This can happen for
@@ -276,52 +191,46 @@ public:
       //       foo (n-1);
       //     else
       //       eval ("x = 1");
       //     endif
       //   endfunction
       //
       // Here, X should only exist in the final stack frame.
 
-      size_t pop_context (scope_id sid)
+      size_t pop_context (scope *sid)
       {
         size_t retval = 1;
 
         if (! (is_persistent () || is_global ())
             && sid == decl_scope ())
           {
             value_stack.pop_back ();
             retval = value_stack.size ();
           }
 
         return retval;
       }
 
       void clear (void) { clear (decl_scope ()); }
 
-      void clear (scope_id sid);
-
-      bool is_defined (context_id context = xdefault_context) const
+      void clear (const scope *sid);
+
+      bool is_defined (context_id context) const
       {
-        if (context == xdefault_context)
-          context = active_context ();
-
         return varval (context).is_defined ();
       }
 
       bool is_valid (void) const
       {
         return valid;
       }
 
       bool is_variable (context_id context) const
       {
-        if (context == xdefault_context)
-          context = active_context ();
-
         return (! is_local () || is_defined (context));
       }
 
       bool is_local (void) const { return storage_class & local; }
       bool is_automatic (void) const { return storage_class & automatic; }
       bool is_formal (void) const { return storage_class & formal; }
       bool is_hidden (void) const { return storage_class & hidden; }
       bool is_inherited (void) const { return storage_class & inherited; }
@@ -363,34 +272,28 @@ public:
 
       void invalidate (void)
       {
         valid = false;
       }
 
       void erase_persistent (void);
 
-      OCTINTERP_API context_id active_context (void) const;
-
-      scope_id decl_scope (void) const { return m_decl_scope; }
+      const scope *decl_scope (void) const { return m_decl_scope; }
 
       void set_curr_fcn (octave_user_function *fcn)
       {
         curr_fcn = fcn;
       }
 
-      symbol_record_rep * dup (scope_id new_scope) const
-      {
-        return new symbol_record_rep (new_scope, name, varval (),
-                                      storage_class);
-      }
+      symbol_record_rep * dup (scope *new_scope) const;
 
       void dump (std::ostream& os, const std::string& prefix) const;
 
-      scope_id m_decl_scope;
+      scope *m_decl_scope;
 
       octave_user_function *curr_fcn;
 
       std::string name;
 
       std::deque<octave_value> value_stack;
 
       unsigned int storage_class;
@@ -411,17 +314,17 @@ public:
 
       octave_value xpersistent_varval (void) const;
     };
 
   public:
 
     symbol_record (void);
 
-    symbol_record (scope_id s, const std::string& nm = "",
+    symbol_record (scope *s, const std::string& nm = "",
                    const octave_value& v = octave_value (),
                    unsigned int sc = local)
       : rep (new symbol_record_rep (s, nm, v, sc)) { }
 
     symbol_record (const symbol_record& sr)
       : rep (sr.rep)
     {
       rep->count++;
@@ -442,96 +345,97 @@ public:
     }
 
     ~symbol_record (void)
     {
       if (--rep->count == 0)
         delete rep;
     }
 
-    symbol_record dup (scope_id new_scope) const
+    symbol_record dup (scope *sid) const
     {
-      return symbol_record (rep->dup (new_scope));
+      return symbol_record (rep->dup (sid));
     }
 
     const std::string& name (void) const { return rep->name; }
 
     void rename (const std::string& new_name) { rep->name = new_name; }
 
     octave_value
     find (const octave_value_list& args = octave_value_list ()) const;
 
-    void assign (const octave_value& value,
-                 context_id context = xdefault_context)
+    void assign (const octave_value& value, context_id context)
     {
       rep->assign (value, context);
     }
 
     void assign (octave_value::assign_op op,
                  const std::string& type,
                  const std::list<octave_value_list>& idx,
                  const octave_value& value,
-                 context_id context = xdefault_context)
+                 context_id context)
     {
       rep->assign (op, type, idx, value, context);
     }
 
     void assign (octave_value::assign_op op, const octave_value& value,
-                 context_id context = xdefault_context)
+                 context_id context)
     {
       rep->assign (op, value, context);
     }
 
-    void do_non_const_unary_op (octave_value::unary_op op)
+    void do_non_const_unary_op (octave_value::unary_op op,
+                                context_id context)
     {
-      rep->do_non_const_unary_op (op);
+      rep->do_non_const_unary_op (op, context);
     }
 
     void do_non_const_unary_op (octave_value::unary_op op,
                                 const std::string& type,
-                                const std::list<octave_value_list>& idx)
+                                const std::list<octave_value_list>& idx,
+                                context_id context)
     {
-      rep->do_non_const_unary_op (op, type, idx);
+      rep->do_non_const_unary_op (op, type, idx, context);
     }
 
     // Delete when deprecated varref functions are removed.
-    octave_value& varref (context_id context = xdefault_context)
+    octave_value& varref (context_id context)
     {
       return rep->varref (context);
     }
 
-    octave_value varval (context_id context = xdefault_context) const
+    octave_value varval (context_id context) const
     {
       return rep->varval (context);
     }
 
-    void push_context (scope_id sid) { rep->push_context (sid); }
-
-    size_t pop_context (scope_id sid) { return rep->pop_context (sid); }
+    void push_context (scope *sid) { rep->push_context (sid); }
+
+    size_t pop_context (scope *sid) { return rep->pop_context (sid); }
 
     void clear (void) { rep->clear (); }
 
-    void clear (scope_id sid) { rep->clear (sid); }
-
-    bool is_defined (context_id context = xdefault_context) const
+    void clear (const scope *sid) { rep->clear (sid); }
+
+    bool is_defined (context_id context) const
     {
       return rep->is_defined (context);
     }
 
-    bool is_undefined (context_id context = xdefault_context) const
+    bool is_undefined (context_id context) const
     {
       return ! rep->is_defined (context);
     }
 
     bool is_valid (void) const
     {
       return rep->is_valid ();
     }
 
-    bool is_variable (context_id context = xdefault_context) const
+    bool is_variable (context_id context) const
     {
       return rep->is_variable (context);
     }
 
     bool is_local (void) const { return rep->is_local (); }
     bool is_automatic (void) const { return rep->is_automatic (); }
     bool is_formal (void) const { return rep->is_formal (); }
     bool is_global (void) const { return rep->is_global (); }
@@ -559,19 +463,17 @@ public:
     void unmark_added_static (void) { rep->unmark_added_static (); }
 
     void init_persistent (void) { rep->init_persistent (); }
 
     void erase_persistent (void) { rep->erase_persistent (); }
 
     void invalidate (void) { rep->invalidate (); }
 
-    context_id active_context (void) const { return rep->active_context (); }
-
-    scope_id decl_scope (void) const { return rep->decl_scope (); }
+    const scope *decl_scope (void) const { return rep->decl_scope (); }
 
     unsigned int xstorage_class (void) const { return rep->storage_class; }
 
     void set_curr_fcn (octave_user_function *fcn) { rep->set_curr_fcn (fcn); }
 
     void
     dump (std::ostream& os, const std::string& prefix = "") const
     {
@@ -585,33 +487,46 @@ public:
     symbol_record (symbol_record_rep *new_rep) : rep (new_rep) { }
   };
 
   static symbol_record dummy_symbol_record;
 
   // Always access a symbol from the current scope.
   // Useful for scripts, as they may be executed in more than one scope.
   class
-  symbol_reference
+    symbol_reference
   {
   public:
 
-    symbol_reference (void) : m_scope (-1) { }
+    symbol_reference (void) : m_scope (0), m_context (0) { }
 
     symbol_reference (const symbol_record& record);
 
-    symbol_reference (const symbol_record& record, scope_id curr_scope)
-      : m_scope (curr_scope), m_sym (record)
+    symbol_reference (const symbol_record& record, scope *curr_scope,
+                      context_id context = 0)
+      : m_scope (curr_scope), m_context (context), m_sym (record)
     { }
 
     symbol_reference (const symbol_reference& ref) = default;
 
     symbol_reference& operator = (const symbol_reference& ref) = default;
 
-    bool is_black_hole (void) const { return m_scope < 0; }
+    bool is_black_hole (void) const { return ! m_scope; }
+
+    symbol_table::scope * scope (void) const
+    {
+      update ();
+      return m_scope;
+    }
+
+    context_id context (void) const
+    {
+      update ();
+      return m_context;
+    }
 
     // The name is the same regardless of scope.
     const std::string& name (void) const { return m_sym.name (); }
 
     symbol_record *operator-> (void)
     {
       update ();
       return &m_sym;
@@ -632,27 +547,28 @@ public:
       {
         return lhs.name () < rhs.name ();
       }
     };
   private:
 
     void update (void) const;
 
-    mutable scope_id m_scope;
+    mutable symbol_table::scope *m_scope;
+    mutable context_id m_context;
     mutable symbol_record m_sym;
   };
 
   class
-  fcn_info
+    fcn_info
   {
   public:
 
     typedef std::map<std::string, octave_value>::const_iterator
-      str_val_const_iterator;
+    str_val_const_iterator;
     typedef std::map<std::string, octave_value>::iterator str_val_iterator;
 
   private:
 
     class
     fcn_info_rep
     {
     public:
@@ -961,235 +877,170 @@ public:
     }
 
   private:
 
     fcn_info_rep *rep;
   };
 
   symbol_table (void)
-    : m_scope_id_cache (), m_global_symbols (), m_all_scopes (),
-      m_fcn_table (), m_class_precedence_table (), m_parent_map (),
-      m_current_scope (xtop_scope)
+    : m_global_symbols (), m_fcn_table (), m_class_precedence_table (),
+      m_parent_map (), m_global_scope (new scope ("global scope")),
+      m_top_scope (new scope ("top scope")),
+      m_current_scope (m_top_scope)
   { }
 
   // No copying!
 
   symbol_table (const symbol_table&) = delete;
 
   symbol_table& operator = (const symbol_table&) = delete;
 
-  ~symbol_table (void) = default;
-
-  static scope_id global_scope (void) { return xglobal_scope; }
-  static scope_id top_scope (void) { return xtop_scope; }
-
-  scope_id current_scope (void) { return m_current_scope; }
-
-  context_id current_context (void) { return xcurrent_context; }
-
-  scope_id alloc_scope (void) { return m_scope_id_cache.alloc (); }
-
-  void set_scope (scope_id sid)
+  ~symbol_table (void)
+    {
+      delete m_top_scope;
+      delete m_global_scope;
+    }
+
+  scope *global_scope (void) { return m_global_scope; }
+  scope *top_scope (void) { return m_top_scope; }
+
+  scope *current_scope (void) { return m_current_scope; }
+
+  context_id current_context (void) const
+  {
+    return m_current_scope ? m_current_scope->current_context () : 0;
+  }
+
+  void set_scope (scope *sid)
   {
     set_scope_and_context (sid, 0);
   }
 
-  void set_scope_and_context (scope_id sid, context_id context)
+  void set_scope_and_context (scope *sid, context_id context)
   {
-    if (sid == xglobal_scope)
+    if (sid == m_global_scope)
       error ("can't set scope to global");
 
-    all_scopes_iterator p = m_all_scopes.find (sid);
-
-    if (p == m_all_scopes.end ())
-      {
-        // Can only create a new scope if we are starting at the
-        // base context.
-
-        if (context != 0)
-          error ("can't find scope %d", sid);
-
-        scope *s = new scope (sid);
-
-        if (! s)
-          error ("failed to create scope %d", sid);
-
-        m_all_scopes[sid] = s;
-      }
-
     m_current_scope = sid;
-    xcurrent_context = context;
-  }
-
-  void erase_scope (scope_id sid)
-  {
-    assert (sid != xglobal_scope);
-
-    all_scopes_iterator p = m_all_scopes.find (sid);
-
-    if (p != m_all_scopes.end ())
-      {
-        m_all_scopes.erase (p);
-
-        free_scope (sid);
-      }
+
+    if (m_current_scope)
+      m_current_scope->set_context (context);
   }
 
-  void erase_subfunctions_in_scope (scope_id sid)
+  void erase_subfunctions_in_scope (scope *sid)
   {
-    scope *s = get_scope (sid);
-
-    if (s)
-      s->erase_subfunctions ();
+    if (sid)
+      sid->erase_subfunctions ();
   }
 
-  void mark_nested (scope_id sid)
+  void mark_nested (scope *sid)
   {
-    scope *s = get_scope (sid);
-
-    if (s)
-      s->mark_nested ();
+    if (sid)
+      sid->mark_nested ();
   }
 
   void
-  mark_subfunctions_in_scope_as_private (scope_id sid,
-                                         const std::string& class_name)
-  {
-    scope *s = get_scope (sid);
-
-    if (s)
-      s->mark_subfunctions_in_scope_as_private (class_name);
-  }
-
-  scope_id dup_scope (scope_id sid)
+    mark_subfunctions_in_scope_as_private (scope *sid,
+                                           const std::string& class_name)
   {
-    scope_id retval = -1;
-
-    scope *s = get_scope (sid);
-
-    if (s)
-      {
-        scope_id new_sid = alloc_scope ();
-
-        m_all_scopes[new_sid] = s->dup (new_sid);
-
-        retval = new_sid;
-      }
-
-    return retval;
-  }
-
-  std::list<scope_id> scopes (void)
-  {
-    return m_scope_id_cache.scopes ();
+    if (sid)
+      sid->mark_subfunctions_in_scope_as_private (class_name);
   }
 
   symbol_record
-  find_symbol (const std::string& name, scope_id sid)
+    find_symbol (const std::string& name, scope *sid)
   {
-    scope *s = get_scope (sid);
-
-    return s ? s->find_symbol (name) : symbol_record (sid);
+    return sid ? sid->find_symbol (name) : symbol_record ();
   }
 
   symbol_record find_symbol (const std::string& name)
   {
     return find_symbol (name, m_current_scope);
   }
 
   void
-  inherit (scope_id sid, scope_id donor_sid, context_id donor_context)
+    inherit (scope *recipient_scope, scope *donor_scope,
+             context_id donor_context)
   {
-    scope *s = get_scope (sid);
-
-    if (s)
+    if (recipient_scope)
       {
-        while (donor_sid > 0)
+        while (donor_scope)
           {
-            scope *donor_scope = get_scope (donor_sid);
-
-            if (donor_scope)
-              {
-                s->inherit (*donor_scope, donor_context);
-
-                if (donor_scope->is_nested ())
-                  donor_sid = donor_scope->parent_scope_id ();
-                else
-                  break;
-              }
+            recipient_scope->inherit (*donor_scope, donor_context);
+
+            if (donor_scope->is_nested ())
+              donor_scope = donor_scope->parent_scope ();
+            else
+              break;
           }
       }
   }
 
   void
-  inherit (scope_id sid, scope_id donor_sid)
+  inherit (scope *sid, scope *donor_sid)
   {
-    inherit (sid, donor_sid, xcurrent_context);
+    context_id donor_context = donor_sid ? donor_sid->current_context () : 0;
+
+    inherit (sid, donor_sid, donor_context);
   }
 
-  void inherit (scope_id sid)
+  void inherit (scope *sid)
   {
     inherit (sid, m_current_scope);
   }
 
-  bool at_top_level (void) { return m_current_scope == xtop_scope; }
+  bool at_top_level (void) { return m_current_scope == m_top_scope; }
 
   // Find a value corresponding to the given name in the table.
   octave_value
-  find (const std::string& name,
-        const octave_value_list& args = octave_value_list (),
-        bool skip_variables = false,
-        bool local_funcs = true);
+    find (const std::string& name,
+          const octave_value_list& args = octave_value_list (),
+          bool skip_variables = false,
+          bool local_funcs = true);
 
   octave_value builtin_find (const std::string& name);
 
   // Insert a new name in the table.
   OCTAVE_DEPRECATED ("use 'get_scope' with 'insert (name)' instead")
-  symbol_record& insert (const std::string& name, scope_id sid)
-  {
-    scope *s = get_scope (sid);
-
-    return s ? s->insert (name) : symbol_table::dummy_symbol_record;
-  }
+    symbol_record& insert (const std::string& name, scope *sid)
+    {
+      return sid ? sid->insert (name) : symbol_table::dummy_symbol_record;
+    }
 
   symbol_record& insert (const std::string& name)
   {
-    scope *s = get_scope (m_current_scope);
-
-    return s ? s->insert (name) : symbol_table::dummy_symbol_record;
+    return (m_current_scope
+            ? m_current_scope->insert (name)
+            : symbol_table::dummy_symbol_record);
   }
 
   void rename (const std::string& old_name, const std::string& new_name)
   {
-    scope *s = get_scope (m_current_scope);
-
-    if (s)
-      s->rename (old_name, new_name);
+    if (m_current_scope)
+      m_current_scope->rename (old_name, new_name);
   }
 
   void assign (const std::string& name, const octave_value& value,
-               scope_id sid, context_id context, bool force_add)
+               scope *sid, context_id context, bool force_add)
   {
-    scope *s = get_scope (sid);
-
-    if (s)
-      s->assign (name, value, context, force_add);
+    if (sid)
+      sid->assign (name, value, context, force_add);
   }
 
   void assign (const std::string& name, const octave_value& value,
-               scope_id sid, context_id context)
+               scope *sid, context_id context)
   {
     assign (name, value, sid, context, false);
   }
 
   void assign (const std::string& name, const octave_value& value,
-               scope_id sid)
+               scope *sid)
   {
-    assign (name, value, sid, xdefault_context);
+    assign (name, value, sid, m_current_scope->current_context ());
   }
 
   void assign (const std::string& name,
                const octave_value& value = octave_value ())
   {
     assign (name, value, m_current_scope);
   }
 
@@ -1197,49 +1048,47 @@ public:
   // octave_value&
   // varref (const std::string& name, scope_id sid = xcurrent_scope,
   //         context_id context = xdefault_context, bool force_add = false);
 
   // Convenience function to simplify
   // octave_user_function::bind_automatic_vars
 
   void force_assign (const std::string& name, const octave_value& value,
-                     scope_id sid, context_id context)
+                     scope *sid, context_id context)
   {
     assign (name, value, sid, context, true);
   }
 
   void force_assign (const std::string& name, const octave_value& value,
-                     scope_id sid)
+                     scope *sid)
   {
-    assign (name, value, sid, xdefault_context);
+    assign (name, value, sid, m_current_scope->current_context ());
   }
 
   void force_assign (const std::string& name,
                      const octave_value& value = octave_value ())
   {
     assign (name, value, m_current_scope);
   }
 
   // use 'force_assign' instead
   // octave_value&
   // force_varref (const std::string& name, scope_id sid = xcurrent_scope,
   //               context_id context = xdefault_context);
 
-  octave_value varval (const std::string& name, scope_id sid,
+  octave_value varval (const std::string& name, scope *sid,
                        context_id context)
   {
-    scope *s = get_scope (sid);
-
-    return s ? s->varval (name, context) : octave_value ();
+    return sid ? sid->varval (name, context) : octave_value ();
   }
 
-  octave_value varval (const std::string& name, scope_id sid)
+  octave_value varval (const std::string& name, scope *sid)
   {
-    return varval (name, sid, xdefault_context);
+    return varval (name, sid, m_current_scope->current_context ());
   }
 
   octave_value varval (const std::string& name)
   {
     return varval (name, m_current_scope);
   }
 
   void
@@ -1280,76 +1129,67 @@ public:
 
   octave_value
   top_level_varval (const std::string& name)
   {
     return varval (name, top_scope (), 0);
   }
 
   void
-  persistent_assign (const std::string& name, scope_id sid,
+  persistent_assign (const std::string& name, scope *sid,
                      const octave_value& value = octave_value ())
   {
-    scope *s = get_scope (sid);
-
-    if (s)
-      s->persistent_assign (name, value);
+    if (sid)
+      sid->persistent_assign (name, value);
   }
 
   void
-  persistent_assign (const std::string& name,
-                     const octave_value& value = octave_value ())
+    persistent_assign (const std::string& name,
+                       const octave_value& value = octave_value ())
   {
     persistent_assign (name, m_current_scope, value);
   }
 
   // use 'persistent_assign' instead
   // octave_value&
   // persistent_varref (const std::string& name);
 
   octave_value persistent_varval (const std::string& name)
   {
-    scope *s = get_scope (m_current_scope);
-
-    return s ? s->persistent_varval (name) : octave_value ();
+    return (m_current_scope
+            ? m_current_scope->persistent_varval (name) : octave_value ());
   }
 
   void erase_persistent (const std::string& name)
   {
-    scope *s = get_scope (m_current_scope);
-
-    if (s)
-      s->erase_persistent (name);
+    if (m_current_scope)
+      m_current_scope->erase_persistent (name);
   }
 
   OCTAVE_DEPRECATED ("use 'get_scope' with 'is_variable (name)' instead")
-  bool is_variable (const std::string& name, scope_id sid)
-  {
-    scope *s = get_scope (sid);
-
-    return s ? s->is_variable (name) : false;
-  }
+    bool is_variable (const std::string& name, scope *sid)
+    {
+      return sid ? sid->is_variable (name) : false;
+    }
 
   bool is_variable (const std::string& name)
   {
-    scope *s = get_scope (m_current_scope);
-
-    return s ? s->is_variable (name) : false;
+    return m_current_scope ? m_current_scope->is_variable (name) : false;
   }
 
   bool
-  is_built_in_function_name (const std::string& name)
+    is_built_in_function_name (const std::string& name)
   {
     octave_value val = find_built_in_function (name);
 
     return val.is_defined ();
   }
 
   octave_value
-  find_method (const std::string& name, const std::string& dispatch_type)
+    find_method (const std::string& name, const std::string& dispatch_type)
   {
     fcn_table_const_iterator p = m_fcn_table.find (name);
 
     if (p != m_fcn_table.end ())
       {
         octave_value fcn = p->second.find_method (dispatch_type);
 
         if (! fcn.is_defined ())
@@ -1369,40 +1209,40 @@ public:
         if (fcn.is_defined ())
           m_fcn_table[name] = finfo;
 
         return fcn;
       }
   }
 
   octave_value
-  find_submethod (const std::string& name, const std::string& dispatch_type);
+    find_submethod (const std::string& name, const std::string& dispatch_type);
 
   octave_value
-  find_built_in_function (const std::string& name)
+    find_built_in_function (const std::string& name)
   {
     fcn_table_const_iterator p = m_fcn_table.find (name);
 
     return (p != m_fcn_table.end ()
             ? p->second.find_built_in_function () : octave_value ());
   }
 
   octave_value
-  find_autoload (const std::string& name)
+    find_autoload (const std::string& name)
   {
     fcn_table_iterator p = m_fcn_table.find (name);
 
     return (p != m_fcn_table.end ()
             ? p->second.find_autoload () : octave_value ());
   }
 
   octave_value
-  find_function (const std::string& name,
-                 const octave_value_list& args = octave_value_list (),
-                 bool local_funcs = true);
+    find_function (const std::string& name,
+                   const octave_value_list& args = octave_value_list (),
+                   bool local_funcs = true);
 
   octave_value find_user_function (const std::string& name)
   {
     fcn_table_iterator p = m_fcn_table.find (name);
 
     return (p != m_fcn_table.end ()
             ? p->second.find_user_function () : octave_value ());
   }
@@ -1434,42 +1274,34 @@ public:
 
         m_fcn_table[name] = finfo;
       }
   }
 
   // Install subfunction FCN named NAME.  SCOPE is the scope of the
   // primary function corresponding to this subfunction.
 
-  void install_subfunction (const std::string& name,
-                            const octave_value& fcn,
-                            scope_id parent_scope)
+  void install_subfunction (const std::string& name, const octave_value& fcn,
+                            scope *parent_scope)
   {
-    scope *s = get_scope (parent_scope);
-
-    if (s)
-      s->install_subfunction (name, fcn);
+    if (parent_scope)
+      parent_scope->install_subfunction (name, fcn);
   }
 
-  void install_nestfunction (const std::string& name,
-                             const octave_value& fcn,
-                             scope_id parent_scope)
+  void install_nestfunction (const std::string& name, const octave_value& fcn,
+                             scope *parent_scope)
   {
-    scope *s = get_scope (parent_scope);
-
-    if (s)
-      s->install_subfunction (name, fcn, true);
+    if (parent_scope)
+      parent_scope->install_subfunction (name, fcn, true);
   }
 
-  void update_nest (scope_id sid)
+  void update_nest (scope *sid)
   {
-    scope *s = get_scope (sid);
-
-    if (s)
-      s->update_nest ();
+    if (sid)
+      sid->update_nest ();
   }
 
   // Install local function FCN named NAME.  FILE_NAME is the name of
   // the file containing the local function.
 
   void install_local_function (const std::string& name,
                                const octave_value& fcn,
                                const std::string& file_name)
@@ -1547,35 +1379,31 @@ public:
 
     clear_functions (force);
   }
 
   // This is written as two separate functions instead of a single
   // function with default values so that it will work properly with
   // unwind_protect.
 
-  void clear_variables (scope_id sid)
+  void clear_variables (scope *sid)
   {
-    scope *s = get_scope (sid);
-
-    if (s)
-      s->clear_variables ();
+    if (sid)
+      sid->clear_variables ();
   }
 
   void clear_variables (void)
   {
     clear_variables (m_current_scope);
   }
 
   void clear_objects (void)
   {
-    scope *s = get_scope (m_current_scope);
-
-    if (s)
-      s->clear_objects ();
+    if (m_current_scope)
+      m_current_scope->clear_objects ();
   }
 
   void clear_functions (bool force = false)
   {
     fcn_table_iterator p = m_fcn_table.begin ();
 
     while (p != m_fcn_table.end ())
       (p++)->second.clear (force);
@@ -1583,28 +1411,24 @@ public:
 
   void clear_function (const std::string& name)
   {
     clear_user_function (name);
   }
 
   void clear_global (const std::string& name)
   {
-    scope *s = get_scope (m_current_scope);
-
-    if (s)
-      s->clear_global (name);
+    if (m_current_scope)
+      m_current_scope->clear_global (name);
   }
 
   void clear_variable (const std::string& name)
   {
-    scope *s = get_scope (m_current_scope);
-
-    if (s)
-      s->clear_variable (name);
+    if (m_current_scope)
+      m_current_scope->clear_variable (name);
   }
 
   void clear_symbol (const std::string& name)
   {
     // FIXME: are we supposed to do both here?
 
     clear_variable (name);
     clear_function (name);
@@ -1622,36 +1446,30 @@ public:
           (p++)->second.clear_user_function ();
         else
           p++;
       }
   }
 
   void clear_global_pattern (const std::string& pat)
   {
-    scope *s = get_scope (m_current_scope);
-
-    if (s)
-      s->clear_global_pattern (pat);
+    if (m_current_scope)
+      m_current_scope->clear_global_pattern (pat);
   }
 
   void clear_variable_pattern (const std::string& pat)
   {
-    scope *s = get_scope (m_current_scope);
-
-    if (s)
-      s->clear_variable_pattern (pat);
+    if (m_current_scope)
+      m_current_scope->clear_variable_pattern (pat);
   }
 
   void clear_variable_regexp (const std::string& pat)
   {
-    scope *s = get_scope (m_current_scope);
-
-    if (s)
-      s->clear_variable_regexp (pat);
+    if (m_current_scope)
+      m_current_scope->clear_variable_regexp (pat);
   }
 
   void clear_symbol_pattern (const std::string& pat)
   {
     // FIXME: are we supposed to do both here?
 
     clear_variable_pattern (pat);
     clear_function_pattern (pat);
@@ -1728,146 +1546,132 @@ public:
         finfo.install_built_in_dispatch (klass);
       }
     else
       error ("install_built_in_dispatch: '%s' is undefined", name.c_str ());
   }
 
   void push_context (void)
   {
-    if (m_current_scope == xtop_scope)
+    if (m_current_scope == m_top_scope)
       error ("invalid call to symtab::push_context");
 
-    scope *s = get_scope (m_current_scope);
-
-    if (s)
-      s->push_context ();
+    if (m_current_scope)
+      m_current_scope->push_context ();
   }
 
   // This is written as two separate functions instead of a single
   // function with default values so that it will work properly with
   // unwind_protect.
 
   void pop_context (void)
   {
-    if (m_current_scope == xtop_scope)
+    if (m_current_scope == m_top_scope)
       error ("invalid call to symtab::pop_context");
 
-    scope *s = get_scope (m_current_scope);
-
-    if (s)
-      s->pop_context ();
+    if (m_current_scope)
+      m_current_scope->pop_context ();
   }
 
   // For unwind_protect where a pointer argument is needed.
 
   void pop_context (void *) { pop_context (); }
 
   void mark_automatic (const std::string& name)
   {
-    scope *s = get_scope (m_current_scope);
-
-    if (s)
-      s->mark_automatic (name);
+    if (m_current_scope)
+      m_current_scope->mark_automatic (name);
   }
 
   void mark_hidden (const std::string& name)
   {
-    scope *s = get_scope (m_current_scope);
-
-    if (s)
-      s->mark_hidden (name);
+    if (m_current_scope)
+      m_current_scope->mark_hidden (name);
   }
 
   void mark_global (const std::string& name)
   {
-    scope *s = get_scope (m_current_scope);
-
-    if (s)
-      s->mark_global (name);
+    if (m_current_scope)
+      m_current_scope->mark_global (name);
   }
 
   // exclude: Storage classes to exclude, you can OR them together
   std::list<symbol_record>
-  all_variables (scope_id sid, context_id context, bool defined_only,
+  all_variables (scope *sid, context_id context, bool defined_only,
                  unsigned int exclude)
   {
-    scope *s = get_scope (sid);
-
-    return (s
-            ? s->all_variables (context, defined_only, exclude)
+    return (sid
+            ? sid->all_variables (context, defined_only, exclude)
             : std::list<symbol_record> ());
   }
 
   std::list<symbol_record>
-  all_variables (scope_id sid, context_id context, bool defined_only)
+  all_variables (scope *sid, context_id context, bool defined_only)
   {
     return all_variables (sid, context, defined_only, symbol_record::hidden);
   }
 
   std::list<symbol_record>
-  all_variables (scope_id sid, context_id context)
+  all_variables (scope *sid, context_id context)
   {
     return all_variables (sid, context, true);
   }
 
   std::list<symbol_record>
-  all_variables (scope_id sid)
+  all_variables (scope *sid)
   {
-    return all_variables (sid, xdefault_context);
+    return all_variables (sid, m_current_scope->current_context ());
   }
 
   std::list<symbol_record>
   all_variables (void)
   {
     return all_variables (m_current_scope);
   }
 
   std::list<symbol_record> glob (const std::string& pattern)
   {
-    scope *s = get_scope (m_current_scope);
-
-    return s ? s->glob (pattern) : std::list<symbol_record> ();
+    return (m_current_scope
+            ? m_current_scope->glob (pattern) : std::list<symbol_record> ());
   }
 
   std::list<symbol_record> regexp (const std::string& pattern)
   {
-    scope *s = get_scope (m_current_scope);
-
-    return s ? s->regexp (pattern) : std::list<symbol_record> ();
+    return (m_current_scope
+            ? m_current_scope->regexp (pattern) : std::list<symbol_record> ());
   }
 
   std::list<symbol_record> glob_variables (const std::string& pattern)
   {
-    scope *s = get_scope (m_current_scope);
-
-    return s ? s->glob (pattern, true) : std::list<symbol_record> ();
+    return (m_current_scope
+            ? m_current_scope->glob (pattern, true)
+            : std::list<symbol_record> ());
   }
 
   std::list<symbol_record> regexp_variables (const std::string& pattern)
   {
-    scope *s = get_scope (m_current_scope);
-
-    return s ? s->regexp (pattern, true) : std::list<symbol_record> ();
+    return (m_current_scope
+            ? m_current_scope->regexp (pattern, true)
+            : std::list<symbol_record> ());
   }
 
   std::list<symbol_record>
   glob_global_variables (const std::string& pattern)
   {
     std::list<symbol_record> retval;
 
     glob_match pat (pattern);
 
     for (const auto& nm_val : m_global_symbols)
       {
         // We generate a list of symbol_record objects so that the results from
         // glob_variables and glob_global_variables may be handled the same
         // way.
         if (pat.match (nm_val.first))
-          retval.push_back (symbol_record (xglobal_scope,
+          retval.push_back (symbol_record (m_global_scope,
                                            nm_val.first, nm_val.second,
                                            symbol_record::global));
       }
 
     return retval;
   }
 
   std::list<symbol_record>
@@ -1878,17 +1682,17 @@ public:
     octave::regexp pat (pattern);
 
     for (const auto& nm_val : m_global_symbols)
       {
         // We generate a list of symbol_record objects so that the results from
         // regexp_variables and regexp_global_variables may be handled the same
         // way.
         if (pat.is_match (nm_val.first))
-          retval.push_back (symbol_record (xglobal_scope,
+          retval.push_back (symbol_record (m_global_scope,
                                            nm_val.first, nm_val.second,
                                            symbol_record::global));
       }
 
     return retval;
   }
 
   std::list<symbol_record> glob_variables (const string_vector& patterns)
@@ -1948,26 +1752,24 @@ public:
 
     retval.sort ();
 
     return retval;
   }
 
   std::list<std::string> top_level_variable_names (void)
   {
-    scope *s = get_scope (xtop_scope);
-
-    return s ? s->variable_names () : std::list<std::string> ();
+    return (m_top_scope
+            ? m_top_scope->variable_names () : std::list<std::string> ());
   }
 
   std::list<std::string> variable_names (void)
   {
-    scope *s = get_scope (m_current_scope);
-
-    return s ? s->variable_names () : std::list<std::string> ();
+    return (m_current_scope
+            ? m_current_scope->variable_names () : std::list<std::string> ());
   }
 
   std::list<std::string> built_in_function_names (void)
   {
     std::list<std::string> retval;
 
     for (const auto& nm_finfo : m_fcn_table)
       {
@@ -1998,98 +1800,74 @@ public:
     if (! retval.empty ())
       retval.sort ();
 
     return retval;
   }
 
   bool is_local_variable (const std::string& name)
   {
-    scope *s = get_scope (m_current_scope);
-
-    return s ? s->is_local_variable (name) : false;
+    return m_current_scope ? m_current_scope->is_local_variable (name) : false;
   }
 
   bool is_global (const std::string& name)
   {
-    scope *s = get_scope (m_current_scope);
-
-    return s ? s->is_global (name) : false;
+    return m_current_scope ? m_current_scope->is_global (name) : false;
   }
 
   std::list<workspace_element> workspace_info (void)
   {
-    scope *s = get_scope (m_current_scope);
-
-    return s ? s->workspace_info () : std::list<workspace_element> ();
+    return (m_current_scope
+            ? m_current_scope->workspace_info ()
+            : std::list<workspace_element> ());
   }
 
-  void dump (std::ostream& os, scope_id sid);
+  void dump (std::ostream& os, scope *sid);
 
   void dump_global (std::ostream& os);
 
   void dump_functions (std::ostream& os);
 
-  void cache_name (scope_id sid, const std::string& name)
+  void cache_name (scope *sid, const std::string& name)
   {
-    scope *s = get_scope (sid, false);
-
-    if (s)
-      s->cache_name (name);
+    if (sid)
+      sid->cache_name (name);
   }
 
-  void lock_subfunctions (scope_id sid)
+  void lock_subfunctions (scope *sid)
   {
-    scope *s = get_scope (sid);
-
-    if (s)
-      s->lock_subfunctions ();
+    if (sid)
+      sid->lock_subfunctions ();
   }
 
-  void unlock_subfunctions (scope_id sid)
+  void unlock_subfunctions (scope *sid)
   {
-    scope *s = get_scope (sid);
-
-    if (s)
-      s->unlock_subfunctions ();
+    if (sid)
+      sid->unlock_subfunctions ();
   }
 
   std::map<std::string, octave_value>
-  subfunctions_defined_in_scope (scope_id sid)
+  subfunctions_defined_in_scope (scope *sid)
   {
-    scope *s = get_scope (sid);
-
-    return (s
-            ? s->subfunctions ()
+    return (sid
+            ? sid->subfunctions ()
             : std::map<std::string, octave_value> ());
   }
 
-  void free_scope (scope_id sid)
-  {
-    if (sid == xglobal_scope || sid == xtop_scope)
-      error ("can't free global or top-level scopes!");
-
-    m_scope_id_cache.free (sid);
-  }
-
-  void stash_dir_name_for_subfunctions (scope_id sid,
+  void stash_dir_name_for_subfunctions (scope *sid,
                                         const std::string& dir_name)
   {
-    scope *s = get_scope (sid);
-
-    if (s)
-      s->stash_dir_name_for_subfunctions (dir_name);
+    if (sid)
+      sid->stash_dir_name_for_subfunctions (dir_name);
   }
 
-  void set_parent (scope_id child_scope_id, scope_id parent_scope_id)
+  void set_parent (scope *child_scope, scope *parent_scope)
   {
-    scope *child_scope = get_scope (child_scope_id);
-
     if (child_scope)
-      child_scope->set_parent (get_scope (parent_scope_id));
+      child_scope->set_parent (parent_scope);
   }
 
   void add_to_parent_map (const std::string& classname,
                           const std::list<std::string>& parent_list)
   {
     m_parent_map[classname] = parent_list;
   }
 
@@ -2113,80 +1891,40 @@ public:
 
         if (! parents.empty ())
           retval.insert (retval.end (), parents.begin (), parents.end ());
       }
 
     return retval;
   }
 
-  OCTAVE_DEPRECATED ("use 'get_scope' with 'get_curr_fcn (name)' instead")
-  octave_user_function * get_curr_fcn (scope_id sid)
+ OCTAVE_DEPRECATED ("use 'get_scope' with 'get_curr_fcn (name)' instead")
+  octave_user_function * get_curr_fcn (scope *sid)
   {
-    scope *s = get_scope (sid);
-    return s->function ();
+    return sid ? sid->function () : 0;
   }
 
   octave_user_function * get_curr_fcn (void)
   {
-    scope *s = get_scope (m_current_scope);
-    return s->function ();
+    return m_current_scope ? m_current_scope->function () : 0;
   }
 
   OCTAVE_DEPRECATED ("set_curr_fcn")
-  void set_curr_fcn (octave_user_function *curr_fcn, scope_id sid)
+  void set_curr_fcn (octave_user_function *curr_fcn, scope *sid)
   {
-    assert (sid != xtop_scope && sid != xglobal_scope);
-    scope *s = get_scope (sid);
+    assert (sid != m_top_scope && sid != m_global_scope);
+
     // FIXME: normally, functions should not usurp each other's scope.
     // If for any incredible reason this is needed, call
     // set_user_function (0, scope) first.  This may cause problems with
     // nested functions, as the curr_fcn of symbol_records must be updated.
-    assert (s->function () == 0 || curr_fcn == 0);
-    s->set_function (curr_fcn);
-  }
-
-  scope * get_scope (scope_id sid, bool create = true)
-  {
-    scope *retval = nullptr;
-
-    bool ok = true;
-
-    if (sid == xglobal_scope)
-      error ("can't get global scope");
-
-    all_scopes_iterator p = m_all_scopes.find (sid);
-
-    if (p == m_all_scopes.end ())
-      {
-        if (create)
-          {
-            retval = new scope (sid);
-
-            if (retval)
-              {
-                m_all_scopes[sid] = retval;
-
-                if (sid == xtop_scope)
-                  retval->cache_name ("top-level");
-              }
-            else
-              ok = false;
-          }
-        else
-          ok = false;
-      }
-    else
-      retval = p->second;
-
-    if (! ok)
-      error ("unable to %s scope object for scope id %d!",
-             create ? "create" : "find", sid);
-
-    return retval;
+
+    assert (sid && (sid->function () == 0 || curr_fcn == 0));
+
+    sid->set_function (curr_fcn);
   }
 
   void cleanup (void);
 
   class scope
   {
   public:
 
@@ -2199,20 +1937,20 @@ public:
       m_persistent_symbols_const_iterator;
     typedef std::map<std::string, octave_value>::iterator
       m_persistent_symbols_iterator;
 
     typedef std::map<std::string, octave_value>::const_iterator
       subfunctions_const_iterator;
     typedef std::map<std::string, octave_value>::iterator subfunctions_iterator;
 
-    scope (scope_id sid)
-      : m_scope (sid), m_name (), m_symbols (), m_children (),
-        m_subfunctions (), m_parent (0), m_fcn (0), m_is_nested (false),
-        m_is_static (false), m_persistent_symbols ()
+    scope (const std::string& name = "")
+      : m_name (name), m_symbols (), m_children (), m_subfunctions (),
+        m_parent (0), m_fcn (0), m_is_nested (false), m_is_static (false),
+        m_persistent_symbols (), m_context (0)
     { }
 
     // No copying!
 
     scope (const scope&) = delete;
 
     scope& operator = (const scope&) = delete;
 
@@ -2222,33 +1960,34 @@ public:
     {
       m_symbols[sr.name ()] = sr;
     }
 
     bool is_nested (void) const { return m_is_nested; }
 
     void mark_nested (void) { m_is_nested = true; }
 
-    scope_id parent_scope_id (void) const
+    scope * parent_scope (void) const { return m_parent; }
+
+    scope * dup (void) const
     {
-      return m_parent ? m_parent->m_scope : -1;
-    }
-
-    scope * dup (scope_id new_sid) const
-    {
-      scope *new_scope = new scope (new_sid);
+      scope *new_sid = new scope ();
 
       for (const auto& nm_sr : m_symbols)
-        new_scope->insert_symbol_record (nm_sr.second.dup (new_sid));
-
-      new_scope->m_parent = m_parent;
-
-      return new_scope;
+        new_sid->insert_symbol_record (nm_sr.second.dup (new_sid));
+
+      new_sid->m_parent = m_parent;
+
+      return new_sid;
     }
 
+    void set_context (context_id context) { m_context = context; }
+
+    context_id current_context (void) const { return m_context; }
+
     symbol_table::symbol_record find_symbol (const std::string& name)
     {
       table_iterator p = m_symbols.find (name);
 
       if (p == m_symbols.end ())
         return insert (name);
       else
         return p->second;
@@ -2287,17 +2026,17 @@ public:
 
     symbol_table::symbol_record&
     insert (const std::string& name, bool force_add = false)
     {
       table_iterator p = m_symbols.find (name);
 
       if (p == m_symbols.end ())
         {
-          symbol_table::symbol_record ret (m_scope, name);
+          symbol_table::symbol_record ret (this, name);
 
           if (m_is_nested && m_parent && m_parent->look_nonlocal (name, ret))
             return m_symbols[name] = ret;
           else
             {
               if (m_is_static && ! force_add)
                 ret.mark_added_static ();
 
@@ -2334,43 +2073,58 @@ public:
           symbol_table::symbol_record& sr = insert (name, force_add);
 
           sr.assign (value, context);
         }
       else
         p->second.assign (value, context);
     }
 
+    void assign (const std::string& name, const octave_value& value,
+                 context_id context)
+    {
+      table_iterator p = m_symbols.find (name);
+
+      if (p == m_symbols.end ())
+        {
+          symbol_table::symbol_record& sr = insert (name, false);
+
+          sr.assign (value, context);
+        }
+      else
+        p->second.assign (value, context);
+    }
+
     void assign (const std::string& name,
                  const octave_value& value = octave_value ())
     {
       table_iterator p = m_symbols.find (name);
 
       if (p == m_symbols.end ())
         {
           symbol_table::symbol_record& sr = insert (name, false);
 
-          sr.assign (value);
+          sr.assign (value, m_context);
         }
       else
-        p->second.assign (value);
+        p->second.assign (value, m_context);
     }
 
     void force_assign (const std::string& name, const octave_value& value)
     {
       table_iterator p = m_symbols.find (name);
 
       if (p == m_symbols.end ())
         {
           symbol_table::symbol_record& sr = insert (name, true);
 
-          sr.assign (value);
+          sr.assign (value, m_context);
         }
       else
-        p->second.assign (value);
+        p->second.assign (value, m_context);
     }
 
     // Use assign (name, value, context, force_add) instead.
     // Delete when deprecated varref functions are removed.
     octave_value&
     varref (const std::string& name, context_id context, bool force_add)
     {
       table_iterator p = m_symbols.find (name);
@@ -2392,17 +2146,18 @@ public:
       return (p != m_symbols.end ()
               ? p->second.varval (context) : octave_value ());
     }
 
     octave_value varval (const std::string& name) const
     {
       table_const_iterator p = m_symbols.find (name);
 
-      return p != m_symbols.end () ? p->second.varval () : octave_value ();
+      return (p != m_symbols.end ()
+              ? p->second.varval (m_context) : octave_value ());
     }
 
     void persistent_assign (const std::string& name, const octave_value& value)
     {
       m_persistent_symbols_iterator p = m_persistent_symbols.find (name);
 
       if (p == m_persistent_symbols.end ())
         m_persistent_symbols[name] = value;
@@ -2440,98 +2195,98 @@ public:
       bool retval = false;
 
       table_const_iterator p = m_symbols.find (name);
 
       if (p != m_symbols.end ())
         {
           const symbol_table::symbol_record& sr = p->second;
 
-          retval = sr.is_variable ();
+          retval = sr.is_variable (m_context);
         }
 
       return retval;
     }
 
     void push_context (void)
     {
       for (auto& nm_sr : m_symbols)
-        nm_sr.second.push_context (m_scope);
+        nm_sr.second.push_context (this);
     }
 
     void pop_context (void)
     {
       table_iterator tbl_it = m_symbols.begin ();
 
       while (tbl_it != m_symbols.end ())
         {
-          if (tbl_it->second.pop_context (m_scope) == 0)
+          if (tbl_it->second.pop_context (this) == 0)
             m_symbols.erase (tbl_it++);
           else
             tbl_it++;
         }
     }
 
     void clear_variables (void)
     {
       for (auto& nm_sr : m_symbols)
-        nm_sr.second.clear (m_scope);
+        nm_sr.second.clear ();
     }
 
     void clear_objects (void)
     {
       for (auto& nm_sr : m_symbols)
         {
           symbol_table::symbol_record& sr = nm_sr.second;
-          octave_value val = sr.varval ();
+          octave_value val = sr.varval (m_context);
           if (val.is_object ())
-            nm_sr.second.clear (m_scope);
+            nm_sr.second.clear ();
         }
     }
 
     void clear_global (const std::string& name);
 
     void clear_variable (const std::string& name)
     {
       table_iterator p = m_symbols.find (name);
 
       if (p != m_symbols.end ())
-        p->second.clear (m_scope);
+        p->second.clear ();
     }
 
     void clear_global_pattern (const std::string& pat);
 
     void clear_variable_pattern (const std::string& pat)
     {
       glob_match pattern (pat);
 
       for (auto& nm_sr : m_symbols)
         {
           symbol_table::symbol_record& sr = nm_sr.second;
 
-          if (sr.is_defined () || sr.is_global ())
+          if (sr.is_defined (m_context) || sr.is_global ())
             {
               if (pattern.match (sr.name ()))
-                sr.clear (m_scope);
+                sr.clear (this);
             }
         }
     }
 
     void clear_variable_regexp (const std::string& pat)
     {
       octave::regexp pattern (pat);
 
       for (auto& nm_sr : m_symbols)
         {
           symbol_table::symbol_record& sr = nm_sr.second;
 
-          if (sr.is_defined () || sr.is_global ())
+          if (sr.is_defined (m_context) || sr.is_global ())
             {
               if (pattern.is_match (sr.name ()))
-                sr.clear (m_scope);
+                sr.clear (this);
             }
         }
     }
 
     void mark_automatic (const std::string& name)
     {
       insert (name).mark_automatic ();
     }
@@ -2574,17 +2329,17 @@ public:
       glob_match pat (pattern);
 
       for (const auto& nm_sr : m_symbols)
         {
           if (pat.match (nm_sr.first))
             {
               const symbol_table::symbol_record& sr = nm_sr.second;
 
-              if (vars_only && ! sr.is_variable ())
+              if (vars_only && ! sr.is_variable (m_context))
                 continue;
 
               retval.push_back (sr);
             }
         }
 
       return retval;
     }
@@ -2597,48 +2352,48 @@ public:
       octave::regexp pat (pattern);
 
       for (const auto& nm_sr : m_symbols)
         {
           if (pat.is_match (nm_sr.first))
             {
               const symbol_table::symbol_record& sr = nm_sr.second;
 
-              if (vars_only && ! sr.is_variable ())
+              if (vars_only && ! sr.is_variable (m_context))
                 continue;
 
               retval.push_back (sr);
             }
         }
 
       return retval;
     }
 
     std::list<std::string> variable_names (void)
     {
       std::list<std::string> retval;
 
       for (const auto& nm_sr : m_symbols)
         {
-          if (nm_sr.second.is_variable ())
+          if (nm_sr.second.is_variable (m_context))
             retval.push_back (nm_sr.first);
         }
 
       retval.sort ();
 
       return retval;
     }
 
     bool is_local_variable (const std::string& name) const
     {
       table_const_iterator p = m_symbols.find (name);
 
       return (p != m_symbols.end ()
               && ! p->second.is_global ()
-              && p->second.is_defined ());
+              && p->second.is_defined (m_context));
     }
 
     bool is_global (const std::string& name) const
     {
       table_const_iterator p = m_symbols.find (name);
 
       return p != m_symbols.end () && p->second.is_global ();
     }
@@ -2706,19 +2461,16 @@ public:
           return true;
         }
 
       return false;
     }
 
   private:
 
-    // The ID for this scope.
-    scope_id m_scope;
-
     // Name for this scope (usually the corresponding filename of the
     // function corresponding to the scope).
     std::string m_name;
 
     // Map from symbol names to symbol info.
     std::map<std::string, symbol_table::symbol_record> m_symbols;
 
     // Child nested functions.
@@ -2736,42 +2488,35 @@ public:
     // If true, then this scope belongs to a nested function.
     bool m_is_nested;
 
     // If true then no variables can be added.
     bool m_is_static;
 
     // Map from names of persistent variables to values.
     std::map<std::string, octave_value> m_persistent_symbols;
+
+    context_id m_context;
   };
 
 private:
 
   typedef std::map<std::string, octave_value>::const_iterator
     global_symbols_const_iterator;
   typedef std::map<std::string, octave_value>::iterator
     global_symbols_iterator;
 
-  typedef std::map<scope_id, scope*>::const_iterator all_scopes_const_iterator;
-  typedef std::map<scope_id, scope*>::iterator
-    all_scopes_iterator;
-
   typedef std::map<std::string, fcn_info>::const_iterator
     fcn_table_const_iterator;
   typedef std::map<std::string, fcn_info>::iterator
     fcn_table_iterator;
 
-  scope_id_cache m_scope_id_cache;
-
   // Map from names of global variables to values.
   std::map<std::string, octave_value> m_global_symbols;
 
-  // Map from scope id to symbol table scopes.
-  std::map<scope_id, scope*> m_all_scopes;
-
   // Map from function names to function info (private
   // functions, class constructors, class methods, etc.)
   // Note that subfunctions are defined in the scope that contains
   // them.
   std::map<std::string, fcn_info> m_fcn_table;
 
   // Map from class names to set of classes that have lower
   // precedence.
@@ -2785,25 +2530,20 @@ private:
   // Map from class names to parent class names.
   std::map<std::string, std::list<std::string>> m_parent_map;
 
   typedef std::map<std::string, std::list<std::string>>::const_iterator
     const_parent_map_iterator;
   typedef std::map<std::string, std::list<std::string>>::iterator
     parent_map_iterator;
 
-  scope_id m_current_scope;
-
-  static const scope_id xglobal_scope = 0;
-  static const scope_id xtop_scope = 1;
-
-  static const context_id xdefault_context
-    = std::numeric_limits<context_id>::max ();
-
-  static context_id xcurrent_context;
+  scope *m_global_scope;
+  scope *m_top_scope;
+
+  scope *m_current_scope;
 
   fcn_info * get_fcn_info (const std::string& name)
   {
     fcn_table_iterator p = m_fcn_table.find (name);
     return p != m_fcn_table.end () ? &p->second : 0;
   }
 };
 
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -1178,23 +1178,30 @@ symbol_info_list
 {
 private:
   struct symbol_info
   {
     symbol_info (const symbol_table::symbol_record& sr,
                  const std::string& expr_str = "",
                  const octave_value& expr_val = octave_value ())
       : name (expr_str.empty () ? sr.name () : expr_str),
-        varval (expr_val.is_undefined () ? sr.varval () : expr_val),
+        varval (),
         is_automatic (sr.is_automatic ()),
         is_complex (varval.iscomplex ()),
         is_formal (sr.is_formal ()),
         is_global (sr.is_global ()),
         is_persistent (sr.is_persistent ())
-    { }
+    {
+      symbol_table& symtab = octave::__get_symbol_table__ ("symbol_info");
+
+      varval = (expr_val.is_undefined ()
+                ? sr.varval (symtab.current_context ()) : expr_val);
+
+      is_complex = varval.is_complex_type ();
+    }
 
     void display_line (std::ostream& os,
                        const std::list<whos_parameter>& params) const
     {
       std::string dims_str = get_dims_str (varval);
 
       std::list<whos_parameter>::const_iterator i = params.begin ();
 
@@ -1690,22 +1697,21 @@ do_who (octave::interpreter& interp, int
             error ("whos: -file argument must be followed by a filename");
 
           std::string nm = argv[i + 1];
 
           octave::unwind_protect frame;
 
           // Set up temporary scope.
 
-          symbol_table::scope_id tmp_scope = symtab.alloc_scope ();
-          frame.add_method (symtab, &symbol_table::erase_scope, tmp_scope);
-
-          symtab.set_scope (tmp_scope);
-
-          cs.push (tmp_scope, 0);
+          symbol_table::scope tmp_scope;
+
+          symtab.set_scope (&tmp_scope);
+
+          cs.push (&tmp_scope, 0);
           frame.add_method (cs, &octave::call_stack::pop);
 
           frame.add_method (symtab, &symbol_table::clear_variables);
 
           octave::feval ("load", octave_value (nm), 0);
 
           std::string newmsg = std::string ("Variables in the file ")
                                + nm + ":\n\n";
@@ -1749,17 +1755,17 @@ do_who (octave::interpreter& interp, int
       if (have_regexp)
         {
           std::list<symbol_table::symbol_record> tmp = global_only
             ? symtab.regexp_global_variables (pat)
             : symtab.regexp_variables (pat);
 
           for (const auto& symrec : tmp)
             {
-              if (symrec.is_variable ())
+              if (symrec.is_variable (symtab.current_context ()))
                 {
                   if (verbose)
                     symbol_stats.append (symrec);
                   else
                     symbol_names.push_back (symrec.name ());
                 }
             }
         }
@@ -1800,17 +1806,17 @@ do_who (octave::interpreter& interp, int
           else
             {
               std::list<symbol_table::symbol_record> tmp = global_only
                 ? symtab.glob_global_variables (pat)
                 : symtab.glob_variables (pat);
 
               for (const auto& symrec : tmp)
                 {
-                  if (symrec.is_variable ())
+                  if (symrec.is_variable (symtab.current_context ()))
                     {
                       if (verbose)
                         symbol_stats.append (symrec);
                       else
                         symbol_names.push_back (symrec.name ());
                     }
                 }
             }
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -429,25 +429,24 @@ octave_fcn_handle::load_ascii (std::istr
       octave::unwind_protect_safe frame;
 
       // Set up temporary scope to use for evaluating the text that
       // defines the anonymous function.
 
       symbol_table& symtab
         = octave::__get_symbol_table__ ("octave_fcn_handle::load_ascii");
 
-      symbol_table::scope_id local_scope = symtab.alloc_scope ();
-      frame.add_method (symtab, &symbol_table::erase_scope, local_scope);
+      symbol_table::scope local_scope;
 
-      symtab.set_scope (local_scope);
+      symtab.set_scope (&local_scope);
 
       octave::call_stack& cs
         = octave::__get_call_stack__ ("octave_fcn_handle::load_ascii");
 
-      cs.push (local_scope, 0);
+      cs.push (&local_scope, 0);
       frame.add_method (cs, &octave::call_stack::pop);
 
       octave_idx_type len = 0;
 
       if (extract_keyword (is, "length", len, true) && len >= 0)
         {
           if (len > 0)
             {
@@ -457,17 +456,17 @@ octave_fcn_handle::load_ascii (std::istr
                   bool dummy;
 
                   std::string name
                     = read_text_data (is, "", dummy, t2, i);
 
                   if (! is)
                     error ("load: failed to load anonymous function handle");
 
-                  symtab.assign (name, t2, local_scope, 0);
+                  local_scope.assign (name, t2, 0);
                 }
             }
         }
       else
         {
           is.seekg (pos);
           is.clear ();
         }
@@ -621,25 +620,24 @@ octave_fcn_handle::load_binary (std::ist
       octave::unwind_protect_safe frame;
 
       // Set up temporary scope to use for evaluating the text that
       // defines the anonymous function.
 
       symbol_table& symtab
         = octave::__get_symbol_table__ ("octave_fcn_handle::load_binary");
 
-      symbol_table::scope_id local_scope = symtab.alloc_scope ();
-      frame.add_method (symtab, &symbol_table::erase_scope, local_scope);
+      symbol_table::scope local_scope;
 
-      symtab.set_scope (local_scope);
+      symtab.set_scope (&local_scope);
 
       octave::call_stack& cs
         = octave::__get_call_stack__ ("octave_fcn_handle::load_binary");
 
-      cs.push (local_scope, 0);
+      cs.push (&local_scope, 0);
       frame.add_method (cs, &octave::call_stack::pop);
 
       if (len > 0)
         {
           for (octave_idx_type i = 0; i < len; i++)
             {
               octave_value t2;
               bool dummy;
@@ -647,17 +645,17 @@ octave_fcn_handle::load_binary (std::ist
 
               std::string name =
                 read_binary_data (is, swap, fmt, "",
                                   dummy, t2, doc);
 
               if (! is)
                 error ("load: failed to load anonymous function handle");
 
-              symtab.assign (name, t2, local_scope);
+              local_scope.force_assign (name, t2);
             }
         }
 
       if (is && success)
         {
           int parse_status;
           octave_value anon_fcn_handle
             = octave::eval_string (ctmp2, true, parse_status);
@@ -1146,25 +1144,24 @@ octave_fcn_handle::load_hdf5 (octave_hdf
       octave::unwind_protect_safe frame;
 
       // Set up temporary scope to use for evaluating the text that
       // defines the anonymous function.
 
       symbol_table& symtab
         = octave::__get_symbol_table__ ("octave_fcn_handle::load_hdf5");
 
-      symbol_table::scope_id local_scope = symtab.alloc_scope ();
-      frame.add_method (symtab, &symbol_table::erase_scope, local_scope);
+      symbol_table::scope local_scope;
 
-      symtab.set_scope (local_scope);
+      symtab.set_scope (&local_scope);
 
       octave::call_stack& cs
         = octave::__get_call_stack__ ("octave_fcn_handle::load_hdf5");
 
-      cs.push (local_scope, 0);
+      cs.push (&local_scope, 0);
       frame.add_method (cs, &octave::call_stack::pop);
 
       if (len > 0 && success)
         {
           hsize_t num_obj = 0;
 #if defined (HAVE_HDF5_18)
           data_hid = H5Gopen (group_hid, "symbol table", octave_H5P_DEFAULT);
 #else
@@ -1179,17 +1176,17 @@ octave_fcn_handle::load_hdf5 (octave_hdf
           hdf5_callback_data dsub;
           int current_item = 0;
           for (octave_idx_type i = 0; i < len; i++)
             {
               if (hdf5_h5g_iterate (group_hid, "symbol table", &current_item,
                                     &dsub) <= 0)
                 error ("load: failed to load anonymous function handle");
 
-              symtab.assign (dsub.name, dsub.tc, local_scope);
+              local_scope.force_assign (dsub.name, dsub.tc);
             }
         }
 
       if (success)
         {
           int parse_status;
           octave_value anon_fcn_handle
             = octave::eval_string (fcn_tmp, true, parse_status);
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -99,20 +99,20 @@ octave_fcn_inline::octave_fcn_inline (co
             {
               octave::call_stack& cs
                 = octave::__get_call_stack__ ("octave_fcn_inline");
 
               octave_function *curr_fcn = cs.current ();
 
               if (curr_fcn)
                 {
-                  symbol_table::scope_id parent_scope
+                  symbol_table::scope *parent_scope
                     = curr_fcn->parent_fcn_scope ();
 
-                  if (parent_scope < 0)
+                  if (! parent_scope)
                     parent_scope = curr_fcn->scope ();
 
                   uf->stash_parent_fcn_scope (parent_scope);
                 }
             }
         }
     }
 
diff --git a/libinterp/octave-value/ov-fcn.h b/libinterp/octave-value/ov-fcn.h
--- a/libinterp/octave-value/ov-fcn.h
+++ b/libinterp/octave-value/ov-fcn.h
@@ -75,21 +75,21 @@ public:
 
   virtual std::string src_file_name (void) const { return ""; }
 
   // The name to show in the profiler (also used as map-key).
   virtual std::string profiler_name (void) const { return name (); }
 
   virtual std::string parent_fcn_name (void) const { return ""; }
 
-  virtual symbol_table::scope_id parent_fcn_scope (void) const { return -1; }
+  virtual symbol_table::scope *parent_fcn_scope (void) const { return 0; }
 
   virtual void mark_fcn_file_up_to_date (const octave::sys::time&) { }
 
-  virtual symbol_table::scope_id scope (void) { return -1; }
+  virtual symbol_table::scope *scope (void) { return 0; }
 
   virtual octave::sys::time time_parsed (void) const
   { return octave::sys::time (static_cast<time_t> (0)); }
 
   virtual octave::sys::time time_checked (void) const
   { return octave::sys::time (static_cast<time_t> (0)); }
 
   virtual bool is_subfunction (void) const { return false; }
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -171,62 +171,49 @@ octave_user_script::accept (octave::tree
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_user_function,
                                      "user-defined function",
                                      "user-defined function");
 
 // Ugh.  This really needs to be simplified (code/data?
 // extrinsic/intrinsic state?).
 
 octave_user_function::octave_user_function
-  (symbol_table::scope_id sid, octave::tree_parameter_list *pl,
+  (symbol_table::scope *scope, octave::tree_parameter_list *pl,
    octave::tree_parameter_list *rl, octave::tree_statement_list *cl)
-  : octave_user_code ("", ""), m_scope (0),
+  : octave_user_code ("", ""), m_scope (scope),
     param_list (pl), ret_list (rl), cmd_list (cl),
     lead_comm (), trail_comm (), file_name (),
     location_line (0), location_column (0),
     parent_name (), t_parsed (static_cast<time_t> (0)),
     t_checked (static_cast<time_t> (0)),
     system_fcn_file (false), call_depth (-1),
     num_named_args (param_list ? param_list->length () : 0),
     subfunction (false), inline_function (false),
     anonymous_function (false), nested_function (false),
     class_constructor (none), class_method (false),
-    parent_scope (-1), local_scope (sid),
-    curr_unwind_protect_frame (0)
+    parent_scope (0), curr_unwind_protect_frame (0)
 #if defined (HAVE_LLVM)
     , jit_info (0)
 #endif
 {
   if (cmd_list)
     cmd_list->mark_as_function_body ();
 
-  if (local_scope >= 0)
-    {
-      symbol_table& symtab = octave::__get_symbol_table__ ("octave_user_function");
-
-      symtab.set_curr_fcn (this, local_scope);
-
-      m_scope = symtab.get_scope (local_scope);
-    }
+  if (m_scope)
+    m_scope->set_function (this);
 }
 
 octave_user_function::~octave_user_function (void)
 {
   // FIXME: shouldn't this happen automatically when deleting cmd_list?
   if (cmd_list)
     cmd_list->remove_all_breakpoints (file_name);
 
   delete m_scope;
 
-  // FIXME: there needs to be a better way...
-  symbol_table& symtab
-    = octave::__get_symbol_table__ ("~octave_user_function");
-
-  symtab.erase_scope (local_scope);
-
   delete param_list;
   delete ret_list;
   delete cmd_list;
   delete lead_comm;
   delete trail_comm;
 
 #if defined (HAVE_LLVM)
   delete jit_info;
@@ -306,17 +293,17 @@ octave_user_function::maybe_relocate_end
             f->maybe_relocate_end_internal ();
         }
     }
 
   maybe_relocate_end_internal ();
 }
 
 void
-octave_user_function::stash_parent_fcn_scope (symbol_table::scope_id ps)
+octave_user_function::stash_parent_fcn_scope (symbol_table::scope *ps)
 {
   parent_scope = ps;
 }
 
 std::string
 octave_user_function::profiler_name (void) const
 {
   std::ostringstream result;
@@ -470,38 +457,49 @@ octave_user_function::call (octave::tree
   call_depth++;
 
   if (call_depth >= Vmax_recursion_depth)
     error ("max_recursion_depth exceeded");
 
   // Save old and set current symbol table context, for
   // eval_undefined_error().
 
-  int context = active_context ();
-
   octave::call_stack& cs
     = octave::__get_call_stack__ ("octave_user_function::call");
 
-  cs.push (this, local_scope, context);
+  symbol_table::context_id context = anonymous_function ? 0 : call_depth;
+  cs.push (this, m_scope, context);
 
   frame.protect_var (Vtrack_line_num);
   Vtrack_line_num = true;    // update source line numbers, even if debugging
   frame.add_method (cs, &octave::call_stack::pop);
 
   if (call_depth > 0 && ! is_anonymous_function ())
     {
       m_scope->push_context ();
 
+#if 0
+      std::cerr << name () << " scope: " << m_scope
+                << " call depth: " << call_depth
+                << " context: " << m_scope->current_context () << std::endl;
+#endif
+
       frame.add_method (m_scope, &symbol_table::scope::pop_context);
     }
 
   string_vector arg_names = args.name_tags ();
 
   if (param_list && ! param_list->varargs_only ())
-    tw.define_parameter_list_from_arg_vector (param_list, args);
+    {
+#if 0
+      std::cerr << "defining param list, scope: " << m_scope
+                << ", context: " << m_scope->current_context () << std::endl;
+#endif
+      tw.define_parameter_list_from_arg_vector (param_list, args);
+    }
 
   // For classdef constructor, pre-populate the output arguments
   // with the pre-initialized object instance, extracted above.
 
   if (is_classdef_constructor ())
     {
       if (! ret_list)
         error ("%s: invalid classdef constructor, no output argument defined",
@@ -652,17 +650,17 @@ octave_user_function::subsasgn_optimizat
 
 #if 0
 void
 octave_user_function::print_symtab_info (std::ostream& os) const
 {
   symbol_table& symtab
     = octave::__get_symbol_table__ ("octave_user_function::print_symtab_info");
 
-  symtab.print_info (os, local_scope);
+  symtab.print_info (os, m_scope);
 }
 #endif
 
 void
 octave_user_function::print_code_function_header (void)
 {
   octave::tree_print_code tpc (octave_stdout, VPS4);
 
diff --git a/libinterp/octave-value/ov-usr-fcn.h b/libinterp/octave-value/ov-usr-fcn.h
--- a/libinterp/octave-value/ov-usr-fcn.h
+++ b/libinterp/octave-value/ov-usr-fcn.h
@@ -164,17 +164,17 @@ private:
 
 // User-defined functions.
 
 class
 octave_user_function : public octave_user_code
 {
 public:
 
-  octave_user_function (symbol_table::scope_id sid = -1,
+  octave_user_function (symbol_table::scope *scope = nullptr,
                         octave::tree_parameter_list *pl = nullptr,
                         octave::tree_parameter_list *rl = nullptr,
                         octave::tree_statement_list *cl = nullptr);
 
   // No copying!
 
   octave_user_function (const octave_user_function& fn) = delete;
 
@@ -217,17 +217,17 @@ public:
 
   int ending_line (void) const { return end_location_line; }
   int ending_column (void) const { return end_location_column; }
 
   void maybe_relocate_end (void);
 
   void stash_parent_fcn_name (const std::string& p) { parent_name = p; }
 
-  void stash_parent_fcn_scope (symbol_table::scope_id ps);
+  void stash_parent_fcn_scope (symbol_table::scope *ps);
 
   void stash_leading_comment (octave_comment_list *lc) { lead_comm = lc; }
 
   void stash_trailing_comment (octave_comment_list *tc) { trail_comm = tc; }
 
   void mark_fcn_file_up_to_date (const octave::sys::time& t) { t_checked = t; }
 
   void stash_fcn_file_time (const octave::sys::time& t)
@@ -237,19 +237,19 @@ public:
   }
 
   std::string fcn_file_name (void) const { return file_name; }
 
   std::string profiler_name (void) const;
 
   std::string parent_fcn_name (void) const { return parent_name; }
 
-  symbol_table::scope_id parent_fcn_scope (void) const { return parent_scope; }
+  symbol_table::scope *parent_fcn_scope (void) const { return parent_scope; }
 
-  symbol_table::scope_id scope (void) { return local_scope; }
+  symbol_table::scope *scope (void) { return m_scope; }
 
   octave::sys::time time_parsed (void) const { return t_parsed; }
 
   octave::sys::time time_checked (void) const { return t_checked; }
 
   void mark_as_system_fcn_file (void);
 
   bool is_system_fcn_file (void) const { return system_fcn_file; }
@@ -460,19 +460,17 @@ private:
 
   // Enum describing whether this function is the constructor for class object.
   class_ctor_type class_constructor;
 
   // TRUE means this function is a method for a class.
   bool class_method;
 
   // The scope of the parent function, if any.
-  symbol_table::scope_id parent_scope;
-
-  symbol_table::scope_id local_scope;
+  symbol_table::scope *parent_scope;
 
   // pointer to the current unwind_protect frame of this function.
   octave::unwind_protect *curr_unwind_protect_frame;
 
 #if defined (HAVE_LLVM)
   jit_function_info *jit_info;
 #endif
 
diff --git a/libinterp/parse-tree/lex.h b/libinterp/parse-tree/lex.h
--- a/libinterp/parse-tree/lex.h
+++ b/libinterp/parse-tree/lex.h
@@ -55,45 +55,37 @@ namespace octave
 
     class symbol_table_context
     {
     public:
 
       symbol_table_context (void)
         : frame_stack () { }
 
-      ~symbol_table_context (void);
+      ~symbol_table_context (void) { clear (); }
 
       void clear (void);
 
       bool empty (void) const { return frame_stack.empty (); }
 
       size_t size (void) const { return frame_stack.size (); }
 
-      void pop (void)
-      {
-        if (empty ())
-          panic_impossible ();
+      void pop (void);
 
-        frame_stack.pop_front ();
-      }
-
-      void push (void);
-
-      void push (symbol_table::scope_id scope)
+      void push (symbol_table::scope *scope)
       {
         frame_stack.push_front (scope);
       }
 
-      symbol_table::scope_id curr_scope (void) const;
-      symbol_table::scope_id parent_scope (void) const;
+      symbol_table::scope *curr_scope (void) const;
+      symbol_table::scope *parent_scope (void) const;
 
     private:
 
-      std::deque<symbol_table::scope_id> frame_stack;
+      std::deque<symbol_table::scope*> frame_stack;
     };
 
     // Track nesting of square brackets, curly braces, and parentheses.
 
     class bbp_nesting_level
     {
     private:
 
@@ -591,17 +583,17 @@ namespace octave
     void xunput (char c, char *buf);
 
     void xunput (char c);
 
     bool looking_at_space (void);
 
     bool inside_any_object_index (void);
 
-    bool is_variable (const std::string& name, symbol_table::scope_id scope);
+    bool is_variable (const std::string& name, symbol_table::scope *scope);
 
     int is_keyword_token (const std::string& s);
 
     bool fq_identifier_contains_keyword (const std::string& s);
 
     bool whitespace_is_significant (void);
 
     void handle_number (void);
diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -2076,75 +2076,58 @@ debug information as it processes an exp
   retval = set_internal_variable (lexer_debug_flag, args, nargout,
                                   "__lexer_debug_flag__");
 
   return retval;
 }
 
 namespace octave
 {
-  lexical_feedback::symbol_table_context::~symbol_table_context (void)
-  {
-    clear ();
-  }
-
   void
   lexical_feedback::symbol_table_context::clear (void)
   {
-    symbol_table& symtab
-      = octave::__get_symbol_table__ ("lexical_feedback::symbol_table_context::push");
-
     while (! frame_stack.empty ())
       {
-        symbol_table::scope_id sid = curr_scope ();
-
-        if (sid > 0)
-          {
-            // FIXME: for now we need to ensure that the scope_id has a
-            // scope object associated with it.  Calling clear_variables
-            // should do that for us.  In the future, this should not be
-            // necessary.
-            symtab.clear_variables (sid);
-
-            symtab.erase_scope (sid);
-          }
+        symbol_table::scope *scope = curr_scope ();
+
+        delete scope;
 
         frame_stack.pop_front ();
       }
   }
 
   void
-  lexical_feedback::symbol_table_context::push (void)
+  lexical_feedback::symbol_table_context::pop (void)
   {
-    symbol_table& symtab
-      = octave::__get_symbol_table__ ("lexical_feedback::symbol_table_context::push");
-
-    push (symtab.current_scope ());
+    if (empty ())
+      panic_impossible ();
+
+    frame_stack.pop_front ();
   }
 
-  symbol_table::scope_id
+  symbol_table::scope *
   lexical_feedback::symbol_table_context::curr_scope (void) const
   {
     if (empty ())
       {
         symbol_table& symtab
           = octave::__get_symbol_table__ ("lexical_feedback::symbol_table_context::curr_scope");
 
         return symtab.current_scope ();
       }
     else
       return frame_stack.front ();
   }
 
-  symbol_table::scope_id
+  symbol_table::scope *
   lexical_feedback::symbol_table_context::parent_scope (void) const
   {
     size_t sz = size ();
 
-    return sz > 1 ? frame_stack[1] : (sz == 1 ? frame_stack[0] : -1);
+    return sz > 1 ? frame_stack[1] : (sz == 1 ? frame_stack[0] : 0);
   }
 
   lexical_feedback::~lexical_feedback (void)
   {
     tokens.clear ();
   }
 
   void
@@ -2536,21 +2519,19 @@ namespace octave
           }
       }
 
     return retval;
   }
 
   bool
   base_lexer::is_variable (const std::string& name,
-                           symbol_table::scope_id scope)
+                           symbol_table::scope *scope)
   {
-    symbol_table& symtab = octave::__get_symbol_table__ ("base_lexer::is_variable");
-
-    return (symtab.is_variable (name, scope)
+    return ((scope && scope->is_variable (name))
             || (pending_local_variables.find (name)
                 != pending_local_variables.end ()));
   }
 
   // Handle keywords.  Return -1 if the keyword should be ignored.
 
   int
   base_lexer::is_keyword_token (const std::string& s)
@@ -3166,33 +3147,34 @@ namespace octave
 
         // The call to is_keyword_token set at_beginning_of_statement.
 
         return kw_token;
       }
 
     // Find the token in the symbol table.
 
-    symbol_table::scope_id sid = symtab_context.curr_scope ();
-
-    symbol_table& symtab
-      = octave::__get_symbol_table__ ("base_lexer::handle_identifier");
-
-    token *tok = new token (NAME, &(symtab.insert (ident, sid)),
-                            input_line_number, current_input_column);
+    symbol_table::scope *scope = symtab_context.curr_scope ();
+
+    symbol_table::symbol_record sr
+      = (scope
+         ? scope->insert (ident)
+         : symbol_table::symbol_record (scope, ident));
+
+    token *tok = new token (NAME, sr, input_line_number, current_input_column);
 
     // The following symbols are handled specially so that things like
     //
     //   pi +1
     //
     // are parsed as an addition expression instead of as a command-style
     // function call with the argument "+1".
 
     if (at_beginning_of_statement
-        && (! (is_variable (ident, sid)
+        && (! (is_variable (ident, scope)
                || ident == "e" || ident == "pi"
                || ident == "I" || ident == "i"
                || ident == "J" || ident == "j"
                || ident == "Inf" || ident == "inf"
                || ident == "NaN" || ident == "nan")))
       tok->mark_may_be_command ();
 
     push_token (tok);
@@ -3353,21 +3335,18 @@ namespace octave
           token *tok_val = current_token ();
           std::cerr << "STRUCT_ELT [" << tok_val->text () << "]\n";
         }
         break;
 
       case NAME:
         {
           token *tok_val = current_token ();
-          symbol_table::symbol_record *sr = tok_val->sym_rec ();
-          std::cerr << "NAME";
-          if (sr)
-            std::cerr << " [" << sr->name () << "]";
-          std::cerr << "\n";
+          symbol_table::symbol_record sr = tok_val->sym_rec ();
+          std::cerr << "NAME [" << sr.name () << "]\n";
         }
         break;
 
       case END: std::cerr << "END\n"; break;
 
       case DQ_STRING:
       case SQ_STRING:
         {
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -498,18 +498,18 @@ word_list       : string
                 ;
 
 // ===========
 // Expressions
 // ===========
 
 identifier      : NAME
                   {
-                    symbol_table::symbol_record *sr = $1->sym_rec ();
-                    $$ = new octave::tree_identifier (*sr, $1->line (), $1->column ());
+                    symbol_table::symbol_record sr = $1->sym_rec ();
+                    $$ = new octave::tree_identifier (sr, $1->line (), $1->column ());
                   }
                 ;
 
 superclass_identifier
                 : SUPERCLASSREF
                   {
                     std::string method_nm = $1->superclass_method_name ();
                     std::string class_nm = $1->superclass_class_name ();
@@ -1262,18 +1262,17 @@ push_fcn_symtab : // empty
                   {
                     $$ = 0;
 
                     parser.curr_fcn_depth++;
 
                     if (parser.max_fcn_depth < parser.curr_fcn_depth)
                       parser.max_fcn_depth = parser.curr_fcn_depth;
 
-                    symbol_table& symtab = octave::__get_symbol_table__ ("push_fcn_symtab");
-                    lexer.symtab_context.push (symtab.alloc_scope ());
+                    lexer.symtab_context.push (new symbol_table::scope ());
 
                     parser.function_scopes.push (lexer.symtab_context.curr_scope ());
 
                     if (! lexer.reading_script_file
                         && parser.curr_fcn_depth == 1
                         && ! parser.parsing_subfunctions)
                       parser.primary_fcn_scope
                         = lexer.symtab_context.curr_scope ();
@@ -1293,18 +1292,17 @@ push_fcn_symtab : // empty
 
 param_list_beg  : '('
                   {
                     $$ = 0;
                     lexer.looking_at_parameter_list = true;
 
                     if (lexer.looking_at_function_handle)
                       {
-                        symbol_table& symtab = octave::__get_symbol_table__ ("push_fcn_symtab");
-                        lexer.symtab_context.push (symtab.alloc_scope ());
+                        lexer.symtab_context.push (new symbol_table::scope ());
                         lexer.looking_at_function_handle--;
                         lexer.looking_at_anon_fcn_args = true;
                       }
                   }
                 ;
 
 param_list_end  : ')'
                   {
@@ -1621,17 +1619,17 @@ classdef_beg    : CLASSDEF
                   {
                     if (! lexer.reading_classdef_file)
                       {
                         parser.bison_error ("classdef must appear inside a file containing only a class definition");
                         YYABORT;
                       }
 
                     // Create invalid parent scope.
-                    lexer.symtab_context.push (-1);
+                    lexer.symtab_context.push (0);
                     lexer.parsing_classdef = true;
                     $$ = $1;
                   }
                 ;
 
 classdef        : classdef_beg stash_comment opt_attr_list identifier opt_superclass_list opt_sep class_body opt_sep END
                   {
                     YYUSE ($6);
@@ -2073,19 +2071,19 @@ namespace octave
 
   void
   base_parser::parent_scope_info::push (const value_type& elt)
   {
     info.push_back (elt);
   }
 
   void
-  base_parser::parent_scope_info::push (symbol_table::scope_id id)
+  base_parser::parent_scope_info::push (symbol_table::scope *scope)
   {
-    push (value_type (id, ""));
+    push (value_type (scope, ""));
   }
 
   void
   base_parser::parent_scope_info::pop (void)
   {
     info.pop_back ();
   }
 
@@ -2126,17 +2124,17 @@ namespace octave
       return false;
 
     if (size () > 0)
       info.back().second = name;
 
     return true;
   }
 
-  symbol_table::scope_id
+  symbol_table::scope *
   base_parser::parent_scope_info::parent_scope (void) const
   {
     return size () > 1 ? info[size()-2].first : 0;
   }
 
   std::string
   base_parser::parent_scope_info::parent_name (void) const
   {
@@ -2148,17 +2146,17 @@ namespace octave
     info.clear ();
     all_names.clear ();
   }
 
   base_parser::base_parser (base_lexer& lxr)
     : endfunction_found (false), autoloading (false),
       fcn_file_from_relative_lookup (false),
       parsing_subfunctions (false), parsing_local_functions (false),
-      max_fcn_depth (0), curr_fcn_depth (0), primary_fcn_scope (-1),
+      max_fcn_depth (0), curr_fcn_depth (0), primary_fcn_scope (0),
       curr_class_name (), curr_package_name (), function_scopes (),
       primary_fcn_ptr (0), subfunction_names (), classdef_object (0),
       stmt_list (0), lexer (lxr), parser_state (yypstate_new ())
   { }
 
   base_parser::~base_parser (void)
   {
     delete stmt_list;
@@ -2181,17 +2179,17 @@ namespace octave
   {
     endfunction_found = false;
     autoloading = false;
     fcn_file_from_relative_lookup = false;
     parsing_subfunctions = false;
     parsing_local_functions = false;
     max_fcn_depth = 0;
     curr_fcn_depth = 0;
-    primary_fcn_scope = -1;
+    primary_fcn_scope = 0;
     curr_class_name = "";
     curr_package_name = "";
     function_scopes.clear ();
     primary_fcn_ptr  = 0;
     subfunction_names.clear ();
 
     delete stmt_list;
     stmt_list = 0;
@@ -2484,18 +2482,18 @@ namespace octave
   tree_anon_fcn_handle *
   base_parser::make_anon_fcn_handle (tree_parameter_list *param_list,
                                      tree_expression *expr)
   {
     // FIXME: need to get these from the location of the @ symbol.
     int l = lexer.input_line_number;
     int c = lexer.current_input_column;
 
-    symbol_table::scope_id fcn_scope = lexer.symtab_context.curr_scope ();
-    symbol_table::scope_id parent_scope = lexer.symtab_context.parent_scope ();
+    symbol_table::scope *fcn_scope = lexer.symtab_context.curr_scope ();
+    symbol_table::scope *parent_scope = lexer.symtab_context.parent_scope ();
 
     lexer.symtab_context.pop ();
 
     expr->set_print_flag (false);
 
     tree_anon_fcn_handle *retval
       = new tree_anon_fcn_handle (param_list, expr, fcn_scope,
                                   parent_scope, l, c);
@@ -3402,17 +3400,17 @@ namespace octave
         fcn->define_ret_list (ret_list);
 
         if (curr_fcn_depth > 1 || parsing_subfunctions)
           {
             fcn->stash_fcn_location (l, c);
 
             if (endfunction_found && function_scopes.size () > 1)
               {
-                symbol_table::scope_id pscope = function_scopes.parent_scope ();
+                symbol_table::scope *pscope = function_scopes.parent_scope ();
 
                 symtab.install_nestfunction (nm, octave_value (fcn), pscope);
               }
             else
               {
                 fcn->mark_as_subfunction ();
                 subfunction_names.push_back (nm);
 
@@ -3715,17 +3713,17 @@ namespace octave
 
         if (mname.find_first_of (".") == std::string::npos
             && mname != "delete"
             && mname != curr_class_name)
           {
             // Create a dummy function that is used until the real method
             // is loaded.
 
-            retval = new octave_user_function (-1, pl);
+            retval = new octave_user_function (0, pl);
 
             retval->stash_function_name (mname);
 
             int l = id->line ();
             int c = id->column ();
 
             retval->stash_fcn_location (l, c);
           }
@@ -4565,17 +4563,17 @@ namespace octave
 
     if (retval)
       {
         retval->stash_dir_name (dir_name);
         retval->stash_package_name (package_name);
 
         if (retval->is_user_function ())
           {
-            symbol_table::scope_id id = retval->scope ();
+            symbol_table::scope *id = retval->scope ();
 
             symbol_table& symtab = octave::__get_symbol_table__ ("load_fcn_from_file");
 
             symtab.stash_dir_name_for_subfunctions (id, dir_name);
           }
       }
 
     return retval;
diff --git a/libinterp/parse-tree/parse.h b/libinterp/parse-tree/parse.h
--- a/libinterp/parse-tree/parse.h
+++ b/libinterp/parse-tree/parse.h
@@ -96,17 +96,17 @@ namespace octave
   base_parser
   {
   private:
 
     class parent_scope_info
     {
     public:
 
-      typedef std::pair<symbol_table::scope_id, std::string> value_type;
+      typedef std::pair<symbol_table::scope*, std::string> value_type;
 
       typedef std::deque<value_type>::iterator iterator;
       typedef std::deque<value_type>::const_iterator const_iterator;
 
       typedef std::deque<value_type>::reverse_iterator reverse_iterator;
       typedef std::deque<value_type>::const_reverse_iterator const_reverse_iterator;
 
       parent_scope_info (void) = default;
@@ -116,25 +116,25 @@ namespace octave
       parent_scope_info& operator = (const parent_scope_info&) = default;
 
       ~parent_scope_info (void) = default;
 
       size_t size (void) const;
 
       void push (const value_type& elt);
 
-      void push (symbol_table::scope_id id);
+      void push (symbol_table::scope *id);
 
       void pop (void);
 
       bool name_ok (const std::string& name);
 
       bool name_current_scope (const std::string& name);
 
-      symbol_table::scope_id parent_scope (void) const;
+      symbol_table::scope *parent_scope (void) const;
 
       std::string parent_name (void) const;
 
       void clear (void);
 
     private:
 
       std::deque<value_type> info;
@@ -427,17 +427,17 @@ namespace octave
     // = 1 inside the primary function or a subfunction.
     // > 1 means we are looking at a function definition that seems to be
     //     inside a function.  Note that the function still might not be a
     //     nested function.
     int curr_fcn_depth;
 
     // Scope where we install all subfunctions and nested functions.  Only
     // used while reading function files.
-    symbol_table::scope_id primary_fcn_scope;
+    symbol_table::scope *primary_fcn_scope;
 
     // Name of the current class when we are parsing class methods or
     // constructors.
     std::string curr_class_name;
 
     // Name of the current package when we are parsing an element contained
     // in a package directory (+-directory).
     std::string curr_package_name;
diff --git a/libinterp/parse-tree/pt-arg-list.cc b/libinterp/parse-tree/pt-arg-list.cc
--- a/libinterp/parse-tree/pt-arg-list.cc
+++ b/libinterp/parse-tree/pt-arg-list.cc
@@ -298,22 +298,21 @@ namespace octave
             retval.push_back (idx_expr->name ());
           }
       }
 
     return retval;
   }
 
   tree_argument_list *
-  tree_argument_list::dup (symbol_table::scope_id scope,
-                           symbol_table::context_id context) const
+  tree_argument_list::dup (symbol_table::scope& scope) const
   {
     tree_argument_list *new_list = new tree_argument_list ();
 
     new_list->list_includes_magic_end = list_includes_magic_end;
     new_list->simple_assign_lhs = simple_assign_lhs;
 
     for (const tree_expression *elt : *this)
-      new_list->append (elt ? elt->dup (scope, context) : 0);
+      new_list->append (elt ? elt->dup (scope) : 0);
 
     return new_list;
   }
 }
diff --git a/libinterp/parse-tree/pt-arg-list.h b/libinterp/parse-tree/pt-arg-list.h
--- a/libinterp/parse-tree/pt-arg-list.h
+++ b/libinterp/parse-tree/pt-arg-list.h
@@ -91,18 +91,17 @@ namespace octave
 
     octave_value_list convert_to_const_vector (tree_evaluator *tw,
                                                const octave_value *object = nullptr);
 
     string_vector get_arg_names (void) const;
 
     std::list<std::string> variable_names (void) const;
 
-    tree_argument_list * dup (symbol_table::scope_id scope,
-                              symbol_table::context_id context) const;
+    tree_argument_list * dup (symbol_table::scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_argument_list (*this);
     }
 
   private:
 
diff --git a/libinterp/parse-tree/pt-array-list.cc b/libinterp/parse-tree/pt-array-list.cc
--- a/libinterp/parse-tree/pt-array-list.cc
+++ b/libinterp/parse-tree/pt-array-list.cc
@@ -72,28 +72,26 @@ namespace octave
   void
   tree_array_list::copy_base (const tree_array_list& array_list)
   {
     tree_expression::copy_base (array_list);
   }
 
   void
   tree_array_list::copy_base (const tree_array_list& array_list,
-                              symbol_table::scope_id scope,
-                              symbol_table::context_id context)
+                              symbol_table::scope& scope)
   {
     for (const tree_argument_list *elt : array_list)
-      append (elt ? elt->dup (scope, context) : 0);
+      append (elt ? elt->dup (scope) : 0);
 
     copy_base (*this);
   }
 
   tree_expression *
-  tree_array_list::dup (symbol_table::scope_id,
-                        symbol_table::context_id) const
+  tree_array_list::dup (symbol_table::scope&) const
   {
     panic_impossible ();
     return 0;
   }
 
   void
   tree_array_list::accept (tree_walker&)
   {
diff --git a/libinterp/parse-tree/pt-array-list.h b/libinterp/parse-tree/pt-array-list.h
--- a/libinterp/parse-tree/pt-array-list.h
+++ b/libinterp/parse-tree/pt-array-list.h
@@ -72,21 +72,19 @@ namespace octave
     // have to do this?  Without the using declaration or a name change,
     // the base class functions will be hidden.  That may be OK, but it
     // can also cause some confusion.
     using tree_expression::copy_base;
 
     void copy_base (const tree_array_list& array_list);
 
     void copy_base (const tree_array_list& array_list,
-                    symbol_table::scope_id scope,
-                    symbol_table::context_id context);
+                    symbol_table::scope& scope);
 
-    tree_expression * dup (symbol_table::scope_id scope,
-                           symbol_table::context_id context) const;
+    tree_expression * dup (symbol_table::scope& scope) const;
 
     void accept (tree_walker& tw);
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED ("use 'octave::tree_array_list' instead")
diff --git a/libinterp/parse-tree/pt-assign.cc b/libinterp/parse-tree/pt-assign.cc
--- a/libinterp/parse-tree/pt-assign.cc
+++ b/libinterp/parse-tree/pt-assign.cc
@@ -63,27 +63,20 @@ namespace octave
 
   std::string
   tree_simple_assignment::oper (void) const
   {
     return octave_value::assign_op_as_string (etype);
   }
 
   tree_expression *
-  tree_simple_assignment::dup (symbol_table::scope_id scope,
-                               symbol_table::context_id context) const
+  tree_simple_assignment::dup (symbol_table::scope&) const
   {
-    tree_simple_assignment *new_sa
-      = new tree_simple_assignment (lhs ? lhs->dup (scope, context) : 0,
-                                    rhs ? rhs->dup (scope, context) : 0,
-                                    preserve, etype);
-
-    new_sa->copy_base (*this);
-
-    return new_sa;
+    panic_impossible ();
+    return 0;
   }
 
   // Multi-valued assignment expressions.
 
   tree_multi_assignment::tree_multi_assignment
   (tree_argument_list *lst, tree_expression *r,
    bool plhs, int l, int c)
     : tree_expression (l, c), lhs (lst), rhs (r), preserve (plhs)
@@ -99,27 +92,20 @@ namespace octave
 
   std::string
   tree_multi_assignment::oper (void) const
   {
     return octave_value::assign_op_as_string (op_type ());
   }
 
   tree_expression *
-  tree_multi_assignment::dup (symbol_table::scope_id scope,
-                              symbol_table::context_id context) const
+  tree_multi_assignment::dup (symbol_table::scope&) const
   {
-    tree_multi_assignment *new_ma
-      = new tree_multi_assignment (lhs ? lhs->dup (scope, context) : 0,
-                                   rhs ? rhs->dup (scope, context) : 0,
-                                   preserve);
-
-    new_ma->copy_base (*this);
-
-    return new_ma;
+    panic_impossible ();
+    return 0;
   }
 }
 
 /*
 %!function varargout = f ()
 %!  varargout{1} = nargout;
 %!endfunction
 %!
diff --git a/libinterp/parse-tree/pt-assign.h b/libinterp/parse-tree/pt-assign.h
--- a/libinterp/parse-tree/pt-assign.h
+++ b/libinterp/parse-tree/pt-assign.h
@@ -71,18 +71,17 @@ namespace octave
     bool is_assignment_expression (void) const { return true; }
 
     std::string oper (void) const;
 
     tree_expression * left_hand_side (void) { return lhs; }
 
     tree_expression * right_hand_side (void) { return rhs; }
 
-    tree_expression * dup (symbol_table::scope_id scope,
-                           symbol_table::context_id context) const;
+    tree_expression * dup (symbol_table::scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_simple_assignment (*this);
     }
 
     octave_value::assign_op op_type (void) const { return etype; }
 
@@ -136,18 +135,17 @@ namespace octave
     bool rvalue_ok (void) const { return true; }
 
     std::string oper (void) const;
 
     tree_argument_list * left_hand_side (void) { return lhs; }
 
     tree_expression * right_hand_side (void) { return rhs; }
 
-    tree_expression * dup (symbol_table::scope_id scope,
-                           symbol_table::context_id context) const;
+    tree_expression * dup (symbol_table::scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_multi_assignment (*this);
     }
 
     octave_value::assign_op op_type (void) const
     { return octave_value::op_asn_eq; }
diff --git a/libinterp/parse-tree/pt-binop.cc b/libinterp/parse-tree/pt-binop.cc
--- a/libinterp/parse-tree/pt-binop.cc
+++ b/libinterp/parse-tree/pt-binop.cc
@@ -50,22 +50,21 @@ namespace octave
 
   std::string
   tree_binary_expression::oper (void) const
   {
     return octave_value::binary_op_as_string (etype);
   }
 
   tree_expression *
-  tree_binary_expression::dup (symbol_table::scope_id scope,
-                               symbol_table::context_id context) const
+  tree_binary_expression::dup (symbol_table::scope& scope) const
   {
     tree_binary_expression *new_be
-      = new tree_binary_expression (op_lhs ? op_lhs->dup (scope, context) : 0,
-                                    op_rhs ? op_rhs->dup (scope, context) : 0,
+      = new tree_binary_expression (op_lhs ? op_lhs->dup (scope) : 0,
+                                    op_rhs ? op_rhs->dup (scope) : 0,
                                     line (), column (), etype);
 
     new_be->copy_base (*this);
 
     return new_be;
   }
 
   // Boolean expressions.
@@ -88,21 +87,20 @@ namespace octave
       default:
         break;
       }
 
     return retval;
   }
 
   tree_expression *
-  tree_boolean_expression::dup (symbol_table::scope_id scope,
-                                symbol_table::context_id context) const
+  tree_boolean_expression::dup (symbol_table::scope& scope) const
   {
     tree_boolean_expression *new_be
-      = new tree_boolean_expression (op_lhs ? op_lhs->dup (scope, context) : 0,
-                                     op_rhs ? op_rhs->dup (scope, context) : 0,
+      = new tree_boolean_expression (op_lhs ? op_lhs->dup (scope) : 0,
+                                     op_rhs ? op_rhs->dup (scope) : 0,
                                      line (), column (), etype);
 
     new_be->copy_base (*this);
 
     return new_be;
   }
 }
diff --git a/libinterp/parse-tree/pt-binop.h b/libinterp/parse-tree/pt-binop.h
--- a/libinterp/parse-tree/pt-binop.h
+++ b/libinterp/parse-tree/pt-binop.h
@@ -98,18 +98,17 @@ namespace octave
     tree_expression * lhs (void) { return op_lhs; }
     tree_expression * rhs (void) { return op_rhs; }
 
     bool is_eligible_for_braindead_shortcircuit (void) const
     {
       return eligible_for_braindead_shortcircuit;
     }
 
-    tree_expression * dup (symbol_table::scope_id scope,
-                           symbol_table::context_id context) const;
+    tree_expression * dup (symbol_table::scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_binary_expression (*this);
     }
 
     std::string profiler_name (void) const { return "binary " + oper (); }
 
@@ -166,18 +165,17 @@ namespace octave
     bool is_boolean_expression (void) const { return true; }
 
     bool rvalue_ok (void) const { return true; }
 
     std::string oper (void) const;
 
     type op_type (void) const { return etype; }
 
-    tree_expression * dup (symbol_table::scope_id scope,
-                           symbol_table::context_id context) const;
+    tree_expression * dup (symbol_table::scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_boolean_expression (*this);
     }
 
   private:
 
diff --git a/libinterp/parse-tree/pt-cell.cc b/libinterp/parse-tree/pt-cell.cc
--- a/libinterp/parse-tree/pt-cell.cc
+++ b/libinterp/parse-tree/pt-cell.cc
@@ -32,18 +32,17 @@ along with Octave; see the file COPYING.
 #include "pt-exp.h"
 #include "pt-cell.h"
 #include "pt-walk.h"
 #include "ov.h"
 
 namespace octave
 {
   tree_expression *
-  tree_cell::dup (symbol_table::scope_id scope,
-                  symbol_table::context_id context) const
+  tree_cell::dup (symbol_table::scope& scope) const
   {
     tree_cell *new_cell = new tree_cell (0, line (), column ());
 
-    new_cell->copy_base (*this, scope, context);
+    new_cell->copy_base (*this, scope);
 
     return new_cell;
   }
 }
diff --git a/libinterp/parse-tree/pt-cell.h b/libinterp/parse-tree/pt-cell.h
--- a/libinterp/parse-tree/pt-cell.h
+++ b/libinterp/parse-tree/pt-cell.h
@@ -55,18 +55,17 @@ namespace octave
     tree_cell& operator = (const tree_cell&) = delete;
 
     ~tree_cell (void) = default;
 
     bool iscell (void) const { return true; }
 
     bool rvalue_ok (void) const { return true; }
 
-    tree_expression * dup (symbol_table::scope_id scope,
-                           symbol_table::context_id context) const;
+    tree_expression * dup (symbol_table::scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_cell (*this);
     }
   };
 }
 
diff --git a/libinterp/parse-tree/pt-colon.cc b/libinterp/parse-tree/pt-colon.cc
--- a/libinterp/parse-tree/pt-colon.cc
+++ b/libinterp/parse-tree/pt-colon.cc
@@ -85,23 +85,21 @@ namespace octave
   {
     return (op_base ? op_base->column ()
             : (op_increment ? op_increment->column ()
                : (op_limit ? op_limit->column ()
                   : -1)));
   }
 
   tree_expression *
-  tree_colon_expression::dup (symbol_table::scope_id scope,
-                              symbol_table::context_id context) const
+  tree_colon_expression::dup (symbol_table::scope& scope) const
   {
     tree_colon_expression *new_ce = new
-      tree_colon_expression (op_base ? op_base->dup (scope, context) : 0,
-                             op_limit ? op_limit->dup (scope, context) : 0,
-                             op_increment ? op_increment->dup (scope, context)
-                             : 0,
+      tree_colon_expression (op_base ? op_base->dup (scope) : 0,
+                             op_limit ? op_limit->dup (scope) : 0,
+                             op_increment ? op_increment->dup (scope) : 0,
                              line (), column ());
 
     new_ce->copy_base (*new_ce);
 
     return new_ce;
   }
 }
diff --git a/libinterp/parse-tree/pt-colon.h b/libinterp/parse-tree/pt-colon.h
--- a/libinterp/parse-tree/pt-colon.h
+++ b/libinterp/parse-tree/pt-colon.h
@@ -89,18 +89,17 @@ namespace octave
 
     tree_expression * limit (void) { return op_limit; }
 
     tree_expression * increment (void) { return op_increment; }
 
     int line (void) const;
     int column (void) const;
 
-    tree_expression * dup (symbol_table::scope_id scope,
-                           symbol_table::context_id context) const;
+    tree_expression * dup (symbol_table::scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_colon_expression (*this);
     }
 
   private:
 
diff --git a/libinterp/parse-tree/pt-const.cc b/libinterp/parse-tree/pt-const.cc
--- a/libinterp/parse-tree/pt-const.cc
+++ b/libinterp/parse-tree/pt-const.cc
@@ -53,18 +53,17 @@ namespace octave
   {
     if (pr_orig_text && ! orig_text.empty ())
       os << orig_text;
     else
       val.print_raw (os, pr_as_read_syntax);
   }
 
   tree_expression *
-  tree_constant::dup (symbol_table::scope_id,
-                      symbol_table::context_id) const
+  tree_constant::dup (symbol_table::scope&) const
   {
     tree_constant *new_tc
       = new tree_constant (val, orig_text, line (), column ());
 
     new_tc->copy_base (*this);
 
     return new_tc;
   }
diff --git a/libinterp/parse-tree/pt-const.h b/libinterp/parse-tree/pt-const.h
--- a/libinterp/parse-tree/pt-const.h
+++ b/libinterp/parse-tree/pt-const.h
@@ -73,18 +73,17 @@ namespace octave
 
     void print_raw (std::ostream& os, bool pr_as_read_syntax = false,
                     bool pr_orig_txt = true);
 
     bool rvalue_ok (void) const { return true; }
 
     octave_value value (void) { return val; }
 
-    tree_expression * dup (symbol_table::scope_id scope,
-                           symbol_table::context_id context) const;
+    tree_expression * dup (symbol_table::scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_constant (*this);
     }
 
     // Store the original text corresponding to this constant for later
     // pretty printing.
diff --git a/libinterp/parse-tree/pt-decl.cc b/libinterp/parse-tree/pt-decl.cc
--- a/libinterp/parse-tree/pt-decl.cc
+++ b/libinterp/parse-tree/pt-decl.cc
@@ -43,21 +43,20 @@ namespace octave
 
   tree_decl_elt::~tree_decl_elt (void)
   {
     delete id;
     delete expr;
   }
 
   tree_decl_elt *
-  tree_decl_elt::dup (symbol_table::scope_id scope,
-                      symbol_table::context_id context) const
+  tree_decl_elt::dup (symbol_table::scope& scope) const
   {
-    return new tree_decl_elt (id ? id->dup (scope, context) : 0,
-                              expr ? expr->dup (scope, context) : 0);
+    return new tree_decl_elt (id ? id->dup (scope) : 0,
+                              expr ? expr->dup (scope) : 0);
   }
 
   // Initializer lists for declaration statements.
 
   // Declaration commands (global, static).
 
   tree_decl_command::tree_decl_command (const std::string& n,
                                         tree_decl_init_list *t, int l, int c)
diff --git a/libinterp/parse-tree/pt-decl.h b/libinterp/parse-tree/pt-decl.h
--- a/libinterp/parse-tree/pt-decl.h
+++ b/libinterp/parse-tree/pt-decl.h
@@ -88,18 +88,17 @@ namespace octave
     bool is_persistent (void) const { return type == persistent; }
 
     tree_identifier * ident (void) { return id; }
 
     std::string name (void) { return id ? id->name () : ""; }
 
     tree_expression * expression (void) { return expr; }
 
-    tree_decl_elt * dup (symbol_table::scope_id scope,
-                         symbol_table::context_id context) const;
+    tree_decl_elt * dup (symbol_table::scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_decl_elt (*this);
     }
 
   private:
 
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -91,48 +91,48 @@ namespace octave
   tree_evaluator::visit_anon_fcn_handle (tree_anon_fcn_handle& anon_fh)
   {
     // FIXME: should CMD_LIST be limited to a single expression?
     // I think that is what Matlab does.
 
     tree_parameter_list *param_list = anon_fh.parameter_list ();
     tree_expression *expr = anon_fh.expression ();
 
-    symbol_table::scope_id af_sid = anon_fh.scope ();
+    symbol_table::scope *af_scope = anon_fh.scope ();
 
     symbol_table& symtab = m_interpreter.get_symbol_table ();
 
-    symbol_table::scope_id af_parent_sid
-      = anon_fh.has_parent_scope () ? symtab.current_scope () : -1;
-
-    symbol_table::scope_id new_scope = symtab.dup_scope (af_sid);
-
-    if (new_scope > 0 && af_parent_sid > 0)
-      symtab.inherit (new_scope, af_parent_sid);
+    symbol_table::scope *af_parent_scope
+      = anon_fh.has_parent_scope () ? symtab.current_scope () : 0;
+
+    symbol_table::scope *new_scope = af_scope ? af_scope->dup () : 0;
+
+    if (new_scope && af_parent_scope)
+      symtab.inherit (new_scope, af_parent_scope);
 
     tree_parameter_list *param_list_dup
-      = param_list ? param_list->dup (new_scope, 0) : 0;
+      = param_list ? param_list->dup (*new_scope) : 0;
 
     tree_parameter_list *ret_list = 0;
 
     tree_statement_list *stmt_list = 0;
 
     if (expr)
       {
-        tree_expression *expr_dup = expr->dup (new_scope, 0);
+        tree_expression *expr_dup = expr->dup (*new_scope);
         tree_statement *stmt = new tree_statement (expr_dup, 0);
         stmt_list = new tree_statement_list (stmt);
       }
 
     octave_user_function *af
       = new octave_user_function (new_scope, param_list_dup, ret_list,
                                   stmt_list);
 
-    if (af_parent_sid > 0)
-      symtab.set_parent (new_scope, af_parent_sid);
+    if (af_parent_scope)
+      symtab.set_parent (new_scope, af_parent_scope);
 
     octave_function *curr_fcn = m_call_stack.current ();
 
     if (curr_fcn)
       {
         // FIXME: maybe it would be better to just stash curr_fcn
         // instead of individual bits of info about it?
 
@@ -581,17 +581,20 @@ namespace octave
       {
         octave_value_list retval (nargout);
 
         int i = 0;
 
         for (tree_decl_elt *elt : *param_list)
           {
             if (elt->is_defined ())
-              retval(i++) = evaluate (elt);
+              {
+                octave_value tmp = evaluate (elt);
+                retval(i++) = tmp;
+              }
             else
               break;
           }
 
         return retval;
       }
     else
       {
diff --git a/libinterp/parse-tree/pt-exp.h b/libinterp/parse-tree/pt-exp.h
--- a/libinterp/parse-tree/pt-exp.h
+++ b/libinterp/parse-tree/pt-exp.h
@@ -53,18 +53,17 @@ namespace octave
     tree_expression (const tree_expression&) = delete;
 
     tree_expression& operator = (const tree_expression&) = delete;
 
     virtual ~tree_expression (void) = default;
 
     virtual bool has_magic_end (void) const = 0;
 
-    virtual tree_expression * dup (symbol_table::scope_id,
-                                   symbol_table::context_id context) const = 0;
+    virtual tree_expression * dup (symbol_table::scope& scope) const = 0;
 
     virtual bool is_constant (void) const { return false; }
 
     virtual bool is_matrix (void) const { return false; }
 
     virtual bool iscell (void) const { return false; }
 
     virtual bool is_identifier (void) const { return false; }
diff --git a/libinterp/parse-tree/pt-fcn-handle.cc b/libinterp/parse-tree/pt-fcn-handle.cc
--- a/libinterp/parse-tree/pt-fcn-handle.cc
+++ b/libinterp/parse-tree/pt-fcn-handle.cc
@@ -49,54 +49,52 @@ namespace octave
   void
   tree_fcn_handle::print_raw (std::ostream& os, bool pr_as_read_syntax,
                               bool pr_orig_text)
   {
     os << ((pr_as_read_syntax || pr_orig_text) ? "@" : "") << nm;
   }
 
   tree_expression *
-  tree_fcn_handle::dup (symbol_table::scope_id,
-                        symbol_table::context_id) const
+  tree_fcn_handle::dup (symbol_table::scope&) const
   {
     tree_fcn_handle *new_fh = new tree_fcn_handle (nm, line (), column ());
 
     new_fh->copy_base (*this);
 
     return new_fh;
   }
 
   tree_anon_fcn_handle::~tree_anon_fcn_handle (void)
   {
     delete m_parameter_list;
     delete m_expression;
   }
 
   tree_expression *
-  tree_anon_fcn_handle::dup (symbol_table::scope_id,
-                             symbol_table::context_id) const
+  tree_anon_fcn_handle::dup (symbol_table::scope&) const
   {
     tree_parameter_list *param_list = parameter_list ();
     tree_expression *expr = expression ();
 
-    symbol_table::scope_id af_sid = scope ();
-    symbol_table::scope_id af_parent_sid = parent_scope ();
+    symbol_table::scope *af_scope = m_scope;
+    symbol_table::scope *af_parent_scope = m_parent_scope;
 
     symbol_table& symtab
       = octave::__get_symbol_table__ ("tree_anon_fcn_handle::dup");
 
-    symbol_table::scope_id new_scope = symtab.dup_scope (af_sid);
+    symbol_table::scope *new_scope = af_scope ? af_scope->dup () : 0;
 
-    if (new_scope > 0)
+    if (new_scope)
       symtab.inherit (new_scope);
 
     tree_anon_fcn_handle *new_afh = new
-      tree_anon_fcn_handle (param_list ? param_list->dup (new_scope, 0) : 0,
-                            expr ? expr->dup (new_scope, 0) : 0,
-                            new_scope, af_parent_sid, line (), column ());
+      tree_anon_fcn_handle (param_list ? param_list->dup (*new_scope) : 0,
+                            expr ? expr->dup (*new_scope) : 0,
+                            new_scope, af_parent_scope, line (), column ());
 
     new_afh->copy_base (*this);
 
     return new_afh;
   }
 }
 
 /*
diff --git a/libinterp/parse-tree/pt-fcn-handle.h b/libinterp/parse-tree/pt-fcn-handle.h
--- a/libinterp/parse-tree/pt-fcn-handle.h
+++ b/libinterp/parse-tree/pt-fcn-handle.h
@@ -68,18 +68,17 @@ namespace octave
 
     void print_raw (std::ostream& os, bool pr_as_read_syntax = false,
                     bool pr_orig_txt = true);
 
     std::string name (void) const { return nm; }
 
     bool rvalue_ok (void) const { return true; }
 
-    tree_expression * dup (symbol_table::scope_id scope,
-                           symbol_table::context_id context) const;
+    tree_expression * dup (symbol_table::scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_fcn_handle (*this);
     }
 
   private:
 
@@ -88,25 +87,25 @@ namespace octave
   };
 
   class tree_anon_fcn_handle : public tree_expression
   {
   public:
 
     tree_anon_fcn_handle (int l = -1, int c = -1)
       : tree_expression (l, c), m_parameter_list (0), m_expression (0),
-        m_sid (-1), m_parent_sid (-1), m_file_name ()
+        m_scope (0), m_parent_scope (0), m_file_name ()
     { }
 
     tree_anon_fcn_handle (tree_parameter_list *pl, tree_expression *ex,
-                          symbol_table::scope_id sid,
-                          symbol_table::scope_id parent_sid,
+                          symbol_table::scope *scope,
+                          symbol_table::scope *parent_scope,
                           int l = -1, int c = -1)
       : tree_expression (l, c), m_parameter_list (pl), m_expression (ex),
-        m_sid (sid), m_parent_sid (parent_sid), m_file_name ()
+        m_scope (scope), m_parent_scope (parent_scope), m_file_name ()
     { }
 
     // No copying!
 
     tree_anon_fcn_handle (const tree_anon_fcn_handle&) = delete;
 
     tree_anon_fcn_handle& operator = (const tree_anon_fcn_handle&) = delete;
 
@@ -118,44 +117,43 @@ namespace octave
 
     tree_parameter_list * parameter_list (void) const
     {
       return m_parameter_list;
     }
 
     tree_expression * expression (void) const { return m_expression; }
 
-    symbol_table::scope_id scope (void) const { return m_sid; }
+    symbol_table::scope *scope (void) const { return m_scope; }
 
-    symbol_table::scope_id parent_scope (void) const { return m_parent_sid; }
+    symbol_table::scope *parent_scope (void) const { return m_parent_scope; }
 
-    bool has_parent_scope (void) const { return m_parent_sid > 0; }
+    bool has_parent_scope (void) const { return m_parent_scope; }
 
-    tree_expression * dup (symbol_table::scope_id scope,
-                           symbol_table::context_id context) const;
+    tree_expression * dup (symbol_table::scope& scope) const;
 
     void accept (tree_walker& tw) { tw.visit_anon_fcn_handle (*this); }
 
     void stash_file_name (const std::string& file) { m_file_name = file; }
 
     std::string file_name (void) const { return m_file_name; }
 
   private:
 
     // Inputs parameters.
     tree_parameter_list *m_parameter_list;
 
     // Function body, limited to a single expression.
     tree_expression *m_expression;
 
     // Function scope.
-    symbol_table::scope_id m_sid;
+    symbol_table::scope *m_scope;
 
-    // Parent scope, or -1 if none.
-    symbol_table::scope_id m_parent_sid;
+    // Parent scope, or 0 if none.
+    symbol_table::scope *m_parent_scope;
 
     // Filename where the handle was defined.
     std::string m_file_name;
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
diff --git a/libinterp/parse-tree/pt-funcall.cc b/libinterp/parse-tree/pt-funcall.cc
--- a/libinterp/parse-tree/pt-funcall.cc
+++ b/libinterp/parse-tree/pt-funcall.cc
@@ -63,17 +63,17 @@ namespace octave
               os << ", ";
           }
 
         os << ")";
       }
   }
 
   tree_funcall *
-  tree_funcall::dup (symbol_table::scope_id, symbol_table::context_id) const
+  tree_funcall::dup (symbol_table::scope&) const
   {
     tree_funcall *new_fc = new tree_funcall (fcn, args, line (), column ());
 
     new_fc->copy_base (*new_fc);
 
     return new_fc;
   }
 }
diff --git a/libinterp/parse-tree/pt-funcall.h b/libinterp/parse-tree/pt-funcall.h
--- a/libinterp/parse-tree/pt-funcall.h
+++ b/libinterp/parse-tree/pt-funcall.h
@@ -61,18 +61,17 @@ namespace octave
     bool has_magic_end (void) const { return false; }
 
     void print (std::ostream& os, bool pr_as_read_syntax = false,
                 bool pr_orig_txt = true);
 
     void print_raw (std::ostream& os, bool pr_as_read_syntax = false,
                     bool pr_orig_txt = true);
 
-    tree_funcall * dup (symbol_table::scope_id,
-                        symbol_table::context_id context) const;
+    tree_funcall * dup (symbol_table::scope& scope) const;
 
     octave_value function (void) const { return fcn; }
 
     octave_value_list arguments (void) const { return args; }
 
     void accept (tree_walker& tw)
     {
       tw.visit_funcall (*this);
diff --git a/libinterp/parse-tree/pt-id.cc b/libinterp/parse-tree/pt-id.cc
--- a/libinterp/parse-tree/pt-id.cc
+++ b/libinterp/parse-tree/pt-id.cc
@@ -65,26 +65,22 @@ namespace octave
   {
     if (sym->is_added_static ())
       static_workspace_error ();
 
     return octave_lvalue (sym);
   }
 
   tree_identifier *
-  tree_identifier::dup (symbol_table::scope_id sc,
-                        symbol_table::context_id) const
+  tree_identifier::dup (symbol_table::scope& scope) const
   {
     // The new tree_identifier object contains a symbol_record
     // entry from the duplicated scope.
 
-    symbol_table& symtab = octave::__get_symbol_table__ ("tree_identifier::dup");
-
-    // FIXME: is this the best way?
-    symbol_table::symbol_record new_sym = symtab.find_symbol (name (), sc);
+    symbol_table::symbol_record new_sym = scope.find_symbol (name ());
 
     tree_identifier *new_id
       = new tree_identifier (new_sym, line (), column ());
 
     new_id->copy_base (*this);
 
     return new_id;
   }
diff --git a/libinterp/parse-tree/pt-id.h b/libinterp/parse-tree/pt-id.h
--- a/libinterp/parse-tree/pt-id.h
+++ b/libinterp/parse-tree/pt-id.h
@@ -68,19 +68,27 @@ namespace octave
     bool has_magic_end (void) const { return (name () == "end"); }
 
     bool is_identifier (void) const { return true; }
 
     // The name doesn't change with scope, so use sym instead of
     // accessing it through sym so that this function may remain const.
     std::string name (void) const { return sym.name (); }
 
-    bool is_defined (void) { return sym->is_defined (); }
+    bool is_defined (void)
+    {
+      symbol_table::context_id context = sym.context ();
+      return sym->is_defined (context);
+    }
 
-    virtual bool is_variable (void) const { return sym->is_variable (); }
+    virtual bool is_variable (void) const
+    {
+      symbol_table::context_id context = sym.context ();
+      return sym->is_variable (context);
+    }
 
     virtual bool is_black_hole (void) { return false; }
 
     // Try to find a definition for an identifier.  Here's how:
     //
     //   * If the identifier is already defined and is a function defined
     //     in an function file that has been modified since the last time
     //     we parsed it, parse it again.
@@ -116,18 +124,17 @@ namespace octave
     void eval_undefined_error (void);
 
     void static_workspace_error (void)
     {
       error ("can not add variable \"%s\" to a static workspace",
              name ().c_str ());
     }
 
-    tree_identifier * dup (symbol_table::scope_id scope,
-                           symbol_table::context_id context) const;
+    tree_identifier * dup (symbol_table::scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_identifier (*this);
     }
 
     symbol_table::symbol_reference symbol (void) const
     {
@@ -147,18 +154,17 @@ namespace octave
       : tree_identifier (l, c) { }
 
     std::string name (void) const { return "~"; }
 
     bool is_variable (void) const { return false; }
 
     bool is_black_hole (void) { return true; }
 
-    tree_black_hole * dup (symbol_table::scope_id,
-                           symbol_table::context_id) const
+    tree_black_hole * dup (symbol_table::scope&) const
     {
       return new tree_black_hole;
     }
 
     octave_lvalue lvalue (tree_evaluator *)
     {
       return octave_lvalue (); // black hole lvalue
     }
diff --git a/libinterp/parse-tree/pt-idx.cc b/libinterp/parse-tree/pt-idx.cc
--- a/libinterp/parse-tree/pt-idx.cc
+++ b/libinterp/parse-tree/pt-idx.cc
@@ -384,39 +384,38 @@ namespace octave
       }
 
     retval.set_index (type, idx);
 
     return retval;
   }
 
   tree_index_expression *
-  tree_index_expression::dup (symbol_table::scope_id scope,
-                              symbol_table::context_id context) const
+  tree_index_expression::dup (symbol_table::scope& scope) const
   {
     tree_index_expression *new_idx_expr
       = new tree_index_expression (line (), column ());
 
-    new_idx_expr->expr = (expr ? expr->dup (scope, context) : 0);
+    new_idx_expr->expr = (expr ? expr->dup (scope) : 0);
 
     std::list<tree_argument_list *> new_args;
 
     for (const tree_argument_list *elt : args)
-      new_args.push_back (elt ? elt->dup (scope, context) : 0);
+      new_args.push_back (elt ? elt->dup (scope) : 0);
 
     new_idx_expr->args = new_args;
 
     new_idx_expr->type = type;
 
     new_idx_expr->arg_nm = arg_nm;
 
     std::list<tree_expression *> new_dyn_field;
 
     for (const tree_expression *elt : dyn_field)
-      new_dyn_field.push_back (elt ? elt->dup (scope, context) : 0);
+      new_dyn_field.push_back (elt ? elt->dup (scope) : 0);
 
     new_idx_expr->dyn_field = new_dyn_field;
 
     new_idx_expr->copy_base (*this);
 
     return new_idx_expr;
   }
 }
diff --git a/libinterp/parse-tree/pt-idx.h b/libinterp/parse-tree/pt-idx.h
--- a/libinterp/parse-tree/pt-idx.h
+++ b/libinterp/parse-tree/pt-idx.h
@@ -89,18 +89,17 @@ namespace octave
     std::list<tree_expression *> dyn_fields (void) { return dyn_field; }
 
     bool lvalue_ok (void) const { return expr->lvalue_ok (); }
 
     bool rvalue_ok (void) const { return true; }
 
     octave_lvalue lvalue (tree_evaluator *tw);
 
-    tree_index_expression * dup (symbol_table::scope_id scope,
-                                 symbol_table::context_id context) const;
+    tree_index_expression * dup (symbol_table::scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_index_expression (*this);
     }
 
     std::string
     get_struct_index
diff --git a/libinterp/parse-tree/pt-jit.cc b/libinterp/parse-tree/pt-jit.cc
--- a/libinterp/parse-tree/pt-jit.cc
+++ b/libinterp/parse-tree/pt-jit.cc
@@ -1077,17 +1077,17 @@ jit_convert::visit_do_until_command (tre
       block->append (factory.create<jit_cond_branch> (check, tail, body));
     }
 
   blocks.push_back (tail);
   block = tail;
 }
 
 void
-jit_convert::initialize (symbol_table::scope_id s)
+jit_convert::initialize (symbol_table::scope *s)
 {
   scope = s;
   iterator_count = 0;
   for_bounds_count = 0;
   short_count = 0;
   jit_instruction::reset_ids ();
 
   entry_block = factory.create<jit_block> ("body");
diff --git a/libinterp/parse-tree/pt-jit.h b/libinterp/parse-tree/pt-jit.h
--- a/libinterp/parse-tree/pt-jit.h
+++ b/libinterp/parse-tree/pt-jit.h
@@ -164,17 +164,17 @@ public:
   void visit_do_until_command (tree_do_until_command&);
 private:
   std::vector<std::pair<std::string, bool>> arguments;
   type_bound_vector bounds;
 
   bool converting_function;
 
   // the scope of the function we are converting, or the current scope
-  symbol_table::scope_id scope;
+  symbol_table::scope *scope;
 
   jit_factory factory;
 
   // used instead of return values from visit_* functions
   jit_value *result;
 
   jit_block *entry_block;
 
@@ -189,17 +189,17 @@ private:
   std::vector<jit_magic_end::context> end_context;
 
   size_t iterator_count;
   size_t for_bounds_count;
   size_t short_count;
 
   variable_map vmap;
 
-  void initialize (symbol_table::scope_id s);
+  void initialize (symbol_table::scope *s);
 
   jit_call * create_checked_impl (jit_call *ret);
 
   // get an existing vairable.  If the variable does not exist, it will not be
   // created
   jit_variable * find_variable (const std::string& vname) const;
 
   // get a variable, create it if it does not exist.  The type will default to
diff --git a/libinterp/parse-tree/pt-mat.cc b/libinterp/parse-tree/pt-mat.cc
--- a/libinterp/parse-tree/pt-mat.cc
+++ b/libinterp/parse-tree/pt-mat.cc
@@ -132,22 +132,21 @@ namespace octave
   maybe_warn_string_concat (bool all_dq_strings_p, bool all_sq_strings_p)
   {
     if (! (all_dq_strings_p || all_sq_strings_p))
       warning_with_id ("Octave:mixed-string-concat",
                        "concatenation of different character string types may have unintended consequences");
   }
 
   tree_expression *
-  tree_matrix::dup (symbol_table::scope_id scope,
-                    symbol_table::context_id context) const
+  tree_matrix::dup (symbol_table::scope& scope) const
   {
     tree_matrix *new_matrix = new tree_matrix (0, line (), column ());
 
-    new_matrix->copy_base (*this, scope, context);
+    new_matrix->copy_base (*this, scope);
 
     return new_matrix;
   }
 }
 
 
 /*
 ## test concatenation with all zero matrices
diff --git a/libinterp/parse-tree/pt-mat.h b/libinterp/parse-tree/pt-mat.h
--- a/libinterp/parse-tree/pt-mat.h
+++ b/libinterp/parse-tree/pt-mat.h
@@ -61,18 +61,17 @@ namespace octave
     tree_matrix& operator = (const tree_matrix&) = delete;
 
     ~tree_matrix (void) = default;
 
     bool is_matrix (void) const { return true; }
 
     bool rvalue_ok (void) const { return true; }
 
-    tree_expression * dup (symbol_table::scope_id scope,
-                           symbol_table::context_id context) const;
+    tree_expression * dup (symbol_table::scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_matrix (*this);
     }
   };
 
   extern std::string
diff --git a/libinterp/parse-tree/pt-misc.cc b/libinterp/parse-tree/pt-misc.cc
--- a/libinterp/parse-tree/pt-misc.cc
+++ b/libinterp/parse-tree/pt-misc.cc
@@ -136,26 +136,25 @@ namespace octave
             break;
           }
       }
 
     return status;
   }
 
   tree_parameter_list *
-  tree_parameter_list::dup (symbol_table::scope_id scope,
-                            symbol_table::context_id context) const
+  tree_parameter_list::dup (symbol_table::scope& scope) const
   {
     tree_parameter_list *new_list = new tree_parameter_list ();
 
     if (takes_varargs ())
       new_list->mark_varargs ();
 
     for (const tree_decl_elt *elt : *this)
-      new_list->append (elt->dup (scope, context));
+      new_list->append (elt->dup (scope));
 
     return new_list;
   }
 
   // Return lists.
 
   tree_return_list::~tree_return_list (void)
   {
diff --git a/libinterp/parse-tree/pt-misc.h b/libinterp/parse-tree/pt-misc.h
--- a/libinterp/parse-tree/pt-misc.h
+++ b/libinterp/parse-tree/pt-misc.h
@@ -73,18 +73,17 @@ namespace octave
     bool takes_varargs (void) const { return marked_for_varargs != 0; }
 
     bool varargs_only (void) { return (marked_for_varargs < 0); }
 
     bool is_defined (void);
 
     std::list<std::string> variable_names (void) const;
 
-    tree_parameter_list * dup (symbol_table::scope_id scope,
-                               symbol_table::context_id context) const;
+    tree_parameter_list * dup (symbol_table::scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_parameter_list (*this);
     }
 
   private:
 
diff --git a/libinterp/parse-tree/pt-unop.cc b/libinterp/parse-tree/pt-unop.cc
--- a/libinterp/parse-tree/pt-unop.cc
+++ b/libinterp/parse-tree/pt-unop.cc
@@ -41,35 +41,33 @@ namespace octave
   tree_unary_expression::oper (void) const
   {
     return octave_value::unary_op_as_string (etype);
   }
 
   // Prefix expressions.
 
   tree_expression *
-  tree_prefix_expression::dup (symbol_table::scope_id scope,
-                               symbol_table::context_id context) const
+  tree_prefix_expression::dup (symbol_table::scope& scope) const
   {
     tree_prefix_expression *new_pe
-      = new tree_prefix_expression (op ? op->dup (scope, context) : 0,
+      = new tree_prefix_expression (op ? op->dup (scope) : 0,
                                     line (), column (), etype);
 
     new_pe->copy_base (*this);
 
     return new_pe;
   }
 
   // Postfix expressions.
 
   tree_expression *
-  tree_postfix_expression::dup (symbol_table::scope_id scope,
-                                symbol_table::context_id context) const
+  tree_postfix_expression::dup (symbol_table::scope& scope) const
   {
     tree_postfix_expression *new_pe
-      = new tree_postfix_expression (op ? op->dup (scope, context) : 0,
+      = new tree_postfix_expression (op ? op->dup (scope) : 0,
                                      line (), column (), etype);
 
     new_pe->copy_base (*this);
 
     return new_pe;
   }
 }
diff --git a/libinterp/parse-tree/pt-unop.h b/libinterp/parse-tree/pt-unop.h
--- a/libinterp/parse-tree/pt-unop.h
+++ b/libinterp/parse-tree/pt-unop.h
@@ -100,18 +100,17 @@ namespace octave
     tree_prefix_expression (const tree_prefix_expression&) = delete;
 
     tree_prefix_expression& operator = (const tree_prefix_expression&) = delete;
 
     ~tree_prefix_expression (void) = default;
 
     bool rvalue_ok (void) const { return true; }
 
-    tree_expression * dup (symbol_table::scope_id scope,
-                           symbol_table::context_id context) const;
+    tree_expression * dup (symbol_table::scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_prefix_expression (*this);
     }
 
     std::string profiler_name (void) const { return "prefix " + oper (); }
   };
@@ -135,18 +134,17 @@ namespace octave
     tree_postfix_expression (const tree_postfix_expression&) = delete;
 
     tree_postfix_expression& operator = (const tree_postfix_expression&) = delete;
 
     ~tree_postfix_expression (void) = default;
 
     bool rvalue_ok (void) const { return true; }
 
-    tree_expression * dup (symbol_table::scope_id scope,
-                           symbol_table::context_id context) const;
+    tree_expression * dup (symbol_table::scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_postfix_expression (*this);
     }
 
     std::string profiler_name (void) const { return "postfix " + oper (); }
   };
diff --git a/libinterp/parse-tree/token.cc b/libinterp/parse-tree/token.cc
--- a/libinterp/parse-tree/token.cc
+++ b/libinterp/parse-tree/token.cc
@@ -65,17 +65,17 @@ namespace octave
   { }
 
   token::token (int tv, end_tok_type t, int l, int c)
     : m_maybe_cmd (false), m_tspc (false), m_line_num (l), m_column_num (c),
       m_tok_val (tv), m_type_tag (ettype_token), m_tok_info (t),
       m_orig_text ()
   { }
 
-  token::token (int tv, symbol_table::symbol_record *sr, int l, int c)
+  token::token (int tv, const symbol_table::symbol_record& sr, int l, int c)
     : m_maybe_cmd (false), m_tspc (false), m_line_num (l), m_column_num (c),
       m_tok_val (tv), m_type_tag (sym_rec_token), m_tok_info (sr),
       m_orig_text ()
   { }
 
   token::token (int tv, const std::string& method_nm,
                 const std::string& class_nm, int l, int c)
     : m_maybe_cmd (false), m_tspc (false), m_line_num (l), m_column_num (c),
@@ -83,16 +83,19 @@ namespace octave
       m_tok_info (method_nm, class_nm), m_orig_text ()
   { }
 
   token::~token (void)
   {
     if (m_type_tag == string_token)
       delete m_tok_info.m_str;
 
+    if (m_type_tag == sym_rec_token)
+      delete m_tok_info.m_sr;
+
     if (m_type_tag == scls_name_token)
       delete m_tok_info.m_superclass_info;
   }
 
   std::string
   token::text (void) const
   {
     assert (m_type_tag == string_token);
@@ -121,21 +124,21 @@ namespace octave
 
   token::end_tok_type
   token::ettype (void) const
   {
     assert (m_type_tag == ettype_token);
     return m_tok_info.m_et;
   }
 
-  symbol_table::symbol_record *
+  symbol_table::symbol_record
   token::sym_rec (void) const
   {
     assert (m_type_tag == sym_rec_token);
-    return m_tok_info.m_sr;
+    return *m_tok_info.m_sr;
   }
 
   std::string
   token::superclass_method_name (void) const
   {
     assert (m_type_tag == scls_name_token);
     return m_tok_info.m_superclass_info->m_method_nm;
   }
diff --git a/libinterp/parse-tree/token.h b/libinterp/parse-tree/token.h
--- a/libinterp/parse-tree/token.h
+++ b/libinterp/parse-tree/token.h
@@ -67,17 +67,18 @@ namespace octave
 
     token (int tv, int l = -1, int c = -1);
     token (int tv, bool is_keyword, int l = -1, int c = -1);
     token (int tv, const char *s, int l = -1, int c = -1);
     token (int tv, const std::string& s, int l = -1, int c = -1);
     token (int tv, double d, const std::string& s = "",
            int l = -1, int c = -1);
     token (int tv, end_tok_type t, int l = -1, int c = -1);
-    token (int tv, symbol_table::symbol_record *s, int l = -1, int c = -1);
+    token (int tv, const symbol_table::symbol_record& s,
+           int l = -1, int c = -1);
     token (int tv, const std::string& mth, const std::string& cls,
            int l = -1, int c = -1);
 
     // No copying!
 
     token (const token&) = delete;
 
     token& operator = (const token&) = delete;
@@ -106,17 +107,17 @@ namespace octave
       return m_type_tag == sym_rec_token;
     }
 
     std::string text (void) const;
     std::string symbol_name (void) const;
     double number (void) const;
     token_type ttype (void) const;
     end_tok_type ettype (void) const;
-    symbol_table::symbol_record * sym_rec (void) const;
+    symbol_table::symbol_record sym_rec (void) const;
 
     std::string superclass_method_name (void) const;
     std::string superclass_class_name (void) const;
 
     std::string text_rep (void) const;
 
   private:
 
@@ -139,17 +140,19 @@ namespace octave
       tok_info (const char *s) : m_str (new std::string (s)) { }
 
       tok_info (const std::string& str) : m_str (new std::string (str)) { }
 
       tok_info (double num) : m_num (num) { }
 
       tok_info (end_tok_type et) : m_et (et) { }
 
-      tok_info (symbol_table::symbol_record *sr) : m_sr (sr) { }
+      tok_info (const symbol_table::symbol_record& sr)
+        : m_sr (new symbol_table::symbol_record (sr))
+      { }
 
       tok_info (const std::string& method_nm, const std::string& class_nm)
         : m_superclass_info (new superclass_info (method_nm, class_nm))
       { }
 
       tok_info (const tok_info&) = delete;
 
       tok_info& operator = (const tok_info&) = delete;
