# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1361859008 18000
#      Tue Feb 26 01:10:08 2013 -0500
# Node ID 7302f8a4df832d9186f36862a1ba386487badf3d
# Parent  229eb14653fd45952e1108f4a687a9733b474229
use pointer for global lexical_feedback structure

* lex.h, lex.ll (curr_lexer): Rename from lexer_flags.
Declare as pointer.  Change all uses.
* lex.h (lexical_feedback): Make copy constructor and operator=
private.
* toplev.cc (main_loop): Protect existing and initialize new
curr_lexer.
* input.cc (get_debug_input): Likewise.

diff --git a/libinterp/interpfcn/input.cc b/libinterp/interpfcn/input.cc
--- a/libinterp/interpfcn/input.cc
+++ b/libinterp/interpfcn/input.cc
@@ -673,16 +673,19 @@ get_debug_input (const std::string& prom
 
       // FIXME: are these safe?
       frame.add_fcn (switch_to_buffer, old_buf);
       frame.add_fcn (delete_buffer, new_buf);
 
       switch_to_buffer (new_buf);
     }
 
+  frame.protect_var (curr_lexer);
+  curr_lexer = new lexical_feedback ();
+
   while (Vdebugging)
     {
       reset_error_handler ();
 
       reset_parser ();
 
       // Save current value of global_command.
       frame.protect_var (global_command);
@@ -1188,17 +1191,17 @@ for details.\n\
 
 typedef std::map<std::string, octave_value> hook_fcn_map_type;
 
 static hook_fcn_map_type hook_fcn_map;
 
 static int
 input_event_hook (void)
 {
-  if (! lexer_flags.defining_func)
+  if (! curr_lexer->defining_func)
     {
       hook_fcn_map_type::iterator p = hook_fcn_map.begin ();
 
       while (p != hook_fcn_map.end ())
         {
           std::string hook_fcn = p->first;
           octave_value user_data = p->second;
 
diff --git a/libinterp/interpfcn/toplev.cc b/libinterp/interpfcn/toplev.cc
--- a/libinterp/interpfcn/toplev.cc
+++ b/libinterp/interpfcn/toplev.cc
@@ -552,24 +552,29 @@ main_loop (void)
   octave_signal_hook = octave_signal_handler;
   octave_interrupt_hook = 0;
   octave_bad_alloc_hook = 0;
 
   octave_catch_interrupts ();
 
   octave_initialized = true;
 
+  unwind_protect frame;
+
+  frame.protect_var (curr_lexer);
+  curr_lexer = new lexical_feedback ();
+
   // The big loop.
 
   int retval = 0;
   do
     {
       try
         {
-          unwind_protect frame;
+          unwind_protect inner_frame;
 
           reset_error_handler ();
 
           reset_parser ();
 
           if (symbol_table::at_top_level ())
             tree_evaluator::reset_debug_state ();
 
@@ -626,17 +631,17 @@ main_loop (void)
                   else
                     {
                       if (octave_completion_matches_called)
                         octave_completion_matches_called = false;
                       else
                         command_editor::increment_current_command_number ();
                     }
                 }
-              else if (lexer_flags.parser_end_of_input)
+              else if (curr_lexer->parser_end_of_input)
                 break;
             }
         }
       catch (octave_interrupt_exception)
         {
           recover_from_exception ();
           octave_stdout << "\n";
           if (quitting_gracefully)
diff --git a/libinterp/parse-tree/lex.h b/libinterp/parse-tree/lex.h
--- a/libinterp/parse-tree/lex.h
+++ b/libinterp/parse-tree/lex.h
@@ -170,84 +170,16 @@ public:
       looping (0), defining_func (0), looking_at_function_handle (0),
       block_comment_nesting_level (0),
       looking_at_object_index (), parsed_function_name (),
       pending_local_variables (), nesting_level ()
   {
     init ();
   }
 
-  lexical_feedback (const lexical_feedback& lf)
-    : convert_spaces_to_comma (lf.convert_spaces_to_comma),
-      do_comma_insert (lf.do_comma_insert),
-      at_beginning_of_statement (lf.at_beginning_of_statement),
-      looking_at_anon_fcn_args (lf.looking_at_anon_fcn_args),
-      looking_at_return_list (lf.looking_at_return_list),
-      looking_at_parameter_list (lf.looking_at_parameter_list),
-      looking_at_decl_list (lf.looking_at_decl_list),
-      looking_at_initializer_expression (lf.looking_at_initializer_expression),
-      looking_at_matrix_or_assign_lhs (lf.looking_at_matrix_or_assign_lhs),
-      looking_for_object_index (lf.looking_for_object_index),
-      looking_at_indirect_ref (lf.looking_at_indirect_ref),
-      parsing_class_method (lf.parsing_class_method),
-      maybe_classdef_get_set_method (lf.maybe_classdef_get_set_method),
-      parsing_classdef (lf.parsing_classdef),
-      quote_is_transpose (lf.quote_is_transpose),
-      parser_end_of_input (lf.parser_end_of_input),
-      input_line_number (lf.input_line_number),
-      current_input_column (lf.current_input_column),
-      bracketflag (lf.bracketflag),
-      braceflag (lf.braceflag),
-      looping (lf.looping),
-      defining_func (lf.defining_func),
-      looking_at_function_handle (lf.looking_at_function_handle),
-      block_comment_nesting_level (lf.block_comment_nesting_level),
-      looking_at_object_index (lf.looking_at_object_index),
-      parsed_function_name (lf.parsed_function_name),
-      pending_local_variables (lf.pending_local_variables),
-      nesting_level (lf.nesting_level)
-  { }
-
-  lexical_feedback& operator = (const lexical_feedback& lf)
-  {
-    if (&lf != this)
-      {
-        convert_spaces_to_comma = lf.convert_spaces_to_comma;
-        do_comma_insert = lf.do_comma_insert;
-        at_beginning_of_statement = lf.at_beginning_of_statement;
-        looking_at_anon_fcn_args = lf.looking_at_anon_fcn_args;
-        looking_at_return_list = lf.looking_at_return_list;
-        looking_at_parameter_list = lf.looking_at_parameter_list;
-        looking_at_decl_list = lf.looking_at_decl_list;
-        looking_at_initializer_expression = lf.looking_at_initializer_expression;
-        looking_at_matrix_or_assign_lhs = lf.looking_at_matrix_or_assign_lhs;
-        looking_for_object_index = lf.looking_for_object_index;
-        looking_at_indirect_ref = lf.looking_at_indirect_ref;
-        parsing_class_method = lf.parsing_class_method;
-        maybe_classdef_get_set_method = lf.maybe_classdef_get_set_method;
-        parsing_classdef = lf.parsing_classdef;
-        quote_is_transpose = lf.quote_is_transpose;
-        parser_end_of_input = lf.parser_end_of_input;
-        input_line_number = lf.input_line_number;
-        current_input_column = lf.current_input_column;
-        bracketflag = lf.bracketflag;
-        braceflag = lf.braceflag;
-        looping = lf.looping;
-        defining_func = lf.defining_func;
-        looking_at_function_handle = lf.looking_at_function_handle;
-        block_comment_nesting_level = lf.block_comment_nesting_level,
-        looking_at_object_index = lf.looking_at_object_index;
-        parsed_function_name = lf.parsed_function_name;
-        pending_local_variables = lf.pending_local_variables;
-        nesting_level = lf.nesting_level;
-      }
-
-    return *this;
-  }
-
   ~lexical_feedback (void) { }
 
   void init (void)
   {
     // The closest paren, brace, or bracket nesting is not an object
     // index.
     looking_at_object_index.push_front (false);
   }
@@ -342,16 +274,24 @@ public:
   std::stack<bool> parsed_function_name;
 
   // Set of identifiers that might be local variable names.
   std::set<std::string> pending_local_variables;
 
   // Is the closest nesting level a square bracket, squiggly brace or
   // a paren?
   bbp_nesting_level nesting_level;
+
+private:
+
+  // No copying!
+
+  lexical_feedback (const lexical_feedback&);
+
+  lexical_feedback& operator = (const lexical_feedback&);
 };
 
 class
 stream_reader
 {
 public:
   virtual int getc (void) = 0;
   virtual int ungetc (int c) = 0;
@@ -365,12 +305,12 @@ private:
   // No copying!
   stream_reader (const stream_reader&);
   stream_reader& operator = (const stream_reader&);
 };
 
 extern std::string
 grab_comment_block (stream_reader& reader, bool at_bol, bool& eof);
 
-// Flags that need to be shared between the lexer and parser.
-extern lexical_feedback lexer_flags;
+// The current state of the lexer.
+extern lexical_feedback *curr_lexer;
 
 #endif
diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -143,44 +143,44 @@ along with Octave; see the file COPYING.
       Vtoken_count++; \
       DISPLAY_TOK_AND_RETURN (tok); \
     } \
   while (0)
 
 #define TOK_RETURN(tok) \
   do \
     { \
-      lexer_flags.current_input_column += yyleng; \
-      lexer_flags.quote_is_transpose = false; \
-      lexer_flags.convert_spaces_to_comma = true; \
+      curr_lexer->current_input_column += yyleng; \
+      curr_lexer->quote_is_transpose = false; \
+      curr_lexer->convert_spaces_to_comma = true; \
       COUNT_TOK_AND_RETURN (tok); \
     } \
   while (0)
 
 #define TOK_PUSH_AND_RETURN(name, tok) \
   do \
     { \
-      yylval.tok_val = new token (name, lexer_flags.input_line_number, \
-                                  lexer_flags.current_input_column); \
+      yylval.tok_val = new token (name, curr_lexer->input_line_number, \
+                                  curr_lexer->current_input_column); \
       token_stack.push (yylval.tok_val); \
       TOK_RETURN (tok); \
     } \
   while (0)
 
 #define BIN_OP_RETURN_INTERNAL(tok, convert, bos, qit) \
   do \
     { \
-      yylval.tok_val = new token (lexer_flags.input_line_number, \
-                                  lexer_flags.current_input_column); \
+      yylval.tok_val = new token (curr_lexer->input_line_number, \
+                                  curr_lexer->current_input_column); \
       token_stack.push (yylval.tok_val); \
-      lexer_flags.current_input_column += yyleng; \
-      lexer_flags.quote_is_transpose = qit; \
-      lexer_flags.convert_spaces_to_comma = convert; \
-      lexer_flags.looking_for_object_index = false; \
-      lexer_flags.at_beginning_of_statement = bos; \
+      curr_lexer->current_input_column += yyleng; \
+      curr_lexer->quote_is_transpose = qit; \
+      curr_lexer->convert_spaces_to_comma = convert; \
+      curr_lexer->looking_for_object_index = false; \
+      curr_lexer->at_beginning_of_statement = bos; \
       COUNT_TOK_AND_RETURN (tok); \
     } \
   while (0)
 
 #define XBIN_OP_RETURN_INTERNAL(tok, convert, bos, qit) \
   do \
     { \
       gripe_matlab_incompatible_operator (yytext); \
@@ -207,17 +207,17 @@ along with Octave; see the file COPYING.
   do \
     { \
       if (lexer_debug_flag) \
         lexer_debug (pattern, yytext); \
     } \
   while (0)
 
 // The state of the lexer.
-lexical_feedback lexer_flags;
+lexical_feedback *curr_lexer = 0;
 
 // Stack to hold tokens so that we can delete them when the parser is
 // reset and avoid growing forever just because we are stashing some
 // information.  This has to appear before lex.h is included, because
 // one of the macros defined there uses token_stack.
 //
 // FIXME -- this should really be static, but that causes
 // problems on some systems.
@@ -310,59 +310,59 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 %{
 // Help and other command-style functions.
 %}
 
 <COMMAND_START>{NL} {
     LEXER_DEBUG ("<COMMAND_START>{NL}");
 
     BEGIN (INITIAL);
-    lexer_flags.input_line_number++;
-    lexer_flags.current_input_column = 1;
-
-    lexer_flags.quote_is_transpose = false;
-    lexer_flags.convert_spaces_to_comma = true;
-    lexer_flags.looking_for_object_index = false;
-    lexer_flags.at_beginning_of_statement = true;
+    curr_lexer->input_line_number++;
+    curr_lexer->current_input_column = 1;
+
+    curr_lexer->quote_is_transpose = false;
+    curr_lexer->convert_spaces_to_comma = true;
+    curr_lexer->looking_for_object_index = false;
+    curr_lexer->at_beginning_of_statement = true;
 
     COUNT_TOK_AND_RETURN ('\n');
   }
 
 <COMMAND_START>[\;\,] {
     LEXER_DEBUG ("<COMMAND_START>[\\;\\,]");
 
-    lexer_flags.looking_for_object_index = false;
-    lexer_flags.at_beginning_of_statement = true;
+    curr_lexer->looking_for_object_index = false;
+    curr_lexer->at_beginning_of_statement = true;
 
     BEGIN (INITIAL);
 
     if (strcmp (yytext, ",") == 0)
       TOK_RETURN (',');
     else
       TOK_RETURN (';');
   }
 
 <COMMAND_START>[\"\'] {
     LEXER_DEBUG ("<COMMAND_START>[\\\"\\']");
 
-    lexer_flags.at_beginning_of_statement = false;
-
-    lexer_flags.current_input_column++;
+    curr_lexer->at_beginning_of_statement = false;
+
+    curr_lexer->current_input_column++;
     int tok = handle_string (yytext[0]);
 
     COUNT_TOK_AND_RETURN (tok);
   }
 
 <COMMAND_START>[^#% \t\r\n\;\,\"\'][^ \t\r\n\;\,]*{S}* {
     LEXER_DEBUG ("<COMMAND_START>[^#% \\t\\r\\n\\;\\,\\\"\\'][^ \\t\\r\\n\\;\\,]*{S}*");
 
     std::string tok = strip_trailing_whitespace (yytext);
 
-    lexer_flags.looking_for_object_index = false;
-    lexer_flags.at_beginning_of_statement = false;
+    curr_lexer->looking_for_object_index = false;
+    curr_lexer->at_beginning_of_statement = false;
 
     TOK_PUSH_AND_RETURN (tok, SQ_STRING);
   }
 
 %{
 // For this and the next two rules, we're looking at ']', and we
 // need to know if the next token is '=' or '=='.
 //
@@ -377,20 +377,20 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 %}
 
 <MATRIX_START>{SNLCMT}*\]{S}* {
     LEXER_DEBUG ("<MATRIX_START>{SNLCMT}*\\]{S}*");
 
     scan_for_comments (yytext);
     fixup_column_count (yytext);
 
-    lexer_flags.looking_at_object_index.pop_front ();
-
-    lexer_flags.looking_for_object_index = true;
-    lexer_flags.at_beginning_of_statement = false;
+    curr_lexer->looking_at_object_index.pop_front ();
+
+    curr_lexer->looking_for_object_index = true;
+    curr_lexer->at_beginning_of_statement = false;
 
     int c = yytext[yyleng-1];
     bool cont_is_spc = (eat_continuation () != lexical_feedback::NO_WHITESPACE);
     bool spc_gobbled = (cont_is_spc || c == ' ' || c == '\t');
     int tok_to_return = handle_close_bracket (spc_gobbled, ']');
 
     if (spc_gobbled)
       xunput (' ', yytext);
@@ -403,20 +403,20 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 %}
 
 <MATRIX_START>{SNLCMT}*\}{S}* {
     LEXER_DEBUG ("<MATRIX_START>{SNLCMT}*\\}{S}*");
 
     scan_for_comments (yytext);
     fixup_column_count (yytext);
 
-    lexer_flags.looking_at_object_index.pop_front ();
-
-    lexer_flags.looking_for_object_index = true;
-    lexer_flags.at_beginning_of_statement = false;
+    curr_lexer->looking_at_object_index.pop_front ();
+
+    curr_lexer->looking_for_object_index = true;
+    curr_lexer->at_beginning_of_statement = false;
 
     int c = yytext[yyleng-1];
     bool cont_is_spc = (eat_continuation () != lexical_feedback::NO_WHITESPACE);
     bool spc_gobbled = (cont_is_spc || c == ' ' || c == '\t');
     int tok_to_return = handle_close_bracket (spc_gobbled, '}');
 
     if (spc_gobbled)
       xunput (' ', yytext);
@@ -428,26 +428,26 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 // Commas are element separators in matrix constants.  If we don't
 // check for continuations here we can end up inserting too many
 // commas.
 %}
 
 <MATRIX_START>{S}*\,{S}* {
     LEXER_DEBUG ("<MATRIX_START>{S}*\\,{S}*");
 
-    lexer_flags.current_input_column += yyleng;
+    curr_lexer->current_input_column += yyleng;
 
     int tmp = eat_continuation ();
 
-    lexer_flags.quote_is_transpose = false;
-    lexer_flags.convert_spaces_to_comma = true;
-    lexer_flags.looking_for_object_index = false;
-    lexer_flags.at_beginning_of_statement = false;
-
-    if (! lexer_flags.looking_at_object_index.front ())
+    curr_lexer->quote_is_transpose = false;
+    curr_lexer->convert_spaces_to_comma = true;
+    curr_lexer->looking_for_object_index = false;
+    curr_lexer->at_beginning_of_statement = false;
+
+    if (! curr_lexer->looking_at_object_index.front ())
       {
         if ((tmp & lexical_feedback::NEWLINE) == lexical_feedback::NEWLINE)
           {
             maybe_warn_separator_insert (';');
 
             xunput (';', yytext);
           }
       }
@@ -460,42 +460,42 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 // If commas are required, spaces are not important in matrix
 // constants so we just eat them.  If we don't check for continuations
 // here we can end up inserting too many commas.
 %}
 
 <MATRIX_START>{S}+ {
     LEXER_DEBUG ("<MATRIX_START>{S}+");
 
-    lexer_flags.current_input_column += yyleng;
-
-    lexer_flags.at_beginning_of_statement = false;
+    curr_lexer->current_input_column += yyleng;
+
+    curr_lexer->at_beginning_of_statement = false;
 
     int tmp = eat_continuation ();
 
-    if (! lexer_flags.looking_at_object_index.front ())
+    if (! curr_lexer->looking_at_object_index.front ())
       {
         bool bin_op = next_token_is_bin_op (true);
         bool postfix_un_op = next_token_is_postfix_unary_op (true);
         bool sep_op = next_token_is_sep_op ();
 
         if (! (postfix_un_op || bin_op || sep_op)
-            && lexer_flags.nesting_level.is_bracket_or_brace ()
-            && lexer_flags.convert_spaces_to_comma)
+            && curr_lexer->nesting_level.is_bracket_or_brace ()
+            && curr_lexer->convert_spaces_to_comma)
           {
             if ((tmp & lexical_feedback::NEWLINE) == lexical_feedback::NEWLINE)
               {
                 maybe_warn_separator_insert (';');
 
                 xunput (';', yytext);
               }
 
-            lexer_flags.quote_is_transpose = false;
-            lexer_flags.convert_spaces_to_comma = true;
-            lexer_flags.looking_for_object_index = false;
+            curr_lexer->quote_is_transpose = false;
+            curr_lexer->convert_spaces_to_comma = true;
+            curr_lexer->looking_for_object_index = false;
 
             maybe_warn_separator_insert (',');
 
             COUNT_TOK_AND_RETURN (',');
           }
       }
   }
 
@@ -509,20 +509,20 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 
 <MATRIX_START>{SNLCMT}*;{SNLCMT}* {
     LEXER_DEBUG ("<MATRIX_START>{SNLCMT}*;{SNLCMT}*");
 
     scan_for_comments (yytext);
     fixup_column_count (yytext);
     eat_whitespace ();
 
-    lexer_flags.quote_is_transpose = false;
-    lexer_flags.convert_spaces_to_comma = true;
-    lexer_flags.looking_for_object_index = false;
-    lexer_flags.at_beginning_of_statement = false;
+    curr_lexer->quote_is_transpose = false;
+    curr_lexer->convert_spaces_to_comma = true;
+    curr_lexer->looking_for_object_index = false;
+    curr_lexer->at_beginning_of_statement = false;
 
     COUNT_TOK_AND_RETURN (';');
   }
 
 %{
 // In some cases, new lines can also become row separators.  If we
 // don't eat whitespace here we can end up inserting too many
 // semicolons.
@@ -533,68 +533,68 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 <MATRIX_START>{S}*{COMMENT}{SNLCMT}* |
 <MATRIX_START>{S}*{NL}{SNLCMT}* {
     LEXER_DEBUG ("<MATRIX_START>{S}*{COMMENT}{SNLCMT}*|<MATRIX_START>{S}*{NL}{SNLCMT}*");
 
     scan_for_comments (yytext);
     fixup_column_count (yytext);
     eat_whitespace ();
 
-    lexer_flags.quote_is_transpose = false;
-    lexer_flags.convert_spaces_to_comma = true;
-    lexer_flags.at_beginning_of_statement = false;
-
-    if (lexer_flags.nesting_level.none ())
+    curr_lexer->quote_is_transpose = false;
+    curr_lexer->convert_spaces_to_comma = true;
+    curr_lexer->at_beginning_of_statement = false;
+
+    if (curr_lexer->nesting_level.none ())
       return LEXICAL_ERROR;
 
-    if (! lexer_flags.looking_at_object_index.front ()
-        && lexer_flags.nesting_level.is_bracket_or_brace ())
+    if (! curr_lexer->looking_at_object_index.front ()
+        && curr_lexer->nesting_level.is_bracket_or_brace ())
       {
         maybe_warn_separator_insert (';');
 
         COUNT_TOK_AND_RETURN (';');
       }
   }
 
 \[{S}* {
     LEXER_DEBUG ("\\[{S}*");
 
-    lexer_flags.nesting_level.bracket ();
-
-    lexer_flags.looking_at_object_index.push_front (false);
-
-    lexer_flags.current_input_column += yyleng;
-    lexer_flags.quote_is_transpose = false;
-    lexer_flags.convert_spaces_to_comma = true;
-    lexer_flags.looking_for_object_index = false;
-    lexer_flags.at_beginning_of_statement = false;
-
-    if (lexer_flags.defining_func
-        && ! lexer_flags.parsed_function_name.top ())
-      lexer_flags.looking_at_return_list = true;
+    curr_lexer->nesting_level.bracket ();
+
+    curr_lexer->looking_at_object_index.push_front (false);
+
+    curr_lexer->current_input_column += yyleng;
+    curr_lexer->quote_is_transpose = false;
+    curr_lexer->convert_spaces_to_comma = true;
+    curr_lexer->looking_for_object_index = false;
+    curr_lexer->at_beginning_of_statement = false;
+
+    if (curr_lexer->defining_func
+        && ! curr_lexer->parsed_function_name.top ())
+      curr_lexer->looking_at_return_list = true;
     else
-      lexer_flags.looking_at_matrix_or_assign_lhs = true;
+      curr_lexer->looking_at_matrix_or_assign_lhs = true;
 
     promptflag--;
     eat_whitespace ();
 
-    lexer_flags.bracketflag++;
+    curr_lexer->bracketflag++;
     BEGIN (MATRIX_START);
     COUNT_TOK_AND_RETURN ('[');
   }
 
 \] {
     LEXER_DEBUG ("\\]");
 
-    lexer_flags.nesting_level.remove ();
-
-    lexer_flags.looking_at_object_index.pop_front ();
-
-    lexer_flags.looking_for_object_index = true;
-    lexer_flags.at_beginning_of_statement = false;
+    curr_lexer->nesting_level.remove ();
+
+    curr_lexer->looking_at_object_index.pop_front ();
+
+    curr_lexer->looking_for_object_index = true;
+    curr_lexer->at_beginning_of_statement = false;
 
     TOK_RETURN (']');
   }
 
 %{
 // Imaginary numbers.
 %}
 
@@ -618,50 +618,50 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
   }
 
 %{
 // Eat whitespace.  Whitespace inside matrix constants is handled by
 // the <MATRIX_START> start state code above.
 %}
 
 {S}* {
-    lexer_flags.current_input_column += yyleng;
+    curr_lexer->current_input_column += yyleng;
   }
 
 %{
 // Continuation lines.  Allow comments after continuations.
 %}
 
 {CONT}{S}*{NL} |
 {CONT}{S}*{COMMENT} {
     LEXER_DEBUG ("{CONT}{S}*{NL}|{CONT}{S}*{COMMENT}");
 
     if (yytext[0] == '\\')
       gripe_matlab_incompatible_continuation ();
     scan_for_comments (yytext);
     promptflag--;
-    lexer_flags.input_line_number++;
-    lexer_flags.current_input_column = 1;
+    curr_lexer->input_line_number++;
+    curr_lexer->current_input_column = 1;
   }
 
 %{
 // End of file.
 %}
 
 <<EOF>> {
     LEXER_DEBUG ("<<EOF>>");
 
-    if (lexer_flags.block_comment_nesting_level != 0)
+    if (curr_lexer->block_comment_nesting_level != 0)
       {
         warning ("block comment open at end of input");
 
         if ((reading_fcn_file || reading_script_file || reading_classdef_file)
             && ! curr_fcn_file_name.empty ())
           warning ("near line %d of file '%s.m'",
-                   lexer_flags.input_line_number, curr_fcn_file_name.c_str ());
+                   curr_lexer->input_line_number, curr_fcn_file_name.c_str ());
       }
 
     TOK_RETURN (END_OF_INPUT);
   }
 
 %{
 // Identifiers.  Truncate the token at the first space or tab but
 // don't write directly on yytext.
@@ -683,17 +683,17 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 {IDENT}@{IDENT}{S}* |
 {IDENT}@{IDENT}.{IDENT}{S}* {
     LEXER_DEBUG ("{IDENT}@{IDENT}{S}*|{IDENT}@{IDENT}.{IDENT}{S}*");
 
     int id_tok = handle_superclass_identifier ();
 
     if (id_tok >= 0)
       {
-        lexer_flags.looking_for_object_index = true;
+        curr_lexer->looking_for_object_index = true;
 
         COUNT_TOK_AND_RETURN (SUPERCLASSREF);
       }
   }
 
 %{
 // Metaclass query
 %}
@@ -701,82 +701,82 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 \?{IDENT}{S}* |
 \?{IDENT}\.{IDENT}{S}* {
     LEXER_DEBUG ("\\?{IDENT}{S}*|\\?{IDENT}\\.{IDENT}{S}*");
 
     int id_tok = handle_meta_identifier ();
 
     if (id_tok >= 0)
       {
-        lexer_flags.looking_for_object_index = true;
+        curr_lexer->looking_for_object_index = true;
 
         COUNT_TOK_AND_RETURN (METAQUERY);
       }
   }
 
 %{
 // Function handles and superclass references
 %}
 
 "@" {
     LEXER_DEBUG ("@");
 
-    lexer_flags.current_input_column++;
-
-    lexer_flags.quote_is_transpose = false;
-    lexer_flags.convert_spaces_to_comma = false;
-    lexer_flags.looking_at_function_handle++;
-    lexer_flags.looking_for_object_index = false;
-    lexer_flags.at_beginning_of_statement = false;
+    curr_lexer->current_input_column++;
+
+    curr_lexer->quote_is_transpose = false;
+    curr_lexer->convert_spaces_to_comma = false;
+    curr_lexer->looking_at_function_handle++;
+    curr_lexer->looking_for_object_index = false;
+    curr_lexer->at_beginning_of_statement = false;
 
     COUNT_TOK_AND_RETURN ('@');
 
   }
 
 %{
 // A new line character.  New line characters inside matrix constants
 // are handled by the <MATRIX_START> start state code above.  If closest
 // nesting is inside parentheses, don't return a row separator.
 %}
 
 {NL} {
     LEXER_DEBUG ("{NL}");
 
-    lexer_flags.input_line_number++;
-    lexer_flags.current_input_column = 1;
-
-    lexer_flags.quote_is_transpose = false;
-    lexer_flags.convert_spaces_to_comma = true;
-
-    if (lexer_flags.nesting_level.none ())
+    curr_lexer->input_line_number++;
+    curr_lexer->current_input_column = 1;
+
+    curr_lexer->quote_is_transpose = false;
+    curr_lexer->convert_spaces_to_comma = true;
+
+    if (curr_lexer->nesting_level.none ())
       {
-        lexer_flags.at_beginning_of_statement = true;
+        curr_lexer->at_beginning_of_statement = true;
         COUNT_TOK_AND_RETURN ('\n');
       }
-    else if (lexer_flags.nesting_level.is_paren ())
+    else if (curr_lexer->nesting_level.is_paren ())
       {
-        lexer_flags.at_beginning_of_statement = false;
+        curr_lexer->at_beginning_of_statement = false;
         gripe_matlab_incompatible ("bare newline inside parentheses");
       }
-    else if (lexer_flags.nesting_level.is_bracket_or_brace ())
+    else if (curr_lexer->nesting_level.is_bracket_or_brace ())
       return LEXICAL_ERROR;
   }
 
 %{
 // Single quote can either be the beginning of a string or a transpose
 // operator.
 %}
 
 "'" {
     LEXER_DEBUG ("'");
 
-    lexer_flags.current_input_column++;
-    lexer_flags.convert_spaces_to_comma = true;
-
-    if (lexer_flags.quote_is_transpose)
+    curr_lexer->current_input_column++;
+    curr_lexer->convert_spaces_to_comma = true;
+
+    if (curr_lexer->quote_is_transpose)
       {
         do_comma_insert_check ();
         COUNT_TOK_AND_RETURN (QUOTE);
       }
     else
       {
         int tok = handle_string ('\'');
         COUNT_TOK_AND_RETURN (tok);
@@ -785,30 +785,30 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 
 %{
 // Double quotes always begin strings.
 %}
 
 \" {
     LEXER_DEBUG ("\"");
 
-    lexer_flags.current_input_column++;
+    curr_lexer->current_input_column++;
     int tok = handle_string ('"');
 
     COUNT_TOK_AND_RETURN (tok);
 }
 
 %{
 // Gobble comments.
 %}
 
 {CCHAR} {
     LEXER_DEBUG ("{CCHAR}");
 
-    lexer_flags.looking_for_object_index = false;
+    curr_lexer->looking_for_object_index = false;
 
     xunput (yytext[0], yytext);
 
     bool eof = false;
     int tok = process_comment (false, eof);
 
     if (eof)
       TOK_RETURN (END_OF_INPUT);
@@ -818,21 +818,21 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 
 %{
 // Block comments.
 %}
 
 ^{S}*{CCHAR}\{{S}*{NL} {
     LEXER_DEBUG ("^{S}*{CCHAR}\\{{S}*{NL}");
 
-    lexer_flags.looking_for_object_index = false;
-
-    lexer_flags.input_line_number++;
-    lexer_flags.current_input_column = 1;
-    lexer_flags.block_comment_nesting_level++;
+    curr_lexer->looking_for_object_index = false;
+
+    curr_lexer->input_line_number++;
+    curr_lexer->current_input_column = 1;
+    curr_lexer->block_comment_nesting_level++;
     promptflag--;
 
     bool eof = false;
     process_comment (true, eof);
   }
 
 %{
 // Other operators.
@@ -860,17 +860,17 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 "<"     { LEXER_DEBUG ("<"); BIN_OP_RETURN (EXPR_LT, false, false); }
 ">"     { LEXER_DEBUG (">"); BIN_OP_RETURN (EXPR_GT, false, false); }
 "+"     { LEXER_DEBUG ("+"); BIN_OP_RETURN ('+', false, false); }
 "-"     { LEXER_DEBUG ("-"); BIN_OP_RETURN ('-', false, false); }
 "*"     { LEXER_DEBUG ("*"); BIN_OP_RETURN ('*', false, false); }
 "/"     { LEXER_DEBUG ("/"); BIN_OP_RETURN ('/', false, false); }
 "\\"    { LEXER_DEBUG ("\\"); BIN_OP_RETURN (LEFTDIV, false, false); }
 ";"     { LEXER_DEBUG (";"); BIN_OP_RETURN (';', true, true); }
-","     { LEXER_DEBUG (","); BIN_OP_RETURN (',', true, ! lexer_flags.looking_at_object_index.front ()); }
+","     { LEXER_DEBUG (","); BIN_OP_RETURN (',', true, ! curr_lexer->looking_at_object_index.front ()); }
 "^"     { LEXER_DEBUG ("^"); BIN_OP_RETURN (POW, false, false); }
 "**"    { LEXER_DEBUG ("**"); XBIN_OP_RETURN (POW, false, false); }
 "="     { LEXER_DEBUG ("="); BIN_OP_RETURN ('=', true, false); }
 "&&"    { LEXER_DEBUG ("&&"); BIN_OP_RETURN (EXPR_AND_AND, false, false); }
 "||"    { LEXER_DEBUG ("||"); BIN_OP_RETURN (EXPR_OR_OR, false, false); }
 "<<"    { LEXER_DEBUG ("<<"); XBIN_OP_RETURN (LSHIFT, false, false); }
 ">>"    { LEXER_DEBUG (">>"); XBIN_OP_RETURN (RSHIFT, false, false); }
 
@@ -886,57 +886,57 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 "(" {
     LEXER_DEBUG ("(");
 
     // If we are looking for an object index, then push TRUE for
     // looking_at_object_index.  Otherwise, just push whatever state
     // is current (so that we can pop it off the stack when we find
     // the matching close paren).
 
-    lexer_flags.looking_at_object_index.push_front
-      (lexer_flags.looking_for_object_index);
-
-    lexer_flags.looking_at_indirect_ref = false;
-    lexer_flags.looking_for_object_index = false;
-    lexer_flags.at_beginning_of_statement = false;
-
-    lexer_flags.nesting_level.paren ();
+    curr_lexer->looking_at_object_index.push_front
+      (curr_lexer->looking_for_object_index);
+
+    curr_lexer->looking_at_indirect_ref = false;
+    curr_lexer->looking_for_object_index = false;
+    curr_lexer->at_beginning_of_statement = false;
+
+    curr_lexer->nesting_level.paren ();
     promptflag--;
 
     TOK_RETURN ('(');
   }
 
 ")" {
     LEXER_DEBUG (")");
 
-    lexer_flags.nesting_level.remove ();
-    lexer_flags.current_input_column++;
-
-    lexer_flags.looking_at_object_index.pop_front ();
-
-    lexer_flags.quote_is_transpose = true;
-    lexer_flags.convert_spaces_to_comma
-      = (lexer_flags.nesting_level.is_bracket_or_brace ()
-         && ! lexer_flags.looking_at_anon_fcn_args);
-    lexer_flags.looking_for_object_index = true;
-    lexer_flags.at_beginning_of_statement = false;
-
-    if (lexer_flags.looking_at_anon_fcn_args)
-      lexer_flags.looking_at_anon_fcn_args = false;
+    curr_lexer->nesting_level.remove ();
+    curr_lexer->current_input_column++;
+
+    curr_lexer->looking_at_object_index.pop_front ();
+
+    curr_lexer->quote_is_transpose = true;
+    curr_lexer->convert_spaces_to_comma
+      = (curr_lexer->nesting_level.is_bracket_or_brace ()
+         && ! curr_lexer->looking_at_anon_fcn_args);
+    curr_lexer->looking_for_object_index = true;
+    curr_lexer->at_beginning_of_statement = false;
+
+    if (curr_lexer->looking_at_anon_fcn_args)
+      curr_lexer->looking_at_anon_fcn_args = false;
 
     do_comma_insert_check ();
 
     COUNT_TOK_AND_RETURN (')');
   }
 
 "." {
     LEXER_DEBUG (".");
 
-    lexer_flags.looking_for_object_index = false;
-    lexer_flags.at_beginning_of_statement = false;
+    curr_lexer->looking_for_object_index = false;
+    curr_lexer->at_beginning_of_statement = false;
 
     TOK_RETURN ('.');
   }
 
 "+="    { LEXER_DEBUG ("+="); XBIN_OP_RETURN (ADD_EQ, false, false); }
 "-="    { LEXER_DEBUG ("-="); XBIN_OP_RETURN (SUB_EQ, false, false); }
 "*="    { LEXER_DEBUG ("*="); XBIN_OP_RETURN (MUL_EQ, false, false); }
 "/="    { LEXER_DEBUG ("/="); XBIN_OP_RETURN (DIV_EQ, false, false); }
@@ -951,44 +951,44 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 "&="    { LEXER_DEBUG ("&="); XBIN_OP_RETURN (AND_EQ, false, false); }
 "|="    { LEXER_DEBUG ("|="); XBIN_OP_RETURN (OR_EQ, false, false); }
 "<<="   { LEXER_DEBUG ("<<="); XBIN_OP_RETURN (LSHIFT_EQ, false, false); }
 ">>="   { LEXER_DEBUG (">>="); XBIN_OP_RETURN (RSHIFT_EQ, false, false); }
 
 \{{S}* {
     LEXER_DEBUG ("\\{{S}*");
 
-    lexer_flags.nesting_level.brace ();
-
-    lexer_flags.looking_at_object_index.push_front
-      (lexer_flags.looking_for_object_index);
-
-    lexer_flags.current_input_column += yyleng;
-    lexer_flags.quote_is_transpose = false;
-    lexer_flags.convert_spaces_to_comma = true;
-    lexer_flags.looking_for_object_index = false;
-    lexer_flags.at_beginning_of_statement = false;
+    curr_lexer->nesting_level.brace ();
+
+    curr_lexer->looking_at_object_index.push_front
+      (curr_lexer->looking_for_object_index);
+
+    curr_lexer->current_input_column += yyleng;
+    curr_lexer->quote_is_transpose = false;
+    curr_lexer->convert_spaces_to_comma = true;
+    curr_lexer->looking_for_object_index = false;
+    curr_lexer->at_beginning_of_statement = false;
 
     promptflag--;
     eat_whitespace ();
 
-    lexer_flags.braceflag++;
+    curr_lexer->braceflag++;
     BEGIN (MATRIX_START);
     COUNT_TOK_AND_RETURN ('{');
   }
 
 "}" {
     LEXER_DEBUG ("}");
 
-    lexer_flags.looking_at_object_index.pop_front ();
-
-    lexer_flags.looking_for_object_index = true;
-    lexer_flags.at_beginning_of_statement = false;
-
-    lexer_flags.nesting_level.remove ();
+    curr_lexer->looking_at_object_index.pop_front ();
+
+    curr_lexer->looking_for_object_index = true;
+    curr_lexer->at_beginning_of_statement = false;
+
+    curr_lexer->nesting_level.remove ();
 
     TOK_RETURN ('}');
   }
 
 %{
 // Unrecognized input is a lexical error.
 %}
 
@@ -996,21 +996,21 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
     LEXER_DEBUG (".");
 
     xunput (yytext[0], yytext);
 
     int c = text_yyinput ();
 
     if (c != EOF)
       {
-        lexer_flags.current_input_column++;
+        curr_lexer->current_input_column++;
 
         error ("invalid character '%s' (ASCII %d) near line %d, column %d",
                undo_string_escape (static_cast<char> (c)), c,
-               lexer_flags.input_line_number, lexer_flags.current_input_column);
+               curr_lexer->input_line_number, curr_lexer->current_input_column);
 
         return LEXICAL_ERROR;
       }
     else
       TOK_RETURN (END_OF_INPUT);
   }
 
 %%
@@ -1027,18 +1027,18 @@ do_comma_insert_check (void)
 
   int c = text_yyinput ();
 
   xunput (c, yytext);
 
   if (spc_gobbled)
     xunput (' ', yytext);
 
-  lexer_flags.do_comma_insert = (! lexer_flags.looking_at_object_index.front ()
-                                 && lexer_flags.bracketflag && c == '[');
+  curr_lexer->do_comma_insert = (! curr_lexer->looking_at_object_index.front ()
+                                 && curr_lexer->bracketflag && c == '[');
 }
 
 // Fix things up for errors or interrupts.  The parser is never called
 // recursively, so it is always safe to reinitialize its state before
 // doing any parsing.
 
 void
 reset_parser (void)
@@ -1069,19 +1069,16 @@ reset_parser (void)
             || reading_script_file
             || get_input_from_eval_string
             || input_from_startup_file))
     yyrestart (stdin);
 
   // Clear the buffer for help text.
   while (! help_buf.empty ())
     help_buf.pop ();
-
-  // Reset other flags.
-  lexer_flags = lexical_feedback ();
 }
 
 static void
 display_character (char c)
 {
   if (isgraph (c))
     std::cerr << c;
   else
@@ -1253,53 +1250,53 @@ text_yyinput (void)
       if (c != '\n')
         {
           xunput (c, yytext);
           c = '\n';
         }
     }
 
   if (c == '\n')
-    lexer_flags.input_line_number++;
+    curr_lexer->input_line_number++;
 
   return c;
 }
 
 static void
 xunput (char c, char *buf)
 {
   if (lexer_debug_flag)
     {
       std::cerr << "U: ";
       display_character (c);
       std::cerr << std::endl;
     }
 
   if (c == '\n')
-    lexer_flags.input_line_number--;
+    curr_lexer->input_line_number--;
 
   yyunput (c, buf);
 }
 
 // If we read some newlines, we need figure out what column we're
 // really looking at.
 
 static void
 fixup_column_count (char *s)
 {
   char c;
   while ((c = *s++) != '\0')
     {
       if (c == '\n')
         {
-          lexer_flags.input_line_number++;
-          lexer_flags.current_input_column = 1;
+          curr_lexer->input_line_number++;
+          curr_lexer->current_input_column = 1;
         }
       else
-        lexer_flags.current_input_column++;
+        curr_lexer->current_input_column++;
     }
 }
 
 // Include these so that we don't have to link to libfl.a.
 
 int
 yywrap (void)
 {
@@ -1374,36 +1371,36 @@ delete_input_buffer (void *buf)
   delete_buffer (static_cast<YY_BUFFER_STATE> (buf));
 }
 
 static bool
 inside_any_object_index (void)
 {
   bool retval = false;
 
-  for (std::list<bool>::const_iterator i = lexer_flags.looking_at_object_index.begin ();
-       i != lexer_flags.looking_at_object_index.end (); i++)
+  for (std::list<bool>::const_iterator i = curr_lexer->looking_at_object_index.begin ();
+       i != curr_lexer->looking_at_object_index.end (); i++)
     {
       if (*i)
         {
           retval = true;
           break;
         }
     }
 
   return retval;
 }
 
 // Handle keywords.  Return -1 if the keyword should be ignored.
 
 static int
 is_keyword_token (const std::string& s)
 {
-  int l = lexer_flags.input_line_number;
-  int c = lexer_flags.current_input_column;
+  int l = curr_lexer->input_line_number;
+  int c = curr_lexer->current_input_column;
 
   int len = s.length ();
 
   const octave_kw *kw = octave_kw_hash::in_word_set (s.c_str (), len);
 
   if (kw)
     {
       yylval.tok_val = 0;
@@ -1412,176 +1409,176 @@ is_keyword_token (const std::string& s)
         {
         case break_kw:
         case catch_kw:
         case continue_kw:
         case else_kw:
         case otherwise_kw:
         case return_kw:
         case unwind_protect_cleanup_kw:
-          lexer_flags.at_beginning_of_statement = true;
+          curr_lexer->at_beginning_of_statement = true;
           break;
 
         case static_kw:
           if ((reading_fcn_file || reading_script_file
                || reading_classdef_file)
               && ! curr_fcn_file_full_name.empty ())
             warning_with_id ("Octave:deprecated-keyword",
                              "the 'static' keyword is obsolete and will be removed from a future version of Octave; please use 'persistent' instead; near line %d of file '%s'",
-                             lexer_flags.input_line_number,
+                             curr_lexer->input_line_number,
                              curr_fcn_file_full_name.c_str ());
           else
             warning_with_id ("Octave:deprecated-keyword",
                              "the 'static' keyword is obsolete and will be removed from a future version of Octave; please use 'persistent' instead; near line %d",
-                             lexer_flags.input_line_number);
+                             curr_lexer->input_line_number);
           // fall through ...
 
         case persistent_kw:
           break;
 
         case case_kw:
         case elseif_kw:
         case global_kw:
         case until_kw:
           break;
 
         case end_kw:
           if (inside_any_object_index ()
               || (! reading_classdef_file
-                  && (lexer_flags.defining_func
-                      && ! (lexer_flags.looking_at_return_list
-                            || lexer_flags.parsed_function_name.top ()))))
+                  && (curr_lexer->defining_func
+                      && ! (curr_lexer->looking_at_return_list
+                            || curr_lexer->parsed_function_name.top ()))))
             return 0;
 
           yylval.tok_val = new token (token::simple_end, l, c);
-          lexer_flags.at_beginning_of_statement = true;
+          curr_lexer->at_beginning_of_statement = true;
           break;
 
         case end_try_catch_kw:
           yylval.tok_val = new token (token::try_catch_end, l, c);
-          lexer_flags.at_beginning_of_statement = true;
+          curr_lexer->at_beginning_of_statement = true;
           break;
 
         case end_unwind_protect_kw:
           yylval.tok_val = new token (token::unwind_protect_end, l, c);
-          lexer_flags.at_beginning_of_statement = true;
+          curr_lexer->at_beginning_of_statement = true;
           break;
 
         case endfor_kw:
           yylval.tok_val = new token (token::for_end, l, c);
-          lexer_flags.at_beginning_of_statement = true;
+          curr_lexer->at_beginning_of_statement = true;
           break;
 
         case endfunction_kw:
           yylval.tok_val = new token (token::function_end, l, c);
-          lexer_flags.at_beginning_of_statement = true;
+          curr_lexer->at_beginning_of_statement = true;
           break;
 
         case endif_kw:
           yylval.tok_val = new token (token::if_end, l, c);
-          lexer_flags.at_beginning_of_statement = true;
+          curr_lexer->at_beginning_of_statement = true;
           break;
 
         case endparfor_kw:
           yylval.tok_val = new token (token::parfor_end, l, c);
-          lexer_flags.at_beginning_of_statement = true;
+          curr_lexer->at_beginning_of_statement = true;
           break;
 
         case endswitch_kw:
           yylval.tok_val = new token (token::switch_end, l, c);
-          lexer_flags.at_beginning_of_statement = true;
+          curr_lexer->at_beginning_of_statement = true;
           break;
 
         case endwhile_kw:
           yylval.tok_val = new token (token::while_end, l, c);
-          lexer_flags.at_beginning_of_statement = true;
+          curr_lexer->at_beginning_of_statement = true;
           break;
 
         case endclassdef_kw:
           yylval.tok_val = new token (token::classdef_end, l, c);
-          lexer_flags.at_beginning_of_statement = true;
+          curr_lexer->at_beginning_of_statement = true;
           break;
 
         case endenumeration_kw:
           yylval.tok_val = new token (token::enumeration_end, l, c);
-          lexer_flags.at_beginning_of_statement = true;
+          curr_lexer->at_beginning_of_statement = true;
           break;
 
         case endevents_kw:
           yylval.tok_val = new token (token::events_end, l, c);
-          lexer_flags.at_beginning_of_statement = true;
+          curr_lexer->at_beginning_of_statement = true;
           break;
 
         case endmethods_kw:
           yylval.tok_val = new token (token::methods_end, l, c);
-          lexer_flags.at_beginning_of_statement = true;
+          curr_lexer->at_beginning_of_statement = true;
           break;
 
         case endproperties_kw:
           yylval.tok_val = new token (token::properties_end, l, c);
-          lexer_flags.at_beginning_of_statement = true;
+          curr_lexer->at_beginning_of_statement = true;
           break;
 
 
         case for_kw:
         case parfor_kw:
         case while_kw:
           promptflag--;
-          lexer_flags.looping++;
+          curr_lexer->looping++;
           break;
 
         case do_kw:
-          lexer_flags.at_beginning_of_statement = true;
+          curr_lexer->at_beginning_of_statement = true;
           promptflag--;
-          lexer_flags.looping++;
+          curr_lexer->looping++;
           break;
 
         case try_kw:
         case unwind_protect_kw:
-          lexer_flags.at_beginning_of_statement = true;
+          curr_lexer->at_beginning_of_statement = true;
           promptflag--;
           break;
 
         case if_kw:
         case switch_kw:
           promptflag--;
           break;
 
         case get_kw:
         case set_kw:
           // 'get' and 'set' are keywords in classdef method
           // declarations.
-          if (! lexer_flags.maybe_classdef_get_set_method)
+          if (! curr_lexer->maybe_classdef_get_set_method)
             return 0;
           break;
 
         case enumeration_kw:
         case events_kw:
         case methods_kw:
         case properties_kw:
           // 'properties', 'methods' and 'events' are keywords for
           // classdef blocks.
-          if (! lexer_flags.parsing_classdef)
+          if (! curr_lexer->parsing_classdef)
             return 0;
           // fall through ...
 
         case classdef_kw:
           // 'classdef' is always a keyword.
           promptflag--;
           break;
 
         case function_kw:
           promptflag--;
 
-          lexer_flags.defining_func++;
-          lexer_flags.parsed_function_name.push (false);
+          curr_lexer->defining_func++;
+          curr_lexer->parsed_function_name.push (false);
 
           if (! (reading_fcn_file || reading_script_file
                  || reading_classdef_file))
-            lexer_flags.input_line_number = 1;
+            curr_lexer->input_line_number = 1;
           break;
 
         case magic_file_kw:
           {
             if ((reading_fcn_file || reading_script_file
                  || reading_classdef_file)
                 && ! curr_fcn_file_full_name.empty ())
               yylval.tok_val = new token (curr_fcn_file_full_name, l, c);
@@ -1608,77 +1605,77 @@ is_keyword_token (const std::string& s)
 
   return 0;
 }
 
 static bool
 is_variable (const std::string& name)
 {
   return (symbol_table::is_variable (name)
-          || (lexer_flags.pending_local_variables.find (name)
-              != lexer_flags.pending_local_variables.end ()));
+          || (curr_lexer->pending_local_variables.find (name)
+              != curr_lexer->pending_local_variables.end ()));
 }
 
 static std::string
 grab_block_comment (stream_reader& reader, bool& eof)
 {
   std::string buf;
 
   bool at_bol = true;
   bool look_for_marker = false;
 
   bool warned_incompatible = false;
 
   int c = 0;
 
   while ((c = reader.getc ()) != EOF)
     {
-      lexer_flags.current_input_column++;
+      curr_lexer->current_input_column++;
 
       if (look_for_marker)
         {
           at_bol = false;
           look_for_marker = false;
 
           if (c == '{' || c == '}')
             {
               std::string tmp_buf (1, static_cast<char> (c));
 
               int type = c;
 
               bool done = false;
 
               while ((c = reader.getc ()) != EOF && ! done)
                 {
-                  lexer_flags.current_input_column++;
+                  curr_lexer->current_input_column++;
 
                   switch (c)
                     {
                     case ' ':
                     case '\t':
                       tmp_buf += static_cast<char> (c);
                       break;
 
                     case '\n':
                       {
-                        lexer_flags.current_input_column = 0;
+                        curr_lexer->current_input_column = 0;
                         at_bol = true;
                         done = true;
 
                         if (type == '{')
                           {
-                            lexer_flags.block_comment_nesting_level++;
+                            curr_lexer->block_comment_nesting_level++;
                             promptflag--;
                           }
                         else
                           {
-                            lexer_flags.block_comment_nesting_level--;
+                            curr_lexer->block_comment_nesting_level--;
                             promptflag++;
 
-                            if (lexer_flags.block_comment_nesting_level == 0)
+                            if (curr_lexer->block_comment_nesting_level == 0)
                               {
                                 buf += grab_comment_block (reader, true, eof);
 
                                 return buf;
                               }
                           }
                       }
                       break;
@@ -1706,17 +1703,17 @@ grab_block_comment (stream_reader& reade
           look_for_marker = true;
         }
       else
         {
           buf += static_cast<char> (c);
 
           if (c == '\n')
             {
-              lexer_flags.current_input_column = 0;
+              curr_lexer->current_input_column = 0;
               at_bol = true;
             }
         }
     }
 
   if (c == EOF)
     eof = true;
 
@@ -1736,49 +1733,49 @@ grab_comment_block (stream_reader& reade
   bool in_comment = false;
 
   bool warned_incompatible = false;
 
   int c = 0;
 
   while ((c = reader.getc ()) != EOF)
     {
-      lexer_flags.current_input_column++;
+      curr_lexer->current_input_column++;
 
       if (begin_comment)
         {
           if (c == '%' || c == '#')
             {
               at_bol = false;
               continue;
             }
           else if (at_bol && c == '{')
             {
               std::string tmp_buf (1, static_cast<char> (c));
 
               bool done = false;
 
               while ((c = reader.getc ()) != EOF && ! done)
                 {
-                  lexer_flags.current_input_column++;
+                  curr_lexer->current_input_column++;
 
                   switch (c)
                     {
                     case ' ':
                     case '\t':
                       tmp_buf += static_cast<char> (c);
                       break;
 
                     case '\n':
                       {
-                        lexer_flags.current_input_column = 0;
+                        curr_lexer->current_input_column = 0;
                         at_bol = true;
                         done = true;
 
-                        lexer_flags.block_comment_nesting_level++;
+                        curr_lexer->block_comment_nesting_level++;
                         promptflag--;
 
                         buf += grab_block_comment (reader, eof);
 
                         in_comment = false;
 
                         if (eof)
                           goto done;
@@ -1803,17 +1800,17 @@ grab_comment_block (stream_reader& reade
 
       if (in_comment)
         {
           buf += static_cast<char> (c);
 
           if (c == '\n')
             {
               at_bol = true;
-              lexer_flags.current_input_column = 0;
+              curr_lexer->current_input_column = 0;
               in_comment = false;
 
               // FIXME -- bailing out here prevents things like
               //
               //    octave> # comment
               //    octave> x = 1
               //
               // from failing at the command line, while still
@@ -1843,17 +1840,17 @@ grab_comment_block (stream_reader& reade
               // fall through...
 
             case '%':
               in_comment = true;
               begin_comment = true;
               break;
 
             default:
-              lexer_flags.current_input_column--;
+              curr_lexer->current_input_column--;
               reader.ungetc (c);
               goto done;
             }
         }
     }
 
  done:
 
@@ -1900,37 +1897,37 @@ process_comment (bool start_in_block, bo
 
   std::string txt = start_in_block
     ? grab_block_comment (flex_reader, eof)
     : grab_comment_block (flex_reader, false, eof);
 
   if (lexer_debug_flag)
     std::cerr << "C: " << txt << std::endl;
 
-  if (help_txt.empty () && lexer_flags.nesting_level.none ())
+  if (help_txt.empty () && curr_lexer->nesting_level.none ())
     {
       if (! help_buf.empty ())
         help_buf.pop ();
 
       help_buf.push (txt);
     }
 
   octave_comment_buffer::append (txt);
 
-  lexer_flags.current_input_column = 1;
-  lexer_flags.quote_is_transpose = false;
-  lexer_flags.convert_spaces_to_comma = true;
-  lexer_flags.at_beginning_of_statement = true;
+  curr_lexer->current_input_column = 1;
+  curr_lexer->quote_is_transpose = false;
+  curr_lexer->convert_spaces_to_comma = true;
+  curr_lexer->at_beginning_of_statement = true;
 
   if (YY_START == COMMAND_START)
     BEGIN (INITIAL);
 
-  if (lexer_flags.nesting_level.none ())
+  if (curr_lexer->nesting_level.none ())
     return '\n';
-  else if (lexer_flags.nesting_level.is_bracket_or_brace ())
+  else if (curr_lexer->nesting_level.is_bracket_or_brace ())
     return ';';
   else
     return 0;
 }
 
 // Return 1 if the given character matches any character in the given
 // string.
 
@@ -2215,17 +2212,17 @@ eat_whitespace (void)
 
   bool in_comment = false;
   bool beginning_of_comment = false;
 
   int c = 0;
 
   while ((c = text_yyinput ()) != EOF)
     {
-      lexer_flags.current_input_column++;
+      curr_lexer->current_input_column++;
 
       switch (c)
         {
         case ' ':
         case '\t':
           if (in_comment)
             {
               comment_buf += static_cast<char> (c);
@@ -2239,17 +2236,17 @@ eat_whitespace (void)
           if (in_comment)
             {
               comment_buf += static_cast<char> (c);
               octave_comment_buffer::append (comment_buf);
               comment_buf.resize (0);
               in_comment = false;
               beginning_of_comment = false;
             }
-          lexer_flags.current_input_column = 0;
+          curr_lexer->current_input_column = 0;
           break;
 
         case '#':
         case '%':
           if (in_comment)
             {
               if (! beginning_of_comment)
                 comment_buf += static_cast<char> (c);
@@ -2304,17 +2301,17 @@ eat_whitespace (void)
         }
     }
 
   if (! comment_buf.empty ())
     octave_comment_buffer::append (comment_buf);
 
  done:
   xunput (c, yytext);
-  lexer_flags.current_input_column--;
+  curr_lexer->current_input_column--;
   return retval;
 }
 
 static inline bool
 looks_like_hex (const char *s, int len)
 {
   return (len > 2 && s[0] == '0' && (s[1] == 'x' || s[1] == 'X'));
 }
@@ -2346,27 +2343,27 @@ handle_number (void)
 
       delete [] tmp;
     }
 
   // If yytext doesn't contain a valid number, we are in deep doo doo.
 
   assert (nread == 1);
 
-  lexer_flags.quote_is_transpose = true;
-  lexer_flags.convert_spaces_to_comma = true;
-  lexer_flags.looking_for_object_index = false;
-  lexer_flags.at_beginning_of_statement = false;
-
-  yylval.tok_val = new token (value, yytext, lexer_flags.input_line_number,
-                              lexer_flags.current_input_column);
+  curr_lexer->quote_is_transpose = true;
+  curr_lexer->convert_spaces_to_comma = true;
+  curr_lexer->looking_for_object_index = false;
+  curr_lexer->at_beginning_of_statement = false;
+
+  yylval.tok_val = new token (value, yytext, curr_lexer->input_line_number,
+                              curr_lexer->current_input_column);
 
   token_stack.push (yylval.tok_val);
 
-  lexer_flags.current_input_column += yyleng;
+  curr_lexer->current_input_column += yyleng;
 
   do_comma_insert_check ();
 }
 
 // We have seen a backslash and need to find out if it should be
 // treated as a continuation character.  If so, this eats it, up to
 // and including the new line character.
 //
@@ -2425,17 +2422,17 @@ have_continuation (bool trailing_comment
           break;
 
         case '\n':
           if (in_comment)
             {
               comment_buf += static_cast<char> (c);
               octave_comment_buffer::append (comment_buf);
             }
-          lexer_flags.current_input_column = 0;
+          curr_lexer->current_input_column = 0;
           promptflag--;
           gripe_matlab_incompatible_continuation ();
           return true;
 
         default:
           if (in_comment)
             {
               comment_buf += static_cast<char> (c);
@@ -2505,25 +2502,25 @@ eat_continuation (void)
   return retval;
 }
 
 static int
 handle_string (char delim)
 {
   std::ostringstream buf;
 
-  int bos_line = lexer_flags.input_line_number;
-  int bos_col = lexer_flags.current_input_column;
+  int bos_line = curr_lexer->input_line_number;
+  int bos_col = curr_lexer->current_input_column;
 
   int c;
   int escape_pending = 0;
 
   while ((c = text_yyinput ()) != EOF)
     {
-      lexer_flags.current_input_column++;
+      curr_lexer->current_input_column++;
 
       if (c == '\\')
         {
           if (delim == '\'' || escape_pending)
             {
               buf << static_cast<char> (c);
               escape_pending = 0;
             }
@@ -2565,29 +2562,29 @@ handle_string (char delim)
                   std::string s;
                   xunput (c, yytext);
 
                   if (delim == '\'')
                     s = buf.str ();
                   else
                     s = do_string_escapes (buf.str ());
 
-                  lexer_flags.quote_is_transpose = true;
-                  lexer_flags.convert_spaces_to_comma = true;
+                  curr_lexer->quote_is_transpose = true;
+                  curr_lexer->convert_spaces_to_comma = true;
 
                   yylval.tok_val = new token (s, bos_line, bos_col);
                   token_stack.push (yylval.tok_val);
 
                   if (delim == '"')
                     gripe_matlab_incompatible ("\" used as string delimiter");
                   else if (delim == '\'')
                     gripe_single_quote_string ();
 
-                  lexer_flags.looking_for_object_index = true;
-                  lexer_flags.at_beginning_of_statement = false;
+                  curr_lexer->looking_for_object_index = true;
+                  curr_lexer->at_beginning_of_statement = false;
 
                   return delim == '"' ? DQ_STRING : SQ_STRING;
                 }
             }
         }
       else
         {
           buf << static_cast<char> (c);
@@ -2691,42 +2688,42 @@ next_token_is_index_op (void)
   return c == '(' || c == '{';
 }
 
 static int
 handle_close_bracket (bool spc_gobbled, int bracket_type)
 {
   int retval = bracket_type;
 
-  if (! lexer_flags.nesting_level.none ())
+  if (! curr_lexer->nesting_level.none ())
     {
-      lexer_flags.nesting_level.remove ();
+      curr_lexer->nesting_level.remove ();
 
       if (bracket_type == ']')
-        lexer_flags.bracketflag--;
+        curr_lexer->bracketflag--;
       else if (bracket_type == '}')
-        lexer_flags.braceflag--;
+        curr_lexer->braceflag--;
       else
         panic_impossible ();
     }
 
-  if (lexer_flags.bracketflag == 0 && lexer_flags.braceflag == 0)
+  if (curr_lexer->bracketflag == 0 && curr_lexer->braceflag == 0)
     BEGIN (INITIAL);
 
   if (bracket_type == ']'
       && next_token_is_assign_op ()
-      && ! lexer_flags.looking_at_return_list)
+      && ! curr_lexer->looking_at_return_list)
     {
       retval = CLOSE_BRACE;
     }
-  else if ((lexer_flags.bracketflag || lexer_flags.braceflag)
-           && lexer_flags.convert_spaces_to_comma
-           && (lexer_flags.nesting_level.is_bracket ()
-               || (lexer_flags.nesting_level.is_brace ()
-                   && ! lexer_flags.looking_at_object_index.front ())))
+  else if ((curr_lexer->bracketflag || curr_lexer->braceflag)
+           && curr_lexer->convert_spaces_to_comma
+           && (curr_lexer->nesting_level.is_bracket ()
+               || (curr_lexer->nesting_level.is_brace ()
+                   && ! curr_lexer->looking_at_object_index.front ())))
     {
       bool index_op = next_token_is_index_op ();
 
       // Don't insert comma if we are looking at something like
       //
       //   [x{i}{j}] or [x{i}(j)]
       //
       // but do if we are looking at
@@ -2746,28 +2743,28 @@ handle_close_bracket (bool spc_gobbled, 
               maybe_warn_separator_insert (',');
 
               xunput (',', yytext);
               return retval;
             }
         }
     }
 
-  lexer_flags.quote_is_transpose = true;
-  lexer_flags.convert_spaces_to_comma = true;
+  curr_lexer->quote_is_transpose = true;
+  curr_lexer->convert_spaces_to_comma = true;
 
   return retval;
 }
 
 static void
 maybe_unput_comma (int spc_gobbled)
 {
-  if (lexer_flags.nesting_level.is_bracket ()
-      || (lexer_flags.nesting_level.is_brace ()
-          && ! lexer_flags.looking_at_object_index.front ()))
+  if (curr_lexer->nesting_level.is_bracket ()
+      || (curr_lexer->nesting_level.is_brace ()
+          && ! curr_lexer->looking_at_object_index.front ()))
     {
       int bin_op = next_token_is_bin_op (spc_gobbled);
 
       int postfix_un_op = next_token_is_postfix_unary_op (spc_gobbled);
 
       int c1 = text_yyinput ();
       int c2 = text_yyinput ();
 
@@ -3085,22 +3082,22 @@ handle_superclass_identifier (void)
       error ("method, class and package names may not be keywords");
       return LEXICAL_ERROR;
     }
 
   yylval.tok_val
     = new token (meth.empty () ? 0 : &(symbol_table::insert (meth)),
                  cls.empty () ? 0 : &(symbol_table::insert (cls)),
                  pkg.empty () ? 0 : &(symbol_table::insert (pkg)),
-                 lexer_flags.input_line_number,
-                 lexer_flags.current_input_column);
+                 curr_lexer->input_line_number,
+                 curr_lexer->current_input_column);
   token_stack.push (yylval.tok_val);
 
-  lexer_flags.convert_spaces_to_comma = true;
-  lexer_flags.current_input_column += yyleng;
+  curr_lexer->convert_spaces_to_comma = true;
+  curr_lexer->current_input_column += yyleng;
 
   return SUPERCLASSREF;
 }
 
 static int
 handle_meta_identifier (void)
 {
   eat_continuation ();
@@ -3120,117 +3117,117 @@ handle_meta_identifier (void)
     {
        error ("class and package names may not be keywords");
       return LEXICAL_ERROR;
     }
 
   yylval.tok_val
     = new token (cls.empty () ? 0 : &(symbol_table::insert (cls)),
                  pkg.empty () ? 0 : &(symbol_table::insert (pkg)),
-                 lexer_flags.input_line_number,
-                 lexer_flags.current_input_column);
+                 curr_lexer->input_line_number,
+                 curr_lexer->current_input_column);
 
   token_stack.push (yylval.tok_val);
 
-  lexer_flags.convert_spaces_to_comma = true;
-  lexer_flags.current_input_column += yyleng;
+  curr_lexer->convert_spaces_to_comma = true;
+  curr_lexer->current_input_column += yyleng;
 
   return METAQUERY;
 }
 
 // Figure out exactly what kind of token to return when we have seen
 // an identifier.  Handles keywords.  Return -1 if the identifier
 // should be ignored.
 
 static int
 handle_identifier (void)
 {
-  bool at_bos = lexer_flags.at_beginning_of_statement;
+  bool at_bos = curr_lexer->at_beginning_of_statement;
 
   std::string tok = strip_trailing_whitespace (yytext);
 
   int c = yytext[yyleng-1];
 
   bool cont_is_spc = (eat_continuation () != lexical_feedback::NO_WHITESPACE);
 
   int spc_gobbled = (cont_is_spc || c == ' ' || c == '\t');
 
   // If we are expecting a structure element, avoid recognizing
   // keywords and other special names and return STRUCT_ELT, which is
   // a string that is also a valid identifier.  But first, we have to
   // decide whether to insert a comma.
 
-  if (lexer_flags.looking_at_indirect_ref)
+  if (curr_lexer->looking_at_indirect_ref)
     {
       do_comma_insert_check ();
 
       maybe_unput_comma (spc_gobbled);
 
-      yylval.tok_val = new token (tok, lexer_flags.input_line_number,
-                                  lexer_flags.current_input_column);
+      yylval.tok_val = new token (tok, curr_lexer->input_line_number,
+                                  curr_lexer->current_input_column);
 
       token_stack.push (yylval.tok_val);
 
-      lexer_flags.quote_is_transpose = true;
-      lexer_flags.convert_spaces_to_comma = true;
-      lexer_flags.looking_for_object_index = true;
-
-      lexer_flags.current_input_column += yyleng;
+      curr_lexer->quote_is_transpose = true;
+      curr_lexer->convert_spaces_to_comma = true;
+      curr_lexer->looking_for_object_index = true;
+
+      curr_lexer->current_input_column += yyleng;
 
       return STRUCT_ELT;
     }
 
-  lexer_flags.at_beginning_of_statement = false;
+  curr_lexer->at_beginning_of_statement = false;
 
   // The is_keyword_token may reset
-  // lexer_flags.at_beginning_of_statement.  For example, if it sees
+  // curr_lexer->at_beginning_of_statement.  For example, if it sees
   // an else token, then the next token is at the beginning of a
   // statement.
 
   int kw_token = is_keyword_token (tok);
 
   // If we found a keyword token, then the beginning_of_statement flag
   // is already set.  Otherwise, we won't be at the beginning of a
   // statement.
 
-  if (lexer_flags.looking_at_function_handle)
+  if (curr_lexer->looking_at_function_handle)
     {
       if (kw_token)
         {
           error ("function handles may not refer to keywords");
 
           return LEXICAL_ERROR;
         }
       else
         {
-          yylval.tok_val = new token (tok, lexer_flags.input_line_number,
-                                      lexer_flags.current_input_column);
+          yylval.tok_val = new token (tok, curr_lexer->input_line_number,
+                                      curr_lexer->current_input_column);
 
           token_stack.push (yylval.tok_val);
 
-          lexer_flags.current_input_column += yyleng;
-          lexer_flags.quote_is_transpose = false;
-          lexer_flags.convert_spaces_to_comma = true;
-          lexer_flags.looking_for_object_index = true;
+          curr_lexer->current_input_column += yyleng;
+          curr_lexer->quote_is_transpose = false;
+          curr_lexer->convert_spaces_to_comma = true;
+          curr_lexer->looking_for_object_index = true;
 
           return FCN_HANDLE;
         }
     }
 
   // If we have a regular keyword, return it.
   // Keywords can be followed by identifiers.
 
   if (kw_token)
     {
       if (kw_token >= 0)
         {
-          lexer_flags.current_input_column += yyleng;
-          lexer_flags.quote_is_transpose = false;
-          lexer_flags.convert_spaces_to_comma = true;
-          lexer_flags.looking_for_object_index = false;
+          curr_lexer->current_input_column += yyleng;
+          curr_lexer->quote_is_transpose = false;
+          curr_lexer->convert_spaces_to_comma = true;
+          curr_lexer->looking_for_object_index = false;
         }
 
       return kw_token;
     }
 
   // See if we have a plot keyword (title, using, with, or clear).
 
   int c1 = text_yyinput ();
@@ -3260,59 +3257,59 @@ handle_identifier (void)
   if (! is_variable (tok))
     {
       if (at_bos && spc_gobbled && can_be_command (tok)
           && looks_like_command_arg ())
         {
           BEGIN (COMMAND_START);
         }
       else if (next_tok_is_eq
-               || lexer_flags.looking_at_decl_list
-               || lexer_flags.looking_at_return_list
-               || (lexer_flags.looking_at_parameter_list
-                   && ! lexer_flags.looking_at_initializer_expression))
+               || curr_lexer->looking_at_decl_list
+               || curr_lexer->looking_at_return_list
+               || (curr_lexer->looking_at_parameter_list
+                   && ! curr_lexer->looking_at_initializer_expression))
         {
           symbol_table::force_variable (tok);
         }
-      else if (lexer_flags.looking_at_matrix_or_assign_lhs)
+      else if (curr_lexer->looking_at_matrix_or_assign_lhs)
         {
-          lexer_flags.pending_local_variables.insert (tok);
+          curr_lexer->pending_local_variables.insert (tok);
         }
     }
 
   // Find the token in the symbol table.  Beware the magic
   // transformation of the end keyword...
 
   if (tok == "end")
     tok = "__end__";
 
   yylval.tok_val = new token (&(symbol_table::insert (tok)),
-                              lexer_flags.input_line_number,
-                              lexer_flags.current_input_column);
+                              curr_lexer->input_line_number,
+                              curr_lexer->current_input_column);
 
   token_stack.push (yylval.tok_val);
 
   // After seeing an identifer, it is ok to convert spaces to a comma
   // (if needed).
 
-  lexer_flags.convert_spaces_to_comma = true;
+  curr_lexer->convert_spaces_to_comma = true;
 
   if (! (next_tok_is_eq || YY_START == COMMAND_START))
     {
-      lexer_flags.quote_is_transpose = true;
+      curr_lexer->quote_is_transpose = true;
 
       do_comma_insert_check ();
 
       maybe_unput_comma (spc_gobbled);
     }
 
-  lexer_flags.current_input_column += yyleng;
+  curr_lexer->current_input_column += yyleng;
 
   if (tok != "__end__")
-    lexer_flags.looking_for_object_index = true;
+    curr_lexer->looking_for_object_index = true;
 
   return NAME;
 }
 
 bool
 is_keyword (const std::string& s)
 {
   // Parsing function names like "set.property_name" inside
@@ -3461,51 +3458,51 @@ octave_read (char *buf, unsigned max_siz
 static void
 maybe_warn_separator_insert (char sep)
 {
   std::string nm = curr_fcn_file_full_name;
 
   if (nm.empty ())
     warning_with_id ("Octave:separator-insert",
                      "potential auto-insertion of '%c' near line %d",
-                     sep, lexer_flags.input_line_number);
+                     sep, curr_lexer->input_line_number);
   else
     warning_with_id ("Octave:separator-insert",
                      "potential auto-insertion of '%c' near line %d of file %s",
-                     sep, lexer_flags.input_line_number, nm.c_str ());
+                     sep, curr_lexer->input_line_number, nm.c_str ());
 }
 
 static void
 gripe_single_quote_string (void)
 {
   std::string nm = curr_fcn_file_full_name;
 
   if (nm.empty ())
     warning_with_id ("Octave:single-quote-string",
                      "single quote delimited string near line %d",
-                     lexer_flags.input_line_number);
+                     curr_lexer->input_line_number);
   else
     warning_with_id ("Octave:single-quote-string",
                      "single quote delimited string near line %d of file %s",
-                     lexer_flags.input_line_number, nm.c_str ());
+                     curr_lexer->input_line_number, nm.c_str ());
 }
 
 static void
 gripe_matlab_incompatible (const std::string& msg)
 {
   std::string nm = curr_fcn_file_full_name;
 
   if (nm.empty ())
     warning_with_id ("Octave:matlab-incompatible",
                      "potential Matlab compatibility problem: %s",
                      msg.c_str ());
   else
     warning_with_id ("Octave:matlab-incompatible",
                      "potential Matlab compatibility problem: %s near line %d offile %s",
-                     msg.c_str (), lexer_flags.input_line_number, nm.c_str ());
+                     msg.c_str (), curr_lexer->input_line_number, nm.c_str ());
 }
 
 static void
 maybe_gripe_matlab_incompatible_comment (char c)
 {
   if (c == '#')
     gripe_matlab_incompatible ("# used as comment character");
 }
diff --git a/libinterp/parse-tree/oct-parse.yy b/libinterp/parse-tree/oct-parse.yy
--- a/libinterp/parse-tree/oct-parse.yy
+++ b/libinterp/parse-tree/oct-parse.yy
@@ -551,17 +551,17 @@ input           : input1
                 | parse_error
                   { ABORT_PARSE; }
                 ;
 
 input1          : '\n'
                   { $$ = 0; }
                 | END_OF_INPUT
                   {
-                    lexer_flags.parser_end_of_input = 1;
+                    curr_lexer->parser_end_of_input = 1;
                     $$ = 0;
                   }
                 | simple_list
                   { $$ = $1; }
                 | simple_list '\n'
                   { $$ = $1; }
                 | simple_list END_OF_INPUT
                   { $$ = $1; }
@@ -654,36 +654,36 @@ constant        : NUM
                   { $$ = make_constant (IMAG_NUM, $1); }
                 | string
                   { $$ = $1; }
                 ;
 
 matrix          : '[' ']'
                   {
                     $$ = new tree_constant (octave_null_matrix::instance);
-                    lexer_flags.looking_at_matrix_or_assign_lhs = false;
-                    lexer_flags.pending_local_variables.clear ();
+                    curr_lexer->looking_at_matrix_or_assign_lhs = false;
+                    curr_lexer->pending_local_variables.clear ();
                   }
                 | '[' ';' ']'
                   {
                     $$ = new tree_constant (octave_null_matrix::instance);
-                    lexer_flags.looking_at_matrix_or_assign_lhs = false;
-                    lexer_flags.pending_local_variables.clear ();
+                    curr_lexer->looking_at_matrix_or_assign_lhs = false;
+                    curr_lexer->pending_local_variables.clear ();
                   }
                 | '[' ',' ']'
                   {
                     $$ = new tree_constant (octave_null_matrix::instance);
-                    lexer_flags.looking_at_matrix_or_assign_lhs = false;
-                    lexer_flags.pending_local_variables.clear ();
+                    curr_lexer->looking_at_matrix_or_assign_lhs = false;
+                    curr_lexer->pending_local_variables.clear ();
                   }
                 | '[' matrix_rows ']'
                   {
                     $$ = finish_matrix ($2);
-                    lexer_flags.looking_at_matrix_or_assign_lhs = false;
-                    lexer_flags.pending_local_variables.clear ();
+                    curr_lexer->looking_at_matrix_or_assign_lhs = false;
+                    curr_lexer->pending_local_variables.clear ();
                   }
                 ;
 
 matrix_rows     : matrix_rows1
                   { $$ = $1; }
                 | matrix_rows1 ';'      // Ignore trailing semicolon.
                   { $$ = $1; }
                 ;
@@ -725,23 +725,23 @@ cell_or_matrix_row
                   { $$ = validate_matrix_row ($1); }
                 | arg_list ','  // Ignore trailing comma.
                   { $$ = validate_matrix_row ($1); }
                 ;
 
 fcn_handle      : '@' FCN_HANDLE
                   {
                     $$ = make_fcn_handle ($2);
-                    lexer_flags.looking_at_function_handle--;
+                    curr_lexer->looking_at_function_handle--;
                   }
                 ;
 
 anon_fcn_handle : '@' param_list statement
                   {
-                    lexer_flags.quote_is_transpose = false;
+                    curr_lexer->quote_is_transpose = false;
                     $$ = make_anon_fcn_handle ($2, $3);
                   }
                 ;
 
 primary_expr    : identifier
                   { $$ = $1; }
                 | constant
                   { $$ = $1; }
@@ -791,17 +791,17 @@ arg_list        : expression
                 | arg_list ',' expression
                   {
                     $1->append ($3);
                     $$ = $1;
                   }
                 ;
 
 indirect_ref_op : '.'
-                  { lexer_flags.looking_at_indirect_ref = true; }
+                  { curr_lexer->looking_at_indirect_ref = true; }
                 ;
 
 oper_expr       : primary_expr
                   { $$ = $1; }
                 | oper_expr PLUS_PLUS
                   { $$ = make_postfix_op (PLUS_PLUS, $1, $2); }
                 | oper_expr MINUS_MINUS
                   { $$ = make_postfix_op (MINUS_MINUS, $1, $2); }
@@ -904,24 +904,24 @@ simple_expr     : colon_expr
 assign_lhs      : simple_expr
                   {
                     $$ = new tree_argument_list ($1);
                     $$->mark_as_simple_assign_lhs ();
                   }
                 | '[' arg_list opt_comma CLOSE_BRACE
                   {
                     $$ = $2;
-                    lexer_flags.looking_at_matrix_or_assign_lhs = false;
-                    for (std::set<std::string>::const_iterator p = lexer_flags.pending_local_variables.begin ();
-                         p != lexer_flags.pending_local_variables.end ();
+                    curr_lexer->looking_at_matrix_or_assign_lhs = false;
+                    for (std::set<std::string>::const_iterator p = curr_lexer->pending_local_variables.begin ();
+                         p != curr_lexer->pending_local_variables.end ();
                          p++)
                       {
                         symbol_table::force_variable (*p);
                       }
-                    lexer_flags.pending_local_variables.clear ();
+                    curr_lexer->pending_local_variables.clear ();
                   }
                 ;
 
 assign_expr     : assign_lhs '=' expression
                   { $$ = make_assign_op ('=', $1, $2, $3); }
                 | assign_lhs ADD_EQ expression
                   { $$ = make_assign_op (ADD_EQ, $1, $2, $3); }
                 | assign_lhs SUB_EQ expression
@@ -983,47 +983,47 @@ command         : declaration
                 ;
 
 // =====================
 // Declaration statemnts
 // =====================
 
 parsing_decl_list
                 : // empty
-                  { lexer_flags.looking_at_decl_list = true; }
+                  { curr_lexer->looking_at_decl_list = true; }
 
 declaration     : GLOBAL parsing_decl_list decl1
                   {
                     $$ = make_decl_command (GLOBAL, $1, $3);
-                    lexer_flags.looking_at_decl_list = false;
+                    curr_lexer->looking_at_decl_list = false;
                   }
                 | PERSISTENT parsing_decl_list decl1
                   {
                     $$ = make_decl_command (PERSISTENT, $1, $3);
-                    lexer_flags.looking_at_decl_list = false;
+                    curr_lexer->looking_at_decl_list = false;
                   }
                 ;
 
 decl1           : decl2
                   { $$ = new tree_decl_init_list ($1); }
                 | decl1 decl2
                   {
                     $1->append ($2);
                     $$ = $1;
                   }
                 ;
 
 decl_param_init : // empty
-                { lexer_flags.looking_at_initializer_expression = true; }
+                { curr_lexer->looking_at_initializer_expression = true; }
 
 decl2           : identifier
                   { $$ = new tree_decl_elt ($1); }
                 | identifier '=' decl_param_init expression
                   {
-                    lexer_flags.looking_at_initializer_expression = false;
+                    curr_lexer->looking_at_initializer_expression = false;
                     $$ = new tree_decl_elt ($1, $4);
                   }
                 | magic_tilde
                   {
                     $$ = new tree_decl_elt ($1);
                   }
                 ;
 
@@ -1238,38 +1238,38 @@ push_fcn_symtab : // empty
                 ;
 
 // ===========================
 // List of function parameters
 // ===========================
 
 param_list_beg  : '('
                   {
-                    lexer_flags.looking_at_parameter_list = true;
-
-                    if (lexer_flags.looking_at_function_handle)
+                    curr_lexer->looking_at_parameter_list = true;
+
+                    if (curr_lexer->looking_at_function_handle)
                       {
                         parser_symtab_context.push ();
                         symbol_table::set_scope (symbol_table::alloc_scope ());
-                        lexer_flags.looking_at_function_handle--;
-                        lexer_flags.looking_at_anon_fcn_args = true;
+                        curr_lexer->looking_at_function_handle--;
+                        curr_lexer->looking_at_anon_fcn_args = true;
                       }
                   }
                 ;
 
 param_list_end  : ')'
                   {
-                    lexer_flags.looking_at_parameter_list = false;
-                    lexer_flags.looking_for_object_index = false;
+                    curr_lexer->looking_at_parameter_list = false;
+                    curr_lexer->looking_for_object_index = false;
                   }
                 ;
 
 param_list      : param_list_beg param_list1 param_list_end
                   {
-                    lexer_flags.quote_is_transpose = false;
+                    curr_lexer->quote_is_transpose = false;
                     $$ = $2;
                   }
                 | param_list_beg error
                   {
                     yyerror ("invalid parameter list");
                     $$ = 0;
                     ABORT_PARSE;
                   }
@@ -1297,30 +1297,30 @@ param_list2     : decl2
                 ;
 
 // ===================================
 // List of function return value names
 // ===================================
 
 return_list     : '[' ']'
                   {
-                    lexer_flags.looking_at_return_list = false;
+                    curr_lexer->looking_at_return_list = false;
                     $$ = new tree_parameter_list ();
                   }
                 | return_list1
                   {
-                    lexer_flags.looking_at_return_list = false;
+                    curr_lexer->looking_at_return_list = false;
                     if ($1->validate (tree_parameter_list::out))
                       $$ = $1;
                     else
                       ABORT_PARSE;
                   }
                 | '[' return_list1 ']'
                   {
-                    lexer_flags.looking_at_return_list = false;
+                    curr_lexer->looking_at_return_list = false;
                     if ($2->validate (tree_parameter_list::out))
                       $$ = $2;
                     else
                       ABORT_PARSE;
                   }
                 ;
 
 return_list1    : identifier
@@ -1334,18 +1334,18 @@ return_list1    : identifier
 
 // ===========
 // Script file
 // ===========
 
 script_file     : SCRIPT_FILE opt_list END_OF_INPUT
                   {
                     tree_statement *end_of_script
-                      = make_end ("endscript", lexer_flags.input_line_number,
-                                  lexer_flags.current_input_column);
+                      = make_end ("endscript", curr_lexer->input_line_number,
+                                  curr_lexer->current_input_column);
 
                     make_script ($2, end_of_script);
 
                     $$ = 0;
                   }
                 ;
 
 // =============
@@ -1363,18 +1363,18 @@ function_list   : function
 // ===================
 // Function definition
 // ===================
 
 function_beg    : push_fcn_symtab FCN stash_comment
                   {
                     $$ = $3;
 
-                    if (reading_classdef_file || lexer_flags.parsing_classdef)
-                      lexer_flags.maybe_classdef_get_set_method = true;
+                    if (reading_classdef_file || curr_lexer->parsing_classdef)
+                      curr_lexer->maybe_classdef_get_set_method = true;
                   }
                 ;
 
 function        : function_beg function1
                   {
                     $$ = finish_function (0, $2, $1);
                     recover_from_parsing_function ();
                   }
@@ -1384,31 +1384,31 @@ function        : function_beg function1
                     recover_from_parsing_function ();
                   }
                 ;
 
 fcn_name        : identifier
                   {
                     std::string id_name = $1->name ();
 
-                    lexer_flags.parsed_function_name.top () = true;
-                    lexer_flags.maybe_classdef_get_set_method = false;
+                    curr_lexer->parsed_function_name.top () = true;
+                    curr_lexer->maybe_classdef_get_set_method = false;
 
                     $$ = $1;
                   }
                 | GET '.' identifier
                   {
-                    lexer_flags.parsed_function_name.top () = true;
-                    lexer_flags.maybe_classdef_get_set_method = false;
+                    curr_lexer->parsed_function_name.top () = true;
+                    curr_lexer->maybe_classdef_get_set_method = false;
                     $$ = $3;
                   }
                 | SET '.' identifier
                   {
-                    lexer_flags.parsed_function_name.top () = true;
-                    lexer_flags.maybe_classdef_get_set_method = false;
+                    curr_lexer->parsed_function_name.top () = true;
+                    curr_lexer->maybe_classdef_get_set_method = false;
                     $$ = $3;
                   }
                 ;
 
 function1       : fcn_name function2
                   {
                     std::string fname = $1->name ();
 
@@ -1458,35 +1458,35 @@ function_end    : END
                       }
 
                     if (reading_classdef_file)
                       {
                         yyerror ("classdef body open at end of input");
                         YYABORT;
                       }
 
-                    $$ = make_end ("endfunction", lexer_flags.input_line_number,
-                                   lexer_flags.current_input_column);
+                    $$ = make_end ("endfunction", curr_lexer->input_line_number,
+                                   curr_lexer->current_input_column);
                   }
                 ;
 
 // ========
 // Classdef
 // ========
 
 classdef_beg    : CLASSDEF stash_comment
                   {
                     $$ = 0;
-                    lexer_flags.parsing_classdef = true;
+                    curr_lexer->parsing_classdef = true;
                   }
                 ;
 
 classdef_end    : END
                   {
-                    lexer_flags.parsing_classdef = false;
+                    curr_lexer->parsing_classdef = false;
 
                     if (end_token_ok ($1, token::classdef_end))
                       $$ = make_end ("endclassdef", $1->line (), $1->column ());
                     else
                       ABORT_PARSE;
                   }
                 ;
 
@@ -1682,22 +1682,22 @@ opt_comma       : // empty
 
 %%
 
 // Generic error messages.
 
 static void
 yyerror (const char *s)
 {
-  int err_col = lexer_flags.current_input_column - 1;
+  int err_col = curr_lexer->current_input_column - 1;
 
   std::ostringstream output_buf;
 
   if (reading_fcn_file || reading_script_file || reading_classdef_file)
-    output_buf << "parse error near line " << lexer_flags.input_line_number
+    output_buf << "parse error near line " << curr_lexer->input_line_number
                << " of file " << curr_fcn_file_full_name;
   else
     output_buf << "parse error:";
 
   if (s && strcmp (s, "parse error") != 0)
     output_buf << "\n\n  " << s;
 
   output_buf << "\n\n";
@@ -2119,18 +2119,18 @@ make_fcn_handle (token *tok_val)
 }
 
 // Make an anonymous function handle.
 
 static tree_anon_fcn_handle *
 make_anon_fcn_handle (tree_parameter_list *param_list, tree_statement *stmt)
 {
   // FIXME -- need to get these from the location of the @ symbol.
-  int l = lexer_flags.input_line_number;
-  int c = lexer_flags.current_input_column;
+  int l = curr_lexer->input_line_number;
+  int c = curr_lexer->current_input_column;
 
   tree_parameter_list *ret_list = 0;
 
   symbol_table::scope_id fcn_scope = symbol_table::current_scope ();
 
   if (parser_symtab_context.empty ())
     panic_impossible ();
 
@@ -2425,17 +2425,17 @@ make_while_command (token *while_tok, tr
   tree_command *retval = 0;
 
   maybe_warn_assign_as_truth_value (expr);
 
   if (end_token_ok (end_tok, token::while_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
-      lexer_flags.looping--;
+      curr_lexer->looping--;
 
       int l = while_tok->line ();
       int c = while_tok->column ();
 
       retval = new tree_while_command (expr, body, lc, tc, l, c);
     }
 
   return retval;
@@ -2448,17 +2448,17 @@ make_do_until_command (token *until_tok,
                        tree_expression *expr, octave_comment_list *lc)
 {
   tree_command *retval = 0;
 
   maybe_warn_assign_as_truth_value (expr);
 
   octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
-  lexer_flags.looping--;
+  curr_lexer->looping--;
 
   int l = until_tok->line ();
   int c = until_tok->column ();
 
   retval = new tree_do_until_command (expr, body, lc, tc, l, c);
 
   return retval;
 }
@@ -2474,17 +2474,17 @@ make_for_command (int tok_id, token *for
   tree_command *retval = 0;
 
   bool parfor = tok_id == PARFOR;
 
   if (end_token_ok (end_tok, parfor ? token::parfor_end : token::for_end))
     {
       octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
-      lexer_flags.looping--;
+      curr_lexer->looping--;
 
       int l = for_tok->line ();
       int c = for_tok->column ();
 
       if (lhs->length () == 1)
         {
           tree_expression *tmp = lhs->remove_front ();
 
@@ -2871,17 +2871,17 @@ frob_function (const std::string& fname,
           fcn->stash_parent_fcn_name (curr_fcn_file_name);
 
           if (current_function_depth > 1)
             fcn->stash_parent_fcn_scope (function_scopes[function_scopes.size ()-2]);
           else
             fcn->stash_parent_fcn_scope (primary_fcn_scope);
         }
 
-      if (lexer_flags.parsing_class_method)
+      if (curr_lexer->parsing_class_method)
         {
           if (current_class_name == id_name)
             fcn->mark_as_class_constructor ();
           else
             fcn->mark_as_class_method ();
 
           fcn->stash_dispatch_class (current_class_name);
         }
@@ -2898,18 +2898,18 @@ frob_function (const std::string& fname,
            && reading_script_file
            && curr_fcn_file_name == id_name)
     {
       warning ("function '%s' defined within script file '%s'",
                id_name.c_str (), curr_fcn_file_full_name.c_str ());
     }
 
   fcn->stash_function_name (id_name);
-  fcn->stash_fcn_location (lexer_flags.input_line_number,
-                           lexer_flags.current_input_column);
+  fcn->stash_fcn_location (curr_lexer->input_line_number,
+                           curr_lexer->current_input_column);
 
   if (! help_buf.empty () && current_function_depth == 1
       && ! parsing_subfunctions)
     {
       fcn->document (help_buf.top ());
 
       help_buf.pop ();
     }
@@ -3001,20 +3001,20 @@ recover_from_parsing_function (void)
 
   if (reading_fcn_file && current_function_depth == 1
       && ! parsing_subfunctions)
     parsing_subfunctions = true;
 
   current_function_depth--;
   function_scopes.pop_back ();
 
-  lexer_flags.defining_func--;
-  lexer_flags.parsed_function_name.pop ();
-  lexer_flags.looking_at_return_list = false;
-  lexer_flags.looking_at_parameter_list = false;
+  curr_lexer->defining_func--;
+  curr_lexer->parsed_function_name.pop ();
+  curr_lexer->looking_at_return_list = false;
+  curr_lexer->looking_at_parameter_list = false;
 }
 
 // Make an index expression.
 
 static tree_index_expression *
 make_index_expression (tree_expression *expr, tree_argument_list *args,
                        char type)
 {
@@ -3061,17 +3061,17 @@ make_indirect_ref (tree_expression *expr
 
       tmp->append (elt);
 
       retval = tmp;
     }
   else
     retval = new tree_index_expression (expr, elt, l, c);
 
-  lexer_flags.looking_at_indirect_ref = false;
+  curr_lexer->looking_at_indirect_ref = false;
 
   return retval;
 }
 
 // Make an indirect reference expression with dynamic field name.
 
 static tree_index_expression *
 make_indirect_ref (tree_expression *expr, tree_expression *elt)
@@ -3087,17 +3087,17 @@ make_indirect_ref (tree_expression *expr
 
       tmp->append (elt);
 
       retval = tmp;
     }
   else
     retval = new tree_index_expression (expr, elt, l, c);
 
-  lexer_flags.looking_at_indirect_ref = false;
+  curr_lexer->looking_at_indirect_ref = false;
 
   return retval;
 }
 
 // Make a declaration command.
 
 static tree_decl_command *
 make_decl_command (int tok, token *tok_val, tree_decl_init_list *lst)
@@ -3308,32 +3308,32 @@ text_getc (FILE *f)
       if (c != '\n')
         {
           ungetc (c, f);
           c = '\n';
         }
     }
 
   if (c == '\n')
-    lexer_flags.input_line_number++;
+    curr_lexer->input_line_number++;
 
   return c;
 }
 
 class
 stdio_stream_reader : public stream_reader
 {
 public:
   stdio_stream_reader (FILE *f_arg) : stream_reader (), f (f_arg) { }
 
   int getc (void) { return ::text_getc (f); }
   int ungetc (int c)
   {
     if (c == '\n')
-      lexer_flags.input_line_number--;
+      curr_lexer->input_line_number--;
 
     return ::ungetc (c, f);
   }
 
 private:
   FILE *f;
 
   // No copying!
@@ -3349,21 +3349,21 @@ skip_white_space (stream_reader& reader)
   int c = 0;
 
   while ((c = reader.getc ()) != EOF)
     {
       switch (c)
         {
         case ' ':
         case '\t':
-          lexer_flags.current_input_column++;
+          curr_lexer->current_input_column++;
           break;
 
         case '\n':
-          lexer_flags.current_input_column = 1;
+          curr_lexer->current_input_column = 1;
           break;
 
         default:
           reader.ungetc (c);
           goto done;
         }
     }
 
@@ -3494,19 +3494,20 @@ parse_fcn_file (const std::string& ff, c
   FILE *ffile = get_input_from_file (ff, 0);
 
   frame.add_fcn (safe_fclose, ffile);
 
   if (ffile)
     {
       bool eof;
 
-      frame.protect_var (lexer_flags);
-
-      // Also resets lexer_flags.
+      frame.protect_var (curr_lexer);
+
+      curr_lexer = new lexical_feedback ();
+
       reset_parser ();
 
       std::string help_txt = gobble_leading_white_space (ffile, eof);
 
       if (! help_txt.empty ())
         help_buf.push (help_txt);
 
       if (! eof)
@@ -3576,17 +3577,17 @@ parse_fcn_file (const std::string& ff, c
           if (! help_txt.empty ())
             help_buf.push (help_txt);
 
           if (reading_script_file)
             prep_lexer_for_script_file ();
           else
             prep_lexer_for_function_file ();
 
-          lexer_flags.parsing_class_method = ! dispatch_type.empty ();
+          curr_lexer->parsing_class_method = ! dispatch_type.empty ();
 
           frame.protect_var (global_command);
 
           global_command = 0;
 
           int status = octave_parse_input ();
 
           // Use an unwind-protect cleanup function so that the
@@ -3599,18 +3600,18 @@ parse_fcn_file (const std::string& ff, c
 
           if (status != 0)
             error ("parse error while reading %s file %s",
                    file_type.c_str (), ff.c_str ());
         }
       else
         {
           tree_statement *end_of_script
-            = make_end ("endscript", lexer_flags.input_line_number,
-                        lexer_flags.current_input_column);
+            = make_end ("endscript", curr_lexer->input_line_number,
+                        curr_lexer->current_input_column);
 
           make_script (0, end_of_script);
 
           fcn_ptr = primary_fcn_ptr;
         }
     }
   else if (require_file)
     error ("no such file, '%s'", ff.c_str ());
@@ -4299,31 +4300,31 @@ another function for the given type sign
 
 octave_value_list
 eval_string (const std::string& s, bool silent, int& parse_status, int nargout)
 {
   octave_value_list retval;
 
   unwind_protect frame;
 
-  frame.protect_var (lexer_flags);
+  frame.protect_var (curr_lexer);
 
   frame.protect_var (get_input_from_eval_string);
   frame.protect_var (line_editing);
   frame.protect_var (current_eval_string);
   frame.protect_var (current_function_depth);
   frame.protect_var (function_scopes);
   frame.protect_var (max_function_depth);
   frame.protect_var (parsing_subfunctions);
   frame.protect_var (endfunction_found);
   frame.protect_var (reading_fcn_file);
   frame.protect_var (reading_script_file);
   frame.protect_var (reading_classdef_file);
 
-  lexer_flags = lexical_feedback ();
+  curr_lexer = new lexical_feedback ();
 
   get_input_from_eval_string = true;
   line_editing = false;
   current_function_depth = 0;
   function_scopes.clear ();
   max_function_depth = 0;
   parsing_subfunctions = false;
   endfunction_found = false;
@@ -4412,17 +4413,17 @@ eval_string (const std::string& s, bool 
                 error ("eval: invalid use of statement list");
 
               if (error_state
                   || tree_return_command::returning
                   || tree_break_command::breaking
                   || tree_continue_command::continuing)
                 break;
             }
-          else if (lexer_flags.parser_end_of_input)
+          else if (curr_lexer->parser_end_of_input)
             break;
         }
     }
   while (parse_status == 0);
 
   return retval;
 }
 
