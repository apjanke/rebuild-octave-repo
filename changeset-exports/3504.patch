# HG changeset patch
# User jwe
# Date 949399646 0
#      Tue Feb 01 10:07:26 2000 +0000
# Node ID 5eef8a2294bdd2ecab22f526f3a8389aad44f766
# Parent  d14c483b3c122e6bfdf6892f180228733c6afdc1
[project @ 2000-02-01 10:06:51 by jwe]

diff --git a/liboctave/Array-str.cc b/liboctave/Array-str.cc
--- a/liboctave/Array-str.cc
+++ b/liboctave/Array-str.cc
@@ -26,15 +26,15 @@ Software Foundation, 59 Temple Place - S
 
 // Instantiate Arrays of strings.
 
 #include "Array.h"
 #include "Array.cc"
 
 #include <string>
 
-template class Array<string>;
+template class Array<std::string>;
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/Array.h b/liboctave/Array.h
--- a/liboctave/Array.h
+++ b/liboctave/Array.h
@@ -41,17 +41,17 @@ class idx_vector;
 #endif
 
 // One dimensional array class.  Handles the reference counting for
 // all the derived classes.
 
 template <class T>
 class Array
 {
-private:
+protected:
 
 // The real representation of all arrays.
 
   class ArrayRep
   {
   public:
 
     T *data;
diff --git a/liboctave/Array2.cc b/liboctave/Array2.cc
--- a/liboctave/Array2.cc
+++ b/liboctave/Array2.cc
@@ -117,24 +117,24 @@ Array2<T>::resize (int r, int c)
       (*current_liboctave_error_handler)
 	("can't resize to negative dimension");
       return;
     }
 
   if (r == dim1 () && c == dim2 ())
     return;
 
-  ArrayRep *old_rep = rep;
+  Array<T>::ArrayRep *old_rep = rep;
   const T *old_data = data ();
 
   int old_d1 = dim1 ();
   int old_d2 = dim2 ();
   int old_len = length ();
 
-  rep = new ArrayRep (get_size (r, c));
+  rep = new Array<T>::ArrayRep (get_size (r, c));
 
   d1 = r;
   d2 = c;
 
   if (old_data && old_len > 0)
     {
       int min_r = old_d1 < r ? old_d1 : r;
       int min_c = old_d2 < c ? old_d2 : c;
@@ -157,24 +157,24 @@ Array2<T>::resize (int r, int c, const T
       (*current_liboctave_error_handler)
 	("can't resize to negative dimension");
       return;
     }
 
   if (r == dim1 () && c == dim2 ())
     return;
 
-  ArrayRep *old_rep = rep;
+  Array<T>::ArrayRep *old_rep = rep;
   const T *old_data = data ();
 
   int old_d1 = dim1 ();
   int old_d2 = dim2 ();
   int old_len = length ();
 
-  rep = new ArrayRep (get_size (r, c));
+  rep = new Array<T>::ArrayRep (get_size (r, c));
 
   d1 = r;
   d2 = c;
 
   int min_r = old_d1 < r ? old_d1 : r;
   int min_c = old_d2 < c ? old_d2 : c;
 
   if (old_data && old_len > 0)
diff --git a/liboctave/Bounds.cc b/liboctave/Bounds.cc
--- a/liboctave/Bounds.cc
+++ b/liboctave/Bounds.cc
@@ -79,18 +79,18 @@ Bounds::set_upper_bounds (const ColumnVe
       return *this;
     }
 
   ub = u;
 
   return *this;
 }
 
-ostream&
-operator << (ostream& os, const Bounds& b)
+std::ostream&
+operator << (std::ostream& os, const Bounds& b)
 {
   for (int i = 0; i < b.size (); i++)
     os << b.lower_bound (i) << " " << b.upper_bound (i) << "\n";
 
   return os;
 }
 
 /*
diff --git a/liboctave/Bounds.h b/liboctave/Bounds.h
--- a/liboctave/Bounds.h
+++ b/liboctave/Bounds.h
@@ -121,17 +121,17 @@ public:
     {
       ub.fill (high);
       return *this;
     }
 
   Bounds& set_lower_bounds (const ColumnVector lb);
   Bounds& set_upper_bounds (const ColumnVector ub);
 
-  friend ostream& operator << (ostream& os, const Bounds& b);
+  friend std::ostream& operator << (std::ostream& os, const Bounds& b);
 
 protected:
 
   ColumnVector lb;
   ColumnVector ub;
 
 private:
 
diff --git a/liboctave/CColVector.cc b/liboctave/CColVector.cc
--- a/liboctave/CColVector.cc
+++ b/liboctave/CColVector.cc
@@ -797,32 +797,32 @@ ComplexColumnVector::max (void) const
 	absres = abs (res);
       }
 
   return res;
 }
 
 // i/o
 
-ostream&
-operator << (ostream& os, const ComplexColumnVector& a)
+std::ostream&
+operator << (std::ostream& os, const ComplexColumnVector& a)
 {
 //  int field_width = os.precision () + 7;
   for (int i = 0; i < a.length (); i++)
     os << /* setw (field_width) << */ a.elem (i) << "\n";
   return os;
 }
 
-istream&
-operator >> (istream& is, ComplexColumnVector& a)
+std::istream&
+operator >> (std::istream& is, ComplexColumnVector& a)
 {
   int len = a.length();
 
   if (len < 1)
-    is.clear (ios::badbit);
+    is.clear (std::ios::badbit);
   else
     {
       double tmp;
       for (int i = 0; i < len; i++)
         {
           is >> tmp;
           if (is)
             a.elem (i) = tmp;
diff --git a/liboctave/CColVector.h b/liboctave/CColVector.h
--- a/liboctave/CColVector.h
+++ b/liboctave/CColVector.h
@@ -177,18 +177,18 @@ public:
 
   ComplexColumnVector& apply (c_c_Mapper f);
 
   Complex min (void) const;
   Complex max (void) const;
 
   // i/o
 
-  friend ostream& operator << (ostream& os, const ComplexColumnVector& a);
-  friend istream& operator >> (istream& is, ComplexColumnVector& a);
+  friend std::ostream& operator << (std::ostream& os, const ComplexColumnVector& a);
+  friend std::istream& operator >> (std::istream& is, ComplexColumnVector& a);
 
 private:
 
   ComplexColumnVector (Complex *d, int l) : MArray<Complex> (d, l) { }
 };
 
 #endif
 
diff --git a/liboctave/CDiagMatrix.cc b/liboctave/CDiagMatrix.cc
--- a/liboctave/CDiagMatrix.cc
+++ b/liboctave/CDiagMatrix.cc
@@ -277,26 +277,26 @@ ComplexDiagMatrix::extract (int r1, int 
   return result;
 }
 
 // extract row or column i.
 
 ComplexRowVector
 ComplexDiagMatrix::row (int i) const
 {
-  int nr = rows ();
-  int nc = cols ();
-  if (i < 0 || i >= nr)
+  int r = rows ();
+  int c = cols ();
+  if (i < 0 || i >= r)
     {
       (*current_liboctave_error_handler) ("invalid row selection");
       return RowVector (); 
     }
 
-  ComplexRowVector retval (nc, 0.0);
-  if (nr <= nc || (nr > nc && i < nc))
+  ComplexRowVector retval (c, 0.0);
+  if (r <= c || (r > c && i < c))
     retval.elem (i) = elem (i, i);
 
   return retval;
 }
 
 ComplexRowVector
 ComplexDiagMatrix::row (char *s) const
 {
@@ -316,26 +316,26 @@ ComplexDiagMatrix::row (char *s) const
       (*current_liboctave_error_handler) ("invalid row selection");
       return ComplexRowVector ();
     }
 }
 
 ComplexColumnVector
 ComplexDiagMatrix::column (int i) const
 {
-  int nr = rows ();
-  int nc = cols ();
-  if (i < 0 || i >= nc)
+  int r = rows ();
+  int c = cols ();
+  if (i < 0 || i >= c)
     {
       (*current_liboctave_error_handler) ("invalid column selection");
       return ColumnVector (); 
     }
 
-  ComplexColumnVector retval (nr, 0.0);
-  if (nr >= nc || (nr < nc && i < nr))
+  ComplexColumnVector retval (r, 0.0);
+  if (r >= c || (r < c && i < r))
     retval.elem (i) = elem (i, i);
 
   return retval;
 }
 
 ComplexColumnVector
 ComplexDiagMatrix::column (char *s) const
 {
@@ -362,25 +362,25 @@ ComplexDiagMatrix::inverse (void) const
 {
   int info;
   return inverse (info);
 }
 
 ComplexDiagMatrix
 ComplexDiagMatrix::inverse (int& info) const
 {
-  int nr = rows ();
-  int nc = cols ();
-  if (nr != nc)
+  int r = rows ();
+  int c = cols ();
+  if (r != c)
     {
       (*current_liboctave_error_handler) ("inverse requires square matrix");
       return DiagMatrix ();
     }
 
-  ComplexDiagMatrix retval (nr, nc);
+  ComplexDiagMatrix retval (r, c);
 
   info = 0;
   for (int i = 0; i < length (); i++)
     {
       if (elem (i, i) == 0.0)
 	{
 	  info = -1;
 	  return *this;
@@ -392,178 +392,132 @@ ComplexDiagMatrix::inverse (int& info) c
   return retval;
 }
 
 // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::operator += (const DiagMatrix& a)
 {
-  int nr = rows ();
-  int nc = cols ();
+  int r = rows ();
+  int c = cols ();
 
   int a_nr = a.rows ();
   int a_nc = a.cols ();
 
-  if (nr != a_nr || nc != a_nc)
+  if (r != a_nr || c != a_nc)
     {
-      gripe_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
+      gripe_nonconformant ("operator +=", r, c, a_nr, a_nc);
       return *this;
     }
 
-  if (nr == 0 || nc == 0)
+  if (r == 0 || c == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
   add2 (d, a.data (), length ());
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::operator -= (const DiagMatrix& a)
 {
-  int nr = rows ();
-  int nc = cols ();
+  int r = rows ();
+  int c = cols ();
 
   int a_nr = a.rows ();
   int a_nc = a.cols ();
 
-  if (nr != a_nr || nc != a_nc)
+  if (r != a_nr || c != a_nc)
     {
-      gripe_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
+      gripe_nonconformant ("operator -=", r, c, a_nr, a_nc);
       return *this;
     }
 
-  if (nr == 0 || nc == 0)
+  if (r == 0 || c == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
   subtract2 (d, a.data (), length ());
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::operator += (const ComplexDiagMatrix& a)
 {
-  int nr = rows ();
-  int nc = cols ();
+  int r = rows ();
+  int c = cols ();
 
   int a_nr = a.rows ();
   int a_nc = a.cols ();
 
-  if (nr != a_nr || nc != a_nc)
+  if (r != a_nr || c != a_nc)
     {
-      gripe_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
+      gripe_nonconformant ("operator +=", r, c, a_nr, a_nc);
       return *this;
     }
 
-  if (nr == 0 || nc == 0)
+  if (r == 0 || c == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
   add2 (d, a.data (), length ());
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::operator -= (const ComplexDiagMatrix& a)
 {
-  int nr = rows ();
-  int nc = cols ();
+  int r = rows ();
+  int c = cols ();
 
   int a_nr = a.rows ();
   int a_nc = a.cols ();
 
-  if (nr != a_nr || nc != a_nc)
+  if (r != a_nr || c != a_nc)
     {
-      gripe_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
+      gripe_nonconformant ("operator -=", r, c, a_nr, a_nc);
       return *this;
     }
 
-  if (nr == 0 || nc == 0)
+  if (r == 0 || c == 0)
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
   subtract2 (d, a.data (), length ());
   return *this;
 }
 
-// diagonal matrix by scalar -> diagonal matrix operations
-
-ComplexDiagMatrix
-operator * (const ComplexDiagMatrix& a, double s)
-{
-  return ComplexDiagMatrix (multiply (a.data (), a.length (), s),
-			    a.rows (), a.cols ());
-}
-
-ComplexDiagMatrix
-operator / (const ComplexDiagMatrix& a, double s)
-{
-  return ComplexDiagMatrix (divide (a.data (), a.length (), s),
-			    a.rows (), a.cols ());
-}
-
-ComplexDiagMatrix
-operator * (const DiagMatrix& a, const Complex& s)
-{
-  return ComplexDiagMatrix (multiply (a.data (), a.length (), s),
-			    a.rows (), a.cols ());
-}
-
-ComplexDiagMatrix
-operator / (const DiagMatrix& a, const Complex& s)
-{
-  return ComplexDiagMatrix (divide (a.data (), a.length (), s),
-			    a.rows (), a.cols ());
-}
-
-// scalar by diagonal matrix -> diagonal matrix operations
-
-ComplexDiagMatrix
-operator * (double s, const ComplexDiagMatrix& a)
-{
-  return ComplexDiagMatrix (multiply (a.data (), a.length (), s),
-			    a.rows (), a.cols ());
-}
-
-ComplexDiagMatrix
-operator * (const Complex& s, const DiagMatrix& a)
-{
-  return ComplexDiagMatrix (multiply (a.data (), a.length (), s),
-			    a.rows (), a.cols ());
-}
-
 // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
 ComplexDiagMatrix
 operator * (const ComplexDiagMatrix& a, const ComplexDiagMatrix& b)
 {
-  int nr_a = a.rows ();
-  int nc_a = a.cols ();
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
 
-  int nr_b = b.rows ();
-  int nc_b = b.cols ();
+  int b_nr = b.rows ();
+  int b_nc = b.cols ();
 
-  if (nc_a != nr_b)
+  if (a_nc != b_nr)
     {
-      gripe_nonconformant ("operator *", nr_a, nc_a, nr_b, nc_b);
+      gripe_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
       return ComplexDiagMatrix ();
     }
 
-  if (nr_a == 0 || nc_a == 0 || nc_b == 0)
-    return ComplexDiagMatrix (nr_a, nc_a, 0.0);
+  if (a_nr == 0 || a_nc == 0 || b_nc == 0)
+    return ComplexDiagMatrix (a_nr, a_nc, 0.0);
 
-  ComplexDiagMatrix c (nr_a, nc_b);
+  ComplexDiagMatrix c (a_nr, b_nc);
 
-  int len = nr_a < nc_b ? nr_a : nc_b;
+  int len = a_nr < b_nc ? a_nr : b_nc;
 
   for (int i = 0; i < len; i++)
     {
       Complex a_element = a.elem (i, i);
       Complex b_element = b.elem (i, i);
 
       if (a_element == 0.0 || b_element == 0.0)
         c.elem (i, i) = 0.0;
@@ -576,34 +530,34 @@ operator * (const ComplexDiagMatrix& a, 
     }
 
   return c;
 }
 
 ComplexDiagMatrix
 operator * (const ComplexDiagMatrix& a, const DiagMatrix& b)
 {
-  int nr_a = a.rows ();
-  int nc_a = a.cols ();
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
 
-  int nr_b = b.rows ();
-  int nc_b = b.cols ();
+  int b_nr = b.rows ();
+  int b_nc = b.cols ();
 
-  if (nc_a != nr_b)
+  if (a_nc != b_nr)
     {
-      gripe_nonconformant ("operator *", nr_a, nc_a, nr_b, nc_b);
+      gripe_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
       return ComplexDiagMatrix ();
     }
 
-  if (nr_a == 0 || nc_a == 0 || nc_b == 0)
-    return ComplexDiagMatrix (nr_a, nc_a, 0.0);
+  if (a_nr == 0 || a_nc == 0 || b_nc == 0)
+    return ComplexDiagMatrix (a_nr, a_nc, 0.0);
 
-  ComplexDiagMatrix c (nr_a, nc_b);
+  ComplexDiagMatrix c (a_nr, b_nc);
 
-  int len = nr_a < nc_b ? nr_a : nc_b;
+  int len = a_nr < b_nc ? a_nr : b_nc;
 
   for (int i = 0; i < len; i++)
     {
       Complex a_element = a.elem (i, i);
       double b_element = b.elem (i, i);
 
       if (a_element == 0.0 || b_element == 0.0)
         c.elem (i, i) = 0.0;
@@ -616,34 +570,34 @@ operator * (const ComplexDiagMatrix& a, 
     }
 
   return c;
 }
 
 ComplexDiagMatrix
 operator * (const DiagMatrix& a, const ComplexDiagMatrix& b)
 {
-  int nr_a = a.rows ();
-  int nc_a = a.cols ();
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
 
-  int nr_b = b.rows ();
-  int nc_b = b.cols ();
+  int b_nr = b.rows ();
+  int b_nc = b.cols ();
 
-  if (nc_a != nr_b)
+  if (a_nc != b_nr)
     {
-      gripe_nonconformant ("operator *", nr_a, nc_a, nr_b, nc_b);
+      gripe_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
       return ComplexDiagMatrix ();
     }
 
-  if (nr_a == 0 || nc_a == 0 || nc_b == 0)
-    return ComplexDiagMatrix (nr_a, nc_a, 0.0);
+  if (a_nr == 0 || a_nc == 0 || b_nc == 0)
+    return ComplexDiagMatrix (a_nr, a_nc, 0.0);
 
-  ComplexDiagMatrix c (nr_a, nc_b);
+  ComplexDiagMatrix c (a_nr, b_nc);
 
-  int len = nr_a < nc_b ? nr_a : nc_b;
+  int len = a_nr < b_nc ? a_nr : b_nc;
 
   for (int i = 0; i < len; i++)
     {
       double a_element = a.elem (i, i);
       Complex b_element = b.elem (i, i);
 
       if (a_element == 0.0 || b_element == 0.0)
         c.elem (i, i) = 0.0;
@@ -698,25 +652,25 @@ ComplexDiagMatrix::diag (int k) const
 	}
       else
 	{
 	  for (int i = 0; i < ndiag; i++)
 	    d.elem (i) = elem (i, i);
 	}
     }
   else
-    cerr << "diag: requested diagonal out of range\n";
+    std::cerr << "diag: requested diagonal out of range\n";
 
   return d;
 }
 
 // i/o
 
-ostream&
-operator << (ostream& os, const ComplexDiagMatrix& a)
+std::ostream&
+operator << (std::ostream& os, const ComplexDiagMatrix& a)
 {
   Complex ZERO (0.0);
 //  int field_width = os.precision () + 7;
   for (int i = 0; i < a.rows (); i++)
     {
       for (int j = 0; j < a.cols (); j++)
 	{
 	  if (i == j)
diff --git a/liboctave/CDiagMatrix.h b/liboctave/CDiagMatrix.h
--- a/liboctave/CDiagMatrix.h
+++ b/liboctave/CDiagMatrix.h
@@ -101,55 +101,41 @@ public:
   // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
   ComplexDiagMatrix& operator += (const DiagMatrix& a);
   ComplexDiagMatrix& operator -= (const DiagMatrix& a);
 
   ComplexDiagMatrix& operator += (const ComplexDiagMatrix& a);
   ComplexDiagMatrix& operator -= (const ComplexDiagMatrix& a);
 
-  // diagonal matrix by scalar -> diagonal matrix operations
-
-  friend ComplexDiagMatrix operator * (const ComplexDiagMatrix& a, double s);
-  friend ComplexDiagMatrix operator / (const ComplexDiagMatrix& a, double s);
-
-  friend ComplexDiagMatrix operator * (const DiagMatrix& a, const Complex& s);
-  friend ComplexDiagMatrix operator / (const DiagMatrix& a, const Complex& s);
-
-  // scalar by diagonal matrix -> diagonal matrix operations
-
-  friend ComplexDiagMatrix operator * (double s, const ComplexDiagMatrix& a);
-
-  friend ComplexDiagMatrix operator * (const Complex& s, const DiagMatrix& a);
-
-  // diagonal matrix by diagonal matrix -> diagonal matrix operations
-
-  friend ComplexDiagMatrix operator * (const ComplexDiagMatrix& a,
-				       const ComplexDiagMatrix& b);
-
-  friend ComplexDiagMatrix operator * (const ComplexDiagMatrix& a,
-				       const DiagMatrix& b);
-
-  friend ComplexDiagMatrix operator * (const DiagMatrix& a,
-				       const ComplexDiagMatrix& b);
-
   // other operations
 
   ComplexColumnVector diag (void) const;
   ComplexColumnVector diag (int k) const;
 
   // i/o
 
-  friend ostream& operator << (ostream& os, const ComplexDiagMatrix& a);
+  friend std::ostream& operator << (std::ostream& os, const ComplexDiagMatrix& a);
 
 private:
 
   ComplexDiagMatrix (Complex *d, int nr, int nc)
     : MDiagArray2<Complex> (d, nr, nc) { }
 };
 
+// diagonal matrix by diagonal matrix -> diagonal matrix operations
+
+ComplexDiagMatrix
+operator * (const ComplexDiagMatrix& a, const ComplexDiagMatrix& b);
+
+ComplexDiagMatrix
+operator * (const ComplexDiagMatrix& a, const DiagMatrix& b);
+
+ComplexDiagMatrix
+operator * (const DiagMatrix& a, const ComplexDiagMatrix& b);
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -2546,17 +2546,17 @@ ComplexMatrix::diag (int k) const
 	}
       else
 	{
 	  for (int i = 0; i < ndiag; i++)
 	    d.elem (i) = elem (i, i);
 	}
     }
   else
-    cerr << "diag: requested diagonal out of range\n";
+    std::cerr << "diag: requested diagonal out of range\n";
 
   return d;
 }
 
 bool
 ComplexMatrix::row_is_real_only (int i) const
 {
   bool retval = true;
@@ -2611,49 +2611,49 @@ ComplexMatrix::row_min (Array<int>& inde
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
       index.resize (nr);
 
       for (int i = 0; i < nr; i++)
         {
-	  int idx = 0;
-
-	  Complex tmp_min = elem (i, idx);
+	  int idx_j = 0;
+
+	  Complex tmp_min = elem (i, idx_j);
 
 	  bool real_only = row_is_real_only (i);
 
 	  double abs_min = real_only ? real (tmp_min) : abs (tmp_min);
 
 	  if (xisnan (tmp_min))
-	    idx = -1;
+	    idx_j = -1;
 	  else
 	    {
 	      for (int j = 1; j < nc; j++)
 		{
 		  Complex tmp = elem (i, j);
 
 		  double abs_tmp = real_only ? real (tmp) : abs (tmp);
 
 		  if (xisnan (tmp))
 		    {
-		      idx = -1;
+		      idx_j = -1;
 		      break;
 		    }
 		  else if (abs_tmp < abs_min)
 		    {
-		      idx = j;
+		      idx_j = j;
 		      tmp_min = tmp;
 		      abs_min = abs_tmp;
 		    }
 		}
 
-	      result.elem (i) = (idx < 0) ? Complex_NaN_result : tmp_min;
-	      index.elem (i) = idx;
+	      result.elem (i) = (idx_j < 0) ? Complex_NaN_result : tmp_min;
+	      index.elem (i) = idx_j;
 	    }
         }
     }
 
   return result;
 }
 
 ComplexColumnVector
@@ -2673,49 +2673,49 @@ ComplexMatrix::row_max (Array<int>& inde
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
       index.resize (nr);
 
       for (int i = 0; i < nr; i++)
         {
-	  int idx = 0;
-
-	  Complex tmp_max = elem (i, idx);
+	  int idx_j = 0;
+
+	  Complex tmp_max = elem (i, idx_j);
 
 	  bool real_only = row_is_real_only (i);
 
 	  double abs_max = real_only ? real (tmp_max) : abs (tmp_max);
 
 	  if (xisnan (tmp_max))
-	    idx = -1;
+	    idx_j = -1;
 	  else
 	    {
 	      for (int j = 1; j < nc; j++)
 		{
 		  Complex tmp = elem (i, j);
 
 		  double abs_tmp = real_only ? real (tmp) : abs (tmp);
 
 		  if (xisnan (tmp))
 		    {
-		      idx = -1;
+		      idx_j = -1;
 		      break;
 		    }
 		  else if (abs_tmp > abs_max)
 		    {
-		      idx = j;
+		      idx_j = j;
 		      tmp_max = tmp;
 		      abs_max = abs_tmp;
 		    }
 		}
 
-	      result.elem (i) = (idx < 0) ? Complex_NaN_result : tmp_max;
-	      index.elem (i) = idx;
+	      result.elem (i) = (idx_j < 0) ? Complex_NaN_result : tmp_max;
+	      index.elem (i) = idx_j;
 	    }
         }
     }
 
   return result;
 }
 
 ComplexRowVector
@@ -2735,49 +2735,49 @@ ComplexMatrix::column_min (Array<int>& i
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
       index.resize (nc);
 
       for (int j = 0; j < nc; j++)
         {
-	  int idx = 0;
-
-	  Complex tmp_min = elem (idx, j);
+	  int idx_i = 0;
+
+	  Complex tmp_min = elem (idx_i, j);
 
 	  bool real_only = column_is_real_only (j);
 
 	  double abs_min = real_only ? real (tmp_min) : abs (tmp_min);
 
 	  if (xisnan (tmp_min))
-	    idx = -1;
+	    idx_i = -1;
 	  else
 	    {
 	      for (int i = 1; i < nr; i++)
 		{
 		  Complex tmp = elem (i, j);
 
 		  double abs_tmp = real_only ? real (tmp) : abs (tmp);
 
 		  if (xisnan (tmp))
 		    {
-		      idx = -1;
+		      idx_i = -1;
 		      break;
 		    }
 		  else if (abs_tmp < abs_min)
 		    {
-		      idx = i;
+		      idx_i = i;
 		      tmp_min = tmp;
 		      abs_min = abs_tmp;
 		    }
 		}
 
-	      result.elem (j) = (idx < 0) ? Complex_NaN_result : tmp_min;
-	      index.elem (j) = idx;
+	      result.elem (j) = (idx_i < 0) ? Complex_NaN_result : tmp_min;
+	      index.elem (j) = idx_i;
 	    }
         }
     }
 
   return result;
 }
 
 ComplexRowVector
@@ -2797,79 +2797,79 @@ ComplexMatrix::column_max (Array<int>& i
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
       index.resize (nc);
 
       for (int j = 0; j < nc; j++)
         {
-	  int idx = 0;
-
-	  Complex tmp_max = elem (idx, j);
+	  int idx_i = 0;
+
+	  Complex tmp_max = elem (idx_i, j);
 
 	  bool real_only = column_is_real_only (j);
 
 	  double abs_max = real_only ? real (tmp_max) : abs (tmp_max);
 
 	  if (xisnan (tmp_max))
-	    idx = -1;
+	    idx_i = -1;
 	  else
 	    {
 	      for (int i = 1; i < nr; i++)
 		{
 		  Complex tmp = elem (i, j);
 
 		  double abs_tmp = real_only ? real (tmp) : abs (tmp);
 
 		  if (xisnan (tmp))
 		    {
-		      idx = -1;
+		      idx_i = -1;
 		      break;
 		    }
 		  else if (abs_tmp > abs_max)
 		    {
-		      idx = i;
+		      idx_i = i;
 		      tmp_max = tmp;
 		      abs_max = abs_tmp;
 		    }
 		}
 
-	      result.elem (j) = (idx < 0) ? Complex_NaN_result : tmp_max;
-	      index.elem (j) = idx;
+	      result.elem (j) = (idx_i < 0) ? Complex_NaN_result : tmp_max;
+	      index.elem (j) = idx_i;
 	    }
         }
     }
 
   return result;
 }
 
 // i/o
 
-ostream&
-operator << (ostream& os, const ComplexMatrix& a)
+std::ostream&
+operator << (std::ostream& os, const ComplexMatrix& a)
 {
 //  int field_width = os.precision () + 7;
   for (int i = 0; i < a.rows (); i++)
     {
       for (int j = 0; j < a.cols (); j++)
 	os << " " /* setw (field_width) */ << a.elem (i, j);
       os << "\n";
     }
   return os;
 }
 
-istream&
-operator >> (istream& is, ComplexMatrix& a)
+std::istream&
+operator >> (std::istream& is, ComplexMatrix& a)
 {
   int nr = a.rows ();
   int nc = a.cols ();
 
   if (nr < 1 || nc < 1)
-    is.clear (ios::badbit);
+    is.clear (std::ios::badbit);
   else
     {
       Complex tmp;
       for (int i = 0; i < nr; i++)
 	for (int j = 0; j < nc; j++)
 	  {
 	    is >> tmp;
 	    if (is)
@@ -3003,21 +3003,21 @@ operator * (const ComplexMatrix& m, cons
 	      ("unrecoverable error in zgemm");
 	}
     }
 
   return retval;
 }
 
 MS_CMP_OPS(ComplexMatrix, real, Complex, real)
-MS_BOOL_OPS(ComplexMatrix, Complex)
+MS_BOOL_OPS(ComplexMatrix, Complex, 0.0)
 
 SM_CMP_OPS(Complex, real, ComplexMatrix, real)
-SM_BOOL_OPS(Complex, ComplexMatrix)
+SM_BOOL_OPS(Complex, ComplexMatrix, 0.0)
 
 MM_CMP_OPS(ComplexMatrix, real, ComplexMatrix, real)
-MM_BOOL_OPS(ComplexMatrix, ComplexMatrix)
+MM_BOOL_OPS(ComplexMatrix, ComplexMatrix, 0.0)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/CMatrix.h b/liboctave/CMatrix.h
--- a/liboctave/CMatrix.h
+++ b/liboctave/CMatrix.h
@@ -31,25 +31,16 @@ Software Foundation, 59 Temple Place - S
 #include "MDiagArray2.h"
 
 #include "mx-defs.h"
 #include "mx-op-defs.h"
 #include "oct-cmplx.h"
 
 class ComplexMatrix : public MArray2<Complex>
 {
-friend class Matrix;
-friend class ComplexCHOL;
-friend class ComplexHESS;
-friend class ComplexLU;
-friend class ComplexQR;
-friend class ComplexQRP;
-friend class ComplexSCHUR;
-friend class ComplexSVD;
-
 public:
  
   typedef void (*solve_singularity_handler) (double rcond);
 
   ComplexMatrix (void) : MArray2<Complex> () { }
   ComplexMatrix (int r, int c) : MArray2<Complex> (r, c) { }
   ComplexMatrix (int r, int c, const Complex& val)
     : MArray2<Complex> (r, c, val) { }
@@ -249,18 +240,18 @@ public:
   ComplexRowVector column_min (void) const;
   ComplexRowVector column_max (void) const;
 
   ComplexRowVector column_min (Array<int>& index) const;
   ComplexRowVector column_max (Array<int>& index) const;
 
   // i/o
 
-  friend ostream& operator << (ostream& os, const ComplexMatrix& a);
-  friend istream& operator >> (istream& is, ComplexMatrix& a);
+  friend std::ostream& operator << (std::ostream& os, const ComplexMatrix& a);
+  friend std::istream& operator >> (std::istream& is, ComplexMatrix& a);
 
 private:
 
   ComplexMatrix (Complex *d, int r, int c) : MArray2<Complex> (d, r, c) { }
 };
 
 ComplexMatrix Givens (const Complex&, const Complex&);
 
diff --git a/liboctave/CRowVector.cc b/liboctave/CRowVector.cc
--- a/liboctave/CRowVector.cc
+++ b/liboctave/CRowVector.cc
@@ -707,32 +707,32 @@ ComplexRowVector::max (void) const
 	absres = abs (res);
       }
 
   return res;
 }
 
 // i/o
 
-ostream&
-operator << (ostream& os, const ComplexRowVector& a)
+std::ostream&
+operator << (std::ostream& os, const ComplexRowVector& a)
 {
 //  int field_width = os.precision () + 7;
   for (int i = 0; i < a.length (); i++)
     os << " " /* setw (field_width) */ << a.elem (i);
   return os;
 }
 
-istream&
-operator >> (istream& is, ComplexRowVector& a)
+std::istream&
+operator >> (std::istream& is, ComplexRowVector& a)
 {
   int len = a.length();
 
   if (len < 1)
-    is.clear (ios::badbit);
+    is.clear (std::ios::badbit);
   else
     {
       Complex tmp;
       for (int i = 0; i < len; i++)
         {
           is >> tmp;
           if (is)
             a.elem (i) = tmp;
diff --git a/liboctave/CRowVector.h b/liboctave/CRowVector.h
--- a/liboctave/CRowVector.h
+++ b/liboctave/CRowVector.h
@@ -144,18 +144,18 @@ public:
 
   ComplexRowVector& apply (c_c_Mapper f);
 
   Complex min (void) const;
   Complex max (void) const;
 
   // i/o
 
-  friend ostream& operator << (ostream& os, const ComplexRowVector& a);
-  friend istream& operator >> (istream& is, ComplexRowVector& a);
+  friend std::ostream& operator << (std::ostream& os, const ComplexRowVector& a);
+  friend std::istream& operator >> (std::istream& is, ComplexRowVector& a);
 
 private:
 
   ComplexRowVector (Complex *d, int l) : MArray<Complex> (d, l) { }
 };
 
 // row vector by column vector -> scalar
 
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,16 +1,50 @@
+2000-02-01  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* dMatrix.cc (write_int, read_int): No longer declared static.
+
+	* CDiagMatrix.h: Delete decls for friend operators that are
+	handled by MDiagArray2 class.  Move others outside class decl and
+	strip friend status.
+	* dDiagMatrix.h: Likewise.
+
+	* MArray.h: Delete decls for friend operators inside class decl.
+	* MArray2.h: Ditto.
+	* MDiagArray2.h: Ditto.
+
+	* MArray-defs.h (DO_VS_OP,, DO_SV_OP, DO_VV_OP, NEGV): Pass all
+	necessary parameters.  Don't allocate memory in the macro.  Change
+	all uses.
+
+	* dMatrix.h (class Matrix): Delete `friend class' decls.
+	* CMatrix.h (class ComplexMatrix): Ditto.
+
+	* mx-op-defs (MS_BOOL_OP, MS_BOOL_OPS, SM_BOOL_OP, SM_BOOL_OPS,
+	MM_BOOL_OP, MM_BOOL_OPS, MDM_MULTIPLY_OP, MDM_BIN_OPS,
+	DMM_MULTIPLY_OP, DMM_BIN_OPS): Pass zero constant as final arg, to
+	avoid type conflicts.  Change all uses.
+
+	* strptime.c (__mon_yday): Fix size of array decl.
+
+	* mx-inlines.cc: Use `xnot' instead of `not' for function name.
+
+	* chMatrix.cc (charMatrix::row_as_string): Delete extraneous
+	default value for second arg.
+
+	* Array2.cc (Array2<T>::resize): Add Array<T>:: qulaifier to
+	references to ArrayRep.
+
 2000-01-31  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
-	* oct-alloc.cc (octave_allocator::grow): Add std:: qualifier for
-	set_net_handler.
+	* Array.h (Array::ArrayRep): Now protected, not private.
 
 	* All source files: Include iostream, fstream, strstream,
 	etc. as needed instead of using forward declarations for these
-	classes.
+	classes.  Add std:: qualifier as needed.
 
 2000-01-30  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* oct-time.cc: Declare strptime extern "C".
 
 2000-01-29  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* oct-time.cc [! HAVE_STRPTIME]: Provide declaration.
diff --git a/liboctave/CmplxAEPBAL.cc b/liboctave/CmplxAEPBAL.cc
--- a/liboctave/CmplxAEPBAL.cc
+++ b/liboctave/CmplxAEPBAL.cc
@@ -42,17 +42,18 @@ extern "C"
  
   int F77_FCN (zgebak, ZGEBAK) (const char*, const char*, const int&,
 				const int&, const int&, double*, const
 				int&, Complex*, const int&, int&,
 				long, long);
 }
 
 int
-ComplexAEPBALANCE::init (const ComplexMatrix& a, const string& balance_job)
+ComplexAEPBALANCE::init (const ComplexMatrix& a,
+			 const std::string& balance_job)
 {
   int n = a.cols ();
 
   if (a.rows () != n)
     {
       (*current_liboctave_error_handler) ("AEPBALANCE requires square matrix");
       return -1;
     }
diff --git a/liboctave/CmplxAEPBAL.h b/liboctave/CmplxAEPBAL.h
--- a/liboctave/CmplxAEPBAL.h
+++ b/liboctave/CmplxAEPBAL.h
@@ -34,17 +34,17 @@ Software Foundation, 59 Temple Place - S
 
 class
 ComplexAEPBALANCE
 {
 public:
 
   ComplexAEPBALANCE (void) : balanced_mat (), balancing_mat () { }
 
-  ComplexAEPBALANCE (const ComplexMatrix& a, const string& balance_job)
+  ComplexAEPBALANCE (const ComplexMatrix& a, const std::string& balance_job)
     {
       init (a, balance_job); 
     }
 
   ComplexAEPBALANCE (const ComplexAEPBALANCE& a)
     : balanced_mat (a.balanced_mat), balancing_mat (a.balancing_mat) { }
 
   ComplexAEPBALANCE& operator = (const ComplexAEPBALANCE& a)
@@ -58,24 +58,24 @@ public:
     }
 
   ~ComplexAEPBALANCE (void) { }
 
   ComplexMatrix balanced_matrix (void) const { return balanced_mat; }
 
   ComplexMatrix balancing_matrix (void) const { return balancing_mat; }
 
-  friend ostream& operator << (ostream& os, const ComplexAEPBALANCE& a);
+  friend std::ostream& operator << (std::ostream& os, const ComplexAEPBALANCE& a);
 
 private:
 
   ComplexMatrix balanced_mat;
   ComplexMatrix balancing_mat;
 
-  int init (const ComplexMatrix& a, const string& balance_job);
+  int init (const ComplexMatrix& a, const std::string& balance_job);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/CmplxCHOL.h b/liboctave/CmplxCHOL.h
--- a/liboctave/CmplxCHOL.h
+++ b/liboctave/CmplxCHOL.h
@@ -56,17 +56,17 @@ public:
       return *this;
     }
 
   ComplexMatrix ComplexCHOL::chol_matrix (void) const
     {
       return chol_mat;
     }
 
-  friend ostream& operator << (ostream& os, const ComplexCHOL& a);
+  friend std::ostream& operator << (std::ostream& os, const ComplexCHOL& a);
 
 private:
 
   ComplexMatrix chol_mat;
 
   int init (const ComplexMatrix& a);
 };
 
diff --git a/liboctave/CmplxDET.h b/liboctave/CmplxDET.h
--- a/liboctave/CmplxDET.h
+++ b/liboctave/CmplxDET.h
@@ -60,17 +60,17 @@ public:
   int value_will_underflow (void) const;
 
   Complex coefficient (void) const;
 
   int exponent (void) const;
 
   Complex value (void) const;
 
-  friend ostream&  operator << (ostream& os, const ComplexDET& a);
+  friend std::ostream&  operator << (std::ostream& os, const ComplexDET& a);
 
 private:
 
   ComplexDET (const Complex *d)
     {
       det[0] = d[0];
       det[1] = d[1];
     }
diff --git a/liboctave/CmplxHESS.h b/liboctave/CmplxHESS.h
--- a/liboctave/CmplxHESS.h
+++ b/liboctave/CmplxHESS.h
@@ -59,17 +59,17 @@ public:
 
   ComplexMatrix hess_matrix (void) const { return hess_mat; }
 
   ComplexMatrix unitary_hess_matrix (void) const
     {
       return unitary_hess_mat;
     }
 
-  friend ostream& operator << (ostream& os, const ComplexHESS& a);
+  friend std::ostream& operator << (std::ostream& os, const ComplexHESS& a);
 
 private:
 
   ComplexMatrix hess_mat;
   ComplexMatrix unitary_hess_mat;
 
   int init (const ComplexMatrix& a);
 };
diff --git a/liboctave/CmplxQR.h b/liboctave/CmplxQR.h
--- a/liboctave/CmplxQR.h
+++ b/liboctave/CmplxQR.h
@@ -56,17 +56,17 @@ public:
   ~ComplexQR (void) { }
 
   void init (const ComplexMatrix&, QR::type = QR::std);
 
   ComplexMatrix Q (void) const { return q; }
 
   ComplexMatrix R (void) const { return r; }
 
-  friend ostream&  operator << (ostream&, const ComplexQR&);
+  friend std::ostream&  operator << (std::ostream&, const ComplexQR&);
 
 protected:
 
   ComplexMatrix q;
   ComplexMatrix r;
 };
 
 #endif
diff --git a/liboctave/CmplxQRP.h b/liboctave/CmplxQRP.h
--- a/liboctave/CmplxQRP.h
+++ b/liboctave/CmplxQRP.h
@@ -53,17 +53,17 @@ public:
     }
 
   ~ComplexQRP (void) { }
 
   void init (const ComplexMatrix&, QR::type = QR::std);
 
   Matrix P (void) const { return p; }
 
-  friend ostream&  operator << (ostream&, const ComplexQRP&);
+  friend std::ostream&  operator << (std::ostream&, const ComplexQRP&);
 
 private:
 
   Matrix p;
 };
 
 #endif
 
diff --git a/liboctave/CmplxSCHUR.cc b/liboctave/CmplxSCHUR.cc
--- a/liboctave/CmplxSCHUR.cc
+++ b/liboctave/CmplxSCHUR.cc
@@ -51,17 +51,17 @@ select_ana (const Complex& a)
 
 static int
 select_dig (const Complex& a)
 {
   return (abs (a) < 1.0);
 }
 
 int
-ComplexSCHUR::init (const ComplexMatrix& a, const string& ord)
+ComplexSCHUR::init (const ComplexMatrix& a, const std::string& ord)
 {
   int a_nr = a.rows ();
   int a_nc = a.cols ();
 
   if (a_nr != a_nc)
     {
       (*current_liboctave_error_handler)
 	("ComplexSCHUR requires square matrix");
diff --git a/liboctave/CmplxSCHUR.h b/liboctave/CmplxSCHUR.h
--- a/liboctave/CmplxSCHUR.h
+++ b/liboctave/CmplxSCHUR.h
@@ -35,23 +35,23 @@ Software Foundation, 59 Temple Place - S
 class
 ComplexSCHUR
 {
 public:
 
   ComplexSCHUR (void)
     : schur_mat (), unitary_mat () { }
 
-  ComplexSCHUR (const ComplexMatrix& a, const string& ord)
+  ComplexSCHUR (const ComplexMatrix& a, const std::string& ord)
     : schur_mat (), unitary_mat ()
       {
         init (a, ord);
       }
 
-  ComplexSCHUR (const ComplexMatrix& a, const string& ord, int& info)
+  ComplexSCHUR (const ComplexMatrix& a, const std::string& ord, int& info)
     : schur_mat (), unitary_mat ()
       {
         info = init (a,ord);
       }
 
   ComplexSCHUR (const ComplexSCHUR& a)
     : schur_mat (a.schur_mat), unitary_mat (a.unitary_mat) { }
 
@@ -66,28 +66,28 @@ public:
     }
 
   ~ComplexSCHUR (void) { }
 
   ComplexMatrix schur_matrix (void) const { return schur_mat; }
 
   ComplexMatrix unitary_matrix (void) const { return unitary_mat; }
 
-  friend ostream& operator << (ostream& os, const ComplexSCHUR& a);
+  friend std::ostream& operator << (std::ostream& os, const ComplexSCHUR& a);
 
   typedef int (*select_function) (const Complex&);
 
 private:
 
   ComplexMatrix schur_mat;
   ComplexMatrix unitary_mat;
 
   select_function selector;
 
-  int init (const ComplexMatrix& a, const string& ord);
+  int init (const ComplexMatrix& a, const std::string& ord);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/CmplxSVD.h b/liboctave/CmplxSVD.h
--- a/liboctave/CmplxSVD.h
+++ b/liboctave/CmplxSVD.h
@@ -68,17 +68,17 @@ public:
   ~ComplexSVD (void) { }
 
   DiagMatrix singular_values (void) const { return sigma; }
 
   ComplexMatrix left_singular_matrix (void) const;
 
   ComplexMatrix right_singular_matrix (void) const;
 
-  friend ostream&  operator << (ostream& os, const ComplexSVD& a);
+  friend std::ostream&  operator << (std::ostream& os, const ComplexSVD& a);
 
 private:
 
   SVD::type type_computed;
 
   DiagMatrix sigma;
   ComplexMatrix left_sm;
   ComplexMatrix right_sm;
diff --git a/liboctave/CollocWt.cc b/liboctave/CollocWt.cc
--- a/liboctave/CollocWt.cc
+++ b/liboctave/CollocWt.cc
@@ -158,18 +158,18 @@ CollocWt::init (void)
   id = 3;
   double *pq = q.fortran_vec ();
   F77_FCN (dfopr, DFOPR) (nt, n, inc_left, inc_right, id, id, pdif1,
 			  pdif2, pdif3, pr, pq);
 
   initialized = 1;
 }
 
-ostream&
-operator << (ostream& os, const CollocWt& a)
+std::ostream&
+operator << (std::ostream& os, const CollocWt& a)
 {
   if (a.left_included ())
     os << "left  boundary is included\n";
   else
     os << "left  boundary is not included\n";
 
   if (a.right_included ())
     os << "right boundary is included\n";
diff --git a/liboctave/CollocWt.h b/liboctave/CollocWt.h
--- a/liboctave/CollocWt.h
+++ b/liboctave/CollocWt.h
@@ -155,17 +155,17 @@ public:
   ColumnVector quad (void) { if (!initialized) init (); return q; }
 
   ColumnVector quad_weights (void) { return quad (); }
 
   Matrix first (void) { if (!initialized) init (); return A; }
 
   Matrix second (void) { if (!initialized) init (); return B; }
 
-  friend ostream& operator << (ostream&, const CollocWt&);
+  friend std::ostream& operator << (std::ostream&, const CollocWt&);
 
 protected:
 
   int n;
 
   int inc_left;
   int inc_right;
 
diff --git a/liboctave/EIG.h b/liboctave/EIG.h
--- a/liboctave/EIG.h
+++ b/liboctave/EIG.h
@@ -66,17 +66,17 @@ public:
     }
 
   ~EIG (void) { }
 
   ComplexColumnVector eigenvalues (void) const { return lambda; }
 
   ComplexMatrix eigenvectors (void) const { return v; }
 
-  friend ostream&  operator << (ostream& os, const EIG& a);
+  friend std::ostream&  operator << (std::ostream& os, const EIG& a);
 
 private:
 
   ComplexColumnVector lambda;
   ComplexMatrix v;
 
   int init (const Matrix& a);
   int init (const ComplexMatrix& a);
diff --git a/liboctave/FEGrid.cc b/liboctave/FEGrid.cc
--- a/liboctave/FEGrid.cc
+++ b/liboctave/FEGrid.cc
@@ -121,18 +121,18 @@ FEGrid::check_grid (void) const
       if (elem.elem (i-1) == elem.elem (i))
 	{
 	  error ("zero width element");
 	  return;
 	}
     }
 }
 
-ostream&
-operator << (ostream& s, const FEGrid& g)
+std::ostream&
+operator << (std::ostream& s, const FEGrid& g)
 {
   s << g.element_boundaries ();
   return s;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/FEGrid.h b/liboctave/FEGrid.h
--- a/liboctave/FEGrid.h
+++ b/liboctave/FEGrid.h
@@ -64,17 +64,17 @@ public:
   double left (void) const { return elem.elem (0); }
 
   double right (void) const { return elem.elem (elem.capacity () - 1); }
 
   int in_bounds (double x) const { return (x >= left () && x <= right ()); }
 
   ColumnVector element_boundaries (void) const { return elem; }
 
-  friend ostream& operator << (ostream&, const FEGrid&);
+  friend std::ostream& operator << (std::ostream&, const FEGrid&);
 
 protected:
 
   ColumnVector elem;
 
 private:
 
   void error (const char* msg) const;
diff --git a/liboctave/LSODE.cc b/liboctave/LSODE.cc
--- a/liboctave/LSODE.cc
+++ b/liboctave/LSODE.cc
@@ -302,17 +302,17 @@ LSODE::do_integrate (double tout)
 	}
     }
 
   return retval;
 }
 
 #if 0
 void
-LSODE::integrate (int nsteps, double tstep, ostream& s)
+LSODE::integrate (int nsteps, double tstep, std::ostream& s)
 {
   int time_to_quit = 0;
   double tout = t;
 
   s << t << " " << x << "\n";
 
   for (int i = 0; i < nsteps; i++)
     {
diff --git a/liboctave/LSODE.h b/liboctave/LSODE.h
--- a/liboctave/LSODE.h
+++ b/liboctave/LSODE.h
@@ -145,17 +145,17 @@ public:
   void set_stop_time (double t);
   void clear_stop_time (void);
 
   ColumnVector do_integrate (double t);
 
   Matrix do_integrate (const ColumnVector& tout);
 
 #if 0
-  void integrate (int nsteps, double tstep, ostream& s);
+  void integrate (int nsteps, double tstep, std::ostream& s);
 #endif
 
   Matrix integrate (const ColumnVector& tout)
     { return do_integrate (tout); }
 
   Matrix integrate (const ColumnVector& tout, const ColumnVector& tcrit);
 
 private:
diff --git a/liboctave/LinConst.cc b/liboctave/LinConst.cc
--- a/liboctave/LinConst.cc
+++ b/liboctave/LinConst.cc
@@ -36,18 +36,18 @@ Software Foundation, 59 Temple Place - S
 // error handling
 
 void
 LinConst::error (const char* msg)
 {
   (*current_liboctave_error_handler) ("fatal LinConst error: %s", msg);
 }
 
-ostream&
-operator << (ostream& os, const LinConst& c)
+std::ostream&
+operator << (std::ostream& os, const LinConst& c)
 {
   for (int i = 0; i < c.size (); i++)
     os << c.lower_bound (i) << " " << c.upper_bound (i) << "\n";
 
   os << "\n";
   os << c.constraint_matrix ();
 
   return os;
diff --git a/liboctave/LinConst.h b/liboctave/LinConst.h
--- a/liboctave/LinConst.h
+++ b/liboctave/LinConst.h
@@ -74,17 +74,17 @@ public:
       if (lb.capacity () != amat.rows ())
 	error ("inconsistent size for new linear constraint matrix");
 
       A = amat;
 
       return *this;
     }
 
-  friend ostream& operator << (ostream& os, const LinConst& b);
+  friend std::ostream& operator << (std::ostream& os, const LinConst& b);
 
 protected:
 
   Matrix A;
 
 private:
 
   void error (const char *msg);
diff --git a/liboctave/MArray-defs.h b/liboctave/MArray-defs.h
--- a/liboctave/MArray-defs.h
+++ b/liboctave/MArray-defs.h
@@ -1,54 +1,38 @@
 // Nothing like a little CPP abuse to brighten everyone's day.  Would
 // have been nice to do this with template functions but as of 2.5.x,
 // g++ seems to fail to resolve them properly.
 
-#define DO_VS_OP(OP) \
-  int l = a.length (); \
-  T *result = 0; \
+#define DO_VS_OP(r, l, v, OP, s) \
   if (l > 0) \
     { \
-      result = new T [l]; \
-      const T *x = a.data (); \
       for (int i = 0; i < l; i++) \
-	result[i] = x[i] OP s; \
+	r[i] = v[i] OP s; \
     }
 
-#define DO_SV_OP(OP) \
-  int l = a.length (); \
-  T *result = 0; \
+#define DO_SV_OP(r, l, s, OP, v) \
   if (l > 0) \
     { \
-      result = new T [l]; \
-      const T *x = a.data (); \
       for (int i = 0; i < l; i++) \
-	result[i] = s OP x[i]; \
+	r[i] = s OP v[i]; \
     }
 
-#define DO_VV_OP(OP) \
-  T *result = 0; \
+#define DO_VV_OP(r, l, x, OP, y) \
   if (l > 0) \
     { \
-      result = new T [l]; \
-      const T *x = a.data (); \
-      const T *y = b.data (); \
       for (int i = 0; i < l; i++) \
-	result[i] = x[i] OP y[i]; \
+	r[i] = x[i] OP y[i]; \
     }
 
-#define NEG_V \
-  int l = a.length (); \
-  T *result = 0; \
+#define NEG_V(r, l, x) \
   if (l > 0) \
     { \
-      result = new T [l]; \
-      const T *x = a.data (); \
       for (int i = 0; i < l; i++) \
-	result[i] = -x[i]; \
+	r[i] = -x[i]; \
     }
 
 #define DO_VS_OP2(OP) \
   int l = a.length (); \
   if (l > 0) \
     { \
       T *tmp = a.fortran_vec (); \
       for (int i = 0; i < l; i++) \
diff --git a/liboctave/MArray.cc b/liboctave/MArray.cc
--- a/liboctave/MArray.cc
+++ b/liboctave/MArray.cc
@@ -89,35 +89,43 @@ operator -= (MArray<T>& a, const MArray<
 
 // Element by element MArray by scalar ops.
 
 #define MARRAY_AS_OP(OP) \
   template <class T> \
   MArray<T> \
   operator OP (const MArray<T>& a, const T& s) \
   { \
-    DO_VS_OP (OP); \
-    return MArray<T> (result, l); \
+    MArray<T> result (a.length ()); \
+    T *r = result.fortran_vec (); \
+    int l = a.length (); \
+    const T *v = a.data (); \
+    DO_VS_OP (r, l, v, OP, s); \
+    return result; \
   }
 
 MARRAY_AS_OP (+)
 MARRAY_AS_OP (-)
 MARRAY_AS_OP (*)
 MARRAY_AS_OP (/)
 
 // Element by element scalar by MArray ops.
 
 #define MARRAY_SA_OP(OP) \
   template <class T> \
   MArray<T> \
   operator OP (const T& s, const MArray<T>& a) \
   { \
-    DO_SV_OP (OP); \
-    return MArray<T> (result, l); \
- }
+    MArray<T> result (a.length ()); \
+    T *r = result.fortran_vec (); \
+    int l = a.length (); \
+    const T *v = a.data (); \
+    DO_SV_OP (r, l, s, OP, v); \
+    return result; \
+  }
 
 MARRAY_SA_OP(+)
 MARRAY_SA_OP(-)
 MARRAY_SA_OP(*)
 MARRAY_SA_OP(/)
 
 // Element by element MArray by MArray ops.
 
@@ -130,32 +138,40 @@ MARRAY_SA_OP(/)
     int bl = b.length (); \
     if (l != bl) \
       { \
 	gripe_nonconformant (#FCN, l, bl); \
 	return MArray<T> (); \
       } \
     if (l == 0) \
       return MArray<T> (); \
-    DO_VV_OP (OP); \
-    return MArray<T> (result, l); \
+    MArray<T> result (l); \
+    T *r = result.fortran_vec (); \
+    const T *x = a.data (); \
+    const T *y = b.data (); \
+    DO_VV_OP (r, l, x, OP, y); \
+    return result; \
   }
 
 MARRAY_AA_OP (operator +, +)
 MARRAY_AA_OP (operator -, -)
 MARRAY_AA_OP (product,    *)
 MARRAY_AA_OP (quotient,   /)
 
 // Unary MArray ops.
 
 template <class T>
 MArray<T>
 operator - (const MArray<T>& a)
 {
-  NEG_V;
-  return MArray<T> (result, l);
+  int l = a.length ();
+  MArray<T> result (l);
+  T *r = result.fortran_vec ();
+  const T *x = a.data ();
+  NEG_V (r, l, x);
+  return result;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/MArray.h b/liboctave/MArray.h
--- a/liboctave/MArray.h
+++ b/liboctave/MArray.h
@@ -114,51 +114,16 @@ public:
 
   ~MArray (void) { }
 
   MArray<T>& operator = (const MArray<T>& a)
     {
       Array<T>::operator = (a);
       return *this;
     }
-
-  // element by element MArray by scalar ops
-
-  friend MArray<T>& operator += LTGT (MArray<T>& a, const T& s);
-  friend MArray<T>& operator -= LTGT (MArray<T>& a, const T& s);
-
-  // element by element MArray by MArray ops
-
-  friend MArray<T>& operator += LTGT (MArray<T>& a, const MArray<T>& b);
-  friend MArray<T>& operator -= LTGT (MArray<T>& a, const MArray<T>& b);
-
-  // element by element MArray by scalar ops
-
-  friend MArray<T> operator + LTGT (const MArray<T>& a, const T& s);
-  friend MArray<T> operator - LTGT (const MArray<T>& a, const T& s);
-  friend MArray<T> operator * LTGT (const MArray<T>& a, const T& s);
-  friend MArray<T> operator / LTGT (const MArray<T>& a, const T& s);
-
-  // element by element scalar by MArray ops
-
-  friend MArray<T> operator + LTGT (const T& s, const MArray<T>& a);
-  friend MArray<T> operator - LTGT (const T& s, const MArray<T>& a);
-  friend MArray<T> operator * LTGT (const T& s, const MArray<T>& a);
-  friend MArray<T> operator / LTGT (const T& s, const MArray<T>& a);
-
-  // element by element MArray by MArray ops
-
-  friend MArray<T> operator + LTGT (const MArray<T>& a, const MArray<T>& b);
-
-  friend MArray<T> operator - LTGT (const MArray<T>& a, const MArray<T>& b);
-
-  friend MArray<T> product LTGT (const MArray<T>& a, const MArray<T>& b);
-  friend MArray<T> quotient LTGT (const MArray<T>& a, const MArray<T>& b);
-
-  friend MArray<T> operator - LTGT (const MArray<T>& a);
 };
 
 #undef LTGT
 
 extern void
 gripe_nonconformant (const char *op, int op1_len, int op2_len);
 
 #define INSTANTIATE_MARRAY_FRIENDS(T) \
diff --git a/liboctave/MArray2.cc b/liboctave/MArray2.cc
--- a/liboctave/MArray2.cc
+++ b/liboctave/MArray2.cc
@@ -99,76 +99,92 @@ operator -= (MArray2<T>& a, const MArray
 
 // Element by element MArray2 by scalar ops.
 
 #define MARRAY_A2S_OP(OP) \
   template <class T> \
   MArray2<T> \
   operator OP (const MArray2<T>& a, const T& s) \
   { \
-    DO_VS_OP (OP); \
-    return MArray2<T> (result, a.rows (), a.cols ()); \
+    MArray2<T> result (a.rows (), a.cols ()); \
+    T *r = result.fortran_vec (); \
+    int l = a.length (); \
+    const T *v = a.data (); \
+    DO_VS_OP (r, l, v, OP, s); \
+    return result; \
   }
 
 MARRAY_A2S_OP (+)
 MARRAY_A2S_OP (-)
 MARRAY_A2S_OP (*)
 MARRAY_A2S_OP (/)
 
 // Element by element scalar by MArray2 ops.
 
 #define MARRAY_SA2_OP(OP) \
   template <class T> \
   MArray2<T> \
   operator OP (const T& s, const MArray2<T>& a) \
   { \
-    DO_SV_OP (OP); \
-    return MArray2<T> (result, a.rows (), a.cols ()); \
+    MArray2<T> result (a.rows (), a.cols ()); \
+    T *r = result.fortran_vec (); \
+    int l = a.length (); \
+    const T *v = a.data (); \
+    DO_SV_OP (r, l, s, OP, v); \
+    return result; \
   }
 
 MARRAY_SA2_OP (+)
 MARRAY_SA2_OP (-)
 MARRAY_SA2_OP (*)
 MARRAY_SA2_OP (/)
 
 // Element by element MArray2 by MArray2 ops.
 
 #define MARRAY_A2A2_OP(FCN, OP) \
   template <class T> \
   MArray2<T> \
   FCN (const MArray2<T>& a, const MArray2<T>& b) \
   { \
-    int r = a.rows (); \
-    int c = a.cols (); \
-    int br = b.rows (); \
-    int bc = b.cols (); \
-    if (r != br || c != bc) \
+    int a_nr = a.rows (); \
+    int a_nc = a.cols (); \
+    int b_nr = b.rows (); \
+    int b_nc = b.cols (); \
+    if (a_nr != b_nr || a_nc != b_nc) \
       { \
-        gripe_nonconformant (#FCN, r, c, br, bc); \
+        gripe_nonconformant (#FCN, a_nr, a_nc, b_nr, b_nc); \
 	return MArray2<T> (); \
       } \
-    if (r == 0 || c == 0) \
-      return MArray2<T> (r, c); \
+    if (a_nr == 0 || a_nc == 0) \
+      return MArray2<T> (a_nr, a_nc); \
     int l = a.length (); \
-    DO_VV_OP (OP); \
-    return MArray2<T> (result, r, c); \
+    MArray2<T> result (a_nr, a_nc); \
+    T *r = result.fortran_vec (); \
+    const T *x = a.data (); \
+    const T *y = b.data (); \
+    DO_VV_OP (r, l, x, OP, y); \
+    return result; \
   }
 
 MARRAY_A2A2_OP (operator +, +)
 MARRAY_A2A2_OP (operator -, -)
 MARRAY_A2A2_OP (product,    *)
 MARRAY_A2A2_OP (quotient,   /)
 
 // Unary MArray2 ops.
 
 template <class T>
 MArray2<T>
 operator - (const MArray2<T>& a)
 {
-  NEG_V;
-  return MArray2<T> (result, a.rows (), a.cols ());
+  int l = a.length ();
+  MArray2<T> result (a.rows (), a.cols ());
+  T *r = result.fortran_vec ();
+  const T *x = a.data ();
+  NEG_V (r, l, x);
+  return result;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/MArray2.h b/liboctave/MArray2.h
--- a/liboctave/MArray2.h
+++ b/liboctave/MArray2.h
@@ -122,50 +122,16 @@ public:
 
   MArray2<T>& insert (const Array2<T>& a, int r, int c)
   {
     Array2<T>::insert (a, r, c);
     return *this;
   }
 
   MArray2<T> transpose (void) const { return Array2<T>::transpose (); }
-
-  // element by element MArray2 by scalar ops
-
-  friend MArray2<T>& operator += LTGT (MArray2<T>& a, const T& s);
-  friend MArray2<T>& operator -= LTGT (MArray2<T>& a, const T& s);
-
-  // element by element MArray2 by MArray2 ops
-
-  friend MArray2<T>& operator += LTGT (MArray2<T>& a, const MArray2<T>& b);
-  friend MArray2<T>& operator -= LTGT (MArray2<T>& a, const MArray2<T>& b);
-
-  // element by element MArray2 by scalar ops
-
-  friend MArray2<T> operator + LTGT (const MArray2<T>& a, const T& s);
-  friend MArray2<T> operator - LTGT (const MArray2<T>& a, const T& s);
-  friend MArray2<T> operator * LTGT (const MArray2<T>& a, const T& s);
-  friend MArray2<T> operator / LTGT (const MArray2<T>& a, const T& s);
-
-  // element by element scalar by MArray2 ops
-
-  friend MArray2<T> operator + LTGT (const T& s, const MArray2<T>& a);
-  friend MArray2<T> operator - LTGT (const T& s, const MArray2<T>& a);
-  friend MArray2<T> operator * LTGT (const T& s, const MArray2<T>& a);
-  friend MArray2<T> operator / LTGT (const T& s, const MArray2<T>& a);
-
-  // element by element MArray2 by MArray2 ops
-
-  friend MArray2<T> operator + LTGT (const MArray2<T>& a, const MArray2<T>& b);
-  friend MArray2<T> operator - LTGT (const MArray2<T>& a, const MArray2<T>& b);
-
-  friend MArray2<T> product LTGT (const MArray2<T>& a, const MArray2<T>& b);
-  friend MArray2<T> quotient LTGT (const MArray2<T>& a, const MArray2<T>& b);
-
-  friend MArray2<T> operator - LTGT (const MArray2<T>& a);
 };
 
 #undef LTGT
 
 extern void
 gripe_nonconformant (const char *op, int op1_nr, int op1_nc,
 		     int op2_nr, int op2_nc);
 
diff --git a/liboctave/MDiagArray2.cc b/liboctave/MDiagArray2.cc
--- a/liboctave/MDiagArray2.cc
+++ b/liboctave/MDiagArray2.cc
@@ -87,67 +87,83 @@ operator -= (MDiagArray2<T>& a, const MD
 
 // Element by element MDiagArray2 by scalar ops.
 
 #define MARRAY_DAS_OP(OP) \
   template <class T> \
   MDiagArray2<T> \
   operator OP (const MDiagArray2<T>& a, const T& s) \
   { \
-    DO_VS_OP (OP); \
-    return MDiagArray2<T> (result, a.rows (), a.cols ()); \
+    MDiagArray2<T> result (a.rows (), a.cols ()); \
+    T *r = result.fortran_vec (); \
+    int l = a.length (); \
+    const T *v = a.data (); \
+    DO_VS_OP (r, l, v, OP, s); \
+    return result; \
   }
 
 MARRAY_DAS_OP (*)
 MARRAY_DAS_OP (/)
 
 // Element by element scalar by MDiagArray2 ops.
 
 template <class T>
 MDiagArray2<T>
 operator * (const T& s, const MDiagArray2<T>& a)
 {
-  DO_SV_OP (*);
-  return MDiagArray2<T> (result, a.rows (), a.cols ());
+  MDiagArray2<T> result (a.rows (), a.cols ()); \
+  T *r = result.fortran_vec (); \
+  int l = a.length (); \
+  const T *v = a.data (); \
+  DO_SV_OP (r, l, s, *, v); \
+  return result; \
 }
 
 // Element by element MDiagArray2 by MDiagArray2 ops.
 
 #define MARRAY_DADA_OP(FCN, OP) \
   template <class T> \
   MDiagArray2<T> \
   FCN (const MDiagArray2<T>& a, const MDiagArray2<T>& b) \
   { \
-    int r = a.rows (); \
-    int c = a.cols (); \
+    int a_nr = a.rows (); \
+    int a_nc = a.cols (); \
     int b_nr = b.rows (); \
     int b_nc = b.cols (); \
-    if (r != b_nr || c != b_nc) \
+    if (a_nr != b_nr || a_nc != b_nc) \
       { \
-        gripe_nonconformant (#FCN, r, c, b_nr, b_nc); \
+        gripe_nonconformant (#FCN, a_nr, a_nc, b_nr, b_nc); \
 	return MDiagArray2<T> (); \
       } \
-    if (c == 0 || r == 0) \
+    if (a_nc == 0 || a_nr == 0) \
       return MDiagArray2<T> (); \
     int l = a.length (); \
-    DO_VV_OP (OP); \
-    return MDiagArray2<T> (result, r, c); \
+    MDiagArray2<T> result (a_nr, a_nc); \
+    T *r = result.fortran_vec (); \
+    const T *x = a.data (); \
+    const T *y = b.data (); \
+    DO_VV_OP (r, l, x, OP, y); \
+    return result; \
   }
 
 MARRAY_DADA_OP (operator +, +)
 MARRAY_DADA_OP (operator -, -)
 MARRAY_DADA_OP (product,    *)
 
 // Unary MDiagArray2 ops.
 
 template <class T>
 MDiagArray2<T>
 operator - (const MDiagArray2<T>& a)
 {
-  NEG_V;
-  return MDiagArray2<T> (result, a.rows (), a.cols ());
+  int l = a.length ();
+  MDiagArray2<T> result (a.rows (), a.cols ());
+  T *r = result.fortran_vec ();
+  const T *x = a.data ();
+  NEG_V (r, l, x);
+  return result;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/MDiagArray2.h b/liboctave/MDiagArray2.h
--- a/liboctave/MDiagArray2.h
+++ b/liboctave/MDiagArray2.h
@@ -104,46 +104,16 @@ public:
 
       int len = nr < nc ? nr : nc;
 
       for (int i = 0; i < len; i++)
 	retval.xelem (i, i) = xelem (i, i);
 
       return retval;
     }
-
-  // element by element MDiagArray2 by MDiagArray2 ops
-
-  friend MDiagArray2<T>&
-  operator += LTGT (MDiagArray2<T>& a, const MDiagArray2<T>& b);
-
-  friend MDiagArray2<T>&
-  operator -= LTGT (MDiagArray2<T>& a, const MDiagArray2<T>& b);
-
-  // element by element MDiagArray2 by scalar ops
-
-  friend MDiagArray2<T> operator * LTGT (const MDiagArray2<T>& a, const T& s);
-  friend MDiagArray2<T> operator / LTGT (const MDiagArray2<T>& a, const T& s);
-
-  // element by element scalar by MDiagArray2 ops
-
-  friend MDiagArray2<T> operator * LTGT (const T& s, const MDiagArray2<T>& a);
-
-  // element by element MDiagArray2 by MDiagArray2 ops
-
-  friend MDiagArray2<T>
-  operator + LTGT (const MDiagArray2<T>& a, const MDiagArray2<T>& b); 
-
-  friend MDiagArray2<T>
-  operator - LTGT (const MDiagArray2<T>& a, const MDiagArray2<T>& b);
-
-  friend MDiagArray2<T>
-  product LTGT (const MDiagArray2<T>& a, const MDiagArray2<T>& b);
-
-  friend MDiagArray2<T> operator - LTGT (const MDiagArray2<T>& a);
 };
 
 #undef LTGT
 
 #define INSTANTIATE_MDIAGARRAY_FRIENDS(T) \
   template MDiagArray2<T>& operator += (MDiagArray2<T>& a, const MDiagArray2<T>& b); \
   template MDiagArray2<T>& operator -= (MDiagArray2<T>& a, const MDiagArray2<T>& b); \
   template MDiagArray2<T> operator * (const MDiagArray2<T>& a, const T& s); \
diff --git a/liboctave/Range.cc b/liboctave/Range.cc
--- a/liboctave/Range.cc
+++ b/liboctave/Range.cc
@@ -107,39 +107,39 @@ Range::sort (void)
       rng_limit = tmp;
       rng_inc = -rng_inc;
     }
 }
 
 void
 Range::print_range (void)
 {
-  cerr << "Range: rng_base = " << rng_base
-       << " rng_limit " << rng_limit
-       << " rng_inc " << rng_inc
-       << " rng_nelem " << rng_nelem << "\n";
+  std::cerr << "Range: rng_base = " << rng_base
+	    << " rng_limit " << rng_limit
+	    << " rng_inc " << rng_inc
+	    << " rng_nelem " << rng_nelem << "\n";
 }
 
-ostream&
-operator << (ostream& os, const Range& a)
+std::ostream&
+operator << (std::ostream& os, const Range& a)
 {
   double b = a.base ();
   double increment = a.inc ();
   int num_elem = a.nelem ();
 
   for (int i = 0; i < num_elem; i++)
     os << b + i * increment << " ";
 
   os << "\n";
 
   return os;
 }
 
-istream&
-operator >> (istream& is, Range& a)
+std::istream&
+operator >> (std::istream& is, Range& a)
 {
   is >> a.rng_base;
   if (is)
     {
       is >> a.rng_limit;
       if (is)
 	{
 	  is >> a.rng_inc;
diff --git a/liboctave/Range.h b/liboctave/Range.h
--- a/liboctave/Range.h
+++ b/liboctave/Range.h
@@ -64,18 +64,18 @@ Range
   double max (void) const;
 
   void sort (void);
 
   void set_base (double b) { rng_base = b;  }
   void set_limit (double l) { rng_limit = l; }
   void set_inc (double i) { rng_inc = i;   }
 
-  friend ostream& operator << (ostream& os, const Range& r);
-  friend istream& operator >> (istream& is, Range& r);
+  friend std::ostream& operator << (std::ostream& os, const Range& r);
+  friend std::istream& operator >> (std::istream& is, Range& r);
 
   void print_range (void);
 
  private:
 
   double rng_base;
   double rng_limit;
   double rng_inc;
diff --git a/liboctave/boolMatrix.h b/liboctave/boolMatrix.h
--- a/liboctave/boolMatrix.h
+++ b/liboctave/boolMatrix.h
@@ -64,18 +64,18 @@ public:
   // other operations
 
   boolMatrix all (void) const;
   boolMatrix any (void) const;
 
 #if 0
   // i/o
 
-  friend ostream& operator << (ostream& os, const Matrix& a);
-  friend istream& operator >> (istream& is, Matrix& a);
+  friend std::ostream& operator << (std::ostream& os, const Matrix& a);
+  friend std::istream& operator >> (std::istream& is, Matrix& a);
 #endif
 
 private:
 
   boolMatrix (bool *b, int r, int c) : Array2<bool> (b, r, c) { }
 };
 
 #endif
diff --git a/liboctave/chMatrix.cc b/liboctave/chMatrix.cc
--- a/liboctave/chMatrix.cc
+++ b/liboctave/chMatrix.cc
@@ -57,17 +57,17 @@ charMatrix::charMatrix (const char *s)
   int nr = s && nc > 0 ? 1 : 0;
 
   resize (nr, nc);
 
   for (int i = 0; i < nc; i++)
     elem (0, i) = s[i];
 }
 
-charMatrix::charMatrix (const string& s)
+charMatrix::charMatrix (const std::string& s)
   : MArray2<char> ()
 {
   int nc = s.length ();
   int nr = nc > 0 ? 1 : 0;
 
   resize (nr, nc);
 
   for (int i = 0; i < nc; i++)
@@ -123,20 +123,20 @@ charMatrix::insert (const char *s, int r
 
 charMatrix&
 charMatrix::insert (const charMatrix& a, int r, int c)
 {
   Array2<char>::insert (a, r, c);
   return *this;
 }
 
-string
-charMatrix::row_as_string (int r, bool strip_ws = false) const 
+std::string
+charMatrix::row_as_string (int r, bool strip_ws) const 
 {
-  string retval;
+  std::string retval;
 
   int nr = rows ();
   int nc = cols ();
 
   if (r == 0 && nr == 0 && nc == 0)
     return retval;
 
   if (r < 0 || r >= nr)
diff --git a/liboctave/chMatrix.h b/liboctave/chMatrix.h
--- a/liboctave/chMatrix.h
+++ b/liboctave/chMatrix.h
@@ -43,47 +43,47 @@ public:
 
   charMatrix (void) : MArray2<char> () { }
   charMatrix (int r, int c) : MArray2<char> (r, c) { }
   charMatrix (int r, int c, char val) : MArray2<char> (r, c, val) { }
   charMatrix (const MArray2<char>& a) : MArray2<char> (a) { }
   charMatrix (const charMatrix& a) : MArray2<char> (a) { }
   charMatrix (char c);
   charMatrix (const char *s);
-  charMatrix (const string& s);
+  charMatrix (const std::string& s);
   charMatrix (const string_vector& s);
 
   charMatrix& operator = (const charMatrix& a)
     {
       MArray2<char>::operator = (a);
       return *this;
     }
 
   bool operator == (const charMatrix& a) const;
   bool operator != (const charMatrix& a) const;
 
   // destructive insert/delete/reorder operations
 
   charMatrix& insert (const char *s, int r, int c);
   charMatrix& insert (const charMatrix& a, int r, int c);
 
-  string row_as_string (int r, bool strip_trailing_whitespace = false) const;
+  std::string row_as_string (int, bool = false) const;
 
   // resize is the destructive equivalent for this one
 
   charMatrix extract (int r1, int c1, int r2, int c2) const;
 
   Matrix all (void) const;
   Matrix any (void) const;
 
 #if 0
   // i/o
 
-  friend ostream& operator << (ostream& os, const Matrix& a);
-  friend istream& operator >> (istream& is, Matrix& a);
+  friend std::ostream& operator << (std::ostream& os, const Matrix& a);
+  friend std::istream& operator >> (std::istream& is, Matrix& a);
 #endif
 
 private:
 
   charMatrix (char *ch, int r, int c) : MArray2<char> (ch, r, c) { }
 };
 
 #endif
diff --git a/liboctave/cmd-edit.cc b/liboctave/cmd-edit.cc
--- a/liboctave/cmd-edit.cc
+++ b/liboctave/cmd-edit.cc
@@ -68,19 +68,19 @@ public:
   typedef command_editor::fcn fcn;
 
   typedef command_editor::completion_fcn completion_fcn;
 
   gnu_readline (void);
 
   ~gnu_readline (void) { }
 
-  void do_set_name (const string& n);
+  void do_set_name (const std::string& n);
 
-  string do_readline (const string& prompt, bool& eof);
+  std::string do_readline (const std::string& prompt, bool& eof);
 
   void do_set_input_stream (FILE *f);
 
   FILE *do_get_input_stream (void);
 
   void do_set_output_stream (FILE *f);
 
   FILE *do_get_output_stream (void);
@@ -88,45 +88,45 @@ public:
   int do_terminal_rows (void);
 
   int do_terminal_cols (void);
 
   void do_clear_screen (void);
 
   void do_resize_terminal (void);
 
-  string newline_chars (void);
+  std::string newline_chars (void);
 
   void do_restore_terminal_state (void);
 
   void do_blink_matching_paren (bool flag);
 
-  void do_set_basic_quote_characters (const string& s);
+  void do_set_basic_quote_characters (const std::string& s);
 
   void do_set_completion_append_character (char c);
 
   void do_set_completion_function (completion_fcn f);
 
   completion_fcn do_get_completion_function (void) const;
 
-  void do_insert_text (const string& text);
+  void do_insert_text (const std::string& text);
 
   void do_newline (void);
 
   void do_clear_undo_list (void);
 
   void do_set_startup_hook (fcn f);
 
   void do_restore_startup_hook (void);
 
   void do_set_event_hook (fcn f);
 
   void do_restore_event_hook (void);
 
-  void do_read_init_file (const string& file);
+  void do_read_init_file (const std::string& file);
 
   static void operate_and_get_next (int, int);
 
 private:
 
   fcn previous_startup_hook;
 
   fcn previous_event_hook;
@@ -158,37 +158,37 @@ gnu_readline::gnu_readline ()
   rl_add_defun ("history-search-backward",
 		rl_history_search_backward, META ('p'));
 
   rl_add_defun ("history-search-forward",
 		rl_history_search_forward, META ('n'));
 }
 
 void
-gnu_readline::do_set_name (const string& n)
+gnu_readline::do_set_name (const std::string& n)
 {
   static char *nm = 0;
 
   delete [] nm;
 
   nm = strsave (n.c_str ());
 
   rl_readline_name = nm;
 
   // Since we've already called rl_initialize, we need to re-read the
   // init file to take advantage of the conditional parsing feature
   // based on rl_readline_name;
 
   rl_re_read_init_file ();
 }
 
-string
-gnu_readline::do_readline (const string& prompt, bool& eof)
+std::string
+gnu_readline::do_readline (const std::string& prompt, bool& eof)
 {
-  string retval;
+  std::string retval;
 
   eof = false;
 
   char *line = ::readline (prompt.c_str ());
 
   if (line)
     {
       retval = line;
@@ -250,17 +250,17 @@ gnu_readline::do_clear_screen (void)
 }
 
 void
 gnu_readline::do_resize_terminal (void)
 {
   rl_resize_terminal ();
 }
 
-string
+std::string
 gnu_readline::newline_chars (void)
 {
   return "\r\n";
 }
 
 void
 gnu_readline::do_restore_terminal_state (void)
 {
@@ -270,17 +270,17 @@ gnu_readline::do_restore_terminal_state 
 
 void
 gnu_readline::do_blink_matching_paren (bool flag)
 {
   rl_blink_matching_paren = flag ? 1 : 0;
 }
 
 void
-gnu_readline::do_set_basic_quote_characters (const string& s)
+gnu_readline::do_set_basic_quote_characters (const std::string& s)
 {
   static char *ss = 0;
 
   delete [] ss;
 
   ss = strsave (s.c_str ());
 
   rl_basic_quote_characters = ss;
@@ -306,17 +306,17 @@ gnu_readline::do_set_completion_function
 
 gnu_readline::completion_fcn
 gnu_readline::do_get_completion_function (void) const
 {
   return completion_function;
 }
 
 void
-gnu_readline::do_insert_text (const string& text)
+gnu_readline::do_insert_text (const std::string& text)
 {
   rl_insert_text (text.c_str ());
 }
 
 void
 gnu_readline::do_newline (void)
 {
   rl_newline ();
@@ -357,17 +357,17 @@ gnu_readline::do_set_event_hook (fcn f)
 
 void
 gnu_readline::do_restore_event_hook (void)
 {
   rl_event_hook = previous_event_hook;
 }
 
 void
-gnu_readline::do_read_init_file (const string& file)
+gnu_readline::do_read_init_file (const std::string& file)
 {
   if (file.empty ())
     rl_re_read_init_file ();
   else
     rl_read_init_file (file.c_str ());
 }
 
 void
@@ -395,17 +395,17 @@ gnu_readline::operate_and_get_next (int 
 
 char *
 gnu_readline::command_generator (const char *text, int state)
 {
   char *retval = 0;
 
   completion_fcn f = command_editor::get_completion_function ();
 
-  string tmp = f (text, state);
+  std::string tmp = f (text, state);
 
   size_t len = tmp.length ();
 
   if (len > 0)
     {
       retval = static_cast<char *> (malloc (len+1));
 
       strcpy (retval, tmp.c_str ());
@@ -429,39 +429,39 @@ default_command_editor : public command_
 {
 public:
 
   default_command_editor (void)
     : command_editor (), input_stream (stdin), output_stream (stdout) { }
 
   ~default_command_editor (void) { }
 
-  string do_readline (const string& prompt, bool& eof);
+  std::string do_readline (const std::string& prompt, bool& eof);
 
   void do_set_input_stream (FILE *f);
 
   FILE *do_get_input_stream (void);
 
   void do_set_output_stream (FILE *f);
 
   FILE *do_get_output_stream (void);
 
-  void do_insert_text (const string&);
+  void do_insert_text (const std::string&);
 
   void do_newline (void);
 
 private:
 
   FILE *input_stream;
 
   FILE *output_stream;
 };
 
-string
-default_command_editor::do_readline (const string& prompt, bool& eof)
+std::string
+default_command_editor::do_readline (const std::string& prompt, bool& eof)
 {
   eof = false;
 
   fprintf (output_stream, prompt.c_str ());
   fflush (output_stream);
 
   return octave_fgets (input_stream);
 }
@@ -486,17 +486,17 @@ default_command_editor::do_set_output_st
 
 FILE *
 default_command_editor::do_get_output_stream (void)
 {
   return output_stream;
 }
 
 void
-default_command_editor::do_insert_text (const string&)
+default_command_editor::do_insert_text (const std::string&)
 {
   // XXX FIXME XXX
 }
 
 void
 default_command_editor::do_newline (void)
 {
   // XXX FIXME XXX
@@ -527,35 +527,35 @@ command_editor::make_command_editor (voi
 #if defined (USE_READLINE)
   instance = new gnu_readline ();
 #else
   instance = new default_command_editor ();
 #endif
 }
 
 void
-command_editor::set_name (const string& n)
+command_editor::set_name (const std::string& n)
 {
   if (instance_ok ())
     instance->do_set_name (n);
 }
 
-string
-command_editor::readline (const string& prompt)
+std::string
+command_editor::readline (const std::string& prompt)
 {
   bool eof;
 
   return readline (prompt, eof);
 }
 
-string
-command_editor::readline (const string& prompt, bool& eof)
+std::string
+command_editor::readline (const std::string& prompt, bool& eof)
 {
   return (instance_ok ())
-    ? instance->do_readline (prompt, eof) : string ();
+    ? instance->do_readline (prompt, eof) : std::string ();
 }
 
 void
 command_editor::set_input_stream (FILE *f)
 {
   if (instance_ok ())
     instance->do_set_input_stream (f);
 }
@@ -604,21 +604,21 @@ command_editor::clear_screen (void)
 
 void
 command_editor::resize_terminal (void)
 {
   if (instance_ok ())
     instance->do_resize_terminal ();
 }
 
-string
-command_editor::decode_prompt_string (const string& s)
+std::string
+command_editor::decode_prompt_string (const std::string& s)
 {
   return (instance_ok ())
-    ? instance->do_decode_prompt_string (s) : string ();
+    ? instance->do_decode_prompt_string (s) : std::string ();
 }
 
 int
 command_editor::current_command_number (void)
 {
   return (instance_ok ())
     ? instance->command_number : 0;
 }
@@ -647,17 +647,17 @@ command_editor::restore_terminal_state (
 void
 command_editor::blink_matching_paren (bool flag)
 {
   if (instance_ok ())
     instance->do_blink_matching_paren (flag);
 }
 
 void
-command_editor::set_basic_quote_characters (const string& s)
+command_editor::set_basic_quote_characters (const std::string& s)
 {
   if (instance_ok ())
     instance->do_set_basic_quote_characters (s);
 }
 
 void
 command_editor::set_completion_append_character (char c)
 {
@@ -675,17 +675,17 @@ command_editor::set_completion_function 
 command_editor::completion_fcn
 command_editor::get_completion_function (void)
 {
   return (instance_ok ())
     ? instance->do_get_completion_function () : 0;
 }
 
 void
-command_editor::insert_text (const string& text)
+command_editor::insert_text (const std::string& text)
 {
   if (instance_ok ())
     instance->do_insert_text (text);
 }
 
 void
 command_editor::newline (void)
 {
@@ -724,17 +724,17 @@ command_editor::set_event_hook (fcn f)
 void
 command_editor::restore_event_hook (void)
 {
   if (instance_ok ())
     instance->do_restore_event_hook ();
 }
 
 void
-command_editor::read_init_file (const string& file)
+command_editor::read_init_file (const std::string& file)
 {
   if (instance_ok ())
     instance->do_read_init_file (file);
 }
 
 // Return a string which will be printed as a prompt.  The string may
 // contain special characters which are decoded as follows: 
 //   
@@ -747,21 +747,21 @@ command_editor::read_init_file (const st
 //	\u	your username
 //	\h	the hostname
 //	\#	the command number of this command
 //	\!	the history number of this command
 //	\$	a $ or a # if you are root
 //	\<octal> character code in octal
 //	\\	a backslash
 
-string
-command_editor::do_decode_prompt_string (const string& s)
+std::string
+command_editor::do_decode_prompt_string (const std::string& s)
 {
-  string result;
-  string temp;
+  std::string result;
+  std::string temp;
   size_t i = 0;
   size_t slen = s.length ();
   int c;
 
   while (i < slen)
     {
       c = s[i];
 
@@ -951,17 +951,17 @@ command_editor::do_decode_prompt_string 
 
   return result;
 }
 
 // Return the octal number parsed from STRING, or -1 to indicate that
 // the string contained a bad number.
 
 int
-command_editor::read_octal (const string& s)
+command_editor::read_octal (const std::string& s)
 {
   int result = 0;
   int digits = 0;
 
   size_t i = 0;
   size_t slen = s.length ();
 
   while (i < slen && s[i] >= '0' && s[i] < '8')
@@ -979,17 +979,17 @@ command_editor::read_octal (const string
 
 void
 command_editor::error (int err_num)
 {
   current_liboctave_error_handler ("%s", strerror (err_num));
 }
 
 void
-command_editor::error (const string& s)
+command_editor::error (const std::string& s)
 {
   current_liboctave_error_handler ("%s", s.c_str ());
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/cmd-edit.h b/liboctave/cmd-edit.h
--- a/liboctave/cmd-edit.h
+++ b/liboctave/cmd-edit.h
@@ -34,25 +34,25 @@ protected:
 
   command_editor (void)
     : command_number (0) { }
 
 public:
 
   typedef int (*fcn) (...);
 
-  typedef string (*completion_fcn) (const string&, int);
+  typedef std::string (*completion_fcn) (const std::string&, int);
 
   virtual ~command_editor (void) { }
 
-  static void set_name (const string& n);
+  static void set_name (const std::string& n);
 
-  static string readline (const string& prompt);
+  static std::string readline (const std::string& prompt);
 
-  static string readline (const string& prompt, bool& eof);
+  static std::string readline (const std::string& prompt, bool& eof);
 
   static void set_input_stream (FILE *f);
 
   static FILE *get_input_stream (void);
 
   static void set_output_stream (FILE *f);
 
   static FILE *get_output_stream (void);
@@ -60,45 +60,45 @@ public:
   static int terminal_rows (void);
 
   static int terminal_cols (void);
 
   static void clear_screen (void);
 
   static void resize_terminal (void);
 
-  static string decode_prompt_string (const string& s);
+  static std::string decode_prompt_string (const std::string& s);
 
   static void restore_terminal_state (void);
 
   static void blink_matching_paren (bool flag);
 
-  static void set_basic_quote_characters (const string& s);
+  static void set_basic_quote_characters (const std::string& s);
 
   static void set_completion_append_character (char c);
 
   static void set_completion_function (completion_fcn f);
 
   static completion_fcn get_completion_function (void);
 
-  static void insert_text (const string& text);
+  static void insert_text (const std::string& text);
 
   static void newline (void);
 
   static void clear_undo_list (void);
 
   static void set_startup_hook (fcn f);
 
   static void restore_startup_hook (void);
 
   static void set_event_hook (fcn f);
 
   static void restore_event_hook (void);
 
-  static void read_init_file (const string& file = string ());
+  static void read_init_file (const std::string& file = std::string ());
 
   static int current_command_number (void);
 
   static void reset_current_command_number (int n);
 
   static void increment_current_command_number (void);
 
 private:
@@ -117,26 +117,26 @@ private:
   static command_editor *instance;
 
 protected:
 
   // To use something other than the GNU readline library, derive a new
   // class from command_editor, overload these functions as
   // necessary, and make instance point to the new class.
 
-  virtual void do_set_name (const string&) { }
+  virtual void do_set_name (const std::string&) { }
 
-  string do_readline (const string& prompt)
+  std::string do_readline (const std::string& prompt)
     {
       bool eof;
 
       return do_readline (prompt, eof);
     }
 
-  virtual string do_readline (const string&, bool&) = 0;
+  virtual std::string do_readline (const std::string&, bool&) = 0;
 
   virtual void do_set_input_stream (FILE *) = 0;
 
   virtual FILE *do_get_input_stream (void) = 0;
 
   virtual void do_set_output_stream (FILE *) = 0;
 
   virtual FILE *do_get_output_stream (void) = 0;
@@ -144,53 +144,53 @@ protected:
   virtual int do_terminal_rows (void) { return 24; }
 
   virtual int do_terminal_cols (void) { return 80; }
 
   virtual void do_clear_screen (void) { }
 
   virtual void do_resize_terminal (void) { }
 
-  virtual string do_decode_prompt_string (const string&);
+  virtual std::string do_decode_prompt_string (const std::string&);
 
-  virtual string newline_chars (void) { return "\n"; } 
+  virtual std::string newline_chars (void) { return "\n"; } 
 
   virtual void do_restore_terminal_state (void) { }
 
   virtual void do_blink_matching_paren (bool) { }
 
-  virtual void do_set_basic_quote_characters (const string&) { }
+  virtual void do_set_basic_quote_characters (const std::string&) { }
 
   virtual void do_set_completion_append_character (char) { }
 
   virtual void do_set_completion_function (completion_fcn) { }
 
   virtual completion_fcn do_get_completion_function (void) const { return 0; }
 
-  virtual void do_insert_text (const string&) = 0;
+  virtual void do_insert_text (const std::string&) = 0;
 
   virtual void do_newline (void) = 0;
 
   virtual void do_clear_undo_list (void) { }
 
   virtual void do_set_startup_hook (fcn) { }
 
   virtual void do_restore_startup_hook (void) { }
 
   virtual void do_set_event_hook (fcn) { }
 
   virtual void do_restore_event_hook (void) { }
 
-  virtual void do_read_init_file (const string&) { }
+  virtual void do_read_init_file (const std::string&) { }
 
-  int read_octal (const string& s);
+  int read_octal (const std::string& s);
 
   void error (int);
 
-  void error (const string&);
+  void error (const std::string&);
 
   // The current command number.
   int command_number;
 };
 
 #endif
 
 /*
diff --git a/liboctave/cmd-hist.cc b/liboctave/cmd-hist.cc
--- a/liboctave/cmd-hist.cc
+++ b/liboctave/cmd-hist.cc
@@ -21,16 +21,18 @@ Software Foundation, 59 Temple Place - S
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cstring>
 
+#include <iostream>
+#include <strstream>
 #include <string>
 
 #include "cmd-edit.h"
 #include "cmd-hist.h"
 #include "lo-error.h"
 #include "str-vec.h"
 
 command_history *command_history::instance = 0;
@@ -61,17 +63,17 @@ gnu_history : public command_history
 {
 public:
 
   gnu_history (void)
     : command_history (), mark (0) { }
 
   ~gnu_history (void) { }
 
-  void do_add (const string&);
+  void do_add (const std::string&);
 
   void do_remove (int);
 
   int do_where (void);
 
   int do_length (void);
 
   int do_max_input_history (void);
@@ -85,41 +87,41 @@ public:
   int do_unstifle (void);
 
   int do_is_stifled (void);
 
   void do_set_mark (int);
 
   void do_goto_mark (void);
 
-  void do_read (const string&, bool);
+  void do_read (const std::string&, bool);
 
-  void do_read_range (const string&, int, int, bool);
+  void do_read_range (const std::string&, int, int, bool);
 
-  void do_write (const string&);
+  void do_write (const std::string&);
 
-  void do_append (const string&);
+  void do_append (const std::string&);
 
-  void do_truncate_file (const string&, int);
+  void do_truncate_file (const std::string&, int);
 
   string_vector do_list (int, bool);
 
-  string do_get_entry (int);
+  std::string do_get_entry (int);
 
-  void do_replace_entry (int, const string&);
+  void do_replace_entry (int, const std::string&);
 
-  void do_clean_up_and_save (const string&, int);
+  void do_clean_up_and_save (const std::string&, int);
 
 private:
 
   int mark;
 };
 
 void
-gnu_history::do_add (const string& s)
+gnu_history::do_add (const std::string& s)
 {
   if (! do_ignoring_entries ())
     {
       if (s.empty ()
 	  || (s.length () == 1 && (s[0] == '\r' || s[0] == '\n')))
 	return;
 
       ::add_history (s.c_str ());
@@ -218,17 +220,17 @@ gnu_history::do_goto_mark (void)
 
   mark = 0;
 
   // XXX FIXME XXX -- for operate_and_get_next.
   command_editor::restore_startup_hook ();
 }
 
 void
-gnu_history::do_read (const string& f, bool must_exist)
+gnu_history::do_read (const std::string& f, bool must_exist)
 {
   if (! f.empty ())
     {
       int status = ::read_history (f.c_str ());
 
       if (status != 0 && must_exist)
 	error (status);
       else
@@ -238,17 +240,17 @@ gnu_history::do_read (const string& f, b
 	  ::using_history ();
 	}
     }
   else
     error ("gnu_history::read: missing file name");
 }
 
 void
-gnu_history::do_read_range (const string& f, int from, int to,
+gnu_history::do_read_range (const std::string& f, int from, int to,
 			    bool must_exist)
 {
   if (from < 0)
     from = lines_in_file;
 
   if (! f.empty ())
     {
       int status = ::read_history_range (f.c_str (), from, to);
@@ -262,44 +264,44 @@ gnu_history::do_read_range (const string
 	  ::using_history ();
 	}
     }
   else
     error ("gnu_history::read_range: missing file name");
 }
 
 void
-gnu_history::do_write (const string& f_arg)
+gnu_history::do_write (const std::string& f_arg)
 {
-  string f = f_arg;
+  std::string f = f_arg;
 
   if (f.empty ())
     f = xfile;
 
   if (! f.empty ())
     {
       int status = ::write_history (f.c_str ());
 
       if (status != 0)
 	error (status);
     }
   else
     error ("gnu_history::write: missing file name");
 }
 
 void
-gnu_history::do_append (const string& f_arg)
+gnu_history::do_append (const std::string& f_arg)
 {
   if (lines_this_session)
     {
       if (lines_this_session < do_where ())
 	{
 	  // Create file if it doesn't already exist.
 
-	  string f = f_arg;
+	  std::string f = f_arg;
 
 	  if (f.empty ())
 	    f = xfile;
 
 	  if (! f.empty ())
 	    {
 	      file_stat fs (f);
 
@@ -322,19 +324,19 @@ gnu_history::do_append (const string& f_
 	    }
 	  else
 	    error ("gnu_history::append: missing file name");
 	}
     }
 }
 
 void
-gnu_history::do_truncate_file (const string& f_arg, int n)
+gnu_history::do_truncate_file (const std::string& f_arg, int n)
 {
-  string f = f_arg;
+  std::string f = f_arg;
 
   if (f.empty ())
     f = xfile;
 
   if (! f.empty ())
     ::history_truncate_file (f.c_str (), n);
   else
     error ("gnu_history::truncate_file: missing file name");
@@ -357,67 +359,67 @@ gnu_history::do_list (int limit, bool nu
 
 	  int beg = (limit < 0 || end < limit) ? 0 : (end - limit);
 
 	  retval.resize (end - beg);
 
 	  int k = 0;
 	  for (int i = beg; i < end; i++)
 	    {
-	      ostrstream output_buf;
+	      std::ostrstream output_buf;
 
 	      if (number_lines)
 		output_buf.form ("%5d%c", i + do_base (),
 				 hlist[i]->data ? '*' : ' '); 
 
-	      output_buf << hlist[i]->line << ends;
+	      output_buf << hlist[i]->line << std::ends;
 
 	      const char *tmp = output_buf.str ();
 
 	      retval[k++] = tmp;
 
 	      delete [] tmp;  
 	    }
 	}
     }
 
   return retval;
 }
 
-string
+std::string
 gnu_history::do_get_entry (int n)
 {
-  string retval;
+  std::string retval;
 
   HIST_ENTRY *entry = ::history_get (do_base () + n);
 
   if (entry && entry->line)
     retval = entry->line;
 
   return retval;
 }
 
 void
-gnu_history::do_replace_entry (int which, const string& line)
+gnu_history::do_replace_entry (int which, const std::string& line)
 {
   HIST_ENTRY *discard = ::replace_history_entry (which, line.c_str (), 0);
 
   if (discard)
     {
       if (discard->line)
 	::free (discard->line);
 
       ::free (discard);
     }
 }
 
 void
-gnu_history::do_clean_up_and_save (const string& f_arg, int n)
+gnu_history::do_clean_up_and_save (const std::string& f_arg, int n)
 {
-  string f = f_arg;
+  std::string f = f_arg;
 
   if (f.empty ())
     f = xfile;
 
   if (! f.empty ())
     {
       if (n < 0)
 	n = xsize;
@@ -457,27 +459,27 @@ command_history::make_command_history (v
 #if defined (USE_READLINE)
   instance = new gnu_history ();
 #else
   instance = new command_history ();
 #endif
 }
 
 void
-command_history::set_file (const string& f)
+command_history::set_file (const std::string& f)
 {
   if (instance_ok ())
     instance->do_set_file (f);
 }
 
-string
+std::string
 command_history::file (void)
 {
   return (instance_ok ())
-    ? instance->do_file () : string ();
+    ? instance->do_file () : std::string ();
 }
 
 void
 command_history::set_size (int n)
 {
   if (instance_ok ())
     instance->do_set_size (n);
 }
@@ -499,17 +501,17 @@ command_history::ignore_entries (bool fl
 bool
 command_history::ignoring_entries (void)
 {
   return (instance_ok ())
     ? instance->do_ignoring_entries () : false;
 }
 
 void
-command_history::add (const string& s)
+command_history::add (const std::string& s)
 {
   if (instance_ok ())
     instance->do_add (s);
 }
 
 void
 command_history::remove (int n)
 {
@@ -592,93 +594,93 @@ command_history::goto_mark (...)
 void
 command_history::read (bool must_exist)
 {
   if (instance_ok ())
     instance->do_read (must_exist);
 }
 
 void
-command_history::read (const string& f, bool must_exist)
+command_history::read (const std::string& f, bool must_exist)
 {
   if (instance_ok ())
     instance->do_read (f, must_exist);
 }
 
 void
 command_history::read_range (int from, int to, bool must_exist)
 {
   if (instance_ok ())
     instance->do_read_range (from, to, must_exist);
 }
 
 void
-command_history::read_range (const string& f, int from, int to,
+command_history::read_range (const std::string& f, int from, int to,
 			     bool must_exist) 
 {
   if (instance_ok ())
     instance->do_read_range (f, from, to, must_exist);
 }
 
 void
-command_history::write (const string& f)
+command_history::write (const std::string& f)
 {
   if (instance_ok ())
     instance->do_write (f);
 }
 
 void
-command_history::append (const string& f)
+command_history::append (const std::string& f)
 {
   if (instance_ok ())
     instance->do_append (f);
 }
 
 void
-command_history::truncate_file (const string& f, int n)
+command_history::truncate_file (const std::string& f, int n)
 {
   if (instance_ok ())
     instance->do_truncate_file (f, n);
 }
 
 string_vector
 command_history::list (int limit, bool number_lines)
 {
   return (instance_ok ())
     ? instance->do_list (limit, number_lines) : string_vector ();
 }
 
-string
+std::string
 command_history::get_entry (int n)
 {
   return (instance_ok ())
-    ? instance->do_get_entry (n) : string ();
+    ? instance->do_get_entry (n) : std::string ();
 }
 
 void
-command_history::replace_entry (int which, const string& line)
+command_history::replace_entry (int which, const std::string& line)
 {
   if (instance_ok ())
     instance->do_replace_entry (which, line);
 }
 
 void
-command_history::clean_up_and_save (const string& f, int n)
+command_history::clean_up_and_save (const std::string& f, int n)
 {
   if (instance_ok ())
     instance->do_clean_up_and_save (f, n);
 }
 
 void
-command_history::do_set_file (const string& f)
+command_history::do_set_file (const std::string& f)
 {
   xfile = f;
 }
 
-string
+std::string
 command_history::do_file (void)
 {
   return xfile;
 }
 
 void
 command_history::do_set_size (int n)
 {
@@ -699,17 +701,17 @@ command_history::do_ignore_entries (bool
 
 bool
 command_history::do_ignoring_entries (void)
 {
   return ignoring_additions;
 }
 
 void
-command_history::do_add (const string&)
+command_history::do_add (const std::string&)
 {
 }
 
 void
 command_history::do_remove (int)
 {
 }
 
@@ -772,116 +774,116 @@ command_history::do_goto_mark (void)
 
 void
 command_history::do_read (bool must_exist)
 {
   do_read (xfile, must_exist);
 }
 
 void
-command_history::do_read (const string& f, bool)
+command_history::do_read (const std::string& f, bool)
 {
   if (f.empty ())
     error ("command_history::read: missing file name");
 }
 
 void
 command_history::do_read_range (int from, int to, bool must_exist)
 {
   do_read_range (xfile, from, to, must_exist);
 }
 
 void
-command_history::do_read_range (const string& f, int, int, bool)
+command_history::do_read_range (const std::string& f, int, int, bool)
 {
   if (f.empty ())
     error ("command_history::read_range: missing file name");
 }
 
 void
-command_history::do_write (const string& f_arg)
+command_history::do_write (const std::string& f_arg)
 {
-  string f = f_arg;
+  std::string f = f_arg;
 
   if (f.empty ())
     f = xfile;
 
   if (f.empty ())
     error ("command_history::write: missing file name");
 }
 
 void
-command_history::do_append (const string& f_arg)
+command_history::do_append (const std::string& f_arg)
 {
   if (lines_this_session)
     {
       if (lines_this_session < do_where ())
 	{
 	  // Create file if it doesn't already exist.
 
-	  string f = f_arg;
+	  std::string f = f_arg;
 
 	  if (f.empty ())
 	    f = xfile;
 
 	  if (f.empty ())
 	    error ("command_history::append: missing file name");
 	}
     }
 }
 
 void
-command_history::do_truncate_file (const string& f_arg, int)
+command_history::do_truncate_file (const std::string& f_arg, int)
 {
-  string f = f_arg;
+  std::string f = f_arg;
 
   if (f.empty ())
     f = xfile;
 
   if (f.empty ())
     error ("command_history::truncate_file: missing file name");
 }
 
 string_vector
 command_history::do_list (int, bool)
 {
   return string_vector ();
 }
 
-string
+std::string
 command_history::do_get_entry (int)
 {
-  return string ();
+  return std::string ();
 }
 
 void
-command_history::do_replace_entry (int, const string&)
+command_history::do_replace_entry (int, const std::string&)
 {
 }
 
 void
-command_history::do_clean_up_and_save (const string& f_arg, int)
+command_history::do_clean_up_and_save (const std::string& f_arg, int)
 {
-  string f = f_arg;
+  std::string f = f_arg;
 
   if (f.empty ())
     f = xfile;
 
   if (f.empty ())
     error ("command_history::clean_up_and_save: missing file name");
 }
 
 void
 command_history::error (int err_num)
 {
   (*current_liboctave_error_handler) ("%s", strerror (err_num));
 }
 
 void
-command_history::error (const string& s)
+command_history::error (const std::string& s)
 {
   (*current_liboctave_error_handler) ("%s", s.c_str ());
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/cmd-hist.h b/liboctave/cmd-hist.h
--- a/liboctave/cmd-hist.h
+++ b/liboctave/cmd-hist.h
@@ -35,29 +35,29 @@ protected:
   command_history (void)
     : ignoring_additions (false), lines_in_file (0),
       lines_this_session (0), xfile (), xsize (-1) { }
 
 public:
 
   virtual ~command_history (void) { }
 
-  static void set_file (const string&);
+  static void set_file (const std::string&);
 
-  static string file (void);
+  static std::string file (void);
 
   static void set_size (int);
 
   static int size (void);
 
   static void ignore_entries (bool = true);
 
   static bool ignoring_entries (void);
 
-  static void add (const string&);
+  static void add (const std::string&);
 
   static void remove (int);
 
   static int where (void);
 
   static int length (void);
 
   static int max_input_history (void);
@@ -76,36 +76,36 @@ public:
 
   // Gag.  This declaration has to match the Function typedef in
   // readline.h.
 
   static int goto_mark (...);
 
   static void read (bool = true);
 
-  static void read (const string&, bool = true);
+  static void read (const std::string&, bool = true);
 
   static void read_range (int = -1, int = -1, bool = true);
 
-  static void read_range (const string&, int = -1, int = -1,
+  static void read_range (const std::string&, int = -1, int = -1,
 			  bool = true);
 
-  static void write (const string& = string ());
+  static void write (const std::string& = std::string ());
 
-  static void append (const string& = string ());
+  static void append (const std::string& = std::string ());
 
-  static void truncate_file (const string& = string (), int = -1);
+  static void truncate_file (const std::string& = std::string (), int = -1);
 
   static string_vector list (int = -1, bool = false);
 
-  static string get_entry (int);
+  static std::string get_entry (int);
 
-  static void replace_entry (int, const string&);
+  static void replace_entry (int, const std::string&);
 
-  static void clean_up_and_save (const string& = string (), int = -1);
+  static void clean_up_and_save (const std::string& = std::string (), int = -1);
 
 private:
 
   // No copying!
 
   command_history (const command_history&);
 
   command_history& operator = (const command_history&);
@@ -118,29 +118,29 @@ private:
   static command_history *instance;
 
 protected:
 
   // To use something other than the GNU history library, derive a new
   // class from command_history, overload these functions as
   // necessary, and make instance point to the new class.
 
-  virtual void do_set_file (const string&);
+  virtual void do_set_file (const std::string&);
 
-  virtual string do_file (void);
+  virtual std::string do_file (void);
 
   virtual void do_set_size (int);
 
   virtual int do_size (void);
 
   virtual void do_ignore_entries (bool);
 
   virtual bool do_ignoring_entries (void);
 
-  virtual void do_add (const string&);
+  virtual void do_add (const std::string&);
 
   virtual void do_remove (int);
 
   virtual int do_where (void);
 
   virtual int do_length (void);
 
   virtual int do_max_input_history (void);
@@ -156,51 +156,51 @@ protected:
   virtual int do_is_stifled (void);
 
   virtual void do_set_mark (int);
 
   virtual void do_goto_mark (void);
 
   virtual void do_read (bool);
 
-  virtual void do_read (const string&, bool);
+  virtual void do_read (const std::string&, bool);
 
   virtual void do_read_range (int, int, bool);
 
-  virtual void do_read_range (const string&, int, int, bool);
+  virtual void do_read_range (const std::string&, int, int, bool);
 
-  virtual void do_write (const string&);
+  virtual void do_write (const std::string&);
 
-  virtual void do_append (const string&);
+  virtual void do_append (const std::string&);
 
-  virtual void do_truncate_file (const string&, int);
+  virtual void do_truncate_file (const std::string&, int);
 
   virtual string_vector do_list (int, bool);
 
-  virtual string do_get_entry (int);
+  virtual std::string do_get_entry (int);
 
-  virtual void do_replace_entry (int, const string&);
+  virtual void do_replace_entry (int, const std::string&);
 
-  virtual void do_clean_up_and_save (const string&, int);
+  virtual void do_clean_up_and_save (const std::string&, int);
 
   void error (int);
 
-  void error (const string&);
+  void error (const std::string&);
 
   // TRUE means we are ignoring new additions.
   bool ignoring_additions;
 
   // The number of hisory lines we read from the history file.
   int lines_in_file;
 
   // The number of history lines we've saved so far.
   int lines_this_session;
 
   // The default history file.
-  string xfile;
+  std::string xfile;
 
   // The number of lines of history to save.
   int xsize;
 };
 
 #endif
 
 /*
diff --git a/liboctave/dColVector.cc b/liboctave/dColVector.cc
--- a/liboctave/dColVector.cc
+++ b/liboctave/dColVector.cc
@@ -326,32 +326,32 @@ ColumnVector::max (void) const
 
   for (int i = 1; i < len; i++)
     if (elem (i) > res)
       res = elem (i);
 
   return res;
 }
 
-ostream&
-operator << (ostream& os, const ColumnVector& a)
+std::ostream&
+operator << (std::ostream& os, const ColumnVector& a)
 {
 //  int field_width = os.precision () + 7;
   for (int i = 0; i < a.length (); i++)
     os << /* setw (field_width) << */ a.elem (i) << "\n";
   return os;
 }
 
-istream&
-operator >> (istream& is, ColumnVector& a)
+std::istream&
+operator >> (std::istream& is, ColumnVector& a)
 {
   int len = a.length();
 
   if (len < 1)
-    is.clear (ios::badbit);
+    is.clear (std::ios::badbit);
   else
     {
       double tmp;
       for (int i = 0; i < len; i++)
         {
           is >> tmp;
           if (is)
             a.elem (i) = tmp;
diff --git a/liboctave/dColVector.h b/liboctave/dColVector.h
--- a/liboctave/dColVector.h
+++ b/liboctave/dColVector.h
@@ -28,19 +28,16 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include "MArray.h"
 
 #include "mx-defs.h"
 
 class ColumnVector : public MArray<double>
 {
-friend class Matrix;
-friend class RowVector;
-
 public:
 
   ColumnVector (void) : MArray<double> () { }
   ColumnVector (int n) : MArray<double> (n) { }
   ColumnVector (int n, double val) : MArray<double> (n, val) { }
   ColumnVector (const MArray<double>& a) : MArray<double> (a) { }
   ColumnVector (const ColumnVector& a) : MArray<double> (a) { }
 
@@ -90,18 +87,18 @@ public:
 
   ColumnVector& apply (d_d_Mapper f);
 
   double min (void) const;
   double max (void) const;
 
   // i/o
 
-  friend ostream& operator << (ostream& os, const ColumnVector& a);
-  friend istream& operator >> (istream& is, ColumnVector& a);
+  friend std::ostream& operator << (std::ostream& os, const ColumnVector& a);
+  friend std::istream& operator >> (std::istream& is, ColumnVector& a);
 
 private:
 
   ColumnVector (double *d, int l) : MArray<double> (d, l) { }
 };
 
 #endif
 
diff --git a/liboctave/dDiagMatrix.cc b/liboctave/dDiagMatrix.cc
--- a/liboctave/dDiagMatrix.cc
+++ b/liboctave/dDiagMatrix.cc
@@ -186,26 +186,26 @@ DiagMatrix::extract (int r1, int c1, int
   return result;
 }
 
 // extract row or column i.
 
 RowVector
 DiagMatrix::row (int i) const
 {
-  int nr = rows ();
-  int nc = cols ();
-  if (i < 0 || i >= nr)
+  int r = rows ();
+  int c = cols ();
+  if (i < 0 || i >= r)
     {
       (*current_liboctave_error_handler) ("invalid row selection");
       return RowVector (); 
     }
 
-  RowVector retval (nc, 0.0);
-  if (nr <= nc || (nr > nc && i < nc))
+  RowVector retval (c, 0.0);
+  if (r <= c || (r > c && i < c))
     retval.elem (i) = elem (i, i);
 
   return retval;
 }
 
 RowVector
 DiagMatrix::row (char *s) const
 {
@@ -225,26 +225,26 @@ DiagMatrix::row (char *s) const
       (*current_liboctave_error_handler) ("invalid row selection");
       return RowVector (); 
     }
 }
 
 ColumnVector
 DiagMatrix::column (int i) const
 {
-  int nr = rows ();
-  int nc = cols ();
-  if (i < 0 || i >= nc)
+  int r = rows ();
+  int c = cols ();
+  if (i < 0 || i >= c)
     {
       (*current_liboctave_error_handler) ("invalid column selection");
       return ColumnVector (); 
     }
 
-  ColumnVector retval (nr, 0.0);
-  if (nr >= nc || (nr < nc && i < nr))
+  ColumnVector retval (r, 0.0);
+  if (r >= c || (r < c && i < r))
     retval.elem (i) = elem (i, i);
 
   return retval;
 }
 
 ColumnVector
 DiagMatrix::column (char *s) const
 {
@@ -271,26 +271,26 @@ DiagMatrix::inverse (void) const
 {
   int info;
   return inverse (info);
 }
 
 DiagMatrix
 DiagMatrix::inverse (int &info) const
 {
-  int nr = rows ();
-  int nc = cols ();
+  int r = rows ();
+  int c = cols ();
   int len = length ();
-  if (nr != nc)
+  if (r != c)
     {
       (*current_liboctave_error_handler) ("inverse requires square matrix");
       return DiagMatrix ();
     }
 
-  DiagMatrix retval (nr, nc);
+  DiagMatrix retval (r, c);
 
   info = 0;
   for (int i = 0; i < len; i++)
     {
       if (elem (i, i) == 0.0)
 	{
 	  info = -1;
 	  return *this;
@@ -302,84 +302,84 @@ DiagMatrix::inverse (int &info) const
   return retval;
 }
 
 // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
 DiagMatrix&
 DiagMatrix::operator += (const DiagMatrix& a)
 {
-  int nr = rows ();
-  int nc = cols ();
+  int r = rows ();
+  int c = cols ();
 
   int a_nr = a.rows ();
   int a_nc = a.cols ();
 
-  if (nr != a_nr || nc != a_nc)
+  if (r != a_nr || c != a_nc)
     {
-      gripe_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
+      gripe_nonconformant ("operator +=", r, c, a_nr, a_nc);
       return *this;
     }
 
-  if (nc == 0 || nr == 0)
+  if (c == 0 || r == 0)
     return *this;
 
   double *d = fortran_vec (); // Ensures only one reference to my privates!
 
   add2 (d, a.data (), length ());
   return *this;
 }
 
 DiagMatrix&
 DiagMatrix::operator -= (const DiagMatrix& a)
 {
-  int nr = rows ();
-  int nc = cols ();
+  int r = rows ();
+  int c = cols ();
 
   int a_nr = a.rows ();
   int a_nc = a.cols ();
 
-  if (nr != a_nr || nc != a_nc)
+  if (r != a_nr || c != a_nc)
     {
-      gripe_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
+      gripe_nonconformant ("operator -=", r, c, a_nr, a_nc);
       return *this;
     }
 
-  if (nr == 0 || nc == 0)
+  if (r == 0 || c == 0)
     return *this;
 
   double *d = fortran_vec (); // Ensures only one reference to my privates!
 
   subtract2 (d, a.data (), length ());
   return *this;
 }
 
 // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
 DiagMatrix
 operator * (const DiagMatrix& a, const DiagMatrix& b)
 {
-  int nr_a = a.rows ();
-  int nc_a = a.cols ();
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
 
-  int nr_b = b.rows ();
-  int nc_b = b.cols ();
+  int b_nr = b.rows ();
+  int b_nc = b.cols ();
 
-  if (nc_a != nr_b)
+  if (a_nc != b_nr)
     {
-      gripe_nonconformant ("operaotr *", nr_a, nc_a, nr_b, nc_b);
+      gripe_nonconformant ("operaotr *", a_nr, a_nc, b_nr, b_nc);
       return DiagMatrix ();
     }
 
-  if (nr_a == 0 || nc_a == 0 || nc_b == 0)
-    return DiagMatrix (nr_a, nc_a, 0.0);
+  if (a_nr == 0 || a_nc == 0 || b_nc == 0)
+    return DiagMatrix (a_nr, a_nc, 0.0);
 
-  DiagMatrix c (nr_a, nc_b);
+  DiagMatrix c (a_nr, b_nc);
 
-  int len = nr_a < nc_b ? nr_a : nc_b;
+  int len = a_nr < b_nc ? a_nr : b_nc;
 
   for (int i = 0; i < len; i++)
     {
       double a_element = a.elem (i, i);
       double b_element = b.elem (i, i);
 
       if (a_element == 0.0 || b_element == 0.0)
         c.elem (i, i) = 0.0;
@@ -434,23 +434,23 @@ DiagMatrix::diag (int k) const
 	}
       else
 	{
 	  for (int i = 0; i < ndiag; i++)
 	    d.elem (i) = elem (i, i);
 	}
     }
   else
-    cerr << "diag: requested diagonal out of range\n";
+    std::cerr << "diag: requested diagonal out of range\n";
 
   return d;
 }
 
-ostream&
-operator << (ostream& os, const DiagMatrix& a)
+std::ostream&
+operator << (std::ostream& os, const DiagMatrix& a)
 {
 //  int field_width = os.precision () + 7;
 
   for (int i = 0; i < a.rows (); i++)
     {
       for (int j = 0; j < a.cols (); j++)
 	{
 	  if (i == j)
diff --git a/liboctave/dDiagMatrix.h b/liboctave/dDiagMatrix.h
--- a/liboctave/dDiagMatrix.h
+++ b/liboctave/dDiagMatrix.h
@@ -85,34 +85,34 @@ public:
   DiagMatrix inverse (void) const;
   DiagMatrix inverse (int& info) const;
 
   // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
   DiagMatrix& operator += (const DiagMatrix& a);
   DiagMatrix& operator -= (const DiagMatrix& a);
 
-  // diagonal matrix by diagonal matrix -> diagonal matrix operations
-
-  friend DiagMatrix operator * (const DiagMatrix& a,
-				const DiagMatrix& b);
-
   // other operations
 
   ColumnVector diag (void) const;
   ColumnVector diag (int k) const;
 
   // i/o
 
-  friend ostream& operator << (ostream& os, const DiagMatrix& a);
+  friend std::ostream& operator << (std::ostream& os, const DiagMatrix& a);
 
 private:
 
   DiagMatrix (double *d, int nr, int nc) : MDiagArray2<double> (d, nr, nc) { }
 };
 
+// diagonal matrix by diagonal matrix -> diagonal matrix operations
+
+DiagMatrix
+operator * (const DiagMatrix& a, const DiagMatrix& b);
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -1457,18 +1457,18 @@ Matrix::expm (void) const
   Matrix npp (nc, nc, 0.0);
   Matrix dpp = npp;
   
   // Now powers a^8 ... a^1.
   
   int minus_one_j = -1;
   for (int j = 7; j >= 0; j--)
     {
-      npp = m * npp + m * padec[j];
-      dpp = m * dpp + m * (minus_one_j * padec[j]);
+      npp = (m * npp) + (m * padec[j]);
+      dpp = (m * dpp) + (m * (minus_one_j * padec[j]));
       minus_one_j *= -1;
     }
   
   // Zero power.
   
   dpp = -dpp;
   for (int j = 0; j < nc; j++)
     {
@@ -2213,17 +2213,17 @@ Matrix::diag (int k) const
 	}
       else
 	{
 	  for (int i = 0; i < ndiag; i++)
 	    d.elem (i) = elem (i, i);
 	}
     }
   else
-    cerr << "diag: requested diagonal out of range\n";
+    std::cerr << "diag: requested diagonal out of range\n";
 
   return d;
 }
 
 ColumnVector
 Matrix::row_min (void) const
 {
   Array<int> index;
@@ -2240,43 +2240,43 @@ Matrix::row_min (Array<int>& index) cons
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
       index.resize (nr);
 
       for (int i = 0; i < nr; i++)
         {
-	  int idx = 0;
-
-	  double tmp_min = elem (i, idx);
+	  int idx_j = 0;
+
+	  double tmp_min = elem (i, idx_j);
 
 	  if (xisnan (tmp_min))
-	    idx = -1;
+	    idx_j = -1;
 	  else
 	    {
 	      for (int j = 1; j < nc; j++)
 		{
 		  double tmp = elem (i, j);
 
 		  if (xisnan (tmp))
 		    {
-		      idx = -1;
+		      idx_j = -1;
 		      break;
 		    }
 		  else if (tmp < tmp_min)
 		    {
-		      idx = j;
+		      idx_j = j;
 		      tmp_min = tmp;
 		    }
 		}
 	    }
 
-	  result.elem (i) = (idx < 0) ? octave_NaN : tmp_min;
-	  index.elem (i) = idx;
+	  result.elem (i) = (idx_j < 0) ? octave_NaN : tmp_min;
+	  index.elem (i) = idx_j;
         }
     }
 
   return result;
 }
 
 ColumnVector
 Matrix::row_max (void) const
@@ -2295,43 +2295,43 @@ Matrix::row_max (Array<int>& index) cons
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nr);
       index.resize (nr);
 
       for (int i = 0; i < nr; i++)
         {
-	  int idx = 0;
-
-	  double tmp_max = elem (i, idx);
+	  int idx_j = 0;
+
+	  double tmp_max = elem (i, idx_j);
 
 	  if (xisnan (tmp_max))
-	    idx = -1;
+	    idx_j = -1;
 	  else
 	    {
 	      for (int j = 1; j < nc; j++)
 		{
 		  double tmp = elem (i, j);
 
 		  if (xisnan (tmp))
 		    {
-		      idx = -1;
+		      idx_j = -1;
 		      break;
 		    }
 		  else if (tmp > tmp_max)
 		    {
-		      idx = j;
+		      idx_j = j;
 		      tmp_max = tmp;
 		    }
 		}
 	    }
 
-	  result.elem (i) = (idx < 0) ? octave_NaN : tmp_max;
-	  index.elem (i) = idx;
+	  result.elem (i) = (idx_j < 0) ? octave_NaN : tmp_max;
+	  index.elem (i) = idx_j;
         }
     }
 
   return result;
 }
 
 RowVector
 Matrix::column_min (void) const
@@ -2350,43 +2350,43 @@ Matrix::column_min (Array<int>& index) c
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
       index.resize (nc);
 
       for (int j = 0; j < nc; j++)
         {
-	  int idx = 0;
-
-	  double tmp_min = elem (idx, j);
+	  int idx_i = 0;
+
+	  double tmp_min = elem (idx_i, j);
 
 	  if (xisnan (tmp_min))
-	    idx = -1;
+	    idx_i = -1;
 	  else
 	    {
 	      for (int i = 1; i < nr; i++)
 		{
 		  double tmp = elem (i, j);
 
 		  if (xisnan (tmp))
 		    {
-		      idx = -1;
+		      idx_i = -1;
 		      break;
 		    }
 		  else if (tmp < tmp_min)
 		    {
-		      idx = i;
+		      idx_i = i;
 		      tmp_min = tmp;
 		    }
 		}
 	    }
 
-	  result.elem (j) = (idx < 0) ? octave_NaN : tmp_min;
-	  index.elem (j) = idx;
+	  result.elem (j) = (idx_i < 0) ? octave_NaN : tmp_min;
+	  index.elem (j) = idx_i;
         }
     }
 
   return result;
 }
 
 RowVector
 Matrix::column_max (void) const
@@ -2405,71 +2405,71 @@ Matrix::column_max (Array<int>& index) c
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
       index.resize (nc);
 
       for (int j = 0; j < nc; j++)
         {
-	  int idx = 0;
-
-	  double tmp_max = elem (idx, j);
+	  int idx_i = 0;
+
+	  double tmp_max = elem (idx_i, j);
 
 	  if (xisnan (tmp_max))
-	    idx = -1;
+	    idx_i = -1;
 	  else
 	    {
 	      for (int i = 1; i < nr; i++)
 		{
 		  double tmp = elem (i, j);
 
 		  if (xisnan (tmp))
 		    {
-		      idx = -1;
+		      idx_i = -1;
 		      break;
 		    }
 		  else if (tmp > tmp_max)
 		    {
-		      idx = i;
+		      idx_i = i;
 		      tmp_max = tmp;
 		    }
 		}
 	    }
 
-	  result.elem (j) = (idx < 0) ? octave_NaN : tmp_max;
-	  index.elem (j) = idx;
+	  result.elem (j) = (idx_i < 0) ? octave_NaN : tmp_max;
+	  index.elem (j) = idx_i;
         }
     }
 
   return result;
 }
 
-ostream&
-operator << (ostream& os, const Matrix& a)
+std::ostream&
+operator << (std::ostream& os, const Matrix& a)
 {
 //  int field_width = os.precision () + 7;
 
   for (int i = 0; i < a.rows (); i++)
     {
       for (int j = 0; j < a.cols (); j++)
 	os << " " /* setw (field_width) */ << a.elem (i, j);
       os << "\n";
     }
   return os;
 }
 
-istream&
-operator >> (istream& is, Matrix& a)
+std::istream&
+operator >> (std::istream& is, Matrix& a)
 {
   int nr = a.rows ();
   int nc = a.cols ();
 
   if (nr < 1 || nc < 1)
-    is.clear (ios::badbit);
+    is.clear (std::ios::badbit);
   else
     {
       double tmp;
       for (int i = 0; i < nr; i++)
 	for (int j = 0; j < nc; j++)
 	  {
 	    is >> tmp;
 	    if (is)
@@ -2480,18 +2480,18 @@ operator >> (istream& is, Matrix& a)
     }
 
  done:
 
   return is;
 }
 
 template <class T>
-static void
-read_int (istream& is, bool swap_bytes, T& val)
+void
+read_int (std::istream& is, bool swap_bytes, T& val)
 {
   is.read (X_CAST (char *, &val), sizeof (T));
 
   if (swap_bytes)
     {
       switch (sizeof (T))
 	{
 	case 1:
@@ -2511,28 +2511,28 @@ read_int (istream& is, bool swap_bytes, 
 
 	default:
 	  (*current_liboctave_error_handler)
 	    ("read_int: unrecognized data format!");
 	}
     }
 }
 
-template void read_int (istream&, bool, char&);
-template void read_int (istream&, bool, signed char&);
-template void read_int (istream&, bool, unsigned char&);
-template void read_int (istream&, bool, short&);
-template void read_int (istream&, bool, unsigned short&);
-template void read_int (istream&, bool, int&);
-template void read_int (istream&, bool, unsigned int&);
-template void read_int (istream&, bool, long&);
-template void read_int (istream&, bool, unsigned long&);
+template void read_int (std::istream&, bool, char&);
+template void read_int (std::istream&, bool, signed char&);
+template void read_int (std::istream&, bool, unsigned char&);
+template void read_int (std::istream&, bool, short&);
+template void read_int (std::istream&, bool, unsigned short&);
+template void read_int (std::istream&, bool, int&);
+template void read_int (std::istream&, bool, unsigned int&);
+template void read_int (std::istream&, bool, long&);
+template void read_int (std::istream&, bool, unsigned long&);
 
 static inline bool
-do_read (istream& is, oct_data_conv::data_type dt, 
+do_read (std::istream& is, oct_data_conv::data_type dt, 
 	 oct_mach_info::float_format flt_fmt, bool swap_bytes,
 	 bool do_float_conversion, double& val)
 {
   bool retval = true;
 
   switch (dt)
     {
     case oct_data_conv::dt_char:
@@ -2635,17 +2635,17 @@ do_read (istream& is, oct_data_conv::dat
 	("read: invalid type specification");
       break;
     }
 
   return retval;
 }
 
 int
-Matrix::read (istream& is, int nr, int nc,
+Matrix::read (std::istream& is, int nr, int nc,
 	      oct_data_conv::data_type dt, int skip,
 	      oct_mach_info::float_format flt_fmt)
 {
   int retval = -1;
 
   bool ok = true;
 
   int count = 0;
@@ -2731,17 +2731,17 @@ Matrix::read (istream& is, int nr, int n
 
 			  data = fortran_vec ();
 			}
 
 		      data[count++] = tmp;
 		    }
 
 		  if (ok && skip != 0)
-		    is.seekg (skip, ios::cur);
+		    is.seekg (skip, std::ios::cur);
 
 		  if (! ok || is.eof ())
 		    {
 		      if (is.eof ())
 			{
 			  if (nr > 0)
 			    {
 			      if (count > nr)
@@ -2787,18 +2787,18 @@ Matrix::read (istream& is, int nr, int n
 
       retval = count;
     }
 
   return retval;
 }
 
 template <class T>
-static void
-write_int (ostream& os, bool swap_bytes, T val)
+void
+write_int (std::ostream& os, bool swap_bytes, T val)
 {
   if (swap_bytes)
     {
       switch (sizeof (T))
 	{
 	case 1:
 	  break;
 
@@ -2818,28 +2818,28 @@ write_int (ostream& os, bool swap_bytes,
 	  (*current_liboctave_error_handler)
 	    ("write_int: unrecognized data format!");
 	}
     }
 
   os.write (X_CAST (char *, &val), sizeof (T));
 }
 
-template void write_int (ostream&, bool, char);
-template void write_int (ostream&, bool, signed char);
-template void write_int (ostream&, bool, unsigned char);
-template void write_int (ostream&, bool, short);
-template void write_int (ostream&, bool, unsigned short);
-template void write_int (ostream&, bool, int);
-template void write_int (ostream&, bool, unsigned int);
-template void write_int (ostream&, bool, long);
-template void write_int (ostream&, bool, unsigned long);
+template void write_int (std::ostream&, bool, char);
+template void write_int (std::ostream&, bool, signed char);
+template void write_int (std::ostream&, bool, unsigned char);
+template void write_int (std::ostream&, bool, short);
+template void write_int (std::ostream&, bool, unsigned short);
+template void write_int (std::ostream&, bool, int);
+template void write_int (std::ostream&, bool, unsigned int);
+template void write_int (std::ostream&, bool, long);
+template void write_int (std::ostream&, bool, unsigned long);
 
 static inline bool
-do_write (ostream& os, double d, oct_data_conv::data_type dt,
+do_write (std::ostream& os, double d, oct_data_conv::data_type dt,
 	  oct_mach_info::float_format flt_fmt, bool swap_bytes,
 	  bool do_float_conversion)
 {
   bool retval = true;
 
   switch (dt)
     {
     case oct_data_conv::dt_char:
@@ -2904,17 +2904,17 @@ do_write (ostream& os, double d, oct_dat
 	("write: invalid type specification");
       break;
     }
 
   return retval;
 }
 
 int
-Matrix::write (ostream& os, oct_data_conv::data_type dt, int skip,
+Matrix::write (std::ostream& os, oct_data_conv::data_type dt, int skip,
 	       oct_mach_info::float_format flt_fmt)
 {
   int retval = -1;
 
   bool ok = true;
 
   int count = 0;
 
@@ -2938,17 +2938,17 @@ Matrix::write (ostream& os, oct_data_con
   else
     swap_bytes = (flt_fmt == oct_mach_info::ieee_big_endian);
 
   for (int i = 0; i < n; i++)
     {
       if (os)
 	{
 	  if (skip != 0)
-	    os.seekp (skip, ios::cur);
+	    os.seekp (skip, std::ios::cur);
 
 	  if (os)
 	    {
 	      ok = do_write (os, d[i], dt, flt_fmt, swap_bytes,
 			     do_float_conversion);
 
 	      if (os && ok)
 		count++;
@@ -3081,21 +3081,21 @@ operator * (const Matrix& m, const Matri
 	      ("unrecoverable error in dgemm");
 	}
     }
 
   return retval;
 }
 
 MS_CMP_OPS(Matrix, , double, )
-MS_BOOL_OPS(Matrix, double)
+MS_BOOL_OPS(Matrix, double, 0.0)
 
 SM_CMP_OPS(double, , Matrix, )
-SM_BOOL_OPS(double, Matrix)
+SM_BOOL_OPS(double, Matrix, 0.0)
 
 MM_CMP_OPS(Matrix, , Matrix, )
-MM_BOOL_OPS(Matrix, Matrix)
+MM_BOOL_OPS(Matrix, Matrix, 0.0)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/dMatrix.h b/liboctave/dMatrix.h
--- a/liboctave/dMatrix.h
+++ b/liboctave/dMatrix.h
@@ -33,27 +33,16 @@ Software Foundation, 59 Temple Place - S
 #include "mx-defs.h"
 #include "mx-op-defs.h"
 
 #include "data-conv.h"
 #include "mach-info.h"
 
 class Matrix : public MArray2<double>
 {
-friend class ComplexMatrix;
-friend class AEPBAL;
-friend class CHOL;
-friend class GEPBAL;
-friend class HESS;
-friend class LU;
-friend class QR;
-friend class QRP;
-friend class SCHUR;
-friend class SVD;
-
 public:
 
   typedef void (*solve_singularity_handler) (double rcond);
 
   Matrix (void) : MArray2<double> () { }
   Matrix (int r, int c) : MArray2<double> (r, c) { }
   Matrix (int r, int c, double val) : MArray2<double> (r, c, val) { }
   Matrix (const MArray2<double>& a) : MArray2<double> (a) { }
@@ -225,23 +214,23 @@ public:
   RowVector column_min (void) const;
   RowVector column_max (void) const;
 
   RowVector column_min (Array<int>& index) const;
   RowVector column_max (Array<int>& index) const;
 
   // i/o
 
-  friend ostream& operator << (ostream& os, const Matrix& a);
-  friend istream& operator >> (istream& is, Matrix& a);
+  friend std::ostream& operator << (std::ostream& os, const Matrix& a);
+  friend std::istream& operator >> (std::istream& is, Matrix& a);
 
-  int read (istream& is, int nr, int nc, oct_data_conv::data_type dt,
+  int read (std::istream& is, int nr, int nc, oct_data_conv::data_type dt,
 	    int skip, oct_mach_info::float_format flt_fmt);
 
-  int write (ostream& os, oct_data_conv::data_type dt, int skip,
+  int write (std::ostream& os, oct_data_conv::data_type dt, int skip,
 	     oct_mach_info::float_format flt_fmt);
 
 private:
 
   Matrix (double *d, int r, int c) : MArray2<double> (d, r, c) { }
 };
 
 extern Matrix Givens (double, double);
diff --git a/liboctave/dRowVector.cc b/liboctave/dRowVector.cc
--- a/liboctave/dRowVector.cc
+++ b/liboctave/dRowVector.cc
@@ -299,33 +299,33 @@ RowVector::max (void) const
 
   for (int i = 1; i < len; i++)
     if (elem (i) > res)
       res = elem (i);
 
   return res;
 }
 
-ostream&
-operator << (ostream& os, const RowVector& a)
+std::ostream&
+operator << (std::ostream& os, const RowVector& a)
 {
 //  int field_width = os.precision () + 7;
 
   for (int i = 0; i < a.length (); i++)
     os << " " /* setw (field_width) */ << a.elem (i);
   return os;
 }
 
-istream&
-operator >> (istream& is, RowVector& a)
+std::istream&
+operator >> (std::istream& is, RowVector& a)
 {
   int len = a.length();
 
   if (len < 1)
-    is.clear (ios::badbit);
+    is.clear (std::ios::badbit);
   else
     {
       double tmp;
       for (int i = 0; i < len; i++)
         {
           is >> tmp;
           if (is)
             a.elem (i) = tmp;
diff --git a/liboctave/dRowVector.h b/liboctave/dRowVector.h
--- a/liboctave/dRowVector.h
+++ b/liboctave/dRowVector.h
@@ -28,18 +28,16 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include "MArray.h"
 
 #include "mx-defs.h"
 
 class RowVector : public MArray<double>
 {
-friend class ColumnVector;
-
 public:
 
   RowVector (void) : MArray<double> () { }
   RowVector (int n) : MArray<double> (n) { }
   RowVector (int n, double val) : MArray<double> (n, val) { }
   RowVector (const MArray<double>& a) : MArray<double> (a) { }
   RowVector (const RowVector& a) : MArray<double> (a) { }
 
@@ -85,18 +83,18 @@ public:
 
   RowVector& apply (d_d_Mapper f);
 
   double min (void) const;
   double max (void) const;
 
   // i/o
 
-  friend ostream& operator << (ostream& os, const RowVector& a);
-  friend istream& operator >> (istream& is, RowVector& a);
+  friend std::ostream& operator << (std::ostream& os, const RowVector& a);
+  friend std::istream& operator >> (std::istream& is, RowVector& a);
 
 private:
 
   RowVector (double *d, int l) : MArray<double> (d, l) { }
 };
 
 // row vector by column vector -> scalar
 
diff --git a/liboctave/data-conv.cc b/liboctave/data-conv.cc
--- a/liboctave/data-conv.cc
+++ b/liboctave/data-conv.cc
@@ -97,17 +97,17 @@ init_sized_type_lookup_table (oct_data_c
 
       FIND_SIZED_FLOAT_TYPE (table[2][i], bits);
 
       bits *= 2;
     }
 }
 
 oct_data_conv::data_type
-oct_data_conv::string_to_data_type (const string& str)
+oct_data_conv::string_to_data_type (const std::string& str)
 {
   data_type retval = dt_unknown;
 
   static bool initialized = false;
 
   static data_type sized_type_table[3][4];
 
   if (! initialized)
@@ -118,17 +118,17 @@ oct_data_conv::string_to_data_type (cons
     }
 
   // XXX FIXME XXX -- finish implementing this.
 
   int n = str.length ();
 
   int k = 0;
 
-  string s (n, ' ');
+  std::string s (n, ' ');
 
   for (int i = 0; i < n; i++)
     if (! isspace (str[i]))
       s[k++] = tolower (str[i]);
 
   s.resize (k);
 
   if (s == "char")
@@ -680,17 +680,17 @@ do_float_format_conversion (float *data,
       (*current_liboctave_error_handler)
 	("impossible state reached in file `%s' at line %d",
 	 __FILE__, __LINE__);
       break;
     }
 }
 
 void
-read_doubles (istream& is, double *data, save_type type, int len,
+read_doubles (std::istream& is, double *data, save_type type, int len,
 	      int swap, oct_mach_info::float_format fmt)
 {
   switch (type)
     {
     case LS_U_CHAR:
       LS_DO_READ (unsigned char, swap, data, 1, len, is);
       break;
 
@@ -727,23 +727,23 @@ read_doubles (istream& is, double *data,
       break;
 
     case LS_DOUBLE: // No conversion necessary.
       is.read (data, 8 * len);
       do_double_format_conversion (data, len, fmt);
       break;
 
     default:
-      is.clear (ios::failbit|is.rdstate ());
+      is.clear (std::ios::failbit|is.rdstate ());
       break;
     }
 }
 
 void
-write_doubles (ostream& os, const double *data, save_type type, int len)
+write_doubles (std::ostream& os, const double *data, save_type type, int len)
 {
   switch (type)
     {
     case LS_U_CHAR:
       LS_DO_WRITE (unsigned char, data, 1, len, os);
       break;
 
     case LS_U_SHORT:
diff --git a/liboctave/data-conv.h b/liboctave/data-conv.h
--- a/liboctave/data-conv.h
+++ b/liboctave/data-conv.h
@@ -67,17 +67,17 @@ public:
       dt_long,
       dt_ulong,
       dt_float,
       dt_double,
       dt_float_complex,
       dt_double_complex
     };
 
-  static data_type string_to_data_type (const string& s);
+  static data_type string_to_data_type (const std::string& s);
 };
 
 enum save_type
   {
     LS_U_CHAR,
     LS_U_SHORT,
     LS_U_INT,
     LS_CHAR,
@@ -91,20 +91,20 @@ extern void
 do_double_format_conversion (double *data, int len,
 			     oct_mach_info::float_format fmt);
 
 extern void
 do_float_format_conversion (float *data, int len,
 			    oct_mach_info::float_format fmt);
 
 extern void
-read_doubles (istream& is, double *data, save_type type, int len,
+read_doubles (std::istream& is, double *data, save_type type, int len,
 	      int swap, oct_mach_info::float_format fmt);
 extern void
-write_doubles (ostream& os, const double *data, save_type type, int len);
+write_doubles (std::ostream& os, const double *data, save_type type, int len);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/dbleAEPBAL.cc b/liboctave/dbleAEPBAL.cc
--- a/liboctave/dbleAEPBAL.cc
+++ b/liboctave/dbleAEPBAL.cc
@@ -41,17 +41,17 @@ extern "C"
 
   int F77_FCN (dgebak, DGEBAK) (const char*, const char*, const int&,
 				const int&, const int&, double*,
 				const int&, double*, const int&,
 				int&, long, long);
 }
 
 int
-AEPBALANCE::init (const Matrix& a, const string& balance_job)
+AEPBALANCE::init (const Matrix& a, const std::string& balance_job)
 {
   int n = a.cols ();
 
   if (a.rows () != n)
     {
       (*current_liboctave_error_handler) ("AEPBALANCE requires square matrix");
       return -1;
     }
diff --git a/liboctave/dbleAEPBAL.h b/liboctave/dbleAEPBAL.h
--- a/liboctave/dbleAEPBAL.h
+++ b/liboctave/dbleAEPBAL.h
@@ -34,17 +34,17 @@ Software Foundation, 59 Temple Place - S
 
 class
 AEPBALANCE
 {
 public:
 
   AEPBALANCE (void) : balanced_mat (), balancing_mat () { }
 
-  AEPBALANCE (const Matrix& a,const string& balance_job)
+  AEPBALANCE (const Matrix& a,const std::string& balance_job)
     {
       init (a, balance_job); 
     }
 
   AEPBALANCE (const AEPBALANCE& a)
     : balanced_mat (a.balanced_mat), balancing_mat (a.balancing_mat) { }
 
   AEPBALANCE& operator = (const AEPBALANCE& a)
@@ -58,24 +58,24 @@ public:
     }
 
   ~AEPBALANCE (void) { }
 
   Matrix balanced_matrix (void) const { return balanced_mat; }
 
   Matrix balancing_matrix (void) const { return balancing_mat; }
 
-  friend ostream& operator << (ostream& os, const AEPBALANCE& a);
+  friend std::ostream& operator << (std::ostream& os, const AEPBALANCE& a);
 
 private:
 
   Matrix balanced_mat;
   Matrix balancing_mat;
 
-  int init (const Matrix& a, const string& balance_job);
+  int init (const Matrix& a, const std::string& balance_job);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/dbleCHOL.h b/liboctave/dbleCHOL.h
--- a/liboctave/dbleCHOL.h
+++ b/liboctave/dbleCHOL.h
@@ -49,17 +49,17 @@ public:
       if (this != &a)
 	chol_mat = a.chol_mat;
 
       return *this;
     }
 
   Matrix chol_matrix (void) const { return chol_mat; }
 
-  friend ostream& operator << (ostream& os, const CHOL& a);
+  friend std::ostream& operator << (std::ostream& os, const CHOL& a);
 
 private:
 
   Matrix chol_mat;
 
   int init (const Matrix& a);
 };
 
diff --git a/liboctave/dbleDET.h b/liboctave/dbleDET.h
--- a/liboctave/dbleDET.h
+++ b/liboctave/dbleDET.h
@@ -58,17 +58,17 @@ public:
   int value_will_underflow (void) const;
 
   double coefficient (void) const;
 
   int exponent (void) const;
 
   double value (void) const;
 
-  friend ostream&  operator << (ostream& os, const DET& a);
+  friend std::ostream&  operator << (std::ostream& os, const DET& a);
 
 private:
 
   DET (const double *d)
     {
       det[0] = d[0];
       det[1] = d[1];
     }
diff --git a/liboctave/dbleHESS.h b/liboctave/dbleHESS.h
--- a/liboctave/dbleHESS.h
+++ b/liboctave/dbleHESS.h
@@ -56,17 +56,17 @@ public:
     }
 
   ~HESS (void) { }
 
   Matrix hess_matrix (void) const { return hess_mat; }
 
   Matrix unitary_hess_matrix (void) const { return unitary_hess_mat; }
 
-  friend ostream& operator << (ostream& os, const HESS& a);
+  friend std::ostream& operator << (std::ostream& os, const HESS& a);
 
 private:
 
   Matrix hess_mat;
   Matrix unitary_hess_mat;
 
   int init (const Matrix& a);
 };
diff --git a/liboctave/dbleQR.h b/liboctave/dbleQR.h
--- a/liboctave/dbleQR.h
+++ b/liboctave/dbleQR.h
@@ -62,17 +62,17 @@ public:
   ~QR (void) { }
 
   void init (const Matrix&, QR::type);
 
   Matrix Q (void) const { return q; }
 
   Matrix R (void) const { return r; }
 
-  friend ostream&  operator << (ostream&, const QR&);
+  friend std::ostream&  operator << (std::ostream&, const QR&);
 
 protected:
 
   Matrix q;
   Matrix r;
 };
 
 #endif
diff --git a/liboctave/dbleQRP.h b/liboctave/dbleQRP.h
--- a/liboctave/dbleQRP.h
+++ b/liboctave/dbleQRP.h
@@ -54,17 +54,17 @@ public:
     }
 
   ~QRP (void) { }
 
   void init (const Matrix&, QR::type = QR::std);
 
   Matrix P (void) const { return p; }
 
-  friend ostream&  operator << (ostream&, const QRP&);
+  friend std::ostream&  operator << (std::ostream&, const QRP&);
 
 protected:
 
   Matrix p;
 };
 
 #endif
 
diff --git a/liboctave/dbleSCHUR.cc b/liboctave/dbleSCHUR.cc
--- a/liboctave/dbleSCHUR.cc
+++ b/liboctave/dbleSCHUR.cc
@@ -53,17 +53,17 @@ select_ana (const double& a, const doubl
 
 static int
 select_dig (const double& a, const double& b)
 {
   return (hypot (a, b) < 1.0);
 }
 
 int
-SCHUR::init (const Matrix& a, const string& ord)
+SCHUR::init (const Matrix& a, const std::string& ord)
 {
   int a_nr = a.rows ();
   int a_nc = a.cols ();
 
   if (a_nr != a_nc)
     {
       (*current_liboctave_error_handler) ("SCHUR requires square matrix");
       return -1;
@@ -124,18 +124,18 @@ SCHUR::init (const Matrix& a, const stri
 			     info, 1L, 1L, 1L));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler) ("unrecoverable error in dgeesx");
 
   return info;
 }
 
-ostream&
-operator << (ostream& os, const SCHUR& a)
+std::ostream&
+operator << (std::ostream& os, const SCHUR& a)
 {
   os << a.schur_matrix () << "\n";
   os << a.unitary_matrix () << "\n";
 
   return os;
 }
 
 /*
diff --git a/liboctave/dbleSCHUR.h b/liboctave/dbleSCHUR.h
--- a/liboctave/dbleSCHUR.h
+++ b/liboctave/dbleSCHUR.h
@@ -35,23 +35,23 @@ Software Foundation, 59 Temple Place - S
 class
 SCHUR
 {
 public:
 
   SCHUR (void)
     : schur_mat (), unitary_mat () { }
 
-  SCHUR (const Matrix& a, const string& ord)
+  SCHUR (const Matrix& a, const std::string& ord)
     : schur_mat (), unitary_mat ()
       {
         init (a, ord);
       }
 
-  SCHUR (const Matrix& a, const string& ord, int& info)
+  SCHUR (const Matrix& a, const std::string& ord, int& info)
     : schur_mat (), unitary_mat ()
       {
         info = init (a, ord);
       }
 
   SCHUR (const SCHUR& a)
     : schur_mat (a.schur_mat), unitary_mat (a.unitary_mat) { }
 
@@ -66,28 +66,28 @@ public:
     }
 
   ~SCHUR (void) { }
 
   Matrix schur_matrix (void) const { return schur_mat; }
 
   Matrix unitary_matrix (void) const { return unitary_mat; }
 
-  friend ostream& operator << (ostream& os, const SCHUR& a);
+  friend std::ostream& operator << (std::ostream& os, const SCHUR& a);
 
   typedef int (*select_function) (const double&, const double&);
 
 private:
 
   Matrix schur_mat;
   Matrix unitary_mat;
 
   select_function selector;
 
-  int init (const Matrix& a, const string& ord);
+  int init (const Matrix& a, const std::string& ord);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/dbleSVD.cc b/liboctave/dbleSVD.cc
--- a/liboctave/dbleSVD.cc
+++ b/liboctave/dbleSVD.cc
@@ -159,18 +159,18 @@ SVD::init (const Matrix& a, SVD::type sv
 	  if (! (jobv == 'N' || jobv == 'O'))
 	    right_sm = right_sm.transpose ();
 	}
     }
 
   return info;
 }
 
-ostream&
-operator << (ostream& os, const SVD& a)
+std::ostream&
+operator << (std::ostream& os, const SVD& a)
 {
   os << a.left_singular_matrix () << "\n";
   os << a.singular_values () << "\n";
   os << a.right_singular_matrix () << "\n";
 
   return os;
 }
 
diff --git a/liboctave/dbleSVD.h b/liboctave/dbleSVD.h
--- a/liboctave/dbleSVD.h
+++ b/liboctave/dbleSVD.h
@@ -71,17 +71,17 @@ public:
   ~SVD (void) { }
 
   DiagMatrix singular_values (void) const { return sigma; }
 
   Matrix left_singular_matrix (void) const;
 
   Matrix right_singular_matrix (void) const;
 
-  friend ostream&  operator << (ostream& os, const SVD& a);
+  friend std::ostream&  operator << (std::ostream& os, const SVD& a);
 
 private:
 
   SVD::type type_computed;
 
   DiagMatrix sigma;
   Matrix left_sm;
   Matrix right_sm;
diff --git a/liboctave/dir-ops.cc b/liboctave/dir-ops.cc
--- a/liboctave/dir-ops.cc
+++ b/liboctave/dir-ops.cc
@@ -31,33 +31,36 @@ Software Foundation, 59 Temple Place - S
 #include "sysdir.h"
 
 #include "dir-ops.h"
 #include "lo-error.h"
 #include "lo-sysdep.h"
 #include "str-vec.h"
 
 bool
-dir_entry::open (const string& n)
+dir_entry::open (const std::string& n)
 {
   fail = true;
 
   if (! n.empty ())
     name = n;
 
   if (! name.empty ())
     {
       close ();
 
       dir = static_cast<void *> (opendir (name.c_str ()));
 
       if (dir)
 	fail = false;
       else
-	errmsg = strerror (errno);
+	{
+	  using namespace std;
+	  errmsg = strerror (errno);
+	}
     }
   else
     errmsg = "dir_entry::open: empty file name";
 
   return ! fail;
 }
 
 string_vector
diff --git a/liboctave/dir-ops.h b/liboctave/dir-ops.h
--- a/liboctave/dir-ops.h
+++ b/liboctave/dir-ops.h
@@ -27,17 +27,17 @@ Software Foundation, 59 Temple Place - S
 
 #include "str-vec.h"
 
 class
 dir_entry
 {
 public:
 
-  dir_entry (const string& n = string ()) : name (n), dir (0)
+  dir_entry (const std::string& n = std::string ()) : name (n), dir (0)
     {
       if (! name.empty ())
         open ();
     }
 
   dir_entry (const dir_entry& d) { copy (d); }
 
   dir_entry& operator = (const dir_entry& d)
@@ -45,43 +45,43 @@ public:
       if (this != &d)
 	copy (d);
 
       return *this;
     }
 
   ~dir_entry (void) { close (); }
 
-  bool open (const string& = string ());
+  bool open (const std::string& = std::string ());
 
   string_vector read (void);
 
   void close (void);
 
   bool ok (void) const { return dir && ! fail; }
 
   operator bool () const { return ok (); }
 
-  string error (void) const { return ok () ? string () : errmsg; }
+  std::string error (void) const { return ok () ? std::string () : errmsg; }
 
 private:
 
   // Name of the directory.
-  string name;
+  std::string name;
 
   // A pointer to the contents of the directory.  We use void here to
   // avoid possible conflicts with the way some systems declare the
   // type DIR.
   void *dir;
 
   // TRUE means the open for this directory failed.
   bool fail;
 
   // If a failure occurs, this contains the system error text.
-  string errmsg;
+  std::string errmsg;
 
   void copy (const dir_entry&);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
diff --git a/liboctave/file-ops.cc b/liboctave/file-ops.cc
--- a/liboctave/file-ops.cc
+++ b/liboctave/file-ops.cc
@@ -46,155 +46,172 @@ Software Foundation, 59 Temple Place - S
 #include "str-vec.h"
 
 #define NOT_SUPPORTED(nm) \
   nm ## ": not supported on this system"
 
 // We provide a replacement for mkdir().
 
 int
-file_ops::mkdir (const string& name, mode_t mode)
+file_ops::mkdir (const std::string& name, mode_t mode)
 {
-  string msg;
+  std::string msg;
   return mkdir (name, mode, msg);
 }
 
 int
-file_ops::mkdir (const string& name, mode_t mode, string& msg)
+file_ops::mkdir (const std::string& name, mode_t mode, std::string& msg)
 {
-  msg = string ();
+  msg = std::string ();
 
   int status = -1;
 
 #if defined (HAVE_MKDIR)
   status = ::mkdir (name.c_str (), mode);
 
   if (status < 0)
-    msg = ::strerror (errno);
+    {
+      using namespace std;
+      msg = ::strerror (errno);
+    }
 #else
   msg = NOT_SUPPORTED ("mkdir");
 #endif
 
   return status;
 }
 
 // I don't know how to emulate this on systems that don't provide it.
 
 int
-file_ops::mkfifo (const string& name, mode_t mode)
+file_ops::mkfifo (const std::string& name, mode_t mode)
 {
-  string msg;
+  std::string msg;
   return mkfifo (name, mode, msg);
 }
 
 int
-file_ops::mkfifo (const string& name, mode_t mode, string& msg)
+file_ops::mkfifo (const std::string& name, mode_t mode, std::string& msg)
 {
-  msg = string ();
+  msg = std::string ();
 
   int status = -1;
 
 #if defined (HAVE_MKFIFO)
   status = ::mkfifo (name.c_str (), mode);
 
   if (status < 0)
-    msg = ::strerror (errno);
+    {
+      using namespace std;
+      msg = ::strerror (errno);
+    }
 #else
   msg = NOT_SUPPORTED ("mkfifo");
 #endif
 
   return status;
 }
 
 // We provide a replacement for rename().
 
 int
-file_ops::rename (const string& from, const string& to)
+file_ops::rename (const std::string& from, const std::string& to)
 {
-  string msg;
+  std::string msg;
   return rename (from, to, msg);
 }
 
 int
-file_ops::rename (const string& from, const string& to, string& msg)
+file_ops::rename (const std::string& from, const std::string& to,
+		  std::string& msg)
 {
   int status = -1;
 
-  msg = string ();
+  msg = std::string ();
 
 #if defined (HAVE_RENAME)
   status = ::rename (from.c_str (), to.c_str ());
 
   if (status < 0)
-    msg = ::strerror (errno);
+    {
+      using namespace std;
+      msg = ::strerror (errno);
+    }
 #else
   msg = NOT_SUPPORTED ("rename");
 #endif
 
   return status;
 }
 
 // We provide a replacement for rmdir().
 
 int
-file_ops::rmdir (const string& name)
+file_ops::rmdir (const std::string& name)
 {
-  string msg;
+  std::string msg;
   return rmdir (name, msg);
 }
 
 int
-file_ops::rmdir (const string& name, string& msg)
+file_ops::rmdir (const std::string& name, std::string& msg)
 {
-  msg = string ();
+  msg = std::string ();
 
   int status = -1;
 
 #if defined (HAVE_RMDIR)
   status = ::rmdir (name.c_str ());
 
   if (status < 0)
-    msg = ::strerror (errno);
+    {
+      using namespace std;
+      msg = ::strerror (errno);
+    }
 #else
   msg = NOT_SUPPORTED ("rmdir");
 #endif
 
   return status;
 }
 
 // We provide a replacement for tempnam().
 
-string
-file_ops::tempnam (const string& dir, const string& pfx)
+std::string
+file_ops::tempnam (const std::string& dir, const std::string& pfx)
 {
-  string msg;
+  std::string msg;
   return tempnam (dir, pfx, msg);
 }
 
-string
-file_ops::tempnam (const string& dir, const string& pfx, string& msg)
+std::string
+file_ops::tempnam (const std::string& dir, const std::string& pfx,
+		   std::string& msg)
 {
-  msg = string ();
+  msg = std::string ();
 
-  string retval;
+  std::string retval;
   
   const char *pdir = dir.empty () ? 0 : dir.c_str ();
 
   const char *ppfx = pfx.empty () ? 0 : pfx.c_str ();
 
   char *tmp = ::tempnam (pdir, ppfx);
 
   if (tmp)
     {
       retval = tmp;
 
       ::free (tmp);
     }
   else
-    msg = ::strerror (errno);
+    {
+      using namespace std;
+      msg = ::strerror (errno);
+    }
 
   return retval;
 }
 
 // The following tilde-expansion code was stolen and adapted from
 // readline.
 
 // XXX FIXME XXX
@@ -235,17 +252,17 @@ string_vector file_ops::tilde_additional
 string_vector file_ops::tilde_additional_suffixes = default_suffixes;
 
 // Find the start of a tilde expansion in S, and return the index
 // of the tilde which starts the expansion.  Place the length of the
 // text which identified this tilde starter in LEN, excluding the
 // tilde itself.
 
 static size_t
-tilde_find_prefix (const string& s, size_t& len)
+tilde_find_prefix (const std::string& s, size_t& len)
 {
   len = 0;
 
   size_t s_len = s.length ();
 
   if (s_len == 0 || s[0] == '~')
     return 0;
 
@@ -270,17 +287,17 @@ tilde_find_prefix (const string& s, size
 
   return s_len;
 }
 
 // Find the end of a tilde expansion in S, and return the index
 // of the character which ends the tilde definition.
 
 static size_t
-tilde_find_suffix (const string& s)
+tilde_find_suffix (const std::string& s)
 {
   size_t s_len = s.length ();
 
   string_vector suffixes = file_ops::tilde_additional_suffixes;
 
   size_t i = 0;
 
   for ( ; i < s_len; i++)
@@ -300,56 +317,56 @@ tilde_find_suffix (const string& s)
 	}
     }
 
   return i;
 }
 
 // Take FNAME and return the tilde prefix we want expanded.
 
-static string
-isolate_tilde_prefix (const string& fname)
+static std::string
+isolate_tilde_prefix (const std::string& fname)
 {
   size_t f_len = fname.length ();
 
   size_t len = 1;
 
   while (len < f_len && fname[len] != DIR_SEP_CHAR)
     len++;
 
   return fname.substr (1, len);
 }
 
 // Do the work of tilde expansion on FILENAME.  FILENAME starts with a
 // tilde.
 
-static string
-tilde_expand_word (const string& filename)
+static std::string
+tilde_expand_word (const std::string& filename)
 {
   size_t f_len = filename.length ();
 
   if (f_len == 0 || filename[0] != '~')
     return filename;
 
   // A leading `~/' or a bare `~' is *always* translated to the value
   // of $HOME or the home directory of the current user, regardless of
   // any preexpansion hook.
 
   if (f_len == 1 || filename[1] == DIR_SEP_CHAR)
     return octave_env::get_home_directory () + filename.substr (1);
 
-  string username = isolate_tilde_prefix (filename);
+  std::string username = isolate_tilde_prefix (filename);
 
   size_t user_len = username.length ();
 
-  string dirname;
+  std::string dirname;
 
   if (file_ops::tilde_expansion_preexpansion_hook)
     {
-      string expansion
+      std::string expansion
 	= file_ops::tilde_expansion_preexpansion_hook (username);
 
       if (! expansion.empty ())
 	return expansion + filename.substr (user_len+1);
     }
 
   // No preexpansion hook, or the preexpansion hook failed.  Look in the
   // password database.
@@ -358,17 +375,17 @@ tilde_expand_word (const string& filenam
 
   if (! pw)
     {
       // If the calling program has a special syntax for expanding tildes,
       // and we couldn't find a standard expansion, then let them try.
 
       if (file_ops::tilde_expansion_failure_hook)
 	{
-	  string expansion
+	  std::string expansion
 	    = file_ops::tilde_expansion_failure_hook (username);
 
 	  if (! expansion.empty ())
 	    dirname = expansion + filename.substr (user_len+1);
 	}
 
       // If we don't have a failure hook, or if the failure hook did not
       // expand the tilde, return a copy of what we were passed.
@@ -380,20 +397,20 @@ tilde_expand_word (const string& filenam
     dirname = pw.dir () + filename.substr (user_len+1);
 
   return dirname;
 }
 
 // If NAME has a leading ~ or ~user, Unix-style, expand it to the
 // user's home directory.  If no ~, or no <pwd.h>, just return NAME.
 
-string
-file_ops::tilde_expand (const string& name)
+std::string
+file_ops::tilde_expand (const std::string& name)
 {
-  string result;
+  std::string result;
 
   size_t name_len = name.length ();
 
   // Scan through S expanding tildes as we come to them.
 
   size_t pos = 0;
 
   while (1)
@@ -420,21 +437,21 @@ file_ops::tilde_expand (const string& na
 
       // If both START and FINI are zero, we are all done.
 
       if (! (start || fini))
 	break;
 
       // Expand the entire tilde word, and copy it into RESULT.
 
-      string tilde_word = name.substr (pos, fini);
+      std::string tilde_word = name.substr (pos, fini);
 
       pos += fini;
 
-      string expansion = tilde_expand_word (tilde_word);
+      std::string expansion = tilde_expand_word (tilde_word);
 
       result.append (expansion);
     }
 
   return result;
 }
 
 // A vector version of the above.
@@ -460,34 +477,37 @@ file_ops::umask (mode_t mode)
 #if defined (HAVE_UMASK)
   return ::umask (mode);
 #else
   return 0;
 #endif
 }
 
 int
-file_ops::unlink (const string& name)
+file_ops::unlink (const std::string& name)
 {
-  string msg;
+  std::string msg;
   return unlink (name, msg);
 }
 
 int
-file_ops::unlink (const string& name, string& msg)
+file_ops::unlink (const std::string& name, std::string& msg)
 {
-  msg = string ();
+  msg = std::string ();
 
   int status = -1;
 
 #if defined (HAVE_UNLINK)
   status = ::unlink (name.c_str ());
 
   if (status < 0)
-    msg = ::strerror (errno);
+    {
+      using namespace std;
+      msg = ::strerror (errno);
+    }
 #else
   msg = NOT_SUPPORTED ("unlink");
 #endif
 
   return status;
 }
 
 /*
diff --git a/liboctave/file-ops.h b/liboctave/file-ops.h
--- a/liboctave/file-ops.h
+++ b/liboctave/file-ops.h
@@ -29,48 +29,48 @@ Software Foundation, 59 Temple Place - S
 #include <sys/types.h>
 #endif
 
 #include "str-vec.h"
 
 struct
 file_ops
 {
-  static int mkdir (const string&, mode_t);
-  static int mkdir (const string&, mode_t, string&);
+  static int mkdir (const std::string&, mode_t);
+  static int mkdir (const std::string&, mode_t, std::string&);
 
-  static int mkfifo (const string&, mode_t);
-  static int mkfifo (const string&, mode_t, string&);
+  static int mkfifo (const std::string&, mode_t);
+  static int mkfifo (const std::string&, mode_t, std::string&);
 
-  static int rename (const string&, const string&);
-  static int rename (const string&, const string&, string&);
+  static int rename (const std::string&, const std::string&);
+  static int rename (const std::string&, const std::string&, std::string&);
 
-  static int rmdir (const string&);
-  static int rmdir (const string&, string&);
+  static int rmdir (const std::string&);
+  static int rmdir (const std::string&, std::string&);
 
-  static string tempnam (const string&, const string&);
-  static string tempnam (const string&, const string&, string&);
+  static std::string tempnam (const std::string&, const std::string&);
+  static std::string tempnam (const std::string&, const std::string&, std::string&);
 
-  typedef string (*tilde_expansion_hook) (const string&);
+  typedef std::string (*tilde_expansion_hook) (const std::string&);
 
   static tilde_expansion_hook tilde_expansion_preexpansion_hook;
 
   static tilde_expansion_hook tilde_expansion_failure_hook;
 
   static string_vector tilde_additional_prefixes;
 
   static string_vector tilde_additional_suffixes;
 
-  static string tilde_expand (const string&);
+  static std::string tilde_expand (const std::string&);
   static string_vector tilde_expand (const string_vector&);
 
   static int umask (mode_t);
 
-  static int unlink (const string&);
-  static int unlink (const string&, string&);
+  static int unlink (const std::string&);
+  static int unlink (const std::string&, std::string&);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/file-stat.cc b/liboctave/file-stat.cc
--- a/liboctave/file-stat.cc
+++ b/liboctave/file-stat.cc
@@ -114,35 +114,35 @@ file_stat::is_sock (void) const
 { 
 #ifdef S_ISSOCK
   return S_ISSOCK (fs_mode);
 #else
   return false;
 #endif
 }
 
-extern "C" void mode_string ();
+extern "C" void mode_string (unsigned short, char *);
 
-string
+std::string
 file_stat::mode_as_string (void) const
 {
   char buf[11];
 
   mode_string (fs_mode, buf);
 
   buf[10] = '\0';
 
-  return string (buf);
+  return std::string (buf);
 }
 
 // Has FILE been modified since TIME?  Returns 1 for yes, 0 for no,
 // and -1 for any error.
 
 int
-file_stat::is_newer (const string& file, const octave_time& time)
+file_stat::is_newer (const std::string& file, const octave_time& time)
 {
   file_stat fs (file);
 
   return fs ? fs.is_newer (time) : -1;
 }
 
 // Private stuff:
 
@@ -157,16 +157,18 @@ file_stat::update_internal (bool force)
       const char *cname = file_name.c_str ();
 
       struct stat buf;
 
       int status = follow_links ? stat (cname, &buf) : lstat (cname, &buf);
 
       if (status < 0)
 	{
+	  using namespace std;
+
 	  fail = true;
 	  errmsg = strerror (errno);
 	}
       else
 	{
 	  fs_mode = buf.st_mode;
 	  fs_ino = buf.st_ino;
 	  fs_dev = buf.st_dev;
diff --git a/liboctave/file-stat.h b/liboctave/file-stat.h
--- a/liboctave/file-stat.h
+++ b/liboctave/file-stat.h
@@ -31,17 +31,17 @@ Software Foundation, 59 Temple Place - S
 #include <sys/types.h>
 #endif
 
 class
 file_stat
 {
 public:
 
-  file_stat (const string& n = string (), bool fl = true)
+  file_stat (const std::string& n = std::string (), bool fl = true)
     : file_name (n), follow_links (fl), initialized (false)
       {
 	if (! file_name.empty ())
 	  update_internal ();
       }
 
   file_stat (const file_stat& f) { copy (f); }
 
@@ -56,17 +56,17 @@ public:
   ~file_stat (void) { }
 
   void get_stats (bool force = false)
     {
       if (! initialized || force)
         update_internal (force);
     }
 
-  void get_stats (const string& n, bool force = false)
+  void get_stats (const std::string& n, bool force = false)
     {
       if (n != file_name || ! initialized  || force)
 	{
 	  initialized = false;
 
 	  file_name = n;
 
 	  update_internal (force);
@@ -105,50 +105,50 @@ public:
 #if defined (HAVE_ST_BLKSIZE)
   long blksize (void) const { return fs_blksize; }
 #endif
 
 #if defined (HAVE_ST_BLOCKS)
   long blocks (void) const { return fs_blocks; }
 #endif
 
-  string mode_as_string (void) const;
+  std::string mode_as_string (void) const;
 
   bool ok (void) const { return initialized && ! fail; }
 
   operator bool () const { return ok (); }
 
   bool exists (void) const { return ok (); }
 
-  string error (void) const { return ok () ? string () : errmsg; }
+  std::string error (void) const { return ok () ? std::string () : errmsg; }
 
   // Has the file referenced by this object been modified since TIME?
   bool is_newer (const octave_time& time) const { return fs_mtime > time; }
 
   // It's nice to be able to hide the file_stat object if we don't
   // really care about it.
-  static int is_newer (const string&, const octave_time&);
+  static int is_newer (const std::string&, const octave_time&);
 
 private:
 
   // Name of the file.
-  string file_name;
+  std::string file_name;
 
   // TRUE means follow symbolic links to the ultimate file (stat).
   // FALSE means get information about the link itself (lstat).
   bool follow_links;
 
   // TRUE means we have already called stat.
   bool initialized;
 
   // TRUE means the stat for this file failed.
   bool fail;
 
   // If a failure occurs, this contains the system error text.
-  string errmsg;
+  std::string errmsg;
 
   // file type and permissions
   mode_t fs_mode;
 
   // serial number
   ino_t fs_ino;
 
   // device number
diff --git a/liboctave/glob-match.cc b/liboctave/glob-match.cc
--- a/liboctave/glob-match.cc
+++ b/liboctave/glob-match.cc
@@ -30,17 +30,17 @@ Software Foundation, 59 Temple Place - S
 #include <iostream>
 #include <string>
 
 #include "file-stat.h"
 #include "glob-match.h"
 #include "str-vec.h"
 
 bool
-glob_match::match (const string& s)
+glob_match::match (const std::string& s)
 {
   int npat = pat.length ();
 
   const char *str = s.c_str ();
 
   int fnmatch_flags = 0;
 
   if (flags & pathname)
@@ -68,17 +68,17 @@ glob_match::match (const string_vector& 
 
   for (int i = 0; i < n; i++)
     retval(i) = match (s[i]);
 
   return retval;
 }
 
 static bool
-single_match_exists (const string& file)
+single_match_exists (const std::string& file)
 {
   file_stat s (file);
 
   return s.exists ();
 }
 
 string_vector
 glob_match::glob (void)
@@ -86,17 +86,17 @@ glob_match::glob (void)
   string_vector retval;
 
   int npat = pat.length ();
 
   int k = 0;
 
   for (int i = 0; i < npat; i++)
     {
-      string xpat = pat(i);
+      std::string xpat = pat(i);
 
       if (! xpat.empty ())
 	{
 	  glob_t glob_info;
 
 	  int err = ::glob (xpat.c_str (), GLOB_NOSORT, 0, &glob_info);
 
 	  if (! err)
@@ -106,17 +106,18 @@ glob_match::glob (void)
 	      const char * const *matches = glob_info.gl_pathv;
 
 	      // XXX FIXME XXX -- we shouldn't have to check to see if
 	      // a single match exists, but it seems that glob() won't
 	      // check for us unless the pattern contains globbing
 	      // characters.  Hmm.
 
 	      if (n > 1
-		  || (n == 1 && single_match_exists (string (matches[0]))))
+		  || (n == 1
+		      && single_match_exists (std::string (matches[0]))))
 		{
 		  retval.resize (k+n);
 
 		  for (int j = 0; j < n; j++)
 		    retval[k++] = matches[j];
 		}
 
 	      globfree (&glob_info);
diff --git a/liboctave/glob-match.h b/liboctave/glob-match.h
--- a/liboctave/glob-match.h
+++ b/liboctave/glob-match.h
@@ -35,17 +35,17 @@ public:
 
   enum opts
     {
       pathname = 1,  // No wildcard can ever match `/'.
       noescape = 2,  // Backslashes don't quote special chars.
       period = 4     // Leading `.' is matched only explicitly.
    };
 
-  glob_match (const string& p = string (),
+  glob_match (const std::string& p = std::string (),
 	      unsigned int f = pathname|noescape|period)
     : pat (p), flags (f) { }
 
   glob_match (const string_vector& p = string_vector (),
 	      unsigned int f = pathname|noescape|period)
     : pat (p), flags (f) { }
 
   glob_match (const glob_match& gm) : pat (gm.pat), flags (gm.flags) { }
@@ -57,21 +57,21 @@ public:
 	  pat = gm.pat;
 	  flags = gm.flags;
 	}
       return *this;
     }
 
   ~glob_match (void) { }
 
-  void set_pattern (const string& p) { pat = p; }
+  void set_pattern (const std::string& p) { pat = p; }
 
   void set_pattern (const string_vector& p) { pat = p; }
 
-  bool match (const string&);
+  bool match (const std::string&);
 
   Array<bool> match (const string_vector&);
 
   string_vector glob (void);
 
 private:
 
   // Globbing pattern(s).
diff --git a/liboctave/idx-vector.cc b/liboctave/idx-vector.cc
--- a/liboctave/idx-vector.cc
+++ b/liboctave/idx-vector.cc
@@ -568,18 +568,18 @@ IDX_VEC_REP::shorten (int n)
 {
   if (n > 0 && n <= len)
     len = n;
   else
     (*current_liboctave_error_handler)
       ("idx_vector::shorten: internal error!");
 }
 
-ostream&
-IDX_VEC_REP::print (ostream& os) const
+std::ostream&
+IDX_VEC_REP::print (std::ostream& os) const
 {
   for (int ii = 0; ii < len; ii++)
     os << data[ii] << "\n";
   return os;
 }
 
 int
 IDX_VEC_REP::freeze (int z_len, const char *tag, int resize_ok)
diff --git a/liboctave/idx-vector.h b/liboctave/idx-vector.h
--- a/liboctave/idx-vector.h
+++ b/liboctave/idx-vector.h
@@ -108,17 +108,17 @@ private:
     // other stuff
 
     void shorten (int n); // Unsafe.  Avoid at all cost.
 
     int freeze (int z_len, const char *tag, int resize_ok);
 
     // i/o
 
-    ostream& print (ostream& os) const;
+    std::ostream& print (std::ostream& os) const;
 
     int *data;
     int len;
     int num_zeros;
     int num_ones;
     int max_val;
     int min_val;
     int orig_nr;
@@ -247,19 +247,19 @@ public:
 // Unsafe.  Avoid at all cost.
   void shorten (int n) { rep->shorten (n); }
 
 // i/o
 
   int freeze (int z_len, const char *tag, int resize_ok = 0)
     { return rep->freeze (z_len, tag, resize_ok); }
 
-  ostream& print (ostream& os) const { return rep->print (os); }
+  std::ostream& print (std::ostream& os) const { return rep->print (os); }
 
-  friend ostream& operator << (ostream& os, const idx_vector& a)
+  friend std::ostream& operator << (std::ostream& os, const idx_vector& a)
     { return a.print (os); }
 
   void maybe_convert_one_zero_to_idx (int z_len)
     { rep->maybe_convert_one_zero_to_idx (z_len); }
 
 private:
 
   idx_vector_rep *rep;
diff --git a/liboctave/lo-sysdep.cc b/liboctave/lo-sysdep.cc
--- a/liboctave/lo-sysdep.cc
+++ b/liboctave/lo-sysdep.cc
@@ -44,20 +44,20 @@ Software Foundation, Inc.
 
 #if ! defined (HAVE_GETHOSTNAME) && defined (HAVE_SYS_UTSNAME_H)
 #include <sys/utsname.h>
 #endif
 
 #include "lo-error.h"
 #include "pathlen.h"
 
-string
+std::string
 octave_getcwd (void)
 {
-  string retval;
+  std::string retval;
 
   char buf[MAXPATHLEN];
 
   char *tmp = 0;
 
 #if defined (__EMX__)
   tmp = _getcwd2 (buf, MAXPATHLEN);
 #elif defined (HAVE_GETCWD)
@@ -70,17 +70,17 @@ octave_getcwd (void)
     retval = tmp;
   else
     (*current_liboctave_error_handler) ("unable to find current directory");
 
   return retval;
 }
 
 int
-octave_chdir (const string& path)
+octave_chdir (const std::string& path)
 {
 #if defined (__EMX__)
   int retval = -1;
 
   char *tmp_path = strsave (path.c_str ());
 
   if (path.length () == 2 && path[1] == ':')
     {
diff --git a/liboctave/lo-sysdep.h b/liboctave/lo-sysdep.h
--- a/liboctave/lo-sysdep.h
+++ b/liboctave/lo-sysdep.h
@@ -22,19 +22,19 @@ Software Foundation, 59 Temple Place - S
 
 #if !defined (octave_liboctave_sysdep_h)
 #define octave_liboctave_sysdep_h 1
 
 #include <string>
 
 #include "lo-ieee.h"
 
-extern string octave_getcwd (void);
+extern std::string octave_getcwd (void);
 
-extern bool octave_chdir (const string&);
+extern bool octave_chdir (const std::string&);
 
 #if ! defined (HAVE_GETHOSTNAME) && defined (HAVE_SYS_UTSNAME_H)
 extern int gethostname (char *, int);
 #endif
 
 #endif
 
 /*
diff --git a/liboctave/lo-utils.cc b/liboctave/lo-utils.cc
--- a/liboctave/lo-utils.cc
+++ b/liboctave/lo-utils.cc
@@ -81,35 +81,35 @@ strsave (const char *s)
 
 // This function was adapted from xputenv from Karl Berry's kpathsearch
 // library.
 
 // XXX FIXME XXX -- make this do the right thing if we don't have a
 // SMART_PUTENV.
 
 void
-octave_putenv (const string& name, const string& value)
+octave_putenv (const std::string& name, const std::string& value)
 {
   int new_len = name.length () + value.length () + 2;
 
   char *new_item = static_cast<char*> (malloc (new_len));
 
   sprintf (new_item, "%s=%s", name.c_str (), value.c_str ());
 
   // As far as I can see there's no way to distinguish between the
   // various errors; putenv doesn't have errno values.
 
   if (putenv (new_item) < 0)
     (*current_liboctave_error_handler) ("putenv (%s) failed", new_item);
 }
 
-string
+std::string
 octave_fgets (FILE *f)
 {
-  string retval;
+  std::string retval;
 
   int grow_size = 1024;
   int max_size = grow_size;
 
   char *buf = static_cast<char *> (malloc (max_size));
   char *bufptr = buf;
   int len = 0;
 
diff --git a/liboctave/lo-utils.h b/liboctave/lo-utils.h
--- a/liboctave/lo-utils.h
+++ b/liboctave/lo-utils.h
@@ -27,19 +27,19 @@ Software Foundation, 59 Temple Place - S
 
 #include <string>
 
 extern int NINT (double x);
 extern double D_NINT (double x);
 
 extern char *strsave (const char *);
 
-extern void octave_putenv (const string&, const string&);
+extern void octave_putenv (const std::string&, const std::string&);
 
-extern string octave_fgets (FILE *);
+extern std::string octave_fgets (std::FILE *);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mach-info.cc b/liboctave/mach-info.cc
--- a/liboctave/mach-info.cc
+++ b/liboctave/mach-info.cc
@@ -181,17 +181,17 @@ oct_mach_info::words_big_endian (void)
 bool
 oct_mach_info::words_little_endian (void)
 {
   return (instance_ok ())
     ? (! instance->big_chief) : false;
 }
 
 oct_mach_info::float_format
-oct_mach_info::string_to_float_format (const string& s)
+oct_mach_info::string_to_float_format (const std::string& s)
 {
   oct_mach_info::float_format retval = oct_mach_info::unknown;
 
   if (s == "native" || s == "n")
     retval = oct_mach_info::native;
   else if (s == "ieee-be" || s == "b")
     retval = oct_mach_info::ieee_big_endian;
   else if (s == "ieee-le" || s == "l")
@@ -206,20 +206,20 @@ oct_mach_info::string_to_float_format (c
     retval = oct_mach_info::unknown;
   else
     (*current_liboctave_error_handler)
       ("invalid architecture type specified");
 
   return retval;
 }
 
-string
+std::string
 oct_mach_info::float_format_as_string (float_format flt_fmt)
 {
-  string retval = "unknown";
+  std::string retval = "unknown";
 
   switch (flt_fmt)
     {
     case native:
       retval = "native";
       break;
 
     case ieee_big_endian:
diff --git a/liboctave/mach-info.h b/liboctave/mach-info.h
--- a/liboctave/mach-info.h
+++ b/liboctave/mach-info.h
@@ -48,19 +48,19 @@ public:
   static bool instance_ok (void);
 
   static float_format native_float_format (void);
 
   static bool words_big_endian (void);
 
   static bool words_little_endian (void);
 
-  static float_format string_to_float_format (const string&);
+  static float_format string_to_float_format (const std::string&);
 
-  static string float_format_as_string (float_format);
+  static std::string float_format_as_string (float_format);
 
 private:
 
   static oct_mach_info *instance;
 
   void init_float_format (void) const;
 
   void ten_little_endians (void) const;
diff --git a/liboctave/mx-cdm-cm.cc b/liboctave/mx-cdm-cm.cc
--- a/liboctave/mx-cdm-cm.cc
+++ b/liboctave/mx-cdm-cm.cc
@@ -24,15 +24,15 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include "mx-cdm-cm.h"
 
 #include "CMatrix.h"
 #include "CDiagMatrix.h"
 
-DMM_BIN_OPS (ComplexMatrix, ComplexDiagMatrix, ComplexMatrix)
+DMM_BIN_OPS (ComplexMatrix, ComplexDiagMatrix, ComplexMatrix, 0.0)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-cdm-m.cc b/liboctave/mx-cdm-m.cc
--- a/liboctave/mx-cdm-m.cc
+++ b/liboctave/mx-cdm-m.cc
@@ -25,15 +25,15 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include "mx-cdm-m.h"
 
 #include "dMatrix.h"
 #include "CMatrix.h"
 #include "CDiagMatrix.h"
 
-DMM_BIN_OPS (ComplexMatrix, ComplexDiagMatrix, Matrix)
+DMM_BIN_OPS (ComplexMatrix, ComplexDiagMatrix, Matrix, 0.0)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-cm-cdm.cc b/liboctave/mx-cm-cdm.cc
--- a/liboctave/mx-cm-cdm.cc
+++ b/liboctave/mx-cm-cdm.cc
@@ -24,15 +24,15 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include "mx-cm-cdm.h"
 
 #include "CMatrix.h"
 #include "CDiagMatrix.h"
 
-MDM_BIN_OPS (ComplexMatrix, ComplexMatrix, ComplexDiagMatrix)
+MDM_BIN_OPS (ComplexMatrix, ComplexMatrix, ComplexDiagMatrix, 0.0)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-cm-dm.cc b/liboctave/mx-cm-dm.cc
--- a/liboctave/mx-cm-dm.cc
+++ b/liboctave/mx-cm-dm.cc
@@ -24,15 +24,15 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include "mx-cm-dm.h"
 
 #include "CMatrix.h"
 #include "dDiagMatrix.h"
 
-MDM_BIN_OPS (ComplexMatrix, ComplexMatrix, DiagMatrix)
+MDM_BIN_OPS (ComplexMatrix, ComplexMatrix, DiagMatrix, 0.0)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-cm-m.cc b/liboctave/mx-cm-m.cc
--- a/liboctave/mx-cm-m.cc
+++ b/liboctave/mx-cm-m.cc
@@ -29,15 +29,15 @@ Software Foundation, 59 Temple Place - S
 #include "boolMatrix.h"
 #include "dMatrix.h"
 #include "CMatrix.h"
 
 MM_BIN_OPS (ComplexMatrix, ComplexMatrix, Matrix)
 
 MM_CMP_OPS (ComplexMatrix, real, Matrix, )
 
-MM_BOOL_OPS (ComplexMatrix, Matrix)
+MM_BOOL_OPS (ComplexMatrix, Matrix, 0.0)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-cm-s.cc b/liboctave/mx-cm-s.cc
--- a/liboctave/mx-cm-s.cc
+++ b/liboctave/mx-cm-s.cc
@@ -28,15 +28,15 @@ Software Foundation, 59 Temple Place - S
 
 #include "boolMatrix.h"
 #include "CMatrix.h"
 
 MS_BIN_OPS (ComplexMatrix, ComplexMatrix, double)
 
 MS_CMP_OPS (ComplexMatrix, real, double, )
 
-MS_BOOL_OPS (ComplexMatrix, double)
+MS_BOOL_OPS (ComplexMatrix, double, 0.0)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-cs-m.cc b/liboctave/mx-cs-m.cc
--- a/liboctave/mx-cs-m.cc
+++ b/liboctave/mx-cs-m.cc
@@ -29,15 +29,15 @@ Software Foundation, 59 Temple Place - S
 #include "boolMatrix.h"
 #include "dMatrix.h"
 #include "CMatrix.h"
 
 SM_BIN_OPS (ComplexMatrix, Complex, Matrix)
 
 SM_CMP_OPS (Complex, real, Matrix, )
 
-SM_BOOL_OPS (Complex, Matrix)
+SM_BOOL_OPS (Complex, Matrix, 0.0)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-dm-cm.cc b/liboctave/mx-dm-cm.cc
--- a/liboctave/mx-dm-cm.cc
+++ b/liboctave/mx-dm-cm.cc
@@ -24,15 +24,15 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include "mx-dm-cm.h"
 
 #include "CMatrix.h"
 #include "dDiagMatrix.h"
 
-DMM_BIN_OPS (ComplexMatrix, DiagMatrix, ComplexMatrix)
+DMM_BIN_OPS (ComplexMatrix, DiagMatrix, ComplexMatrix, 0.0)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-dm-m.cc b/liboctave/mx-dm-m.cc
--- a/liboctave/mx-dm-m.cc
+++ b/liboctave/mx-dm-m.cc
@@ -24,15 +24,15 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include "mx-dm-m.h"
 
 #include "dMatrix.h"
 #include "dDiagMatrix.h"
 
-DMM_BIN_OPS (Matrix, DiagMatrix, Matrix)
+DMM_BIN_OPS (Matrix, DiagMatrix, Matrix, 0.0)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-inlines.cc b/liboctave/mx-inlines.cc
--- a/liboctave/mx-inlines.cc
+++ b/liboctave/mx-inlines.cc
@@ -210,18 +210,18 @@ OP_EQ_FCN (Complex, Complex)
     return r; \
   }
 
 OP_DUP_FCN (, dup, double,  double)
 OP_DUP_FCN (, dup, Complex, Complex)
 
 // These should really return a bool *.  Also, they should probably be
 // in with a collection of other element-by-element boolean ops.
-OP_DUP_FCN (0.0 ==, not, double, double)
-OP_DUP_FCN (0.0 ==, not, double, Complex)
+OP_DUP_FCN (0.0 ==, xnot, double, double)
+OP_DUP_FCN (0.0 ==, xnot, double, Complex)
 
 OP_DUP_FCN (, make_complex, Complex, double)
 
 OP_DUP_FCN (-, change_sign, double,  double)
 OP_DUP_FCN (-, change_sign, Complex, Complex)
 
 OP_DUP_FCN (real, real_dup, double,  Complex)
 OP_DUP_FCN (imag, imag_dup, double,  Complex)
diff --git a/liboctave/mx-m-cdm.cc b/liboctave/mx-m-cdm.cc
--- a/liboctave/mx-m-cdm.cc
+++ b/liboctave/mx-m-cdm.cc
@@ -25,15 +25,15 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include "mx-m-cdm.h"
 
 #include "dMatrix.h"
 #include "CMatrix.h"
 #include "CDiagMatrix.h"
 
-MDM_BIN_OPS (ComplexMatrix, Matrix, ComplexDiagMatrix)
+MDM_BIN_OPS (ComplexMatrix, Matrix, ComplexDiagMatrix, 0.0)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-m-cm.cc b/liboctave/mx-m-cm.cc
--- a/liboctave/mx-m-cm.cc
+++ b/liboctave/mx-m-cm.cc
@@ -29,15 +29,15 @@ Software Foundation, 59 Temple Place - S
 #include "boolMatrix.h"
 #include "dMatrix.h"
 #include "CMatrix.h"
 
 MM_BIN_OPS (ComplexMatrix, Matrix, ComplexMatrix)
 
 MM_CMP_OPS (Matrix, , ComplexMatrix, real)
 
-MM_BOOL_OPS (Matrix, ComplexMatrix)
+MM_BOOL_OPS (Matrix, ComplexMatrix, 0.0)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-m-cs.cc b/liboctave/mx-m-cs.cc
--- a/liboctave/mx-m-cs.cc
+++ b/liboctave/mx-m-cs.cc
@@ -29,15 +29,15 @@ Software Foundation, 59 Temple Place - S
 #include "boolMatrix.h"
 #include "dMatrix.h"
 #include "CMatrix.h"
 
 MS_BIN_OPS (ComplexMatrix, Matrix, Complex)
 
 MS_CMP_OPS (Matrix, , Complex, real)
 
-MS_BOOL_OPS (Matrix, Complex)
+MS_BOOL_OPS (Matrix, Complex, 0.0)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-m-dm.cc b/liboctave/mx-m-dm.cc
--- a/liboctave/mx-m-dm.cc
+++ b/liboctave/mx-m-dm.cc
@@ -24,15 +24,15 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include "mx-m-dm.h"
 
 #include "dMatrix.h"
 #include "dDiagMatrix.h"
 
-MDM_BIN_OPS (Matrix, Matrix, DiagMatrix)
+MDM_BIN_OPS (Matrix, Matrix, DiagMatrix, 0.0)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-op-defs.h b/liboctave/mx-op-defs.h
--- a/liboctave/mx-op-defs.h
+++ b/liboctave/mx-op-defs.h
@@ -201,40 +201,40 @@ class boolMatrix;
   MS_CMP_OP (mx_el_gt, >,  M, CM, S, CS, NBM) \
   MS_CMP_OP (mx_el_eq, ==, M,   , S,   , FBM) \
   MS_CMP_OP (mx_el_ne, !=, M,   , S,   , TBM)
 
 #define MS_BOOL_OP_DECLS(M, S) \
   BOOL_OP_DECL (mx_el_and, M, S); \
   BOOL_OP_DECL (mx_el_or,  M, S); \
 
-#define MS_BOOL_OP(F, OP, M, S) \
+#define MS_BOOL_OP(F, OP, M, S, ZERO) \
   boolMatrix \
   F (const M& m, const S& s) \
   { \
     boolMatrix r; \
  \
     int nr = m.rows (); \
     int nc = m.cols (); \
  \
     if (nr != 0 && nc != 0) \
       { \
         r.resize (nr, nc); \
  \
         for (int j = 0; j < nc; j++) \
           for (int i = 0; i < nr; i++) \
-	    r.elem(i, j) = (m.elem(i, j) != 0) OP (s != 0); \
+	    r.elem(i, j) = (m.elem(i, j) != ZERO) OP (s != ZERO); \
       } \
  \
     return r; \
   }
 
-#define MS_BOOL_OPS(M, S) \
-  MS_BOOL_OP (mx_el_and, &&, M, S) \
-  MS_BOOL_OP (mx_el_or,  ||, M, S)
+#define MS_BOOL_OPS(M, S, ZERO) \
+  MS_BOOL_OP (mx_el_and, &&, M, S, ZERO) \
+  MS_BOOL_OP (mx_el_or,  ||, M, S, ZERO)
 
 #define MS_OP_DECLS(R, M, S) \
   MS_BIN_OP_DECLS (R, M, S) \
   MS_CMP_OP_DECLS (M, S) \
   MS_BOOL_OP_DECLS (M, S) \
 
 // scalar by matrix operations.
 
@@ -303,40 +303,40 @@ class boolMatrix;
   SM_CMP_OP (mx_el_gt, >,  S, CS, M, CM, NBM) \
   SM_CMP_OP (mx_el_eq, ==, S,   , M,   , FBM) \
   SM_CMP_OP (mx_el_ne, !=, S,   , M,   , TBM)
 
 #define SM_BOOL_OP_DECLS(S, M) \
   BOOL_OP_DECL (mx_el_and, S, M); \
   BOOL_OP_DECL (mx_el_or,  S, M); \
 
-#define SM_BOOL_OP(F, OP, S, M) \
+#define SM_BOOL_OP(F, OP, S, M, ZERO) \
   boolMatrix \
   F (const S& s, const M& m) \
   { \
     boolMatrix r; \
  \
     int nr = m.rows (); \
     int nc = m.cols (); \
  \
     if (nr != 0 && nc != 0) \
       { \
         r.resize (nr, nc); \
  \
         for (int j = 0; j < nc; j++) \
           for (int i = 0; i < nr; i++) \
-	    r.elem(i, j) = (s != 0) OP (m.elem(i, j) != 0); \
+	    r.elem(i, j) = (s != ZERO) OP (m.elem(i, j) != ZERO); \
       } \
  \
     return r; \
   }
 
-#define SM_BOOL_OPS(S, M) \
-  SM_BOOL_OP (mx_el_and, &&, S, M) \
-  SM_BOOL_OP (mx_el_or,  ||, S, M)
+#define SM_BOOL_OPS(S, M, ZERO) \
+  SM_BOOL_OP (mx_el_and, &&, S, M, ZERO) \
+  SM_BOOL_OP (mx_el_or,  ||, S, M, ZERO)
 
 #define SM_OP_DECLS(R, S, M) \
   SM_BIN_OP_DECLS (R, S, M) \
   SM_CMP_OP_DECLS (S, M) \
   SM_BOOL_OP_DECLS (S, M) \
 
 // matrix by matrix operations.
 
@@ -428,17 +428,17 @@ class boolMatrix;
   MM_CMP_OP (mx_el_gt, >,  M1, C1, M2, C2, NBM, NBM) \
   MM_CMP_OP (mx_el_eq, ==, M1,   , M2,   , FBM, TBM) \
   MM_CMP_OP (mx_el_ne, !=, M1,   , M2,   , TBM, FBM)
 
 #define MM_BOOL_OP_DECLS(M1, M2) \
   BOOL_OP_DECL (mx_el_and, M1, M2); \
   BOOL_OP_DECL (mx_el_or,  M1, M2);
 
-#define MM_BOOL_OP(F, OP, M1, M2) \
+#define MM_BOOL_OP(F, OP, M1, M2, ZERO) \
   boolMatrix \
   F (const M1& m1, const M2& m2) \
   { \
     boolMatrix r; \
  \
     int m1_nr = m1.rows (); \
     int m1_nc = m1.cols (); \
  \
@@ -448,31 +448,32 @@ class boolMatrix;
     if (m1_nr == m2_nr && m1_nc == m2_nc) \
       { \
 	if (m1_nr != 0 || m1_nc != 0) \
 	  { \
 	    r.resize (m1_nr, m1_nc); \
  \
 	    for (int j = 0; j < m1_nc; j++) \
 	      for (int i = 0; i < m1_nr; i++) \
-		r.elem(i, j) = (m1.elem(i, j) != 0) OP (m2.elem(i, j) != 0); \
+		r.elem(i, j) = (m1.elem(i, j) != ZERO) \
+                                OP (m2.elem(i, j) != ZERO); \
 	  } \
       } \
     else \
       { \
 	if ((m1_nr != 0 || m1_nc != 0) && (m2_nr != 0 || m2_nc != 0)) \
 	  gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
       } \
  \
     return r; \
   }
 
-#define MM_BOOL_OPS(M1, M2) \
-  MM_BOOL_OP (mx_el_and, &&, M1, M2) \
-  MM_BOOL_OP (mx_el_or,  ||, M1, M2)
+#define MM_BOOL_OPS(M1, M2, ZERO) \
+  MM_BOOL_OP (mx_el_and, &&, M1, M2, ZERO) \
+  MM_BOOL_OP (mx_el_or,  ||, M1, M2, ZERO)
 
 #define MM_OP_DECLS(R, M1, M2) \
   MM_BIN_OP_DECLS (R, M1, M2) \
   MM_CMP_OP_DECLS (M1, M2) \
   MM_BOOL_OP_DECLS (M1, M2)
 
 // scalar by diagonal matrix operations.
 
@@ -568,59 +569,59 @@ OP (const M& m, const DM& dm) \
 	  for (int i = 0; i < len; i++) \
 	    r.elem(i, i) OPEQ dm.elem(i, i); \
 	} \
     } \
  \
   return r; \
 }
 
-#define MDM_MULTIPLY_OP(R, M, DM) \
+#define MDM_MULTIPLY_OP(R, M, DM, ZERO) \
 R \
 operator * (const M& m, const DM& dm) \
 { \
   R r; \
  \
   int m_nr = m.rows (); \
   int m_nc = m.cols (); \
  \
   int dm_nr = dm.rows (); \
   int dm_nc = dm.cols (); \
  \
   if (m_nc != dm_nr) \
     gripe_nonconformant ("operator *", m_nr, m_nc, dm_nr, dm_nc); \
   else \
     { \
-      r.resize (m_nr, dm_nc, 0.0); \
+      r.resize (m_nr, dm_nc, ZERO); \
  \
       if (m_nr > 0 && m_nc > 0 && dm_nc > 0) \
 	{ \
 	  for (int j = 0; j < dm.length (); j++) \
 	    { \
 	      if (dm.elem(j, j) == 1.0) \
 		{ \
 		  for (int i = 0; i < m_nr; i++) \
 		    r.elem(i, j) = m.elem(i, j); \
 		} \
-	      else if (dm.elem(j, j) != 0.0) \
+	      else if (dm.elem(j, j) != ZERO) \
 		{ \
 		  for (int i = 0; i < m_nr; i++) \
 		    r.elem(i, j) = dm.elem(j, j) * m.elem(i, j); \
 		} \
 	    } \
 	} \
     } \
  \
   return r; \
 }
 
-#define MDM_BIN_OPS(R, M, DM) \
+#define MDM_BIN_OPS(R, M, DM, ZERO) \
   MDM_BIN_OP (R, operator +, M, DM, +=) \
   MDM_BIN_OP (R, operator -, M, DM, -=) \
-  MDM_MULTIPLY_OP (R, M, DM)
+  MDM_MULTIPLY_OP (R, M, DM, ZERO)
 
 #define MDM_OP_DECLS(R, M, DM) \
   MDM_BIN_OP_DECLS(R, M, DM)
 
 // diagonal matrix by matrix operations.
 
 // XXX FIXME XXX -- DM - M will not give the correct result.
 
@@ -656,59 +657,59 @@ OP (const DM& dm, const M& m) \
 	} \
       else \
 	r.resize (m_nr, m_nc); \
     } \
  \
   return r; \
 }
 
-#define DMM_MULTIPLY_OP(R, DM, M) \
+#define DMM_MULTIPLY_OP(R, DM, M, ZERO) \
 R \
 operator * (const DM& dm, const M& m) \
 { \
   R r; \
  \
   int dm_nr = dm.rows (); \
   int dm_nc = dm.cols (); \
  \
   int m_nr = m.rows (); \
   int m_nc = m.cols (); \
  \
   if (dm_nc != m_nr) \
     gripe_nonconformant ("operator *", dm_nr, dm_nc, m_nr, m_nc); \
   else \
     { \
-      r.resize (dm_nr, m_nc, 0.0); \
+      r.resize (dm_nr, m_nc, ZERO); \
  \
       if (dm_nr > 0 && dm_nc > 0 && m_nc > 0) \
 	{ \
 	  for (int i = 0; i < dm.length (); i++) \
 	    { \
 	      if (dm.elem(i, i) == 1.0) \
 		{ \
 		  for (int j = 0; j < m_nc; j++) \
 		    r.elem(i, j) = m.elem(i, j); \
 		} \
-	      else if (dm.elem(i, i) != 0.0) \
+	      else if (dm.elem(i, i) != ZERO) \
 		{ \
 		  for (int j = 0; j < m_nc; j++) \
 		    r.elem(i, j) = dm.elem(i, i) * m.elem(i, j); \
 		} \
 	    } \
 	} \
     } \
  \
   return r; \
 }
 
-#define DMM_BIN_OPS(R, DM, M) \
+#define DMM_BIN_OPS(R, DM, M, ZERO) \
   DMM_BIN_OP (R, operator +, DM, M, +=) \
   DMM_BIN_OP (R, operator -, DM, M, -=) \
-  DMM_MULTIPLY_OP(R, DM, M)
+  DMM_MULTIPLY_OP(R, DM, M, ZERO)
 
 #define DMM_OP_DECLS(R, DM, M) \
   DMM_BIN_OP_DECLS(R, DM, M)
 
 // diagonal matrix by diagonal matrix operations.
 
 #define DMDM_BIN_OP_DECLS(R, DM1, DM2) \
   BIN_OP_DECL (R, operator +, DM1, DM2); \
diff --git a/liboctave/mx-s-cm.cc b/liboctave/mx-s-cm.cc
--- a/liboctave/mx-s-cm.cc
+++ b/liboctave/mx-s-cm.cc
@@ -28,15 +28,15 @@ Software Foundation, 59 Temple Place - S
 
 #include "boolMatrix.h"
 #include "CMatrix.h"
 
 SM_BIN_OPS (ComplexMatrix, double, ComplexMatrix)
 
 SM_CMP_OPS (double, , ComplexMatrix, real)
 
-SM_BOOL_OPS (double, ComplexMatrix)
+SM_BOOL_OPS (double, ComplexMatrix, 0.0)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/oct-cmplx.h b/liboctave/oct-cmplx.h
--- a/liboctave/oct-cmplx.h
+++ b/liboctave/oct-cmplx.h
@@ -20,17 +20,17 @@ Software Foundation, 59 Temple Place - S
 
 */
 
 #if !defined (octave_oct_cmplx_h)
 #define octave_oct_cmplx_h 1
 
 #include <complex>
 
-typedef complex<double> Complex;
+typedef std::complex<double> Complex;
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/oct-env.cc b/liboctave/oct-env.cc
--- a/liboctave/oct-env.cc
+++ b/liboctave/oct-env.cc
@@ -36,16 +36,17 @@ Free Software Foundation, Inc.
 
 */ 
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cstdlib>
+#include <string>
 
 #ifdef HAVE_UNISTD_H
 #ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
 #include <unistd.h>
 #endif
 
@@ -86,137 +87,137 @@ octave_env::instance_ok (void)
 	("unable to create current working directoy object!");
 
       retval = false;
     }
 
   return retval;
 }
 
-string
-octave_env::polite_directory_format (const string& name)
+std::string
+octave_env::polite_directory_format (const std::string& name)
 {
   return (instance_ok ())
-    ? instance->do_polite_directory_format (name) : string ();
+    ? instance->do_polite_directory_format (name) : std::string ();
 }
 
 bool
-octave_env::absolute_pathname (const string& s)
+octave_env::absolute_pathname (const std::string& s)
 {
   return (instance_ok ())
     ? instance->do_absolute_pathname (s) : false;
 }
 
-string
-octave_env::base_pathname (const string& s)
+std::string
+octave_env::base_pathname (const std::string& s)
 {
   return (instance_ok ())
-    ? instance->do_base_pathname (s) : string ();
+    ? instance->do_base_pathname (s) : std::string ();
 }
 
-string
-octave_env::make_absolute (const string& s, const string& dot_path)
+std::string
+octave_env::make_absolute (const std::string& s, const std::string& dot_path)
 {
   return (instance_ok ())
-    ? instance->do_make_absolute (s, dot_path) : string ();
+    ? instance->do_make_absolute (s, dot_path) : std::string ();
 }
 
-string
+std::string
 octave_env::getcwd ()
 {
   return (instance_ok ())
-    ? instance->do_getcwd () : string ();
+    ? instance->do_getcwd () : std::string ();
 }
 
-string
+std::string
 octave_env::get_home_directory ()
 {
   return (instance_ok ())
-    ? instance->do_get_home_directory () : string ();
+    ? instance->do_get_home_directory () : std::string ();
 }
 
-string
+std::string
 octave_env::get_program_name (void)
 {
   return (instance_ok ())
-    ? instance->program_name : string ();
+    ? instance->program_name : std::string ();
 }
 
-string
+std::string
 octave_env::get_program_invocation_name (void)
 {
   return (instance_ok ())
-    ? instance->program_invocation_name : string ();
+    ? instance->program_invocation_name : std::string ();
 }
 
 void
-octave_env::set_program_name (const string& s)
+octave_env::set_program_name (const std::string& s)
 {
   if (instance_ok ())
     instance->do_set_program_name (s);
 }
 
-string
+std::string
 octave_env::get_user_name (void)
 {
   return (instance_ok ())
-    ? instance->do_get_user_name () : string ();
+    ? instance->do_get_user_name () : std::string ();
 }
 
-string
+std::string
 octave_env::get_host_name (void)
 {
   return (instance_ok ())
-    ? instance->do_get_host_name () : string ();
+    ? instance->do_get_host_name () : std::string ();
 }
 
 // XXX FIXME XXX -- this leaves no way to distinguish between a
 // variable that is not set and one that is set to the empty string.
 // Is this a problem?
 
-string
-octave_env::getenv (const string& name)
+std::string
+octave_env::getenv (const std::string& name)
 {
   return (instance_ok ())
-    ? instance->do_getenv (name) : string ();
+    ? instance->do_getenv (name) : std::string ();
 }
 
 void
-octave_env::putenv (const string& name, const string& value)
+octave_env::putenv (const std::string& name, const std::string& value)
 {
   octave_putenv (name, value);
 }
 
 bool
-octave_env::chdir (const string& newdir)
+octave_env::chdir (const std::string& newdir)
 {
   return (instance_ok ())
     ? instance->do_chdir (newdir) : false;
 }
 
 void
-octave_env::do_set_program_name (const string& s) const
+octave_env::do_set_program_name (const std::string& s) const
 {
   program_invocation_name = s;
 
   size_t pos = program_invocation_name.rfind ('/');
 
   program_name = (pos == NPOS)
     ? program_invocation_name : program_invocation_name.substr (pos+1);
 }
 
 // Return a pretty pathname.  If the first part of the pathname is the
 // same as $HOME, then replace that with `~'.
 
-string
-octave_env::do_polite_directory_format (const string& name) const
+std::string
+octave_env::do_polite_directory_format (const std::string& name) const
 {
-  string retval;
+  std::string retval;
 
-  string home_dir = do_get_home_directory ();
+  std::string home_dir = do_get_home_directory ();
 
   size_t len = home_dir.length ();
 
   if (len > 1 && home_dir.compare (name, 0, len) == 0
       && (name.length () == len || name[len] == '/'))
     {
       retval = "~";
       retval.append (name.substr (len));
@@ -225,17 +226,17 @@ octave_env::do_polite_directory_format (
     retval = name;
 
   return retval;
 }
 
 // Return 1 if STRING contains an absolute pathname, else 0.
 
 bool
-octave_env::do_absolute_pathname (const string& s) const
+octave_env::do_absolute_pathname (const std::string& s) const
 {
   if (s.empty ())
     return 0;
 
   if (s[0] == '/')
     return true;
 
   if (s[0] == '.')
@@ -249,45 +250,46 @@ octave_env::do_absolute_pathname (const 
     }
 
   return false;
 }
 
 // Return the `basename' of the pathname in STRING (the stuff after
 // the last '/').  If STRING is not a full pathname, simply return it.
 
-string
-octave_env::do_base_pathname (const string& s) const
+std::string
+octave_env::do_base_pathname (const std::string& s) const
 {
   if (! do_absolute_pathname (s))
     return s;
 
   size_t pos = s.rfind ('/');
 
   if (pos == NPOS)
     return s;
   else
     return s.substr (pos+1);
 }
 
 // Turn STRING (a pathname) into an absolute pathname, assuming that
 // DOT_PATH contains the symbolic location of '.'.
 
-string
-octave_env::do_make_absolute (const string& s, const string& dot_path) const
+std::string
+octave_env::do_make_absolute (const std::string& s,
+			      const std::string& dot_path) const
 {
 #if defined (__EMX__)
   if (s.length () > 1 && s[1] == ':')
     return s;
 #endif
 
   if (dot_path.empty () || s[0] == '/' || s.empty ())
     return s;
 
-  string current_path = dot_path;
+  std::string current_path = dot_path;
 
   if (current_path.empty ())
     current_path = "./";
 
   size_t pos = current_path.length () - 1;
 
   if (current_path[pos] != '/')
     current_path.append ("/");
@@ -335,63 +337,63 @@ octave_env::do_make_absolute (const stri
 	}
     }
 
   return current_path;
 }
 
 // Return a consed string which is the current working directory.
 
-string
+std::string
 octave_env::do_getcwd ()
 {
   if (! follow_symbolic_links)
     current_directory = "";
 
   if (verbatim_pwd || current_directory.empty ())
     current_directory = ::octave_getcwd ();
 
   return current_directory;
 }
 
 // This value is not cached because it can change while Octave is
 // running.
 
-string
+std::string
 octave_env::do_get_home_directory (void) const
 {
-  string hd = do_getenv ("HOME");
+  std::string hd = do_getenv ("HOME");
 
   if (hd.empty ())
     {
       octave_passwd pw = octave_passwd::getpwuid (octave_syscalls::getuid ());
 
-      hd = pw ? pw.dir () : string ("/");
+      hd = pw ? pw.dir () : std::string ("/");
     }
 
   return hd;
 }
 
-string
+std::string
 octave_env::do_get_user_name (void) const
 {
   // XXX FIXME XXX -- is it possible for this to change while Octave
   // is running?
 
   if (user_name.empty ())
     {
       octave_passwd pw = octave_passwd::getpwuid (octave_syscalls::getuid ());
 
-      user_name = pw ? pw.name () : string ("unknown");
+      user_name = pw ? pw.name () : std::string ("unknown");
     }
 
   return user_name;
 }
 
-string
+std::string
 octave_env::do_get_host_name (void) const
 {
   // XXX FIXME XXX -- is it possible for this to change while Octave
   // is running?
 
   if (host_name.empty ())
     {
       char hostname[256];
@@ -399,33 +401,33 @@ octave_env::do_get_host_name (void) cons
       int status = gethostname (hostname, 255);
 
       host_name = (status < 0) ? "unknown" : hostname;
     }
 
   return host_name;
 }
 
-string
-octave_env::do_getenv (const string& name) const
+std::string
+octave_env::do_getenv (const std::string& name) const
 {
   char *value = ::getenv (name.c_str ());
 
   return value ? value : "";
 }
 
 // Do the work of changing to the directory NEWDIR.  Handle symbolic
 // link following, etc.
 
 bool
-octave_env::do_chdir (const string& newdir)
+octave_env::do_chdir (const std::string& newdir)
 {
   bool retval = false;
 
-  string tmp;
+  std::string tmp;
 
   if (follow_symbolic_links)
     {
       if (current_directory.empty ())
 	do_getcwd ();
 
       if (current_directory.empty ())
 	tmp = newdir;
@@ -452,17 +454,17 @@ octave_env::do_chdir (const string& newd
     retval = (! ::octave_chdir (newdir));
 
   return retval;
 }
 
 // Remove the last N directories from PATH.
 
 void
-octave_env::pathname_backup (string& path, int n) const
+octave_env::pathname_backup (std::string& path, int n) const
 {
   if (path.empty ())
     return;
 
   size_t i = path.length () - 1;
 
   while (n--)
     {
@@ -480,17 +482,17 @@ octave_env::pathname_backup (string& pat
 
 void
 octave_env::error (int err_num) const
 {
   (*current_liboctave_error_handler) ("%s", strerror (err_num));
 }
 
 void
-octave_env::error (const string& s) const
+octave_env::error (const std::string& s) const
 {
   (*current_liboctave_error_handler) ("%s", s.c_str ());
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/oct-env.h b/liboctave/oct-env.h
--- a/liboctave/oct-env.h
+++ b/liboctave/oct-env.h
@@ -29,77 +29,77 @@ class
 octave_env
 {
 protected:
 
   octave_env (void);
 
 public:
 
-  static string polite_directory_format (const string& name);
+  static std::string polite_directory_format (const std::string& name);
 
-  static bool absolute_pathname (const string& s);
+  static bool absolute_pathname (const std::string& s);
 
-  static string base_pathname (const string& s);
+  static std::string base_pathname (const std::string& s);
 
-  static string make_absolute (const string& s, const string& dot_path);
+  static std::string make_absolute (const std::string& s, const std::string& dot_path);
 
-  static string getcwd (void);
+  static std::string getcwd (void);
 
-  static string get_home_directory (void);
+  static std::string get_home_directory (void);
 
-  static string get_program_name (void);
+  static std::string get_program_name (void);
 
-  static string get_program_invocation_name (void);
+  static std::string get_program_invocation_name (void);
 
-  static string get_user_name (void);
+  static std::string get_user_name (void);
 
-  static string get_host_name (void);
+  static std::string get_host_name (void);
 
-  static string getenv (const string& name);
+  static std::string getenv (const std::string& name);
 
-  static void putenv (const string& name, const string& value);
+  static void putenv (const std::string& name, const std::string& value);
 
-  static bool chdir (const string& newdir);
+  static bool chdir (const std::string& newdir);
 
-  static void set_program_name (const string& s);
+  static void set_program_name (const std::string& s);
 
 private:
 
   static bool instance_ok (void);
 
-  string do_polite_directory_format (const string& name) const;
+  std::string do_polite_directory_format (const std::string& name) const;
 
-  bool do_absolute_pathname (const string& s) const;
+  bool do_absolute_pathname (const std::string& s) const;
 
-  string do_base_pathname (const string& s) const;
+  std::string do_base_pathname (const std::string& s) const;
 
-  string do_make_absolute (const string& s, const string& dot_path) const;
+  std::string do_make_absolute (const std::string& s, const std::string& dot_path) const;
 
-  string do_getcwd (void);
+  std::string do_getcwd (void);
 
-  string do_get_home_directory (void) const;
+  std::string do_get_home_directory (void) const;
 
-  string do_get_user_name (void) const;
+  std::string do_get_user_name (void) const;
 
-  string do_get_host_name (void) const;
+  std::string do_get_host_name (void) const;
 
-  string do_getenv (const string& name) const;
+  std::string do_getenv (const std::string& name) const;
 
-  void do_putenv (const string& name, const string& value) const;
+  void do_putenv (const std::string& name, const std::string& value) const;
 
-  bool do_chdir (const string& newdir);
+  bool do_chdir (const std::string& newdir);
 
-  void do_set_program_name (const string& s) const;
+  void do_set_program_name (const std::string& s) const;
 
-  void pathname_backup (string& path, int n) const;
+  void pathname_backup (std::string& path, int n) const;
 
   void error (int) const;
 
-  void error (const string&) const;
+  void error (const std::string&) const;
 
   // No copying!
 
   octave_env (const octave_env&);
 
   octave_env& operator = (const octave_env&);
 
   // The real thing.
@@ -109,26 +109,26 @@ private:
   // as if they are real directories.
   bool follow_symbolic_links;
 
   // TRUE means that pwd always give verbatim directory, regardless
   // of symbolic link following.
   bool verbatim_pwd;
 
   // Where are we?
-  string current_directory;
+  std::string current_directory;
 
   // Etc.
-  mutable string program_name;
+  mutable std::string program_name;
 
-  mutable string program_invocation_name;
+  mutable std::string program_invocation_name;
 
-  mutable string user_name;
+  mutable std::string user_name;
 
-  mutable string host_name;
+  mutable std::string host_name;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/oct-group.cc b/liboctave/oct-group.cc
--- a/liboctave/oct-group.cc
+++ b/liboctave/oct-group.cc
@@ -34,26 +34,26 @@ Software Foundation, 59 Temple Place - S
 
 #include "lo-error.h"
 #include "oct-group.h"
 #include "str-vec.h"
 
 #define NOT_SUPPORTED(nm) \
   nm ## ": not supported on this system"
 
-string
+std::string
 octave_group::name (void) const
 {
   if (! ok ())
     gripe_invalid ();
 
   return gr_name;
 }
 
-string
+std::string
 octave_group::passwd (void) const
 {
   if (! ok ())
     gripe_invalid ();
 
   return gr_passwd;
 }
 
@@ -73,115 +73,115 @@ octave_group::mem (void) const
     gripe_invalid ();
 
   return gr_mem;
 }
 
 octave_group
 octave_group::getgrent (void)
 {
-  string msg;
+  std::string msg;
   return getgrent (msg);
 }
 
 octave_group
-octave_group::getgrent (string& msg)
+octave_group::getgrent (std::string& msg)
 {
 #if defined (HAVE_GETGRENT)
-  msg = string ();
+  msg = std::string ();
   return octave_group (::getgrent (), msg);
 #else
   msg = NOT_SUPPORTED ("getgrent");
   return octave_group ();
 #endif
 }
 
 octave_group
 octave_group::getgrgid (gid_t gid)
 {
-  string msg;
+  std::string msg;
   return getgrgid (gid, msg);
 }
 
 octave_group
-octave_group::getgrgid (gid_t gid, string& msg)
+octave_group::getgrgid (gid_t gid, std::string& msg)
 {
 #if defined (HAVE_GETGRGID)
-  msg = string ();
+  msg = std::string ();
   return octave_group (::getgrgid (gid), msg);
 #else
   msg = NOT_SUPPORTED ("getgruid");
   return octave_group ();
 #endif
 }
 
 octave_group
-octave_group::getgrnam (const string& nm)
+octave_group::getgrnam (const std::string& nm)
 {
-  string msg;
+  std::string msg;
   return getgrnam (msg);
 }
 
 octave_group
-octave_group::getgrnam (const string& nm, string& msg)
+octave_group::getgrnam (const std::string& nm, std::string& msg)
 {
 #if defined (HAVE_GETGRNAM)
-  msg = string ();
+  msg = std::string ();
   return octave_group (::getgrnam (nm.c_str ()), msg);
 #else
   msg = NOT_SUPPORTED ("getgrnam");
   return octave_group ();
 #endif
 }
 
 int
 octave_group::setgrent (void)
 {
-  string msg;
+  std::string msg;
   return setgrent (msg);
 }
 
 int
-octave_group::setgrent (string& msg)
+octave_group::setgrent (std::string& msg)
 {
 #if defined (HAVE_SETGRENT)
-  msg = string ();
+  msg = std::string ();
   ::setgrent ();
   return 0;
 #else
   msg = NOT_SUPPORTED ("setgrent");
   return -1;
 #endif
 }
 
 int
 octave_group::endgrent (void)
 {
-  string msg;
+  std::string msg;
   return endgrent (msg);
 }
 
 int
-octave_group::endgrent (string& msg)
+octave_group::endgrent (std::string& msg)
 {
 #if defined (HAVE_ENDGRENT)
-  msg = string ();
+  msg = std::string ();
   ::endgrent ();
   return 0;
 #else
   msg = NOT_SUPPORTED ("endgrent");
   return -1;
 #endif
 }
 
-octave_group::octave_group (void *p, string& msg)
+octave_group::octave_group (void *p, std::string& msg)
   : gr_name (), gr_passwd (), gr_gid (0), gr_mem (), valid (false)
 {
 #if defined (HAVE_GRP_H)
-  msg = string ();
+  msg = std::string ();
 
   if (p)
     {
       struct group *gr = static_cast<struct group *> (p);
 
       gr_name = gr->gr_name;
 
 #if defined (HAVE_GR_PASSWD)
diff --git a/liboctave/oct-group.h b/liboctave/oct-group.h
--- a/liboctave/oct-group.h
+++ b/liboctave/oct-group.h
@@ -54,63 +54,63 @@ public:
 	gr_gid = gr.gr_gid;
 	gr_mem = gr.gr_mem;
 	valid = gr.valid;
       }
 
     return *this;
   }
 
-  string name (void) const;
+  std::string name (void) const;
 
-  string passwd (void) const;
+  std::string passwd (void) const;
 
   gid_t gid (void) const;
 
   string_vector mem (void) const;
 
   bool ok (void) const { return valid; }
 
   operator bool () const { return ok (); }
 
   static octave_group getgrent (void);
-  static octave_group getgrent (string& msg);
+  static octave_group getgrent (std::string& msg);
 
   static octave_group getgrgid (gid_t gid);
-  static octave_group getgrgid (gid_t gid, string& msg);
+  static octave_group getgrgid (gid_t gid, std::string& msg);
 
-  static octave_group getgrnam (const string& nm);
-  static octave_group getgrnam (const string& nm, string& msg);
+  static octave_group getgrnam (const std::string& nm);
+  static octave_group getgrnam (const std::string& nm, std::string& msg);
 
   static int setgrent (void);
-  static int setgrent (string& msg);
+  static int setgrent (std::string& msg);
 
   static int endgrent (void);
-  static int endgrent (string& msg);
+  static int endgrent (std::string& msg);
 
 private:
 
   // The group name.
-  string gr_name;
+  std::string gr_name;
 
   // The group password.
-  string gr_passwd;
+  std::string gr_passwd;
 
   // The numeric group id.
   gid_t gr_gid;
 
   // The members of the group;
   string_vector gr_mem;
 
   // Flag that says whether we have been properly initialized.
   bool valid;
 
   // This is how we will create an octave_group object from a pointer
   // to a struct group.
-  octave_group (void *p, string& msg);
+  octave_group (void *p, std::string& msg);
 
   void gripe_invalid (void) const;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
diff --git a/liboctave/oct-passwd.cc b/liboctave/oct-passwd.cc
--- a/liboctave/oct-passwd.cc
+++ b/liboctave/oct-passwd.cc
@@ -33,26 +33,26 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include "lo-error.h"
 #include "oct-passwd.h"
 
 #define NOT_SUPPORTED(nm) \
   nm ## ": not supported on this system"
 
-string
+std::string
 octave_passwd::name (void) const
 {
   if (! ok ())
     gripe_invalid ();
 
   return pw_name;
 }
 
-string
+std::string
 octave_passwd::passwd (void) const
 {
   if (! ok ())
     gripe_invalid ();
 
   return pw_passwd;
 }
 
@@ -69,146 +69,146 @@ gid_t
 octave_passwd::gid (void) const
 {
   if (! ok ())
     gripe_invalid ();
 
   return pw_gid;
 }
 
-string
+std::string
 octave_passwd::gecos (void) const
 {
   if (! ok ())
     gripe_invalid ();
 
   return pw_gecos;
 }
 
-string
+std::string
 octave_passwd::dir (void) const
 {
   if (! ok ())
     gripe_invalid ();
 
   return pw_dir;
 }
 
-string
+std::string
 octave_passwd::shell (void) const
 {
   if (! ok ())
     gripe_invalid ();
 
   return pw_shell;
 }
 
 octave_passwd
 octave_passwd::getpwent (void)
 {
-  string msg;
+  std::string msg;
   return getpwent (msg);
 }
 
 octave_passwd
-octave_passwd::getpwent (string& msg)
+octave_passwd::getpwent (std::string& msg)
 {
 #if defined HAVE_GETPWENT
-  msg = string ();
+  msg = std::string ();
   return octave_passwd (::getpwent (), msg);
 #else
   msg = NOT_SUPPORTED ("getpwent");
   return octave_passwd ();
 #endif
 }
 
 octave_passwd
 octave_passwd::getpwuid (uid_t uid)
 {
-  string msg;
+  std::string msg;
   return getpwuid (uid, msg);
 }
 
 octave_passwd
-octave_passwd::getpwuid (uid_t uid, string& msg)
+octave_passwd::getpwuid (uid_t uid, std::string& msg)
 {
 #if defined (HAVE_GETPWUID)
-  msg = string ();
+  msg = std::string ();
   return octave_passwd (::getpwuid (uid), msg);
 #else
   msg = NOT_SUPPORTED ("getpwuid");
   return octave_passwd ();
 #endif
 }
 
 octave_passwd
-octave_passwd::getpwnam (const string& nm)
+octave_passwd::getpwnam (const std::string& nm)
 {
-  string msg;
+  std::string msg;
   return getpwnam (nm, msg);
 }
 
 octave_passwd
-octave_passwd::getpwnam (const string& nm, string& msg)
+octave_passwd::getpwnam (const std::string& nm, std::string& msg)
 {
 #if defined (HAVE_GETPWNAM)
-  msg = string ();
+  msg = std::string ();
   return octave_passwd (::getpwnam (nm.c_str ()), msg);
 #else
   msg = NOT_SUPPORTED ("getpwnam");
   return octave_passwd ();
 #endif
 }
 
 int
 octave_passwd::setpwent (void)
 {
-  string msg;
+  std::string msg;
   return setpwent (msg);
 }
 
 int
-octave_passwd::setpwent (string& msg)
+octave_passwd::setpwent (std::string& msg)
 {
 #if defined (HAVE_SETPWENT)
-  msg = string ();
+  msg = std::string ();
   ::setpwent ();
   return 0;
 #else
   msg = NOT_SUPPORTED ("setpwent");
   return -1;
 #endif
 }
 
 int
 octave_passwd::endpwent (void)
 {
-  string msg;
+  std::string msg;
   return endpwent (msg);
 }
 
 int
-octave_passwd::endpwent (string& msg)
+octave_passwd::endpwent (std::string& msg)
 {
 #if defined (HAVE_ENDPWENT)
-  msg = string ();
+  msg = std::string ();
   ::endpwent ();
   return 0;
 #else
   msg = NOT_SUPPORTED ("endpwent");
   return -1;
 #endif
 }
 
-octave_passwd::octave_passwd (void *p, string& msg)
+octave_passwd::octave_passwd (void *p, std::string& msg)
   : pw_name (), pw_passwd (), pw_uid (0), pw_gid (0), pw_gecos (),
     pw_dir (), pw_shell (), valid (false)
 {
 #if defined (HAVE_PWD_H)
-  msg = string ();
+  msg = std::string ();
 
   if (p)
     {
       struct passwd *pw = static_cast<struct passwd *> (p);
 
       pw_name = pw->pw_name;
       pw_passwd = pw->pw_passwd;
       pw_uid = pw->pw_uid;
diff --git a/liboctave/oct-passwd.h b/liboctave/oct-passwd.h
--- a/liboctave/oct-passwd.h
+++ b/liboctave/oct-passwd.h
@@ -59,78 +59,78 @@ public:
 	valid = pw.valid;
       }
 
     return *this;
   }
 
   ~octave_passwd (void) { }
 
-  string name (void) const;
+  std::string name (void) const;
 
-  string passwd (void) const;
+  std::string passwd (void) const;
 
   uid_t uid (void) const;
 
   gid_t gid (void) const;
 
-  string gecos (void) const;
+  std::string gecos (void) const;
 
-  string dir (void) const;
+  std::string dir (void) const;
 
-  string shell (void) const;
+  std::string shell (void) const;
 
   bool ok (void) const { return valid; }
 
   operator bool () const { return ok (); }
 
   static octave_passwd getpwent (void);
-  static octave_passwd getpwent (string& msg);
+  static octave_passwd getpwent (std::string& msg);
 
   static octave_passwd getpwuid (uid_t uid);
-  static octave_passwd getpwuid (uid_t uid, string& msg);
+  static octave_passwd getpwuid (uid_t uid, std::string& msg);
 
-  static octave_passwd getpwnam (const string& nm);
-  static octave_passwd getpwnam (const string& nm, string& msg);
+  static octave_passwd getpwnam (const std::string& nm);
+  static octave_passwd getpwnam (const std::string& nm, std::string& msg);
 
   static int setpwent (void);
-  static int setpwent (string& msg);
+  static int setpwent (std::string& msg);
 
   static int endpwent (void);
-  static int endpwent (string& msg);
+  static int endpwent (std::string& msg);
 
 private:
 
   // User name.
-  string pw_name;
+  std::string pw_name;
 
   // Encrypted password.
-  string pw_passwd;
+  std::string pw_passwd;
 
   // Numeric user id.
   uid_t pw_uid;
 
   // Numeric group id.
   gid_t pw_gid;
 
   // Miscellaneous junk.
-  string pw_gecos;
+  std::string pw_gecos;
 
   // Home directory.
-  string pw_dir;
+  std::string pw_dir;
 
   // Login shell.
-  string pw_shell;
+  std::string pw_shell;
 
   // Flag that says whether we have been properly initialized.
   bool valid;
 
   // This is how we will create an octave_passwd object from a pointer
   // to a struct passwd.
-  octave_passwd (void *p, string& msg);
+  octave_passwd (void *p, std::string& msg);
 
   void gripe_invalid (void) const;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
diff --git a/liboctave/oct-shlib.cc b/liboctave/oct-shlib.cc
--- a/liboctave/oct-shlib.cc
+++ b/liboctave/oct-shlib.cc
@@ -60,66 +60,66 @@ octave_base_shlib : public octave_shlib
 {
 public:
 
   octave_base_shlib (void)
     : octave_shlib (octave_xshlib ()), file (), fcn_names (),
       tm_loaded (static_cast<time_t> (0))
   { count = 1; }
 
-  octave_base_shlib (const string& f)
+  octave_base_shlib (const std::string& f)
     : octave_shlib (octave_xshlib ()), file (f), fcn_names (),
       tm_loaded (static_cast<time_t> (0))
   { count = 1; }
 
   ~octave_base_shlib (void) { }
 
-  void open (const string&, bool = false) { }
+  void open (const std::string&, bool = false) { }
 
-  void *search (const string&, name_mangler = 0) { return 0; }
+  void *search (const std::string&, name_mangler = 0) { return 0; }
 
   void close (octave_shlib::close_hook = 0) { }
 
-  bool remove (const string& fcn_name);
+  bool remove (const std::string& fcn_name);
 
   bool is_open (void) const { return false; }
 
   bool is_out_of_date (void) const;
 
   int number_of_functions_loaded (void) const { return fcn_names.length (); }
 
-  string file_name (void) const { return file; }
+  std::string file_name (void) const { return file; }
 
   octave_time time_loaded (void) const { return tm_loaded; }
 
 protected:
 
-  string file;
+  std::string file;
 
   string_vector fcn_names;
 
   octave_time tm_loaded;
 
   void stamp_time (bool warn_future = false);
 
-  void add_to_fcn_names (const string& name);
+  void add_to_fcn_names (const std::string& name);
 
   void do_close_hook (octave_shlib::close_hook = 0);
 
   void tabula_rasa (void);
 
   // No copying!
 
   octave_base_shlib (const octave_base_shlib&);
 
   octave_base_shlib& operator = (const octave_base_shlib&);
 };
 
 bool
-octave_base_shlib::remove (const string& fcn_name)
+octave_base_shlib::remove (const std::string& fcn_name)
 {
   bool retval = false;
 
   int n = number_of_functions_loaded ();
 
   string_vector new_fcn_names (n);
 
   int k = 0;
@@ -158,17 +158,17 @@ octave_base_shlib::stamp_time (bool warn
 
       if (fs.is_newer (tm_loaded))
 	(*current_liboctave_warning_handler)
 	  ("timestamp on file %s is in the future", file.c_str ());
     }
 }
 
 void
-octave_base_shlib::add_to_fcn_names (const string& name)
+octave_base_shlib::add_to_fcn_names (const std::string& name)
 {
   int n = number_of_functions_loaded ();
 
   for (int i = 0; i < n; i++)
     if (fcn_names(i) == name)
       return;
 
   fcn_names.resize (n+1);
@@ -201,19 +201,19 @@ class
 octave_dlopen_shlib : public octave_base_shlib
 {
 public:
 
   octave_dlopen_shlib (void);
 
   ~octave_dlopen_shlib (void);
 
-  void open (const string& f, bool warn_future = false);
+  void open (const std::string& f, bool warn_future = false);
 
-  void *search (const string& name, name_mangler mangler = 0);
+  void *search (const std::string& name, name_mangler mangler = 0);
 
   void close (octave_shlib::close_hook cl_hook = 0);
 
   bool is_open (void) const { return (library != 0); }
 
 private:
 
   // No copying!
@@ -231,17 +231,17 @@ octave_dlopen_shlib::octave_dlopen_shlib
 }
 
 octave_dlopen_shlib::~octave_dlopen_shlib (void)
 {
   close ();
 }
 
 void
-octave_dlopen_shlib::open (const string& f, bool warn_future)
+octave_dlopen_shlib::open (const std::string& f, bool warn_future)
 {
   if (! is_open ())
     {
       file = f;
 
       library = dlopen (file.c_str (), RTLD_LAZY);
 
       if (library)
@@ -255,24 +255,24 @@ octave_dlopen_shlib::open (const string&
 	}
     }
   else
     (*current_liboctave_error_handler)
       ("shared library %s is already open", file.c_str ());
 }
 
 void *
-octave_dlopen_shlib::search (const string& name,
+octave_dlopen_shlib::search (const std::string& name,
 			     octave_shlib::name_mangler mangler)
 {
   void *function = 0;
 
   if (is_open ())
     {
-      string sym_name = name;
+      std::string sym_name = name;
 
       if (mangler)
 	sym_name = mangler (name);
 
       function = dlsym (library, sym_name.c_str ());
 
       if (function)
 	add_to_fcn_names (name);
@@ -305,19 +305,19 @@ class
 octave_shl_load_shlib : public octave_base_shlib
 {
 public:
 
   octave_shl_load_shlib (void);
 
   ~octave_shl_load_shlib (void);
 
-  void open (const string& f, bool warn_future = false);
+  void open (const std::string& f, bool warn_future = false);
 
-  void *search (const string& name, name_mangler mangler = 0);
+  void *search (const std::string& name, name_mangler mangler = 0);
 
   void close (octave_shlib::close_hook cl_hook = 0);
 
   bool is_open (void) const { return { library != 0); }
 
 private:
 
   // No copying!
@@ -335,43 +335,46 @@ octave_shl_load_shlib::octave_shl_load_s
 }
 
 octave_shl_load_shlib::~octave_shl_load_shlib (void)
 {
   close ();
 }
 
 void
-octave_shl_load_shlib::open (const string& f, bool warn_future)
+octave_shl_load_shlib::open (const std::string& f, bool warn_future)
 {
   if (! is_open ())
     {
       file = f;
 
       library = shl_load (file.c_str (), BIND_DEFERRED, 0L);
 
       if (library)
 	stamp_time (warn_future);
       else
-	(*current_liboctave_error_handler) ("%s", strerror (errno));
+	{
+	  using namespace std;
+	  (*current_liboctave_error_handler) ("%s", strerror (errno));
+	}
     }
   else
     (*current_liboctave_error_handler)
       ("shared library %s is already open", file.c_str ());
 }
 
 void *
-octave_shl_load_shlib::search (const string& name,
+octave_shl_load_shlib::search (const std::string& name,
 			       octave_shlib::name_mangler mangler)
 {
   void *function = 0;
 
   if (is_open ())
     {
-      string sym_name = name;
+      std::string s ym_name = name;
 
       if (mangler)
 	sym_name = mangler (name);
 	
       int status = shl_findsym (&library, sym_name.c_str (),
 				TYPE_UNDEFINED, &function);
 
       if (status == 0)
diff --git a/liboctave/oct-shlib.h b/liboctave/oct-shlib.h
--- a/liboctave/oct-shlib.h
+++ b/liboctave/oct-shlib.h
@@ -38,23 +38,23 @@ public:
   octave_xshlib (void) { }
 };
 
 class
 octave_shlib
 {
 public:
 
-  typedef string (*name_mangler) (const string&);
+  typedef std::string (*name_mangler) (const std::string&);
 
-  typedef void (*close_hook) (const string&);
+  typedef void (*close_hook) (const std::string&);
 
   octave_shlib (void) : rep (make_shlib ()) { }
 
-  octave_shlib::octave_shlib (const string& f, bool warn_future)
+  octave_shlib::octave_shlib (const std::string& f, bool warn_future)
     : rep (make_shlib ())
   {
     open (f, warn_future);
   }
 
   virtual ~octave_shlib (void)
     {
       if (rep && --rep->count == 0)
@@ -84,35 +84,35 @@ public:
       return *this;
     }
 
   bool operator == (const octave_shlib& sl) const
     { return (rep == sl.rep); }
 
   operator bool () const { return is_open (); }
 
-  virtual void open (const string& f, bool warn_future = false)
+  virtual void open (const std::string& f, bool warn_future = false)
     { rep->open (f, warn_future); }
   
-  virtual void *search (const string& nm, name_mangler mangler = 0)
+  virtual void *search (const std::string& nm, name_mangler mangler = 0)
     { return rep->search (nm, mangler); }
 
   virtual void close (close_hook cl_hook = 0)
     { rep->close (cl_hook); }
 
-  virtual bool remove (const string& fcn_name)
+  virtual bool remove (const std::string& fcn_name)
     { return rep->remove (fcn_name); }
 
   virtual bool is_out_of_date (void) const
     { return rep->is_out_of_date (); }
 
   virtual int number_of_functions_loaded (void) const
     { return rep->number_of_functions_loaded (); }
 
-  virtual string file_name (void) const
+  virtual std::string file_name (void) const
     { return rep->file_name (); }
 
   virtual octave_time time_loaded (void) const
     { return rep->time_loaded (); }
 
 protected:
 
   octave_shlib (const octave_xshlib&) : rep (0) { }
diff --git a/liboctave/oct-syscalls.cc b/liboctave/oct-syscalls.cc
--- a/liboctave/oct-syscalls.cc
+++ b/liboctave/oct-syscalls.cc
@@ -45,144 +45,162 @@ Software Foundation, 59 Temple Place - S
 #include "syswait.h"
 
 #define NOT_SUPPORTED(nm) \
   nm ## ": not supported on this system"
 
 int
 octave_syscalls::dup2 (int old_fd, int new_fd)
 {
-  string msg;
+  std::string msg;
   return dup2 (old_fd, new_fd, msg);
 }
 
 int
-octave_syscalls::dup2 (int old_fd, int new_fd, string& msg)
+octave_syscalls::dup2 (int old_fd, int new_fd, std::string& msg)
 {
-  msg = string ();
+  msg = std::string ();
 
   int status = -1;
 
 #if defined (HAVE_DUP2)
   status = ::dup2 (old_fd, new_fd);
 
   if (status < 0)
-    msg = ::strerror (errno);
+    {
+      using namespace std;
+      msg = ::strerror (errno);
+    }
 #else
   msg = NOT_SUPPORTED ("dup2");
 #endif
 
   return status;
 }
 
 int
-octave_syscalls::execvp (const string& file, const string_vector& argv)
+octave_syscalls::execvp (const std::string& file, const string_vector& argv)
 {
-  string msg;
+  std::string msg;
   return execvp (file, argv, msg);
 }
 
 int
-octave_syscalls::execvp (const string& file, const string_vector& args,
-			 string& msg)
+octave_syscalls::execvp (const std::string& file, const string_vector& args,
+			 std::string& msg)
 {
-  msg = string ();
+  msg = std::string ();
 
   int status = -1;
 
 #if defined (HAVE_EXECVP)
   char **argv = args.c_str_vec ();
 
   status = ::execvp (file.c_str (), argv);
 
   string_vector::delete_c_str_vec (argv);
 
   if (status < 0)
-    msg = ::strerror (errno);
+    {
+      using namespace std;
+      msg = ::strerror (errno);
+    }
 #else
   msg = NOT_SUPPORTED ("execvp");
 #endif
 
   return status;
 }
 
 int
 octave_syscalls::fcntl (int fd, int cmd, long arg)
 {
-  string msg;
+  std::string msg;
   return fcntl (fd, cmd, arg, msg);
 }
 
 int
-octave_syscalls::fcntl (int fd, int cmd, long arg, string& msg)
+octave_syscalls::fcntl (int fd, int cmd, long arg, std::string& msg)
 {
-  msg = string ();
+  msg = std::string ();
 
   int status = -1;
 
 #if defined (HAVE_FCNTL)
   status = ::fcntl (fd, cmd, arg);
 
   if (status < 0)
-    msg = ::strerror (errno);
+    {
+      using namespace std;
+      msg = ::strerror (errno);
+    }
 #else
   msg = NOT_SUPPORTED ("fcntl");
 #endif
 
   return status;
 }
 
 pid_t
-octave_syscalls::fork (string& msg)
+octave_syscalls::fork (std::string& msg)
 {
   pid_t status = -1;
 
 #if defined (HAVE_FORK)
   status = ::fork ();
 
   if (status < 0)
-    msg = ::strerror (errno);
+    {
+      using namespace std;
+      msg = ::strerror (errno);
+    }
 #else
   msg = NOT_SUPPORTED ("fork");
 #endif
 
   return status;
 }
 
 pid_t
-octave_syscalls::vfork (string& msg)
+octave_syscalls::vfork (std::string& msg)
 {
   pid_t status = -1;
 
 #if defined (HAVE_VFORK) || defined (HAVE_FORK)
 #if defined (HAVE_VFORK)
   status = ::vfork ();
 #else
   status = ::fork ();
 #endif
 
   if (status < 0)
-    msg = ::strerror (errno);
+    {
+      using namespace std;
+      msg = ::strerror (errno);
+    }
 #else
   msg = NOT_SUPPORTED ("vfork");
 #endif
 
   return status;
 }
 
 pid_t
-octave_syscalls::getpgrp (string& msg)
+octave_syscalls::getpgrp (std::string& msg)
 {
   pid_t status = -1;
 
 #if defined (HAVE_GETPGRP)
   status = ::getpgrp ();
 
   if (status < 0)
-    msg = ::strerror (errno);
+    {
+      using namespace std;
+      msg = ::strerror (errno);
+    }
 #else
   msg = NOT_SUPPORTED ("getpgrp");
 #endif
 
   return status;
 }
 
 pid_t
@@ -243,58 +261,64 @@ octave_syscalls::geteuid (void)
 #else
   return 0;
 #endif
 }
 
 int
 octave_syscalls::pipe (int *fildes)
 {
-  string msg;
+  std::string msg;
   return pipe (fildes);
 }
 
 int
-octave_syscalls::pipe (int *fildes, string& msg)
+octave_syscalls::pipe (int *fildes, std::string& msg)
 {
-  msg = string ();
+  msg = std::string ();
 
   int status = -1;
 
 #if defined (HAVE_PIPE)
   status = ::pipe (fildes);
 
   if (status < 0)
-    msg = ::strerror (errno);
+    {
+      using namespace std;
+      msg = ::strerror (errno);
+    }
 #else
   msg = NOT_SUPPORTED ("pipe");
 #endif
 
   return status;
 }
 
 pid_t
 octave_syscalls::waitpid (pid_t pid, int options)
 {
-  string msg;
+  std::string msg;
   return waitpid (pid, options, msg);
 }
 
 pid_t
-octave_syscalls::waitpid (pid_t pid, int options, string& msg)
+octave_syscalls::waitpid (pid_t pid, int options, std::string& msg)
 {
-  msg = string ();
+  msg = std::string ();
 
   int status = -1;
 
 #if defined (HAVE_WAITPID)
   status = ::waitpid (pid, 0, options);
 
   if (status < 0)
-    msg = ::strerror (errno);
+    {
+      using namespace std;
+      msg = ::strerror (errno);
+    }
 #else
   msg = NOT_SUPPORTED ("waitpid");
 #endif
 
   return status;
 }
 
 /*
diff --git a/liboctave/oct-syscalls.h b/liboctave/oct-syscalls.h
--- a/liboctave/oct-syscalls.h
+++ b/liboctave/oct-syscalls.h
@@ -30,43 +30,43 @@ class string_vector;
 #ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
 
 struct
 octave_syscalls
 {
   static int dup2 (int, int);
-  static int dup2 (int, int, string&);
+  static int dup2 (int, int, std::string&);
 
-  static int execvp (const string&, const string_vector&);
-  static int execvp (const string&, const string_vector&, string&);
+  static int execvp (const std::string&, const string_vector&);
+  static int execvp (const std::string&, const string_vector&, std::string&);
 
   static int fcntl (int, int, long);
-  static int fcntl (int, int, long, string&);
+  static int fcntl (int, int, long, std::string&);
 
-  static pid_t fork (string&);
-  static pid_t vfork (string&);
+  static pid_t fork (std::string&);
+  static pid_t vfork (std::string&);
 
-  static pid_t getpgrp (string&);
+  static pid_t getpgrp (std::string&);
 
   static pid_t getpid (void);
   static pid_t getppid (void);
 
   static gid_t getgid (void);
   static gid_t getegid (void);
 
   static uid_t getuid (void);
   static uid_t geteuid (void);
 
   static int pipe (int *);
-  static int pipe (int *, string&);
+  static int pipe (int *, std::string&);
 
   static pid_t waitpid (pid_t, int);
-  static pid_t waitpid (pid_t, int, string&);
+  static pid_t waitpid (pid_t, int, std::string&);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/oct-time.cc b/liboctave/oct-time.cc
--- a/liboctave/oct-time.cc
+++ b/liboctave/oct-time.cc
@@ -46,31 +46,31 @@ octave_time::octave_time (const octave_b
   t.tm_mday = tm.mday ();
   t.tm_mon = tm.mon ();
   t.tm_year = tm.year ();
   t.tm_wday = tm.wday ();
   t.tm_yday = tm.yday ();
   t.tm_isdst = tm.isdst ();
 
 #if defined (HAVE_TM_ZONE)
-  string s = tm.zone ();
+  std::string s = tm.zone ();
   char *ps = strsave (s.c_str ());
   t.tm_zone = ps;
 #endif
 
   ot_unix_time = mktime (&t);
 
 #if defined (HAVE_TM_ZONE)
   delete [] ps;
 #endif
 
   ot_usec = tm.usec ();
 }
 
-string
+std::string
 octave_time::ctime (void) const
 {
   return octave_localtime (*this) . asctime ();
 }
 
 void
 octave_time::stamp (void)
 {
@@ -115,30 +115,30 @@ DEFINE_SET_INT_FIELD_FCN (hour, 0, 23)
 DEFINE_SET_INT_FIELD_FCN (mday, 1, 31)
 DEFINE_SET_INT_FIELD_FCN (mon, 0, 11)
 DEFINE_SET_INT_FIELD_FCN (year, INT_MIN, INT_MAX)
 DEFINE_SET_INT_FIELD_FCN (wday, 0, 6)
 DEFINE_SET_INT_FIELD_FCN (yday, 0, 365)
 DEFINE_SET_INT_FIELD_FCN (isdst, 0, 1)
 
 octave_base_tm&
-octave_base_tm::zone (const string& s)
+octave_base_tm::zone (const std::string& s)
 {
   tm_zone = s;
   return *this;
 }
 
 #if !defined STRFTIME_BUF_INITIAL_SIZE
 #define STRFTIME_BUF_INITIAL_SIZE 128
 #endif
 
-string
-octave_base_tm::strftime (const string& fmt) const
+std::string
+octave_base_tm::strftime (const std::string& fmt) const
 {
-  string retval;
+  std::string retval;
 
   struct tm t;
   
   t.tm_sec = tm_sec;
   t.tm_min = tm_min;
   t.tm_hour = tm_hour;
   t.tm_mday = tm_mday;
   t.tm_mon = tm_mon;
@@ -219,17 +219,17 @@ octave_gmtime::init (const octave_time& 
   tm_usec = ot.usec ();
 
   time_t t = ot;
 
   octave_base_tm::init (gmtime (&t));
 }
 
 void
-octave_strptime::init (const string& str, const string& fmt)
+octave_strptime::init (const std::string& str, const std::string& fmt)
 {
   struct tm t;
 
   t.tm_sec = 0;
   t.tm_min = 0;
   t.tm_hour = 0;
   t.tm_mday = 0;
   t.tm_mon = 0;
diff --git a/liboctave/oct-time.h b/liboctave/oct-time.h
--- a/liboctave/oct-time.h
+++ b/liboctave/oct-time.h
@@ -41,17 +41,17 @@ public:
 
   octave_time (time_t t)
     : ot_unix_time (t), ot_usec (0) { }
 
   octave_time (double d)
     : ot_unix_time (static_cast<time_t> (d)), ot_usec (0)
   {
     double ip;
-    ot_usec = static_cast<int> (modf (d, &ip) * 1e6);
+    ot_usec = static_cast<int> (std::modf (d, &ip) * 1e6);
   }
 
   octave_time (const octave_base_tm& tm);
 
   octave_time (const octave_time& ot)
     : ot_unix_time (ot.ot_unix_time), ot_usec (ot.ot_usec) { }
 
   octave_time& operator = (const octave_time& ot)
@@ -72,17 +72,17 @@ public:
   operator double () const { return ot_unix_time + ot_usec / 1e6; }
 
   operator time_t () const { return ot_unix_time; }
 
   time_t unix_time (void) const { return ot_unix_time; }
 
   int usec (void) const { return ot_usec; }
 
-  string ctime (void) const;
+  std::string ctime (void) const;
 
 private:
 
   // Seconds since the epoch.
   time_t ot_unix_time;
 
   // Additional microseconds.
   int ot_usec;
@@ -183,33 +183,34 @@ public:
   int min (void) const { return tm_min; }
   int hour (void) const { return tm_hour; }
   int mday (void) const { return tm_mday; }
   int mon (void) const { return tm_mon; }
   int year (void) const { return tm_year; }
   int wday (void) const { return tm_wday; }
   int yday (void) const { return tm_yday; }
   int isdst (void) const { return tm_isdst; }
-  string zone (void) const { return tm_zone; }
+  std::string zone (void) const { return tm_zone; }
 
   octave_base_tm& usec (int v);
   octave_base_tm& sec (int v);
   octave_base_tm& min (int v);
   octave_base_tm& hour (int v);
   octave_base_tm& mday (int v);
   octave_base_tm& mon (int v);
   octave_base_tm& year (int v);
   octave_base_tm& wday (int v);
   octave_base_tm& yday (int v);
   octave_base_tm& isdst (int v);
-  octave_base_tm& zone (const string& s);
+  octave_base_tm& zone (const std::string& s);
 
-  string strftime (const string& fmt) const;
+  std::string strftime (const std::string& fmt) const;
 
-  string asctime (void) const { return strftime ("%a %b %d %H:%M:%S %Y\n"); }
+  std::string asctime (void) const
+    { return strftime ("%a %b %d %H:%M:%S %Y\n"); }
 
 protected:
 
   // Microseconds after the second (0, 999999).
   int tm_usec;
 
   // Seconds after the minute (0, 61).
   int tm_sec;
@@ -234,17 +235,17 @@ protected:
 
   // Days since January 1 (0, 365).
   int tm_yday;
 
   // Daylight Savings Time flag.
   int tm_isdst;
 
   // Time zone.
-  string tm_zone;
+  std::string tm_zone;
 
   void init (void *p);
 };
 
 class
 octave_localtime : public octave_base_tm
 {
 public:
@@ -295,17 +296,17 @@ private:
   void init (const octave_time& ot);
 };
 
 class
 octave_strptime : public octave_base_tm
 {
 public:
 
-  octave_strptime (const string& str, const string& fmt)
+  octave_strptime (const std::string& str, const std::string& fmt)
     : octave_base_tm () { init (str, fmt); }
 
   octave_strptime (const octave_strptime& s)
     : octave_base_tm (s) { nchars = s.nchars; }
 
   octave_strptime& operator = (const octave_strptime& s)
   {
     octave_base_tm::operator = (s);
@@ -316,17 +317,17 @@ public:
   int characters_converted (void) const { return nchars; }
 
   ~octave_strptime (void) { }
 
 private:
 
   int nchars;
 
-  void init (const string& str, const string& fmt);
+  void init (const std::string& str, const std::string& fmt);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/pathsearch.cc b/liboctave/pathsearch.cc
--- a/liboctave/pathsearch.cc
+++ b/liboctave/pathsearch.cc
@@ -97,36 +97,36 @@ dir_path::all_directories (void)
 	}
 
       retval.resize (count);
     }
 
   return retval;
 }
 
-string
-dir_path::find_first (const string& nm)
+std::string
+dir_path::find_first (const std::string& nm)
 {
-  string retval;
+  std::string retval;
 
   if (initialized)
     {
       char *tmp = kpse_path_search (p.c_str (), nm.c_str (), true);
       if (tmp)
 	{
 	  retval = tmp;
 	  free (tmp);
 	}
     }
 
   return retval;
 }
 
 string_vector
-dir_path::find_all (const string& nm)
+dir_path::find_all (const std::string& nm)
 {
   string_vector retval;
 
   if (initialized)
     {
       kpse_string *tmp = kpse_all_path_search (p.c_str (), nm.c_str ());
 
       if (tmp)
@@ -142,17 +142,17 @@ dir_path::find_all (const string& nm)
 	    retval[i] = tmp[i];
 	}
     }
 
   return retval;
 }
 
 void
-dir_path::set_program_name (const string& nm)
+dir_path::set_program_name (const std::string& nm)
 {
   kpse_set_progname (nm.c_str ());
 }
 
 void
 dir_path::init (void)
 {
   if (! octave_kpathsea_initialized)
@@ -182,17 +182,17 @@ dir_path::init (void)
     }
 
   if (t1)
     {
       p = t1;
       free (t1);
     }
   else
-    p = string ();
+    p = std::string ();
 
   int count = 0;
   char *path_elt = kpse_path_element (p.c_str ());
   while (path_elt)
     {
       path_elt = kpse_path_element (0);
       count++;
     }
diff --git a/liboctave/pathsearch.h b/liboctave/pathsearch.h
--- a/liboctave/pathsearch.h
+++ b/liboctave/pathsearch.h
@@ -27,17 +27,18 @@ Software Foundation, 59 Temple Place - S
 
 #include "str-vec.h"
 
 class
 dir_path
 {
 public:
 
-  dir_path (const string& s = string (), const string& d = string ())
+  dir_path (const std::string& s = std::string (),
+	    const std::string& d = std::string ())
     : p_orig (s), p_default (d), initialized (false)
     {
       if (! p_orig.empty ())
 	init ();
     }
 
   dir_path (const dir_path& dp)
     : p_orig (dp.p_orig), p_default (dp.p_default),
@@ -51,54 +52,54 @@ public:
       initialized = dp.initialized;
       p = dp.p;
       pv = dp.pv;
       return *this;
     }
 
   ~dir_path (void) { }
 
-  void set (const string& s)
+  void set (const std::string& s)
     {
       initialized = false;
       p_orig = s;
       init ();
     }
 
   string_vector elements (void);
   string_vector all_directories (void);
 
-  string find_first (const string&);
-  string find (const string& nm) { return find_first (nm); }
+  std::string find_first (const std::string&);
+  std::string find (const std::string& nm) { return find_first (nm); }
 
-  string_vector find_all (const string&);
+  string_vector find_all (const std::string&);
 
-  static void set_program_name (const string&);
+  static void set_program_name (const std::string&);
 
   void rehash (void)
     {
       initialized = false;
       init ();
     }
 
 private:
 
   // The colon separated list that we were given.
-  string p_orig;
+  std::string p_orig;
 
   // The default path.  If specified, replaces leading, trailing, or
   // doubled colons in p_orig.
-  string p_default;
+  std::string p_default;
 
   // TRUE means we've unpacked p.
   bool initialized;
 
   // A version of the colon separate list on which we have performed
   // tilde, variable, and possibly default path expansion.
-  string p;
+  std::string p;
 
   // The elements of the list.
   string_vector pv;
 
   void init (void);
 };
 
 #endif
diff --git a/liboctave/str-vec.cc b/liboctave/str-vec.cc
--- a/liboctave/str-vec.cc
+++ b/liboctave/str-vec.cc
@@ -37,17 +37,17 @@ 90, 91, 95, 1996 Free Software Foundatio
 
 #include "cmd-edit.h"
 #include "lo-utils.h"
 #include "str-vec.h"
 
 // Create a string vector from a NULL terminated list of C strings.
 
 string_vector::string_vector (const char * const *s)
-  : Array<string> ()
+  : Array<std::string> ()
 {
   int n = 0;
 
   const char * const *t = s;
 
   while (*t++)
     n++;
 
@@ -56,17 +56,17 @@ string_vector::string_vector (const char
   for (int i = 0; i < n; i++)
     elem (i) = s[i];
 }
 
 // Create a string vector from up to N C strings.  Assumes that N is
 // nonnegative.
 
 string_vector::string_vector (const char * const *s, int n)
-  : Array<string> (n)
+  : Array<std::string> (n)
 {
   for (int i = 0; i < n; i++)
     elem (i) = s[i];
 }
 
 string_vector&
 string_vector::uniq (void)
 {
@@ -109,18 +109,18 @@ string_vector::delete_c_str_vec (const c
   while (*v)
     delete [] *v;
 
   delete [] v;
 }
 
 // Format a list in neat columns.
 
-ostream&
-string_vector::list_in_columns (ostream& os) const
+std::ostream&
+string_vector::list_in_columns (std::ostream& os) const
 {
   // Compute the maximum name length.
 
   int max_name_length = 0;
   int total_names = length ();
 
   for (int i = 0; i < total_names; i++)
     {
@@ -154,17 +154,17 @@ string_vector::list_in_columns (ostream&
     {
       count = row;
       int pos = 0;
 
       // Print the next row.
 
       while (1)
 	{
-	  string nm = elem (count);
+	  std::string nm = elem (count);
 
 	  os << nm;
 	  int name_length = nm.length ();
 
 	  count += rows;
 	  if (count >= total_names)
 	    break;
 
diff --git a/liboctave/str-vec.h b/liboctave/str-vec.h
--- a/liboctave/str-vec.h
+++ b/liboctave/str-vec.h
@@ -26,45 +26,45 @@ Software Foundation, 59 Temple Place - S
 #include <iostream>
 #include <string>
 
 #include "Array.h"
 
 static int
 str_vec_compare (const void *a_arg, const void *b_arg)
 {
-  const string *a = (const string *) a_arg;
-  const string *b = (const string *) b_arg;
+  const std::string *a = (const std::string *) a_arg;
+  const std::string *b = (const std::string *) b_arg;
 
   return a->compare (*b);
 }
 
 class
-string_vector : public Array<string>
+string_vector : public Array<std::string>
 {
 public:
 
-  string_vector (void) : Array<string> () { }
+  string_vector (void) : Array<std::string> () { }
 
-  string_vector (int n) : Array<string> (n) { }
+  string_vector (int n) : Array<std::string> (n) { }
 
-  string_vector (const char *s) : Array<string> (1, s) { }
+  string_vector (const char *s) : Array<std::string> (1, s) { }
 
-  string_vector (const string& s) : Array<string> (1, s) { }
+  string_vector (const std::string& s) : Array<std::string> (1, s) { }
 
-  string_vector (const string_vector& s) : Array<string> (s) { }
+  string_vector (const string_vector& s) : Array<std::string> (s) { }
 
   string_vector (const char * const *s);
 
   string_vector (const char * const *s, int n);
 
   string_vector& operator = (const string_vector& s)
   {
     if (this != &s)
-      Array<string>::operator = (s);
+      Array<std::string>::operator = (s);
 
     return *this;
   }
 
   ~string_vector (void) { }
 
   int empty (void) const { return length () == 0; }
 
@@ -79,37 +79,37 @@ public:
 
 	if (tmp > longest)
 	  longest = tmp;
       }
 
     return longest;
   }
 
-  string& operator[] (int i) { return Array<string>::elem (i); }
+  std::string& operator[] (int i) { return Array<std::string>::elem (i); }
 
-  string operator[] (int i) const { return Array<string>::elem (i); }
+  std::string operator[] (int i) const { return Array<std::string>::elem (i); }
 
   string_vector& qsort (bool make_unique = false)
   {
-    Array<string>::qsort (str_vec_compare);
+    Array<std::string>::qsort (str_vec_compare);
 
     if (make_unique)
       uniq ();
 
     return *this;
   }
 
   string_vector& uniq (void);
 
   char **c_str_vec (void) const;
 
   static void delete_c_str_vec (const char * const*);
 
-  ostream& list_in_columns (ostream&) const;
+  std::ostream& list_in_columns (std::ostream&) const;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/strptime.c b/liboctave/strptime.c
--- a/liboctave/strptime.c
+++ b/liboctave/strptime.c
@@ -197,17 +197,17 @@ static char const ab_month_name[][4] =
   };
 # define HERE_D_T_FMT "%a %b %e %H:%M:%S %Y"
 # define HERE_D_FMT "%m/%d/%y"
 # define HERE_AM_STR "AM"
 # define HERE_PM_STR "PM"
 # define HERE_T_FMT_AMPM "%I:%M:%S %p"
 # define HERE_T_FMT "%H:%M:%S"
 
-const unsigned short int __mon_yday[1][13] =
+const unsigned short int __mon_yday[2][13] =
   {
     /* Normal years.  */
     { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 },
     /* Leap years.  */
     { 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366 }
   };
 #endif
 
