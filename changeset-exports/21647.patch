# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1461788020 14400
#      Wed Apr 27 16:13:40 2016 -0400
# Node ID 66cae7a6dc471c4143ff555b5d6c000d680c46b2
# Parent  3cddf1e65ccf4d3ebff62970bedae5c1e98a0d98
eliminate some macros for operator definitions

* ops.h (CAST_UNOP_ARG, CAST_BINOP_ARGS, CAST_CONV_ARG, ASSIGNOPDECL,
NULLASSIGNOPDECL, ASSIGNANYOPDECL, DEFASSIGNOP, DEFASSIGNOP_FN,
UNOPDECL, BINOPDECL, CATOPDECL): Delete macros.

* make_int.cc, ov-bool-mat.cc, ov-bool-sparse.cc, ov-bool.cc,
ov-complex.cc, ov-cx-diag.cc, ov-cx-mat.cc, ov-flt-cx-diag.cc,
ov-flt-re-diag.cc, ov-lazy-idx.cc, ov-null-mat.cc, ov-perm.cc,
ov-range.cc, ov-re-diag.cc, ov-re-mat.cc, ov-scalar.cc, ov-str-mat.cc,
op-b-b.cc, op-b-bm.cc, op-b-sbm.cc, op-bm-bm.cc, op-bm-sbm.cc,
op-cdm-cdm.cc, op-cell.cc, op-chm.cc, op-cm-cm.cc, op-cm-cs.cc,
op-cm-m.cc, op-cm-s.cc, op-cm-scm.cc, op-cm-sm.cc, op-cs-cm.cc,
op-cs-cs.cc, op-cs-m.cc, op-cs-s.cc, op-cs-scm.cc, op-cs-sm.cc,
op-dm-dm.cc, op-dm-scm.cc, op-dm-sm.cc, op-dm-template.cc,
op-dms-template.cc, op-fcdm-fcdm.cc, op-fcm-fcm.cc, op-fcm-fcs.cc,
op-fcm-fm.cc, op-fcm-fs.cc, op-fcn.cc, op-fcs-fcm.cc, op-fcs-fcs.cc,
op-fcs-fm.cc, op-fcs-fs.cc, op-fdm-fdm.cc, op-fm-fcm.cc, op-fm-fcs.cc,
op-fm-fm.cc, op-fm-fs.cc, op-fs-fcm.cc, op-fs-fcs.cc, op-fs-fm.cc,
op-fs-fs.cc, op-int-conv.cc, op-int.h, op-m-cm.cc, op-m-cs.cc,
op-m-m.cc, op-m-s.cc, op-m-scm.cc, op-m-sm.cc, op-pm-pm.cc,
op-pm-scm.cc, op-pm-sm.cc, op-pm-template.cc, op-range.cc, op-s-cm.cc,
op-s-cs.cc, op-s-m.cc, op-s-s.cc, op-s-scm.cc, op-s-sm.cc,
op-sbm-b.cc, op-sbm-bm.cc, op-sbm-sbm.cc, op-scm-cm.cc, op-scm-cs.cc,
op-scm-m.cc, op-scm-s.cc, op-scm-scm.cc, op-scm-sm.cc, op-sm-cm.cc,
op-sm-cs.cc, op-sm-m.cc, op-sm-s.cc, op-sm-scm.cc, op-sm-sm.cc,
op-str-m.cc, op-str-s.cc, op-str-str.cc, op-struct.cc, ops.h:
Expand eliminated macros in place.

diff --git a/examples/code/make_int.cc b/examples/code/make_int.cc
--- a/examples/code/make_int.cc
+++ b/examples/code/make_int.cc
@@ -119,76 +119,82 @@ octave_integer::print (std::ostream& os,
   newline (os);
 }
 
 #ifdef DEFUNOP_OP
 #undef DEFUNOP_OP
 #endif
 
 #define DEFUNOP_OP(name, t, op) \
-  UNOPDECL (name, a) \
+  static octave_value \
+  CONCAT2(oct_unop_, name) (const octave_base_value& a) \
   { \
-    CAST_UNOP_ARG (const octave_ ## t&); \
+    const octave_ ## t& v = dynamic_cast<const octave_ ## t&> (a); \
     return octave_value (new octave_integer (op v.t ## _value ())); \
   }
 
 DEFUNOP_OP (gnot, integer, !)
 DEFUNOP_OP (uminus, integer, -)
 DEFUNOP_OP (transpose, integer, /* no-op */)
 DEFUNOP_OP (hermitian, integer, /* no-op */)
 
 DEFNCUNOP_METHOD (incr, integer, increment)
 DEFNCUNOP_METHOD (decr, integer, decrement)
 
 #ifdef DEFBINOP_OP
 #undef DEFBINOP_OP
 #endif
 
 #define DEFBINOP_OP(name, t1, t2, op) \
-  BINOPDECL (name, a1, a2) \
+  static octave_value \
+  CONCAT2(oct_binop_, name) (const octave_base_value& a1, const octave_base_value& a2) \
   { \
-    CAST_BINOP_ARGS (const octave_ ## t1&, const octave_ ## t2&); \
+    const octave_ ## t1& v1 = dynamic_cast<const octave_ ## t1&> (a1); \
+    const octave_ ## t2& v2 = dynamic_cast<const octave_ ## t2&> (a2); \
     return octave_value \
       (new octave_integer (v1.t1 ## _value () op v2.t2 ## _value ())); \
   }
 
 // integer by integer ops.
 
 DEFBINOP_OP (add, integer, integer, +)
 DEFBINOP_OP (sub, integer, integer, -)
 DEFBINOP_OP (mul, integer, integer, *)
 
 DEFBINOP (div, integer, integer)
 {
-  CAST_BINOP_ARGS (const octave_integer&, const octave_integer&);
+  const octave_integer& v1 = dynamic_cast<const octave_integer&> (a1);
+  const octave_integer& v2 = dynamic_cast<const octave_integer&> (a2);
 
   int d = v2.integer_value ();
 
   if (d == 0)
     gripe_divide_by_zero ();
 
   return new octave_integer (v1.integer_value () / d);
 }
 
 
 DEFBINOP (i_s_div, integer, scalar)
 {
-  CAST_BINOP_ARGS (const octave_integer&, const octave_scalar&);
+  const octave_integer& v1 = dynamic_cast<const octave_integer&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   double d = v2.double_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return new octave_scalar (v1.double_value () / d);
 }
 
 DEFBINOP (ldiv, integer, integer)
 {
-  CAST_BINOP_ARGS (const octave_integer&, const octave_integer&);
+  const octave_integer& v1 = dynamic_cast<const octave_integer&> (a1);
+  const octave_integer& v2 = dynamic_cast<const octave_integer&> (a2);
 
   int d = v1.integer_value ();
 
   if (d == 0)
     gripe_divide_by_zero ();
 
   return new octave_integer (v2.integer_value () / d);
 }
@@ -199,29 +205,31 @@ DEFBINOP_OP (eq, integer, integer, ==)
 DEFBINOP_OP (ge, integer, integer, >=)
 DEFBINOP_OP (gt, integer, integer, >)
 DEFBINOP_OP (ne, integer, integer, !=)
 
 DEFBINOP_OP (el_mul, integer, integer, !=)
 
 DEFBINOP (el_div, integer, integer)
 {
-  CAST_BINOP_ARGS (const octave_integer&, const octave_integer&);
+  const octave_integer& v1 = dynamic_cast<const octave_integer&> (a1);
+  const octave_integer& v2 = dynamic_cast<const octave_integer&> (a2);
 
   int d = v2.integer_value ();
 
   if (d == 0)
     gripe_divide_by_zero ();
 
   return new octave_integer (v1.integer_value () / d);
 }
 
 DEFBINOP (el_ldiv, integer, integer)
 {
-  CAST_BINOP_ARGS (const octave_integer&, const octave_integer&);
+  const octave_integer& v1 = dynamic_cast<const octave_integer&> (a1);
+  const octave_integer& v2 = dynamic_cast<const octave_integer&> (a2);
 
   int d = v1.integer_value ();
 
   if (d == 0)
     gripe_divide_by_zero ();
 
   return new octave_integer (v2.integer_value () / d);
 }
diff --git a/libinterp/octave-value/ov-bool-mat.cc b/libinterp/octave-value/ov-bool-mat.cc
--- a/libinterp/octave-value/ov-bool-mat.cc
+++ b/libinterp/octave-value/ov-bool-mat.cc
@@ -55,17 +55,17 @@ template class octave_base_matrix<boolND
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_bool_matrix,
                                      "bool matrix", "logical");
 
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
-  CAST_CONV_ARG (const octave_bool_matrix&);
+  const octave_bool_matrix& v = dynamic_cast<const octave_bool_matrix&> (a);
 
   return new octave_matrix (NDArray (v.bool_array_value ()));
 }
 
 octave_base_value::type_conv_info
 octave_bool_matrix::numeric_conversion_function (void) const
 {
   return octave_base_value::type_conv_info (default_numeric_conversion_function,
diff --git a/libinterp/octave-value/ov-bool-sparse.cc b/libinterp/octave-value/ov-bool-sparse.cc
--- a/libinterp/octave-value/ov-bool-sparse.cc
+++ b/libinterp/octave-value/ov-bool-sparse.cc
@@ -53,17 +53,17 @@ template class OCTINTERP_API octave_base
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_sparse_bool_matrix,
                                      "sparse bool matrix", "logical");
 
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
-  CAST_CONV_ARG (const octave_sparse_bool_matrix&);
+  const octave_sparse_bool_matrix& v = dynamic_cast<const octave_sparse_bool_matrix&> (a);
 
   return
     new octave_sparse_matrix (SparseMatrix (v.sparse_bool_matrix_value ()));
 }
 
 octave_base_value::type_conv_info
 octave_sparse_bool_matrix::numeric_conversion_function (void) const
 {
diff --git a/libinterp/octave-value/ov-bool.cc b/libinterp/octave-value/ov-bool.cc
--- a/libinterp/octave-value/ov-bool.cc
+++ b/libinterp/octave-value/ov-bool.cc
@@ -54,17 +54,17 @@ extern template class OCTINTERP_API octa
 template class octave_base_scalar<bool>;
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_bool, "bool", "logical");
 
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
-  CAST_CONV_ARG (const octave_bool&);
+  const octave_bool& v = dynamic_cast<const octave_bool&> (a);
 
   return new octave_scalar (v.bool_value ());
 }
 
 octave_base_value::type_conv_info
 octave_bool::numeric_conversion_function (void) const
 {
   return octave_base_value::type_conv_info (default_numeric_conversion_function,
diff --git a/libinterp/octave-value/ov-complex.cc b/libinterp/octave-value/ov-complex.cc
--- a/libinterp/octave-value/ov-complex.cc
+++ b/libinterp/octave-value/ov-complex.cc
@@ -84,17 +84,17 @@ public:
   {
     return "Octave:invalid-index";
   }
 };
 
 static octave_base_value *
 default_numeric_demotion_function (const octave_base_value& a)
 {
-  CAST_CONV_ARG (const octave_complex&);
+  const octave_complex& v = dynamic_cast<const octave_complex&> (a);
 
   return new octave_float_complex (v.float_complex_value ());
 }
 
 octave_base_value::type_conv_info
 octave_complex::numeric_demotion_function (void) const
 {
   return
diff --git a/libinterp/octave-value/ov-cx-diag.cc b/libinterp/octave-value/ov-cx-diag.cc
--- a/libinterp/octave-value/ov-cx-diag.cc
+++ b/libinterp/octave-value/ov-cx-diag.cc
@@ -38,33 +38,33 @@ template class octave_base_diag<ComplexD
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_complex_diag_matrix,
                                      "complex diagonal matrix", "double");
 
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
-  CAST_CONV_ARG (const octave_complex_diag_matrix&);
+  const octave_complex_diag_matrix& v = dynamic_cast<const octave_complex_diag_matrix&> (a);
 
   return new octave_complex_matrix (v.complex_matrix_value ());
 }
 
 octave_base_value::type_conv_info
 octave_complex_diag_matrix::numeric_conversion_function (void) const
 {
   return octave_base_value::type_conv_info
            (default_numeric_conversion_function,
             octave_complex_matrix::static_type_id ());
 }
 
 static octave_base_value *
 default_numeric_demotion_function (const octave_base_value& a)
 {
-  CAST_CONV_ARG (const octave_complex_diag_matrix&);
+  const octave_complex_diag_matrix& v = dynamic_cast<const octave_complex_diag_matrix&> (a);
 
   return new octave_float_complex_diag_matrix
                (v.float_complex_diag_matrix_value ());
 }
 
 octave_base_value::type_conv_info
 octave_complex_diag_matrix::numeric_demotion_function (void) const
 {
diff --git a/libinterp/octave-value/ov-cx-mat.cc b/libinterp/octave-value/ov-cx-mat.cc
--- a/libinterp/octave-value/ov-cx-mat.cc
+++ b/libinterp/octave-value/ov-cx-mat.cc
@@ -61,17 +61,17 @@ template class octave_base_matrix<Comple
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_complex_matrix,
                                      "complex matrix", "double");
 
 static octave_base_value *
 default_numeric_demotion_function (const octave_base_value& a)
 {
-  CAST_CONV_ARG (const octave_complex_matrix&);
+  const octave_complex_matrix& v = dynamic_cast<const octave_complex_matrix&> (a);
 
   return new octave_float_complex_matrix (v.float_complex_array_value ());
 }
 
 octave_base_value::type_conv_info
 octave_complex_matrix::numeric_demotion_function (void) const
 {
   return octave_base_value::type_conv_info
diff --git a/libinterp/octave-value/ov-flt-cx-diag.cc b/libinterp/octave-value/ov-flt-cx-diag.cc
--- a/libinterp/octave-value/ov-flt-cx-diag.cc
+++ b/libinterp/octave-value/ov-flt-cx-diag.cc
@@ -37,17 +37,17 @@ template class octave_base_diag<FloatCom
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_float_complex_diag_matrix,
                                      "float complex diagonal matrix", "single");
 
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
-  CAST_CONV_ARG (const octave_float_complex_diag_matrix&);
+  const octave_float_complex_diag_matrix& v = dynamic_cast<const octave_float_complex_diag_matrix&> (a);
 
   return new octave_float_complex_matrix (v.float_complex_matrix_value ());
 }
 
 octave_base_value::type_conv_info
 octave_float_complex_diag_matrix::numeric_conversion_function (void) const
 {
   return octave_base_value::type_conv_info (default_numeric_conversion_function,
diff --git a/libinterp/octave-value/ov-flt-re-diag.cc b/libinterp/octave-value/ov-flt-re-diag.cc
--- a/libinterp/octave-value/ov-flt-re-diag.cc
+++ b/libinterp/octave-value/ov-flt-re-diag.cc
@@ -36,17 +36,17 @@ template class octave_base_diag<FloatDia
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_float_diag_matrix,
                                      "float diagonal matrix", "single");
 
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
-  CAST_CONV_ARG (const octave_float_diag_matrix&);
+  const octave_float_diag_matrix& v = dynamic_cast<const octave_float_diag_matrix&> (a);
 
   return new octave_float_matrix (v.float_matrix_value ());
 }
 
 octave_base_value::type_conv_info
 octave_float_diag_matrix::numeric_conversion_function (void) const
 {
   return octave_base_value::type_conv_info (default_numeric_conversion_function,
diff --git a/libinterp/octave-value/ov-lazy-idx.cc b/libinterp/octave-value/ov-lazy-idx.cc
--- a/libinterp/octave-value/ov-lazy-idx.cc
+++ b/libinterp/octave-value/ov-lazy-idx.cc
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 #include "ls-oct-text.h"
 #include "ls-oct-binary.h"
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_lazy_index, "lazy_index", "double");
 
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
-  CAST_CONV_ARG (const octave_lazy_index&);
+  const octave_lazy_index& v = dynamic_cast<const octave_lazy_index&> (a);
 
   return v.full_value ().clone ();
 }
 
 octave_base_value::type_conv_info
 octave_lazy_index::numeric_conversion_function (void) const
 {
   return octave_base_value::type_conv_info (default_numeric_conversion_function,
diff --git a/libinterp/octave-value/ov-null-mat.cc b/libinterp/octave-value/ov-null-mat.cc
--- a/libinterp/octave-value/ov-null-mat.cc
+++ b/libinterp/octave-value/ov-null-mat.cc
@@ -32,17 +32,17 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
                                      "double");
 
 const octave_value octave_null_matrix::instance (new octave_null_matrix ());
 
 static octave_base_value *
 default_null_matrix_numeric_conversion_function (const octave_base_value& a)
 {
   // The cast is not necessary?
-  // CAST_CONV_ARG (const octave_null_matrix&);
+  // const octave_null_matrix& v = dynamic_cast<const octave_null_matrix&> (a);
 
   return a.empty_clone ();
 }
 
 octave_base_value::type_conv_info
 octave_null_matrix::numeric_conversion_function (void) const
 {
   return octave_base_value::type_conv_info
@@ -53,17 +53,17 @@ octave_null_matrix::numeric_conversion_f
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_null_str, "null_string", "char");
 
 const octave_value octave_null_str::instance (new octave_null_str ());
 
 static octave_base_value *
 default_null_str_numeric_conversion_function (const octave_base_value& a)
 {
   // The cast is not necessary?
-  // CAST_CONV_ARG (const octave_null_str&);
+  // const octave_null_str& v = dynamic_cast<const octave_null_str&> (a);
 
   return a.empty_clone ();
 }
 
 octave_base_value::type_conv_info
 octave_null_str::numeric_conversion_function (void) const
 {
   return octave_base_value::type_conv_info
@@ -75,17 +75,17 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
                                      "char");
 
 const octave_value octave_null_sq_str::instance (new octave_null_sq_str ());
 
 static octave_base_value *
 default_null_sq_str_numeric_conversion_function (const octave_base_value& a)
 {
   // The cast is not necessary?
-  // CAST_CONV_ARG (const octave_null_sq_str&);
+  // const octave_null_sq_str& v = dynamic_cast<const octave_null_sq_str&> (a);
 
   return a.empty_clone ();
 }
 
 octave_base_value::type_conv_info
 octave_null_sq_str::numeric_conversion_function (void) const
 {
   return octave_base_value::type_conv_info
diff --git a/libinterp/octave-value/ov-perm.cc b/libinterp/octave-value/ov-perm.cc
--- a/libinterp/octave-value/ov-perm.cc
+++ b/libinterp/octave-value/ov-perm.cc
@@ -408,17 +408,17 @@ octave_perm_matrix::to_dense (void) cons
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_perm_matrix,
                                      "permutation matrix", "double");
 
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
-  CAST_CONV_ARG (const octave_perm_matrix&);
+  const octave_perm_matrix& v = dynamic_cast<const octave_perm_matrix&> (a);
 
   return new octave_matrix (v.matrix_value ());
 }
 
 octave_base_value::type_conv_info
 octave_perm_matrix::numeric_conversion_function (void) const
 {
   return octave_base_value::type_conv_info (default_numeric_conversion_function,
diff --git a/libinterp/octave-value/ov-range.cc b/libinterp/octave-value/ov-range.cc
--- a/libinterp/octave-value/ov-range.cc
+++ b/libinterp/octave-value/ov-range.cc
@@ -50,17 +50,17 @@ along with Octave; see the file COPYING.
 static bool Vallow_noninteger_range_as_index = true;
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_range, "range", "double");
 
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
-  CAST_CONV_ARG (const octave_range&);
+  const octave_range& v = dynamic_cast<const octave_range&> (a);
 
   return new octave_matrix (v.matrix_value ());
 }
 
 octave_base_value::type_conv_info
 octave_range::numeric_conversion_function (void) const
 {
   return octave_base_value::type_conv_info (default_numeric_conversion_function,
diff --git a/libinterp/octave-value/ov-re-diag.cc b/libinterp/octave-value/ov-re-diag.cc
--- a/libinterp/octave-value/ov-re-diag.cc
+++ b/libinterp/octave-value/ov-re-diag.cc
@@ -37,32 +37,32 @@ template class octave_base_diag<DiagMatr
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_diag_matrix, "diagonal matrix",
                                      "double");
 
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
-  CAST_CONV_ARG (const octave_diag_matrix&);
+  const octave_diag_matrix& v = dynamic_cast<const octave_diag_matrix&> (a);
 
   return new octave_matrix (v.matrix_value ());
 }
 
 octave_base_value::type_conv_info
 octave_diag_matrix::numeric_conversion_function (void) const
 {
   return octave_base_value::type_conv_info (default_numeric_conversion_function,
                                             octave_matrix::static_type_id ());
 }
 
 static octave_base_value *
 default_numeric_demotion_function (const octave_base_value& a)
 {
-  CAST_CONV_ARG (const octave_diag_matrix&);
+  const octave_diag_matrix& v = dynamic_cast<const octave_diag_matrix&> (a);
 
   return new octave_float_diag_matrix (v.float_diag_matrix_value ());
 }
 
 octave_base_value::type_conv_info
 octave_diag_matrix::numeric_demotion_function (void) const
 {
   return octave_base_value::type_conv_info
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -72,17 +72,17 @@ along with Octave; see the file COPYING.
 template class octave_base_matrix<NDArray>;
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_matrix, "matrix", "double");
 
 static octave_base_value *
 default_numeric_demotion_function (const octave_base_value& a)
 {
-  CAST_CONV_ARG (const octave_matrix&);
+  const octave_matrix& v = dynamic_cast<const octave_matrix&> (a);
 
   return new octave_float_matrix (v.float_array_value ());
 }
 
 octave_base_value::type_conv_info
 octave_matrix::numeric_demotion_function (void) const
 {
   return octave_base_value::type_conv_info
diff --git a/libinterp/octave-value/ov-scalar.cc b/libinterp/octave-value/ov-scalar.cc
--- a/libinterp/octave-value/ov-scalar.cc
+++ b/libinterp/octave-value/ov-scalar.cc
@@ -61,17 +61,17 @@ extern template class OCTINTERP_API octa
 template class octave_base_scalar<double>;
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_scalar, "scalar", "double");
 
 static octave_base_value *
 default_numeric_demotion_function (const octave_base_value& a)
 {
-  CAST_CONV_ARG (const octave_scalar&);
+  const octave_scalar& v = dynamic_cast<const octave_scalar&> (a);
 
   return new octave_float_scalar (v.float_value ());
 }
 
 octave_base_value::type_conv_info
 octave_scalar::numeric_demotion_function (void) const
 {
   return octave_base_value::type_conv_info
diff --git a/libinterp/octave-value/ov-str-mat.cc b/libinterp/octave-value/ov-str-mat.cc
--- a/libinterp/octave-value/ov-str-mat.cc
+++ b/libinterp/octave-value/ov-str-mat.cc
@@ -59,17 +59,17 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_char_matrix_sq_str, "sq_string",
                                      "char");
 
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
   octave_base_value *retval = 0;
 
-  CAST_CONV_ARG (const octave_char_matrix_str&);
+  const octave_char_matrix_str& v = dynamic_cast<const octave_char_matrix_str&> (a);
 
   NDArray nda = v.array_value (true);
 
   if (nda.numel () == 1)
     retval = new octave_scalar (nda(0));
   else
     retval = new octave_matrix (nda);
 
diff --git a/libinterp/operators/op-b-b.cc b/libinterp/operators/op-b-b.cc
--- a/libinterp/operators/op-b-b.cc
+++ b/libinterp/operators/op-b-b.cc
@@ -39,25 +39,27 @@ along with Octave; see the file COPYING.
 #include "xpow.h"
 
 // bool unary ops.
 
 // scalar unary ops.
 
 DEFUNOP_OP (not, bool, !)
 
-UNOPDECL (uplus, a)
+static octave_value
+oct_unop_uplus (const octave_base_value& a)
 {
-  CAST_UNOP_ARG (const octave_bool&);
+  const octave_bool& v = dynamic_cast<const octave_bool&> (a);
   return octave_value (v.double_value ());
 }
 
-UNOPDECL (uminus, a)
+static octave_value
+oct_unop_uminus (const octave_base_value& a)
 {
-  CAST_UNOP_ARG (const octave_bool&);
+  const octave_bool& v = dynamic_cast<const octave_bool&> (a);
   return octave_value (- v.double_value ());
 }
 
 DEFUNOP_OP (transpose, bool, /* no-op */)
 DEFUNOP_OP (hermitian, bool, /* no-op */)
 
 // bool by bool ops.
 
diff --git a/libinterp/operators/op-b-bm.cc b/libinterp/operators/op-b-bm.cc
--- a/libinterp/operators/op-b-bm.cc
+++ b/libinterp/operators/op-b-bm.cc
@@ -51,17 +51,17 @@ DEFNDCATOP_FN (b_m, bool, matrix, array,
 DEFNDCATOP_FN (s_bm, scalar, bool_matrix, array, array, concat)
 
 DEFNDCATOP_FN (b_fm, bool, float_matrix, float_array, float_array, concat)
 DEFNDCATOP_FN (f_bm, float_scalar, bool_matrix, float_array, float_array,
                concat)
 
 DEFCONV (bool_matrix_conv, bool, bool_matrix)
 {
-  CAST_CONV_ARG (const octave_bool&);
+  const octave_bool& v = dynamic_cast<const octave_bool&> (a);
 
   return new octave_bool_matrix (v.bool_matrix_value ());
 }
 
 void
 install_b_bm_ops (void)
 {
   INSTALL_BINOP (op_el_and, octave_bool, octave_bool_matrix, el_and);
diff --git a/libinterp/operators/op-b-sbm.cc b/libinterp/operators/op-b-sbm.cc
--- a/libinterp/operators/op-b-sbm.cc
+++ b/libinterp/operators/op-b-sbm.cc
@@ -42,39 +42,42 @@ along with Octave; see the file COPYING.
 DEFBINOP_FN (ne, bool, sparse_bool_matrix, mx_el_ne)
 DEFBINOP_FN (eq, bool, sparse_bool_matrix, mx_el_eq)
 
 DEFBINOP_FN (el_and, bool, sparse_bool_matrix, mx_el_and)
 DEFBINOP_FN (el_or, bool, sparse_bool_matrix, mx_el_or)
 
 DEFCATOP (b_sbm, bool, sparse_bool_matrix)
 {
-  CAST_BINOP_ARGS (octave_bool&, const octave_sparse_bool_matrix&);
+  octave_bool& v1 = dynamic_cast<octave_bool&> (a1);
+  const octave_sparse_bool_matrix& v2 = dynamic_cast<const octave_sparse_bool_matrix&> (a2);
   SparseBoolMatrix tmp (1, 1, v1.bool_value ());
   return octave_value (tmp. concat (v2.sparse_bool_matrix_value (),
                                     ra_idx));
 }
 
 DEFCATOP (b_sm, bool, sparse_matrix)
 {
-  CAST_BINOP_ARGS (octave_bool&, const octave_sparse_matrix&);
+  octave_bool& v1 = dynamic_cast<octave_bool&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
   SparseMatrix tmp (1, 1, v1.scalar_value ());
   return octave_value (tmp. concat (v2.sparse_matrix_value (), ra_idx));
 }
 
 DEFCATOP (s_sbm, scalar, sparse_bool_matrix)
 {
-  CAST_BINOP_ARGS (octave_scalar&, const octave_sparse_bool_matrix&);
+  octave_scalar& v1 = dynamic_cast<octave_scalar&> (a1);
+  const octave_sparse_bool_matrix& v2 = dynamic_cast<const octave_sparse_bool_matrix&> (a2);
   SparseMatrix tmp (1, 1, v1.scalar_value ());
   return octave_value(tmp. concat (v2.sparse_matrix_value (), ra_idx));
 }
 
 DEFCONV (sparse_bool_matrix_conv, bool, sparse_bool_matrix)
 {
-  CAST_CONV_ARG (const octave_bool&);
+  const octave_bool& v = dynamic_cast<const octave_bool&> (a);
 
   return new octave_sparse_bool_matrix
     (SparseBoolMatrix (1, 1, v.bool_value ()));
 }
 
 void
 install_b_sbm_ops (void)
 {
diff --git a/libinterp/operators/op-bm-bm.cc b/libinterp/operators/op-bm-bm.cc
--- a/libinterp/operators/op-bm-bm.cc
+++ b/libinterp/operators/op-bm-bm.cc
@@ -53,17 +53,17 @@ along with Octave; see the file COPYING.
 DEFNDUNOP_OP (not, bool_matrix, bool_array, !)
 DEFNDUNOP_OP (uplus, bool_matrix, array, +)
 DEFNDUNOP_OP (uminus, bool_matrix, array, -)
 
 DEFNCUNOP_METHOD (invert, bool_matrix, invert)
 
 DEFUNOP (transpose, bool_matrix)
 {
-  CAST_UNOP_ARG (const octave_bool_matrix&);
+  const octave_bool_matrix& v = dynamic_cast<const octave_bool_matrix&> (a);
 
   if (v.ndims () > 2)
     error ("transpose not defined for N-D objects");
 
   return octave_value (v.bool_matrix_value ().transpose ());
 }
 
 // bool matrix by bool matrix ops.
diff --git a/libinterp/operators/op-bm-sbm.cc b/libinterp/operators/op-bm-sbm.cc
--- a/libinterp/operators/op-bm-sbm.cc
+++ b/libinterp/operators/op-bm-sbm.cc
@@ -44,39 +44,42 @@ along with Octave; see the file COPYING.
 DEFBINOP_FN (eq, bool_matrix, sparse_bool_matrix, mx_el_eq)
 DEFBINOP_FN (ne, bool_matrix, sparse_bool_matrix, mx_el_ne)
 
 DEFBINOP_FN (el_and, bool_matrix, sparse_bool_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  bool_matrix, sparse_bool_matrix, mx_el_or)
 
 DEFCATOP (bm_sbm, bool_matrix, sparse_bool_matrix)
 {
-  CAST_BINOP_ARGS (octave_bool_matrix&, const octave_sparse_bool_matrix&);
+  octave_bool_matrix& v1 = dynamic_cast<octave_bool_matrix&> (a1);
+  const octave_sparse_bool_matrix& v2 = dynamic_cast<const octave_sparse_bool_matrix&> (a2);
   SparseBoolMatrix tmp (v1.bool_matrix_value ());
   return octave_value (tmp. concat (v2.sparse_bool_matrix_value (),
                                     ra_idx));
 }
 
 DEFCATOP (m_sbm, matrix, sparse_bool_matrix)
 {
-  CAST_BINOP_ARGS (octave_matrix&, const octave_sparse_bool_matrix&);
+  octave_matrix& v1 = dynamic_cast<octave_matrix&> (a1);
+  const octave_sparse_bool_matrix& v2 = dynamic_cast<const octave_sparse_bool_matrix&> (a2);
   SparseMatrix tmp (v1.matrix_value ());
   return octave_value (tmp. concat (v2.sparse_matrix_value (), ra_idx));
 }
 
 DEFCATOP (bm_sm, bool_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (octave_bool_matrix&, const octave_sparse_matrix&);
+  octave_bool_matrix& v1 = dynamic_cast<octave_bool_matrix&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
   SparseMatrix tmp (v1.matrix_value ());
   return octave_value (tmp. concat (v2.sparse_matrix_value (), ra_idx));
 }
 
 DEFCONV (sparse_bool_matrix_conv, bool_matrix, sparse_bool_matrix)
 {
-  CAST_CONV_ARG (const octave_bool_matrix&);
+  const octave_bool_matrix& v = dynamic_cast<const octave_bool_matrix&> (a);
   return new octave_sparse_bool_matrix
     (SparseBoolMatrix (v.bool_matrix_value ()));
 }
 
 DEFNDASSIGNOP_FN (assign, bool_matrix, sparse_bool_matrix, bool_array, assign)
 
 void
 install_bm_sbm_ops (void)
diff --git a/libinterp/operators/op-cdm-cdm.cc b/libinterp/operators/op-cdm-cdm.cc
--- a/libinterp/operators/op-cdm-cdm.cc
+++ b/libinterp/operators/op-cdm-cdm.cc
@@ -37,60 +37,60 @@ along with Octave; see the file COPYING.
 
 // matrix unary ops.
 
 DEFUNOP_OP (uplus, complex_diag_matrix, /* no-op */)
 DEFUNOP_OP (uminus, complex_diag_matrix, -)
 
 DEFUNOP (transpose, complex_diag_matrix)
 {
-  CAST_UNOP_ARG (const octave_complex_diag_matrix&);
+  const octave_complex_diag_matrix& v = dynamic_cast<const octave_complex_diag_matrix&> (a);
   return octave_value (v.complex_diag_matrix_value ().transpose ());
 }
 
 DEFUNOP (hermitian, complex_diag_matrix)
 {
-  CAST_UNOP_ARG (const octave_complex_diag_matrix&);
+  const octave_complex_diag_matrix& v = dynamic_cast<const octave_complex_diag_matrix&> (a);
   return octave_value (v.complex_diag_matrix_value ().hermitian ());
 }
 
 // matrix by matrix ops.
 
 DEFBINOP_OP (add, complex_diag_matrix, complex_diag_matrix, +)
 DEFBINOP_OP (sub, complex_diag_matrix, complex_diag_matrix, -)
 DEFBINOP_OP (mul, complex_diag_matrix, complex_diag_matrix, *)
 
 DEFBINOP (div, complex_diag_matrix, complex_diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_diag_matrix&,
-                   const octave_complex_diag_matrix&);
+  const octave_complex_diag_matrix& v1 = dynamic_cast<const octave_complex_diag_matrix&> (a1);
+  const octave_complex_diag_matrix& v2 = dynamic_cast<const octave_complex_diag_matrix&> (a2);
 
   return xdiv (v1.complex_diag_matrix_value (),
                v2.complex_diag_matrix_value ());
 }
 
 DEFBINOP (ldiv, complex_diag_matrix, complex_diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_diag_matrix&,
-                   const octave_complex_diag_matrix&);
+  const octave_complex_diag_matrix& v1 = dynamic_cast<const octave_complex_diag_matrix&> (a1);
+  const octave_complex_diag_matrix& v2 = dynamic_cast<const octave_complex_diag_matrix&> (a2);
 
   return xleftdiv (v1.complex_diag_matrix_value (),
                    v2.complex_diag_matrix_value ());
 }
 
 CONVDECL (complex_diag_matrix_to_complex_matrix)
 {
-  CAST_CONV_ARG (const octave_complex_diag_matrix&);
+  const octave_complex_diag_matrix& v = dynamic_cast<const octave_complex_diag_matrix&> (a);
 
   return new octave_complex_matrix (v.complex_matrix_value ());
 }
 
 CONVDECL (complex_diag_matrix_to_float_complex_diag_matrix)
 {
-  CAST_CONV_ARG (const octave_complex_diag_matrix&);
+  const octave_complex_diag_matrix& v = dynamic_cast<const octave_complex_diag_matrix&> (a);
 
   return
     new octave_float_complex_diag_matrix (v.float_complex_diag_matrix_value ());
 }
 
 void
 install_cdm_cdm_ops (void)
 {
diff --git a/libinterp/operators/op-cell.cc b/libinterp/operators/op-cell.cc
--- a/libinterp/operators/op-cell.cc
+++ b/libinterp/operators/op-cell.cc
@@ -33,17 +33,17 @@ along with Octave; see the file COPYING.
 #include "ov-typeinfo.h"
 #include "ov-null-mat.h"
 #include "ops.h"
 
 // cell ops.
 
 DEFUNOP (transpose, cell)
 {
-  CAST_UNOP_ARG (const octave_cell&);
+  const octave_cell& v = dynamic_cast<const octave_cell&> (a);
 
   if (v.ndims () > 2)
     error ("transpose not defined for N-D objects");
 
   return octave_value (Cell (v.cell_value ().transpose ()));
 }
 
 DEFCATOP_FN (c_c, cell, cell, concat)
diff --git a/libinterp/operators/op-chm.cc b/libinterp/operators/op-chm.cc
--- a/libinterp/operators/op-chm.cc
+++ b/libinterp/operators/op-chm.cc
@@ -34,60 +34,64 @@ along with Octave; see the file COPYING.
 #include "ov-bool-mat.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 
 // char matrix unary ops.
 
 DEFUNOP (transpose, char_matrix)
 {
-  CAST_UNOP_ARG (const octave_char_matrix&);
+  const octave_char_matrix& v = dynamic_cast<const octave_char_matrix&> (a);
 
   return octave_value (v.matrix_value ().transpose ());
 }
 
 DEFNDCATOP_FN (chm_chm, char_matrix, char_matrix, char_array, char_array,
                concat)
 
 DEFCATOP (chm_s, char_matrix, scalar)
 {
-  CAST_BINOP_ARGS (octave_char_matrix&, const octave_scalar&);
+  octave_char_matrix& v1 = dynamic_cast<octave_char_matrix&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   warn_implicit_conversion ("Octave:num-to-str",
                             v2.type_name (), v1.type_name ());
 
   return octave_value (v1.char_array_value (). concat (v2.array_value (),
                        ra_idx));
 }
 
 DEFCATOP (chm_m, char_matrix, matrix)
 {
-  CAST_BINOP_ARGS (octave_char_matrix&, const octave_matrix&);
+  octave_char_matrix& v1 = dynamic_cast<octave_char_matrix&> (a1);
+  const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
 
   warn_implicit_conversion ("Octave:num-to-str",
                             v2.type_name (), v1.type_name ());
 
   return octave_value (v1.char_array_value (). concat (v2.array_value (),
                        ra_idx));
 }
 
 DEFCATOP (s_chm, scalar, char_matrix)
 {
-  CAST_BINOP_ARGS (octave_scalar&, const octave_char_matrix&);
+  octave_scalar& v1 = dynamic_cast<octave_scalar&> (a1);
+  const octave_char_matrix& v2 = dynamic_cast<const octave_char_matrix&> (a2);
 
   warn_implicit_conversion ("Octave:num-to-str",
                             v1.type_name (), v2.type_name ());
 
   return octave_value (v1.array_value (). concat (v2.char_array_value (),
                        ra_idx));
 }
 
 DEFCATOP (m_chm, matrix, char_matrix)
 {
-  CAST_BINOP_ARGS (octave_matrix&, const octave_char_matrix&);
+  octave_matrix& v1 = dynamic_cast<octave_matrix&> (a1);
+  const octave_char_matrix& v2 = dynamic_cast<const octave_char_matrix&> (a2);
 
   warn_implicit_conversion ("Octave:num-to-str",
                             v1.type_name (), v2.type_name ());
 
   return octave_value (v1.array_value (). concat (v2.char_array_value (),
                        ra_idx));
 }
 
diff --git a/libinterp/operators/op-cm-cm.cc b/libinterp/operators/op-cm-cm.cc
--- a/libinterp/operators/op-cm-cm.cc
+++ b/libinterp/operators/op-cm-cm.cc
@@ -38,27 +38,27 @@ along with Octave; see the file COPYING.
 // unary complex matrix ops.
 
 DEFNDUNOP_OP (not, complex_matrix, complex_array, !)
 DEFNDUNOP_OP (uplus, complex_matrix, complex_array, /* no-op */)
 DEFNDUNOP_OP (uminus, complex_matrix, complex_array, -)
 
 DEFUNOP (transpose, complex_matrix)
 {
-  CAST_UNOP_ARG (const octave_complex_matrix&);
+  const octave_complex_matrix& v = dynamic_cast<const octave_complex_matrix&> (a);
 
   if (v.ndims () > 2)
     error ("transpose not defined for N-D objects");
 
   return octave_value (v.complex_matrix_value ().transpose ());
 }
 
 DEFUNOP (hermitian, complex_matrix)
 {
-  CAST_UNOP_ARG (const octave_complex_matrix&);
+  const octave_complex_matrix& v = dynamic_cast<const octave_complex_matrix&> (a);
 
   if (v.ndims () > 2)
     error ("complex-conjugate transpose not defined for N-D objects");
 
   return octave_value (v.complex_matrix_value ().hermitian ());
 }
 
 DEFNCUNOP_METHOD (incr, complex_matrix, increment)
@@ -71,90 +71,98 @@ DEFNDBINOP_OP (add, complex_matrix, comp
                complex_array, +)
 DEFNDBINOP_OP (sub, complex_matrix, complex_matrix, complex_array,
                complex_array, -)
 
 DEFBINOP_OP (mul, complex_matrix, complex_matrix, *)
 
 DEFBINOP (div, complex_matrix, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
+  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
   MatrixType typ = v2.matrix_type ();
 
   ComplexMatrix ret = xdiv (v1.complex_matrix_value (),
                             v2.complex_matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, complex_matrix, complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, complex_matrix, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
+  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
   MatrixType typ = v1.matrix_type ();
 
   ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (),
                                 v2.complex_matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP (trans_mul, complex_matrix, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
+  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
   return octave_value(xgemm (v1.complex_matrix_value (),
                              v2.complex_matrix_value (),
                              blas_trans, blas_no_trans));
 }
 
 DEFBINOP (mul_trans, complex_matrix, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
+  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
   return octave_value(xgemm (v1.complex_matrix_value (),
                              v2.complex_matrix_value (),
                              blas_no_trans, blas_trans));
 }
 
 DEFBINOP (herm_mul, complex_matrix, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
+  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
   return octave_value(xgemm (v1.complex_matrix_value (),
                              v2.complex_matrix_value (),
                              blas_conj_trans, blas_no_trans));
 }
 
 DEFBINOP (mul_herm, complex_matrix, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
+  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
   return octave_value(xgemm (v1.complex_matrix_value (),
                              v2.complex_matrix_value (),
                              blas_no_trans, blas_conj_trans));
 }
 
 DEFBINOP (trans_ldiv, complex_matrix, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
+  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
   MatrixType typ = v1.matrix_type ();
 
   ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (),
                                 v2.complex_matrix_value (), typ, blas_trans);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP (herm_ldiv, complex_matrix, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
+  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
   MatrixType typ = v1.matrix_type ();
 
   ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (),
                                 v2.complex_matrix_value (), typ,
                                 blas_conj_trans);
 
   v1.matrix_type (typ);
   return ret;
@@ -177,17 +185,18 @@ DEFNDBINOP_FN (el_mul, complex_matrix, c
                complex_array, product)
 DEFNDBINOP_FN (el_div, complex_matrix, complex_matrix, complex_array,
                complex_array, quotient)
 DEFNDBINOP_FN (el_pow, complex_matrix, complex_matrix, complex_array,
                complex_array, elem_xpow)
 
 DEFBINOP (el_ldiv, complex_matrix, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
+  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
 
   return octave_value (quotient (v2.complex_array_value (),
                                  v1.complex_array_value ()));
 }
 
 DEFNDBINOP_FN (el_and, complex_matrix, complex_matrix, complex_array,
                complex_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  complex_matrix, complex_matrix, complex_array,
@@ -204,17 +213,17 @@ DEFNDASSIGNOP_OP (assign_add, complex_ma
 DEFNDASSIGNOP_OP (assign_sub, complex_matrix, complex_matrix, complex_array, -=)
 DEFNDASSIGNOP_FNOP (assign_el_mul, complex_matrix, complex_matrix,
                     complex_array, product_eq)
 DEFNDASSIGNOP_FNOP (assign_el_div, complex_matrix, complex_matrix,
                     complex_array, quotient_eq)
 
 CONVDECL (complex_matrix_to_float_complex_matrix)
 {
-  CAST_CONV_ARG (const octave_complex_matrix&);
+  const octave_complex_matrix& v = dynamic_cast<const octave_complex_matrix&> (a);
 
   return
     new octave_float_complex_matrix
           (FloatComplexNDArray (v.complex_array_value ()));
 }
 
 void
 install_cm_cm_ops (void)
diff --git a/libinterp/operators/op-cm-cs.cc b/libinterp/operators/op-cm-cs.cc
--- a/libinterp/operators/op-cm-cs.cc
+++ b/libinterp/operators/op-cm-cs.cc
@@ -38,31 +38,33 @@ along with Octave; see the file COPYING.
 // complex matrix by complex scalar ops.
 
 DEFNDBINOP_OP (add, complex_matrix, complex, complex_array, complex, +)
 DEFNDBINOP_OP (sub, complex_matrix, complex, complex_array, complex, -)
 DEFNDBINOP_OP (mul, complex_matrix, complex, complex_array, complex, *)
 
 DEFBINOP (div, complex_matrix, complex)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
+  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   Complex d = v2.complex_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v1.complex_array_value () / d);
 }
 
 DEFBINOP_FN (pow, complex_matrix, complex, xpow)
 
 DEFBINOP (ldiv, complex_matrix, complex)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
+  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   ComplexMatrix m1 = v1.complex_matrix_value ();
   ComplexMatrix m2 = v2.complex_matrix_value ();
   MatrixType typ = v1.matrix_type ();
 
   ComplexMatrix ret = xleftdiv (m1, m2, typ);
   v1.matrix_type (typ);
   return ret;
@@ -80,32 +82,34 @@ DEFNDCMPLXCMPOP_FN (gt, complex_matrix, 
                     mx_el_gt)
 DEFNDCMPLXCMPOP_FN (ne, complex_matrix, complex, complex_array, complex,
                     mx_el_ne)
 
 DEFNDBINOP_OP (el_mul, complex_matrix, complex, complex_array, complex, *)
 
 DEFBINOP (el_div, complex_matrix, complex)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
+  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   Complex d = v2.complex_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v1.complex_array_value () / d);
 }
 
 DEFNDBINOP_FN (el_pow, complex_matrix, complex, complex_array, complex,
                elem_xpow)
 
 DEFBINOP (el_ldiv, complex_matrix, complex)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
+  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   return x_el_div (v2.complex_value (), v1.complex_array_value ());
 }
 
 DEFNDBINOP_FN (el_and, complex_matrix, complex, complex_array, complex,
                mx_el_and)
 DEFNDBINOP_FN (el_or,  complex_matrix, complex, complex_array, complex,
                mx_el_or)
diff --git a/libinterp/operators/op-cm-m.cc b/libinterp/operators/op-cm-m.cc
--- a/libinterp/operators/op-cm-m.cc
+++ b/libinterp/operators/op-cm-m.cc
@@ -43,28 +43,30 @@ along with Octave; see the file COPYING.
 
 DEFNDBINOP_OP (add, complex_matrix, matrix, complex_array, array, +)
 DEFNDBINOP_OP (sub, complex_matrix, matrix, complex_array, array, -)
 
 DEFBINOP_OP (mul, complex_matrix, matrix, *)
 
 DEFBINOP (mul_trans, complex_matrix, matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
+  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
 
   ComplexMatrix m1 = v1.complex_matrix_value ();
   Matrix m2 = v2.matrix_value ();
 
   return ComplexMatrix (xgemm (real (m1), m2, blas_no_trans, blas_trans),
                         xgemm (imag (m1), m2, blas_no_trans, blas_trans));
 }
 
 DEFBINOP (div, complex_matrix, matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
+  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
   MatrixType typ = v2.matrix_type ();
 
   ComplexMatrix ret = xdiv (v1.complex_matrix_value (),
                             v2.matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
@@ -72,17 +74,18 @@ DEFBINOP (div, complex_matrix, matrix)
 
 DEFBINOPX (pow, complex_matrix, matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, complex_matrix, matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
+  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
   MatrixType typ = v1.matrix_type ();
 
   ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (),
                                 v2.matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
@@ -95,17 +98,18 @@ DEFNDCMPLXCMPOP_FN (gt, complex_matrix, 
 DEFNDCMPLXCMPOP_FN (ne, complex_matrix, matrix, complex_array, array, mx_el_ne)
 
 DEFNDBINOP_FN (el_mul, complex_matrix, matrix, complex_array, array, product)
 DEFNDBINOP_FN (el_div, complex_matrix, matrix, complex_array, array, quotient)
 DEFNDBINOP_FN (el_pow, complex_matrix, matrix, complex_array, array, elem_xpow)
 
 DEFBINOP (el_ldiv, complex_matrix, matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
+  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
 
   return quotient (v2.array_value (), v1.complex_array_value ());
 }
 
 DEFNDBINOP_FN (el_and, complex_matrix, matrix, complex_array, array, mx_el_and)
 DEFNDBINOP_FN (el_or,  complex_matrix, matrix, complex_array, array, mx_el_or)
 
 DEFNDCATOP_FN (cm_m, complex_matrix, matrix, complex_array, array, concat)
diff --git a/libinterp/operators/op-cm-s.cc b/libinterp/operators/op-cm-s.cc
--- a/libinterp/operators/op-cm-s.cc
+++ b/libinterp/operators/op-cm-s.cc
@@ -41,31 +41,33 @@ along with Octave; see the file COPYING.
 // complex matrix by scalar ops.
 
 DEFNDBINOP_OP (add, complex_matrix, scalar, complex_array, scalar, +)
 DEFNDBINOP_OP (sub, complex_matrix, scalar, complex_array, scalar, -)
 DEFNDBINOP_OP (mul, complex_matrix, scalar, complex_array, scalar, *)
 
 DEFBINOP (div, complex_matrix, scalar)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
+  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   double d = v2.double_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v1.complex_array_value () / d);
 }
 
 DEFBINOP_FN (pow, complex_matrix, scalar, xpow)
 
 DEFBINOP (ldiv, complex_matrix, scalar)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
+  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   ComplexMatrix m1 = v1.complex_matrix_value ();
   Matrix m2 = v2.matrix_value ();
   MatrixType typ = v1.matrix_type ();
 
   ComplexMatrix ret = xleftdiv (m1, m2, typ);
 
   v1.matrix_type (typ);
@@ -78,31 +80,33 @@ DEFNDCMPLXCMPOP_FN (eq, complex_matrix, 
 DEFNDCMPLXCMPOP_FN (ge, complex_matrix, scalar, complex_array, scalar, mx_el_ge)
 DEFNDCMPLXCMPOP_FN (gt, complex_matrix, scalar, complex_array, scalar, mx_el_gt)
 DEFNDCMPLXCMPOP_FN (ne, complex_matrix, scalar, complex_array, scalar, mx_el_ne)
 
 DEFNDBINOP_OP (el_mul, complex_matrix, scalar, complex_array, scalar, *)
 
 DEFBINOP (el_div, complex_matrix, scalar)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
+  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   double d = v2.double_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v1.complex_array_value () / d);
 }
 
 DEFNDBINOP_FN (el_pow, complex_matrix, scalar, complex_array, scalar, elem_xpow)
 
 DEFBINOP (el_ldiv, complex_matrix, scalar)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
+  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   return x_el_div (v2.double_value (), v1.complex_array_value ());
 }
 
 DEFNDBINOP_FN (el_and, complex_matrix, scalar, complex_array, scalar, mx_el_and)
 DEFNDBINOP_FN (el_or,  complex_matrix, scalar, complex_array, scalar, mx_el_or)
 
 DEFNDCATOP_FN (cm_s, complex_matrix, scalar, complex_array, array, concat)
diff --git a/libinterp/operators/op-cm-scm.cc b/libinterp/operators/op-cm-scm.cc
--- a/libinterp/operators/op-cm-scm.cc
+++ b/libinterp/operators/op-cm-scm.cc
@@ -43,18 +43,18 @@ along with Octave; see the file COPYING.
 
 DEFBINOP_OP (add, complex_matrix, sparse_complex_matrix, +)
 DEFBINOP_OP (sub, complex_matrix, sparse_complex_matrix, -)
 
 DEFBINOP_OP (mul, complex_matrix, sparse_complex_matrix, *)
 
 DEFBINOP (div, complex_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&,
-                   const octave_sparse_complex_matrix&);
+  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -74,18 +74,18 @@ DEFBINOP (div, complex_matrix, sparse_co
 
 DEFBINOPX (pow, complex_matrix, sparse_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, complex_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&,
-                   const octave_sparse_complex_matrix&);
+  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
   MatrixType typ = v1.matrix_type ();
 
   ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (),
                                 v2.complex_matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
@@ -100,49 +100,49 @@ DEFBINOP_FN (ge, complex_matrix, sparse_
 DEFBINOP_FN (gt, complex_matrix, sparse_complex_matrix, mx_el_gt)
 DEFBINOP_FN (ne, complex_matrix, sparse_complex_matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, complex_matrix, sparse_complex_matrix, product)
 DEFBINOP_FN (el_div, complex_matrix, sparse_complex_matrix, quotient)
 
 DEFBINOP (el_pow, complex_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&,
-                   const octave_sparse_complex_matrix&);
+  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   return octave_value
          (elem_xpow (SparseComplexMatrix (v1.complex_matrix_value ()),
                      v2.sparse_complex_matrix_value ()));
 }
 
 DEFBINOP (el_ldiv, sparse_complex_matrix, matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&,
-                   const octave_sparse_complex_matrix&);
+  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   return octave_value (quotient (v2.sparse_complex_matrix_value (),
                                  v1.complex_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, complex_matrix, sparse_complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  complex_matrix, sparse_complex_matrix, mx_el_or)
 
 DEFCATOP (cm_scm, complex_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (octave_complex_matrix&,
-                   const octave_sparse_complex_matrix&);
+  octave_complex_matrix& v1 = dynamic_cast<octave_complex_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
   SparseComplexMatrix tmp (v1.complex_matrix_value ());
   return octave_value (tmp. concat (v2.sparse_complex_matrix_value (),
                                     ra_idx));
 }
 
 DEFCONV (sparse_complex_matrix_conv, complex_matrix,
          sparse_complex_matrix)
 {
-  CAST_CONV_ARG (const octave_complex_matrix&);
+  const octave_complex_matrix& v = dynamic_cast<const octave_complex_matrix&> (a);
   return new octave_sparse_complex_matrix
          (SparseComplexMatrix (v.complex_matrix_value ()));
 }
 
 DEFNDASSIGNOP_FN (assign, complex_matrix, sparse_complex_matrix,
                   complex_array, assign)
 
 void
diff --git a/libinterp/operators/op-cm-sm.cc b/libinterp/operators/op-cm-sm.cc
--- a/libinterp/operators/op-cm-sm.cc
+++ b/libinterp/operators/op-cm-sm.cc
@@ -43,17 +43,18 @@ along with Octave; see the file COPYING.
 
 DEFBINOP_OP (add, complex_matrix, sparse_matrix, +)
 DEFBINOP_OP (sub, complex_matrix, sparse_matrix, -)
 
 DEFBINOP_OP (mul, complex_matrix, sparse_matrix, *)
 
 DEFBINOP (div, complex_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_sparse_matrix&);
+  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -73,18 +74,18 @@ DEFBINOP (div, complex_matrix, sparse_ma
 
 DEFBINOPX (pow, complex_matrix, sparse_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, complex_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&,
-                   const octave_sparse_matrix&);
+  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
   MatrixType typ = v1.matrix_type ();
 
   ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (),
                                 v2.matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
@@ -96,38 +97,39 @@ DEFBINOP_FN (ge, complex_matrix, sparse_
 DEFBINOP_FN (gt, complex_matrix, sparse_matrix, mx_el_gt)
 DEFBINOP_FN (ne, complex_matrix, sparse_matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, complex_matrix, sparse_matrix, product)
 DEFBINOP_FN (el_div, complex_matrix, sparse_matrix, quotient)
 
 DEFBINOP (el_pow, complex_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&,
-                   const octave_sparse_matrix&);
+  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   return octave_value
          (elem_xpow (SparseComplexMatrix (v1.complex_matrix_value ()),
                      v2.sparse_matrix_value ()));
 }
 
 DEFBINOP (el_ldiv, complex_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&,
-                   const octave_sparse_matrix&);
+  const octave_complex_matrix& v1 = dynamic_cast<const octave_complex_matrix&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
   return octave_value
          (quotient (v2.sparse_matrix_value (), v1.complex_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, complex_matrix, sparse_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  complex_matrix, sparse_matrix, mx_el_or)
 
 DEFCATOP (cm_sm, complex_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (octave_complex_matrix&, const octave_sparse_matrix&);
+  octave_complex_matrix& v1 = dynamic_cast<octave_complex_matrix&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
   SparseComplexMatrix tmp (v1.complex_matrix_value ());
   return octave_value (tmp. concat (v2.sparse_matrix_value (), ra_idx));
 }
 
 DEFNDASSIGNOP_FN (assign, complex_matrix, sparse_matrix, complex_array, assign)
 
 void
 install_cm_sm_ops (void)
diff --git a/libinterp/operators/op-cs-cm.cc b/libinterp/operators/op-cs-cm.cc
--- a/libinterp/operators/op-cs-cm.cc
+++ b/libinterp/operators/op-cs-cm.cc
@@ -37,33 +37,35 @@ along with Octave; see the file COPYING.
 // complex scalar by complex matrix ops.
 
 DEFNDBINOP_OP (add, complex, complex_matrix, complex, complex_array, +)
 DEFNDBINOP_OP (sub, complex, complex_matrix, complex, complex_array, -)
 DEFNDBINOP_OP (mul, complex, complex_matrix, complex, complex_array, *)
 
 DEFBINOP (div, complex, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
+  const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
+  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
 
   ComplexMatrix m1 = v1.complex_matrix_value ();
   ComplexMatrix m2 = v2.complex_matrix_value ();
   MatrixType typ = v2.matrix_type ();
 
   ComplexMatrix ret = xdiv (m1, m2, typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP_FN (pow, complex, complex_matrix, xpow)
 
 DEFBINOP (ldiv, complex, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
+  const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
+  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
 
   Complex d = v1.complex_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v2.complex_array_value () / d);
 }
@@ -84,17 +86,18 @@ DEFNDCMPLXCMPOP_FN (ne, complex, complex
 DEFNDBINOP_OP (el_mul, complex, complex_matrix, complex, complex_array, *)
 DEFNDBINOP_FN (el_div, complex, complex_matrix, complex, complex_array,
                x_el_div)
 DEFNDBINOP_FN (el_pow, complex, complex_matrix, complex, complex_array,
                elem_xpow)
 
 DEFBINOP (el_ldiv, complex, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
+  const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
+  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
 
   Complex d = v1.complex_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v2.complex_array_value () / d);
 }
@@ -104,17 +107,17 @@ DEFNDBINOP_FN (el_and, complex, complex_
 DEFNDBINOP_FN (el_or,  complex, complex_matrix, complex, complex_array,
                mx_el_or)
 
 DEFNDCATOP_FN (cs_cm, complex, complex_matrix, complex_array, complex_array,
                concat)
 
 DEFCONV (complex_matrix_conv, complex, complex_matrix)
 {
-  CAST_CONV_ARG (const octave_complex&);
+  const octave_complex& v = dynamic_cast<const octave_complex&> (a);
 
   return new octave_complex_matrix (v.complex_matrix_value ());
 }
 
 void
 install_cs_cm_ops (void)
 {
   INSTALL_BINOP (op_add, octave_complex, octave_complex_matrix, add);
diff --git a/libinterp/operators/op-cs-cs.cc b/libinterp/operators/op-cs-cs.cc
--- a/libinterp/operators/op-cs-cs.cc
+++ b/libinterp/operators/op-cs-cs.cc
@@ -37,61 +37,63 @@ along with Octave; see the file COPYING.
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // unary complex scalar ops.
 
 DEFUNOP (not, complex)
 {
-  CAST_UNOP_ARG (const octave_complex&);
+  const octave_complex& v = dynamic_cast<const octave_complex&> (a);
   Complex x = v.complex_value ();
   if (xisnan (x))
     err_nan_to_logical_conversion ();
 
   return octave_value (x == 0.0);
 }
 
 DEFUNOP_OP (uplus, complex, /* no-op */)
 DEFUNOP_OP (uminus, complex, -)
 DEFUNOP_OP (transpose, complex, /* no-op */)
 
 DEFUNOP (hermitian, complex)
 {
-  CAST_UNOP_ARG (const octave_complex&);
+  const octave_complex& v = dynamic_cast<const octave_complex&> (a);
 
   return octave_value (conj (v.complex_value ()));
 }
 
 DEFNCUNOP_METHOD (incr, complex, increment)
 DEFNCUNOP_METHOD (decr, complex, decrement)
 
 // complex scalar by complex scalar ops.
 
 DEFBINOP_OP (add, complex, complex, +)
 DEFBINOP_OP (sub, complex, complex, -)
 DEFBINOP_OP (mul, complex, complex, *)
 
 DEFBINOP (div, complex, complex)
 {
-  CAST_BINOP_ARGS (const octave_complex&, const octave_complex&);
+  const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
+  const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   Complex d = v2.complex_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v1.complex_value () / d);
 }
 
 DEFBINOP_FN (pow, complex, complex, xpow)
 
 DEFBINOP (ldiv, complex, complex)
 {
-  CAST_BINOP_ARGS (const octave_complex&, const octave_complex&);
+  const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
+  const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   Complex d = v1.complex_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v2.complex_value () / d);
 }
@@ -102,59 +104,63 @@ DEFCMPLXCMPOP_OP (eq, complex, complex, 
 DEFCMPLXCMPOP_OP (ge, complex, complex, >=)
 DEFCMPLXCMPOP_OP (gt, complex, complex, >)
 DEFCMPLXCMPOP_OP (ne, complex, complex, !=)
 
 DEFBINOP_OP (el_mul, complex, complex, *)
 
 DEFBINOP (el_div, complex, complex)
 {
-  CAST_BINOP_ARGS (const octave_complex&, const octave_complex&);
+  const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
+  const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   Complex d = v2.complex_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v1.complex_value () / d);
 }
 
 DEFBINOP_FN (el_pow, complex, complex, xpow)
 
 DEFBINOP (el_ldiv, complex, complex)
 {
-  CAST_BINOP_ARGS (const octave_complex&, const octave_complex&);
+  const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
+  const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   Complex d = v1.complex_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v2.complex_value () / d);
 }
 
 DEFBINOP (el_and, complex, complex)
 {
-  CAST_BINOP_ARGS (const octave_complex&, const octave_complex&);
+  const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
+  const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   return v1.complex_value () != 0.0 && v2.complex_value () != 0.0;
 }
 
 DEFBINOP (el_or, complex, complex)
 {
-  CAST_BINOP_ARGS (const octave_complex&, const octave_complex&);
+  const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
+  const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   return v1.complex_value () != 0.0 || v2.complex_value () != 0.0;
 }
 
 DEFNDCATOP_FN (cs_cs, complex, complex, complex_array, complex_array, concat)
 
 CONVDECL (complex_to_float_complex)
 {
-  CAST_CONV_ARG (const octave_complex&);
+  const octave_complex& v = dynamic_cast<const octave_complex&> (a);
 
   return new octave_float_complex_matrix (FloatComplexMatrix (1, 1,
                                           static_cast<FloatComplex>
                                             (v.complex_value ())));
 }
 
 void
 install_cs_cs_ops (void)
diff --git a/libinterp/operators/op-cs-m.cc b/libinterp/operators/op-cs-m.cc
--- a/libinterp/operators/op-cs-m.cc
+++ b/libinterp/operators/op-cs-m.cc
@@ -43,33 +43,35 @@ along with Octave; see the file COPYING.
 // complex scalar by matrix ops.
 
 DEFNDBINOP_OP (add, complex, matrix, complex, array, +)
 DEFNDBINOP_OP (sub, complex, matrix, complex, array, -)
 DEFNDBINOP_OP (mul, complex, matrix, complex, array, *)
 
 DEFBINOP (div, complex, matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
+  const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
+  const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
 
   ComplexMatrix m1 = v1.complex_matrix_value ();
   Matrix m2 = v2.matrix_value ();
   MatrixType typ = v2.matrix_type ();
 
   ComplexMatrix ret = xdiv (m1, m2, typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP_FN (pow, complex, matrix, xpow)
 
 DEFBINOP (ldiv, complex, matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
+  const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
+  const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
 
   Complex d = v1.complex_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v2.array_value () / d);
 }
@@ -82,17 +84,18 @@ DEFNDCMPLXCMPOP_FN (gt, complex, matrix,
 DEFNDCMPLXCMPOP_FN (ne, complex, matrix, complex, array, mx_el_ne)
 
 DEFNDBINOP_OP (el_mul, complex, matrix, complex, array, *)
 DEFNDBINOP_FN (el_div, complex, matrix, complex, array, x_el_div)
 DEFNDBINOP_FN (el_pow, complex, matrix, complex, array, elem_xpow)
 
 DEFBINOP (el_ldiv, complex, matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
+  const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
+  const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
 
   Complex d = v1.complex_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v2.array_value () / d);
 }
diff --git a/libinterp/operators/op-cs-s.cc b/libinterp/operators/op-cs-s.cc
--- a/libinterp/operators/op-cs-s.cc
+++ b/libinterp/operators/op-cs-s.cc
@@ -38,31 +38,33 @@ along with Octave; see the file COPYING.
 // complex scalar by scalar ops.
 
 DEFBINOP_OP (add, complex, scalar, +)
 DEFBINOP_OP (sub, complex, scalar, -)
 DEFBINOP_OP (mul, complex, scalar, *)
 
 DEFBINOP (div, complex, scalar)
 {
-  CAST_BINOP_ARGS (const octave_complex&, const octave_scalar&);
+  const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   double d = v2.double_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v1.complex_value () / d);
 }
 
 DEFBINOP_FN (pow, complex, scalar, xpow)
 
 DEFBINOP (ldiv, complex, scalar)
 {
-  CAST_BINOP_ARGS (const octave_complex&, const octave_scalar&);
+  const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   Complex d = v1.complex_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v2.double_value () / d);
 }
@@ -73,50 +75,54 @@ DEFCMPLXCMPOP_OP (eq, complex, scalar, =
 DEFCMPLXCMPOP_OP (ge, complex, scalar, >=)
 DEFCMPLXCMPOP_OP (gt, complex, scalar, >)
 DEFCMPLXCMPOP_OP (ne, complex, scalar, !=)
 
 DEFBINOP_OP (el_mul, complex, scalar, *)
 
 DEFBINOP (el_div, complex, scalar)
 {
-  CAST_BINOP_ARGS (const octave_complex&, const octave_scalar&);
+  const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   double d = v2.double_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v1.complex_value () / d);
 }
 
 DEFBINOP_FN (el_pow, complex, scalar, xpow)
 
 DEFBINOP (el_ldiv, complex, scalar)
 {
-  CAST_BINOP_ARGS (const octave_complex&, const octave_scalar&);
+  const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   Complex d = v1.complex_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v2.double_value () / d);
 }
 
 DEFBINOP (el_and, complex, scalar)
 {
-  CAST_BINOP_ARGS (const octave_complex&, const octave_scalar&);
+  const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   return v1.complex_value () != 0.0 && v2.double_value ();
 }
 
 DEFBINOP (el_or, complex, scalar)
 {
-  CAST_BINOP_ARGS (const octave_complex&, const octave_scalar&);
+  const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   return v1.complex_value () != 0.0 || v2.double_value ();
 }
 
 DEFNDCATOP_FN (cs_s, complex, scalar, complex_array, array, concat)
 
 void
 install_cs_s_ops (void)
diff --git a/libinterp/operators/op-cs-scm.cc b/libinterp/operators/op-cs-scm.cc
--- a/libinterp/operators/op-cs-scm.cc
+++ b/libinterp/operators/op-cs-scm.cc
@@ -41,17 +41,18 @@ along with Octave; see the file COPYING.
 // complex scalar by sparse complex matrix ops.
 
 DEFBINOP_OP (add, complex, sparse_complex_matrix, +)
 DEFBINOP_OP (sub, complex, sparse_complex_matrix, -)
 DEFBINOP_OP (mul, complex, sparse_complex_matrix, *)
 
 DEFBINOP (div, complex, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex&, const octave_sparse_complex_matrix&);
+  const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
+  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -65,24 +66,25 @@ DEFBINOP (div, complex, sparse_complex_m
       ComplexMatrix ret = xdiv (m1, m2, typ);
       v2.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOP (pow, complex, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex&,
-                   const octave_sparse_complex_matrix&);
+  const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
+  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
   return xpow (v1.complex_value (), v2.complex_matrix_value ());
 }
 
 DEFBINOP (ldiv, complex, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex&, const octave_sparse_complex_matrix&);
+  const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
+  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   Complex d = v1.complex_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v2.sparse_complex_matrix_value () / d);
 }
@@ -96,17 +98,18 @@ DEFBINOP_FN (ne, complex, sparse_complex
 
 DEFBINOP_OP (el_mul, complex, sparse_complex_matrix, *)
 DEFBINOP_FN (el_div, complex, sparse_complex_matrix, x_el_div)
 
 DEFBINOP_FN (el_pow, complex, sparse_complex_matrix, elem_xpow)
 
 DEFBINOP (el_ldiv, complex, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex&, const octave_sparse_complex_matrix&);
+  const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
+  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   Complex d = v1.complex_value ();
   octave_value retval;
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   retval = octave_value (v2.sparse_complex_matrix_value () / d);
@@ -114,25 +117,26 @@ DEFBINOP (el_ldiv, complex, sparse_compl
   return retval;
 }
 
 DEFBINOP_FN (el_and, complex, sparse_complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  complex, sparse_complex_matrix, mx_el_or)
 
 DEFCATOP (cs_scm, complex, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (octave_complex&, const octave_sparse_complex_matrix&);
+  octave_complex& v1 = dynamic_cast<octave_complex&> (a1);
+  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
   SparseComplexMatrix tmp (1, 1, v1.complex_value ());
   return octave_value (tmp. concat (v2.sparse_complex_matrix_value (),
                                     ra_idx));
 }
 
 DEFCONV (sparse_complex_matrix_conv, complex, sparse_complex_matrix)
 {
-  CAST_CONV_ARG (const octave_complex&);
+  const octave_complex& v = dynamic_cast<const octave_complex&> (a);
 
   return new octave_sparse_complex_matrix
          (SparseComplexMatrix (v.complex_matrix_value ()));
 }
 
 void
 install_cs_scm_ops (void)
 {
diff --git a/libinterp/operators/op-cs-sm.cc b/libinterp/operators/op-cs-sm.cc
--- a/libinterp/operators/op-cs-sm.cc
+++ b/libinterp/operators/op-cs-sm.cc
@@ -43,17 +43,18 @@ along with Octave; see the file COPYING.
 // complex by sparse matrix ops.
 
 DEFBINOP_OP (add, complex, sparse_matrix, +)
 DEFBINOP_OP (sub, complex, sparse_matrix, -)
 DEFBINOP_OP (mul, complex, sparse_matrix, *)
 
 DEFBINOP (div, complex, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex&, const octave_sparse_matrix&);
+  const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -67,23 +68,25 @@ DEFBINOP (div, complex, sparse_matrix)
       ComplexMatrix ret = xdiv (m1, m2, typ);
       v2.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOP (pow, complex, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex&, const octave_sparse_matrix&);
+  const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
   return xpow (v1.complex_value (), v2.matrix_value ());
 }
 
 DEFBINOP (ldiv, complex, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex&, const octave_sparse_matrix&);
+  const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   Complex d = v1.complex_value ();
   octave_value retval;
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   retval = octave_value (v2.sparse_matrix_value () / d);
@@ -99,17 +102,18 @@ DEFBINOP_FN (gt, complex, sparse_matrix,
 DEFBINOP_FN (ne, complex, sparse_matrix, mx_el_ne)
 
 DEFBINOP_OP (el_mul, complex, sparse_matrix, *)
 DEFBINOP_FN (el_div, complex, sparse_matrix, x_el_div)
 DEFBINOP_FN (el_pow, complex, sparse_matrix, elem_xpow)
 
 DEFBINOP (el_ldiv, complex, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex&, const octave_sparse_matrix&);
+  const octave_complex& v1 = dynamic_cast<const octave_complex&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   Complex d = v1.complex_value ();
   octave_value retval;
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   retval = octave_value (v2.sparse_matrix_value () / d);
@@ -117,24 +121,25 @@ DEFBINOP (el_ldiv, complex, sparse_matri
   return retval;
 }
 
 DEFBINOP_FN (el_and, complex, sparse_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  complex, sparse_matrix, mx_el_or)
 
 DEFCATOP (cs_sm, sparse_matrix, complex)
 {
-  CAST_BINOP_ARGS (octave_complex&, const octave_sparse_matrix&);
+  octave_complex& v1 = dynamic_cast<octave_complex&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
   SparseComplexMatrix tmp (1, 1, v1.complex_value ());
   return octave_value (tmp. concat (v2.sparse_matrix_value (), ra_idx));
 }
 
 DEFCONV (sparse_matrix_conv, complex, sparse_matrix)
 {
-  CAST_CONV_ARG (const octave_complex&);
+  const octave_complex& v = dynamic_cast<const octave_complex&> (a);
 
   return new octave_sparse_matrix
          (SparseMatrix (v.matrix_value ()));
 }
 
 void
 install_cs_sm_ops (void)
 {
diff --git a/libinterp/operators/op-dm-dm.cc b/libinterp/operators/op-dm-dm.cc
--- a/libinterp/operators/op-dm-dm.cc
+++ b/libinterp/operators/op-dm-dm.cc
@@ -37,52 +37,54 @@ along with Octave; see the file COPYING.
 
 // matrix unary ops.
 
 DEFUNOP_OP (uplus, diag_matrix, /* no-op */)
 DEFUNOP_OP (uminus, diag_matrix, -)
 
 DEFUNOP (transpose, diag_matrix)
 {
-  CAST_UNOP_ARG (const octave_diag_matrix&);
+  const octave_diag_matrix& v = dynamic_cast<const octave_diag_matrix&> (a);
   return octave_value (v.diag_matrix_value ().transpose ());
 }
 
 // matrix by matrix ops.
 
 DEFBINOP_OP (add, diag_matrix, diag_matrix, +)
 DEFBINOP_OP (sub, diag_matrix, diag_matrix, -)
 DEFBINOP_OP (mul, diag_matrix, diag_matrix, *)
 
 DEFBINOP (div, diag_matrix, diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_diag_matrix&, const octave_diag_matrix&);
+  const octave_diag_matrix& v1 = dynamic_cast<const octave_diag_matrix&> (a1);
+  const octave_diag_matrix& v2 = dynamic_cast<const octave_diag_matrix&> (a2);
 
   return xdiv (v1.diag_matrix_value (),
                v2.diag_matrix_value ());
 }
 
 DEFBINOP (ldiv, diag_matrix, diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_diag_matrix&, const octave_diag_matrix&);
+  const octave_diag_matrix& v1 = dynamic_cast<const octave_diag_matrix&> (a1);
+  const octave_diag_matrix& v2 = dynamic_cast<const octave_diag_matrix&> (a2);
 
   return xleftdiv (v1.diag_matrix_value (),
                    v2.diag_matrix_value ());
 }
 
 CONVDECL (diag_matrix_to_matrix)
 {
-  CAST_CONV_ARG (const octave_diag_matrix&);
+  const octave_diag_matrix& v = dynamic_cast<const octave_diag_matrix&> (a);
 
   return new octave_matrix (v.matrix_value ());
 }
 
 CONVDECL (diag_matrix_to_float_diag_matrix)
 {
-  CAST_CONV_ARG (const octave_diag_matrix&);
+  const octave_diag_matrix& v = dynamic_cast<const octave_diag_matrix&> (a);
 
   return new octave_float_diag_matrix (v.float_diag_matrix_value ());
 }
 
 void
 install_dm_dm_ops (void)
 {
   INSTALL_UNOP (op_uplus, octave_diag_matrix, uplus);
diff --git a/libinterp/operators/op-dm-scm.cc b/libinterp/operators/op-dm-scm.cc
--- a/libinterp/operators/op-dm-scm.cc
+++ b/libinterp/operators/op-dm-scm.cc
@@ -45,18 +45,18 @@ along with Octave; see the file COPYING.
 #include "ov-cx-sparse.h"
 
 #include "sparse-xdiv.h"
 
 // diagonal matrix by sparse matrix ops
 
 DEFBINOP (mul_dm_scm, diag_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_diag_matrix&,
-                   const octave_sparse_complex_matrix&);
+  const octave_diag_matrix& v1 = dynamic_cast<const octave_diag_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.diag_matrix_value () * d);
@@ -70,18 +70,18 @@ DEFBINOP (mul_dm_scm, diag_matrix, spars
       typ.mark_as_unsymmetric ();
       out.matrix_type (typ);
       return out;
     }
 }
 
 DEFBINOP (mul_cdm_sm, complex_diag_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_diag_matrix&,
-                   const octave_sparse_matrix&);
+  const octave_complex_diag_matrix& v1 = dynamic_cast<const octave_complex_diag_matrix&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.scalar_value ();
 
       return octave_value (v1.complex_diag_matrix_value () * d);
@@ -95,18 +95,18 @@ DEFBINOP (mul_cdm_sm, complex_diag_matri
       typ.mark_as_unsymmetric ();
       out.matrix_type (typ);
       return out;
     }
 }
 
 DEFBINOP (mul_cdm_scm, complex_diag_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_diag_matrix&,
-                   const octave_sparse_complex_matrix&);
+  const octave_complex_diag_matrix& v1 = dynamic_cast<const octave_complex_diag_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.complex_diag_matrix_value () * d);
@@ -120,134 +120,134 @@ DEFBINOP (mul_cdm_scm, complex_diag_matr
       typ.mark_as_unsymmetric ();
       out.matrix_type (typ);
       return out;
     }
 }
 
 DEFBINOP (ldiv_dm_scm, diag_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_diag_matrix&,
-                   const octave_sparse_complex_matrix&);
+  const octave_diag_matrix& v1 = dynamic_cast<const octave_diag_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   MatrixType typ = v2.matrix_type ();
   return xleftdiv (v1.diag_matrix_value (), v2.sparse_complex_matrix_value (),
                    typ);
 }
 
 DEFBINOP (ldiv_cdm_sm, complex_diag_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_diag_matrix&,
-                   const octave_sparse_matrix&);
+  const octave_complex_diag_matrix& v1 = dynamic_cast<const octave_complex_diag_matrix&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   MatrixType typ = v2.matrix_type ();
   return xleftdiv (v1.complex_diag_matrix_value (), v2.sparse_matrix_value (),
                    typ);
 }
 
 DEFBINOP (ldiv_cdm_scm, complex_diag_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_diag_matrix&,
-                   const octave_sparse_complex_matrix&);
+  const octave_complex_diag_matrix& v1 = dynamic_cast<const octave_complex_diag_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   MatrixType typ = v2.matrix_type ();
   return xleftdiv (v1.complex_diag_matrix_value (),
                    v2.sparse_complex_matrix_value (),
                    typ);
 }
 
 DEFBINOP (add_dm_scm, diag_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_diag_matrix&,
-                   const octave_sparse_complex_matrix&);
+  const octave_diag_matrix& v1 = dynamic_cast<const octave_diag_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.matrix_value () + d);
     }
   else
     return v1.diag_matrix_value () + v2.sparse_complex_matrix_value ();
 }
 
 DEFBINOP (add_cdm_sm, complex_diag_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_diag_matrix&,
-                   const octave_sparse_matrix&);
+  const octave_complex_diag_matrix& v1 = dynamic_cast<const octave_complex_diag_matrix&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v2.scalar_value ();
 
       return octave_value (v1.complex_matrix_value () + d);
     }
   else
     return v1.complex_diag_matrix_value () + v2.sparse_matrix_value ();
 }
 
 DEFBINOP (add_cdm_scm, complex_diag_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_diag_matrix&,
-                   const octave_sparse_complex_matrix&);
+  const octave_complex_diag_matrix& v1 = dynamic_cast<const octave_complex_diag_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.complex_matrix_value () + d);
     }
   else
     return v1.complex_diag_matrix_value () + v2.sparse_complex_matrix_value ();
 }
 
 DEFBINOP (sub_dm_scm, diag_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_diag_matrix&,
-                   const octave_sparse_complex_matrix&);
+  const octave_diag_matrix& v1 = dynamic_cast<const octave_diag_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.matrix_value () + (-d));
     }
   else
     return v1.diag_matrix_value () - v2.sparse_complex_matrix_value ();
 }
 
 DEFBINOP (sub_cdm_sm, complex_diag_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_diag_matrix&,
-                   const octave_sparse_matrix&);
+  const octave_complex_diag_matrix& v1 = dynamic_cast<const octave_complex_diag_matrix&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v2.scalar_value ();
 
       return octave_value (v1.complex_matrix_value () + (-d));
     }
   else
     return v1.complex_diag_matrix_value () - v2.sparse_matrix_value ();
 }
 
 DEFBINOP (sub_cdm_scm, complex_diag_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_diag_matrix&,
-                   const octave_sparse_complex_matrix&);
+  const octave_complex_diag_matrix& v1 = dynamic_cast<const octave_complex_diag_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.complex_matrix_value () + (-d));
@@ -255,18 +255,18 @@ DEFBINOP (sub_cdm_scm, complex_diag_matr
   else
     return v1.complex_diag_matrix_value () - v2.sparse_complex_matrix_value ();
 }
 
 // sparse matrix by diagonal matrix ops
 
 DEFBINOP (mul_scm_dm, sparse_complex_matrix, diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
-                   const octave_diag_matrix&);
+  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_diag_matrix& v2 = dynamic_cast<const octave_diag_matrix&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     // If v1 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v1.complex_value ();
 
       return octave_value (d * v2.diag_matrix_value ());
@@ -280,18 +280,18 @@ DEFBINOP (mul_scm_dm, sparse_complex_mat
       typ.mark_as_unsymmetric ();
       out.matrix_type (typ);
       return out;
     }
 }
 
 DEFBINOP (mul_sm_cdm, sparse_matrix, complex_diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&,
-                   const octave_complex_diag_matrix&);
+  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_complex_diag_matrix& v2 = dynamic_cast<const octave_complex_diag_matrix&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     // If v1 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v1.complex_value ();
 
       return octave_value (d * v2.complex_diag_matrix_value ());
@@ -305,18 +305,18 @@ DEFBINOP (mul_sm_cdm, sparse_matrix, com
       typ.mark_as_unsymmetric ();
       out.matrix_type (typ);
       return out;
     }
 }
 
 DEFBINOP (mul_scm_cdm, sparse_complex_matrix, complex_diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
-                   const octave_complex_diag_matrix&);
+  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_complex_diag_matrix& v2 = dynamic_cast<const octave_complex_diag_matrix&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     // If v1 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v1.complex_value ();
 
       return octave_value (d * v2.complex_diag_matrix_value ());
@@ -337,18 +337,18 @@ DEFBINOP (mul_scm_cdm, sparse_complex_ma
       typ.mark_as_unsymmetric ();
       out.matrix_type (typ);
       return out;
     }
 }
 
 DEFBINOP (div_scm_dm, sparse_complex_matrix, diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
-                   const octave_diag_matrix&);
+  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_diag_matrix& v2 = dynamic_cast<const octave_diag_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -359,18 +359,18 @@ DEFBINOP (div_scm_dm, sparse_complex_mat
       MatrixType typ = v2.matrix_type ();
       return xdiv (v1.sparse_complex_matrix_value (),
                    v2.diag_matrix_value (), typ);
     }
 }
 
 DEFBINOP (div_sm_cdm, sparse_matrix, complex_diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&,
-                   const octave_complex_diag_matrix&);
+  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_complex_diag_matrix& v2 = dynamic_cast<const octave_complex_diag_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       std::complex<double> d = v2.complex_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -381,18 +381,18 @@ DEFBINOP (div_sm_cdm, sparse_matrix, com
       MatrixType typ = v2.matrix_type ();
       return xdiv (v1.sparse_matrix_value (),
                    v2.complex_diag_matrix_value (), typ);
     }
 }
 
 DEFBINOP (div_scm_cdm, sparse_complex_matrix, complex_diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
-                   const octave_complex_diag_matrix&);
+  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_complex_diag_matrix& v2 = dynamic_cast<const octave_complex_diag_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       std::complex<double> d = v2.complex_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -403,103 +403,103 @@ DEFBINOP (div_scm_cdm, sparse_complex_ma
       MatrixType typ = v2.matrix_type ();
       return xdiv (v1.sparse_complex_matrix_value (),
                    v2.complex_diag_matrix_value (), typ);
     }
 }
 
 DEFBINOP (add_sm_cdm, sparse_matrix, complex_diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&,
-                   const octave_complex_diag_matrix&);
+  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_complex_diag_matrix& v2 = dynamic_cast<const octave_complex_diag_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.sparse_matrix_value () + d);
     }
   else
     return v1.sparse_matrix_value () + v2.complex_diag_matrix_value ();
 }
 
 DEFBINOP (add_scm_dm, sparse_complex_matrix, diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
-                   const octave_diag_matrix&);
+  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_diag_matrix& v2 = dynamic_cast<const octave_diag_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v2.scalar_value ();
 
       return octave_value (v1.sparse_complex_matrix_value () + d);
     }
   else
     return v1.sparse_complex_matrix_value () + v2.diag_matrix_value ();
 }
 
 DEFBINOP (add_scm_cdm, sparse_complex_matrix, complex_diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
-                   const octave_complex_diag_matrix&);
+  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_complex_diag_matrix& v2 = dynamic_cast<const octave_complex_diag_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.sparse_complex_matrix_value () + d);
     }
   else
     return v1.sparse_complex_matrix_value () + v2.complex_diag_matrix_value ();
 }
 
 DEFBINOP (sub_sm_cdm, sparse_matrix, complex_diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&,
-                   const octave_complex_diag_matrix&);
+  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_complex_diag_matrix& v2 = dynamic_cast<const octave_complex_diag_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.sparse_matrix_value () + (-d));
     }
   else
     return v1.sparse_matrix_value () - v2.complex_diag_matrix_value ();
 }
 
 DEFBINOP (sub_scm_dm, sparse_complex_matrix, diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
-                   const octave_diag_matrix&);
+  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_diag_matrix& v2 = dynamic_cast<const octave_diag_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v2.scalar_value ();
 
       return octave_value (v1.sparse_complex_matrix_value () + (-d));
     }
   else
     return v1.sparse_complex_matrix_value () - v2.diag_matrix_value ();
 }
 
 DEFBINOP (sub_scm_cdm, sparse_complex_matrix, complex_diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
-                   const octave_complex_diag_matrix&);
+  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_complex_diag_matrix& v2 = dynamic_cast<const octave_complex_diag_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.sparse_complex_matrix_value () + (-d));
diff --git a/libinterp/operators/op-dm-sm.cc b/libinterp/operators/op-dm-sm.cc
--- a/libinterp/operators/op-dm-sm.cc
+++ b/libinterp/operators/op-dm-sm.cc
@@ -34,17 +34,18 @@ along with Octave; see the file COPYING.
 #include "ov-re-sparse.h"
 
 #include "sparse-xdiv.h"
 
 // diagonal matrix by sparse matrix ops
 
 DEFBINOP (mul_dm_sm, diag_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_diag_matrix&, const octave_sparse_matrix&);
+  const octave_diag_matrix& v1 = dynamic_cast<const octave_diag_matrix&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v2.scalar_value ();
 
       return octave_value (v1.diag_matrix_value () * d);
@@ -57,41 +58,44 @@ DEFBINOP (mul_dm_sm, diag_matrix, sparse
       typ.mark_as_unsymmetric ();
       out.matrix_type (typ);
       return out;
     }
 }
 
 DEFBINOP (ldiv_dm_sm, diag_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_diag_matrix&, const octave_sparse_matrix&);
+  const octave_diag_matrix& v1 = dynamic_cast<const octave_diag_matrix&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   MatrixType typ = v2.matrix_type ();
   return xleftdiv (v1.diag_matrix_value (), v2.sparse_matrix_value (), typ);
 }
 
 DEFBINOP (add_dm_sm, diag_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_diag_matrix&, const octave_sparse_matrix&);
+  const octave_diag_matrix& v1 = dynamic_cast<const octave_diag_matrix&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v2.scalar_value ();
 
       return octave_value (v1.matrix_value () + d);
     }
   else
     return v1.diag_matrix_value () + v2.sparse_matrix_value ();
 }
 
 DEFBINOP (sub_dm_sm, diag_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_diag_matrix&, const octave_sparse_matrix&);
+  const octave_diag_matrix& v1 = dynamic_cast<const octave_diag_matrix&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v2.scalar_value ();
 
       return octave_value (v1.matrix_value () - d);
@@ -99,17 +103,18 @@ DEFBINOP (sub_dm_sm, diag_matrix, sparse
   else
     return v1.diag_matrix_value () - v2.sparse_matrix_value ();
 }
 
 // sparse matrix by diagonal matrix ops
 
 DEFBINOP (mul_sm_dm, sparse_matrix, diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_diag_matrix&);
+  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_diag_matrix& v2 = dynamic_cast<const octave_diag_matrix&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     // If v1 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v1.scalar_value ();
 
       return octave_value (d * v2.diag_matrix_value ());
@@ -122,17 +127,18 @@ DEFBINOP (mul_sm_dm, sparse_matrix, diag
       typ.mark_as_unsymmetric ();
       out.matrix_type (typ);
       return out;
     }
 }
 
 DEFBINOP (div_sm_dm, sparse_matrix, diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_diag_matrix&);
+  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_diag_matrix& v2 = dynamic_cast<const octave_diag_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -142,33 +148,35 @@ DEFBINOP (div_sm_dm, sparse_matrix, diag
     {
       MatrixType typ = v2.matrix_type ();
       return xdiv (v1.sparse_matrix_value (), v2.diag_matrix_value (), typ);
     }
 }
 
 DEFBINOP (add_sm_dm, sparse_matrix, diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_diag_matrix&);
+  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_diag_matrix& v2 = dynamic_cast<const octave_diag_matrix&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     // If v1 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v1.scalar_value ();
 
       return octave_value (d + v2.matrix_value ());
     }
   else
     return v1.sparse_matrix_value () + v2.diag_matrix_value ();
 }
 
 DEFBINOP (sub_sm_dm, sparse_matrix, diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_diag_matrix&);
+  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_diag_matrix& v2 = dynamic_cast<const octave_diag_matrix&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     // If v1 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v1.scalar_value ();
 
       return octave_value (d - v2.matrix_value ());
diff --git a/libinterp/operators/op-dm-template.cc b/libinterp/operators/op-dm-template.cc
--- a/libinterp/operators/op-dm-template.cc
+++ b/libinterp/operators/op-dm-template.cc
@@ -56,26 +56,28 @@ DEFBINOP_OP (mul, LMATRIX, RMATRIX, *)
 #define LMATRIX_VALUE CONCAT2(LMATRIX, _value)
 #define RMATRIX_VALUE CONCAT2(RMATRIX, _value)
 #define LDMATRIX_VALUE CONCAT2(LDMATRIX, _value)
 #define RDMATRIX_VALUE CONCAT2(RDMATRIX, _value)
 
 #ifdef DEFINEDIV
 DEFBINOP (div, LMATRIX, RMATRIX)
 {
-  CAST_BINOP_ARGS (const OCTAVE_LMATRIX&, const OCTAVE_RMATRIX&);
+  const OCTAVE_LMATRIX& v1 = dynamic_cast<const OCTAVE_LMATRIX&> (a1);
+  const OCTAVE_RMATRIX& v2 = dynamic_cast<const OCTAVE_RMATRIX&> (a2);
 
   return xdiv (v1.LDMATRIX_VALUE (), v2.RMATRIX_VALUE ());
 }
 #endif
 
 #ifdef DEFINELDIV
 DEFBINOP (ldiv, LMATRIX, RMATRIX)
 {
-  CAST_BINOP_ARGS (const OCTAVE_LMATRIX&, const OCTAVE_RMATRIX&);
+  const OCTAVE_LMATRIX& v1 = dynamic_cast<const OCTAVE_LMATRIX&> (a1);
+  const OCTAVE_RMATRIX& v2 = dynamic_cast<const OCTAVE_RMATRIX&> (a2);
 
   return xleftdiv (v1.LMATRIX_VALUE (), v2.RDMATRIX_VALUE ());
 }
 #endif
 
 #define SHORT_NAME CONCAT3(LSHORT, _, RSHORT)
 #define INST_NAME CONCAT3(install_, SHORT_NAME, _ops)
 
diff --git a/libinterp/operators/op-dms-template.cc b/libinterp/operators/op-dms-template.cc
--- a/libinterp/operators/op-dms-template.cc
+++ b/libinterp/operators/op-dms-template.cc
@@ -55,31 +55,34 @@ gripe_if_zero (T x)
   if (x == T ())
     warn_divide_by_zero ();
 
   return x;
 }
 
 DEFBINOP (dmsdiv, MATRIX, SCALAR)
 {
-  CAST_BINOP_ARGS (const OCTAVE_MATRIX&, const OCTAVE_SCALAR&);
+  const OCTAVE_MATRIX& v1 = dynamic_cast<const OCTAVE_MATRIX&> (a1);
+  const OCTAVE_SCALAR& v2 = dynamic_cast<const OCTAVE_SCALAR&> (a2);
 
   return v1.MATRIX_VALUE () / gripe_if_zero (v2.SCALAR_VALUE ());
 }
 
 DEFBINOP (sdmldiv, SCALAR, MATRIX)
 {
-  CAST_BINOP_ARGS (const OCTAVE_SCALAR&, const OCTAVE_MATRIX&);
+  const OCTAVE_SCALAR& v1 = dynamic_cast<const OCTAVE_SCALAR&> (a1);
+  const OCTAVE_MATRIX& v2 = dynamic_cast<const OCTAVE_MATRIX&> (a2);
 
   return v2.MATRIX_VALUE () / gripe_if_zero (v1.SCALAR_VALUE ());
 }
 
 DEFBINOP (dmspow, MATRIX, SCALAR)
 {
-  CAST_BINOP_ARGS (const OCTAVE_MATRIX&, const OCTAVE_SCALAR&);
+  const OCTAVE_MATRIX& v1 = dynamic_cast<const OCTAVE_MATRIX&> (a1);
+  const OCTAVE_SCALAR& v2 = dynamic_cast<const OCTAVE_SCALAR&> (a2);
 
   return xpow (v1.MATRIX_VALUE (), v2.SCALAR_VALUE ());
 }
 
 #define SHORT_NAME CONCAT3(MSHORT, _, SSHORT)
 #define INST_NAME CONCAT3(install_, SHORT_NAME, _ops)
 
 void
diff --git a/libinterp/operators/op-fcdm-fcdm.cc b/libinterp/operators/op-fcdm-fcdm.cc
--- a/libinterp/operators/op-fcdm-fcdm.cc
+++ b/libinterp/operators/op-fcdm-fcdm.cc
@@ -37,60 +37,60 @@ along with Octave; see the file COPYING.
 
 // matrix unary ops.
 
 DEFUNOP_OP (uplus, float_complex_diag_matrix, /* no-op */)
 DEFUNOP_OP (uminus, float_complex_diag_matrix, -)
 
 DEFUNOP (transpose, float_complex_diag_matrix)
 {
-  CAST_UNOP_ARG (const octave_float_complex_diag_matrix&);
+  const octave_float_complex_diag_matrix& v = dynamic_cast<const octave_float_complex_diag_matrix&> (a);
   return octave_value (v.float_complex_diag_matrix_value ().transpose ());
 }
 
 DEFUNOP (hermitian, float_complex_diag_matrix)
 {
-  CAST_UNOP_ARG (const octave_float_complex_diag_matrix&);
+  const octave_float_complex_diag_matrix& v = dynamic_cast<const octave_float_complex_diag_matrix&> (a);
   return octave_value (v.float_complex_diag_matrix_value ().hermitian ());
 }
 
 // matrix by matrix ops.
 
 DEFBINOP_OP (add, float_complex_diag_matrix, float_complex_diag_matrix, +)
 DEFBINOP_OP (sub, float_complex_diag_matrix, float_complex_diag_matrix, -)
 DEFBINOP_OP (mul, float_complex_diag_matrix, float_complex_diag_matrix, *)
 
 DEFBINOP (div, float_complex_diag_matrix, float_complex_diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_diag_matrix&,
-                   const octave_float_complex_diag_matrix&);
+  const octave_float_complex_diag_matrix& v1 = dynamic_cast<const octave_float_complex_diag_matrix&> (a1);
+  const octave_float_complex_diag_matrix& v2 = dynamic_cast<const octave_float_complex_diag_matrix&> (a2);
 
   return xdiv (v1.float_complex_diag_matrix_value (),
                v2.float_complex_diag_matrix_value ());
 }
 
 DEFBINOP (ldiv, float_complex_diag_matrix, float_complex_diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_diag_matrix&,
-                   const octave_float_complex_diag_matrix&);
+  const octave_float_complex_diag_matrix& v1 = dynamic_cast<const octave_float_complex_diag_matrix&> (a1);
+  const octave_float_complex_diag_matrix& v2 = dynamic_cast<const octave_float_complex_diag_matrix&> (a2);
 
   return xleftdiv (v1.float_complex_diag_matrix_value (),
                    v2.float_complex_diag_matrix_value ());
 }
 
 CONVDECL (float_complex_diag_matrix_to_float_complex_matrix)
 {
-  CAST_CONV_ARG (const octave_float_complex_diag_matrix&);
+  const octave_float_complex_diag_matrix& v = dynamic_cast<const octave_float_complex_diag_matrix&> (a);
 
   return new octave_float_complex_matrix (v.float_complex_matrix_value ());
 }
 
 CONVDECL (float_complex_diag_matrix_to_complex_diag_matrix)
 {
-  CAST_CONV_ARG (const octave_float_complex_diag_matrix&);
+  const octave_float_complex_diag_matrix& v = dynamic_cast<const octave_float_complex_diag_matrix&> (a);
 
   return new octave_complex_diag_matrix (v.complex_diag_matrix_value ());
 }
 
 void
 install_fcdm_fcdm_ops (void)
 {
   INSTALL_UNOP (op_uplus, octave_float_complex_diag_matrix, uplus);
diff --git a/libinterp/operators/op-fcm-fcm.cc b/libinterp/operators/op-fcm-fcm.cc
--- a/libinterp/operators/op-fcm-fcm.cc
+++ b/libinterp/operators/op-fcm-fcm.cc
@@ -38,27 +38,27 @@ along with Octave; see the file COPYING.
 // unary complex matrix ops.
 
 DEFNDUNOP_OP (not, float_complex_matrix, float_complex_array, !)
 DEFNDUNOP_OP (uplus, float_complex_matrix, float_complex_array, /* no-op */)
 DEFNDUNOP_OP (uminus, float_complex_matrix, float_complex_array, -)
 
 DEFUNOP (transpose, float_complex_matrix)
 {
-  CAST_UNOP_ARG (const octave_float_complex_matrix&);
+  const octave_float_complex_matrix& v = dynamic_cast<const octave_float_complex_matrix&> (a);
 
   if (v.ndims () > 2)
     error ("transpose not defined for N-D objects");
 
   return octave_value (v.float_complex_matrix_value ().transpose ());
 }
 
 DEFUNOP (hermitian, float_complex_matrix)
 {
-  CAST_UNOP_ARG (const octave_float_complex_matrix&);
+  const octave_float_complex_matrix& v = dynamic_cast<const octave_float_complex_matrix&> (a);
 
   if (v.ndims () > 2)
     error ("complex-conjugate transpose not defined for N-D objects");
 
   return octave_value (v.float_complex_matrix_value ().hermitian ());
 }
 
 DEFNCUNOP_METHOD (incr, float_complex_matrix, increment)
@@ -71,99 +71,99 @@ DEFNDBINOP_OP (add, float_complex_matrix
                float_complex_array, float_complex_array, +)
 DEFNDBINOP_OP (sub, float_complex_matrix, float_complex_matrix,
                float_complex_array, float_complex_array, -)
 
 DEFBINOP_OP (mul, float_complex_matrix, float_complex_matrix, *)
 
 DEFBINOP (div, float_complex_matrix, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
-                   const octave_float_complex_matrix&);
+  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
   MatrixType typ = v2.matrix_type ();
 
   FloatComplexMatrix ret = xdiv (v1.float_complex_matrix_value (),
                                  v2.float_complex_matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, float_complex_matrix, float_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, float_complex_matrix, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
-                   const octave_float_complex_matrix&);
+  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
   MatrixType typ = v1.matrix_type ();
 
   FloatComplexMatrix ret = xleftdiv (v1.float_complex_matrix_value (),
                                      v2.float_complex_matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP (trans_mul, float_complex_matrix, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
-                   const octave_float_complex_matrix&);
+  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
   return octave_value(xgemm (v1.float_complex_matrix_value (),
                              v2.float_complex_matrix_value (),
                              blas_trans, blas_no_trans));
 }
 
 DEFBINOP (mul_trans, float_complex_matrix, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
-                   const octave_float_complex_matrix&);
+  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
   return octave_value(xgemm (v1.float_complex_matrix_value (),
                              v2.float_complex_matrix_value (),
                              blas_no_trans, blas_trans));
 }
 
 DEFBINOP (herm_mul, float_complex_matrix, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
-                   const octave_float_complex_matrix&);
+  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
   return octave_value(xgemm (v1.float_complex_matrix_value (),
                              v2.float_complex_matrix_value (),
                              blas_conj_trans, blas_no_trans));
 }
 
 DEFBINOP (mul_herm, float_complex_matrix, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
-                   const octave_float_complex_matrix&);
+  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
   return octave_value(xgemm (v1.float_complex_matrix_value (),
                              v2.float_complex_matrix_value (),
                              blas_no_trans, blas_conj_trans));
 }
 
 DEFBINOP (trans_ldiv, float_complex_matrix, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
-                   const octave_float_complex_matrix&);
+  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
   MatrixType typ = v1.matrix_type ();
 
   FloatComplexMatrix ret = xleftdiv (v1.float_complex_matrix_value (),
                                      v2.float_complex_matrix_value (),
                                      typ, blas_trans);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP (herm_ldiv, float_complex_matrix, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
-                   const octave_float_complex_matrix&);
+  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
   MatrixType typ = v1.matrix_type ();
 
   FloatComplexMatrix ret = xleftdiv (v1.float_complex_matrix_value (),
                                      v2.float_complex_matrix_value (),
                                      typ, blas_conj_trans);
 
   v1.matrix_type (typ);
   return ret;
@@ -186,18 +186,18 @@ DEFNDBINOP_FN (el_mul, float_complex_mat
                float_complex_array, float_complex_array, product)
 DEFNDBINOP_FN (el_div, float_complex_matrix, float_complex_matrix,
                float_complex_array, float_complex_array, quotient)
 DEFNDBINOP_FN (el_pow, float_complex_matrix, float_complex_matrix,
                float_complex_array, float_complex_array, elem_xpow)
 
 DEFBINOP (el_ldiv, float_complex_matrix, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
-                   const octave_float_complex_matrix&);
+  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
 
   return octave_value (quotient (v2.float_complex_array_value (),
                                  v1.float_complex_array_value ()));
 }
 
 DEFNDBINOP_FN (el_and, float_complex_matrix, float_complex_matrix,
                float_complex_array, float_complex_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_complex_matrix, float_complex_matrix,
@@ -229,17 +229,17 @@ DEFNDASSIGNOP_OP (assign_sub, float_comp
                   float_complex_matrix, float_complex_array, -=)
 DEFNDASSIGNOP_FNOP (assign_el_mul, float_complex_matrix, float_complex_matrix,
                     float_complex_array, product_eq)
 DEFNDASSIGNOP_FNOP (assign_el_div, float_complex_matrix, float_complex_matrix,
                     float_complex_array, quotient_eq)
 
 CONVDECL (float_complex_matrix_to_complex_matrix)
 {
-  CAST_CONV_ARG (const octave_float_complex_matrix&);
+  const octave_float_complex_matrix& v = dynamic_cast<const octave_float_complex_matrix&> (a);
 
   return
     new octave_complex_matrix (ComplexNDArray (v.float_complex_array_value ()));
 }
 
 void
 install_fcm_fcm_ops (void)
 {
diff --git a/libinterp/operators/op-fcm-fcs.cc b/libinterp/operators/op-fcm-fcs.cc
--- a/libinterp/operators/op-fcm-fcs.cc
+++ b/libinterp/operators/op-fcm-fcs.cc
@@ -42,33 +42,33 @@ DEFNDBINOP_OP (add, float_complex_matrix
                float_complex_array, float_complex, +)
 DEFNDBINOP_OP (sub, float_complex_matrix, float_complex,
                float_complex_array, float_complex, -)
 DEFNDBINOP_OP (mul, float_complex_matrix, float_complex,
                float_complex_array, float_complex, *)
 
 DEFBINOP (div, float_complex_matrix, float_complex)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
-                   const octave_float_complex&);
+  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
 
   FloatComplex d = v2.float_complex_value ();
 
   if (d == 0.0f)
     warn_divide_by_zero ();
 
   return octave_value (v1.float_complex_array_value () / d);
 }
 
 DEFBINOP_FN (pow, float_complex_matrix, float_complex, xpow)
 
 DEFBINOP (ldiv, float_complex_matrix, float_complex)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
-                   const octave_float_complex&);
+  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
 
   FloatComplexMatrix m1 = v1.float_complex_matrix_value ();
   FloatComplexMatrix m2 = v2.float_complex_matrix_value ();
   MatrixType typ = v1.matrix_type ();
 
   FloatComplexMatrix ret = xleftdiv (m1, m2, typ);
   v1.matrix_type (typ);
   return ret;
@@ -87,34 +87,34 @@ DEFNDCMPLXCMPOP_FN (gt, float_complex_ma
 DEFNDCMPLXCMPOP_FN (ne, float_complex_matrix, float_complex,
                     float_complex_array, float_complex, mx_el_ne)
 
 DEFNDBINOP_OP (el_mul, float_complex_matrix, float_complex,
                float_complex_array, float_complex, *)
 
 DEFBINOP (el_div, float_complex_matrix, float_complex)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
-                   const octave_float_complex&);
+  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
 
   FloatComplex d = v2.float_complex_value ();
 
   if (d == 0.0f)
     warn_divide_by_zero ();
 
   return octave_value (v1.float_complex_array_value () / d);
 }
 
 DEFNDBINOP_FN (el_pow, float_complex_matrix, float_complex,
                float_complex_array, float_complex, elem_xpow)
 
 DEFBINOP (el_ldiv, float_complex_matrix, float_complex)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
-                   const octave_float_complex&);
+  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
 
   return x_el_div (v2.float_complex_value (), v1.float_complex_array_value ());
 }
 
 DEFNDBINOP_FN (el_and, float_complex_matrix, float_complex,
                float_complex_array, float_complex, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_complex_matrix, float_complex,
                float_complex_array, float_complex, mx_el_or)
diff --git a/libinterp/operators/op-fcm-fm.cc b/libinterp/operators/op-fcm-fm.cc
--- a/libinterp/operators/op-fcm-fm.cc
+++ b/libinterp/operators/op-fcm-fm.cc
@@ -47,30 +47,30 @@ DEFNDBINOP_OP (add, float_complex_matrix
                float_array, +)
 DEFNDBINOP_OP (sub, float_complex_matrix, float_matrix, float_complex_array,
                float_array, -)
 
 DEFBINOP_OP (mul, float_complex_matrix, float_matrix, *)
 
 DEFBINOP (mul_trans, float_complex_matrix, float_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
-                   const octave_float_matrix&);
+  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_matrix& v2 = dynamic_cast<const octave_float_matrix&> (a2);
 
   FloatComplexMatrix m1 = v1.float_complex_matrix_value ();
   FloatMatrix m2 = v2.float_matrix_value ();
 
   return FloatComplexMatrix (xgemm (real (m1), m2, blas_no_trans, blas_trans),
                              xgemm (imag (m1), m2, blas_no_trans, blas_trans));
 }
 
 DEFBINOP (div, float_complex_matrix, float_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
-                   const octave_float_matrix&);
+  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_matrix& v2 = dynamic_cast<const octave_float_matrix&> (a2);
   MatrixType typ = v2.matrix_type ();
 
   FloatComplexMatrix ret = xdiv (v1.float_complex_matrix_value (),
                                  v2.float_matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
@@ -78,18 +78,18 @@ DEFBINOP (div, float_complex_matrix, flo
 
 DEFBINOPX (pow, float_complex_matrix, float_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, float_complex_matrix, float_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
-                   const octave_float_matrix&);
+  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_matrix& v2 = dynamic_cast<const octave_float_matrix&> (a2);
   MatrixType typ = v1.matrix_type ();
 
   FloatComplexMatrix ret = xleftdiv (v1.float_complex_matrix_value (),
                                      v2.float_matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
@@ -111,18 +111,18 @@ DEFNDBINOP_FN (el_mul, float_complex_mat
                float_complex_array, float_array, product)
 DEFNDBINOP_FN (el_div, float_complex_matrix, float_matrix,
                float_complex_array, float_array, quotient)
 DEFNDBINOP_FN (el_pow, float_complex_matrix, float_matrix,
                float_complex_array, float_array, elem_xpow)
 
 DEFBINOP (el_ldiv, float_complex_matrix, float_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
-                   const octave_float_matrix&);
+  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_matrix& v2 = dynamic_cast<const octave_float_matrix&> (a2);
 
   return quotient (v2.float_array_value (), v1.float_complex_array_value ());
 }
 
 DEFNDBINOP_FN (el_and, float_complex_matrix, float_matrix,
                float_complex_array, float_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_complex_matrix, float_matrix,
                float_complex_array, float_array, mx_el_or)
diff --git a/libinterp/operators/op-fcm-fs.cc b/libinterp/operators/op-fcm-fs.cc
--- a/libinterp/operators/op-fcm-fs.cc
+++ b/libinterp/operators/op-fcm-fs.cc
@@ -45,33 +45,33 @@ DEFNDBINOP_OP (add, float_complex_matrix
                float_scalar, +)
 DEFNDBINOP_OP (sub, float_complex_matrix, float_scalar, float_complex_array,
                float_scalar, -)
 DEFNDBINOP_OP (mul, float_complex_matrix, float_scalar, float_complex_array,
                float_scalar, *)
 
 DEFBINOP (div, float_complex_matrix, float)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
-                   const octave_float_scalar&);
+  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_scalar& v2 = dynamic_cast<const octave_float_scalar&> (a2);
 
   float d = v2.float_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v1.float_complex_array_value () / d);
 }
 
 DEFBINOP_FN (pow, float_complex_matrix, float_scalar, xpow)
 
 DEFBINOP (ldiv, float_complex_matrix, float)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
-                   const octave_float_scalar&);
+  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_scalar& v2 = dynamic_cast<const octave_float_scalar&> (a2);
 
   FloatComplexMatrix m1 = v1.float_complex_matrix_value ();
   FloatMatrix m2 = v2.float_matrix_value ();
   MatrixType typ = v1.matrix_type ();
 
   FloatComplexMatrix ret = xleftdiv (m1, m2, typ);
 
   v1.matrix_type (typ);
@@ -91,34 +91,34 @@ DEFNDCMPLXCMPOP_FN (gt, float_complex_ma
 DEFNDCMPLXCMPOP_FN (ne, float_complex_matrix, float_scalar, float_complex_array,
                     float_scalar, mx_el_ne)
 
 DEFNDBINOP_OP (el_mul, float_complex_matrix, float_scalar, float_complex_array,
                float_scalar, *)
 
 DEFBINOP (el_div, float_complex_matrix, float)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
-                   const octave_float_scalar&);
+  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_scalar& v2 = dynamic_cast<const octave_float_scalar&> (a2);
 
   float d = v2.float_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v1.float_complex_array_value () / d);
 }
 
 DEFNDBINOP_FN (el_pow, float_complex_matrix, float_scalar, float_complex_array,
                float_scalar, elem_xpow)
 
 DEFBINOP (el_ldiv, float_complex_matrix, float)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
-                   const octave_float_scalar&);
+  const octave_float_complex_matrix& v1 = dynamic_cast<const octave_float_complex_matrix&> (a1);
+  const octave_float_scalar& v2 = dynamic_cast<const octave_float_scalar&> (a2);
 
   return x_el_div (v2.float_value (), v1.float_complex_array_value ());
 }
 
 DEFNDBINOP_FN (el_and, float_complex_matrix, float_scalar, float_complex_array,
                float_scalar, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_complex_matrix, float_scalar, float_complex_array,
                float_scalar, mx_el_or)
diff --git a/libinterp/operators/op-fcn.cc b/libinterp/operators/op-fcn.cc
--- a/libinterp/operators/op-fcn.cc
+++ b/libinterp/operators/op-fcn.cc
@@ -29,24 +29,26 @@ along with Octave; see the file COPYING.
 #include "ov.h"
 #include "ov-fcn-handle.h"
 #include "ov-scalar.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 
 DEFBINOP (eq, fcn_handle, fcn_handle)
 {
-  CAST_BINOP_ARGS (const octave_fcn_handle&, const octave_fcn_handle&);
+  const octave_fcn_handle& v1 = dynamic_cast<const octave_fcn_handle&> (a1);
+  const octave_fcn_handle& v2 = dynamic_cast<const octave_fcn_handle&> (a2);
 
   return v1.is_equal_to (v2);
 }
 
 DEFBINOP (ne, fcn_handle, fcn_handle)
 {
-  CAST_BINOP_ARGS (const octave_fcn_handle&, const octave_fcn_handle&);
+  const octave_fcn_handle& v1 = dynamic_cast<const octave_fcn_handle&> (a1);
+  const octave_fcn_handle& v2 = dynamic_cast<const octave_fcn_handle&> (a2);
 
   return ! v1.is_equal_to (v2);
 }
 
 void
 install_fcn_ops (void)
 {
   INSTALL_BINOP (op_eq, octave_fcn_handle, octave_fcn_handle, eq);
diff --git a/libinterp/operators/op-fcs-fcm.cc b/libinterp/operators/op-fcs-fcm.cc
--- a/libinterp/operators/op-fcs-fcm.cc
+++ b/libinterp/operators/op-fcs-fcm.cc
@@ -42,35 +42,35 @@ DEFNDBINOP_OP (add, float_complex, float
                float_complex_array, +)
 DEFNDBINOP_OP (sub, float_complex, float_complex_matrix, float_complex,
                float_complex_array, -)
 DEFNDBINOP_OP (mul, float_complex, float_complex_matrix, float_complex,
                float_complex_array, *)
 
 DEFBINOP (div, float_complex, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex&,
-                   const octave_float_complex_matrix&);
+  const octave_float_complex& v1 = dynamic_cast<const octave_float_complex&> (a1);
+  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
 
   FloatComplexMatrix m1 = v1.float_complex_matrix_value ();
   FloatComplexMatrix m2 = v2.float_complex_matrix_value ();
   MatrixType typ = v2.matrix_type ();
 
   FloatComplexMatrix ret = xdiv (m1, m2, typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP_FN (pow, float_complex, float_complex_matrix, xpow)
 
 DEFBINOP (ldiv, float_complex, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex&,
-                   const octave_float_complex_matrix&);
+  const octave_float_complex& v1 = dynamic_cast<const octave_float_complex&> (a1);
+  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
 
   FloatComplex d = v1.float_complex_value ();
 
   if (d == 0.0f)
     warn_divide_by_zero ();
 
   return octave_value (v2.float_complex_array_value () / d);
 }
@@ -92,18 +92,18 @@ DEFNDBINOP_OP (el_mul, float_complex, fl
                float_complex_array, *)
 DEFNDBINOP_FN (el_div, float_complex, float_complex_matrix, float_complex,
                float_complex_array, x_el_div)
 DEFNDBINOP_FN (el_pow, float_complex, float_complex_matrix, float_complex,
                float_complex_array, elem_xpow)
 
 DEFBINOP (el_ldiv, float_complex, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex&,
-                   const octave_float_complex_matrix&);
+  const octave_float_complex& v1 = dynamic_cast<const octave_float_complex&> (a1);
+  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
 
   FloatComplex d = v1.float_complex_value ();
 
   if (d == 0.0f)
     warn_divide_by_zero ();
 
   return octave_value (v2.float_complex_array_value () / d);
 }
@@ -119,17 +119,17 @@ DEFNDCATOP_FN (fcs_fcm, float_complex, f
 DEFNDCATOP_FN (cs_fcm, complex, float_complex_matrix, float_complex_array,
                float_complex_array, concat)
 
 DEFNDCATOP_FN (fcs_cm, float_complex, complex_matrix, float_complex_array,
                float_complex_array, concat)
 
 DEFCONV (float_complex_matrix_conv, float_complex, float_complex_matrix)
 {
-  CAST_CONV_ARG (const octave_float_complex&);
+  const octave_float_complex& v = dynamic_cast<const octave_float_complex&> (a);
 
   return new octave_float_complex_matrix (v.float_complex_matrix_value ());
 }
 
 void
 install_fcs_fcm_ops (void)
 {
   INSTALL_BINOP (op_add, octave_float_complex, octave_float_complex_matrix,
diff --git a/libinterp/operators/op-fcs-fcs.cc b/libinterp/operators/op-fcs-fcs.cc
--- a/libinterp/operators/op-fcs-fcs.cc
+++ b/libinterp/operators/op-fcs-fcs.cc
@@ -35,61 +35,63 @@ along with Octave; see the file COPYING.
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // unary complex scalar ops.
 
 DEFUNOP (not, float_complex)
 {
-  CAST_UNOP_ARG (const octave_float_complex&);
+  const octave_float_complex& v = dynamic_cast<const octave_float_complex&> (a);
   FloatComplex x = v.float_complex_value ();
   if (xisnan (x))
     err_nan_to_logical_conversion ();
 
   return octave_value (x == 0.0f);
 }
 
 DEFUNOP_OP (uplus, float_complex, /* no-op */)
 DEFUNOP_OP (uminus, float_complex, -)
 DEFUNOP_OP (transpose, float_complex, /* no-op */)
 
 DEFUNOP (hermitian, float_complex)
 {
-  CAST_UNOP_ARG (const octave_float_complex&);
+  const octave_float_complex& v = dynamic_cast<const octave_float_complex&> (a);
 
   return octave_value (conj (v.float_complex_value ()));
 }
 
 DEFNCUNOP_METHOD (incr, float_complex, increment)
 DEFNCUNOP_METHOD (decr, float_complex, decrement)
 
 // complex scalar by complex scalar ops.
 
 DEFBINOP_OP (add, float_complex, float_complex, +)
 DEFBINOP_OP (sub, float_complex, float_complex, -)
 DEFBINOP_OP (mul, float_complex, float_complex, *)
 
 DEFBINOP (div, float_complex, float_complex)
 {
-  CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_complex&);
+  const octave_float_complex& v1 = dynamic_cast<const octave_float_complex&> (a1);
+  const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
 
   FloatComplex d = v2.float_complex_value ();
 
   if (d == 0.0f)
     warn_divide_by_zero ();
 
   return octave_value (v1.float_complex_value () / d);
 }
 
 DEFBINOP_FN (pow, float_complex, float_complex, xpow)
 
 DEFBINOP (ldiv, float_complex, float_complex)
 {
-  CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_complex&);
+  const octave_float_complex& v1 = dynamic_cast<const octave_float_complex&> (a1);
+  const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
 
   FloatComplex d = v1.float_complex_value ();
 
   if (d == 0.0f)
     warn_divide_by_zero ();
 
   return octave_value (v2.float_complex_value () / d);
 }
@@ -100,68 +102,72 @@ DEFCMPLXCMPOP_OP (eq, float_complex, flo
 DEFCMPLXCMPOP_OP (ge, float_complex, float_complex, >=)
 DEFCMPLXCMPOP_OP (gt, float_complex, float_complex, >)
 DEFCMPLXCMPOP_OP (ne, float_complex, float_complex, !=)
 
 DEFBINOP_OP (el_mul, float_complex, float_complex, *)
 
 DEFBINOP (el_div, float_complex, float_complex)
 {
-  CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_complex&);
+  const octave_float_complex& v1 = dynamic_cast<const octave_float_complex&> (a1);
+  const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
 
   FloatComplex d = v2.float_complex_value ();
 
   if (d == 0.0f)
     warn_divide_by_zero ();
 
   return octave_value (v1.float_complex_value () / d);
 }
 
 DEFBINOP_FN (el_pow, float_complex, float_complex, xpow)
 
 DEFBINOP (el_ldiv, float_complex, float_complex)
 {
-  CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_complex&);
+  const octave_float_complex& v1 = dynamic_cast<const octave_float_complex&> (a1);
+  const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
 
   FloatComplex d = v1.float_complex_value ();
 
   if (d == 0.0f)
     warn_divide_by_zero ();
 
   return octave_value (v2.float_complex_value () / d);
 }
 
 DEFBINOP (el_and, float_complex, float_complex)
 {
-  CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_complex&);
+  const octave_float_complex& v1 = dynamic_cast<const octave_float_complex&> (a1);
+  const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
 
   return (v1.float_complex_value () != 0.0f
           && v2.float_complex_value () != 0.0f);
 }
 
 DEFBINOP (el_or, float_complex, float_complex)
 {
-  CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_complex&);
+  const octave_float_complex& v1 = dynamic_cast<const octave_float_complex&> (a1);
+  const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
 
   return (v1.float_complex_value () != 0.0f
           || v2.float_complex_value () != 0.0f);
 }
 
 DEFNDCATOP_FN (fcs_fcs, float_complex, float_complex, float_complex_array,
                float_complex_array, concat)
 
 DEFNDCATOP_FN (cs_fcs, complex, float_complex, float_complex_array,
                float_complex_array, concat)
 
 DEFNDCATOP_FN (fcs_cs, float_complex, complex, float_complex_array,
                float_complex_array, concat)
 
 CONVDECL (float_complex_to_complex)
 {
-  CAST_CONV_ARG (const octave_float_complex&);
+  const octave_float_complex& v = dynamic_cast<const octave_float_complex&> (a);
 
   return new octave_complex_matrix
                (ComplexMatrix (1, 1,
                                static_cast<Complex>(v.float_complex_value ())));
 }
 
 void
 install_fcs_fcs_ops (void)
diff --git a/libinterp/operators/op-fcs-fm.cc b/libinterp/operators/op-fcs-fm.cc
--- a/libinterp/operators/op-fcs-fm.cc
+++ b/libinterp/operators/op-fcs-fm.cc
@@ -44,33 +44,35 @@ along with Octave; see the file COPYING.
 // complex scalar by matrix ops.
 
 DEFNDBINOP_OP (add, float_complex, float_matrix, float_complex, float_array, +)
 DEFNDBINOP_OP (sub, float_complex, float_matrix, float_complex, float_array, -)
 DEFNDBINOP_OP (mul, float_complex, float_matrix, float_complex, float_array, *)
 
 DEFBINOP (div, float_complex, float_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_matrix&);
+  const octave_float_complex& v1 = dynamic_cast<const octave_float_complex&> (a1);
+  const octave_float_matrix& v2 = dynamic_cast<const octave_float_matrix&> (a2);
 
   FloatComplexMatrix m1 = v1.float_complex_matrix_value ();
   FloatMatrix m2 = v2.float_matrix_value ();
   MatrixType typ = v2.matrix_type ();
 
   FloatComplexMatrix ret = xdiv (m1, m2, typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP_FN (pow, float_complex, float_matrix, xpow)
 
 DEFBINOP (ldiv, float_complex, float_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_matrix&);
+  const octave_float_complex& v1 = dynamic_cast<const octave_float_complex&> (a1);
+  const octave_float_matrix& v2 = dynamic_cast<const octave_float_matrix&> (a2);
 
   FloatComplex d = v1.float_complex_value ();
 
   if (d == 0.0f)
     warn_divide_by_zero ();
 
   return octave_value (v2.float_array_value () / d);
 }
@@ -92,17 +94,18 @@ DEFNDBINOP_OP (el_mul, float_complex, fl
                float_array, *)
 DEFNDBINOP_FN (el_div, float_complex, float_matrix, float_complex,
                float_array, x_el_div)
 DEFNDBINOP_FN (el_pow, float_complex, float_matrix, float_complex,
                float_array, elem_xpow)
 
 DEFBINOP (el_ldiv, float_complex, float_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_matrix&);
+  const octave_float_complex& v1 = dynamic_cast<const octave_float_complex&> (a1);
+  const octave_float_matrix& v2 = dynamic_cast<const octave_float_matrix&> (a2);
 
   FloatComplex d = v1.float_complex_value ();
 
   if (d == 0.0f)
     warn_divide_by_zero ();
 
   return octave_value (v2.float_array_value () / d);
 }
diff --git a/libinterp/operators/op-fcs-fs.cc b/libinterp/operators/op-fcs-fs.cc
--- a/libinterp/operators/op-fcs-fs.cc
+++ b/libinterp/operators/op-fcs-fs.cc
@@ -41,31 +41,33 @@ along with Octave; see the file COPYING.
 // complex scalar by scalar ops.
 
 DEFBINOP_OP (add, float_complex, float_scalar, +)
 DEFBINOP_OP (sub, float_complex, float_scalar, -)
 DEFBINOP_OP (mul, float_complex, float_scalar, *)
 
 DEFBINOP (div, float_complex, float)
 {
-  CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_scalar&);
+  const octave_float_complex& v1 = dynamic_cast<const octave_float_complex&> (a1);
+  const octave_float_scalar& v2 = dynamic_cast<const octave_float_scalar&> (a2);
 
   float d = v2.float_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v1.float_complex_value () / d);
 }
 
 DEFBINOP_FN (pow, float_complex, float_scalar, xpow)
 
 DEFBINOP (ldiv, float_complex, float)
 {
-  CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_scalar&);
+  const octave_float_complex& v1 = dynamic_cast<const octave_float_complex&> (a1);
+  const octave_float_scalar& v2 = dynamic_cast<const octave_float_scalar&> (a2);
 
   FloatComplex d = v1.float_complex_value ();
 
   if (d == 0.0f)
     warn_divide_by_zero ();
 
   return octave_value (v2.float_value () / d);
 }
@@ -76,50 +78,54 @@ DEFCMPLXCMPOP_OP (eq, float_complex, flo
 DEFCMPLXCMPOP_OP (ge, float_complex, float_scalar, >=)
 DEFCMPLXCMPOP_OP (gt, float_complex, float_scalar, >)
 DEFCMPLXCMPOP_OP (ne, float_complex, float_scalar, !=)
 
 DEFBINOP_OP (el_mul, float_complex, float_scalar, *)
 
 DEFBINOP (el_div, float_complex, float)
 {
-  CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_scalar&);
+  const octave_float_complex& v1 = dynamic_cast<const octave_float_complex&> (a1);
+  const octave_float_scalar& v2 = dynamic_cast<const octave_float_scalar&> (a2);
 
   float d = v2.float_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v1.float_complex_value () / d);
 }
 
 DEFBINOP_FN (el_pow, float_complex, float_scalar, xpow)
 
 DEFBINOP (el_ldiv, float_complex, float)
 {
-  CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_scalar&);
+  const octave_float_complex& v1 = dynamic_cast<const octave_float_complex&> (a1);
+  const octave_float_scalar& v2 = dynamic_cast<const octave_float_scalar&> (a2);
 
   FloatComplex d = v1.float_complex_value ();
 
   if (d == 0.0f)
     warn_divide_by_zero ();
 
   return octave_value (v2.float_value () / d);
 }
 
 DEFBINOP (el_and, float_complex, float)
 {
-  CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_scalar&);
+  const octave_float_complex& v1 = dynamic_cast<const octave_float_complex&> (a1);
+  const octave_float_scalar& v2 = dynamic_cast<const octave_float_scalar&> (a2);
 
   return (v1.float_complex_value () != 0.0f && v2.float_value ());
 }
 
 DEFBINOP (el_or, float_complex, float)
 {
-  CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_scalar&);
+  const octave_float_complex& v1 = dynamic_cast<const octave_float_complex&> (a1);
+  const octave_float_scalar& v2 = dynamic_cast<const octave_float_scalar&> (a2);
 
   return (v1.float_complex_value () != 0.0f || v2.float_value ());
 }
 
 DEFNDCATOP_FN (fcs_fs, float_complex, float_scalar, float_complex_array,
                float_array, concat)
 
 DEFNDCATOP_FN (cs_fs, complex, float_scalar, float_complex_array,
diff --git a/libinterp/operators/op-fdm-fdm.cc b/libinterp/operators/op-fdm-fdm.cc
--- a/libinterp/operators/op-fdm-fdm.cc
+++ b/libinterp/operators/op-fdm-fdm.cc
@@ -37,54 +37,54 @@ along with Octave; see the file COPYING.
 
 // matrix unary ops.
 
 DEFUNOP_OP (uplus, float_diag_matrix, /* no-op */)
 DEFUNOP_OP (uminus, float_diag_matrix, -)
 
 DEFUNOP (transpose, float_diag_matrix)
 {
-  CAST_UNOP_ARG (const octave_float_diag_matrix&);
+  const octave_float_diag_matrix& v = dynamic_cast<const octave_float_diag_matrix&> (a);
   return octave_value (v.float_diag_matrix_value ().transpose ());
 }
 
 // matrix by matrix ops.
 
 DEFBINOP_OP (add, float_diag_matrix, float_diag_matrix, +)
 DEFBINOP_OP (sub, float_diag_matrix, float_diag_matrix, -)
 DEFBINOP_OP (mul, float_diag_matrix, float_diag_matrix, *)
 
 DEFBINOP (div, float_diag_matrix, float_diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_diag_matrix&,
-                   const octave_float_diag_matrix&);
+  const octave_float_diag_matrix& v1 = dynamic_cast<const octave_float_diag_matrix&> (a1);
+  const octave_float_diag_matrix& v2 = dynamic_cast<const octave_float_diag_matrix&> (a2);
 
   return xdiv (v1.float_diag_matrix_value (),
                v2.float_diag_matrix_value ());
 }
 
 DEFBINOP (ldiv, float_diag_matrix, float_diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_diag_matrix&,
-                   const octave_float_diag_matrix&);
+  const octave_float_diag_matrix& v1 = dynamic_cast<const octave_float_diag_matrix&> (a1);
+  const octave_float_diag_matrix& v2 = dynamic_cast<const octave_float_diag_matrix&> (a2);
 
   return xleftdiv (v1.float_diag_matrix_value (),
                    v2.float_diag_matrix_value ());
 }
 
 CONVDECL (float_diag_matrix_to_diag_matrix)
 {
-  CAST_CONV_ARG (const octave_float_diag_matrix&);
+  const octave_float_diag_matrix& v = dynamic_cast<const octave_float_diag_matrix&> (a);
 
   return new octave_diag_matrix (v.diag_matrix_value ());
 }
 
 CONVDECL (float_diag_matrix_to_float_matrix)
 {
-  CAST_CONV_ARG (const octave_float_diag_matrix&);
+  const octave_float_diag_matrix& v = dynamic_cast<const octave_float_diag_matrix&> (a);
 
   return new octave_float_matrix (v.float_matrix_value ());
 }
 
 void
 install_fdm_fdm_ops (void)
 {
   INSTALL_UNOP (op_uplus, octave_float_diag_matrix, uplus);
diff --git a/libinterp/operators/op-fm-fcm.cc b/libinterp/operators/op-fm-fcm.cc
--- a/libinterp/operators/op-fm-fcm.cc
+++ b/libinterp/operators/op-fm-fcm.cc
@@ -47,61 +47,61 @@ DEFNDBINOP_OP (add, float_matrix, float_
                float_complex_array, +)
 DEFNDBINOP_OP (sub, float_matrix, float_complex_matrix, float_array,
                float_complex_array, -)
 
 DEFBINOP_OP (mul, float_matrix, float_complex_matrix, *)
 
 DEFBINOP (trans_mul, float_matrix, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_matrix&,
-                   const octave_float_complex_matrix&);
+  const octave_float_matrix& v1 = dynamic_cast<const octave_float_matrix&> (a1);
+  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
 
   FloatMatrix m1 = v1.float_matrix_value ();
   FloatComplexMatrix m2 = v2.float_complex_matrix_value ();
 
   return FloatComplexMatrix (xgemm (m1, real (m2), blas_trans, blas_no_trans),
                              xgemm (m1, imag (m2), blas_trans, blas_no_trans));
 }
 
 DEFBINOP (div, float_matrix, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_matrix&,
-                   const octave_float_complex_matrix&);
+  const octave_float_matrix& v1 = dynamic_cast<const octave_float_matrix&> (a1);
+  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
   MatrixType typ = v2.matrix_type ();
 
   FloatComplexMatrix ret = xdiv (v1.float_matrix_value (),
                                  v2.float_complex_matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, float_matrix, float_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, float_matrix, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_matrix&,
-                   const octave_float_complex_matrix&);
+  const octave_float_matrix& v1 = dynamic_cast<const octave_float_matrix&> (a1);
+  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
   MatrixType typ = v1.matrix_type ();
 
   FloatComplexMatrix ret = xleftdiv (v1.float_matrix_value (),
                                      v2.float_complex_matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP (trans_ldiv, float_matrix, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_matrix&,
-                   const octave_float_complex_matrix&);
+  const octave_float_matrix& v1 = dynamic_cast<const octave_float_matrix&> (a1);
+  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
   MatrixType typ = v1.matrix_type ();
 
   FloatComplexMatrix ret = xleftdiv (v1.float_matrix_value (),
                                      v2.float_complex_matrix_value (),
                                      typ, blas_trans);
 
   v1.matrix_type (typ);
   return ret;
@@ -124,18 +124,18 @@ DEFNDBINOP_FN (el_mul, float_matrix, flo
                float_complex_array, product)
 DEFNDBINOP_FN (el_div, float_matrix, float_complex_matrix, float_array,
                float_complex_array, quotient)
 DEFNDBINOP_FN (el_pow, float_matrix, float_complex_matrix, float_array,
                float_complex_array, elem_xpow)
 
 DEFBINOP (el_ldiv, float_matrix, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_matrix&,
-                   const octave_float_complex_matrix&);
+  const octave_float_matrix& v1 = dynamic_cast<const octave_float_matrix&> (a1);
+  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
 
   return quotient (v2.float_complex_array_value (), v1.float_array_value ());
 }
 
 DEFNDBINOP_FN (el_and, float_matrix, float_complex_matrix, float_array,
                float_complex_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_matrix, float_complex_matrix, float_array,
                float_complex_array, mx_el_or)
@@ -146,17 +146,17 @@ DEFNDCATOP_FN (fm_fcm, float_matrix, flo
 DEFNDCATOP_FN (m_fcm, matrix, float_complex_matrix, float_array,
                float_complex_array, concat)
 
 DEFNDCATOP_FN (fm_cm, float_matrix, complex_matrix, float_array,
                float_complex_array, concat)
 
 DEFCONV (float_complex_matrix_conv, float_matrix, float_complex_matrix)
 {
-  CAST_CONV_ARG (const octave_float_matrix&);
+  const octave_float_matrix& v = dynamic_cast<const octave_float_matrix&> (a);
 
   return new octave_float_complex_matrix (FloatComplexNDArray
                                            (v.float_array_value ()));
 }
 
 void
 install_fm_fcm_ops (void)
 {
diff --git a/libinterp/operators/op-fm-fcs.cc b/libinterp/operators/op-fm-fcs.cc
--- a/libinterp/operators/op-fm-fcs.cc
+++ b/libinterp/operators/op-fm-fcs.cc
@@ -46,31 +46,33 @@ along with Octave; see the file COPYING.
 // matrix by complex scalar ops.
 
 DEFNDBINOP_OP (add, float_matrix, float_complex, float_array, float_complex, +)
 DEFNDBINOP_OP (sub, float_matrix, float_complex, float_array, float_complex, -)
 DEFNDBINOP_OP (mul, float_matrix, float_complex, float_array, float_complex, *)
 
 DEFBINOP (div, float_matrix, float_complex)
 {
-  CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_complex&);
+  const octave_float_matrix& v1 = dynamic_cast<const octave_float_matrix&> (a1);
+  const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
 
   FloatComplex d = v2.float_complex_value ();
 
   if (d == 0.0f)
     warn_divide_by_zero ();
 
   return octave_value (v1.float_array_value () / d);
 }
 
 DEFBINOP_FN (pow, float_matrix, float_complex, xpow)
 
 DEFBINOP (ldiv, float_matrix, float_complex)
 {
-  CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_complex&);
+  const octave_float_matrix& v1 = dynamic_cast<const octave_float_matrix&> (a1);
+  const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
 
   FloatMatrix m1 = v1.float_matrix_value ();
   FloatComplexMatrix m2 = v2.float_complex_matrix_value ();
   MatrixType typ = v1.matrix_type ();
 
   FloatComplexMatrix ret = xleftdiv (m1, m2, typ);
 
   v1.matrix_type (typ);
@@ -90,32 +92,34 @@ DEFNDCMPLXCMPOP_FN (gt, float_matrix, fl
 DEFNDCMPLXCMPOP_FN (ne, float_matrix, float_complex, float_array,
                     float_complex, mx_el_ne)
 
 DEFNDBINOP_OP (el_mul, float_matrix, float_complex, float_array,
                float_complex, *)
 
 DEFBINOP (el_div, float_matrix, float_complex)
 {
-  CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_complex&);
+  const octave_float_matrix& v1 = dynamic_cast<const octave_float_matrix&> (a1);
+  const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
 
   FloatComplex d = v2.float_complex_value ();
 
   if (d == 0.0f)
     warn_divide_by_zero ();
 
   return octave_value (v1.float_array_value () / d);
 }
 
 DEFNDBINOP_FN (el_pow, float_matrix, float_complex, float_array,
                float_complex, elem_xpow)
 
 DEFBINOP (el_ldiv, float_matrix, flaot_complex)
 {
-  CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_complex&);
+  const octave_float_matrix& v1 = dynamic_cast<const octave_float_matrix&> (a1);
+  const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
 
   return x_el_div (v2.float_complex_value (), v1.float_array_value ());
 }
 
 DEFNDBINOP_FN (el_and, float_matrix, float_complex, float_array,
                float_complex, mx_el_and)
 DEFNDBINOP_FN (el_or, float_matrix, float_complex, float_array,
                float_complex, mx_el_or)
diff --git a/libinterp/operators/op-fm-fm.cc b/libinterp/operators/op-fm-fm.cc
--- a/libinterp/operators/op-fm-fm.cc
+++ b/libinterp/operators/op-fm-fm.cc
@@ -38,17 +38,17 @@ along with Octave; see the file COPYING.
 // matrix unary ops.
 
 DEFNDUNOP_OP (not, float_matrix, float_array, !)
 DEFNDUNOP_OP (uplus, float_matrix, float_array, /* no-op */)
 DEFNDUNOP_OP (uminus, float_matrix, float_array, -)
 
 DEFUNOP (transpose, float_matrix)
 {
-  CAST_UNOP_ARG (const octave_float_matrix&);
+  const octave_float_matrix& v = dynamic_cast<const octave_float_matrix&> (a);
 
   if (v.ndims () > 2)
     error ("transpose not defined for N-D objects");
 
   return octave_value (v.float_matrix_value ().transpose ());
 }
 
 DEFNCUNOP_METHOD (incr, float_matrix, increment)
@@ -59,62 +59,67 @@ DEFNCUNOP_METHOD (changesign, float_matr
 
 DEFNDBINOP_OP (add, float_matrix, float_matrix, float_array, float_array, +)
 DEFNDBINOP_OP (sub, float_matrix, float_matrix, float_array, float_array, -)
 
 DEFBINOP_OP (mul, float_matrix, float_matrix, *)
 
 DEFBINOP (div, float_matrix, float_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_matrix&);
+  const octave_float_matrix& v1 = dynamic_cast<const octave_float_matrix&> (a1);
+  const octave_float_matrix& v2 = dynamic_cast<const octave_float_matrix&> (a2);
   MatrixType typ = v2.matrix_type ();
 
   FloatMatrix ret = xdiv (v1.float_matrix_value (),
                           v2.float_matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, float_matrix, float_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, float_matrix, float_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_matrix&);
+  const octave_float_matrix& v1 = dynamic_cast<const octave_float_matrix&> (a1);
+  const octave_float_matrix& v2 = dynamic_cast<const octave_float_matrix&> (a2);
   MatrixType typ = v1.matrix_type ();
 
   FloatMatrix ret = xleftdiv (v1.float_matrix_value (),
                               v2.float_matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP (trans_mul, float_matrix, float_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_matrix&);
+  const octave_float_matrix& v1 = dynamic_cast<const octave_float_matrix&> (a1);
+  const octave_float_matrix& v2 = dynamic_cast<const octave_float_matrix&> (a2);
   return octave_value(xgemm (v1.float_matrix_value (),
                              v2.float_matrix_value (),
                              blas_trans, blas_no_trans));
 }
 
 DEFBINOP (mul_trans, float_matrix, float_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_matrix&);
+  const octave_float_matrix& v1 = dynamic_cast<const octave_float_matrix&> (a1);
+  const octave_float_matrix& v2 = dynamic_cast<const octave_float_matrix&> (a2);
   return octave_value(xgemm (v1.float_matrix_value (),
                              v2.float_matrix_value (),
                              blas_no_trans, blas_trans));
 }
 
 DEFBINOP (trans_ldiv, float_matrix, float_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_matrix&);
+  const octave_float_matrix& v1 = dynamic_cast<const octave_float_matrix&> (a1);
+  const octave_float_matrix& v2 = dynamic_cast<const octave_float_matrix&> (a2);
   MatrixType typ = v1.matrix_type ();
 
   FloatMatrix ret = xleftdiv (v1.float_matrix_value (),
                               v2.float_matrix_value (), typ, blas_trans);
 
   v1.matrix_type (typ);
   return ret;
 }
@@ -136,17 +141,18 @@ DEFNDBINOP_FN (el_mul, float_matrix, flo
                float_array, product)
 DEFNDBINOP_FN (el_div, float_matrix, float_matrix, float_array,
                float_array, quotient)
 DEFNDBINOP_FN (el_pow, float_matrix, float_matrix, float_array,
                float_array, elem_xpow)
 
 DEFBINOP (el_ldiv, float_matrix, float_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_matrix&);
+  const octave_float_matrix& v1 = dynamic_cast<const octave_float_matrix&> (a1);
+  const octave_float_matrix& v2 = dynamic_cast<const octave_float_matrix&> (a2);
 
   return octave_value (quotient (v2.float_array_value (),
                                  v1.float_array_value ()));
 }
 
 DEFNDBINOP_FN (el_and, float_matrix, float_matrix, float_array,
                float_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_matrix, float_matrix, float_array,
@@ -179,17 +185,17 @@ DEFNDASSIGNOP_OP (assign_add, float_matr
 DEFNDASSIGNOP_OP (assign_sub, float_matrix, float_matrix, float_array, -=)
 DEFNDASSIGNOP_FNOP (assign_el_mul, float_matrix, float_matrix, float_array,
                     product_eq)
 DEFNDASSIGNOP_FNOP (assign_el_div, float_matrix, float_matrix, float_array,
                     quotient_eq)
 
 CONVDECL (float_matrix_to_matrix)
 {
-  CAST_CONV_ARG (const octave_float_matrix&);
+  const octave_float_matrix& v = dynamic_cast<const octave_float_matrix&> (a);
 
   return new octave_matrix (v.array_value ());
 }
 
 void
 install_fm_fm_ops (void)
 {
   INSTALL_UNOP (op_not, octave_float_matrix, not);
diff --git a/libinterp/operators/op-fm-fs.cc b/libinterp/operators/op-fm-fs.cc
--- a/libinterp/operators/op-fm-fs.cc
+++ b/libinterp/operators/op-fm-fs.cc
@@ -38,31 +38,33 @@ along with Octave; see the file COPYING.
 // matrix by scalar ops.
 
 DEFNDBINOP_OP (add, float_matrix, float_scalar, float_array, float_scalar, +)
 DEFNDBINOP_OP (sub, float_matrix, float_scalar, float_array, float_scalar, -)
 DEFNDBINOP_OP (mul, float_matrix, float_scalar, float_array, float_scalar, *)
 
 DEFBINOP (div, float_matrix, float)
 {
-  CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_scalar&);
+  const octave_float_matrix& v1 = dynamic_cast<const octave_float_matrix&> (a1);
+  const octave_float_scalar& v2 = dynamic_cast<const octave_float_scalar&> (a2);
 
   float d = v2.float_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v1.float_array_value () / d);
 }
 
 DEFBINOP_FN (pow, float_matrix, float_scalar, xpow)
 
 DEFBINOP (ldiv, float_matrix, float)
 {
-  CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_scalar&);
+  const octave_float_matrix& v1 = dynamic_cast<const octave_float_matrix&> (a1);
+  const octave_float_scalar& v2 = dynamic_cast<const octave_float_scalar&> (a2);
 
   FloatMatrix m1 = v1.float_matrix_value ();
   FloatMatrix m2 = v2.float_matrix_value ();
   MatrixType typ = v1.matrix_type ();
 
   FloatMatrix ret = xleftdiv (m1, m2, typ);
 
   v1.matrix_type (typ);
@@ -81,32 +83,34 @@ DEFNDBINOP_FN (gt, float_matrix, float_s
                float_scalar, mx_el_gt)
 DEFNDBINOP_FN (ne, float_matrix, float_scalar, float_array,
                float_scalar, mx_el_ne)
 
 DEFNDBINOP_OP (el_mul, float_matrix, float_scalar, float_array, float_scalar, *)
 
 DEFBINOP (el_div, float_matrix, float)
 {
-  CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_scalar&);
+  const octave_float_matrix& v1 = dynamic_cast<const octave_float_matrix&> (a1);
+  const octave_float_scalar& v2 = dynamic_cast<const octave_float_scalar&> (a2);
 
   float d = v2.float_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v1.float_array_value () / d);
 }
 
 DEFNDBINOP_FN (el_pow, float_matrix, float_scalar, float_array,
                float_scalar, elem_xpow)
 
 DEFBINOP (el_ldiv, float_matrix, float)
 {
-  CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_scalar&);
+  const octave_float_matrix& v1 = dynamic_cast<const octave_float_matrix&> (a1);
+  const octave_float_scalar& v2 = dynamic_cast<const octave_float_scalar&> (a2);
 
   return x_el_div (v2.float_value (), v1.float_array_value ());
 }
 
 DEFNDBINOP_FN (el_and, float_matrix, float_scalar, float_array,
                float_scalar, mx_el_and)
 DEFNDBINOP_FN (el_or, float_matrix, float_scalar, float_array,
                float_scalar, mx_el_or)
diff --git a/libinterp/operators/op-fs-fcm.cc b/libinterp/operators/op-fs-fcm.cc
--- a/libinterp/operators/op-fs-fcm.cc
+++ b/libinterp/operators/op-fs-fcm.cc
@@ -48,35 +48,35 @@ DEFNDBINOP_OP (add, float_scalar, float_
                float_complex_array, +)
 DEFNDBINOP_OP (sub, float_scalar, float_complex_matrix, float_scalar,
                float_complex_array, -)
 DEFNDBINOP_OP (mul, float_scalar, float_complex_matrix, float_scalar,
                float_complex_array, *)
 
 DEFBINOP (div, float_scalar, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_scalar&,
-                   const octave_float_complex_matrix&);
+  const octave_float_scalar& v1 = dynamic_cast<const octave_float_scalar&> (a1);
+  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
 
   FloatMatrix m1 = v1.float_matrix_value ();
   FloatComplexMatrix m2 = v2.float_complex_matrix_value ();
   MatrixType typ = v2.matrix_type ();
 
   FloatComplexMatrix ret = xdiv (m1, m2, typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP_FN (pow, float_scalar, float_complex_matrix, xpow)
 
 DEFBINOP (ldiv, float_scalar, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_scalar&,
-                   const octave_float_complex_matrix&);
+  const octave_float_scalar& v1 = dynamic_cast<const octave_float_scalar&> (a1);
+  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
 
   float d = v1.float_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v2.float_complex_array_value () / d);
 }
@@ -98,18 +98,18 @@ DEFNDBINOP_OP (el_mul, float_scalar, flo
                float_complex_array, *)
 DEFNDBINOP_FN (el_div, float_scalar, float_complex_matrix, float_scalar,
                float_complex_array, x_el_div)
 DEFNDBINOP_FN (el_pow, float_scalar, float_complex_matrix, float_scalar,
                float_complex_array, elem_xpow)
 
 DEFBINOP (el_ldiv, float_scalar, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_scalar&,
-                   const octave_float_complex_matrix&);
+  const octave_float_scalar& v1 = dynamic_cast<const octave_float_scalar&> (a1);
+  const octave_float_complex_matrix& v2 = dynamic_cast<const octave_float_complex_matrix&> (a2);
 
   float d = v1.float_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v2.float_complex_array_value () / d);
 }
@@ -125,17 +125,17 @@ DEFNDCATOP_FN (fs_fcm, float_scalar, flo
 DEFNDCATOP_FN (s_fcm, scalar, float_complex_matrix, float_array,
                float_complex_array, concat)
 
 DEFNDCATOP_FN (fs_cm, float_scalar, complex_matrix, float_array,
                float_complex_array, concat)
 
 DEFCONV (float_complex_matrix_conv, float_scalar, float_complex_matrix)
 {
-  CAST_CONV_ARG (const octave_float_scalar&);
+  const octave_float_scalar& v = dynamic_cast<const octave_float_scalar&> (a);
 
   return new octave_float_complex_matrix (FloatComplexMatrix
                                             (v.float_matrix_value ()));
 }
 
 void
 install_fs_fcm_ops (void)
 {
diff --git a/libinterp/operators/op-fs-fcs.cc b/libinterp/operators/op-fs-fcs.cc
--- a/libinterp/operators/op-fs-fcs.cc
+++ b/libinterp/operators/op-fs-fcs.cc
@@ -41,31 +41,33 @@ along with Octave; see the file COPYING.
 // scalar by complex scalar ops.
 
 DEFBINOP_OP (add, float_scalar, float_complex, +)
 DEFBINOP_OP (sub, float_scalar, float_complex, -)
 DEFBINOP_OP (mul, float_scalar, float_complex, *)
 
 DEFBINOP (div, float_scalar, float_complex)
 {
-  CAST_BINOP_ARGS (const octave_float_scalar&, const octave_float_complex&);
+  const octave_float_scalar& v1 = dynamic_cast<const octave_float_scalar&> (a1);
+  const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
 
   FloatComplex d = v2.float_complex_value ();
 
   if (d == 0.0f)
     warn_divide_by_zero ();
 
   return octave_value (v1.float_value () / d);
 }
 
 DEFBINOP_FN (pow, float_scalar, float_complex, xpow)
 
 DEFBINOP (ldiv, float_scalar, float_complex)
 {
-  CAST_BINOP_ARGS (const octave_float_scalar&, const octave_float_complex&);
+  const octave_float_scalar& v1 = dynamic_cast<const octave_float_scalar&> (a1);
+  const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
 
   float d = v1.float_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v2.float_complex_value () / d);
 }
@@ -76,51 +78,55 @@ DEFCMPLXCMPOP_OP (eq, float_scalar, floa
 DEFCMPLXCMPOP_OP (ge, float_scalar, float_complex, >=)
 DEFCMPLXCMPOP_OP (gt, float_scalar, float_complex, >)
 DEFCMPLXCMPOP_OP (ne, float_scalar, float_complex, !=)
 
 DEFBINOP_OP (el_mul, float_scalar, float_complex, *)
 
 DEFBINOP (el_div, float_scalar, float_complex)
 {
-  CAST_BINOP_ARGS (const octave_float_scalar&, const octave_float_complex&);
+  const octave_float_scalar& v1 = dynamic_cast<const octave_float_scalar&> (a1);
+  const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
 
   FloatComplex d = v2.float_complex_value ();
 
   if (d == 0.0f)
     warn_divide_by_zero ();
 
   return octave_value (v1.float_value () / d);
 }
 
 DEFBINOP_FN (el_pow, float_scalar, float_complex, xpow)
 
 DEFBINOP (el_ldiv, float_scalar, float_complex)
 {
-  CAST_BINOP_ARGS (const octave_float_scalar&, const octave_float_complex&);
+  const octave_float_scalar& v1 = dynamic_cast<const octave_float_scalar&> (a1);
+  const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
 
   float d = v1.float_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v2.float_complex_value () / d);
 }
 
 DEFBINOP (el_and, float_scalar, float_complex)
 {
-  CAST_BINOP_ARGS (const octave_float_scalar&, const octave_float_complex&);
+  const octave_float_scalar& v1 = dynamic_cast<const octave_float_scalar&> (a1);
+  const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
 
   return octave_value (v1.float_scalar_value ()
                        && (v2.float_complex_value () != 0.0f));
 }
 
 DEFBINOP (el_or, float_scalar, float_complex)
 {
-  CAST_BINOP_ARGS (const octave_float_scalar&, const octave_float_complex&);
+  const octave_float_scalar& v1 = dynamic_cast<const octave_float_scalar&> (a1);
+  const octave_float_complex& v2 = dynamic_cast<const octave_float_complex&> (a2);
 
   return octave_value (v1.float_scalar_value ()
                        || (v2.float_complex_value () != 0.0f));
 }
 
 DEFNDCATOP_FN (fs_fcs, float_scalar, float_complex, float_array,
                float_complex_array, concat)
 
diff --git a/libinterp/operators/op-fs-fm.cc b/libinterp/operators/op-fs-fm.cc
--- a/libinterp/operators/op-fs-fm.cc
+++ b/libinterp/operators/op-fs-fm.cc
@@ -39,33 +39,35 @@ along with Octave; see the file COPYING.
 // scalar by matrix ops.
 
 DEFNDBINOP_OP (add, float_scalar, float_matrix, float_scalar, float_array, +)
 DEFNDBINOP_OP (sub, float_scalar, float_matrix, float_scalar, float_array, -)
 DEFNDBINOP_OP (mul, float_scalar, float_matrix, float_scalar, float_array, *)
 
 DEFBINOP (div, float_scalar, float_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_scalar&, const octave_float_matrix&);
+  const octave_float_scalar& v1 = dynamic_cast<const octave_float_scalar&> (a1);
+  const octave_float_matrix& v2 = dynamic_cast<const octave_float_matrix&> (a2);
 
   FloatMatrix m1 = v1.float_matrix_value ();
   FloatMatrix m2 = v2.float_matrix_value ();
   MatrixType typ = v2.matrix_type ();
 
   FloatMatrix ret = xdiv (m1, m2, typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP_FN (pow, float_scalar, float_matrix, xpow)
 
 DEFBINOP (ldiv, float_scalar, float_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_scalar&, const octave_float_matrix&);
+  const octave_float_scalar& v1 = dynamic_cast<const octave_float_scalar&> (a1);
+  const octave_float_matrix& v2 = dynamic_cast<const octave_float_matrix&> (a2);
 
   float d = v1.float_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v2.float_array_value () / d);
 }
@@ -87,17 +89,18 @@ DEFNDBINOP_OP (el_mul, float_scalar, flo
                float_array, *)
 DEFNDBINOP_FN (el_div, float_scalar, float_matrix, float_scalar,
                float_array, x_el_div)
 DEFNDBINOP_FN (el_pow, float_scalar, float_matrix, float_scalar,
                float_array, elem_xpow)
 
 DEFBINOP (el_ldiv, float_scalar, float_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_scalar&, const octave_float_matrix&);
+  const octave_float_scalar& v1 = dynamic_cast<const octave_float_scalar&> (a1);
+  const octave_float_matrix& v2 = dynamic_cast<const octave_float_matrix&> (a2);
 
   float d = v1.float_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v2.float_array_value () / d);
 }
@@ -111,17 +114,17 @@ DEFNDCATOP_FN (fs_fm, float_scalar, floa
                float_array, concat)
 
 DEFNDCATOP_FN (s_fm, scalar, float_matrix, float_array, float_array, concat)
 
 DEFNDCATOP_FN (fs_m, float_scalar, matrix, float_array, float_array, concat)
 
 DEFCONV (matrix_conv, float_scalar, float_matrix)
 {
-  CAST_CONV_ARG (const octave_float_scalar&);
+  const octave_float_scalar& v = dynamic_cast<const octave_float_scalar&> (a);
 
   return new octave_float_matrix (v.float_matrix_value ());
 }
 
 void
 install_fs_fm_ops (void)
 {
   INSTALL_BINOP (op_add, octave_float_scalar, octave_float_matrix, add);
diff --git a/libinterp/operators/op-fs-fs.cc b/libinterp/operators/op-fs-fs.cc
--- a/libinterp/operators/op-fs-fs.cc
+++ b/libinterp/operators/op-fs-fs.cc
@@ -37,17 +37,17 @@ along with Octave; see the file COPYING.
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // scalar unary ops.
 
 DEFUNOP (not, float_scalar)
 {
-  CAST_UNOP_ARG (const octave_float_scalar&);
+  const octave_float_scalar& v = dynamic_cast<const octave_float_scalar&> (a);
   float x = v.float_value ();
   if (xisnan (x))
     err_nan_to_logical_conversion ();
 
   return octave_value (x == 0.0f);
 }
 
 DEFUNOP_OP (uplus, float_scalar, /* no-op */)
@@ -61,31 +61,33 @@ DEFNCUNOP_METHOD (decr, float_scalar, de
 // float by float ops.
 
 DEFBINOP_OP (add, float_scalar, float_scalar, +)
 DEFBINOP_OP (sub, float_scalar, float_scalar, -)
 DEFBINOP_OP (mul, float_scalar, float_scalar, *)
 
 DEFBINOP (div, float_scalar, float_scalar)
 {
-  CAST_BINOP_ARGS (const octave_float_scalar&, const octave_float_scalar&);
+  const octave_float_scalar& v1 = dynamic_cast<const octave_float_scalar&> (a1);
+  const octave_float_scalar& v2 = dynamic_cast<const octave_float_scalar&> (a2);
 
   float d = v2.float_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v1.float_value () / d);
 }
 
 DEFBINOP_FN (pow, float_scalar, float_scalar, xpow)
 
 DEFBINOP (ldiv, float_scalar, float_scalar)
 {
-  CAST_BINOP_ARGS (const octave_float_scalar&, const octave_float_scalar&);
+  const octave_float_scalar& v1 = dynamic_cast<const octave_float_scalar&> (a1);
+  const octave_float_scalar& v2 = dynamic_cast<const octave_float_scalar&> (a2);
 
   float d = v1.float_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v2.float_value () / d);
 }
@@ -96,31 +98,33 @@ DEFBINOP_OP (eq, float_scalar, float_sca
 DEFBINOP_OP (ge, float_scalar, float_scalar, >=)
 DEFBINOP_OP (gt, float_scalar, float_scalar, >)
 DEFBINOP_OP (ne, float_scalar, float_scalar, !=)
 
 DEFBINOP_OP (el_mul, float_scalar, float_scalar, *)
 
 DEFBINOP (el_div, float_scalar, float_scalar)
 {
-  CAST_BINOP_ARGS (const octave_float_scalar&, const octave_float_scalar&);
+  const octave_float_scalar& v1 = dynamic_cast<const octave_float_scalar&> (a1);
+  const octave_float_scalar& v2 = dynamic_cast<const octave_float_scalar&> (a2);
 
   float d = v2.float_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v1.float_value () / d);
 }
 
 DEFBINOP_FN (el_pow, float_scalar, float_scalar, xpow)
 
 DEFBINOP (el_ldiv, float_scalar, float_scalar)
 {
-  CAST_BINOP_ARGS (const octave_float_scalar&, const octave_float_scalar&);
+  const octave_float_scalar& v1 = dynamic_cast<const octave_float_scalar&> (a1);
+  const octave_float_scalar& v2 = dynamic_cast<const octave_float_scalar&> (a2);
 
   float d = v1.float_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v2.float_value () / d);
 }
@@ -130,17 +134,17 @@ DEFSCALARBOOLOP_OP (el_or, float_scalar,
 
 DEFNDCATOP_FN (fs_fs, float_scalar, float_scalar, float_array, float_array,
                concat)
 DEFNDCATOP_FN (s_fs, scalar, float_scalar, float_array, float_array, concat)
 DEFNDCATOP_FN (fs_s, float_scalar, scalar, float_array, float_array, concat)
 
 CONVDECL (float_to_scalar)
 {
-  CAST_CONV_ARG (const octave_float_scalar&);
+  const octave_float_scalar& v = dynamic_cast<const octave_float_scalar&> (a);
 
   return new octave_matrix (Matrix (1, 1,
                                     static_cast<double>(v.float_value ())));
 }
 
 void
 install_fs_fs_ops (void)
 {
diff --git a/libinterp/operators/op-int-conv.cc b/libinterp/operators/op-int-conv.cc
--- a/libinterp/operators/op-int-conv.cc
+++ b/libinterp/operators/op-int-conv.cc
@@ -44,17 +44,17 @@ along with Octave; see the file COPYING.
 #include "ov-flt-re-mat.h"
 #include "ov-str-mat.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 
 #define DEFINTCONVFN(name, tfrom, tto) \
   CONVDECL (name) \
   { \
-    CAST_CONV_ARG (const octave_ ## tfrom&); \
+    const octave_ ## tfrom& v = dynamic_cast<const octave_ ## tfrom&> (a); \
  \
     octave_ ## tto ## _matrix v2 = v.tto ## _array_value (); \
     return new octave_ ## tto ## _matrix (v2); \
   }
 
 // conversion ops
 
 DEFINTCONVFN (scalar_to_int8, scalar, int8)
diff --git a/libinterp/operators/op-int.h b/libinterp/operators/op-int.h
--- a/libinterp/operators/op-int.h
+++ b/libinterp/operators/op-int.h
@@ -24,45 +24,53 @@ along with Octave; see the file COPYING.
 #define octave_op_int_h 1
 
 #include "octave-config.h"
 
 #include "quit.h"
 #include "bsxfun.h"
 
 #define DEFINTBINOP_OP(name, t1, t2, op, t3) \
-  BINOPDECL (name, a1, a2) \
+  static octave_value \
+  CONCAT2(oct_binop_, name) (const octave_base_value& a1, const octave_base_value& a2) \
   { \
-    CAST_BINOP_ARGS (const octave_ ## t1&, const octave_ ## t2&); \
+    const octave_ ## t1& v1 = dynamic_cast<const octave_ ## t1&> (a1); \
+    const octave_ ## t2& v2 = dynamic_cast<const octave_ ## t2&> (a2); \
     octave_value retval = octave_value \
       (v1.t1 ## _value () op v2.t2 ## _value ()); \
     return retval; \
   }
 
 #define DEFINTNDBINOP_OP(name, t1, t2, e1, e2, op, t3) \
-  BINOPDECL (name, a1, a2) \
+  static octave_value \
+  CONCAT2(oct_binop_, name) (const octave_base_value& a1, const octave_base_value& a2) \
   { \
-    CAST_BINOP_ARGS (const octave_ ## t1&, const octave_ ## t2&); \
+    const octave_ ## t1& v1 = dynamic_cast<const octave_ ## t1&> (a1); \
+    const octave_ ## t2& v2 = dynamic_cast<const octave_ ## t2&> (a2); \
     octave_value retval = octave_value \
       (v1.e1 ## _value () op v2.e2 ## _value ()); \
     return retval; \
   }
 
 #define DEFINTBINOP_FN(name, t1, t2, f, t3, op) \
-  BINOPDECL (name, a1, a2) \
+  static octave_value \
+  CONCAT2(oct_binop_, name) (const octave_base_value& a1, const octave_base_value& a2) \
   { \
-    CAST_BINOP_ARGS (const octave_ ## t1&, const octave_ ## t2&); \
+    const octave_ ## t1& v1 = dynamic_cast<const octave_ ## t1&> (a1); \
+    const octave_ ## t2& v2 = dynamic_cast<const octave_ ## t2&> (a2); \
     octave_value retval = octave_value (f (v1.t1 ## _value (), v2.t2 ## _value ())); \
     return retval; \
   }
 
 #define DEFINTNDBINOP_FN(name, t1, t2, e1, e2, f, t3, op)       \
-  BINOPDECL (name, a1, a2) \
+  static octave_value \
+  CONCAT2(oct_binop_, name) (const octave_base_value& a1, const octave_base_value& a2) \
   { \
-    CAST_BINOP_ARGS (const octave_ ## t1&, const octave_ ## t2&); \
+    const octave_ ## t1& v1 = dynamic_cast<const octave_ ## t1&> (a1); \
+    const octave_ ## t2& v2 = dynamic_cast<const octave_ ## t2&> (a2); \
     octave_value retval = octave_value (f (v1.e1 ## _value (), v2.e2 ## _value ())); \
     return retval; \
   }
 
 #define OCTAVE_CONCAT_FN2(T1, T2) \
   DEFNDCATOP_FN2 (T1 ## _ ## T2 ## _s_s, T1 ## _scalar, T2 ## _scalar, , T1 ## NDArray, T1 ## _array, T2 ## _array, concat) \
   DEFNDCATOP_FN2 (T1 ## _ ## T2 ## _s_m, T1 ## _scalar, T2 ## _matrix, , T1 ## NDArray, T1 ## _array, T2 ## _array, concat) \
   DEFNDCATOP_FN2 (T1 ## _ ## T2 ## _m_s, T1 ## _matrix, T2 ## _scalar, , T1 ## NDArray, T1 ## _array, T2 ## _array, concat) \
@@ -159,17 +167,17 @@ along with Octave; see the file COPYING.
 
 // scalar unary ops.
 #define OCTAVE_S_INT_UNOPS(TYPE) \
  \
   DEFUNOP_OP (s_not, TYPE ## _scalar, !) \
   DEFUNOP_OP (s_uplus, TYPE ## _scalar, /* no-op */) \
   DEFUNOP (s_uminus, TYPE ## _scalar) \
   { \
-    CAST_UNOP_ARG (const octave_ ## TYPE ## _scalar &); \
+    const octave_ ## TYPE ## _scalar & v = dynamic_cast<const octave_ ## TYPE ## _scalar &> (a); \
     octave_value retval = octave_value (- v. TYPE ## _scalar_value ()); \
     return retval; \
   } \
   DEFUNOP_OP (s_transpose, TYPE ## _scalar, /* no-op */) \
   DEFUNOP_OP (s_hermitian, TYPE ## _scalar, /* no-op */) \
  \
   DEFNCUNOP_METHOD (s_incr, TYPE ## _scalar, increment) \
   DEFNCUNOP_METHOD (s_decr, TYPE ## _scalar, decrement)
@@ -178,75 +186,81 @@ along with Octave; see the file COPYING.
 #define OCTAVE_SS_INT_ARITH_OPS(PFX, T1, T2, T3)        \
  \
   DEFINTBINOP_OP (PFX ## _add, T1 ## scalar, T2 ## scalar, +, T3) \
   DEFINTBINOP_OP (PFX ## _sub, T1 ## scalar, T2 ## scalar, -, T3) \
   DEFINTBINOP_OP (PFX ## _mul, T1 ## scalar, T2 ## scalar, *, T3) \
  \
   DEFBINOP (PFX ## _div, T1 ## scalar, T2 ## scalar) \
   { \
-    CAST_BINOP_ARGS (const octave_ ## T1 ## scalar&, const octave_ ## T2 ## scalar&); \
+    const octave_ ## T1 ## scalar& v1 = dynamic_cast<const octave_ ## T1 ## scalar&> (a1); \
+    const octave_ ## T2 ## scalar& v2 = dynamic_cast<const octave_ ## T2 ## scalar&> (a2); \
  \
     if (! v2.T2 ## scalar_value ()) \
       warn_divide_by_zero (); \
  \
     octave_value retval = octave_value (v1.T1 ## scalar_value () / v2.T2 ## scalar_value ()); \
     return retval; \
   } \
  \
   DEFINTBINOP_FN (PFX ## _pow, T1 ## scalar, T2 ## scalar, xpow, T3, ^) \
  \
   DEFBINOP (PFX ## _ldiv, T1 ## scalar, T2 ## scalar) \
   { \
-    CAST_BINOP_ARGS (const octave_ ## T1 ## scalar&, const octave_ ## T2 ## scalar&); \
+    const octave_ ## T1 ## scalar& v1 = dynamic_cast<const octave_ ## T1 ## scalar&> (a1); \
+    const octave_ ## T2 ## scalar& v2 = dynamic_cast<const octave_ ## T2 ## scalar&> (a2); \
  \
     if (! v1.T1 ## scalar_value ()) \
       warn_divide_by_zero (); \
  \
     octave_value retval = octave_value (v2.T2 ## scalar_value () / v1.T1 ## scalar_value ()); \
     return retval; \
   } \
  \
   DEFINTBINOP_OP (PFX ## _el_mul, T1 ## scalar, T2 ## scalar, *, T3)    \
  \
   DEFBINOP (PFX ## _el_div, T1 ## scalar, T2 ## scalar) \
   { \
-    CAST_BINOP_ARGS (const octave_ ## T1 ## scalar&, const octave_ ## T2 ## scalar&); \
+    const octave_ ## T1 ## scalar& v1 = dynamic_cast<const octave_ ## T1 ## scalar&> (a1); \
+    const octave_ ## T2 ## scalar& v2 = dynamic_cast<const octave_ ## T2 ## scalar&> (a2); \
  \
     if (! v2.T2 ## scalar_value ()) \
       warn_divide_by_zero (); \
  \
     octave_value retval = octave_value (v1.T1 ## scalar_value () / v2.T2 ## scalar_value ()); \
     return retval; \
   } \
  \
   DEFINTBINOP_FN (PFX ## _el_pow, T1 ## scalar, T2 ## scalar, xpow, T3, .^) \
  \
   DEFBINOP (PFX ## _el_ldiv, T1 ## scalar, T2 ## scalar) \
   { \
-    CAST_BINOP_ARGS (const octave_ ## T1 ## scalar&, const octave_ ## T2 ## scalar&); \
+    const octave_ ## T1 ## scalar& v1 = dynamic_cast<const octave_ ## T1 ## scalar&> (a1); \
+    const octave_ ## T2 ## scalar& v2 = dynamic_cast<const octave_ ## T2 ## scalar&> (a2); \
  \
     if (! v1.T1 ## scalar_value ()) \
       warn_divide_by_zero (); \
  \
     octave_value retval = octave_value (v2.T2 ## scalar_value () / v1.T1 ## scalar_value ()); \
     return retval; \
   }
 
 #define OCTAVE_SS_INT_BOOL_OPS(PFX, T1, T2, Z1, Z2) \
   DEFBINOP (PFX ## _el_and, T2, T2) \
   { \
-    CAST_BINOP_ARGS (const octave_ ## T1 ## scalar&, const octave_ ## T2 ## scalar&); \
+    const octave_ ## T1 ## scalar& v1 = dynamic_cast<const octave_ ## T1 ## scalar&> (a1); \
+    const octave_ ## T2 ## scalar& v2 = dynamic_cast<const octave_ ## T2 ## scalar&> (a2); \
  \
     return v1.T1 ## scalar_value () != Z1 && v2.T2 ## scalar_value () != Z2; \
   } \
  \
   DEFBINOP (PFX ## _el_or, T1, T2) \
   { \
-    CAST_BINOP_ARGS (const octave_ ## T1 ## scalar&, const octave_ ## T2 ## scalar&); \
+    const octave_ ## T1 ## scalar& v1 = dynamic_cast<const octave_ ## T1 ## scalar&> (a1); \
+    const octave_ ## T2 ## scalar& v2 = dynamic_cast<const octave_ ## T2 ## scalar&> (a2); \
  \
     return v1.T1 ## scalar_value () != Z1 || v2.T2 ## scalar_value () != Z2; \
   }
 
 #define OCTAVE_SS_INT_CMP_OPS(PFX, T1, T2) \
   DEFBINOP_OP (PFX ## _lt, T1 ## scalar, T2 ## scalar, <) \
   DEFBINOP_OP (PFX ## _le, T1 ## scalar, T2 ## scalar, <=) \
   DEFBINOP_OP (PFX ## _eq, T1 ## scalar, T2 ## scalar, ==) \
@@ -308,51 +322,55 @@ along with Octave; see the file COPYING.
 #define OCTAVE_SM_INT_ARITH_OPS(PFX, TS, TM, TI) \
  \
   DEFINTNDBINOP_OP (PFX ## _add, TS ## scalar, TM ## matrix, TS ## scalar, TM ## array, +, TI) \
   DEFINTNDBINOP_OP (PFX ## _sub, TS ## scalar, TM ## matrix, TS ## scalar, TM ## array, -, TI) \
   DEFINTNDBINOP_OP (PFX ## _mul, TS ## scalar, TM ## matrix, TS ## scalar, TM ## array, *, TI) \
  \
   /* DEFBINOP (PFX ## _div, TS ## scalar, TM ## matrix) */ \
   /* { */ \
-  /* CAST_BINOP_ARGS (const octave_ ## TS ## scalar&, const octave_ ## TM ## matrix&); */ \
+  /* const octave_ ## TS ## scalar& v1 = dynamic_cast<const octave_ ## TS ## scalar&> (a1); */ \
+  /* const octave_ ## TM ## matrix& v2 = dynamic_cast<const octave_ ## TM ## matrix&> (a2); */ \
   /* */ \
   /* Matrix m1 = v1.TM ## matrix_value (); */ \
   /* Matrix m2 = v2.TM ## matrix_value (); */ \
   /* */ \
   /* return octave_value (xdiv (m1, m2)); */ \
   /* } */ \
  \
   /* DEFBINOP_FN (PFX ## _pow, TS ## scalar, TM ## matrix, xpow) */ \
  \
   DEFBINOP (PFX ## _ldiv, TS ## scalar, TM ## matrix) \
   { \
-    CAST_BINOP_ARGS (const octave_ ## TS ## scalar&, const octave_ ## TM ## matrix&); \
+    const octave_ ## TS ## scalar& v1 = dynamic_cast<const octave_ ## TS ## scalar&> (a1); \
+    const octave_ ## TM ## matrix& v2 = dynamic_cast<const octave_ ## TM ## matrix&> (a2); \
  \
     if (! v1.TS ## scalar_value ()) \
       warn_divide_by_zero (); \
  \
     octave_value retval = octave_value (v2.TS ## scalar_value () / v1.TS ## scalar_value ()); \
     return retval; \
   } \
  \
   DEFINTNDBINOP_OP (PFX ## _el_mul, TS ## scalar, TM ## matrix, TS ## scalar, TM ## array, *, TI) \
   DEFBINOP (PFX ## _el_div, TS ## scalar, TM ## matrix) \
   { \
-    CAST_BINOP_ARGS (const octave_ ## TS ## scalar&, const octave_ ## TM ## matrix&); \
+    const octave_ ## TS ## scalar& v1 = dynamic_cast<const octave_ ## TS ## scalar&> (a1); \
+    const octave_ ## TM ## matrix& v2 = dynamic_cast<const octave_ ## TM ## matrix&> (a2); \
  \
     octave_value retval = octave_value (v1.TS ## scalar_value () / v2.TM ## array_value ()); \
     return retval; \
   } \
  \
   DEFINTNDBINOP_FN (PFX ## _el_pow, TS ## scalar, TM ## matrix, TS ## scalar, TM ## array, elem_xpow, TI, .^) \
  \
   DEFBINOP (PFX ## _el_ldiv, TS ## scalar, TM ## matrix) \
   { \
-    CAST_BINOP_ARGS (const octave_ ## TS ## scalar&, const octave_ ## TM ## matrix&); \
+    const octave_ ## TS ## scalar& v1 = dynamic_cast<const octave_ ## TS ## scalar&> (a1); \
+    const octave_ ## TM ## matrix& v2 = dynamic_cast<const octave_ ## TM ## matrix&> (a2); \
  \
     if (! v1.TS ## scalar_value ()) \
       warn_divide_by_zero (); \
  \
     octave_value retval = octave_value (v2.TM ## array_value () / v1.TS ## scalar_value ()); \
     return retval; \
   }
 
@@ -430,17 +448,17 @@ along with Octave; see the file COPYING.
       } \
     return octave_value (result); \
   }
 
 
 #define OCTAVE_SM_CONV(TS, TM) \
   DEFCONV (TS ## s_ ## TM ## m_conv, TM ## scalar, TM ## matrix) \
   { \
-    CAST_CONV_ARG (const octave_ ## TS ## scalar&); \
+    const octave_ ## TS ## scalar& v = dynamic_cast<const octave_ ## TS ## scalar&> (a); \
  \
     return new octave_ ## TM ## matrix (v.TM ## array_value ()); \
   }
 
 #define OCTAVE_SM_INT_OPS(TYPE) \
   OCTAVE_SM_POW_OPS (TYPE, TYPE) \
   OCTAVE_SM_INT_ARITH_OPS (sm, TYPE ## _, TYPE ## _, TYPE) \
   OCTAVE_SM_INT_ARITH_OPS (smx, TYPE ## _, , TYPE) \
@@ -465,55 +483,59 @@ along with Octave; see the file COPYING.
 #define OCTAVE_MS_INT_ARITH_OPS(PFX, TM, TS, TI) \
  \
   DEFINTNDBINOP_OP (PFX ## _add, TM ## matrix, TS ## scalar, TM ## array, TS ## scalar, +, TI) \
   DEFINTNDBINOP_OP (PFX ## _sub, TM ## matrix, TS ## scalar, TM ## array, TS ## scalar, -, TI) \
   DEFINTNDBINOP_OP (PFX ## _mul, TM ## matrix, TS ## scalar, TM ## array, TS ## scalar, *, TI) \
  \
   DEFBINOP (PFX ## _div, TM ## matrix, TS ## scalar) \
   { \
-    CAST_BINOP_ARGS (const octave_ ## TM ## matrix&, const octave_ ## TS ## scalar&); \
+    const octave_ ## TM ## matrix& v1 = dynamic_cast<const octave_ ## TM ## matrix&> (a1); \
+    const octave_ ## TS ## scalar& v2 = dynamic_cast<const octave_ ## TS ## scalar&> (a2); \
  \
     if (! v2.TS ## scalar_value ()) \
       warn_divide_by_zero (); \
  \
     octave_value retval = octave_value (v1.TM ## array_value () / v2.TS ## scalar_value ()); \
     return retval; \
   } \
  \
   /* DEFBINOP_FN (PFX ## _pow, TM ## matrix, TS ## scalar, xpow) */ \
  \
   /* DEFBINOP (PFX ## _ldiv, TM ## matrix, TS ## scalar) */ \
   /* { */ \
-  /* CAST_BINOP_ARGS (const octave_ ## TM ## matrix&, const octave_ ## TS ## scalar&); */ \
+  /* const octave_ ## TM ## matrix& v1 = dynamic_cast<const octave_ ## TM ## matrix&> (a1); */ \
+  /* const octave_ ## TS ## scalar& v2 = dynamic_cast<const octave_ ## TS ## scalar&> (a2); */ \
   /* */ \
   /* Matrix m1 = v1.TM ## matrix_value (); */ \
   /* Matrix m2 = v2.TM ## matrix_value (); */ \
   /* */ \
   /* return octave_value (xleftdiv (m1, m2)); */ \
   /* } */ \
  \
   DEFINTNDBINOP_OP (PFX ## _el_mul, TM ## matrix, TS ## scalar, TM ## array, TS ## scalar, *, TI) \
  \
   DEFBINOP (PFX ## _el_div, TM ## matrix, TS ## scalar) \
   { \
-    CAST_BINOP_ARGS (const octave_ ## TM ## matrix&, const octave_ ## TS ## scalar&); \
+    const octave_ ## TM ## matrix& v1 = dynamic_cast<const octave_ ## TM ## matrix&> (a1); \
+    const octave_ ## TS ## scalar& v2 = dynamic_cast<const octave_ ## TS ## scalar&> (a2); \
  \
     if (! v2.TS ## scalar_value ()) \
       warn_divide_by_zero (); \
  \
     octave_value retval = octave_value (v1.TM ## array_value () / v2.TS ## scalar_value ()); \
     return retval; \
   } \
  \
   DEFINTNDBINOP_FN (PFX ## _el_pow, TM ## matrix, TS ## scalar, TM ## array, TS ## scalar, elem_xpow, TI, .^) \
  \
   DEFBINOP (PFX ## _el_ldiv, TM ## matrix, TS ## scalar) \
   { \
-    CAST_BINOP_ARGS (const octave_ ## TM ## matrix&, const octave_ ## TS ## scalar&); \
+    const octave_ ## TM ## matrix& v1 = dynamic_cast<const octave_ ## TM ## matrix&> (a1); \
+    const octave_ ## TS ## scalar& v2 = dynamic_cast<const octave_ ## TS ## scalar&> (a2); \
     \
     octave_value retval = v2.TS ## scalar_value () / v1.TM ## array_value (); \
     return retval; \
   }
 
 #define OCTAVE_MS_INT_CMP_OPS(PFX, TM, TS) \
   DEFNDBINOP_FN (PFX ## _lt, TM ## matrix, TS ## scalar, TM ## array, TS ## scalar, mx_el_lt) \
   DEFNDBINOP_FN (PFX ## _le, TM ## matrix, TS ## scalar, TM ## array, TS ## scalar, mx_el_le) \
@@ -618,24 +640,24 @@ octave_value elem_xpow (FloatNDArray a, 
 
 // matrix unary ops.
 #define OCTAVE_M_INT_UNOPS(TYPE) \
  \
   DEFNDUNOP_OP (m_not, TYPE ## _matrix, TYPE ## _array, !) \
   DEFNDUNOP_OP (m_uplus, TYPE ## _matrix, TYPE ## _array, /* no-op */) \
   DEFUNOP (m_uminus, TYPE ## _matrix) \
   { \
-    CAST_UNOP_ARG (const octave_ ## TYPE ## _matrix &); \
+    const octave_ ## TYPE ## _matrix & v = dynamic_cast<const octave_ ## TYPE ## _matrix &> (a); \
     octave_value retval = octave_value (- v. TYPE ## _array_value ()); \
     return retval; \
   } \
  \
   DEFUNOP (m_transpose, TYPE ## _matrix) \
   { \
-    CAST_UNOP_ARG (const octave_ ## TYPE ## _matrix&); \
+    const octave_ ## TYPE ## _matrix& v = dynamic_cast<const octave_ ## TYPE ## _matrix&> (a); \
  \
     if (v.ndims () > 2) \
       error ("transpose not defined for N-D objects"); \
  \
     return octave_value (v.TYPE ## _array_value ().transpose ()); \
   } \
  \
   DEFNCUNOP_METHOD (m_incr, TYPE ## _matrix, increment) \
@@ -661,17 +683,18 @@ octave_value elem_xpow (FloatNDArray a, 
   DEFINTNDBINOP_FN (PFX ## _el_mul, T1 ## matrix, T2 ## matrix, T1 ## array, T2 ## array, product, T3, .*) \
  \
   DEFINTNDBINOP_FN (PFX ## _el_div, T1 ## matrix, T2 ## matrix, T1 ## array, T2 ## array, quotient, T3, ./) \
  \
   DEFINTNDBINOP_FN (PFX ## _el_pow, T1 ## matrix, T2 ## matrix, T1 ## array, T2 ## array, elem_xpow, T3, .^) \
  \
   DEFBINOP (PFX ## _el_ldiv, T1 ## matrix, T2 ## matrix) \
   { \
-    CAST_BINOP_ARGS (const octave_ ## T1 ## matrix&, const octave_ ## T2 ## matrix&); \
+    const octave_ ## T1 ## matrix& v1 = dynamic_cast<const octave_ ## T1 ## matrix&> (a1); \
+    const octave_ ## T2 ## matrix& v2 = dynamic_cast<const octave_ ## T2 ## matrix&> (a2); \
     \
     octave_value retval = octave_value (quotient (v2.T2 ## array_value (), v1.T1 ## array_value ())); \
     return retval; \
   }
 
 #define OCTAVE_MM_INT_CMP_OPS(PFX, T1, T2) \
   DEFNDBINOP_FN (PFX ## _lt, T1 ## matrix, T2 ## matrix, T1 ## array, T2 ## array, mx_el_lt) \
   DEFNDBINOP_FN (PFX ## _le, T1 ## matrix, T2 ## matrix, T1 ## array, T2 ## array, mx_el_le) \
@@ -802,17 +825,17 @@ octave_value elem_xpow (FloatNDArray a, 
       } \
     return octave_value (result); \
   }
 
 
 #define OCTAVE_MM_CONV(T1, T2) \
   DEFCONV (T1 ## m_ ## T2 ## m_conv, T1 ## matrix, T2 ## matrix) \
   { \
-    CAST_CONV_ARG (const octave_ ## T1 ## matrix&); \
+    const octave_ ## T1 ## matrix& v = dynamic_cast<const octave_ ## T1 ## matrix&> (a); \
  \
     return new octave_ ## T2 ## matrix (v.T2 ## array_value ()); \
   }
 
 #define OCTAVE_MM_INT_OPS(TYPE) \
   OCTAVE_M_INT_UNOPS (TYPE) \
   OCTAVE_MM_POW_OPS (TYPE, TYPE) \
   OCTAVE_MM_INT_ARITH_OPS (mm, TYPE ## _, TYPE ## _, TYPE) \
diff --git a/libinterp/operators/op-m-cm.cc b/libinterp/operators/op-m-cm.cc
--- a/libinterp/operators/op-m-cm.cc
+++ b/libinterp/operators/op-m-cm.cc
@@ -45,57 +45,61 @@ along with Octave; see the file COPYING.
 
 DEFNDBINOP_OP (add, matrix, complex_matrix, array, complex_array, +)
 DEFNDBINOP_OP (sub, matrix, complex_matrix, array, complex_array, -)
 
 DEFBINOP_OP (mul, matrix, complex_matrix, *)
 
 DEFBINOP (trans_mul, matrix, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
+  const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
+  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
 
   Matrix m1 = v1.matrix_value ();
   ComplexMatrix m2 = v2.complex_matrix_value ();
 
   return ComplexMatrix (xgemm (m1, real (m2), blas_trans, blas_no_trans),
                         xgemm (m1, imag (m2), blas_trans, blas_no_trans));
 }
 
 DEFBINOP (div, matrix, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
+  const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
+  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
   MatrixType typ = v2.matrix_type ();
 
   ComplexMatrix ret = xdiv (v1.matrix_value (),
                             v2.complex_matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, matrix, complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, matrix, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
+  const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
+  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
   MatrixType typ = v1.matrix_type ();
 
   ComplexMatrix ret = xleftdiv (v1.matrix_value (),
                                 v2.complex_matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP (trans_ldiv, matrix, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
+  const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
+  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
   MatrixType typ = v1.matrix_type ();
 
   ComplexMatrix ret = xleftdiv (v1.matrix_value (),
                                 v2.complex_matrix_value (), typ, blas_trans);
 
   v1.matrix_type (typ);
   return ret;
 }
@@ -108,29 +112,30 @@ DEFNDCMPLXCMPOP_FN (gt, matrix, complex_
 DEFNDCMPLXCMPOP_FN (ne, matrix, complex_matrix, array, complex_array, mx_el_ne)
 
 DEFNDBINOP_FN (el_mul, matrix, complex_matrix, array, complex_array, product)
 DEFNDBINOP_FN (el_div, matrix, complex_matrix, array, complex_array, quotient)
 DEFNDBINOP_FN (el_pow, matrix, complex_matrix, array, complex_array, elem_xpow)
 
 DEFBINOP (el_ldiv, matrix, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
+  const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
+  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
 
   return quotient (v2.complex_array_value (), v1.array_value ());
 }
 
 DEFNDBINOP_FN (el_and, matrix, complex_matrix, array, complex_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  matrix, complex_matrix, array, complex_array, mx_el_or)
 
 DEFNDCATOP_FN (m_cm, matrix, complex_matrix, array, complex_array, concat)
 
 DEFCONV (complex_matrix_conv, matrix, complex_matrix)
 {
-  CAST_CONV_ARG (const octave_matrix&);
+  const octave_matrix& v = dynamic_cast<const octave_matrix&> (a);
 
   return new octave_complex_matrix (ComplexNDArray (v.array_value ()));
 }
 
 void
 install_m_cm_ops (void)
 {
   INSTALL_BINOP (op_add, octave_matrix, octave_complex_matrix, add);
diff --git a/libinterp/operators/op-m-cs.cc b/libinterp/operators/op-m-cs.cc
--- a/libinterp/operators/op-m-cs.cc
+++ b/libinterp/operators/op-m-cs.cc
@@ -45,31 +45,33 @@ along with Octave; see the file COPYING.
 // matrix by complex scalar ops.
 
 DEFNDBINOP_OP (add, matrix, complex, array, complex, +)
 DEFNDBINOP_OP (sub, matrix, complex, array, complex, -)
 DEFNDBINOP_OP (mul, matrix, complex, array, complex, *)
 
 DEFBINOP (div, matrix, complex)
 {
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
+  const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
+  const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   Complex d = v2.complex_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v1.array_value () / d);
 }
 
 DEFBINOP_FN (pow, matrix, complex, xpow)
 
 DEFBINOP (ldiv, matrix, complex)
 {
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
+  const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
+  const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   Matrix m1 = v1.matrix_value ();
   ComplexMatrix m2 = v2.complex_matrix_value ();
   MatrixType typ = v1.matrix_type ();
 
   ComplexMatrix ret = xleftdiv (m1, m2, typ);
 
   v1.matrix_type (typ);
@@ -82,31 +84,33 @@ DEFNDCMPLXCMPOP_FN (eq, matrix, complex,
 DEFNDCMPLXCMPOP_FN (ge, matrix, complex, array, complex, mx_el_ge)
 DEFNDCMPLXCMPOP_FN (gt, matrix, complex, array, complex, mx_el_gt)
 DEFNDCMPLXCMPOP_FN (ne, matrix, complex, array, complex, mx_el_ne)
 
 DEFNDBINOP_OP (el_mul, matrix, complex, array, complex, *)
 
 DEFBINOP (el_div, matrix, complex)
 {
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
+  const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
+  const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   Complex d = v2.complex_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v1.array_value () / d);
 }
 
 DEFNDBINOP_FN (el_pow, matrix, complex, array, complex, elem_xpow)
 
 DEFBINOP (el_ldiv, matrix, complex)
 {
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
+  const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
+  const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   return x_el_div (v2.complex_value (), v1.array_value ());
 }
 
 DEFNDBINOP_FN (el_and, matrix, complex, array, complex, mx_el_and)
 DEFNDBINOP_FN (el_or, matrix, complex, array, complex, mx_el_or)
 
 DEFNDCATOP_FN (m_cs, matrix, complex, array, complex_array, concat)
diff --git a/libinterp/operators/op-m-m.cc b/libinterp/operators/op-m-m.cc
--- a/libinterp/operators/op-m-m.cc
+++ b/libinterp/operators/op-m-m.cc
@@ -38,17 +38,17 @@ along with Octave; see the file COPYING.
 // matrix unary ops.
 
 DEFNDUNOP_OP (not, matrix, array, !)
 DEFNDUNOP_OP (uplus, matrix, array, /* no-op */)
 DEFNDUNOP_OP (uminus, matrix, array, -)
 
 DEFUNOP (transpose, matrix)
 {
-  CAST_UNOP_ARG (const octave_matrix&);
+  const octave_matrix& v = dynamic_cast<const octave_matrix&> (a);
 
   if (v.ndims () > 2)
     error ("transpose not defined for N-D objects");
 
   return octave_value (v.matrix_value ().transpose ());
 }
 
 DEFNCUNOP_METHOD (incr, matrix, increment)
@@ -59,58 +59,63 @@ DEFNCUNOP_METHOD (changesign, matrix, ch
 
 DEFNDBINOP_OP (add, matrix, matrix, array, array, +)
 DEFNDBINOP_OP (sub, matrix, matrix, array, array, -)
 
 DEFBINOP_OP (mul, matrix, matrix, *)
 
 DEFBINOP (div, matrix, matrix)
 {
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
+  const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
+  const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
   MatrixType typ = v2.matrix_type ();
 
   Matrix ret = xdiv (v1.matrix_value (), v2.matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, matrix, matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, matrix, matrix)
 {
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
+  const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
+  const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
   MatrixType typ = v1.matrix_type ();
 
   Matrix ret = xleftdiv (v1.matrix_value (), v2.matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP (trans_mul, matrix, matrix)
 {
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
+  const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
+  const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
   return octave_value(xgemm (v1.matrix_value (), v2.matrix_value (),
                              blas_trans, blas_no_trans));
 }
 
 DEFBINOP (mul_trans, matrix, matrix)
 {
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
+  const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
+  const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
   return octave_value(xgemm (v1.matrix_value (), v2.matrix_value (),
                              blas_no_trans, blas_trans));
 }
 
 DEFBINOP (trans_ldiv, matrix, matrix)
 {
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
+  const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
+  const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
   MatrixType typ = v1.matrix_type ();
 
   Matrix ret = xleftdiv (v1.matrix_value (), v2.matrix_value (),
                          typ, blas_trans);
 
   v1.matrix_type (typ);
   return ret;
 }
@@ -123,17 +128,18 @@ DEFNDBINOP_FN (gt, matrix, matrix, array
 DEFNDBINOP_FN (ne, matrix, matrix, array, array, mx_el_ne)
 
 DEFNDBINOP_FN (el_mul, matrix, matrix, array, array, product)
 DEFNDBINOP_FN (el_div, matrix, matrix, array, array, quotient)
 DEFNDBINOP_FN (el_pow, matrix, matrix, array, array, elem_xpow)
 
 DEFBINOP (el_ldiv, matrix, matrix)
 {
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
+  const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
+  const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
 
   return octave_value (quotient (v2.array_value (), v1.array_value ()));
 }
 
 DEFNDBINOP_FN (el_and, matrix, matrix, array, array, mx_el_and)
 DEFNDBINOP_FN (el_or,  matrix, matrix, array, array, mx_el_or)
 DEFNDBINOP_FN (el_not_and, matrix, matrix, array, array, mx_el_not_and)
 DEFNDBINOP_FN (el_not_or,  matrix, matrix, array, array, mx_el_not_or)
@@ -150,17 +156,17 @@ DEFNULLASSIGNOP_FN (null_assign, matrix,
 
 DEFNDASSIGNOP_OP (assign_add, matrix, matrix, array, +=)
 DEFNDASSIGNOP_OP (assign_sub, matrix, matrix, array, -=)
 DEFNDASSIGNOP_FNOP (assign_el_mul, matrix, matrix, array, product_eq)
 DEFNDASSIGNOP_FNOP (assign_el_div, matrix, matrix, array, quotient_eq)
 
 CONVDECL (matrix_to_float_matrix)
 {
-  CAST_CONV_ARG (const octave_matrix&);
+  const octave_matrix& v = dynamic_cast<const octave_matrix&> (a);
 
   return new octave_float_matrix (FloatNDArray (v.array_value ()));
 }
 
 void
 install_m_m_ops (void)
 {
   INSTALL_UNOP (op_not, octave_matrix, not);
diff --git a/libinterp/operators/op-m-s.cc b/libinterp/operators/op-m-s.cc
--- a/libinterp/operators/op-m-s.cc
+++ b/libinterp/operators/op-m-s.cc
@@ -39,31 +39,33 @@ along with Octave; see the file COPYING.
 // matrix by scalar ops.
 
 DEFNDBINOP_OP (add, matrix, scalar, array, scalar, +)
 DEFNDBINOP_OP (sub, matrix, scalar, array, scalar, -)
 DEFNDBINOP_OP (mul, matrix, scalar, array, scalar, *)
 
 DEFBINOP (div, matrix, scalar)
 {
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
+  const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   double d = v2.double_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v1.array_value () / d);
 }
 
 DEFBINOP_FN (pow, matrix, scalar, xpow)
 
 DEFBINOP (ldiv, matrix, scalar)
 {
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
+  const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   Matrix m1 = v1.matrix_value ();
   Matrix m2 = v2.matrix_value ();
   MatrixType typ = v1.matrix_type ();
 
   Matrix ret = xleftdiv (m1, m2, typ);
 
   v1.matrix_type (typ);
@@ -76,31 +78,33 @@ DEFNDBINOP_FN (eq, matrix, scalar, array
 DEFNDBINOP_FN (ge, matrix, scalar, array, scalar, mx_el_ge)
 DEFNDBINOP_FN (gt, matrix, scalar, array, scalar, mx_el_gt)
 DEFNDBINOP_FN (ne, matrix, scalar, array, scalar, mx_el_ne)
 
 DEFNDBINOP_OP (el_mul, matrix, scalar, array, scalar, *)
 
 DEFBINOP (el_div, matrix, scalar)
 {
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
+  const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   double d = v2.double_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v1.array_value () / d);
 }
 
 DEFNDBINOP_FN (el_pow, matrix, scalar, array, scalar, elem_xpow)
 
 DEFBINOP (el_ldiv, matrix, scalar)
 {
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
+  const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   return x_el_div (v2.double_value (), v1.array_value ());
 }
 
 DEFNDBINOP_FN (el_and, matrix, scalar, array, scalar, mx_el_and)
 DEFNDBINOP_FN (el_or, matrix, scalar, array, scalar, mx_el_or)
 
 DEFNDCATOP_FN (m_s, matrix, scalar, array, array, concat)
diff --git a/libinterp/operators/op-m-scm.cc b/libinterp/operators/op-m-scm.cc
--- a/libinterp/operators/op-m-scm.cc
+++ b/libinterp/operators/op-m-scm.cc
@@ -44,17 +44,18 @@ along with Octave; see the file COPYING.
 
 DEFBINOP_OP (add, matrix, sparse_complex_matrix, +)
 DEFBINOP_OP (sub, matrix, sparse_complex_matrix, -)
 
 DEFBINOP_OP (mul, matrix, sparse_complex_matrix, *)
 
 DEFBINOP (div, matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_sparse_complex_matrix&);
+  const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -74,18 +75,18 @@ DEFBINOP (div, matrix, sparse_complex_ma
 
 DEFBINOPX (pow, matrix, sparse_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_matrix&,
-                   const octave_sparse_complex_matrix&);
+  const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
   MatrixType typ = v1.matrix_type ();
 
   ComplexMatrix ret = xleftdiv (v1.matrix_value (),
                                 v2.complex_matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
@@ -97,46 +98,47 @@ DEFBINOP_FN (ge, matrix, sparse_complex_
 DEFBINOP_FN (gt, matrix, sparse_complex_matrix, mx_el_gt)
 DEFBINOP_FN (ne, matrix, sparse_complex_matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, matrix, sparse_complex_matrix, product)
 DEFBINOP_FN (el_div, matrix, sparse_complex_matrix, quotient)
 
 DEFBINOP (el_pow, matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_matrix&,
-                   const octave_sparse_complex_matrix&);
+  const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   return octave_value
          (elem_xpow (SparseMatrix (v1.matrix_value ()),
                      v2.sparse_complex_matrix_value ()));
 }
 
 DEFBINOP (el_ldiv, matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_matrix&,
-                   const octave_sparse_complex_matrix&);
+  const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
   return octave_value
          (quotient (v2.sparse_complex_matrix_value (), v1.matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, matrix, sparse_complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  matrix, sparse_complex_matrix, mx_el_or)
 
 DEFCATOP (m_scm, matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (octave_matrix&, const octave_sparse_complex_matrix&);
+  octave_matrix& v1 = dynamic_cast<octave_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
   SparseMatrix tmp (v1.matrix_value ());
   return octave_value (tmp. concat (v2.sparse_complex_matrix_value (),
                                     ra_idx));
 }
 
 DEFCONV (sparse_complex_matrix_conv, matrix, sparse_complex_matrix)
 {
-  CAST_CONV_ARG (const octave_matrix&);
+  const octave_matrix& v = dynamic_cast<const octave_matrix&> (a);
   return new octave_sparse_complex_matrix
          (SparseComplexMatrix (v.complex_matrix_value ()));
 }
 
 void
 install_m_scm_ops (void)
 {
   INSTALL_BINOP (op_add, octave_matrix, octave_sparse_complex_matrix, add);
diff --git a/libinterp/operators/op-m-sm.cc b/libinterp/operators/op-m-sm.cc
--- a/libinterp/operators/op-m-sm.cc
+++ b/libinterp/operators/op-m-sm.cc
@@ -43,17 +43,18 @@ along with Octave; see the file COPYING.
 
 DEFBINOP_OP (add, matrix, sparse_matrix, +)
 DEFBINOP_OP (sub, matrix, sparse_matrix, -)
 
 DEFBINOP_OP (mul, matrix, sparse_matrix, *)
 
 DEFBINOP (div, matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_sparse_matrix&);
+  const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -72,17 +73,18 @@ DEFBINOP (div, matrix, sparse_matrix)
 
 DEFBINOPX (pow, matrix, sparse_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_sparse_matrix&);
+  const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
   MatrixType typ = v1.matrix_type ();
 
   Matrix ret = xleftdiv (v1.matrix_value (), v2.matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
@@ -95,43 +97,46 @@ DEFBINOP_FN (ge, matrix, sparse_matrix, 
 DEFBINOP_FN (gt, matrix, sparse_matrix, mx_el_gt)
 DEFBINOP_FN (ne, matrix, sparse_matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, matrix, sparse_matrix, product)
 DEFBINOP_FN (el_div, matrix, sparse_matrix, quotient)
 
 DEFBINOP (el_pow, matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_sparse_matrix&);
+  const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   return octave_value (elem_xpow (SparseMatrix (v1.matrix_value ()),
                                   v2.sparse_matrix_value ()));
 }
 
 DEFBINOP (el_ldiv, matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_sparse_matrix&);
+  const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   return octave_value
          (quotient (v2.sparse_matrix_value (), v1.matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, matrix, sparse_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  matrix, sparse_matrix, mx_el_or)
 
 DEFCATOP (m_sm, matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (octave_matrix&, const octave_sparse_matrix&);
+  octave_matrix& v1 = dynamic_cast<octave_matrix&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
   SparseMatrix tmp (v1.matrix_value ());
   return octave_value (tmp. concat (v2.sparse_matrix_value (), ra_idx));
 }
 
 DEFCONV (sparse_matrix_conv, matrix, sparse_matrix)
 {
-  CAST_CONV_ARG (const octave_matrix&);
+  const octave_matrix& v = dynamic_cast<const octave_matrix&> (a);
   return new octave_sparse_matrix (SparseMatrix (v.matrix_value ()));
 }
 
 DEFNDASSIGNOP_FN (assign, matrix, sparse_matrix, array, assign)
 
 void
 install_m_sm_ops (void)
 {
diff --git a/libinterp/operators/op-pm-pm.cc b/libinterp/operators/op-pm-pm.cc
--- a/libinterp/operators/op-pm-pm.cc
+++ b/libinterp/operators/op-pm-pm.cc
@@ -31,46 +31,49 @@ along with Octave; see the file COPYING.
 #include "ov-re-mat.h"
 #include "ov-scalar.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xpow.h"
 
 DEFUNOP (transpose, perm_matrix)
 {
-  CAST_UNOP_ARG (const octave_perm_matrix&);
+  const octave_perm_matrix& v = dynamic_cast<const octave_perm_matrix&> (a);
   return octave_value (v.perm_matrix_value ().transpose ());
 }
 
 DEFBINOP_OP (mul, perm_matrix, perm_matrix, *)
 
 DEFBINOP (div, perm_matrix, perm_matrix)
 {
-  CAST_BINOP_ARGS (const octave_perm_matrix&, const octave_perm_matrix&);
+  const octave_perm_matrix& v1 = dynamic_cast<const octave_perm_matrix&> (a1);
+  const octave_perm_matrix& v2 = dynamic_cast<const octave_perm_matrix&> (a2);
 
   return (v1.perm_matrix_value () * v2.perm_matrix_value ().inverse ());
 }
 
 DEFBINOP (ldiv, perm_matrix, perm_matrix)
 {
-  CAST_BINOP_ARGS (const octave_perm_matrix&, const octave_perm_matrix&);
+  const octave_perm_matrix& v1 = dynamic_cast<const octave_perm_matrix&> (a1);
+  const octave_perm_matrix& v2 = dynamic_cast<const octave_perm_matrix&> (a2);
 
   return (v1.perm_matrix_value ().inverse () * v2.perm_matrix_value ());
 }
 
 DEFBINOP (pow, perm_matrix, scalar)
 {
-  CAST_BINOP_ARGS (const octave_perm_matrix&, const octave_scalar&);
+  const octave_perm_matrix& v1 = dynamic_cast<const octave_perm_matrix&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   return xpow (v1.perm_matrix_value (), v2.scalar_value ());
 }
 
 CONVDECL (perm_matrix_to_matrix)
 {
-  CAST_CONV_ARG (const octave_perm_matrix&);
+  const octave_perm_matrix& v = dynamic_cast<const octave_perm_matrix&> (a);
 
   return new octave_matrix (v.matrix_value ());
 }
 
 void
 install_pm_pm_ops (void)
 {
   INSTALL_UNOP (op_transpose, octave_perm_matrix, transpose);
diff --git a/libinterp/operators/op-pm-scm.cc b/libinterp/operators/op-pm-scm.cc
--- a/libinterp/operators/op-pm-scm.cc
+++ b/libinterp/operators/op-pm-scm.cc
@@ -32,62 +32,62 @@ along with Octave; see the file COPYING.
 
 #include "ov-perm.h"
 #include "ov-cx-sparse.h"
 
 // permutation matrix by sparse matrix ops
 
 DEFBINOP (mul_pm_scm, perm_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_perm_matrix&,
-                   const octave_sparse_complex_matrix&);
+  const octave_perm_matrix& v1 = dynamic_cast<const octave_perm_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.sparse_matrix_value () * d);
     }
   else if (v1.rows () == 1 && v1.columns () == 1)
     return octave_value (v2.sparse_complex_matrix_value ());
   else
     return v1.perm_matrix_value  () * v2.sparse_complex_matrix_value ();
 }
 
 DEFBINOP (ldiv_pm_scm, perm_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_perm_matrix&,
-                   const octave_sparse_complex_matrix&);
+  const octave_perm_matrix& v1 = dynamic_cast<const octave_perm_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   return v1.perm_matrix_value ().inverse () * v2.sparse_complex_matrix_value ();
 }
 
 // sparse matrix by diagonal matrix ops
 
 DEFBINOP (mul_scm_pm, sparse_complex_matrix, perm_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
-                   const octave_perm_matrix&);
+  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_perm_matrix& v2 = dynamic_cast<const octave_perm_matrix&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       std::complex<double> d = v1.scalar_value ();
 
       return octave_value (d * v2.sparse_matrix_value ());
     }
   else if (v2.rows () == 1 && v2.columns () == 1)
     return octave_value (v1.sparse_complex_matrix_value ());
   else
     return v1.sparse_complex_matrix_value  () * v2.perm_matrix_value ();
 }
 
 DEFBINOP (div_scm_pm, sparse_complex_matrix, perm_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
-                   const octave_perm_matrix&);
+  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_perm_matrix& v2 = dynamic_cast<const octave_perm_matrix&> (a2);
 
   return v1.sparse_complex_matrix_value () * v2.perm_matrix_value ().inverse ();
 }
 
 void
 install_pm_scm_ops (void)
 {
   INSTALL_BINOP (op_mul, octave_perm_matrix, octave_sparse_complex_matrix,
diff --git a/libinterp/operators/op-pm-sm.cc b/libinterp/operators/op-pm-sm.cc
--- a/libinterp/operators/op-pm-sm.cc
+++ b/libinterp/operators/op-pm-sm.cc
@@ -32,58 +32,62 @@ along with Octave; see the file COPYING.
 
 #include "ov-perm.h"
 #include "ov-re-sparse.h"
 
 // permutation matrix by sparse matrix ops
 
 DEFBINOP (mul_pm_sm, perm_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_perm_matrix&, const octave_sparse_matrix&);
+  const octave_perm_matrix& v1 = dynamic_cast<const octave_perm_matrix&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       return octave_value (v1.sparse_matrix_value () * d);
     }
   else if (v1.rows () == 1 && v1.columns () == 1)
     return octave_value (v2.sparse_matrix_value ());
   else
     return v1.perm_matrix_value  () * v2.sparse_matrix_value ();
 }
 
 DEFBINOP (ldiv_pm_sm, perm_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_perm_matrix&, const octave_sparse_matrix&);
+  const octave_perm_matrix& v1 = dynamic_cast<const octave_perm_matrix&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   return v1.perm_matrix_value ().inverse () * v2.sparse_matrix_value ();
 }
 
 // sparse matrix by diagonal matrix ops
 
 DEFBINOP (mul_sm_pm, sparse_matrix, perm_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_perm_matrix&);
+  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_perm_matrix& v2 = dynamic_cast<const octave_perm_matrix&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       double d = v1.scalar_value ();
 
       return octave_value (d * v2.sparse_matrix_value ());
     }
   else if (v2.rows () == 1 && v2.columns () == 1)
     return octave_value (v1.sparse_matrix_value ());
   else
     return v1.sparse_matrix_value  () * v2.perm_matrix_value ();
 }
 
 DEFBINOP (div_sm_pm, sparse_matrix, perm_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_perm_matrix&);
+  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_perm_matrix& v2 = dynamic_cast<const octave_perm_matrix&> (a2);
 
   return v1.sparse_matrix_value () * v2.perm_matrix_value ().inverse ();
 }
 
 void
 install_pm_sm_ops (void)
 {
   INSTALL_BINOP (op_mul, octave_perm_matrix, octave_sparse_matrix,
diff --git a/libinterp/operators/op-pm-template.cc b/libinterp/operators/op-pm-template.cc
--- a/libinterp/operators/op-pm-template.cc
+++ b/libinterp/operators/op-pm-template.cc
@@ -47,32 +47,35 @@ along with Octave; see the file COPYING.
 #  define RMATRIX_VALUE CONCAT2(RMATRIX, _value)
 #else
 #  define LMATRIX_VALUE CONCAT2(LMATRIX, _value)
 #  define RMATRIX_VALUE perm_matrix_value
 #endif
 
 DEFBINOP (mul, LMATRIX, RMATRIX)
 {
-  CAST_BINOP_ARGS (const OCTAVE_LMATRIX&, const OCTAVE_RMATRIX&);
+  const OCTAVE_LMATRIX& v1 = dynamic_cast<const OCTAVE_LMATRIX&> (a1);
+  const OCTAVE_RMATRIX& v2 = dynamic_cast<const OCTAVE_RMATRIX&> (a2);
 
   return v1.LMATRIX_VALUE () * v2.RMATRIX_VALUE ();
 }
 
 #ifdef LEFT
 DEFBINOP (ldiv, LMATRIX, RMATRIX)
 {
-  CAST_BINOP_ARGS (const OCTAVE_LMATRIX&, const OCTAVE_RMATRIX&);
+  const OCTAVE_LMATRIX& v1 = dynamic_cast<const OCTAVE_LMATRIX&> (a1);
+  const OCTAVE_RMATRIX& v2 = dynamic_cast<const OCTAVE_RMATRIX&> (a2);
 
   return v1.perm_matrix_value ().inverse () * v2.RMATRIX_VALUE ();
 }
 #else
 DEFBINOP (div, LMATRIX, RMATRIX)
 {
-  CAST_BINOP_ARGS (const OCTAVE_LMATRIX&, const OCTAVE_RMATRIX&);
+  const OCTAVE_LMATRIX& v1 = dynamic_cast<const OCTAVE_LMATRIX&> (a1);
+  const OCTAVE_RMATRIX& v2 = dynamic_cast<const OCTAVE_RMATRIX&> (a2);
 
   return v1.LMATRIX_VALUE () * v2.perm_matrix_value ().inverse ();
 }
 #endif
 
 
 #define SHORT_NAME CONCAT3(LSHORT, _, RSHORT)
 #define INST_NAME CONCAT3(install_, SHORT_NAME, _ops)
diff --git a/libinterp/operators/op-range.cc b/libinterp/operators/op-range.cc
--- a/libinterp/operators/op-range.cc
+++ b/libinterp/operators/op-range.cc
@@ -40,27 +40,27 @@ along with Octave; see the file COPYING.
 #include "ov-null-mat.h"
 #include "ops.h"
 #include "xpow.h"
 
 // range unary ops.
 
 DEFUNOP (not, range)
 {
-  CAST_UNOP_ARG (const octave_range&);
+  const octave_range& v = dynamic_cast<const octave_range&> (a);
 
   return octave_value (! v.matrix_value ());
 }
 
 DEFUNOP_OP (uplus, range, /* no-op */)
 DEFUNOP_OP (uminus, range, -)
 
 DEFUNOP (transpose, range)
 {
-  CAST_UNOP_ARG (const octave_range&);
+  const octave_range& v = dynamic_cast<const octave_range&> (a);
 
   return octave_value (v.matrix_value ().transpose ());
 }
 
 DEFBINOP_OP (addrs, range, scalar, +)
 DEFBINOP_OP (addsr, scalar, range, +)
 DEFBINOP_OP (subrs, range, scalar, -)
 DEFBINOP_OP (subsr, scalar, range, -)
@@ -83,17 +83,17 @@ DEFNDCATOP_FN (m_r, matrix, range, array
 DEFNDCATOP_FN (cs_r, complex, range, complex_array, array, concat)
 DEFNDCATOP_FN (cm_r, complex_matrix, range, complex_array, array, concat)
 DEFNDCATOP_FN (b_r, bool, range, array, array, concat)
 DEFNDCATOP_FN (bm_r, bool_matrix, range, array, array, concat)
 DEFNDCATOP_FN (chm_r, char_matrix, range, char_array, array, concat)
 
 CONVDECL (range_to_matrix)
 {
-  CAST_CONV_ARG (const octave_range&);
+  const octave_range& v = dynamic_cast<const octave_range&> (a);
 
   return new octave_matrix (v.array_value ());
 }
 
 void
 install_range_ops (void)
 {
   INSTALL_UNOP (op_not, octave_range, not);
diff --git a/libinterp/operators/op-s-cm.cc b/libinterp/operators/op-s-cm.cc
--- a/libinterp/operators/op-s-cm.cc
+++ b/libinterp/operators/op-s-cm.cc
@@ -45,33 +45,35 @@ along with Octave; see the file COPYING.
 // scalar by complex matrix ops.
 
 DEFNDBINOP_OP (add, scalar, complex_matrix, scalar, complex_array, +)
 DEFNDBINOP_OP (sub, scalar, complex_matrix, scalar, complex_array, -)
 DEFNDBINOP_OP (mul, scalar, complex_matrix, scalar, complex_array, *)
 
 DEFBINOP (div, scalar, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
+  const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
+  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
 
   Matrix m1 = v1.matrix_value ();
   ComplexMatrix m2 = v2.complex_matrix_value ();
   MatrixType typ = v2.matrix_type ();
 
   ComplexMatrix ret = xdiv (m1, m2, typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP_FN (pow, scalar, complex_matrix, xpow)
 
 DEFBINOP (ldiv, scalar, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
+  const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
+  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
 
   double d = v1.double_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v2.complex_array_value () / d);
 }
@@ -84,34 +86,35 @@ DEFNDCMPLXCMPOP_FN (gt, scalar, complex_
 DEFNDCMPLXCMPOP_FN (ne, scalar, complex_matrix, scalar, complex_array, mx_el_ne)
 
 DEFNDBINOP_OP (el_mul, scalar, complex_matrix, scalar, complex_array, *)
 DEFNDBINOP_FN (el_div, scalar, complex_matrix, scalar, complex_array, x_el_div)
 DEFNDBINOP_FN (el_pow, scalar, complex_matrix, scalar, complex_array, elem_xpow)
 
 DEFBINOP (el_ldiv, scalar, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
+  const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
+  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
 
   double d = v1.double_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v2.complex_array_value () / d);
 }
 
 DEFNDBINOP_FN (el_and, scalar, complex_matrix, scalar, complex_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  scalar, complex_matrix, scalar, complex_array, mx_el_or)
 
 DEFNDCATOP_FN (s_cm, scalar, complex_matrix, array, complex_array, concat)
 
 DEFCONV (complex_matrix_conv, scalar, complex_matrix)
 {
-  CAST_CONV_ARG (const octave_scalar&);
+  const octave_scalar& v = dynamic_cast<const octave_scalar&> (a);
 
   return new octave_complex_matrix (ComplexMatrix (v.matrix_value ()));
 }
 
 void
 install_s_cm_ops (void)
 {
   INSTALL_BINOP (op_add, octave_scalar, octave_complex_matrix, add);
diff --git a/libinterp/operators/op-s-cs.cc b/libinterp/operators/op-s-cs.cc
--- a/libinterp/operators/op-s-cs.cc
+++ b/libinterp/operators/op-s-cs.cc
@@ -40,31 +40,33 @@ along with Octave; see the file COPYING.
 // scalar by complex scalar ops.
 
 DEFBINOP_OP (add, scalar, complex, +)
 DEFBINOP_OP (sub, scalar, complex, -)
 DEFBINOP_OP (mul, scalar, complex, *)
 
 DEFBINOP (div, scalar, complex)
 {
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_complex&);
+  const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
+  const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   Complex d = v2.complex_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v1.double_value () / d);
 }
 
 DEFBINOP_FN (pow, scalar, complex, xpow)
 
 DEFBINOP (ldiv, scalar, complex)
 {
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_complex&);
+  const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
+  const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   double d = v1.double_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v2.complex_value () / d);
 }
@@ -75,50 +77,54 @@ DEFCMPLXCMPOP_OP (eq, scalar, complex, =
 DEFCMPLXCMPOP_OP (ge, scalar, complex, >=)
 DEFCMPLXCMPOP_OP (gt, scalar, complex, >)
 DEFCMPLXCMPOP_OP (ne, scalar, complex, !=)
 
 DEFBINOP_OP (el_mul, scalar, complex, *)
 
 DEFBINOP (el_div, scalar, complex)
 {
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_complex&);
+  const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
+  const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   Complex d = v2.complex_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v1.double_value () / d);
 }
 
 DEFBINOP_FN (el_pow, scalar, complex, xpow)
 
 DEFBINOP (el_ldiv, scalar, complex)
 {
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_complex&);
+  const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
+  const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   double d = v1.double_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v2.complex_value () / d);
 }
 
 DEFBINOP (el_and, scalar, complex)
 {
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_complex&);
+  const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
+  const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   return octave_value (v1.double_value () && (v2.complex_value () != 0.0));
 }
 
 DEFBINOP (el_or, scalar, complex)
 {
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_complex&);
+  const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
+  const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   return octave_value (v1.double_value () || (v2.complex_value () != 0.0));
 }
 
 DEFNDCATOP_FN (s_cs, scalar, complex, array, complex_array, concat)
 
 void
 install_s_cs_ops (void)
diff --git a/libinterp/operators/op-s-m.cc b/libinterp/operators/op-s-m.cc
--- a/libinterp/operators/op-s-m.cc
+++ b/libinterp/operators/op-s-m.cc
@@ -39,33 +39,35 @@ along with Octave; see the file COPYING.
 // scalar by matrix ops.
 
 DEFNDBINOP_OP (add, scalar, matrix, scalar, array, +)
 DEFNDBINOP_OP (sub, scalar, matrix, scalar, array, -)
 DEFNDBINOP_OP (mul, scalar, matrix, scalar, array, *)
 
 DEFBINOP (div, scalar, matrix)
 {
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
+  const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
+  const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
 
   Matrix m1 = v1.matrix_value ();
   Matrix m2 = v2.matrix_value ();
   MatrixType typ = v2.matrix_type ();
 
   Matrix ret = xdiv (m1, m2, typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP_FN (pow, scalar, matrix, xpow)
 
 DEFBINOP (ldiv, scalar, matrix)
 {
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
+  const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
+  const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
 
   double d = v1.double_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v2.array_value () / d);
 }
@@ -78,34 +80,35 @@ DEFNDBINOP_FN (gt, scalar, matrix, scala
 DEFNDBINOP_FN (ne, scalar, matrix, scalar, array, mx_el_ne)
 
 DEFNDBINOP_OP (el_mul, scalar, matrix, scalar, array, *)
 DEFNDBINOP_FN (el_div, scalar, matrix, scalar, array, x_el_div)
 DEFNDBINOP_FN (el_pow, scalar, matrix, scalar, array, elem_xpow)
 
 DEFBINOP (el_ldiv, scalar, matrix)
 {
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
+  const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
+  const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
 
   double d = v1.double_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v2.array_value () / d);
 }
 
 DEFNDBINOP_FN (el_and, scalar, matrix, scalar, array, mx_el_and)
 DEFNDBINOP_FN (el_or,  scalar, matrix, scalar, array, mx_el_or)
 
 DEFNDCATOP_FN (s_m, scalar, matrix, array, array, concat)
 
 DEFCONV (matrix_conv, scalar, matrix)
 {
-  CAST_CONV_ARG (const octave_scalar&);
+  const octave_scalar& v = dynamic_cast<const octave_scalar&> (a);
 
   return new octave_matrix (v.matrix_value ());
 }
 
 void
 install_s_m_ops (void)
 {
   INSTALL_BINOP (op_add, octave_scalar, octave_matrix, add);
diff --git a/libinterp/operators/op-s-s.cc b/libinterp/operators/op-s-s.cc
--- a/libinterp/operators/op-s-s.cc
+++ b/libinterp/operators/op-s-s.cc
@@ -38,17 +38,17 @@ along with Octave; see the file COPYING.
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // scalar unary ops.
 
 DEFUNOP (not, scalar)
 {
-  CAST_UNOP_ARG (const octave_scalar&);
+  const octave_scalar& v = dynamic_cast<const octave_scalar&> (a);
   double x = v.scalar_value ();
   if (xisnan (x))
     err_nan_to_logical_conversion ();
 
   return octave_value (x == 0.0);
 }
 
 DEFUNOP_OP (uplus, scalar, /* no-op */)
@@ -62,31 +62,33 @@ DEFNCUNOP_METHOD (decr, scalar, decremen
 // scalar by scalar ops.
 
 DEFBINOP_OP (add, scalar, scalar, +)
 DEFBINOP_OP (sub, scalar, scalar, -)
 DEFBINOP_OP (mul, scalar, scalar, *)
 
 DEFBINOP (div, scalar, scalar)
 {
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_scalar&);
+  const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   double d = v2.double_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v1.double_value () / d);
 }
 
 DEFBINOP_FN (pow, scalar, scalar, xpow)
 
 DEFBINOP (ldiv, scalar, scalar)
 {
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_scalar&);
+  const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   double d = v1.double_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v2.double_value () / d);
 }
@@ -97,31 +99,33 @@ DEFBINOP_OP (eq, scalar, scalar, ==)
 DEFBINOP_OP (ge, scalar, scalar, >=)
 DEFBINOP_OP (gt, scalar, scalar, >)
 DEFBINOP_OP (ne, scalar, scalar, !=)
 
 DEFBINOP_OP (el_mul, scalar, scalar, *)
 
 DEFBINOP (el_div, scalar, scalar)
 {
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_scalar&);
+  const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   double d = v2.double_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v1.double_value () / d);
 }
 
 DEFBINOP_FN (el_pow, scalar, scalar, xpow)
 
 DEFBINOP (el_ldiv, scalar, scalar)
 {
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_scalar&);
+  const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   double d = v1.double_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   return octave_value (v2.double_value () / d);
 }
diff --git a/libinterp/operators/op-s-scm.cc b/libinterp/operators/op-s-scm.cc
--- a/libinterp/operators/op-s-scm.cc
+++ b/libinterp/operators/op-s-scm.cc
@@ -44,17 +44,18 @@ along with Octave; see the file COPYING.
 // scalar by sparse complex matrix ops.
 
 DEFBINOP_OP (add, scalar, sparse_complex_matrix, +)
 DEFBINOP_OP (sub, scalar, sparse_complex_matrix, -)
 DEFBINOP_OP (mul, scalar, sparse_complex_matrix, *)
 
 DEFBINOP (div, scalar, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_sparse_complex_matrix&);
+  const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
+  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -68,25 +69,25 @@ DEFBINOP (div, scalar, sparse_complex_ma
       ComplexMatrix ret = xdiv (m1, m2, typ);
       v2.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOP (pow, scalar, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_scalar&,
-                   const octave_sparse_complex_matrix&);
+  const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
+  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
   return xpow (v1.scalar_value (), v2.complex_matrix_value ());
 }
 
 DEFBINOP (ldiv, scalar, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_scalar&,
-                   const octave_sparse_complex_matrix&);
+  const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
+  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   double d = v1.double_value ();
   octave_value retval;
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   retval = octave_value (v2.sparse_complex_matrix_value () / d);
@@ -102,18 +103,18 @@ DEFBINOP_FN (gt, scalar, sparse_complex_
 DEFBINOP_FN (ne, scalar, sparse_complex_matrix, mx_el_ne)
 
 DEFBINOP_OP (el_mul, scalar, sparse_complex_matrix, *)
 DEFBINOP_FN (el_div, scalar, sparse_complex_matrix, x_el_div)
 DEFBINOP_FN (el_pow, scalar, sparse_complex_matrix, elem_xpow)
 
 DEFBINOP (el_ldiv, scalar, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_scalar&,
-                   const octave_sparse_complex_matrix&);
+  const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
+  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   double d = v1.double_value ();
   octave_value retval;
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   retval = octave_value (v2.sparse_complex_matrix_value () / d);
@@ -121,25 +122,26 @@ DEFBINOP (el_ldiv, scalar, sparse_comple
   return retval;
 }
 
 DEFBINOP_FN (el_and, scalar, sparse_complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or, scalar, sparse_complex_matrix, mx_el_or)
 
 DEFCATOP (s_scm, scalar, sparse_compelx_matrix)
 {
-  CAST_BINOP_ARGS (octave_scalar&, const octave_sparse_complex_matrix&);
+  octave_scalar& v1 = dynamic_cast<octave_scalar&> (a1);
+  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
   SparseMatrix tmp (1, 1, v1.scalar_value ());
   return octave_value
          (tmp.concat (v2.sparse_complex_matrix_value (), ra_idx));
 }
 
 DEFCONV (sparse_complex_matrix_conv, scalar, sparse_complex_matrix)
 {
-  CAST_CONV_ARG (const octave_scalar&);
+  const octave_scalar& v = dynamic_cast<const octave_scalar&> (a);
 
   return new octave_sparse_complex_matrix
          (SparseComplexMatrix (v.complex_matrix_value ()));
 }
 
 void
 install_s_scm_ops (void)
 {
diff --git a/libinterp/operators/op-s-sm.cc b/libinterp/operators/op-s-sm.cc
--- a/libinterp/operators/op-s-sm.cc
+++ b/libinterp/operators/op-s-sm.cc
@@ -40,17 +40,18 @@ along with Octave; see the file COPYING.
 // scalar by sparse matrix ops.
 
 DEFBINOP_OP (add, scalar, sparse_matrix, +)
 DEFBINOP_OP (sub, scalar, sparse_matrix, -)
 DEFBINOP_OP (mul, scalar, sparse_matrix, *)
 
 DEFBINOP (div, scalar, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_sparse_matrix&);
+  const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -64,23 +65,25 @@ DEFBINOP (div, scalar, sparse_matrix)
       Matrix ret = xdiv (m1, m2, typ);
       v2.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOP (pow, scalar, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_sparse_matrix&);
+  const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
   return xpow (v1.scalar_value (), v2.matrix_value ());
 }
 
 DEFBINOP (ldiv, scalar, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_sparse_matrix&);
+  const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   double d = v1.double_value ();
   octave_value retval;
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   retval = octave_value (v2.sparse_matrix_value () / d);
@@ -96,17 +99,18 @@ DEFBINOP_FN (gt, scalar, sparse_matrix, 
 DEFBINOP_FN (ne, scalar, sparse_matrix, mx_el_ne)
 
 DEFBINOP_OP (el_mul, scalar, sparse_matrix, *)
 DEFBINOP_FN (el_div, scalar, sparse_matrix, x_el_div)
 DEFBINOP_FN (el_pow, scalar, sparse_matrix, elem_xpow)
 
 DEFBINOP (el_ldiv, scalar, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_scalar&, const octave_sparse_matrix&);
+  const octave_scalar& v1 = dynamic_cast<const octave_scalar&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   double d = v1.double_value ();
   octave_value retval;
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   retval = octave_value (v2.sparse_matrix_value () / d);
@@ -114,24 +118,25 @@ DEFBINOP (el_ldiv, scalar, sparse_matrix
   return retval;
 }
 
 DEFBINOP_FN (el_and, scalar, sparse_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  scalar, sparse_matrix, mx_el_or)
 
 DEFCATOP (s_sm, scalar, sparse_matrix)
 {
-  CAST_BINOP_ARGS (octave_scalar&, const octave_sparse_matrix&);
+  octave_scalar& v1 = dynamic_cast<octave_scalar&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
   SparseMatrix tmp (1, 1, v1.scalar_value ());
   return octave_value (tmp.concat (v2.sparse_matrix_value (), ra_idx));
 }
 
 DEFCONV (sparse_matrix_conv, scalar, sparse_matrix)
 {
-  CAST_CONV_ARG (const octave_scalar&);
+  const octave_scalar& v = dynamic_cast<const octave_scalar&> (a);
 
   return new octave_sparse_matrix (SparseMatrix (v.matrix_value ()));
 }
 
 void
 install_s_sm_ops (void)
 {
   INSTALL_BINOP (op_add, octave_scalar, octave_sparse_matrix, add);
diff --git a/libinterp/operators/op-sbm-b.cc b/libinterp/operators/op-sbm-b.cc
--- a/libinterp/operators/op-sbm-b.cc
+++ b/libinterp/operators/op-sbm-b.cc
@@ -49,41 +49,45 @@ along with Octave; see the file COPYING.
 DEFBINOP_FN (ne, sparse_bool_matrix, bool, mx_el_ne)
 DEFBINOP_FN (eq, sparse_bool_matrix, bool, mx_el_eq)
 
 DEFBINOP_FN (el_and, sparse_bool_matrix, bool, mx_el_and)
 DEFBINOP_FN (el_or, sparse_bool_matrix, bool, mx_el_or)
 
 DEFCATOP (sbm_b, sparse_bool_matrix, bool)
 {
-  CAST_BINOP_ARGS (octave_sparse_bool_matrix&, const octave_bool&);
+  octave_sparse_bool_matrix& v1 = dynamic_cast<octave_sparse_bool_matrix&> (a1);
+  const octave_bool& v2 = dynamic_cast<const octave_bool&> (a2);
 
   SparseBoolMatrix tmp (1, 1, v2.bool_value ());
   return octave_value (v1.sparse_bool_matrix_value (). concat (tmp, ra_idx));
 }
 
 DEFCATOP (sm_b, sparse_matrix, bool)
 {
-  CAST_BINOP_ARGS (octave_sparse_matrix&, const octave_bool&);
+  octave_sparse_matrix& v1 = dynamic_cast<octave_sparse_matrix&> (a1);
+  const octave_bool& v2 = dynamic_cast<const octave_bool&> (a2);
 
   SparseMatrix tmp (1, 1, v2.scalar_value ());
   return octave_value (v1.sparse_matrix_value (). concat (tmp, ra_idx));
 }
 
 DEFCATOP (sbm_s, sparse_bool_matrix, scalar)
 {
-  CAST_BINOP_ARGS (octave_sparse_bool_matrix&, const octave_scalar&);
+  octave_sparse_bool_matrix& v1 = dynamic_cast<octave_sparse_bool_matrix&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   SparseMatrix tmp (1, 1, v2.scalar_value ());
   return octave_value (v1.sparse_matrix_value (). concat (tmp, ra_idx));
 }
 
 DEFASSIGNOP (assign, sparse_bool_matrix, bool)
 {
-  CAST_BINOP_ARGS (octave_sparse_bool_matrix&, const octave_bool&);
+  octave_sparse_bool_matrix& v1 = dynamic_cast<octave_sparse_bool_matrix&> (a1);
+  const octave_bool& v2 = dynamic_cast<const octave_bool&> (a2);
 
   SparseBoolMatrix tmp (1, 1, v2.bool_value ());
   v1.assign (idx, tmp);
   return octave_value ();
 }
 
 static octave_value
 oct_assignop_conv_and_assign (octave_base_value& a1,
diff --git a/libinterp/operators/op-sbm-bm.cc b/libinterp/operators/op-sbm-bm.cc
--- a/libinterp/operators/op-sbm-bm.cc
+++ b/libinterp/operators/op-sbm-bm.cc
@@ -54,41 +54,45 @@ along with Octave; see the file COPYING.
 DEFBINOP_FN (eq, sparse_bool_matrix, bool_matrix, mx_el_eq)
 DEFBINOP_FN (ne, sparse_bool_matrix, bool_matrix, mx_el_ne)
 
 DEFBINOP_FN (el_and, sparse_bool_matrix, bool_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_bool_matrix, bool_matrix, mx_el_or)
 
 DEFCATOP (sbm_bm, sparse_bool_matrix, bool_matrix)
 {
-  CAST_BINOP_ARGS (octave_sparse_bool_matrix&, const octave_bool_matrix&);
+  octave_sparse_bool_matrix& v1 = dynamic_cast<octave_sparse_bool_matrix&> (a1);
+  const octave_bool_matrix& v2 = dynamic_cast<const octave_bool_matrix&> (a2);
 
   SparseBoolMatrix tmp (v2.bool_matrix_value ());
   return octave_value (v1.sparse_bool_matrix_value (). concat (tmp, ra_idx));
 }
 
 DEFCATOP (sbm_m, sparse_bool_matrix, matrix)
 {
-  CAST_BINOP_ARGS (octave_sparse_bool_matrix&, const octave_matrix&);
+  octave_sparse_bool_matrix& v1 = dynamic_cast<octave_sparse_bool_matrix&> (a1);
+  const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
 
   SparseMatrix tmp (v2.matrix_value ());
   return octave_value (v1.sparse_matrix_value (). concat (tmp, ra_idx));
 }
 
 DEFCATOP (sm_bm, sparse_matrix, bool_matrix)
 {
-  CAST_BINOP_ARGS (octave_sparse_matrix&, const octave_bool_matrix&);
+  octave_sparse_matrix& v1 = dynamic_cast<octave_sparse_matrix&> (a1);
+  const octave_bool_matrix& v2 = dynamic_cast<const octave_bool_matrix&> (a2);
 
   SparseMatrix tmp (v2.matrix_value ());
   return octave_value (v1.sparse_matrix_value (). concat (tmp, ra_idx));
 }
 
 DEFASSIGNOP (assign, sparse_bool_matrix, bool_matrix)
 {
-  CAST_BINOP_ARGS (octave_sparse_bool_matrix&, const octave_bool_matrix&);
+  octave_sparse_bool_matrix& v1 = dynamic_cast<octave_sparse_bool_matrix&> (a1);
+  const octave_bool_matrix& v2 = dynamic_cast<const octave_bool_matrix&> (a2);
 
   v1.assign (idx, SparseBoolMatrix (v2.bool_matrix_value ()));
   return octave_value ();
 }
 
 DEFNULLASSIGNOP_FN (null_assign, sparse_bool_matrix, delete_elements)
 
 static octave_value
diff --git a/libinterp/operators/op-sbm-sbm.cc b/libinterp/operators/op-sbm-sbm.cc
--- a/libinterp/operators/op-sbm-sbm.cc
+++ b/libinterp/operators/op-sbm-sbm.cc
@@ -37,29 +37,29 @@ along with Octave; see the file COPYING.
 #include "ov-bool-sparse.h"
 
 // unary sparse bool matrix ops.
 
 DEFUNOP_OP (not, sparse_bool_matrix, !)
 
 DEFUNOP (uplus, sparse_bool_matrix)
 {
-  CAST_UNOP_ARG (const octave_sparse_bool_matrix&);
+  const octave_sparse_bool_matrix& v = dynamic_cast<const octave_sparse_bool_matrix&> (a);
   return octave_value (v.sparse_matrix_value ());
 }
 
 DEFUNOP (uminus, sparse_bool_matrix)
 {
-  CAST_UNOP_ARG (const octave_sparse_bool_matrix&);
+  const octave_sparse_bool_matrix& v = dynamic_cast<const octave_sparse_bool_matrix&> (a);
   return octave_value (- v.sparse_matrix_value ());
 }
 
 DEFUNOP (transpose, sparse_bool_matrix)
 {
-  CAST_UNOP_ARG (const octave_sparse_bool_matrix&);
+  const octave_sparse_bool_matrix& v = dynamic_cast<const octave_sparse_bool_matrix&> (a);
   return octave_value (v.sparse_bool_matrix_value ().transpose ());
 }
 
 // sparse bool matrix by sparse bool matrix ops.
 
 DEFBINOP_FN (eq, sparse_bool_matrix, sparse_bool_matrix, mx_el_eq)
 DEFBINOP_FN (ne, sparse_bool_matrix, sparse_bool_matrix, mx_el_ne)
 DEFBINOP_FN (el_and, sparse_bool_matrix, sparse_bool_matrix, mx_el_and)
@@ -72,17 +72,17 @@ DEFNDCATOP_FN (sbm_sm, sparse_bool_matri
 DEFNDCATOP_FN (sm_sbm, sparse_matrix, sparse_bool_matrix, sparse_matrix,
                sparse_matrix, concat)
 
 DEFASSIGNOP_FN (assign, sparse_bool_matrix, sparse_bool_matrix,
                 assign)
 
 CONVDECL (bool_matrix_to_double_matrix)
 {
-  CAST_CONV_ARG (const octave_sparse_bool_matrix&);
+  const octave_sparse_bool_matrix& v = dynamic_cast<const octave_sparse_bool_matrix&> (a);
 
   return new octave_sparse_matrix (SparseMatrix
                                     (v.sparse_bool_matrix_value ()));
 }
 
 void
 install_sbm_sbm_ops (void)
 {
diff --git a/libinterp/operators/op-scm-cm.cc b/libinterp/operators/op-scm-cm.cc
--- a/libinterp/operators/op-scm-cm.cc
+++ b/libinterp/operators/op-scm-cm.cc
@@ -43,36 +43,36 @@ along with Octave; see the file COPYING.
 
 DEFBINOP_OP (add, sparse_complex_matrix, complex_matrix, +)
 DEFBINOP_OP (sub, sparse_complex_matrix, complex_matrix, -)
 
 DEFBINOP_OP (mul, sparse_complex_matrix, complex_matrix, *)
 
 DEFBINOP (div, sparse_complex_matrix, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
-                   const octave_complex_matrix&);
+  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
   MatrixType typ = v2.matrix_type ();
 
   ComplexMatrix ret = xdiv (v1.complex_matrix_value (),
                             v2.complex_matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, sparse_complex_matrix, complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
-                   const octave_complex_matrix&);
+  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -100,49 +100,49 @@ DEFBINOP_FN (ge, sparse_complex_matrix, 
 DEFBINOP_FN (gt, sparse_complex_matrix, complex_matrix, mx_el_gt)
 DEFBINOP_FN (ne, sparse_complex_matrix, complex_matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, sparse_complex_matrix, complex_matrix, product)
 DEFBINOP_FN (el_div, sparse_complex_matrix, complex_matrix, quotient)
 
 DEFBINOP (el_pow, sparse_complex_matrix, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
-                   const octave_complex_matrix&);
+  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
 
   return octave_value
          (elem_xpow (v1.sparse_complex_matrix_value (), SparseComplexMatrix
                      (v2.complex_matrix_value ())));
 }
 
 DEFBINOP (el_ldiv, sparse_complex_matrix, matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
-                   const octave_complex_matrix&);
+  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
 
   return octave_value (quotient (v2.complex_matrix_value (),
                                  v1.sparse_complex_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_complex_matrix, complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_complex_matrix, complex_matrix, mx_el_or)
 
 DEFCATOP (scm_cm, sparse_complex_matrix, complex_matrix)
 {
-  CAST_BINOP_ARGS (octave_sparse_complex_matrix&,
-                   const octave_complex_matrix&);
+  octave_sparse_complex_matrix& v1 = dynamic_cast<octave_sparse_complex_matrix&> (a1);
+  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
   SparseComplexMatrix tmp (v2.complex_matrix_value ());
   return octave_value
          (v1.sparse_complex_matrix_value (). concat (tmp, ra_idx));
 }
 
 DEFASSIGNOP (assign, sparse_complex_matrix, complex_matrix)
 {
-  CAST_BINOP_ARGS (octave_sparse_complex_matrix&,
-                   const octave_complex_matrix&);
+  octave_sparse_complex_matrix& v1 = dynamic_cast<octave_sparse_complex_matrix&> (a1);
+  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
 
   SparseComplexMatrix tmp (v2.complex_matrix_value ());
   v1.assign (idx, tmp);
   return octave_value ();
 }
 
 void
 install_scm_cm_ops (void)
diff --git a/libinterp/operators/op-scm-cs.cc b/libinterp/operators/op-scm-cs.cc
--- a/libinterp/operators/op-scm-cs.cc
+++ b/libinterp/operators/op-scm-cs.cc
@@ -41,40 +41,41 @@ along with Octave; see the file COPYING.
 // sparse complex matrix by complex scalar ops.
 
 DEFBINOP_OP (add, sparse_complex_matrix, complex, +)
 DEFBINOP_OP (sub, sparse_complex_matrix, complex, -)
 DEFBINOP_OP (mul, sparse_complex_matrix, complex, *)
 
 DEFBINOP (div, sparse_complex_matrix, complex)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
-                   const octave_complex&);
+  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   Complex d = v2.complex_value ();
   octave_value retval;
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   retval = octave_value (v1.sparse_complex_matrix_value () / d);
 
   return retval;
 }
 
 DEFBINOP (pow, sparse_complex_matrix, complex)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
-                   const octave_complex&);
+  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
   return xpow (v1.complex_matrix_value (), v2.complex_value ());
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, complex)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_complex&);
+  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -97,18 +98,18 @@ DEFBINOP_FN (eq, sparse_complex_matrix, 
 DEFBINOP_FN (ge, sparse_complex_matrix, complex, mx_el_ge)
 DEFBINOP_FN (gt, sparse_complex_matrix, complex, mx_el_gt)
 DEFBINOP_FN (ne, sparse_complex_matrix, complex, mx_el_ne)
 
 DEFBINOP_OP (el_mul, sparse_complex_matrix, complex, *)
 
 DEFBINOP (el_div, sparse_complex_matrix, complex)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
-                   const octave_complex&);
+  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   octave_value retval;
 
   Complex d = v2.complex_value ();
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
@@ -116,37 +117,39 @@ DEFBINOP (el_div, sparse_complex_matrix,
 
   return retval;
 }
 
 DEFBINOP_FN (el_pow, sparse_complex_matrix, complex, elem_xpow)
 
 DEFBINOP (el_ldiv, sparse_complex_matrix, complex)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
-                   const octave_complex&);
+  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   return octave_value
          (x_el_div (v2.complex_value (), v1.sparse_complex_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_complex_matrix, complex, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_complex_matrix, complex, mx_el_or)
 
 DEFCATOP (scm_cs, sparse_complex_matrix, complex)
 {
-  CAST_BINOP_ARGS (octave_sparse_complex_matrix&, const octave_complex&);
+  octave_sparse_complex_matrix& v1 = dynamic_cast<octave_sparse_complex_matrix&> (a1);
+  const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
   SparseComplexMatrix tmp (1, 1, v2.complex_value ());
   return octave_value
          (v1.sparse_complex_matrix_value (). concat (tmp, ra_idx));
 }
 
 DEFASSIGNOP (assign, sparse_complex_matrix, complex)
 {
-  CAST_BINOP_ARGS (octave_sparse_complex_matrix&, const octave_complex&);
+  octave_sparse_complex_matrix& v1 = dynamic_cast<octave_sparse_complex_matrix&> (a1);
+  const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   SparseComplexMatrix tmp (1, 1, v2.complex_value ());
   v1.assign (idx, tmp);
   return octave_value ();
 }
 
 void
 install_scm_cs_ops (void)
diff --git a/libinterp/operators/op-scm-m.cc b/libinterp/operators/op-scm-m.cc
--- a/libinterp/operators/op-scm-m.cc
+++ b/libinterp/operators/op-scm-m.cc
@@ -44,35 +44,36 @@ along with Octave; see the file COPYING.
 
 DEFBINOP_OP (add, sparse_complex_matrix, matrix, +)
 DEFBINOP_OP (sub, sparse_complex_matrix, matrix, -)
 
 DEFBINOP_OP (mul, sparse_complex_matrix, matrix, *)
 
 DEFBINOP (div, sparse_complex_matrix, matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
-                   const octave_matrix&);
+  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
   MatrixType typ = v2.matrix_type ();
 
   ComplexMatrix ret = xdiv (v1.complex_matrix_value (),
                             v2.matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, sparse_complex_matrix, matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_matrix&);
+  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -97,47 +98,49 @@ DEFBINOP_FN (ge, sparse_complex_matrix, 
 DEFBINOP_FN (gt, sparse_complex_matrix, matrix, mx_el_gt)
 DEFBINOP_FN (ne, sparse_complex_matrix, matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, sparse_complex_matrix, matrix, product)
 DEFBINOP_FN (el_div, sparse_complex_matrix, matrix, quotient)
 
 DEFBINOP (el_pow, sparse_complex_matrix, matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
-                   const octave_matrix&);
+  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
 
   return octave_value
          (elem_xpow (v1.sparse_complex_matrix_value (), SparseMatrix
                      (v2.matrix_value ())));
 }
 
 DEFBINOP (el_ldiv, sparse_complex_matrix, matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
-                   const octave_matrix&);
+  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
 
   return octave_value
          (quotient (v2.matrix_value (), v1.sparse_complex_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_complex_matrix, matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_complex_matrix, matrix, mx_el_or)
 
 DEFCATOP (scm_m, sparse_complex_matrix, matrix)
 {
-  CAST_BINOP_ARGS (octave_sparse_complex_matrix&, const octave_matrix&);
+  octave_sparse_complex_matrix& v1 = dynamic_cast<octave_sparse_complex_matrix&> (a1);
+  const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
   SparseMatrix tmp (v2.matrix_value ());
   return octave_value
          (v1.sparse_complex_matrix_value (). concat (tmp, ra_idx));
 }
 
 DEFASSIGNOP (assign, sparse_complex_matrix, matrix)
 {
-  CAST_BINOP_ARGS (octave_sparse_complex_matrix&, const octave_matrix&);
+  octave_sparse_complex_matrix& v1 = dynamic_cast<octave_sparse_complex_matrix&> (a1);
+  const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
 
   SparseComplexMatrix tmp (v2.complex_matrix_value ());
   v1.assign (idx, tmp);
   return octave_value ();
 }
 
 void
 install_scm_m_ops (void)
diff --git a/libinterp/operators/op-scm-s.cc b/libinterp/operators/op-scm-s.cc
--- a/libinterp/operators/op-scm-s.cc
+++ b/libinterp/operators/op-scm-s.cc
@@ -44,45 +44,46 @@ along with Octave; see the file COPYING.
 // sparse complex matrix by scalar ops.
 
 DEFBINOP_OP (add, sparse_complex_matrix, scalar, +)
 DEFBINOP_OP (sub, sparse_complex_matrix, scalar, -)
 DEFBINOP_OP (mul, sparse_complex_matrix, scalar, *)
 
 DEFBINOP (div, sparse_complex_matrix, scalar)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
-                   const octave_scalar&);
+  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   double d = v2.double_value ();
   octave_value retval;
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   retval = octave_value (v1.sparse_complex_matrix_value () / d);
 
   return retval;
 }
 
 DEFBINOP (pow, sparse_complex_matrix, scalar)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
-                   const octave_scalar&);
+  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   double tmp = v2.scalar_value ();
   if (static_cast<int> (tmp) == tmp)
     return xpow (v1.sparse_complex_matrix_value (), tmp);
   else
     return xpow (v1.complex_matrix_value (), tmp);
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, scalar)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_scalar&);
+  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -105,54 +106,57 @@ DEFBINOP_FN (eq, sparse_complex_matrix, 
 DEFBINOP_FN (ge, sparse_complex_matrix, scalar, mx_el_ge)
 DEFBINOP_FN (gt, sparse_complex_matrix, scalar, mx_el_gt)
 DEFBINOP_FN (ne, sparse_complex_matrix, scalar, mx_el_ne)
 
 DEFBINOP_OP (el_mul, sparse_complex_matrix, scalar, *)
 
 DEFBINOP (el_div, sparse_complex_matrix, scalar)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
-                   const octave_scalar&);
+  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   double d = v2.double_value ();
   octave_value retval;
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   retval = octave_value (v1.sparse_complex_matrix_value () / d);
 
   return retval;
 }
 
 DEFBINOP_FN (el_pow, sparse_complex_matrix, scalar, elem_xpow)
 
 DEFBINOP (el_ldiv, sparse_complex_matrix, scalar)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_scalar&);
+  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   return octave_value
          (x_el_div (v2.double_value (), v1.sparse_complex_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_complex_matrix, scalar, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_complex_matrix, scalar, mx_el_or)
 
 DEFCATOP (scm_s, sparse_complex_matrix, scalar)
 {
-  CAST_BINOP_ARGS (octave_sparse_complex_matrix&, const octave_scalar&);
+  octave_sparse_complex_matrix& v1 = dynamic_cast<octave_sparse_complex_matrix&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
   SparseComplexMatrix tmp (1, 1, v2.complex_value ());
   return octave_value
          (v1.sparse_complex_matrix_value (). concat (tmp, ra_idx));
 }
 
 DEFASSIGNOP (assign, sparse_complex_matrix, scalar)
 {
-  CAST_BINOP_ARGS (octave_sparse_complex_matrix&, const octave_scalar&);
+  octave_sparse_complex_matrix& v1 = dynamic_cast<octave_sparse_complex_matrix&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   SparseComplexMatrix tmp (1, 1, v2.complex_value ());
   v1.assign (idx, tmp);
   return octave_value ();
 }
 
 void
 install_scm_s_ops (void)
diff --git a/libinterp/operators/op-scm-scm.cc b/libinterp/operators/op-scm-scm.cc
--- a/libinterp/operators/op-scm-scm.cc
+++ b/libinterp/operators/op-scm-scm.cc
@@ -53,57 +53,57 @@ along with Octave; see the file COPYING.
 // unary sparse complex matrix ops.
 
 DEFUNOP_OP (not, sparse_complex_matrix, !)
 DEFUNOP_OP (uplus, sparse_complex_matrix, /* no-op */)
 DEFUNOP_OP (uminus, sparse_complex_matrix, -)
 
 DEFUNOP (transpose, sparse_complex_matrix)
 {
-  CAST_UNOP_ARG (const octave_sparse_complex_matrix&);
+  const octave_sparse_complex_matrix& v = dynamic_cast<const octave_sparse_complex_matrix&> (a);
   return octave_value
          (v.sparse_complex_matrix_value ().transpose (),
           v.matrix_type ().transpose ());
 }
 
 DEFUNOP (hermitian, sparse_complex_matrix)
 {
-  CAST_UNOP_ARG (const octave_sparse_complex_matrix&);
+  const octave_sparse_complex_matrix& v = dynamic_cast<const octave_sparse_complex_matrix&> (a);
   return octave_value
          (v.sparse_complex_matrix_value ().hermitian (),
           v.matrix_type ().transpose ());
 }
 
 #if 0
 DEFUNOP (incr, sparse_complex_matrix)
 {
-  CAST_UNOP_ARG (const octave_sparse_complex_matrix&);
+  const octave_sparse_complex_matrix& v = dynamic_cast<const octave_sparse_complex_matrix&> (a);
 
   return octave_value (v.complex_matrix_value () .increment ());
 }
 
 DEFUNOP (decr, sparse_complex_matrix)
 {
-  CAST_UNOP_ARG (const octave_sparse_complex_matrix&);
+  const octave_sparse_complex_matrix& v = dynamic_cast<const octave_sparse_complex_matrix&> (a);
 
   return octave_value (v.complex_matrix_value () .decrement ());
 }
 #endif
 
 // complex matrix by complex matrix ops.
 
 DEFBINOP_OP (add, sparse_complex_matrix, sparse_complex_matrix, +)
 DEFBINOP_OP (sub, sparse_complex_matrix, sparse_complex_matrix, -)
 
 DEFBINOP_OP (mul, sparse_complex_matrix, sparse_complex_matrix, *)
 
 DEFBINOP (div, sparse_complex_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
-                   const octave_sparse_complex_matrix&);
+  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -122,18 +122,18 @@ DEFBINOP (div, sparse_complex_matrix, sp
 
 DEFBINOPX (pow, sparse_complex_matrix, sparse_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
-                   const octave_sparse_complex_matrix&);
+  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -160,18 +160,18 @@ DEFBINOP_FN (gt, sparse_complex_matrix, 
 DEFBINOP_FN (ne, sparse_complex_matrix, sparse_complex_matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, sparse_complex_matrix, sparse_complex_matrix, product)
 DEFBINOP_FN (el_div, sparse_complex_matrix, sparse_complex_matrix, quotient)
 DEFBINOP_FN (el_pow, sparse_complex_matrix, sparse_complex_matrix, elem_xpow)
 
 DEFBINOP (el_ldiv, sparse_complex_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
-                   const octave_sparse_complex_matrix&);
+  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   return octave_value (quotient (v2.sparse_complex_matrix_value (),
                                  v1.sparse_complex_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_complex_matrix, sparse_complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_complex_matrix, sparse_complex_matrix, mx_el_or)
 
diff --git a/libinterp/operators/op-scm-sm.cc b/libinterp/operators/op-scm-sm.cc
--- a/libinterp/operators/op-scm-sm.cc
+++ b/libinterp/operators/op-scm-sm.cc
@@ -42,18 +42,18 @@ along with Octave; see the file COPYING.
 
 DEFBINOP_OP (add, sparse_complex_matrix, sparse_matrix, +)
 DEFBINOP_OP (sub, sparse_complex_matrix, sparse_matrix, -)
 
 DEFBINOP_OP (mul, sparse_complex_matrix, sparse_matrix, *)
 
 DEFBINOP (div, sparse_complex_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
-                   const octave_sparse_matrix&);
+  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -72,18 +72,18 @@ DEFBINOP (div, sparse_complex_matrix, sp
 
 DEFBINOPX (pow, sparse_complex_matrix, sparse_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
-                   const octave_sparse_matrix&);
+  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -109,18 +109,18 @@ DEFBINOP_FN (gt, sparse_complex_matrix, 
 DEFBINOP_FN (ne, sparse_complex_matrix, sparse_matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, sparse_complex_matrix, sparse_matrix, product)
 DEFBINOP_FN (el_div, sparse_complex_matrix, sparse_matrix, quotient)
 DEFBINOP_FN (el_pow, sparse_complex_matrix, sparse_matrix, elem_xpow)
 
 DEFBINOP (el_ldiv, sparse_complex_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
-                   const octave_sparse_matrix&);
+  const octave_sparse_complex_matrix& v1 = dynamic_cast<const octave_sparse_complex_matrix&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   return octave_value (quotient (v2.sparse_matrix_value (),
                                  v1.sparse_complex_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_complex_matrix, sparse_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_complex_matrix, sparse_matrix, mx_el_or)
 
diff --git a/libinterp/operators/op-sm-cm.cc b/libinterp/operators/op-sm-cm.cc
--- a/libinterp/operators/op-sm-cm.cc
+++ b/libinterp/operators/op-sm-cm.cc
@@ -43,35 +43,36 @@ along with Octave; see the file COPYING.
 
 DEFBINOP_OP (add, sparse_matrix, complex_matrix, +)
 DEFBINOP_OP (sub, sparse_matrix, complex_matrix, -)
 
 DEFBINOP_OP (mul, sparse_matrix, complex_matrix, *)
 
 DEFBINOP (div, sparse_matrix, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&,
-                   const octave_complex_matrix&);
+  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
   MatrixType typ = v2.matrix_type ();
 
   ComplexMatrix ret = xdiv (v1.matrix_value (),
                             v2.complex_matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, sparse_matrix, complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, sparse_matrix, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex_matrix&);
+  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       double d = v1.scalar_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -96,46 +97,47 @@ DEFBINOP_FN (ge, sparse_matrix, complex_
 DEFBINOP_FN (gt, sparse_matrix, complex_matrix, mx_el_gt)
 DEFBINOP_FN (ne, sparse_matrix, complex_matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, sparse_matrix, complex_matrix, product)
 DEFBINOP_FN (el_div, sparse_matrix, complex_matrix, quotient)
 
 DEFBINOP (el_pow, sparse_matrix, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&,
-                   const octave_complex_matrix&);
+  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
 
   return octave_value
          (elem_xpow (v1.sparse_matrix_value (), SparseComplexMatrix
                      (v2.complex_matrix_value ())));
 }
 
 DEFBINOP (el_ldiv, sparse_matrix, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&,
-                   const octave_complex_matrix&);
+  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
 
   return octave_value
          (quotient (v2.complex_matrix_value (), v1.sparse_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_matrix, complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_matrix, complex_matrix, mx_el_or)
 
 DEFCATOP (sm_cm, sparse_matrix, complex_matrix)
 {
-  CAST_BINOP_ARGS (octave_sparse_matrix&, const octave_complex_matrix&);
+  octave_sparse_matrix& v1 = dynamic_cast<octave_sparse_matrix&> (a1);
+  const octave_complex_matrix& v2 = dynamic_cast<const octave_complex_matrix&> (a2);
   SparseComplexMatrix tmp (v2.complex_matrix_value ());
   return octave_value (v1.sparse_matrix_value (). concat (tmp, ra_idx));
 }
 
 DEFCONV (sparse_complex_matrix_conv, sparse_matrix, sparse_complex_matrix)
 {
-  CAST_CONV_ARG (const octave_sparse_matrix&);
+  const octave_sparse_matrix& v = dynamic_cast<const octave_sparse_matrix&> (a);
   return new octave_complex_matrix (v.complex_matrix_value ());
 }
 
 void
 install_sm_cm_ops (void)
 {
   INSTALL_BINOP (op_add, octave_sparse_matrix, octave_complex_matrix, add);
   INSTALL_BINOP (op_sub, octave_sparse_matrix, octave_complex_matrix, sub);
diff --git a/libinterp/operators/op-sm-cs.cc b/libinterp/operators/op-sm-cs.cc
--- a/libinterp/operators/op-sm-cs.cc
+++ b/libinterp/operators/op-sm-cs.cc
@@ -43,38 +43,41 @@ along with Octave; see the file COPYING.
 // sparse matrix by scalar ops.
 
 DEFBINOP_OP (add, sparse_matrix, complex, +)
 DEFBINOP_OP (sub, sparse_matrix, complex, -)
 DEFBINOP_OP (mul, sparse_matrix, complex, *)
 
 DEFBINOP (div, sparse_matrix, complex)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex&);
+  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   Complex d = v2.complex_value ();
   octave_value retval;
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   retval = octave_value (v1.sparse_matrix_value () / d);
 
   return retval;
 }
 
 DEFBINOP (pow, sparse_matrix, complex)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex&);
+  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
   return xpow (v1.matrix_value (), v2.complex_value ());
 }
 
 DEFBINOP (ldiv, sparse_matrix, complex)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex&);
+  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       double d = v1.scalar_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -97,45 +100,48 @@ DEFBINOP_FN (eq, sparse_matrix, complex,
 DEFBINOP_FN (ge, sparse_matrix, complex, mx_el_ge)
 DEFBINOP_FN (gt, sparse_matrix, complex, mx_el_gt)
 DEFBINOP_FN (ne, sparse_matrix, complex, mx_el_ne)
 
 DEFBINOP_OP (el_mul, sparse_matrix, complex, *)
 
 DEFBINOP (el_div, sparse_matrix, complex)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex&);
+  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   Complex d = v2.complex_value ();
   octave_value retval;
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   retval = octave_value (v1.sparse_matrix_value () / d);
 
   return retval;
 }
 
 DEFBINOP_FN (el_pow, sparse_matrix, complex, elem_xpow)
 
 DEFBINOP (el_ldiv, sparse_matrix, complex)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex&);
+  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
 
   return octave_value (x_el_div (v2.complex_value (),
                                  v1.sparse_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_matrix, complex, mx_el_and)
 DEFBINOP_FN (el_or, sparse_matrix, complex, mx_el_or)
 
 DEFCATOP (sm_cs, sparse_matrix, complex)
 {
-  CAST_BINOP_ARGS (octave_sparse_matrix&, const octave_complex&);
+  octave_sparse_matrix& v1 = dynamic_cast<octave_sparse_matrix&> (a1);
+  const octave_complex& v2 = dynamic_cast<const octave_complex&> (a2);
   SparseComplexMatrix tmp (1, 1, v2.complex_value ());
   return octave_value (v1.sparse_matrix_value (). concat (tmp, ra_idx));
 }
 
 void
 install_sm_cs_ops (void)
 {
   INSTALL_BINOP (op_add, octave_sparse_matrix, octave_complex, add);
diff --git a/libinterp/operators/op-sm-m.cc b/libinterp/operators/op-sm-m.cc
--- a/libinterp/operators/op-sm-m.cc
+++ b/libinterp/operators/op-sm-m.cc
@@ -43,33 +43,35 @@ along with Octave; see the file COPYING.
 
 DEFBINOP_OP (add, sparse_matrix, matrix, +)
 DEFBINOP_OP (sub, sparse_matrix, matrix, -)
 
 DEFBINOP_OP (mul, sparse_matrix, matrix, *)
 
 DEFBINOP (div, sparse_matrix, matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_matrix&);
+  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
   MatrixType typ = v2.matrix_type ();
 
   Matrix ret = xdiv (v1.matrix_value (), v2.matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, sparse_matrix, matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, sparse_matrix, matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_matrix&);
+  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       double d = v1.scalar_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -96,43 +98,47 @@ DEFBINOP_FN (ge, sparse_matrix, matrix, 
 DEFBINOP_FN (gt, sparse_matrix, matrix, mx_el_gt)
 DEFBINOP_FN (ne, sparse_matrix, matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, sparse_matrix, matrix, product)
 DEFBINOP_FN (el_div, sparse_matrix, matrix, quotient)
 
 DEFBINOP (el_pow, sparse_matrix, matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_matrix&);
+  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
 
   return octave_value (elem_xpow (v1.sparse_matrix_value (),
                                   SparseMatrix (v2.matrix_value ())));
 }
 
 DEFBINOP (el_ldiv, sparse_matrix, matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_matrix&);
+  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
 
   return octave_value
          (quotient (v2.matrix_value (), v1.sparse_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_matrix, matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_matrix, matrix, mx_el_or)
 
 DEFCATOP (sm_m, sparse_matrix, matrix)
 {
-  CAST_BINOP_ARGS (octave_sparse_matrix&, const octave_matrix&);
+  octave_sparse_matrix& v1 = dynamic_cast<octave_sparse_matrix&> (a1);
+  const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
   SparseMatrix tmp (v2.matrix_value ());
   return octave_value (v1.sparse_matrix_value (). concat (tmp, ra_idx));
 }
 
 DEFASSIGNOP (assign, sparse_matrix, matrix)
 {
-  CAST_BINOP_ARGS (octave_sparse_matrix&, const octave_matrix&);
+  octave_sparse_matrix& v1 = dynamic_cast<octave_sparse_matrix&> (a1);
+  const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
 
   SparseMatrix tmp (v2.matrix_value ());
   v1.assign (idx, tmp);
   return octave_value ();
 }
 
 void
 install_sm_m_ops (void)
diff --git a/libinterp/operators/op-sm-s.cc b/libinterp/operators/op-sm-s.cc
--- a/libinterp/operators/op-sm-s.cc
+++ b/libinterp/operators/op-sm-s.cc
@@ -40,43 +40,46 @@ along with Octave; see the file COPYING.
 // sparse matrix by scalar ops.
 
 DEFBINOP_OP (add, sparse_matrix, scalar, +)
 DEFBINOP_OP (sub, sparse_matrix, scalar, -)
 DEFBINOP_OP (mul, sparse_matrix, scalar, *)
 
 DEFBINOP (div, sparse_matrix, scalar)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_scalar&);
+  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   double d = v2.double_value ();
   octave_value retval;
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   retval = octave_value (v1.sparse_matrix_value () / d);
 
   return retval;
 }
 
 DEFBINOP (pow, sparse_matrix, scalar)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_scalar&);
+  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   double tmp = v2.scalar_value ();
   if (static_cast<int> (tmp) == tmp)
     return xpow (v1.sparse_matrix_value (), tmp);
   else
     return xpow (v1.matrix_value (), tmp);
 }
 
 DEFBINOP (ldiv, sparse_matrix, scalar)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_scalar&);
+  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       double d = v1.scalar_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -99,52 +102,56 @@ DEFBINOP_FN (eq, sparse_matrix, scalar, 
 DEFBINOP_FN (ge, sparse_matrix, scalar, mx_el_ge)
 DEFBINOP_FN (gt, sparse_matrix, scalar, mx_el_gt)
 DEFBINOP_FN (ne, sparse_matrix, scalar, mx_el_ne)
 
 DEFBINOP_OP (el_mul, sparse_matrix, scalar, *)
 
 DEFBINOP (el_div, sparse_matrix, scalar)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_scalar&);
+  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   double d = v2.double_value ();
   octave_value retval;
 
   if (d == 0.0)
     warn_divide_by_zero ();
 
   retval = octave_value (v1.sparse_matrix_value () / d);
 
   return retval;
 }
 
 DEFBINOP_FN (el_pow, sparse_matrix, scalar, elem_xpow)
 
 DEFBINOP (el_ldiv, sparse_matrix, scalar)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_scalar&);
+  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   return octave_value
          (x_el_div (v2.complex_value (), v1.sparse_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_matrix, scalar, mx_el_and)
 DEFBINOP_FN (el_or, sparse_matrix, scalar, mx_el_or)
 
 DEFCATOP (sm_s, sparse_matrix, scalar)
 {
-  CAST_BINOP_ARGS (octave_sparse_matrix&, const octave_scalar&);
+  octave_sparse_matrix& v1 = dynamic_cast<octave_sparse_matrix&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
   SparseMatrix tmp (1, 1, v2.scalar_value ());
   return octave_value (v1.sparse_matrix_value (). concat (tmp, ra_idx));
 }
 
 DEFASSIGNOP (assign, sparse_matrix, scalar)
 {
-  CAST_BINOP_ARGS (octave_sparse_matrix&, const octave_scalar&);
+  octave_sparse_matrix& v1 = dynamic_cast<octave_sparse_matrix&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   SparseMatrix tmp (1, 1, v2.scalar_value ());
   v1.assign (idx, tmp);
   return octave_value ();
 }
 
 void
 install_sm_s_ops (void)
diff --git a/libinterp/operators/op-sm-scm.cc b/libinterp/operators/op-sm-scm.cc
--- a/libinterp/operators/op-sm-scm.cc
+++ b/libinterp/operators/op-sm-scm.cc
@@ -42,18 +42,18 @@ along with Octave; see the file COPYING.
 
 DEFBINOP_OP (add, sparse_matrix, sparse_complex_matrix, +)
 DEFBINOP_OP (sub, sparse_matrix, sparse_complex_matrix, -)
 
 DEFBINOP_OP (mul, sparse_matrix, sparse_complex_matrix, *)
 
 DEFBINOP (div, sparse_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&,
-                   const octave_sparse_complex_matrix&);
+  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -72,18 +72,18 @@ DEFBINOP (div, sparse_matrix, sparse_com
 
 DEFBINOPX (pow, sparse_matrix, sparse_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, sparse_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&,
-                   const octave_sparse_complex_matrix&);
+  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       double d = v1.scalar_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -110,31 +110,31 @@ DEFBINOP_FN (gt, sparse_matrix, sparse_c
 DEFBINOP_FN (ne, sparse_matrix, sparse_complex_matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, sparse_matrix, sparse_complex_matrix, product)
 DEFBINOP_FN (el_div, sparse_matrix, sparse_complex_matrix, quotient)
 DEFBINOP_FN (el_pow, sparse_matrix, sparse_complex_matrix, elem_xpow)
 
 DEFBINOP (el_ldiv, sparse_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&,
-                   const octave_sparse_complex_matrix&);
+  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_sparse_complex_matrix& v2 = dynamic_cast<const octave_sparse_complex_matrix&> (a2);
 
   return octave_value (quotient (v2.sparse_complex_matrix_value (),
                                  v1.sparse_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_matrix, sparse_complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_matrix, sparse_complex_matrix, mx_el_or)
 
 DEFCATOP_FN (sm_scm, sparse_matrix, sparse_complex_matrix, concat)
 
 DEFCONV (sparse_complex_matrix_conv, sparse_matrix, sparse_complex_matrix)
 {
-  CAST_CONV_ARG (const octave_sparse_matrix&);
+  const octave_sparse_matrix& v = dynamic_cast<const octave_sparse_matrix&> (a);
   return new octave_sparse_complex_matrix (v.sparse_complex_matrix_value ());
 }
 
 void
 install_sm_scm_ops (void)
 {
   INSTALL_BINOP (op_add, octave_sparse_matrix, octave_sparse_complex_matrix,
                  add);
diff --git a/libinterp/operators/op-sm-sm.cc b/libinterp/operators/op-sm-sm.cc
--- a/libinterp/operators/op-sm-sm.cc
+++ b/libinterp/operators/op-sm-sm.cc
@@ -40,17 +40,17 @@ along with Octave; see the file COPYING.
 // sparse matrix unary ops.
 
 DEFUNOP_OP (not, sparse_matrix, !)
 DEFUNOP_OP (uplus, sparse_matrix, /* no-op */)
 DEFUNOP_OP (uminus, sparse_matrix, -)
 
 DEFUNOP (transpose, sparse_matrix)
 {
-  CAST_UNOP_ARG (const octave_sparse_matrix&);
+  const octave_sparse_matrix& v = dynamic_cast<const octave_sparse_matrix&> (a);
   return octave_value (v.sparse_matrix_value ().transpose (),
                        v.matrix_type ().transpose ());
 }
 
 // sparse matrix by sparse matrix ops.
 
 DEFBINOP_OP (add, sparse_matrix, sparse_matrix, +)
 
@@ -67,17 +67,18 @@ oct_binop_sub (const octave_base_value& 
 
   return octave_value (m);
 }
 
 DEFBINOP_OP (mul, sparse_matrix, sparse_matrix, *)
 
 DEFBINOP (div, sparse_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_sparse_matrix&);
+  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -96,17 +97,18 @@ DEFBINOP (div, sparse_matrix, sparse_mat
 
 DEFBINOPX (pow, sparse_matrix, sparse_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
 }
 
 DEFBINOP (ldiv, sparse_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_sparse_matrix&);
+  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       double d = v1.double_value ();
 
       if (d == 0.0)
         warn_divide_by_zero ();
 
@@ -133,17 +135,18 @@ DEFBINOP_FN (ne, sparse_matrix, sparse_m
 
 DEFBINOP_FN (el_mul, sparse_matrix, sparse_matrix, product)
 DEFBINOP_FN (el_div, sparse_matrix, sparse_matrix, quotient)
 
 DEFBINOP_FN (el_pow, sparse_matrix, sparse_matrix, elem_xpow)
 
 DEFBINOP (el_ldiv, sparse_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_sparse_matrix&);
+  const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
   return octave_value
          (quotient (v2.sparse_matrix_value (), v1.sparse_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_matrix, sparse_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_matrix, sparse_matrix, mx_el_or)
 
 DEFCATOP_FN (sm_sm, sparse_matrix, sparse_matrix, concat)
diff --git a/libinterp/operators/op-str-m.cc b/libinterp/operators/op-str-m.cc
--- a/libinterp/operators/op-str-m.cc
+++ b/libinterp/operators/op-str-m.cc
@@ -29,17 +29,18 @@ along with Octave; see the file COPYING.
 #include "ov.h"
 #include "ov-re-mat.h"
 #include "ov-str-mat.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 
 DEFASSIGNOP (assign, char_matrix_str, octave_matrix)
 {
-  CAST_BINOP_ARGS (octave_char_matrix_str&, const octave_matrix&);
+  octave_char_matrix_str& v1 = dynamic_cast<octave_char_matrix_str&> (a1);
+  const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
 
   octave_value tmp
     = v2.convert_to_str_internal (false, false,
                                   a1.is_sq_string () ? '\'' : '"');
 
   v1.assign (idx, tmp.char_array_value ());
 
   return octave_value ();
diff --git a/libinterp/operators/op-str-s.cc b/libinterp/operators/op-str-s.cc
--- a/libinterp/operators/op-str-s.cc
+++ b/libinterp/operators/op-str-s.cc
@@ -29,17 +29,18 @@ along with Octave; see the file COPYING.
 #include "ov.h"
 #include "ov-scalar.h"
 #include "ov-str-mat.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 
 DEFASSIGNOP (assign, char_matrix_str, octave_scalar)
 {
-  CAST_BINOP_ARGS (octave_char_matrix_str&, const octave_scalar&);
+  octave_char_matrix_str& v1 = dynamic_cast<octave_char_matrix_str&> (a1);
+  const octave_scalar& v2 = dynamic_cast<const octave_scalar&> (a2);
 
   octave_value tmp
     = v2.convert_to_str_internal (false, false,
                                   a1.is_sq_string () ? '\'' : '"');
 
   v1.assign (idx, tmp.char_array_value ());
 
   return octave_value ();
diff --git a/libinterp/operators/op-str-str.cc b/libinterp/operators/op-str-str.cc
--- a/libinterp/operators/op-str-str.cc
+++ b/libinterp/operators/op-str-str.cc
@@ -31,37 +31,39 @@ along with Octave; see the file COPYING.
 #include "ov-typeinfo.h"
 #include "ov-null-mat.h"
 #include "ops.h"
 
 // string unary ops.
 
 DEFUNOP (transpose, char_matrix_str)
 {
-  CAST_UNOP_ARG (const octave_char_matrix_str&);
+  const octave_char_matrix_str& v = dynamic_cast<const octave_char_matrix_str&> (a);
 
   if (v.ndims () > 2)
     error ("transpose not defined for N-D objects");
 
   return octave_value (v.char_matrix_value ().transpose (),
                        a.is_sq_string () ? '\'' : '"');
 }
 
 // string by string ops.
 
 #define DEFCHARNDBINOP_FN(name, op, t1, t2, e1, e2, f)  \
-  BINOPDECL (name, a1, a2) \
+  static octave_value \
+  CONCAT2(oct_binop_, name) (const octave_base_value& a1, const octave_base_value& a2) \
   { \
     dim_vector a1_dims = a1.dims (); \
     dim_vector a2_dims = a2.dims (); \
  \
     bool a1_is_scalar = a1_dims.all_ones (); \
     bool a2_is_scalar = a2_dims.all_ones (); \
  \
-    CAST_BINOP_ARGS (const octave_ ## t1&, const octave_ ## t2&); \
+    const octave_ ## t1& v1 = dynamic_cast<const octave_ ## t1&> (a1); \
+    const octave_ ## t2& v2 = dynamic_cast<const octave_ ## t2&> (a2); \
  \
     if (a1_is_scalar) \
       { \
         if (a2_is_scalar) \
           return octave_value ((v1.e1 ## _value ())(0) op (v2.e2 ## _value ())(0)); \
         else \
           return octave_value (f ((v1.e1 ## _value ())(0), v2.e2 ## _value ())); \
       } \
@@ -84,17 +86,18 @@ DEFCHARNDBINOP_FN (ge, >=, char_matrix_s
                    char_array, mx_el_ge)
 DEFCHARNDBINOP_FN (gt, >, char_matrix_str, char_matrix_str, char_array,
                    char_array, mx_el_gt)
 DEFCHARNDBINOP_FN (ne, !=, char_matrix_str, char_matrix_str, char_array,
                    char_array, mx_el_ne)
 
 DEFASSIGNOP (assign, char_matrix_str, char_matrix_str)
 {
-  CAST_BINOP_ARGS (octave_char_matrix_str&, const octave_char_matrix_str&);
+  octave_char_matrix_str& v1 = dynamic_cast<octave_char_matrix_str&> (a1);
+  const octave_char_matrix_str& v2 = dynamic_cast<const octave_char_matrix_str&> (a2);
 
   v1.assign (idx, v2.char_array_value ());
   return octave_value ();
 }
 
 DEFNULLASSIGNOP_FN (null_assign, char_matrix_str, delete_elements)
 
 DEFNDCHARCATOP_FN (str_str, char_matrix_str, char_matrix_str, concat)
diff --git a/libinterp/operators/op-struct.cc b/libinterp/operators/op-struct.cc
--- a/libinterp/operators/op-struct.cc
+++ b/libinterp/operators/op-struct.cc
@@ -31,56 +31,58 @@ along with Octave; see the file COPYING.
 #include "ov-struct.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 
 // struct ops.
 
 DEFUNOP (transpose, struct)
 {
-  CAST_UNOP_ARG (const octave_struct&);
+  const octave_struct& v = dynamic_cast<const octave_struct&> (a);
 
   if (v.ndims () > 2)
     error ("transpose not defined for N-D objects");
 
   return octave_value (v.map_value ().transpose ());
 }
 
 DEFUNOP (scalar_transpose, scalar_struct)
 {
-  CAST_UNOP_ARG (const octave_scalar_struct&);
+  const octave_scalar_struct& v = dynamic_cast<const octave_scalar_struct&> (a);
 
   return octave_value (v.scalar_map_value ());
 }
 
 DEFNDCATOP_FN (s_s_concat, struct, struct, map, map, concat)
 DEFNDCATOP_FN (s_ss_concat, struct, scalar_struct, map, map, concat)
 DEFNDCATOP_FN (ss_s_concat, scalar_struct, struct, map, map, concat)
 DEFNDCATOP_FN (ss_ss_concat, scalar_struct, scalar_struct, map, map, concat)
 
 static octave_value
 oct_catop_struct_matrix (octave_base_value& a1, const octave_base_value& a2,
                          const Array<octave_idx_type>&)
 {
-  CAST_BINOP_ARGS (const octave_struct&, const octave_matrix&);
+  const octave_struct& v1 = dynamic_cast<const octave_struct&> (a1);
+  const octave_matrix& v2 = dynamic_cast<const octave_matrix&> (a2);
 
   NDArray tmp = v2.array_value ();
   dim_vector dv = tmp.dims ();
 
   if (! dv.all_zero ())
     error ("invalid concatenation of structure with matrix");
 
   return octave_value (v1.map_value ());
 }
 
 static octave_value
 oct_catop_matrix_struct (octave_base_value& a1, const octave_base_value& a2,
                          const Array<octave_idx_type>&)
 {
-  CAST_BINOP_ARGS (const octave_matrix&, const octave_struct&);
+  const octave_matrix& v1 = dynamic_cast<const octave_matrix&> (a1);
+  const octave_struct& v2 = dynamic_cast<const octave_struct&> (a2);
 
   NDArray tmp = v1.array_value ();
   dim_vector dv = tmp.dims ();
 
   if (! dv.all_zero ())
     error ("invalid concatenation of structure with matrix");
 
   return octave_value (v2.map_value ());
diff --git a/libinterp/operators/ops.h b/libinterp/operators/ops.h
--- a/libinterp/operators/ops.h
+++ b/libinterp/operators/ops.h
@@ -70,99 +70,96 @@ extern void install_ops (void);
 #define INSTALL_CONVOP(t1, t2, f) \
   octave_value_typeinfo::register_type_conv_op \
     (t1::static_type_id (), t2::static_type_id (), CONCAT2(oct_conv_, f));
 
 #define INSTALL_WIDENOP(t1, t2, f) \
   octave_value_typeinfo::register_widening_op \
     (t1::static_type_id (), t2::static_type_id (), CONCAT2(oct_conv_, f));
 
-#define CAST_UNOP_ARG(t) \
-  t v = dynamic_cast<t> (a)
-
-#define CAST_BINOP_ARGS(t1, t2) \
-  t1 v1 = dynamic_cast<t1> (a1);                \
-  t2 v2 = dynamic_cast<t2> (a2)
-
-#define CAST_CONV_ARG(t) \
-  t v = dynamic_cast<t> (a)
-
-#define ASSIGNOPDECL(name) \
+#define DEFASSIGNOP(name, t1, t2) \
   static octave_value \
   CONCAT2(oct_assignop_, name) (octave_base_value& a1, \
-                         const octave_value_list& idx, \
-                         const octave_base_value& a2)
+                                const octave_value_list& idx, \
+                                const octave_base_value& a2)
 
-#define NULLASSIGNOPDECL(name) \
-  static octave_value \
-  CONCAT2(oct_assignop_, name) (octave_base_value& a, \
-                         const octave_value_list& idx, \
-                         const octave_base_value&)
-
-#define ASSIGNANYOPDECL(name) \
+#define DEFASSIGNOP_FN(name, t1, t2, f) \
   static octave_value \
   CONCAT2(oct_assignop_, name) (octave_base_value& a1, \
-                         const octave_value_list& idx, \
-                         const octave_value& a2)
-
-#define DEFASSIGNOP(name, t1, t2) \
-  ASSIGNOPDECL (name)
-
-#define DEFASSIGNOP_FN(name, t1, t2, f) \
-  ASSIGNOPDECL (name) \
+                                const octave_value_list& idx, \
+                                const octave_base_value& a2) \
   { \
-    CAST_BINOP_ARGS (CONCAT2(octave_, t1)&, const CONCAT2(octave_, t2)&); \
+    CONCAT2(octave_, t1)& v1 = dynamic_cast<CONCAT2(octave_, t1)&> (a1); \
+    const CONCAT2(octave_, t2)& v2 = dynamic_cast<const CONCAT2(octave_, t2)&> (a2); \
  \
     v1.f (idx, v2.CONCAT2(t1, _value) ()); \
     return octave_value (); \
   }
 
 #define DEFNULLASSIGNOP_FN(name, t, f) \
-  NULLASSIGNOPDECL (name) \
+  static octave_value \
+  CONCAT2(oct_assignop_, name) (octave_base_value& a, \
+                                const octave_value_list& idx, \
+                                const octave_base_value&) \
   { \
-    CAST_UNOP_ARG (CONCAT2(octave_, t)&); \
+    CONCAT2(octave_, t)& v = dynamic_cast<CONCAT2(octave_, t)&> (a); \
  \
     v.f (idx); \
     return octave_value (); \
   }
 
 #define DEFNDASSIGNOP_FN(name, t1, t2, e, f) \
-  ASSIGNOPDECL (name) \
+  static octave_value \
+  CONCAT2(oct_assignop_, name) (octave_base_value& a1, \
+                                const octave_value_list& idx, \
+                                const octave_base_value& a2) \
   { \
-    CAST_BINOP_ARGS (CONCAT2(octave_, t1)&, const CONCAT2(octave_, t2)&); \
+    CONCAT2(octave_, t1)& v1 = dynamic_cast<CONCAT2(octave_, t1)&> (a1); \
+    const CONCAT2(octave_, t2)& v2 = dynamic_cast<const CONCAT2(octave_, t2)&> (a2); \
  \
     v1.f (idx, v2.CONCAT2(e, _value) ()); \
     return octave_value (); \
   }
 
 // FIXME: the following currently don't handle index.
 #define DEFNDASSIGNOP_OP(name, t1, t2, f, op) \
-  ASSIGNOPDECL (name) \
+  static octave_value \
+  CONCAT2(oct_assignop_, name) (octave_base_value& a1, \
+                                const octave_value_list& idx, \
+                                const octave_base_value& a2) \
   { \
-    CAST_BINOP_ARGS (CONCAT2(octave_, t1)&, const CONCAT2(octave_, t2)&); \
+    CONCAT2(octave_, t1)& v1 = dynamic_cast<CONCAT2(octave_, t1)&> (a1); \
+    const CONCAT2(octave_, t2)& v2 = dynamic_cast<const CONCAT2(octave_, t2)&> (a2); \
  \
     assert (idx.empty ()); \
     v1.matrix_ref () op v2.CONCAT2(f, _value) (); \
  \
     return octave_value (); \
   }
 
 #define DEFNDASSIGNOP_FNOP(name, t1, t2, f, fnop) \
-  ASSIGNOPDECL (name) \
+  static octave_value \
+  CONCAT2(oct_assignop_, name) (octave_base_value& a1, \
+                                const octave_value_list& idx, \
+                                const octave_base_value& a2) \
   { \
-    CAST_BINOP_ARGS (CONCAT2(octave_, t1)&, const CONCAT2(octave_, t2)&); \
+    CONCAT2(octave_, t1)& v1 = dynamic_cast<CONCAT2(octave_, t1)&> (a1); \
+    const CONCAT2(octave_, t2)& v2 = dynamic_cast<const CONCAT2(octave_, t2)&> (a2); \
  \
     assert (idx.empty ()); \
     fnop (v1.matrix_ref (), v2.CONCAT2(f, _value) ()); \
  \
     return octave_value (); \
   }
 
 #define DEFASSIGNANYOP_FN(name, t1, f) \
-  ASSIGNANYOPDECL (name) \
+  static octave_value \
+  CONCAT2(oct_assignop_, name) (octave_base_value& a1, \
+                                const octave_value_list& idx, \
+                                const octave_value& a2) \
   { \
     CONCAT2(octave_, t1)& v1 = dynamic_cast<CONCAT2(octave_, t1)&> (a1); \
  \
     v1.f (idx, a2); \
     return octave_value (); \
   }
 
 #define CONVDECL(name) \
@@ -174,41 +171,41 @@ extern void install_ops (void);
   CONCAT2(oct_conv_, name) (const octave_base_value&)
 
 #define DEFCONV(name, a_dummy, b_dummy) \
   CONVDECL (name)
 
 #define DEFCONVFNX(name, tfrom, ovtto, tto, e) \
   CONVDECL (name) \
   { \
-    CAST_CONV_ARG (const CONCAT2(octave_, tfrom)&); \
+    const CONCAT2(octave_, tfrom)& v = dynamic_cast<const CONCAT2(octave_, tfrom)&> (a); \
  \
     return new CONCAT2(octave_, ovtto) (CONCAT2(tto, NDArray) (v.CONCAT2(e, array_value) ())); \
   }
 
 #define DEFCONVFNX2(name, tfrom, ovtto, e) \
   CONVDECL (name) \
   { \
-    CAST_CONV_ARG (const CONCAT2(octave_, tfrom)&); \
+    const CONCAT2(octave_, tfrom)& v = dynamic_cast<const CONCAT2(octave_, tfrom)&> (a); \
  \
     return new CONCAT2(octave_, ovtto) (v.CONCAT2(e, array_value) ()); \
   }
 
 #define DEFDBLCONVFN(name, ovtfrom, e) \
   CONVDECL (name) \
   { \
-    CAST_CONV_ARG (const CONCAT2(octave_, ovtfrom)&); \
+    const CONCAT2(octave_, ovtfrom)& v = dynamic_cast<const CONCAT2(octave_, ovtfrom)&> (a); \
  \
     return new octave_matrix (NDArray (v.CONCAT2(e, _value) ())); \
   }
 
 #define DEFFLTCONVFN(name, ovtfrom, e) \
   CONVDECL (name) \
   { \
-    CAST_CONV_ARG (const CONCAT2(octave_, ovtfrom)&); \
+    const CONCAT2(octave_, ovtfrom)& v = dynamic_cast<const CONCAT2(octave_, ovtfrom)&> (a); \
  \
     return new octave_float_matrix (FloatNDArray (v.CONCAT2(e, _value) ())); \
   }
 
 #define DEFSTRINTCONVFN(name, tto) \
   DEFCONVFNX(name, char_matrix_str, CONCAT2(tto, _matrix), tto, char_)
 
 #define DEFSTRDBLCONVFN(name, tfrom) \
@@ -218,177 +215,202 @@ extern void install_ops (void);
   DEFCONVFNX(name, tfrom, float_matrix, Float, char_)
 
 #define DEFCONVFN(name, tfrom, tto) \
   DEFCONVFNX2 (name, tfrom, CONCAT2(tto, _matrix), CONCAT2(tto, _))
 
 #define DEFCONVFN2(name, tfrom, sm, tto) \
   DEFCONVFNX2 (name, CONCAT3(tfrom, _, sm), CONCAT2(tto, _matrix), CONCAT2(tto, _))
 
-#define UNOPDECL(name, a) \
+#define DEFUNOPX(name, t) \
+  static octave_value \
+  CONCAT2(oct_unop_, name) (const octave_base_value&)
+
+#define DEFUNOP(name, t) \
   static octave_value \
   CONCAT2(oct_unop_, name) (const octave_base_value& a)
 
-#define DEFUNOPX(name, t) \
-  UNOPDECL (name, , )
-
-#define DEFUNOP(name, t) \
-  UNOPDECL (name, a)
-
 #define DEFUNOP_OP(name, t, op) \
-  UNOPDECL (name, a) \
+  static octave_value \
+  CONCAT2(oct_unop_, name) (const octave_base_value& a) \
   { \
-    CAST_UNOP_ARG (const CONCAT2(octave_, t)&); \
+    const CONCAT2(octave_, t)& v = dynamic_cast<const CONCAT2(octave_, t)&> (a); \
     return octave_value (op v.CONCAT2(t, _value) ()); \
   }
 
 #define DEFNDUNOP_OP(name, t, e, op) \
-  UNOPDECL (name, a) \
+  static octave_value \
+  CONCAT2(oct_unop_, name) (const octave_base_value& a) \
   { \
-    CAST_UNOP_ARG (const CONCAT2(octave_, t)&); \
+    const CONCAT2(octave_, t)& v = dynamic_cast<const CONCAT2(octave_, t)&> (a); \
     return octave_value (op v.CONCAT2(e, _value) ()); \
   }
 
 // FIXME: in some cases, the constructor isn't necessary.
 
 #define DEFUNOP_FN(name, t, f) \
-  UNOPDECL (name, a) \
+  static octave_value \
+  CONCAT2(oct_unop_, name) (const octave_base_value& a) \
   { \
-    CAST_UNOP_ARG (const CONCAT2(octave_, t)&); \
+    const CONCAT2(octave_, t)& v = dynamic_cast<const CONCAT2(octave_, t)&> (a); \
     return octave_value (f (v.CONCAT2(t, _value) ())); \
   }
 
 #define DEFNDUNOP_FN(name, t, e, f) \
-  UNOPDECL (name, a) \
+  static octave_value \
+  CONCAT2(oct_unop_, name) (const octave_base_value& a) \
   { \
-    CAST_UNOP_ARG (const CONCAT2(octave_, t)&); \
+    const CONCAT2(octave_, t)& v = dynamic_cast<const CONCAT2(octave_, t)&> (a); \
     return octave_value (f (v.CONCAT2(e, _value) ())); \
   }
 
 #define DEFNCUNOP_METHOD(name, t, method) \
   static void \
   CONCAT2(oct_unop_, name) (octave_base_value& a) \
   { \
-    CAST_UNOP_ARG (CONCAT2(octave_, t)&); \
+    CONCAT2(octave_, t)& v = dynamic_cast<CONCAT2(octave_, t)&> (a); \
     v.method (); \
   }
 
-#define BINOPDECL(name, a1, a2) \
+#define DEFBINOPX(name, t1, t2) \
+  static octave_value \
+  CONCAT2(oct_binop_, name) (const octave_base_value&, const octave_base_value&)
+
+#define DEFBINOP(name, t1, t2) \
   static octave_value \
   CONCAT2(oct_binop_, name) (const octave_base_value& a1, const octave_base_value& a2)
 
-#define DEFBINOPX(name, t1, t2) \
-  BINOPDECL (name, , )
-
-#define DEFBINOP(name, t1, t2) \
-  BINOPDECL (name, a1, a2)
-
 #define DEFBINOP_OP(name, t1, t2, op) \
-  BINOPDECL (name, a1, a2) \
+  static octave_value \
+  CONCAT2(oct_binop_, name) (const octave_base_value& a1, const octave_base_value& a2) \
   { \
-    CAST_BINOP_ARGS (const CONCAT2(octave_, t1)&, const CONCAT2(octave_, t2)&); \
+    const CONCAT2(octave_, t1)& v1 = dynamic_cast<const CONCAT2(octave_, t1)&> (a1); \
+    const CONCAT2(octave_, t2)& v2 = dynamic_cast<const CONCAT2(octave_, t2)&> (a2); \
     return octave_value \
       (v1.CONCAT2(t1, _value) () op v2.CONCAT2(t2, _value) ()); \
   }
 
 #define DEFCMPLXCMPOP_OP(name, t1, t2, op) \
-  BINOPDECL (name, a1, a2) \
+  static octave_value \
+  CONCAT2(oct_binop_, name) (const octave_base_value& a1, const octave_base_value& a2) \
   { \
-    CAST_BINOP_ARGS (const CONCAT2(octave_, t1)&, const CONCAT2(octave_, t2)&); \
+    const CONCAT2(octave_, t1)& v1 = dynamic_cast<const CONCAT2(octave_, t1)&> (a1); \
+    const CONCAT2(octave_, t2)& v2 = dynamic_cast<const CONCAT2(octave_, t2)&> (a2); \
     warn_complex_cmp (); \
     return octave_value \
       (v1.CONCAT2(t1, _value) () op v2.CONCAT2(t2, _value) ()); \
   }
 
 #define DEFSCALARBOOLOP_OP(name, t1, t2, op) \
-  BINOPDECL (name, a1, a2) \
+  static octave_value \
+  CONCAT2(oct_binop_, name) (const octave_base_value& a1, const octave_base_value& a2) \
   { \
-    CAST_BINOP_ARGS (const CONCAT2(octave_, t1)&, const CONCAT2(octave_, t2)&); \
+    const CONCAT2(octave_, t1)& v1 = dynamic_cast<const CONCAT2(octave_, t1)&> (a1); \
+    const CONCAT2(octave_, t2)& v2 = dynamic_cast<const CONCAT2(octave_, t2)&> (a2); \
     if (xisnan (v1.CONCAT2(t1, _value) ()) || xisnan (v2.CONCAT2(t2, _value) ())) \
       err_nan_to_logical_conversion (); \
  \
     return octave_value \
       (v1.CONCAT2(t1, _value) () op v2.CONCAT2(t2, _value) ()); \
   }
 
 #define DEFNDBINOP_OP(name, t1, t2, e1, e2, op) \
-  BINOPDECL (name, a1, a2) \
+  static octave_value \
+  CONCAT2(oct_binop_, name) (const octave_base_value& a1, const octave_base_value& a2) \
   { \
-    CAST_BINOP_ARGS (const CONCAT2(octave_, t1)&, const CONCAT2(octave_, t2)&); \
+    const CONCAT2(octave_, t1)& v1 = dynamic_cast<const CONCAT2(octave_, t1)&> (a1); \
+    const CONCAT2(octave_, t2)& v2 = dynamic_cast<const CONCAT2(octave_, t2)&> (a2); \
     return octave_value \
       (v1.CONCAT2(e1, _value) () op v2.CONCAT2(e2, _value) ()); \
   }
 
 // FIXME: in some cases, the constructor isn't necessary.
 
 #define DEFBINOP_FN(name, t1, t2, f) \
-  BINOPDECL (name, a1, a2) \
+  static octave_value \
+  CONCAT2(oct_binop_, name) (const octave_base_value& a1, const octave_base_value& a2) \
   { \
-    CAST_BINOP_ARGS (const CONCAT2(octave_, t1)&, const CONCAT2(octave_, t2)&); \
+    const CONCAT2(octave_, t1)& v1 = dynamic_cast<const CONCAT2(octave_, t1)&> (a1); \
+    const CONCAT2(octave_, t2)& v2 = dynamic_cast<const CONCAT2(octave_, t2)&> (a2); \
     return octave_value (f (v1.CONCAT2(t1, _value) (), v2.CONCAT2(t2, _value) ())); \
   }
 
 #define DEFNDBINOP_FN(name, t1, t2, e1, e2, f) \
-  BINOPDECL (name, a1, a2) \
+  static octave_value \
+  CONCAT2(oct_binop_, name) (const octave_base_value& a1, const octave_base_value& a2) \
   { \
-    CAST_BINOP_ARGS (const CONCAT2(octave_, t1)&, const CONCAT2(octave_, t2)&); \
+    const CONCAT2(octave_, t1)& v1 = dynamic_cast<const CONCAT2(octave_, t1)&> (a1); \
+    const CONCAT2(octave_, t2)& v2 = dynamic_cast<const CONCAT2(octave_, t2)&> (a2); \
     return octave_value (f (v1.CONCAT2(e1, _value) (), v2.CONCAT2(e2, _value) ())); \
   }
 
 #define DEFNDCMPLXCMPOP_FN(name, t1, t2, e1, e2, f) \
-  BINOPDECL (name, a1, a2) \
+  static octave_value \
+  CONCAT2(oct_binop_, name) (const octave_base_value& a1, const octave_base_value& a2) \
   { \
-    CAST_BINOP_ARGS (const CONCAT2(octave_, t1)&, const CONCAT2(octave_, t2)&); \
+    const CONCAT2(octave_, t1)& v1 = dynamic_cast<const CONCAT2(octave_, t1)&> (a1); \
+    const CONCAT2(octave_, t2)& v2 = dynamic_cast<const CONCAT2(octave_, t2)&> (a2); \
     return octave_value (f (v1.CONCAT2(e1, _value) (), v2.CONCAT2(e2, _value) ())); \
   }
 
-#define CATOPDECL(name, a1, a2) \
+#define DEFCATOPX(name, t1, t2) \
+  static octave_value \
+  CONCAT2(oct_catop_, name) (octave_base_value&, const octave_base_value&, \
+                             const Array<octave_idx_type>& ra_idx)
+
+#define DEFCATOP(name, t1, t2)  \
   static octave_value \
   CONCAT2(oct_catop_, name) (octave_base_value& a1, const octave_base_value& a2, \
-                      const Array<octave_idx_type>& ra_idx)
-
-#define DEFCATOPX(name, t1, t2) \
-  CATOPDECL (name, , )
-
-#define DEFCATOP(name, t1, t2)  \
-  CATOPDECL (name, a1, a2)
+                             const Array<octave_idx_type>& ra_idx)
 
 // FIXME: in some cases, the constructor isn't necessary.
 
 #define DEFCATOP_FN(name, t1, t2, f) \
-  CATOPDECL (name, a1, a2) \
+  static octave_value \
+  CONCAT2(oct_catop_, name) (octave_base_value& a1, const octave_base_value& a2, \
+                             const Array<octave_idx_type>& ra_idx) \
   { \
-    CAST_BINOP_ARGS (CONCAT2(octave_, t1)&, const CONCAT2(octave_, t2)&); \
+    CONCAT2(octave_, t1)& v1 = dynamic_cast<CONCAT2(octave_, t1)&> (a1); \
+    const CONCAT2(octave_, t2)& v2 = dynamic_cast<const CONCAT2(octave_, t2)&> (a2); \
     return octave_value (v1.CONCAT2(t1, _value) () . f (v2.CONCAT2(t2, _value) (), ra_idx)); \
   }
 
 #define DEFNDCATOP_FN(name, t1, t2, e1, e2, f) \
-  CATOPDECL (name, a1, a2) \
+  static octave_value \
+  CONCAT2(oct_catop_, name) (octave_base_value& a1, const octave_base_value& a2, \
+                             const Array<octave_idx_type>& ra_idx) \
   { \
-    CAST_BINOP_ARGS (CONCAT2(octave_, t1)&, const CONCAT2(octave_, t2)&); \
+    CONCAT2(octave_, t1)& v1 = dynamic_cast<CONCAT2(octave_, t1)&> (a1); \
+    const CONCAT2(octave_, t2)& v2 = dynamic_cast<const CONCAT2(octave_, t2)&> (a2); \
     return octave_value (v1.CONCAT2(e1, _value) () . f (v2.CONCAT2(e2, _value) (), ra_idx)); \
   }
 
 #define DEFNDCHARCATOP_FN(name, t1, t2, f) \
-  CATOPDECL (name, a1, a2) \
+  static octave_value \
+  CONCAT2(oct_catop_, name) (octave_base_value& a1, const octave_base_value& a2, \
+                             const Array<octave_idx_type>& ra_idx) \
   { \
-    CAST_BINOP_ARGS (CONCAT2(octave_, t1)&, const CONCAT2(octave_, t2)&); \
+    CONCAT2(octave_, t1)& v1 = dynamic_cast<CONCAT2(octave_, t1)&> (a1); \
+    const CONCAT2(octave_, t2)& v2 = dynamic_cast<const CONCAT2(octave_, t2)&> (a2); \
  \
     return octave_value (v1.char_array_value () . f (v2.char_array_value (), ra_idx), \
                          ((a1.is_sq_string () || a2.is_sq_string ()) \
                           ? '\'' : '"')); \
   }
 
 // For compatibility, the second arg is always converted to the type
 // of the first.  Hmm.
 
 #define DEFNDCATOP_FN2(name, t1, t2, tc1, tc2, e1, e2, f) \
-  CATOPDECL (name, a1, a2) \
+  static octave_value \
+  CONCAT2(oct_catop_, name) (octave_base_value& a1, const octave_base_value& a2, \
+                             const Array<octave_idx_type>& ra_idx) \
   { \
-    CAST_BINOP_ARGS (CONCAT2(octave_, t1)&, const CONCAT2(octave_, t2)&); \
+    CONCAT2(octave_, t1)& v1 = dynamic_cast<CONCAT2(octave_, t1)&> (a1); \
+    const CONCAT2(octave_, t2)& v2 = dynamic_cast<const CONCAT2(octave_, t2)&> (a2); \
     return octave_value (tc1 (v1.CONCAT2(e1, _value) ()) . f (tc2 (v2.CONCAT2(e2, _value) ()), ra_idx)); \
   }
 
 #define CATOP_NONCONFORMANT(msg) \
   err_nonconformant (msg, \
                      a1.rows (), a1.columns (), \
                      a2.rows (), a2.columns ()); \
   return octave_value ()
