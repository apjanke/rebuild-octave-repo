# HG changeset patch
# User Rik <rdrider0-list@yahoo.com>
# Date 1242596379 25200
#      Sun May 17 14:39:39 2009 -0700
# Node ID f0c3d3fc49039c26bba3bc04ccf86f2eb4edf491
# Parent  a7a9eecc07b5bb760264e0d540c8457369b97939
Simplify Texinfo documentation in .m scripts by removing redundant @iftex calls

diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,13 @@
+2009-05-17  Rik Wehbring  <rdrider0-list@yahoo.com>
+
+	* *.m: Simplify Texinfo documentation in .m scripts by removing 
+	redundant @iftex calls
+
 2009-05-17  Jaroslav Hajek  <highegg@gmail.com>
 
 	* optimization/fminunc.m: Improve TR updating strategy.
 	* optimization/fsolve.m: Ditto.
 
 2009-05-15  John W. Eaton  <jwe@octave.org>
 
 	* general/nargchk.m: Don't generate error if output is struct.
diff --git a/scripts/general/diff.m b/scripts/general/diff.m
--- a/scripts/general/diff.m
+++ b/scripts/general/diff.m
@@ -16,21 +16,19 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} diff (@var{x}, @var{k}, @var{dim})
 ## If @var{x} is a vector of length @var{n}, @code{diff (@var{x})} is the
 ## vector of first differences
-## @iftex
 ## @tex
 ##  $x_2 - x_1, \ldots{}, x_n - x_{n-1}$.
 ## @end tex
-## @end iftex
 ## @ifnottex
 ##  @var{x}(2) - @var{x}(1), @dots{}, @var{x}(n) - @var{x}(n-1).
 ## @end ifnottex
 ##
 ## If @var{x} is a matrix, @code{diff (@var{x})} is the matrix of column
 ## differences along the first non-singleton dimension.
 ##
 ## The second argument is optional.  If supplied, @code{diff (@var{x},
diff --git a/scripts/general/logspace.m b/scripts/general/logspace.m
--- a/scripts/general/logspace.m
+++ b/scripts/general/logspace.m
@@ -16,49 +16,41 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} logspace (@var{base}, @var{limit}, @var{n})
 ## Similar to @code{linspace} except that the values are logarithmically
 ## spaced from
-## @iftex
 ## @tex
 ## $10^{base}$ to $10^{limit}$.
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## 10^base to 10^limit.
 ## @end ifnottex
 ##
 ## If @var{limit} is equal to
-## @iftex
 ## @tex
 ## $\pi$,
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## pi,
 ## @end ifnottex
 ## the points are between
-## @iftex
 ## @tex
 ## $10^{base}$ and $\pi$,
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## 10^base and pi,
 ## @end ifnottex
 ## @emph{not}
-## @iftex
 ## @tex
 ## $10^{base}$ and $10^{\pi}$,
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## 10^base and 10^pi,
 ## @end ifnottex
 ## in order to be compatible with the corresponding @sc{matlab}
 ## function.
 ##
 ## Also for compatibility, return the second argument if fewer than two
 ## values are requested.
diff --git a/scripts/linear-algebra/commutation_matrix.m b/scripts/linear-algebra/commutation_matrix.m
--- a/scripts/linear-algebra/commutation_matrix.m
+++ b/scripts/linear-algebra/commutation_matrix.m
@@ -15,67 +15,55 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} commutation_matrix (@var{m}, @var{n})
 ## Return the commutation matrix
-## @iftex
 ## @tex
 ##  $K_{m,n}$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ##  K(m,n)
 ## @end ifnottex
 ##  which is the unique
-## @iftex
 ## @tex
 ##  $m n \times m n$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ##  @var{m}*@var{n} by @var{m}*@var{n}
 ## @end ifnottex
 ##  matrix such that
-## @iftex
 ## @tex
 ##  $K_{m,n} \cdot {\rm vec} (A) = {\rm vec} (A^T)$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ##  @math{K(m,n) * vec(A) = vec(A')}
 ## @end ifnottex
 ##  for all
-## @iftex
 ## @tex
 ##  $m\times n$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ##  @math{m} by @math{n}
 ## @end ifnottex
 ##  matrices
-## @iftex
 ## @tex
 ##  $A$.
 ## @end tex
-## @end iftex
 ## @ifnottex
 ##  @math{A}.
 ## @end ifnottex
 ##
 ## If only one argument @var{m} is given,
-## @iftex
 ## @tex
 ##  $K_{m,m}$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ##  @math{K(m,m)}
 ## @end ifnottex
 ##  is returned.
 ##
 ## See Magnus and Neudecker (1988), Matrix differential calculus with
 ## applications in statistics and econometrics.
 ## @end deftypefn
diff --git a/scripts/linear-algebra/duplication_matrix.m b/scripts/linear-algebra/duplication_matrix.m
--- a/scripts/linear-algebra/duplication_matrix.m
+++ b/scripts/linear-algebra/duplication_matrix.m
@@ -15,57 +15,47 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} duplication_matrix (@var{n})
 ## Return the duplication matrix
-## @iftex
 ## @tex
 ##  $D_n$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ##  @math{Dn}
 ## @end ifnottex
 ##  which is the unique
-## @iftex
 ## @tex
 ##  $n^2 \times n(n+1)/2$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ##  @math{n^2} by @math{n*(n+1)/2}
 ## @end ifnottex
 ##  matrix such that
-## @iftex
 ## @tex
 ##  $D_n * {\rm vech} (A) = {\rm vec} (A)$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ##  @math{Dn vech (A) = vec (A)}
 ## @end ifnottex
 ##  for all symmetric
-## @iftex
 ## @tex
 ##  $n \times n$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ##  @math{n} by @math{n}
 ## @end ifnottex
 ##  matrices
-## @iftex
 ## @tex
 ##  $A$.
 ## @end tex
-## @end iftex
 ## @ifnottex
 ##  @math{A}.
 ## @end ifnottex
 ##
 ## See Magnus and Neudecker (1988), Matrix differential calculus with
 ## applications in statistics and econometrics.
 ## @end deftypefn
 
diff --git a/scripts/linear-algebra/expm.m b/scripts/linear-algebra/expm.m
--- a/scripts/linear-algebra/expm.m
+++ b/scripts/linear-algebra/expm.m
@@ -15,93 +15,79 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} expm (@var{a})
 ## Return the exponential of a matrix, defined as the infinite Taylor
 ## series
-## @iftex
 ## @tex
 ## $$
 ##  \exp (A) = I + A + {A^2 \over 2!} + {A^3 \over 3!} + \cdots
 ## $$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## 
 ## @example
 ## expm(a) = I + a + a^2/2! + a^3/3! + @dots{}
 ## @end example
 ## 
 ## @end ifnottex
 ## The Taylor series is @emph{not} the way to compute the matrix
 ## exponential; see Moler and Van Loan, @cite{Nineteen Dubious Ways to
 ## Compute the Exponential of a Matrix}, SIAM Review, 1978.  This routine
 ## uses Ward's diagonal
-## @iftex
 ## @tex
 ## Pad\'e
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## Pade'
 ## @end ifnottex
 ## approximation method with three step preconditioning (SIAM Journal on
 ## Numerical Analysis, 1977).  Diagonal
-## @iftex
 ## @tex
 ## Pad\'e
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## Pade'
 ## @end ifnottex
 ##  approximations are rational polynomials of matrices
-## @iftex
 ## @tex
 ## $D_q(a)^{-1}N_q(a)$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## 
 ## @example
 ## @group
 ##      -1
 ## D (a)   N (a)
 ## @end group
 ## @end example
 ## 
 ## @end ifnottex
 ##  whose Taylor series matches the first
-## @iftex
 ## @tex
 ## $2 q + 1 $
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## @code{2q+1}
 ## @end ifnottex
 ## terms of the Taylor series above; direct evaluation of the Taylor series
 ## (with the same preconditioning steps) may be desirable in lieu of the
-## @iftex
 ## @tex
 ## Pad\'e
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## Pade'
 ## @end ifnottex
 ## approximation when
-## @iftex
 ## @tex
 ## $D_q(a)$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## @code{Dq(a)}
 ## @end ifnottex
 ## is ill-conditioned.
 ## @end deftypefn
 
 function r = expm (a)
 
diff --git a/scripts/linear-algebra/planerot.m b/scripts/linear-algebra/planerot.m
--- a/scripts/linear-algebra/planerot.m
+++ b/scripts/linear-algebra/planerot.m
@@ -14,21 +14,19 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{g}, @var{y}] =} planerot (@var{x})
 ## Given a two-element column vector, returns the
-## @iftex
 ## @tex
 ## $2 \times 2$ orthogonal matrix
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## 2 by 2 orthogonal matrix
 ## @end ifnottex
 ## @var{G} such that
 ## @code{@var{y} = @var{g} * @var{x}} and @code{@var{y}(2) = 0}.
 ## @seealso{givens}
 ## @end deftypefn
 
diff --git a/scripts/miscellaneous/bincoeff.m b/scripts/miscellaneous/bincoeff.m
--- a/scripts/miscellaneous/bincoeff.m
+++ b/scripts/miscellaneous/bincoeff.m
@@ -15,23 +15,21 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {} bincoeff (@var{n}, @var{k})
 ## Return the binomial coefficient of @var{n} and @var{k}, defined as
-## @iftex
 ## @tex
 ## $$
 ##  {n \choose k} = {n (n-1) (n-2) \cdots (n-k+1) \over k!}
 ## $$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ##
 ## @example
 ## @group
 ##  /   \
 ##  | n |    n (n-1) (n-2) @dots{} (n-k+1)
 ##  |   |  = -------------------------
 ##  | k |               k!
diff --git a/scripts/miscellaneous/namelengthmax.m b/scripts/miscellaneous/namelengthmax.m
--- a/scripts/miscellaneous/namelengthmax.m
+++ b/scripts/miscellaneous/namelengthmax.m
@@ -15,21 +15,19 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} namelengthmax ()
 ## Returns the @sc{matlab} compatible maximum variable name length.  Octave is
 ## capable of storing strings up to 
-## @iftex
 ## @tex
 ## $2^{31} - 1$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## @code{2 ^ 31 - 1}
 ## @end ifnottex
 ## in length.  However for @sc{matlab} compatibility all variable, function
 ## and structure field names should be shorter than the length supplied by
 ## @code{namelengthmax}.  In particular variables stored to a @sc{matlab} file
 ## format will have their names truncated to this length.
 ## @end deftypefn
diff --git a/scripts/optimization/glpk.m b/scripts/optimization/glpk.m
--- a/scripts/optimization/glpk.m
+++ b/scripts/optimization/glpk.m
@@ -16,71 +16,63 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{xopt}, @var{fmin}, @var{status}, @var{extra}] =} glpk (@var{c}, @var{a}, @var{b}, @var{lb}, @var{ub}, @var{ctype}, @var{vartype}, @var{sense}, @var{param})
 ## Solve a linear program using the GNU GLPK library.  Given three
 ## arguments, @code{glpk} solves the following standard LP:
 ## 
-## @iftex
 ## @tex
 ## $$
 ##   \min_x C^T x
 ## $$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## @example
 ## min C'*x
 ## @end example
 ## @end ifnottex
 ## 
 ## subject to
 ## 
-## @iftex
 ## @tex
 ## $$
 ##   Ax = b \qquad x \geq 0
 ## $$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## @example
 ## @group
 ## A*x  = b
 ##   x >= 0
 ## @end group
 ## @end example
 ## @end ifnottex
 ## 
 ## but may also solve problems of the form
 ## 
-## @iftex
 ## @tex
 ## $$
 ##   [ \min_x | \max_x ] C^T x
 ## $$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## @example
 ## [ min | max ] C'*x
 ## @end example
 ## @end ifnottex
 ## 
 ## subject to
 ## 
-## @iftex
 ## @tex
 ## $$
 ##  Ax [ = | \leq | \geq ] b \qquad LB \leq x \leq UB
 ## $$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## @example
 ## @group
 ## A*x [ "=" | "<=" | ">=" ] b
 ##   x >= LB
 ##   x <= UB
 ## @end group
 ## @end example
diff --git a/scripts/optimization/qp.m b/scripts/optimization/qp.m
--- a/scripts/optimization/qp.m
+++ b/scripts/optimization/qp.m
@@ -15,41 +15,37 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{x}, @var{obj}, @var{info}, @var{lambda}] =} qp (@var{x0}, @var{H}, @var{q}, @var{A}, @var{b}, @var{lb}, @var{ub}, @var{A_lb}, @var{A_in}, @var{A_ub})
 ## Solve the quadratic program
-## @iftex
 ## @tex
 ## $$
 ##  \min_x {1 \over 2} x^T H x + x^T q
 ## $$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ##
 ## @example
 ## @group
 ##      min 0.5 x'*H*x + x'*q
 ##       x
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ## subject to
-## @iftex
 ## @tex
 ## $$
 ##  Ax = b \qquad lb \leq x \leq ub \qquad A_{lb} \leq A_{in} \leq A_{ub}
 ## $$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ##
 ## @example
 ## @group
 ##      A*x = b
 ##      lb <= x <= ub
 ##      A_lb <= A_in*x <= A_ub
 ## @end group
diff --git a/scripts/optimization/sqp.m b/scripts/optimization/sqp.m
--- a/scripts/optimization/sqp.m
+++ b/scripts/optimization/sqp.m
@@ -14,41 +14,37 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{x}, @var{obj}, @var{info}, @var{iter}, @var{nf}, @var{lambda}] =} sqp (@var{x}, @var{phi}, @var{g}, @var{h}, @var{lb}, @var{ub}, @var{maxiter}, @var{tolerance})
 ## Solve the nonlinear program
-## @iftex
 ## @tex
 ## $$
 ## \min_x \phi (x)
 ## $$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ##
 ## @example
 ## @group
 ##      min phi (x)
 ##       x
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ## subject to
-## @iftex
 ## @tex
 ## $$
 ##  g(x) = 0 \qquad h(x) \geq 0 \qquad lb \leq x \leq ub
 ## $$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ##
 ## @example
 ## @group
 ##      g(x)  = 0
 ##      h(x) >= 0
 ##      lb <= x <= ub
 ## @end group
@@ -114,25 +110,23 @@
 ## @noindent
 ## in which @var{x} is a vector and @var{r} is a vector.
 ## 
 ## The third and fourth arguments may also be 2-element cell arrays of
 ## function handles.  The first element should point to the constraint
 ## function and the second should point to a function that computes the
 ## gradient of the constraint function:
 ##
-## @iftex
 ## @tex
 ## $$
 ##  \Bigg( {\partial f(x) \over \partial x_1}, 
 ##         {\partial f(x) \over \partial x_2}, \ldots,
 ##         {\partial f(x) \over \partial x_N} \Bigg)^T
 ## $$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## @example
 ## @group
 ##                 [ d f(x)   d f(x)        d f(x) ]
 ##     transpose ( [ ------   -----   ...   ------ ] )
 ##                 [  dx_1     dx_2          dx_N  ]
 ## @end group
 ## @end example
diff --git a/scripts/plot/peaks.m b/scripts/plot/peaks.m
--- a/scripts/plot/peaks.m
+++ b/scripts/plot/peaks.m
@@ -20,21 +20,19 @@
 ## @deftypefn {Function File} {} peaks ()
 ## @deftypefnx {Function File} {} peaks (@var{n})
 ## @deftypefnx {Function File} {} peaks (@var{x}, @var{y})
 ## @deftypefnx {Function File} {@var{z} =} peaks (@dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{y}, @var{z}] =} peaks (@dots{})
 ## Generate a function with lots of local maxima and minima.  The function
 ## has the form
 ##
-## @iftex
 ## @tex
 ## $f(x,y) = 3 (1 - x) ^ 2 e ^ {\left(-x^2 - (y+1)^2\right)} - 10 \left({x \over 5} - x^3 - y^5)\right) - {1 \over 3} e^{\left(-(x+1)^2 - y^2\right)}$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## @verbatim
 ## f(x,y) = 3*(1-x)^2*exp(-x^2 - (y+1)^2) ...
 ##          - 10*(x/5 - x^3 - y^5)*exp(-x^2-y^2) ...
 ##          - 1/3*exp(-(x+1)^2 - y^2)
 ## @end verbatim
 ## @end ifnottex
 ##
diff --git a/scripts/plot/subplot.m b/scripts/plot/subplot.m
--- a/scripts/plot/subplot.m
+++ b/scripts/plot/subplot.m
@@ -27,27 +27,25 @@
 ## specifying the location in digits 1 (rows) and 2 (columns) and the plot
 ## index in digit 3.
 ##
 ## The plot index runs row-wise.  First all the columns in a row are filled
 ## and then the next row is filled.
 ##
 ## For example, a plot with 2 by 3 grid will have plot indices running as
 ## follows:
-## @iftex
 ## @tex
 ## \vskip 10pt
 ## \hfil\vbox{\offinterlineskip\hrule
 ## \halign{\vrule#&&\qquad\hfil#\hfil\qquad\vrule\cr
 ## height13pt&1&2&3\cr height12pt&&&\cr\noalign{\hrule}
 ## height13pt&4&5&6\cr height12pt&&&\cr\noalign{\hrule}}}
 ## \hfil
 ## \vskip 10pt
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## @display
 ## @example
 ## @group
 ##
 ## +-----+-----+-----+
 ## |  1  |  2  |  3  |
 ## +-----+-----+-----+
diff --git a/scripts/polynomial/compan.m b/scripts/polynomial/compan.m
--- a/scripts/polynomial/compan.m
+++ b/scripts/polynomial/compan.m
@@ -18,28 +18,26 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} compan (@var{c})
 ## Compute the companion matrix corresponding to polynomial coefficient
 ## vector @var{c}.
 ##
 ## The companion matrix is
-## @iftex
 ## @tex
 ## $$
 ## A = \left[\matrix{
 ##  -c_2/c_1 & -c_3/c_1 & \cdots & -c_N/c_1 & -c_{N+1}/c_1\cr
 ##      1    &     0    & \cdots &     0    &         0   \cr
 ##      0    &     1    & \cdots &     0    &         0   \cr
 ##   \vdots  &   \vdots & \ddots &  \vdots  &      \vdots \cr
 ##      0    &     0    & \cdots &     1    &         0}\right].
 ## $$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ##
 ## @c Set example in small font to prevent overfull line
 ## @smallexample
 ##      _                                                        _
 ##     |  -c(2)/c(1)   -c(3)/c(1)  @dots{}  -c(N)/c(1)  -c(N+1)/c(1)  |
 ##     |       1            0      @dots{}       0             0      |
 ##     |       0            1      @dots{}       0             0      |
diff --git a/scripts/polynomial/pchip.m b/scripts/polynomial/pchip.m
--- a/scripts/polynomial/pchip.m
+++ b/scripts/polynomial/pchip.m
@@ -25,31 +25,27 @@
 ## later be used with @code{ppval} to evaluate the polynomial at
 ## specific points.
 ##
 ## The variable @var{x} must be a strictly monotonic vector (either
 ## increasing or decreasing).  While @var{y} can be either a vector or
 ## array.  In the case where @var{y} is a vector, it must have a length
 ## of @var{n}.  If @var{y} is an array, then the size of @var{y} must
 ## have the form
-## @iftex
 ## @tex
 ## $$[s_1, s_2, \cdots, s_k, n]$$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## @code{[@var{s1}, @var{s2}, @dots{}, @var{sk}, @var{n}]}
 ## @end ifnottex
 ## The array is then reshaped internally to a matrix where the leading
 ## dimension is given by 
-## @iftex
 ## @tex
 ## $$s_1 s_2 \cdots s_k$$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## @code{@var{s1} * @var{s2} * @dots{} * @var{sk}}
 ## @end ifnottex
 ## and each row in this matrix is then treated separately.  Note that this
 ## is exactly the opposite treatment than @code{interp1} and is done
 ## for compatibility.
 ##
 ## Called with a third input argument, @code{pchip} evaluates the 
diff --git a/scripts/polynomial/polyout.m b/scripts/polynomial/polyout.m
--- a/scripts/polynomial/polyout.m
+++ b/scripts/polynomial/polyout.m
@@ -15,21 +15,19 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} polyout (@var{c}, @var{x})
 ## Write formatted polynomial
-## @iftex
 ## @tex
 ## $$ c(x) = c_1 x^n + \ldots + c_n x + c_{n+1} $$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## @example
 ##    c(x) = c(1) * x^n + @dots{} + c(n) x + c(n+1)
 ## @end example
 ## @end ifnottex
 ##  and return it as a string or write it to the screen (if
 ##  @var{nargout} is zero).
 ##  @var{x} defaults to the string @code{"s"}.
diff --git a/scripts/polynomial/residue.m b/scripts/polynomial/residue.m
--- a/scripts/polynomial/residue.m
+++ b/scripts/polynomial/residue.m
@@ -18,24 +18,22 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{r}, @var{p}, @var{k}, @var{e}] =} residue (@var{b}, @var{a})
 ## Compute the partial fraction expansion for the quotient of the
 ## polynomials, @var{b} and @var{a}.
 ##
-## @iftex
 ## @tex
 ## $$
 ## {B(s)\over A(s)} = \sum_{m=1}^M {r_m\over (s-p_m)^e_m}
 ##   + \sum_{i=1}^N k_i s^{N-i}.
 ## $$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ##
 ## @example
 ## @group
 ##  B(s)    M       r(m)         N
 ##  ---- = SUM -------------  + SUM k(i)*s^(N-i)
 ##  A(s)   m=1 (s-p(m))^e(m)    i=1
 ## @end group
@@ -59,23 +57,21 @@
 ##      @result{} p = [2; 2; 1]
 ##      @result{} k = [](0x0)
 ##      @result{} e = [1; 2; 1]
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## which represents the following partial fraction expansion
-## @iftex
 ## @tex
 ## $$
 ## {s^2+s+1\over s^3-5s^2+8s-4} = {-2\over s-2} + {7\over (s-2)^2} + {3\over s-1}
 ## $$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ##
 ## @example
 ## @group
 ##         s^2 + s + 1       -2        7        3
 ##    ------------------- = ----- + ------- + -----
 ##    s^3 - 5s^2 + 8s - 4   (s-2)   (s-2)^2   (s-1)
 ## @end group
@@ -120,23 +116,21 @@
 ## [b, a] = residue (r, p, k, e);
 ##      @result{} b = [1, -5, 9, -3, 1]
 ##      @result{} a = [1, -5, 8, -4]
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## which represents the following partial fraction expansion
-## @iftex
 ## @tex
 ## $$
 ## {-2\over s-2} + {7\over (s-2)^2} + {3\over s-1} + s = {s^4-5s^3+9s^2-3s+1\over s^3-5s^2+8s-4}
 ## $$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ##
 ## @example
 ## @group
 ##     -2        7        3         s^4 - 5s^3 + 9s^2 - 3s + 1
 ##    ----- + ------- + ----- + s = --------------------------
 ##    (s-2)   (s-2)^2   (s-1)          s^3 - 5s^2 + 8s - 4
 ## @end group
diff --git a/scripts/polynomial/roots.m b/scripts/polynomial/roots.m
--- a/scripts/polynomial/roots.m
+++ b/scripts/polynomial/roots.m
@@ -17,65 +17,57 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} roots (@var{v})
 ##
 ## For a vector @var{v} with @math{N} components, return
 ## the roots of the polynomial
-## @iftex
 ## @tex
 ## $$
 ## v_1 z^{N-1} + \cdots + v_{N-1} z + v_N.
 ## $$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ##
 ## @example
 ## v(1) * z^(N-1) + @dots{} + v(N-1) * z + v(N)
 ## @end example
 ## @end ifnottex
 ##
 ## As an example, the following code finds the roots of the quadratic
 ## polynomial
-## @iftex
 ## @tex
 ## $$ p(x) = x^2 - 5. $$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## @example
 ## p(x) = x^2 - 5.
 ## @end example
 ## @end ifnottex
 ## @example
 ## @group
 ## c = [1, 0, -5];
 ## roots(c)
 ## @result{}  2.2361
 ## @result{} -2.2361
 ## @end group
 ## @end example
 ## Note that the true result is
-## @iftex
 ## @tex
 ## $\pm \sqrt{5}$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## @math{+/- sqrt(5)}
 ## @end ifnottex
 ## which is roughly
-## @iftex
 ## @tex
 ## $\pm 2.2361$.
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## @math{+/- 2.2361}.
 ## @end ifnottex
 ## @seealso{compan}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 24 December 1993
diff --git a/scripts/polynomial/spline.m b/scripts/polynomial/spline.m
--- a/scripts/polynomial/spline.m
+++ b/scripts/polynomial/spline.m
@@ -34,40 +34,34 @@
 ## can be either a vector or array.  In the case where @var{y} is a
 ## vector, it can have a length of either @var{n} or @code{@var{n} + 2}.
 ## If the length of @var{y} is @var{n}, then the 'not-a-knot' end
 ## condition is used.  If the length of @var{y} is @code{@var{n} + 2},
 ## then the first and last values of the vector @var{y} are the values
 ## of the first derivative of the cubic spline at the end-points.
 ##
 ## If @var{y} is an array, then the size of @var{y} must have the form
-## @iftex
 ## @tex
 ## $$[s_1, s_2, \cdots, s_k, n]$$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## @code{[@var{s1}, @var{s2}, @dots{}, @var{sk}, @var{n}]}
 ## @end ifnottex
 ## or
-## @iftex
 ## @tex
 ## $$[s_1, s_2, \cdots, s_k, n + 2].$$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## @code{[@var{s1}, @var{s2}, @dots{}, @var{sk}, @var{n} + 2]}.
 ## @end ifnottex
 ## The array is then reshaped internally to a matrix where the leading
 ## dimension is given by 
-## @iftex
 ## @tex
 ## $$s_1 s_2 \cdots s_k$$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## @code{@var{s1} * @var{s2} * @dots{} * @var{sk}}
 ## @end ifnottex
 ## and each row of this matrix is then treated separately.  Note that this
 ## is exactly the opposite treatment than @code{interp1} and is done
 ## for compatibility.
 ## @seealso{ppval, mkpp, unmkpp}
 ## @end deftypefn
diff --git a/scripts/signal/freqz.m b/scripts/signal/freqz.m
--- a/scripts/signal/freqz.m
+++ b/scripts/signal/freqz.m
@@ -21,35 +21,31 @@
 ## @deftypefn {Function File} {[@var{h}, @var{w}] =} freqz (@var{b}, @var{a}, @var{n}, "whole")
 ## Return the complex frequency response @var{h} of the rational IIR filter
 ## whose numerator and denominator coefficients are @var{b} and @var{a},
 ## respectively.  The response is evaluated at @var{n} angular frequencies
 ## between 0 and
 ## @ifnottex
 ##  2*pi.
 ## @end ifnottex
-## @iftex
 ## @tex
 ##  $2\pi$.
 ## @end tex
-## @end iftex
 ##
 ## @noindent
 ## The output value @var{w} is a vector of the frequencies.
 ##
 ## If the fourth argument is omitted, the response is evaluated at
 ## frequencies between 0 and
 ## @ifnottex
 ##  pi.
 ## @end ifnottex
-## @iftex
 ## @tex
 ##  $\pi$.
 ## @end tex
-## @end iftex
 ##
 ## If @var{n} is omitted, a value of 512 is assumed.
 ##
 ## If @var{a} is omitted, the denominator is assumed to be 1 (this
 ## corresponds to a simple FIR filter).
 ##
 ## For fastest computation, @var{n} should factor into a small number of
 ## small primes.
diff --git a/scripts/signal/sinc.m b/scripts/signal/sinc.m
--- a/scripts/signal/sinc.m
+++ b/scripts/signal/sinc.m
@@ -15,21 +15,19 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} sinc (@var{x})
 ## Return
-## @iftex
 ## @tex
 ## $ \sin (\pi x)/(\pi x)$.
 ## @end tex
-## @end iftex
 ## @ifnottex
 ##  sin(pi*x)/(pi*x).
 ## @end ifnottex
 ## @end deftypefn
 
 ## Author: jwe ???
 
 function result = sinc (x)
diff --git a/scripts/specfun/beta.m b/scripts/specfun/beta.m
--- a/scripts/specfun/beta.m
+++ b/scripts/specfun/beta.m
@@ -15,23 +15,21 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {} beta (@var{a}, @var{b})
 ## For real inputs, return the Beta function,
-## @iftex
 ## @tex
 ## $$
 ##  B (a, b) = {\Gamma (a) \Gamma (b) \over \Gamma (a + b)}.
 ## $$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ##
 ## @example
 ## beta (a, b) = gamma (a) * gamma (b) / gamma (a + b).
 ## @end example
 ## @end ifnottex
 ## @end deftypefn
 
diff --git a/scripts/specfun/betaln.m b/scripts/specfun/betaln.m
--- a/scripts/specfun/betaln.m
+++ b/scripts/specfun/betaln.m
@@ -14,23 +14,21 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {} betaln (@var{a}, @var{b})
 ## Return the log of the Beta function,
-## @iftex
 ## @tex
 ## $$
 ##  B (a, b) = \log {\Gamma (a) \Gamma (b) \over \Gamma (a + b)}.
 ## $$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ##
 ## @example
 ## betaln (a, b) = gammaln (a) + gammaln (b) - gammaln (a + b)
 ## @end example
 ## @end ifnottex
 ## @seealso{beta, betainc, gammaln}
 ## @end deftypefn
diff --git a/scripts/special-matrix/hankel.m b/scripts/special-matrix/hankel.m
--- a/scripts/special-matrix/hankel.m
+++ b/scripts/special-matrix/hankel.m
@@ -22,23 +22,21 @@
 ## Return the Hankel matrix constructed given the first column @var{c}, and
 ## (optionally) the last row @var{r}.  If the last element of @var{c} is
 ## not the same as the first element of @var{r}, the last element of
 ## @var{c} is used.  If the second argument is omitted, it is assumed to
 ## be a vector of zeros with the same size as @var{c}.
 ##
 ## A Hankel matrix formed from an m-vector @var{c}, and an n-vector
 ## @var{r}, has the elements
-## @iftex
 ## @tex
 ## $$
 ## H (i, j) = \cases{c_{i+j-1},&$i+j-1\le m$;\cr r_{i+j-m},&otherwise.\cr}
 ## $$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ##
 ## @example
 ## @group
 ## H(i,j) = c(i+j-1),  i+j-1 <= m;
 ## H(i,j) = r(i+j-m),  otherwise
 ## @end group
 ## @end example
diff --git a/scripts/special-matrix/hilb.m b/scripts/special-matrix/hilb.m
--- a/scripts/special-matrix/hilb.m
+++ b/scripts/special-matrix/hilb.m
@@ -15,32 +15,28 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} hilb (@var{n})
 ## Return the Hilbert matrix of order @var{n}.  The
-## @iftex
 ## @tex
 ## $i,\,j$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## i, j
 ## @end ifnottex
 ## element of a Hilbert matrix is defined as
-## @iftex
 ## @tex
 ## $$
 ## H (i, j) = {1 \over (i + j - 1)}
 ## $$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ##
 ## @example
 ## H (i, j) = 1 / (i + j - 1)
 ## @end example
 ## @end ifnottex
 ## @seealso{hankel, vander, sylvester_matrix, invhilb, toeplitz}
 ## @end deftypefn
diff --git a/scripts/special-matrix/sylvester_matrix.m b/scripts/special-matrix/sylvester_matrix.m
--- a/scripts/special-matrix/sylvester_matrix.m
+++ b/scripts/special-matrix/sylvester_matrix.m
@@ -15,21 +15,19 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} sylvester_matrix (@var{k})
 ## Return the Sylvester matrix of order
-## @iftex
 ## @tex
 ## $n = 2^k$.
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## n = 2^k.
 ## @end ifnottex
 ## @seealso{hankel, vander, hilb, invhilb, toeplitz}
 ## @end deftypefn
 
 ## Author: jwe
 
diff --git a/scripts/special-matrix/toeplitz.m b/scripts/special-matrix/toeplitz.m
--- a/scripts/special-matrix/toeplitz.m
+++ b/scripts/special-matrix/toeplitz.m
@@ -22,27 +22,25 @@
 ## @deftypefn {Function File} {} toeplitz (@var{c}, @var{r})
 ## Return the Toeplitz matrix constructed given the first column @var{c},
 ## and (optionally) the first row @var{r}.  If the first element of @var{c}
 ## is not the same as the first element of @var{r}, the first element of
 ## @var{c} is used.  If the second argument is omitted, the first row is
 ## taken to be the same as the first column.
 ##
 ## A square Toeplitz matrix has the form:
-## @iftex
 ## @tex
 ## $$
 ## \left[\matrix{c_0    & r_1     & r_2      & \cdots & r_n\cr
 ##               c_1    & c_0     & r_1      & \cdots & r_{n-1}\cr
 ##               c_2    & c_1     & c_0      & \cdots & r_{n-2}\cr
 ##               \vdots & \vdots  & \vdots   & \ddots & \vdots\cr
 ##               c_n    & c_{n-1} & c_{n-2} & \ldots & c_0}\right]
 ## $$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ##
 ## @example
 ## @group
 ## c(0)  r(1)   r(2)  @dots{}  r(n)
 ## c(1)  c(0)   r(1)  @dots{} r(n-1)
 ## c(2)  c(1)   c(0)  @dots{} r(n-2)
 ##  .     ,      ,   .      .
diff --git a/scripts/special-matrix/vander.m b/scripts/special-matrix/vander.m
--- a/scripts/special-matrix/vander.m
+++ b/scripts/special-matrix/vander.m
@@ -20,26 +20,24 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} vander (@var{c}, @var{n})
 ## Return the Vandermonde matrix whose next to last column is @var{c}.
 ## If @var{n} is specified, it determines the number of columns;
 ## otherwise, @var{n} is taken to be equal to the length of @var{c}.
 ##
 ## A Vandermonde matrix has the form:
-## @iftex
 ## @tex
 ## $$
 ## \left[\matrix{c_1^{n-1}  & \cdots & c_1^2  & c_1    & 1      \cr
 ##               c_2^{n-1}  & \cdots & c_2^2  & c_2    & 1      \cr
 ##               \vdots     & \ddots & \vdots & \vdots & \vdots \cr
 ##               c_n^{n-1}  & \cdots & c_n^2  & c_n    & 1      }\right]
 ## $$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ##
 ## @example
 ## @group
 ## c(1)^(n-1) @dots{} c(1)^2  c(1)  1
 ## c(2)^(n-1) @dots{} c(2)^2  c(2)  1
 ##     .     .      .      .    .
 ##     .       .    .      .    .
diff --git a/scripts/statistics/base/cloglog.m b/scripts/statistics/base/cloglog.m
--- a/scripts/statistics/base/cloglog.m
+++ b/scripts/statistics/base/cloglog.m
@@ -16,23 +16,21 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} cloglog (@var{x})
 ## Return the complementary log-log function of @var{x}, defined as
 ##
-## @iftex
 ## @tex
 ## $$
 ## {\rm cloglog}(x) = - \log (- \log (x))
 ## $$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## @example
 ## cloglog(x) = - log (- log (@var{x}))
 ## @end example
 ## @end ifnottex
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
diff --git a/scripts/statistics/base/cor.m b/scripts/statistics/base/cor.m
--- a/scripts/statistics/base/cor.m
+++ b/scripts/statistics/base/cor.m
@@ -20,23 +20,21 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} cor (@var{x}, @var{y})
 ## Compute correlation.
 ##
 ## The (@var{i}, @var{j})-th entry of @code{cor (@var{x}, @var{y})} is
 ## the correlation between the @var{i}-th variable in @var{x} and the
 ## @var{j}-th variable in @var{y}.
 ##
-## @iftex
 ## @tex
 ## $$
 ## {\rm corrcoef}(x,y) = {{\rm cov}(x,y) \over {\rm std}(x) {\rm std}(y)}
 ## $$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## @example
 ## corrcoef(x,y) = cov(x,y)/(std(x)*std(y))
 ## @end example
 ## @end ifnottex
 ##
 ## For matrices, each row is an observation and each column a variable;
 ## vectors are always observations and may be row or column vectors.
diff --git a/scripts/statistics/base/corrcoef.m b/scripts/statistics/base/corrcoef.m
--- a/scripts/statistics/base/corrcoef.m
+++ b/scripts/statistics/base/corrcoef.m
@@ -21,23 +21,21 @@
 ## @deftypefn {Function File} {} corrcoef (@var{x}, @var{y})
 ## Compute correlation.
 ##
 ## If each row of @var{x} and @var{y} is an observation and each column is
 ## a variable, the (@var{i}, @var{j})-th entry of
 ## @code{corrcoef (@var{x}, @var{y})} is the correlation between the
 ## @var{i}-th variable in @var{x} and the @var{j}-th variable in @var{y}.
 ##
-## @iftex
 ## @tex
 ## $$
 ## {\rm corrcoef}(x,y) = {{\rm cov}(x,y) \over {\rm std}(x) {\rm std}(y)}
 ## $$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## @example
 ## corrcoef(x,y) = cov(x,y)/(std(x)*std(y))
 ## @end example
 ## @end ifnottex
 ##
 ## If called with one argument, compute @code{corrcoef (@var{x}, @var{x})}.
 ## @end deftypefn
diff --git a/scripts/statistics/base/cov.m b/scripts/statistics/base/cov.m
--- a/scripts/statistics/base/cov.m
+++ b/scripts/statistics/base/cov.m
@@ -20,24 +20,22 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} cov (@var{x}, @var{y})
 ## Compute covariance.
 ##
 ## If each row of @var{x} and @var{y} is an observation and each column is
 ## a variable, the (@var{i}, @var{j})-th entry of
 ## @code{cov (@var{x}, @var{y})} is the covariance between the @var{i}-th
 ## variable in @var{x} and the @var{j}-th variable in @var{y}.
-## @iftex
 ## @tex
 ## $$
 ## \sigma_{ij} = {1 \over N-1} \sum_{i=1}^N (x_i - \bar{x})(y_i - \bar{y})
 ## $$
 ## where $\bar{x}$ and $\bar{y}$ are the mean values of $x$ and $y$.
 ## @end tex
-## @end iftex
 ## If called with one argument, compute @code{cov (@var{x}, @var{x})}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Compute covariances
 
 function c = cov (x, y)
 
diff --git a/scripts/statistics/base/gls.m b/scripts/statistics/base/gls.m
--- a/scripts/statistics/base/gls.m
+++ b/scripts/statistics/base/gls.m
@@ -15,34 +15,30 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{beta}, @var{v}, @var{r}] =} gls (@var{y}, @var{x}, @var{o})
 ## Generalized least squares estimation for the multivariate model
-## @iftex
 ## @tex
 ## $y = x b + e$
 ## with $\bar{e} = 0$ and cov(vec($e$)) = $(s^2)o$,
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## @math{y = x b + e} with @math{mean (e) = 0} and
 ## @math{cov (vec (e)) = (s^2) o},
 ## @end ifnottex
 ##  where
-## @iftex
 ## @tex
 ## $y$ is a $t \times p$ matrix, $x$ is a $t \times k$ matrix, $b$ is a $k
 ## \times p$ matrix, $e$ is a $t \times p$ matrix, and $o$ is a $tp \times
 ## tp$ matrix.
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## @math{y} is a @math{t} by @math{p} matrix, @math{x} is a @math{t} by
 ## @math{k} matrix, @math{b} is a @math{k} by @math{p} matrix, @math{e}
 ## is a @math{t} by @math{p} matrix, and @math{o} is a @math{t p} by
 ## @math{t p} matrix.
 ## @end ifnottex
 ##
 ## @noindent
diff --git a/scripts/statistics/base/kendall.m b/scripts/statistics/base/kendall.m
--- a/scripts/statistics/base/kendall.m
+++ b/scripts/statistics/base/kendall.m
@@ -28,51 +28,45 @@
 ## @code{kendall (@var{x})} is equivalent to @code{kendall (@var{x},
 ## @var{x})}.
 ##
 ## For two data vectors @var{x}, @var{y} of common length @var{n},
 ## Kendall's @var{tau} is the correlation of the signs of all rank
 ## differences of @var{x} and @var{y};  i.e., if both @var{x} and
 ## @var{y} have distinct entries, then
 ##
-## @iftex
 ## @tex
 ## $$ \tau = {1 \over n(n-1)} \sum_{i,j} {\rm sign}(q_i-q_j) {\rm sign}(r_i-r_j) $$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## @example
 ## @group
 ##          1    
 ## tau = -------   SUM sign (q(i) - q(j)) * sign (r(i) - r(j))
 ##       n (n-1)   i,j
 ## @end group
 ## @end example
 ## @end ifnottex
 ##
 ## @noindent
 ## in which the
-## @iftex
 ## @tex
 ## $q_i$ and $r_i$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## @var{q}(@var{i}) and @var{r}(@var{i})
 ## @end ifnottex
 ##  are the ranks of
 ## @var{x} and @var{y}, respectively.
 ##
 ## If @var{x} and @var{y} are drawn from independent distributions,
 ## Kendall's @var{tau} is asymptotically normal with mean 0 and variance
-## @iftex
 ## @tex
 ## ${2 (2n+5) \over 9n(n-1)}$.
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## @code{(2 * (2@var{n}+5)) / (9 * @var{n} * (@var{n}-1))}.
 ## @end ifnottex
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Kendall's rank correlation tau
 
diff --git a/scripts/statistics/base/kurtosis.m b/scripts/statistics/base/kurtosis.m
--- a/scripts/statistics/base/kurtosis.m
+++ b/scripts/statistics/base/kurtosis.m
@@ -15,24 +15,22 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} kurtosis (@var{x}, @var{dim})
 ## If @var{x} is a vector of length @math{N}, return the kurtosis
-## @iftex
 ## @tex
 ## $$
 ##  {\rm kurtosis} (x) = {1\over N \sigma(x)^4} \sum_{i=1}^N (x_i-\bar{x})^4 - 3
 ## $$
 ## where $\bar{x}$ is the mean value of $x$.
 ## @end tex
-## @end iftex
 ## @ifnottex
 ##
 ## @example
 ## kurtosis (x) = N^(-1) std(x)^(-4) sum ((x - mean(x)).^4) - 3
 ## @end example
 ## @end ifnottex
 ##
 ## @noindent
diff --git a/scripts/statistics/base/logit.m b/scripts/statistics/base/logit.m
--- a/scripts/statistics/base/logit.m
+++ b/scripts/statistics/base/logit.m
@@ -15,23 +15,21 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} logit (@var{p})
 ## For each component of @var{p}, return the logit of @var{p} defined as
-## @iftex
 ## @tex
 ## $$
 ## {\rm logit}(p) = \log\Big({p \over 1-p}\Big)
 ## $$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## @example
 ## logit(@var{p}) = log (@var{p} / (1-@var{p}))
 ## @end example
 ## @end ifnottex
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
diff --git a/scripts/statistics/base/mean.m b/scripts/statistics/base/mean.m
--- a/scripts/statistics/base/mean.m
+++ b/scripts/statistics/base/mean.m
@@ -15,21 +15,19 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} mean (@var{x}, @var{dim}, @var{opt})
 ## If @var{x} is a vector, compute the mean of the elements of @var{x}
-## @iftex
 ## @tex
 ## $$ {\rm mean}(x) = \bar{x} = {1\over N} \sum_{i=1}^N x_i $$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ##
 ## @example
 ## mean (x) = SUM_i x(i) / N
 ## @end example
 ## @end ifnottex
 ## If @var{x} is a matrix, compute the mean for each column and return them
 ## in a row vector.
diff --git a/scripts/statistics/base/median.m b/scripts/statistics/base/median.m
--- a/scripts/statistics/base/median.m
+++ b/scripts/statistics/base/median.m
@@ -17,25 +17,23 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} median (@var{x}, @var{dim})
 ## If @var{x} is a vector, compute the median value of the elements of
 ## @var{x}.  If the elements of @var{x} are sorted, the median is defined
 ## as
-## @iftex
 ## @tex
 ## $$
 ## {\rm median} (x) =
 ##   \cases{x(\lceil N/2\rceil), & $N$ odd;\cr
 ##           (x(N/2)+x(N/2+1))/2, & $N$ even.}
 ## $$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ##
 ## @example
 ## @group
 ##             x(ceil(N/2)),             N odd
 ## median(x) =
 ##             (x(N/2) + x((N/2)+1))/2,  N even
 ## @end group
diff --git a/scripts/statistics/base/ols.m b/scripts/statistics/base/ols.m
--- a/scripts/statistics/base/ols.m
+++ b/scripts/statistics/base/ols.m
@@ -15,34 +15,30 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{beta}, @var{sigma}, @var{r}] =} ols (@var{y}, @var{x})
 ## Ordinary least squares estimation for the multivariate model
-## @iftex
 ## @tex
 ## $y = x b + e$
 ## with
 ## $\bar{e} = 0$, and cov(vec($e$)) = kron ($s, I$)
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## @math{y = x b + e} with
 ## @math{mean (e) = 0} and @math{cov (vec (e)) = kron (s, I)}.
 ## @end ifnottex
 ##  where
-## @iftex
 ## @tex
 ## $y$ is a $t \times p$ matrix, $x$ is a $t \times k$ matrix,
 ## $b$ is a $k \times p$ matrix, and $e$ is a $t \times p$ matrix.
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## @math{y} is a @math{t} by @math{p} matrix, @math{x} is a @math{t} by
 ## @math{k} matrix, @math{b} is a @math{k} by @math{p} matrix, and
 ## @math{e} is a @math{t} by @math{p} matrix.
 ## @end ifnottex
 ##
 ## Each row of @var{y} and @var{x} is an observation and each column a
 ## variable.
diff --git a/scripts/statistics/base/skewness.m b/scripts/statistics/base/skewness.m
--- a/scripts/statistics/base/skewness.m
+++ b/scripts/statistics/base/skewness.m
@@ -15,24 +15,22 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} skewness (@var{x}, @var{dim})
 ## If @var{x} is a vector of length @math{n}, return the skewness
-## @iftex
 ## @tex
 ## $$
 ## {\rm skewness} (x) = {1\over N \sigma(x)^3} \sum_{i=1}^N (x_i-\bar{x})^3
 ## $$
 ## where $\bar{x}$ is the mean value of $x$.
 ## @end tex
-## @end iftex
 ## @ifnottex
 ##
 ## @example
 ## skewness (x) = N^(-1) std(x)^(-3) sum ((x - mean(x)).^3)
 ## @end example
 ## @end ifnottex
 ##
 ## @noindent
diff --git a/scripts/statistics/base/std.m b/scripts/statistics/base/std.m
--- a/scripts/statistics/base/std.m
+++ b/scripts/statistics/base/std.m
@@ -18,24 +18,22 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} std (@var{x})
 ## @deftypefnx {Function File} {} std (@var{x}, @var{opt})
 ## @deftypefnx {Function File} {} std (@var{x}, @var{opt}, @var{dim})
 ## If @var{x} is a vector, compute the standard deviation of the elements
 ## of @var{x}.
-## @iftex
 ## @tex
 ## $$
 ## {\rm std} (x) = \sigma (x) = \sqrt{{\sum_{i=1}^N (x_i - \bar{x})^2 \over N - 1}}
 ## $$
 ## where $\bar{x}$ is the mean value of $x$.
 ## @end tex
-## @end iftex
 ## @ifnottex
 ##
 ## @example
 ## @group
 ## std (x) = sqrt (sumsq (x - mean (x)) / (n - 1))
 ## @end group
 ## @end example
 ## @end ifnottex
diff --git a/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m b/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
--- a/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
+++ b/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
@@ -15,21 +15,19 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} kolmogorov_smirnov_cdf (@var{x}, @var{tol})
 ## Return the CDF at @var{x} of the Kolmogorov-Smirnov distribution,
-## @iftex
 ## @tex
 ## $$ Q(x) = \sum_{k=-\infty}^\infty (-1)^k \exp(-2 k^2 x^2) $$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## @example
 ## @group
 ##          Inf
 ## Q(x) =   SUM    (-1)^k exp(-2 k^2 x^2)
 ##        k = -Inf
 ## @end group
 ## @end example
diff --git a/scripts/statistics/distributions/wblcdf.m b/scripts/statistics/distributions/wblcdf.m
--- a/scripts/statistics/distributions/wblcdf.m
+++ b/scripts/statistics/distributions/wblcdf.m
@@ -17,22 +17,20 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} wblcdf (@var{x}, @var{scale}, @var{shape})
 ## Compute the cumulative distribution function (CDF) at @var{x} of the
 ## Weibull distribution with shape parameter @var{scale} and scale
 ## parameter @var{shape}, which is
 ##
-## @iftex
 ## @tex
 ## $$ 1 - \exp(-(x/shape)^{scale}) $$
 ## for $x\geq 0$.
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## @example
 ## 1 - exp(-(x/shape)^scale)
 ## @end example
 ## for @var{x} >= 0.
 ## @end ifnottex
 ## @end deftypefn
 
diff --git a/scripts/statistics/distributions/wblpdf.m b/scripts/statistics/distributions/wblpdf.m
--- a/scripts/statistics/distributions/wblpdf.m
+++ b/scripts/statistics/distributions/wblpdf.m
@@ -17,21 +17,19 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} wblpdf (@var{x}, @var{scale}, @var{shape})
 ## Compute the probability density function (PDF) at @var{x} of the
 ## Weibull distribution with shape parameter @var{scale} and scale
 ## parameter @var{shape} which is given by
 ##
-## @iftex
 ## @tex
 ## $$  scale \cdot shape^{-scale} x^{scale-1} \exp(-(x/shape)^{scale}) $$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## @example
 ##    scale * shape^(-scale) * x^(scale-1) * exp(-(x/shape)^scale)
 ## @end example
 ## @end ifnottex
 ##
 ## @noindent
 ## for @var{x} > 0.
diff --git a/scripts/statistics/tests/hotelling_test_2.m b/scripts/statistics/tests/hotelling_test_2.m
--- a/scripts/statistics/tests/hotelling_test_2.m
+++ b/scripts/statistics/tests/hotelling_test_2.m
@@ -21,23 +21,21 @@
 ## @deftypefn {Function File} {[@var{pval}, @var{tsq}] =} hotelling_test_2 (@var{x}, @var{y})
 ## For two samples @var{x} from multivariate normal distributions with
 ## the same number of variables (columns), unknown means and unknown
 ## equal covariance matrices, test the null hypothesis @code{mean
 ## (@var{x}) == mean (@var{y})}.
 ##
 ## Hotelling's two-sample @math{T^2} is returned in @var{tsq}.  Under the null,
 ##
-## @iftex
 ## @tex
 ## $$
 ## {n_x+n_y-p-1) T^2 \over p(n_x+n_y-2)}
 ## $$
 ## @end tex
-## @end iftex
 ## @ifnottex
 ## @example
 ## (n_x+n_y-p-1) T^2 / (p(n_x+n_y-2))
 ## @end example
 ## @end ifnottex
 ##
 ## @noindent
 ## has an F distribution with @math{p} and @math{n_x+n_y-p-1} degrees of
