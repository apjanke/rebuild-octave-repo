# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1455608849 18000
#      Tue Feb 16 02:47:29 2016 -0500
# Node ID 3c8a3d35661a6422812b35416970181128a5d12c
# Parent  f08ae27289e40c4732fff014d825d3ff95a86011
better use of templates for Cholesky factorization

* liboctave/numeric/chol.h, liboctave/numeric/chol.cc: New files
generated from CmplxCHOL.cc, fCmplxCHOL.cc, floatCHOL.cc, CmplxCHOL.h,
dbleCHOL.cc, dbleCHOL.h, fCmplxCHOL.h, and floatCHOL.h and converted
to templates.

* liboctave/numeric/module.mk: Update.

* __qp__.cc, chol.cc, CMatrix.cc, CMatrix.h, dMatrix.cc, dMatrix.h,
fCMatrix.cc, fCMatrix.h, fMatrix.cc, fMatrix.h, eigs-base.cc,
mx-defs.h, mx-ext.h: Use new classes.

diff --git a/libinterp/corefcn/__qp__.cc b/libinterp/corefcn/__qp__.cc
--- a/libinterp/corefcn/__qp__.cc
+++ b/libinterp/corefcn/__qp__.cc
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #  include <config.h>
 #endif
 
 #include <cfloat>
 
-#include "dbleCHOL.h"
+#include "chol.h"
 #include "dbleSVD.h"
 #include "mx-m-dm.h"
 #include "EIG.h"
 
 #include "defun.h"
 #include "error.h"
 #include "errwarn.h"
 #include "ovl.h"
@@ -186,17 +186,17 @@ qp (const Matrix& H, const ColumnVector&
           // There are no active constraints.
 
           if (minReal > 0.0)
             {
               // Inverting the Hessian.  Using the Cholesky
               // factorization since the Hessian is positive
               // definite.
 
-              CHOL cholH (H);
+              chol<Matrix> cholH (H);
 
               R = cholH.chol_matrix ();
 
               Matrix Hinv = chol2inv (R);
 
               // Computing the unconstrained step.
               // p = -Hinv * g;
 
@@ -245,17 +245,17 @@ qp (const Matrix& H, const ColumnVector&
 
           octave_idx_type pR = 0;
 
           if (dimZ > 0)
             {
               // Computing the Cholesky factorization (pR = 0 means
               // that the reduced Hessian was positive definite).
 
-              CHOL cholrH (rH, pR);
+              chol<Matrix> cholrH (rH, pR);
               Matrix tR = cholrH.chol_matrix ();
               if (pR == 0)
                 R = tR;
             }
 
           if (pR == 0)
             {
               info = 0;
diff --git a/libinterp/dldfcn/chol.cc b/libinterp/dldfcn/chol.cc
--- a/libinterp/dldfcn/chol.cc
+++ b/libinterp/dldfcn/chol.cc
@@ -22,20 +22,17 @@ along with Octave; see the file COPYING.
 
 */
 
 
 #ifdef HAVE_CONFIG_H
 #  include <config.h>
 #endif
 
-#include "CmplxCHOL.h"
-#include "dbleCHOL.h"
-#include "fCmplxCHOL.h"
-#include "floatCHOL.h"
+#include "chol.h"
 #include "sparse-chol.h"
 #include "oct-spparms.h"
 #include "sparse-util.h"
 
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 #include "defun-dld.h"
 #include "error.h"
@@ -245,32 +242,30 @@ sparse matrices.\n\
   else if (arg.is_single_type ())
     {
       if (arg.is_real_type ())
         {
           FloatMatrix m = arg.float_matrix_value ();
 
           octave_idx_type info;
 
-          FloatCHOL fact;
-          fact = FloatCHOL (m, info, LLt != true);
+          chol<FloatMatrix> fact (m, info, LLt != true);
 
           if (nargout == 2 || info == 0)
             retval = ovl (get_chol (fact), info);
           else
             error ("chol: input matrix must be positive definite");
         }
       else if (arg.is_complex_type ())
         {
           FloatComplexMatrix m = arg.float_complex_matrix_value ();
 
           octave_idx_type info;
 
-          FloatComplexCHOL fact;
-          fact = FloatComplexCHOL (m, info, LLt != true);
+          chol<FloatComplexMatrix> fact (m, info, LLt != true);
 
           if (nargout == 2 || info == 0)
             retval = ovl (get_chol (fact), info);
           else
             error ("chol: input matrix must be positive definite");
         }
       else
         err_wrong_type_arg ("chol", arg);
@@ -278,32 +273,30 @@ sparse matrices.\n\
   else
     {
       if (arg.is_real_type ())
         {
           Matrix m = arg.matrix_value ();
 
           octave_idx_type info;
 
-          CHOL fact;
-          fact = CHOL (m, info, LLt != true);
+          chol<Matrix> fact (m, info, LLt != true);
 
           if (nargout == 2 || info == 0)
             retval = ovl (get_chol (fact), info);
           else
             error ("chol: input matrix must be positive definite");
         }
       else if (arg.is_complex_type ())
         {
           ComplexMatrix m = arg.complex_matrix_value ();
 
           octave_idx_type info;
 
-          ComplexCHOL fact;
-          fact = ComplexCHOL (m, info, LLt != true);
+          chol<ComplexMatrix> fact (m, info, LLt != true);
 
           if (nargout == 2 || info == 0)
             retval = ovl (get_chol (fact), info);
           else
             error ("chol: input matrix must be positive definite");
         }
       else
         err_wrong_type_arg ("chol", arg);
@@ -380,55 +373,55 @@ the Cholesky@tie{}factorization.\n\
         }
       else if (arg.is_single_type ())
         {
           if (arg.is_real_type ())
             {
               FloatMatrix m = arg.float_matrix_value ();
 
               octave_idx_type info;
-              FloatCHOL chol (m, info);
+              chol<FloatMatrix> chol (m, info);
               if (info == 0)
                 retval = chol.inverse ();
               else
                 error ("cholinv: A must be positive definite");
             }
           else if (arg.is_complex_type ())
             {
               FloatComplexMatrix m = arg.float_complex_matrix_value ();
 
               octave_idx_type info;
-              FloatComplexCHOL chol (m, info);
+              chol<FloatComplexMatrix> chol (m, info);
               if (info == 0)
                 retval = chol.inverse ();
               else
                 error ("cholinv: A must be positive definite");
             }
           else
             err_wrong_type_arg ("chol", arg);
         }
       else
         {
           if (arg.is_real_type ())
             {
               Matrix m = arg.matrix_value ();
 
               octave_idx_type info;
-              CHOL chol (m, info);
+              chol<Matrix> chol (m, info);
               if (info == 0)
                 retval = chol.inverse ();
               else
                 error ("cholinv: A must be positive definite");
             }
           else if (arg.is_complex_type ())
             {
               ComplexMatrix m = arg.complex_matrix_value ();
 
               octave_idx_type info;
-              ComplexCHOL chol (m, info);
+              chol<ComplexMatrix> chol (m, info);
               if (info == 0)
                 retval = chol.inverse ();
               else
                 error ("cholinv: A must be positive definite");
             }
           else
             err_wrong_type_arg ("chol", arg);
         }
@@ -597,34 +590,34 @@ If @var{info} is not present, an error m
   if (argr.is_single_type () || argu.is_single_type ())
     {
       if (argr.is_real_type () && argu.is_real_type ())
         {
           // real case
           FloatMatrix R = argr.float_matrix_value ();
           FloatColumnVector u = argu.float_column_vector_value ();
 
-          FloatCHOL fact;
+          chol<FloatMatrix> fact;
           fact.set (R);
 
           if (down)
             err = fact.downdate (u);
           else
             fact.update (u);
 
           retval = ovl (get_chol_r (fact));
         }
       else
         {
           // complex case
           FloatComplexMatrix R = argr.float_complex_matrix_value ();
           FloatComplexColumnVector u =
             argu.float_complex_column_vector_value ();
 
-          FloatComplexCHOL fact;
+          chol<FloatComplexMatrix> fact;
           fact.set (R);
 
           if (down)
             err = fact.downdate (u);
           else
             fact.update (u);
 
           retval = ovl (get_chol_r (fact));
@@ -633,33 +626,33 @@ If @var{info} is not present, an error m
   else
     {
       if (argr.is_real_type () && argu.is_real_type ())
         {
           // real case
           Matrix R = argr.matrix_value ();
           ColumnVector u = argu.column_vector_value ();
 
-          CHOL fact;
+          chol<Matrix> fact;
           fact.set (R);
 
           if (down)
             err = fact.downdate (u);
           else
             fact.update (u);
 
           retval = ovl (get_chol_r (fact));
         }
       else
         {
           // complex case
           ComplexMatrix R = argr.complex_matrix_value ();
           ComplexColumnVector u = argu.complex_column_vector_value ();
 
-          ComplexCHOL fact;
+          chol<ComplexMatrix> fact;
           fact.set (R);
 
           if (down)
             err = fact.downdate (u);
           else
             fact.update (u);
 
           retval = ovl (get_chol_r (fact));
@@ -788,58 +781,58 @@ If @var{info} is not present, an error m
   if (argr.is_single_type () || argu.is_single_type ())
     {
       if (argr.is_real_type () && argu.is_real_type ())
         {
           // real case
           FloatMatrix R = argr.float_matrix_value ();
           FloatColumnVector u = argu.float_column_vector_value ();
 
-          FloatCHOL fact;
+          chol<FloatMatrix> fact;
           fact.set (R);
           err = fact.insert_sym (u, j-1);
 
           retval = ovl (get_chol_r (fact));
         }
       else
         {
           // complex case
           FloatComplexMatrix R = argr.float_complex_matrix_value ();
           FloatComplexColumnVector u =
             argu.float_complex_column_vector_value ();
 
-          FloatComplexCHOL fact;
+          chol<FloatComplexMatrix> fact;
           fact.set (R);
           err = fact.insert_sym (u, j-1);
 
           retval = ovl (get_chol_r (fact));
         }
     }
   else
     {
       if (argr.is_real_type () && argu.is_real_type ())
         {
           // real case
           Matrix R = argr.matrix_value ();
           ColumnVector u = argu.column_vector_value ();
 
-          CHOL fact;
+          chol<Matrix> fact;
           fact.set (R);
           err = fact.insert_sym (u, j-1);
 
           retval = ovl (get_chol_r (fact));
         }
       else
         {
           // complex case
           ComplexMatrix R = argr.complex_matrix_value ();
           ComplexColumnVector u =
             argu.complex_column_vector_value ();
 
-          ComplexCHOL fact;
+          chol<ComplexMatrix> fact;
           fact.set (R);
           err = fact.insert_sym (u, j-1);
 
           retval = ovl (get_chol_r (fact));
         }
     }
 
   if (nargout > 1)
@@ -1023,53 +1016,53 @@ triangular, return the Cholesky@tie{}fac
 
   if (argr.is_single_type ())
     {
       if (argr.is_real_type ())
         {
           // real case
           FloatMatrix R = argr.float_matrix_value ();
 
-          FloatCHOL fact;
+          chol<FloatMatrix> fact;
           fact.set (R);
           fact.delete_sym (j-1);
 
           retval = ovl (get_chol_r (fact));
         }
       else
         {
           // complex case
           FloatComplexMatrix R = argr.float_complex_matrix_value ();
 
-          FloatComplexCHOL fact;
+          chol<FloatComplexMatrix> fact;
           fact.set (R);
           fact.delete_sym (j-1);
 
           retval = ovl (get_chol_r (fact));
         }
     }
   else
     {
       if (argr.is_real_type ())
         {
           // real case
           Matrix R = argr.matrix_value ();
 
-          CHOL fact;
+          chol<Matrix> fact;
           fact.set (R);
           fact.delete_sym (j-1);
 
           retval = ovl (get_chol_r (fact));
         }
       else
         {
           // complex case
           ComplexMatrix R = argr.complex_matrix_value ();
 
-          ComplexCHOL fact;
+          chol<ComplexMatrix> fact;
           fact.set (R);
           fact.delete_sym (j-1);
 
           retval = ovl (get_chol_r (fact));
         }
     }
 
   return retval;
@@ -1153,53 +1146,53 @@ triangular, return the Cholesky@tie{}fac
   if (argr.is_single_type () && argi.is_single_type ()
       && argj.is_single_type ())
     {
       if (argr.is_real_type ())
         {
           // real case
           FloatMatrix R = argr.float_matrix_value ();
 
-          FloatCHOL fact;
+          chol<FloatMatrix> fact;
           fact.set (R);
           fact.shift_sym (i-1, j-1);
 
           retval = ovl (get_chol_r (fact));
         }
       else
         {
           // complex case
           FloatComplexMatrix R = argr.float_complex_matrix_value ();
 
-          FloatComplexCHOL fact;
+          chol<FloatComplexMatrix> fact;
           fact.set (R);
           fact.shift_sym (i-1, j-1);
 
           retval = ovl (get_chol_r (fact));
         }
     }
   else
     {
       if (argr.is_real_type ())
         {
           // real case
           Matrix R = argr.matrix_value ();
 
-          CHOL fact;
+          chol<Matrix> fact;
           fact.set (R);
           fact.shift_sym (i-1, j-1);
 
           retval = ovl (get_chol_r (fact));
         }
       else
         {
           // complex case
           ComplexMatrix R = argr.complex_matrix_value ();
 
-          ComplexCHOL fact;
+          chol<ComplexMatrix> fact;
           fact.set (R);
           fact.shift_sym (i-1, j-1);
 
           retval = ovl (get_chol_r (fact));
         }
     }
 
   return retval;
diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -33,24 +33,24 @@ along with Octave; see the file COPYING.
 #include <vector>
 
 // FIXME
 #include <sys/types.h>
 
 #include "Array-util.h"
 #include "boolMatrix.h"
 #include "chMatrix.h"
+#include "chol.h"
 #include "dMatrix.h"
 #include "CMatrix.h"
 #include "CNDArray.h"
 #include "CRowVector.h"
 #include "dRowVector.h"
 #include "CDiagMatrix.h"
 #include "dDiagMatrix.h"
-#include "CmplxCHOL.h"
 #include "schur.h"
 #include "CmplxSVD.h"
 #include "DET.h"
 #include "f77-fcn.h"
 #include "functor.h"
 #include "lo-error.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
@@ -1104,17 +1104,17 @@ ComplexMatrix::inverse (MatrixType &matt
     typ = mattype.type (*this);
 
   if (typ == MatrixType::Upper || typ == MatrixType::Lower)
     ret = tinverse (mattype, info, rcon, force, calc_cond);
   else
     {
       if (mattype.is_hermitian ())
         {
-          ComplexCHOL chol (*this, info, true, calc_cond);
+          chol<ComplexMatrix> chol (*this, info, true, calc_cond);
           if (info == 0)
             {
               if (calc_cond)
                 rcon = chol.rcond ();
               else
                 rcon = 1.0;
               ret = chol.inverse ();
             }
diff --git a/liboctave/array/CMatrix.h b/liboctave/array/CMatrix.h
--- a/liboctave/array/CMatrix.h
+++ b/liboctave/array/CMatrix.h
@@ -45,16 +45,19 @@ public:
   typedef ComplexRowVector row_vector_type;
 
   typedef ColumnVector real_column_vector_type;
   typedef RowVector real_row_vector_type;
 
   typedef Matrix real_matrix_type;
   typedef ComplexMatrix complex_matrix_type;
 
+  typedef double real_elt_type;
+  typedef Complex complex_elt_type;
+
   typedef void (*solve_singularity_handler) (double rcon);
 
   ComplexMatrix (void) : ComplexNDArray () { }
 
   ComplexMatrix (octave_idx_type r, octave_idx_type c)
     : ComplexNDArray (dim_vector (r, c)) { }
 
   ComplexMatrix (octave_idx_type r, octave_idx_type c, const Complex& val)
diff --git a/liboctave/array/dMatrix.cc b/liboctave/array/dMatrix.cc
--- a/liboctave/array/dMatrix.cc
+++ b/liboctave/array/dMatrix.cc
@@ -31,27 +31,27 @@ along with Octave; see the file COPYING.
 
 #include <iostream>
 #include <vector>
 
 #include "Array-util.h"
 #include "byte-swap.h"
 #include "boolMatrix.h"
 #include "chMatrix.h"
+#include "chol.h"
 #include "dMatrix.h"
 #include "dDiagMatrix.h"
 #include "CMatrix.h"
 #include "dColVector.h"
 #include "dRowVector.h"
 #include "CColVector.h"
 #include "PermMatrix.h"
 #include "DET.h"
 #include "schur.h"
 #include "dbleSVD.h"
-#include "dbleCHOL.h"
 #include "f77-fcn.h"
 #include "functor.h"
 #include "lo-error.h"
 #include "oct-locbuf.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "lo-utils.h"
 #include "mx-m-dm.h"
@@ -794,17 +794,17 @@ Matrix::inverse (MatrixType &mattype, oc
     typ = mattype.type (*this);
 
   if (typ == MatrixType::Upper || typ == MatrixType::Lower)
     ret = tinverse (mattype, info, rcon, force, calc_cond);
   else
     {
       if (mattype.is_hermitian ())
         {
-          CHOL chol (*this, info, true, calc_cond);
+          chol<Matrix> chol (*this, info, true, calc_cond);
           if (info == 0)
             {
               if (calc_cond)
                 rcon = chol.rcond ();
               else
                 rcon = 1.0;
               ret = chol.inverse ();
             }
diff --git a/liboctave/array/dMatrix.h b/liboctave/array/dMatrix.h
--- a/liboctave/array/dMatrix.h
+++ b/liboctave/array/dMatrix.h
@@ -44,16 +44,19 @@ public:
   typedef RowVector row_vector_type;
 
   typedef ColumnVector real_column_vector_type;
   typedef RowVector real_row_vector_type;
 
   typedef Matrix real_matrix_type;
   typedef ComplexMatrix complex_matrix_type;
 
+  typedef double real_elt_type;
+  typedef Complex complex_elt_type;
+
   typedef void (*solve_singularity_handler) (double rcon);
 
   Matrix (void) : NDArray () { }
 
   Matrix (octave_idx_type r, octave_idx_type c)
     : NDArray (dim_vector (r, c)) { }
 
   Matrix (octave_idx_type r, octave_idx_type c, double val)
diff --git a/liboctave/array/fCMatrix.cc b/liboctave/array/fCMatrix.cc
--- a/liboctave/array/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -35,22 +35,22 @@ along with Octave; see the file COPYING.
 // FIXME
 #include <sys/types.h>
 
 #include "Array-util.h"
 #include "DET.h"
 #include "f77-fcn.h"
 #include "boolMatrix.h"
 #include "chMatrix.h"
+#include "chol.h"
 #include "fCMatrix.h"
 #include "fCNDArray.h"
 #include "fCDiagMatrix.h"
 #include "fCColVector.h"
 #include "fCRowVector.h"
-#include "fCmplxCHOL.h"
 #include "schur.h"
 #include "fCmplxSVD.h"
 #include "functor.h"
 #include "lo-error.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "lo-utils.h"
 #include "mx-fcm-fdm.h"
@@ -1107,17 +1107,17 @@ FloatComplexMatrix::inverse (MatrixType 
     typ = mattype.type (*this);
 
   if (typ == MatrixType::Upper || typ == MatrixType::Lower)
     ret = tinverse (mattype, info, rcon, force, calc_cond);
   else
     {
       if (mattype.is_hermitian ())
         {
-          FloatComplexCHOL chol (*this, info, true, calc_cond);
+          chol<FloatComplexMatrix> chol (*this, info, true, calc_cond);
           if (info == 0)
             {
               if (calc_cond)
                 rcon = chol.rcond ();
               else
                 rcon = 1.0;
               ret = chol.inverse ();
             }
diff --git a/liboctave/array/fCMatrix.h b/liboctave/array/fCMatrix.h
--- a/liboctave/array/fCMatrix.h
+++ b/liboctave/array/fCMatrix.h
@@ -45,16 +45,19 @@ public:
   typedef FloatComplexRowVector row_vector_type;
 
   typedef FloatColumnVector real_column_vector_type;
   typedef FloatRowVector real_row_vector_type;
 
   typedef FloatMatrix real_matrix_type;
   typedef FloatComplexMatrix complex_matrix_type;
 
+  typedef float real_elt_type;
+  typedef FloatComplex complex_elt_type;
+
   typedef void (*solve_singularity_handler) (float rcon);
 
   FloatComplexMatrix (void) : FloatComplexNDArray () { }
 
   FloatComplexMatrix (octave_idx_type r, octave_idx_type c)
     : FloatComplexNDArray (dim_vector (r, c)) { }
 
   FloatComplexMatrix (octave_idx_type r, octave_idx_type c,
diff --git a/liboctave/array/fMatrix.cc b/liboctave/array/fMatrix.cc
--- a/liboctave/array/fMatrix.cc
+++ b/liboctave/array/fMatrix.cc
@@ -31,28 +31,28 @@ along with Octave; see the file COPYING.
 
 #include <iostream>
 #include <vector>
 
 #include "fNDArray.h"
 #include "Array-util.h"
 #include "boolMatrix.h"
 #include "chMatrix.h"
+#include "chol.h"
 #include "fMatrix.h"
 #include "fDiagMatrix.h"
 #include "fCMatrix.h"
 #include "fColVector.h"
 #include "fRowVector.h"
 #include "fCColVector.h"
 #include "PermMatrix.h"
 #include "DET.h"
 #include "byte-swap.h"
 #include "f77-fcn.h"
 #include "fMatrix.h"
-#include "floatCHOL.h"
 #include "schur.h"
 #include "floatSVD.h"
 #include "functor.h"
 #include "lo-error.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "lo-utils.h"
 #include "mx-fdm-fm.h"
@@ -801,17 +801,17 @@ FloatMatrix::inverse (MatrixType &mattyp
     typ = mattype.type (*this);
 
   if (typ == MatrixType::Upper || typ == MatrixType::Lower)
     ret = tinverse (mattype, info, rcon, force, calc_cond);
   else
     {
       if (mattype.is_hermitian ())
         {
-          FloatCHOL chol (*this, info, true, calc_cond);
+          chol<FloatMatrix> chol (*this, info, true, calc_cond);
           if (info == 0)
             {
               if (calc_cond)
                 rcon = chol.rcond ();
               else
                 rcon = 1.0;
               ret = chol.inverse ();
             }
diff --git a/liboctave/array/fMatrix.h b/liboctave/array/fMatrix.h
--- a/liboctave/array/fMatrix.h
+++ b/liboctave/array/fMatrix.h
@@ -44,16 +44,19 @@ public:
   typedef FloatRowVector row_vector_type;
 
   typedef FloatColumnVector real_column_vector_type;
   typedef FloatRowVector real_row_vector_type;
 
   typedef FloatMatrix real_matrix_type;
   typedef FloatComplexMatrix complex_matrix_type;
 
+  typedef float real_elt_type;
+  typedef FloatComplex complex_elt_type;
+
   typedef void (*solve_singularity_handler) (float rcon);
 
   FloatMatrix (void) : FloatNDArray () { }
 
   FloatMatrix (octave_idx_type r, octave_idx_type c)
     : FloatNDArray (dim_vector (r, c)) { }
 
   FloatMatrix (octave_idx_type r, octave_idx_type c, float val)
diff --git a/liboctave/numeric/CmplxCHOL.cc b/liboctave/numeric/CmplxCHOL.cc
deleted file mode 100644
--- a/liboctave/numeric/CmplxCHOL.cc
+++ /dev/null
@@ -1,447 +0,0 @@
-/*
-
-Copyright (C) 1994-2015 John W. Eaton
-Copyright (C) 2008-2009 Jaroslav Hajek
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-
-#include <vector>
-
-#include "dMatrix.h"
-#include "dRowVector.h"
-#include "CmplxCHOL.h"
-#include "f77-fcn.h"
-#include "lo-error.h"
-#include "oct-locbuf.h"
-#include "oct-norm.h"
-#ifndef HAVE_QRUPDATE
-#  include "dbleQR.h"
-#endif
-
-extern "C"
-{
-  F77_RET_T
-  F77_FUNC (zpotrf, ZPOTRF) (F77_CONST_CHAR_ARG_DECL,
-                             const octave_idx_type&, Complex*,
-                             const octave_idx_type&, octave_idx_type&
-                             F77_CHAR_ARG_LEN_DECL);
-  F77_RET_T
-  F77_FUNC (zpotri, ZPOTRI) (F77_CONST_CHAR_ARG_DECL,
-                             const octave_idx_type&, Complex*,
-                             const octave_idx_type&, octave_idx_type&
-                             F77_CHAR_ARG_LEN_DECL);
-
-  F77_RET_T
-  F77_FUNC (zpocon, ZPOCON) (F77_CONST_CHAR_ARG_DECL,
-                             const octave_idx_type&, Complex*,
-                             const octave_idx_type&, const double&,
-                             double&, Complex*, double*, octave_idx_type&
-                             F77_CHAR_ARG_LEN_DECL);
-#ifdef HAVE_QRUPDATE
-
-  F77_RET_T
-  F77_FUNC (zch1up, ZCH1UP) (const octave_idx_type&, Complex*,
-                             const octave_idx_type&, Complex*, double*);
-
-  F77_RET_T
-  F77_FUNC (zch1dn, ZCH1DN) (const octave_idx_type&, Complex*,
-                             const octave_idx_type&, Complex*, double*,
-                             octave_idx_type&);
-
-  F77_RET_T
-  F77_FUNC (zchinx, ZCHINX) (const octave_idx_type&, Complex*,
-                             const octave_idx_type&, const octave_idx_type&,
-                             Complex*, double*, octave_idx_type&);
-
-  F77_RET_T
-  F77_FUNC (zchdex, ZCHDEX) (const octave_idx_type&, Complex*,
-                             const octave_idx_type&, const octave_idx_type&,
-                             double*);
-
-  F77_RET_T
-  F77_FUNC (zchshx, ZCHSHX) (const octave_idx_type&, Complex*,
-                             const octave_idx_type&, const octave_idx_type&,
-                             const octave_idx_type&, Complex*, double*);
-#endif
-}
-
-octave_idx_type
-ComplexCHOL::init (const ComplexMatrix& a, bool upper, bool calc_cond)
-{
-  octave_idx_type a_nr = a.rows ();
-  octave_idx_type a_nc = a.cols ();
-
-  if (a_nr != a_nc)
-    (*current_liboctave_error_handler) ("ComplexCHOL requires square matrix");
-
-  octave_idx_type n = a_nc;
-  octave_idx_type info;
-
-  is_upper = upper;
-
-  chol_mat.clear (n, n);
-  if (is_upper)
-    for (octave_idx_type j = 0; j < n; j++)
-      {
-        for (octave_idx_type i = 0; i <= j; i++)
-          chol_mat.xelem (i, j) = a(i, j);
-        for (octave_idx_type i = j+1; i < n; i++)
-          chol_mat.xelem (i, j) = 0.0;
-      }
-  else
-    for (octave_idx_type j = 0; j < n; j++)
-      {
-        for (octave_idx_type i = 0; i < j; i++)
-          chol_mat.xelem (i, j) = 0.0;
-        for (octave_idx_type i = j; i < n; i++)
-          chol_mat.xelem (i, j) = a(i, j);
-      }
-  Complex *h = chol_mat.fortran_vec ();
-
-  // Calculate the norm of the matrix, for later use.
-  double anorm = 0;
-  if (calc_cond)
-    anorm = xnorm (a, 1);
-
-  if (is_upper)
-    F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 ("U", 1), n, h, n, info
-                               F77_CHAR_ARG_LEN (1)));
-  else
-    F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1), n, h, n, info
-                               F77_CHAR_ARG_LEN (1)));
-
-  xrcond = 0.0;
-  if (info > 0)
-    chol_mat.resize (info - 1, info - 1);
-  else if (calc_cond)
-    {
-      octave_idx_type zpocon_info = 0;
-
-      // Now calculate the condition number for non-singular matrix.
-      Array<Complex> z (dim_vector (2*n, 1));
-      Complex *pz = z.fortran_vec ();
-      Array<double> rz (dim_vector (n, 1));
-      double *prz = rz.fortran_vec ();
-      F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 ("U", 1), n, h,
-                                 n, anorm, xrcond, pz, prz, zpocon_info
-                                 F77_CHAR_ARG_LEN (1)));
-
-      if (zpocon_info != 0)
-        info = -1;
-    }
-
-  return info;
-}
-
-static ComplexMatrix
-chol2inv_internal (const ComplexMatrix& r, bool is_upper = true)
-{
-  ComplexMatrix retval;
-
-  octave_idx_type r_nr = r.rows ();
-  octave_idx_type r_nc = r.cols ();
-
-  if (r_nr != r_nc)
-    (*current_liboctave_error_handler) ("chol2inv requires square matrix");
-
-  octave_idx_type n = r_nc;
-  octave_idx_type info;
-
-  ComplexMatrix tmp = r;
-
-  if (is_upper)
-    F77_XFCN (zpotri, ZPOTRI, (F77_CONST_CHAR_ARG2 ("U", 1), n,
-                               tmp.fortran_vec (), n, info
-                               F77_CHAR_ARG_LEN (1)));
-  else
-    F77_XFCN (zpotri, ZPOTRI, (F77_CONST_CHAR_ARG2 ("L", 1), n,
-                               tmp.fortran_vec (), n, info
-                               F77_CHAR_ARG_LEN (1)));
-
-  // If someone thinks of a more graceful way of doing this (or
-  // faster for that matter :-)), please let me know!
-
-  if (n > 1)
-    {
-      if (is_upper)
-        for (octave_idx_type j = 0; j < r_nc; j++)
-          for (octave_idx_type i = j+1; i < r_nr; i++)
-            tmp.xelem (i, j) = tmp.xelem (j, i);
-      else
-        for (octave_idx_type j = 0; j < r_nc; j++)
-          for (octave_idx_type i = j+1; i < r_nr; i++)
-            tmp.xelem (j, i) = tmp.xelem (i, j);
-    }
-
-  retval = tmp;
-
-  return retval;
-}
-
-// Compute the inverse of a matrix using the Cholesky factorization.
-ComplexMatrix
-ComplexCHOL::inverse (void) const
-{
-  return chol2inv_internal (chol_mat, is_upper);
-}
-
-void
-ComplexCHOL::set (const ComplexMatrix& R)
-{
-  if (R.is_square ())
-    chol_mat = R;
-  else
-    (*current_liboctave_error_handler) ("CHOL requires square matrix");
-}
-
-#ifdef HAVE_QRUPDATE
-
-void
-ComplexCHOL::update (const ComplexColumnVector& u)
-{
-  octave_idx_type n = chol_mat.rows ();
-
-  if (u.numel () != n)
-    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
-
-  ComplexColumnVector utmp = u;
-
-  OCTAVE_LOCAL_BUFFER (double, rw, n);
-
-  F77_XFCN (zch1up, ZCH1UP, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                             utmp.fortran_vec (), rw));
-}
-
-octave_idx_type
-ComplexCHOL::downdate (const ComplexColumnVector& u)
-{
-  octave_idx_type info = -1;
-
-  octave_idx_type n = chol_mat.rows ();
-
-  if (u.numel () != n)
-    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
-
-  ComplexColumnVector utmp = u;
-
-  OCTAVE_LOCAL_BUFFER (double, rw, n);
-
-  F77_XFCN (zch1dn, ZCH1DN, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                             utmp.fortran_vec (), rw, info));
-
-  return info;
-}
-
-octave_idx_type
-ComplexCHOL::insert_sym (const ComplexColumnVector& u, octave_idx_type j)
-{
-  octave_idx_type info = -1;
-
-  octave_idx_type n = chol_mat.rows ();
-
-  if (u.numel () != n + 1)
-    (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
-  if (j < 0 || j > n)
-    (*current_liboctave_error_handler) ("cholinsert: index out of range");
-
-  ComplexColumnVector utmp = u;
-
-  OCTAVE_LOCAL_BUFFER (double, rw, n);
-
-  chol_mat.resize (n+1, n+1);
-
-  F77_XFCN (zchinx, ZCHINX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                             j + 1, utmp.fortran_vec (), rw, info));
-
-  return info;
-}
-
-void
-ComplexCHOL::delete_sym (octave_idx_type j)
-{
-  octave_idx_type n = chol_mat.rows ();
-
-  if (j < 0 || j > n-1)
-    (*current_liboctave_error_handler) ("choldelete: index out of range");
-
-  OCTAVE_LOCAL_BUFFER (double, rw, n);
-
-  F77_XFCN (zchdex, ZCHDEX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                             j + 1, rw));
-
-  chol_mat.resize (n-1, n-1);
-}
-
-void
-ComplexCHOL::shift_sym (octave_idx_type i, octave_idx_type j)
-{
-  octave_idx_type n = chol_mat.rows ();
-
-  if (i < 0 || i > n-1 || j < 0 || j > n-1)
-    (*current_liboctave_error_handler) ("cholshift: index out of range");
-
-  OCTAVE_LOCAL_BUFFER (Complex, w, n);
-  OCTAVE_LOCAL_BUFFER (double, rw, n);
-
-  F77_XFCN (zchshx, ZCHSHX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                             i + 1, j + 1, w, rw));
-}
-
-#else
-
-void
-ComplexCHOL::update (const ComplexColumnVector& u)
-{
-  warn_qrupdate_once ();
-
-  octave_idx_type n = chol_mat.rows ();
-
-  if (u.numel () != n)
-    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
-
-  init (chol_mat.hermitian () * chol_mat
-        + ComplexMatrix (u) * ComplexMatrix (u).hermitian (), true, false);
-}
-
-static bool
-singular (const ComplexMatrix& a)
-{
-  for (octave_idx_type i = 0; i < a.rows (); i++)
-    if (a(i,i) == 0.0) return true;
-  return false;
-}
-
-octave_idx_type
-ComplexCHOL::downdate (const ComplexColumnVector& u)
-{
-  warn_qrupdate_once ();
-
-  octave_idx_type info = -1;
-
-  octave_idx_type n = chol_mat.rows ();
-
-  if (u.numel () != n)
-    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
-
-  if (singular (chol_mat))
-    info = 2;
-  else
-    {
-      info = init (chol_mat.hermitian () * chol_mat
-                   - ComplexMatrix (u) * ComplexMatrix (u).hermitian (),
-                   true, false);
-      if (info) info = 1;
-    }
-
-  return info;
-}
-
-octave_idx_type
-ComplexCHOL::insert_sym (const ComplexColumnVector& u, octave_idx_type j)
-{
-  warn_qrupdate_once ();
-
-  octave_idx_type info = -1;
-
-  octave_idx_type n = chol_mat.rows ();
-
-  if (u.numel () != n + 1)
-    (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
-  if (j < 0 || j > n)
-    (*current_liboctave_error_handler) ("cholinsert: index out of range");
-
-  if (singular (chol_mat))
-    info = 2;
-  else if (u(j).imag () != 0.0)
-    info = 3;
-  else
-    {
-      ComplexMatrix a = chol_mat.hermitian () * chol_mat;
-      ComplexMatrix a1 (n+1, n+1);
-      for (octave_idx_type k = 0; k < n+1; k++)
-        for (octave_idx_type l = 0; l < n+1; l++)
-          {
-            if (l == j)
-              a1(k, l) = u(k);
-            else if (k == j)
-              a1(k, l) = std::conj (u(l));
-            else
-              a1(k, l) = a(k < j ? k : k-1, l < j ? l : l-1);
-          }
-      info = init (a1, true, false);
-      if (info) info = 1;
-    }
-
-  return info;
-}
-
-void
-ComplexCHOL::delete_sym (octave_idx_type j)
-{
-  warn_qrupdate_once ();
-
-  octave_idx_type n = chol_mat.rows ();
-
-  if (j < 0 || j > n-1)
-    (*current_liboctave_error_handler) ("choldelete: index out of range");
-
-  ComplexMatrix a = chol_mat.hermitian () * chol_mat;
-  a.delete_elements (1, idx_vector (j));
-  a.delete_elements (0, idx_vector (j));
-  init (a, true, false);
-}
-
-void
-ComplexCHOL::shift_sym (octave_idx_type i, octave_idx_type j)
-{
-  warn_qrupdate_once ();
-
-  octave_idx_type n = chol_mat.rows ();
-
-  if (i < 0 || i > n-1 || j < 0 || j > n-1)
-    (*current_liboctave_error_handler) ("cholshift: index out of range");
-
-  ComplexMatrix a = chol_mat.hermitian () * chol_mat;
-  Array<octave_idx_type> p (dim_vector (n, 1));
-  for (octave_idx_type k = 0; k < n; k++) p(k) = k;
-  if (i < j)
-    {
-      for (octave_idx_type k = i; k < j; k++) p(k) = k+1;
-      p(j) = i;
-    }
-  else if (j < i)
-    {
-      p(j) = i;
-      for (octave_idx_type k = j+1; k < i+1; k++) p(k) = k-1;
-    }
-
-  init (a.index (idx_vector (p), idx_vector (p)), true, false);
-}
-
-#endif
-
-ComplexMatrix
-chol2inv (const ComplexMatrix& r)
-{
-  return chol2inv_internal (r);
-}
diff --git a/liboctave/numeric/CmplxCHOL.h b/liboctave/numeric/CmplxCHOL.h
deleted file mode 100644
--- a/liboctave/numeric/CmplxCHOL.h
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
-
-Copyright (C) 1994-2015 John W. Eaton
-Copyright (C) 2008-2009 Jaroslav Hajek
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#if ! defined (octave_CmplxCHOL_h)
-#define octave_CmplxCHOL_h 1
-
-#include "octave-config.h"
-
-#include <iosfwd>
-
-#include "CMatrix.h"
-#include "CColVector.h"
-
-class
-OCTAVE_API
-ComplexCHOL
-{
-public:
-
-  ComplexCHOL (void) : chol_mat (), xrcond (0) { }
-
-  ComplexCHOL (const ComplexMatrix& a, bool upper = true, bool calc_cond = false)
-    : chol_mat (), xrcond (0)
-  {
-    init (a, upper, calc_cond);
-  }
-
-  ComplexCHOL (const ComplexMatrix& a, octave_idx_type& info, bool upper = true,
-               bool calc_cond = false)
-    : chol_mat (), xrcond (0)
-  {
-    info = init (a, upper, calc_cond);
-  }
-
-  ComplexCHOL (const ComplexCHOL& a)
-    : chol_mat (a.chol_mat), xrcond (a.xrcond) { }
-
-  ComplexCHOL& operator = (const ComplexCHOL& a)
-  {
-    if (this != &a)
-      {
-        chol_mat = a.chol_mat;
-        xrcond = a.xrcond;
-      }
-
-    return *this;
-  }
-
-  ComplexMatrix chol_matrix (void) const { return chol_mat; }
-
-  double rcond (void) const { return xrcond; }
-
-  ComplexMatrix inverse (void) const;
-
-  void set (const ComplexMatrix& R);
-
-  void update (const ComplexColumnVector& u);
-
-  octave_idx_type downdate (const ComplexColumnVector& u);
-
-  octave_idx_type insert_sym (const ComplexColumnVector& u, octave_idx_type j);
-
-  void delete_sym (octave_idx_type j);
-
-  void shift_sym (octave_idx_type i, octave_idx_type j);
-
-  friend OCTAVE_API std::ostream& operator << (std::ostream& os,
-                                               const ComplexCHOL& a);
-
-private:
-
-  ComplexMatrix chol_mat;
-
-  double xrcond;
-
-  bool is_upper;
-
-  octave_idx_type init (const ComplexMatrix& a, bool upper, bool calc_cond);
-};
-
-ComplexMatrix OCTAVE_API chol2inv (const ComplexMatrix& r);
-
-#endif
diff --git a/liboctave/numeric/dbleCHOL.cc b/liboctave/numeric/chol.cc
rename from liboctave/numeric/dbleCHOL.cc
rename to liboctave/numeric/chol.cc
--- a/liboctave/numeric/dbleCHOL.cc
+++ b/liboctave/numeric/chol.cc
@@ -22,24 +22,36 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #  include <config.h>
 #endif
 
 #include <vector>
 
-#include "dRowVector.h"
-#include "dbleCHOL.h"
+
+#include "CColVector.h"
+#include "CMatrix.h"
+#include "chol.h"
+#include "dColVector.h"
+#include "dMatrix.h"
 #include "f77-fcn.h"
+#include "fCColVector.h"
+#include "fCMatrix.h"
+#include "fColVector.h"
+#include "fMatrix.h"
 #include "lo-error.h"
 #include "oct-locbuf.h"
 #include "oct-norm.h"
-#ifndef HAVE_QRUPDATE
+
+#if ! defined (HAVE_QRUPDATE)
+#  include "CmplxQR.h"
 #  include "dbleQR.h"
+#  include "fCmplxQR.h"
+#  include "floatQR.h"
 #endif
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dpotrf, DPOTRF) (F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&, double*,
                              const octave_idx_type&, octave_idx_type&
@@ -79,26 +91,517 @@ extern "C"
                              const octave_idx_type&, const octave_idx_type&,
                              double*);
 
   F77_RET_T
   F77_FUNC (dchshx, DCHSHX) (const octave_idx_type&, double*,
                              const octave_idx_type&, const octave_idx_type&,
                              const octave_idx_type&, double*);
 #endif
+
+  F77_RET_T
+  F77_FUNC (spotrf, SPOTRF) (F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, float*,
+                             const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
+
+  F77_RET_T
+  F77_FUNC (spotri, SPOTRI) (F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, float*,
+                             const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
+
+  F77_RET_T
+  F77_FUNC (spocon, SPOCON) (F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, float*,
+                             const octave_idx_type&, const float&,
+                             float&, float*, octave_idx_type*,
+                             octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
+#ifdef HAVE_QRUPDATE
+
+  F77_RET_T
+  F77_FUNC (sch1up, SCH1UP) (const octave_idx_type&, float*,
+                             const octave_idx_type&, float*, float*);
+
+  F77_RET_T
+  F77_FUNC (sch1dn, SCH1DN) (const octave_idx_type&, float*,
+                             const octave_idx_type&, float*, float*,
+                             octave_idx_type&);
+
+  F77_RET_T
+  F77_FUNC (schinx, SCHINX) (const octave_idx_type&, float*,
+                             const octave_idx_type&, const octave_idx_type&,
+                             float*, float*, octave_idx_type&);
+
+  F77_RET_T
+  F77_FUNC (schdex, SCHDEX) (const octave_idx_type&, float*,
+                             const octave_idx_type&, const octave_idx_type&,
+                             float*);
+
+  F77_RET_T
+  F77_FUNC (schshx, SCHSHX) (const octave_idx_type&, float*,
+                             const octave_idx_type&, const octave_idx_type&,
+                             const octave_idx_type&, float*);
+#endif
+
+  F77_RET_T
+  F77_FUNC (zpotrf, ZPOTRF) (F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, Complex*,
+                             const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
+  F77_RET_T
+  F77_FUNC (zpotri, ZPOTRI) (F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, Complex*,
+                             const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
+
+  F77_RET_T
+  F77_FUNC (zpocon, ZPOCON) (F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, Complex*,
+                             const octave_idx_type&, const double&,
+                             double&, Complex*, double*, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
+#ifdef HAVE_QRUPDATE
+
+  F77_RET_T
+  F77_FUNC (zch1up, ZCH1UP) (const octave_idx_type&, Complex*,
+                             const octave_idx_type&, Complex*, double*);
+
+  F77_RET_T
+  F77_FUNC (zch1dn, ZCH1DN) (const octave_idx_type&, Complex*,
+                             const octave_idx_type&, Complex*, double*,
+                             octave_idx_type&);
+
+  F77_RET_T
+  F77_FUNC (zchinx, ZCHINX) (const octave_idx_type&, Complex*,
+                             const octave_idx_type&, const octave_idx_type&,
+                             Complex*, double*, octave_idx_type&);
+
+  F77_RET_T
+  F77_FUNC (zchdex, ZCHDEX) (const octave_idx_type&, Complex*,
+                             const octave_idx_type&, const octave_idx_type&,
+                             double*);
+
+  F77_RET_T
+  F77_FUNC (zchshx, ZCHSHX) (const octave_idx_type&, Complex*,
+                             const octave_idx_type&, const octave_idx_type&,
+                             const octave_idx_type&, Complex*, double*);
+#endif
+
+  F77_RET_T
+  F77_FUNC (cpotrf, CPOTRF) (F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, FloatComplex*,
+                             const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
+  F77_RET_T
+  F77_FUNC (cpotri, CPOTRI) (F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, FloatComplex*,
+                             const octave_idx_type&, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
+
+  F77_RET_T
+  F77_FUNC (cpocon, CPOCON) (F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, FloatComplex*,
+                             const octave_idx_type&, const float&,
+                             float&, FloatComplex*, float*, octave_idx_type&
+                             F77_CHAR_ARG_LEN_DECL);
+#ifdef HAVE_QRUPDATE
+
+  F77_RET_T
+  F77_FUNC (cch1up, CCH1UP) (const octave_idx_type&, FloatComplex*,
+                             const octave_idx_type&, FloatComplex*, float*);
+
+  F77_RET_T
+  F77_FUNC (cch1dn, CCH1DN) (const octave_idx_type&, FloatComplex*,
+                             const octave_idx_type&, FloatComplex*,
+                             float*, octave_idx_type&);
+
+  F77_RET_T
+  F77_FUNC (cchinx, CCHINX) (const octave_idx_type&, FloatComplex*,
+                             const octave_idx_type&, const octave_idx_type&,
+                             FloatComplex*, float*, octave_idx_type&);
+
+  F77_RET_T
+  F77_FUNC (cchdex, CCHDEX) (const octave_idx_type&, FloatComplex*,
+                             const octave_idx_type&, const octave_idx_type&,
+                             float*);
+
+  F77_RET_T
+  F77_FUNC (cchshx, CCHSHX) (const octave_idx_type&, FloatComplex*,
+                             const octave_idx_type&, const octave_idx_type&,
+                             const octave_idx_type&, FloatComplex*, float*);
+#endif
+}
+
+static Matrix
+chol2inv_internal (const Matrix& r, bool is_upper = true)
+{
+  Matrix retval;
+
+  octave_idx_type r_nr = r.rows ();
+  octave_idx_type r_nc = r.cols ();
+
+  if (r_nr != r_nc)
+    (*current_liboctave_error_handler) ("chol2inv requires square matrix");
+
+  octave_idx_type n = r_nc;
+  octave_idx_type info = 0;
+
+  Matrix tmp = r;
+  double *v = tmp.fortran_vec ();
+
+  if (info == 0)
+    {
+      if (is_upper)
+        F77_XFCN (dpotri, DPOTRI, (F77_CONST_CHAR_ARG2 ("U", 1), n,
+                                   v, n, info
+                                   F77_CHAR_ARG_LEN (1)));
+      else
+        F77_XFCN (dpotri, DPOTRI, (F77_CONST_CHAR_ARG2 ("L", 1), n,
+                                   v, n, info
+                                   F77_CHAR_ARG_LEN (1)));
+
+      // If someone thinks of a more graceful way of doing this (or
+      // faster for that matter :-)), please let me know!
+
+      if (n > 1)
+        {
+          if (is_upper)
+            for (octave_idx_type j = 0; j < r_nc; j++)
+              for (octave_idx_type i = j+1; i < r_nr; i++)
+                tmp.xelem (i, j) = tmp.xelem (j, i);
+          else
+            for (octave_idx_type j = 0; j < r_nc; j++)
+              for (octave_idx_type i = j+1; i < r_nr; i++)
+                tmp.xelem (j, i) = tmp.xelem (i, j);
+        }
+
+      retval = tmp;
+    }
+
+  return retval;
+}
+
+static FloatMatrix
+chol2inv_internal (const FloatMatrix& r, bool is_upper = true)
+{
+  FloatMatrix retval;
+
+  octave_idx_type r_nr = r.rows ();
+  octave_idx_type r_nc = r.cols ();
+
+  if (r_nr != r_nc)
+    (*current_liboctave_error_handler) ("chol2inv requires square matrix");
+
+  octave_idx_type n = r_nc;
+  octave_idx_type info = 0;
+
+  FloatMatrix tmp = r;
+  float *v = tmp.fortran_vec ();
+
+  if (info == 0)
+    {
+      if (is_upper)
+        F77_XFCN (spotri, SPOTRI, (F77_CONST_CHAR_ARG2 ("U", 1), n,
+                                   v, n, info
+                                   F77_CHAR_ARG_LEN (1)));
+      else
+        F77_XFCN (spotri, SPOTRI, (F77_CONST_CHAR_ARG2 ("L", 1), n,
+                                   v, n, info
+                                   F77_CHAR_ARG_LEN (1)));
+
+      // If someone thinks of a more graceful way of doing this (or
+      // faster for that matter :-)), please let me know!
+
+      if (n > 1)
+        {
+          if (is_upper)
+            for (octave_idx_type j = 0; j < r_nc; j++)
+              for (octave_idx_type i = j+1; i < r_nr; i++)
+                tmp.xelem (i, j) = tmp.xelem (j, i);
+          else
+            for (octave_idx_type j = 0; j < r_nc; j++)
+              for (octave_idx_type i = j+1; i < r_nr; i++)
+                tmp.xelem (j, i) = tmp.xelem (i, j);
+        }
+
+      retval = tmp;
+    }
+
+  return retval;
 }
 
+static ComplexMatrix
+chol2inv_internal (const ComplexMatrix& r, bool is_upper = true)
+{
+  ComplexMatrix retval;
+
+  octave_idx_type r_nr = r.rows ();
+  octave_idx_type r_nc = r.cols ();
+
+  if (r_nr != r_nc)
+    (*current_liboctave_error_handler) ("chol2inv requires square matrix");
+
+  octave_idx_type n = r_nc;
+  octave_idx_type info;
+
+  ComplexMatrix tmp = r;
+
+  if (is_upper)
+    F77_XFCN (zpotri, ZPOTRI, (F77_CONST_CHAR_ARG2 ("U", 1), n,
+                               tmp.fortran_vec (), n, info
+                               F77_CHAR_ARG_LEN (1)));
+  else
+    F77_XFCN (zpotri, ZPOTRI, (F77_CONST_CHAR_ARG2 ("L", 1), n,
+                               tmp.fortran_vec (), n, info
+                               F77_CHAR_ARG_LEN (1)));
+
+  // If someone thinks of a more graceful way of doing this (or
+  // faster for that matter :-)), please let me know!
+
+  if (n > 1)
+    {
+      if (is_upper)
+        for (octave_idx_type j = 0; j < r_nc; j++)
+          for (octave_idx_type i = j+1; i < r_nr; i++)
+            tmp.xelem (i, j) = tmp.xelem (j, i);
+      else
+        for (octave_idx_type j = 0; j < r_nc; j++)
+          for (octave_idx_type i = j+1; i < r_nr; i++)
+            tmp.xelem (j, i) = tmp.xelem (i, j);
+    }
+
+  retval = tmp;
+
+  return retval;
+}
+
+static FloatComplexMatrix
+chol2inv_internal (const FloatComplexMatrix& r, bool is_upper = true)
+{
+  FloatComplexMatrix retval;
+
+  octave_idx_type r_nr = r.rows ();
+  octave_idx_type r_nc = r.cols ();
+
+  if (r_nr != r_nc)
+    (*current_liboctave_error_handler) ("chol2inv requires square matrix");
+
+  octave_idx_type n = r_nc;
+  octave_idx_type info;
+
+  FloatComplexMatrix tmp = r;
+
+  if (is_upper)
+    F77_XFCN (cpotri, CPOTRI, (F77_CONST_CHAR_ARG2 ("U", 1), n,
+                               tmp.fortran_vec (), n, info
+                               F77_CHAR_ARG_LEN (1)));
+  else
+    F77_XFCN (cpotri, CPOTRI, (F77_CONST_CHAR_ARG2 ("L", 1), n,
+                               tmp.fortran_vec (), n, info
+                               F77_CHAR_ARG_LEN (1)));
+
+  // If someone thinks of a more graceful way of doing this (or
+  // faster for that matter :-)), please let me know!
+
+  if (n > 1)
+    {
+      if (is_upper)
+        for (octave_idx_type j = 0; j < r_nc; j++)
+          for (octave_idx_type i = j+1; i < r_nr; i++)
+            tmp.xelem (i, j) = tmp.xelem (j, i);
+      else
+        for (octave_idx_type j = 0; j < r_nc; j++)
+          for (octave_idx_type i = j+1; i < r_nr; i++)
+            tmp.xelem (j, i) = tmp.xelem (i, j);
+    }
+
+  retval = tmp;
+
+  return retval;
+}
+
+template <typename T>
+T
+chol2inv (const T& r)
+{
+  return chol2inv_internal (r);
+}
+
+// Compute the inverse of a matrix using the Cholesky factorization.
+template <typename T>
+T
+chol<T>::inverse (void) const
+{
+  return chol2inv_internal (chol_mat, is_upper);
+}
+
+template <typename T>
+void
+chol<T>::set (const T& R)
+{
+  if (! R.is_square ())
+    (*current_liboctave_error_handler) ("chol: requires square matrix");
+
+  chol_mat = R;
+}
+
+#if ! defined (HAVE_QRUPDATE)
+
+template <typename T>
+void
+chol<T>::update (const T::VT& u)
+{
+  warn_qrupdate_once ();
+
+  octave_idx_type n = chol_mat.rows ();
+
+  if (u.numel () != n)
+    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
+
+  init (chol_mat.hermitian () * chol_mat + T (u) * T (u).hermitian (),
+        true, false);
+}
+
+template <typename T>
+static bool
+singular (const T& a)
+{
+  static typename T::element_type zero ();
+  for (octave_idx_type i = 0; i < a.rows (); i++)
+    if (a(i,i) == zero) return true;
+  return false;
+}
+
+template <typename T>
 octave_idx_type
-CHOL::init (const Matrix& a, bool upper, bool calc_cond)
+chol<T>::downdate (const T::VT& u)
+{
+  warn_qrupdate_once ();
+
+  octave_idx_type info = -1;
+
+  octave_idx_type n = chol_mat.rows ();
+
+  if (u.numel () != n)
+    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
+
+  if (singular (chol_mat))
+    info = 2;
+  else
+    {
+      info = init (chol_mat.hermitian () * chol_mat
+                   - T (u) * T (u).hermitian (), true, false);
+      if (info) info = 1;
+    }
+
+  return info;
+}
+
+template <typename T>
+octave_idx_type
+chol<T>::insert_sym (const T::VT& u, octave_idx_type j)
+{
+  static typename T::element_type zero ();
+
+  warn_qrupdate_once ();
+
+  octave_idx_type info = -1;
+
+  octave_idx_type n = chol_mat.rows ();
+
+  if (u.numel () != n + 1)
+    (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
+  if (j < 0 || j > n)
+    (*current_liboctave_error_handler) ("cholinsert: index out of range");
+
+  if (singular (chol_mat))
+    info = 2;
+  else if (ximag (u(j)) != zero)
+    info = 3;
+  else
+    {
+      T a = chol_mat.hermitian () * chol_mat;
+      T a1 (n+1, n+1);
+      for (octave_idx_type k = 0; k < n+1; k++)
+        for (octave_idx_type l = 0; l < n+1; l++)
+          {
+            if (l == j)
+              a1(k, l) = u(k);
+            else if (k == j)
+              a1(k, l) = xconj (u(l));
+            else
+              a1(k, l) = a(k < j ? k : k-1, l < j ? l : l-1);
+          }
+      info = init (a1, true, false);
+      if (info) info = 1;
+    }
+
+  return info;
+}
+
+template <typename T>
+void
+chol<T>::delete_sym (octave_idx_type j)
+{
+  warn_qrupdate_once ();
+
+  octave_idx_type n = chol_mat.rows ();
+
+  if (j < 0 || j > n-1)
+    (*current_liboctave_error_handler) ("choldelete: index out of range");
+
+  T a = chol_mat.hermitian () * chol_mat;
+  a.delete_elements (1, idx_vector (j));
+  a.delete_elements (0, idx_vector (j));
+  init (a, true, false);
+}
+
+template <typename T>
+void
+chol<T>::shift_sym (octave_idx_type i, octave_idx_type j)
+{
+  warn_qrupdate_once ();
+
+  octave_idx_type n = chol_mat.rows ();
+
+  if (i < 0 || i > n-1 || j < 0 || j > n-1)
+    (*current_liboctave_error_handler) ("cholshift: index out of range");
+
+  T a = chol_mat.hermitian () * chol_mat;
+  Array<octave_idx_type> p (dim_vector (n, 1));
+  for (octave_idx_type k = 0; k < n; k++) p(k) = k;
+  if (i < j)
+    {
+      for (octave_idx_type k = i; k < j; k++) p(k) = k+1;
+      p(j) = i;
+    }
+  else if (j < i)
+    {
+      p(j) = i;
+      for (octave_idx_type k = j+1; k < i+1; k++) p(k) = k-1;
+    }
+
+  init (a.index (idx_vector (p), idx_vector (p)), true, false);
+}
+
+#endif
+
+// Specializations.
+
+template <>
+octave_idx_type
+chol<Matrix>::init (const Matrix& a, bool upper, bool calc_cond)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
-    (*current_liboctave_error_handler) ("CHOL requires square matrix");
+    (*current_liboctave_error_handler) ("chol: requires square matrix");
 
   octave_idx_type n = a_nc;
   octave_idx_type info;
 
   is_upper = upper;
 
   chol_mat.clear (n, n);
   if (is_upper)
@@ -154,101 +657,38 @@ CHOL::init (const Matrix& a, bool upper,
 
       if (dpocon_info != 0)
         info = -1;
     }
 
   return info;
 }
 
-static Matrix
-chol2inv_internal (const Matrix& r, bool is_upper = true)
-{
-  Matrix retval;
-
-  octave_idx_type r_nr = r.rows ();
-  octave_idx_type r_nc = r.cols ();
-
-  if (r_nr != r_nc)
-    (*current_liboctave_error_handler) ("chol2inv requires square matrix");
-
-  octave_idx_type n = r_nc;
-  octave_idx_type info = 0;
-
-  Matrix tmp = r;
-  double *v = tmp.fortran_vec ();
-
-  if (info == 0)
-    {
-      if (is_upper)
-        F77_XFCN (dpotri, DPOTRI, (F77_CONST_CHAR_ARG2 ("U", 1), n,
-                                   v, n, info
-                                   F77_CHAR_ARG_LEN (1)));
-      else
-        F77_XFCN (dpotri, DPOTRI, (F77_CONST_CHAR_ARG2 ("L", 1), n,
-                                   v, n, info
-                                   F77_CHAR_ARG_LEN (1)));
-
-      // If someone thinks of a more graceful way of doing this (or
-      // faster for that matter :-)), please let me know!
+#if defined (HAVE_QRUPDATE)
 
-      if (n > 1)
-        {
-          if (is_upper)
-            for (octave_idx_type j = 0; j < r_nc; j++)
-              for (octave_idx_type i = j+1; i < r_nr; i++)
-                tmp.xelem (i, j) = tmp.xelem (j, i);
-          else
-            for (octave_idx_type j = 0; j < r_nc; j++)
-              for (octave_idx_type i = j+1; i < r_nr; i++)
-                tmp.xelem (j, i) = tmp.xelem (i, j);
-        }
-
-      retval = tmp;
-    }
-
-  return retval;
-}
-
-// Compute the inverse of a matrix using the Cholesky factorization.
-Matrix
-CHOL::inverse (void) const
-{
-  return chol2inv_internal (chol_mat, is_upper);
-}
-
+template <>
 void
-CHOL::set (const Matrix& R)
-{
-  if (! R.is_square ())
-    (*current_liboctave_error_handler) ("CHOL requires square matrix");
-
-  chol_mat = R;
-}
-
-#ifdef HAVE_QRUPDATE
-
-void
-CHOL::update (const ColumnVector& u)
+chol<Matrix>::update (const ColumnVector& u)
 {
   octave_idx_type n = chol_mat.rows ();
 
   if (u.numel () != n)
     (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
   ColumnVector utmp = u;
 
   OCTAVE_LOCAL_BUFFER (double, w, n);
 
   F77_XFCN (dch1up, DCH1UP, (n, chol_mat.fortran_vec (), chol_mat.rows (),
                              utmp.fortran_vec (), w));
 }
 
+template <>
 octave_idx_type
-CHOL::downdate (const ColumnVector& u)
+chol<Matrix>::downdate (const ColumnVector& u)
 {
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
   if (u.numel () != n)
     (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
@@ -257,18 +697,19 @@ CHOL::downdate (const ColumnVector& u)
   OCTAVE_LOCAL_BUFFER (double, w, n);
 
   F77_XFCN (dch1dn, DCH1DN, (n, chol_mat.fortran_vec (), chol_mat.rows (),
                              utmp.fortran_vec (), w, info));
 
   return info;
 }
 
+template <>
 octave_idx_type
-CHOL::insert_sym (const ColumnVector& u, octave_idx_type j)
+chol<Matrix>::insert_sym (const ColumnVector& u, octave_idx_type j)
 {
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
   if (u.numel () != n + 1)
     (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
   if (j < 0 || j > n)
@@ -281,173 +722,577 @@ CHOL::insert_sym (const ColumnVector& u,
   chol_mat.resize (n+1, n+1);
 
   F77_XFCN (dchinx, DCHINX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
                              j + 1, utmp.fortran_vec (), w, info));
 
   return info;
 }
 
+template <>
 void
-CHOL::delete_sym (octave_idx_type j)
+chol<Matrix>::delete_sym (octave_idx_type j)
 {
   octave_idx_type n = chol_mat.rows ();
 
   if (j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("choldelete: index out of range");
 
   OCTAVE_LOCAL_BUFFER (double, w, n);
 
   F77_XFCN (dchdex, DCHDEX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
                              j + 1, w));
 
   chol_mat.resize (n-1, n-1);
 }
 
+template <>
 void
-CHOL::shift_sym (octave_idx_type i, octave_idx_type j)
+chol<Matrix>::shift_sym (octave_idx_type i, octave_idx_type j)
 {
   octave_idx_type n = chol_mat.rows ();
 
   if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("cholshift: index out of range");
 
   OCTAVE_LOCAL_BUFFER (double, w, 2*n);
 
   F77_XFCN (dchshx, DCHSHX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
                              i + 1, j + 1, w));
 }
 
-#else
+#endif
+
+template <>
+octave_idx_type
+chol<FloatMatrix>::init (const FloatMatrix& a, bool upper, bool calc_cond)
+{
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type a_nc = a.cols ();
+
+  if (a_nr != a_nc)
+    (*current_liboctave_error_handler) ("chol: requires square matrix");
+
+  octave_idx_type n = a_nc;
+  octave_idx_type info;
+
+  is_upper = upper;
+
+  chol_mat.clear (n, n);
+  if (is_upper)
+    for (octave_idx_type j = 0; j < n; j++)
+      {
+        for (octave_idx_type i = 0; i <= j; i++)
+          chol_mat.xelem (i, j) = a(i, j);
+        for (octave_idx_type i = j+1; i < n; i++)
+          chol_mat.xelem (i, j) = 0.0f;
+      }
+  else
+    for (octave_idx_type j = 0; j < n; j++)
+      {
+        for (octave_idx_type i = 0; i < j; i++)
+          chol_mat.xelem (i, j) = 0.0f;
+        for (octave_idx_type i = j; i < n; i++)
+          chol_mat.xelem (i, j) = a(i, j);
+      }
+  float *h = chol_mat.fortran_vec ();
 
+  // Calculate the norm of the matrix, for later use.
+  float anorm = 0;
+  if (calc_cond)
+    anorm = xnorm (a, 1);
+
+  if (is_upper)
+    F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 ("U", 1), n, h, n, info
+                               F77_CHAR_ARG_LEN (1)));
+  else
+    F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1), n, h, n, info
+                               F77_CHAR_ARG_LEN (1)));
+
+  xrcond = 0.0;
+  if (info > 0)
+    chol_mat.resize (info - 1, info - 1);
+  else if (calc_cond)
+    {
+      octave_idx_type spocon_info = 0;
+
+      // Now calculate the condition number for non-singular matrix.
+      Array<float> z (dim_vector (3*n, 1));
+      float *pz = z.fortran_vec ();
+      Array<octave_idx_type> iz (dim_vector (n, 1));
+      octave_idx_type *piz = iz.fortran_vec ();
+      if (is_upper)
+        F77_XFCN (spocon, SPOCON, (F77_CONST_CHAR_ARG2 ("U", 1), n, h,
+                                   n, anorm, xrcond, pz, piz, spocon_info
+                                   F77_CHAR_ARG_LEN (1)));
+      else
+        F77_XFCN (spocon, SPOCON, (F77_CONST_CHAR_ARG2 ("L", 1), n, h,
+                                   n, anorm, xrcond, pz, piz, spocon_info
+                                   F77_CHAR_ARG_LEN (1)));
+
+      if (spocon_info != 0)
+        info = -1;
+    }
+
+  return info;
+}
+
+#ifdef HAVE_QRUPDATE
+
+template <>
 void
-CHOL::update (const ColumnVector& u)
+chol<FloatMatrix>::update (const FloatColumnVector& u)
 {
-  warn_qrupdate_once ();
-
   octave_idx_type n = chol_mat.rows ();
 
   if (u.numel () != n)
     (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
-  init (chol_mat.transpose () * chol_mat
-        + Matrix (u) * Matrix (u).transpose (), true, false);
+  FloatColumnVector utmp = u;
+
+  OCTAVE_LOCAL_BUFFER (float, w, n);
+
+  F77_XFCN (sch1up, SCH1UP, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+                             utmp.fortran_vec (), w));
 }
 
-static bool
-singular (const Matrix& a)
+template <>
+octave_idx_type
+chol<FloatMatrix>::downdate (const FloatColumnVector& u)
 {
-  for (octave_idx_type i = 0; i < a.rows (); i++)
-    if (a(i,i) == 0.0) return true;
-  return false;
-}
-
-octave_idx_type
-CHOL::downdate (const ColumnVector& u)
-{
-  warn_qrupdate_once ();
-
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
   if (u.numel () != n)
     (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
-  if (singular (chol_mat))
-    info = 2;
-  else
-    {
-      info = init (chol_mat.transpose () * chol_mat
-                   - Matrix (u) * Matrix (u).transpose (), true, false);
-      if (info) info = 1;
-    }
+  FloatColumnVector utmp = u;
+
+  OCTAVE_LOCAL_BUFFER (float, w, n);
+
+  F77_XFCN (sch1dn, SCH1DN, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+                             utmp.fortran_vec (), w, info));
 
   return info;
 }
 
+template <>
 octave_idx_type
-CHOL::insert_sym (const ColumnVector& u, octave_idx_type j)
+chol<FloatMatrix>::insert_sym (const FloatColumnVector& u, octave_idx_type j)
 {
-  warn_qrupdate_once ();
-
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
   if (u.numel () != n + 1)
     (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
   if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("cholinsert: index out of range");
 
-  if (singular (chol_mat))
-    info = 2;
+  FloatColumnVector utmp = u;
+
+  OCTAVE_LOCAL_BUFFER (float, w, n);
+
+  chol_mat.resize (n+1, n+1);
+
+  F77_XFCN (schinx, SCHINX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+                             j + 1, utmp.fortran_vec (), w, info));
+
+  return info;
+}
+
+template <>
+void
+chol<FloatMatrix>::delete_sym (octave_idx_type j)
+{
+  octave_idx_type n = chol_mat.rows ();
+
+  if (j < 0 || j > n-1)
+    (*current_liboctave_error_handler) ("choldelete: index out of range");
+
+  OCTAVE_LOCAL_BUFFER (float, w, n);
+
+  F77_XFCN (schdex, SCHDEX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+                             j + 1, w));
+
+  chol_mat.resize (n-1, n-1);
+}
+
+template <>
+void
+chol<FloatMatrix>::shift_sym (octave_idx_type i, octave_idx_type j)
+{
+  octave_idx_type n = chol_mat.rows ();
+
+  if (i < 0 || i > n-1 || j < 0 || j > n-1)
+    (*current_liboctave_error_handler) ("cholshift: index out of range");
+
+  OCTAVE_LOCAL_BUFFER (float, w, 2*n);
+
+  F77_XFCN (schshx, SCHSHX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+                             i + 1, j + 1, w));
+}
+
+#endif
+
+template <>
+octave_idx_type
+chol<ComplexMatrix>::init (const ComplexMatrix& a, bool upper, bool calc_cond)
+{
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type a_nc = a.cols ();
+
+  if (a_nr != a_nc)
+    (*current_liboctave_error_handler) ("chol: requires square matrix");
+
+  octave_idx_type n = a_nc;
+  octave_idx_type info;
+
+  is_upper = upper;
+
+  chol_mat.clear (n, n);
+  if (is_upper)
+    for (octave_idx_type j = 0; j < n; j++)
+      {
+        for (octave_idx_type i = 0; i <= j; i++)
+          chol_mat.xelem (i, j) = a(i, j);
+        for (octave_idx_type i = j+1; i < n; i++)
+          chol_mat.xelem (i, j) = 0.0;
+      }
   else
+    for (octave_idx_type j = 0; j < n; j++)
+      {
+        for (octave_idx_type i = 0; i < j; i++)
+          chol_mat.xelem (i, j) = 0.0;
+        for (octave_idx_type i = j; i < n; i++)
+          chol_mat.xelem (i, j) = a(i, j);
+      }
+  Complex *h = chol_mat.fortran_vec ();
+
+  // Calculate the norm of the matrix, for later use.
+  double anorm = 0;
+  if (calc_cond)
+    anorm = xnorm (a, 1);
+
+  if (is_upper)
+    F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 ("U", 1), n, h, n, info
+                               F77_CHAR_ARG_LEN (1)));
+  else
+    F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1), n, h, n, info
+                               F77_CHAR_ARG_LEN (1)));
+
+  xrcond = 0.0;
+  if (info > 0)
+    chol_mat.resize (info - 1, info - 1);
+  else if (calc_cond)
     {
-      Matrix a = chol_mat.transpose () * chol_mat;
-      Matrix a1 (n+1, n+1);
-      for (octave_idx_type k = 0; k < n+1; k++)
-        for (octave_idx_type l = 0; l < n+1; l++)
-          {
-            if (l == j)
-              a1(k, l) = u(k);
-            else if (k == j)
-              a1(k, l) = u(l);
-            else
-              a1(k, l) = a(k < j ? k : k-1, l < j ? l : l-1);
-          }
-      info = init (a1, true, false);
-      if (info) info = 1;
+      octave_idx_type zpocon_info = 0;
+
+      // Now calculate the condition number for non-singular matrix.
+      Array<Complex> z (dim_vector (2*n, 1));
+      Complex *pz = z.fortran_vec ();
+      Array<double> rz (dim_vector (n, 1));
+      double *prz = rz.fortran_vec ();
+      F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 ("U", 1), n, h,
+                                 n, anorm, xrcond, pz, prz, zpocon_info
+                                 F77_CHAR_ARG_LEN (1)));
+
+      if (zpocon_info != 0)
+        info = -1;
     }
 
   return info;
 }
 
+#ifdef HAVE_QRUPDATE
+
+template <>
 void
-CHOL::delete_sym (octave_idx_type j)
+chol<ComplexMatrix>::update (const ComplexColumnVector& u)
+{
+  octave_idx_type n = chol_mat.rows ();
+
+  if (u.numel () != n)
+    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
+
+  ComplexColumnVector utmp = u;
+
+  OCTAVE_LOCAL_BUFFER (double, rw, n);
+
+  F77_XFCN (zch1up, ZCH1UP, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+                             utmp.fortran_vec (), rw));
+}
+
+template <>
+octave_idx_type
+chol<ComplexMatrix>::downdate (const ComplexColumnVector& u)
 {
-  warn_qrupdate_once ();
+  octave_idx_type info = -1;
+
+  octave_idx_type n = chol_mat.rows ();
+
+  if (u.numel () != n)
+    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
+
+  ComplexColumnVector utmp = u;
+
+  OCTAVE_LOCAL_BUFFER (double, rw, n);
+
+  F77_XFCN (zch1dn, ZCH1DN, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+                             utmp.fortran_vec (), rw, info));
+
+  return info;
+}
+
+template <>
+octave_idx_type
+chol<ComplexMatrix>::insert_sym (const ComplexColumnVector& u,
+                                 octave_idx_type j)
+{
+  octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
+  if (u.numel () != n + 1)
+    (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
+  if (j < 0 || j > n)
+    (*current_liboctave_error_handler) ("cholinsert: index out of range");
+
+  ComplexColumnVector utmp = u;
+
+  OCTAVE_LOCAL_BUFFER (double, rw, n);
+
+  chol_mat.resize (n+1, n+1);
+
+  F77_XFCN (zchinx, ZCHINX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+                             j + 1, utmp.fortran_vec (), rw, info));
+
+  return info;
+}
+
+template <>
+void
+chol<ComplexMatrix>::delete_sym (octave_idx_type j)
+{
+  octave_idx_type n = chol_mat.rows ();
+
   if (j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("choldelete: index out of range");
 
-  Matrix a = chol_mat.transpose () * chol_mat;
-  a.delete_elements (1, idx_vector (j));
-  a.delete_elements (0, idx_vector (j));
-  init (a, true, false);
+  OCTAVE_LOCAL_BUFFER (double, rw, n);
+
+  F77_XFCN (zchdex, ZCHDEX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+                             j + 1, rw));
+
+  chol_mat.resize (n-1, n-1);
 }
 
+template <>
 void
-CHOL::shift_sym (octave_idx_type i, octave_idx_type j)
+chol<ComplexMatrix>::shift_sym (octave_idx_type i, octave_idx_type j)
 {
-  warn_qrupdate_once ();
-
   octave_idx_type n = chol_mat.rows ();
 
   if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("cholshift: index out of range");
 
-  Matrix a = chol_mat.transpose () * chol_mat;
-  Array<octave_idx_type> p (dim_vector (n, 1));
-  for (octave_idx_type k = 0; k < n; k++) p(k) = k;
-  if (i < j)
-    {
-      for (octave_idx_type k = i; k < j; k++) p(k) = k+1;
-      p(j) = i;
-    }
-  else if (j < i)
-    {
-      p(j) = i;
-      for (octave_idx_type k = j+1; k < i+1; k++) p(k) = k-1;
-    }
+  OCTAVE_LOCAL_BUFFER (Complex, w, n);
+  OCTAVE_LOCAL_BUFFER (double, rw, n);
 
-  init (a.index (idx_vector (p), idx_vector (p)), true, false);
+  F77_XFCN (zchshx, ZCHSHX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+                             i + 1, j + 1, w, rw));
 }
 
 #endif
 
-Matrix
-chol2inv (const Matrix& r)
+template <>
+octave_idx_type
+chol<FloatComplexMatrix>::init (const FloatComplexMatrix& a, bool upper,
+                                bool calc_cond)
+{
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type a_nc = a.cols ();
+
+  if (a_nr != a_nc)
+    (*current_liboctave_error_handler) ("chol: requires square matrix");
+
+  octave_idx_type n = a_nc;
+  octave_idx_type info;
+
+  is_upper = upper;
+
+  chol_mat.clear (n, n);
+  if (is_upper)
+    for (octave_idx_type j = 0; j < n; j++)
+      {
+        for (octave_idx_type i = 0; i <= j; i++)
+          chol_mat.xelem (i, j) = a(i, j);
+        for (octave_idx_type i = j+1; i < n; i++)
+          chol_mat.xelem (i, j) = 0.0f;
+      }
+  else
+    for (octave_idx_type j = 0; j < n; j++)
+      {
+        for (octave_idx_type i = 0; i < j; i++)
+          chol_mat.xelem (i, j) = 0.0f;
+        for (octave_idx_type i = j; i < n; i++)
+          chol_mat.xelem (i, j) = a(i, j);
+      }
+  FloatComplex *h = chol_mat.fortran_vec ();
+
+  // Calculate the norm of the matrix, for later use.
+  float anorm = 0;
+  if (calc_cond)
+    anorm = xnorm (a, 1);
+
+  if (is_upper)
+    F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 ("U", 1), n, h, n, info
+                               F77_CHAR_ARG_LEN (1)));
+  else
+    F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1), n, h, n, info
+                               F77_CHAR_ARG_LEN (1)));
+
+  xrcond = 0.0;
+  if (info > 0)
+    chol_mat.resize (info - 1, info - 1);
+  else if (calc_cond)
+    {
+      octave_idx_type cpocon_info = 0;
+
+      // Now calculate the condition number for non-singular matrix.
+      Array<FloatComplex> z (dim_vector (2*n, 1));
+      FloatComplex *pz = z.fortran_vec ();
+      Array<float> rz (dim_vector (n, 1));
+      float *prz = rz.fortran_vec ();
+      F77_XFCN (cpocon, CPOCON, (F77_CONST_CHAR_ARG2 ("U", 1), n, h,
+                                 n, anorm, xrcond, pz, prz, cpocon_info
+                                 F77_CHAR_ARG_LEN (1)));
+
+      if (cpocon_info != 0)
+        info = -1;
+    }
+
+  return info;
+}
+
+#ifdef HAVE_QRUPDATE
+
+template <>
+void
+chol<FloatComplexMatrix>::update (const FloatComplexColumnVector& u)
+{
+  octave_idx_type n = chol_mat.rows ();
+
+  if (u.numel () != n)
+    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
+
+  FloatComplexColumnVector utmp = u;
+
+  OCTAVE_LOCAL_BUFFER (float, rw, n);
+
+  F77_XFCN (cch1up, CCH1UP, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+                             utmp.fortran_vec (), rw));
+}
+
+template <>
+octave_idx_type
+chol<FloatComplexMatrix>::downdate (const FloatComplexColumnVector& u)
 {
-  return chol2inv_internal (r);
+  octave_idx_type info = -1;
+
+  octave_idx_type n = chol_mat.rows ();
+
+  if (u.numel () != n)
+    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
+
+  FloatComplexColumnVector utmp = u;
+
+  OCTAVE_LOCAL_BUFFER (float, rw, n);
+
+  F77_XFCN (cch1dn, CCH1DN, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+                             utmp.fortran_vec (), rw, info));
+
+  return info;
+}
+
+template <>
+octave_idx_type
+chol<FloatComplexMatrix>::insert_sym (const FloatComplexColumnVector& u,
+                                      octave_idx_type j)
+{
+  octave_idx_type info = -1;
+
+  octave_idx_type n = chol_mat.rows ();
+
+  if (u.numel () != n + 1)
+    (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
+  if (j < 0 || j > n)
+    (*current_liboctave_error_handler) ("cholinsert: index out of range");
+
+  FloatComplexColumnVector utmp = u;
+
+  OCTAVE_LOCAL_BUFFER (float, rw, n);
+
+  chol_mat.resize (n+1, n+1);
+
+  F77_XFCN (cchinx, CCHINX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+                             j + 1, utmp.fortran_vec (), rw, info));
+
+  return info;
 }
+
+template <>
+void
+chol<FloatComplexMatrix>::delete_sym (octave_idx_type j)
+{
+  octave_idx_type n = chol_mat.rows ();
+
+  if (j < 0 || j > n-1)
+    (*current_liboctave_error_handler) ("choldelete: index out of range");
+
+  OCTAVE_LOCAL_BUFFER (float, rw, n);
+
+  F77_XFCN (cchdex, CCHDEX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+                             j + 1, rw));
+
+  chol_mat.resize (n-1, n-1);
+}
+
+template <>
+void
+chol<FloatComplexMatrix>::shift_sym (octave_idx_type i, octave_idx_type j)
+{
+  octave_idx_type n = chol_mat.rows ();
+
+  if (i < 0 || i > n-1 || j < 0 || j > n-1)
+    (*current_liboctave_error_handler) ("cholshift: index out of range");
+
+  OCTAVE_LOCAL_BUFFER (FloatComplex, w, n);
+  OCTAVE_LOCAL_BUFFER (float, rw, n);
+
+  F77_XFCN (cchshx, CCHSHX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+                             i + 1, j + 1, w, rw));
+}
+
+#endif
+
+// Instantiations we need.
+
+template class chol<Matrix>;
+
+template class chol<FloatMatrix>;
+
+template class chol<ComplexMatrix>;
+
+template class chol<FloatComplexMatrix>;
+
+template Matrix
+chol2inv<Matrix> (const Matrix& r);
+
+template ComplexMatrix
+chol2inv<ComplexMatrix> (const ComplexMatrix& r);
+
+template FloatMatrix
+chol2inv<FloatMatrix> (const FloatMatrix& r);
+
+template FloatComplexMatrix
+chol2inv<FloatComplexMatrix> (const FloatComplexMatrix& r);
diff --git a/liboctave/numeric/dbleCHOL.h b/liboctave/numeric/chol.h
rename from liboctave/numeric/dbleCHOL.h
rename to liboctave/numeric/chol.h
--- a/liboctave/numeric/dbleCHOL.h
+++ b/liboctave/numeric/chol.h
@@ -16,85 +16,86 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
-#if ! defined (octave_dbleCHOL_h)
-#define octave_dbleCHOL_h 1
+#if ! defined (octave_chol_h)
+#define octave_chol_h 1
 
 #include "octave-config.h"
 
-#include <iosfwd>
-
-#include "dMatrix.h"
-#include "dColVector.h"
-
+template <typename T>
 class
-OCTAVE_API
-CHOL
+chol
 {
 public:
 
-  CHOL (void) : chol_mat (), xrcond (0) { }
+  typedef typename T::column_vector_type VT;
+  typedef typename T::real_elt_type COND_T;
 
-  CHOL (const Matrix& a, bool upper = true, bool calc_cond = false)
+  chol (void) : chol_mat (), xrcond (0) { }
+
+  chol (const T& a, bool upper = true, bool calc_cond = false)
     : chol_mat (), xrcond (0)
   {
     init (a, upper, calc_cond);
   }
 
-  CHOL (const Matrix& a, octave_idx_type& info, bool upper = true,
-        bool calc_cond = false) : chol_mat (), xrcond (0)
+  chol (const T& a, octave_idx_type& info, bool upper = true,
+        bool calc_cond = false)
+    : chol_mat (), xrcond (0)
   {
     info = init (a, upper, calc_cond);
   }
 
-  CHOL (const CHOL& a) : chol_mat (a.chol_mat), xrcond (a.xrcond) { }
+  chol (const chol& a)
+    : chol_mat (a.chol_mat), xrcond (a.xrcond) { }
 
-  CHOL& operator = (const CHOL& a)
+  chol& operator = (const chol& a)
   {
     if (this != &a)
       {
         chol_mat = a.chol_mat;
         xrcond = a.xrcond;
       }
+
     return *this;
   }
 
-  Matrix chol_matrix (void) const { return chol_mat; }
+  T chol_matrix (void) const { return chol_mat; }
 
-  double rcond (void) const { return xrcond; }
+  COND_T rcond (void) const { return xrcond; }
 
   // Compute the inverse of a matrix using the Cholesky factorization.
-  Matrix inverse (void) const;
+  T inverse (void) const;
 
-  void set (const Matrix& R);
+  void set (const T& R);
 
-  void update (const ColumnVector& u);
+  void update (const VT& u);
 
-  octave_idx_type downdate (const ColumnVector& u);
+  octave_idx_type downdate (const VT& u);
 
-  octave_idx_type insert_sym (const ColumnVector& u, octave_idx_type j);
+  octave_idx_type insert_sym (const VT& u, octave_idx_type j);
 
   void delete_sym (octave_idx_type j);
 
   void shift_sym (octave_idx_type i, octave_idx_type j);
 
-  friend OCTAVE_API std::ostream& operator << (std::ostream& os, const CHOL& a);
-
 private:
 
-  Matrix chol_mat;
+  T chol_mat;
 
-  double xrcond;
+  COND_T xrcond;
 
   bool is_upper;
 
-  octave_idx_type init (const Matrix& a, bool upper, bool calc_cond);
+  octave_idx_type init (const T& a, bool upper, bool calc_cond);
 };
 
-Matrix OCTAVE_API chol2inv (const Matrix& r);
+template <typename T>
+T
+chol2inv (const T& r);
 
 #endif
diff --git a/liboctave/numeric/eigs-base.cc b/liboctave/numeric/eigs-base.cc
--- a/liboctave/numeric/eigs-base.cc
+++ b/liboctave/numeric/eigs-base.cc
@@ -25,21 +25,20 @@ along with Octave; see the file COPYING.
 #endif
 
 #include <cfloat>
 #include <cmath>
 #include <vector>
 #include <iostream>
 
 #include "CSparse.h"
-#include "CmplxCHOL.h"
 #include "CmplxLU.h"
 #include "MatrixType.h"
+#include "chol.h"
 #include "dSparse.h"
-#include "dbleCHOL.h"
 #include "dbleLU.h"
 #include "eigs-base.h"
 #include "f77-fcn.h"
 #include "mx-ops.h"
 #include "oct-locbuf.h"
 #include "oct-rand.h"
 #include "quit.h"
 #include "sparse-chol.h"
@@ -300,17 +299,17 @@ vector_product (const ComplexMatrix& m, 
 
   return true;
 }
 
 static bool
 make_cholb (Matrix& b, Matrix& bt, ColumnVector& permB)
 {
   octave_idx_type info;
-  CHOL fact (b, info);
+  chol<Matrix> fact (b, info);
   octave_idx_type n = b.cols ();
 
   if (info != 0)
     return false;
   else
     {
       bt = fact.chol_matrix ();
       b = bt.transpose ();
@@ -337,17 +336,17 @@ make_cholb (SparseMatrix& b, SparseMatri
       return true;
     }
 }
 
 static bool
 make_cholb (ComplexMatrix& b, ComplexMatrix& bt, ColumnVector& permB)
 {
   octave_idx_type info;
-  ComplexCHOL fact (b, info);
+  chol<ComplexMatrix> fact (b, info);
   octave_idx_type n = b.cols ();
 
   if (info != 0)
     return false;
   else
     {
       bt = fact.chol_matrix ();
       b = bt.hermitian ();
diff --git a/liboctave/numeric/fCmplxCHOL.cc b/liboctave/numeric/fCmplxCHOL.cc
deleted file mode 100644
--- a/liboctave/numeric/fCmplxCHOL.cc
+++ /dev/null
@@ -1,452 +0,0 @@
-/*
-
-Copyright (C) 1994-2015 John W. Eaton
-Copyright (C) 2008-2009 Jaroslav Hajek
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-
-#include <vector>
-
-#include "fMatrix.h"
-#include "fRowVector.h"
-#include "fCmplxCHOL.h"
-#include "f77-fcn.h"
-#include "lo-error.h"
-#include "oct-locbuf.h"
-#include "oct-norm.h"
-#ifndef HAVE_QRUPDATE
-#  include "dbleQR.h"
-#endif
-
-extern "C"
-{
-  F77_RET_T
-  F77_FUNC (cpotrf, CPOTRF) (F77_CONST_CHAR_ARG_DECL,
-                             const octave_idx_type&, FloatComplex*,
-                             const octave_idx_type&, octave_idx_type&
-                             F77_CHAR_ARG_LEN_DECL);
-  F77_RET_T
-  F77_FUNC (cpotri, CPOTRI) (F77_CONST_CHAR_ARG_DECL,
-                             const octave_idx_type&, FloatComplex*,
-                             const octave_idx_type&, octave_idx_type&
-                             F77_CHAR_ARG_LEN_DECL);
-
-  F77_RET_T
-  F77_FUNC (cpocon, CPOCON) (F77_CONST_CHAR_ARG_DECL,
-                             const octave_idx_type&, FloatComplex*,
-                             const octave_idx_type&, const float&,
-                             float&, FloatComplex*, float*, octave_idx_type&
-                             F77_CHAR_ARG_LEN_DECL);
-#ifdef HAVE_QRUPDATE
-
-  F77_RET_T
-  F77_FUNC (cch1up, CCH1UP) (const octave_idx_type&, FloatComplex*,
-                             const octave_idx_type&, FloatComplex*, float*);
-
-  F77_RET_T
-  F77_FUNC (cch1dn, CCH1DN) (const octave_idx_type&, FloatComplex*,
-                             const octave_idx_type&, FloatComplex*,
-                             float*, octave_idx_type&);
-
-  F77_RET_T
-  F77_FUNC (cchinx, CCHINX) (const octave_idx_type&, FloatComplex*,
-                             const octave_idx_type&, const octave_idx_type&,
-                             FloatComplex*, float*, octave_idx_type&);
-
-  F77_RET_T
-  F77_FUNC (cchdex, CCHDEX) (const octave_idx_type&, FloatComplex*,
-                             const octave_idx_type&, const octave_idx_type&,
-                             float*);
-
-  F77_RET_T
-  F77_FUNC (cchshx, CCHSHX) (const octave_idx_type&, FloatComplex*,
-                             const octave_idx_type&, const octave_idx_type&,
-                             const octave_idx_type&, FloatComplex*, float*);
-#endif
-}
-
-octave_idx_type
-FloatComplexCHOL::init (const FloatComplexMatrix& a, bool upper, bool calc_cond)
-{
-  octave_idx_type a_nr = a.rows ();
-  octave_idx_type a_nc = a.cols ();
-
-  if (a_nr != a_nc)
-    (*current_liboctave_error_handler)
-      ("FloatComplexCHOL requires square matrix");
-
-  octave_idx_type n = a_nc;
-  octave_idx_type info;
-
-  is_upper = upper;
-
-  chol_mat.clear (n, n);
-  if (is_upper)
-    for (octave_idx_type j = 0; j < n; j++)
-      {
-        for (octave_idx_type i = 0; i <= j; i++)
-          chol_mat.xelem (i, j) = a(i, j);
-        for (octave_idx_type i = j+1; i < n; i++)
-          chol_mat.xelem (i, j) = 0.0f;
-      }
-  else
-    for (octave_idx_type j = 0; j < n; j++)
-      {
-        for (octave_idx_type i = 0; i < j; i++)
-          chol_mat.xelem (i, j) = 0.0f;
-        for (octave_idx_type i = j; i < n; i++)
-          chol_mat.xelem (i, j) = a(i, j);
-      }
-  FloatComplex *h = chol_mat.fortran_vec ();
-
-  // Calculate the norm of the matrix, for later use.
-  float anorm = 0;
-  if (calc_cond)
-    anorm = xnorm (a, 1);
-
-  if (is_upper)
-    F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 ("U", 1), n, h, n, info
-                               F77_CHAR_ARG_LEN (1)));
-  else
-    F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1), n, h, n, info
-                               F77_CHAR_ARG_LEN (1)));
-
-  xrcond = 0.0;
-  if (info > 0)
-    chol_mat.resize (info - 1, info - 1);
-  else if (calc_cond)
-    {
-      octave_idx_type cpocon_info = 0;
-
-      // Now calculate the condition number for non-singular matrix.
-      Array<FloatComplex> z (dim_vector (2*n, 1));
-      FloatComplex *pz = z.fortran_vec ();
-      Array<float> rz (dim_vector (n, 1));
-      float *prz = rz.fortran_vec ();
-      F77_XFCN (cpocon, CPOCON, (F77_CONST_CHAR_ARG2 ("U", 1), n, h,
-                                 n, anorm, xrcond, pz, prz, cpocon_info
-                                 F77_CHAR_ARG_LEN (1)));
-
-      if (cpocon_info != 0)
-        info = -1;
-    }
-
-  return info;
-}
-
-static FloatComplexMatrix
-chol2inv_internal (const FloatComplexMatrix& r, bool is_upper = true)
-{
-  FloatComplexMatrix retval;
-
-  octave_idx_type r_nr = r.rows ();
-  octave_idx_type r_nc = r.cols ();
-
-  if (r_nr != r_nc)
-    (*current_liboctave_error_handler) ("chol2inv requires square matrix");
-
-  octave_idx_type n = r_nc;
-  octave_idx_type info;
-
-  FloatComplexMatrix tmp = r;
-
-  if (is_upper)
-    F77_XFCN (cpotri, CPOTRI, (F77_CONST_CHAR_ARG2 ("U", 1), n,
-                               tmp.fortran_vec (), n, info
-                               F77_CHAR_ARG_LEN (1)));
-  else
-    F77_XFCN (cpotri, CPOTRI, (F77_CONST_CHAR_ARG2 ("L", 1), n,
-                               tmp.fortran_vec (), n, info
-                               F77_CHAR_ARG_LEN (1)));
-
-  // If someone thinks of a more graceful way of doing this (or
-  // faster for that matter :-)), please let me know!
-
-  if (n > 1)
-    {
-      if (is_upper)
-        for (octave_idx_type j = 0; j < r_nc; j++)
-          for (octave_idx_type i = j+1; i < r_nr; i++)
-            tmp.xelem (i, j) = tmp.xelem (j, i);
-      else
-        for (octave_idx_type j = 0; j < r_nc; j++)
-          for (octave_idx_type i = j+1; i < r_nr; i++)
-            tmp.xelem (j, i) = tmp.xelem (i, j);
-    }
-
-  retval = tmp;
-
-  return retval;
-}
-
-// Compute the inverse of a matrix using the Cholesky factorization.
-FloatComplexMatrix
-FloatComplexCHOL::inverse (void) const
-{
-  return chol2inv_internal (chol_mat, is_upper);
-}
-
-void
-FloatComplexCHOL::set (const FloatComplexMatrix& R)
-{
-  if (! R.is_square ())
-    (*current_liboctave_error_handler) ("CHOL requires square matrix");
-
-  chol_mat = R;
-}
-
-#ifdef HAVE_QRUPDATE
-
-void
-FloatComplexCHOL::update (const FloatComplexColumnVector& u)
-{
-  octave_idx_type n = chol_mat.rows ();
-
-  if (u.numel () != n)
-    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
-
-  FloatComplexColumnVector utmp = u;
-
-  OCTAVE_LOCAL_BUFFER (float, rw, n);
-
-  F77_XFCN (cch1up, CCH1UP, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                             utmp.fortran_vec (), rw));
-}
-
-octave_idx_type
-FloatComplexCHOL::downdate (const FloatComplexColumnVector& u)
-{
-  octave_idx_type info = -1;
-
-  octave_idx_type n = chol_mat.rows ();
-
-  if (u.numel () != n)
-    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
-
-  FloatComplexColumnVector utmp = u;
-
-  OCTAVE_LOCAL_BUFFER (float, rw, n);
-
-  F77_XFCN (cch1dn, CCH1DN, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                             utmp.fortran_vec (), rw, info));
-
-  return info;
-}
-
-octave_idx_type
-FloatComplexCHOL::insert_sym (const FloatComplexColumnVector& u,
-                              octave_idx_type j)
-{
-  octave_idx_type info = -1;
-
-  octave_idx_type n = chol_mat.rows ();
-
-  if (u.numel () != n + 1)
-    (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
-  if (j < 0 || j > n)
-    (*current_liboctave_error_handler) ("cholinsert: index out of range");
-
-  FloatComplexColumnVector utmp = u;
-
-  OCTAVE_LOCAL_BUFFER (float, rw, n);
-
-  chol_mat.resize (n+1, n+1);
-
-  F77_XFCN (cchinx, CCHINX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                             j + 1, utmp.fortran_vec (), rw, info));
-
-  return info;
-}
-
-void
-FloatComplexCHOL::delete_sym (octave_idx_type j)
-{
-  octave_idx_type n = chol_mat.rows ();
-
-  if (j < 0 || j > n-1)
-    (*current_liboctave_error_handler) ("choldelete: index out of range");
-
-  OCTAVE_LOCAL_BUFFER (float, rw, n);
-
-  F77_XFCN (cchdex, CCHDEX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                             j + 1, rw));
-
-  chol_mat.resize (n-1, n-1);
-}
-
-void
-FloatComplexCHOL::shift_sym (octave_idx_type i, octave_idx_type j)
-{
-  octave_idx_type n = chol_mat.rows ();
-
-  if (i < 0 || i > n-1 || j < 0 || j > n-1)
-    (*current_liboctave_error_handler) ("cholshift: index out of range");
-
-  OCTAVE_LOCAL_BUFFER (FloatComplex, w, n);
-  OCTAVE_LOCAL_BUFFER (float, rw, n);
-
-  F77_XFCN (cchshx, CCHSHX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                             i + 1, j + 1, w, rw));
-}
-
-#else
-
-void
-FloatComplexCHOL::update (const FloatComplexColumnVector& u)
-{
-  warn_qrupdate_once ();
-
-  octave_idx_type n = chol_mat.rows ();
-
-  if (u.numel () != n)
-    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
-
-  init (chol_mat.hermitian () * chol_mat
-        + FloatComplexMatrix (u) * FloatComplexMatrix (u).hermitian (),
-        true, false);
-}
-
-static bool
-singular (const FloatComplexMatrix& a)
-{
-  for (octave_idx_type i = 0; i < a.rows (); i++)
-    if (a(i,i) == 0.0f) return true;
-  return false;
-}
-
-octave_idx_type
-FloatComplexCHOL::downdate (const FloatComplexColumnVector& u)
-{
-  warn_qrupdate_once ();
-
-  octave_idx_type info = -1;
-
-  octave_idx_type n = chol_mat.rows ();
-
-  if (u.numel () != n)
-    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
-
-  if (singular (chol_mat))
-    info = 2;
-  else
-    {
-      info = init (chol_mat.hermitian () * chol_mat
-                   - FloatComplexMatrix (u)
-                   * FloatComplexMatrix (u).hermitian (),
-                   true, false);
-      if (info) info = 1;
-    }
-
-  return info;
-}
-
-octave_idx_type
-FloatComplexCHOL::insert_sym (const FloatComplexColumnVector& u,
-                              octave_idx_type j)
-{
-  warn_qrupdate_once ();
-
-  octave_idx_type info = -1;
-
-  octave_idx_type n = chol_mat.rows ();
-
-  if (u.numel () != n + 1)
-    (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
-  if (j < 0 || j > n)
-    (*current_liboctave_error_handler) ("cholinsert: index out of range");
-
-  if (singular (chol_mat))
-    info = 2;
-  else if (u(j).imag () != 0.0)
-    info = 3;
-  else
-    {
-      FloatComplexMatrix a = chol_mat.hermitian () * chol_mat;
-      FloatComplexMatrix a1 (n+1, n+1);
-      for (octave_idx_type k = 0; k < n+1; k++)
-        for (octave_idx_type l = 0; l < n+1; l++)
-          {
-            if (l == j)
-              a1(k, l) = u(k);
-            else if (k == j)
-              a1(k, l) = std::conj (u(l));
-            else
-              a1(k, l) = a(k < j ? k : k-1, l < j ? l : l-1);
-          }
-      info = init (a1, true, false);
-      if (info) info = 1;
-    }
-
-  return info;
-}
-
-void
-FloatComplexCHOL::delete_sym (octave_idx_type j)
-{
-  warn_qrupdate_once ();
-
-  octave_idx_type n = chol_mat.rows ();
-
-  if (j < 0 || j > n-1)
-    (*current_liboctave_error_handler) ("choldelete: index out of range");
-
-  FloatComplexMatrix a = chol_mat.hermitian () * chol_mat;
-  a.delete_elements (1, idx_vector (j));
-  a.delete_elements (0, idx_vector (j));
-  init (a, true, false);
-}
-
-void
-FloatComplexCHOL::shift_sym (octave_idx_type i, octave_idx_type j)
-{
-  warn_qrupdate_once ();
-
-  octave_idx_type n = chol_mat.rows ();
-
-  if (i < 0 || i > n-1 || j < 0 || j > n-1)
-    (*current_liboctave_error_handler) ("cholshift: index out of range");
-
-  FloatComplexMatrix a = chol_mat.hermitian () * chol_mat;
-  Array<octave_idx_type> p (dim_vector (n, 1));
-  for (octave_idx_type k = 0; k < n; k++) p(k) = k;
-  if (i < j)
-    {
-      for (octave_idx_type k = i; k < j; k++) p(k) = k+1;
-      p(j) = i;
-    }
-  else if (j < i)
-    {
-      p(j) = i;
-      for (octave_idx_type k = j+1; k < i+1; k++) p(k) = k-1;
-    }
-
-  init (a.index (idx_vector (p), idx_vector (p)), true, false);
-}
-
-#endif
-
-FloatComplexMatrix
-chol2inv (const FloatComplexMatrix& r)
-{
-  return chol2inv_internal (r);
-}
diff --git a/liboctave/numeric/fCmplxCHOL.h b/liboctave/numeric/fCmplxCHOL.h
deleted file mode 100644
--- a/liboctave/numeric/fCmplxCHOL.h
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
-
-Copyright (C) 1994-2015 John W. Eaton
-Copyright (C) 2008-2009 Jaroslav Hajek
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#if ! defined (octave_fCmplxCHOL_h)
-#define octave_fCmplxCHOL_h 1
-
-#include "octave-config.h"
-
-#include <iosfwd>
-
-#include "fCMatrix.h"
-#include "fCColVector.h"
-
-class
-OCTAVE_API
-FloatComplexCHOL
-{
-public:
-
-  FloatComplexCHOL (void) : chol_mat (), xrcond (0) { }
-
-  FloatComplexCHOL (const FloatComplexMatrix& a, bool upper = true,
-                    bool calc_cond = false)
-    : chol_mat (), xrcond (0)
-  {
-    init (a, upper, calc_cond);
-  }
-
-  FloatComplexCHOL (const FloatComplexMatrix& a, octave_idx_type& info,
-                    bool upper = true, bool calc_cond = false)
-    : chol_mat (), xrcond (0)
-  {
-    info = init (a, upper, calc_cond);
-  }
-
-  FloatComplexCHOL (const FloatComplexCHOL& a)
-    : chol_mat (a.chol_mat), xrcond (a.xrcond) { }
-
-  FloatComplexCHOL& operator = (const FloatComplexCHOL& a)
-  {
-    if (this != &a)
-      {
-        chol_mat = a.chol_mat;
-        xrcond = a.xrcond;
-      }
-
-    return *this;
-  }
-
-  FloatComplexMatrix chol_matrix (void) const { return chol_mat; }
-
-  float rcond (void) const { return xrcond; }
-
-  FloatComplexMatrix inverse (void) const;
-
-  void set (const FloatComplexMatrix& R);
-
-  void update (const FloatComplexColumnVector& u);
-
-  octave_idx_type downdate (const FloatComplexColumnVector& u);
-
-  octave_idx_type insert_sym (const FloatComplexColumnVector& u,
-                              octave_idx_type j);
-
-  void delete_sym (octave_idx_type j);
-
-  void shift_sym (octave_idx_type i, octave_idx_type j);
-
-  friend OCTAVE_API std::ostream& operator << (std::ostream& os,
-                                               const FloatComplexCHOL& a);
-
-private:
-
-  FloatComplexMatrix chol_mat;
-
-  float xrcond;
-
-  bool is_upper;
-
-  octave_idx_type init (const FloatComplexMatrix& a, bool upper, bool calc_cond);
-};
-
-FloatComplexMatrix OCTAVE_API chol2inv (const FloatComplexMatrix& r);
-
-#endif
diff --git a/liboctave/numeric/floatCHOL.cc b/liboctave/numeric/floatCHOL.cc
deleted file mode 100644
--- a/liboctave/numeric/floatCHOL.cc
+++ /dev/null
@@ -1,454 +0,0 @@
-/*
-
-Copyright (C) 1994-2015 John W. Eaton
-Copyright (C) 2008-2009 Jaroslav Hajek
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
-
-#include <vector>
-
-#include "fRowVector.h"
-#include "floatCHOL.h"
-#include "f77-fcn.h"
-#include "lo-error.h"
-#include "oct-locbuf.h"
-#include "oct-norm.h"
-#ifndef HAVE_QRUPDATE
-#  include "dbleQR.h"
-#endif
-
-extern "C"
-{
-  F77_RET_T
-  F77_FUNC (spotrf, SPOTRF) (F77_CONST_CHAR_ARG_DECL,
-                             const octave_idx_type&, float*,
-                             const octave_idx_type&, octave_idx_type&
-                             F77_CHAR_ARG_LEN_DECL);
-
-  F77_RET_T
-  F77_FUNC (spotri, SPOTRI) (F77_CONST_CHAR_ARG_DECL,
-                             const octave_idx_type&, float*,
-                             const octave_idx_type&, octave_idx_type&
-                             F77_CHAR_ARG_LEN_DECL);
-
-  F77_RET_T
-  F77_FUNC (spocon, SPOCON) (F77_CONST_CHAR_ARG_DECL,
-                             const octave_idx_type&, float*,
-                             const octave_idx_type&, const float&,
-                             float&, float*, octave_idx_type*,
-                             octave_idx_type&
-                             F77_CHAR_ARG_LEN_DECL);
-#ifdef HAVE_QRUPDATE
-
-  F77_RET_T
-  F77_FUNC (sch1up, SCH1UP) (const octave_idx_type&, float*,
-                             const octave_idx_type&, float*, float*);
-
-  F77_RET_T
-  F77_FUNC (sch1dn, SCH1DN) (const octave_idx_type&, float*,
-                             const octave_idx_type&, float*, float*,
-                             octave_idx_type&);
-
-  F77_RET_T
-  F77_FUNC (schinx, SCHINX) (const octave_idx_type&, float*,
-                             const octave_idx_type&, const octave_idx_type&,
-                             float*, float*, octave_idx_type&);
-
-  F77_RET_T
-  F77_FUNC (schdex, SCHDEX) (const octave_idx_type&, float*,
-                             const octave_idx_type&, const octave_idx_type&,
-                             float*);
-
-  F77_RET_T
-  F77_FUNC (schshx, SCHSHX) (const octave_idx_type&, float*,
-                             const octave_idx_type&, const octave_idx_type&,
-                             const octave_idx_type&, float*);
-#endif
-}
-
-octave_idx_type
-FloatCHOL::init (const FloatMatrix& a, bool upper, bool calc_cond)
-{
-  octave_idx_type a_nr = a.rows ();
-  octave_idx_type a_nc = a.cols ();
-
-  if (a_nr != a_nc)
-    (*current_liboctave_error_handler) ("FloatCHOL requires square matrix");
-
-  octave_idx_type n = a_nc;
-  octave_idx_type info;
-
-  is_upper = upper;
-
-  chol_mat.clear (n, n);
-  if (is_upper)
-    for (octave_idx_type j = 0; j < n; j++)
-      {
-        for (octave_idx_type i = 0; i <= j; i++)
-          chol_mat.xelem (i, j) = a(i, j);
-        for (octave_idx_type i = j+1; i < n; i++)
-          chol_mat.xelem (i, j) = 0.0f;
-      }
-  else
-    for (octave_idx_type j = 0; j < n; j++)
-      {
-        for (octave_idx_type i = 0; i < j; i++)
-          chol_mat.xelem (i, j) = 0.0f;
-        for (octave_idx_type i = j; i < n; i++)
-          chol_mat.xelem (i, j) = a(i, j);
-      }
-  float *h = chol_mat.fortran_vec ();
-
-  // Calculate the norm of the matrix, for later use.
-  float anorm = 0;
-  if (calc_cond)
-    anorm = xnorm (a, 1);
-
-  if (is_upper)
-    F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 ("U", 1), n, h, n, info
-                               F77_CHAR_ARG_LEN (1)));
-  else
-    F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1), n, h, n, info
-                               F77_CHAR_ARG_LEN (1)));
-
-  xrcond = 0.0;
-  if (info > 0)
-    chol_mat.resize (info - 1, info - 1);
-  else if (calc_cond)
-    {
-      octave_idx_type spocon_info = 0;
-
-      // Now calculate the condition number for non-singular matrix.
-      Array<float> z (dim_vector (3*n, 1));
-      float *pz = z.fortran_vec ();
-      Array<octave_idx_type> iz (dim_vector (n, 1));
-      octave_idx_type *piz = iz.fortran_vec ();
-      if (is_upper)
-        F77_XFCN (spocon, SPOCON, (F77_CONST_CHAR_ARG2 ("U", 1), n, h,
-                                   n, anorm, xrcond, pz, piz, spocon_info
-                                   F77_CHAR_ARG_LEN (1)));
-      else
-        F77_XFCN (spocon, SPOCON, (F77_CONST_CHAR_ARG2 ("L", 1), n, h,
-                                   n, anorm, xrcond, pz, piz, spocon_info
-                                   F77_CHAR_ARG_LEN (1)));
-
-      if (spocon_info != 0)
-        info = -1;
-    }
-
-  return info;
-}
-
-static FloatMatrix
-chol2inv_internal (const FloatMatrix& r, bool is_upper = true)
-{
-  FloatMatrix retval;
-
-  octave_idx_type r_nr = r.rows ();
-  octave_idx_type r_nc = r.cols ();
-
-  if (r_nr != r_nc)
-    (*current_liboctave_error_handler) ("chol2inv requires square matrix");
-
-  octave_idx_type n = r_nc;
-  octave_idx_type info = 0;
-
-  FloatMatrix tmp = r;
-  float *v = tmp.fortran_vec ();
-
-  if (info == 0)
-    {
-      if (is_upper)
-        F77_XFCN (spotri, SPOTRI, (F77_CONST_CHAR_ARG2 ("U", 1), n,
-                                   v, n, info
-                                   F77_CHAR_ARG_LEN (1)));
-      else
-        F77_XFCN (spotri, SPOTRI, (F77_CONST_CHAR_ARG2 ("L", 1), n,
-                                   v, n, info
-                                   F77_CHAR_ARG_LEN (1)));
-
-      // If someone thinks of a more graceful way of doing this (or
-      // faster for that matter :-)), please let me know!
-
-      if (n > 1)
-        {
-          if (is_upper)
-            for (octave_idx_type j = 0; j < r_nc; j++)
-              for (octave_idx_type i = j+1; i < r_nr; i++)
-                tmp.xelem (i, j) = tmp.xelem (j, i);
-          else
-            for (octave_idx_type j = 0; j < r_nc; j++)
-              for (octave_idx_type i = j+1; i < r_nr; i++)
-                tmp.xelem (j, i) = tmp.xelem (i, j);
-        }
-
-      retval = tmp;
-    }
-
-  return retval;
-}
-
-// Compute the inverse of a matrix using the Cholesky factorization.
-FloatMatrix
-FloatCHOL::inverse (void) const
-{
-  return chol2inv_internal (chol_mat, is_upper);
-}
-
-void
-FloatCHOL::set (const FloatMatrix& R)
-{
-  if (! R.is_square ())
-    (*current_liboctave_error_handler) ("FloatCHOL requires square matrix");
-
-  chol_mat = R;
-}
-
-#ifdef HAVE_QRUPDATE
-
-void
-FloatCHOL::update (const FloatColumnVector& u)
-{
-  octave_idx_type n = chol_mat.rows ();
-
-  if (u.numel () != n)
-    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
-
-  FloatColumnVector utmp = u;
-
-  OCTAVE_LOCAL_BUFFER (float, w, n);
-
-  F77_XFCN (sch1up, SCH1UP, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                             utmp.fortran_vec (), w));
-}
-
-octave_idx_type
-FloatCHOL::downdate (const FloatColumnVector& u)
-{
-  octave_idx_type info = -1;
-
-  octave_idx_type n = chol_mat.rows ();
-
-  if (u.numel () != n)
-    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
-
-  FloatColumnVector utmp = u;
-
-  OCTAVE_LOCAL_BUFFER (float, w, n);
-
-  F77_XFCN (sch1dn, SCH1DN, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                             utmp.fortran_vec (), w, info));
-
-  return info;
-}
-
-octave_idx_type
-FloatCHOL::insert_sym (const FloatColumnVector& u, octave_idx_type j)
-{
-  octave_idx_type info = -1;
-
-  octave_idx_type n = chol_mat.rows ();
-
-  if (u.numel () != n + 1)
-    (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
-  if (j < 0 || j > n)
-    (*current_liboctave_error_handler) ("cholinsert: index out of range");
-
-  FloatColumnVector utmp = u;
-
-  OCTAVE_LOCAL_BUFFER (float, w, n);
-
-  chol_mat.resize (n+1, n+1);
-
-  F77_XFCN (schinx, SCHINX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                             j + 1, utmp.fortran_vec (), w, info));
-
-  return info;
-}
-
-void
-FloatCHOL::delete_sym (octave_idx_type j)
-{
-  octave_idx_type n = chol_mat.rows ();
-
-  if (j < 0 || j > n-1)
-    (*current_liboctave_error_handler) ("choldelete: index out of range");
-
-  OCTAVE_LOCAL_BUFFER (float, w, n);
-
-  F77_XFCN (schdex, SCHDEX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                             j + 1, w));
-
-  chol_mat.resize (n-1, n-1);
-}
-
-void
-FloatCHOL::shift_sym (octave_idx_type i, octave_idx_type j)
-{
-  octave_idx_type n = chol_mat.rows ();
-
-  if (i < 0 || i > n-1 || j < 0 || j > n-1)
-    (*current_liboctave_error_handler) ("cholshift: index out of range");
-
-  OCTAVE_LOCAL_BUFFER (float, w, 2*n);
-
-  F77_XFCN (schshx, SCHSHX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                             i + 1, j + 1, w));
-}
-
-#else
-
-void
-FloatCHOL::update (const FloatColumnVector& u)
-{
-  warn_qrupdate_once ();
-
-  octave_idx_type n = chol_mat.rows ();
-
-  if (u.numel () != n)
-    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
-
-  init (chol_mat.transpose () * chol_mat
-        + FloatMatrix (u) * FloatMatrix (u).transpose (), true, false);
-}
-
-static bool
-singular (const FloatMatrix& a)
-{
-  for (octave_idx_type i = 0; i < a.rows (); i++)
-    if (a(i,i) == 0.0f) return true;
-  return false;
-}
-
-octave_idx_type
-FloatCHOL::downdate (const FloatColumnVector& u)
-{
-  warn_qrupdate_once ();
-
-  octave_idx_type info = -1;
-
-  octave_idx_type n = chol_mat.rows ();
-
-  if (u.numel () != n)
-    (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
-
-  if (singular (chol_mat))
-    info = 2;
-  else
-    {
-      info = init (chol_mat.transpose () * chol_mat
-                   - FloatMatrix (u) * FloatMatrix (u).transpose (), true,
-                   false);
-      if (info) info = 1;
-    }
-
-  return info;
-}
-
-octave_idx_type
-FloatCHOL::insert_sym (const FloatColumnVector& u, octave_idx_type j)
-{
-  warn_qrupdate_once ();
-
-  octave_idx_type info = -1;
-
-  octave_idx_type n = chol_mat.rows ();
-
-  if (u.numel () != n + 1)
-    (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
-  if (j < 0 || j > n)
-    (*current_liboctave_error_handler) ("cholinsert: index out of range");
-
-  if (singular (chol_mat))
-    info = 2;
-  else
-    {
-      FloatMatrix a = chol_mat.transpose () * chol_mat;
-      FloatMatrix a1 (n+1, n+1);
-      for (octave_idx_type k = 0; k < n+1; k++)
-        for (octave_idx_type l = 0; l < n+1; l++)
-          {
-            if (l == j)
-              a1(k, l) = u(k);
-            else if (k == j)
-              a1(k, l) = u(l);
-            else
-              a1(k, l) = a(k < j ? k : k-1, l < j ? l : l-1);
-          }
-      info = init (a1, true, false);
-      if (info) info = 1;
-    }
-
-  return info;
-}
-
-void
-FloatCHOL::delete_sym (octave_idx_type j)
-{
-  warn_qrupdate_once ();
-
-  octave_idx_type n = chol_mat.rows ();
-
-  if (j < 0 || j > n-1)
-    (*current_liboctave_error_handler) ("choldelete: index out of range");
-
-  FloatMatrix a = chol_mat.transpose () * chol_mat;
-  a.delete_elements (1, idx_vector (j));
-  a.delete_elements (0, idx_vector (j));
-  init (a, true, false);
-}
-
-void
-FloatCHOL::shift_sym (octave_idx_type i, octave_idx_type j)
-{
-  warn_qrupdate_once ();
-
-  octave_idx_type n = chol_mat.rows ();
-
-  if (i < 0 || i > n-1 || j < 0 || j > n-1)
-    (*current_liboctave_error_handler) ("cholshift: index out of range");
-
-  FloatMatrix a = chol_mat.transpose () * chol_mat;
-  Array<octave_idx_type> p (dim_vector (n, 1));
-  for (octave_idx_type k = 0; k < n; k++) p(k) = k;
-  if (i < j)
-    {
-      for (octave_idx_type k = i; k < j; k++) p(k) = k+1;
-      p(j) = i;
-    }
-  else if (j < i)
-    {
-      p(j) = i;
-      for (octave_idx_type k = j+1; k < i+1; k++) p(k) = k-1;
-    }
-
-  init (a.index (idx_vector (p), idx_vector (p)), true, false);
-}
-
-#endif
-
-FloatMatrix
-chol2inv (const FloatMatrix& r)
-{
-  return chol2inv_internal (r);
-}
diff --git a/liboctave/numeric/floatCHOL.h b/liboctave/numeric/floatCHOL.h
deleted file mode 100644
--- a/liboctave/numeric/floatCHOL.h
+++ /dev/null
@@ -1,102 +0,0 @@
-/*
-
-Copyright (C) 1994-2015 John W. Eaton
-Copyright (C) 2008-2009 Jaroslav Hajek
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#if ! defined (octave_floatCHOL_h)
-#define octave_floatCHOL_h 1
-
-#include "octave-config.h"
-
-#include <iosfwd>
-
-#include "fMatrix.h"
-#include "fColVector.h"
-
-class
-OCTAVE_API
-FloatCHOL
-{
-public:
-
-  FloatCHOL (void) : chol_mat (), xrcond (0) { }
-
-  FloatCHOL (const FloatMatrix& a, bool upper = true, bool calc_cond = false)
-    : chol_mat (), xrcond (0)
-  {
-    init (a, upper, calc_cond);
-  }
-
-  FloatCHOL (const FloatMatrix& a, octave_idx_type& info, bool upper = true,
-             bool calc_cond = false)
-    : chol_mat (), xrcond (0)
-  {
-    info = init (a, upper, calc_cond);
-  }
-
-  FloatCHOL (const FloatCHOL& a) : chol_mat (a.chol_mat), xrcond (a.xrcond) { }
-
-  FloatCHOL& operator = (const FloatCHOL& a)
-  {
-    if (this != &a)
-      {
-        chol_mat = a.chol_mat;
-        xrcond = a.xrcond;
-      }
-    return *this;
-  }
-
-  FloatMatrix chol_matrix (void) const { return chol_mat; }
-
-  float rcond (void) const { return xrcond; }
-
-  // Compute the inverse of a matrix using the Cholesky factorization.
-  FloatMatrix inverse (void) const;
-
-  void set (const FloatMatrix& R);
-
-  void update (const FloatColumnVector& u);
-
-  octave_idx_type downdate (const FloatColumnVector& u);
-
-  octave_idx_type insert_sym (const FloatColumnVector& u, octave_idx_type j);
-
-  void delete_sym (octave_idx_type j);
-
-  void shift_sym (octave_idx_type i, octave_idx_type j);
-
-  friend OCTAVE_API std::ostream& operator << (std::ostream& os,
-                                               const FloatCHOL& a);
-
-private:
-
-  FloatMatrix chol_mat;
-
-  float xrcond;
-
-  bool is_upper;
-
-  octave_idx_type init (const FloatMatrix& a, bool upper, bool calc_cond);
-};
-
-FloatMatrix OCTAVE_API chol2inv (const FloatMatrix& r);
-
-#endif
diff --git a/liboctave/numeric/module.mk b/liboctave/numeric/module.mk
--- a/liboctave/numeric/module.mk
+++ b/liboctave/numeric/module.mk
@@ -3,17 +3,16 @@ LIBOCTAVE_OPT_INC = \
   liboctave/numeric/DASRT-opts.h \
   liboctave/numeric/DASSL-opts.h \
   liboctave/numeric/LSODE-opts.h \
   liboctave/numeric/Quad-opts.h
 
 LIBOCTAVE_OPT_IN = $(LIBOCTAVE_OPT_INC:.h=.in)
 
 NUMERIC_INC = \
-  liboctave/numeric/CmplxCHOL.h \
   liboctave/numeric/CmplxLU.h \
   liboctave/numeric/CmplxQR.h \
   liboctave/numeric/CmplxQRP.h \
   liboctave/numeric/CmplxSVD.h \
   liboctave/numeric/CollocWt.h \
   liboctave/numeric/DAE.h \
   liboctave/numeric/DAEFunc.h \
   liboctave/numeric/DAERT.h \
@@ -32,29 +31,27 @@ NUMERIC_INC = \
   liboctave/numeric/aepbalance.h \
   liboctave/numeric/base-dae.h \
   liboctave/numeric/base-de.h \
   liboctave/numeric/base-lu.h \
   liboctave/numeric/base-min.h \
   liboctave/numeric/base-qr.h \
   liboctave/numeric/bsxfun-decl.h \
   liboctave/numeric/bsxfun.h \
-  liboctave/numeric/dbleCHOL.h \
+  liboctave/numeric/chol.h \
   liboctave/numeric/dbleLU.h \
   liboctave/numeric/dbleQR.h \
   liboctave/numeric/dbleQRP.h \
   liboctave/numeric/dbleSVD.h \
   liboctave/numeric/eigs-base.h \
-  liboctave/numeric/fCmplxCHOL.h \
   liboctave/numeric/fCmplxLU.h \
   liboctave/numeric/fCmplxQR.h \
   liboctave/numeric/fCmplxQRP.h \
   liboctave/numeric/fCmplxSVD.h \
   liboctave/numeric/fEIG.h \
-  liboctave/numeric/floatCHOL.h \
   liboctave/numeric/floatLU.h \
   liboctave/numeric/floatQR.h \
   liboctave/numeric/floatQRP.h \
   liboctave/numeric/floatSVD.h \
   liboctave/numeric/gepbalance.h \
   liboctave/numeric/hess.h \
   liboctave/numeric/lo-mappers.h \
   liboctave/numeric/lo-specfun.h \
@@ -73,43 +70,40 @@ NUMERIC_INC = \
   liboctave/numeric/sparse-qr.h
 
 NUMERIC_C_SRC = \
   liboctave/numeric/randgamma.c \
   liboctave/numeric/randmtzig.c \
   liboctave/numeric/randpoisson.c
 
 NUMERIC_SRC = \
-  liboctave/numeric/CmplxCHOL.cc \
   liboctave/numeric/CmplxLU.cc \
   liboctave/numeric/CmplxQR.cc \
   liboctave/numeric/CmplxQRP.cc \
   liboctave/numeric/CmplxSVD.cc \
   liboctave/numeric/CollocWt.cc \
   liboctave/numeric/DASPK.cc \
   liboctave/numeric/DASRT.cc \
   liboctave/numeric/DASSL.cc \
   liboctave/numeric/EIG.cc \
   liboctave/numeric/LSODE.cc \
   liboctave/numeric/ODES.cc \
   liboctave/numeric/Quad.cc \
   liboctave/numeric/aepbalance.cc \
-  liboctave/numeric/dbleCHOL.cc \
+  liboctave/numeric/chol.cc \
   liboctave/numeric/dbleLU.cc \
   liboctave/numeric/dbleQR.cc \
   liboctave/numeric/dbleQRP.cc \
   liboctave/numeric/dbleSVD.cc \
   liboctave/numeric/eigs-base.cc \
-  liboctave/numeric/fCmplxCHOL.cc \
   liboctave/numeric/fCmplxLU.cc \
   liboctave/numeric/fCmplxQR.cc \
   liboctave/numeric/fCmplxQRP.cc \
   liboctave/numeric/fCmplxSVD.cc \
   liboctave/numeric/fEIG.cc \
-  liboctave/numeric/floatCHOL.cc \
   liboctave/numeric/floatLU.cc \
   liboctave/numeric/floatQR.cc \
   liboctave/numeric/floatQRP.cc \
   liboctave/numeric/floatSVD.cc \
   liboctave/numeric/gepbalance.cc \
   liboctave/numeric/hess.cc \
   liboctave/numeric/lo-mappers.cc \
   liboctave/numeric/lo-specfun.cc \
diff --git a/liboctave/operators/mx-defs.h b/liboctave/operators/mx-defs.h
--- a/liboctave/operators/mx-defs.h
+++ b/liboctave/operators/mx-defs.h
@@ -57,20 +57,17 @@ class FloatDiagMatrix;
 class FloatComplexDiagMatrix;
 
 class PermMatrix;
 
 template <typename T> class aepbalance;
 
 template <typename T> class gepbalance;
 
-class CHOL;
-class ComplexCHOL;
-class FloatCHOL;
-class FloatComplexCHOL;
+template <typename T> class chol;
 
 class EIG;
 
 template <typename T> class hess;
 
 template <typename T> class schur;
 
 class SVD;
diff --git a/liboctave/operators/mx-ext.h b/liboctave/operators/mx-ext.h
--- a/liboctave/operators/mx-ext.h
+++ b/liboctave/operators/mx-ext.h
@@ -34,20 +34,17 @@ along with Octave; see the file COPYING.
 #include "gepbalance.h"
 
 // Result of a Determinant calculation.
 
 #include "DET.h"
 
 // Result of a Cholesky Factorization
 
-#include "dbleCHOL.h"
-#include "CmplxCHOL.h"
-#include "floatCHOL.h"
-#include "fCmplxCHOL.h"
+#include "chol.h"
 
 // Result of a Hessenberg Decomposition
 
 #include "hess.h"
 
 // Result of a Schur Decomposition
 
 #include "schur.h"
