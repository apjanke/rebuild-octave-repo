# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1453661404 18000
#      Sun Jan 24 13:50:04 2016 -0500
# Node ID 538b57866b908a5f2115a54af0446fd14d91c59a
# Parent  e2fca7d79169446c0a2b578917eab824df514016
consistently use "typename" intead of "class" in template declarations

* Object.h, QtHandlesUtils.cc, QtHandlesUtils.h, ToolBarButton.cc,
ToolBarButton.h, Cell.h, __lin_interpn__.cc, bitfcns.cc, bsxfun.cc,
cellfun.cc, data.cc, filter.cc, gcd.cc, graphics.cc, help.cc, kron.cc,
lookup.cc, ls-mat5.cc, ls-oct-text.h, lu.cc, max.cc, mgorth.cc,
oct-map.cc, oct-map.h, oct-stream.cc, oct-stream.h, octave-link.h,
pr-output.cc, profiler.h, schur.cc, sparse-xdiv.cc, sparse-xpow.cc,
sqrtm.cc, symtab.h, tril.cc, typecast.cc, variables.cc, xdiv.cc,
zfstream.h, __init_fltk__.cc, __magick_read__.cc, chol.cc, qr.cc,
ov-base-diag.cc, ov-base-diag.h, ov-base-int.cc, ov-base-int.h,
ov-base-mat.cc, ov-base-mat.h, ov-base-scalar.cc, ov-base-scalar.h,
ov-base-sparse.cc, ov-base-sparse.h, ov-base.h, ov-classdef.cc,
ov-int-traits.h, ov-java.h, ov-usr-fcn.h, ov.cc, ov.h,
op-dms-template.cc, oct-parse.in.yy, parse.h, pt-mat.cc, Array-b.cc,
Array.cc, Array.h, CDiagMatrix.h, CMatrix.h, CNDArray.h,
DiagArray2.cc, DiagArray2.h, MArray.cc, MArray.h, MDiagArray2.cc,
MDiagArray2.h, MSparse.cc, MSparse.h, MatrixType.cc, Sparse.cc,
Sparse.h, dDiagMatrix.h, dMatrix.h, dNDArray.h, fCDiagMatrix.h,
fCMatrix.h, fCNDArray.h, fDiagMatrix.h, fMatrix.h, fNDArray.h,
idx-vector.cc, idx-vector.h, intNDArray.cc, intNDArray.h, DET.h,
base-aepbal.h, base-lu.cc, base-lu.h, base-qr.cc, base-qr.h,
bsxfun-defs.cc, eigs-base.cc, lo-mappers.h, lo-specfun.cc,
lo-specfun.h, oct-convn.cc, oct-fftw.cc, oct-norm.cc,
sparse-base-chol.cc, sparse-base-chol.h, sparse-base-lu.cc,
sparse-base-lu.h, sparse-dmsolve.cc, mx-inlines.cc,
action-container.h, base-list.h, lo-traits.h, lo-utils.h,
oct-base64.h, oct-binmap.h, oct-cmplx.h, oct-inttypes.cc,
oct-inttypes.h, oct-locbuf.h, oct-refcount.h, oct-sort.cc, oct-sort.h:
Use "typename" instead of "class" in template declarations.

diff --git a/libgui/graphics/Object.h b/libgui/graphics/Object.h
--- a/libgui/graphics/Object.h
+++ b/libgui/graphics/Object.h
@@ -47,35 +47,35 @@ public:
   virtual ~Object (void);
 
   base_properties& properties (void)
     { return object ().get_properties (); }
 
   const base_properties& properties (void) const
     { return object ().get_properties (); }
 
-  template <class T>
+  template <typename T>
   typename T::properties& properties (void)
     {
       return dynamic_cast<typename T::properties&>
         (object ().get_properties ());
     }
 
-  template <class T>
+  template <typename T>
   const typename T::properties& properties (void) const
     {
       return dynamic_cast<const typename T::properties&>
         (object ().get_properties ());
     }
 
   graphics_object object (void) const;
 
   virtual QObject* qObject (void) { return m_qobject; }
 
-  template <class T>
+  template <typename T>
   T* qWidget (void) { return qobject_cast<T*>(qObject ()); }
 
   virtual Container* innerContainer (void) = 0;
 
   static Object* fromQObject (QObject* obj);
 
 public slots:
   void slotUpdate (int pId);
diff --git a/libgui/graphics/QtHandlesUtils.cc b/libgui/graphics/QtHandlesUtils.cc
--- a/libgui/graphics/QtHandlesUtils.cc
+++ b/libgui/graphics/QtHandlesUtils.cc
@@ -93,17 +93,17 @@ Cell toCellString (const QStringList& l)
   // no strings will be a a 1x1 cell with empty string
   if (tmp.length () == 0)
     tmp += "";
 
   Cell v(toStringVector (tmp));
   return v;
 }
 
-template <class T>
+template <typename T>
 QFont
 computeFont (const typename T::properties& props, int height)
 {
   QFont f (fromStdString (props.get_fontname ()));
 
   static std::map<std::string, QFont::Weight> weightMap;
   static std::map<std::string, QFont::Style> angleMap;
   static bool mapsInitialized = false;
diff --git a/libgui/graphics/QtHandlesUtils.h b/libgui/graphics/QtHandlesUtils.h
--- a/libgui/graphics/QtHandlesUtils.h
+++ b/libgui/graphics/QtHandlesUtils.h
@@ -44,37 +44,37 @@ namespace Utils
   QString fromStdString (const std::string& s);
   std::string toStdString (const QString& s);
 
   QStringList fromStringVector (const string_vector& v);
   string_vector toStringVector (const QStringList& l);
 
   Cell toCellString (const QStringList& l);
 
-  template <class T>
+  template <typename T>
   QFont computeFont (const typename T::properties& props, int height = -1);
 
   QColor fromRgb (const Matrix& rgb);
   Matrix toRgb (const QColor& c);
 
   Qt::Alignment fromHVAlign (const caseless_str& halign,
                              const caseless_str& valign);
 
   std::string figureSelectionType (QMouseEvent* event,
                                    bool isDoubleClick = false);
 
   Matrix figureCurrentPoint (const graphics_object& fig, QMouseEvent* event);
   Matrix figureCurrentPoint (const graphics_object& fig);
 
-  template <class T>
+  template <typename T>
   inline typename T::properties&
   properties (graphics_object obj)
     { return dynamic_cast<typename T::properties&> (obj.get_properties ()); }
 
-  template <class T>
+  template <typename T>
   inline typename T::properties&
   properties (const graphics_handle& h)
     { return Utils::properties<T> (gh_manager::get_object (h)); }
 
   QImage makeImageFromCData (const octave_value& v, int width = -1,
                              int height = -1);
 
   octave_scalar_map makeKeyEventStruct (QKeyEvent* event);
diff --git a/libgui/graphics/ToolBarButton.cc b/libgui/graphics/ToolBarButton.cc
--- a/libgui/graphics/ToolBarButton.cc
+++ b/libgui/graphics/ToolBarButton.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 #include <QWidget>
 
 #include "ToolBarButton.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
-template <class T>
+template <typename T>
 ToolBarButton<T>::ToolBarButton (const graphics_object& go, QAction* action)
   : Object (go, action), m_separator (0)
 {
   typename T::properties& tp = properties<T> ();
 
   action->setToolTip (Utils::fromStdString (tp.get_tooltipstring ()));
   action->setVisible (tp.is_visible ());
   QImage img = Utils::makeImageFromCData (tp.get_cdata (), 16, 16);
@@ -53,22 +53,22 @@ ToolBarButton<T>::ToolBarButton (const g
 
   QWidget* w = qobject_cast<QWidget*> (action->parent ());
 
   w->insertAction (w->actions ().back (), action);
   if (m_separator)
     w->insertAction (action, m_separator);
 }
 
-template <class T>
+template <typename T>
 ToolBarButton<T>::~ToolBarButton (void)
 {
 }
 
-template <class T>
+template <typename T>
 void
 ToolBarButton<T>::update (int pId)
 {
   typename T::properties& tp = properties<T> ();
   QAction* action = qWidget<QAction> ();
 
   switch (pId)
     {
diff --git a/libgui/graphics/ToolBarButton.h b/libgui/graphics/ToolBarButton.h
--- a/libgui/graphics/ToolBarButton.h
+++ b/libgui/graphics/ToolBarButton.h
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 
 class QAction;
 
 namespace QtHandles
 {
 
 class Container;
 
-template <class T>
+template <typename T>
 class ToolBarButton : public Object
 {
 public:
   ToolBarButton (const graphics_object& go, QAction* action);
   ~ToolBarButton (void);
 
   Container* innerContainer (void) { return 0; }
 
diff --git a/libinterp/corefcn/Cell.h b/libinterp/corefcn/Cell.h
--- a/libinterp/corefcn/Cell.h
+++ b/libinterp/corefcn/Cell.h
@@ -137,13 +137,13 @@ public:
 
 private:
 
   typedef octave_value (octave_value::*ctype_mapper) (void) const;
 
   Cell map (ctype_mapper) const;
 };
 
-template<>
+template <>
 inline Cell octave_value_extract<Cell> (const octave_value& v)
 { return v.cell_value (); }
 
 #endif
diff --git a/libinterp/corefcn/__lin_interpn__.cc b/libinterp/corefcn/__lin_interpn__.cc
--- a/libinterp/corefcn/__lin_interpn__.cc
+++ b/libinterp/corefcn/__lin_interpn__.cc
@@ -29,26 +29,26 @@ along with Octave; see the file COPYING.
 #include "oct-locbuf.h"
 
 #include "defun.h"
 #include "error.h"
 #include "ovl.h"
 
 // equivalent to isvector.m
 
-template <class T>
+template <typename T>
 bool
 isvector (const T& array)
 {
   const dim_vector dv = array.dims ();
   return dv.length () == 2 && (dv(0) == 1 || dv(1) == 1);
 }
 
 // lookup a value in a sorted table (lookup.m)
-template <class T>
+template <typename T>
 octave_idx_type
 lookup (const T *x, octave_idx_type n, T y)
 {
   octave_idx_type j;
 
   if (x[0] < x[n-1])
     {
       // increasing x
@@ -117,17 +117,17 @@ lookup (const T *x, octave_idx_type n, T
             j0 = j;
         }
 #endif
     }
 }
 
 // n-dimensional linear interpolation
 
-template <class T>
+template <typename T>
 void
 lin_interpn (int n, const octave_idx_type *size, const octave_idx_type *scale,
              octave_idx_type Ni, T extrapval, const T **x,
              const T *v, const T **y, T *vi)
 {
   bool out = false;
   int bit;
 
@@ -176,17 +176,17 @@ lin_interpn (int n, const octave_idx_typ
                 }
 
               vi[m] += c * v[l];
             }
         }
     }
 }
 
-template <class T, class M>
+template <typename T, typename M>
 octave_value
 lin_interpn (int n, M *X, const M V, M *Y)
 {
   octave_value retval;
 
   M Vi = M (Y[0].dims ());
 
   OCTAVE_LOCAL_BUFFER (const T *, y, n);
diff --git a/libinterp/corefcn/bitfcns.cc b/libinterp/corefcn/bitfcns.cc
--- a/libinterp/corefcn/bitfcns.cc
+++ b/libinterp/corefcn/bitfcns.cc
@@ -108,17 +108,17 @@ bitopxx (const OP& op, const std::string
 
   return result;
 }
 
 // Trampoline function, instantiates the proper template above, with
 // reflective information hardwired. We can't hardwire this information
 // in Fbitxxx DEFUNs below, because at that moment, we still don't have
 // information about which integer types we need to instantiate.
-template<typename T>
+template <typename T>
 octave_value
 bitopx (const std::string& fname, const Array<T>& x, const Array<T>& y)
 {
   if (fname == "bitand")
     return bitopxx (std::bit_and<T>(), fname, x, y);
   if (fname == "bitor")
     return bitopxx (std::bit_or<T>(), fname, x, y);
 
diff --git a/libinterp/corefcn/bsxfun.cc b/libinterp/corefcn/bsxfun.cc
--- a/libinterp/corefcn/bsxfun.cc
+++ b/libinterp/corefcn/bsxfun.cc
@@ -90,37 +90,37 @@ bsxfun_builtin_lookup (const std::string
 }
 
 typedef octave_value (*bsxfun_handler) (const octave_value&,
                                         const octave_value&);
 
 // Static table of handlers.
 bsxfun_handler bsxfun_handler_table[bsxfun_num_builtin_ops][btyp_num_types];
 
-template <class NDA, NDA (bsxfun_op) (const NDA&, const NDA&)>
+template <typename NDA, NDA (bsxfun_op) (const NDA&, const NDA&)>
 static octave_value
 bsxfun_forward_op (const octave_value& x, const octave_value& y)
 {
   NDA xa = octave_value_extract<NDA> (x);
   NDA ya = octave_value_extract<NDA> (y);
   return octave_value (bsxfun_op (xa, ya));
 }
 
-template <class NDA, boolNDArray (bsxfun_rel) (const NDA&, const NDA&)>
+template <typename NDA, boolNDArray (bsxfun_rel) (const NDA&, const NDA&)>
 static octave_value
 bsxfun_forward_rel (const octave_value& x, const octave_value& y)
 {
   NDA xa = octave_value_extract<NDA> (x);
   NDA ya = octave_value_extract<NDA> (y);
   return octave_value (bsxfun_rel (xa, ya));
 }
 
 // pow() needs a special handler for reals
 // because of the potentially complex result.
-template <class NDA, class CNDA>
+template <typename NDA, typename CNDA>
 static octave_value
 do_bsxfun_real_pow (const octave_value& x, const octave_value& y)
 {
   NDA xa = octave_value_extract<NDA> (x);
   NDA ya = octave_value_extract<NDA> (y);
   if (! ya.all_integers () && xa.any_element_is_negative ())
     return octave_value (bsxfun_pow (CNDA (xa), ya));
   else
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -113,17 +113,17 @@ get_output_list (octave_idx_type count, 
     }
 
   return tmp;
 }
 
 // Templated function because the user can be stubborn enough to request
 // a cell array as an output even in these cases where the output fits
 // in an ordinary array
-template<typename BNDA, typename NDA>
+template <typename BNDA, typename NDA>
 static octave_value_list
 try_cellfun_internal_ops (const octave_value_list& args, int nargin)
 {
   octave_value_list retval;
 
   std::string name = args(0).string_value ();
 
   const Cell f_args = args(1).cell_value ();
@@ -1634,27 +1634,27 @@ do_num2cell_helper (const dim_vector& dv
 
   for (int i = 0; i < maxd; i++)
     if (sing[i])
       celldv(i) = 1;
     else
       arraydv(i) = 1;
 }
 
-template<class NDA>
+template <typename NDA>
 static inline typename NDA::element_type
 do_num2cell_elem (const NDA& array, octave_idx_type i)
 { return array(i); }
 
 static inline Cell
 do_num2cell_elem (const Cell& array, octave_idx_type i)
 { return Cell (array(i)); }
 
 
-template<class NDA>
+template <typename NDA>
 static Cell
 do_num2cell (const NDA& array, const Array<int>& dimv)
 {
   if (dimv.is_empty ())
     {
       Cell retval (array.dims ());
       octave_idx_type nel = array.numel ();
       for (octave_idx_type i = 0; i < nel; i++)
@@ -1856,17 +1856,17 @@ mat2cell_mismatch (const dim_vector& dv,
 
       if (s != r)
         error ("mat2cell: mismatch on %d-th dimension (%d != %d)", i+1, r, s);
     }
 
   return false;
 }
 
-template<class container>
+template <typename container>
 static void
 prepare_idx (container *idx, int idim, int nd,
              const Array<octave_idx_type>* d)
 {
   octave_idx_type nidx = idim < nd ? d[idim].numel () : 1;
   if (nidx == 1)
     idx[0] = idx_vector::colon;
   else
@@ -1879,17 +1879,17 @@ prepare_idx (container *idx, int idim, i
           l = u;
         }
     }
 }
 
 // 2D specialization, works for Array, Sparse and octave_map.
 // Uses 1D or 2D indexing.
 
-template <class Array2D>
+template <typename Array2D>
 static Cell
 do_mat2cell_2d (const Array2D& a, const Array<octave_idx_type> *d, int nd)
 {
   NoAlias<Cell> retval;
   assert (nd == 1 || nd == 2);
   assert (a.ndims () == 2);
 
   if (mat2cell_mismatch (a.dims (), d, nd))
@@ -1936,17 +1936,17 @@ do_mat2cell_2d (const Array2D& a, const 
     }
 
   return retval;
 }
 
 // Nd case. Works for Arrays and octave_map.
 // Uses Nd indexing.
 
-template <class ArrayND>
+template <typename ArrayND>
 Cell
 do_mat2cell_nd (const ArrayND& a, const Array<octave_idx_type> *d, int nd)
 {
   NoAlias<Cell> retval;
   assert (nd >= 1);
 
   if (mat2cell_mismatch (a.dims (), d, nd))
     return retval;
@@ -1988,17 +1988,17 @@ do_mat2cell_nd (const ArrayND& a, const 
 
       rdv.increment_index (ridx);
     }
 
   return retval;
 }
 
 // Dispatcher.
-template <class ArrayND>
+template <typename ArrayND>
 Cell
 do_mat2cell (const ArrayND& a, const Array<octave_idx_type> *d, int nd)
 {
   if (a.ndims () == 2 && nd <= 2)
     return do_mat2cell_2d (a, d, nd);
   else
     return do_mat2cell_nd (a, d, nd);
 }
@@ -2185,17 +2185,17 @@ mat2cell (reshape (1:16,4,4), [3,1], [3,
 %!test
 %! x = "abcdefghij";
 %! c = mat2cell (x, 1, [0,4,2,0,4,0]);
 %! empty1by0str = resize ("", 1, 0);
 %! assert (c, {empty1by0str,"abcd","ef",empty1by0str,"ghij",empty1by0str});
 */
 
 // FIXME: it would be nice to allow ranges being handled without a conversion.
-template <class NDA>
+template <typename NDA>
 static Cell
 do_cellslices_nda (const NDA& array,
                    const Array<octave_idx_type>& lb,
                    const Array<octave_idx_type>& ub,
                    int dim = -1)
 {
   octave_idx_type n = lb.numel ();
   Cell retval (1, n);
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -456,17 +456,17 @@ hypot (hypot (hypot (@var{x}, @var{y}), 
 %! assert (y, sparse ([0 1]));
 %!test
 %! y = hypot (sparse ([0 1]), sparse ([0 0]));
 %! assert (nnz (y), 1);
 %! assert (y, sparse ([0 1]));
 
 */
 
-template<typename T, typename ET>
+template <typename T, typename ET>
 void
 map_2_xlog2 (const Array<T>& x, Array<T>& f, Array<ET>& e)
 {
   f = Array<T>(x.dims ());
   e = Array<ET>(x.dims ());
   for (octave_idx_type i = 0; i < x.numel (); i++)
     {
       int exp;
@@ -1677,17 +1677,17 @@ all_scalar_1x1 (const octave_value_list&
   int n_args = args.length ();
   for (int i = 0; i < n_args; i++)
     if (args(i).numel () != 1)
       return false;
 
   return true;
 }
 
-template <class TYPE, class T>
+template <typename TYPE, typename T>
 static void
 single_type_concat (Array<T>& result,
                     const octave_value_list& args,
                     int dim)
 {
   int n_args = args.length ();
   if (! (equal_types<T, char>::value
          || equal_types<T, octave_value>::value)
@@ -1720,17 +1720,17 @@ single_type_concat (Array<T>& result,
 
           array_list[j] = octave_value_extract<TYPE> (args(j));
         }
 
       result = Array<T>::cat (dim, n_args, array_list);
     }
 }
 
-template <class TYPE, class T>
+template <typename TYPE, typename T>
 static void
 single_type_concat (Sparse<T>& result,
                     const octave_value_list& args,
                     int dim)
 {
   int n_args = args.length ();
   OCTAVE_LOCAL_BUFFER (Sparse<T>, sparse_list, n_args);
 
@@ -1740,28 +1740,28 @@ single_type_concat (Sparse<T>& result,
 
       sparse_list[j] = octave_value_extract<TYPE> (args(j));
     }
 
   result = Sparse<T>::cat (dim, n_args, sparse_list);
 }
 
 // Dispatcher.
-template<class TYPE>
+template <typename TYPE>
 static TYPE
 do_single_type_concat (const octave_value_list& args, int dim)
 {
   TYPE result;
 
   single_type_concat<TYPE, typename TYPE::element_type> (result, args, dim);
 
   return result;
 }
 
-template<class MAP>
+template <typename MAP>
 static void
 single_type_concat_map (octave_map& result,
                         const octave_value_list& args,
                         int dim)
 {
   int n_args = args.length ();
   OCTAVE_LOCAL_BUFFER (MAP, map_list, n_args);
 
@@ -4806,17 +4806,17 @@ matrix of the specified size.\n\
 If invoked with two or more scalar integer arguments, or a vector of integer\n\
 values, return an array with given dimensions.\n\
 @seealso{false}\n\
 @end deftypefn")
 {
   return fill_matrix (args, true, "true");
 }
 
-template <class MT>
+template <typename MT>
 octave_value
 identity_matrix (int nr, int nc)
 {
   octave_value retval;
 
   typename MT::element_type one (1);
 
   if (nr == 1 && nc == 1)
@@ -5020,17 +5020,17 @@ definitions are for compatibility with @
 %!assert (full (eye (2, 3,"single")), single ([1, 0, 0; 0, 1, 0]))
 
 %!assert (eye (3, "int8"), int8 ([1, 0, 0; 0, 1, 0; 0, 0, 1]))
 %!assert (eye (2, 3, "int8"), int8 ([1, 0, 0; 0, 1, 0]))
 
 %!error eye (1, 2, 3)
 */
 
-template <class MT>
+template <typename MT>
 static octave_value
 do_linspace (const octave_value& base, const octave_value& limit,
              octave_idx_type n)
 {
   typedef typename MT::column_vector_type CVT;
   typedef typename MT::element_type T;
 
   octave_value retval;
@@ -6924,17 +6924,17 @@ the ratio K/M is small; otherwise, it ma
     {
       index_error ("nth_element: invalid N value %s. %s",
                    e.idx (), e.details ());
     }
 
   return retval;
 }
 
-template <class NDT>
+template <typename NDT>
 static NDT
 do_accumarray_sum (const idx_vector& idx, const NDT& vals,
                    octave_idx_type n = -1)
 {
   typedef typename NDT::element_type T;
   if (n < 0)
     n = idx.extent (0);
   else if (idx.extent (n) > n)
@@ -7009,17 +7009,17 @@ Undocumented internal function.\n\
     {
       index_error ("__accumarray_sum__: invalid IDX %s. %s",
                    e.idx (), e.details ());
     }
 
   return retval;
 }
 
-template <class NDT>
+template <typename NDT>
 static NDT
 do_accumarray_minmax (const idx_vector& idx, const NDT& vals,
                       octave_idx_type n, bool ismin,
                       const typename NDT::element_type& zero_val)
 {
   typedef typename NDT::element_type T;
   if (n < 0)
     n = idx.extent (0);
@@ -7139,17 +7139,17 @@ DEFUN (__accumarray_max__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __accumarray_max__ (@var{idx}, @var{vals}, @var{zero}, @var{n})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   return do_accumarray_minmax_fun (args, false);
 }
 
-template <class NDT>
+template <typename NDT>
 static NDT
 do_accumdim_sum (const idx_vector& idx, const NDT& vals,
                  int dim = -1, octave_idx_type n = -1)
 {
   typedef typename NDT::element_type T;
   if (n < 0)
     n = idx.extent (0);
   else if (idx.extent (n) > n)
@@ -7229,17 +7229,17 @@ Undocumented internal function.\n\
     {
       index_error ("__accumdim_sum__: invalid IDX %s. %s",
                    e.idx (), e.details ());
     }
 
   return retval;
 }
 
-template <class NDT>
+template <typename NDT>
 static NDT
 do_merge (const Array<bool>& mask,
           const NDT& tval, const NDT& fval)
 {
   typedef typename NDT::element_type T;
   dim_vector dv = mask.dims ();
   NDT retval (dv);
 
@@ -7400,17 +7400,17 @@ converted to logical.\n\
 
   return retval;
 }
 
 DEFALIAS (ifelse, merge);
 
 #undef MAKE_INT_BRANCH
 
-template <class SparseT>
+template <typename SparseT>
 static SparseT
 do_sparse_diff (const SparseT& array, octave_idx_type order,
                 int dim)
 {
   SparseT retval = array;
   if (dim == 1)
     {
       octave_idx_type k = retval.columns ();
@@ -7601,17 +7601,17 @@ an empty matrix is returned.\n\
 %!assert (isempty (diff (1)))
 
 %!error diff ()
 %!error diff (1, 2, 3, 4)
 %!error diff ("foo")
 %!error diff ([1, 2; 3, 4], -1)
 */
 
-template <class T>
+template <typename T>
 static Array<T>
 do_repelems (const Array<T>& src, const Array<octave_idx_type>& rep)
 {
   Array<T> retval;
 
   assert (rep.ndims () == 2 && rep.rows () == 2);
 
   octave_idx_type n = rep.columns ();
diff --git a/libinterp/corefcn/filter.cc b/libinterp/corefcn/filter.cc
--- a/libinterp/corefcn/filter.cc
+++ b/libinterp/corefcn/filter.cc
@@ -48,17 +48,17 @@ filter (MArray<Complex>&, MArray<Complex
 extern MArray<float>
 filter (MArray<float>&, MArray<float>&, MArray<float>&, int dim);
 
 extern MArray<FloatComplex>
 filter (MArray<FloatComplex>&, MArray<FloatComplex>&, MArray<FloatComplex>&,
         int dim);
 #endif
 
-template <class T>
+template <typename T>
 MArray<T>
 filter (MArray<T>& b, MArray<T>& a, MArray<T>& x, MArray<T>& si,
         int dim = 0)
 {
   MArray<T> y;
 
   octave_idx_type a_len  = a.numel ();
   octave_idx_type b_len  = b.numel ();
@@ -230,17 +230,17 @@ extern MArray<float>
 filter (MArray<float>&, MArray<float>&, MArray<float>&,
         MArray<float>&, int dim);
 
 extern MArray<FloatComplex>
 filter (MArray<FloatComplex>&, MArray<FloatComplex>&, MArray<FloatComplex>&,
         MArray<FloatComplex>&, int dim);
 #endif
 
-template <class T>
+template <typename T>
 MArray<T>
 filter (MArray<T>& b, MArray<T>& a, MArray<T>& x, int dim = -1)
 {
   dim_vector x_dims = x.dims ();
 
   if (dim < 0)
     dim = x_dims.first_non_singleton ();
   else if (dim > x_dims.length ())
diff --git a/libinterp/corefcn/gcd.cc b/libinterp/corefcn/gcd.cc
--- a/libinterp/corefcn/gcd.cc
+++ b/libinterp/corefcn/gcd.cc
@@ -91,17 +91,17 @@ simple_gcd (const std::complex<FP>& a, c
       divide (aa, bb, qq, rr);
       aa = bb;
       bb = rr;
     }
 
   return aa;
 }
 
-template <class T>
+template <typename T>
 static octave_int<T>
 simple_gcd (const octave_int<T>& a, const octave_int<T>& b)
 {
   T aa = a.abs ().value ();
   T bb = b.abs ().value ();
 
   while (bb != 0)
     {
@@ -191,17 +191,17 @@ extended_gcd (const std::complex<FP>& a,
   y = ly;
 
   if (swapped)
     std::swap (x, y);
 
   return aa;
 }
 
-template <class T>
+template <typename T>
 static octave_int<T>
 extended_gcd (const octave_int<T>& a, const octave_int<T>& b,
               octave_int<T>& x, octave_int<T>& y)
 {
   T aa = a.abs ().value ();
   T bb = b.abs ().value ();
   T xx, lx, yy, ly;
   xx = 0, lx = 1;
@@ -224,17 +224,17 @@ extended_gcd (const octave_int<T>& a, co
     }
 
   x = octave_int<T> (lx) * a.signum ();
   y = octave_int<T> (ly) * b.signum ();
 
   return aa;
 }
 
-template<class NDA>
+template <typename NDA>
 static octave_value
 do_simple_gcd (const octave_value& a, const octave_value& b)
 {
   typedef typename NDA::element_type T;
   octave_value retval;
 
   if (a.is_scalar_type () && b.is_scalar_type ())
     {
@@ -304,17 +304,17 @@ do_simple_gcd (const octave_value& a, co
     }
 
   if (btyp == btyp_float)
     retval = retval.float_array_value ();
 
   return retval;
 }
 
-template<class NDA>
+template <typename NDA>
 static octave_value
 do_extended_gcd (const octave_value& a, const octave_value& b,
                  octave_value& x, octave_value& y)
 {
   typedef typename NDA::element_type T;
   octave_value retval;
 
   if (a.is_scalar_type () && b.is_scalar_type ())
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -865,17 +865,17 @@ convert_cdata_2 (bool is_scaled, bool is
       octave_idx_type idx = static_cast<octave_idx_type> (x);
 
       av[i]       = cmapv[idx];
       av[i+lda]   = cmapv[idx+nc];
       av[i+2*lda] = cmapv[idx+2*nc];
     }
 }
 
-template <class T>
+template <typename T>
 void
 convert_cdata_1 (bool is_scaled, bool is_real, double clim_0, double clim_1,
                  const double *cmapv, const T *cv, octave_idx_type lda,
                  octave_idx_type nc, double *av)
 {
   for (octave_idx_type i = 0; i < lda; i++)
     convert_cdata_2 (is_scaled, is_real,
                      clim_0, clim_1, cmapv, cv[i], lda, nc, i, av);
@@ -961,17 +961,17 @@ convert_cdata (const base_properties& pr
   else
     error ("unsupported type for cdata (= %s)", cdata.type_name ().c_str ());
 
 #undef CONVERT_CDATA_1
 
   return octave_value (a);
 }
 
-template<class T>
+template <typename T>
 static void
 get_array_limits (const Array<T>& m, double& emin, double& emax,
                   double& eminp, double& emaxp)
 {
   const T *data = m.data ();
   octave_idx_type n = m.numel ();
 
   for (octave_idx_type i = 0; i < n; i++)
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -93,17 +93,17 @@ static std::string Vmakeinfo_program = "
 static bool Vsuppress_verbose_help_message = false;
 
 #include <map>
 
 typedef std::map<std::string, std::string> map_type;
 typedef map_type::value_type pair_type;
 typedef map_type::const_iterator map_iter;
 
-template<typename T, size_t z>
+template <typename T, size_t z>
 size_t
 size (T const (&)[z])
 {
   return z;
 }
 
 const static pair_type operators[] =
 {
diff --git a/libinterp/corefcn/kron.cc b/libinterp/corefcn/kron.cc
--- a/libinterp/corefcn/kron.cc
+++ b/libinterp/corefcn/kron.cc
@@ -43,17 +43,17 @@ along with Octave; see the file COPYING.
 
 #include "mx-inlines.cc"
 #include "quit.h"
 
 #include "defun.h"
 #include "error.h"
 #include "ovl.h"
 
-template <class R, class T>
+template <typename R, typename T>
 static MArray<T>
 kron (const MArray<R>& a, const MArray<T>& b)
 {
   assert (a.ndims () == 2);
   assert (b.ndims () == 2);
 
   octave_idx_type nra = a.rows ();
   octave_idx_type nrb = b.rows ();
@@ -70,17 +70,17 @@ kron (const MArray<R>& a, const MArray<T
           octave_quit ();
           mx_inline_mul (nrb, cv, a(ia, ja), b.data () + nrb*jb);
           cv += nrb;
         }
 
   return c;
 }
 
-template <class R, class T>
+template <typename R, typename T>
 static MArray<T>
 kron (const MDiagArray2<R>& a, const MArray<T>& b)
 {
   assert (b.ndims () == 2);
 
   octave_idx_type nra = a.rows ();
   octave_idx_type nrb = b.rows ();
   octave_idx_type dla = a.diag_length ();
@@ -95,17 +95,17 @@ kron (const MDiagArray2<R>& a, const MAr
         octave_quit ();
         mx_inline_mul (nrb, &c.xelem (ja*nrb, ja*ncb + jb), a.dgelem (ja),
                        b.data () + nrb*jb);
       }
 
   return c;
 }
 
-template <class T>
+template <typename T>
 static MSparse<T>
 kron (const MSparse<T>& A, const MSparse<T>& B)
 {
   octave_idx_type idx = 0;
   MSparse<T> C (A.rows () * B.rows (), A.columns () * B.columns (),
                 A.nnz () * B.nnz ());
 
   C.cidx (0) = 0;
@@ -145,17 +145,17 @@ kron (const PermMatrix& a, const PermMat
       octave_idx_type a_add = pa(i) * nb;
       for (octave_idx_type j = 0; j < nb; j++)
         res_perm.xelem (rescol++) = a_add + pb(j);
     }
 
   return PermMatrix (res_perm, true);
 }
 
-template <class MTA, class MTB>
+template <typename MTA, typename MTB>
 octave_value
 do_kron (const octave_value& a, const octave_value& b)
 {
   MTA am = octave_value_extract<MTA> (a);
   MTB bm = octave_value_extract<MTB> (b);
 
   return octave_value (kron (am, bm));
 }
diff --git a/libinterp/corefcn/lookup.cc b/libinterp/corefcn/lookup.cc
--- a/libinterp/corefcn/lookup.cc
+++ b/libinterp/corefcn/lookup.cc
@@ -78,17 +78,17 @@ static bool
 stri_comp_gt (const std::string& a, const std::string& b)
 {
   return std::lexicographical_compare (a.begin (), a.end (),
                                        b.begin (), b.end (),
                                        icmp_char_gt ());
 }
 #endif
 
-template <class T>
+template <typename T>
 inline sortmode
 get_sort_mode (const Array<T>& array,
                typename octave_sort<T>::compare_fcn_type desc_comp
                = octave_sort<T>::descending_compare)
 {
   octave_idx_type n = array.numel ();
   if (n > 1 && desc_comp (array (0), array (n-1)))
     return DESCENDING;
@@ -101,17 +101,17 @@ get_sort_mode (const Array<T>& array,
 // We'd need a dispatch on two arguments. Hmmm...
 
 #define INT_ARRAY_LOOKUP(TYPE) \
   (table.is_ ## TYPE ## _type () && y.is_ ## TYPE ## _type ()) \
     retval = do_numeric_lookup (table.TYPE ## _array_value (), \
                                 y.TYPE ## _array_value (), \
                                 left_inf, right_inf, \
                                 match_idx, match_bool);
-template <class ArrayT>
+template <typename ArrayT>
 static octave_value
 do_numeric_lookup (const ArrayT& array, const ArrayT& values,
                    bool left_inf, bool right_inf,
                    bool match_idx, bool match_bool)
 {
   octave_value retval;
 
   Array<octave_idx_type> idx = array.lookup (values);
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -247,17 +247,17 @@ read_mat5_binary_data (std::istream& is,
       break;
 
     case miMATRIX:
     default:
       break;
     }
 }
 
-template <class T>
+template <typename T>
 void
 read_mat5_integer_data (std::istream& is, T *m, octave_idx_type count,
                         bool swap, mat5_data_type type)
 {
 
 #define READ_INTEGER_DATA(TYPE, swap, data, size, len, stream)  \
   do \
     { \
@@ -1766,17 +1766,17 @@ write_mat5_array (std::ostream& os, cons
   }
   if (PAD (len) > len)
     {
       static char buf[9]="\x00\x00\x00\x00\x00\x00\x00\x00";
       os.write (buf, PAD (len) - len);
     }
 }
 
-template <class T>
+template <typename T>
 void
 write_mat5_integer_data (std::ostream& os, const T *m, int size,
                          octave_idx_type nel)
 {
   mat5_data_type mst;
   unsigned len;
 
   switch (size)
diff --git a/libinterp/corefcn/ls-oct-text.h b/libinterp/corefcn/ls-oct-text.h
--- a/libinterp/corefcn/ls-oct-text.h
+++ b/libinterp/corefcn/ls-oct-text.h
@@ -63,17 +63,17 @@ save_three_d (std::ostream& os, const oc
 
 // Match KEYWORD on stream IS, placing the associated value in VALUE,
 // returning TRUE if successful and FALSE otherwise.
 //
 // Input should look something like:
 //
 //  [%#][ \t]*keyword[ \t]*int-value.*\n
 
-template <class T>
+template <typename T>
 bool
 extract_keyword (std::istream& is, const char *keyword, T& value,
                  const bool next_only = false)
 {
   bool status = false;
   value = T ();
 
   char c;
@@ -110,33 +110,33 @@ extract_keyword (std::istream& is, const
             }
           else if (next_only)
             break;
         }
     }
   return status;
 }
 
-template <class T>
+template <typename T>
 bool
 extract_keyword (std::istream& is, const std::string& kw, T& value,
                  const bool next_only = false)
 {
   return extract_keyword (is, kw.c_str (), value, next_only);
 }
 
 // Match one of the elements in KEYWORDS on stream IS, placing the
 // matched keyword in KW and the associated value in VALUE,
 // returning TRUE if successful and FALSE otherwise.
 //
 // Input should look something like:
 //
 //  [%#][ \t]*keyword[ \t]*int-value.*\n
 
-template <class T>
+template <typename T>
 bool
 extract_keyword (std::istream& is, const string_vector& keywords,
                  std::string& kw, T& value, const bool next_only = false)
 {
   bool status = false;
   kw = "";
   value = 0;
 
diff --git a/libinterp/corefcn/lu.cc b/libinterp/corefcn/lu.cc
--- a/libinterp/corefcn/lu.cc
+++ b/libinterp/corefcn/lu.cc
@@ -34,28 +34,28 @@ along with Octave; see the file COPYING.
 #include "defun.h"
 #include "error.h"
 #include "errwarn.h"
 #include "ovl.h"
 #include "utils.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 
-template <class MT>
+template <typename MT>
 static octave_value
 get_lu_l (const base_lu<MT>& fact)
 {
   MT L = fact.L ();
   if (L.is_square ())
     return octave_value (L, MatrixType (MatrixType::Lower));
   else
     return L;
 }
 
-template <class MT>
+template <typename MT>
 static octave_value
 get_lu_u (const base_lu<MT>& fact)
 {
   MT U = fact.U ();
   if (U.is_square () && fact.regular ())
     return octave_value (U, MatrixType (MatrixType::Upper));
   else
     return U;
diff --git a/libinterp/corefcn/max.cc b/libinterp/corefcn/max.cc
--- a/libinterp/corefcn/max.cc
+++ b/libinterp/corefcn/max.cc
@@ -36,17 +36,17 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "errwarn.h"
 #include "ovl.h"
 
 #include "ov-cx-mat.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 
-template <class ArrayType>
+template <typename ArrayType>
 static octave_value_list
 do_minmax_red_op (const octave_value& arg,
                   int nargout, int dim, bool ismin)
 {
   octave_value_list retval (nargout > 1 ? 2 : 1);
   ArrayType array = octave_value_extract<ArrayType> (arg);
 
   if (nargout <= 1)
@@ -133,17 +133,17 @@ do_minmax_red_op<boolNDArray> (const oct
       retval = do_minmax_red_op<int8NDArray> (arg, nargout, dim, ismin);
 
       retval(0) = retval(0).bool_array_value ();
     }
 
   return retval;
 }
 
-template <class ArrayType>
+template <typename ArrayType>
 static octave_value
 do_minmax_bin_op (const octave_value& argx, const octave_value& argy,
                   bool ismin)
 {
   typedef typename ArrayType::element_type ScalarType;
 
   octave_value retval;
 
@@ -861,17 +861,17 @@ the first index of the maximum value(s).
 %!error max (1, 2, 3, 4)
 %!error <DIM must be a valid dimension> max ([1 2; 3 4], [], -3)
 %!warning <second argument is ignored> max ([1 2 3 4], 2, 2);
 %!error <wrong type argument 'cell'> max ({1 2 3 4})
 %!error <cannot compute max \(cell, scalar\)> max ({1, 2, 3}, 2)
 
 */
 
-template <class ArrayType>
+template <typename ArrayType>
 static octave_value_list
 do_cumminmax_red_op (const octave_value& arg,
                      int nargout, int dim, bool ismin)
 {
   octave_value_list retval (nargout > 1 ? 2 : 1);
   ArrayType array = octave_value_extract<ArrayType> (arg);
 
   if (nargout <= 1)
diff --git a/libinterp/corefcn/mgorth.cc b/libinterp/corefcn/mgorth.cc
--- a/libinterp/corefcn/mgorth.cc
+++ b/libinterp/corefcn/mgorth.cc
@@ -25,17 +25,17 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include "oct-norm.h"
 #include "defun.h"
 #include "error.h"
 #include "errwarn.h"
 
-template <class ColumnVector, class Matrix, class RowVector>
+template <typename ColumnVector, typename Matrix, typename RowVector>
 static void
 do_mgorth (ColumnVector& x, const Matrix& V, RowVector& h)
 {
   octave_idx_type Vc = V.columns ();
   h = RowVector (Vc + 1);
   for (octave_idx_type j = 0; j < Vc; j++)
     {
       ColumnVector Vcj = V.column (j);
diff --git a/libinterp/corefcn/oct-map.cc b/libinterp/corefcn/oct-map.cc
--- a/libinterp/corefcn/oct-map.cc
+++ b/libinterp/corefcn/oct-map.cc
@@ -618,17 +618,17 @@ void permute_to_correct_order1 (const oc
                                 octave_map& dest, Array<octave_idx_type>& perm)
 {
   if (src.nfields () == 0 && src.is_empty ())
     dest = octave_map (src.dims (), ref.keys ());
   else
     dest = src.orderfields (ref, perm);
 }
 
-template <class map>
+template <typename map>
 static void
 permute_to_correct_order (octave_idx_type n, octave_idx_type nf,
                           octave_idx_type idx, const map *map_list,
                           map *new_map_list)
 {
   new_map_list[idx] = map_list[idx];
 
   Array<octave_idx_type> perm (dim_vector (1, nf));
diff --git a/libinterp/corefcn/oct-map.h b/libinterp/corefcn/oct-map.h
--- a/libinterp/corefcn/oct-map.h
+++ b/libinterp/corefcn/oct-map.h
@@ -249,17 +249,17 @@ public:
 
 private:
 
   octave_fields xkeys;
   std::vector<octave_value> xvals;
 
 };
 
-template<>
+template <>
 inline octave_scalar_map
 octave_value_extract<octave_scalar_map> (const octave_value& v)
 { return v.scalar_map_value (); }
 
 class OCTINTERP_API
 octave_map
 {
 public:
@@ -464,13 +464,13 @@ private:
   void extract_scalar (octave_scalar_map& dest,
                        octave_idx_type index) const;
   static void do_cat (int dim, octave_idx_type n,
                       const octave_scalar_map *map_list, octave_map& retval);
   static void do_cat (int dim, octave_idx_type n,
                       const octave_map *map_list, octave_map& retval);
 };
 
-template<>
+template <>
 inline octave_map octave_value_extract<octave_map> (const octave_value& v)
 { return v.map_value (); }
 
 #endif
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -1104,17 +1104,17 @@ octave_base_stream::skipl (off_t num, bo
         cnt = -1;
     }
 
   return cnt;
 }
 
 #define OCTAVE_SCAN(is, fmt, arg) octave_scan (is, fmt, arg)
 
-template <class T>
+template <typename T>
 std::istream&
 octave_scan_1 (std::istream& is, const scanf_format_elt& fmt, T* valptr)
 {
   T& ref = *valptr;
 
   switch (fmt.type)
     {
     case 'o':
@@ -1176,17 +1176,17 @@ octave_scan_1 (std::istream& is, const s
     default:
       is >> ref;
       break;
     }
 
   return is;
 }
 
-template <class T>
+template <typename T>
 std::istream&
 octave_scan (std::istream& is, const scanf_format_elt& fmt, T* valptr)
 {
   if (fmt.width)
     {
       // Limit input to fmt.width characters by reading into a
       // temporary stringstream buffer.
       std::string tmp;
@@ -1202,25 +1202,25 @@ octave_scan (std::istream& is, const sca
     octave_scan_1 (is, fmt, valptr);
 
   return is;
 }
 
 // Note that this specialization is only used for reading characters, not
 // character strings. See BEGIN_S_CONVERSION for details.
 
-template<>
+template <>
 std::istream&
 octave_scan<> (std::istream& is, const scanf_format_elt& /* fmt */,
                char* valptr)
 {
   return is >> valptr;
 }
 
-template<>
+template <>
 std::istream&
 octave_scan<> (std::istream& is, const scanf_format_elt& fmt, double* valptr)
 {
   double& ref = *valptr;
 
   switch (fmt.type)
     {
     case 'e':
@@ -1244,17 +1244,17 @@ octave_scan<> (std::istream& is, const s
     default:
       panic_impossible ();
       break;
     }
 
   return is;
 }
 
-template <class T>
+template <typename T>
 void
 do_scanf_conv (std::istream& is, const scanf_format_elt& fmt,
                T valptr, Matrix& mval, double *data, octave_idx_type& idx,
                octave_idx_type& conversion_count, octave_idx_type nr,
                octave_idx_type max_size, bool discard)
 {
   OCTAVE_SCAN (is, fmt, valptr);
 
@@ -2347,17 +2347,17 @@ printf_value_cache::int_value (void)
   else
     curr_state = conversion_error;
 
   return retval;
 }
 
 // Ugh again and again.
 
-template <class T>
+template <typename T>
 int
 do_printf_conv (std::ostream& os, const char *fmt, int nsa, int sa_1,
                 int sa_2, T arg, const std::string& who)
 {
   int retval = 0;
 
   switch (nsa)
     {
@@ -3088,17 +3088,17 @@ octave_stream::is_open (void) const
 
 void
 octave_stream::close (void)
 {
   if (stream_ok ())
     rep->close ();
 }
 
-template <class SRC_T, class DST_T>
+template <typename SRC_T, typename DST_T>
 static octave_value
 convert_and_copy (std::list<void *>& input_buf_list,
                   octave_idx_type input_buf_elts,
                   octave_idx_type elts_read,
                   octave_idx_type nr, octave_idx_type nc, bool swap,
                   bool do_float_fmt_conv, bool do_NA_conv,
                   oct_mach_info::float_format from_flt_fmt)
 {
@@ -3494,29 +3494,29 @@ octave_stream::write (const octave_value
         error ("fwrite: write error");
       else
         retval = status;
     }
 
   return retval;
 }
 
-template <class T, class V>
+template <typename T, typename V>
 static void
 convert_chars (const void *data, void *conv_data, octave_idx_type n_elts)
 {
   const T *tt_data = static_cast<const T *> (data);
 
   V *vt_data = static_cast<V *> (conv_data);
 
   for (octave_idx_type i = 0; i < n_elts; i++)
     vt_data[i] = tt_data[i];
 }
 
-template <class T, class V>
+template <typename T, typename V>
 static void
 convert_ints (const T *data, void *conv_data, octave_idx_type n_elts,
               bool swap)
 {
   typedef typename V::val_type val_type;
 
   val_type *vt_data = static_cast<val_type *> (conv_data);
 
@@ -3527,31 +3527,31 @@ convert_ints (const T *data, void *conv_
 
       vt_data[i] = val.value ();
 
       if (swap)
         swap_bytes<sizeof (val_type)> (&vt_data[i]);
     }
 }
 
-template <class T>
+template <typename T>
 class ultimate_element_type
 {
 public:
   typedef T type;
 };
 
-template <class T>
+template <typename T>
 class ultimate_element_type<octave_int<T> >
 {
 public:
   typedef T type;
 };
 
-template <class T>
+template <typename T>
 static bool
 convert_data (const T *data, void *conv_data, octave_idx_type n_elts,
               oct_data_conv::data_type output_type,
               oct_mach_info::float_format flt_fmt)
 {
   bool retval = true;
 
   bool swap
@@ -3705,17 +3705,17 @@ octave_stream::skip_bytes (size_t skip)
     seek (skip, SEEK_CUR);
 
   if (os)
     status = true;
 
   return status;
 }
 
-template <class T>
+template <typename T>
 octave_idx_type
 octave_stream::write (const Array<T>& data, octave_idx_type block_size,
                       oct_data_conv::data_type output_type,
                       octave_idx_type skip,
                       oct_mach_info::float_format flt_fmt)
 {
   bool swap = ((oct_mach_info::words_big_endian ()
                 && flt_fmt == oct_mach_info::flt_fmt_ieee_little_endian)
diff --git a/libinterp/corefcn/oct-stream.h b/libinterp/corefcn/oct-stream.h
--- a/libinterp/corefcn/oct-stream.h
+++ b/libinterp/corefcn/oct-stream.h
@@ -559,17 +559,17 @@ public:
                          oct_data_conv::data_type output_type,
                          octave_idx_type skip,
                          oct_mach_info::float_format flt_fmt);
 
   bool write_bytes (const void *data, size_t n_elts);
 
   bool skip_bytes (size_t n_elts);
 
-  template <class T>
+  template <typename T>
   octave_idx_type write (const Array<T>& data, octave_idx_type block_size,
                          oct_data_conv::data_type output_type,
                          octave_idx_type skip,
                          oct_mach_info::float_format flt_fmt);
 
   octave_value scanf (const std::string& fmt, const Array<double>& size,
                       octave_idx_type& count, const std::string& who /* = "scanf" */);
 
diff --git a/libinterp/corefcn/octave-link.h b/libinterp/corefcn/octave-link.h
--- a/libinterp/corefcn/octave-link.h
+++ b/libinterp/corefcn/octave-link.h
@@ -94,31 +94,31 @@ public:
     bool retval = false;
 
     if (instance_ok ())
       retval = instance->do_exit (status);
 
     return retval;
   }
 
-  template <class T>
+  template <typename T>
   static void post_event (T *obj, void (T::*method) (void))
   {
     if (enabled ())
       instance->do_post_event (obj, method);
   }
 
-  template <class T, class A>
+  template <typename T, typename A>
   static void post_event (T *obj, void (T::*method) (A), A arg)
   {
     if (enabled ())
       instance->do_post_event (obj, method, arg);
   }
 
-  template <class T, class A>
+  template <typename T, typename A>
   static void post_event (T *obj, void (T::*method) (const A&), const A& arg)
   {
     if (enabled ())
       instance->do_post_event (obj, method, arg);
   }
 
   static void entered_readline_hook (void)
   {
@@ -370,29 +370,29 @@ protected:
 
   bool debugging;
   bool link_enabled;
 
   void do_generate_events (void);
   void do_process_events (void);
   void do_discard_events (void);
 
-  template <class T>
+  template <typename T>
   void do_post_event (T *obj, void (T::*method) (void))
   {
     gui_event_queue.add_method (obj, method);
   }
 
-  template <class T, class A>
+  template <typename T, typename A>
   void do_post_event (T *obj, void (T::*method) (A), A arg)
   {
     gui_event_queue.add_method (obj, method, arg);
   }
 
-  template <class T, class A>
+  template <typename T, typename A>
   void do_post_event (T *obj, void (T::*method) (const A&), const A& arg)
   {
     gui_event_queue.add_method (obj, method, arg);
   }
 
   void do_entered_readline_hook (void) { }
   void do_finished_readline_hook (void) { }
 
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -1698,17 +1698,17 @@ pr_col_num_header (std::ostream& os, oct
       else
         os << " Columns " << col + 1 << " through " << lim << ":\n";
 
       if (! Vcompact_format)
         os << "\n";
     }
 }
 
-template <class T>
+template <typename T>
 /* static */ inline void
 pr_plus_format (std::ostream& os, const T& val)
 {
   if (val > T (0))
     os << plus_format_chars[0];
   else if (val < T (0))
     os << plus_format_chars[1];
   else
@@ -2965,17 +2965,17 @@ octave_print_internal (std::ostream& os,
             os << "\n";
 
           if (i < m)
             increment_index (ra_idx, dims, 2);
         }
     }
 }
 
-template <class T>
+template <typename T>
 class
 octave_print_conv
 {
 public:
   typedef T print_conv_type;
 };
 
 #define PRINT_CONV(T1, T2) \
@@ -2987,17 +2987,17 @@ public:
     typedef T2 print_conv_type; \
   }
 
 PRINT_CONV (octave_int8, octave_int16);
 PRINT_CONV (octave_uint8, octave_uint16);
 
 #undef PRINT_CONV
 
-template <class T>
+template <typename T>
 /* static */ inline void
 pr_int (std::ostream& os, const T& d, int fw = 0)
 {
   size_t sz = d.byte_size ();
   const unsigned char * tmpi = d.iptr ();
 
   // Unless explicitly asked for, always print in big-endian
   // format for hex and bit formats.
@@ -3056,17 +3056,17 @@ pr_int (std::ostream& os, const T& d, in
 }
 
 // FIXME: all this mess with abs is an attempt to avoid seeing
 //
 //   warning: comparison of unsigned expression < 0 is always false
 //
 // from GCC.  Isn't there a better way?
 
-template <class T>
+template <typename T>
 /* static */ inline T
 abs (T x)
 {
   return x < 0 ? -x : x;
 }
 
 #define INSTANTIATE_ABS(T) \
   template /* static */ T abs (T)
@@ -3110,17 +3110,17 @@ template void
 pr_int (std::ostream&, const octave_uint16&, int);
 
 template void
 pr_int (std::ostream&, const octave_uint32&, int);
 
 template void
 pr_int (std::ostream&, const octave_uint64&, int);
 
-template <class T>
+template <typename T>
 void
 octave_print_internal_template (std::ostream& os, const octave_int<T>& val,
                                 bool)
 {
   if (plus_format)
     {
       pr_plus_format (os, val);
     }
@@ -3144,17 +3144,17 @@ PRINT_INT_SCALAR_INTERNAL (int8_t)
 PRINT_INT_SCALAR_INTERNAL (uint8_t)
 PRINT_INT_SCALAR_INTERNAL (int16_t)
 PRINT_INT_SCALAR_INTERNAL (uint16_t)
 PRINT_INT_SCALAR_INTERNAL (int32_t)
 PRINT_INT_SCALAR_INTERNAL (uint32_t)
 PRINT_INT_SCALAR_INTERNAL (int64_t)
 PRINT_INT_SCALAR_INTERNAL (uint64_t)
 
-template <class T>
+template <typename T>
 /* static */ inline void
 octave_print_internal_template (std::ostream& os, const intNDArray<T>& nda,
                                 bool pr_as_read_syntax, int extra_indent)
 {
   // FIXME: this mostly duplicates the code in the print_nd_array<>
   // function. Can fix this with std::is_same from C++11.
 
   if (nda.is_empty ())
diff --git a/libinterp/corefcn/profiler.h b/libinterp/corefcn/profiler.h
--- a/libinterp/corefcn/profiler.h
+++ b/libinterp/corefcn/profiler.h
@@ -35,17 +35,17 @@ class octave_value;
 class
 OCTINTERP_API
 profile_data_accumulator
 {
 public:
 
   // This is a utility class that can be used to call the enter/exit
   // functions in a manner protected from stack unwinding.
-  template<class T> class enter
+  template <typename T> class enter
   {
   private:
 
     profile_data_accumulator& acc;
     std::string fcn;
     bool is_active;
 
   public:
diff --git a/libinterp/corefcn/schur.cc b/libinterp/corefcn/schur.cc
--- a/libinterp/corefcn/schur.cc
+++ b/libinterp/corefcn/schur.cc
@@ -32,17 +32,17 @@ along with Octave; see the file COPYING.
 #include "floatSCHUR.h"
 
 #include "defun.h"
 #include "error.h"
 #include "errwarn.h"
 #include "ovl.h"
 #include "utils.h"
 
-template <class Matrix>
+template <typename Matrix>
 static octave_value
 mark_upper_triangular (const Matrix& a)
 {
   octave_value retval = a;
 
   octave_idx_type n = a.rows ();
   assert (a.columns () == n);
 
diff --git a/libinterp/corefcn/sparse-xdiv.cc b/libinterp/corefcn/sparse-xdiv.cc
--- a/libinterp/corefcn/sparse-xdiv.cc
+++ b/libinterp/corefcn/sparse-xdiv.cc
@@ -42,17 +42,17 @@ along with Octave; see the file COPYING.
 #include "sparse-xdiv.h"
 
 static void
 solve_singularity_warning (double rcond)
 {
   warn_singular_matrix (rcond);
 }
 
-template <class T1, class T2>
+template <typename T1, typename T2>
 bool
 mx_leftdiv_conform (const T1& a, const T2& b)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type b_nr = b.rows ();
 
   if (a_nr != b_nr)
     {
@@ -76,17 +76,17 @@ INSTANTIATE_MX_LEFTDIV_CONFORM (SparseMa
 INSTANTIATE_MX_LEFTDIV_CONFORM (SparseMatrix, ComplexMatrix);
 INSTANTIATE_MX_LEFTDIV_CONFORM (SparseComplexMatrix, Matrix);
 INSTANTIATE_MX_LEFTDIV_CONFORM (SparseComplexMatrix, ComplexMatrix);
 INSTANTIATE_MX_LEFTDIV_CONFORM (DiagMatrix, SparseMatrix);
 INSTANTIATE_MX_LEFTDIV_CONFORM (DiagMatrix, SparseComplexMatrix);
 INSTANTIATE_MX_LEFTDIV_CONFORM (ComplexDiagMatrix, SparseMatrix);
 INSTANTIATE_MX_LEFTDIV_CONFORM (ComplexDiagMatrix, SparseComplexMatrix);
 
-template <class T1, class T2>
+template <typename T1, typename T2>
 bool
 mx_div_conform (const T1& a, const T2& b)
 {
   octave_idx_type a_nc = a.cols ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nc)
     {
diff --git a/libinterp/corefcn/sparse-xpow.cc b/libinterp/corefcn/sparse-xpow.cc
--- a/libinterp/corefcn/sparse-xpow.cc
+++ b/libinterp/corefcn/sparse-xpow.cc
@@ -223,17 +223,17 @@ xpow (const SparseComplexMatrix& a, doub
 // library...
 
 // Handle special case of scalar-sparse-matrix .^ sparse-matrix.
 // Forwarding to the scalar elem_xpow function and then converting the
 // result back to a sparse matrix is a bit wasteful but it does not
 // seem worth the effort to optimize -- how often does this case come up
 // in practice?
 
-template <class S, class SM>
+template <typename S, typename SM>
 inline octave_value
 scalar_xpow (const S& a, const SM& b)
 {
   octave_value val = elem_xpow (a, b);
 
   if (val.is_complex_type ())
     return SparseComplexMatrix (val.complex_matrix_value ());
   else
diff --git a/libinterp/corefcn/sqrtm.cc b/libinterp/corefcn/sqrtm.cc
--- a/libinterp/corefcn/sqrtm.cc
+++ b/libinterp/corefcn/sqrtm.cc
@@ -34,17 +34,17 @@ along with Octave; see the file COPYING.
 #include "oct-norm.h"
 
 #include "defun.h"
 #include "error.h"
 #include "errwarn.h"
 #include "utils.h"
 #include "xnorm.h"
 
-template <class Matrix>
+template <typename Matrix>
 static void
 sqrtm_utri_inplace (Matrix& T)
 {
   typedef typename Matrix::element_type element_type;
 
   const element_type zero = element_type ();
 
   bool singular = false;
@@ -83,17 +83,17 @@ sqrtm_utri_inplace (Matrix& T)
         }
     }
 
   if (singular)
     warning_with_id ("Octave:sqrtm:SingularMatrix",
                      "sqrtm: matrix is singular, may not have a square root");
 }
 
-template <class Matrix, class ComplexMatrix, class ComplexSCHUR>
+template <typename Matrix, typename ComplexMatrix, typename ComplexSCHUR>
 static octave_value
 do_sqrtm (const octave_value& arg)
 {
 
   octave_value retval;
 
   MatrixType mt = arg.matrix_type ();
 
diff --git a/libinterp/corefcn/symtab.h b/libinterp/corefcn/symtab.h
--- a/libinterp/corefcn/symtab.h
+++ b/libinterp/corefcn/symtab.h
@@ -845,17 +845,17 @@ public:
         function_on_path = f;
       }
 
       void install_built_in_function (const octave_value& f)
       {
         built_in_function = f;
       }
 
-      template <class T>
+      template <typename T>
       void
       clear_map (std::map<T, octave_value>& map, bool force = false)
       {
         typename std::map<T, octave_value>::iterator p = map.begin ();
 
         while (p != map.end ())
           {
             if (force || ! p->second.islocked ())
diff --git a/libinterp/corefcn/tril.cc b/libinterp/corefcn/tril.cc
--- a/libinterp/corefcn/tril.cc
+++ b/libinterp/corefcn/tril.cc
@@ -33,17 +33,17 @@ along with Octave; see the file COPYING.
 #include "ov.h"
 #include "Cell.h"
 
 #include "defun.h"
 #include "error.h"
 #include "ovl.h"
 
 // The bulk of the work.
-template <class T>
+template <typename T>
 static Array<T>
 do_tril (const Array<T>& a, octave_idx_type k, bool pack)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.columns ();
   const T *avec = a.fortran_vec ();
   octave_idx_type zero = 0;
 
@@ -75,17 +75,17 @@ do_tril (const Array<T>& a, octave_idx_t
           avec += nr;
           rvec += nr;
         }
 
       return r;
     }
 }
 
-template <class T>
+template <typename T>
 static Array<T>
 do_triu (const Array<T>& a, octave_idx_type k, bool pack)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.columns ();
   const T *avec = a.fortran_vec ();
   octave_idx_type zero = 0;
 
@@ -121,17 +121,17 @@ do_triu (const Array<T>& a, octave_idx_t
 
       return r;
     }
 }
 
 // These two are by David Bateman.
 // FIXME: optimizations possible. "pack" support missing.
 
-template <class T>
+template <typename T>
 static Sparse<T>
 do_tril (const Sparse<T>& a, octave_idx_type k, bool pack)
 {
   if (pack) // FIXME
     error ("tril: \"pack\" not implemented for sparse matrices");
 
   Sparse<T> m = a;
   octave_idx_type nc = m.cols ();
@@ -141,17 +141,17 @@ do_tril (const Sparse<T>& a, octave_idx_
       if (m.ridx (i) < j-k)
         m.data(i) = 0.;
 
   m.maybe_compress (true);
 
   return m;
 }
 
-template <class T>
+template <typename T>
 static Sparse<T>
 do_triu (const Sparse<T>& a, octave_idx_type k, bool pack)
 {
   if (pack) // FIXME
     error ("triu: \"pack\" not implemented for sparse matrices");
 
   Sparse<T> m = a;
   octave_idx_type nc = m.cols ();
@@ -161,24 +161,24 @@ do_triu (const Sparse<T>& a, octave_idx_
       if (m.ridx (i) > j-k)
         m.data(i) = 0.;
 
   m.maybe_compress (true);
   return m;
 }
 
 // Convenience dispatchers.
-template <class T>
+template <typename T>
 static Array<T>
 do_trilu (const Array<T>& a, octave_idx_type k, bool lower, bool pack)
 {
   return lower ? do_tril (a, k, pack) : do_triu (a, k, pack);
 }
 
-template <class T>
+template <typename T>
 static Sparse<T>
 do_trilu (const Sparse<T>& a, octave_idx_type k, bool lower, bool pack)
 {
   return lower ? do_tril (a, k, pack) : do_triu (a, k, pack);
 }
 
 static octave_value
 do_trilu (const std::string& name,
diff --git a/libinterp/corefcn/typecast.cc b/libinterp/corefcn/typecast.cc
--- a/libinterp/corefcn/typecast.cc
+++ b/libinterp/corefcn/typecast.cc
@@ -41,17 +41,17 @@ get_vec_dims (const dim_vector& old_dims
   if (old_dims.length () == 2 && old_dims(0) == 1)
     return dim_vector (1, n);
   else if (old_dims.length () == 2 && old_dims(0) == 0 && old_dims(1) == 0)
     return dim_vector ();
   else
     return dim_vector (n, 1);
 }
 
-template <class ArrayType>
+template <typename ArrayType>
 static void
 get_data_and_bytesize (const ArrayType& array,
                        const void *& data,
                        octave_idx_type& byte_size,
                        dim_vector& old_dims,
                        unwind_protect& frame)
 {
   // The array given may be a temporary, constructed from a scalar or sparse
@@ -59,17 +59,17 @@ get_data_and_bytesize (const ArrayType& 
   frame.add_delete (new ArrayType (array));
 
   data = reinterpret_cast<const void *> (array.data ());
   byte_size = array.byte_size ();
 
   old_dims = array.dims ();
 }
 
-template <class ArrayType>
+template <typename ArrayType>
 static ArrayType
 reinterpret_copy (const void *data, octave_idx_type byte_size,
                   const dim_vector& old_dims)
 {
   typedef typename ArrayType::element_type T;
   octave_idx_type n = byte_size / sizeof (T);
 
   if (n * static_cast<int> (sizeof (T)) != byte_size)
@@ -251,17 +251,17 @@ typecast (@var{x}, \"uint8\")\n\
     retval = reinterpret_copy<ComplexNDArray> (data, byte_size, old_dims);
 
   if (retval.is_undefined ())
     error ("typecast: cannot convert to %s class", numclass.c_str ());
 
   return retval;
 }
 
-template <class ArrayType>
+template <typename ArrayType>
 ArrayType
 do_bitpack (const boolNDArray& bitp)
 {
   typedef typename ArrayType::element_type T;
   octave_idx_type n
     = bitp.numel () / (sizeof (T) * std::numeric_limits<unsigned char>::digits);
 
   if (n * static_cast<int> (sizeof (T)) * std::numeric_limits<unsigned char>::digits != bitp.numel ())
@@ -371,17 +371,17 @@ column vector.\n\
     retval = do_bitpack<ComplexNDArray> (bitp);
 
   if (retval.is_undefined ())
     error ("bitpack: cannot pack to %s class", numclass.c_str ());
 
   return retval;
 }
 
-template <class ArrayType>
+template <typename ArrayType>
 boolNDArray
 do_bitunpack (const ArrayType& array)
 {
   typedef typename ArrayType::element_type T;
   octave_idx_type n = array.numel () * sizeof (T)
                       * std::numeric_limits<unsigned char>::digits;
 
   boolNDArray retval (get_vec_dims (array.dims (), n));
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -729,17 +729,17 @@ wants_local_change (const octave_value_l
         }
       else
         error_with_cfn ("second argument must be \"local\"");
     }
 
   return retval;
 }
 
-template <class T>
+template <typename T>
 bool try_local_protect (T& var)
 {
   octave_user_code *curr_usr_code = octave_call_stack::caller_user_code ();
   octave_user_function *curr_usr_fcn = 0;
   if (curr_usr_code && curr_usr_code->is_user_function ())
     curr_usr_fcn = dynamic_cast<octave_user_function *> (curr_usr_code);
 
   if (curr_usr_fcn && curr_usr_fcn->local_protect (var))
diff --git a/libinterp/corefcn/xdiv.cc b/libinterp/corefcn/xdiv.cc
--- a/libinterp/corefcn/xdiv.cc
+++ b/libinterp/corefcn/xdiv.cc
@@ -57,17 +57,17 @@ result_ok (octave_idx_type info)
 }
 
 static void
 solve_singularity_warning (double rcond)
 {
   warn_singular_matrix (rcond);
 }
 
-template <class T1, class T2>
+template <typename T1, typename T2>
 bool
 mx_leftdiv_conform (const T1& a, const T2& b, blas_trans_type blas_trans)
 {
   octave_idx_type a_nr = blas_trans == blas_no_trans ? a.rows () : a.cols ();
   octave_idx_type b_nr = b.rows ();
 
   if (a_nr != b_nr)
     {
@@ -84,17 +84,17 @@ mx_leftdiv_conform (const T1& a, const T
 #define INSTANTIATE_MX_LEFTDIV_CONFORM(T1, T2) \
   template bool mx_leftdiv_conform (const T1&, const T2&, blas_trans_type)
 
 INSTANTIATE_MX_LEFTDIV_CONFORM (Matrix, Matrix);
 INSTANTIATE_MX_LEFTDIV_CONFORM (Matrix, ComplexMatrix);
 INSTANTIATE_MX_LEFTDIV_CONFORM (ComplexMatrix, Matrix);
 INSTANTIATE_MX_LEFTDIV_CONFORM (ComplexMatrix, ComplexMatrix);
 
-template <class T1, class T2>
+template <typename T1, typename T2>
 bool
 mx_div_conform (const T1& a, const T2& b)
 {
   octave_idx_type a_nc = a.cols ();
   octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nc)
     {
@@ -698,17 +698,17 @@ xleftdiv (const FloatComplexMatrix& a, c
 
   octave_idx_type info;
   float rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
 }
 
 // Diagonal matrix division.
 
-template <class MT, class DMT>
+template <typename MT, typename DMT>
 MT
 mdm_div_impl (const MT& a, const DMT& d)
 {
   if (! mx_div_conform (a, d))
     return MT ();
 
   octave_idx_type m = a.rows ();
   octave_idx_type n = d.rows ();
@@ -781,17 +781,17 @@ FloatComplexMatrix
 xdiv (const FloatComplexMatrix& a, const FloatDiagMatrix& b)
 { return mdm_div_impl (a, b); }
 
 // -*- 3 -*-
 FloatComplexMatrix
 xdiv (const FloatComplexMatrix& a, const FloatComplexDiagMatrix& b)
 { return mdm_div_impl (a, b); }
 
-template <class MT, class DMT>
+template <typename MT, typename DMT>
 MT
 dmm_leftdiv_impl (const DMT& d, const MT& a)
 {
   if (! mx_leftdiv_conform (d, a, blas_no_trans))
     return MT ();
 
   octave_idx_type m = d.cols ();
   octave_idx_type n = a.cols ();
@@ -861,17 +861,17 @@ xleftdiv (const FloatDiagMatrix& a, cons
 
 // -*- 3 -*-
 FloatComplexMatrix
 xleftdiv (const FloatComplexDiagMatrix& a, const FloatComplexMatrix& b)
 { return dmm_leftdiv_impl (a, b); }
 
 // Diagonal by diagonal matrix division.
 
-template <class MT, class DMT>
+template <typename MT, typename DMT>
 MT
 dmdm_div_impl (const MT& a, const DMT& d)
 {
   if (! mx_div_conform (a, d))
     return MT ();
 
   octave_idx_type m = a.rows ();
   octave_idx_type n = d.rows ();
@@ -936,17 +936,17 @@ FloatComplexDiagMatrix
 xdiv (const FloatComplexDiagMatrix& a, const FloatDiagMatrix& b)
 { return dmdm_div_impl (a, b); }
 
 // -*- 3 -*-
 FloatComplexDiagMatrix
 xdiv (const FloatComplexDiagMatrix& a, const FloatComplexDiagMatrix& b)
 { return dmdm_div_impl (a, b); }
 
-template <class MT, class DMT>
+template <typename MT, typename DMT>
 MT
 dmdm_leftdiv_impl (const DMT& d, const MT& a)
 {
   if (! mx_leftdiv_conform (d, a, blas_no_trans))
     return MT ();
 
   octave_idx_type m = d.cols ();
   octave_idx_type n = a.cols ();
diff --git a/libinterp/corefcn/zfstream.h b/libinterp/corefcn/zfstream.h
--- a/libinterp/corefcn/zfstream.h
+++ b/libinterp/corefcn/zfstream.h
@@ -443,17 +443,17 @@ private:
 };
 
 /**
  *  @brief  Gzipped file output stream manipulator class.
  *
  *  This class defines a two-argument manipulator for gzofstream. It is used
  *  as base for the setcompression(int,int) manipulator.
 */
-template<typename T1, typename T2>
+template <typename T1, typename T2>
 class gzomanip2
 {
 public:
   // Allows insertor to peek at internals
   template <typename Ta, typename Tb>
   friend gzofstream&
   operator<<(gzofstream&,
              const gzomanip2<Ta,Tb>&);
@@ -476,26 +476,26 @@ private:
 inline gzofstream&
 setcompression (gzofstream &gzs, int l, int s = Z_DEFAULT_STRATEGY)
 {
   (gzs.rdbuf ())->setcompression (l, s);
   return gzs;
 }
 
 // Manipulator constructor stores arguments
-template<typename T1, typename T2>
+template <typename T1, typename T2>
 inline
 gzomanip2<T1,T2>::gzomanip2 (gzofstream &(*f)(gzofstream &, T1, T2),
                              T1 v1,
                              T2 v2)
   : func(f), val1(v1), val2(v2)
 { }
 
 // Insertor applies underlying manipulator function to stream
-template<typename T1, typename T2>
+template <typename T1, typename T2>
 inline gzofstream&
 operator<<(gzofstream& s, const gzomanip2<T1,T2>& m)
 { return (*m.func)(s, m.val1, m.val2); }
 
 // Insert this onto stream to simplify setting of compression level
 inline gzomanip2<int,int>
 setcompression (int l, int s = Z_DEFAULT_STRATEGY)
 { return gzomanip2<int,int>(&setcompression, l, s); }
diff --git a/libinterp/dldfcn/__init_fltk__.cc b/libinterp/dldfcn/__init_fltk__.cc
--- a/libinterp/dldfcn/__init_fltk__.cc
+++ b/libinterp/dldfcn/__init_fltk__.cc
@@ -648,17 +648,17 @@ public:
             uimenu::properties& kprop = dynamic_cast<uimenu::properties&>
                                         (kgo.get_properties ());
             add_to_menu (kprop);
             update_position (kprop, ++count);
           }
       }
   }
 
-  template <class T_prop>
+  template <typename T_prop>
   void remove_from_menu (T_prop& prop)
   {
     Matrix kids;
     std::string type = prop.get_type ();
     kids = find_uimenu_children (prop);
     int len = kids.numel ();
 
     for (octave_idx_type ii = 0; ii < len; ii++)
diff --git a/libinterp/dldfcn/__magick_read__.cc b/libinterp/dldfcn/__magick_read__.cc
--- a/libinterp/dldfcn/__magick_read__.cc
+++ b/libinterp/dldfcn/__magick_read__.cc
@@ -204,17 +204,17 @@ read_maps (Magick::Image& img)
       amap(i)   = c.alpha ();
     }
   octave_value_list maps;
   maps(0) = cmap;
   maps(1) = amap;
   return maps;
 }
 
-template <class T>
+template <typename T>
 static octave_value_list
 read_indexed_images (const std::vector<Magick::Image>& imvec,
                      const Array<octave_idx_type>& frameidx,
                      const octave_idx_type& nargout,
                      const octave_scalar_map& options)
 {
   typedef typename T::element_type P;
 
@@ -299,17 +299,17 @@ read_indexed_images (const std::vector<M
 
   return retval;
 }
 
 // This function is highly repetitive, a bunch of for loops that are
 // very similar to account for different image types. They are different
 // enough that trying to reduce the copy and paste would decrease its
 // readability too much.
-template <class T>
+template <typename T>
 octave_value_list
 read_images (std::vector<Magick::Image>& imvec,
              const Array<octave_idx_type>& frameidx,
              const octave_idx_type& nargout,
              const octave_scalar_map& options)
 {
   typedef typename T::element_type P;
 
@@ -855,17 +855,17 @@ Use @code{imread} instead.\n\
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
 
 #ifdef HAVE_MAGICK
 
-template <class T>
+template <typename T>
 static uint32NDArray
 img_float2uint (const T& img)
 {
   typedef typename T::element_type P;
   uint32NDArray out (img.dims ());
 
   octave_uint32* out_fvec = out.fortran_vec ();
   const P*       img_fvec = img.fortran_vec ();
@@ -875,17 +875,17 @@ img_float2uint (const T& img)
   for (octave_idx_type idx = 0; idx < numel; idx++)
     out_fvec[idx] = img_fvec[idx] * max;
 
   return out;
 }
 
 // Gets the bitdepth to be used for an Octave class, i.e, returns 8 for
 // uint8, 16 for uint16, and 32 for uint32
-template <class T>
+template <typename T>
 static octave_idx_type
 bitdepth_from_class ()
 {
   typedef typename T::element_type P;
   const octave_idx_type bitdepth =
     sizeof (P) * std::numeric_limits<unsigned char>::digits;
   return bitdepth;
 }
@@ -916,17 +916,17 @@ init_enconde_image (const octave_idx_typ
 
     default:
       img.matte (false);
     }
 
   return img;
 }
 
-template <class T>
+template <typename T>
 static void
 encode_indexed_images (std::vector<Magick::Image>& imvec,
                        const T& img,
                        const Matrix& cmap)
 {
   typedef typename T::element_type P;
   const octave_idx_type nFrames   = img.ndims () < 4 ? 1 : img.dims ()(3);
   const octave_idx_type nRows     = img.rows ();
@@ -1032,17 +1032,17 @@ encode_bool_image (std::vector<Magick::I
       m_img.syncPixels ();
       // While we could not set it to Bilevel at the start, we can do it
       // here otherwise some coders won't save it as binary.
       m_img.type (Magick::BilevelType);
       imvec.push_back (m_img);
     }
 }
 
-template <class T>
+template <typename T>
 static void
 encode_uint_image (std::vector<Magick::Image>& imvec,
                    const T& img, const T& alpha)
 {
   typedef typename T::element_type P;
   const octave_idx_type channels = img.ndims () < 3 ? 1 : img.dims ()(2);
   const octave_idx_type nFrames  = img.ndims () < 4 ? 1 : img.dims ()(3);
   const octave_idx_type nRows    = img.rows ();
diff --git a/libinterp/dldfcn/chol.cc b/libinterp/dldfcn/chol.cc
--- a/libinterp/dldfcn/chol.cc
+++ b/libinterp/dldfcn/chol.cc
@@ -39,32 +39,32 @@ along with Octave; see the file COPYING.
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 #include "defun-dld.h"
 #include "error.h"
 #include "errwarn.h"
 #include "ovl.h"
 #include "utils.h"
 
-template <class CHOLT>
+template <typename CHOLT>
 static octave_value
 get_chol (const CHOLT& fact)
 {
   return octave_value (fact.chol_matrix());
 }
 
-template <class CHOLT>
+template <typename CHOLT>
 static octave_value
 get_chol_r (const CHOLT& fact)
 {
   return octave_value (fact.chol_matrix (),
                        MatrixType (MatrixType::Upper));
 }
 
-template <class CHOLT>
+template <typename CHOLT>
 static octave_value
 get_chol_l (const CHOLT& fact)
 {
   return octave_value (fact.chol_matrix ().transpose (),
                        MatrixType (MatrixType::Lower));
 }
 
 DEFUN_DLD (chol, args, nargout,
diff --git a/libinterp/dldfcn/qr.cc b/libinterp/dldfcn/qr.cc
--- a/libinterp/dldfcn/qr.cc
+++ b/libinterp/dldfcn/qr.cc
@@ -39,17 +39,17 @@ along with Octave; see the file COPYING.
 
 
 #include "defun-dld.h"
 #include "error.h"
 #include "errwarn.h"
 #include "ovl.h"
 #include "utils.h"
 
-template <class MT>
+template <typename MT>
 static octave_value
 get_qr_r (const base_qr<MT>& fact)
 {
   MT R = fact.R ();
   if (R.is_square () && fact.regular ())
     return octave_value (R, MatrixType (MatrixType::Upper));
   else
     return R;
diff --git a/libinterp/octave-value/ov-base-diag.cc b/libinterp/octave-value/ov-base-diag.cc
--- a/libinterp/octave-value/ov-base-diag.cc
+++ b/libinterp/octave-value/ov-base-diag.cc
@@ -36,17 +36,17 @@ along with Octave; see the file COPYING.
 #include "pr-output.h"
 #include "error.h"
 #include "errwarn.h"
 #include "oct-stream.h"
 #include "ops.h"
 
 #include "ls-oct-text.h"
 
-template <class DMT, class MT>
+template <typename DMT, typename MT>
 octave_value
 octave_base_diag<DMT, MT>::subsref (const std::string& type,
                                     const std::list<octave_value_list>& idx)
 {
   octave_value retval;
 
   switch (type[0])
     {
@@ -65,17 +65,17 @@ octave_base_diag<DMT, MT>::subsref (cons
     default:
       panic_impossible ();
     }
 
   return retval.next_subsref (type, idx);
 }
 
 
-template <class DMT, class MT>
+template <typename DMT, typename MT>
 octave_value
 octave_base_diag<DMT,MT>::diag (octave_idx_type k) const
 {
   octave_value retval;
   if (matrix.rows () == 1 || matrix.cols () == 1)
     {
       // Rather odd special case. This is a row or column vector
       // represented as a diagonal matrix with a single nonzero entry, but
@@ -90,17 +90,17 @@ octave_base_diag<DMT,MT>::diag (octave_i
     }
   else
     // Returns Array<T> vector
     retval = matrix.extract_diag (k);
   return retval;
 }
 
 
-template <class DMT, class MT>
+template <typename DMT, typename MT>
 octave_value
 octave_base_diag<DMT, MT>::do_index_op (const octave_value_list& idx,
                                         bool resize_ok)
 {
   octave_value retval;
 
   if (idx.length () == 2 && ! resize_ok)
     {
@@ -138,17 +138,17 @@ octave_base_diag<DMT, MT>::do_index_op (
         }
     }
   else
     retval = to_dense ().do_index_op (idx, resize_ok);
 
   return retval;
 }
 
-template <class DMT, class MT>
+template <typename DMT, typename MT>
 octave_value
 octave_base_diag<DMT, MT>::subsasgn (const std::string& type,
                                      const std::list<octave_value_list>& idx,
                                      const octave_value& rhs)
 {
   octave_value retval;
 
   switch (type[0])
@@ -252,49 +252,49 @@ octave_base_diag<DMT, MT>::subsasgn (con
 
     default:
       panic_impossible ();
     }
 
   return retval;
 }
 
-template <class DMT, class MT>
+template <typename DMT, typename MT>
 octave_value
 octave_base_diag<DMT, MT>::resize (const dim_vector& dv, bool fill) const
 {
   octave_value retval;
   if (dv.length () == 2)
     {
       DMT rm (matrix);
       rm.resize (dv(0), dv(1));
       retval = rm;
     }
   else
     retval = to_dense ().resize (dv, fill);
   return retval;
 }
 
-template <class DMT, class MT>
+template <typename DMT, typename MT>
 bool
 octave_base_diag<DMT, MT>::is_true (void) const
 {
   return to_dense ().is_true ();
 }
 
 // FIXME: This should be achieveable using ::real
-template <class T> inline T helper_getreal (T x) { return x; }
-template <class T> inline T helper_getreal (std::complex<T> x)
+template <typename T> inline T helper_getreal (T x) { return x; }
+template <typename T> inline T helper_getreal (std::complex<T> x)
 { return x.real (); }
 // FIXME: We really need some traits so that ad hoc hooks like this
 //        are not necessary.
-template <class T> inline T helper_iscomplex (T) { return false; }
-template <class T> inline T helper_iscomplex (std::complex<T>) { return true; }
+template <typename T> inline T helper_iscomplex (T) { return false; }
+template <typename T> inline T helper_iscomplex (std::complex<T>) { return true; }
 
-template <class DMT, class MT>
+template <typename DMT, typename MT>
 double
 octave_base_diag<DMT, MT>::double_value (bool force_conversion) const
 {
   double retval = lo_ieee_nan_value ();
   typedef typename DMT::element_type el_type;
 
   if (helper_iscomplex (el_type ()) && ! force_conversion)
     warn_implicit_conversion ("Octave:imag-to-real",
@@ -306,17 +306,17 @@ octave_base_diag<DMT, MT>::double_value 
   warn_implicit_conversion ("Octave:array-to-scalar",
                             type_name (), "real scalar");
 
   retval = helper_getreal (el_type (matrix (0, 0)));
 
   return retval;
 }
 
-template <class DMT, class MT>
+template <typename DMT, typename MT>
 float
 octave_base_diag<DMT, MT>::float_value (bool force_conversion) const
 {
   float retval = lo_ieee_float_nan_value ();
   typedef typename DMT::element_type el_type;
 
   if (helper_iscomplex (el_type ()) && ! force_conversion)
     warn_implicit_conversion ("Octave:imag-to-real",
@@ -330,17 +330,17 @@ octave_base_diag<DMT, MT>::float_value (
       retval = helper_getreal (el_type (matrix (0, 0)));
     }
   else
     err_invalid_conversion (type_name (), "real scalar");
 
   return retval;
 }
 
-template <class DMT, class MT>
+template <typename DMT, typename MT>
 Complex
 octave_base_diag<DMT, MT>::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
   if (rows () == 0 || columns () == 0)
@@ -349,17 +349,17 @@ octave_base_diag<DMT, MT>::complex_value
   warn_implicit_conversion ("Octave:array-to-scalar",
                             type_name (), "complex scalar");
 
   retval = matrix (0, 0);
 
   return retval;
 }
 
-template <class DMT, class MT>
+template <typename DMT, typename MT>
 FloatComplex
 octave_base_diag<DMT, MT>::float_complex_value (bool) const
 {
   float tmp = lo_ieee_float_nan_value ();
 
   FloatComplex retval (tmp, tmp);
 
   if (rows () == 0 || columns () == 0)
@@ -368,128 +368,128 @@ octave_base_diag<DMT, MT>::float_complex
   warn_implicit_conversion ("Octave:array-to-scalar",
                             type_name (), "complex scalar");
 
   retval = matrix (0, 0);
 
   return retval;
 }
 
-template <class DMT, class MT>
+template <typename DMT, typename MT>
 Matrix
 octave_base_diag<DMT, MT>::matrix_value (bool) const
 {
   return Matrix (diag_matrix_value ());
 }
 
-template <class DMT, class MT>
+template <typename DMT, typename MT>
 FloatMatrix
 octave_base_diag<DMT, MT>::float_matrix_value (bool) const
 {
   return FloatMatrix (float_diag_matrix_value ());
 }
 
-template <class DMT, class MT>
+template <typename DMT, typename MT>
 ComplexMatrix
 octave_base_diag<DMT, MT>::complex_matrix_value (bool) const
 {
   return ComplexMatrix (complex_diag_matrix_value ());
 }
 
-template <class DMT, class MT>
+template <typename DMT, typename MT>
 FloatComplexMatrix
 octave_base_diag<DMT, MT>::float_complex_matrix_value (bool) const
 {
   return FloatComplexMatrix (float_complex_diag_matrix_value ());
 }
 
-template <class DMT, class MT>
+template <typename DMT, typename MT>
 NDArray
 octave_base_diag<DMT, MT>::array_value (bool) const
 {
   return NDArray (matrix_value ());
 }
 
-template <class DMT, class MT>
+template <typename DMT, typename MT>
 FloatNDArray
 octave_base_diag<DMT, MT>::float_array_value (bool) const
 {
   return FloatNDArray (float_matrix_value ());
 }
 
-template <class DMT, class MT>
+template <typename DMT, typename MT>
 ComplexNDArray
 octave_base_diag<DMT, MT>::complex_array_value (bool) const
 {
   return ComplexNDArray (complex_matrix_value ());
 }
 
-template <class DMT, class MT>
+template <typename DMT, typename MT>
 FloatComplexNDArray
 octave_base_diag<DMT, MT>::float_complex_array_value (bool) const
 {
   return FloatComplexNDArray (float_complex_matrix_value ());
 }
 
-template <class DMT, class MT>
+template <typename DMT, typename MT>
 boolNDArray
 octave_base_diag<DMT, MT>::bool_array_value (bool warn) const
 {
   return to_dense ().bool_array_value (warn);
 }
 
-template <class DMT, class MT>
+template <typename DMT, typename MT>
 charNDArray
 octave_base_diag<DMT, MT>::char_array_value (bool warn) const
 {
   return to_dense ().char_array_value (warn);
 }
 
-template <class DMT, class MT>
+template <typename DMT, typename MT>
 SparseMatrix
 octave_base_diag<DMT, MT>::sparse_matrix_value (bool) const
 {
   return SparseMatrix (diag_matrix_value ());
 }
 
-template <class DMT, class MT>
+template <typename DMT, typename MT>
 SparseComplexMatrix
 octave_base_diag<DMT, MT>::sparse_complex_matrix_value (bool) const
 {
   return SparseComplexMatrix (complex_diag_matrix_value ());
 }
 
-template <class DMT, class MT>
+template <typename DMT, typename MT>
 idx_vector
 octave_base_diag<DMT, MT>::index_vector (bool require_integers) const
 {
   return to_dense ().index_vector (require_integers);
 }
 
-template <class DMT, class MT>
+template <typename DMT, typename MT>
 octave_value
 octave_base_diag<DMT, MT>::convert_to_str_internal (bool pad, bool force,
                                                     char type) const
 {
   return to_dense ().convert_to_str_internal (pad, force, type);
 }
 
-template <class DMT, class MT>
+template <typename DMT, typename MT>
 bool
 octave_base_diag<DMT, MT>::save_ascii (std::ostream& os)
 {
   os << "# rows: " << matrix.rows () << "\n"
      << "# columns: " << matrix.columns () << "\n";
 
   os << matrix.extract_diag ();
 
   return true;
 }
 
-template <class DMT, class MT>
+template <typename DMT, typename MT>
 bool
 octave_base_diag<DMT, MT>::load_ascii (std::istream& is)
 {
   octave_idx_type r = 0;
   octave_idx_type c = 0;
 
   if (! extract_keyword (is, "rows", r, true)
       || ! extract_keyword (is, "columns", c, true))
@@ -510,84 +510,84 @@ octave_base_diag<DMT, MT>::load_ascii (s
   matrix.resize (r, c);
 
   // Invalidate cache. Probably not necessary, but safe.
   dense_cache = octave_value ();
 
   return true;
 }
 
-template <class DMT, class MT>
+template <typename DMT, typename MT>
 void
 octave_base_diag<DMT, MT>::print_raw (std::ostream& os,
                                       bool pr_as_read_syntax) const
 {
   return octave_print_internal (os, matrix, pr_as_read_syntax,
                                 current_print_indent_level ());
 }
 
-template <class DMT, class MT>
+template <typename DMT, typename MT>
 mxArray *
 octave_base_diag<DMT, MT>::as_mxArray (void) const
 {
   return to_dense ().as_mxArray ();
 }
 
-template <class DMT, class MT>
+template <typename DMT, typename MT>
 bool
 octave_base_diag<DMT, MT>::print_as_scalar (void) const
 {
   dim_vector dv = dims ();
 
   return (dv.all_ones () || dv.any_zero ());
 }
 
-template <class DMT, class MT>
+template <typename DMT, typename MT>
 void
 octave_base_diag<DMT, MT>::print (std::ostream& os, bool pr_as_read_syntax)
 {
   print_raw (os, pr_as_read_syntax);
   newline (os);
 }
-template <class DMT, class MT>
+template <typename DMT, typename MT>
 int
 octave_base_diag<DMT, MT>::write (octave_stream& os, int block_size,
                                   oct_data_conv::data_type output_type,
                                   int skip,
                                   oct_mach_info::float_format flt_fmt) const
 {
   return to_dense ().write (os, block_size, output_type, skip, flt_fmt);
 }
 
-template <class DMT, class MT>
+template <typename DMT, typename MT>
 void
 octave_base_diag<DMT, MT>::print_info (std::ostream& os,
                                        const std::string& prefix) const
 {
   matrix.print_info (os, prefix);
 }
 
-template <class DMT, class MT>
+template <typename DMT, typename MT>
 octave_value
 octave_base_diag<DMT, MT>::fast_elem_extract (octave_idx_type n) const
 {
   if (n < matrix.numel ())
     {
       octave_idx_type nr = matrix.rows ();
 
       octave_idx_type r = n % nr;
       octave_idx_type c = n / nr;
 
       return octave_value (matrix.elem (r, c));
     }
   else
     return octave_value ();
 }
 
-template <class DMT, class MT>
+template <typename DMT, typename MT>
 octave_value
 octave_base_diag<DMT, MT>::to_dense (void) const
 {
   if (! dense_cache.is_defined ())
     dense_cache = MT (matrix);
 
   return dense_cache;
 }
diff --git a/libinterp/octave-value/ov-base-diag.h b/libinterp/octave-value/ov-base-diag.h
--- a/libinterp/octave-value/ov-base-diag.h
+++ b/libinterp/octave-value/ov-base-diag.h
@@ -34,17 +34,17 @@ along with Octave; see the file COPYING.
 #include "ovl.h"
 #include "ov-base.h"
 #include "ov-typeinfo.h"
 
 class tree_walker;
 
 // Real matrix values.
 
-template <class DMT, class MT>
+template <typename DMT, typename MT>
 class
 octave_base_diag : public octave_base_value
 {
 
 public:
 
   octave_base_diag (void)
     : octave_base_value (), matrix (), dense_cache () { }
diff --git a/libinterp/octave-value/ov-base-int.cc b/libinterp/octave-value/ov-base-int.cc
--- a/libinterp/octave-value/ov-base-int.cc
+++ b/libinterp/octave-value/ov-base-int.cc
@@ -56,54 +56,54 @@ along with Octave; see the file COPYING.
 #include "ls-utils.h"
 #include "ls-hdf5.h"
 
 // We have all the machinery below (octave_base_int_helper and
 // octave_base_int_helper_traits) to avoid a few warnings from GCC
 // about comparisons always false due to limited range of data types.
 // Ugh.  The cure may be worse than the disease.
 
-template <class T, bool is_signed = true, bool can_be_too_big = true>
+template <typename T, bool is_signed = true, bool can_be_too_big = true>
 struct octave_base_int_helper
 {
   static bool
   char_value_out_of_range (T val)
   {
     return val < 0 || val > std::numeric_limits<unsigned char>::max ();
   }
 };
 
-template <class T>
+template <typename T>
 struct octave_base_int_helper<T, false, false>
 {
   static bool char_value_out_of_range (T) { return false; }
 };
 
-template <class T>
+template <typename T>
 struct octave_base_int_helper<T, false, true>
 {
   static bool char_value_out_of_range (T val)
   {
     return val > std::numeric_limits<unsigned char>::max ();
   }
 };
 
-template <class T>
+template <typename T>
 struct octave_base_int_helper<T, true, false>
 {
   static bool char_value_out_of_range (T val) { return val < 0; }
 };
 
 // For all types other than char, signed char, and unsigned char, we
 // assume that the upper limit for the range of allowable values is
 // larger than the range for unsigned char.  If that's not true, we
 // are still OK, but will see the warnings again for any other types
 // that do not meet this assumption.
 
-template <class T>
+template <typename T>
 struct octave_base_int_helper_traits
 {
   static const bool can_be_larger_than_uchar_max = true;
 };
 
 template <>
 struct octave_base_int_helper_traits<char>
 {
@@ -118,30 +118,30 @@ struct octave_base_int_helper_traits<sig
 
 template <>
 struct octave_base_int_helper_traits<unsigned char>
 {
   static const bool can_be_larger_than_uchar_max = false;
 };
 
 
-template <class T>
+template <typename T>
 octave_base_value *
 octave_base_int_matrix<T>::try_narrowing_conversion (void)
 {
   octave_base_value *retval = 0;
 
   if (this->matrix.numel () == 1)
     retval = new typename octave_value_int_traits<T>::scalar_type
                (this->matrix (0));
 
   return retval;
 }
 
-template <class T>
+template <typename T>
 octave_value
 octave_base_int_matrix<T>::convert_to_str_internal (bool, bool, char type) const
 {
   octave_value retval;
   dim_vector dv = this->dims ();
   octave_idx_type nel = dv.numel ();
 
   charNDArray chm (dv);
@@ -179,33 +179,33 @@ octave_base_int_matrix<T>::convert_to_st
         chm (i) = static_cast<char> (ival);
     }
 
   retval = octave_value (chm, type);
 
   return retval;
 }
 
-template <class T>
+template <typename T>
 bool
 octave_base_int_matrix<T>::save_ascii (std::ostream& os)
 {
   dim_vector d = this->dims ();
 
   os << "# ndims: " << d.length () << "\n";
 
   for (int i = 0; i < d.length (); i++)
     os << " " << d(i);
 
   os << "\n" << this->matrix;
 
   return true;
 }
 
-template <class T>
+template <typename T>
 bool
 octave_base_int_matrix<T>::load_ascii (std::istream& is)
 {
   int mdims = 0;
 
   if (! extract_keyword (is, "ndims", mdims, true))
     error ("load: failed to extract number of dimensions");
 
@@ -225,17 +225,17 @@ octave_base_int_matrix<T>::load_ascii (s
   if (! is)
     error ("load: failed to load matrix constant");
 
   this->matrix = tmp;
 
   return true;
 }
 
-template <class T>
+template <typename T>
 bool
 octave_base_int_matrix<T>::save_binary (std::ostream& os, bool&)
 {
   dim_vector d = this->dims ();
   if (d.length () < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
@@ -248,17 +248,17 @@ octave_base_int_matrix<T>::save_binary (
     }
 
   os.write (reinterpret_cast<const char *> (this->matrix.data ()),
             this->byte_size ());
 
   return true;
 }
 
-template <class T>
+template <typename T>
 bool
 octave_base_int_matrix<T>::load_binary (std::istream& is, bool swap,
                                         oct_mach_info::float_format)
 {
   int32_t mdims;
   if (! is.read (reinterpret_cast<char *> (&mdims), 4))
     return false;
   if (swap)
@@ -318,17 +318,17 @@ octave_base_int_matrix<T>::load_binary (
             break;
           }
     }
 
   this->matrix = m;
   return true;
 }
 
-template <class T>
+template <typename T>
 bool
 octave_base_int_matrix<T>::save_hdf5 (octave_hdf5_id loc_id, const char *name, bool)
 {
   bool retval = false;
 
 #if defined (HAVE_HDF5)
 
   hid_t save_type_hid = HDF5_SAVE_TYPE;
@@ -370,17 +370,17 @@ octave_base_int_matrix<T>::save_hdf5 (oc
 
 #else
   this->warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
-template <class T>
+template <typename T>
 bool
 octave_base_int_matrix<T>::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
   bool retval = false;
 
 #if defined (HAVE_HDF5)
 
   hid_t save_type_hid = HDF5_SAVE_TYPE;
@@ -439,26 +439,26 @@ octave_base_int_matrix<T>::load_hdf5 (oc
 
 #else
   this->warn_load ("hdf5");
 #endif
 
   return retval;
 }
 
-template <class T>
+template <typename T>
 void
 octave_base_int_matrix<T>::print_raw (std::ostream& os,
                                       bool pr_as_read_syntax) const
 {
   octave_print_internal (os, this->matrix, pr_as_read_syntax,
                          this->current_print_indent_level ());
 }
 
-template <class T>
+template <typename T>
 octave_value
 octave_base_int_scalar<T>::convert_to_str_internal (bool, bool, char type) const
 {
   octave_value retval;
 
   T tmp = this->scalar;
 
   typedef typename T::val_type val_type;
@@ -479,44 +479,44 @@ octave_base_int_scalar<T>::convert_to_st
       ::warning ("range error for conversion to character value");
     }
   else
     retval = octave_value (std::string (1, static_cast<char> (ival)), type);
 
   return retval;
 }
 
-template <class T>
+template <typename T>
 bool
 octave_base_int_scalar<T>::save_ascii (std::ostream& os)
 {
   os << this->scalar << "\n";
   return true;
 }
 
-template <class T>
+template <typename T>
 bool
 octave_base_int_scalar<T>::load_ascii (std::istream& is)
 {
   is >> this->scalar;
   if (! is)
     error ("load: failed to load scalar constant");
 
   return true;
 }
 
-template <class T>
+template <typename T>
 bool
 octave_base_int_scalar<T>::save_binary (std::ostream& os, bool&)
 {
   os.write (reinterpret_cast<char *> (&(this->scalar)), this->byte_size ());
   return true;
 }
 
-template <class T>
+template <typename T>
 bool
 octave_base_int_scalar<T>::load_binary (std::istream& is, bool swap,
                                         oct_mach_info::float_format)
 {
   T tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), this->byte_size ()))
     return false;
 
@@ -535,17 +535,17 @@ octave_base_int_scalar<T>::load_binary (
       case 1:
       default:
         break;
       }
   this->scalar = tmp;
   return true;
 }
 
-template <class T>
+template <typename T>
 bool
 octave_base_int_scalar<T>::save_hdf5 (octave_hdf5_id loc_id, const char *name, bool)
 {
   bool retval = false;
 
 #if defined (HAVE_HDF5)
 
   hid_t save_type_hid = HDF5_SAVE_TYPE;
@@ -577,17 +577,17 @@ octave_base_int_scalar<T>::save_hdf5 (oc
 
 #else
   this->warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
-template <class T>
+template <typename T>
 bool
 octave_base_int_scalar<T>::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
 #if defined (HAVE_HDF5)
 
   hid_t save_type_hid = HDF5_SAVE_TYPE;
 #if HAVE_HDF5_18
   hid_t data_hid = H5Dopen (loc_id, name, octave_H5P_DEFAULT);
diff --git a/libinterp/octave-value/ov-base-int.h b/libinterp/octave-value/ov-base-int.h
--- a/libinterp/octave-value/ov-base-int.h
+++ b/libinterp/octave-value/ov-base-int.h
@@ -34,17 +34,17 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "ov-base-scalar.h"
 #include "ov-typeinfo.h"
 
 // base int matrix values.
 
-template <class T>
+template <typename T>
 class
 octave_base_int_matrix : public octave_base_matrix<T>
 {
 public:
 
   octave_base_int_matrix (void) : octave_base_matrix<T> () { }
 
   octave_base_int_matrix (const T& nda) : octave_base_matrix<T> (nda) { }
@@ -80,17 +80,17 @@ public:
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 };
 
 // base int scalar values.
 
-template <class T>
+template <typename T>
 class
 octave_base_int_scalar : public octave_base_scalar<T>
 {
 public:
 
   octave_base_int_scalar (void) : octave_base_scalar<T> () { }
 
   octave_base_int_scalar (const T& s) : octave_base_scalar<T> (s) { }
diff --git a/libinterp/octave-value/ov-base-mat.cc b/libinterp/octave-value/ov-base-mat.cc
--- a/libinterp/octave-value/ov-base-mat.cc
+++ b/libinterp/octave-value/ov-base-mat.cc
@@ -32,17 +32,17 @@ along with Octave; see the file COPYING.
 #include "Cell.h"
 #include "ovl.h"
 #include "oct-map.h"
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "ov-base-scalar.h"
 #include "pr-output.h"
 
-template <class MT>
+template <typename MT>
 octave_value
 octave_base_matrix<MT>::subsref (const std::string& type,
                                  const std::list<octave_value_list>& idx)
 {
   octave_value retval;
 
   switch (type[0])
     {
@@ -60,17 +60,17 @@ octave_base_matrix<MT>::subsref (const s
 
     default:
       panic_impossible ();
     }
 
   return retval.next_subsref (type, idx);
 }
 
-template <class MT>
+template <typename MT>
 octave_value
 octave_base_matrix<MT>::subsasgn (const std::string& type,
                                   const std::list<octave_value_list>& idx,
                                   const octave_value& rhs)
 {
   octave_value retval;
 
   switch (type[0])
@@ -119,17 +119,17 @@ octave_base_matrix<MT>::subsasgn (const 
 
     default:
       panic_impossible ();
     }
 
   return retval;
 }
 
-template <class MT>
+template <typename MT>
 octave_value
 octave_base_matrix<MT>::do_index_op (const octave_value_list& idx,
                                      bool resize_ok)
 {
   octave_value retval;
 
   octave_idx_type n_idx = idx.length ();
 
@@ -203,17 +203,17 @@ octave_base_matrix<MT>::do_index_op (con
       // Rethrow to allow more info to be reported later.
       e.set_pos_if_unset (n_idx, k+1);
       throw;
     }
 
   return retval;
 }
 
-template <class MT>
+template <typename MT>
 void
 octave_base_matrix<MT>::assign (const octave_value_list& idx, const MT& rhs)
 {
   octave_idx_type n_idx = idx.length ();
 
   // If we catch an indexing error in index_vector, we flag an error in
   // index k.  Ensure it is the right value befor each idx_vector call.
   // Same variable as used in the for loop in the default case.
@@ -263,26 +263,26 @@ octave_base_matrix<MT>::assign (const oc
     {
       err_invalid_index (e.idx (), n_idx, k+1);
     }
 
   // Clear cache.
   clear_cached_info ();
 }
 
-template <class MT>
+template <typename MT>
 MatrixType
 octave_base_matrix<MT>::matrix_type (const MatrixType& _typ) const
 {
   delete typ;
   typ = new MatrixType (_typ);
   return *typ;
 }
 
-template <class MT>
+template <typename MT>
 void
 octave_base_matrix<MT>::assign (const octave_value_list& idx,
                                 typename MT::element_type rhs)
 {
   octave_idx_type n_idx = idx.length ();
 
   int nd = matrix.ndims ();
 
@@ -367,46 +367,46 @@ octave_base_matrix<MT>::assign (const oc
     {
       err_invalid_index (e.idx (), n_idx, k+1);
     }
 
   // Clear cache.
   clear_cached_info ();
 }
 
-template <class MT>
+template <typename MT>
 void
 octave_base_matrix<MT>::delete_elements (const octave_value_list& idx)
 {
   octave_idx_type len = idx.length ();
 
   Array<idx_vector> ra_idx (dim_vector (len, 1));
 
   for (octave_idx_type i = 0; i < len; i++)
     ra_idx(i) = idx(i).index_vector ();
 
   matrix.delete_elements (ra_idx);
 
   // Clear cache.
   clear_cached_info ();
 }
 
-template <class MT>
+template <typename MT>
 octave_value
 octave_base_matrix<MT>::resize (const dim_vector& dv, bool fill) const
 {
   MT retval (matrix);
   if (fill)
     retval.resize (dv, 0);
   else
     retval.resize (dv);
   return retval;
 }
 
-template <class MT>
+template <typename MT>
 bool
 octave_base_matrix<MT>::is_true (void) const
 {
   bool retval = false;
   dim_vector dv = matrix.dims ();
   int nel = dv.numel ();
 
   if (nel > 0)
@@ -419,42 +419,42 @@ octave_base_matrix<MT>::is_true (void) c
       boolNDArray t2 = t1.all ();
 
       retval = t2(0);
     }
 
   return retval;
 }
 
-template <class MT>
+template <typename MT>
 bool
 octave_base_matrix<MT>::print_as_scalar (void) const
 {
   dim_vector dv = dims ();
 
   return (dv.all_ones () || dv.any_zero ());
 }
 
-template <class MT>
+template <typename MT>
 void
 octave_base_matrix<MT>::print (std::ostream& os, bool pr_as_read_syntax)
 {
   print_raw (os, pr_as_read_syntax);
   newline (os);
 }
 
-template <class MT>
+template <typename MT>
 void
 octave_base_matrix<MT>::print_info (std::ostream& os,
                                     const std::string& prefix) const
 {
   matrix.print_info (os, prefix);
 }
 
-template <class MT>
+template <typename MT>
 void
 octave_base_matrix<MT>::short_disp (std::ostream& os) const
 {
   if (matrix.is_empty ())
     os << "[]";
   else if (matrix.ndims () == 2)
     {
       // FIXME: should this be configurable?
@@ -496,27 +496,27 @@ octave_base_matrix<MT>::short_disp (std:
 
       if (nel <= max_elts)
         os << "]";
     }
   else
     os << "...";
 }
 
-template <class MT>
+template <typename MT>
 octave_value
 octave_base_matrix<MT>::fast_elem_extract (octave_idx_type n) const
 {
   if (n < matrix.numel ())
     return matrix(n);
   else
     return octave_value ();
 }
 
-template <class MT>
+template <typename MT>
 bool
 octave_base_matrix<MT>::fast_elem_insert (octave_idx_type n,
                                           const octave_value& x)
 {
   if (n < matrix.numel ())
     {
       // Don't use builtin_type () here to avoid an extra VM call.
       typedef typename MT::element_type ET;
diff --git a/libinterp/octave-value/ov-base-mat.h b/libinterp/octave-value/ov-base-mat.h
--- a/libinterp/octave-value/ov-base-mat.h
+++ b/libinterp/octave-value/ov-base-mat.h
@@ -37,17 +37,17 @@ along with Octave; see the file COPYING.
 #include "ovl.h"
 #include "ov-base.h"
 #include "ov-typeinfo.h"
 
 class tree_walker;
 
 // Real matrix values.
 
-template <class MT>
+template <typename MT>
 class
 octave_base_matrix : public octave_base_value
 {
 public:
 
   octave_base_matrix (void)
     : octave_base_value (), matrix (), typ (), idx_cache () { }
 
diff --git a/libinterp/octave-value/ov-base-scalar.cc b/libinterp/octave-value/ov-base-scalar.cc
--- a/libinterp/octave-value/ov-base-scalar.cc
+++ b/libinterp/octave-value/ov-base-scalar.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 
 #include "ovl.h"
 #include "ov-base.h"
 #include "ov-cx-mat.h"
 #include "ov-re-mat.h"
 #include "ov-base-scalar.h"
 #include "pr-output.h"
 
-template <class ST>
+template <typename ST>
 octave_value
 octave_base_scalar<ST>::subsref (const std::string& type,
                                  const std::list<octave_value_list>& idx)
 {
   octave_value retval;
 
   switch (type[0])
     {
@@ -56,17 +56,17 @@ octave_base_scalar<ST>::subsref (const s
 
     default:
       panic_impossible ();
     }
 
   return retval.next_subsref (type, idx);
 }
 
-template <class ST>
+template <typename ST>
 octave_value
 octave_base_scalar<ST>::subsasgn (const std::string& type,
                                   const std::list<octave_value_list>& idx,
                                   const octave_value& rhs)
 {
   octave_value retval;
 
   switch (type[0])
@@ -94,103 +94,103 @@ octave_base_scalar<ST>::subsasgn (const 
 
     default:
       panic_impossible ();
     }
 
   return retval;
 }
 
-template <class ST>
+template <typename ST>
 octave_value
 octave_base_scalar<ST>::permute (const Array<int>& vec, bool inv) const
 {
   return Array<ST> (dim_vector (1, 1), scalar).permute (vec, inv);
 }
 
-template <class ST>
+template <typename ST>
 octave_value
 octave_base_scalar<ST>::reshape (const dim_vector& new_dims) const
 {
   return Array<ST> (dim_vector (1, 1), scalar).reshape (new_dims);
 }
 
-template <class ST>
+template <typename ST>
 octave_value
 octave_base_scalar<ST>::diag (octave_idx_type k) const
 {
   return Array<ST> (dim_vector (1, 1), scalar).diag (k);
 }
 
-template <class ST>
+template <typename ST>
 octave_value
 octave_base_scalar<ST>::diag (octave_idx_type m, octave_idx_type n) const
 {
   return Array<ST> (dim_vector (1, 1), scalar).diag (m, n);
 }
 
-template <class ST>
+template <typename ST>
 bool
 octave_base_scalar<ST>::is_true (void) const
 {
   if (xisnan (scalar))
     err_nan_to_logical_conversion ();
 
   return (scalar != ST ());
 }
 
-template <class ST>
+template <typename ST>
 void
 octave_base_scalar<ST>::print (std::ostream& os, bool pr_as_read_syntax)
 {
   print_raw (os, pr_as_read_syntax);
   newline (os);
 }
 
-template <class ST>
+template <typename ST>
 void
 octave_base_scalar<ST>::print_raw (std::ostream& os,
                                    bool pr_as_read_syntax) const
 {
   indent (os);
   octave_print_internal (os, scalar, pr_as_read_syntax);
 }
 
-template <class ST>
+template <typename ST>
 bool
 octave_base_scalar<ST>::print_name_tag (std::ostream& os,
                                         const std::string& name) const
 {
   indent (os);
   os << name << " = ";
   return false;
 }
 
-template <class ST>
+template <typename ST>
 void
 octave_base_scalar<ST>::short_disp (std::ostream& os) const
 {
   std::ostringstream buf;
   octave_print_internal (buf, scalar);
   std::string tmp = buf.str ();
   size_t pos = tmp.find_first_not_of (" ");
   if (pos != std::string::npos)
     os << tmp.substr (pos);
   else if (! tmp.empty ())
     os << tmp[0];
 }
 
-template <class ST>
+template <typename ST>
 octave_value
 octave_base_scalar<ST>::fast_elem_extract (octave_idx_type n) const
 {
   return (n == 0) ? octave_value (scalar) : octave_value ();
 }
 
-template <class ST>
+template <typename ST>
 bool
 octave_base_scalar<ST>::fast_elem_insert_self (void *where,
                                                builtin_type_t btyp) const
 {
 
   // Don't use builtin_type () here to avoid an extra VM call.
   if (btyp == class_to_btyp<ST>::btyp)
     {
diff --git a/libinterp/octave-value/ov-base-scalar.h b/libinterp/octave-value/ov-base-scalar.h
--- a/libinterp/octave-value/ov-base-scalar.h
+++ b/libinterp/octave-value/ov-base-scalar.h
@@ -33,17 +33,17 @@ along with Octave; see the file COPYING.
 #include "str-vec.h"
 #include "MatrixType.h"
 
 #include "ov-base.h"
 #include "ov-typeinfo.h"
 
 // Real scalar values.
 
-template <class ST>
+template <typename ST>
 class
 octave_base_scalar : public octave_base_value
 {
 public:
 
   octave_base_scalar (void)
     : octave_base_value (), scalar () { }
 
diff --git a/libinterp/octave-value/ov-base-sparse.cc b/libinterp/octave-value/ov-base-sparse.cc
--- a/libinterp/octave-value/ov-base-sparse.cc
+++ b/libinterp/octave-value/ov-base-sparse.cc
@@ -42,17 +42,17 @@ along with Octave; see the file COPYING.
 #include "boolSparse.h"
 #include "ov-base-sparse.h"
 #include "octave-preserve-stream-state.h"
 #include "pager.h"
 #include "utils.h"
 
 #include "lo-array-errwarn.h"
 
-template <class T>
+template <typename T>
 octave_value
 octave_base_sparse<T>::do_index_op (const octave_value_list& idx,
                                     bool resize_ok)
 {
   octave_value retval;
 
   octave_idx_type n_idx = idx.length ();
 
@@ -98,17 +98,17 @@ octave_base_sparse<T>::do_index_op (cons
       // Rethrow to allow more info to be reported later.
       e.set_pos_if_unset (n_idx, k+1);
       throw;
     }
 
   return retval;
 }
 
-template <class T>
+template <typename T>
 octave_value
 octave_base_sparse<T>::subsref (const std::string& type,
                                 const std::list<octave_value_list>& idx)
 {
   octave_value retval;
 
   switch (type[0])
     {
@@ -126,17 +126,17 @@ octave_base_sparse<T>::subsref (const st
 
     default:
       panic_impossible ();
     }
 
   return retval.next_subsref (type, idx);
 }
 
-template <class T>
+template <typename T>
 octave_value
 octave_base_sparse<T>::subsasgn (const std::string& type,
                                  const std::list<octave_value_list>& idx,
                                  const octave_value& rhs)
 {
   octave_value retval;
 
   switch (type[0])
@@ -171,17 +171,17 @@ octave_base_sparse<T>::subsasgn (const s
 
     default:
       panic_impossible ();
     }
 
   return retval;
 }
 
-template <class T>
+template <typename T>
 void
 octave_base_sparse<T>::assign (const octave_value_list& idx, const T& rhs)
 {
 
   octave_idx_type len = idx.length ();
 
   // If we catch an indexing error in index_vector, we flag an error in
   // index k.  Ensure it is the right value befor each idx_vector call.
@@ -225,17 +225,17 @@ octave_base_sparse<T>::assign (const oct
       throw;
     }
 
 
   // Invalidate matrix type.
   typ.invalidate_type ();
 }
 
-template <class MT>
+template <typename MT>
 void
 octave_base_sparse<MT>::delete_elements (const octave_value_list& idx)
 {
   octave_idx_type len = idx.length ();
 
   // If we catch an indexing error in index_vector, we flag an error in
   // index k.  Ensure it is the right value befor each idx_vector call.
   // Same variable as used in the for loop in the default case.
@@ -277,26 +277,26 @@ octave_base_sparse<MT>::delete_elements 
       e.set_pos_if_unset (len, k+1);
       throw;
     }
 
   // Invalidate the matrix type
   typ.invalidate_type ();
 }
 
-template <class T>
+template <typename T>
 octave_value
 octave_base_sparse<T>::resize (const dim_vector& dv, bool) const
 {
   T retval (matrix);
   retval.resize (dv);
   return retval;
 }
 
-template <class T>
+template <typename T>
 bool
 octave_base_sparse<T>::is_true (void) const
 {
   bool retval = false;
   dim_vector dv = matrix.dims ();
   octave_idx_type nel = dv.numel ();
   octave_idx_type nz = nnz ();
 
@@ -307,42 +307,42 @@ octave_base_sparse<T>::is_true (void) co
       SparseBoolMatrix t2 = t1.all ();
 
       retval = t2(0);
     }
 
   return retval;
 }
 
-template <class T>
+template <typename T>
 bool
 octave_base_sparse<T>::print_as_scalar (void) const
 {
   dim_vector dv = dims ();
 
   return (dv.all_ones () || dv.any_zero ());
 }
 
-template <class T>
+template <typename T>
 void
 octave_base_sparse<T>::print (std::ostream& os, bool pr_as_read_syntax)
 {
   print_raw (os, pr_as_read_syntax);
   newline (os);
 }
 
-template <class T>
+template <typename T>
 void
 octave_base_sparse<T>::print_info (std::ostream& os,
                                    const std::string& prefix) const
 {
   matrix.print_info (os, prefix);
 }
 
-template <class T>
+template <typename T>
 void
 octave_base_sparse<T>::print_raw (std::ostream& os,
                                   bool pr_as_read_syntax) const
 {
   octave_preserve_stream_state stream_state (os);
 
   octave_idx_type nr = matrix.rows ();
   octave_idx_type nc = matrix.cols ();
@@ -414,17 +414,17 @@ octave_base_sparse<T>::print_raw (std::o
               os << "  (" << matrix.ridx (i)+1 << ", "  << j+1 << ") -> ";
 
               octave_print_internal (os, matrix.data (i), pr_as_read_syntax);
             }
         }
     }
 }
 
-template <class T>
+template <typename T>
 bool
 octave_base_sparse<T>::save_ascii (std::ostream& os)
 {
   dim_vector dv = this->dims ();
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
 
@@ -432,17 +432,17 @@ octave_base_sparse<T>::save_ascii (std::
   os << "# rows: "     << dv(0) << "\n";
   os << "# columns: "  << dv(1) << "\n";
 
   os << this->matrix;
 
   return true;
 }
 
-template <class T>
+template <typename T>
 bool
 octave_base_sparse<T>::load_ascii (std::istream& is)
 {
   octave_idx_type nz = 0;
   octave_idx_type nr = 0;
   octave_idx_type nc = 0;
 
   if (! extract_keyword (is, "nnz", nz, true)
@@ -458,30 +458,30 @@ octave_base_sparse<T>::load_ascii (std::
     error ("load: failed to load matrix constant");
 
   matrix = tmp;
 
   return true;
 }
 
 
-template <class T>
+template <typename T>
 octave_value
 octave_base_sparse<T>::fast_elem_extract (octave_idx_type n) const
 {
   octave_idx_type nr = matrix.rows ();
   octave_idx_type nc = matrix.cols ();
 
   octave_idx_type i = n % nr;
   octave_idx_type j = n / nr;
 
   return (i < nr && j < nc) ? octave_value (matrix(i,j)) : octave_value ();
 }
 
-template <class T>
+template <typename T>
 octave_value
 octave_base_sparse<T>::map (octave_base_value::unary_mapper_t umap) const
 {
   if (umap == umap_xtolower || umap == umap_xtoupper)
     return matrix;
 
   // Try the map on the dense value.
   // FIXME: We should probably be smarter about this, especially for the
diff --git a/libinterp/octave-value/ov-base-sparse.h b/libinterp/octave-value/ov-base-sparse.h
--- a/libinterp/octave-value/ov-base-sparse.h
+++ b/libinterp/octave-value/ov-base-sparse.h
@@ -38,17 +38,17 @@ along with Octave; see the file COPYING.
 
 #include "boolSparse.h"
 #include "MatrixType.h"
 
 class tree_walker;
 
 class octave_sparse_bool_matrix;
 
-template <class T>
+template <typename T>
 class
 octave_base_sparse : public octave_base_value
 {
 public:
 
   octave_base_sparse (void)
     : octave_base_value (), matrix (), typ (MatrixType ())
   { }
diff --git a/libinterp/octave-value/ov-base.h b/libinterp/octave-value/ov-base.h
--- a/libinterp/octave-value/ov-base.h
+++ b/libinterp/octave-value/ov-base.h
@@ -105,17 +105,17 @@ inline bool btyp_isarray (builtin_type_t
 // uint + uint -> uint (the bigger one)
 // sint + sint -> sint (the bigger one)
 //
 // failing otherwise.
 
 extern OCTINTERP_API
 builtin_type_t btyp_mixed_numeric (builtin_type_t x, builtin_type_t y);
 
-template <class T>
+template <typename T>
 struct class_to_btyp
 {
   static const builtin_type_t btyp = btyp_unknown;
 };
 
 #define DEF_CLASS_TO_BTYP(CLASS,BTYP) \
 template <> \
 struct class_to_btyp<CLASS> \
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -2565,17 +2565,17 @@ compute_attribute_value (tree_classdef_a
         }
 
       return t->expression ()->rvalue1 ();
     }
   else
     return octave_value (true);
 }
 
-template<class T>
+template <typename T>
 static std::string
 attribute_value_to_string (T* t, octave_value v)
 {
   if (v.is_string ())
     return v.string_value ();
   else if (t->expression ())
     return t->expression ()->original_text ();
   else
@@ -3284,17 +3284,17 @@ void
 cdef_package::cdef_package_rep::install_package (const cdef_package& pack,
                                                  const std::string& nm)
 {
   package_map[nm] = pack;
 
   member_count++;
 }
 
-template<class T1, class T2>
+template <typename T1, typename T2>
 Cell
 map2Cell (const std::map<T1, T2>& m)
 {
   Cell retval (1, m.size ());
   int i = 0;
 
   for (typename std::map<T1, T2>::const_iterator it = m.begin ();
        it != m.end (); ++it, ++i)
diff --git a/libinterp/octave-value/ov-int-traits.h b/libinterp/octave-value/ov-int-traits.h
--- a/libinterp/octave-value/ov-int-traits.h
+++ b/libinterp/octave-value/ov-int-traits.h
@@ -28,26 +28,26 @@ along with Octave; see the file COPYING.
 #include "ov-int32.h"
 #include "ov-int64.h"
 
 #include "ov-uint8.h"
 #include "ov-uint16.h"
 #include "ov-uint32.h"
 #include "ov-uint64.h"
 
-template <class T>
+template <typename T>
 class
 octave_value_int_traits
 {
 public:
   typedef T scalar_type;
 };
 
 #define OCTAVE_VALUE_INT_TRAITS(MT, ST) \
-  template<> \
+  template <> \
   class \
   octave_value_int_traits<MT> \
   { \
   public: \
     typedef ST scalar_type; \
   }
 
 OCTAVE_VALUE_INT_TRAITS(int8NDArray, octave_int8_scalar);
diff --git a/libinterp/octave-value/ov-java.h b/libinterp/octave-value/ov-java.h
--- a/libinterp/octave-value/ov-java.h
+++ b/libinterp/octave-value/ov-java.h
@@ -23,17 +23,17 @@ along with Octave; see the file COPYING.
 #if ! defined (octave_ov_java_h)
 #define octave_ov_java_h 1
 
 #include <jni.h>
 
 #include <ovl.h>
 #include <ov.h>
 
-template <class T>
+template <typename T>
 class java_local_ref
 {
 public:
 
   java_local_ref (JNIEnv *_env)
     : jobj (0), detached (false), env (_env) { }
 
   java_local_ref (JNIEnv *_env, T obj)
diff --git a/libinterp/octave-value/ov-usr-fcn.h b/libinterp/octave-value/ov-usr-fcn.h
--- a/libinterp/octave-value/ov-usr-fcn.h
+++ b/libinterp/octave-value/ov-usr-fcn.h
@@ -386,17 +386,17 @@ public:
   // If is_special_expr is true, retrieve the sigular expression that forms the
   // body. May be null (even if is_special_expr is true).
   tree_expression *special_expr (void);
 
   bool subsasgn_optimization_ok (void);
 
   void accept (tree_walker& tw);
 
-  template <class T>
+  template <typename T>
   bool local_protect (T& variable)
   {
     if (curr_unwind_protect_frame)
       {
         curr_unwind_protect_frame->protect_var (variable);
         return true;
       }
     else
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -1645,17 +1645,17 @@ octave_value::vector_value (bool force_s
 {
   Array<double> retval = array_value (force_string_conv);
 
   return retval.reshape (make_vector_dims (retval.dims (),
                                            force_vector_conversion,
                                            type_name (), "real vector"));
 }
 
-template <class T>
+template <typename T>
 static Array<int>
 convert_to_int_array (const Array<octave_int<T> >& A)
 {
   Array<int> retval (A.dims ());
   octave_idx_type n = A.numel ();
 
   for (octave_idx_type i = 0; i < n; i++)
     retval.xelem (i) = octave_int<int> (A.xelem (i));
@@ -1714,17 +1714,17 @@ octave_value::int_vector_value (bool req
         retval = Array<int> (a);
     }
 
   return retval.reshape (make_vector_dims (retval.dims (),
                                            force_vector_conversion,
                                            type_name (), "integer vector"));
 }
 
-template <class T>
+template <typename T>
 static Array<octave_idx_type>
 convert_to_octave_idx_type_array (const Array<octave_int<T> >& A)
 {
   Array<octave_idx_type> retval (A.dims ());
   octave_idx_type n = A.numel ();
 
   for (octave_idx_type i = 0; i < n; i++)
     retval.xelem (i) = octave_int<octave_idx_type> (A.xelem (i));
diff --git a/libinterp/octave-value/ov.h b/libinterp/octave-value/ov.h
--- a/libinterp/octave-value/ov.h
+++ b/libinterp/octave-value/ov.h
@@ -1534,22 +1534,22 @@ OV_BINOP_FN (op_struct_ref)
 OV_COMP_BINOP_FN (op_trans_mul)
 OV_COMP_BINOP_FN (op_mul_trans)
 OV_COMP_BINOP_FN (op_herm_mul)
 OV_COMP_BINOP_FN (op_mul_herm)
 
 extern OCTINTERP_API void install_types (void);
 
 // Templated value extractors.
-template<class Value>
+template <typename Value>
 inline Value octave_value_extract (const octave_value&)
 { assert (false); }
 
 #define DEF_VALUE_EXTRACTOR(VALUE,MPREFIX) \
-template<> \
+template <> \
 inline VALUE octave_value_extract<VALUE> (const octave_value& v) \
   { return v.MPREFIX ## _value (); }
 
 DEF_VALUE_EXTRACTOR (double, scalar)
 DEF_VALUE_EXTRACTOR (float, float_scalar)
 DEF_VALUE_EXTRACTOR (Complex, complex)
 DEF_VALUE_EXTRACTOR (FloatComplex, float_complex)
 DEF_VALUE_EXTRACTOR (bool, bool)
@@ -1603,17 +1603,17 @@ DEF_VALUE_EXTRACTOR (FloatComplexDiagMat
 DEF_VALUE_EXTRACTOR (PermMatrix, perm_matrix)
 
 DEF_VALUE_EXTRACTOR (SparseMatrix, sparse_matrix)
 DEF_VALUE_EXTRACTOR (SparseComplexMatrix, sparse_complex_matrix)
 DEF_VALUE_EXTRACTOR (SparseBoolMatrix, sparse_bool_matrix)
 #undef DEF_VALUE_EXTRACTOR
 
 #define DEF_DUMMY_VALUE_EXTRACTOR(VALUE,DEFVAL) \
-template<> \
+template <> \
 inline VALUE octave_value_extract<VALUE> (const octave_value&) \
   { assert (false); return DEFVAL; }
 
 DEF_DUMMY_VALUE_EXTRACTOR (char, 0)
 DEF_DUMMY_VALUE_EXTRACTOR (octave_value, octave_value ())
 #undef DEF_DUMMY_VALUE_EXTRACTOR
 
 #endif
diff --git a/libinterp/operators/op-dms-template.cc b/libinterp/operators/op-dms-template.cc
--- a/libinterp/operators/op-dms-template.cc
+++ b/libinterp/operators/op-dms-template.cc
@@ -43,17 +43,17 @@ along with Octave; see the file COPYING.
 DEFNDBINOP_OP (sdmmul, SCALAR, MATRIX, SCALARV, MATRIXV, *)
 DEFNDBINOP_OP (dmsmul, MATRIX, SCALAR, MATRIXV, SCALARV, *)
 
 #define OCTAVE_MATRIX CONCAT2(octave_, MATRIX)
 #define OCTAVE_SCALAR CONCAT2(octave_, SCALAR)
 #define MATRIX_VALUE CONCAT2(MATRIXV, _value)
 #define SCALAR_VALUE CONCAT2(SCALARV, _value)
 
-template <class T>
+template <typename T>
 static T
 gripe_if_zero (T x)
 {
   if (x == T ())
     warn_divide_by_zero ();
 
   return x;
 }
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -3934,17 +3934,17 @@ octave_base_parser::set_stmt_print_flag 
       list->pop_back ();
       delete tmp;
     }
 
   return list;
 }
 
 // Finish building a statement.
-template <class T>
+template <typename T>
 tree_statement *
 octave_base_parser::make_statement (T *arg)
 {
   octave_comment_list *comment = lexer.get_comment ();
 
   return new tree_statement (arg, comment);
 }
 
diff --git a/libinterp/parse-tree/parse.h b/libinterp/parse-tree/parse.h
--- a/libinterp/parse-tree/parse.h
+++ b/libinterp/parse-tree/parse.h
@@ -372,17 +372,17 @@ public:
   // Maybe print a warning.  Duh.
   void maybe_warn_missing_semi (tree_statement_list *);
 
   // Set the print flag for a statement based on the separator type.
   tree_statement_list *
   set_stmt_print_flag (tree_statement_list *, char, bool);
 
   // Finish building a statement.
-  template <class T>
+  template <typename T>
   tree_statement *make_statement (T *arg);
 
   // Create a statement list.
   tree_statement_list *make_statement_list (tree_statement *stmt);
 
   // Append a statement to an existing statement list.
   tree_statement_list *
   append_statement_list (tree_statement_list *list, char sep,
diff --git a/libinterp/parse-tree/pt-mat.cc b/libinterp/parse-tree/pt-mat.cc
--- a/libinterp/parse-tree/pt-mat.cc
+++ b/libinterp/parse-tree/pt-mat.cc
@@ -659,17 +659,17 @@ tree_matrix::rvalue (int nargout)
 void
 maybe_warn_string_concat (bool all_dq_strings_p, bool all_sq_strings_p)
 {
   if (! (all_dq_strings_p || all_sq_strings_p))
     warning_with_id ("Octave:mixed-string-concat",
                      "concatenation of different character string types may have unintended consequences");
 }
 
-template<class TYPE, class T>
+template <typename TYPE, typename T>
 static void
 single_type_concat (Array<T>& result,
                     tm_const& tmp)
 {
   octave_idx_type r = 0;
   octave_idx_type c = 0;
 
   for (tm_const::iterator p = tmp.begin (); p != tmp.end (); p++)
@@ -697,17 +697,17 @@ single_type_concat (Array<T>& result,
             }
         }
 
       r += row.rows ();
       c = 0;
     }
 }
 
-template<class TYPE, class T>
+template <typename TYPE, typename T>
 static void
 single_type_concat (Array<T>& result,
                     const dim_vector& dv,
                     tm_const& tmp)
 {
   if (dv.any_zero ())
     {
       result = Array<T> (dv);
@@ -748,17 +748,17 @@ single_type_concat (Array<T>& result,
     }
   else
     {
       result = Array<T> (dv);
       single_type_concat<TYPE> (result, tmp);
     }
 }
 
-template<class TYPE, class T>
+template <typename TYPE, typename T>
 static void
 single_type_concat (Sparse<T>& result,
                     const dim_vector& dv,
                     tm_const& tmp)
 {
   if (dv.any_zero ())
     {
       result = Sparse<T> (dv);
@@ -789,17 +789,17 @@ single_type_concat (Sparse<T>& result,
       Sparse<T> stmp = Sparse<T>::cat (-2, ncols, sparse_list);
       sparse_row_list[j] = stmp;
       j++;
     }
 
   result = Sparse<T>::cat (-1, nrows, sparse_row_list);
 }
 
-template<class MAP>
+template <typename MAP>
 static void
 single_type_concat (octave_map& result,
                     const dim_vector& dv,
                     tm_const& tmp)
 {
   if (dv.any_zero ())
     {
       result = octave_map (dv);
@@ -827,29 +827,29 @@ single_type_concat (octave_map& result,
       octave_map mtmp = octave_map::cat (-2, ncols, map_list);
       map_row_list[j] = mtmp;
       j++;
     }
 
   result = octave_map::cat (-1, nrows, map_row_list);
 }
 
-template<class TYPE>
+template <typename TYPE>
 static octave_value
 do_single_type_concat (const dim_vector& dv,
                        tm_const& tmp)
 {
   TYPE result;
 
   single_type_concat<TYPE> (result, dv, tmp);
 
   return result;
 }
 
-template<>
+template <>
 octave_value
 do_single_type_concat<octave_map> (const dim_vector& dv,
                                    tm_const& tmp)
 {
   octave_map result;
 
   if (tmp.all_1x1_p ())
     single_type_concat<octave_scalar_map> (result, dv, tmp);
diff --git a/liboctave/array/Array-b.cc b/liboctave/array/Array-b.cc
--- a/liboctave/array/Array-b.cc
+++ b/liboctave/array/Array-b.cc
@@ -29,28 +29,28 @@ along with Octave; see the file COPYING.
 #include "Array.h"
 #include "Array.cc"
 #define INLINE_ASCENDING_SORT
 #define INLINE_DESCENDING_SORT
 #include "oct-sort.cc"
 
 // Specialize bool sorting (aka stable partitioning).
 
-template<bool desc>
+template <bool desc>
 static void do_bool_partition (bool *data, octave_idx_type nel)
 {
   octave_idx_type k = 0;
   for (octave_idx_type i = 0; i < nel; i++)
     if (data[i] == desc)
       data[k++] = desc;
   for (octave_idx_type i = k; i < nel; i++)
     data[i] = ! desc;
 }
 
-template<bool desc>
+template <bool desc>
 static void do_bool_partition (bool *data, octave_idx_type *idx,
                                octave_idx_type nel)
 {
   // FIXME: This is essentially a simple bucket sort.
   // Can it be efficiently done by std::partition?
   OCTAVE_LOCAL_BUFFER (octave_idx_type, jdx, nel);
   octave_idx_type k = 0;
   octave_idx_type l = 0;
@@ -67,41 +67,45 @@ static void do_bool_partition (bool *dat
 
   for (octave_idx_type i = k; i < nel; i++)
     {
       data[i] = ! desc;
       idx[i] = jdx[i-k];
     }
 }
 
-template <> template <>
+template <>
+template <>
 void
 octave_sort<bool>::sort (bool *data, octave_idx_type nel,
                          std::less<bool>)
 {
   do_bool_partition<false> (data, nel);
 }
 
-template <> template <>
+template <>
+template <>
 void
 octave_sort<bool>::sort (bool *data, octave_idx_type nel,
                          std::greater<bool>)
 {
   do_bool_partition<true> (data, nel);
 }
 
-template <> template <>
+template <>
+template <>
 void
 octave_sort<bool>::sort (bool *data, octave_idx_type *idx, octave_idx_type nel,
                          std::less<bool>)
 {
   do_bool_partition<false> (data, idx, nel);
 }
 
-template <> template <>
+template <>
+template <>
 void
 octave_sort<bool>::sort (bool *data, octave_idx_type *idx, octave_idx_type nel,
                          std::greater<bool>)
 {
   do_bool_partition<true> (data, idx, nel);
 }
 
 template class OCTAVE_API octave_sort<bool>;
diff --git a/liboctave/array/Array.cc b/liboctave/array/Array.cc
--- a/liboctave/array/Array.cc
+++ b/liboctave/array/Array.cc
@@ -39,17 +39,17 @@ along with Octave; see the file COPYING.
 #include "Array-util.h"
 #include "idx-vector.h"
 #include "lo-error.h"
 #include "oct-locbuf.h"
 
 // One dimensional array class.  Handles the reference counting for
 // all the derived classes.
 
-template <class T>
+template <typename T>
 Array<T>::Array (const Array<T>& a, const dim_vector& dv)
   : dimensions (dv), rep (a.rep),
     slice_data (a.slice_data), slice_len (a.slice_len)
 {
   if (dimensions.safe_numel () != a.numel ())
     {
       std::string dimensions_str = a.dimensions.str ();
       std::string new_dims_str = dimensions.str ();
@@ -60,61 +60,61 @@ Array<T>::Array (const Array<T>& a, cons
     }
 
   // This goes here because if an exception is thrown by the above,
   // destructor will be never called.
   rep->count++;
   dimensions.chop_trailing_singletons ();
 }
 
-template <class T>
+template <typename T>
 void
 Array<T>::fill (const T& val)
 {
   if (rep->count > 1)
     {
       --rep->count;
       rep = new ArrayRep (numel (), val);
       slice_data = rep->data;
     }
   else
     std::fill_n (slice_data, slice_len, val);
 }
 
-template <class T>
+template <typename T>
 void
 Array<T>::clear (void)
 {
   if (--rep->count == 0)
     delete rep;
 
   rep = nil_rep ();
   rep->count++;
   slice_data = rep->data;
   slice_len = rep->len;
 
   dimensions = dim_vector ();
 }
 
-template <class T>
+template <typename T>
 void
 Array<T>::clear (const dim_vector& dv)
 {
   if (--rep->count == 0)
     delete rep;
 
   rep = new ArrayRep (dv.safe_numel ());
   slice_data = rep->data;
   slice_len = rep->len;
 
   dimensions = dv;
   dimensions.chop_trailing_singletons ();
 }
 
-template <class T>
+template <typename T>
 Array<T>
 Array<T>::squeeze (void) const
 {
   Array<T> retval = *this;
 
   if (ndims () > 2)
     {
       bool dims_changed = false;
@@ -157,136 +157,136 @@ Array<T>::squeeze (void) const
         }
 
       retval = Array<T> (*this, new_dimensions);
     }
 
   return retval;
 }
 
-template <class T>
+template <typename T>
 octave_idx_type
 Array<T>::compute_index (octave_idx_type i, octave_idx_type j) const
 {
   return ::compute_index (i, j, dimensions);
 }
 
-template <class T>
+template <typename T>
 octave_idx_type
 Array<T>::compute_index (octave_idx_type i, octave_idx_type j,
                          octave_idx_type k) const
 {
   return ::compute_index (i, j, k, dimensions);
 }
 
-template <class T>
+template <typename T>
 octave_idx_type
 Array<T>::compute_index (const Array<octave_idx_type>& ra_idx) const
 {
   return ::compute_index (ra_idx, dimensions);
 }
 
-template <class T>
+template <typename T>
 T&
 Array<T>::checkelem (octave_idx_type n)
 {
   // Do checks directly to avoid recomputing slice_len.
   if (n < 0)
     err_invalid_index (n);
   if (n >= slice_len)
     err_index_out_of_range (1, 1, n+1, slice_len, dimensions);
 
   return elem (n);
 }
 
-template <class T>
+template <typename T>
 T&
 Array<T>::checkelem (octave_idx_type i, octave_idx_type j)
 {
   return elem (compute_index (i, j));
 }
 
-template <class T>
+template <typename T>
 T&
 Array<T>::checkelem (octave_idx_type i, octave_idx_type j, octave_idx_type k)
 {
   return elem (compute_index (i, j, k));
 }
 
-template <class T>
+template <typename T>
 T&
 Array<T>::checkelem (const Array<octave_idx_type>& ra_idx)
 {
   return elem (compute_index (ra_idx));
 }
 
-template <class T>
+template <typename T>
 typename Array<T>::crefT
 Array<T>::checkelem (octave_idx_type n) const
 {
   // Do checks directly to avoid recomputing slice_len.
   if (n < 0)
     err_invalid_index (n);
   if (n >= slice_len)
     err_index_out_of_range (1, 1, n+1, slice_len, dimensions);
 
   return elem (n);
 }
 
-template <class T>
+template <typename T>
 typename Array<T>::crefT
 Array<T>::checkelem (octave_idx_type i, octave_idx_type j) const
 {
   return elem (compute_index (i, j));
 }
 
-template <class T>
+template <typename T>
 typename Array<T>::crefT
 Array<T>::checkelem (octave_idx_type i, octave_idx_type j,
                      octave_idx_type k) const
 {
   return elem (compute_index (i, j, k));
 }
 
-template <class T>
+template <typename T>
 typename Array<T>::crefT
 Array<T>::checkelem (const Array<octave_idx_type>& ra_idx) const
 {
   return elem (compute_index (ra_idx));
 }
 
-template <class T>
+template <typename T>
 Array<T>
 Array<T>::column (octave_idx_type k) const
 {
   octave_idx_type r = dimensions(0);
 #ifdef ENABLE_BOUNDS_CHECK
   if (k < 0 || k > dimensions.numel (1))
     err_index_out_of_range (2, 2, k+1, dimensions.numel (1), dimensions);
 #endif
 
   return Array<T> (*this, dim_vector (r, 1), k*r, k*r + r);
 }
 
-template <class T>
+template <typename T>
 Array<T>
 Array<T>::page (octave_idx_type k) const
 {
   octave_idx_type r = dimensions(0);
   octave_idx_type c = dimensions(1);
   octave_idx_type p = r*c;
 #ifdef ENABLE_BOUNDS_CHECK
   if (k < 0 || k > dimensions.numel (2))
     err_index_out_of_range (3, 3, k+1, dimensions.numel (2), dimensions);
 #endif
 
   return Array<T> (*this, dim_vector (r, c), k*p, k*p + p);
 }
 
-template <class T>
+template <typename T>
 Array<T>
 Array<T>::linear_slice (octave_idx_type lo, octave_idx_type up) const
 {
 #ifdef ENABLE_BOUNDS_CHECK
   if (lo < 0)
     err_index_out_of_range (1, 1, lo+1, numel (), dimensions);
   if (up > numel ())
     err_index_out_of_range (1, 1, up, numel (), dimensions);
@@ -344,17 +344,17 @@ public:
     // Determine whether we can use block transposes.
     use_blk = top >= 1 && stride[1] == 1 && stride[0] == dim[1];
 
   }
 
   ~rec_permute_helper (void) { delete [] dim; }
 
   // Helper method for fast blocked transpose.
-  template <class T>
+  template <typename T>
   static T *
   blk_trans (const T *src, T *dest, octave_idx_type nr, octave_idx_type nc)
   {
     static const octave_idx_type m = 8;
     OCTAVE_LOCAL_BUFFER (T, blk, m*m);
     for (octave_idx_type kr = 0; kr < nr; kr += m)
       for (octave_idx_type kc = 0; kc < nc; kc += m)
         {
@@ -385,17 +385,17 @@ public:
         }
 
     return dest + nr*nc;
   }
 
 private:
 
   // Recursive N-D generalized transpose
-  template <class T>
+  template <typename T>
   T *do_permute (const T *src, T *dest, int lev) const
   {
     if (lev == 0)
       {
         octave_idx_type step = stride[0];
         octave_idx_type len = dim[0];
         if (step == 1)
           {
@@ -426,22 +426,22 @@ private:
   // No copying!
 
   rec_permute_helper (const rec_permute_helper&);
 
   rec_permute_helper& operator = (const rec_permute_helper&);
 
 public:
 
-  template <class T>
+  template <typename T>
   void permute (const T *src, T *dest) const { do_permute (src, dest, top); }
 };
 
 
-template <class T>
+template <typename T>
 Array<T>
 Array<T>::permute (const Array<octave_idx_type>& perm_vec_arg, bool inv) const
 {
   Array<T> retval;
 
   Array<octave_idx_type> perm_vec = perm_vec_arg;
 
   dim_vector dv = dims ();
@@ -552,51 +552,51 @@ public:
       }
   }
 
   ~rec_index_helper (void) { delete [] idx; delete [] dim; }
 
 private:
 
   // Recursive N-D indexing
-  template <class T>
+  template <typename T>
   T *do_index (const T *src, T *dest, int lev) const
   {
     if (lev == 0)
       dest += idx[0].index (src, dim[0], dest);
     else
       {
         octave_idx_type nn = idx[lev].length (dim[lev]);
         octave_idx_type d = cdim[lev];
         for (octave_idx_type i = 0; i < nn; i++)
           dest = do_index (src + d*idx[lev].xelem (i), dest, lev-1);
       }
 
     return dest;
   }
 
   // Recursive N-D indexed assignment
-  template <class T>
+  template <typename T>
   const T *do_assign (const T *src, T *dest, int lev) const
   {
     if (lev == 0)
       src += idx[0].assign (src, dim[0], dest);
     else
       {
         octave_idx_type nn = idx[lev].length (dim[lev]);
         octave_idx_type d = cdim[lev];
         for (octave_idx_type i = 0; i < nn; i++)
           src = do_assign (src, dest + d*idx[lev].xelem (i), lev-1);
       }
 
     return src;
   }
 
   // Recursive N-D indexed assignment
-  template <class T>
+  template <typename T>
   void do_fill (const T& val, T *dest, int lev) const
   {
     if (lev == 0)
       idx[0].fill (val, dim[0], dest);
     else
       {
         octave_idx_type nn = idx[lev].length (dim[lev]);
         octave_idx_type d = cdim[lev];
@@ -608,23 +608,23 @@ private:
   // No copying!
 
   rec_index_helper (const rec_index_helper&);
 
   rec_index_helper& operator = (const rec_index_helper&);
 
 public:
 
-  template <class T>
+  template <typename T>
   void index (const T *src, T *dest) const { do_index (src, dest, top); }
 
-  template <class T>
+  template <typename T>
   void assign (const T *src, T *dest) const { do_assign (src, dest, top); }
 
-  template <class T>
+  template <typename T>
   void fill (const T& val, T *dest) const { do_fill (val, dest, top); }
 
   bool is_cont_range (octave_idx_type& l,
                       octave_idx_type& u) const
   {
     return top == 0 && idx[0].is_cont_range (dim[0], l, u);
   }
 };
@@ -665,17 +665,17 @@ public:
     cext[0] *= ld;
   }
 
   ~rec_resize_helper (void) { delete [] cext; }
 
 private:
 
   // recursive resizing
-  template <class T>
+  template <typename T>
   void do_resize_fill (const T* src, T *dest, const T& rfv, int lev) const
   {
     if (lev == 0)
       {
         std::copy (src, src+cext[0], dest);
         std::fill_n (dest + cext[0], dext[0] - cext[0], rfv);
       }
     else
@@ -693,22 +693,22 @@ private:
   // No copying!
 
   rec_resize_helper (const rec_resize_helper&);
 
   rec_resize_helper& operator = (const rec_resize_helper&);
 
 public:
 
-  template <class T>
+  template <typename T>
   void resize_fill (const T* src, T *dest, const T& rfv) const
   { do_resize_fill (src, dest, rfv, n-1); }
 };
 
-template <class T>
+template <typename T>
 Array<T>
 Array<T>::index (const idx_vector& i) const
 {
   octave_idx_type n = numel ();
   Array<T> retval;
 
   if (i.is_colon ())
     {
@@ -762,17 +762,17 @@ Array<T>::index (const idx_vector& i) co
           if (il != 0)
             i.index (data (), n, retval.fortran_vec ());
         }
     }
 
   return retval;
 }
 
-template <class T>
+template <typename T>
 Array<T>
 Array<T>::index (const idx_vector& i, const idx_vector& j) const
 {
   // Get dimensions, allowing Fortran indexing in the 2nd dim.
   dim_vector dv = dimensions.redim (2);
   octave_idx_type r = dv(0);
   octave_idx_type c = dv(1);
   Array<T> retval;
@@ -820,17 +820,17 @@ Array<T>::index (const idx_vector& i, co
           for (octave_idx_type k = 0; k < jl; k++)
             dest += i.index (src + r * j.xelem (k), r, dest);
         }
     }
 
   return retval;
 }
 
-template <class T>
+template <typename T>
 Array<T>
 Array<T>::index (const Array<idx_vector>& ia) const
 {
   int ial = ia.numel ();
   Array<T> retval;
 
   // FIXME: is this dispatching necessary?
   if (ial == 1)
@@ -884,28 +884,28 @@ Array<T>::index (const Array<idx_vector>
         }
     }
 
   return retval;
 }
 
 // The default fill value.  Override if you want a different one.
 
-template <class T>
+template <typename T>
 T
 Array<T>::resize_fill_value (void) const
 {
   static T zero = T ();
   return zero;
 }
 
 // Yes, we could do resize using index & assign.  However, that would
 // possibly involve a lot more memory traffic than we actually need.
 
-template <class T>
+template <typename T>
 void
 Array<T>::resize1 (octave_idx_type n, const T& rfv)
 {
   if (n < 0 || ndims () != 2)
     err_invalid_resize ();
 
   dim_vector dv;
   // This is driven by Matlab's behaviour of giving a *row* vector
@@ -966,17 +966,17 @@ Array<T>::resize1 (octave_idx_type n, co
       octave_idx_type n1 = n - n0;
       std::copy (data (), data () + n0, dest);
       std::fill_n (dest + n0, n1, rfv);
 
       *this = tmp;
     }
 }
 
-template <class T>
+template <typename T>
 void
 Array<T>::resize2 (octave_idx_type r, octave_idx_type c, const T& rfv)
 {
   if (r < 0 || c < 0 || ndims () != 2)
     err_invalid_resize ();
 
   octave_idx_type rx = rows ();
   octave_idx_type cx = columns ();
@@ -1008,17 +1008,17 @@ Array<T>::resize2 (octave_idx_type r, oc
         }
 
       std::fill_n (dest, r * c1, rfv);
 
       *this = tmp;
     }
 }
 
-template<class T>
+template <typename T>
 void
 Array<T>::resize (const dim_vector& dv, const T& rfv)
 {
   int dvl = dv.length ();
   if (dvl == 2)
     resize2 (dv(0), dv(1), rfv);
   else if (dimensions != dv)
     {
@@ -1030,17 +1030,17 @@ Array<T>::resize (const dim_vector& dv, 
       rec_resize_helper rh (dv, dimensions.redim (dvl));
 
       // Do it.
       rh.resize_fill (data (), tmp.fortran_vec (), rfv);
       *this = tmp;
     }
 }
 
-template <class T>
+template <typename T>
 Array<T>
 Array<T>::index (const idx_vector& i, bool resize_ok, const T& rfv) const
 {
   Array<T> tmp = *this;
   if (resize_ok)
     {
       octave_idx_type n = numel ();
       octave_idx_type nx = i.extent (n);
@@ -1054,17 +1054,17 @@ Array<T>::index (const idx_vector& i, bo
 
       if (tmp.numel () != nx)
         return Array<T> ();
     }
 
   return tmp.index (i);
 }
 
-template <class T>
+template <typename T>
 Array<T>
 Array<T>::index (const idx_vector& i, const idx_vector& j,
                  bool resize_ok, const T& rfv) const
 {
   Array<T> tmp = *this;
   if (resize_ok)
     {
       dim_vector dv = dimensions.redim (2);
@@ -1082,17 +1082,17 @@ Array<T>::index (const idx_vector& i, co
 
       if (tmp.rows () != rx || tmp.columns () != cx)
         return Array<T> ();
     }
 
   return tmp.index (i, j);
 }
 
-template <class T>
+template <typename T>
 Array<T>
 Array<T>::index (const Array<idx_vector>& ia,
                  bool resize_ok, const T& rfv) const
 {
   Array<T> tmp = *this;
   if (resize_ok)
     {
       int ial = ia.numel ();
@@ -1114,17 +1114,17 @@ Array<T>::index (const Array<idx_vector>
             return Array<T> ();
         }
     }
 
   return tmp.index (ia);
 }
 
 
-template <class T>
+template <typename T>
 void
 Array<T>::assign (const idx_vector& i, const Array<T>& rhs, const T& rfv)
 {
   octave_idx_type n = numel ();
   octave_idx_type rhl = rhs.numel ();
 
   if (rhl != 1 && i.length (n) != rhl)
     err_nonconformant ("=", dim_vector(i.length(n),1), rhs.dims());
@@ -1161,17 +1161,17 @@ Array<T>::assign (const idx_vector& i, c
       if (rhl == 1)
         i.fill (rhs(0), n, fortran_vec ());
       else
         i.assign (rhs.data (), n, fortran_vec ());
     }
 }
 
 // Assignment to a 2-dimensional array
-template <class T>
+template <typename T>
 void
 Array<T>::assign (const idx_vector& i, const idx_vector& j,
                   const Array<T>& rhs, const T& rfv)
 {
   bool initial_dims_all_zero = dimensions.all_zero ();
 
   // Get RHS extents, discarding singletons.
   dim_vector rhdv = rhs.dims ();
@@ -1265,17 +1265,17 @@ Array<T>::assign (const idx_vector& i, c
         }
     }
   // any empty RHS can be assigned to an empty LHS
   else if ((il != 0 && jl != 0) || (rhdv(0) != 0 && rhdv(1) != 0))
     err_nonconformant ("=", il, jl, rhs.dim1 (), rhs.dim2 ());
 }
 
 // Assignment to a multi-dimensional array
-template <class T>
+template <typename T>
 void
 Array<T>::assign (const Array<idx_vector>& ia,
                   const Array<T>& rhs, const T& rfv)
 {
   int ial = ia.numel ();
 
   // FIXME: is this dispatching necessary / desirable?
   if (ial == 1)
@@ -1388,17 +1388,17 @@ Array<T>::assign (const Array<idx_vector
 /*
 %!shared a
 %! a = [1 2; 3 4];
 %!error <op1 is 1x2, op2 is 1x3> a(1,:) = [1 2 3]
 %!error <op1 is 2x1, op2 is 1x3> a(:,1) = [1 2 3]
 %!error <op1 is 2x2, op2 is 2x1> a(1:2,2:3) = [1;2]
 */
 
-template <class T>
+template <typename T>
 void
 Array<T>::delete_elements (const idx_vector& i)
 {
   octave_idx_type n = numel ();
   if (i.is_colon ())
     {
       *this = Array<T> ();
     }
@@ -1428,17 +1428,17 @@ Array<T>::delete_elements (const idx_vec
       else
         {
           // Use index.
           *this = index (i.complement (n));
         }
     }
 }
 
-template <class T>
+template <typename T>
 void
 Array<T>::delete_elements (int dim, const idx_vector& i)
 {
   if (dim < 0 || dim >= ndims ())
     (*current_liboctave_error_handler) ("invalid dimension in delete_elements");
 
   octave_idx_type n = dimensions(dim);
   if (i.is_colon ())
@@ -1484,17 +1484,17 @@ Array<T>::delete_elements (int dim, cons
           // Use index.
           Array<idx_vector> ia (dim_vector (ndims (), 1), idx_vector::colon);
           ia (dim) = i.complement (n);
           *this = index (ia);
         }
     }
 }
 
-template <class T>
+template <typename T>
 void
 Array<T>::delete_elements (const Array<idx_vector>& ia)
 {
   int ial = ia.numel ();
 
   if (ial == 1)
     delete_elements (ia(0));
   else
@@ -1561,17 +1561,17 @@ Array<T>::delete_elements (const Array<i
           if (! empty_assignment)
             (*current_liboctave_error_handler)
               ("a null assignment can only have one non-colon index");
         }
     }
 
 }
 
-template <class T>
+template <typename T>
 Array<T>&
 Array<T>::insert (const Array<T>& a, octave_idx_type r, octave_idx_type c)
 {
   idx_vector i (r, r + a.rows ());
   idx_vector j (c, c + a.columns ());
   if (ndims () == 2 && a.ndims () == 2)
     assign (i, j, a);
   else
@@ -1582,33 +1582,33 @@ Array<T>::insert (const Array<T>& a, oct
       for (int k = 2; k < a.ndims (); k++)
         idx(k) = idx_vector (0, a.dimensions(k));
       assign (idx, a);
     }
 
   return *this;
 }
 
-template <class T>
+template <typename T>
 Array<T>&
 Array<T>::insert (const Array<T>& a, const Array<octave_idx_type>& ra_idx)
 {
   octave_idx_type n = ra_idx.numel ();
   Array<idx_vector> idx (dim_vector (n, 1));
   const dim_vector dva = a.dims ().redim (n);
   for (octave_idx_type k = 0; k < n; k++)
     idx(k) = idx_vector (ra_idx(k), ra_idx(k) + dva(k));
 
   assign (idx, a);
 
   return *this;
 }
 
 
-template <class T>
+template <typename T>
 Array<T>
 Array<T>::transpose (void) const
 {
   assert (ndims () == 2);
 
   octave_idx_type nr = dim1 ();
   octave_idx_type nc = dim2 ();
 
@@ -1634,24 +1634,24 @@ Array<T>::transpose (void) const
     }
   else
     {
       // Fast transpose for vectors and empty matrices.
       return Array<T> (*this, dim_vector (nc, nr));
     }
 }
 
-template <class T>
+template <typename T>
 static T
 no_op_fcn (const T& x)
 {
   return x;
 }
 
-template <class T>
+template <typename T>
 Array<T>
 Array<T>::hermitian (T (*fcn) (const T&)) const
 {
   assert (ndims () == 2);
 
   if (! fcn)
     fcn = no_op_fcn<T>;
 
@@ -1740,34 +1740,34 @@ Array<T>::hermitian (T (*fcn) (const T&)
 %!assert ((1i*[m8, m8; m8, m8]).', 1i * [mt8, mt8; mt8, mt8])
 %!assert ((1i*[m8, m8; m8, m8])', conj (1i * [mt8, mt8; mt8, mt8]))
 %!assert ([m9, m8; m9, m8]', [mt9, mt9; mt8, mt8])
 %!assert ((1i*[m9, m8; m9, m8]).', 1i * [mt9, mt9; mt8, mt8])
 %!assert ((1i*[m9, m8; m9, m8])', conj (1i * [mt9, mt9; mt8, mt8]))
 
 */
 
-template <class T>
+template <typename T>
 T *
 Array<T>::fortran_vec (void)
 {
   make_unique ();
 
   return slice_data;
 }
 
 // Non-real types don't have NaNs.
-template <class T>
+template <typename T>
 inline bool
 sort_isnan (typename ref_param<T>::type)
 {
   return false;
 }
 
-template <class T>
+template <typename T>
 Array<T>
 Array<T>::sort (int dim, sortmode mode) const
 {
   if (dim < 0)
     (*current_liboctave_error_handler) ("sort: invalid dimension");
 
   Array<T> m (dims ());
 
@@ -1873,17 +1873,17 @@ Array<T>::sort (int dim, sortmode mode) 
           for (octave_idx_type i = 0; i < ns; i++)
             v[i*stride + offset] = buf[i];
         }
     }
 
   return m;
 }
 
-template <class T>
+template <typename T>
 Array<T>
 Array<T>::sort (Array<octave_idx_type> &sidx, int dim,
                 sortmode mode) const
 {
   if (dim < 0 || dim >= ndims ())
     (*current_liboctave_error_handler) ("sort: invalid dimension");
 
   Array<T> m (dims ());
@@ -2021,30 +2021,30 @@ Array<T>::sort (Array<octave_idx_type> &
           for (octave_idx_type i = 0; i < ns; i++)
             vi[i*stride + offset] = bufi[i];
         }
     }
 
   return m;
 }
 
-template <class T>
+template <typename T>
 typename Array<T>::compare_fcn_type
 safe_comparator (sortmode mode, const Array<T>& /* a */,
                  bool /* allow_chk */)
 {
   if (mode == ASCENDING)
     return octave_sort<T>::ascending_compare;
   else if (mode == DESCENDING)
     return octave_sort<T>::descending_compare;
   else
     return 0;
 }
 
-template <class T>
+template <typename T>
 sortmode
 Array<T>::is_sorted (sortmode mode) const
 {
   octave_sort<T> lsort;
 
   octave_idx_type n = numel ();
 
   if (n <= 1)
@@ -2069,17 +2069,17 @@ Array<T>::is_sorted (sortmode mode) cons
       if (! lsort.is_sorted (data (), n))
         mode = UNSORTED;
     }
 
   return mode;
 
 }
 
-template <class T>
+template <typename T>
 Array<octave_idx_type>
 Array<T>::sort_rows_idx (sortmode mode) const
 {
   Array<octave_idx_type> idx;
 
   octave_sort<T> lsort (safe_comparator (mode, *this, true));
 
   octave_idx_type r = rows ();
@@ -2088,17 +2088,17 @@ Array<T>::sort_rows_idx (sortmode mode) 
   idx = Array<octave_idx_type> (dim_vector (r, 1));
 
   lsort.sort_rows (data (), idx.fortran_vec (), r, c);
 
   return idx;
 }
 
 
-template <class T>
+template <typename T>
 sortmode
 Array<T>::is_sorted_rows (sortmode mode) const
 {
   octave_sort<T> lsort;
 
   octave_idx_type r = rows ();
   octave_idx_type c = cols ();
 
@@ -2149,17 +2149,17 @@ Array<T>::is_sorted_rows (sortmode mode)
         mode = UNSORTED;
     }
 
   return mode;
 
 }
 
 // Do a binary lookup in a sorted array.
-template <class T>
+template <typename T>
 octave_idx_type
 Array<T>::lookup (const T& value, sortmode mode) const
 {
   octave_idx_type n = numel ();
   octave_sort<T> lsort;
 
   if (mode == UNSORTED)
     {
@@ -2170,17 +2170,17 @@ Array<T>::lookup (const T& value, sortmo
         mode = ASCENDING;
     }
 
   lsort.set_compare (mode);
 
   return lsort.lookup (data (), n, value);
 }
 
-template <class T>
+template <typename T>
 Array<octave_idx_type>
 Array<T>::lookup (const Array<T>& values, sortmode mode) const
 {
   octave_idx_type n = numel ();
   octave_idx_type nval = values.numel ();
   octave_sort<T> lsort;
   Array<octave_idx_type> idx (values.dims ());
 
@@ -2214,32 +2214,32 @@ Array<T>::lookup (const Array<T>& values
     lsort.lookup_sorted (data (), n, values.data (), nval,
                          idx.fortran_vec (), vmode != mode);
   else
     lsort.lookup (data (), n, values.data (), nval, idx.fortran_vec ());
 
   return idx;
 }
 
-template <class T>
+template <typename T>
 octave_idx_type
 Array<T>::nnz (void) const
 {
   const T *src = data ();
   octave_idx_type nel = numel ();
   octave_idx_type retval = 0;
   const T zero = T ();
   for (octave_idx_type i = 0; i < nel; i++)
     if (src[i] != zero)
       retval++;
 
   return retval;
 }
 
-template <class T>
+template <typename T>
 Array<octave_idx_type>
 Array<T>::find (octave_idx_type n, bool backward) const
 {
   Array<octave_idx_type> retval;
   const T *src = data ();
   octave_idx_type nel = numel ();
   const T zero = T ();
   if (n < 0 || n >= nel)
@@ -2310,17 +2310,17 @@ Array<T>::find (octave_idx_type n, bool 
       || (rows () == 0 && dims ().numel (1) == 0))
     retval.dimensions = dim_vector ();
   else if (rows () == 1 && ndims () == 2)
     retval.dimensions = dim_vector (1, retval.numel ());
 
   return retval;
 }
 
-template <class T>
+template <typename T>
 Array<T>
 Array<T>::nth_element (const idx_vector& n, int dim) const
 {
   if (dim < 0)
     (*current_liboctave_error_handler) ("nth_element: invalid dimension");
 
   dim_vector dv = dims ();
   if (dim >= dv.length ())
@@ -2498,17 +2498,17 @@ Array<T>::nnz (void) const\
 template <> Array<octave_idx_type> \
 Array<T>::find (octave_idx_type, bool) const\
 { return Array<octave_idx_type> (); } \
  \
 template <> Array<T>  \
 Array<T>::nth_element (const idx_vector&, int) const { return Array<T> (); }
 
 
-template <class T>
+template <typename T>
 Array<T>
 Array<T>::diag (octave_idx_type k) const
 {
   dim_vector dv = dims ();
   octave_idx_type nd = dv.length ();
   Array<T> d;
 
   if (nd > 2)
@@ -2584,32 +2584,32 @@ Array<T>::diag (octave_idx_type k) const
           for (octave_idx_type i = 0; i < nnr; i++)
             d.xelem (i+roff, i+coff) = elem (i, 0);
         }
     }
 
   return d;
 }
 
-template <class T>
+template <typename T>
 Array<T>
 Array<T>::diag (octave_idx_type m, octave_idx_type n) const
 {
   if (ndims () != 2 || (rows () != 1 && cols () != 1))
     (*current_liboctave_error_handler) ("cat: invalid dimension");
 
   Array<T> retval (dim_vector (m, n), resize_fill_value ());
 
   for (octave_idx_type i = 0; i < numel (); i++)
     retval.xelem (i, i) = xelem (i);
 
   return retval;
 }
 
-template <class T>
+template <typename T>
 Array<T>
 Array<T>::cat (int dim, octave_idx_type n, const Array<T> *array_list)
 {
   // Default concatenation.
   bool (dim_vector::*concat_rule) (const dim_vector&, int) = &dim_vector::concat;
 
   if (dim == -1 || dim == -2)
     {
@@ -2703,58 +2703,58 @@ Array<T>::cat (int dim, octave_idx_type 
       retval.assign (idxa, array_list[i]);
 
       l = u;
     }
 
   return retval;
 }
 
-template <class T>
+template <typename T>
 void
 Array<T>::print_info (std::ostream& os, const std::string& prefix) const
 {
   os << prefix << "rep address: " << rep << '\n'
      << prefix << "rep->len:    " << rep->len << '\n'
      << prefix << "rep->data:   " << static_cast<void *> (rep->data) << '\n'
      << prefix << "rep->count:  " << rep->count << '\n'
      << prefix << "slice_data:  " << static_cast<void *> (slice_data) << '\n'
      << prefix << "slice_len:   " << slice_len << '\n';
 
   // 2D info:
   //
   //     << pefix << "rows: " << rows () << "\n"
   //     << prefix << "cols: " << cols () << "\n";
 }
 
-template <class T>
+template <typename T>
 bool Array<T>::optimize_dimensions (const dim_vector& dv)
 {
   bool retval = dimensions == dv;
   if (retval)
     dimensions = dv;
 
   return retval;
 }
 
-template <class T>
+template <typename T>
 void Array<T>::instantiation_guard ()
 {
   // This guards against accidental implicit instantiations.
   // Array<T> instances should always be explicit and use INSTANTIATE_ARRAY.
   T::__xXxXx__ ();
 }
 
 #define INSTANTIATE_ARRAY(T, API) \
   template <> void Array<T>::instantiation_guard () { } \
   template class API Array<T>
 
 // FIXME: is this used?
 
-template <class T>
+template <typename T>
 std::ostream&
 operator << (std::ostream& os, const Array<T>& a)
 {
   dim_vector a_dims = a.dims ();
 
   int n_dims = a_dims.length ();
 
   os << n_dims << "-dimensional array";
diff --git a/liboctave/array/Array.h b/liboctave/array/Array.h
--- a/liboctave/array/Array.h
+++ b/liboctave/array/Array.h
@@ -36,17 +36,17 @@ along with Octave; see the file COPYING.
 #include "idx-vector.h"
 #include "lo-traits.h"
 #include "lo-utils.h"
 #include "oct-sort.h"
 #include "quit.h"
 #include "oct-refcount.h"
 
 //! Handles the reference counting for all the derived classes.
-template <class T>
+template <typename T>
 class
 Array
 {
 protected:
 
   //! The real representation of all arrays.
   class ArrayRep
   {
@@ -57,17 +57,17 @@ protected:
     octave_refcount<int> count;
 
     ArrayRep (T *d, octave_idx_type l)
       : data (new T [l]), len (l), count (1)
     {
       std::copy (d, d+l, data);
     }
 
-    template <class U>
+    template <typename U>
     ArrayRep (U *d, octave_idx_type l)
       : data (new T [l]), len (l), count (1)
     {
       std::copy (d, d+l, data);
     }
 
     ArrayRep (void) : data (0), len (0), count (1) { }
 
@@ -195,17 +195,17 @@ public:
     fill (val);
     dimensions.chop_trailing_singletons ();
   }
 
   //! Reshape constructor.
   Array (const Array<T>& a, const dim_vector& dv);
 
   //! Type conversion case.
-  template <class U>
+  template <typename U>
   Array (const Array<U>& a)
     : dimensions (a.dims ()),
       rep (new typename Array<T>::ArrayRep (a.data (), a.numel ())),
       slice_data (rep->data), slice_len (rep->len)
   { }
 
   //! No type conversion case.
   Array (const Array<T>& a)
@@ -655,17 +655,17 @@ public:
   //! to cat(). dim = -1 corresponds to dim = 0 and dim = -2
   //! corresponds to dim = 1, but apply the looser matching rules of
   //! vertcat/horzcat.
   static Array<T>
   cat (int dim, octave_idx_type n, const Array<T> *array_list);
 
   //! Apply function fcn to each element of the Array<T>. This function
   //! is optimised with a manually unrolled loop.
-  template <class U, class F>
+  template <typename U, typename F>
   Array<U>
   map (F fcn) const
   {
     octave_idx_type len = numel ();
 
     const T *m = data ();
 
     Array<U> result (dims ());
@@ -687,41 +687,41 @@ public:
     for (; i < len; i++)
       p[i] = fcn (m[i]);
 
     return result;
   }
 
   //@{
   //! Overloads for function references.
-  template <class U>
+  template <typename U>
   Array<U>
   map (U (&fcn) (T)) const
   { return map<U, U (&) (T)> (fcn); }
 
-  template <class U>
+  template <typename U>
   Array<U>
   map (U (&fcn) (const T&)) const
   { return map<U, U (&) (const T&)> (fcn); }
   //@}
 
   //! Generic any/all test functionality with arbitrary predicate.
-  template <class F, bool zero>
+  template <typename F, bool zero>
   bool test (F fcn) const
   {
     return any_all_test<F, T, zero> (fcn, data (), numel ());
   }
 
   //@{
   //! Simpler calls.
-  template <class F>
+  template <typename F>
   bool test_any (F fcn) const
   { return test<F, false> (fcn); }
 
-  template <class F>
+  template <typename F>
   bool test_all (F fcn) const
   { return test<F, true> (fcn); }
   //@}
 
   //@{
   //! Overloads for function references.
   bool test_any (bool (&fcn) (T)) const
   { return test<bool (&) (T), false> (fcn); }
@@ -731,17 +731,17 @@ public:
 
   bool test_all (bool (&fcn) (T)) const
   { return test<bool (&) (T), true> (fcn); }
 
   bool test_all (bool (&fcn) (const T&)) const
   { return test<bool (&) (const T&), true> (fcn); }
   //@}
 
-  template <class U> friend class Array;
+  template <typename U> friend class Array;
 
   //! Returns true if this->dims () == dv, and if so, replaces this->dimensions
   //! by a shallow copy of dv. This is useful for maintaining several arrays with
   //! supposedly equal dimensions (e.g. structs in the interpreter).
   bool optimize_dimensions (const dim_vector& dv);
 
   //@{
   //! WARNING: Only call these functions from jit
@@ -759,40 +759,40 @@ private:
   static void instantiation_guard ();
 };
 
 //! This is a simple wrapper template that will subclass an Array<T>
 //! type or any later type derived from it and override the default
 //! non-const operator() to not check for the array's uniqueness. It
 //! is, however, the user's responsibility to ensure the array is
 //! actually unaliased whenever elements are accessed.
-template<class ArrayClass>
+template <typename ArrayClass>
 class NoAlias : public ArrayClass
 {
   typedef typename ArrayClass::element_type T;
 public:
   NoAlias () : ArrayClass () { }
 
   // FIXME: this would be simpler once C++0x is available
-  template <class X>
+  template <typename X>
     explicit NoAlias (X x) : ArrayClass (x) { }
 
-  template <class X, class Y>
+  template <typename X, typename Y>
     explicit NoAlias (X x, Y y) : ArrayClass (x, y) { }
 
-  template <class X, class Y, class Z>
+  template <typename X, typename Y, typename Z>
     explicit NoAlias (X x, Y y, Z z) : ArrayClass (x, y, z) { }
 
   T& operator () (octave_idx_type n)
   { return ArrayClass::xelem (n); }
   T& operator () (octave_idx_type i, octave_idx_type j)
   { return ArrayClass::xelem (i, j); }
   T& operator () (octave_idx_type i, octave_idx_type j, octave_idx_type k)
   { return ArrayClass::xelem (i, j, k); }
   T& operator () (const Array<octave_idx_type>& ra_idx)
   { return ArrayClass::xelem (ra_idx); }
 };
 
-template <class T>
+template <typename T>
 std::ostream&
 operator << (std::ostream& os, const Array<T>& a);
 
 #endif
diff --git a/liboctave/array/CDiagMatrix.h b/liboctave/array/CDiagMatrix.h
--- a/liboctave/array/CDiagMatrix.h
+++ b/liboctave/array/CDiagMatrix.h
@@ -60,17 +60,17 @@ public:
   explicit ComplexDiagMatrix (const DiagMatrix& a);
 
   ComplexDiagMatrix (const MDiagArray2<Complex>& a)
     : MDiagArray2<Complex> (a) { }
 
   ComplexDiagMatrix (const ComplexDiagMatrix& a)
     : MDiagArray2<Complex> (a) { }
 
-  template <class U>
+  template <typename U>
   ComplexDiagMatrix (const DiagArray2<U>& a)
     : MDiagArray2<Complex> (a) { }
 
   ComplexDiagMatrix& operator = (const ComplexDiagMatrix& a)
   {
     MDiagArray2<Complex>::operator = (a);
     return *this;
   }
diff --git a/liboctave/array/CMatrix.h b/liboctave/array/CMatrix.h
--- a/liboctave/array/CMatrix.h
+++ b/liboctave/array/CMatrix.h
@@ -54,20 +54,20 @@ public:
 
   ComplexMatrix (const dim_vector& dv) : ComplexNDArray (dv.redim (2)) { }
 
   ComplexMatrix (const dim_vector& dv, const Complex& val)
     : ComplexNDArray (dv.redim (2), val) { }
 
   ComplexMatrix (const ComplexMatrix& a) : ComplexNDArray (a) { }
 
-  template <class U>
+  template <typename U>
   ComplexMatrix (const MArray<U>& a) : ComplexNDArray (a.as_matrix ()) { }
 
-  template <class U>
+  template <typename U>
   ComplexMatrix (const Array<U>& a) : ComplexNDArray (a.as_matrix ()) { }
 
   ComplexMatrix (const Matrix& re, const Matrix& im);
 
   explicit ComplexMatrix (const Matrix& a);
 
   explicit ComplexMatrix (const RowVector& rv);
 
diff --git a/liboctave/array/CNDArray.h b/liboctave/array/CNDArray.h
--- a/liboctave/array/CNDArray.h
+++ b/liboctave/array/CNDArray.h
@@ -39,20 +39,20 @@ public:
 
   ComplexNDArray (const dim_vector& dv) : MArray<Complex> (dv) { }
 
   ComplexNDArray (const dim_vector& dv, const Complex& val)
     : MArray<Complex> (dv, val) { }
 
   ComplexNDArray (const ComplexNDArray& a) : MArray<Complex> (a) { }
 
-  template <class U>
+  template <typename U>
   ComplexNDArray (const MArray<U>& a) : MArray<Complex> (a) { }
 
-  template <class U>
+  template <typename U>
   ComplexNDArray (const Array<U>& a) : MArray<Complex> (a) { }
 
   ComplexNDArray (const charNDArray&);
 
   ComplexNDArray& operator = (const ComplexNDArray& a)
   {
     MArray<Complex>::operator = (a);
     return *this;
diff --git a/liboctave/array/DiagArray2.cc b/liboctave/array/DiagArray2.cc
--- a/liboctave/array/DiagArray2.cc
+++ b/liboctave/array/DiagArray2.cc
@@ -31,34 +31,34 @@ along with Octave; see the file COPYING.
 #include <iostream>
 
 #include <algorithm>
 
 #include "DiagArray2.h"
 
 #include "lo-error.h"
 
-template <class T>
+template <typename T>
 DiagArray2<T>::DiagArray2 (const Array<T>& a, octave_idx_type r,
                            octave_idx_type c)
   : Array<T> (a.as_column ()), d1 (r), d2 (c)
 {
   octave_idx_type rcmin = std::min (r, c);
   if (rcmin != a.numel ())
     Array<T>::resize (dim_vector (rcmin, 1));
 }
 
-template <class T>
+template <typename T>
 Array<T>
 DiagArray2<T>::diag (octave_idx_type k) const
 {
   return extract_diag (k);
 }
 
-template <class T>
+template <typename T>
 Array<T>
 DiagArray2<T>::extract_diag (octave_idx_type k) const
 {
   Array<T> d;
 
   if (k == 0)
     // The main diagonal is shallow-copied.
     d = *this;
@@ -67,48 +67,48 @@ DiagArray2<T>::extract_diag (octave_idx_
   else if (k < 0 && -k < rows ())
     d = Array<T> (dim_vector (std::min (rows () + k, cols ()), 1), T ());
   else  // Matlab returns [] 0x1 for out-of-range diagonal
     d.resize (dim_vector (0, 1));
 
   return d;
 }
 
-template <class T>
+template <typename T>
 DiagArray2<T>
 DiagArray2<T>::transpose (void) const
 {
   return DiagArray2<T> (*this, d2, d1);
 }
 
-template <class T>
+template <typename T>
 DiagArray2<T>
 DiagArray2<T>::hermitian (T (* fcn) (const T&)) const
 {
   return DiagArray2<T> (Array<T>::template map<T> (fcn), d2, d1);
 }
 
 // A two-dimensional array with diagonal elements only.
 
-template <class T>
+template <typename T>
 void
 DiagArray2<T>::resize (octave_idx_type r, octave_idx_type c,
                        const T& rfv)
 {
   if (r < 0 || c < 0)
     (*current_liboctave_error_handler) ("can't resize to negative dimensions");
 
   if (r != dim1 () || c != dim2 ())
     {
       Array<T>::resize (dim_vector (std::min (r, c), 1), rfv);
       d1 = r; d2 = c;
     }
 }
 
-template <class T>
+template <typename T>
 Array<T>
 DiagArray2<T>::array_value (void) const
 {
   Array<T> result (dims (), T (0));
 
   for (octave_idx_type i = 0, len = length (); i < len; i++)
     result.xelem (i, i) = dgelem (i);
 
diff --git a/liboctave/array/DiagArray2.h b/liboctave/array/DiagArray2.h
--- a/liboctave/array/DiagArray2.h
+++ b/liboctave/array/DiagArray2.h
@@ -29,17 +29,17 @@ along with Octave; see the file COPYING.
 #include <cassert>
 #include <cstdlib>
 
 #include "Array.h"
 
 // Array<T> is inherited privately so that some methods, like index, don't
 // produce unexpected results.
 
-template <class T>
+template <typename T>
 class
 DiagArray2 : protected Array<T>
 {
 protected:
   octave_idx_type d1, d2;
 
 public:
 
@@ -57,17 +57,17 @@ public:
   explicit DiagArray2 (const Array<T>& a)
     : Array<T> (a.as_column ()), d1 (a.numel ()), d2 (a.numel ()) { }
 
   DiagArray2 (const Array<T>& a, octave_idx_type r, octave_idx_type c);
 
   DiagArray2 (const DiagArray2<T>& a)
     : Array<T> (a), d1 (a.d1), d2 (a.d2) { }
 
-  template <class U>
+  template <typename U>
   DiagArray2 (const DiagArray2<U>& a)
     : Array<T> (a.extract_diag ()), d1 (a.dim1 ()), d2 (a.dim2 ()) { }
 
   ~DiagArray2 (void) { }
 
   DiagArray2<T>& operator = (const DiagArray2<T>& a)
   {
     if (this != &a)
diff --git a/liboctave/array/MArray.cc b/liboctave/array/MArray.cc
--- a/liboctave/array/MArray.cc
+++ b/liboctave/array/MArray.cc
@@ -24,37 +24,37 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "MArray.h"
 #include "Array-util.h"
 #include "lo-error.h"
 
-template <class T>
+template <typename T>
 struct _idxadds_helper
 {
   T *array;
   T val;
   _idxadds_helper (T *a, T v) : array (a), val (v) { }
   void operator () (octave_idx_type i)
   { array[i] += val; }
 };
 
-template <class T>
+template <typename T>
 struct _idxadda_helper
 {
   T *array;
   const T *vals;
   _idxadda_helper (T *a, const T *v) : array (a), vals (v) { }
   void operator () (octave_idx_type i)
   { array[i] += *vals++; }
 };
 
-template <class T>
+template <typename T>
 void
 MArray<T>::idx_add (const idx_vector& idx, T val)
 {
   octave_idx_type n = this->numel ();
   octave_idx_type ext = idx.extent (n);
   if (ext > n)
     {
       this->resize1 (ext);
@@ -62,17 +62,17 @@ MArray<T>::idx_add (const idx_vector& id
     }
 
   octave_quit ();
 
   octave_idx_type len = idx.length (n);
   idx.loop (len, _idxadds_helper<T> (this->fortran_vec (), val));
 }
 
-template <class T>
+template <typename T>
 void
 MArray<T>::idx_add (const idx_vector& idx, const MArray<T>& vals)
 {
   octave_idx_type n = this->numel ();
   octave_idx_type ext = idx.extent (n);
   if (ext > n)
     {
       this->resize1 (ext);
@@ -80,28 +80,28 @@ MArray<T>::idx_add (const idx_vector& id
     }
 
   octave_quit ();
 
   octave_idx_type len = std::min (idx.length (n), vals.numel ());
   idx.loop (len, _idxadda_helper<T> (this->fortran_vec (), vals.data ()));
 }
 
-template <class T, T op (typename ref_param<T>::type,
+template <typename T, T op (typename ref_param<T>::type,
                          typename ref_param<T>::type)>
 struct _idxbinop_helper
 {
   T *array;
   const T *vals;
   _idxbinop_helper (T *a, const T *v) : array (a), vals (v) { }
   void operator () (octave_idx_type i)
   { array[i] = op (array[i], *vals++); }
 };
 
-template <class T>
+template <typename T>
 void
 MArray<T>::idx_min (const idx_vector& idx, const MArray<T>& vals)
 {
   octave_idx_type n = this->numel ();
   octave_idx_type ext = idx.extent (n);
   if (ext > n)
     {
       this->resize1 (ext);
@@ -110,17 +110,17 @@ MArray<T>::idx_min (const idx_vector& id
 
   octave_quit ();
 
   octave_idx_type len = std::min (idx.length (n), vals.numel ());
   idx.loop (len, _idxbinop_helper<T, xmin> (this->fortran_vec (),
                                             vals.data ()));
 }
 
-template <class T>
+template <typename T>
 void
 MArray<T>::idx_max (const idx_vector& idx, const MArray<T>& vals)
 {
   octave_idx_type n = this->numel ();
   octave_idx_type ext = idx.extent (n);
   if (ext > n)
     {
       this->resize1 (ext);
@@ -131,17 +131,17 @@ MArray<T>::idx_max (const idx_vector& id
 
   octave_idx_type len = std::min (idx.length (n), vals.numel ());
   idx.loop (len, _idxbinop_helper<T, xmax> (this->fortran_vec (),
                                             vals.data ()));
 }
 
 #include <iostream>
 
-template <class T>
+template <typename T>
 void MArray<T>::idx_add_nd (const idx_vector& idx, const MArray<T>& vals,
                             int dim)
 {
   int nd = std::max (this->ndims (), vals.ndims ());
   if (dim < 0)
     dim = vals.dims ().first_non_singleton ();
   else if (dim > nd)
     nd = dim;
@@ -194,169 +194,169 @@ void MArray<T>::idx_add_nd (const idx_ve
 
           dst += l*n;
           src += l*ns;
         }
     }
 }
 
 // N-dimensional array with math ops.
-template <class T>
+template <typename T>
 void
 MArray<T>::changesign (void)
 {
   if (Array<T>::is_shared ())
     *this = - *this;
   else
     do_mx_inplace_op<T> (*this, mx_inline_uminus2);
 }
 
 // Element by element MArray by scalar ops.
 
-template <class T>
+template <typename T>
 MArray<T>&
 operator += (MArray<T>& a, const T& s)
 {
   if (a.is_shared ())
     a = a + s;
   else
     do_ms_inplace_op<T, T> (a, s, mx_inline_add2);
   return a;
 }
 
-template <class T>
+template <typename T>
 MArray<T>&
 operator -= (MArray<T>& a, const T& s)
 {
   if (a.is_shared ())
     a = a - s;
   else
     do_ms_inplace_op<T, T> (a, s, mx_inline_sub2);
   return a;
 }
 
-template <class T>
+template <typename T>
 MArray<T>&
 operator *= (MArray<T>& a, const T& s)
 {
   if (a.is_shared ())
     a = a * s;
   else
     do_ms_inplace_op<T, T> (a, s, mx_inline_mul2);
   return a;
 }
 
-template <class T>
+template <typename T>
 MArray<T>&
 operator /= (MArray<T>& a, const T& s)
 {
   if (a.is_shared ())
     a = a / s;
   else
     do_ms_inplace_op<T, T> (a, s, mx_inline_div2);
   return a;
 }
 
 // Element by element MArray by MArray ops.
 
-template <class T>
+template <typename T>
 MArray<T>&
 operator += (MArray<T>& a, const MArray<T>& b)
 {
   if (a.is_shared ())
     a = a + b;
   else
     do_mm_inplace_op<T, T> (a, b, mx_inline_add2, mx_inline_add2, "+=");
   return a;
 }
 
-template <class T>
+template <typename T>
 MArray<T>&
 operator -= (MArray<T>& a, const MArray<T>& b)
 {
   if (a.is_shared ())
     a = a - b;
   else
     do_mm_inplace_op<T, T> (a, b, mx_inline_sub2, mx_inline_sub2, "-=");
   return a;
 }
 
 
-template <class T>
+template <typename T>
 MArray<T>&
 product_eq (MArray<T>& a, const MArray<T>& b)
 {
   if (a.is_shared ())
     return a = product (a, b);
   else
     do_mm_inplace_op<T, T> (a, b, mx_inline_mul2, mx_inline_mul2, ".*=");
   return a;
 }
 
-template <class T>
+template <typename T>
 MArray<T>&
 quotient_eq (MArray<T>& a, const MArray<T>& b)
 {
   if (a.is_shared ())
     return a = quotient (a, b);
   else
     do_mm_inplace_op<T, T> (a, b, mx_inline_div2, mx_inline_div2, "./=");
   return a;
 }
 
 // Element by element MArray by scalar ops.
 
 #define MARRAY_NDS_OP(OP, FN) \
-  template <class T> \
+  template <typename T> \
   MArray<T> \
   operator OP (const MArray<T>& a, const T& s) \
   { \
     return do_ms_binary_op<T, T, T> (a, s, FN); \
   }
 
 MARRAY_NDS_OP (+, mx_inline_add)
 MARRAY_NDS_OP (-, mx_inline_sub)
 MARRAY_NDS_OP (*, mx_inline_mul)
 MARRAY_NDS_OP (/, mx_inline_div)
 
 // Element by element scalar by MArray ops.
 
 #define MARRAY_SND_OP(OP, FN) \
-  template <class T> \
+  template <typename T> \
   MArray<T> \
   operator OP (const T& s, const MArray<T>& a) \
   { \
     return do_sm_binary_op<T, T, T> (s, a, FN); \
   }
 
 MARRAY_SND_OP (+, mx_inline_add)
 MARRAY_SND_OP (-, mx_inline_sub)
 MARRAY_SND_OP (*, mx_inline_mul)
 MARRAY_SND_OP (/, mx_inline_div)
 
 // Element by element MArray by MArray ops.
 
 #define MARRAY_NDND_OP(FCN, OP, FN) \
-  template <class T> \
+  template <typename T> \
   MArray<T> \
   FCN (const MArray<T>& a, const MArray<T>& b) \
   { \
     return do_mm_binary_op<T, T, T> (a, b, FN, FN, FN, #FCN); \
   }
 
 MARRAY_NDND_OP (operator +, +, mx_inline_add)
 MARRAY_NDND_OP (operator -, -, mx_inline_sub)
 MARRAY_NDND_OP (product,    *, mx_inline_mul)
 MARRAY_NDND_OP (quotient,   /, mx_inline_div)
 
-template <class T>
+template <typename T>
 MArray<T>
 operator + (const MArray<T>& a)
 {
   return a;
 }
 
-template <class T>
+template <typename T>
 MArray<T>
 operator - (const MArray<T>& a)
 {
   return do_mx_unary_op<T, T> (a, mx_inline_uminus);
 }
diff --git a/liboctave/array/MArray.h b/liboctave/array/MArray.h
--- a/liboctave/array/MArray.h
+++ b/liboctave/array/MArray.h
@@ -22,17 +22,17 @@ along with Octave; see the file COPYING.
 */
 
 #if ! defined (octave_MArray_h)
 #define octave_MArray_h 1
 
 #include "Array.h"
 #include "mx-inlines.cc"
 
-template <class T> class MArray;
+template <typename T> class MArray;
 
 template <typename T> MArray<T>& operator += (MArray<T>&, const T&);
 template <typename T> MArray<T>& operator -= (MArray<T>&, const T&);
 template <typename T> MArray<T>& operator *= (MArray<T>&, const T&);
 template <typename T> MArray<T>& operator /= (MArray<T>&, const T&);
 template <typename T> MArray<T>& operator += (MArray<T>&, const MArray<T>&);
 template <typename T> MArray<T>& operator -= (MArray<T>&, const MArray<T>&);
 template <typename T> MArray<T>& product_eq (MArray<T>&, const MArray<T>&);
@@ -48,17 +48,17 @@ template <typename T> MArray<T> operator
 template <typename T> MArray<T> operator * (const T&, const MArray<T>&);
 template <typename T> MArray<T> operator / (const T&, const MArray<T>&);
 template <typename T> MArray<T> operator + (const MArray<T>&, const MArray<T>&);
 template <typename T> MArray<T> operator - (const MArray<T>&, const MArray<T>&);
 template <typename T> MArray<T> quotient (const MArray<T>&, const MArray<T>&);
 template <typename T> MArray<T> product (const MArray<T>&, const MArray<T>&);
 
 //! Template for N-dimensional array classes with like-type math operators.
-template <class T>
+template <typename T>
 class
 MArray : public Array<T>
 {
 protected:
 
   // For jit support
   MArray (T *sdata, octave_idx_type slen, octave_idx_type *adims, void *arep)
     : Array<T> (sdata, slen, adims, arep) { }
@@ -70,17 +70,17 @@ public:
   explicit MArray (const dim_vector& dv)
     : Array<T> (dv) { }
 
   explicit MArray (const dim_vector& dv, const T& val)
     : Array<T> (dv, val) { }
 
   MArray (const MArray<T>& a) : Array<T> (a) { }
 
-  template <class U>
+  template <typename U>
   MArray (const Array<U>& a) : Array<T> (a) { }
 
   ~MArray (void) { }
 
   MArray<T>& operator = (const MArray<T>& a)
   {
     Array<T>::operator = (a);
     return *this;
diff --git a/liboctave/array/MDiagArray2.cc b/liboctave/array/MDiagArray2.cc
--- a/liboctave/array/MDiagArray2.cc
+++ b/liboctave/array/MDiagArray2.cc
@@ -24,17 +24,17 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "MDiagArray2.h"
 #include "Array-util.h"
 #include "lo-error.h"
 
-template <class T>
+template <typename T>
 bool
 MDiagArray2<T>::is_multiple_of_identity (T val) const
 {
   bool retval = this->rows () == this->cols ();
   if (retval)
     {
       octave_idx_type len = this->length ();
       octave_idx_type i = 0;
@@ -48,61 +48,61 @@ MDiagArray2<T>::is_multiple_of_identity 
 
 // Two dimensional diagonal array with math ops.
 
 // Element by element MDiagArray2 by MDiagArray2 ops.
 
 // Element by element MDiagArray2 by scalar ops.
 
 #define MARRAY_DAS_OP(OP, FN) \
-  template <class T> \
+  template <typename T> \
   MDiagArray2<T> \
   operator OP (const MDiagArray2<T>& a, const T& s) \
   { \
     return MDiagArray2<T> (do_ms_binary_op<T, T, T> (a, s, FN), a.d1, a.d2); \
   }
 
 MARRAY_DAS_OP (*, mx_inline_mul)
 MARRAY_DAS_OP (/, mx_inline_div)
 
 // Element by element scalar by MDiagArray2 ops.
 
-template <class T>
+template <typename T>
 MDiagArray2<T>
 operator * (const T& s, const MDiagArray2<T>& a)
 {
   return MDiagArray2<T> (do_sm_binary_op<T, T, T> (s, a, mx_inline_mul),
                                                    a.d1, a.d2);
 }
 
 // Element by element MDiagArray2 by MDiagArray2 ops.
 
 #define MARRAY_DADA_OP(FCN, OP, FN) \
-  template <class T> \
+  template <typename T> \
   MDiagArray2<T> \
   FCN (const MDiagArray2<T>& a, const MDiagArray2<T>& b) \
   { \
     if (a.d1 != b.d1 || a.d2 != b.d2) \
       err_nonconformant (#FCN, a.d1, a.d2, b.d1, b.d2); \
  \
     return MDiagArray2<T> (do_mm_binary_op<T, T, T> (a, b, FN, FN, FN, #FCN), a.d1, a.d2); \
   }
 
 MARRAY_DADA_OP (operator +, +, mx_inline_add)
 MARRAY_DADA_OP (operator -, -, mx_inline_sub)
 MARRAY_DADA_OP (product,    *, mx_inline_mul)
 
 // Unary MDiagArray2 ops.
 
-template <class T>
+template <typename T>
 MDiagArray2<T>
 operator + (const MDiagArray2<T>& a)
 {
   return a;
 }
 
-template <class T>
+template <typename T>
 MDiagArray2<T>
 operator - (const MDiagArray2<T>& a)
 {
   return MDiagArray2<T> (do_mx_unary_op<T, T> (a, mx_inline_uminus),
                          a.d1, a.d2);
 }
diff --git a/liboctave/array/MDiagArray2.h b/liboctave/array/MDiagArray2.h
--- a/liboctave/array/MDiagArray2.h
+++ b/liboctave/array/MDiagArray2.h
@@ -23,17 +23,17 @@ along with Octave; see the file COPYING.
 */
 
 #if ! defined (octave_MDiagArray2_h)
 #define octave_MDiagArray2_h 1
 
 #include "DiagArray2.h"
 #include "MArray.h"
 
-template <class T> class MDiagArray2;
+template <typename T> class MDiagArray2;
 
 template <typename T> MDiagArray2<T> operator + (const MDiagArray2<T>&);
 template <typename T> MDiagArray2<T> operator - (const MDiagArray2<T>&);
 template <typename T> MDiagArray2<T> operator * (const MDiagArray2<T>&,
                                                  const T&);
 template <typename T> MDiagArray2<T> operator / (const MDiagArray2<T>&,
                                                  const T&);
 template <typename T> MDiagArray2<T> operator * (const T&,
@@ -41,34 +41,34 @@ template <typename T> MDiagArray2<T> ope
 template <typename T> MDiagArray2<T> operator + (const MDiagArray2<T>&,
                                                  const MDiagArray2<T>&);
 template <typename T> MDiagArray2<T> operator - (const MDiagArray2<T>&,
                                                  const MDiagArray2<T>&);
 template <typename T> MDiagArray2<T> product (const MDiagArray2<T>&,
                                               const MDiagArray2<T>&);
 
 //! Template for two dimensional diagonal array with math operators.
-template <class T>
+template <typename T>
 class
 MDiagArray2 : public DiagArray2<T>
 {
 public:
 
   MDiagArray2 (void) : DiagArray2<T> () { }
 
   MDiagArray2 (octave_idx_type r, octave_idx_type c) : DiagArray2<T> (r, c) { }
 
   MDiagArray2 (octave_idx_type r, octave_idx_type c, const T& val)
     : DiagArray2<T> (r, c, val) { }
 
   MDiagArray2 (const MDiagArray2<T>& a) : DiagArray2<T> (a) { }
 
   MDiagArray2 (const DiagArray2<T>& a) : DiagArray2<T> (a) { }
 
-  template <class U>
+  template <typename U>
   MDiagArray2 (const DiagArray2<U>& a) : DiagArray2<T> (a) { }
 
   explicit MDiagArray2 (const Array<T>& a) : DiagArray2<T> (a) { }
 
   MDiagArray2 (const Array<T>& a, octave_idx_type r, octave_idx_type c)
     : DiagArray2<T> (a, r, c) { }
 
   ~MDiagArray2 (void) { }
diff --git a/liboctave/array/MSparse.cc b/liboctave/array/MSparse.cc
--- a/liboctave/array/MSparse.cc
+++ b/liboctave/array/MSparse.cc
@@ -20,17 +20,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 // sparse array with math ops.
 
 // Element by element MSparse by MSparse ops.
 
-template <class T, class OP>
+template <typename T, typename OP>
 MSparse<T>&
 plus_or_minus (MSparse<T>& a, const MSparse<T>& b, OP op, const char* op_name)
 {
   MSparse<T> r;
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
@@ -107,17 +107,17 @@ MSparse<T>&
 operator -= (MSparse<T>& a, const MSparse<T>& b)
 {
   return plus_or_minus (a, b, std::minus<T> (), "operator -=");
 }
 
 
 // Element by element MSparse by scalar ops.
 
-template <class T, class OP>
+template <typename T, typename OP>
 MArray<T>
 plus_or_minus (const MSparse<T>& a, const T& s, OP op)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   MArray<T> r (dim_vector (nr, nc), op (0.0, s));
 
@@ -137,17 +137,17 @@ operator + (const MSparse<T>& a, const T
 template <typename T>
 MArray<T>
 operator - (const MSparse<T>& a, const T& s)
 {
   return plus_or_minus (a, s, std::minus<T> ());
 }
 
 
-template <class T, class OP>
+template <typename T, typename OP>
 MSparse<T>
 times_or_divide (const MSparse<T>& a, const T& s, OP op)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
   octave_idx_type nz = a.nnz ();
 
   MSparse<T> r (nr, nc, nz);
@@ -175,17 +175,17 @@ MSparse<T>
 operator / (const MSparse<T>& a, const T& s)
 {
   return times_or_divide (a, s, std::divides<T> ());
 }
 
 
 // Element by element scalar by MSparse ops.
 
-template <class T, class OP>
+template <typename T, typename OP>
 MArray<T>
 plus_or_minus (const T& s, const MSparse<T>& a, OP op)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   MArray<T> r (dim_vector (nr, nc), op (s, 0.0));
 
@@ -204,17 +204,17 @@ operator + (const T& s, const MSparse<T>
 
 template <typename T>
 MArray<T>
 operator - (const T& s, const MSparse<T>& a)
 {
   return plus_or_minus (s, a, std::minus<T> ());
 }
 
-template <class T, class OP>
+template <typename T, typename OP>
 MSparse<T>
 times_or_divides (const T& s, const MSparse<T>& a, OP op)
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
   octave_idx_type nz = a.nnz ();
 
   MSparse<T> r (nr, nc, nz);
@@ -225,34 +225,34 @@ times_or_divides (const T& s, const MSpa
       r.ridx (i) = a.ridx (i);
     }
   for (octave_idx_type i = 0; i < nc + 1; i++)
     r.cidx (i) = a.cidx (i);
   r.maybe_compress (true);
   return r;
 }
 
-template <class T>
+template <typename T>
 MSparse<T>
 operator * (const T& s, const MSparse<T>& a)
 {
   return times_or_divides (s, a, std::multiplies<T> ());
 }
 
-template <class T>
+template <typename T>
 MSparse<T>
 operator / (const T& s, const MSparse<T>& a)
 {
   return times_or_divides (s, a, std::divides<T> ());
 }
 
 
 // Element by element MSparse by MSparse ops.
 
-template <class T, class OP>
+template <typename T, typename OP>
 MSparse<T>
 plus_or_minus (const MSparse<T>& a, const MSparse<T>& b, OP op,
                const char* op_name, bool negate)
 {
   MSparse<T> r;
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
@@ -361,31 +361,31 @@ plus_or_minus (const MSparse<T>& a, cons
         }
 
       r.maybe_compress ();
     }
 
   return r;
 }
 
-template <class T>
+template <typename T>
 MSparse<T>
 operator+ (const MSparse<T>& a, const MSparse<T>& b)
 {
   return plus_or_minus (a, b, std::plus<T> (), "operator +", false);
 }
 
-template <class T>
+template <typename T>
 MSparse<T>
 operator- (const MSparse<T>& a, const MSparse<T>& b)
 {
   return plus_or_minus (a, b, std::minus<T> (), "operator -", true);
 }
 
-template <class T>
+template <typename T>
 MSparse<T>
 product (const MSparse<T>& a, const MSparse<T>& b)
 {
   MSparse<T> r;
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
@@ -472,17 +472,17 @@ product (const MSparse<T>& a, const MSpa
         }
 
       r.maybe_compress ();
     }
 
   return r;
 }
 
-template <class T>
+template <typename T>
 MSparse<T>
 quotient (const MSparse<T>& a, const MSparse<T>& b)
 {
   MSparse<T> r;
   T Zero = T ();
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
@@ -590,24 +590,24 @@ quotient (const MSparse<T>& a, const MSp
 
   return r;
 }
 
 
 
 // Unary MSparse ops.
 
-template <class T>
+template <typename T>
 MSparse<T>
 operator + (const MSparse<T>& a)
 {
   return a;
 }
 
-template <class T>
+template <typename T>
 MSparse<T>
 operator - (const MSparse<T>& a)
 {
   MSparse<T> retval (a);
   octave_idx_type nz = a.nnz ();
   for (octave_idx_type i = 0; i < nz; i++)
     retval.data (i) = - retval.data (i);
   return retval;
diff --git a/liboctave/array/MSparse.h b/liboctave/array/MSparse.h
--- a/liboctave/array/MSparse.h
+++ b/liboctave/array/MSparse.h
@@ -33,17 +33,17 @@ along with Octave; see the file COPYING.
 #include "quit.h"
 #include "lo-error.h"
 #include "Sparse.h"
 #include "MArray.h"
 #include "Array-util.h"
 
 
 // Two dimensional sparse array with math ops.
-template <class T>
+template <typename T>
 class
 MSparse : public Sparse<T>
 {
 public:
 
   MSparse (void) : Sparse<T> () { }
 
   MSparse (octave_idx_type n, octave_idx_type m) : Sparse<T> (n, m) { }
@@ -52,17 +52,17 @@ public:
     : Sparse<T> (dv, nz) { }
 
   MSparse (const MSparse<T>& a) : Sparse<T> (a) { }
 
   MSparse (const MSparse<T>& a, const dim_vector& dv) : Sparse<T> (a, dv) { }
 
   MSparse (const Sparse<T>& a) : Sparse<T> (a) { }
 
-  template <class U>
+  template <typename U>
   MSparse (const Sparse<U>& a) : Sparse<T> (a) { }
 
   MSparse (const Array<T>& a, const idx_vector& r, const idx_vector& c,
            octave_idx_type nr = -1, octave_idx_type nc = -1,
            bool sum_terms = true, octave_idx_type nzm = -1)
     : Sparse<T> (a, r, c, nr, nc, sum_terms, nzm) { }
 
   explicit MSparse (octave_idx_type r, octave_idx_type c, T val)
@@ -107,22 +107,22 @@ public:
   { return Sparse<T>::ipermute (vec); }
 
   MSparse<T> diag (octave_idx_type k = 0) const
   {
     return Sparse<T>::diag (k);
   }
 
   // FIXME: should go away.
-  template <class U>
+  template <typename U>
   MSparse<U>
   map (U (&fcn) (T)) const
   { return Sparse<T>::template map<U> (fcn); }
 
-  template <class U>
+  template <typename U>
   MSparse<U>
   map (U (&fcn) (const T&)) const
   { return Sparse<T>::template map<U> (fcn); }
 };
 
 // Include operator templates for MSparse
 #include "MSparse.cc"
 
diff --git a/liboctave/array/MatrixType.cc b/liboctave/array/MatrixType.cc
--- a/liboctave/array/MatrixType.cc
+++ b/liboctave/array/MatrixType.cc
@@ -75,17 +75,17 @@ MatrixType::MatrixType (const MatrixType
   if (nperm != 0)
     {
       perm = new octave_idx_type [nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = a.perm[i];
     }
 }
 
-template<class T>
+template <typename T>
 MatrixType::matrix_type
 matrix_real_probe (const MArray<T>& a)
 {
   MatrixType::matrix_type typ;
   octave_idx_type nrows = a.rows ();
   octave_idx_type ncols = a.cols ();
 
   const T zero = 0;
@@ -133,17 +133,17 @@ matrix_real_probe (const MArray<T>& a)
         typ = MatrixType::Full;
     }
   else
     typ = MatrixType::Rectangular;
 
   return typ;
 }
 
-template<class T>
+template <typename T>
 MatrixType::matrix_type
 matrix_complex_probe (const MArray<std::complex<T> >& a)
 {
   MatrixType::matrix_type typ = MatrixType::Unknown;
   octave_idx_type nrows = a.rows ();
   octave_idx_type ncols = a.cols ();
 
   const T zero = 0;
diff --git a/liboctave/array/Sparse.cc b/liboctave/array/Sparse.cc
--- a/liboctave/array/Sparse.cc
+++ b/liboctave/array/Sparse.cc
@@ -47,17 +47,17 @@ along with Octave; see the file COPYING.
 #include "Sparse.h"
 #include "sparse-sort.h"
 #include "sparse-util.h"
 #include "oct-spparms.h"
 #include "mx-inlines.cc"
 
 #include "PermMatrix.h"
 
-template <class T>
+template <typename T>
 Sparse<T>::Sparse (const PermMatrix& a)
   : rep (new typename Sparse<T>::SparseRep (a.rows (), a.cols (), a.rows ())),
     dimensions (dim_vector (a.rows (), a.cols ()))
 {
   octave_idx_type n = a.rows ();
   for (octave_idx_type i = 0; i <= n; i++)
     cidx (i) = i;
 
@@ -65,17 +65,17 @@ Sparse<T>::Sparse (const PermMatrix& a)
 
   for (octave_idx_type i = 0; i < n; i++)
     ridx (i) = pv(i);
 
   for (octave_idx_type i = 0; i < n; i++)
     data (i) = 1.0;
 }
 
-template <class T>
+template <typename T>
 T&
 Sparse<T>::SparseRep::elem (octave_idx_type _r, octave_idx_type _c)
 {
   octave_idx_type i;
 
   if (nzmx <= 0)
     (*current_liboctave_error_handler)
       ("Sparse::SparseRep::elem (octave_idx_type, octave_idx_type): sparse matrix filled");
@@ -106,28 +106,28 @@ Sparse<T>::SparseRep::elem (octave_idx_t
     c[j] = c[j] + 1;
 
   d[i] = 0.;
   r[i] = _r;
 
   return d[i];
 }
 
-template <class T>
+template <typename T>
 T
 Sparse<T>::SparseRep::celem (octave_idx_type _r, octave_idx_type _c) const
 {
   if (nzmx > 0)
     for (octave_idx_type i = c[_c]; i < c[_c + 1]; i++)
       if (r[i] == _r)
         return d[i];
   return T ();
 }
 
-template <class T>
+template <typename T>
 void
 Sparse<T>::SparseRep::maybe_compress (bool remove_zeros)
 {
   if (remove_zeros)
     {
       octave_idx_type i = 0;
       octave_idx_type k = 0;
       for (octave_idx_type j = 1; j <= ncols; j++)
@@ -141,17 +141,17 @@ Sparse<T>::SparseRep::maybe_compress (bo
               }
           c[j] = k;
         }
     }
 
   change_length (c[ncols]);
 }
 
-template <class T>
+template <typename T>
 void
 Sparse<T>::SparseRep::change_length (octave_idx_type nz)
 {
   for (octave_idx_type j = ncols; j > 0 && c[j] > nz; j--)
     c[j] = nz;
 
   // We shall skip reallocation if we have less than 1/frac extra elements to
   // discard.
@@ -172,24 +172,24 @@ Sparse<T>::SparseRep::change_length (oct
 
       delete [] d;
       d = new_data;
 
       nzmx = nz;
     }
 }
 
-template <class T>
+template <typename T>
 bool
 Sparse<T>::SparseRep::indices_ok (void) const
 {
   return sparse_indices_ok (r, c, nrows, ncols, nnz ());
 }
 
-template <class T>
+template <typename T>
 Sparse<T>::Sparse (octave_idx_type nr, octave_idx_type nc, T val)
   : rep (0), dimensions (dim_vector (nr, nc))
 {
   if (val != T ())
     {
       rep = new typename Sparse<T>::SparseRep (nr, nc, dimensions.safe_numel ());
 
       octave_idx_type ii = 0;
@@ -207,28 +207,28 @@ Sparse<T>::Sparse (octave_idx_type nr, o
   else
     {
       rep = new typename Sparse<T>::SparseRep (nr, nc, 0);
       for (octave_idx_type j = 0; j < nc+1; j++)
         xcidx (j) = 0;
     }
 }
 
-template <class T>
+template <typename T>
 Sparse<T>::Sparse (const dim_vector& dv)
   : rep (0), dimensions (dv)
 {
   if (dv.length () != 2)
     (*current_liboctave_error_handler)
       ("Sparse::Sparse (const dim_vector&): dimension mismatch");
 
   rep = new typename Sparse<T>::SparseRep (dv(0), dv(1), 0);
 }
 
-template <class T>
+template <typename T>
 Sparse<T>::Sparse (const Sparse<T>& a, const dim_vector& dv)
   : rep (0), dimensions (dv)
 {
 
   // Work in unsigned long long to avoid overflow issues with numel
   unsigned long long a_nel = static_cast<unsigned long long>(a.rows ()) *
                              static_cast<unsigned long long>(a.cols ());
   unsigned long long dv_nel = static_cast<unsigned long long>(dv(0)) *
@@ -260,17 +260,17 @@ Sparse<T>::Sparse (const Sparse<T>& a, c
         kk = jj;
         xdata (j) = a.data (j);
         xridx (j) = ii;
       }
   for (octave_idx_type k = kk; k < new_nc; k++)
     xcidx (k+1) = new_nzmx;
 }
 
-template <class T>
+template <typename T>
 Sparse<T>::Sparse (const Array<T>& a, const idx_vector& r,
                    const idx_vector& c, octave_idx_type nr,
                    octave_idx_type nc, bool sum_terms,
                    octave_idx_type nzm)
   : rep (0), dimensions ()
 {
   if (nr < 0)
     nr = r.extent (0);
@@ -620,17 +620,17 @@ Sparse<T>::Sparse (const Array<T>& a, co
                 }
             }
         }
 
       maybe_compress (true);
     }
 }
 
-template <class T>
+template <typename T>
 Sparse<T>::Sparse (const Array<T>& a)
   : rep (0), dimensions (a.dims ())
 {
   if (dimensions.length () > 2)
     (*current_liboctave_error_handler)
       ("Sparse::Sparse (const Array<T>&): dimension mismatch");
 
   octave_idx_type nr = rows ();
@@ -654,24 +654,24 @@ Sparse<T>::Sparse (const Array<T>& a)
           {
             xdata (ii) = a.elem (i,j);
             xridx (ii++) = i;
           }
       xcidx (j+1) = ii;
     }
 }
 
-template <class T>
+template <typename T>
 Sparse<T>::~Sparse (void)
 {
   if (--rep->count == 0)
     delete rep;
 }
 
-template <class T>
+template <typename T>
 Sparse<T>&
 Sparse<T>::operator = (const Sparse<T>& a)
 {
   if (this != &a)
     {
       if (--rep->count == 0)
         delete rep;
 
@@ -679,17 +679,17 @@ Sparse<T>::operator = (const Sparse<T>& 
       rep->count++;
 
       dimensions = a.dimensions;
     }
 
   return *this;
 }
 
-template <class T>
+template <typename T>
 octave_idx_type
 Sparse<T>::compute_index (const Array<octave_idx_type>& ra_idx) const
 {
   octave_idx_type n = dimensions.length ();
 
   if (n <= 0 || n != ra_idx.numel ())
     (*current_liboctave_error_handler)
       ("Sparse<T>::compute_index: invalid ra_idxing operation");
@@ -702,46 +702,46 @@ Sparse<T>::compute_index (const Array<oc
     {
       retval *= dimensions(n);
       retval += ra_idx(n);
     }
 
   return retval;
 }
 
-template <class T>
+template <typename T>
 T
 Sparse<T>::range_error (const char *fcn, octave_idx_type n) const
 {
   (*current_liboctave_error_handler) ("%s (%d): range error", fcn, n);
 }
 
-template <class T>
+template <typename T>
 T&
 Sparse<T>::range_error (const char *fcn, octave_idx_type n)
 {
   (*current_liboctave_error_handler) ("%s (%d): range error", fcn, n);
 }
 
-template <class T>
+template <typename T>
 T
 Sparse<T>::range_error (const char *fcn, octave_idx_type i,
                         octave_idx_type j) const
 {
   (*current_liboctave_error_handler) ("%s (%d, %d): range error", fcn, i, j);
 }
 
-template <class T>
+template <typename T>
 T&
 Sparse<T>::range_error (const char *fcn, octave_idx_type i, octave_idx_type j)
 {
   (*current_liboctave_error_handler) ("%s (%d, %d): range error", fcn, i, j);
 }
 
-template <class T>
+template <typename T>
 T
 Sparse<T>::range_error (const char *fcn,
                         const Array<octave_idx_type>& ra_idx) const
 {
   std::ostringstream buf;
 
   buf << fcn << " (";
 
@@ -755,17 +755,17 @@ Sparse<T>::range_error (const char *fcn,
 
   buf << "): range error";
 
   std::string buf_str = buf.str ();
 
   (*current_liboctave_error_handler) (buf_str.c_str ());
 }
 
-template <class T>
+template <typename T>
 T&
 Sparse<T>::range_error (const char *fcn, const Array<octave_idx_type>& ra_idx)
 {
   std::ostringstream buf;
 
   buf << fcn << " (";
 
   octave_idx_type n = ra_idx.numel ();
@@ -778,17 +778,17 @@ Sparse<T>::range_error (const char *fcn,
 
   buf << "): range error";
 
   std::string buf_str = buf.str ();
 
   (*current_liboctave_error_handler) (buf_str.c_str ());
 }
 
-template <class T>
+template <typename T>
 Sparse<T>
 Sparse<T>::reshape (const dim_vector& new_dims) const
 {
   Sparse<T> retval;
   dim_vector dims2 = new_dims;
 
   if (dims2.length () > 2)
     {
@@ -845,17 +845,17 @@ Sparse<T>::reshape (const dim_vector& ne
         }
     }
   else
     retval = *this;
 
   return retval;
 }
 
-template <class T>
+template <typename T>
 Sparse<T>
 Sparse<T>::permute (const Array<octave_idx_type>& perm_vec, bool) const
 {
   // The only valid permutations of a sparse array are [1, 2] and [2, 1].
 
   bool fail = false;
   bool trans = false;
 
@@ -873,17 +873,17 @@ Sparse<T>::permute (const Array<octave_i
 
   if (fail)
     (*current_liboctave_error_handler)
       ("permutation vector contains an invalid element");
 
   return trans ? this->transpose () : *this;
 }
 
-template <class T>
+template <typename T>
 void
 Sparse<T>::resize1 (octave_idx_type n)
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr == 0)
     resize (1, std::max (nc, n));
@@ -892,29 +892,29 @@ Sparse<T>::resize1 (octave_idx_type n)
   else if (nr == 1)
     resize (1, n);
   else if (nc == 1)
     resize (n, 1);
   else
     err_invalid_resize ();
 }
 
-template <class T>
+template <typename T>
 void
 Sparse<T>::resize (const dim_vector& dv)
 {
   octave_idx_type n = dv.length ();
 
   if (n != 2)
     (*current_liboctave_error_handler) ("sparse array must be 2-D");
 
   resize (dv(0), dv(1));
 }
 
-template <class T>
+template <typename T>
 void
 Sparse<T>::resize (octave_idx_type r, octave_idx_type c)
 {
   if (r < 0 || c < 0)
     (*current_liboctave_error_handler) ("can't resize to negative dimension");
 
   if (r == dim1 () && c == dim2 ())
     return;
@@ -954,17 +954,17 @@ Sparse<T>::resize (octave_idx_type r, oc
                      rep->c[rep->ncols]);
     }
 
   rep->ncols = dimensions(1) = c;
 
   rep->change_length (rep->nnz ());
 }
 
-template <class T>
+template <typename T>
 Sparse<T>&
 Sparse<T>::insert (const Sparse<T>& a, octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_rows = a.rows ();
   octave_idx_type a_cols = a.cols ();
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
@@ -1035,28 +1035,28 @@ Sparse<T>::insert (const Sparse<T>& a, o
           ridx (ii++) = tmp.ridx (j);
         }
       cidx (i+1) = ii;
     }
 
   return *this;
 }
 
-template <class T>
+template <typename T>
 Sparse<T>&
 Sparse<T>::insert (const Sparse<T>& a, const Array<octave_idx_type>& ra_idx)
 {
 
   if (ra_idx.numel () != 2)
     (*current_liboctave_error_handler) ("range error for insert");
 
   return insert (a, ra_idx(0), ra_idx(1));
 }
 
-template <class T>
+template <typename T>
 Sparse<T>
 Sparse<T>::transpose (void) const
 {
   assert (ndims () == 2);
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nz = nnz ();
@@ -1102,17 +1102,17 @@ lblookup (const octave_idx_type *ridx, o
         if (ridx[l] >= ri)
           break;
       return l;
     }
   else
     return std::lower_bound (ridx, ridx + nr, ri) - ridx;
 }
 
-template <class T>
+template <typename T>
 void
 Sparse<T>::delete_elements (const idx_vector& idx)
 {
   Sparse<T> retval;
 
   assert (ndims () == 2);
 
   octave_idx_type nr = dim1 ();
@@ -1203,17 +1203,17 @@ Sparse<T>::delete_elements (const idx_ve
         {
           *this = index (idx_vector::colon);
           delete_elements (idx);
           *this = transpose (); // We want a row vector.
         }
     }
 }
 
-template <class T>
+template <typename T>
 void
 Sparse<T>::delete_elements (const idx_vector& idx_i, const idx_vector& idx_j)
 {
   assert (ndims () == 2);
 
   octave_idx_type nr = dim1 ();
   octave_idx_type nc = dim2 ();
   octave_idx_type nz = nnz ();
@@ -1322,29 +1322,29 @@ Sparse<T>::delete_elements (const idx_ve
         = (idx_i.length (nr) == 0 || idx_j.length (nc) == 0);
 
       if (! empty_assignment)
         (*current_liboctave_error_handler)
           ("a null assignment can only have one non-colon index");
     }
 }
 
-template <class T>
+template <typename T>
 void
 Sparse<T>::delete_elements (int dim, const idx_vector& idx)
 {
   if (dim == 0)
     delete_elements (idx, idx_vector::colon);
   else if (dim == 1)
     delete_elements (idx_vector::colon, idx);
   else
     (*current_liboctave_error_handler) ("invalid dimension in delete_elements");
 }
 
-template <class T>
+template <typename T>
 Sparse<T>
 Sparse<T>::index (const idx_vector& idx, bool resize_ok) const
 {
   Sparse<T> retval;
 
   assert (ndims () == 2);
 
   octave_idx_type nr = dim1 ();
@@ -1535,17 +1535,17 @@ Sparse<T>::index (const idx_vector& idx,
           if (idx_dims(0) == 1 && idx_dims(1) != 1)
             retval = retval.transpose ();
         }
     }
 
   return retval;
 }
 
-template <class T>
+template <typename T>
 Sparse<T>
 Sparse<T>::index (const idx_vector& idx_i, const idx_vector& idx_j,
                   bool resize_ok) const
 {
   Sparse<T> retval;
 
   assert (ndims () == 2);
 
@@ -1779,17 +1779,17 @@ Sparse<T>::index (const idx_vector& idx_
       // A(I, J) is decomposed into A(:, J)(I, :).
       retval = index (idx_vector::colon, idx_j);
       retval = retval.index (idx_i, idx_vector::colon);
     }
 
   return retval;
 }
 
-template <class T>
+template <typename T>
 void
 Sparse<T>::assign (const idx_vector& idx, const Sparse<T>& rhs)
 {
   Sparse<T> retval;
 
   assert (ndims () == 2);
 
   octave_idx_type nr = dim1 ();
@@ -1931,17 +1931,17 @@ Sparse<T>::assign (const idx_vector& idx
         assign (idx, Sparse<T> (rhl, 1, rhs.data (0)));
       else
         assign (idx, Sparse<T> (rhl, 1));
     }
   else
     err_nonconformant ("=", dim_vector(idx.length (n),1), rhs.dims());
 }
 
-template <class T>
+template <typename T>
 void
 Sparse<T>::assign (const idx_vector& idx_i,
                    const idx_vector& idx_j, const Sparse<T>& rhs)
 {
   Sparse<T> retval;
 
   assert (ndims () == 2);
 
@@ -2173,33 +2173,33 @@ Sparse<T>::assign (const idx_vector& idx
       assign (idx_i, idx_j, rhs.transpose ());
     }
   else
     err_nonconformant  ("=", idx_i.length (nr), idx_j.length (nc), n, m);
 }
 
 // Can't use versions of these in Array.cc due to duplication of the
 // instantiations for Array<double and Sparse<double>, etc
-template <class T>
+template <typename T>
 bool
 sparse_ascending_compare (typename ref_param<T>::type a,
                           typename ref_param<T>::type b)
 {
   return (a < b);
 }
 
-template <class T>
+template <typename T>
 bool
 sparse_descending_compare (typename ref_param<T>::type a,
                            typename ref_param<T>::type b)
 {
   return (a > b);
 }
 
-template <class T>
+template <typename T>
 Sparse<T>
 Sparse<T>::sort (octave_idx_type dim, sortmode mode) const
 {
   Sparse<T> m = *this;
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.columns ();
 
@@ -2254,17 +2254,17 @@ Sparse<T>::sort (octave_idx_type dim, so
     }
 
   if (dim > 0)
     m = m.transpose ();
 
   return m;
 }
 
-template <class T>
+template <typename T>
 Sparse<T>
 Sparse<T>::sort (Array<octave_idx_type> &sidx, octave_idx_type dim,
                  sortmode mode) const
 {
   Sparse<T> m = *this;
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.columns ();
@@ -2360,17 +2360,17 @@ Sparse<T>::sort (Array<octave_idx_type> 
     {
       m = m.transpose ();
       sidx = sidx.transpose ();
     }
 
   return m;
 }
 
-template <class T>
+template <typename T>
 Sparse<T>
 Sparse<T>::diag (octave_idx_type k) const
 {
   octave_idx_type nnr = rows ();
   octave_idx_type nnc = cols ();
   Sparse<T> d;
 
   if (nnr == 0 || nnc == 0)
@@ -2533,17 +2533,17 @@ Sparse<T>::diag (octave_idx_type k) cons
                 d.xcidx (i) = nz;
             }
         }
     }
 
   return d;
 }
 
-template <class T>
+template <typename T>
 Sparse<T>
 Sparse<T>::cat (int dim, octave_idx_type n, const Sparse<T> *sparse_list)
 {
   // Default concatenation.
   bool (dim_vector::*concat_rule) (const dim_vector&, int) = &dim_vector::concat;
 
   if (dim == -1 || dim == -2)
     {
@@ -2631,17 +2631,17 @@ Sparse<T>::cat (int dim, octave_idx_type
       }
     default:
       assert (false);
     }
 
   return retval;
 }
 
-template <class T>
+template <typename T>
 Array<T>
 Sparse<T>::array_value () const
 {
   NoAlias< Array<T> > retval (dims (), T ());
   if (rows () == 1)
     {
       octave_idx_type i = 0;
       for (octave_idx_type j = 0, nc = cols (); j < nc; j++)
@@ -2857,17 +2857,17 @@ bug #35570:
 %! a = sparse (magic (3));
 %! b = a;
 %! a(1,:) = 1:3;
 %! b(1,:) = (1:3)';
 %! assert (a, b);
 
 */
 
-template <class T>
+template <typename T>
 void
 Sparse<T>::print_info (std::ostream& os, const std::string& prefix) const
 {
   os << prefix << "rep address: " << rep << "\n"
      << prefix << "rep->nzmx:   " << rep->nzmx  << "\n"
      << prefix << "rep->nrows:  " << rep->nrows << "\n"
      << prefix << "rep->ncols:  " << rep->ncols << "\n"
      << prefix << "rep->data:   " << static_cast<void *> (rep->d) << "\n"
diff --git a/liboctave/array/Sparse.h b/liboctave/array/Sparse.h
--- a/liboctave/array/Sparse.h
+++ b/liboctave/array/Sparse.h
@@ -40,17 +40,17 @@ along with Octave; see the file COPYING.
 #include "oct-sort.h"
 
 class idx_vector;
 class PermMatrix;
 
 // Two dimensional sparse class.  Handles the reference counting for
 // all the derived classes.
 
-template <class T>
+template <typename T>
 class
 Sparse
 {
 public:
 
   typedef T element_type;
 
 protected:
@@ -199,17 +199,17 @@ public:
     : rep (new typename Sparse<T>::SparseRep (nr, nc, nz)),
       dimensions (dim_vector (nr, nc)) { }
 
   // Both SparseMatrix and SparseBoolMatrix need this ctor, and this
   // is their only common ancestor.
   explicit Sparse (const PermMatrix& a);
 
   // Type conversion case. Preserves capacity ().
-  template <class U>
+  template <typename U>
   Sparse (const Sparse<U>& a)
     : rep (new typename Sparse<T>::SparseRep (a.rep->nrows, a.rep->ncols,
            a.rep->nzmx)),
     dimensions (a.dimensions)
   {
     octave_idx_type nz = a.nnz ();
     std::copy (a.rep->d, a.rep->d + nz, rep->d);
     std::copy (a.rep->r, a.rep->r + nz, rep->r);
@@ -594,45 +594,45 @@ public:
 
   // dim = -1 and dim = -2 are special; see Array<T>::cat description.
   static Sparse<T>
   cat (int dim, octave_idx_type n, const Sparse<T> *sparse_list);
 
   Array<T> array_value (void) const;
 
   // Generic any/all test functionality with arbitrary predicate.
-  template <class F, bool zero>
+  template <typename F, bool zero>
   bool test (F fcn) const
   {
     return any_all_test<F, T, zero> (fcn, data (), nnz ());
   }
 
   // Simpler calls.
-  template <class F>
+  template <typename F>
   bool test_any (F fcn) const
   { return test<F, false> (fcn); }
 
-  template <class F>
+  template <typename F>
   bool test_all (F fcn) const
   { return test<F, true> (fcn); }
 
   // Overloads for function references.
   bool test_any (bool (&fcn) (T)) const
   { return test<bool (&) (T), false> (fcn); }
 
   bool test_any (bool (&fcn) (const T&)) const
   { return test<bool (&) (const T&), false> (fcn); }
 
   bool test_all (bool (&fcn) (T)) const
   { return test<bool (&) (T), true> (fcn); }
 
   bool test_all (bool (&fcn) (const T&)) const
   { return test<bool (&) (const T&), true> (fcn); }
 
-  template <class U, class F>
+  template <typename U, typename F>
   Sparse<U>
   map (F fcn) const
   {
     Sparse<U> result;
     U f_zero = fcn (0.);
 
     if (f_zero != 0.)
       {
@@ -678,30 +678,30 @@ public:
 
         result.maybe_compress (false);
       }
 
     return result;
   }
 
   // Overloads for function references.
-  template <class U>
+  template <typename U>
   Sparse<U>
   map (U (&fcn) (T)) const
   { return map<U, U (&) (T)> (fcn); }
 
-  template <class U>
+  template <typename U>
   Sparse<U>
   map (U (&fcn) (const T&)) const
   { return map<U, U (&) (const T&)> (fcn); }
 
   bool indices_ok (void) const { return rep->indices_ok (); }
 };
 
-template<typename T>
+template <typename T>
 std::istream&
 read_sparse_matrix (std::istream& is, Sparse<T>& a,
                     T (*read_fcn) (std::istream&))
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
   octave_idx_type nz = a.nzmax ();
 
diff --git a/liboctave/array/dDiagMatrix.h b/liboctave/array/dDiagMatrix.h
--- a/liboctave/array/dDiagMatrix.h
+++ b/liboctave/array/dDiagMatrix.h
@@ -47,17 +47,17 @@ public:
 
   DiagMatrix (octave_idx_type r, octave_idx_type c, double val)
     : MDiagArray2<double> (r, c, val) { }
 
   DiagMatrix (const DiagMatrix& a) : MDiagArray2<double> (a) { }
 
   DiagMatrix (const MDiagArray2<double>& a) : MDiagArray2<double> (a) { }
 
-  template <class U>
+  template <typename U>
   DiagMatrix (const DiagArray2<U>& a) : MDiagArray2<double> (a) { }
 
   explicit DiagMatrix (const Array<double>& a) : MDiagArray2<double> (a) { }
 
   DiagMatrix (const Array<double>& a, octave_idx_type r, octave_idx_type c)
     : MDiagArray2<double> (a, r, c) { }
 
   DiagMatrix& operator = (const DiagMatrix& a)
diff --git a/liboctave/array/dMatrix.h b/liboctave/array/dMatrix.h
--- a/liboctave/array/dMatrix.h
+++ b/liboctave/array/dMatrix.h
@@ -53,20 +53,20 @@ public:
 
   Matrix (const dim_vector& dv) : NDArray (dv.redim (2)) { }
 
   Matrix (const dim_vector& dv, double val)
     : NDArray (dv.redim (2), val) { }
 
   Matrix (const Matrix& a) : NDArray (a) { }
 
-  template <class U>
+  template <typename U>
   Matrix (const MArray<U>& a) : NDArray (a.as_matrix ()) { }
 
-  template <class U>
+  template <typename U>
   Matrix (const Array<U>& a) : NDArray (a.as_matrix ()) { }
 
   explicit Matrix (const RowVector& rv);
 
   explicit Matrix (const ColumnVector& cv);
 
   explicit Matrix (const DiagMatrix& a);
 
@@ -378,12 +378,12 @@ MS_BOOL_OP_DECLS (Matrix, double, OCTAVE
 SM_CMP_OP_DECLS (double, Matrix, OCTAVE_API)
 SM_BOOL_OP_DECLS (double, Matrix, OCTAVE_API)
 
 MM_CMP_OP_DECLS (Matrix, Matrix, OCTAVE_API)
 MM_BOOL_OP_DECLS (Matrix, Matrix, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArray, Matrix, double)
 
-template <class T>
+template <typename T>
 void read_int (std::istream& is, bool swap_bytes, T& val);
 
 #endif
diff --git a/liboctave/array/dNDArray.h b/liboctave/array/dNDArray.h
--- a/liboctave/array/dNDArray.h
+++ b/liboctave/array/dNDArray.h
@@ -43,23 +43,23 @@ public:
   NDArray (const dim_vector& dv, double val)
     : MArray<double> (dv, val) { }
 
   NDArray (const NDArray& a) : MArray<double> (a) { }
 
   NDArray (const Array<octave_idx_type>& a, bool zero_based = false,
            bool negative_to_nan = false);
 
-  template <class U>
+  template <typename U>
   NDArray (const MArray<U>& a) : MArray<double> (a) { }
 
-  template <class U>
+  template <typename U>
   NDArray (const Array<U>& a) : MArray<double> (a) { }
 
-  template <class U>
+  template <typename U>
   explicit NDArray (const intNDArray<U>& a) : MArray<double> (a) { }
 
   NDArray (const charNDArray&);
 
   // For jit support only
   NDArray (double *sdata, octave_idx_type slen, octave_idx_type *adims,
            void *arep)
     : MArray<double> (sdata, slen, adims, arep) { }
diff --git a/liboctave/array/fCDiagMatrix.h b/liboctave/array/fCDiagMatrix.h
--- a/liboctave/array/fCDiagMatrix.h
+++ b/liboctave/array/fCDiagMatrix.h
@@ -62,17 +62,17 @@ public:
   explicit FloatComplexDiagMatrix (const FloatDiagMatrix& a);
 
   FloatComplexDiagMatrix (const MDiagArray2<FloatComplex>& a)
     : MDiagArray2<FloatComplex> (a) { }
 
   FloatComplexDiagMatrix (const FloatComplexDiagMatrix& a)
     : MDiagArray2<FloatComplex> (a) { }
 
-  template <class U>
+  template <typename U>
   FloatComplexDiagMatrix (const DiagArray2<U>& a)
     : MDiagArray2<FloatComplex> (a) { }
 
   FloatComplexDiagMatrix& operator = (const FloatComplexDiagMatrix& a)
   {
     MDiagArray2<FloatComplex>::operator = (a);
     return *this;
   }
diff --git a/liboctave/array/fCMatrix.h b/liboctave/array/fCMatrix.h
--- a/liboctave/array/fCMatrix.h
+++ b/liboctave/array/fCMatrix.h
@@ -57,21 +57,21 @@ public:
     : FloatComplexNDArray (dv.redim (2)) { }
 
   FloatComplexMatrix (const dim_vector& dv, const FloatComplex& val)
     : FloatComplexNDArray (dv.redim (2), val) { }
 
   FloatComplexMatrix (const FloatComplexMatrix& a)
     : FloatComplexNDArray (a) { }
 
-  template <class U>
+  template <typename U>
   FloatComplexMatrix (const MArray<U>& a)
     : FloatComplexNDArray (a.as_matrix ()) { }
 
-  template <class U>
+  template <typename U>
   FloatComplexMatrix (const Array<U>& a)
     : FloatComplexNDArray (a.as_matrix ()) { }
 
   explicit FloatComplexMatrix (const FloatMatrix& a);
 
   explicit FloatComplexMatrix (const FloatRowVector& rv);
 
   explicit FloatComplexMatrix (const FloatColumnVector& cv);
diff --git a/liboctave/array/fCNDArray.h b/liboctave/array/fCNDArray.h
--- a/liboctave/array/fCNDArray.h
+++ b/liboctave/array/fCNDArray.h
@@ -40,20 +40,20 @@ public:
   FloatComplexNDArray (const dim_vector& dv) : MArray<FloatComplex> (dv) { }
 
   FloatComplexNDArray (const dim_vector& dv, const FloatComplex& val)
     : MArray<FloatComplex> (dv, val) { }
 
   FloatComplexNDArray (const FloatComplexNDArray& a)
     : MArray<FloatComplex> (a) { }
 
-  template <class U>
+  template <typename U>
   FloatComplexNDArray (const MArray<U>& a) : MArray<FloatComplex> (a) { }
 
-  template <class U>
+  template <typename U>
   FloatComplexNDArray (const Array<U>& a) : MArray<FloatComplex> (a) { }
 
   FloatComplexNDArray (const charNDArray&);
 
   FloatComplexNDArray& operator = (const FloatComplexNDArray& a)
   {
     MArray<FloatComplex>::operator = (a);
     return *this;
diff --git a/liboctave/array/fDiagMatrix.h b/liboctave/array/fDiagMatrix.h
--- a/liboctave/array/fDiagMatrix.h
+++ b/liboctave/array/fDiagMatrix.h
@@ -47,17 +47,17 @@ public:
 
   FloatDiagMatrix (octave_idx_type r, octave_idx_type c, float val)
     : MDiagArray2<float> (r, c, val) { }
 
   FloatDiagMatrix (const FloatDiagMatrix& a) : MDiagArray2<float> (a) { }
 
   FloatDiagMatrix (const MDiagArray2<float>& a) : MDiagArray2<float> (a) { }
 
-  template <class U>
+  template <typename U>
   FloatDiagMatrix (const DiagArray2<U>& a) : MDiagArray2<float> (a) { }
 
   explicit FloatDiagMatrix (const Array<double>& a) : MDiagArray2<float> (a) { }
 
   FloatDiagMatrix (const Array<float>& a, octave_idx_type r, octave_idx_type c)
     : MDiagArray2<float> (a, r, c) { }
 
   FloatDiagMatrix& operator = (const FloatDiagMatrix& a)
diff --git a/liboctave/array/fMatrix.h b/liboctave/array/fMatrix.h
--- a/liboctave/array/fMatrix.h
+++ b/liboctave/array/fMatrix.h
@@ -53,20 +53,20 @@ public:
 
   FloatMatrix (const dim_vector& dv) : FloatNDArray (dv.redim (2)) { }
 
   FloatMatrix (const dim_vector& dv, float val)
     : FloatNDArray (dv.redim (2), val) { }
 
   FloatMatrix (const FloatMatrix& a) : FloatNDArray (a) { }
 
-  template <class U>
+  template <typename U>
   FloatMatrix (const MArray<U>& a) : FloatNDArray (a.as_matrix ()) { }
 
-  template <class U>
+  template <typename U>
   FloatMatrix (const Array<U>& a) : FloatNDArray (a.as_matrix ()) { }
 
   explicit FloatMatrix (const FloatRowVector& rv);
 
   explicit FloatMatrix (const FloatColumnVector& cv);
 
   explicit FloatMatrix (const FloatDiagMatrix& a);
 
@@ -395,12 +395,12 @@ MS_BOOL_OP_DECLS (FloatMatrix, float, OC
 SM_CMP_OP_DECLS (float, FloatMatrix, OCTAVE_API)
 SM_BOOL_OP_DECLS (float, FloatMatrix, OCTAVE_API)
 
 MM_CMP_OP_DECLS (FloatMatrix, FloatMatrix, OCTAVE_API)
 MM_BOOL_OP_DECLS (FloatMatrix, FloatMatrix, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArray, FloatMatrix, float)
 
-template <class T>
+template <typename T>
 void read_int (std::istream& is, bool swap_bytes, T& val);
 
 #endif
diff --git a/liboctave/array/fNDArray.h b/liboctave/array/fNDArray.h
--- a/liboctave/array/fNDArray.h
+++ b/liboctave/array/fNDArray.h
@@ -40,23 +40,23 @@ public:
 
   FloatNDArray (const dim_vector& dv) : MArray<float> (dv) { }
 
   FloatNDArray (const dim_vector& dv, float val)
     : MArray<float> (dv, val) { }
 
   FloatNDArray (const FloatNDArray& a) : MArray<float> (a) { }
 
-  template <class U>
+  template <typename U>
   FloatNDArray (const MArray<U>& a) : MArray<float> (a) { }
 
-  template <class U>
+  template <typename U>
   FloatNDArray (const Array<U>& a) : MArray<float> (a) { }
 
-  template <class U>
+  template <typename U>
   explicit FloatNDArray (const intNDArray<U>& a) : MArray<float> (a) { }
 
   FloatNDArray (const charNDArray&);
 
   FloatNDArray& operator = (const FloatNDArray& a)
   {
     MArray<float>::operator = (a);
     return *this;
diff --git a/liboctave/array/idx-vector.cc b/liboctave/array/idx-vector.cc
--- a/liboctave/array/idx-vector.cc
+++ b/liboctave/array/idx-vector.cc
@@ -226,28 +226,28 @@ convert_index (double x, bool& conv_erro
 }
 
 inline octave_idx_type
 convert_index (float x, bool& conv_error, octave_idx_type& ext)
 {
   return convert_index (static_cast<double> (x), conv_error, ext);
 }
 
-template <class T>
+template <typename T>
 inline octave_idx_type
 convert_index (octave_int<T> x, bool& conv_error,
                octave_idx_type& ext)
 {
   octave_idx_type i = octave_int<octave_idx_type> (x).value ();
 
   return convert_index (i, conv_error, ext);
 }
 
 
-template <class T>
+template <typename T>
 idx_vector::idx_scalar_rep::idx_scalar_rep (T x)
   : data (0)
 {
   octave_idx_type dummy = 0;
 
   data = convert_index (x, err, dummy);
 }
 
@@ -289,17 +289,17 @@ idx_vector::idx_scalar_rep::unconvert (v
 
 Array<octave_idx_type>
 idx_vector::idx_scalar_rep::as_array (void)
 {
   return Array<octave_idx_type> (dim_vector (1, 1), data);
 }
 
 
-template <class T>
+template <typename T>
 idx_vector::idx_vector_rep::idx_vector_rep (const Array<T>& nda)
   : data (0), len (nda.numel ()), ext (0), aowner (0), orig_dims (nda.dims ())
 {
   if (len != 0)
     {
       octave_idx_type *d = new octave_idx_type [len];
       for (octave_idx_type i = 0; i < len; i++)
         d[i] = convert_index (nda.xelem (i), err, ext);
diff --git a/liboctave/array/idx-vector.h b/liboctave/array/idx-vector.h
--- a/liboctave/array/idx-vector.h
+++ b/liboctave/array/idx-vector.h
@@ -31,18 +31,18 @@ along with Octave; see the file COPYING.
 #include <algorithm>
 #include <iosfwd>
 #include <memory>
 
 #include "dim-vector.h"
 #include "oct-inttypes.h"
 #include "oct-refcount.h"
 
-template<class T> class Array;
-template<class T> class Sparse;
+template <typename T> class Array;
+template <typename T> class Sparse;
 class Range;
 
 // Design rationale:
 // idx_vector is a reference-counting, polymorphic pointer, that can contain
 // 4 types of index objects: a magic colon, a range, a scalar, or an index vector.
 // Polymorphic methods for single element access are provided, as well as
 // templates implementing "early dispatch", i.e. hoisting the checks for index
 // type out of loops.
@@ -58,17 +58,17 @@ public:
     class_invalid = -1,
     class_colon = 0,
     class_range,
     class_scalar,
     class_vector,
     class_mask
   };
 
-  template<class T> friend class std::auto_ptr;
+  template <typename T> friend class std::auto_ptr;
 
 private:
 
   class OCTAVE_API idx_base_rep
   {
   public:
     idx_base_rep (void) : count (1), err (false) { }
 
@@ -223,17 +223,17 @@ private:
       : data (i) { }
 
     idx_scalar_rep (void)
       : data (0) { }
 
     // Zero-based constructor.
     idx_scalar_rep (octave_idx_type i);
 
-    template <class T>
+    template <typename T>
     idx_scalar_rep (T x);
 
     octave_idx_type xelem (octave_idx_type) const { return data; }
 
     octave_idx_type checkelem (octave_idx_type i) const;
 
     octave_idx_type length (octave_idx_type) const { return 1; }
 
@@ -285,17 +285,17 @@ private:
     { }
 
     // Zero-based constructor.
     idx_vector_rep (const Array<octave_idx_type>& inda);
 
     idx_vector_rep (const Array<octave_idx_type>& inda,
                     octave_idx_type _ext, direct);
 
-    template <class T>
+    template <typename T>
     idx_vector_rep (const Array<T>&);
 
     idx_vector_rep (bool);
 
     idx_vector_rep (const Array<bool>&, octave_idx_type = -1);
 
     idx_vector_rep (const Sparse<bool>&);
 
@@ -491,27 +491,27 @@ public:
   // Colon is best constructed by simply copying (or referencing) this member.
   static const idx_vector colon;
 
   // or passing ':' here
   idx_vector (char c) : rep (new idx_colon_rep (c)) { chkerr (); }
 
   // Conversion constructors (used by interpreter).
 
-  template <class T>
+  template <typename T>
   idx_vector (octave_int<T> x) : rep (new idx_scalar_rep (x)) { chkerr (); }
 
   idx_vector (double x) : rep (new idx_scalar_rep (x)) { chkerr (); }
 
   idx_vector (float x) : rep (new idx_scalar_rep (x)) { chkerr (); }
 
   // A scalar bool does not necessarily map to scalar index.
   idx_vector (bool x) : rep (new idx_mask_rep (x)) { chkerr (); }
 
-  template <class T>
+  template <typename T>
   idx_vector (const Array<octave_int<T> >& nda) : rep (new idx_vector_rep (nda))
   { chkerr (); }
 
   idx_vector (const Array<double>& nda) : rep (new idx_vector_rep (nda))
   { chkerr (); }
 
   idx_vector (const Array<float>& nda) : rep (new idx_vector_rep (nda))
   { chkerr (); }
@@ -611,17 +611,17 @@ public:
   // Slice with specializations. No checking of bounds!
   //
   // This is equivalent to the following loop (but much faster):
   //
   // for (octave_idx_type i = 0; i < idx->length (n); i++)
   //   dest[i] = src[idx(i)];
   // return i;
   //
-  template <class T>
+  template <typename T>
   octave_idx_type
   index (const T *src, octave_idx_type n, T *dest) const
   {
     octave_idx_type len = rep->length (n);
 
     switch (rep->idx_class ())
       {
       case class_colon:
@@ -685,17 +685,17 @@ public:
   // Slice assignment with specializations. No checking of bounds!
   //
   // This is equivalent to the following loop (but much faster):
   //
   // for (octave_idx_type i = 0; i < idx->length (n); i++)
   //   dest[idx(i)] = src[i];
   // return i;
   //
-  template <class T>
+  template <typename T>
   octave_idx_type
   assign (const T *src, octave_idx_type n, T *dest) const
   {
     octave_idx_type len = rep->length (n);
 
     switch (rep->idx_class ())
       {
       case class_colon:
@@ -757,17 +757,17 @@ public:
   // Slice fill with specializations. No checking of bounds!
   //
   // This is equivalent to the following loop (but much faster):
   //
   // for (octave_idx_type i = 0; i < idx->length (n); i++)
   //   dest[idx(i)] = val;
   // return i;
   //
-  template <class T>
+  template <typename T>
   octave_idx_type
   fill (const T& val, octave_idx_type n, T *dest) const
   {
     octave_idx_type len = rep->length (n);
 
     switch (rep->idx_class ())
       {
       case class_colon:
@@ -827,17 +827,17 @@ public:
   }
 
   // Generic non-breakable indexed loop. The loop body should be
   // encapsulated in a single functor body.  This is equivalent to the
   // following loop (but faster, at least for simple inlined bodies):
   //
   // for (octave_idx_type i = 0; i < idx->length (n); i++) body (idx(i));
 
-  template <class Functor>
+  template <typename Functor>
   void
   loop (octave_idx_type n, Functor body) const
   {
     octave_idx_type len = rep->length (n);
 
     switch (rep->idx_class ())
       {
       case class_colon:
@@ -895,17 +895,17 @@ public:
   // encapsulated in a single functor body.  This is equivalent to the
   // following loop (but faster, at least for simple inlined bodies):
   //
   // for (octave_idx_type i = 0; i < idx->length (n); i++)
   //   if (body (idx(i))) break;
   // return i;
   //
 
-  template <class Functor>
+  template <typename Functor>
   octave_idx_type
   bloop (octave_idx_type n, Functor body) const
   {
     octave_idx_type len = rep->length (n), ret;
 
     switch (rep->idx_class ())
       {
       case class_colon:
diff --git a/liboctave/array/intNDArray.cc b/liboctave/array/intNDArray.cc
--- a/liboctave/array/intNDArray.cc
+++ b/liboctave/array/intNDArray.cc
@@ -28,135 +28,135 @@ along with Octave; see the file COPYING.
 
 #include "Array-util.h"
 #include "mx-base.h"
 #include "lo-ieee.h"
 #include "mx-inlines.cc"
 
 // unary operations
 
-template <class T>
+template <typename T>
 boolNDArray
 intNDArray<T>::operator ! (void) const
 {
   boolNDArray b (this->dims ());
 
   for (octave_idx_type i = 0; i < this->numel (); i++)
     b.elem (i) = ! this->elem (i);
 
   return b;
 }
 
-template <class T>
+template <typename T>
 bool
 intNDArray<T>::any_element_not_one_or_zero (void) const
 {
   octave_idx_type nel = this->numel ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       T val = this->elem (i);
 
       if (val != 0.0 && val != 1.0)
         return true;
     }
 
   return false;
 }
 
-template <class T>
+template <typename T>
 intNDArray<T>
 intNDArray<T>::diag (octave_idx_type k) const
 {
   return MArray<T>::diag (k);
 }
 
-template <class T>
+template <typename T>
 intNDArray<T>
 intNDArray<T>::diag (octave_idx_type m, octave_idx_type n) const
 {
   return MArray<T>::diag (m, n);
 }
 
 // FIXME: this is not quite the right thing.
 
-template <class T>
+template <typename T>
 boolNDArray
 intNDArray<T>::all (int dim) const
 {
   return do_mx_red_op<bool, T > (*this, dim, mx_inline_all);
 }
 
-template <class T>
+template <typename T>
 boolNDArray
 intNDArray<T>::any (int dim) const
 {
   return do_mx_red_op<bool, T > (*this, dim, mx_inline_any);
 }
 
-template <class T>
+template <typename T>
 void
 intNDArray<T>::increment_index (Array<octave_idx_type>& ra_idx,
                                 const dim_vector& dimensions,
                                 int start_dimension)
 {
   ::increment_index (ra_idx, dimensions, start_dimension);
 }
 
-template <class T>
+template <typename T>
 octave_idx_type
 intNDArray<T>::compute_index (Array<octave_idx_type>& ra_idx,
                               const dim_vector& dimensions)
 {
   return ::compute_index (ra_idx, dimensions);
 }
 
-template <class T>
+template <typename T>
 intNDArray<T>
 intNDArray<T>::concat (const intNDArray<T>& rb,
                        const Array<octave_idx_type>& ra_idx)
 {
   if (rb.numel () > 0)
     insert (rb, ra_idx);
   return *this;
 }
 
-template <class T>
+template <typename T>
 intNDArray<T>&
 intNDArray<T>::insert (const intNDArray<T>& a, octave_idx_type r,
                        octave_idx_type c)
 {
   Array<T>::insert (a, r, c);
   return *this;
 }
 
-template <class T>
+template <typename T>
 intNDArray<T>&
 intNDArray<T>::insert (const intNDArray<T>& a,
                        const Array<octave_idx_type>& ra_idx)
 {
   Array<T>::insert (a, ra_idx);
   return *this;
 }
 
 // This contains no information on the array structure !!!
 
-template <class T>
+template <typename T>
 std::ostream&
 operator << (std::ostream& os, const intNDArray<T>& a)
 {
   octave_idx_type nel = a.numel ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     os << " " << a.elem (i) << "\n";
 
   return os;
 }
 
-template <class T>
+template <typename T>
 std::istream&
 operator >> (std::istream& is, intNDArray<T>& a)
 {
   octave_idx_type nel = a.numel ();
 
   if (nel > 0)
     {
       T tmp;
@@ -174,130 +174,130 @@ operator >> (std::istream& is, intNDArra
 
 done:
 
   return is;
 }
 
 // FIXME: should abs and signum just be mapper functions?
 
-template <class T>
+template <typename T>
 intNDArray<T>
 intNDArray<T>::abs (void) const
 {
   octave_idx_type nel = this->numel ();
   intNDArray<T> ret (this->dims ());
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       T val = this->elem (i);
       ret.xelem (i) = val.abs ();
     }
 
   return ret;
 }
 
-template <class T>
+template <typename T>
 intNDArray<T>
 intNDArray<T>::signum (void) const
 {
   octave_idx_type nel = this->numel ();
   intNDArray<T> ret (this->dims ());
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       T val = this->elem (i);
       ret.xelem (i) = val.signum ();
     }
 
   return ret;
 }
 
-template <class T>
+template <typename T>
 intNDArray<T>
 intNDArray<T>::prod (int dim) const
 {
   return do_mx_red_op<T, T> (*this, dim, mx_inline_prod);
 }
 
-template <class T>
+template <typename T>
 intNDArray<T>
 intNDArray<T>::sum (int dim) const
 {
   return do_mx_red_op<T, T> (*this, dim, mx_inline_sum);
 }
 
-template <class T>
+template <typename T>
 NDArray
 intNDArray<T>::dsum (int dim) const
 {
   return do_mx_red_op<double, T> (*this, dim, mx_inline_dsum);
 }
 
-template <class T>
+template <typename T>
 intNDArray<T>
 intNDArray<T>::cumsum (int dim) const
 {
   return do_mx_cum_op<T, T> (*this, dim, mx_inline_cumsum);
 }
 
-template <class T>
+template <typename T>
 intNDArray<T>
 intNDArray<T>::max (int dim) const
 {
   return do_mx_minmax_op<T> (*this, dim, mx_inline_max);
 }
 
-template <class T>
+template <typename T>
 intNDArray<T>
 intNDArray<T>::max (Array<octave_idx_type>& idx_arg, int dim) const
 {
   return do_mx_minmax_op<T> (*this, idx_arg, dim, mx_inline_max);
 }
 
-template <class T>
+template <typename T>
 intNDArray<T>
 intNDArray<T>::min (int dim) const
 {
   return do_mx_minmax_op<T> (*this, dim, mx_inline_min);
 }
 
-template <class T>
+template <typename T>
 intNDArray<T>
 intNDArray<T>::min (Array<octave_idx_type>& idx_arg, int dim) const
 {
   return do_mx_minmax_op<T> (*this, idx_arg, dim, mx_inline_min);
 }
 
-template <class T>
+template <typename T>
 intNDArray<T>
 intNDArray<T>::cummax (int dim) const
 {
   return do_mx_cumminmax_op<T> (*this, dim, mx_inline_cummax);
 }
 
-template <class T>
+template <typename T>
 intNDArray<T>
 intNDArray<T>::cummax (Array<octave_idx_type>& idx_arg, int dim) const
 {
   return do_mx_cumminmax_op<T> (*this, idx_arg, dim, mx_inline_cummax);
 }
 
-template <class T>
+template <typename T>
 intNDArray<T>
 intNDArray<T>::cummin (int dim) const
 {
   return do_mx_cumminmax_op<T> (*this, dim, mx_inline_cummin);
 }
 
-template <class T>
+template <typename T>
 intNDArray<T>
 intNDArray<T>::cummin (Array<octave_idx_type>& idx_arg, int dim) const
 {
   return do_mx_cumminmax_op<T> (*this, idx_arg, dim, mx_inline_cummin);
 }
 
-template <class T>
+template <typename T>
 intNDArray<T>
 intNDArray<T>::diff (octave_idx_type order, int dim) const
 {
   return do_mx_diff_op<T> (*this, dim, order, mx_inline_diff);
 }
diff --git a/liboctave/array/intNDArray.h b/liboctave/array/intNDArray.h
--- a/liboctave/array/intNDArray.h
+++ b/liboctave/array/intNDArray.h
@@ -22,40 +22,40 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_intNDArray_h)
 #define octave_intNDArray_h 1
 
 #include "MArray.h"
 #include "boolNDArray.h"
 class NDArray;
 
-template <class T>
+template <typename T>
 class
 intNDArray : public MArray<T>
 {
 public:
 
   using typename MArray<T>::element_type;
 
   intNDArray (void) : MArray<T> () { }
 
   intNDArray (T val) : MArray<T> (dim_vector (1, 1), val) { }
 
   intNDArray (const dim_vector& dv) : MArray<T> (dv) { }
 
   intNDArray (const dim_vector& dv, T val)
     : MArray<T> (dv, val) { }
 
-  template <class U>
+  template <typename U>
   intNDArray (const Array<U>& a) : MArray<T> (a) { }
 
-  template <class U>
+  template <typename U>
   intNDArray (const MArray<U>& a) : MArray<T> (a) { }
 
-  template <class U>
+  template <typename U>
   intNDArray (const intNDArray<U>& a) : MArray<T> (a) { }
 
   intNDArray& operator = (const intNDArray<T>& a)
   {
     MArray<T>::operator = (a);
     return *this;
   }
 
@@ -118,15 +118,15 @@ public:
                                int start_dimension = 0);
 
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
                                         const dim_vector& dimensions);
 };
 
 // i/o
 
-template <class T>
+template <typename T>
 std::ostream& operator << (std::ostream& os, const intNDArray<T>& a);
 
-template <class T>
+template <typename T>
 std::istream& operator >> (std::istream& is, intNDArray<T>& a);
 
 #endif
diff --git a/liboctave/numeric/DET.h b/liboctave/numeric/DET.h
--- a/liboctave/numeric/DET.h
+++ b/liboctave/numeric/DET.h
@@ -22,17 +22,17 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_DET_h)
 #define octave_DET_h 1
 
 #include <cmath>
 #include "oct-cmplx.h"
 #include "lo-mappers.h"
 
-template <class T>
+template <typename T>
 class
 base_det
 {
 public:
 
   base_det (T c = 1, int e = 0)
     : c2 (), e2 ()
   {
diff --git a/liboctave/numeric/base-aepbal.h b/liboctave/numeric/base-aepbal.h
--- a/liboctave/numeric/base-aepbal.h
+++ b/liboctave/numeric/base-aepbal.h
@@ -18,17 +18,17 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if ! defined (octave_base_aepbal_h)
 #define octave_base_aepbal_h 1
 
-template <class MatrixT, class VectorT>
+template <typename MatrixT, typename VectorT>
 class base_aepbal
 {
 protected:
   MatrixT balanced_mat;
   VectorT scale;
   octave_idx_type ilo, ihi;
   char job;
 
diff --git a/liboctave/numeric/base-lu.cc b/liboctave/numeric/base-lu.cc
--- a/liboctave/numeric/base-lu.cc
+++ b/liboctave/numeric/base-lu.cc
@@ -22,45 +22,45 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "base-lu.h"
 
-template <class lu_type>
+template <typename lu_type>
 base_lu<lu_type>::base_lu (const lu_type& l, const lu_type& u,
                            const PermMatrix& p)
   : a_fact (u), l_fact (l), ipvt (p.transpose ().col_perm_vec ())
 {
   if (l.columns () != u.rows ())
     (*current_liboctave_error_handler) ("lu: dimension mismatch");
 }
 
-template <class lu_type>
+template <typename lu_type>
 bool
 base_lu <lu_type> :: packed (void) const
 {
   return l_fact.dims () == dim_vector ();
 }
 
-template <class lu_type>
+template <typename lu_type>
 void
 base_lu <lu_type> :: unpack (void)
 {
   if (packed ())
     {
       l_fact = L ();
       a_fact = U (); // FIXME: sub-optimal
       ipvt = getp ();
     }
 }
 
-template <class lu_type>
+template <typename lu_type>
 lu_type
 base_lu <lu_type> :: L (void) const
 {
   if (packed ())
     {
       octave_idx_type a_nr = a_fact.rows ();
       octave_idx_type a_nc = a_fact.cols ();
       octave_idx_type mn = (a_nr < a_nc ? a_nr : a_nc);
@@ -77,17 +77,17 @@ base_lu <lu_type> :: L (void) const
         }
 
       return l;
     }
   else
     return l_fact;
 }
 
-template <class lu_type>
+template <typename lu_type>
 lu_type
 base_lu <lu_type> :: U (void) const
 {
   if (packed ())
     {
       octave_idx_type a_nr = a_fact.rows ();
       octave_idx_type a_nc = a_fact.cols ();
       octave_idx_type mn = (a_nr < a_nc ? a_nr : a_nc);
@@ -101,28 +101,28 @@ base_lu <lu_type> :: U (void) const
         }
 
       return u;
     }
   else
     return a_fact;
 }
 
-template <class lu_type>
+template <typename lu_type>
 lu_type
 base_lu <lu_type> :: Y (void) const
 {
   if (! packed ())
     (*current_liboctave_error_handler)
       ("lu: Y () not implemented for unpacked form");
 
   return a_fact;
 }
 
-template <class lu_type>
+template <typename lu_type>
 Array<octave_idx_type>
 base_lu <lu_type> :: getp (void) const
 {
   if (packed ())
     {
       octave_idx_type a_nr = a_fact.rows ();
 
       Array<octave_idx_type> pvt (dim_vector (a_nr, 1));
@@ -143,40 +143,40 @@ base_lu <lu_type> :: getp (void) const
         }
 
       return pvt;
     }
   else
     return ipvt;
 }
 
-template <class lu_type>
+template <typename lu_type>
 PermMatrix
 base_lu <lu_type> :: P (void) const
 {
   return PermMatrix (getp (), false);
 }
 
-template <class lu_type>
+template <typename lu_type>
 ColumnVector
 base_lu <lu_type> :: P_vec (void) const
 {
   octave_idx_type a_nr = a_fact.rows ();
 
   ColumnVector p (a_nr);
 
   Array<octave_idx_type> pvt = getp ();
 
   for (octave_idx_type i = 0; i < a_nr; i++)
     p.xelem (i) = static_cast<double> (pvt.xelem (i) + 1);
 
   return p;
 }
 
-template <class lu_type>
+template <typename lu_type>
 bool
 base_lu<lu_type>::regular (void) const
 {
   bool retval = true;
 
   octave_idx_type k = std::min (a_fact.rows (), a_fact.columns ());
 
   for (octave_idx_type i = 0; i < k; i++)
diff --git a/liboctave/numeric/base-lu.h b/liboctave/numeric/base-lu.h
--- a/liboctave/numeric/base-lu.h
+++ b/liboctave/numeric/base-lu.h
@@ -23,17 +23,17 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_base_lu_h)
 #define octave_base_lu_h 1
 
 #include "MArray.h"
 #include "dColVector.h"
 #include "PermMatrix.h"
 
-template <class lu_type>
+template <typename lu_type>
 class
 base_lu
 {
 public:
 
   typedef typename lu_type::element_type lu_elt_type;
 
   base_lu (void)
diff --git a/liboctave/numeric/base-qr.cc b/liboctave/numeric/base-qr.cc
--- a/liboctave/numeric/base-qr.cc
+++ b/liboctave/numeric/base-qr.cc
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "base-qr.h"
 
-template <class qr_type>
+template <typename qr_type>
 base_qr<qr_type>::base_qr (const qr_type& q_arg, const qr_type& r_arg)
   : q (q_arg), r (r_arg)
 {
   octave_idx_type q_nr = q.rows ();
   octave_idx_type q_nc = q.columns ();
   octave_idx_type r_nr = r.rows ();
   octave_idx_type r_nc = r.columns ();
 
@@ -39,33 +39,33 @@ base_qr<qr_type>::base_qr (const qr_type
     {
       q = qr_type ();
       r = qr_type ();
 
       (*current_liboctave_error_handler) ("QR dimensions mismatch");
     }
 }
 
-template <class qr_type>
+template <typename qr_type>
 qr_type_t
 base_qr<qr_type>::get_type (void) const
 {
   qr_type_t retval;
 
   if (! q.is_empty () && q.is_square ())
     retval = qr_type_std;
   else if (q.rows () > q.columns () && r.is_square ())
     retval = qr_type_economy;
   else
     retval = qr_type_raw;
 
   return retval;
 }
 
-template <class qr_type>
+template <typename qr_type>
 bool
 base_qr<qr_type>::regular (void) const
 {
   bool retval = true;
 
   octave_idx_type k = std::min (r.rows (), r.columns ());
 
   for (octave_idx_type i = 0; i < k; i++)
diff --git a/liboctave/numeric/base-qr.h b/liboctave/numeric/base-qr.h
--- a/liboctave/numeric/base-qr.h
+++ b/liboctave/numeric/base-qr.h
@@ -29,17 +29,17 @@ along with Octave; see the file COPYING.
 
 enum qr_type_t
 {
   qr_type_std,
   qr_type_raw,
   qr_type_economy
 };
 
-template <class qr_type>
+template <typename qr_type>
 class
 base_qr
 {
 public:
 
   typedef typename qr_type::element_type qr_elt_type;
 
   base_qr (void) : q (), r () { }
diff --git a/liboctave/numeric/bsxfun-defs.cc b/liboctave/numeric/bsxfun-defs.cc
--- a/liboctave/numeric/bsxfun-defs.cc
+++ b/liboctave/numeric/bsxfun-defs.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 #include <iostream>
 
 #include "dim-vector.h"
 #include "oct-locbuf.h"
 #include "lo-error.h"
 
 #include "mx-inlines.cc"
 
-template <class R, class X, class Y>
+template <typename R, typename X, typename Y>
 Array<R>
 do_bsxfun_op (const Array<X>& x, const Array<Y>& y,
               void (*op_vv) (size_t, R *, const X *, const Y *),
               void (*op_sv) (size_t, R *, X, const Y *),
               void (*op_vs) (size_t, R *, const X *, Y))
 {
   int nd = std::max (x.ndims (), y.ndims ());
   dim_vector dvx = x.dims ().redim (nd);
@@ -129,17 +129,17 @@ do_bsxfun_op (const Array<X>& x, const A
 
           dvr.increment_index (idx + start, start);
         }
     }
 
   return retval;
 }
 
-template <class R, class X>
+template <typename R, typename X>
 void
 do_inplace_bsxfun_op (Array<R>& r, const Array<X>& x,
                       void (*op_vv) (size_t, R *, const X *),
                       void (*op_vs) (size_t, R *, X))
 {
   dim_vector dvr = r.dims ();
   dim_vector dvx = x.dims ();
   octave_idx_type nd = r.ndims ();
diff --git a/liboctave/numeric/eigs-base.cc b/liboctave/numeric/eigs-base.cc
--- a/liboctave/numeric/eigs-base.cc
+++ b/liboctave/numeric/eigs-base.cc
@@ -211,17 +211,17 @@ static void
 warn_convergence (void)
 {
   (*current_liboctave_warning_with_id_handler)
     ("Octave:convergence",
      "eigs: 'A - sigma*B' is singular, indicating sigma is exactly "
      "an eigenvalue so convergence is not guaranteed");
 }
 
-template <class M, class SM>
+template <typename M, typename SM>
 static octave_idx_type
 lusolve (const SM& L, const SM& U, M& m)
 {
   octave_idx_type err = 0;
   double rcond;
   MatrixType utyp (MatrixType::Upper);
 
   // Sparse L is lower triangular, Dense L is permuted lower triangular!!!
@@ -229,17 +229,17 @@ lusolve (const SM& L, const SM& U, M& m)
   if (err)
     return err;
 
   m = U.solve (utyp, m, err, rcond, 0);
 
   return err;
 }
 
-template <class SM, class M>
+template <typename SM, typename M>
 static M
 ltsolve (const SM& L, const ColumnVector& Q, const M& m)
 {
   octave_idx_type n = L.cols ();
   octave_idx_type b_nc = m.cols ();
   octave_idx_type err = 0;
   double rcond;
   MatrixType ltyp (MatrixType::Lower);
@@ -256,17 +256,17 @@ ltsolve (const SM& L, const ColumnVector
             retval.elem (static_cast<octave_idx_type>(qv[i]), j) =
               tmp.elem (i,j);
         }
     }
 
   return retval;
 }
 
-template <class SM, class M>
+template <typename SM, typename M>
 static M
 utsolve (const SM& U, const ColumnVector& Q, const M& m)
 {
   octave_idx_type n = U.cols ();
   octave_idx_type b_nc = m.cols ();
   octave_idx_type err = 0;
   double rcond;
   MatrixType utyp (MatrixType::Upper);
@@ -744,17 +744,17 @@ LuAminusSigmaB (const ComplexMatrix &m, 
   volatile double rcond_plus_one = rcond + 1.0;
 
   if (rcond_plus_one == 1.0 || xisnan (rcond))
     warn_convergence ();
 
   return true;
 }
 
-template <class M>
+template <typename M>
 octave_idx_type
 EigsRealSymmetricMatrix (const M& m, const std::string typ,
                          octave_idx_type k, octave_idx_type p,
                          octave_idx_type &info, Matrix &eig_vec,
                          ColumnVector &eig_val, const M& _b,
                          ColumnVector &permB, ColumnVector &resid,
                          std::ostream& os, double tol, bool rvec,
                          bool cholB, int disp, int maxit)
@@ -1014,17 +1014,17 @@ EigsRealSymmetricMatrix (const M& m, con
         }
     }
   else
     (*current_liboctave_error_handler) ("eigs: error %d in dseupd", info2);
 
   return ip(4);
 }
 
-template <class M>
+template <typename M>
 octave_idx_type
 EigsRealSymmetricMatrixShift (const M& m, double sigma,
                               octave_idx_type k, octave_idx_type p,
                               octave_idx_type &info, Matrix &eig_vec,
                               ColumnVector &eig_val, const M& _b,
                               ColumnVector &permB, ColumnVector &resid,
                               std::ostream& os, double tol, bool rvec,
                               bool cholB, int disp, int maxit)
@@ -1538,17 +1538,17 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
         }
     }
   else
     (*current_liboctave_error_handler) ("eigs: error %d in dseupd", info2);
 
   return ip(4);
 }
 
-template <class M>
+template <typename M>
 octave_idx_type
 EigsRealNonSymmetricMatrix (const M& m, const std::string typ,
                             octave_idx_type k, octave_idx_type p,
                             octave_idx_type &info, ComplexMatrix &eig_vec,
                             ComplexColumnVector &eig_val, const M& _b,
                             ColumnVector &permB, ColumnVector &resid,
                             std::ostream& os, double tol, bool rvec,
                             bool cholB, int disp, int maxit)
@@ -1856,17 +1856,17 @@ EigsRealNonSymmetricMatrix (const M& m, 
         }
     }
   else
     (*current_liboctave_error_handler) ("eigs: error %d in dneupd", info2);
 
   return ip(4);
 }
 
-template <class M>
+template <typename M>
 octave_idx_type
 EigsRealNonSymmetricMatrixShift (const M& m, double sigmar,
                                  octave_idx_type k, octave_idx_type p,
                                  octave_idx_type &info,
                                  ComplexMatrix &eig_vec,
                                  ComplexColumnVector &eig_val, const M& _b,
                                  ColumnVector &permB, ColumnVector &resid,
                                  std::ostream& os, double tol, bool rvec,
@@ -2483,17 +2483,17 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
         }
     }
   else
     (*current_liboctave_error_handler) ("eigs: error %d in dneupd", info2);
 
   return ip(4);
 }
 
-template <class M>
+template <typename M>
 octave_idx_type
 EigsComplexNonSymmetricMatrix (const M& m, const std::string typ,
                                octave_idx_type k, octave_idx_type p,
                                octave_idx_type &info, ComplexMatrix &eig_vec,
                                ComplexColumnVector &eig_val, const M& _b,
                                ColumnVector &permB,
                                ComplexColumnVector &cresid,
                                std::ostream& os, double tol, bool rvec,
@@ -2755,17 +2755,17 @@ EigsComplexNonSymmetricMatrix (const M& 
         }
     }
   else
     (*current_liboctave_error_handler) ("eigs: error %d in zneupd", info2);
 
   return ip(4);
 }
 
-template <class M>
+template <typename M>
 octave_idx_type
 EigsComplexNonSymmetricMatrixShift (const M& m, Complex sigma,
                                     octave_idx_type k, octave_idx_type p,
                                     octave_idx_type &info,
                                     ComplexMatrix &eig_vec,
                                     ComplexColumnVector &eig_val, const M& _b,
                                     ColumnVector &permB,
                                     ComplexColumnVector &cresid,
diff --git a/liboctave/numeric/lo-mappers.h b/liboctave/numeric/lo-mappers.h
--- a/liboctave/numeric/lo-mappers.h
+++ b/liboctave/numeric/lo-mappers.h
@@ -70,23 +70,23 @@ inline bool xisinf (double x)
 { return std::isinf (x); }
 #else
 extern OCTAVE_API bool xisinf (double x);
 #endif
 
 extern OCTAVE_API bool octave_is_NA (double x);
 
 // Generic xmin, xmax definitions
-template <class T>
+template <typename T>
 inline T xmin (T x, T y)
 {
   return x <= y ? x : y;
 }
 
-template <class T>
+template <typename T>
 inline T xmax (T x, T y)
 {
   return x >= y ? x : y;
 }
 
 // This form is favorable. GCC will translate (x <= y ? x : y) without a
 // jump, hence the only conditional jump involved will be the first
 // (xisnan), infrequent and hence friendly to branch prediction.
diff --git a/liboctave/numeric/lo-specfun.cc b/liboctave/numeric/lo-specfun.cc
--- a/liboctave/numeric/lo-specfun.cc
+++ b/liboctave/numeric/lo-specfun.cc
@@ -3687,17 +3687,17 @@ ellipj (const Complex& u, double m, Comp
       sn = Complex (ss*dd1/ddd, cc*dd*ss1*cc1/ddd);
       cn = Complex (cc*cc1/ddd, -ss*dd*ss1*dd1/ddd);
       dn = Complex (dd*cc1*dd1/ddd, -m*ss*cc*ss1/ddd);
     }
 }
 
 static const double pi = 3.14159265358979323846;
 
-template <class T>
+template <typename T>
 static inline T
 xlog (const T& x)
 {
   return log (x);
 }
 
 template <>
 inline double
@@ -3708,17 +3708,17 @@ xlog (const double& x)
 
 template <>
 inline float
 xlog (const float& x)
 {
   return gnulib::logf (x);
 }
 
-template<class T>
+template <typename T>
 static T
 Lanczos_approximation_psi (const T zc)
 {
   // Coefficients for C.Lanczos expansion of psi function from XLiFE++
   // gammaFunctions psi_coef[k] = - (2k+1) * lg_coef[k] (see melina++
   // gamma functions -1/12, 3/360,-5/1260, 7/1680,-9/1188,
   // 11*691/360360,-13/156, 15*3617/122400, ? , ?
   static const T dg_coeff[10] = {
@@ -3734,17 +3734,17 @@ Lanczos_approximation_psi (const T zc)
 
   T p = 0;
   for (octave_idx_type k = 0; k < 10; k++, overz2k *= overz2)
     p += dg_coeff[k] * overz2k;
   p += xlog (zc) - T (0.5) / zc;
   return p;
 }
 
-template<class T>
+template <typename T>
 T
 psi (const T& z)
 {
   static const double euler_mascheroni = 0.577215664901532860606512090082402431042;
 
   const bool is_int = (xfloor (z) == z);
 
   T p = 0;
@@ -3790,17 +3790,17 @@ psi (const T& z)
 
   return p;
 }
 
 // explicit instantiations
 template double psi<double> (const double& z);
 template float  psi<float> (const float& z);
 
-template<class T>
+template <typename T>
 std::complex<T>
 psi (const std::complex<T>& z)
 {
   // adapted from XLiFE++ gammaFunctions
 
   typedef typename std::complex<T>::value_type P;
 
   P z_r  = z.real ();
@@ -3840,40 +3840,40 @@ psi (const std::complex<T>& z)
   return dgam;
 }
 
 // explicit instantiations
 template Complex psi<double> (const Complex& z);
 template FloatComplex psi<float> (const FloatComplex& z);
 
 
-template<typename T>
+template <typename T>
 static inline void
 fortran_psifn (const T z, const octave_idx_type n, T* ans,
                octave_idx_type* ierr);
 
-template<>
+template <>
 inline void
 fortran_psifn<double> (const double z, const octave_idx_type n,
                        double* ans, octave_idx_type* ierr)
 {
   octave_idx_type flag = 0;
   F77_XFCN (dpsifn, DPSIFN, (&z, n, 1, 1, ans, &flag, ierr));
 }
 
-template<>
+template <>
 inline void
 fortran_psifn<float> (const float z, const octave_idx_type n,
                       float* ans, octave_idx_type* ierr)
 {
   octave_idx_type flag = 0;
   F77_XFCN (psifn, PSIFN, (&z, n, 1, 1, ans, &flag, ierr));
 }
 
-template<class T>
+template <typename T>
 T
 psi (const octave_idx_type n, const T z)
 {
   T ans;
   octave_idx_type ierr = 0;
   fortran_psifn<T> (z, n, &ans, &ierr);
   if (ierr == 0)
     {
diff --git a/liboctave/numeric/lo-specfun.h b/liboctave/numeric/lo-specfun.h
--- a/liboctave/numeric/lo-specfun.h
+++ b/liboctave/numeric/lo-specfun.h
@@ -661,26 +661,26 @@ extern OCTAVE_API void
 ellipj (double u, double m, double& sn, double& cn, double& dn, double& err);
 extern OCTAVE_API void
 ellipj (const Complex& u, double m, Complex& sn, Complex& cn, Complex& dn,
         double& err);
 
 //! Digamma function.
 //!
 //! Only defined for double and float.
-template<class T>
+template <typename T>
 extern OCTAVE_API T psi (const T& z);
 
 //! Digamma function for complex input.
 //!
 //! Only defined for double and float.
-template<class T>
+template <typename T>
 extern OCTAVE_API std::complex<T> psi (const std::complex<T>& z);
 
 //! Polygamma function.
 //!
 //! Only defined for double and float.
 //! @param n must be non-negative.  If zero, the digamma function is computed.
 //! @param z must be real and non-negative.
-template<class T>
+template <typename T>
 extern OCTAVE_API T psi (const octave_idx_type n, const T z);
 
 #endif
diff --git a/liboctave/numeric/oct-convn.cc b/liboctave/numeric/oct-convn.cc
--- a/liboctave/numeric/oct-convn.cc
+++ b/liboctave/numeric/oct-convn.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 #include <algorithm>
 
 #include "f77-fcn.h"
 
 #include "oct-convn.h"
 #include "oct-locbuf.h"
 
 // 2d convolution with a matrix kernel.
-template <class T, class R>
+template <typename T, typename R>
 static void
 convolve_2d (const T *a, octave_idx_type ma, octave_idx_type na,
              const R *b, octave_idx_type mb, octave_idx_type nb,
              T *c, bool inner);
 
 // Forward instances to our Fortran implementations.
 #define FORWARD_IMPL(T,R,f,F) \
 extern "C" \
@@ -68,17 +68,17 @@ convolve_2d<T, R> (const T *a, octave_id
 
 FORWARD_IMPL (double, double, d, D)
 FORWARD_IMPL (float, float, s, S)
 FORWARD_IMPL (Complex, Complex, z, Z)
 FORWARD_IMPL (FloatComplex, FloatComplex, c, C)
 FORWARD_IMPL (Complex, double, zd, ZD)
 FORWARD_IMPL (FloatComplex, float, cs, CS)
 
-template <class T, class R>
+template <typename T, typename R>
 void convolve_nd (const T *a, const dim_vector& ad, const dim_vector& acd,
                   const R *b, const dim_vector& bd, const dim_vector& bcd,
                   T *c, const dim_vector& ccd, int nd, bool inner)
 {
   if (nd == 2)
     convolve_2d<T, R> (a, ad(0), ad(1), b, bd(0), bd(1), c, inner);
   else
     {
@@ -102,17 +102,17 @@ void convolve_nd (const T *a, const dim_
               convolve_nd<T, R> (a + ma*ja, ad, acd, b + mb*jb, bd, bcd,
                                  c + ldc*(ja+jb), ccd, nd-1, inner);
         }
     }
 }
 
 // Arbitrary convolutor.
 // The 2nd array is assumed to be the smaller one.
-template <class T, class R>
+template <typename T, typename R>
 static MArray<T>
 convolve (const MArray<T>& a, const MArray<R>& b,
           convn_type ct)
 {
   if (a.is_empty () || b.is_empty ())
     return MArray<T> ();
 
   int nd = std::max (a.ndims (), b.ndims ());
diff --git a/liboctave/numeric/oct-fftw.cc b/liboctave/numeric/oct-fftw.cc
--- a/liboctave/numeric/oct-fftw.cc
+++ b/liboctave/numeric/oct-fftw.cc
@@ -733,33 +733,33 @@ octave_float_fftw_planner::do_method (Ff
           rplan = plan[0] = plan[1] = 0;
         }
     }
   else
     ret = UNKNOWN;
   return ret;
 }
 
-template <class T>
+template <typename T>
 static inline void
 convert_packcomplex_1d (T *out, size_t nr, size_t nc,
                         octave_idx_type stride, octave_idx_type dist)
 {
   octave_quit ();
 
   // Fill in the missing data.
 
   for (size_t i = 0; i < nr; i++)
     for (size_t j = nc/2+1; j < nc; j++)
       out[j*stride + i*dist] = conj (out[(nc - j)*stride + i*dist]);
 
   octave_quit ();
 }
 
-template <class T>
+template <typename T>
 static inline void
 convert_packcomplex_Nd (T *out, const dim_vector &dv)
 {
   size_t nc = dv(0);
   size_t nr = dv(1);
   size_t np = (dv.length () > 2 ? dv.numel () / nc / nr : 1);
   size_t nrp = nr * np;
   T *ptr1, *ptr2;
diff --git a/liboctave/numeric/oct-norm.cc b/liboctave/numeric/oct-norm.cc
--- a/liboctave/numeric/oct-norm.cc
+++ b/liboctave/numeric/oct-norm.cc
@@ -62,25 +62,25 @@ along with Octave; see the file COPYING.
 #include "fCmplxSVD.h"
 
 // Theory: norm accumulator is an object that has an accum method able
 // to handle both real and complex element, and a cast operator
 // returning the intermediate norm. Reference: Higham, N. "Estimating
 // the Matrix p-Norm." Numer. Math. 62, 539-555, 1992.
 
 // norm accumulator for the p-norm
-template <class R>
+template <typename R>
 class norm_accumulator_p
 {
   R p,scl,sum;
 public:
   norm_accumulator_p () {} // we need this one for Array
   norm_accumulator_p (R pp) : p(pp), scl(0), sum(1) {}
 
-  template<class U>
+  template <typename U>
   void accum (U val)
   {
     octave_quit ();
     R t = std::abs (val);
     if (scl == t) // we need this to handle Infs properly
       sum += 1;
     else if (scl < t)
       {
@@ -90,25 +90,25 @@ public:
       }
     else if (t != 0)
       sum += std::pow (t/scl, p);
   }
   operator R () { return scl * std::pow (sum, 1/p); }
 };
 
 // norm accumulator for the minus p-pseudonorm
-template <class R>
+template <typename R>
 class norm_accumulator_mp
 {
   R p,scl,sum;
 public:
   norm_accumulator_mp () {} // we need this one for Array
   norm_accumulator_mp (R pp) : p(pp), scl(0), sum(1) {}
 
-  template<class U>
+  template <typename U>
   void accum (U val)
   {
     octave_quit ();
     R t = 1 / std::abs (val);
     if (scl == t)
       sum += 1;
     else if (scl < t)
       {
@@ -118,17 +118,17 @@ public:
       }
     else if (t != 0)
       sum += std::pow (t/scl, p);
   }
   operator R () { return scl * std::pow (sum, -1/p); }
 };
 
 // norm accumulator for the 2-norm (euclidean)
-template <class R>
+template <typename R>
 class norm_accumulator_2
 {
   R scl,sum;
   static R pow2 (R x) { return x*x; }
 public:
   norm_accumulator_2 () : scl(0), sum(1) {}
 
   void accum (R val)
@@ -151,150 +151,150 @@ public:
     accum (val.real ());
     accum (val.imag ());
   }
 
   operator R () { return scl * std::sqrt (sum); }
 };
 
 // norm accumulator for the 1-norm (city metric)
-template <class R>
+template <typename R>
 class norm_accumulator_1
 {
   R sum;
 public:
   norm_accumulator_1 () : sum (0) {}
-  template<class U>
+  template <typename U>
   void accum (U val)
   {
     sum += std::abs (val);
   }
   operator R () { return sum; }
 };
 
 // norm accumulator for the inf-norm (max metric)
-template <class R>
+template <typename R>
 class norm_accumulator_inf
 {
   R max;
 public:
   norm_accumulator_inf () : max (0) {}
-  template<class U>
+  template <typename U>
   void accum (U val)
   {
     max = std::max (max, std::abs (val));
   }
   operator R () { return max; }
 };
 
 // norm accumulator for the -inf pseudonorm (min abs value)
-template <class R>
+template <typename R>
 class norm_accumulator_minf
 {
   R min;
 public:
   norm_accumulator_minf () : min (octave_Inf) {}
-  template<class U>
+  template <typename U>
   void accum (U val)
   {
     min = std::min (min, std::abs (val));
   }
   operator R () { return min; }
 };
 
 // norm accumulator for the 0-pseudonorm (hamming distance)
-template <class R>
+template <typename R>
 class norm_accumulator_0
 {
   unsigned int num;
 public:
   norm_accumulator_0 () : num (0) {}
-  template<class U>
+  template <typename U>
   void accum (U val)
   {
     if (val != static_cast<U> (0)) ++num;
   }
   operator R () { return num; }
 };
 
 
 // OK, we're armed :) Now let's go for the fun
 
-template <class T, class R, class ACC>
+template <typename T, typename R, typename ACC>
 inline void vector_norm (const Array<T>& v, R& res, ACC acc)
 {
   for (octave_idx_type i = 0; i < v.numel (); i++)
     acc.accum (v(i));
 
   res = acc;
 }
 
 // dense versions
-template <class T, class R, class ACC>
+template <typename T, typename R, typename ACC>
 void column_norms (const MArray<T>& m, MArray<R>& res, ACC acc)
 {
   res = MArray<R> (dim_vector (1, m.columns ()));
   for (octave_idx_type j = 0; j < m.columns (); j++)
     {
       ACC accj = acc;
       for (octave_idx_type i = 0; i < m.rows (); i++)
         accj.accum (m(i, j));
 
       res.xelem (j) = accj;
     }
 }
 
-template <class T, class R, class ACC>
+template <typename T, typename R, typename ACC>
 void row_norms (const MArray<T>& m, MArray<R>& res, ACC acc)
 {
   res = MArray<R> (dim_vector (m.rows (), 1));
   std::vector<ACC> acci (m.rows (), acc);
   for (octave_idx_type j = 0; j < m.columns (); j++)
     {
       for (octave_idx_type i = 0; i < m.rows (); i++)
         acci[i].accum (m(i, j));
     }
 
   for (octave_idx_type i = 0; i < m.rows (); i++)
     res.xelem (i) = acci[i];
 }
 
 // sparse versions
-template <class T, class R, class ACC>
+template <typename T, typename R, typename ACC>
 void column_norms (const MSparse<T>& m, MArray<R>& res, ACC acc)
 {
   res = MArray<R> (dim_vector (1, m.columns ()));
   for (octave_idx_type j = 0; j < m.columns (); j++)
     {
       ACC accj = acc;
       for (octave_idx_type k = m.cidx (j); k < m.cidx (j+1); k++)
         accj.accum (m.data (k));
 
       res.xelem (j) = accj;
     }
 }
 
-template <class T, class R, class ACC>
+template <typename T, typename R, typename ACC>
 void row_norms (const MSparse<T>& m, MArray<R>& res, ACC acc)
 {
   res = MArray<R> (dim_vector (m.rows (), 1));
   std::vector<ACC> acci (m.rows (), acc);
   for (octave_idx_type j = 0; j < m.columns (); j++)
     {
       for (octave_idx_type k = m.cidx (j); k < m.cidx (j+1); k++)
         acci[m.ridx (k)].accum (m.data (k));
     }
 
   for (octave_idx_type i = 0; i < m.rows (); i++)
     res.xelem (i) = acci[i];
 }
 
 // now the dispatchers
 #define DEFINE_DISPATCHER(FUNC_NAME, ARG_TYPE, RES_TYPE) \
-template <class T, class R> \
+template <typename T, typename R> \
 RES_TYPE FUNC_NAME (const ARG_TYPE& v, R p) \
 { \
   RES_TYPE res; \
   if (p == 2) \
     FUNC_NAME (v, res, norm_accumulator_2<R> ()); \
   else if (p == 1) \
     FUNC_NAME (v, res, norm_accumulator_1<R> ()); \
   else if (lo_ieee_isinf (p)) \
@@ -317,17 +317,17 @@ DEFINE_DISPATCHER (vector_norm, MArray<T
 DEFINE_DISPATCHER (column_norms, MArray<T>, MArray<R>)
 DEFINE_DISPATCHER (row_norms, MArray<T>, MArray<R>)
 DEFINE_DISPATCHER (column_norms, MSparse<T>, MArray<R>)
 DEFINE_DISPATCHER (row_norms, MSparse<T>, MArray<R>)
 
 // The approximate subproblem in Higham's method. Find lambda and mu such that
 // norm ([lambda, mu], p) == 1 and norm (y*lambda + col*mu, p) is maximized.
 // Real version. As in Higham's paper.
-template <class ColVectorT, class R>
+template <typename ColVectorT, typename R>
 static void
 higham_subp (const ColVectorT& y, const ColVectorT& col,
              octave_idx_type nsamp, R p, R& lambda, R& mu)
 {
   R nrm = 0;
   for (octave_idx_type i = 0; i < nsamp; i++)
     {
       octave_quit ();
@@ -345,17 +345,17 @@ higham_subp (const ColVectorT& y, const 
           nrm = nrm1;
         }
     }
 }
 
 // Complex version. Higham's paper does not deal with complex case, so we use a
 // simple extension. First, guess the magnitudes as in real version, then try
 // to rotate lambda to improve further.
-template <class ColVectorT, class R>
+template <typename ColVectorT, typename R>
 static void
 higham_subp (const ColVectorT& y, const ColVectorT& col,
              octave_idx_type nsamp, R p,
              std::complex<R>& lambda, std::complex<R>& mu)
 {
   typedef std::complex<R> CR;
   R nrm = 0;
   lambda = 1.0;
@@ -390,37 +390,37 @@ higham_subp (const ColVectorT& y, const 
         {
           lambda = lama * lamcu;
           nrm = nrm1;
         }
     }
 }
 
 // the p-dual element (should work for both real and complex)
-template <class T, class R>
+template <typename T, typename R>
 inline T elem_dual_p (T x, R p)
 {
   return signum (x) * std::pow (std::abs (x), p-1);
 }
 
 // the VectorT is used for vectors, but actually it has to be
 // a Matrix type to allow all the operations. For instance SparseMatrix
 // does not support multiplication with column/row vectors.
 // the dual vector
-template <class VectorT, class R>
+template <typename VectorT, typename R>
 VectorT dual_p (const VectorT& x, R p, R q)
 {
   VectorT res (x.dims ());
   for (octave_idx_type i = 0; i < x.numel (); i++)
     res.xelem (i) = elem_dual_p (x(i), p);
   return res / vector_norm (res, q);
 }
 
 // Higham's hybrid method
-template <class MatrixT, class VectorT, class R>
+template <typename MatrixT, typename VectorT, typename R>
 R higham (const MatrixT& m, R p, R tol, int maxiter,
           VectorT& x)
 {
   x.resize (m.columns (), 1);
   // the OSE part
   VectorT y(m.rows (), 1, 0), z(m.rows (), 1);
   typedef typename VectorT::element_type RR;
   RR lambda = 0;
@@ -470,17 +470,17 @@ R higham (const MatrixT& m, R p, R tol, 
 static const char *p_less1_gripe = "xnorm: p must be at least 1";
 
 // Static constant to control the maximum number of iterations.  100 seems to
 // be a good value.  Eventually, we can provide a means to change this
 // constant from Octave.
 static int max_norm_iter = 100;
 
 // version with SVD for dense matrices
-template <class MatrixT, class VectorT, class SVDT, class R>
+template <typename MatrixT, typename VectorT, typename SVDT, typename R>
 R matrix_norm (const MatrixT& m, R p, VectorT, SVDT)
 {
   R res = 0;
   if (p == 2)
     {
       SVDT svd (m, SVD::sigma_only);
       res = svd.singular_values () (0,0);
     }
@@ -496,17 +496,17 @@ R matrix_norm (const MatrixT& m, R p, Ve
     }
   else
     (*current_liboctave_error_handler) (p_less1_gripe);
 
   return res;
 }
 
 // SVD-free version for sparse matrices
-template <class MatrixT, class VectorT, class R>
+template <typename MatrixT, typename VectorT, typename R>
 R matrix_norm (const MatrixT& m, R p, VectorT)
 {
   R res = 0;
   if (p == 1)
     res = xcolnorms (m, 1).max ();
   else if (lo_ieee_isinf (p))
     res = xrownorms (m, 1).max ();
   else if (p > 1)
@@ -534,17 +534,17 @@ R matrix_norm (const MatrixT& m, R p, Ve
   { return vector_norm (x, static_cast<RTYPE> (2)); }
 
 DEFINE_XNORM_FUNCS(, double)
 DEFINE_XNORM_FUNCS(Complex, double)
 DEFINE_XNORM_FUNCS(Float, float)
 DEFINE_XNORM_FUNCS(FloatComplex, float)
 
 // this is needed to avoid copying the sparse matrix for xfrobnorm
-template <class T, class R>
+template <typename T, typename R>
 inline void array_norm_2 (const T* v, octave_idx_type n, R& res)
 {
   norm_accumulator_2<R> acc;
   for (octave_idx_type i = 0; i < n; i++)
     acc.accum (v[i]);
 
   res = acc;
 }
diff --git a/liboctave/numeric/sparse-base-chol.cc b/liboctave/numeric/sparse-base-chol.cc
--- a/liboctave/numeric/sparse-base-chol.cc
+++ b/liboctave/numeric/sparse-base-chol.cc
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 #include "lo-error.h"
 #include "oct-sparse.h"
 #include "oct-spparms.h"
 #include "quit.h"
 #include "MatrixType.h"
 
 #ifdef HAVE_CHOLMOD
 // Can't use CHOLMOD_NAME(drop)(0.0, S, cm). It doesn't treat complex matrices
-template <class chol_type, class chol_elt, class p_type>
+template <typename chol_type, typename chol_elt, typename p_type>
 void
 sparse_base_chol<chol_type, chol_elt, p_type>::sparse_base_chol_rep::drop_zeros
   (const cholmod_sparse* S)
 {
   chol_elt sik;
   octave_idx_type *Sp, *Si;
   chol_elt *Sx;
   octave_idx_type pdest, k, ncol, p, pend;
@@ -72,17 +72,17 @@ sparse_base_chol<chol_type, chol_elt, p_
               pdest++;
             }
         }
     }
   Sp[ncol] = pdest;
 }
 #endif
 
-template <class chol_type, class chol_elt, class p_type>
+template <typename chol_type, typename chol_elt, typename p_type>
 octave_idx_type
 sparse_base_chol<chol_type, chol_elt, p_type>::sparse_base_chol_rep::init
   (const chol_type& a, bool natural, bool force)
 {
   volatile octave_idx_type info = 0;
 
 #ifdef HAVE_CHOLMOD
   octave_idx_type a_nr = a.rows ();
@@ -213,17 +213,17 @@ sparse_base_chol<chol_type, chol_elt, p_
   return info;
 
 #else
   (*current_liboctave_error_handler)
     ("support for CHOLMOD was unavailable or disabled when liboctave was built");
 #endif
 }
 
-template <class chol_type, class chol_elt, class p_type>
+template <typename chol_type, typename chol_elt, typename p_type>
 chol_type
 sparse_base_chol<chol_type, chol_elt, p_type>::L (void) const
 {
 #ifdef HAVE_CHOLMOD
   cholmod_sparse *m = rep->L ();
   octave_idx_type nc = m->ncol;
   octave_idx_type nnz = m->nzmax;
   chol_type ret (m->nrow, nc, nnz);
@@ -235,17 +235,17 @@ sparse_base_chol<chol_type, chol_elt, p_
       ret.xdata (i) = static_cast<chol_elt *>(m->x)[i];
     }
   return ret;
 #else
   return chol_type ();
 #endif
 }
 
-template <class chol_type, class chol_elt, class p_type>
+template <typename chol_type, typename chol_elt, typename p_type>
 p_type
 sparse_base_chol<chol_type, chol_elt, p_type>::
 sparse_base_chol_rep::Q (void) const
 {
 #ifdef HAVE_CHOLMOD
   octave_idx_type n = Lsparse->nrow;
   p_type p (n, n, n);
 
@@ -258,17 +258,17 @@ sparse_base_chol_rep::Q (void) const
   p.xcidx (n) = n;
 
   return p;
 #else
   return p_type ();
 #endif
 }
 
-template <class chol_type, class chol_elt, class p_type>
+template <typename chol_type, typename chol_elt, typename p_type>
 chol_type
 sparse_base_chol<chol_type, chol_elt, p_type>::inverse (void) const
 {
   chol_type retval;
 #ifdef HAVE_CHOLMOD
   cholmod_sparse *m = rep->L ();
   octave_idx_type n = m->ncol;
   ColumnVector perms = rep->perm ();
diff --git a/liboctave/numeric/sparse-base-chol.h b/liboctave/numeric/sparse-base-chol.h
--- a/liboctave/numeric/sparse-base-chol.h
+++ b/liboctave/numeric/sparse-base-chol.h
@@ -22,17 +22,17 @@ along with Octave; see the file COPYING.
 */
 
 #if ! defined (octave_sparse_base_chol_h)
 #define octave_sparse_base_chol_h 1
 
 #include "oct-sparse.h"
 #include "dColVector.h"
 
-template <class chol_type, class chol_elt, class p_type>
+template <typename chol_type, typename chol_elt, typename p_type>
 class
 sparse_base_chol
 {
 protected:
 #ifdef HAVE_CHOLMOD
   class sparse_base_chol_rep
   {
   public:
diff --git a/liboctave/numeric/sparse-base-lu.cc b/liboctave/numeric/sparse-base-lu.cc
--- a/liboctave/numeric/sparse-base-lu.cc
+++ b/liboctave/numeric/sparse-base-lu.cc
@@ -24,17 +24,17 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "sparse-base-lu.h"
 
 #include "PermMatrix.h"
 
-template <class lu_type, class lu_elt_type, class p_type, class p_elt_type>
+template <typename lu_type, typename lu_elt_type, typename p_type, typename p_elt_type>
 lu_type
 sparse_base_lu <lu_type, lu_elt_type, p_type, p_elt_type> :: Y (void) const
 {
   octave_idx_type nr = Lfact.rows ();
   octave_idx_type nz = Lfact.cols ();
   octave_idx_type nc = Ufact.cols ();
 
   lu_type Yout (nr, nc, Lfact.nnz () + Ufact.nnz () - (nr<nz?nr:nz));
@@ -59,17 +59,17 @@ sparse_base_lu <lu_type, lu_elt_type, p_
             }
         }
       Yout.xcidx (j + 1) = ii;
     }
 
   return Yout;
 }
 
-template <class lu_type, class lu_elt_type, class p_type, class p_elt_type>
+template <typename lu_type, typename lu_elt_type, typename p_type, typename p_elt_type>
 p_type
 sparse_base_lu <lu_type, lu_elt_type, p_type, p_elt_type> :: Pr (void) const
 {
 
   octave_idx_type nr = Lfact.rows ();
 
   p_type Pout (nr, nr, nr);
 
@@ -79,39 +79,39 @@ sparse_base_lu <lu_type, lu_elt_type, p_
       Pout.ridx (P (i)) = i;
       Pout.data (i) = 1;
     }
   Pout.cidx (nr) = nr;
 
   return Pout;
 }
 
-template <class lu_type, class lu_elt_type, class p_type, class p_elt_type>
+template <typename lu_type, typename lu_elt_type, typename p_type, typename p_elt_type>
 ColumnVector
 sparse_base_lu <lu_type, lu_elt_type, p_type, p_elt_type> :: Pr_vec (void) const
 {
 
   octave_idx_type nr = Lfact.rows ();
 
   ColumnVector Pout (nr);
 
   for (octave_idx_type i = 0; i < nr; i++)
     Pout.xelem (i) = static_cast<double> (P(i) + 1);
 
   return Pout;
 }
 
-template <class lu_type, class lu_elt_type, class p_type, class p_elt_type>
+template <typename lu_type, typename lu_elt_type, typename p_type, typename p_elt_type>
 PermMatrix
 sparse_base_lu <lu_type, lu_elt_type, p_type, p_elt_type> :: Pr_mat (void) const
 {
   return PermMatrix (P, false);
 }
 
-template <class lu_type, class lu_elt_type, class p_type, class p_elt_type>
+template <typename lu_type, typename lu_elt_type, typename p_type, typename p_elt_type>
 p_type
 sparse_base_lu <lu_type, lu_elt_type, p_type, p_elt_type> :: Pc (void) const
 {
   octave_idx_type nc = Ufact.cols ();
 
   p_type Pout (nc, nc, nc);
 
   for (octave_idx_type i = 0; i < nc; i++)
@@ -120,29 +120,29 @@ sparse_base_lu <lu_type, lu_elt_type, p_
       Pout.ridx (i) = Q (i);
       Pout.data (i) = 1;
     }
   Pout.cidx (nc) = nc;
 
   return Pout;
 }
 
-template <class lu_type, class lu_elt_type, class p_type, class p_elt_type>
+template <typename lu_type, typename lu_elt_type, typename p_type, typename p_elt_type>
 ColumnVector
 sparse_base_lu <lu_type, lu_elt_type, p_type, p_elt_type> :: Pc_vec (void) const
 {
 
   octave_idx_type nc = Ufact.cols ();
 
   ColumnVector Pout (nc);
 
   for (octave_idx_type i = 0; i < nc; i++)
     Pout.xelem (i) = static_cast<double> (Q(i) + 1);
 
   return Pout;
 }
 
-template <class lu_type, class lu_elt_type, class p_type, class p_elt_type>
+template <typename lu_type, typename lu_elt_type, typename p_type, typename p_elt_type>
 PermMatrix
 sparse_base_lu <lu_type, lu_elt_type, p_type, p_elt_type> :: Pc_mat (void) const
 {
   return PermMatrix (Q, true);
 }
diff --git a/liboctave/numeric/sparse-base-lu.h b/liboctave/numeric/sparse-base-lu.h
--- a/liboctave/numeric/sparse-base-lu.h
+++ b/liboctave/numeric/sparse-base-lu.h
@@ -23,17 +23,17 @@ along with Octave; see the file COPYING.
 
 
 #if ! defined (octave_sparse_base_lu_h)
 #define octave_sparse_base_lu_h 1
 
 #include "MArray.h"
 #include "dSparse.h"
 
-template <class lu_type, class lu_elt_type, class p_type, class p_elt_type>
+template <typename lu_type, typename lu_elt_type, typename p_type, typename p_elt_type>
 class
 sparse_base_lu
 {
 public:
 
   sparse_base_lu (void)
     : Lfact (), Ufact (), Rfact (), cond (0), P (), Q () { }
 
diff --git a/liboctave/numeric/sparse-dmsolve.cc b/liboctave/numeric/sparse-dmsolve.cc
--- a/liboctave/numeric/sparse-dmsolve.cc
+++ b/liboctave/numeric/sparse-dmsolve.cc
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 #include "MSparse.h"
 #include "SparseQR.h"
 #include "SparseCmplxQR.h"
 #include "MatrixType.h"
 #include "oct-sort.h"
 #include "oct-locbuf.h"
 #include "oct-inttypes.h"
 
-template <class T>
+template <typename T>
 static MSparse<T>
 dmsolve_extract (const MSparse<T> &A, const octave_idx_type *Pinv,
                  const octave_idx_type *Q, octave_idx_type rst,
                  octave_idx_type rend, octave_idx_type cst,
                  octave_idx_type cend, octave_idx_type maxnz = -1,
                  bool lazy = false)
 {
   octave_idx_type nr = rend - rst;
@@ -120,17 +120,17 @@ dmsolve_extract (const MSparse<double> &
 static MSparse<Complex>
 dmsolve_extract (const MSparse<Complex> &A, const octave_idx_type *Pinv,
                  const octave_idx_type *Q, octave_idx_type rst,
                  octave_idx_type rend, octave_idx_type cst,
                  octave_idx_type cend, octave_idx_type maxnz,
                  bool lazy);
 #endif
 
-template <class T>
+template <typename T>
 static MArray<T>
 dmsolve_extract (const MArray<T> &m, const octave_idx_type *,
                  const octave_idx_type *, octave_idx_type r1,
                  octave_idx_type r2, octave_idx_type c1,
                  octave_idx_type c2)
 {
   r2 -= 1;
   c2 -= 1;
@@ -158,17 +158,17 @@ dmsolve_extract (const MArray<double> &m
 
 static MArray<Complex>
 dmsolve_extract (const MArray<Complex> &m, const octave_idx_type *,
                  const octave_idx_type *, octave_idx_type r1,
                  octave_idx_type r2, octave_idx_type c1,
                  octave_idx_type c2)
 #endif
 
-template <class T>
+template <typename T>
 static void
 dmsolve_insert (MArray<T> &a, const MArray<T> &b, const octave_idx_type *Q,
                 octave_idx_type r, octave_idx_type c)
 {
   T *ax = a.fortran_vec ();
   const T *bx = b.fortran_vec ();
   octave_idx_type anr = a.rows ();
   octave_idx_type nr = b.rows ();
@@ -190,17 +190,17 @@ static void
 dmsolve_insert (MArray<double> &a, const MArray<double> &b,
                 const octave_idx_type *Q, octave_idx_type r, octave_idx_type c);
 
 static void
 dmsolve_insert (MArray<Complex> &a, const MArray<Complex> &b,
                 const octave_idx_type *Q, octave_idx_type r, octave_idx_type c);
 #endif
 
-template <class T>
+template <typename T>
 static void
 dmsolve_insert (MSparse<T> &a, const MSparse<T> &b, const octave_idx_type *Q,
                 octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type b_rows = b.rows ();
   octave_idx_type b_cols = b.cols ();
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
@@ -277,17 +277,17 @@ static void
 dmsolve_insert (MSparse<double> &a, const SparseMatrix &b,
                 const octave_idx_type *Q, octave_idx_type r, octave_idx_type c);
 
 static void
 dmsolve_insert (MSparse<Complex> &a, const MSparse<Complex> &b,
                 const octave_idx_type *Q, octave_idx_type r, octave_idx_type c);
 #endif
 
-template <class T, class RT>
+template <typename T, typename RT>
 static void
 dmsolve_permute (MArray<RT> &a, const MArray<T>& b, const octave_idx_type *p)
 {
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
   const T *Bx = b.fortran_vec ();
   a.resize (dim_vector (b_nr, b_nc));
   RT *Btx = a.fortran_vec ();
@@ -311,17 +311,17 @@ static void
 dmsolve_permute (MArray<Complex> &a, const MArray<double>& b,
                  const octave_idx_type *p);
 
 static void
 dmsolve_permute (MArray<Complex> &a, const MArray<Complex>& b,
                  const octave_idx_type *p);
 #endif
 
-template <class T, class RT>
+template <typename T, typename RT>
 static void
 dmsolve_permute (MSparse<RT> &a, const MSparse<T>& b, const octave_idx_type *p)
 {
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nz = b.nnz ();
   octave_idx_type nz = 0;
   a = MSparse<RT> (b_nr, b_nc, b_nz);
@@ -364,17 +364,17 @@ dmsolve_permute (MSparse<Complex> &a, co
 
 static void
 solve_singularity_warning (double)
 {
   // Dummy singularity handler so that LU solver doesn't flag
   // an error for numerically rank defficient matrices
 }
 
-template <class RT, class ST, class T>
+template <typename RT, typename ST, typename T>
 RT
 dmsolve (const ST &a, const T &b, octave_idx_type &info)
 {
 #ifdef HAVE_CXSPARSE
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
diff --git a/liboctave/operators/mx-inlines.cc b/liboctave/operators/mx-inlines.cc
--- a/liboctave/operators/mx-inlines.cc
+++ b/liboctave/operators/mx-inlines.cc
@@ -37,237 +37,237 @@ along with Octave; see the file COPYING.
 #include "oct-inttypes.h"
 #include "Array.h"
 #include "Array-util.h"
 
 #include "bsxfun.h"
 
 // Provides some commonly repeated, basic loop templates.
 
-template <class R, class S>
+template <typename R, typename S>
 inline void mx_inline_fill (size_t n, R *r, S s) throw ()
 { for (size_t i = 0; i < n; i++) r[i] = s; }
 
 #define DEFMXUNOP(F, OP) \
-template <class R, class X> \
+template <typename R, typename X> \
 inline void F (size_t n, R *r, const X *x) throw () \
 { for (size_t i = 0; i < n; i++) r[i] = OP x[i]; }
 
 DEFMXUNOP (mx_inline_uminus, -)
 
 #define DEFMXUNOPEQ(F, OP) \
-template <class R> \
+template <typename R> \
 inline void F (size_t n, R *r) throw () \
 { for (size_t i = 0; i < n; i++) r[i] = OP r[i]; }
 
 DEFMXUNOPEQ (mx_inline_uminus2, -)
 
 #define DEFMXUNBOOLOP(F, OP) \
-template <class X> \
+template <typename X> \
 inline void F (size_t n, bool *r, const X *x) throw () \
 { const X zero = X (); for (size_t i = 0; i < n; i++) r[i] = x[i] OP zero; }
 
 DEFMXUNBOOLOP (mx_inline_iszero, ==)
 DEFMXUNBOOLOP (mx_inline_notzero, !=)
 
 #define DEFMXBINOP(F, OP) \
-template <class R, class X, class Y> \
+template <typename R, typename X, typename Y> \
 inline void F (size_t n, R *r, const X *x, const Y *y) throw () \
 { for (size_t i = 0; i < n; i++) r[i] = x[i] OP y[i]; } \
-template <class R, class X, class Y> \
+template <typename R, typename X, typename Y> \
 inline void F (size_t n, R *r, const X *x, Y y) throw () \
 { for (size_t i = 0; i < n; i++) r[i] = x[i] OP y; } \
-template <class R, class X, class Y> \
+template <typename R, typename X, typename Y> \
 inline void F (size_t n, R *r, X x, const Y *y) throw () \
 { for (size_t i = 0; i < n; i++) r[i] = x OP y[i]; }
 
 DEFMXBINOP (mx_inline_add, +)
 DEFMXBINOP (mx_inline_sub, -)
 DEFMXBINOP (mx_inline_mul, *)
 DEFMXBINOP (mx_inline_div, /)
 
 #define DEFMXBINOPEQ(F, OP) \
-template <class R, class X> \
+template <typename R, typename X> \
 inline void F (size_t n, R *r, const X *x) throw () \
 { for (size_t i = 0; i < n; i++) r[i] OP x[i]; } \
-template <class R, class X> \
+template <typename R, typename X> \
 inline void F (size_t n, R *r, X x) throw () \
 { for (size_t i = 0; i < n; i++) r[i] OP x; }
 
 DEFMXBINOPEQ (mx_inline_add2, +=)
 DEFMXBINOPEQ (mx_inline_sub2, -=)
 DEFMXBINOPEQ (mx_inline_mul2, *=)
 DEFMXBINOPEQ (mx_inline_div2, /=)
 
 #define DEFMXCMPOP(F, OP) \
-template <class X, class Y> \
+template <typename X, typename Y> \
 inline void F (size_t n, bool *r, const X *x, const Y *y) throw () \
 { for (size_t i = 0; i < n; i++) r[i] = x[i] OP y[i]; } \
-template <class X, class Y> \
+template <typename X, typename Y> \
 inline void F (size_t n, bool *r, const X *x, Y y) throw () \
 { for (size_t i = 0; i < n; i++) r[i] = x[i] OP y; } \
-template <class X, class Y> \
+template <typename X, typename Y> \
 inline void F (size_t n, bool *r, X x, const Y *y) throw () \
 { for (size_t i = 0; i < n; i++) r[i] = x OP y[i]; }
 
 DEFMXCMPOP (mx_inline_lt, <)
 DEFMXCMPOP (mx_inline_le, <=)
 DEFMXCMPOP (mx_inline_gt, >)
 DEFMXCMPOP (mx_inline_ge, >=)
 DEFMXCMPOP (mx_inline_eq, ==)
 DEFMXCMPOP (mx_inline_ne, !=)
 
 // Convert to logical value, for logical op purposes.
-template <class T> inline bool logical_value (T x) { return x; }
-template <class T> inline bool logical_value (const std::complex<T>& x)
+template <typename T> inline bool logical_value (T x) { return x; }
+template <typename T> inline bool logical_value (const std::complex<T>& x)
 { return x.real () != 0 || x.imag () != 0; }
-template <class T> inline bool logical_value (const octave_int<T>& x)
+template <typename T> inline bool logical_value (const octave_int<T>& x)
 { return x.value (); }
 
-template <class X>
+template <typename X>
 void mx_inline_not (size_t n, bool *r, const X* x) throw ()
 {
   for (size_t i = 0; i < n; i++)
     r[i] = ! logical_value (x[i]);
 }
 
 inline void mx_inline_not2 (size_t n, bool *r) throw ()
 {
   for (size_t i = 0; i < n; i++) r[i] = ! r[i];
 }
 
 #define DEFMXBOOLOP(F, NOT1, OP, NOT2) \
-template <class X, class Y> \
+template <typename X, typename Y> \
 inline void F (size_t n, bool *r, const X *x, const Y *y) throw () \
 { \
   for (size_t i = 0; i < n; i++) \
     r[i] = (NOT1 logical_value (x[i])) OP (NOT2 logical_value (y[i])); \
 } \
-template <class X, class Y> \
+template <typename X, typename Y> \
 inline void F (size_t n, bool *r, const X *x, Y y) throw () \
 { \
   const bool yy = (NOT2 logical_value (y)); \
   for (size_t i = 0; i < n; i++) \
     r[i] = (NOT1 logical_value (x[i])) OP yy; \
 } \
-template <class X, class Y> \
+template <typename X, typename Y> \
 inline void F (size_t n, bool *r, X x, const Y *y) throw () \
 { \
   const bool xx = (NOT1 logical_value (x)); \
   for (size_t i = 0; i < n; i++) \
     r[i] = xx OP (NOT2 logical_value (y[i])); \
 }
 
 DEFMXBOOLOP (mx_inline_and, , &, )
 DEFMXBOOLOP (mx_inline_or, , |, )
 DEFMXBOOLOP (mx_inline_not_and, !, &, )
 DEFMXBOOLOP (mx_inline_not_or, !, |, )
 DEFMXBOOLOP (mx_inline_and_not, , &, !)
 DEFMXBOOLOP (mx_inline_or_not, , |, !)
 
 #define DEFMXBOOLOPEQ(F, OP) \
-template <class X> \
+template <typename X> \
 inline void F (size_t n, bool *r, const X *x) throw () \
 { \
   for (size_t i = 0; i < n; i++) \
     r[i] OP logical_value (x[i]); \
 } \
-template <class X> \
+template <typename X> \
 inline void F (size_t n, bool *r, X x) throw () \
 { for (size_t i = 0; i < n; i++) r[i] OP x; }
 
 DEFMXBOOLOPEQ (mx_inline_and2, &=)
 DEFMXBOOLOPEQ (mx_inline_or2, |=)
 
-template <class T>
+template <typename T>
 inline bool
 mx_inline_any_nan (size_t n, const T* x)  throw ()
 {
   for (size_t i = 0; i < n; i++)
     {
       if (xisnan (x[i]))
         return true;
     }
 
   return false;
 }
 
-template <class T>
+template <typename T>
 inline bool
 mx_inline_all_finite (size_t n, const T* x)  throw ()
 {
   for (size_t i = 0; i < n; i++)
     {
       if (! xfinite (x[i]))
         return false;
     }
 
   return true;
 }
 
-template <class T>
+template <typename T>
 inline bool
 mx_inline_any_negative (size_t n, const T* x) throw ()
 {
   for (size_t i = 0; i < n; i++)
     {
       if (x[i] < 0)
         return true;
     }
 
   return false;
 }
 
-template <class T>
+template <typename T>
 inline bool
 mx_inline_any_positive (size_t n, const T* x) throw ()
 {
   for (size_t i = 0; i < n; i++)
     {
       if (x[i] > 0)
         return true;
     }
 
   return false;
 }
 
-template<class T>
+template <typename T>
 inline bool
 mx_inline_all_real (size_t n, const std::complex<T>* x) throw ()
 {
   for (size_t i = 0; i < n; i++)
     {
       if (x[i].imag () != 0)
         return false;
     }
 
   return true;
 }
 
 #define DEFMXMAPPER(F, FUN) \
-template <class T> \
+template <typename T> \
 inline void F (size_t n, T *r, const T *x) throw () \
 { for (size_t i = 0; i < n; i++) r[i] = FUN (x[i]); }
 
-template<class T>
+template <typename T>
 inline void mx_inline_real (size_t n, T *r, const std::complex<T>* x) throw ()
 { for (size_t i = 0; i < n; i++) r[i] = x[i].real (); }
-template<class T>
+template <typename T>
 inline void mx_inline_imag (size_t n, T *r, const std::complex<T>* x) throw ()
 { for (size_t i = 0; i < n; i++) r[i] = x[i].imag (); }
 
 // Pairwise minimums/maximums
 #define DEFMXMAPPER2(F, FUN) \
-template <class T> \
+template <typename T> \
 inline void F (size_t n, T *r, const T *x, const T *y) throw () \
 { for (size_t i = 0; i < n; i++) r[i] = FUN (x[i], y[i]); } \
-template <class T> \
+template <typename T> \
 inline void F (size_t n, T *r, const T *x, T y) throw () \
 { for (size_t i = 0; i < n; i++) r[i] = FUN (x[i], y); } \
-template <class T> \
+template <typename T> \
 inline void F (size_t n, T *r, T x, const T *y) throw () \
 { for (size_t i = 0; i < n; i++) r[i] = FUN (x, y[i]); }
 
 DEFMXMAPPER2 (mx_inline_xmin, xmin)
 DEFMXMAPPER2 (mx_inline_xmax, xmax)
 
 // Specialize array-scalar max/min
 #define DEFMINMAXSPEC(T, F, OP) \
@@ -290,80 +290,80 @@ inline void F<T> (size_t n, T *r, T x, c
 
 DEFMINMAXSPEC (double, mx_inline_xmin, <=)
 DEFMINMAXSPEC (double, mx_inline_xmax, >=)
 DEFMINMAXSPEC (float, mx_inline_xmin, <=)
 DEFMINMAXSPEC (float, mx_inline_xmax, >=)
 
 // Pairwise power
 #define DEFMXMAPPER2X(F, FUN) \
-template <class R, class X, class Y> \
+template <typename R, typename X, typename Y> \
 inline void F (size_t n, R *r, const X *x, const Y *y) throw () \
 { for (size_t i = 0; i < n; i++) r[i] = FUN (x[i], y[i]); } \
-template <class R, class X, class Y> \
+template <typename R, typename X, typename Y> \
 inline void F (size_t n, R *r, const X *x, Y y) throw () \
 { for (size_t i = 0; i < n; i++) r[i] = FUN (x[i], y); } \
-template <class R, class X, class Y> \
+template <typename R, typename X, typename Y> \
 inline void F (size_t n, R *r, X x, const Y *y) throw () \
 { for (size_t i = 0; i < n; i++) r[i] = FUN (x, y[i]); }
 
 // Let the compiler decide which pow to use, whichever best matches the
 // arguments provided.
 using std::pow;
 DEFMXMAPPER2X (mx_inline_pow, pow)
 
 // Arbitrary function appliers. The function is a template parameter to enable
 // inlining.
-template <class R, class X, R fun (X x)>
+template <typename R, typename X, R fun (X x)>
 inline void mx_inline_map (size_t n, R *r, const X *x) throw ()
 { for (size_t i = 0; i < n; i++) r[i] = fun (x[i]); }
 
-template <class R, class X, R fun (const X& x)>
+template <typename R, typename X, R fun (const X& x)>
 inline void mx_inline_map (size_t n, R *r, const X *x) throw ()
 { for (size_t i = 0; i < n; i++) r[i] = fun (x[i]); }
 
 // Appliers. Since these call the operation just once, we pass it as
 // a pointer, to allow the compiler reduce number of instances.
 
-template <class R, class X>
+template <typename R, typename X>
 inline Array<R>
 do_mx_unary_op (const Array<X>& x,
                 void (*op) (size_t, R *, const X *) throw ())
 {
   Array<R> r (x.dims ());
   op (r.numel (), r.fortran_vec (), x.data ());
   return r;
 }
 
 // Shortcuts for applying mx_inline_map.
 
-template <class R, class X, R fun (X)>
+template <typename R, typename X, R fun (X)>
 inline Array<R>
 do_mx_unary_map (const Array<X>& x)
 {
   return do_mx_unary_op<R, X> (x, mx_inline_map<R, X, fun>);
 }
 
-template <class R, class X, R fun (const X&)>
+template <typename R, typename X, R fun (const X&)>
 inline Array<R>
 do_mx_unary_map (const Array<X>& x)
 {
   return do_mx_unary_op<R, X> (x, mx_inline_map<R, X, fun>);
 }
 
-template <class R>
+template <typename R>
 inline Array<R>&
 do_mx_inplace_op (Array<R>& r,
                   void (*op) (size_t, R *) throw ())
 {
   op (r.numel (), r.fortran_vec ());
   return r;
 }
 
-template <class R, class X, class Y>
+template <typename R, typename X, typename Y>
 inline Array<R>
 do_mm_binary_op (const Array<X>& x, const Array<Y>& y,
                  void (*op) (size_t, R *, const X *, const Y *) throw (),
                  void (*op1) (size_t, R *, X, const Y *) throw (),
                  void (*op2) (size_t, R *, const X *, Y) throw (),
                  const char *opname)
 {
   dim_vector dx = x.dims ();
@@ -377,37 +377,37 @@ do_mm_binary_op (const Array<X>& x, cons
   else if (is_valid_bsxfun (opname, dx, dy))
     {
       return do_bsxfun_op (x, y, op, op1, op2);
     }
   else
     err_nonconformant (opname, dx, dy);
 }
 
-template <class R, class X, class Y>
+template <typename R, typename X, typename Y>
 inline Array<R>
 do_ms_binary_op (const Array<X>& x, const Y& y,
                  void (*op) (size_t, R *, const X *, Y) throw ())
 {
   Array<R> r (x.dims ());
   op (r.numel (), r.fortran_vec (), x.data (), y);
   return r;
 }
 
-template <class R, class X, class Y>
+template <typename R, typename X, typename Y>
 inline Array<R>
 do_sm_binary_op (const X& x, const Array<Y>& y,
                  void (*op) (size_t, R *, X, const Y *) throw ())
 {
   Array<R> r (y.dims ());
   op (r.numel (), r.fortran_vec (), x, y.data ());
   return r;
 }
 
-template <class R, class X>
+template <typename R, typename X>
 inline Array<R>&
 do_mm_inplace_op (Array<R>& r, const Array<X>& x,
                   void (*op) (size_t, R *, const X *) throw (),
                   void (*op1) (size_t, R *, X) throw (),
                   const char *opname)
 {
   dim_vector dr = r.dims ();
   dim_vector dx = x.dims ();
@@ -416,58 +416,58 @@ do_mm_inplace_op (Array<R>& r, const Arr
   else if (is_valid_inplace_bsxfun (opname, dr, dx))
     do_inplace_bsxfun_op (r, x, op, op1);
   else
     err_nonconformant (opname, dr, dx);
 
   return r;
 }
 
-template <class R, class X>
+template <typename R, typename X>
 inline Array<R>&
 do_ms_inplace_op (Array<R>& r, const X& x,
                   void (*op) (size_t, R *, X) throw ())
 {
   op (r.numel (), r.fortran_vec (), x);
   return r;
 }
 
-template <class T1, class T2>
+template <typename T1, typename T2>
 inline bool
 mx_inline_equal (size_t n, const T1 *x, const T2 *y) throw ()
 {
   for (size_t i = 0; i < n; i++)
     if (x[i] != y[i])
       return false;
   return true;
 }
 
-template <class T>
+template <typename T>
 inline bool
 do_mx_check (const Array<T>& a,
              bool (*op) (size_t, const T *) throw ())
 {
   return op (a.numel (), a.data ());
 }
 
 // NOTE: we don't use std::norm because it typically does some heavyweight
 // magic to avoid underflows, which we don't need here.
-template <class T>
+template <typename T>
 inline T cabsq (const std::complex<T>& c)
 { return c.real () * c.real () + c.imag () * c.imag (); }
 
 // default. works for integers and bool.
-template <class T>
+template <typename T>
 inline bool xis_true (T x) { return x; }
-template <class T>
+template <typename T>
 inline bool xis_false (T x) { return ! x; }
 // for octave_ints
-template <class T>
+template <typename T>
 inline bool xis_true (const octave_int<T>& x) { return x.value (); }
-template <class T>
+template <typename T>
 inline bool xis_false (const octave_int<T>& x) { return ! x.value (); }
 // for reals, we want to ignore NaNs.
 inline bool xis_true (double x) { return ! xisnan (x) && x != 0.0; }
 inline bool xis_false (double x) { return x == 0.0; }
 inline bool xis_true (float x) { return ! xisnan (x) && x != 0.0f; }
 inline bool xis_false (float x) { return x == 0.0f; }
 // Ditto for complex.
 inline bool xis_true (const Complex& x) { return ! xisnan (x) && x != 0.0; }
@@ -479,34 +479,34 @@ inline bool xis_false (const FloatComple
 #define OP_RED_PROD(ac, el) ac *= el
 #define OP_RED_SUMSQ(ac, el) ac += el*el
 #define OP_RED_SUMSQC(ac, el) ac += cabsq (el)
 
 inline void op_dble_prod (double& ac, float el)
 { ac *= el; }
 inline void op_dble_prod (Complex& ac, const FloatComplex& el)
 { ac *= el; } // FIXME: guaranteed?
-template <class T>
+template <typename T>
 inline void op_dble_prod (double& ac, const octave_int<T>& el)
 { ac *= el.double_value (); }
 
 inline void op_dble_sum (double& ac, float el)
 { ac += el; }
 inline void op_dble_sum (Complex& ac, const FloatComplex& el)
 { ac += el; } // FIXME: guaranteed?
-template <class T>
+template <typename T>
 inline void op_dble_sum (double& ac, const octave_int<T>& el)
 { ac += el.double_value (); }
 
 // The following two implement a simple short-circuiting.
 #define OP_RED_ANYC(ac, el) if (xis_true (el)) { ac = true; break; } else continue
 #define OP_RED_ALLC(ac, el) if (xis_false (el)) { ac = false; break; } else continue
 
 #define OP_RED_FCN(F, TSRC, TRES, OP, ZERO) \
-template <class T> \
+template <typename T> \
 inline TRES \
 F (const TSRC* v, octave_idx_type n) \
 { \
   TRES ac = ZERO; \
   for (octave_idx_type i = 0; i < n; i++) \
     OP(ac, v[i]); \
   return ac; \
 }
@@ -520,17 +520,17 @@ OP_RED_FCN (mx_inline_prod, T, T, OP_RED
 OP_RED_FCN (mx_inline_dprod, T, PROMOTE_DOUBLE(T), op_dble_prod, 1)
 OP_RED_FCN (mx_inline_sumsq, T, T, OP_RED_SUMSQ, 0)
 OP_RED_FCN (mx_inline_sumsq, std::complex<T>, T, OP_RED_SUMSQC, 0)
 OP_RED_FCN (mx_inline_any, T, bool, OP_RED_ANYC, false)
 OP_RED_FCN (mx_inline_all, T, bool, OP_RED_ALLC, true)
 
 
 #define OP_RED_FCN2(F, TSRC, TRES, OP, ZERO) \
-template <class T> \
+template <typename T> \
 inline void \
 F (const TSRC* v, TRES *r, octave_idx_type m, octave_idx_type n) \
 { \
   for (octave_idx_type i = 0; i < m; i++) \
     r[i] = ZERO; \
   for (octave_idx_type j = 0; j < n; j++) \
     { \
       for (octave_idx_type i = 0; i < m; i++) \
@@ -553,17 +553,17 @@ OP_RED_FCN2 (mx_inline_sumsq, std::compl
 OP_RED_FCN2 (mx_inline_any_r, T, bool, OP_RED_ANYR, false)
 OP_RED_FCN2 (mx_inline_all_r, T, bool, OP_RED_ALLR, true)
 
 // Using the general code for any/all would sacrifice short-circuiting.
 // OTOH, going by rows would sacrifice cache-coherence. The following algorithm
 // will achieve both, at the cost of a temporary octave_idx_type array.
 
 #define OP_ROW_SHORT_CIRCUIT(F, PRED, ZERO) \
-template <class T> \
+template <typename T> \
 inline void \
 F (const T* v, bool *r, octave_idx_type m, octave_idx_type n) \
 { \
   if (n <= 8) \
     return F ## _r (v, r, m, n); \
   \
   /* FIXME: it may be sub-optimal to allocate the buffer here. */ \
   OCTAVE_LOCAL_BUFFER (octave_idx_type, iact, m); \
@@ -584,17 +584,17 @@ F (const T* v, bool *r, octave_idx_type 
   for (octave_idx_type i = 0; i < m; i++) r[i] = ! ZERO; \
   for (octave_idx_type i = 0; i < nact; i++) r[iact[i]] = ZERO; \
 }
 
 OP_ROW_SHORT_CIRCUIT (mx_inline_any, xis_true, false)
 OP_ROW_SHORT_CIRCUIT (mx_inline_all, xis_false, true)
 
 #define OP_RED_FCNN(F, TSRC, TRES) \
-template <class T> \
+template <typename T> \
 inline void \
 F (const TSRC *v, TRES *r, octave_idx_type l, \
    octave_idx_type n, octave_idx_type u) \
 { \
   if (l == 1) \
     { \
       for (octave_idx_type i = 0; i < u; i++) \
         { \
@@ -619,34 +619,34 @@ OP_RED_FCNN (mx_inline_count, bool, T)
 OP_RED_FCNN (mx_inline_prod, T, T)
 OP_RED_FCNN (mx_inline_dprod, T, PROMOTE_DOUBLE(T))
 OP_RED_FCNN (mx_inline_sumsq, T, T)
 OP_RED_FCNN (mx_inline_sumsq, std::complex<T>, T)
 OP_RED_FCNN (mx_inline_any, T, bool)
 OP_RED_FCNN (mx_inline_all, T, bool)
 
 #define OP_CUM_FCN(F, TSRC, TRES, OP) \
-template <class T> \
+template <typename T> \
 inline void \
 F (const TSRC *v, TRES *r, octave_idx_type n) \
 { \
   if (n) \
     { \
       TRES t = r[0] = v[0]; \
       for (octave_idx_type i = 1; i < n; i++) \
         r[i] = t = t OP v[i]; \
     } \
 }
 
 OP_CUM_FCN (mx_inline_cumsum, T, T, +)
 OP_CUM_FCN (mx_inline_cumprod, T, T, *)
 OP_CUM_FCN (mx_inline_cumcount, bool, T, +)
 
 #define OP_CUM_FCN2(F, TSRC, TRES, OP) \
-template <class T> \
+template <typename T> \
 inline void \
 F (const TSRC *v, TRES *r, octave_idx_type m, octave_idx_type n) \
 { \
   if (n) \
     { \
       for (octave_idx_type i = 0; i < m; i++) \
         r[i] = v[i]; \
       const T *r0 = r; \
@@ -660,17 +660,17 @@ F (const TSRC *v, TRES *r, octave_idx_ty
     } \
 }
 
 OP_CUM_FCN2 (mx_inline_cumsum, T, T, +)
 OP_CUM_FCN2 (mx_inline_cumprod, T, T, *)
 OP_CUM_FCN2 (mx_inline_cumcount, bool, T, +)
 
 #define OP_CUM_FCNN(F, TSRC, TRES) \
-template <class T> \
+template <typename T> \
 inline void \
 F (const TSRC *v, TRES *r, octave_idx_type l, \
    octave_idx_type n, octave_idx_type u) \
 { \
   if (l == 1) \
     { \
       for (octave_idx_type i = 0; i < u; i++) \
         { \
@@ -689,32 +689,32 @@ F (const TSRC *v, TRES *r, octave_idx_ty
     } \
 }
 
 OP_CUM_FCNN (mx_inline_cumsum, T, T)
 OP_CUM_FCNN (mx_inline_cumprod, T, T)
 OP_CUM_FCNN (mx_inline_cumcount, bool, T)
 
 #define OP_MINMAX_FCN(F, OP) \
-template <class T> \
+template <typename T> \
 void F (const T *v, T *r, octave_idx_type n) \
 { \
   if (! n) return; \
   T tmp = v[0]; \
   octave_idx_type i = 1; \
   if (xisnan (tmp)) \
     { \
       for (; i < n && xisnan (v[i]); i++) ; \
       if (i < n) tmp = v[i]; \
     } \
   for (; i < n; i++) \
     if (v[i] OP tmp) tmp = v[i]; \
   *r = tmp; \
 } \
-template <class T> \
+template <typename T> \
 void F (const T *v, T *r, octave_idx_type *ri, octave_idx_type n) \
 { \
   if (! n) return; \
   T tmp = v[0]; \
   octave_idx_type tmpi = 0; \
   octave_idx_type i = 1; \
   if (xisnan (tmp)) \
     { \
@@ -730,17 +730,17 @@ void F (const T *v, T *r, octave_idx_typ
 OP_MINMAX_FCN (mx_inline_min, <)
 OP_MINMAX_FCN (mx_inline_max, >)
 
 // Row reductions will be slightly complicated.  We will proceed with checks
 // for NaNs until we detect that no row will yield a NaN, in which case we
 // proceed to a faster code.
 
 #define OP_MINMAX_FCN2(F, OP) \
-template <class T> \
+template <typename T> \
 inline void \
 F (const T *v, T *r, octave_idx_type m, octave_idx_type n) \
 { \
   if (! n) return; \
   bool nan = false; \
   octave_idx_type j = 0; \
   for (octave_idx_type i = 0; i < m; i++) \
     {  \
@@ -762,17 +762,17 @@ F (const T *v, T *r, octave_idx_type m, 
     } \
   while (j < n) \
     { \
       for (octave_idx_type i = 0; i < m; i++) \
         if (v[i] OP r[i]) r[i] = v[i]; \
       j++; v += m; \
     } \
 } \
-template <class T> \
+template <typename T> \
 inline void \
 F (const T *v, T *r, octave_idx_type *ri, \
    octave_idx_type m, octave_idx_type n) \
 { \
   if (! n) return; \
   bool nan = false; \
   octave_idx_type j = 0; \
   for (octave_idx_type i = 0; i < m; i++) \
@@ -801,17 +801,17 @@ F (const T *v, T *r, octave_idx_type *ri
       j++; v += m; \
     } \
 }
 
 OP_MINMAX_FCN2 (mx_inline_min, <)
 OP_MINMAX_FCN2 (mx_inline_max, >)
 
 #define OP_MINMAX_FCNN(F) \
-template <class T> \
+template <typename T> \
 inline void \
 F (const T *v, T *r, octave_idx_type l, \
    octave_idx_type n, octave_idx_type u) \
 { \
   if (! n) return; \
   if (l == 1) \
     { \
       for (octave_idx_type i = 0; i < u; i++) \
@@ -825,17 +825,17 @@ F (const T *v, T *r, octave_idx_type l, 
       for (octave_idx_type i = 0; i < u; i++) \
         { \
           F (v, r, l, n); \
           v += l*n; \
           r += l; \
         } \
     } \
 } \
-template <class T> \
+template <typename T> \
 inline void \
 F (const T *v, T *r, octave_idx_type *ri, \
    octave_idx_type l, octave_idx_type n, octave_idx_type u) \
 { \
   if (! n) return; \
   if (l == 1) \
     { \
       for (octave_idx_type i = 0; i < u; i++) \
@@ -854,17 +854,17 @@ F (const T *v, T *r, octave_idx_type *ri
         } \
     } \
 }
 
 OP_MINMAX_FCNN (mx_inline_min)
 OP_MINMAX_FCNN (mx_inline_max)
 
 #define OP_CUMMINMAX_FCN(F, OP) \
-template <class T> \
+template <typename T> \
 void F (const T *v, T *r, octave_idx_type n) \
 { \
   if (! n) return; \
   T tmp = v[0]; \
   octave_idx_type i = 1; \
   octave_idx_type j = 0; \
   if (xisnan (tmp)) \
     { \
@@ -875,17 +875,17 @@ void F (const T *v, T *r, octave_idx_typ
   for (; i < n; i++) \
     if (v[i] OP tmp) \
       { \
         for (; j < i; j++) r[j] = tmp; \
         tmp = v[i]; \
       } \
   for (; j < i; j++) r[j] = tmp; \
 } \
-template <class T> \
+template <typename T> \
 void F (const T *v, T *r, octave_idx_type *ri, octave_idx_type n) \
 { \
   if (! n) return; \
   T tmp = v[0]; octave_idx_type tmpi = 0; \
   octave_idx_type i = 1; \
   octave_idx_type j = 0; \
   if (xisnan (tmp)) \
     { \
@@ -905,17 +905,17 @@ void F (const T *v, T *r, octave_idx_typ
 OP_CUMMINMAX_FCN (mx_inline_cummin, <)
 OP_CUMMINMAX_FCN (mx_inline_cummax, >)
 
 // Row reductions will be slightly complicated.  We will proceed with checks
 // for NaNs until we detect that no row will yield a NaN, in which case we
 // proceed to a faster code.
 
 #define OP_CUMMINMAX_FCN2(F, OP) \
-template <class T> \
+template <typename T> \
 inline void \
 F (const T *v, T *r, octave_idx_type m, octave_idx_type n) \
 { \
   if (! n) return; \
   bool nan = false; \
   const T *r0; \
   octave_idx_type j = 0; \
   for (octave_idx_type i = 0; i < m; i++) \
@@ -943,17 +943,17 @@ F (const T *v, T *r, octave_idx_type m, 
       for (octave_idx_type i = 0; i < m; i++) \
         if (v[i] OP r0[i]) \
           r[i] = v[i]; \
         else \
           r[i] = r0[i]; \
       j++; v += m; r0 = r; r += m; \
     } \
 } \
-template <class T> \
+template <typename T> \
 inline void \
 F (const T *v, T *r, octave_idx_type *ri, \
    octave_idx_type m, octave_idx_type n) \
 { \
   if (! n) return; \
   bool nan = false; \
   const T *r0; const octave_idx_type *r0i; \
   octave_idx_type j = 0; \
@@ -987,17 +987,17 @@ F (const T *v, T *r, octave_idx_type *ri
       j++; v += m; r0 = r; r += m; r0i = ri; ri += m;  \
     } \
 }
 
 OP_CUMMINMAX_FCN2 (mx_inline_cummin, <)
 OP_CUMMINMAX_FCN2 (mx_inline_cummax, >)
 
 #define OP_CUMMINMAX_FCNN(F) \
-template <class T> \
+template <typename T> \
 inline void \
 F (const T *v, T *r, octave_idx_type l, \
    octave_idx_type n, octave_idx_type u) \
 { \
   if (! n) return; \
   if (l == 1) \
     { \
       for (octave_idx_type i = 0; i < u; i++) \
@@ -1011,17 +1011,17 @@ F (const T *v, T *r, octave_idx_type l, 
       for (octave_idx_type i = 0; i < u; i++) \
         { \
           F (v, r, l, n); \
           v += l*n; \
           r += l*n; \
         } \
     } \
 } \
-template <class T> \
+template <typename T> \
 inline void \
 F (const T *v, T *r, octave_idx_type *ri, \
    octave_idx_type l, octave_idx_type n, octave_idx_type u) \
 { \
   if (! n) return; \
   if (l == 1) \
     { \
       for (octave_idx_type i = 0; i < u; i++) \
@@ -1039,17 +1039,17 @@ F (const T *v, T *r, octave_idx_type *ri
           r += l*n; ri += l*n; \
         } \
     } \
 }
 
 OP_CUMMINMAX_FCNN (mx_inline_cummin)
 OP_CUMMINMAX_FCNN (mx_inline_cummax)
 
-template <class T>
+template <typename T>
 void mx_inline_diff (const T *v, T *r, octave_idx_type n,
                      octave_idx_type order)
 {
   switch (order)
     {
     case 1:
       for (octave_idx_type i = 0; i < n-1; i++)
         r[i] = v[i+1] - v[i];
@@ -1080,17 +1080,17 @@ void mx_inline_diff (const T *v, T *r, o
           }
 
         for (octave_idx_type i = 0; i < n-order; i++)
           r[i] = buf[i];
       }
     }
 }
 
-template <class T>
+template <typename T>
 void mx_inline_diff (const T *v, T *r,
                      octave_idx_type m, octave_idx_type n,
                      octave_idx_type order)
 {
   switch (order)
     {
     case 1:
       for (octave_idx_type i = 0; i < m*(n-1); i++)
@@ -1120,17 +1120,17 @@ void mx_inline_diff (const T *v, T *r,
 
             for (octave_idx_type i = 0; i < n-order; i++)
               r[i*m+j] = buf[i];
           }
       }
     }
 }
 
-template <class T>
+template <typename T>
 inline void
 mx_inline_diff (const T *v, T *r,
                 octave_idx_type l, octave_idx_type n, octave_idx_type u,
                 octave_idx_type order)
 {
   if (! n) return;
   if (l == 1)
     {
@@ -1178,17 +1178,17 @@ get_extent_triplet (const dim_vector& di
         u *= dims(i);
     }
 }
 
 // Appliers.
 // FIXME: is this the best design? C++ gives a lot of options here...
 // maybe it can be done without an explicit parameter?
 
-template <class R, class T>
+template <typename R, typename T>
 inline Array<R>
 do_mx_red_op (const Array<T>& src, int dim,
               void (*mx_red_op) (const T *, R *, octave_idx_type,
                                  octave_idx_type, octave_idx_type))
 {
   octave_idx_type l, n, u;
   dim_vector dims = src.dims ();
   // M*b inconsistency: sum ([]) = 0 etc.
@@ -1202,34 +1202,34 @@ do_mx_red_op (const Array<T>& src, int d
   dims.chop_trailing_singletons ();
 
   Array<R> ret (dims);
   mx_red_op (src.data (), ret.fortran_vec (), l, n, u);
 
   return ret;
 }
 
-template <class R, class T>
+template <typename R, typename T>
 inline Array<R>
 do_mx_cum_op (const Array<T>& src, int dim,
               void (*mx_cum_op) (const T *, R *, octave_idx_type,
                                  octave_idx_type, octave_idx_type))
 {
   octave_idx_type l, n, u;
   dim_vector dims = src.dims ();
   get_extent_triplet (dims, dim, l, n, u);
 
   // Cumulative operation doesn't reduce the array size.
   Array<R> ret (dims);
   mx_cum_op (src.data (), ret.fortran_vec (), l, n, u);
 
   return ret;
 }
 
-template <class R>
+template <typename R>
 inline Array<R>
 do_mx_minmax_op (const Array<R>& src, int dim,
                  void (*mx_minmax_op) (const R *, R *, octave_idx_type,
                                        octave_idx_type, octave_idx_type))
 {
   octave_idx_type l, n, u;
   dim_vector dims = src.dims ();
   get_extent_triplet (dims, dim, l, n, u);
@@ -1239,17 +1239,17 @@ do_mx_minmax_op (const Array<R>& src, in
   dims.chop_trailing_singletons ();
 
   Array<R> ret (dims);
   mx_minmax_op (src.data (), ret.fortran_vec (), l, n, u);
 
   return ret;
 }
 
-template <class R>
+template <typename R>
 inline Array<R>
 do_mx_minmax_op (const Array<R>& src, Array<octave_idx_type>& idx, int dim,
                  void (*mx_minmax_op) (const R *, R *, octave_idx_type *,
                                        octave_idx_type, octave_idx_type, octave_idx_type))
 {
   octave_idx_type l, n, u;
   dim_vector dims = src.dims ();
   get_extent_triplet (dims, dim, l, n, u);
@@ -1262,33 +1262,33 @@ do_mx_minmax_op (const Array<R>& src, Ar
   if (idx.dims () != dims) idx = Array<octave_idx_type> (dims);
 
   mx_minmax_op (src.data (), ret.fortran_vec (), idx.fortran_vec (),
                 l, n, u);
 
   return ret;
 }
 
-template <class R>
+template <typename R>
 inline Array<R>
 do_mx_cumminmax_op (const Array<R>& src, int dim,
                     void (*mx_cumminmax_op) (const R *, R *, octave_idx_type,
                                              octave_idx_type, octave_idx_type))
 {
   octave_idx_type l, n, u;
   dim_vector dims = src.dims ();
   get_extent_triplet (dims, dim, l, n, u);
 
   Array<R> ret (dims);
   mx_cumminmax_op (src.data (), ret.fortran_vec (), l, n, u);
 
   return ret;
 }
 
-template <class R>
+template <typename R>
 inline Array<R>
 do_mx_cumminmax_op (const Array<R>& src, Array<octave_idx_type>& idx, int dim,
                     void (*mx_cumminmax_op) (const R *, R *, octave_idx_type *,
                                              octave_idx_type, octave_idx_type, octave_idx_type))
 {
   octave_idx_type l, n, u;
   dim_vector dims = src.dims ();
   get_extent_triplet (dims, dim, l, n, u);
@@ -1297,17 +1297,17 @@ do_mx_cumminmax_op (const Array<R>& src,
   if (idx.dims () != dims) idx = Array<octave_idx_type> (dims);
 
   mx_cumminmax_op (src.data (), ret.fortran_vec (), idx.fortran_vec (),
                    l, n, u);
 
   return ret;
 }
 
-template <class R>
+template <typename R>
 inline Array<R>
 do_mx_diff_op (const Array<R>& src, int dim, octave_idx_type order,
                void (*mx_diff_op) (const R *, R *,
                                    octave_idx_type, octave_idx_type, octave_idx_type,
                                    octave_idx_type))
 {
   octave_idx_type l, n, u;
   if (order <= 0)
@@ -1335,40 +1335,40 @@ do_mx_diff_op (const Array<R>& src, int 
   return ret;
 }
 
 // Fast extra-precise summation. According to
 // T. Ogita, S. M. Rump, S. Oishi:
 // Accurate Sum And Dot Product,
 // SIAM J. Sci. Computing, Vol. 26, 2005
 
-template <class T>
+template <typename T>
 inline void twosum_accum (T& s, T& e,
                           const T& x)
 {
   T s1 = s + x;
   T t = s1 - s;
   T e1 = (s - (s1 - t)) + (x - t);
   s = s1;
   e += e1;
 }
 
-template <class T>
+template <typename T>
 inline T
 mx_inline_xsum (const T *v, octave_idx_type n)
 {
   T s, e;
   s = e = 0;
   for (octave_idx_type i = 0; i < n; i++)
     twosum_accum (s, e, v[i]);
 
   return s + e;
 }
 
-template <class T>
+template <typename T>
 inline void
 mx_inline_xsum (const T *v, T *r,
                 octave_idx_type m, octave_idx_type n)
 {
   OCTAVE_LOCAL_BUFFER (T, e, m);
   for (octave_idx_type i = 0; i < m; i++)
     e[i] = r[i] = T ();
 
diff --git a/liboctave/util/action-container.h b/liboctave/util/action-container.h
--- a/liboctave/util/action-container.h
+++ b/liboctave/util/action-container.h
@@ -69,17 +69,17 @@ public:
 
   private:
     void (*e_fptr) (void);
   };
 
   // An element that stores a variable of type T along with a void (*) (T)
   // function pointer, and calls the function with the parameter.
 
-  template <class T>
+  template <typename T>
   class fcn_arg_elem : public elem
   {
   public:
     fcn_arg_elem (void (*fcn) (T), T arg)
       : e_fcn (fcn), e_arg (arg) { }
 
     void run (void) { e_fcn (e_arg); }
 
@@ -94,33 +94,33 @@ public:
     void (*e_fcn) (T);
     T e_arg;
   };
 
   // An element that stores a variable of type T along with a
   // void (*) (const T&) function pointer, and calls the function with
   // the parameter.
 
-  template <class T>
+  template <typename T>
   class fcn_crefarg_elem : public elem
   {
   public:
     fcn_crefarg_elem (void (*fcn) (const T&), const T& arg)
       : e_fcn (fcn), e_arg (arg) { }
 
     void run (void) { e_fcn (e_arg); }
 
   private:
     void (*e_fcn) (const T&);
     T e_arg;
   };
 
   // An element for calling a member function.
 
-  template <class T>
+  template <typename T>
   class method_elem : public elem
   {
   public:
     method_elem (T *obj, void (T::*method) (void))
       : e_obj (obj), e_method (method) { }
 
     void run (void) { (e_obj->*e_method) (); }
 
@@ -133,17 +133,17 @@ public:
 
     method_elem (const method_elem&);
 
     method_elem operator = (const method_elem&);
   };
 
   // An element for calling a member function with a single argument
 
-  template <class T, class A>
+  template <typename T, typename A>
   class method_arg_elem : public elem
   {
   public:
     method_arg_elem (T *obj, void (T::*method) (A), A arg)
       : e_obj (obj), e_method (method), e_arg (arg) { }
 
     void run (void) { (e_obj->*e_method) (e_arg); }
 
@@ -157,17 +157,17 @@ public:
 
     method_arg_elem (const method_arg_elem&);
 
     method_arg_elem operator = (const method_arg_elem&);
   };
 
   // An element for calling a member function with a single argument
 
-  template <class T, class A>
+  template <typename T, typename A>
   class method_crefarg_elem : public elem
   {
   public:
     method_crefarg_elem (T *obj, void (T::*method) (const A&), const A& arg)
       : e_obj (obj), e_method (method), e_arg (arg) { }
 
     void run (void) { (e_obj->*e_method) (e_arg); }
 
@@ -181,17 +181,17 @@ public:
 
     method_crefarg_elem (const method_crefarg_elem&);
 
     method_crefarg_elem operator = (const method_crefarg_elem&);
   };
 
   // An element that stores arbitrary variable, and restores it.
 
-  template <class T>
+  template <typename T>
   class restore_var_elem : public elem
   {
   public:
     restore_var_elem (T& ref, const T& val)
       : e_ptr (&ref), e_val (val) { }
 
     void run (void) { *e_ptr = e_val; }
 
@@ -203,17 +203,17 @@ public:
 
     restore_var_elem& operator = (const restore_var_elem&);
 
     T *e_ptr, e_val;
   };
 
   // Deletes a class allocated using new.
 
-  template <class T>
+  template <typename T>
   class delete_ptr_elem : public elem
   {
   public:
     delete_ptr_elem (T *ptr)
       : e_ptr (ptr) { }
 
     void run (void) { delete e_ptr; }
 
@@ -236,67 +236,67 @@ public:
 
   // Call to void func (void).
   void add_fcn (void (*fcn) (void))
   {
     add (new fcn_elem (fcn));
   }
 
   // Call to void func (T).
-  template <class T>
+  template <typename T>
   void add_fcn (void (*action) (T), T val)
   {
     add (new fcn_arg_elem<T> (action, val));
   }
 
   // Call to void func (const T&).
-  template <class T>
+  template <typename T>
   void add_fcn (void (*action) (const T&), const T& val)
   {
     add (new fcn_crefarg_elem<T> (action, val));
   }
 
   // Call to T::method (void).
-  template <class T>
+  template <typename T>
   void add_method (T *obj, void (T::*method) (void))
   {
     add (new method_elem<T> (obj, method));
   }
 
   // Call to T::method (A).
-  template <class T, class A>
+  template <typename T, typename A>
   void add_method (T *obj, void (T::*method) (A), A arg)
   {
     add (new method_arg_elem<T, A> (obj, method, arg));
   }
 
   // Call to T::method (const A&).
-  template <class T, class A>
+  template <typename T, typename A>
   void add_method (T *obj, void (T::*method) (const A&), const A& arg)
   {
     add (new method_crefarg_elem<T, A> (obj, method, arg));
   }
 
   // Call to delete (T*).
 
-  template <class T>
+  template <typename T>
   void add_delete (T *obj)
   {
     add (new delete_ptr_elem<T> (obj));
   }
 
   // Protect any variable.
-  template <class T>
+  template <typename T>
   void protect_var (T& var)
   {
     add (new restore_var_elem<T> (var, var));
   }
 
   // Protect any variable, value given.
-  template <class T>
+  template <typename T>
   void protect_var (T& var, const T& val)
   {
     add (new restore_var_elem<T> (var, val));
   }
 
   operator bool (void) const { return ! empty (); }
 
   virtual void run_first (void) = 0;
diff --git a/liboctave/util/base-list.h b/liboctave/util/base-list.h
--- a/liboctave/util/base-list.h
+++ b/liboctave/util/base-list.h
@@ -41,17 +41,17 @@ public:
 
   bool empty (void) const { return lst.empty (); }
 
   size_t size (void) const { return lst.size (); }
   size_t length (void) const { return size (); }
 
   iterator erase (iterator pos) { return lst.erase (pos); }
 
-  template <class P>
+  template <typename P>
   void remove_if (P pred)
   {
     lst.remove_if (pred);
 
     // FIXME: kluge removed 8/7/13.  Eventually this commented
     //        code should be deleted.
     //
     // FIXME: this kluge should be removed at some point.
diff --git a/liboctave/util/lo-traits.h b/liboctave/util/lo-traits.h
--- a/liboctave/util/lo-traits.h
+++ b/liboctave/util/lo-traits.h
@@ -27,127 +27,127 @@ along with Octave; see the file COPYING.
 // Guide by David Vandevoorde and Nicolai M. Josuttis, Addison-Wesley
 // (2003).
 
 // Select a type based on the value of a constant expression.
 
 template <bool cond, typename T1, typename T2>
 class if_then_else;
 
-template<typename T1, typename T2>
+template <typename T1, typename T2>
 class if_then_else<true, T1, T2>
 {
 public:
 
   typedef T1 result;
 };
 
-template<typename T1, typename T2>
+template <typename T1, typename T2>
 class if_then_else<false, T1, T2>
 {
 public:
 
   typedef T2 result;
 };
 
 // Determine whether two types are equal.
-template <class T1, class T2>
+template <typename T1, typename T2>
 class equal_types
 {
 public:
 
   static const bool value = false;
 };
 
-template <class T>
+template <typename T>
 class equal_types <T, T>
 {
 public:
 
   static const bool value = true;
 };
 
 // Determine whether a type is an instance of a template.
 
-template <template <class> class Template, class T>
+template <template <typename> class Template, typename T>
 class is_instance
 {
 public:
 
   static const bool value = false;
 };
 
-template <template <class> class Template, class T>
+template <template <typename> class Template, typename T>
 class is_instance <Template, Template<T> >
 {
 public:
 
   static const bool value = true;
 };
 
 // Determine whether a template paramter is a class type.
 
-template<typename T1>
+template <typename T1>
 class is_class_type
 {
 private:
 
   typedef char one;
   typedef struct { char c[2]; } two;
 
   // Classes can have pointers to members.
-  template<typename T2> static one is_class_type_test (int T2::*);
+  template <typename T2> static one is_class_type_test (int T2::*);
 
   // Catch everything else.
-  template<typename T2> static two is_class_type_test (...);
+  template <typename T2> static two is_class_type_test (...);
 
 public:
 
   enum { yes = sizeof (is_class_type_test<T1> (0)) == 1 };
   enum { no = ! yes };
 };
 
 // Define typename ref_param<T>::type as T const& if T is a class
 // type.  Otherwise, define it to be T.
 
-template<typename T>
+template <typename T>
 class ref_param
 {
 public:
 
   typedef typename if_then_else<is_class_type<T>::no, T, T const&>::result type;
 };
 
 // Will turn TemplatedClass<T> to T, leave T otherwise.
 // Useful for stripping wrapper classes, like octave_int.
 
-template<template<typename> class TemplatedClass, typename T>
+template <template <typename> class TemplatedClass, typename T>
 class strip_template_param
 {
 public:
   typedef T type;
 };
 
-template<template<typename> class TemplatedClass, typename T>
+template <template <typename> class TemplatedClass, typename T>
 class strip_template_param<TemplatedClass, TemplatedClass<T> >
 {
 public:
   typedef T type;
 };
 
 // Will turn TemplatedClass<T> to TemplatedClass<S>, T to S otherwise.
 // Useful for generic promotions.
 
-template<template<typename> class TemplatedClass, typename T, typename S>
+template <template <typename> class TemplatedClass, typename T, typename S>
 class subst_template_param
 {
 public:
   typedef S type;
 };
 
-template<template<typename> class TemplatedClass, typename T, typename S>
+template <template <typename> class TemplatedClass, typename T, typename S>
 class subst_template_param<TemplatedClass, TemplatedClass<T>, S>
 {
 public:
   typedef TemplatedClass<S> type;
 };
 
 #endif
diff --git a/liboctave/util/lo-utils.h b/liboctave/util/lo-utils.h
--- a/liboctave/util/lo-utils.h
+++ b/liboctave/util/lo-utils.h
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 
 #include "quit.h"
 
 #include "lo-cutils.h"
 #include "oct-cmplx.h"
 
 // Generic any/all test functionality with arbitrary predicate.
 
-template <class F, class T, bool zero>
+template <typename F, typename T, bool zero>
 bool
 any_all_test (F fcn, const T *m, octave_idx_type len)
 {
   octave_idx_type i;
 
   for (i = 0; i < len - 3; i += 4)
     {
       octave_quit ();
diff --git a/liboctave/util/oct-base64.h b/liboctave/util/oct-base64.h
--- a/liboctave/util/oct-base64.h
+++ b/liboctave/util/oct-base64.h
@@ -20,17 +20,17 @@ along with Octave; see the file COPYING.
 
 */
 
 #if ! defined (octave_oct_base64_h)
 #define octave_oct_base64_h 1
 
 #include <string>
 
-template<class T> class Array;
+template <typename T> class Array;
 
 extern OCTAVE_API bool
 octave_base64_encode (const char *inc, const size_t inlen, char **out);
 
 extern OCTAVE_API Array<double>
 octave_base64_decode (const std::string& str);
 
 #endif
diff --git a/liboctave/util/oct-binmap.h b/liboctave/util/oct-binmap.h
--- a/liboctave/util/oct-binmap.h
+++ b/liboctave/util/oct-binmap.h
@@ -55,17 +55,17 @@ along with Octave; see the file COPYING.
 // Additionally, f can be an arbitrary functor object.
 //
 // octave_quit() is called at appropriate places, hence the operation
 // is breakable.
 
 // The following template wrappers are provided for automatic bsxfun
 // calls (see the function signature for do_bsxfun_op).
 
-template<typename R, typename X, typename Y, typename F>
+template <typename R, typename X, typename Y, typename F>
 class bsxfun_wrapper
 {
 private:
   static F f;
 
 public:
   static void
   set_f (const F& f_in)
@@ -91,22 +91,22 @@ public:
   op_ms (size_t n , R* r, const X* x, Y y)
   {
     for (size_t i = 0; i < n; i++)
       r[i] = f (x[i], y);
   }
 };
 
 // Static init
-template<typename R, typename X, typename Y, typename F>
+template <typename R, typename X, typename Y, typename F>
 F bsxfun_wrapper<R, X, Y, F>::f;
 
 
 // scalar-Array
-template <class U, class T, class R, class F>
+template <typename U, typename T, typename R, typename F>
 Array<U>
 binmap (const T& x, const Array<R>& ya, F fcn)
 {
   octave_idx_type len = ya.numel ();
 
   const R *y = ya.data ();
 
   Array<U> result (ya.dims ());
@@ -127,17 +127,17 @@ binmap (const T& x, const Array<R>& ya, 
 
   for (; i < len; i++)
     p[i] = fcn (x, y[i]);
 
   return result;
 }
 
 // Array-scalar
-template <class U, class T, class R, class F>
+template <typename U, typename T, typename R, typename F>
 Array<U>
 binmap (const Array<T>& xa, const R& y, F fcn)
 {
   octave_idx_type len = xa.numel ();
 
   const R *x = xa.data ();
 
   Array<U> result (xa.dims ());
@@ -158,17 +158,17 @@ binmap (const Array<T>& xa, const R& y, 
 
   for (; i < len; i++)
     p[i] = fcn (x[i], y);
 
   return result;
 }
 
 // Array-Array (treats singletons as scalars)
-template <class U, class T, class R, class F>
+template <typename U, typename T, typename R, typename F>
 Array<U>
 binmap (const Array<T>& xa, const Array<R>& ya, F fcn, const char *name)
 {
   dim_vector xad = xa.dims ();
   dim_vector yad = ya.dims ();
   if (xa.numel () == 1)
     return binmap<U, T, R, F> (xa(0), ya, fcn);
   else if (ya.numel () == 1)
@@ -208,17 +208,17 @@ binmap (const Array<T>& xa, const Array<
 
   for (; i < len; i++)
     p[i] = fcn (x[i], y[i]);
 
   return result;
 }
 
 // scalar-Sparse
-template <class U, class T, class R, class F>
+template <typename U, typename T, typename R, typename F>
 Sparse<U>
 binmap (const T& x, const Sparse<R>& ys, F fcn)
 {
   R yzero = R ();
   U fz = fcn (x, yzero);
 
   if (fz == U ())  // Sparsity preserving fcn
     {
@@ -239,17 +239,17 @@ binmap (const T& x, const Sparse<R>& ys,
       retval.maybe_compress (true);
       return retval;
     }
   else
     return Sparse<U> (binmap<U, T, R, F> (x, ys.array_value (), fcn));
 }
 
 // Sparse-scalar
-template <class U, class T, class R, class F>
+template <typename U, typename T, typename R, typename F>
 Sparse<U>
 binmap (const Sparse<T>& xs, const R& y, F fcn)
 {
   T xzero = T ();
   U fz = fcn (xzero, y);
 
   if (fz == U ())  // Sparsity preserving fcn
     {
@@ -270,17 +270,17 @@ binmap (const Sparse<T>& xs, const R& y,
       retval.maybe_compress (true);
       return retval;
     }
   else
     return Sparse<U> (binmap<U, T, R, F> (xs.array_value (), y, fcn));
 }
 
 // Sparse-Sparse (treats singletons as scalars)
-template <class U, class T, class R, class F>
+template <typename U, typename T, typename R, typename F>
 Sparse<U>
 binmap (const Sparse<T>& xs, const Sparse<R>& ys, F fcn, const char *name)
 {
   if (xs.rows () == 1 && xs.cols () == 1)
     return binmap<U, T, R, F> (xs(0,0), ys, fcn);
   else if (ys.rows () == 1 && ys.cols () == 1)
     return binmap<U, T, R, F> (xs, ys(0,0), fcn);
   else if (xs.dims () != ys.dims ())
@@ -349,143 +349,143 @@ binmap (const Sparse<T>& xs, const Spars
     return Sparse<U> (binmap<U, T, R, F> (xs.array_value (), ys.array_value (),
                                           fcn, name));
 }
 
 // Overloads for function pointers.
 
 // Signature (T, R)
 
-template <class U, class T, class R>
+template <typename U, typename T, typename R>
 inline Array<U>
 binmap (const Array<T>& xa, const Array<R>& ya, U (*fcn) (T, R),
         const char *name)
 { return binmap<U, T, R, U (*) (T, R)> (xa, ya, fcn, name); }
 
-template <class U, class T, class R>
+template <typename U, typename T, typename R>
 inline Array<U>
 binmap (const T& x, const Array<R>& ya, U (*fcn) (T, R))
 { return binmap<U, T, R, U (*) (T, R)> (x, ya, fcn); }
 
-template <class U, class T, class R>
+template <typename U, typename T, typename R>
 inline Array<U>
 binmap (const Array<T>& xa, const R& y, U (*fcn) (T, R))
 { return binmap<U, T, R, U (*) (T, R)> (xa, y, fcn); }
 
-template <class U, class T, class R>
+template <typename U, typename T, typename R>
 inline Sparse<U>
 binmap (const Sparse<T>& xa, const Sparse<R>& ya, U (*fcn) (T, R),
         const char *name)
 { return binmap<U, T, R, U (*) (T, R)> (xa, ya, fcn, name); }
 
-template <class U, class T, class R>
+template <typename U, typename T, typename R>
 inline Sparse<U>
 binmap (const T& x, const Sparse<R>& ya, U (*fcn) (T, R))
 { return binmap<U, T, R, U (*) (T, R)> (x, ya, fcn); }
 
-template <class U, class T, class R>
+template <typename U, typename T, typename R>
 inline Sparse<U>
 binmap (const Sparse<T>& xa, const R& y, U (*fcn) (T, R))
 { return binmap<U, T, R, U (*) (T, R)> (xa, y, fcn); }
 
 // Signature (const T&, const R&)
 
-template <class U, class T, class R>
+template <typename U, typename T, typename R>
 inline Array<U>
 binmap (const Array<T>& xa, const Array<R>& ya, U (*fcn) (const T&, const R&),
         const char *name)
 { return binmap<U, T, R, U (*) (const T&, const R&)> (xa, ya, fcn, name); }
 
-template <class U, class T, class R>
+template <typename U, typename T, typename R>
 inline Array<U>
 binmap (const T& x, const Array<R>& ya, U (*fcn) (const T&, const R&))
 { return binmap<U, T, R, U (*) (const T&, const R&)> (x, ya, fcn); }
 
-template <class U, class T, class R>
+template <typename U, typename T, typename R>
 inline Array<U>
 binmap (const Array<T>& xa, const R& y, U (*fcn) (const T&, const R&))
 { return binmap<U, T, R, U (*) (const T&, const R&)> (xa, y, fcn); }
 
-template <class U, class T, class R>
+template <typename U, typename T, typename R>
 inline Sparse<U>
 binmap (const Sparse<T>& xa, const Sparse<R>& ya, U (*fcn) (const T&, const R&),
         const char *name)
 { return binmap<U, T, R, U (*) (const T&, const R&)> (xa, ya, fcn, name); }
 
-template <class U, class T, class R>
+template <typename U, typename T, typename R>
 inline Sparse<U>
 binmap (const T& x, const Sparse<R>& ya, U (*fcn) (const T&, const R&))
 { return binmap<U, T, R, U (*) (const T&, const R&)> (x, ya, fcn); }
 
-template <class U, class T, class R>
+template <typename U, typename T, typename R>
 inline Sparse<U>
 binmap (const Sparse<T>& xa, const R& y, U (*fcn) (const T&, const R&))
 { return binmap<U, T, R, U (*) (const T&, const R&)> (xa, y, fcn); }
 
 // Signature (const T&, R)
 
-template <class U, class T, class R>
+template <typename U, typename T, typename R>
 inline Array<U>
 binmap (const Array<T>& xa, const Array<R>& ya, U (*fcn) (const T&, R),
         const char *name)
 { return binmap<U, T, R, U (*) (const T&, R)> (xa, ya, fcn, name); }
 
-template <class U, class T, class R>
+template <typename U, typename T, typename R>
 inline Array<U>
 binmap (const T& x, const Array<R>& ya, U (*fcn) (const T&, R))
 { return binmap<U, T, R, U (*) (const T&, R)> (x, ya, fcn); }
 
-template <class U, class T, class R>
+template <typename U, typename T, typename R>
 inline Array<U>
 binmap (const Array<T>& xa, const R& y, U (*fcn) (const T&, R))
 { return binmap<U, T, R, U (*) (const T&, R)> (xa, y, fcn); }
 
-template <class U, class T, class R>
+template <typename U, typename T, typename R>
 inline Sparse<U>
 binmap (const Sparse<T>& xa, const Sparse<R>& ya, U (*fcn) (const T&, R),
         const char *name)
 { return binmap<U, T, R, U (*) (const T&, R)> (xa, ya, fcn, name); }
 
-template <class U, class T, class R>
+template <typename U, typename T, typename R>
 inline Sparse<U>
 binmap (const T& x, const Sparse<R>& ya, U (*fcn) (const T&, R))
 { return binmap<U, T, R, U (*) (const T&, R)> (x, ya, fcn); }
 
-template <class U, class T, class R>
+template <typename U, typename T, typename R>
 inline Sparse<U>
 binmap (const Sparse<T>& xa, const R& y, U (*fcn) (const T&, R))
 { return binmap<U, T, R, U (*) (const T&, R)> (xa, y, fcn); }
 
 // Signature (T, const R&)
 
-template <class U, class T, class R>
+template <typename U, typename T, typename R>
 inline Array<U>
 binmap (const Array<T>& xa, const Array<R>& ya, U (*fcn) (T, const R&),
         const char *name)
 { return binmap<U, T, R, U (*) (T, const R&)> (xa, ya, fcn, name); }
 
-template <class U, class T, class R>
+template <typename U, typename T, typename R>
 inline Array<U>
 binmap (const T& x, const Array<R>& ya, U (*fcn) (T, const R&))
 { return binmap<U, T, R, U (*) (T, const R&)> (x, ya, fcn); }
 
-template <class U, class T, class R>
+template <typename U, typename T, typename R>
 inline Array<U>
 binmap (const Array<T>& xa, const R& y, U (*fcn) (T, const R&))
 { return binmap<U, T, R, U (*) (T, const R&)> (xa, y, fcn); }
 
-template <class U, class T, class R>
+template <typename U, typename T, typename R>
 inline Sparse<U>
 binmap (const Sparse<T>& xa, const Sparse<R>& ya, U (*fcn) (T, const R&),
         const char *name)
 { return binmap<U, T, R, U (*) (T, const R&)> (xa, ya, fcn, name); }
 
-template <class U, class T, class R>
+template <typename U, typename T, typename R>
 inline Sparse<U>
 binmap (const T& x, const Sparse<R>& ya, U (*fcn) (T, const R&))
 { return binmap<U, T, R, U (*) (T, const R&)> (x, ya, fcn); }
 
-template <class U, class T, class R>
+template <typename U, typename T, typename R>
 inline Sparse<U>
 binmap (const Sparse<T>& xa, const R& y, U (*fcn) (T, const R&))
 { return binmap<U, T, R, U (*) (T, const R&)> (xa, y, fcn); }
 
 #endif
diff --git a/liboctave/util/oct-cmplx.h b/liboctave/util/oct-cmplx.h
--- a/liboctave/util/oct-cmplx.h
+++ b/liboctave/util/oct-cmplx.h
@@ -36,17 +36,17 @@ typedef std::complex<float> FloatComplex
 // The abs/arg comparison is definitely more useful (the other one is emulated
 // rather trivially), so let's be consistent and use that all over.
 
 // The standard C library function arg() returns [-pi,pi], which creates a
 // non-unique representation for numbers along the negative real axis branch
 // cut.  Change this to principal value (-pi,pi] by mapping -pi to pi.
 
 #define DEF_COMPLEXR_COMP(OP, OPS) \
-template <class T> \
+template <typename T> \
 inline bool operator OP (const std::complex<T>& a, const std::complex<T>& b) \
 { \
   FLOAT_TRUNCATE const T ax = std::abs (a); \
   FLOAT_TRUNCATE const T bx = std::abs (b); \
   if (ax == bx) \
     { \
       FLOAT_TRUNCATE const T ay = std::arg (a); \
       FLOAT_TRUNCATE const T by = std::arg (b); \
@@ -59,32 +59,32 @@ inline bool operator OP (const std::comp
         { \
           return ay OP static_cast<T> (M_PI); \
         } \
       return ay OP by; \
     } \
   else \
     return ax OPS bx; \
 } \
-template <class T> \
+template <typename T> \
 inline bool operator OP (const std::complex<T>& a, T b) \
 { \
   FLOAT_TRUNCATE const T ax = std::abs (a); \
   FLOAT_TRUNCATE const T bx = std::abs (b); \
   if (ax == bx) \
     { \
       FLOAT_TRUNCATE const T ay = std::arg (a); \
       if (ay == static_cast<T> (-M_PI)) \
         return static_cast<T> (M_PI) OP 0; \
       return ay OP 0; \
     } \
   else \
     return ax OPS bx; \
 } \
-template <class T> \
+template <typename T> \
 inline bool operator OP (T a, const std::complex<T>& b) \
 { \
   FLOAT_TRUNCATE const T ax = std::abs (a); \
   FLOAT_TRUNCATE const T bx = std::abs (b); \
   if (ax == bx) \
     { \
       FLOAT_TRUNCATE const T by = std::arg (b); \
       if (by == static_cast<T> (-M_PI)) \
diff --git a/liboctave/util/oct-inttypes.cc b/liboctave/util/oct-inttypes.cc
--- a/liboctave/util/oct-inttypes.cc
+++ b/liboctave/util/oct-inttypes.cc
@@ -26,20 +26,20 @@ along with Octave; see the file COPYING.
 #endif
 
 #include <fpucw.h>
 
 #include "lo-error.h"
 
 #include "oct-inttypes.h"
 
-template<class T>
+template <typename T>
 const octave_int<T> octave_int<T>::zero (static_cast<T> (0));
 
-template<class T>
+template <typename T>
 const octave_int<T> octave_int<T>::one (static_cast<T> (1));
 
 // define type names.
 #define DECLARE_OCTAVE_INT_TYPENAME(TYPE, TYPENAME) \
   template <> \
   OCTAVE_API const char * \
   octave_int<TYPE>::type_name () { return TYPENAME; }
 
@@ -52,33 +52,33 @@ DECLARE_OCTAVE_INT_TYPENAME (uint16_t, "
 DECLARE_OCTAVE_INT_TYPENAME (uint32_t, "uint32")
 DECLARE_OCTAVE_INT_TYPENAME (uint64_t, "uint64")
 
 #ifdef OCTAVE_INT_USE_LONG_DOUBLE
 
 #ifdef OCTAVE_ENSURE_LONG_DOUBLE_OPERATIONS_ARE_NOT_TRUNCATED
 
 #define DEFINE_OCTAVE_LONG_DOUBLE_CMP_OP_TEMPLATES(T) \
-  template <class xop> \
+  template <typename xop> \
   bool \
   octave_int_cmp_op::external_mop (double x, T y) \
   { \
      DECL_LONG_DOUBLE_ROUNDING \
    \
      BEGIN_LONG_DOUBLE_ROUNDING (); \
    \
      bool retval = xop::op (static_cast<long double> (x), \
                             static_cast<long double> (y)); \
    \
      END_LONG_DOUBLE_ROUNDING (); \
    \
      return retval; \
   } \
    \
-  template <class xop> \
+  template <typename xop> \
   bool \
   octave_int_cmp_op::external_mop (T x, double y) \
   { \
      DECL_LONG_DOUBLE_ROUNDING \
    \
      BEGIN_LONG_DOUBLE_ROUNDING (); \
    \
      bool retval = xop::op (static_cast<long double> (x), \
@@ -184,17 +184,17 @@ OCTAVE_LONG_DOUBLE_OPS(octave_int64);
 OCTAVE_LONG_DOUBLE_OPS(octave_uint64);
 
 #endif
 
 #else
 
 // Define comparison operators
 
-template <class xop>
+template <typename xop>
 bool
 octave_int_cmp_op::emulate_mop (uint64_t x, double y)
 {
   static const double xxup = std::numeric_limits<uint64_t>::max ();
   // This converts to the nearest double. Unless there's an equality, the
   // result is clear.
   double xx = x;
   if (xx != y)
@@ -204,17 +204,17 @@ octave_int_cmp_op::emulate_mop (uint64_t
       // If equality occurred we compare as integers.
       if (xx == xxup)
         return xop::gtval;
       else
         return xop::op (x, static_cast<uint64_t> (xx));
     }
 }
 
-template <class xop>
+template <typename xop>
 bool
 octave_int_cmp_op::emulate_mop (int64_t x, double y)
 {
   static const double xxup = std::numeric_limits<int64_t>::max ();
   static const double xxlo = std::numeric_limits<int64_t>::min ();
   // This converts to the nearest double. Unless there's an equality, the
   // result is clear.
   double xx = x;
@@ -231,17 +231,17 @@ octave_int_cmp_op::emulate_mop (int64_t 
         return xop::op (x, static_cast<int64_t> (xx));
     }
 
 }
 
 // We define double-int operations by reverting the operator
 
 // A trait class reverting the operator
-template <class xop>
+template <typename xop>
 class rev_op
 {
 public:
   typedef xop op;
 };
 
 #define DEFINE_REVERTED_OPERATOR(OP1,OP2) \
   template <> \
@@ -251,25 +251,25 @@ public:
     typedef octave_int_cmp_op::OP2 op; \
   }
 
 DEFINE_REVERTED_OPERATOR(lt,gt);
 DEFINE_REVERTED_OPERATOR(gt,lt);
 DEFINE_REVERTED_OPERATOR(le,ge);
 DEFINE_REVERTED_OPERATOR(ge,le);
 
-template <class xop>
+template <typename xop>
 bool
 octave_int_cmp_op::emulate_mop (double x, uint64_t y)
 {
   typedef typename rev_op<xop>::op rop;
   return mop<rop> (y, x);
 }
 
-template <class xop>
+template <typename xop>
 bool
 octave_int_cmp_op::emulate_mop (double x, int64_t y)
 {
   typedef typename rev_op<xop>::op rop;
   return mop<rop> (y, x);
 }
 
 
@@ -658,24 +658,17 @@ INSTANTIATE_INT64_DOUBLE_CMP_OP(lt);
 INSTANTIATE_INT64_DOUBLE_CMP_OP(le);
 INSTANTIATE_INT64_DOUBLE_CMP_OP(gt);
 INSTANTIATE_INT64_DOUBLE_CMP_OP(ge);
 INSTANTIATE_INT64_DOUBLE_CMP_OP(eq);
 INSTANTIATE_INT64_DOUBLE_CMP_OP(ne);
 
 #endif
 
-//template <class T>
-//bool
-//xisnan (const octave_int<T>&)
-//{
-//  return false;
-//}
-
-template <class T>
+template <typename T>
 octave_int<T>
 pow (const octave_int<T>& a, const octave_int<T>& b)
 {
   octave_int<T> retval;
 
   octave_int<T> zero = static_cast<T> (0);
   octave_int<T> one = static_cast<T> (1);
 
@@ -707,53 +700,53 @@ pow (const octave_int<T>& a, const octav
           if (b_val)
             a_val = a_val * a_val;
         }
     }
 
   return retval;
 }
 
-template <class T>
+template <typename T>
 octave_int<T>
 pow (const double& a, const octave_int<T>& b)
 { return octave_int<T> (pow (a, b.double_value ())); }
 
-template <class T>
+template <typename T>
 octave_int<T>
 pow (const octave_int<T>& a, const double& b)
 {
   return ((b >= 0 && b < std::numeric_limits<T>::digits && b == xround (b))
           ? pow (a, octave_int<T> (static_cast<T> (b)))
           : octave_int<T> (pow (a.double_value (), b)));
 }
 
-template <class T>
+template <typename T>
 octave_int<T>
 pow (const float& a, const octave_int<T>& b)
 { return octave_int<T> (pow (a, b.float_value ())); }
 
-template <class T>
+template <typename T>
 octave_int<T>
 pow (const octave_int<T>& a, const float& b)
 {
   return ((b >= 0 && b < std::numeric_limits<T>::digits && b == xround (b))
           ? pow (a, octave_int<T> (static_cast<T> (b)))
           : octave_int<T> (pow (a.double_value (), static_cast<double> (b))));
 }
 
 // FIXME: Do we really need a differently named single-precision
 //        function integer power function here instead of an overloaded
 //        one?
-template <class T>
+template <typename T>
 octave_int<T>
 powf (const float& a, const octave_int<T>& b)
 { return octave_int<T> (pow (a, b.float_value ())); }
 
-template <class T>
+template <typename T>
 octave_int<T>
 powf (const octave_int<T>& a, const float& b)
 {
   return ((b >= 0 && b < std::numeric_limits<T>::digits && b == xround (b))
           ? pow (a, octave_int<T> (static_cast<T> (b)))
           : octave_int<T> (pow (a.double_value (), static_cast<double> (b))));
 }
 
diff --git a/liboctave/util/oct-inttypes.h b/liboctave/util/oct-inttypes.h
--- a/liboctave/util/oct-inttypes.h
+++ b/liboctave/util/oct-inttypes.h
@@ -37,21 +37,21 @@ along with Octave; see the file COPYING.
 inline long double xround (long double x) { return roundl (x); }
 inline long double xisnan (long double x)
 { return xisnan (static_cast<double> (x)); }
 #endif
 
 // FIXME: we define this by our own because some compilers, such as
 // MSVC, do not provide std::abs (int64_t) and std::abs (uint64_t).  In
 // the future, it should go away in favor of std::abs.
-template <class T>
+template <typename T>
 inline T octave_int_abs (T x) { return x >= 0 ? x : -x; }
 
 // Query for an integer type of certain sizeof, and signedness.
-template<int qsize, bool qsigned>
+template <int qsize, bool qsigned>
 struct query_integer_type
 {
 public:
   static const bool registered = false;
   typedef void type; // Void shall result in a compile-time error if we
                      // attempt to use it in computations.
 };
 
@@ -78,41 +78,41 @@ REGISTER_INT_TYPE (uint64_t);
 // result of the binary relation. They also have two static boolean fields:
 // ltval, gtval determine the value of x OP y if x < y, x > y, respectively.
 #define REGISTER_OCTAVE_CMP_OP(NM,OP) \
   class NM \
     { \
     public: \
       static const bool ltval = (0 OP 1); \
       static const bool gtval = (1 OP 0); \
-      template <class T> \
+      template <typename T> \
       static bool op (T x, T y) { return x OP y; } \
     }
 
 // We also provide two special relations: ct, yielding always true, and cf,
 // yielding always false.
 #define REGISTER_OCTAVE_CONST_OP(NM,value) \
   class NM \
     { \
     public: \
       static const bool ltval = value; \
       static const bool gtval = value; \
-      template <class T> \
+      template <typename T> \
       static bool op (T, T) { return value; } \
     }
 
 // Handles non-homogeneous integer comparisons. Avoids doing useless tests.
 class octave_int_cmp_op
 {
   // This determines a suitable promotion type for T1 when meeting T2 in a
   // binary relation. If promotion to int or T2 is safe, it is used. Otherwise,
   // the signedness of T1 is preserved and it is widened if T2 is wider.
   // Notice that if this is applied to both types, they must end up with equal
   // size.
-  template <class T1, class T2>
+  template <typename T1, typename T2>
   class prom
   {
     // Promote to int?
     static const bool pint = (sizeof (T1) < sizeof (int)
                               && sizeof (T2) < sizeof (int));
     static const bool t1sig = std::numeric_limits<T1>::is_signed;
     static const bool t2sig = std::numeric_limits<T2>::is_signed;
     static const bool psig =
@@ -121,17 +121,17 @@ class octave_int_cmp_op
       (pint ? sizeof (int) : (sizeof (T2) > sizeof (T1)
                               ? sizeof (T2) : sizeof (T1)));
   public:
     typedef typename query_integer_type<psize, psig>::type type;
   };
 
   // Implements comparisons between two types of equal size but
   // possibly different signedness.
-  template<class xop, int size>
+  template <typename xop, int size>
   class uiop
   {
     typedef typename query_integer_type<size, false>::type utype;
     typedef typename query_integer_type<size, true>::type stype;
   public:
     static bool op (utype x, utype y)
     { return xop::op (x, y); }
     static bool op (stype x, stype y)
@@ -148,127 +148,127 @@ public:
   REGISTER_OCTAVE_CMP_OP (gt, >);
   REGISTER_OCTAVE_CMP_OP (ge, >=);
   REGISTER_OCTAVE_CMP_OP (eq, ==);
   REGISTER_OCTAVE_CMP_OP (ne, !=);
   REGISTER_OCTAVE_CONST_OP (ct, true);
   REGISTER_OCTAVE_CONST_OP (cf, false);
 
   // Universal comparison operation.
-  template<class xop, class T1, class T2>
+  template <typename xop, typename T1, typename T2>
   static bool
   op (T1 x, T2 y)
   {
     typedef typename prom<T1, T2>::type PT1;
     typedef typename prom<T2, T1>::type PT2;
     return uiop<xop, sizeof (PT1)>::op (static_cast<PT1> (x),
                                         static_cast<PT2> (y));
   }
 
 public:
 
   // Mixed comparisons
-  template <class xop, class T>
+  template <typename xop, typename T>
   static bool
   mop (T x, double y)
   { return xop::op (static_cast<double> (x), y); }
 
-  template <class xop, class T>
+  template <typename xop, typename T>
   static bool
   mop (double x, T y)
   { return xop::op (x, static_cast<double> (y)); }
 
 #ifdef OCTAVE_ENSURE_LONG_DOUBLE_OPERATIONS_ARE_NOT_TRUNCATED
 #define DECLARE_EXTERNAL_LONG_DOUBLE_CMP_OPS(T) \
-  template <class xop> static OCTAVE_API bool \
+  template <typename xop> static OCTAVE_API bool \
   external_mop (double, T); \
-  template <class xop> static OCTAVE_API bool \
+  template <typename xop> static OCTAVE_API bool \
   external_mop (T, double)
 
   DECLARE_EXTERNAL_LONG_DOUBLE_CMP_OPS (int64_t);
   DECLARE_EXTERNAL_LONG_DOUBLE_CMP_OPS (uint64_t);
 #endif
 
   // Typecasting to doubles won't work properly for 64-bit integers --
   // they lose precision.
   // If we have long doubles, use them...
 #ifdef OCTAVE_INT_USE_LONG_DOUBLE
 #ifdef OCTAVE_ENSURE_LONG_DOUBLE_OPERATIONS_ARE_NOT_TRUNCATED
 #define DEFINE_LONG_DOUBLE_CMP_OP(T) \
-  template <class xop> \
+  template <typename xop> \
   static bool \
   mop (double x, T y) \
   { \
     return external_mop<xop> (x, y); \
   } \
-  template <class xop> \
+  template <typename xop> \
   static bool \
   mop (T x, double y) \
   { \
     return external_mop<xop> (x, y); \
   }
 #else
 #define DEFINE_LONG_DOUBLE_CMP_OP(T) \
-  template <class xop> \
+  template <typename xop> \
   static bool \
   mop (double x, T y) \
   { \
     return xop::op (static_cast<long double> (x), \
                     static_cast<long double> (y)); \
   } \
-  template <class xop> \
+  template <typename xop> \
   static bool \
   mop (T x, double y) \
   { \
     return xop::op (static_cast<long double> (x), \
                     static_cast<long double> (y)); \
   }
 #endif
 #else
   // ... otherwise, use external handlers
 
   // FIXME: We could declare directly the mop methods as external,
   // but we can't do this because bugs in gcc (<= 4.3) prevent
   // explicit instantiations later in that case.
 #define DEFINE_LONG_DOUBLE_CMP_OP(T) \
-  template <class xop> static OCTAVE_API bool \
+  template <typename xop> static OCTAVE_API bool \
   emulate_mop (double, T); \
-  template <class xop> \
+  template <typename xop> \
   static bool \
   mop (double x, T y) \
     { \
       return emulate_mop<xop> (x, y); \
     } \
-  template <class xop> static OCTAVE_API bool \
+  template <typename xop> static OCTAVE_API bool \
   emulate_mop (T, double); \
-  template <class xop> \
+  template <typename xop> \
   static bool \
   mop (T x, double y) \
     { \
       return emulate_mop<xop> (x, y); \
     }
 #endif
 
   DEFINE_LONG_DOUBLE_CMP_OP(int64_t)
   DEFINE_LONG_DOUBLE_CMP_OP(uint64_t)
 
 #undef DEFINE_LONG_DOUBLE_CMP_OP
 };
 
 // Base integer class. No data, just conversion methods and exception flags.
-template <class T>
+template <typename T>
 class octave_int_base
 {
 public:
 
   static T min_val () { return std::numeric_limits<T>:: min (); }
   static T max_val () { return std::numeric_limits<T>:: max (); }
 
   // Convert integer value.
-  template <class S>
+  template <typename S>
   static T
   truncate_int (const S& value)
   {
     // An exhaustive test whether the max and/or min check can be omitted.
     static const bool t_is_signed = std::numeric_limits<T>::is_signed;
     static const bool s_is_signed = std::numeric_limits<S>::is_signed;
     static const int t_size = sizeof (T);
     static const int s_size = sizeof (S);
@@ -297,31 +297,31 @@ public:
       }
     else
       return static_cast<T> (value);
   }
 
 private:
 
   // Computes a real-valued threshold for a max/min check.
-  template <class S>
+  template <typename S>
   static S
   compute_threshold (S val, T orig_val)
   {
     val = xround (val); // Fool optimizations (maybe redundant)
     // If val is even, but orig_val is odd, we're one unit off.
     if (orig_val % 2 && val / 2 == xround (val / 2))
       // FIXME: is this always correct?
       val *= (static_cast<S> (1) - (std::numeric_limits<S>::epsilon () / 2));
     return val;
   }
 
 public:
   // Convert a real number (check NaN and non-int).
-  template <class S>
+  template <typename S>
   static T
   convert_real (const S& value)
   {
     // Compute proper thresholds.
     static const S thmin = compute_threshold (static_cast<S> (min_val ()),
                            min_val ());
     static const S thmax = compute_threshold (static_cast<S> (max_val ()),
                            max_val ());
@@ -345,23 +345,23 @@ public:
   }
 };
 
 // Saturated (homogeneous) integer arithmetics. The signed and unsigned
 // implementations are significantly different, so we implement another layer
 // and completely specialize. Arithmetics inherits from octave_int_base so that
 // it can use its exceptions and truncation functions.
 
-template <class T, bool is_signed>
+template <typename T, bool is_signed>
 class octave_int_arith_base
 { };
 
 // Unsigned arithmetics. C++ standard requires it to be modular, so the
 // overflows can be handled efficiently and reliably.
-template <class T>
+template <typename T>
 class octave_int_arith_base<T, false> : octave_int_base<T>
 {
 public:
 
   static T
   abs (T x) { return x; }
 
   static T
@@ -512,17 +512,17 @@ octave_int_arith_base<uint64_t, false>::
 //
 // The above conditions are satisfied by most modern platforms. If
 // HAVE_FAST_INT_OPS is defined, bit tricks and wraparound arithmetics are used
 // to avoid conditional jumps as much as possible, thus being friendly to
 // modern pipeline processor architectures.
 // Otherwise, we fall back to a bullet-proof code that only uses assumptions
 // guaranteed by the standard.
 
-template <class T>
+template <typename T>
 class octave_int_arith_base<T, true> : octave_int_base<T>
 {
   // The corresponding unsigned type.
   typedef typename query_integer_type<sizeof (T), false>::type UT;
 public:
 
   // Returns 1 for negative number, 0 otherwise.
   static T
@@ -816,22 +816,22 @@ octave_int_arith_base<int64_t, true>::mu
 // Special handler for 64-bit integer multiply.
 template <>
 OCTAVE_API int64_t
 octave_int_arith_base<int64_t, true>::mul_internal (int64_t, int64_t);
 
 #endif
 
 // This class simply selects the proper arithmetics.
-template<class T>
+template <typename T>
 class octave_int_arith
  : public octave_int_arith_base<T, std::numeric_limits<T>::is_signed>
 { };
 
-template <class T>
+template <typename T>
 class
 octave_int : public octave_int_base<T>
 {
 public:
   typedef T val_type;
 
   octave_int (void) : ival () { }
 
@@ -847,20 +847,20 @@ public:
   octave_int (float d) : ival (octave_int_base<T>::convert_real (d)) { }
 
 #ifdef OCTAVE_INT_USE_LONG_DOUBLE
   octave_int (long double d) : ival (octave_int_base<T>::convert_real (d)) { }
 #endif
 
   octave_int (bool b) : ival (b) { }
 
-  template <class U>
+  template <typename U>
   octave_int (const U& i) : ival(octave_int_base<T>::truncate_int (i)) { }
 
-  template <class U>
+  template <typename U>
   octave_int (const octave_int<U>& i)
     : ival (octave_int_base<T>::truncate_int (i.value ())) { }
 
   octave_int (const octave_int<T>& i) : ival (i.ival) { }
 
   octave_int& operator = (const octave_int<T>& i)
   {
     ival = i.ival;
@@ -944,93 +944,93 @@ public:
   // You should not use it anywhere else.
   void *mex_get_data (void) const { return const_cast<T *> (&ival); }
 
 private:
 
   T ival;
 };
 
-template <class T>
+template <typename T>
 inline octave_int<T>
 rem (const octave_int<T>& x, const octave_int<T>& y)
 { return octave_int_arith<T>::rem (x.value (), y.value ()); }
 
-template <class T>
+template <typename T>
 inline octave_int<T>
 mod (const octave_int<T>& x, const octave_int<T>& y)
 { return octave_int_arith<T>::mod (x.value (), y.value ()); }
 
 // No mixed integer binary operations!
 
-template <class T>
+template <typename T>
 inline bool
 xisnan (const octave_int<T>&)
 { return false; }
 
 // FIXME: can/should any of these be inline?
 
-template <class T>
+template <typename T>
 extern OCTAVE_API octave_int<T>
 pow (const octave_int<T>&, const octave_int<T>&);
 
-template <class T>
+template <typename T>
 extern OCTAVE_API octave_int<T>
 pow (const double& a, const octave_int<T>& b);
 
-template <class T>
+template <typename T>
 extern OCTAVE_API octave_int<T>
 pow (const octave_int<T>& a, const double& b);
 
-template <class T>
+template <typename T>
 extern OCTAVE_API octave_int<T>
 pow (const float& a, const octave_int<T>& b);
 
-template <class T>
+template <typename T>
 extern OCTAVE_API octave_int<T>
 pow (const octave_int<T>& a, const float& b);
 
 // FIXME: Do we really need a differently named single-precision
 //        function integer power function here instead of an overloaded
 //        one?
-template <class T>
+template <typename T>
 extern OCTAVE_API octave_int<T>
 powf (const float& a, const octave_int<T>& b);
 
-template <class T>
+template <typename T>
 extern OCTAVE_API octave_int<T>
 powf (const octave_int<T>& a, const float& b);
 
 // Binary relations
 
 #define OCTAVE_INT_CMP_OP(OP, NAME) \
-  template<class T1, class T2> \
+  template <typename T1, typename T2> \
   inline bool \
   operator OP (const octave_int<T1>& x, const octave_int<T2>& y) \
   { return octave_int_cmp_op::op<octave_int_cmp_op::NAME, T1, T2> \
     (x.value (), y.value ()); }
 
 OCTAVE_INT_CMP_OP (<, lt)
 OCTAVE_INT_CMP_OP (<=, le)
 OCTAVE_INT_CMP_OP (>, gt)
 OCTAVE_INT_CMP_OP (>=, ge)
 OCTAVE_INT_CMP_OP (==, eq)
 OCTAVE_INT_CMP_OP (!=, ne)
 
 #undef OCTAVE_INT_CMP_OP
 
-template <class T>
+template <typename T>
 inline std::ostream&
 operator << (std::ostream& os, const octave_int<T>& ival)
 {
   os << ival.value ();
   return os;
 }
 
-template <class T>
+template <typename T>
 inline std::istream&
 operator >> (std::istream& is, octave_int<T>& ival)
 {
   T tmp = 0;
   is >> tmp;
   ival = tmp;
   return is;
 }
@@ -1077,29 +1077,29 @@ operator >> (std::istream& is, octave_in
   ival = static_cast<uint8_t> (tmp);
   return is;
 }
 
 
 // Bitwise operations
 
 #define OCTAVE_INT_BITCMP_OP(OP) \
-  template <class T> \
+  template <typename T> \
   octave_int<T> \
   operator OP (const octave_int<T>& x, const octave_int<T>& y) \
   { return x.value () OP y.value (); }
 
 OCTAVE_INT_BITCMP_OP (&)
 OCTAVE_INT_BITCMP_OP (|)
 OCTAVE_INT_BITCMP_OP (^)
 
 #undef OCTAVE_INT_BITCMP_OP
 
 // General bit shift.
-template <class T>
+template <typename T>
 octave_int<T>
 bitshift (const octave_int<T>& a, int n,
           const octave_int<T>& mask = std::numeric_limits<T>::max ())
 {
   if (n > 0)
     return (a << n) & mask;
   else if (n < 0)
     return (a >> -n) & mask;
@@ -1132,21 +1132,21 @@ typedef octave_int<uint64_t> octave_uint
   DECLARE_EXTERNAL_LONG_DOUBLE_OP (T, div)
 
 DECLARE_EXTERNAL_LONG_DOUBLE_OPS (octave_int64);
 DECLARE_EXTERNAL_LONG_DOUBLE_OPS (octave_uint64);
 
 #endif
 
 #define OCTAVE_INT_DOUBLE_BIN_OP0(OP) \
-  template <class T> \
+  template <typename T> \
   inline octave_int<T> \
   operator OP (const octave_int<T>& x, const double& y) \
   { return octave_int<T> (static_cast<double> (x) OP y); } \
-  template <class T> \
+  template <typename T> \
   inline octave_int<T> \
   operator OP (const double& x, const octave_int<T>& y) \
   { return octave_int<T> (x OP static_cast<double> (y)); }
 
 #ifdef OCTAVE_INT_USE_LONG_DOUBLE
 // Handle mixed op using long double
 #ifdef OCTAVE_ENSURE_LONG_DOUBLE_OPERATIONS_ARE_NOT_TRUNCATED
 #define OCTAVE_INT_DOUBLE_BIN_OP(OP, NAME) \
@@ -1228,82 +1228,82 @@ OCTAVE_INT_DOUBLE_BIN_OP (*, mul)
 OCTAVE_INT_DOUBLE_BIN_OP (/, div)
 
 #undef OCTAVE_INT_DOUBLE_BIN_OP0
 #undef OCTAVE_INT_DOUBLE_BIN_OP
 #undef DECLARE_EXTERNAL_LONG_DOUBLE_OP
 #undef DECLARE_EXTERNAL_LONG_DOUBLE_OPS
 
 #define OCTAVE_INT_DOUBLE_CMP_OP(OP,NAME) \
-  template <class T> \
+  template <typename T> \
   inline bool \
   operator OP (const octave_int<T>& x, const double& y) \
   { return octave_int_cmp_op::mop<octave_int_cmp_op::NAME> (x.value (), y); } \
-  template <class T> \
+  template <typename T> \
   inline bool \
   operator OP (const double& x, const octave_int<T>& y) \
   { return octave_int_cmp_op::mop<octave_int_cmp_op::NAME> (x, y.value ()); }
 
 OCTAVE_INT_DOUBLE_CMP_OP (<, lt)
 OCTAVE_INT_DOUBLE_CMP_OP (<=, le)
 OCTAVE_INT_DOUBLE_CMP_OP (>=, ge)
 OCTAVE_INT_DOUBLE_CMP_OP (>, gt)
 OCTAVE_INT_DOUBLE_CMP_OP (==, eq)
 OCTAVE_INT_DOUBLE_CMP_OP (!=, ne)
 
 #undef OCTAVE_INT_DOUBLE_CMP_OP
 
 // Floats are handled by simply converting to doubles.
 
 #define OCTAVE_INT_FLOAT_BIN_OP(OP) \
-  template <class T> \
+  template <typename T> \
   inline octave_int<T> \
   operator OP (const octave_int<T>& x, float y) \
   { return x OP static_cast<double> (y); } \
-  template <class T> \
+  template <typename T> \
   inline octave_int<T> \
   operator OP (float x, const octave_int<T>& y) \
   { return static_cast<double> (x) OP y; }
 
 OCTAVE_INT_FLOAT_BIN_OP (+)
 OCTAVE_INT_FLOAT_BIN_OP (-)
 OCTAVE_INT_FLOAT_BIN_OP (*)
 OCTAVE_INT_FLOAT_BIN_OP (/)
 
 #undef OCTAVE_INT_FLOAT_BIN_OP
 
 #define OCTAVE_INT_FLOAT_CMP_OP(OP) \
-  template <class T> \
+  template <typename T> \
   inline bool \
   operator OP (const octave_int<T>& x, const float& y) \
   { return x OP static_cast<double> (y); } \
-  template <class T> \
+  template <typename T> \
   bool \
   operator OP (const float& x, const octave_int<T>& y) \
   { return static_cast<double> (x) OP y; }
 
 OCTAVE_INT_FLOAT_CMP_OP (<)
 OCTAVE_INT_FLOAT_CMP_OP (<=)
 OCTAVE_INT_FLOAT_CMP_OP (>=)
 OCTAVE_INT_FLOAT_CMP_OP (>)
 OCTAVE_INT_FLOAT_CMP_OP (==)
 OCTAVE_INT_FLOAT_CMP_OP (!=)
 
 #undef OCTAVE_INT_FLOAT_CMP_OP
 
-template <class T>
+template <typename T>
 octave_int<T>
 xmax (const octave_int<T>& x, const octave_int<T>& y)
 {
   const T xv = x.value ();
   const T yv = y.value ();
   return octave_int<T> (xv >= yv ? xv : yv);
 }
 
-template <class T>
+template <typename T>
 octave_int<T>
 xmin (const octave_int<T>& x, const octave_int<T>& y)
 {
   const T xv = x.value ();
   const T yv = y.value ();
   return octave_int<T> (xv <= yv ? xv : yv);
 }
 
diff --git a/liboctave/util/oct-locbuf.h b/liboctave/util/oct-locbuf.h
--- a/liboctave/util/oct-locbuf.h
+++ b/liboctave/util/oct-locbuf.h
@@ -25,17 +25,17 @@ along with Octave; see the file COPYING.
 
 #include <cstddef>
 #include "oct-cmplx.h"
 
 // The default local buffer simply encapsulates an *array* pointer
 // that gets deleted automatically.  For common POD types, we provide
 // specializations.
 
-template <class T>
+template <typename T>
 class octave_local_buffer
 {
 public:
   octave_local_buffer (size_t size)
     : data (0)
   {
     if (size)
       data = new T [size];
@@ -132,28 +132,28 @@ SPECIALIZE_POD_BUFFER (unsigned long);
 SPECIALIZE_POD_BUFFER (float);
 SPECIALIZE_POD_BUFFER (double);
 // FIXME: Are these guaranteed to be POD and satisfy alignment?
 SPECIALIZE_POD_BUFFER (Complex);
 SPECIALIZE_POD_BUFFER (FloatComplex);
 // MORE ?
 
 // All pointers and const pointers are also POD types.
-template <class T>
+template <typename T>
 class octave_local_buffer<T *> : private octave_chunk_buffer
 {
 public:
   octave_local_buffer (size_t size)
     : octave_chunk_buffer (size * sizeof (T *))
   { }
 
   operator T **() const { return reinterpret_cast<T **> (this->data ()); }
 };
 
-template <class T>
+template <typename T>
 class octave_local_buffer<const T *> : private octave_chunk_buffer
 {
 public:
   octave_local_buffer (size_t size)
     : octave_chunk_buffer (size * sizeof (const T *))
   { }
 
   operator const T **() const
diff --git a/liboctave/util/oct-refcount.h b/liboctave/util/oct-refcount.h
--- a/liboctave/util/oct-refcount.h
+++ b/liboctave/util/oct-refcount.h
@@ -44,17 +44,17 @@ along with Octave; see the file COPYING.
 // Generic non-locking versions
 # define OCTREFCOUNT_ATOMIC_INCREMENT(x) ++(*(x))
 # define OCTREFCOUNT_ATOMIC_DECREMENT(x) --(*(x))
 # define OCTREFCOUNT_ATOMIC_INCREMENT_POST(x) (*(x))++
 # define OCTREFCOUNT_ATOMIC_DECREMENT_POST(x) (*(x))--
 #endif
 
 // Encapsulates a reference counter.
-template <class T>
+template <typename T>
 class octave_refcount
 {
 public:
   typedef T count_type;
 
   octave_refcount(count_type initial_count) : count(initial_count) { }
 
   // Increment/Decrement. int is postfix.
diff --git a/liboctave/util/oct-sort.cc b/liboctave/util/oct-sort.cc
--- a/liboctave/util/oct-sort.cc
+++ b/liboctave/util/oct-sort.cc
@@ -111,48 +111,48 @@ The Python license is
 #include <cstring>
 #include <stack>
 
 #include "lo-mappers.h"
 #include "quit.h"
 #include "oct-sort.h"
 #include "oct-locbuf.h"
 
-template <class T>
+template <typename T>
 octave_sort<T>::octave_sort (void) :
   compare (ascending_compare), ms (0)
 {
 }
 
-template <class T>
+template <typename T>
 octave_sort<T>::octave_sort (compare_fcn_type comp)
   : compare (comp), ms (0)
 {
 }
 
-template <class T>
+template <typename T>
 octave_sort<T>::~octave_sort ()
 {
   delete ms;
 }
 
-template <class T>
+template <typename T>
 void
 octave_sort<T>::set_compare (sortmode mode)
 {
   if (mode == ASCENDING)
     compare = ascending_compare;
   else if (mode == DESCENDING)
     compare = descending_compare;
   else
     compare = 0;
 }
 
-template <class T>
-template <class Comp>
+template <typename T>
+template <typename Comp>
 void
 octave_sort<T>::binarysort (T *data, octave_idx_type nel,
                             octave_idx_type start, Comp comp)
 {
   if (start == 0)
     ++start;
 
   for (; start < nel; ++start)
@@ -186,18 +186,18 @@ octave_sort<T>::binarysort (T *data, oct
       for (octave_idx_type p = l; p < start; p++)
         std::swap (pivot, data[p]);
       data[start] = pivot;
     }
 
   return;
 }
 
-template <class T>
-template <class Comp>
+template <typename T>
+template <typename Comp>
 void
 octave_sort<T>::binarysort (T *data, octave_idx_type *idx, octave_idx_type nel,
                             octave_idx_type start, Comp comp)
 {
   if (start == 0)
     ++start;
 
   for (; start < nel; ++start)
@@ -253,18 +253,18 @@ or the longest descending sequence, with
 DESCENDING is set to false in the former case, or to true in the latter.
 For its intended use in a stable mergesort, the strictness of the defn of
 "descending" is needed so that the caller can safely reverse a descending
 sequence without violating stability (strict > ensures there are no equal
 elements to get out of order).
 
 Returns -1 in case of error.
 */
-template <class T>
-template <class Comp>
+template <typename T>
+template <typename Comp>
 octave_idx_type
 octave_sort<T>::count_run (T *lo, octave_idx_type nel, bool& descending,
                            Comp comp)
 {
   octave_idx_type n;
   T *hi = lo + nel;
 
   descending = false;
@@ -313,18 +313,18 @@ The return value is the int k in 0..n su
     a[k-1] < key <= a[k]
 
 pretending that *(a-1) is minus infinity and a[n] is plus infinity.  IOW,
 key belongs at index k; or, IOW, the first k elements of a should precede
 key, and the last n-k should follow key.
 
 Returns -1 on error.  See listsort.txt for info on the method.
 */
-template <class T>
-template <class Comp>
+template <typename T>
+template <typename Comp>
 octave_idx_type
 octave_sort<T>::gallop_left (T key, T *a, octave_idx_type n,
                              octave_idx_type hint,
                              Comp comp)
 {
   octave_idx_type ofs;
   octave_idx_type lastofs;
   octave_idx_type k;
@@ -408,18 +408,18 @@ The return value is the int k in 0..n su
     a[k-1] <= key < a[k]
 
 or -1 if error.
 
 The code duplication is massive, but this is enough different given that
 we're sticking to "<" comparisons that it's much harder to follow if
 written as one routine with yet another "left or right?" flag.
 */
-template <class T>
-template <class Comp>
+template <typename T>
+template <typename Comp>
 octave_idx_type
 octave_sort<T>::gallop_right (T key, T *a, octave_idx_type n,
                               octave_idx_type hint,
                               Comp comp)
 {
   octave_idx_type ofs;
   octave_idx_type lastofs;
   octave_idx_type k;
@@ -529,17 +529,17 @@ roundupsize (octave_idx_type n)
     }
 
   return ((n >> nbits) + 1) << nbits;
 }
 
 /* Ensure enough temp memory for 'need' array slots is available.
  * Returns 0 on success and -1 if the memory can't be gotten.
  */
-template <class T>
+template <typename T>
 void
 octave_sort<T>::MergeState::getmem (octave_idx_type need)
 {
   if (need <= alloced)
     return;
 
   need = roundupsize (need);
   /* Don't realloc!  That can cost cycles to copy the old data, but
@@ -547,17 +547,17 @@ octave_sort<T>::MergeState::getmem (octa
    */
   delete [] a;
   delete [] ia; // Must do this or fool possible next getmemi.
   a = new T [need];
   alloced = need;
 
 }
 
-template <class T>
+template <typename T>
 void
 octave_sort<T>::MergeState::getmemi (octave_idx_type need)
 {
   if (ia && need <= alloced)
     return;
 
   need = roundupsize (need);
   /* Don't realloc!  That can cost cycles to copy the old data, but
@@ -572,18 +572,18 @@ octave_sort<T>::MergeState::getmemi (oct
 }
 
 /* Merge the na elements starting at pa with the nb elements starting at pb
  * in a stable way, in-place.  na and nb must be > 0, and pa + na == pb.
  * Must also have that *pb < *pa, that pa[na-1] belongs at the end of the
  * merge, and should have na <= nb.  See listsort.txt for more info.
  * Return 0 if successful, -1 if error.
  */
-template <class T>
-template <class Comp>
+template <typename T>
+template <typename Comp>
 int
 octave_sort<T>::merge_lo (T *pa, octave_idx_type na,
                           T *pb, octave_idx_type nb,
                           Comp comp)
 {
   octave_idx_type k;
   T *dest;
   int result = -1;      /* guilty until proved innocent */
@@ -707,18 +707,18 @@ Fail:
 CopyB:
   /* The last element of pa belongs at the end of the merge. */
   std::copy (pb, pb + nb, dest);
   dest[nb] = *pa;
 
   return 0;
 }
 
-template <class T>
-template <class Comp>
+template <typename T>
+template <typename Comp>
 int
 octave_sort<T>::merge_lo (T *pa, octave_idx_type *ipa, octave_idx_type na,
                           T *pb, octave_idx_type *ipb, octave_idx_type nb,
                           Comp comp)
 {
   octave_idx_type k;
   T *dest;
   octave_idx_type *idest;
@@ -854,18 +854,18 @@ CopyB:
 }
 
 /* Merge the na elements starting at pa with the nb elements starting at pb
  * in a stable way, in-place.  na and nb must be > 0, and pa + na == pb.
  * Must also have that *pb < *pa, that pa[na-1] belongs at the end of the
  * merge, and should have na >= nb.  See listsort.txt for more info.
  * Return 0 if successful, -1 if error.
  */
-template <class T>
-template <class Comp>
+template <typename T>
+template <typename Comp>
 int
 octave_sort<T>::merge_hi (T *pa, octave_idx_type na,
                           T *pb, octave_idx_type nb,
                           Comp comp)
 {
   octave_idx_type k;
   T *dest;
   int result = -1;      /* guilty until proved innocent */
@@ -991,18 +991,18 @@ CopyA:
   /* The first element of pb belongs at the front of the merge. */
   dest = std::copy_backward (pa+1 - na, pa+1, dest+1) - 1;
   pa -= na;
   *dest = *pb;
 
   return 0;
 }
 
-template <class T>
-template <class Comp>
+template <typename T>
+template <typename Comp>
 int
 octave_sort<T>::merge_hi (T *pa, octave_idx_type *ipa, octave_idx_type na,
                           T *pb, octave_idx_type *ipb, octave_idx_type nb,
                           Comp comp)
 {
   octave_idx_type k;
   T *dest;
   octave_idx_type *idest;
@@ -1141,18 +1141,18 @@ CopyA:
   *dest = *pb; *idest = *ipb;
 
   return 0;
 }
 
 /* Merge the two runs at stack indices i and i+1.
  * Returns 0 on success, -1 on error.
  */
-template <class T>
-template <class Comp>
+template <typename T>
+template <typename Comp>
 int
 octave_sort<T>::merge_at (octave_idx_type i, T *data,
                           Comp comp)
 {
   T *pa, *pb;
   octave_idx_type na, nb;
   octave_idx_type k;
 
@@ -1192,18 +1192,18 @@ octave_sort<T>::merge_at (octave_idx_typ
    * min (na, nb) elements.
    */
   if (na <= nb)
     return merge_lo (pa, na, pb, nb, comp);
   else
     return merge_hi (pa, na, pb, nb, comp);
 }
 
-template <class T>
-template <class Comp>
+template <typename T>
+template <typename Comp>
 int
 octave_sort<T>::merge_at (octave_idx_type i, T *data, octave_idx_type *idx,
                           Comp comp)
 {
   T *pa, *pb;
   octave_idx_type *ipa, *ipb;
   octave_idx_type na, nb;
   octave_idx_type k;
@@ -1256,18 +1256,18 @@ octave_sort<T>::merge_at (octave_idx_typ
  *
  * 1. len[-3] > len[-2] + len[-1]
  * 2. len[-2] > len[-1]
  *
  * See listsort.txt for more info.
  *
  * Returns 0 on success, -1 on error.
  */
-template <class T>
-template <class Comp>
+template <typename T>
+template <typename Comp>
 int
 octave_sort<T>::merge_collapse (T *data, Comp comp)
 {
   struct s_slice *p = ms->pending;
 
   while (ms->n > 1)
     {
       octave_idx_type n = ms->n - 2;
@@ -1285,18 +1285,18 @@ octave_sort<T>::merge_collapse (T *data,
         }
       else
         break;
     }
 
   return 0;
 }
 
-template <class T>
-template <class Comp>
+template <typename T>
+template <typename Comp>
 int
 octave_sort<T>::merge_collapse (T *data, octave_idx_type *idx, Comp comp)
 {
   struct s_slice *p = ms->pending;
 
   while (ms->n > 1)
     {
       octave_idx_type n = ms->n - 2;
@@ -1319,18 +1319,18 @@ octave_sort<T>::merge_collapse (T *data,
   return 0;
 }
 
 /* Regardless of invariants, merge all runs on the stack until only one
  * remains.  This is used at the end of the mergesort.
  *
  * Returns 0 on success, -1 on error.
  */
-template <class T>
-template <class Comp>
+template <typename T>
+template <typename Comp>
 int
 octave_sort<T>::merge_force_collapse (T *data, Comp comp)
 {
   struct s_slice *p = ms->pending;
 
   while (ms->n > 1)
     {
       octave_idx_type n = ms->n - 2;
@@ -1338,18 +1338,18 @@ octave_sort<T>::merge_force_collapse (T 
         --n;
       if (merge_at (n, data, comp) < 0)
         return -1;
     }
 
   return 0;
 }
 
-template <class T>
-template <class Comp>
+template <typename T>
+template <typename Comp>
 int
 octave_sort<T>::merge_force_collapse (T *data, octave_idx_type *idx, Comp comp)
 {
   struct s_slice *p = ms->pending;
 
   while (ms->n > 1)
     {
       octave_idx_type n = ms->n - 2;
@@ -1367,33 +1367,33 @@ octave_sort<T>::merge_force_collapse (T 
  *
  * If n < 64, return n (it's too small to bother with fancy stuff).
  * Else if n is an exact power of 2, return 32.
  * Else return an int k, 32 <= k <= 64, such that n/k is close to, but
  * strictly less than, an exact power of 2.
  *
  * See listsort.txt for more info.
  */
-template <class T>
+template <typename T>
 octave_idx_type
 octave_sort<T>::merge_compute_minrun (octave_idx_type n)
 {
   octave_idx_type r = 0;        /* becomes 1 if any 1 bits are shifted off */
 
   while (n >= 64)
     {
       r |= n & 1;
       n >>= 1;
     }
 
   return n + r;
 }
 
-template <class T>
-template <class Comp>
+template <typename T>
+template <typename Comp>
 void
 octave_sort<T>::sort (T *data, octave_idx_type nel, Comp comp)
 {
   /* Re-initialize the Mergestate as this might be the second time called */
   if (! ms) ms = new MergeState;
 
   ms->reset ();
   ms->getmem (1024);
@@ -1441,18 +1441,18 @@ octave_sort<T>::sort (T *data, octave_id
 
       merge_force_collapse (data, comp);
     }
 
 fail:
   return;
 }
 
-template <class T>
-template <class Comp>
+template <typename T>
+template <typename Comp>
 void
 octave_sort<T>::sort (T *data, octave_idx_type *idx, octave_idx_type nel,
                       Comp comp)
 {
   /* Re-initialize the Mergestate as this might be the second time called */
   if (! ms) ms = new MergeState;
 
   ms->reset ();
@@ -1504,17 +1504,17 @@ octave_sort<T>::sort (T *data, octave_id
 
       merge_force_collapse (data, idx, comp);
     }
 
 fail:
   return;
 }
 
-template <class T>
+template <typename T>
 void
 octave_sort<T>::sort (T *data, octave_idx_type nel)
 {
 #ifdef INLINE_ASCENDING_SORT
   if (compare == ascending_compare)
     sort (data, nel, std::less<T> ());
   else
 #endif
@@ -1522,17 +1522,17 @@ octave_sort<T>::sort (T *data, octave_id
     if (compare == descending_compare)
       sort (data, nel, std::greater<T> ());
     else
 #endif
       if (compare)
         sort (data, nel, compare);
 }
 
-template <class T>
+template <typename T>
 void
 octave_sort<T>::sort (T *data, octave_idx_type *idx, octave_idx_type nel)
 {
 #ifdef INLINE_ASCENDING_SORT
   if (compare == ascending_compare)
     sort (data, idx, nel, std::less<T> ());
   else
 #endif
@@ -1540,17 +1540,18 @@ octave_sort<T>::sort (T *data, octave_id
     if (compare == descending_compare)
       sort (data, idx, nel, std::greater<T> ());
     else
 #endif
       if (compare)
         sort (data, idx, nel, compare);
 }
 
-template <class T> template <class Comp>
+template <typename T>
+template <typename Comp>
 bool
 octave_sort<T>::is_sorted (const T *data, octave_idx_type nel, Comp comp)
 {
   const T *end = data + nel;
   if (data != end)
     {
       const T *next = data;
       while (++next != end)
@@ -1560,17 +1561,17 @@ octave_sort<T>::is_sorted (const T *data
           data = next;
         }
       data = next;
     }
 
   return data == end;
 }
 
-template <class T>
+template <typename T>
 bool
 octave_sort<T>::is_sorted (const T *data, octave_idx_type nel)
 {
   bool retval = false;
 #ifdef INLINE_ASCENDING_SORT
   if (compare == ascending_compare)
     retval = is_sorted (data, nel, std::less<T> ());
   else
@@ -1590,17 +1591,18 @@ octave_sort<T>::is_sorted (const T *data
 struct sortrows_run_t
 {
   sortrows_run_t (octave_idx_type c, octave_idx_type o, octave_idx_type n)
     : col (c), ofs (o), nel (n) { }
   octave_idx_type col, ofs, nel;
 };
 
 
-template <class T> template <class Comp>
+template <typename T>
+template <typename Comp>
 void
 octave_sort<T>::sort_rows (const T *data, octave_idx_type *idx,
                            octave_idx_type rows, octave_idx_type cols,
                            Comp comp)
 {
   OCTAVE_LOCAL_BUFFER (T, buf, rows);
   for (octave_idx_type i = 0; i < rows; i++)
     idx[i] = i;
@@ -1648,17 +1650,17 @@ octave_sort<T>::sort_rows (const T *data
                 }
             }
           if (nel > lst + 1)
             runs.push (run_t (col+1, ofs + lst, nel - lst));
         }
     }
 }
 
-template <class T>
+template <typename T>
 void
 octave_sort<T>::sort_rows (const T *data, octave_idx_type *idx,
                            octave_idx_type rows, octave_idx_type cols)
 {
 #ifdef INLINE_ASCENDING_SORT
   if (compare == ascending_compare)
     sort_rows (data, idx, rows, cols, std::less<T> ());
   else
@@ -1667,17 +1669,18 @@ octave_sort<T>::sort_rows (const T *data
     if (compare == descending_compare)
       sort_rows (data, idx, rows, cols, std::greater<T> ());
     else
 #endif
       if (compare)
         sort_rows (data, idx, rows, cols, compare);
 }
 
-template <class T> template <class Comp>
+template <typename T>
+template <typename Comp>
 bool
 octave_sort<T>::is_sorted_rows (const T *data, octave_idx_type rows,
                                 octave_idx_type cols, Comp comp)
 {
   if (rows <= 1 || cols == 0)
     return true;
 
   // This is a breadth-first traversal.
@@ -1724,17 +1727,17 @@ octave_sort<T>::is_sorted_rows (const T 
       else
         // The final column - use fast code.
         sorted = is_sorted (lo, n, comp);
     }
 
   return sorted;
 }
 
-template <class T>
+template <typename T>
 bool
 octave_sort<T>::is_sorted_rows (const T *data, octave_idx_type rows,
                                 octave_idx_type cols)
 {
   bool retval = false;
 
 #ifdef INLINE_ASCENDING_SORT
   if (compare == ascending_compare)
@@ -1749,17 +1752,18 @@ octave_sort<T>::is_sorted_rows (const T 
       if (compare)
         retval = is_sorted_rows (data, rows, cols, compare);
 
   return retval;
 }
 
 // The simple binary lookup.
 
-template <class T> template <class Comp>
+template <typename T>
+template <typename Comp>
 octave_idx_type
 octave_sort<T>::lookup (const T *data, octave_idx_type nel,
                         const T& value, Comp comp)
 {
   octave_idx_type lo = 0;
   octave_idx_type hi = nel;
 
   while (lo < hi)
@@ -1769,17 +1773,17 @@ octave_sort<T>::lookup (const T *data, o
         hi = mid;
       else
         lo = mid + 1;
     }
 
   return lo;
 }
 
-template <class T>
+template <typename T>
 octave_idx_type
 octave_sort<T>::lookup (const T *data, octave_idx_type nel,
                         const T& value)
 {
   octave_idx_type retval = 0;
 
 #ifdef INLINE_ASCENDING_SORT
   if (compare == ascending_compare)
@@ -1792,30 +1796,31 @@ octave_sort<T>::lookup (const T *data, o
     else
 #endif
       if (compare)
         retval = lookup (data, nel, value, std::ptr_fun (compare));
 
   return retval;
 }
 
-template <class T> template <class Comp>
+template <typename T>
+template <typename Comp>
 void
 octave_sort<T>::lookup (const T *data, octave_idx_type nel,
                         const T *values, octave_idx_type nvalues,
                         octave_idx_type *idx, Comp comp)
 {
   // Use a sequence of binary lookups.
   // TODO: Can this be sped up generally? The sorted merge case is dealt with
   // elsewhere.
   for (octave_idx_type j = 0; j < nvalues; j++)
     idx[j] = lookup (data, nel, values[j], comp);
 }
 
-template <class T>
+template <typename T>
 void
 octave_sort<T>::lookup (const T *data, octave_idx_type nel,
                         const T* values, octave_idx_type nvalues,
                         octave_idx_type *idx)
 {
 #ifdef INLINE_ASCENDING_SORT
   if (compare == ascending_compare)
     lookup (data, nel, values, nvalues, idx, std::less<T> ());
@@ -1825,17 +1830,18 @@ octave_sort<T>::lookup (const T *data, o
     if (compare == descending_compare)
       lookup (data, nel, values, nvalues, idx, std::greater<T> ());
     else
 #endif
       if (compare)
         lookup (data, nel, values, nvalues, idx, std::ptr_fun (compare));
 }
 
-template <class T> template <class Comp>
+template <typename T>
+template <typename Comp>
 void
 octave_sort<T>::lookup_sorted (const T *data, octave_idx_type nel,
                                const T *values, octave_idx_type nvalues,
                                octave_idx_type *idx, bool rev, Comp comp)
 {
   if (rev)
     {
       octave_idx_type i = 0;
@@ -1879,17 +1885,17 @@ octave_sort<T>::lookup_sorted (const T *
             }
         }
 
       for (; j != nvalues; j++)
         idx[j] = i;
     }
 }
 
-template <class T>
+template <typename T>
 void
 octave_sort<T>::lookup_sorted (const T *data, octave_idx_type nel,
                                const T* values, octave_idx_type nvalues,
                                octave_idx_type *idx, bool rev)
 {
 #ifdef INLINE_ASCENDING_SORT
   if (compare == ascending_compare)
     lookup_sorted (data, nel, values, nvalues, idx, rev, std::less<T> ());
@@ -1900,17 +1906,18 @@ octave_sort<T>::lookup_sorted (const T *
       lookup_sorted (data, nel, values, nvalues, idx, rev, std::greater<T> ());
     else
 #endif
       if (compare)
         lookup_sorted (data, nel, values, nvalues, idx, rev,
                        std::ptr_fun (compare));
 }
 
-template <class T> template <class Comp>
+template <typename T>
+template <typename Comp>
 void
 octave_sort<T>::nth_element (T *data, octave_idx_type nel,
                              octave_idx_type lo, octave_idx_type up,
                              Comp comp)
 {
   // Simply wrap the STL algorithms.
   // FIXME: this will fail if we attempt to inline <,> for Complex.
   if (up == lo+1)
@@ -1926,17 +1933,17 @@ octave_sort<T>::nth_element (T *data, oc
           std::swap (data[lo+1],
                      *std::min_element (data + lo + 1, data + nel, comp));
         }
       else
         std::partial_sort (data + lo + 1, data + up, data + nel, comp);
     }
 }
 
-template <class T>
+template <typename T>
 void
 octave_sort<T>::nth_element (T *data, octave_idx_type nel,
                              octave_idx_type lo, octave_idx_type up)
 {
   if (up < 0)
     up = lo + 1;
 #ifdef INLINE_ASCENDING_SORT
   if (compare == ascending_compare)
@@ -1947,23 +1954,23 @@ octave_sort<T>::nth_element (T *data, oc
     if (compare == descending_compare)
       nth_element (data, nel, lo, up, std::greater<T> ());
     else
 #endif
       if (compare)
         nth_element (data, nel, lo, up, std::ptr_fun (compare));
 }
 
-template <class T>
+template <typename T>
 bool
 octave_sort<T>::ascending_compare (typename ref_param<T>::type x,
                                    typename ref_param<T>::type y)
 {
   return x < y;
 }
 
-template <class T>
+template <typename T>
 bool
 octave_sort<T>::descending_compare (typename ref_param<T>::type x,
                                     typename ref_param<T>::type y)
 {
   return x > y;
 }
diff --git a/liboctave/util/oct-sort.h b/liboctave/util/oct-sort.h
--- a/liboctave/util/oct-sort.h
+++ b/liboctave/util/oct-sort.h
@@ -97,17 +97,17 @@ The Python license is
 #define MIN_GALLOP 7
 
 // Avoid malloc for small temp arrays.
 #define MERGESTATE_TEMP_SIZE 1024
 
 // Enum for type of sort function
 enum sortmode { UNSORTED = 0, ASCENDING, DESCENDING };
 
-template <class T>
+template <typename T>
 class
 octave_sort
 {
 public:
 
   typedef bool (*compare_fcn_type) (typename ref_param<T>::type,
                                     typename ref_param<T>::type);
 
@@ -226,121 +226,121 @@ private:
     MergeState& operator = (const MergeState&);
   };
 
   compare_fcn_type compare;
 
   MergeState *ms;
 
 
-  template <class Comp>
+  template <typename Comp>
   void binarysort (T *data, octave_idx_type nel,
                    octave_idx_type start, Comp comp);
 
-  template <class Comp>
+  template <typename Comp>
   void binarysort (T *data, octave_idx_type *idx, octave_idx_type nel,
                    octave_idx_type start, Comp comp);
 
-  template <class Comp>
+  template <typename Comp>
   octave_idx_type count_run (T *lo, octave_idx_type n, bool& descending,
                              Comp comp);
 
-  template <class Comp>
+  template <typename Comp>
   octave_idx_type gallop_left (T key, T *a, octave_idx_type n,
                                octave_idx_type hint, Comp comp);
 
-  template <class Comp>
+  template <typename Comp>
   octave_idx_type gallop_right (T key, T *a, octave_idx_type n,
                                 octave_idx_type hint, Comp comp);
 
-  template <class Comp>
+  template <typename Comp>
   int merge_lo (T *pa, octave_idx_type na,
                 T *pb, octave_idx_type nb,
                 Comp comp);
 
-  template <class Comp>
+  template <typename Comp>
   int merge_lo (T *pa, octave_idx_type *ipa, octave_idx_type na,
                 T *pb, octave_idx_type *ipb, octave_idx_type nb,
                 Comp comp);
 
-  template <class Comp>
+  template <typename Comp>
   int merge_hi (T *pa, octave_idx_type na,
                 T *pb, octave_idx_type nb,
                 Comp comp);
 
-  template <class Comp>
+  template <typename Comp>
   int merge_hi (T *pa, octave_idx_type *ipa, octave_idx_type na,
                 T *pb, octave_idx_type *ipb, octave_idx_type nb,
                 Comp comp);
 
-  template <class Comp>
+  template <typename Comp>
   int merge_at (octave_idx_type i, T *data, Comp comp);
 
-  template <class Comp>
+  template <typename Comp>
   int merge_at (octave_idx_type i, T *data, octave_idx_type *idx, Comp comp);
 
-  template <class Comp>
+  template <typename Comp>
   int merge_collapse (T *data, Comp comp);
 
-  template <class Comp>
+  template <typename Comp>
   int merge_collapse (T *data, octave_idx_type *idx, Comp comp);
 
-  template <class Comp>
+  template <typename Comp>
   int merge_force_collapse (T *data, Comp comp);
 
-  template <class Comp>
+  template <typename Comp>
   int merge_force_collapse (T *data, octave_idx_type *idx, Comp comp);
 
   octave_idx_type merge_compute_minrun (octave_idx_type n);
 
-  template <class Comp>
+  template <typename Comp>
   void sort (T *data, octave_idx_type nel, Comp comp);
 
-  template <class Comp>
+  template <typename Comp>
   void sort (T *data, octave_idx_type *idx, octave_idx_type nel, Comp comp);
 
-  template <class Comp>
+  template <typename Comp>
   bool is_sorted (const T *data, octave_idx_type nel, Comp comp);
 
-  template <class Comp>
+  template <typename Comp>
   void sort_rows (const T *data, octave_idx_type *idx,
                   octave_idx_type rows, octave_idx_type cols,
                   Comp comp);
 
-  template <class Comp>
+  template <typename Comp>
   bool is_sorted_rows (const T *data, octave_idx_type rows,
                        octave_idx_type cols, Comp comp);
 
-  template <class Comp>
+  template <typename Comp>
   octave_idx_type lookup (const T *data, octave_idx_type nel,
                           const T& value, Comp comp);
 
-  template <class Comp>
+  template <typename Comp>
   void lookup (const T *data, octave_idx_type nel,
                const T* values, octave_idx_type nvalues,
                octave_idx_type *idx, Comp comp);
 
-  template <class Comp>
+  template <typename Comp>
   void lookup_sorted (const T *data, octave_idx_type nel,
                       const T* values, octave_idx_type nvalues,
                       octave_idx_type *idx, bool rev, Comp comp);
 
-  template <class Comp>
+  template <typename Comp>
   void nth_element (T *data, octave_idx_type nel,
                     octave_idx_type lo, octave_idx_type up,
                     Comp comp);
 
   // No copying!
 
   octave_sort (const octave_sort&);
 
   octave_sort& operator = (const octave_sort&);
 };
 
-template <class T>
+template <typename T>
 class
 vec_index
 {
 public:
   T vec;
   octave_idx_type indx;
 };
 #endif
