# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1295562299 18000
#      Thu Jan 20 17:24:59 2011 -0500
# Node ID 12df7854fa7ccc7457baea63f7263b6e22bf77d5
# Parent  1473d0cf86d210e31834f6806e070f4d2a565453
strip trailing whitespace from source files

diff --git a/libcruft/ChangeLog b/libcruft/ChangeLog
--- a/libcruft/ChangeLog
+++ b/libcruft/ChangeLog
@@ -1,8 +1,13 @@
+2011-01-20  John W. Eaton  <jwe@octave.org>
+
+	* misc/cquit.c, misc/f77-fcn.h, misc/quit.cc: Strip trailing
+	whitespace.
+
 2011-01-14  John W. Eaton  <jwe@octave.org>
 
 	* Update copyright notices for 2011.
 
 2010-09-07  Jaroslav Hajek  <highegg@gmail.com>
 
 	* blas-xtra/cconv2.f, blas-xtra/csconv2.f, blas-xtra/dconv2.f,
 	blas-xtra/sconv2.f, blas-xtra/zconv2.f, blas-xtra/zdconv2.f:
diff --git a/libcruft/misc/cquit.c b/libcruft/misc/cquit.c
--- a/libcruft/misc/cquit.c
+++ b/libcruft/misc/cquit.c
@@ -93,55 +93,55 @@ w32_reset_context (LPVOID v)
   int ret;
 
   /* Mutex the setjmp/longjmp */
   EnterCriticalSection (&w32_thread_setjmp_mutex);
 
   DEBUGs ("enter w32_set_context");
   SuspendThread (w32_main_thread);
   DEBUGs ("main suspended");
-  if (! SetThreadContext (w32_main_thread, context)) 
+  if (! SetThreadContext (w32_main_thread, context))
     {
       fprintf (stderr, "%lx: context failed: ctrl-c won't work\n",
-               GetCurrentThreadId ()); 
+               GetCurrentThreadId ());
       fflush (stderr);
     }
   DEBUGs ("context captured (or not)");
   ret = ResumeThread (w32_main_thread);
   DEBUGd ("main resumed with %d", ret);
 
   LeaveCriticalSection (&w32_thread_setjmp_mutex);
   return 0;
 }
 
-static void 
+static void
 w32_raise_in_main (void)
 {
   DWORD threadid;
 
   DEBUGd ("w32_raise_in_main with signal %d", w32_signal_to_raise);
   raise (w32_signal_to_raise);
   DEBUGd ("w32_raise_in_main signal %d returned a value",
           w32_signal_to_raise);
 
   DEBUGs ("attempting to restore main to pre-signal configuration");
   if (w32_restore_thread != NULL) /* Catch leaky threads */
     CloseHandle (w32_restore_thread);
   w32_restore_thread = CreateThread (NULL, 10000, w32_reset_context,
                                      &w32_signal_context, 0, &threadid);
-  if (w32_restore_thread == NULL) 
+  if (w32_restore_thread == NULL)
     {
-      fprintf (stderr, "w32_raise_in_main couldn't create thread\n"); 
+      fprintf (stderr, "w32_raise_in_main couldn't create thread\n");
       fflush (stderr);
-    } 
-  else 
+    }
+  else
     {
       DEBUGs ("waiting to restore raise context");
       WaitForSingleObject (w32_restore_thread, INFINITE);
-      fprintf (stderr, "w32_raise_in_main couldn't restore context\n"); 
+      fprintf (stderr, "w32_raise_in_main couldn't restore context\n");
       fflush (stderr);
     }
 }
 
 void
 w32_raise_final (void)
 {
   CloseHandle (w32_main_thread);
@@ -152,34 +152,34 @@ w32_raise_final (void)
 
 /* Raise the given signal in the main thread.  w32_raise_init ()
    must have been called from the main thread already.  */
 void
 w32_raise (int sig)
 {
   int ret;
 
-  if (w32_in_main_thread ()) 
+  if (w32_in_main_thread ())
     {
       /* Called from main thread -- a simple raise () should work.  */
       DEBUGd ("raising signal %d within main", signal);
       raise (sig);
       DEBUGd ("returning from signal %d within main", signal);
-    } 
-  else 
+    }
+  else
     {
       /* Called from alternate thread -- call w32_raise_in_main in the
          main thread with w32_signal_to_raise set to the signal */
       CONTEXT raise_context;
       DEBUGd ("raising signal %d from separate thread", signal);
 
       /* Suspend main and remember the context.  */
       SuspendThread (w32_main_thread);
       /* X86 code */
-      w32_signal_context.ContextFlags 
+      w32_signal_context.ContextFlags
         = CONTEXT_FULL|CONTEXT_FLOATING_POINT|CONTEXT_DEBUG_REGISTERS;
       GetThreadContext (w32_main_thread, &w32_signal_context);
 
       /* Change the context to w32_raise_in_main.  The
          context.Eip=&fn trick for setting the program counter is
          courtesy of
 
            http://fit.c2.com/files/LispPlatform/lisp/clisp-2.28/src/win32aux.d
diff --git a/libcruft/misc/f77-fcn.h b/libcruft/misc/f77-fcn.h
--- a/libcruft/misc/f77-fcn.h
+++ b/libcruft/misc/f77-fcn.h
@@ -97,17 +97,17 @@ CRUFT_API extern int f77_exception_encou
 #define F77_CHAR_ARG_DECL octave_cray_ftn_ch_dsc
 #define F77_CONST_CHAR_ARG_DECL octave_cray_ftn_ch_dsc
 #define F77_CHAR_ARG_LEN_DECL
 
 /* Use these macros to write C-language functions that accept
    Fortran-style character strings.  */
 #define F77_CHAR_ARG_DEF(s, len) octave_cray_ftn_ch_dsc s
 #define F77_CONST_CHAR_ARG_DEF(s, len) octave_cray_ftn_ch_dsc s
-#define F77_CHAR_ARG_LEN_DEF(len) 
+#define F77_CHAR_ARG_LEN_DEF(len)
 #define F77_CHAR_ARG_USE(s) s.ptr
 #define F77_CHAR_ARG_LEN_USE(s, len) (s.mask.len>>3)
 
 #define F77_RET_T int
 #define F77_RETURN(retval) return retval;
 
 /* FIXME -- these should work for SV1 or Y-MP systems but will
    need to be changed for others.  */
@@ -166,17 +166,17 @@ octave_make_cray_const_ftn_ch_dsc (const
 #define F77_CHAR_ARG_DECL char *, int
 #define F77_CONST_CHAR_ARG_DECL const char *, int
 #define F77_CHAR_ARG_LEN_DECL
 
 /* Use these macros to write C-language functions that accept
    Fortran-style character strings.  */
 #define F77_CHAR_ARG_DEF(s, len) char *s, int len
 #define F77_CONST_CHAR_ARG_DEF(s, len) const char *s, int len
-#define F77_CHAR_ARG_LEN_DEF(len) 
+#define F77_CHAR_ARG_LEN_DEF(len)
 #define F77_CHAR_ARG_USE(s) s
 #define F77_CHAR_ARG_LEN_USE(s, len) len
 
 #define F77_RET_T void
 #define F77_RETURN(retval)
 
 #else
 
@@ -204,23 +204,23 @@ octave_make_cray_const_ftn_ch_dsc (const
 #define F77_RET_T int
 #define F77_RETURN(retval) return retval;
 
 #endif
 
 
 /* Build a C string local variable CS from the Fortran string parameter S
    declared as F77_CHAR_ARG_DEF(s, len) or F77_CONST_CHAR_ARG_DEF(s, len).
-   The string will be cleaned up at the end of the current block.  
+   The string will be cleaned up at the end of the current block.
    Needs to include <cstring> and <vector>.  */
 
 #define F77_CSTRING(s, len, cs) \
  OCTAVE_LOCAL_BUFFER (char, cs, F77_CHAR_ARG_LEN_USE (s, len) + 1); \
  memcpy (cs, F77_CHAR_ARG_USE (s), F77_CHAR_ARG_LEN_USE (s, len)); \
- cs[F77_CHAR_ARG_LEN_USE(s, len)] = '\0' 
+ cs[F77_CHAR_ARG_LEN_USE(s, len)] = '\0'
 
 
 extern CRUFT_API F77_RET_T
 F77_FUNC (xstopx, XSTOPX) (F77_CONST_CHAR_ARG_DECL
                            F77_CHAR_ARG_LEN_DECL) GCC_ATTR_NORETURN;
 
 #ifdef __cplusplus
 }
diff --git a/libcruft/misc/quit.cc b/libcruft/misc/quit.cc
--- a/libcruft/misc/quit.cc
+++ b/libcruft/misc/quit.cc
@@ -48,36 +48,36 @@ octave_handle_signal (void)
     }
 }
 
 void
 octave_throw_interrupt_exception (void)
 {
   if (octave_interrupt_hook)
     octave_interrupt_hook ();
-    
+
   throw octave_interrupt_exception ();
 }
 
 void
 octave_throw_execution_exception (void)
 {
   // FIXME -- would a hook function be useful here?
 
   octave_exception_state = octave_exec_exception;
-    
+
   throw octave_execution_exception ();
 }
 
 void
 octave_throw_bad_alloc (void)
 {
   if (octave_bad_alloc_hook)
     octave_bad_alloc_hook ();
-    
+
   octave_exception_state = octave_alloc_exception;
 
   throw std::bad_alloc ();
 }
 
 void
 octave_rethrow_exception (void)
 {
diff --git a/liboctave/Array-b.cc b/liboctave/Array-b.cc
--- a/liboctave/Array-b.cc
+++ b/liboctave/Array-b.cc
@@ -41,17 +41,17 @@ static void do_bool_partition (bool *dat
   for (octave_idx_type i = 0; i < nel; i++)
     if (data[i] == desc)
       data[k++] = desc;
   for (octave_idx_type i = k; i < nel; i++)
     data[i] = ! desc;
 }
 
 template<bool desc>
-static void do_bool_partition (bool *data, octave_idx_type *idx, 
+static void do_bool_partition (bool *data, octave_idx_type *idx,
                                octave_idx_type nel)
 {
   // FIXME: This is essentially a simple bucket sort.
   // Can it be efficiently done by std::partition?
   OCTAVE_LOCAL_BUFFER (octave_idx_type, jdx, nel);
   octave_idx_type k = 0, l = 0;
   for (octave_idx_type i = 0; i < nel; i++)
     {
diff --git a/liboctave/Array-d.cc b/liboctave/Array-d.cc
--- a/liboctave/Array-d.cc
+++ b/liboctave/Array-d.cc
@@ -111,17 +111,17 @@ Array<double>::is_sorted (sortmode mode)
     {
       octave_idx_type j = 0;
       double r;
       // Sort out NaNs.
       do
         r = el[j++];
       while (xisnan (r) && j < n);
 
-      // Orient the test so that NaN will not pass through. 
+      // Orient the test so that NaN will not pass through.
       for (; j < n; j++)
         {
           if (r >= el[j])
             r = el[j];
           else
             {
               mode = UNSORTED;
               break;
@@ -132,17 +132,17 @@ Array<double>::is_sorted (sortmode mode)
   else if (mode == ASCENDING)
     {
       // Sort out NaNs.
       while (n > 0 && xisnan (el[n-1]))
         n--;
 
       if (n > 0)
         {
-          // Orient the test so that NaN will not pass through. 
+          // Orient the test so that NaN will not pass through.
           double r = el[0];
           for (octave_idx_type j = 1; j < n; j++)
             {
               if (r <= el[j])
                 r = el[j];
               else
                 {
                   mode = UNSORTED;
diff --git a/liboctave/Array-f.cc b/liboctave/Array-f.cc
--- a/liboctave/Array-f.cc
+++ b/liboctave/Array-f.cc
@@ -111,17 +111,17 @@ Array<float>::is_sorted (sortmode mode) 
     {
       octave_idx_type j = 0;
       float r;
       // Sort out NaNs.
       do
         r = el[j++];
       while (xisnan (r) && j < n);
 
-      // Orient the test so that NaN will not pass through. 
+      // Orient the test so that NaN will not pass through.
       for (; j < n; j++)
         {
           if (r >= el[j])
             r = el[j];
           else
             {
               mode = UNSORTED;
               break;
@@ -132,17 +132,17 @@ Array<float>::is_sorted (sortmode mode) 
   else if (mode == ASCENDING)
     {
       // Sort out NaNs.
       while (n > 0 && xisnan (el[n-1]))
         n--;
 
       if (n > 0)
         {
-          // Orient the test so that NaN will not pass through. 
+          // Orient the test so that NaN will not pass through.
           float r = el[0];
           for (octave_idx_type j = 1; j < n; j++)
             {
               if (r <= el[j])
                 r = el[j];
               else
                 {
                   mode = UNSORTED;
diff --git a/liboctave/Array-util.cc b/liboctave/Array-util.cc
--- a/liboctave/Array-util.cc
+++ b/liboctave/Array-util.cc
@@ -83,19 +83,19 @@ get_scalar_idx (Array<octave_idx_type>& 
 
   int n = idx.length ();
 
   if (n > 0)
     {
       retval = idx(--n);
 
       while (--n >= 0)
-        {               
+        {
           retval *= dims (n);
-        
+
           retval += idx(n);
         }
     }
   return retval;
 }
 
 octave_idx_type
 num_ones (const Array<octave_idx_type>& ra_idx)
@@ -124,17 +124,17 @@ is_scalar (const dim_vector& dim)
     }
   else
     {
       for (int i = 0; i < n; i ++)
         {
           if (dim (i) != 1)
             {
               retval = false;
-        
+
               break;
             }
         }
     }
   return retval;
 }
 
 bool
@@ -162,64 +162,64 @@ any_ones (const Array<octave_idx_type>& 
 {
   bool retval = false;
 
   for (octave_idx_type i = 0; i < arr.length (); i++)
     {
       if (arr (i) == 1)
         {
           retval = true;
-        
+
           break;
         }
     }
   return retval;
 }
 
-octave_idx_type 
+octave_idx_type
 compute_index (octave_idx_type n, const dim_vector& dims)
 {
   if (n < 0)
     gripe_invalid_index ();
   if (n >= dims.numel ())
     gripe_index_out_of_range (1, 1, n+1, dims.numel ());
 
   return n;
 }
 
-octave_idx_type 
+octave_idx_type
 compute_index (octave_idx_type i, octave_idx_type j, const dim_vector& dims)
 {
   if (i < 0 || j < 0)
     gripe_invalid_index ();
   if (i >= dims(0))
     gripe_index_out_of_range (2, 1, i+1, dims(0));
   if (j >= dims.numel (1))
     gripe_index_out_of_range (2, 2, j+1, dims.numel (1));
 
   return j*dims(0) + i;
 }
 
-octave_idx_type 
+octave_idx_type
 compute_index (octave_idx_type i, octave_idx_type j, octave_idx_type k,
                const dim_vector& dims)
 {
   if (i < 0 || j < 0 || k < 0)
     gripe_invalid_index ();
   if (i >= dims(0))
     gripe_index_out_of_range (3, 1, i+1, dims(0));
   if (j >= dims(1))
     gripe_index_out_of_range (3, 2, j+1, dims(1));
   if (k >= dims.numel (2))
     gripe_index_out_of_range (3, 3, k+1, dims.numel (2));
 
   return (k*dims(1) + j)*dims(0) + i;
 }
 
-octave_idx_type 
+octave_idx_type
 compute_index (const Array<octave_idx_type>& ra_idx, const dim_vector& dims)
 {
   int nd = ra_idx.length ();
   const dim_vector dv = dims.redim (nd);
   for (int d = 0; d < nd; d++)
     {
       if (ra_idx(d) < 0)
         gripe_invalid_index ();
@@ -423,17 +423,17 @@ get_ra_idx (octave_idx_type idx, const d
 
 dim_vector
 zero_dims_inquire (const Array<idx_vector>& ia, const dim_vector& rhdv)
 {
   int ial = ia.length (), rhdvl = rhdv.length ();
   dim_vector rdv = dim_vector::alloc (ial);
   bool *scalar = new bool[ial], *colon = new bool[ial];
   // Mark scalars and colons, count non-scalar indices.
-  int nonsc = 0; 
+  int nonsc = 0;
   bool all_colons = true;
   for (int i = 0; i < ial; i++)
     {
       // FIXME -- should we check for length() instead?
       scalar[i] = ia(i).is_scalar ();
       colon[i] = ia(i).is_colon ();
       if (! scalar[i]) nonsc++;
       if (! colon[i]) rdv(i) = ia(i).extent (0);
diff --git a/liboctave/Array-util.h b/liboctave/Array-util.h
--- a/liboctave/Array-util.h
+++ b/liboctave/Array-util.h
@@ -42,27 +42,27 @@ extern OCTAVE_API octave_idx_type num_on
 extern OCTAVE_API bool is_scalar (const dim_vector& dim);
 
 extern OCTAVE_API bool is_vector (const dim_vector& dim);
 
 extern OCTAVE_API bool any_ones (const Array<octave_idx_type>& arr);
 
 // These four compute a linear index for given dimensions, throwing
 // exceptions on invalid indices.
-extern OCTAVE_API octave_idx_type 
+extern OCTAVE_API octave_idx_type
 compute_index (octave_idx_type n, const dim_vector& dims);
 
-extern OCTAVE_API octave_idx_type 
+extern OCTAVE_API octave_idx_type
 compute_index (octave_idx_type i, octave_idx_type j, const dim_vector& dims);
 
-extern OCTAVE_API octave_idx_type 
+extern OCTAVE_API octave_idx_type
 compute_index (octave_idx_type i, octave_idx_type j, octave_idx_type k,
                const dim_vector& dims);
 
-extern OCTAVE_API octave_idx_type 
+extern OCTAVE_API octave_idx_type
 compute_index (const Array<octave_idx_type>& ra_idx, const dim_vector& dims);
 
 extern OCTAVE_API Array<octave_idx_type> conv_to_int_array (const Array<idx_vector>& a);
 
 extern OCTAVE_API Array<idx_vector> conv_to_array (const idx_vector *tmp, const octave_idx_type len);
 
 extern OCTAVE_API dim_vector freeze (Array<idx_vector>& ra_idx,
                           const dim_vector& dimensions, int resize_ok);
diff --git a/liboctave/Array.cc b/liboctave/Array.cc
--- a/liboctave/Array.cc
+++ b/liboctave/Array.cc
@@ -1,12 +1,12 @@
 // Template array classes
 /*
 
-Copyright (C) 1993-2011 John W. Eaton 
+Copyright (C) 1993-2011 John W. Eaton
 Copyright (C) 2008-2009 Jaroslav Hajek
 Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
@@ -83,17 +83,17 @@ Array<T>::fill (const T& val)
 template <class T>
 void
 Array<T>::clear (void)
 {
   if (--rep->count <= 0)
     delete rep;
 
   rep = nil_rep ();
-  rep->count++; 
+  rep->count++;
   slice_data = rep->data;
   slice_len = rep->len;
 
   dimensions = dim_vector ();
 }
 
 template <class T>
 void
@@ -180,44 +180,44 @@ Array<T>::compute_index (octave_idx_type
 template <class T>
 octave_idx_type
 Array<T>::compute_index (const Array<octave_idx_type>& ra_idx) const
 {
   return ::compute_index (ra_idx, dimensions);
 }
 
 template <class T>
-T& 
+T&
 Array<T>::checkelem (octave_idx_type n)
 {
   // Do checks directly to avoid recomputing slice_len.
   if (n < 0)
     gripe_invalid_index ();
   if (n >= slice_len)
     gripe_index_out_of_range (1, 1, n+1, slice_len);
 
   return elem (n);
 }
 
 template <class T>
-T& 
+T&
 Array<T>::checkelem (octave_idx_type i, octave_idx_type j)
 {
   return elem (compute_index (i, j));
 }
 
 template <class T>
-T& 
+T&
 Array<T>::checkelem (octave_idx_type i, octave_idx_type j, octave_idx_type k)
 {
   return elem (compute_index (i, j, k));
 }
 
 template <class T>
-T& 
+T&
 Array<T>::checkelem (const Array<octave_idx_type>& ra_idx)
 {
   return elem (compute_index (ra_idx));
 }
 
 template <class T>
 typename Array<T>::crefT
 Array<T>::checkelem (octave_idx_type n) const
@@ -411,17 +411,17 @@ private:
         {
           octave_idx_type step = stride[lev], len = dim[lev];
           for (octave_idx_type i = 0, j = 0; i < len; i++, j+= step)
            dest = do_permute (src + i * step, dest, lev-1);
         }
 
       return dest;
     }
-  
+
 public:
 
   template <class T>
   void permute (const T *src, T *dest) const { do_permute (src, dest, top); }
 
 };
 
 
@@ -500,17 +500,17 @@ Array<T>::permute (const Array<octave_id
     }
 
   return retval;
 }
 
 // Helper class for multi-d index reduction and recursive
 // indexing/indexed assignment.  Rationale: we could avoid recursion
 // using a state machine instead.  However, using recursion is much
-// more amenable to possible parallelization in the future. 
+// more amenable to possible parallelization in the future.
 // Also, the recursion solution is cleaner and more understandable.
 
 class rec_index_helper
 {
   // CDIM occupies the last half of the space allocated for dim to
   // avoid a double allocation.
 
   int n;
@@ -540,17 +540,17 @@ public:
             }
           else
             {
               // Unsuccessful, store index & cumulative dim.
               top++;
               idx[top] = ia(i);
               dim[top] = dv(i);
               cdim[top] = cdim[top-1] * dim[top-1];
-            } 
+            }
         }
     }
 
   ~rec_index_helper (void) { delete [] idx; delete [] dim; }
 
 private:
 
   // Recursive N-d indexing
@@ -563,17 +563,17 @@ private:
         {
           octave_idx_type nn = idx[lev].length (dim[lev]), d = cdim[lev];
           for (octave_idx_type i = 0; i < nn; i++)
             dest = do_index (src + d*idx[lev].xelem (i), dest, lev-1);
         }
 
       return dest;
     }
-  
+
   // Recursive N-d indexed assignment
   template <class T>
   const T *do_assign (const T *src, T *dest, int lev) const
     {
       if (lev == 0)
         src += idx[0].assign (src, dim[0], dest);
       else
         {
@@ -605,17 +605,17 @@ public:
   void index (const T *src, T *dest) const { do_index (src, dest, top); }
 
   template <class T>
   void assign (const T *src, T *dest) const { do_assign (src, dest, top); }
 
   template <class T>
   void fill (const T& val, T *dest) const { do_fill (val, dest, top); }
 
-  bool is_cont_range (octave_idx_type& l, 
+  bool is_cont_range (octave_idx_type& l,
                             octave_idx_type& u) const
     {
       return top == 0 && idx[0].is_cont_range (dim[0], l, u);
     }
 };
 
 // Helper class for multi-d recursive resizing
 // This handles resize () in an efficient manner, touching memory only
@@ -670,17 +670,17 @@ private:
           for (k = 0; k < cext[lev]; k++)
             do_resize_fill (src + k * sd, dest + k * dd, rfv, lev - 1);
 
           fill_or_memset (dext[lev] - k * dd, rfv, dest + k * dd);
         }
     }
 public:
   template <class T>
-  void resize_fill (const T* src, T *dest, const T& rfv) const 
+  void resize_fill (const T* src, T *dest, const T& rfv) const
     { do_resize_fill (src, dest, rfv, n-1); }
 
 };
 
 template <class T>
 Array<T>
 Array<T>::index (const idx_vector& i) const
 {
@@ -828,17 +828,17 @@ Array<T>::index (const Array<idx_vector>
 
 
       if (all_colons)
         {
           // A(:,:,...,:) produces a shallow copy.
           dv.chop_trailing_singletons ();
           retval = Array<T> (*this, dv);
         }
-      else 
+      else
         {
           // Form result dimensions.
           dim_vector rdv = dim_vector::alloc (ial);
           for (int i = 0; i < ial; i++) rdv(i) = ia(i).length (dv(i));
           rdv.chop_trailing_singletons ();
 
           // Prepare for recursive indexing
           rec_index_helper rh (dv, ia);
@@ -884,22 +884,22 @@ Array<T>::resize1 (octave_idx_type n, co
       // on some out-of-bounds assignments.  Specifically, Matlab
       // allows a(i) with out-of-bouds i when a is either of 0x0, 1x0,
       // 1x1, 0xN, and gives a row vector in all cases (yes, even the
       // last one, search me why).  Giving a column vector would make
       // much more sense (given the way trailing singleton dims are
       // treated).
       bool invalid = false;
       if (rows () == 0 || rows () == 1)
-        dv = dim_vector (1, n);          
+        dv = dim_vector (1, n);
       else if (columns () == 1)
         dv = dim_vector (n, 1);
       else
          invalid = true;
-        
+
       if (invalid)
         gripe_invalid_resize ();
       else
         {
           octave_idx_type nx = numel ();
           if (n == nx - 1 && n > 0)
             {
               // Stack "pop" operation.
@@ -999,26 +999,26 @@ Array<T>::resize (const dim_vector& dv, 
     {
       if (dimensions.length () <= dvl && ! dv.any_neg ())
         {
           Array<T> tmp (dv);
           // Prepare for recursive resizing.
           rec_resize_helper rh (dv, dimensions.redim (dvl));
 
           // Do it.
-          rh.resize_fill (data (), tmp.fortran_vec (), rfv);   
+          rh.resize_fill (data (), tmp.fortran_vec (), rfv);
           *this = tmp;
         }
       else
         gripe_invalid_resize ();
     }
 }
 
 template <class T>
-Array<T> 
+Array<T>
 Array<T>::index (const idx_vector& i, bool resize_ok, const T& rfv) const
 {
   Array<T> tmp = *this;
   if (resize_ok)
     {
       octave_idx_type n = numel (), nx = i.extent (n);
       if (n != nx)
         {
@@ -1031,18 +1031,18 @@ Array<T>::index (const idx_vector& i, bo
       if (tmp.numel () != nx)
         return Array<T> ();
     }
 
   return tmp.index (i);
 }
 
 template <class T>
-Array<T> 
-Array<T>::index (const idx_vector& i, const idx_vector& j, 
+Array<T>
+Array<T>::index (const idx_vector& i, const idx_vector& j,
                  bool resize_ok, const T& rfv) const
 {
   Array<T> tmp = *this;
   if (resize_ok)
     {
       dim_vector dv = dimensions.redim (2);
       octave_idx_type r = dv(0), c = dv(1);
       octave_idx_type rx = i.extent (r), cx = j.extent (c);
@@ -1053,74 +1053,74 @@ Array<T>::index (const idx_vector& i, co
           else
             tmp.resize2 (rx, cx, rfv);
         }
 
       if (tmp.rows () != rx || tmp.columns () != cx)
         return Array<T> ();
     }
 
-  return tmp.index (i, j);  
+  return tmp.index (i, j);
 }
 
 template <class T>
-Array<T> 
+Array<T>
 Array<T>::index (const Array<idx_vector>& ia,
                  bool resize_ok, const T& rfv) const
 {
   Array<T> tmp = *this;
   if (resize_ok)
     {
       int ial = ia.length ();
       dim_vector dv = dimensions.redim (ial);
       dim_vector dvx = dim_vector::alloc (ial);
       for (int i = 0; i < ial; i++) dvx(i) = ia(i).extent (dv (i));
       if (! (dvx == dv))
         {
           bool all_scalars = true;
-          for (int i = 0; i < ial; i++) 
+          for (int i = 0; i < ial; i++)
             all_scalars = all_scalars && ia(i).is_scalar ();
           if (all_scalars)
             return Array<T> (dim_vector (1, 1), rfv);
           else
             tmp.resize (dvx, rfv);
         }
 
       if (tmp.dimensions != dvx)
         return Array<T> ();
     }
 
-  return tmp.index (ia);  
+  return tmp.index (ia);
 }
 
 
 template <class T>
 void
 Array<T>::assign (const idx_vector& i, const Array<T>& rhs, const T& rfv)
 {
   octave_idx_type n = numel (), rhl = rhs.numel ();
 
   if (rhl == 1 || i.length (n) == rhl)
     {
       octave_idx_type nx = i.extent (n);
       bool colon = i.is_colon_equiv (nx);
-      // Try to resize first if necessary. 
+      // Try to resize first if necessary.
       if (nx != n)
         {
-          // Optimize case A = []; A(1:n) = X with A empty. 
+          // Optimize case A = []; A(1:n) = X with A empty.
           if (dimensions.zero_by_zero () && colon)
             {
               if (rhl == 1)
                 *this = Array<T> (dim_vector (1, nx), rhs(0));
               else
                 *this = Array<T> (rhs, dim_vector (1, nx));
               return;
             }
 
-          resize1 (nx, rfv);      
+          resize1 (nx, rfv);
           n = numel ();
         }
 
       if (colon)
         {
           // A(:) = X makes a full fill or a shallow copy.
           if (rhl == 1)
             fill (rhs(0));
@@ -1140,21 +1140,21 @@ Array<T>::assign (const idx_vector& i, c
 }
 
 template <class T>
 void
 Array<T>::assign (const idx_vector& i, const idx_vector& j,
                   const Array<T>& rhs, const T& rfv)
 {
   // Get RHS extents, discarding singletons.
-  dim_vector rhdv = rhs.dims (); 
+  dim_vector rhdv = rhs.dims ();
   // Get LHS extents, allowing Fortran indexing in the second dim.
   dim_vector dv = dimensions.redim (2);
   // Check for out-of-bounds and form resizing dimensions.
-  dim_vector rdv; 
+  dim_vector rdv;
   // In the special when all dimensions are zero, colons are allowed
   // to inquire the shape of RHS.  The rules are more obscure, so we
   // solve that elsewhere.
   if (dv.all_zero ())
     rdv = zero_dims_inquire (i, j, rhdv);
   else
     {
       rdv(0) = i.extent (dv(0));
@@ -1165,17 +1165,17 @@ Array<T>::assign (const idx_vector& i, c
   octave_idx_type il = i.length (rdv(0)), jl = j.length (rdv(1));
   rhdv.chop_all_singletons ();
   bool match = (isfill
                 || (rhdv.length () == 2 && il == rhdv(0) && jl == rhdv(1)));
   match = match || (il == 1 && jl == rhdv(0) && rhdv(1) == 1);
 
   if (match)
     {
-      bool all_colons = (i.is_colon_equiv (rdv(0)) 
+      bool all_colons = (i.is_colon_equiv (rdv(0))
                          && j.is_colon_equiv (rdv(1)));
       // Resize if requested.
       if (rdv != dv)
         {
           // Optimize case A = []; A(1:m, 1:n) = X
           if (dv.zero_by_zero () && all_colons)
             {
               if (isfill)
@@ -1247,18 +1247,18 @@ Array<T>::assign (const Array<idx_vector
     assign (ia(0), ia(1), rhs, rfv);
   else if (ial > 0)
     {
       // Get RHS extents, discarding singletons.
       dim_vector rhdv = rhs.dims ();
 
       // Get LHS extents, allowing Fortran indexing in the second dim.
       dim_vector dv = dimensions.redim (ial);
-      
-      // Get the extents forced by indexing. 
+
+      // Get the extents forced by indexing.
       dim_vector rdv;
 
       // In the special when all dimensions are zero, colons are
       // allowed to inquire the shape of RHS.  The rules are more
       // obscure, so we solve that elsewhere.
       if (dv.all_zero ())
         rdv = zero_dims_inquire (ia, rhdv);
       else
@@ -1278,17 +1278,17 @@ Array<T>::assign (const Array<idx_vector
           all_colons = all_colons && ia(i).is_colon_equiv (rdv(i));
           octave_idx_type l = ia(i).length (rdv(i));
           if (l == 1) continue;
           match = match && j < rhdvl && l == rhdv(j++);
         }
 
       match = match && (j == rhdvl || rhdv(j) == 1);
       match = match || isfill;
-            
+
       if (match)
         {
           // Resize first if necessary.
           if (rdv != dv)
             {
               // Optimize case A = []; A(1:m, 1:n) = X
               if (dv.zero_by_zero () && all_colons)
                 {
@@ -1321,28 +1321,28 @@ Array<T>::assign (const Array<idx_vector
 
               // Do it.
               if (isfill)
                 rh.fill (rhs(0), fortran_vec ());
               else
                 rh.assign (rhs.data (), fortran_vec ());
             }
         }
-      else 
+      else
         gripe_assignment_dimension_mismatch ();
     }
 }
 
 template <class T>
-void 
+void
 Array<T>::delete_elements (const idx_vector& i)
 {
   octave_idx_type n = numel ();
   if (i.is_colon ())
-    { 
+    {
       *this = Array<T> ();
     }
   else if (i.length (n) != 0)
     {
       if (i.extent (n) != n)
         gripe_del_index_out_of_range (true, i.extent (n), n);
 
       octave_idx_type l, u;
@@ -1367,29 +1367,29 @@ Array<T>::delete_elements (const idx_vec
         {
           // Use index.
           *this = index (i.complement (n));
         }
     }
 }
 
 template <class T>
-void 
+void
 Array<T>::delete_elements (int dim, const idx_vector& i)
 {
   if (dim < 0 || dim >= ndims ())
     {
       (*current_liboctave_error_handler)
         ("invalid dimension in delete_elements");
       return;
     }
 
   octave_idx_type n = dimensions (dim);
   if (i.is_colon ())
-    { 
+    {
       *this = Array<T> ();
     }
   else if (i.length (n) != 0)
     {
       if (i.extent (n) != n)
         gripe_del_index_out_of_range (false, i.extent (n), n);
 
       octave_idx_type l, u;
@@ -1425,17 +1425,17 @@ Array<T>::delete_elements (int dim, cons
           Array<idx_vector> ia (dim_vector (ndims (), 1), idx_vector::colon);
           ia (dim) = i.complement (n);
           *this = index (ia);
         }
     }
 }
 
 template <class T>
-void 
+void
 Array<T>::delete_elements (const Array<idx_vector>& ia)
 {
   if (ia.length () == 1)
     delete_elements (ia(0));
   else
     {
       int len = ia.length (), k, dim = -1;
       for (k = 0; k < len; k++)
@@ -1570,34 +1570,34 @@ Array<T>::hermitian (T (*fcn) (const T&)
       T buf[64];
 
       octave_idx_type ii = 0, jj;
       for (jj = 0; jj < (nc - 8 + 1); jj += 8)
         {
           for (ii = 0; ii < (nr - 8 + 1); ii += 8)
             {
               // Copy to buffer
-              for (octave_idx_type j = jj, k = 0, idxj = jj * nr; 
+              for (octave_idx_type j = jj, k = 0, idxj = jj * nr;
                    j < jj + 8; j++, idxj += nr)
                 for (octave_idx_type i = ii; i < ii + 8; i++)
                   buf[k++] = xelem (i + idxj);
 
               // Copy from buffer
-              for (octave_idx_type i = ii, idxi = ii * nc; i < ii + 8; 
+              for (octave_idx_type i = ii, idxi = ii * nc; i < ii + 8;
                    i++, idxi += nc)
-                for (octave_idx_type j = jj, k = i - ii; j < jj + 8; 
+                for (octave_idx_type j = jj, k = i - ii; j < jj + 8;
                      j++, k+=8)
                   result.xelem (j + idxi) = fcn (buf[k]);
             }
 
           if (ii < nr)
             for (octave_idx_type j = jj; j < jj + 8; j++)
               for (octave_idx_type i = ii; i < nr; i++)
                 result.xelem (j, i) = fcn (xelem (i, j));
-        } 
+        }
 
       for (octave_idx_type j = jj; j < nc; j++)
         for (octave_idx_type i = 0; i < nr; i++)
           result.xelem (j, i) = fcn (xelem (i, j));
 
       return result;
     }
   else
@@ -1690,27 +1690,27 @@ Array<T>::sort (int dim, sortmode mode) 
 
   for (int i = 0; i < dim; i++)
     stride *= dv(i);
 
   T *v = m.fortran_vec ();
   const T *ov = data ();
 
   octave_sort<T> lsort;
-  
-  if (mode != UNSORTED) 
+
+  if (mode != UNSORTED)
     lsort.set_compare (mode);
   else
     return m;
 
   if (stride == 1)
     {
       for (octave_idx_type j = 0; j < iter; j++)
         {
-          // copy and partition out NaNs. 
+          // copy and partition out NaNs.
           // FIXME: impact on integer types noticeable?
           octave_idx_type kl = 0, ku = ns;
           for (octave_idx_type i = 0; i < ns; i++)
             {
               T tmp = ov[i];
               if (sort_isnan<T> (tmp))
                 v[--ku] = tmp;
               else
@@ -1731,30 +1731,30 @@ Array<T>::sort (int dim, sortmode mode) 
           v += ns;
           ov += ns;
         }
     }
   else
     {
       OCTAVE_LOCAL_BUFFER (T, buf, ns);
 
-      for (octave_idx_type j = 0; j < iter; j++) 
+      for (octave_idx_type j = 0; j < iter; j++)
         {
           octave_idx_type offset = j;
           octave_idx_type offset2 = 0;
 
           while (offset >= stride)
             {
               offset -= stride;
               offset2++;
             }
 
           offset += offset2 * stride * ns;
-          
-          // gather and partition out NaNs. 
+
+          // gather and partition out NaNs.
           // FIXME: impact on integer types noticeable?
           octave_idx_type kl = 0, ku = ns;
           for (octave_idx_type i = 0; i < ns; i++)
             {
               T tmp = ov[i*stride + offset];
               if (sort_isnan<T> (tmp))
                 buf[--ku] = tmp;
               else
@@ -1778,17 +1778,17 @@ Array<T>::sort (int dim, sortmode mode) 
         }
     }
 
   return m;
 }
 
 template <class T>
 Array<T>
-Array<T>::sort (Array<octave_idx_type> &sidx, int dim, 
+Array<T>::sort (Array<octave_idx_type> &sidx, int dim,
                 sortmode mode) const
 {
   if (dim < 0 || dim >= ndims ())
     {
       (*current_liboctave_error_handler)
         ("sort: invalid dimension");
       return Array<T> ();
     }
@@ -1812,27 +1812,27 @@ Array<T>::sort (Array<octave_idx_type> &
 
   T *v = m.fortran_vec ();
   const T *ov = data ();
 
   octave_sort<T> lsort;
 
   sidx = Array<octave_idx_type> (dv);
   octave_idx_type *vi = sidx.fortran_vec ();
-  
-  if (mode != UNSORTED) 
+
+  if (mode != UNSORTED)
     lsort.set_compare (mode);
   else
     return m;
 
   if (stride == 1)
     {
       for (octave_idx_type j = 0; j < iter; j++)
         {
-          // copy and partition out NaNs. 
+          // copy and partition out NaNs.
           // FIXME: impact on integer types noticeable?
           octave_idx_type kl = 0, ku = ns;
           for (octave_idx_type i = 0; i < ns; i++)
             {
               T tmp = ov[i];
               if (sort_isnan<T> (tmp))
                 {
                   --ku;
@@ -1867,30 +1867,30 @@ Array<T>::sort (Array<octave_idx_type> &
           ov += ns;
         }
     }
   else
     {
       OCTAVE_LOCAL_BUFFER (T, buf, ns);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, bufi, ns);
 
-      for (octave_idx_type j = 0; j < iter; j++) 
+      for (octave_idx_type j = 0; j < iter; j++)
         {
           octave_idx_type offset = j;
           octave_idx_type offset2 = 0;
 
           while (offset >= stride)
             {
               offset -= stride;
               offset2++;
             }
 
           offset += offset2 * stride * ns;
-          
-          // gather and partition out NaNs. 
+
+          // gather and partition out NaNs.
           // FIXME: impact on integer types noticeable?
           octave_idx_type kl = 0, ku = ns;
           for (octave_idx_type i = 0; i < ns; i++)
             {
               T tmp = ov[i*stride + offset];
               if (sort_isnan<T> (tmp))
                 {
                   --ku;
@@ -1993,17 +1993,17 @@ Array<T>::sort_rows_idx (sortmode mode) 
 
   lsort.sort_rows (data (), idx.fortran_vec (), r, c);
 
   return idx;
 }
 
 
 template <class T>
-sortmode 
+sortmode
 Array<T>::is_sorted_rows (sortmode mode) const
 {
   octave_sort<T> lsort;
 
   octave_idx_type r = rows (), c = cols ();
 
   if (r <= 1 || c == 0)
     return mode ? mode : ASCENDING;
@@ -2052,17 +2052,17 @@ Array<T>::is_sorted_rows (sortmode mode)
     }
 
   return mode;
 
 }
 
 // Do a binary lookup in a sorted array.
 template <class T>
-octave_idx_type 
+octave_idx_type
 Array<T>::lookup (const T& value, sortmode mode) const
 {
   octave_idx_type n = numel ();
   octave_sort<T> lsort;
 
   if (mode == UNSORTED)
     {
       // auto-detect mode
@@ -2073,17 +2073,17 @@ Array<T>::lookup (const T& value, sortmo
     }
 
   lsort.set_compare (mode);
 
   return lsort.lookup (data (), n, value);
 }
 
 template <class T>
-Array<octave_idx_type> 
+Array<octave_idx_type>
 Array<T>::lookup (const Array<T>& values, sortmode mode) const
 {
   octave_idx_type n = numel (), nval = values.numel ();
   octave_sort<T> lsort;
   Array<octave_idx_type> idx (values.dims ());
 
   if (mode == UNSORTED)
     {
@@ -2115,31 +2115,31 @@ Array<T>::lookup (const Array<T>& values
                          idx.fortran_vec (), vmode != mode);
   else
     lsort.lookup (data (), n, values.data (), nval, idx.fortran_vec ());
 
   return idx;
 }
 
 template <class T>
-octave_idx_type 
+octave_idx_type
 Array<T>::nnz (void) const
 {
   const T *src = data ();
   octave_idx_type nel = nelem (), retval = 0;
   const T zero = T ();
   for (octave_idx_type i = 0; i < nel; i++)
     if (src[i] != zero)
       retval++;
 
   return retval;
 }
 
 template <class T>
-Array<octave_idx_type> 
+Array<octave_idx_type>
 Array<T>::find (octave_idx_type n, bool backward) const
 {
   Array<octave_idx_type> retval;
   const T *src = data ();
   octave_idx_type nel = nelem ();
   const T zero = T ();
   if (n < 0 || n >= nel)
     {
@@ -2297,33 +2297,33 @@ Array<T>::nth_element (const idx_vector&
   lsort.set_compare (mode);
 
   for (octave_idx_type j = 0; j < iter; j++)
     {
       octave_idx_type kl = 0, ku = ns;
 
       if (stride == 1)
         {
-          // copy without NaNs. 
+          // copy without NaNs.
           // FIXME: impact on integer types noticeable?
           for (octave_idx_type i = 0; i < ns; i++)
             {
               T tmp = ov[i];
               if (sort_isnan<T> (tmp))
                 buf[--ku] = tmp;
               else
                 buf[kl++] = tmp;
             }
 
           ov += ns;
         }
       else
         {
           octave_idx_type offset = j % stride;
-          // copy without NaNs. 
+          // copy without NaNs.
           // FIXME: impact on integer types noticeable?
           for (octave_idx_type i = 0; i < ns; i++)
             {
               T tmp = ov[offset + i*stride];
               if (sort_isnan<T> (tmp))
                 buf[--ku] = tmp;
               else
                 buf[kl++] = tmp;
@@ -2416,17 +2416,17 @@ template <class T>
 Array<T>
 Array<T>::diag (octave_idx_type k) const
 {
   dim_vector dv = dims ();
   octave_idx_type nd = dv.length ();
   Array<T> d;
 
   if (nd > 2)
-    (*current_liboctave_error_handler) ("Matrix must be 2-dimensional");    
+    (*current_liboctave_error_handler) ("Matrix must be 2-dimensional");
   else
     {
       octave_idx_type nnr = dv (0);
       octave_idx_type nnc = dv (1);
 
       if (nnr == 0 || nnc == 0)
         ; // do nothing
       else if (nnr != 1 && nnc != 1)
@@ -2623,17 +2623,17 @@ Array<T>::print_info (std::ostream& os, 
 }
 
 template <class T>
 bool Array<T>::optimize_dimensions (const dim_vector& dv)
 {
   bool retval = dimensions == dv;
   if (retval)
     dimensions = dv;
-  
+
   return retval;
 }
 
 template <class T>
 void Array<T>::instantiation_guard ()
 {
   // This guards against accidental implicit instantiations.
   // Array<T> instances should always be explicit and use INSTANTIATE_ARRAY.
diff --git a/liboctave/Array.h b/liboctave/Array.h
--- a/liboctave/Array.h
+++ b/liboctave/Array.h
@@ -56,26 +56,26 @@ protected:
   class ArrayRep
   {
   public:
 
     T *data;
     octave_idx_type len;
     int count;
 
-    ArrayRep (T *d, octave_idx_type l) 
-      : data (no_ctor_new<T> (l)), len (l), count (1) 
-        { 
+    ArrayRep (T *d, octave_idx_type l)
+      : data (no_ctor_new<T> (l)), len (l), count (1)
+        {
           copy_or_memcpy (l, d, data);
         }
 
     template <class U>
-    ArrayRep (U *d, octave_idx_type l) 
-      : data (no_ctor_new<T> (l)), len (l), count (1) 
-        { 
+    ArrayRep (U *d, octave_idx_type l)
+      : data (no_ctor_new<T> (l)), len (l), count (1)
+        {
           std::copy (d, d+l, data);
         }
 
     ArrayRep (void) : data (0), len (0), count (1) { }
 
     explicit ArrayRep (octave_idx_type n) : data (no_ctor_new<T> (n)), len (n), count (1) { }
 
     explicit ArrayRep (octave_idx_type n, const T& val)
@@ -84,17 +84,17 @@ protected:
         fill_or_memset (n, val, data);
       }
 
     ArrayRep (const ArrayRep& a)
       : data (no_ctor_new<T> (a.len)), len (a.len), count (1)
       {
         copy_or_memcpy (a.len, a.data, data);
       }
- 
+
     ~ArrayRep (void) { no_ctor_delete<T> (data); }
 
     octave_idx_type length (void) const { return len; }
 
   private:
 
     // No assignment!
 
@@ -159,18 +159,18 @@ private:
 
 public:
 
   // Empty ctor (0x0).
 
   Array (void)
     : dimensions (), rep (nil_rep ()), slice_data (rep->data),
       slice_len (rep->len)
-    { 
-      rep->count++; 
+    {
+      rep->count++;
     }
 
   // Obsolete 1D ctor (there are no 1D arrays).
   explicit Array (octave_idx_type n) GCC_ATTR_DEPRECATED
     : dimensions (n, 1), rep (new typename Array<T>::ArrayRep (n)),
       slice_data (rep->data), slice_len (rep->len)
     { }
 
@@ -182,17 +182,17 @@ public:
       fill (val);
     }
 
   // nD uninitialized ctor.
   explicit Array (const dim_vector& dv)
     : dimensions (dv),
       rep (new typename Array<T>::ArrayRep (dv.safe_numel ())),
       slice_data (rep->data), slice_len (rep->len)
-    { 
+    {
       dimensions.chop_trailing_singletons ();
     }
 
   // nD initialized ctor.
   explicit Array (const dim_vector& dv, const T& val)
     : dimensions (dv),
       rep (new typename Array<T>::ArrayRep (dv.safe_numel ())),
       slice_data (rep->data), slice_len (rep->len)
@@ -241,17 +241,17 @@ public:
           dimensions = a.dimensions;
           slice_data = a.slice_data;
           slice_len = a.slice_len;
         }
 
       return *this;
     }
 
-  void fill (const T& val); 
+  void fill (const T& val);
 
   void clear (void);
   void clear (const dim_vector& dv);
 
   void clear (octave_idx_type r, octave_idx_type c)
     { clear (dim_vector (r, c)); }
 
   octave_idx_type capacity (void) const { return slice_len; }
@@ -299,38 +299,38 @@ public:
   octave_idx_type pages (void) const { return dim3 (); }
 
   size_t byte_size (void) const { return static_cast<size_t> (numel ()) * sizeof (T); }
 
   // Return a const-reference so that dims ()(i) works efficiently.
   const dim_vector& dims (void) const { return dimensions; }
 
   Array<T> squeeze (void) const;
-  
+
   void chop_trailing_singletons (void) GCC_ATTR_DEPRECATED
   { dimensions.chop_trailing_singletons (); }
-  
+
   octave_idx_type compute_index (octave_idx_type i, octave_idx_type j) const;
   octave_idx_type compute_index (octave_idx_type i, octave_idx_type j, octave_idx_type k) const;
   octave_idx_type compute_index (const Array<octave_idx_type>& ra_idx) const;
 
   octave_idx_type compute_index_unchecked (const Array<octave_idx_type>& ra_idx) const
     { return dimensions.compute_index (ra_idx.data (), ra_idx.length ()); }
 
   // No checking, even for multiple references, ever.
 
   T& xelem (octave_idx_type n) { return slice_data [n]; }
   crefT xelem (octave_idx_type n) const { return slice_data [n]; }
 
   T& xelem (octave_idx_type i, octave_idx_type j) { return xelem (dim1()*j+i); }
   crefT xelem (octave_idx_type i, octave_idx_type j) const { return xelem (dim1()*j+i); }
 
-  T& xelem (octave_idx_type i, octave_idx_type j, octave_idx_type k) 
+  T& xelem (octave_idx_type i, octave_idx_type j, octave_idx_type k)
     { return xelem (i, dim2()*k+j); }
-  crefT xelem (octave_idx_type i, octave_idx_type j, octave_idx_type k) const 
+  crefT xelem (octave_idx_type i, octave_idx_type j, octave_idx_type k) const
     { return xelem (i, dim2()*k+j); }
 
   T& xelem (const Array<octave_idx_type>& ra_idx)
     { return xelem (compute_index_unchecked (ra_idx)); }
 
   crefT xelem (const Array<octave_idx_type>& ra_idx) const
     { return xelem (compute_index_unchecked (ra_idx)); }
 
@@ -438,17 +438,17 @@ public:
   // Indexing without resizing.
 
   Array<T> index (const idx_vector& i) const;
 
   Array<T> index (const idx_vector& i, const idx_vector& j) const;
 
   Array<T> index (const Array<idx_vector>& ia) const;
 
-  static const T& resize_fill_value (); 
+  static const T& resize_fill_value ();
 
   // Resizing (with fill).
 
   void resize1 (octave_idx_type n, const T& rfv = resize_fill_value ());
 
   void resize (octave_idx_type n) GCC_ATTR_DEPRECATED
     { resize1 (n); }
 
@@ -462,25 +462,25 @@ public:
 
   // Indexing with possible resizing and fill
   // FIXME -- this is really a corner case, that should better be
   // handled directly in liboctinterp.
 
   Array<T> index (const idx_vector& i, bool resize_ok,
                   const T& rfv = resize_fill_value ()) const;
 
-  Array<T> index (const idx_vector& i, const idx_vector& j, 
+  Array<T> index (const idx_vector& i, const idx_vector& j,
                   bool resize_ok, const T& rfv = resize_fill_value ()) const;
 
   Array<T> index (const Array<idx_vector>& ia,
                   bool resize_ok, const T& rfv = resize_fill_value ()) const;
 
   // Indexed assignment (always with resize & fill).
 
-  void assign (const idx_vector& i, const Array<T>& rhs, 
+  void assign (const idx_vector& i, const Array<T>& rhs,
                const T& rfv = resize_fill_value ());
 
   void assign (const idx_vector& i, const idx_vector& j, const Array<T>& rhs,
                const T& rfv = resize_fill_value ());
 
   void assign (const Array<idx_vector>& ia, const Array<T>& rhs,
                const T& rfv = resize_fill_value ());
 
@@ -610,17 +610,17 @@ public:
 
     const T *m = data ();
 
     octave_idx_type i;
     for (i = 0; i < len - 3; i += 4)
       {
         octave_quit ();
 
-        if (fcn (m[i]) != zero 
+        if (fcn (m[i]) != zero
             || fcn (m[i+1]) != zero
             || fcn (m[i+2]) != zero
             || fcn (m[i+3]) != zero)
            return ! zero;
 
       }
 
     octave_quit ();
@@ -658,17 +658,17 @@ public:
 
   // Returns true if this->dims () == dv, and if so, replaces this->dimensions
   // by a shallow copy of dv. This is useful for maintaining several arrays with
   // supposedly equal dimensions (e.g. structs in the interpreter).
   bool optimize_dimensions (const dim_vector& dv);
 
 private:
 
-  void resize2 (octave_idx_type nr, octave_idx_type nc, 
+  void resize2 (octave_idx_type nr, octave_idx_type nc,
                 const T& rfv = resize_fill_value ());
 
   static void instantiation_guard ();
 };
 
 // This is a simple wrapper template that will subclass an Array<T> type or any
 // later type derived from it and override the default non-const operator() to
 // not check for the array's uniqueness. It is, however, the user's
diff --git a/liboctave/Array3.h b/liboctave/Array3.h
--- a/liboctave/Array3.h
+++ b/liboctave/Array3.h
@@ -58,17 +58,17 @@ public:
   Array3<T>& operator = (const Array3<T>& a)
     {
       if (this != &a)
         Array<T>::operator = (a);
 
       return *this;
     }
 
-  void resize (octave_idx_type r, octave_idx_type c, octave_idx_type p) 
+  void resize (octave_idx_type r, octave_idx_type c, octave_idx_type p)
     { Array<T>::resize (dim_vector (r, c, p)); }
 
   void resize (octave_idx_type r, octave_idx_type c, octave_idx_type p, const T& val)
     { Array<T>::resize (dim_vector (r, c, p), val); }
 
   Array3<T> sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const
     {
       Array<T> tmp = Array<T>::sort (dim, mode);
diff --git a/liboctave/CColVector.cc b/liboctave/CColVector.cc
--- a/liboctave/CColVector.cc
+++ b/liboctave/CColVector.cc
@@ -216,19 +216,19 @@ ComplexColumnVector::stack (const Comple
   octave_idx_type len = length ();
   octave_idx_type nr_insert = len;
   ComplexColumnVector retval (len + a.length ());
   retval.insert (*this, 0);
   retval.insert (a, nr_insert);
   return retval;
 }
 
-ComplexRowVector 
+ComplexRowVector
 ComplexColumnVector::hermitian (void) const
-{ 
+{
   return MArray<Complex>::hermitian (std::conj);
 }
 
 ComplexRowVector
 ComplexColumnVector::transpose (void) const
 {
   return MArray<Complex>::transpose ();
 }
diff --git a/liboctave/CColVector.h b/liboctave/CColVector.h
--- a/liboctave/CColVector.h
+++ b/liboctave/CColVector.h
@@ -37,17 +37,17 @@ friend class ComplexRowVector;
 
 public:
 
   ComplexColumnVector (void) : MArray<Complex> (dim_vector (0, 1)) { }
 
   explicit ComplexColumnVector (octave_idx_type n)
     : MArray<Complex> (dim_vector (n, 1)) { }
 
-  explicit ComplexColumnVector (const dim_vector& dv) 
+  explicit ComplexColumnVector (const dim_vector& dv)
     : MArray<Complex> (dv.as_column ()) { }
 
   ComplexColumnVector (octave_idx_type n, const Complex& val)
     : MArray<Complex> (dim_vector (n, 1), val) { }
 
   ComplexColumnVector (const ComplexColumnVector& a) : MArray<Complex> (a) { }
 
   ComplexColumnVector (const MArray<Complex>& a)
diff --git a/liboctave/CDiagMatrix.cc b/liboctave/CDiagMatrix.cc
--- a/liboctave/CDiagMatrix.cc
+++ b/liboctave/CDiagMatrix.cc
@@ -270,33 +270,33 @@ ComplexDiagMatrix::extract (octave_idx_t
 ComplexRowVector
 ComplexDiagMatrix::row (octave_idx_type i) const
 {
   octave_idx_type r = rows ();
   octave_idx_type c = cols ();
   if (i < 0 || i >= r)
     {
       (*current_liboctave_error_handler) ("invalid row selection");
-      return ComplexRowVector (); 
+      return ComplexRowVector ();
     }
 
   ComplexRowVector retval (c, 0.0);
   if (r <= c || (r > c && i < c))
     retval.elem (i) = elem (i, i);
 
   return retval;
 }
 
 ComplexRowVector
 ComplexDiagMatrix::row (char *s) const
 {
   if (! s)
     {
       (*current_liboctave_error_handler) ("invalid row selection");
-      return ComplexRowVector (); 
+      return ComplexRowVector ();
     }
 
   char c = *s;
   if (c == 'f' || c == 'F')
     return row (static_cast<octave_idx_type>(0));
   else if (c == 'l' || c == 'L')
     return row (rows () - 1);
   else
@@ -309,44 +309,44 @@ ComplexDiagMatrix::row (char *s) const
 ComplexColumnVector
 ComplexDiagMatrix::column (octave_idx_type i) const
 {
   octave_idx_type r = rows ();
   octave_idx_type c = cols ();
   if (i < 0 || i >= c)
     {
       (*current_liboctave_error_handler) ("invalid column selection");
-      return ComplexColumnVector (); 
+      return ComplexColumnVector ();
     }
 
   ComplexColumnVector retval (r, 0.0);
   if (r >= c || (r < c && i < r))
     retval.elem (i) = elem (i, i);
 
   return retval;
 }
 
 ComplexColumnVector
 ComplexDiagMatrix::column (char *s) const
 {
   if (! s)
     {
       (*current_liboctave_error_handler) ("invalid column selection");
-      return ComplexColumnVector (); 
+      return ComplexColumnVector ();
     }
 
   char c = *s;
   if (c == 'f' || c == 'F')
     return column (static_cast<octave_idx_type>(0));
   else if (c == 'l' || c == 'L')
     return column (cols () - 1);
   else
     {
       (*current_liboctave_error_handler) ("invalid column selection");
-      return ComplexColumnVector (); 
+      return ComplexColumnVector ();
     }
 }
 
 ComplexDiagMatrix
 ComplexDiagMatrix::inverse (void) const
 {
   octave_idx_type info;
   return inverse (info);
diff --git a/liboctave/CDiagMatrix.h b/liboctave/CDiagMatrix.h
--- a/liboctave/CDiagMatrix.h
+++ b/liboctave/CDiagMatrix.h
@@ -47,29 +47,29 @@ public:
     : MDiagArray2<Complex> (r, c, val) { }
 
   explicit ComplexDiagMatrix (const Array<Complex>& a)
     : MDiagArray2<Complex> (a) { }
 
   explicit ComplexDiagMatrix (const Array<double>& a)
     : MDiagArray2<Complex> (Array<Complex> (a)) { }
 
-  ComplexDiagMatrix (const Array<Complex>& a, octave_idx_type r, octave_idx_type c) 
+  ComplexDiagMatrix (const Array<Complex>& a, octave_idx_type r, octave_idx_type c)
     : MDiagArray2<Complex> (a, r, c) { }
 
   explicit ComplexDiagMatrix (const DiagMatrix& a);
 
   ComplexDiagMatrix (const MDiagArray2<Complex>& a)
     : MDiagArray2<Complex> (a) { }
 
   ComplexDiagMatrix (const ComplexDiagMatrix& a)
     : MDiagArray2<Complex> (a) { }
 
   template <class U>
-  ComplexDiagMatrix (const DiagArray2<U>& a) 
+  ComplexDiagMatrix (const DiagArray2<U>& a)
     : MDiagArray2<Complex> (a) { }
 
   ComplexDiagMatrix& operator = (const ComplexDiagMatrix& a)
     {
       MDiagArray2<Complex>::operator = (a);
       return *this;
     }
 
@@ -86,17 +86,17 @@ public:
   ComplexDiagMatrix& fill (const ComplexRowVector& a);
   ComplexDiagMatrix& fill (const ColumnVector& a, octave_idx_type beg);
   ComplexDiagMatrix& fill (const ComplexColumnVector& a, octave_idx_type beg);
   ComplexDiagMatrix& fill (const RowVector& a, octave_idx_type beg);
   ComplexDiagMatrix& fill (const ComplexRowVector& a, octave_idx_type beg);
 
   ComplexDiagMatrix hermitian (void) const { return MDiagArray2<Complex>::hermitian (std::conj); }
   ComplexDiagMatrix transpose (void) const { return MDiagArray2<Complex>::transpose(); }
-  DiagMatrix abs (void) const; 
+  DiagMatrix abs (void) const;
 
   friend OCTAVE_API ComplexDiagMatrix conj (const ComplexDiagMatrix& a);
 
   // resize is the destructive analog for this one
 
   ComplexMatrix extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const;
 
   // extract row or column i
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -118,27 +118,27 @@ extern "C"
   F77_RET_T
   F77_FUNC (xzdotc, XZDOTC) (const octave_idx_type&, const Complex*,
                              const octave_idx_type&, const Complex*,
                              const octave_idx_type&, Complex&);
 
   F77_RET_T
   F77_FUNC (zsyrk, ZSYRK) (F77_CONST_CHAR_ARG_DECL,
                            F77_CONST_CHAR_ARG_DECL,
-                           const octave_idx_type&, const octave_idx_type&, 
+                           const octave_idx_type&, const octave_idx_type&,
                            const Complex&, const Complex*,
                            const octave_idx_type&, const Complex&,
                            Complex*, const octave_idx_type&
                            F77_CHAR_ARG_LEN_DECL
                            F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zherk, ZHERK) (F77_CONST_CHAR_ARG_DECL,
                            F77_CONST_CHAR_ARG_DECL,
-                           const octave_idx_type&, const octave_idx_type&, 
+                           const octave_idx_type&, const octave_idx_type&,
                            const double&, const Complex*,
                            const octave_idx_type&, const double&, Complex*,
                            const octave_idx_type&
                            F77_CHAR_ARG_LEN_DECL
                            F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zgetrf, ZGETRF) (const octave_idx_type&, const octave_idx_type&,
@@ -156,18 +156,18 @@ extern "C"
   F77_RET_T
   F77_FUNC (zgetri, ZGETRI) (const octave_idx_type&, Complex*,
                              const octave_idx_type&, const octave_idx_type*,
                              Complex*, const octave_idx_type&,
                              octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (zgecon, ZGECON) (F77_CONST_CHAR_ARG_DECL,
-                             const octave_idx_type&, Complex*, 
-                             const octave_idx_type&, const double&, double&, 
+                             const octave_idx_type&, Complex*,
+                             const octave_idx_type&, const double&, double&,
                              Complex*, double*, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zgelsy, ZGELSY) (const octave_idx_type&, const octave_idx_type&,
                              const octave_idx_type&, Complex*,
                              const octave_idx_type&, Complex*,
                              const octave_idx_type&, octave_idx_type*,
@@ -176,17 +176,17 @@ extern "C"
                              octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (zgelsd, ZGELSD) (const octave_idx_type&, const octave_idx_type&,
                              const octave_idx_type&, Complex*,
                              const octave_idx_type&, Complex*,
                              const octave_idx_type&, double*, double&,
                              octave_idx_type&, Complex*,
-                             const octave_idx_type&, double*, 
+                             const octave_idx_type&, double*,
                              octave_idx_type*, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (zpotrf, ZPOTRF) (F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&, Complex*,
                              const octave_idx_type&, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL);
 
@@ -195,45 +195,45 @@ extern "C"
                              const octave_idx_type&, Complex*,
                              const octave_idx_type&, const double&,
                              double&, Complex*, double*, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zpotrs, ZPOTRS) (F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&, const octave_idx_type&,
-                             const Complex*, const octave_idx_type&, Complex*, 
+                             const Complex*, const octave_idx_type&, Complex*,
                              const octave_idx_type&, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (ztrtri, ZTRTRI) (F77_CONST_CHAR_ARG_DECL,
-                             F77_CONST_CHAR_ARG_DECL, 
-                             const octave_idx_type&, const Complex*, 
-                             const octave_idx_type&, octave_idx_type& 
+                             F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, const Complex*,
+                             const octave_idx_type&, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (ztrcon, ZTRCON) (F77_CONST_CHAR_ARG_DECL,
-                             F77_CONST_CHAR_ARG_DECL, 
+                             F77_CONST_CHAR_ARG_DECL,
                              F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&, const Complex*,
                              const octave_idx_type&, double&,
-                             Complex*, double*, octave_idx_type& 
+                             Complex*, double*, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (ztrtrs, ZTRTRS) (F77_CONST_CHAR_ARG_DECL,
                              F77_CONST_CHAR_ARG_DECL,
                              F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&, const octave_idx_type&,
-                             const Complex*, const octave_idx_type&, Complex*, 
+                             const Complex*, const octave_idx_type&, Complex*,
                              const octave_idx_type&, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zlartg, ZLARTG) (const Complex&, const Complex&, double&,
                              Complex&, Complex&);
@@ -1011,42 +1011,42 @@ ComplexMatrix::tinverse (MatrixType &mat
       int typ = mattype.type ();
       char uplo = (typ == MatrixType::Lower ? 'L' : 'U');
       char udiag = 'N';
       retval = *this;
       Complex *tmp_data = retval.fortran_vec ();
 
       F77_XFCN (ztrtri, ZTRTRI, (F77_CONST_CHAR_ARG2 (&uplo, 1),
                                  F77_CONST_CHAR_ARG2 (&udiag, 1),
-                                 nr, tmp_data, nr, info 
+                                 nr, tmp_data, nr, info
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
-      if (info != 0) 
+      if (info != 0)
         info = -1;
-      else if (calc_cond) 
+      else if (calc_cond)
         {
           octave_idx_type ztrcon_info = 0;
           char job = '1';
 
           OCTAVE_LOCAL_BUFFER (Complex, cwork, 2*nr);
           OCTAVE_LOCAL_BUFFER (double, rwork, nr);
 
           F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      F77_CONST_CHAR_ARG2 (&uplo, 1),
                                      F77_CONST_CHAR_ARG2 (&udiag, 1),
-                                     nr, tmp_data, nr, rcon, 
-                                     cwork, rwork, ztrcon_info 
+                                     nr, tmp_data, nr, rcon,
+                                     cwork, rwork, ztrcon_info
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)));
 
-          if (ztrcon_info != 0) 
+          if (ztrcon_info != 0)
             info = -1;
         }
 
       if (info == -1 && ! force)
         retval = *this; // Restore matrix contents.
     }
 
   return retval;
@@ -1071,17 +1071,17 @@ ComplexMatrix::finverse (MatrixType &mat
       retval = *this;
       Complex *tmp_data = retval.fortran_vec ();
 
       Array<Complex> z (dim_vector (1, 1));
       octave_idx_type lwork = -1;
 
       // Query the optimum work array size.
 
-      F77_XFCN (zgetri, ZGETRI, (nc, tmp_data, nr, pipvt, 
+      F77_XFCN (zgetri, ZGETRI, (nc, tmp_data, nr, pipvt,
                                  z.fortran_vec (), lwork, info));
 
       lwork = static_cast<octave_idx_type> (std::real(z(0)));
       lwork = (lwork <  2 *nc ? 2*nc : lwork);
       z.resize (dim_vector (lwork, 1));
       Complex *pz = z.fortran_vec ();
 
       info = 0;
@@ -1090,51 +1090,51 @@ ComplexMatrix::finverse (MatrixType &mat
       double anorm;
       if (calc_cond)
         anorm  = retval.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
       F77_XFCN (zgetrf, ZGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
-      if (info != 0) 
+      if (info != 0)
         info = -1;
-      else if (calc_cond) 
+      else if (calc_cond)
         {
           // Now calculate the condition number for non-singular matrix.
           octave_idx_type zgecon_info = 0;
           char job = '1';
           Array<double> rz (dim_vector (2 * nc, 1));
           double *prz = rz.fortran_vec ();
           F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                     nc, tmp_data, nr, anorm, 
+                                     nc, tmp_data, nr, anorm,
                                      rcon, pz, prz, zgecon_info
                                      F77_CHAR_ARG_LEN (1)));
 
-          if (zgecon_info != 0) 
+          if (zgecon_info != 0)
             info = -1;
         }
 
       if (info == -1 && ! force)
         retval = *this;  // Restore contents.
       else
         {
           octave_idx_type zgetri_info = 0;
 
           F77_XFCN (zgetri, ZGETRI, (nc, tmp_data, nr, pipvt,
                                      pz, lwork, zgetri_info));
 
-          if (zgetri_info != 0) 
+          if (zgetri_info != 0)
             info = -1;
         }
 
       if (info != 0)
         mattype.mark_as_rectangular();
     }
-  
+
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::inverse (MatrixType &mattype, octave_idx_type& info,
                         double& rcon, int force, int calc_cond) const
 {
   int typ = mattype.type (false);
@@ -1234,17 +1234,17 @@ ComplexMatrix::fourier (void) const
     {
       npts = nr;
       nsamples = nc;
     }
 
   const Complex *in (data ());
   Complex *out (retval.fortran_vec ());
 
-  octave_fftw::fft (in, out, npts, nsamples); 
+  octave_fftw::fft (in, out, npts, nsamples);
 
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::ifourier (void) const
 {
   size_t nr = rows ();
@@ -1263,17 +1263,17 @@ ComplexMatrix::ifourier (void) const
     {
       npts = nr;
       nsamples = nc;
     }
 
   const Complex *in (data ());
   Complex *out (retval.fortran_vec ());
 
-  octave_fftw::ifft (in, out, npts, nsamples); 
+  octave_fftw::ifft (in, out, npts, nsamples);
 
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::fourier2d (void) const
 {
   dim_vector dv(rows (), cols ());
@@ -1586,56 +1586,56 @@ ComplexMatrix::determinant (MatrixType& 
 
       if (typ == MatrixType::Unknown)
         typ = mattype.type (*this);
       else if (typ == MatrixType::Rectangular)
         typ = MatrixType::Full;
 
       if (typ == MatrixType::Lower || typ == MatrixType::Upper)
         {
-          for (octave_idx_type i = 0; i < nc; i++) 
+          for (octave_idx_type i = 0; i < nc; i++)
             retval *= elem (i,i);
         }
       else if (typ == MatrixType::Hermitian)
         {
           ComplexMatrix atmp = *this;
           Complex *tmp_data = atmp.fortran_vec ();
 
           info = 0;
           double anorm = 0;
           if (calc_cond) anorm = xnorm (*this, 1);
 
 
           char job = 'L';
-          F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
+          F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                      tmp_data, nr, info
                                      F77_CHAR_ARG_LEN (1)));
 
-          if (info != 0) 
+          if (info != 0)
             {
               rcon = 0.0;
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
-          else 
+          else
             {
               Array<Complex> z (dim_vector (2 * nc, 1));
               Complex *pz = z.fortran_vec ();
               Array<double> rz (dim_vector (nc, 1));
               double *prz = rz.fortran_vec ();
 
               F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                          nr, tmp_data, nr, anorm,
                                          rcon, pz, prz, info
                                          F77_CHAR_ARG_LEN (1)));
 
-              if (info != 0) 
+              if (info != 0)
                 rcon = 0.0;
 
-              for (octave_idx_type i = 0; i < nc; i++) 
+              for (octave_idx_type i = 0; i < nc; i++)
                 retval *= atmp (i,i);
 
               retval = retval.square ();
             }
         }
       else if (typ != MatrixType::Full)
         (*current_liboctave_error_handler) ("det: invalid dense matrix type");
 
@@ -1652,46 +1652,46 @@ ComplexMatrix::determinant (MatrixType& 
           // Calculate the norm of the matrix, for later use.
           double anorm = 0;
           if (calc_cond) anorm = xnorm (*this, 1);
 
           F77_XFCN (zgetrf, ZGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
-          if (info != 0) 
+          if (info != 0)
             {
               info = -1;
               retval = ComplexDET ();
-            } 
-          else 
+            }
+          else
             {
-              if (calc_cond) 
+              if (calc_cond)
                 {
                   // Now calc the condition number for non-singular matrix.
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nc, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> rz (dim_vector (2 * nc, 1));
                   double *prz = rz.fortran_vec ();
 
                   F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                             nc, tmp_data, nr, anorm, 
+                                             nc, tmp_data, nr, anorm,
                                              rcon, pz, prz, info
                                              F77_CHAR_ARG_LEN (1)));
                 }
 
-              if (info != 0) 
+              if (info != 0)
                 {
                   info = -1;
                   retval = ComplexDET ();
-                } 
-              else 
+                }
+              else
                 {
-                  for (octave_idx_type i = 0; i < nc; i++) 
+                  for (octave_idx_type i = 0; i < nc; i++)
                     {
                       Complex c = atmp(i,i);
                       retval *= (ipvt(i) != (i+1)) ? -c : c;
                     }
                 }
             }
         }
     }
@@ -1733,26 +1733,26 @@ ComplexMatrix::rcond (MatrixType &mattyp
           char uplo = 'U';
           char dia = 'N';
 
           Array<Complex> z (dim_vector (2 * nc, 1));
           Complex *pz = z.fortran_vec ();
           Array<double> rz (dim_vector (nc, 1));
           double *prz = rz.fortran_vec ();
 
-          F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
-                                     F77_CONST_CHAR_ARG2 (&uplo, 1), 
-                                     F77_CONST_CHAR_ARG2 (&dia, 1), 
+          F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
+                                     F77_CONST_CHAR_ARG2 (&uplo, 1),
+                                     F77_CONST_CHAR_ARG2 (&dia, 1),
                                      nr, tmp_data, nr, rcon,
                                      pz, prz, info
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)));
 
-          if (info != 0) 
+          if (info != 0)
             rcon = 0;
         }
       else if  (typ == MatrixType::Permuted_Upper)
         (*current_liboctave_error_handler)
           ("permuted triangular matrix not implemented");
       else if (typ == MatrixType::Lower)
         {
           const Complex *tmp_data = fortran_vec ();
@@ -1761,26 +1761,26 @@ ComplexMatrix::rcond (MatrixType &mattyp
           char uplo = 'L';
           char dia = 'N';
 
           Array<Complex> z (dim_vector (2 * nc, 1));
           Complex *pz = z.fortran_vec ();
           Array<double> rz (dim_vector (nc, 1));
           double *prz = rz.fortran_vec ();
 
-          F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
-                                     F77_CONST_CHAR_ARG2 (&uplo, 1), 
-                                     F77_CONST_CHAR_ARG2 (&dia, 1), 
+          F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
+                                     F77_CONST_CHAR_ARG2 (&uplo, 1),
+                                     F77_CONST_CHAR_ARG2 (&dia, 1),
                                      nr, tmp_data, nr, rcon,
                                      pz, prz, info
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)));
 
-          if (info != 0) 
+          if (info != 0)
             rcon = 0.0;
         }
       else if (typ == MatrixType::Permuted_Lower)
         (*current_liboctave_error_handler)
           ("permuted triangular matrix not implemented");
       else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
         {
           double anorm = -1.0;
@@ -1789,40 +1789,40 @@ ComplexMatrix::rcond (MatrixType &mattyp
 
           if (typ == MatrixType::Hermitian)
             {
               octave_idx_type info = 0;
               char job = 'L';
               anorm = atmp.abs().sum().
                 row(static_cast<octave_idx_type>(0)).max();
 
-              F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
+              F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                          tmp_data, nr, info
                                          F77_CHAR_ARG_LEN (1)));
 
-              if (info != 0) 
+              if (info != 0)
                 {
                   rcon = 0.0;
 
                   mattype.mark_as_unsymmetric ();
                   typ = MatrixType::Full;
                 }
-              else 
+              else
                 {
                   Array<Complex> z (dim_vector (2 * nc, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> rz (dim_vector (nc, 1));
                   double *prz = rz.fortran_vec ();
 
                   F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, tmp_data, nr, anorm,
                                              rcon, pz, prz, info
                                              F77_CHAR_ARG_LEN (1)));
 
-                  if (info != 0) 
+                  if (info != 0)
                     rcon = 0.0;
                 }
             }
 
 
           if (typ == MatrixType::Full)
             {
               octave_idx_type info = 0;
@@ -1836,44 +1836,44 @@ ComplexMatrix::rcond (MatrixType &mattyp
 
               Array<Complex> z (dim_vector (2 * nc, 1));
               Complex *pz = z.fortran_vec ();
               Array<double> rz (dim_vector (2 * nc, 1));
               double *prz = rz.fortran_vec ();
 
               F77_XFCN (zgetrf, ZGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
-              if (info != 0) 
-                { 
+              if (info != 0)
+                {
                   rcon = 0.0;
                   mattype.mark_as_rectangular ();
-                } 
-              else 
+                }
+              else
                 {
                   char job = '1';
                   F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                             nc, tmp_data, nr, anorm, 
+                                             nc, tmp_data, nr, anorm,
                                              rcon, pz, prz, info
                                              F77_CHAR_ARG_LEN (1)));
 
-                  if (info != 0) 
+                  if (info != 0)
                     rcon = 0.0;
                 }
             }
         }
       else
         rcon = 0.0;
     }
 
   return rcon;
 }
 
 ComplexMatrix
-ComplexMatrix::utsolve (MatrixType &mattype, const ComplexMatrix& b, 
-                        octave_idx_type& info, double& rcon, 
+ComplexMatrix::utsolve (MatrixType &mattype, const ComplexMatrix& b,
+                        octave_idx_type& info, double& rcon,
                         solve_singularity_handler sing_handler,
                         bool calc_cond, blas_trans_type transt) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
@@ -1908,26 +1908,26 @@ ComplexMatrix::utsolve (MatrixType &matt
                   char uplo = 'U';
                   char dia = 'N';
 
                   Array<Complex> z (dim_vector (2 * nc, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> rz (dim_vector (nc, 1));
                   double *prz = rz.fortran_vec ();
 
-                  F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
-                                             F77_CONST_CHAR_ARG2 (&uplo, 1), 
-                                             F77_CONST_CHAR_ARG2 (&dia, 1), 
+                  F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
+                                             F77_CONST_CHAR_ARG2 (&uplo, 1),
+                                             F77_CONST_CHAR_ARG2 (&dia, 1),
                                              nr, tmp_data, nr, rcon,
                                              pz, prz, info
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)));
 
-                  if (info != 0) 
+                  if (info != 0)
                     info = -2;
 
                   volatile double rcond_plus_one = rcon + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
@@ -1944,37 +1944,37 @@ ComplexMatrix::utsolve (MatrixType &matt
                 {
                   retval = b;
                   Complex *result = retval.fortran_vec ();
 
                   char uplo = 'U';
                   char trans = get_blas_char (transt);
                   char dia = 'N';
 
-                  F77_XFCN (ztrtrs, ZTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
-                                             F77_CONST_CHAR_ARG2 (&trans, 1), 
-                                             F77_CONST_CHAR_ARG2 (&dia, 1), 
+                  F77_XFCN (ztrtrs, ZTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1),
+                                             F77_CONST_CHAR_ARG2 (&trans, 1),
+                                             F77_CONST_CHAR_ARG2 (&dia, 1),
                                              nr, b_nc, tmp_data, nr,
                                              result, nr, info
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)));
                 }
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-ComplexMatrix::ltsolve (MatrixType &mattype, const ComplexMatrix& b, 
-                        octave_idx_type& info, double& rcon, 
+ComplexMatrix::ltsolve (MatrixType &mattype, const ComplexMatrix& b,
+                        octave_idx_type& info, double& rcon,
                         solve_singularity_handler sing_handler,
                         bool calc_cond, blas_trans_type transt) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
@@ -2009,26 +2009,26 @@ ComplexMatrix::ltsolve (MatrixType &matt
                   char uplo = 'L';
                   char dia = 'N';
 
                   Array<Complex> z (dim_vector (2 * nc, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> rz (dim_vector (nc, 1));
                   double *prz = rz.fortran_vec ();
 
-                  F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
-                                             F77_CONST_CHAR_ARG2 (&uplo, 1), 
-                                             F77_CONST_CHAR_ARG2 (&dia, 1), 
+                  F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
+                                             F77_CONST_CHAR_ARG2 (&uplo, 1),
+                                             F77_CONST_CHAR_ARG2 (&dia, 1),
                                              nr, tmp_data, nr, rcon,
                                              pz, prz, info
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)));
 
-                  if (info != 0) 
+                  if (info != 0)
                     info = -2;
 
                   volatile double rcond_plus_one = rcon + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
@@ -2045,36 +2045,36 @@ ComplexMatrix::ltsolve (MatrixType &matt
                 {
                   retval = b;
                   Complex *result = retval.fortran_vec ();
 
                   char uplo = 'L';
                   char trans = get_blas_char (transt);
                   char dia = 'N';
 
-                  F77_XFCN (ztrtrs, ZTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
-                                             F77_CONST_CHAR_ARG2 (&trans, 1), 
-                                             F77_CONST_CHAR_ARG2 (&dia, 1), 
+                  F77_XFCN (ztrtrs, ZTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1),
+                                             F77_CONST_CHAR_ARG2 (&trans, 1),
+                                             F77_CONST_CHAR_ARG2 (&dia, 1),
                                              nr, b_nc, tmp_data, nr,
                                              result, nr, info
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)));
                 }
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-ComplexMatrix::fsolve (MatrixType &mattype, const ComplexMatrix& b, 
+ComplexMatrix::fsolve (MatrixType &mattype, const ComplexMatrix& b,
                        octave_idx_type& info, double& rcon,
                        solve_singularity_handler sing_handler,
                        bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -2083,56 +2083,56 @@ ComplexMatrix::fsolve (MatrixType &matty
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       volatile int typ = mattype.type ();
- 
+
      // Calculate the norm of the matrix, for later use.
       double anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
         {
           info = 0;
           char job = 'L';
           ComplexMatrix atmp = *this;
           Complex *tmp_data = atmp.fortran_vec ();
           anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
-          F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
+          F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                      tmp_data, nr, info
                                      F77_CHAR_ARG_LEN (1)));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
-          if (info != 0) 
+          if (info != 0)
             {
               info = -2;
 
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
-          else 
+          else
             {
               if (calc_cond)
                 {
                   Array<Complex> z (dim_vector (2 * nc, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> rz (dim_vector (nc, 1));
                   double *prz = rz.fortran_vec ();
 
                   F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, tmp_data, nr, anorm,
                                              rcon, pz, prz, info
                                              F77_CHAR_ARG_LEN (1)));
 
-                  if (info != 0) 
+                  if (info != 0)
                     info = -2;
 
                   volatile double rcond_plus_one = rcon + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
@@ -2183,41 +2183,41 @@ ComplexMatrix::fsolve (MatrixType &matty
           // Calculate the norm of the matrix, for later use.
           if (anorm < 0.)
             anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
           F77_XFCN (zgetrf, ZGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
-          if (info != 0) 
-            { 
+          if (info != 0)
+            {
               info = -2;
 
               if (sing_handler)
                 sing_handler (rcon);
               else
                 (*current_liboctave_error_handler)
                   ("matrix singular to machine precision");
 
               mattype.mark_as_rectangular ();
-            } 
-          else 
+            }
+          else
             {
               if (calc_cond)
                 {
-                  // Now calculate the condition number for 
+                  // Now calculate the condition number for
                   // non-singular matrix.
                   char job = '1';
                   F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                             nc, tmp_data, nr, anorm, 
+                                             nc, tmp_data, nr, anorm,
                                              rcon, pz, prz, info
                                              F77_CHAR_ARG_LEN (1)));
 
-                  if (info != 0) 
+                  if (info != 0)
                     info = -2;
 
                   volatile double rcond_plus_one = rcon + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
@@ -2236,84 +2236,84 @@ ComplexMatrix::fsolve (MatrixType &matty
                   Complex *result = retval.fortran_vec ();
 
                   octave_idx_type b_nc = b.cols ();
 
                   char job = 'N';
                   F77_XFCN (zgetrs, ZGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, b_nc, tmp_data, nr,
                                              pipvt, result, b.rows(), info
-                                             F77_CHAR_ARG_LEN (1))); 
+                                             F77_CHAR_ARG_LEN (1)));
                 }
               else
-                mattype.mark_as_rectangular ();             
+                mattype.mark_as_rectangular ();
             }
         }
     }
-  
+
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::solve (MatrixType &typ, const Matrix& b) const
 {
   octave_idx_type info;
   double rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 ComplexMatrix
-ComplexMatrix::solve (MatrixType &typ, const Matrix& b, 
+ComplexMatrix::solve (MatrixType &typ, const Matrix& b,
                       octave_idx_type& info) const
 {
   double rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
                       double& rcon) const
 {
   return solve (typ, b, info, rcon, 0);
 }
 
 ComplexMatrix
-ComplexMatrix::solve (MatrixType &typ, const Matrix& b, octave_idx_type& info, 
+ComplexMatrix::solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
                       double& rcon, solve_singularity_handler sing_handler,
                       bool singular_fallback, blas_trans_type transt) const
 {
   ComplexMatrix tmp (b);
   return solve (typ, tmp, info, rcon, sing_handler, singular_fallback, transt);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (MatrixType &typ, const ComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 ComplexMatrix
-ComplexMatrix::solve (MatrixType &typ, const ComplexMatrix& b, 
+ComplexMatrix::solve (MatrixType &typ, const ComplexMatrix& b,
                       octave_idx_type& info) const
 {
   double rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 ComplexMatrix
-ComplexMatrix::solve (MatrixType &typ, const ComplexMatrix& b, 
+ComplexMatrix::solve (MatrixType &typ, const ComplexMatrix& b,
                       octave_idx_type& info, double& rcon) const
 {
   return solve (typ, b, info, rcon, 0);
 }
 
 ComplexMatrix
-ComplexMatrix::solve (MatrixType &mattype, const ComplexMatrix& b, 
+ComplexMatrix::solve (MatrixType &mattype, const ComplexMatrix& b,
                       octave_idx_type& info, double& rcon,
                       solve_singularity_handler sing_handler,
                       bool singular_fallback, blas_trans_type transt) const
 {
   ComplexMatrix retval;
   int typ = mattype.type ();
 
   if (typ == MatrixType::Unknown)
@@ -2350,48 +2350,48 @@ ComplexColumnVector
 ComplexMatrix::solve (MatrixType &typ, const ColumnVector& b) const
 {
   octave_idx_type info;
   double rcon;
   return solve (typ, ComplexColumnVector (b), info, rcon, 0);
 }
 
 ComplexColumnVector
-ComplexMatrix::solve (MatrixType &typ, const ColumnVector& b, 
+ComplexMatrix::solve (MatrixType &typ, const ColumnVector& b,
                       octave_idx_type& info) const
 {
   double rcon;
   return solve (typ, ComplexColumnVector (b), info, rcon, 0);
 }
 
 ComplexColumnVector
-ComplexMatrix::solve (MatrixType &typ, const ColumnVector& b, 
+ComplexMatrix::solve (MatrixType &typ, const ColumnVector& b,
                       octave_idx_type& info, double& rcon) const
 {
   return solve (typ, ComplexColumnVector (b), info, rcon, 0);
 }
 
 ComplexColumnVector
-ComplexMatrix::solve (MatrixType &typ, const ColumnVector& b, 
+ComplexMatrix::solve (MatrixType &typ, const ColumnVector& b,
                       octave_idx_type& info, double& rcon,
                       solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   return solve (typ, ComplexColumnVector (b), info, rcon, sing_handler, transt);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (MatrixType &typ, const ComplexColumnVector& b) const
 {
   octave_idx_type info;
   double rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 ComplexColumnVector
-ComplexMatrix::solve (MatrixType &typ, const ComplexColumnVector& b, 
+ComplexMatrix::solve (MatrixType &typ, const ComplexColumnVector& b,
                       octave_idx_type& info) const
 {
   double rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (MatrixType &typ, const ComplexColumnVector& b,
@@ -2480,25 +2480,25 @@ ComplexMatrix::solve (const ColumnVector
 ComplexColumnVector
 ComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info) const
 {
   double rcon;
   return solve (ComplexColumnVector (b), info, rcon, 0);
 }
 
 ComplexColumnVector
-ComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info, 
+ComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info,
                       double& rcon) const
 {
   return solve (ComplexColumnVector (b), info, rcon, 0);
 }
 
 ComplexColumnVector
-ComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info, 
-                      double& rcon, 
+ComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info,
+                      double& rcon,
                       solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   return solve (ComplexColumnVector (b), info, rcon, sing_handler, transt);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ComplexColumnVector& b) const
 {
@@ -2583,17 +2583,17 @@ ComplexMatrix
 ComplexMatrix::lssolve (const ComplexMatrix& b, octave_idx_type& info,
                         octave_idx_type& rank) const
 {
   double rcon;
   return lssolve (b, info, rank, rcon);
 }
 
 ComplexMatrix
-ComplexMatrix::lssolve (const ComplexMatrix& b, octave_idx_type& info, 
+ComplexMatrix::lssolve (const ComplexMatrix& b, octave_idx_type& info,
                         octave_idx_type& rank, double& rcon) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nrhs = b.cols ();
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
@@ -2708,17 +2708,17 @@ ComplexMatrix::lssolve (const ComplexMat
             work(0) = lworkaround;
         }
 
       lwork = static_cast<octave_idx_type> (std::real (work(0)));
       work.resize (dim_vector (lwork, 1));
 
       F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, tmp_data, m, pretval,
                                  maxmn, ps, rcon, rank,
-                                 work.fortran_vec (), lwork, 
+                                 work.fortran_vec (), lwork,
                                  prwork, piwork, info));
 
       if (s.elem (0) == 0.0)
         rcon = 0.0;
       else
         rcon = s.elem (minmn - 1) / s.elem (0);
 
       retval.resize (n, nrhs);
@@ -2740,25 +2740,25 @@ ComplexColumnVector
 ComplexMatrix::lssolve (const ColumnVector& b, octave_idx_type& info) const
 {
   octave_idx_type rank;
   double rcon;
   return lssolve (ComplexColumnVector (b), info, rank, rcon);
 }
 
 ComplexColumnVector
-ComplexMatrix::lssolve (const ColumnVector& b, octave_idx_type& info, 
+ComplexMatrix::lssolve (const ColumnVector& b, octave_idx_type& info,
                         octave_idx_type& rank) const
 {
   double rcon;
   return lssolve (ComplexColumnVector (b), info, rank, rcon);
 }
 
 ComplexColumnVector
-ComplexMatrix::lssolve (const ColumnVector& b, octave_idx_type& info, 
+ComplexMatrix::lssolve (const ColumnVector& b, octave_idx_type& info,
                         octave_idx_type& rank, double& rcon) const
 {
   return lssolve (ComplexColumnVector (b), info, rank, rcon);
 }
 
 ComplexColumnVector
 ComplexMatrix::lssolve (const ComplexColumnVector& b) const
 {
@@ -2869,17 +2869,17 @@ ComplexMatrix::lssolve (const ComplexCol
 
       lwork = static_cast<octave_idx_type> (std::real (work(0)));
       work.resize (dim_vector (lwork, 1));
       rwork.resize (dim_vector (static_cast<octave_idx_type> (rwork(0)), 1));
       iwork.resize (dim_vector (iwork(0), 1));
 
       F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, tmp_data, m, pretval,
                                  maxmn, ps, rcon, rank,
-                                 work.fortran_vec (), lwork, 
+                                 work.fortran_vec (), lwork,
                                  prwork, piwork, info));
 
       if (rank < minmn)
         {
           if (s.elem (0) == 0.0)
             rcon = 0.0;
           else
             rcon = s.elem (minmn - 1) / s.elem (0);
@@ -3098,17 +3098,17 @@ ComplexMatrix::any_element_is_inf_or_nan
 bool
 ComplexMatrix::all_elements_are_real (void) const
 {
   return do_mx_check<Complex> (*this, mx_inline_all_real);
 }
 
 // Return nonzero if any element of CM has a non-integer real or
 // imaginary part.  Also extract the largest and smallest (real or
-// imaginary) values and return them in MAX_VAL and MIN_VAL. 
+// imaginary) values and return them in MAX_VAL and MIN_VAL.
 
 bool
 ComplexMatrix::all_integers (double& max_val, double& min_val) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
@@ -3248,17 +3248,17 @@ ComplexMatrix::row_is_real_only (octave_
     {
       if (std::imag (elem (i, j)) != 0.0)
         {
           retval = false;
           break;
         }
     }
 
-  return retval;              
+  return retval;
 }
 
 bool
 ComplexMatrix::column_is_real_only (octave_idx_type j) const
 {
   bool retval = true;
 
   octave_idx_type nr = rows ();
@@ -3267,17 +3267,17 @@ ComplexMatrix::column_is_real_only (octa
     {
       if (std::imag (elem (i, j)) != 0.0)
         {
           retval = false;
           break;
         }
     }
 
-  return retval;              
+  return retval;
 }
 
 ComplexColumnVector
 ComplexMatrix::row_min (void) const
 {
   Array<octave_idx_type> dummy_idx;
   return row_min (dummy_idx);
 }
@@ -3613,17 +3613,17 @@ done:
   return is;
 }
 
 ComplexMatrix
 Givens (const Complex& x, const Complex& y)
 {
   double cc;
   Complex cs, temp_r;
- 
+
   F77_FUNC (zlartg, ZLARTG) (x, y, cc, cs, temp_r);
 
   ComplexMatrix g (2, 2);
 
   g.elem (0, 0) = cc;
   g.elem (1, 1) = cc;
   g.elem (0, 1) = cs;
   g.elem (1, 0) = -conj (cs);
@@ -3639,40 +3639,40 @@ Sylvester (const ComplexMatrix& a, const
 
   // FIXME -- need to check that a, b, and c are all the same
   // size.
 
   // Compute Schur decompositions
 
   ComplexSCHUR as (a, "U");
   ComplexSCHUR bs (b, "U");
-  
+
   // Transform c to new coordinates.
 
   ComplexMatrix ua = as.unitary_matrix ();
   ComplexMatrix sch_a = as.schur_matrix ();
 
   ComplexMatrix ub = bs.unitary_matrix ();
   ComplexMatrix sch_b = bs.schur_matrix ();
-  
+
   ComplexMatrix cx = ua.hermitian () * c * ub;
 
   // Solve the sylvester equation, back-transform, and return the
   // solution.
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type b_nr = b.rows ();
 
   double scale;
   octave_idx_type info;
 
   Complex *pa = sch_a.fortran_vec ();
   Complex *pb = sch_b.fortran_vec ();
   Complex *px = cx.fortran_vec ();
-  
+
   F77_XFCN (ztrsyl, ZTRSYL, (F77_CONST_CHAR_ARG2 ("N", 1),
                              F77_CONST_CHAR_ARG2 ("N", 1),
                              1, a_nr, b_nr, pa, a_nr, pb,
                              b_nr, px, a_nr, scale, info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
   // FIXME -- check info?
@@ -3725,17 +3725,17 @@ static inline char
 get_blas_trans_arg (bool trans, bool conj)
 {
   return trans ? (conj ? 'C' : 'T') : 'N';
 }
 
 // the general GEMM operation
 
 ComplexMatrix
-xgemm (const ComplexMatrix& a, const ComplexMatrix& b, 
+xgemm (const ComplexMatrix& a, const ComplexMatrix& b,
        blas_trans_type transa, blas_trans_type transb)
 {
   ComplexMatrix retval;
 
   bool tra = transa != blas_no_trans, trb = transb != blas_no_trans;
   bool cja = transa == blas_conj_trans, cjb = transb == blas_conj_trans;
 
   octave_idx_type a_nr = tra ? a.cols () : a.rows ();
@@ -4025,18 +4025,18 @@ max (const ComplexMatrix& a, const Compl
               result (i, j) = xmax (a (i, j), b (i, j));
             }
         }
     }
 
   return result;
 }
 
-ComplexMatrix linspace (const ComplexColumnVector& x1, 
-                        const ComplexColumnVector& x2, 
+ComplexMatrix linspace (const ComplexColumnVector& x1,
+                        const ComplexColumnVector& x2,
                         octave_idx_type n)
 
 {
   if (n < 1) n = 1;
 
   octave_idx_type m = x1.length ();
 
   if (x2.length () != m)
@@ -4044,17 +4044,17 @@ ComplexMatrix linspace (const ComplexCol
 
   NoAlias<ComplexMatrix> retval;
 
   retval.clear (m, n);
   for (octave_idx_type i = 0; i < m; i++)
     retval(i, 0) = x1(i);
 
   // The last column is not needed while using delta.
-  Complex *delta = &retval(0, n-1); 
+  Complex *delta = &retval(0, n-1);
   for (octave_idx_type i = 0; i < m; i++)
     delta[i] = (x2(i) - x1(i)) / (n - 1.0);
 
   for (octave_idx_type j = 1; j < n-1; j++)
     for (octave_idx_type i = 0; i < m; i++)
       retval(i, j) = x1(i) + static_cast<double> (j)*delta[i];
 
   for (octave_idx_type i = 0; i < m; i++)
diff --git a/liboctave/CMatrix.h b/liboctave/CMatrix.h
--- a/liboctave/CMatrix.h
+++ b/liboctave/CMatrix.h
@@ -32,33 +32,33 @@ along with Octave; see the file COPYING.
 #include "oct-cmplx.h"
 #include "DET.h"
 
 class
 OCTAVE_API
 ComplexMatrix : public MArray<Complex>
 {
 public:
- 
+
   typedef ComplexColumnVector column_vector_type;
   typedef ComplexRowVector row_vector_type;
 
   typedef void (*solve_singularity_handler) (double rcon);
 
   ComplexMatrix (void) : MArray<Complex> () { }
 
   ComplexMatrix (octave_idx_type r, octave_idx_type c)
     : MArray<Complex> (dim_vector (r, c)) { }
 
   ComplexMatrix (octave_idx_type r, octave_idx_type c, const Complex& val)
     : MArray<Complex> (dim_vector (r, c), val) { }
 
   ComplexMatrix (const dim_vector& dv) : MArray<Complex> (dv.redim (2)) { }
 
-  ComplexMatrix (const dim_vector& dv, const Complex& val) 
+  ComplexMatrix (const dim_vector& dv, const Complex& val)
     : MArray<Complex> (dv.redim (2), val) { }
 
   ComplexMatrix (const ComplexMatrix& a) : MArray<Complex> (a) { }
 
   template <class U>
   ComplexMatrix (const MArray<U>& a) : MArray<Complex> (a.as_matrix ()) { }
 
   template <class U>
@@ -162,142 +162,142 @@ private:
                           double& rcon, int force, int calc_cond) const;
 
   ComplexMatrix finverse (MatrixType &mattype, octave_idx_type& info,
                           double& rcon, int force, int calc_cond) const;
 
 public:
   ComplexMatrix inverse (void) const;
   ComplexMatrix inverse (octave_idx_type& info) const;
-  ComplexMatrix inverse (octave_idx_type& info, double& rcon, int force = 0, 
+  ComplexMatrix inverse (octave_idx_type& info, double& rcon, int force = 0,
                          int calc_cond = 1) const;
 
   ComplexMatrix inverse (MatrixType &mattype) const;
   ComplexMatrix inverse (MatrixType &mattype, octave_idx_type& info) const;
   ComplexMatrix inverse (MatrixType &mattype, octave_idx_type& info,
-                         double& rcon, int force = 0, 
+                         double& rcon, int force = 0,
                          int calc_cond = 1) const;
 
   ComplexMatrix pseudo_inverse (double tol = 0.0) const;
 
   ComplexMatrix fourier (void) const;
   ComplexMatrix ifourier (void) const;
 
   ComplexMatrix fourier2d (void) const;
   ComplexMatrix ifourier2d (void) const;
 
   ComplexDET determinant (void) const;
   ComplexDET determinant (octave_idx_type& info) const;
   ComplexDET determinant (octave_idx_type& info, double& rcon, int calc_cond = 1) const;
-  ComplexDET determinant (MatrixType &mattype, octave_idx_type& info, 
+  ComplexDET determinant (MatrixType &mattype, octave_idx_type& info,
                           double& rcon, int calc_cond = 1) const;
 
   double rcond (void) const;
   double rcond (MatrixType &mattype) const;
 
 private:
   // Upper triangular matrix solvers
   ComplexMatrix utsolve (MatrixType &typ, const ComplexMatrix& b,
-                  octave_idx_type& info, double& rcon, 
+                  octave_idx_type& info, double& rcon,
                   solve_singularity_handler sing_handler,
-                  bool calc_cond = false, 
+                  bool calc_cond = false,
                   blas_trans_type transt = blas_no_trans) const;
 
   // Lower triangular matrix solvers
   ComplexMatrix ltsolve (MatrixType &typ, const ComplexMatrix& b,
-                  octave_idx_type& info, double& rcon, 
+                  octave_idx_type& info, double& rcon,
                   solve_singularity_handler sing_handler,
                   bool calc_cond = false, blas_trans_type transt = blas_no_trans) const;
 
   // Full matrix solvers (umfpack/cholesky)
   ComplexMatrix fsolve (MatrixType &typ, const ComplexMatrix& b,
-                 octave_idx_type& info, double& rcon, 
+                 octave_idx_type& info, double& rcon,
                  solve_singularity_handler sing_handler,
                  bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
   ComplexMatrix solve (MatrixType &typ, const Matrix& b) const;
-  ComplexMatrix solve (MatrixType &typ, const Matrix& b, 
+  ComplexMatrix solve (MatrixType &typ, const Matrix& b,
                        octave_idx_type& info) const;
-  ComplexMatrix solve (MatrixType &typ, const Matrix& b, 
+  ComplexMatrix solve (MatrixType &typ, const Matrix& b,
                        octave_idx_type& info, double& rcon) const;
   ComplexMatrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
                        double& rcon, solve_singularity_handler sing_handler,
-                       bool singular_fallback = true, 
+                       bool singular_fallback = true,
                        blas_trans_type transt = blas_no_trans) const;
 
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b) const;
-  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
+  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b,
                        octave_idx_type& info) const;
-  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
+  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b,
                        octave_idx_type& info, double& rcon) const;
-  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
+  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b,
                        octave_idx_type& info, double& rcon,
                        solve_singularity_handler sing_handler,
-                       bool singular_fallback = true, 
+                       bool singular_fallback = true,
                        blas_trans_type transt = blas_no_trans) const;
 
   ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b) const;
-  ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b, 
+  ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b,
                              octave_idx_type& info) const;
-  ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b, 
+  ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b,
                              octave_idx_type& info, double& rcon) const;
-  ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b, 
+  ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b,
                              octave_idx_type& info, double& rcon,
-                             solve_singularity_handler sing_handler, 
+                             solve_singularity_handler sing_handler,
                              blas_trans_type transt = blas_no_trans) const;
 
-  ComplexColumnVector solve (MatrixType &typ, 
+  ComplexColumnVector solve (MatrixType &typ,
                              const ComplexColumnVector& b) const;
-  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b, 
+  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b,
                              octave_idx_type& info) const;
-  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b, 
+  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b,
                              octave_idx_type& info, double& rcon) const;
-  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b, 
+  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b,
                              octave_idx_type& info, double& rcon,
-                             solve_singularity_handler sing_handler, 
+                             solve_singularity_handler sing_handler,
                              blas_trans_type transt = blas_no_trans) const;
 
   // Generic interface to solver with probing of type
   ComplexMatrix solve (const Matrix& b) const;
   ComplexMatrix solve (const Matrix& b, octave_idx_type& info) const;
   ComplexMatrix solve (const Matrix& b, octave_idx_type& info, double& rcon) const;
   ComplexMatrix solve (const Matrix& b, octave_idx_type& info, double& rcon,
-                       solve_singularity_handler sing_handler, 
+                       solve_singularity_handler sing_handler,
                        blas_trans_type transt = blas_no_trans) const;
 
   ComplexMatrix solve (const ComplexMatrix& b) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, double& rcon) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, double& rcon,
-                       solve_singularity_handler sing_handler, 
+                       solve_singularity_handler sing_handler,
                        blas_trans_type transt = blas_no_trans) const;
 
   ComplexColumnVector solve (const ColumnVector& b) const;
   ComplexColumnVector solve (const ColumnVector& b, octave_idx_type& info) const;
   ComplexColumnVector solve (const ColumnVector& b, octave_idx_type& info,
                              double& rcon) const;
   ComplexColumnVector solve (const ColumnVector& b, octave_idx_type& info, double& rcon,
-                             solve_singularity_handler sing_handler, 
+                             solve_singularity_handler sing_handler,
                              blas_trans_type transt = blas_no_trans) const;
 
   ComplexColumnVector solve (const ComplexColumnVector& b) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
                              double& rcon) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
-                             double& rcon, solve_singularity_handler sing_handler, 
+                             double& rcon, solve_singularity_handler sing_handler,
                              blas_trans_type transt = blas_no_trans) const;
 
   ComplexMatrix lssolve (const Matrix& b) const;
   ComplexMatrix lssolve (const Matrix& b, octave_idx_type& info) const;
-  ComplexMatrix lssolve (const Matrix& b, octave_idx_type& info, 
+  ComplexMatrix lssolve (const Matrix& b, octave_idx_type& info,
                          octave_idx_type& rank) const;
-  ComplexMatrix lssolve (const Matrix& b, octave_idx_type& info, 
+  ComplexMatrix lssolve (const Matrix& b, octave_idx_type& info,
                          octave_idx_type& rank, double& rcon) const;
 
   ComplexMatrix lssolve (const ComplexMatrix& b) const;
   ComplexMatrix lssolve (const ComplexMatrix& b, octave_idx_type& info) const;
   ComplexMatrix lssolve (const ComplexMatrix& b, octave_idx_type& info,
                          octave_idx_type& rank) const;
   ComplexMatrix lssolve (const ComplexMatrix& b, octave_idx_type& info,
                          octave_idx_type& rank, double& rcon) const;
@@ -358,17 +358,17 @@ public:
   ComplexMatrix diag (octave_idx_type k = 0) const;
 
   bool row_is_real_only (octave_idx_type) const;
   bool column_is_real_only (octave_idx_type) const;
 
   ComplexColumnVector row_min (void) const;
   ComplexColumnVector row_max (void) const;
 
-  ComplexColumnVector row_min (Array<octave_idx_type>& index) const; 
+  ComplexColumnVector row_min (Array<octave_idx_type>& index) const;
   ComplexColumnVector row_max (Array<octave_idx_type>& index) const;
 
   ComplexRowVector column_min (void) const;
   ComplexRowVector column_max (void) const;
 
   ComplexRowVector column_min (Array<octave_idx_type>& index) const;
   ComplexRowVector column_max (Array<octave_idx_type>& index) const;
 
@@ -395,35 +395,35 @@ extern OCTAVE_API ComplexMatrix
 operator * (const ComplexColumnVector& a, const ComplexRowVector& b);
 
 extern OCTAVE_API ComplexMatrix
 Givens (const Complex&, const Complex&);
 
 extern OCTAVE_API ComplexMatrix
 Sylvester (const ComplexMatrix&, const ComplexMatrix&, const ComplexMatrix&);
 
-extern OCTAVE_API ComplexMatrix 
+extern OCTAVE_API ComplexMatrix
 xgemm (const ComplexMatrix& a, const ComplexMatrix& b,
-       blas_trans_type transa = blas_no_trans, 
+       blas_trans_type transa = blas_no_trans,
        blas_trans_type transb = blas_no_trans);
 
 extern OCTAVE_API ComplexMatrix operator * (const Matrix&,        const ComplexMatrix&);
 extern OCTAVE_API ComplexMatrix operator * (const ComplexMatrix&, const Matrix&);
 extern OCTAVE_API ComplexMatrix operator * (const ComplexMatrix&, const ComplexMatrix&);
 
 extern OCTAVE_API ComplexMatrix min (const Complex& c, const ComplexMatrix& m);
 extern OCTAVE_API ComplexMatrix min (const ComplexMatrix& m, const Complex& c);
 extern OCTAVE_API ComplexMatrix min (const ComplexMatrix& a, const ComplexMatrix& b);
 
 extern OCTAVE_API ComplexMatrix max (const Complex& c, const ComplexMatrix& m);
 extern OCTAVE_API ComplexMatrix max (const ComplexMatrix& m, const Complex& c);
 extern OCTAVE_API ComplexMatrix max (const ComplexMatrix& a, const ComplexMatrix& b);
 
-extern OCTAVE_API ComplexMatrix linspace (const ComplexColumnVector& x1, 
-                                          const ComplexColumnVector& x2, 
+extern OCTAVE_API ComplexMatrix linspace (const ComplexColumnVector& x1,
+                                          const ComplexColumnVector& x2,
                                           octave_idx_type n);
 
 
 MS_CMP_OP_DECLS (ComplexMatrix, Complex, OCTAVE_API)
 MS_BOOL_OP_DECLS (ComplexMatrix, Complex, OCTAVE_API)
 
 SM_CMP_OP_DECLS (Complex, ComplexMatrix, OCTAVE_API)
 SM_BOOL_OP_DECLS (Complex, ComplexMatrix, OCTAVE_API)
diff --git a/liboctave/CNDArray.cc b/liboctave/CNDArray.cc
--- a/liboctave/CNDArray.cc
+++ b/liboctave/CNDArray.cc
@@ -74,17 +74,17 @@ ComplexNDArray::fourier (int dim) const
   octave_idx_type dist = (stride == 1 ? n : 1);
 
   const Complex *in (fortran_vec ());
   ComplexNDArray retval (dv);
   Complex *out (retval.fortran_vec ());
 
   // Need to be careful here about the distance between fft's
   for (octave_idx_type k = 0; k < nloop; k++)
-    octave_fftw::fft (in + k * stride * n, out + k * stride * n, 
+    octave_fftw::fft (in + k * stride * n, out + k * stride * n,
                       n, howmany, stride, dist);
 
   return retval;
 }
 
 ComplexNDArray
 ComplexNDArray::ifourier (int dim) const
 {
@@ -105,17 +105,17 @@ ComplexNDArray::ifourier (int dim) const
   octave_idx_type dist = (stride == 1 ? n : 1);
 
   const Complex *in (fortran_vec ());
   ComplexNDArray retval (dv);
   Complex *out (retval.fortran_vec ());
 
   // Need to be careful here about the distance between fft's
   for (octave_idx_type k = 0; k < nloop; k++)
-    octave_fftw::ifft (in + k * stride * n, out + k * stride * n, 
+    octave_fftw::ifft (in + k * stride * n, out + k * stride * n,
                       n, howmany, stride, dist);
 
   return retval;
 }
 
 ComplexNDArray
 ComplexNDArray::fourier2d (void) const
 {
@@ -314,17 +314,17 @@ ComplexNDArray::fourier2d (void) const
       octave_idx_type npts = dv2(i);
       octave_idx_type nn = 4*npts+15;
       Array<Complex> wsave (dim_vector (nn, 1));
       Complex *pwsave = wsave.fortran_vec ();
       Array<Complex> row (dim_vector (npts, 1));
       Complex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany : 
+      howmany = (stride == 1 ? howmany :
                  (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
@@ -362,17 +362,17 @@ ComplexNDArray::ifourier2d (void) const
       octave_idx_type npts = dv2(i);
       octave_idx_type nn = 4*npts+15;
       Array<Complex> wsave (dim_vector (nn, 1));
       Complex *pwsave = wsave.fortran_vec ();
       Array<Complex> row (dim_vector (npts, 1));
       Complex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany : 
+      howmany = (stride == 1 ? howmany :
                  (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
@@ -410,17 +410,17 @@ ComplexNDArray::fourierNd (void) const
       octave_idx_type npts = dv(i);
       octave_idx_type nn = 4*npts+15;
       Array<Complex> wsave (dim_vector (nn, 1));
       Complex *pwsave = wsave.fortran_vec ();
       Array<Complex> row (dim_vector (npts, 1));
       Complex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany : 
+      howmany = (stride == 1 ? howmany :
                  (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
@@ -457,17 +457,17 @@ ComplexNDArray::ifourierNd (void) const
       octave_idx_type npts = dv(i);
       octave_idx_type nn = 4*npts+15;
       Array<Complex> wsave (dim_vector (nn, 1));
       Complex *pwsave = wsave.fortran_vec ();
       Array<Complex> row (dim_vector (npts, 1));
       Complex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany : 
+      howmany = (stride == 1 ? howmany :
                  (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
@@ -524,30 +524,30 @@ ComplexNDArray::any_element_is_inf_or_na
 bool
 ComplexNDArray::all_elements_are_real (void) const
 {
   return do_mx_check<Complex> (*this, mx_inline_all_real);
 }
 
 // Return nonzero if any element of CM has a non-integer real or
 // imaginary part.  Also extract the largest and smallest (real or
-// imaginary) values and return them in MAX_VAL and MIN_VAL. 
+// imaginary) values and return them in MAX_VAL and MIN_VAL.
 
 bool
 ComplexNDArray::all_integers (double& max_val, double& min_val) const
 {
   octave_idx_type nel = nelem ();
 
   if (nel > 0)
     {
       Complex val = elem (0);
 
       double r_val = std::real (val);
       double i_val = std::imag (val);
-      
+
       max_val = r_val;
       min_val = r_val;
 
       if (i_val > max_val)
         max_val = i_val;
 
       if (i_val < max_val)
         min_val = i_val;
@@ -762,50 +762,50 @@ conj (const ComplexNDArray& a)
 {
   return do_mx_unary_map<Complex, Complex, std::conj> (a);
 }
 
 ComplexNDArray&
 ComplexNDArray::insert (const NDArray& a, octave_idx_type r, octave_idx_type c)
 {
   dim_vector a_dv = a.dims ();
-  
+
   int n = a_dv.length ();
-  
+
   if (n == dimensions.length ())
     {
       Array<octave_idx_type> a_ra_idx (dim_vector (a_dv.length (), 1), 0);
-      
+
       a_ra_idx.elem (0) = r;
       a_ra_idx.elem (1) = c;
-      
+
       for (int i = 0; i < n; i++)
         {
           if (a_ra_idx (i) < 0 || (a_ra_idx (i) + a_dv (i)) > dimensions (i))
             {
               (*current_liboctave_error_handler)
                 ("Array<T>::insert: range error for insert");
               return *this;
             }
         }
-      
+
       a_ra_idx.elem (0) = 0;
       a_ra_idx.elem (1) = 0;
-      
+
       octave_idx_type n_elt = a.numel ();
-      
+
       // IS make_unique () NECCESSARY HERE??
 
       for (octave_idx_type i = 0; i < n_elt; i++)
         {
           Array<octave_idx_type> ra_idx = a_ra_idx;
-          
+
           ra_idx.elem (0) = a_ra_idx (0) + r;
           ra_idx.elem (1) = a_ra_idx (1) + c;
-          
+
           elem (ra_idx) = a.elem (a_ra_idx);
 
           increment_index (a_ra_idx, a_dv);
         }
     }
   else
     (*current_liboctave_error_handler)
       ("Array<T>::insert: invalid indexing operation");
@@ -844,17 +844,17 @@ ComplexNDArray::matrix_value (void) cons
 void
 ComplexNDArray::increment_index (Array<octave_idx_type>& ra_idx,
                                  const dim_vector& dimensions,
                                  int start_dimension)
 {
   ::increment_index (ra_idx, dimensions, start_dimension);
 }
 
-octave_idx_type 
+octave_idx_type
 ComplexNDArray::compute_index (Array<octave_idx_type>& ra_idx,
                                const dim_vector& dimensions)
 {
   return ::compute_index (ra_idx, dimensions);
 }
 
 ComplexNDArray
 ComplexNDArray::diag (octave_idx_type k) const
diff --git a/liboctave/CNDArray.h b/liboctave/CNDArray.h
--- a/liboctave/CNDArray.h
+++ b/liboctave/CNDArray.h
@@ -39,28 +39,28 @@ public:
   typedef ComplexMatrix matrix_type;
 
   ComplexNDArray (void) : MArray<Complex> () { }
 
   ComplexNDArray (const dim_vector& dv) : MArray<Complex> (dv) { }
 
   ComplexNDArray (const dim_vector& dv, const Complex& val)
     : MArray<Complex> (dv, val) { }
-  
+
   ComplexNDArray (const ComplexNDArray& a) : MArray<Complex> (a) { }
 
   ComplexNDArray (const ComplexMatrix& a) : MArray<Complex> (a) { }
 
   template <class U>
   ComplexNDArray (const MArray<U>& a) : MArray<Complex> (a) { }
 
   template <class U>
   ComplexNDArray (const Array<U>& a) : MArray<Complex> (a) { }
 
-  ComplexNDArray (const charNDArray&); 
+  ComplexNDArray (const charNDArray&);
 
   ComplexNDArray& operator = (const ComplexNDArray& a)
     {
       MArray<Complex>::operator = (a);
       return *this;
     }
 
   // unary operations
@@ -97,17 +97,17 @@ public:
   ComplexNDArray cummin (int dim = -1) const;
   ComplexNDArray cummin (Array<octave_idx_type>& index, int dim = -1) const;
 
   ComplexNDArray diff (octave_idx_type order = 1, int dim = -1) const;
 
   ComplexNDArray& insert (const NDArray& a, octave_idx_type r, octave_idx_type c);
   ComplexNDArray& insert (const ComplexNDArray& a, octave_idx_type r, octave_idx_type c);
   ComplexNDArray& insert (const ComplexNDArray& a, const Array<octave_idx_type>& ra_idx);
-  
+
   NDArray abs (void) const;
   boolNDArray isnan (void) const;
   boolNDArray isinf (void) const;
   boolNDArray isfinite (void) const;
 
   friend OCTAVE_API ComplexNDArray conj (const ComplexNDArray& a);
 
   ComplexNDArray fourier (int dim = 1) const;
@@ -137,20 +137,20 @@ public:
 
   static Complex resize_fill_value (void) { return Complex (0.0, 0.0); }
 
   //  bool all_elements_are_real (void) const;
   //  bool all_integers (double& max_val, double& min_val) const;
 
   ComplexNDArray diag (octave_idx_type k = 0) const;
 
-  ComplexNDArray& changesign (void) 
-    { 
-      MArray<Complex>::changesign (); 
-      return *this; 
+  ComplexNDArray& changesign (void)
+    {
+      MArray<Complex>::changesign ();
+      return *this;
     }
 
 };
 
 extern OCTAVE_API ComplexNDArray conj (const ComplexNDArray& a);
 
 MINMAX_DECLS (ComplexNDArray, Complex, OCTAVE_API)
 
diff --git a/liboctave/CSparse.cc b/liboctave/CSparse.cc
--- a/liboctave/CSparse.cc
+++ b/liboctave/CSparse.cc
@@ -256,17 +256,17 @@ SparseComplexMatrix::max (int dim) const
 SparseComplexMatrix
 SparseComplexMatrix::max (Array<octave_idx_type>& idx_arg, int dim) const
 {
   SparseComplexMatrix result;
   dim_vector dv = dims ();
 
   if (dv.numel () == 0 || dim >= dv.length ())
     return result;
- 
+
   if (dim < 0)
     dim = dv.first_non_singleton ();
 
   octave_idx_type nr = dv(0);
   octave_idx_type nc = dv(1);
 
   if (dim == 0)
     {
@@ -342,17 +342,17 @@ SparseComplexMatrix::max (Array<octave_i
               continue;
             bool found = false;
             for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
               if (ridx(k) == i)
                 {
                   found = true;
                   break;
                 }
-            
+
             if (!found)
               idx_arg.elem(i) = j;
 
           }
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
@@ -411,17 +411,17 @@ SparseComplexMatrix::min (int dim) const
 SparseComplexMatrix
 SparseComplexMatrix::min (Array<octave_idx_type>& idx_arg, int dim) const
 {
   SparseComplexMatrix result;
   dim_vector dv = dims ();
 
   if (dv.numel () == 0 || dim >= dv.length ())
     return result;
- 
+
   if (dim < 0)
     dim = dv.first_non_singleton ();
 
   octave_idx_type nr = dv(0);
   octave_idx_type nc = dv(1);
 
   if (dim == 0)
     {
@@ -497,17 +497,17 @@ SparseComplexMatrix::min (Array<octave_i
               continue;
             bool found = false;
             for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
               if (ridx(k) == i)
                 {
                   found = true;
                   break;
                 }
-            
+
             if (!found)
               idx_arg.elem(i) = j;
 
           }
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
@@ -551,17 +551,17 @@ SparseComplexMatrix::min (Array<octave_i
                 }
             }
         }
     }
 
   return result;
 }
 
-ComplexRowVector 
+ComplexRowVector
 SparseComplexMatrix::row (octave_idx_type i) const
 {
   octave_idx_type nc = columns ();
   ComplexRowVector retval (nc, 0);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type k = cidx (j); k < cidx (j+1); k++)
       {
@@ -570,17 +570,17 @@ SparseComplexMatrix::row (octave_idx_typ
             retval(j) = data (k);
             break;
           }
       }
 
   return retval;
 }
 
-ComplexColumnVector 
+ComplexColumnVector
 SparseComplexMatrix::column (octave_idx_type i) const
 {
   octave_idx_type nr = rows ();
   ComplexColumnVector retval (nr);
 
   for (octave_idx_type k = cidx (i); k < cidx (i+1); k++)
     retval(ridx (k)) = data (k);
 
@@ -613,17 +613,17 @@ SparseComplexMatrix::insert (const Spars
 SparseComplexMatrix&
 SparseComplexMatrix::insert (const SparseComplexMatrix& a, const Array<octave_idx_type>& indx)
 {
   MSparse<Complex>::insert (a, indx);
   return *this;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::concat (const SparseComplexMatrix& rb, 
+SparseComplexMatrix::concat (const SparseComplexMatrix& rb,
                              const Array<octave_idx_type>& ra_idx)
 {
   // Don't use numel to avoid all possiblity of an overflow
   if (rb.rows () > 0 && rb.cols () > 0)
     insert (rb, ra_idx(0), ra_idx(1));
   return *this;
 }
 
@@ -715,18 +715,18 @@ SparseComplexMatrix::inverse (MatrixType
 
 SparseComplexMatrix
 SparseComplexMatrix::inverse (MatrixType& mattype, octave_idx_type& info) const
 {
   double rcond;
   return inverse (mattype, info, rcond, 0, 0);
 }
 
-SparseComplexMatrix 
-SparseComplexMatrix::dinverse (MatrixType &mattyp, octave_idx_type& info, 
+SparseComplexMatrix
+SparseComplexMatrix::dinverse (MatrixType &mattyp, octave_idx_type& info,
                         double& rcond, const bool,
                         const bool calccond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   info = 0;
@@ -741,23 +741,23 @@ SparseComplexMatrix::dinverse (MatrixTyp
 
       if (typ == MatrixType::Diagonal ||
           typ == MatrixType::Permuted_Diagonal)
         {
           if (typ == MatrixType::Permuted_Diagonal)
             retval = transpose();
           else
             retval = *this;
-              
+
           // Force make_unique to be called
           Complex *v = retval.data();
 
           if (calccond)
             {
-              double dmax = 0., dmin = octave_Inf; 
+              double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nr; i++)
                 {
                   double tmp = std::abs(v[i]);
                   if (tmp > dmax)
                     dmax = tmp;
                   if (tmp < dmin)
                     dmin = tmp;
                 }
@@ -769,18 +769,18 @@ SparseComplexMatrix::dinverse (MatrixTyp
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
-SparseComplexMatrix 
-SparseComplexMatrix::tinverse (MatrixType &mattyp, octave_idx_type& info, 
+SparseComplexMatrix
+SparseComplexMatrix::tinverse (MatrixType &mattyp, octave_idx_type& info,
                                double& rcond, const bool,
                                const bool calccond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   info = 0;
@@ -819,73 +819,73 @@ SparseComplexMatrix::tinverse (MatrixTyp
               octave_idx_type nz2 = nz;
               retval = SparseComplexMatrix (nr, nc, nz2);
 
               for (octave_idx_type i = 0; i < nr; i++)
                 {
                   octave_quit ();
                   // place the 1 in the identity position
                   octave_idx_type cx_colstart = cx;
-          
+
                   if (cx == nz2)
                     {
                       nz2 *= 2;
                       retval.change_capacity (nz2);
                     }
 
                   retval.xcidx(i) = cx;
                   retval.xridx(cx) = i;
                   retval.xdata(cx) = 1.0;
                   cx++;
 
                   // iterate accross columns of input matrix
-                  for (octave_idx_type j = i+1; j < nr; j++) 
+                  for (octave_idx_type j = i+1; j < nr; j++)
                     {
                       Complex v = 0.;
                       // iterate to calculate sum
                       octave_idx_type colXp = retval.xcidx(i);
                       octave_idx_type colUp = cidx(j);
                       octave_idx_type rpX, rpU;
 
                       if (cidx(j) == cidx(j+1))
                         {
-                          (*current_liboctave_error_handler) 
+                          (*current_liboctave_error_handler)
                             ("division by zero");
                           goto inverse_singular;
                         }
 
                       do
                         {
                           octave_quit ();
                           rpX = retval.xridx(colXp);
                           rpU = ridx(colUp);
 
-                          if (rpX < rpU) 
+                          if (rpX < rpU)
                             colXp++;
-                          else if (rpX > rpU) 
+                          else if (rpX > rpU)
                             colUp++;
-                          else 
+                          else
                             {
                               v -= retval.xdata(colXp) * data(colUp);
                               colXp++;
                               colUp++;
                             }
-                        } while ((rpX<j) && (rpU<j) && 
+                        } while ((rpX<j) && (rpU<j) &&
                                  (colXp<cx) && (colUp<nz));
 
 
                       // get A(m,m)
                       if (typ == MatrixType::Upper)
                         colUp = cidx(j+1) - 1;
                       else
                         colUp = cidx(j);
                       Complex pivot = data(colUp);
-                      if (pivot == 0. || ridx(colUp) != j) 
+                      if (pivot == 0. || ridx(colUp) != j)
                         {
-                          (*current_liboctave_error_handler) 
+                          (*current_liboctave_error_handler)
                             ("division by zero");
                           goto inverse_singular;
                         }
 
                       if (v != 0.)
                         {
                           if (cx == nz2)
                             {
@@ -901,17 +901,17 @@ SparseComplexMatrix::tinverse (MatrixTyp
 
                   // get A(m,m)
                   octave_idx_type colUp;
                   if (typ == MatrixType::Upper)
                     colUp = cidx(i+1) - 1;
                   else
                     colUp = cidx(i);
                   Complex pivot = data(colUp);
-                  if (pivot == 0. || ridx(colUp) != i) 
+                  if (pivot == 0. || ridx(colUp) != i)
                     {
                       (*current_liboctave_error_handler) ("division by zero");
                       goto inverse_singular;
                     }
 
                   if (pivot != 1.0)
                     for (octave_idx_type j = cx_colstart; j < cx; j++)
                       retval.xdata(j) /= pivot;
@@ -950,55 +950,55 @@ SparseComplexMatrix::tinverse (MatrixTyp
 
                   for (octave_idx_type j = 0; j < nr; j++)
                     work[j] = 0.;
 
                   // place the 1 in the identity position
                   work[iidx] = 1.0;
 
                   // iterate accross columns of input matrix
-                  for (octave_idx_type j = iidx+1; j < nr; j++) 
+                  for (octave_idx_type j = iidx+1; j < nr; j++)
                     {
                       Complex v = 0.;
                       octave_idx_type jidx = perm[j];
                       // iterate to calculate sum
-                      for (octave_idx_type k = cidx(jidx); 
+                      for (octave_idx_type k = cidx(jidx);
                            k < cidx(jidx+1); k++)
                         {
                           octave_quit ();
                           v -= work[ridx(k)] * data(k);
                         }
 
                       // get A(m,m)
                       Complex pivot;
                       if (typ == MatrixType::Permuted_Upper)
                         pivot = data(cidx(jidx+1) - 1);
                       else
                         pivot = data(cidx(jidx));
-                      if (pivot == 0.) 
+                      if (pivot == 0.)
                         {
-                          (*current_liboctave_error_handler) 
+                          (*current_liboctave_error_handler)
                             ("division by zero");
                           goto inverse_singular;
                         }
 
                       work[j] = v / pivot;
                     }
 
                   // get A(m,m)
                   octave_idx_type colUp;
                   if (typ == MatrixType::Permuted_Upper)
                     colUp = cidx(perm[iidx]+1) - 1;
                   else
-                    colUp = cidx(perm[iidx]);             
+                    colUp = cidx(perm[iidx]);
 
                   Complex pivot = data(colUp);
                   if (pivot == 0.)
                     {
-                      (*current_liboctave_error_handler) 
+                      (*current_liboctave_error_handler)
                         ("division by zero");
                       goto inverse_singular;
                     }
 
                   octave_idx_type new_cx = cx;
                   for (octave_idx_type j = iidx; j < nr; j++)
                     if (work[j] != 0.0)
                       {
@@ -1027,52 +1027,52 @@ SparseComplexMatrix::tinverse (MatrixTyp
             }
 
           if (calccond)
             {
               // Calculate the 1-norm of inverse matrix for rcond calculation
               for (octave_idx_type j = 0; j < nr; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = retval.cidx(j); 
+                  for (octave_idx_type i = retval.cidx(j);
                        i < retval.cidx(j+1); i++)
                     atmp += std::abs(retval.data(i));
                   if (atmp > ainvnorm)
                     ainvnorm = atmp;
                 }
 
-              rcond = 1. / ainvnorm / anorm;     
+              rcond = 1. / ainvnorm / anorm;
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 
  inverse_singular:
   return SparseComplexMatrix();
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::inverse (MatrixType& mattype, octave_idx_type& info, 
+SparseComplexMatrix::inverse (MatrixType& mattype, octave_idx_type& info,
                               double& rcond, int, int calc_cond) const
 {
   int typ = mattype.type (false);
   SparseComplexMatrix ret;
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     ret = dinverse (mattype, info, rcond, true, calc_cond);
   else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     ret = tinverse (mattype, info, rcond, true, calc_cond).transpose();
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
-    { 
+    {
       MatrixType newtype = mattype.transpose();
       ret = transpose().tinverse (newtype, info, rcond, true, calc_cond);
     }
   else
     {
       if (mattype.is_hermitian())
         {
           MatrixType tmp_typ (MatrixType::Upper);
@@ -1164,39 +1164,39 @@ SparseComplexMatrix::determinant (octave
           Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
         }
 
       // Set whether we are allowed to modify Q or not
       tmp = octave_sparse_params::get_key ("autoamd");
       if (!xisnan (tmp))
         Control (UMFPACK_FIXQ) = tmp;
 
-      // Turn-off UMFPACK scaling for LU 
+      // Turn-off UMFPACK scaling for LU
       Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
 
       UMFPACK_ZNAME (report_control) (control);
 
       const octave_idx_type *Ap = cidx ();
       const octave_idx_type *Ai = ridx ();
       const Complex *Ax = data ();
 
-      UMFPACK_ZNAME (report_matrix) (nr, nc, Ap, Ai, 
-                                     reinterpret_cast<const double *> (Ax), 
+      UMFPACK_ZNAME (report_matrix) (nr, nc, Ap, Ai,
+                                     reinterpret_cast<const double *> (Ax),
                                      0, 1, control);
 
       void *Symbolic;
       Matrix Info (1, UMFPACK_INFO);
       double *info = Info.fortran_vec ();
-      int status = UMFPACK_ZNAME (qsymbolic) 
-        (nr, nc, Ap, Ai, reinterpret_cast<const double *> (Ax), 0, 
+      int status = UMFPACK_ZNAME (qsymbolic)
+        (nr, nc, Ap, Ai, reinterpret_cast<const double *> (Ax), 0,
          0, &Symbolic, control, info);
 
       if (status < 0)
         {
-          (*current_liboctave_error_handler) 
+          (*current_liboctave_error_handler)
             ("SparseComplexMatrix::determinant symbolic factorization failed");
 
           UMFPACK_ZNAME (report_status) (control, status);
           UMFPACK_ZNAME (report_info) (control, info);
 
           UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
         }
       else
@@ -1209,17 +1209,17 @@ SparseComplexMatrix::determinant (octave
                                        reinterpret_cast<const double *> (Ax),
                                        0, Symbolic, &Numeric, control, info) ;
           UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
 
           rcond = Info (UMFPACK_RCOND);
 
           if (status < 0)
             {
-              (*current_liboctave_error_handler) 
+              (*current_liboctave_error_handler)
                 ("SparseComplexMatrix::determinant numeric factorization failed");
 
               UMFPACK_ZNAME (report_status) (control, status);
               UMFPACK_ZNAME (report_info) (control, info);
 
               UMFPACK_ZNAME (free_numeric) (&Numeric);
             }
           else
@@ -1228,39 +1228,39 @@ SparseComplexMatrix::determinant (octave
 
               double c10[2], e10;
 
               status = UMFPACK_ZNAME (get_determinant) (c10, 0, &e10,
                                                         Numeric, info);
 
               if (status < 0)
                 {
-                  (*current_liboctave_error_handler) 
+                  (*current_liboctave_error_handler)
                     ("SparseComplexMatrix::determinant error calculating determinant");
-                  
+
                   UMFPACK_ZNAME (report_status) (control, status);
                   UMFPACK_ZNAME (report_info) (control, info);
                 }
               else
                 retval = ComplexDET (Complex (c10[0], c10[1]), e10, 10);
-                  
+
               UMFPACK_ZNAME (free_numeric) (&Numeric);
             }
         }
     }
 #else
   (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::dsolve (MatrixType &mattype, const Matrix& b,
-                             octave_idx_type& err, double& rcond, 
+                             octave_idx_type& err, double& rcond,
                              solve_singularity_handler, bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
@@ -1284,20 +1284,20 @@ SparseComplexMatrix::dsolve (MatrixType 
             for (octave_idx_type j = 0; j < b.cols(); j++)
                 for (octave_idx_type i = 0; i < nm; i++)
                   retval(i,j) = b(i,j) / data (i);
           else
             for (octave_idx_type j = 0; j < b.cols(); j++)
               for (octave_idx_type k = 0; k < nc; k++)
                 for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
                   retval(k,j) = b(ridx(i),j) / data (i);
-            
+
           if (calc_cond)
             {
-              double dmax = 0., dmin = octave_Inf; 
+              double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nm; i++)
                 {
                   double tmp = std::abs(data(i));
                   if (tmp > dmax)
                     dmax = tmp;
                   if (tmp < dmin)
                     dmin = tmp;
                 }
@@ -1310,17 +1310,17 @@ SparseComplexMatrix::dsolve (MatrixType 
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::dsolve (MatrixType &mattype, const SparseMatrix& b,
-                             octave_idx_type& err, double& rcond, 
+                             octave_idx_type& err, double& rcond,
                              solve_singularity_handler,
                              bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
@@ -1375,20 +1375,20 @@ SparseComplexMatrix::dsolve (MatrixType 
                       if (found)
                         {
                           retval.xridx (ii) = l;
                           retval.xdata (ii++) = b.data(k) / data (i);
                         }
                     }
                 retval.xcidx(j+1) = ii;
               }
-            
+
           if (calc_cond)
             {
-              double dmax = 0., dmin = octave_Inf; 
+              double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nm; i++)
                 {
                   double tmp = std::abs(data(i));
                   if (tmp > dmax)
                     dmax = tmp;
                   if (tmp < dmin)
                     dmin = tmp;
                 }
@@ -1401,17 +1401,17 @@ SparseComplexMatrix::dsolve (MatrixType 
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::dsolve (MatrixType &mattype, const ComplexMatrix& b,
-                             octave_idx_type& err, double& rcond, 
+                             octave_idx_type& err, double& rcond,
                              solve_singularity_handler,
                              bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
@@ -1436,20 +1436,20 @@ SparseComplexMatrix::dsolve (MatrixType 
             for (octave_idx_type j = 0; j < b.cols(); j++)
               for (octave_idx_type i = 0; i < nm; i++)
                 retval(i,j) = b(i,j) / data (i);
           else
             for (octave_idx_type j = 0; j < b.cols(); j++)
               for (octave_idx_type k = 0; k < nc; k++)
                 for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
                   retval(k,j) = b(ridx(i),j) / data (i);
-            
+
           if (calc_cond)
             {
-              double dmax = 0., dmin = octave_Inf; 
+              double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nr; i++)
                 {
                   double tmp = std::abs(data(i));
                   if (tmp > dmax)
                     dmax = tmp;
                   if (tmp < dmin)
                     dmin = tmp;
                 }
@@ -1462,17 +1462,17 @@ SparseComplexMatrix::dsolve (MatrixType 
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::dsolve (MatrixType &mattype, const SparseComplexMatrix& b,
-                             octave_idx_type& err, double& rcond, 
+                             octave_idx_type& err, double& rcond,
                              solve_singularity_handler,
                              bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
@@ -1527,20 +1527,20 @@ SparseComplexMatrix::dsolve (MatrixType 
                       if (found)
                         {
                           retval.xridx (ii) = l;
                           retval.xdata (ii++) = b.data(k) / data (i);
                         }
                     }
                 retval.xcidx(j+1) = ii;
               }
-            
+
           if (calc_cond)
             {
-              double dmax = 0., dmin = octave_Inf; 
+              double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nm; i++)
                 {
                   double tmp = std::abs(data(i));
                   if (tmp > dmax)
                     dmax = tmp;
                   if (tmp < dmin)
                     dmin = tmp;
                 }
@@ -1620,21 +1620,21 @@ SparseComplexMatrix::utsolve (MatrixType
 
                       if (work[k] != 0.)
                         {
                           if (ridx(cidx(kidx+1)-1) != k ||
                               data(cidx(kidx+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
-                            }                       
+                            }
 
                           Complex tmp = work[k] / data(cidx(kidx+1)-1);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(kidx); 
+                          for (octave_idx_type i = cidx(kidx);
                                i < cidx(kidx+1)-1; i++)
                             {
                               octave_idx_type iidx = ridx(i);
                               work[iidx] = work[iidx] - tmp * data(i);
                             }
                         }
                     }
 
@@ -1655,17 +1655,17 @@ SparseComplexMatrix::utsolve (MatrixType
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           octave_idx_type iidx = perm[k];
 
                           if (work[k] != 0.)
                             {
                               Complex tmp = work[k] / data(cidx(iidx+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(iidx); 
+                              for (octave_idx_type i = cidx(iidx);
                                    i < cidx(iidx+1)-1; i++)
                                 {
                                   octave_idx_type idx2 = ridx(i);
                                   work[idx2] = work[idx2] - tmp * data(i);
                                 }
                             }
                         }
                       double atmp = 0;
@@ -1696,17 +1696,17 @@ SparseComplexMatrix::utsolve (MatrixType
                     {
                       if (work[k] != 0.)
                         {
                           if (ridx(cidx(k+1)-1) != k ||
                               data(cidx(k+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
-                            }                       
+                            }
 
                           Complex tmp = work[k] / data(cidx(k+1)-1);
                           work[k] = tmp;
                           for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
                             {
                               octave_idx_type iidx = ridx(i);
                               work[iidx] = work[iidx] - tmp * data(i);
                             }
@@ -1728,17 +1728,17 @@ SparseComplexMatrix::utsolve (MatrixType
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           if (work[k] != 0.)
                             {
                               Complex tmp = work[k] / data(cidx(k+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k); 
+                              for (octave_idx_type i = cidx(k);
                                    i < cidx(k+1)-1; i++)
                                 {
                                   octave_idx_type iidx = ridx(i);
                                   work[iidx] = work[iidx] - tmp * data(i);
                                 }
                             }
                         }
                       double atmp = 0;
@@ -1789,17 +1789,17 @@ SparseComplexMatrix::utsolve (MatrixType
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::utsolve (MatrixType &mattype, const SparseMatrix& b,
-                              octave_idx_type& err, double& rcond, 
+                              octave_idx_type& err, double& rcond,
                               solve_singularity_handler sing_handler,
                               bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
@@ -1865,21 +1865,21 @@ SparseComplexMatrix::utsolve (MatrixType
 
                       if (work[k] != 0.)
                         {
                           if (ridx(cidx(kidx+1)-1) != k ||
                               data(cidx(kidx+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
-                            }                       
+                            }
 
                           Complex tmp = work[k] / data(cidx(kidx+1)-1);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(kidx); 
+                          for (octave_idx_type i = cidx(kidx);
                                i < cidx(kidx+1)-1; i++)
                             {
                               octave_idx_type iidx = ridx(i);
                               work[iidx] = work[iidx] - tmp * data(i);
                             }
                         }
                     }
 
@@ -1922,17 +1922,17 @@ SparseComplexMatrix::utsolve (MatrixType
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           octave_idx_type iidx = perm[k];
 
                           if (work[k] != 0.)
                             {
                               Complex tmp = work[k] / data(cidx(iidx+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(iidx); 
+                              for (octave_idx_type i = cidx(iidx);
                                    i < cidx(iidx+1)-1; i++)
                                 {
                                   octave_idx_type idx2 = ridx(i);
                                   work[idx2] = work[idx2] - tmp * data(i);
                                 }
                             }
                         }
                       double atmp = 0;
@@ -1962,17 +1962,17 @@ SparseComplexMatrix::utsolve (MatrixType
                     {
                       if (work[k] != 0.)
                         {
                           if (ridx(cidx(k+1)-1) != k ||
                               data(cidx(k+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
-                            }                       
+                            }
 
                           Complex tmp = work[k] / data(cidx(k+1)-1);
                           work[k] = tmp;
                           for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
                             {
                               octave_idx_type iidx = ridx(i);
                               work[iidx] = work[iidx] - tmp * data(i);
                             }
@@ -2016,17 +2016,17 @@ SparseComplexMatrix::utsolve (MatrixType
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           if (work[k] != 0.)
                             {
                               Complex tmp = work[k] / data(cidx(k+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k); 
+                              for (octave_idx_type i = cidx(k);
                                    i < cidx(k+1)-1; i++)
                                 {
                                   octave_idx_type iidx = ridx(i);
                                   work[iidx] = work[iidx] - tmp * data(i);
                                 }
                             }
                         }
                       double atmp = 0;
@@ -2076,17 +2076,17 @@ SparseComplexMatrix::utsolve (MatrixType
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::utsolve (MatrixType &mattype, const ComplexMatrix& b,
-                              octave_idx_type& err, double& rcond, 
+                              octave_idx_type& err, double& rcond,
                               solve_singularity_handler sing_handler,
                               bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
@@ -2097,17 +2097,17 @@ SparseComplexMatrix::utsolve (MatrixType
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
-      
+
       if (typ == MatrixType::Permuted_Upper ||
           typ == MatrixType::Upper)
         {
           double anorm = 0.;
           double ainvnorm = 0.;
           octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
@@ -2143,21 +2143,21 @@ SparseComplexMatrix::utsolve (MatrixType
 
                       if (work[k] != 0.)
                         {
                           if (ridx(cidx(kidx+1)-1) != k ||
                               data(cidx(kidx+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
-                            }                       
+                            }
 
                           Complex tmp = work[k] / data(cidx(kidx+1)-1);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(kidx); 
+                          for (octave_idx_type i = cidx(kidx);
                                i < cidx(kidx+1)-1; i++)
                             {
                               octave_idx_type iidx = ridx(i);
                               work[iidx] = work[iidx] - tmp * data(i);
                             }
                         }
                     }
 
@@ -2178,17 +2178,17 @@ SparseComplexMatrix::utsolve (MatrixType
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           octave_idx_type iidx = perm[k];
 
                           if (work[k] != 0.)
                             {
                               Complex tmp = work[k] / data(cidx(iidx+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(iidx); 
+                              for (octave_idx_type i = cidx(iidx);
                                    i < cidx(iidx+1)-1; i++)
                                 {
                                   octave_idx_type idx2 = ridx(i);
                                   work[idx2] = work[idx2] - tmp * data(i);
                                 }
                             }
                         }
                       double atmp = 0;
@@ -2219,17 +2219,17 @@ SparseComplexMatrix::utsolve (MatrixType
                     {
                       if (work[k] != 0.)
                         {
                           if (ridx(cidx(k+1)-1) != k ||
                               data(cidx(k+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
-                            }                       
+                            }
 
                           Complex tmp = work[k] / data(cidx(k+1)-1);
                           work[k] = tmp;
                           for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
                             {
                               octave_idx_type iidx = ridx(i);
                               work[iidx] = work[iidx] - tmp * data(i);
                             }
@@ -2251,17 +2251,17 @@ SparseComplexMatrix::utsolve (MatrixType
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           if (work[k] != 0.)
                             {
                               Complex tmp = work[k] / data(cidx(k+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k); 
+                              for (octave_idx_type i = cidx(k);
                                    i < cidx(k+1)-1; i++)
                                 {
                                   octave_idx_type iidx = ridx(i);
                                   work[iidx] = work[iidx] - tmp * data(i);
                                 }
                             }
                         }
                       double atmp = 0;
@@ -2312,17 +2312,17 @@ SparseComplexMatrix::utsolve (MatrixType
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::utsolve (MatrixType &mattype, const SparseComplexMatrix& b,
-                              octave_idx_type& err, double& rcond, 
+                              octave_idx_type& err, double& rcond,
                               solve_singularity_handler sing_handler,
                               bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
@@ -2333,17 +2333,17 @@ SparseComplexMatrix::utsolve (MatrixType
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
-      
+
       if (typ == MatrixType::Permuted_Upper ||
           typ == MatrixType::Upper)
         {
           double anorm = 0.;
           double ainvnorm = 0.;
           rcond = 1.;
 
           if (calc_cond)
@@ -2388,21 +2388,21 @@ SparseComplexMatrix::utsolve (MatrixType
 
                       if (work[k] != 0.)
                         {
                           if (ridx(cidx(kidx+1)-1) != k ||
                               data(cidx(kidx+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
-                            }                       
+                            }
 
                           Complex tmp = work[k] / data(cidx(kidx+1)-1);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(kidx); 
+                          for (octave_idx_type i = cidx(kidx);
                                i < cidx(kidx+1)-1; i++)
                             {
                               octave_idx_type iidx = ridx(i);
                               work[iidx] = work[iidx] - tmp * data(i);
                             }
                         }
                     }
 
@@ -2445,17 +2445,17 @@ SparseComplexMatrix::utsolve (MatrixType
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           octave_idx_type iidx = perm[k];
 
                           if (work[k] != 0.)
                             {
                               Complex tmp = work[k] / data(cidx(iidx+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(iidx); 
+                              for (octave_idx_type i = cidx(iidx);
                                    i < cidx(iidx+1)-1; i++)
                                 {
                                   octave_idx_type idx2 = ridx(i);
                                   work[idx2] = work[idx2] - tmp * data(i);
                                 }
                             }
                         }
                       double atmp = 0;
@@ -2485,17 +2485,17 @@ SparseComplexMatrix::utsolve (MatrixType
                     {
                       if (work[k] != 0.)
                         {
                           if (ridx(cidx(k+1)-1) != k ||
                               data(cidx(k+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
-                            }                       
+                            }
 
                           Complex tmp = work[k] / data(cidx(k+1)-1);
                           work[k] = tmp;
                           for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
                             {
                               octave_idx_type iidx = ridx(i);
                               work[iidx] = work[iidx] - tmp * data(i);
                             }
@@ -2539,17 +2539,17 @@ SparseComplexMatrix::utsolve (MatrixType
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           if (work[k] != 0.)
                             {
                               Complex tmp = work[k] / data(cidx(k+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k); 
+                              for (octave_idx_type i = cidx(k);
                                    i < cidx(k+1)-1; i++)
                                 {
                                   octave_idx_type iidx = ridx(i);
                                   work[iidx] = work[iidx] - tmp * data(i);
                                 }
                             }
                         }
                       double atmp = 0;
@@ -2599,18 +2599,18 @@ SparseComplexMatrix::utsolve (MatrixType
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::ltsolve (MatrixType &mattype, const Matrix& b, 
-                              octave_idx_type& err, double& rcond, 
+SparseComplexMatrix::ltsolve (MatrixType &mattype, const Matrix& b,
+                              octave_idx_type& err, double& rcond,
                               solve_singularity_handler sing_handler,
                               bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
@@ -2621,17 +2621,17 @@ SparseComplexMatrix::ltsolve (MatrixType
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
-      
+
       if (typ == MatrixType::Permuted_Lower ||
           typ == MatrixType::Lower)
         {
           double anorm = 0.;
           double ainvnorm = 0.;
           octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
@@ -2674,17 +2674,17 @@ SparseComplexMatrix::ltsolve (MatrixType
                                 minr = perm[ridx(i)];
                                 mini = i;
                               }
 
                           if (minr != k || data (mini) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
-                            }                       
+                            }
 
                           Complex tmp = work[k] / data(mini);
                           work[k] = tmp;
                           for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
                             {
                               if (i == mini)
                                 continue;
 
@@ -2710,27 +2710,27 @@ SparseComplexMatrix::ltsolve (MatrixType
 
                       for (octave_idx_type k = 0; k < nc; k++)
                         {
                           if (work[k] != 0.)
                             {
                               octave_idx_type minr = nr;
                               octave_idx_type mini = 0;
 
-                              for (octave_idx_type i = cidx(k); 
+                              for (octave_idx_type i = cidx(k);
                                    i < cidx(k+1); i++)
                                 if (perm[ridx(i)] < minr)
                                   {
                                     minr = perm[ridx(i)];
                                     mini = i;
                                   }
 
                               Complex tmp = work[k] / data(mini);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k); 
+                              for (octave_idx_type i = cidx(k);
                                    i < cidx(k+1); i++)
                                 {
                                   if (i == mini)
                                     continue;
 
                                   octave_idx_type iidx = perm[ridx(i)];
                                   work[iidx] = work[iidx] - tmp * data(i);
                                 }
@@ -2764,17 +2764,17 @@ SparseComplexMatrix::ltsolve (MatrixType
                     {
                       if (work[k] != 0.)
                         {
                           if (ridx(cidx(k)) != k ||
                               data(cidx(k)) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
-                            }                       
+                            }
 
                           Complex tmp = work[k] / data(cidx(k));
                           work[k] = tmp;
                           for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
                             {
                               octave_idx_type iidx = ridx(i);
                               work[iidx] = work[iidx] - tmp * data(i);
                             }
@@ -2796,17 +2796,17 @@ SparseComplexMatrix::ltsolve (MatrixType
 
                       for (octave_idx_type k = j; k < nc; k++)
                         {
 
                           if (work[k] != 0.)
                             {
                               Complex tmp = work[k] / data(cidx(k));
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k)+1; 
+                              for (octave_idx_type i = cidx(k)+1;
                                    i < cidx(k+1); i++)
                                 {
                                   octave_idx_type iidx = ridx(i);
                                   work[iidx] = work[iidx] - tmp * data(i);
                                 }
                             }
                         }
                       double atmp = 0;
@@ -2855,18 +2855,18 @@ SparseComplexMatrix::ltsolve (MatrixType
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::ltsolve (MatrixType &mattype, const SparseMatrix& b, 
-                              octave_idx_type& err, double& rcond, 
+SparseComplexMatrix::ltsolve (MatrixType &mattype, const SparseMatrix& b,
+                              octave_idx_type& err, double& rcond,
                               solve_singularity_handler sing_handler,
                               bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
@@ -2878,17 +2878,17 @@ SparseComplexMatrix::ltsolve (MatrixType
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
-      
+
       if (typ == MatrixType::Permuted_Lower ||
           typ == MatrixType::Lower)
         {
           double anorm = 0.;
           double ainvnorm = 0.;
           rcond = 1.;
 
           if (calc_cond)
@@ -2936,17 +2936,17 @@ SparseComplexMatrix::ltsolve (MatrixType
                                 minr = perm[ridx(i)];
                                 mini = i;
                               }
 
                           if (minr != k || data (mini) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
-                            }                       
+                            }
 
                           Complex tmp = work[k] / data(mini);
                           work[k] = tmp;
                           for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
                             {
                               if (i == mini)
                                 continue;
 
@@ -2994,27 +2994,27 @@ SparseComplexMatrix::ltsolve (MatrixType
 
                       for (octave_idx_type k = 0; k < nc; k++)
                         {
                           if (work[k] != 0.)
                             {
                               octave_idx_type minr = nr;
                               octave_idx_type mini = 0;
 
-                              for (octave_idx_type i = cidx(k); 
+                              for (octave_idx_type i = cidx(k);
                                    i < cidx(k+1); i++)
                                 if (perm[ridx(i)] < minr)
                                   {
                                     minr = perm[ridx(i)];
                                     mini = i;
                                   }
 
                               Complex tmp = work[k] / data(mini);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k); 
+                              for (octave_idx_type i = cidx(k);
                                    i < cidx(k+1); i++)
                                 {
                                   if (i == mini)
                                     continue;
 
                                   octave_idx_type iidx = perm[ridx(i)];
                                   work[iidx] = work[iidx] - tmp * data(i);
                                 }
@@ -3048,17 +3048,17 @@ SparseComplexMatrix::ltsolve (MatrixType
                     {
                       if (work[k] != 0.)
                         {
                           if (ridx(cidx(k)) != k ||
                               data(cidx(k)) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
-                            }                       
+                            }
 
                           Complex tmp = work[k] / data(cidx(k));
                           work[k] = tmp;
                           for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
                             {
                               octave_idx_type iidx = ridx(i);
                               work[iidx] = work[iidx] - tmp * data(i);
                             }
@@ -3103,17 +3103,17 @@ SparseComplexMatrix::ltsolve (MatrixType
 
                       for (octave_idx_type k = j; k < nc; k++)
                         {
 
                           if (work[k] != 0.)
                             {
                               Complex tmp = work[k] / data(cidx(k));
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k)+1; 
+                              for (octave_idx_type i = cidx(k)+1;
                                    i < cidx(k+1); i++)
                                 {
                                   octave_idx_type iidx = ridx(i);
                                   work[iidx] = work[iidx] - tmp * data(i);
                                 }
                             }
                         }
                       double atmp = 0;
@@ -3185,17 +3185,17 @@ SparseComplexMatrix::ltsolve (MatrixType
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
-      
+
       if (typ == MatrixType::Permuted_Lower ||
           typ == MatrixType::Lower)
         {
           double anorm = 0.;
           double ainvnorm = 0.;
           octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
@@ -3238,17 +3238,17 @@ SparseComplexMatrix::ltsolve (MatrixType
                                 minr = perm[ridx(i)];
                                 mini = i;
                               }
 
                           if (minr != k || data (mini) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
-                            }                       
+                            }
 
                           Complex tmp = work[k] / data(mini);
                           work[k] = tmp;
                           for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
                             {
                               if (i == mini)
                                 continue;
 
@@ -3274,27 +3274,27 @@ SparseComplexMatrix::ltsolve (MatrixType
 
                       for (octave_idx_type k = 0; k < nc; k++)
                         {
                           if (work[k] != 0.)
                             {
                               octave_idx_type minr = nr;
                               octave_idx_type mini = 0;
 
-                              for (octave_idx_type i = cidx(k); 
+                              for (octave_idx_type i = cidx(k);
                                    i < cidx(k+1); i++)
                                 if (perm[ridx(i)] < minr)
                                   {
                                     minr = perm[ridx(i)];
                                     mini = i;
                                   }
 
                               Complex tmp = work[k] / data(mini);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k); 
+                              for (octave_idx_type i = cidx(k);
                                    i < cidx(k+1); i++)
                                 {
                                   if (i == mini)
                                     continue;
 
                                   octave_idx_type iidx = perm[ridx(i)];
                                   work[iidx] = work[iidx] - tmp * data(i);
                                 }
@@ -3330,17 +3330,17 @@ SparseComplexMatrix::ltsolve (MatrixType
                     {
                       if (work[k] != 0.)
                         {
                           if (ridx(cidx(k)) != k ||
                               data(cidx(k)) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
-                            }                       
+                            }
 
                           Complex tmp = work[k] / data(cidx(k));
                           work[k] = tmp;
                           for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
                             {
                               octave_idx_type iidx = ridx(i);
                               work[iidx] = work[iidx] - tmp * data(i);
                             }
@@ -3363,17 +3363,17 @@ SparseComplexMatrix::ltsolve (MatrixType
 
                       for (octave_idx_type k = j; k < nc; k++)
                         {
 
                           if (work[k] != 0.)
                             {
                               Complex tmp = work[k] / data(cidx(k));
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k)+1; 
+                              for (octave_idx_type i = cidx(k)+1;
                                    i < cidx(k+1); i++)
                                 {
                                   octave_idx_type iidx = ridx(i);
                                   work[iidx] = work[iidx] - tmp * data(i);
                                 }
                             }
                         }
                       double atmp = 0;
@@ -3424,17 +3424,17 @@ SparseComplexMatrix::ltsolve (MatrixType
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::ltsolve (MatrixType &mattype, const SparseComplexMatrix& b,
-                              octave_idx_type& err, double& rcond, 
+                              octave_idx_type& err, double& rcond,
                               solve_singularity_handler sing_handler,
                               bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
@@ -3445,17 +3445,17 @@ SparseComplexMatrix::ltsolve (MatrixType
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
-      
+
       if (typ == MatrixType::Permuted_Lower ||
           typ == MatrixType::Lower)
         {
           double anorm = 0.;
           double ainvnorm = 0.;
           rcond = 1.;
 
           if (calc_cond)
@@ -3503,17 +3503,17 @@ SparseComplexMatrix::ltsolve (MatrixType
                                 minr = perm[ridx(i)];
                                 mini = i;
                               }
 
                           if (minr != k || data (mini) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
-                            }                       
+                            }
 
                           Complex tmp = work[k] / data(mini);
                           work[k] = tmp;
                           for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
                             {
                               if (i == mini)
                                 continue;
 
@@ -3561,27 +3561,27 @@ SparseComplexMatrix::ltsolve (MatrixType
 
                       for (octave_idx_type k = 0; k < nc; k++)
                         {
                           if (work[k] != 0.)
                             {
                               octave_idx_type minr = nr;
                               octave_idx_type mini = 0;
 
-                              for (octave_idx_type i = cidx(k); 
+                              for (octave_idx_type i = cidx(k);
                                    i < cidx(k+1); i++)
                                 if (perm[ridx(i)] < minr)
                                   {
                                     minr = perm[ridx(i)];
                                     mini = i;
                                   }
 
                               Complex tmp = work[k] / data(mini);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k); 
+                              for (octave_idx_type i = cidx(k);
                                    i < cidx(k+1); i++)
                                 {
                                   if (i == mini)
                                     continue;
 
                                   octave_idx_type iidx = perm[ridx(i)];
                                   work[iidx] = work[iidx] - tmp * data(i);
                                 }
@@ -3615,17 +3615,17 @@ SparseComplexMatrix::ltsolve (MatrixType
                     {
                       if (work[k] != 0.)
                         {
                           if (ridx(cidx(k)) != k ||
                               data(cidx(k)) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
-                            }                       
+                            }
 
                           Complex tmp = work[k] / data(cidx(k));
                           work[k] = tmp;
                           for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
                             {
                               octave_idx_type iidx = ridx(i);
                               work[iidx] = work[iidx] - tmp * data(i);
                             }
@@ -3670,17 +3670,17 @@ SparseComplexMatrix::ltsolve (MatrixType
 
                       for (octave_idx_type k = j; k < nc; k++)
                         {
 
                           if (work[k] != 0.)
                             {
                               Complex tmp = work[k] / data(cidx(k));
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k)+1; 
+                              for (octave_idx_type i = cidx(k)+1;
                                    i < cidx(k+1); i++)
                                 {
                                   octave_idx_type iidx = ridx(i);
                                   work[iidx] = work[iidx] - tmp * data(i);
                                 }
                             }
                         }
                       double atmp = 0;
@@ -3747,24 +3747,24 @@ SparseComplexMatrix::trisolve (MatrixTyp
   err = 0;
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else if (calc_cond)
-    (*current_liboctave_error_handler) 
+    (*current_liboctave_error_handler)
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
-      
+
       if (typ == MatrixType::Tridiagonal_Hermitian)
         {
           OCTAVE_LOCAL_BUFFER (double, D, nr);
           OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
@@ -3790,31 +3790,31 @@ SparseComplexMatrix::trisolve (MatrixTyp
                 for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
                   {
                     if (ridx(i) == j)
                       D[j] = std::real(data(i));
                     else if (ridx(i) == j + 1)
                       DL[j] = data(i);
                   }
             }
-              
+
           octave_idx_type b_nc = b.cols();
           retval = ComplexMatrix (b);
           Complex *result = retval.fortran_vec ();
 
-          F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, DL, result, 
+          F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, DL, result,
                                    b.rows(), err));
 
           if (err != 0)
             {
               err = 0;
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Tridiagonal;
             }
-          else 
+          else
             rcond = 1.;
         }
 
       if (typ == MatrixType::Tridiagonal)
         {
           OCTAVE_LOCAL_BUFFER (Complex, DU, nr - 1);
           OCTAVE_LOCAL_BUFFER (Complex, D, nr);
           OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
@@ -3852,70 +3852,70 @@ SparseComplexMatrix::trisolve (MatrixTyp
                       DU[j-1] = data(i);
                   }
             }
 
           octave_idx_type b_nc = b.cols();
           retval = ComplexMatrix (b);
           Complex *result = retval.fortran_vec ();
 
-          F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, DL, D, DU, result, 
+          F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, DL, D, DU, result,
                                    b.rows(), err));
 
           if (err != 0)
             {
               rcond = 0.;
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
                 (*current_liboctave_error_handler)
                   ("matrix singular to machine precision");
 
-            } 
-          else 
+            }
+          else
             rcond = 1.;
         }
       else if (typ != MatrixType::Tridiagonal_Hermitian)
                (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::trisolve (MatrixType &mattype, const SparseMatrix& b,
-                               octave_idx_type& err, double& rcond, 
+                               octave_idx_type& err, double& rcond,
                                solve_singularity_handler sing_handler,
                                bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || b.cols () == 0)
     retval = SparseComplexMatrix (nc, b.cols ());
   else if (calc_cond)
-    (*current_liboctave_error_handler) 
+    (*current_liboctave_error_handler)
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
-      
+
       // Note can't treat symmetric case as there is no dpttrf function
       if (typ == MatrixType::Tridiagonal ||
           typ == MatrixType::Tridiagonal_Hermitian)
         {
           OCTAVE_LOCAL_BUFFER (Complex, DU2, nr - 2);
           OCTAVE_LOCAL_BUFFER (Complex, DU, nr - 1);
           OCTAVE_LOCAL_BUFFER (Complex, D, nr);
           OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
@@ -3953,32 +3953,32 @@ SparseComplexMatrix::trisolve (MatrixTyp
                       DL[j] = data(i);
                     else if (ridx(i) == j - 1)
                       DU[j-1] = data(i);
                   }
             }
 
           F77_XFCN (zgttrf, ZGTTRF, (nr, DL, D, DU, DU2, pipvt, err));
 
-          if (err != 0) 
+          if (err != 0)
             {
               err = -2;
               rcond = 0.0;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
                 (*current_liboctave_error_handler)
                   ("matrix singular to machine precision");
 
-            } 
-          else 
+            }
+          else
             {
               char job = 'N';
               volatile octave_idx_type x_nz = b.nnz ();
               octave_idx_type b_nc = b.cols ();
               retval = SparseComplexMatrix (nr, b_nc, x_nz);
               retval.xcidx(0) = 0;
               volatile octave_idx_type ii = 0;
               rcond = 1.0;
@@ -3987,23 +3987,23 @@ SparseComplexMatrix::trisolve (MatrixTyp
 
               for (volatile octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nr; i++)
                     work[i] = 0.;
                   for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
                     work[b.ridx(i)] = b.data(i);
 
-                  F77_XFCN (zgttrs, ZGTTRS, 
+                  F77_XFCN (zgttrs, ZGTTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, 1, DL, D, DU, DU2, pipvt, 
+                             nr, 1, DL, D, DU, DU2, pipvt,
                              work, b.rows (), err
                              F77_CHAR_ARG_LEN (1)));
 
-                  // Count non-zeros in work vector and adjust 
+                  // Count non-zeros in work vector and adjust
                   // space in retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nr; i++)
                     if (work[i] != 0.)
                       new_nnz++;
 
                   if (ii + new_nnz > x_nz)
                     {
@@ -4029,40 +4029,40 @@ SparseComplexMatrix::trisolve (MatrixTyp
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::trisolve (MatrixType &mattype, const ComplexMatrix& b,
-                               octave_idx_type& err, double& rcond, 
+                               octave_idx_type& err, double& rcond,
                                solve_singularity_handler sing_handler,
                                bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else if (calc_cond)
-    (*current_liboctave_error_handler) 
+    (*current_liboctave_error_handler)
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
-      
+
       if (typ == MatrixType::Tridiagonal_Hermitian)
         {
           OCTAVE_LOCAL_BUFFER (double, D, nr);
           OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
@@ -4095,18 +4095,18 @@ SparseComplexMatrix::trisolve (MatrixTyp
             }
 
           octave_idx_type b_nr = b.rows ();
           octave_idx_type b_nc = b.cols();
           rcond = 1.;
 
           retval = ComplexMatrix (b);
           Complex *result = retval.fortran_vec ();
-                  
-          F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, DL, result, 
+
+          F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, DL, result,
                                    b_nr, err));
 
           if (err != 0)
             {
               err = 0;
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Tridiagonal;
             }
@@ -4153,25 +4153,25 @@ SparseComplexMatrix::trisolve (MatrixTyp
             }
 
           octave_idx_type b_nr = b.rows();
           octave_idx_type b_nc = b.cols();
           rcond = 1.;
 
           retval = ComplexMatrix (b);
           Complex *result = retval.fortran_vec ();
-              
-          F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, DL, D, DU, result, 
+
+          F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, DL, D, DU, result,
                                    b_nr, err));
 
           if (err != 0)
             {
               rcond = 0.;
               err = -2;
-                      
+
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
                 (*current_liboctave_error_handler)
                   ("matrix singular to machine precision");
@@ -4180,42 +4180,42 @@ SparseComplexMatrix::trisolve (MatrixTyp
       else if (typ != MatrixType::Tridiagonal_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::trisolve (MatrixType &mattype, 
-                               const SparseComplexMatrix& b, 
-                               octave_idx_type& err, double& rcond, 
+SparseComplexMatrix::trisolve (MatrixType &mattype,
+                               const SparseComplexMatrix& b,
+                               octave_idx_type& err, double& rcond,
                                solve_singularity_handler sing_handler,
                                bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || b.cols () == 0)
     retval = SparseComplexMatrix (nc, b.cols ());
   else if (calc_cond)
-    (*current_liboctave_error_handler) 
+    (*current_liboctave_error_handler)
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
-      
+
       // Note can't treat symmetric case as there is no dpttrf function
       if (typ == MatrixType::Tridiagonal ||
           typ == MatrixType::Tridiagonal_Hermitian)
         {
           OCTAVE_LOCAL_BUFFER (Complex, DU2, nr - 2);
           OCTAVE_LOCAL_BUFFER (Complex, DU, nr - 1);
           OCTAVE_LOCAL_BUFFER (Complex, D, nr);
           OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
@@ -4253,32 +4253,32 @@ SparseComplexMatrix::trisolve (MatrixTyp
                       DL[j] = data(i);
                     else if (ridx(i) == j - 1)
                       DU[j-1] = data(i);
                   }
             }
 
           F77_XFCN (zgttrf, ZGTTRF, (nr, DL, D, DU, DU2, pipvt, err));
 
-          if (err != 0) 
+          if (err != 0)
             {
               rcond = 0.0;
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
                 (*current_liboctave_error_handler)
                   ("matrix singular to machine precision");
-            } 
-          else 
-            {   
+            }
+          else
+            {
               rcond = 1.;
               char job = 'N';
               octave_idx_type b_nr = b.rows ();
               octave_idx_type b_nc = b.cols ();
               OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
 
               // Take a first guess that the number of non-zero terms
               // will be as many as in b
@@ -4288,32 +4288,32 @@ SparseComplexMatrix::trisolve (MatrixTyp
 
               retval.xcidx(0) = 0;
               for (volatile octave_idx_type j = 0; j < b_nc; j++)
                 {
 
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     Bx[i] = b (i,j);
 
-                  F77_XFCN (zgttrs, ZGTTRS, 
+                  F77_XFCN (zgttrs, ZGTTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, 1, DL, D, DU, DU2, pipvt, 
+                             nr, 1, DL, D, DU, DU2, pipvt,
                              Bx, b_nr, err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     {
                       (*current_liboctave_error_handler)
                         ("SparseComplexMatrix::solve solve failed");
 
                       err = -1;
                       break;
                     }
 
-                  // Count non-zeros in work vector and adjust 
+                  // Count non-zeros in work vector and adjust
                   // space in retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nr; i++)
                     if (Bx[i] != 0.)
                       new_nnz++;
 
                   if (ii + new_nnz > x_nz)
                     {
@@ -4367,18 +4367,18 @@ SparseComplexMatrix::bsolve (MatrixType 
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
         {
           octave_idx_type n_lower = mattype.nlower ();
           octave_idx_type ldm = n_lower + 1;
           ComplexMatrix m_band (ldm, nc);
           Complex *tmp_data = m_band.fortran_vec ();
-              
-          if (! mattype.is_dense ()) 
+
+          if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
@@ -4394,42 +4394,42 @@ SparseComplexMatrix::bsolve (MatrixType 
           double anorm;
           if (calc_cond)
             anorm = m_band.abs().sum().row(0).max();
 
           char job = 'L';
           F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
-            
-          if (err != 0) 
+
+          if (err != 0)
             {
               rcond = 0.0;
               // Matrix is not positive definite!! Fall through to
               // unsymmetric banded solver.
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Banded;
               err = 0;
-            } 
-          else 
+            }
+          else
             {
               if (calc_cond)
                 {
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
-                  F77_XFCN (zpbcon, ZPBCON, 
+                  F77_XFCN (zpbcon, ZPBCON,
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nr, n_lower, tmp_data, ldm,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
-                  if (err != 0) 
+                  if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcond))
                     {
                       err = -2;
 
@@ -4449,43 +4449,43 @@ SparseComplexMatrix::bsolve (MatrixType 
 
               if (err == 0)
                 {
                   retval = ComplexMatrix (b);
                   Complex *result = retval.fortran_vec ();
 
                   octave_idx_type b_nc = b.cols ();
 
-                  F77_XFCN (zpbtrs, ZPBTRS, 
+                  F77_XFCN (zpbtrs, ZPBTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              nr, n_lower, b_nc, tmp_data,
                              ldm, result, b.rows(), err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     {
-                      (*current_liboctave_error_handler) 
+                      (*current_liboctave_error_handler)
                         ("SparseMatrix::solve solve failed");
                       err = -1;
                     }
                 }
             }
         }
 
       if (typ == MatrixType::Banded)
         {
           // Create the storage for the banded form of the sparse matrix
           octave_idx_type n_upper = mattype.nupper ();
           octave_idx_type n_lower = mattype.nlower ();
           octave_idx_type ldm = n_upper + 2 * n_lower + 1;
 
           ComplexMatrix m_band (ldm, nc);
           Complex *tmp_data = m_band.fortran_vec ();
-              
-          if (! mattype.is_dense ()) 
+
+          if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
@@ -4505,52 +4505,52 @@ SparseComplexMatrix::bsolve (MatrixType 
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
-          F77_XFCN (zgbtrf, ZGBTRF, (nr, nc, n_lower, n_upper, tmp_data, 
+          F77_XFCN (zgbtrf, ZGBTRF, (nr, nc, n_lower, n_upper, tmp_data,
                                      ldm, pipvt, err));
-            
-          // Throw-away extra info LAPACK gives so as to not 
+
+          // Throw-away extra info LAPACK gives so as to not
           // change output.
-          if (err != 0) 
+          if (err != 0)
             {
               rcond = 0.0;
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
                 (*current_liboctave_error_handler)
                   ("matrix singular to machine precision");
-            } 
-          else 
+            }
+          else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
-                  F77_XFCN (zgbcon, ZGBCON, 
+                  F77_XFCN (zgbcon, ZGBCON,
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nc, n_lower, n_upper, tmp_data, ldm, pipvt,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
-                   if (err != 0) 
+                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcond))
                     {
                       err = -2;
 
@@ -4571,34 +4571,34 @@ SparseComplexMatrix::bsolve (MatrixType 
               if (err == 0)
                 {
                   retval = ComplexMatrix (b);
                   Complex *result = retval.fortran_vec ();
 
                   octave_idx_type b_nc = b.cols ();
 
                   char job = 'N';
-                  F77_XFCN (zgbtrs, ZGBTRS, 
+                  F77_XFCN (zgbtrs, ZGBTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              nr, n_lower, n_upper, b_nc, tmp_data,
                              ldm, pipvt, result, b.rows(), err
                              F77_CHAR_ARG_LEN (1)));
                 }
             }
         }
       else if (typ != MatrixType::Banded_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::bsolve (MatrixType &mattype, const SparseMatrix& b,
-                             octave_idx_type& err, double& rcond, 
+                             octave_idx_type& err, double& rcond,
                              solve_singularity_handler sing_handler,
                              bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
@@ -4616,18 +4616,18 @@ SparseComplexMatrix::bsolve (MatrixType 
 
       if (typ == MatrixType::Banded_Hermitian)
         {
           octave_idx_type n_lower = mattype.nlower ();
           octave_idx_type ldm = n_lower + 1;
 
           ComplexMatrix m_band (ldm, nc);
           Complex *tmp_data = m_band.fortran_vec ();
-              
-          if (! mattype.is_dense ()) 
+
+          if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
@@ -4643,40 +4643,40 @@ SparseComplexMatrix::bsolve (MatrixType 
           double anorm;
           if (calc_cond)
             anorm = m_band.abs().sum().row(0).max();
 
           char job = 'L';
           F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
-            
-          if (err != 0) 
+
+          if (err != 0)
             {
               rcond = 0.0;
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Banded;
               err = 0;
-            } 
-          else 
+            }
+          else
             {
               if (calc_cond)
                 {
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
-                  F77_XFCN (zpbcon, ZPBCON, 
+                  F77_XFCN (zpbcon, ZPBCON,
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nr, n_lower, tmp_data, ldm,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
-                  if (err != 0) 
+                  if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcond))
                     {
                       err = -2;
 
@@ -4707,39 +4707,39 @@ SparseComplexMatrix::bsolve (MatrixType 
                   retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
                   retval.xcidx(0) = 0;
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
                       for (octave_idx_type i = 0; i < b_nr; i++)
                         Bx[i] = b.elem (i, j);
 
-                      F77_XFCN (zpbtrs, ZPBTRS, 
+                      F77_XFCN (zpbtrs, ZPBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, 1, tmp_data,
                                  ldm, Bx, b_nr, err
                                  F77_CHAR_ARG_LEN (1)));
 
                       if (err != 0)
                         {
-                          (*current_liboctave_error_handler) 
+                          (*current_liboctave_error_handler)
                             ("SparseComplexMatrix::solve solve failed");
                           err = -1;
                           break;
                         }
 
                       for (octave_idx_type i = 0; i < b_nr; i++)
                         {
                           Complex tmp = Bx[i];
                           if (tmp != 0.0)
                             {
                               if (ii == x_nz)
                                 {
                                   // Resize the sparse matrix
-                                  octave_idx_type sz = x_nz * 
+                                  octave_idx_type sz = x_nz *
                                     (b_nc - j) / b_nc;
                                   sz = (sz > 10 ? sz : 10) + x_nz;
                                   retval.change_capacity (sz);
                                   x_nz = sz;
                                 }
                               retval.xdata(ii) = tmp;
                               retval.xridx(ii++) = i;
                             }
@@ -4756,18 +4756,18 @@ SparseComplexMatrix::bsolve (MatrixType 
         {
           // Create the storage for the banded form of the sparse matrix
           octave_idx_type n_upper = mattype.nupper ();
           octave_idx_type n_lower = mattype.nlower ();
           octave_idx_type ldm = n_upper + 2 * n_lower + 1;
 
           ComplexMatrix m_band (ldm, nc);
           Complex *tmp_data = m_band.fortran_vec ();
-              
-          if (! mattype.is_dense ()) 
+
+          if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
@@ -4787,51 +4787,51 @@ SparseComplexMatrix::bsolve (MatrixType 
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
-          F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
+          F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, tmp_data,
                                      ldm, pipvt, err));
-            
-          if (err != 0) 
+
+          if (err != 0)
             {
               rcond = 0.0;
               err = -2;
 
               if (sing_handler)
                 {
                 sing_handler (rcond);
                 mattype.mark_as_rectangular ();
                 }
               else
                 (*current_liboctave_error_handler)
                   ("matrix singular to machine precision");
 
-            } 
-          else 
+            }
+          else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
-                  F77_XFCN (zgbcon, ZGBCON, 
+                  F77_XFCN (zgbcon, ZGBCON,
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nc, n_lower, n_upper, tmp_data, ldm, pipvt,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
-                   if (err != 0) 
+                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcond))
                     {
                       err = -2;
 
@@ -4859,27 +4859,27 @@ SparseComplexMatrix::bsolve (MatrixType 
                   volatile octave_idx_type ii = 0;
 
                   OCTAVE_LOCAL_BUFFER (Complex, work, nr);
 
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
                       for (octave_idx_type i = 0; i < nr; i++)
                         work[i] = 0.;
-                      for (octave_idx_type i = b.cidx(j); 
+                      for (octave_idx_type i = b.cidx(j);
                            i < b.cidx(j+1); i++)
                         work[b.ridx(i)] = b.data(i);
 
-                      F77_XFCN (zgbtrs, ZGBTRS, 
+                      F77_XFCN (zgbtrs, ZGBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, n_upper, 1, tmp_data,
                                  ldm, pipvt, work, b.rows (), err
                                  F77_CHAR_ARG_LEN (1)));
 
-                      // Count non-zeros in work vector and adjust 
+                      // Count non-zeros in work vector and adjust
                       // space in retval if needed
                       octave_idx_type new_nnz = 0;
                       for (octave_idx_type i = 0; i < nr; i++)
                         if (work[i] != 0.)
                           new_nnz++;
 
                       if (ii + new_nnz > x_nz)
                         {
@@ -4905,18 +4905,18 @@ SparseComplexMatrix::bsolve (MatrixType 
       else if (typ != MatrixType::Banded_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::bsolve (MatrixType &mattype, const ComplexMatrix& b, 
-                             octave_idx_type& err, double& rcond, 
+SparseComplexMatrix::bsolve (MatrixType &mattype, const ComplexMatrix& b,
+                             octave_idx_type& err, double& rcond,
                              solve_singularity_handler sing_handler,
                              bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
@@ -4934,18 +4934,18 @@ SparseComplexMatrix::bsolve (MatrixType 
 
       if (typ == MatrixType::Banded_Hermitian)
         {
           octave_idx_type n_lower = mattype.nlower ();
           octave_idx_type ldm = n_lower + 1;
 
           ComplexMatrix m_band (ldm, nc);
           Complex *tmp_data = m_band.fortran_vec ();
-              
-          if (! mattype.is_dense ()) 
+
+          if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
@@ -4961,42 +4961,42 @@ SparseComplexMatrix::bsolve (MatrixType 
           double anorm;
           if (calc_cond)
             anorm = m_band.abs().sum().row(0).max();
 
           char job = 'L';
           F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
-            
-          if (err != 0) 
+
+          if (err != 0)
             {
               // Matrix is not positive definite!! Fall through to
               // unsymmetric banded solver.
               rcond = 0.0;
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Banded;
               err = 0;
-            } 
-          else 
+            }
+          else
             {
               if (calc_cond)
                 {
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
-                  F77_XFCN (zpbcon, ZPBCON, 
+                  F77_XFCN (zpbcon, ZPBCON,
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nr, n_lower, tmp_data, ldm,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
-                  if (err != 0) 
+                  if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcond))
                     {
                       err = -2;
 
@@ -5016,43 +5016,43 @@ SparseComplexMatrix::bsolve (MatrixType 
 
               if (err == 0)
                 {
                   octave_idx_type b_nr = b.rows ();
                   octave_idx_type b_nc = b.cols ();
                   retval = ComplexMatrix (b);
                   Complex *result = retval.fortran_vec ();
 
-                  F77_XFCN (zpbtrs, ZPBTRS, 
+                  F77_XFCN (zpbtrs, ZPBTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              nr, n_lower, b_nc, tmp_data,
                              ldm, result, b_nr, err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     {
-                      (*current_liboctave_error_handler) 
+                      (*current_liboctave_error_handler)
                         ("SparseComplexMatrix::solve solve failed");
                       err = -1;
                     }
                 }
             }
         }
 
       if (typ == MatrixType::Banded)
         {
           // Create the storage for the banded form of the sparse matrix
           octave_idx_type n_upper = mattype.nupper ();
           octave_idx_type n_lower = mattype.nlower ();
           octave_idx_type ldm = n_upper + 2 * n_lower + 1;
 
           ComplexMatrix m_band (ldm, nc);
           Complex *tmp_data = m_band.fortran_vec ();
-              
-          if (! mattype.is_dense ()) 
+
+          if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
@@ -5072,50 +5072,50 @@ SparseComplexMatrix::bsolve (MatrixType 
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
-          F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
+          F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, tmp_data,
                                      ldm, pipvt, err));
-            
-          if (err != 0) 
+
+          if (err != 0)
             {
               err = -2;
               rcond = 0.0;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
                 (*current_liboctave_error_handler)
                   ("matrix singular to machine precision");
-            } 
-          else 
+            }
+          else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
-                  F77_XFCN (zgbcon, ZGBCON, 
+                  F77_XFCN (zgbcon, ZGBCON,
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nc, n_lower, n_upper, tmp_data, ldm, pipvt,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
-                   if (err != 0) 
+                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcond))
                     {
                       err = -2;
 
@@ -5135,34 +5135,34 @@ SparseComplexMatrix::bsolve (MatrixType 
 
               if (err == 0)
                 {
                   char job = 'N';
                   octave_idx_type b_nc = b.cols ();
                   retval = ComplexMatrix (b);
                   Complex *result = retval.fortran_vec ();
 
-                  F77_XFCN (zgbtrs, ZGBTRS, 
+                  F77_XFCN (zgbtrs, ZGBTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              nr, n_lower, n_upper, b_nc, tmp_data,
                              ldm, pipvt, result, b.rows (), err
                              F77_CHAR_ARG_LEN (1)));
                 }
             }
         }
       else if (typ != MatrixType::Banded_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::bsolve (MatrixType &mattype, const SparseComplexMatrix& b,
-                             octave_idx_type& err, double& rcond, 
+                             octave_idx_type& err, double& rcond,
                              solve_singularity_handler sing_handler,
                              bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
@@ -5180,18 +5180,18 @@ SparseComplexMatrix::bsolve (MatrixType 
 
       if (typ == MatrixType::Banded_Hermitian)
         {
           octave_idx_type n_lower = mattype.nlower ();
           octave_idx_type ldm = n_lower + 1;
 
           ComplexMatrix m_band (ldm, nc);
           Complex *tmp_data = m_band.fortran_vec ();
-              
-          if (! mattype.is_dense ()) 
+
+          if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
@@ -5207,43 +5207,43 @@ SparseComplexMatrix::bsolve (MatrixType 
           double anorm;
           if (calc_cond)
             anorm = m_band.abs().sum().row(0).max();
 
           char job = 'L';
           F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
-            
-          if (err != 0) 
+
+          if (err != 0)
             {
               // Matrix is not positive definite!! Fall through to
               // unsymmetric banded solver.
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Banded;
 
               rcond = 0.0;
               err = 0;
-            } 
-          else 
+            }
+          else
             {
               if (calc_cond)
                 {
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
-                  F77_XFCN (zpbcon, ZPBCON, 
+                  F77_XFCN (zpbcon, ZPBCON,
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nr, n_lower, tmp_data, ldm,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
-                  if (err != 0) 
+                  if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcond))
                     {
                       err = -2;
 
@@ -5275,31 +5275,31 @@ SparseComplexMatrix::bsolve (MatrixType 
 
                   retval.xcidx(0) = 0;
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
 
                       for (octave_idx_type i = 0; i < b_nr; i++)
                         Bx[i] = b (i,j);
 
-                      F77_XFCN (zpbtrs, ZPBTRS, 
+                      F77_XFCN (zpbtrs, ZPBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, 1, tmp_data,
                                  ldm, Bx, b_nr, err
                                  F77_CHAR_ARG_LEN (1)));
 
                       if (err != 0)
                         {
-                          (*current_liboctave_error_handler) 
+                          (*current_liboctave_error_handler)
                             ("SparseMatrix::solve solve failed");
                           err = -1;
                           break;
                         }
 
-                      // Count non-zeros in work vector and adjust 
+                      // Count non-zeros in work vector and adjust
                       // space in retval if needed
                       octave_idx_type new_nnz = 0;
                       for (octave_idx_type i = 0; i < nr; i++)
                         if (Bx[i] != 0.)
                           new_nnz++;
 
                       if (ii + new_nnz > x_nz)
                         {
@@ -5328,18 +5328,18 @@ SparseComplexMatrix::bsolve (MatrixType 
         {
           // Create the storage for the banded form of the sparse matrix
           octave_idx_type n_upper = mattype.nupper ();
           octave_idx_type n_lower = mattype.nlower ();
           octave_idx_type ldm = n_upper + 2 * n_lower + 1;
 
           ComplexMatrix m_band (ldm, nc);
           Complex *tmp_data = m_band.fortran_vec ();
-              
-          if (! mattype.is_dense ()) 
+
+          if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
@@ -5359,51 +5359,51 @@ SparseComplexMatrix::bsolve (MatrixType 
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
-          F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
+          F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, tmp_data,
                                      ldm, pipvt, err));
-            
-          if (err != 0) 
+
+          if (err != 0)
             {
               err = -2;
               rcond = 0.0;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
                 (*current_liboctave_error_handler)
                   ("matrix singular to machine precision");
 
             }
-          else 
+          else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
-                  F77_XFCN (zgbcon, ZGBCON, 
+                  F77_XFCN (zgbcon, ZGBCON,
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nc, n_lower, n_upper, tmp_data, ldm, pipvt,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
-                   if (err != 0) 
+                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcond))
                     {
                       err = -2;
 
@@ -5432,27 +5432,27 @@ SparseComplexMatrix::bsolve (MatrixType 
 
                   OCTAVE_LOCAL_BUFFER (Complex, Bx, nr);
 
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
                       for (octave_idx_type i = 0; i < nr; i++)
                         Bx[i] = 0.;
 
-                      for (octave_idx_type i = b.cidx(j); 
+                      for (octave_idx_type i = b.cidx(j);
                            i < b.cidx(j+1); i++)
                         Bx[b.ridx(i)] = b.data(i);
 
-                      F77_XFCN (zgbtrs, ZGBTRS, 
+                      F77_XFCN (zgbtrs, ZGBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, n_upper, 1, tmp_data,
                                  ldm, pipvt, Bx, b.rows (), err
                                  F77_CHAR_ARG_LEN (1)));
 
-                      // Count non-zeros in work vector and adjust 
+                      // Count non-zeros in work vector and adjust
                       // space in retval if needed
                       octave_idx_type new_nnz = 0;
                       for (octave_idx_type i = 0; i < nr; i++)
                         if (Bx[i] != 0.)
                           new_nnz++;
 
                       if (ii + new_nnz > x_nz)
                         {
@@ -5461,29 +5461,29 @@ SparseComplexMatrix::bsolve (MatrixType 
                           retval.change_capacity (sz);
                           x_nz = sz;
                         }
 
                       for (octave_idx_type i = 0; i < nr; i++)
                         if (Bx[i] != 0.)
                           {
                             retval.xridx(ii) = i;
-                            retval.xdata(ii++) = Bx[i]; 
+                            retval.xdata(ii++) = Bx[i];
                           }
                       retval.xcidx(j+1) = ii;
                     }
 
                   retval.maybe_compress ();
                 }
             }
         }
       else if (typ != MatrixType::Banded_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
-  
+
   return retval;
 }
 
 void *
 SparseComplexMatrix::factorize (octave_idx_type& err, double &rcond,
                                 Matrix &Control, Matrix &Info,
                                 solve_singularity_handler sing_handler,
                                 bool calc_cond) const
@@ -5523,69 +5523,69 @@ SparseComplexMatrix::factorize (octave_i
 
   UMFPACK_ZNAME (report_matrix) (nr, nc, Ap, Ai,
                                  reinterpret_cast<const double *> (Ax),
                                  0, 1, control);
 
   void *Symbolic;
   Info = Matrix (1, UMFPACK_INFO);
   double *info = Info.fortran_vec ();
-  int status = UMFPACK_ZNAME (qsymbolic) (nr, nc, Ap, Ai, 
-                                     reinterpret_cast<const double *> (Ax), 
+  int status = UMFPACK_ZNAME (qsymbolic) (nr, nc, Ap, Ai,
+                                     reinterpret_cast<const double *> (Ax),
                                      0, 0, &Symbolic, control, info);
 
   if (status < 0)
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
         ("SparseComplexMatrix::solve symbolic factorization failed");
       err = -1;
 
       UMFPACK_ZNAME (report_status) (control, status);
       UMFPACK_ZNAME (report_info) (control, info);
 
       UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
     }
   else
     {
       UMFPACK_ZNAME (report_symbolic) (Symbolic, control);
 
       status = UMFPACK_ZNAME (numeric) (Ap, Ai,
-                                   reinterpret_cast<const double *> (Ax), 0, 
+                                   reinterpret_cast<const double *> (Ax), 0,
                                    Symbolic, &Numeric, control, info) ;
       UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
 
       if (calc_cond)
         rcond = Info (UMFPACK_RCOND);
       else
         rcond = 1.;
       volatile double rcond_plus_one = rcond + 1.0;
 
-      if (status == UMFPACK_WARNING_singular_matrix || 
+      if (status == UMFPACK_WARNING_singular_matrix ||
           rcond_plus_one == 1.0 || xisnan (rcond))
         {
           UMFPACK_ZNAME (report_numeric) (Numeric, control);
 
           err = -2;
 
           if (sing_handler)
             sing_handler (rcond);
           else
             (*current_liboctave_error_handler)
               ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
                rcond);
 
         }
       else if (status < 0)
           {
-            (*current_liboctave_error_handler) 
+            (*current_liboctave_error_handler)
               ("SparseComplexMatrix::solve numeric factorization failed");
 
             UMFPACK_ZNAME (report_status) (control, status);
             UMFPACK_ZNAME (report_info) (control, info);
-              
+
             err = -1;
           }
         else
           {
             UMFPACK_ZNAME (report_numeric) (Numeric, control);
           }
     }
 
@@ -5717,17 +5717,17 @@ SparseComplexMatrix::fsolve (MatrixType 
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
                     (*current_liboctave_error_handler)
                       ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
                        rcond);
-              
+
                   return retval;
                 }
 
               cholmod_dense *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
@@ -5755,17 +5755,17 @@ SparseComplexMatrix::fsolve (MatrixType 
           typ = MatrixType::Full;
 #endif
         }
 
       if (typ == MatrixType::Full)
         {
 #ifdef HAVE_UMFPACK
           Matrix Control, Info;
-          void *Numeric = factorize (err, rcond, Control, Info, 
+          void *Numeric = factorize (err, rcond, Control, Info,
                                      sing_handler, calc_cond);
 
           if (err == 0)
             {
               octave_idx_type b_nr = b.rows ();
               octave_idx_type b_nc = b.cols ();
               int status = 0;
               double *control = Control.fortran_vec ();
@@ -5784,44 +5784,44 @@ SparseComplexMatrix::fsolve (MatrixType 
               retval.resize (b_nr, b_nc);
               Complex *Xx = retval.fortran_vec ();
 
               for (octave_idx_type j = 0, iidx = 0; j < b_nc; j++, iidx += b_nr)
                 {
 #ifdef UMFPACK_SEPARATE_SPLIT
                   status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap,
                                              Ai,
-                                             reinterpret_cast<const double *> (Ax), 
+                                             reinterpret_cast<const double *> (Ax),
                                              0,
-                                             reinterpret_cast<double *> (&Xx[iidx]), 
+                                             reinterpret_cast<double *> (&Xx[iidx]),
                                              0,
-                                             &Bx[iidx], Bz, Numeric, 
+                                             &Bx[iidx], Bz, Numeric,
                                              control, info);
 #else
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     Bz[i] = b.elem (i, j);
 
                   status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap,
                                              Ai,
-                                             reinterpret_cast<const double *> (Ax), 
+                                             reinterpret_cast<const double *> (Ax),
                                              0,
-                                             reinterpret_cast<double *> (&Xx[iidx]), 
+                                             reinterpret_cast<double *> (&Xx[iidx]),
                                              0,
                                              reinterpret_cast<const double *> (Bz),
-                                             0, Numeric, 
+                                             0, Numeric,
                                              control, info);
 #endif
 
                   if (status < 0)
                     {
-                      (*current_liboctave_error_handler) 
+                      (*current_liboctave_error_handler)
                         ("SparseComplexMatrix::solve solve failed");
 
                       UMFPACK_ZNAME (report_status) (control, status);
-                      
+
                       err = -1;
 
                       break;
                     }
                 }
 
               UMFPACK_ZNAME (report_info) (control, info);
 
@@ -5832,22 +5832,22 @@ SparseComplexMatrix::fsolve (MatrixType 
 
 #else
           (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
         }
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
-  
+
   return retval;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::fsolve (MatrixType &mattype, const SparseMatrix& b, 
+SparseComplexMatrix::fsolve (MatrixType &mattype, const SparseMatrix& b,
                              octave_idx_type& err, double& rcond,
                              solve_singularity_handler sing_handler,
                              bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -5970,33 +5970,33 @@ SparseComplexMatrix::fsolve (MatrixType 
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
                     (*current_liboctave_error_handler)
                       ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
                        rcond);
-              
+
                   return retval;
                 }
 
               cholmod_sparse *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
-              retval = SparseComplexMatrix 
-                (static_cast<octave_idx_type>(X->nrow), 
+              retval = SparseComplexMatrix
+                (static_cast<octave_idx_type>(X->nrow),
                  static_cast<octave_idx_type>(X->ncol),
                  static_cast<octave_idx_type>(X->nzmax));
-              for (octave_idx_type j = 0; 
+              for (octave_idx_type j = 0;
                    j <= static_cast<octave_idx_type>(X->ncol); j++)
                 retval.xcidx(j) = static_cast<octave_idx_type *>(X->p)[j];
-              for (octave_idx_type j = 0; 
+              for (octave_idx_type j = 0;
                    j < static_cast<octave_idx_type>(X->nzmax); j++)
                 {
                   retval.xridx(j) = static_cast<octave_idx_type *>(X->i)[j];
                   retval.xdata(j) = static_cast<Complex *>(X->x)[j];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_sparse) (&X, cm);
@@ -6014,17 +6014,17 @@ SparseComplexMatrix::fsolve (MatrixType 
           typ = MatrixType::Full;
 #endif
         }
 
       if (typ == MatrixType::Full)
         {
 #ifdef HAVE_UMFPACK
           Matrix Control, Info;
-          void *Numeric = factorize (err, rcond, Control, Info, 
+          void *Numeric = factorize (err, rcond, Control, Info,
                                      sing_handler, calc_cond);
 
           if (err == 0)
             {
               octave_idx_type b_nr = b.rows ();
               octave_idx_type b_nc = b.cols ();
               int status = 0;
               double *control = Control.fortran_vec ();
@@ -6044,54 +6044,54 @@ SparseComplexMatrix::fsolve (MatrixType 
 
               // Take a first guess that the number of non-zero terms
               // will be as many as in b
               octave_idx_type x_nz = b.nnz ();
               octave_idx_type ii = 0;
               retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
               OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
-              
+
               retval.xcidx(0) = 0;
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
 
 #ifdef UMFPACK_SEPARATE_SPLIT
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     Bx[i] = b.elem (i, j);
 
                   status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap,
                                              Ai,
                                              reinterpret_cast<const double *> (Ax),
                                              0,
                                              reinterpret_cast<double *> (Xx),
-                                             0, 
-                                             Bx, Bz, Numeric, control, 
+                                             0,
+                                             Bx, Bz, Numeric, control,
                                              info);
 #else
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     Bz[i] = b.elem (i, j);
 
-                  status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap, Ai, 
+                  status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap, Ai,
                                              reinterpret_cast<const double *> (Ax),
                                              0,
                                              reinterpret_cast<double *> (Xx),
                                              0,
                                              reinterpret_cast<double *> (Bz),
                                              0,
-                                             Numeric, control, 
+                                             Numeric, control,
                                              info);
 #endif
                   if (status < 0)
                     {
-                      (*current_liboctave_error_handler) 
+                      (*current_liboctave_error_handler)
                         ("SparseComplexMatrix::solve solve failed");
 
                       UMFPACK_ZNAME (report_status) (control, status);
-                      
+
                       err = -1;
 
                       break;
                     }
 
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     {
                       Complex tmp = Xx[i];
@@ -6123,22 +6123,22 @@ SparseComplexMatrix::fsolve (MatrixType 
 
 #else
           (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
         }
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
-  
+
   return retval;
 }
 
 ComplexMatrix
-SparseComplexMatrix::fsolve (MatrixType &mattype, const ComplexMatrix& b, 
+SparseComplexMatrix::fsolve (MatrixType &mattype, const ComplexMatrix& b,
                              octave_idx_type& err, double& rcond,
                              solve_singularity_handler sing_handler,
                              bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -6251,17 +6251,17 @@ SparseComplexMatrix::fsolve (MatrixType 
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
                     (*current_liboctave_error_handler)
                       ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
                        rcond);
-              
+
                   return retval;
                 }
 
               cholmod_dense *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
@@ -6306,35 +6306,35 @@ SparseComplexMatrix::fsolve (MatrixType 
               double *info = Info.fortran_vec ();
               const octave_idx_type *Ap = cidx ();
               const octave_idx_type *Ai = ridx ();
               const Complex *Ax = data ();
               const Complex *Bx = b.fortran_vec ();
 
               retval.resize (b_nr, b_nc);
               Complex *Xx = retval.fortran_vec ();
-              
+
               for (octave_idx_type j = 0, iidx = 0; j < b_nc; j++, iidx += b_nr)
                 {
-                  status = 
-                    UMFPACK_ZNAME (solve) (UMFPACK_A, Ap, Ai, 
-                                      reinterpret_cast<const double *> (Ax), 
+                  status =
+                    UMFPACK_ZNAME (solve) (UMFPACK_A, Ap, Ai,
+                                      reinterpret_cast<const double *> (Ax),
                                       0,
-                                      reinterpret_cast<double *> (&Xx[iidx]), 
+                                      reinterpret_cast<double *> (&Xx[iidx]),
                                       0,
-                                      reinterpret_cast<const double *> (&Bx[iidx]), 
+                                      reinterpret_cast<const double *> (&Bx[iidx]),
                                       0, Numeric, control, info);
-                  
+
                   if (status < 0)
                     {
-                      (*current_liboctave_error_handler) 
+                      (*current_liboctave_error_handler)
                         ("SparseComplexMatrix::solve solve failed");
 
                       UMFPACK_ZNAME (report_status) (control, status);
-                      
+
                       err = -1;
 
                       break;
                     }
                 }
 
               UMFPACK_ZNAME (report_info) (control, info);
 
@@ -6345,17 +6345,17 @@ SparseComplexMatrix::fsolve (MatrixType 
 
 #else
           (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
         }
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
-  
+
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::fsolve (MatrixType &mattype, const SparseComplexMatrix& b,
                              octave_idx_type& err, double& rcond,
                              solve_singularity_handler sing_handler,
                              bool calc_cond) const
@@ -6483,33 +6483,33 @@ SparseComplexMatrix::fsolve (MatrixType 
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
                     (*current_liboctave_error_handler)
                       ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
                        rcond);
-              
+
                   return retval;
                 }
 
               cholmod_sparse *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
-              retval = SparseComplexMatrix 
-                (static_cast<octave_idx_type>(X->nrow), 
+              retval = SparseComplexMatrix
+                (static_cast<octave_idx_type>(X->nrow),
                  static_cast<octave_idx_type>(X->ncol),
                  static_cast<octave_idx_type>(X->nzmax));
-              for (octave_idx_type j = 0; 
+              for (octave_idx_type j = 0;
                    j <= static_cast<octave_idx_type>(X->ncol); j++)
                 retval.xcidx(j) = static_cast<octave_idx_type *>(X->p)[j];
-              for (octave_idx_type j = 0; 
+              for (octave_idx_type j = 0;
                    j < static_cast<octave_idx_type>(X->nzmax); j++)
                 {
                   retval.xridx(j) = static_cast<octave_idx_type *>(X->i)[j];
                   retval.xdata(j) = static_cast<Complex *>(X->x)[j];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_sparse) (&X, cm);
@@ -6550,39 +6550,39 @@ SparseComplexMatrix::fsolve (MatrixType 
 
               // Take a first guess that the number of non-zero terms
               // will be as many as in b
               octave_idx_type x_nz = b.nnz ();
               octave_idx_type ii = 0;
               retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
               OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
-              
+
               retval.xcidx(0) = 0;
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     Bx[i] = b (i,j);
 
                   status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap,
                                              Ai,
                                              reinterpret_cast<const double *> (Ax),
                                              0,
                                              reinterpret_cast<double *> (Xx),
                                              0,
                                              reinterpret_cast<double *> (Bx),
                                              0, Numeric, control, info);
-                  
+
                   if (status < 0)
                     {
-                      (*current_liboctave_error_handler) 
+                      (*current_liboctave_error_handler)
                         ("SparseComplexMatrix::solve solve failed");
 
                       UMFPACK_ZNAME (report_status) (control, status);
-                  
+
                       err = -1;
 
                       break;
                     }
 
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     {
                       Complex tmp = Xx[i];
@@ -6603,17 +6603,17 @@ SparseComplexMatrix::fsolve (MatrixType 
                   retval.xcidx(j+1) = ii;
                 }
 
               retval.maybe_compress ();
 
               rcond = Info (UMFPACK_RCOND);
               volatile double rcond_plus_one = rcond + 1.0;
 
-              if (status == UMFPACK_WARNING_singular_matrix || 
+              if (status == UMFPACK_WARNING_singular_matrix ||
                   rcond_plus_one == 1.0 || xisnan (rcond))
                 {
                   err = -2;
 
                   if (sing_handler)
                     sing_handler (rcond);
                   else
                     (*current_liboctave_error_handler)
@@ -6631,46 +6631,46 @@ SparseComplexMatrix::fsolve (MatrixType 
 
 #else
           (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
         }
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
-  
+
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (MatrixType &mattype, const Matrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseComplexMatrix::solve (MatrixType &mattype, const Matrix& b, 
+SparseComplexMatrix::solve (MatrixType &mattype, const Matrix& b,
                             octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (MatrixType &mattype, const Matrix& b,
                             octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (MatrixType &mattype, const Matrix& b,
-                            octave_idx_type& err, double& rcond, 
+                            octave_idx_type& err, double& rcond,
                             solve_singularity_handler sing_handler,
                             bool singular_fallback) const
 {
   ComplexMatrix retval;
   int typ = mattype.type (false);
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
@@ -6678,17 +6678,17 @@ SparseComplexMatrix::solve (MatrixType &
   if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     retval = dsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == MatrixType::Tridiagonal || 
+  else if (typ == MatrixType::Tridiagonal ||
            typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return ComplexMatrix ();
@@ -6712,32 +6712,32 @@ SparseComplexMatrix
 SparseComplexMatrix::solve (MatrixType &mattype, const SparseMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::solve (MatrixType &mattype, const SparseMatrix& b, 
+SparseComplexMatrix::solve (MatrixType &mattype, const SparseMatrix& b,
                      octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (MatrixType &mattype, const SparseMatrix& b,
                      octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::solve (MatrixType &mattype, const SparseMatrix& b, 
+SparseComplexMatrix::solve (MatrixType &mattype, const SparseMatrix& b,
                             octave_idx_type& err, double& rcond,
                             solve_singularity_handler sing_handler,
                             bool singular_fallback) const
 {
   SparseComplexMatrix retval;
   int typ = mattype.type (false);
 
   if (typ == MatrixType::Unknown)
@@ -6746,17 +6746,17 @@ SparseComplexMatrix::solve (MatrixType &
   if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     retval = dsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == MatrixType::Tridiagonal || 
+  else if (typ == MatrixType::Tridiagonal ||
            typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return SparseComplexMatrix ();
@@ -6780,33 +6780,33 @@ ComplexMatrix
 SparseComplexMatrix::solve (MatrixType &mattype, const ComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseComplexMatrix::solve (MatrixType &mattype, const ComplexMatrix& b, 
+SparseComplexMatrix::solve (MatrixType &mattype, const ComplexMatrix& b,
                             octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseComplexMatrix::solve (MatrixType &mattype, const ComplexMatrix& b, 
+SparseComplexMatrix::solve (MatrixType &mattype, const ComplexMatrix& b,
                             octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseComplexMatrix::solve (MatrixType &mattype, const ComplexMatrix& b, 
-                            octave_idx_type& err, double& rcond, 
+SparseComplexMatrix::solve (MatrixType &mattype, const ComplexMatrix& b,
+                            octave_idx_type& err, double& rcond,
                             solve_singularity_handler sing_handler,
                             bool singular_fallback) const
 {
   ComplexMatrix retval;
   int typ = mattype.type (false);
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
@@ -6814,17 +6814,17 @@ SparseComplexMatrix::solve (MatrixType &
   if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     retval = dsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == MatrixType::Tridiagonal || 
+  else if (typ == MatrixType::Tridiagonal ||
            typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return ComplexMatrix ();
@@ -6840,41 +6840,41 @@ SparseComplexMatrix::solve (MatrixType &
         ComplexMatrix> (*this, b, err);
 #endif
     }
 
   return retval;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::solve (MatrixType &mattype, 
+SparseComplexMatrix::solve (MatrixType &mattype,
                             const SparseComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::solve (MatrixType &mattype, const SparseComplexMatrix& b, 
+SparseComplexMatrix::solve (MatrixType &mattype, const SparseComplexMatrix& b,
                             octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (MatrixType &mattype, const SparseComplexMatrix& b,
                             octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::solve (MatrixType &mattype, const SparseComplexMatrix& b, 
+SparseComplexMatrix::solve (MatrixType &mattype, const SparseComplexMatrix& b,
                             octave_idx_type& err, double& rcond,
                             solve_singularity_handler sing_handler,
                             bool singular_fallback) const
 {
   SparseComplexMatrix retval;
   int typ = mattype.type (false);
 
   if (typ == MatrixType::Unknown)
@@ -6883,17 +6883,17 @@ SparseComplexMatrix::solve (MatrixType &
   if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     retval = dsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == MatrixType::Tridiagonal || 
+  else if (typ == MatrixType::Tridiagonal ||
            typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return SparseComplexMatrix ();
@@ -6916,41 +6916,41 @@ SparseComplexMatrix::solve (MatrixType &
 ComplexColumnVector
 SparseComplexMatrix::solve (MatrixType &mattype, const ColumnVector& b) const
 {
   octave_idx_type info; double rcond;
   return solve (mattype, b, info, rcond);
 }
 
 ComplexColumnVector
-SparseComplexMatrix::solve (MatrixType &mattype, const ColumnVector& b, 
+SparseComplexMatrix::solve (MatrixType &mattype, const ColumnVector& b,
                             octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond);
 }
 
 ComplexColumnVector
-SparseComplexMatrix::solve (MatrixType &mattype, const ColumnVector& b, 
+SparseComplexMatrix::solve (MatrixType &mattype, const ColumnVector& b,
                             octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexColumnVector
-SparseComplexMatrix::solve (MatrixType &mattype, const ColumnVector& b, 
+SparseComplexMatrix::solve (MatrixType &mattype, const ColumnVector& b,
                             octave_idx_type& info, double& rcond,
                             solve_singularity_handler sing_handler) const
 {
   Matrix tmp (b);
   return solve (mattype, tmp, info, rcond, sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 ComplexColumnVector
-SparseComplexMatrix::solve (MatrixType &mattype, 
+SparseComplexMatrix::solve (MatrixType &mattype,
                             const ComplexColumnVector& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexColumnVector
@@ -6988,112 +6988,112 @@ SparseComplexMatrix::solve (const Matrix
 ComplexMatrix
 SparseComplexMatrix::solve (const Matrix& b, octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseComplexMatrix::solve (const Matrix& b, octave_idx_type& info, 
+SparseComplexMatrix::solve (const Matrix& b, octave_idx_type& info,
                      double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseComplexMatrix::solve (const Matrix& b, octave_idx_type& err, 
-                            double& rcond, 
+SparseComplexMatrix::solve (const Matrix& b, octave_idx_type& err,
+                            double& rcond,
                             solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::solve (const SparseMatrix& b, 
+SparseComplexMatrix::solve (const SparseMatrix& b,
                      octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseMatrix& b,
                      octave_idx_type& info, double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::solve (const SparseMatrix& b, 
+SparseComplexMatrix::solve (const SparseMatrix& b,
                      octave_idx_type& err, double& rcond,
                      solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 ComplexMatrix
-SparseComplexMatrix::solve (const ComplexMatrix& b, 
+SparseComplexMatrix::solve (const ComplexMatrix& b,
                             octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseComplexMatrix::solve (const ComplexMatrix& b, 
+SparseComplexMatrix::solve (const ComplexMatrix& b,
                      octave_idx_type& info, double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseComplexMatrix::solve (const ComplexMatrix& b, 
-                     octave_idx_type& err, double& rcond, 
+SparseComplexMatrix::solve (const ComplexMatrix& b,
+                     octave_idx_type& err, double& rcond,
                      solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::solve (const SparseComplexMatrix& b, 
+SparseComplexMatrix::solve (const SparseComplexMatrix& b,
                      octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseComplexMatrix& b,
                      octave_idx_type& info, double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::solve (const SparseComplexMatrix& b, 
+SparseComplexMatrix::solve (const SparseComplexMatrix& b,
                      octave_idx_type& err, double& rcond,
                      solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 ComplexColumnVector
@@ -7106,17 +7106,17 @@ SparseComplexMatrix::solve (const Column
 ComplexColumnVector
 SparseComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond);
 }
 
 ComplexColumnVector
-SparseComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info, 
+SparseComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info,
                             double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info, double& rcond,
                             solve_singularity_handler sing_handler) const
@@ -7136,24 +7136,24 @@ SparseComplexMatrix::solve (const Comple
 ComplexColumnVector
 SparseComplexMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 ComplexColumnVector
-SparseComplexMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info, 
+SparseComplexMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info,
                      double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 ComplexColumnVector
-SparseComplexMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info, 
+SparseComplexMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info,
                             double& rcond,
                             solve_singularity_handler sing_handler) const
 {
   ComplexMatrix tmp (b);
   return solve (tmp, info, rcond, sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 // unary operations
@@ -7162,19 +7162,19 @@ SparseComplexMatrix::operator ! (void) c
 {
   if (any_element_is_nan ())
     gripe_nan_to_logical_conversion ();
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nz1 = nnz ();
   octave_idx_type nz2 = nr*nc - nz1;
-   
+
   SparseBoolMatrix r (nr, nc, nz2);
-   
+
   octave_idx_type ii = 0;
   octave_idx_type jj = 0;
   r.cidx (0) = 0;
   for (octave_idx_type i = 0; i < nc; i++)
     {
       for (octave_idx_type j = 0; j < nr; j++)
         {
           if (jj < cidx(i+1) && ridx(jj) == j)
@@ -7186,20 +7186,20 @@ SparseComplexMatrix::operator ! (void) c
             }
         }
       r.cidx (i+1) = ii;
     }
 
   return r;
 }
 
-SparseComplexMatrix 
+SparseComplexMatrix
 SparseComplexMatrix::squeeze (void) const
-{ 
-  return MSparse<Complex>::squeeze (); 
+{
+  return MSparse<Complex>::squeeze ();
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::reshape (const dim_vector& new_dims) const
 {
   return MSparse<Complex>::reshape (new_dims);
 }
 
@@ -7252,17 +7252,17 @@ SparseComplexMatrix::any_element_is_inf_
 bool
 SparseComplexMatrix::all_elements_are_real (void) const
 {
   return mx_inline_all_real (nnz (), data ());
 }
 
 // Return nonzero if any element of CM has a non-integer real or
 // imaginary part.  Also extract the largest and smallest (real or
-// imaginary) values and return them in MAX_VAL and MIN_VAL. 
+// imaginary) values and return them in MAX_VAL and MIN_VAL.
 
 bool
 SparseComplexMatrix::all_integers (double& max_val, double& min_val) const
 {
   octave_idx_type nel = nnz ();
 
   if (nel == 0)
     return false;
@@ -7347,17 +7347,17 @@ SparseComplexMatrix::cumsum (int dim) co
 
 SparseComplexMatrix
 SparseComplexMatrix::prod (int dim) const
 {
   if ((rows() == 1 && dim == -1) || dim == 1)
     return transpose (). prod (0). transpose();
   else
     {
-      SPARSE_REDUCTION_OP (SparseComplexMatrix, Complex, *=, 
+      SPARSE_REDUCTION_OP (SparseComplexMatrix, Complex, *=,
                            (cidx(j+1) - cidx(j) < nr ? 0.0 : 1.0), 1.0);
     }
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::sum (int dim) const
 {
   SPARSE_REDUCTION_OP (SparseComplexMatrix, Complex, +=, 0.0, 0.0);
@@ -7369,17 +7369,17 @@ SparseComplexMatrix::sumsq (int dim) con
 #define ROW_EXPR \
   Complex d = data (i); \
   tmp [ridx(i)] += d * conj (d)
 
 #define COL_EXPR \
   Complex d = data (i); \
   tmp [j] += d * conj (d)
 
-  SPARSE_BASE_REDUCTION_OP (SparseComplexMatrix, Complex, ROW_EXPR, 
+  SPARSE_BASE_REDUCTION_OP (SparseComplexMatrix, Complex, ROW_EXPR,
                             COL_EXPR, 0.0, 0.0);
 
 #undef ROW_EXPR
 #undef COL_EXPR
 }
 
 SparseMatrix SparseComplexMatrix::abs (void) const
 {
@@ -7645,60 +7645,60 @@ min (const Complex& c, const SparseCompl
   else
     {
       result = SparseComplexMatrix (m);
 
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
           result.data(i) = xmin(c, m.data(i));
     }
-  
+
   return result;
 }
 
 SparseComplexMatrix
 min (const SparseComplexMatrix& m, const Complex& c)
 {
   return min (c, m);
 }
 
 SparseComplexMatrix
 min (const SparseComplexMatrix& a, const SparseComplexMatrix& b)
 {
   SparseComplexMatrix r;
 
-  if ((a.rows() == b.rows()) && (a.cols() == b.cols())) 
+  if ((a.rows() == b.rows()) && (a.cols() == b.cols()))
     {
       octave_idx_type a_nr = a.rows ();
       octave_idx_type a_nc = a.cols ();
 
       octave_idx_type b_nr = b.rows ();
       octave_idx_type b_nc = b.cols ();
 
       if (a_nr == 0 || b_nc == 0 || a.nnz () == 0 || b.nnz () == 0)
         return SparseComplexMatrix (a_nr, a_nc);
 
       if (a_nr != b_nr || a_nc != b_nc)
         gripe_nonconformant ("min", a_nr, a_nc, b_nr, b_nc);
       else
         {
           r = SparseComplexMatrix (a_nr, a_nc, (a.nnz () + b.nnz ()));
-       
+
           octave_idx_type jx = 0;
           r.cidx (0) = 0;
           for (octave_idx_type i = 0 ; i < a_nc ; i++)
             {
               octave_idx_type  ja = a.cidx(i);
               octave_idx_type  ja_max = a.cidx(i+1);
               bool ja_lt_max= ja < ja_max;
-           
+
               octave_idx_type  jb = b.cidx(i);
               octave_idx_type  jb_max = b.cidx(i+1);
               bool jb_lt_max = jb < jb_max;
-           
+
               while (ja_lt_max || jb_lt_max )
                 {
                   octave_quit ();
                   if ((! jb_lt_max) ||
                       (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
                     {
                       Complex tmp = xmin (a.data(ja), 0.);
                       if (tmp != 0.)
@@ -7735,17 +7735,17 @@ min (const SparseComplexMatrix& a, const
                       ja++;
                       ja_lt_max= ja < ja_max;
                       jb++;
                       jb_lt_max= jb < jb_max;
                     }
                 }
               r.cidx(i+1) = jx;
             }
-          
+
           r.maybe_compress ();
         }
     }
   else
     (*current_liboctave_error_handler) ("matrix size mismatch");
 
   return r;
 }
@@ -7780,17 +7780,17 @@ max (const SparseComplexMatrix& m, const
   return max (c, m);
 }
 
 SparseComplexMatrix
 max (const SparseComplexMatrix& a, const SparseComplexMatrix& b)
 {
   SparseComplexMatrix r;
 
-  if ((a.rows() == b.rows()) && (a.cols() == b.cols())) 
+  if ((a.rows() == b.rows()) && (a.cols() == b.cols()))
     {
       octave_idx_type a_nr = a.rows ();
       octave_idx_type a_nc = a.cols ();
 
       octave_idx_type b_nr = b.rows ();
       octave_idx_type b_nc = b.cols ();
 
       if (a_nr == 0 || b_nc == 0)
@@ -7800,29 +7800,29 @@ max (const SparseComplexMatrix& a, const
       if (b.nnz () == 0)
         return SparseComplexMatrix (a);
 
       if (a_nr != b_nr || a_nc != b_nc)
         gripe_nonconformant ("min", a_nr, a_nc, b_nr, b_nc);
       else
         {
           r = SparseComplexMatrix (a_nr, a_nc, (a.nnz () + b.nnz ()));
-       
+
           octave_idx_type jx = 0;
           r.cidx (0) = 0;
           for (octave_idx_type i = 0 ; i < a_nc ; i++)
             {
               octave_idx_type  ja = a.cidx(i);
               octave_idx_type  ja_max = a.cidx(i+1);
               bool ja_lt_max= ja < ja_max;
-           
+
               octave_idx_type  jb = b.cidx(i);
               octave_idx_type  jb_max = b.cidx(i+1);
               bool jb_lt_max = jb < jb_max;
-           
+
               while (ja_lt_max || jb_lt_max )
                 {
                   octave_quit ();
                   if ((! jb_lt_max) ||
                       (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
                     {
                       Complex tmp = xmax (a.data(ja), 0.);
                       if (tmp != 0.)
@@ -7859,29 +7859,29 @@ max (const SparseComplexMatrix& a, const
                       ja++;
                       ja_lt_max= ja < ja_max;
                       jb++;
                       jb_lt_max= jb < jb_max;
                     }
                 }
               r.cidx(i+1) = jx;
             }
-          
+
           r.maybe_compress ();
         }
     }
   else
     (*current_liboctave_error_handler) ("matrix size mismatch");
 
   return r;
 }
 
-SPARSE_SMS_CMP_OPS (SparseComplexMatrix, 0.0, real, Complex, 
+SPARSE_SMS_CMP_OPS (SparseComplexMatrix, 0.0, real, Complex,
                    0.0, real)
 SPARSE_SMS_BOOL_OPS (SparseComplexMatrix, Complex, 0.0)
 
-SPARSE_SSM_CMP_OPS (Complex, 0.0, real, SparseComplexMatrix, 
+SPARSE_SSM_CMP_OPS (Complex, 0.0, real, SparseComplexMatrix,
                    0.0, real)
 SPARSE_SSM_BOOL_OPS (Complex, SparseComplexMatrix, 0.0)
 
-SPARSE_SMSM_CMP_OPS (SparseComplexMatrix, 0.0, real, SparseComplexMatrix, 
+SPARSE_SMSM_CMP_OPS (SparseComplexMatrix, 0.0, real, SparseComplexMatrix,
                      0.0, real)
 SPARSE_SMSM_BOOL_OPS (SparseComplexMatrix, SparseComplexMatrix, 0.0)
diff --git a/liboctave/CSparse.h b/liboctave/CSparse.h
--- a/liboctave/CSparse.h
+++ b/liboctave/CSparse.h
@@ -43,61 +43,61 @@ class ComplexDiagMatrix;
 class SparseMatrix;
 class SparseBoolMatrix;
 
 class
 OCTAVE_API
 SparseComplexMatrix : public MSparse<Complex>
 {
 public:
-  
+
   typedef void (*solve_singularity_handler) (double rcond);
 
   SparseComplexMatrix (void) : MSparse<Complex> () { }
 
   SparseComplexMatrix (octave_idx_type r, octave_idx_type c) : MSparse<Complex> (r, c) { }
 
-  SparseComplexMatrix (const dim_vector& dv, octave_idx_type nz = 0) : 
+  SparseComplexMatrix (const dim_vector& dv, octave_idx_type nz = 0) :
     MSparse<Complex> (dv, nz) { }
 
-  explicit SparseComplexMatrix (octave_idx_type r, octave_idx_type c, Complex val) 
+  explicit SparseComplexMatrix (octave_idx_type r, octave_idx_type c, Complex val)
     : MSparse<Complex> (r, c, val) { }
 
-  SparseComplexMatrix (octave_idx_type r, octave_idx_type c, double val) 
+  SparseComplexMatrix (octave_idx_type r, octave_idx_type c, double val)
     : MSparse<Complex> (r, c, Complex (val)) { }
 
-  SparseComplexMatrix (const SparseComplexMatrix& a) 
+  SparseComplexMatrix (const SparseComplexMatrix& a)
     : MSparse<Complex> (a) { }
 
-  SparseComplexMatrix (const SparseComplexMatrix& a, const dim_vector& dv) 
+  SparseComplexMatrix (const SparseComplexMatrix& a, const dim_vector& dv)
     : MSparse<Complex> (a, dv) { }
 
   SparseComplexMatrix (const MSparse<Complex>& a) : MSparse<Complex> (a) { }
 
   SparseComplexMatrix (const Sparse<Complex>& a) : MSparse<Complex> (a) { }
 
-  explicit SparseComplexMatrix (const ComplexMatrix& a) 
+  explicit SparseComplexMatrix (const ComplexMatrix& a)
     : MSparse<Complex> (a) { }
 
-  explicit SparseComplexMatrix (const ComplexNDArray& a) 
+  explicit SparseComplexMatrix (const ComplexNDArray& a)
     : MSparse<Complex> (a) { }
 
-  SparseComplexMatrix (const Array<Complex>& a, const idx_vector& r, 
-                       const idx_vector& c, octave_idx_type nr = -1, 
+  SparseComplexMatrix (const Array<Complex>& a, const idx_vector& r,
+                       const idx_vector& c, octave_idx_type nr = -1,
                        octave_idx_type nc = -1, bool sum_terms = true,
                        octave_idx_type nzm = -1)
     : MSparse<Complex> (a, r, c, nr, nc, sum_terms, nzm) { }
 
   explicit SparseComplexMatrix (const SparseMatrix& a);
 
   explicit SparseComplexMatrix (const SparseBoolMatrix& a);
 
   explicit SparseComplexMatrix (const ComplexDiagMatrix& a);
 
-  SparseComplexMatrix (octave_idx_type r, octave_idx_type c, octave_idx_type num_nz) 
+  SparseComplexMatrix (octave_idx_type r, octave_idx_type c, octave_idx_type num_nz)
     : MSparse<Complex> (r, c, num_nz) { }
 
   SparseComplexMatrix& operator = (const SparseComplexMatrix& a)
     {
       MSparse<Complex>::operator = (a);
       return *this;
     }
 
@@ -131,280 +131,280 @@ public:
 
   // extract row or column i.
 
   ComplexRowVector row (octave_idx_type i) const;
 
   ComplexColumnVector column (octave_idx_type i) const;
 
 private:
-  SparseComplexMatrix dinverse (MatrixType &mattyp, octave_idx_type& info, 
-                                double& rcond, const bool force = false, 
+  SparseComplexMatrix dinverse (MatrixType &mattyp, octave_idx_type& info,
+                                double& rcond, const bool force = false,
                                 const bool calccond = true) const;
 
-  SparseComplexMatrix tinverse (MatrixType &mattyp, octave_idx_type& info, 
-                                double& rcond, const bool force = false, 
+  SparseComplexMatrix tinverse (MatrixType &mattyp, octave_idx_type& info,
+                                double& rcond, const bool force = false,
                                 const bool calccond = true) const;
 
 public:
   SparseComplexMatrix inverse (void) const;
   SparseComplexMatrix inverse (MatrixType& mattype) const;
-  SparseComplexMatrix inverse (MatrixType& mattype, 
+  SparseComplexMatrix inverse (MatrixType& mattype,
                                octave_idx_type& info) const;
-  SparseComplexMatrix inverse (MatrixType& mattype, octave_idx_type& info, 
-                               double& rcond, int force = 0, 
+  SparseComplexMatrix inverse (MatrixType& mattype, octave_idx_type& info,
+                               double& rcond, int force = 0,
                                int calc_cond = 1) const;
 
   ComplexDET determinant (void) const;
   ComplexDET determinant (octave_idx_type& info) const;
-  ComplexDET determinant (octave_idx_type& info, double& rcond, 
+  ComplexDET determinant (octave_idx_type& info, double& rcond,
                                 int calc_cond = 1) const;
 
 private:
   // Diagonal matrix solvers
-  ComplexMatrix dsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info, 
+  ComplexMatrix dsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
                 double& rcond, solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
-  ComplexMatrix dsolve (MatrixType &typ, const ComplexMatrix& b, 
-                octave_idx_type& info, double& rcond, 
-                solve_singularity_handler sing_handler, 
+  ComplexMatrix dsolve (MatrixType &typ, const ComplexMatrix& b,
+                octave_idx_type& info, double& rcond,
+                solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
-  SparseComplexMatrix dsolve (MatrixType &typ, const SparseMatrix& b, 
+  SparseComplexMatrix dsolve (MatrixType &typ, const SparseMatrix& b,
                 octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
   SparseComplexMatrix dsolve (MatrixType &typ, const SparseComplexMatrix& b,
-                octave_idx_type& info, double& rcond, 
+                octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
   // Upper triangular matrix solvers
   ComplexMatrix utsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
                 double& rcond, solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
-  ComplexMatrix utsolve (MatrixType &typ, const ComplexMatrix& b, 
-                octave_idx_type& info, double& rcond, 
+  ComplexMatrix utsolve (MatrixType &typ, const ComplexMatrix& b,
+                octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
-  SparseComplexMatrix utsolve (MatrixType &typ, const SparseMatrix& b, 
-                octave_idx_type& info, double& rcond, 
+  SparseComplexMatrix utsolve (MatrixType &typ, const SparseMatrix& b,
+                octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
-  SparseComplexMatrix utsolve (MatrixType &typ, const SparseComplexMatrix& b, 
-                octave_idx_type& info, double& rcond, 
+  SparseComplexMatrix utsolve (MatrixType &typ, const SparseComplexMatrix& b,
+                octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
   // Lower triangular matrix solvers
-  ComplexMatrix ltsolve (MatrixType &typ, const Matrix& b, 
-                octave_idx_type& info, double& rcond, 
+  ComplexMatrix ltsolve (MatrixType &typ, const Matrix& b,
+                octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
-  ComplexMatrix ltsolve (MatrixType &typ, const ComplexMatrix& b, 
-                octave_idx_type& info, double& rcond, 
+  ComplexMatrix ltsolve (MatrixType &typ, const ComplexMatrix& b,
+                octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
   SparseComplexMatrix ltsolve (MatrixType &typ, const SparseMatrix& b,
-                octave_idx_type& info, double& rcond, 
+                octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
-  SparseComplexMatrix ltsolve (MatrixType &typ, const SparseComplexMatrix& b, 
-                octave_idx_type& info, double& rcond, 
+  SparseComplexMatrix ltsolve (MatrixType &typ, const SparseComplexMatrix& b,
+                octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
   // Tridiagonal matrix solvers
   ComplexMatrix trisolve (MatrixType &typ, const Matrix& b,
-                octave_idx_type& info, double& rcond, 
+                octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
-  ComplexMatrix trisolve (MatrixType &typ, const ComplexMatrix& b, 
-                octave_idx_type& info, double& rcond, 
+  ComplexMatrix trisolve (MatrixType &typ, const ComplexMatrix& b,
+                octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
   SparseComplexMatrix trisolve (MatrixType &typ, const SparseMatrix& b,
-                octave_idx_type& info, double& rcond, 
+                octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
   SparseComplexMatrix trisolve (MatrixType &typ, const SparseComplexMatrix& b,
-                octave_idx_type& info, double& rcond, 
+                octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
   // Banded matrix solvers (umfpack/cholesky)
   ComplexMatrix bsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
                 double& rcond, solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
-  ComplexMatrix bsolve (MatrixType &typ, const ComplexMatrix& b, 
-                octave_idx_type& info, double& rcond, 
+  ComplexMatrix bsolve (MatrixType &typ, const ComplexMatrix& b,
+                octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
-  SparseComplexMatrix bsolve (MatrixType &typ, const SparseMatrix& b, 
-                octave_idx_type& info, double& rcond, 
+  SparseComplexMatrix bsolve (MatrixType &typ, const SparseMatrix& b,
+                octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
   SparseComplexMatrix bsolve (MatrixType &typ, const SparseComplexMatrix& b,
                 octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
   // Full matrix solvers (umfpack/cholesky)
-  void * factorize (octave_idx_type& err, double &rcond, Matrix &Control, 
+  void * factorize (octave_idx_type& err, double &rcond, Matrix &Control,
                 Matrix &Info, solve_singularity_handler sing_handler,
                 bool calc_cond) const;
 
-  ComplexMatrix fsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info, 
+  ComplexMatrix fsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
                 double& rcond, solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
-  ComplexMatrix fsolve (MatrixType &typ, const ComplexMatrix& b, 
-                octave_idx_type& info, double& rcond, 
+  ComplexMatrix fsolve (MatrixType &typ, const ComplexMatrix& b,
+                octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
-  SparseComplexMatrix fsolve (MatrixType &typ, const SparseMatrix& b, 
-                octave_idx_type& info, double& rcond, 
+  SparseComplexMatrix fsolve (MatrixType &typ, const SparseMatrix& b,
+                octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
   SparseComplexMatrix fsolve (MatrixType &typ, const SparseComplexMatrix& b,
-                octave_idx_type& info, double& rcond, 
+                octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
   ComplexMatrix solve (MatrixType &typ, const Matrix& b) const;
-  ComplexMatrix solve (MatrixType &typ, const Matrix& b, 
+  ComplexMatrix solve (MatrixType &typ, const Matrix& b,
                        octave_idx_type& info) const;
-  ComplexMatrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info, 
+  ComplexMatrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
                        double& rcond) const;
-  ComplexMatrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info, 
+  ComplexMatrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
                        double& rcond, solve_singularity_handler sing_handler,
                        bool singular_fallback = true) const;
 
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b) const;
-  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
+  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b,
                        octave_idx_type& info) const;
-  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
+  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b,
                        octave_idx_type& info, double& rcond) const;
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b,
-                       octave_idx_type& info, double& rcond, 
+                       octave_idx_type& info, double& rcond,
                        solve_singularity_handler sing_handler,
                        bool singular_fallback = true) const;
 
   SparseComplexMatrix solve (MatrixType &typ, const SparseMatrix& b) const;
-  SparseComplexMatrix solve (MatrixType &typ, const SparseMatrix& b, 
+  SparseComplexMatrix solve (MatrixType &typ, const SparseMatrix& b,
                              octave_idx_type& info) const;
-  SparseComplexMatrix solve (MatrixType &typ, const SparseMatrix& b, 
+  SparseComplexMatrix solve (MatrixType &typ, const SparseMatrix& b,
                              octave_idx_type& info, double& rcond) const;
-  SparseComplexMatrix solve (MatrixType &typ, const SparseMatrix& b, 
-                             octave_idx_type& info, double& rcond, 
+  SparseComplexMatrix solve (MatrixType &typ, const SparseMatrix& b,
+                             octave_idx_type& info, double& rcond,
                              solve_singularity_handler sing_handler,
                              bool singular_fallback = true) const;
 
-  SparseComplexMatrix solve (MatrixType &typ, 
+  SparseComplexMatrix solve (MatrixType &typ,
                              const SparseComplexMatrix& b) const;
-  SparseComplexMatrix solve (MatrixType &typ, const SparseComplexMatrix& b, 
+  SparseComplexMatrix solve (MatrixType &typ, const SparseComplexMatrix& b,
                              octave_idx_type& info) const;
-  SparseComplexMatrix solve (MatrixType &typ, const SparseComplexMatrix& b, 
+  SparseComplexMatrix solve (MatrixType &typ, const SparseComplexMatrix& b,
                              octave_idx_type& info, double& rcond) const;
   SparseComplexMatrix solve (MatrixType &typ, const SparseComplexMatrix& b,
-                             octave_idx_type& info, double& rcond, 
+                             octave_idx_type& info, double& rcond,
                              solve_singularity_handler sing_handler,
                              bool singular_fallback = true) const;
 
   ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b) const;
-  ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b, 
+  ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b,
                              octave_idx_type& info) const;
-  ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b, 
+  ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b,
                              octave_idx_type& info, double& rcond) const;
   ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b,
-                             octave_idx_type& info, double& rcond, 
+                             octave_idx_type& info, double& rcond,
                              solve_singularity_handler sing_handler) const;
 
-  ComplexColumnVector solve (MatrixType &typ, 
+  ComplexColumnVector solve (MatrixType &typ,
                              const ComplexColumnVector& b) const;
-  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b, 
+  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b,
                              octave_idx_type& info) const;
   ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b,
                              octave_idx_type& info, double& rcond) const;
   ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b,
                              octave_idx_type& info, double& rcond,
                              solve_singularity_handler sing_handler) const;
 
   // Generic interface to solver with probing of type
   ComplexMatrix solve (const Matrix& b) const;
   ComplexMatrix solve (const Matrix& b, octave_idx_type& info) const;
-  ComplexMatrix solve (const Matrix& b, octave_idx_type& info, 
+  ComplexMatrix solve (const Matrix& b, octave_idx_type& info,
                        double& rcond) const;
-  ComplexMatrix solve (const Matrix& b, octave_idx_type& info, double& rcond, 
+  ComplexMatrix solve (const Matrix& b, octave_idx_type& info, double& rcond,
                        solve_singularity_handler sing_handler) const;
 
   ComplexMatrix solve (const ComplexMatrix& b) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info) const;
-  ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, 
+  ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info,
                        double& rcond) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info,
                        double& rcond, solve_singularity_handler sing_handler) const;
 
   SparseComplexMatrix solve (const SparseMatrix& b) const;
   SparseComplexMatrix solve (const SparseMatrix& b, octave_idx_type& info) const;
-  SparseComplexMatrix solve (const SparseMatrix& b, octave_idx_type& info, 
+  SparseComplexMatrix solve (const SparseMatrix& b, octave_idx_type& info,
                              double& rcond) const;
-  SparseComplexMatrix solve (const SparseMatrix& b, octave_idx_type& info, 
-                             double& rcond, 
+  SparseComplexMatrix solve (const SparseMatrix& b, octave_idx_type& info,
+                             double& rcond,
                              solve_singularity_handler sing_handler) const;
 
   SparseComplexMatrix solve (const SparseComplexMatrix& b) const;
-  SparseComplexMatrix solve (const SparseComplexMatrix& b, 
+  SparseComplexMatrix solve (const SparseComplexMatrix& b,
                              octave_idx_type& info) const;
   SparseComplexMatrix solve (const SparseComplexMatrix& b,
                              octave_idx_type& info, double& rcond) const;
   SparseComplexMatrix solve (const SparseComplexMatrix& b,
                              octave_idx_type& info, double& rcond,
                              solve_singularity_handler sing_handler) const;
 
   ComplexColumnVector solve (const ColumnVector& b) const;
   ComplexColumnVector solve (const ColumnVector& b, octave_idx_type& info) const;
   ComplexColumnVector solve (const ColumnVector& b, octave_idx_type& info,
                              double& rcond) const;
-  ComplexColumnVector solve (const ColumnVector& b, octave_idx_type& info, 
+  ComplexColumnVector solve (const ColumnVector& b, octave_idx_type& info,
                              double& rcond,
                              solve_singularity_handler sing_handler) const;
 
   ComplexColumnVector solve (const ComplexColumnVector& b) const;
-  ComplexColumnVector solve (const ComplexColumnVector& b, 
+  ComplexColumnVector solve (const ComplexColumnVector& b,
                              octave_idx_type& info) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
                              double& rcond) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
                              double& rcond,
                              solve_singularity_handler sing_handler) const;
 
   SparseComplexMatrix squeeze (void) const;
 
   SparseComplexMatrix reshape (const dim_vector& new_dims) const;
 
-  SparseComplexMatrix permute (const Array<octave_idx_type>& vec, 
+  SparseComplexMatrix permute (const Array<octave_idx_type>& vec,
                                bool inv = false) const;
 
   SparseComplexMatrix ipermute (const Array<octave_idx_type>& vec) const;
 
   bool any_element_is_nan (void) const;
   bool any_element_is_inf_or_nan (void) const;
   bool all_elements_are_real (void) const;
   bool all_integers (double& max_val, double& min_val) const;
@@ -420,49 +420,49 @@ public:
   SparseComplexMatrix prod (int dim = -1) const;
   SparseComplexMatrix sum (int dim = -1) const;
   SparseComplexMatrix sumsq (int dim = -1) const;
   SparseMatrix abs (void) const;
 
   SparseComplexMatrix diag (octave_idx_type k = 0) const;
 
   // i/o
-  friend OCTAVE_API std::ostream& operator << (std::ostream& os, 
+  friend OCTAVE_API std::ostream& operator << (std::ostream& os,
                                     const SparseComplexMatrix& a);
-  friend OCTAVE_API std::istream& operator >> (std::istream& is, 
+  friend OCTAVE_API std::istream& operator >> (std::istream& is,
                                     SparseComplexMatrix& a);
 };
 
-extern OCTAVE_API SparseComplexMatrix operator * (const SparseMatrix&,        
+extern OCTAVE_API SparseComplexMatrix operator * (const SparseMatrix&,
                                        const SparseComplexMatrix&);
-extern OCTAVE_API SparseComplexMatrix operator * (const SparseComplexMatrix&, 
+extern OCTAVE_API SparseComplexMatrix operator * (const SparseComplexMatrix&,
                                        const SparseMatrix&);
-extern OCTAVE_API SparseComplexMatrix operator * (const SparseComplexMatrix&, 
+extern OCTAVE_API SparseComplexMatrix operator * (const SparseComplexMatrix&,
                                        const SparseComplexMatrix&);
 
-extern OCTAVE_API ComplexMatrix operator * (const Matrix&,        
+extern OCTAVE_API ComplexMatrix operator * (const Matrix&,
                                        const SparseComplexMatrix&);
-extern OCTAVE_API ComplexMatrix operator * (const ComplexMatrix&, 
+extern OCTAVE_API ComplexMatrix operator * (const ComplexMatrix&,
                                        const SparseMatrix&);
-extern OCTAVE_API ComplexMatrix operator * (const ComplexMatrix&, 
+extern OCTAVE_API ComplexMatrix operator * (const ComplexMatrix&,
                                        const SparseComplexMatrix&);
-extern OCTAVE_API ComplexMatrix mul_trans (const ComplexMatrix&, 
+extern OCTAVE_API ComplexMatrix mul_trans (const ComplexMatrix&,
                                        const SparseComplexMatrix&);
-extern OCTAVE_API ComplexMatrix mul_herm (const ComplexMatrix&, 
+extern OCTAVE_API ComplexMatrix mul_herm (const ComplexMatrix&,
                                        const SparseComplexMatrix&);
 
-extern OCTAVE_API ComplexMatrix operator * (const SparseMatrix&,        
+extern OCTAVE_API ComplexMatrix operator * (const SparseMatrix&,
                                        const ComplexMatrix&);
-extern OCTAVE_API ComplexMatrix operator * (const SparseComplexMatrix&, 
+extern OCTAVE_API ComplexMatrix operator * (const SparseComplexMatrix&,
                                        const Matrix&);
-extern OCTAVE_API ComplexMatrix operator * (const SparseComplexMatrix&, 
+extern OCTAVE_API ComplexMatrix operator * (const SparseComplexMatrix&,
                                        const ComplexMatrix&);
-extern OCTAVE_API ComplexMatrix trans_mul (const SparseComplexMatrix&, 
+extern OCTAVE_API ComplexMatrix trans_mul (const SparseComplexMatrix&,
                                        const ComplexMatrix&);
-extern OCTAVE_API ComplexMatrix herm_mul (const SparseComplexMatrix&, 
+extern OCTAVE_API ComplexMatrix herm_mul (const SparseComplexMatrix&,
                                        const ComplexMatrix&);
 
 extern OCTAVE_API SparseComplexMatrix operator * (const DiagMatrix&, const SparseComplexMatrix&);
 extern OCTAVE_API SparseComplexMatrix operator * (const SparseComplexMatrix&, const DiagMatrix&);
 
 extern OCTAVE_API SparseComplexMatrix operator * (const ComplexDiagMatrix&, const SparseMatrix&);
 extern OCTAVE_API SparseComplexMatrix operator * (const SparseMatrix&, const ComplexDiagMatrix&);
 
@@ -483,28 +483,28 @@ extern OCTAVE_API SparseComplexMatrix op
 extern OCTAVE_API SparseComplexMatrix operator - (const SparseComplexMatrix&, const DiagMatrix&);
 extern OCTAVE_API SparseComplexMatrix operator - (const SparseComplexMatrix&, const ComplexDiagMatrix&);
 
 extern OCTAVE_API SparseComplexMatrix operator * (const PermMatrix&,
                                                   const SparseComplexMatrix&);
 extern OCTAVE_API SparseComplexMatrix operator * (const SparseComplexMatrix&,
                                                   const PermMatrix&);
 
-extern OCTAVE_API SparseComplexMatrix min (const Complex& c, 
+extern OCTAVE_API SparseComplexMatrix min (const Complex& c,
                                 const SparseComplexMatrix& m);
-extern OCTAVE_API SparseComplexMatrix min (const SparseComplexMatrix& m, 
+extern OCTAVE_API SparseComplexMatrix min (const SparseComplexMatrix& m,
                                 const Complex& c);
-extern OCTAVE_API SparseComplexMatrix min (const SparseComplexMatrix& a, 
+extern OCTAVE_API SparseComplexMatrix min (const SparseComplexMatrix& a,
                                 const SparseComplexMatrix& b);
 
-extern OCTAVE_API SparseComplexMatrix max (const Complex& c, 
+extern OCTAVE_API SparseComplexMatrix max (const Complex& c,
                                 const SparseComplexMatrix& m);
-extern OCTAVE_API SparseComplexMatrix max (const SparseComplexMatrix& m, 
+extern OCTAVE_API SparseComplexMatrix max (const SparseComplexMatrix& m,
                                 const Complex& c);
-extern OCTAVE_API SparseComplexMatrix max (const SparseComplexMatrix& a, 
+extern OCTAVE_API SparseComplexMatrix max (const SparseComplexMatrix& a,
                                 const SparseComplexMatrix& b);
 
 SPARSE_SMS_CMP_OP_DECLS (SparseComplexMatrix, Complex, OCTAVE_API)
 SPARSE_SMS_BOOL_OP_DECLS (SparseComplexMatrix, Complex, OCTAVE_API)
 
 SPARSE_SSM_CMP_OP_DECLS (Complex, SparseComplexMatrix, OCTAVE_API)
 SPARSE_SSM_BOOL_OP_DECLS (Complex, SparseComplexMatrix, OCTAVE_API)
 
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,61 @@
+2011-01-20  John W. Eaton  <jwe@octave.org>
+
+	* Array-b.cc, Array-d.cc, Array-f.cc, Array-util.cc,
+	Array-util.h, Array.cc, Array.h, Array3.h, CColVector.cc,
+	CColVector.h, CDiagMatrix.cc, CDiagMatrix.h, CMatrix.cc,
+	CMatrix.h, CNDArray.cc, CNDArray.h, CSparse.cc, CSparse.h,
+	CmplxAEPBAL.cc, CmplxAEPBAL.h, CmplxCHOL.cc, CmplxGEPBAL.cc,
+	CmplxGEPBAL.h, CmplxHESS.cc, CmplxLU.h, CmplxQR.cc, CmplxQR.h,
+	CmplxSCHUR.cc, CmplxSVD.h, CollocWt.cc, CollocWt.h, DASPK.cc,
+	DASPK.h, DASRT.cc, DASRT.h, DASSL.cc, DASSL.h, DET.h,
+	DiagArray2.h, EIG.cc, LSODE.cc, MArray.cc, MArray.h,
+	MDiagArray2.cc, MDiagArray2.h, MSparse.cc, MSparse.h,
+	MatrixType.cc, MatrixType.h, ODESFunc.h, PermMatrix.cc,
+	PermMatrix.h, Quad.cc, Range.cc, Sparse.cc, Sparse.h,
+	SparseCmplxCHOL.cc, SparseCmplxCHOL.h, SparseCmplxLU.cc,
+	SparseCmplxLU.h, SparseCmplxQR.cc, SparseCmplxQR.h, SparseQR.cc,
+	SparseQR.h, SparsedbleCHOL.cc, SparsedbleCHOL.h,
+	SparsedbleLU.cc, SparsedbleLU.h, base-aepbal.h, base-de.h,
+	base-lu.cc, base-lu.h, boolNDArray.cc, boolNDArray.h,
+	boolSparse.cc, boolSparse.h, bsxfun-defs.cc, chMatrix.cc,
+	chNDArray.cc, chNDArray.h, cmd-edit.cc, cmd-edit.h, cmd-hist.cc,
+	dColVector.h, dDiagMatrix.cc, dDiagMatrix.h, dMatrix.cc,
+	dMatrix.h, dNDArray.cc, dNDArray.h, dSparse.cc, dSparse.h,
+	dbleAEPBAL.h, dbleCHOL.cc, dbleCHOL.h, dbleGEPBAL.cc,
+	dbleGEPBAL.h, dbleQR.cc, dbleQR.h, dbleSCHUR.h, dbleSVD.h,
+	dim-vector.cc, dim-vector.h, dir-ops.cc, eigs-base.cc,
+	f2c-main.c, fCColVector.cc, fCColVector.h, fCDiagMatrix.cc,
+	fCDiagMatrix.h, fCMatrix.cc, fCMatrix.h, fCNDArray.cc,
+	fCNDArray.h, fCRowVector.cc, fCRowVector.h, fCmplxAEPBAL.cc,
+	fCmplxAEPBAL.h, fCmplxCHOL.cc, fCmplxGEPBAL.cc, fCmplxGEPBAL.h,
+	fCmplxHESS.cc, fCmplxLU.h, fCmplxQR.cc, fCmplxQR.h,
+	fCmplxQRP.cc, fCmplxSCHUR.cc, fCmplxSVD.h, fColVector.h,
+	fDiagMatrix.cc, fDiagMatrix.h, fEIG.cc, fMatrix.cc, fMatrix.h,
+	fNDArray.cc, fNDArray.h, file-ops.cc, file-stat.cc,
+	floatAEPBAL.cc, floatAEPBAL.h, floatCHOL.cc, floatCHOL.h,
+	floatGEPBAL.cc, floatGEPBAL.h, floatLU.h, floatQR.cc, floatQR.h,
+	floatQRP.cc, floatSCHUR.h, floatSVD.h, idx-vector.cc,
+	idx-vector.h, intNDArray.cc, intNDArray.h, kpse.cc,
+	lo-array-gripes.cc, lo-array-gripes.h, lo-cieee.c, lo-ieee.h,
+	lo-mappers.cc, lo-mappers.h, lo-specfun.cc, mx-defs.h,
+	mx-inlines.cc, oct-binmap.h, oct-convn.cc, oct-env.cc,
+	oct-fftw.cc, oct-fftw.h, oct-glob.cc, oct-group.h,
+	oct-inttypes.cc, oct-inttypes.h, oct-locbuf.cc, oct-locbuf.h,
+	oct-md5.cc, oct-mem.h, oct-norm.cc, oct-norm.h, oct-rand.cc,
+	oct-rand.h, oct-rl-hist.c, oct-shlib.cc, oct-shlib.h,
+	oct-sort.cc, oct-sort.h, oct-spparms.cc, oct-spparms.h,
+	oct-syscalls.cc, oct-time.cc, randgamma.c, randmtzig.c,
+	randmtzig.h, randpoisson.c, regex-match.cc, regex-match.h,
+	sparse-base-chol.cc, sparse-base-chol.h, sparse-base-lu.cc,
+	sparse-base-lu.h, sparse-dmsolve.cc, sparse-sort.cc,
+	sparse-sort.h, sparse-util.h, tempname.c:
+	Strip trailing whitespace.
+
 2011-01-20  John W. Eaton  <jwe@octave.org>
 
 	* Array.h, Array.cc
 	(Array<T>::resize2 (octave_idx_type, octave_idx_type, const T&)):
 	New private function.
 	(Array<T>::resize (octave_idx_type, octave_idx_type, const T&)):
 	Deprecate.  Call resize2 to do the work.  Remove all uses from
 	Octave.
diff --git a/liboctave/CmplxAEPBAL.cc b/liboctave/CmplxAEPBAL.cc
--- a/liboctave/CmplxAEPBAL.cc
+++ b/liboctave/CmplxAEPBAL.cc
@@ -34,29 +34,29 @@ along with Octave; see the file COPYING.
 extern "C"
 {
   F77_RET_T
   F77_FUNC (zgebal, ZGEBAL) (F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&, Complex*,
                              const octave_idx_type&, octave_idx_type&,
                              octave_idx_type&, double*, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL);
- 
+
   F77_RET_T
   F77_FUNC (zgebak, ZGEBAK) (F77_CONST_CHAR_ARG_DECL,
                              F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&, const octave_idx_type&,
                              const octave_idx_type&, const double*,
                              const octave_idx_type&, Complex*,
                              const octave_idx_type&, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 }
 
-ComplexAEPBALANCE::ComplexAEPBALANCE (const ComplexMatrix& a, 
+ComplexAEPBALANCE::ComplexAEPBALANCE (const ComplexMatrix& a,
                                       bool noperm, bool noscal)
   : base_aepbal<ComplexMatrix, ColumnVector> ()
 {
   octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
     {
       (*current_liboctave_error_handler) ("AEPBALANCE requires square matrix");
diff --git a/liboctave/CmplxAEPBAL.h b/liboctave/CmplxAEPBAL.h
--- a/liboctave/CmplxAEPBAL.h
+++ b/liboctave/CmplxAEPBAL.h
@@ -37,15 +37,15 @@ ComplexAEPBALANCE : public base_aepbal<C
 {
 public:
 
   ComplexAEPBALANCE (void) : base_aepbal<ComplexMatrix, ColumnVector> () { }
 
   ComplexAEPBALANCE (const ComplexMatrix& a, bool noperm = false,
                      bool noscal = false);
 
-  ComplexAEPBALANCE (const ComplexAEPBALANCE& a) 
+  ComplexAEPBALANCE (const ComplexAEPBALANCE& a)
     : base_aepbal<ComplexMatrix, ColumnVector> (a) { }
 
   ComplexMatrix balancing_matrix (void) const;
 };
 
 #endif
diff --git a/liboctave/CmplxCHOL.cc b/liboctave/CmplxCHOL.cc
--- a/liboctave/CmplxCHOL.cc
+++ b/liboctave/CmplxCHOL.cc
@@ -108,39 +108,39 @@ ComplexCHOL::init (const ComplexMatrix& 
         chol_mat.xelem (i, j) = a(i, j);
       for (octave_idx_type i = j+1; i < n; i++)
         chol_mat.xelem (i, j) = 0.0;
     }
   Complex *h = chol_mat.fortran_vec ();
 
   // Calculate the norm of the matrix, for later use.
   double anorm = 0;
-  if (calc_cond) 
+  if (calc_cond)
     anorm = xnorm (a, 1);
 
   F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 ("U", 1), n, h, n, info
                              F77_CHAR_ARG_LEN (1)));
 
   xrcond = 0.0;
   if (info > 0)
     chol_mat.resize (info - 1, info - 1);
-  else if (calc_cond) 
+  else if (calc_cond)
     {
       octave_idx_type zpocon_info = 0;
 
       // Now calculate the condition number for non-singular matrix.
       Array<Complex> z (dim_vector (2*n, 1));
       Complex *pz = z.fortran_vec ();
       Array<double> rz (dim_vector (n, 1));
       double *prz = rz.fortran_vec ();
       F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 ("U", 1), n, h,
                                  n, anorm, xrcond, pz, prz, zpocon_info
                                  F77_CHAR_ARG_LEN (1)));
 
-      if (zpocon_info != 0) 
+      if (zpocon_info != 0)
         info = -1;
     }
 
   return info;
 }
 
 static ComplexMatrix
 chol2inv_internal (const ComplexMatrix& r)
@@ -182,17 +182,17 @@ ComplexMatrix
 ComplexCHOL::inverse (void) const
 {
   return chol2inv_internal (chol_mat);
 }
 
 void
 ComplexCHOL::set (const ComplexMatrix& R)
 {
-  if (R.is_square ()) 
+  if (R.is_square ())
     chol_mat = R;
   else
     (*current_liboctave_error_handler) ("CHOL requires square matrix");
 }
 
 #ifdef HAVE_QRUPDATE
 
 void
@@ -236,17 +236,17 @@ ComplexCHOL::downdate (const ComplexColu
 }
 
 octave_idx_type
 ComplexCHOL::insert_sym (const ComplexColumnVector& u, octave_idx_type j)
 {
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
-  
+
   if (u.length () != n + 1)
     (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
   else if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("cholinsert: index out of range");
   else
     {
       ComplexColumnVector utmp = u;
 
@@ -260,36 +260,36 @@ ComplexCHOL::insert_sym (const ComplexCo
 
   return info;
 }
 
 void
 ComplexCHOL::delete_sym (octave_idx_type j)
 {
   octave_idx_type n = chol_mat.rows ();
-  
+
   if (j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("choldelete: index out of range");
   else
     {
       OCTAVE_LOCAL_BUFFER (double, rw, n);
 
-      F77_XFCN (zchdex, ZCHDEX, (n, chol_mat.fortran_vec (), chol_mat.rows (), 
+      F77_XFCN (zchdex, ZCHDEX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
                                  j + 1, rw));
 
       chol_mat.resize (n-1, n-1);
     }
 }
 
 void
 ComplexCHOL::shift_sym (octave_idx_type i, octave_idx_type j)
 {
   octave_idx_type n = chol_mat.rows ();
-  
-  if (i < 0 || i > n-1 || j < 0 || j > n-1) 
+
+  if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("cholshift: index out of range");
   else
     {
       OCTAVE_LOCAL_BUFFER (Complex, w, n);
       OCTAVE_LOCAL_BUFFER (double, rw, n);
 
       F77_XFCN (zchshx, ZCHSHX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
                                  i + 1, j + 1, w, rw));
@@ -302,17 +302,17 @@ void
 ComplexCHOL::update (const ComplexColumnVector& u)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = chol_mat.rows ();
 
   if (u.length () == n)
     {
-      init (chol_mat.hermitian () * chol_mat 
+      init (chol_mat.hermitian () * chol_mat
             + ComplexMatrix (u) * ComplexMatrix (u).hermitian (), false);
     }
   else
     (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 }
 
 static bool
 singular (const ComplexMatrix& a)
@@ -332,17 +332,17 @@ ComplexCHOL::downdate (const ComplexColu
   octave_idx_type n = chol_mat.rows ();
 
   if (u.length () == n)
     {
       if (singular (chol_mat))
         info = 2;
       else
         {
-          info = init (chol_mat.hermitian () * chol_mat 
+          info = init (chol_mat.hermitian () * chol_mat
                        - ComplexMatrix (u) * ComplexMatrix (u).hermitian (), false);
           if (info) info = 1;
         }
     }
   else
     (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
   return info;
@@ -351,17 +351,17 @@ ComplexCHOL::downdate (const ComplexColu
 octave_idx_type
 ComplexCHOL::insert_sym (const ComplexColumnVector& u, octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
-  
+
   if (u.length () != n + 1)
     (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
   else if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("cholinsert: index out of range");
   else
     {
       if (singular (chol_mat))
         info = 2;
@@ -390,17 +390,17 @@ ComplexCHOL::insert_sym (const ComplexCo
 }
 
 void
 ComplexCHOL::delete_sym (octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = chol_mat.rows ();
-  
+
   if (j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("choldelete: index out of range");
   else
     {
       ComplexMatrix a = chol_mat.hermitian () * chol_mat;
       a.delete_elements (1, idx_vector (j));
       a.delete_elements (0, idx_vector (j));
       init (a, false);
@@ -408,18 +408,18 @@ ComplexCHOL::delete_sym (octave_idx_type
 }
 
 void
 ComplexCHOL::shift_sym (octave_idx_type i, octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = chol_mat.rows ();
-  
-  if (i < 0 || i > n-1 || j < 0 || j > n-1) 
+
+  if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("cholshift: index out of range");
   else
     {
       ComplexMatrix a = chol_mat.hermitian () * chol_mat;
       Array<octave_idx_type> p (dim_vector (n, 1));
       for (octave_idx_type k = 0; k < n; k++) p(k) = k;
       if (i < j)
         {
diff --git a/liboctave/CmplxGEPBAL.cc b/liboctave/CmplxGEPBAL.cc
--- a/liboctave/CmplxGEPBAL.cc
+++ b/liboctave/CmplxGEPBAL.cc
@@ -54,32 +54,32 @@ extern "C"
                              octave_idx_type& M, double* V,
                              const octave_idx_type& LDV, octave_idx_type& INFO
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
 }
 
 octave_idx_type
-ComplexGEPBALANCE::init (const ComplexMatrix& a, const ComplexMatrix& b, 
+ComplexGEPBALANCE::init (const ComplexMatrix& a, const ComplexMatrix& b,
                   const std::string& balance_job)
 {
   octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
     {
       (*current_liboctave_error_handler) ("ComplexGEPBALANCE requires square matrix");
       return -1;
     }
 
   if (a.dims() != b.dims ())
     {
       gripe_nonconformant ("ComplexGEPBALANCE", n, n, b.rows(), b.cols());
       return -1;
-    } 
+    }
 
   octave_idx_type info;
   octave_idx_type ilo;
   octave_idx_type ihi;
 
   OCTAVE_LOCAL_BUFFER (double, plscale, n);
   OCTAVE_LOCAL_BUFFER (double, prscale,  n);
   OCTAVE_LOCAL_BUFFER (double, pwork, 6 * n);
@@ -110,17 +110,17 @@ ComplexGEPBALANCE::init (const ComplexMa
 
   // first left
   F77_XFCN (dggbak, DGGBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
                              F77_CONST_CHAR_ARG2 ("L", 1),
                              n, ilo, ihi, plscale, prscale,
                              n, p_balancing_mat, n, info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
-      
+
   // then right
   F77_XFCN (dggbak, DGGBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
                              F77_CONST_CHAR_ARG2 ("R", 1),
                              n, ilo, ihi, plscale, prscale,
                              n, p_balancing_mat2, n, info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
diff --git a/liboctave/CmplxGEPBAL.h b/liboctave/CmplxGEPBAL.h
--- a/liboctave/CmplxGEPBAL.h
+++ b/liboctave/CmplxGEPBAL.h
@@ -38,17 +38,17 @@ public:
   ComplexGEPBALANCE (void)
     : balanced_mat (), balanced_mat2 (), balancing_mat (), balancing_mat2 ()
     { }
 
   ComplexGEPBALANCE (const ComplexMatrix& a, const ComplexMatrix& b,
                      const std::string& balance_job)
     : balanced_mat (), balanced_mat2 (), balancing_mat (), balancing_mat2 ()
     {
-      init (a, b, balance_job); 
+      init (a, b, balance_job);
     }
 
   ComplexGEPBALANCE (const ComplexGEPBALANCE& a)
     : balanced_mat (a.balanced_mat), balanced_mat2 (a.balanced_mat2),
       balancing_mat (a.balancing_mat), balancing_mat2 (a.balancing_mat2) { }
 
   ComplexGEPBALANCE& operator = (const ComplexGEPBALANCE& a)
     {
@@ -76,13 +76,13 @@ public:
 
 private:
 
   ComplexMatrix balanced_mat;
   ComplexMatrix balanced_mat2;
   Matrix balancing_mat;
   Matrix balancing_mat2;
 
-  octave_idx_type init (const ComplexMatrix& a, const ComplexMatrix& b, 
+  octave_idx_type init (const ComplexMatrix& a, const ComplexMatrix& b,
                         const std::string& balance_job);
 };
 
 #endif
diff --git a/liboctave/CmplxHESS.cc b/liboctave/CmplxHESS.cc
--- a/liboctave/CmplxHESS.cc
+++ b/liboctave/CmplxHESS.cc
@@ -31,23 +31,23 @@ along with Octave; see the file COPYING.
 extern "C"
 {
   F77_RET_T
   F77_FUNC (zgebal, ZGEBAL) (F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&, Complex*,
                              const octave_idx_type&, octave_idx_type&,
                              octave_idx_type&, double*, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL);
- 
+
   F77_RET_T
   F77_FUNC (zgehrd, ZGEHRD) (const octave_idx_type&, const octave_idx_type&,
                              const octave_idx_type&, Complex*,
                              const octave_idx_type&, Complex*, Complex*,
                              const octave_idx_type&, octave_idx_type&);
- 
+
   F77_RET_T
   F77_FUNC (zunghr, ZUNGHR) (const octave_idx_type&, const octave_idx_type&,
                              const octave_idx_type&, Complex*,
                              const octave_idx_type&, Complex*, Complex*,
                              const octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (zgebak, ZGEBAK) (F77_CONST_CHAR_ARG_DECL,
diff --git a/liboctave/CmplxLU.h b/liboctave/CmplxLU.h
--- a/liboctave/CmplxLU.h
+++ b/liboctave/CmplxLU.h
@@ -36,17 +36,17 @@ public:
   ComplexLU (void)
     : base_lu <ComplexMatrix> () { }
 
   ComplexLU (const ComplexMatrix& a);
 
   ComplexLU (const ComplexLU& a)
     : base_lu <ComplexMatrix> (a) { }
 
-  ComplexLU (const ComplexMatrix& l, const ComplexMatrix& u, 
+  ComplexLU (const ComplexMatrix& l, const ComplexMatrix& u,
              const PermMatrix& p)
     : base_lu <ComplexMatrix> (l, u, p) { }
 
   ComplexLU& operator = (const ComplexLU& a)
     {
       if (this != &a)
         base_lu <ComplexMatrix> :: operator = (a);
 
diff --git a/liboctave/CmplxQR.cc b/liboctave/CmplxQR.cc
--- a/liboctave/CmplxQR.cc
+++ b/liboctave/CmplxQR.cc
@@ -38,17 +38,17 @@ along with Octave; see the file COPYING.
 template class base_qr<ComplexMatrix>;
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (zgeqrf, ZGEQRF) (const octave_idx_type&, const octave_idx_type&,
                              Complex*, const octave_idx_type&, Complex*,
                              Complex*, const octave_idx_type&,
-                             octave_idx_type&); 
+                             octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (zungqr, ZUNGQR) (const octave_idx_type&, const octave_idx_type&,
                              const octave_idx_type&, Complex*,
                              const octave_idx_type&, Complex*, Complex*,
                              const octave_idx_type&, octave_idx_type&);
 
 #ifdef HAVE_QRUPDATE
@@ -70,23 +70,23 @@ extern "C"
   F77_RET_T
   F77_FUNC (zqrdec, ZQRDEC) (const octave_idx_type&, const octave_idx_type&,
                              const octave_idx_type&, Complex*,
                              const octave_idx_type&, Complex*,
                              const octave_idx_type&, const octave_idx_type&,
                              double*);
 
   F77_RET_T
-  F77_FUNC (zqrinr, ZQRINR) (const octave_idx_type&, const octave_idx_type&, 
+  F77_FUNC (zqrinr, ZQRINR) (const octave_idx_type&, const octave_idx_type&,
                              Complex*, const octave_idx_type&, Complex*,
                              const octave_idx_type&, const octave_idx_type&,
                              const Complex*, double*);
 
   F77_RET_T
-  F77_FUNC (zqrder, ZQRDER) (const octave_idx_type&, const octave_idx_type&, 
+  F77_FUNC (zqrder, ZQRDER) (const octave_idx_type&, const octave_idx_type&,
                              Complex*, const octave_idx_type&, Complex*,
                              const octave_idx_type&, const octave_idx_type&,
                              Complex*, double*);
 
   F77_RET_T
   F77_FUNC (zqrshc, ZQRSHC) (const octave_idx_type&, const octave_idx_type&,
                              const octave_idx_type&, Complex*,
                              const octave_idx_type&, Complex*,
@@ -127,17 +127,17 @@ ComplexQR::init (const ComplexMatrix& a,
       lwork = std::max (lwork, static_cast<octave_idx_type> (1));
       OCTAVE_LOCAL_BUFFER (Complex, work, lwork);
       F77_XFCN (zgeqrf, ZGEQRF, (m, n, afact.fortran_vec (), m, tau, work, lwork, info));
     }
 
   form (n, afact, tau, qr_type);
 }
 
-void ComplexQR::form (octave_idx_type n, ComplexMatrix& afact, 
+void ComplexQR::form (octave_idx_type n, ComplexMatrix& afact,
                       Complex *tau, qr_type_t qr_type)
 {
   octave_idx_type m = afact.rows (), min_mn = std::min (m, n);
   octave_idx_type info;
 
   if (qr_type == qr_type_raw)
     {
       for (octave_idx_type j = 0; j < min_mn; j++)
@@ -247,34 +247,34 @@ void
 ComplexQR::insert_col (const ComplexColumnVector& u, octave_idx_type j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
   if (u.length () != m)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (j < 0 || j > n) 
+  else if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       if (k < m)
         {
           q.resize (m, k+1);
           r.resize (k+1, n+1);
         }
       else
         {
           r.resize (k, n+1);
         }
 
       ComplexColumnVector utmp = u;
       OCTAVE_LOCAL_BUFFER (double, rw, k);
       F77_XFCN (zqrinc, ZQRINC, (m, n, k, q.fortran_vec (), q.rows (),
-                                 r.fortran_vec (), r.rows (), j + 1, 
+                                 r.fortran_vec (), r.rows (), j + 1,
                                  utmp.data (), rw));
     }
 }
 
 void
 ComplexQR::insert_col (const ComplexMatrix& u, const Array<octave_idx_type>& j)
 {
   octave_idx_type m = q.rows ();
@@ -307,32 +307,32 @@ ComplexQR::insert_col (const ComplexMatr
           r.resize (k, n + nj);
         }
 
       OCTAVE_LOCAL_BUFFER (double, rw, kmax);
       for (volatile octave_idx_type i = 0; i < js.length (); i++)
         {
           octave_idx_type ii = i;
           ComplexColumnVector utmp = u.column (jsi(i));
-          F77_XFCN (zqrinc, ZQRINC, (m, n + ii, std::min (kmax, k + ii), 
+          F77_XFCN (zqrinc, ZQRINC, (m, n + ii, std::min (kmax, k + ii),
                                      q.fortran_vec (), q.rows (),
-                                     r.fortran_vec (), r.rows (), js(ii) + 1, 
+                                     r.fortran_vec (), r.rows (), js(ii) + 1,
                                      utmp.data (), rw));
         }
     }
 }
 
 void
 ComplexQR::delete_col (octave_idx_type j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type k = r.rows ();
   octave_idx_type n = r.columns ();
 
-  if (j < 0 || j > n-1) 
+  if (j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
   else
     {
       OCTAVE_LOCAL_BUFFER (double, rw, k);
       F77_XFCN (zqrdec, ZQRDEC, (m, n, k, q.fortran_vec (), q.rows (),
                                  r.fortran_vec (), r.rows (), j + 1, rw));
 
       if (k < m)
@@ -366,17 +366,17 @@ ComplexQR::delete_col (const Array<octav
   else if (nj > 0 && (js(0) > n-1 || js(nj-1) < 0))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else if (nj > 0)
     {
       OCTAVE_LOCAL_BUFFER (double, rw, k);
       for (volatile octave_idx_type i = 0; i < js.length (); i++)
         {
           octave_idx_type ii = i;
-          F77_XFCN (zqrdec, ZQRDEC, (m, n - ii, k == m ? k : k - ii, 
+          F77_XFCN (zqrdec, ZQRDEC, (m, n - ii, k == m ? k : k - ii,
                                      q.fortran_vec (), q.rows (),
                                      r.fortran_vec (), r.rows (), js(ii) + 1, rw));
         }
       if (k < m)
         {
           q.resize (m, k - nj);
           r.resize (k - nj, n - nj);
         }
@@ -392,40 +392,40 @@ void
 ComplexQR::insert_row (const ComplexRowVector& u, octave_idx_type j)
 {
   octave_idx_type m = r.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = std::min (m, n);
 
   if (! q.is_square () || u.length () != n)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (j < 0 || j > m) 
+  else if (j < 0 || j > m)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       q.resize (m + 1, m + 1);
       r.resize (m + 1, n);
       ComplexRowVector utmp = u;
       OCTAVE_LOCAL_BUFFER (double, rw, k);
       F77_XFCN (zqrinr, ZQRINR, (m, n, q.fortran_vec (), q.rows (),
-                                 r.fortran_vec (), r.rows (), 
+                                 r.fortran_vec (), r.rows (),
                                  j + 1, utmp.fortran_vec (), rw));
 
     }
 }
 
 void
 ComplexQR::delete_row (octave_idx_type j)
 {
   octave_idx_type m = r.rows ();
   octave_idx_type n = r.columns ();
 
   if (! q.is_square ())
     (*current_liboctave_error_handler) ("qrdelete: dimensions mismatch");
-  else if (j < 0 || j > m-1) 
+  else if (j < 0 || j > m-1)
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
   else
     {
       OCTAVE_LOCAL_BUFFER (Complex, w, m);
       OCTAVE_LOCAL_BUFFER (double, rw, m);
       F77_XFCN (zqrder, ZQRDER, (m, n, q.fortran_vec (), q.rows (),
                                  r.fortran_vec (), r.rows (), j + 1,
                                  w, rw));
@@ -437,23 +437,23 @@ ComplexQR::delete_row (octave_idx_type j
 
 void
 ComplexQR::shift_cols (octave_idx_type i, octave_idx_type j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type k = r.rows ();
   octave_idx_type n = r.columns ();
 
-  if (i < 0 || i > n-1 || j < 0 || j > n-1) 
+  if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("qrshift: index out of range");
   else
     {
       OCTAVE_LOCAL_BUFFER (Complex, w, k);
       OCTAVE_LOCAL_BUFFER (double, rw, k);
-      F77_XFCN (zqrshc, ZQRSHC, (m, n, k, 
+      F77_XFCN (zqrshc, ZQRSHC, (m, n, k,
                                  q.fortran_vec (), q.rows (),
                                  r.fortran_vec (), r.rows (),
                                  i + 1, j + 1, w, rw));
     }
 }
 
 #else
 
@@ -529,17 +529,17 @@ static
 ComplexMatrix delete_row (const ComplexMatrix& a, octave_idx_type i)
 {
   ComplexMatrix retval = a;
   retval.delete_elements (0, idx_vector (i));
   return retval;
 }
 
 static
-ComplexMatrix shift_cols (const ComplexMatrix& a, 
+ComplexMatrix shift_cols (const ComplexMatrix& a,
                           octave_idx_type i, octave_idx_type j)
 {
   octave_idx_type n = a.columns ();
   Array<octave_idx_type> p (n);
   for (octave_idx_type k = 0; k < n; k++) p(k) = k;
   if (i < j)
     {
       for (octave_idx_type k = i; k < j; k++) p(k) = k+1;
@@ -559,17 +559,17 @@ ComplexQR::insert_col (const ComplexColu
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
   if (u.length () != m)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (j < 0 || j > n) 
+  else if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       init (::insert_col (q*r, j, u), get_type ());
     }
 }
 
 void
@@ -605,17 +605,17 @@ ComplexQR::insert_col (const ComplexMatr
 void
 ComplexQR::delete_col (octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
-  if (j < 0 || j > n-1) 
+  if (j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
   else
     {
       init (::delete_col (q*r, j), get_type ());
     }
 }
 
 void
@@ -651,17 +651,17 @@ ComplexQR::insert_row (const ComplexRowV
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = r.rows ();
   octave_idx_type n = r.columns ();
 
   if (! q.is_square () || u.length () != n)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (j < 0 || j > m) 
+  else if (j < 0 || j > m)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       init (::insert_row (q*r, j, u), get_type ());
     }
 }
 
 void
@@ -669,33 +669,33 @@ ComplexQR::delete_row (octave_idx_type j
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = r.rows ();
   octave_idx_type n = r.columns ();
 
   if (! q.is_square ())
     (*current_liboctave_error_handler) ("qrdelete: dimensions mismatch");
-  else if (j < 0 || j > m-1) 
+  else if (j < 0 || j > m-1)
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
   else
     {
       init (::delete_row (q*r, j), get_type ());
     }
 }
 
 void
 ComplexQR::shift_cols (octave_idx_type i, octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
-  if (i < 0 || i > n-1 || j < 0 || j > n-1) 
+  if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("qrshift: index out of range");
   else
     {
       init (::shift_cols (q*r, i, j), get_type ());
     }
 }
 
 #endif
diff --git a/liboctave/CmplxQR.h b/liboctave/CmplxQR.h
--- a/liboctave/CmplxQR.h
+++ b/liboctave/CmplxQR.h
@@ -1,12 +1,12 @@
 /*
 
 Copyright (C) 1994-2011 John W. Eaton
-Copyright (C) 2008-2009 Jaroslav Hajek              
+Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -37,17 +37,17 @@ OCTAVE_API
 ComplexQR : public base_qr<ComplexMatrix>
 {
 public:
 
   ComplexQR (void) : base_qr<ComplexMatrix> () { }
 
   ComplexQR (const ComplexMatrix&, qr_type_t = qr_type_std);
 
-  ComplexQR (const ComplexMatrix& qx, const ComplexMatrix& rx) 
+  ComplexQR (const ComplexMatrix& qx, const ComplexMatrix& rx)
     : base_qr<ComplexMatrix> (qx, rx) { }
 
   ComplexQR (const ComplexQR& a) : base_qr<ComplexMatrix> (a) { }
 
   void init (const ComplexMatrix&, qr_type_t = qr_type_std);
 
   void update (const ComplexColumnVector& u, const ComplexColumnVector& v);
 
@@ -64,13 +64,13 @@ public:
   void insert_row (const ComplexRowVector& u, octave_idx_type j);
 
   void delete_row (octave_idx_type j);
 
   void shift_cols (octave_idx_type i, octave_idx_type j);
 
 protected:
 
-  void form (octave_idx_type n, ComplexMatrix& afact, 
+  void form (octave_idx_type n, ComplexMatrix& afact,
              Complex *tau, qr_type_t qr_type);
 };
 
 #endif
diff --git a/liboctave/CmplxSCHUR.cc b/liboctave/CmplxSCHUR.cc
--- a/liboctave/CmplxSCHUR.cc
+++ b/liboctave/CmplxSCHUR.cc
@@ -59,17 +59,17 @@ select_ana (const Complex& a)
 
 static octave_idx_type
 select_dig (const Complex& a)
 {
   return (abs (a) < 1.0);
 }
 
 octave_idx_type
-ComplexSCHUR::init (const ComplexMatrix& a, const std::string& ord, 
+ComplexSCHUR::init (const ComplexMatrix& a, const std::string& ord,
                     bool calc_unitary)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
     {
       (*current_liboctave_error_handler)
diff --git a/liboctave/CmplxSVD.h b/liboctave/CmplxSVD.h
--- a/liboctave/CmplxSVD.h
+++ b/liboctave/CmplxSVD.h
@@ -35,25 +35,25 @@ ComplexSVD
 {
 public:
 
   ComplexSVD (void)
     : type_computed (), sigma (), left_sm (), right_sm ()
     { }
 
   ComplexSVD (const ComplexMatrix& a, SVD::type svd_type = SVD::std,
-              SVD::driver svd_driver = SVD::GESVD) 
+              SVD::driver svd_driver = SVD::GESVD)
     : type_computed (), sigma (), left_sm (), right_sm ()
     {
       init (a, svd_type, svd_driver);
     }
 
   ComplexSVD (const ComplexMatrix& a, octave_idx_type& info,
               SVD::type svd_type = SVD::std,
-              SVD::driver svd_driver = SVD::GESVD) 
+              SVD::driver svd_driver = SVD::GESVD)
     : type_computed (), sigma (), left_sm (), right_sm ()
     {
       info = init (a, svd_type, svd_driver);
     }
 
   ComplexSVD (const ComplexSVD& a)
     : type_computed (a.type_computed), sigma (a.sigma),
       left_sm (a.left_sm), right_sm (a.right_sm)
@@ -85,13 +85,13 @@ private:
 
   SVD::type type_computed;
 
   DiagMatrix sigma;
   ComplexMatrix left_sm;
   ComplexMatrix right_sm;
 
   octave_idx_type init (const ComplexMatrix& a,
-                        SVD::type svd_type = SVD::std, 
+                        SVD::type svd_type = SVD::std,
                         SVD::driver svd_driver = SVD::GESVD);
 };
 
 #endif
diff --git a/liboctave/CollocWt.cc b/liboctave/CollocWt.cc
--- a/liboctave/CollocWt.cc
+++ b/liboctave/CollocWt.cc
@@ -468,17 +468,17 @@ CollocWt::init (void)
         A(i,j) = vect(j);
     }
 
   // Second derivative weights.
 
   id = 2;
   for (octave_idx_type i = 0; i < nt; i++)
     {
-      dfopr (n, inc_left, inc_right, i, id, pdif1, pdif2, pdif3, pr, pvect); 
+      dfopr (n, inc_left, inc_right, i, id, pdif1, pdif2, pdif3, pr, pvect);
 
       for (octave_idx_type j = 0; j < nt; j++)
         B(i,j) = vect(j);
     }
 
   // Gaussian quadrature weights.
 
   id = 3;
diff --git a/liboctave/CollocWt.h b/liboctave/CollocWt.h
--- a/liboctave/CollocWt.h
+++ b/liboctave/CollocWt.h
@@ -49,25 +49,25 @@ public:
 
   CollocWt (octave_idx_type nc, double a, double b, octave_idx_type il,
             octave_idx_type ir)
     : n (nc), inc_left (il), inc_right (ir), lb (0.0), rb (1.0),
       Alpha (a), Beta (b), r (), q (), A (), B (), initialized (false) { }
 
   CollocWt (octave_idx_type nc, double a, double b, octave_idx_type il,
             octave_idx_type ir,
-                      double ll, double rr)  
+                      double ll, double rr)
     : n (nc), inc_left (il), inc_right (ir), lb (ll), rb (rr),
       Alpha (a), Beta (b), r (), q (), A (), B (), initialized (false) { }
 
   CollocWt (const CollocWt& a)
     : n (a.n), inc_left (a.inc_left), inc_right (a.inc_right),
       lb (a.lb), rb (a.rb), Alpha (a.Alpha), Beta (a.Beta),
       r (a.r), q (a.q), A (a.A), B (a.B),
-      initialized (a.initialized) { } 
+      initialized (a.initialized) { }
 
   CollocWt& operator = (const CollocWt& a)
     {
       if (this != &a)
         {
           n = a.n;
           inc_left = a.inc_left;
           inc_right = a.inc_right;
diff --git a/liboctave/DASPK.cc b/liboctave/DASPK.cc
--- a/liboctave/DASPK.cc
+++ b/liboctave/DASPK.cc
@@ -208,17 +208,17 @@ DASPK::do_integrate (double tout)
       else
         {
           (*current_liboctave_error_handler)
             ("daspk: no user supplied RHS subroutine!");
 
           integration_error = true;
           return retval;
         }
-  
+
       info(4) = user_jac ? 1 : 0;
 
       DAEFunc::reset = false;
 
       octave_idx_type eiq = enforce_inequality_constraints ();
       octave_idx_type ccic = compute_consistent_initial_condition ();
       octave_idx_type eavfet = exclude_algebraic_variables_from_error_test ();
 
@@ -574,17 +574,17 @@ Matrix
 DASPK::do_integrate (const ColumnVector& tout, const ColumnVector& tcrit)
 {
   Matrix dummy;
   return integrate (tout, dummy, tcrit);
 }
 
 Matrix
 DASPK::integrate (const ColumnVector& tout, Matrix& xdot_out,
-                  const ColumnVector& tcrit) 
+                  const ColumnVector& tcrit)
 {
   Matrix retval;
 
   octave_idx_type n_out = tout.capacity ();
   octave_idx_type n = size ();
 
   if (n_out > 0 && n > 0)
     {
diff --git a/liboctave/DASPK.h b/liboctave/DASPK.h
--- a/liboctave/DASPK.h
+++ b/liboctave/DASPK.h
@@ -49,30 +49,30 @@ public:
       rel_tol () { }
 
   ~DASPK (void) { }
 
   ColumnVector do_integrate (double t);
 
   Matrix do_integrate (const ColumnVector& tout);
 
-  Matrix do_integrate (const ColumnVector& tout, const ColumnVector& tcrit); 
+  Matrix do_integrate (const ColumnVector& tout, const ColumnVector& tcrit);
 
   Matrix integrate (const ColumnVector& tout, Matrix& xdot_out);
 
   Matrix integrate (const ColumnVector& tout, Matrix& xdot_out,
-                    const ColumnVector& tcrit); 
+                    const ColumnVector& tcrit);
 
   std::string error_message (void) const;
 
 private:
 
   bool initialized;
 
-  octave_idx_type liw;  
+  octave_idx_type liw;
   octave_idx_type lrw;
 
   Array<octave_idx_type> info;
   Array<octave_idx_type> iwork;
 
   Array<double> rwork;
 
   Array<double> abs_tol;
diff --git a/liboctave/DASRT.cc b/liboctave/DASRT.cc
--- a/liboctave/DASRT.cc
+++ b/liboctave/DASRT.cc
@@ -53,17 +53,17 @@ typedef octave_idx_type (*dasrt_constr_p
 extern "C"
 {
   F77_RET_T
   F77_FUNC (ddasrt, DDASRT) (dasrt_fcn_ptr, const octave_idx_type&,
                              double&, double*, double*, const double&,
                              octave_idx_type*, const double*,
                              const double*, octave_idx_type&, double*,
                              const octave_idx_type&, octave_idx_type*,
-                             const octave_idx_type&, double*, 
+                             const octave_idx_type&, double*,
                              octave_idx_type*, dasrt_jac_ptr,
                              dasrt_constr_ptr, const octave_idx_type&,
                              octave_idx_type*);
 }
 
 static DAEFunc::DAERHSFunc user_fsub;
 static DAEFunc::DAEJacFunc user_jsub;
 static DAERTFunc::DAERTConstrFunc user_csub;
@@ -125,17 +125,17 @@ ddasrt_j (const double& time, const doub
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 static octave_idx_type
 ddasrt_g (const octave_idx_type& neq, const double& t, const double *state,
-          const octave_idx_type& ng, double *gout, double *, octave_idx_type *) 
+          const octave_idx_type& ng, double *gout, double *, octave_idx_type *)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
   octave_idx_type n = neq;
 
   ColumnVector tmp_state (n);
   for (octave_idx_type i = 0; i < n; i++)
     tmp_state(i) = state[i];
@@ -439,17 +439,17 @@ DASRT::integrate (const ColumnVector& to
     }
 
   retval = DASRT_result (x_out, xdot_out, t_out);
 
   return retval;
 }
 
 DASRT_result
-DASRT::integrate (const ColumnVector& tout, const ColumnVector& tcrit) 
+DASRT::integrate (const ColumnVector& tout, const ColumnVector& tcrit)
 {
   DASRT_result retval;
 
   Matrix x_out;
   Matrix xdot_out;
   ColumnVector t_outs = tout;
 
   octave_idx_type n_out = tout.capacity ();
diff --git a/liboctave/DASRT.h b/liboctave/DASRT.h
--- a/liboctave/DASRT.h
+++ b/liboctave/DASRT.h
@@ -91,25 +91,25 @@ public:
       abs_tol (), rel_tol ()
     { }
 
   ~DASRT (void) { }
 
   DASRT_result integrate (const ColumnVector& tout);
 
   DASRT_result integrate (const ColumnVector& tout,
-                          const ColumnVector& tcrit); 
+                          const ColumnVector& tcrit);
 
   std::string error_message (void) const;
 
 private:
 
   bool initialized;
 
-  octave_idx_type liw;  
+  octave_idx_type liw;
   octave_idx_type lrw;
 
   octave_idx_type ng;
 
   Array<octave_idx_type> info;
   Array<octave_idx_type> iwork;
   Array<octave_idx_type> jroot;
 
diff --git a/liboctave/DASSL.cc b/liboctave/DASSL.cc
--- a/liboctave/DASSL.cc
+++ b/liboctave/DASSL.cc
@@ -189,17 +189,17 @@ DASSL::do_integrate (double tout)
           (*current_liboctave_error_handler)
             ("dassl: no user supplied RHS subroutine!");
 
           integration_error = true;
           return retval;
         }
 
       info(4) = user_jac ? 1 : 0;
-  
+
       DAEFunc::reset = false;
 
       // DASSL_options
 
       double hmax = maximum_step_size ();
       if (hmax >= 0.0)
         {
           rwork(1) = hmax;
@@ -389,17 +389,17 @@ Matrix
 DASSL::do_integrate (const ColumnVector& tout, const ColumnVector& tcrit)
 {
   Matrix dummy;
   return integrate (tout, dummy, tcrit);
 }
 
 Matrix
 DASSL::integrate (const ColumnVector& tout, Matrix& xdot_out,
-                  const ColumnVector& tcrit) 
+                  const ColumnVector& tcrit)
 {
   Matrix retval;
 
   octave_idx_type n_out = tout.capacity ();
   octave_idx_type n = size ();
 
   if (n_out > 0 && n > 0)
     {
diff --git a/liboctave/DASSL.h b/liboctave/DASSL.h
--- a/liboctave/DASSL.h
+++ b/liboctave/DASSL.h
@@ -49,30 +49,30 @@ public:
       rel_tol () { }
 
   ~DASSL (void) { }
 
   ColumnVector do_integrate (double t);
 
   Matrix do_integrate (const ColumnVector& tout);
 
-  Matrix do_integrate (const ColumnVector& tout, const ColumnVector& tcrit); 
+  Matrix do_integrate (const ColumnVector& tout, const ColumnVector& tcrit);
 
   Matrix integrate (const ColumnVector& tout, Matrix& xdot_out);
 
   Matrix integrate (const ColumnVector& tout, Matrix& xdot_out,
-                    const ColumnVector& tcrit); 
+                    const ColumnVector& tcrit);
 
   std::string error_message (void) const;
 
 private:
 
   bool initialized;
 
-  octave_idx_type liw;  
+  octave_idx_type liw;
   octave_idx_type lrw;
 
   Array<octave_idx_type> info;
   Array<octave_idx_type> iwork;
 
   Array<double> rwork;
 
   Array<double> abs_tol;
diff --git a/liboctave/DET.h b/liboctave/DET.h
--- a/liboctave/DET.h
+++ b/liboctave/DET.h
@@ -30,24 +30,24 @@ along with Octave; see the file COPYING.
 template <class T>
 class
 base_det
 {
 public:
 
   base_det (T c = 1, int e = 0)
     : c2 (), e2 ()
-    { 
-      c2 = xlog2 (c, e2); 
-      e2 += e; 
+    {
+      c2 = xlog2 (c, e2);
+      e2 += e;
     }
 
-  base_det (T c, double e, double b) 
+  base_det (T c, double e, double b)
     : c2 (), e2 ()
-    { 
+    {
       e *= xlog2 (b);
       e2 = e;
       c *= xexp2 (e - e2);
       int f;
       c2 = xlog2 (c, f);
       e2 += f;
     }
 
diff --git a/liboctave/DiagArray2.h b/liboctave/DiagArray2.h
--- a/liboctave/DiagArray2.h
+++ b/liboctave/DiagArray2.h
@@ -40,35 +40,35 @@ DiagArray2 : protected Array<T>
 {
 protected:
   octave_idx_type d1, d2;
 
 public:
 
   using Array<T>::element_type;
 
-  DiagArray2 (void) 
+  DiagArray2 (void)
     : Array<T> (), d1 (0), d2 (0) { }
 
-  DiagArray2 (octave_idx_type r, octave_idx_type c) 
+  DiagArray2 (octave_idx_type r, octave_idx_type c)
     : Array<T> (dim_vector (std::min (r, c), 1)), d1 (r), d2 (c) { }
 
-  DiagArray2 (octave_idx_type r, octave_idx_type c, const T& val) 
+  DiagArray2 (octave_idx_type r, octave_idx_type c, const T& val)
     : Array<T> (dim_vector (std::min (r, c), 1), val), d1 (r), d2 (c) { }
 
-  explicit DiagArray2 (const Array<T>& a) 
+  explicit DiagArray2 (const Array<T>& a)
     : Array<T> (a.as_column ()), d1 (a.numel ()), d2 (a.numel ()) { }
 
   DiagArray2 (const Array<T>& a, octave_idx_type r, octave_idx_type c);
 
-  DiagArray2 (const DiagArray2<T>& a) 
+  DiagArray2 (const DiagArray2<T>& a)
     : Array<T> (a), d1 (a.d1), d2 (a.d2) { }
 
   template <class U>
-  DiagArray2 (const DiagArray2<U>& a) 
+  DiagArray2 (const DiagArray2<U>& a)
     : Array<T> (a.diag ()), d1 (a.dim1 ()), d2 (a.dim2 ()) { }
 
   ~DiagArray2 (void) { }
 
   DiagArray2<T>& operator = (const DiagArray2<T>& a)
     {
       if (this != &a)
         {
@@ -95,33 +95,33 @@ public:
 
   size_t byte_size (void) const { return Array<T>::byte_size (); }
 
   dim_vector dims (void) const { return dim_vector (d1, d2); }
 
   Array<T> diag (octave_idx_type k = 0) const;
 
   // Warning: the non-const two-index versions will silently ignore assignments
-  // to off-diagonal elements. 
+  // to off-diagonal elements.
 
   T elem (octave_idx_type r, octave_idx_type c) const
     {
       return (r == c) ? Array<T>::elem (r) : T (0);
     }
 
   T& elem (octave_idx_type r, octave_idx_type c)
     {
       static T zero (0);
       return (r == c) ? Array<T>::elem (r) : zero;
     }
 
   T dgelem (octave_idx_type i) const
     { return Array<T>::elem (i); }
 
-  T& dgelem (octave_idx_type i) 
+  T& dgelem (octave_idx_type i)
     { return Array<T>::elem (i); }
 
   T checkelem (octave_idx_type r, octave_idx_type c) const;
 
   T operator () (octave_idx_type r, octave_idx_type c) const
     {
 #if defined (BOUNDS_CHECKING)
       return checkelem (r, c);
@@ -138,17 +138,17 @@ public:
     }
 
   T& dgxelem (octave_idx_type i)
     { return Array<T>::xelem (i); }
 
   T dgxelem (octave_idx_type i) const
     { return Array<T>::xelem (i); }
 
-  void resize (octave_idx_type n, octave_idx_type m, 
+  void resize (octave_idx_type n, octave_idx_type m,
                const T& rfv = Array<T>::resize_fill_value ());
 
   DiagArray2<T> transpose (void) const;
   DiagArray2<T> hermitian (T (*fcn) (const T&) = 0) const;
 
   Array<T> array_value (void) const;
 
   const T *data (void) const { return Array<T>::data (); }
diff --git a/liboctave/EIG.cc b/liboctave/EIG.cc
--- a/liboctave/EIG.cc
+++ b/liboctave/EIG.cc
@@ -68,34 +68,34 @@ extern "C"
                            const octave_idx_type&, Complex*,
                            const octave_idx_type&, double*,
                            Complex*, const octave_idx_type&, double*,
                            octave_idx_type&
                            F77_CHAR_ARG_LEN_DECL
                            F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
-  F77_FUNC (dpotrf, DPOTRF) (F77_CONST_CHAR_ARG_DECL, 
+  F77_FUNC (dpotrf, DPOTRF) (F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&, double*,
                              const octave_idx_type&, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
-  F77_FUNC (zpotrf, ZPOTRF) (F77_CONST_CHAR_ARG_DECL, 
-                             const octave_idx_type&, 
+  F77_FUNC (zpotrf, ZPOTRF) (F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&,
                              Complex*, const octave_idx_type&,
                              octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
-  F77_FUNC (dggev, DGGEV) (F77_CONST_CHAR_ARG_DECL, 
+  F77_FUNC (dggev, DGGEV) (F77_CONST_CHAR_ARG_DECL,
                            F77_CONST_CHAR_ARG_DECL,
-                           const octave_idx_type&, 
+                           const octave_idx_type&,
                            double*, const octave_idx_type&,
                            double*, const octave_idx_type&,
                            double*, double*, double *, double*,
                            const octave_idx_type&, double*,
                            const octave_idx_type&, double*,
                            const octave_idx_type&, octave_idx_type&
                            F77_CHAR_ARG_LEN_DECL
                            F77_CHAR_ARG_LEN_DECL);
@@ -107,31 +107,31 @@ extern "C"
                            const octave_idx_type&, double*,
                            const octave_idx_type&, double*,
                            const octave_idx_type&, double*, double*,
                            const octave_idx_type&, octave_idx_type&
                            F77_CHAR_ARG_LEN_DECL
                            F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
-  F77_FUNC (zggev, ZGGEV) (F77_CONST_CHAR_ARG_DECL, 
+  F77_FUNC (zggev, ZGGEV) (F77_CONST_CHAR_ARG_DECL,
                            F77_CONST_CHAR_ARG_DECL,
-                           const octave_idx_type&, 
+                           const octave_idx_type&,
                            Complex*, const octave_idx_type&,
                            Complex*, const octave_idx_type&,
                            Complex*, Complex*, Complex*,
                            const octave_idx_type&, Complex*,
                            const octave_idx_type&, Complex*,
                            const octave_idx_type&, double*, octave_idx_type&
                            F77_CHAR_ARG_LEN_DECL
                            F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zhegv, ZHEGV) (const octave_idx_type&,
-                           F77_CONST_CHAR_ARG_DECL, 
+                           F77_CONST_CHAR_ARG_DECL,
                            F77_CONST_CHAR_ARG_DECL,
                            const octave_idx_type&, Complex*,
                            const octave_idx_type&, Complex*,
                            const octave_idx_type&, double*, Complex*,
                            const octave_idx_type&, double*, octave_idx_type&
                            F77_CHAR_ARG_LEN_DECL
                            F77_CHAR_ARG_LEN_DECL);
 }
@@ -245,17 +245,17 @@ EIG::init (const Matrix& a, bool calc_ev
         }
     }
   else
     (*current_liboctave_error_handler) ("dgeev workspace query failed");
 
   return info;
 }
 
-octave_idx_type 
+octave_idx_type
 EIG::symmetric_init (const Matrix& a, bool calc_ev)
 {
   octave_idx_type n = a.rows ();
 
   if (n != a.cols ())
     {
       (*current_liboctave_error_handler) ("EIG requires square matrix");
       return -1;
@@ -487,17 +487,17 @@ EIG::init (const Matrix& a, const Matrix
     }
 
   octave_idx_type info = 0;
 
   Matrix tmp = b;
   double *tmp_data = tmp.fortran_vec ();
 
   F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1),
-                             n, tmp_data, n, 
+                             n, tmp_data, n,
                              info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
   if (a.is_symmetric () && b.is_symmetric () && info == 0)
     return symmetric_init (a, b, calc_ev);
 
   Matrix atmp = a;
@@ -522,32 +522,32 @@ EIG::init (const Matrix& a, const Matrix
   octave_idx_type lwork = -1;
   double dummy_work;
 
   double *dummy = 0;
   octave_idx_type idummy = 1;
 
   F77_XFCN (dggev, DGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                            F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                           n, atmp_data, n, btmp_data, n, 
+                           n, atmp_data, n, btmp_data, n,
                            par, pai, pbeta,
                            dummy, idummy, pvr, n,
                            &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work);
       Array<double> work (dim_vector (lwork, 1));
       double *pwork = work.fortran_vec ();
 
       F77_XFCN (dggev, DGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                                F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                               n, atmp_data, n, btmp_data, n, 
+                               n, atmp_data, n, btmp_data, n,
                                par, pai, pbeta,
                                dummy, idummy, pvr, n,
                                pwork, lwork, info
                                F77_CHAR_ARG_LEN (1)
                                F77_CHAR_ARG_LEN (1)));
 
       if (info < 0)
         {
@@ -576,19 +576,19 @@ EIG::init (const Matrix& a, const Matrix
           else
             {
               if (j+1 >= n)
                 {
                   (*current_liboctave_error_handler) ("EIG: internal error");
                   return -1;
                 }
 
-              lambda.elem(j) = Complex (ar.elem(j) / beta.elem (j), 
+              lambda.elem(j) = Complex (ar.elem(j) / beta.elem (j),
                                         ai.elem(j) / beta.elem (j));
-              lambda.elem(j+1) = Complex (ar.elem(j+1) / beta.elem (j+1), 
+              lambda.elem(j+1) = Complex (ar.elem(j+1) / beta.elem (j+1),
                                           ai.elem(j+1) / beta.elem (j+1));
 
               for (octave_idx_type i = 0; i < nvr; i++)
                 {
                   double real_part = vr.elem (i, j);
                   double imag_part = vr.elem (i, j+1);
                   v.elem (i, j) = Complex (real_part, imag_part);
                   v.elem (i, j+1) = Complex (real_part, -imag_part);
@@ -598,17 +598,17 @@ EIG::init (const Matrix& a, const Matrix
         }
     }
   else
     (*current_liboctave_error_handler) ("dggev workspace query failed");
 
   return info;
 }
 
-octave_idx_type 
+octave_idx_type
 EIG::symmetric_init (const Matrix& a, const Matrix& b, bool calc_ev)
 {
   octave_idx_type n = a.rows ();
   octave_idx_type nb = b.rows ();
 
   if (n != a.cols () || nb != b.cols ())
     {
       (*current_liboctave_error_handler) ("EIG requires square matrix");
@@ -632,32 +632,32 @@ EIG::symmetric_init (const Matrix& a, co
   ColumnVector wr (n);
   double *pwr = wr.fortran_vec ();
 
   octave_idx_type lwork = -1;
   double dummy_work;
 
   F77_XFCN (dsygv, DSYGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
-                           n, atmp_data, n, 
-                           btmp_data, n, 
+                           n, atmp_data, n,
+                           btmp_data, n,
                            pwr, &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work);
       Array<double> work (dim_vector (lwork, 1));
       double *pwork = work.fortran_vec ();
 
       F77_XFCN (dsygv, DSYGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                                F77_CONST_CHAR_ARG2 ("U", 1),
-                               n, atmp_data, n, 
-                               btmp_data, n, 
+                               n, atmp_data, n,
+                               btmp_data, n,
                                pwr, pwork, lwork, info
                                F77_CHAR_ARG_LEN (1)
                                F77_CHAR_ARG_LEN (1)));
 
       if (info < 0)
         {
           (*current_liboctave_error_handler) ("unrecoverable error in dsygv");
           return info;
@@ -704,17 +704,17 @@ EIG::init (const ComplexMatrix& a, const
     }
 
   octave_idx_type info = 0;
 
   ComplexMatrix tmp = b;
   Complex*tmp_data = tmp.fortran_vec ();
 
   F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1),
-                             n, tmp_data, n, 
+                             n, tmp_data, n,
                              info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
   if (a.is_hermitian () && b.is_hermitian () && info == 0)
     return hermitian_init (a, calc_ev);
 
   ComplexMatrix atmp = a;
@@ -740,36 +740,36 @@ EIG::init (const ComplexMatrix& a, const
   Array<double> rwork (dim_vector (lrwork, 1));
   double *prwork = rwork.fortran_vec ();
 
   Complex *dummy = 0;
   octave_idx_type idummy = 1;
 
   F77_XFCN (zggev, ZGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                            F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                           n, atmp_data, n, btmp_data, n, 
+                           n, atmp_data, n, btmp_data, n,
                            palpha, pbeta, dummy, idummy,
                            pv, n, &dummy_work, lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work.real ());
       Array<Complex> work (dim_vector (lwork, 1));
       Complex *pwork = work.fortran_vec ();
 
       F77_XFCN (zggev, ZGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                                F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                               n, atmp_data, n, btmp_data, n, 
+                               n, atmp_data, n, btmp_data, n,
                                palpha, pbeta, dummy, idummy,
                                pv, n, pwork, lwork, prwork, info
                                F77_CHAR_ARG_LEN (1)
                                F77_CHAR_ARG_LEN (1)));
-      
+
       if (info < 0)
         {
           (*current_liboctave_error_handler) ("unrecoverable error in zggev");
           return info;
         }
 
       if (info > 0)
         {
@@ -823,33 +823,33 @@ EIG::hermitian_init (const ComplexMatrix
   Complex dummy_work;
 
   octave_idx_type lrwork = 3*n;
   Array<double> rwork (dim_vector (lrwork, 1));
   double *prwork = rwork.fortran_vec ();
 
   F77_XFCN (zhegv, ZHEGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
-                           n, atmp_data, n, 
+                           n, atmp_data, n,
                            btmp_data, n,
                            pwr, &dummy_work, lwork,
                            prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work.real ());
       Array<Complex> work (dim_vector (lwork, 1));
       Complex *pwork = work.fortran_vec ();
 
       F77_XFCN (zhegv, ZHEGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                                F77_CONST_CHAR_ARG2 ("U", 1),
-                               n, atmp_data, n, 
-                               btmp_data, n, 
+                               n, atmp_data, n,
+                               btmp_data, n,
                                pwr, pwork, lwork, prwork, info
                                F77_CHAR_ARG_LEN (1)
                                F77_CHAR_ARG_LEN (1)));
 
       if (info < 0)
         {
           (*current_liboctave_error_handler) ("unrecoverable error in zhegv");
           return info;
diff --git a/liboctave/LSODE.cc b/liboctave/LSODE.cc
--- a/liboctave/LSODE.cc
+++ b/liboctave/LSODE.cc
@@ -57,17 +57,17 @@ extern "C"
 }
 
 static ODEFunc::ODERHSFunc user_fun;
 static ODEFunc::ODEJacFunc user_jac;
 static ColumnVector *tmp_x;
 
 static octave_idx_type
 lsode_f (const octave_idx_type& neq, const double& time, double *,
-         double *deriv, octave_idx_type& ierr) 
+         double *deriv, octave_idx_type& ierr)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
   ColumnVector tmp_deriv;
 
   // NOTE: this won't work if LSODE passes copies of the state vector.
   //       In that case we have to create a temporary vector object
   //       and copy.
@@ -166,17 +166,17 @@ LSODE::do_integrate (double tout)
         rwork(i) = 0;
 
       if (maxord >= 0)
         {
           if (maxord > 0 && maxord <= max_maxord)
             {
               iwork(4) = maxord;
               iopt = 1;
-            }     
+            }
           else
             {
               (*current_liboctave_error_handler)
                 ("lsode: invalid value for maximum order");
               integration_error = true;
               return retval;
             }
         }
@@ -324,21 +324,21 @@ LSODE::error_message (void) const
     {
     case 1:
       retval = "prior to initial integration step";
       break;
 
     case 2:
       retval = "successful exit";
       break;
-          
+
     case 3:
       retval = "prior to continuation call with modified parameters";
       break;
-          
+
     case -1:
       retval = std::string ("excess work on this call (t = ")
         + t_curr + "; perhaps wrong integration method)";
       break;
 
     case -2:
       retval = "excess accuracy requested (tolerances too small)";
       break;
diff --git a/liboctave/MArray.cc b/liboctave/MArray.cc
--- a/liboctave/MArray.cc
+++ b/liboctave/MArray.cc
@@ -1,12 +1,12 @@
 /*
 
 Copyright (C) 1993-2011 John W. Eaton
-Copyright (C) 2009 VZLU Prague              
+Copyright (C) 2009 VZLU Prague
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -353,10 +353,10 @@ operator + (const MArray<T>& a)
 {
   return a;
 }
 
 template <class T>
 MArray<T>
 operator - (const MArray<T>& a)
 {
-  return do_mx_unary_op<T, T> (a, mx_inline_uminus); 
+  return do_mx_unary_op<T, T> (a, mx_inline_uminus);
 }
diff --git a/liboctave/MArray.h b/liboctave/MArray.h
--- a/liboctave/MArray.h
+++ b/liboctave/MArray.h
@@ -35,29 +35,29 @@ along with Octave; see the file COPYING.
 
 MARRAY_OPS_FORWARD_DECLS (MArray, )
 
 template <class T>
 class
 MArray : public Array<T>
 {
 public:
-  
+
   MArray (void) : Array<T> () {}
-  
+
   explicit MArray (octave_idx_type n) GCC_ATTR_DEPRECATED
     : Array<T> (dim_vector (n, 1)) { }
 
   MArray (octave_idx_type n, const T& val) GCC_ATTR_DEPRECATED
     : Array<T> (dim_vector (n, 1), val) { }
 
-  explicit MArray (const dim_vector& dv) 
+  explicit MArray (const dim_vector& dv)
     : Array<T> (dv) { }
-  
-  explicit MArray (const dim_vector& dv, const T& val) 
+
+  explicit MArray (const dim_vector& dv, const T& val)
     : Array<T> (dv, val) { }
 
   MArray (const MArray<T>& a) : Array<T> (a) { }
 
   template <class U>
   MArray (const Array<U>& a) : Array<T> (a) { }
 
   ~MArray (void) { }
@@ -66,17 +66,17 @@ public:
     {
       Array<T>::operator = (a);
       return *this;
     }
 
   MArray<T> reshape (const dim_vector& new_dims) const
     { return Array<T>::reshape (new_dims); }
 
-  MArray<T> permute (const Array<octave_idx_type>& vec, 
+  MArray<T> permute (const Array<octave_idx_type>& vec,
                       bool inv = false) const
     { return Array<T>::permute (vec, inv); }
 
   MArray<T> ipermute (const Array<octave_idx_type>& vec) const
     { return Array<T>::ipermute (vec); }
 
   MArray squeeze (void) const { return Array<T>::squeeze (); }
 
diff --git a/liboctave/MDiagArray2.cc b/liboctave/MDiagArray2.cc
--- a/liboctave/MDiagArray2.cc
+++ b/liboctave/MDiagArray2.cc
@@ -27,24 +27,24 @@ along with Octave; see the file COPYING.
 
 #include "MDiagArray2.h"
 #include "Array-util.h"
 #include "lo-error.h"
 
 #include "MArray-defs.h"
 
 template <class T>
-bool 
+bool
 MDiagArray2<T>::is_multiple_of_identity (T val) const
 {
   bool retval = this->rows () == this->cols ();
   if (retval)
     {
       octave_idx_type len = this->length (), i = 0;
-      for (;i < len; i++) 
+      for (;i < len; i++)
         if (DiagArray2<T>::elem (i, i) != val) break;
       retval = i == len;
     }
 
   return retval;
 }
 
 // Two dimensional diagonal array with math ops.
@@ -97,10 +97,10 @@ operator + (const MDiagArray2<T>& a)
 {
   return a;
 }
 
 template <class T>
 MDiagArray2<T>
 operator - (const MDiagArray2<T>& a)
 {
-  return MDiagArray2<T> (do_mx_unary_op<T, T> (a, mx_inline_uminus), a.d1, a.d2); 
+  return MDiagArray2<T> (do_mx_unary_op<T, T> (a, mx_inline_uminus), a.d1, a.d2);
 }
diff --git a/liboctave/MDiagArray2.h b/liboctave/MDiagArray2.h
--- a/liboctave/MDiagArray2.h
+++ b/liboctave/MDiagArray2.h
@@ -36,33 +36,33 @@ along with Octave; see the file COPYING.
 
 MDIAGARRAY2_OPS_FORWARD_DECLS (MDiagArray2, )
 
 template <class T>
 class
 MDiagArray2 : public DiagArray2<T>
 {
 public:
-  
+
   MDiagArray2 (void) : DiagArray2<T> () { }
 
   MDiagArray2 (octave_idx_type r, octave_idx_type c) : DiagArray2<T> (r, c) { }
 
   MDiagArray2 (octave_idx_type r, octave_idx_type c, const T& val) : DiagArray2<T> (r, c, val) { }
 
   MDiagArray2 (const MDiagArray2<T>& a) : DiagArray2<T> (a) { }
 
   MDiagArray2 (const DiagArray2<T>& a) : DiagArray2<T> (a) { }
 
   template <class U>
   MDiagArray2 (const DiagArray2<U>& a) : DiagArray2<T> (a) { }
 
   explicit MDiagArray2 (const Array<T>& a) : DiagArray2<T> (a) { }
 
-  MDiagArray2 (const Array<T>& a, octave_idx_type r, octave_idx_type c) 
+  MDiagArray2 (const Array<T>& a, octave_idx_type r, octave_idx_type c)
     : DiagArray2<T> (a, r, c) { }
 
   ~MDiagArray2 (void) { }
 
   MDiagArray2<T>& operator = (const MDiagArray2<T>& a)
     {
       DiagArray2<T>::operator = (a);
       return *this;
diff --git a/liboctave/MSparse.cc b/liboctave/MSparse.cc
--- a/liboctave/MSparse.cc
+++ b/liboctave/MSparse.cc
@@ -49,28 +49,28 @@ operator += (MSparse<T>& a, const MSpars
     octave_idx_type b_nr = b.rows ();
     octave_idx_type b_nc = b.cols ();
 
     if (a_nr != b_nr || a_nc != b_nc)
       gripe_nonconformant ("operator +=" , a_nr, a_nc, b_nr, b_nc);
     else
       {
         r = MSparse<T> (a_nr, a_nc, (a.nnz () + b.nnz ()));
-       
+
         octave_idx_type jx = 0;
         for (octave_idx_type i = 0 ; i < a_nc ; i++)
           {
             octave_idx_type  ja = a.cidx(i);
             octave_idx_type  ja_max = a.cidx(i+1);
             bool ja_lt_max= ja < ja_max;
-           
+
             octave_idx_type  jb = b.cidx(i);
             octave_idx_type  jb_max = b.cidx(i+1);
             bool jb_lt_max = jb < jb_max;
-           
+
             while (ja_lt_max || jb_lt_max )
               {
                 octave_quit ();
                 if ((! jb_lt_max) ||
                       (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
                   {
                     r.ridx(jx) = a.ridx(ja);
                     r.data(jx) = a.data(ja) + 0.;
@@ -98,17 +98,17 @@ operator += (MSparse<T>& a, const MSpars
                      ja++;
                      ja_lt_max= ja < ja_max;
                      jb++;
                      jb_lt_max= jb < jb_max;
                   }
               }
             r.cidx(i+1) = jx;
           }
-       
+
         a = r.maybe_compress ();
       }
 
     return a;
 }
 
 template <class T>
 MSparse<T>&
@@ -122,28 +122,28 @@ operator -= (MSparse<T>& a, const MSpars
     octave_idx_type b_nr = b.rows ();
     octave_idx_type b_nc = b.cols ();
 
     if (a_nr != b_nr || a_nc != b_nc)
       gripe_nonconformant ("operator -=" , a_nr, a_nc, b_nr, b_nc);
     else
       {
         r = MSparse<T> (a_nr, a_nc, (a.nnz () + b.nnz ()));
-       
+
         octave_idx_type jx = 0;
         for (octave_idx_type i = 0 ; i < a_nc ; i++)
           {
             octave_idx_type  ja = a.cidx(i);
             octave_idx_type  ja_max = a.cidx(i+1);
             bool ja_lt_max= ja < ja_max;
-           
+
             octave_idx_type  jb = b.cidx(i);
             octave_idx_type  jb_max = b.cidx(i+1);
             bool jb_lt_max = jb < jb_max;
-           
+
             while (ja_lt_max || jb_lt_max )
               {
                 octave_quit ();
                 if ((! jb_lt_max) ||
                       (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
                   {
                     r.ridx(jx) = a.ridx(ja);
                     r.data(jx) = a.data(ja) - 0.;
@@ -171,17 +171,17 @@ operator -= (MSparse<T>& a, const MSpars
                      ja++;
                      ja_lt_max= ja < ja_max;
                      jb++;
                      jb_lt_max= jb < jb_max;
                   }
               }
             r.cidx(i+1) = jx;
           }
-       
+
         a = r.maybe_compress ();
       }
 
     return a;
 }
 
 // Element by element MSparse by scalar ops.
 
diff --git a/liboctave/MSparse.h b/liboctave/MSparse.h
--- a/liboctave/MSparse.h
+++ b/liboctave/MSparse.h
@@ -41,30 +41,30 @@ class
 MSparse : public Sparse<T>
 {
 public:
 
   MSparse (void) : Sparse<T> () { }
 
   MSparse (octave_idx_type n, octave_idx_type m) : Sparse<T> (n, m) { }
 
-  MSparse (const dim_vector& dv, octave_idx_type nz = 0) : 
+  MSparse (const dim_vector& dv, octave_idx_type nz = 0) :
     Sparse<T> (dv, nz) { }
 
   MSparse (const MSparse<T>& a) : Sparse<T> (a) { }
 
   MSparse (const MSparse<T>& a, const dim_vector& dv) : Sparse<T> (a, dv) { }
 
   MSparse (const Sparse<T>& a) : Sparse<T> (a) { }
 
   template <class U>
   MSparse (const Sparse<U>& a) : Sparse<T> (a) { }
 
   MSparse (const Array<T>& a, const idx_vector& r, const idx_vector& c,
-           octave_idx_type nr = -1, octave_idx_type nc = -1, 
+           octave_idx_type nr = -1, octave_idx_type nc = -1,
            bool sum_terms = true, octave_idx_type nzm = -1)
     : Sparse<T> (a, r, c, nr, nc, sum_terms, nzm) { }
 
   explicit MSparse (octave_idx_type r, octave_idx_type c, T val) : Sparse<T> (r, c, val) { }
 
   MSparse (octave_idx_type r, octave_idx_type c, octave_idx_type num_nz) : Sparse<T> (r, c, num_nz) { }
 
   ~MSparse (void) { }
@@ -88,17 +88,17 @@ public:
   }
 
   MSparse<T> transpose (void) const { return Sparse<T>::transpose (); }
 
   MSparse<T> squeeze (void) const { return Sparse<T>::squeeze (); }
 
   MSparse<T> reshape (const dim_vector& new_dims) const
     { return Sparse<T>::reshape (new_dims); }
-     
+
   MSparse<T> permute (const Array<octave_idx_type>& vec, bool inv = false) const
     { return Sparse<T>::permute (vec, inv); }
 
   MSparse<T> ipermute (const Array<octave_idx_type>& vec) const
     { return Sparse<T>::ipermute (vec); }
 
 
   MSparse<T> diag (octave_idx_type k = 0) const
diff --git a/liboctave/MatrixType.cc b/liboctave/MatrixType.cc
--- a/liboctave/MatrixType.cc
+++ b/liboctave/MatrixType.cc
@@ -34,93 +34,93 @@ along with Octave; see the file COPYING.
 #include "dSparse.h"
 #include "CSparse.h"
 #include "oct-spparms.h"
 #include "oct-locbuf.h"
 
 // FIXME There is a large code duplication here
 
 MatrixType::MatrixType (void)
-  : typ (MatrixType::Unknown), 
+  : typ (MatrixType::Unknown),
     sp_bandden (octave_sparse_params::get_bandden()),
-    bandden (0), upper_band (0), 
+    bandden (0), upper_band (0),
     lower_band (0), dense (false), full (false), nperm (0), perm (0) { }
 
 MatrixType::MatrixType (const MatrixType &a)
-  : typ (a.typ), sp_bandden (a.sp_bandden), bandden (a.bandden), 
-    upper_band (a.upper_band), lower_band (a.lower_band), 
+  : typ (a.typ), sp_bandden (a.sp_bandden), bandden (a.bandden),
+    upper_band (a.upper_band), lower_band (a.lower_band),
     dense (a.dense), full (a.full), nperm (a.nperm), perm (0)
-{ 
+{
   if (nperm != 0)
     {
       perm = new octave_idx_type [nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = a.perm[i];
     }
 }
 
-template<class T> 
-MatrixType::matrix_type 
+template<class T>
+MatrixType::matrix_type
 matrix_real_probe (const MArray<T>& a)
 {
   MatrixType::matrix_type typ;
   octave_idx_type nrows = a.rows ();
   octave_idx_type ncols = a.cols ();
 
   const T zero = 0;
- 
+
   if (ncols == nrows)
     {
       bool upper = true;
       bool lower = true;
       bool hermitian = true;
 
       // do the checks for lower/upper/hermitian all in one pass.
       OCTAVE_LOCAL_BUFFER(T, diag, ncols);
 
-      for (octave_idx_type j = 0; 
+      for (octave_idx_type j = 0;
            j < ncols && upper; j++)
         {
           T d = a.elem (j,j);
           upper = upper && (d != zero);
           lower = lower && (d != zero);
           hermitian = hermitian && (d > zero);
           diag[j] = d;
         }
 
-      for (octave_idx_type j = 0; 
+      for (octave_idx_type j = 0;
            j < ncols && (upper || lower || hermitian); j++)
         {
           for (octave_idx_type i = 0; i < j; i++)
             {
               double aij = a.elem (i,j), aji = a.elem (j,i);
               lower = lower && (aij == zero);
               upper = upper && (aji == zero);
-              hermitian = hermitian && (aij == aji 
+              hermitian = hermitian && (aij == aji
                                         && aij*aij < diag[i]*diag[j]);
             }
         }
 
       if (upper)
         typ = MatrixType::Upper;
       else if (lower)
         typ = MatrixType::Lower;
       else if (hermitian)
         typ = MatrixType::Hermitian;
-      else 
+      else
         typ = MatrixType::Full;
     }
   else
     typ = MatrixType::Rectangular;
 
   return typ;
 }
 
-template<class T> 
-MatrixType::matrix_type 
+template<class T>
+MatrixType::matrix_type
 matrix_complex_probe (const MArray<std::complex<T> >& a)
 {
   MatrixType::matrix_type typ;
   octave_idx_type nrows = a.rows ();
   octave_idx_type ncols = a.cols ();
 
   const T zero = 0;
   // get the real type
@@ -129,27 +129,27 @@ matrix_complex_probe (const MArray<std::
     {
       bool upper = true;
       bool lower = true;
       bool hermitian = true;
 
       // do the checks for lower/upper/hermitian all in one pass.
       OCTAVE_LOCAL_BUFFER(T, diag, ncols);
 
-      for (octave_idx_type j = 0; 
+      for (octave_idx_type j = 0;
            j < ncols && upper; j++)
         {
           std::complex<T> d = a.elem (j,j);
           upper = upper && (d != zero);
           lower = lower && (d != zero);
           hermitian = hermitian && (d.real() > zero && d.imag() == zero);
           diag[j] = d.real();
         }
 
-      for (octave_idx_type j = 0; 
+      for (octave_idx_type j = 0;
            j < ncols && (upper || lower || hermitian); j++)
         {
           for (octave_idx_type i = 0; i < j; i++)
             {
               std::complex<T> aij = a.elem (i,j), aji = a.elem (j,i);
               lower = lower && (aij == zero);
               upper = upper && (aji == zero);
               hermitian = hermitian && (aij == std::conj (aji)
@@ -212,17 +212,17 @@ MatrixType::MatrixType (const SparseMatr
     dense (false), full (false), nperm (0), perm (0)
 {
   octave_idx_type nrows = a.rows ();
   octave_idx_type ncols = a.cols ();
   octave_idx_type nm = (ncols < nrows ? ncols : nrows);
   octave_idx_type nnz = a.nnz ();
 
   if (octave_sparse_params::get_key ("spumoni") != 0.)
-    (*current_liboctave_warning_handler) 
+    (*current_liboctave_warning_handler)
       ("Calculating Sparse Matrix Type");
 
   sp_bandden = octave_sparse_params::get_bandden();
   bool maybe_hermitian = false;
   typ = MatrixType::Full;
 
   if (nnz == nm)
     {
@@ -237,29 +237,29 @@ MatrixType::MatrixType (const SparseMatr
               break;
             }
           if (a.ridx(i) != i)
             {
               tmp_typ = MatrixType::Permuted_Diagonal;
               break;
             }
         }
-          
+
       if (tmp_typ == MatrixType::Permuted_Diagonal)
         {
           std::vector<bool> found (nrows);
 
           for (octave_idx_type j = 0; j < i; j++)
             found [j] = true;
           for (octave_idx_type j = i; j < nrows; j++)
             found [j] = false;
-              
+
           for (octave_idx_type j = i; j < nm; j++)
             {
-              if ((a.cidx(j+1) > a.cidx(j) + 1)  || 
+              if ((a.cidx(j+1) > a.cidx(j) + 1)  ||
                   ((a.cidx(j+1) == a.cidx(j) + 1) && found [a.ridx(j)]))
                 {
                   tmp_typ = MatrixType::Full;
                   break;
                 }
               found [a.ridx(j)] = true;
             }
         }
@@ -294,17 +294,17 @@ MatrixType::MatrixType (const SparseMatr
 
           if (a.cidx(j+1) != a.cidx(j))
             {
               octave_idx_type ru = a.ridx(a.cidx(j));
               octave_idx_type rl = a.ridx(a.cidx(j+1)-1);
 
               if (j - ru > upper_band)
                 upper_band = j - ru;
-                  
+
               if (rl - j > lower_band)
                 lower_band = rl - j;
             }
         }
 
       if (!singular)
         {
           bandden = double (nnz) /
@@ -315,23 +315,23 @@ MatrixType::MatrixType (const SparseMatr
 
           if (nrows == ncols && sp_bandden != 1. && bandden > sp_bandden)
             {
               if (upper_band == 1 && lower_band == 1)
                 typ = MatrixType::Tridiagonal;
               else
                 typ = MatrixType::Banded;
 
-              octave_idx_type nnz_in_band = 
+              octave_idx_type nnz_in_band =
                 (upper_band + lower_band + 1) * nrows -
                 (1 + upper_band) * upper_band / 2 -
                 (1 + lower_band) * lower_band / 2;
               if (nnz_in_band == nnz)
                 dense = true;
-              else 
+              else
                 dense = false;
             }
           else if (upper_band == 0)
             typ = MatrixType::Lower;
           else if (lower_band == 0)
             typ = MatrixType::Upper;
 
           if (upper_band == lower_band && nrows == ncols)
@@ -354,17 +354,17 @@ MatrixType::MatrixType (const SparseMatr
             perm [i] = -1;
 
           for (octave_idx_type i = 0; i < nm; i++)
             {
               found = false;
 
               for (octave_idx_type j = 0; j < ncols; j++)
                 {
-                  if ((a.cidx(j+1) - a.cidx(j)) > 0 && 
+                  if ((a.cidx(j+1) - a.cidx(j)) > 0 &&
                       (a.ridx(a.cidx(j+1)-1) == i))
                     {
                       perm [i] = j;
                       found = true;
                       break;
                     }
                 }
 
@@ -461,18 +461,18 @@ MatrixType::MatrixType (const SparseMatr
               typ == MatrixType::Permuted_Lower)
             delete [] perm;
           nperm = 0;
         }
 
       if (typ == MatrixType::Full && ncols != nrows)
         typ = MatrixType::Rectangular;
 
-      if (maybe_hermitian && (typ == MatrixType::Full || 
-                              typ == MatrixType::Tridiagonal || 
+      if (maybe_hermitian && (typ == MatrixType::Full ||
+                              typ == MatrixType::Tridiagonal ||
                               typ == MatrixType::Banded))
         {
           bool is_herm = true;
 
           // first, check whether the diagonal is positive & extract it
           ColumnVector diag (ncols);
 
           for (octave_idx_type j = 0; is_herm && j < ncols; j++)
@@ -493,17 +493,17 @@ MatrixType::MatrixType (const SparseMatr
 
           // next, check symmetry and 2x2 positiveness
 
           for (octave_idx_type j = 0; is_herm && j < ncols; j++)
             for (octave_idx_type i = a.cidx(j); is_herm && i < a.cidx(j+1); i++)
               {
                 octave_idx_type k = a.ridx(i);
                 is_herm = k == j;
-                if (is_herm) 
+                if (is_herm)
                   continue;
                 double d = a.data(i);
                 if (d*d < diag(j)*diag(k))
                   {
                     for (octave_idx_type l = a.cidx(k); l < a.cidx(k+1); l++)
                       {
                         if (a.ridx(l) == j)
                           {
@@ -533,17 +533,17 @@ MatrixType::MatrixType (const SparseComp
     dense (false), full (false), nperm (0), perm (0)
 {
   octave_idx_type nrows = a.rows ();
   octave_idx_type ncols = a.cols ();
   octave_idx_type nm = (ncols < nrows ? ncols : nrows);
   octave_idx_type nnz = a.nnz ();
 
   if (octave_sparse_params::get_key ("spumoni") != 0.)
-    (*current_liboctave_warning_handler) 
+    (*current_liboctave_warning_handler)
       ("Calculating Sparse Matrix Type");
 
   sp_bandden = octave_sparse_params::get_bandden();
   bool maybe_hermitian = false;
   typ = MatrixType::Full;
 
   if (nnz == nm)
     {
@@ -558,29 +558,29 @@ MatrixType::MatrixType (const SparseComp
               break;
             }
           if (a.ridx(i) != i)
             {
               tmp_typ = MatrixType::Permuted_Diagonal;
               break;
             }
         }
-          
+
       if (tmp_typ == MatrixType::Permuted_Diagonal)
         {
           std::vector<bool> found (nrows);
 
           for (octave_idx_type j = 0; j < i; j++)
             found [j] = true;
           for (octave_idx_type j = i; j < nrows; j++)
             found [j] = false;
-              
+
           for (octave_idx_type j = i; j < nm; j++)
             {
-              if ((a.cidx(j+1) > a.cidx(j) + 1)  || 
+              if ((a.cidx(j+1) > a.cidx(j) + 1)  ||
                   ((a.cidx(j+1) == a.cidx(j) + 1) && found [a.ridx(j)]))
                 {
                   tmp_typ = MatrixType::Full;
                   break;
                 }
               found [a.ridx(j)] = true;
             }
         }
@@ -615,17 +615,17 @@ MatrixType::MatrixType (const SparseComp
 
           if (a.cidx(j+1) != a.cidx(j))
             {
               octave_idx_type ru = a.ridx(a.cidx(j));
               octave_idx_type rl = a.ridx(a.cidx(j+1)-1);
 
               if (j - ru > upper_band)
                 upper_band = j - ru;
-                  
+
               if (rl - j > lower_band)
                 lower_band = rl - j;
             }
         }
 
       if (!singular)
         {
           bandden = double (nnz) /
@@ -636,23 +636,23 @@ MatrixType::MatrixType (const SparseComp
 
           if (nrows == ncols && sp_bandden != 1. && bandden > sp_bandden)
             {
               if (upper_band == 1 && lower_band == 1)
                 typ = MatrixType::Tridiagonal;
               else
                 typ = MatrixType::Banded;
 
-              octave_idx_type nnz_in_band = 
+              octave_idx_type nnz_in_band =
                 (upper_band + lower_band + 1) * nrows -
                 (1 + upper_band) * upper_band / 2 -
                 (1 + lower_band) * lower_band / 2;
               if (nnz_in_band == nnz)
                 dense = true;
-              else 
+              else
                 dense = false;
             }
           else if (upper_band == 0)
             typ = MatrixType::Lower;
           else if (lower_band == 0)
             typ = MatrixType::Upper;
 
           if (upper_band == lower_band && nrows == ncols)
@@ -675,17 +675,17 @@ MatrixType::MatrixType (const SparseComp
             perm [i] = -1;
 
           for (octave_idx_type i = 0; i < nm; i++)
             {
               found = false;
 
               for (octave_idx_type j = 0; j < ncols; j++)
                 {
-                  if ((a.cidx(j+1) - a.cidx(j)) > 0 && 
+                  if ((a.cidx(j+1) - a.cidx(j)) > 0 &&
                       (a.ridx(a.cidx(j+1)-1) == i))
                     {
                       perm [i] = j;
                       found = true;
                       break;
                     }
                 }
 
@@ -782,18 +782,18 @@ MatrixType::MatrixType (const SparseComp
               typ == MatrixType::Permuted_Lower)
             delete [] perm;
           nperm = 0;
         }
 
       if (typ == MatrixType::Full && ncols != nrows)
         typ = MatrixType::Rectangular;
 
-      if (maybe_hermitian && (typ == MatrixType::Full || 
-                              typ == MatrixType::Tridiagonal || 
+      if (maybe_hermitian && (typ == MatrixType::Full ||
+                              typ == MatrixType::Tridiagonal ||
                               typ == MatrixType::Banded))
         {
           bool is_herm = true;
 
           // first, check whether the diagonal is positive & extract it
           ColumnVector diag (ncols);
 
           for (octave_idx_type j = 0; is_herm && j < ncols; j++)
@@ -813,17 +813,17 @@ MatrixType::MatrixType (const SparseComp
 
           // next, check symmetry and 2x2 positiveness
 
           for (octave_idx_type j = 0; is_herm && j < ncols; j++)
             for (octave_idx_type i = a.cidx(j); is_herm && i < a.cidx(j+1); i++)
               {
                 octave_idx_type k = a.ridx(i);
                 is_herm = k == j;
-                if (is_herm) 
+                if (is_herm)
                   continue;
                 Complex d = a.data(i);
                 if (std::norm (d) < diag(j)*diag(k))
                   {
                     d = std::conj (d);
                     for (octave_idx_type l = a.cidx(k); l < a.cidx(k+1); l++)
                       {
                         if (a.ridx(l) == j)
@@ -849,19 +849,19 @@ MatrixType::MatrixType (const SparseComp
     }
 }
 MatrixType::MatrixType (const matrix_type t, bool _full)
   : typ (MatrixType::Unknown),
     sp_bandden (octave_sparse_params::get_bandden()),
     bandden (0), upper_band (0), lower_band (0),
     dense (false), full (_full), nperm (0), perm (0)
 {
-  if (t == MatrixType::Unknown || t == MatrixType::Full 
-      || t == MatrixType::Diagonal || t == MatrixType::Permuted_Diagonal 
-      || t == MatrixType::Upper || t == MatrixType::Lower 
+  if (t == MatrixType::Unknown || t == MatrixType::Full
+      || t == MatrixType::Diagonal || t == MatrixType::Permuted_Diagonal
+      || t == MatrixType::Upper || t == MatrixType::Lower
       || t == MatrixType::Tridiagonal || t == MatrixType::Tridiagonal_Hermitian
       || t == MatrixType::Rectangular)
     typ = t;
   else
     (*current_liboctave_warning_handler) ("Invalid matrix type");
 }
 
 MatrixType::MatrixType (const matrix_type t, const octave_idx_type np,
@@ -893,28 +893,28 @@ MatrixType::MatrixType (const matrix_typ
 {
   if (t == MatrixType::Banded || t == MatrixType::Banded_Hermitian)
     {
       typ = t;
       upper_band = ku;
       lower_band = kl;
     }
   else
-    (*current_liboctave_warning_handler) ("Invalid sparse matrix type"); 
+    (*current_liboctave_warning_handler) ("Invalid sparse matrix type");
 }
 
-MatrixType::~MatrixType (void) 
-{ 
+MatrixType::~MatrixType (void)
+{
   if (nperm != 0)
     {
-      delete [] perm; 
+      delete [] perm;
     }
 }
 
-MatrixType& 
+MatrixType&
 MatrixType::operator = (const MatrixType& a)
 {
   if (this != &a)
     {
       typ = a.typ;
       sp_bandden = a.sp_bandden;
       bandden = a.bandden;
       upper_band = a.upper_band;
@@ -937,42 +937,42 @@ MatrixType::operator = (const MatrixType
 int
 MatrixType::type (bool quiet)
 {
   if (typ != MatrixType::Unknown && (full ||
       sp_bandden == octave_sparse_params::get_bandden()))
     {
       if (!quiet &&
           octave_sparse_params::get_key ("spumoni") != 0.)
-        (*current_liboctave_warning_handler) 
+        (*current_liboctave_warning_handler)
           ("Using Cached Matrix Type");
-      
+
       return typ;
     }
 
-  if (typ != MatrixType::Unknown && 
+  if (typ != MatrixType::Unknown &&
       octave_sparse_params::get_key ("spumoni") != 0.)
-    (*current_liboctave_warning_handler) 
+    (*current_liboctave_warning_handler)
       ("Invalidating Matrix Type");
 
   typ = MatrixType::Unknown;
 
   return typ;
 }
 
 int
 MatrixType::type (const SparseMatrix &a)
 {
   if (typ != MatrixType::Unknown && (full ||
       sp_bandden == octave_sparse_params::get_bandden()))
     {
       if (octave_sparse_params::get_key ("spumoni") != 0.)
-        (*current_liboctave_warning_handler) 
+        (*current_liboctave_warning_handler)
           ("Using Cached Matrix Type");
-      
+
       return typ;
     }
 
   MatrixType tmp_typ (a);
   typ = tmp_typ.typ;
   sp_bandden = tmp_typ.sp_bandden;
   bandden = tmp_typ.bandden;
   upper_band = tmp_typ.upper_band;
@@ -989,23 +989,23 @@ MatrixType::type (const SparseMatrix &a)
     }
 
   return typ;
 }
 
 int
 MatrixType::type (const SparseComplexMatrix &a)
 {
-  if (typ != MatrixType::Unknown && (full || 
+  if (typ != MatrixType::Unknown && (full ||
       sp_bandden == octave_sparse_params::get_bandden()))
     {
       if (octave_sparse_params::get_key ("spumoni") != 0.)
-        (*current_liboctave_warning_handler) 
+        (*current_liboctave_warning_handler)
           ("Using Cached Matrix Type");
-      
+
       return typ;
     }
 
   MatrixType tmp_typ (a);
   typ = tmp_typ.typ;
   sp_bandden = tmp_typ.sp_bandden;
   bandden = tmp_typ.bandden;
   upper_band = tmp_typ.upper_band;
@@ -1025,19 +1025,19 @@ MatrixType::type (const SparseComplexMat
 }
 
 int
 MatrixType::type (const Matrix &a)
 {
   if (typ != MatrixType::Unknown)
     {
       if (octave_sparse_params::get_key ("spumoni") != 0.)
-        (*current_liboctave_warning_handler) 
+        (*current_liboctave_warning_handler)
           ("Using Cached Matrix Type");
-      
+
       return typ;
     }
 
   MatrixType tmp_typ (a);
   typ = tmp_typ.typ;
   full = tmp_typ.full;
   nperm = tmp_typ.nperm;
 
@@ -1052,25 +1052,25 @@ MatrixType::type (const Matrix &a)
 }
 
 int
 MatrixType::type (const ComplexMatrix &a)
 {
   if (typ != MatrixType::Unknown)
     {
       if (octave_sparse_params::get_key ("spumoni") != 0.)
-        (*current_liboctave_warning_handler) 
+        (*current_liboctave_warning_handler)
           ("Using Cached Matrix Type");
-      
+
       return typ;
     }
 
   MatrixType tmp_typ (a);
   typ = tmp_typ.typ;
-  full = tmp_typ.full; 
+  full = tmp_typ.full;
   nperm = tmp_typ.nperm;
 
   if (nperm != 0)
     {
       perm = new octave_idx_type [nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = tmp_typ.perm[i];
     }
@@ -1079,19 +1079,19 @@ MatrixType::type (const ComplexMatrix &a
 }
 
 int
 MatrixType::type (const FloatMatrix &a)
 {
   if (typ != MatrixType::Unknown)
     {
       if (octave_sparse_params::get_key ("spumoni") != 0.)
-        (*current_liboctave_warning_handler) 
+        (*current_liboctave_warning_handler)
           ("Using Cached Matrix Type");
-      
+
       return typ;
     }
 
   MatrixType tmp_typ (a);
   typ = tmp_typ.typ;
   full = tmp_typ.full;
   nperm = tmp_typ.nperm;
 
@@ -1106,25 +1106,25 @@ MatrixType::type (const FloatMatrix &a)
 }
 
 int
 MatrixType::type (const FloatComplexMatrix &a)
 {
   if (typ != MatrixType::Unknown)
     {
       if (octave_sparse_params::get_key ("spumoni") != 0.)
-        (*current_liboctave_warning_handler) 
+        (*current_liboctave_warning_handler)
           ("Using Cached Matrix Type");
-      
+
       return typ;
     }
 
   MatrixType tmp_typ (a);
   typ = tmp_typ.typ;
-  full = tmp_typ.full; 
+  full = tmp_typ.full;
   nperm = tmp_typ.nperm;
 
   if (nperm != 0)
     {
       perm = new octave_idx_type [nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = tmp_typ.perm[i];
     }
@@ -1133,89 +1133,89 @@ MatrixType::type (const FloatComplexMatr
 }
 
 void
 MatrixType::info () const
 {
   if (octave_sparse_params::get_key ("spumoni") != 0.)
     {
       if (typ == MatrixType::Unknown)
-        (*current_liboctave_warning_handler) 
+        (*current_liboctave_warning_handler)
           ("Unknown Matrix Type");
       else if (typ == MatrixType::Diagonal)
-        (*current_liboctave_warning_handler) 
+        (*current_liboctave_warning_handler)
           ("Diagonal Sparse Matrix");
       else if (typ == MatrixType::Permuted_Diagonal)
-        (*current_liboctave_warning_handler) 
+        (*current_liboctave_warning_handler)
           ("Permuted Diagonal Sparse Matrix");
       else if (typ == MatrixType::Upper)
-        (*current_liboctave_warning_handler) 
+        (*current_liboctave_warning_handler)
           ("Upper Triangular Matrix");
       else if (typ == MatrixType::Lower)
-        (*current_liboctave_warning_handler) 
+        (*current_liboctave_warning_handler)
           ("Lower Triangular Matrix");
       else if (typ == MatrixType::Permuted_Upper)
-        (*current_liboctave_warning_handler) 
+        (*current_liboctave_warning_handler)
           ("Permuted Upper Triangular Matrix");
       else if (typ == MatrixType::Permuted_Lower)
-        (*current_liboctave_warning_handler) 
+        (*current_liboctave_warning_handler)
           ("Permuted Lower Triangular Matrix");
       else if (typ == MatrixType::Banded)
-        (*current_liboctave_warning_handler) 
-          ("Banded Sparse Matrix %d-1-%d (Density %f)", lower_band, 
+        (*current_liboctave_warning_handler)
+          ("Banded Sparse Matrix %d-1-%d (Density %f)", lower_band,
            upper_band, bandden);
       else if (typ == MatrixType::Banded_Hermitian)
-        (*current_liboctave_warning_handler) 
-          ("Banded Hermitian/Symmetric Sparse Matrix %d-1-%d (Density %f)", 
+        (*current_liboctave_warning_handler)
+          ("Banded Hermitian/Symmetric Sparse Matrix %d-1-%d (Density %f)",
            lower_band, upper_band, bandden);
       else if (typ == MatrixType::Hermitian)
-        (*current_liboctave_warning_handler) 
+        (*current_liboctave_warning_handler)
           ("Hermitian/Symmetric Matrix");
       else if (typ == MatrixType::Tridiagonal)
-        (*current_liboctave_warning_handler) 
+        (*current_liboctave_warning_handler)
           ("Tridiagonal Sparse Matrix");
       else if (typ == MatrixType::Tridiagonal_Hermitian)
-        (*current_liboctave_warning_handler) 
+        (*current_liboctave_warning_handler)
           ("Hermitian/Symmetric Tridiagonal Sparse Matrix");
       else if (typ == MatrixType::Rectangular)
-        (*current_liboctave_warning_handler) 
+        (*current_liboctave_warning_handler)
           ("Rectangular/Singular Matrix");
       else if (typ == MatrixType::Full)
-        (*current_liboctave_warning_handler) 
+        (*current_liboctave_warning_handler)
           ("Full Matrix");
     }
 }
 
 void
 MatrixType::mark_as_symmetric (void)
 {
-  if (typ == MatrixType::Tridiagonal || 
+  if (typ == MatrixType::Tridiagonal ||
       typ == MatrixType::Tridiagonal_Hermitian)
     typ = MatrixType::Tridiagonal_Hermitian;
   else if (typ == MatrixType::Banded ||
            typ == MatrixType::Banded_Hermitian)
     typ = MatrixType::Banded_Hermitian;
-  else if (typ == MatrixType::Full || typ == MatrixType::Hermitian || 
+  else if (typ == MatrixType::Full || typ == MatrixType::Hermitian ||
            typ == MatrixType::Unknown)
     typ = MatrixType::Hermitian;
   else
-    (*current_liboctave_error_handler) 
+    (*current_liboctave_error_handler)
       ("Can not mark current matrix type as symmetric");
 }
 
 void
 MatrixType::mark_as_unsymmetric (void)
 {
-  if (typ == MatrixType::Tridiagonal || 
+  if (typ == MatrixType::Tridiagonal ||
       typ == MatrixType::Tridiagonal_Hermitian)
     typ = MatrixType::Tridiagonal;
   else if (typ == MatrixType::Banded ||
            typ == MatrixType::Banded_Hermitian)
     typ = MatrixType::Banded;
-  else if (typ == MatrixType::Full || typ == MatrixType::Hermitian || 
+  else if (typ == MatrixType::Full || typ == MatrixType::Hermitian ||
            typ == MatrixType::Unknown)
     typ = MatrixType::Full;
 }
 
 void
 MatrixType::mark_as_permuted (const octave_idx_type np, const octave_idx_type *p)
 {
   nperm = np;
@@ -1225,17 +1225,17 @@ MatrixType::mark_as_permuted (const octa
 
   if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     typ = MatrixType::Permuted_Diagonal;
   else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     typ = MatrixType::Permuted_Upper;
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     typ = MatrixType::Permuted_Lower;
   else
-    (*current_liboctave_error_handler) 
+    (*current_liboctave_error_handler)
       ("Can not mark current matrix type as symmetric");
 }
 
 void
 MatrixType::mark_as_unpermuted (void)
 {
   if (nperm)
     {
diff --git a/liboctave/MatrixType.h b/liboctave/MatrixType.h
--- a/liboctave/MatrixType.h
+++ b/liboctave/MatrixType.h
@@ -69,17 +69,17 @@ public:
 
   MatrixType (const SparseComplexMatrix &a);
 
   MatrixType (const matrix_type t, bool _full = false);
 
   MatrixType (const matrix_type t, const octave_idx_type np,
               const octave_idx_type *p, bool _full = false);
 
-  MatrixType (const matrix_type t, const octave_idx_type ku, 
+  MatrixType (const matrix_type t, const octave_idx_type ku,
               const octave_idx_type kl, bool _full = false);
 
   ~MatrixType (void);
 
   MatrixType& operator = (const MatrixType& a);
 
   int type (bool quiet = true);
 
@@ -98,31 +98,31 @@ public:
   double band_density (void) const { return bandden; }
 
   int nupper (void) const { return upper_band; }
 
   int nlower (void) const { return lower_band; }
 
   bool is_dense (void) const { return dense; }
 
-  bool is_diagonal (void) const 
+  bool is_diagonal (void) const
     { return (typ == Diagonal || typ == Permuted_Diagonal); }
-  
-  bool is_upper_triangular (void) const 
+
+  bool is_upper_triangular (void) const
     { return (typ == Upper || typ == Permuted_Upper); }
 
-  bool is_lower_triangular (void) const 
+  bool is_lower_triangular (void) const
     { return (typ == Lower || typ == Permuted_Lower); }
 
    bool is_banded (void)
     { return (typ == Banded || typ == Banded_Hermitian); }
-  
+
   bool is_tridiagonal (void) const
     { return (typ == Tridiagonal || typ == Tridiagonal_Hermitian); }
-  
+
   bool is_hermitian (void) const
     { return (typ == Banded_Hermitian || typ == Tridiagonal_Hermitian ||
               typ == Hermitian); }
 
   bool is_rectangular (void) const { return (typ == Rectangular); }
 
   bool is_known (void) const { return (typ != Unknown); }
 
diff --git a/liboctave/ODESFunc.h b/liboctave/ODESFunc.h
--- a/liboctave/ODESFunc.h
+++ b/liboctave/ODESFunc.h
@@ -32,17 +32,17 @@ public:
 
   struct DAEJac
     {
       Matrix *dfdxdot;
       Matrix *dfdx;
     };
 
   typedef ColumnVector (*ODES_fsub) (const ColumnVector& x, double,
-                                     const ColumnVector& theta); 
+                                     const ColumnVector& theta);
 
   typedef ColumnVector (*ODES_bsub) (const ColumnVector& x, double,
                                      const ColumnVector& theta, int column);
 
   typedef Matrix (*ODES_jsub) (const ColumnVector& x, double,
                                const ColumnVector& theta);
 
   ODESFunc (void)
diff --git a/liboctave/PermMatrix.cc b/liboctave/PermMatrix.cc
--- a/liboctave/PermMatrix.cc
+++ b/liboctave/PermMatrix.cc
@@ -64,45 +64,45 @@ PermMatrix::PermMatrix (const idx_vector
 }
 
 PermMatrix::PermMatrix (octave_idx_type n)
   : Array<octave_idx_type> (dim_vector (n, 1)), _colp (false)
 {
   for (octave_idx_type i = 0; i < n; i++) xelem (i) = i;
 }
 
-octave_idx_type 
+octave_idx_type
 PermMatrix::checkelem (octave_idx_type i, octave_idx_type j) const
 {
   octave_idx_type len = Array<octave_idx_type>::length ();
   if (i < 0 || j < 0 || i > len || j > len)
     {
       (*current_liboctave_error_handler) ("index out of range");
       return 0;
     }
   else
     return elem (i, j);
 }
 
 
-PermMatrix 
+PermMatrix
 PermMatrix::transpose (void) const
 {
   PermMatrix retval (*this);
   retval._colp = ! retval._colp;
   return retval;
 }
 
-PermMatrix 
+PermMatrix
 PermMatrix::inverse (void) const
 {
   return transpose ();
 }
 
-octave_idx_type 
+octave_idx_type
 PermMatrix::determinant (void) const
 {
   // Determine the sign of a permutation in linear time.
   // Is this widely known?
 
   octave_idx_type len = perm_length ();
   const octave_idx_type *pa = data ();
 
@@ -122,21 +122,21 @@ PermMatrix::determinant (void) const
       octave_idx_type j = p[i], k = q[i];
       if (j != i)
         {
           p[k] = p[i];
           q[j] = q[i];
           neg = ! neg;
         }
     }
-  
+
   return neg ? -1 : 1;
 }
 
-PermMatrix 
+PermMatrix
 PermMatrix::power (octave_idx_type m) const
 {
   octave_idx_type n = rows ();
   bool res_colp = _colp;
   if (m < 0)
     {
       res_colp = ! res_colp;
       m = -m;
@@ -183,28 +183,28 @@ PermMatrix::eye (octave_idx_type n)
 {
   Array<octave_idx_type> p (dim_vector (n, 1));
   for (octave_idx_type i = 0; i < n; i++)
     p(i) = i;
 
   return PermMatrix (p, false, false);
 }
 
-PermMatrix 
+PermMatrix
 operator *(const PermMatrix& a, const PermMatrix& b)
 {
   const Array<octave_idx_type> ia = a.pvec (), ib = b.pvec ();
   PermMatrix r;
   octave_idx_type n = a.columns ();
   if (n != b.rows ())
     gripe_nonconformant ("operator *", n, n, b.rows (), b.rows ());
   else if (a._colp == b._colp)
     {
-      r = PermMatrix ((a._colp 
-                       ? ia.index (idx_vector (ib)) 
+      r = PermMatrix ((a._colp
+                       ? ia.index (idx_vector (ib))
                        : ib.index (idx_vector (ia))), a._colp, false);
     }
   else
     {
       Array<octave_idx_type> ra (dim_vector (n, 1));
       if (a._colp)
         ra.assign (idx_vector (ib), ia);
       else
diff --git a/liboctave/PermMatrix.h b/liboctave/PermMatrix.h
--- a/liboctave/PermMatrix.h
+++ b/liboctave/PermMatrix.h
@@ -33,101 +33,101 @@ class OCTAVE_API PermMatrix : protected 
 {
 
 public:
 
   PermMatrix (void) : Array<octave_idx_type> (), _colp (false) { }
 
   PermMatrix (octave_idx_type n);
 
-  PermMatrix (const Array<octave_idx_type>& p, bool colp = false, 
+  PermMatrix (const Array<octave_idx_type>& p, bool colp = false,
               bool check = true);
 
   PermMatrix (const PermMatrix& m)
     : Array<octave_idx_type> (m), _colp(m._colp) { }
-  
-  PermMatrix (const idx_vector& idx, bool colp = false, octave_idx_type n = 0); 
+
+  PermMatrix (const idx_vector& idx, bool colp = false, octave_idx_type n = 0);
 
-  octave_idx_type dim1 (void) const 
+  octave_idx_type dim1 (void) const
     { return Array<octave_idx_type>::length (); }
-  octave_idx_type dim2 (void) const 
+  octave_idx_type dim2 (void) const
     { return Array<octave_idx_type>::length (); }
 
   octave_idx_type rows (void) const { return dim1 (); }
   octave_idx_type cols (void) const { return dim2 (); }
   octave_idx_type columns (void) const { return dim2 (); }
 
-  octave_idx_type perm_length (void) const 
+  octave_idx_type perm_length (void) const
     { return Array<octave_idx_type>::length (); }
   // FIXME: a dangerous ambiguity?
-  octave_idx_type length (void) const 
+  octave_idx_type length (void) const
     { return perm_length (); }
   octave_idx_type nelem (void) const { return dim1 () * dim2 (); }
   octave_idx_type numel (void) const { return nelem (); }
 
-  size_t byte_size (void) const 
+  size_t byte_size (void) const
     { return Array<octave_idx_type>::byte_size (); }
 
   dim_vector dims (void) const { return dim_vector (dim1 (), dim2 ()); }
 
   Array<octave_idx_type> pvec (void) const
     { return *this; }
 
-  octave_idx_type 
+  octave_idx_type
   elem (octave_idx_type i, octave_idx_type j) const
     {
-      return (_colp 
+      return (_colp
               ? ((Array<octave_idx_type>::elem (j) == i) ? 1 : 0)
               : ((Array<octave_idx_type>::elem (i) == j) ? 1 : 0));
     }
 
-  octave_idx_type 
+  octave_idx_type
   checkelem (octave_idx_type i, octave_idx_type j) const;
 
   octave_idx_type
   operator () (octave_idx_type i, octave_idx_type j) const
     {
 #if defined (BOUNDS_CHECKING)
       return checkelem (i, j);
 #else
       return elem (i, j);
 #endif
     }
-  
+
   // These are, in fact, super-fast.
   PermMatrix transpose (void) const;
   PermMatrix inverse (void) const;
 
   // Determinant, i.e. the sign of permutation.
   octave_idx_type determinant (void) const;
 
   // Efficient integer power of a permutation.
   PermMatrix power (octave_idx_type n) const;
 
   bool is_col_perm (void) const { return _colp; }
   bool is_row_perm (void) const { return !_colp; }
 
   friend OCTAVE_API PermMatrix operator *(const PermMatrix& a, const PermMatrix& b);
 
-  const octave_idx_type *data (void) const 
+  const octave_idx_type *data (void) const
     { return Array<octave_idx_type>::data (); }
 
-  const octave_idx_type *fortran_vec (void) const 
+  const octave_idx_type *fortran_vec (void) const
     { return Array<octave_idx_type>::fortran_vec (); }
 
-  octave_idx_type *fortran_vec (void) 
+  octave_idx_type *fortran_vec (void)
     { return Array<octave_idx_type>::fortran_vec (); }
 
   void print_info (std::ostream& os, const std::string& prefix) const
     { Array<octave_idx_type>::print_info (os, prefix); }
 
   static PermMatrix eye (octave_idx_type n);
 
 private:
   bool _colp;
 };
 
 // Multiplying permutations together.
-PermMatrix 
+PermMatrix
 OCTAVE_API
 operator *(const PermMatrix& a, const PermMatrix& b);
 
 #endif
diff --git a/liboctave/Quad.cc b/liboctave/Quad.cc
--- a/liboctave/Quad.cc
+++ b/liboctave/Quad.cc
@@ -36,50 +36,50 @@ static float_integrand_fcn float_user_fc
 // FIXME -- would be nice to not have to have this global
 // variable.
 // Nonzero means an error occurred in the calculation of the integrand
 // function, and the user wants us to quit.
 int quad_integration_error = 0;
 
 typedef octave_idx_type (*quad_fcn_ptr) (double*, int&, double*);
 typedef octave_idx_type (*quad_float_fcn_ptr) (float*, int&, float*);
-                              
+
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dqagp, DQAGP) (quad_fcn_ptr, const double&, const double&,
                            const octave_idx_type&, const double*,
                            const double&, const double&, double&,
                            double&, octave_idx_type&, octave_idx_type&,
                            const octave_idx_type&, const octave_idx_type&,
                            octave_idx_type&, octave_idx_type*, double*);
 
   F77_RET_T
   F77_FUNC (dqagi, DQAGI) (quad_fcn_ptr, const double&,
                            const octave_idx_type&, const double&,
                            const double&, double&, double&,
                            octave_idx_type&, octave_idx_type&,
                            const octave_idx_type&, const octave_idx_type&,
-                           octave_idx_type&, octave_idx_type*, double*); 
+                           octave_idx_type&, octave_idx_type*, double*);
 
   F77_RET_T
   F77_FUNC (qagp, QAGP) (quad_float_fcn_ptr, const float&, const float&,
                          const octave_idx_type&, const float*, const float&,
                          const float&, float&, float&, octave_idx_type&,
                          octave_idx_type&, const octave_idx_type&,
                          const octave_idx_type&, octave_idx_type&,
                          octave_idx_type*, float*);
 
   F77_RET_T
   F77_FUNC (qagi, QAGI) (quad_float_fcn_ptr, const float&,
                          const octave_idx_type&, const float&,
                          const float&, float&, float&, octave_idx_type&,
                          octave_idx_type&, const octave_idx_type&,
                          const octave_idx_type&, octave_idx_type&,
-                         octave_idx_type*, float*); 
+                         octave_idx_type*, float*);
 }
 
 static octave_idx_type
 user_function (double *x, int& ierr, double *result)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
 #if defined (__sparc) && defined (__GNUC__)
diff --git a/liboctave/Range.cc b/liboctave/Range.cc
--- a/liboctave/Range.cc
+++ b/liboctave/Range.cc
@@ -32,17 +32,17 @@ along with Octave; see the file COPYING.
 #include "Range.h"
 #include "lo-error.h"
 #include "lo-mappers.h"
 #include "lo-math.h"
 #include "lo-utils.h"
 #include "Array-util.h"
 
 Range::Range (double b, double i, octave_idx_type n)
-  : rng_base (b), rng_limit (b + n * i), rng_inc (i), 
+  : rng_base (b), rng_limit (b + n * i), rng_inc (i),
   rng_nelem (n), cache ()
 {
   if (! xfinite (b) || ! xfinite (i))
     rng_nelem = -2;
 }
 
 bool
 Range::all_elements_are_ints (void) const
@@ -88,23 +88,23 @@ Range::checkelem (octave_idx_type i) con
     gripe_index_out_of_range (1, 1, i+1, rng_nelem);
 
   return rng_base + rng_inc * i;
 }
 
 struct _rangeidx_helper
 {
   double *array, base, inc;
-  _rangeidx_helper (double *a, double b, double i) 
+  _rangeidx_helper (double *a, double b, double i)
     : array (a), base (b), inc (i) { }
   void operator () (octave_idx_type i)
     { *array++ = base + i * inc; }
 };
 
-Array<double> 
+Array<double>
 Range::index (const idx_vector& i) const
 {
   Array<double> retval;
 
   octave_idx_type n = rng_nelem;
 
   if (i.is_colon ())
     {
@@ -230,17 +230,17 @@ Range::sort_internal (Array<octave_idx_t
   octave_idx_type tmp = reverse ? nel - 1 : 0;
   octave_idx_type stp = reverse ? -1 : 1;
 
   for (octave_idx_type i = 0; i < nel; i++, tmp += stp)
     psidx[i] = tmp;
 
 }
 
-Matrix 
+Matrix
 Range::diag (octave_idx_type k) const
 {
   return matrix_value ().diag (k);
 }
 
 Range
 Range::sort (octave_idx_type dim, sortmode mode) const
 {
diff --git a/liboctave/Sparse.cc b/liboctave/Sparse.cc
--- a/liboctave/Sparse.cc
+++ b/liboctave/Sparse.cc
@@ -59,17 +59,17 @@ Sparse<T>::SparseRep::elem (octave_idx_t
   if (nzmx > 0)
     {
       for (i = c[_c]; i < c[_c + 1]; i++)
         if (r[i] == _r)
           return d[i];
         else if (r[i] > _r)
           break;
 
-      // Ok, If we've gotten here, we're in trouble.. Have to create a 
+      // Ok, If we've gotten here, we're in trouble.. Have to create a
       // new element in the sparse array. This' gonna be slow!!!
       if (c[ncols] == nzmx)
         {
           (*current_liboctave_error_handler)
             ("Sparse::SparseRep::elem (octave_idx_type, octave_idx_type): sparse matrix filled");
           return *d;
         }
 
@@ -80,17 +80,17 @@ Sparse<T>::SparseRep::elem (octave_idx_t
             {
               d[j] = d[j-1];
               r[j] = r[j-1];
             }
         }
 
       for (octave_idx_type j = _c + 1; j < ncols + 1; j++)
         c[j] = c[j] + 1;
-      
+
       d[i] = 0.;
       r[i] = _r;
 
       return d[i];
     }
   else
     {
       (*current_liboctave_error_handler)
@@ -169,45 +169,45 @@ bool
 Sparse<T>::SparseRep::indices_ok (void) const
 {
   return sparse_indices_ok (r, c, nrows, ncols, nnz ());
 }
 
 template <class T>
 Sparse<T>::Sparse (octave_idx_type nr, octave_idx_type nc, T val)
   : rep (0), dimensions (dim_vector (nr, nc))
-{ 
+{
   if (val != T ())
     {
       rep = new typename Sparse<T>::SparseRep (nr, nc, nr*nc);
 
       octave_idx_type ii = 0;
       xcidx (0) = 0;
       for (octave_idx_type j = 0; j < nc; j++)
         {
           for (octave_idx_type i = 0; i < nr; i++)
             {
               xdata (ii) = val;
               xridx (ii++) = i;
-            } 
+            }
           xcidx (j+1) = ii;
         }
     }
   else
     {
       rep = new typename Sparse<T>::SparseRep (nr, nc, 0);
       for (octave_idx_type j = 0; j < nc+1; j++)
         xcidx(j) = 0;
     }
 }
 
 template <class T>
 Sparse<T>::Sparse (const dim_vector& dv)
   : rep (0), dimensions (dv)
-{ 
+{
   if (dv.length() != 2)
     (*current_liboctave_error_handler)
       ("Sparse::Sparse (const dim_vector&): dimension mismatch");
   else
     rep = new typename Sparse<T>::SparseRep (dv(0), dv(1));
 }
 
 template <class T>
@@ -237,30 +237,30 @@ Sparse<T>::Sparse (const Sparse<T>& a, c
 
       octave_idx_type kk = 0;
       xcidx(0) = 0;
       for (octave_idx_type i = 0; i < old_nc; i++)
         for (octave_idx_type j = a.cidx(i); j < a.cidx(i+1); j++)
           {
             octave_idx_type tmp = i * old_nr + a.ridx(j);
             octave_idx_type ii = tmp % new_nr;
-            octave_idx_type jj = (tmp - ii) / new_nr; 
+            octave_idx_type jj = (tmp - ii) / new_nr;
             for (octave_idx_type k = kk; k < jj; k++)
               xcidx(k+1) = j;
             kk = jj;
             xdata(j) = a.data(j);
             xridx(j) = ii;
           }
       for (octave_idx_type k = kk; k < new_nc; k++)
         xcidx(k+1) = new_nzmx;
     }
 }
 
 template <class T>
-Sparse<T>::Sparse (const Array<T>& a, const idx_vector& r, 
+Sparse<T>::Sparse (const Array<T>& a, const idx_vector& r,
                    const idx_vector& c, octave_idx_type nr,
                    octave_idx_type nc, bool sum_terms,
                    octave_idx_type nzm)
   : rep (0), dimensions ()
 {
   if (nr < 0)
     nr = r.extent (0);
   else if (r.extent (nr) > nr)
@@ -285,17 +285,17 @@ Sparse<T>::Sparse (const Array<T>& a, co
       if (rl != 1)
         n = rl;
       else if (cl != 1)
         n = cl;
     }
 
   if ((rl != 1 && rl != n) || (cl != 1 && cl != n))
     (*current_liboctave_error_handler) ("sparse: dimension mismatch");
-    
+
   if (rl <= 1 && cl <= 1)
     {
       if (n == 1 && a(0) != T ())
         {
           change_capacity (nzm > 1 ? nzm : 1);
           xridx(0) = r(0);
           xdata(0) = a(0);
           for (octave_idx_type j = 0; j < nc; j++)
@@ -451,17 +451,17 @@ Sparse<T>::Sparse (const Array<T>& a, co
             }
         }
     }
   else if (cl == 1)
     {
       // Sparse column vector. Sort row indices.
       Array<octave_idx_type> rsi;
       idx_vector rs = r.sorted (rsi);
-      
+
       octave_quit ();
 
       const octave_idx_type *rd = rs.raw (), *rdi = rsi.data ();
       // Count unique indices.
       octave_idx_type new_nz = 1;
       for (octave_idx_type i = 1; i < n; i++)
         new_nz += rd[i-1] != rd[i];
       // Allocate result.
@@ -734,17 +734,17 @@ Sparse<T>::range_error (const char *fcn,
 
   if (n > 0)
     buf << ra_idx(0);
 
   for (octave_idx_type i = 1; i < n; i++)
     buf << ", " << ra_idx(i);
 
   buf << "): range error";
-  
+
   std::string buf_str = buf.str ();
 
   (*current_liboctave_error_handler) (buf_str.c_str ());
 
   return T ();
 }
 
 template <class T>
@@ -804,17 +804,17 @@ Sparse<T>::reshape (const dim_vector& ne
 
           octave_idx_type kk = 0;
           retval.xcidx(0) = 0;
           for (octave_idx_type i = 0; i < old_nc; i++)
             for (octave_idx_type j = cidx(i); j < cidx(i+1); j++)
               {
                 octave_idx_type tmp = i * old_nr + ridx(j);
                 octave_idx_type ii = tmp % new_nr;
-                octave_idx_type jj = (tmp - ii) / new_nr; 
+                octave_idx_type jj = (tmp - ii) / new_nr;
                 for (octave_idx_type k = kk; k < jj; k++)
                   retval.xcidx(k+1) = j;
                 kk = jj;
                 retval.xdata(j) = data(j);
                 retval.xridx(j) = ii;
               }
           for (octave_idx_type k = kk; k < new_nc; k++)
             retval.xcidx(k+1) = new_nnz;
@@ -1308,17 +1308,17 @@ Sparse<T>::index (const idx_vector& idx,
         {
           // Fast magic colon processing.
           retval = Sparse<T> (nel, 1, nz);
 
           for (octave_idx_type i = 0; i < nc; i++)
             {
               for (octave_idx_type j = cidx(i); j < cidx(i+1); j++)
                 {
-                  retval.xdata(j) = data(j); 
+                  retval.xdata(j) = data(j);
                   retval.xridx(j) = ridx(j) + i * nr;
                 }
             }
 
           retval.xcidx(0) = 0;
           retval.xcidx(1) = nz;
         }
     }
@@ -1334,18 +1334,18 @@ Sparse<T>::index (const idx_vector& idx,
         }
       else
         gripe_index_out_of_range (1, 1, idx.extent (nel), nel);
     }
   else if (nr == 1 && nc == 1)
     {
       // You have to be pretty sick to get to this bit of code,
       // since you have a scalar stored as a sparse matrix, and
-      // then want to make a dense matrix with sparse 
-      // representation. Ok, we'll do it, but you deserve what 
+      // then want to make a dense matrix with sparse
+      // representation. Ok, we'll do it, but you deserve what
       // you get!!
       retval = Sparse<T> (idx_dims(0), idx_dims(1), nz ? data(0) : T ());
     }
   else if (nc == 1)
     {
       // Sparse column vector.
       octave_idx_type lb, ub;
 
@@ -1386,17 +1386,17 @@ Sparse<T>::index (const idx_vector& idx,
               retval = Sparse<T> (tmp);
             }
         }
       else
         {
           // If indexing a sparse column vector by a vector, the result is a
           // sparse column vector, otherwise it inherits the shape of index.
           // Vector transpose is cheap, so do it right here.
-          const Array<octave_idx_type> idxa = (idx_dims(0) == 1 
+          const Array<octave_idx_type> idxa = (idx_dims(0) == 1
                                                ? idx.as_array ().transpose ()
                                                : idx.as_array ());
 
           octave_idx_type new_nr = idxa.rows (), new_nc = idxa.cols ();
 
           // Lookup.
           // FIXME: Could specialize for sorted idx?
           NoAlias< Array<octave_idx_type> > lidx (dim_vector (new_nr, new_nc));
@@ -1415,17 +1415,17 @@ Sparse<T>::index (const idx_vector& idx,
                     nzj++;
                   else
                     lidx(i, j) = nz;
                 }
               retval.xcidx(j+1) = retval.xcidx(j) + nzj;
             }
 
           retval.change_capacity (retval.xcidx(new_nc));
-          
+
           // Copy data and set row indices.
           octave_idx_type k = 0;
           for (octave_idx_type j = 0; j < new_nc; j++)
             for (octave_idx_type i = 0; i < new_nr; i++)
               {
                 octave_idx_type l = lidx(i, j);
                 if (l < nz)
                   {
@@ -1453,24 +1453,24 @@ Sparse<T>::index (const idx_vector& idx,
         {
           // Sparse row vectors occupy O(nr) storage anyway, so let's just
           // convert the matrix to full, index, and sparsify the result.
           retval = Sparse<T> (array_value ().index (idx));
         }
     }
   else
     {
-      (*current_liboctave_warning_with_id_handler) 
+      (*current_liboctave_warning_with_id_handler)
         ("Octave:fortran-indexing", "single index used for sparse matrix");
 
       if (nr != 0 && idx.is_scalar ())
         retval = Sparse<T> (1, 1, elem (idx(0) % nr, idx(0) / nr));
       else
         {
-          // Indexing a non-vector sparse matrix by linear indexing. 
+          // Indexing a non-vector sparse matrix by linear indexing.
           // I suppose this is rare (and it may easily overflow), so let's take the easy way,
           // and reshape first to column vector, which is already handled above.
           retval = index (idx_vector::colon).index (idx);
           // In this case we're supposed to always inherit the shape, but column(row) doesn't do
           // it, so we'll do it instead.
           if (idx_dims(0) == 1 && idx_dims(1) != 1)
             retval = retval.transpose ();
         }
@@ -1712,17 +1712,17 @@ Sparse<T>::assign (const idx_vector& idx
   octave_idx_type rhl = rhs.numel ();
 
   if (idx.length (n) == rhl)
     {
       if (rhl == 0)
         return;
 
       octave_idx_type nx = idx.extent (n);
-      // Try to resize first if necessary. 
+      // Try to resize first if necessary.
       if (nx != n)
         {
           resize1 (nx);
           n = numel ();
           nr = rows ();
           nc = cols ();
           // nz is preserved.
         }
@@ -1749,17 +1749,17 @@ Sparse<T>::assign (const idx_vector& idx
                   // Adding/overwriting elements, enough capacity allocated.
 
                   if (new_nz > nz)
                     {
                       // Make room first.
                       std::copy_backward (data () + ui, data () + nz, data () + nz + rnz);
                       std::copy_backward (ridx () + ui, ridx () + nz, ridx () + nz + rnz);
                     }
-                  
+
                   // Copy data and adjust indices from rhs.
                   copy_or_memcpy (rnz, rhs.data (), data () + li);
                   mx_inline_add (rnz, ridx () + li, rhs.ridx (), lb);
                 }
               else
                 {
                   // Clearing elements or exceeding capacity, allocate afresh
                   // and paste pieces.
@@ -1859,17 +1859,17 @@ Sparse<T>::assign (const idx_vector& idx
   octave_idx_type m = rhs.columns ();
 
   if (idx_i.length (nr) == n && idx_j.length (nc) == m)
     {
       if (n == 0 || m == 0)
         return;
 
       octave_idx_type nrx = idx_i.extent (nr), ncx = idx_j.extent (nc);
-      // Try to resize first if necessary. 
+      // Try to resize first if necessary.
       if (nrx != nr || ncx != nc)
         {
           resize (nrx, ncx);
           nr = rows ();
           nc = cols ();
           // nz is preserved.
         }
 
@@ -1939,17 +1939,17 @@ Sparse<T>::assign (const idx_vector& idx
             {
               *this = rhs.index (idx_i, idx_j.inverse_permutation (nc));
             }
           else
             {
               const Sparse<T> tmp = *this;
               *this = Sparse<T> (nr, nc);
               OCTAVE_LOCAL_BUFFER_INIT (octave_idx_type, jsav, nc, -1);
-              
+
               // Assemble column lengths.
               for (octave_idx_type i = 0; i < nc; i++)
                 xcidx(i+1) = tmp.cidx(i+1) - tmp.cidx(i);
 
               for (octave_idx_type i = 0; i < m; i++)
                 {
                   octave_idx_type j =idx_j(i);
                   jsav[j] = i;
@@ -1992,17 +1992,17 @@ Sparse<T>::assign (const idx_vector& idx
       else if (idx_j.is_colon ())
         {
           if (idx_i.is_permutation (nr))
             {
               *this = rhs.index (idx_i.inverse_permutation (nr), idx_j);
             }
           else
             {
-              // FIXME: optimize more special cases? 
+              // FIXME: optimize more special cases?
               // In general this requires unpacking the columns, which is slow,
               // especially for many small columns. OTOH, transpose is an
               // efficient O(nr+nc+nnz) operation.
               *this = transpose ();
               assign (idx_vector::colon, idx_i, rhs.transpose ());
               *this = transpose ();
             }
         }
@@ -2022,29 +2022,29 @@ Sparse<T>::assign (const idx_vector& idx
         assign (idx_i, idx_j, Sparse<T> (n, m, rhs.data (0)));
       else
         assign (idx_i, idx_j, Sparse<T> (n, m));
     }
   else
     gripe_assignment_dimension_mismatch ();
 }
 
-// Can't use versions of these in Array.cc due to duplication of the 
+// Can't use versions of these in Array.cc due to duplication of the
 // instantiations for Array<double and Sparse<double>, etc
 template <class T>
-bool 
-sparse_ascending_compare (typename ref_param<T>::type a, 
+bool
+sparse_ascending_compare (typename ref_param<T>::type a,
                           typename ref_param<T>::type b)
 {
   return (a < b);
 }
 
 template <class T>
-bool 
-sparse_descending_compare (typename ref_param<T>::type a, 
+bool
+sparse_descending_compare (typename ref_param<T>::type a,
                            typename ref_param<T>::type b)
 {
   return (a > b);
 }
 
 template <class T>
 Sparse<T>
 Sparse<T>::sort (octave_idx_type dim, sortmode mode) const
@@ -2061,63 +2061,63 @@ Sparse<T>::sort (octave_idx_type dim, so
     {
       m = m.transpose ();
       nr = m.rows ();
       nc = m.columns ();
     }
 
   octave_sort<T> lsort;
 
-  if (mode == ASCENDING) 
+  if (mode == ASCENDING)
     lsort.set_compare (sparse_ascending_compare<T>);
   else if (mode == DESCENDING)
     lsort.set_compare (sparse_descending_compare<T>);
   else
     abort ();
 
   T *v = m.data ();
   octave_idx_type *mcidx = m.cidx ();
   octave_idx_type *mridx = m.ridx ();
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       octave_idx_type ns = mcidx [j + 1] - mcidx [j];
       lsort.sort (v, ns);
 
       octave_idx_type i;
-      if (mode == ASCENDING) 
+      if (mode == ASCENDING)
         {
           for (i = 0; i < ns; i++)
             if (sparse_ascending_compare<T> (static_cast<T> (0), v [i]))
               break;
         }
       else
         {
           for (i = 0; i < ns; i++)
             if (sparse_descending_compare<T> (static_cast<T> (0), v [i]))
               break;
         }
       for (octave_idx_type k = 0; k < i; k++)
         mridx [k] = k;
       for (octave_idx_type k = i; k < ns; k++)
-        mridx [k] = k - ns + nr; 
+        mridx [k] = k - ns + nr;
 
       v += ns;
       mridx += ns;
     }
 
   if (dim > 0)
       m = m.transpose ();
 
   return m;
 }
 
 template <class T>
 Sparse<T>
-Sparse<T>::sort (Array<octave_idx_type> &sidx, octave_idx_type dim, 
+Sparse<T>::sort (Array<octave_idx_type> &sidx, octave_idx_type dim,
                  sortmode mode) const
 {
   Sparse<T> m = *this;
 
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.columns ();
 
   if (m.length () < 1 || dim > 1)
@@ -2130,17 +2130,17 @@ Sparse<T>::sort (Array<octave_idx_type> 
     {
       m = m.transpose ();
       nr = m.rows ();
       nc = m.columns ();
     }
 
   octave_sort<T> indexed_sort;
 
-  if (mode == ASCENDING) 
+  if (mode == ASCENDING)
     indexed_sort.set_compare (sparse_ascending_compare<T>);
   else if (mode == DESCENDING)
     indexed_sort.set_compare (sparse_descending_compare<T>);
   else
     abort ();
 
   T *v = m.data ();
   octave_idx_type *mcidx = m.cidx ();
@@ -2162,17 +2162,17 @@ Sparse<T>::sort (Array<octave_idx_type> 
       else
         {
           for (octave_idx_type i = 0; i < ns; i++)
             vi[i] = mridx[i];
 
           indexed_sort.sort (v, vi, ns);
 
           octave_idx_type i;
-          if (mode == ASCENDING) 
+          if (mode == ASCENDING)
             {
               for (i = 0; i < ns; i++)
                 if (sparse_ascending_compare<T> (static_cast<T> (0), v[i]))
                   break;
             }
           else
             {
               for (i = 0; i < ns; i++)
@@ -2194,17 +2194,17 @@ Sparse<T>::sort (Array<octave_idx_type> 
             {
               sidx (k + offset) = vi [k];
               mridx [k] = k;
             }
 
           for (octave_idx_type k = i; k < ns; k++)
             {
               sidx (k - ns + nr + offset) = vi [k];
-              mridx [k] = k - ns + nr; 
+              mridx [k] = k - ns + nr;
             }
 
           v += ns;
           mridx += ns;
         }
     }
 
   if (dim > 0)
@@ -2252,17 +2252,17 @@ Sparse<T>::diag (octave_idx_type k) cons
                   nel++;
             }
           else
             {
               for (octave_idx_type i = 0; i < ndiag; i++)
                 if (elem (i, i) != 0.)
                   nel++;
             }
-      
+
           d = Sparse<T> (ndiag, 1, nel);
           d.xcidx (0) = 0;
           d.xcidx (1) = nel;
 
           octave_idx_type ii = 0;
           if (k > 0)
             {
               for (octave_idx_type i = 0; i < ndiag; i++)
@@ -2296,35 +2296,35 @@ Sparse<T>::diag (octave_idx_type k) cons
                     {
                       d.xdata (ii) = tmp;
                       d.xridx (ii++) = i;
                     }
                 }
             }
         }
       else
-        (*current_liboctave_error_handler) 
+        (*current_liboctave_error_handler)
           ("diag: requested diagonal out of range");
     }
   else if (nnr != 0 && nnc != 0)
     {
       octave_idx_type roff = 0;
       octave_idx_type coff = 0;
-      if (k > 0) 
+      if (k > 0)
         {
           roff = 0;
           coff = k;
-        } 
-      else if (k < 0) 
+        }
+      else if (k < 0)
         {
           roff = -k;
           coff = 0;
         }
 
-      if (nnr == 1) 
+      if (nnr == 1)
         {
           octave_idx_type n = nnc + std::abs (k);
           octave_idx_type nz = nnz ();
 
           d = Sparse<T> (n, n, nz);
 
           if (nnz () > 0)
             {
@@ -2339,18 +2339,18 @@ Sparse<T>::diag (octave_idx_type k) cons
                       d.xridx (i) = j + roff;
                     }
                   d.xcidx (j + coff + 1) = cidx(j+1);
                 }
 
               for (octave_idx_type i = nnc + coff + 1; i < n + 1; i++)
                 d.xcidx (i) = nz;
             }
-        } 
-      else 
+        }
+      else
         {
           octave_idx_type n = nnr + std::abs (k);
           octave_idx_type nz = nnz ();
 
           d = Sparse<T> (n, n, nz);
 
           if (nnz () > 0)
             {
@@ -2413,17 +2413,17 @@ Sparse<T>::cat (int dim, octave_idx_type
           total_nz += sparse_list[i].nnz ();
         }
     }
   else
     (*current_liboctave_error_handler)
       ("cat: invalid dimension for sparse concatenation");
 
   Sparse<T> retval (dv, total_nz);
-  
+
   if (retval.is_empty ())
     return retval;
 
   switch (dim)
     {
     case 0:
       {
         // sparse vertcat. This is not efficiently handled by assignment, so
diff --git a/liboctave/Sparse.h b/liboctave/Sparse.h
--- a/liboctave/Sparse.h
+++ b/liboctave/Sparse.h
@@ -70,46 +70,46 @@ protected:
     octave_idx_type ncols;
     int count;
 
     SparseRep (void) : d (0), r (0), c (new octave_idx_type [1]), nzmx (0), nrows (0),
                        ncols (0), count (1) { c[0] = 0; }
 
     SparseRep (octave_idx_type n) : d (0), r (0), c (new octave_idx_type [n+1]), nzmx (0), nrows (n),
       ncols (n), count (1)
-      { 
+      {
         for (octave_idx_type i = 0; i < n + 1; i++)
           c[i] = 0;
       }
 
-    SparseRep (octave_idx_type nr, octave_idx_type nc) : d (0), r (0), c (new octave_idx_type [nc+1]), nzmx (0), 
+    SparseRep (octave_idx_type nr, octave_idx_type nc) : d (0), r (0), c (new octave_idx_type [nc+1]), nzmx (0),
       nrows (nr), ncols (nc), count (1)
-      { 
+      {
         for (octave_idx_type i = 0; i < nc + 1; i++)
           c[i] = 0;
       }
 
-    SparseRep (octave_idx_type nr, octave_idx_type nc, octave_idx_type nz) : d (new T [nz]), 
-      r (new octave_idx_type [nz]), c (new octave_idx_type [nc+1]), nzmx (nz), nrows (nr), 
+    SparseRep (octave_idx_type nr, octave_idx_type nc, octave_idx_type nz) : d (new T [nz]),
+      r (new octave_idx_type [nz]), c (new octave_idx_type [nc+1]), nzmx (nz), nrows (nr),
       ncols (nc), count (1)
-      { 
+      {
         for (octave_idx_type i = 0; i < nc + 1; i++)
           c[i] = 0;
       }
 
     SparseRep (const SparseRep& a)
-      : d (new T [a.nzmx]), r (new octave_idx_type [a.nzmx]), c (new octave_idx_type [a.ncols + 1]), 
+      : d (new T [a.nzmx]), r (new octave_idx_type [a.nzmx]), c (new octave_idx_type [a.ncols + 1]),
       nzmx (a.nzmx), nrows (a.nrows), ncols (a.ncols), count (1)
       {
         octave_idx_type nz = a.nnz ();
         copy_or_memcpy (nz, a.d, d);
         copy_or_memcpy (nz, a.r, r);
         copy_or_memcpy (ncols + 1, a.c, c);
       }
- 
+
     ~SparseRep (void) { delete [] d; delete [] r; delete [] c; }
 
     octave_idx_type length (void) const { return nzmx; }
 
     octave_idx_type nnz (void) const { return c [ncols]; }
 
     T& elem (octave_idx_type _r, octave_idx_type _c);
 
@@ -173,39 +173,39 @@ private:
     }
 
 public:
 
   Sparse (void)
     : rep (nil_rep ()), dimensions (dim_vector(0,0)) { }
 
   explicit Sparse (octave_idx_type n)
-    : rep (new typename Sparse<T>::SparseRep (n)), 
+    : rep (new typename Sparse<T>::SparseRep (n)),
       dimensions (dim_vector (n, n)) { }
 
   explicit Sparse (octave_idx_type nr, octave_idx_type nc)
-    : rep (new typename Sparse<T>::SparseRep (nr, nc)), 
+    : rep (new typename Sparse<T>::SparseRep (nr, nc)),
       dimensions (dim_vector (nr, nc)) { }
 
   explicit Sparse (octave_idx_type nr, octave_idx_type nc, T val);
 
   Sparse (const dim_vector& dv, octave_idx_type nz)
     : rep (new typename Sparse<T>::SparseRep (dv(0), dv(1), nz)),
     dimensions (dv) { }
 
   Sparse (octave_idx_type nr, octave_idx_type nc, octave_idx_type nz)
     : rep (new typename Sparse<T>::SparseRep (nr, nc, nz)),
       dimensions (dim_vector (nr, nc)) { }
 
   // Type conversion case. Preserves capacity ().
-  template <class U> 
+  template <class U>
   Sparse (const Sparse<U>& a)
     : rep (new typename Sparse<T>::SparseRep (a.rep->nrows, a.rep->ncols, a.rep->nzmx)),
-    dimensions (a.dimensions) 
-    { 
+    dimensions (a.dimensions)
+    {
       octave_idx_type nz = a.nnz ();
       std::copy (a.rep->d, a.rep->d + nz, rep->d);
       copy_or_memcpy (nz, a.rep->r, rep->r);
       copy_or_memcpy (rep->ncols + 1, a.rep->c, rep->c);
     }
 
   // No type conversion case.
   Sparse (const Sparse<T>& a)
@@ -235,19 +235,19 @@ public:
   // non-zero elements, while nnz is the actual number of non-zero
   // terms.
   octave_idx_type nzmax (void) const { return rep->length (); }
   octave_idx_type capacity (void) const { return nzmax (); }
   octave_idx_type nnz (void) const { return rep->nnz (); }
 
   // Querying the number of elements (incl. zeros) may overflow the index type,
   // so don't do it unless you really need it.
-  octave_idx_type numel (void) const 
-    { 
-      return dimensions.safe_numel (); 
+  octave_idx_type numel (void) const
+    {
+      return dimensions.safe_numel ();
     }
 
   octave_idx_type nelem (void) const { return capacity (); }
   octave_idx_type length (void) const { return numel (); }
 
   octave_idx_type dim1 (void) const { return dimensions(0); }
   octave_idx_type dim2 (void) const { return dimensions(1); }
 
@@ -259,51 +259,51 @@ public:
   octave_idx_type get_col_index (octave_idx_type k)
     {
       octave_idx_type ret = 0;
       while (cidx(ret+1) < k)
         ret++;
       return ret;
     }
 
-  size_t byte_size (void) const 
-    { 
+  size_t byte_size (void) const
+    {
       return (static_cast<size_t>(cols () + 1) * sizeof (octave_idx_type)
-              + static_cast<size_t> (capacity ()) * (sizeof (T) + sizeof (octave_idx_type))); 
+              + static_cast<size_t> (capacity ()) * (sizeof (T) + sizeof (octave_idx_type)));
     }
 
   dim_vector dims (void) const { return dimensions; }
 
   Sparse<T> squeeze (void) const { return *this; }
-  
+
   octave_idx_type compute_index (const Array<octave_idx_type>& ra_idx) const;
 
   T range_error (const char *fcn, octave_idx_type n) const;
   T& range_error (const char *fcn, octave_idx_type n);
 
   T range_error (const char *fcn, octave_idx_type i, octave_idx_type j) const;
   T& range_error (const char *fcn, octave_idx_type i, octave_idx_type j);
 
   T range_error (const char *fcn, const Array<octave_idx_type>& ra_idx) const;
   T& range_error (const char *fcn, const Array<octave_idx_type>& ra_idx);
 
   // No checking, even for multiple references, ever.
 
-  T& xelem (octave_idx_type n) 
-    { 
-      octave_idx_type i = n % rows (), j = n / rows(); 
-      return xelem (i, j); 
+  T& xelem (octave_idx_type n)
+    {
+      octave_idx_type i = n % rows (), j = n / rows();
+      return xelem (i, j);
     }
 
-  T xelem (octave_idx_type n) const 
-    { 
-      octave_idx_type i = n % rows (), j = n / rows(); 
-      return xelem (i, j); 
+  T xelem (octave_idx_type n) const
+    {
+      octave_idx_type i = n % rows (), j = n / rows();
+      return xelem (i, j);
     }
-  
+
   T& xelem (octave_idx_type i, octave_idx_type j) { return rep->elem (i, j); }
   T xelem (octave_idx_type i, octave_idx_type j) const { return rep->celem (i, j); }
 
   T& xelem (const Array<octave_idx_type>& ra_idx)
     { return xelem (compute_index (ra_idx)); }
 
   T xelem (const Array<octave_idx_type>& ra_idx) const
     { return xelem (compute_index (ra_idx)); }
@@ -345,20 +345,20 @@ public:
     }
 
   T& elem (octave_idx_type n)
     {
       make_unique ();
       return xelem (n);
     }
 
-  T& elem (octave_idx_type i, octave_idx_type j) 
-    { 
+  T& elem (octave_idx_type i, octave_idx_type j)
+    {
       make_unique ();
-      return xelem (i, j); 
+      return xelem (i, j);
     }
 
   T& elem (const Array<octave_idx_type>& ra_idx)
     { return Sparse<T>::elem (compute_index (ra_idx)); }
 
 #if defined (BOUNDS_CHECKING)
   T& operator () (octave_idx_type n) { return checkelem (n); }
   T& operator () (octave_idx_type i, octave_idx_type j) { return checkelem (i, j); }
@@ -407,43 +407,43 @@ public:
   T operator () (octave_idx_type i, octave_idx_type j) const { return checkelem (i, j); }
   T operator () (const Array<octave_idx_type>& ra_idx) const { return checkelem (ra_idx); }
 #else
   T operator () (octave_idx_type n) const { return elem (n); }
   T operator () (octave_idx_type i, octave_idx_type j) const { return elem (i, j); }
   T operator () (const Array<octave_idx_type>& ra_idx) const { return elem (ra_idx); }
 #endif
 
-  Sparse<T> maybe_compress (bool remove_zeros = false) 
-    { 
+  Sparse<T> maybe_compress (bool remove_zeros = false)
+    {
       if (remove_zeros)
         make_unique (); // Needs to unshare because elements are removed.
 
-      rep->maybe_compress (remove_zeros); 
-      return (*this); 
+      rep->maybe_compress (remove_zeros);
+      return (*this);
     }
 
   Sparse<T> reshape (const dim_vector& new_dims) const;
 
   Sparse<T> permute (const Array<octave_idx_type>& vec, bool inv = false) const;
 
   Sparse<T> ipermute (const Array<octave_idx_type>& vec) const
     { return permute (vec, true); }
 
   void resize1 (octave_idx_type n);
 
   void resize (octave_idx_type r, octave_idx_type c);
 
   void resize (const dim_vector& dv);
 
-  void change_capacity (octave_idx_type nz) 
-    { 
+  void change_capacity (octave_idx_type nz)
+    {
       if (nz < nnz ())
         make_unique (); // Unshare now because elements will be truncated.
-      rep->change_length (nz); 
+      rep->change_length (nz);
     }
 
   Sparse<T>& insert (const Sparse<T>& a, octave_idx_type r, octave_idx_type c);
   Sparse<T>& insert (const Sparse<T>& a, const Array<octave_idx_type>& idx);
 
   bool is_square (void) const { return (dim1 () == dim2 ()); }
 
   bool is_empty (void) const { return (rows () < 1 && cols () < 1); }
@@ -521,17 +521,17 @@ public:
   {
     Sparse<U> result;
     U f_zero = fcn (0.);
 
     if (f_zero != 0.)
       {
         octave_idx_type nr = rows ();
         octave_idx_type nc = cols ();
-      
+
         result = Sparse<U> (nr, nc, f_zero);
 
         for (octave_idx_type j = 0; j < nc; j++)
           for (octave_idx_type i = cidx(j); i < cidx (j+1); i++)
             {
               octave_quit ();
               /* Use data instead of elem for better performance.  */
               result.data (ridx (i) + j * nr) = fcn (data(i));
@@ -596,17 +596,17 @@ read_sparse_matrix (std::istream& is, Sp
   if (nr > 0 && nc > 0)
     {
       octave_idx_type itmp;
       octave_idx_type jtmp;
       octave_idx_type iold = 0;
       octave_idx_type jold = 0;
       octave_idx_type ii = 0;
       T tmp;
-       
+
       a.cidx (0) = 0;
       for (octave_idx_type i = 0; i < nz; i++)
         {
           itmp = 0; jtmp = 0;
           is >> itmp;
           itmp--;
 
           is >> jtmp;
@@ -649,28 +649,28 @@ read_sparse_matrix (std::istream& is, Sp
               is.setstate (std::ios::failbit);
               goto done;
             }
 
           iold = itmp;
           jold = jtmp;
 
           tmp = read_fcn (is);
-          
+
           if (is)
             {
               a.data (ii) = tmp;
               a.ridx (ii++) = itmp;
             }
           else
             goto done;
         }
 
       for (octave_idx_type j = jold; j < nc; j++)
         a.cidx(j+1) = ii;
     }
-  
+
  done:
 
   return is;
 }
 
 #endif
diff --git a/liboctave/SparseCmplxCHOL.cc b/liboctave/SparseCmplxCHOL.cc
--- a/liboctave/SparseCmplxCHOL.cc
+++ b/liboctave/SparseCmplxCHOL.cc
@@ -55,16 +55,16 @@ chol2inv (const SparseComplexMatrix& r)
           retval = rinv.transpose() * rinv;
         }
       else if (typ == MatrixType::Lower)
         {
           rinv = r.transpose().inverse(mattype, info, rcond, true, false);
           retval = rinv.transpose() * rinv;
         }
       else
-        (*current_liboctave_error_handler) 
+        (*current_liboctave_error_handler)
           ("spchol2inv requires triangular matrix");
     }
   else
     (*current_liboctave_error_handler) ("spchol2inv requires square matrix");
 
   return retval;
 }
diff --git a/liboctave/SparseCmplxCHOL.h b/liboctave/SparseCmplxCHOL.h
--- a/liboctave/SparseCmplxCHOL.h
+++ b/liboctave/SparseCmplxCHOL.h
@@ -25,74 +25,74 @@ along with Octave; see the file COPYING.
 #define octave_sparse_complex_CHOL_h 1
 
 #include "sparse-base-chol.h"
 #include "dSparse.h"
 #include "CSparse.h"
 
 class
 OCTAVE_API
-SparseComplexCHOL : 
+SparseComplexCHOL :
   public sparse_base_chol <SparseComplexMatrix, Complex, SparseMatrix>
 {
 public:
 
-  SparseComplexCHOL (void) : 
+  SparseComplexCHOL (void) :
     sparse_base_chol<SparseComplexMatrix, Complex, SparseMatrix> () { }
 
-  SparseComplexCHOL (const SparseComplexMatrix& a, bool natural = true) : 
-    sparse_base_chol<SparseComplexMatrix, Complex, SparseMatrix> 
+  SparseComplexCHOL (const SparseComplexMatrix& a, bool natural = true) :
+    sparse_base_chol<SparseComplexMatrix, Complex, SparseMatrix>
   (a, natural) { }
 
-  SparseComplexCHOL (const SparseComplexMatrix& a, octave_idx_type& info, 
+  SparseComplexCHOL (const SparseComplexMatrix& a, octave_idx_type& info,
                      bool natural = true) :
-    sparse_base_chol<SparseComplexMatrix, Complex, SparseMatrix> 
+    sparse_base_chol<SparseComplexMatrix, Complex, SparseMatrix>
   (a, info, natural) { }
 
-  SparseComplexCHOL (const SparseComplexCHOL& a) : 
+  SparseComplexCHOL (const SparseComplexCHOL& a) :
     sparse_base_chol<SparseComplexMatrix, Complex, SparseMatrix> (a) { }
 
   ~SparseComplexCHOL (void) { }
 
   SparseComplexCHOL& operator = (const SparseComplexCHOL& a)
     {
       if (this != &a)
         sparse_base_chol <SparseComplexMatrix, Complex, SparseMatrix> ::
           operator = (a);
 
       return *this;
     }
 
   SparseComplexMatrix chol_matrix (void) const { return R(); }
 
-  SparseComplexMatrix L (void) const 
-    { return sparse_base_chol<SparseComplexMatrix, Complex, 
+  SparseComplexMatrix L (void) const
+    { return sparse_base_chol<SparseComplexMatrix, Complex,
         SparseMatrix>:: L (); }
 
-  SparseComplexMatrix R (void) const 
+  SparseComplexMatrix R (void) const
     { return sparse_base_chol<SparseComplexMatrix, Complex,
         SparseMatrix>:: R (); }
 
-  octave_idx_type P (void) const 
-   { return sparse_base_chol<SparseComplexMatrix, Complex, 
+  octave_idx_type P (void) const
+   { return sparse_base_chol<SparseComplexMatrix, Complex,
         SparseMatrix>:: P (); }
 
-  ColumnVector perm (void) const 
-    { return sparse_base_chol<SparseComplexMatrix, Complex, 
+  ColumnVector perm (void) const
+    { return sparse_base_chol<SparseComplexMatrix, Complex,
         SparseMatrix>:: perm (); }
 
-  SparseMatrix Q (void) const 
-    { return sparse_base_chol<SparseComplexMatrix, Complex, 
+  SparseMatrix Q (void) const
+    { return sparse_base_chol<SparseComplexMatrix, Complex,
         SparseMatrix>:: Q (); }
 
   double rcond (void) const
-    { return sparse_base_chol<SparseComplexMatrix, Complex, 
+    { return sparse_base_chol<SparseComplexMatrix, Complex,
         SparseMatrix>:: rcond (); }
 
   // Compute the inverse of a matrix using the Cholesky factorization.
   SparseComplexMatrix inverse (void) const
-    { return sparse_base_chol<SparseComplexMatrix, Complex, 
+    { return sparse_base_chol<SparseComplexMatrix, Complex,
         SparseMatrix>:: inverse (); }
 };
 
 SparseComplexMatrix OCTAVE_API chol2inv (const SparseComplexMatrix& r);
 
 #endif
diff --git a/liboctave/SparseCmplxLU.cc b/liboctave/SparseCmplxLU.cc
--- a/liboctave/SparseCmplxLU.cc
+++ b/liboctave/SparseCmplxLU.cc
@@ -37,17 +37,17 @@ along with Octave; see the file COPYING.
 
 #include "sparse-base-lu.h"
 #include "sparse-base-lu.cc"
 
 template class sparse_base_lu <SparseComplexMatrix, Complex, SparseMatrix, double>;
 
 #include "oct-sparse.h"
 
-SparseComplexLU::SparseComplexLU (const SparseComplexMatrix& a, 
+SparseComplexLU::SparseComplexLU (const SparseComplexMatrix& a,
                                   const Matrix& piv_thres, bool scale)
 {
 #ifdef HAVE_UMFPACK
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   // Setup the control parameters
   Matrix Control (UMFPACK_CONTROL, 1);
@@ -77,17 +77,17 @@ SparseComplexLU::SparseComplexLU (const 
           Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
     }
 
   // Set whether we are allowed to modify Q or not
   tmp = octave_sparse_params::get_key ("autoamd");
   if (!xisnan (tmp))
     Control (UMFPACK_FIXQ) = tmp;
 
-  // Turn-off UMFPACK scaling for LU 
+  // Turn-off UMFPACK scaling for LU
   if (scale)
     Control (UMFPACK_SCALE) = UMFPACK_SCALE_SUM;
   else
     Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
 
   UMFPACK_ZNAME (report_control) (control);
 
   const octave_idx_type *Ap = a.cidx ();
@@ -96,24 +96,24 @@ SparseComplexLU::SparseComplexLU (const 
 
   UMFPACK_ZNAME (report_matrix) (nr, nc, Ap, Ai,
                                  reinterpret_cast<const double *> (Ax),
                                  0, 1, control);
 
   void *Symbolic;
   Matrix Info (1, UMFPACK_INFO);
   double *info = Info.fortran_vec ();
-  int status = UMFPACK_ZNAME (qsymbolic) (nr, nc, Ap, Ai, 
+  int status = UMFPACK_ZNAME (qsymbolic) (nr, nc, Ap, Ai,
                                           reinterpret_cast<const double *> (Ax),
                                           0, 0,
                                           &Symbolic, control, info);
 
   if (status < 0)
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
             ("SparseComplexLU::SparseComplexLU symbolic factorization failed");
 
       UMFPACK_ZNAME (report_status) (control, status);
       UMFPACK_ZNAME (report_info) (control, info);
 
       UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
     }
   else
@@ -126,35 +126,35 @@ SparseComplexLU::SparseComplexLU (const 
                                         0, Symbolic, &Numeric, control,
                                         info);
       UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
 
       cond = Info (UMFPACK_RCOND);
 
       if (status < 0)
         {
-          (*current_liboctave_error_handler) 
+          (*current_liboctave_error_handler)
             ("SparseComplexLU::SparseComplexLU numeric factorization failed");
 
           UMFPACK_ZNAME (report_status) (control, status);
           UMFPACK_ZNAME (report_info) (control, info);
 
           UMFPACK_ZNAME (free_numeric) (&Numeric);
         }
       else
         {
           UMFPACK_ZNAME (report_numeric) (Numeric, control);
 
           octave_idx_type lnz, unz, ignore1, ignore2, ignore3;
           status = UMFPACK_ZNAME (get_lunz) (&lnz, &unz, &ignore1,
                                         &ignore2, &ignore3, Numeric) ;
-          
+
           if (status < 0)
             {
-              (*current_liboctave_error_handler) 
+              (*current_liboctave_error_handler)
                 ("SparseComplexLU::SparseComplexLU extracting LU factors failed");
 
               UMFPACK_ZNAME (report_status) (control, status);
               UMFPACK_ZNAME (report_info) (control, info);
 
               UMFPACK_ZNAME (free_numeric) (&Numeric);
             }
           else
@@ -175,17 +175,17 @@ SparseComplexLU::SparseComplexLU (const 
                 Ufact = SparseComplexMatrix (n_inner, nc,
                                              static_cast<octave_idx_type> (1));
               else
                 Ufact = SparseComplexMatrix (n_inner, nc, unz);
 
               octave_idx_type *Up = Ufact.cidx ();
               octave_idx_type *Uj = Ufact.ridx ();
               Complex *Ux = Ufact.data ();
-              
+
               Rfact = SparseMatrix (nr, nr, nr);
               for (octave_idx_type i = 0; i < nr; i++)
                 {
                   Rfact.xridx (i) = i;
                   Rfact.xcidx (i) = i;
                 }
               Rfact.xcidx (nr) = nr;
               double *Rx = Rfact.data ();
@@ -203,61 +203,61 @@ SparseComplexLU::SparseComplexLU (const 
                                                     reinterpret_cast <double *> (Ux),
                                                     0, p, q, 0, 0,
                                                     &do_recip, Rx, Numeric);
 
               UMFPACK_ZNAME (free_numeric) (&Numeric) ;
 
               if (status < 0)
                 {
-                  (*current_liboctave_error_handler) 
+                  (*current_liboctave_error_handler)
                     ("SparseComplexLU::SparseComplexLU extracting LU factors failed");
 
                   UMFPACK_ZNAME (report_status) (control, status);
                 }
               else
                 {
                   Lfact = Lfact.transpose ();
 
                   if (do_recip)
                     for (octave_idx_type i = 0; i < nr; i++)
                       Rx[i] = 1.0 / Rx[i];
 
                   UMFPACK_ZNAME (report_matrix) (nr, n_inner,
-                                            Lfact.cidx (), Lfact.ridx (), 
-                                            reinterpret_cast<double *> (Lfact.data()), 
+                                            Lfact.cidx (), Lfact.ridx (),
+                                            reinterpret_cast<double *> (Lfact.data()),
                                             0, 1, control);
 
                   UMFPACK_ZNAME (report_matrix) (n_inner, nc,
-                                            Ufact.cidx (), Ufact.ridx (), 
-                                            reinterpret_cast<double *> (Ufact.data()), 
+                                            Ufact.cidx (), Ufact.ridx (),
+                                            reinterpret_cast<double *> (Ufact.data()),
                                             0, 1, control);
                   UMFPACK_ZNAME (report_perm) (nr, p, control);
                   UMFPACK_ZNAME (report_perm) (nc, q, control);
                 }
 
               UMFPACK_ZNAME (report_info) (control, info);
             }
         }
     }
 #else
   (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 }
 
-SparseComplexLU::SparseComplexLU (const SparseComplexMatrix& a, 
-                                  const ColumnVector& Qinit, 
+SparseComplexLU::SparseComplexLU (const SparseComplexMatrix& a,
+                                  const ColumnVector& Qinit,
                                   const Matrix& piv_thres, bool scale,
-                                  bool FixedQ, double droptol, 
+                                  bool FixedQ, double droptol,
                                   bool milu, bool udiag)
 {
 #ifdef HAVE_UMFPACK
   if (milu)
-    (*current_liboctave_error_handler) 
-      ("Modified incomplete LU not implemented");   
+    (*current_liboctave_error_handler)
+      ("Modified incomplete LU not implemented");
   else
     {
       octave_idx_type nr = a.rows ();
       octave_idx_type nc = a.cols ();
 
       // Setup the control parameters
       Matrix Control (UMFPACK_CONTROL, 1);
       double *control = Control.fortran_vec ();
@@ -294,94 +294,94 @@ SparseComplexLU::SparseComplexLU (const 
         Control (UMFPACK_FIXQ) = 1.0;
       else
         {
           tmp = octave_sparse_params::get_key ("autoamd");
           if (!xisnan (tmp))
             Control (UMFPACK_FIXQ) = tmp;
         }
 
-      // Turn-off UMFPACK scaling for LU 
+      // Turn-off UMFPACK scaling for LU
       if (scale)
         Control (UMFPACK_SCALE) = UMFPACK_SCALE_SUM;
       else
         Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
 
       UMFPACK_ZNAME (report_control) (control);
 
       const octave_idx_type *Ap = a.cidx ();
       const octave_idx_type *Ai = a.ridx ();
       const Complex *Ax = a.data ();
 
-      UMFPACK_ZNAME (report_matrix) (nr, nc, Ap, Ai, 
+      UMFPACK_ZNAME (report_matrix) (nr, nc, Ap, Ai,
                                 reinterpret_cast<const double *> (Ax), 0,
                                 1, control);
 
       void *Symbolic;
       Matrix Info (1, UMFPACK_INFO);
       double *info = Info.fortran_vec ();
       int status;
 
       // Null loop so that qinit is imediately deallocated when not
       // needed
       do {
         OCTAVE_LOCAL_BUFFER (octave_idx_type, qinit, nc);
 
         for (octave_idx_type i = 0; i < nc; i++)
           qinit [i] = static_cast<octave_idx_type> (Qinit (i));
 
-        status = UMFPACK_ZNAME (qsymbolic) (nr, nc, Ap, Ai, 
+        status = UMFPACK_ZNAME (qsymbolic) (nr, nc, Ap, Ai,
                                        reinterpret_cast<const double *> (Ax),
-                                       0, qinit, &Symbolic, control, 
+                                       0, qinit, &Symbolic, control,
                                        info);
       } while (0);
 
       if (status < 0)
         {
-          (*current_liboctave_error_handler) 
+          (*current_liboctave_error_handler)
             ("SparseComplexLU::SparseComplexLU symbolic factorization failed");
 
           UMFPACK_ZNAME (report_status) (control, status);
           UMFPACK_ZNAME (report_info) (control, info);
 
           UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
         }
       else
         {
           UMFPACK_ZNAME (report_symbolic) (Symbolic, control);
 
           void *Numeric;
-          status = UMFPACK_ZNAME (numeric) (Ap, Ai, 
+          status = UMFPACK_ZNAME (numeric) (Ap, Ai,
                                        reinterpret_cast<const double *> (Ax), 0,
                                        Symbolic, &Numeric, control, info) ;
           UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
 
           cond = Info (UMFPACK_RCOND);
 
           if (status < 0)
             {
-              (*current_liboctave_error_handler) 
+              (*current_liboctave_error_handler)
                 ("SparseComplexLU::SparseComplexLU numeric factorization failed");
 
               UMFPACK_ZNAME (report_status) (control, status);
               UMFPACK_ZNAME (report_info) (control, info);
 
               UMFPACK_ZNAME (free_numeric) (&Numeric);
             }
           else
             {
               UMFPACK_ZNAME (report_numeric) (Numeric, control);
 
               octave_idx_type lnz, unz, ignore1, ignore2, ignore3;
               status = UMFPACK_ZNAME (get_lunz) (&lnz, &unz,
                                             &ignore1, &ignore2, &ignore3, Numeric);
-          
+
               if (status < 0)
                 {
-                  (*current_liboctave_error_handler) 
+                  (*current_liboctave_error_handler)
                     ("SparseComplexLU::SparseComplexLU extracting LU factors failed");
 
                   UMFPACK_ZNAME (report_status) (control, status);
                   UMFPACK_ZNAME (report_info) (control, info);
 
                   UMFPACK_ZNAME (free_numeric) (&Numeric);
                 }
               else
@@ -402,78 +402,78 @@ SparseComplexLU::SparseComplexLU (const 
                     Ufact = SparseComplexMatrix (n_inner, nc,
                        static_cast<octave_idx_type> (1));
                   else
                     Ufact = SparseComplexMatrix  (n_inner, nc, unz);
 
                   octave_idx_type *Up = Ufact.cidx ();
                   octave_idx_type *Uj = Ufact.ridx ();
                   Complex *Ux = Ufact.data ();
-              
+
                   Rfact = SparseMatrix (nr, nr, nr);
                   for (octave_idx_type i = 0; i < nr; i++)
                     {
                       Rfact.xridx (i) = i;
                       Rfact.xcidx (i) = i;
                     }
                   Rfact.xcidx (nr) = nr;
                   double *Rx = Rfact.data ();
 
                   P.resize (dim_vector (nr, 1));
                   octave_idx_type *p = P.fortran_vec ();
 
                   Q.resize (dim_vector (nc, 1));
                   octave_idx_type *q = Q.fortran_vec ();
 
                   octave_idx_type do_recip;
-                  status = 
-                    UMFPACK_ZNAME (get_numeric) (Ltp, Ltj, 
+                  status =
+                    UMFPACK_ZNAME (get_numeric) (Ltp, Ltj,
                                             reinterpret_cast<double *> (Ltx),
                                             0, Up, Uj,
-                                            reinterpret_cast<double *> (Ux), 
-                                            0, p, q, 0, 0, 
+                                            reinterpret_cast<double *> (Ux),
+                                            0, p, q, 0, 0,
                                             &do_recip, Rx, Numeric) ;
 
                   UMFPACK_ZNAME (free_numeric) (&Numeric) ;
 
                   if (status < 0)
                     {
-                      (*current_liboctave_error_handler) 
+                      (*current_liboctave_error_handler)
                         ("SparseComplexLU::SparseComplexLU extracting LU factors failed");
 
                       UMFPACK_ZNAME (report_status) (control, status);
                     }
                   else
                     {
                       Lfact = Lfact.transpose ();
 
                       if (do_recip)
                         for (octave_idx_type i = 0; i < nr; i++)
                           Rx[i] = 1.0 / Rx[i];
 
-                      UMFPACK_ZNAME (report_matrix) (nr, n_inner, 
-                                                Lfact.cidx (), 
-                                                Lfact.ridx (), 
-                                                reinterpret_cast<double *> (Lfact.data()), 
+                      UMFPACK_ZNAME (report_matrix) (nr, n_inner,
+                                                Lfact.cidx (),
+                                                Lfact.ridx (),
+                                                reinterpret_cast<double *> (Lfact.data()),
                                                 0, 1, control);
 
-                      UMFPACK_ZNAME (report_matrix) (n_inner, nc, 
-                                                Ufact.cidx (), 
-                                                Ufact.ridx (), 
-                                                reinterpret_cast<double *> (Ufact.data()), 
+                      UMFPACK_ZNAME (report_matrix) (n_inner, nc,
+                                                Ufact.cidx (),
+                                                Ufact.ridx (),
+                                                reinterpret_cast<double *> (Ufact.data()),
                                                 0, 1, control);
                       UMFPACK_ZNAME (report_perm) (nr, p, control);
                       UMFPACK_ZNAME (report_perm) (nc, q, control);
                     }
 
                   UMFPACK_ZNAME (report_info) (control, info);
                 }
             }
         }
 
       if (udiag)
-        (*current_liboctave_error_handler) 
-          ("Option udiag of incomplete LU not implemented");   
+        (*current_liboctave_error_handler)
+          ("Option udiag of incomplete LU not implemented");
     }
 #else
   (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 }
diff --git a/liboctave/SparseCmplxLU.h b/liboctave/SparseCmplxLU.h
--- a/liboctave/SparseCmplxLU.h
+++ b/liboctave/SparseCmplxLU.h
@@ -25,41 +25,41 @@ along with Octave; see the file COPYING.
 #define octave_sparse_complex_LU_h 1
 
 #include "sparse-base-lu.h"
 #include "dSparse.h"
 #include "CSparse.h"
 
 class
 OCTAVE_API
-SparseComplexLU 
+SparseComplexLU
   : public sparse_base_lu <SparseComplexMatrix, Complex, SparseMatrix, double>
 {
 public:
 
-  SparseComplexLU (void) 
+  SparseComplexLU (void)
     : sparse_base_lu <SparseComplexMatrix, Complex, SparseMatrix, double> () { }
 
-  SparseComplexLU (const SparseComplexMatrix& a, 
+  SparseComplexLU (const SparseComplexMatrix& a,
                    const Matrix& piv_thres = Matrix (),
                    bool scale = false);
 
   SparseComplexLU (const SparseComplexMatrix& a, const ColumnVector& Qinit,
-                   const Matrix& piv_thres = Matrix (), 
+                   const Matrix& piv_thres = Matrix (),
                    bool scale = false, bool FixedQ = false,
                    double droptol = -1., bool milu = false,
                    bool udiag = false);
 
-  SparseComplexLU (const SparseComplexLU& a) 
+  SparseComplexLU (const SparseComplexLU& a)
     : sparse_base_lu <SparseComplexMatrix, Complex, SparseMatrix, double> (a) { }
 
   SparseComplexLU& operator = (const SparseComplexLU& a)
     {
       if (this != &a)
-        sparse_base_lu <SparseComplexMatrix, Complex, SparseMatrix, double> 
+        sparse_base_lu <SparseComplexMatrix, Complex, SparseMatrix, double>
           :: operator = (a);
 
       return *this;
     }
 
   ~SparseComplexLU (void) { }
 };
 
diff --git a/liboctave/SparseCmplxQR.cc b/liboctave/SparseCmplxQR.cc
--- a/liboctave/SparseCmplxQR.cc
+++ b/liboctave/SparseCmplxQR.cc
@@ -43,34 +43,34 @@ typedef double _Complex cs_complex_t;
 #define OCTAVE_C99_ONE (1. + 0.iF)
 #else
 #define OCTAVE_C99_COMPLEX(buf, n) \
   OCTAVE_LOCAL_BUFFER (cs_complex_t, buf, (n));
 #define OCTAVE_C99_ZERO cs_complex_t(0., 0.);
 #define OCTAVE_C99_ONE cs_complex_t(1., 0.);
 #endif
 
-SparseComplexQR::SparseComplexQR_rep::SparseComplexQR_rep 
+SparseComplexQR::SparseComplexQR_rep::SparseComplexQR_rep
   (GCC_ATTR_UNUSED const SparseComplexMatrix& a, GCC_ATTR_UNUSED int order)
   : count (1), nrows (0)
 #ifdef HAVE_CXSPARSE
     , S (0), N (0)
 #endif
 {
 #ifdef HAVE_CXSPARSE
   CXSPARSE_ZNAME () A;
   A.nzmax = a.nnz ();
   A.m = a.rows ();
   A.n = a.cols ();
   nrows = A.m;
   // Cast away const on A, with full knowledge that CSparse won't touch it
   // Prevents the methods below making a copy of the data.
   A.p = const_cast<octave_idx_type *>(a.cidx ());
   A.i = const_cast<octave_idx_type *>(a.ridx ());
-  A.x = const_cast<cs_complex_t *>(reinterpret_cast<const cs_complex_t *> 
+  A.x = const_cast<cs_complex_t *>(reinterpret_cast<const cs_complex_t *>
                                       (a.data ()));
   A.nz = -1;
   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
   S = CXSPARSE_ZNAME (_sqr) (order, &A, 1);
 #else
   S = CXSPARSE_ZNAME (_sqr) (&A, order - 1, 1);
 #endif
@@ -89,17 +89,17 @@ SparseComplexQR::SparseComplexQR_rep::Sp
 SparseComplexQR::SparseComplexQR_rep::~SparseComplexQR_rep (void)
 {
 #ifdef HAVE_CXSPARSE
   CXSPARSE_ZNAME (_sfree) (S);
   CXSPARSE_ZNAME (_nfree) (N);
 #endif
 }
 
-SparseComplexMatrix 
+SparseComplexMatrix
 SparseComplexQR::SparseComplexQR_rep::V (void) const
 {
 #ifdef HAVE_CXSPARSE
   // Drop zeros from V and sort
   // FIXME Is the double transpose to sort necessary?
   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
   CXSPARSE_ZNAME (_dropzeros) (N->L);
   CXSPARSE_ZNAME () *D = CXSPARSE_ZNAME (_transpose) (N->L, 1);
@@ -119,51 +119,51 @@ SparseComplexQR::SparseComplexQR_rep::V 
       ret.xdata (j) = reinterpret_cast<Complex *>(N->L->x)[j];
     }
   return ret;
 #else
   return SparseComplexMatrix ();
 #endif
 }
 
-ColumnVector 
+ColumnVector
 SparseComplexQR::SparseComplexQR_rep::Pinv (void) const
 {
 #ifdef HAVE_CXSPARSE
   ColumnVector ret(N->L->m);
   for (octave_idx_type i = 0; i < N->L->m; i++)
 #if defined(CS_VER) && (CS_VER >= 2)
     ret.xelem(i) = S->pinv[i];
 #else
     ret.xelem(i) = S->Pinv[i];
 #endif
   return ret;
 #else
   return ColumnVector ();
 #endif
 }
 
-ColumnVector 
+ColumnVector
 SparseComplexQR::SparseComplexQR_rep::P (void) const
 {
 #ifdef HAVE_CXSPARSE
   ColumnVector ret(N->L->m);
   for (octave_idx_type i = 0; i < N->L->m; i++)
 #if defined(CS_VER) && (CS_VER >= 2)
     ret.xelem(S->pinv[i]) = i;
 #else
     ret.xelem(S->Pinv[i]) = i;
 #endif
   return ret;
 #else
   return ColumnVector ();
 #endif
 }
 
-SparseComplexMatrix 
+SparseComplexMatrix
 SparseComplexQR::SparseComplexQR_rep::R (const bool econ) const
 {
 #ifdef HAVE_CXSPARSE
   // Drop zeros from R and sort
   // FIXME Is the double transpose to sort necessary?
   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
   CXSPARSE_ZNAME (_dropzeros) (N->U);
   CXSPARSE_ZNAME () *D = CXSPARSE_ZNAME (_transpose) (N->U, 1);
@@ -191,45 +191,45 @@ SparseComplexQR::SparseComplexQR_rep::R 
 ComplexMatrix
 SparseComplexQR::SparseComplexQR_rep::C (const ComplexMatrix &b) const
 {
 #ifdef HAVE_CXSPARSE
   octave_idx_type b_nr = b.rows();
   octave_idx_type b_nc = b.cols();
   octave_idx_type nc = N->L->n;
   octave_idx_type nr = nrows;
-  const cs_complex_t *bvec = 
+  const cs_complex_t *bvec =
     reinterpret_cast<const cs_complex_t *>(b.fortran_vec());
   ComplexMatrix ret(b_nr, b_nc);
   Complex *vec = ret.fortran_vec();
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler) ("matrix dimension mismatch");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     ret = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else
     {
       OCTAVE_LOCAL_BUFFER (Complex, buf, S->m2);
       for (volatile octave_idx_type j = 0, idx = 0; j < b_nc; j++, idx+=b_nr)
         {
           octave_quit ();
           volatile octave_idx_type nm = (nr < nc ? nr : nc);
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_ZNAME (_ipvec) 
+          CXSPARSE_ZNAME (_ipvec)
             (S->pinv, bvec + idx, reinterpret_cast<cs_complex_t *>(buf), b_nr);
 #else
-          CXSPARSE_ZNAME (_ipvec) 
+          CXSPARSE_ZNAME (_ipvec)
             (b_nr, S->Pinv, bvec + idx, reinterpret_cast<cs_complex_t *>(buf));
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type i = 0; i < nm; i++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-              CXSPARSE_ZNAME (_happly) 
+              CXSPARSE_ZNAME (_happly)
                 (N->L, i, N->B[i], reinterpret_cast<cs_complex_t *>(buf));
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           for (octave_idx_type i = 0; i < b_nr; i++)
             vec[i+idx] = buf[i];
         }
     }
   return ret;
@@ -258,28 +258,28 @@ SparseComplexQR::SparseComplexQR_rep::Q 
       OCTAVE_LOCAL_BUFFER (Complex, buf, S->m2);
       for (volatile octave_idx_type j = 0, idx = 0; j < nr; j++, idx+=nr)
         {
           octave_quit ();
           bvec[j] = OCTAVE_C99_ONE;
           volatile octave_idx_type nm = (nr < nc ? nr : nc);
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_ZNAME (_ipvec) 
+          CXSPARSE_ZNAME (_ipvec)
             (S->pinv, bvec, reinterpret_cast<cs_complex_t *>(buf), nr);
 #else
-          CXSPARSE_ZNAME (_ipvec) 
+          CXSPARSE_ZNAME (_ipvec)
             (nr, S->Pinv, bvec, reinterpret_cast<cs_complex_t *>(buf));
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type i = 0; i < nm; i++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-              CXSPARSE_ZNAME (_happly) 
+              CXSPARSE_ZNAME (_happly)
                 (N->L, i, N->B[i], reinterpret_cast<cs_complex_t *>(buf));
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           for (octave_idx_type i = 0; i < nr; i++)
             vec[i+idx] = buf[i];
           bvec[j] = OCTAVE_C99_ZERO;
         }
     }
@@ -319,20 +319,20 @@ qrsolve(const SparseComplexMatrix&a, con
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             Xx[j] = b.xelem(j,i);
           for (octave_idx_type j = nr; j < q.S()->m2; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_ZNAME (_ipvec) 
+          CXSPARSE_ZNAME (_ipvec)
             (q.S()->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
-          CXSPARSE_ZNAME (_ipvec) 
+          CXSPARSE_ZNAME (_ipvec)
             (nr, q.S()->Pinv, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_ZNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
@@ -390,17 +390,17 @@ qrsolve(const SparseComplexMatrix&a, con
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
 #if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
               CXSPARSE_ZNAME (_happly) (q.N()->L, j, B[j], buf);
 #else
-              CXSPARSE_ZNAME (_happly) 
+              CXSPARSE_ZNAME (_happly)
                 (q.N()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
 #endif
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec) (q.S()->pinv, buf, vec + idx, nc);
 #else
@@ -449,37 +449,37 @@ qrsolve(const SparseComplexMatrix&a, con
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             Xx[j] = b.xelem(j,i);
           for (octave_idx_type j = nr; j < q.S()->m2; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_ZNAME (_ipvec) 
+          CXSPARSE_ZNAME (_ipvec)
             (q.S()->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
-          CXSPARSE_ZNAME (_ipvec) 
+          CXSPARSE_ZNAME (_ipvec)
             (nr, q.S()->Pinv, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_ZNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_ZNAME (_usolve) (q.N()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_ZNAME (_ipvec) 
+          CXSPARSE_ZNAME (_ipvec)
             (q.S()->q, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
 #else
-          CXSPARSE_ZNAME (_ipvec) 
+          CXSPARSE_ZNAME (_ipvec)
             (nc, q.S()->Q, buf, reinterpret_cast<cs_complex_t *>(Xx));
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
               Complex tmp = Xx[j];
               if (tmp != 0.0)
@@ -542,27 +542,27 @@ qrsolve(const SparseComplexMatrix&a, con
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
               CXSPARSE_ZNAME (_happly) (q.N()->L, j, B[j], buf);
 #else
-              CXSPARSE_ZNAME (_happly) 
+              CXSPARSE_ZNAME (_happly)
                 (q.N()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
 #endif
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_ZNAME (_pvec) 
+          CXSPARSE_ZNAME (_pvec)
             (q.S()->pinv, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
 #else
-          CXSPARSE_ZNAME (_pvec) 
+          CXSPARSE_ZNAME (_pvec)
             (nc, q.S()->Pinv, buf, reinterpret_cast<cs_complex_t *>(Xx));
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
               Complex tmp = Xx[j];
               if (tmp != 0.0)
@@ -595,17 +595,17 @@ ComplexMatrix
 qrsolve(const SparseComplexMatrix&a, const ComplexMatrix &b, octave_idx_type &info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
   octave_idx_type nr = a.rows();
   octave_idx_type nc = a.cols();
   octave_idx_type b_nc = b.cols();
   octave_idx_type b_nr = b.rows();
-  const cs_complex_t *bvec = 
+  const cs_complex_t *bvec =
     reinterpret_cast<const cs_complex_t *>(b.fortran_vec());
   ComplexMatrix x;
 
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
@@ -613,17 +613,17 @@ qrsolve(const SparseComplexMatrix&a, con
     {
       SparseComplexQR q (a, 2);
       if (! q.ok ())
         return ComplexMatrix();
       x.resize(nc, b_nc);
       cs_complex_t *vec = reinterpret_cast<cs_complex_t *>
         (x.fortran_vec());
       OCTAVE_C99_COMPLEX (buf, q.S()->m2);
-      for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc; 
+      for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc;
            i++, idx+=nc, bidx+=b_nr)
         {
           octave_quit ();
           for (octave_idx_type j = nr; j < q.S()->m2; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_ipvec) (q.S()->pinv, bvec + bidx, buf, nr);
@@ -664,17 +664,17 @@ qrsolve(const SparseComplexMatrix&a, con
       OCTAVE_LOCAL_BUFFER (double, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
         B[i] = q.N()->B [i];
 #else
       OCTAVE_LOCAL_BUFFER (Complex, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
         B[i] = conj (reinterpret_cast<Complex *>(q.N()->B) [i]);
 #endif
-      for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc; 
+      for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc;
            i++, idx+=nc, bidx+=b_nr)
         {
           octave_quit ();
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec) (q.S()->q, bvec + bidx, buf, nr);
@@ -685,17 +685,17 @@ qrsolve(const SparseComplexMatrix&a, con
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
               CXSPARSE_ZNAME (_happly) (q.N()->L, j, B[j], buf);
 #else
-              CXSPARSE_ZNAME (_happly) 
+              CXSPARSE_ZNAME (_happly)
                 (q.N()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
 #endif
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
           CXSPARSE_ZNAME (_pvec) (q.S()->pinv, buf, vec + idx, nc);
 #else
@@ -744,37 +744,37 @@ qrsolve(const SparseComplexMatrix&a, con
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             Xx[j] = b.xelem(j,i);
           for (octave_idx_type j = nr; j < q.S()->m2; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_ZNAME (_ipvec) 
+          CXSPARSE_ZNAME (_ipvec)
             (q.S()->pinv, reinterpret_cast<cs_complex_t *>(Xx), buf, nr);
 #else
-          CXSPARSE_ZNAME (_ipvec) 
+          CXSPARSE_ZNAME (_ipvec)
             (nr, q.S()->Pinv, reinterpret_cast<cs_complex_t *>(Xx), buf);
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CXSPARSE_ZNAME (_happly) (q.N()->L, j, q.N()->B[j], buf);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           CXSPARSE_ZNAME (_usolve) (q.N()->U, buf);
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_ZNAME (_ipvec) 
+          CXSPARSE_ZNAME (_ipvec)
             (q.S()->q, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
 #else
-          CXSPARSE_ZNAME (_ipvec) 
+          CXSPARSE_ZNAME (_ipvec)
             (nc, q.S()->Q, buf, reinterpret_cast<cs_complex_t *>(Xx));
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
               Complex tmp = Xx[j];
               if (tmp != 0.0)
@@ -836,27 +836,27 @@ qrsolve(const SparseComplexMatrix&a, con
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           for (volatile octave_idx_type j = nr-1; j >= 0; j--)
             {
               octave_quit ();
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
               CXSPARSE_ZNAME (_happly) (q.N()->L, j, B[j], buf);
 #else
-              CXSPARSE_ZNAME (_happly) 
+              CXSPARSE_ZNAME (_happly)
                 (q.N()->L, j, reinterpret_cast<cs_complex_t *>(B)[j], buf);
 #endif
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
-          CXSPARSE_ZNAME (_pvec) 
+          CXSPARSE_ZNAME (_pvec)
             (q.S()->pinv, buf, reinterpret_cast<cs_complex_t *>(Xx), nc);
 #else
-          CXSPARSE_ZNAME (_pvec) 
+          CXSPARSE_ZNAME (_pvec)
             (nc, q.S()->Pinv, buf, reinterpret_cast<cs_complex_t *>(Xx));
 #endif
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
               Complex tmp = Xx[j];
               if (tmp != 0.0)
@@ -880,21 +880,21 @@ qrsolve(const SparseComplexMatrix&a, con
 
   x.maybe_compress ();
   return x;
 #else
   return SparseComplexMatrix ();
 #endif
 }
 
-ComplexMatrix 
-qrsolve (const SparseComplexMatrix &a, const MArray<double> &b, 
+ComplexMatrix
+qrsolve (const SparseComplexMatrix &a, const MArray<double> &b,
          octave_idx_type &info)
 {
   return qrsolve (a, Matrix (b), info);
 }
 
-ComplexMatrix 
-qrsolve (const SparseComplexMatrix &a, const MArray<Complex> &b, 
+ComplexMatrix
+qrsolve (const SparseComplexMatrix &a, const MArray<Complex> &b,
          octave_idx_type &info)
 {
   return qrsolve (a, ComplexMatrix (b), info);
 }
diff --git a/liboctave/SparseCmplxQR.h b/liboctave/SparseCmplxQR.h
--- a/liboctave/SparseCmplxQR.h
+++ b/liboctave/SparseCmplxQR.h
@@ -72,21 +72,21 @@ protected:
     CXSPARSE_ZNAME (s) *S;
 
     CXSPARSE_ZNAME (n) *N;
 #endif
   };
 private:
   SparseComplexQR_rep *rep;
 
-public:  
-  SparseComplexQR (void) : 
+public:
+  SparseComplexQR (void) :
     rep (new SparseComplexQR_rep (SparseComplexMatrix(), 0)) { }
 
-  SparseComplexQR (const SparseComplexMatrix& a, int order = 0) : 
+  SparseComplexQR (const SparseComplexMatrix& a, int order = 0) :
     rep (new SparseComplexQR_rep (a, order)) { }
 
   SparseComplexQR (const SparseComplexQR& a) : rep (a.rep) { rep->count++; }
 
   ~SparseComplexQR (void)
     {
       if (--rep->count <= 0)
         delete rep;
@@ -108,35 +108,35 @@ public:
   bool ok (void) const { return rep->ok(); }
 
   SparseComplexMatrix V (void) const { return rep->V(); }
 
   ColumnVector Pinv (void) const { return rep->P(); }
 
   ColumnVector P (void) const { return rep->P(); }
 
-  SparseComplexMatrix R (const bool econ = false) const 
+  SparseComplexMatrix R (const bool econ = false) const
     { return rep->R(econ); }
 
   ComplexMatrix C (const ComplexMatrix &b) const { return rep->C(b); }
 
   ComplexMatrix Q (void) const { return rep->Q(); }
 
   friend ComplexMatrix qrsolve (const SparseComplexMatrix &a, const Matrix &b,
                                 octave_idx_type &info);
 
-  friend SparseComplexMatrix qrsolve (const SparseComplexMatrix &a, 
+  friend SparseComplexMatrix qrsolve (const SparseComplexMatrix &a,
                                       const SparseMatrix &b,
                                       octave_idx_type &info);
 
-  friend ComplexMatrix qrsolve (const SparseComplexMatrix &a, 
+  friend ComplexMatrix qrsolve (const SparseComplexMatrix &a,
                                 const ComplexMatrix &b,
                                 octave_idx_type &info);
 
-  friend SparseComplexMatrix qrsolve (const SparseComplexMatrix &a, 
+  friend SparseComplexMatrix qrsolve (const SparseComplexMatrix &a,
                                       const SparseComplexMatrix &b,
                                       octave_idx_type &info);
 
 protected:
 #ifdef HAVE_CXSPARSE
   CXSPARSE_ZNAME (s) * S (void) { return rep->S; }
 
   CXSPARSE_ZNAME (n) * N (void) { return rep->N; }
@@ -144,28 +144,28 @@ protected:
 };
 
 
 // Publish externally used friend functions.
 
 extern ComplexMatrix qrsolve (const SparseComplexMatrix &a, const Matrix &b,
                               octave_idx_type &info);
 
-extern ComplexMatrix qrsolve (const SparseComplexMatrix &a, 
-                              const MArray<double> &b, 
+extern ComplexMatrix qrsolve (const SparseComplexMatrix &a,
+                              const MArray<double> &b,
                               octave_idx_type &info);
 
-extern SparseComplexMatrix qrsolve (const SparseComplexMatrix &a, 
+extern SparseComplexMatrix qrsolve (const SparseComplexMatrix &a,
                                     const SparseMatrix &b,
                                     octave_idx_type &info);
 
-extern ComplexMatrix qrsolve (const SparseComplexMatrix &a, 
+extern ComplexMatrix qrsolve (const SparseComplexMatrix &a,
                               const ComplexMatrix &b,
                               octave_idx_type &info);
 
-extern ComplexMatrix qrsolve (const SparseComplexMatrix &a, 
-                              const MArray<Complex> &b, 
+extern ComplexMatrix qrsolve (const SparseComplexMatrix &a,
+                              const MArray<Complex> &b,
                               octave_idx_type &info);
 
-extern SparseComplexMatrix qrsolve (const SparseComplexMatrix &a, 
+extern SparseComplexMatrix qrsolve (const SparseComplexMatrix &a,
                                     const SparseComplexMatrix &b,
                                     octave_idx_type &info);
 #endif
diff --git a/liboctave/SparseQR.cc b/liboctave/SparseQR.cc
--- a/liboctave/SparseQR.cc
+++ b/liboctave/SparseQR.cc
@@ -69,17 +69,17 @@ SparseQR::SparseQR_rep::SparseQR_rep (co
 SparseQR::SparseQR_rep::~SparseQR_rep (void)
 {
 #ifdef HAVE_CXSPARSE
   CXSPARSE_DNAME (_sfree) (S);
   CXSPARSE_DNAME (_nfree) (N);
 #endif
 }
 
-SparseMatrix 
+SparseMatrix
 SparseQR::SparseQR_rep::V (void) const
 {
 #ifdef HAVE_CXSPARSE
   // Drop zeros from V and sort
   // FIXME Is the double transpose to sort necessary?
   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
   CXSPARSE_DNAME (_dropzeros) (N->L);
   CXSPARSE_DNAME () *D = CXSPARSE_DNAME (_transpose) (N->L, 1);
@@ -99,51 +99,51 @@ SparseQR::SparseQR_rep::V (void) const
       ret.xdata (j) = N->L->x[j];
     }
   return ret;
 #else
   return SparseMatrix ();
 #endif
 }
 
-ColumnVector 
+ColumnVector
 SparseQR::SparseQR_rep::Pinv (void) const
 {
 #ifdef HAVE_CXSPARSE
   ColumnVector ret(N->L->m);
   for (octave_idx_type i = 0; i < N->L->m; i++)
 #if defined(CS_VER) && (CS_VER >= 2)
     ret.xelem(i) = S->pinv[i];
 #else
     ret.xelem(i) = S->Pinv[i];
 #endif
   return ret;
 #else
   return ColumnVector ();
 #endif
 }
 
-ColumnVector 
+ColumnVector
 SparseQR::SparseQR_rep::P (void) const
 {
 #ifdef HAVE_CXSPARSE
   ColumnVector ret(N->L->m);
   for (octave_idx_type i = 0; i < N->L->m; i++)
 #if defined(CS_VER) && (CS_VER >= 2)
     ret.xelem(S->pinv[i]) = i;
 #else
     ret.xelem(S->Pinv[i]) = i;
 #endif
   return ret;
 #else
   return ColumnVector ();
 #endif
 }
 
-SparseMatrix 
+SparseMatrix
 SparseQR::SparseQR_rep::R (const bool econ) const
 {
 #ifdef HAVE_CXSPARSE
   // Drop zeros from R and sort
   // FIXME Is the double transpose to sort necessary?
   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
   CXSPARSE_DNAME (_dropzeros) (N->U);
   CXSPARSE_DNAME () *D = CXSPARSE_DNAME (_transpose) (N->U, 1);
@@ -285,22 +285,22 @@ qrsolve(const SparseMatrix&a, const Matr
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = Matrix (nc, b_nc, 0.0);
   else if (nr >= nc)
     {
       SparseQR q (a, 3);
-      if (! q.ok ()) 
+      if (! q.ok ())
         return Matrix();
       x.resize(nc, b_nc);
       double *vec = x.fortran_vec();
       OCTAVE_LOCAL_BUFFER (double, buf, q.S()->m2);
-      for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc; 
+      for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc;
            i++, idx+=nc, bidx+=b_nr)
         {
           octave_quit ();
           for (octave_idx_type j = nr; j < q.S()->m2; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_ipvec) (q.S()->pinv, bvec + bidx, buf, nr);
@@ -331,17 +331,17 @@ qrsolve(const SparseMatrix&a, const Matr
       SparseMatrix at = a.hermitian();
       SparseQR q (at, 3);
       if (! q.ok ())
         return Matrix();
       x.resize(nc, b_nc);
       double *vec = x.fortran_vec();
       volatile octave_idx_type nbuf = (nc > q.S()->m2 ? nc : q.S()->m2);
       OCTAVE_LOCAL_BUFFER (double, buf, nbuf);
-      for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc; 
+      for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc;
            i++, idx+=nc, bidx+=b_nr)
         {
           octave_quit ();
           for (octave_idx_type j = nr; j < nbuf; j++)
             buf[j] = 0.;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined(CS_VER) && (CS_VER >= 2)
           CXSPARSE_DNAME (_pvec) (q.S()->q, bvec + bidx, buf, nr);
@@ -389,17 +389,17 @@ qrsolve(const SparseMatrix&a, const Spar
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = SparseMatrix (nc, b_nc);
   else if (nr >= nc)
     {
       SparseQR q (a, 3);
-      if (! q.ok ()) 
+      if (! q.ok ())
         return SparseMatrix();
       x = SparseMatrix (nc, b_nc, b.nnz());
       x.xcidx(0) = 0;
       x_nz = b.nnz();
       ii = 0;
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, buf, q.S()->m2);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
@@ -707,17 +707,17 @@ qrsolve(const SparseMatrix&a, const Spar
   if (nr < 0 || nc < 0 || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch in solution of minimum norm problem");
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = SparseComplexMatrix (nc, b_nc);
   else if (nr >= nc)
     {
       SparseQR q (a, 3);
-      if (! q.ok ()) 
+      if (! q.ok ())
         return SparseComplexMatrix();
       x = SparseComplexMatrix (nc, b_nc, b.nnz());
       x.xcidx(0) = 0;
       x_nz = b.nnz();
       ii = 0;
       OCTAVE_LOCAL_BUFFER (double, Xx, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, Xz, (b_nr > nc ? b_nr : nc));
       OCTAVE_LOCAL_BUFFER (double, buf, q.S()->m2);
@@ -896,21 +896,21 @@ qrsolve(const SparseMatrix&a, const Spar
 
   x.maybe_compress ();
   return x;
 #else
   return SparseComplexMatrix ();
 #endif
 }
 
-Matrix 
-qrsolve(const SparseMatrix &a, const MArray<double> &b, 
+Matrix
+qrsolve(const SparseMatrix &a, const MArray<double> &b,
         octave_idx_type &info)
-{ 
-  return qrsolve (a, Matrix (b), info); 
+{
+  return qrsolve (a, Matrix (b), info);
 }
 
-ComplexMatrix 
-qrsolve(const SparseMatrix &a, const MArray<Complex> &b, 
+ComplexMatrix
+qrsolve(const SparseMatrix &a, const MArray<Complex> &b,
         octave_idx_type &info)
-{ 
+{
   return qrsolve (a, ComplexMatrix (b), info);
 }
diff --git a/liboctave/SparseQR.h b/liboctave/SparseQR.h
--- a/liboctave/SparseQR.h
+++ b/liboctave/SparseQR.h
@@ -72,20 +72,20 @@ protected:
     CXSPARSE_DNAME (s) *S;
 
     CXSPARSE_DNAME (n) *N;
 #endif
   };
 private:
   SparseQR_rep *rep;
 
-public:  
+public:
   SparseQR (void) : rep (new SparseQR_rep (SparseMatrix(), 0)) { }
 
-  SparseQR (const SparseMatrix& a, int order = 0) : 
+  SparseQR (const SparseMatrix& a, int order = 0) :
     rep (new SparseQR_rep (a, order)) { }
 
   SparseQR (const SparseQR& a) : rep (a.rep) { rep->count++; }
 
   ~SparseQR (void)
     {
       if (--rep->count <= 0)
         delete rep;
@@ -113,52 +113,52 @@ public:
   ColumnVector P (void) const { return rep->P(); }
 
   SparseMatrix R (const bool econ = false) const { return rep->R(econ); }
 
   Matrix C (const Matrix &b) const { return rep->C(b); }
 
   Matrix Q (void) const { return rep->Q(); }
 
-  friend Matrix qrsolve (const SparseMatrix &a, const Matrix &b, 
+  friend Matrix qrsolve (const SparseMatrix &a, const Matrix &b,
                          octave_idx_type &info);
 
   friend SparseMatrix qrsolve (const SparseMatrix &a, const SparseMatrix &b,
                          octave_idx_type &info);
 
   friend ComplexMatrix qrsolve (const SparseMatrix &a, const ComplexMatrix &b,
                                 octave_idx_type &info);
 
-  friend SparseComplexMatrix qrsolve (const SparseMatrix &a, 
+  friend SparseComplexMatrix qrsolve (const SparseMatrix &a,
                                       const SparseComplexMatrix &b,
                                       octave_idx_type &info);
 
 protected:
 #ifdef HAVE_CXSPARSE
   CXSPARSE_DNAME (s) * S (void) { return rep->S; }
 
   CXSPARSE_DNAME (n) * N (void) { return rep->N; }
 #endif
 };
 
 
 // Publish externally used friend functions.
 
-extern Matrix qrsolve (const SparseMatrix &a, const Matrix &b, 
+extern Matrix qrsolve (const SparseMatrix &a, const Matrix &b,
                        octave_idx_type &info);
 
-extern Matrix qrsolve (const SparseMatrix &a, const MArray<double> &b, 
+extern Matrix qrsolve (const SparseMatrix &a, const MArray<double> &b,
                        octave_idx_type &info);
 
 extern SparseMatrix qrsolve (const SparseMatrix &a, const SparseMatrix &b,
                              octave_idx_type &info);
 
 extern ComplexMatrix qrsolve (const SparseMatrix &a, const ComplexMatrix &b,
                               octave_idx_type &info);
 
-extern ComplexMatrix qrsolve (const SparseMatrix &a, const MArray<Complex> &b, 
+extern ComplexMatrix qrsolve (const SparseMatrix &a, const MArray<Complex> &b,
                               octave_idx_type &info);
 
-extern SparseComplexMatrix qrsolve (const SparseMatrix &a, 
+extern SparseComplexMatrix qrsolve (const SparseMatrix &a,
                                     const SparseComplexMatrix &b,
                                     octave_idx_type &info);
 
 #endif
diff --git a/liboctave/SparsedbleCHOL.cc b/liboctave/SparsedbleCHOL.cc
--- a/liboctave/SparsedbleCHOL.cc
+++ b/liboctave/SparsedbleCHOL.cc
@@ -55,16 +55,16 @@ chol2inv (const SparseMatrix& r)
           retval = rinv.transpose() * rinv;
         }
       else if (typ == MatrixType::Lower)
         {
           rinv = r.transpose().inverse(mattype, info, rcond, true, false);
           retval = rinv.transpose() * rinv;
         }
       else
-        (*current_liboctave_error_handler) 
+        (*current_liboctave_error_handler)
           ("spchol2inv requires triangular matrix");
     }
   else
     (*current_liboctave_error_handler) ("spchol2inv requires square matrix");
 
   return retval;
 }
diff --git a/liboctave/SparsedbleCHOL.h b/liboctave/SparsedbleCHOL.h
--- a/liboctave/SparsedbleCHOL.h
+++ b/liboctave/SparsedbleCHOL.h
@@ -30,57 +30,57 @@ along with Octave; see the file COPYING.
 class
 OCTAVE_API
 SparseCHOL : public sparse_base_chol <SparseMatrix, double, SparseMatrix>
 {
 public:
 
   SparseCHOL (void) : sparse_base_chol<SparseMatrix, double, SparseMatrix> () { }
 
-  SparseCHOL (const SparseMatrix& a, bool natural = true) : 
+  SparseCHOL (const SparseMatrix& a, bool natural = true) :
     sparse_base_chol<SparseMatrix, double, SparseMatrix> (a, natural) { }
 
-  SparseCHOL (const SparseMatrix& a, octave_idx_type& info, 
-              bool natural = true) : 
+  SparseCHOL (const SparseMatrix& a, octave_idx_type& info,
+              bool natural = true) :
     sparse_base_chol<SparseMatrix, double, SparseMatrix> (a, info, natural) { }
 
-  SparseCHOL (const SparseCHOL& a) : 
+  SparseCHOL (const SparseCHOL& a) :
     sparse_base_chol<SparseMatrix, double, SparseMatrix> (a) { }
 
   ~SparseCHOL (void) { }
 
   SparseCHOL& operator = (const SparseCHOL& a)
     {
       if (this != &a)
         sparse_base_chol <SparseMatrix, double, SparseMatrix> :: operator = (a);
 
       return *this;
     }
 
   SparseMatrix chol_matrix (void) const { return R(); }
 
-  SparseMatrix L (void) const 
+  SparseMatrix L (void) const
   { return sparse_base_chol<SparseMatrix, double, SparseMatrix>:: L (); }
 
-  SparseMatrix R (void) const 
+  SparseMatrix R (void) const
     { return sparse_base_chol<SparseMatrix, double, SparseMatrix>:: R (); }
 
-  octave_idx_type P (void) const 
+  octave_idx_type P (void) const
     { return sparse_base_chol<SparseMatrix, double, SparseMatrix>:: P (); }
 
-  ColumnVector perm (void) const 
+  ColumnVector perm (void) const
     { return sparse_base_chol<SparseMatrix, double, SparseMatrix>:: perm (); }
 
-  SparseMatrix Q (void) const 
+  SparseMatrix Q (void) const
     { return sparse_base_chol<SparseMatrix, double, SparseMatrix>:: Q (); }
 
   double rcond (void) const
     { return sparse_base_chol<SparseMatrix, double, SparseMatrix>:: rcond (); }
 
   // Compute the inverse of a matrix using the Cholesky factorization.
   SparseMatrix inverse (void) const
-   { return sparse_base_chol<SparseMatrix, double, SparseMatrix>:: 
+   { return sparse_base_chol<SparseMatrix, double, SparseMatrix>::
        inverse (); }
 };
 
 SparseMatrix OCTAVE_API chol2inv (const SparseMatrix& r);
 
 #endif
diff --git a/liboctave/SparsedbleLU.cc b/liboctave/SparsedbleLU.cc
--- a/liboctave/SparsedbleLU.cc
+++ b/liboctave/SparsedbleLU.cc
@@ -98,56 +98,56 @@ SparseLU::SparseLU (const SparseMatrix& 
   void *Symbolic;
   Matrix Info (1, UMFPACK_INFO);
   double *info = Info.fortran_vec ();
   int status = UMFPACK_DNAME (qsymbolic) (nr, nc, Ap, Ai, Ax, 0,
                                      &Symbolic, control, info);
 
   if (status < 0)
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
             ("SparseLU::SparseLU symbolic factorization failed");
 
       UMFPACK_DNAME (report_status) (control, status);
       UMFPACK_DNAME (report_info) (control, info);
 
       UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
     }
   else
     {
       UMFPACK_DNAME (report_symbolic) (Symbolic, control);
 
       void *Numeric;
-      status = UMFPACK_DNAME (numeric) (Ap, Ai, Ax, Symbolic, 
+      status = UMFPACK_DNAME (numeric) (Ap, Ai, Ax, Symbolic,
                                    &Numeric, control, info) ;
       UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
 
       cond = Info (UMFPACK_RCOND);
 
       if (status < 0)
         {
-          (*current_liboctave_error_handler) 
+          (*current_liboctave_error_handler)
             ("SparseLU::SparseLU numeric factorization failed");
 
           UMFPACK_DNAME (report_status) (control, status);
           UMFPACK_DNAME (report_info) (control, info);
 
           UMFPACK_DNAME (free_numeric) (&Numeric);
         }
       else
         {
           UMFPACK_DNAME (report_numeric) (Numeric, control);
 
           octave_idx_type lnz, unz, ignore1, ignore2, ignore3;
           status = UMFPACK_DNAME (get_lunz) (&lnz, &unz, &ignore1,
                                         &ignore2, &ignore3, Numeric) ;
-          
+
           if (status < 0)
             {
-              (*current_liboctave_error_handler) 
+              (*current_liboctave_error_handler)
                 ("SparseLU::SparseLU extracting LU factors failed");
 
               UMFPACK_DNAME (report_status) (control, status);
               UMFPACK_DNAME (report_info) (control, info);
 
               UMFPACK_DNAME (free_numeric) (&Numeric);
             }
           else
@@ -187,40 +187,40 @@ SparseLU::SparseLU (const SparseMatrix& 
               octave_idx_type *p = P.fortran_vec ();
 
               Q.resize (dim_vector (nc, 1));
               octave_idx_type *q = Q.fortran_vec ();
 
               octave_idx_type do_recip;
               status = UMFPACK_DNAME (get_numeric) (Ltp, Ltj, Ltx,
                                                Up, Uj, Ux, p, q, 0,
-                                               &do_recip, Rx, 
+                                               &do_recip, Rx,
                                                Numeric) ;
 
               UMFPACK_DNAME (free_numeric) (&Numeric) ;
 
               if (status < 0)
                 {
-                  (*current_liboctave_error_handler) 
+                  (*current_liboctave_error_handler)
                     ("SparseLU::SparseLU extracting LU factors failed");
 
                   UMFPACK_DNAME (report_status) (control, status);
                 }
               else
                 {
                   Lfact = Lfact.transpose ();
 
                   if (do_recip)
                     for (octave_idx_type i = 0; i < nr; i++)
                       Rx[i] = 1.0 / Rx[i];
 
-                  UMFPACK_DNAME (report_matrix) (nr, n_inner, 
+                  UMFPACK_DNAME (report_matrix) (nr, n_inner,
                                             Lfact.cidx (), Lfact.ridx (),
                                             Lfact.data (), 1, control);
-                  UMFPACK_DNAME (report_matrix) (n_inner, nc, 
+                  UMFPACK_DNAME (report_matrix) (n_inner, nc,
                                             Ufact.cidx (), Ufact.ridx (),
                                             Ufact.data (), 1, control);
                   UMFPACK_DNAME (report_perm) (nr, p, control);
                   UMFPACK_DNAME (report_perm) (nc, q, control);
                 }
 
               UMFPACK_DNAME (report_info) (control, info);
             }
@@ -232,18 +232,18 @@ SparseLU::SparseLU (const SparseMatrix& 
 }
 
 SparseLU::SparseLU (const SparseMatrix& a, const ColumnVector& Qinit,
                     const Matrix& piv_thres, bool scale, bool FixedQ,
                     double droptol, bool milu, bool udiag)
 {
 #ifdef HAVE_UMFPACK
   if (milu)
-    (*current_liboctave_error_handler) 
-      ("Modified incomplete LU not implemented");   
+    (*current_liboctave_error_handler)
+      ("Modified incomplete LU not implemented");
   else
     {
       octave_idx_type nr = a.rows ();
       octave_idx_type nc = a.cols ();
 
       // Setup the control parameters
       Matrix Control (UMFPACK_CONTROL, 1);
       double *control = Control.fortran_vec ();
@@ -293,38 +293,38 @@ SparseLU::SparseLU (const SparseMatrix& 
         Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
 
       UMFPACK_DNAME (report_control) (control);
 
       const octave_idx_type *Ap = a.cidx ();
       const octave_idx_type *Ai = a.ridx ();
       const double *Ax = a.data ();
 
-      UMFPACK_DNAME (report_matrix) (nr, nc, Ap, Ai, Ax, 1, 
+      UMFPACK_DNAME (report_matrix) (nr, nc, Ap, Ai, Ax, 1,
                                                      control);
 
       void *Symbolic;
       Matrix Info (1, UMFPACK_INFO);
       double *info = Info.fortran_vec ();
       int status;
 
       // Null loop so that qinit is imediately deallocated when not needed
       do {
         OCTAVE_LOCAL_BUFFER (octave_idx_type, qinit, nc);
 
         for (octave_idx_type i = 0; i < nc; i++)
           qinit [i] = static_cast<octave_idx_type> (Qinit (i));
 
-        status = UMFPACK_DNAME (qsymbolic) (nr, nc, Ap, Ai, Ax, 
+        status = UMFPACK_DNAME (qsymbolic) (nr, nc, Ap, Ai, Ax,
                                        qinit, &Symbolic, control, info);
       } while (0);
 
       if (status < 0)
         {
-          (*current_liboctave_error_handler) 
+          (*current_liboctave_error_handler)
             ("SparseLU::SparseLU symbolic factorization failed");
 
           UMFPACK_DNAME (report_status) (control, status);
           UMFPACK_DNAME (report_info) (control, info);
 
           UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
         }
       else
@@ -335,35 +335,35 @@ SparseLU::SparseLU (const SparseMatrix& 
           status = UMFPACK_DNAME (numeric) (Ap, Ai, Ax, Symbolic,
                                        &Numeric, control, info) ;
           UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
 
           cond = Info (UMFPACK_RCOND);
 
           if (status < 0)
             {
-              (*current_liboctave_error_handler) 
+              (*current_liboctave_error_handler)
                 ("SparseLU::SparseLU numeric factorization failed");
 
               UMFPACK_DNAME (report_status) (control, status);
               UMFPACK_DNAME (report_info) (control, info);
 
               UMFPACK_DNAME (free_numeric) (&Numeric);
             }
           else
             {
               UMFPACK_DNAME (report_numeric) (Numeric, control);
 
               octave_idx_type lnz, unz, ignore1, ignore2, ignore3;
               status = UMFPACK_DNAME (get_lunz) (&lnz, &unz, &ignore1, &ignore2,
                                                  &ignore3, Numeric) ;
-          
+
               if (status < 0)
                 {
-                  (*current_liboctave_error_handler) 
+                  (*current_liboctave_error_handler)
                     ("SparseLU::SparseLU extracting LU factors failed");
 
                   UMFPACK_DNAME (report_status) (control, status);
                   UMFPACK_DNAME (report_info) (control, info);
 
                   UMFPACK_DNAME (free_numeric) (&Numeric);
                 }
               else
@@ -402,56 +402,56 @@ SparseLU::SparseLU (const SparseMatrix& 
                   P.resize (dim_vector (nr, 1));
                   octave_idx_type *p = P.fortran_vec ();
 
                   Q.resize (dim_vector (nc, 1));
                   octave_idx_type *q = Q.fortran_vec ();
 
                   octave_idx_type do_recip;
                   status = UMFPACK_DNAME (get_numeric) (Ltp, Ltj,
-                                                   Ltx, Up, Uj, Ux, p, q, 
-                                                   0, &do_recip, 
+                                                   Ltx, Up, Uj, Ux, p, q,
+                                                   0, &do_recip,
                                                    Rx, Numeric) ;
 
                   UMFPACK_DNAME (free_numeric) (&Numeric) ;
 
                   if (status < 0)
                     {
-                      (*current_liboctave_error_handler) 
+                      (*current_liboctave_error_handler)
                         ("SparseLU::SparseLU extracting LU factors failed");
 
                       UMFPACK_DNAME (report_status) (control, status);
                     }
                   else
                     {
                       Lfact = Lfact.transpose ();
 
                       if (do_recip)
                         for (octave_idx_type i = 0; i < nr; i++)
                           Rx[i] = 1.0 / Rx[i];
 
-                      UMFPACK_DNAME (report_matrix) (nr, n_inner, 
-                                                Lfact.cidx (), 
-                                                Lfact.ridx (), 
+                      UMFPACK_DNAME (report_matrix) (nr, n_inner,
+                                                Lfact.cidx (),
+                                                Lfact.ridx (),
                                                 Lfact.data (),
                                                 1, control);
-                      UMFPACK_DNAME (report_matrix) (n_inner, nc, 
-                                                Ufact.cidx (), 
-                                                Ufact.ridx (), 
+                      UMFPACK_DNAME (report_matrix) (n_inner, nc,
+                                                Ufact.cidx (),
+                                                Ufact.ridx (),
                                                 Ufact.data (),
                                                 1, control);
                       UMFPACK_DNAME (report_perm) (nr, p, control);
                       UMFPACK_DNAME (report_perm) (nc, q, control);
                     }
 
                   UMFPACK_DNAME (report_info) (control, info);
                 }
             }
         }
 
       if (udiag)
-        (*current_liboctave_error_handler) 
-          ("Option udiag of incomplete LU not implemented");   
+        (*current_liboctave_error_handler)
+          ("Option udiag of incomplete LU not implemented");
     }
 #else
   (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 }
diff --git a/liboctave/SparsedbleLU.h b/liboctave/SparsedbleLU.h
--- a/liboctave/SparsedbleLU.h
+++ b/liboctave/SparsedbleLU.h
@@ -28,34 +28,34 @@ along with Octave; see the file COPYING.
 #include "dSparse.h"
 
 class
 OCTAVE_API
 SparseLU : public sparse_base_lu <SparseMatrix, double, SparseMatrix, double>
 {
 public:
 
-  SparseLU (void) 
+  SparseLU (void)
     : sparse_base_lu <SparseMatrix, double, SparseMatrix, double> () { }
 
   SparseLU (const SparseMatrix& a, const Matrix& piv_thres = Matrix(),
             bool scale = false);
 
-  SparseLU (const SparseMatrix& a, const ColumnVector& Qinit, 
-            const Matrix& piv_thres = Matrix(), bool scale = false, 
-            bool FixedQ = false, double droptol = -1., 
+  SparseLU (const SparseMatrix& a, const ColumnVector& Qinit,
+            const Matrix& piv_thres = Matrix(), bool scale = false,
+            bool FixedQ = false, double droptol = -1.,
             bool milu = false, bool udiag = false);
 
-  SparseLU (const SparseLU& a) 
+  SparseLU (const SparseLU& a)
     : sparse_base_lu <SparseMatrix, double, SparseMatrix, double> (a) { }
 
   SparseLU& operator = (const SparseLU& a)
     {
       if (this != &a)
-        sparse_base_lu <SparseMatrix, double, SparseMatrix, double> 
+        sparse_base_lu <SparseMatrix, double, SparseMatrix, double>
           :: operator = (a);
 
       return *this;
     }
 
   ~SparseLU (void) { }
 };
 
diff --git a/liboctave/base-aepbal.h b/liboctave/base-aepbal.h
--- a/liboctave/base-aepbal.h
+++ b/liboctave/base-aepbal.h
@@ -31,20 +31,20 @@ protected:
   VectorT scale;
   octave_idx_type ilo, ihi;
   char job;
 
   base_aepbal (void) : balanced_mat (), scale (), ilo (), ihi (), job () { }
 
 public:
 
-  base_aepbal (const base_aepbal& a) 
-    : balanced_mat (a.balanced_mat), scale (a.scale), 
+  base_aepbal (const base_aepbal& a)
+    : balanced_mat (a.balanced_mat), scale (a.scale),
       ilo(a.ilo), ihi(a.ihi), job(a.job)
-  { 
+  {
   }
 
   base_aepbal& operator = (const base_aepbal& a)
     {
       balanced_mat = a.balanced_mat;
       scale = a.scale;
       ilo = a.ilo;
       ihi = a.ihi;
@@ -67,17 +67,17 @@ public:
           octave_idx_type j = scale(i) - 1;
           std::swap (pv(i), pv(j));
         }
       for (octave_idx_type i = 0; i < ilo-1; i++)
         {
           octave_idx_type j = scale(i) - 1;
           std::swap (pv(i), pv(j));
         }
-      
+
       return pv;
     }
 
   VectorT scaling_vector (void) const
     {
       octave_idx_type n = balanced_mat.rows ();
       VectorT scv (n);
       for (octave_idx_type i = 0; i < ilo-1; i++)
diff --git a/liboctave/base-de.h b/liboctave/base-de.h
--- a/liboctave/base-de.h
+++ b/liboctave/base-de.h
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 
 class
 base_diff_eqn
 {
 public:
 
   base_diff_eqn (void)
     : x (), t (0.0), stop_time (0.0), stop_time_set (false),
-      restart (true), integration_error (false), istate (0) { } 
+      restart (true), integration_error (false), istate (0) { }
 
   base_diff_eqn (const ColumnVector& xx, double tt)
     : x (xx), t (tt), stop_time (0.0), stop_time_set (false),
       restart (true), integration_error (false), istate (0) { }
 
   base_diff_eqn (const base_diff_eqn& a)
     : x (a.x), t (a.t), stop_time (0.0), stop_time_set (false),
       restart (true), integration_error (false), istate (0) { }
diff --git a/liboctave/base-lu.cc b/liboctave/base-lu.cc
--- a/liboctave/base-lu.cc
+++ b/liboctave/base-lu.cc
@@ -23,17 +23,17 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "base-lu.h"
 
 template <class lu_type>
-base_lu<lu_type>::base_lu (const lu_type& l, const lu_type& u, 
+base_lu<lu_type>::base_lu (const lu_type& l, const lu_type& u,
                            const PermMatrix& p)
   : a_fact (u), l_fact (l), ipvt (p.pvec ())
 {
   if (l.columns () != u.rows ())
     (*current_liboctave_error_handler) ("lu: dimension mismatch");
 }
 
 template <class lu_type>
diff --git a/liboctave/base-lu.h b/liboctave/base-lu.h
--- a/liboctave/base-lu.h
+++ b/liboctave/base-lu.h
@@ -37,17 +37,17 @@ public:
   typedef typename lu_type::element_type lu_elt_type;
 
   base_lu (void)
     : a_fact (), l_fact (), ipvt () { }
 
   base_lu (const base_lu& a)
     : a_fact (a.a_fact), l_fact (a.l_fact), ipvt (a.ipvt) { }
 
-  base_lu (const lu_type& l, const lu_type& u, 
+  base_lu (const lu_type& l, const lu_type& u,
            const PermMatrix& p);
 
   base_lu& operator = (const base_lu& a)
     {
       if (this != &a)
         {
           a_fact = a.a_fact;
           l_fact = a.l_fact;
diff --git a/liboctave/boolNDArray.cc b/liboctave/boolNDArray.cc
--- a/liboctave/boolNDArray.cc
+++ b/liboctave/boolNDArray.cc
@@ -63,25 +63,25 @@ boolNDArray::all (int dim) const
 }
 
 boolNDArray
 boolNDArray::any (int dim) const
 {
   return do_mx_red_op<bool, bool> (*this, dim, mx_inline_any);
 }
 
-NDArray 
+NDArray
 boolNDArray::sum (int dim) const
 {
   // NOTE: going via octave_idx_type is typically faster even though it
-  // requires a conversion. 
+  // requires a conversion.
   return do_mx_red_op<octave_idx_type, bool> (*this, dim, mx_inline_count);
 }
 
-NDArray 
+NDArray
 boolNDArray::cumsum (int dim) const
 {
   // In this case, it's better to sum directly to doubles.
   return do_mx_cum_op<double , bool> (*this, dim, mx_inline_cumcount);
 }
 
 boolNDArray
 boolNDArray::concat (const boolNDArray& rb, const Array<octave_idx_type>& ra_idx)
@@ -138,28 +138,28 @@ NDND_BOOL_OPS (boolNDArray, boolNDArray)
 NDND_CMP_OPS (boolNDArray, boolNDArray)
 
 NDS_BOOL_OPS (boolNDArray, bool)
 NDS_CMP_OPS (boolNDArray, bool)
 
 SND_BOOL_OPS (bool, boolNDArray)
 SND_CMP_OPS (bool, boolNDArray)
 
-boolNDArray& 
+boolNDArray&
 mx_el_and_assign (boolNDArray& a, const boolNDArray& b)
 {
   if (a.is_shared ())
     a = mx_el_and (a, b);
   else
     do_mm_inplace_op<bool, bool> (a, b, mx_inline_and2, "operator &=");
 
   return a;
 }
 
-boolNDArray& 
+boolNDArray&
 mx_el_or_assign (boolNDArray& a, const boolNDArray& b)
 {
   if (a.is_shared ())
     a = mx_el_or (a, b);
   else
     do_mm_inplace_op<bool, bool> (a, b, mx_inline_or2, "operator |=");
 
   return a;
diff --git a/liboctave/boolNDArray.h b/liboctave/boolNDArray.h
--- a/liboctave/boolNDArray.h
+++ b/liboctave/boolNDArray.h
@@ -41,34 +41,34 @@ public:
   typedef boolMatrix matrix_type;
 
   boolNDArray (void) : Array<bool> () { }
 
   boolNDArray (const dim_vector& dv) : Array<bool> (dv) { }
 
   boolNDArray (const dim_vector& dv, const bool& val)
     : Array<bool> (dv, val) { }
-  
+
   boolNDArray (const boolNDArray& a) : Array<bool> (a) { }
 
   boolNDArray (const boolMatrix& a) : Array<bool> (a) { }
 
   boolNDArray (const Array<bool>& a) : Array<bool> (a) { }
 
   boolNDArray& operator = (const boolNDArray& a)
     {
       Array<bool>::operator = (a);
       return *this;
     }
 
   // unary operations
 
   boolNDArray operator ! (void) const;
 
-  boolNDArray& invert (void); 
+  boolNDArray& invert (void);
 
   bool any_element_is_nan (void) const { return false; }
 
   // FIXME -- this is not quite the right thing.
 
   boolNDArray all (int dim = -1) const;
   boolNDArray any (int dim = -1) const;
 
@@ -109,17 +109,17 @@ NDND_BOOL_OP_DECLS (boolNDArray, boolNDA
 NDND_CMP_OP_DECLS (boolNDArray, boolNDArray, OCTAVE_API)
 
 NDS_BOOL_OP_DECLS (boolNDArray, bool, OCTAVE_API)
 NDS_CMP_OP_DECLS (boolNDArray, bool, OCTAVE_API)
 
 SND_BOOL_OP_DECLS (bool, boolNDArray, OCTAVE_API)
 SND_CMP_OP_DECLS (bool, boolNDArray, OCTAVE_API)
 
-extern OCTAVE_API boolNDArray& 
+extern OCTAVE_API boolNDArray&
 mx_el_and_assign (boolNDArray& m, const boolNDArray& a);
-extern OCTAVE_API boolNDArray& 
+extern OCTAVE_API boolNDArray&
 mx_el_or_assign (boolNDArray& m, const boolNDArray& a);
 
 BSXFUN_OP_DECL (and, boolNDArray, OCTAVE_API);
 BSXFUN_OP_DECL (or, boolNDArray, OCTAVE_API);
 
 #endif
diff --git a/liboctave/boolSparse.cc b/liboctave/boolSparse.cc
--- a/liboctave/boolSparse.cc
+++ b/liboctave/boolSparse.cc
@@ -98,19 +98,19 @@ SparseBoolMatrix::concat (const SparseBo
 
 SparseBoolMatrix
 SparseBoolMatrix::operator ! (void) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nz1 = nnz ();
   octave_idx_type nz2 = nr*nc - nz1;
-   
+
   SparseBoolMatrix r (nr, nc, nz2);
-   
+
   octave_idx_type ii = 0;
   octave_idx_type jj = 0;
   r.cidx (0) = 0;
   for (octave_idx_type i = 0; i < nc; i++)
     {
       for (octave_idx_type j = 0; j < nr; j++)
         {
           if (jj < cidx(i+1) && ridx(jj) == j)
@@ -254,52 +254,52 @@ SparseBoolMatrix::matrix_value (void) co
 
 std::ostream&
 operator << (std::ostream& os, const SparseBoolMatrix& a)
 {
   octave_idx_type nc = a.cols ();
 
    // add one to the printed indices to go from
    //  zero-based to one-based arrays
-   for (octave_idx_type j = 0; j < nc; j++)  
+   for (octave_idx_type j = 0; j < nc; j++)
      {
        octave_quit ();
        for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
          os << a.ridx(i) + 1 << " "  << j + 1 << " " << a.data(i) << "\n";
      }
-   
+
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, SparseBoolMatrix& a)
 {
   typedef SparseBoolMatrix::element_type elt_type;
 
   return read_sparse_matrix<elt_type> (is, a, octave_read_value<bool>);
 }
 
 SparseBoolMatrix
-SparseBoolMatrix::squeeze (void) const 
-{ 
-  return Sparse<bool>::squeeze (); 
+SparseBoolMatrix::squeeze (void) const
+{
+  return Sparse<bool>::squeeze ();
 }
 
 SparseBoolMatrix
-SparseBoolMatrix::index (const idx_vector& i, bool resize_ok) const 
-{ 
-  return Sparse<bool>::index (i, resize_ok); 
+SparseBoolMatrix::index (const idx_vector& i, bool resize_ok) const
+{
+  return Sparse<bool>::index (i, resize_ok);
 }
 
 SparseBoolMatrix
-SparseBoolMatrix::index (const idx_vector& i, const idx_vector& j, bool resize_ok) const 
-{ 
-  return Sparse<bool>::index (i, j, resize_ok); 
+SparseBoolMatrix::index (const idx_vector& i, const idx_vector& j, bool resize_ok) const
+{
+  return Sparse<bool>::index (i, j, resize_ok);
 }
-  
+
 SparseBoolMatrix
 SparseBoolMatrix::reshape (const dim_vector& new_dims) const
 {
   return Sparse<bool>::reshape (new_dims);
 }
 
 SparseBoolMatrix
 SparseBoolMatrix::permute (const Array<octave_idx_type>& vec, bool inv) const
diff --git a/liboctave/boolSparse.h b/liboctave/boolSparse.h
--- a/liboctave/boolSparse.h
+++ b/liboctave/boolSparse.h
@@ -35,60 +35,60 @@ OCTAVE_API
 SparseBoolMatrix : public Sparse<bool>
 {
 public:
 
   SparseBoolMatrix (void) : Sparse<bool> () { }
 
   SparseBoolMatrix (octave_idx_type r, octave_idx_type c) : Sparse<bool> (r, c) { }
 
-  explicit SparseBoolMatrix (octave_idx_type r, octave_idx_type c, bool val) 
+  explicit SparseBoolMatrix (octave_idx_type r, octave_idx_type c, bool val)
     : Sparse<bool> (r, c, val) { }
 
-  SparseBoolMatrix (const dim_vector& dv, octave_idx_type nz = 0) : 
+  SparseBoolMatrix (const dim_vector& dv, octave_idx_type nz = 0) :
     Sparse<bool> (dv, nz) { }
 
   SparseBoolMatrix (const Sparse<bool>& a) : Sparse<bool> (a) { }
 
   SparseBoolMatrix (const SparseBoolMatrix& a) : Sparse<bool> (a) { }
 
-  SparseBoolMatrix (const SparseBoolMatrix& a, const dim_vector& dv) 
+  SparseBoolMatrix (const SparseBoolMatrix& a, const dim_vector& dv)
     : Sparse<bool> (a, dv) { }
 
   explicit SparseBoolMatrix (const boolMatrix& a) : Sparse<bool> (a) { }
 
   explicit SparseBoolMatrix (const boolNDArray& a) : Sparse<bool> (a) { }
 
-  SparseBoolMatrix (const Array<bool>& a, const idx_vector& r, 
-                    const idx_vector& c, octave_idx_type nr = -1, 
+  SparseBoolMatrix (const Array<bool>& a, const idx_vector& r,
+                    const idx_vector& c, octave_idx_type nr = -1,
                     octave_idx_type nc = -1, bool sum_terms = true,
                     octave_idx_type nzm = -1)
     : Sparse<bool> (a, r, c, nr, nc, sum_terms, nzm) { }
 
   SparseBoolMatrix (octave_idx_type r, octave_idx_type c, octave_idx_type num_nz) : Sparse<bool> (r, c, num_nz) { }
 
   SparseBoolMatrix& operator = (const SparseBoolMatrix& a)
     {
       Sparse<bool>::operator = (a);
       return *this;
     }
 
   bool operator == (const SparseBoolMatrix& a) const;
   bool operator != (const SparseBoolMatrix& a) const;
 
-  SparseBoolMatrix transpose (void) const 
+  SparseBoolMatrix transpose (void) const
     { return Sparse<bool>::transpose (); }
 
   // destructive insert/delete/reorder operations
 
   SparseBoolMatrix& insert (const SparseBoolMatrix& a, octave_idx_type r, octave_idx_type c);
 
   SparseBoolMatrix& insert (const SparseBoolMatrix& a, const Array<octave_idx_type>& indx);
 
-  SparseBoolMatrix concat (const SparseBoolMatrix& rb, 
+  SparseBoolMatrix concat (const SparseBoolMatrix& rb,
                            const Array<octave_idx_type>& ra_idx);
 
   SparseBoolMatrix diag (octave_idx_type k = 0) const;
 
   boolMatrix matrix_value (void) const;
 
   SparseBoolMatrix squeeze (void) const;
 
diff --git a/liboctave/bsxfun-defs.cc b/liboctave/bsxfun-defs.cc
--- a/liboctave/bsxfun-defs.cc
+++ b/liboctave/bsxfun-defs.cc
@@ -108,17 +108,17 @@ do_bsxfun_op (const Array<X>& x, const A
 
       octave_idx_type niter = dvr.numel (start);
       // The index array.
       OCTAVE_LOCAL_BUFFER_INIT (octave_idx_type, idx, nd, 0);
       for (octave_idx_type iter = 0; iter < niter; iter++)
         {
           octave_quit ();
 
-          // Compute indices. 
+          // Compute indices.
           // FIXME: performance impact noticeable?
           octave_idx_type xidx = cdvx.cum_compute_index (idx);
           octave_idx_type yidx = cdvy.cum_compute_index (idx);
           octave_idx_type ridx = dvr.compute_index (idx);
 
           // Apply the low-level loop.
           if (xsing)
             op_sv (ldr, rvec + ridx, xvec[xidx], yvec + yidx);
diff --git a/liboctave/chMatrix.cc b/liboctave/chMatrix.cc
--- a/liboctave/chMatrix.cc
+++ b/liboctave/chMatrix.cc
@@ -125,17 +125,17 @@ charMatrix::insert (const char *s, octav
 charMatrix&
 charMatrix::insert (const charMatrix& a, octave_idx_type r, octave_idx_type c)
 {
   Array<char>::insert (a, r, c);
   return *this;
 }
 
 std::string
-charMatrix::row_as_string (octave_idx_type r, bool strip_ws) const 
+charMatrix::row_as_string (octave_idx_type r, bool strip_ws) const
 {
   std::string retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (r == 0 && nr == 0 && nc == 0)
     return retval;
diff --git a/liboctave/chNDArray.cc b/liboctave/chNDArray.cc
--- a/liboctave/chNDArray.cc
+++ b/liboctave/chNDArray.cc
@@ -115,17 +115,17 @@ charNDArray::matrix_value (void) const
 void
 charNDArray::increment_index (Array<octave_idx_type>& ra_idx,
                               const dim_vector& dimensions,
                               int start_dimension)
 {
   ::increment_index (ra_idx, dimensions, start_dimension);
 }
 
-octave_idx_type 
+octave_idx_type
 charNDArray::compute_index (Array<octave_idx_type>& ra_idx,
                             const dim_vector& dimensions)
 {
   return ::compute_index (ra_idx, dimensions);
 }
 
 charNDArray
 charNDArray::diag (octave_idx_type k) const
diff --git a/liboctave/chNDArray.h b/liboctave/chNDArray.h
--- a/liboctave/chNDArray.h
+++ b/liboctave/chNDArray.h
@@ -38,17 +38,17 @@ public:
 
   typedef charMatrix matrix_type;
 
   charNDArray (void) : Array<char> () { }
 
   charNDArray (const dim_vector& dv) : Array<char> (dv) { }
 
   charNDArray (const dim_vector& dv, char val) : Array<char> (dv, val) { }
-  
+
   charNDArray (const charNDArray& a) : Array<char> (a) { }
 
   charNDArray (const charMatrix& a) : Array<char> (a) { }
 
   charNDArray (char c) : Array<char> (charMatrix (c)) { }
 
   charNDArray (const char *s) : Array<char> (charMatrix (s)) { }
 
@@ -70,17 +70,17 @@ public:
 
   boolNDArray all (int dim = -1) const;
   boolNDArray any (int dim = -1) const;
   charNDArray concat (const charNDArray& rb, const Array<octave_idx_type>& ra_idx);
   charNDArray concat (const NDArray& rb, const Array<octave_idx_type>& ra_idx);
 
   charNDArray& insert (const charNDArray& a, octave_idx_type r, octave_idx_type c);
   charNDArray& insert (const charNDArray& a, const Array<octave_idx_type>& ra_idx);
-  
+
   charMatrix matrix_value (void) const;
 
   charNDArray squeeze (void) const { return Array<char>::squeeze (); }
 
   static void increment_index (Array<octave_idx_type>& ra_idx,
                                const dim_vector& dimensions,
                                int start_dimension = 0);
 
diff --git a/liboctave/cmd-edit.cc b/liboctave/cmd-edit.cc
--- a/liboctave/cmd-edit.cc
+++ b/liboctave/cmd-edit.cc
@@ -422,17 +422,17 @@ gnu_readline::do_set_char_is_quoted_func
 }
 
 void
 gnu_readline::do_set_user_accept_line_function (user_accept_line_fcn f)
 {
   user_accept_line_function = f;
 
   if (f)
-    octave_rl_add_defun ("accept-line", gnu_readline::command_accept_line, 
+    octave_rl_add_defun ("accept-line", gnu_readline::command_accept_line,
                          ::octave_rl_ctrl ('M'));
   else
     octave_rl_add_defun ("accept-line", ::octave_rl_newline,
                          ::octave_rl_ctrl ('M'));
 }
 
 gnu_readline::completion_fcn
 gnu_readline::do_get_completion_function (void) const
@@ -843,17 +843,17 @@ command_editor::make_command_editor (voi
 {
 #if defined (USE_READLINE)
   instance = new gnu_readline ();
 #else
   instance = new default_command_editor ();
 #endif
 }
 
-void 
+void
 command_editor::force_default_editor (void)
 {
   delete instance;
   instance = new default_command_editor ();
 }
 
 int
 command_editor::startup_handler (void)
@@ -1248,18 +1248,18 @@ command_editor::filename_completion_desi
 bool
 command_editor::filename_quoting_desired (bool arg)
 {
   return (instance_ok ())
     ? instance->do_filename_quoting_desired (arg) : false;
 }
 
 // Return a string which will be printed as a prompt.  The string may
-// contain special characters which are decoded as follows: 
-//   
+// contain special characters which are decoded as follows:
+//
 //      \a      bell (ascii 07)
 //      \d      the date
 //      \e      escape (ascii 033)
 //      \h      the hostname up to the first `.'
 //      \H      the hostname
 //      \n      CRLF
 //      \r      CR
 //      \s      the name of the shell (program)
@@ -1422,17 +1422,17 @@ command_editor::do_decode_prompt_string 
             case 'h':
               {
                 temp = octave_env::get_host_name ();
 
                 size_t pos = temp.find ('.');
 
                 if (pos != std::string::npos)
                   temp.resize (pos);
-                
+
                 goto add_string;
               }
 
             case '#':
               {
                 char number_buffer[128];
                 sprintf (number_buffer, "%d", command_number);
                 temp = number_buffer;
diff --git a/liboctave/cmd-edit.h b/liboctave/cmd-edit.h
--- a/liboctave/cmd-edit.h
+++ b/liboctave/cmd-edit.h
@@ -212,17 +212,17 @@ protected:
   virtual int do_terminal_cols (void) { return 80; }
 
   virtual void do_clear_screen (void) { }
 
   virtual void do_resize_terminal (void) { }
 
   virtual std::string do_decode_prompt_string (const std::string&);
 
-  virtual std::string newline_chars (void) { return "\n"; } 
+  virtual std::string newline_chars (void) { return "\n"; }
 
   virtual void do_restore_terminal_state (void) { }
 
   virtual void do_blink_matching_paren (bool) { }
 
   virtual void do_set_basic_word_break_characters (const std::string&) { }
 
   virtual void do_set_completer_word_break_characters (const std::string&) { }
diff --git a/liboctave/cmd-hist.cc b/liboctave/cmd-hist.cc
--- a/liboctave/cmd-hist.cc
+++ b/liboctave/cmd-hist.cc
@@ -593,17 +593,17 @@ command_history::read (const std::string
 void
 command_history::read_range (int from, int to, bool must_exist)
 {
   read_range (file (), from, to, must_exist);
 }
 
 void
 command_history::read_range (const std::string& f, int from, int to,
-                             bool must_exist) 
+                             bool must_exist)
 {
   if (instance_ok ())
     instance->do_read_range (f, from, to, must_exist);
 }
 
 void
 command_history::write (const std::string& f)
 {
diff --git a/liboctave/dColVector.h b/liboctave/dColVector.h
--- a/liboctave/dColVector.h
+++ b/liboctave/dColVector.h
@@ -34,17 +34,17 @@ ColumnVector : public MArray<double>
 {
 public:
 
   ColumnVector (void) : MArray<double> (dim_vector (0, 1)) { }
 
   explicit ColumnVector (octave_idx_type n)
     : MArray<double> (dim_vector (n, 1)) { }
 
-  explicit ColumnVector (const dim_vector& dv) 
+  explicit ColumnVector (const dim_vector& dv)
     : MArray<double> (dv.as_column ()) { }
 
   ColumnVector (octave_idx_type n, double val)
     : MArray<double> (dim_vector (n, 1), val) { }
 
   ColumnVector (const ColumnVector& a) : MArray<double> (a) { }
 
   ColumnVector (const MArray<double>& a) : MArray<double> (a.as_column ()) { }
diff --git a/liboctave/dDiagMatrix.cc b/liboctave/dDiagMatrix.cc
--- a/liboctave/dDiagMatrix.cc
+++ b/liboctave/dDiagMatrix.cc
@@ -179,83 +179,83 @@ DiagMatrix::extract (octave_idx_type r1,
 RowVector
 DiagMatrix::row (octave_idx_type i) const
 {
   octave_idx_type r = rows ();
   octave_idx_type c = cols ();
   if (i < 0 || i >= r)
     {
       (*current_liboctave_error_handler) ("invalid row selection");
-      return RowVector (); 
+      return RowVector ();
     }
 
   RowVector retval (c, 0.0);
   if (r <= c || (r > c && i < c))
     retval.elem (i) = elem (i, i);
 
   return retval;
 }
 
 RowVector
 DiagMatrix::row (char *s) const
 {
   if (! s)
     {
       (*current_liboctave_error_handler) ("invalid row selection");
-      return RowVector (); 
+      return RowVector ();
     }
 
   char c = *s;
   if (c == 'f' || c == 'F')
     return row (static_cast<octave_idx_type>(0));
   else if (c == 'l' || c == 'L')
     return row (rows () - 1);
   else
     {
       (*current_liboctave_error_handler) ("invalid row selection");
-      return RowVector (); 
+      return RowVector ();
     }
 }
 
 ColumnVector
 DiagMatrix::column (octave_idx_type i) const
 {
   octave_idx_type r = rows ();
   octave_idx_type c = cols ();
   if (i < 0 || i >= c)
     {
       (*current_liboctave_error_handler) ("invalid column selection");
-      return ColumnVector (); 
+      return ColumnVector ();
     }
 
   ColumnVector retval (r, 0.0);
   if (r >= c || (r < c && i < r))
     retval.elem (i) = elem (i, i);
 
   return retval;
 }
 
 ColumnVector
 DiagMatrix::column (char *s) const
 {
   if (! s)
     {
       (*current_liboctave_error_handler) ("invalid column selection");
-      return ColumnVector (); 
+      return ColumnVector ();
     }
 
   char c = *s;
   if (c == 'f' || c == 'F')
     return column (static_cast<octave_idx_type>(0));
   else if (c == 'l' || c == 'L')
     return column (cols () - 1);
   else
     {
       (*current_liboctave_error_handler) ("invalid column selection");
-      return ColumnVector (); 
+      return ColumnVector ();
     }
 }
 
 DiagMatrix
 DiagMatrix::inverse (void) const
 {
   octave_idx_type info;
   return inverse (info);
diff --git a/liboctave/dDiagMatrix.h b/liboctave/dDiagMatrix.h
--- a/liboctave/dDiagMatrix.h
+++ b/liboctave/dDiagMatrix.h
@@ -50,17 +50,17 @@ public:
 
   DiagMatrix (const MDiagArray2<double>& a) : MDiagArray2<double> (a) { }
 
   template <class U>
   DiagMatrix (const DiagArray2<U>& a) : MDiagArray2<double> (a) { }
 
   explicit DiagMatrix (const Array<double>& a) : MDiagArray2<double> (a) { }
 
-  DiagMatrix (const Array<double>& a, octave_idx_type r, octave_idx_type c) 
+  DiagMatrix (const Array<double>& a, octave_idx_type r, octave_idx_type c)
     : MDiagArray2<double> (a, r, c) { }
 
   DiagMatrix& operator = (const DiagMatrix& a)
     {
       MDiagArray2<double>::operator = (a);
       return *this;
     }
 
@@ -70,17 +70,17 @@ public:
   DiagMatrix& fill (double val);
   DiagMatrix& fill (double val, octave_idx_type beg, octave_idx_type end);
   DiagMatrix& fill (const ColumnVector& a);
   DiagMatrix& fill (const RowVector& a);
   DiagMatrix& fill (const ColumnVector& a, octave_idx_type beg);
   DiagMatrix& fill (const RowVector& a, octave_idx_type beg);
 
   DiagMatrix transpose (void) const { return MDiagArray2<double>::transpose(); }
-  DiagMatrix abs (void) const; 
+  DiagMatrix abs (void) const;
 
   friend OCTAVE_API DiagMatrix real (const ComplexDiagMatrix& a);
   friend OCTAVE_API DiagMatrix imag (const ComplexDiagMatrix& a);
 
   // resize is the destructive analog for this one
 
   Matrix extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const;
 
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -112,17 +112,17 @@ extern "C"
   F77_RET_T
   F77_FUNC (xddot, XDDOT) (const octave_idx_type&, const double*,
                            const octave_idx_type&, const double*,
                            const octave_idx_type&, double&);
 
   F77_RET_T
   F77_FUNC (dsyrk, DSYRK) (F77_CONST_CHAR_ARG_DECL,
                            F77_CONST_CHAR_ARG_DECL,
-                           const octave_idx_type&, const octave_idx_type&, 
+                           const octave_idx_type&, const octave_idx_type&,
                            const double&, const double*, const octave_idx_type&,
                            const double&, double*, const octave_idx_type&
                            F77_CHAR_ARG_LEN_DECL
                            F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dgetrf, DGETRF) (const octave_idx_type&, const octave_idx_type&,
                              double*, const octave_idx_type&,
@@ -139,18 +139,18 @@ extern "C"
   F77_RET_T
   F77_FUNC (dgetri, DGETRI) (const octave_idx_type&, double*,
                              const octave_idx_type&, const octave_idx_type*,
                              double*, const octave_idx_type&,
                              octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (dgecon, DGECON) (F77_CONST_CHAR_ARG_DECL,
-                             const octave_idx_type&, double*, 
-                             const octave_idx_type&, const double&, double&, 
+                             const octave_idx_type&, double*,
+                             const octave_idx_type&, const double&, double&,
                              double*, octave_idx_type*, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dgelsy, DGELSY) (const octave_idx_type&, const octave_idx_type&,
                              const octave_idx_type&, double*,
                              const octave_idx_type&, double*,
                              const octave_idx_type&, octave_idx_type*,
@@ -177,43 +177,43 @@ extern "C"
                              const octave_idx_type&, double*,
                              const octave_idx_type&, const double&,
                              double&, double*, octave_idx_type*,
                              octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL);
   F77_RET_T
   F77_FUNC (dpotrs, DPOTRS) (F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&, const octave_idx_type&,
-                             const double*, const octave_idx_type&, double*, 
+                             const double*, const octave_idx_type&, double*,
                              const octave_idx_type&, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dtrtri, DTRTRI) (F77_CONST_CHAR_ARG_DECL,
-                             F77_CONST_CHAR_ARG_DECL, 
-                             const octave_idx_type&, const double*, 
+                             F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, const double*,
                              const octave_idx_type&, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
   F77_RET_T
   F77_FUNC (dtrcon, DTRCON) (F77_CONST_CHAR_ARG_DECL,
-                             F77_CONST_CHAR_ARG_DECL, 
+                             F77_CONST_CHAR_ARG_DECL,
                              F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&, const double*,
                              const octave_idx_type&, double&,
-                             double*, octave_idx_type*, octave_idx_type& 
+                             double*, octave_idx_type*, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
   F77_RET_T
   F77_FUNC (dtrtrs, DTRTRS) (F77_CONST_CHAR_ARG_DECL,
-                             F77_CONST_CHAR_ARG_DECL, 
+                             F77_CONST_CHAR_ARG_DECL,
                              F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&, const octave_idx_type&,
-                             const double*, const octave_idx_type&, double*, 
+                             const double*, const octave_idx_type&, double*,
                              const octave_idx_type&, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dlartg, DLARTG) (const double&, const double&, double&,
                              double&, double&);
@@ -229,17 +229,17 @@ extern "C"
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (xdlange, XDLANGE) (F77_CONST_CHAR_ARG_DECL,
                                const octave_idx_type&, const octave_idx_type&,
                                const double*, const octave_idx_type&,
                                double*, double&
-                               F77_CHAR_ARG_LEN_DECL); 
+                               F77_CHAR_ARG_LEN_DECL);
 }
 
 // Matrix class.
 
 Matrix::Matrix (const RowVector& rv)
   : MArray<double> (rv)
 {
 }
@@ -665,17 +665,17 @@ Matrix::inverse (MatrixType& mattype) co
 Matrix
 Matrix::inverse (MatrixType &mattype, octave_idx_type& info) const
 {
   double rcon;
   return inverse (mattype, info, rcon, 0, 0);
 }
 
 Matrix
-Matrix::tinverse (MatrixType &mattype, octave_idx_type& info, double& rcon, 
+Matrix::tinverse (MatrixType &mattype, octave_idx_type& info, double& rcon,
                   int force, int calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc || nr == 0 || nc == 0)
@@ -685,55 +685,55 @@ Matrix::tinverse (MatrixType &mattype, o
       int typ = mattype.type ();
       char uplo = (typ == MatrixType::Lower ? 'L' : 'U');
       char udiag = 'N';
       retval = *this;
       double *tmp_data = retval.fortran_vec ();
 
       F77_XFCN (dtrtri, DTRTRI, (F77_CONST_CHAR_ARG2 (&uplo, 1),
                                  F77_CONST_CHAR_ARG2 (&udiag, 1),
-                                 nr, tmp_data, nr, info 
+                                 nr, tmp_data, nr, info
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
-      if (info != 0) 
+      if (info != 0)
         info = -1;
-      else if (calc_cond) 
+      else if (calc_cond)
         {
           octave_idx_type dtrcon_info = 0;
           char job = '1';
 
           OCTAVE_LOCAL_BUFFER (double, work, 3 * nr);
           OCTAVE_LOCAL_BUFFER (octave_idx_type, iwork, nr);
 
           F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      F77_CONST_CHAR_ARG2 (&uplo, 1),
                                      F77_CONST_CHAR_ARG2 (&udiag, 1),
-                                     nr, tmp_data, nr, rcon, 
-                                     work, iwork, dtrcon_info 
+                                     nr, tmp_data, nr, rcon,
+                                     work, iwork, dtrcon_info
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)));
 
-          if (dtrcon_info != 0) 
+          if (dtrcon_info != 0)
             info = -1;
         }
 
       if (info == -1 && ! force)
         retval = *this; // Restore matrix contents.
     }
 
   return retval;
 }
 
 
 Matrix
-Matrix::finverse (MatrixType &mattype, octave_idx_type& info, double& rcon, 
+Matrix::finverse (MatrixType &mattype, octave_idx_type& info, double& rcon,
                   int force, int calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc || nr == 0 || nc == 0)
@@ -745,76 +745,76 @@ Matrix::finverse (MatrixType &mattype, o
 
       retval = *this;
       double *tmp_data = retval.fortran_vec ();
 
       Array<double> z (dim_vector (1, 1));
       octave_idx_type lwork = -1;
 
       // Query the optimum work array size.
-      F77_XFCN (dgetri, DGETRI, (nc, tmp_data, nr, pipvt, 
+      F77_XFCN (dgetri, DGETRI, (nc, tmp_data, nr, pipvt,
                                  z.fortran_vec (), lwork, info));
 
       lwork = static_cast<octave_idx_type> (z(0));
       lwork = (lwork < 2 *nc ? 2*nc : lwork);
       z.resize (dim_vector (lwork, 1));
       double *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       double anorm = 0;
-      if (calc_cond) 
+      if (calc_cond)
         anorm = retval.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
       F77_XFCN (dgetrf, DGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
-      if (info != 0) 
+      if (info != 0)
         info = -1;
-      else if (calc_cond) 
+      else if (calc_cond)
         {
           octave_idx_type dgecon_info = 0;
 
           // Now calculate the condition number for non-singular matrix.
           char job = '1';
           Array<octave_idx_type> iz (dim_vector (nc, 1));
           octave_idx_type *piz = iz.fortran_vec ();
           F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                     nc, tmp_data, nr, anorm, 
+                                     nc, tmp_data, nr, anorm,
                                      rcon, pz, piz, dgecon_info
                                      F77_CHAR_ARG_LEN (1)));
 
-          if (dgecon_info != 0) 
+          if (dgecon_info != 0)
             info = -1;
         }
 
       if (info == -1 && ! force)
         retval = *this; // Restore matrix contents.
       else
         {
           octave_idx_type dgetri_info = 0;
 
           F77_XFCN (dgetri, DGETRI, (nc, tmp_data, nr, pipvt,
                                      pz, lwork, dgetri_info));
 
-          if (dgetri_info != 0) 
+          if (dgetri_info != 0)
             info = -1;
         }
 
       if (info != 0)
         mattype.mark_as_rectangular();
     }
 
   return retval;
 }
 
 Matrix
-Matrix::inverse (MatrixType &mattype, octave_idx_type& info, double& rcon, 
+Matrix::inverse (MatrixType &mattype, octave_idx_type& info, double& rcon,
                  int force, int calc_cond) const
 {
   int typ = mattype.type (false);
   Matrix ret;
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
@@ -905,17 +905,17 @@ Matrix::fourier (void) const
     {
       npts = nr;
       nsamples = nc;
     }
 
   const double *in (fortran_vec ());
   Complex *out (retval.fortran_vec ());
 
-  octave_fftw::fft (in, out, npts, nsamples); 
+  octave_fftw::fft (in, out, npts, nsamples);
 
   return retval;
 }
 
 ComplexMatrix
 Matrix::ifourier (void) const
 {
   size_t nr = rows ();
@@ -935,17 +935,17 @@ Matrix::ifourier (void) const
       npts = nr;
       nsamples = nc;
     }
 
   ComplexMatrix tmp (*this);
   Complex *in (tmp.fortran_vec ());
   Complex *out (retval.fortran_vec ());
 
-  octave_fftw::ifft (in, out, npts, nsamples); 
+  octave_fftw::ifft (in, out, npts, nsamples);
 
   return retval;
 }
 
 ComplexMatrix
 Matrix::fourier2d (void) const
 {
   dim_vector dv(rows (), cols ());
@@ -1254,56 +1254,56 @@ Matrix::determinant (MatrixType& mattype
 
       if (typ == MatrixType::Unknown)
         typ = mattype.type (*this);
       else if (typ == MatrixType::Rectangular)
         typ = MatrixType::Full;
 
       if (typ == MatrixType::Lower || typ == MatrixType::Upper)
         {
-          for (octave_idx_type i = 0; i < nc; i++) 
+          for (octave_idx_type i = 0; i < nc; i++)
             retval *= elem (i,i);
         }
       else if (typ == MatrixType::Hermitian)
         {
           Matrix atmp = *this;
           double *tmp_data = atmp.fortran_vec ();
 
           info = 0;
           double anorm = 0;
           if (calc_cond) anorm = xnorm (*this, 1);
 
 
           char job = 'L';
-          F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
+          F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                      tmp_data, nr, info
                                      F77_CHAR_ARG_LEN (1)));
 
-          if (info != 0) 
+          if (info != 0)
             {
               rcon = 0.0;
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
-          else 
+          else
             {
               Array<double> z (dim_vector (3 * nc, 1));
               double *pz = z.fortran_vec ();
               Array<octave_idx_type> iz (dim_vector (nc, 1));
               octave_idx_type *piz = iz.fortran_vec ();
 
               F77_XFCN (dpocon, DPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                          nr, tmp_data, nr, anorm,
                                          rcon, pz, piz, info
                                          F77_CHAR_ARG_LEN (1)));
 
-              if (info != 0) 
+              if (info != 0)
                 rcon = 0.0;
 
-              for (octave_idx_type i = 0; i < nc; i++) 
+              for (octave_idx_type i = 0; i < nc; i++)
                 retval *= atmp (i,i);
 
               retval = retval.square ();
             }
         }
       else if (typ != MatrixType::Full)
         (*current_liboctave_error_handler) ("det: invalid dense matrix type");
 
@@ -1320,46 +1320,46 @@ Matrix::determinant (MatrixType& mattype
           // Calculate the norm of the matrix, for later use.
           double anorm = 0;
           if (calc_cond) anorm = xnorm (*this, 1);
 
           F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
-          if (info != 0) 
+          if (info != 0)
             {
               info = -1;
               retval = DET ();
-            } 
-          else 
+            }
+          else
             {
-              if (calc_cond) 
+              if (calc_cond)
                 {
                   // Now calc the condition number for non-singular matrix.
                   char job = '1';
                   Array<double> z (dim_vector (4 * nc, 1));
                   double *pz = z.fortran_vec ();
                   Array<octave_idx_type> iz (dim_vector (nc, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                             nc, tmp_data, nr, anorm, 
+                                             nc, tmp_data, nr, anorm,
                                              rcon, pz, piz, info
                                              F77_CHAR_ARG_LEN (1)));
                 }
 
-              if (info != 0) 
+              if (info != 0)
                 {
                   info = -1;
                   retval = DET ();
-                } 
-              else 
+                }
+              else
                 {
-                  for (octave_idx_type i = 0; i < nc; i++) 
+                  for (octave_idx_type i = 0; i < nc; i++)
                     {
                       double c = atmp(i,i);
                       retval *= (ipvt(i) != (i+1)) ? -c : c;
                     }
                 }
             }
         }
     }
@@ -1401,26 +1401,26 @@ Matrix::rcond (MatrixType &mattype) cons
           char uplo = 'U';
           char dia = 'N';
 
           Array<double> z (dim_vector (3 * nc, 1));
           double *pz = z.fortran_vec ();
           Array<octave_idx_type> iz (dim_vector (nc, 1));
           octave_idx_type *piz = iz.fortran_vec ();
 
-          F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
-                                     F77_CONST_CHAR_ARG2 (&uplo, 1), 
-                                     F77_CONST_CHAR_ARG2 (&dia, 1), 
+          F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
+                                     F77_CONST_CHAR_ARG2 (&uplo, 1),
+                                     F77_CONST_CHAR_ARG2 (&dia, 1),
                                      nr, tmp_data, nr, rcon,
                                      pz, piz, info
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)));
 
-          if (info != 0) 
+          if (info != 0)
             rcon = 0.0;
         }
       else if  (typ == MatrixType::Permuted_Upper)
         (*current_liboctave_error_handler)
           ("permuted triangular matrix not implemented");
       else if (typ == MatrixType::Lower)
         {
           const double *tmp_data = fortran_vec ();
@@ -1429,26 +1429,26 @@ Matrix::rcond (MatrixType &mattype) cons
           char uplo = 'L';
           char dia = 'N';
 
           Array<double> z (dim_vector (3 * nc, 1));
           double *pz = z.fortran_vec ();
           Array<octave_idx_type> iz (dim_vector (nc, 1));
           octave_idx_type *piz = iz.fortran_vec ();
 
-          F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
-                                     F77_CONST_CHAR_ARG2 (&uplo, 1), 
-                                     F77_CONST_CHAR_ARG2 (&dia, 1), 
+          F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
+                                     F77_CONST_CHAR_ARG2 (&uplo, 1),
+                                     F77_CONST_CHAR_ARG2 (&dia, 1),
                                      nr, tmp_data, nr, rcon,
                                      pz, piz, info
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)));
 
-          if (info != 0) 
+          if (info != 0)
             rcon = 0.0;
         }
       else if (typ == MatrixType::Permuted_Lower)
         (*current_liboctave_error_handler)
           ("permuted triangular matrix not implemented");
       else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
         {
           double anorm = -1.0;
@@ -1457,39 +1457,39 @@ Matrix::rcond (MatrixType &mattype) cons
 
           if (typ == MatrixType::Hermitian)
             {
               octave_idx_type info = 0;
               char job = 'L';
               anorm = atmp.abs().sum().
                 row(static_cast<octave_idx_type>(0)).max();
 
-              F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
+              F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                          tmp_data, nr, info
                                          F77_CHAR_ARG_LEN (1)));
 
-              if (info != 0) 
+              if (info != 0)
                 {
                   rcon = 0.0;
                   mattype.mark_as_unsymmetric ();
                   typ = MatrixType::Full;
                 }
-              else 
+              else
                 {
                   Array<double> z (dim_vector (3 * nc, 1));
                   double *pz = z.fortran_vec ();
                   Array<octave_idx_type> iz (dim_vector (nc, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dpocon, DPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, tmp_data, nr, anorm,
                                              rcon, pz, piz, info
                                              F77_CHAR_ARG_LEN (1)));
 
-                  if (info != 0) 
+                  if (info != 0)
                     rcon = 0.0;
                 }
             }
 
           if (typ == MatrixType::Full)
             {
               octave_idx_type info = 0;
 
@@ -1502,30 +1502,30 @@ Matrix::rcond (MatrixType &mattype) cons
 
               Array<double> z (dim_vector (4 * nc, 1));
               double *pz = z.fortran_vec ();
               Array<octave_idx_type> iz (dim_vector (nc, 1));
               octave_idx_type *piz = iz.fortran_vec ();
 
               F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
-              if (info != 0) 
+              if (info != 0)
                 {
                   rcon = 0.0;
                   mattype.mark_as_rectangular ();
                 }
-              else 
+              else
                 {
                   char job = '1';
                   F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                             nc, tmp_data, nr, anorm, 
+                                             nc, tmp_data, nr, anorm,
                                              rcon, pz, piz, info
                                              F77_CHAR_ARG_LEN (1)));
 
-                  if (info != 0) 
+                  if (info != 0)
                     rcon = 0.0;
                 }
             }
         }
       else
         rcon = 0.0;
     }
 
@@ -1573,26 +1573,26 @@ Matrix::utsolve (MatrixType &mattype, co
                   char uplo = 'U';
                   char dia = 'N';
 
                   Array<double> z (dim_vector (3 * nc, 1));
                   double *pz = z.fortran_vec ();
                   Array<octave_idx_type> iz (dim_vector (nc, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
-                  F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
-                                             F77_CONST_CHAR_ARG2 (&uplo, 1), 
-                                             F77_CONST_CHAR_ARG2 (&dia, 1), 
+                  F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
+                                             F77_CONST_CHAR_ARG2 (&uplo, 1),
+                                             F77_CONST_CHAR_ARG2 (&dia, 1),
                                              nr, tmp_data, nr, rcon,
                                              pz, piz, info
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)));
 
-                  if (info != 0) 
+                  if (info != 0)
                     info = -2;
 
                   volatile double rcond_plus_one = rcon + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
@@ -1609,19 +1609,19 @@ Matrix::utsolve (MatrixType &mattype, co
                 {
                   retval = b;
                   double *result = retval.fortran_vec ();
 
                   char uplo = 'U';
                   char trans = get_blas_char (transt);
                   char dia = 'N';
 
-                  F77_XFCN (dtrtrs, DTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
-                                             F77_CONST_CHAR_ARG2 (&trans, 1), 
-                                             F77_CONST_CHAR_ARG2 (&dia, 1), 
+                  F77_XFCN (dtrtrs, DTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1),
+                                             F77_CONST_CHAR_ARG2 (&trans, 1),
+                                             F77_CONST_CHAR_ARG2 (&dia, 1),
                                              nr, b_nc, tmp_data, nr,
                                              result, nr, info
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)));
                 }
             }
         }
@@ -1673,26 +1673,26 @@ Matrix::ltsolve (MatrixType &mattype, co
                   char uplo = 'L';
                   char dia = 'N';
 
                   Array<double> z (dim_vector (3 * nc, 1));
                   double *pz = z.fortran_vec ();
                   Array<octave_idx_type> iz (dim_vector (nc, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
-                  F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
-                                             F77_CONST_CHAR_ARG2 (&uplo, 1), 
-                                             F77_CONST_CHAR_ARG2 (&dia, 1), 
+                  F77_XFCN (dtrcon, DTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
+                                             F77_CONST_CHAR_ARG2 (&uplo, 1),
+                                             F77_CONST_CHAR_ARG2 (&dia, 1),
                                              nr, tmp_data, nr, rcon,
                                              pz, piz, info
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)));
 
-                  if (info != 0) 
+                  if (info != 0)
                     info = -2;
 
                   volatile double rcond_plus_one = rcon + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
@@ -1709,19 +1709,19 @@ Matrix::ltsolve (MatrixType &mattype, co
                 {
                   retval = b;
                   double *result = retval.fortran_vec ();
 
                   char uplo = 'L';
                   char trans = get_blas_char (transt);
                   char dia = 'N';
 
-                  F77_XFCN (dtrtrs, DTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
-                                             F77_CONST_CHAR_ARG2 (&trans, 1), 
-                                             F77_CONST_CHAR_ARG2 (&dia, 1), 
+                  F77_XFCN (dtrtrs, DTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1),
+                                             F77_CONST_CHAR_ARG2 (&trans, 1),
+                                             F77_CONST_CHAR_ARG2 (&dia, 1),
                                              nr, b_nc, tmp_data, nr,
                                              result, nr, info
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)));
                 }
             }
         }
@@ -1745,56 +1745,56 @@ Matrix::fsolve (MatrixType &mattype, con
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || b.cols () == 0)
     retval = Matrix (nc, b.cols (), 0.0);
   else
     {
       volatile int typ = mattype.type ();
- 
+
      // Calculate the norm of the matrix, for later use.
       double anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
         {
           info = 0;
           char job = 'L';
           Matrix atmp = *this;
           double *tmp_data = atmp.fortran_vec ();
           anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
-          F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
+          F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                      tmp_data, nr, info
                                      F77_CHAR_ARG_LEN (1)));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
-          if (info != 0) 
+          if (info != 0)
             {
               info = -2;
 
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
-          else 
+          else
             {
               if (calc_cond)
                 {
                   Array<double> z (dim_vector (3 * nc, 1));
                   double *pz = z.fortran_vec ();
                   Array<octave_idx_type> iz (dim_vector (nc, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dpocon, DPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, tmp_data, nr, anorm,
                                              rcon, pz, piz, info
                                              F77_CHAR_ARG_LEN (1)));
 
-                  if (info != 0) 
+                  if (info != 0)
                     info = -2;
 
                   volatile double rcond_plus_one = rcon + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
@@ -1818,17 +1818,17 @@ Matrix::fsolve (MatrixType &mattype, con
                                              nr, b_nc, tmp_data, nr,
                                              result, b.rows(), info
                                              F77_CHAR_ARG_LEN (1)));
                 }
               else
                 {
                   mattype.mark_as_unsymmetric ();
                   typ = MatrixType::Full;
-                }                   
+                }
             }
         }
 
       if (typ == MatrixType::Full)
         {
           info = 0;
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
@@ -1843,41 +1843,41 @@ Matrix::fsolve (MatrixType &mattype, con
           double *pz = z.fortran_vec ();
           Array<octave_idx_type> iz (dim_vector (nc, 1));
           octave_idx_type *piz = iz.fortran_vec ();
 
           F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
-          if (info != 0) 
+          if (info != 0)
             {
               info = -2;
 
               if (sing_handler)
                 sing_handler (rcon);
               else
                 (*current_liboctave_error_handler)
                   ("matrix singular to machine precision");
 
               mattype.mark_as_rectangular ();
             }
-          else 
+          else
             {
               if (calc_cond)
                 {
-                  // Now calculate the condition number for 
+                  // Now calculate the condition number for
                   // non-singular matrix.
                   char job = '1';
                   F77_XFCN (dgecon, DGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                             nc, tmp_data, nr, anorm, 
+                                             nc, tmp_data, nr, anorm,
                                              rcon, pz, piz, info
                                              F77_CHAR_ARG_LEN (1)));
 
-                  if (info != 0) 
+                  if (info != 0)
                     info = -2;
 
                   volatile double rcond_plus_one = rcon + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
@@ -1925,17 +1925,17 @@ Matrix::solve (MatrixType &typ, const Ma
 Matrix
 Matrix::solve (MatrixType &typ, const Matrix& b, octave_idx_type& info) const
 {
   double rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 Matrix
-Matrix::solve (MatrixType &typ, const Matrix& b, octave_idx_type& info, 
+Matrix::solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
                double& rcon) const
 {
   return solve (typ, b, info, rcon, 0);
 }
 
 Matrix
 Matrix::solve (MatrixType &mattype, const Matrix& b, octave_idx_type& info,
                double& rcon, solve_singularity_handler sing_handler,
@@ -1976,17 +1976,17 @@ ComplexMatrix
 Matrix::solve (MatrixType &typ, const ComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 ComplexMatrix
-Matrix::solve (MatrixType &typ, const ComplexMatrix& b, 
+Matrix::solve (MatrixType &typ, const ComplexMatrix& b,
   octave_idx_type& info) const
 {
   double rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 ComplexMatrix
 Matrix::solve (MatrixType &typ, const ComplexMatrix& b, octave_idx_type& info,
@@ -2035,17 +2035,17 @@ Matrix::solve (MatrixType &typ, const Co
 ColumnVector
 Matrix::solve (MatrixType &typ, const ColumnVector& b) const
 {
   octave_idx_type info; double rcon;
   return solve (typ, b, info, rcon);
 }
 
 ColumnVector
-Matrix::solve (MatrixType &typ, const ColumnVector& b, 
+Matrix::solve (MatrixType &typ, const ColumnVector& b,
                octave_idx_type& info) const
 {
   double rcon;
   return solve (typ, b, info, rcon);
 }
 
 ColumnVector
 Matrix::solve (MatrixType &typ, const ColumnVector& b, octave_idx_type& info,
@@ -2066,33 +2066,33 @@ Matrix::solve (MatrixType &typ, const Co
 ComplexColumnVector
 Matrix::solve (MatrixType &typ, const ComplexColumnVector& b) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (typ, b);
 }
 
 ComplexColumnVector
-Matrix::solve (MatrixType &typ, const ComplexColumnVector& b, 
+Matrix::solve (MatrixType &typ, const ComplexColumnVector& b,
                octave_idx_type& info) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (typ, b, info);
 }
 
 ComplexColumnVector
-Matrix::solve (MatrixType &typ, const ComplexColumnVector& b, 
+Matrix::solve (MatrixType &typ, const ComplexColumnVector& b,
                octave_idx_type& info, double& rcon) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (typ, b, info, rcon);
 }
 
 ComplexColumnVector
-Matrix::solve (MatrixType &typ, const ComplexColumnVector& b, 
+Matrix::solve (MatrixType &typ, const ComplexColumnVector& b,
                octave_idx_type& info, double& rcon,
                solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve(typ, b, info, rcon, sing_handler, transt);
 }
 
 Matrix
@@ -2353,17 +2353,17 @@ Matrix::lssolve (const Matrix& b, octave
             work(0) = lworkaround;
         }
 
       lwork = static_cast<octave_idx_type> (work(0));
       work.resize (dim_vector (lwork, 1));
 
       F77_XFCN (dgelsd, DGELSD, (m, n, nrhs, tmp_data, m, pretval,
                                  maxmn, ps, rcon, rank,
-                                 work.fortran_vec (), lwork, 
+                                 work.fortran_vec (), lwork,
                                  piwork, info));
 
       if (s.elem (0) == 0.0)
         rcon = 0.0;
       else
         rcon = s.elem (minmn - 1) / s.elem (0);
 
       retval.resize (n, nrhs);
@@ -2387,26 +2387,26 @@ Matrix::lssolve (const ComplexMatrix& b,
 {
   ComplexMatrix tmp (*this);
   octave_idx_type rank;
   double rcon;
   return tmp.lssolve (b, info, rank, rcon);
 }
 
 ComplexMatrix
-Matrix::lssolve (const ComplexMatrix& b, octave_idx_type& info, 
+Matrix::lssolve (const ComplexMatrix& b, octave_idx_type& info,
                  octave_idx_type& rank) const
 {
   ComplexMatrix tmp (*this);
   double rcon;
   return tmp.lssolve (b, info, rank, rcon);
 }
 
 ComplexMatrix
-Matrix::lssolve (const ComplexMatrix& b, octave_idx_type& info, 
+Matrix::lssolve (const ComplexMatrix& b, octave_idx_type& info,
                  octave_idx_type& rank, double& rcon) const
 {
   ComplexMatrix tmp (*this);
   return tmp.lssolve (b, info, rank, rcon);
 }
 
 ColumnVector
 Matrix::lssolve (const ColumnVector& b) const
@@ -2449,17 +2449,17 @@ Matrix::lssolve (const ColumnVector& b, 
       ("matrix dimension mismatch solution of linear equations");
   else if (m == 0 || n == 0)
     retval = ColumnVector (n, 0.0);
   else
     {
       volatile octave_idx_type minmn = (m < n ? m : n);
       octave_idx_type maxmn = m > n ? m : n;
       rcon = -1.0;
- 
+
       if (m != n)
         {
           retval = ColumnVector (maxmn, 0.0);
 
           for (octave_idx_type i = 0; i < m; i++)
             retval.elem (i) = b.elem (i);
         }
       else
@@ -2507,17 +2507,17 @@ Matrix::lssolve (const ColumnVector& b, 
                                  ps, rcon, rank, work.fortran_vec (),
                                  lwork, piwork, info));
 
       lwork = static_cast<octave_idx_type> (work(0));
       work.resize (dim_vector (lwork, 1));
 
       F77_XFCN (dgelsd, DGELSD, (m, n, nrhs, tmp_data, m, pretval,
                                  maxmn, ps, rcon, rank,
-                                 work.fortran_vec (), lwork, 
+                                 work.fortran_vec (), lwork,
                                  piwork, info));
 
       if (rank < minmn)
         {
           if (s.elem (0) == 0.0)
             rcon = 0.0;
           else
             rcon = s.elem (minmn - 1) / s.elem (0);
@@ -2544,26 +2544,26 @@ Matrix::lssolve (const ComplexColumnVect
 {
   ComplexMatrix tmp (*this);
   octave_idx_type rank;
   double rcon;
   return tmp.lssolve (b, info, rank, rcon);
 }
 
 ComplexColumnVector
-Matrix::lssolve (const ComplexColumnVector& b, octave_idx_type& info, 
+Matrix::lssolve (const ComplexColumnVector& b, octave_idx_type& info,
                  octave_idx_type& rank) const
 {
   ComplexMatrix tmp (*this);
   double rcon;
   return tmp.lssolve (b, info, rank, rcon);
 }
 
 ComplexColumnVector
-Matrix::lssolve (const ComplexColumnVector& b, octave_idx_type& info, 
+Matrix::lssolve (const ComplexColumnVector& b, octave_idx_type& info,
                  octave_idx_type& rank, double &rcon) const
 {
   ComplexMatrix tmp (*this);
   return tmp.lssolve (b, info, rank, rcon);
 }
 
 Matrix&
 Matrix::operator += (const DiagMatrix& a)
@@ -2628,17 +2628,17 @@ operator * (const ColumnVector& v, const
   octave_idx_type len = v.length ();
 
   if (len != 0)
     {
       octave_idx_type a_len = a.length ();
 
       retval = Matrix (len, a_len);
       double *c = retval.fortran_vec ();
-          
+
       F77_XFCN (dgemm, DGEMM, (F77_CONST_CHAR_ARG2 ("N", 1),
                                F77_CONST_CHAR_ARG2 ("N", 1),
                                len, a_len, 1, 1.0, v.data (), len,
                                a.data (), 1, 0.0, c, len
                                F77_CHAR_ARG_LEN (1)
                                F77_CHAR_ARG_LEN (1)));
     }
 
@@ -3058,27 +3058,27 @@ Sylvester (const Matrix& a, const Matrix
 
   // FIXME -- need to check that a, b, and c are all the same
   // size.
 
   // Compute Schur decompositions.
 
   SCHUR as (a, "U");
   SCHUR bs (b, "U");
-  
+
   // Transform c to new coordinates.
 
   Matrix ua = as.unitary_matrix ();
   Matrix sch_a = as.schur_matrix ();
 
   Matrix ub = bs.unitary_matrix ();
   Matrix sch_b = bs.schur_matrix ();
-  
+
   Matrix cx = ua.transpose () * c * ub;
-  
+
   // Solve the sylvester equation, back-transform, and return the
   // solution.
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type b_nr = b.rows ();
 
   double scale;
   octave_idx_type info;
@@ -3091,17 +3091,17 @@ Sylvester (const Matrix& a, const Matrix
                              F77_CONST_CHAR_ARG2 ("N", 1),
                              1, a_nr, b_nr, pa, a_nr, pb,
                              b_nr, px, a_nr, scale, info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
 
   // FIXME -- check info?
-  
+
   retval = -ua*cx*ub.transpose ();
 
   return retval;
 }
 
 // matrix by matrix -> matrix operations
 
 /* Simple Dot Product, Matrix-Vector and Matrix-Matrix Unit tests
@@ -3125,18 +3125,18 @@ Sylvester (const Matrix& a, const Matrix
 static inline char
 get_blas_trans_arg (bool trans)
 {
   return trans ? 'T' : 'N';
 }
 
 // the general GEMM operation
 
-Matrix 
-xgemm (const Matrix& a, const Matrix& b, 
+Matrix
+xgemm (const Matrix& a, const Matrix& b,
        blas_trans_type transa, blas_trans_type transb)
 {
   Matrix retval;
 
   bool tra = transa != blas_no_trans, trb = transb != blas_no_trans;
 
   octave_idx_type a_nr = tra ? a.cols () : a.rows ();
   octave_idx_type a_nc = tra ? a.rows () : a.cols ();
@@ -3357,18 +3357,18 @@ max (const Matrix& a, const Matrix& b)
       {
         octave_quit ();
         result (i, j) = xmax (a (i, j), b (i, j));
       }
 
   return result;
 }
 
-Matrix linspace (const ColumnVector& x1, 
-                 const ColumnVector& x2, 
+Matrix linspace (const ColumnVector& x1,
+                 const ColumnVector& x2,
                  octave_idx_type n)
 
 {
   if (n < 1) n = 1;
 
   octave_idx_type m = x1.length ();
 
   if (x2.length () != m)
@@ -3376,17 +3376,17 @@ Matrix linspace (const ColumnVector& x1,
 
   NoAlias<Matrix> retval;
 
   retval.clear (m, n);
   for (octave_idx_type i = 0; i < m; i++)
     retval(i, 0) = x1(i);
 
   // The last column is not needed while using delta.
-  double *delta = &retval(0, n-1); 
+  double *delta = &retval(0, n-1);
   for (octave_idx_type i = 0; i < m; i++)
     delta[i] = (x2(i) - x1(i)) / (n - 1);
 
   for (octave_idx_type j = 1; j < n-1; j++)
     for (octave_idx_type i = 0; i < m; i++)
       retval(i, j) = x1(i) + j*delta[i];
 
   for (octave_idx_type i = 0; i < m; i++)
diff --git a/liboctave/dMatrix.h b/liboctave/dMatrix.h
--- a/liboctave/dMatrix.h
+++ b/liboctave/dMatrix.h
@@ -127,20 +127,20 @@ public:
 
   void resize (octave_idx_type nr, octave_idx_type nc,
                double rfv = resize_fill_value ())
   {
     MArray<double>::resize (dim_vector (nr, nc), rfv);
   }
 
 private:
-  Matrix tinverse (MatrixType &mattype, octave_idx_type& info, double& rcon, 
+  Matrix tinverse (MatrixType &mattype, octave_idx_type& info, double& rcon,
                    int force, int calc_cond) const;
 
-  Matrix finverse (MatrixType &mattype, octave_idx_type& info, double& rcon, 
+  Matrix finverse (MatrixType &mattype, octave_idx_type& info, double& rcon,
                    int force, int calc_cond) const;
 
 public:
   Matrix inverse (void) const;
   Matrix inverse (octave_idx_type& info) const;
   Matrix inverse (octave_idx_type& info, double& rcon, int force = 0,
                   int calc_cond = 1) const;
 
@@ -155,17 +155,17 @@ public:
   ComplexMatrix ifourier (void) const;
 
   ComplexMatrix fourier2d (void) const;
   ComplexMatrix ifourier2d (void) const;
 
   DET determinant (void) const;
   DET determinant (octave_idx_type& info) const;
   DET determinant (octave_idx_type& info, double& rcon, int calc_cond = 1) const;
-  DET determinant (MatrixType &mattype, octave_idx_type& info, 
+  DET determinant (MatrixType &mattype, octave_idx_type& info,
                    double& rcon, int calc_cond = 1) const;
 
   double rcond (void) const;
   double rcond (MatrixType &mattype) const;
 
 private:
   // Upper triangular matrix solvers
   Matrix utsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
@@ -181,90 +181,90 @@ private:
   Matrix fsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
                  double& rcon, solve_singularity_handler sing_handler,
                  bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
   Matrix solve (MatrixType &typ, const Matrix& b) const;
   Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info) const;
-  Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info, 
+  Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
                 double& rcon) const;
   Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
                 double& rcon, solve_singularity_handler sing_handler,
                 bool singular_fallback = true, blas_trans_type transt = blas_no_trans) const;
 
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b) const;
-  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
+  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b,
                        octave_idx_type& info) const;
-  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
+  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b,
                        octave_idx_type& info, double& rcon) const;
-  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
+  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b,
                        octave_idx_type& info, double& rcon,
                        solve_singularity_handler sing_handler,
-                       bool singular_fallback = true, 
+                       bool singular_fallback = true,
                        blas_trans_type transt = blas_no_trans) const;
 
   ColumnVector solve (MatrixType &typ, const ColumnVector& b) const;
-  ColumnVector solve (MatrixType &typ, const ColumnVector& b, 
+  ColumnVector solve (MatrixType &typ, const ColumnVector& b,
                       octave_idx_type& info) const;
-  ColumnVector solve (MatrixType &typ, const ColumnVector& b, 
+  ColumnVector solve (MatrixType &typ, const ColumnVector& b,
                       octave_idx_type& info, double& rcon) const;
-  ColumnVector solve (MatrixType &typ, const ColumnVector& b, 
+  ColumnVector solve (MatrixType &typ, const ColumnVector& b,
                       octave_idx_type& info, double& rcon,
-                      solve_singularity_handler sing_handler, 
+                      solve_singularity_handler sing_handler,
                       blas_trans_type transt = blas_no_trans) const;
 
-  ComplexColumnVector solve (MatrixType &typ, 
+  ComplexColumnVector solve (MatrixType &typ,
                              const ComplexColumnVector& b) const;
-  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b, 
+  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b,
                              octave_idx_type& info) const;
-  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b, 
+  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b,
                              octave_idx_type& info, double& rcon) const;
-  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b, 
+  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b,
                              octave_idx_type& info, double& rcon,
-                             solve_singularity_handler sing_handler, 
+                             solve_singularity_handler sing_handler,
                              blas_trans_type transt = blas_no_trans) const;
 
   // Generic interface to solver with probing of type
   Matrix solve (const Matrix& b) const;
   Matrix solve (const Matrix& b, octave_idx_type& info) const;
   Matrix solve (const Matrix& b, octave_idx_type& info, double& rcon) const;
   Matrix solve (const Matrix& b, octave_idx_type& info, double& rcon,
-                solve_singularity_handler sing_handler, 
+                solve_singularity_handler sing_handler,
                 blas_trans_type transt = blas_no_trans) const;
 
   ComplexMatrix solve (const ComplexMatrix& b) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, double& rcon) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, double& rcon,
-                       solve_singularity_handler sing_handler, 
+                       solve_singularity_handler sing_handler,
                        blas_trans_type transt = blas_no_trans) const;
 
   ColumnVector solve (const ColumnVector& b) const;
   ColumnVector solve (const ColumnVector& b, octave_idx_type& info) const;
   ColumnVector solve (const ColumnVector& b, octave_idx_type& info, double& rcon) const;
   ColumnVector solve (const ColumnVector& b, octave_idx_type& info, double& rcon,
-                      solve_singularity_handler sing_handler, 
+                      solve_singularity_handler sing_handler,
                       blas_trans_type transt = blas_no_trans) const;
 
   ComplexColumnVector solve (const ComplexColumnVector& b) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
                              double& rcon) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
-                             double& rcon, solve_singularity_handler sing_handler, 
+                             double& rcon, solve_singularity_handler sing_handler,
                              blas_trans_type transt = blas_no_trans) const;
 
   // Singular solvers
   Matrix lssolve (const Matrix& b) const;
   Matrix lssolve (const Matrix& b, octave_idx_type& info) const;
-  Matrix lssolve (const Matrix& b, octave_idx_type& info, 
+  Matrix lssolve (const Matrix& b, octave_idx_type& info,
                   octave_idx_type& rank) const;
-  Matrix lssolve (const Matrix& b, octave_idx_type& info, 
+  Matrix lssolve (const Matrix& b, octave_idx_type& info,
                   octave_idx_type& rank, double& rcon) const;
 
   ComplexMatrix lssolve (const ComplexMatrix& b) const;
   ComplexMatrix lssolve (const ComplexMatrix& b, octave_idx_type& info) const;
   ComplexMatrix lssolve (const ComplexMatrix& b, octave_idx_type& info,
                          octave_idx_type& rank) const;
   ComplexMatrix lssolve (const ComplexMatrix& b, octave_idx_type& info,
                          octave_idx_type& rank, double &rcon) const;
@@ -272,22 +272,22 @@ public:
   ColumnVector lssolve (const ColumnVector& b) const;
   ColumnVector lssolve (const ColumnVector& b, octave_idx_type& info) const;
   ColumnVector lssolve (const ColumnVector& b, octave_idx_type& info,
                         octave_idx_type& rank) const;
   ColumnVector lssolve (const ColumnVector& b, octave_idx_type& info,
                         octave_idx_type& rank, double& rcon) const;
 
   ComplexColumnVector lssolve (const ComplexColumnVector& b) const;
-  ComplexColumnVector lssolve (const ComplexColumnVector& b, 
+  ComplexColumnVector lssolve (const ComplexColumnVector& b,
                                octave_idx_type& info) const;
   ComplexColumnVector lssolve (const ComplexColumnVector& b,
                                octave_idx_type& info,
                                octave_idx_type& rank) const;
-  ComplexColumnVector lssolve (const ComplexColumnVector& b, 
+  ComplexColumnVector lssolve (const ComplexColumnVector& b,
                                octave_idx_type& info,
                                octave_idx_type& rank, double& rcon) const;
 
   Matrix& operator += (const DiagMatrix& a);
   Matrix& operator -= (const DiagMatrix& a);
 
   // unary operations
 
@@ -297,17 +297,17 @@ public:
 
   bool any_element_is_negative (bool = false) const;
   bool any_element_is_nan (void) const;
   bool any_element_is_inf_or_nan (void) const;
   bool any_element_not_one_or_zero (void) const;
   bool all_elements_are_int_or_inf_or_nan (void) const;
   bool all_integers (double& max_val, double& min_val) const;
   bool too_large_for_float (void) const;
- 
+
   boolMatrix all (int dim = -1) const;
   boolMatrix any (int dim = -1) const;
 
   Matrix cumprod (int dim = -1) const;
   Matrix cumsum (int dim = -1) const;
   Matrix prod (int dim = -1) const;
   Matrix sum (int dim = -1) const;
   Matrix sumsq (int dim = -1) const;
@@ -346,31 +346,31 @@ extern OCTAVE_API Matrix operator * (con
 
 // Other functions.
 
 extern OCTAVE_API Matrix Givens (double, double);
 
 extern OCTAVE_API Matrix Sylvester (const Matrix&, const Matrix&, const Matrix&);
 
 extern OCTAVE_API Matrix xgemm (const Matrix& a, const Matrix& b,
-                                blas_trans_type transa = blas_no_trans, 
+                                blas_trans_type transa = blas_no_trans,
                                 blas_trans_type transb = blas_no_trans);
 
 extern OCTAVE_API Matrix operator * (const Matrix& a, const Matrix& b);
 
 extern OCTAVE_API Matrix min (double d, const Matrix& m);
 extern OCTAVE_API Matrix min (const Matrix& m, double d);
 extern OCTAVE_API Matrix min (const Matrix& a, const Matrix& b);
 
 extern OCTAVE_API Matrix max (double d, const Matrix& m);
 extern OCTAVE_API Matrix max (const Matrix& m, double d);
 extern OCTAVE_API Matrix max (const Matrix& a, const Matrix& b);
 
-extern OCTAVE_API Matrix linspace (const ColumnVector& x1, 
-                                   const ColumnVector& x2, 
+extern OCTAVE_API Matrix linspace (const ColumnVector& x1,
+                                   const ColumnVector& x2,
                                    octave_idx_type n);
 
 MS_CMP_OP_DECLS (Matrix, double, OCTAVE_API)
 MS_BOOL_OP_DECLS (Matrix, double, OCTAVE_API)
 
 SM_CMP_OP_DECLS (double, Matrix, OCTAVE_API)
 SM_BOOL_OP_DECLS (double, Matrix, OCTAVE_API)
 
diff --git a/liboctave/dNDArray.cc b/liboctave/dNDArray.cc
--- a/liboctave/dNDArray.cc
+++ b/liboctave/dNDArray.cc
@@ -52,17 +52,17 @@ NDArray::NDArray (const Array<octave_idx
   double *ptmp = fortran_vec ();
   if (negative_to_nan)
     {
       double nan_val = lo_ieee_nan_value ();
 
       if (zero_based)
         for (octave_idx_type i = 0; i < a.numel (); i++)
           {
-            double val = static_cast<double> 
+            double val = static_cast<double>
               (pa[i] + static_cast<octave_idx_type> (1));
             if (val <= 0)
               ptmp[i] = nan_val;
             else
               ptmp[i] = val;
           }
       else
         for (octave_idx_type i = 0; i < a.numel (); i++)
@@ -73,17 +73,17 @@ NDArray::NDArray (const Array<octave_idx
             else
               ptmp[i] = val;
           }
     }
   else
     {
       if (zero_based)
         for (octave_idx_type i = 0; i < a.numel (); i++)
-          ptmp[i] = static_cast<double> 
+          ptmp[i] = static_cast<double>
             (pa[i] + static_cast<octave_idx_type> (1));
       else
         for (octave_idx_type i = 0; i < a.numel (); i++)
           ptmp[i] = static_cast<double> (pa[i]);
     }
 }
 
 NDArray::NDArray (const charNDArray& a)
@@ -116,17 +116,17 @@ NDArray::fourier (int dim) const
   octave_idx_type dist = (stride == 1 ? n : 1);
 
   const double *in (fortran_vec ());
   ComplexNDArray retval (dv);
   Complex *out (retval.fortran_vec ());
 
   // Need to be careful here about the distance between fft's
   for (octave_idx_type k = 0; k < nloop; k++)
-    octave_fftw::fft (in + k * stride * n, out + k * stride * n, 
+    octave_fftw::fft (in + k * stride * n, out + k * stride * n,
                       n, howmany, stride, dist);
 
   return retval;
 }
 
 ComplexNDArray
 NDArray::ifourier (int dim) const
 {
@@ -146,17 +146,17 @@ NDArray::ifourier (int dim) const
   octave_idx_type nloop = (stride == 1 ? 1 : numel () / dv (dim) / stride);
   octave_idx_type dist = (stride == 1 ? n : 1);
 
   ComplexNDArray retval (*this);
   Complex *out (retval.fortran_vec ());
 
   // Need to be careful here about the distance between fft's
   for (octave_idx_type k = 0; k < nloop; k++)
-    octave_fftw::ifft (out + k * stride * n, out + k * stride * n, 
+    octave_fftw::ifft (out + k * stride * n, out + k * stride * n,
                       n, howmany, stride, dist);
 
   return retval;
 }
 
 ComplexNDArray
 NDArray::fourier2d (void) const
 {
@@ -328,17 +328,17 @@ NDArray::ifourier (int dim) const
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
             tmp[i] = elem((i + k*npts)*stride + j*dist);
 
           F77_FUNC (zfftb, ZFFTB) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
-            retval ((i + k*npts)*stride + j*dist) = tmp[i] / 
+            retval ((i + k*npts)*stride + j*dist) = tmp[i] /
               static_cast<double> (npts);
         }
     }
 
   return retval;
 }
 
 ComplexNDArray
@@ -355,17 +355,17 @@ NDArray::fourier2d (void) const
       octave_idx_type npts = dv2(i);
       octave_idx_type nn = 4*npts+15;
       Array<Complex> wsave (nn);
       Complex *pwsave = wsave.fortran_vec ();
       Array<Complex> row (npts);
       Complex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany : 
+      howmany = (stride == 1 ? howmany :
                  (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
@@ -403,17 +403,17 @@ NDArray::ifourier2d (void) const
       octave_idx_type npts = dv2(i);
       octave_idx_type nn = 4*npts+15;
       Array<Complex> wsave (nn);
       Complex *pwsave = wsave.fortran_vec ();
       Array<Complex> row (npts);
       Complex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany : 
+      howmany = (stride == 1 ? howmany :
                  (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
@@ -422,17 +422,17 @@ NDArray::ifourier2d (void) const
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
                 prow[l] = retval ((l + k*npts)*stride + j*dist);
 
               F77_FUNC (zfftb, ZFFTB) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval ((l + k*npts)*stride + j*dist) = prow[l] / 
+                retval ((l + k*npts)*stride + j*dist) = prow[l] /
                   static_cast<double> (npts);
             }
         }
 
       stride *= dv2(i);
     }
 
   return retval;
@@ -451,17 +451,17 @@ NDArray::fourierNd (void) const
       octave_idx_type npts = dv(i);
       octave_idx_type nn = 4*npts+15;
       Array<Complex> wsave (nn);
       Complex *pwsave = wsave.fortran_vec ();
       Array<Complex> row (npts);
       Complex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany : 
+      howmany = (stride == 1 ? howmany :
                  (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
@@ -498,17 +498,17 @@ NDArray::ifourierNd (void) const
       octave_idx_type npts = dv(i);
       octave_idx_type nn = 4*npts+15;
       Array<Complex> wsave (nn);
       Complex *pwsave = wsave.fortran_vec ();
       Array<Complex> row (npts);
       Complex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany : 
+      howmany = (stride == 1 ? howmany :
                  (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (zffti, ZFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
@@ -918,10 +918,10 @@ SND_BOOL_OPS (double, NDArray)
 
 NDND_CMP_OPS (NDArray, NDArray)
 NDND_BOOL_OPS (NDArray, NDArray)
 
 BSXFUN_STDOP_DEFS_MXLOOP (NDArray)
 BSXFUN_STDREL_DEFS_MXLOOP (NDArray)
 
 BSXFUN_OP_DEF_MXLOOP (pow, NDArray, mx_inline_pow)
-BSXFUN_OP2_DEF_MXLOOP (pow, ComplexNDArray, ComplexNDArray, 
+BSXFUN_OP2_DEF_MXLOOP (pow, ComplexNDArray, ComplexNDArray,
                        NDArray, mx_inline_pow)
diff --git a/liboctave/dNDArray.h b/liboctave/dNDArray.h
--- a/liboctave/dNDArray.h
+++ b/liboctave/dNDArray.h
@@ -40,34 +40,34 @@ public:
   typedef Matrix matrix_type;
 
   NDArray (void) : MArray<double> () { }
 
   NDArray (const dim_vector& dv) : MArray<double> (dv) { }
 
   NDArray (const dim_vector& dv, double val)
     : MArray<double> (dv, val) { }
-  
+
   NDArray (const NDArray& a) : MArray<double> (a) { }
 
   NDArray (const Matrix& a) : MArray<double> (a) { }
 
-  NDArray (const Array<octave_idx_type>& a, bool zero_based = false, 
+  NDArray (const Array<octave_idx_type>& a, bool zero_based = false,
            bool negative_to_nan = false);
 
   template <class U>
   NDArray (const MArray<U>& a) : MArray<double> (a) { }
 
   template <class U>
   NDArray (const Array<U>& a) : MArray<double> (a) { }
 
   template <class U>
   explicit NDArray (const intNDArray<U>& a) : MArray<double> (a) { }
 
-  NDArray (const charNDArray&); 
+  NDArray (const charNDArray&);
 
   NDArray& operator = (const NDArray& a)
     {
       MArray<double>::operator = (a);
       return *this;
     }
 
   // unary operations
@@ -87,28 +87,28 @@ public:
   // FIXME -- this is not quite the right thing.
 
   boolNDArray all (int dim = -1) const;
   boolNDArray any (int dim = -1) const;
 
   NDArray cumprod (int dim = -1) const;
   NDArray cumsum (int dim = -1) const;
   NDArray prod (int dim = -1) const;
-  NDArray sum (int dim = -1) const;  
-  NDArray xsum (int dim = -1) const;  
+  NDArray sum (int dim = -1) const;
+  NDArray xsum (int dim = -1) const;
   NDArray sumsq (int dim = -1) const;
   NDArray concat (const NDArray& rb, const Array<octave_idx_type>& ra_idx);
   ComplexNDArray concat (const ComplexNDArray& rb, const Array<octave_idx_type>& ra_idx);
   charNDArray concat (const charNDArray& rb, const Array<octave_idx_type>& ra_idx);
 
   NDArray max (int dim = -1) const;
   NDArray max (Array<octave_idx_type>& index, int dim = -1) const;
   NDArray min (int dim = -1) const;
   NDArray min (Array<octave_idx_type>& index, int dim = -1) const;
-  
+
   NDArray cummax (int dim = -1) const;
   NDArray cummax (Array<octave_idx_type>& index, int dim = -1) const;
   NDArray cummin (int dim = -1) const;
   NDArray cummin (Array<octave_idx_type>& index, int dim = -1) const;
 
   NDArray diff (octave_idx_type order = 1, int dim = -1) const;
 
   NDArray& insert (const NDArray& a, octave_idx_type r, octave_idx_type c);
@@ -148,20 +148,20 @@ public:
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const NDArray& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, NDArray& a);
 
   static double resize_fill_value (void) { return 0; }
 
   NDArray diag (octave_idx_type k = 0) const;
 
-  NDArray& changesign (void) 
-    { 
-      MArray<double>::changesign (); 
-      return *this; 
+  NDArray& changesign (void)
+    {
+      MArray<double>::changesign ();
+      return *this;
     }
 
 };
 
 // Publish externally used friend functions.
 
 extern OCTAVE_API NDArray real (const ComplexNDArray& a);
 extern OCTAVE_API NDArray imag (const ComplexNDArray& a);
@@ -178,12 +178,12 @@ NDND_CMP_OP_DECLS (NDArray, NDArray, OCT
 NDND_BOOL_OP_DECLS (NDArray, NDArray, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArray, NDArray, double)
 
 BSXFUN_STDOP_DECLS (NDArray, OCTAVE_API)
 BSXFUN_STDREL_DECLS (NDArray, OCTAVE_API)
 
 BSXFUN_OP_DECL (pow, NDArray, OCTAVE_API)
-BSXFUN_OP2_DECL (pow, ComplexNDArray, ComplexNDArray, 
+BSXFUN_OP2_DECL (pow, ComplexNDArray, ComplexNDArray,
                  NDArray, OCTAVE_API)
 
 #endif
diff --git a/liboctave/dSparse.cc b/liboctave/dSparse.cc
--- a/liboctave/dSparse.cc
+++ b/liboctave/dSparse.cc
@@ -179,17 +179,17 @@ SparseMatrix::SparseMatrix (const DiagMa
   for (octave_idx_type i = l; i <= a.cols (); i++)
     cidx(i) = j;
 }
 
 SparseMatrix::SparseMatrix (const PermMatrix& a)
   : MSparse<double> (a.rows (), a.cols (), a.rows ())
 {
   octave_idx_type n = a.rows ();
-  for (octave_idx_type i = 0; i <= n; i++) 
+  for (octave_idx_type i = 0; i <= n; i++)
     cidx (i) = i;
   const Array<octave_idx_type> pv = a.pvec ();
 
   if (a.is_row_perm ())
     {
       for (octave_idx_type i = 0; i < n; i++)
         ridx (pv (i)) = i;
     }
@@ -297,17 +297,17 @@ SparseMatrix::max (int dim) const
 SparseMatrix
 SparseMatrix::max (Array<octave_idx_type>& idx_arg, int dim) const
 {
   SparseMatrix result;
   dim_vector dv = dims ();
 
   if (dv.numel () == 0 || dim >= dv.length ())
     return result;
- 
+
   if (dim < 0)
     dim = dv.first_non_singleton ();
 
   octave_idx_type nr = dv(0);
   octave_idx_type nc = dv(1);
 
   if (dim == 0)
     {
@@ -377,17 +377,17 @@ SparseMatrix::max (Array<octave_idx_type
               continue;
             bool found = false;
             for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
               if (ridx(k) == i)
                 {
                   found = true;
                   break;
                 }
-            
+
             if (!found)
               idx_arg.elem(i) = j;
 
           }
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
@@ -446,17 +446,17 @@ SparseMatrix::min (int dim) const
 SparseMatrix
 SparseMatrix::min (Array<octave_idx_type>& idx_arg, int dim) const
 {
   SparseMatrix result;
   dim_vector dv = dims ();
 
   if (dv.numel () == 0 || dim >= dv.length ())
     return result;
- 
+
   if (dim < 0)
     dim = dv.first_non_singleton ();
 
   octave_idx_type nr = dv(0);
   octave_idx_type nc = dv(1);
 
   if (dim == 0)
     {
@@ -526,17 +526,17 @@ SparseMatrix::min (Array<octave_idx_type
               continue;
             bool found = false;
             for (octave_idx_type k = cidx(j); k < cidx(j+1); k++)
               if (ridx(k) == i)
                 {
                   found = true;
                   break;
                 }
-            
+
             if (!found)
               idx_arg.elem(i) = j;
 
           }
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
@@ -580,17 +580,17 @@ SparseMatrix::min (Array<octave_idx_type
                 }
             }
         }
     }
 
   return result;
 }
 
-RowVector 
+RowVector
 SparseMatrix::row (octave_idx_type i) const
 {
   octave_idx_type nc = columns ();
   RowVector retval (nc, 0);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type k = cidx (j); k < cidx (j+1); k++)
       {
@@ -599,17 +599,17 @@ SparseMatrix::row (octave_idx_type i) co
             retval(j) = data (k);
             break;
           }
       }
 
   return retval;
 }
 
-ColumnVector 
+ColumnVector
 SparseMatrix::column (octave_idx_type i) const
 {
   octave_idx_type nr = rows ();
   ColumnVector retval (nr);
 
   for (octave_idx_type k = cidx (i); k < cidx (i+1); k++)
     retval(ridx (k)) = data (k);
 
@@ -669,17 +669,17 @@ imag (const SparseComplexMatrix& a)
     {
       r.data(i) = std::imag (a.data(i));
       r.ridx(i) = a.ridx(i);
     }
 
   return r;
 }
 
-SparseMatrix 
+SparseMatrix
 atan2 (const double& x, const SparseMatrix& y)
 {
   octave_idx_type nr = y.rows ();
   octave_idx_type nc = y.cols ();
 
   if (x == 0.)
     return SparseMatrix (nr, nc);
   else
@@ -691,17 +691,17 @@ atan2 (const double& x, const SparseMatr
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = y.cidx (j); i < y.cidx (j+1); i++)
           tmp.elem (y.ridx(i), j) = atan2 (x, y.data(i));
 
       return SparseMatrix (tmp);
     }
 }
 
-SparseMatrix 
+SparseMatrix
 atan2 (const SparseMatrix& x, const double& y)
 {
   octave_idx_type nr = x.rows ();
   octave_idx_type nc = x.cols ();
   octave_idx_type nz = x.nnz ();
 
   SparseMatrix retval (nr, nc, nz);
 
@@ -732,47 +732,47 @@ atan2 (const SparseMatrix& x, const doub
           retval2.xridx (i) = retval.ridx (i);
         }
       return retval2;
     }
   else
     return retval;
 }
 
-SparseMatrix 
+SparseMatrix
 atan2 (const SparseMatrix& x, const SparseMatrix& y)
 {
   SparseMatrix r;
 
-  if ((x.rows() == y.rows()) && (x.cols() == y.cols())) 
+  if ((x.rows() == y.rows()) && (x.cols() == y.cols()))
     {
       octave_idx_type x_nr = x.rows ();
       octave_idx_type x_nc = x.cols ();
 
       octave_idx_type y_nr = y.rows ();
       octave_idx_type y_nc = y.cols ();
 
       if (x_nr != y_nr || x_nc != y_nc)
         gripe_nonconformant ("atan2", x_nr, x_nc, y_nr, y_nc);
       else
         {
           r = SparseMatrix (x_nr, x_nc, (x.nnz () + y.nnz ()));
-       
+
           octave_idx_type jx = 0;
           r.cidx (0) = 0;
           for (octave_idx_type i = 0 ; i < x_nc ; i++)
             {
               octave_idx_type  ja = x.cidx(i);
               octave_idx_type  ja_max = x.cidx(i+1);
               bool ja_lt_max= ja < ja_max;
-           
+
               octave_idx_type  jb = y.cidx(i);
               octave_idx_type  jb_max = y.cidx(i+1);
               bool jb_lt_max = jb < jb_max;
-           
+
               while (ja_lt_max || jb_lt_max )
                 {
                   octave_quit ();
                   if ((! jb_lt_max) ||
                       (ja_lt_max && (x.ridx(ja) < y.ridx(jb))))
                     {
                       r.ridx(jx) = x.ridx(ja);
                       r.data(jx) = atan2 (x.data(ja), 0.);
@@ -798,17 +798,17 @@ atan2 (const SparseMatrix& x, const Spar
                       ja++;
                       ja_lt_max= ja < ja_max;
                       jb++;
                       jb_lt_max= jb < jb_max;
                     }
                 }
               r.cidx(i+1) = jx;
             }
-          
+
           r.maybe_compress ();
         }
     }
   else
     (*current_liboctave_error_handler) ("matrix size mismatch");
 
   return r;
 }
@@ -832,19 +832,19 @@ SparseMatrix::inverse (MatrixType& matty
 
 SparseMatrix
 SparseMatrix::inverse (MatrixType& mattype, octave_idx_type& info) const
 {
   double rcond;
   return inverse (mattype, info, rcond, 0, 0);
 }
 
-SparseMatrix 
-SparseMatrix::dinverse (MatrixType &mattyp, octave_idx_type& info, 
-                        double& rcond, const bool, 
+SparseMatrix
+SparseMatrix::dinverse (MatrixType &mattyp, octave_idx_type& info,
+                        double& rcond, const bool,
                         const bool calccond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   info = 0;
 
@@ -858,23 +858,23 @@ SparseMatrix::dinverse (MatrixType &matt
 
       if (typ == MatrixType::Diagonal ||
           typ == MatrixType::Permuted_Diagonal)
         {
           if (typ == MatrixType::Permuted_Diagonal)
             retval = transpose();
           else
             retval = *this;
-              
+
           // Force make_unique to be called
           double *v = retval.data();
 
           if (calccond)
             {
-              double dmax = 0., dmin = octave_Inf; 
+              double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nr; i++)
                 {
                   double tmp = fabs(v[i]);
                   if (tmp > dmax)
                     dmax = tmp;
                   if (tmp < dmin)
                     dmin = tmp;
                 }
@@ -886,36 +886,36 @@ SparseMatrix::dinverse (MatrixType &matt
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
-SparseMatrix 
-SparseMatrix::tinverse (MatrixType &mattyp, octave_idx_type& info, 
-                        double& rcond, const bool, 
+SparseMatrix
+SparseMatrix::tinverse (MatrixType &mattyp, octave_idx_type& info,
+                        double& rcond, const bool,
                         const bool calccond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   info = 0;
 
   if (nr == 0 || nc == 0 || nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattyp.type ();
       mattyp.info ();
 
-      if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper || 
+      if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper ||
           typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
         {
           double anorm = 0.;
           double ainvnorm = 0.;
 
           if (calccond)
             {
               // Calculate the 1-norm of matrix for rcond calculation
@@ -936,72 +936,72 @@ SparseMatrix::tinverse (MatrixType &matt
               octave_idx_type nz2 = nz;
               retval = SparseMatrix (nr, nc, nz2);
 
               for (octave_idx_type i = 0; i < nr; i++)
                 {
                   octave_quit ();
                   // place the 1 in the identity position
                   octave_idx_type cx_colstart = cx;
-          
+
                   if (cx == nz2)
                     {
                       nz2 *= 2;
                       retval.change_capacity (nz2);
                     }
 
                   retval.xcidx(i) = cx;
                   retval.xridx(cx) = i;
                   retval.xdata(cx) = 1.0;
                   cx++;
 
                   // iterate accross columns of input matrix
-                  for (octave_idx_type j = i+1; j < nr; j++) 
+                  for (octave_idx_type j = i+1; j < nr; j++)
                     {
                       double v = 0.;
                       // iterate to calculate sum
                       octave_idx_type colXp = retval.xcidx(i);
                       octave_idx_type colUp = cidx(j);
                       octave_idx_type rpX, rpU;
 
                       if (cidx(j) == cidx(j+1))
                         {
-                          (*current_liboctave_error_handler) 
+                          (*current_liboctave_error_handler)
                             ("division by zero");
                           goto inverse_singular;
                         }
 
                       do
                         {
                           octave_quit ();
                           rpX = retval.xridx(colXp);
                           rpU = ridx(colUp);
 
-                          if (rpX < rpU) 
+                          if (rpX < rpU)
                             colXp++;
-                          else if (rpX > rpU) 
+                          else if (rpX > rpU)
                             colUp++;
-                          else 
+                          else
                             {
                               v -= retval.xdata(colXp) * data(colUp);
                               colXp++;
                               colUp++;
                             }
-                        } while ((rpX<j) && (rpU<j) && 
+                        } while ((rpX<j) && (rpU<j) &&
                                  (colXp<cx) && (colUp<nz));
 
                       // get A(m,m)
                       if (typ == MatrixType::Upper)
                         colUp = cidx(j+1) - 1;
                       else
                         colUp = cidx(j);
                       double pivot = data(colUp);
-                      if (pivot == 0. || ridx(colUp) != j) 
+                      if (pivot == 0. || ridx(colUp) != j)
                         {
-                          (*current_liboctave_error_handler) 
+                          (*current_liboctave_error_handler)
                             ("division by zero");
                           goto inverse_singular;
                         }
 
                       if (v != 0.)
                         {
                           if (cx == nz2)
                             {
@@ -1017,17 +1017,17 @@ SparseMatrix::tinverse (MatrixType &matt
 
                   // get A(m,m)
                   octave_idx_type colUp;
                   if (typ == MatrixType::Upper)
                     colUp = cidx(i+1) - 1;
                   else
                     colUp = cidx(i);
                   double pivot = data(colUp);
-                  if (pivot == 0. || ridx(colUp) != i) 
+                  if (pivot == 0. || ridx(colUp) != i)
                     {
                       (*current_liboctave_error_handler) ("division by zero");
                       goto inverse_singular;
                     }
 
                   if (pivot != 1.0)
                     for (octave_idx_type j = cx_colstart; j < cx; j++)
                       retval.xdata(j) /= pivot;
@@ -1066,37 +1066,37 @@ SparseMatrix::tinverse (MatrixType &matt
 
                   for (octave_idx_type j = 0; j < nr; j++)
                     work[j] = 0.;
 
                   // place the 1 in the identity position
                   work[iidx] = 1.0;
 
                   // iterate accross columns of input matrix
-                  for (octave_idx_type j = iidx+1; j < nr; j++) 
+                  for (octave_idx_type j = iidx+1; j < nr; j++)
                     {
                       double v = 0.;
                       octave_idx_type jidx = perm[j];
                       // iterate to calculate sum
-                      for (octave_idx_type k = cidx(jidx); 
+                      for (octave_idx_type k = cidx(jidx);
                            k < cidx(jidx+1); k++)
                         {
                           octave_quit ();
                           v -= work[ridx(k)] * data(k);
                         }
 
                       // get A(m,m)
                       double pivot;
                       if (typ == MatrixType::Permuted_Upper)
                         pivot = data(cidx(jidx+1) - 1);
                       else
                         pivot = data(cidx(jidx));
-                      if (pivot == 0.) 
+                      if (pivot == 0.)
                         {
-                          (*current_liboctave_error_handler) 
+                          (*current_liboctave_error_handler)
                             ("division by zero");
                           goto inverse_singular;
                         }
 
                       work[j] = v / pivot;
                     }
 
                   // get A(m,m)
@@ -1104,17 +1104,17 @@ SparseMatrix::tinverse (MatrixType &matt
                   if (typ == MatrixType::Permuted_Upper)
                     colUp = cidx(perm[iidx]+1) - 1;
                   else
                     colUp = cidx(perm[iidx]);
 
                   double pivot = data(colUp);
                   if (pivot == 0.)
                     {
-                      (*current_liboctave_error_handler) 
+                      (*current_liboctave_error_handler)
                         ("division by zero");
                       goto inverse_singular;
                     }
 
                   octave_idx_type new_cx = cx;
                   for (octave_idx_type j = iidx; j < nr; j++)
                     if (work[j] != 0.0)
                       {
@@ -1143,38 +1143,38 @@ SparseMatrix::tinverse (MatrixType &matt
             }
 
           if (calccond)
             {
               // Calculate the 1-norm of inverse matrix for rcond calculation
               for (octave_idx_type j = 0; j < nr; j++)
                 {
                   double atmp = 0.;
-                  for (octave_idx_type i = retval.cidx(j); 
+                  for (octave_idx_type i = retval.cidx(j);
                        i < retval.cidx(j+1); i++)
                     atmp += fabs(retval.data(i));
                   if (atmp > ainvnorm)
                     ainvnorm = atmp;
                 }
 
-              rcond = 1. / ainvnorm / anorm;     
+              rcond = 1. / ainvnorm / anorm;
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 
  inverse_singular:
   return SparseMatrix();
 }
 
 SparseMatrix
-SparseMatrix::inverse (MatrixType &mattype, octave_idx_type& info, 
+SparseMatrix::inverse (MatrixType &mattype, octave_idx_type& info,
                        double& rcond, int, int calc_cond) const
 {
   int typ = mattype.type (false);
   SparseMatrix ret;
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
@@ -1216,17 +1216,17 @@ SparseMatrix::inverse (MatrixType &matty
           ColumnVector Qinit(n);
           for (octave_idx_type i = 0; i < n; i++)
             Qinit(i) = i;
 
           MatrixType tmp_typ (MatrixType::Upper);
           SparseLU fact (*this, Qinit, Matrix(), false, false);
           rcond = fact.rcond();
           double rcond2;
-          SparseMatrix InvL = fact.L().transpose().tinverse(tmp_typ, 
+          SparseMatrix InvL = fact.L().transpose().tinverse(tmp_typ,
                                            info, rcond2, true, false);
           SparseMatrix InvU = fact.U().tinverse(tmp_typ, info, rcond2,
                                            true, false).transpose();
           ret = fact.Pc().transpose() * InvU * InvL * fact.Pr();
         }
     }
 
   return ret;
@@ -1280,57 +1280,57 @@ SparseMatrix::determinant (octave_idx_ty
           Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
         }
 
       // Set whether we are allowed to modify Q or not
       tmp = octave_sparse_params::get_key ("autoamd");
       if (!xisnan (tmp))
         Control (UMFPACK_FIXQ) = tmp;
 
-      // Turn-off UMFPACK scaling for LU 
+      // Turn-off UMFPACK scaling for LU
       Control (UMFPACK_SCALE) = UMFPACK_SCALE_NONE;
 
       UMFPACK_DNAME (report_control) (control);
 
       const octave_idx_type *Ap = cidx ();
       const octave_idx_type *Ai = ridx ();
       const double *Ax = data ();
 
       UMFPACK_DNAME (report_matrix) (nr, nc, Ap, Ai, Ax, 1, control);
 
       void *Symbolic;
       Matrix Info (1, UMFPACK_INFO);
       double *info = Info.fortran_vec ();
-      int status = UMFPACK_DNAME (qsymbolic) (nr, nc, Ap, Ai, 
+      int status = UMFPACK_DNAME (qsymbolic) (nr, nc, Ap, Ai,
                                          Ax, 0, &Symbolic, control, info);
 
       if (status < 0)
         {
-          (*current_liboctave_error_handler) 
+          (*current_liboctave_error_handler)
             ("SparseMatrix::determinant symbolic factorization failed");
 
           UMFPACK_DNAME (report_status) (control, status);
           UMFPACK_DNAME (report_info) (control, info);
 
           UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
         }
       else
         {
           UMFPACK_DNAME (report_symbolic) (Symbolic, control);
 
           void *Numeric;
-          status = UMFPACK_DNAME (numeric) (Ap, Ai, Ax, Symbolic, 
+          status = UMFPACK_DNAME (numeric) (Ap, Ai, Ax, Symbolic,
                                        &Numeric, control, info) ;
           UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
 
           rcond = Info (UMFPACK_RCOND);
 
           if (status < 0)
             {
-              (*current_liboctave_error_handler) 
+              (*current_liboctave_error_handler)
                 ("SparseMatrix::determinant numeric factorization failed");
 
               UMFPACK_DNAME (report_status) (control, status);
               UMFPACK_DNAME (report_info) (control, info);
 
               UMFPACK_DNAME (free_numeric) (&Numeric);
             }
           else
@@ -1338,19 +1338,19 @@ SparseMatrix::determinant (octave_idx_ty
               UMFPACK_DNAME (report_numeric) (Numeric, control);
 
               double c10, e10;
 
               status = UMFPACK_DNAME (get_determinant) (&c10, &e10, Numeric, info);
 
               if (status < 0)
                 {
-                  (*current_liboctave_error_handler) 
+                  (*current_liboctave_error_handler)
                     ("SparseMatrix::determinant error calculating determinant");
-                  
+
                   UMFPACK_DNAME (report_status) (control, status);
                   UMFPACK_DNAME (report_info) (control, info);
                 }
               else
                 retval = DET (c10, e10, 10);
 
               UMFPACK_DNAME (free_numeric) (&Numeric);
             }
@@ -1360,17 +1360,17 @@ SparseMatrix::determinant (octave_idx_ty
   (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 
   return retval;
 }
 
 Matrix
 SparseMatrix::dsolve (MatrixType &mattype, const Matrix& b, octave_idx_type& err,
-                      double& rcond, solve_singularity_handler, 
+                      double& rcond, solve_singularity_handler,
                       bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
@@ -1397,17 +1397,17 @@ SparseMatrix::dsolve (MatrixType &mattyp
           else
             for (octave_idx_type j = 0; j < b.cols(); j++)
               for (octave_idx_type k = 0; k < nc; k++)
                 for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
                   retval(k,j) = b(ridx(i),j) / data (i);
 
           if (calc_cond)
             {
-              double dmax = 0., dmin = octave_Inf; 
+              double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nm; i++)
                 {
                   double tmp = fabs(data(i));
                   if (tmp > dmax)
                     dmax = tmp;
                   if (tmp < dmin)
                     dmin = tmp;
                 }
@@ -1419,18 +1419,18 @@ SparseMatrix::dsolve (MatrixType &mattyp
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseMatrix
-SparseMatrix::dsolve (MatrixType &mattype, const SparseMatrix& b, 
-                      octave_idx_type& err, double& rcond, 
+SparseMatrix::dsolve (MatrixType &mattype, const SparseMatrix& b,
+                      octave_idx_type& err, double& rcond,
                       solve_singularity_handler, bool calc_cond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
@@ -1487,17 +1487,17 @@ SparseMatrix::dsolve (MatrixType &mattyp
                           retval.xdata (ii++) = b.data(k) / data (i);
                         }
                     }
                 retval.xcidx(j+1) = ii;
               }
 
           if (calc_cond)
             {
-              double dmax = 0., dmin = octave_Inf; 
+              double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nm; i++)
                 {
                   double tmp = fabs(data(i));
                   if (tmp > dmax)
                     dmax = tmp;
                   if (tmp < dmin)
                     dmin = tmp;
                 }
@@ -1544,20 +1544,20 @@ SparseMatrix::dsolve (MatrixType &mattyp
             for (octave_idx_type j = 0; j < b.cols(); j++)
                 for (octave_idx_type i = 0; i < nm; i++)
                   retval(i,j) = b(i,j) / data (i);
           else
             for (octave_idx_type j = 0; j < b.cols(); j++)
               for (octave_idx_type k = 0; k < nc; k++)
                 for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
                   retval(k,j) = b(ridx(i),j) / data (i);
-            
+
           if (calc_cond)
             {
-              double dmax = 0., dmin = octave_Inf; 
+              double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nm; i++)
                 {
                   double tmp = fabs(data(i));
                   if (tmp > dmax)
                     dmax = tmp;
                   if (tmp < dmin)
                     dmin = tmp;
                 }
@@ -1570,17 +1570,17 @@ SparseMatrix::dsolve (MatrixType &mattyp
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseMatrix::dsolve (MatrixType &mattype, const SparseComplexMatrix& b,
-                     octave_idx_type& err, double& rcond, 
+                     octave_idx_type& err, double& rcond,
                      solve_singularity_handler, bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
@@ -1634,20 +1634,20 @@ SparseMatrix::dsolve (MatrixType &mattyp
                       if (found)
                         {
                           retval.xridx (ii) = l;
                           retval.xdata (ii++) = b.data(k) / data (i);
                         }
                     }
                 retval.xcidx(j+1) = ii;
               }
-            
+
           if (calc_cond)
             {
-              double dmax = 0., dmin = octave_Inf; 
+              double dmax = 0., dmin = octave_Inf;
               for (octave_idx_type i = 0; i < nm; i++)
                 {
                   double tmp = fabs(data(i));
                   if (tmp > dmax)
                     dmax = tmp;
                   if (tmp < dmin)
                     dmin = tmp;
                 }
@@ -1661,17 +1661,17 @@ SparseMatrix::dsolve (MatrixType &mattyp
     }
 
   return retval;
 }
 
 Matrix
 SparseMatrix::utsolve (MatrixType &mattype, const Matrix& b,
                        octave_idx_type& err, double& rcond,
-                       solve_singularity_handler sing_handler, 
+                       solve_singularity_handler sing_handler,
                        bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
   err = 0;
@@ -1727,21 +1727,21 @@ SparseMatrix::utsolve (MatrixType &matty
 
                       if (work[k] != 0.)
                         {
                           if (ridx(cidx(kidx+1)-1) != k ||
                               data(cidx(kidx+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
-                            }                       
+                            }
 
                           double tmp = work[k] / data(cidx(kidx+1)-1);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(kidx); 
+                          for (octave_idx_type i = cidx(kidx);
                                i < cidx(kidx+1)-1; i++)
                             {
                               octave_idx_type iidx = ridx(i);
                               work[iidx] = work[iidx] - tmp * data(i);
                             }
                         }
                     }
 
@@ -1762,17 +1762,17 @@ SparseMatrix::utsolve (MatrixType &matty
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           octave_idx_type iidx = perm[k];
 
                           if (work[k] != 0.)
                             {
                               double tmp = work[k] / data(cidx(iidx+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(iidx); 
+                              for (octave_idx_type i = cidx(iidx);
                                    i < cidx(iidx+1)-1; i++)
                                 {
                                   octave_idx_type idx2 = ridx(i);
                                   work[idx2] = work[idx2] - tmp * data(i);
                                 }
                             }
                         }
                       double atmp = 0;
@@ -1803,17 +1803,17 @@ SparseMatrix::utsolve (MatrixType &matty
                     {
                       if (work[k] != 0.)
                         {
                           if (ridx(cidx(k+1)-1) != k ||
                               data(cidx(k+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
-                            }                       
+                            }
 
                           double tmp = work[k] / data(cidx(k+1)-1);
                           work[k] = tmp;
                           for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
                             {
                               octave_idx_type iidx = ridx(i);
                               work[iidx] = work[iidx] - tmp * data(i);
                             }
@@ -1895,17 +1895,17 @@ SparseMatrix::utsolve (MatrixType &matty
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseMatrix
 SparseMatrix::utsolve (MatrixType &mattype, const SparseMatrix& b,
-                       octave_idx_type& err, double& rcond, 
+                       octave_idx_type& err, double& rcond,
                        solve_singularity_handler sing_handler,
                        bool calc_cond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
@@ -1971,21 +1971,21 @@ SparseMatrix::utsolve (MatrixType &matty
 
                       if (work[k] != 0.)
                         {
                           if (ridx(cidx(kidx+1)-1) != k ||
                               data(cidx(kidx+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
-                            }                       
+                            }
 
                           double tmp = work[k] / data(cidx(kidx+1)-1);
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(kidx); 
+                          for (octave_idx_type i = cidx(kidx);
                                i < cidx(kidx+1)-1; i++)
                             {
                               octave_idx_type iidx = ridx(i);
                               work[iidx] = work[iidx] - tmp * data(i);
                             }
                         }
                     }
 
@@ -2028,17 +2028,17 @@ SparseMatrix::utsolve (MatrixType &matty
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           octave_idx_type iidx = perm[k];
 
                           if (work[k] != 0.)
                             {
                               double tmp = work[k] / data(cidx(iidx+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(iidx); 
+                              for (octave_idx_type i = cidx(iidx);
                                    i < cidx(iidx+1)-1; i++)
                                 {
                                   octave_idx_type idx2 = ridx(i);
                                   work[idx2] = work[idx2] - tmp * data(i);
                                 }
                             }
                         }
                       double atmp = 0;
@@ -2068,17 +2068,17 @@ SparseMatrix::utsolve (MatrixType &matty
                     {
                       if (work[k] != 0.)
                         {
                           if (ridx(cidx(k+1)-1) != k ||
                               data(cidx(k+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
-                            }                       
+                            }
 
                           double tmp = work[k] / data(cidx(k+1)-1);
                           work[k] = tmp;
                           for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
                             {
                               octave_idx_type iidx = ridx(i);
                               work[iidx] = work[iidx] - tmp * data(i);
                             }
@@ -2122,17 +2122,17 @@ SparseMatrix::utsolve (MatrixType &matty
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           if (work[k] != 0.)
                             {
                               double tmp = work[k] / data(cidx(k+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k); 
+                              for (octave_idx_type i = cidx(k);
                                    i < cidx(k+1)-1; i++)
                                 {
                                   octave_idx_type iidx = ridx(i);
                                   work[iidx] = work[iidx] - tmp * data(i);
                                 }
                             }
                         }
                       double atmp = 0;
@@ -2181,18 +2181,18 @@ SparseMatrix::utsolve (MatrixType &matty
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
   return retval;
 }
 
 ComplexMatrix
-SparseMatrix::utsolve (MatrixType &mattype, const ComplexMatrix& b, 
-                       octave_idx_type& err, double& rcond, 
+SparseMatrix::utsolve (MatrixType &mattype, const ComplexMatrix& b,
+                       octave_idx_type& err, double& rcond,
                        solve_singularity_handler sing_handler,
                        bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
@@ -2203,17 +2203,17 @@ SparseMatrix::utsolve (MatrixType &matty
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
-      
+
       if (typ == MatrixType::Permuted_Upper ||
           typ == MatrixType::Upper)
         {
           double anorm = 0.;
           double ainvnorm = 0.;
           octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
@@ -2249,21 +2249,21 @@ SparseMatrix::utsolve (MatrixType &matty
 
                       if (cwork[k] != 0.)
                         {
                           if (ridx(cidx(kidx+1)-1) != k ||
                               data(cidx(kidx+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
-                            }                       
+                            }
 
                           Complex tmp = cwork[k] / data(cidx(kidx+1)-1);
                           cwork[k] = tmp;
-                          for (octave_idx_type i = cidx(kidx); 
+                          for (octave_idx_type i = cidx(kidx);
                                i < cidx(kidx+1)-1; i++)
                             {
                               octave_idx_type iidx = ridx(i);
                               cwork[iidx] = cwork[iidx] - tmp * data(i);
                             }
                         }
                     }
 
@@ -2285,17 +2285,17 @@ SparseMatrix::utsolve (MatrixType &matty
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           octave_idx_type iidx = perm[k];
 
                           if (work[k] != 0.)
                             {
                               double tmp = work[k] / data(cidx(iidx+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(iidx); 
+                              for (octave_idx_type i = cidx(iidx);
                                    i < cidx(iidx+1)-1; i++)
                                 {
                                   octave_idx_type idx2 = ridx(i);
                                   work[idx2] = work[idx2] - tmp * data(i);
                                 }
                             }
                         }
                       double atmp = 0;
@@ -2326,17 +2326,17 @@ SparseMatrix::utsolve (MatrixType &matty
                     {
                       if (cwork[k] != 0.)
                         {
                           if (ridx(cidx(k+1)-1) != k ||
                               data(cidx(k+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
-                            }                       
+                            }
 
                           Complex tmp = cwork[k] / data(cidx(k+1)-1);
                           cwork[k] = tmp;
                           for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
                             {
                               octave_idx_type iidx = ridx(i);
                               cwork[iidx] = cwork[iidx] - tmp  * data(i);
                             }
@@ -2359,17 +2359,17 @@ SparseMatrix::utsolve (MatrixType &matty
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           if (work[k] != 0.)
                             {
                               double tmp = work[k] / data(cidx(k+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k); 
+                              for (octave_idx_type i = cidx(k);
                                    i < cidx(k+1)-1; i++)
                                 {
                                   octave_idx_type iidx = ridx(i);
                                   work[iidx] = work[iidx] - tmp * data(i);
                                 }
                             }
                         }
                       double atmp = 0;
@@ -2420,17 +2420,17 @@ SparseMatrix::utsolve (MatrixType &matty
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseMatrix::utsolve (MatrixType &mattype, const SparseComplexMatrix& b,
-                       octave_idx_type& err, double& rcond, 
+                       octave_idx_type& err, double& rcond,
                        solve_singularity_handler sing_handler,
                        bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
@@ -2441,17 +2441,17 @@ SparseMatrix::utsolve (MatrixType &matty
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
-      
+
       if (typ == MatrixType::Permuted_Upper ||
           typ == MatrixType::Upper)
         {
           double anorm = 0.;
           double ainvnorm = 0.;
           rcond = 1.;
 
           if (calc_cond)
@@ -2496,21 +2496,21 @@ SparseMatrix::utsolve (MatrixType &matty
 
                       if (cwork[k] != 0.)
                         {
                           if (ridx(cidx(kidx+1)-1) != k ||
                               data(cidx(kidx+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
-                            }                       
+                            }
 
                           Complex tmp = cwork[k] / data(cidx(kidx+1)-1);
                           cwork[k] = tmp;
-                          for (octave_idx_type i = cidx(kidx); 
+                          for (octave_idx_type i = cidx(kidx);
                                i < cidx(kidx+1)-1; i++)
                             {
                               octave_idx_type iidx = ridx(i);
                               cwork[iidx] = cwork[iidx] - tmp * data(i);
                             }
                         }
                     }
 
@@ -2554,17 +2554,17 @@ SparseMatrix::utsolve (MatrixType &matty
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           octave_idx_type iidx = perm[k];
 
                           if (work[k] != 0.)
                             {
                               double tmp = work[k] / data(cidx(iidx+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(iidx); 
+                              for (octave_idx_type i = cidx(iidx);
                                    i < cidx(iidx+1)-1; i++)
                                 {
                                   octave_idx_type idx2 = ridx(i);
                                   work[idx2] = work[idx2] - tmp * data(i);
                                 }
                             }
                         }
                       double atmp = 0;
@@ -2594,17 +2594,17 @@ SparseMatrix::utsolve (MatrixType &matty
                     {
                       if (cwork[k] != 0.)
                         {
                           if (ridx(cidx(k+1)-1) != k ||
                               data(cidx(k+1)-1) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
-                            }                       
+                            }
 
                           Complex tmp = cwork[k] / data(cidx(k+1)-1);
                           cwork[k] = tmp;
                           for (octave_idx_type i = cidx(k); i < cidx(k+1)-1; i++)
                             {
                               octave_idx_type iidx = ridx(i);
                               cwork[iidx] = cwork[iidx] - tmp * data(i);
                             }
@@ -2649,17 +2649,17 @@ SparseMatrix::utsolve (MatrixType &matty
                       work[j] = 1.;
 
                       for (octave_idx_type k = j; k >= 0; k--)
                         {
                           if (work[k] != 0.)
                             {
                               double tmp = work[k] / data(cidx(k+1)-1);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k); 
+                              for (octave_idx_type i = cidx(k);
                                    i < cidx(k+1)-1; i++)
                                 {
                                   octave_idx_type iidx = ridx(i);
                                   work[iidx] = work[iidx] - tmp * data(i);
                                 }
                             }
                         }
                       double atmp = 0;
@@ -2731,17 +2731,17 @@ SparseMatrix::ltsolve (MatrixType &matty
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = Matrix (nc, b.cols (), 0.0);
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
-      
+
       if (typ == MatrixType::Permuted_Lower ||
           typ == MatrixType::Lower)
         {
           double anorm = 0.;
           double ainvnorm = 0.;
           octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
@@ -2785,17 +2785,17 @@ SparseMatrix::ltsolve (MatrixType &matty
                                 minr = perm[ridx(i)];
                                 mini = i;
                               }
 
                           if (minr != k || data(mini) == 0)
                             {
                               err = -2;
                               goto triangular_error;
-                            }                       
+                            }
 
                           double tmp = work[k] / data(mini);
                           work[k] = tmp;
                           for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
                             {
                               if (i == mini)
                                 continue;
 
@@ -2821,27 +2821,27 @@ SparseMatrix::ltsolve (MatrixType &matty
 
                       for (octave_idx_type k = 0; k < nc; k++)
                         {
                           if (work[k] != 0.)
                             {
                               octave_idx_type minr = nr;
                               octave_idx_type mini = 0;
 
-                              for (octave_idx_type i = cidx(k); 
+                              for (octave_idx_type i = cidx(k);
                                    i < cidx(k+1); i++)
                                 if (perm[ridx(i)] < minr)
                                   {
                                     minr = perm[ridx(i)];
                                     mini = i;
                                   }
 
                               double tmp = work[k] / data(mini);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k); 
+                              for (octave_idx_type i = cidx(k);
                                    i < cidx(k+1); i++)
                                 {
                                   if (i == mini)
                                     continue;
 
                                   octave_idx_type iidx = perm[ridx(i)];
                                   work[iidx] = work[iidx] - tmp * data(i);
                                 }
@@ -2875,21 +2875,21 @@ SparseMatrix::ltsolve (MatrixType &matty
                     {
                       if (work[k] != 0.)
                         {
                           if (ridx(cidx(k)) != k ||
                               data(cidx(k)) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
-                            }                       
+                            }
 
                           double tmp = work[k] / data(cidx(k));
                           work[k] = tmp;
-                          for (octave_idx_type i = cidx(k)+1; 
+                          for (octave_idx_type i = cidx(k)+1;
                                i < cidx(k+1); i++)
                             {
                               octave_idx_type iidx = ridx(i);
                               work[iidx] = work[iidx] - tmp * data(i);
                             }
                         }
                     }
 
@@ -2909,17 +2909,17 @@ SparseMatrix::ltsolve (MatrixType &matty
 
                       for (octave_idx_type k = j; k < nc; k++)
                         {
 
                           if (work[k] != 0.)
                             {
                               double tmp = work[k] / data(cidx(k));
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k)+1; 
+                              for (octave_idx_type i = cidx(k)+1;
                                    i < cidx(k+1); i++)
                                 {
                                   octave_idx_type iidx = ridx(i);
                                   work[iidx] = work[iidx] - tmp * data(i);
                                 }
                             }
                         }
                       double atmp = 0;
@@ -2969,18 +2969,18 @@ SparseMatrix::ltsolve (MatrixType &matty
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseMatrix
-SparseMatrix::ltsolve (MatrixType &mattype, const SparseMatrix& b, 
-                       octave_idx_type& err, double& rcond, 
+SparseMatrix::ltsolve (MatrixType &mattype, const SparseMatrix& b,
+                       octave_idx_type& err, double& rcond,
                        solve_singularity_handler sing_handler,
                        bool calc_cond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
@@ -2991,17 +2991,17 @@ SparseMatrix::ltsolve (MatrixType &matty
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = SparseMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
-      
+
       if (typ == MatrixType::Permuted_Lower ||
           typ == MatrixType::Lower)
         {
           double anorm = 0.;
           double ainvnorm = 0.;
           rcond = 1.;
 
           if (calc_cond)
@@ -3049,17 +3049,17 @@ SparseMatrix::ltsolve (MatrixType &matty
                                 minr = perm[ridx(i)];
                                 mini = i;
                               }
 
                           if (minr != k || data(mini) == 0)
                             {
                               err = -2;
                               goto triangular_error;
-                            }                       
+                            }
 
                           double tmp = work[k] / data(mini);
                           work[k] = tmp;
                           for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
                             {
                               if (i == mini)
                                 continue;
 
@@ -3107,27 +3107,27 @@ SparseMatrix::ltsolve (MatrixType &matty
 
                       for (octave_idx_type k = 0; k < nc; k++)
                         {
                           if (work[k] != 0.)
                             {
                               octave_idx_type minr = nr;
                               octave_idx_type mini = 0;
 
-                              for (octave_idx_type i = cidx(k); 
+                              for (octave_idx_type i = cidx(k);
                                    i < cidx(k+1); i++)
                                 if (perm[ridx(i)] < minr)
                                   {
                                     minr = perm[ridx(i)];
                                     mini = i;
                                   }
 
                               double tmp = work[k] / data(mini);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k); 
+                              for (octave_idx_type i = cidx(k);
                                    i < cidx(k+1); i++)
                                 {
                                   if (i == mini)
                                     continue;
 
                                   octave_idx_type iidx = perm[ridx(i)];
                                   work[iidx] = work[iidx] - tmp * data(i);
                                 }
@@ -3161,17 +3161,17 @@ SparseMatrix::ltsolve (MatrixType &matty
                     {
                       if (work[k] != 0.)
                         {
                           if (ridx(cidx(k)) != k ||
                               data(cidx(k)) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
-                            }                       
+                            }
 
                           double tmp = work[k] / data(cidx(k));
                           work[k] = tmp;
                           for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
                             {
                               octave_idx_type iidx = ridx(i);
                               work[iidx] = work[iidx] - tmp * data(i);
                             }
@@ -3216,17 +3216,17 @@ SparseMatrix::ltsolve (MatrixType &matty
 
                       for (octave_idx_type k = j; k < nc; k++)
                         {
 
                           if (work[k] != 0.)
                             {
                               double tmp = work[k] / data(cidx(k));
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k)+1; 
+                              for (octave_idx_type i = cidx(k)+1;
                                    i < cidx(k+1); i++)
                                 {
                                   octave_idx_type iidx = ridx(i);
                                   work[iidx] = work[iidx] - tmp * data(i);
                                 }
                             }
                         }
                       double atmp = 0;
@@ -3276,18 +3276,18 @@ SparseMatrix::ltsolve (MatrixType &matty
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseMatrix::ltsolve (MatrixType &mattype, const ComplexMatrix& b, 
-                       octave_idx_type& err, double& rcond, 
+SparseMatrix::ltsolve (MatrixType &mattype, const ComplexMatrix& b,
+                       octave_idx_type& err, double& rcond,
                        solve_singularity_handler sing_handler,
                        bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
@@ -3298,17 +3298,17 @@ SparseMatrix::ltsolve (MatrixType &matty
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
-      
+
       if (typ == MatrixType::Permuted_Lower ||
           typ == MatrixType::Lower)
         {
           double anorm = 0.;
           double ainvnorm = 0.;
           octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
@@ -3351,17 +3351,17 @@ SparseMatrix::ltsolve (MatrixType &matty
                                 minr = perm[ridx(i)];
                                 mini = i;
                               }
 
                           if (minr != k || data(mini) == 0)
                             {
                               err = -2;
                               goto triangular_error;
-                            }                       
+                            }
 
                           Complex tmp = cwork[k] / data(mini);
                           cwork[k] = tmp;
                           for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
                             {
                               if (i == mini)
                                 continue;
 
@@ -3388,27 +3388,27 @@ SparseMatrix::ltsolve (MatrixType &matty
 
                       for (octave_idx_type k = 0; k < nc; k++)
                         {
                           if (work[k] != 0.)
                             {
                               octave_idx_type minr = nr;
                               octave_idx_type mini = 0;
 
-                              for (octave_idx_type i = cidx(k); 
+                              for (octave_idx_type i = cidx(k);
                                    i < cidx(k+1); i++)
                                 if (perm[ridx(i)] < minr)
                                   {
                                     minr = perm[ridx(i)];
                                     mini = i;
                                   }
 
                               double tmp = work[k] / data(mini);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k); 
+                              for (octave_idx_type i = cidx(k);
                                    i < cidx(k+1); i++)
                                 {
                                   if (i == mini)
                                     continue;
 
                                   octave_idx_type iidx = perm[ridx(i)];
                                   work[iidx] = work[iidx] - tmp * data(i);
                                 }
@@ -3443,17 +3443,17 @@ SparseMatrix::ltsolve (MatrixType &matty
                     {
                       if (cwork[k] != 0.)
                         {
                           if (ridx(cidx(k)) != k ||
                               data(cidx(k)) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
-                            }                       
+                            }
 
                           Complex tmp = cwork[k] / data(cidx(k));
                           cwork[k] = tmp;
                           for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
                             {
                               octave_idx_type iidx = ridx(i);
                               cwork[iidx] = cwork[iidx] - tmp * data(i);
                             }
@@ -3477,17 +3477,17 @@ SparseMatrix::ltsolve (MatrixType &matty
 
                       for (octave_idx_type k = j; k < nc; k++)
                         {
 
                           if (work[k] != 0.)
                             {
                               double tmp = work[k] / data(cidx(k));
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k)+1; 
+                              for (octave_idx_type i = cidx(k)+1;
                                    i < cidx(k+1); i++)
                                 {
                                   octave_idx_type iidx = ridx(i);
                                   work[iidx] = work[iidx] - tmp * data(i);
                                 }
                             }
                         }
                       double atmp = 0;
@@ -3538,17 +3538,17 @@ SparseMatrix::ltsolve (MatrixType &matty
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseMatrix::ltsolve (MatrixType &mattype, const SparseComplexMatrix& b,
-                       octave_idx_type& err, double& rcond, 
+                       octave_idx_type& err, double& rcond,
                        solve_singularity_handler sing_handler,
                        bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc > nr ? nc : nr);
@@ -3559,17 +3559,17 @@ SparseMatrix::ltsolve (MatrixType &matty
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || nc == 0 || b.cols () == 0)
     retval = SparseComplexMatrix (nc, b.cols ());
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
-      
+
       if (typ == MatrixType::Permuted_Lower ||
           typ == MatrixType::Lower)
         {
           double anorm = 0.;
           double ainvnorm = 0.;
           rcond = 1.;
 
           if (calc_cond)
@@ -3617,17 +3617,17 @@ SparseMatrix::ltsolve (MatrixType &matty
                                 minr = perm[ridx(i)];
                                 mini = i;
                               }
 
                           if (minr != k || data(mini) == 0)
                             {
                               err = -2;
                               goto triangular_error;
-                            }                       
+                            }
 
                           Complex tmp = cwork[k] / data(mini);
                           cwork[k] = tmp;
                           for (octave_idx_type i = cidx(k); i < cidx(k+1); i++)
                             {
                               if (i == mini)
                                 continue;
 
@@ -3676,27 +3676,27 @@ SparseMatrix::ltsolve (MatrixType &matty
 
                       for (octave_idx_type k = 0; k < nc; k++)
                         {
                           if (work[k] != 0.)
                             {
                               octave_idx_type minr = nr;
                               octave_idx_type mini = 0;
 
-                              for (octave_idx_type i = cidx(k); 
+                              for (octave_idx_type i = cidx(k);
                                    i < cidx(k+1); i++)
                                 if (perm[ridx(i)] < minr)
                                   {
                                     minr = perm[ridx(i)];
                                     mini = i;
                                   }
 
                               double tmp = work[k] / data(mini);
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k); 
+                              for (octave_idx_type i = cidx(k);
                                    i < cidx(k+1); i++)
                                 {
                                   if (i == mini)
                                     continue;
 
                                   octave_idx_type iidx = perm[ridx(i)];
                                   work[iidx] = work[iidx] - tmp * data(i);
                                 }
@@ -3730,17 +3730,17 @@ SparseMatrix::ltsolve (MatrixType &matty
                     {
                       if (cwork[k] != 0.)
                         {
                           if (ridx(cidx(k)) != k ||
                               data(cidx(k)) == 0.)
                             {
                               err = -2;
                               goto triangular_error;
-                            }                       
+                            }
 
                           Complex tmp = cwork[k] / data(cidx(k));
                           cwork[k] = tmp;
                           for (octave_idx_type i = cidx(k)+1; i < cidx(k+1); i++)
                             {
                               octave_idx_type iidx = ridx(i);
                               cwork[iidx] = cwork[iidx] - tmp * data(i);
                             }
@@ -3786,17 +3786,17 @@ SparseMatrix::ltsolve (MatrixType &matty
 
                       for (octave_idx_type k = j; k < nc; k++)
                         {
 
                           if (work[k] != 0.)
                             {
                               double tmp = work[k] / data(cidx(k));
                               work[k] = tmp;
-                              for (octave_idx_type i = cidx(k)+1; 
+                              for (octave_idx_type i = cidx(k)+1;
                                    i < cidx(k+1); i++)
                                 {
                                   octave_idx_type iidx = ridx(i);
                                   work[iidx] = work[iidx] - tmp * data(i);
                                 }
                             }
                         }
                       double atmp = 0;
@@ -3863,24 +3863,24 @@ SparseMatrix::trisolve (MatrixType &matt
   err = 0;
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || b.cols () == 0)
     retval = Matrix (nc, b.cols (), 0.0);
   else if (calc_cond)
-    (*current_liboctave_error_handler) 
+    (*current_liboctave_error_handler)
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
-      
+
       if (typ == MatrixType::Tridiagonal_Hermitian)
         {
           OCTAVE_LOCAL_BUFFER (double, D, nr);
           OCTAVE_LOCAL_BUFFER (double, DL, nr - 1);
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
@@ -3906,31 +3906,31 @@ SparseMatrix::trisolve (MatrixType &matt
                 for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
                   {
                     if (ridx(i) == j)
                       D[j] = data(i);
                     else if (ridx(i) == j + 1)
                       DL[j] = data(i);
                   }
             }
-              
+
           octave_idx_type b_nc = b.cols();
           retval = b;
           double *result = retval.fortran_vec ();
 
-          F77_XFCN (dptsv, DPTSV, (nr, b_nc, D, DL, result, 
+          F77_XFCN (dptsv, DPTSV, (nr, b_nc, D, DL, result,
                                    b.rows(), err));
 
           if (err != 0)
             {
               err = 0;
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Tridiagonal;
             }
-          else 
+          else
             rcond = 1.;
         }
 
       if (typ == MatrixType::Tridiagonal)
         {
           OCTAVE_LOCAL_BUFFER (double, DU, nr - 1);
           OCTAVE_LOCAL_BUFFER (double, D, nr);
           OCTAVE_LOCAL_BUFFER (double, DL, nr - 1);
@@ -3968,70 +3968,70 @@ SparseMatrix::trisolve (MatrixType &matt
                       DU[j-1] = data(i);
                   }
             }
 
           octave_idx_type b_nc = b.cols();
           retval = b;
           double *result = retval.fortran_vec ();
 
-          F77_XFCN (dgtsv, DGTSV, (nr, b_nc, DL, D, DU, result, 
+          F77_XFCN (dgtsv, DGTSV, (nr, b_nc, DL, D, DU, result,
                                    b.rows(), err));
 
           if (err != 0)
             {
               rcond = 0.;
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
                 (*current_liboctave_error_handler)
                   ("matrix singular to machine precision");
 
-            } 
-          else 
+            }
+          else
             rcond = 1.;
         }
       else if (typ != MatrixType::Tridiagonal_Hermitian)
                (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseMatrix
-SparseMatrix::trisolve (MatrixType &mattype, const SparseMatrix& b, 
-                        octave_idx_type& err, double& rcond, 
+SparseMatrix::trisolve (MatrixType &mattype, const SparseMatrix& b,
+                        octave_idx_type& err, double& rcond,
                         solve_singularity_handler sing_handler,
                         bool calc_cond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || b.cols () == 0)
     retval = SparseMatrix (nc, b.cols ());
   else if (calc_cond)
-    (*current_liboctave_error_handler) 
+    (*current_liboctave_error_handler)
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
-      
+
       // Note can't treat symmetric case as there is no dpttrf function
       if (typ == MatrixType::Tridiagonal ||
           typ == MatrixType::Tridiagonal_Hermitian)
         {
           OCTAVE_LOCAL_BUFFER (double, DU2, nr - 2);
           OCTAVE_LOCAL_BUFFER (double, DU, nr - 1);
           OCTAVE_LOCAL_BUFFER (double, D, nr);
           OCTAVE_LOCAL_BUFFER (double, DL, nr - 1);
@@ -4069,32 +4069,32 @@ SparseMatrix::trisolve (MatrixType &matt
                       DL[j] = data(i);
                     else if (ridx(i) == j - 1)
                       DU[j-1] = data(i);
                   }
             }
 
           F77_XFCN (dgttrf, DGTTRF, (nr, DL, D, DU, DU2, pipvt, err));
 
-          if (err != 0) 
+          if (err != 0)
             {
               rcond = 0.0;
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
                 (*current_liboctave_error_handler)
                   ("matrix singular to machine precision");
 
-            } 
-          else 
+            }
+          else
             {
               rcond = 1.0;
               char job = 'N';
               volatile octave_idx_type x_nz = b.nnz ();
               octave_idx_type b_nc = b.cols ();
               retval = SparseMatrix (nr, b_nc, x_nz);
               retval.xcidx(0) = 0;
               volatile octave_idx_type ii = 0;
@@ -4103,23 +4103,23 @@ SparseMatrix::trisolve (MatrixType &matt
 
               for (volatile octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nr; i++)
                     work[i] = 0.;
                   for (octave_idx_type i = b.cidx(j); i < b.cidx(j+1); i++)
                     work[b.ridx(i)] = b.data(i);
 
-                  F77_XFCN (dgttrs, DGTTRS, 
+                  F77_XFCN (dgttrs, DGTTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, 1, DL, D, DU, DU2, pipvt, 
+                             nr, 1, DL, D, DU, DU2, pipvt,
                              work, b.rows (), err
                              F77_CHAR_ARG_LEN (1)));
 
-                  // Count non-zeros in work vector and adjust 
+                  // Count non-zeros in work vector and adjust
                   // space in retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nr; i++)
                     if (work[i] != 0.)
                       new_nnz++;
 
                   if (ii + new_nnz > x_nz)
                     {
@@ -4144,41 +4144,41 @@ SparseMatrix::trisolve (MatrixType &matt
       else if (typ != MatrixType::Tridiagonal_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseMatrix::trisolve (MatrixType &mattype, const ComplexMatrix& b, 
-                        octave_idx_type& err, double& rcond, 
+SparseMatrix::trisolve (MatrixType &mattype, const ComplexMatrix& b,
+                        octave_idx_type& err, double& rcond,
                         solve_singularity_handler sing_handler,
                         bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else if (calc_cond)
-    (*current_liboctave_error_handler) 
+    (*current_liboctave_error_handler)
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
-      
+
       if (typ == MatrixType::Tridiagonal_Hermitian)
         {
           OCTAVE_LOCAL_BUFFER (double, D, nr);
           OCTAVE_LOCAL_BUFFER (Complex, DL, nr - 1);
 
           if (mattype.is_dense ())
             {
               octave_idx_type ii = 0;
@@ -4211,18 +4211,18 @@ SparseMatrix::trisolve (MatrixType &matt
             }
 
           octave_idx_type b_nr = b.rows ();
           octave_idx_type b_nc = b.cols();
           rcond = 1.;
 
           retval = b;
           Complex *result = retval.fortran_vec ();
-                  
-          F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, DL, result, 
+
+          F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, DL, result,
                                    b_nr, err));
 
           if (err != 0)
             {
               err = 0;
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Tridiagonal;
             }
@@ -4269,25 +4269,25 @@ SparseMatrix::trisolve (MatrixType &matt
             }
 
           octave_idx_type b_nr = b.rows();
           octave_idx_type b_nc = b.cols();
           rcond = 1.;
 
           retval = b;
           Complex *result = retval.fortran_vec ();
-              
-          F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, DL, D, DU, result, 
+
+          F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, DL, D, DU, result,
                                    b_nr, err));
 
           if (err != 0)
             {
               rcond = 0.;
               err = -2;
-                      
+
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
                 (*current_liboctave_error_handler)
                   ("matrix singular to machine precision");
@@ -4297,40 +4297,40 @@ SparseMatrix::trisolve (MatrixType &matt
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseMatrix::trisolve (MatrixType &mattype, const SparseComplexMatrix& b,
-                        octave_idx_type& err, double& rcond, 
+                        octave_idx_type& err, double& rcond,
                         solve_singularity_handler sing_handler,
                         bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || b.cols () == 0)
     retval = SparseComplexMatrix (nc, b.cols ());
   else if (calc_cond)
-    (*current_liboctave_error_handler) 
+    (*current_liboctave_error_handler)
       ("calculation of condition number not implemented");
   else
     {
       // Print spparms("spumoni") info if requested
       int typ = mattype.type ();
       mattype.info ();
-      
+
       // Note can't treat symmetric case as there is no dpttrf function
       if (typ == MatrixType::Tridiagonal ||
           typ == MatrixType::Tridiagonal_Hermitian)
         {
           OCTAVE_LOCAL_BUFFER (double, DU2, nr - 2);
           OCTAVE_LOCAL_BUFFER (double, DU, nr - 1);
           OCTAVE_LOCAL_BUFFER (double, D, nr);
           OCTAVE_LOCAL_BUFFER (double, DL, nr - 1);
@@ -4368,32 +4368,32 @@ SparseMatrix::trisolve (MatrixType &matt
                       DL[j] = data(i);
                     else if (ridx(i) == j - 1)
                       DU[j-1] = data(i);
                   }
             }
 
           F77_XFCN (dgttrf, DGTTRF, (nr, DL, D, DU, DU2, pipvt, err));
 
-          if (err != 0) 
+          if (err != 0)
             {
               rcond = 0.0;
               err = -2;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
                 (*current_liboctave_error_handler)
                   ("matrix singular to machine precision");
-            } 
-          else 
-            {   
+            }
+          else
+            {
               rcond = 1.;
               char job = 'N';
               octave_idx_type b_nr = b.rows ();
               octave_idx_type b_nc = b.cols ();
               OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
               OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
 
               // Take a first guess that the number of non-zero terms
@@ -4408,47 +4408,47 @@ SparseMatrix::trisolve (MatrixType &matt
 
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     {
                       Complex c = b (i,j);
                       Bx[i] = std::real (c);
                       Bz[i] = std::imag (c);
                     }
 
-                  F77_XFCN (dgttrs, DGTTRS, 
+                  F77_XFCN (dgttrs, DGTTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, 1, DL, D, DU, DU2, pipvt, 
+                             nr, 1, DL, D, DU, DU2, pipvt,
                              Bx, b_nr, err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     {
                       (*current_liboctave_error_handler)
                         ("SparseMatrix::solve solve failed");
 
                       err = -1;
                       break;
                     }
 
-                  F77_XFCN (dgttrs, DGTTRS, 
+                  F77_XFCN (dgttrs, DGTTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, 1, DL, D, DU, DU2, pipvt, 
+                             nr, 1, DL, D, DU, DU2, pipvt,
                              Bz, b_nr, err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     {
                       (*current_liboctave_error_handler)
                         ("SparseMatrix::solve solve failed");
 
                       err = -1;
                       break;
                     }
 
-                  // Count non-zeros in work vector and adjust 
+                  // Count non-zeros in work vector and adjust
                   // space in retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nr; i++)
                     if (Bx[i] != 0. || Bz[i] != 0.)
                       new_nnz++;
 
                   if (ii + new_nnz > x_nz)
                     {
@@ -4457,17 +4457,17 @@ SparseMatrix::trisolve (MatrixType &matt
                       retval.change_capacity (sz);
                       x_nz = sz;
                     }
 
                   for (octave_idx_type i = 0; i < nr; i++)
                     if (Bx[i] != 0. || Bz[i] != 0.)
                       {
                         retval.xridx(ii) = i;
-                        retval.xdata(ii++) = 
+                        retval.xdata(ii++) =
                           Complex (Bx[i], Bz[i]);
                       }
 
                   retval.xcidx(j+1) = ii;
                 }
 
               retval.maybe_compress ();
             }
@@ -4503,18 +4503,18 @@ SparseMatrix::bsolve (MatrixType &mattyp
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
         {
           octave_idx_type n_lower = mattype.nlower ();
           octave_idx_type ldm = n_lower + 1;
           Matrix m_band (ldm, nc);
           double *tmp_data = m_band.fortran_vec ();
-              
-          if (! mattype.is_dense ()) 
+
+          if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
@@ -4530,42 +4530,42 @@ SparseMatrix::bsolve (MatrixType &mattyp
           double anorm;
           if (calc_cond)
             anorm = m_band.abs().sum().row(0).max();
 
           char job = 'L';
           F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
-            
-          if (err != 0) 
+
+          if (err != 0)
             {
               // Matrix is not positive definite!! Fall through to
               // unsymmetric banded solver.
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Banded;
               rcond = 0.0;
               err = 0;
-            } 
-          else 
+            }
+          else
             {
               if (calc_cond)
                 {
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
                   Array<octave_idx_type> iz (dim_vector (nr, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
-                  F77_XFCN (dpbcon, DPBCON, 
+                  F77_XFCN (dpbcon, DPBCON,
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nr, n_lower, tmp_data, ldm,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
-                  if (err != 0) 
+                  if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcond))
                     {
                       err = -2;
 
@@ -4585,43 +4585,43 @@ SparseMatrix::bsolve (MatrixType &mattyp
 
               if (err == 0)
                 {
                   retval = b;
                   double *result = retval.fortran_vec ();
 
                   octave_idx_type b_nc = b.cols ();
 
-                  F77_XFCN (dpbtrs, DPBTRS, 
+                  F77_XFCN (dpbtrs, DPBTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              nr, n_lower, b_nc, tmp_data,
                              ldm, result, b.rows(), err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     {
-                      (*current_liboctave_error_handler) 
+                      (*current_liboctave_error_handler)
                         ("SparseMatrix::solve solve failed");
                       err = -1;
                     }
                 }
             }
         }
 
       if (typ == MatrixType::Banded)
         {
           // Create the storage for the banded form of the sparse matrix
           octave_idx_type n_upper = mattype.nupper ();
           octave_idx_type n_lower = mattype.nlower ();
           octave_idx_type ldm = n_upper + 2 * n_lower + 1;
 
           Matrix m_band (ldm, nc);
           double *tmp_data = m_band.fortran_vec ();
-              
-          if (! mattype.is_dense ()) 
+
+          if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
@@ -4641,53 +4641,53 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
-          F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
+          F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data,
                                      ldm, pipvt, err));
-            
-          // Throw-away extra info LAPACK gives so as to not 
+
+          // Throw-away extra info LAPACK gives so as to not
           // change output.
-          if (err != 0) 
+          if (err != 0)
             {
               err = -2;
               rcond = 0.0;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
                 (*current_liboctave_error_handler)
                   ("matrix singular to machine precision");
 
-            } 
-          else 
+            }
+          else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
                   Array<octave_idx_type> iz (dim_vector (nr, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
-                  F77_XFCN (dgbcon, DGBCON, 
+                  F77_XFCN (dgbcon, DGBCON,
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nc, n_lower, n_upper, tmp_data, ldm, pipvt,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
-                   if (err != 0) 
+                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcond))
                     {
                       err = -2;
 
@@ -4708,34 +4708,34 @@ SparseMatrix::bsolve (MatrixType &mattyp
               if (err == 0)
                 {
                   retval = b;
                   double *result = retval.fortran_vec ();
 
                   octave_idx_type b_nc = b.cols ();
 
                   char job = 'N';
-                  F77_XFCN (dgbtrs, DGBTRS, 
+                  F77_XFCN (dgbtrs, DGBTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              nr, n_lower, n_upper, b_nc, tmp_data,
                              ldm, pipvt, result, b.rows(), err
                              F77_CHAR_ARG_LEN (1)));
                 }
             }
         }
       else if (typ != MatrixType::Banded_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseMatrix
 SparseMatrix::bsolve (MatrixType &mattype, const SparseMatrix& b,
-                      octave_idx_type& err, double& rcond, 
+                      octave_idx_type& err, double& rcond,
                       solve_singularity_handler sing_handler,
                       bool calc_cond) const
 {
   SparseMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
@@ -4753,18 +4753,18 @@ SparseMatrix::bsolve (MatrixType &mattyp
 
       if (typ == MatrixType::Banded_Hermitian)
         {
           octave_idx_type n_lower = mattype.nlower ();
           octave_idx_type ldm = n_lower + 1;
 
           Matrix m_band (ldm, nc);
           double *tmp_data = m_band.fortran_vec ();
-              
-          if (! mattype.is_dense ()) 
+
+          if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
@@ -4780,40 +4780,40 @@ SparseMatrix::bsolve (MatrixType &mattyp
           double anorm;
           if (calc_cond)
             anorm = m_band.abs().sum().row(0).max();
 
           char job = 'L';
           F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
-            
-          if (err != 0) 
+
+          if (err != 0)
             {
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Banded;
               rcond = 0.0;
               err = 0;
-            } 
-          else 
+            }
+          else
             {
               if (calc_cond)
                 {
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
                   Array<octave_idx_type> iz (dim_vector (nr, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
-                  F77_XFCN (dpbcon, DPBCON, 
+                  F77_XFCN (dpbcon, DPBCON,
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nr, n_lower, tmp_data, ldm,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
-                  if (err != 0) 
+                  if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcond))
                     {
                       err = -2;
 
@@ -4844,39 +4844,39 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   retval = SparseMatrix (b_nr, b_nc, x_nz);
 
                   retval.xcidx(0) = 0;
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
                       for (octave_idx_type i = 0; i < b_nr; i++)
                         Bx[i] = b.elem (i, j);
 
-                      F77_XFCN (dpbtrs, DPBTRS, 
+                      F77_XFCN (dpbtrs, DPBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, 1, tmp_data,
                                  ldm, Bx, b_nr, err
                                  F77_CHAR_ARG_LEN (1)));
 
                       if (err != 0)
                         {
-                          (*current_liboctave_error_handler) 
+                          (*current_liboctave_error_handler)
                             ("SparseMatrix::solve solve failed");
                           err = -1;
                           break;
                         }
 
                       for (octave_idx_type i = 0; i < b_nr; i++)
                         {
                           double tmp = Bx[i];
                           if (tmp != 0.0)
                             {
                               if (ii == x_nz)
                                 {
                                   // Resize the sparse matrix
-                                  octave_idx_type sz = x_nz * 
+                                  octave_idx_type sz = x_nz *
                                     (b_nc - j) / b_nc;
                                   sz = (sz > 10 ? sz : 10) + x_nz;
                                   retval.change_capacity (sz);
                                   x_nz = sz;
                                 }
                               retval.xdata(ii) = tmp;
                               retval.xridx(ii++) = i;
                             }
@@ -4893,18 +4893,18 @@ SparseMatrix::bsolve (MatrixType &mattyp
         {
           // Create the storage for the banded form of the sparse matrix
           octave_idx_type n_upper = mattype.nupper ();
           octave_idx_type n_lower = mattype.nlower ();
           octave_idx_type ldm = n_upper + 2 * n_lower + 1;
 
           Matrix m_band (ldm, nc);
           double *tmp_data = m_band.fortran_vec ();
-              
-          if (! mattype.is_dense ()) 
+
+          if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
@@ -4924,51 +4924,51 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
-          F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
+          F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data,
                                      ldm, pipvt, err));
-            
-          if (err != 0) 
+
+          if (err != 0)
             {
               err = -2;
               rcond = 0.0;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
                 (*current_liboctave_error_handler)
                   ("matrix singular to machine precision");
 
-            } 
-          else 
+            }
+          else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
                   Array<octave_idx_type> iz (dim_vector (nr, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
-                  F77_XFCN (dgbcon, DGBCON, 
+                  F77_XFCN (dgbcon, DGBCON,
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nc, n_lower, n_upper, tmp_data, ldm, pipvt,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
-                   if (err != 0) 
+                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcond))
                     {
                       err = -2;
 
@@ -4996,27 +4996,27 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   volatile octave_idx_type ii = 0;
 
                   OCTAVE_LOCAL_BUFFER (double, work, nr);
 
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
                       for (octave_idx_type i = 0; i < nr; i++)
                         work[i] = 0.;
-                      for (octave_idx_type i = b.cidx(j); 
+                      for (octave_idx_type i = b.cidx(j);
                            i < b.cidx(j+1); i++)
                         work[b.ridx(i)] = b.data(i);
 
-                      F77_XFCN (dgbtrs, DGBTRS, 
+                      F77_XFCN (dgbtrs, DGBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, n_upper, 1, tmp_data,
                                  ldm, pipvt, work, b.rows (), err
                                  F77_CHAR_ARG_LEN (1)));
 
-                      // Count non-zeros in work vector and adjust 
+                      // Count non-zeros in work vector and adjust
                       // space in retval if needed
                       octave_idx_type new_nnz = 0;
                       for (octave_idx_type i = 0; i < nr; i++)
                         if (work[i] != 0.)
                           new_nnz++;
 
                       if (ii + new_nnz > x_nz)
                         {
@@ -5042,18 +5042,18 @@ SparseMatrix::bsolve (MatrixType &mattyp
       else if (typ != MatrixType::Banded_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 ComplexMatrix
-SparseMatrix::bsolve (MatrixType &mattype, const ComplexMatrix& b, 
-                      octave_idx_type& err, double& rcond, 
+SparseMatrix::bsolve (MatrixType &mattype, const ComplexMatrix& b,
+                      octave_idx_type& err, double& rcond,
                       solve_singularity_handler sing_handler,
                       bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
@@ -5071,18 +5071,18 @@ SparseMatrix::bsolve (MatrixType &mattyp
 
       if (typ == MatrixType::Banded_Hermitian)
         {
           octave_idx_type n_lower = mattype.nlower ();
           octave_idx_type ldm = n_lower + 1;
 
           Matrix m_band (ldm, nc);
           double *tmp_data = m_band.fortran_vec ();
-              
-          if (! mattype.is_dense ()) 
+
+          if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
@@ -5098,42 +5098,42 @@ SparseMatrix::bsolve (MatrixType &mattyp
           double anorm;
           if (calc_cond)
             anorm = m_band.abs().sum().row(0).max();
 
           char job = 'L';
           F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
-            
-          if (err != 0) 
+
+          if (err != 0)
             {
               // Matrix is not positive definite!! Fall through to
               // unsymmetric banded solver.
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Banded;
               rcond = 0.0;
               err = 0;
-            } 
-          else 
+            }
+          else
             {
               if (calc_cond)
                 {
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
                   Array<octave_idx_type> iz (dim_vector (nr, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
-                  F77_XFCN (dpbcon, DPBCON, 
+                  F77_XFCN (dpbcon, DPBCON,
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nr, n_lower, tmp_data, ldm,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
-                  if (err != 0) 
+                  if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcond))
                     {
                       err = -2;
 
@@ -5165,39 +5165,39 @@ SparseMatrix::bsolve (MatrixType &mattyp
                     {
                       for (octave_idx_type i = 0; i < b_nr; i++)
                         {
                           Complex c = b (i,j);
                           Bx[i] = std::real (c);
                           Bz[i] = std::imag (c);
                         }
 
-                      F77_XFCN (dpbtrs, DPBTRS, 
+                      F77_XFCN (dpbtrs, DPBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, 1, tmp_data,
                                  ldm, Bx, b_nr, err
                                  F77_CHAR_ARG_LEN (1)));
 
                       if (err != 0)
                         {
-                          (*current_liboctave_error_handler) 
+                          (*current_liboctave_error_handler)
                             ("SparseMatrix::solve solve failed");
                           err = -1;
                           break;
                         }
 
-                      F77_XFCN (dpbtrs, DPBTRS, 
+                      F77_XFCN (dpbtrs, DPBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, 1, tmp_data,
                                  ldm, Bz, b.rows(), err
                                  F77_CHAR_ARG_LEN (1)));
 
                       if (err != 0)
                         {
-                          (*current_liboctave_error_handler) 
+                          (*current_liboctave_error_handler)
                             ("SparseMatrix::solve solve failed");
                           err = -1;
                           break;
                         }
 
                       for (octave_idx_type i = 0; i < b_nr; i++)
                         retval (i, j) = Complex (Bx[i], Bz[i]);
                     }
@@ -5209,18 +5209,18 @@ SparseMatrix::bsolve (MatrixType &mattyp
         {
           // Create the storage for the banded form of the sparse matrix
           octave_idx_type n_upper = mattype.nupper ();
           octave_idx_type n_lower = mattype.nlower ();
           octave_idx_type ldm = n_upper + 2 * n_lower + 1;
 
           Matrix m_band (ldm, nc);
           double *tmp_data = m_band.fortran_vec ();
-              
-          if (! mattype.is_dense ()) 
+
+          if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
@@ -5240,51 +5240,51 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
-          F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
+          F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data,
                                      ldm, pipvt, err));
-            
-          if (err != 0) 
+
+          if (err != 0)
             {
               err = -2;
               rcond = 0.0;
 
               if (sing_handler)
                 {
                 sing_handler (rcond);
                 mattype.mark_as_rectangular ();
                 }
               else
                 (*current_liboctave_error_handler)
                   ("matrix singular to machine precision");
 
-            } 
-          else 
+            }
+          else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
                   Array<octave_idx_type> iz (dim_vector (nr, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
-                  F77_XFCN (dpbcon, DPBCON, 
+                  F77_XFCN (dpbcon, DPBCON,
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nr, n_lower, tmp_data, ldm,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
-                  if (err != 0) 
+                  if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcond))
                     {
                       err = -2;
 
@@ -5315,23 +5315,23 @@ SparseMatrix::bsolve (MatrixType &mattyp
                     {
                       for (octave_idx_type i = 0; i < nr; i++)
                         {
                           Complex c = b (i, j);
                           Bx[i] = std::real (c);
                           Bz[i] = std::imag  (c);
                         }
 
-                      F77_XFCN (dgbtrs, DGBTRS, 
+                      F77_XFCN (dgbtrs, DGBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, n_upper, 1, tmp_data,
                                  ldm, pipvt, Bx, b.rows (), err
                                  F77_CHAR_ARG_LEN (1)));
 
-                      F77_XFCN (dgbtrs, DGBTRS, 
+                      F77_XFCN (dgbtrs, DGBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, n_upper, 1, tmp_data,
                                  ldm, pipvt, Bz, b.rows (), err
                                  F77_CHAR_ARG_LEN (1)));
 
                       for (octave_idx_type i = 0; i < nr; i++)
                         retval (i, j) = Complex (Bx[i], Bz[i]);
                     }
@@ -5342,17 +5342,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseMatrix::bsolve (MatrixType &mattype, const SparseComplexMatrix& b,
-                      octave_idx_type& err, double& rcond, 
+                      octave_idx_type& err, double& rcond,
                       solve_singularity_handler sing_handler,
                       bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
@@ -5370,18 +5370,18 @@ SparseMatrix::bsolve (MatrixType &mattyp
 
       if (typ == MatrixType::Banded_Hermitian)
         {
           octave_idx_type n_lower = mattype.nlower ();
           octave_idx_type ldm = n_lower + 1;
 
           Matrix m_band (ldm, nc);
           double *tmp_data = m_band.fortran_vec ();
-              
-          if (! mattype.is_dense ()) 
+
+          if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
@@ -5397,43 +5397,43 @@ SparseMatrix::bsolve (MatrixType &mattyp
           double anorm;
           if (calc_cond)
             anorm = m_band.abs().sum().row(0).max();
 
           char job = 'L';
           F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      nr, n_lower, tmp_data, ldm, err
                                      F77_CHAR_ARG_LEN (1)));
-            
-          if (err != 0) 
+
+          if (err != 0)
             {
               // Matrix is not positive definite!! Fall through to
               // unsymmetric banded solver.
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Banded;
 
               rcond = 0.0;
               err = 0;
-            } 
-          else 
+            }
+          else
             {
               if (calc_cond)
                 {
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
                   Array<octave_idx_type> iz (dim_vector (nr, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
-                  F77_XFCN (dpbcon, DPBCON, 
+                  F77_XFCN (dpbcon, DPBCON,
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nr, n_lower, tmp_data, ldm,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
-                  if (err != 0) 
+                  if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcond))
                     {
                       err = -2;
 
@@ -5470,46 +5470,46 @@ SparseMatrix::bsolve (MatrixType &mattyp
 
                       for (octave_idx_type i = 0; i < b_nr; i++)
                         {
                           Complex c = b (i,j);
                           Bx[i] = std::real (c);
                           Bz[i] = std::imag (c);
                         }
 
-                      F77_XFCN (dpbtrs, DPBTRS, 
+                      F77_XFCN (dpbtrs, DPBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, 1, tmp_data,
                                  ldm, Bx, b_nr, err
                                  F77_CHAR_ARG_LEN (1)));
 
                       if (err != 0)
                         {
-                          (*current_liboctave_error_handler) 
+                          (*current_liboctave_error_handler)
                             ("SparseMatrix::solve solve failed");
                           err = -1;
                           break;
                         }
 
-                      F77_XFCN (dpbtrs, DPBTRS, 
+                      F77_XFCN (dpbtrs, DPBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, 1, tmp_data,
                                  ldm, Bz, b_nr, err
                                  F77_CHAR_ARG_LEN (1)));
 
                       if (err != 0)
                         {
                           (*current_liboctave_error_handler)
                             ("SparseMatrix::solve solve failed");
 
                           err = -1;
                           break;
                         }
 
-                      // Count non-zeros in work vector and adjust 
+                      // Count non-zeros in work vector and adjust
                       // space in retval if needed
                       octave_idx_type new_nnz = 0;
                       for (octave_idx_type i = 0; i < nr; i++)
                         if (Bx[i] != 0. || Bz[i] != 0.)
                           new_nnz++;
 
                       if (ii + new_nnz > x_nz)
                         {
@@ -5518,17 +5518,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                           retval.change_capacity (sz);
                           x_nz = sz;
                         }
 
                       for (octave_idx_type i = 0; i < nr; i++)
                         if (Bx[i] != 0. || Bz[i] != 0.)
                           {
                             retval.xridx(ii) = i;
-                            retval.xdata(ii++) = 
+                            retval.xdata(ii++) =
                               Complex (Bx[i], Bz[i]);
                           }
 
                       retval.xcidx(j+1) = ii;
                     }
 
                   retval.maybe_compress ();
                 }
@@ -5539,18 +5539,18 @@ SparseMatrix::bsolve (MatrixType &mattyp
         {
           // Create the storage for the banded form of the sparse matrix
           octave_idx_type n_upper = mattype.nupper ();
           octave_idx_type n_lower = mattype.nlower ();
           octave_idx_type ldm = n_upper + 2 * n_lower + 1;
 
           Matrix m_band (ldm, nc);
           double *tmp_data = m_band.fortran_vec ();
-              
-          if (! mattype.is_dense ()) 
+
+          if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
               for (octave_idx_type j = 0; j < ldm; j++)
                 for (octave_idx_type i = 0; i < nc; i++)
                   tmp_data[ii++] = 0.;
             }
 
@@ -5570,51 +5570,51 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
-          F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data, 
+          F77_XFCN (dgbtrf, DGBTRF, (nr, nr, n_lower, n_upper, tmp_data,
                                      ldm, pipvt, err));
-            
-          if (err != 0) 
+
+          if (err != 0)
             {
               err = -2;
               rcond = 0.0;
 
               if (sing_handler)
                 {
                   sing_handler (rcond);
                   mattype.mark_as_rectangular ();
                 }
               else
                 (*current_liboctave_error_handler)
                   ("matrix singular to machine precision");
 
-            } 
-          else 
+            }
+          else
             {
               if (calc_cond)
                 {
                   char job = '1';
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
                   Array<octave_idx_type> iz (dim_vector (nr, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
-                  F77_XFCN (dgbcon, DGBCON, 
+                  F77_XFCN (dgbcon, DGBCON,
                     (F77_CONST_CHAR_ARG2 (&job, 1),
                      nc, n_lower, n_upper, tmp_data, ldm, pipvt,
                      anorm, rcond, pz, piz, err
                      F77_CHAR_ARG_LEN (1)));
 
-                   if (err != 0) 
+                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcond))
                     {
                       err = -2;
 
@@ -5646,37 +5646,37 @@ SparseMatrix::bsolve (MatrixType &mattyp
 
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
                       for (octave_idx_type i = 0; i < nr; i++)
                         {
                           Bx[i] = 0.;
                           Bz[i] = 0.;
                         }
-                      for (octave_idx_type i = b.cidx(j); 
+                      for (octave_idx_type i = b.cidx(j);
                            i < b.cidx(j+1); i++)
                         {
                           Complex c = b.data(i);
                           Bx[b.ridx(i)] = std::real (c);
                           Bz[b.ridx(i)] = std::imag (c);
                         }
 
-                      F77_XFCN (dgbtrs, DGBTRS, 
+                      F77_XFCN (dgbtrs, DGBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, n_upper, 1, tmp_data,
                                  ldm, pipvt, Bx, b.rows (), err
                                  F77_CHAR_ARG_LEN (1)));
 
-                      F77_XFCN (dgbtrs, DGBTRS, 
+                      F77_XFCN (dgbtrs, DGBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, n_upper, 1, tmp_data,
                                  ldm, pipvt, Bz, b.rows (), err
                                  F77_CHAR_ARG_LEN (1)));
 
-                      // Count non-zeros in work vector and adjust 
+                      // Count non-zeros in work vector and adjust
                       // space in retval if needed
                       octave_idx_type new_nnz = 0;
                       for (octave_idx_type i = 0; i < nr; i++)
                         if (Bx[i] != 0. || Bz[i] != 0.)
                           new_nnz++;
 
                       if (ii + new_nnz > x_nz)
                         {
@@ -5685,30 +5685,30 @@ SparseMatrix::bsolve (MatrixType &mattyp
                           retval.change_capacity (sz);
                           x_nz = sz;
                         }
 
                       for (octave_idx_type i = 0; i < nr; i++)
                         if (Bx[i] != 0. || Bz[i] != 0.)
                           {
                             retval.xridx(ii) = i;
-                            retval.xdata(ii++) = 
+                            retval.xdata(ii++) =
                               Complex (Bx[i], Bz[i]);
                           }
                       retval.xcidx(j+1) = ii;
                     }
 
                   retval.maybe_compress ();
                 }
             }
         }
       else if (typ != MatrixType::Banded_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
-  
+
   return retval;
 }
 
 void *
 SparseMatrix::factorize (octave_idx_type& err, double &rcond, Matrix &Control,
                          Matrix &Info, solve_singularity_handler sing_handler,
                          bool calc_cond) const
 {
@@ -5750,17 +5750,17 @@ SparseMatrix::factorize (octave_idx_type
   void *Symbolic;
   Info = Matrix (1, UMFPACK_INFO);
   double *info = Info.fortran_vec ();
   int status = UMFPACK_DNAME (qsymbolic) (nr, nc, Ap, Ai, Ax, 0,
                                      &Symbolic, control, info);
 
   if (status < 0)
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
         ("SparseMatrix::solve symbolic factorization failed");
       err = -1;
 
       UMFPACK_DNAME (report_status) (control, status);
       UMFPACK_DNAME (report_info) (control, info);
 
       UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
     }
@@ -5773,39 +5773,39 @@ SparseMatrix::factorize (octave_idx_type
       UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
 
       if (calc_cond)
         rcond = Info (UMFPACK_RCOND);
       else
         rcond = 1.;
       volatile double rcond_plus_one = rcond + 1.0;
 
-      if (status == UMFPACK_WARNING_singular_matrix || 
+      if (status == UMFPACK_WARNING_singular_matrix ||
           rcond_plus_one == 1.0 || xisnan (rcond))
         {
           UMFPACK_DNAME (report_numeric) (Numeric, control);
 
           err = -2;
 
           if (sing_handler)
             sing_handler (rcond);
           else
             (*current_liboctave_error_handler)
               ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
                rcond);
 
         }
       else if (status < 0)
           {
-            (*current_liboctave_error_handler) 
+            (*current_liboctave_error_handler)
               ("SparseMatrix::solve numeric factorization failed");
 
             UMFPACK_DNAME (report_status) (control, status);
             UMFPACK_DNAME (report_info) (control, info);
-              
+
             err = -1;
           }
         else
           {
             UMFPACK_DNAME (report_numeric) (Numeric, control);
           }
     }
 
@@ -5816,17 +5816,17 @@ SparseMatrix::factorize (octave_idx_type
   (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 
   return Numeric;
 }
 
 Matrix
 SparseMatrix::fsolve (MatrixType &mattype, const Matrix& b,
-                      octave_idx_type& err, double& rcond, 
+                      octave_idx_type& err, double& rcond,
                       solve_singularity_handler sing_handler,
                       bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   err = 0;
@@ -5939,17 +5939,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
                     (*current_liboctave_error_handler)
                       ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
                        rcond);
-              
+
                   return retval;
                 }
 
               cholmod_dense *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
@@ -5977,17 +5977,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
           typ = MatrixType::Full;
 #endif
         }
 
       if (typ == MatrixType::Full)
         {
 #ifdef HAVE_UMFPACK
           Matrix Control, Info;
-          void *Numeric = 
+          void *Numeric =
             factorize (err, rcond, Control, Info, sing_handler, calc_cond);
 
           if (err == 0)
             {
               const double *Bx = b.fortran_vec ();
               retval.resize (b.rows (), b.cols());
               double *result = retval.fortran_vec ();
               octave_idx_type b_nr = b.rows ();
@@ -5996,47 +5996,47 @@ SparseMatrix::fsolve (MatrixType &mattyp
               double *control = Control.fortran_vec ();
               double *info = Info.fortran_vec ();
               const octave_idx_type *Ap = cidx ();
               const octave_idx_type *Ai = ridx ();
               const double *Ax = data ();
 
               for (octave_idx_type j = 0, iidx = 0; j < b_nc; j++, iidx += b_nr)
                 {
-                  status = UMFPACK_DNAME (solve) (UMFPACK_A, Ap, 
+                  status = UMFPACK_DNAME (solve) (UMFPACK_A, Ap,
                                              Ai, Ax, &result[iidx], &Bx[iidx],
                                              Numeric, control, info);
                   if (status < 0)
                     {
-                      (*current_liboctave_error_handler) 
+                      (*current_liboctave_error_handler)
                         ("SparseMatrix::solve solve failed");
 
                       UMFPACK_DNAME (report_status) (control, status);
-                      
+
                       err = -1;
-                  
+
                       break;
                     }
                 }
 
               UMFPACK_DNAME (report_info) (control, info);
-                
+
               UMFPACK_DNAME (free_numeric) (&Numeric);
             }
           else
             mattype.mark_as_rectangular ();
 
 #else
           (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
         }
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
-  
+
   return retval;
 }
 
 SparseMatrix
 SparseMatrix::fsolve (MatrixType &mattype, const SparseMatrix& b,
                       octave_idx_type& err, double& rcond,
                       solve_singularity_handler sing_handler,
                       bool calc_cond) const
@@ -6164,32 +6164,32 @@ SparseMatrix::fsolve (MatrixType &mattyp
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
                     (*current_liboctave_error_handler)
                       ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
                        rcond);
-              
+
                   return retval;
                 }
 
               cholmod_sparse *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
-              retval = SparseMatrix (static_cast<octave_idx_type>(X->nrow), 
+              retval = SparseMatrix (static_cast<octave_idx_type>(X->nrow),
                                      static_cast<octave_idx_type>(X->ncol),
                                      static_cast<octave_idx_type>(X->nzmax));
-              for (octave_idx_type j = 0; 
+              for (octave_idx_type j = 0;
                    j <= static_cast<octave_idx_type>(X->ncol); j++)
                 retval.xcidx(j) = static_cast<octave_idx_type *>(X->p)[j];
-              for (octave_idx_type j = 0; 
+              for (octave_idx_type j = 0;
                    j < static_cast<octave_idx_type>(X->nzmax); j++)
                 {
                   retval.xridx(j) = static_cast<octave_idx_type *>(X->i)[j];
                   retval.xdata(j) = static_cast<double *>(X->x)[j];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_sparse) (&X, cm);
@@ -6207,17 +6207,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
           typ = MatrixType::Full;
 #endif
         }
 
       if (typ == MatrixType::Full)
         {
 #ifdef HAVE_UMFPACK
           Matrix Control, Info;
-          void *Numeric = factorize (err, rcond, Control, Info, 
+          void *Numeric = factorize (err, rcond, Control, Info,
                                      sing_handler, calc_cond);
 
           if (err == 0)
             {
               octave_idx_type b_nr = b.rows ();
               octave_idx_type b_nc = b.cols ();
               int status = 0;
               double *control = Control.fortran_vec ();
@@ -6237,31 +6237,31 @@ SparseMatrix::fsolve (MatrixType &mattyp
 
               retval.xcidx(0) = 0;
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
 
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     Bx[i] = b.elem (i, j);
 
-                  status = UMFPACK_DNAME (solve) (UMFPACK_A, Ap, 
-                                             Ai, Ax, Xx, Bx, Numeric, control, 
+                  status = UMFPACK_DNAME (solve) (UMFPACK_A, Ap,
+                                             Ai, Ax, Xx, Bx, Numeric, control,
                                              info);
                   if (status < 0)
                     {
-                      (*current_liboctave_error_handler) 
+                      (*current_liboctave_error_handler)
                         ("SparseMatrix::solve solve failed");
 
                       UMFPACK_DNAME (report_status) (control, status);
-                  
+
                       err = -1;
 
                       break;
                     }
-              
+
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     {
                       double tmp = Xx[i];
                       if (tmp != 0.0)
                         {
                           if (ii == x_nz)
                             {
                               // Resize the sparse matrix
@@ -6288,22 +6288,22 @@ SparseMatrix::fsolve (MatrixType &mattyp
 
 #else
           (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
         }
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
-  
+
   return retval;
 }
 
 ComplexMatrix
-SparseMatrix::fsolve (MatrixType &mattype, const ComplexMatrix& b, 
+SparseMatrix::fsolve (MatrixType &mattype, const ComplexMatrix& b,
                       octave_idx_type& err, double& rcond,
                       solve_singularity_handler sing_handler,
                       bool calc_cond) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -6416,17 +6416,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
                     (*current_liboctave_error_handler)
                       ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
                        rcond);
-              
+
                   return retval;
                 }
 
               cholmod_dense *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(solve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
@@ -6454,17 +6454,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
           typ = MatrixType::Full;
 #endif
         }
 
       if (typ == MatrixType::Full)
         {
 #ifdef HAVE_UMFPACK
           Matrix Control, Info;
-          void *Numeric = factorize (err, rcond, Control, Info, 
+          void *Numeric = factorize (err, rcond, Control, Info,
                                      sing_handler, calc_cond);
 
           if (err == 0)
             {
               octave_idx_type b_nr = b.rows ();
               octave_idx_type b_nc = b.cols ();
               int status = 0;
               double *control = Control.fortran_vec ();
@@ -6475,40 +6475,40 @@ SparseMatrix::fsolve (MatrixType &mattyp
 
               OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
               OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
 
               retval.resize (b_nr, b_nc);
 
               OCTAVE_LOCAL_BUFFER (double, Xx, b_nr);
               OCTAVE_LOCAL_BUFFER (double, Xz, b_nr);
-              
+
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     {
                       Complex c = b (i,j);
                       Bx[i] = std::real (c);
                       Bz[i] = std::imag (c);
                     }
 
-                  status = UMFPACK_DNAME (solve) (UMFPACK_A, Ap, 
-                                             Ai, Ax, Xx, Bx, Numeric, control, 
+                  status = UMFPACK_DNAME (solve) (UMFPACK_A, Ap,
+                                             Ai, Ax, Xx, Bx, Numeric, control,
                                              info);
                   int status2 = UMFPACK_DNAME (solve) (UMFPACK_A,
-                                                  Ap, Ai, Ax, Xz, Bz, Numeric, 
+                                                  Ap, Ai, Ax, Xz, Bz, Numeric,
                                                   control, info) ;
 
                   if (status < 0 || status2 < 0)
                     {
-                      (*current_liboctave_error_handler) 
+                      (*current_liboctave_error_handler)
                         ("SparseMatrix::solve solve failed");
 
                       UMFPACK_DNAME (report_status) (control, status);
-                      
+
                       err = -1;
 
                       break;
                     }
 
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     retval (i, j) = Complex (Xx[i], Xz[i]);
                 }
@@ -6522,22 +6522,22 @@ SparseMatrix::fsolve (MatrixType &mattyp
 
 #else
           (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
         }
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
-  
+
   return retval;
 }
 
 SparseComplexMatrix
-SparseMatrix::fsolve (MatrixType &mattype, const SparseComplexMatrix& b, 
+SparseMatrix::fsolve (MatrixType &mattype, const SparseComplexMatrix& b,
                       octave_idx_type& err, double& rcond,
                       solve_singularity_handler sing_handler,
                       bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -6660,33 +6660,33 @@ SparseMatrix::fsolve (MatrixType &mattyp
                     {
                       sing_handler (rcond);
                       mattype.mark_as_rectangular ();
                     }
                   else
                     (*current_liboctave_error_handler)
                       ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
                        rcond);
-              
+
                   return retval;
                 }
 
               cholmod_sparse *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
-              retval = SparseComplexMatrix 
-                (static_cast<octave_idx_type>(X->nrow), 
+              retval = SparseComplexMatrix
+                (static_cast<octave_idx_type>(X->nrow),
                  static_cast<octave_idx_type>(X->ncol),
                  static_cast<octave_idx_type>(X->nzmax));
-              for (octave_idx_type j = 0; 
+              for (octave_idx_type j = 0;
                    j <= static_cast<octave_idx_type>(X->ncol); j++)
                 retval.xcidx(j) = static_cast<octave_idx_type *>(X->p)[j];
-              for (octave_idx_type j = 0; 
+              for (octave_idx_type j = 0;
                    j < static_cast<octave_idx_type>(X->nzmax); j++)
                 {
                   retval.xridx(j) = static_cast<octave_idx_type *>(X->i)[j];
                   retval.xdata(j) = static_cast<Complex *>(X->x)[j];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_sparse) (&X, cm);
@@ -6704,17 +6704,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
           typ = MatrixType::Full;
 #endif
         }
 
       if (typ == MatrixType::Full)
         {
 #ifdef HAVE_UMFPACK
           Matrix Control, Info;
-          void *Numeric = factorize (err, rcond, Control, Info, 
+          void *Numeric = factorize (err, rcond, Control, Info,
                                      sing_handler, calc_cond);
 
           if (err == 0)
             {
               octave_idx_type b_nr = b.rows ();
               octave_idx_type b_nc = b.cols ();
               int status = 0;
               double *control = Control.fortran_vec ();
@@ -6729,41 +6729,41 @@ SparseMatrix::fsolve (MatrixType &mattyp
               // Take a first guess that the number of non-zero terms
               // will be as many as in b
               octave_idx_type x_nz = b.nnz ();
               octave_idx_type ii = 0;
               retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
 
               OCTAVE_LOCAL_BUFFER (double, Xx, b_nr);
               OCTAVE_LOCAL_BUFFER (double, Xz, b_nr);
-              
+
               retval.xcidx(0) = 0;
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     {
                       Complex c = b (i,j);
                       Bx[i] = std::real (c);
                       Bz[i] = std::imag (c);
                     }
 
                   status = UMFPACK_DNAME (solve) (UMFPACK_A, Ap,
-                                             Ai, Ax, Xx, Bx, Numeric, control, 
+                                             Ai, Ax, Xx, Bx, Numeric, control,
                                              info);
                   int status2 = UMFPACK_DNAME (solve) (UMFPACK_A,
-                                                  Ap, Ai, Ax, Xz, Bz, Numeric, 
+                                                  Ap, Ai, Ax, Xz, Bz, Numeric,
                                                   control, info) ;
 
                   if (status < 0 || status2 < 0)
                     {
-                      (*current_liboctave_error_handler) 
+                      (*current_liboctave_error_handler)
                         ("SparseMatrix::solve solve failed");
 
                       UMFPACK_DNAME (report_status) (control, status);
-                      
+
                       err = -1;
 
                       break;
                     }
 
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     {
                       Complex tmp = Complex (Xx[i], Xz[i]);
@@ -6794,45 +6794,45 @@ SparseMatrix::fsolve (MatrixType &mattyp
             mattype.mark_as_rectangular ();
 #else
           (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
         }
       else if (typ != MatrixType::Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
-  
+
   return retval;
 }
 
 Matrix
 SparseMatrix::solve (MatrixType &mattype, const Matrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 Matrix
-SparseMatrix::solve (MatrixType &mattype, const Matrix& b, 
+SparseMatrix::solve (MatrixType &mattype, const Matrix& b,
                      octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 Matrix
-SparseMatrix::solve (MatrixType &mattype, const Matrix& b, octave_idx_type& info, 
+SparseMatrix::solve (MatrixType &mattype, const Matrix& b, octave_idx_type& info,
                      double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 Matrix
-SparseMatrix::solve (MatrixType &mattype, const Matrix& b, octave_idx_type& err, 
+SparseMatrix::solve (MatrixType &mattype, const Matrix& b, octave_idx_type& err,
                      double& rcond, solve_singularity_handler sing_handler,
                      bool singular_fallback) const
 {
   Matrix retval;
   int typ = mattype.type (false);
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
@@ -6841,17 +6841,17 @@ SparseMatrix::solve (MatrixType &mattype
   if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     retval = dsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == MatrixType::Tridiagonal || 
+  else if (typ == MatrixType::Tridiagonal ||
            typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return Matrix ();
@@ -6875,32 +6875,32 @@ SparseMatrix
 SparseMatrix::solve (MatrixType &mattype, const SparseMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseMatrix
-SparseMatrix::solve (MatrixType &mattype, const SparseMatrix& b, 
+SparseMatrix::solve (MatrixType &mattype, const SparseMatrix& b,
                      octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseMatrix
 SparseMatrix::solve (MatrixType &mattype, const SparseMatrix& b,
                      octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseMatrix
-SparseMatrix::solve (MatrixType &mattype, const SparseMatrix& b, 
+SparseMatrix::solve (MatrixType &mattype, const SparseMatrix& b,
                      octave_idx_type& err, double& rcond,
                      solve_singularity_handler sing_handler,
                      bool singular_fallback) const
 {
   SparseMatrix retval;
   int typ = mattype.type (false);
 
   if (typ == MatrixType::Unknown)
@@ -6909,67 +6909,67 @@ SparseMatrix::solve (MatrixType &mattype
   if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     retval = dsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == MatrixType::Tridiagonal || 
+  else if (typ == MatrixType::Tridiagonal ||
            typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return SparseMatrix ();
     }
 
   if (singular_fallback && mattype.type (false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
-      retval = dmsolve<SparseMatrix, SparseMatrix, 
+      retval = dmsolve<SparseMatrix, SparseMatrix,
         SparseMatrix> (*this, b, err);
 #endif
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseMatrix::solve (MatrixType &mattype, const ComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseMatrix::solve (MatrixType &mattype, const ComplexMatrix& b, 
+SparseMatrix::solve (MatrixType &mattype, const ComplexMatrix& b,
                             octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseMatrix::solve (MatrixType &mattype, const ComplexMatrix& b, 
+SparseMatrix::solve (MatrixType &mattype, const ComplexMatrix& b,
                      octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseMatrix::solve (MatrixType &mattype, const ComplexMatrix& b, 
-                     octave_idx_type& err, double& rcond, 
+SparseMatrix::solve (MatrixType &mattype, const ComplexMatrix& b,
+                     octave_idx_type& err, double& rcond,
                      solve_singularity_handler sing_handler,
                      bool singular_fallback) const
 {
   ComplexMatrix retval;
   int typ = mattype.type (false);
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
@@ -6977,66 +6977,66 @@ SparseMatrix::solve (MatrixType &mattype
   if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     retval = dsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == MatrixType::Tridiagonal || 
+  else if (typ == MatrixType::Tridiagonal ||
            typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return ComplexMatrix ();
     }
 
   if (singular_fallback && mattype.type(false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
-      retval = dmsolve<ComplexMatrix, SparseMatrix, 
+      retval = dmsolve<ComplexMatrix, SparseMatrix,
         ComplexMatrix> (*this, b, err);
 #endif
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseMatrix::solve (MatrixType &mattype, const SparseComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
-SparseMatrix::solve (MatrixType &mattype, const SparseComplexMatrix& b, 
+SparseMatrix::solve (MatrixType &mattype, const SparseComplexMatrix& b,
                      octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseMatrix::solve (MatrixType &mattype, const SparseComplexMatrix& b,
                      octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
-SparseMatrix::solve (MatrixType &mattype, const SparseComplexMatrix& b, 
+SparseMatrix::solve (MatrixType &mattype, const SparseComplexMatrix& b,
                      octave_idx_type& err, double& rcond,
                      solve_singularity_handler sing_handler,
                      bool singular_fallback) const
 {
   SparseComplexMatrix retval;
   int typ = mattype.type (false);
 
   if (typ == MatrixType::Unknown)
@@ -7045,34 +7045,34 @@ SparseMatrix::solve (MatrixType &mattype
   if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     retval = dsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Banded || typ == MatrixType::Banded_Hermitian)
     retval = bsolve (mattype, b, err, rcond, sing_handler, false);
-  else if (typ == MatrixType::Tridiagonal || 
+  else if (typ == MatrixType::Tridiagonal ||
            typ == MatrixType::Tridiagonal_Hermitian)
     retval = trisolve (mattype, b, err, rcond, sing_handler, false);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, err, rcond, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return SparseComplexMatrix ();
     }
 
   if (singular_fallback && mattype.type(false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
-      retval = dmsolve<SparseComplexMatrix, SparseMatrix, 
+      retval = dmsolve<SparseComplexMatrix, SparseMatrix,
         SparseComplexMatrix> (*this, b, err);
 #endif
     }
 
   return retval;
 }
 
 ColumnVector
@@ -7114,17 +7114,17 @@ SparseMatrix::solve (MatrixType &mattype
 ComplexColumnVector
 SparseMatrix::solve (MatrixType &mattype, const ComplexColumnVector& b, octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexColumnVector
-SparseMatrix::solve (MatrixType &mattype, const ComplexColumnVector& b, octave_idx_type& info, 
+SparseMatrix::solve (MatrixType &mattype, const ComplexColumnVector& b, octave_idx_type& info,
                      double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexColumnVector
 SparseMatrix::solve (MatrixType &mattype, const ComplexColumnVector& b, octave_idx_type& info, double& rcond,
                solve_singularity_handler sing_handler) const
@@ -7144,112 +7144,112 @@ SparseMatrix::solve (const Matrix& b) co
 Matrix
 SparseMatrix::solve (const Matrix& b, octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 Matrix
-SparseMatrix::solve (const Matrix& b, octave_idx_type& info, 
+SparseMatrix::solve (const Matrix& b, octave_idx_type& info,
                      double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 Matrix
-SparseMatrix::solve (const Matrix& b, octave_idx_type& err, 
-                     double& rcond, 
+SparseMatrix::solve (const Matrix& b, octave_idx_type& err,
+                     double& rcond,
                      solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 SparseMatrix
 SparseMatrix::solve (const SparseMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 SparseMatrix
-SparseMatrix::solve (const SparseMatrix& b, 
+SparseMatrix::solve (const SparseMatrix& b,
                      octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 SparseMatrix
 SparseMatrix::solve (const SparseMatrix& b,
                      octave_idx_type& info, double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 SparseMatrix
-SparseMatrix::solve (const SparseMatrix& b, 
+SparseMatrix::solve (const SparseMatrix& b,
                      octave_idx_type& err, double& rcond,
                      solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 ComplexMatrix
-SparseMatrix::solve (const ComplexMatrix& b, 
+SparseMatrix::solve (const ComplexMatrix& b,
                             octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseMatrix::solve (const ComplexMatrix& b, 
+SparseMatrix::solve (const ComplexMatrix& b,
                      octave_idx_type& info, double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseMatrix::solve (const ComplexMatrix& b, 
-                     octave_idx_type& err, double& rcond, 
+SparseMatrix::solve (const ComplexMatrix& b,
+                     octave_idx_type& err, double& rcond,
                      solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 SparseComplexMatrix
 SparseMatrix::solve (const SparseComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
-SparseMatrix::solve (const SparseComplexMatrix& b, 
+SparseMatrix::solve (const SparseComplexMatrix& b,
                      octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseMatrix::solve (const SparseComplexMatrix& b,
                      octave_idx_type& info, double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
-SparseMatrix::solve (const SparseComplexMatrix& b, 
+SparseMatrix::solve (const SparseComplexMatrix& b,
                      octave_idx_type& err, double& rcond,
                      solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 ColumnVector
@@ -7291,17 +7291,17 @@ SparseMatrix::solve (const ComplexColumn
 ComplexColumnVector
 SparseMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 ComplexColumnVector
-SparseMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info, 
+SparseMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info,
                      double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 ComplexColumnVector
 SparseMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info, double& rcond,
                solve_singularity_handler sing_handler) const
@@ -7449,29 +7449,29 @@ SparseMatrix::too_large_for_float (void)
 
       if (val > FLT_MAX || val < FLT_MIN)
         return true;
     }
 
   return false;
 }
 
-SparseBoolMatrix 
-SparseMatrix::operator ! (void) const 
-{ 
+SparseBoolMatrix
+SparseMatrix::operator ! (void) const
+{
   if (any_element_is_nan ())
     gripe_nan_to_logical_conversion ();
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nz1 = nnz ();
   octave_idx_type nz2 = nr*nc - nz1;
-   
+
   SparseBoolMatrix r (nr, nc, nz2);
-   
+
   octave_idx_type ii = 0;
   octave_idx_type jj = 0;
   r.cidx (0) = 0;
   for (octave_idx_type i = 0; i < nc; i++)
     {
       for (octave_idx_type j = 0; j < nr; j++)
         {
           if (jj < cidx(i+1) && ridx(jj) == j)
@@ -7517,17 +7517,17 @@ SparseMatrix::cumsum (int dim) const
 
 SparseMatrix
 SparseMatrix::prod (int dim) const
 {
   if ((rows() == 1 && dim == -1) || dim == 1)
     return transpose (). prod (0). transpose();
   else
     {
-      SPARSE_REDUCTION_OP (SparseMatrix, double, *=, 
+      SPARSE_REDUCTION_OP (SparseMatrix, double, *=,
                            (cidx(j+1) - cidx(j) < nr ? 0.0 : 1.0), 1.0);
     }
 }
 
 SparseMatrix
 SparseMatrix::sum (int dim) const
 {
   SPARSE_REDUCTION_OP (SparseMatrix, double, +=, 0.0, 0.0);
@@ -7539,17 +7539,17 @@ SparseMatrix::sumsq (int dim) const
 #define ROW_EXPR \
   double d = data (i); \
   tmp[ridx(i)] += d * d
 
 #define COL_EXPR \
   double d = data (i); \
   tmp[j] += d * d
 
-  SPARSE_BASE_REDUCTION_OP (SparseMatrix, double, ROW_EXPR, COL_EXPR, 
+  SPARSE_BASE_REDUCTION_OP (SparseMatrix, double, ROW_EXPR, COL_EXPR,
                             0.0, 0.0);
 
 #undef ROW_EXPR
 #undef COL_EXPR
 }
 
 SparseMatrix
 SparseMatrix::abs (void) const
@@ -7601,19 +7601,19 @@ std::istream&
 operator >> (std::istream& is, SparseMatrix& a)
 {
   typedef SparseMatrix::element_type elt_type;
 
   return read_sparse_matrix<elt_type> (is, a, octave_read_value<double>);
 }
 
 SparseMatrix
-SparseMatrix::squeeze (void) const 
-{ 
-  return MSparse<double>::squeeze (); 
+SparseMatrix::squeeze (void) const
+{
+  return MSparse<double>::squeeze ();
 }
 
 SparseMatrix
 SparseMatrix::reshape (const dim_vector& new_dims) const
 {
   return MSparse<double>::reshape (new_dims);
 }
 
@@ -7783,42 +7783,42 @@ min (const SparseMatrix& m, double d)
   return min (d, m);
 }
 
 SparseMatrix
 min (const SparseMatrix& a, const SparseMatrix& b)
 {
   SparseMatrix r;
 
-  if ((a.rows() == b.rows()) && (a.cols() == b.cols())) 
+  if ((a.rows() == b.rows()) && (a.cols() == b.cols()))
     {
       octave_idx_type a_nr = a.rows ();
       octave_idx_type a_nc = a.cols ();
 
       octave_idx_type b_nr = b.rows ();
       octave_idx_type b_nc = b.cols ();
 
       if (a_nr != b_nr || a_nc != b_nc)
         gripe_nonconformant ("min", a_nr, a_nc, b_nr, b_nc);
       else
         {
           r = SparseMatrix (a_nr, a_nc, (a.nnz () + b.nnz ()));
-       
+
           octave_idx_type jx = 0;
           r.cidx (0) = 0;
           for (octave_idx_type i = 0 ; i < a_nc ; i++)
             {
               octave_idx_type  ja = a.cidx(i);
               octave_idx_type  ja_max = a.cidx(i+1);
               bool ja_lt_max= ja < ja_max;
-           
+
               octave_idx_type  jb = b.cidx(i);
               octave_idx_type  jb_max = b.cidx(i+1);
               bool jb_lt_max = jb < jb_max;
-           
+
               while (ja_lt_max || jb_lt_max )
                 {
                   octave_quit ();
                   if ((! jb_lt_max) ||
                       (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
                     {
                       double tmp = xmin (a.data(ja), 0.);
                       if (tmp != 0.)
@@ -7855,17 +7855,17 @@ min (const SparseMatrix& a, const Sparse
                       ja++;
                       ja_lt_max= ja < ja_max;
                       jb++;
                       jb_lt_max= jb < jb_max;
                     }
                 }
               r.cidx(i+1) = jx;
             }
-          
+
           r.maybe_compress ();
         }
     }
   else
     (*current_liboctave_error_handler) ("matrix size mismatch");
 
   return r;
 }
@@ -7933,42 +7933,42 @@ max (const SparseMatrix& m, double d)
   return max (d, m);
 }
 
 SparseMatrix
 max (const SparseMatrix& a, const SparseMatrix& b)
 {
   SparseMatrix r;
 
-  if ((a.rows() == b.rows()) && (a.cols() == b.cols())) 
+  if ((a.rows() == b.rows()) && (a.cols() == b.cols()))
     {
       octave_idx_type a_nr = a.rows ();
       octave_idx_type a_nc = a.cols ();
 
       octave_idx_type b_nr = b.rows ();
       octave_idx_type b_nc = b.cols ();
 
       if (a_nr != b_nr || a_nc != b_nc)
         gripe_nonconformant ("min", a_nr, a_nc, b_nr, b_nc);
       else
         {
           r = SparseMatrix (a_nr, a_nc, (a.nnz () + b.nnz ()));
-       
+
           octave_idx_type jx = 0;
           r.cidx (0) = 0;
           for (octave_idx_type i = 0 ; i < a_nc ; i++)
             {
               octave_idx_type  ja = a.cidx(i);
               octave_idx_type  ja_max = a.cidx(i+1);
               bool ja_lt_max= ja < ja_max;
-           
+
               octave_idx_type  jb = b.cidx(i);
               octave_idx_type  jb_max = b.cidx(i+1);
               bool jb_lt_max = jb < jb_max;
-           
+
               while (ja_lt_max || jb_lt_max )
                 {
                   octave_quit ();
                   if ((! jb_lt_max) ||
                       (ja_lt_max && (a.ridx(ja) < b.ridx(jb))))
                     {
                       double tmp = xmax (a.data(ja), 0.);
                       if (tmp != 0.)
@@ -8005,17 +8005,17 @@ max (const SparseMatrix& a, const Sparse
                       ja++;
                       ja_lt_max= ja < ja_max;
                       jb++;
                       jb_lt_max= jb < jb_max;
                     }
                 }
               r.cidx(i+1) = jx;
             }
-          
+
           r.maybe_compress ();
         }
     }
   else
     (*current_liboctave_error_handler) ("matrix size mismatch");
 
   return r;
 }
diff --git a/liboctave/dSparse.h b/liboctave/dSparse.h
--- a/liboctave/dSparse.h
+++ b/liboctave/dSparse.h
@@ -48,39 +48,39 @@ SparseMatrix : public MSparse<double>
  public:
 
   typedef void (*solve_singularity_handler) (double rcond);
 
   SparseMatrix (void) : MSparse<double> () { }
 
   SparseMatrix (octave_idx_type r, octave_idx_type c) : MSparse<double> (r, c) { }
 
-  SparseMatrix (const dim_vector& dv, octave_idx_type nz = 0) : 
+  SparseMatrix (const dim_vector& dv, octave_idx_type nz = 0) :
     MSparse<double> (dv, nz) { }
 
-  explicit SparseMatrix (octave_idx_type r, octave_idx_type c, double val) 
+  explicit SparseMatrix (octave_idx_type r, octave_idx_type c, double val)
     : MSparse<double> (r, c, val) { }
 
   SparseMatrix (const SparseMatrix& a) : MSparse<double> (a) { }
 
-  SparseMatrix (const SparseMatrix& a, const dim_vector& dv) 
+  SparseMatrix (const SparseMatrix& a, const dim_vector& dv)
     : MSparse<double> (a, dv) { }
 
   SparseMatrix (const MSparse<double>& a) : MSparse<double> (a) { }
 
   SparseMatrix (const Sparse<double>& a) : MSparse<double> (a) { }
 
   explicit SparseMatrix (const SparseBoolMatrix& a);
 
   explicit SparseMatrix (const Matrix& a) : MSparse<double> (a) { }
 
   explicit SparseMatrix (const NDArray& a) : MSparse<double> (a) { }
 
-  SparseMatrix (const Array<double>& a, const idx_vector& r, 
-                const idx_vector& c, octave_idx_type nr = -1, 
+  SparseMatrix (const Array<double>& a, const idx_vector& r,
+                const idx_vector& c, octave_idx_type nr = -1,
                 octave_idx_type nc = -1, bool sum_terms = true,
                 octave_idx_type nzm = -1)
     : MSparse<double> (a, r, c, nr, nc, sum_terms, nzm) { }
 
   explicit SparseMatrix (const DiagMatrix& a);
 
   explicit SparseMatrix (const PermMatrix& a);
 
@@ -96,17 +96,17 @@ SparseMatrix : public MSparse<double>
   bool operator != (const SparseMatrix& a) const;
 
   bool is_symmetric (void) const;
 
   SparseMatrix max (int dim = -1) const;
   SparseMatrix max (Array<octave_idx_type>& index, int dim = -1) const;
   SparseMatrix min (int dim = -1) const;
   SparseMatrix min (Array<octave_idx_type>& index, int dim = -1) const;
-  
+
   // destructive insert/delete/reorder operations
 
   SparseMatrix& insert (const SparseMatrix& a, octave_idx_type r, octave_idx_type c);
 
   SparseMatrix& insert (const SparseMatrix& a, const Array<octave_idx_type>& indx);
 
   SparseMatrix concat (const SparseMatrix& rb, const Array<octave_idx_type>& ra_idx);
   SparseComplexMatrix concat (const SparseComplexMatrix& rb,
@@ -114,259 +114,259 @@ SparseMatrix : public MSparse<double>
 
   friend OCTAVE_API SparseMatrix real (const SparseComplexMatrix& a);
   friend OCTAVE_API SparseMatrix imag (const SparseComplexMatrix& a);
 
   friend OCTAVE_API SparseMatrix atan2 (const double& x, const SparseMatrix& y);
   friend OCTAVE_API SparseMatrix atan2 (const SparseMatrix& x, const double& y);
   friend OCTAVE_API SparseMatrix atan2 (const SparseMatrix& x, const SparseMatrix& y);
 
-  SparseMatrix transpose (void) const 
-    { 
-      return MSparse<double>::transpose (); 
+  SparseMatrix transpose (void) const
+    {
+      return MSparse<double>::transpose ();
     }
   SparseMatrix hermitian (void) const { return transpose (); }
 
   // extract row or column i.
 
   RowVector row (octave_idx_type i) const;
 
   ColumnVector column (octave_idx_type i) const;
 
 private:
-  SparseMatrix dinverse (MatrixType &mattyp, octave_idx_type& info, 
-                         double& rcond, const bool force = false, 
+  SparseMatrix dinverse (MatrixType &mattyp, octave_idx_type& info,
+                         double& rcond, const bool force = false,
                          const bool calccond = true) const;
 
-  SparseMatrix tinverse (MatrixType &mattyp, octave_idx_type& info, 
-                         double& rcond, const bool force = false, 
+  SparseMatrix tinverse (MatrixType &mattyp, octave_idx_type& info,
+                         double& rcond, const bool force = false,
                          const bool calccond = true) const;
 
 public:
   SparseMatrix inverse (void) const;
   SparseMatrix inverse (MatrixType& mattype) const;
   SparseMatrix inverse (MatrixType& mattype, octave_idx_type& info) const;
-  SparseMatrix inverse (MatrixType& mattype, octave_idx_type& info, 
+  SparseMatrix inverse (MatrixType& mattype, octave_idx_type& info,
                         double& rcond, int force = 0, int calc_cond = 1) const;
 
   DET determinant (void) const;
   DET determinant (octave_idx_type& info) const;
   DET determinant (octave_idx_type& info, double& rcond, int calc_cond = 1) const;
 
 private:
   // Diagonal matrix solvers
   Matrix dsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
                 double& rcond, solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
   ComplexMatrix dsolve (MatrixType &typ, const ComplexMatrix& b,
-                octave_idx_type& info, double& rcond, 
-                solve_singularity_handler sing_handler, 
+                octave_idx_type& info, double& rcond,
+                solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
   SparseMatrix dsolve (MatrixType &typ, const SparseMatrix& b,
-                octave_idx_type& info, double& rcond, 
+                octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
   SparseComplexMatrix dsolve (MatrixType &typ, const SparseComplexMatrix& b,
-                octave_idx_type& info, double& rcond, 
+                octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
   // Upper triangular matrix solvers
   Matrix utsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
                 double& rcond, solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
   ComplexMatrix utsolve (MatrixType &typ, const ComplexMatrix& b,
-                octave_idx_type& info, double& rcond, 
+                octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
   SparseMatrix utsolve (MatrixType &typ, const SparseMatrix& b,
                 octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
   SparseComplexMatrix utsolve (MatrixType &typ, const SparseComplexMatrix& b,
-                octave_idx_type& info, double& rcond, 
+                octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
   // Lower triangular matrix solvers
   Matrix ltsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
                 double& rcond, solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
   ComplexMatrix ltsolve (MatrixType &typ, const ComplexMatrix& b,
-                octave_idx_type& info, double& rcond, 
+                octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
   SparseMatrix ltsolve (MatrixType &typ, const SparseMatrix& b,
-                octave_idx_type& info, double& rcond, 
+                octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
   SparseComplexMatrix ltsolve (MatrixType &typ, const SparseComplexMatrix& b,
-                octave_idx_type& info, double& rcond, 
+                octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
   // Tridiagonal matrix solvers
   Matrix trisolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
                 double& rcond, solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
   ComplexMatrix trisolve (MatrixType &typ, const ComplexMatrix& b,
-                octave_idx_type& info, double& rcond, 
+                octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
   SparseMatrix trisolve (MatrixType &typ, const SparseMatrix& b,
                 octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
   SparseComplexMatrix trisolve (MatrixType &typ, const SparseComplexMatrix& b,
-                octave_idx_type& info, double& rcond, 
+                octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
   // Banded matrix solvers (umfpack/cholesky)
   Matrix bsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
                 double& rcond, solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
   ComplexMatrix bsolve (MatrixType &typ, const ComplexMatrix& b,
-                octave_idx_type& info, double& rcond, 
+                octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
   SparseMatrix bsolve (MatrixType &typ, const SparseMatrix& b,
-                octave_idx_type& info, double& rcond, 
+                octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
   SparseComplexMatrix bsolve (MatrixType &typ, const SparseComplexMatrix& b,
-                octave_idx_type& info, double& rcond, 
+                octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
   // Full matrix solvers (umfpack/cholesky)
   void * factorize (octave_idx_type& err, double &rcond, Matrix &Control,
                     Matrix &Info, solve_singularity_handler sing_handler,
                     bool calc_cond = false) const;
 
   Matrix fsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
                 double& rcond, solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
   ComplexMatrix fsolve (MatrixType &typ, const ComplexMatrix& b,
-                octave_idx_type& info, double& rcond, 
+                octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
   SparseMatrix fsolve (MatrixType &typ, const SparseMatrix& b,
-                octave_idx_type& info, double& rcond, 
+                octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
   SparseComplexMatrix fsolve (MatrixType &typ, const SparseComplexMatrix& b,
-                octave_idx_type& info, double& rcond, 
+                octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler,
                 bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
   Matrix solve (MatrixType &typ, const Matrix& b) const;
   Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info) const;
-  Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info, 
+  Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
                 double& rcond) const;
   Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
                 double& rcond, solve_singularity_handler sing_handler,
                 bool singular_fallback = true) const;
 
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b) const;
-  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
+  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b,
                        octave_idx_type& info) const;
-  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
+  ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b,
                        octave_idx_type& info, double& rcond) const;
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b,
-                       octave_idx_type& info, double& rcond, 
+                       octave_idx_type& info, double& rcond,
                        solve_singularity_handler sing_handler,
                        bool singular_fallback = true) const;
 
   SparseMatrix solve (MatrixType &typ, const SparseMatrix& b) const;
-  SparseMatrix solve (MatrixType &typ, const SparseMatrix& b, 
+  SparseMatrix solve (MatrixType &typ, const SparseMatrix& b,
                       octave_idx_type& info) const;
   SparseMatrix solve (MatrixType &typ, const SparseMatrix& b,
                       octave_idx_type& info, double& rcond) const;
   SparseMatrix solve (MatrixType &typ, const SparseMatrix& b,
-                      octave_idx_type& info, double& rcond, 
+                      octave_idx_type& info, double& rcond,
                       solve_singularity_handler sing_handler,
                       bool singular_fallback = true) const;
 
-  SparseComplexMatrix solve (MatrixType &typ, 
+  SparseComplexMatrix solve (MatrixType &typ,
                              const SparseComplexMatrix& b) const;
-  SparseComplexMatrix solve (MatrixType &typ, const SparseComplexMatrix& b, 
+  SparseComplexMatrix solve (MatrixType &typ, const SparseComplexMatrix& b,
                              octave_idx_type& info) const;
-  SparseComplexMatrix solve (MatrixType &typ, const SparseComplexMatrix& b, 
+  SparseComplexMatrix solve (MatrixType &typ, const SparseComplexMatrix& b,
                              octave_idx_type& info, double& rcond) const;
   SparseComplexMatrix solve (MatrixType &typ, const SparseComplexMatrix& b,
-                             octave_idx_type& info, double& rcond, 
+                             octave_idx_type& info, double& rcond,
                              solve_singularity_handler sing_handler,
                              bool singular_fallabck = true) const;
 
   ColumnVector solve (MatrixType &typ, const ColumnVector& b) const;
-  ColumnVector solve (MatrixType &typ, const ColumnVector& b, 
+  ColumnVector solve (MatrixType &typ, const ColumnVector& b,
                       octave_idx_type& info) const;
-  ColumnVector solve (MatrixType &typ, const ColumnVector& b, 
+  ColumnVector solve (MatrixType &typ, const ColumnVector& b,
                       octave_idx_type& info, double& rcond) const;
   ColumnVector solve (MatrixType &typ, const ColumnVector& b,
-                      octave_idx_type& info, double& rcond, 
+                      octave_idx_type& info, double& rcond,
                       solve_singularity_handler sing_handler) const;
 
-  ComplexColumnVector solve (MatrixType &typ, 
+  ComplexColumnVector solve (MatrixType &typ,
                              const ComplexColumnVector& b) const;
-  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b, 
+  ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b,
                              octave_idx_type& info) const;
   ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b,
                              octave_idx_type& info, double& rcond) const;
   ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b,
                              octave_idx_type& info, double& rcond,
                              solve_singularity_handler sing_handler) const;
 
   // Generic interface to solver with probing of type
   Matrix solve (const Matrix& b) const;
   Matrix solve (const Matrix& b, octave_idx_type& info) const;
   Matrix solve (const Matrix& b, octave_idx_type& info, double& rcond) const;
   Matrix solve (const Matrix& b, octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler) const;
 
   ComplexMatrix solve (const ComplexMatrix& b) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info) const;
-  ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, 
+  ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info,
                        double& rcond) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, double& rcond,
                        solve_singularity_handler sing_handler) const;
 
   SparseMatrix solve (const SparseMatrix& b) const;
   SparseMatrix solve (const SparseMatrix& b, octave_idx_type& info) const;
-  SparseMatrix solve (const SparseMatrix& b, octave_idx_type& info, 
+  SparseMatrix solve (const SparseMatrix& b, octave_idx_type& info,
                       double& rcond) const;
   SparseMatrix solve (const SparseMatrix& b, octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler) const;
 
   SparseComplexMatrix solve (const SparseComplexMatrix& b) const;
   SparseComplexMatrix solve (const SparseComplexMatrix& b, octave_idx_type& info) const;
-  SparseComplexMatrix solve (const SparseComplexMatrix& b, octave_idx_type& info, 
+  SparseComplexMatrix solve (const SparseComplexMatrix& b, octave_idx_type& info,
                              double& rcond) const;
-  SparseComplexMatrix solve (const SparseComplexMatrix& b, octave_idx_type& info, 
+  SparseComplexMatrix solve (const SparseComplexMatrix& b, octave_idx_type& info,
                              double& rcond,
                              solve_singularity_handler sing_handler) const;
 
   ColumnVector solve (const ColumnVector& b) const;
   ColumnVector solve (const ColumnVector& b, octave_idx_type& info) const;
   ColumnVector solve (const ColumnVector& b, octave_idx_type& info, double& rcond) const;
   ColumnVector solve (const ColumnVector& b, octave_idx_type& info, double& rcond,
                       solve_singularity_handler sing_handler) const;
@@ -384,17 +384,17 @@ public:
   bool any_element_is_negative (bool = false) const;
   bool any_element_is_nan (void) const;
   bool any_element_is_inf_or_nan (void) const;
   bool any_element_not_one_or_zero (void) const;
   bool all_elements_are_zero (void) const;
   bool all_elements_are_int_or_inf_or_nan (void) const;
   bool all_integers (double& max_val, double& min_val) const;
   bool too_large_for_float (void) const;
- 
+
   SparseBoolMatrix operator ! (void) const;
 
   SparseBoolMatrix all (int dim = -1) const;
   SparseBoolMatrix any (int dim = -1) const;
 
   SparseMatrix cumprod (int dim = -1) const;
   SparseMatrix cumsum (int dim = -1) const;
   SparseMatrix prod (int dim = -1) const;
@@ -423,25 +423,25 @@ public:
 
 // Publish externally used friend functions.
 
 extern OCTAVE_API SparseMatrix real (const SparseComplexMatrix& a);
 extern OCTAVE_API SparseMatrix imag (const SparseComplexMatrix& a);
 
 // Other operators.
 
-extern OCTAVE_API SparseMatrix operator * (const SparseMatrix& a, 
+extern OCTAVE_API SparseMatrix operator * (const SparseMatrix& a,
                                 const SparseMatrix& b);
-extern OCTAVE_API Matrix operator * (const Matrix& a, 
+extern OCTAVE_API Matrix operator * (const Matrix& a,
                                 const SparseMatrix& b);
-extern OCTAVE_API Matrix mul_trans (const Matrix& a, 
+extern OCTAVE_API Matrix mul_trans (const Matrix& a,
                                 const SparseMatrix& b);
-extern OCTAVE_API Matrix operator * (const SparseMatrix& a, 
+extern OCTAVE_API Matrix operator * (const SparseMatrix& a,
                                 const Matrix& b);
-extern OCTAVE_API Matrix trans_mul (const SparseMatrix& a, 
+extern OCTAVE_API Matrix trans_mul (const SparseMatrix& a,
                                 const Matrix& b);
 
 extern OCTAVE_API SparseMatrix operator * (const DiagMatrix&, const SparseMatrix&);
 extern OCTAVE_API SparseMatrix operator * (const SparseMatrix&, const DiagMatrix&);
 
 extern OCTAVE_API SparseMatrix operator + (const DiagMatrix&, const SparseMatrix&);
 extern OCTAVE_API SparseMatrix operator + (const SparseMatrix&, const DiagMatrix&);
 extern OCTAVE_API SparseMatrix operator - (const DiagMatrix&, const SparseMatrix&);
diff --git a/liboctave/dbleAEPBAL.h b/liboctave/dbleAEPBAL.h
--- a/liboctave/dbleAEPBAL.h
+++ b/liboctave/dbleAEPBAL.h
@@ -37,15 +37,15 @@ AEPBALANCE : public base_aepbal<Matrix, 
 {
 public:
 
   AEPBALANCE (void) : base_aepbal<Matrix, ColumnVector> () { }
 
   AEPBALANCE (const Matrix& a, bool noperm = false,
               bool noscal = false);
 
-  AEPBALANCE (const AEPBALANCE& a) 
+  AEPBALANCE (const AEPBALANCE& a)
     : base_aepbal<Matrix, ColumnVector> (a) { }
 
   Matrix balancing_matrix (void) const;
 };
 
 #endif
diff --git a/liboctave/dbleCHOL.cc b/liboctave/dbleCHOL.cc
--- a/liboctave/dbleCHOL.cc
+++ b/liboctave/dbleCHOL.cc
@@ -50,17 +50,17 @@ extern "C"
                              const octave_idx_type&, double*,
                              const octave_idx_type&, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dpocon, DPOCON) (F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&, double*,
                              const octave_idx_type&, const double&,
-                             double&, double*, octave_idx_type*, 
+                             double&, double*, octave_idx_type*,
                              octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL);
 #ifdef HAVE_QRUPDATE
 
   F77_RET_T
   F77_FUNC (dch1up, DCH1UP) (const octave_idx_type&, double*,
                              const octave_idx_type&, double*, double*);
 
@@ -108,40 +108,40 @@ CHOL::init (const Matrix& a, bool calc_c
         chol_mat.xelem (i, j) = a(i, j);
       for (octave_idx_type i = j+1; i < n; i++)
         chol_mat.xelem (i, j) = 0.0;
     }
   double *h = chol_mat.fortran_vec ();
 
   // Calculate the norm of the matrix, for later use.
   double anorm = 0;
-  if (calc_cond) 
+  if (calc_cond)
     anorm = xnorm (a, 1);
 
   F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 ("U", 1),
                              n, h, n, info
                              F77_CHAR_ARG_LEN (1)));
 
   xrcond = 0.0;
   if (info > 0)
     chol_mat.resize (info - 1, info - 1);
-  else if (calc_cond) 
+  else if (calc_cond)
     {
       octave_idx_type dpocon_info = 0;
 
       // Now calculate the condition number for non-singular matrix.
       Array<double> z (dim_vector (3*n, 1));
       double *pz = z.fortran_vec ();
       Array<octave_idx_type> iz (dim_vector (n, 1));
       octave_idx_type *piz = iz.fortran_vec ();
       F77_XFCN (dpocon, DPOCON, (F77_CONST_CHAR_ARG2 ("U", 1), n, h,
                                  n, anorm, xrcond, pz, piz, dpocon_info
                                  F77_CHAR_ARG_LEN (1)));
 
-      if (dpocon_info != 0) 
+      if (dpocon_info != 0)
         info = -1;
     }
 
   return info;
 }
 
 static Matrix
 chol2inv_internal (const Matrix& r)
@@ -187,17 +187,17 @@ Matrix
 CHOL::inverse (void) const
 {
   return chol2inv_internal (chol_mat);
 }
 
 void
 CHOL::set (const Matrix& R)
 {
-  if (R.is_square ()) 
+  if (R.is_square ())
     chol_mat = R;
   else
     (*current_liboctave_error_handler) ("CHOL requires square matrix");
 }
 
 #ifdef HAVE_QRUPDATE
 
 void
@@ -241,17 +241,17 @@ CHOL::downdate (const ColumnVector& u)
 }
 
 octave_idx_type
 CHOL::insert_sym (const ColumnVector& u, octave_idx_type j)
 {
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
-  
+
   if (u.length () != n + 1)
     (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
   else if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("cholinsert: index out of range");
   else
     {
       ColumnVector utmp = u;
 
@@ -265,36 +265,36 @@ CHOL::insert_sym (const ColumnVector& u,
 
   return info;
 }
 
 void
 CHOL::delete_sym (octave_idx_type j)
 {
   octave_idx_type n = chol_mat.rows ();
-  
+
   if (j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("choldelete: index out of range");
   else
     {
       OCTAVE_LOCAL_BUFFER (double, w, n);
 
-      F77_XFCN (dchdex, DCHDEX, (n, chol_mat.fortran_vec (), chol_mat.rows (), 
+      F77_XFCN (dchdex, DCHDEX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
                                  j + 1, w));
 
       chol_mat.resize (n-1, n-1);
     }
 }
 
 void
 CHOL::shift_sym (octave_idx_type i, octave_idx_type j)
 {
   octave_idx_type n = chol_mat.rows ();
-  
-  if (i < 0 || i > n-1 || j < 0 || j > n-1) 
+
+  if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("cholshift: index out of range");
   else
     {
       OCTAVE_LOCAL_BUFFER (double, w, 2*n);
 
       F77_XFCN (dchshx, DCHSHX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
                                  i + 1, j + 1, w));
     }
@@ -306,17 +306,17 @@ void
 CHOL::update (const ColumnVector& u)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = chol_mat.rows ();
 
   if (u.length () == n)
     {
-      init (chol_mat.transpose () * chol_mat 
+      init (chol_mat.transpose () * chol_mat
             + Matrix (u) * Matrix (u).transpose (), false);
     }
   else
     (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 }
 
 static bool
 singular (const Matrix& a)
@@ -336,17 +336,17 @@ CHOL::downdate (const ColumnVector& u)
   octave_idx_type n = chol_mat.rows ();
 
   if (u.length () == n)
     {
       if (singular (chol_mat))
         info = 2;
       else
         {
-          info = init (chol_mat.transpose () * chol_mat 
+          info = init (chol_mat.transpose () * chol_mat
                 - Matrix (u) * Matrix (u).transpose (), false);
           if (info) info = 1;
         }
     }
   else
     (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
   return info;
@@ -411,17 +411,17 @@ CHOL::delete_sym (octave_idx_type j)
 
 void
 CHOL::shift_sym (octave_idx_type i, octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = chol_mat.rows ();
 
-  if (i < 0 || i > n-1 || j < 0 || j > n-1) 
+  if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("cholshift: index out of range");
   else
     {
       Matrix a = chol_mat.transpose () * chol_mat;
       Array<octave_idx_type> p (dim_vector (n, 1));
       for (octave_idx_type k = 0; k < n; k++) p(k) = k;
       if (i < j)
         {
diff --git a/liboctave/dbleCHOL.h b/liboctave/dbleCHOL.h
--- a/liboctave/dbleCHOL.h
+++ b/liboctave/dbleCHOL.h
@@ -38,17 +38,17 @@ public:
   CHOL (void) : chol_mat (), xrcond (0) { }
 
   CHOL (const Matrix& a, bool calc_cond = false)
     : chol_mat (), xrcond (0)
     {
       init (a, calc_cond);
     }
 
-  CHOL (const Matrix& a, octave_idx_type& info, bool calc_cond = false) 
+  CHOL (const Matrix& a, octave_idx_type& info, bool calc_cond = false)
     : chol_mat (), xrcond (0)
     {
       info = init (a, calc_cond);
     }
 
   CHOL (const CHOL& a) : chol_mat (a.chol_mat), xrcond (a.xrcond) { }
 
   CHOL& operator = (const CHOL& a)
diff --git a/liboctave/dbleGEPBAL.cc b/liboctave/dbleGEPBAL.cc
--- a/liboctave/dbleGEPBAL.cc
+++ b/liboctave/dbleGEPBAL.cc
@@ -54,32 +54,32 @@ extern "C"
                              octave_idx_type& M, double* V,
                              const octave_idx_type& LDV, octave_idx_type& INFO
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
 }
 
 octave_idx_type
-GEPBALANCE::init (const Matrix& a, const Matrix& b, 
+GEPBALANCE::init (const Matrix& a, const Matrix& b,
                   const std::string& balance_job)
 {
   octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
     {
       (*current_liboctave_error_handler) ("GEPBALANCE requires square matrix");
       return -1;
     }
 
   if (a.dims() != b.dims ())
     {
       gripe_nonconformant ("GEPBALANCE", n, n, b.rows(), b.cols());
       return -1;
-    } 
+    }
 
   octave_idx_type info;
   octave_idx_type ilo;
   octave_idx_type ihi;
 
   OCTAVE_LOCAL_BUFFER (double, plscale, n);
   OCTAVE_LOCAL_BUFFER (double, prscale, n);
   OCTAVE_LOCAL_BUFFER (double, pwork, 6 * n);
@@ -110,17 +110,17 @@ GEPBALANCE::init (const Matrix& a, const
 
   // first left
   F77_XFCN (dggbak, DGGBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
                              F77_CONST_CHAR_ARG2 ("L", 1),
                              n, ilo, ihi, plscale, prscale,
                              n, p_balancing_mat, n, info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
-      
+
   // then right
   F77_XFCN (dggbak, DGGBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
                              F77_CONST_CHAR_ARG2 ("R", 1),
                              n, ilo, ihi, plscale, prscale,
                              n, p_balancing_mat2, n, info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
diff --git a/liboctave/dbleGEPBAL.h b/liboctave/dbleGEPBAL.h
--- a/liboctave/dbleGEPBAL.h
+++ b/liboctave/dbleGEPBAL.h
@@ -36,17 +36,17 @@ public:
 
   GEPBALANCE (void)
     : balanced_mat (), balanced_mat2 (), balancing_mat (), balancing_mat2 ()
     { }
 
   GEPBALANCE (const Matrix& a, const Matrix& b, const std::string& balance_job)
     : balanced_mat (), balanced_mat2 (), balancing_mat (), balancing_mat2 ()
     {
-      init (a, b, balance_job); 
+      init (a, b, balance_job);
     }
 
   GEPBALANCE (const GEPBALANCE& a)
     : balanced_mat (a.balanced_mat), balanced_mat2 (a.balanced_mat2),
       balancing_mat (a.balancing_mat), balancing_mat2 (a.balancing_mat2)
     { }
 
   GEPBALANCE& operator = (const GEPBALANCE& a)
@@ -75,13 +75,13 @@ public:
 
 private:
 
   Matrix balanced_mat;
   Matrix balanced_mat2;
   Matrix balancing_mat;
   Matrix balancing_mat2;
 
-  octave_idx_type init (const Matrix& a, const Matrix& b, 
+  octave_idx_type init (const Matrix& a, const Matrix& b,
                         const std::string& balance_job);
 };
 
 #endif
diff --git a/liboctave/dbleQR.cc b/liboctave/dbleQR.cc
--- a/liboctave/dbleQR.cc
+++ b/liboctave/dbleQR.cc
@@ -38,17 +38,17 @@ along with Octave; see the file COPYING.
 template class base_qr<Matrix>;
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dgeqrf, DGEQRF) (const octave_idx_type&, const octave_idx_type&,
                              double*, const octave_idx_type&, double*,
                              double*, const octave_idx_type&,
-                             octave_idx_type&); 
+                             octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (dorgqr, DORGQR) (const octave_idx_type&, const octave_idx_type&,
                              const octave_idx_type&, double*,
                              const octave_idx_type&, double*, double*,
                              const octave_idx_type&, octave_idx_type&);
 
 #ifdef HAVE_QRUPDATE
@@ -69,23 +69,23 @@ extern "C"
   F77_RET_T
   F77_FUNC (dqrdec, DQRDEC) (const octave_idx_type&, const octave_idx_type&,
                              const octave_idx_type&, double*,
                              const octave_idx_type&, double*,
                              const octave_idx_type&, const octave_idx_type&,
                              double*);
 
   F77_RET_T
-  F77_FUNC (dqrinr, DQRINR) (const octave_idx_type&, const octave_idx_type&, 
+  F77_FUNC (dqrinr, DQRINR) (const octave_idx_type&, const octave_idx_type&,
                              double*, const octave_idx_type&, double*,
                              const octave_idx_type&, const octave_idx_type&,
                              const double*, double*);
 
   F77_RET_T
-  F77_FUNC (dqrder, DQRDER) (const octave_idx_type&, const octave_idx_type&, 
+  F77_FUNC (dqrder, DQRDER) (const octave_idx_type&, const octave_idx_type&,
                              double*, const octave_idx_type&, double*,
                              const octave_idx_type&, const octave_idx_type&,
                              double*);
 
   F77_RET_T
   F77_FUNC (dqrshc, DQRSHC) (const octave_idx_type&, const octave_idx_type&,
                              const octave_idx_type&, double*,
                              const octave_idx_type&, double*,
@@ -128,17 +128,17 @@ QR::init (const Matrix& a, qr_type_t qr_
       lwork = std::max (lwork, static_cast<octave_idx_type> (1));
       OCTAVE_LOCAL_BUFFER (double, work, lwork);
       F77_XFCN (dgeqrf, DGEQRF, (m, n, afact.fortran_vec (), m, tau, work, lwork, info));
     }
 
   form (n, afact, tau, qr_type);
 }
 
-void QR::form (octave_idx_type n, Matrix& afact, 
+void QR::form (octave_idx_type n, Matrix& afact,
                double *tau, qr_type_t qr_type)
 {
   octave_idx_type m = afact.rows (), min_mn = std::min (m, n);
   octave_idx_type info;
 
   if (qr_type == qr_type_raw)
     {
       for (octave_idx_type j = 0; j < min_mn; j++)
@@ -246,34 +246,34 @@ void
 QR::insert_col (const ColumnVector& u, octave_idx_type j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
   if (u.length () != m)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (j < 0 || j > n) 
+  else if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       if (k < m)
         {
           q.resize (m, k+1);
           r.resize (k+1, n+1);
         }
       else
         {
           r.resize (k, n+1);
         }
 
       ColumnVector utmp = u;
       OCTAVE_LOCAL_BUFFER (double, w, k);
       F77_XFCN (dqrinc, DQRINC, (m, n, k, q.fortran_vec (), q.rows (),
-                                 r.fortran_vec (), r.rows (), j + 1, 
+                                 r.fortran_vec (), r.rows (), j + 1,
                                  utmp.data (), w));
     }
 }
 
 void
 QR::insert_col (const Matrix& u, const Array<octave_idx_type>& j)
 {
   octave_idx_type m = q.rows ();
@@ -306,32 +306,32 @@ QR::insert_col (const Matrix& u, const A
           r.resize (k, n + nj);
         }
 
       OCTAVE_LOCAL_BUFFER (double, w, kmax);
       for (volatile octave_idx_type i = 0; i < js.length (); i++)
         {
           octave_idx_type ii = i;
           ColumnVector utmp = u.column (jsi(i));
-          F77_XFCN (dqrinc, DQRINC, (m, n + ii, std::min (kmax, k + ii), 
+          F77_XFCN (dqrinc, DQRINC, (m, n + ii, std::min (kmax, k + ii),
                                      q.fortran_vec (), q.rows (),
-                                     r.fortran_vec (), r.rows (), js(ii) + 1, 
+                                     r.fortran_vec (), r.rows (), js(ii) + 1,
                                      utmp.data (), w));
         }
     }
 }
 
 void
 QR::delete_col (octave_idx_type j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type k = r.rows ();
   octave_idx_type n = r.columns ();
 
-  if (j < 0 || j > n-1) 
+  if (j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
   else
     {
       OCTAVE_LOCAL_BUFFER (double, w, k);
       F77_XFCN (dqrdec, DQRDEC, (m, n, k, q.fortran_vec (), q.rows (),
                                  r.fortran_vec (), r.rows (), j + 1, w));
 
       if (k < m)
@@ -365,17 +365,17 @@ QR::delete_col (const Array<octave_idx_t
   else if (nj > 0 && (js(0) > n-1 || js(nj-1) < 0))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else if (nj > 0)
     {
       OCTAVE_LOCAL_BUFFER (double, w, k);
       for (volatile octave_idx_type i = 0; i < js.length (); i++)
         {
           octave_idx_type ii = i;
-          F77_XFCN (dqrdec, DQRDEC, (m, n - ii, k == m ? k : k - ii, 
+          F77_XFCN (dqrdec, DQRDEC, (m, n - ii, k == m ? k : k - ii,
                                      q.fortran_vec (), q.rows (),
                                      r.fortran_vec (), r.rows (), js(ii) + 1, w));
         }
       if (k < m)
         {
           q.resize (m, k - nj);
           r.resize (k - nj, n - nj);
         }
@@ -391,40 +391,40 @@ void
 QR::insert_row (const RowVector& u, octave_idx_type j)
 {
   octave_idx_type m = r.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = std::min (m, n);
 
   if (! q.is_square () || u.length () != n)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (j < 0 || j > m) 
+  else if (j < 0 || j > m)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       q.resize (m + 1, m + 1);
       r.resize (m + 1, n);
       RowVector utmp = u;
       OCTAVE_LOCAL_BUFFER (double, w, k);
       F77_XFCN (dqrinr, DQRINR, (m, n, q.fortran_vec (), q.rows (),
-                                 r.fortran_vec (), r.rows (), 
+                                 r.fortran_vec (), r.rows (),
                                  j + 1, utmp.fortran_vec (), w));
 
     }
 }
 
 void
 QR::delete_row (octave_idx_type j)
 {
   octave_idx_type m = r.rows ();
   octave_idx_type n = r.columns ();
 
   if (! q.is_square ())
     (*current_liboctave_error_handler) ("qrdelete: dimensions mismatch");
-  else if (j < 0 || j > m-1) 
+  else if (j < 0 || j > m-1)
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
   else
     {
       OCTAVE_LOCAL_BUFFER (double, w, 2*m);
       F77_XFCN (dqrder, DQRDER, (m, n, q.fortran_vec (), q.rows (),
                                  r.fortran_vec (), r.rows (), j + 1,
                                  w));
 
@@ -435,22 +435,22 @@ QR::delete_row (octave_idx_type j)
 
 void
 QR::shift_cols (octave_idx_type i, octave_idx_type j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type k = r.rows ();
   octave_idx_type n = r.columns ();
 
-  if (i < 0 || i > n-1 || j < 0 || j > n-1) 
+  if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("qrshift: index out of range");
   else
     {
       OCTAVE_LOCAL_BUFFER (double, w, 2*k);
-      F77_XFCN (dqrshc, DQRSHC, (m, n, k, 
+      F77_XFCN (dqrshc, DQRSHC, (m, n, k,
                                  q.fortran_vec (), q.rows (),
                                  r.fortran_vec (), r.rows (),
                                  i + 1, j + 1, w));
     }
 }
 
 #else
 
@@ -526,17 +526,17 @@ static
 Matrix delete_row (const Matrix& a, octave_idx_type i)
 {
   Matrix retval = a;
   retval.delete_elements (0, idx_vector (i));
   return retval;
 }
 
 static
-Matrix shift_cols (const Matrix& a, 
+Matrix shift_cols (const Matrix& a,
                         octave_idx_type i, octave_idx_type j)
 {
   octave_idx_type n = a.columns ();
   Array<octave_idx_type> p (n);
   for (octave_idx_type k = 0; k < n; k++) p(k) = k;
   if (i < j)
     {
       for (octave_idx_type k = i; k < j; k++) p(k) = k+1;
@@ -556,17 +556,17 @@ QR::insert_col (const ColumnVector& u, o
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
   if (u.length () != m)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (j < 0 || j > n) 
+  else if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       init (::insert_col (q*r, j, u), get_type ());
     }
 }
 
 void
@@ -602,17 +602,17 @@ QR::insert_col (const Matrix& u, const A
 void
 QR::delete_col (octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
-  if (j < 0 || j > n-1) 
+  if (j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
   else
     {
       init (::delete_col (q*r, j), get_type ());
     }
 }
 
 void
@@ -648,49 +648,49 @@ QR::insert_row (const RowVector& u, octa
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = r.rows ();
   octave_idx_type n = r.columns ();
 
   if (! q.is_square () || u.length () != n)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (j < 0 || j > m) 
+  else if (j < 0 || j > m)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       init (::insert_row (q*r, j, u), get_type ());
     }
 }
 
 void
 QR::delete_row (octave_idx_type j)
 {
   octave_idx_type m = r.rows ();
   octave_idx_type n = r.columns ();
 
   if (! q.is_square ())
     (*current_liboctave_error_handler) ("qrdelete: dimensions mismatch");
-  else if (j < 0 || j > m-1) 
+  else if (j < 0 || j > m-1)
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
   else
     {
       init (::delete_row (q*r, j), get_type ());
     }
 }
 
 void
 QR::shift_cols (octave_idx_type i, octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
-  if (i < 0 || i > n-1 || j < 0 || j > n-1) 
+  if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("qrshift: index out of range");
   else
     {
       init (::shift_cols (q*r, i, j), get_type ());
     }
 }
 
 void warn_qrupdate_once (void)
diff --git a/liboctave/dbleQR.h b/liboctave/dbleQR.h
--- a/liboctave/dbleQR.h
+++ b/liboctave/dbleQR.h
@@ -1,12 +1,12 @@
 /*
 
 Copyright (C) 1994-2011 John W. Eaton
-Copyright (C) 2008-2009 Jaroslav Hajek              
+Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -43,17 +43,17 @@ public:
   static const type std = qr_type_std;
   static const type raw = qr_type_raw;
   static const type economy = qr_type_economy;
 
   QR (void) : base_qr<Matrix> () { }
 
   QR (const Matrix&, qr_type_t = qr_type_std);
 
-  QR (const Matrix& qx, const Matrix& rx) 
+  QR (const Matrix& qx, const Matrix& rx)
     : base_qr<Matrix> (qx, rx) { }
 
   QR (const QR& a) : base_qr<Matrix> (a) { }
 
   void init (const Matrix&, qr_type_t);
 
   void update (const ColumnVector& u, const ColumnVector& v);
 
@@ -70,13 +70,13 @@ public:
   void insert_row (const RowVector& u, octave_idx_type j);
 
   void delete_row (octave_idx_type j);
 
   void shift_cols (octave_idx_type i, octave_idx_type j);
 
 protected:
 
-  void form (octave_idx_type n, Matrix& afact, 
+  void form (octave_idx_type n, Matrix& afact,
              double *tau, qr_type_t qr_type);
 };
 
 #endif
diff --git a/liboctave/dbleSCHUR.h b/liboctave/dbleSCHUR.h
--- a/liboctave/dbleSCHUR.h
+++ b/liboctave/dbleSCHUR.h
@@ -37,17 +37,17 @@ public:
   SCHUR (void) : schur_mat (), unitary_mat (), selector (0) { }
 
   SCHUR (const Matrix& a, const std::string& ord, bool calc_unitary = true)
     : schur_mat (), unitary_mat (), selector (0)
     {
       init (a, ord, calc_unitary);
     }
 
-  SCHUR (const Matrix& a, const std::string& ord, int& info, 
+  SCHUR (const Matrix& a, const std::string& ord, int& info,
          bool calc_unitary = true)
     : schur_mat (), unitary_mat (), selector (0)
     {
       info = init (a, ord, calc_unitary);
     }
 
   SCHUR (const SCHUR& a)
     : schur_mat (a.schur_mat), unitary_mat (a.unitary_mat), selector (0)
diff --git a/liboctave/dbleSVD.h b/liboctave/dbleSVD.h
--- a/liboctave/dbleSVD.h
+++ b/liboctave/dbleSVD.h
@@ -44,25 +44,25 @@ public:
   enum driver
     {
       GESVD,
       GESDD
     };
 
   SVD (void) : type_computed (), sigma (), left_sm (), right_sm () { }
 
-  SVD (const Matrix& a, 
-       type svd_type = SVD::std, driver svd_driver = SVD::GESVD) 
+  SVD (const Matrix& a,
+       type svd_type = SVD::std, driver svd_driver = SVD::GESVD)
     : type_computed (), sigma (), left_sm (), right_sm ()
     {
       init (a, svd_type, svd_driver);
     }
 
-  SVD (const Matrix& a, octave_idx_type& info, 
-       type svd_type = SVD::std, driver svd_driver = SVD::GESVD) 
+  SVD (const Matrix& a, octave_idx_type& info,
+       type svd_type = SVD::std, driver svd_driver = SVD::GESVD)
     : type_computed (), sigma (), left_sm (), right_sm ()
     {
       info = init (a, svd_type, svd_driver);
     }
 
   SVD (const SVD& a)
     : type_computed (a.type_computed), sigma (a.sigma),
       left_sm (a.left_sm), right_sm (a.right_sm)
@@ -94,13 +94,13 @@ public:
 private:
 
   SVD::type type_computed;
 
   DiagMatrix sigma;
   Matrix left_sm;
   Matrix right_sm;
 
-  octave_idx_type init (const Matrix& a, 
+  octave_idx_type init (const Matrix& a,
                         type svd_type = std, driver svd_driver = GESVD);
 };
 
 #endif
diff --git a/liboctave/dim-vector.cc b/liboctave/dim-vector.cc
--- a/liboctave/dim-vector.cc
+++ b/liboctave/dim-vector.cc
@@ -103,17 +103,17 @@ dim_vector::safe_numel (void) const
         idx_max /= rep[i];
       if (idx_max <= 0)
         throw std::bad_alloc ();
     }
 
   return n;
 }
 
-dim_vector 
+dim_vector
 dim_vector::squeeze (void) const
 {
   dim_vector new_dims = *this;
 
   bool dims_changed = 1;
 
   int k = 0;
 
@@ -221,22 +221,22 @@ dim_vector::concat (const dim_vector& dv
     }
 
   chop_trailing_singletons ();
 
   return match;
 }
 
 // Rules for horzcat/vertcat are yet looser.
-// two arrays A, B can be concatenated 
+// two arrays A, B can be concatenated
 // horizontally (dim = 2) or vertically (dim = 1) if one of the
 // following holds, in this order:
-// 
+//
 // 1. cat(dim, A, B) works
-// 
+//
 // 2. A, B are 2D and one of them is an empty vector, in which
 // case the result is the other one except if both of them
 // are empty vectors, in which case the result is 0x0.
 
 bool
 dim_vector::hvcat (const dim_vector& dvb, int dim)
 {
   if (concat (dvb, dim))
diff --git a/liboctave/dim-vector.h b/liboctave/dim-vector.h
--- a/liboctave/dim-vector.h
+++ b/liboctave/dim-vector.h
@@ -203,17 +203,17 @@ public:
         while (l > 2 && rep[l-1] == 1);
         ndims () = l;
       }
   }
 
   void chop_all_singletons (void);
 
 private:
-  
+
   static octave_idx_type *nil_rep (void)
     {
       static dim_vector zv (0, 0);
       return zv.rep;
     }
 
   explicit dim_vector (octave_idx_type *r)
     : rep (r) { }
@@ -362,17 +362,17 @@ public:
     return i < n_dims;
   }
 
   dim_vector squeeze (void) const;
 
   // This corresponds to cat().
   bool concat (const dim_vector& dvb, int dim);
 
-  // This corresponds to [,] (horzcat, dim = 0) and [;] (vertcat, dim = 1). 
+  // This corresponds to [,] (horzcat, dim = 0) and [;] (vertcat, dim = 1).
   // The rules are more relaxed here.
   bool hvcat (const dim_vector& dvb, int dim);
 
   // Force certain dimensionality, preserving numel ().  Missing
   // dimensions are set to 1, redundant are folded into the trailing
   // one.  If n = 1, the result is 2d and the second dim is 1
   // (dim_vectors are always at least 2D).  If the original dimensions
   // were all zero, the padding value is zero.
@@ -403,17 +403,17 @@ public:
   int first_non_singleton (int def = 0) const
     {
       for (int i = 0; i < length (); i++)
         {
           if (elem (i) != 1)
             return i;
         }
 
-      return def;      
+      return def;
     }
 
   // Compute a linear index from an index tuple.
 
   octave_idx_type compute_index (const octave_idx_type *idx) const
     {
       octave_idx_type k = 0;
       for (int i = length () - 1; i >= 0; i--)
diff --git a/liboctave/dir-ops.cc b/liboctave/dir-ops.cc
--- a/liboctave/dir-ops.cc
+++ b/liboctave/dir-ops.cc
@@ -45,17 +45,17 @@ dir_entry::open (const std::string& n)
   fail = true;
 
   if (! n.empty ())
     name = n;
 
   if (! name.empty ())
     {
       close ();
-      
+
       std::string fullname = file_ops::tilde_expand (name);
 
       dir = static_cast<void *> (gnulib::opendir (fullname.c_str ()));
 
       if (dir)
         fail = false;
       else
         errmsg = gnulib::strerror (errno);
diff --git a/liboctave/eigs-base.cc b/liboctave/eigs-base.cc
--- a/liboctave/eigs-base.cc
+++ b/liboctave/eigs-base.cc
@@ -41,108 +41,108 @@ along with Octave; see the file COPYING.
 #include "oct-rand.h"
 #include "dbleCHOL.h"
 #include "CmplxCHOL.h"
 #include "dbleLU.h"
 #include "CmplxLU.h"
 
 #ifdef HAVE_ARPACK
 typedef ColumnVector (*EigsFunc) (const ColumnVector &x, int &eigs_error);
-typedef ComplexColumnVector (*EigsComplexFunc) 
+typedef ComplexColumnVector (*EigsComplexFunc)
   (const ComplexColumnVector &x, int &eigs_error);
 
 // Arpack and blas fortran functions we call.
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dsaupd, DSAUPD) (octave_idx_type&,
                              F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&,
-                             F77_CONST_CHAR_ARG_DECL, 
+                             F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&, const double&,
                              double*, const octave_idx_type&, double*,
                              const octave_idx_type&, octave_idx_type*,
-                             octave_idx_type*, double*, double*, 
+                             octave_idx_type*, double*, double*,
                              const octave_idx_type&, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dseupd, DSEUPD) (const octave_idx_type&,
                              F77_CONST_CHAR_ARG_DECL,
                              octave_idx_type*, double*, double*,
                              const octave_idx_type&, const double&,
                              F77_CONST_CHAR_ARG_DECL,
-                             const octave_idx_type&, 
+                             const octave_idx_type&,
                              F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&, const double&, double*,
                              const octave_idx_type&, double*,
                              const octave_idx_type&, octave_idx_type*,
-                             octave_idx_type*, double*, double*, 
+                             octave_idx_type*, double*, double*,
                              const octave_idx_type&, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dnaupd, DNAUPD) (octave_idx_type&,
                              F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&,
-                             F77_CONST_CHAR_ARG_DECL, 
+                             F77_CONST_CHAR_ARG_DECL,
                              octave_idx_type&, const double&,
                              double*, const octave_idx_type&, double*,
                              const octave_idx_type&, octave_idx_type*,
-                             octave_idx_type*, double*, double*, 
+                             octave_idx_type*, double*, double*,
                              const octave_idx_type&, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dneupd, DNEUPD) (const octave_idx_type&,
                              F77_CONST_CHAR_ARG_DECL,
                              octave_idx_type*, double*, double*,
                              double*, const octave_idx_type&, const double&,
                              const double&, double*,
-                             F77_CONST_CHAR_ARG_DECL, 
+                             F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&,
-                             F77_CONST_CHAR_ARG_DECL, 
-                             octave_idx_type&, const double&, double*, 
-                             const octave_idx_type&, double*, 
-                             const octave_idx_type&, octave_idx_type*, 
-                             octave_idx_type*, double*, double*, 
+                             F77_CONST_CHAR_ARG_DECL,
+                             octave_idx_type&, const double&, double*,
+                             const octave_idx_type&, double*,
+                             const octave_idx_type&, octave_idx_type*,
+                             octave_idx_type*, double*, double*,
                              const octave_idx_type&, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (znaupd, ZNAUPD) (octave_idx_type&,
                              F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&,
                              F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&, const double&,
                              Complex*, const octave_idx_type&, Complex*,
                              const octave_idx_type&, octave_idx_type*,
-                             octave_idx_type*, Complex*, Complex*, 
+                             octave_idx_type*, Complex*, Complex*,
                              const octave_idx_type&, double *, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zneupd, ZNEUPD) (const octave_idx_type&,
                              F77_CONST_CHAR_ARG_DECL,
-                             octave_idx_type*, Complex*, Complex*, 
+                             octave_idx_type*, Complex*, Complex*,
                              const octave_idx_type&, const Complex&, Complex*,
                              F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&,
-                             F77_CONST_CHAR_ARG_DECL, 
+                             F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&, const double&,
                              Complex*, const octave_idx_type&, Complex*,
                              const octave_idx_type&, octave_idx_type*,
-                             octave_idx_type*, Complex*, Complex*, 
+                             octave_idx_type*, Complex*, Complex*,
                              const octave_idx_type&, double *, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dgemv, DGEMV) (F77_CONST_CHAR_ARG_DECL,
                            const octave_idx_type&, const octave_idx_type&,
@@ -163,27 +163,27 @@ extern "C"
 }
 
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 static octave_idx_type
 lusolve (const SparseMatrix&, const SparseMatrix&, Matrix&);
 
 static octave_idx_type
-lusolve (const SparseComplexMatrix&, const SparseComplexMatrix&, 
+lusolve (const SparseComplexMatrix&, const SparseComplexMatrix&,
          ComplexMatrix&);
 
 static octave_idx_type
 lusolve (const Matrix&, const Matrix&, Matrix&);
 
 static octave_idx_type
 lusolve (const ComplexMatrix&, const ComplexMatrix&, ComplexMatrix&);
 
 static ComplexMatrix
-ltsolve (const SparseComplexMatrix&, const ColumnVector&, 
+ltsolve (const SparseComplexMatrix&, const ColumnVector&,
                 const ComplexMatrix&);
 
 static Matrix
 ltsolve (const SparseMatrix&, const ColumnVector&, const Matrix&,);
 
 static ComplexMatrix
 ltsolve (const ComplexMatrix&, const ColumnVector&, const ComplexMatrix&);
 
@@ -236,17 +236,17 @@ ltsolve (const SM& L, const ColumnVector
   const double* qv = Q.fortran_vec();
 
   if (!err)
     {
       retval.resize (n, b_nc);
       for (octave_idx_type j = 0; j < b_nc; j++)
         {
           for (octave_idx_type i = 0; i < n; i++)
-            retval.elem(static_cast<octave_idx_type>(qv[i]), j)  = 
+            retval.elem(static_cast<octave_idx_type>(qv[i]), j)  =
               tmp.elem(i,j);
         }
     }
 
   return retval;
 }
 
 template <class SM, class M>
@@ -292,26 +292,26 @@ vector_product (const Matrix& m, const d
 
   F77_XFCN (dgemv, DGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
                            nr, nc, 1.0,  m.data (), nr,
                            x, 1, 0.0, y, 1
                            F77_CHAR_ARG_LEN (1)));
 
   if (f77_exception_encountered)
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
         ("eigs: unrecoverable error in dgemv");
       return false;
     }
   else
     return true;
 }
 
 static bool
-vector_product (const SparseComplexMatrix& m, const Complex* x, 
+vector_product (const SparseComplexMatrix& m, const Complex* x,
                         Complex* y)
 {
   octave_idx_type nc = m.cols ();
 
   for (octave_idx_type j = 0; j < nc; j++)
     y[j] = 0.;
 
   for (octave_idx_type j = 0; j < nc; j++)
@@ -329,17 +329,17 @@ vector_product (const ComplexMatrix& m, 
 
   F77_XFCN (zgemv, ZGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
                            nr, nc, 1.0,  m.data (), nr,
                            x, 1, 0.0, y, 1
                            F77_CHAR_ARG_LEN (1)));
 
   if (f77_exception_encountered)
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
         ("eigs: unrecoverable error in zgemv");
       return false;
     }
   else
     return true;
 }
 
 static bool
@@ -395,17 +395,17 @@ make_cholb (ComplexMatrix& b, ComplexMat
       permB = ColumnVector(n);
       for (octave_idx_type i = 0; i < n; i++)
         permB(i) = i;
       return true;
     }
 }
 
 static bool
-make_cholb (SparseComplexMatrix& b, SparseComplexMatrix& bt, 
+make_cholb (SparseComplexMatrix& b, SparseComplexMatrix& bt,
             ColumnVector& permB)
 {
   octave_idx_type info;
   SparseComplexCHOL fact (b, info, false);
 
   if (fact.P() != 0)
     return false;
   else
@@ -413,19 +413,19 @@ make_cholb (SparseComplexMatrix& b, Spar
       b = fact.L();
       bt = b.hermitian();
       permB = fact.perm() - 1.0;
       return true;
     }
 }
 
 static bool
-LuAminusSigmaB (const SparseMatrix &m, const SparseMatrix &b, 
+LuAminusSigmaB (const SparseMatrix &m, const SparseMatrix &b,
                 bool cholB, const ColumnVector& permB, double sigma,
-                SparseMatrix &L, SparseMatrix &U, octave_idx_type *P, 
+                SparseMatrix &L, SparseMatrix &U, octave_idx_type *P,
                 octave_idx_type *Q)
 {
   bool have_b = ! b.is_empty ();
   octave_idx_type n = m.rows();
 
   // Caclulate LU decomposition of 'A - sigma * B'
   SparseMatrix AminusSigmaB (m);
 
@@ -434,17 +434,17 @@ LuAminusSigmaB (const SparseMatrix &m, c
       if (cholB)
         {
           if (permB.length())
             {
               SparseMatrix tmp(n,n,n);
               for (octave_idx_type i = 0; i < n; i++)
                 {
                   tmp.xcidx(i) = i;
-                  tmp.xridx(i) = 
+                  tmp.xridx(i) =
                     static_cast<octave_idx_type>(permB(i));
                   tmp.xdata(i) = 1;
                 }
               tmp.xcidx(n) = n;
 
               AminusSigmaB = AminusSigmaB - sigma * tmp *
                 b.transpose() * b * tmp.transpose();
             }
@@ -511,19 +511,19 @@ LuAminusSigmaB (const SparseMatrix &m, c
       (*current_liboctave_warning_handler)
         ("       an eigenvalue. Convergence is not guaranteed");
     }
 
   return true;
 }
 
 static bool
-LuAminusSigmaB (const Matrix &m, const Matrix &b, 
+LuAminusSigmaB (const Matrix &m, const Matrix &b,
                 bool cholB, const ColumnVector& permB, double sigma,
-                Matrix &L, Matrix &U, octave_idx_type *P, 
+                Matrix &L, Matrix &U, octave_idx_type *P,
                 octave_idx_type *Q)
 {
   bool have_b = ! b.is_empty ();
   octave_idx_type n = m.cols();
 
   // Caclulate LU decomposition of 'A - sigma * B'
   Matrix AminusSigmaB (m);
 
@@ -532,19 +532,19 @@ LuAminusSigmaB (const Matrix &m, const M
       if (cholB)
         {
           Matrix tmp = sigma * b.transpose() * b;
           const double *pB = permB.fortran_vec();
           double *p = AminusSigmaB.fortran_vec();
 
           if (permB.length())
             {
-              for (octave_idx_type j = 0; 
+              for (octave_idx_type j = 0;
                    j < b.cols(); j++)
-                for (octave_idx_type i = 0; 
+                for (octave_idx_type i = 0;
                      i < b.rows(); i++)
                   *p++ -=  tmp.xelem (static_cast<octave_idx_type>(pB[i]),
                                       static_cast<octave_idx_type>(pB[j]));
             }
           else
             AminusSigmaB = AminusSigmaB - tmp;
         }
       else
@@ -558,17 +558,17 @@ LuAminusSigmaB (const Matrix &m, const M
         p[i*(n+1)] -= sigma;
     }
 
   LU fact (AminusSigmaB);
 
   L = fact.P().transpose() * fact.L ();
   U = fact.U ();
   for (octave_idx_type j = 0; j < n; j++)
-    P[j] = Q[j] = j;  
+    P[j] = Q[j] = j;
 
   // Test condition number of LU decomposition
   double minU = octave_NaN;
   double maxU = octave_NaN;
   for (octave_idx_type j = 0; j < n; j++)
     {
       double d = std::abs (U.xelem(j,j));
       if (xisnan (minU) || d < minU)
@@ -578,27 +578,27 @@ LuAminusSigmaB (const Matrix &m, const M
         maxU = d;
     }
 
   double rcond = (minU / maxU);
   volatile double rcond_plus_one = rcond + 1.0;
 
   if (rcond_plus_one == 1.0 || xisnan (rcond))
     {
-      (*current_liboctave_warning_handler) 
+      (*current_liboctave_warning_handler)
         ("eigs: 'A - sigma*B' is singular, indicating sigma is exactly");
-      (*current_liboctave_warning_handler) 
+      (*current_liboctave_warning_handler)
         ("       an eigenvalue. Convergence is not guaranteed");
     }
 
   return true;
 }
 
 static bool
-LuAminusSigmaB (const SparseComplexMatrix &m, const SparseComplexMatrix &b, 
+LuAminusSigmaB (const SparseComplexMatrix &m, const SparseComplexMatrix &b,
                 bool cholB, const ColumnVector& permB, Complex sigma,
                 SparseComplexMatrix &L, SparseComplexMatrix &U,
                 octave_idx_type *P, octave_idx_type *Q)
 {
   bool have_b = ! b.is_empty ();
   octave_idx_type n = m.rows();
 
   // Caclulate LU decomposition of 'A - sigma * B'
@@ -609,23 +609,23 @@ LuAminusSigmaB (const SparseComplexMatri
       if (cholB)
         {
           if (permB.length())
             {
               SparseMatrix tmp(n,n,n);
               for (octave_idx_type i = 0; i < n; i++)
                 {
                   tmp.xcidx(i) = i;
-                  tmp.xridx(i) = 
+                  tmp.xridx(i) =
                     static_cast<octave_idx_type>(permB(i));
                   tmp.xdata(i) = 1;
                 }
               tmp.xcidx(n) = n;
 
-              AminusSigmaB = AminusSigmaB - tmp * b.hermitian() * b * 
+              AminusSigmaB = AminusSigmaB - tmp * b.hermitian() * b *
                 tmp.transpose() * sigma;
             }
           else
             AminusSigmaB = AminusSigmaB - sigma * b.hermitian() * b;
         }
       else
         AminusSigmaB = AminusSigmaB - sigma * b;
     }
@@ -685,19 +685,19 @@ LuAminusSigmaB (const SparseComplexMatri
       (*current_liboctave_warning_handler)
         ("       an eigenvalue. Convergence is not guaranteed");
     }
 
   return true;
 }
 
 static bool
-LuAminusSigmaB (const ComplexMatrix &m, const ComplexMatrix &b, 
+LuAminusSigmaB (const ComplexMatrix &m, const ComplexMatrix &b,
                 bool cholB, const ColumnVector& permB, Complex sigma,
-                ComplexMatrix &L, ComplexMatrix &U, octave_idx_type *P, 
+                ComplexMatrix &L, ComplexMatrix &U, octave_idx_type *P,
                 octave_idx_type *Q)
 {
   bool have_b = ! b.is_empty ();
   octave_idx_type n = m.cols();
 
   // Caclulate LU decomposition of 'A - sigma * B'
   ComplexMatrix AminusSigmaB (m);
 
@@ -706,19 +706,19 @@ LuAminusSigmaB (const ComplexMatrix &m, 
       if (cholB)
         {
           ComplexMatrix tmp = sigma * b.hermitian() * b;
           const double *pB = permB.fortran_vec();
           Complex *p = AminusSigmaB.fortran_vec();
 
           if (permB.length())
             {
-              for (octave_idx_type j = 0; 
+              for (octave_idx_type j = 0;
                    j < b.cols(); j++)
-                for (octave_idx_type i = 0; 
+                for (octave_idx_type i = 0;
                      i < b.rows(); i++)
                   *p++ -=  tmp.xelem (static_cast<octave_idx_type>(pB[i]),
                                       static_cast<octave_idx_type>(pB[j]));
             }
           else
             AminusSigmaB = AminusSigmaB - tmp;
         }
       else
@@ -732,17 +732,17 @@ LuAminusSigmaB (const ComplexMatrix &m, 
         p[i*(n+1)] -= sigma;
     }
 
   ComplexLU fact (AminusSigmaB);
 
   L = fact.P().transpose() * fact.L ();
   U = fact.U ();
   for (octave_idx_type j = 0; j < n; j++)
-    P[j] = Q[j] = j;  
+    P[j] = Q[j] = j;
 
   // Test condition number of LU decomposition
   double minU = octave_NaN;
   double maxU = octave_NaN;
   for (octave_idx_type j = 0; j < n; j++)
     {
       double d = std::abs (U.xelem(j,j));
       if (xisnan (minU) || d < minU)
@@ -752,33 +752,33 @@ LuAminusSigmaB (const ComplexMatrix &m, 
         maxU = d;
     }
 
   double rcond = (minU / maxU);
   volatile double rcond_plus_one = rcond + 1.0;
 
   if (rcond_plus_one == 1.0 || xisnan (rcond))
     {
-      (*current_liboctave_warning_handler) 
+      (*current_liboctave_warning_handler)
         ("eigs: 'A - sigma*B' is singular, indicating sigma is exactly");
-      (*current_liboctave_warning_handler) 
+      (*current_liboctave_warning_handler)
         ("       an eigenvalue. Convergence is not guaranteed");
     }
 
   return true;
 }
 
 template <class M>
 octave_idx_type
-EigsRealSymmetricMatrix (const M& m, const std::string typ, 
+EigsRealSymmetricMatrix (const M& m, const std::string typ,
                          octave_idx_type k, octave_idx_type p,
                          octave_idx_type &info, Matrix &eig_vec,
                          ColumnVector &eig_val, const M& _b,
-                         ColumnVector &permB, ColumnVector &resid, 
-                         std::ostream& os, double tol, bool rvec, 
+                         ColumnVector &permB, ColumnVector &resid,
+                         std::ostream& os, double tol, bool rvec,
                          bool cholB, int disp, int maxit)
 {
   M b(_b);
   octave_idx_type n = m.cols ();
   octave_idx_type mode = 1;
   bool have_b = ! b.is_empty();
   bool note3 = false;
   char bmat = 'I';
@@ -787,17 +787,17 @@ EigsRealSymmetricMatrix (const M& m, con
 
   if (m.rows() != m.cols())
     {
       (*current_liboctave_error_handler) ("eigs: A must be square");
       return -1;
     }
   if (have_b && (m.rows() != b.rows() || m.rows() != b.cols()))
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
         ("eigs: B must be square and the same size as A");
       return -1;
     }
 
   if (resid.is_empty())
     {
       std::string rand_dist = octave_rand::distribution();
       octave_rand::distribution("uniform");
@@ -813,75 +813,75 @@ EigsRealSymmetricMatrix (const M& m, con
     }
 
   if (p < 0)
     {
       p = k * 2;
 
       if (p < 20)
         p = 20;
-      
+
       if (p > n - 1)
         p = n - 1 ;
     }
-  
+
   if (k < 1 || k > n - 2)
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
         ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1-1).\n"
          "      Use 'eig(full(A))' instead");
       return -1;
     }
 
   if (p <= k || p >= n)
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
-  if (have_b && cholB && permB.length() != 0) 
+  if (have_b && cholB && permB.length() != 0)
     {
       // Check the we really have a permutation vector
       if (permB.length() != n)
         {
-          (*current_liboctave_error_handler) 
+          (*current_liboctave_error_handler)
             ("eigs: permB vector invalid");
           return -1;
         }
       else
         {
           Array<bool> checked (dim_vector (n, 1), false);
           for (octave_idx_type i = 0; i < n; i++)
             {
-              octave_idx_type bidx = 
+              octave_idx_type bidx =
                 static_cast<octave_idx_type> (permB(i));
               if (checked(bidx) || bidx < 0 ||
                   bidx >= n || D_NINT (bidx) != bidx)
                 {
-                  (*current_liboctave_error_handler) 
+                  (*current_liboctave_error_handler)
                     ("eigs: permB vector invalid");
                   return -1;
                 }
             }
         }
     }
 
-  if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA" && 
+  if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA" &&
       typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI" &&
       typ != "SI")
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
         ("eigs: unrecognized sigma value");
       return -1;
     }
-  
+
   if (typ == "LI" || typ == "SI" || typ == "LR" || typ == "SR")
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
         ("eigs: invalid sigma value for real symmetric problem");
       return -1;
     }
 
   if (have_b)
     {
       // See Note 3 dsaupd
       note3 = true;
@@ -895,17 +895,17 @@ EigsRealSymmetricMatrix (const M& m, con
               for (octave_idx_type i = 0; i < n; i++)
                 permB(i) = i;
             }
         }
       else
         {
           if (! make_cholb(b, bt, permB))
             {
-              (*current_liboctave_error_handler) 
+              (*current_liboctave_error_handler)
                 ("eigs: The matrix B is not positive definite");
               return -1;
             }
         }
     }
 
   Array<octave_idx_type> ip (dim_vector (11, 1));
   octave_idx_type *iparam = ip.fortran_vec ();
@@ -917,118 +917,118 @@ EigsRealSymmetricMatrix (const M& m, con
   ip(4) = 0; // nconv, number of Ritz values that satisfy convergence
   ip(5) = 0; //ip(5) not referenced
   ip(6) = mode; // mode
   ip(7) = 0;
   ip(8) = 0;
   ip(9) = 0;
   ip(10) = 0;
   // ip(7) to ip(10) return values
- 
+
   Array<octave_idx_type> iptr (dim_vector (14, 1));
   octave_idx_type *ipntr = iptr.fortran_vec ();
 
   octave_idx_type ido = 0;
   int iter = 0;
   octave_idx_type lwork = p * (p + 8);
 
   OCTAVE_LOCAL_BUFFER (double, v, n * p);
   OCTAVE_LOCAL_BUFFER (double, workl, lwork);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n);
   double *presid = resid.fortran_vec ();
 
-  do 
+  do
     {
-      F77_FUNC (dsaupd, DSAUPD) 
+      F77_FUNC (dsaupd, DSAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         {
-          (*current_liboctave_error_handler) 
+          (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in dsaupd");
           return -1;
         }
 
       if (disp > 0 && !xisnan(workl[iptr(5)-1]))
         {
           if (iter++)
             {
-              os << "Iteration " << iter - 1 << 
+              os << "Iteration " << iter - 1 <<
                 ": a few Ritz values of the " << p << "-by-" <<
                 p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
             }
 
           // This is a kludge, as ARPACK doesn't give its
           // iteration pointer. But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
           // is a way of obtaining the iteration counter.
           if (ido != 99)
-            workl[iptr(5)-1] = octave_NaN; 
+            workl[iptr(5)-1] = octave_NaN;
         }
 
       if (ido == -1 || ido == 1 || ido == 2)
         {
           if (have_b)
             {
               Matrix mtmp (n,1);
               for (octave_idx_type i = 0; i < n; i++)
                 mtmp(i,0) = workd[i + iptr(0) - 1];
-              
+
               mtmp = utsolve(bt, permB, m * ltsolve(b, permB, mtmp));
 
               for (octave_idx_type i = 0; i < n; i++)
                 workd[i+iptr(1)-1] = mtmp(i,0);
             }
-          else if (!vector_product (m, workd + iptr(0) - 1, 
+          else if (!vector_product (m, workd + iptr(0) - 1,
                                     workd + iptr(1) - 1))
             break;
         }
       else
         {
           if (info < 0)
             {
-              (*current_liboctave_error_handler) 
+              (*current_liboctave_error_handler)
                 ("eigs: error %d in dsaupd", info);
               return -1;
             }
           break;
         }
-    } 
+    }
   while (1);
 
   octave_idx_type info2;
 
-  // We have a problem in that the size of the C++ bool 
-  // type relative to the fortran logical type. It appears 
-  // that fortran uses 4- or 8-bytes per logical and C++ 1-byte 
-  // per bool, though this might be system dependent. As 
+  // We have a problem in that the size of the C++ bool
+  // type relative to the fortran logical type. It appears
+  // that fortran uses 4- or 8-bytes per logical and C++ 1-byte
+  // per bool, though this might be system dependent. As
   // long as the HOWMNY arg is not "S", the logical array
-  // is just workspace for ARPACK, so use int type to 
+  // is just workspace for ARPACK, so use int type to
   // avoid problems.
   Array<octave_idx_type> s (dim_vector (p, 1));
   octave_idx_type *sel = s.fortran_vec ();
 
   eig_vec.resize (n, k);
   double *z = eig_vec.fortran_vec ();
 
   eig_val.resize (k);
   double *d = eig_val.fortran_vec ();
 
-  F77_FUNC (dseupd, DSEUPD) 
-    (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, d, z, n, sigma, 
-     F77_CONST_CHAR_ARG2 (&bmat, 1), n, 
+  F77_FUNC (dseupd, DSEUPD)
+    (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, d, z, n, sigma,
+     F77_CONST_CHAR_ARG2 (&bmat, 1), n,
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2), k, tol, presid, p, v, n, iparam,
-     ipntr, workd, workl, lwork, info2 F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) 
+     ipntr, workd, workl, lwork, info2 F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1)
      F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
     {
       (*current_liboctave_error_handler)
         ("eigs: unrecoverable exception encountered in dseupd");
       return -1;
     }
@@ -1073,49 +1073,49 @@ EigsRealSymmetricMatrix (const M& m, con
                 }
 
               if (note3)
                 eig_vec = ltsolve(b, permB, eig_vec);
             }
         }
       else
         {
-          (*current_liboctave_error_handler) 
+          (*current_liboctave_error_handler)
             ("eigs: error %d in dseupd", info2);
           return -1;
         }
     }
 
   return ip(4);
 }
 
 template <class M>
 octave_idx_type
 EigsRealSymmetricMatrixShift (const M& m, double sigma,
-                              octave_idx_type k, octave_idx_type p, 
-                              octave_idx_type &info, Matrix &eig_vec, 
+                              octave_idx_type k, octave_idx_type p,
+                              octave_idx_type &info, Matrix &eig_vec,
                               ColumnVector &eig_val, const M& _b,
-                              ColumnVector &permB, ColumnVector &resid, 
-                              std::ostream& os, double tol, bool rvec, 
+                              ColumnVector &permB, ColumnVector &resid,
+                              std::ostream& os, double tol, bool rvec,
                               bool cholB, int disp, int maxit)
 {
   M b(_b);
   octave_idx_type n = m.cols ();
   octave_idx_type mode = 3;
   bool have_b = ! b.is_empty();
   std::string typ = "LM";
 
   if (m.rows() != m.cols())
     {
       (*current_liboctave_error_handler) ("eigs: A must be square");
       return -1;
     }
   if (have_b && (m.rows() != b.rows() || m.rows() != b.cols()))
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
         ("eigs: B must be square and the same size as A");
       return -1;
     }
 
   // FIXME: The "SM" type for mode 1 seems unstable though faster!!
   //if (! std::abs (sigma))
   //  return EigsRealSymmetricMatrix (m, "SM", k, p, info, eig_vec, eig_val,
   //                                _b, permB, resid, os, tol, rvec, cholB,
@@ -1133,59 +1133,59 @@ EigsRealSymmetricMatrixShift (const M& m
     {
       (*current_liboctave_error_handler)
         ("eigs: n must be at least 3");
       return -1;
     }
 
   if (k <= 0 || k >= n - 1)
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
         ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1-1).\n"
              "      Use 'eig(full(A))' instead");
       return -1;
     }
 
   if (p < 0)
     {
       p = k * 2;
 
       if (p < 20)
         p = 20;
-      
+
       if (p > n - 1)
         p = n - 1 ;
     }
-  
+
   if (p <= k || p >= n)
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
-  if (have_b && cholB && permB.length() != 0) 
+  if (have_b && cholB && permB.length() != 0)
     {
       // Check the we really have a permutation vector
       if (permB.length() != n)
         {
           (*current_liboctave_error_handler) ("eigs: permB vector invalid");
           return -1;
         }
       else
         {
           Array<bool> checked (dim_vector (n, 1), false);
           for (octave_idx_type i = 0; i < n; i++)
             {
-              octave_idx_type bidx = 
+              octave_idx_type bidx =
                 static_cast<octave_idx_type> (permB(i));
               if (checked(bidx) || bidx < 0 ||
                   bidx >= n || D_NINT (bidx) != bidx)
                 {
-                  (*current_liboctave_error_handler) 
+                  (*current_liboctave_error_handler)
                     ("eigs: permB vector invalid");
                   return -1;
                 }
             }
         }
     }
 
   char bmat = 'I';
@@ -1223,83 +1223,83 @@ EigsRealSymmetricMatrixShift (const M& m
 
   octave_idx_type lwork = p * (p + 8);
 
   OCTAVE_LOCAL_BUFFER (double, v, n * p);
   OCTAVE_LOCAL_BUFFER (double, workl, lwork);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n);
   double *presid = resid.fortran_vec ();
 
-  do 
+  do
     {
-      F77_FUNC (dsaupd, DSAUPD) 
+      F77_FUNC (dsaupd, DSAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         {
-          (*current_liboctave_error_handler) 
+          (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in dsaupd");
           return -1;
         }
 
       if (disp > 0 && !xisnan(workl[iptr(5)-1]))
         {
           if (iter++)
             {
-              os << "Iteration " << iter - 1 << 
+              os << "Iteration " << iter - 1 <<
                 ": a few Ritz values of the " << p << "-by-" <<
                 p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
             }
 
           // This is a kludge, as ARPACK doesn't give its
           // iteration pointer. But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
           // is a way of obtaining the iteration counter.
           if (ido != 99)
-            workl[iptr(5)-1] = octave_NaN; 
+            workl[iptr(5)-1] = octave_NaN;
         }
 
       if (ido == -1 || ido == 1 || ido == 2)
         {
           if (have_b)
             {
               if (ido == -1)
                 {
                   OCTAVE_LOCAL_BUFFER (double, dtmp, n);
 
                   vector_product (m, workd+iptr(0)-1, dtmp);
 
                   Matrix tmp(n, 1);
 
                   for (octave_idx_type i = 0; i < n; i++)
                     tmp(i,0) = dtmp[P[i]];
-                                  
+
                   lusolve (L, U, tmp);
 
                   double *ip2 = workd+iptr(1)-1;
                   for (octave_idx_type i = 0; i < n; i++)
                     ip2[Q[i]] = tmp(i,0);
                 }
               else if (ido == 2)
                 vector_product (b, workd+iptr(0)-1, workd+iptr(1)-1);
               else
                 {
                   double *ip2 = workd+iptr(2)-1;
                   Matrix tmp(n, 1);
 
                   for (octave_idx_type i = 0; i < n; i++)
                     tmp(i,0) = ip2[P[i]];
-                                  
+
                   lusolve (L, U, tmp);
 
                   ip2 = workd+iptr(1)-1;
                   for (octave_idx_type i = 0; i < n; i++)
                     ip2[Q[i]] = tmp(i,0);
                 }
             }
           else
@@ -1311,58 +1311,58 @@ EigsRealSymmetricMatrixShift (const M& m
                 }
               else
                 {
                   double *ip2 = workd+iptr(0)-1;
                   Matrix tmp(n, 1);
 
                   for (octave_idx_type i = 0; i < n; i++)
                     tmp(i,0) = ip2[P[i]];
-                                  
+
                   lusolve (L, U, tmp);
 
                   ip2 = workd+iptr(1)-1;
                   for (octave_idx_type i = 0; i < n; i++)
                     ip2[Q[i]] = tmp(i,0);
                 }
             }
         }
       else
         {
           if (info < 0)
             {
-              (*current_liboctave_error_handler) 
+              (*current_liboctave_error_handler)
                 ("eigs: error %d in dsaupd", info);
               return -1;
             }
           break;
         }
-    } 
+    }
   while (1);
 
   octave_idx_type info2;
 
-  // We have a problem in that the size of the C++ bool 
-  // type relative to the fortran logical type. It appears 
-  // that fortran uses 4- or 8-bytes per logical and C++ 1-byte 
-  // per bool, though this might be system dependent. As 
+  // We have a problem in that the size of the C++ bool
+  // type relative to the fortran logical type. It appears
+  // that fortran uses 4- or 8-bytes per logical and C++ 1-byte
+  // per bool, though this might be system dependent. As
   // long as the HOWMNY arg is not "S", the logical array
-  // is just workspace for ARPACK, so use int type to 
+  // is just workspace for ARPACK, so use int type to
   // avoid problems.
   Array<octave_idx_type> s (dim_vector (p, 1));
   octave_idx_type *sel = s.fortran_vec ();
-                        
+
   eig_vec.resize (n, k);
   double *z = eig_vec.fortran_vec ();
 
   eig_val.resize (k);
   double *d = eig_val.fortran_vec ();
 
-  F77_FUNC (dseupd, DSEUPD) 
-    (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, d, z, n, sigma, 
+  F77_FUNC (dseupd, DSEUPD)
+    (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, d, z, n, sigma,
      F77_CONST_CHAR_ARG2 (&bmat, 1), n,
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
      k, tol, presid, p, v, n, iparam, ipntr, workd, workl, lwork, info2
      F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
     {
       (*current_liboctave_error_handler)
@@ -1413,19 +1413,19 @@ EigsRealSymmetricMatrixShift (const M& m
     }
 
   return ip(4);
 }
 
 octave_idx_type
 EigsRealSymmetricFunc (EigsFunc fun, octave_idx_type n,
                        const std::string &_typ, double sigma,
-                       octave_idx_type k, octave_idx_type p, 
-                       octave_idx_type &info, Matrix &eig_vec, 
-                       ColumnVector &eig_val, ColumnVector &resid, 
+                       octave_idx_type k, octave_idx_type p,
+                       octave_idx_type &info, Matrix &eig_vec,
+                       ColumnVector &eig_val, ColumnVector &resid,
                        std::ostream& os, double tol, bool rvec,
                        bool /* cholB */, int disp, int maxit)
 {
   std::string typ (_typ);
   bool have_sigma = (sigma ? true : false);
   char bmat = 'I';
   octave_idx_type mode = 1;
   int err = 0;
@@ -1446,21 +1446,21 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
     }
 
   if (p < 0)
     {
       p = k * 2;
 
       if (p < 20)
         p = 20;
-      
+
       if (p > n - 1)
         p = n - 1 ;
     }
-  
+
   if (k <= 0 || k >= n - 1)
     {
       (*current_liboctave_error_handler)
         ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
              "      Use 'eig(full(A))' instead");
       return -1;
     }
 
@@ -1468,25 +1468,25 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
   if (! have_sigma)
     {
-      if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA" && 
+      if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA" &&
           typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI" &&
           typ != "SI")
-        (*current_liboctave_error_handler) 
+        (*current_liboctave_error_handler)
           ("eigs: unrecognized sigma value");
 
       if (typ == "LI" || typ == "SI" || typ == "LR" || typ == "SR")
         {
-          (*current_liboctave_error_handler) 
+          (*current_liboctave_error_handler)
             ("eigs: invalid sigma value for real symmetric problem");
           return -1;
         }
 
       if (typ == "SM")
         {
           typ = "LM";
           sigma = 0.;
@@ -1511,63 +1511,63 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
   ip(4) = 0; // nconv, number of Ritz values that satisfy convergence
   ip(5) = 0; //ip(5) not referenced
   ip(6) = mode; // mode
   ip(7) = 0;
   ip(8) = 0;
   ip(9) = 0;
   ip(10) = 0;
   // ip(7) to ip(10) return values
- 
+
   Array<octave_idx_type> iptr (dim_vector (14, 1));
   octave_idx_type *ipntr = iptr.fortran_vec ();
 
   octave_idx_type ido = 0;
   int iter = 0;
   octave_idx_type lwork = p * (p + 8);
 
   OCTAVE_LOCAL_BUFFER (double, v, n * p);
   OCTAVE_LOCAL_BUFFER (double, workl, lwork);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n);
   double *presid = resid.fortran_vec ();
 
-  do 
+  do
     {
-      F77_FUNC (dsaupd, DSAUPD) 
+      F77_FUNC (dsaupd, DSAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         {
-          (*current_liboctave_error_handler) 
+          (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in dsaupd");
           return -1;
         }
 
       if (disp > 0 && !xisnan(workl[iptr(5)-1]))
         {
           if (iter++)
             {
-              os << "Iteration " << iter - 1 << 
+              os << "Iteration " << iter - 1 <<
                 ": a few Ritz values of the " << p << "-by-" <<
                 p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
             }
 
           // This is a kludge, as ARPACK doesn't give its
           // iteration pointer. But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
           // is a way of obtaining the iteration counter.
           if (ido != 99)
-            workl[iptr(5)-1] = octave_NaN; 
+            workl[iptr(5)-1] = octave_NaN;
         }
 
 
       if (ido == -1 || ido == 1 || ido == 2)
         {
           double *ip2 = workd + iptr(0) - 1;
           ColumnVector x(n);
 
@@ -1582,45 +1582,45 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
           ip2 = workd + iptr(1) - 1;
           for (octave_idx_type i = 0; i < n; i++)
             *ip2++ = y(i);
         }
       else
         {
           if (info < 0)
             {
-              (*current_liboctave_error_handler) 
+              (*current_liboctave_error_handler)
                 ("eigs: error %d in dsaupd", info);
               return -1;
             }
           break;
         }
-    } 
+    }
   while (1);
 
   octave_idx_type info2;
 
-  // We have a problem in that the size of the C++ bool 
-  // type relative to the fortran logical type. It appears 
-  // that fortran uses 4- or 8-bytes per logical and C++ 1-byte 
-  // per bool, though this might be system dependent. As 
+  // We have a problem in that the size of the C++ bool
+  // type relative to the fortran logical type. It appears
+  // that fortran uses 4- or 8-bytes per logical and C++ 1-byte
+  // per bool, though this might be system dependent. As
   // long as the HOWMNY arg is not "S", the logical array
-  // is just workspace for ARPACK, so use int type to 
+  // is just workspace for ARPACK, so use int type to
   // avoid problems.
   Array<octave_idx_type> s (dim_vector (p, 1));
   octave_idx_type *sel = s.fortran_vec ();
-                        
+
   eig_vec.resize (n, k);
   double *z = eig_vec.fortran_vec ();
 
   eig_val.resize (k);
   double *d = eig_val.fortran_vec ();
 
-  F77_FUNC (dseupd, DSEUPD) 
-    (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, d, z, n, sigma, 
+  F77_FUNC (dseupd, DSEUPD)
+    (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, d, z, n, sigma,
      F77_CONST_CHAR_ARG2 (&bmat, 1), n,
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
      k, tol, presid, p, v, n, iparam, ipntr, workd, workl, lwork, info2
      F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
     {
       (*current_liboctave_error_handler)
@@ -1676,22 +1676,22 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
         }
     }
 
   return ip(4);
 }
 
 template <class M>
 octave_idx_type
-EigsRealNonSymmetricMatrix (const M& m, const std::string typ, 
+EigsRealNonSymmetricMatrix (const M& m, const std::string typ,
                             octave_idx_type k, octave_idx_type p,
                             octave_idx_type &info, ComplexMatrix &eig_vec,
                             ComplexColumnVector &eig_val, const M& _b,
-                            ColumnVector &permB, ColumnVector &resid, 
-                            std::ostream& os, double tol, bool rvec, 
+                            ColumnVector &permB, ColumnVector &resid,
+                            std::ostream& os, double tol, bool rvec,
                             bool cholB, int disp, int maxit)
 {
   M b(_b);
   octave_idx_type n = m.cols ();
   octave_idx_type mode = 1;
   bool have_b = ! b.is_empty();
   bool note3 = false;
   char bmat = 'I';
@@ -1701,17 +1701,17 @@ EigsRealNonSymmetricMatrix (const M& m, 
 
   if (m.rows() != m.cols())
     {
       (*current_liboctave_error_handler) ("eigs: A must be square");
       return -1;
     }
   if (have_b && (m.rows() != b.rows() || m.rows() != b.cols()))
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
         ("eigs: B must be square and the same size as A");
       return -1;
     }
 
   if (resid.is_empty())
     {
       std::string rand_dist = octave_rand::distribution();
       octave_rand::distribution("uniform");
@@ -1727,75 +1727,75 @@ EigsRealNonSymmetricMatrix (const M& m, 
     }
 
   if (p < 0)
     {
       p = k * 2 + 1;
 
       if (p < 20)
         p = 20;
-      
+
       if (p > n - 1)
         p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
         ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
          "      Use 'eig(full(A))' instead");
       return -1;
     }
 
   if (p <= k || p >= n)
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
-  if (have_b && cholB && permB.length() != 0) 
+  if (have_b && cholB && permB.length() != 0)
     {
       // Check the we really have a permutation vector
       if (permB.length() != n)
         {
-          (*current_liboctave_error_handler) 
+          (*current_liboctave_error_handler)
             ("eigs: permB vector invalid");
           return -1;
         }
       else
         {
           Array<bool> checked (dim_vector (n, 1), false);
           for (octave_idx_type i = 0; i < n; i++)
             {
-              octave_idx_type bidx = 
+              octave_idx_type bidx =
                 static_cast<octave_idx_type> (permB(i));
               if (checked(bidx) || bidx < 0 ||
                   bidx >= n || D_NINT (bidx) != bidx)
                 {
-                  (*current_liboctave_error_handler) 
+                  (*current_liboctave_error_handler)
                     ("eigs: permB vector invalid");
                   return -1;
                 }
             }
         }
     }
 
-  if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA" && 
+  if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA" &&
       typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI" &&
       typ != "SI")
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
         ("eigs: unrecognized sigma value");
       return -1;
     }
-  
+
   if (typ == "LA" || typ == "SA" || typ == "BE")
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
         ("eigs: invalid sigma value for unsymmetric problem");
       return -1;
     }
 
   if (have_b)
     {
       // See Note 3 dsaupd
       note3 = true;
@@ -1809,17 +1809,17 @@ EigsRealNonSymmetricMatrix (const M& m, 
               for (octave_idx_type i = 0; i < n; i++)
                 permB(i) = i;
             }
         }
       else
         {
           if (! make_cholb(b, bt, permB))
             {
-              (*current_liboctave_error_handler) 
+              (*current_liboctave_error_handler)
                 ("eigs: The matrix B is not positive definite");
               return -1;
             }
         }
     }
 
   Array<octave_idx_type> ip (dim_vector (11, 1));
   octave_idx_type *iparam = ip.fortran_vec ();
@@ -1831,121 +1831,121 @@ EigsRealNonSymmetricMatrix (const M& m, 
   ip(4) = 0; // nconv, number of Ritz values that satisfy convergence
   ip(5) = 0; //ip(5) not referenced
   ip(6) = mode; // mode
   ip(7) = 0;
   ip(8) = 0;
   ip(9) = 0;
   ip(10) = 0;
   // ip(7) to ip(10) return values
- 
+
   Array<octave_idx_type> iptr (dim_vector (14, 1));
   octave_idx_type *ipntr = iptr.fortran_vec ();
 
   octave_idx_type ido = 0;
   int iter = 0;
   octave_idx_type lwork = 3 * p * (p + 2);
 
   OCTAVE_LOCAL_BUFFER (double, v, n * (p + 1));
   OCTAVE_LOCAL_BUFFER (double, workl, lwork + 1);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n + 1);
   double *presid = resid.fortran_vec ();
 
-  do 
+  do
     {
-      F77_FUNC (dnaupd, DNAUPD) 
+      F77_FUNC (dnaupd, DNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         {
-          (*current_liboctave_error_handler) 
+          (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in dnaupd");
           return -1;
         }
 
       if (disp > 0 && !xisnan(workl[iptr(5)-1]))
         {
           if (iter++)
             {
-              os << "Iteration " << iter - 1 << 
+              os << "Iteration " << iter - 1 <<
                 ": a few Ritz values of the " << p << "-by-" <<
                 p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
             }
 
           // This is a kludge, as ARPACK doesn't give its
           // iteration pointer. But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
           // is a way of obtaining the iteration counter.
           if (ido != 99)
-            workl[iptr(5)-1] = octave_NaN; 
+            workl[iptr(5)-1] = octave_NaN;
         }
 
       if (ido == -1 || ido == 1 || ido == 2)
         {
           if (have_b)
             {
               Matrix mtmp (n,1);
               for (octave_idx_type i = 0; i < n; i++)
                 mtmp(i,0) = workd[i + iptr(0) - 1];
-              
+
               mtmp = utsolve(bt, permB, m * ltsolve(b, permB, mtmp));
 
               for (octave_idx_type i = 0; i < n; i++)
                 workd[i+iptr(1)-1] = mtmp(i,0);
             }
-          else if (!vector_product (m, workd + iptr(0) - 1, 
+          else if (!vector_product (m, workd + iptr(0) - 1,
                                     workd + iptr(1) - 1))
             break;
         }
       else
         {
           if (info < 0)
             {
-              (*current_liboctave_error_handler) 
+              (*current_liboctave_error_handler)
                 ("eigs: error %d in dnaupd", info);
               return -1;
             }
           break;
         }
-    } 
+    }
   while (1);
 
   octave_idx_type info2;
 
-  // We have a problem in that the size of the C++ bool 
-  // type relative to the fortran logical type. It appears 
-  // that fortran uses 4- or 8-bytes per logical and C++ 1-byte 
-  // per bool, though this might be system dependent. As 
+  // We have a problem in that the size of the C++ bool
+  // type relative to the fortran logical type. It appears
+  // that fortran uses 4- or 8-bytes per logical and C++ 1-byte
+  // per bool, though this might be system dependent. As
   // long as the HOWMNY arg is not "S", the logical array
-  // is just workspace for ARPACK, so use int type to 
+  // is just workspace for ARPACK, so use int type to
   // avoid problems.
   Array<octave_idx_type> s (dim_vector (p, 1));
   octave_idx_type *sel = s.fortran_vec ();
 
   Matrix eig_vec2 (n, k + 1);
   double *z = eig_vec2.fortran_vec ();
 
   OCTAVE_LOCAL_BUFFER (double, dr, k + 1);
   OCTAVE_LOCAL_BUFFER (double, di, k + 1);
   OCTAVE_LOCAL_BUFFER (double, workev, 3 * p);
   for (octave_idx_type i = 0; i < k+1; i++)
     dr[i] = di[i] = 0.;
 
-  F77_FUNC (dneupd, DNEUPD) 
-    (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, dr, di, z, n, sigmar, 
+  F77_FUNC (dneupd, DNEUPD)
+    (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, dr, di, z, n, sigmar,
      sigmai, workev,  F77_CONST_CHAR_ARG2 (&bmat, 1), n,
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2), k, tol, presid, p, v, n, iparam,
-     ipntr, workd, workl, lwork, info2 F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) 
+     ipntr, workd, workl, lwork, info2 F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1)
      F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
     {
       (*current_liboctave_error_handler)
         ("eigs: unrecoverable exception encountered in dneupd");
       return -1;
     }
@@ -2003,75 +2003,75 @@ EigsRealNonSymmetricMatrix (const M& m, 
               octave_idx_type i = 0;
               while (i < k)
                 {
                   octave_idx_type off1 = i * n;
                   octave_idx_type off2 = (i+1) * n;
                   if (std::imag(eig_val(i)) == 0)
                     {
                       for (octave_idx_type j = 0; j < n; j++)
-                        eig_vec(j,i) = 
+                        eig_vec(j,i) =
                           Complex(z[j+off1],0.);
                       i++;
                     }
                   else
                     {
                       for (octave_idx_type j = 0; j < n; j++)
                         {
-                          eig_vec(j,i) = 
+                          eig_vec(j,i) =
                             Complex(z[j+off1],z[j+off2]);
                           if (i < k - 1)
-                            eig_vec(j,i+1) = 
+                            eig_vec(j,i+1) =
                               Complex(z[j+off1],-z[j+off2]);
                         }
                       i+=2;
                     }
                 }
 
               if (note3)
                 eig_vec = ltsolve(M (b), permB, eig_vec);
             }
         }
       else
         {
-          (*current_liboctave_error_handler) 
+          (*current_liboctave_error_handler)
             ("eigs: error %d in dneupd", info2);
           return -1;
         }
     }
 
   return ip(4);
 }
 
 template <class M>
 octave_idx_type
 EigsRealNonSymmetricMatrixShift (const M& m, double sigmar,
-                                 octave_idx_type k, octave_idx_type p, 
-                                 octave_idx_type &info, 
-                                 ComplexMatrix &eig_vec, 
+                                 octave_idx_type k, octave_idx_type p,
+                                 octave_idx_type &info,
+                                 ComplexMatrix &eig_vec,
                                  ComplexColumnVector &eig_val, const M& _b,
-                                 ColumnVector &permB, ColumnVector &resid, 
-                                 std::ostream& os, double tol, bool rvec, 
+                                 ColumnVector &permB, ColumnVector &resid,
+                                 std::ostream& os, double tol, bool rvec,
                                  bool cholB, int disp, int maxit)
 {
   M b(_b);
   octave_idx_type n = m.cols ();
   octave_idx_type mode = 3;
   bool have_b = ! b.is_empty();
   std::string typ = "LM";
   double sigmai = 0.;
 
   if (m.rows() != m.cols())
     {
       (*current_liboctave_error_handler) ("eigs: A must be square");
       return -1;
     }
   if (have_b && (m.rows() != b.rows() || m.rows() != b.cols()))
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
         ("eigs: B must be square and the same size as A");
       return -1;
     }
 
   // FIXME: The "SM" type for mode 1 seems unstable though faster!!
   //if (! std::abs (sigmar))
   //  return EigsRealNonSymmetricMatrix (m, "SM", k, p, info, eig_vec, eig_val,
   //                                   _b, permB, resid, os, tol, rvec, cholB,
@@ -2093,55 +2093,55 @@ EigsRealNonSymmetricMatrixShift (const M
     }
 
   if (p < 0)
     {
       p = k * 2 + 1;
 
       if (p < 20)
         p = 20;
-      
+
       if (p > n - 1)
         p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
         ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
              "      Use 'eig(full(A))' instead");
       return -1;
     }
 
   if (p <= k || p >= n)
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
-  if (have_b && cholB && permB.length() != 0) 
+  if (have_b && cholB && permB.length() != 0)
     {
       // Check that we really have a permutation vector
       if (permB.length() != n)
         {
           (*current_liboctave_error_handler) ("eigs: permB vector invalid");
           return -1;
         }
       else
         {
           Array<bool> checked (dim_vector (n, 1), false);
           for (octave_idx_type i = 0; i < n; i++)
             {
-              octave_idx_type bidx = 
+              octave_idx_type bidx =
                 static_cast<octave_idx_type> (permB(i));
               if (checked(bidx) || bidx < 0 ||
                   bidx >= n || D_NINT (bidx) != bidx)
                 {
-                  (*current_liboctave_error_handler) 
+                  (*current_liboctave_error_handler)
                     ("eigs: permB vector invalid");
                   return -1;
                 }
             }
         }
     }
 
   char bmat = 'I';
@@ -2179,83 +2179,83 @@ EigsRealNonSymmetricMatrixShift (const M
 
   octave_idx_type lwork = 3 * p * (p + 2);
 
   OCTAVE_LOCAL_BUFFER (double, v, n * (p + 1));
   OCTAVE_LOCAL_BUFFER (double, workl, lwork + 1);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n + 1);
   double *presid = resid.fortran_vec ();
 
-  do 
+  do
     {
-      F77_FUNC (dnaupd, DNAUPD) 
+      F77_FUNC (dnaupd, DNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         {
-          (*current_liboctave_error_handler) 
+          (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in dsaupd");
           return -1;
         }
 
       if (disp > 0 && !xisnan(workl[iptr(5)-1]))
         {
           if (iter++)
             {
-              os << "Iteration " << iter - 1 << 
+              os << "Iteration " << iter - 1 <<
                 ": a few Ritz values of the " << p << "-by-" <<
                 p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
             }
 
           // This is a kludge, as ARPACK doesn't give its
           // iteration pointer. But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
           // is a way of obtaining the iteration counter.
           if (ido != 99)
-            workl[iptr(5)-1] = octave_NaN; 
+            workl[iptr(5)-1] = octave_NaN;
         }
 
       if (ido == -1 || ido == 1 || ido == 2)
         {
           if (have_b)
             {
               if (ido == -1)
                 {
                   OCTAVE_LOCAL_BUFFER (double, dtmp, n);
 
                   vector_product (m, workd+iptr(0)-1, dtmp);
 
                   Matrix tmp(n, 1);
 
                   for (octave_idx_type i = 0; i < n; i++)
                     tmp(i,0) = dtmp[P[i]];
-                                  
+
                   lusolve (L, U, tmp);
 
                   double *ip2 = workd+iptr(1)-1;
                   for (octave_idx_type i = 0; i < n; i++)
                     ip2[Q[i]] = tmp(i,0);
                 }
               else if (ido == 2)
                 vector_product (b, workd+iptr(0)-1, workd+iptr(1)-1);
               else
                 {
                   double *ip2 = workd+iptr(2)-1;
                   Matrix tmp(n, 1);
 
                   for (octave_idx_type i = 0; i < n; i++)
                     tmp(i,0) = ip2[P[i]];
-                                  
+
                   lusolve (L, U, tmp);
 
                   ip2 = workd+iptr(1)-1;
                   for (octave_idx_type i = 0; i < n; i++)
                     ip2[Q[i]] = tmp(i,0);
                 }
             }
           else
@@ -2267,64 +2267,64 @@ EigsRealNonSymmetricMatrixShift (const M
                 }
               else
                 {
                   double *ip2 = workd+iptr(0)-1;
                   Matrix tmp(n, 1);
 
                   for (octave_idx_type i = 0; i < n; i++)
                     tmp(i,0) = ip2[P[i]];
-                                  
+
                   lusolve (L, U, tmp);
 
                   ip2 = workd+iptr(1)-1;
                   for (octave_idx_type i = 0; i < n; i++)
                     ip2[Q[i]] = tmp(i,0);
                 }
             }
         }
       else
         {
           if (info < 0)
             {
-              (*current_liboctave_error_handler) 
+              (*current_liboctave_error_handler)
                 ("eigs: error %d in dsaupd", info);
               return -1;
             }
           break;
         }
-    } 
+    }
   while (1);
 
   octave_idx_type info2;
 
-  // We have a problem in that the size of the C++ bool 
-  // type relative to the fortran logical type. It appears 
-  // that fortran uses 4- or 8-bytes per logical and C++ 1-byte 
-  // per bool, though this might be system dependent. As 
+  // We have a problem in that the size of the C++ bool
+  // type relative to the fortran logical type. It appears
+  // that fortran uses 4- or 8-bytes per logical and C++ 1-byte
+  // per bool, though this might be system dependent. As
   // long as the HOWMNY arg is not "S", the logical array
-  // is just workspace for ARPACK, so use int type to 
+  // is just workspace for ARPACK, so use int type to
   // avoid problems.
   Array<octave_idx_type> s (dim_vector (p, 1));
   octave_idx_type *sel = s.fortran_vec ();
-                        
+
   Matrix eig_vec2 (n, k + 1);
   double *z = eig_vec2.fortran_vec ();
 
   OCTAVE_LOCAL_BUFFER (double, dr, k + 1);
   OCTAVE_LOCAL_BUFFER (double, di, k + 1);
   OCTAVE_LOCAL_BUFFER (double, workev, 3 * p);
   for (octave_idx_type i = 0; i < k+1; i++)
     dr[i] = di[i] = 0.;
 
-  F77_FUNC (dneupd, DNEUPD) 
-    (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, dr, di, z, n, sigmar, 
+  F77_FUNC (dneupd, DNEUPD)
+    (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, dr, di, z, n, sigmar,
      sigmai, workev,  F77_CONST_CHAR_ARG2 (&bmat, 1), n,
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2), k, tol, presid, p, v, n, iparam,
-     ipntr, workd, workl, lwork, info2 F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) 
+     ipntr, workd, workl, lwork, info2 F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1)
      F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
     {
       (*current_liboctave_error_handler)
         ("eigs: unrecoverable exception encountered in dneupd");
       return -1;
     }
@@ -2382,52 +2382,52 @@ EigsRealNonSymmetricMatrixShift (const M
               octave_idx_type i = 0;
               while (i < k)
                 {
                   octave_idx_type off1 = i * n;
                   octave_idx_type off2 = (i+1) * n;
                   if (std::imag(eig_val(i)) == 0)
                     {
                       for (octave_idx_type j = 0; j < n; j++)
-                        eig_vec(j,i) = 
+                        eig_vec(j,i) =
                           Complex(z[j+off1],0.);
                       i++;
                     }
                   else
                     {
                       for (octave_idx_type j = 0; j < n; j++)
                         {
-                          eig_vec(j,i) = 
+                          eig_vec(j,i) =
                             Complex(z[j+off1],z[j+off2]);
                           if (i < k - 1)
-                            eig_vec(j,i+1) = 
+                            eig_vec(j,i+1) =
                               Complex(z[j+off1],-z[j+off2]);
                         }
                       i+=2;
                     }
                 }
             }
         }
       else
         {
-          (*current_liboctave_error_handler) 
+          (*current_liboctave_error_handler)
             ("eigs: error %d in dneupd", info2);
           return -1;
         }
     }
 
   return ip(4);
 }
 
 octave_idx_type
 EigsRealNonSymmetricFunc (EigsFunc fun, octave_idx_type n,
                           const std::string &_typ, double sigmar,
-                          octave_idx_type k, octave_idx_type p, 
-                          octave_idx_type &info, ComplexMatrix &eig_vec, 
-                          ComplexColumnVector &eig_val, ColumnVector &resid, 
+                          octave_idx_type k, octave_idx_type p,
+                          octave_idx_type &info, ComplexMatrix &eig_vec,
+                          ComplexColumnVector &eig_val, ColumnVector &resid,
                           std::ostream& os, double tol, bool rvec,
                           bool /* cholB */, int disp, int maxit)
 {
   std::string typ (_typ);
   bool have_sigma = (sigmar ? true : false);
   char bmat = 'I';
   double sigmai = 0.;
   octave_idx_type mode = 1;
@@ -2449,17 +2449,17 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
     }
 
   if (p < 0)
     {
       p = k * 2 + 1;
 
       if (p < 20)
         p = 20;
-      
+
       if (p > n - 1)
         p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
     {
       (*current_liboctave_error_handler)
         ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
@@ -2472,25 +2472,25 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
 
   if (! have_sigma)
     {
-      if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA" && 
+      if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA" &&
           typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI" &&
           typ != "SI")
-        (*current_liboctave_error_handler) 
+        (*current_liboctave_error_handler)
           ("eigs: unrecognized sigma value");
 
       if (typ == "LA" || typ == "SA" || typ == "BE")
         {
-          (*current_liboctave_error_handler) 
+          (*current_liboctave_error_handler)
             ("eigs: invalid sigma value for unsymmetric problem");
           return -1;
         }
 
       if (typ == "SM")
         {
           typ = "LM";
           sigmar = 0.;
@@ -2515,63 +2515,63 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
   ip(4) = 0; // nconv, number of Ritz values that satisfy convergence
   ip(5) = 0; //ip(5) not referenced
   ip(6) = mode; // mode
   ip(7) = 0;
   ip(8) = 0;
   ip(9) = 0;
   ip(10) = 0;
   // ip(7) to ip(10) return values
- 
+
   Array<octave_idx_type> iptr (dim_vector (14, 1));
   octave_idx_type *ipntr = iptr.fortran_vec ();
 
   octave_idx_type ido = 0;
   int iter = 0;
   octave_idx_type lwork = 3 * p * (p + 2);
 
   OCTAVE_LOCAL_BUFFER (double, v, n * (p + 1));
   OCTAVE_LOCAL_BUFFER (double, workl, lwork + 1);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n + 1);
   double *presid = resid.fortran_vec ();
 
-  do 
+  do
     {
-      F77_FUNC (dnaupd, DNAUPD) 
+      F77_FUNC (dnaupd, DNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         {
-          (*current_liboctave_error_handler) 
+          (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in dnaupd");
           return -1;
         }
 
       if (disp > 0 && !xisnan(workl[iptr(5)-1]))
         {
           if (iter++)
             {
-              os << "Iteration " << iter - 1 << 
+              os << "Iteration " << iter - 1 <<
                 ": a few Ritz values of the " << p << "-by-" <<
                 p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
             }
 
           // This is a kludge, as ARPACK doesn't give its
           // iteration pointer. But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
           // is a way of obtaining the iteration counter.
           if (ido != 99)
-            workl[iptr(5)-1] = octave_NaN; 
+            workl[iptr(5)-1] = octave_NaN;
         }
 
       if (ido == -1 || ido == 1 || ido == 2)
         {
           double *ip2 = workd + iptr(0) - 1;
           ColumnVector x(n);
 
           for (octave_idx_type i = 0; i < n; i++)
@@ -2585,51 +2585,51 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
           ip2 = workd + iptr(1) - 1;
           for (octave_idx_type i = 0; i < n; i++)
             *ip2++ = y(i);
         }
       else
         {
           if (info < 0)
             {
-              (*current_liboctave_error_handler) 
+              (*current_liboctave_error_handler)
                 ("eigs: error %d in dsaupd", info);
               return -1;
             }
           break;
         }
-    } 
+    }
   while (1);
 
   octave_idx_type info2;
 
-  // We have a problem in that the size of the C++ bool 
-  // type relative to the fortran logical type. It appears 
-  // that fortran uses 4- or 8-bytes per logical and C++ 1-byte 
-  // per bool, though this might be system dependent. As 
+  // We have a problem in that the size of the C++ bool
+  // type relative to the fortran logical type. It appears
+  // that fortran uses 4- or 8-bytes per logical and C++ 1-byte
+  // per bool, though this might be system dependent. As
   // long as the HOWMNY arg is not "S", the logical array
-  // is just workspace for ARPACK, so use int type to 
+  // is just workspace for ARPACK, so use int type to
   // avoid problems.
   Array<octave_idx_type> s (dim_vector (p, 1));
   octave_idx_type *sel = s.fortran_vec ();
 
   Matrix eig_vec2 (n, k + 1);
   double *z = eig_vec2.fortran_vec ();
 
   OCTAVE_LOCAL_BUFFER (double, dr, k + 1);
   OCTAVE_LOCAL_BUFFER (double, di, k + 1);
   OCTAVE_LOCAL_BUFFER (double, workev, 3 * p);
   for (octave_idx_type i = 0; i < k+1; i++)
     dr[i] = di[i] = 0.;
 
-  F77_FUNC (dneupd, DNEUPD) 
-    (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, dr, di, z, n, sigmar, 
+  F77_FUNC (dneupd, DNEUPD)
+    (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, dr, di, z, n, sigmar,
      sigmai, workev,  F77_CONST_CHAR_ARG2 (&bmat, 1), n,
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2), k, tol, presid, p, v, n, iparam,
-     ipntr, workd, workl, lwork, info2 F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) 
+     ipntr, workd, workl, lwork, info2 F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1)
      F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
     {
       (*current_liboctave_error_handler)
         ("eigs: unrecoverable exception encountered in dneupd");
       return -1;
     }
@@ -2687,55 +2687,55 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
               octave_idx_type i = 0;
               while (i < k)
                 {
                   octave_idx_type off1 = i * n;
                   octave_idx_type off2 = (i+1) * n;
                   if (std::imag(eig_val(i)) == 0)
                     {
                       for (octave_idx_type j = 0; j < n; j++)
-                        eig_vec(j,i) = 
+                        eig_vec(j,i) =
                           Complex(z[j+off1],0.);
                       i++;
                     }
                   else
                     {
                       for (octave_idx_type j = 0; j < n; j++)
                         {
-                          eig_vec(j,i) = 
+                          eig_vec(j,i) =
                             Complex(z[j+off1],z[j+off2]);
                           if (i < k - 1)
-                            eig_vec(j,i+1) = 
+                            eig_vec(j,i+1) =
                               Complex(z[j+off1],-z[j+off2]);
                         }
                       i+=2;
                     }
                 }
             }
         }
       else
         {
-          (*current_liboctave_error_handler) 
+          (*current_liboctave_error_handler)
             ("eigs: error %d in dneupd", info2);
           return -1;
         }
     }
 
   return ip(4);
 }
 
 template <class M>
 octave_idx_type
-EigsComplexNonSymmetricMatrix (const M& m, const std::string typ, 
+EigsComplexNonSymmetricMatrix (const M& m, const std::string typ,
                                octave_idx_type k, octave_idx_type p,
                                octave_idx_type &info, ComplexMatrix &eig_vec,
                                ComplexColumnVector &eig_val, const M& _b,
-                               ColumnVector &permB, 
-                               ComplexColumnVector &cresid, 
-                               std::ostream& os, double tol, bool rvec, 
+                               ColumnVector &permB,
+                               ComplexColumnVector &cresid,
+                               std::ostream& os, double tol, bool rvec,
                                bool cholB, int disp, int maxit)
 {
   M b(_b);
   octave_idx_type n = m.cols ();
   octave_idx_type mode = 1;
   bool have_b = ! b.is_empty();
   bool note3 = false;
   char bmat = 'I';
@@ -2744,17 +2744,17 @@ EigsComplexNonSymmetricMatrix (const M& 
 
   if (m.rows() != m.cols())
     {
       (*current_liboctave_error_handler) ("eigs: A must be square");
       return -1;
     }
   if (have_b && (m.rows() != b.rows() || m.rows() != b.cols()))
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
         ("eigs: B must be square and the same size as A");
       return -1;
     }
 
   if (cresid.is_empty())
     {
       std::string rand_dist = octave_rand::distribution();
       octave_rand::distribution("uniform");
@@ -2774,75 +2774,75 @@ EigsComplexNonSymmetricMatrix (const M& 
     }
 
   if (p < 0)
     {
       p = k * 2 + 1;
 
       if (p < 20)
         p = 20;
-      
+
       if (p > n - 1)
         p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
         ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
          "      Use 'eig(full(A))' instead");
       return -1;
     }
 
   if (p <= k || p >= n)
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
-  if (have_b && cholB && permB.length() != 0) 
+  if (have_b && cholB && permB.length() != 0)
     {
       // Check the we really have a permutation vector
       if (permB.length() != n)
         {
-          (*current_liboctave_error_handler) 
+          (*current_liboctave_error_handler)
             ("eigs: permB vector invalid");
           return -1;
         }
       else
         {
           Array<bool> checked (dim_vector (n, 1), false);
           for (octave_idx_type i = 0; i < n; i++)
             {
-              octave_idx_type bidx = 
+              octave_idx_type bidx =
                 static_cast<octave_idx_type> (permB(i));
               if (checked(bidx) || bidx < 0 ||
                   bidx >= n || D_NINT (bidx) != bidx)
                 {
-                  (*current_liboctave_error_handler) 
+                  (*current_liboctave_error_handler)
                     ("eigs: permB vector invalid");
                   return -1;
                 }
             }
         }
     }
 
-  if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA" && 
+  if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA" &&
       typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI" &&
       typ != "SI")
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
         ("eigs: unrecognized sigma value");
       return -1;
     }
-  
+
   if (typ == "LA" || typ == "SA" || typ == "BE")
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
         ("eigs: invalid sigma value for complex problem");
       return -1;
     }
 
   if (have_b)
     {
       // See Note 3 dsaupd
       note3 = true;
@@ -2856,17 +2856,17 @@ EigsComplexNonSymmetricMatrix (const M& 
               for (octave_idx_type i = 0; i < n; i++)
                 permB(i) = i;
             }
         }
       else
         {
           if (! make_cholb(b, bt, permB))
             {
-              (*current_liboctave_error_handler) 
+              (*current_liboctave_error_handler)
                 ("eigs: The matrix B is not positive definite");
               return -1;
             }
         }
     }
 
   Array<octave_idx_type> ip (dim_vector (11, 1));
   octave_idx_type *iparam = ip.fortran_vec ();
@@ -2878,125 +2878,125 @@ EigsComplexNonSymmetricMatrix (const M& 
   ip(4) = 0; // nconv, number of Ritz values that satisfy convergence
   ip(5) = 0; //ip(5) not referenced
   ip(6) = mode; // mode
   ip(7) = 0;
   ip(8) = 0;
   ip(9) = 0;
   ip(10) = 0;
   // ip(7) to ip(10) return values
- 
+
   Array<octave_idx_type> iptr (dim_vector (14, 1));
   octave_idx_type *ipntr = iptr.fortran_vec ();
 
   octave_idx_type ido = 0;
   int iter = 0;
   octave_idx_type lwork = p * (3 * p + 5);
-              
+
   OCTAVE_LOCAL_BUFFER (Complex, v, n * p);
   OCTAVE_LOCAL_BUFFER (Complex, workl, lwork);
   OCTAVE_LOCAL_BUFFER (Complex, workd, 3 * n);
   OCTAVE_LOCAL_BUFFER (double, rwork, p);
   Complex *presid = cresid.fortran_vec ();
 
-  do 
+  do
     {
-      F77_FUNC (znaupd, ZNAUPD) 
+      F77_FUNC (znaupd, ZNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, rwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         {
-          (*current_liboctave_error_handler) 
+          (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in znaupd");
           return -1;
         }
 
       if (disp > 0 && !xisnan(workl[iptr(5)-1]))
         {
           if (iter++)
             {
-              os << "Iteration " << iter - 1 << 
+              os << "Iteration " << iter - 1 <<
                 ": a few Ritz values of the " << p << "-by-" <<
                 p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
             }
-                          
+
           // This is a kludge, as ARPACK doesn't give its
           // iteration pointer. But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
           // is a way of obtaining the iteration counter.
           if (ido != 99)
-            workl[iptr(5)-1] = octave_NaN; 
+            workl[iptr(5)-1] = octave_NaN;
         }
 
       if (ido == -1 || ido == 1 || ido == 2)
         {
           if (have_b)
             {
               ComplexMatrix mtmp (n,1);
               for (octave_idx_type i = 0; i < n; i++)
                 mtmp(i,0) = workd[i + iptr(0) - 1];
               mtmp = utsolve(bt, permB, m * ltsolve(b, permB, mtmp));
               for (octave_idx_type i = 0; i < n; i++)
                 workd[i+iptr(1)-1] = mtmp(i,0);
 
             }
-          else if (!vector_product (m, workd + iptr(0) - 1, 
+          else if (!vector_product (m, workd + iptr(0) - 1,
                                     workd + iptr(1) - 1))
             break;
         }
       else
         {
           if (info < 0)
             {
-              (*current_liboctave_error_handler) 
+              (*current_liboctave_error_handler)
                 ("eigs: error %d in znaupd", info);
               return -1;
             }
           break;
         }
-    } 
+    }
   while (1);
 
   octave_idx_type info2;
 
-  // We have a problem in that the size of the C++ bool 
-  // type relative to the fortran logical type. It appears 
-  // that fortran uses 4- or 8-bytes per logical and C++ 1-byte 
-  // per bool, though this might be system dependent. As 
+  // We have a problem in that the size of the C++ bool
+  // type relative to the fortran logical type. It appears
+  // that fortran uses 4- or 8-bytes per logical and C++ 1-byte
+  // per bool, though this might be system dependent. As
   // long as the HOWMNY arg is not "S", the logical array
-  // is just workspace for ARPACK, so use int type to 
+  // is just workspace for ARPACK, so use int type to
   // avoid problems.
   Array<octave_idx_type> s (dim_vector (p, 1));
   octave_idx_type *sel = s.fortran_vec ();
 
   eig_vec.resize (n, k);
   Complex *z = eig_vec.fortran_vec ();
 
   eig_val.resize (k+1);
   Complex *d = eig_val.fortran_vec ();
 
   OCTAVE_LOCAL_BUFFER (Complex, workev, 2 * p);
 
-  F77_FUNC (zneupd, ZNEUPD) 
+  F77_FUNC (zneupd, ZNEUPD)
     (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, d, z, n, sigma, workev,
      F77_CONST_CHAR_ARG2 (&bmat, 1), n,
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
      k, tol, presid, p, v, n, iparam, ipntr, workd, workl, lwork, rwork, info2
      F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
         ("eigs: unrecoverable exception encountered in zneupd");
       return -1;
     }
 
   if (info2 == 0)
     {
       octave_idx_type k2 = k / 2;
       for (octave_idx_type i = 0; i < k2; i++)
@@ -3030,50 +3030,50 @@ EigsComplexNonSymmetricMatrix (const M& 
             }
 
           if (note3)
             eig_vec = ltsolve(b, permB, eig_vec);
         }
     }
   else
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
         ("eigs: error %d in zneupd", info2);
       return -1;
     }
 
   return ip(4);
 }
 
 template <class M>
 octave_idx_type
 EigsComplexNonSymmetricMatrixShift (const M& m, Complex sigma,
-                                    octave_idx_type k, octave_idx_type p, 
-                                    octave_idx_type &info, 
-                                    ComplexMatrix &eig_vec, 
+                                    octave_idx_type k, octave_idx_type p,
+                                    octave_idx_type &info,
+                                    ComplexMatrix &eig_vec,
                                     ComplexColumnVector &eig_val, const M& _b,
-                                    ColumnVector &permB, 
-                                    ComplexColumnVector &cresid, 
-                                    std::ostream& os, double tol, bool rvec, 
+                                    ColumnVector &permB,
+                                    ComplexColumnVector &cresid,
+                                    std::ostream& os, double tol, bool rvec,
                                     bool cholB, int disp, int maxit)
 {
   M b(_b);
   octave_idx_type n = m.cols ();
   octave_idx_type mode = 3;
   bool have_b = ! b.is_empty();
   std::string typ = "LM";
 
   if (m.rows() != m.cols())
     {
       (*current_liboctave_error_handler) ("eigs: A must be square");
       return -1;
     }
   if (have_b && (m.rows() != b.rows() || m.rows() != b.cols()))
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
         ("eigs: B must be square and the same size as A");
       return -1;
     }
 
   // FIXME: The "SM" type for mode 1 seems unstable though faster!!
   //if (! std::abs (sigma))
   //  return EigsComplexNonSymmetricMatrix (m, "SM", k, p, info, eig_vec,
   //                                      eig_val, _b, permB, cresid, os, tol,
@@ -3099,55 +3099,55 @@ EigsComplexNonSymmetricMatrixShift (cons
     }
 
   if (p < 0)
     {
       p = k * 2 + 1;
 
       if (p < 20)
         p = 20;
-      
+
       if (p > n - 1)
         p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
         ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
              "      Use 'eig(full(A))' instead");
       return -1;
     }
 
   if (p <= k || p >= n)
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
-  if (have_b && cholB && permB.length() != 0) 
+  if (have_b && cholB && permB.length() != 0)
     {
       // Check that we really have a permutation vector
       if (permB.length() != n)
         {
           (*current_liboctave_error_handler) ("eigs: permB vector invalid");
           return -1;
         }
       else
         {
           Array<bool> checked (dim_vector (n, 1), false);
           for (octave_idx_type i = 0; i < n; i++)
             {
-              octave_idx_type bidx = 
+              octave_idx_type bidx =
                 static_cast<octave_idx_type> (permB(i));
               if (checked(bidx) || bidx < 0 ||
                   bidx >= n || D_NINT (bidx) != bidx)
                 {
-                  (*current_liboctave_error_handler) 
+                  (*current_liboctave_error_handler)
                     ("eigs: permB vector invalid");
                   return -1;
                 }
             }
         }
     }
 
   char bmat = 'I';
@@ -3179,90 +3179,90 @@ EigsComplexNonSymmetricMatrixShift (cons
 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, P, (have_b ? b.rows() : m.rows()));
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Q, (have_b ? b.cols() : m.cols()));
 
   if (! LuAminusSigmaB(m, b, cholB, permB, sigma, L, U, P, Q))
     return -1;
 
   octave_idx_type lwork = p * (3 * p + 5);
-              
+
   OCTAVE_LOCAL_BUFFER (Complex, v, n * p);
   OCTAVE_LOCAL_BUFFER (Complex, workl, lwork);
   OCTAVE_LOCAL_BUFFER (Complex, workd, 3 * n);
   OCTAVE_LOCAL_BUFFER (double, rwork, p);
   Complex *presid = cresid.fortran_vec ();
 
-  do 
+  do
     {
-      F77_FUNC (znaupd, ZNAUPD) 
+      F77_FUNC (znaupd, ZNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, rwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         {
-          (*current_liboctave_error_handler) 
+          (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in znaupd");
           return -1;
         }
 
       if (disp > 0 && !xisnan(workl[iptr(5)-1]))
         {
           if (iter++)
             {
-              os << "Iteration " << iter - 1 << 
+              os << "Iteration " << iter - 1 <<
                 ": a few Ritz values of the " << p << "-by-" <<
                 p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
             }
-                          
+
           // This is a kludge, as ARPACK doesn't give its
           // iteration pointer. But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
           // is a way of obtaining the iteration counter.
           if (ido != 99)
-            workl[iptr(5)-1] = octave_NaN; 
+            workl[iptr(5)-1] = octave_NaN;
         }
 
       if (ido == -1 || ido == 1 || ido == 2)
         {
           if (have_b)
             {
               if (ido == -1)
                 {
                   OCTAVE_LOCAL_BUFFER (Complex, ctmp, n);
 
                   vector_product (m, workd+iptr(0)-1, ctmp);
 
                   ComplexMatrix tmp(n, 1);
 
                   for (octave_idx_type i = 0; i < n; i++)
                     tmp(i,0) = ctmp[P[i]];
-                                  
+
                   lusolve (L, U, tmp);
 
                   Complex *ip2 = workd+iptr(1)-1;
                   for (octave_idx_type i = 0; i < n; i++)
                     ip2[Q[i]] = tmp(i,0);
                 }
               else if (ido == 2)
                 vector_product (b, workd + iptr(0) - 1, workd + iptr(1) - 1);
               else
                 {
                   Complex *ip2 = workd+iptr(2)-1;
                   ComplexMatrix tmp(n, 1);
 
                   for (octave_idx_type i = 0; i < n; i++)
                     tmp(i,0) = ip2[P[i]];
-                                  
+
                   lusolve (L, U, tmp);
 
                   ip2 = workd+iptr(1)-1;
                   for (octave_idx_type i = 0; i < n; i++)
                     ip2[Q[i]] = tmp(i,0);
                 }
             }
           else
@@ -3275,68 +3275,68 @@ EigsComplexNonSymmetricMatrixShift (cons
                 }
               else
                 {
                   Complex *ip2 = workd+iptr(0)-1;
                   ComplexMatrix tmp(n, 1);
 
                   for (octave_idx_type i = 0; i < n; i++)
                     tmp(i,0) = ip2[P[i]];
-                                  
+
                   lusolve (L, U, tmp);
 
                   ip2 = workd+iptr(1)-1;
                   for (octave_idx_type i = 0; i < n; i++)
                     ip2[Q[i]] = tmp(i,0);
                 }
             }
         }
       else
         {
           if (info < 0)
             {
-              (*current_liboctave_error_handler) 
+              (*current_liboctave_error_handler)
                 ("eigs: error %d in dsaupd", info);
               return -1;
             }
           break;
         }
-    } 
+    }
   while (1);
 
   octave_idx_type info2;
 
-  // We have a problem in that the size of the C++ bool 
-  // type relative to the fortran logical type. It appears 
-  // that fortran uses 4- or 8-bytes per logical and C++ 1-byte 
-  // per bool, though this might be system dependent. As 
+  // We have a problem in that the size of the C++ bool
+  // type relative to the fortran logical type. It appears
+  // that fortran uses 4- or 8-bytes per logical and C++ 1-byte
+  // per bool, though this might be system dependent. As
   // long as the HOWMNY arg is not "S", the logical array
-  // is just workspace for ARPACK, so use int type to 
+  // is just workspace for ARPACK, so use int type to
   // avoid problems.
   Array<octave_idx_type> s (dim_vector (p, 1));
   octave_idx_type *sel = s.fortran_vec ();
 
   eig_vec.resize (n, k);
   Complex *z = eig_vec.fortran_vec ();
 
   eig_val.resize (k+1);
   Complex *d = eig_val.fortran_vec ();
 
   OCTAVE_LOCAL_BUFFER (Complex, workev, 2 * p);
 
-  F77_FUNC (zneupd, ZNEUPD) 
+  F77_FUNC (zneupd, ZNEUPD)
     (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, d, z, n, sigma, workev,
      F77_CONST_CHAR_ARG2 (&bmat, 1), n,
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
      k, tol, presid, p, v, n, iparam, ipntr, workd, workl, lwork, rwork, info2
      F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
         ("eigs: unrecoverable exception encountered in zneupd");
       return -1;
     }
 
   if (info2 == 0)
     {
       octave_idx_type k2 = k / 2;
       for (octave_idx_type i = 0; i < k2; i++)
@@ -3367,31 +3367,31 @@ EigsComplexNonSymmetricMatrixShift (cons
 
               for (octave_idx_type j = 0; j < n; j++)
                 z[off2 + j] = ctmp[j];
             }
         }
     }
   else
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
         ("eigs: error %d in zneupd", info2);
       return -1;
     }
 
   return ip(4);
 }
 
 octave_idx_type
 EigsComplexNonSymmetricFunc (EigsComplexFunc fun, octave_idx_type n,
                              const std::string &_typ, Complex sigma,
-                             octave_idx_type k, octave_idx_type p, 
-                             octave_idx_type &info, ComplexMatrix &eig_vec, 
-                             ComplexColumnVector &eig_val, 
-                             ComplexColumnVector &cresid, std::ostream& os, 
+                             octave_idx_type k, octave_idx_type p,
+                             octave_idx_type &info, ComplexMatrix &eig_vec,
+                             ComplexColumnVector &eig_val,
+                             ComplexColumnVector &cresid, std::ostream& os,
                              double tol, bool rvec, bool /* cholB */,
                              int disp, int maxit)
 {
   std::string typ (_typ);
   bool have_sigma = (std::abs(sigma) ? true : false);
   char bmat = 'I';
   octave_idx_type mode = 1;
   int err = 0;
@@ -3416,17 +3416,17 @@ EigsComplexNonSymmetricFunc (EigsComplex
     }
 
   if (p < 0)
     {
       p = k * 2 + 1;
 
       if (p < 20)
         p = 20;
-      
+
       if (p > n - 1)
         p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
     {
       (*current_liboctave_error_handler)
         ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
@@ -3438,25 +3438,25 @@ EigsComplexNonSymmetricFunc (EigsComplex
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
     }
 
   if (! have_sigma)
     {
-      if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA" && 
+      if (typ != "LM" && typ != "SM" && typ != "LA" && typ != "SA" &&
           typ != "BE" && typ != "LR" && typ != "SR" && typ != "LI" &&
           typ != "SI")
-        (*current_liboctave_error_handler) 
+        (*current_liboctave_error_handler)
           ("eigs: unrecognized sigma value");
 
       if (typ == "LA" || typ == "SA" || typ == "BE")
         {
-          (*current_liboctave_error_handler) 
+          (*current_liboctave_error_handler)
             ("eigs: invalid sigma value for complex problem");
           return -1;
         }
 
       if (typ == "SM")
         {
           typ = "LM";
           sigma = 0.;
@@ -3481,64 +3481,64 @@ EigsComplexNonSymmetricFunc (EigsComplex
   ip(4) = 0; // nconv, number of Ritz values that satisfy convergence
   ip(5) = 0; //ip(5) not referenced
   ip(6) = mode; // mode
   ip(7) = 0;
   ip(8) = 0;
   ip(9) = 0;
   ip(10) = 0;
   // ip(7) to ip(10) return values
- 
+
   Array<octave_idx_type> iptr (dim_vector (14, 1));
   octave_idx_type *ipntr = iptr.fortran_vec ();
 
   octave_idx_type ido = 0;
   int iter = 0;
   octave_idx_type lwork = p * (3 * p + 5);
-              
+
   OCTAVE_LOCAL_BUFFER (Complex, v, n * p);
   OCTAVE_LOCAL_BUFFER (Complex, workl, lwork);
   OCTAVE_LOCAL_BUFFER (Complex, workd, 3 * n);
   OCTAVE_LOCAL_BUFFER (double, rwork, p);
   Complex *presid = cresid.fortran_vec ();
 
-  do 
+  do
     {
-      F77_FUNC (znaupd, ZNAUPD) 
+      F77_FUNC (znaupd, ZNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, rwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         {
-          (*current_liboctave_error_handler) 
+          (*current_liboctave_error_handler)
             ("eigs: unrecoverable exception encountered in znaupd");
           return -1;
         }
 
       if (disp > 0 && !xisnan(workl[iptr(5)-1]))
         {
           if (iter++)
             {
-              os << "Iteration " << iter - 1 << 
+              os << "Iteration " << iter - 1 <<
                 ": a few Ritz values of the " << p << "-by-" <<
                 p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
             }
-                          
+
           // This is a kludge, as ARPACK doesn't give its
           // iteration pointer. But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
           // is a way of obtaining the iteration counter.
           if (ido != 99)
-            workl[iptr(5)-1] = octave_NaN; 
+            workl[iptr(5)-1] = octave_NaN;
         }
 
       if (ido == -1 || ido == 1 || ido == 2)
         {
           Complex *ip2 = workd + iptr(0) - 1;
           ComplexColumnVector x(n);
 
           for (octave_idx_type i = 0; i < n; i++)
@@ -3552,55 +3552,55 @@ EigsComplexNonSymmetricFunc (EigsComplex
           ip2 = workd + iptr(1) - 1;
           for (octave_idx_type i = 0; i < n; i++)
             *ip2++ = y(i);
         }
       else
         {
           if (info < 0)
             {
-              (*current_liboctave_error_handler) 
+              (*current_liboctave_error_handler)
                 ("eigs: error %d in dsaupd", info);
               return -1;
             }
           break;
         }
-    } 
+    }
   while (1);
 
   octave_idx_type info2;
 
-  // We have a problem in that the size of the C++ bool 
-  // type relative to the fortran logical type. It appears 
-  // that fortran uses 4- or 8-bytes per logical and C++ 1-byte 
-  // per bool, though this might be system dependent. As 
+  // We have a problem in that the size of the C++ bool
+  // type relative to the fortran logical type. It appears
+  // that fortran uses 4- or 8-bytes per logical and C++ 1-byte
+  // per bool, though this might be system dependent. As
   // long as the HOWMNY arg is not "S", the logical array
-  // is just workspace for ARPACK, so use int type to 
+  // is just workspace for ARPACK, so use int type to
   // avoid problems.
   Array<octave_idx_type> s (dim_vector (p, 1));
   octave_idx_type *sel = s.fortran_vec ();
 
   eig_vec.resize (n, k);
   Complex *z = eig_vec.fortran_vec ();
 
   eig_val.resize (k+1);
   Complex *d = eig_val.fortran_vec ();
 
   OCTAVE_LOCAL_BUFFER (Complex, workev, 2 * p);
 
-  F77_FUNC (zneupd, ZNEUPD) 
+  F77_FUNC (zneupd, ZNEUPD)
     (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, d, z, n, sigma, workev,
      F77_CONST_CHAR_ARG2 (&bmat, 1), n,
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
      k, tol, presid, p, v, n, iparam, ipntr, workd, workl, lwork, rwork, info2
      F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
         ("eigs: unrecoverable exception encountered in zneupd");
       return -1;
     }
 
   if (info2 == 0)
     {
       octave_idx_type k2 = k / 2;
       for (octave_idx_type i = 0; i < k2; i++)
@@ -3631,207 +3631,207 @@ EigsComplexNonSymmetricFunc (EigsComplex
 
               for (octave_idx_type j = 0; j < n; j++)
                 z[off2 + j] = ctmp[j];
             }
         }
     }
   else
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
         ("eigs: error %d in zneupd", info2);
       return -1;
     }
 
   return ip(4);
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 extern octave_idx_type
-EigsRealSymmetricMatrix (const Matrix& m, const std::string typ, 
+EigsRealSymmetricMatrix (const Matrix& m, const std::string typ,
                          octave_idx_type k, octave_idx_type p,
                          octave_idx_type &info, Matrix &eig_vec,
                          ColumnVector &eig_val, const Matrix& b,
-                         ColumnVector &permB, ColumnVector &resid, 
+                         ColumnVector &permB, ColumnVector &resid,
                          std::ostream &os, double tol = DBL_EPSILON,
                          bool rvec = false, bool cholB = 0, int disp = 0,
                          int maxit = 300);
 
 extern octave_idx_type
-EigsRealSymmetricMatrix (const SparseMatrix& m, const std::string typ, 
+EigsRealSymmetricMatrix (const SparseMatrix& m, const std::string typ,
                          octave_idx_type k, octave_idx_type p,
                          octave_idx_type &info, Matrix &eig_vec,
                          ColumnVector &eig_val, const SparseMatrix& b,
-                         ColumnVector &permB, ColumnVector &resid, 
+                         ColumnVector &permB, ColumnVector &resid,
                          std::ostream& os, double tol = DBL_EPSILON,
-                         bool rvec = false, bool cholB = 0, int disp = 0, 
+                         bool rvec = false, bool cholB = 0, int disp = 0,
                          int maxit = 300);
 
 extern octave_idx_type
 EigsRealSymmetricMatrixShift (const Matrix& m, double sigma,
-                              octave_idx_type k, octave_idx_type p, 
-                              octave_idx_type &info, Matrix &eig_vec, 
+                              octave_idx_type k, octave_idx_type p,
+                              octave_idx_type &info, Matrix &eig_vec,
                               ColumnVector &eig_val, const Matrix& b,
-                              ColumnVector &permB, ColumnVector &resid, 
+                              ColumnVector &permB, ColumnVector &resid,
                               std::ostream &os, double tol = DBL_EPSILON,
-                              bool rvec = false, bool cholB = 0, int disp = 0, 
+                              bool rvec = false, bool cholB = 0, int disp = 0,
                               int maxit = 300);
 
 extern octave_idx_type
 EigsRealSymmetricMatrixShift (const SparseMatrix& m, double sigma,
-                              octave_idx_type k, octave_idx_type p, 
-                              octave_idx_type &info, Matrix &eig_vec, 
+                              octave_idx_type k, octave_idx_type p,
+                              octave_idx_type &info, Matrix &eig_vec,
                               ColumnVector &eig_val, const SparseMatrix& b,
-                              ColumnVector &permB, ColumnVector &resid, 
+                              ColumnVector &permB, ColumnVector &resid,
                               std::ostream &os, double tol = DBL_EPSILON,
-                              bool rvec = false, bool cholB = 0, int disp = 0, 
+                              bool rvec = false, bool cholB = 0, int disp = 0,
                               int maxit = 300);
 
 extern octave_idx_type
 EigsRealSymmetricFunc (EigsFunc fun, octave_idx_type n,
                        const std::string &typ, double sigma,
-                       octave_idx_type k, octave_idx_type p, 
+                       octave_idx_type k, octave_idx_type p,
                        octave_idx_type &info,
-                       Matrix &eig_vec, ColumnVector &eig_val, 
+                       Matrix &eig_vec, ColumnVector &eig_val,
                        ColumnVector &resid, std::ostream &os,
                        double tol = DBL_EPSILON, bool rvec = false,
                        bool cholB = 0, int disp = 0, int maxit = 300);
 
 extern octave_idx_type
-EigsRealNonSymmetricMatrix (const Matrix& m, const std::string typ, 
+EigsRealNonSymmetricMatrix (const Matrix& m, const std::string typ,
                             octave_idx_type k, octave_idx_type p,
                             octave_idx_type &info, ComplexMatrix &eig_vec,
                             ComplexColumnVector &eig_val, const Matrix& b,
-                            ColumnVector &permB, ColumnVector &resid, 
+                            ColumnVector &permB, ColumnVector &resid,
                             std::ostream &os, double tol = DBL_EPSILON,
                             bool rvec = false, bool cholB = 0, int disp = 0,
                             int maxit = 300);
 
 extern octave_idx_type
-EigsRealNonSymmetricMatrix (const SparseMatrix& m, const std::string typ, 
+EigsRealNonSymmetricMatrix (const SparseMatrix& m, const std::string typ,
                             octave_idx_type k, octave_idx_type p,
                             octave_idx_type &info, ComplexMatrix &eig_vec,
-                            ComplexColumnVector &eig_val, 
+                            ComplexColumnVector &eig_val,
                             const SparseMatrix& b,
-                            ColumnVector &permB, ColumnVector &resid, 
+                            ColumnVector &permB, ColumnVector &resid,
                             std::ostream &os, double tol = DBL_EPSILON,
                             bool rvec = false, bool cholB = 0, int disp = 0,
                             int maxit = 300);
 
 extern octave_idx_type
 EigsRealNonSymmetricMatrixShift (const Matrix& m, double sigma,
-                                 octave_idx_type k, octave_idx_type p, 
+                                 octave_idx_type k, octave_idx_type p,
                                  octave_idx_type &info,
-                                 ComplexMatrix &eig_vec, 
+                                 ComplexMatrix &eig_vec,
                                  ComplexColumnVector &eig_val, const Matrix& b,
-                                 ColumnVector &permB, ColumnVector &resid, 
+                                 ColumnVector &permB, ColumnVector &resid,
                                  std::ostream &os, double tol = DBL_EPSILON,
                                  bool rvec = false, bool cholB = 0,
                                  int disp = 0, int maxit = 300);
 
 extern octave_idx_type
 EigsRealNonSymmetricMatrixShift (const SparseMatrix& m, double sigma,
-                                 octave_idx_type k, octave_idx_type p, 
+                                 octave_idx_type k, octave_idx_type p,
                                  octave_idx_type &info,
-                                 ComplexMatrix &eig_vec, 
-                                 ComplexColumnVector &eig_val, 
+                                 ComplexMatrix &eig_vec,
+                                 ComplexColumnVector &eig_val,
                                  const SparseMatrix& b,
-                                 ColumnVector &permB, ColumnVector &resid, 
+                                 ColumnVector &permB, ColumnVector &resid,
                                  std::ostream &os, double tol = DBL_EPSILON,
                                  bool rvec = false, bool cholB = 0,
                                  int disp = 0, int maxit = 300);
 
 extern octave_idx_type
 EigsRealNonSymmetricFunc (EigsFunc fun, octave_idx_type n,
                           const std::string &_typ, double sigma,
-                          octave_idx_type k, octave_idx_type p, 
-                          octave_idx_type &info, ComplexMatrix &eig_vec, 
-                          ComplexColumnVector &eig_val, 
-                          ColumnVector &resid, std::ostream& os, 
+                          octave_idx_type k, octave_idx_type p,
+                          octave_idx_type &info, ComplexMatrix &eig_vec,
+                          ComplexColumnVector &eig_val,
+                          ColumnVector &resid, std::ostream& os,
                           double tol = DBL_EPSILON, bool rvec = false,
                           bool cholB = 0, int disp = 0, int maxit = 300);
 
 extern octave_idx_type
-EigsComplexNonSymmetricMatrix (const ComplexMatrix& m, const std::string typ, 
+EigsComplexNonSymmetricMatrix (const ComplexMatrix& m, const std::string typ,
                                octave_idx_type k, octave_idx_type p,
                                octave_idx_type &info, ComplexMatrix &eig_vec,
-                               ComplexColumnVector &eig_val, 
-                               const ComplexMatrix& b, ColumnVector &permB, 
-                               ComplexColumnVector &resid, 
+                               ComplexColumnVector &eig_val,
+                               const ComplexMatrix& b, ColumnVector &permB,
+                               ComplexColumnVector &resid,
                                std::ostream &os, double tol = DBL_EPSILON,
-                               bool rvec = false, bool cholB = 0, int disp = 0, 
+                               bool rvec = false, bool cholB = 0, int disp = 0,
                                int maxit = 300);
 
 extern octave_idx_type
-EigsComplexNonSymmetricMatrix (const SparseComplexMatrix& m, 
-                               const std::string typ, octave_idx_type k, 
-                               octave_idx_type p, octave_idx_type &info, 
+EigsComplexNonSymmetricMatrix (const SparseComplexMatrix& m,
+                               const std::string typ, octave_idx_type k,
+                               octave_idx_type p, octave_idx_type &info,
                                ComplexMatrix &eig_vec,
-                               ComplexColumnVector &eig_val, 
+                               ComplexColumnVector &eig_val,
                                const SparseComplexMatrix& b,
                                ColumnVector &permB,
-                               ComplexColumnVector &resid, 
+                               ComplexColumnVector &resid,
                                std::ostream &os, double tol = DBL_EPSILON,
-                               bool rvec = false, bool cholB = 0, int disp = 0, 
+                               bool rvec = false, bool cholB = 0, int disp = 0,
                                int maxit = 300);
 
 extern octave_idx_type
 EigsComplexNonSymmetricMatrixShift (const ComplexMatrix& m, Complex sigma,
-                                    octave_idx_type k, octave_idx_type p, 
-                                    octave_idx_type &info, 
-                                    ComplexMatrix &eig_vec, 
+                                    octave_idx_type k, octave_idx_type p,
+                                    octave_idx_type &info,
+                                    ComplexMatrix &eig_vec,
                                     ComplexColumnVector &eig_val,
                                     const ComplexMatrix& b,
                                     ColumnVector &permB,
-                                    ComplexColumnVector &resid, 
+                                    ComplexColumnVector &resid,
                                     std::ostream &os, double tol = DBL_EPSILON,
                                     bool rvec = false, bool cholB = 0,
                                     int disp = 0, int maxit = 300);
 
 extern octave_idx_type
 EigsComplexNonSymmetricMatrixShift (const SparseComplexMatrix& m,
                                     Complex sigma,
-                                    octave_idx_type k, octave_idx_type p, 
-                                    octave_idx_type &info, 
-                                    ComplexMatrix &eig_vec, 
-                                    ComplexColumnVector &eig_val, 
+                                    octave_idx_type k, octave_idx_type p,
+                                    octave_idx_type &info,
+                                    ComplexMatrix &eig_vec,
+                                    ComplexColumnVector &eig_val,
                                     const SparseComplexMatrix& b,
                                     ColumnVector &permB,
-                                    ComplexColumnVector &resid, 
+                                    ComplexColumnVector &resid,
                                     std::ostream &os, double tol = DBL_EPSILON,
                                     bool rvec = false, bool cholB = 0,
                                     int disp = 0, int maxit = 300);
 
 extern octave_idx_type
 EigsComplexNonSymmetricFunc (EigsComplexFunc fun, octave_idx_type n,
                              const std::string &_typ, Complex sigma,
-                             octave_idx_type k, octave_idx_type p, 
-                             octave_idx_type &info, ComplexMatrix &eig_vec, 
-                             ComplexColumnVector &eig_val, 
-                             ComplexColumnVector &resid, std::ostream& os, 
+                             octave_idx_type k, octave_idx_type p,
+                             octave_idx_type &info, ComplexMatrix &eig_vec,
+                             ComplexColumnVector &eig_val,
+                             ComplexColumnVector &resid, std::ostream& os,
                              double tol = DBL_EPSILON, bool rvec = false,
                              bool cholB = 0, int disp = 0, int maxit = 300);
 #endif
 
 #ifndef _MSC_VER
 template static octave_idx_type
 lusolve (const SparseMatrix&, const SparseMatrix&, Matrix&);
 
 template static octave_idx_type
-lusolve (const SparseComplexMatrix&, const SparseComplexMatrix&, 
+lusolve (const SparseComplexMatrix&, const SparseComplexMatrix&,
          ComplexMatrix&);
 
 template static octave_idx_type
 lusolve (const Matrix&, const Matrix&, Matrix&);
 
 template static octave_idx_type
 lusolve (const ComplexMatrix&, const ComplexMatrix&, ComplexMatrix&);
 
 template static ComplexMatrix
-ltsolve (const SparseComplexMatrix&, const ColumnVector&, 
+ltsolve (const SparseComplexMatrix&, const ColumnVector&,
          const ComplexMatrix&);
 
 template static Matrix
 ltsolve (const SparseMatrix&, const ColumnVector&, const Matrix&);
 
 template static ComplexMatrix
 ltsolve (const ComplexMatrix&, const ColumnVector&, const ComplexMatrix&);
 
diff --git a/liboctave/f2c-main.c b/liboctave/f2c-main.c
--- a/liboctave/f2c-main.c
+++ b/liboctave/f2c-main.c
@@ -19,17 +19,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #include <assert.h>
 
 
 /* Dummy Fortran main declaration, needed in order to link to some
-   Fortran libraries.  See the AC_F77_DUMMY_MAIN macro documentation. 
+   Fortran libraries.  See the AC_F77_DUMMY_MAIN macro documentation.
    This function should never be called. */
 
 #ifdef F77_DUMMY_MAIN
 #  ifdef __cplusplus
 extern "C"
 #  endif
 int F77_DUMMY_MAIN() { assert(0); return 1; }
 #endif
diff --git a/liboctave/fCColVector.cc b/liboctave/fCColVector.cc
--- a/liboctave/fCColVector.cc
+++ b/liboctave/fCColVector.cc
@@ -216,23 +216,23 @@ FloatComplexColumnVector::stack (const F
   octave_idx_type len = length ();
   octave_idx_type nr_insert = len;
   FloatComplexColumnVector retval (len + a.length ());
   retval.insert (*this, 0);
   retval.insert (a, nr_insert);
   return retval;
 }
 
-FloatComplexRowVector 
+FloatComplexRowVector
 FloatComplexColumnVector::hermitian (void) const
 {
   return MArray<FloatComplex>::hermitian (std::conj);
 }
 
-FloatComplexRowVector 
+FloatComplexRowVector
 FloatComplexColumnVector::transpose (void) const
 {
   return MArray<FloatComplex>::transpose ();
 }
 
 FloatColumnVector
 FloatComplexColumnVector::abs (void) const
 {
diff --git a/liboctave/fCColVector.h b/liboctave/fCColVector.h
--- a/liboctave/fCColVector.h
+++ b/liboctave/fCColVector.h
@@ -38,17 +38,17 @@ friend class FloatComplexRowVector;
 public:
 
  FloatComplexColumnVector (void)
    : MArray<FloatComplex> (dim_vector (0, 1)) { }
 
   explicit FloatComplexColumnVector (octave_idx_type n)
     : MArray<FloatComplex> (dim_vector (n, 1)) { }
 
-  explicit FloatComplexColumnVector (const dim_vector& dv) 
+  explicit FloatComplexColumnVector (const dim_vector& dv)
     : MArray<FloatComplex> (dv.as_column ()) { }
 
   FloatComplexColumnVector (octave_idx_type n, const FloatComplex& val)
     : MArray<FloatComplex> (dim_vector (n, 1), val) { }
 
   FloatComplexColumnVector (const FloatComplexColumnVector& a)
     : MArray<FloatComplex> (a) { }
 
diff --git a/liboctave/fCDiagMatrix.cc b/liboctave/fCDiagMatrix.cc
--- a/liboctave/fCDiagMatrix.cc
+++ b/liboctave/fCDiagMatrix.cc
@@ -270,33 +270,33 @@ FloatComplexDiagMatrix::extract (octave_
 FloatComplexRowVector
 FloatComplexDiagMatrix::row (octave_idx_type i) const
 {
   octave_idx_type r = rows ();
   octave_idx_type c = cols ();
   if (i < 0 || i >= r)
     {
       (*current_liboctave_error_handler) ("invalid row selection");
-      return FloatComplexRowVector (); 
+      return FloatComplexRowVector ();
     }
 
   FloatComplexRowVector retval (c, 0.0);
   if (r <= c || (r > c && i < c))
     retval.elem (i) = elem (i, i);
 
   return retval;
 }
 
 FloatComplexRowVector
 FloatComplexDiagMatrix::row (char *s) const
 {
   if (! s)
     {
       (*current_liboctave_error_handler) ("invalid row selection");
-      return FloatComplexRowVector (); 
+      return FloatComplexRowVector ();
     }
 
   char c = *s;
   if (c == 'f' || c == 'F')
     return row (static_cast<octave_idx_type>(0));
   else if (c == 'l' || c == 'L')
     return row (rows () - 1);
   else
@@ -309,44 +309,44 @@ FloatComplexDiagMatrix::row (char *s) co
 FloatComplexColumnVector
 FloatComplexDiagMatrix::column (octave_idx_type i) const
 {
   octave_idx_type r = rows ();
   octave_idx_type c = cols ();
   if (i < 0 || i >= c)
     {
       (*current_liboctave_error_handler) ("invalid column selection");
-      return FloatComplexColumnVector (); 
+      return FloatComplexColumnVector ();
     }
 
   FloatComplexColumnVector retval (r, 0.0);
   if (r >= c || (r < c && i < r))
     retval.elem (i) = elem (i, i);
 
   return retval;
 }
 
 FloatComplexColumnVector
 FloatComplexDiagMatrix::column (char *s) const
 {
   if (! s)
     {
       (*current_liboctave_error_handler) ("invalid column selection");
-      return FloatComplexColumnVector (); 
+      return FloatComplexColumnVector ();
     }
 
   char c = *s;
   if (c == 'f' || c == 'F')
     return column (static_cast<octave_idx_type>(0));
   else if (c == 'l' || c == 'L')
     return column (cols () - 1);
   else
     {
       (*current_liboctave_error_handler) ("invalid column selection");
-      return FloatComplexColumnVector (); 
+      return FloatComplexColumnVector ();
     }
 }
 
 FloatComplexDiagMatrix
 FloatComplexDiagMatrix::inverse (void) const
 {
   octave_idx_type info;
   return inverse (info);
diff --git a/liboctave/fCDiagMatrix.h b/liboctave/fCDiagMatrix.h
--- a/liboctave/fCDiagMatrix.h
+++ b/liboctave/fCDiagMatrix.h
@@ -44,32 +44,32 @@ public:
   FloatComplexDiagMatrix (octave_idx_type r, octave_idx_type c) : MDiagArray2<FloatComplex> (r, c) { }
 
   FloatComplexDiagMatrix (octave_idx_type r, octave_idx_type c, const FloatComplex& val)
     : MDiagArray2<FloatComplex> (r, c, val) { }
 
   explicit FloatComplexDiagMatrix (const Array<FloatComplex>& a)
     : MDiagArray2<FloatComplex> (a) { }
 
-  FloatComplexDiagMatrix (const Array<FloatComplex>& a, octave_idx_type r, octave_idx_type c) 
+  FloatComplexDiagMatrix (const Array<FloatComplex>& a, octave_idx_type r, octave_idx_type c)
     : MDiagArray2<FloatComplex> (a, r, c) { }
 
   explicit FloatComplexDiagMatrix (const Array<float>& a)
     : MDiagArray2<FloatComplex> (Array<FloatComplex> (a)) { }
 
   explicit FloatComplexDiagMatrix (const FloatDiagMatrix& a);
 
   FloatComplexDiagMatrix (const MDiagArray2<FloatComplex>& a)
     : MDiagArray2<FloatComplex> (a) { }
 
   FloatComplexDiagMatrix (const FloatComplexDiagMatrix& a)
     : MDiagArray2<FloatComplex> (a) { }
 
   template <class U>
-  FloatComplexDiagMatrix (const DiagArray2<U>& a) 
+  FloatComplexDiagMatrix (const DiagArray2<U>& a)
     : MDiagArray2<FloatComplex> (a) { }
 
   FloatComplexDiagMatrix& operator = (const FloatComplexDiagMatrix& a)
     {
       MDiagArray2<FloatComplex>::operator = (a);
       return *this;
     }
 
@@ -86,17 +86,17 @@ public:
   FloatComplexDiagMatrix& fill (const FloatComplexRowVector& a);
   FloatComplexDiagMatrix& fill (const FloatColumnVector& a, octave_idx_type beg);
   FloatComplexDiagMatrix& fill (const FloatComplexColumnVector& a, octave_idx_type beg);
   FloatComplexDiagMatrix& fill (const FloatRowVector& a, octave_idx_type beg);
   FloatComplexDiagMatrix& fill (const FloatComplexRowVector& a, octave_idx_type beg);
 
   FloatComplexDiagMatrix hermitian (void) const { return MDiagArray2<FloatComplex>::hermitian (std::conj); }
   FloatComplexDiagMatrix transpose (void) const { return MDiagArray2<FloatComplex>::transpose(); }
-  FloatDiagMatrix abs (void) const; 
+  FloatDiagMatrix abs (void) const;
 
   friend OCTAVE_API FloatComplexDiagMatrix conj (const FloatComplexDiagMatrix& a);
 
   // resize is the destructive analog for this one
 
   FloatComplexMatrix extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const;
 
   // extract row or column i
diff --git a/liboctave/fCMatrix.cc b/liboctave/fCMatrix.cc
--- a/liboctave/fCMatrix.cc
+++ b/liboctave/fCMatrix.cc
@@ -156,18 +156,18 @@ extern "C"
   F77_RET_T
   F77_FUNC (cgetri, CGETRI) (const octave_idx_type&, FloatComplex*,
                              const octave_idx_type&, const octave_idx_type*,
                              FloatComplex*, const octave_idx_type&,
                              octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (cgecon, CGECON) (F77_CONST_CHAR_ARG_DECL,
-                             const octave_idx_type&, FloatComplex*, 
-                             const octave_idx_type&, const float&, float&, 
+                             const octave_idx_type&, FloatComplex*,
+                             const octave_idx_type&, const float&, float&,
                              FloatComplex*, float*, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (cgelsy, CGELSY) (const octave_idx_type&, const octave_idx_type&,
                              const octave_idx_type&, FloatComplex*,
                              const octave_idx_type&, FloatComplex*,
                              const octave_idx_type&, octave_idx_type*,
@@ -175,17 +175,17 @@ extern "C"
                              const octave_idx_type&, float*, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (cgelsd, CGELSD) (const octave_idx_type&, const octave_idx_type&,
                              const octave_idx_type&, FloatComplex*,
                              const octave_idx_type&, FloatComplex*,
                              const octave_idx_type&, float*, float&,
                              octave_idx_type&, FloatComplex*,
-                             const octave_idx_type&, float*, 
+                             const octave_idx_type&, float*,
                              octave_idx_type*, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (cpotrf, CPOTRF) (F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&, FloatComplex*,
                              const octave_idx_type&, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL);
 
@@ -193,44 +193,44 @@ extern "C"
   F77_FUNC (cpocon, CPOCON) (F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&, FloatComplex*,
                              const octave_idx_type&, const float&, float&,
                              FloatComplex*, float*, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (cpotrs, CPOTRS) (F77_CONST_CHAR_ARG_DECL,
-                             const octave_idx_type&, 
-                             const octave_idx_type&, const FloatComplex*, 
-                             const octave_idx_type&, FloatComplex*, 
+                             const octave_idx_type&,
+                             const octave_idx_type&, const FloatComplex*,
+                             const octave_idx_type&, FloatComplex*,
                              const octave_idx_type&, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (ctrtri, CTRTRI) (F77_CONST_CHAR_ARG_DECL,
-                             F77_CONST_CHAR_ARG_DECL, 
-                             const octave_idx_type&, const FloatComplex*, 
-                             const octave_idx_type&, octave_idx_type& 
+                             F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, const FloatComplex*,
+                             const octave_idx_type&, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (ctrcon, CTRCON) (F77_CONST_CHAR_ARG_DECL,
-                             F77_CONST_CHAR_ARG_DECL, 
+                             F77_CONST_CHAR_ARG_DECL,
                              F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&, const FloatComplex*,
                              const octave_idx_type&, float&, FloatComplex*,
-                             float*, octave_idx_type& 
+                             float*, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (ctrtrs, CTRTRS) (F77_CONST_CHAR_ARG_DECL,
-                             F77_CONST_CHAR_ARG_DECL, 
+                             F77_CONST_CHAR_ARG_DECL,
                              F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&, const octave_idx_type&,
                              const FloatComplex*, const octave_idx_type&,
                              FloatComplex*, const octave_idx_type&,
                              octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
@@ -1013,42 +1013,42 @@ FloatComplexMatrix::tinverse (MatrixType
       int typ = mattype.type ();
       char uplo = (typ == MatrixType::Lower ? 'L' : 'U');
       char udiag = 'N';
       retval = *this;
       FloatComplex *tmp_data = retval.fortran_vec ();
 
       F77_XFCN (ctrtri, CTRTRI, (F77_CONST_CHAR_ARG2 (&uplo, 1),
                                  F77_CONST_CHAR_ARG2 (&udiag, 1),
-                                 nr, tmp_data, nr, info 
+                                 nr, tmp_data, nr, info
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
-      if (info != 0) 
+      if (info != 0)
         info = -1;
-      else if (calc_cond) 
+      else if (calc_cond)
         {
           octave_idx_type ztrcon_info = 0;
           char job = '1';
 
           OCTAVE_LOCAL_BUFFER (FloatComplex, cwork, 2*nr);
           OCTAVE_LOCAL_BUFFER (float, rwork, nr);
 
           F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      F77_CONST_CHAR_ARG2 (&uplo, 1),
                                      F77_CONST_CHAR_ARG2 (&udiag, 1),
-                                     nr, tmp_data, nr, rcon, 
-                                     cwork, rwork, ztrcon_info 
+                                     nr, tmp_data, nr, rcon,
+                                     cwork, rwork, ztrcon_info
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)));
 
-          if (ztrcon_info != 0) 
+          if (ztrcon_info != 0)
             info = -1;
         }
 
       if (info == -1 && ! force)
         retval = *this; // Restore matrix contents.
     }
 
   return retval;
@@ -1073,17 +1073,17 @@ FloatComplexMatrix::finverse (MatrixType
       retval = *this;
       FloatComplex *tmp_data = retval.fortran_vec ();
 
       Array<FloatComplex> z (dim_vector (1, 1));
       octave_idx_type lwork = -1;
 
       // Query the optimum work array size.
 
-      F77_XFCN (cgetri, CGETRI, (nc, tmp_data, nr, pipvt, 
+      F77_XFCN (cgetri, CGETRI, (nc, tmp_data, nr, pipvt,
                                  z.fortran_vec (), lwork, info));
 
       lwork = static_cast<octave_idx_type> (std::real(z(0)));
       lwork = (lwork <  2 *nc ? 2*nc : lwork);
       z.resize (dim_vector (lwork, 1));
       FloatComplex *pz = z.fortran_vec ();
 
       info = 0;
@@ -1092,51 +1092,51 @@ FloatComplexMatrix::finverse (MatrixType
       float anorm;
       if (calc_cond)
         anorm  = retval.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
       F77_XFCN (cgetrf, CGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
-      if (info != 0) 
+      if (info != 0)
         info = -1;
-      else if (calc_cond) 
+      else if (calc_cond)
         {
           // Now calculate the condition number for non-singular matrix.
           octave_idx_type zgecon_info = 0;
           char job = '1';
           Array<float> rz (dim_vector (2 * nc, 1));
           float *prz = rz.fortran_vec ();
           F77_XFCN (cgecon, CGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                     nc, tmp_data, nr, anorm, 
+                                     nc, tmp_data, nr, anorm,
                                      rcon, pz, prz, zgecon_info
                                      F77_CHAR_ARG_LEN (1)));
 
-          if (zgecon_info != 0) 
+          if (zgecon_info != 0)
             info = -1;
         }
 
       if (info == -1 && ! force)
         retval = *this;  // Restore contents.
       else
         {
           octave_idx_type zgetri_info = 0;
 
           F77_XFCN (cgetri, CGETRI, (nc, tmp_data, nr, pipvt,
                                      pz, lwork, zgetri_info));
 
-          if (zgetri_info != 0) 
+          if (zgetri_info != 0)
             info = -1;
         }
 
       if (info != 0)
         mattype.mark_as_rectangular();
     }
-  
+
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::inverse (MatrixType &mattype, octave_idx_type& info,
                         float& rcon, int force, int calc_cond) const
 {
   int typ = mattype.type (false);
@@ -1236,17 +1236,17 @@ FloatComplexMatrix::fourier (void) const
     {
       npts = nr;
       nsamples = nc;
     }
 
   const FloatComplex *in (data ());
   FloatComplex *out (retval.fortran_vec ());
 
-  octave_fftw::fft (in, out, npts, nsamples); 
+  octave_fftw::fft (in, out, npts, nsamples);
 
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::ifourier (void) const
 {
   size_t nr = rows ();
@@ -1265,17 +1265,17 @@ FloatComplexMatrix::ifourier (void) cons
     {
       npts = nr;
       nsamples = nc;
     }
 
   const FloatComplex *in (data ());
   FloatComplex *out (retval.fortran_vec ());
 
-  octave_fftw::ifft (in, out, npts, nsamples); 
+  octave_fftw::ifft (in, out, npts, nsamples);
 
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::fourier2d (void) const
 {
   dim_vector dv(rows (), cols ());
@@ -1582,56 +1582,56 @@ FloatComplexMatrix::determinant (MatrixT
 
       if (typ == MatrixType::Unknown)
         typ = mattype.type (*this);
       else if (typ == MatrixType::Rectangular)
         typ = MatrixType::Full;
 
       if (typ == MatrixType::Lower || typ == MatrixType::Upper)
         {
-          for (octave_idx_type i = 0; i < nc; i++) 
+          for (octave_idx_type i = 0; i < nc; i++)
             retval *= elem (i,i);
         }
       else if (typ == MatrixType::Hermitian)
         {
           FloatComplexMatrix atmp = *this;
           FloatComplex *tmp_data = atmp.fortran_vec ();
 
           info = 0;
           float anorm = 0;
           if (calc_cond) anorm = xnorm (*this, 1);
 
 
           char job = 'L';
-          F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
+          F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                      tmp_data, nr, info
                                      F77_CHAR_ARG_LEN (1)));
 
-          if (info != 0) 
+          if (info != 0)
             {
               rcon = 0.0;
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
-          else 
+          else
             {
               Array<FloatComplex> z (dim_vector (2 * nc, 1));
               FloatComplex *pz = z.fortran_vec ();
               Array<float> rz (dim_vector (nc, 1));
               float *prz = rz.fortran_vec ();
 
               F77_XFCN (cpocon, CPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                          nr, tmp_data, nr, anorm,
                                          rcon, pz, prz, info
                                          F77_CHAR_ARG_LEN (1)));
 
-              if (info != 0) 
+              if (info != 0)
                 rcon = 0.0;
 
-              for (octave_idx_type i = 0; i < nc; i++) 
+              for (octave_idx_type i = 0; i < nc; i++)
                 retval *= atmp (i,i);
 
               retval = retval.square ();
             }
         }
       else if (typ != MatrixType::Full)
         (*current_liboctave_error_handler) ("det: invalid dense matrix type");
 
@@ -1648,46 +1648,46 @@ FloatComplexMatrix::determinant (MatrixT
           // Calculate the norm of the matrix, for later use.
           float anorm = 0;
           if (calc_cond) anorm = xnorm (*this, 1);
 
           F77_XFCN (cgetrf, CGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
-          if (info != 0) 
+          if (info != 0)
             {
               info = -1;
               retval = FloatComplexDET ();
-            } 
-          else 
+            }
+          else
             {
-              if (calc_cond) 
+              if (calc_cond)
                 {
                   // Now calc the condition number for non-singular matrix.
                   char job = '1';
                   Array<FloatComplex> z (dim_vector (2 * nc, 1));
                   FloatComplex *pz = z.fortran_vec ();
                   Array<float> rz (dim_vector (2 * nc, 1));
                   float *prz = rz.fortran_vec ();
 
                   F77_XFCN (cgecon, CGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                             nc, tmp_data, nr, anorm, 
+                                             nc, tmp_data, nr, anorm,
                                              rcon, pz, prz, info
                                              F77_CHAR_ARG_LEN (1)));
                 }
 
-              if (info != 0) 
+              if (info != 0)
                 {
                   info = -1;
                   retval = FloatComplexDET ();
-                } 
-              else 
+                }
+              else
                 {
-                  for (octave_idx_type i = 0; i < nc; i++) 
+                  for (octave_idx_type i = 0; i < nc; i++)
                     {
                       FloatComplex c = atmp(i,i);
                       retval *= (ipvt(i) != (i+1)) ? -c : c;
                     }
                 }
             }
         }
     }
@@ -1729,26 +1729,26 @@ FloatComplexMatrix::rcond (MatrixType &m
           char uplo = 'U';
           char dia = 'N';
 
           Array<FloatComplex> z (dim_vector (2 * nc, 1));
           FloatComplex *pz = z.fortran_vec ();
           Array<float> rz (dim_vector (nc, 1));
           float *prz = rz.fortran_vec ();
 
-          F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
-                                     F77_CONST_CHAR_ARG2 (&uplo, 1), 
-                                     F77_CONST_CHAR_ARG2 (&dia, 1), 
+          F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
+                                     F77_CONST_CHAR_ARG2 (&uplo, 1),
+                                     F77_CONST_CHAR_ARG2 (&dia, 1),
                                      nr, tmp_data, nr, rcon,
                                      pz, prz, info
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)));
 
-          if (info != 0) 
+          if (info != 0)
             rcon = 0;
         }
       else if  (typ == MatrixType::Permuted_Upper)
         (*current_liboctave_error_handler)
           ("permuted triangular matrix not implemented");
       else if (typ == MatrixType::Lower)
         {
           const FloatComplex *tmp_data = fortran_vec ();
@@ -1757,26 +1757,26 @@ FloatComplexMatrix::rcond (MatrixType &m
           char uplo = 'L';
           char dia = 'N';
 
           Array<FloatComplex> z (dim_vector (2 * nc, 1));
           FloatComplex *pz = z.fortran_vec ();
           Array<float> rz (dim_vector (nc, 1));
           float *prz = rz.fortran_vec ();
 
-          F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
-                                     F77_CONST_CHAR_ARG2 (&uplo, 1), 
-                                     F77_CONST_CHAR_ARG2 (&dia, 1), 
+          F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
+                                     F77_CONST_CHAR_ARG2 (&uplo, 1),
+                                     F77_CONST_CHAR_ARG2 (&dia, 1),
                                      nr, tmp_data, nr, rcon,
                                      pz, prz, info
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)));
 
-          if (info != 0) 
+          if (info != 0)
             rcon = 0.0;
         }
       else if (typ == MatrixType::Permuted_Lower)
         (*current_liboctave_error_handler)
           ("permuted triangular matrix not implemented");
       else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
         {
           float anorm = -1.0;
@@ -1785,40 +1785,40 @@ FloatComplexMatrix::rcond (MatrixType &m
 
           if (typ == MatrixType::Hermitian)
             {
               octave_idx_type info = 0;
               char job = 'L';
               anorm = atmp.abs().sum().
                 row(static_cast<octave_idx_type>(0)).max();
 
-              F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
+              F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                          tmp_data, nr, info
                                          F77_CHAR_ARG_LEN (1)));
 
-              if (info != 0) 
+              if (info != 0)
                 {
                   rcon = 0.0;
 
                   mattype.mark_as_unsymmetric ();
                   typ = MatrixType::Full;
                 }
-              else 
+              else
                 {
                   Array<FloatComplex> z (dim_vector (2 * nc, 1));
                   FloatComplex *pz = z.fortran_vec ();
                   Array<float> rz (dim_vector (nc, 1));
                   float *prz = rz.fortran_vec ();
 
                   F77_XFCN (cpocon, CPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, tmp_data, nr, anorm,
                                              rcon, pz, prz, info
                                              F77_CHAR_ARG_LEN (1)));
 
-                  if (info != 0) 
+                  if (info != 0)
                     rcon = 0.0;
                 }
             }
 
 
           if (typ == MatrixType::Full)
             {
               octave_idx_type info = 0;
@@ -1832,44 +1832,44 @@ FloatComplexMatrix::rcond (MatrixType &m
 
               Array<FloatComplex> z (dim_vector (2 * nc, 1));
               FloatComplex *pz = z.fortran_vec ();
               Array<float> rz (dim_vector (2 * nc, 1));
               float *prz = rz.fortran_vec ();
 
               F77_XFCN (cgetrf, CGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
-              if (info != 0) 
-                { 
+              if (info != 0)
+                {
                   rcon = 0.0;
                   mattype.mark_as_rectangular ();
-                } 
-              else 
+                }
+              else
                 {
                   char job = '1';
                   F77_XFCN (cgecon, CGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                             nc, tmp_data, nr, anorm, 
+                                             nc, tmp_data, nr, anorm,
                                              rcon, pz, prz, info
                                              F77_CHAR_ARG_LEN (1)));
 
-                  if (info != 0) 
+                  if (info != 0)
                     rcon = 0.0;
                 }
             }
         }
       else
         rcon = 0.0;
     }
 
   return rcon;
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::utsolve (MatrixType &mattype, const FloatComplexMatrix& b, 
-                        octave_idx_type& info, float& rcon, 
+FloatComplexMatrix::utsolve (MatrixType &mattype, const FloatComplexMatrix& b,
+                        octave_idx_type& info, float& rcon,
                         solve_singularity_handler sing_handler,
                         bool calc_cond, blas_trans_type transt) const
 {
   FloatComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
@@ -1904,26 +1904,26 @@ FloatComplexMatrix::utsolve (MatrixType 
                   char uplo = 'U';
                   char dia = 'N';
 
                   Array<FloatComplex> z (dim_vector (2 * nc, 1));
                   FloatComplex *pz = z.fortran_vec ();
                   Array<float> rz (dim_vector (nc, 1));
                   float *prz = rz.fortran_vec ();
 
-                  F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
-                                             F77_CONST_CHAR_ARG2 (&uplo, 1), 
-                                             F77_CONST_CHAR_ARG2 (&dia, 1), 
+                  F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
+                                             F77_CONST_CHAR_ARG2 (&uplo, 1),
+                                             F77_CONST_CHAR_ARG2 (&dia, 1),
                                              nr, tmp_data, nr, rcon,
                                              pz, prz, info
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)));
 
-                  if (info != 0) 
+                  if (info != 0)
                     info = -2;
 
                   volatile float rcond_plus_one = rcon + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
@@ -1940,37 +1940,37 @@ FloatComplexMatrix::utsolve (MatrixType 
                 {
                   retval = b;
                   FloatComplex *result = retval.fortran_vec ();
 
                   char uplo = 'U';
                   char trans = get_blas_char (transt);
                   char dia = 'N';
 
-                  F77_XFCN (ctrtrs, CTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
-                                             F77_CONST_CHAR_ARG2 (&trans, 1), 
-                                             F77_CONST_CHAR_ARG2 (&dia, 1), 
+                  F77_XFCN (ctrtrs, CTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1),
+                                             F77_CONST_CHAR_ARG2 (&trans, 1),
+                                             F77_CONST_CHAR_ARG2 (&dia, 1),
                                              nr, b_nc, tmp_data, nr,
                                              result, nr, info
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)));
                 }
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::ltsolve (MatrixType &mattype, const FloatComplexMatrix& b, 
-                        octave_idx_type& info, float& rcon, 
+FloatComplexMatrix::ltsolve (MatrixType &mattype, const FloatComplexMatrix& b,
+                        octave_idx_type& info, float& rcon,
                         solve_singularity_handler sing_handler,
                         bool calc_cond, blas_trans_type transt) const
 {
   FloatComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
@@ -2005,26 +2005,26 @@ FloatComplexMatrix::ltsolve (MatrixType 
                   char uplo = 'L';
                   char dia = 'N';
 
                   Array<FloatComplex> z (dim_vector (2 * nc, 1));
                   FloatComplex *pz = z.fortran_vec ();
                   Array<float> rz (dim_vector (nc, 1));
                   float *prz = rz.fortran_vec ();
 
-                  F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
-                                             F77_CONST_CHAR_ARG2 (&uplo, 1), 
-                                             F77_CONST_CHAR_ARG2 (&dia, 1), 
+                  F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
+                                             F77_CONST_CHAR_ARG2 (&uplo, 1),
+                                             F77_CONST_CHAR_ARG2 (&dia, 1),
                                              nr, tmp_data, nr, rcon,
                                              pz, prz, info
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)));
 
-                  if (info != 0) 
+                  if (info != 0)
                     info = -2;
 
                   volatile float rcond_plus_one = rcon + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
@@ -2041,36 +2041,36 @@ FloatComplexMatrix::ltsolve (MatrixType 
                 {
                   retval = b;
                   FloatComplex *result = retval.fortran_vec ();
 
                   char uplo = 'L';
                   char trans = get_blas_char (transt);
                   char dia = 'N';
 
-                  F77_XFCN (ctrtrs, CTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
-                                             F77_CONST_CHAR_ARG2 (&trans, 1), 
-                                             F77_CONST_CHAR_ARG2 (&dia, 1), 
+                  F77_XFCN (ctrtrs, CTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1),
+                                             F77_CONST_CHAR_ARG2 (&trans, 1),
+                                             F77_CONST_CHAR_ARG2 (&dia, 1),
                                              nr, b_nc, tmp_data, nr,
                                              result, nr, info
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)));
                 }
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::fsolve (MatrixType &mattype, const FloatComplexMatrix& b, 
+FloatComplexMatrix::fsolve (MatrixType &mattype, const FloatComplexMatrix& b,
                        octave_idx_type& info, float& rcon,
                        solve_singularity_handler sing_handler,
                        bool calc_cond) const
 {
   FloatComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -2079,56 +2079,56 @@ FloatComplexMatrix::fsolve (MatrixType &
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || b.cols () == 0)
     retval = FloatComplexMatrix (nc, b.cols (), FloatComplex (0.0, 0.0));
   else
     {
       volatile int typ = mattype.type ();
- 
+
      // Calculate the norm of the matrix, for later use.
       float anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
         {
           info = 0;
           char job = 'L';
           FloatComplexMatrix atmp = *this;
           FloatComplex *tmp_data = atmp.fortran_vec ();
           anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
-          F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
+          F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                      tmp_data, nr, info
                                      F77_CHAR_ARG_LEN (1)));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
-          if (info != 0) 
+          if (info != 0)
             {
               info = -2;
 
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
-          else 
+          else
             {
               if (calc_cond)
                 {
                   Array<FloatComplex> z (dim_vector (2 * nc, 1));
                   FloatComplex *pz = z.fortran_vec ();
                   Array<float> rz (dim_vector (nc, 1));
                   float *prz = rz.fortran_vec ();
 
                   F77_XFCN (cpocon, CPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, tmp_data, nr, anorm,
                                              rcon, pz, prz, info
                                              F77_CHAR_ARG_LEN (1)));
 
-                  if (info != 0) 
+                  if (info != 0)
                     info = -2;
 
                   volatile float rcond_plus_one = rcon + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
@@ -2179,41 +2179,41 @@ FloatComplexMatrix::fsolve (MatrixType &
           // Calculate the norm of the matrix, for later use.
           if (anorm < 0.)
             anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
           F77_XFCN (cgetrf, CGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
-          if (info != 0) 
-            { 
+          if (info != 0)
+            {
               info = -2;
 
               if (sing_handler)
                 sing_handler (rcon);
               else
                 (*current_liboctave_error_handler)
                   ("matrix singular to machine precision");
 
               mattype.mark_as_rectangular ();
-            } 
-          else 
+            }
+          else
             {
               if (calc_cond)
                 {
-                  // Now calculate the condition number for 
+                  // Now calculate the condition number for
                   // non-singular matrix.
                   char job = '1';
                   F77_XFCN (cgecon, CGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                             nc, tmp_data, nr, anorm, 
+                                             nc, tmp_data, nr, anorm,
                                              rcon, pz, prz, info
                                              F77_CHAR_ARG_LEN (1)));
 
-                  if (info != 0) 
+                  if (info != 0)
                     info = -2;
 
                   volatile float rcond_plus_one = rcon + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
@@ -2232,84 +2232,84 @@ FloatComplexMatrix::fsolve (MatrixType &
                   FloatComplex *result = retval.fortran_vec ();
 
                   octave_idx_type b_nc = b.cols ();
 
                   char job = 'N';
                   F77_XFCN (cgetrs, CGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, b_nc, tmp_data, nr,
                                              pipvt, result, b.rows(), info
-                                             F77_CHAR_ARG_LEN (1))); 
+                                             F77_CHAR_ARG_LEN (1)));
                 }
               else
-                mattype.mark_as_rectangular ();             
+                mattype.mark_as_rectangular ();
             }
         }
     }
-  
+
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (MatrixType &typ, const FloatMatrix& b) const
 {
   octave_idx_type info;
   float rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::solve (MatrixType &typ, const FloatMatrix& b, 
+FloatComplexMatrix::solve (MatrixType &typ, const FloatMatrix& b,
                       octave_idx_type& info) const
 {
   float rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info,
                       float& rcon) const
 {
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info, 
+FloatComplexMatrix::solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info,
                       float& rcon, solve_singularity_handler sing_handler,
                       bool singular_fallback, blas_trans_type transt) const
 {
   FloatComplexMatrix tmp (b);
   return solve (typ, tmp, info, rcon, sing_handler, singular_fallback, transt);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b) const
 {
   octave_idx_type info;
   float rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b, 
+FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b,
                       octave_idx_type& info) const
 {
   float rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b, 
+FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b,
                       octave_idx_type& info, float& rcon) const
 {
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::solve (MatrixType &mattype, const FloatComplexMatrix& b, 
+FloatComplexMatrix::solve (MatrixType &mattype, const FloatComplexMatrix& b,
                       octave_idx_type& info, float& rcon,
                       solve_singularity_handler sing_handler,
                       bool singular_fallback, blas_trans_type transt) const
 {
   FloatComplexMatrix retval;
   int typ = mattype.type ();
 
   if (typ == MatrixType::Unknown)
@@ -2346,48 +2346,48 @@ FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType &typ, const FloatColumnVector& b) const
 {
   octave_idx_type info;
   float rcon;
   return solve (typ, FloatComplexColumnVector (b), info, rcon, 0);
 }
 
 FloatComplexColumnVector
-FloatComplexMatrix::solve (MatrixType &typ, const FloatColumnVector& b, 
+FloatComplexMatrix::solve (MatrixType &typ, const FloatColumnVector& b,
                       octave_idx_type& info) const
 {
   float rcon;
   return solve (typ, FloatComplexColumnVector (b), info, rcon, 0);
 }
 
 FloatComplexColumnVector
-FloatComplexMatrix::solve (MatrixType &typ, const FloatColumnVector& b, 
+FloatComplexMatrix::solve (MatrixType &typ, const FloatColumnVector& b,
                       octave_idx_type& info, float& rcon) const
 {
   return solve (typ, FloatComplexColumnVector (b), info, rcon, 0);
 }
 
 FloatComplexColumnVector
-FloatComplexMatrix::solve (MatrixType &typ, const FloatColumnVector& b, 
+FloatComplexMatrix::solve (MatrixType &typ, const FloatColumnVector& b,
                       octave_idx_type& info, float& rcon,
                       solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   return solve (typ, FloatComplexColumnVector (b), info, rcon, sing_handler, transt);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b) const
 {
   octave_idx_type info;
   float rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexColumnVector
-FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b, 
+FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b,
                       octave_idx_type& info) const
 {
   float rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b,
@@ -2476,25 +2476,25 @@ FloatComplexMatrix::solve (const FloatCo
 FloatComplexColumnVector
 FloatComplexMatrix::solve (const FloatColumnVector& b, octave_idx_type& info) const
 {
   float rcon;
   return solve (FloatComplexColumnVector (b), info, rcon, 0);
 }
 
 FloatComplexColumnVector
-FloatComplexMatrix::solve (const FloatColumnVector& b, octave_idx_type& info, 
+FloatComplexMatrix::solve (const FloatColumnVector& b, octave_idx_type& info,
                       float& rcon) const
 {
   return solve (FloatComplexColumnVector (b), info, rcon, 0);
 }
 
 FloatComplexColumnVector
-FloatComplexMatrix::solve (const FloatColumnVector& b, octave_idx_type& info, 
-                      float& rcon, 
+FloatComplexMatrix::solve (const FloatColumnVector& b, octave_idx_type& info,
+                      float& rcon,
                       solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   return solve (FloatComplexColumnVector (b), info, rcon, sing_handler, transt);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (const FloatComplexColumnVector& b) const
 {
@@ -2579,17 +2579,17 @@ FloatComplexMatrix
 FloatComplexMatrix::lssolve (const FloatComplexMatrix& b, octave_idx_type& info,
                         octave_idx_type& rank) const
 {
   float rcon;
   return lssolve (b, info, rank, rcon);
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::lssolve (const FloatComplexMatrix& b, octave_idx_type& info, 
+FloatComplexMatrix::lssolve (const FloatComplexMatrix& b, octave_idx_type& info,
                         octave_idx_type& rank, float& rcon) const
 {
   FloatComplexMatrix retval;
 
   octave_idx_type nrhs = b.cols ();
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
@@ -2704,17 +2704,17 @@ FloatComplexMatrix::lssolve (const Float
             work(0) = lworkaround;
         }
 
       lwork = static_cast<octave_idx_type> (std::real (work(0)));
       work.resize (dim_vector (lwork, 1));
 
       F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, tmp_data, m, pretval,
                                  maxmn, ps, rcon, rank,
-                                 work.fortran_vec (), lwork, 
+                                 work.fortran_vec (), lwork,
                                  prwork, piwork, info));
 
       if (s.elem (0) == 0.0)
         rcon = 0.0;
       else
         rcon = s.elem (minmn - 1) / s.elem (0);
 
       retval.resize (n, nrhs);
@@ -2736,25 +2736,25 @@ FloatComplexColumnVector
 FloatComplexMatrix::lssolve (const FloatColumnVector& b, octave_idx_type& info) const
 {
   octave_idx_type rank;
   float rcon;
   return lssolve (FloatComplexColumnVector (b), info, rank, rcon);
 }
 
 FloatComplexColumnVector
-FloatComplexMatrix::lssolve (const FloatColumnVector& b, octave_idx_type& info, 
+FloatComplexMatrix::lssolve (const FloatColumnVector& b, octave_idx_type& info,
                         octave_idx_type& rank) const
 {
   float rcon;
   return lssolve (FloatComplexColumnVector (b), info, rank, rcon);
 }
 
 FloatComplexColumnVector
-FloatComplexMatrix::lssolve (const FloatColumnVector& b, octave_idx_type& info, 
+FloatComplexMatrix::lssolve (const FloatColumnVector& b, octave_idx_type& info,
                         octave_idx_type& rank, float& rcon) const
 {
   return lssolve (FloatComplexColumnVector (b), info, rank, rcon);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::lssolve (const FloatComplexColumnVector& b) const
 {
@@ -2865,17 +2865,17 @@ FloatComplexMatrix::lssolve (const Float
 
       lwork = static_cast<octave_idx_type> (std::real (work(0)));
       work.resize (dim_vector (lwork, 1));
       rwork.resize (dim_vector (static_cast<octave_idx_type> (rwork(0)), 1));
       iwork.resize (dim_vector (iwork(0), 1));
 
       F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, tmp_data, m, pretval,
                                  maxmn, ps, rcon, rank,
-                                 work.fortran_vec (), lwork, 
+                                 work.fortran_vec (), lwork,
                                  prwork, piwork, info));
 
       if (rank < minmn)
         {
           if (s.elem (0) == 0.0)
             rcon = 0.0;
           else
             rcon = s.elem (minmn - 1) / s.elem (0);
@@ -3094,17 +3094,17 @@ FloatComplexMatrix::any_element_is_inf_o
 bool
 FloatComplexMatrix::all_elements_are_real (void) const
 {
   return do_mx_check<FloatComplex> (*this, mx_inline_all_real);
 }
 
 // Return nonzero if any element of CM has a non-integer real or
 // imaginary part.  Also extract the largest and smallest (real or
-// imaginary) values and return them in MAX_VAL and MIN_VAL. 
+// imaginary) values and return them in MAX_VAL and MIN_VAL.
 
 bool
 FloatComplexMatrix::all_integers (float& max_val, float& min_val) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr > 0 && nc > 0)
@@ -3244,17 +3244,17 @@ FloatComplexMatrix::row_is_real_only (oc
     {
       if (std::imag (elem (i, j)) != 0.0)
         {
           retval = false;
           break;
         }
     }
 
-  return retval;              
+  return retval;
 }
 
 bool
 FloatComplexMatrix::column_is_real_only (octave_idx_type j) const
 {
   bool retval = true;
 
   octave_idx_type nr = rows ();
@@ -3263,17 +3263,17 @@ FloatComplexMatrix::column_is_real_only 
     {
       if (std::imag (elem (i, j)) != 0.0)
         {
           retval = false;
           break;
         }
     }
 
-  return retval;              
+  return retval;
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::row_min (void) const
 {
   Array<octave_idx_type> dummy_idx;
   return row_min (dummy_idx);
 }
@@ -3609,17 +3609,17 @@ done:
   return is;
 }
 
 FloatComplexMatrix
 Givens (const FloatComplex& x, const FloatComplex& y)
 {
   float cc;
   FloatComplex cs, temp_r;
- 
+
   F77_FUNC (clartg, CLARTG) (x, y, cc, cs, temp_r);
 
   FloatComplexMatrix g (2, 2);
 
   g.elem (0, 0) = cc;
   g.elem (1, 1) = cc;
   g.elem (0, 1) = cs;
   g.elem (1, 0) = -conj (cs);
@@ -3635,40 +3635,40 @@ Sylvester (const FloatComplexMatrix& a, 
 
   // FIXME -- need to check that a, b, and c are all the same
   // size.
 
   // Compute Schur decompositions
 
   FloatComplexSCHUR as (a, "U");
   FloatComplexSCHUR bs (b, "U");
-  
+
   // Transform c to new coordinates.
 
   FloatComplexMatrix ua = as.unitary_matrix ();
   FloatComplexMatrix sch_a = as.schur_matrix ();
 
   FloatComplexMatrix ub = bs.unitary_matrix ();
   FloatComplexMatrix sch_b = bs.schur_matrix ();
-  
+
   FloatComplexMatrix cx = ua.hermitian () * c * ub;
 
   // Solve the sylvester equation, back-transform, and return the
   // solution.
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type b_nr = b.rows ();
 
   float scale;
   octave_idx_type info;
 
   FloatComplex *pa = sch_a.fortran_vec ();
   FloatComplex *pb = sch_b.fortran_vec ();
   FloatComplex *px = cx.fortran_vec ();
-  
+
   F77_XFCN (ctrsyl, CTRSYL, (F77_CONST_CHAR_ARG2 ("N", 1),
                              F77_CONST_CHAR_ARG2 ("N", 1),
                              1, a_nr, b_nr, pa, a_nr, pb,
                              b_nr, px, a_nr, scale, info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
   // FIXME -- check info?
@@ -3721,17 +3721,17 @@ static char
 get_blas_trans_arg (bool trans, bool conj)
 {
   return trans ? (conj ? 'C' : 'T') : 'N';
 }
 
 // the general GEMM operation
 
 FloatComplexMatrix
-xgemm (const FloatComplexMatrix& a, const FloatComplexMatrix& b, 
+xgemm (const FloatComplexMatrix& a, const FloatComplexMatrix& b,
        blas_trans_type transa, blas_trans_type transb)
 {
   FloatComplexMatrix retval;
 
   bool tra = transa != blas_no_trans, trb = transb != blas_no_trans;
   bool cja = transa == blas_conj_trans, cjb = transb == blas_conj_trans;
 
   octave_idx_type a_nr = tra ? a.cols () : a.rows ();
@@ -4021,18 +4021,18 @@ max (const FloatComplexMatrix& a, const 
               result (i, j) = xmax (a (i, j), b (i, j));
             }
         }
     }
 
   return result;
 }
 
-FloatComplexMatrix linspace (const FloatComplexColumnVector& x1, 
-                             const FloatComplexColumnVector& x2, 
+FloatComplexMatrix linspace (const FloatComplexColumnVector& x1,
+                             const FloatComplexColumnVector& x2,
                              octave_idx_type n)
 
 {
   if (n < 1) n = 1;
 
   octave_idx_type m = x1.length ();
 
   if (x2.length () != m)
@@ -4040,17 +4040,17 @@ FloatComplexMatrix linspace (const Float
 
   NoAlias<FloatComplexMatrix> retval;
 
   retval.clear (m, n);
   for (octave_idx_type i = 0; i < m; i++)
     retval(i, 0) = x1(i);
 
   // The last column is not needed while using delta.
-  FloatComplex *delta = &retval(0, n-1); 
+  FloatComplex *delta = &retval(0, n-1);
   for (octave_idx_type i = 0; i < m; i++)
     delta[i] = (x2(i) - x1(i)) / (n - 1.0f);
 
   for (octave_idx_type j = 1; j < n-1; j++)
     for (octave_idx_type i = 0; i < m; i++)
       retval(i, j) = x1(i) + static_cast<float> (j)*delta[i];
 
   for (octave_idx_type i = 0; i < m; i++)
diff --git a/liboctave/fCMatrix.h b/liboctave/fCMatrix.h
--- a/liboctave/fCMatrix.h
+++ b/liboctave/fCMatrix.h
@@ -32,17 +32,17 @@ along with Octave; see the file COPYING.
 #include "oct-cmplx.h"
 #include "DET.h"
 
 class
 OCTAVE_API
 FloatComplexMatrix : public MArray<FloatComplex>
 {
 public:
- 
+
   typedef FloatComplexColumnVector column_vector_type;
   typedef FloatComplexRowVector row_vector_type;
 
   typedef void (*solve_singularity_handler) (float rcon);
 
   FloatComplexMatrix (void) : MArray<FloatComplex> () { }
 
   FloatComplexMatrix (octave_idx_type r, octave_idx_type c)
@@ -50,17 +50,17 @@ public:
 
   FloatComplexMatrix (octave_idx_type r, octave_idx_type c,
                       const FloatComplex& val)
     : MArray<FloatComplex> (dim_vector (r, c), val) { }
 
   FloatComplexMatrix (const dim_vector& dv)
     : MArray<FloatComplex> (dv.redim (2)) { }
 
-  FloatComplexMatrix (const dim_vector& dv, const FloatComplex& val) 
+  FloatComplexMatrix (const dim_vector& dv, const FloatComplex& val)
     : MArray<FloatComplex> (dv.redim (2), val) { }
 
   FloatComplexMatrix (const FloatComplexMatrix& a)
     : MArray<FloatComplex> (a) { }
 
   template <class U>
   FloatComplexMatrix (const MArray<U>& a)
     : MArray<FloatComplex> (a.as_matrix ()) { }
@@ -167,142 +167,142 @@ private:
                           float& rcon, int force, int calc_cond) const;
 
   FloatComplexMatrix finverse (MatrixType &mattype, octave_idx_type& info,
                           float& rcon, int force, int calc_cond) const;
 
 public:
   FloatComplexMatrix inverse (void) const;
   FloatComplexMatrix inverse (octave_idx_type& info) const;
-  FloatComplexMatrix inverse (octave_idx_type& info, float& rcon, int force = 0, 
+  FloatComplexMatrix inverse (octave_idx_type& info, float& rcon, int force = 0,
                          int calc_cond = 1) const;
 
   FloatComplexMatrix inverse (MatrixType &mattype) const;
   FloatComplexMatrix inverse (MatrixType &mattype, octave_idx_type& info) const;
   FloatComplexMatrix inverse (MatrixType &mattype, octave_idx_type& info,
-                         float& rcon, int force = 0, 
+                         float& rcon, int force = 0,
                          int calc_cond = 1) const;
 
   FloatComplexMatrix pseudo_inverse (float tol = 0.0) const;
 
   FloatComplexMatrix fourier (void) const;
   FloatComplexMatrix ifourier (void) const;
 
   FloatComplexMatrix fourier2d (void) const;
   FloatComplexMatrix ifourier2d (void) const;
 
   FloatComplexDET determinant (void) const;
   FloatComplexDET determinant (octave_idx_type& info) const;
   FloatComplexDET determinant (octave_idx_type& info, float& rcon, int calc_cond = 1) const;
-  FloatComplexDET determinant (MatrixType &mattype, octave_idx_type& info, 
+  FloatComplexDET determinant (MatrixType &mattype, octave_idx_type& info,
                                float& rcon, int calc_cond = 1) const;
 
   float rcond (void) const;
   float rcond (MatrixType &mattype) const;
 
 private:
   // Upper triangular matrix solvers
   FloatComplexMatrix utsolve (MatrixType &typ, const FloatComplexMatrix& b,
-                  octave_idx_type& info, float& rcon, 
+                  octave_idx_type& info, float& rcon,
                   solve_singularity_handler sing_handler,
                   bool calc_cond = false, blas_trans_type transt = blas_no_trans) const;
 
   // Lower triangular matrix solvers
   FloatComplexMatrix ltsolve (MatrixType &typ, const FloatComplexMatrix& b,
-                  octave_idx_type& info, float& rcon, 
+                  octave_idx_type& info, float& rcon,
                   solve_singularity_handler sing_handler,
                   bool calc_cond = false, blas_trans_type transt = blas_no_trans) const;
 
   // Full matrix solvers (umfpack/cholesky)
   FloatComplexMatrix fsolve (MatrixType &typ, const FloatComplexMatrix& b,
-                 octave_idx_type& info, float& rcon, 
+                 octave_idx_type& info, float& rcon,
                  solve_singularity_handler sing_handler,
                  bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
   FloatComplexMatrix solve (MatrixType &typ, const FloatMatrix& b) const;
-  FloatComplexMatrix solve (MatrixType &typ, const FloatMatrix& b, 
+  FloatComplexMatrix solve (MatrixType &typ, const FloatMatrix& b,
                        octave_idx_type& info) const;
-  FloatComplexMatrix solve (MatrixType &typ, const FloatMatrix& b, 
+  FloatComplexMatrix solve (MatrixType &typ, const FloatMatrix& b,
                        octave_idx_type& info, float& rcon) const;
   FloatComplexMatrix solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info,
                        float& rcon, solve_singularity_handler sing_handler,
-                       bool singular_fallback = true, 
+                       bool singular_fallback = true,
                        blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b) const;
-  FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b, 
+  FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b,
                        octave_idx_type& info) const;
-  FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b, 
+  FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b,
                        octave_idx_type& info, float& rcon) const;
-  FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b, 
+  FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b,
                        octave_idx_type& info, float& rcon,
                        solve_singularity_handler sing_handler,
-                       bool singular_fallback = true, 
+                       bool singular_fallback = true,
                        blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexColumnVector solve (MatrixType &typ, const FloatColumnVector& b) const;
-  FloatComplexColumnVector solve (MatrixType &typ, const FloatColumnVector& b, 
+  FloatComplexColumnVector solve (MatrixType &typ, const FloatColumnVector& b,
                              octave_idx_type& info) const;
-  FloatComplexColumnVector solve (MatrixType &typ, const FloatColumnVector& b, 
+  FloatComplexColumnVector solve (MatrixType &typ, const FloatColumnVector& b,
                              octave_idx_type& info, float& rcon) const;
-  FloatComplexColumnVector solve (MatrixType &typ, const FloatColumnVector& b, 
+  FloatComplexColumnVector solve (MatrixType &typ, const FloatColumnVector& b,
                              octave_idx_type& info, float& rcon,
-                             solve_singularity_handler sing_handler, 
+                             solve_singularity_handler sing_handler,
                              blas_trans_type transt = blas_no_trans) const;
 
-  FloatComplexColumnVector solve (MatrixType &typ, 
+  FloatComplexColumnVector solve (MatrixType &typ,
                              const FloatComplexColumnVector& b) const;
-  FloatComplexColumnVector solve (MatrixType &typ, const FloatComplexColumnVector& b, 
+  FloatComplexColumnVector solve (MatrixType &typ, const FloatComplexColumnVector& b,
                              octave_idx_type& info) const;
-  FloatComplexColumnVector solve (MatrixType &typ, const FloatComplexColumnVector& b, 
+  FloatComplexColumnVector solve (MatrixType &typ, const FloatComplexColumnVector& b,
                              octave_idx_type& info, float& rcon) const;
-  FloatComplexColumnVector solve (MatrixType &typ, const FloatComplexColumnVector& b, 
+  FloatComplexColumnVector solve (MatrixType &typ, const FloatComplexColumnVector& b,
                              octave_idx_type& info, float& rcon,
-                             solve_singularity_handler sing_handler, 
+                             solve_singularity_handler sing_handler,
                              blas_trans_type transt = blas_no_trans) const;
 
   // Generic interface to solver with probing of type
   FloatComplexMatrix solve (const FloatMatrix& b) const;
   FloatComplexMatrix solve (const FloatMatrix& b, octave_idx_type& info) const;
   FloatComplexMatrix solve (const FloatMatrix& b, octave_idx_type& info, float& rcon) const;
   FloatComplexMatrix solve (const FloatMatrix& b, octave_idx_type& info, float& rcon,
-                       solve_singularity_handler sing_handler, 
+                       solve_singularity_handler sing_handler,
                        blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexMatrix solve (const FloatComplexMatrix& b) const;
   FloatComplexMatrix solve (const FloatComplexMatrix& b, octave_idx_type& info) const;
   FloatComplexMatrix solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcon) const;
   FloatComplexMatrix solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcon,
-                       solve_singularity_handler sing_handler, 
+                       solve_singularity_handler sing_handler,
                        blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexColumnVector solve (const FloatColumnVector& b) const;
   FloatComplexColumnVector solve (const FloatColumnVector& b, octave_idx_type& info) const;
   FloatComplexColumnVector solve (const FloatColumnVector& b, octave_idx_type& info,
                              float& rcon) const;
   FloatComplexColumnVector solve (const FloatColumnVector& b, octave_idx_type& info, float& rcon,
-                             solve_singularity_handler sing_handler, 
+                             solve_singularity_handler sing_handler,
                              blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexColumnVector solve (const FloatComplexColumnVector& b) const;
   FloatComplexColumnVector solve (const FloatComplexColumnVector& b, octave_idx_type& info) const;
   FloatComplexColumnVector solve (const FloatComplexColumnVector& b, octave_idx_type& info,
                              float& rcon) const;
   FloatComplexColumnVector solve (const FloatComplexColumnVector& b, octave_idx_type& info,
                              float& rcon,
-                             solve_singularity_handler sing_handler, 
+                             solve_singularity_handler sing_handler,
                              blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexMatrix lssolve (const FloatMatrix& b) const;
   FloatComplexMatrix lssolve (const FloatMatrix& b, octave_idx_type& info) const;
-  FloatComplexMatrix lssolve (const FloatMatrix& b, octave_idx_type& info, 
+  FloatComplexMatrix lssolve (const FloatMatrix& b, octave_idx_type& info,
                          octave_idx_type& rank) const;
-  FloatComplexMatrix lssolve (const FloatMatrix& b, octave_idx_type& info, 
+  FloatComplexMatrix lssolve (const FloatMatrix& b, octave_idx_type& info,
                          octave_idx_type& rank, float& rcon) const;
 
   FloatComplexMatrix lssolve (const FloatComplexMatrix& b) const;
   FloatComplexMatrix lssolve (const FloatComplexMatrix& b, octave_idx_type& info) const;
   FloatComplexMatrix lssolve (const FloatComplexMatrix& b, octave_idx_type& info,
                          octave_idx_type& rank) const;
   FloatComplexMatrix lssolve (const FloatComplexMatrix& b, octave_idx_type& info,
                          octave_idx_type& rank, float& rcon) const;
@@ -363,17 +363,17 @@ public:
   FloatComplexMatrix diag (octave_idx_type k = 0) const;
 
   bool row_is_real_only (octave_idx_type) const;
   bool column_is_real_only (octave_idx_type) const;
 
   FloatComplexColumnVector row_min (void) const;
   FloatComplexColumnVector row_max (void) const;
 
-  FloatComplexColumnVector row_min (Array<octave_idx_type>& index) const; 
+  FloatComplexColumnVector row_min (Array<octave_idx_type>& index) const;
   FloatComplexColumnVector row_max (Array<octave_idx_type>& index) const;
 
   FloatComplexRowVector column_min (void) const;
   FloatComplexRowVector column_max (void) const;
 
   FloatComplexRowVector column_min (Array<octave_idx_type>& index) const;
   FloatComplexRowVector column_max (Array<octave_idx_type>& index) const;
 
@@ -400,35 +400,35 @@ extern OCTAVE_API FloatComplexMatrix
 operator * (const FloatComplexColumnVector& a, const FloatComplexRowVector& b);
 
 extern OCTAVE_API FloatComplexMatrix
 Givens (const FloatComplex&, const FloatComplex&);
 
 extern OCTAVE_API FloatComplexMatrix
 Sylvester (const FloatComplexMatrix&, const FloatComplexMatrix&, const FloatComplexMatrix&);
 
-extern OCTAVE_API FloatComplexMatrix 
+extern OCTAVE_API FloatComplexMatrix
 xgemm (const FloatComplexMatrix& a, const FloatComplexMatrix& b,
-       blas_trans_type transa = blas_no_trans, 
+       blas_trans_type transa = blas_no_trans,
        blas_trans_type transb = blas_no_trans);
 
 extern OCTAVE_API FloatComplexMatrix operator * (const FloatMatrix&,        const FloatComplexMatrix&);
 extern OCTAVE_API FloatComplexMatrix operator * (const FloatComplexMatrix&, const FloatMatrix&);
 extern OCTAVE_API FloatComplexMatrix operator * (const FloatComplexMatrix&, const FloatComplexMatrix&);
 
 extern OCTAVE_API FloatComplexMatrix min (const FloatComplex& c, const FloatComplexMatrix& m);
 extern OCTAVE_API FloatComplexMatrix min (const FloatComplexMatrix& m, const FloatComplex& c);
 extern OCTAVE_API FloatComplexMatrix min (const FloatComplexMatrix& a, const FloatComplexMatrix& b);
 
 extern OCTAVE_API FloatComplexMatrix max (const FloatComplex& c, const FloatComplexMatrix& m);
 extern OCTAVE_API FloatComplexMatrix max (const FloatComplexMatrix& m, const FloatComplex& c);
 extern OCTAVE_API FloatComplexMatrix max (const FloatComplexMatrix& a, const FloatComplexMatrix& b);
 
-extern OCTAVE_API FloatComplexMatrix linspace (const FloatComplexColumnVector& x1, 
-                                               const FloatComplexColumnVector& x2, 
+extern OCTAVE_API FloatComplexMatrix linspace (const FloatComplexColumnVector& x1,
+                                               const FloatComplexColumnVector& x2,
                                                octave_idx_type n);
 
 MS_CMP_OP_DECLS (FloatComplexMatrix, FloatComplex, OCTAVE_API)
 MS_BOOL_OP_DECLS (FloatComplexMatrix, FloatComplex, OCTAVE_API)
 
 SM_CMP_OP_DECLS (FloatComplex, FloatComplexMatrix, OCTAVE_API)
 SM_BOOL_OP_DECLS (FloatComplex, FloatComplexMatrix, OCTAVE_API)
 
diff --git a/liboctave/fCNDArray.cc b/liboctave/fCNDArray.cc
--- a/liboctave/fCNDArray.cc
+++ b/liboctave/fCNDArray.cc
@@ -74,17 +74,17 @@ FloatComplexNDArray::fourier (int dim) c
   octave_idx_type dist = (stride == 1 ? n : 1);
 
   const FloatComplex *in (fortran_vec ());
   FloatComplexNDArray retval (dv);
   FloatComplex *out (retval.fortran_vec ());
 
   // Need to be careful here about the distance between fft's
   for (octave_idx_type k = 0; k < nloop; k++)
-    octave_fftw::fft (in + k * stride * n, out + k * stride * n, 
+    octave_fftw::fft (in + k * stride * n, out + k * stride * n,
                       n, howmany, stride, dist);
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::ifourier (int dim) const
 {
@@ -105,17 +105,17 @@ FloatComplexNDArray::ifourier (int dim) 
   octave_idx_type dist = (stride == 1 ? n : 1);
 
   const FloatComplex *in (fortran_vec ());
   FloatComplexNDArray retval (dv);
   FloatComplex *out (retval.fortran_vec ());
 
   // Need to be careful here about the distance between fft's
   for (octave_idx_type k = 0; k < nloop; k++)
-    octave_fftw::ifft (in + k * stride * n, out + k * stride * n, 
+    octave_fftw::ifft (in + k * stride * n, out + k * stride * n,
                       n, howmany, stride, dist);
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::fourier2d (void) const
 {
@@ -311,17 +311,17 @@ FloatComplexNDArray::fourier2d (void) co
       octave_idx_type npts = dv2(i);
       octave_idx_type nn = 4*npts+15;
       Array<FloatComplex> wsave (nn, 1);
       FloatComplex *pwsave = wsave.fortran_vec ();
       Array<FloatComplex> row (npts, 1);
       FloatComplex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany : 
+      howmany = (stride == 1 ? howmany :
                  (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
@@ -359,17 +359,17 @@ FloatComplexNDArray::ifourier2d (void) c
       octave_idx_type npts = dv2(i);
       octave_idx_type nn = 4*npts+15;
       Array<FloatComplex> wsave (nn, 1);
       FloatComplex *pwsave = wsave.fortran_vec ();
       Array<FloatComplex> row (npts, 1);
       FloatComplex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany : 
+      howmany = (stride == 1 ? howmany :
                  (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
@@ -407,17 +407,17 @@ FloatComplexNDArray::fourierNd (void) co
       octave_idx_type npts = dv(i);
       octave_idx_type nn = 4*npts+15;
       Array<FloatComplex> wsave (nn, 1);
       FloatComplex *pwsave = wsave.fortran_vec ();
       Array<FloatComplex> row (npts, 1);
       FloatComplex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany : 
+      howmany = (stride == 1 ? howmany :
                  (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
@@ -454,17 +454,17 @@ FloatComplexNDArray::ifourierNd (void) c
       octave_idx_type npts = dv(i);
       octave_idx_type nn = 4*npts+15;
       Array<FloatComplex> wsave (nn, 1);
       FloatComplex *pwsave = wsave.fortran_vec ();
       Array<FloatComplex> row (npts, 1);
       FloatComplex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany : 
+      howmany = (stride == 1 ? howmany :
                  (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
@@ -521,30 +521,30 @@ FloatComplexNDArray::any_element_is_inf_
 bool
 FloatComplexNDArray::all_elements_are_real (void) const
 {
   return do_mx_check<FloatComplex> (*this, mx_inline_all_real);
 }
 
 // Return nonzero if any element of CM has a non-integer real or
 // imaginary part.  Also extract the largest and smallest (real or
-// imaginary) values and return them in MAX_VAL and MIN_VAL. 
+// imaginary) values and return them in MAX_VAL and MIN_VAL.
 
 bool
 FloatComplexNDArray::all_integers (float& max_val, float& min_val) const
 {
   octave_idx_type nel = nelem ();
 
   if (nel > 0)
     {
       FloatComplex val = elem (0);
 
       float r_val = std::real (val);
       float i_val = std::imag (val);
-      
+
       max_val = r_val;
       min_val = r_val;
 
       if (i_val > max_val)
         max_val = i_val;
 
       if (i_val < max_val)
         min_val = i_val;
@@ -759,50 +759,50 @@ conj (const FloatComplexNDArray& a)
 {
   return do_mx_unary_map<FloatComplex, FloatComplex, std::conj> (a);
 }
 
 FloatComplexNDArray&
 FloatComplexNDArray::insert (const NDArray& a, octave_idx_type r, octave_idx_type c)
 {
   dim_vector a_dv = a.dims ();
-  
+
   int n = a_dv.length ();
-  
+
   if (n == dimensions.length ())
     {
       Array<octave_idx_type> a_ra_idx (dim_vector (a_dv.length (), 1), 0);
-      
+
       a_ra_idx.elem (0) = r;
       a_ra_idx.elem (1) = c;
-      
+
       for (int i = 0; i < n; i++)
         {
           if (a_ra_idx (i) < 0 || (a_ra_idx (i) + a_dv (i)) > dimensions (i))
             {
               (*current_liboctave_error_handler)
                 ("Array<T>::insert: range error for insert");
               return *this;
             }
         }
-      
+
       a_ra_idx.elem (0) = 0;
       a_ra_idx.elem (1) = 0;
-      
+
       octave_idx_type n_elt = a.numel ();
-      
+
       // IS make_unique () NECCESSARY HERE??
 
       for (octave_idx_type i = 0; i < n_elt; i++)
         {
           Array<octave_idx_type> ra_idx = a_ra_idx;
-          
+
           ra_idx.elem (0) = a_ra_idx (0) + r;
           ra_idx.elem (1) = a_ra_idx (1) + c;
-          
+
           elem (ra_idx) = a.elem (a_ra_idx);
 
           increment_index (a_ra_idx, a_dv);
         }
     }
   else
     (*current_liboctave_error_handler)
       ("Array<T>::insert: invalid indexing operation");
@@ -841,17 +841,17 @@ FloatComplexNDArray::matrix_value (void)
 void
 FloatComplexNDArray::increment_index (Array<octave_idx_type>& ra_idx,
                                  const dim_vector& dimensions,
                                  int start_dimension)
 {
   ::increment_index (ra_idx, dimensions, start_dimension);
 }
 
-octave_idx_type 
+octave_idx_type
 FloatComplexNDArray::compute_index (Array<octave_idx_type>& ra_idx,
                                const dim_vector& dimensions)
 {
   return ::compute_index (ra_idx, dimensions);
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::diag (octave_idx_type k) const
diff --git a/liboctave/fCNDArray.h b/liboctave/fCNDArray.h
--- a/liboctave/fCNDArray.h
+++ b/liboctave/fCNDArray.h
@@ -39,28 +39,28 @@ public:
   typedef FloatComplexMatrix matrix_type;
 
   FloatComplexNDArray (void) : MArray<FloatComplex> () { }
 
   FloatComplexNDArray (const dim_vector& dv) : MArray<FloatComplex> (dv) { }
 
   FloatComplexNDArray (const dim_vector& dv, const FloatComplex& val)
     : MArray<FloatComplex> (dv, val) { }
-  
+
   FloatComplexNDArray (const FloatComplexNDArray& a) : MArray<FloatComplex> (a) { }
 
   FloatComplexNDArray (const FloatComplexMatrix& a) : MArray<FloatComplex> (a) { }
 
   template <class U>
   FloatComplexNDArray (const MArray<U>& a) : MArray<FloatComplex> (a) { }
 
   template <class U>
   FloatComplexNDArray (const Array<U>& a) : MArray<FloatComplex> (a) { }
 
-  FloatComplexNDArray (const charNDArray&); 
+  FloatComplexNDArray (const charNDArray&);
 
   FloatComplexNDArray& operator = (const FloatComplexNDArray& a)
     {
       MArray<FloatComplex>::operator = (a);
       return *this;
     }
 
   // unary operations
@@ -97,17 +97,17 @@ public:
   FloatComplexNDArray cummin (int dim = -1) const;
   FloatComplexNDArray cummin (Array<octave_idx_type>& index, int dim = -1) const;
 
   FloatComplexNDArray diff (octave_idx_type order = 1, int dim = -1) const;
 
   FloatComplexNDArray& insert (const NDArray& a, octave_idx_type r, octave_idx_type c);
   FloatComplexNDArray& insert (const FloatComplexNDArray& a, octave_idx_type r, octave_idx_type c);
   FloatComplexNDArray& insert (const FloatComplexNDArray& a, const Array<octave_idx_type>& ra_idx);
-  
+
   FloatNDArray abs (void) const;
   boolNDArray isnan (void) const;
   boolNDArray isinf (void) const;
   boolNDArray isfinite (void) const;
 
   friend OCTAVE_API FloatComplexNDArray conj (const FloatComplexNDArray& a);
 
   FloatComplexNDArray fourier (int dim = 1) const;
@@ -137,20 +137,20 @@ public:
 
   static FloatComplex resize_fill_value (void) { return FloatComplex (0.0, 0.0); }
 
   //  bool all_elements_are_real (void) const;
   //  bool all_integers (float& max_val, float& min_val) const;
 
   FloatComplexNDArray diag (octave_idx_type k = 0) const;
 
-  FloatComplexNDArray& changesign (void) 
-    { 
-      MArray<FloatComplex>::changesign (); 
-      return *this; 
+  FloatComplexNDArray& changesign (void)
+    {
+      MArray<FloatComplex>::changesign ();
+      return *this;
     }
 
 };
 
 extern OCTAVE_API FloatComplexNDArray conj (const FloatComplexNDArray& a);
 
 MINMAX_DECLS (FloatComplexNDArray, FloatComplex, OCTAVE_API)
 
diff --git a/liboctave/fCRowVector.cc b/liboctave/fCRowVector.cc
--- a/liboctave/fCRowVector.cc
+++ b/liboctave/fCRowVector.cc
@@ -214,23 +214,23 @@ FloatComplexRowVector::append (const Flo
   octave_idx_type len = length ();
   octave_idx_type nc_insert = len;
   FloatComplexRowVector retval (len + a.length ());
   retval.insert (*this, 0);
   retval.insert (a, nc_insert);
   return retval;
 }
 
-FloatComplexColumnVector 
+FloatComplexColumnVector
 FloatComplexRowVector::hermitian (void) const
 {
   return MArray<FloatComplex>::hermitian (std::conj);
 }
 
-FloatComplexColumnVector 
+FloatComplexColumnVector
 FloatComplexRowVector::transpose (void) const
 {
   return MArray<FloatComplex>::transpose ();
 }
 
 FloatComplexRowVector
 conj (const FloatComplexRowVector& a)
 {
diff --git a/liboctave/fCRowVector.h b/liboctave/fCRowVector.h
--- a/liboctave/fCRowVector.h
+++ b/liboctave/fCRowVector.h
@@ -40,17 +40,17 @@ public:
     : MArray<FloatComplex> (dim_vector (1, 0)) { }
 
   explicit FloatComplexRowVector (octave_idx_type n)
     : MArray<FloatComplex> (dim_vector (1, n)) { }
 
   explicit FloatComplexRowVector (const dim_vector& dv)
     : MArray<FloatComplex> (dv.as_row ()) { }
 
-  FloatComplexRowVector (octave_idx_type n, const FloatComplex& val) 
+  FloatComplexRowVector (octave_idx_type n, const FloatComplex& val)
     : MArray<FloatComplex> (dim_vector (1, n), val) { }
 
   FloatComplexRowVector (const FloatComplexRowVector& a)
     : MArray<FloatComplex> (a) { }
 
   FloatComplexRowVector (const MArray<FloatComplex>& a)
     : MArray<FloatComplex> (a.as_row ()) { }
 
diff --git a/liboctave/fCmplxAEPBAL.cc b/liboctave/fCmplxAEPBAL.cc
--- a/liboctave/fCmplxAEPBAL.cc
+++ b/liboctave/fCmplxAEPBAL.cc
@@ -34,29 +34,29 @@ along with Octave; see the file COPYING.
 extern "C"
 {
   F77_RET_T
   F77_FUNC (cgebal, CGEBAL) (F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&, FloatComplex*,
                              const octave_idx_type&, octave_idx_type&,
                              octave_idx_type&, float*, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL);
- 
+
   F77_RET_T
   F77_FUNC (cgebak, CGEBAK) (F77_CONST_CHAR_ARG_DECL,
                              F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&, const octave_idx_type&,
                              const octave_idx_type&, const float*,
                              const octave_idx_type&, FloatComplex*,
                              const octave_idx_type&, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 }
 
-FloatComplexAEPBALANCE::FloatComplexAEPBALANCE (const FloatComplexMatrix& a, 
+FloatComplexAEPBALANCE::FloatComplexAEPBALANCE (const FloatComplexMatrix& a,
                                                 bool noperm, bool noscal)
  : base_aepbal<FloatComplexMatrix, FloatColumnVector> ()
 {
   octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
     {
       (*current_liboctave_error_handler) ("AEPBALANCE requires square matrix");
diff --git a/liboctave/fCmplxAEPBAL.h b/liboctave/fCmplxAEPBAL.h
--- a/liboctave/fCmplxAEPBAL.h
+++ b/liboctave/fCmplxAEPBAL.h
@@ -37,15 +37,15 @@ FloatComplexAEPBALANCE : public base_aep
 {
 public:
 
   FloatComplexAEPBALANCE (void) : base_aepbal<FloatComplexMatrix, FloatColumnVector> () { }
 
   FloatComplexAEPBALANCE (const FloatComplexMatrix& a, bool noperm = false,
                           bool noscal = false);
 
-  FloatComplexAEPBALANCE (const FloatComplexAEPBALANCE& a) 
+  FloatComplexAEPBALANCE (const FloatComplexAEPBALANCE& a)
     : base_aepbal<FloatComplexMatrix, FloatColumnVector> (a) { }
 
   FloatComplexMatrix balancing_matrix (void) const;
 };
 
 #endif
diff --git a/liboctave/fCmplxCHOL.cc b/liboctave/fCmplxCHOL.cc
--- a/liboctave/fCmplxCHOL.cc
+++ b/liboctave/fCmplxCHOL.cc
@@ -108,39 +108,39 @@ FloatComplexCHOL::init (const FloatCompl
         chol_mat.xelem (i, j) = a(i, j);
       for (octave_idx_type i = j+1; i < n; i++)
         chol_mat.xelem (i, j) = 0.0f;
     }
   FloatComplex *h = chol_mat.fortran_vec ();
 
   // Calculate the norm of the matrix, for later use.
   float anorm = 0;
-  if (calc_cond) 
+  if (calc_cond)
     anorm = xnorm (a, 1);
 
   F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 ("U", 1), n, h, n, info
                              F77_CHAR_ARG_LEN (1)));
 
   xrcond = 0.0;
   if (info > 0)
     chol_mat.resize (info - 1, info - 1);
-  else if (calc_cond) 
+  else if (calc_cond)
     {
       octave_idx_type cpocon_info = 0;
 
       // Now calculate the condition number for non-singular matrix.
       Array<FloatComplex> z (dim_vector (2*n, 1));
       FloatComplex *pz = z.fortran_vec ();
       Array<float> rz (dim_vector (n, 1));
       float *prz = rz.fortran_vec ();
       F77_XFCN (cpocon, CPOCON, (F77_CONST_CHAR_ARG2 ("U", 1), n, h,
                                  n, anorm, xrcond, pz, prz, cpocon_info
                                  F77_CHAR_ARG_LEN (1)));
 
-      if (cpocon_info != 0) 
+      if (cpocon_info != 0)
         info = -1;
     }
 
   return info;
 }
 
 static FloatComplexMatrix
 chol2inv_internal (const FloatComplexMatrix& r)
@@ -182,17 +182,17 @@ FloatComplexMatrix
 FloatComplexCHOL::inverse (void) const
 {
   return chol2inv_internal (chol_mat);
 }
 
 void
 FloatComplexCHOL::set (const FloatComplexMatrix& R)
 {
-  if (R.is_square ()) 
+  if (R.is_square ())
     chol_mat = R;
   else
     (*current_liboctave_error_handler) ("CHOL requires square matrix");
 }
 
 #ifdef HAVE_QRUPDATE
 
 void
@@ -236,17 +236,17 @@ FloatComplexCHOL::downdate (const FloatC
 }
 
 octave_idx_type
 FloatComplexCHOL::insert_sym (const FloatComplexColumnVector& u, octave_idx_type j)
 {
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
-  
+
   if (u.length () != n + 1)
     (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
   else if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("cholinsert: index out of range");
   else
     {
       FloatComplexColumnVector utmp = u;
 
@@ -260,36 +260,36 @@ FloatComplexCHOL::insert_sym (const Floa
 
   return info;
 }
 
 void
 FloatComplexCHOL::delete_sym (octave_idx_type j)
 {
   octave_idx_type n = chol_mat.rows ();
-  
+
   if (j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("choldelete: index out of range");
   else
     {
       OCTAVE_LOCAL_BUFFER (float, rw, n);
 
-      F77_XFCN (cchdex, CCHDEX, (n, chol_mat.fortran_vec (), chol_mat.rows (), 
+      F77_XFCN (cchdex, CCHDEX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
                                  j + 1, rw));
 
       chol_mat.resize (n-1, n-1);
     }
 }
 
 void
 FloatComplexCHOL::shift_sym (octave_idx_type i, octave_idx_type j)
 {
   octave_idx_type n = chol_mat.rows ();
-  
-  if (i < 0 || i > n-1 || j < 0 || j > n-1) 
+
+  if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("cholshift: index out of range");
   else
     {
       OCTAVE_LOCAL_BUFFER (FloatComplex, w, n);
       OCTAVE_LOCAL_BUFFER (float, rw, n);
 
       F77_XFCN (cchshx, CCHSHX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
                                  i + 1, j + 1, w, rw));
@@ -302,17 +302,17 @@ void
 FloatComplexCHOL::update (const FloatComplexColumnVector& u)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = chol_mat.rows ();
 
   if (u.length () == n)
     {
-      init (chol_mat.hermitian () * chol_mat 
+      init (chol_mat.hermitian () * chol_mat
             + FloatComplexMatrix (u) * FloatComplexMatrix (u).hermitian (), false);
     }
   else
     (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 }
 
 static bool
 singular (const FloatComplexMatrix& a)
@@ -332,17 +332,17 @@ FloatComplexCHOL::downdate (const FloatC
   octave_idx_type n = chol_mat.rows ();
 
   if (u.length () == n)
     {
       if (singular (chol_mat))
         info = 2;
       else
         {
-          info = init (chol_mat.hermitian () * chol_mat 
+          info = init (chol_mat.hermitian () * chol_mat
                        - FloatComplexMatrix (u) * FloatComplexMatrix (u).hermitian (), false);
           if (info) info = 1;
         }
     }
   else
     (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
   return info;
@@ -409,17 +409,17 @@ FloatComplexCHOL::delete_sym (octave_idx
 
 void
 FloatComplexCHOL::shift_sym (octave_idx_type i, octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = chol_mat.rows ();
 
-  if (i < 0 || i > n-1 || j < 0 || j > n-1) 
+  if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("cholshift: index out of range");
   else
     {
       FloatComplexMatrix a = chol_mat.hermitian () * chol_mat;
       Array<octave_idx_type> p (dim_vector (n, 1));
       for (octave_idx_type k = 0; k < n; k++) p(k) = k;
       if (i < j)
         {
diff --git a/liboctave/fCmplxGEPBAL.cc b/liboctave/fCmplxGEPBAL.cc
--- a/liboctave/fCmplxGEPBAL.cc
+++ b/liboctave/fCmplxGEPBAL.cc
@@ -53,32 +53,32 @@ extern "C"
                              const float* RSCALE, octave_idx_type& M, float* V,
                              const octave_idx_type& LDV, octave_idx_type& INFO
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
 }
 
 octave_idx_type
-FloatComplexGEPBALANCE::init (const FloatComplexMatrix& a, const FloatComplexMatrix& b, 
+FloatComplexGEPBALANCE::init (const FloatComplexMatrix& a, const FloatComplexMatrix& b,
                   const std::string& balance_job)
 {
   octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
     {
       (*current_liboctave_error_handler) ("FloatComplexGEPBALANCE requires square matrix");
       return -1;
     }
 
   if (a.dims() != b.dims ())
     {
       gripe_nonconformant ("FloatComplexGEPBALANCE", n, n, b.rows(), b.cols());
       return -1;
-    } 
+    }
 
   octave_idx_type info;
   octave_idx_type ilo;
   octave_idx_type ihi;
 
   OCTAVE_LOCAL_BUFFER (float, plscale, n);
   OCTAVE_LOCAL_BUFFER (float, prscale, n);
   OCTAVE_LOCAL_BUFFER (float, pwork, 6 * n);
@@ -109,17 +109,17 @@ FloatComplexGEPBALANCE::init (const Floa
 
   // first left
   F77_XFCN (sggbak, SGGBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
                              F77_CONST_CHAR_ARG2 ("L", 1),
                              n, ilo, ihi, plscale, prscale,
                              n, p_balancing_mat, n, info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
-      
+
   // then right
   F77_XFCN (sggbak, SGGBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
                              F77_CONST_CHAR_ARG2 ("R", 1),
                              n, ilo, ihi, plscale, prscale,
                              n, p_balancing_mat2, n, info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
diff --git a/liboctave/fCmplxGEPBAL.h b/liboctave/fCmplxGEPBAL.h
--- a/liboctave/fCmplxGEPBAL.h
+++ b/liboctave/fCmplxGEPBAL.h
@@ -39,17 +39,17 @@ public:
     : balanced_mat (), balanced_mat2 (), balancing_mat (), balancing_mat2 ()
     { }
 
   FloatComplexGEPBALANCE (const FloatComplexMatrix& a,
                           const FloatComplexMatrix& b,
                           const std::string& balance_job)
     : balanced_mat (), balanced_mat2 (), balancing_mat (), balancing_mat2 ()
     {
-      init (a, b, balance_job); 
+      init (a, b, balance_job);
     }
 
   FloatComplexGEPBALANCE (const FloatComplexGEPBALANCE& a)
     : balanced_mat (a.balanced_mat), balanced_mat2 (a.balanced_mat2),
       balancing_mat (a.balancing_mat), balancing_mat2 (a.balancing_mat2)
     { }
 
   FloatComplexGEPBALANCE& operator = (const FloatComplexGEPBALANCE& a)
@@ -78,13 +78,13 @@ public:
 
 private:
 
   FloatComplexMatrix balanced_mat;
   FloatComplexMatrix balanced_mat2;
   FloatMatrix balancing_mat;
   FloatMatrix balancing_mat2;
 
-  octave_idx_type init (const FloatComplexMatrix& a, const FloatComplexMatrix& b, 
+  octave_idx_type init (const FloatComplexMatrix& a, const FloatComplexMatrix& b,
                         const std::string& balance_job);
 };
 
 #endif
diff --git a/liboctave/fCmplxHESS.cc b/liboctave/fCmplxHESS.cc
--- a/liboctave/fCmplxHESS.cc
+++ b/liboctave/fCmplxHESS.cc
@@ -31,24 +31,24 @@ along with Octave; see the file COPYING.
 extern "C"
 {
   F77_RET_T
   F77_FUNC (cgebal, CGEBAL) (F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&, FloatComplex*,
                              const octave_idx_type&, octave_idx_type&,
                              octave_idx_type&, float*, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL);
- 
+
   F77_RET_T
   F77_FUNC (cgehrd, CGEHRD) (const octave_idx_type&, const octave_idx_type&,
                              const octave_idx_type&, FloatComplex*,
                              const octave_idx_type&, FloatComplex*,
                              FloatComplex*, const octave_idx_type&,
                              octave_idx_type&);
- 
+
   F77_RET_T
   F77_FUNC (cunghr, CUNGHR) (const octave_idx_type&, const octave_idx_type&,
                              const octave_idx_type&, FloatComplex*,
                              const octave_idx_type&, FloatComplex*,
                              FloatComplex*, const octave_idx_type&,
                              octave_idx_type&);
 
   F77_RET_T
diff --git a/liboctave/fCmplxLU.h b/liboctave/fCmplxLU.h
--- a/liboctave/fCmplxLU.h
+++ b/liboctave/fCmplxLU.h
@@ -36,17 +36,17 @@ public:
   FloatComplexLU (void)
     : base_lu <FloatComplexMatrix> () { }
 
   FloatComplexLU (const FloatComplexMatrix& a);
 
   FloatComplexLU (const FloatComplexLU& a)
     : base_lu <FloatComplexMatrix> (a) { }
 
-  FloatComplexLU (const FloatComplexMatrix& l, const FloatComplexMatrix& u, 
+  FloatComplexLU (const FloatComplexMatrix& l, const FloatComplexMatrix& u,
                   const PermMatrix& p)
     : base_lu <FloatComplexMatrix> (l, u, p) { }
 
   FloatComplexLU& operator = (const FloatComplexLU& a)
     {
       if (this != &a)
         base_lu <FloatComplexMatrix> :: operator = (a);
 
diff --git a/liboctave/fCmplxQR.cc b/liboctave/fCmplxQR.cc
--- a/liboctave/fCmplxQR.cc
+++ b/liboctave/fCmplxQR.cc
@@ -38,17 +38,17 @@ along with Octave; see the file COPYING.
 template class base_qr<FloatComplexMatrix>;
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (cgeqrf, CGEQRF) (const octave_idx_type&, const octave_idx_type&,
                              FloatComplex*, const octave_idx_type&,
                              FloatComplex*, FloatComplex*,
-                             const octave_idx_type&, octave_idx_type&); 
+                             const octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (cungqr, CUNGQR) (const octave_idx_type&, const octave_idx_type&,
                              const octave_idx_type&, FloatComplex*,
                              const octave_idx_type&, FloatComplex*,
                              FloatComplex*, const octave_idx_type&,
                              octave_idx_type&);
 
@@ -71,24 +71,24 @@ extern "C"
   F77_RET_T
   F77_FUNC (cqrdec, CQRDEC) (const octave_idx_type&, const octave_idx_type&,
                              const octave_idx_type&, FloatComplex*,
                              const octave_idx_type&, FloatComplex*,
                              const octave_idx_type&, const octave_idx_type&,
                              float*);
 
   F77_RET_T
-  F77_FUNC (cqrinr, CQRINR) (const octave_idx_type&, const octave_idx_type&, 
+  F77_FUNC (cqrinr, CQRINR) (const octave_idx_type&, const octave_idx_type&,
                              FloatComplex*, const octave_idx_type&,
                              FloatComplex*, const octave_idx_type&,
                              const octave_idx_type&, const FloatComplex*,
                              float*);
 
   F77_RET_T
-  F77_FUNC (cqrder, CQRDER) (const octave_idx_type&, const octave_idx_type&, 
+  F77_FUNC (cqrder, CQRDER) (const octave_idx_type&, const octave_idx_type&,
                              FloatComplex*, const octave_idx_type&,
                              FloatComplex*, const octave_idx_type&,
                              const octave_idx_type&, FloatComplex*, float*);
 
   F77_RET_T
   F77_FUNC (cqrshc, CQRSHC) (const octave_idx_type&, const octave_idx_type&,
                              const octave_idx_type&, FloatComplex*,
                              const octave_idx_type&, FloatComplex*,
@@ -130,17 +130,17 @@ FloatComplexQR::init (const FloatComplex
       lwork = std::max (lwork, static_cast<octave_idx_type> (1));
       OCTAVE_LOCAL_BUFFER (FloatComplex, work, lwork);
       F77_XFCN (cgeqrf, CGEQRF, (m, n, afact.fortran_vec (), m, tau, work, lwork, info));
     }
 
   form (n, afact, tau, qr_type);
 }
 
-void FloatComplexQR::form (octave_idx_type n, FloatComplexMatrix& afact, 
+void FloatComplexQR::form (octave_idx_type n, FloatComplexMatrix& afact,
                            FloatComplex *tau, qr_type_t qr_type)
 {
   octave_idx_type m = afact.rows (), min_mn = std::min (m, n);
   octave_idx_type info;
 
   if (qr_type == qr_type_raw)
     {
       for (octave_idx_type j = 0; j < min_mn; j++)
@@ -250,34 +250,34 @@ void
 FloatComplexQR::insert_col (const FloatComplexColumnVector& u, octave_idx_type j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
   if (u.length () != m)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (j < 0 || j > n) 
+  else if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       if (k < m)
         {
           q.resize (m, k+1);
           r.resize (k+1, n+1);
         }
       else
         {
           r.resize (k, n+1);
         }
 
       FloatComplexColumnVector utmp = u;
       OCTAVE_LOCAL_BUFFER (float, rw, k);
       F77_XFCN (cqrinc, CQRINC, (m, n, k, q.fortran_vec (), q.rows (),
-                                 r.fortran_vec (), r.rows (), j + 1, 
+                                 r.fortran_vec (), r.rows (), j + 1,
                                  utmp.data (), rw));
     }
 }
 
 void
 FloatComplexQR::insert_col (const FloatComplexMatrix& u, const Array<octave_idx_type>& j)
 {
   octave_idx_type m = q.rows ();
@@ -309,32 +309,32 @@ FloatComplexQR::insert_col (const FloatC
         {
           r.resize (k, n + nj);
         }
 
       OCTAVE_LOCAL_BUFFER (float, rw, kmax);
       for (volatile octave_idx_type i = 0; i < js.length (); i++)
         {
           octave_idx_type ii = i;
-          F77_XFCN (cqrinc, CQRINC, (m, n + ii, std::min (kmax, k + ii), 
+          F77_XFCN (cqrinc, CQRINC, (m, n + ii, std::min (kmax, k + ii),
                                      q.fortran_vec (), q.rows (),
-                                     r.fortran_vec (), r.rows (), js(ii) + 1, 
+                                     r.fortran_vec (), r.rows (), js(ii) + 1,
                                      u.column (jsi(i)).data (), rw));
         }
     }
 }
 
 void
 FloatComplexQR::delete_col (octave_idx_type j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type k = r.rows ();
   octave_idx_type n = r.columns ();
 
-  if (j < 0 || j > n-1) 
+  if (j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
   else
     {
       OCTAVE_LOCAL_BUFFER (float, rw, k);
       F77_XFCN (cqrdec, CQRDEC, (m, n, k, q.fortran_vec (), q.rows (),
                                  r.fortran_vec (), r.rows (), j + 1, rw));
 
       if (k < m)
@@ -368,17 +368,17 @@ FloatComplexQR::delete_col (const Array<
   else if (nj > 0 && (js(0) > n-1 || js(nj-1) < 0))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else if (nj > 0)
     {
       OCTAVE_LOCAL_BUFFER (float, rw, k);
       for (volatile octave_idx_type i = 0; i < js.length (); i++)
         {
           octave_idx_type ii = i;
-          F77_XFCN (cqrdec, CQRDEC, (m, n - ii, k == m ? k : k - ii, 
+          F77_XFCN (cqrdec, CQRDEC, (m, n - ii, k == m ? k : k - ii,
                                      q.fortran_vec (), q.rows (),
                                      r.fortran_vec (), r.rows (), js(ii) + 1, rw));
         }
       if (k < m)
         {
           q.resize (m, k - nj);
           r.resize (k - nj, n - nj);
         }
@@ -394,40 +394,40 @@ void
 FloatComplexQR::insert_row (const FloatComplexRowVector& u, octave_idx_type j)
 {
   octave_idx_type m = r.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = std::min (m, n);
 
   if (! q.is_square () || u.length () != n)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (j < 0 || j > m) 
+  else if (j < 0 || j > m)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       q.resize (m + 1, m + 1);
       r.resize (m + 1, n);
       FloatComplexRowVector utmp = u;
       OCTAVE_LOCAL_BUFFER (float, rw, k);
       F77_XFCN (cqrinr, CQRINR, (m, n, q.fortran_vec (), q.rows (),
-                                 r.fortran_vec (), r.rows (), 
+                                 r.fortran_vec (), r.rows (),
                                  j + 1, utmp.fortran_vec (), rw));
 
     }
 }
 
 void
 FloatComplexQR::delete_row (octave_idx_type j)
 {
   octave_idx_type m = r.rows ();
   octave_idx_type n = r.columns ();
 
   if (! q.is_square ())
     (*current_liboctave_error_handler) ("qrdelete: dimensions mismatch");
-  else if (j < 0 || j > m-1) 
+  else if (j < 0 || j > m-1)
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
   else
     {
       OCTAVE_LOCAL_BUFFER (FloatComplex, w, m);
       OCTAVE_LOCAL_BUFFER (float, rw, m);
       F77_XFCN (cqrder, CQRDER, (m, n, q.fortran_vec (), q.rows (),
                                  r.fortran_vec (), r.rows (), j + 1,
                                  w, rw));
@@ -439,23 +439,23 @@ FloatComplexQR::delete_row (octave_idx_t
 
 void
 FloatComplexQR::shift_cols (octave_idx_type i, octave_idx_type j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type k = r.rows ();
   octave_idx_type n = r.columns ();
 
-  if (i < 0 || i > n-1 || j < 0 || j > n-1) 
+  if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("qrshift: index out of range");
   else
     {
       OCTAVE_LOCAL_BUFFER (FloatComplex, w, k);
       OCTAVE_LOCAL_BUFFER (float, rw, k);
-      F77_XFCN (cqrshc, CQRSHC, (m, n, k, 
+      F77_XFCN (cqrshc, CQRSHC, (m, n, k,
                                  q.fortran_vec (), q.rows (),
                                  r.fortran_vec (), r.rows (),
                                  i + 1, j + 1, w, rw));
     }
 }
 
 #else
 
@@ -531,17 +531,17 @@ static
 FloatComplexMatrix delete_row (const FloatComplexMatrix& a, octave_idx_type i)
 {
   FloatComplexMatrix retval = a;
   retval.delete_elements (0, idx_vector (i));
   return retval;
 }
 
 static
-FloatComplexMatrix shift_cols (const FloatComplexMatrix& a, 
+FloatComplexMatrix shift_cols (const FloatComplexMatrix& a,
                                octave_idx_type i, octave_idx_type j)
 {
   octave_idx_type n = a.columns ();
   Array<octave_idx_type> p (n);
   for (octave_idx_type k = 0; k < n; k++) p(k) = k;
   if (i < j)
     {
       for (octave_idx_type k = i; k < j; k++) p(k) = k+1;
@@ -561,17 +561,17 @@ FloatComplexQR::insert_col (const FloatC
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
   if (u.length () != m)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (j < 0 || j > n) 
+  else if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       init (::insert_col (q*r, j, u), get_type ());
     }
 }
 
 void
@@ -607,17 +607,17 @@ FloatComplexQR::insert_col (const FloatC
 void
 FloatComplexQR::delete_col (octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
-  if (j < 0 || j > n-1) 
+  if (j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
   else
     {
       init (::delete_col (q*r, j), get_type ());
     }
 }
 
 void
@@ -653,17 +653,17 @@ FloatComplexQR::insert_row (const FloatC
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = r.rows ();
   octave_idx_type n = r.columns ();
 
   if (! q.is_square () || u.length () != n)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (j < 0 || j > m) 
+  else if (j < 0 || j > m)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       init (::insert_row (q*r, j, u), get_type ());
     }
 }
 
 void
@@ -671,33 +671,33 @@ FloatComplexQR::delete_row (octave_idx_t
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = r.rows ();
   octave_idx_type n = r.columns ();
 
   if (! q.is_square ())
     (*current_liboctave_error_handler) ("qrdelete: dimensions mismatch");
-  else if (j < 0 || j > m-1) 
+  else if (j < 0 || j > m-1)
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
   else
     {
       init (::delete_row (q*r, j), get_type ());
     }
 }
 
 void
 FloatComplexQR::shift_cols (octave_idx_type i, octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
-  if (i < 0 || i > n-1 || j < 0 || j > n-1) 
+  if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("qrshift: index out of range");
   else
     {
       init (::shift_cols (q*r, i, j), get_type ());
     }
 }
 
 #endif
diff --git a/liboctave/fCmplxQR.h b/liboctave/fCmplxQR.h
--- a/liboctave/fCmplxQR.h
+++ b/liboctave/fCmplxQR.h
@@ -38,17 +38,17 @@ OCTAVE_API
 FloatComplexQR : public base_qr<FloatComplexMatrix>
 {
 public:
 
   FloatComplexQR (void) : base_qr<FloatComplexMatrix> () { }
 
   FloatComplexQR (const FloatComplexMatrix&, qr_type_t = qr_type_std);
 
-  FloatComplexQR (const FloatComplexMatrix& qx, const FloatComplexMatrix& rx) 
+  FloatComplexQR (const FloatComplexMatrix& qx, const FloatComplexMatrix& rx)
     : base_qr<FloatComplexMatrix> (qx, rx) { }
 
   FloatComplexQR (const FloatComplexQR& a) : base_qr<FloatComplexMatrix> (a) { }
 
   void init (const FloatComplexMatrix&, qr_type_t = qr_type_std);
 
   void update (const FloatComplexColumnVector& u, const FloatComplexColumnVector& v);
 
@@ -65,13 +65,13 @@ public:
   void insert_row (const FloatComplexRowVector& u, octave_idx_type j);
 
   void delete_row (octave_idx_type j);
 
   void shift_cols (octave_idx_type i, octave_idx_type j);
 
 protected:
 
-  void form (octave_idx_type n, FloatComplexMatrix& afact, 
+  void form (octave_idx_type n, FloatComplexMatrix& afact,
              FloatComplex *tau, qr_type_t qr_type);
 };
 
 #endif
diff --git a/liboctave/fCmplxQRP.cc b/liboctave/fCmplxQRP.cc
--- a/liboctave/fCmplxQRP.cc
+++ b/liboctave/fCmplxQRP.cc
@@ -92,15 +92,15 @@ FloatComplexQRP::init (const FloatComple
 
   jpvt -= static_cast<octave_idx_type> (1);
   p = PermMatrix (jpvt, true);
 
 
   form (n, afact, tau, qr_type);
 }
 
-FloatRowVector 
+FloatRowVector
 FloatComplexQRP::Pvec (void) const
 {
   Array<float> pa (p.pvec ());
   FloatRowVector pv (MArray<float> (pa) + 1.0f);
   return pv;
 }
diff --git a/liboctave/fCmplxSCHUR.cc b/liboctave/fCmplxSCHUR.cc
--- a/liboctave/fCmplxSCHUR.cc
+++ b/liboctave/fCmplxSCHUR.cc
@@ -58,17 +58,17 @@ select_ana (const FloatComplex& a)
 
 static octave_idx_type
 select_dig (const FloatComplex& a)
 {
   return (abs (a) < 1.0);
 }
 
 octave_idx_type
-FloatComplexSCHUR::init (const FloatComplexMatrix& a, const std::string& ord, 
+FloatComplexSCHUR::init (const FloatComplexMatrix& a, const std::string& ord,
                     bool calc_unitary)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
     {
       (*current_liboctave_error_handler)
@@ -142,17 +142,17 @@ FloatComplexSCHUR::init (const FloatComp
                              pwork, lwork, prwork, pbwork, info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
   return info;
 }
 
-FloatComplexSCHUR::FloatComplexSCHUR (const FloatComplexMatrix& s, 
+FloatComplexSCHUR::FloatComplexSCHUR (const FloatComplexMatrix& s,
                                       const FloatComplexMatrix& u)
   : schur_mat (s), unitary_mat (u), selector (0)
 {
   octave_idx_type n = s.rows ();
   if (s.columns () != n || u.rows () != n || u.columns () != n)
     (*current_liboctave_error_handler)
       ("schur: inconsistent matrix dimensions");
 }
diff --git a/liboctave/fCmplxSVD.h b/liboctave/fCmplxSVD.h
--- a/liboctave/fCmplxSVD.h
+++ b/liboctave/fCmplxSVD.h
@@ -34,27 +34,27 @@ OCTAVE_API
 FloatComplexSVD
 {
 public:
 
   FloatComplexSVD (void)
     : type_computed (), sigma (), left_sm (), right_sm ()
     { }
 
-  FloatComplexSVD (const FloatComplexMatrix& a, 
+  FloatComplexSVD (const FloatComplexMatrix& a,
                    SVD::type svd_type = SVD::std,
-                   SVD::driver svd_driver = SVD::GESVD) 
+                   SVD::driver svd_driver = SVD::GESVD)
     : type_computed (), sigma (), left_sm (), right_sm ()
     {
       init (a, svd_type, svd_driver);
     }
 
   FloatComplexSVD (const FloatComplexMatrix& a, octave_idx_type& info,
                    SVD::type svd_type = SVD::std,
-                   SVD::driver svd_driver = SVD::GESVD) 
+                   SVD::driver svd_driver = SVD::GESVD)
     : type_computed (), sigma (), left_sm (), right_sm ()
     {
       info = init (a, svd_type, svd_driver);
     }
 
   FloatComplexSVD (const FloatComplexSVD& a)
     : type_computed (a.type_computed), sigma (a.sigma),
       left_sm (a.left_sm), right_sm (a.right_sm)
@@ -85,14 +85,14 @@ public:
 private:
 
   SVD::type type_computed;
 
   FloatDiagMatrix sigma;
   FloatComplexMatrix left_sm;
   FloatComplexMatrix right_sm;
 
-  octave_idx_type init (const FloatComplexMatrix& a, 
-                        SVD::type svd_type = SVD::std, 
+  octave_idx_type init (const FloatComplexMatrix& a,
+                        SVD::type svd_type = SVD::std,
                         SVD::driver svd_driver = SVD::GESVD);
 };
 
 #endif
diff --git a/liboctave/fColVector.h b/liboctave/fColVector.h
--- a/liboctave/fColVector.h
+++ b/liboctave/fColVector.h
@@ -34,17 +34,17 @@ FloatColumnVector : public MArray<float>
 {
 public:
 
   FloatColumnVector (void) : MArray<float> (dim_vector (0, 1)) { }
 
   explicit FloatColumnVector (octave_idx_type n)
     : MArray<float> (dim_vector (n, 1)) { }
 
-  explicit FloatColumnVector (const dim_vector& dv) 
+  explicit FloatColumnVector (const dim_vector& dv)
     : MArray<float> (dv.as_column ()) { }
 
   FloatColumnVector (octave_idx_type n, float val)
     : MArray<float> (dim_vector (n, 1), val) { }
 
   FloatColumnVector (const FloatColumnVector& a) : MArray<float> (a) { }
 
   FloatColumnVector (const MArray<float>& a)
diff --git a/liboctave/fDiagMatrix.cc b/liboctave/fDiagMatrix.cc
--- a/liboctave/fDiagMatrix.cc
+++ b/liboctave/fDiagMatrix.cc
@@ -179,83 +179,83 @@ FloatDiagMatrix::extract (octave_idx_typ
 FloatRowVector
 FloatDiagMatrix::row (octave_idx_type i) const
 {
   octave_idx_type r = rows ();
   octave_idx_type c = cols ();
   if (i < 0 || i >= r)
     {
       (*current_liboctave_error_handler) ("invalid row selection");
-      return FloatRowVector (); 
+      return FloatRowVector ();
     }
 
   FloatRowVector retval (c, 0.0);
   if (r <= c || (r > c && i < c))
     retval.elem (i) = elem (i, i);
 
   return retval;
 }
 
 FloatRowVector
 FloatDiagMatrix::row (char *s) const
 {
   if (! s)
     {
       (*current_liboctave_error_handler) ("invalid row selection");
-      return FloatRowVector (); 
+      return FloatRowVector ();
     }
 
   char c = *s;
   if (c == 'f' || c == 'F')
     return row (static_cast<octave_idx_type>(0));
   else if (c == 'l' || c == 'L')
     return row (rows () - 1);
   else
     {
       (*current_liboctave_error_handler) ("invalid row selection");
-      return FloatRowVector (); 
+      return FloatRowVector ();
     }
 }
 
 FloatColumnVector
 FloatDiagMatrix::column (octave_idx_type i) const
 {
   octave_idx_type r = rows ();
   octave_idx_type c = cols ();
   if (i < 0 || i >= c)
     {
       (*current_liboctave_error_handler) ("invalid column selection");
-      return FloatColumnVector (); 
+      return FloatColumnVector ();
     }
 
   FloatColumnVector retval (r, 0.0);
   if (r >= c || (r < c && i < r))
     retval.elem (i) = elem (i, i);
 
   return retval;
 }
 
 FloatColumnVector
 FloatDiagMatrix::column (char *s) const
 {
   if (! s)
     {
       (*current_liboctave_error_handler) ("invalid column selection");
-      return FloatColumnVector (); 
+      return FloatColumnVector ();
     }
 
   char c = *s;
   if (c == 'f' || c == 'F')
     return column (static_cast<octave_idx_type>(0));
   else if (c == 'l' || c == 'L')
     return column (cols () - 1);
   else
     {
       (*current_liboctave_error_handler) ("invalid column selection");
-      return FloatColumnVector (); 
+      return FloatColumnVector ();
     }
 }
 
 FloatDiagMatrix
 FloatDiagMatrix::inverse (void) const
 {
   octave_idx_type info;
   return inverse (info);
diff --git a/liboctave/fDiagMatrix.h b/liboctave/fDiagMatrix.h
--- a/liboctave/fDiagMatrix.h
+++ b/liboctave/fDiagMatrix.h
@@ -50,17 +50,17 @@ public:
 
   FloatDiagMatrix (const MDiagArray2<float>& a) : MDiagArray2<float> (a) { }
 
   template <class U>
   FloatDiagMatrix (const DiagArray2<U>& a) : MDiagArray2<float> (a) { }
 
   explicit FloatDiagMatrix (const Array<double>& a) : MDiagArray2<float> (a) { }
 
-  FloatDiagMatrix (const Array<float>& a, octave_idx_type r, octave_idx_type c) 
+  FloatDiagMatrix (const Array<float>& a, octave_idx_type r, octave_idx_type c)
     : MDiagArray2<float> (a, r, c) { }
 
   FloatDiagMatrix& operator = (const FloatDiagMatrix& a)
     {
       MDiagArray2<float>::operator = (a);
       return *this;
     }
 
@@ -70,17 +70,17 @@ public:
   FloatDiagMatrix& fill (float val);
   FloatDiagMatrix& fill (float val, octave_idx_type beg, octave_idx_type end);
   FloatDiagMatrix& fill (const FloatColumnVector& a);
   FloatDiagMatrix& fill (const FloatRowVector& a);
   FloatDiagMatrix& fill (const FloatColumnVector& a, octave_idx_type beg);
   FloatDiagMatrix& fill (const FloatRowVector& a, octave_idx_type beg);
 
   FloatDiagMatrix transpose (void) const { return MDiagArray2<float>::transpose(); }
-  FloatDiagMatrix abs (void) const; 
+  FloatDiagMatrix abs (void) const;
 
   friend OCTAVE_API FloatDiagMatrix real (const FloatComplexDiagMatrix& a);
   friend OCTAVE_API FloatDiagMatrix imag (const FloatComplexDiagMatrix& a);
 
   // resize is the destructive analog for this one
 
   FloatMatrix extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const;
 
diff --git a/liboctave/fEIG.cc b/liboctave/fEIG.cc
--- a/liboctave/fEIG.cc
+++ b/liboctave/fEIG.cc
@@ -67,31 +67,31 @@ extern "C"
                            F77_CONST_CHAR_ARG_DECL,
                            const octave_idx_type&, FloatComplex*,
                            const octave_idx_type&, float*, FloatComplex*,
                            const octave_idx_type&, float*, octave_idx_type&
                            F77_CHAR_ARG_LEN_DECL
                            F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
-  F77_FUNC (spotrf, SPOTRF) (F77_CONST_CHAR_ARG_DECL, 
+  F77_FUNC (spotrf, SPOTRF) (F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&, float*,
                              const octave_idx_type&, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
-  F77_FUNC (cpotrf, CPOTRF) (F77_CONST_CHAR_ARG_DECL, 
+  F77_FUNC (cpotrf, CPOTRF) (F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&, FloatComplex*,
                              const octave_idx_type&, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
-  F77_FUNC (sggev, SGGEV) (F77_CONST_CHAR_ARG_DECL, 
+  F77_FUNC (sggev, SGGEV) (F77_CONST_CHAR_ARG_DECL,
                            F77_CONST_CHAR_ARG_DECL,
                            const octave_idx_type&, float*,
                            const octave_idx_type&, float*,
                            const octave_idx_type&, float*, float*, float*,
                            float*, const octave_idx_type&, float*,
                            const octave_idx_type&, float*,
                            const octave_idx_type&, octave_idx_type&
                            F77_CHAR_ARG_LEN_DECL
@@ -104,31 +104,31 @@ extern "C"
                            const octave_idx_type&, float*,
                            const octave_idx_type&, float*,
                            const octave_idx_type&, float*, float*,
                            const octave_idx_type&, octave_idx_type&
                            F77_CHAR_ARG_LEN_DECL
                            F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
-  F77_FUNC (cggev, CGGEV) (F77_CONST_CHAR_ARG_DECL, 
+  F77_FUNC (cggev, CGGEV) (F77_CONST_CHAR_ARG_DECL,
                            F77_CONST_CHAR_ARG_DECL,
                            const octave_idx_type&, FloatComplex*,
                            const octave_idx_type&, FloatComplex*,
                            const octave_idx_type&, FloatComplex*,
                            FloatComplex*, FloatComplex*,
                            const octave_idx_type&, FloatComplex*,
                            const octave_idx_type&, FloatComplex*,
                            const octave_idx_type&, float*, octave_idx_type&
                            F77_CHAR_ARG_LEN_DECL
                            F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (chegv, CHEGV) (const octave_idx_type&,
-                           F77_CONST_CHAR_ARG_DECL, 
+                           F77_CONST_CHAR_ARG_DECL,
                            F77_CONST_CHAR_ARG_DECL,
                            const octave_idx_type&, FloatComplex*,
                            const octave_idx_type&, FloatComplex*,
                            const octave_idx_type&, float*, FloatComplex*,
                            const octave_idx_type&, float*, octave_idx_type&
                            F77_CHAR_ARG_LEN_DECL
                            F77_CHAR_ARG_LEN_DECL);
 }
@@ -241,17 +241,17 @@ FloatEIG::init (const FloatMatrix& a, bo
         }
     }
   else
     (*current_liboctave_error_handler) ("sgeev workspace query failed");
 
   return info;
 }
 
-octave_idx_type 
+octave_idx_type
 FloatEIG::symmetric_init (const FloatMatrix& a, bool calc_ev)
 {
   octave_idx_type n = a.rows ();
 
   if (n != a.cols ())
     {
       (*current_liboctave_error_handler) ("EIG requires square matrix");
       return -1;
@@ -483,17 +483,17 @@ FloatEIG::init (const FloatMatrix& a, co
     }
 
   octave_idx_type info = 0;
 
   FloatMatrix tmp = b;
   float *tmp_data = tmp.fortran_vec ();
 
   F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1),
-                             n, tmp_data, n, 
+                             n, tmp_data, n,
                              info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
   if (a.is_symmetric () && b.is_symmetric () && info == 0)
     return symmetric_init (a, b, calc_ev);
 
   FloatMatrix atmp = a;
@@ -518,32 +518,32 @@ FloatEIG::init (const FloatMatrix& a, co
   octave_idx_type lwork = -1;
   float dummy_work;
 
   float *dummy = 0;
   octave_idx_type idummy = 1;
 
   F77_XFCN (sggev, SGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                            F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                           n, atmp_data, n, btmp_data, n, 
+                           n, atmp_data, n, btmp_data, n,
                            par, pai, pbeta,
                            dummy, idummy, pvr, n,
                            &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work);
       Array<float> work (dim_vector (lwork, 1));
       float *pwork = work.fortran_vec ();
 
       F77_XFCN (sggev, SGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                                F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                               n, atmp_data, n, btmp_data, n, 
+                               n, atmp_data, n, btmp_data, n,
                                par, pai, pbeta,
                                dummy, idummy, pvr, n,
                                pwork, lwork, info
                                F77_CHAR_ARG_LEN (1)
                                F77_CHAR_ARG_LEN (1)));
 
       if (info < 0)
         {
@@ -571,19 +571,19 @@ FloatEIG::init (const FloatMatrix& a, co
           else
             {
               if (j+1 >= n)
                 {
                   (*current_liboctave_error_handler) ("EIG: internal error");
                   return -1;
                 }
 
-              lambda.elem(j) = FloatComplex (ar.elem(j) / beta.elem (j), 
+              lambda.elem(j) = FloatComplex (ar.elem(j) / beta.elem (j),
                                              ai.elem(j) / beta.elem (j));
-              lambda.elem(j+1) = FloatComplex (ar.elem(j+1) / beta.elem (j+1), 
+              lambda.elem(j+1) = FloatComplex (ar.elem(j+1) / beta.elem (j+1),
                                                ai.elem(j+1) / beta.elem (j+1));
 
               for (octave_idx_type i = 0; i < nvr; i++)
                 {
                   float real_part = vr.elem (i, j);
                   float imag_part = vr.elem (i, j+1);
                   v.elem (i, j) = FloatComplex (real_part, imag_part);
                   v.elem (i, j+1) = FloatComplex (real_part, -imag_part);
@@ -593,17 +593,17 @@ FloatEIG::init (const FloatMatrix& a, co
         }
     }
   else
     (*current_liboctave_error_handler) ("sggev workspace query failed");
 
   return info;
 }
 
-octave_idx_type 
+octave_idx_type
 FloatEIG::symmetric_init (const FloatMatrix& a, const FloatMatrix& b, bool calc_ev)
 {
   octave_idx_type n = a.rows ();
   octave_idx_type nb = b.rows ();
 
   if (n != a.cols () || nb != b.cols ())
     {
       (*current_liboctave_error_handler) ("EIG requires square matrix");
@@ -627,32 +627,32 @@ FloatEIG::symmetric_init (const FloatMat
   FloatColumnVector wr (n);
   float *pwr = wr.fortran_vec ();
 
   octave_idx_type lwork = -1;
   float dummy_work;
 
   F77_XFCN (ssygv, SSYGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
-                           n, atmp_data, n, 
-                           btmp_data, n, 
+                           n, atmp_data, n,
+                           btmp_data, n,
                            pwr, &dummy_work, lwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work);
       Array<float> work (dim_vector (lwork, 1));
       float *pwork = work.fortran_vec ();
 
       F77_XFCN (ssygv, SSYGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                                F77_CONST_CHAR_ARG2 ("U", 1),
-                               n, atmp_data, n, 
-                               btmp_data, n, 
+                               n, atmp_data, n,
+                               btmp_data, n,
                                pwr, pwork, lwork, info
                                F77_CHAR_ARG_LEN (1)
                                F77_CHAR_ARG_LEN (1)));
 
       if (info < 0)
         {
           (*current_liboctave_error_handler) ("unrecoverable error in ssygv");
           return info;
@@ -699,17 +699,17 @@ FloatEIG::init (const FloatComplexMatrix
     }
 
   octave_idx_type info = 0;
 
   FloatComplexMatrix tmp = b;
   FloatComplex *tmp_data = tmp.fortran_vec ();
 
   F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1),
-                             n, tmp_data, n, 
+                             n, tmp_data, n,
                              info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
   if (a.is_hermitian () && b.is_hermitian () && info == 0)
     return hermitian_init (a, calc_ev);
 
   FloatComplexMatrix atmp = a;
@@ -735,36 +735,36 @@ FloatEIG::init (const FloatComplexMatrix
   Array<float> rwork (dim_vector (lrwork, 1));
   float *prwork = rwork.fortran_vec ();
 
   FloatComplex *dummy = 0;
   octave_idx_type idummy = 1;
 
   F77_XFCN (cggev, CGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                            F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                           n, atmp_data, n, btmp_data, n, 
+                           n, atmp_data, n, btmp_data, n,
                            palpha, pbeta, dummy, idummy,
                            pv, n, &dummy_work, lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work.real ());
       Array<FloatComplex> work (dim_vector (lwork, 1));
       FloatComplex *pwork = work.fortran_vec ();
 
       F77_XFCN (cggev, CGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                                F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                               n, atmp_data, n, btmp_data, n, 
+                               n, atmp_data, n, btmp_data, n,
                                palpha, pbeta, dummy, idummy,
                                pv, n, pwork, lwork, prwork, info
                                F77_CHAR_ARG_LEN (1)
                                F77_CHAR_ARG_LEN (1)));
-      
+
       if (info < 0)
         {
           (*current_liboctave_error_handler) ("unrecoverable error in cggev");
           return info;
         }
 
       if (info > 0)
         {
@@ -818,33 +818,33 @@ FloatEIG::hermitian_init (const FloatCom
   FloatComplex dummy_work;
 
   octave_idx_type lrwork = 3*n;
   Array<float> rwork (dim_vector (lrwork, 1));
   float *prwork = rwork.fortran_vec ();
 
   F77_XFCN (chegv, CHEGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
-                           n, atmp_data, n, 
+                           n, atmp_data, n,
                            btmp_data, n,
                            pwr, &dummy_work, lwork,
                            prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info == 0)
     {
       lwork = static_cast<octave_idx_type> (dummy_work.real ());
       Array<FloatComplex> work (dim_vector (lwork, 1));
       FloatComplex *pwork = work.fortran_vec ();
 
       F77_XFCN (chegv, CHEGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                                F77_CONST_CHAR_ARG2 ("U", 1),
-                               n, atmp_data, n, 
-                               btmp_data, n, 
+                               n, atmp_data, n,
+                               btmp_data, n,
                                pwr, pwork, lwork, prwork, info
                                F77_CHAR_ARG_LEN (1)
                                F77_CHAR_ARG_LEN (1)));
 
       if (info < 0)
         {
           (*current_liboctave_error_handler) ("unrecoverable error in zhegv");
           return info;
diff --git a/liboctave/fMatrix.cc b/liboctave/fMatrix.cc
--- a/liboctave/fMatrix.cc
+++ b/liboctave/fMatrix.cc
@@ -111,45 +111,45 @@ extern "C"
   F77_RET_T
   F77_FUNC (xsdot, XSDOT) (const octave_idx_type&, const float*,
                            const octave_idx_type&, const float*,
                            const octave_idx_type&, float&);
 
   F77_RET_T
   F77_FUNC (ssyrk, SSYRK) (F77_CONST_CHAR_ARG_DECL,
                            F77_CONST_CHAR_ARG_DECL,
-                           const octave_idx_type&, const octave_idx_type&, 
+                           const octave_idx_type&, const octave_idx_type&,
                            const float&, const float*, const octave_idx_type&,
                            const float&, float*, const octave_idx_type&
                            F77_CHAR_ARG_LEN_DECL
                            F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (sgetrf, SGETRF) (const octave_idx_type&,
                              const octave_idx_type&, float*,
                              const octave_idx_type&,
                              octave_idx_type*, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (sgetrs, SGETRS) (F77_CONST_CHAR_ARG_DECL,
-                             const octave_idx_type&, const octave_idx_type&, 
+                             const octave_idx_type&, const octave_idx_type&,
                              const float*, const octave_idx_type&,
                              const octave_idx_type*, float*,
                              const octave_idx_type&, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (sgetri, SGETRI) (const octave_idx_type&, float*,
                              const octave_idx_type&, const octave_idx_type*,
                              float*, const octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (sgecon, SGECON) (F77_CONST_CHAR_ARG_DECL,
-                             const octave_idx_type&, float*, 
-                             const octave_idx_type&, const float&, float&, 
+                             const octave_idx_type&, float*,
+                             const octave_idx_type&, const float&, float&,
                              float*, octave_idx_type*, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (sgelsy, SGELSY) (const octave_idx_type&, const octave_idx_type&,
                              const octave_idx_type&, float*,
                              const octave_idx_type&, float*,
                              const octave_idx_type&, octave_idx_type*,
@@ -176,44 +176,44 @@ extern "C"
                              const octave_idx_type&, float*,
                              const octave_idx_type&, const float&,
                              float&, float*, octave_idx_type*,
                              octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL);
   F77_RET_T
   F77_FUNC (spotrs, SPOTRS) (F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&, const octave_idx_type&,
-                             const float*, const octave_idx_type&, float*, 
+                             const float*, const octave_idx_type&, float*,
                              const octave_idx_type&, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (strtri, STRTRI) (F77_CONST_CHAR_ARG_DECL,
-                             F77_CONST_CHAR_ARG_DECL, 
-                             const octave_idx_type&, const float*, 
+                             F77_CONST_CHAR_ARG_DECL,
+                             const octave_idx_type&, const float*,
                              const octave_idx_type&, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
   F77_RET_T
   F77_FUNC (strcon, STRCON) (F77_CONST_CHAR_ARG_DECL,
-                             F77_CONST_CHAR_ARG_DECL, 
+                             F77_CONST_CHAR_ARG_DECL,
                              F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&, const float*,
                              const octave_idx_type&, float&,
-                             float*, octave_idx_type*, octave_idx_type& 
+                             float*, octave_idx_type*, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
   F77_RET_T
   F77_FUNC (strtrs, STRTRS) (F77_CONST_CHAR_ARG_DECL,
-                             F77_CONST_CHAR_ARG_DECL, 
+                             F77_CONST_CHAR_ARG_DECL,
                              F77_CONST_CHAR_ARG_DECL,
-                             const octave_idx_type&, 
-                             const octave_idx_type&, const float*, 
-                             const octave_idx_type&, float*, 
+                             const octave_idx_type&,
+                             const octave_idx_type&, const float*,
+                             const octave_idx_type&, float*,
                              const octave_idx_type&, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (slartg, SLARTG) (const float&, const float&, float&,
                              float&, float&);
@@ -229,17 +229,17 @@ extern "C"
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (xslange, XSLANGE) (F77_CONST_CHAR_ARG_DECL,
                                const octave_idx_type&,
                                const octave_idx_type&, const float*,
                                const octave_idx_type&, float*, float&
-                               F77_CHAR_ARG_LEN_DECL); 
+                               F77_CHAR_ARG_LEN_DECL);
 }
 
 // Matrix class.
 
 FloatMatrix::FloatMatrix (const FloatRowVector& rv)
   : MArray<float> (rv)
 {
 }
@@ -665,17 +665,17 @@ FloatMatrix::inverse (MatrixType& mattyp
 FloatMatrix
 FloatMatrix::inverse (MatrixType &mattype, octave_idx_type& info) const
 {
   float rcon;
   return inverse (mattype, info, rcon, 0, 0);
 }
 
 FloatMatrix
-FloatMatrix::tinverse (MatrixType &mattype, octave_idx_type& info, float& rcon, 
+FloatMatrix::tinverse (MatrixType &mattype, octave_idx_type& info, float& rcon,
                   int force, int calc_cond) const
 {
   FloatMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc || nr == 0 || nc == 0)
@@ -685,55 +685,55 @@ FloatMatrix::tinverse (MatrixType &matty
       int typ = mattype.type ();
       char uplo = (typ == MatrixType::Lower ? 'L' : 'U');
       char udiag = 'N';
       retval = *this;
       float *tmp_data = retval.fortran_vec ();
 
       F77_XFCN (strtri, STRTRI, (F77_CONST_CHAR_ARG2 (&uplo, 1),
                                  F77_CONST_CHAR_ARG2 (&udiag, 1),
-                                 nr, tmp_data, nr, info 
+                                 nr, tmp_data, nr, info
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
-      if (info != 0) 
+      if (info != 0)
         info = -1;
-      else if (calc_cond) 
+      else if (calc_cond)
         {
           octave_idx_type dtrcon_info = 0;
           char job = '1';
 
           OCTAVE_LOCAL_BUFFER (float, work, 3 * nr);
           OCTAVE_LOCAL_BUFFER (octave_idx_type, iwork, nr);
 
           F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      F77_CONST_CHAR_ARG2 (&uplo, 1),
                                      F77_CONST_CHAR_ARG2 (&udiag, 1),
-                                     nr, tmp_data, nr, rcon, 
-                                     work, iwork, dtrcon_info 
+                                     nr, tmp_data, nr, rcon,
+                                     work, iwork, dtrcon_info
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)));
 
-          if (dtrcon_info != 0) 
+          if (dtrcon_info != 0)
             info = -1;
         }
 
       if (info == -1 && ! force)
         retval = *this; // Restore matrix contents.
     }
 
   return retval;
 }
 
 
 FloatMatrix
-FloatMatrix::finverse (MatrixType &mattype, octave_idx_type& info, float& rcon, 
+FloatMatrix::finverse (MatrixType &mattype, octave_idx_type& info, float& rcon,
                   int force, int calc_cond) const
 {
   FloatMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc || nr == 0 || nc == 0)
@@ -745,76 +745,76 @@ FloatMatrix::finverse (MatrixType &matty
 
       retval = *this;
       float *tmp_data = retval.fortran_vec ();
 
       Array<float> z(dim_vector (1, 1));
       octave_idx_type lwork = -1;
 
       // Query the optimum work array size.
-      F77_XFCN (sgetri, SGETRI, (nc, tmp_data, nr, pipvt, 
+      F77_XFCN (sgetri, SGETRI, (nc, tmp_data, nr, pipvt,
                                  z.fortran_vec (), lwork, info));
 
       lwork = static_cast<octave_idx_type> (z(0));
       lwork = (lwork < 2 *nc ? 2*nc : lwork);
       z.resize (dim_vector (lwork, 1));
       float *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       float anorm = 0;
-      if (calc_cond) 
+      if (calc_cond)
         anorm = retval.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
       F77_XFCN (sgetrf, SGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
-      if (info != 0) 
+      if (info != 0)
         info = -1;
-      else if (calc_cond) 
+      else if (calc_cond)
         {
           octave_idx_type dgecon_info = 0;
 
           // Now calculate the condition number for non-singular matrix.
           char job = '1';
           Array<octave_idx_type> iz (dim_vector (nc, 1));
           octave_idx_type *piz = iz.fortran_vec ();
           F77_XFCN (sgecon, SGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                     nc, tmp_data, nr, anorm, 
+                                     nc, tmp_data, nr, anorm,
                                      rcon, pz, piz, dgecon_info
                                      F77_CHAR_ARG_LEN (1)));
 
-          if (dgecon_info != 0) 
+          if (dgecon_info != 0)
             info = -1;
         }
 
       if (info == -1 && ! force)
         retval = *this; // Restore matrix contents.
       else
         {
           octave_idx_type dgetri_info = 0;
 
           F77_XFCN (sgetri, SGETRI, (nc, tmp_data, nr, pipvt,
                                      pz, lwork, dgetri_info));
 
-          if (dgetri_info != 0) 
+          if (dgetri_info != 0)
             info = -1;
         }
 
       if (info != 0)
         mattype.mark_as_rectangular();
     }
 
   return retval;
 }
 
 FloatMatrix
-FloatMatrix::inverse (MatrixType &mattype, octave_idx_type& info, float& rcon, 
+FloatMatrix::inverse (MatrixType &mattype, octave_idx_type& info, float& rcon,
                  int force, int calc_cond) const
 {
   int typ = mattype.type (false);
   FloatMatrix ret;
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
@@ -905,17 +905,17 @@ FloatMatrix::fourier (void) const
     {
       npts = nr;
       nsamples = nc;
     }
 
   const float *in (fortran_vec ());
   FloatComplex *out (retval.fortran_vec ());
 
-  octave_fftw::fft (in, out, npts, nsamples); 
+  octave_fftw::fft (in, out, npts, nsamples);
 
   return retval;
 }
 
 FloatComplexMatrix
 FloatMatrix::ifourier (void) const
 {
   size_t nr = rows ();
@@ -935,17 +935,17 @@ FloatMatrix::ifourier (void) const
       npts = nr;
       nsamples = nc;
     }
 
   FloatComplexMatrix tmp (*this);
   FloatComplex *in (tmp.fortran_vec ());
   FloatComplex *out (retval.fortran_vec ());
 
-  octave_fftw::ifft (in, out, npts, nsamples); 
+  octave_fftw::ifft (in, out, npts, nsamples);
 
   return retval;
 }
 
 FloatComplexMatrix
 FloatMatrix::fourier2d (void) const
 {
   dim_vector dv(rows (), cols ());
@@ -1254,56 +1254,56 @@ FloatMatrix::determinant (MatrixType& ma
 
       if (typ == MatrixType::Unknown)
         typ = mattype.type (*this);
       else if (typ == MatrixType::Rectangular)
         typ = MatrixType::Full;
 
       if (typ == MatrixType::Lower || typ == MatrixType::Upper)
         {
-          for (octave_idx_type i = 0; i < nc; i++) 
+          for (octave_idx_type i = 0; i < nc; i++)
             retval *= elem (i,i);
         }
       else if (typ == MatrixType::Hermitian)
         {
           FloatMatrix atmp = *this;
           float *tmp_data = atmp.fortran_vec ();
 
           info = 0;
           float anorm = 0;
           if (calc_cond) anorm = xnorm (*this, 1);
 
 
           char job = 'L';
-          F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
+          F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                      tmp_data, nr, info
                                      F77_CHAR_ARG_LEN (1)));
 
-          if (info != 0) 
+          if (info != 0)
             {
               rcon = 0.0;
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
-          else 
+          else
             {
               Array<float> z (dim_vector (3 * nc, 1));
               float *pz = z.fortran_vec ();
               Array<octave_idx_type> iz (dim_vector (nc, 1));
               octave_idx_type *piz = iz.fortran_vec ();
 
               F77_XFCN (spocon, SPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                          nr, tmp_data, nr, anorm,
                                          rcon, pz, piz, info
                                          F77_CHAR_ARG_LEN (1)));
 
-              if (info != 0) 
+              if (info != 0)
                 rcon = 0.0;
 
-              for (octave_idx_type i = 0; i < nc; i++) 
+              for (octave_idx_type i = 0; i < nc; i++)
                 retval *= atmp (i,i);
 
               retval = retval.square ();
             }
         }
       else if (typ != MatrixType::Full)
         (*current_liboctave_error_handler) ("det: invalid dense matrix type");
 
@@ -1320,46 +1320,46 @@ FloatMatrix::determinant (MatrixType& ma
           // Calculate the norm of the matrix, for later use.
           float anorm = 0;
           if (calc_cond) anorm = xnorm (*this, 1);
 
           F77_XFCN (sgetrf, SGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
-          if (info != 0) 
+          if (info != 0)
             {
               info = -1;
               retval = FloatDET ();
-            } 
-          else 
+            }
+          else
             {
-              if (calc_cond) 
+              if (calc_cond)
                 {
                   // Now calc the condition number for non-singular matrix.
                   char job = '1';
                   Array<float> z (dim_vector (4 * nc, 1));
                   float *pz = z.fortran_vec ();
                   Array<octave_idx_type> iz (dim_vector (nc, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (sgecon, SGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                             nc, tmp_data, nr, anorm, 
+                                             nc, tmp_data, nr, anorm,
                                              rcon, pz, piz, info
                                              F77_CHAR_ARG_LEN (1)));
                 }
 
-              if (info != 0) 
+              if (info != 0)
                 {
                   info = -1;
                   retval = FloatDET ();
-                } 
-              else 
+                }
+              else
                 {
-                  for (octave_idx_type i = 0; i < nc; i++) 
+                  for (octave_idx_type i = 0; i < nc; i++)
                     {
                       float c = atmp(i,i);
                       retval *= (ipvt(i) != (i+1)) ? -c : c;
                     }
                 }
             }
         }
     }
@@ -1401,26 +1401,26 @@ FloatMatrix::rcond (MatrixType &mattype)
           char uplo = 'U';
           char dia = 'N';
 
           Array<float> z (dim_vector (3 * nc, 1));
           float *pz = z.fortran_vec ();
           Array<octave_idx_type> iz (dim_vector (nc, 1));
           octave_idx_type *piz = iz.fortran_vec ();
 
-          F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
-                                     F77_CONST_CHAR_ARG2 (&uplo, 1), 
-                                     F77_CONST_CHAR_ARG2 (&dia, 1), 
+          F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
+                                     F77_CONST_CHAR_ARG2 (&uplo, 1),
+                                     F77_CONST_CHAR_ARG2 (&dia, 1),
                                      nr, tmp_data, nr, rcon,
                                      pz, piz, info
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)));
 
-          if (info != 0) 
+          if (info != 0)
             rcon = 0.0;
         }
       else if  (typ == MatrixType::Permuted_Upper)
         (*current_liboctave_error_handler)
           ("permuted triangular matrix not implemented");
       else if (typ == MatrixType::Lower)
         {
           const float *tmp_data = fortran_vec ();
@@ -1429,26 +1429,26 @@ FloatMatrix::rcond (MatrixType &mattype)
           char uplo = 'L';
           char dia = 'N';
 
           Array<float> z (dim_vector (3 * nc, 1));
           float *pz = z.fortran_vec ();
           Array<octave_idx_type> iz (dim_vector (nc, 1));
           octave_idx_type *piz = iz.fortran_vec ();
 
-          F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
-                                     F77_CONST_CHAR_ARG2 (&uplo, 1), 
-                                     F77_CONST_CHAR_ARG2 (&dia, 1), 
+          F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
+                                     F77_CONST_CHAR_ARG2 (&uplo, 1),
+                                     F77_CONST_CHAR_ARG2 (&dia, 1),
                                      nr, tmp_data, nr, rcon,
                                      pz, piz, info
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)));
 
-          if (info != 0) 
+          if (info != 0)
             rcon = 0.0;
         }
       else if (typ == MatrixType::Permuted_Lower)
         (*current_liboctave_error_handler)
           ("permuted triangular matrix not implemented");
       else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
         {
           float anorm = -1.0;
@@ -1457,39 +1457,39 @@ FloatMatrix::rcond (MatrixType &mattype)
 
           if (typ == MatrixType::Hermitian)
             {
               octave_idx_type info = 0;
               char job = 'L';
               anorm = atmp.abs().sum().
                 row(static_cast<octave_idx_type>(0)).max();
 
-              F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
+              F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                          tmp_data, nr, info
                                          F77_CHAR_ARG_LEN (1)));
 
-              if (info != 0) 
+              if (info != 0)
                 {
                   rcon = 0.0;
                   mattype.mark_as_unsymmetric ();
                   typ = MatrixType::Full;
                 }
-              else 
+              else
                 {
                   Array<float> z (dim_vector (3 * nc, 1));
                   float *pz = z.fortran_vec ();
                   Array<octave_idx_type> iz (dim_vector (nc, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (spocon, SPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, tmp_data, nr, anorm,
                                              rcon, pz, piz, info
                                              F77_CHAR_ARG_LEN (1)));
 
-                  if (info != 0) 
+                  if (info != 0)
                     rcon = 0.0;
                 }
             }
 
           if (typ == MatrixType::Full)
             {
               octave_idx_type info = 0;
 
@@ -1502,30 +1502,30 @@ FloatMatrix::rcond (MatrixType &mattype)
 
               Array<float> z (dim_vector (4 * nc, 1));
               float *pz = z.fortran_vec ();
               Array<octave_idx_type> iz (dim_vector (nc, 1));
               octave_idx_type *piz = iz.fortran_vec ();
 
               F77_XFCN (sgetrf, SGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
-              if (info != 0) 
+              if (info != 0)
                 {
                   rcon = 0.0;
                   mattype.mark_as_rectangular ();
                 }
-              else 
+              else
                 {
                   char job = '1';
                   F77_XFCN (sgecon, SGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                             nc, tmp_data, nr, anorm, 
+                                             nc, tmp_data, nr, anorm,
                                              rcon, pz, piz, info
                                              F77_CHAR_ARG_LEN (1)));
 
-                  if (info != 0) 
+                  if (info != 0)
                     rcon = 0.0;
                 }
             }
         }
       else
         rcon = 0.0;
     }
 
@@ -1573,26 +1573,26 @@ FloatMatrix::utsolve (MatrixType &mattyp
                   char uplo = 'U';
                   char dia = 'N';
 
                   Array<float> z (dim_vector (3 * nc, 1));
                   float *pz = z.fortran_vec ();
                   Array<octave_idx_type> iz (dim_vector (nc, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
-                  F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
-                                             F77_CONST_CHAR_ARG2 (&uplo, 1), 
-                                             F77_CONST_CHAR_ARG2 (&dia, 1), 
+                  F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
+                                             F77_CONST_CHAR_ARG2 (&uplo, 1),
+                                             F77_CONST_CHAR_ARG2 (&dia, 1),
                                              nr, tmp_data, nr, rcon,
                                              pz, piz, info
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)));
 
-                  if (info != 0) 
+                  if (info != 0)
                     info = -2;
 
                   volatile float rcond_plus_one = rcon + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
@@ -1609,19 +1609,19 @@ FloatMatrix::utsolve (MatrixType &mattyp
                 {
                   retval = b;
                   float *result = retval.fortran_vec ();
 
                   char uplo = 'U';
                   char trans = get_blas_char (transt);
                   char dia = 'N';
 
-                  F77_XFCN (strtrs, STRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
-                                             F77_CONST_CHAR_ARG2 (&trans, 1), 
-                                             F77_CONST_CHAR_ARG2 (&dia, 1), 
+                  F77_XFCN (strtrs, STRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1),
+                                             F77_CONST_CHAR_ARG2 (&trans, 1),
+                                             F77_CONST_CHAR_ARG2 (&dia, 1),
                                              nr, b_nc, tmp_data, nr,
                                              result, nr, info
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)));
                 }
             }
         }
@@ -1673,26 +1673,26 @@ FloatMatrix::ltsolve (MatrixType &mattyp
                   char uplo = 'L';
                   char dia = 'N';
 
                   Array<float> z (dim_vector (3 * nc, 1));
                   float *pz = z.fortran_vec ();
                   Array<octave_idx_type> iz (dim_vector (nc, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
-                  F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&norm, 1), 
-                                             F77_CONST_CHAR_ARG2 (&uplo, 1), 
-                                             F77_CONST_CHAR_ARG2 (&dia, 1), 
+                  F77_XFCN (strcon, STRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
+                                             F77_CONST_CHAR_ARG2 (&uplo, 1),
+                                             F77_CONST_CHAR_ARG2 (&dia, 1),
                                              nr, tmp_data, nr, rcon,
                                              pz, piz, info
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)));
 
-                  if (info != 0) 
+                  if (info != 0)
                     info = -2;
 
                   volatile float rcond_plus_one = rcon + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
@@ -1709,19 +1709,19 @@ FloatMatrix::ltsolve (MatrixType &mattyp
                 {
                   retval = b;
                   float *result = retval.fortran_vec ();
 
                   char uplo = 'L';
                   char trans = get_blas_char (transt);
                   char dia = 'N';
 
-                  F77_XFCN (strtrs, STRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
-                                             F77_CONST_CHAR_ARG2 (&trans, 1), 
-                                             F77_CONST_CHAR_ARG2 (&dia, 1), 
+                  F77_XFCN (strtrs, STRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1),
+                                             F77_CONST_CHAR_ARG2 (&trans, 1),
+                                             F77_CONST_CHAR_ARG2 (&dia, 1),
                                              nr, b_nc, tmp_data, nr,
                                              result, nr, info
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)));
                 }
             }
         }
@@ -1745,56 +1745,56 @@ FloatMatrix::fsolve (MatrixType &mattype
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || b.cols () == 0)
     retval = FloatMatrix (nc, b.cols (), 0.0);
   else
     {
       volatile int typ = mattype.type ();
- 
+
      // Calculate the norm of the matrix, for later use.
       float anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
         {
           info = 0;
           char job = 'L';
           FloatMatrix atmp = *this;
           float *tmp_data = atmp.fortran_vec ();
           anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
-          F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr, 
+          F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                      tmp_data, nr, info
                                      F77_CHAR_ARG_LEN (1)));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
-          if (info != 0) 
+          if (info != 0)
             {
               info = -2;
 
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
-          else 
+          else
             {
               if (calc_cond)
                 {
                   Array<float> z (dim_vector (3 * nc, 1));
                   float *pz = z.fortran_vec ();
                   Array<octave_idx_type> iz (dim_vector (nc, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (spocon, SPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, tmp_data, nr, anorm,
                                              rcon, pz, piz, info
                                              F77_CHAR_ARG_LEN (1)));
 
-                  if (info != 0) 
+                  if (info != 0)
                     info = -2;
 
                   volatile float rcond_plus_one = rcon + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
@@ -1818,17 +1818,17 @@ FloatMatrix::fsolve (MatrixType &mattype
                                              nr, b_nc, tmp_data, nr,
                                              result, b.rows(), info
                                              F77_CHAR_ARG_LEN (1)));
                 }
               else
                 {
                   mattype.mark_as_unsymmetric ();
                   typ = MatrixType::Full;
-                }                   
+                }
             }
         }
 
       if (typ == MatrixType::Full)
         {
           info = 0;
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
@@ -1843,41 +1843,41 @@ FloatMatrix::fsolve (MatrixType &mattype
           float *pz = z.fortran_vec ();
           Array<octave_idx_type> iz (dim_vector (nc, 1));
           octave_idx_type *piz = iz.fortran_vec ();
 
           F77_XFCN (sgetrf, SGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
-          if (info != 0) 
+          if (info != 0)
             {
               info = -2;
 
               if (sing_handler)
                 sing_handler (rcon);
               else
                 (*current_liboctave_error_handler)
                   ("matrix singular to machine precision");
 
               mattype.mark_as_rectangular ();
             }
-          else 
+          else
             {
               if (calc_cond)
                 {
-                  // Now calculate the condition number for 
+                  // Now calculate the condition number for
                   // non-singular matrix.
                   char job = '1';
                   F77_XFCN (sgecon, SGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                             nc, tmp_data, nr, anorm, 
+                                             nc, tmp_data, nr, anorm,
                                              rcon, pz, piz, info
                                              F77_CHAR_ARG_LEN (1)));
 
-                  if (info != 0) 
+                  if (info != 0)
                     info = -2;
 
                   volatile float rcond_plus_one = rcon + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcon))
                     {
                       info = -2;
 
@@ -1925,17 +1925,17 @@ FloatMatrix::solve (MatrixType &typ, con
 FloatMatrix
 FloatMatrix::solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info) const
 {
   float rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatMatrix
-FloatMatrix::solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info, 
+FloatMatrix::solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info,
                float& rcon) const
 {
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatMatrix
 FloatMatrix::solve (MatrixType &mattype, const FloatMatrix& b, octave_idx_type& info,
                float& rcon, solve_singularity_handler sing_handler,
@@ -1976,17 +1976,17 @@ FloatComplexMatrix
 FloatMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b) const
 {
   octave_idx_type info;
   float rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
-FloatMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b, 
+FloatMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b,
   octave_idx_type& info) const
 {
   float rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
 FloatMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b, octave_idx_type& info,
@@ -2035,17 +2035,17 @@ FloatMatrix::solve (MatrixType &typ, con
 FloatColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatColumnVector& b) const
 {
   octave_idx_type info; float rcon;
   return solve (typ, b, info, rcon);
 }
 
 FloatColumnVector
-FloatMatrix::solve (MatrixType &typ, const FloatColumnVector& b, 
+FloatMatrix::solve (MatrixType &typ, const FloatColumnVector& b,
                octave_idx_type& info) const
 {
   float rcon;
   return solve (typ, b, info, rcon);
 }
 
 FloatColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatColumnVector& b, octave_idx_type& info,
@@ -2066,33 +2066,33 @@ FloatMatrix::solve (MatrixType &typ, con
 FloatComplexColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (typ, b);
 }
 
 FloatComplexColumnVector
-FloatMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b, 
+FloatMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b,
                octave_idx_type& info) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (typ, b, info);
 }
 
 FloatComplexColumnVector
-FloatMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b, 
+FloatMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b,
                octave_idx_type& info, float& rcon) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (typ, b, info, rcon);
 }
 
 FloatComplexColumnVector
-FloatMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b, 
+FloatMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b,
                octave_idx_type& info, float& rcon,
                solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve(typ, b, info, rcon, sing_handler, transt);
 }
 
 FloatMatrix
@@ -2353,17 +2353,17 @@ FloatMatrix::lssolve (const FloatMatrix&
             work(0) = lworkaround;
         }
 
       lwork = static_cast<octave_idx_type> (work(0));
       work.resize (dim_vector (lwork, 1));
 
       F77_XFCN (sgelsd, SGELSD, (m, n, nrhs, tmp_data, m, pretval,
                                  maxmn, ps, rcon, rank,
-                                 work.fortran_vec (), lwork, 
+                                 work.fortran_vec (), lwork,
                                  piwork, info));
 
       if (s.elem (0) == 0.0)
         rcon = 0.0;
       else
         rcon = s.elem (minmn - 1) / s.elem (0);
 
       retval.resize (n, nrhs);
@@ -2387,26 +2387,26 @@ FloatMatrix::lssolve (const FloatComplex
 {
   FloatComplexMatrix tmp (*this);
   octave_idx_type rank;
   float rcon;
   return tmp.lssolve (b, info, rank, rcon);
 }
 
 FloatComplexMatrix
-FloatMatrix::lssolve (const FloatComplexMatrix& b, octave_idx_type& info, 
+FloatMatrix::lssolve (const FloatComplexMatrix& b, octave_idx_type& info,
                  octave_idx_type& rank) const
 {
   FloatComplexMatrix tmp (*this);
   float rcon;
   return tmp.lssolve (b, info, rank, rcon);
 }
 
 FloatComplexMatrix
-FloatMatrix::lssolve (const FloatComplexMatrix& b, octave_idx_type& info, 
+FloatMatrix::lssolve (const FloatComplexMatrix& b, octave_idx_type& info,
                  octave_idx_type& rank, float& rcon) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.lssolve (b, info, rank, rcon);
 }
 
 FloatColumnVector
 FloatMatrix::lssolve (const FloatColumnVector& b) const
@@ -2449,17 +2449,17 @@ FloatMatrix::lssolve (const FloatColumnV
       ("matrix dimension mismatch solution of linear equations");
   else if (m == 0 || n == 0)
     retval = FloatColumnVector (n, 0.0);
   else
     {
       volatile octave_idx_type minmn = (m < n ? m : n);
       octave_idx_type maxmn = m > n ? m : n;
       rcon = -1.0;
- 
+
       if (m != n)
         {
           retval = FloatColumnVector (maxmn, 0.0);
 
           for (octave_idx_type i = 0; i < m; i++)
             retval.elem (i) = b.elem (i);
         }
       else
@@ -2507,17 +2507,17 @@ FloatMatrix::lssolve (const FloatColumnV
                                  ps, rcon, rank, work.fortran_vec (),
                                  lwork, piwork, info));
 
       lwork = static_cast<octave_idx_type> (work(0));
       work.resize (dim_vector (lwork, 1));
 
       F77_XFCN (sgelsd, SGELSD, (m, n, nrhs, tmp_data, m, pretval,
                                  maxmn, ps, rcon, rank,
-                                 work.fortran_vec (), lwork, 
+                                 work.fortran_vec (), lwork,
                                  piwork, info));
 
       if (rank < minmn)
         {
           if (s.elem (0) == 0.0)
             rcon = 0.0;
           else
             rcon = s.elem (minmn - 1) / s.elem (0);
@@ -2544,26 +2544,26 @@ FloatMatrix::lssolve (const FloatComplex
 {
   FloatComplexMatrix tmp (*this);
   octave_idx_type rank;
   float rcon;
   return tmp.lssolve (b, info, rank, rcon);
 }
 
 FloatComplexColumnVector
-FloatMatrix::lssolve (const FloatComplexColumnVector& b, octave_idx_type& info, 
+FloatMatrix::lssolve (const FloatComplexColumnVector& b, octave_idx_type& info,
                  octave_idx_type& rank) const
 {
   FloatComplexMatrix tmp (*this);
   float rcon;
   return tmp.lssolve (b, info, rank, rcon);
 }
 
 FloatComplexColumnVector
-FloatMatrix::lssolve (const FloatComplexColumnVector& b, octave_idx_type& info, 
+FloatMatrix::lssolve (const FloatComplexColumnVector& b, octave_idx_type& info,
                  octave_idx_type& rank, float &rcon) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.lssolve (b, info, rank, rcon);
 }
 
 FloatMatrix&
 FloatMatrix::operator += (const FloatDiagMatrix& a)
@@ -2628,17 +2628,17 @@ operator * (const FloatColumnVector& v, 
   octave_idx_type len = v.length ();
 
   if (len != 0)
     {
       octave_idx_type a_len = a.length ();
 
       retval = FloatMatrix (len, a_len);
       float *c = retval.fortran_vec ();
-          
+
       F77_XFCN (sgemm, SGEMM, (F77_CONST_CHAR_ARG2 ("N", 1),
                                F77_CONST_CHAR_ARG2 ("N", 1),
                                len, a_len, 1, 1.0, v.data (), len,
                                a.data (), 1, 0.0, c, len
                                F77_CHAR_ARG_LEN (1)
                                F77_CHAR_ARG_LEN (1)));
     }
 
@@ -3058,27 +3058,27 @@ Sylvester (const FloatMatrix& a, const F
 
   // FIXME -- need to check that a, b, and c are all the same
   // size.
 
   // Compute Schur decompositions.
 
   FloatSCHUR as (a, "U");
   FloatSCHUR bs (b, "U");
-  
+
   // Transform c to new coordinates.
 
   FloatMatrix ua = as.unitary_matrix ();
   FloatMatrix sch_a = as.schur_matrix ();
 
   FloatMatrix ub = bs.unitary_matrix ();
   FloatMatrix sch_b = bs.schur_matrix ();
-  
+
   FloatMatrix cx = ua.transpose () * c * ub;
-  
+
   // Solve the sylvester equation, back-transform, and return the
   // solution.
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type b_nr = b.rows ();
 
   float scale;
   octave_idx_type info;
@@ -3091,17 +3091,17 @@ Sylvester (const FloatMatrix& a, const F
                              F77_CONST_CHAR_ARG2 ("N", 1),
                              1, a_nr, b_nr, pa, a_nr, pb,
                              b_nr, px, a_nr, scale, info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
 
   // FIXME -- check info?
-  
+
   retval = -ua*cx*ub.transpose ();
 
   return retval;
 }
 
 // matrix by matrix -> matrix operations
 
 /* Simple Dot Product, Matrix-Vector and Matrix-Matrix Unit tests
@@ -3125,18 +3125,18 @@ Sylvester (const FloatMatrix& a, const F
 static char
 get_blas_trans_arg (bool trans)
 {
   return trans ? 'T' : 'N';
 }
 
 // the general GEMM operation
 
-FloatMatrix 
-xgemm (const FloatMatrix& a, const FloatMatrix& b, 
+FloatMatrix
+xgemm (const FloatMatrix& a, const FloatMatrix& b,
        blas_trans_type transa, blas_trans_type transb)
 {
   FloatMatrix retval;
 
   bool tra = transa != blas_no_trans, trb = transb != blas_no_trans;
 
   octave_idx_type a_nr = tra ? a.cols () : a.rows ();
   octave_idx_type a_nc = tra ? a.rows () : a.cols ();
@@ -3357,18 +3357,18 @@ max (const FloatMatrix& a, const FloatMa
       {
         octave_quit ();
         result (i, j) = xmax (a (i, j), b (i, j));
       }
 
   return result;
 }
 
-FloatMatrix linspace (const FloatColumnVector& x1, 
-                      const FloatColumnVector& x2, 
+FloatMatrix linspace (const FloatColumnVector& x1,
+                      const FloatColumnVector& x2,
                       octave_idx_type n)
 
 {
   if (n < 1) n = 1;
 
   octave_idx_type m = x1.length ();
 
   if (x2.length () != m)
@@ -3376,17 +3376,17 @@ FloatMatrix linspace (const FloatColumnV
 
   NoAlias<FloatMatrix> retval;
 
   retval.clear (m, n);
   for (octave_idx_type i = 0; i < m; i++)
     retval(i, 0) = x1(i);
 
   // The last column is not needed while using delta.
-  float *delta = &retval(0, n-1); 
+  float *delta = &retval(0, n-1);
   for (octave_idx_type i = 0; i < m; i++)
     delta[i] = (x2(i) - x1(i)) / (n - 1);
 
   for (octave_idx_type j = 1; j < n-1; j++)
     for (octave_idx_type i = 0; i < m; i++)
       retval(i, j) = x1(i) + j*delta[i];
 
   for (octave_idx_type i = 0; i < m; i++)
diff --git a/liboctave/fMatrix.h b/liboctave/fMatrix.h
--- a/liboctave/fMatrix.h
+++ b/liboctave/fMatrix.h
@@ -128,20 +128,20 @@ public:
 
   void resize (octave_idx_type nr, octave_idx_type nc,
                float rfv = resize_fill_value ())
   {
     MArray<float>::resize (dim_vector (nr, nc), rfv);
   }
 
 private:
-  FloatMatrix tinverse (MatrixType &mattype, octave_idx_type& info, float& rcon, 
+  FloatMatrix tinverse (MatrixType &mattype, octave_idx_type& info, float& rcon,
                    int force, int calc_cond) const;
 
-  FloatMatrix finverse (MatrixType &mattype, octave_idx_type& info, float& rcon, 
+  FloatMatrix finverse (MatrixType &mattype, octave_idx_type& info, float& rcon,
                    int force, int calc_cond) const;
 
 public:
   FloatMatrix inverse (void) const;
   FloatMatrix inverse (octave_idx_type& info) const;
   FloatMatrix inverse (octave_idx_type& info, float& rcon, int force = 0,
                   int calc_cond = 1) const;
 
@@ -156,17 +156,17 @@ public:
   FloatComplexMatrix ifourier (void) const;
 
   FloatComplexMatrix fourier2d (void) const;
   FloatComplexMatrix ifourier2d (void) const;
 
   FloatDET determinant (void) const;
   FloatDET determinant (octave_idx_type& info) const;
   FloatDET determinant (octave_idx_type& info, float& rcon, int calc_cond = 1) const;
-  FloatDET determinant (MatrixType &mattype, octave_idx_type& info, 
+  FloatDET determinant (MatrixType &mattype, octave_idx_type& info,
                         float& rcon, int calc_cond = 1) const;
 
   float rcond (void) const;
   float rcond (MatrixType &mattype) const;
 
 private:
   // Upper triangular matrix solvers
   FloatMatrix utsolve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info,
@@ -182,89 +182,89 @@ private:
   FloatMatrix fsolve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info,
                  float& rcon, solve_singularity_handler sing_handler,
                  bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
   FloatMatrix solve (MatrixType &typ, const FloatMatrix& b) const;
   FloatMatrix solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info) const;
-  FloatMatrix solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info, 
+  FloatMatrix solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info,
                 float& rcon) const;
   FloatMatrix solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info,
                 float& rcon, solve_singularity_handler sing_handler,
                 bool singular_fallback = true, blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b) const;
-  FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b, 
+  FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b,
                        octave_idx_type& info) const;
-  FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b, 
+  FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b,
                        octave_idx_type& info, float& rcon) const;
-  FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b, 
+  FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b,
                        octave_idx_type& info, float& rcon,
                        solve_singularity_handler sing_handler,
-                       bool singular_fallback = true, 
+                       bool singular_fallback = true,
                        blas_trans_type transt = blas_no_trans) const;
 
   FloatColumnVector solve (MatrixType &typ, const FloatColumnVector& b) const;
-  FloatColumnVector solve (MatrixType &typ, const FloatColumnVector& b, 
+  FloatColumnVector solve (MatrixType &typ, const FloatColumnVector& b,
                       octave_idx_type& info) const;
-  FloatColumnVector solve (MatrixType &typ, const FloatColumnVector& b, 
+  FloatColumnVector solve (MatrixType &typ, const FloatColumnVector& b,
                       octave_idx_type& info, float& rcon) const;
-  FloatColumnVector solve (MatrixType &typ, const FloatColumnVector& b, 
+  FloatColumnVector solve (MatrixType &typ, const FloatColumnVector& b,
                       octave_idx_type& info, float& rcon,
-                      solve_singularity_handler sing_handler, 
+                      solve_singularity_handler sing_handler,
                       blas_trans_type transt = blas_no_trans) const;
 
-  FloatComplexColumnVector solve (MatrixType &typ, 
+  FloatComplexColumnVector solve (MatrixType &typ,
                              const FloatComplexColumnVector& b) const;
-  FloatComplexColumnVector solve (MatrixType &typ, const FloatComplexColumnVector& b, 
+  FloatComplexColumnVector solve (MatrixType &typ, const FloatComplexColumnVector& b,
                              octave_idx_type& info) const;
-  FloatComplexColumnVector solve (MatrixType &typ, const FloatComplexColumnVector& b, 
+  FloatComplexColumnVector solve (MatrixType &typ, const FloatComplexColumnVector& b,
                              octave_idx_type& info, float& rcon) const;
-  FloatComplexColumnVector solve (MatrixType &typ, const FloatComplexColumnVector& b, 
+  FloatComplexColumnVector solve (MatrixType &typ, const FloatComplexColumnVector& b,
                              octave_idx_type& info, float& rcon,
                              solve_singularity_handler sing_handler, blas_trans_type transt = blas_no_trans) const;
 
   // Generic interface to solver with probing of type
   FloatMatrix solve (const FloatMatrix& b) const;
   FloatMatrix solve (const FloatMatrix& b, octave_idx_type& info) const;
   FloatMatrix solve (const FloatMatrix& b, octave_idx_type& info, float& rcon) const;
   FloatMatrix solve (const FloatMatrix& b, octave_idx_type& info, float& rcon,
-                     solve_singularity_handler sing_handler, 
+                     solve_singularity_handler sing_handler,
                      blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexMatrix solve (const FloatComplexMatrix& b) const;
   FloatComplexMatrix solve (const FloatComplexMatrix& b, octave_idx_type& info) const;
   FloatComplexMatrix solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcon) const;
   FloatComplexMatrix solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcon,
-                            solve_singularity_handler sing_handler, 
+                            solve_singularity_handler sing_handler,
                             blas_trans_type transt = blas_no_trans) const;
 
   FloatColumnVector solve (const FloatColumnVector& b) const;
   FloatColumnVector solve (const FloatColumnVector& b, octave_idx_type& info) const;
   FloatColumnVector solve (const FloatColumnVector& b, octave_idx_type& info, float& rcon) const;
   FloatColumnVector solve (const FloatColumnVector& b, octave_idx_type& info, float& rcon,
-                           solve_singularity_handler sing_handler, 
+                           solve_singularity_handler sing_handler,
                            blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexColumnVector solve (const FloatComplexColumnVector& b) const;
   FloatComplexColumnVector solve (const FloatComplexColumnVector& b, octave_idx_type& info) const;
   FloatComplexColumnVector solve (const FloatComplexColumnVector& b, octave_idx_type& info,
                                   float& rcon) const;
   FloatComplexColumnVector solve (const FloatComplexColumnVector& b, octave_idx_type& info,
-                                  float& rcon, solve_singularity_handler sing_handler, 
+                                  float& rcon, solve_singularity_handler sing_handler,
                                   blas_trans_type transt = blas_no_trans) const;
 
   // Singular solvers
   FloatMatrix lssolve (const FloatMatrix& b) const;
   FloatMatrix lssolve (const FloatMatrix& b, octave_idx_type& info) const;
-  FloatMatrix lssolve (const FloatMatrix& b, octave_idx_type& info, 
+  FloatMatrix lssolve (const FloatMatrix& b, octave_idx_type& info,
                   octave_idx_type& rank) const;
-  FloatMatrix lssolve (const FloatMatrix& b, octave_idx_type& info, 
+  FloatMatrix lssolve (const FloatMatrix& b, octave_idx_type& info,
                   octave_idx_type& rank, float& rcon) const;
 
   FloatComplexMatrix lssolve (const FloatComplexMatrix& b) const;
   FloatComplexMatrix lssolve (const FloatComplexMatrix& b, octave_idx_type& info) const;
   FloatComplexMatrix lssolve (const FloatComplexMatrix& b, octave_idx_type& info,
                          octave_idx_type& rank) const;
   FloatComplexMatrix lssolve (const FloatComplexMatrix& b, octave_idx_type& info,
                          octave_idx_type& rank, float &rcon) const;
@@ -272,22 +272,22 @@ public:
   FloatColumnVector lssolve (const FloatColumnVector& b) const;
   FloatColumnVector lssolve (const FloatColumnVector& b, octave_idx_type& info) const;
   FloatColumnVector lssolve (const FloatColumnVector& b, octave_idx_type& info,
                         octave_idx_type& rank) const;
   FloatColumnVector lssolve (const FloatColumnVector& b, octave_idx_type& info,
                         octave_idx_type& rank, float& rcon) const;
 
   FloatComplexColumnVector lssolve (const FloatComplexColumnVector& b) const;
-  FloatComplexColumnVector lssolve (const FloatComplexColumnVector& b, 
+  FloatComplexColumnVector lssolve (const FloatComplexColumnVector& b,
                                octave_idx_type& info) const;
   FloatComplexColumnVector lssolve (const FloatComplexColumnVector& b,
                                octave_idx_type& info,
                                octave_idx_type& rank) const;
-  FloatComplexColumnVector lssolve (const FloatComplexColumnVector& b, 
+  FloatComplexColumnVector lssolve (const FloatComplexColumnVector& b,
                                octave_idx_type& info,
                                octave_idx_type& rank, float& rcon) const;
 
   FloatMatrix& operator += (const FloatDiagMatrix& a);
   FloatMatrix& operator -= (const FloatDiagMatrix& a);
 
   // unary operations
 
@@ -297,17 +297,17 @@ public:
 
   bool any_element_is_negative (bool = false) const;
   bool any_element_is_nan (void) const;
   bool any_element_is_inf_or_nan (void) const;
   bool any_element_not_one_or_zero (void) const;
   bool all_elements_are_int_or_inf_or_nan (void) const;
   bool all_integers (float& max_val, float& min_val) const;
   bool too_large_for_float (void) const;
- 
+
   boolMatrix all (int dim = -1) const;
   boolMatrix any (int dim = -1) const;
 
   FloatMatrix cumprod (int dim = -1) const;
   FloatMatrix cumsum (int dim = -1) const;
   FloatMatrix prod (int dim = -1) const;
   FloatMatrix sum (int dim = -1) const;
   FloatMatrix sumsq (int dim = -1) const;
@@ -347,31 +347,31 @@ extern OCTAVE_API FloatMatrix operator *
 
 // Other functions.
 
 extern OCTAVE_API FloatMatrix Givens (float, float);
 
 extern OCTAVE_API FloatMatrix Sylvester (const FloatMatrix&, const FloatMatrix&, const FloatMatrix&);
 
 extern OCTAVE_API FloatMatrix xgemm (const FloatMatrix& a, const FloatMatrix& b,
-                                     blas_trans_type transa = blas_no_trans, 
+                                     blas_trans_type transa = blas_no_trans,
                                      blas_trans_type transb = blas_no_trans);
 
 extern OCTAVE_API FloatMatrix operator * (const FloatMatrix& a, const FloatMatrix& b);
 
 extern OCTAVE_API FloatMatrix min (float d, const FloatMatrix& m);
 extern OCTAVE_API FloatMatrix min (const FloatMatrix& m, float d);
 extern OCTAVE_API FloatMatrix min (const FloatMatrix& a, const FloatMatrix& b);
 
 extern OCTAVE_API FloatMatrix max (float d, const FloatMatrix& m);
 extern OCTAVE_API FloatMatrix max (const FloatMatrix& m, float d);
 extern OCTAVE_API FloatMatrix max (const FloatMatrix& a, const FloatMatrix& b);
 
-extern OCTAVE_API FloatMatrix linspace (const FloatColumnVector& x1, 
-                                        const FloatColumnVector& x2, 
+extern OCTAVE_API FloatMatrix linspace (const FloatColumnVector& x1,
+                                        const FloatColumnVector& x2,
                                         octave_idx_type n);
 
 
 MS_CMP_OP_DECLS (FloatMatrix, float, OCTAVE_API)
 MS_BOOL_OP_DECLS (FloatMatrix, float, OCTAVE_API)
 
 SM_CMP_OP_DECLS (float, FloatMatrix, OCTAVE_API)
 SM_BOOL_OP_DECLS (float, FloatMatrix, OCTAVE_API)
diff --git a/liboctave/fNDArray.cc b/liboctave/fNDArray.cc
--- a/liboctave/fNDArray.cc
+++ b/liboctave/fNDArray.cc
@@ -74,17 +74,17 @@ FloatNDArray::fourier (int dim) const
   octave_idx_type dist = (stride == 1 ? n : 1);
 
   const float *in (fortran_vec ());
   FloatComplexNDArray retval (dv);
   FloatComplex *out (retval.fortran_vec ());
 
   // Need to be careful here about the distance between fft's
   for (octave_idx_type k = 0; k < nloop; k++)
-    octave_fftw::fft (in + k * stride * n, out + k * stride * n, 
+    octave_fftw::fft (in + k * stride * n, out + k * stride * n,
                       n, howmany, stride, dist);
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatNDArray::ifourier (int dim) const
 {
@@ -104,17 +104,17 @@ FloatNDArray::ifourier (int dim) const
   octave_idx_type nloop = (stride == 1 ? 1 : numel () / dv (dim) / stride);
   octave_idx_type dist = (stride == 1 ? n : 1);
 
   FloatComplexNDArray retval (*this);
   FloatComplex *out (retval.fortran_vec ());
 
   // Need to be careful here about the distance between fft's
   for (octave_idx_type k = 0; k < nloop; k++)
-    octave_fftw::ifft (out + k * stride * n, out + k * stride * n, 
+    octave_fftw::ifft (out + k * stride * n, out + k * stride * n,
                       n, howmany, stride, dist);
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatNDArray::fourier2d (void) const
 {
@@ -288,17 +288,17 @@ FloatNDArray::ifourier (int dim) const
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
             tmp[i] = elem((i + k*npts)*stride + j*dist);
 
           F77_FUNC (cfftb, CFFTB) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
-            retval ((i + k*npts)*stride + j*dist) = tmp[i] / 
+            retval ((i + k*npts)*stride + j*dist) = tmp[i] /
               static_cast<float> (npts);
         }
     }
 
   return retval;
 }
 
 FloatComplexNDArray
@@ -315,17 +315,17 @@ FloatNDArray::fourier2d (void) const
       octave_idx_type npts = dv2(i);
       octave_idx_type nn = 4*npts+15;
       Array<FloatComplex> wsave (nn);
       FloatComplex *pwsave = wsave.fortran_vec ();
       Array<FloatComplex> row (npts);
       FloatComplex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany : 
+      howmany = (stride == 1 ? howmany :
                  (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
@@ -363,17 +363,17 @@ FloatNDArray::ifourier2d (void) const
       octave_idx_type npts = dv2(i);
       octave_idx_type nn = 4*npts+15;
       Array<FloatComplex> wsave (nn);
       FloatComplex *pwsave = wsave.fortran_vec ();
       Array<FloatComplex> row (npts);
       FloatComplex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany : 
+      howmany = (stride == 1 ? howmany :
                  (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
@@ -382,17 +382,17 @@ FloatNDArray::ifourier2d (void) const
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
                 prow[l] = retval ((l + k*npts)*stride + j*dist);
 
               F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval ((l + k*npts)*stride + j*dist) = prow[l] / 
+                retval ((l + k*npts)*stride + j*dist) = prow[l] /
                   static_cast<float> (npts);
             }
         }
 
       stride *= dv2(i);
     }
 
   return retval;
@@ -411,17 +411,17 @@ FloatNDArray::fourierNd (void) const
       octave_idx_type npts = dv(i);
       octave_idx_type nn = 4*npts+15;
       Array<FloatComplex> wsave (nn);
       FloatComplex *pwsave = wsave.fortran_vec ();
       Array<FloatComplex> row (npts);
       FloatComplex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany : 
+      howmany = (stride == 1 ? howmany :
                  (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
@@ -458,17 +458,17 @@ FloatNDArray::ifourierNd (void) const
       octave_idx_type npts = dv(i);
       octave_idx_type nn = 4*npts+15;
       Array<FloatComplex> wsave (nn);
       FloatComplex *pwsave = wsave.fortran_vec ();
       Array<FloatComplex> row (npts);
       FloatComplex *prow = row.fortran_vec ();
 
       octave_idx_type howmany = numel () / npts;
-      howmany = (stride == 1 ? howmany : 
+      howmany = (stride == 1 ? howmany :
                  (howmany > stride ? stride : howmany));
       octave_idx_type nloop = (stride == 1 ? 1 : numel () / npts / stride);
       octave_idx_type dist = (stride == 1 ? npts : 1);
 
       F77_FUNC (cffti, CFFTI) (npts, pwsave);
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
@@ -878,10 +878,10 @@ SND_BOOL_OPS (float, FloatNDArray)
 
 NDND_CMP_OPS (FloatNDArray, FloatNDArray)
 NDND_BOOL_OPS (FloatNDArray, FloatNDArray)
 
 BSXFUN_STDOP_DEFS_MXLOOP (FloatNDArray)
 BSXFUN_STDREL_DEFS_MXLOOP (FloatNDArray)
 
 BSXFUN_OP_DEF_MXLOOP (pow, FloatNDArray, mx_inline_pow)
-BSXFUN_OP2_DEF_MXLOOP (pow, FloatComplexNDArray, FloatComplexNDArray, 
+BSXFUN_OP2_DEF_MXLOOP (pow, FloatComplexNDArray, FloatComplexNDArray,
                        FloatNDArray, mx_inline_pow)
diff --git a/liboctave/fNDArray.h b/liboctave/fNDArray.h
--- a/liboctave/fNDArray.h
+++ b/liboctave/fNDArray.h
@@ -40,31 +40,31 @@ public:
   typedef FloatMatrix matrix_type;
 
   FloatNDArray (void) : MArray<float> () { }
 
   FloatNDArray (const dim_vector& dv) : MArray<float> (dv) { }
 
   FloatNDArray (const dim_vector& dv, float val)
     : MArray<float> (dv, val) { }
-  
+
   FloatNDArray (const FloatNDArray& a) : MArray<float> (a) { }
 
   FloatNDArray (const FloatMatrix& a) : MArray<float> (a) { }
 
   template <class U>
   FloatNDArray (const MArray<U>& a) : MArray<float> (a) { }
 
   template <class U>
   FloatNDArray (const Array<U>& a) : MArray<float> (a) { }
 
   template <class U>
   explicit FloatNDArray (const intNDArray<U>& a) : MArray<float> (a) { }
 
-  FloatNDArray (const charNDArray&); 
+  FloatNDArray (const charNDArray&);
 
   FloatNDArray& operator = (const FloatNDArray& a)
     {
       MArray<float>::operator = (a);
       return *this;
     }
 
   // unary operations
@@ -84,28 +84,28 @@ public:
   // FIXME -- this is not quite the right thing.
 
   boolNDArray all (int dim = -1) const;
   boolNDArray any (int dim = -1) const;
 
   FloatNDArray cumprod (int dim = -1) const;
   FloatNDArray cumsum (int dim = -1) const;
   FloatNDArray prod (int dim = -1) const;
-  FloatNDArray sum (int dim = -1) const;  
-       NDArray dsum (int dim = -1) const;  
+  FloatNDArray sum (int dim = -1) const;
+       NDArray dsum (int dim = -1) const;
   FloatNDArray sumsq (int dim = -1) const;
   FloatNDArray concat (const FloatNDArray& rb, const Array<octave_idx_type>& ra_idx);
   FloatComplexNDArray concat (const FloatComplexNDArray& rb, const Array<octave_idx_type>& ra_idx);
   charNDArray concat (const charNDArray& rb, const Array<octave_idx_type>& ra_idx);
 
   FloatNDArray max (int dim = -1) const;
   FloatNDArray max (Array<octave_idx_type>& index, int dim = -1) const;
   FloatNDArray min (int dim = -1) const;
   FloatNDArray min (Array<octave_idx_type>& index, int dim = -1) const;
-  
+
   FloatNDArray cummax (int dim = -1) const;
   FloatNDArray cummax (Array<octave_idx_type>& index, int dim = -1) const;
   FloatNDArray cummin (int dim = -1) const;
   FloatNDArray cummin (Array<octave_idx_type>& index, int dim = -1) const;
 
   FloatNDArray diff (octave_idx_type order = 1, int dim = -1) const;
 
   FloatNDArray& insert (const FloatNDArray& a, octave_idx_type r, octave_idx_type c);
@@ -145,20 +145,20 @@ public:
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatNDArray& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatNDArray& a);
 
   static float resize_fill_value (void) { return 0; }
 
   FloatNDArray diag (octave_idx_type k = 0) const;
 
-  FloatNDArray& changesign (void) 
-    { 
-      MArray<float>::changesign (); 
-      return *this; 
+  FloatNDArray& changesign (void)
+    {
+      MArray<float>::changesign ();
+      return *this;
     }
 
 };
 
 // Publish externally used friend functions.
 
 extern OCTAVE_API FloatNDArray real (const FloatComplexNDArray& a);
 extern OCTAVE_API FloatNDArray imag (const FloatComplexNDArray& a);
@@ -175,12 +175,12 @@ NDND_CMP_OP_DECLS (FloatNDArray, FloatND
 NDND_BOOL_OP_DECLS (FloatNDArray, FloatNDArray, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArray, FloatNDArray, float)
 
 BSXFUN_STDOP_DECLS (FloatNDArray, OCTAVE_API)
 BSXFUN_STDREL_DECLS (FloatNDArray, OCTAVE_API)
 
 BSXFUN_OP_DECL (pow, FloatNDArray, OCTAVE_API)
-BSXFUN_OP2_DECL (pow, FloatComplexNDArray, FloatComplexNDArray, 
+BSXFUN_OP2_DECL (pow, FloatComplexNDArray, FloatComplexNDArray,
                  FloatNDArray, OCTAVE_API)
 
 #endif
diff --git a/liboctave/file-ops.cc b/liboctave/file-ops.cc
--- a/liboctave/file-ops.cc
+++ b/liboctave/file-ops.cc
@@ -646,17 +646,17 @@ octave_tempnam (const std::string& dir, 
 
 std::string
 octave_tempnam (const std::string& dir, const std::string& pfx,
                 std::string& msg)
 {
   msg = std::string ();
 
   std::string retval;
-  
+
   const char *pdir = dir.empty () ? 0 : dir.c_str ();
 
   const char *ppfx = pfx.empty () ? 0 : pfx.c_str ();
 
   char *tmp = tempnam (pdir, ppfx);
 
   if (tmp)
     {
diff --git a/liboctave/file-stat.cc b/liboctave/file-stat.cc
--- a/liboctave/file-stat.cc
+++ b/liboctave/file-stat.cc
@@ -49,41 +49,41 @@ base_file_stat::is_blk (void) const
 bool
 base_file_stat::is_chr (void) const
 {
   return exists () && is_chr (fs_mode);
 }
 
 bool
 base_file_stat::is_dir (void) const
-{ 
+{
   return exists () && is_dir (fs_mode);
 }
 
 bool
 base_file_stat::is_fifo (void) const
-{ 
+{
   return exists () && is_fifo (fs_mode);
 }
 
 bool
 base_file_stat::is_lnk (void) const
-{ 
+{
   return exists () && is_lnk (fs_mode);
 }
 
 bool
 base_file_stat::is_reg (void) const
-{ 
+{
   return exists () && is_reg (fs_mode);
 }
 
 bool
 base_file_stat::is_sock (void) const
-{ 
+{
   return exists () && is_sock (fs_mode);
 }
 
 bool
 base_file_stat::is_blk (mode_t mode)
 {
 #ifdef S_ISBLK
   return S_ISBLK (mode);
@@ -99,57 +99,57 @@ base_file_stat::is_chr (mode_t mode)
   return S_ISCHR (mode);
 #else
   return false;
 #endif
 }
 
 bool
 base_file_stat::is_dir (mode_t mode)
-{ 
+{
 #ifdef S_ISDIR
   return S_ISDIR (mode);
 #else
   return false;
 #endif
 }
 
 bool
 base_file_stat::is_fifo (mode_t mode)
-{ 
+{
 #ifdef S_ISFIFO
   return S_ISFIFO (mode);
 #else
   return false;
 #endif
 }
 
 bool
 base_file_stat::is_lnk (mode_t mode)
-{ 
+{
 #ifdef S_ISLNK
   return S_ISLNK (mode);
 #else
   return false;
 #endif
 }
 
 bool
 base_file_stat::is_reg (mode_t mode)
-{ 
+{
 #ifdef S_ISREG
   return S_ISREG (mode);
 #else
   return false;
 #endif
 }
 
 bool
 base_file_stat::is_sock (mode_t mode)
-{ 
+{
 #ifdef S_ISSOCK
   return S_ISSOCK (mode);
 #else
   return false;
 #endif
 }
 
 std::string
@@ -177,17 +177,17 @@ base_file_stat::is_newer (const std::str
 
 void
 file_stat::update_internal (bool force)
 {
   if (! initialized || force)
     {
       initialized = false;
       fail = false;
-      
+
       std::string full_file_name = file_ops::tilde_expand (file_name);
 
 #if defined (__WIN32__)
       // Remove trailing slash.
       if (file_ops::is_dir_sep (full_file_name[full_file_name.length () - 1])
           && full_file_name.length () != 1
           && ! (full_file_name.length() == 3 && full_file_name[1] == ':'))
         full_file_name.resize (full_file_name.length () - 1);
diff --git a/liboctave/floatAEPBAL.cc b/liboctave/floatAEPBAL.cc
--- a/liboctave/floatAEPBAL.cc
+++ b/liboctave/floatAEPBAL.cc
@@ -45,17 +45,17 @@ extern "C"
                              const octave_idx_type&, const octave_idx_type&,
                              const octave_idx_type&, const float*,
                              const octave_idx_type&, float*,
                              const octave_idx_type&, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 }
 
-FloatAEPBALANCE::FloatAEPBALANCE (const FloatMatrix& a, 
+FloatAEPBALANCE::FloatAEPBALANCE (const FloatMatrix& a,
                                   bool noperm, bool noscal)
   : base_aepbal<FloatMatrix, FloatColumnVector> ()
 {
   octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
     {
       (*current_liboctave_error_handler) ("AEPBALANCE requires square matrix");
diff --git a/liboctave/floatAEPBAL.h b/liboctave/floatAEPBAL.h
--- a/liboctave/floatAEPBAL.h
+++ b/liboctave/floatAEPBAL.h
@@ -37,15 +37,15 @@ FloatAEPBALANCE : public base_aepbal<Flo
 {
 public:
 
   FloatAEPBALANCE (void) : base_aepbal<FloatMatrix, FloatColumnVector> () { }
 
   FloatAEPBALANCE (const FloatMatrix& a, bool noperm = false,
                    bool noscal = false);
 
-  FloatAEPBALANCE (const FloatAEPBALANCE& a) 
+  FloatAEPBALANCE (const FloatAEPBALANCE& a)
     : base_aepbal<FloatMatrix, FloatColumnVector> (a) { }
 
   FloatMatrix balancing_matrix (void) const;
 };
 
 #endif
diff --git a/liboctave/floatCHOL.cc b/liboctave/floatCHOL.cc
--- a/liboctave/floatCHOL.cc
+++ b/liboctave/floatCHOL.cc
@@ -50,17 +50,17 @@ extern "C"
                              const octave_idx_type&, float*,
                              const octave_idx_type&, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (spocon, SPOCON) (F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type&, float*,
                              const octave_idx_type&, const float&,
-                             float&, float*, octave_idx_type*, 
+                             float&, float*, octave_idx_type*,
                              octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL);
 #ifdef HAVE_QRUPDATE
 
   F77_RET_T
   F77_FUNC (sch1up, SCH1UP) (const octave_idx_type&, float*,
                              const octave_idx_type&, float*, float*);
 
@@ -108,40 +108,40 @@ FloatCHOL::init (const FloatMatrix& a, b
         chol_mat.xelem (i, j) = a(i, j);
       for (octave_idx_type i = j+1; i < n; i++)
         chol_mat.xelem (i, j) = 0.0f;
     }
   float *h = chol_mat.fortran_vec ();
 
   // Calculate the norm of the matrix, for later use.
   float anorm = 0;
-  if (calc_cond) 
+  if (calc_cond)
     anorm = xnorm (a, 1);
 
   F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 ("U", 1),
                              n, h, n, info
                              F77_CHAR_ARG_LEN (1)));
 
   xrcond = 0.0;
   if (info > 0)
     chol_mat.resize (info - 1, info - 1);
-  else if (calc_cond) 
+  else if (calc_cond)
     {
       octave_idx_type spocon_info = 0;
 
       // Now calculate the condition number for non-singular matrix.
       Array<float> z (dim_vector (3*n, 1));
       float *pz = z.fortran_vec ();
       Array<octave_idx_type> iz (dim_vector (n, 1));
       octave_idx_type *piz = iz.fortran_vec ();
       F77_XFCN (spocon, SPOCON, (F77_CONST_CHAR_ARG2 ("U", 1), n, h,
                                  n, anorm, xrcond, pz, piz, spocon_info
                                  F77_CHAR_ARG_LEN (1)));
 
-      if (spocon_info != 0) 
+      if (spocon_info != 0)
         info = -1;
     }
 
   return info;
 }
 
 static FloatMatrix
 chol2inv_internal (const FloatMatrix& r)
@@ -187,17 +187,17 @@ FloatMatrix
 FloatCHOL::inverse (void) const
 {
   return chol2inv_internal (chol_mat);
 }
 
 void
 FloatCHOL::set (const FloatMatrix& R)
 {
-  if (R.is_square ()) 
+  if (R.is_square ())
     chol_mat = R;
   else
     (*current_liboctave_error_handler) ("FloatCHOL requires square matrix");
 }
 
 #ifdef HAVE_QRUPDATE
 
 void
@@ -241,17 +241,17 @@ FloatCHOL::downdate (const FloatColumnVe
 }
 
 octave_idx_type
 FloatCHOL::insert_sym (const FloatColumnVector& u, octave_idx_type j)
 {
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
-  
+
   if (u.length () != n + 1)
     (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
   else if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("cholinsert: index out of range");
   else
     {
       FloatColumnVector utmp = u;
 
@@ -265,36 +265,36 @@ FloatCHOL::insert_sym (const FloatColumn
 
   return info;
 }
 
 void
 FloatCHOL::delete_sym (octave_idx_type j)
 {
   octave_idx_type n = chol_mat.rows ();
-  
+
   if (j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("choldelete: index out of range");
   else
     {
       OCTAVE_LOCAL_BUFFER (float, w, n);
 
-      F77_XFCN (schdex, SCHDEX, (n, chol_mat.fortran_vec (), chol_mat.rows (), 
+      F77_XFCN (schdex, SCHDEX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
                                  j + 1, w));
 
       chol_mat.resize (n-1, n-1);
     }
 }
 
 void
 FloatCHOL::shift_sym (octave_idx_type i, octave_idx_type j)
 {
   octave_idx_type n = chol_mat.rows ();
-  
-  if (i < 0 || i > n-1 || j < 0 || j > n-1) 
+
+  if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("cholshift: index out of range");
   else
     {
       OCTAVE_LOCAL_BUFFER (float, w, 2*n);
 
       F77_XFCN (schshx, SCHSHX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
                                  i + 1, j + 1, w));
     }
@@ -306,17 +306,17 @@ void
 FloatCHOL::update (const FloatColumnVector& u)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = chol_mat.rows ();
 
   if (u.length () == n)
     {
-      init (chol_mat.transpose () * chol_mat 
+      init (chol_mat.transpose () * chol_mat
             + FloatMatrix (u) * FloatMatrix (u).transpose (), false);
     }
   else
     (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 }
 
 static bool
 singular (const FloatMatrix& a)
@@ -336,17 +336,17 @@ FloatCHOL::downdate (const FloatColumnVe
   octave_idx_type n = chol_mat.rows ();
 
   if (u.length () == n)
     {
       if (singular (chol_mat))
         info = 2;
       else
         {
-          info = init (chol_mat.transpose () * chol_mat 
+          info = init (chol_mat.transpose () * chol_mat
                 - FloatMatrix (u) * FloatMatrix (u).transpose (), false);
           if (info) info = 1;
         }
     }
   else
     (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
   return info;
@@ -411,17 +411,17 @@ FloatCHOL::delete_sym (octave_idx_type j
 
 void
 FloatCHOL::shift_sym (octave_idx_type i, octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = chol_mat.rows ();
 
-  if (i < 0 || i > n-1 || j < 0 || j > n-1) 
+  if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("cholshift: index out of range");
   else
     {
       FloatMatrix a = chol_mat.transpose () * chol_mat;
       Array<octave_idx_type> p (dim_vector (n, 1));
       for (octave_idx_type k = 0; k < n; k++) p(k) = k;
       if (i < j)
         {
diff --git a/liboctave/floatCHOL.h b/liboctave/floatCHOL.h
--- a/liboctave/floatCHOL.h
+++ b/liboctave/floatCHOL.h
@@ -39,17 +39,17 @@ public:
 
   FloatCHOL (const FloatMatrix& a, bool calc_cond = false)
     : chol_mat (), xrcond (0)
     {
       init (a, calc_cond);
     }
 
   FloatCHOL (const FloatMatrix& a, octave_idx_type& info,
-             bool calc_cond = false) 
+             bool calc_cond = false)
     : chol_mat (), xrcond (0)
     {
       info = init (a, calc_cond);
     }
 
   FloatCHOL (const FloatCHOL& a) : chol_mat (a.chol_mat), xrcond (a.xrcond) { }
 
   FloatCHOL& operator = (const FloatCHOL& a)
diff --git a/liboctave/floatGEPBAL.cc b/liboctave/floatGEPBAL.cc
--- a/liboctave/floatGEPBAL.cc
+++ b/liboctave/floatGEPBAL.cc
@@ -54,32 +54,32 @@ extern "C"
                              octave_idx_type& M, float* V,
                              const octave_idx_type& LDV, octave_idx_type& INFO
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
 }
 
 octave_idx_type
-FloatGEPBALANCE::init (const FloatMatrix& a, const FloatMatrix& b, 
+FloatGEPBALANCE::init (const FloatMatrix& a, const FloatMatrix& b,
                   const std::string& balance_job)
 {
   octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
     {
       (*current_liboctave_error_handler) ("FloatGEPBALANCE requires square matrix");
       return -1;
     }
 
   if (a.dims() != b.dims ())
     {
       gripe_nonconformant ("FloatGEPBALANCE", n, n, b.rows(), b.cols());
       return -1;
-    } 
+    }
 
   octave_idx_type info;
   octave_idx_type ilo;
   octave_idx_type ihi;
 
   OCTAVE_LOCAL_BUFFER (float, plscale, n);
   OCTAVE_LOCAL_BUFFER (float, prscale, n);
   OCTAVE_LOCAL_BUFFER (float, pwork, 6 * n);
@@ -110,17 +110,17 @@ FloatGEPBALANCE::init (const FloatMatrix
 
   // first left
   F77_XFCN (sggbak, SGGBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
                              F77_CONST_CHAR_ARG2 ("L", 1),
                              n, ilo, ihi, plscale, prscale,
                              n, p_balancing_mat, n, info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
-      
+
   // then right
   F77_XFCN (sggbak, SGGBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
                              F77_CONST_CHAR_ARG2 ("R", 1),
                              n, ilo, ihi, plscale, prscale,
                              n, p_balancing_mat2, n, info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
diff --git a/liboctave/floatGEPBAL.h b/liboctave/floatGEPBAL.h
--- a/liboctave/floatGEPBAL.h
+++ b/liboctave/floatGEPBAL.h
@@ -36,17 +36,17 @@ public:
 
   FloatGEPBALANCE (void)
     : balanced_mat (), balanced_mat2 (), balancing_mat (), balancing_mat2 ()
     { }
   FloatGEPBALANCE (const FloatMatrix& a, const FloatMatrix& b,
                    const std::string& balance_job)
     : balanced_mat (), balanced_mat2 (), balancing_mat (), balancing_mat2 ()
     {
-      init (a, b, balance_job); 
+      init (a, b, balance_job);
     }
 
   FloatGEPBALANCE (const FloatGEPBALANCE& a)
     : balanced_mat (a.balanced_mat), balanced_mat2 (a.balanced_mat2),
       balancing_mat (a.balancing_mat), balancing_mat2 (a.balancing_mat2) { }
 
   FloatGEPBALANCE& operator = (const FloatGEPBALANCE& a)
     {
@@ -74,13 +74,13 @@ public:
 
 private:
 
   FloatMatrix balanced_mat;
   FloatMatrix balanced_mat2;
   FloatMatrix balancing_mat;
   FloatMatrix balancing_mat2;
 
-  octave_idx_type init (const FloatMatrix& a, const FloatMatrix& b, 
+  octave_idx_type init (const FloatMatrix& a, const FloatMatrix& b,
                         const std::string& balance_job);
 };
 
 #endif
diff --git a/liboctave/floatLU.h b/liboctave/floatLU.h
--- a/liboctave/floatLU.h
+++ b/liboctave/floatLU.h
@@ -34,17 +34,17 @@ FloatLU : public base_lu <FloatMatrix>
 public:
 
   FloatLU (void) : base_lu <FloatMatrix> () { }
 
   FloatLU (const FloatMatrix& a);
 
   FloatLU (const FloatLU& a) : base_lu <FloatMatrix> (a) { }
 
-  FloatLU (const FloatMatrix& l, const FloatMatrix& u, 
+  FloatLU (const FloatMatrix& l, const FloatMatrix& u,
            const PermMatrix& p)
     : base_lu <FloatMatrix> (l, u, p) { }
 
   FloatLU& operator = (const FloatLU& a)
     {
       if (this != &a)
         base_lu <FloatMatrix> :: operator = (a);
 
diff --git a/liboctave/floatQR.cc b/liboctave/floatQR.cc
--- a/liboctave/floatQR.cc
+++ b/liboctave/floatQR.cc
@@ -37,17 +37,17 @@ along with Octave; see the file COPYING.
 
 template class base_qr<FloatMatrix>;
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (sgeqrf, SGEQRF) (const octave_idx_type&, const octave_idx_type&,
                              float*, const octave_idx_type&, float*, float*,
-                             const octave_idx_type&, octave_idx_type&); 
+                             const octave_idx_type&, octave_idx_type&);
 
   F77_RET_T
   F77_FUNC (sorgqr, SORGQR) (const octave_idx_type&, const octave_idx_type&,
                              const octave_idx_type&, float*,
                              const octave_idx_type&, float*, float*,
                              const octave_idx_type&, octave_idx_type&);
 
 #ifdef HAVE_QRUPDATE
@@ -68,23 +68,23 @@ extern "C"
   F77_RET_T
   F77_FUNC (sqrdec, SQRDEC) (const octave_idx_type&, const octave_idx_type&,
                              const octave_idx_type&, float*,
                              const octave_idx_type&, float*,
                              const octave_idx_type&,
                              const octave_idx_type&, float*);
 
   F77_RET_T
-  F77_FUNC (sqrinr, SQRINR) (const octave_idx_type&, const octave_idx_type&, 
+  F77_FUNC (sqrinr, SQRINR) (const octave_idx_type&, const octave_idx_type&,
                              float*, const octave_idx_type&,
                              float*, const octave_idx_type&,
                              const octave_idx_type&, const float*, float*);
 
   F77_RET_T
-  F77_FUNC (sqrder, SQRDER) (const octave_idx_type&, const octave_idx_type&, 
+  F77_FUNC (sqrder, SQRDER) (const octave_idx_type&, const octave_idx_type&,
                              float*, const octave_idx_type&,
                              float*, const octave_idx_type&,
                              const octave_idx_type&, float*);
 
   F77_RET_T
   F77_FUNC (sqrshc, SQRSHC) (const octave_idx_type&, const octave_idx_type&,
                              const octave_idx_type&, float*,
                              const octave_idx_type&, float*,
@@ -126,17 +126,17 @@ FloatQR::init (const FloatMatrix& a, qr_
       lwork = std::max (lwork, static_cast<octave_idx_type> (1));
       OCTAVE_LOCAL_BUFFER (float, work, lwork);
       F77_XFCN (sgeqrf, SGEQRF, (m, n, afact.fortran_vec (), m, tau, work, lwork, info));
     }
 
   form (n, afact, tau, qr_type);
 }
 
-void FloatQR::form (octave_idx_type n, FloatMatrix& afact, 
+void FloatQR::form (octave_idx_type n, FloatMatrix& afact,
                     float *tau, qr_type_t qr_type)
 {
   octave_idx_type m = afact.rows (), min_mn = std::min (m, n);
   octave_idx_type info;
 
   if (qr_type == qr_type_raw)
     {
       for (octave_idx_type j = 0; j < min_mn; j++)
@@ -244,34 +244,34 @@ void
 FloatQR::insert_col (const FloatColumnVector& u, octave_idx_type j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
   if (u.length () != m)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (j < 0 || j > n) 
+  else if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       if (k < m)
         {
           q.resize (m, k+1);
           r.resize (k+1, n+1);
         }
       else
         {
           r.resize (k, n+1);
         }
 
       FloatColumnVector utmp = u;
       OCTAVE_LOCAL_BUFFER (float, w, k);
       F77_XFCN (sqrinc, SQRINC, (m, n, k, q.fortran_vec (), q.rows (),
-                                 r.fortran_vec (), r.rows (), j + 1, 
+                                 r.fortran_vec (), r.rows (), j + 1,
                                  utmp.data (), w));
     }
 }
 
 void
 FloatQR::insert_col (const FloatMatrix& u, const Array<octave_idx_type>& j)
 {
   octave_idx_type m = q.rows ();
@@ -304,32 +304,32 @@ FloatQR::insert_col (const FloatMatrix& 
           r.resize (k, n + nj);
         }
 
       OCTAVE_LOCAL_BUFFER (float, w, kmax);
       for (volatile octave_idx_type i = 0; i < js.length (); i++)
         {
           octave_idx_type ii = i;
           FloatColumnVector utmp = u.column (jsi(i));
-          F77_XFCN (sqrinc, SQRINC, (m, n + ii, std::min (kmax, k + ii), 
+          F77_XFCN (sqrinc, SQRINC, (m, n + ii, std::min (kmax, k + ii),
                                      q.fortran_vec (), q.rows (),
-                                     r.fortran_vec (), r.rows (), js(ii) + 1, 
+                                     r.fortran_vec (), r.rows (), js(ii) + 1,
                                      utmp.data (), w));
         }
     }
 }
 
 void
 FloatQR::delete_col (octave_idx_type j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type k = r.rows ();
   octave_idx_type n = r.columns ();
 
-  if (j < 0 || j > n-1) 
+  if (j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
   else
     {
       OCTAVE_LOCAL_BUFFER (float, w, k);
       F77_XFCN (sqrdec, SQRDEC, (m, n, k, q.fortran_vec (), q.rows (),
                                  r.fortran_vec (), r.rows (), j + 1, w));
 
       if (k < m)
@@ -363,17 +363,17 @@ FloatQR::delete_col (const Array<octave_
   else if (nj > 0 && (js(0) > n-1 || js(nj-1) < 0))
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else if (nj > 0)
     {
       OCTAVE_LOCAL_BUFFER (float, w, k);
       for (volatile octave_idx_type i = 0; i < js.length (); i++)
         {
           octave_idx_type ii = i;
-          F77_XFCN (sqrdec, SQRDEC, (m, n - ii, k == m ? k : k - ii, 
+          F77_XFCN (sqrdec, SQRDEC, (m, n - ii, k == m ? k : k - ii,
                                      q.fortran_vec (), q.rows (),
                                      r.fortran_vec (), r.rows (), js(ii) + 1, w));
         }
       if (k < m)
         {
           q.resize (m, k - nj);
           r.resize (k - nj, n - nj);
         }
@@ -389,40 +389,40 @@ void
 FloatQR::insert_row (const FloatRowVector& u, octave_idx_type j)
 {
   octave_idx_type m = r.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = std::min (m, n);
 
   if (! q.is_square () || u.length () != n)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (j < 0 || j > m) 
+  else if (j < 0 || j > m)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       q.resize (m + 1, m + 1);
       r.resize (m + 1, n);
       FloatRowVector utmp = u;
       OCTAVE_LOCAL_BUFFER (float, w, k);
       F77_XFCN (sqrinr, SQRINR, (m, n, q.fortran_vec (), q.rows (),
-                                 r.fortran_vec (), r.rows (), 
+                                 r.fortran_vec (), r.rows (),
                                  j + 1, utmp.fortran_vec (), w));
 
     }
 }
 
 void
 FloatQR::delete_row (octave_idx_type j)
 {
   octave_idx_type m = r.rows ();
   octave_idx_type n = r.columns ();
 
   if (! q.is_square ())
     (*current_liboctave_error_handler) ("qrdelete: dimensions mismatch");
-  else if (j < 0 || j > m-1) 
+  else if (j < 0 || j > m-1)
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
   else
     {
       OCTAVE_LOCAL_BUFFER (float, w, 2*m);
       F77_XFCN (sqrder, SQRDER, (m, n, q.fortran_vec (), q.rows (),
                                  r.fortran_vec (), r.rows (), j + 1,
                                  w));
 
@@ -433,22 +433,22 @@ FloatQR::delete_row (octave_idx_type j)
 
 void
 FloatQR::shift_cols (octave_idx_type i, octave_idx_type j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type k = r.rows ();
   octave_idx_type n = r.columns ();
 
-  if (i < 0 || i > n-1 || j < 0 || j > n-1) 
+  if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("qrshift: index out of range");
   else
     {
       OCTAVE_LOCAL_BUFFER (float, w, 2*k);
-      F77_XFCN (sqrshc, SQRSHC, (m, n, k, 
+      F77_XFCN (sqrshc, SQRSHC, (m, n, k,
                                  q.fortran_vec (), q.rows (),
                                  r.fortran_vec (), r.rows (),
                                  i + 1, j + 1, w));
     }
 }
 
 #else
 
@@ -524,17 +524,17 @@ static
 FloatMatrix delete_row (const FloatMatrix& a, octave_idx_type i)
 {
   FloatMatrix retval = a;
   retval.delete_elements (0, idx_vector (i));
   return retval;
 }
 
 static
-FloatMatrix shift_cols (const FloatMatrix& a, 
+FloatMatrix shift_cols (const FloatMatrix& a,
                         octave_idx_type i, octave_idx_type j)
 {
   octave_idx_type n = a.columns ();
   Array<octave_idx_type> p (n);
   for (octave_idx_type k = 0; k < n; k++) p(k) = k;
   if (i < j)
     {
       for (octave_idx_type k = i; k < j; k++) p(k) = k+1;
@@ -554,17 +554,17 @@ FloatQR::insert_col (const FloatColumnVe
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
   if (u.length () != m)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (j < 0 || j > n) 
+  else if (j < 0 || j > n)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       init (::insert_col (q*r, j, u), get_type ());
     }
 }
 
 void
@@ -600,17 +600,17 @@ FloatQR::insert_col (const FloatMatrix& 
 void
 FloatQR::delete_col (octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
-  if (j < 0 || j > n-1) 
+  if (j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
   else
     {
       init (::delete_col (q*r, j), get_type ());
     }
 }
 
 void
@@ -646,17 +646,17 @@ FloatQR::insert_row (const FloatRowVecto
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = r.rows ();
   octave_idx_type n = r.columns ();
 
   if (! q.is_square () || u.length () != n)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
-  else if (j < 0 || j > m) 
+  else if (j < 0 || j > m)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       init (::insert_row (q*r, j, u), get_type ());
     }
 }
 
 void
@@ -664,33 +664,33 @@ FloatQR::delete_row (octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = r.rows ();
   octave_idx_type n = r.columns ();
 
   if (! q.is_square ())
     (*current_liboctave_error_handler) ("qrdelete: dimensions mismatch");
-  else if (j < 0 || j > m-1) 
+  else if (j < 0 || j > m-1)
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
   else
     {
       init (::delete_row (q*r, j), get_type ());
     }
 }
 
 void
 FloatQR::shift_cols (octave_idx_type i, octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
-  if (i < 0 || i > n-1 || j < 0 || j > n-1) 
+  if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("qrshift: index out of range");
   else
     {
       init (::shift_cols (q*r, i, j), get_type ());
     }
 }
 
 #endif
diff --git a/liboctave/floatQR.h b/liboctave/floatQR.h
--- a/liboctave/floatQR.h
+++ b/liboctave/floatQR.h
@@ -36,17 +36,17 @@ OCTAVE_API
 FloatQR : public base_qr<FloatMatrix>
 {
 public:
 
   FloatQR (void) : base_qr<FloatMatrix> () { }
 
   FloatQR (const FloatMatrix&, qr_type_t = qr_type_std);
 
-  FloatQR (const FloatMatrix& qx, const FloatMatrix& rx) 
+  FloatQR (const FloatMatrix& qx, const FloatMatrix& rx)
     : base_qr<FloatMatrix> (qx, rx) { }
 
   FloatQR (const FloatQR& a) : base_qr<FloatMatrix> (a) { }
 
   void init (const FloatMatrix&, qr_type_t);
 
   void update (const FloatColumnVector& u, const FloatColumnVector& v);
 
@@ -63,13 +63,13 @@ public:
   void insert_row (const FloatRowVector& u, octave_idx_type j);
 
   void delete_row (octave_idx_type j);
 
   void shift_cols (octave_idx_type i, octave_idx_type j);
 
 protected:
 
-  void form (octave_idx_type n, FloatMatrix& afact, 
+  void form (octave_idx_type n, FloatMatrix& afact,
              float *tau, qr_type_t qr_type);
 };
 
 #endif
diff --git a/liboctave/floatQRP.cc b/liboctave/floatQRP.cc
--- a/liboctave/floatQRP.cc
+++ b/liboctave/floatQRP.cc
@@ -90,15 +90,15 @@ FloatQRP::init (const FloatMatrix& a, qr
 
   jpvt -= static_cast<octave_idx_type> (1);
   p = PermMatrix (jpvt, true);
 
 
   form (n, afact, tau, qr_type);
 }
 
-FloatRowVector 
+FloatRowVector
 FloatQRP::Pvec (void) const
 {
   Array<float> pa (p.pvec ());
   FloatRowVector pv (MArray<float> (pa) + 1.0f);
   return pv;
 }
diff --git a/liboctave/floatSCHUR.h b/liboctave/floatSCHUR.h
--- a/liboctave/floatSCHUR.h
+++ b/liboctave/floatSCHUR.h
@@ -38,17 +38,17 @@ public:
 
   FloatSCHUR (const FloatMatrix& a, const std::string& ord,
               bool calc_unitary = true)
     : schur_mat (), unitary_mat (), selector (0)
     {
       init (a, ord, calc_unitary);
     }
 
-  FloatSCHUR (const FloatMatrix& a, const std::string& ord, int& info, 
+  FloatSCHUR (const FloatMatrix& a, const std::string& ord, int& info,
               bool calc_unitary = true)
     : schur_mat (), unitary_mat (), selector (0)
     {
       info = init (a, ord, calc_unitary);
     }
 
   FloatSCHUR (const FloatSCHUR& a)
     : schur_mat (a.schur_mat), unitary_mat (a.unitary_mat), selector (0)
diff --git a/liboctave/floatSVD.h b/liboctave/floatSVD.h
--- a/liboctave/floatSVD.h
+++ b/liboctave/floatSVD.h
@@ -32,26 +32,26 @@ along with Octave; see the file COPYING.
 class
 OCTAVE_API
 FloatSVD
 {
 public:
 
   FloatSVD (void) : type_computed (), sigma (), left_sm (), right_sm () { }
 
-  FloatSVD (const FloatMatrix& a, 
-            SVD::type svd_type = SVD::std, SVD::driver svd_driver = SVD::GESVD) 
+  FloatSVD (const FloatMatrix& a,
+            SVD::type svd_type = SVD::std, SVD::driver svd_driver = SVD::GESVD)
     : type_computed (), sigma (), left_sm (), right_sm ()
     {
       init (a, svd_type, svd_driver);
     }
 
-  FloatSVD (const FloatMatrix& a, octave_idx_type& info, 
+  FloatSVD (const FloatMatrix& a, octave_idx_type& info,
             SVD::type svd_type = SVD::std,
-            SVD::driver svd_driver = SVD::GESVD) 
+            SVD::driver svd_driver = SVD::GESVD)
     : type_computed (), sigma (), left_sm (), right_sm ()
     {
       info = init (a, svd_type, svd_driver);
     }
 
   FloatSVD (const FloatSVD& a)
     : type_computed (a.type_computed), sigma (a.sigma),
       left_sm (a.left_sm), right_sm (a.right_sm)
@@ -83,14 +83,14 @@ public:
 private:
 
   SVD::type type_computed;
 
   FloatDiagMatrix sigma;
   FloatMatrix left_sm;
   FloatMatrix right_sm;
 
-  octave_idx_type init (const FloatMatrix& a, 
-                        SVD::type svd_type = SVD::std, 
+  octave_idx_type init (const FloatMatrix& a,
+                        SVD::type svd_type = SVD::std,
                         SVD::driver svd_driver = SVD::GESVD);
 };
 
 #endif
diff --git a/liboctave/idx-vector.cc b/liboctave/idx-vector.cc
--- a/liboctave/idx-vector.cc
+++ b/liboctave/idx-vector.cc
@@ -93,17 +93,17 @@ idx_vector::idx_colon_rep::sort_idx (Arr
 {
   (*current_liboctave_error_handler)
     ("internal error: idx_colon_rep::sort_idx");
 
   count++;
   return this;
 }
 
-std::ostream& 
+std::ostream&
 idx_vector::idx_colon_rep::print (std::ostream& os) const
 {
   return os << ":";
 }
 
 DEFINE_OCTAVE_ALLOCATOR(idx_vector::idx_range_rep);
 
 idx_vector::idx_range_rep::idx_range_rep (octave_idx_type _start,
@@ -129,17 +129,17 @@ idx_vector::idx_range_rep::idx_range_rep
   if (len < 0)
     {
       gripe_invalid_range ();
       err = true;
     }
   else if (len > 0)
     {
       if (r.all_elements_are_ints ())
-        {    
+        {
           start = static_cast<octave_idx_type> (r.base ()) - 1;
           step = static_cast<octave_idx_type> (r.inc ());
           if (start < 0 || (step < 0 && start + (len-1)*step < 0))
             {
               gripe_invalid_index ();
               err = true;
             }
         }
@@ -190,45 +190,45 @@ idx_vector::idx_range_rep::sort_idx (Arr
       idx.clear (1, len);
       for (octave_idx_type i = 0; i < len; i++)
         idx.xelem (i) = i;
       count++;
       return this;
     }
 }
 
-std::ostream& 
+std::ostream&
 idx_vector::idx_range_rep::print (std::ostream& os) const
 {
   os << start << ':' << step << ':' << start + len*step;
   return os;
 }
 
 Range
 idx_vector::idx_range_rep::unconvert (void) const
 {
-  return Range (static_cast<double> (start+1), 
+  return Range (static_cast<double> (start+1),
                 static_cast<double> (step), len);
 }
 
 Array<octave_idx_type>
 idx_vector::idx_range_rep::as_array (void)
 {
   Array<octave_idx_type> retval (dim_vector (1, len));
   for (octave_idx_type i = 0; i < len; i++)
     retval.xelem (i) = start + i*step;
 
   return retval;
 }
 
 inline octave_idx_type
-convert_index (octave_idx_type i, bool& conv_error, 
+convert_index (octave_idx_type i, bool& conv_error,
                octave_idx_type& ext)
 {
-  if (i <= 0) 
+  if (i <= 0)
     conv_error = true;
 
   if (ext < i)
     ext = i;
 
   return i - 1;
 }
 
@@ -246,17 +246,17 @@ convert_index (double x, bool& conv_erro
 inline octave_idx_type
 convert_index (float x, bool& conv_error, octave_idx_type& ext)
 {
   return convert_index (static_cast<double> (x), conv_error, ext);
 }
 
 template <class T>
 inline octave_idx_type
-convert_index (octave_int<T> x, bool& conv_error, 
+convert_index (octave_int<T> x, bool& conv_error,
                octave_idx_type& ext)
 {
   octave_idx_type i = octave_int<octave_idx_type> (x).value ();
 
   return convert_index (i, conv_error, ext);
 }
 
 DEFINE_OCTAVE_ALLOCATOR(idx_vector::idx_scalar_rep);
@@ -268,20 +268,20 @@ idx_vector::idx_scalar_rep::idx_scalar_r
   octave_idx_type dummy = 0;
 
   data = convert_index (x, err, dummy);
 
   if (err)
     gripe_invalid_index ();
 }
 
-idx_vector::idx_scalar_rep::idx_scalar_rep (octave_idx_type i) 
+idx_vector::idx_scalar_rep::idx_scalar_rep (octave_idx_type i)
   : data (i)
 {
-  if (data < 0) 
+  if (data < 0)
     {
       gripe_invalid_index ();
       err = true;
     }
 }
 
 octave_idx_type
 idx_vector::idx_scalar_rep::checkelem (octave_idx_type i) const
@@ -334,41 +334,41 @@ idx_vector::idx_vector_rep::idx_vector_r
       if (err)
         gripe_invalid_index ();
     }
 }
 
 // Note that this makes a shallow copy of the index array.
 
 idx_vector::idx_vector_rep::idx_vector_rep (const Array<octave_idx_type>& inda)
-  : data (inda.data ()), len (inda.numel ()), ext (0), 
+  : data (inda.data ()), len (inda.numel ()), ext (0),
     aowner (new Array<octave_idx_type> (inda)), orig_dims (inda.dims ())
 {
   if (len != 0)
     {
       octave_idx_type max = -1;
       for (octave_idx_type i = 0; i < len; i++)
         {
           octave_idx_type k = inda.xelem (i);
-          if (k < 0) 
+          if (k < 0)
             err = true;
-          else if (k > max) 
+          else if (k > max)
             max = k;
         }
 
       ext = max + 1;
 
       if (err)
         gripe_invalid_index ();
     }
 }
 
 idx_vector::idx_vector_rep::idx_vector_rep (const Array<octave_idx_type>& inda,
                                             octave_idx_type _ext, direct)
-  : data (inda.data ()), len (inda.numel ()), ext (_ext), 
+  : data (inda.data ()), len (inda.numel ()), ext (_ext),
     aowner (new Array<octave_idx_type> (inda)), orig_dims (inda.dims ())
 {
   // No checking.
   if (ext < 0)
     {
       octave_idx_type max = -1;
       for (octave_idx_type i = 0; i < len; i++)
         if (data[i] > max)
@@ -395,17 +395,17 @@ idx_vector::idx_vector_rep::idx_vector_r
   : data (0), len (nnz), ext (0), aowner (0), orig_dims ()
 {
   if (nnz < 0)
     len = bnda.nnz ();
 
   const dim_vector dv = bnda.dims ();
 
   if (! dv.all_zero ())
-    orig_dims = ((dv.length () == 2 && dv(0) == 1) 
+    orig_dims = ((dv.length () == 2 && dv(0) == 1)
                  ? dim_vector (1, len) : dim_vector (len, 1));
 
   if (len != 0)
     {
       octave_idx_type *d = new octave_idx_type [len];
 
       octave_idx_type ntot = bnda.length ();
 
@@ -436,32 +436,32 @@ idx_vector::idx_vector_rep::idx_vector_r
       octave_idx_type *d = new octave_idx_type [len];
 
       octave_idx_type nnz = bnda.nnz ();
 
       octave_idx_type k = 0;
       // FIXME: I hope this is OK, i.e. the element iterated this way are correctly ordered.
       for (octave_idx_type i = 0; i < nnz; i++)
         {
-          if (bnda.data (i)) 
+          if (bnda.data (i))
             d[k++] = bnda.cidx (i) + bnda.rows () * bnda.ridx (i);
         }
 
       data = d;
 
       ext = d[k-1] + 1;
     }
 }
 
 idx_vector::idx_vector_rep::~idx_vector_rep (void)
-{ 
-  if (aowner) 
+{
+  if (aowner)
     delete aowner;
   else
-    delete [] data; 
+    delete [] data;
 }
 
 octave_idx_type
 idx_vector::idx_vector_rep::checkelem (octave_idx_type n) const
 {
   if (n < 0 || n >= len)
     {
       gripe_invalid_index ();
@@ -476,17 +476,17 @@ idx_vector::idx_vector_rep::sort_uniq_cl
 {
   if (len == 0)
     {
       count++;
       return this;
     }
 
   // This is wrapped in auto_ptr so that we don't leak on out-of-memory.
-  std::auto_ptr<idx_vector_rep> new_rep ( 
+  std::auto_ptr<idx_vector_rep> new_rep (
     new idx_vector_rep (0, len, ext, orig_dims, DIRECT));
 
   if (ext > len*xlog2 (1.0 + len))
     {
       // Use standard sort via octave_sort.
       octave_idx_type *new_data = new octave_idx_type[len];
       new_rep->data = new_data;
 
@@ -599,17 +599,17 @@ idx_vector::idx_vector_rep::sort_idx (Ar
           new_data[k] = j;
           idx_data[k] = i;
         }
     }
 
   return new_rep.release ();
 }
 
-std::ostream& 
+std::ostream&
 idx_vector::idx_vector_rep::print (std::ostream& os) const
 {
   os << '[';
 
   for (octave_idx_type ii = 0; ii < len - 1; ii++)
     os << data[ii] << ',' << ' ';
 
   if (len > 0)
@@ -670,29 +670,29 @@ idx_vector::idx_mask_rep::idx_mask_rep (
   // We truncate the extent as much as possible. For Matlab
   // compatibility, but maybe it's not a bad idea anyway.
   while (ext > 0 && ! bnda(ext-1))
     ext--;
 
   const dim_vector dv = bnda.dims ();
 
   if (! dv.all_zero ())
-    orig_dims = ((dv.length () == 2 && dv(0) == 1) 
+    orig_dims = ((dv.length () == 2 && dv(0) == 1)
                  ? dim_vector (1, len) : dim_vector (len, 1));
 
   aowner = new Array<bool> (bnda);
   data = bnda.data ();
 }
 
 idx_vector::idx_mask_rep::~idx_mask_rep (void)
-{ 
-  if (aowner) 
+{
+  if (aowner)
     delete aowner;
   else
-    delete [] data; 
+    delete [] data;
 }
 
 octave_idx_type
 idx_vector::idx_mask_rep::xelem (octave_idx_type n) const
 {
   if (n == lsti + 1)
     {
       lsti = n;
@@ -715,17 +715,17 @@ idx_vector::idx_mask_rep::checkelem (oct
     {
       gripe_invalid_index ();
       return 0;
     }
 
   return xelem (n);
 }
 
-std::ostream& 
+std::ostream&
 idx_vector::idx_mask_rep::print (std::ostream& os) const
 {
   os << '[';
 
   for (octave_idx_type ii = 0; ii < ext - 1; ii++)
     os << data[ii] << ',' << ' ';
 
   if (ext > 0)
@@ -1145,17 +1145,17 @@ idx_vector::is_permutation (octave_idx_t
     retval = true;
   else if (length (n) == n && extent(n) == n)
     {
       OCTAVE_LOCAL_BUFFER_INIT (bool, left, n, true);
 
       retval = true;
 
       for (octave_idx_type i = 0, len = length (); i < len; i++)
-        { 
+        {
           octave_idx_type k = xelem (i);
           if (left[k])
               left[k] = false;
           else
             {
               retval = false;
               break;
             }
@@ -1206,30 +1206,30 @@ idx_vector::unmask (void) const
   if (idx_class () == class_mask)
     {
       idx_mask_rep * r = dynamic_cast<idx_mask_rep *> (rep);
       const bool *data = r->get_data ();
       octave_idx_type ext = r->extent (0), len = r->length (0);
       octave_idx_type *idata = new octave_idx_type [len];
 
       for (octave_idx_type i = 0, j = 0; i < ext; i++)
-        if (data[i]) 
+        if (data[i])
           idata[j++] = i;
 
       ext = len > 0 ? idata[len - 1] + 1 : 0;
 
       return new idx_vector_rep (idata, len, ext, r->orig_dimensions (),
                                  DIRECT);
     }
   else
     return *this;
 }
 
 void idx_vector::unconvert (idx_class_type& iclass,
-                            double& scalar, Range& range, 
+                            double& scalar, Range& range,
                             Array<double>& array, Array<bool>& mask) const
 {
   iclass = idx_class ();
   switch (iclass)
     {
     case class_colon:
       break;
 
@@ -1262,43 +1262,43 @@ void idx_vector::unconvert (idx_class_ty
       break;
 
     default:
       assert (false);
       break;
     }
 }
 
-Array<octave_idx_type> 
+Array<octave_idx_type>
 idx_vector::as_array (void) const
 {
   return rep->as_array ();
 }
 
 bool
 idx_vector::is_vector (void) const
 {
   return idx_class () != class_vector || orig_dimensions ().is_vector ();
 }
-    
-octave_idx_type 
+
+octave_idx_type
 idx_vector::freeze (octave_idx_type z_len, const char *, bool resize_ok)
 {
   if (! resize_ok && extent (z_len) > z_len)
     {
       (*current_liboctave_error_handler)
         ("invalid matrix index = %d", extent (z_len));
       rep->err = true;
       chkerr ();
     }
 
   return length (z_len);
 }
 
-octave_idx_type 
+octave_idx_type
 idx_vector::ones_count () const
 {
   octave_idx_type n = 0;
 
   if (is_colon ())
     n = 1;
   else
     {
diff --git a/liboctave/idx-vector.h b/liboctave/idx-vector.h
--- a/liboctave/idx-vector.h
+++ b/liboctave/idx-vector.h
@@ -46,17 +46,17 @@ class Range;
 // templates implementing "early dispatch", i.e. hoisting the checks for index
 // type out of loops.
 
 class
 OCTAVE_API
 idx_vector
 {
 public:
-  
+
   enum idx_class_type
     {
       class_invalid = -1,
       class_colon = 0,
       class_range,
       class_scalar,
       class_vector,
       class_mask
@@ -152,25 +152,25 @@ private:
   // To distinguish the "direct" constructors that blindly trust the data.
   enum direct { DIRECT };
 
   // The integer range index.
   class OCTAVE_API idx_range_rep : public idx_base_rep
   {
   public:
     idx_range_rep (octave_idx_type _start, octave_idx_type _len,
-                   octave_idx_type _step, direct) 
+                   octave_idx_type _step, direct)
       : idx_base_rep (), start(_start), len(_len), step(_step) { }
 
-    idx_range_rep (void) 
+    idx_range_rep (void)
       : start(0), len(0), step(1) { }
 
     // Zero-based constructor.
     idx_range_rep (octave_idx_type _start, octave_idx_type _limit,
-                   octave_idx_type _step); 
+                   octave_idx_type _step);
 
     idx_range_rep (const Range&);
 
     octave_idx_type xelem (octave_idx_type i) const
       { return start + i * step; }
 
     octave_idx_type checkelem (octave_idx_type i) const;
 
@@ -270,21 +270,21 @@ private:
 
   };
 
   // The integer vector index.
   class OCTAVE_API idx_vector_rep : public idx_base_rep
   {
   public:
     // Direct constructor.
-    idx_vector_rep (octave_idx_type *_data, octave_idx_type _len, 
+    idx_vector_rep (octave_idx_type *_data, octave_idx_type _len,
                     octave_idx_type _ext, const dim_vector& od, direct)
       : data (_data), len (_len), ext (_ext), aowner (0), orig_dims (od) { }
 
-    idx_vector_rep (void) 
+    idx_vector_rep (void)
       : data (0), len (0), ext (0), aowner (0), orig_dims ()
       { }
 
     // Zero-based constructor.
     idx_vector_rep (const Array<octave_idx_type>& inda);
 
     idx_vector_rep (const Array<octave_idx_type>& inda,
                     octave_idx_type _ext, direct);
@@ -319,17 +319,17 @@ private:
 
     const octave_idx_type *get_data (void) const { return data; }
 
     std::ostream& print (std::ostream& os) const;
 
     Array<double> unconvert (void) const;
 
     Array<octave_idx_type> as_array (void);
-    
+
   private:
 
     DECLARE_OCTAVE_ALLOCATOR
 
     // No copying!
     idx_vector_rep (const idx_vector_rep& idx);
     idx_vector_rep& operator = (const idx_vector_rep& idx);
 
@@ -338,33 +338,33 @@ private:
     octave_idx_type ext;
 
     // This is a trick to allow user-given zero-based arrays to be used
     // as indices without copying.  If the following pointer is nonzero,
     // we do not own the data, but rather have an Array<octave_idx_type>
     // object that provides us the data.  Note that we need a pointer
     // because we deferred the Array<T> declaration and we do not want
     // it yet to be defined.
-    
+
     Array<octave_idx_type> *aowner;
 
     dim_vector orig_dims;
   };
 
   // The logical mask index.
   class OCTAVE_API idx_mask_rep : public idx_base_rep
   {
   public:
     // Direct constructor.
-    idx_mask_rep (bool *_data, octave_idx_type _len, 
+    idx_mask_rep (bool *_data, octave_idx_type _len,
                   octave_idx_type _ext, const dim_vector& od, direct)
       : data (_data), len (_len), ext (_ext), lsti (-1), lste (-1),
         aowner (0), orig_dims (od) { }
 
-    idx_mask_rep (void) 
+    idx_mask_rep (void)
       : data (0), len (0), ext (0), lsti (-1), lste (-1), aowner (0),
         orig_dims ()
       { }
 
     idx_mask_rep (bool);
 
     idx_mask_rep (const Array<bool>&, octave_idx_type = -1);
 
@@ -376,34 +376,34 @@ private:
 
     octave_idx_type length (octave_idx_type) const { return len; }
 
     octave_idx_type extent (octave_idx_type n) const
       { return std::max (n, ext); }
 
     idx_class_type idx_class (void) const { return class_mask; }
 
-    idx_base_rep *sort_uniq_clone (bool = false) 
+    idx_base_rep *sort_uniq_clone (bool = false)
       { count++; return this; }
 
     idx_base_rep *sort_idx (Array<octave_idx_type>&);
 
     dim_vector orig_dimensions (void) const { return orig_dims; }
 
     bool is_colon_equiv (octave_idx_type n) const
       { return len == n && ext == n; }
 
     const bool *get_data (void) const { return data; }
 
     std::ostream& print (std::ostream& os) const;
 
     Array<bool> unconvert (void) const;
 
     Array<octave_idx_type> as_array (void);
-    
+
   private:
 
     DECLARE_OCTAVE_ALLOCATOR
 
     // No copying!
     idx_mask_rep (const idx_mask_rep& idx);
     idx_mask_rep& operator = (const idx_mask_rep& idx);
 
@@ -417,17 +417,17 @@ private:
     mutable octave_idx_type lste;
 
     // This is a trick to allow user-given mask arrays to be used as
     // indices without copying.  If the following pointer is nonzero, we
     // do not own the data, but rather have an Array<bool> object that
     // provides us the data.  Note that we need a pointer because we
     // deferred the Array<T> declaration and we do not want it yet to be
     // defined.
-    
+
     Array<bool> *aowner;
 
     dim_vector orig_dims;
   };
 
   idx_vector (idx_base_rep *r) : rep (r) { }
 
   // The shared empty vector representation (for fast default
@@ -460,37 +460,37 @@ private:
     }
 
 public:
 
   // Fast empty constructor.
   idx_vector (void) : rep (nil_rep ()) { rep->count++; }
 
   // Zero-based constructors (for use from C++).
-  idx_vector (octave_idx_type i) : rep (new idx_scalar_rep (i)) 
+  idx_vector (octave_idx_type i) : rep (new idx_scalar_rep (i))
     { chkerr (); }
 
   idx_vector (octave_idx_type start, octave_idx_type limit,
               octave_idx_type step = 1)
-    : rep (new idx_range_rep (start, limit, step)) 
+    : rep (new idx_range_rep (start, limit, step))
     { chkerr (); }
 
-  static idx_vector 
+  static idx_vector
     make_range (octave_idx_type start, octave_idx_type step,
                 octave_idx_type len)
     {
       return idx_vector (new idx_range_rep (start, len, step, DIRECT));
     }
 
-  idx_vector (const Array<octave_idx_type>& inda) 
+  idx_vector (const Array<octave_idx_type>& inda)
     : rep (new idx_vector_rep (inda))
     { chkerr (); }
 
   // Directly pass extent, no checking.
-  idx_vector (const Array<octave_idx_type>& inda, octave_idx_type ext) 
+  idx_vector (const Array<octave_idx_type>& inda, octave_idx_type ext)
     : rep (new idx_vector_rep (inda, ext, DIRECT))
     { }
 
   // Colon is best constructed by simply copying (or referencing) this member.
   static const idx_vector colon;
 
   // or passing ':' here
   idx_vector (char c) : rep (new idx_colon_rep (c)) { chkerr (); }
@@ -514,17 +514,17 @@ public:
   idx_vector (const Array<double>& nda) : rep (new idx_vector_rep (nda))
     { chkerr (); }
 
   idx_vector (const Array<float>& nda) : rep (new idx_vector_rep (nda))
     { chkerr (); }
 
   idx_vector (const Array<bool>& nda);
 
-  idx_vector (const Range& r) 
+  idx_vector (const Range& r)
     : rep (new idx_range_rep (r))
     { chkerr (); }
 
   idx_vector (const Sparse<bool>& nda) : rep (new idx_vector_rep (nda))
     { chkerr (); }
 
   idx_vector (const idx_vector& a) : rep (a.rep) { rep->count++; }
 
@@ -544,44 +544,44 @@ public:
           rep = a.rep;
           rep->count++;
         }
       return *this;
     }
 
   idx_class_type idx_class (void) const { return rep->idx_class (); }
 
-  octave_idx_type length (octave_idx_type n = 0) const 
+  octave_idx_type length (octave_idx_type n = 0) const
     { return rep->length (n); }
 
-  octave_idx_type extent (octave_idx_type n) const 
+  octave_idx_type extent (octave_idx_type n) const
     { return rep->extent (n); }
 
-  octave_idx_type xelem (octave_idx_type n) const 
+  octave_idx_type xelem (octave_idx_type n) const
     { return rep->xelem (n); }
 
-  octave_idx_type checkelem (octave_idx_type n) const 
+  octave_idx_type checkelem (octave_idx_type n) const
     { return rep->checkelem (n); }
 
-  octave_idx_type operator () (octave_idx_type n) const 
+  octave_idx_type operator () (octave_idx_type n) const
     {
 #if defined (BOUNDS_CHECKING)
-      return rep->checkelem (n); 
+      return rep->checkelem (n);
 #else
       return rep->xelem (n);
 #endif
     }
 
   operator bool (void) const
     { return ! rep->err; }
 
-  bool is_colon (void) const 
+  bool is_colon (void) const
     { return rep->idx_class () == class_colon; }
 
-  bool is_scalar (void) const 
+  bool is_scalar (void) const
     { return rep->idx_class () == class_scalar; }
 
   bool is_range (void) const
     { return rep->idx_class () == class_range; }
 
   bool is_colon_equiv (octave_idx_type n) const
     { return rep->is_colon_equiv (n); }
 
@@ -890,17 +890,17 @@ public:
 
   // Generic breakable indexed loop. The loop body should be
   // encapsulated in a single functor body.  This is equivalent to the
   // following loop (but faster, at least for simple inlined bodies):
   //
   // for (octave_idx_type i = 0; i < idx->length (n); i++)
   //   if (body (idx(i))) break;
   // return i;
-  // 
+  //
 
   template <class Functor>
   octave_idx_type
   bloop (octave_idx_type n, Functor body) const
     {
       octave_idx_type len = rep->length (n), ret;
 
       switch (rep->idx_class ())
@@ -968,17 +968,17 @@ public:
         default:
           assert (false);
           break;
         }
 
       return ret;
     }
 
-  // Rationale: 
+  // Rationale:
   // This method is the key to "smart indexing". When indexing cartesian
   // arrays, sometimes consecutive index vectors can be reduced into a
   // single index.  If rows (A) = k and i.maybe_reduce (j) gives k, then
   // A(i,j)(:) is equal to A(k)(:).
 
   // If the next index can be reduced, returns true and updates this.
   bool maybe_reduce (octave_idx_type n, const idx_vector& j,
                      octave_idx_type nj);
@@ -1002,45 +1002,45 @@ public:
   // Copies all the indices to a given array. Not allowed for colons.
   void copy_data (octave_idx_type *data) const;
 
   // If the index is a mask, convert it to index vector.
   idx_vector unmask (void) const;
 
   // Unconverts the index to a scalar, Range, double array or a mask.
   void unconvert (idx_class_type& iclass,
-                  double& scalar, Range& range, 
+                  double& scalar, Range& range,
                   Array<double>& array, Array<bool>& mask) const;
 
   Array<octave_idx_type> as_array (void) const;
 
   // Raw pointer to index array.  This is non-const because it may be
   // necessary to mutate the index.
   const octave_idx_type *raw (void);
 
   bool is_vector (void) const;
-    
+
   // FIXME -- these are here for compatibility.  They should be removed
   // when no longer in use.
 
-  octave_idx_type elem (octave_idx_type n) const 
+  octave_idx_type elem (octave_idx_type n) const
     { return (*this) (n); }
 
   bool is_colon_equiv (octave_idx_type n, int) const
     { return is_colon_equiv (n); }
 
   octave_idx_type
   freeze (octave_idx_type z_len, const char *tag, bool resize_ok = false);
 
   void sort (bool uniq = false)
     { *this = sorted (uniq); }
 
   octave_idx_type ones_count (void) const;
 
   octave_idx_type max (void) const { return extent (1) - 1; }
-  
+
 private:
 
   idx_base_rep *rep;
 
 };
 
 #endif
diff --git a/liboctave/intNDArray.cc b/liboctave/intNDArray.cc
--- a/liboctave/intNDArray.cc
+++ b/liboctave/intNDArray.cc
@@ -90,17 +90,17 @@ void
 intNDArray<T>::increment_index (Array<octave_idx_type>& ra_idx,
                                const dim_vector& dimensions,
                                int start_dimension)
 {
   ::increment_index (ra_idx, dimensions, start_dimension);
 }
 
 template <class T>
-octave_idx_type 
+octave_idx_type
 intNDArray<T>::compute_index (Array<octave_idx_type>& ra_idx,
                               const dim_vector& dimensions)
 {
   return ::compute_index (ra_idx, dimensions);
 }
 
 template <class T>
 intNDArray<T>
diff --git a/liboctave/intNDArray.h b/liboctave/intNDArray.h
--- a/liboctave/intNDArray.h
+++ b/liboctave/intNDArray.h
@@ -29,26 +29,26 @@ class NDArray;
 
 template <class T>
 class
 intNDArray : public MArray<T>
 {
 public:
 
   using MArray<T>::element_type;
-  
+
   intNDArray (void) : MArray<T> () { }
 
   intNDArray (T val) : MArray<T> (dim_vector (1, 1), val) { }
 
   intNDArray (const dim_vector& dv) : MArray<T> (dv) { }
-  
+
   intNDArray (const dim_vector& dv, T val)
     : MArray<T> (dv, val) { }
-  
+
   template <class U>
   intNDArray (const Array<U>& a) : MArray<T> (a) { }
 
   template <class U>
   intNDArray (const MArray<U>& a) : MArray<T> (a) { }
 
   template <class U>
   intNDArray (const intNDArray<U>& a) : MArray<T> (a) { }
@@ -61,37 +61,37 @@ public:
 
   boolNDArray operator ! (void) const;
 
   bool any_element_is_nan (void) const { return false; }
   bool any_element_not_one_or_zero (void) const;
 
   intNDArray diag (octave_idx_type k = 0) const;
 
-  intNDArray& changesign (void) 
-    { 
-      MArray<T>::changesign (); 
-      return *this; 
+  intNDArray& changesign (void)
+    {
+      MArray<T>::changesign ();
+      return *this;
     }
 
   // FIXME -- this is not quite the right thing.
 
   boolNDArray all (int dim = -1) const;
   boolNDArray any (int dim = -1) const;
 
   intNDArray max (int dim = -1) const;
   intNDArray max (Array<octave_idx_type>& index, int dim = -1) const;
   intNDArray min (int dim = -1) const;
   intNDArray min (Array<octave_idx_type>& index, int dim = -1) const;
-  
+
   intNDArray cummax (int dim = -1) const;
   intNDArray cummax (Array<octave_idx_type>& index, int dim = -1) const;
   intNDArray cummin (int dim = -1) const;
   intNDArray cummin (Array<octave_idx_type>& index, int dim = -1) const;
-  
+
   intNDArray sum (int dim) const;
   NDArray dsum (int dim) const;
   intNDArray cumsum (int dim) const;
 
   intNDArray diff (octave_idx_type order = 1, int dim = -1) const;
 
   intNDArray abs (void) const;
   intNDArray signum (void) const;
diff --git a/liboctave/kpse.cc b/liboctave/kpse.cc
--- a/liboctave/kpse.cc
+++ b/liboctave/kpse.cc
@@ -5,17 +5,17 @@
 
 Copyright (C) 1993, 94, 95, 96, 97, 98 Karl Berry.
 Copyright (C) 1993, 94, 95, 96, 97 Karl Berry & O. Weber.
 Copyright (C) 1992, 93, 94, 95, 96, 97 Free Software Foundation, Inc.
 
 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Library General Public
 License as published by the Free Software Foundation; either
-version 2 of the License, or (at your option) any later version. 
+version 2 of the License, or (at your option) any later version.
 
 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Library General Public License for more details.
 
 You should have received a copy of the GNU Library General Public
 License along with this library; if not, write to the Free Software
@@ -61,17 +61,17 @@ extern "C" {
 #include <io.h>         /* for `setmode' */
 #endif
 }
 
 /* Some drivers have partially integrated kpathsea changes.  */
 #ifndef KPATHSEA
 #define KPATHSEA 32
 #endif
- 
+
 /* System dependencies that are figured out by `configure'.  If we are
    compiling standalone, we get our c-auto.h.  Otherwise, the package
    containing us must provide this (unless it can somehow generate ours
    from c-auto.in).  We use <...> instead of "..." so that the current
    cpp directory (i.e., kpathsea/) won't be searched. */
 
 /* If you want to find subdirectories in a directory with non-Unix
    semantics (specifically, if a directory with no subdirectories does
@@ -107,20 +107,20 @@ extern "C" {
 #define DIR_SEP_STRING "/"
 #endif /* not DOSISH */
 #endif /* not DIR_SEP */
 
 #ifndef IS_DIR_SEP
 #define IS_DIR_SEP(ch) ((ch) == DIR_SEP)
 #endif
 #ifndef IS_DEVICE_SEP /* No `devices' on, e.g., Unix.  */
-#define IS_DEVICE_SEP(ch) 0 
+#define IS_DEVICE_SEP(ch) 0
 #endif
 #ifndef NAME_BEGINS_WITH_DEVICE
-#define NAME_BEGINS_WITH_DEVICE(name) 0 
+#define NAME_BEGINS_WITH_DEVICE(name) 0
 #endif
 
 #include "lo-error.h"
 #include "oct-env.h"
 #include "oct-passwd.h"
 #include "str-vec.h"
 
 /* Header files that essentially all of our sources need, and
@@ -911,29 +911,29 @@ search (const std::string& path, const s
   return ret_list;
 }
 
 /* Search PATH for the first NAME.  */
 
 /* Call `kpse_expand' on NAME.  If the result is an absolute or
    explicitly relative filename, check whether it is a readable
    (regular) file.
-   
+
    Otherwise, look in each of the directories specified in PATH (also do
    tilde and variable expansion on elements in PATH), using a prebuilt
    db (see db.h) if it's relevant for a given path element.
-   
+
    If the prebuilt db doesn't exist, or if MUST_EXIST is true and NAME
    isn't found in the prebuilt db, look on the filesystem.  (I.e., if
    MUST_EXIST is false, and NAME isn't found in the db, do *not* look on
    the filesystem.)
-   
+
    The caller must expand PATH. This is because it makes more sense to
    do this once, in advance, instead of for every search using it.
-   
+
    In any case, return the complete filename if found, otherwise NULL.  */
 
 static std::string
 kpse_path_search (const std::string& path, const std::string& name,
                   bool must_exist)
 {
   string_vector ret_list = search (path, name, must_exist, false);
 
@@ -2382,17 +2382,17 @@ expand_elt (str_llist_type *str_list_ptr
 }
 
 /* Here is the entry point.  Returns directory list for ELT.  */
 
 /* Given a path element ELT, return a pointer to a NULL-terminated list
    of the corresponding (existing) directory or directories, with
    trailing slashes, or NULL.  If ELT is the empty string, check the
    current working directory.
-   
+
    It's up to the caller to expand ELT.  This is because this routine is
    most likely only useful to be called from `kpse_path_search', which
    has already assumed expansion has been done.  */
 
 static str_llist_type *
 kpse_element_dirs (const std::string& elt)
 {
   str_llist_type *ret;
diff --git a/liboctave/lo-array-gripes.cc b/liboctave/lo-array-gripes.cc
--- a/liboctave/lo-array-gripes.cc
+++ b/liboctave/lo-array-gripes.cc
@@ -139,21 +139,21 @@ gripe_invalid_index (void)
 // Anyway, propagating various error messages into procedure is, IMHO,
 // a nonsense.  If anything, we should change error handling here (and
 // throughout liboctave) to allow custom handling of errors
 
 void
 gripe_invalid_resize (void)
 {
   (*current_liboctave_error_with_id_handler)
-    ("Octave:invalid-resize", 
+    ("Octave:invalid-resize",
      "Invalid resizing operation or ambiguous assignment to an out-of-bounds array element.");
 }
 
-void 
+void
 gripe_invalid_assignment_size (void)
 {
   (*current_liboctave_error_handler)
     ("A(I) = X: X must have the same size as I");
 }
 
 void
 gripe_assignment_dimension_mismatch (void)
diff --git a/liboctave/lo-array-gripes.h b/liboctave/lo-array-gripes.h
--- a/liboctave/lo-array-gripes.h
+++ b/liboctave/lo-array-gripes.h
@@ -47,21 +47,21 @@ gripe_nonconformant (const char *op,
                      octave_idx_type op2_nr, octave_idx_type op2_nc);
 
 
 extern void OCTAVE_API
 gripe_nonconformant (const char *op, const dim_vector& op1_dims,
                      const dim_vector& op2_dims);
 
 extern void OCTAVE_API
-gripe_index_out_of_range (int nd, int dim, 
+gripe_index_out_of_range (int nd, int dim,
                           octave_idx_type iext, octave_idx_type ext);
 
 extern void OCTAVE_API
-gripe_del_index_out_of_range (bool is1d, octave_idx_type iext, 
+gripe_del_index_out_of_range (bool is1d, octave_idx_type iext,
                               octave_idx_type ext);
 
 extern void OCTAVE_API
 gripe_invalid_index (void);
 
 extern void OCTAVE_API
 gripe_invalid_resize (void);
 
diff --git a/liboctave/lo-cieee.c b/liboctave/lo-cieee.c
--- a/liboctave/lo-cieee.c
+++ b/liboctave/lo-cieee.c
@@ -107,30 +107,30 @@ int
 }
 
 int
 __lo_ieee_is_NA (double x)
 {
 #if defined (HAVE_ISNAN)
   lo_ieee_double t;
   t.value = x;
-  return (isnan (x) && t.word[lo_ieee_hw] == LO_IEEE_NA_HW 
+  return (isnan (x) && t.word[lo_ieee_hw] == LO_IEEE_NA_HW
           && t.word[lo_ieee_lw] == LO_IEEE_NA_LW) ? 1 : 0;
 #else
   return 0;
 #endif
 }
 
 int
 __lo_ieee_is_old_NA (double x)
 {
 #if defined (HAVE_ISNAN)
   lo_ieee_double t;
   t.value = x;
-  return (isnan (x) && t.word[lo_ieee_lw] == LO_IEEE_NA_LW_OLD 
+  return (isnan (x) && t.word[lo_ieee_lw] == LO_IEEE_NA_LW_OLD
           && t.word[lo_ieee_hw] == LO_IEEE_NA_HW_OLD) ? 1 : 0;
 #else
   return 0;
 #endif
 }
 
 double
 __lo_ieee_replace_old_NA (double x)
diff --git a/liboctave/lo-ieee.h b/liboctave/lo-ieee.h
--- a/liboctave/lo-ieee.h
+++ b/liboctave/lo-ieee.h
@@ -63,17 +63,17 @@ typedef union
   unsigned int word;
 } lo_ieee_float;
 
 #define LO_IEEE_NA_HW_OLD 0x7ff00000
 #define LO_IEEE_NA_LW_OLD 1954
 #define LO_IEEE_NA_HW 0x7FF840F4
 #define LO_IEEE_NA_LW 0x40000000
 #define LO_IEEE_NA_FLOAT   0x7FC207A2
- 
+
 extern OCTAVE_API void octave_ieee_init (void);
 
 extern OCTAVE_API int __lo_ieee_isnan (double x);
 extern OCTAVE_API int __lo_ieee_finite (double x);
 extern OCTAVE_API int __lo_ieee_isinf (double x);
 
 extern OCTAVE_API int __lo_ieee_is_NA (double);
 extern OCTAVE_API int __lo_ieee_is_old_NA (double);
diff --git a/liboctave/lo-mappers.cc b/liboctave/lo-mappers.cc
--- a/liboctave/lo-mappers.cc
+++ b/liboctave/lo-mappers.cc
@@ -54,17 +54,17 @@ double xfloor (double x)
 }
 
 double
 xround (double x)
 {
   return gnulib::round (x);
 }
 
-double 
+double
 xroundb (double x)
 {
   double t = xround (x);
 
   if (fabs (x - t) == 0.5)
     t = 2 * xtrunc (0.5 * t);
 
   return t;
@@ -268,17 +268,17 @@ xtrunc (float x)
 }
 
 float
 xround (float x)
 {
   return gnulib::round (x);
 }
 
-float 
+float
 xroundb (float x)
 {
   float t = xround (x);
 
   if (fabsf (x - t) == 0.5)
     t = 2 * xtrunc (0.5 * t);
 
   return t;
diff --git a/liboctave/lo-mappers.h b/liboctave/lo-mappers.h
--- a/liboctave/lo-mappers.h
+++ b/liboctave/lo-mappers.h
@@ -24,31 +24,31 @@ along with Octave; see the file COPYING.
 #if !defined (octave_liboctave_mappers_h)
 #define octave_liboctave_mappers_h 1
 
 #include <limits>
 
 #include "oct-cmplx.h"
 #include "lo-math.h"
 
-// Double Precision 
+// Double Precision
 extern OCTAVE_API double xtrunc (double x);
 inline double xcopysign (double x, double y) { return copysign (x, y); }
 inline double xceil (double x) { return ceil (x); }
 extern OCTAVE_API double xfloor (double x);
 inline double arg (double x) { return atan2 (0.0, x); }
 inline double conj (double x) { return x; }
 inline double fix (double x) { return xtrunc (x); }
 inline double imag (double) { return 0.0; }
 inline double real (double x) { return x; }
 extern OCTAVE_API double xround (double x);
 extern OCTAVE_API double xroundb (double x);
 extern OCTAVE_API double signum (double x);
-extern OCTAVE_API double xlog2 (double x); 
-extern OCTAVE_API Complex xlog2 (const Complex& x); 
+extern OCTAVE_API double xlog2 (double x);
+extern OCTAVE_API Complex xlog2 (const Complex& x);
 extern OCTAVE_API double xlog2 (double x, int& exp);
 extern OCTAVE_API Complex xlog2 (const Complex& x, int& exp);
 extern OCTAVE_API double xexp2 (double x);
 
 // These are used by the BOOL_OP macros in mx-op-defs.h.
 inline bool xisnan (bool) { return false; }
 inline bool xisnan (char) { return false; }
 
@@ -110,31 +110,31 @@ extern OCTAVE_API Complex atan (const Co
 extern OCTAVE_API Complex atanh (const Complex& x);
 
 extern OCTAVE_API bool octave_is_NA (const Complex& x);
 extern OCTAVE_API bool octave_is_NaN_or_NA (const Complex& x);
 
 extern OCTAVE_API Complex xmin (const Complex& x, const Complex& y);
 extern OCTAVE_API Complex xmax (const Complex& x, const Complex& y);
 
-// Single Precision 
+// Single Precision
 extern OCTAVE_API float xtrunc (float x);
 inline float xcopysign (float x, float y) { return copysignf (x, y); }
 inline float xceil (float x) { return ceilf (x); }
 inline float xfloor (float x) { return floorf (x); }
 inline float arg (float x) { return atan2f (0.0f, x); }
 inline float conj (float x) { return x; }
 inline float fix (float x) { return xtrunc (x); }
 inline float imag (float) { return 0.0f; }
 inline float real (float x) { return x; }
 extern OCTAVE_API float xround (float x);
 extern OCTAVE_API float xroundb (float x);
 extern OCTAVE_API float signum (float x);
-extern OCTAVE_API float xlog2 (float x); 
-extern OCTAVE_API FloatComplex xlog2 (const FloatComplex& x); 
+extern OCTAVE_API float xlog2 (float x);
+extern OCTAVE_API FloatComplex xlog2 (const FloatComplex& x);
 extern OCTAVE_API float xlog2 (float x, int& exp);
 extern OCTAVE_API FloatComplex xlog2 (const FloatComplex& x, int& exp);
 extern OCTAVE_API float xexp2 (float x);
 
 #if defined (HAVE_CMATH_ISNANF)
 inline bool xisnan (float x)
 { return std::isnan (x); }
 #else
@@ -209,17 +209,17 @@ xisinteger (double x)
 }
 
 inline bool
 xisinteger (float x)
 {
   return xfinite (x) && x == xround (x);
 }
 
-// Test for negative sign. 
+// Test for negative sign.
 extern OCTAVE_API bool xnegative_sign (double x);
 extern OCTAVE_API bool xnegative_sign (float x);
 
 // Some old rounding functions.
 
 extern OCTAVE_API octave_idx_type NINTbig (double x);
 extern OCTAVE_API octave_idx_type NINTbig (float x);
 
diff --git a/liboctave/lo-specfun.cc b/liboctave/lo-specfun.cc
--- a/liboctave/lo-specfun.cc
+++ b/liboctave/lo-specfun.cc
@@ -328,17 +328,17 @@ xlgamma (double x)
 
 Complex
 rc_lgamma (double x)
 {
   double result;
 
 #if defined (HAVE_LGAMMA_R)
   int sgngam;
-  result = lgamma_r (x, &sgngam);    
+  result = lgamma_r (x, &sgngam);
 #else
   double sgngam;
 
   if (xisnan (x))
     result = x;
   else if ((x <= 0 && D_NINT (x) == x) || xisinf (x))
     result = octave_Inf;
   else
@@ -393,17 +393,17 @@ xlgamma (float x)
 
 FloatComplex
 rc_lgamma (float x)
 {
   float result;
 
 #if defined (HAVE_LGAMMAF_R)
   int sgngam;
-  result = lgammaf_r (x, &sgngam);    
+  result = lgammaf_r (x, &sgngam);
 #else
   float sgngam;
 
   if (xisnan (x))
     result = x;
   else if ((x <= 0 && D_NINT (x) == x) || xisinf (x))
     result = octave_Float_Inf;
   else
@@ -426,17 +426,17 @@ expm1 (double x)
   double ax = fabs (x);
 
   if (ax < 0.1)
     {
       ax /= 16;
 
       // use Taylor series to calculate exp(x)-1.
       double t = ax;
-      double s = 0; 
+      double s = 0;
       for (int i = 2; i < 7; i++)
         s += (t *= ax/i);
       s += ax;
 
       // use the identity (a+1)^2-1 = a*(a+2)
       double e = s;
       for (int i = 0; i < 4; i++)
         {
@@ -448,17 +448,17 @@ expm1 (double x)
     }
   else
     retval = exp (x) - 1;
 
   return retval;
 }
 #endif
 
-Complex 
+Complex
 expm1(const Complex& x)
 {
   Complex retval;
 
   if (std:: abs (x) < 1)
     {
       double im = x.imag();
       double u = expm1 (x.real ());
@@ -481,17 +481,17 @@ expm1f (float x)
   float ax = fabs (x);
 
   if (ax < 0.1)
     {
       ax /= 16;
 
       // use Taylor series to calculate exp(x)-1.
       float t = ax;
-      float s = 0; 
+      float s = 0;
       for (int i = 2; i < 7; i++)
         s += (t *= ax/i);
       s += ax;
 
       // use the identity (a+1)^2-1 = a*(a+2)
       float e = s;
       for (int i = 0; i < 4; i++)
         {
@@ -503,17 +503,17 @@ expm1f (float x)
     }
   else
     retval = exp (x) - 1;
 
   return retval;
 }
 #endif
 
-FloatComplex 
+FloatComplex
 expm1(const FloatComplex& x)
 {
   FloatComplex retval;
 
   if (std:: abs (x) < 1)
     {
       float im = x.imag();
       float u = expm1 (x.real ());
@@ -546,17 +546,17 @@ log1p (double x)
     }
   else
     retval = log (1 + x);
 
   return retval;
 }
 #endif
 
-Complex 
+Complex
 log1p (const Complex& x)
 {
   Complex retval;
 
   double r = x.real (), i = x.imag();
 
   if (fabs (r) < 0.5 && fabs (i) < 0.5)
     {
@@ -605,17 +605,17 @@ log1pf (float x)
     }
   else
     retval = log (1 + x);
 
   return retval;
 }
 #endif
 
-FloatComplex 
+FloatComplex
 log1p (const FloatComplex& x)
 {
   FloatComplex retval;
 
   float r = x.real (), i = x.imag();
 
   if (fabs (r) < 0.5 && fabs (i) < 0.5)
     {
@@ -710,32 +710,32 @@ zbesj (const Complex& z, double alpha, i
 
       double zr = z.real ();
       double zi = z.imag ();
 
       F77_FUNC (zbesj, ZBESJ) (zr, zi, alpha, 2, 1, &yr, &yi, nz, ierr);
 
       if (kode != 2)
         {
-          double expz = exp (std::abs (zi)); 
+          double expz = exp (std::abs (zi));
           yr *= expz;
           yi *= expz;
         }
 
       if (zi == 0.0 && zr >= 0.0)
         yi = 0.0;
 
       retval = bessel_return_value (Complex (yr, yi), ierr);
     }
   else if (is_integer_value (alpha))
     {
       // zbesy can overflow as z->0, and cause troubles for generic case below
       alpha = -alpha;
       Complex tmp = zbesj (z, alpha, kode, ierr);
-      if ((static_cast <long> (alpha)) & 1) 
+      if ((static_cast <long> (alpha)) & 1)
         tmp = - tmp;
       retval = bessel_return_value (tmp, ierr);
     }
   else
     {
       alpha = -alpha;
 
       Complex tmp = cos (M_PI * alpha) * zbesj (z, alpha, kode, ierr);
@@ -795,17 +795,17 @@ zbesy (const Complex& z, double alpha, i
 
       return bessel_return_value (Complex (yr, yi), ierr);
     }
   else if (is_integer_value (alpha - 0.5))
     {
       // zbesy can overflow as z->0, and cause troubles for generic case below
       alpha = -alpha;
       Complex tmp = zbesj (z, alpha, kode, ierr);
-      if ((static_cast <long> (alpha - 0.5)) & 1) 
+      if ((static_cast <long> (alpha - 0.5)) & 1)
         tmp = - tmp;
       retval = bessel_return_value (tmp, ierr);
     }
   else
     {
       alpha = -alpha;
 
       Complex tmp = cos (M_PI * alpha) * zbesy (z, alpha, kode, ierr);
@@ -857,23 +857,23 @@ zbesi (const Complex& z, double alpha, i
       alpha = -alpha;
 
       Complex tmp = zbesi (z, alpha, kode, ierr);
 
       if (ierr == 0 || ierr == 3)
         {
           Complex tmp2 = (2.0 / M_PI) * sin (M_PI * alpha)
             * zbesk (z, alpha, kode, ierr);
-        
-          if (kode == 2) 
+
+          if (kode == 2)
             {
               // Compensate for different scaling factor of besk.
               tmp2 *= exp(-z - std::abs(z.real()));
             }
-          
+
           tmp += tmp2;
 
           retval = bessel_return_value (tmp, ierr);
         }
       else
         retval = Complex (octave_NaN, octave_NaN);
     }
 
@@ -1347,17 +1347,17 @@ cbesj (const FloatComplex& z, float alph
 
       retval = bessel_return_value (y, ierr);
     }
   else if (is_integer_value (alpha))
     {
       // zbesy can overflow as z->0, and cause troubles for generic case below
       alpha = -alpha;
       FloatComplex tmp = cbesj (z, alpha, kode, ierr);
-      if ((static_cast <long> (alpha)) & 1) 
+      if ((static_cast <long> (alpha)) & 1)
         tmp = - tmp;
       retval = bessel_return_value (tmp, ierr);
     }
   else
     {
       alpha = -alpha;
 
       FloatComplex tmp = cosf (static_cast<float> (M_PI) * alpha) * cbesj (z, alpha, kode, ierr);
@@ -1410,17 +1410,17 @@ cbesy (const FloatComplex& z, float alph
 
       return bessel_return_value (y, ierr);
     }
   else if (is_integer_value (alpha - 0.5))
     {
       // zbesy can overflow as z->0, and cause troubles for generic case below
       alpha = -alpha;
       FloatComplex tmp = cbesj (z, alpha, kode, ierr);
-      if ((static_cast <long> (alpha - 0.5)) & 1) 
+      if ((static_cast <long> (alpha - 0.5)) & 1)
         tmp = - tmp;
       retval = bessel_return_value (tmp, ierr);
     }
   else
     {
       alpha = -alpha;
 
       FloatComplex tmp = cosf (static_cast<float> (M_PI) * alpha) * cbesy (z, alpha, kode, ierr);
@@ -1467,18 +1467,18 @@ cbesi (const FloatComplex& z, float alph
       alpha = -alpha;
 
       FloatComplex tmp = cbesi (z, alpha, kode, ierr);
 
       if (ierr == 0 || ierr == 3)
         {
           FloatComplex tmp2 = static_cast<float> (2.0 / M_PI) * sinf (static_cast<float> (M_PI) * alpha)
             * cbesk (z, alpha, kode, ierr);
-          
-          if (kode == 2) 
+
+          if (kode == 2)
             {
               // Compensate for different scaling factor of besk.
               tmp2 *= exp(-z - std::abs(z.real()));
             }
 
           tmp += tmp2;
 
           retval = bessel_return_value (tmp, ierr);
@@ -2254,17 +2254,17 @@ betainc (double x, const NDArray& a, con
 
       retval.resize (dv);
 
       for (octave_idx_type i = 0; i < nel; i++)
         retval (i) = betainc (x, a(i), b(i));
     }
   else
     gripe_betainc_nonconformant (dim_vector (0, 0), dv, b.dims ());
-  
+
   return retval;
 }
 
 
 Matrix
 betainc (const Matrix& x, double a, double b)
 {
   octave_idx_type nr = x.rows ();
@@ -2383,17 +2383,17 @@ betainc (const NDArray& x, double a, con
 
       retval.resize (dv);
 
       for (octave_idx_type i = 0; i < nel; i++)
         retval (i) = betainc (x(i), a, b(i));
     }
   else
     gripe_betainc_nonconformant (dv, dim_vector (0, 0), b.dims ());
-  
+
   return retval;
 }
 
 NDArray
 betainc (const NDArray& x, const NDArray& a, double b)
 {
   NDArray retval;
   dim_vector dv = x.dims ();
@@ -2404,17 +2404,17 @@ betainc (const NDArray& x, const NDArray
 
       retval.resize (dv);
 
       for (octave_idx_type i = 0; i < nel; i++)
         retval (i) = betainc (x(i), a(i), b);
     }
   else
     gripe_betainc_nonconformant (dv, a.dims (), dim_vector (0, 0));
-  
+
   return retval;
 }
 
 NDArray
 betainc (const NDArray& x, const NDArray& a, const NDArray& b)
 {
   NDArray retval;
   dim_vector dv = x.dims ();
@@ -2537,17 +2537,17 @@ betainc (float x, const FloatNDArray& a,
 
       retval.resize (dv);
 
       for (octave_idx_type i = 0; i < nel; i++)
         retval (i) = betainc (x, a(i), b(i));
     }
   else
     gripe_betainc_nonconformant (dim_vector (0, 0), dv, b.dims ());
-  
+
   return retval;
 }
 
 
 FloatMatrix
 betainc (const FloatMatrix& x, float a, float b)
 {
   octave_idx_type nr = x.rows ();
@@ -2666,17 +2666,17 @@ betainc (const FloatNDArray& x, float a,
 
       retval.resize (dv);
 
       for (octave_idx_type i = 0; i < nel; i++)
         retval (i) = betainc (x(i), a, b(i));
     }
   else
     gripe_betainc_nonconformant (dv, dim_vector (0, 0), b.dims ());
-  
+
   return retval;
 }
 
 FloatNDArray
 betainc (const FloatNDArray& x, const FloatNDArray& a, float b)
 {
   FloatNDArray retval;
   dim_vector dv = x.dims ();
@@ -2687,17 +2687,17 @@ betainc (const FloatNDArray& x, const Fl
 
       retval.resize (dv);
 
       for (octave_idx_type i = 0; i < nel; i++)
         retval (i) = betainc (x(i), a(i), b);
     }
   else
     gripe_betainc_nonconformant (dv, a.dims (), dim_vector (0, 0));
-  
+
   return retval;
 }
 
 FloatNDArray
 betainc (const FloatNDArray& x, const FloatNDArray& a, const FloatNDArray& b)
 {
   FloatNDArray retval;
   dim_vector dv = x.dims ();
@@ -2897,17 +2897,17 @@ gammainc (const NDArray& x, const NDArra
     {
       result.resize (dv);
 
       bool err;
 
       for (octave_idx_type i = 0; i < nel; i++)
         {
           result (i) = gammainc (x(i), a(i), err);
-          
+
           if (err)
             goto done;
         }
 
       retval = result;
     }
   else
     {
@@ -3102,17 +3102,17 @@ gammainc (const FloatNDArray& x, const F
     {
       result.resize (dv);
 
       bool err;
 
       for (octave_idx_type i = 0; i < nel; i++)
         {
           result (i) = gammainc (x(i), a(i), err);
-          
+
           if (err)
             goto done;
         }
 
       retval = result;
     }
   else
     {
@@ -3147,29 +3147,29 @@ FloatComplex rc_log1p (float x)
 // The rational approximation has relative accuracy 1.15e-9 in the whole region.
 // For doubles, it is refined by a single step of Higham's 3rd order method.
 // For single precision, the accuracy is already OK, so we skip it to get
 // faster evaluation.
 
 static double do_erfinv (double x, bool refine)
 {
   // Coefficients of rational approximation.
-  static const double a[] = 
+  static const double a[] =
     { -2.806989788730439e+01,  1.562324844726888e+02,
       -1.951109208597547e+02,  9.783370457507161e+01,
       -2.168328665628878e+01,  1.772453852905383e+00 };
-  static const double b[] = 
+  static const double b[] =
     { -5.447609879822406e+01,  1.615858368580409e+02,
       -1.556989798598866e+02,  6.680131188771972e+01,
       -1.328068155288572e+01 };
-  static const double c[] = 
+  static const double c[] =
     { -5.504751339936943e-03, -2.279687217114118e-01,
       -1.697592457770869e+00, -1.802933168781950e+00,
        3.093354679843505e+00,  2.077595676404383e+00 };
-  static const double d[] = 
+  static const double d[] =
     {  7.784695709041462e-03,  3.224671290700398e-01,
        2.445134137142996e+00,  3.754408661907416e+00 };
 
   static const double spi2 =  8.862269254527579e-01; // sqrt(pi)/2.
   static const double pbreak = 0.95150;
   double ax = fabs (x), y;
 
   // Select case.
@@ -3206,55 +3206,55 @@ static double do_erfinv (double x, bool 
 
 double erfinv (double x)
 {
   return do_erfinv (x, true);
 }
 
 float erfinv (float x)
 {
-  return do_erfinv (x, false); 
+  return do_erfinv (x, false);
 }
 
 // Implementation based on the Fortran code by W.J.Cody
 // see http://www.netlib.org/specfun/erf.
 // Templatized and simplified workflow.
 
 // FIXME: Maybe this should be globally visible.
 static inline float erfc (float x) { return erfcf (x); }
 
 template <class T>
-static T 
+static T
 erfcx_impl (T x)
 {
-  static const T c[] = 
-    { 
+  static const T c[] =
+    {
       5.64188496988670089e-1,8.88314979438837594,
       6.61191906371416295e+1,2.98635138197400131e+2,
       8.81952221241769090e+2,1.71204761263407058e+3,
       2.05107837782607147e+3,1.23033935479799725e+3,
-      2.15311535474403846e-8 
+      2.15311535474403846e-8
     };
 
-  static const T d[] = 
-    { 
+  static const T d[] =
+    {
       1.57449261107098347e+1,1.17693950891312499e+2,
       5.37181101862009858e+2,1.62138957456669019e+3,
       3.29079923573345963e+3,4.36261909014324716e+3,
       3.43936767414372164e+3,1.23033935480374942e+3
     };
 
-  static const T p[] = 
+  static const T p[] =
     {
       3.05326634961232344e-1,3.60344899949804439e-1,
       1.25781726111229246e-1,1.60837851487422766e-2,
       6.58749161529837803e-4,1.63153871373020978e-2
     };
 
-  static const T q[] = 
+  static const T q[] =
     {
       2.56852019228982242,1.87295284992346047,
       5.27905102951428412e-1,6.05183413124413191e-2,
       2.33520497626869185e-3
     };
 
   static const T sqrpi = 5.6418958354775628695e-1;
   static const T xhuge = sqrt (1.0 / std::numeric_limits<T>::epsilon ());
diff --git a/liboctave/mx-defs.h b/liboctave/mx-defs.h
--- a/liboctave/mx-defs.h
+++ b/liboctave/mx-defs.h
@@ -127,17 +127,17 @@ typedef FloatComplex (*fc_fc_Mapper)(con
 
 enum blas_trans_type
 {
   blas_no_trans = 'N',
   blas_trans = 'T',
   blas_conj_trans = 'C'
 };
 
-inline char 
+inline char
 get_blas_char (blas_trans_type transt)
 {
   return static_cast<char> (transt);
 }
 
 
 #endif
 
diff --git a/liboctave/mx-inlines.cc b/liboctave/mx-inlines.cc
--- a/liboctave/mx-inlines.cc
+++ b/liboctave/mx-inlines.cc
@@ -109,19 +109,19 @@ DEFMXCMPOP (mx_inline_lt, <)
 DEFMXCMPOP (mx_inline_le, <=)
 DEFMXCMPOP (mx_inline_gt, >)
 DEFMXCMPOP (mx_inline_ge, >=)
 DEFMXCMPOP (mx_inline_eq, ==)
 DEFMXCMPOP (mx_inline_ne, !=)
 
 // Convert to logical value, for logical op purposes.
 template <class T> inline bool logical_value (T x) { return x; }
-template <class T> inline bool logical_value (const std::complex<T>& x) 
+template <class T> inline bool logical_value (const std::complex<T>& x)
 { return x.real () != 0 || x.imag () != 0; }
-template <class T> inline bool logical_value (const octave_int<T>& x) 
+template <class T> inline bool logical_value (const octave_int<T>& x)
 { return x.value (); }
 
 template <class X>
 void mx_inline_not (size_t n, bool *r, const X* x) throw ()
 {
   for (size_t i = 0; i < n; i++)
     r[i] = ! logical_value (x[i]);
 }
@@ -166,18 +166,18 @@ inline void F (size_t n, bool *r, const 
 { \
   for (size_t i = 0; i < n; i++) \
     r[i] OP logical_value (x[i]); \
 } \
 
 DEFMXBOOLOPEQ (mx_inline_and2, &=)
 DEFMXBOOLOPEQ (mx_inline_or2, |=)
 
-template <class T> 
-inline bool 
+template <class T>
+inline bool
 mx_inline_any_nan (size_t n, const T* x)  throw ()
 {
   for (size_t i = 0; i < n; i++)
     {
       if (xisnan (x[i]))
         return true;
     }
 
@@ -192,31 +192,31 @@ mx_inline_all_finite (size_t n, const T*
     {
       if (! xfinite (x[i]))
         return false;
     }
 
   return true;
 }
 
-template <class T> 
-inline bool 
-mx_inline_any_negative (size_t n, const T* x) throw () 
+template <class T>
+inline bool
+mx_inline_any_negative (size_t n, const T* x) throw ()
 {
   for (size_t i = 0; i < n; i++)
     {
       if (x[i] < 0)
         return true;
     }
 
   return false;
 }
 
 template<class T>
-inline bool 
+inline bool
 mx_inline_all_real (size_t n, const std::complex<T>* x) throw ()
 {
   for (size_t i = 0; i < n; i++)
     {
       if (x[i].imag () != 0)
         return false;
     }
 
@@ -264,20 +264,20 @@ template <> \
 inline void F<T> (size_t n, T *r, T x, const T *y) throw () \
 { \
   if (xisnan (x)) \
     std::memcpy (r, y, n * sizeof (T)); \
   else \
     for (size_t i = 0; i < n; i++) r[i] = (y[i] OP x) ? y[i] : x; \
 }
 
-DEFMINMAXSPEC (double, mx_inline_xmin, <=) 
-DEFMINMAXSPEC (double, mx_inline_xmax, >=) 
-DEFMINMAXSPEC (float, mx_inline_xmin, <=) 
-DEFMINMAXSPEC (float, mx_inline_xmax, >=) 
+DEFMINMAXSPEC (double, mx_inline_xmin, <=)
+DEFMINMAXSPEC (double, mx_inline_xmax, >=)
+DEFMINMAXSPEC (float, mx_inline_xmin, <=)
+DEFMINMAXSPEC (float, mx_inline_xmax, >=)
 
 // Pairwise power
 #define DEFMXMAPPER2X(F, FUN) \
 template <class R, class X, class Y> \
 inline void F (size_t n, R *r, const X *x, const Y *y) throw () \
 { for (size_t i = 0; i < n; i++) r[i] = FUN (x[i], y[i]); } \
 template <class R, class X, class Y> \
 inline void F (size_t n, R *r, const X *x, Y y) throw () \
@@ -297,53 +297,53 @@ inline void mx_inline_map (size_t n, R *
 template <class R, class X, R fun (const X& x)>
 inline void mx_inline_map (size_t n, R *r, const X *x) throw ()
 { for (size_t i = 0; i < n; i++) r[i] = fun (x[i]); }
 
 // Appliers. Since these call the operation just once, we pass it as
 // a pointer, to allow the compiler reduce number of instances.
 
 template <class R, class X>
-inline Array<R> 
+inline Array<R>
 do_mx_unary_op (const Array<X>& x,
                 void (*op) (size_t, R *, const X *) throw ())
 {
   Array<R> r (x.dims ());
   op (r.numel (), r.fortran_vec (), x.data ());
   return r;
 }
 
 // Shortcuts for applying mx_inline_map.
 
 template <class R, class X, R fun (X)>
-inline Array<R> 
+inline Array<R>
 do_mx_unary_map (const Array<X>& x)
 {
   return do_mx_unary_op<R, X> (x, mx_inline_map<R, X, fun>);
 }
 
 template <class R, class X, R fun (const X&)>
-inline Array<R> 
+inline Array<R>
 do_mx_unary_map (const Array<X>& x)
 {
   return do_mx_unary_op<R, X> (x, mx_inline_map<R, X, fun>);
 }
 
 template <class R>
 inline Array<R>&
 do_mx_inplace_op (Array<R>& r,
                   void (*op) (size_t, R *) throw ())
 {
   op (r.numel (), r.fortran_vec ());
   return r;
 }
 
 
 template <class R, class X, class Y>
-inline Array<R> 
+inline Array<R>
 do_mm_binary_op (const Array<X>& x, const Array<Y>& y,
                  void (*op) (size_t, R *, const X *, const Y *) throw (),
                  const char *opname)
 {
   dim_vector dx = x.dims (), dy = y.dims ();
   if (dx == dy)
     {
       Array<R> r (dx);
@@ -353,51 +353,51 @@ do_mm_binary_op (const Array<X>& x, cons
   else
     {
       gripe_nonconformant (opname, dx, dy);
       return Array<R> ();
     }
 }
 
 template <class R, class X, class Y>
-inline Array<R> 
+inline Array<R>
 do_ms_binary_op (const Array<X>& x, const Y& y,
                  void (*op) (size_t, R *, const X *, Y) throw ())
 {
   Array<R> r (x.dims ());
   op (r.length (), r.fortran_vec (), x.data (), y);
   return r;
 }
 
 template <class R, class X, class Y>
-inline Array<R> 
+inline Array<R>
 do_sm_binary_op (const X& x, const Array<Y>& y,
                  void (*op) (size_t, R *, X, const Y *) throw ())
 {
   Array<R> r (y.dims ());
   op (r.length (), r.fortran_vec (), x, y.data ());
   return r;
 }
 
 template <class R, class X>
-inline Array<R>& 
+inline Array<R>&
 do_mm_inplace_op (Array<R>& r, const Array<X>& x,
                   void (*op) (size_t, R *, const X *) throw (),
                   const char *opname)
 {
   dim_vector dr = r.dims (), dx = x.dims ();
   if (dr == dx)
     op (r.length (), r.fortran_vec (), x.data ());
   else
     gripe_nonconformant (opname, dr, dx);
   return r;
 }
 
 template <class R, class X>
-inline Array<R>& 
+inline Array<R>&
 do_ms_inplace_op (Array<R>& r, const X& x,
                   void (*op) (size_t, R *, X) throw ())
 {
   op (r.length (), r.fortran_vec (), x);
   return r;
 }
 
 template <class T1, class T2>
@@ -407,26 +407,26 @@ mx_inline_equal (size_t n, const T1 *x, 
   for (size_t i = 0; i < n; i++)
     if (x[i] != y[i])
       return false;
   return true;
 }
 
 template <class T>
 inline bool
-do_mx_check (const Array<T>& a, 
+do_mx_check (const Array<T>& a,
              bool (*op) (size_t, const T *) throw ())
 {
   return op (a.numel (), a.data ());
 }
 
 // NOTE: we don't use std::norm because it typically does some heavyweight
 // magic to avoid underflows, which we don't need here.
 template <class T>
-inline T cabsq (const std::complex<T>& c) 
+inline T cabsq (const std::complex<T>& c)
 { return c.real () * c.real () + c.imag () * c.imag (); }
 
 // default. works for integers and bool.
 template <class T>
 inline bool xis_true (T x) { return x; }
 template <class T>
 inline bool xis_false (T x) { return ! x; }
 // for octave_ints
@@ -1034,17 +1034,17 @@ void mx_inline_diff (const T *v, T *r, o
 
           for (octave_idx_type i = 0; i < n-order; i++)
             r[i] = buf[i];
         }
     }
 }
 
 template <class T>
-void mx_inline_diff (const T *v, T *r, 
+void mx_inline_diff (const T *v, T *r,
                      octave_idx_type m, octave_idx_type n,
                      octave_idx_type order)
 {
   switch (order)
     {
     case 1:
       for (octave_idx_type i = 0; i < m*(n-1); i++)
         r[i] = v[i+m] - v[i];
@@ -1120,31 +1120,31 @@ get_extent_triplet (const dim_vector& di
     }
   else
     {
       if (dim < 0)
         dim = dims.first_non_singleton ();
 
       // calculate extent triplet.
       l = 1, n = dims(dim), u = 1;
-      for (octave_idx_type i = 0; i < dim; i++) 
+      for (octave_idx_type i = 0; i < dim; i++)
         l *= dims (i);
       for (octave_idx_type i = dim + 1; i < ndims; i++)
         u *= dims (i);
     }
 }
 
 // Appliers.
 // FIXME: is this the best design? C++ gives a lot of options here...
 // maybe it can be done without an explicit parameter?
 
 template <class R, class T>
 inline Array<R>
 do_mx_red_op (const Array<T>& src, int dim,
-              void (*mx_red_op) (const T *, R *, octave_idx_type, 
+              void (*mx_red_op) (const T *, R *, octave_idx_type,
                                  octave_idx_type, octave_idx_type))
 {
   octave_idx_type l, n, u;
   dim_vector dims = src.dims ();
   // M*b inconsistency: sum([]) = 0 etc.
   if (dims.length () == 2 && dims(0) == 0 && dims(1) == 0)
     dims (1) = 1;
 
@@ -1158,34 +1158,34 @@ do_mx_red_op (const Array<T>& src, int d
   mx_red_op (src.data (), ret.fortran_vec (), l, n, u);
 
   return ret;
 }
 
 template <class R, class T>
 inline Array<R>
 do_mx_cum_op (const Array<T>& src, int dim,
-              void (*mx_cum_op) (const T *, R *, octave_idx_type, 
+              void (*mx_cum_op) (const T *, R *, octave_idx_type,
                                  octave_idx_type, octave_idx_type))
 {
   octave_idx_type l, n, u;
   dim_vector dims = src.dims ();
   get_extent_triplet (dims, dim, l, n, u);
 
   // Cumulative operation doesn't reduce the array size.
   Array<R> ret (dims);
   mx_cum_op (src.data (), ret.fortran_vec (), l, n, u);
 
   return ret;
 }
 
 template <class R>
 inline Array<R>
 do_mx_minmax_op (const Array<R>& src, int dim,
-                 void (*mx_minmax_op) (const R *, R *, octave_idx_type, 
+                 void (*mx_minmax_op) (const R *, R *, octave_idx_type,
                                        octave_idx_type, octave_idx_type))
 {
   octave_idx_type l, n, u;
   dim_vector dims = src.dims ();
   get_extent_triplet (dims, dim, l, n, u);
 
   // If the dimension is zero, we don't do anything.
   if (dim < dims.length () && dims(dim) != 0) dims(dim) = 1;
@@ -1218,17 +1218,17 @@ do_mx_minmax_op (const Array<R>& src, Ar
                 l, n, u);
 
   return ret;
 }
 
 template <class R>
 inline Array<R>
 do_mx_cumminmax_op (const Array<R>& src, int dim,
-                    void (*mx_cumminmax_op) (const R *, R *, octave_idx_type, 
+                    void (*mx_cumminmax_op) (const R *, R *, octave_idx_type,
                                              octave_idx_type, octave_idx_type))
 {
   octave_idx_type l, n, u;
   dim_vector dims = src.dims ();
   get_extent_triplet (dims, dim, l, n, u);
 
   Array<R> ret (dims);
   mx_cumminmax_op (src.data (), ret.fortran_vec (), l, n, u);
@@ -1289,38 +1289,38 @@ do_mx_diff_op (const Array<R>& src, int 
 }
 
 // Fast extra-precise summation. According to
 // T. Ogita, S. M. Rump, S. Oishi:
 // Accurate Sum And Dot Product,
 // SIAM J. Sci. Computing, Vol. 26, 2005
 
 template <class T>
-inline void twosum_accum (T& s, T& e, 
+inline void twosum_accum (T& s, T& e,
                           const T& x)
 {
   T s1 = s + x, t = s1 - s, e1 = (s - (s1 - t)) + (x - t);
   s = s1;
   e += e1;
 }
 
 template <class T>
 inline T
-mx_inline_xsum (const T *v, octave_idx_type n) 
+mx_inline_xsum (const T *v, octave_idx_type n)
 {
   T s = 0, e = 0;
   for (octave_idx_type i = 0; i < n; i++)
     twosum_accum (s, e, v[i]);
 
   return s + e;
 }
 
 template <class T>
 inline void
-mx_inline_xsum (const T *v, T *r, 
+mx_inline_xsum (const T *v, T *r,
                 octave_idx_type m, octave_idx_type n)
 {
   OCTAVE_LOCAL_BUFFER (T, e, m);
   for (octave_idx_type i = 0; i < m; i++)
     e[i] = r[i] = T ();
 
   for (octave_idx_type j = 0; j < n; j++)
     {
diff --git a/liboctave/oct-binmap.h b/liboctave/oct-binmap.h
--- a/liboctave/oct-binmap.h
+++ b/liboctave/oct-binmap.h
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 // The syntax is binmap<type> (a, b, f, [name]). type denotes the expected
 // return type of the operation. a, b, should be one of the 6 combinations:
 // Array-Array
 // Array-scalar
 // scalar-Array
 // Sparse-Sparse
 // Sparse-scalar
 // scalar-Sparse
-// 
+//
 // If both operands are nonscalar, name must be supplied. It is used as the base for error message
 // when operands are nonconforming.
 //
 // The operation needs not be homogeneous, i.e. a, b and the result may be of distinct types.
 // f can have any of the four signatures:
 // U f (T, R)
 // U f (const T&, R)
 // U f (T, const R&)
diff --git a/liboctave/oct-convn.cc b/liboctave/oct-convn.cc
--- a/liboctave/oct-convn.cc
+++ b/liboctave/oct-convn.cc
@@ -29,17 +29,17 @@ along with Octave; see the file COPYING.
 
 #include "f77-fcn.h"
 
 #include "oct-convn.h"
 #include "oct-locbuf.h"
 
 // 2d convolution with a matrix kernel.
 template <class T, class R>
-static void 
+static void
 convolve_2d (const T *a, octave_idx_type ma, octave_idx_type na,
              const R *b, octave_idx_type mb, octave_idx_type nb,
              T *c, bool inner);
 
 // Forward instances to our Fortran implementations.
 #define FORWARD_IMPL(T,R,f,F) \
 extern "C" \
 F77_RET_T \
@@ -96,17 +96,17 @@ void convolve_nd (const T *a, const dim_
           for (octave_idx_type ja = 0; ja < na; ja++)
             for (octave_idx_type jb = 0; jb < nb; jb++)
               convolve_nd<T, R> (a + ma*ja, ad, acd, b + mb*jb, bd, bcd,
                                  c + ldc*(ja+jb), ccd, nd-1, inner);
         }
     }
 }
 
-// Arbitrary convolutor. 
+// Arbitrary convolutor.
 // The 2nd array is assumed to be the smaller one.
 template <class T, class R>
 static MArray<T>
 convolve (const MArray<T>& a, const MArray<R>& b,
           convn_type ct)
 {
   if (a.is_empty () || b.is_empty ())
     return MArray<T> ();
diff --git a/liboctave/oct-env.cc b/liboctave/oct-env.cc
--- a/liboctave/oct-env.cc
+++ b/liboctave/oct-env.cc
@@ -29,17 +29,17 @@ Free Software Foundation, Inc.
   octave_env::do_absolute_pathname
   octave_env::do_base_pathname
   octave_env::do_chdir
   octave_env::do_getcwd
   octave_env::do_make_absolute
   octave_env::do_polite_directory_format
   octave_env::pathname_backup
 
-*/ 
+*/
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cctype>
 #include <cstdlib>
 #include <cstring>
diff --git a/liboctave/oct-fftw.cc b/liboctave/oct-fftw.cc
--- a/liboctave/oct-fftw.cc
+++ b/liboctave/oct-fftw.cc
@@ -59,17 +59,17 @@ octave_fftw_planner::octave_fftw_planner
   : meth (ESTIMATE), rplan (0), rd (0), rs (0), rr (0), rh (0), rn (),
     rsimd_align (false)
 {
   plan[0] = plan[1] = 0;
   d[0] = d[1] = s[0] = s[1] = r[0] = r[1] = h[0] = h[1] = 0;
   simd_align[0] = simd_align[1] = false;
   inplace[0] = inplace[1] = false;
   n[0] = n[1] = dim_vector ();
-  
+
   // If we have a system wide wisdom file, import it.
   fftw_import_system_wisdom ();
 }
 
 bool
 octave_fftw_planner::instance_ok (void)
 {
   bool retval = true;
@@ -91,31 +91,31 @@ octave_fftw_planner::instance_ok (void)
 #define CHECK_SIMD_ALIGNMENT(x) \
   (((reinterpret_cast<ptrdiff_t> (x)) & 0xF) == 0)
 
 fftw_plan
 octave_fftw_planner::do_create_plan (int dir, const int rank,
                                      const dim_vector dims,
                                      octave_idx_type howmany,
                                      octave_idx_type stride,
-                                     octave_idx_type dist, 
+                                     octave_idx_type dist,
                                      const Complex *in, Complex *out)
 {
   int which = (dir == FFTW_FORWARD) ? 0 : 1;
   fftw_plan *cur_plan_p = &plan[which];
   bool create_new_plan = false;
   bool ioalign = CHECK_SIMD_ALIGNMENT (in) && CHECK_SIMD_ALIGNMENT (out);
   bool ioinplace = (in == out);
 
   // Don't create a new plan if we have a non SIMD plan already but
   // can do SIMD.  This prevents endlessly recreating plans if we
   // change the alignment.
 
   if (plan[which] == 0 || d[which] != dist || s[which] != stride
-      || r[which] != rank || h[which] != howmany 
+      || r[which] != rank || h[which] != howmany
       || ioinplace != inplace[which]
       || ((ioalign != simd_align[which]) ? !ioalign : false))
     create_new_plan = true;
   else
     {
       // We still might not have the same shape of array.
 
       for (int i = 0; i < rank; i++)
@@ -144,17 +144,17 @@ octave_fftw_planner::do_create_plan (int
         {
           tmp[i] = dims(j);
           nn *= dims(j);
         }
 
       int plan_flags = 0;
       bool plan_destroys_in = true;
 
-      switch (meth) 
+      switch (meth)
         {
         case UNKNOWN:
         case ESTIMATE:
           plan_flags |= FFTW_ESTIMATE;
           plan_destroys_in = false;
           break;
         case MEASURE:
           plan_flags |= FFTW_MEASURE;
@@ -184,17 +184,17 @@ octave_fftw_planner::do_create_plan (int
       if (*cur_plan_p)
         fftw_destroy_plan (*cur_plan_p);
 
       if (plan_destroys_in)
         {
           // Create matrix with the same size and 16-byte alignment as input
           OCTAVE_LOCAL_BUFFER (Complex, itmp, nn * howmany + 32);
           itmp = reinterpret_cast<Complex *>
-            (((reinterpret_cast<ptrdiff_t>(itmp) + 15) & ~ 0xF) + 
+            (((reinterpret_cast<ptrdiff_t>(itmp) + 15) & ~ 0xF) +
              ((reinterpret_cast<ptrdiff_t> (in)) & 0xF));
 
           *cur_plan_p =
             fftw_plan_many_dft (rank, tmp, howmany,
               reinterpret_cast<fftw_complex *> (itmp),
               0, stride, dist, reinterpret_cast<fftw_complex *> (out),
               0, stride, dist, dir, plan_flags);
         }
@@ -208,22 +208,22 @@ octave_fftw_planner::do_create_plan (int
         }
 
       if (*cur_plan_p == 0)
         (*current_liboctave_error_handler) ("Error creating fftw plan");
     }
 
   return *cur_plan_p;
 }
- 
+
 fftw_plan
-octave_fftw_planner::do_create_plan (const int rank, const dim_vector dims, 
+octave_fftw_planner::do_create_plan (const int rank, const dim_vector dims,
                                      octave_idx_type howmany,
                                      octave_idx_type stride,
-                                     octave_idx_type dist, 
+                                     octave_idx_type dist,
                                      const double *in, Complex *out)
 {
   fftw_plan *cur_plan_p = &rplan;
   bool create_new_plan = false;
   bool ioalign = CHECK_SIMD_ALIGNMENT (in) && CHECK_SIMD_ALIGNMENT (out);
 
   // Don't create a new plan if we have a non SIMD plan already but
   // can do SIMD.  This prevents endlessly recreating plans if we
@@ -261,17 +261,17 @@ octave_fftw_planner::do_create_plan (con
         {
           tmp[i] = dims(j);
           nn *= dims(j);
         }
 
       int plan_flags = 0;
       bool plan_destroys_in = true;
 
-      switch (meth) 
+      switch (meth)
         {
         case UNKNOWN:
         case ESTIMATE:
           plan_flags |= FFTW_ESTIMATE;
           plan_destroys_in = false;
           break;
         case MEASURE:
           plan_flags |= FFTW_MEASURE;
@@ -301,17 +301,17 @@ octave_fftw_planner::do_create_plan (con
       if (*cur_plan_p)
         fftw_destroy_plan (*cur_plan_p);
 
       if (plan_destroys_in)
         {
           // Create matrix with the same size and 16-byte alignment as input
           OCTAVE_LOCAL_BUFFER (double, itmp, nn + 32);
           itmp = reinterpret_cast<double *>
-            (((reinterpret_cast<ptrdiff_t>(itmp) + 15) & ~ 0xF) + 
+            (((reinterpret_cast<ptrdiff_t>(itmp) + 15) & ~ 0xF) +
              ((reinterpret_cast<ptrdiff_t> (in)) & 0xF));
 
           *cur_plan_p =
             fftw_plan_many_dft_r2c (rank, tmp, howmany, itmp,
               0, stride, dist, reinterpret_cast<fftw_complex *> (out),
               0, stride, dist, plan_flags);
         }
       else
@@ -339,17 +339,17 @@ octave_fftw_planner::do_method (void)
 octave_fftw_planner::FftwMethod
 octave_fftw_planner::do_method (FftwMethod _meth)
 {
   FftwMethod ret = meth;
   if (_meth == ESTIMATE || _meth == MEASURE
       || _meth == PATIENT || _meth == EXHAUSTIVE
       || _meth == HYBRID)
     {
-      if (meth != _meth) 
+      if (meth != _meth)
         {
           meth = _meth;
           if (rplan)
             fftw_destroy_plan (rplan);
           if (plan[0])
             fftw_destroy_plan (plan[0]);
           if (plan[1])
             fftw_destroy_plan (plan[1]);
@@ -367,17 +367,17 @@ octave_float_fftw_planner::octave_float_
   : meth (ESTIMATE), rplan (0), rd (0), rs (0), rr (0), rh (0), rn (),
     rsimd_align (false)
 {
   plan[0] = plan[1] = 0;
   d[0] = d[1] = s[0] = s[1] = r[0] = r[1] = h[0] = h[1] = 0;
   simd_align[0] = simd_align[1] = false;
   inplace[0] = inplace[1] = false;
   n[0] = n[1] = dim_vector ();
- 
+
   // If we have a system wide wisdom file, import it.
   fftwf_import_system_wisdom ();
 }
 
 bool
 octave_float_fftw_planner::instance_ok (void)
 {
   bool retval = true;
@@ -396,32 +396,32 @@ octave_float_fftw_planner::instance_ok (
   return retval;
 }
 
 fftwf_plan
 octave_float_fftw_planner::do_create_plan (int dir, const int rank,
                                            const dim_vector dims,
                                            octave_idx_type howmany,
                                            octave_idx_type stride,
-                                           octave_idx_type dist, 
+                                           octave_idx_type dist,
                                            const FloatComplex *in,
                                            FloatComplex *out)
 {
   int which = (dir == FFTW_FORWARD) ? 0 : 1;
   fftwf_plan *cur_plan_p = &plan[which];
   bool create_new_plan = false;
   bool ioalign = CHECK_SIMD_ALIGNMENT (in) && CHECK_SIMD_ALIGNMENT (out);
   bool ioinplace = (in == out);
 
   // Don't create a new plan if we have a non SIMD plan already but
   // can do SIMD.  This prevents endlessly recreating plans if we
   // change the alignment.
 
   if (plan[which] == 0 || d[which] != dist || s[which] != stride
-      || r[which] != rank || h[which] != howmany 
+      || r[which] != rank || h[which] != howmany
       || ioinplace != inplace[which]
       || ((ioalign != simd_align[which]) ? !ioalign : false))
     create_new_plan = true;
   else
     {
       // We still might not have the same shape of array.
 
       for (int i = 0; i < rank; i++)
@@ -450,17 +450,17 @@ octave_float_fftw_planner::do_create_pla
         {
           tmp[i] = dims(j);
           nn *= dims(j);
         }
 
       int plan_flags = 0;
       bool plan_destroys_in = true;
 
-      switch (meth) 
+      switch (meth)
         {
         case UNKNOWN:
         case ESTIMATE:
           plan_flags |= FFTW_ESTIMATE;
           plan_destroys_in = false;
           break;
         case MEASURE:
           plan_flags |= FFTW_MEASURE;
@@ -490,17 +490,17 @@ octave_float_fftw_planner::do_create_pla
       if (*cur_plan_p)
         fftwf_destroy_plan (*cur_plan_p);
 
       if (plan_destroys_in)
         {
           // Create matrix with the same size and 16-byte alignment as input
           OCTAVE_LOCAL_BUFFER (FloatComplex, itmp, nn * howmany + 32);
           itmp = reinterpret_cast<FloatComplex *>
-            (((reinterpret_cast<ptrdiff_t>(itmp) + 15) & ~ 0xF) + 
+            (((reinterpret_cast<ptrdiff_t>(itmp) + 15) & ~ 0xF) +
              ((reinterpret_cast<ptrdiff_t> (in)) & 0xF));
 
           *cur_plan_p =
             fftwf_plan_many_dft (rank, tmp, howmany,
               reinterpret_cast<fftwf_complex *> (itmp),
               0, stride, dist, reinterpret_cast<fftwf_complex *> (out),
               0, stride, dist, dir, plan_flags);
         }
@@ -514,23 +514,23 @@ octave_float_fftw_planner::do_create_pla
         }
 
       if (*cur_plan_p == 0)
         (*current_liboctave_error_handler) ("Error creating fftw plan");
     }
 
   return *cur_plan_p;
 }
- 
+
 fftwf_plan
 octave_float_fftw_planner::do_create_plan (const int rank,
-                                           const dim_vector dims, 
+                                           const dim_vector dims,
                                            octave_idx_type howmany,
                                            octave_idx_type stride,
-                                           octave_idx_type dist, 
+                                           octave_idx_type dist,
                                            const float *in, FloatComplex *out)
 {
   fftwf_plan *cur_plan_p = &rplan;
   bool create_new_plan = false;
   bool ioalign = CHECK_SIMD_ALIGNMENT (in) && CHECK_SIMD_ALIGNMENT (out);
 
   // Don't create a new plan if we have a non SIMD plan already but
   // can do SIMD.  This prevents endlessly recreating plans if we
@@ -568,17 +568,17 @@ octave_float_fftw_planner::do_create_pla
         {
           tmp[i] = dims(j);
           nn *= dims(j);
         }
 
       int plan_flags = 0;
       bool plan_destroys_in = true;
 
-      switch (meth) 
+      switch (meth)
         {
         case UNKNOWN:
         case ESTIMATE:
           plan_flags |= FFTW_ESTIMATE;
           plan_destroys_in = false;
           break;
         case MEASURE:
           plan_flags |= FFTW_MEASURE;
@@ -608,17 +608,17 @@ octave_float_fftw_planner::do_create_pla
       if (*cur_plan_p)
         fftwf_destroy_plan (*cur_plan_p);
 
       if (plan_destroys_in)
         {
           // Create matrix with the same size and 16-byte alignment as input
           OCTAVE_LOCAL_BUFFER (float, itmp, nn + 32);
           itmp = reinterpret_cast<float *>
-            (((reinterpret_cast<ptrdiff_t>(itmp) + 15) & ~ 0xF) + 
+            (((reinterpret_cast<ptrdiff_t>(itmp) + 15) & ~ 0xF) +
              ((reinterpret_cast<ptrdiff_t> (in)) & 0xF));
 
           *cur_plan_p =
             fftwf_plan_many_dft_r2c (rank, tmp, howmany, itmp,
               0, stride, dist, reinterpret_cast<fftwf_complex *> (out),
               0, stride, dist, plan_flags);
         }
       else
@@ -646,17 +646,17 @@ octave_float_fftw_planner::do_method (vo
 octave_float_fftw_planner::FftwMethod
 octave_float_fftw_planner::do_method (FftwMethod _meth)
 {
   FftwMethod ret = meth;
   if (_meth == ESTIMATE || _meth == MEASURE
       || _meth == PATIENT || _meth == EXHAUSTIVE
       || _meth == HYBRID)
     {
-      if (meth != _meth) 
+      if (meth != _meth)
         {
           meth = _meth;
           if (rplan)
             fftwf_destroy_plan (rplan);
           if (plan[0])
             fftwf_destroy_plan (plan[0]);
           if (plan[1])
             fftwf_destroy_plan (plan[1]);
@@ -723,37 +723,37 @@ convert_packcomplex_Nd (T *out, const di
   octave_quit ();
 
   // Now do the permutations needed for rank > 2 cases.
 
   size_t jstart = dv(0) * dv(1);
   size_t kstep = dv(0);
   size_t nel = dv.numel ();
 
-  for (int inner = 2; inner < dv.length (); inner++) 
+  for (int inner = 2; inner < dv.length (); inner++)
     {
       size_t jmax = jstart * dv(inner);
       for (size_t i = 0; i < nel; i+=jmax)
-        for (size_t j = jstart, jj = jmax-jstart; j < jj; 
+        for (size_t j = jstart, jj = jmax-jstart; j < jj;
              j+=jstart, jj-=jstart)
           for (size_t k = 0; k < jstart; k+= kstep)
             for (size_t l = nc/2+1; l < nc; l++)
               {
                 T tmp = out[i+ j + k + l];
                 out[i + j + k + l] =  out[i + jj + k + l];
                 out[i + jj + k + l] = tmp;
               }
       jstart = jmax;
     }
 
   octave_quit ();
 }
 
 int
-octave_fftw::fft (const double *in, Complex *out, size_t npts, 
+octave_fftw::fft (const double *in, Complex *out, size_t npts,
                   size_t nsamples, octave_idx_type stride, octave_idx_type dist)
 {
   dist = (dist < 0 ? npts : dist);
 
   dim_vector dv (npts, 1);
   fftw_plan plan = octave_fftw_planner::create_plan (1, dv, nsamples,
                                                      stride, dist, in, out);
 
@@ -763,125 +763,125 @@ octave_fftw::fft (const double *in, Comp
   // Need to create other half of the transform.
 
   convert_packcomplex_1d (out, nsamples, npts, stride, dist);
 
   return 0;
 }
 
 int
-octave_fftw::fft (const Complex *in, Complex *out, size_t npts, 
+octave_fftw::fft (const Complex *in, Complex *out, size_t npts,
                   size_t nsamples, octave_idx_type stride, octave_idx_type dist)
 {
   dist = (dist < 0 ? npts : dist);
 
   dim_vector dv (npts, 1);
   fftw_plan plan = octave_fftw_planner::create_plan (FFTW_FORWARD, 1, dv,
                                                      nsamples, stride,
                                                      dist, in, out);
 
-  fftw_execute_dft (plan, 
+  fftw_execute_dft (plan,
         reinterpret_cast<fftw_complex *> (const_cast<Complex *>(in)),
         reinterpret_cast<fftw_complex *> (out));
 
   return 0;
 }
 
 int
-octave_fftw::ifft (const Complex *in, Complex *out, size_t npts, 
+octave_fftw::ifft (const Complex *in, Complex *out, size_t npts,
                    size_t nsamples, octave_idx_type stride, octave_idx_type dist)
 {
   dist = (dist < 0 ? npts : dist);
 
   dim_vector dv (npts, 1);
   fftw_plan plan = octave_fftw_planner::create_plan (FFTW_BACKWARD, 1, dv,
                                                      nsamples, stride,
                                                      dist, in, out);
 
-  fftw_execute_dft (plan, 
+  fftw_execute_dft (plan,
         reinterpret_cast<fftw_complex *> (const_cast<Complex *>(in)),
         reinterpret_cast<fftw_complex *> (out));
 
   const Complex scale = npts;
   for (size_t j = 0; j < nsamples; j++)
     for (size_t i = 0; i < npts; i++)
       out[i*stride + j*dist] /= scale;
 
   return 0;
 }
 
 int
-octave_fftw::fftNd (const double *in, Complex *out, const int rank, 
+octave_fftw::fftNd (const double *in, Complex *out, const int rank,
                     const dim_vector &dv)
 {
   octave_idx_type dist = 1;
   for (int i = 0; i < rank; i++)
     dist *= dv(i);
 
   // Fool with the position of the start of the output matrix, so that
   // creating other half of the matrix won't cause cache problems.
 
-  octave_idx_type offset = (dv.numel () / dv(0)) * ((dv(0) - 1) / 2); 
-  
+  octave_idx_type offset = (dv.numel () / dv(0)) * ((dv(0) - 1) / 2);
+
   fftw_plan plan = octave_fftw_planner::create_plan (rank, dv, 1, 1, dist,
                                                      in, out + offset);
 
   fftw_execute_dft_r2c (plan, (const_cast<double *>(in)),
                         reinterpret_cast<fftw_complex *> (out+ offset));
 
   // Need to create other half of the transform.
 
   convert_packcomplex_Nd (out, dv);
 
   return 0;
 }
 
 int
-octave_fftw::fftNd (const Complex *in, Complex *out, const int rank, 
+octave_fftw::fftNd (const Complex *in, Complex *out, const int rank,
                     const dim_vector &dv)
 {
   octave_idx_type dist = 1;
   for (int i = 0; i < rank; i++)
     dist *= dv(i);
 
   fftw_plan plan = octave_fftw_planner::create_plan (FFTW_FORWARD, rank,
                                                      dv, 1, 1, dist, in, out);
 
-  fftw_execute_dft (plan, 
+  fftw_execute_dft (plan,
         reinterpret_cast<fftw_complex *> (const_cast<Complex *>(in)),
         reinterpret_cast<fftw_complex *> (out));
 
   return 0;
 }
 
 int
-octave_fftw::ifftNd (const Complex *in, Complex *out, const int rank, 
+octave_fftw::ifftNd (const Complex *in, Complex *out, const int rank,
                      const dim_vector &dv)
 {
   octave_idx_type dist = 1;
   for (int i = 0; i < rank; i++)
     dist *= dv(i);
 
   fftw_plan plan = octave_fftw_planner::create_plan (FFTW_BACKWARD, rank,
                                                      dv, 1, 1, dist, in, out);
 
-  fftw_execute_dft (plan, 
+  fftw_execute_dft (plan,
         reinterpret_cast<fftw_complex *> (const_cast<Complex *>(in)),
         reinterpret_cast<fftw_complex *> (out));
 
   const size_t npts = dv.numel ();
   const Complex scale = npts;
   for (size_t i = 0; i < npts; i++)
     out[i] /= scale;
 
   return 0;
 }
 
 int
-octave_fftw::fft (const float *in, FloatComplex *out, size_t npts, 
+octave_fftw::fft (const float *in, FloatComplex *out, size_t npts,
                   size_t nsamples, octave_idx_type stride, octave_idx_type dist)
 {
   dist = (dist < 0 ? npts : dist);
 
   dim_vector dv (npts, 1);
   fftwf_plan plan = octave_float_fftw_planner::create_plan (1, dv, nsamples,
                                                             stride, dist,
                                                             in, out);
@@ -892,117 +892,117 @@ octave_fftw::fft (const float *in, Float
   // Need to create other half of the transform.
 
   convert_packcomplex_1d (out, nsamples, npts, stride, dist);
 
   return 0;
 }
 
 int
-octave_fftw::fft (const FloatComplex *in, FloatComplex *out, size_t npts, 
+octave_fftw::fft (const FloatComplex *in, FloatComplex *out, size_t npts,
                   size_t nsamples, octave_idx_type stride, octave_idx_type dist)
 {
   dist = (dist < 0 ? npts : dist);
 
   dim_vector dv (npts, 1);
   fftwf_plan plan = octave_float_fftw_planner::create_plan (FFTW_FORWARD, 1,
                                                             dv, nsamples,
                                                             stride, dist,
                                                             in, out);
 
-  fftwf_execute_dft (plan, 
+  fftwf_execute_dft (plan,
         reinterpret_cast<fftwf_complex *> (const_cast<FloatComplex *>(in)),
         reinterpret_cast<fftwf_complex *> (out));
 
   return 0;
 }
 
 int
-octave_fftw::ifft (const FloatComplex *in, FloatComplex *out, size_t npts, 
+octave_fftw::ifft (const FloatComplex *in, FloatComplex *out, size_t npts,
                    size_t nsamples, octave_idx_type stride, octave_idx_type dist)
 {
   dist = (dist < 0 ? npts : dist);
 
   dim_vector dv (npts, 1);
   fftwf_plan plan = octave_float_fftw_planner::create_plan (FFTW_BACKWARD, 1,
                                                             dv, nsamples,
                                                             stride, dist,
                                                             in, out);
 
-  fftwf_execute_dft (plan, 
+  fftwf_execute_dft (plan,
         reinterpret_cast<fftwf_complex *> (const_cast<FloatComplex *>(in)),
         reinterpret_cast<fftwf_complex *> (out));
 
   const FloatComplex scale = npts;
   for (size_t j = 0; j < nsamples; j++)
     for (size_t i = 0; i < npts; i++)
       out[i*stride + j*dist] /= scale;
 
   return 0;
 }
 
 int
-octave_fftw::fftNd (const float *in, FloatComplex *out, const int rank, 
+octave_fftw::fftNd (const float *in, FloatComplex *out, const int rank,
                     const dim_vector &dv)
 {
   octave_idx_type dist = 1;
   for (int i = 0; i < rank; i++)
     dist *= dv(i);
 
   // Fool with the position of the start of the output matrix, so that
   // creating other half of the matrix won't cause cache problems.
 
-  octave_idx_type offset = (dv.numel () / dv(0)) * ((dv(0) - 1) / 2); 
-  
+  octave_idx_type offset = (dv.numel () / dv(0)) * ((dv(0) - 1) / 2);
+
   fftwf_plan plan = octave_float_fftw_planner::create_plan (rank, dv, 1, 1,
                                                             dist, in,
                                                             out + offset);
 
   fftwf_execute_dft_r2c (plan, (const_cast<float *>(in)),
                         reinterpret_cast<fftwf_complex *> (out+ offset));
 
   // Need to create other half of the transform.
 
   convert_packcomplex_Nd (out, dv);
 
   return 0;
 }
 
 int
-octave_fftw::fftNd (const FloatComplex *in, FloatComplex *out, const int rank, 
+octave_fftw::fftNd (const FloatComplex *in, FloatComplex *out, const int rank,
                     const dim_vector &dv)
 {
   octave_idx_type dist = 1;
   for (int i = 0; i < rank; i++)
     dist *= dv(i);
 
   fftwf_plan plan = octave_float_fftw_planner::create_plan (FFTW_FORWARD,
                                                             rank, dv, 1, 1,
                                                             dist, in, out);
 
-  fftwf_execute_dft (plan, 
+  fftwf_execute_dft (plan,
         reinterpret_cast<fftwf_complex *> (const_cast<FloatComplex *>(in)),
         reinterpret_cast<fftwf_complex *> (out));
 
   return 0;
 }
 
 int
-octave_fftw::ifftNd (const FloatComplex *in, FloatComplex *out, const int rank, 
+octave_fftw::ifftNd (const FloatComplex *in, FloatComplex *out, const int rank,
                      const dim_vector &dv)
 {
   octave_idx_type dist = 1;
   for (int i = 0; i < rank; i++)
     dist *= dv(i);
 
   fftwf_plan plan = octave_float_fftw_planner::create_plan (FFTW_BACKWARD,
                                                             rank, dv, 1, 1,
                                                             dist, in, out);
 
-  fftwf_execute_dft (plan, 
+  fftwf_execute_dft (plan,
         reinterpret_cast<fftwf_complex *> (const_cast<FloatComplex *>(in)),
         reinterpret_cast<fftwf_complex *> (out));
 
   const size_t npts = dv.numel ();
   const FloatComplex scale = npts;
   for (size_t i = 0; i < npts; i++)
     out[i] /= scale;
 
diff --git a/liboctave/oct-fftw.h b/liboctave/oct-fftw.h
--- a/liboctave/oct-fftw.h
+++ b/liboctave/oct-fftw.h
@@ -54,31 +54,31 @@ public:
     PATIENT,
     EXHAUSTIVE,
     HYBRID
   };
 
   static bool instance_ok (void);
 
   static fftw_plan
-  create_plan (int dir, const int rank, const dim_vector dims, 
+  create_plan (int dir, const int rank, const dim_vector dims,
                octave_idx_type howmany, octave_idx_type stride,
                octave_idx_type dist, const Complex *in,
                Complex *out)
   {
     static fftw_plan dummy;
 
     return instance_ok ()
       ? instance->do_create_plan (dir, rank, dims, howmany, stride,
                                   dist, in, out)
       : dummy;
   }
 
   static fftw_plan
-  create_plan (const int rank, const dim_vector dims, 
+  create_plan (const int rank, const dim_vector dims,
                octave_idx_type howmany, octave_idx_type stride,
                octave_idx_type dist, const double *in, Complex *out)
   {
     static fftw_plan dummy;
 
     return instance_ok ()
       ? instance->do_create_plan (rank, dims, howmany, stride, dist, in, out)
       : dummy;
@@ -98,23 +98,23 @@ public:
     return instance_ok () ? instance->do_method (_meth) : dummy;
   }
 
 private:
 
   static octave_fftw_planner *instance;
 
   fftw_plan
-  do_create_plan (int dir, const int rank, const dim_vector dims, 
+  do_create_plan (int dir, const int rank, const dim_vector dims,
                   octave_idx_type howmany, octave_idx_type stride,
                   octave_idx_type dist, const Complex *in,
                   Complex *out);
 
   fftw_plan
-  do_create_plan (const int rank, const dim_vector dims, 
+  do_create_plan (const int rank, const dim_vector dims,
                   octave_idx_type howmany, octave_idx_type stride,
                   octave_idx_type dist, const double *in, Complex *out);
 
   FftwMethod do_method (void);
 
   FftwMethod do_method (FftwMethod _meth);
 
   FftwMethod meth;
@@ -181,33 +181,33 @@ public:
     ESTIMATE,
     MEASURE,
     PATIENT,
     EXHAUSTIVE,
     HYBRID
   };
 
   static bool instance_ok (void);
-  
+
   static fftwf_plan
-  create_plan (int dir, const int rank, const dim_vector dims, 
+  create_plan (int dir, const int rank, const dim_vector dims,
                octave_idx_type howmany, octave_idx_type stride,
                octave_idx_type dist, const FloatComplex *in,
                FloatComplex *out)
   {
     static fftwf_plan dummy;
 
     return instance_ok ()
       ? instance->do_create_plan (dir, rank, dims, howmany, stride,
                                   dist, in, out)
       : dummy;
   }
 
   static fftwf_plan
-  create_plan (const int rank, const dim_vector dims, 
+  create_plan (const int rank, const dim_vector dims,
                octave_idx_type howmany, octave_idx_type stride,
                octave_idx_type dist, const float *in, FloatComplex *out)
   {
     static fftwf_plan dummy;
 
     return instance_ok ()
       ? instance->do_create_plan (rank, dims, howmany, stride, dist, in, out)
       : dummy;
@@ -227,23 +227,23 @@ public:
     return instance_ok () ? instance->method (_meth) : dummy;
   }
 
 private:
 
   static octave_float_fftw_planner *instance;
 
   fftwf_plan
-  do_create_plan (int dir, const int rank, const dim_vector dims, 
+  do_create_plan (int dir, const int rank, const dim_vector dims,
                   octave_idx_type howmany, octave_idx_type stride,
                   octave_idx_type dist, const FloatComplex *in,
                   FloatComplex *out);
 
   fftwf_plan
-  do_create_plan (const int rank, const dim_vector dims, 
+  do_create_plan (const int rank, const dim_vector dims,
                   octave_idx_type howmany, octave_idx_type stride,
                   octave_idx_type dist, const float *in, FloatComplex *out);
 
   FftwMethod do_method (void);
 
   FftwMethod do_method (FftwMethod _meth);
 
   FftwMethod meth;
@@ -293,40 +293,40 @@ private:
 };
 
 class
 OCTAVE_API
 octave_fftw
 {
 public:
 
-  static int fft (const double *in, Complex *out, size_t npts, 
+  static int fft (const double *in, Complex *out, size_t npts,
                   size_t nsamples = 1, octave_idx_type stride = 1, octave_idx_type dist = -1);
-  static int fft (const Complex *in, Complex *out, size_t npts, 
+  static int fft (const Complex *in, Complex *out, size_t npts,
                   size_t nsamples = 1, octave_idx_type stride = 1, octave_idx_type dist = -1);
   static int ifft (const Complex *in, Complex *out, size_t npts,
                    size_t nsamples = 1, octave_idx_type stride = 1, octave_idx_type dist = -1);
 
   static int fftNd (const double*, Complex*, const int, const dim_vector &);
-  static int fftNd (const Complex*, Complex*, const int, 
+  static int fftNd (const Complex*, Complex*, const int,
                     const dim_vector &);
-  static int ifftNd (const Complex*, Complex*, const int, 
+  static int ifftNd (const Complex*, Complex*, const int,
                      const dim_vector &);
 
-  static int fft (const float *in, FloatComplex *out, size_t npts, 
+  static int fft (const float *in, FloatComplex *out, size_t npts,
                   size_t nsamples = 1, octave_idx_type stride = 1, octave_idx_type dist = -1);
-  static int fft (const FloatComplex *in, FloatComplex *out, size_t npts, 
+  static int fft (const FloatComplex *in, FloatComplex *out, size_t npts,
                   size_t nsamples = 1, octave_idx_type stride = 1, octave_idx_type dist = -1);
   static int ifft (const FloatComplex *in, FloatComplex *out, size_t npts,
                    size_t nsamples = 1, octave_idx_type stride = 1, octave_idx_type dist = -1);
 
   static int fftNd (const float*, FloatComplex*, const int, const dim_vector &);
-  static int fftNd (const FloatComplex*, FloatComplex*, const int, 
+  static int fftNd (const FloatComplex*, FloatComplex*, const int,
                     const dim_vector &);
-  static int ifftNd (const FloatComplex*, FloatComplex*, const int, 
+  static int ifftNd (const FloatComplex*, FloatComplex*, const int,
                      const dim_vector &);
 
 private:
   octave_fftw (void);
   octave_fftw (const octave_fftw&);
   octave_fftw& operator = (const octave_fftw&);
 };
 
diff --git a/liboctave/oct-glob.cc b/liboctave/oct-glob.cc
--- a/liboctave/oct-glob.cc
+++ b/liboctave/oct-glob.cc
@@ -75,21 +75,21 @@ octave_glob (const string_vector& pat)
     {
       std::string xpat = pat(i);
 
       if (! xpat.empty ())
         {
           glob_t glob_info;
 
 #if defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM) \
-          && ! defined (OCTAVE_HAVE_POSIX_FILESYSTEM) 
-              std::replace_if (xpat.begin (), xpat.end (), 
-                               std::bind2nd (std::equal_to<char> (), '\\'), 
-                               '/'); 
-#endif 
+          && ! defined (OCTAVE_HAVE_POSIX_FILESYSTEM)
+              std::replace_if (xpat.begin (), xpat.end (),
+                               std::bind2nd (std::equal_to<char> (), '\\'),
+                               '/');
+#endif
 
           int err = gnulib::glob (xpat.c_str (), GLOB_NOSORT, 0, &glob_info);
 
           if (! err)
             {
               int n = glob_info.gl_pathc;
 
               const char * const *matches = glob_info.gl_pathv;
@@ -101,29 +101,29 @@ octave_glob (const string_vector& pat)
 
               if (n > 1
                   || (n == 1
                       && single_match_exists (std::string (matches[0]))))
                 {
                   retval.resize (k+n);
 
                   for (int j = 0; j < n; j++)
-                    { 
-                      std::string tmp = matches[j]; 
+                    {
+                      std::string tmp = matches[j];
 
 #if defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM) \
-                      && ! defined (OCTAVE_HAVE_POSIX_FILESYSTEM) 
-                          std::replace_if (tmp.begin (), tmp.end (), 
-                                           std::bind2nd (std::equal_to<char> (), 
-                                                         '/'), 
-                                           '\\'); 
-#endif 
+                      && ! defined (OCTAVE_HAVE_POSIX_FILESYSTEM)
+                          std::replace_if (tmp.begin (), tmp.end (),
+                                           std::bind2nd (std::equal_to<char> (),
+                                                         '/'),
+                                           '\\');
+#endif
 
-                      retval[k++] = tmp; 
-                    } 
+                      retval[k++] = tmp;
+                    }
                 }
 
               gnulib::globfree (&glob_info);
             }
         }
     }
 
   return retval.sort ();
diff --git a/liboctave/oct-group.h b/liboctave/oct-group.h
--- a/liboctave/oct-group.h
+++ b/liboctave/oct-group.h
@@ -36,17 +36,17 @@ octave_group
 public:
 
   octave_group (void)
     : gr_name (), gr_passwd (), gr_gid (0), gr_mem (), valid (false)
   { }
 
   octave_group (const octave_group& gr)
     : gr_name (gr.gr_name), gr_passwd (gr.gr_passwd),
-      gr_gid (gr.gr_gid), gr_mem (gr.gr_mem), valid (gr.valid) 
+      gr_gid (gr.gr_gid), gr_mem (gr.gr_mem), valid (gr.valid)
   { }
 
   octave_group& operator = (const octave_group& gr)
   {
     if (this != &gr)
       {
         gr_name  = gr.gr_name;
         gr_passwd = gr.gr_passwd;
diff --git a/liboctave/oct-inttypes.cc b/liboctave/oct-inttypes.cc
--- a/liboctave/oct-inttypes.cc
+++ b/liboctave/oct-inttypes.cc
@@ -1,12 +1,12 @@
 /*
 
 Copyright (C) 2004-2011 John W. Eaton
-Copyright (C) 2008-2009 Jaroslav Hajek 
+Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 #include "oct-inttypes.h"
 
 template<class T>
 const octave_int<T> octave_int<T>::zero (static_cast<T> (0));
 
 template<class T>
 const octave_int<T> octave_int<T>::one (static_cast<T> (1));
 
-// define type names. 
+// define type names.
 #define DECLARE_OCTAVE_INT_TYPENAME(TYPE, TYPENAME) \
   template <> \
   OCTAVE_API const char * \
   octave_int<TYPE>::type_name () { return TYPENAME; }
 
 DECLARE_OCTAVE_INT_TYPENAME (int8_t, "int8")
 DECLARE_OCTAVE_INT_TYPENAME (int16_t, "int16")
 DECLARE_OCTAVE_INT_TYPENAME (int32_t, "int32")
@@ -49,18 +49,18 @@ DECLARE_OCTAVE_INT_TYPENAME (uint8_t, "u
 DECLARE_OCTAVE_INT_TYPENAME (uint16_t, "uint16")
 DECLARE_OCTAVE_INT_TYPENAME (uint32_t, "uint32")
 DECLARE_OCTAVE_INT_TYPENAME (uint64_t, "uint64")
 
 #ifndef OCTAVE_INT_USE_LONG_DOUBLE
 
 // Define comparison operators
 
-template <class xop> 
-bool 
+template <class xop>
+bool
 octave_int_cmp_op::emulate_mop (uint64_t x, double y)
 {
   static const double xxup = std::numeric_limits<uint64_t>::max ();
   // This converts to the nearest double. Unless there's an equality, the
   // result is clear.
   double xx = x;
   if (xx != y)
     return xop::op (xx, y);
@@ -69,18 +69,18 @@ octave_int_cmp_op::emulate_mop (uint64_t
       // If equality occured we compare as integers.
       if (xx == xxup)
         return xop::gtval;
       else
         return xop::op (x, static_cast<uint64_t> (xx));
     }
 }
 
-template <class xop> 
-bool 
+template <class xop>
+bool
 octave_int_cmp_op::emulate_mop (int64_t x, double y)
 {
   static const double xxup = std::numeric_limits<int64_t>::max ();
   static const double xxlo = std::numeric_limits<int64_t>::min ();
   // This converts to the nearest double. Unless there's an equality, the
   // result is clear.
   double xx = x;
   if (xx != y)
@@ -116,60 +116,60 @@ public:
     typedef octave_int_cmp_op::OP2 op; \
   }
 
 DEFINE_REVERTED_OPERATOR(lt,gt);
 DEFINE_REVERTED_OPERATOR(gt,lt);
 DEFINE_REVERTED_OPERATOR(le,ge);
 DEFINE_REVERTED_OPERATOR(ge,le);
 
-template <class xop> 
-bool 
+template <class xop>
+bool
 octave_int_cmp_op::emulate_mop (double x, uint64_t y)
 {
   typedef typename rev_op<xop>::op rop;
   return mop<rop> (y, x);
 }
 
-template <class xop> 
-bool 
+template <class xop>
+bool
 octave_int_cmp_op::emulate_mop (double x, int64_t y)
 {
   typedef typename rev_op<xop>::op rop;
   return mop<rop> (y, x);
 }
 
 
 // Define handlers for int64 multiplication
 
 template <>
-uint64_t 
+uint64_t
 octave_int_arith_base<uint64_t, false>::mul (uint64_t x, uint64_t y)
-{ 
+{
   // Get upper words
   uint64_t ux = x >> 32, uy = y >> 32;
   uint64_t res;
   if (ux)
     {
-      if (uy) 
+      if (uy)
         goto overflow;
       else
         {
           uint64_t ly = static_cast<uint32_t> (y), uxly = ux*ly;
-          if (uxly >> 32) 
+          if (uxly >> 32)
             goto overflow;
           uxly <<= 32; // never overflows
           uint64_t lx = static_cast<uint32_t> (x), lxly = lx*ly;
           res = add (uxly, lxly);
         }
     }
   else if (uy)
     {
       uint64_t lx = static_cast<uint32_t> (x), uylx = uy*lx;
-      if (uylx >> 32) 
+      if (uylx >> 32)
         goto overflow;
       uylx <<= 32; // never overflows
       uint64_t ly = static_cast<uint32_t> (y), lylx = ly*lx;
       res = add (uylx, lylx);
     }
   else
     {
       uint64_t lx = static_cast<uint32_t> (x);
@@ -179,53 +179,53 @@ octave_int_arith_base<uint64_t, false>::
 
   return res;
 
 overflow:
   return max_val ();
 }
 
 template <>
-int64_t 
+int64_t
 octave_int_arith_base<int64_t, true>::mul (int64_t x, int64_t y)
-{ 
+{
   // The signed case is far worse. The problem is that
   // even if neither integer fits into signed 32-bit range, the result may
   // still be OK. Uh oh.
-  
+
   // Essentially, what we do is compute sign, multiply absolute values
   // (as above) and impose the sign.
   // FIXME -- can we do something faster if we HAVE_FAST_INT_OPS?
 
   uint64_t usx = octave_int_abs (x), usy = octave_int_abs (y);
   bool positive = (x < 0) == (y < 0);
 
   // Get upper words
   uint64_t ux = usx >> 32, uy = usy >> 32;
   uint64_t res;
   if (ux)
     {
-      if (uy) 
+      if (uy)
         goto overflow;
       else
         {
           uint64_t ly = static_cast<uint32_t> (usy), uxly = ux*ly;
-          if (uxly >> 32) 
+          if (uxly >> 32)
             goto overflow;
           uxly <<= 32; // never overflows
           uint64_t lx = static_cast<uint32_t> (usx), lxly = lx*ly;
           res = uxly + lxly;
           if (res < uxly)
             goto overflow;
         }
     }
   else if (uy)
     {
       uint64_t lx = static_cast<uint32_t> (usx), uylx = uy*lx;
-      if (uylx >> 32) 
+      if (uylx >> 32)
         goto overflow;
       uylx <<= 32; // never overflows
       uint64_t ly = static_cast<uint32_t> (usy), lylx = ly*lx;
       res = uylx + lylx;
       if (res < uylx)
         goto overflow;
     }
   else
@@ -287,38 +287,38 @@ INT_DOUBLE_BINOP_DECL (+, int64)
       // If the number is within the int64 range (the most common case,
       // probably), the above will work as expected. If not, it's more
       // complicated - as long as y is within _twice_ the signed range, the
       // result may still be an integer. An instance of such an operation is
       // 3*2**62 + (1+intmin('int64')) that should yield int64(2**62) + 1.  So
       // what we do is to try to convert y/2 and add it twice. Note that if y/2
       // overflows, the result must overflow as well, and that y/2 cannot be a
       // fractional number.
-      octave_int64 y2 (y / 2); 
+      octave_int64 y2 (y / 2);
       return (x + y2) + y2;
     }
 }
 
 DOUBLE_INT_BINOP_DECL (+, int64)
-{ 
-  return y + x; 
+{
+  return y + x;
 }
 
 INT_DOUBLE_BINOP_DECL (-, uint64)
 {
   return x + (-y);
 }
 
 DOUBLE_INT_BINOP_DECL (-, uint64)
 {
   if (x <= static_cast<double> (octave_uint64::max ()))
-    return octave_uint64(x) - y; 
+    return octave_uint64(x) - y;
   else
     {
-      // Again a trick to get the corner cases right. Things like 
+      // Again a trick to get the corner cases right. Things like
       // 3**2**63 - intmax('uint64') should produce the correct result, i.e.
       // int64(2**63) + 1.
       const double p2_64 = std::pow (2.0, 64);
       if (y.bool_value ())
         {
           const uint64_t p2_64my = (~y.value ()) + 1; // Equals 2**64 - y
           return octave_uint64 (x - p2_64) + octave_uint64 (p2_64my);
         }
@@ -329,40 +329,40 @@ DOUBLE_INT_BINOP_DECL (-, uint64)
 
 INT_DOUBLE_BINOP_DECL (-, int64)
 {
   return x + (-y);
 }
 
 DOUBLE_INT_BINOP_DECL (-, int64)
 {
-  static const bool twosc = (std::numeric_limits<int64_t>::min () 
+  static const bool twosc = (std::numeric_limits<int64_t>::min ()
                              < -std::numeric_limits<int64_t>::max ());
   // In case of symmetric integers (not two's complement), this will probably
   // be eliminated at compile time.
   if (twosc && y.value () == std::numeric_limits<int64_t>::min ())
     {
       return octave_int64 (x + std::pow(2.0, 63));
     }
   else
-    return x + (-y); 
+    return x + (-y);
 }
 
 // NOTE:
 // Emulated mixed multiplications are tricky due to possible precision loss.
 // Here, after sorting out common cases for speed, we follow the strategy
 // of converting the double number into the form sign * 64-bit integer* 2**exponent,
 // multiply the 64-bit integers to get a 128-bit number, split that number into 32-bit words
 // and form 4 double-valued summands (none of which loases precision), then convert these
 // into integers and sum them. Though it is not immediately obvious, this should work
 // even w.r.t. rounding (none of the summands lose precision).
 
 // Multiplies two unsigned 64-bit ints to get a 128-bit number represented
 // as four 32-bit words.
-static void 
+static void
 umul128 (uint64_t x, uint64_t y, uint32_t w[4])
 {
   uint64_t lx = static_cast<uint32_t> (x), ux = x >> 32;
   uint64_t ly = static_cast<uint32_t> (y), uy = y >> 32;
   uint64_t a = lx * ly;
   w[0] = a; a >>= 32;
   uint64_t uxly = ux*ly, uylx = uy*lx;
   a += static_cast<uint32_t> (uxly); uxly >>= 32;
@@ -370,17 +370,17 @@ umul128 (uint64_t x, uint64_t y, uint32_
   w[1] = a; a >>= 32;
   uint64_t uxuy = ux * uy;
   a += uxly; a += uylx; a += uxuy;
   w[2] = a; a >>= 32;
   w[3] = a;
 }
 
 // Splits a double into bool sign, unsigned 64-bit mantissa and int exponent
-static void 
+static void
 dblesplit (double x, bool& sign, uint64_t& mtis, int& exp)
 {
   sign = x < 0; x = fabs (x);
   x = frexp (x, &exp);
   exp -= 52;
   mtis = static_cast<uint64_t> (ldexp (x, 52));
 }
 
@@ -400,32 +400,32 @@ INT_DOUBLE_BINOP_DECL (*, uint64)
       return x * octave_uint64 (static_cast<uint64_t> (y));
     }
   else if (y == 0.5)
     {
       return x / octave_uint64 (static_cast<uint64_t> (2));
     }
   else if (y < 0 || xisnan (y) || xisinf (y))
     {
-      return octave_uint64 (x.value () * y); 
+      return octave_uint64 (x.value () * y);
     }
   else
     {
       bool sign;
       uint64_t my;
       int e;
       dblesplit (y, sign, my, e);
       uint32_t w[4];
       umul128 (x.value (), my, w);
       octave_uint64 res = octave_uint64::zero;
       for (short i = 0; i < 4; i++)
         {
           res += octave_uint64 (dbleget (sign, w[i], e));
           e += 32;
-        }          
+        }
       return res;
     }
 }
 
 DOUBLE_INT_BINOP_DECL (*, uint64)
 { return y * x; }
 
 INT_DOUBLE_BINOP_DECL (*, int64)
@@ -435,33 +435,33 @@ INT_DOUBLE_BINOP_DECL (*, int64)
       return x * octave_int64 (static_cast<int64_t> (y));
     }
   else if (fabs (y) == 0.5)
     {
       return x / octave_int64 (static_cast<uint64_t> (4*y));
     }
   else if (xisnan (y) || xisinf (y))
     {
-      return octave_int64 (x.value () * y); 
+      return octave_int64 (x.value () * y);
     }
   else
     {
       bool sign;
       uint64_t my;
       int e;
       dblesplit (y, sign, my, e);
       uint32_t w[4];
       sign = (sign != (x.value () < 0));
       umul128 (octave_int_abs (x.value ()), my, w);
       octave_int64 res = octave_int64::zero;
       for (short i = 0; i < 4; i++)
         {
           res += octave_int64 (dbleget (sign, w[i], e));
           e += 32;
-        }          
+        }
       return res;
     }
 }
 
 DOUBLE_INT_BINOP_DECL (*, int64)
 { return y * x; }
 
 DOUBLE_INT_BINOP_DECL (/, uint64)
@@ -565,34 +565,34 @@ pow (const octave_int<T>& a, const octav
 template <class T>
 octave_int<T>
 pow (const double& a, const octave_int<T>& b)
 { return octave_int<T> (pow (a, b.double_value ())); }
 
 template <class T>
 octave_int<T>
 pow (const octave_int<T>& a, const double& b)
-{ 
+{
   return ((b >= 0 && b < std::numeric_limits<T>::digits && b == xround (b))
           ? pow (a, octave_int<T> (static_cast<T> (b)))
-          : octave_int<T> (pow (a.double_value (), b))); 
+          : octave_int<T> (pow (a.double_value (), b)));
 }
 
 template <class T>
 octave_int<T>
 powf (const float& a, const octave_int<T>& b)
 { return octave_int<T> (pow (a, b.float_value ())); }
 
 template <class T>
 octave_int<T>
 powf (const octave_int<T>& a, const float& b)
 {
   return ((b >= 0 && b < std::numeric_limits<T>::digits && b == xround (b))
           ? pow (a, octave_int<T> (static_cast<T> (b)))
-          : octave_int<T> (pow (a.double_value (), static_cast<double> (b)))); 
+          : octave_int<T> (pow (a.double_value (), static_cast<double> (b))));
 }
 
 #define INSTANTIATE_INTTYPE(T) \
   template class OCTAVE_API octave_int<T>; \
   template OCTAVE_API octave_int<T> pow (const octave_int<T>&, const octave_int<T>&); \
   template OCTAVE_API octave_int<T> pow (const double&, const octave_int<T>&); \
   template OCTAVE_API octave_int<T> pow (const octave_int<T>&, const double&); \
   template OCTAVE_API octave_int<T> powf (const float&, const octave_int<T>&); \
diff --git a/liboctave/oct-inttypes.h b/liboctave/oct-inttypes.h
--- a/liboctave/oct-inttypes.h
+++ b/liboctave/oct-inttypes.h
@@ -46,17 +46,17 @@ template <class T>
 inline T octave_int_abs (T x) { return x >= 0 ? x : -x; }
 
 // Query for an integer type of certain sizeof, and signedness.
 template<int qsize, bool qsigned>
 struct query_integer_type
 {
 public:
   static const bool registered = false;
-  typedef void type; // Void shall result in a compile-time error if we 
+  typedef void type; // Void shall result in a compile-time error if we
                      // attempt to use it in computations.
 };
 
 #define REGISTER_INT_TYPE(TYPE) \
 template <> \
 class query_integer_type<sizeof (TYPE), std::numeric_limits<TYPE>::is_signed> \
 { \
 public: \
@@ -71,17 +71,17 @@ REGISTER_INT_TYPE (int16_t);
 REGISTER_INT_TYPE (uint16_t);
 REGISTER_INT_TYPE (int32_t);
 REGISTER_INT_TYPE (uint32_t);
 REGISTER_INT_TYPE (int64_t);
 REGISTER_INT_TYPE (uint64_t);
 
 // Rationale: Comparators have a single static method, rel(), that returns the
 // result of the binary relation. They also have two static boolean fields:
-// ltval, gtval determine the value of x OP y if x < y, x > y, respectively. 
+// ltval, gtval determine the value of x OP y if x < y, x > y, respectively.
 #define REGISTER_OCTAVE_CMP_OP(NM,OP) \
   class NM \
     { \
     public: \
       static const bool ltval = (0 OP 1), gtval = (1 OP 0); \
       template <class T> \
       static bool op (T x, T y) { return x OP y; } \
     }
@@ -104,44 +104,44 @@ class octave_int_cmp_op
   // binary relation. If promotion to int or T2 is safe, it is used. Otherwise,
   // the signedness of T1 is preserved and it is widened if T2 is wider.
   // Notice that if this is applied to both types, they must end up with equal
   // size.
   template <class T1, class T2>
   class prom
     {
       // Promote to int?
-      static const bool pint = (sizeof (T1) < sizeof (int) 
+      static const bool pint = (sizeof (T1) < sizeof (int)
                                 && sizeof (T2) < sizeof (int));
       static const bool t1sig = std::numeric_limits<T1>::is_signed;
       static const bool t2sig = std::numeric_limits<T2>::is_signed;
-      static const bool psig = 
+      static const bool psig =
         (pint || (sizeof (T2) > sizeof (T1) && t2sig) || t1sig);
       static const int psize =
-        (pint ? sizeof (int) : (sizeof (T2) > sizeof (T1) 
+        (pint ? sizeof (int) : (sizeof (T2) > sizeof (T1)
                                 ? sizeof (T2) : sizeof (T1)));
     public:
       typedef typename query_integer_type<psize, psig>::type type;
     };
 
   // Implements comparisons between two types of equal size but
   // possibly different signedness.
   template<class xop, int size>
   class uiop
     {
       typedef typename query_integer_type<size, false>::type utype;
       typedef typename query_integer_type<size, true>::type stype;
     public:
-      static bool op (utype x, utype y) 
+      static bool op (utype x, utype y)
         { return xop::op (x, y); }
-      static bool op (stype x, stype y) 
+      static bool op (stype x, stype y)
         { return xop::op (x, y); }
-      static bool op (stype x, utype y) 
+      static bool op (stype x, utype y)
         { return (x < 0) ? xop::ltval : xop::op (static_cast<utype> (x), y); }
-      static bool op (utype x, stype y) 
+      static bool op (utype x, stype y)
         { return (y < 0) ? xop::gtval : xop::op (x, static_cast<utype> (y)); }
     };
 
 public:
   REGISTER_OCTAVE_CMP_OP (lt, <);
   REGISTER_OCTAVE_CMP_OP (le, <=);
   REGISTER_OCTAVE_CMP_OP (gt, >);
   REGISTER_OCTAVE_CMP_OP (ge, >=);
@@ -152,20 +152,20 @@ public:
 
   // Universal comparison operation.
   template<class xop, class T1, class T2>
   static bool
   op (T1 x, T2 y)
     {
       typedef typename prom<T1, T2>::type PT1;
       typedef typename prom<T2, T1>::type PT2;
-      return uiop<xop, sizeof (PT1)>::op (static_cast<PT1> (x), 
+      return uiop<xop, sizeof (PT1)>::op (static_cast<PT1> (x),
                                           static_cast<PT2> (y));
     }
-  
+
 public:
 
   // Mixed comparisons
   template <class xop, class T>
   static bool
   mop (T x, double y)
     { return xop::op (static_cast<double> (x), y); }
 
@@ -180,17 +180,17 @@ public:
 #define DEFINE_LONG_DOUBLE_CMP_OP(T1, T2) \
   template <class xop> \
   static bool \
   mop (T1 x, T2 y) \
     { \
       return xop::op (static_cast<long double> (x), \
                       static_cast<long double> (y)); \
     }
-#else 
+#else
   // ... otherwise, use external handlers
 
   // FIXME: We could declare directly the mop methods as external,
   // but we can't do this because bugs in gcc (<= 4.3) prevent
   // explicit instantiations later in that case.
 #define DEFINE_LONG_DOUBLE_CMP_OP(T1, T2) \
   template <class xop> static OCTAVE_API bool \
   emulate_mop (T1, T2); \
@@ -206,39 +206,39 @@ public:
   DEFINE_LONG_DOUBLE_CMP_OP(double, int64_t)
   DEFINE_LONG_DOUBLE_CMP_OP(int64_t, double)
   DEFINE_LONG_DOUBLE_CMP_OP(uint64_t, double)
 
 #undef DEFINE_LONG_DOUBLE_CMP_OP
 };
 
 // Base integer class. No data, just conversion methods and exception flags.
-template <class T> 
+template <class T>
 class octave_int_base
 {
 protected:
 
   static T min_val () { return std::numeric_limits<T>:: min (); }
   static T max_val () { return std::numeric_limits<T>:: max (); }
 
 public:
 
   // Convert integer value.
   template <class S>
-  static T 
+  static T
   truncate_int (const S& value)
-    { 
+    {
       // An exhaustive test whether the max and/or min check can be omitted.
       static const bool t_is_signed = std::numeric_limits<T>::is_signed;
       static const bool s_is_signed = std::numeric_limits<S>::is_signed;
       static const int t_size = sizeof (T), s_size = sizeof (S);
-      static const bool omit_chk_min = 
+      static const bool omit_chk_min =
         (! s_is_signed || (t_is_signed && t_size >= s_size));
-      static const bool omit_chk_max = 
-        (t_size > s_size || (t_size == s_size 
+      static const bool omit_chk_max =
+        (t_size > s_size || (t_size == s_size
          && (! t_is_signed || s_is_signed)));
       // If the check can be omitted, substitute constant false relation.
       typedef octave_int_cmp_op::cf cf;
       typedef octave_int_cmp_op::lt lt;
       typedef octave_int_cmp_op::gt gt;
       typedef typename if_then_else<omit_chk_min, cf, lt>::result chk_min;
       typedef typename if_then_else<omit_chk_max, cf, gt>::result chk_max;
 
@@ -253,33 +253,33 @@ public:
           return max_val ();
         }
       else
         return static_cast<T> (value);
     }
 
 private:
 
-  // Computes a real-valued threshold for a max/min check. 
+  // Computes a real-valued threshold for a max/min check.
   template <class S>
-  static S 
+  static S
   compute_threshold (S val, T orig_val)
-    { 
+    {
       val = xround (val); // Fool optimizations (maybe redundant)
       // If val is even, but orig_val is odd, we're one unit off.
       if (orig_val % 2 && val / 2 == xround (val / 2))
         // FIXME -- is this always correct?
-        val *= (static_cast<S>(1) - (std::numeric_limits<S>::epsilon () / 2)); 
+        val *= (static_cast<S>(1) - (std::numeric_limits<S>::epsilon () / 2));
       return val;
     }
-  
+
 public:
   // Convert a real number (check NaN and non-int).
   template <class S>
-  static T 
+  static T
   convert_real (const S& value)
     {
       // Compute proper thresholds.
       static const S thmin = compute_threshold (static_cast<S> (min_val ()), min_val ());
       static const S thmax = compute_threshold (static_cast<S> (max_val ()), max_val ());
       if (xisnan (value))
         {
           return static_cast<T> (0);
@@ -332,52 +332,52 @@ public:
   static T
   minus (T)
     {
       return static_cast<T> (0);
     }
 
   // the overflow behaviour for unsigned integers is guaranteed by C/C++,
   // so the following should always work.
-  static T 
+  static T
   add (T x, T y)
     {
       T u = x + y;
       if (u < x)
         {
           u = octave_int_base<T>::max_val ();
         }
       return u;
     }
 
-  static T 
+  static T
   sub (T x, T y)
     {
       T u = x - y;
       if (u > x)
         {
           u = 0;
         }
       return u;
     }
 
   // Multiplication is done using promotion to wider integer type. If there is
-  // no suitable promotion type, this operation *MUST* be specialized. 
-  static T 
+  // no suitable promotion type, this operation *MUST* be specialized.
+  static T
   mul (T x, T y)
     {
       // Promotion type for multiplication (if exists).
       typedef typename query_integer_type<2*sizeof (T), false>::type mptype;
-      return truncate_int (static_cast<mptype> (x) 
+      return truncate_int (static_cast<mptype> (x)
                            * static_cast<mptype> (y));
     }
 
   // Division with rounding to nearest. Note that / and % are probably
   // computed by a single instruction.
-  static T 
+  static T
   div (T x, T y)
     {
       if (y != 0)
         {
           T z = x / y, w = x % y;
           if (w >= y-w) z += 1;
           return z;
         }
@@ -414,17 +414,17 @@ octave_int_arith_base<uint64_t, false>::
       return octave_int_base<uint64_t>::max_val ();
     }
   else
     return static_cast<uint64_t> (p);
 }
 #else
 // Special handler for 64-bit integer multiply.
 template <>
-OCTAVE_API uint64_t 
+OCTAVE_API uint64_t
 octave_int_arith_base<uint64_t, false>::mul (uint64_t, uint64_t);
 #endif
 
 // Signed integer arithmetics.
 // Rationale: If HAVE_FAST_INT_OPS is defined, the following conditions
 // should hold:
 // 1. Signed numbers are represented by twos complement
 //    (see <http://en.wikipedia.org/wiki/Two%27s_complement>)
@@ -435,47 +435,47 @@ octave_int_arith_base<uint64_t, false>::
 //     need for things like -ftrapv).
 // 4. Bit operations on signed integers work like on unsigned integers,
 //    except for the shifts. Shifts are arithmetic.
 //
 // The above conditions are satisfied by most modern platforms. If
 // HAVE_FAST_INT_OPS is defined, bit tricks and wraparound arithmetics are used
 // to avoid conditional jumps as much as possible, thus being friendly to modern
 // pipeline processor architectures.
-// Otherwise, we fall back to a bullet-proof code that only uses assumptions 
+// Otherwise, we fall back to a bullet-proof code that only uses assumptions
 // guaranteed by the standard.
 
 template <class T>
 class octave_int_arith_base<T, true> : octave_int_base<T>
 {
   // The corresponding unsigned type.
   typedef typename query_integer_type<sizeof (T), false>::type UT;
 public:
 
   // Returns 1 for negative number, 0 otherwise.
   static T
-  signbit (T x) 
-    { 
+  signbit (T x)
+    {
 #ifdef HAVE_FAST_INT_OPS
       return static_cast<UT> (x) >> std::numeric_limits<T>::digits;
 #else
-      return (x < 0) ? 1 : 0; 
+      return (x < 0) ? 1 : 0;
 #endif
     }
 
   static T
   abs (T x)
     {
 #ifdef HAVE_FAST_INT_OPS
       // This is close to how GCC does std::abs, but we can't just use std::abs,
       // because its behaviour for INT_MIN is undefined and the compiler could
       // discard the following test.
       T m = x >> std::numeric_limits<T>::digits;
       T y = (x ^ m) - m;
-      if (y < 0) 
+      if (y < 0)
         {
           y = octave_int_base<T>::max_val ();
         }
       return y;
 #else
       // -INT_MAX is safe because C++ actually allows only three implementations
       // of integers: sign & magnitude, ones complement and twos complement.
       // The first test will, with modest optimizations, evaluate at compile
@@ -488,20 +488,20 @@ public:
         }
       else
         y = (x < 0) ? -x : x;
       return y;
 #endif
     }
 
   static T
-  signum (T x) 
-    { 
+  signum (T x)
+    {
       // With modest optimizations, this will compile without a jump.
-      return ((x > 0) ? 1 : 0) - signbit (x); 
+      return ((x > 0) ? 1 : 0) - signbit (x);
     }
 
   // FIXME -- we do not have an authority what signed shifts should
   // exactly do, so we define them the easy way. Note that Matlab does
   // not define signed shifts.
 
   static T
   rshift (T x, int n) { return x >> n; }
@@ -528,26 +528,26 @@ public:
           y = octave_int_base<T>::max_val ();
         }
       else
         y = -x;
       return y;
 #endif
     }
 
-  static T 
+  static T
   add (T x, T y)
     {
 #ifdef HAVE_FAST_INT_OPS
     // The typecasts do nothing, but they are here to prevent an optimizing
     // compiler from interfering. Also, the signed operations on small types
     // actually return int.
       T u = static_cast<UT> (x) + static_cast<UT> (y);
-      T ux = u ^ x, uy = u ^ y; 
-      if ((ux & uy) < 0) 
+      T ux = u ^ x, uy = u ^ y;
+      if ((ux & uy) < 0)
         {
           u = octave_int_base<T>::max_val () + signbit (~u);
         }
       return u;
 #else
       // We shall carefully avoid anything that may overflow.
       T u;
       if (y < 0)
@@ -569,26 +569,26 @@ public:
             u = x + y;
         }
 
       return u;
 #endif
     }
 
   // This is very similar to addition.
-  static T 
+  static T
   sub (T x, T y)
     {
 #ifdef HAVE_FAST_INT_OPS
     // The typecasts do nothing, but they are here to prevent an optimizing
     // compiler from interfering. Also, the signed operations on small types
     // actually return int.
       T u = static_cast<UT> (x) - static_cast<UT> (y);
-      T ux = u ^ x, uy = u ^ ~y; 
-      if ((ux & uy) < 0) 
+      T ux = u ^ x, uy = u ^ ~y;
+      if ((ux & uy) < 0)
         {
           u = octave_int_base<T>::max_val () + signbit (~u);
         }
       return u;
 #else
       // We shall carefully avoid anything that may overflow.
       T u;
       if (y < 0)
@@ -610,28 +610,28 @@ public:
             u = x - y;
         }
 
       return u;
 #endif
     }
 
   // Multiplication is done using promotion to wider integer type. If there is
-  // no suitable promotion type, this operation *MUST* be specialized. 
-  static T 
+  // no suitable promotion type, this operation *MUST* be specialized.
+  static T
   mul (T x, T y)
     {
       // Promotion type for multiplication (if exists).
       typedef typename query_integer_type<2*sizeof (T), true>::type mptype;
-      return truncate_int (static_cast<mptype> (x) 
+      return truncate_int (static_cast<mptype> (x)
                            * static_cast<mptype> (y));
     }
 
   // Division.
-  static T 
+  static T
   div (T x, T y)
     {
       T z;
       if (y == 0)
         {
           if (x < 0)
             z = octave_int_base<T>::min_val ();
           else if (x != 0)
@@ -645,29 +645,29 @@ public:
           if (y == -1 && x == octave_int_base<T>::min_val ())
             {
               z = octave_int_base<T>::max_val ();
             }
           else
             {
               z = x / y;
               T w = -octave_int_abs (x % y); // Can't overflow, but std::abs (x) can!
-              if (w <= y - w) 
+              if (w <= y - w)
                 z -= 1 - (signbit (x) << 1);
             }
         }
       else
         {
           z = x / y;
           // FIXME -- this is a workaround due to MSVC's absence of
           // std::abs (int64_t).  The call to octave_int_abs can't
           // overflow, but std::abs (x) can!
           T w = octave_int_abs (x % y);
 
-          if (w >= y - w) 
+          if (w >= y - w)
             z += 1 - (signbit (x) << 1);
         }
       return z;
     }
 
   // Remainder.
   static T
   rem (T x, T y)
@@ -708,43 +708,43 @@ octave_int_arith_base<int64_t, true>:: m
       return octave_int_base<int64_t>::min_val ();
     }
   else
     return static_cast<int64_t> (p);
 }
 #else
 // Special handler for 64-bit integer multiply.
 template <>
-OCTAVE_API int64_t 
+OCTAVE_API int64_t
 octave_int_arith_base<int64_t, true>::mul (int64_t, int64_t);
 #endif
 
 // This class simply selects the proper arithmetics.
 template<class T>
-class octave_int_arith 
+class octave_int_arith
  : public octave_int_arith_base<T, std::numeric_limits<T>::is_signed>
 {};
 
 template <class T>
 class
 octave_int : public octave_int_base<T>
 {
 public:
   typedef T val_type;
 
   octave_int (void) : ival () { }
 
   octave_int (T i) : ival (i) { }
 
-  octave_int (double d) : ival (octave_int_base<T>::convert_real (d)) { } 
+  octave_int (double d) : ival (octave_int_base<T>::convert_real (d)) { }
 
-  octave_int (float d) : ival (octave_int_base<T>::convert_real (d)) { } 
+  octave_int (float d) : ival (octave_int_base<T>::convert_real (d)) { }
 
 #ifdef OCTAVE_INT_USE_LONG_DOUBLE
-  octave_int (long double d) : ival (octave_int_base<T>::convert_real (d)) { } 
+  octave_int (long double d) : ival (octave_int_base<T>::convert_real (d)) { }
 #endif
 
   octave_int (bool b) : ival (b) { }
 
   template <class U>
   octave_int (const U& i) : ival(octave_int_base<T>::truncate_int (i)) { }
 
   template <class U>
@@ -826,17 +826,17 @@ public:
   static int nbits (void) { return std::numeric_limits<T>::digits; }
 
   static int byte_size (void) { return sizeof(T); }
 
   static const char *type_name ();
 
   // The following are provided for convenience.
   static const octave_int zero, one;
-  
+
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
   void *mex_get_data (void) const { return const_cast<T *> (&ival); }
 
 private:
 
   T ival;
 };
@@ -1069,20 +1069,20 @@ OCTAVE_INT_FLOAT_CMP_OP (!=)
 
 #undef OCTAVE_INT_FLOAT_CMP_OP
 
 template <class T>
 octave_int<T>
 xmax (const octave_int<T>& x, const octave_int<T>& y)
 {
   const T xv = x.value (), yv = y.value ();
-  return octave_int<T> (xv >= yv ? xv : yv); 
+  return octave_int<T> (xv >= yv ? xv : yv);
 }
 
 template <class T>
 octave_int<T>
 xmin (const octave_int<T>& x, const octave_int<T>& y)
 {
   const T xv = x.value (), yv = y.value ();
-  return octave_int<T> (xv <= yv ? xv : yv); 
+  return octave_int<T> (xv <= yv ? xv : yv);
 }
 
 #endif
diff --git a/liboctave/oct-locbuf.cc b/liboctave/oct-locbuf.cc
--- a/liboctave/oct-locbuf.cc
+++ b/liboctave/oct-locbuf.cc
@@ -29,28 +29,28 @@ along with Octave; see the file COPYING.
 
 // Query for configured chunk size, and if not defined, set it to 32 MB.
 // FIXME: 32MB is hard-coded. Maybe we could use something better, like
 // querying for available physical memory.
 #ifndef OCTAVE_LOCBUF_CHUNKSIZE_MB
 #define OCTAVE_LOCBUF_CHUNKSIZE_MB 32
 #endif
 
-// Each chunk will be at least this big. 
-const size_t octave_chunk_buffer::chunk_size = 
+// Each chunk will be at least this big.
+const size_t octave_chunk_buffer::chunk_size =
   static_cast<size_t> (OCTAVE_LOCBUF_CHUNKSIZE_MB) << 20;
 
 char *octave_chunk_buffer::top = 0, *octave_chunk_buffer::chunk = 0;
 size_t octave_chunk_buffer::left = 0;
 
-octave_chunk_buffer::octave_chunk_buffer (size_t size) : cnk (0), dat (0) 
+octave_chunk_buffer::octave_chunk_buffer (size_t size) : cnk (0), dat (0)
 {
   // Alignment mask. The size of double or long int, whichever is greater.
   // All data will be aligned to this size. If it's not enough for a type,
-  // that type should not be declared as POD. 
+  // that type should not be declared as POD.
   static const size_t align_mask = (sizeof (long) < sizeof (double)
                                     ? sizeof (double)
                                     : sizeof (long)) - 1;
 
   if (! size) return;
   // Align size. Note that size_t is unsigned, so size-1 must correctly
   // wrap around.
   size = ((size - 1) | align_mask) + 1;
diff --git a/liboctave/oct-locbuf.h b/liboctave/oct-locbuf.h
--- a/liboctave/oct-locbuf.h
+++ b/liboctave/oct-locbuf.h
@@ -29,20 +29,20 @@ along with Octave; see the file COPYING.
 // The default local buffer simply encapsulates an *array* pointer that gets
 // delete[]d automatically. For common POD types, we provide specializations.
 
 template <class T>
 class octave_local_buffer
 {
 public:
   octave_local_buffer (size_t size)
-    : data (0) 
-    { 
-      if (size) 
-        data = new T[size]; 
+    : data (0)
+    {
+      if (size)
+        data = new T[size];
     }
   ~octave_local_buffer (void) { delete [] data; }
   operator T *() const { return data; }
 
 private:
   T *data;
 
   // No copying!
@@ -169,17 +169,17 @@ public:
 #else
 
 // If we don't have automatic arrays, we simply always use octave_local_buffer.
 
 #define OCTAVE_LOCAL_BUFFER(T, buf, size) \
   octave_local_buffer<T> _buffer_ ## buf (size); \
   T *buf = _buffer_ ## buf
 
-#endif 
+#endif
 
 // Yeah overloading macros would be nice.
 // Note: we use weird variables in the for loop to avoid warnings about
 // shadowed parameters.
 #define OCTAVE_LOCAL_BUFFER_INIT(T, buf, size, value) \
   OCTAVE_LOCAL_BUFFER(T, buf, size); \
   for (size_t _buf_iter = 0, _buf_size = size; \
        _buf_iter < _buf_size; _buf_iter++) buf[_buf_iter] = value
diff --git a/liboctave/oct-md5.cc b/liboctave/oct-md5.cc
--- a/liboctave/oct-md5.cc
+++ b/liboctave/oct-md5.cc
@@ -41,27 +41,27 @@ oct_md5_result_to_str (const unsigned ch
   sprintf (tmp,
            "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
            buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6], buf[7],
            buf[8],  buf[9], buf[10], buf[11], buf[12], buf[13], buf[14],
            buf[15]);
 
   return std::string (tmp, 32);
 }
- 
+
 std::string
 oct_md5 (const std::string str)
 {
   unsigned char buf[16];
 
   md5_buffer (str.data (), str.length (), buf);
 
   return oct_md5_result_to_str (buf);
 }
-          
+
 std::string
 oct_md5_file (const std::string file)
 {
   std::string retval;
 
   FILE *ifile = fopen (file.c_str (), "rb");
 
   if (ifile)
diff --git a/liboctave/oct-mem.h b/liboctave/oct-mem.h
--- a/liboctave/oct-mem.h
+++ b/liboctave/oct-mem.h
@@ -73,26 +73,26 @@ DEFINE_POD_UCOPY (octave_int<T>)
 // Fill by value, with a check for zero. This boils down to memset if value is
 // a POD zero.
 template <class T>
 inline void fill_or_memset (size_t n, const T& value, T *dest)
 { std::fill_n (dest, n, value); }
 
 template <class T>
 inline bool helper_is_zero_mem (const T& value)
-{ 
+{
   typedef typename query_integer_type<sizeof (T), false>::type IT; // get integer type of the same size.
-  return *(reinterpret_cast<const IT *>(&value)) == 0; 
+  return *(reinterpret_cast<const IT *>(&value)) == 0;
 }
 
 template <class T>
 inline bool helper_is_zero_mem (const std::complex<T>& value)
 {
-  return (helper_is_zero_mem (value.real ()) 
-          && helper_is_zero_mem (value.imag ())); 
+  return (helper_is_zero_mem (value.real ())
+          && helper_is_zero_mem (value.imag ()));
 }
 
 template <class T>
 inline bool helper_is_zero_mem (const octave_int<T>& value)
 { return value.value () == T(); }
 
 #define DEFINE_POD_FILL(T) \
 inline void fill_or_memset (size_t n, const T& value, T *dest) \
@@ -119,21 +119,21 @@ DEFINE_POD_FILL (FloatComplex)
 
 template <class T>
 DEFINE_POD_FILL (octave_int<T>)
 
 // Uninitialized allocation. Will not initialize memory for complex and octave_int.
 // Memory allocated by octave_new should be freed by octave_delete.
 template <class T>
 inline T *no_ctor_new (size_t n)
-{ 
+{
   // Some systems let us allocate > 2GB memory even though size_t, which is either
   // buggy or completely cuckoo, so let's check here to stay safe.
   safe_size_comp (n, sizeof (T));
-  return new T[n]; 
+  return new T[n];
 }
 template <class T>
 inline void no_ctor_delete (T *ptr)
 { delete [] ptr; }
 
 #define DEFINE_POD_NEW_DELETE(T) \
 template <> \
 inline T *no_ctor_new<T > (size_t n) \
diff --git a/liboctave/oct-norm.cc b/liboctave/oct-norm.cc
--- a/liboctave/oct-norm.cc
+++ b/liboctave/oct-norm.cc
@@ -65,17 +65,17 @@ along with Octave; see the file COPYING.
 template <class R>
 class norm_accumulator_p
 {
   R p,scl,sum;
 public:
   norm_accumulator_p () {} // we need this one for Array
   norm_accumulator_p (R pp) : p(pp), scl(0), sum(1) {}
 
-  template<class U> 
+  template<class U>
   void accum (U val)
     {
       octave_quit ();
       R t = std::abs (val);
       if (scl == t) // we need this to handle Infs properly
         sum += 1;
       else if (scl < t)
         {
@@ -93,17 +93,17 @@ public:
 template <class R>
 class norm_accumulator_mp
 {
   R p,scl,sum;
 public:
   norm_accumulator_mp () {} // we need this one for Array
   norm_accumulator_mp (R pp) : p(pp), scl(0), sum(1) {}
 
-  template<class U> 
+  template<class U>
   void accum (U val)
     {
       octave_quit ();
       R t = 1 / std::abs (val);
       if (scl == t)
         sum += 1;
       else if (scl < t)
         {
@@ -152,62 +152,62 @@ public:
 
 // norm accumulator for the 1-norm (city metric)
 template <class R>
 class norm_accumulator_1
 {
   R sum;
 public:
   norm_accumulator_1 () : sum (0) {}
-  template<class U> 
+  template<class U>
   void accum (U val)
     {
-      sum += std::abs (val); 
+      sum += std::abs (val);
     }
   operator R () { return sum; }
 };
 
 // norm accumulator for the inf-norm (max metric)
 template <class R>
 class norm_accumulator_inf
 {
   R max;
 public:
   norm_accumulator_inf () : max (0) {}
-  template<class U> 
+  template<class U>
   void accum (U val)
     {
       max = std::max (max, std::abs (val));
     }
   operator R () { return max; }
 };
 
 // norm accumulator for the -inf pseudonorm (min abs value)
 template <class R>
 class norm_accumulator_minf
 {
   R min;
 public:
   norm_accumulator_minf () : min (octave_Inf) {}
-  template<class U> 
+  template<class U>
   void accum (U val)
     {
       min = std::min (min, std::abs (val));
     }
   operator R () { return min; }
 };
 
 // norm accumulator for the 0-pseudonorm (hamming distance)
 template <class R>
 class norm_accumulator_0
 {
   unsigned int num;
 public:
   norm_accumulator_0 () : num (0) {}
-  template<class U> 
+  template<class U>
   void accum (U val)
     {
       if (val != static_cast<U> (0)) ++num;
     }
   operator R () { return num; }
 };
 
 
@@ -236,17 +236,17 @@ void column_norms (const MArray<T>& m, M
       res.xelem (j) = accj;
     }
 }
 
 template <class T, class R, class ACC>
 void row_norms (const MArray<T>& m, MArray<R>& res, ACC acc)
 {
   res = MArray<R> (dim_vector (m.rows (), 1));
-  std::vector<ACC> acci (m.rows (), acc); 
+  std::vector<ACC> acci (m.rows (), acc);
   for (octave_idx_type j = 0; j < m.columns (); j++)
     {
       for (octave_idx_type i = 0; i < m.rows (); i++)
         acci[i].accum (m(i, j));
     }
 
   for (octave_idx_type i = 0; i < m.rows (); i++)
     res.xelem (i) = acci[i];
@@ -266,17 +266,17 @@ void column_norms (const MSparse<T>& m, 
       res.xelem (j) = accj;
     }
 }
 
 template <class T, class R, class ACC>
 void row_norms (const MSparse<T>& m, MArray<R>& res, ACC acc)
 {
   res = MArray<R> (dim_vector (m.rows (), 1));
-  std::vector<ACC> acci (m.rows (), acc); 
+  std::vector<ACC> acci (m.rows (), acc);
   for (octave_idx_type j = 0; j < m.columns (); j++)
     {
       for (octave_idx_type k = m.cidx (j); k < m.cidx (j+1); k++)
         acci[m.ridx (k)].accum (m.data (k));
     }
 
   for (octave_idx_type i = 0; i < m.rows (); i++)
     res.xelem (i) = acci[i];
@@ -313,57 +313,57 @@ DEFINE_DISPATCHER (column_norms, MArray<
 DEFINE_DISPATCHER (row_norms, MArray<T>, MArray<R>)
 DEFINE_DISPATCHER (column_norms, MSparse<T>, MArray<R>)
 DEFINE_DISPATCHER (row_norms, MSparse<T>, MArray<R>)
 
 // The approximate subproblem in Higham's method. Find lambda and mu such that
 // norm ([lambda, mu], p) == 1 and norm (y*lambda + col*mu, p) is maximized.
 // Real version. As in Higham's paper.
 template <class ColVectorT, class R>
-static void 
-higham_subp (const ColVectorT& y, const ColVectorT& col, 
+static void
+higham_subp (const ColVectorT& y, const ColVectorT& col,
              octave_idx_type nsamp, R p, R& lambda, R& mu)
 {
   R nrm = 0;
   for (octave_idx_type i = 0; i < nsamp; i++)
     {
       octave_quit ();
       R fi = i*M_PI/nsamp, lambda1 = cos (fi), mu1 = sin (fi);
-      R lmnr = std::pow (std::pow (std::abs (lambda1), p) + 
+      R lmnr = std::pow (std::pow (std::abs (lambda1), p) +
                          std::pow (std::abs (mu1), p), 1/p);
       lambda1 /= lmnr; mu1 /= lmnr;
       R nrm1 = vector_norm (lambda1 * y + mu1 * col, p);
       if (nrm1 > nrm)
         {
           lambda = lambda1;
           mu = mu1;
           nrm = nrm1;
         }
     }
 }
 
 // Complex version. Higham's paper does not deal with complex case, so we use a simple
 // extension. First, guess the magnitudes as in real version, then try to rotate lambda
 // to improve further.
 template <class ColVectorT, class R>
-static void 
-higham_subp (const ColVectorT& y, const ColVectorT& col, 
-             octave_idx_type nsamp, R p, 
+static void
+higham_subp (const ColVectorT& y, const ColVectorT& col,
+             octave_idx_type nsamp, R p,
              std::complex<R>& lambda, std::complex<R>& mu)
 {
   typedef std::complex<R> CR;
   R nrm = 0;
   lambda = 1.0;
   CR lamcu = lambda / std::abs (lambda);
   // Probe magnitudes
   for (octave_idx_type i = 0; i < nsamp; i++)
     {
       octave_quit ();
       R fi = i*M_PI/nsamp, lambda1 = cos (fi), mu1 = sin (fi);
-      R lmnr = std::pow (std::pow (std::abs (lambda1), p) + 
+      R lmnr = std::pow (std::pow (std::abs (lambda1), p) +
                          std::pow (std::abs (mu1), p), 1/p);
       lambda1 /= lmnr; mu1 /= lmnr;
       R nrm1 = vector_norm (lambda1 * lamcu * y + mu1 * col, p);
       if (nrm1 > nrm)
         {
           lambda = lambda1 * lamcu;
           mu = mu1;
           nrm = nrm1;
@@ -421,17 +421,17 @@ R higham (const MatrixT& m, R p, R tol, 
       VectorT col (m.column (k));
       if (k > 0)
         higham_subp (y, col, 4*k, p, lambda, mu);
       for (octave_idx_type i = 0; i < k; i++)
         x(i) *= lambda;
       x(k) = mu;
       y = lambda * y + mu * col;
     }
-  
+
   // the PM part
   x = x / vector_norm (x, p);
   R q = p/(p-1);
 
   R gamma = 0, gamma1;
   int iter = 0;
   while (iter < maxiter)
     {
@@ -450,17 +450,17 @@ R higham (const MatrixT& m, R p, R tol, 
       z = z.hermitian ();
       x = dual_p (z, q, p);
       iter ++;
     }
 
   return gamma;
 }
 
-// derive column vector and SVD types 
+// derive column vector and SVD types
 
 static const char *p_less1_gripe = "xnorm: p must be at least 1";
 
 // Static constant to control the maximum number of iterations. 100 seems to be a good value.
 // Eventually, we can provide a means to change this constant from Octave.
 static int max_norm_iter = 100;
 
 // version with SVD for dense matrices
@@ -479,17 +479,17 @@ R matrix_norm (const MatrixT& m, R p, Ve
     res = xrownorms (m, 1).max ();
   else if (p > 1)
     {
       VectorT x;
       const R sqrteps = std::sqrt (std::numeric_limits<R>::epsilon ());
       res = higham (m, p, sqrteps, max_norm_iter, x);
     }
   else
-    (*current_liboctave_error_handler) (p_less1_gripe); 
+    (*current_liboctave_error_handler) (p_less1_gripe);
 
   return res;
 }
 
 // SVD-free version for sparse matrices
 template <class MatrixT, class VectorT, class R>
 R matrix_norm (const MatrixT& m, R p, VectorT)
 {
@@ -500,17 +500,17 @@ R matrix_norm (const MatrixT& m, R p, Ve
     res = xrownorms (m, 1).max ();
   else if (p > 1)
     {
       VectorT x;
       const R sqrteps = std::sqrt (std::numeric_limits<R>::epsilon ());
       res = higham (m, p, sqrteps, max_norm_iter, x);
     }
   else
-    (*current_liboctave_error_handler) (p_less1_gripe); 
+    (*current_liboctave_error_handler) (p_less1_gripe);
 
   return res;
 }
 
 // and finally, here's what we've promised in the header file
 
 #define DEFINE_XNORM_FUNCS(PREFIX, RTYPE) \
   OCTAVE_API RTYPE xnorm (const PREFIX##ColumnVector& x, RTYPE p) \
diff --git a/liboctave/oct-norm.h b/liboctave/oct-norm.h
--- a/liboctave/oct-norm.h
+++ b/liboctave/oct-norm.h
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 #define DECLARE_XNORM_FUNCS(PREFIX, RTYPE) \
   class PREFIX##Matrix; \
   class PREFIX##ColumnVector; \
   class PREFIX##RowVector; \
   \
   extern OCTAVE_API RTYPE xnorm (const PREFIX##ColumnVector&, RTYPE p = 2); \
   extern OCTAVE_API RTYPE xnorm (const PREFIX##RowVector&, RTYPE p = 2); \
   extern OCTAVE_API RTYPE xnorm (const PREFIX##Matrix&, RTYPE p = 2); \
-  extern OCTAVE_API RTYPE xfrobnorm (const PREFIX##Matrix&); 
+  extern OCTAVE_API RTYPE xfrobnorm (const PREFIX##Matrix&);
 
 DECLARE_XNORM_FUNCS(, double)
 DECLARE_XNORM_FUNCS(Complex, double)
 DECLARE_XNORM_FUNCS(Float, float)
 DECLARE_XNORM_FUNCS(FloatComplex, float)
 
 DECLARE_XNORM_FUNCS(Sparse, double)
 DECLARE_XNORM_FUNCS(SparseComplex, double)
diff --git a/liboctave/oct-rand.cc b/liboctave/oct-rand.cc
--- a/liboctave/oct-rand.cc
+++ b/liboctave/oct-rand.cc
@@ -102,17 +102,17 @@ octave_rand::instance_ok (void)
   return retval;
 }
 
 double
 octave_rand::do_seed (void)
 {
   union d2i { double d; int32_t i[2]; };
   union d2i u;
-    
+
   oct_mach_info::float_format ff = oct_mach_info::native_float_format ();
 
   switch (ff)
     {
     case oct_mach_info::flt_fmt_ieee_big_endian:
       F77_FUNC (getsd, GETSD) (u.i[1], u.i[0]);
       break;
     default:
@@ -367,17 +367,17 @@ octave_rand::do_scalar (double a)
         case gamma_dist:
           if (a <= 0.0 || xisnan(a) || xisinf(a))
             retval = octave_NaN;
           else
             F77_FUNC (dgengam, DGENGAM) (1.0, a, retval);
           break;
 
         default:
-          (*current_liboctave_error_handler) 
+          (*current_liboctave_error_handler)
             ("rand: invalid distribution ID = %d", current_distribution);
           break;
         }
     }
   else
     {
       switch (current_distribution)
         {
diff --git a/liboctave/oct-rand.h b/liboctave/oct-rand.h
--- a/liboctave/oct-rand.h
+++ b/liboctave/oct-rand.h
@@ -73,24 +73,24 @@ public:
 
   // Set the current state/
   static void state (const ColumnVector &s,
                      const std::string& d = std::string ())
   {
     if (instance_ok ())
       instance->do_state (s, d);
   }
-  
+
   // Reset the current state/
   static void reset (const std::string& d)
   {
     if (instance_ok ())
       instance->do_reset (d);
   }
-  
+
   // Return the current distribution.
   static std::string distribution (void)
   {
     return instance_ok () ? instance->do_distribution () : std::string ();
   }
 
   // Set the current distribution.  May be either "uniform" (the
   // default), "normal", "exponential", "poisson", or "gamma".
@@ -189,20 +189,20 @@ private:
   // Reset the seed.
   void do_reset ();
 
   // Return the current state.
   ColumnVector do_state (const std::string& d);
 
   // Set the current state/
   void do_state (const ColumnVector &s, const std::string& d);
-  
+
   // Reset the current state/
   void do_reset (const std::string& d);
-  
+
   // Return the current distribution.
   std::string do_distribution (void);
 
   // Set the current distribution.  May be either "uniform" (the
   // default), "normal", "exponential", "poisson", or "gamma".
   void do_distribution (const std::string& d);
 
   void do_uniform_distribution (void);
diff --git a/liboctave/oct-rl-hist.c b/liboctave/oct-rl-hist.c
--- a/liboctave/oct-rl-hist.c
+++ b/liboctave/oct-rl-hist.c
@@ -98,17 +98,17 @@ octave_add_history (const char *line, in
 {
   if (check_history_control (line, history_control))
     {
       /* We're committed to saving the line.  If the user has requested it,
          remove other matching lines from the history.  */
 
       if (history_control & HC_ERASEDUPS)
         hc_erasedups (line);
-        
+
       add_history (line);
 
       return 1;
     }
 
   return 0;
 }
 
diff --git a/liboctave/oct-shlib.cc b/liboctave/oct-shlib.cc
--- a/liboctave/oct-shlib.cc
+++ b/liboctave/oct-shlib.cc
@@ -289,17 +289,17 @@ octave_shl_load_shlib::search (const std
   void *function = 0;
 
   if (is_open ())
     {
       std::string sym_name = name;
 
       if (mangler)
         sym_name = mangler (name);
-        
+
       int status = shl_findsym (&library, sym_name.c_str (),
                                 TYPE_UNDEFINED, &function);
     }
   else
     (*current_liboctave_error_handler)
       ("shared library %s is not open", file.c_str ());
 
   return function;
@@ -323,17 +323,17 @@ public:
 private:
 
   // No copying!
 
   octave_w32_shlib (const octave_w32_shlib&);
 
   octave_w32_shlib& operator = (const octave_w32_shlib&);
 
-  HINSTANCE handle; 
+  HINSTANCE handle;
 };
 
 octave_w32_shlib::octave_w32_shlib (const std::string& f)
   : octave_shlib::shlib_rep (f), handle (0)
 {
   handle = LoadLibrary (file.c_str ());
 
   if (! handle)
@@ -446,17 +446,17 @@ octave_dyld_shlib::octave_dyld_shlib (co
           const char *errstr = 0;
 
           NSLinkEditError (&ler, &lerno, &file2, &errstr);
 
           if (! errstr)
             errstr = "unspecified error";
 
           (*current_liboctave_error_handler)
-            ("%s: %s", file.c_str (), errstr);  
+            ("%s: %s", file.c_str (), errstr);
         }
     }
   else
     {
       (*current_liboctave_error_handler)
         ("got NSObjectFileImageReturnCode %d", returnCode);
 
       // FIXME -- should use NSLinkEditError () to get
diff --git a/liboctave/oct-shlib.h b/liboctave/oct-shlib.h
--- a/liboctave/oct-shlib.h
+++ b/liboctave/oct-shlib.h
@@ -37,17 +37,17 @@ public: // FIXME: make this class privat
 
   typedef std::string (*name_mangler) (const std::string&);
   typedef void (*close_hook) (const std::string&);
 
   class shlib_rep
   {
   public:
 
-    shlib_rep (void) 
+    shlib_rep (void)
       : count (1), file (), tm_loaded (time_t ()), fcn_names () { }
 
   protected:
 
     shlib_rep (const std::string& f);
 
   public:
 
@@ -84,17 +84,17 @@ public: // FIXME: make this class privat
     void do_close_hook (close_hook cl_hook);
 
   public:
 
     int count;
 
   protected:
 
-    void fake_reload (void); 
+    void fake_reload (void);
 
     std::string file;
     octave_time tm_loaded;
 
     // Set of hooked function names.
     typedef std::map<std::string, size_t>::iterator fcn_names_iterator;
     typedef std::map<std::string, size_t>::const_iterator fcn_names_const_iterator;
 
@@ -140,30 +140,30 @@ public:
       return *this;
     }
 
   bool operator == (const octave_shlib& sl) const
     { return (rep == sl.rep); }
 
   operator bool () const { return rep->is_open (); }
 
-  void open (const std::string& f) 
+  void open (const std::string& f)
     { *this = octave_shlib (f); }
 
   void close (close_hook cl_hook = 0)
-    { 
+    {
       if (cl_hook)
         rep->do_close_hook (cl_hook);
 
-      *this = octave_shlib (); 
+      *this = octave_shlib ();
     }
 
   void *search (const std::string& nm, name_mangler mangler = 0) const
-    { 
-      void *f = rep->search (nm, mangler); 
+    {
+      void *f = rep->search (nm, mangler);
       if (f)
         rep->add_fcn_name (nm);
 
       return f;
     }
 
   void add (const std::string& name)
     { rep->add_fcn_name (name); }
diff --git a/liboctave/oct-sort.cc b/liboctave/oct-sort.cc
--- a/liboctave/oct-sort.cc
+++ b/liboctave/oct-sort.cc
@@ -22,24 +22,24 @@ along with Octave; see the file COPYING.
 
 Code stolen in large part from Python's, listobject.c, which itself had
 no license header. However, thanks to Tim Peters for the parts of the
 code I ripped-off.
 
 As required in the Python license the short description of the changes
 made are
 
-* convert the sorting code in listobject.cc into a generic class, 
+* convert the sorting code in listobject.cc into a generic class,
   replacing PyObject* with the type of the class T.
 
 * replaced usages of malloc, free, memcpy and memmove by standard C++
   new [], delete [] and std::copy and std::copy_backward. Note that replacing
   memmove by std::copy is possible if the destination starts before the source.
   If not, std::copy_backward needs to be used.
-  
+
 * templatize comparison operator in most methods, provide possible dispatch
 
 * duplicate methods to avoid by-the-way indexed sorting
 
 * add methods for verifying sortedness of array
 
 * row sorting via breadth-first tree subsorting
 
@@ -112,30 +112,30 @@ The Python license is
 #include <stack>
 
 #include "lo-mappers.h"
 #include "quit.h"
 #include "oct-sort.h"
 #include "oct-locbuf.h"
 
 template <class T>
-octave_sort<T>::octave_sort (void) : 
+octave_sort<T>::octave_sort (void) :
   compare (ascending_compare), ms (0)
-{ 
+{
 }
 
 template <class T>
-octave_sort<T>::octave_sort (compare_fcn_type comp) 
+octave_sort<T>::octave_sort (compare_fcn_type comp)
   : compare (comp), ms (0)
-{ 
+{
 }
 
 template <class T>
-octave_sort<T>::~octave_sort () 
-{ 
+octave_sort<T>::~octave_sort ()
+{
   delete ms;
 }
 
 template <class T>
 void
 octave_sort<T>::set_compare (sortmode mode)
 {
   if (mode == ASCENDING)
@@ -144,40 +144,40 @@ octave_sort<T>::set_compare (sortmode mo
     compare = descending_compare;
   else
     compare = 0;
 }
 
 template <class T>
 template <class Comp>
 void
-octave_sort<T>::binarysort (T *data, octave_idx_type nel, 
+octave_sort<T>::binarysort (T *data, octave_idx_type nel,
                             octave_idx_type start, Comp comp)
 {
   if (start == 0)
     ++start;
 
-  for (; start < nel; ++start) 
+  for (; start < nel; ++start)
     {
       /* set l to where *start belongs */
       octave_idx_type l = 0, r = start;
       T pivot = data[start];
       /* Invariants:
        * pivot >= all in [lo, l).
        * pivot  < all in [r, start).
        * The second is vacuously true at the start.
        */
-      do 
+      do
         {
           octave_idx_type p = l + ((r - l) >> 1);
           if (comp (pivot, data[p]))
             r = p;
           else
             l = p+1;
-        } 
+        }
       while (l < r);
       /* The invariants still hold, so pivot >= all in [lo, l) and
          pivot < all in [l, start), so pivot belongs at l.  Note
          that if there are elements equal to pivot, l points to the
          first slot after them -- that's why this sort is stable.
          Slide over to make room.
          Caution: using memmove is much slower under MSVC 5;
          we're not usually moving many slots. */
@@ -188,40 +188,40 @@ octave_sort<T>::binarysort (T *data, oct
     }
 
   return;
 }
 
 template <class T>
 template <class Comp>
 void
-octave_sort<T>::binarysort (T *data, octave_idx_type *idx, octave_idx_type nel, 
+octave_sort<T>::binarysort (T *data, octave_idx_type *idx, octave_idx_type nel,
                             octave_idx_type start, Comp comp)
 {
   if (start == 0)
     ++start;
 
-  for (; start < nel; ++start) 
+  for (; start < nel; ++start)
     {
       /* set l to where *start belongs */
       octave_idx_type l = 0, r = start;
       T pivot = data[start];
       /* Invariants:
        * pivot >= all in [lo, l).
        * pivot  < all in [r, start).
        * The second is vacuously true at the start.
        */
-      do 
+      do
         {
           octave_idx_type p = l + ((r - l) >> 1);
           if (comp (pivot, data[p]))
             r = p;
           else
             l = p+1;
-        } 
+        }
       while (l < r);
       /* The invariants still hold, so pivot >= all in [lo, l) and
          pivot < all in [l, start), so pivot belongs at l.  Note
          that if there are elements equal to pivot, l points to the
          first slot after them -- that's why this sort is stable.
          Slide over to make room.
          Caution: using memmove is much slower under MSVC 5;
          we're not usually moving many slots. */
@@ -269,27 +269,27 @@ octave_sort<T>::count_run (T *lo, octave
   if (lo == hi)
     return 1;
 
   n = 2;
 
   if (comp (*lo, *(lo-1)))
     {
       descending = true;
-      for (lo = lo+1; lo < hi; ++lo, ++n) 
+      for (lo = lo+1; lo < hi; ++lo, ++n)
         {
           if (comp (*lo, *(lo-1)))
             ;
           else
             break;
         }
     }
-  else 
+  else
     {
-      for (lo = lo+1; lo < hi; ++lo, ++n) 
+      for (lo = lo+1; lo < hi; ++lo, ++n)
         {
           if (comp (*lo, *(lo-1)))
             break;
         }
     }
 
   return n;
 }
@@ -329,17 +329,17 @@ octave_sort<T>::gallop_left (T key, T *a
   lastofs = 0;
   ofs = 1;
   if (comp (*a, key))
     {
       /* a[hint] < key -- gallop right, until
        * a[hint + lastofs] < key <= a[hint + ofs]
        */
       const octave_idx_type maxofs = n - hint;  /* &a[n-1] is highest */
-      while (ofs < maxofs) 
+      while (ofs < maxofs)
         {
           if (comp (a[ofs], key))
             {
               lastofs = ofs;
               ofs = (ofs << 1) + 1;
               if (ofs <= 0)     /* int overflow */
                 ofs = maxofs;
             }
@@ -347,23 +347,23 @@ octave_sort<T>::gallop_left (T key, T *a
             break;
         }
       if (ofs > maxofs)
         ofs = maxofs;
       /* Translate back to offsets relative to &a[0]. */
       lastofs += hint;
       ofs += hint;
     }
-  else 
+  else
     {
       /* key <= a[hint] -- gallop left, until
        * a[hint - ofs] < key <= a[hint - lastofs]
        */
       const octave_idx_type maxofs = hint + 1;  /* &a[0] is lowest */
-      while (ofs < maxofs) 
+      while (ofs < maxofs)
         {
           if (comp (*(a-ofs), key))
             break;
           /* key <= a[hint - ofs] */
           lastofs = ofs;
           ofs = (ofs << 1) + 1;
           if (ofs <= 0) /* int overflow */
             ofs = maxofs;
@@ -377,17 +377,17 @@ octave_sort<T>::gallop_left (T key, T *a
     }
   a -= hint;
 
   /* Now a[lastofs] < key <= a[ofs], so key belongs somewhere to the
    * right of lastofs but no farther right than ofs.  Do a binary
    * search, with invariant a[lastofs-1] < key <= a[ofs].
    */
   ++lastofs;
-  while (lastofs < ofs) 
+  while (lastofs < ofs)
     {
       octave_idx_type m = lastofs + ((ofs - lastofs) >> 1);
 
       if (comp (a[m], key))
         lastofs = m+1;  /* a[m] < key */
       else
         ofs = m;        /* key <= a[m] */
     }
@@ -423,17 +423,17 @@ octave_sort<T>::gallop_right (T key, T *
   lastofs = 0;
   ofs = 1;
   if (comp (key, *a))
     {
       /* key < a[hint] -- gallop left, until
        * a[hint - ofs] <= key < a[hint - lastofs]
        */
       const octave_idx_type maxofs = hint + 1;  /* &a[0] is lowest */
-      while (ofs < maxofs) 
+      while (ofs < maxofs)
         {
           if (comp (key, *(a-ofs)))
             {
               lastofs = ofs;
               ofs = (ofs << 1) + 1;
               if (ofs <= 0)     /* int overflow */
                 ofs = maxofs;
             }
@@ -442,23 +442,23 @@ octave_sort<T>::gallop_right (T key, T *
         }
       if (ofs > maxofs)
         ofs = maxofs;
       /* Translate back to positive offsets relative to &a[0]. */
       k = lastofs;
       lastofs = hint - ofs;
       ofs = hint - k;
     }
-  else 
+  else
     {
       /* a[hint] <= key -- gallop right, until
        * a[hint + lastofs] <= key < a[hint + ofs]
        */
       const octave_idx_type maxofs = n - hint;  /* &a[n-1] is highest */
-      while (ofs < maxofs) 
+      while (ofs < maxofs)
         {
           if (comp (key, a[ofs]))
             break;
           /* a[hint + ofs] <= key */
           lastofs = ofs;
           ofs = (ofs << 1) + 1;
           if (ofs <= 0) /* int overflow */
             ofs = maxofs;
@@ -471,17 +471,17 @@ octave_sort<T>::gallop_right (T key, T *
     }
   a -= hint;
 
   /* Now a[lastofs] <= key < a[ofs], so key belongs somewhere to the
    * right of lastofs but no farther right than ofs.  Do a binary
    * search, with invariant a[lastofs-1] <= key < a[ofs].
    */
   ++lastofs;
-  while (lastofs < ofs) 
+  while (lastofs < ofs)
     {
       octave_idx_type m = lastofs + ((ofs - lastofs) >> 1);
 
       if (comp (key, a[m]))
         ofs = m;        /* key < a[m] */
       else
         lastofs = m+1;  /* a[m] <= key */
     }
@@ -531,17 +531,17 @@ roundupsize (octave_idx_type n)
  */
 template <class T>
 void
 octave_sort<T>::MergeState::getmem (octave_idx_type need)
 {
   if (need <= alloced)
     return;
 
-  need = roundupsize (need); 
+  need = roundupsize (need);
   /* Don't realloc!  That can cost cycles to copy the old data, but
    * we don't care what's in the block.
    */
   delete [] a;
   delete [] ia; // Must do this or fool possible next getmemi.
   a = new T[need];
   alloced = need;
 
@@ -549,17 +549,17 @@ octave_sort<T>::MergeState::getmem (octa
 
 template <class T>
 void
 octave_sort<T>::MergeState::getmemi (octave_idx_type need)
 {
   if (ia && need <= alloced)
     return;
 
-  need = roundupsize (need); 
+  need = roundupsize (need);
   /* Don't realloc!  That can cost cycles to copy the old data, but
    * we don't care what's in the block.
    */
   delete [] a;
   delete [] ia;
 
   a = new T[need];
   ia = new octave_idx_type[need];
@@ -570,17 +570,17 @@ octave_sort<T>::MergeState::getmemi (oct
  * in a stable way, in-place.  na and nb must be > 0, and pa + na == pb.
  * Must also have that *pb < *pa, that pa[na-1] belongs at the end of the
  * merge, and should have na <= nb.  See listsort.txt for more info.
  * Return 0 if successful, -1 if error.
  */
 template <class T>
 template <class Comp>
 int
-octave_sort<T>::merge_lo (T *pa, octave_idx_type na, 
+octave_sort<T>::merge_lo (T *pa, octave_idx_type na,
                           T *pb, octave_idx_type nb,
                           Comp comp)
 {
   octave_idx_type k;
   T *dest;
   int result = -1;      /* guilty until proved innocent */
   octave_idx_type min_gallop = ms->min_gallop;
 
@@ -605,17 +605,17 @@ octave_sort<T>::merge_lo (T *pa, octave_
       /* Do the straightforward thing until (if ever) one run
        * appears to win consistently.
        */
       for (;;)
         {
 
           // FIXME: these loops are candidates for further optimizations.
           // Rather than testing everything in each cycle, it may be more
-          // efficient to do it in hunks. 
+          // efficient to do it in hunks.
           if (comp (*pb, *pa))
             {
               *dest++ = *pb++;
               ++bcount;
               acount = 0;
               --nb;
               if (nb == 0)
                 goto Succeed;
@@ -705,17 +705,17 @@ octave_sort<T>::merge_lo (T *pa, octave_
   dest[nb] = *pa;
 
   return 0;
 }
 
 template <class T>
 template <class Comp>
 int
-octave_sort<T>::merge_lo (T *pa, octave_idx_type *ipa, octave_idx_type na, 
+octave_sort<T>::merge_lo (T *pa, octave_idx_type *ipa, octave_idx_type na,
                           T *pb, octave_idx_type *ipb, octave_idx_type nb,
                           Comp comp)
 {
   octave_idx_type k;
   T *dest;
   octave_idx_type *idest;
   int result = -1;      /* guilty until proved innocent */
   octave_idx_type min_gallop = ms->min_gallop;
@@ -852,17 +852,17 @@ octave_sort<T>::merge_lo (T *pa, octave_
  * in a stable way, in-place.  na and nb must be > 0, and pa + na == pb.
  * Must also have that *pb < *pa, that pa[na-1] belongs at the end of the
  * merge, and should have na >= nb.  See listsort.txt for more info.
  * Return 0 if successful, -1 if error.
  */
 template <class T>
 template <class Comp>
 int
-octave_sort<T>::merge_hi (T *pa, octave_idx_type na, 
+octave_sort<T>::merge_hi (T *pa, octave_idx_type na,
                           T *pb, octave_idx_type nb,
                           Comp comp)
 {
   octave_idx_type k;
   T *dest;
   int result = -1;      /* guilty until proved innocent */
   T *basea, *baseb;
   octave_idx_type min_gallop = ms->min_gallop;
@@ -878,38 +878,38 @@ octave_sort<T>::merge_hi (T *pa, octave_
 
   *dest-- = *pa--;
   --na;
   if (na == 0)
     goto Succeed;
   if (nb == 1)
     goto CopyA;
 
-  for (;;) 
+  for (;;)
     {
       octave_idx_type acount = 0;       /* # of times A won in a row */
       octave_idx_type bcount = 0;       /* # of times B won in a row */
 
       /* Do the straightforward thing until (if ever) one run
        * appears to win consistently.
        */
-      for (;;) 
+      for (;;)
         {
           if (comp (*pb, *pa))
             {
               *dest-- = *pa--;
               ++acount;
               bcount = 0;
               --na;
               if (na == 0)
                 goto Succeed;
               if (acount >= min_gallop)
                 break;
             }
-          else 
+          else
             {
               *dest-- = *pb--;
               ++bcount;
               acount = 0;
               --nb;
               if (nb == 1)
                 goto CopyA;
               if (bcount >= min_gallop)
@@ -918,26 +918,26 @@ octave_sort<T>::merge_hi (T *pa, octave_
         }
 
       /* One run is winning so consistently that galloping may
        * be a huge win.  So try that, and continue galloping until
        * (if ever) neither run appears to be winning consistently
        * anymore.
        */
       ++min_gallop;
-      do 
+      do
         {
           min_gallop -= min_gallop > 1;
           ms->min_gallop = min_gallop;
           k = gallop_right (*pb, basea, na, na-1, comp);
           if (k < 0)
             goto Fail;
           k = na - k;
           acount = k;
-          if (k) 
+          if (k)
             {
               dest = std::copy_backward (pa+1 - k, pa+1, dest+1) - 1;
               pa -= k;
               na -= k;
               if (na == 0)
                 goto Succeed;
             }
           *dest-- = *pb--;
@@ -945,17 +945,17 @@ octave_sort<T>::merge_hi (T *pa, octave_
           if (nb == 1)
             goto CopyA;
 
           k = gallop_left (*pa, baseb, nb, nb-1, comp);
           if (k < 0)
             goto Fail;
           k = nb - k;
           bcount = k;
-          if (k) 
+          if (k)
             {
               dest -= k;
               pb -= k;
               std::copy (pb+1, pb+1 + k, dest+1);
               nb -= k;
               if (nb == 1)
                 goto CopyA;
               /* nb==0 is impossible now if the comparison
@@ -989,17 +989,17 @@ CopyA:
   *dest = *pb;
 
   return 0;
 }
 
 template <class T>
 template <class Comp>
 int
-octave_sort<T>::merge_hi (T *pa, octave_idx_type *ipa, octave_idx_type na, 
+octave_sort<T>::merge_hi (T *pa, octave_idx_type *ipa, octave_idx_type na,
                           T *pb, octave_idx_type *ipb, octave_idx_type nb,
                           Comp comp)
 {
   octave_idx_type k;
   T *dest;
   octave_idx_type *idest;
   int result = -1;      /* guilty until proved innocent */
   T *basea, *baseb;
@@ -1019,38 +1019,38 @@ octave_sort<T>::merge_hi (T *pa, octave_
 
   *dest-- = *pa--; *idest-- = *ipa--;
   --na;
   if (na == 0)
     goto Succeed;
   if (nb == 1)
     goto CopyA;
 
-  for (;;) 
+  for (;;)
     {
       octave_idx_type acount = 0;       /* # of times A won in a row */
       octave_idx_type bcount = 0;       /* # of times B won in a row */
 
       /* Do the straightforward thing until (if ever) one run
        * appears to win consistently.
        */
-      for (;;) 
+      for (;;)
         {
           if (comp (*pb, *pa))
             {
               *dest-- = *pa--; *idest-- = *ipa--;
               ++acount;
               bcount = 0;
               --na;
               if (na == 0)
                 goto Succeed;
               if (acount >= min_gallop)
                 break;
             }
-          else 
+          else
             {
               *dest-- = *pb--; *idest-- = *ipb--;
               ++bcount;
               acount = 0;
               --nb;
               if (nb == 1)
                 goto CopyA;
               if (bcount >= min_gallop)
@@ -1059,26 +1059,26 @@ octave_sort<T>::merge_hi (T *pa, octave_
         }
 
       /* One run is winning so consistently that galloping may
        * be a huge win.  So try that, and continue galloping until
        * (if ever) neither run appears to be winning consistently
        * anymore.
        */
       ++min_gallop;
-      do 
+      do
         {
           min_gallop -= min_gallop > 1;
           ms->min_gallop = min_gallop;
           k = gallop_right (*pb, basea, na, na-1, comp);
           if (k < 0)
             goto Fail;
           k = na - k;
           acount = k;
-          if (k) 
+          if (k)
             {
               dest = std::copy_backward (pa+1 - k, pa+1, dest+1) - 1;
               idest = std::copy_backward (ipa+1 - k, ipa+1, idest+1) - 1;
               pa -= k; ipa -= k;
               na -= k;
               if (na == 0)
                 goto Succeed;
             }
@@ -1087,17 +1087,17 @@ octave_sort<T>::merge_hi (T *pa, octave_
           if (nb == 1)
             goto CopyA;
 
           k = gallop_left (*pa, baseb, nb, nb-1, comp);
           if (k < 0)
             goto Fail;
           k = nb - k;
           bcount = k;
-          if (k) 
+          if (k)
             {
               dest -= k; idest -= k;
               pb -= k; ipb -= k;
               std::copy (pb+1, pb+1 + k, dest+1);
               std::copy (ipb+1, ipb+1 + k, idest+1);
               nb -= k;
               if (nb == 1)
                 goto CopyA;
@@ -1258,27 +1258,27 @@ octave_sort<T>::merge_at (octave_idx_typ
  */
 template <class T>
 template <class Comp>
 int
 octave_sort<T>::merge_collapse (T *data, Comp comp)
 {
   struct s_slice *p = ms->pending;
 
-  while (ms->n > 1) 
+  while (ms->n > 1)
     {
       octave_idx_type n = ms->n - 2;
-      if (n > 0 && p[n-1].len <= p[n].len + p[n+1].len) 
+      if (n > 0 && p[n-1].len <= p[n].len + p[n+1].len)
         {
           if (p[n-1].len < p[n+1].len)
             --n;
           if (merge_at (n, data, comp) < 0)
             return -1;
         }
-      else if (p[n].len <= p[n+1].len) 
+      else if (p[n].len <= p[n+1].len)
         {
           if (merge_at (n, data, comp) < 0)
             return -1;
         }
       else
         break;
     }
 
@@ -1287,27 +1287,27 @@ octave_sort<T>::merge_collapse (T *data,
 
 template <class T>
 template <class Comp>
 int
 octave_sort<T>::merge_collapse (T *data, octave_idx_type *idx, Comp comp)
 {
   struct s_slice *p = ms->pending;
 
-  while (ms->n > 1) 
+  while (ms->n > 1)
     {
       octave_idx_type n = ms->n - 2;
-      if (n > 0 && p[n-1].len <= p[n].len + p[n+1].len) 
+      if (n > 0 && p[n-1].len <= p[n].len + p[n+1].len)
         {
           if (p[n-1].len < p[n+1].len)
             --n;
           if (merge_at (n, data, idx, comp) < 0)
             return -1;
         }
-      else if (p[n].len <= p[n+1].len) 
+      else if (p[n].len <= p[n+1].len)
         {
           if (merge_at (n, data, idx, comp) < 0)
             return -1;
         }
       else
         break;
     }
 
@@ -1321,17 +1321,17 @@ octave_sort<T>::merge_collapse (T *data,
  */
 template <class T>
 template <class Comp>
 int
 octave_sort<T>::merge_force_collapse (T *data, Comp comp)
 {
   struct s_slice *p = ms->pending;
 
-  while (ms->n > 1) 
+  while (ms->n > 1)
     {
       octave_idx_type n = ms->n - 2;
       if (n > 0 && p[n-1].len < p[n+1].len)
         --n;
       if (merge_at (n, data, comp) < 0)
         return -1;
     }
 
@@ -1340,17 +1340,17 @@ octave_sort<T>::merge_force_collapse (T 
 
 template <class T>
 template <class Comp>
 int
 octave_sort<T>::merge_force_collapse (T *data, octave_idx_type *idx, Comp comp)
 {
   struct s_slice *p = ms->pending;
 
-  while (ms->n > 1) 
+  while (ms->n > 1)
     {
       octave_idx_type n = ms->n - 2;
       if (n > 0 && p[n-1].len < p[n+1].len)
         --n;
       if (merge_at (n, data, idx, comp) < 0)
         return -1;
     }
 
@@ -1390,36 +1390,36 @@ octave_sort<T>::sort (T *data, octave_id
   /* Re-initialize the Mergestate as this might be the second time called */
   if (! ms) ms = new MergeState;
 
   ms->reset ();
   ms->getmem (1024);
 
   if (nel > 1)
     {
-      octave_idx_type nremaining = nel; 
+      octave_idx_type nremaining = nel;
       octave_idx_type lo = 0;
 
       /* March over the array once, left to right, finding natural runs,
        * and extending short natural runs to minrun elements.
        */
       octave_idx_type minrun = merge_compute_minrun (nremaining);
-      do 
+      do
         {
           bool descending;
           octave_idx_type n;
 
           /* Identify next run. */
           n = count_run (data + lo, nremaining, descending, comp);
           if (n < 0)
             goto fail;
           if (descending)
             std::reverse (data + lo, data + lo + n);
           /* If short, extend to min(minrun, nremaining). */
-          if (n < minrun) 
+          if (n < minrun)
             {
               const octave_idx_type force = nremaining <= minrun ? nremaining : minrun;
               binarysort (data + lo, force, n, comp);
               n = force;
             }
           /* Push run onto pending-runs stack, and maybe merge. */
           assert (ms->n < MAX_MERGE_PENDING);
           ms->pending[ms->n].base = lo;
@@ -1438,50 +1438,50 @@ octave_sort<T>::sort (T *data, octave_id
 
 fail:
   return;
 }
 
 template <class T>
 template <class Comp>
 void
-octave_sort<T>::sort (T *data, octave_idx_type *idx, octave_idx_type nel, 
+octave_sort<T>::sort (T *data, octave_idx_type *idx, octave_idx_type nel,
                       Comp comp)
 {
   /* Re-initialize the Mergestate as this might be the second time called */
   if (! ms) ms = new MergeState;
 
   ms->reset ();
   ms->getmemi (1024);
 
   if (nel > 1)
     {
-      octave_idx_type nremaining = nel; 
+      octave_idx_type nremaining = nel;
       octave_idx_type lo = 0;
 
       /* March over the array once, left to right, finding natural runs,
        * and extending short natural runs to minrun elements.
        */
       octave_idx_type minrun = merge_compute_minrun (nremaining);
-      do 
+      do
         {
           bool descending;
           octave_idx_type n;
 
           /* Identify next run. */
           n = count_run (data + lo, nremaining, descending, comp);
           if (n < 0)
             goto fail;
           if (descending)
             {
               std::reverse (data + lo, data + lo + n);
               std::reverse (idx + lo, idx + lo + n);
             }
           /* If short, extend to min(minrun, nremaining). */
-          if (n < minrun) 
+          if (n < minrun)
             {
               const octave_idx_type force = nremaining <= minrun ? nremaining : minrun;
               binarysort (data + lo, idx + lo, force, n, comp);
               n = force;
             }
           /* Push run onto pending-runs stack, and maybe merge. */
           assert (ms->n < MAX_MERGE_PENDING);
           ms->pending[ms->n].base = lo;
@@ -1506,17 +1506,17 @@ template <class T>
 void
 octave_sort<T>::sort (T *data, octave_idx_type nel)
 {
 #ifdef INLINE_ASCENDING_SORT
   if (compare == ascending_compare)
     sort (data, nel, std::less<T> ());
   else
 #endif
-#ifdef INLINE_DESCENDING_SORT    
+#ifdef INLINE_DESCENDING_SORT
     if (compare == descending_compare)
       sort (data, nel, std::greater<T> ());
   else
 #endif
     if (compare)
       sort (data, nel, compare);
 }
 
@@ -1524,27 +1524,27 @@ template <class T>
 void
 octave_sort<T>::sort (T *data, octave_idx_type *idx, octave_idx_type nel)
 {
 #ifdef INLINE_ASCENDING_SORT
   if (compare == ascending_compare)
     sort (data, idx, nel, std::less<T> ());
   else
 #endif
-#ifdef INLINE_DESCENDING_SORT    
+#ifdef INLINE_DESCENDING_SORT
     if (compare == descending_compare)
       sort (data, idx, nel, std::greater<T> ());
   else
 #endif
     if (compare)
       sort (data, idx, nel, compare);
 }
 
 template <class T> template <class Comp>
-bool 
+bool
 octave_sort<T>::is_sorted (const T *data, octave_idx_type nel, Comp comp)
 {
   const T *end = data + nel;
   if (data != end)
     {
       const T *next = data;
       while (++next != end)
         {
@@ -1553,27 +1553,27 @@ octave_sort<T>::is_sorted (const T *data
           data = next;
         }
       data = next;
     }
 
   return data == end;
 }
 
-template <class T> 
-bool 
+template <class T>
+bool
 octave_sort<T>::is_sorted (const T *data, octave_idx_type nel)
 {
   bool retval = false;
 #ifdef INLINE_ASCENDING_SORT
   if (compare == ascending_compare)
     retval = is_sorted (data, nel, std::less<T> ());
   else
 #endif
-#ifdef INLINE_DESCENDING_SORT    
+#ifdef INLINE_DESCENDING_SORT
     if (compare == descending_compare)
       retval = is_sorted (data, nel, std::greater<T> ());
   else
 #endif
     if (compare)
       retval = is_sorted (data, nel, compare);
 
   return retval;
@@ -1584,17 +1584,17 @@ struct sortrows_run_t
 {
   sortrows_run_t (octave_idx_type c, octave_idx_type o, octave_idx_type n)
     : col (c), ofs (o), nel (n) { }
   octave_idx_type col, ofs, nel;
 };
 
 
 template <class T> template <class Comp>
-void 
+void
 octave_sort<T>::sort_rows (const T *data, octave_idx_type *idx,
                            octave_idx_type rows, octave_idx_type cols,
                            Comp comp)
 {
   OCTAVE_LOCAL_BUFFER (T, buf, rows);
   for (octave_idx_type i = 0; i < rows; i++)
     idx[i] = i;
 
@@ -1642,42 +1642,42 @@ octave_sort<T>::sort_rows (const T *data
             }
           if (nel > lst + 1)
             runs.push (run_t (col+1, ofs + lst, nel - lst));
         }
     }
 }
 
 template <class T>
-void 
+void
 octave_sort<T>::sort_rows (const T *data, octave_idx_type *idx,
                            octave_idx_type rows, octave_idx_type cols)
 {
 #ifdef INLINE_ASCENDING_SORT
   if (compare == ascending_compare)
     sort_rows (data, idx, rows, cols, std::less<T> ());
   else
 #endif
-#ifdef INLINE_DESCENDING_SORT    
+#ifdef INLINE_DESCENDING_SORT
     if (compare == descending_compare)
       sort_rows (data, idx, rows, cols, std::greater<T> ());
   else
 #endif
     if (compare)
       sort_rows (data, idx, rows, cols, compare);
 }
 
 template <class T> template <class Comp>
-bool 
-octave_sort<T>::is_sorted_rows (const T *data, octave_idx_type rows, 
+bool
+octave_sort<T>::is_sorted_rows (const T *data, octave_idx_type rows,
                                 octave_idx_type cols, Comp comp)
 {
   if (rows <= 1 || cols == 0)
     return true;
-    
+
   // This is a breadth-first traversal.
   const T *lastrow = data + rows*(cols - 1);
   typedef std::pair<const T *, octave_idx_type> run_t;
   std::stack<run_t> runs;
 
   bool sorted = true;
   runs.push (run_t (data, rows));
   while (sorted && ! runs.empty ())
@@ -1712,47 +1712,47 @@ octave_sort<T>::is_sorted_rows (const T 
               sorted = false;
               break;
             }
         }
       else
         // The final column - use fast code.
         sorted = is_sorted (lo, n, comp);
     }
-      
+
   return sorted;
 }
 
 template <class T>
-bool 
-octave_sort<T>::is_sorted_rows (const T *data, octave_idx_type rows, 
+bool
+octave_sort<T>::is_sorted_rows (const T *data, octave_idx_type rows,
                                 octave_idx_type cols)
 {
   bool retval = false;
 
 #ifdef INLINE_ASCENDING_SORT
   if (compare == ascending_compare)
     retval = is_sorted_rows (data, rows, cols, std::less<T> ());
   else
 #endif
-#ifdef INLINE_DESCENDING_SORT    
+#ifdef INLINE_DESCENDING_SORT
     if (compare == descending_compare)
       retval = is_sorted_rows (data, rows, cols, std::greater<T> ());
   else
 #endif
     if (compare)
       retval = is_sorted_rows (data, rows, cols, compare);
 
   return retval;
 }
 
 // The simple binary lookup.
 
 template <class T> template <class Comp>
-octave_idx_type 
+octave_idx_type
 octave_sort<T>::lookup (const T *data, octave_idx_type nel,
                         const T& value, Comp comp)
 {
   octave_idx_type lo = 0, hi = nel;
 
   while (lo < hi)
     {
       octave_idx_type mid = lo + ((hi-lo) >> 1);
@@ -1761,73 +1761,73 @@ octave_sort<T>::lookup (const T *data, o
       else
         lo = mid + 1;
     }
 
   return lo;
 }
 
 template <class T>
-octave_idx_type 
+octave_idx_type
 octave_sort<T>::lookup (const T *data, octave_idx_type nel,
                         const T& value)
 {
   octave_idx_type retval = 0;
 
 #ifdef INLINE_ASCENDING_SORT
   if (compare == ascending_compare)
     retval = lookup (data, nel, value, std::less<T> ());
   else
 #endif
-#ifdef INLINE_DESCENDING_SORT    
+#ifdef INLINE_DESCENDING_SORT
     if (compare == descending_compare)
       retval = lookup (data, nel, value, std::greater<T> ());
   else
 #endif
     if (compare)
       retval = lookup (data, nel, value, std::ptr_fun (compare));
 
   return retval;
 }
 
 template <class T> template <class Comp>
-void 
+void
 octave_sort<T>::lookup (const T *data, octave_idx_type nel,
                         const T *values, octave_idx_type nvalues,
                         octave_idx_type *idx, Comp comp)
 {
   // Use a sequence of binary lookups.
   // TODO: Can this be sped up generally? The sorted merge case is dealt with
   // elsewhere.
   for (octave_idx_type j = 0; j < nvalues; j++)
     idx[j] = lookup (data, nel, values[j], comp);
 }
 
 template <class T>
-void 
+void
 octave_sort<T>::lookup (const T *data, octave_idx_type nel,
                         const T* values, octave_idx_type nvalues,
                         octave_idx_type *idx)
 {
 #ifdef INLINE_ASCENDING_SORT
   if (compare == ascending_compare)
     lookup (data, nel, values, nvalues, idx, std::less<T> ());
   else
 #endif
-#ifdef INLINE_DESCENDING_SORT    
+#ifdef INLINE_DESCENDING_SORT
     if (compare == descending_compare)
       lookup (data, nel, values, nvalues, idx, std::greater<T> ());
   else
 #endif
     if (compare)
       lookup (data, nel, values, nvalues, idx, std::ptr_fun (compare));
 }
 
 template <class T> template <class Comp>
-void 
+void
 octave_sort<T>::lookup_sorted (const T *data, octave_idx_type nel,
                                const T *values, octave_idx_type nvalues,
                                octave_idx_type *idx, bool rev, Comp comp)
 {
   if (rev)
     {
       octave_idx_type i = 0, j = nvalues - 1;
 
@@ -1869,89 +1869,89 @@ octave_sort<T>::lookup_sorted (const T *
         }
 
       for (; j != nvalues; j++)
         idx[j] = i;
     }
 }
 
 template <class T>
-void 
+void
 octave_sort<T>::lookup_sorted (const T *data, octave_idx_type nel,
                                const T* values, octave_idx_type nvalues,
                                octave_idx_type *idx, bool rev)
 {
 #ifdef INLINE_ASCENDING_SORT
   if (compare == ascending_compare)
     lookup_sorted (data, nel, values, nvalues, idx, rev, std::less<T> ());
   else
 #endif
-#ifdef INLINE_DESCENDING_SORT    
+#ifdef INLINE_DESCENDING_SORT
     if (compare == descending_compare)
       lookup_sorted (data, nel, values, nvalues, idx, rev, std::greater<T> ());
   else
 #endif
     if (compare)
       lookup_sorted (data, nel, values, nvalues, idx, rev, std::ptr_fun (compare));
 }
 
 template <class T> template <class Comp>
-void 
+void
 octave_sort<T>::nth_element (T *data, octave_idx_type nel,
                              octave_idx_type lo, octave_idx_type up,
                              Comp comp)
 {
   // Simply wrap the STL algorithms.
   // FIXME: this will fail if we attempt to inline <,> for Complex.
   if (up == lo+1)
     std::nth_element (data, data + lo, data + nel, comp);
   else if (lo == 0)
     std::partial_sort (data, data + up, data + nel, comp);
   else
     {
       std::nth_element (data, data + lo, data + nel, comp);
       if (up == lo + 2)
         {
           // Finding two subsequent elements.
-          std::swap (data[lo+1], 
+          std::swap (data[lo+1],
                      *std::min_element (data + lo + 1, data + nel, comp));
         }
       else
         std::partial_sort (data + lo + 1, data + up, data + nel, comp);
     }
 }
 
 template <class T>
-void 
+void
 octave_sort<T>::nth_element (T *data, octave_idx_type nel,
                              octave_idx_type lo, octave_idx_type up)
 {
   if (up < 0)
     up = lo + 1;
 #ifdef INLINE_ASCENDING_SORT
   if (compare == ascending_compare)
     nth_element (data, nel, lo, up, std::less<T> ());
   else
 #endif
-#ifdef INLINE_DESCENDING_SORT    
+#ifdef INLINE_DESCENDING_SORT
     if (compare == descending_compare)
       nth_element (data, nel, lo, up, std::greater<T> ());
   else
 #endif
     if (compare)
       nth_element (data, nel, lo, up, std::ptr_fun (compare));
 }
 
 template <class T>
-bool 
+bool
 octave_sort<T>::ascending_compare (typename ref_param<T>::type x,
                                    typename ref_param<T>::type y)
 {
   return x < y;
 }
 
 template <class T>
-bool 
+bool
 octave_sort<T>::descending_compare (typename ref_param<T>::type x,
                                     typename ref_param<T>::type y)
 {
   return x > y;
 }
diff --git a/liboctave/oct-sort.h b/liboctave/oct-sort.h
--- a/liboctave/oct-sort.h
+++ b/liboctave/oct-sort.h
@@ -20,17 +20,17 @@ along with Octave; see the file COPYING.
 
 Code stolen in large part from Python's, listobject.c, which itself had
 no license header. However, thanks to Tim Peters for the parts of the
 code I ripped-off.
 
 As required in the Python license the short description of the changes
 made are
 
-* convert the sorting code in listobject.cc into a generic class, 
+* convert the sorting code in listobject.cc into a generic class,
   replacing PyObject* with the type of the class T.
 
 The Python license is
 
   PSF LICENSE AGREEMENT FOR PYTHON 2.3
   --------------------------------------
 
   1. This LICENSE AGREEMENT is between the Python Software Foundation
@@ -109,18 +109,18 @@ octave_sort
 public:
 
   typedef bool (*compare_fcn_type) (typename ref_param<T>::type,
                                     typename ref_param<T>::type);
 
   octave_sort (void);
 
   octave_sort (compare_fcn_type);
-  
-  ~octave_sort (void); 
+
+  ~octave_sort (void);
 
   void set_compare (compare_fcn_type comp) { compare = comp; }
 
   void set_compare (sortmode mode);
 
   // Sort an array in-place.
   void sort (T *data, octave_idx_type nel);
 
@@ -131,17 +131,17 @@ public:
   bool is_sorted (const T *data, octave_idx_type nel);
 
   // Sort a matrix by rows, return a permutation
   // vector.
   void sort_rows (const T *data, octave_idx_type *idx,
                   octave_idx_type rows, octave_idx_type cols);
 
   // Determine whether a matrix (as a contiguous block) is sorted by rows.
-  bool is_sorted_rows (const T *data, 
+  bool is_sorted_rows (const T *data,
                        octave_idx_type rows, octave_idx_type cols);
 
   // Do a binary lookup in a sorted array.
   octave_idx_type lookup (const T *data, octave_idx_type nel,
                           const T& value);
 
   // Ditto, but for an array.
   void lookup (const T *data, octave_idx_type nel,
@@ -150,17 +150,17 @@ public:
 
   // A linear merge of two sorted tables. rev indicates the second table is
   // in reverse order.
   void lookup_sorted (const T *data, octave_idx_type nel,
                       const T* values, octave_idx_type nvalues,
                       octave_idx_type *idx, bool rev = false);
 
   // Rearranges the array so that the elements with indices
-  // lo..up-1 are in their correct place. 
+  // lo..up-1 are in their correct place.
   void nth_element (T *data, octave_idx_type nel,
                     octave_idx_type lo, octave_idx_type up = -1);
 
   static bool ascending_compare (typename ref_param<T>::type,
                                  typename ref_param<T>::type);
 
   static bool descending_compare (typename ref_param<T>::type,
                                   typename ref_param<T>::type);
@@ -169,32 +169,32 @@ private:
 
   // One MergeState exists on the stack per invocation of mergesort.
   // It's just a convenient way to pass state around among the helper
   // functions.
   //
   // DGB: This isn't needed with mergesort in a class, but it doesn't
   // slow things up, and it is likely to make my life easier for any
   // potential backporting of changes in the Python code.
-  
-  struct s_slice 
+
+  struct s_slice
   {
     octave_idx_type base, len;
   };
-  
-  struct MergeState 
+
+  struct MergeState
   {
     MergeState (void)
       : min_gallop (), a (0), ia (0), alloced (0), n (0)
       { reset (); }
-    
-    ~MergeState (void) 
+
+    ~MergeState (void)
       { delete [] a; delete [] ia; }
-    
-    void reset (void) 
+
+    void reset (void)
       { min_gallop = MIN_GALLOP; n = 0; }
 
     void getmem (octave_idx_type need);
 
     void getmemi (octave_idx_type need);
 
     // This controls when we get *into* galloping mode.  It's
     // initialized to MIN_GALLOP.  merge_lo and merge_hi tend to nudge
@@ -202,70 +202,70 @@ private:
     // data.
     octave_idx_type min_gallop;
 
     // 'a' is temp storage to help with merges.  It contains room for
     // alloced entries.
     T *a;               // may point to temparray below
     octave_idx_type *ia;
     octave_idx_type alloced;
-    
+
     // A stack of n pending runs yet to be merged.  Run #i starts at
     // address base[i] and extends for len[i] elements.  It's always
     // true (so long as the indices are in bounds) that
     //
     //   pending[i].base + pending[i].len == pending[i+1].base
     //
     // so we could cut the storage for this, but it's a minor amount,
     // and keeping all the info explicit simplifies the code.
     octave_idx_type n;
     struct s_slice pending[MAX_MERGE_PENDING];
   };
 
   compare_fcn_type compare;
-  
+
   MergeState *ms;
-  
-    
+
+
   template <class Comp>
-  void binarysort (T *data, octave_idx_type nel, 
+  void binarysort (T *data, octave_idx_type nel,
               octave_idx_type start, Comp comp);
-    
+
   template <class Comp>
-  void binarysort (T *data, octave_idx_type *idx, octave_idx_type nel, 
+  void binarysort (T *data, octave_idx_type *idx, octave_idx_type nel,
               octave_idx_type start, Comp comp);
-    
+
   template <class Comp>
   octave_idx_type count_run (T *lo, octave_idx_type n, bool& descending, Comp comp);
 
   template <class Comp>
   octave_idx_type gallop_left (T key, T *a, octave_idx_type n, octave_idx_type hint,
                                Comp comp);
 
   template <class Comp>
   octave_idx_type gallop_right (T key, T *a, octave_idx_type n, octave_idx_type hint,
                                 Comp comp);
 
   template <class Comp>
-  int merge_lo (T *pa, octave_idx_type na, 
+  int merge_lo (T *pa, octave_idx_type na,
                 T *pb, octave_idx_type nb,
                 Comp comp);
 
   template <class Comp>
-  int merge_lo (T *pa, octave_idx_type *ipa, octave_idx_type na, 
+  int merge_lo (T *pa, octave_idx_type *ipa, octave_idx_type na,
                 T *pb, octave_idx_type *ipb, octave_idx_type nb,
                 Comp comp);
 
   template <class Comp>
-  int merge_hi (T *pa, octave_idx_type na, 
+  int merge_hi (T *pa, octave_idx_type na,
                 T *pb, octave_idx_type nb,
                 Comp comp);
 
   template <class Comp>
-  int merge_hi (T *pa, octave_idx_type *ipa, octave_idx_type na, 
+  int merge_hi (T *pa, octave_idx_type *ipa, octave_idx_type na,
                 T *pb, octave_idx_type *ipb, octave_idx_type nb,
                 Comp comp);
 
   template <class Comp>
   int merge_at (octave_idx_type i, T *data,
                 Comp comp);
 
   template <class Comp>
@@ -296,17 +296,17 @@ private:
   bool is_sorted (const T *data, octave_idx_type nel, Comp comp);
 
   template <class Comp>
   void sort_rows (const T *data, octave_idx_type *idx,
                   octave_idx_type rows, octave_idx_type cols,
                   Comp comp);
 
   template <class Comp>
-  bool is_sorted_rows (const T *data, octave_idx_type rows, 
+  bool is_sorted_rows (const T *data, octave_idx_type rows,
                        octave_idx_type cols, Comp comp);
 
   template <class Comp>
   octave_idx_type lookup (const T *data, octave_idx_type nel,
                           const T& value, Comp comp);
 
   template <class Comp>
   void lookup (const T *data, octave_idx_type nel,
diff --git a/liboctave/oct-spparms.cc b/liboctave/oct-spparms.cc
--- a/liboctave/oct-spparms.cc
+++ b/liboctave/oct-spparms.cc
@@ -138,17 +138,17 @@ octave_sparse_params::do_tight (void)
   params(6) = 0.5;    // wh_frac
   params(7) = 1;      // autommd
   params(8) = 1;      // autoamd
   params(9) = 0.1;    // piv_tol
   params(10) = 0.5;   // bandden
   params(11) = 1;     // umfpack
   params(12) = 0.001; // sym_tol
 }
-  
+
 void
 octave_sparse_params::init_keys (void)
 {
   keys(0) = "spumoni";
   keys(1) = "ths_rel";
   keys(2) = "ths_abs";
   keys(3) = "exact_d";
   keys(4) = "supernd";
diff --git a/liboctave/oct-spparms.h b/liboctave/oct-spparms.h
--- a/liboctave/oct-spparms.h
+++ b/liboctave/oct-spparms.h
@@ -38,17 +38,17 @@ along with Octave; see the file COPYING.
 class
 OCTAVE_API
 octave_sparse_params
 {
 protected:
 
   octave_sparse_params (void)
     : params (OCTAVE_SPARSE_CONTROLS_SIZE),
-      keys (OCTAVE_SPARSE_CONTROLS_SIZE) 
+      keys (OCTAVE_SPARSE_CONTROLS_SIZE)
   {
     init_keys ();
     do_defaults ();
   }
 
 public:
 
   octave_sparse_params (const octave_sparse_params& a)
@@ -56,28 +56,28 @@ public:
 
   octave_sparse_params& operator = (const octave_sparse_params& a)
   {
     if (&a != this)
       {
         params = a.params;
         keys = a.keys;
       }
-    
+
     return *this;
   }
 
   ~octave_sparse_params (void) { }
 
   static bool instance_ok (void);
 
   static void defaults (void);
 
   static void tight (void);
-  
+
   static string_vector get_keys (void);
 
   static ColumnVector get_vals (void);
 
   static bool set_vals (const NDArray& vals);
 
   static bool set_key (const std::string& key, const double& val);
 
@@ -93,27 +93,27 @@ private:
 
   string_vector keys;
 
   static octave_sparse_params *instance;
 
   void do_defaults (void);
 
   void do_tight (void);
-  
+
   string_vector do_get_keys (void) const { return keys; }
 
   ColumnVector do_get_vals (void) const { return params; }
 
   bool do_set_vals (const NDArray& vals);
 
   bool do_set_key (const std::string& key, const double& val);
 
   double do_get_key (const std::string& key);
 
   double do_get_bandden (void);
 
   void do_print_info (std::ostream& os, const std::string& prefix) const;
-  
+
   void init_keys (void);
 };
 
 #endif
diff --git a/liboctave/oct-syscalls.cc b/liboctave/oct-syscalls.cc
--- a/liboctave/oct-syscalls.cc
+++ b/liboctave/oct-syscalls.cc
@@ -350,19 +350,19 @@ octave_syscalls::popen2 (const std::stri
                       if (execvp (cmd, args, child_msg) < 0)
                         child_msg = "popen2 (child): unable to start process -- " + child_msg;
                     }
                   else
                     child_msg = "popen2 (child): file handle duplication failed -- " + child_msg;
                 }
               else
                 child_msg = "popen2 (child): file handle duplication failed -- " + child_msg;
-              
+
               (*current_liboctave_error_handler)(child_msg.c_str());
-              
+
               exit(0);
             }
           else
             {
               // Parent process
               gnulib::close (child_stdin[0]);
               gnulib::close (child_stdout[1]);
 
diff --git a/liboctave/oct-time.cc b/liboctave/oct-time.cc
--- a/liboctave/oct-time.cc
+++ b/liboctave/oct-time.cc
@@ -37,17 +37,17 @@ along with Octave; see the file COPYING.
 #include "lo-math.h"
 #include "lo-utils.h"
 #include "oct-time.h"
 
 octave_time::octave_time (const octave_base_tm& tm)
   : ot_unix_time (), ot_usec ()
 {
   struct tm t;
-  
+
   t.tm_sec = tm.sec ();
   t.tm_min = tm.min ();
   t.tm_hour = tm.hour ();
   t.tm_mday = tm.mday ();
   t.tm_mon = tm.mon ();
   t.tm_year = tm.year ();
   t.tm_wday = tm.wday ();
   t.tm_yday = tm.yday ();
@@ -147,17 +147,17 @@ octave_base_tm::zone (const std::string&
 std::string
 octave_base_tm::strftime (const std::string& fmt) const
 {
   std::string retval;
 
   if (! fmt.empty ())
     {
       struct tm t;
-  
+
       t.tm_sec = tm_sec;
       t.tm_min = tm_min;
       t.tm_hour = tm_hour;
       t.tm_mday = tm_mday;
       t.tm_mon = tm_mon;
       t.tm_year = tm_year;
       t.tm_wday = tm_wday;
       t.tm_yday = tm_yday;
@@ -199,17 +199,17 @@ octave_base_tm::strftime (const std::str
 
 void
 octave_base_tm::init (void *p)
 {
   if (! p)
     return;
 
   struct tm *t = static_cast<struct tm*> (p);
-  
+
   tm_sec = t->tm_sec;
   tm_min = t->tm_min;
   tm_hour = t->tm_hour;
   tm_mday = t->tm_mday;
   tm_mon = t->tm_mon;
   tm_year = t->tm_year;
   tm_wday = t->tm_wday;
   tm_yday = t->tm_yday;
diff --git a/liboctave/randgamma.c b/liboctave/randgamma.c
--- a/liboctave/randgamma.c
+++ b/liboctave/randgamma.c
@@ -20,25 +20,25 @@ along with Octave; see the file COPYING.
 
 */
 
 /* Original version written by Paul Kienzle distributed as free
    software in the in the public domain.  */
 
 /*
 
-double randg(a) 
+double randg(a)
 void fill_randg(a,n,x)
 
 Generate a series of standard gamma distributions.
 
 See: Marsaglia G and Tsang W (2000), "A simple method for generating
 gamma variables", ACM Transactions on Mathematical Software 26(3) 363-372
 
-Needs the following defines: 
+Needs the following defines:
 * NAN: value to return for Not-A-Number
 * RUNI: uniform generator on (0,1)
 * RNOR: normal generator
 * REXP: exponential generator, or -log(RUNI) if one isn't available
 * INFINITE: function to test whether a value is infinite
 
 Test using:
   mean = a
@@ -90,54 +90,54 @@ Dirichlet(a1,...,ak) for ai > 0
 
 #undef NAN
 #define NAN octave_NaN
 #define INFINITE lo_ieee_isinf
 #define RUNI oct_randu()
 #define RNOR oct_randn()
 #define REXP oct_rande()
 
-void 
+void
 oct_fill_randg (double a, octave_idx_type n, double *r)
 {
   octave_idx_type i;
   /* If a < 1, start by generating gamma(1+a) */
   const double d =  (a < 1. ? 1.+a : a) - 1./3.;
   const double c = 1./sqrt(9.*d);
 
   /* Handle invalid cases */
-  if (a <= 0 || INFINITE(a)) 
+  if (a <= 0 || INFINITE(a))
     {
-      for (i=0; i < n; i++) 
+      for (i=0; i < n; i++)
         r[i] = NAN;
       return;
     }
 
-  for (i=0; i < n; i++) 
+  for (i=0; i < n; i++)
     {
       double x, xsq, v, u;
     restart:
       x = RNOR;
       v = (1+c*x);
       v *= v*v;
-      if (v <= 0) 
+      if (v <= 0)
         goto restart; /* rare, so don't bother moving up */
       u = RUNI;
       xsq = x*x;
       if (u >= 1.-0.0331*xsq*xsq && log(u) >= 0.5*xsq + d*(1-v+log(v)))
         goto restart;
       r[i] = d*v;
     }
-  if (a < 1) 
+  if (a < 1)
     { /* Use gamma(a) = gamma(1+a)*U^(1/a) */
       /* Given REXP = -log(U) then U^(1/a) = exp(-REXP/a) */
-      for (i = 0; i < n; i++) 
+      for (i = 0; i < n; i++)
         r[i] *= exp(-REXP/a);
     }
 }
 
-double 
+double
 oct_randg (double a)
 {
   double ret;
   oct_fill_randg(a,1,&ret);
   return ret;
 }
diff --git a/liboctave/randmtzig.c b/liboctave/randmtzig.c
--- a/liboctave/randmtzig.c
+++ b/liboctave/randmtzig.c
@@ -15,47 +15,47 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
-/* 
+/*
    A C-program for MT19937, with initialization improved 2002/2/10.
    Coded by Takuji Nishimura and Makoto Matsumoto.
    This is a faster version by taking Shawn Cokus's optimization,
    Matthe Bellew's simplification, Isaku Wada's real version.
    David Bateman added normal and exponential distributions following
    Marsaglia and Tang's Ziggurat algorithm.
 
    Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
    Copyright (C) 2004, David Bateman
    All rights reserved.
 
    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:
-   
+
      1. Redistributions of source code must retain the above copyright
         notice, this list of conditions and the following disclaimer.
 
      2. Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
         documentation and/or other materials provided with the distribution.
 
-     3. The names of its contributors may not be used to endorse or promote 
-        products derived from this software without specific prior written 
+     3. The names of its contributors may not be used to endorse or promote
+        products derived from this software without specific prior written
         permission.
 
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER 
+   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER
    OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
@@ -87,26 +87,26 @@ along with Octave; see the file COPYING.
    *
    * 2005-02-23 Paul Kienzle
    * * fix -DHAVE_X86_32 flag and add -DUSE_X86_32=0|1 for explicit control
    */
 
 /*
    === Build instructions ===
 
-   Compile with -DHAVE_GETTIMEOFDAY if the gettimeofday function is 
+   Compile with -DHAVE_GETTIMEOFDAY if the gettimeofday function is
    available.  This is not necessary if your architecture has
    /dev/urandom defined.
 
    Compile with -DALLBITS to disable 53-bit random numbers. This is about
    50% slower than using 32-bit random numbers.
 
-   Uses implicit -Di386 or explicit -DHAVE_X86_32 to determine if CPU=x86.  
-   You can force X86 behaviour with -DUSE_X86_32=1, or suppress it with 
-   -DUSE_X86_32=0. You should also consider -march=i686 or similar for 
+   Uses implicit -Di386 or explicit -DHAVE_X86_32 to determine if CPU=x86.
+   You can force X86 behaviour with -DUSE_X86_32=1, or suppress it with
+   -DUSE_X86_32=0. You should also consider -march=i686 or similar for
    extra performance. Check whether -DUSE_X86_32=0 is faster on 64-bit
    x86 architectures.
 
    If you want to replace the Mersenne Twister with another
    generator then redefine randi32 appropriately.
 
    === Usage instructions ===
    Before using any of the generators, initialize the state with one of
@@ -151,63 +151,63 @@ along with Octave; see the file COPYING.
 #include <time.h>
 
 #ifdef HAVE_GETTIMEOFDAY
 #include <sys/time.h>
 #endif
 
 #include "lo-math.h"
 #include "randmtzig.h"
-   
+
 /* FIXME may want to suppress X86 if sizeof(long)>4 */
 #if !defined(USE_X86_32)
 # if defined(i386) || defined(HAVE_X86_32)
 #  define USE_X86_32 1
 # else
 #  define USE_X86_32 0
 # endif
 #endif
 
-/* ===== Mersenne Twister 32-bit generator ===== */  
+/* ===== Mersenne Twister 32-bit generator ===== */
 
 #define MT_M 397
 #define MATRIX_A 0x9908b0dfUL   /* constant vector a */
 #define UMASK 0x80000000UL /* most significant w-r bits */
 #define LMASK 0x7fffffffUL /* least significant r bits */
 #define MIXBITS(u,v) ( ((u) & UMASK) | ((v) & LMASK) )
 #define TWIST(u,v) ((MIXBITS(u,v) >> 1) ^ ((v)&1UL ? MATRIX_A : 0UL))
 
 static uint32_t *next;
 static uint32_t state[MT_N]; /* the array for the state vector  */
 static int left = 1;
 static int initf = 0;
 static int initt = 1;
 
 /* initializes state[MT_N] with a seed */
-void 
+void
 oct_init_by_int (uint32_t s)
 {
     int j;
     state[0] = s & 0xffffffffUL;
     for (j = 1; j < MT_N; j++) {
-        state[j] = (1812433253UL * (state[j-1] ^ (state[j-1] >> 30)) + j); 
+        state[j] = (1812433253UL * (state[j-1] ^ (state[j-1] >> 30)) + j);
         /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
         /* In the previous versions, MSBs of the seed affect   */
         /* only MSBs of the array state[].                        */
         /* 2002/01/09 modified by Makoto Matsumoto             */
         state[j] &= 0xffffffffUL;  /* for >32 bit machines */
     }
-    left = 1; 
+    left = 1;
     initf = 1;
 }
 
 /* initialize by an array with array-length */
 /* init_key is the array for initializing keys */
 /* key_length is its length */
-void 
+void
 oct_init_by_array (uint32_t *init_key, int key_length)
 {
   int i, j, k;
   oct_init_by_int (19650218UL);
   i = 1;
   j = 0;
   k = (MT_N > key_length ? MT_N : key_length);
   for (; k; k--)
@@ -238,136 +238,136 @@ oct_init_by_array (uint32_t *init_key, i
         }
     }
 
   state[0] = 0x80000000UL; /* MSB is 1; assuring non-zero initial array */
   left = 1;
   initf = 1;
 }
 
-void 
+void
 oct_init_by_entropy (void)
 {
     uint32_t entropy[MT_N];
     int n = 0;
 
     /* Look for entropy in /dev/urandom */
     FILE* urandom =fopen("/dev/urandom", "rb");
-    if (urandom) 
+    if (urandom)
       {
-        while (n < MT_N) 
+        while (n < MT_N)
           {
             unsigned char word[4];
-            if (fread(word, 4, 1, urandom) != 1) 
+            if (fread(word, 4, 1, urandom) != 1)
               break;
             entropy[n++] = word[0]+(word[1]<<8)+(word[2]<<16)+(word[3]<<24);
           }
         fclose(urandom);
       }
 
     /* If there isn't enough entropy, gather some from various sources */
-    if (n < MT_N) 
+    if (n < MT_N)
       entropy[n++] = time(NULL); /* Current time in seconds */
-    if (n < MT_N) 
+    if (n < MT_N)
       entropy[n++] = clock();    /* CPU time used (usec) */
 #ifdef HAVE_GETTIMEOFDAY
-    if (n < MT_N) 
+    if (n < MT_N)
       {
         struct timeval tv;
         if (gettimeofday(&tv, NULL) != -1)
           entropy[n++] = tv.tv_usec;   /* Fractional part of current time */
       }
 #endif
     /* Send all the entropy into the initial state vector */
     oct_init_by_array(entropy,n);
 }
 
-void 
+void
 oct_set_state (uint32_t *save)
 {
   int i;
-  for (i = 0; i < MT_N; i++) 
+  for (i = 0; i < MT_N; i++)
     state[i] = save[i];
   left = save[MT_N];
   next = state + (MT_N - left + 1);
 }
 
-void 
+void
 oct_get_state (uint32_t *save)
 {
   int i;
-  for (i = 0; i < MT_N; i++) 
+  for (i = 0; i < MT_N; i++)
     save[i] = state[i];
   save[MT_N] = left;
 }
 
-static void 
+static void
 next_state (void)
 {
   uint32_t *p = state;
   int j;
 
   /* if init_by_int() has not been called, */
   /* a default initial seed is used         */
   /* if (initf==0) init_by_int(5489UL); */
   /* Or better yet, a random seed! */
-  if (initf == 0) 
+  if (initf == 0)
     oct_init_by_entropy();
 
   left = MT_N;
   next = state;
-    
-  for (j = MT_N - MT_M + 1; --j; p++) 
+
+  for (j = MT_N - MT_M + 1; --j; p++)
     *p = p[MT_M] ^ TWIST(p[0], p[1]);
 
-  for (j = MT_M; --j; p++) 
+  for (j = MT_M; --j; p++)
     *p = p[MT_M-MT_N] ^ TWIST(p[0], p[1]);
 
   *p = p[MT_M-MT_N] ^ TWIST(p[0], state[0]);
 }
 
 /* generates a random number on [0,0xffffffff]-interval */
 static uint32_t
 randmt (void)
 {
   register uint32_t y;
 
-  if (--left == 0) 
+  if (--left == 0)
     next_state();
   y = *next++;
 
   /* Tempering */
   y ^= (y >> 11);
   y ^= (y << 7) & 0x9d2c5680UL;
   y ^= (y << 15) & 0xefc60000UL;
   return (y ^ (y >> 18));
 }
 
 /* ===== Uniform generators ===== */
 
 /* Select which 32 bit generator to use */
 #define randi32 randmt
 
-static uint64_t 
+static uint64_t
 randi53 (void)
 {
   const uint32_t lo = randi32();
   const uint32_t hi = randi32()&0x1FFFFF;
 #if HAVE_X86_32
   uint64_t u;
   uint32_t *p = (uint32_t *)&u;
   p[0] = lo;
   p[1] = hi;
   return u;
 #else
   return (((uint64_t)hi<<32)|lo);
 #endif
 }
 
-static uint64_t 
+static uint64_t
 randi54 (void)
 {
   const uint32_t lo = randi32();
   const uint32_t hi = randi32()&0x3FFFFF;
 #if HAVE_X86_32
   uint64_t u;
   uint32_t *p = (uint32_t *)&u;
   p[0] = lo;
@@ -375,17 +375,17 @@ randi54 (void)
   return u;
 #else
   return (((uint64_t)hi<<32)|lo);
 #endif
 }
 
 #if 0
 // FIXME -- this doesn't seem to be used anywhere; should it be removed?
-static uint64_t 
+static uint64_t
 randi64 (void)
 {
   const uint32_t lo = randi32();
   const uint32_t hi = randi32();
 #if HAVE_X86_32
   uint64_t u;
   uint32_t *p = (uint32_t *)&u;
   p[0] = lo;
@@ -397,28 +397,28 @@ randi64 (void)
 }
 #endif
 
 #ifdef ALLBITS
 /* generates a random number on (0,1)-real-interval */
 static double
 randu32 (void)
 {
-  return ((double)randi32() + 0.5) * (1.0/4294967296.0); 
+  return ((double)randi32() + 0.5) * (1.0/4294967296.0);
   /* divided by 2^32 */
 }
 #else
 /* generates a random number on (0,1) with 53-bit resolution */
 static double
-randu53 (void) 
-{ 
+randu53 (void)
+{
   const uint32_t a=randi32()>>5;
-  const uint32_t b=randi32()>>6; 
+  const uint32_t b=randi32()>>6;
   return (a*67108864.0+b+0.4) * (1.0/9007199254740992.0);
-} 
+}
 #endif
 
 /* Determine mantissa for uniform doubles */
 double
 oct_randu (void)
 {
 #ifdef ALLBITS
   return randu32 ();
@@ -434,17 +434,17 @@ oct_randu (void)
 # define ERANDI randi32() /* 32 bits for mantissa */
 # define NMANTISSA 2147483648.0 /* 31 bit mantissa */
 # define NRANDI randi32() /* 31 bits for mantissa + 1 bit sign */
 # define RANDU randu32()
 #else
 # define ZIGINT uint64_t
 # define EMANTISSA 9007199254740992.0  /* 53 bit mantissa */
 # define ERANDI randi53() /* 53 bits for mantissa */
-# define NMANTISSA EMANTISSA  
+# define NMANTISSA EMANTISSA
 # define NRANDI randi54() /* 53 bits for mantissa + 1 bit sign */
 # define RANDU randu53()
 #endif
 
 #define ZIGGURAT_TABLE_SIZE 256
 
 #define ZIGGURAT_NOR_R 3.6541528853610088
 #define ZIGGURAT_NOR_INV_R 0.27366123732975828
@@ -458,65 +458,65 @@ static ZIGINT ki[ZIGGURAT_TABLE_SIZE];
 static double wi[ZIGGURAT_TABLE_SIZE], fi[ZIGGURAT_TABLE_SIZE];
 static ZIGINT ke[ZIGGURAT_TABLE_SIZE];
 static double we[ZIGGURAT_TABLE_SIZE], fe[ZIGGURAT_TABLE_SIZE];
 
 /*
 This code is based on the paper Marsaglia and Tsang, "The ziggurat method
 for generating random variables", Journ. Statistical Software. Code was
 presented in this paper for a Ziggurat of 127 levels and using a 32 bit
-integer random number generator. This version of the code, uses the 
-Mersenne Twister as the integer generator and uses 256 levels in the 
+integer random number generator. This version of the code, uses the
+Mersenne Twister as the integer generator and uses 256 levels in the
 Ziggurat. This has several advantages.
 
-  1) As Marsaglia and Tsang themselves states, the more levels the few 
+  1) As Marsaglia and Tsang themselves states, the more levels the few
      times the expensive tail algorithm must be called
-  2) The cycle time of the generator is determined by the integer 
-     generator, thus the use of a Mersenne Twister for the core random 
+  2) The cycle time of the generator is determined by the integer
+     generator, thus the use of a Mersenne Twister for the core random
      generator makes this cycle extremely long.
-  3) The license on the original code was unclear, thus rewriting the code 
+  3) The license on the original code was unclear, thus rewriting the code
      from the article means we are free of copyright issues.
   4) Compile flag for full 53-bit random mantissa.
 
 It should be stated that the authors made my life easier, by the fact that
 the algorithm developed in the text of the article is for a 256 level
 ziggurat, even if the code itself isn't...
 
 One modification to the algorithm developed in the article, is that it is
 assumed that 0 <= x < Inf, and "unsigned long"s are used, thus resulting in
 terms like 2^32 in the code. As the normal distribution is defined between
 -Inf < x < Inf, we effectively only have 31 bit integers plus a sign. Thus
 in Marsaglia and Tsang, terms like 2^32 become 2^31. We use NMANTISSA for
-this term.  The exponential distribution is one sided so we use the 
+this term.  The exponential distribution is one sided so we use the
 full 32 bits.  We use EMANTISSA for this term.
 
 It appears that I'm slightly slower than the code in the article, this
 is partially due to a better generator of random integers than they
 use. But might also be that the case of rapid return was optimized by
 inlining the relevant code with a #define. As the basic Mersenne
 Twister is only 25% faster than this code I suspect that the main
 reason is just the use of the Mersenne Twister and not the inlining,
 so I'm not going to try and optimize further.
 */
 
-static void 
+static void
 create_ziggurat_tables (void)
 {
   int i;
   double x, x1;
- 
+
   /* Ziggurat tables for the normal distribution */
   x1 = ZIGGURAT_NOR_R;
   wi[255] = x1 / NMANTISSA;
   fi[255] = exp (-0.5 * x1 * x1);
 
-  /* Index zero is special for tail strip, where Marsaglia and Tsang 
-   * defines this as 
+  /* Index zero is special for tail strip, where Marsaglia and Tsang
+   * defines this as
    * k_0 = 2^31 * r * f(r) / v, w_0 = 0.5^31 * v / f(r), f_0 = 1,
-   * where v is the area of each strip of the ziggurat. 
+   * where v is the area of each strip of the ziggurat.
    */
   ki[0] = (ZIGINT) (x1 * fi[255] / NOR_SECTION_AREA * NMANTISSA);
   wi[0] = NOR_SECTION_AREA / fi[255] / NMANTISSA;
   fi[0] = 1.;
 
   for (i = 254; i > 0; i--)
     {
       /* New x is given by x = f^{-1}(v/x_{i+1} + f(x_{i+1})), thus
@@ -531,20 +531,20 @@ create_ziggurat_tables (void)
 
   ki[1] = 0;
 
   /* Zigurrat tables for the exponential distribution */
   x1 = ZIGGURAT_EXP_R;
   we[255] = x1 / EMANTISSA;
   fe[255] = exp (-x1);
 
-  /* Index zero is special for tail strip, where Marsaglia and Tsang 
-   * defines this as 
+  /* Index zero is special for tail strip, where Marsaglia and Tsang
+   * defines this as
    * k_0 = 2^32 * r * f(r) / v, w_0 = 0.5^32 * v / f(r), f_0 = 1,
-   * where v is the area of each strip of the ziggurat. 
+   * where v is the area of each strip of the ziggurat.
    */
   ke[0] = (ZIGINT) (x1 * fe[255] / EXP_SECTION_AREA * EMANTISSA);
   we[0] = EXP_SECTION_AREA / fe[255] / EMANTISSA;
   fe[0] = 1.;
 
   for (i = 254; i > 0; i--)
     {
       /* New x is given by x = f^{-1}(v/x_{i+1} + f(x_{i+1})), thus
@@ -574,17 +574,17 @@ create_ziggurat_tables (void)
  *
  * Where f is the functional form of the distribution, which for a normal
  * distribution is exp(-0.5*x*x)
  */
 
 double
 oct_randn (void)
 {
-  if (initt) 
+  if (initt)
     create_ziggurat_tables();
 
   while (1)
     {
       /* The following code is specialized for 32-bit mantissa.
        * Compared to the arbitrary mantissa code, there is a performance
        * gain for 32-bits:  PPC: 2%, MIPS: 8%, x86: 40%
        * There is a bigger performance gain compared to using a full
@@ -622,82 +622,82 @@ oct_randn (void)
       const int idx = (int)(r&0xFF);
       const double x = ((int32_t)r) * wi[idx];
       if (rabs < ki[idx])
 #endif /* ALLBITS */
         return x;        /* 99.3% of the time we return here 1st try */
       else if (idx == 0)
         {
           /* As stated in Marsaglia and Tsang
-           * 
+           *
            * For the normal tail, the method of Marsaglia[5] provides:
            * generate x = -ln(U_1)/r, y = -ln(U_2), until y+y > x*x,
-           * then return r+x. Except that r+x is always in the positive 
+           * then return r+x. Except that r+x is always in the positive
            * tail!!!! Any thing random might be used to determine the
            * sign, but as we already have r we might as well use it
            *
            * [PAK] but not the bottom 8 bits, since they are all 0 here!
            */
           double xx, yy;
           do
             {
               xx = - ZIGGURAT_NOR_INV_R * log (RANDU);
               yy = - log (RANDU);
-            } 
+            }
           while ( yy+yy <= xx*xx);
           return (rabs&0x100 ? -ZIGGURAT_NOR_R-xx : ZIGGURAT_NOR_R+xx);
         }
       else if ((fi[idx-1] - fi[idx]) * RANDU + fi[idx] < exp(-0.5*x*x))
         return x;
     }
 }
 
 double
 oct_rande (void)
 {
-  if (initt) 
+  if (initt)
     create_ziggurat_tables();
 
   while (1)
     {
       ZIGINT ri = ERANDI;
       const int idx = (int)(ri & 0xFF);
       const double x = ri * we[idx];
       if (ri < ke[idx])
         return x;               // 98.9% of the time we return here 1st try
       else if (idx == 0)
         {
           /* As stated in Marsaglia and Tsang
-           * 
+           *
            * For the exponential tail, the method of Marsaglia[5] provides:
            * x = r - ln(U);
            */
           return ZIGGURAT_EXP_R - log(RANDU);
         }
       else if ((fe[idx-1] - fe[idx]) * RANDU + fe[idx] < exp(-x))
         return x;
     }
 }
 
 /* Array generators */
-void 
+void
 oct_fill_randu (octave_idx_type n, double *p)
 {
   octave_idx_type i;
-  for (i = 0; i < n; i++) 
+  for (i = 0; i < n; i++)
     p[i] = oct_randu();
 }
 
-void 
+void
 oct_fill_randn (octave_idx_type n, double *p)
 {
   octave_idx_type i;
-  for (i = 0; i < n; i++) 
+  for (i = 0; i < n; i++)
     p[i] = oct_randn();
 }
 
-void 
+void
 oct_fill_rande (octave_idx_type n, double *p)
 {
   octave_idx_type i;
-  for (i = 0; i < n; i++) 
+  for (i = 0; i < n; i++)
     p[i] = oct_rande();
 }
diff --git a/liboctave/randmtzig.h b/liboctave/randmtzig.h
--- a/liboctave/randmtzig.h
+++ b/liboctave/randmtzig.h
@@ -15,47 +15,47 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
-/* 
+/*
    A C-program for MT19937, with initialization improved 2002/2/10.
    Coded by Takuji Nishimura and Makoto Matsumoto.
    This is a faster version by taking Shawn Cokus's optimization,
    Matthe Bellew's simplification, Isaku Wada's real version.
    David Bateman added normal and exponential distributions following
    Marsaglia and Tang's Ziggurat algorithm.
 
    Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
    Copyright (C) 2004, David Bateman
    All rights reserved.
 
    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:
-   
+
      1. Redistributions of source code must retain the above copyright
         notice, this list of conditions and the following disclaimer.
 
      2. Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
         documentation and/or other materials provided with the distribution.
 
-     3. The names of its contributors may not be used to endorse or promote 
-        products derived from this software without specific prior written 
+     3. The names of its contributors may not be used to endorse or promote
+        products derived from this software without specific prior written
         permission.
 
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER 
+   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER
    OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
diff --git a/liboctave/randpoisson.c b/liboctave/randpoisson.c
--- a/liboctave/randpoisson.c
+++ b/liboctave/randpoisson.c
@@ -18,17 +18,17 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 /* Original version written by Paul Kienzle distributed as free
    software in the in the public domain.  */
 
-/* Needs the following defines: 
+/* Needs the following defines:
  * NAN: value to return for Not-A-Number
  * RUNI: uniform generator on (0,1)
  * RNOR: normal generator
  * LGAMMA: log gamma function
  * INFINITE: function to test whether a value is infinite
  */
 
 #if defined (HAVE_CONFIG_H)
@@ -72,17 +72,17 @@ xlgamma (double x)
     F77_XFCN (dlgams, DLGAMS, (&x, &result, &sgngam));
 #endif
   return result;
 }
 
 /* ---- pprsc.c from Stadloeber's winrand --- */
 
 /* flogfak(k) = ln(k!) */
-static double 
+static double
 flogfak (double k)
 {
 #define       C0      9.18938533204672742e-01
 #define       C1      8.33333333333333333e-02
 #define       C3     -2.77777777777777778e-03
 #define       C5      7.93650793650793651e-04
 #define       C7     -5.95238095238095238e-04
 
@@ -93,20 +93,20 @@ flogfak (double k)
     12.80182748008146961,  15.10441257307551530,  17.50230784587388584,
     19.98721449566188615,  22.55216385312342289,  25.19122118273868150,
     27.89927138384089157,  30.67186010608067280,  33.50507345013688888,
     36.39544520803305358,  39.33988418719949404,  42.33561646075348503,
     45.38013889847690803,  48.47118135183522388,  51.60667556776437357,
     54.78472939811231919,  58.00360522298051994,  61.26170176100200198,
     64.55753862700633106,  67.88974313718153498,  71.25703896716800901
   };
-  
+
   double  r, rr;
-  
-  if (k >= 30.0) 
+
+  if (k >= 30.0)
     {
       r  = 1.0 / k;
       rr = r * r;
       return ((k + 0.5)*log(k) - k + C0 + r*(C1 + rr*(C3 + rr*(C5 + rr*C7))));
     }
   else
     return (logfak[(int)k]);
 }
@@ -138,94 +138,94 @@ flogfak (double k)
  * SUBPROGRAM : - drand(seed) ... (0,1)-Uniform generator with    *
  *                unsigned long integer *seed.                    *
  *                                                                *
  * Implemented by H. Zechner, January 1994                        *
  * Revised by F. Niederl, July 1994                               *
  *                                                                *
  ******************************************************************/
 
-static double 
+static double
 f (double k, double l_nu, double c_pm)
 {
   return exp(k * l_nu - flogfak(k) - c_pm);
 }
 
-static double 
+static double
 pprsc (double my)
 {
   static double        my_last = -1.0;
   static double        m,  k2, k4, k1, k5;
   static double        dl, dr, r1, r2, r4, r5, ll, lr, l_my, c_pm,
     f1, f2, f4, f5, p1, p2, p3, p4, p5, p6;
   double               Dk, X, Y;
   double               Ds, U, V, W;
-  
+
   if (my != my_last)
     {                               /* set-up           */
       my_last = my;
       /* approximate deviation of reflection points k2, k4 from my - 1/2 */
       Ds = sqrt(my + 0.25);
-      
+
       /* mode m, reflection points k2 and k4, and points k1 and k5,      */
       /* which delimit the centre region of h(x)                         */
       m  = floor(my);
       k2 = ceil(my - 0.5 - Ds);
       k4 = floor(my - 0.5 + Ds);
       k1 = k2 + k2 - m + 1L;
       k5 = k4 + k4 - m;
-      
+
       /* range width of the critical left and right centre region        */
       dl = (k2 - k1);
       dr = (k5 - k4);
-      
+
       /* recurrence constants r(k)=p(k)/p(k-1) at k = k1, k2, k4+1, k5+1 */
       r1 = my / k1;
       r2 = my / k2;
       r4 = my / (k4 + 1.0);
       r5 = my / (k5 + 1.0);
 
       /* reciprocal values of the scale parameters of exp. tail envelope */
       ll =  log(r1);                                 /* expon. tail left */
       lr = -log(r5);                                 /* expon. tail right*/
-      
+
       /* Poisson constants, necessary for computing function values f(k) */
       l_my = log(my);
       c_pm = m * l_my - flogfak(m);
-      
+
       /* function values f(k) = p(k)/p(m) at k = k2, k4, k1, k5          */
       f2 = f(k2, l_my, c_pm);
       f4 = f(k4, l_my, c_pm);
       f1 = f(k1, l_my, c_pm);
       f5 = f(k5, l_my, c_pm);
-      
+
       /* area of the two centre and the two exponential tail regions     */
       /* area of the two immediate acceptance regions between k2, k4     */
       p1 = f2 * (dl + 1.0);                            /* immed. left    */
       p2 = f2 * dl         + p1;                       /* centre left    */
       p3 = f4 * (dr + 1.0) + p2;                       /* immed. right   */
       p4 = f4 * dr         + p3;                       /* centre right   */
       p5 = f1 / ll         + p4;                       /* exp. tail left */
       p6 = f5 / lr         + p5;                       /* exp. tail right*/
     }
-  
+
   for (;;)
     {
       /* generate uniform number U -- U(0, p6)                           */
       /* case distinction corresponding to U                             */
       if ((U = RUNI * p6) < p2)
         {                                            /* centre left      */
-          
-          /* immediate acceptance region 
+
+          /* immediate acceptance region
              R2 = [k2, m) *[0, f2),  X = k2, ... m -1 */
           if ((V = U - p1) < 0.0)  return(k2 + floor(U/f2));
-          /* immediate acceptance region 
+          /* immediate acceptance region
              R1 = [k1, k2)*[0, f1),  X = k1, ... k2-1 */
           if ((W = V / dl) < f1 )  return(k1 + floor(V/f1));
-          
+
           /* computation of candidate X < k2, and its counterpart Y > k2 */
           /* either squeeze-acceptance of X or acceptance-rejection of Y */
           Dk = floor(dl * RUNI) + 1.0;
           if (W <= f2 - Dk * (f2 - f2/r2))
             {                                        /* quick accept of  */
               return(k2 - Dk);                       /* X = k2 - Dk      */
             }
           if ((V = f2 + f2 - W) < 1.0)
@@ -236,23 +236,23 @@ pprsc (double my)
                   return(Y);                         /* Y = k2 + Dk      */
                 }
               if (V <= f(Y, l_my, c_pm))  return(Y); /* final accept of Y*/
             }
           X = k2 - Dk;
         }
       else if (U < p4)
         {                                            /* centre right     */
-          /*  immediate acceptance region 
+          /*  immediate acceptance region
               R3 = [m, k4+1)*[0, f4), X = m, ... k4    */
           if ((V = U - p3) < 0.0)  return(k4 - floor((U - p2)/f4));
-          /* immediate acceptance region 
+          /* immediate acceptance region
              R4 = [k4+1, k5+1)*[0, f5)                */
           if ((W = V / dr) < f5 )  return(k5 - floor(V/f5));
-          
+
           /* computation of candidate X > k4, and its counterpart Y < k4 */
           /* either squeeze-acceptance of X or acceptance-rejection of Y */
           Dk = floor(dr * RUNI) + 1.0;
           if (W <= f4 - Dk * (f4 - f4*r4))
             {                                        /* quick accept of  */
               return(k4 + Dk);                       /* X = k4 + Dk      */
             }
           if ((V = f4 + f4 - W) < 1.0)
@@ -269,177 +269,177 @@ pprsc (double my)
       else
         {
           W = RUNI;
           if (U < p5)
             {                                        /* expon. tail left */
               Dk = floor(1.0 - log(W)/ll);
               if ((X = k1 - Dk) < 0L)  continue;     /* 0 <= X <= k1 - 1 */
               W *= (U - p4) * ll;                    /* W -- U(0, h(x))  */
-              if (W <= f1 - Dk * (f1 - f1/r1))  
+              if (W <= f1 - Dk * (f1 - f1/r1))
                 return(X);                           /* quick accept of X*/
             }
           else
             {                                        /* expon. tail right*/
               Dk = floor(1.0 - log(W)/lr);
               X  = k5 + Dk;                          /* X >= k5 + 1      */
               W *= (U - p5) * lr;                    /* W -- U(0, h(x))  */
-              if (W <= f5 - Dk * (f5 - f5*r5))  
+              if (W <= f5 - Dk * (f5 - f5*r5))
                 return(X);                           /* quick accept of X*/
             }
         }
-      
+
       /* acceptance-rejection test of candidate X from the original area */
       /* test, whether  W <= f(k),    with  W = U*h(x)  and  U -- U(0, 1)*/
       /* log f(X) = (X - m)*log(my) - log X! + log m!                    */
       if (log(W) <= X * l_my - flogfak(X) - c_pm)  return(X);
     }
 }
 /* ---- pprsc.c end ------ */
 
 
 /* The remainder of the file is by Paul Kienzle */
 
 /* Given uniform u, find x such that CDF(L,x)==u.  Return x. */
-static void 
+static void
 poisson_cdf_lookup(double lambda, double *p, size_t n)
 {
   /* Table size is predicated on the maximum value of lambda
    * we want to store in the table, and the maximum value of
    * returned by the uniform random number generator on [0,1).
    * With lambda==10 and u_max = 1 - 1/(2^32+1), we
    * have poisson_pdf(lambda,36) < 1-u_max.  If instead our
    * generator uses more bits of mantissa or returns a value
-   * in the range [0,1], then for lambda==10 we need a table 
-   * size of 46 instead.  For long doubles, the table size 
+   * in the range [0,1], then for lambda==10 we need a table
+   * size of 46 instead.  For long doubles, the table size
    * will need to be longer still.  */
 #define TABLESIZE 46
   double t[TABLESIZE];
-  
+
   /* Precompute the table for the u up to and including 0.458.
    * We will almost certainly need it. */
   int intlambda = (int)floor(lambda);
   double P;
   int tableidx;
   size_t i = n;
-  
+
   t[0] = P = exp(-lambda);
   for (tableidx = 1; tableidx <= intlambda; tableidx++) {
     P = P*lambda/(double)tableidx;
     t[tableidx] = t[tableidx-1] + P;
   }
 
   while (i-- > 0) {
     double u = RUNI;
-    
+
     /* If u > 0.458 we know we can jump to floor(lambda) before
      * comparing (this observation is based on Stadlober's winrand
      * code). For lambda >= 1, this will be a win.  Lambda < 1
      * is already fast, so adding an extra comparison is not a
      * problem. */
     int k = (u > 0.458 ? intlambda : 0);
 
     /* We aren't using a for loop here because when we find the
      * right k we want to jump to the next iteration of the
-     * outer loop, and the continue statement will only work for 
+     * outer loop, and the continue statement will only work for
      * the inner loop. */
   nextk:
     if ( u <= t[k] ) {
       p[i] = (double) k;
       continue;
     }
     if (++k < tableidx) goto nextk;
-    
-    /* We only need high values of the table very rarely so we 
+
+    /* We only need high values of the table very rarely so we
      * don't automatically compute the entire table. */
     while (tableidx < TABLESIZE) {
       P = P*lambda/(double)tableidx;
       t[tableidx] = t[tableidx-1] + P;
       /* Make sure we converge to 1.0 just in case u is uniform
        * on [0,1] rather than [0,1). */
       if (t[tableidx] == t[tableidx-1]) t[tableidx] = 1.0;
       tableidx++;
       if (u <= t[tableidx-1]) break;
     }
-    
+
     /* We are assuming that the table size is big enough here.
      * This should be true even if RUNI is returning values in
      * the range [0,1] rather than [0,1).
      */
     p[i] = (double)(tableidx-1);
   }
 }
 
 /* From Press, et al., Numerical Recipes */
 static void
 poisson_rejection (double lambda, double *p, size_t n)
 {
   double sq = sqrt(2.0*lambda);
   double alxm = log(lambda);
   double g = lambda*alxm - LGAMMA(lambda+1.0);
   size_t i;
-  
-  for (i = 0; i < n; i++) 
+
+  for (i = 0; i < n; i++)
     {
       double y, em, t;
       do {
         do {
           y = tan(M_PI*RUNI);
           em = sq * y + lambda;
         } while (em < 0.0);
         em = floor(em);
         t = 0.9*(1.0+y*y)*exp(em*alxm-flogfak(em)-g);
       } while (RUNI > t);
       p[i] = em;
     }
 }
 
-/* The cutoff of L <= 1e8 in the following two functions before using 
+/* The cutoff of L <= 1e8 in the following two functions before using
  * the normal approximation is based on:
  *   > L=1e8; x=floor(linspace(0,2*L,1000));
  *   > max(abs(normal_pdf(x,L,L)-poisson_pdf(x,L)))
  *   ans =  1.1376e-28
  * For L=1e7, the max is around 1e-9, which is within the step size of RUNI.
  * For L>1e10 the pprsc function breaks down, as I saw from the histogram
  * of a large sample, so 1e8 is both small enough and large enough. */
 
 /* Generate a set of poisson numbers with the same distribution */
-void 
+void
 oct_fill_randp (double L, octave_idx_type n, double *p)
 {
   octave_idx_type i;
-  if (L < 0.0 || INFINITE(L)) 
+  if (L < 0.0 || INFINITE(L))
     {
-      for (i=0; i<n; i++) 
+      for (i=0; i<n; i++)
         p[i] = NAN;
-    } 
-  else if (L <= 10.0) 
+    }
+  else if (L <= 10.0)
     {
       poisson_cdf_lookup(L, p, n);
-    } 
-  else if (L <= 1e8) 
+    }
+  else if (L <= 1e8)
     {
-      for (i=0; i<n; i++) 
+      for (i=0; i<n; i++)
         p[i] = pprsc(L);
-    } 
-  else 
+    }
+  else
     {
       /* normal approximation: from Phys. Rev. D (1994) v50 p1284 */
       const double sqrtL = sqrt(L);
-      for (i = 0; i < n; i++) 
+      for (i = 0; i < n; i++)
         {
           p[i] = floor(RNOR*sqrtL + L + 0.5);
-          if (p[i] < 0.0) 
+          if (p[i] < 0.0)
             p[i] = 0.0; /* will probably never happen */
         }
     }
 }
 
 /* Generate one poisson variate */
-double 
+double
 oct_randp (double L)
 {
   double ret;
   if (L < 0.0) ret = NAN;
   else if (L <= 12.0) {
     /* From Press, et al. Numerical recipes */
     double g = exp(-L);
     int em = -1;
diff --git a/liboctave/regex-match.cc b/liboctave/regex-match.cc
--- a/liboctave/regex-match.cc
+++ b/liboctave/regex-match.cc
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 #include <vector>
 #include <iostream>
 #include <string>
 
 #include "regex-match.h"
 #include "str-vec.h"
 #include "oct-locbuf.h"
 
-regex_match& 
+regex_match&
 regex_match::operator = (const regex_match& gm)
 {
   if (this != &gm)
     {
 #if HAVE_REGEX
       for (int i = 0; i < pat.length (); i++)
         regfree (compiled +i);
       delete [] compiled;
@@ -54,86 +54,86 @@ regex_match::~regex_match (void)
 #if HAVE_REGEX
   for (int i = 0; i < pat.length (); i++)
     regfree (compiled +i);
   delete [] compiled;
 #endif
 }
 
 
-void 
-regex_match::set_pattern (const std::string& p) 
-{ 
+void
+regex_match::set_pattern (const std::string& p)
+{
 #if HAVE_REGEX
   for (int i = 0; i < pat.length (); i++)
     regfree (compiled +i);
   delete [] compiled;
 #endif
-  pat = p; 
+  pat = p;
   init ();
 }
 
-void 
-regex_match::set_pattern (const string_vector& p) 
-{ 
+void
+regex_match::set_pattern (const string_vector& p)
+{
 #if HAVE_REGEX
   for (int i = 0; i < pat.length (); i++)
     regfree (compiled +i);
   delete [] compiled;
 #endif
-  pat = p; 
+  pat = p;
   init ();
 }
 
 void
 regex_match::init (void)
 {
 #ifdef HAVE_REGEX
   int npat = pat.length ();
   int err = 0;
   int i;
 
   compiled = new regex_t [npat];
 
   for (i = 0; i < npat; i++)
     {
-      err = regcomp (compiled + i, pat(i).c_str (), 
+      err = regcomp (compiled + i, pat(i).c_str (),
                      (REG_NOSUB | REG_EXTENDED |
                       (case_insen ? REG_ICASE : 0)));
       if (err)
         break;
     }
-  
+
   if (err)
     {
       int len = regerror (err, compiled + i, 0, 0);
       OCTAVE_LOCAL_BUFFER (char, errmsg, len);
       regerror(err, compiled + i, errmsg, len);
-      (*current_liboctave_error_handler) ("%s in pattern (%s)", errmsg, 
+      (*current_liboctave_error_handler) ("%s in pattern (%s)", errmsg,
                                           pat(i).c_str());
 
       for (int j = 0; j < i + 1; j++)
         regfree (compiled + j);
     }
 #else
-  (*current_liboctave_error_handler) 
-    ("regex not available in this version of Octave"); 
+  (*current_liboctave_error_handler)
+    ("regex not available in this version of Octave");
 #endif
 }
 
 bool
 regex_match::match (const std::string& s)
 {
 #if HAVE_REGEX
   int npat = pat.length ();
 
   const char *str = s.c_str ();
 
   for (int i = 0; i < npat; i++)
-    if (regexec (compiled + i, str, 0, 0, 0) == 0) 
+    if (regexec (compiled + i, str, 0, 0, 0) == 0)
       return true;
 #endif
 
   return false;
 }
 
 Array<bool>
 regex_match::match (const string_vector& s)
diff --git a/liboctave/regex-match.h b/liboctave/regex-match.h
--- a/liboctave/regex-match.h
+++ b/liboctave/regex-match.h
@@ -37,35 +37,35 @@ along with Octave; see the file COPYING.
 #include "str-vec.h"
 
 class
 OCTAVE_API
 regex_match
 {
 public:
 
-  regex_match (const std::string& p, bool insen = false) 
+  regex_match (const std::string& p, bool insen = false)
     : pat (p), case_insen (insen)
 #if HAVE_REGEX
       , compiled (0)
 #endif
     {
       init ();
     }
 
-  regex_match (const string_vector& p = string_vector (), bool insen = false) 
+  regex_match (const string_vector& p = string_vector (), bool insen = false)
     : pat (p), case_insen (insen)
 #if HAVE_REGEX
       , compiled (0)
 #endif
     {
       init ();
     }
 
-  regex_match (const regex_match& gm) 
+  regex_match (const regex_match& gm)
     : pat (gm.pat), case_insen (gm.case_insen)
 #if HAVE_REGEX
       , compiled (0)
 #endif
     {
       init ();
     }
 
diff --git a/liboctave/sparse-base-chol.cc b/liboctave/sparse-base-chol.cc
--- a/liboctave/sparse-base-chol.cc
+++ b/liboctave/sparse-base-chol.cc
@@ -31,18 +31,18 @@ along with Octave; see the file COPYING.
 #include "oct-sparse.h"
 #include "oct-spparms.h"
 #include "quit.h"
 #include "MatrixType.h"
 
 #ifdef HAVE_CHOLMOD
 // Can't use CHOLMOD_NAME(drop)(0.0, S, cm). It doesn't treat complex matrices
 template <class chol_type, class chol_elt, class p_type>
-void 
-sparse_base_chol<chol_type, chol_elt, p_type>::sparse_base_chol_rep::drop_zeros 
+void
+sparse_base_chol<chol_type, chol_elt, p_type>::sparse_base_chol_rep::drop_zeros
   (const cholmod_sparse* S)
 {
   chol_elt sik;
   octave_idx_type *Sp, *Si;
   chol_elt *Sx;
   octave_idx_type pdest, k, ncol, p, pend;
 
   if (! S)
@@ -74,27 +74,27 @@ sparse_base_chol<chol_type, chol_elt, p_
         }
     }
   Sp [ncol] = pdest;
 }
 #endif
 
 template <class chol_type, class chol_elt, class p_type>
 octave_idx_type
-sparse_base_chol<chol_type, chol_elt, p_type>::sparse_base_chol_rep::init 
+sparse_base_chol<chol_type, chol_elt, p_type>::sparse_base_chol_rep::init
   (const chol_type& a, bool natural)
 {
   volatile octave_idx_type info = 0;
 #ifdef HAVE_CHOLMOD
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
     {
-      (*current_liboctave_error_handler) 
+      (*current_liboctave_error_handler)
         ("SparseCHOL requires square matrix");
       return -1;
     }
 
   cholmod_common *cm = &Common;
 
   // Setup initial parameters
   CHOLMOD_NAME(start) (cm);
@@ -184,17 +184,17 @@ sparse_base_chol<chol_type, chol_elt, p_
 
       if (minor_p > 0 && minor_p < a_nr)
         {
           size_t n1 = a_nr + 1;
           Lsparse->p = CHOLMOD_NAME(realloc) (minor_p+1,
                                               sizeof(octave_idx_type),
                                               Lsparse->p, &n1, cm);
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
-          CHOLMOD_NAME(reallocate_sparse) 
+          CHOLMOD_NAME(reallocate_sparse)
             (static_cast<octave_idx_type *>(Lsparse->p)[minor_p], Lsparse, cm);
           END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
           Lsparse->ncol = minor_p;
         }
 
       drop_zeros (Lsparse);
 
       if (! natural)
@@ -208,24 +208,24 @@ sparse_base_chol<chol_type, chol_elt, p_
 
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       CHOLMOD_NAME(free_factor) (&Lfactor, cm);
       CHOLMOD_NAME(finish) (cm);
       CHOLMOD_NAME(print_common) (tmp, cm);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
     }
 #else
-  (*current_liboctave_error_handler) 
+  (*current_liboctave_error_handler)
     ("Missing CHOLMOD. Sparse cholesky factorization disabled");
 #endif
   return info;
 }
 
 template <class chol_type, class chol_elt, class p_type>
-chol_type 
+chol_type
 sparse_base_chol<chol_type, chol_elt, p_type>::L (void) const
 {
 #ifdef HAVE_CHOLMOD
   cholmod_sparse *m = rep->L();
   octave_idx_type nc = m->ncol;
   octave_idx_type nnz = m->nzmax;
   chol_type ret (m->nrow, nc, nnz);
   for (octave_idx_type j = 0; j < nc+1; j++)
@@ -237,17 +237,17 @@ sparse_base_chol<chol_type, chol_elt, p_
     }
   return ret;
 #else
   return chol_type();
 #endif
 }
 
 template <class chol_type, class chol_elt, class p_type>
-p_type 
+p_type
 sparse_base_chol<chol_type, chol_elt, p_type>::
 sparse_base_chol_rep::Q (void) const
 {
 #ifdef HAVE_CHOLMOD
   octave_idx_type n = Lsparse->nrow;
   p_type p (n, n, n);
 
   for (octave_idx_type i = 0; i < n; i++)
@@ -260,17 +260,17 @@ sparse_base_chol_rep::Q (void) const
 
   return p;
 #else
   return p_type();
 #endif
 }
 
 template <class chol_type, class chol_elt, class p_type>
-chol_type 
+chol_type
 sparse_base_chol<chol_type, chol_elt, p_type>::inverse (void) const
 {
   chol_type retval;
 #ifdef HAVE_CHOLMOD
   cholmod_sparse *m = rep->L();
   octave_idx_type n = m->ncol;
   ColumnVector perms = rep->perm();
   chol_type ret;
diff --git a/liboctave/sparse-base-chol.h b/liboctave/sparse-base-chol.h
--- a/liboctave/sparse-base-chol.h
+++ b/liboctave/sparse-base-chol.h
@@ -43,35 +43,35 @@ protected:
 
     sparse_base_chol_rep (const chol_type& a, const bool natural)
       : count (1), Lsparse (0), Common (), is_pd (false), minor_p (0),
         perms (), cond (0)
       {
         init (a, natural);
       }
 
-    sparse_base_chol_rep (const chol_type& a, octave_idx_type& info, 
+    sparse_base_chol_rep (const chol_type& a, octave_idx_type& info,
                           const bool natural)
       : count (1), Lsparse (0), Common (), is_pd (false), minor_p (0),
         perms (), cond (0)
       {
         info = init (a, natural);
       }
 
     ~sparse_base_chol_rep (void)
       {
         if (is_pd)
           CHOLMOD_NAME (free_sparse) (&Lsparse, &Common);
       }
 
     cholmod_sparse * L (void) const { return Lsparse; }
 
-    octave_idx_type P (void) const 
+    octave_idx_type P (void) const
       {
-        return (minor_p == static_cast<octave_idx_type>(Lsparse->ncol) ? 
+        return (minor_p == static_cast<octave_idx_type>(Lsparse->ncol) ?
                 0 : minor_p + 1);
       }
 
     ColumnVector perm (void) const { return perms + 1; }
 
     p_type Q (void) const;
 
     bool is_positive_definite (void) const { return is_pd; }
@@ -102,22 +102,22 @@ protected:
   };
 #else
   class sparse_base_chol_rep
   {
   public:
     sparse_base_chol_rep (void)
       : count (1), is_pd (false), minor_p (0), perms (), cond (0) { }
 
-    sparse_base_chol_rep (const chol_type& a, 
+    sparse_base_chol_rep (const chol_type& a,
                           const bool natural)
       : count (1), is_pd (false), minor_p (0), perms (), cond (0)
       { init (a, natural); }
 
-    sparse_base_chol_rep (const chol_type& a, octave_idx_type& info, 
+    sparse_base_chol_rep (const chol_type& a, octave_idx_type& info,
                           const bool natural)
       : count (1), is_pd (false), minor_p (0), perms (), cond (0)
       { info = init (a, natural); }
 
     ~sparse_base_chol_rep (void) { }
 
     octave_idx_type P (void) const { return 0; }
 
@@ -144,38 +144,38 @@ protected:
 
     // No assignment
     sparse_base_chol_rep& operator = (const sparse_base_chol_rep& a);
   };
 #endif
 
  private:
   sparse_base_chol_rep *rep;
-  
+
 public:
 
   sparse_base_chol (void)
-    : rep (new typename 
+    : rep (new typename
            sparse_base_chol<chol_type, chol_elt, p_type>::sparse_base_chol_rep ())
     { }
 
   sparse_base_chol (const chol_type& a, const bool n)
     : rep (new typename
            sparse_base_chol<chol_type, chol_elt, p_type>::sparse_base_chol_rep (a, n))
     { }
 
   sparse_base_chol (const chol_type& a, octave_idx_type& info, const bool n)
     : rep (new typename sparse_base_chol<chol_type, chol_elt, p_type>::sparse_base_chol_rep (a, info, n))
     { }
 
   sparse_base_chol (const sparse_base_chol<chol_type, chol_elt, p_type>& a)
     : rep (a.rep)
     { rep->count++; }
 
-  virtual ~sparse_base_chol (void) 
+  virtual ~sparse_base_chol (void)
     {
       if (--rep->count <= 0)
         delete rep;
     }
 
   sparse_base_chol& operator = (const sparse_base_chol& a)
     {
       if (this != &a)
@@ -195,17 +195,17 @@ public:
   chol_type R (void) const { return L().hermitian (); }
 
   octave_idx_type P (void) const { return rep->P(); }
 
   ColumnVector perm (void) const { return rep->perm(); }
 
   p_type Q (void) const { return rep->Q(); }
 
-  bool is_positive_definite (void) const 
+  bool is_positive_definite (void) const
     { return rep->is_positive_definite(); }
 
   double rcond (void) const { return rep->rcond(); }
 
   chol_type inverse (void) const;
 };
 
 #endif
diff --git a/liboctave/sparse-base-lu.cc b/liboctave/sparse-base-lu.cc
--- a/liboctave/sparse-base-lu.cc
+++ b/liboctave/sparse-base-lu.cc
@@ -43,18 +43,18 @@ sparse_base_lu <lu_type, lu_elt_type, p_
     {
       for (octave_idx_type i = Ufact.cidx (j); i < Ufact.cidx(j + 1); i++)
         {
           Yout.xridx (ii) = Ufact.ridx(i);
           Yout.xdata (ii++) = Ufact.data(i);
         }
       if (j < rcmin)
         {
-          // Note the +1 skips the 1.0 on the diagonal 
-          for (octave_idx_type i = Lfact.cidx (j) + 1; 
+          // Note the +1 skips the 1.0 on the diagonal
+          for (octave_idx_type i = Lfact.cidx (j) + 1;
                i < Lfact.cidx(j +1); i++)
             {
               Yout.xridx (ii) = Lfact.ridx(i);
               Yout.xdata (ii++) = Lfact.data(i);
             }
         }
       Yout.xcidx(j + 1) = ii;
     }
diff --git a/liboctave/sparse-base-lu.h b/liboctave/sparse-base-lu.h
--- a/liboctave/sparse-base-lu.h
+++ b/liboctave/sparse-base-lu.h
@@ -32,17 +32,17 @@ template <class lu_type, class lu_elt_ty
 class
 sparse_base_lu
 {
 public:
 
   sparse_base_lu (void)
     : Lfact (), Ufact (), Rfact (), cond (0), P (), Q () { }
 
-  sparse_base_lu (const sparse_base_lu& a) 
+  sparse_base_lu (const sparse_base_lu& a)
     : Lfact (a.Lfact), Ufact (a.Ufact), Rfact (), cond (a.cond),
     P (a.P), Q (a.Q)
     { }
 
   sparse_base_lu& operator = (const sparse_base_lu& a)
     {
       if (this != &a)
         {
diff --git a/liboctave/sparse-dmsolve.cc b/liboctave/sparse-dmsolve.cc
--- a/liboctave/sparse-dmsolve.cc
+++ b/liboctave/sparse-dmsolve.cc
@@ -31,28 +31,28 @@ along with Octave; see the file COPYING.
 #include "SparseQR.h"
 #include "SparseCmplxQR.h"
 #include "MatrixType.h"
 #include "oct-sort.h"
 #include "oct-locbuf.h"
 
 template <class T>
 static MSparse<T>
-dmsolve_extract (const MSparse<T> &A, const octave_idx_type *Pinv, 
-                const octave_idx_type *Q, octave_idx_type rst, 
-                octave_idx_type rend, octave_idx_type cst, 
+dmsolve_extract (const MSparse<T> &A, const octave_idx_type *Pinv,
+                const octave_idx_type *Q, octave_idx_type rst,
+                octave_idx_type rend, octave_idx_type cst,
                 octave_idx_type cend, octave_idx_type maxnz = -1,
                 bool lazy = false)
 {
   octave_idx_type nz = (rend - rst) * (cend - cst);
   maxnz = (maxnz < 0 ? A.nnz () : maxnz);
   MSparse<T> B (rend - rst, cend - cst, (nz < maxnz ? nz : maxnz));
   // Some sparse functions can support lazy indexing (where elements
-  // in the row are in no particular order), even though octave in 
-  // general can't. For those functions that can using it is a big 
+  // in the row are in no particular order), even though octave in
+  // general can't. For those functions that can using it is a big
   // win here in terms of speed.
   if (lazy)
     {
       nz = 0;
       for (octave_idx_type j = cst ; j < cend ; j++)
         {
           octave_idx_type qq = (Q ? Q [j] : j);
           B.xcidx (j - cst) = nz;
@@ -86,45 +86,45 @@ dmsolve_extract (const MSparse<T> &A, co
               if (r >= rst && r < rend)
                 {
                   X [r-rst] = A.data (p);
                   B.xridx (nz++) =  r - rst ;
                 }
             }
           sort.sort (ri + B.xcidx (j - cst), nz - B.xcidx (j - cst));
           for (octave_idx_type p = B.cidx (j - cst); p < nz; p++)
-            B.xdata (p) = X [B.xridx (p)]; 
+            B.xdata (p) = X [B.xridx (p)];
         }
       B.xcidx (cend - cst) = nz ;
     }
 
   return B;
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 static MSparse<double>
-dmsolve_extract (const MSparse<double> &A, const octave_idx_type *Pinv, 
-                const octave_idx_type *Q, octave_idx_type rst, 
-                octave_idx_type rend, octave_idx_type cst, 
+dmsolve_extract (const MSparse<double> &A, const octave_idx_type *Pinv,
+                const octave_idx_type *Q, octave_idx_type rst,
+                octave_idx_type rend, octave_idx_type cst,
                 octave_idx_type cend, octave_idx_type maxnz,
                 bool lazy);
 
 static MSparse<Complex>
-dmsolve_extract (const MSparse<Complex> &A, const octave_idx_type *Pinv, 
-                const octave_idx_type *Q, octave_idx_type rst, 
-                octave_idx_type rend, octave_idx_type cst, 
+dmsolve_extract (const MSparse<Complex> &A, const octave_idx_type *Pinv,
+                const octave_idx_type *Q, octave_idx_type rst,
+                octave_idx_type rend, octave_idx_type cst,
                 octave_idx_type cend, octave_idx_type maxnz,
                 bool lazy);
 #endif
 
 template <class T>
 static MArray<T>
-dmsolve_extract (const MArray<T> &m, const octave_idx_type *, 
-                 const octave_idx_type *, octave_idx_type r1, 
-                 octave_idx_type r2, octave_idx_type c1, 
+dmsolve_extract (const MArray<T> &m, const octave_idx_type *,
+                 const octave_idx_type *, octave_idx_type r1,
+                 octave_idx_type r2, octave_idx_type c1,
                  octave_idx_type c2)
 {
   r2 -= 1;
   c2 -= 1;
   if (r1 > r2) { octave_idx_type tmp = r1; r1 = r2; r2 = tmp; }
   if (c1 > c2) { octave_idx_type tmp = c1; c1 = c2; c2 = tmp; }
 
   octave_idx_type new_r = r2 - r1 + 1;
@@ -136,25 +136,25 @@ dmsolve_extract (const MArray<T> &m, con
     for (octave_idx_type i = 0; i < new_r; i++)
       result.xelem (i, j) = m.elem (r1+i, c1+j);
 
   return result;
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 static MArray<double>
-dmsolve_extract (const MArray<double> &m, const octave_idx_type *, 
-                 const octave_idx_type *, octave_idx_type r1, 
-                 octave_idx_type r2, octave_idx_type c1, 
+dmsolve_extract (const MArray<double> &m, const octave_idx_type *,
+                 const octave_idx_type *, octave_idx_type r1,
+                 octave_idx_type r2, octave_idx_type c1,
                  octave_idx_type c2)
 
 static MArray<Complex>
-dmsolve_extract (const MArray<Complex> &m, const octave_idx_type *, 
-                 const octave_idx_type *, octave_idx_type r1, 
-                 octave_idx_type r2, octave_idx_type c1, 
+dmsolve_extract (const MArray<Complex> &m, const octave_idx_type *,
+                 const octave_idx_type *, octave_idx_type r1,
+                 octave_idx_type r2, octave_idx_type c1,
                  octave_idx_type c2)
 #endif
 
 template <class T>
 static void
 dmsolve_insert (MArray<T> &a, const MArray<T> &b, const octave_idx_type *Q,
                octave_idx_type r, octave_idx_type c)
 {
@@ -172,17 +172,17 @@ dmsolve_insert (MArray<T> &a, const MArr
           octave_quit ();
           ax [Q [r + i] + aoff] = bx [i + boff];
         }
     }
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 static void
-dmsolve_insert (MArray<double> &a, const MArray<double> &b, 
+dmsolve_insert (MArray<double> &a, const MArray<double> &b,
                const octave_idx_type *Q, octave_idx_type r, octave_idx_type c);
 
 static void
 dmsolve_insert (MArray<Complex> &a, const MArray<Complex> &b,
                const octave_idx_type *Q, octave_idx_type r, octave_idx_type c);
 #endif
 
 template <class T>
@@ -242,34 +242,34 @@ dmsolve_insert (MSparse<T> &a, const MSp
       for (octave_idx_type j = b.cidx(i-c); j < b.cidx(i-c+1); j++)
         {
           X [Q [r + b.ridx(j)]] = b.data(j);
           a.xridx(ii++) = Q [r + b.ridx(j)];
         }
 
       sort.sort (ri + a.xcidx (i), ii - a.xcidx (i));
       for (octave_idx_type p = a.xcidx (i); p < ii; p++)
-        a.xdata (p) = X [a.xridx (p)]; 
+        a.xdata (p) = X [a.xridx (p)];
       a.xcidx(i+1) = ii;
     }
 
   for (octave_idx_type i = c + b_cols; i < nc; i++)
     {
       for (octave_idx_type j = tmp.xcidx(i); j < tmp.cidx(i+1); j++)
         {
           a.xdata(ii) = tmp.xdata(j);
           a.xridx(ii++) = tmp.xridx(j);
         }
       a.xcidx(i+1) = ii;
     }
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 static void
-dmsolve_insert (MSparse<double> &a, const SparseMatrix &b, 
+dmsolve_insert (MSparse<double> &a, const SparseMatrix &b,
                const octave_idx_type *Q, octave_idx_type r, octave_idx_type c);
 
 static void
 dmsolve_insert (MSparse<Complex> &a, const MSparse<Complex> &b,
                const octave_idx_type *Q, octave_idx_type r, octave_idx_type c);
 #endif
 
 template <class T, class RT>
@@ -327,25 +327,25 @@ dmsolve_permute (MSparse<RT> &a, const M
           octave_idx_type r = p [b.ridx (i)];
           X [r] = b.data (i);
           a.xridx(nz++) = p [b.ridx (i)];
         }
       sort.sort (ri + a.xcidx (j), nz - a.xcidx (j));
       for (octave_idx_type i = a.cidx (j); i < nz; i++)
         {
           octave_quit ();
-          a.xdata (i) = X [a.xridx (i)]; 
+          a.xdata (i) = X [a.xridx (i)];
         }
       a.xcidx(j+1) = nz;
     }
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 static void
-dmsolve_permute (MSparse<double> &a, const MSparse<double>& b, 
+dmsolve_permute (MSparse<double> &a, const MSparse<double>& b,
                  const octave_idx_type *p);
 
 static void
 dmsolve_permute (MSparse<Complex> &a, const MSparse<double>& b,
                  const octave_idx_type *p);
 
 static void
 dmsolve_permute (MSparse<Complex> &a, const MSparse<Complex>& b,
@@ -404,47 +404,47 @@ dmsolve (const ST &a, const T &b, octave
       RT btmp;
       dmsolve_permute (btmp, b, pinv);
       info = 0;
       retval.resize (nc, b_nc);
 
       // Leading over-determined block
       if (dm->rr [2] < nr && dm->cc [3] < nc)
         {
-          ST m = dmsolve_extract (a, pinv, q, dm->rr [2], nr, dm->cc [3], nc, 
+          ST m = dmsolve_extract (a, pinv, q, dm->rr [2], nr, dm->cc [3], nc,
                                   nnz_remaining, true);
           nnz_remaining -= m.nnz();
-          RT mtmp = 
+          RT mtmp =
             qrsolve (m, dmsolve_extract (btmp, 0, 0, dm->rr[2], b_nr, 0,
                                          b_nc), info);
           dmsolve_insert (retval, mtmp, q, dm->cc [3], 0);
           if (dm->rr [2] > 0 && !info)
             {
-              m = dmsolve_extract (a, pinv, q, 0, dm->rr [2], 
+              m = dmsolve_extract (a, pinv, q, 0, dm->rr [2],
                                    dm->cc [3], nc, nnz_remaining, true);
               nnz_remaining -= m.nnz();
-              RT ctmp = dmsolve_extract (btmp, 0, 0, 0, 
+              RT ctmp = dmsolve_extract (btmp, 0, 0, 0,
                                          dm->rr[2], 0, b_nc);
               btmp.insert (ctmp - m * mtmp, 0, 0);
             }
         }
-      
+
       // Structurally non-singular blocks
       // FIXME Should use fine Dulmange-Mendelsohn decomposition here.
       if (dm->rr [1] < dm->rr [2] && dm->cc [2] < dm->cc [3] && !info)
         {
-          ST m = dmsolve_extract (a, pinv, q, dm->rr [1], dm->rr [2], 
+          ST m = dmsolve_extract (a, pinv, q, dm->rr [1], dm->rr [2],
                                   dm->cc [2], dm->cc [3], nnz_remaining, false);
           nnz_remaining -= m.nnz();
-          RT btmp2 = dmsolve_extract (btmp, 0, 0, dm->rr [1], dm->rr [2], 
+          RT btmp2 = dmsolve_extract (btmp, 0, 0, dm->rr [1], dm->rr [2],
                                       0, b_nc);
           double rcond = 0.0;
           MatrixType mtyp (MatrixType::Full);
-          RT mtmp = m.solve (mtyp, btmp2, info, rcond, 
-                             solve_singularity_warning, false); 
+          RT mtmp = m.solve (mtyp, btmp2, info, rcond,
+                             solve_singularity_warning, false);
           if (info != 0)
             {
               info = 0;
               mtmp = qrsolve (m, btmp2, info);
             }
 
           dmsolve_insert (retval, mtmp, q, dm->cc [2], 0);
           if (dm->rr [1] > 0 && !info)
@@ -456,57 +456,57 @@ dmsolve (const ST &a, const T &b, octave
                                          dm->rr[1], 0, b_nc);
               btmp.insert (ctmp - m * mtmp, 0, 0);
             }
         }
 
       // Trailing under-determined block
       if (dm->rr [1] > 0 && dm->cc [2] > 0 && !info)
         {
-          ST m = dmsolve_extract (a, pinv, q, 0, dm->rr [1], 0, 
+          ST m = dmsolve_extract (a, pinv, q, 0, dm->rr [1], 0,
                                   dm->cc [2], nnz_remaining, true);
-          RT mtmp = 
-            qrsolve (m, dmsolve_extract(btmp, 0, 0, 0, dm->rr [1] , 0, 
+          RT mtmp =
+            qrsolve (m, dmsolve_extract(btmp, 0, 0, 0, dm->rr [1] , 0,
                                         b_nc), info);
           dmsolve_insert (retval, mtmp, q, 0, 0);
         }
 
       CXSPARSE_DNAME (_dfree) (dm);
     }
   return retval;
 #else
   return RT ();
 #endif
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 extern Matrix
-dmsolve (const SparseMatrix &a, const Matrix &b, 
+dmsolve (const SparseMatrix &a, const Matrix &b,
          octave_idx_type &info);
 
 extern ComplexMatrix
-dmsolve (const SparseMatrix &a, const ComplexMatrix &b, 
+dmsolve (const SparseMatrix &a, const ComplexMatrix &b,
          octave_idx_type &info);
 
 extern ComplexMatrix
-dmsolve (const SparseComplexMatrix &a, const Matrix &b, 
+dmsolve (const SparseComplexMatrix &a, const Matrix &b,
          octave_idx_type &info);
 
 extern ComplexMatrix
-dmsolve (const SparseComplexMatrix &a, const ComplexMatrix &b, 
+dmsolve (const SparseComplexMatrix &a, const ComplexMatrix &b,
          octave_idx_type &info);
 
 extern SparseMatrix
-dmsolve (const SparseMatrix &a, const SparseMatrix &b, 
+dmsolve (const SparseMatrix &a, const SparseMatrix &b,
          octave_idx_type &info);
 
 extern SparseComplexMatrix
-dmsolve (const SparseMatrix &a, const SparseComplexMatrix &b, 
+dmsolve (const SparseMatrix &a, const SparseComplexMatrix &b,
          octave_idx_type &info);
 
 extern SparseComplexMatrix
-dmsolve (const SparseComplexMatrix &a, const SparseMatrix &b, 
+dmsolve (const SparseComplexMatrix &a, const SparseMatrix &b,
          octave_idx_type &info);
 
 extern SparseComplexMatrix
-dmsolve (const SparseComplexMatrix &a, const SparseComplexMatrix &b, 
+dmsolve (const SparseComplexMatrix &a, const SparseComplexMatrix &b,
          octave_idx_type &info);
 #endif
diff --git a/liboctave/sparse-sort.cc b/liboctave/sparse-sort.cc
--- a/liboctave/sparse-sort.cc
+++ b/liboctave/sparse-sort.cc
@@ -33,17 +33,17 @@ along with Octave; see the file COPYING.
 
 #include "sparse-sort.h"
 
 // A simple class and instantiation of the octave merge sort class
 // to sort sparse data before matrix creation. This is significantly
 // faster than using octave_qsort.
 
 bool
-octave_sparse_sidxl_comp (octave_sparse_sort_idxl* i, 
+octave_sparse_sidxl_comp (octave_sparse_sort_idxl* i,
                           octave_sparse_sort_idxl* j)
 {
   octave_idx_type tmp = i->c - j->c;
   if (tmp < 0)
     return true;
   else if (tmp > 0)
     return false;
   return  (i->r < j->r);
diff --git a/liboctave/sparse-sort.h b/liboctave/sparse-sort.h
--- a/liboctave/sparse-sort.h
+++ b/liboctave/sparse-sort.h
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 #include "oct-sort.h"
 
 class
 octave_sparse_sort_idxl
 {
 public:
   octave_idx_type r;
   octave_idx_type c;
-  octave_idx_type idx; 
+  octave_idx_type idx;
 };
 
 bool octave_sparse_sidxl_comp (octave_sparse_sort_idxl* i,
                                octave_sparse_sort_idxl* j);
 
 class
 octave_idx_vector_sort
 {
diff --git a/liboctave/sparse-util.h b/liboctave/sparse-util.h
--- a/liboctave/sparse-util.h
+++ b/liboctave/sparse-util.h
@@ -20,19 +20,19 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_sparse_util_h)
 #define octave_sparse_util_h 1
 
 // FIXME this overload is here due to API change in SuiteSparse (3.1 -> 3.2)
-extern OCTAVE_API void SparseCholError (int status, char *file, 
+extern OCTAVE_API void SparseCholError (int status, char *file,
                                         int line, char *message);
-extern OCTAVE_API void SparseCholError (int status, const char *file, 
+extern OCTAVE_API void SparseCholError (int status, const char *file,
                                         int line, const char *message);
 extern OCTAVE_API int SparseCholPrint (const char *fmt, ...);
 
 extern OCTAVE_API bool
 sparse_indices_ok (octave_idx_type *r, octave_idx_type *c,
                    octave_idx_type nrows, octave_idx_type ncols,
                    octave_idx_type nnz);
 
diff --git a/liboctave/tempname.c b/liboctave/tempname.c
--- a/liboctave/tempname.c
+++ b/liboctave/tempname.c
@@ -178,17 +178,17 @@ char *
                        % (sizeof (letters) - 1)],
                letters[(*idx / ((sizeof (letters) - 1) *
                                 (sizeof (letters) - 1)))
                        % (sizeof (letters) - 1)]
                );
 
       if (! buf || strlen (buf) != (int) len)
         return NULL;
-  
+
       if (streamptr != NULL)
         abort ();
       else if (exists (buf))
         continue;
 
       /* If the file already existed we have continued the loop above,
          so we only get here when we have a winning name to return.  */
 
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,119 @@
+2011-01-20  John W. Eaton  <jwe@octave.org>
+
+	* DLD-FUNCTIONS/__contourc__.cc, DLD-FUNCTIONS/__delaunayn__.cc,
+	DLD-FUNCTIONS/__dsearchn__.cc, DLD-FUNCTIONS/__glpk__.cc,
+	DLD-FUNCTIONS/__init_fltk__.cc,
+	DLD-FUNCTIONS/__lin_interpn__.cc,
+	DLD-FUNCTIONS/__magick_read__.cc,
+	DLD-FUNCTIONS/__pchip_deriv__.cc, DLD-FUNCTIONS/__qp__.cc,
+	DLD-FUNCTIONS/__voronoi__.cc, DLD-FUNCTIONS/amd.cc,
+	DLD-FUNCTIONS/balance.cc, DLD-FUNCTIONS/besselj.cc,
+	DLD-FUNCTIONS/bsxfun.cc, DLD-FUNCTIONS/ccolamd.cc,
+	DLD-FUNCTIONS/cellfun.cc, DLD-FUNCTIONS/chol.cc,
+	DLD-FUNCTIONS/colamd.cc, DLD-FUNCTIONS/colloc.cc,
+	DLD-FUNCTIONS/convhulln.cc, DLD-FUNCTIONS/daspk.cc,
+	DLD-FUNCTIONS/dasrt.cc, DLD-FUNCTIONS/dassl.cc,
+	DLD-FUNCTIONS/det.cc, DLD-FUNCTIONS/dlmread.cc,
+	DLD-FUNCTIONS/dmperm.cc, DLD-FUNCTIONS/dot.cc,
+	DLD-FUNCTIONS/eig.cc, DLD-FUNCTIONS/eigs.cc,
+	DLD-FUNCTIONS/fft.cc, DLD-FUNCTIONS/fft2.cc,
+	DLD-FUNCTIONS/fftn.cc, DLD-FUNCTIONS/fftw.cc,
+	DLD-FUNCTIONS/filter.cc, DLD-FUNCTIONS/find.cc,
+	DLD-FUNCTIONS/gammainc.cc, DLD-FUNCTIONS/givens.cc,
+	DLD-FUNCTIONS/hex2num.cc, DLD-FUNCTIONS/inv.cc,
+	DLD-FUNCTIONS/kron.cc, DLD-FUNCTIONS/lookup.cc,
+	DLD-FUNCTIONS/lsode.cc, DLD-FUNCTIONS/lu.cc,
+	DLD-FUNCTIONS/luinc.cc, DLD-FUNCTIONS/matrix_type.cc,
+	DLD-FUNCTIONS/max.cc, DLD-FUNCTIONS/md5sum.cc,
+	DLD-FUNCTIONS/onCleanup.cc, DLD-FUNCTIONS/qr.cc,
+	DLD-FUNCTIONS/quad.cc, DLD-FUNCTIONS/quadcc.cc,
+	DLD-FUNCTIONS/qz.cc, DLD-FUNCTIONS/rand.cc,
+	DLD-FUNCTIONS/regexp.cc, DLD-FUNCTIONS/schur.cc,
+	DLD-FUNCTIONS/spparms.cc, DLD-FUNCTIONS/sqrtm.cc,
+	DLD-FUNCTIONS/str2double.cc, DLD-FUNCTIONS/strfind.cc,
+	DLD-FUNCTIONS/sub2ind.cc, DLD-FUNCTIONS/svd.cc,
+	DLD-FUNCTIONS/syl.cc, DLD-FUNCTIONS/symbfact.cc,
+	DLD-FUNCTIONS/symrcm.cc, DLD-FUNCTIONS/tril.cc,
+	DLD-FUNCTIONS/tsearch.cc, DLD-FUNCTIONS/typecast.cc,
+	DLD-FUNCTIONS/urlwrite.cc, OPERATORS/op-b-sbm.cc,
+	OPERATORS/op-bm-sbm.cc, OPERATORS/op-cdm-cdm.cc,
+	OPERATORS/op-chm.cc, OPERATORS/op-cm-cm.cc,
+	OPERATORS/op-cm-m.cc, OPERATORS/op-cm-scm.cc,
+	OPERATORS/op-cm-sm.cc, OPERATORS/op-cs-cs.cc,
+	OPERATORS/op-cs-scm.cc, OPERATORS/op-cs-sm.cc,
+	OPERATORS/op-dm-dm.cc, OPERATORS/op-dms-template.cc,
+	OPERATORS/op-fcdm-fcdm.cc, OPERATORS/op-fcm-fcm.cc,
+	OPERATORS/op-fcm-fcs.cc, OPERATORS/op-fcm-fm.cc,
+	OPERATORS/op-fcm-fs.cc, OPERATORS/op-fcs-fcm.cc,
+	OPERATORS/op-fcs-fcs.cc, OPERATORS/op-fcs-fm.cc,
+	OPERATORS/op-fcs-fs.cc, OPERATORS/op-fdm-fdm.cc,
+	OPERATORS/op-fm-fcm.cc, OPERATORS/op-fm-fcs.cc,
+	OPERATORS/op-fm-fm.cc, OPERATORS/op-fm-fs.cc,
+	OPERATORS/op-fs-fcm.cc, OPERATORS/op-fs-fcs.cc,
+	OPERATORS/op-fs-fm.cc, OPERATORS/op-int-concat.cc,
+	OPERATORS/op-m-cm.cc, OPERATORS/op-m-m.cc,
+	OPERATORS/op-m-scm.cc, OPERATORS/op-m-sm.cc,
+	OPERATORS/op-pm-pm.cc, OPERATORS/op-pm-scm.cc,
+	OPERATORS/op-pm-sm.cc, OPERATORS/op-pm-template.cc,
+	OPERATORS/op-range.cc, OPERATORS/op-s-scm.cc,
+	OPERATORS/op-sbm-b.cc, OPERATORS/op-sbm-bm.cc,
+	OPERATORS/op-sbm-sbm.cc, OPERATORS/op-scm-cm.cc,
+	OPERATORS/op-scm-cs.cc, OPERATORS/op-scm-m.cc,
+	OPERATORS/op-scm-s.cc, OPERATORS/op-scm-scm.cc,
+	OPERATORS/op-scm-sm.cc, OPERATORS/op-sm-cm.cc,
+	OPERATORS/op-sm-cs.cc, OPERATORS/op-sm-m.cc,
+	OPERATORS/op-sm-s.cc, OPERATORS/op-sm-scm.cc,
+	OPERATORS/op-sm-sm.cc, OPERATORS/op-str-str.cc,
+	OPERATORS/op-ui64-ui64.cc, bitfcns.cc, c-file-ptr-stream.cc,
+	c-file-ptr-stream.h, comment-list.h, data.cc, debug.cc, debug.h,
+	defun-int.h, defun.cc, dynamic-ld.cc, error.cc, file-io.cc,
+	gl-render.cc, gl-render.h, gl2ps-renderer.cc, gl2ps-renderer.h,
+	gl2ps.c, gl2ps.h, graphics.cc, graphics.h.in, help.cc, input.cc,
+	lex.h, lex.ll, load-path.cc, load-path.h, load-save.cc,
+	load-save.h, ls-ascii-helper.cc, ls-hdf5.cc, ls-hdf5.h,
+	ls-mat-ascii.cc, ls-mat4.cc, ls-mat4.h, ls-mat5.cc,
+	ls-oct-ascii.cc, ls-oct-ascii.h, ls-oct-binary.cc, mappers.cc,
+	mex.cc, mex.h, mexproto.h, mxarray.h.in, oct-hist.cc,
+	oct-lvalue.cc, oct-lvalue.h, oct-map.cc, oct-map.h, oct-obj.cc,
+	oct-obj.h, oct-parse.yy, oct-procbuf.cc, oct-stream.cc,
+	oct-stream.h, octave.cc, ov-base-diag.cc, ov-base-diag.h,
+	ov-base-int.cc, ov-base-int.h, ov-base-mat.cc, ov-base-mat.h,
+	ov-base-scalar.cc, ov-base-scalar.h, ov-base-sparse.cc,
+	ov-base-sparse.h, ov-base.cc, ov-base.h, ov-bool-mat.cc,
+	ov-bool-mat.h, ov-bool-sparse.cc, ov-bool-sparse.h, ov-bool.cc,
+	ov-bool.h, ov-builtin.h, ov-cell.cc, ov-cell.h, ov-ch-mat.cc,
+	ov-class.cc, ov-class.h, ov-complex.cc, ov-complex.h,
+	ov-cx-diag.cc, ov-cx-diag.h, ov-cx-mat.cc, ov-cx-mat.h,
+	ov-cx-sparse.cc, ov-cx-sparse.h, ov-dld-fcn.h, ov-fcn-handle.cc,
+	ov-fcn-handle.h, ov-fcn-inline.cc, ov-fcn-inline.h, ov-fcn.h,
+	ov-float.cc, ov-float.h, ov-flt-complex.cc, ov-flt-complex.h,
+	ov-flt-cx-diag.cc, ov-flt-cx-diag.h, ov-flt-cx-mat.cc,
+	ov-flt-cx-mat.h, ov-flt-re-diag.cc, ov-flt-re-diag.h,
+	ov-flt-re-mat.cc, ov-flt-re-mat.h, ov-intx.h, ov-lazy-idx.cc,
+	ov-lazy-idx.h, ov-null-mat.cc, ov-null-mat.h, ov-perm.cc,
+	ov-perm.h, ov-range.cc, ov-range.h, ov-re-diag.cc, ov-re-diag.h,
+	ov-re-mat.cc, ov-re-mat.h, ov-re-sparse.cc, ov-re-sparse.h,
+	ov-scalar.cc, ov-scalar.h, ov-str-mat.cc, ov-str-mat.h,
+	ov-struct.cc, ov-struct.h, ov-type-conv.h, ov-typeinfo.cc,
+	ov-usr-fcn.cc, ov-usr-fcn.h, ov.cc, ov.h, pager.cc,
+	pr-output.cc, procstream.h, pt-arg-list.cc, pt-assign.h,
+	pt-binop.cc, pt-bp.cc, pt-bp.h, pt-cbinop.cc, pt-cell.cc,
+	pt-colon.cc, pt-const.cc, pt-decl.cc, pt-eval.cc,
+	pt-fcn-handle.cc, pt-id.h, pt-idx.cc, pt-idx.h, pt-mat.cc,
+	pt-mat.h, pt-pr-code.cc, pt-select.cc, pt-select.h, pt-stmt.cc,
+	pt-unop.cc, pt-unop.h, sighandlers.cc, sighandlers.h,
+	sparse-xdiv.cc, sparse-xdiv.h, sparse-xpow.cc, sparse-xpow.h,
+	sparse.cc, strfns.cc, symtab.cc, symtab.h, syscalls.cc,
+	sysdep.cc, toplev.cc, toplev.h, txt-eng-ft.cc, txt-eng-ft.h,
+	txt-eng.h, unwind-prot.h, utils.cc, utils.h, variables.cc,
+	variables.h, xdiv.cc, xdiv.h, xnorm.cc, xpow.cc, zfstream.cc,
+	zfstream.h: Strip trailing whitespace.
+
 2011-01-20  John W. Eaton  <jwe@octave.org>
 
 	* gl-render.cc, DLD-FUNCTIONS/__init_fltk__.cc,
 	DLD-FUNCTIONS/__magick_read__.cc: Untabify.
 
 2011-01-20  Pascal Dupuis <Pascal.Dupuis@worldonline.be>.
 
 	* debug.h, dynamic-ld.cc, gl-render.cc, gl-render.h,
diff --git a/src/DLD-FUNCTIONS/__contourc__.cc b/src/DLD-FUNCTIONS/__contourc__.cc
--- a/src/DLD-FUNCTIONS/__contourc__.cc
+++ b/src/DLD-FUNCTIONS/__contourc__.cc
@@ -189,17 +189,17 @@ drawcn (const RowVector& X, const RowVec
   // Decrease id value of current facet for start edge.
   mark(r, c) -= static_cast<char> (1 << stop_edge);
 
   // Find next facet.
   next_c = c;
   next_r = r;
 
   if (stop_edge == 0)
-    next_r--; 
+    next_r--;
   else if (stop_edge == 1)
     next_c++;
   else if (stop_edge == 2)
     next_r++;
   else if (stop_edge == 3)
     next_c--;
 
   // Check if next facet is not done yet.
diff --git a/src/DLD-FUNCTIONS/__delaunayn__.cc b/src/DLD-FUNCTIONS/__delaunayn__.cc
--- a/src/DLD-FUNCTIONS/__delaunayn__.cc
+++ b/src/DLD-FUNCTIONS/__delaunayn__.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
   * Added Qbb option to normalize the input and avoid crashes in Octave.
   * delaunayn accepts now a second (optional) argument that must be a string
   containing extra options to the qhull command.
   * Fixed doc string.  The dimension of the result matrix is [m, dim+1], and
   not [n, dim-1].
 
   6. June 2006: Changes by Alexander Barth <abarth@marine.usf.edu>
 
-  * triangulate non-simplicial facets 
+  * triangulate non-simplicial facets
   * allow options to be specified as cell array of strings
   * change the default options (for compatibility with matlab)
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
@@ -94,48 +94,48 @@ Undocumented internal function.\n\
 
 
   if (nargin == 2)
     {
     if (args(1).is_empty ())
       {
         // keep default options
       }
-    else if (args(1).is_string ()) 
+    else if (args(1).is_string ())
       {
         // option string is directly provided
         options = args(1).string_value ();
       }
-    else if (args(1).is_cell ()) 
+    else if (args(1).is_cell ())
       {
         options = "";
 
         Cell c = args(1).cell_value ();
         for (octave_idx_type i = 0; i < c.numel (); i++)
           {
 
-            if (! c.elem(i).is_string ()) 
+            if (! c.elem(i).is_string ())
               {
                 error ("__delaunayn__: all options must be strings");
                 return retval;
               }
 
             options = options + c.elem(i).string_value () + " ";
           }
       }
-    else 
+    else
       {
         error ("__delaunayn__: OPT argument must be a string, cell array of strings, or empty");
         return retval;
       }
-    } 
+    }
 
   //octave_stdout << "options " << options << std::endl;
 
-  if (n > dim + 1) 
+  if (n > dim + 1)
     {
       p = p.transpose ();
       double *pt_array = p.fortran_vec ();
       boolT ismalloc = false;
 
       OCTAVE_LOCAL_BUFFER (char, flags, 250);
 
       sprintf (flags, "qhull d %s", options.c_str ());
@@ -144,40 +144,40 @@ Undocumented internal function.\n\
       // with stdout or some other file open for writing.
 
       FILE *outfile = 0;
       FILE *errfile = stderr;
 
       if (! qh_new_qhull (dim, n, pt_array, ismalloc, flags, outfile, errfile))
         {
           // triangulate non-simplicial facets
-          qh_triangulate (); 
+          qh_triangulate ();
 
           facetT *facet;
           vertexT *vertex, **vertexp;
           octave_idx_type nf = 0, i = 0;
 
           FORALLfacets
             {
               if (! facet->upperdelaunay)
                 nf++;
 
               // Double check
-              if (! facet->simplicial) 
+              if (! facet->simplicial)
                 {
                   error ("__delaunayn__: Qhull returned non-simplicial facets -- try delaunayn with different options");
                   break;
                 }
             }
 
           Matrix simpl (nf, dim+1);
 
           FORALLfacets
             {
-              if (! facet->upperdelaunay) 
+              if (! facet->upperdelaunay)
                 {
                   octave_idx_type j = 0;
 
                   FOREACHvertex_ (facet->vertices)
                     {
                       // if delaunayn crashes, enable this check
 #if 0
                       if (j > dim)
@@ -204,22 +204,22 @@ Undocumented internal function.\n\
 
           if (curlong || totlong)
             warning ("__delaunay__: did not free %d bytes of long memory (%d pieces)",
                      totlong, curlong);
         }
       else
         error ("__delaunayn__: qhull failed.");
     }
-  else if (n == dim + 1) 
+  else if (n == dim + 1)
     {
       // one should check if nx points span a simplex
       // I will look at this later.
       RowVector vec (n);
-      for (octave_idx_type i = 0; i < n; i++) 
+      for (octave_idx_type i = 0; i < n; i++)
         vec(i) = i + 1.0;
 
       retval(0) = vec;
     }
 
 #else
   error ("__delaunayn__: not available in this version of Octave");
 #endif
diff --git a/src/DLD-FUNCTIONS/__dsearchn__.cc b/src/DLD-FUNCTIONS/__dsearchn__.cc
--- a/src/DLD-FUNCTIONS/__dsearchn__.cc
+++ b/src/DLD-FUNCTIONS/__dsearchn__.cc
@@ -91,17 +91,17 @@ Undocumented internal function.\n\
                   if (d < d0)
                     {
                       d0 = d;
                       *pidx = static_cast<double>(j + 1);
                     }
                   OCTAVE_QUIT;
                 }
 
-              *pdist++ = d0; 
+              *pdist++ = d0;
               pidx++;
               pxi += n;
             }
 
           retval(1) = dist;
           retval(0) = idx;
         }
     }
diff --git a/src/DLD-FUNCTIONS/__glpk__.cc b/src/DLD-FUNCTIONS/__glpk__.cc
--- a/src/DLD-FUNCTIONS/__glpk__.cc
+++ b/src/DLD-FUNCTIONS/__glpk__.cc
@@ -259,17 +259,17 @@ glpk (int sense, int n, int m, double *c
         case 'S':
           typx = LPX_FX;
           break;
 
         case 'D':
           typx = LPX_DB;
           break;
         }
-      
+
       lpx_set_row_bnds (lp, i+1, typx, b[i], b[i]);
 
     }
 
   lpx_load_matrix (lp, nz, rn, cn, a);
 
   if (save_pb)
     {
diff --git a/src/DLD-FUNCTIONS/__init_fltk__.cc b/src/DLD-FUNCTIONS/__init_fltk__.cc
--- a/src/DLD-FUNCTIONS/__init_fltk__.cc
+++ b/src/DLD-FUNCTIONS/__init_fltk__.cc
@@ -93,39 +93,39 @@ public:
       in_zoom (false), zoom_box (),  print_fid (-1)
   {
     // Ask for double buffering and a depth buffer.
     mode (FL_DEPTH | FL_DOUBLE);
   }
 
   ~OpenGL_fltk (void) { }
 
-  void zoom (bool z) 
+  void zoom (bool z)
   {
     in_zoom = z;
     if (! in_zoom)
       hide_overlay ();
   }
 
   bool zoom (void) { return in_zoom; }
   void set_zoom_box (const Matrix& zb) { zoom_box = zb; }
-  
+
   void print (const int fid, const std::string& term)
   {
     print_fid  = fid;
     print_term  = term;
   }
 
   void resize (int xx, int yy, int ww, int hh)
   {
     Fl_Gl_Window::resize (xx, yy, ww, hh);
     setup_viewport (ww, hh);
     redraw ();
   }
-  
+
 private:
   double number;
   opengl_renderer renderer;
   bool in_zoom;
   // (x1,y1,x2,y2)
   Matrix zoom_box;
 
   int print_fid;
@@ -165,17 +165,17 @@ private:
   void zoom_box_vertex (void)
   {
     glVertex2d (zoom_box(0), h () - zoom_box(1));
     glVertex2d (zoom_box(0), h () - zoom_box(3));
     glVertex2d (zoom_box(2), h () - zoom_box(3));
     glVertex2d (zoom_box(2), h () - zoom_box(1));
     glVertex2d (zoom_box(0), h () - zoom_box(1));
   }
- 
+
   void overlay (void)
   {
     glPushMatrix ();
 
     glMatrixMode (GL_MODELVIEW);
     glLoadIdentity ();
 
     glMatrixMode (GL_PROJECTION);
@@ -223,17 +223,17 @@ private:
 static double wheel_zoom_speed = 0.05;
 // Parameter controlling the GUI mode.
 static enum { pan_zoom, rotate_zoom, none } gui_mode;
 
 void script_cb(Fl_Widget*, void* data)
   {
     static_cast<uimenu::properties*> (data)->execute_callback ();
   }
-  
+
 
 class fltk_uimenu
 {
 public:
   fltk_uimenu (int xx, int yy, int ww, int hh)
     {
       menubar = new
         Fl_Menu_Bar(xx, yy, ww, hh);
@@ -297,75 +297,75 @@ public:
               if (m->label () == NULL)
                 {
                   std::size_t idx = menupath.find_last_of ("/");
                   if (idx != std::string::npos)
                     menupath.erase (idx);
                   else
                     menupath.clear ();
                   continue;
-                }   
+                }
               // Menu item?
               std::string itempath = menupath;
               if (!itempath.empty ())
-                itempath += "/";              
+                itempath += "/";
               itempath += m->label ();
 
               if (itempath.compare (findname) == 0)
                 return (t);
             }
         }
       return (-1);
     }
-  
+
   Matrix find_uimenu_children (uimenu::properties& uimenup) const
     {
       Matrix uimenu_childs = uimenup.get_all_children ();
       Matrix retval = do_find_uimenu_children (uimenu_childs);
       return retval;
     }
 
   Matrix find_uimenu_children (figure::properties& figp) const
     {
       Matrix uimenu_childs = figp.get_all_children ();
       Matrix retval = do_find_uimenu_children (uimenu_childs);
       return retval;
     }
-    
+
   Matrix do_find_uimenu_children (Matrix uimenu_childs) const
     {
       octave_idx_type k = 0;
-      
-      
+
+
       Matrix pos = Matrix (uimenu_childs.numel (), 1);
-      
+
       for (octave_idx_type ii = 0; ii < uimenu_childs.numel (); ii++)
       {
         graphics_object kidgo = gh_manager::get_object (uimenu_childs (ii));
-        
+
         if (kidgo.valid_object() && kidgo.isa ("uimenu"))
           {
             uimenu_childs(k) = uimenu_childs(ii);
             pos(k++) =
               dynamic_cast<uimenu::properties&> (kidgo.get_properties ()).get_position ();
           }
       }
-      
-      uimenu_childs.resize (k, 1);    
+
+      uimenu_childs.resize (k, 1);
       pos.resize (k, 1);
       Matrix retval = Matrix (k, 1);
       // Don't know if this is the best method to sort.
       // Can we avoid the for loop?
       Array<octave_idx_type> sidx = pos.sort_rows_idx (DESCENDING);
       for (octave_idx_type ii = 0; ii < k; ii++)
         retval(ii) = uimenu_childs (sidx(ii));
-       
+
       return retval;
     }
-    
+
   void delete_entry(uimenu::properties& uimenup)
     {
       std::string fltk_label = uimenup.get_fltk_label ();
       int idx = find_index_by_name (fltk_label.c_str ());
 
       if (idx >= 0)
         menubar->remove (idx);
     }
@@ -399,17 +399,17 @@ public:
               if (!uimenup.get_callback ().is_empty ())
                 item->callback(static_cast<Fl_Callback*>(script_cb), //callback
                               static_cast<void*>(&uimenup));        //callback data
               else
                 item->callback(NULL, static_cast<void*>(0));
             }
         }
     }
-            
+
   void update_enable (uimenu::properties& uimenup)
     {
       std::string fltk_label = uimenup.get_fltk_label ();
       if (!fltk_label.empty ())
         {
           Fl_Menu_Item* item = const_cast<Fl_Menu_Item*>(menubar->find_item (fltk_label.c_str ()));
           if (item != NULL)
             {
@@ -444,17 +444,17 @@ public:
       // the previous item in this menu/submenu. (Kai)
       std::string fltk_label = uimenup.get_fltk_label ();
       if (!fltk_label.empty ())
         {
           int itemflags = 0, idx;
           int curr_idx = find_index_by_name(fltk_label.c_str ());
 
           for (idx = curr_idx - 1; idx >= 0; idx--)
-            { 
+            {
               Fl_Menu_Item* item = const_cast<Fl_Menu_Item*>(&menubar->menu () [idx]);
               itemflags = item->flags;
               if (item->label () != NULL)
                 break;
             }
 
           if ((idx >= 0) && (idx < menubar->size ()))
             {
@@ -479,39 +479,39 @@ public:
             {
               if (uimenup.is_visible ())
                 item->show ();
               else
                 item->hide ();
             }
         }
     }
-    
+
   void add_entry (uimenu::properties& uimenup)
     {
 
       std::string fltk_label = uimenup.get_fltk_label ();
 
       if (!fltk_label.empty ())
         {
           bool item_added = false;
           do
-            {  
+            {
               const Fl_Menu_Item* item = menubar->find_item(fltk_label.c_str ());
-              
+
               if (item == NULL)
                 {
                   Matrix uimenu_ch = find_uimenu_children (uimenup);
                   int len = uimenu_ch.numel ();
                   int flags = 0;
-                  if (len > 0) 
+                  if (len > 0)
                     flags = FL_SUBMENU;
                   if ((len == 0) && (uimenup.is_checked ()))
                     flags += FL_MENU_TOGGLE + FL_MENU_VALUE;
-                  menubar->add(fltk_label.c_str (), 0, 0, 0, flags);      
+                  menubar->add(fltk_label.c_str (), 0, 0, 0, flags);
                   item_added = true;
                 }
               else
                 {
                   //avoid duplicate menulabels
                   std::size_t idx1 = fltk_label.find_last_of ("(");
                   std::size_t idx2 = fltk_label.find_last_of (")");
                   int len = idx2 - idx1;
@@ -527,48 +527,48 @@ public:
                   std::ostringstream valstream;
                   valstream << val;
                   fltk_label += "(" + valstream.str () + ")";
                 }
             }
           while (!item_added);
           uimenup.set_fltk_label (fltk_label);
         }
-    }  
+    }
 
   void add_to_menu (uimenu::properties& uimenup)
     {
       Matrix kids = find_uimenu_children (uimenup);
       int len = kids.length ();
       std::string fltk_label = uimenup.get_fltk_label ();
-      
+
       add_entry (uimenup);
       update_foregroundcolor (uimenup);
       update_callback (uimenup);
       update_accelerator (uimenup);
       update_enable (uimenup);
       update_visible (uimenup);
       update_seperator (uimenup);
-      
+
       for (octave_idx_type ii = 0; ii < len; ii++)
         {
           graphics_object kgo = gh_manager::get_object (kids (len - (ii + 1)));
           if (kgo.valid_object ())
             {
               uimenu::properties& kprop = dynamic_cast<uimenu::properties&>(kgo.get_properties ());
               add_to_menu (kprop);
             }
         }
     }
 
   void add_to_menu (figure::properties& figp)
     {
       Matrix kids = find_uimenu_children (figp);
       int len = kids.length ();
-      menubar->clear ();      
+      menubar->clear ();
       for (octave_idx_type ii = 0; ii < len; ii++)
         {
           graphics_object kgo = gh_manager::get_object (kids (len - (ii + 1)));
 
           if (kgo.valid_object ())
             {
               uimenu::properties& kprop = dynamic_cast<uimenu::properties&>(kgo.get_properties ());
               add_to_menu (kprop);
@@ -576,17 +576,17 @@ public:
         }
     }
 
   template <class T_prop>
   void remove_from_menu (T_prop& prop)
     {
       Matrix kids;
       std::string type = prop.get_type ();
-      kids = find_uimenu_children (prop);    
+      kids = find_uimenu_children (prop);
       int len = kids.length ();
 
       for (octave_idx_type ii = 0; ii < len; ii++)
         {
           graphics_object kgo = gh_manager::get_object (kids (len - (ii + 1)));
 
           if (kgo.valid_object ())
             {
@@ -600,17 +600,17 @@ public:
       else if (type.compare("figure") == 0)
         menubar->clear ();
     }
 
   ~fltk_uimenu()
     {
       delete menubar;
     }
-    
+
 private:
   Fl_Menu_Bar* menubar;
 };
 
 class plot_window : public Fl_Window
 {
   friend class fltk_uimenu;
 public:
@@ -618,28 +618,28 @@ public:
     : Fl_Window (xx, yy, ww, hh, "octave"), window_label (), shift (0),
       ndim (2), fp (xfp), canvas (0), autoscale (0), togglegrid (0),
       panzoom (0), rotate (0), help (0), status (0)
   {
     callback (window_close, static_cast<void*> (this));
 
     begin ();
     {
-      
+
       uimenu = new
         fltk_uimenu(0, 0, ww, menu_h);
       uimenu->hide ();
-      
+
       canvas = new
         OpenGL_fltk (0, 0, ww , hh - status_h, number ());
 
-      bottom = new 
-        Fl_Box (0, 
-                hh - status_h, 
-                ww, 
+      bottom = new
+        Fl_Box (0,
+                hh - status_h,
+                ww,
                 status_h);
       bottom->box(FL_FLAT_BOX);
 
       ndim = calc_dimensions (gh_manager::get_object (fp.get___myhandle__ ()));
 
       autoscale = new
         Fl_Button (0,
                    hh - status_h,
@@ -761,43 +761,43 @@ public:
       dm = 0;
     canvas->resize (canvas->x (),
                     canvas->y () + dm,
                     canvas->w (),
                     canvas->h () - dm);
     uimenu->show ();
     mark_modified ();
   }
-  
+
   void hide_menubar (void)
   {
     int dm = menu_h;
     if (!uimenu->is_visible ())
       dm = 0;
     canvas->resize (canvas->x (),
                     canvas->y () - dm,
                     canvas->w (),
                     canvas->h () + dm);
     uimenu->hide ();
-    mark_modified (); 
+    mark_modified ();
   }
-  
+
   void uimenu_update(graphics_handle gh, int id)
   {
     graphics_object uimenu_obj = gh_manager::get_object (gh);
-    
+
     if (uimenu_obj.valid_object () && uimenu_obj.isa ("uimenu"))
       {
         uimenu::properties& uimenup =
           dynamic_cast<uimenu::properties&> (uimenu_obj.get_properties ());
         std::string fltk_label = uimenup.get_fltk_label();
         graphics_object fig = uimenu_obj.get_ancestor("figure");
         figure::properties& figp =
           dynamic_cast<figure::properties&> (fig.get_properties ());
-        
+
         switch(id)
           {
             case base_properties::ID_BEINGDELETED:
               uimenu->remove_from_menu (uimenup);
               break;
             case base_properties::ID_VISIBLE:
               uimenu->update_visible (uimenup);
               break;
@@ -821,37 +821,37 @@ public:
               break;
             case uimenu::properties::ID_POSITION:
               uimenu->add_to_menu (figp);//rebuilding entire menu
               break;
             case uimenu::properties::ID_SEPARATOR:
               uimenu->update_seperator (uimenup);
               break;
           }
-          
+
           if (uimenu->items_to_show ())
             show_menubar ();
           else
             hide_menubar ();
-          
+
           mark_modified();
       }
   }
 
   void show_canvas (void)
   {
     canvas->show ();
     canvas->make_current ();
   }
-  
+
   void hide_canvas (void)
   {
     canvas->hide ();
   }
-  
+
   void mark_modified (void)
   {
     damage (FL_DAMAGE_ALL);
     canvas->damage (FL_DAMAGE_ALL);
     ndim = calc_dimensions (gh_manager::get_object (fp.get___myhandle__ ()));
 
     if (ndim == 3)
       rotate->activate ();
@@ -904,20 +904,20 @@ private:
 
   void button_press (Fl_Widget* widg, void*)
   {
     if (widg == autoscale)
       axis_auto ();
 
     if (widg == togglegrid)
       toggle_grid ();
-    
+
     if (widg == panzoom)
       gui_mode = pan_zoom;
-    
+
     if (widg == rotate && ndim == 3)
       gui_mode = rotate_zoom;
 
     if (widg == help)
       fl_message ("%s", help_text);
   }
 
   fltk_uimenu* uimenu;
@@ -939,28 +939,28 @@ private:
     mark_modified ();
   }
 
   void toggle_grid (void)
   {
     octave_value_list args;
     if (fp.get_currentaxes ().ok ())
       args(0) = fp.get_currentaxes ().as_octave_value ();
-    
+
     feval ("grid", args);
     mark_modified ();
   }
-  
-  void pixel2pos 
+
+  void pixel2pos
   (graphics_handle ax, int px, int py, double& xx, double& yy) const
   {
     pixel2pos ( gh_manager::get_object (ax), px, py, xx, yy);
   }
 
-  void pixel2pos 
+  void pixel2pos
   (graphics_object ax, int px, int py, double& xx, double& yy) const
   {
     if (ax && ax.isa ("axes"))
       {
         axes::properties& ap =
           dynamic_cast<axes::properties&> (ax.get_properties ());
         ColumnVector pp = ap.pixel2coord (px, py);
         xx = pp(0);
@@ -990,17 +990,17 @@ private:
                   {
                     return hnd;
                   }
               }
           }
       }
     return fp.get_currentaxes ();
   }
-  
+
   void pixel2status (graphics_handle ax, int px0, int py0,
                      int px1 = -1, int py1 = -1)
   {
     pixel2status (gh_manager::get_object (ax), px0, py0, px1, py1);
   }
 
   void pixel2status (graphics_object ax, int px0, int py0,
                      int px1 = -1, int py1 = -1)
@@ -1020,48 +1020,48 @@ private:
     status->value (cbuf.str ().c_str ());
     status->redraw ();
   }
 
   void view2status (graphics_object ax)
   {
      if (ax && ax.isa ("axes"))
        {
-         axes::properties& ap = 
+         axes::properties& ap =
            dynamic_cast<axes::properties&> (ax.get_properties ());
          std::stringstream cbuf;
          cbuf.precision (4);
          cbuf.width (6);
          Matrix v (1,2,0);
          v = ap.get("view").matrix_value();
          cbuf << "[azimuth: " << v(0) << ", elevation: " << v(1) << "]";
-    
+
          status->value (cbuf.str ().c_str ());
          status->redraw ();
        }
   }
-  
+
   void set_currentpoint (int px, int py)
   {
     if (!fp.is_beingdeleted ())
       {
         Matrix pos (1,2,0);
         pos(0) = px;
         pos(1) = h () - status_h - menu_h - py;
         fp.set_currentpoint (pos);
       }
   }
 
   void set_axes_currentpoint (graphics_object ax, int px, int py)
   {
     if (ax.valid_object ())
       {
-        axes::properties& ap = 
+        axes::properties& ap =
           dynamic_cast<axes::properties&> (ax.get_properties ());
-    
+
         double xx, yy;
         pixel2pos (ax, px, py, xx, yy);
 
         Matrix pos (2,3,0);
         pos(0,0) = xx;
         pos(1,0) = yy;
         pos(0,1) = xx;
         pos(1,1) = yy;
@@ -1096,17 +1096,17 @@ private:
     if (key == FL_Escape) return 0x1b;
 
     return 0;
   }
 
   Cell modifier2cell ()
   {
     string_vector mod;
-    
+
     if (shift & FL_SHIFT)
       mod.append (std::string ("shift"));
     if (shift & FL_CTRL)
       mod.append (std::string ("control"));
     if (shift & FL_ALT || shift & FL_META)
       mod.append (std::string ("alt"));
 
     return Cell (mod);
@@ -1152,17 +1152,17 @@ private:
         switch (event)
           {
           case FL_KEYDOWN:
             {
               int key = Fl::event_key ();
 
               shift |= key2shift (key);
               int key_a = key2ascii (key);
-              if (key_a && fp.get_keypressfcn ().is_defined ()) 
+              if (key_a && fp.get_keypressfcn ().is_defined ())
                 {
                   Octave_map evt;
                   evt.assign ("Character", octave_value (key_a));
                   evt.assign ("Key", octave_value (std::tolower (key_a)));
                   evt.assign ("Modifier", octave_value (modifier2cell ()));
                   fp.execute_keypressfcn (evt);
                 }
               switch (key)
@@ -1212,55 +1212,55 @@ private:
                           Fl::event_x (), Fl::event_y ());
             break;
 
           case FL_PUSH:
             px0 = Fl::event_x ();
             py0 = Fl::event_y ();
 
             set_currentpoint (Fl::event_x (), Fl::event_y ());
-            
+
             gh = pixel2axes_or_ca (px0, py0);
 
             if (gh.ok ())
               {
                 ax0 = gh_manager::get_object (gh);
                 set_axes_currentpoint (ax0, px0, py0);
               }
-              
+
             fp.execute_windowbuttondownfcn ();
 
             if (Fl::event_button () == 1 || Fl::event_button () == 3)
               return 1;
 
             break;
 
           case FL_DRAG:
             if (fp.get_windowbuttonmotionfcn ().is_defined ())
               {
                 set_currentpoint (Fl::event_x (), Fl::event_y ());
                 fp.execute_windowbuttonmotionfcn ();
               }
-            
+
             if (Fl::event_button () == 1)
               {
                 if (ax0 && ax0.isa ("axes"))
                   {
                     if (gui_mode == pan_zoom)
                       pixel2status (ax0, px0, py0, Fl::event_x (), Fl::event_y ());
                     else
                       view2status (ax0);
-                    axes::properties& ap = 
+                    axes::properties& ap =
                       dynamic_cast<axes::properties&> (ax0.get_properties ());
-                  
+
                     double x0, y0, x1, y1;
                     Matrix pos = fp.get_position ().matrix_value ();
                     pixel2pos (ax0, px0, py0, x0, y0);
                     pixel2pos (ax0, Fl::event_x (), Fl::event_y (), x1, y1);
-                    
+
                     if (gui_mode == pan_zoom)
                       ap.translate_view (x0 - x1, y0 - y1);
                     else if (gui_mode == rotate_zoom)
                       {
                         double daz, del;
                         daz = (Fl::event_x () - px0) / pos(2) * 360;
                         del = (Fl::event_y () - py0) / pos(3) * 360;
                         ap.rotate_view (del, daz);
@@ -1284,45 +1284,45 @@ private:
                 canvas->zoom (true);
                 canvas->redraw ();
               }
 
             break;
 
           case FL_MOUSEWHEEL:
             {
-              graphics_object ax = 
-                gh_manager::get_object (pixel2axes_or_ca (Fl::event_x (), 
-                                                          Fl::event_y ()));                                                                      
+              graphics_object ax =
+                gh_manager::get_object (pixel2axes_or_ca (Fl::event_x (),
+                                                          Fl::event_y ()));
               if (ax && ax.isa ("axes"))
                 {
-                  axes::properties& ap = 
+                  axes::properties& ap =
                     dynamic_cast<axes::properties&> (ax.get_properties ());
-                  
+
                   // Determine if we're zooming in or out.
-                  const double factor = 
+                  const double factor =
                     (Fl::event_dy () > 0) ? 1.0 + wheel_zoom_speed : 1.0 - wheel_zoom_speed;
-                  
+
                   // Get the point we're zooming about.
                   double x1, y1;
                   pixel2pos (ax, Fl::event_x (), Fl::event_y (), x1, y1);
-                  
+
                   ap.zoom_about_point (x1, y1, factor, false);
                   mark_modified ();
                 }
             }
           return 1;
 
           case FL_RELEASE:
             if (fp.get_windowbuttonupfcn ().is_defined ())
               {
                 set_currentpoint (Fl::event_x (), Fl::event_y ());
                 fp.execute_windowbuttonupfcn ();
               }
-          
+
             if (Fl::event_button () == 1)
               {
                 if ( Fl::event_clicks () == 1)
                   {
                     if (ax0 && ax0.isa ("axes"))
                       {
                         axes::properties& ap =
                           dynamic_cast<axes::properties&> (ax0.get_properties ());
@@ -1473,40 +1473,40 @@ public:
     return get_size (hnd2idx (gh));
   }
 
   static void print (const graphics_handle& gh , const int fid,  const std::string& term)
   {
     if (instance_ok ())
       instance->do_print (hnd2idx(gh), fid, term);
   }
-  
+
   static void uimenu_update (const graphics_handle& figh, const graphics_handle& uimenuh, const int id)
   {
     if (instance_ok ())
       instance->do_uimenu_update (hnd2idx(figh), uimenuh, id);
   }
-  
+
   static void update_canvas (const graphics_handle& gh, const graphics_handle& ca)
   {
     if (instance_ok ())
       instance->do_update_canvas (hnd2idx(gh), ca);
   }
-  
+
   static void toggle_menubar_visibility (int fig_idx, bool menubar_is_figure)
   {
     if (instance_ok ())
       instance->do_toggle_menubar_visibility (fig_idx, menubar_is_figure);
   }
 
   static void toggle_menubar_visibility (std::string fig_idx_str, bool menubar_is_figure)
   {
     toggle_menubar_visibility (str2idx (fig_idx_str), menubar_is_figure);
   }
-  
+
 private:
 
   static figure_manager *instance;
 
   figure_manager (void) { }
 
   // No copying!
   figure_manager (const figure_manager&);
@@ -1570,21 +1570,21 @@ private:
   {
     wm_iterator win;
     if ((win = windows.find (fig_idx)) != windows.end ())
       {
         if (menubar_is_figure)
           win->second->show_menubar ();
         else
           win->second->hide_menubar ();
-        
+
         win->second->redraw ();
       }
   }
-  
+
   void do_mark_modified (int idx)
   {
     wm_iterator win;
     if ((win = windows.find (idx)) != windows.end ())
       {
         win->second->mark_modified ();
       }
   }
@@ -1624,30 +1624,30 @@ private:
   void do_uimenu_update (int idx, graphics_handle gh, int id)
   {
     wm_iterator win;
     if ((win = windows.find (idx)) != windows.end ())
       {
         win->second->uimenu_update (gh, id);
       }
   }
-  
+
   void do_update_canvas (int idx, graphics_handle ca)
   {
     wm_iterator win;
     if ((win = windows.find (idx)) != windows.end ())
       {
         if (ca.ok ())
           win->second->show_canvas ();
         else
           win->second->hide_canvas ();
       }
   }
-  
-  
+
+
   // FIXME -- default size should be configurable.
   void default_size (int& x, int& y, int& w, int& h)
   {
     x = 0;
     y = 0;
     w = 640;
     h = 480;
   }
@@ -1768,42 +1768,42 @@ public:
   }
 
   void uimenu_set_fltk_label(graphics_object uimenu_obj)
   {
     if (uimenu_obj.valid_object ())
       {
         uimenu::properties& uimenup =
           dynamic_cast<uimenu::properties&> (uimenu_obj.get_properties ());
-        std::string fltk_label = uimenup.get_label ();  
+        std::string fltk_label = uimenup.get_label ();
         graphics_object go = gh_manager::get_object (uimenu_obj.get_parent ());
         if (go.isa ("uimenu"))
           fltk_label = dynamic_cast<const uimenu::properties&> (go.get_properties ()).get_fltk_label ()
                      + "/"
                      + fltk_label;
         else if (go.isa ("figure"))
           ;
         else
           error("unexpected parent object\n");
-        
+
         uimenup.set_fltk_label(fltk_label);
       }
   }
-  
+
   void update (const graphics_object& go, int id)
   {
     if (go.isa ("figure"))
       {
         octave_value ov = go.get (caseless_str ("__plot_stream__"));
-        
+
         if (! ov.is_empty ())
           {
             const figure::properties& fp =
               dynamic_cast<const figure::properties&> (go.get_properties ());
-            
+
             switch (id)
               {
                 case base_properties::ID_VISIBLE:
                   figure_manager::toggle_window_visibility (ov.string_value (), fp.is_visible ());
                   break;
                 case figure::properties::ID_MENUBAR:
                   figure_manager::toggle_menubar_visibility (ov.string_value (), fp.menubar_is("figure"));
                   break;
@@ -1816,34 +1816,34 @@ public:
                   break;
               }
           }
       }
     else if (go.isa ("uimenu"))
       {
         if (id == uimenu::properties::ID_LABEL)
           uimenu_set_fltk_label (go);
-        
+
         graphics_object fig = go.get_ancestor("figure");
         figure_manager::uimenu_update(fig.get_handle (), go.get_handle (), id);
       }
   }
 
   void redraw_figure (const graphics_object& go) const
   {
     figure_manager::mark_modified (go.get_handle ());
 
     __fltk_redraw__ ();
   }
 
   void print_figure (const graphics_object& go,
                      const std::string& term,
                      const std::string& file, bool /*mono*/,
-                     const std::string& /*debug_file*/) const 
-  { 
+                     const std::string& /*debug_file*/) const
+  {
     int fid;
     std::istringstream istr (file);
     if (istr >> fid)
       {
         figure_manager::print (go.get_handle (), fid, term);
         redraw_figure (go);
       }
     else
@@ -1877,17 +1877,17 @@ DEFUN_DLD (__init_fltk__, , , "")
   static bool remove_fltk_registered = false;
 
   if (! toolkit_registered)
     {
       mlock ();
 
       graphics_toolkit::register_toolkit (new fltk_graphics_toolkit);
       toolkit_registered = true;
-      
+
       octave_value_list args;
       args(0) = "__fltk_redraw__";
       feval ("add_input_event_hook", args, 0);
 
       if (! remove_fltk_registered)
         {
           octave_add_atexit_function ("__remove_fltk__");
 
@@ -1922,17 +1922,17 @@ DEFUN_DLD (__remove_fltk__, , , "")
       args(0) = "__fltk_redraw__";
       feval ("remove_input_event_hook", args, 0);
 
       // FIXME ???
       Fl::wait (fltk_maxtime);
     }
 
   octave_value retval;
-  return retval;        
+  return retval;
 }
 
 DEFUN_DLD (__fltk_maxtime__, args, ,"")
 {
   octave_value retval = fltk_maxtime;
 
   if (args.length () == 1)
     {
@@ -1986,20 +1986,20 @@ Mouse inputs have no effect.\n\
   caseless_str mode_str;
 
   if (gui_mode == pan_zoom)
     mode_str = "2d";
   else if (gui_mode == rotate_zoom)
     mode_str = "3d";
   else
     mode_str = "none";
-  
-  
+
+
   bool failed = false;
-  
+
   if (args.length () == 1)
     {
       if (args(0).is_string ())
         {
           mode_str = args(0).string_value ();
 
           if (mode_str.compare ("2d"))
             gui_mode = pan_zoom;
@@ -2008,21 +2008,21 @@ Mouse inputs have no effect.\n\
           else if (mode_str.compare ("none"))
             gui_mode = none;
           else
             failed = true;
         }
       else
         failed = true;
     }
-    
+
   if (failed)
     error ("MODE must be one of the strings: ""2D"", ""3D"", or ""None"".");
-  
-  
+
+
   return octave_value(mode_str);
 }
 
 #include "file-ops.h"
 DEFUN_DLD (__fltk_uigetfile__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __fltk_uigetfile__ (@dots{})\n\
 Undocumented internal function.\n\
@@ -2030,95 +2030,95 @@ Undocumented internal function.\n\
 {
   // This function should be called by uigetfile.m
   // Error checking should be done in uigetfile.m!
   //
   // Expected argument list
   // args(0) ... FileFilter in fltk format
   // args(1) ... Title
   // args(2) ... Default Filename
-  // args(3) ... PostionValue [x,y] 
+  // args(3) ... PostionValue [x,y]
   // args(4) ... SelectValue "on"/"off"/"dir"/"create"
-  
+
   std::string file_filter, title, default_name, multi;
   if (args(0).is_string ())
     file_filter = args(0).string_value();
-    
+
   if (args(1).is_string ())
     title = args(1).string_value();
-    
+
   if (args(2).is_string ())
     default_name = args(2).string_value();
-    
+
   if (args(3).is_real_matrix ())
     Matrix pos = args(3).matrix_value();
-    
+
   int multi_type = Fl_File_Chooser::SINGLE;
   std::string flabel = "Filename:";
   if (args(4).is_string ())
     {
       multi = args(4).string_value();
       if (multi == "on")
         multi_type = Fl_File_Chooser::MULTI;
       else if (multi == "dir")
         {
           multi_type = Fl_File_Chooser::DIRECTORY;
           flabel = "Directory:";
         }
       else if (multi == "create")
         multi_type = Fl_File_Chooser::CREATE;
     }
-  
-  Fl_File_Chooser::filename_label = flabel.c_str ();  
+
+  Fl_File_Chooser::filename_label = flabel.c_str ();
   Fl_File_Chooser *fc = new Fl_File_Chooser(default_name.c_str (), file_filter.c_str (), multi_type, title.c_str ());
   fc->preview(0);
-  
+
   if (multi_type == Fl_File_Chooser::CREATE)
     fc->ok_label("Save");
-  
+
   fc->show();
   while (fc->shown ())
         { Fl::wait (); }
 
   octave_value_list fargs, retval;
-  
+
   retval(0) = octave_value(0);
   retval(1) = octave_value(0);
   retval(2) = octave_value(0);
-  
+
   if (fc->value() != NULL)
     {
       int file_count = fc->count ();
       std::string fname;
       std::string sep = file_ops::dir_sep_str ();
       std::size_t idx;
-      
+
       if ((file_count == 1) && (multi_type != Fl_File_Chooser::DIRECTORY))
         {
-          fname = fc->value ();    
+          fname = fc->value ();
           idx = fname.find_last_of(sep);
           retval(0) = fname.substr(idx + 1);
         }
-      else  
+      else
         {
           Cell file_cell = Cell(file_count, 1);
           for (octave_idx_type n = 1; n <= file_count; n++)
             {
-              fname = fc->value (n);    
+              fname = fc->value (n);
               idx = fname.find_last_of(sep);
               file_cell(n - 1) = fname.substr(idx + 1);
             }
           retval(0) = file_cell;
         }
-        
+
       if (multi_type == Fl_File_Chooser::DIRECTORY)
         retval(0) = std::string(fc->value ());
       else
         {
           retval(1) = std::string(fc->directory ()) + sep;
           retval(2) = fc->filter_value();
         }
     }
-  
+
   return retval;
 }
 
 #endif
diff --git a/src/DLD-FUNCTIONS/__lin_interpn__.cc b/src/DLD-FUNCTIONS/__lin_interpn__.cc
--- a/src/DLD-FUNCTIONS/__lin_interpn__.cc
+++ b/src/DLD-FUNCTIONS/__lin_interpn__.cc
@@ -195,17 +195,17 @@ lin_interpn (int n, M *X, const M V, M *
   for (int i = 0; i < n; i++)
     {
       y[i] = Y[i].data ();
       size[i] =  V.dims()(i);
     }
 
   OCTAVE_LOCAL_BUFFER (const T *, x, n);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, scale, n);
-  
+
   const T *v = V.data ();
   T *vi = Vi.fortran_vec ();
   octave_idx_type Ni = Vi.numel ();
 
   T extrapval = octave_NA;
 
   // offset in memory of each dimension
 
@@ -314,17 +314,17 @@ Undocumented internal function.\n\
             {
               error ("interpn: incompatible size of argument number %d", n+i+2);
               return retval;
             }
         }
 
       retval = lin_interpn<float, FloatNDArray> (n, X, V, Y);
     }
-  else  
+  else
     {
       OCTAVE_LOCAL_BUFFER (NDArray, X, n);
       OCTAVE_LOCAL_BUFFER (NDArray, Y, n);
 
       const NDArray V = args(n).array_value ();
 
       if (error_state)
         {
@@ -344,14 +344,14 @@ Undocumented internal function.\n\
             }
 
           if (Y[0].dims () != Y[i].dims ())
             {
               error ("interpn: incompatible size of argument number %d", n+i+2);
               return retval;
             }
         }
-      
+
       retval = lin_interpn<double, NDArray> (n, X, V, Y);
     }
 
   return retval;
 }
diff --git a/src/DLD-FUNCTIONS/__magick_read__.cc b/src/DLD-FUNCTIONS/__magick_read__.cc
--- a/src/DLD-FUNCTIONS/__magick_read__.cc
+++ b/src/DLD-FUNCTIONS/__magick_read__.cc
@@ -423,17 +423,17 @@ function.  Instead use @code{imread}.\n\
       return output;
     }
 
   Array<int> frameidx;
   bool all_frames = false;
 
   if (args.length () == 2 && args(1).is_real_type ())
     frameidx = args(1).int_vector_value();
-  else if (args.length () == 3 && args(1).is_string () 
+  else if (args.length () == 3 && args(1).is_string ()
            && args(1).string_value() == "frames")
     {
       if (args(2).is_string () && args(2).string_value() == "all")
         all_frames = true;
       else if (args(2).is_real_type ())
         frameidx = args(2).int_vector_value();
     }
   else
@@ -494,17 +494,17 @@ function.  Instead use @code{imread}.\n\
       if (depth > 1)
         {
           --depth;
           int i = 1;
           while (depth >>= 1)
             i++;
           depth = 1 << i;
         }
-      
+
       switch (depth)
         {
         case 1:
           output = read_images<boolNDArray> (imvec, frameidx, depth);
           break;
 
         case 2:
         case 4:
@@ -1018,18 +1018,18 @@ not be using this function.  Instead use
 
   const std::string filename = args (0).string_value ();
 
   try
     {
       // Read the file.
       std::vector<Magick::Image> imvec;
       Magick::readImages (&imvec, args(0).string_value ());
-      int nframes = imvec.size (); 
-      
+      int nframes = imvec.size ();
+
       // Create the right size for the output.
 
       static const char *fields[] =
         {
           "Filename",
           "FileModDate",
           "FileSize",
           "Height",
@@ -1077,21 +1077,21 @@ not be using this function.  Instead use
           return retval;
         }
 
       // For each frame in the image (some images contain multiple
       // layers, each to be treated like a separate image).
       for (int frame = 0; frame < nframes; frame++)
         {
           Magick::Image im = imvec[frame];
-      
+
           // Add file name and timestamp.
           info.contents ("Filename")(frame,0) = filename;
           info.contents ("FileModDate")(frame,0) = filetime;
-          
+
           // Annoying CamelCase naming is for Matlab compatibility.
           GET_PARAM (fileSize, "FileSize")
           GET_PARAM (rows, "Height")
           GET_PARAM (columns, "Width")
           GET_PARAM (depth, "BitDepth")
           GET_PARAM (magick, "Format")
           GET_PARAM (format, "LongFormat")
           GET_PARAM (xResolution, "XResolution")
diff --git a/src/DLD-FUNCTIONS/__pchip_deriv__.cc b/src/DLD-FUNCTIONS/__pchip_deriv__.cc
--- a/src/DLD-FUNCTIONS/__pchip_deriv__.cc
+++ b/src/DLD-FUNCTIONS/__pchip_deriv__.cc
@@ -1,9 +1,9 @@
-/* 
+/*
 
 Copyright (C) 2002-2011 Kai Habel
 Copyright (C) 2008-2009 Jaroslav Hajek
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
@@ -83,17 +83,17 @@ Undocumented internal function.\n\
           float *dvec = dmat.fortran_vec ();
 
           octave_idx_type ierr;
           const octave_idx_type incfd = rows ? nyr : 1;
           const octave_idx_type inc = rows ? 1 : nyr;
 
           for (octave_idx_type i = (rows ? nyr : nyc); i > 0; i--)
             {
-              F77_FUNC (pchim, PCHIM) (nx, xvec.data (), 
+              F77_FUNC (pchim, PCHIM) (nx, xvec.data (),
                                        yvec, dvec, incfd, &ierr);
 
               yvec += inc;
               dvec += inc;
 
               if (ierr < 0)
                 {
                   error ("PCHIM: error: %i\n", ierr);
@@ -123,17 +123,17 @@ Undocumented internal function.\n\
           double *dvec = dmat.fortran_vec ();
 
           octave_idx_type ierr;
           const octave_idx_type incfd = rows ? nyr : 1;
           const octave_idx_type inc = rows ? 1 : nyr;
 
           for (octave_idx_type i = (rows ? nyr : nyc); i > 0; i--)
             {
-              F77_FUNC (dpchim, DPCHIM) (nx, xvec.data (), 
+              F77_FUNC (dpchim, DPCHIM) (nx, xvec.data (),
                                          yvec, dvec, incfd, &ierr);
 
               yvec += inc;
               dvec += inc;
 
               if (ierr < 0)
                 {
                   error ("DPCHIM: error: %i\n", ierr);
diff --git a/src/DLD-FUNCTIONS/__qp__.cc b/src/DLD-FUNCTIONS/__qp__.cc
--- a/src/DLD-FUNCTIONS/__qp__.cc
+++ b/src/DLD-FUNCTIONS/__qp__.cc
@@ -252,17 +252,17 @@ qp (const Matrix& H, const ColumnVector&
               if (pR == 0)
                 R = tR;
             }
 
           if (pR == 0)
             {
               info = 0;
 
-              // Computing the step pz. 
+              // Computing the step pz.
               if (dimZ > 0)
                 {
                   // Using the Cholesky factorization to invert rH
 
                   Matrix rHinv = chol2inv (R);
 
                   ColumnVector pz = -rHinv * Zt * g;
 
diff --git a/src/DLD-FUNCTIONS/__voronoi__.cc b/src/DLD-FUNCTIONS/__voronoi__.cc
--- a/src/DLD-FUNCTIONS/__voronoi__.cc
+++ b/src/DLD-FUNCTIONS/__voronoi__.cc
@@ -62,27 +62,27 @@ Undocumented internal function.\n\
 {
   octave_value_list retval;
 
 #ifdef HAVE_QHULL
 
   retval(0) = 0.0;
 
   int nargin = args.length ();
-  if (nargin < 1 || nargin > 2) 
+  if (nargin < 1 || nargin > 2)
     {
       print_usage ();
       return retval;
     }
 
   const char *options;
 
-  if (nargin == 2) 
+  if (nargin == 2)
     {
-      if (! args (1).is_string ()) 
+      if (! args (1).is_string ())
         {
           error ("__voronoi__: OPTIONS argument must be a string");
           return retval;
         }
 
       options = args (1).string_value().c_str ();
     }
   else
@@ -92,17 +92,17 @@ Undocumented internal function.\n\
 
   const octave_idx_type dim = p.columns ();
   const octave_idx_type np = p.rows ();
   p = p.transpose ();
 
   double *pt_array = p.fortran_vec ();
 
   //double  pt_array[dim * np];
-  //for (int i = 0; i < np; i++) 
+  //for (int i = 0; i < np; i++)
   //  {
   //    for (int j = 0; j < dim; j++)
   //      {
   //        pt_array[j+i*dim] = p(i,j);
   //      }
   //  }
 
   boolT ismalloc = false;
@@ -113,37 +113,37 @@ Undocumented internal function.\n\
   sprintf (flags, "qhull v Fv T0 %s", options);
 
   // If you want some debugging information replace the 0 pointer
   // with stdout or some other file open for writing.
 
   FILE *outfile = 0;
   FILE *errfile = stderr;
 
-  if (! qh_new_qhull (dim, np, pt_array, ismalloc, flags, outfile, errfile)) 
+  if (! qh_new_qhull (dim, np, pt_array, ismalloc, flags, outfile, errfile))
     {
       facetT *facet;
       vertexT *vertex;
 
       octave_idx_type i = 0, n = 1, k = 0, m = 0, fidx = 0, j = 0, r = 0;
       OCTAVE_LOCAL_BUFFER (octave_idx_type, ni, np);
-      
-      for (i = 0; i < np; i++) 
+
+      for (i = 0; i < np; i++)
         ni[i] = 0;
       qh_setvoronoi_all ();
       bool infinity_seen = false;
       facetT *neighbor, **neighborp;
       coordT *voronoi_vertex;
 
-      FORALLfacets 
+      FORALLfacets
         {
           facet->seen = false;
         }
 
-      FORALLvertices 
+      FORALLvertices
         {
           if (qh hull_dim == 3)
             qh_order_vertexneighbors (vertex);
           infinity_seen = false;
 
           FOREACHneighbor_ (vertex)
             {
               if (! neighbor->upperdelaunay)
@@ -164,23 +164,23 @@ Undocumented internal function.\n\
           k++;
         }
 
       Matrix v (n, dim);
       for (octave_idx_type d = 0; d < dim; d++)
         v(0,d) = octave_Inf;
 
       boolMatrix AtInf (np, 1);
-      for (i = 0; i < np; i++) 
+      for (i = 0; i < np; i++)
         AtInf(i) = false;
       octave_value_list F (np, octave_value ());
       k = 0;
       i = 0;
 
-      FORALLfacets 
+      FORALLfacets
         {
           facet->seen = false;
         }
 
       FORALLvertices
         {
           if (qh hull_dim == 3)
             qh_order_vertexneighbors(vertex);
@@ -193,18 +193,18 @@ Undocumented internal function.\n\
               if (neighbor->upperdelaunay)
                 {
                   if (! infinity_seen)
                     {
                       infinity_seen = true;
                       facet_list(m++) = 1;
                       AtInf(j) = true;
                     }
-                } 
-              else 
+                }
+              else
                 {
                   if (! neighbor->seen)
                     {
                       voronoi_vertex = neighbor->center;
                       fidx = neighbor->id;
                       i++;
                       for (octave_idx_type d = 0; d < dim; d++)
                         {
diff --git a/src/DLD-FUNCTIONS/amd.cc b/src/DLD-FUNCTIONS/amd.cc
--- a/src/DLD-FUNCTIONS/amd.cc
+++ b/src/DLD-FUNCTIONS/amd.cc
@@ -117,34 +117,34 @@ The author of the code itself is Timothy
             }
         }
       else
         {
           if (args(0).is_complex_type ())
             sm = SparseMatrix (real (args(0).complex_matrix_value ()));
           else
             sm = SparseMatrix (args(0).matrix_value ());
-          
+
           n_row = sm.rows ();
           n_col = sm.cols ();
           ridx = sm.xridx ();
           cidx = sm.xcidx ();
         }
 
       if (!error_state && n_row != n_col)
         error ("amd: matrix S must be square");
 
       if (!error_state)
         {
           OCTAVE_LOCAL_BUFFER (double, Control, AMD_CONTROL);
           AMD_NAME (_defaults) (Control) ;
           if (nargin > 1)
             {
               octave_scalar_map arg1 = args(1).scalar_map_value ();
-          
+
               if (!error_state)
                 {
                   octave_value tmp;
 
                   tmp = arg1.getfield ("dense");
                   if (tmp.is_defined ())
                     Control[AMD_DENSE] = tmp.double_value ();
 
@@ -158,17 +158,17 @@ The author of the code itself is Timothy
 
           if (!error_state)
             {
               OCTAVE_LOCAL_BUFFER (octave_idx_type, P, n_col);
               Matrix xinfo (AMD_INFO, 1);
               double *Info = xinfo.fortran_vec ();
 
               // FIXME -- how can we manage the memory allocation of
-              // amd in a cleaner manner? 
+              // amd in a cleaner manner?
               amd_malloc = malloc;
               amd_free = free;
               amd_calloc = calloc;
               amd_realloc = realloc;
               amd_printf = printf;
 
               octave_idx_type result = AMD_NAME (_order) (n_col, cidx, ridx, P,
                                                           Control, Info);
diff --git a/src/DLD-FUNCTIONS/balance.cc b/src/DLD-FUNCTIONS/balance.cc
--- a/src/DLD-FUNCTIONS/balance.cc
+++ b/src/DLD-FUNCTIONS/balance.cc
@@ -105,20 +105,20 @@ Generalized eigenvalue problem balancing
   octave_idx_type nn = args(0).rows ();
 
   if (nn != args(0).columns())
     {
       gripe_square_matrix_required ("balance");
       return retval;
     }
 
-  bool isfloat = args(0).is_single_type () || 
-    (! AEPcase && args(1).is_single_type()); 
+  bool isfloat = args(0).is_single_type () ||
+    (! AEPcase && args(1).is_single_type());
 
-  bool complex_case = (args(0).is_complex_type () || 
+  bool complex_case = (args(0).is_complex_type () ||
                        (! AEPcase && args(1).is_complex_type ()));
 
   // Extract argument 1 parameter for both AEP and GEP.
   Matrix aa;
   ComplexMatrix caa;
   FloatMatrix faa;
   FloatComplexMatrix fcaa;
 
@@ -137,17 +137,17 @@ Generalized eigenvalue problem balancing
         aa = args(0).matrix_value ();
     }
 
   if (error_state)
     return retval;
 
   // Treat AEP/GEP cases.
   if (AEPcase)
-    {  
+    {
       // Algebraic eigenvalue problem.
       bool noperm = false, noscal = false;
       if (nargin > 1)
         {
           std::string a1s = args(1).string_value ();
           noperm = a1s == "noperm" || a1s == "S";
           noscal = a1s == "noscal" || a1s == "P";
         }
diff --git a/src/DLD-FUNCTIONS/besselj.cc b/src/DLD-FUNCTIONS/besselj.cc
--- a/src/DLD-FUNCTIONS/besselj.cc
+++ b/src/DLD-FUNCTIONS/besselj.cc
@@ -158,17 +158,17 @@ do_bessel (enum bessel_type type, const 
               bool args1_is_col_vector = (dv1 (0) == dv1.numel ());
 
               if (args0_is_row_vector && args1_is_col_vector)
                 {
                   FloatRowVector ralpha = args(0).float_row_vector_value ();
 
                   if (! error_state)
                     {
-                      FloatComplexColumnVector cx = 
+                      FloatComplexColumnVector cx =
                         x_arg.float_complex_column_vector_value ();
 
                       if (! error_state)
                         {
                           Array<octave_idx_type> ierr;
                           octave_value result;
 
                           DO_BESSEL (type, ralpha, cx, scaled, ierr, result);
@@ -212,19 +212,19 @@ do_bessel (enum bessel_type type, const 
                       else
                         {
                           FloatComplexNDArray x = x_arg.float_complex_array_value ();
 
                           if (! error_state)
                             {
                               Array<octave_idx_type> ierr;
                               octave_value result;
-                          
+
                               DO_BESSEL (type, alpha, x, scaled, ierr, result);
-                          
+
                               if (nargout > 1)
                                 retval(1) = NDArray (ierr);
 
                               retval(0) = result;
                             }
                           else
                             gripe_bessel_arg (fn, "second");
                         }
@@ -293,17 +293,17 @@ do_bessel (enum bessel_type type, const 
               bool args1_is_col_vector = (dv1 (0) == dv1.numel ());
 
               if (args0_is_row_vector && args1_is_col_vector)
                 {
                   RowVector ralpha = args(0).row_vector_value ();
 
                   if (! error_state)
                     {
-                      ComplexColumnVector cx = 
+                      ComplexColumnVector cx =
                         x_arg.complex_column_vector_value ();
 
                       if (! error_state)
                         {
                           Array<octave_idx_type> ierr;
                           octave_value result;
 
                           DO_BESSEL (type, ralpha, cx, scaled, ierr, result);
@@ -347,19 +347,19 @@ do_bessel (enum bessel_type type, const 
                       else
                         {
                           ComplexNDArray x = x_arg.complex_array_value ();
 
                           if (! error_state)
                             {
                               Array<octave_idx_type> ierr;
                               octave_value result;
-                          
+
                               DO_BESSEL (type, alpha, x, scaled, ierr, result);
-                          
+
                               if (nargout > 1)
                                 retval(1) = NDArray (ierr);
 
                               retval(0) = result;
                             }
                           else
                             gripe_bessel_arg (fn, "second");
                         }
@@ -582,17 +582,17 @@ return @code{NaN}.\n\
       if (nargin > 1)
         {
           kind = args(0).int_value ();
 
           if (! error_state)
             {
               if (kind < 0 || kind > 3)
                 error ("airy: expecting K = 0, 1, 2, or 3");
-            }         
+            }
           else
             error ("airy: expecting integer value for K");
         }
 
       if (! error_state)
         {
           int idx = nargin == 1 ? 0 : 1;
 
@@ -655,277 +655,277 @@ return @code{NaN}.\n\
 %!
 %! # Bessel functions, even order, positive and negative x
 %! alpha = 2; x = 1.25;
 %! jx = 0.1710911312405234823613091417;
 %! yx = -1.193199310178553861283790424;
 %! ix = 0.2220184483766341752692212604;
 %! kx = 0.9410016167388185767085460540;
 %!
-%!assert(besselj(alpha,x), jx, 100*eps) 
+%!assert(besselj(alpha,x), jx, 100*eps)
 %!assert(bessely(alpha,x), yx, 100*eps)
 %!assert(besseli(alpha,x), ix, 100*eps)
-%!assert(besselk(alpha,x), kx, 100*eps) 
+%!assert(besselk(alpha,x), kx, 100*eps)
 %!assert(besselh(alpha,1,x), jx + I*yx, 100*eps)
 %!assert(besselh(alpha,2,x), jx - I*yx, 100*eps)
 %!
-%!assert(besselj(alpha,x,1), jx*exp(-abs(imag(x))), 100*eps) 
+%!assert(besselj(alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
 %!assert(bessely(alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
 %!assert(besseli(alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
-%!assert(besselk(alpha,x,1), kx*exp(x), 100*eps) 
+%!assert(besselk(alpha,x,1), kx*exp(x), 100*eps)
 %!assert(besselh(alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
 %!assert(besselh(alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
 %!
-%!assert(besselj(-alpha,x), jx, 100*eps) 
+%!assert(besselj(-alpha,x), jx, 100*eps)
 %!assert(bessely(-alpha,x), yx, 100*eps)
 %!assert(besseli(-alpha,x), ix, 100*eps)
-%!assert(besselk(-alpha,x), kx, 100*eps) 
+%!assert(besselk(-alpha,x), kx, 100*eps)
 %!assert(besselh(-alpha,1,x), jx + I*yx, 100*eps)
 %!assert(besselh(-alpha,2,x), jx - I*yx, 100*eps)
 %!
-%!assert(besselj(-alpha,x,1), jx*exp(-abs(imag(x))), 100*eps) 
+%!assert(besselj(-alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
 %!assert(bessely(-alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
 %!assert(besseli(-alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
-%!assert(besselk(-alpha,x,1), kx*exp(x), 100*eps) 
+%!assert(besselk(-alpha,x,1), kx*exp(x), 100*eps)
 %!assert(besselh(-alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
 %!assert(besselh(-alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
 %!
 %! x *= -1;
 %! yx = -1.193199310178553861283790424 + 0.3421822624810469647226182835*I;
 %! kx = 0.9410016167388185767085460540 - 0.6974915263814386815610060884*I;
 %!
-%!assert(besselj(alpha,x), jx, 100*eps) 
+%!assert(besselj(alpha,x), jx, 100*eps)
 %!assert(bessely(alpha,x), yx, 100*eps)
 %!assert(besseli(alpha,x), ix, 100*eps)
-%!assert(besselk(alpha,x), kx, 100*eps) 
+%!assert(besselk(alpha,x), kx, 100*eps)
 %!assert(besselh(alpha,1,x), jx + I*yx, 100*eps)
 %!assert(besselh(alpha,2,x), jx - I*yx, 100*eps)
 %!
-%!assert(besselj(alpha,x,1), jx*exp(-abs(imag(x))), 100*eps) 
+%!assert(besselj(alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
 %!assert(bessely(alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
 %!assert(besseli(alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
-%!assert(besselk(alpha,x,1), kx*exp(x), 100*eps) 
+%!assert(besselk(alpha,x,1), kx*exp(x), 100*eps)
 %!assert(besselh(alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
 %!assert(besselh(alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
 %!
 %! # Bessel functions, odd order, positive and negative x
 %! alpha = 3; x = 2.5;
 %! jx = 0.2166003910391135247666890035;
 %! yx = -0.7560554967536709968379029772;
 %! ix = 0.4743704087780355895548240179;
 %! kx = 0.2682271463934492027663765197;
 %!
-%!assert(besselj(alpha,x), jx, 100*eps) 
+%!assert(besselj(alpha,x), jx, 100*eps)
 %!assert(bessely(alpha,x), yx, 100*eps)
 %!assert(besseli(alpha,x), ix, 100*eps)
-%!assert(besselk(alpha,x), kx, 100*eps) 
+%!assert(besselk(alpha,x), kx, 100*eps)
 %!assert(besselh(alpha,1,x), jx + I*yx, 100*eps)
 %!assert(besselh(alpha,2,x), jx - I*yx, 100*eps)
 %!
-%!assert(besselj(alpha,x,1), jx*exp(-abs(imag(x))), 100*eps) 
+%!assert(besselj(alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
 %!assert(bessely(alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
 %!assert(besseli(alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
-%!assert(besselk(alpha,x,1), kx*exp(x), 100*eps) 
+%!assert(besselk(alpha,x,1), kx*exp(x), 100*eps)
 %!assert(besselh(alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
 %!assert(besselh(alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
 %!
-%!assert(besselj(-alpha,x), -jx, 100*eps) 
+%!assert(besselj(-alpha,x), -jx, 100*eps)
 %!assert(bessely(-alpha,x), -yx, 100*eps)
 %!assert(besseli(-alpha,x), ix, 100*eps)
-%!assert(besselk(-alpha,x), kx, 100*eps) 
+%!assert(besselk(-alpha,x), kx, 100*eps)
 %!assert(besselh(-alpha,1,x), -(jx + I*yx), 100*eps)
 %!assert(besselh(-alpha,2,x), -(jx - I*yx), 100*eps)
 %!
-%!assert(besselj(-alpha,x,1), -jx*exp(-abs(imag(x))), 100*eps) 
+%!assert(besselj(-alpha,x,1), -jx*exp(-abs(imag(x))), 100*eps)
 %!assert(bessely(-alpha,x,1), -yx*exp(-abs(imag(x))), 100*eps)
 %!assert(besseli(-alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
-%!assert(besselk(-alpha,x,1), kx*exp(x), 100*eps) 
+%!assert(besselk(-alpha,x,1), kx*exp(x), 100*eps)
 %!assert(besselh(-alpha,1,x,1), -(jx + I*yx)*exp(-I*x), 100*eps)
 %!assert(besselh(-alpha,2,x,1), -(jx - I*yx)*exp(I*x), 100*eps)
 %!
 %! x *= -1;
 %! jx = -jx;
 %! yx = 0.7560554967536709968379029772 - 0.4332007820782270495333780070*I;
 %! ix = -ix;
 %! kx = -0.2682271463934492027663765197 - 1.490278591297463775542004240*I;
 %!
-%!assert(besselj(alpha,x), jx, 100*eps) 
+%!assert(besselj(alpha,x), jx, 100*eps)
 %!assert(bessely(alpha,x), yx, 100*eps)
 %!assert(besseli(alpha,x), ix, 100*eps)
-%!assert(besselk(alpha,x), kx, 100*eps) 
+%!assert(besselk(alpha,x), kx, 100*eps)
 %!assert(besselh(alpha,1,x), jx + I*yx, 100*eps)
 %!assert(besselh(alpha,2,x), jx - I*yx, 100*eps)
 %!
-%!assert(besselj(alpha,x,1), jx*exp(-abs(imag(x))), 100*eps) 
+%!assert(besselj(alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
 %!assert(bessely(alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
 %!assert(besseli(alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
-%!assert(besselk(alpha,x,1), kx*exp(x), 100*eps) 
+%!assert(besselk(alpha,x,1), kx*exp(x), 100*eps)
 %!assert(besselh(alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
 %!assert(besselh(alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
 %!
 %! # Bessel functions, fractional order, positive and negative x
 %!
 %! alpha = 3.5; x = 2.75;
 %! jx = 0.1691636439842384154644784389;
 %! yx = -0.8301381935499356070267953387;
 %! ix = 0.3930540878794826310979363668;
 %! kx = 0.2844099013460621170288192503;
 %!
-%!assert(besselj(alpha,x), jx, 100*eps) 
+%!assert(besselj(alpha,x), jx, 100*eps)
 %!assert(bessely(alpha,x), yx, 100*eps)
 %!assert(besseli(alpha,x), ix, 100*eps)
-%!assert(besselk(alpha,x), kx, 100*eps) 
+%!assert(besselk(alpha,x), kx, 100*eps)
 %!assert(besselh(alpha,1,x), jx + I*yx, 100*eps)
 %!assert(besselh(alpha,2,x), jx - I*yx, 100*eps)
 %!
-%!assert(besselj(alpha,x,1), jx*exp(-abs(imag(x))), 100*eps) 
+%!assert(besselj(alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
 %!assert(bessely(alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
 %!assert(besseli(alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
-%!assert(besselk(alpha,x,1), kx*exp(x), 100*eps) 
+%!assert(besselk(alpha,x,1), kx*exp(x), 100*eps)
 %!assert(besselh(alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
 %!assert(besselh(alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
 %!
 %! nix = 0.2119931212254662995364461998;
 %!
-%!assert(besselj(-alpha,x), yx, 100*eps) 
+%!assert(besselj(-alpha,x), yx, 100*eps)
 %!assert(bessely(-alpha,x), -jx, 100*eps)
 %!assert(besseli(-alpha,x), nix, 100*eps)
-%!assert(besselk(-alpha,x), kx, 100*eps) 
+%!assert(besselk(-alpha,x), kx, 100*eps)
 %!assert(besselh(-alpha,1,x), -I*(jx + I*yx), 100*eps)
 %!assert(besselh(-alpha,2,x), I*(jx - I*yx), 100*eps)
 %!
-%!assert(besselj(-alpha,x,1), yx*exp(-abs(imag(x))), 100*eps) 
+%!assert(besselj(-alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
 %!assert(bessely(-alpha,x,1), -jx*exp(-abs(imag(x))), 100*eps)
 %!assert(besseli(-alpha,x,1), nix*exp(-abs(real(x))), 100*eps)
-%!assert(besselk(-alpha,x,1), kx*exp(x), 100*eps) 
+%!assert(besselk(-alpha,x,1), kx*exp(x), 100*eps)
 %!assert(besselh(-alpha,1,x,1), -I*(jx + I*yx)*exp(-I*x), 100*eps)
 %!assert(besselh(-alpha,2,x,1), I*(jx - I*yx)*exp(I*x), 100*eps)
 %!
 %! x *= -1;
 %! jx *= -I;
 %! yx = -0.8301381935499356070267953387*I;
 %! ix *= -I;
 %! kx = -0.9504059335995575096509874508*I;
 %!
-%!assert(besselj(alpha,x), jx, 100*eps) 
+%!assert(besselj(alpha,x), jx, 100*eps)
 %!assert(bessely(alpha,x), yx, 100*eps)
 %!assert(besseli(alpha,x), ix, 100*eps)
-%!assert(besselk(alpha,x), kx, 100*eps) 
+%!assert(besselk(alpha,x), kx, 100*eps)
 %!assert(besselh(alpha,1,x), jx + I*yx, 100*eps)
 %!assert(besselh(alpha,2,x), jx - I*yx, 100*eps)
 %!
-%!assert(besselj(alpha,x,1), jx*exp(-abs(imag(x))), 100*eps) 
+%!assert(besselj(alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
 %!assert(bessely(alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
 %!assert(besseli(alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
-%!assert(besselk(alpha,x,1), kx*exp(x), 100*eps) 
+%!assert(besselk(alpha,x,1), kx*exp(x), 100*eps)
 %!assert(besselh(alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
 %!assert(besselh(alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
 %!
 %! # Bessel functions, even order, complex x
 %!
 %! alpha = 2; x = 1.25 + 3.625 * I;
 %! jx = -1.299533366810794494030065917 + 4.370833116012278943267479589*I;
 %! yx = -4.370357232383223896393056727 - 1.283083391453582032688834041*I;
 %! ix = -0.6717801680341515541002273932 - 0.2314623443930774099910228553*I;
 %! kx = -0.01108009888623253515463783379 + 0.2245218229358191588208084197*I;
 %!
-%!assert(besselj(alpha,x), jx, 100*eps) 
+%!assert(besselj(alpha,x), jx, 100*eps)
 %!assert(bessely(alpha,x), yx, 100*eps)
 %!assert(besseli(alpha,x), ix, 100*eps)
-%!assert(besselk(alpha,x), kx, 100*eps) 
+%!assert(besselk(alpha,x), kx, 100*eps)
 %!assert(besselh(alpha,1,x), jx + I*yx, 100*eps)
 %!assert(besselh(alpha,2,x), jx - I*yx, 100*eps)
 %!
-%!assert(besselj(alpha,x,1), jx*exp(-abs(imag(x))), 100*eps) 
+%!assert(besselj(alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
 %!assert(bessely(alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
 %!assert(besseli(alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
-%!assert(besselk(alpha,x,1), kx*exp(x), 100*eps) 
+%!assert(besselk(alpha,x,1), kx*exp(x), 100*eps)
 %!assert(besselh(alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
 %!assert(besselh(alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
 %!
-%!assert(besselj(-alpha,x), jx, 100*eps) 
+%!assert(besselj(-alpha,x), jx, 100*eps)
 %!assert(bessely(-alpha,x), yx, 100*eps)
 %!assert(besseli(-alpha,x), ix, 100*eps)
-%!assert(besselk(-alpha,x), kx, 100*eps) 
+%!assert(besselk(-alpha,x), kx, 100*eps)
 %!assert(besselh(-alpha,1,x), jx + I*yx, 100*eps)
 %!assert(besselh(-alpha,2,x), jx - I*yx, 100*eps)
 %!
-%!assert(besselj(-alpha,x,1), jx*exp(-abs(imag(x))), 100*eps) 
+%!assert(besselj(-alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
 %!assert(bessely(-alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
 %!assert(besseli(-alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
-%!assert(besselk(-alpha,x,1), kx*exp(x), 100*eps) 
+%!assert(besselk(-alpha,x,1), kx*exp(x), 100*eps)
 %!assert(besselh(-alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
 %!assert(besselh(-alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
 %!
 %! # Bessel functions, odd order, complex x
 %!
 %! alpha = 3; x = 2.5 + 1.875 * I;
 %! jx = 0.1330721523048277493333458596 + 0.5386295217249660078754395597*I;
 %! yx = -0.6485072392105829901122401551 + 0.2608129289785456797046996987*I;
 %! ix = -0.6182064685486998097516365709 + 0.4677561094683470065767989920*I;
 %! kx = -0.1568585587733540007867882337 - 0.05185853709490846050505141321*I;
 %!
-%!assert(besselj(alpha,x), jx, 100*eps) 
+%!assert(besselj(alpha,x), jx, 100*eps)
 %!assert(bessely(alpha,x), yx, 100*eps)
 %!assert(besseli(alpha,x), ix, 100*eps)
-%!assert(besselk(alpha,x), kx, 100*eps) 
+%!assert(besselk(alpha,x), kx, 100*eps)
 %!assert(besselh(alpha,1,x), jx + I*yx, 100*eps)
 %!assert(besselh(alpha,2,x), jx - I*yx, 100*eps)
 %!
-%!assert(besselj(alpha,x,1), jx*exp(-abs(imag(x))), 100*eps) 
+%!assert(besselj(alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
 %!assert(bessely(alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
 %!assert(besseli(alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
-%!assert(besselk(alpha,x,1), kx*exp(x), 100*eps) 
+%!assert(besselk(alpha,x,1), kx*exp(x), 100*eps)
 %!assert(besselh(alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
 %!assert(besselh(alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
 %!
-%!assert(besselj(-alpha,x), -jx, 100*eps) 
+%!assert(besselj(-alpha,x), -jx, 100*eps)
 %!assert(bessely(-alpha,x), -yx, 100*eps)
 %!assert(besseli(-alpha,x), ix, 100*eps)
-%!assert(besselk(-alpha,x), kx, 100*eps) 
+%!assert(besselk(-alpha,x), kx, 100*eps)
 %!assert(besselh(-alpha,1,x), -(jx + I*yx), 100*eps)
 %!assert(besselh(-alpha,2,x), -(jx - I*yx), 100*eps)
 %!
-%!assert(besselj(-alpha,x,1), -jx*exp(-abs(imag(x))), 100*eps) 
+%!assert(besselj(-alpha,x,1), -jx*exp(-abs(imag(x))), 100*eps)
 %!assert(bessely(-alpha,x,1), -yx*exp(-abs(imag(x))), 100*eps)
 %!assert(besseli(-alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
-%!assert(besselk(-alpha,x,1), kx*exp(x), 100*eps) 
+%!assert(besselk(-alpha,x,1), kx*exp(x), 100*eps)
 %!assert(besselh(-alpha,1,x,1), -(jx + I*yx)*exp(-I*x), 100*eps)
 %!assert(besselh(-alpha,2,x,1), -(jx - I*yx)*exp(I*x), 100*eps)
 %!
 %! # Bessel functions, fractional order, complex x
 %!
 %! alpha = 3.5; x = 1.75 + 4.125 * I;
 %! jx = -3.018566131370455929707009100 - 0.7585648436793900607704057611*I;
 %! yx = 0.7772278839106298215614791107 - 3.018518722313849782683792010*I;
 %! ix = 0.2100873577220057189038160913 - 0.6551765604618246531254970926*I;
 %! kx = 0.1757147290513239935341488069 + 0.08772348296883849205562558311*I;
 %!
-%!assert(besselj(alpha,x), jx, 100*eps) 
+%!assert(besselj(alpha,x), jx, 100*eps)
 %!assert(bessely(alpha,x), yx, 100*eps)
 %!assert(besseli(alpha,x), ix, 100*eps)
-%!assert(besselk(alpha,x), kx, 100*eps) 
+%!assert(besselk(alpha,x), kx, 100*eps)
 %!assert(besselh(alpha,1,x), jx + I*yx, 100*eps)
 %!assert(besselh(alpha,2,x), jx - I*yx, 100*eps)
 %!
-%!assert(besselj(alpha,x,1), jx*exp(-abs(imag(x))), 100*eps) 
+%!assert(besselj(alpha,x,1), jx*exp(-abs(imag(x))), 100*eps)
 %!assert(bessely(alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
 %!assert(besseli(alpha,x,1), ix*exp(-abs(real(x))), 100*eps)
-%!assert(besselk(alpha,x,1), kx*exp(x), 100*eps) 
+%!assert(besselk(alpha,x,1), kx*exp(x), 100*eps)
 %!assert(besselh(alpha,1,x,1), (jx + I*yx)*exp(-I*x), 100*eps)
 %!assert(besselh(alpha,2,x,1), (jx - I*yx)*exp(I*x), 100*eps)
 %!
 %!  nix = 0.09822388691172060573913739253 - 0.7110230642207380127317227407*I;
 %!
-%!assert(besselj(-alpha,x), yx, 100*eps) 
+%!assert(besselj(-alpha,x), yx, 100*eps)
 %!assert(bessely(-alpha,x), -jx, 100*eps)
 %!assert(besseli(-alpha,x), nix, 100*eps)
-%!assert(besselk(-alpha,x), kx, 100*eps) 
+%!assert(besselk(-alpha,x), kx, 100*eps)
 %!assert(besselh(-alpha,1,x), -I*(jx + I*yx), 100*eps)
 %!assert(besselh(-alpha,2,x), I*(jx - I*yx), 100*eps)
 %!
-%!assert(besselj(-alpha,x,1), yx*exp(-abs(imag(x))), 100*eps) 
+%!assert(besselj(-alpha,x,1), yx*exp(-abs(imag(x))), 100*eps)
 %!assert(bessely(-alpha,x,1), -jx*exp(-abs(imag(x))), 100*eps)
 %!assert(besseli(-alpha,x,1), nix*exp(-abs(real(x))), 100*eps)
-%!assert(besselk(-alpha,x,1), kx*exp(x), 100*eps) 
+%!assert(besselk(-alpha,x,1), kx*exp(x), 100*eps)
 %!assert(besselh(-alpha,1,x,1), -I*(jx + I*yx)*exp(-I*x), 100*eps)
 %!assert(besselh(-alpha,2,x,1), I*(jx - I*yx)*exp(I*x), 100*eps)
 */
diff --git a/src/DLD-FUNCTIONS/bsxfun.cc b/src/DLD-FUNCTIONS/bsxfun.cc
--- a/src/DLD-FUNCTIONS/bsxfun.cc
+++ b/src/DLD-FUNCTIONS/bsxfun.cc
@@ -56,17 +56,17 @@ enum bsxfun_builtin_op
   bsxfun_builtin_ge,
   bsxfun_builtin_and,
   bsxfun_builtin_or,
   bsxfun_builtin_power,
   bsxfun_builtin_unknown,
   bsxfun_num_builtin_ops = bsxfun_builtin_unknown
 };
 
-const char *bsxfun_builtin_names[] = 
+const char *bsxfun_builtin_names[] =
 {
   "plus",
   "minus",
   "times",
   "rdivide",
   "max",
   "min",
   "eq",
@@ -75,41 +75,41 @@ const char *bsxfun_builtin_names[] =
   "le",
   "gt",
   "ge",
   "and",
   "or",
   "power"
 };
 
-static bsxfun_builtin_op 
+static bsxfun_builtin_op
 bsxfun_builtin_lookup (const std::string& name)
 {
   for (int i = 0; i < bsxfun_num_builtin_ops; i++)
     if (name == bsxfun_builtin_names[i])
       return static_cast<bsxfun_builtin_op> (i);
   return bsxfun_builtin_unknown;
 }
 
 typedef octave_value (*bsxfun_handler) (const octave_value&, const octave_value&);
 
 // Static table of handlers.
 bsxfun_handler bsxfun_handler_table[bsxfun_num_builtin_ops][btyp_num_types];
 
-template <class NDA, NDA (bsxfun_op) (const NDA&, const NDA&)> 
-static octave_value 
+template <class NDA, NDA (bsxfun_op) (const NDA&, const NDA&)>
+static octave_value
 bsxfun_forward_op (const octave_value& x, const octave_value& y)
 {
   NDA xa = octave_value_extract<NDA> (x);
   NDA ya = octave_value_extract<NDA> (y);
   return octave_value (bsxfun_op (xa, ya));
 }
 
-template <class NDA, boolNDArray (bsxfun_rel) (const NDA&, const NDA&)> 
-static octave_value 
+template <class NDA, boolNDArray (bsxfun_rel) (const NDA&, const NDA&)>
+static octave_value
 bsxfun_forward_rel (const octave_value& x, const octave_value& y)
 {
   NDA xa = octave_value_extract<NDA> (x);
   NDA ya = octave_value_extract<NDA> (y);
   return octave_value (bsxfun_rel (xa, ya));
 }
 
 // Pow needs a special handler for reals because of the potentially complex result.
@@ -162,19 +162,19 @@ static void maybe_fill_table (void)
   REGISTER_STD_HANDLERS (btyp_uint32, uint32NDArray);
   REGISTER_STD_HANDLERS (btyp_uint64, uint64NDArray);
 
   // For bools, we register and/or.
   REGISTER_OP_HANDLER (bsxfun_builtin_and, btyp_bool, boolNDArray, bsxfun_and);
   REGISTER_OP_HANDLER (bsxfun_builtin_or, btyp_bool, boolNDArray, bsxfun_or);
 
   // Register power handlers.
-  bsxfun_handler_table[bsxfun_builtin_power][btyp_double] = 
+  bsxfun_handler_table[bsxfun_builtin_power][btyp_double] =
     do_bsxfun_real_pow<NDArray, ComplexNDArray>;
-  bsxfun_handler_table[bsxfun_builtin_power][btyp_float] = 
+  bsxfun_handler_table[bsxfun_builtin_power][btyp_float] =
     do_bsxfun_real_pow<FloatNDArray, FloatComplexNDArray>;
 
   REGISTER_OP_HANDLER (bsxfun_builtin_power, btyp_complex, ComplexNDArray, bsxfun_pow);
   REGISTER_OP_HANDLER (bsxfun_builtin_power, btyp_float_complex, FloatComplexNDArray, bsxfun_pow);
 
   // For chars, we want just relational handlers.
   REGISTER_REL_HANDLER (bsxfun_builtin_eq, btyp_char, charNDArray, bsxfun_eq);
   REGISTER_REL_HANDLER (bsxfun_builtin_ne, btyp_char, charNDArray, bsxfun_ne);
@@ -216,17 +216,17 @@ maybe_optimized_builtin (const std::stri
             retval = handler (a, b);
         }
     }
 
   return retval;
 }
 
 static bool
-maybe_update_column (octave_value& Ac, const octave_value& A, 
+maybe_update_column (octave_value& Ac, const octave_value& A,
                      const dim_vector& dva, const dim_vector& dvc,
                      octave_idx_type i, octave_value_list &idx)
 {
   octave_idx_type nd = dva.length ();
 
   if (i == 0)
     {
       idx(0) = octave_value (':');
@@ -340,17 +340,17 @@ dimensionality as the other matrix.\n\
             error ("bsxfun: invalid function name: %s", name.c_str ());
         }
       else if (! (args(0).is_function_handle () || args(0).is_inline_function ()))
         error ("bsxfun: F must be a string or function handle");
 
       const octave_value A = args (1);
       const octave_value B = args (2);
 
-      if (func.is_builtin_function () 
+      if (func.is_builtin_function ()
           || (func.is_function_handle () && ! A.is_object () && ! B.is_object ()))
         {
           // This may break if the default behavior is overriden. But if you override
           // arithmetic operators for builtin classes, you should expect mayhem
           // anyway (constant folding etc). Querying is_overloaded may not be
           // exactly what we need here.
           octave_function *fcn_val = func.function_value ();
           if (fcn_val)
@@ -363,17 +363,17 @@ dimensionality as the other matrix.\n\
 
       if (! error_state && retval.empty ())
         {
           dim_vector dva = A.dims ();
           octave_idx_type nda = dva.length ();
           dim_vector dvb = B.dims ();
           octave_idx_type ndb = dvb.length ();
           octave_idx_type nd = nda;
-      
+
           if (nda > ndb)
               dvb.resize (nda, 1);
           else if (nda < ndb)
             {
               dva.resize (ndb, 1);
               nd = ndb;
             }
 
@@ -384,34 +384,34 @@ dimensionality as the other matrix.\n\
                 break;
               }
 
           if (!error_state)
             {
               // Find the size of the output
               dim_vector dvc;
               dvc.resize (nd);
-          
+
               for (octave_idx_type i = 0; i < nd; i++)
                 dvc (i) = (dva (i) < 1  ? dva (i) : (dvb (i) < 1 ? dvb (i) :
                       (dva (i) > dvb (i) ? dva (i) : dvb (i))));
 
               if (dva == dvb || dva.numel () == 1 || dvb.numel () == 1)
                 {
                   octave_value_list inputs;
                   inputs (0) = A;
                   inputs (1) = B;
-                  retval = func.do_multi_index_op (1, inputs);  
+                  retval = func.do_multi_index_op (1, inputs);
                 }
               else if (dvc.numel () < 1)
                 {
                   octave_value_list inputs;
                   inputs (0) = A.resize (dvc);
                   inputs (1) = B.resize (dvc);
-                  retval = func.do_multi_index_op (1, inputs);  
+                  retval = func.do_multi_index_op (1, inputs);
                 }
               else
                 {
                   octave_idx_type ncount = 1;
                   for (octave_idx_type i = 1; i < nd; i++)
                     ncount *= dvc (i);
 
 #define BSXDEF(T) \
@@ -443,18 +443,18 @@ dimensionality as the other matrix.\n\
 
                   for (octave_idx_type i = 0; i < ncount; i++)
                     {
                       if (maybe_update_column (Ac, A, dva, dvc, i, idxA))
                         inputs (0) = Ac;
 
                       if (maybe_update_column (Bc, B, dvb, dvc, i, idxB))
                         inputs (1) = Bc;
-                        
-                      octave_value_list tmp = func.do_multi_index_op (1, inputs);  
+
+                      octave_value_list tmp = func.do_multi_index_op (1, inputs);
 
                       if (error_state)
                         break;
 
 #define BSXINIT(T, CLS, EXTRACTOR) \
                       (result_type == CLS) \
                         { \
                             have_ ## T = true; \
@@ -474,33 +474,33 @@ dimensionality as the other matrix.\n\
                                     {
                                       have_NDArray = true;
                                       result_NDArray = tmp(0).array_value ();
                                       result_NDArray.resize (dvc);
                                     }
                                   else
                                     {
                                       have_ComplexNDArray = true;
-                                      result_ComplexNDArray = 
+                                      result_ComplexNDArray =
                                         tmp(0).complex_array_value ();
                                       result_ComplexNDArray.resize (dvc);
                                     }
                                 }
                               else if (result_type == "single")
                                 {
                                   if (tmp(0).is_real_type ())
                                     {
                                       have_FloatNDArray = true;
                                       result_FloatNDArray = tmp(0).float_array_value ();
                                       result_FloatNDArray.resize (dvc);
                                     }
                                   else
                                     {
                                       have_ComplexNDArray = true;
-                                      result_ComplexNDArray = 
+                                      result_ComplexNDArray =
                                         tmp(0).complex_array_value ();
                                       result_ComplexNDArray.resize (dvc);
                                     }
                                 }
                               else if BSXINIT(boolNDArray, "logical", bool)
                               else if BSXINIT(int8NDArray, "int8", int8)
                               else if BSXINIT(int16NDArray, "int16", int16)
                               else if BSXINIT(int32NDArray, "int32", int32)
@@ -514,17 +514,17 @@ dimensionality as the other matrix.\n\
                                   C = tmp (0);
                                   C = C.resize (dvc);
                                 }
                             }
                         }
                       else
                         {
                           update_index (ra_idx, dvc, i);
-                          
+
                           if (have_FloatNDArray ||
                               have_FloatComplexNDArray)
                             {
                               if (! tmp(0).is_float_type ())
                                 {
                                   if (have_FloatNDArray)
                                     {
                                       have_FloatNDArray = false;
@@ -534,65 +534,65 @@ dimensionality as the other matrix.\n\
                                     {
                                       have_FloatComplexNDArray = false;
                                       C = result_FloatComplexNDArray;
                                     }
                                   C = do_cat_op (C, tmp(0), ra_idx);
                                 }
                               else if (tmp(0).is_double_type ())
                                 {
-                                  if (tmp(0).is_complex_type () && 
+                                  if (tmp(0).is_complex_type () &&
                                       have_FloatNDArray)
                                     {
-                                      result_ComplexNDArray = 
+                                      result_ComplexNDArray =
                                         ComplexNDArray (result_FloatNDArray);
-                                      result_ComplexNDArray.insert 
+                                      result_ComplexNDArray.insert
                                         (tmp(0).complex_array_value(), ra_idx);
                                       have_FloatComplexNDArray = false;
                                       have_ComplexNDArray = true;
                                     }
                                   else
                                     {
-                                      result_NDArray = 
+                                      result_NDArray =
                                         NDArray (result_FloatNDArray);
-                                      result_NDArray.insert 
+                                      result_NDArray.insert
                                         (tmp(0).array_value(), ra_idx);
                                       have_FloatNDArray = false;
                                       have_NDArray = true;
                                     }
                                 }
                               else if (tmp(0).is_real_type ())
-                                result_FloatNDArray.insert 
+                                result_FloatNDArray.insert
                                   (tmp(0).float_array_value(), ra_idx);
                               else
                                 {
-                                  result_FloatComplexNDArray = 
+                                  result_FloatComplexNDArray =
                                     FloatComplexNDArray (result_FloatNDArray);
-                                  result_FloatComplexNDArray.insert 
+                                  result_FloatComplexNDArray.insert
                                     (tmp(0).float_complex_array_value(), ra_idx);
                                   have_FloatNDArray = false;
                                   have_FloatComplexNDArray = true;
                                 }
                             }
                           else if (have_NDArray)
                             {
                               if (! tmp(0).is_float_type ())
                                 {
                                   have_NDArray = false;
                                   C = result_NDArray;
                                   C = do_cat_op (C, tmp(0), ra_idx);
                                 }
                               else if (tmp(0).is_real_type ())
-                                result_NDArray.insert (tmp(0).array_value(), 
+                                result_NDArray.insert (tmp(0).array_value(),
                                                        ra_idx);
                               else
                                 {
-                                  result_ComplexNDArray = 
+                                  result_ComplexNDArray =
                                     ComplexNDArray (result_NDArray);
-                                  result_ComplexNDArray.insert 
+                                  result_ComplexNDArray.insert
                                     (tmp(0).complex_array_value(), ra_idx);
                                   have_NDArray = false;
                                   have_ComplexNDArray = true;
                                 }
                             }
 
 #define BSXLOOP(T, CLS, EXTRACTOR) \
                         (have_ ## T) \
@@ -641,17 +641,17 @@ dimensionality as the other matrix.\n\
                   else if BSXEND(uint16NDArray)
                   else if BSXEND(uint32NDArray)
                   else if BSXEND(uint64NDArray)
                   else
                     retval(0) = C;
                 }
             }
         }
-    }   
+    }
 
   return retval;
 }
 
 /*
 
 %!shared a, b, c, f
 %! a = randn (4, 4);
diff --git a/src/DLD-FUNCTIONS/ccolamd.cc b/src/DLD-FUNCTIONS/ccolamd.cc
--- a/src/DLD-FUNCTIONS/ccolamd.cc
+++ b/src/DLD-FUNCTIONS/ccolamd.cc
@@ -143,83 +143,83 @@ colamd, symamd, and other related orderi
 @end deftypefn")
 {
   octave_value_list retval;
 
 #ifdef HAVE_CCOLAMD
 
   int nargin = args.length ();
   int spumoni = 0;
- 
+
   if (nargout > 2 || nargin < 1 || nargin > 3)
     usage ("ccolamd: incorrect number of input and/or output arguments");
   else
     {
       // Get knobs
-      OCTAVE_LOCAL_BUFFER (double, knobs, CCOLAMD_KNOBS);      
+      OCTAVE_LOCAL_BUFFER (double, knobs, CCOLAMD_KNOBS);
       CCOLAMD_NAME (_set_defaults) (knobs);
 
       // Check for user-passed knobs
       if (nargin > 1)
         {
           NDArray User_knobs = args(1).array_value ();
           int nel_User_knobs = User_knobs.length ();
 
-          if (nel_User_knobs > 0) 
+          if (nel_User_knobs > 0)
             knobs [CCOLAMD_LU] = (User_knobs (0) != 0);
-          if (nel_User_knobs > 1) 
+          if (nel_User_knobs > 1)
             knobs [CCOLAMD_DENSE_ROW]  = User_knobs (1);
-          if (nel_User_knobs > 2) 
+          if (nel_User_knobs > 2)
             knobs [CCOLAMD_DENSE_COL]  = User_knobs (2);
-          if (nel_User_knobs > 3) 
+          if (nel_User_knobs > 3)
             knobs [CCOLAMD_AGGRESSIVE] = (User_knobs (3) != 0);
-          if (nel_User_knobs > 4) 
+          if (nel_User_knobs > 4)
             spumoni = (User_knobs (4) != 0);
 
           // print knob settings if spumoni is set
           if (spumoni)
             {
               octave_stdout << "\nccolamd version " << CCOLAMD_MAIN_VERSION << "."
-                            <<  CCOLAMD_SUB_VERSION << ", " << CCOLAMD_DATE 
+                            <<  CCOLAMD_SUB_VERSION << ", " << CCOLAMD_DATE
                             << ":\nknobs(1): " << User_knobs (0) << ", order for ";
               if ( knobs [CCOLAMD_LU] != 0)
                 octave_stdout << "lu(A)\n";
               else
                 octave_stdout << "chol(A'*A)\n";
 
               if (knobs [CCOLAMD_DENSE_ROW] >= 0)
-                octave_stdout << "knobs(2): " << User_knobs (1) 
+                octave_stdout << "knobs(2): " << User_knobs (1)
                               << ", rows with > max(16,"
                               << knobs [CCOLAMD_DENSE_ROW] << "*sqrt(size(A,2)))"
                               << " entries removed\n";
               else
                 octave_stdout << "knobs(2): " << User_knobs (1)
                               << ", no dense rows removed\n";
 
               if (knobs [CCOLAMD_DENSE_COL] >= 0)
-                octave_stdout << "knobs(3): " << User_knobs (2) 
+                octave_stdout << "knobs(3): " << User_knobs (2)
                               << ", cols with > max(16,"
                               << knobs [CCOLAMD_DENSE_COL] << "*sqrt(size(A)))"
                               << " entries removed\n";
               else
                 octave_stdout << "knobs(3): " << User_knobs (2)
                               << ", no dense columns removed\n";
 
               if (knobs [CCOLAMD_AGGRESSIVE] != 0)
-                octave_stdout << "knobs(4): " << User_knobs(3) 
+                octave_stdout << "knobs(4): " << User_knobs(3)
                               << ", aggressive absorption: yes";
               else
-                octave_stdout << "knobs(4): " << User_knobs(3) 
+                octave_stdout << "knobs(4): " << User_knobs(3)
                               << ", aggressive absorption: no";
- 
-              octave_stdout << "knobs(5): " << User_knobs (4) 
+
+              octave_stdout << "knobs(5): " << User_knobs (4)
                             << ", statistics and knobs printed\n";
             }
         }
-      
+
       octave_idx_type n_row, n_col, nnz;
       octave_idx_type *ridx, *cidx;
       SparseComplexMatrix scm;
       SparseMatrix sm;
 
       if (args(0).is_sparse_type ())
         {
           if (args(0).is_complex_type ())
@@ -271,17 +271,17 @@ colamd, symamd, and other related orderi
       if (nargin > 2)
         {
           NDArray in_cmember = args(2).array_value();
           octave_idx_type cslen = in_cmember.length();
           OCTAVE_LOCAL_BUFFER (octave_idx_type, cmember, cslen);
           for (octave_idx_type i = 0; i < cslen; i++)
             // convert cmember from 1-based to 0-based
             cmember[i] = static_cast<octave_idx_type>(in_cmember(i) - 1);
-          
+
           if (cslen != n_col)
             error ("ccolamd: CMEMBER must be of length equal to #cols of A");
           else
             // Order the columns (destroys A)
             if (! CCOLAMD_NAME () (n_row, n_col, Alen, A, p, knobs, stats, cmember))
               {
                 CCOLAMD_NAME (_report) (stats) ;
                 error ("ccolamd: internal error!");
@@ -313,21 +313,21 @@ colamd, symamd, and other related orderi
       // Return the stats vector
       if (nargout == 2)
         {
           NDArray out_stats (dim_vector (1, CCOLAMD_STATS));
           for (octave_idx_type i = 0 ; i < CCOLAMD_STATS ; i++)
             out_stats (i) = stats [i] ;
           retval(1) = out_stats;
 
-          // fix stats (5) and (6), for 1-based information on 
-          // jumbled matrix.  note that this correction doesn't 
+          // fix stats (5) and (6), for 1-based information on
+          // jumbled matrix.  note that this correction doesn't
           // occur if symamd returns FALSE
-          out_stats (CCOLAMD_INFO1) ++ ; 
-          out_stats (CCOLAMD_INFO2) ++ ; 
+          out_stats (CCOLAMD_INFO1) ++ ;
+          out_stats (CCOLAMD_INFO2) ++ ;
         }
     }
 
 #else
 
   error ("ccolamd: not available in this version of Octave");
 
 #endif
@@ -398,66 +398,66 @@ colamd, symamd, and other related orderi
 @end deftypefn")
 {
   octave_value_list retval;
 
 #if HAVE_CCOLAMD
 
   int nargin = args.length ();
   int spumoni = 0;
- 
+
   if (nargout > 2 || nargin < 1 || nargin > 3)
     usage ("ccolamd: incorrect number of input and/or output arguments");
   else
     {
       // Get knobs
       OCTAVE_LOCAL_BUFFER (double, knobs, CCOLAMD_KNOBS);
       CCOLAMD_NAME (_set_defaults) (knobs);
 
       // Check for user-passed knobs
       if (nargin > 1)
         {
           NDArray User_knobs = args(1).array_value ();
           int nel_User_knobs = User_knobs.length ();
-          
-          if (nel_User_knobs > 0) 
+
+          if (nel_User_knobs > 0)
             knobs [CCOLAMD_DENSE_ROW] = User_knobs (0);
-          if (nel_User_knobs > 0) 
+          if (nel_User_knobs > 0)
             knobs [CCOLAMD_AGGRESSIVE] = User_knobs (1);
-          if (nel_User_knobs > 1) 
+          if (nel_User_knobs > 1)
             spumoni = static_cast<int> (User_knobs (2));
 
           // print knob settings if spumoni is set
           if (spumoni)
             {
               octave_stdout << "\ncsymamd version " << CCOLAMD_MAIN_VERSION << "."
                             <<  CCOLAMD_SUB_VERSION << ", " << CCOLAMD_DATE << "\n";
 
               if (knobs [CCOLAMD_DENSE_ROW] >= 0)
-                octave_stdout << "knobs(1): " << User_knobs (0) 
+                octave_stdout << "knobs(1): " << User_knobs (0)
                               << ", rows/cols with > max(16,"
                               << knobs [CCOLAMD_DENSE_ROW] << "*sqrt(size(A,2)))"
                               << " entries removed\n";
               else
                 octave_stdout << "knobs(1): " << User_knobs (0)
                               << ", no dense rows/cols removed\n";
 
               if (knobs [CCOLAMD_AGGRESSIVE] != 0)
-                octave_stdout << "knobs(2): " << User_knobs(1) 
+                octave_stdout << "knobs(2): " << User_knobs(1)
                               << ", aggressive absorption: yes";
               else
-                octave_stdout << "knobs(2): " << User_knobs(1) 
+                octave_stdout << "knobs(2): " << User_knobs(1)
                               << ", aggressive absorption: no";
- 
+
 
-              octave_stdout << "knobs(3): " << User_knobs (2) 
+              octave_stdout << "knobs(3): " << User_knobs (2)
                             << ", statistics and knobs printed\n";
             }
         }
-      
+
       octave_idx_type n_row, n_col, nnz;
       octave_idx_type *ridx, *cidx;
       SparseMatrix sm;
       SparseComplexMatrix scm;
 
       if (args(0).is_sparse_type ())
         {
           if (args(0).is_complex_type ())
@@ -480,17 +480,17 @@ colamd, symamd, and other related orderi
             }
         }
       else
         {
           if (args(0).is_complex_type ())
             sm = SparseMatrix (real (args(0).complex_matrix_value ()));
           else
             sm = SparseMatrix (args(0).matrix_value ());
-          
+
           n_row = sm.rows ();
           n_col = sm.cols ();
           nnz = sm.nnz ();
           ridx = sm.xridx ();
           cidx = sm.xcidx ();
         }
 
       if (n_row != n_col)
@@ -506,31 +506,31 @@ colamd, symamd, and other related orderi
       if (nargin > 2)
         {
           NDArray in_cmember = args(2).array_value();
           octave_idx_type cslen = in_cmember.length();
           OCTAVE_LOCAL_BUFFER (octave_idx_type, cmember, cslen);
           for (octave_idx_type i = 0; i < cslen; i++)
             // convert cmember from 1-based to 0-based
             cmember[i] = static_cast<octave_idx_type>(in_cmember(i) - 1);
-          
+
           if (cslen != n_col)
             error ("csymamd: CMEMBER must be of length equal to #cols of A");
           else
-            if (!CSYMAMD_NAME () (n_col, ridx, cidx, perm, knobs, stats, 
+            if (!CSYMAMD_NAME () (n_col, ridx, cidx, perm, knobs, stats,
                                   &calloc, &free, cmember, -1))
               {
                 CSYMAMD_NAME (_report) (stats) ;
                 error ("csymamd: internal error!") ;
                 return retval;
               }
         }
       else
         {
-          if (!CSYMAMD_NAME () (n_col, ridx, cidx, perm, knobs, stats, 
+          if (!CSYMAMD_NAME () (n_col, ridx, cidx, perm, knobs, stats,
                                 &calloc, &free, 0, -1))
             {
               CSYMAMD_NAME (_report) (stats) ;
               error ("csymamd: internal error!") ;
               return retval;
             }
         }
 
@@ -544,40 +544,40 @@ colamd, symamd, and other related orderi
       // Return the stats vector
       if (nargout == 2)
         {
           NDArray out_stats (dim_vector (1, CCOLAMD_STATS));
           for (octave_idx_type i = 0 ; i < CCOLAMD_STATS ; i++)
             out_stats (i) = stats [i] ;
           retval(1) = out_stats;
 
-          // fix stats (5) and (6), for 1-based information on 
-          // jumbled matrix.  note that this correction doesn't 
+          // fix stats (5) and (6), for 1-based information on
+          // jumbled matrix.  note that this correction doesn't
           // occur if symamd returns FALSE
-          out_stats (CCOLAMD_INFO1) ++ ; 
-          out_stats (CCOLAMD_INFO2) ++ ; 
+          out_stats (CCOLAMD_INFO1) ++ ;
+          out_stats (CCOLAMD_INFO2) ++ ;
         }
 
       // print stats if spumoni > 0
       if (spumoni > 0)
         CSYMAMD_NAME (_report) (stats) ;
 
       // Return the stats vector
       if (nargout == 2)
         {
           NDArray out_stats (dim_vector (1, CCOLAMD_STATS));
           for (octave_idx_type i = 0 ; i < CCOLAMD_STATS ; i++)
             out_stats (i) = stats [i] ;
           retval(1) = out_stats;
 
-          // fix stats (5) and (6), for 1-based information on 
-          // jumbled matrix.  note that this correction doesn't 
+          // fix stats (5) and (6), for 1-based information on
+          // jumbled matrix.  note that this correction doesn't
           // occur if symamd returns FALSE
-          out_stats (CCOLAMD_INFO1) ++ ; 
-          out_stats (CCOLAMD_INFO2) ++ ; 
+          out_stats (CCOLAMD_INFO1) ++ ;
+          out_stats (CCOLAMD_INFO2) ++ ;
         }
     }
 
 #else
 
   error ("csymamd: not available in this version of Octave");
 
 #endif
diff --git a/src/DLD-FUNCTIONS/cellfun.cc b/src/DLD-FUNCTIONS/cellfun.cc
--- a/src/DLD-FUNCTIONS/cellfun.cc
+++ b/src/DLD-FUNCTIONS/cellfun.cc
@@ -53,17 +53,17 @@ along with Octave; see the file COPYING.
 #include "ov-int16.h"
 #include "ov-int32.h"
 #include "ov-int64.h"
 #include "ov-uint8.h"
 #include "ov-uint16.h"
 #include "ov-uint32.h"
 #include "ov-uint64.h"
 
-static octave_value_list 
+static octave_value_list
 get_output_list (octave_idx_type count, octave_idx_type nargout,
                  const octave_value_list& inputlist,
                  octave_value& func,
                  octave_value& error_handler)
 {
   octave_value_list tmp = func.do_multi_index_op (nargout, inputlist);
 
   if (error_state)
@@ -222,27 +222,27 @@ cellfun (@@factorial, @{-1,2@},'ErrorHan
   octave_value func = args(0);
 
   if (! args(1).is_cell ())
     {
       error ("cellfun: C must be a cell array");
 
       return retval;
     }
-  
+
   if (func.is_string ())
     {
       const Cell f_args = args(1).cell_value ();
 
       octave_idx_type k = f_args.numel ();
 
       std::string name = func.string_value ();
 
       if (name == "isempty")
-        {      
+        {
           boolNDArray result (f_args.dims ());
           for (octave_idx_type count = 0; count < k ; count++)
             result(count) = f_args.elem(count).is_empty ();
           retval(0) = result;
         }
       else if (name == "islogical")
         {
           boolNDArray result (f_args.dims ());
@@ -322,17 +322,17 @@ cellfun (@@factorial, @{-1,2@},'ErrorHan
         {
           if (! valid_identifier (name))
             {
 
               std::string fcn_name = unique_symbol_name ("__cellfun_fcn_");
               std::string fname = "function y = ";
               fname.append (fcn_name);
               fname.append ("(x) y = ");
-              octave_function *ptr_func = extract_function (args(0), "cellfun", 
+              octave_function *ptr_func = extract_function (args(0), "cellfun",
                                                             fcn_name, fname, "; endfunction");
               if (ptr_func && ! error_state)
                 func = octave_value (ptr_func, true);
             }
           else
             {
               func = symbol_table::find_function (name);
               if (func.is_undefined ())
@@ -352,24 +352,24 @@ cellfun (@@factorial, @{-1,2@},'ErrorHan
 
       bool uniform_output = true;
       octave_value error_handler;
 
       while (nargin > 3 && args(nargin-2).is_string())
         {
           std::string arg = args(nargin-2).string_value();
 
-          std::transform (arg.begin (), arg.end (), 
+          std::transform (arg.begin (), arg.end (),
                           arg.begin (), tolower);
 
           if (arg == "uniformoutput")
             uniform_output = args(nargin-1).bool_value();
           else if (arg == "errorhandler")
             {
-              if (args(nargin-1).is_function_handle () || 
+              if (args(nargin-1).is_function_handle () ||
                   args(nargin-1).is_inline_function ())
                 {
                   error_handler = args(nargin-1);
                 }
               else if (args(nargin-1).is_string ())
                 {
                   std::string err_name = args(nargin-1).string_value ();
                   error_handler = symbol_table::find_function (err_name);
@@ -382,17 +382,17 @@ cellfun (@@factorial, @{-1,2@},'ErrorHan
               else
                 {
                   error ("cellfun: invalid value for 'ErrorHandler' function");
                   break;
                 }
             }
           else
             {
-              error ("cellfun: unrecognized parameter %s", 
+              error ("cellfun: unrecognized parameter %s",
                      arg.c_str());
               break;
             }
 
           nargin -= 2;
         }
 
       nargin -= 1;
@@ -973,17 +973,17 @@ num2cell([1,2;3,4],1)\n\
           [1,2] =\n\
              2\n\
              4\n\
         @}\n\
 @end group\n\
 @end example\n\
 \n\
 @seealso{mat2cell}\n\
-@end deftypefn") 
+@end deftypefn")
 {
   int nargin =  args.length();
   octave_value retval;
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   else
     {
@@ -1048,17 +1048,17 @@ num2cell([1,2;3,4],1)\n\
 /*
 
 %!assert(num2cell([1,2;3,4]),{1,2;3,4})
 %!assert(num2cell([1,2;3,4],1),{[1;3],[2;4]})
 %!assert(num2cell([1,2;3,4],2),{[1,2];[3,4]})
 
 */
 
-static bool 
+static bool
 mat2cell_mismatch (const dim_vector& dv,
                    const Array<octave_idx_type> *d, int nd)
 {
   for (int i = 0; i < nd; i++)
     {
       octave_idx_type s = 0;
       for (octave_idx_type j = 0; j < d[i].length (); j++)
         s += d[i](j);
@@ -1072,17 +1072,17 @@ mat2cell_mismatch (const dim_vector& dv,
           return true;
         }
     }
 
   return false;
 }
 
 template<class container>
-static void 
+static void
 prepare_idx (container *idx, int idim, int nd,
              const Array<octave_idx_type>* d)
 {
   octave_idx_type nidx = idim < nd ? d[idim].numel () : 1;
   if (nidx == 1)
     idx[0] = idx_vector::colon;
   else
     {
@@ -1247,17 +1247,17 @@ do_mat2cell (octave_value& a, const Arra
   for (int i = 0; i < nd; i++)
     {
       idx[i] = xidx + idxtot;
       prepare_idx (idx[i], i, nd, d);
       idxtot += nidx[i];
     }
 
   OCTAVE_LOCAL_BUFFER_INIT (octave_idx_type, ridx, nd, 0);
-  octave_value_list ra_idx (std::max (nd, a.ndims ()), 
+  octave_value_list ra_idx (std::max (nd, a.ndims ()),
                             octave_value::magic_colon_t);
 
   for (octave_idx_type j = 0; j < retval.numel (); j++)
     {
       octave_quit ();
 
       for (int i = 0; i < nd; i++)
         ra_idx(i) = idx[i][ridx[i]];
@@ -1404,26 +1404,26 @@ mat2cell (reshape(1:16,4,4),[3,1],[3,1])
 %! c = mat2cell(x,1,[0,4,2,0,4,0]);
 %! empty1by0str = resize('',1,0);
 %! assert(c,{empty1by0str,'abcd','ef',empty1by0str,'ghij',empty1by0str})
 
 */
 
 // FIXME: it would be nice to allow ranges being handled without a conversion.
 template <class NDA>
-static Cell 
-do_cellslices_nda (const NDA& array, 
-                   const Array<octave_idx_type>& lb, 
+static Cell
+do_cellslices_nda (const NDA& array,
+                   const Array<octave_idx_type>& lb,
                    const Array<octave_idx_type>& ub,
                    int dim = -1)
 {
   octave_idx_type n = lb.length ();
   Cell retval (1, n);
-  if (array.is_vector () && (dim == -1 
-                             || (dim == 0 && array.columns () == 1) 
+  if (array.is_vector () && (dim == -1
+                             || (dim == 0 && array.columns () == 1)
                              || (dim == 1 && array.rows () == 1)))
     {
       for (octave_idx_type i = 0; i < n && ! error_state; i++)
         retval(i) = array.index (idx_vector (lb(i) - 1, ub(i)));
     }
   else
     {
       const dim_vector dv = array.dims ();
diff --git a/src/DLD-FUNCTIONS/chol.cc b/src/DLD-FUNCTIONS/chol.cc
--- a/src/DLD-FUNCTIONS/chol.cc
+++ b/src/DLD-FUNCTIONS/chol.cc
@@ -43,25 +43,25 @@ along with Octave; see the file COPYING.
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 template <class CHOLT>
 static octave_value
 get_chol_r (const CHOLT& fact)
 {
-  return octave_value (fact.chol_matrix (), 
+  return octave_value (fact.chol_matrix (),
                        MatrixType (MatrixType::Upper));
 }
 
 template <class CHOLT>
 static octave_value
 get_chol_l (const CHOLT& fact)
 {
-  return octave_value (fact.chol_matrix ().transpose (), 
+  return octave_value (fact.chol_matrix ().transpose (),
                        MatrixType (MatrixType::Lower));
 }
 
 DEFUN_DLD (chol, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{R} =} chol (@var{A})\n\
 @deftypefnx {Loadable Function} {[@var{R}, @var{p}] =} chol (@var{A})\n\
 @deftypefnx {Loadable Function} {[@var{R}, @var{p}, @var{Q}] =} chol (@var{S})\n\
@@ -133,17 +133,17 @@ sparse matrices.\n\
 @seealso{cholinv, chol2inv}\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
   bool LLt = false;
   bool vecout = false;
 
-  if (nargin < 1 || nargin > 3 || nargout > 3 
+  if (nargin < 1 || nargin > 3 || nargout > 3
       || (! args(0).is_sparse_type () && nargout > 2))
     {
       print_usage ();
       return retval;
     }
 
   int n = 1;
   while (n < nargin && ! error_state)
@@ -163,17 +163,17 @@ sparse matrices.\n\
         }
       else
         error ("chol: expecting trailing string arguments");
     }
 
   if (! error_state)
     {
       octave_value arg = args(0);
-    
+
       octave_idx_type nr = arg.rows ();
       octave_idx_type nc = arg.columns ();
       bool natural = (nargout != 3);
 
       int arg_is_empty = empty_arg ("chol", nr, nc);
 
       if (arg_is_empty < 0)
         return retval;
@@ -221,17 +221,17 @@ sparse matrices.\n\
 
                   if (nargout == 3)
                     {
                       if (vecout)
                         retval(2) = fact.perm ();
                       else
                         retval(2) = fact.Q();
                     }
-          
+
                   if (nargout > 1 || info == 0)
                     {
                       retval(1) = fact.P();
                       if (LLt)
                         retval(0) = fact.L();
                       else
                         retval(0) = fact.R();
                     }
@@ -359,17 +359,17 @@ symmetric positive definite matrix @var{
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       octave_value arg = args(0);
-    
+
       octave_idx_type nr = arg.rows ();
       octave_idx_type nc = arg.columns ();
 
       if (nr == 0 || nc == 0)
         retval = Matrix ();
       else
         {
           if (arg.is_sparse_type ())
@@ -512,17 +512,17 @@ using @code{inv}.\n\
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       octave_value arg = args(0);
-    
+
       octave_idx_type nr = arg.rows ();
       octave_idx_type nc = arg.columns ();
 
       if (nr == 0 || nc == 0)
         retval = Matrix ();
       else
         {
           if (arg.is_sparse_type ())
@@ -736,82 +736,82 @@ If @var{info} is not present, an error m
 }
 
 /*
 %!shared A, u, Ac, uc
 %! A = [  0.436997  -0.131721   0.124120  -0.061673 ;
 %!       -0.131721   0.738529   0.019851  -0.140295 ;
 %!        0.124120   0.019851   0.354879  -0.059472 ;
 %!       -0.061673  -0.140295  -0.059472   0.600939 ];
-%! 
+%!
 %! u = [  0.98950 ;
 %!        0.39844 ;
 %!        0.63484 ;
 %!        0.13351 ];
 %! Ac = [  0.5585528 + 0.0000000i  -0.1662088 - 0.0315341i   0.0107873 + 0.0236411i  -0.0276775 - 0.0186073i ;
 %!        -0.1662088 + 0.0315341i   0.6760061 + 0.0000000i   0.0011452 - 0.0475528i   0.0145967 + 0.0247641i ;
 %!         0.0107873 - 0.0236411i   0.0011452 + 0.0475528i   0.6263149 - 0.0000000i  -0.1585837 - 0.0719763i ;
 %!        -0.0276775 + 0.0186073i   0.0145967 - 0.0247641i  -0.1585837 + 0.0719763i   0.6034234 - 0.0000000i ];
-%! 
+%!
 %! uc = [ 0.54267 + 0.91519i ;
 %!        0.99647 + 0.43141i ;
 %!        0.83760 + 0.68977i ;
 %!        0.39160 + 0.90378i ];
 
 
 
 %!test
 %! R = chol(A);
-%! 
+%!
 %! R1 = cholupdate(R,u);
-%! 
+%!
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(R1'*R1 - R'*R - u*u',Inf) < 1e1*eps)
-%! 
+%!
 %! R1 = cholupdate(R1,u,"-");
-%! 
+%!
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(R1 - R,Inf) < 1e1*eps)
-%! 
+%!
 %!test
 %! R = chol(Ac);
-%! 
+%!
 %! R1 = cholupdate(R,uc);
-%! 
+%!
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(R1'*R1 - R'*R - uc*uc',Inf) < 1e1*eps)
-%! 
+%!
 %! R1 = cholupdate(R1,uc,"-");
-%! 
+%!
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(R1 - R,Inf) < 1e1*eps)
 
 %!test
 %! R = chol(single(A));
-%! 
+%!
 %! R1 = cholupdate(R,single(u));
-%! 
+%!
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(R1'*R1 - R'*R - single(u*u'),Inf) < 1e1*eps('single'))
-%! 
+%!
 %! R1 = cholupdate(R1,single(u),"-");
-%! 
+%!
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(R1 - R,Inf) < 2e1*eps('single'))
-%! 
+%!
 %!test
 %! R = chol(single(Ac));
-%! 
+%!
 %! R1 = cholupdate(R,single(uc));
-%! 
+%!
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(R1'*R1 - R'*R - single(uc*uc'),Inf) < 1e1*eps('single'))
-%! 
+%!
 %! R1 = cholupdate(R1,single(uc),"-");
-%! 
+%!
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(R1 - R,Inf) < 2e1*eps('single'))
 */
 
 DEFUN_DLD (cholinsert, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{R1} =} cholinsert (@var{R}, @var{j}, @var{u})\n\
 @deftypefnx {Loadable Function} {[@var{R1}, @var{info}] =} cholinsert (@var{R}, @var{j}, @var{u})\n\
@@ -938,69 +938,69 @@ If @var{info} is not present, an error m
 %!test
 %! u2 = [  0.35080 ;
 %!         0.63930 ;
 %!         3.31057 ;
 %!        -0.13825 ;
 %!         0.45266 ];
 %!
 %! R = chol(A);
-%! 
+%!
 %! j = 3; p = [1:j-1, j+1:5];
 %! R1 = cholinsert(R,j,u2); A1 = R1'*R1;
-%! 
+%!
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(A1(p,p) - A,Inf) < 1e1*eps)
-%! 
+%!
 %!test
 %! u2 = [  0.35080  + 0.04298i;
 %!         0.63930  + 0.23778i;
 %!         3.31057  + 0.00000i;
 %!        -0.13825  + 0.19879i;
 %!         0.45266  + 0.50020i];
 %!
 %! R = chol(Ac);
-%! 
+%!
 %! j = 3; p = [1:j-1, j+1:5];
 %! R1 = cholinsert(R,j,u2); A1 = R1'*R1;
-%! 
+%!
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(A1(p,p) - Ac,Inf) < 1e1*eps)
-%! 
+%!
 
 %!test
 %! u2 = single ([  0.35080 ;
 %!                 0.63930 ;
 %!                 3.31057 ;
 %!                -0.13825 ;
 %!                 0.45266 ]);
 %!
 %! R = chol(single(A));
-%! 
+%!
 %! j = 3; p = [1:j-1, j+1:5];
 %! R1 = cholinsert(R,j,u2); A1 = R1'*R1;
-%! 
+%!
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(A1(p,p) - A,Inf) < 1e1*eps('single'))
-%! 
+%!
 %!test
 %! u2 = single ([  0.35080  + 0.04298i;
 %!                 0.63930  + 0.23778i;
 %!                 3.31057  + 0.00000i;
 %!                -0.13825  + 0.19879i;
 %!                 0.45266  + 0.50020i]);
 %!
 %! R = chol(single(Ac));
-%! 
+%!
 %! j = 3; p = [1:j-1, j+1:5];
 %! R1 = cholinsert(R,j,u2); A1 = R1'*R1;
-%! 
+%!
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(A1(p,p) - single(Ac),Inf) < 2e1*eps('single'))
-%! 
+%!
 */
 
 DEFUN_DLD (choldelete, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{R1} =} choldelete (@var{R}, @var{j})\n\
 Given a Cholesky@tie{}factorization of a real symmetric or complex Hermitian\n\
 positive definite matrix @w{@var{A} = @var{R}'*@var{R}}, @var{R}@tie{}upper\n\
 triangular, return the Cholesky@tie{}factorization of @w{A(p,p)}, where\n\
@@ -1091,47 +1091,47 @@ triangular, return the Cholesky@tie{}fac
     print_usage ();
 
   return retval;
 }
 
 /*
 %!test
 %! R = chol(A);
-%! 
+%!
 %! j = 3; p = [1:j-1,j+1:4];
 %! R1 = choldelete(R,j);
-%! 
+%!
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(R1'*R1 - A(p,p),Inf) < 1e1*eps)
-%! 
+%!
 %!test
 %! R = chol(Ac);
-%! 
+%!
 %! j = 3; p = [1:j-1,j+1:4];
 %! R1 = choldelete(R,j);
-%! 
+%!
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(R1'*R1 - Ac(p,p),Inf) < 1e1*eps)
 
 %!test
 %! R = chol(single(A));
-%! 
+%!
 %! j = 3; p = [1:j-1,j+1:4];
 %! R1 = choldelete(R,j);
-%! 
+%!
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(R1'*R1 - single(A(p,p)),Inf) < 1e1*eps('single'))
-%! 
+%!
 %!test
 %! R = chol(single(Ac));
-%! 
+%!
 %! j = 3; p = [1:j-1,j+1:4];
 %! R1 = choldelete(R,j);
-%! 
+%!
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(R1'*R1 - single(Ac(p,p)),Inf) < 1e1*eps('single'))
 */
 
 DEFUN_DLD (cholshift, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{R1} =} cholshift (@var{R}, @var{i}, @var{j})\n\
 Given a Cholesky@tie{}factorization of a real symmetric or complex Hermitian\n\
@@ -1165,17 +1165,17 @@ triangular, return the Cholesky@tie{}fac
       octave_idx_type i = argi.scalar_value ();
       octave_idx_type j = argj.scalar_value ();
 
       if (argr.columns () == n)
         {
           if (j > 0 && j <= n+1 && i > 0 && i <= n+1)
             {
 
-              if (argr.is_single_type () && argi.is_single_type () && 
+              if (argr.is_single_type () && argi.is_single_type () &&
                   argj.is_single_type ())
                 {
                   if (argr.is_real_type ())
                     {
                       // real case
                       FloatMatrix R = argr.float_matrix_value ();
 
                       FloatCHOL fact;
@@ -1232,66 +1232,66 @@ triangular, return the Cholesky@tie{}fac
     print_usage ();
 
   return retval;
 }
 
 /*
 %!test
 %! R = chol(A);
-%! 
+%!
 %! i = 1; j = 3; p = [1:i-1, shift(i:j,-1), j+1:4];
 %! R1 = cholshift(R,i,j);
-%! 
+%!
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(R1'*R1 - A(p,p),Inf) < 1e1*eps)
-%! 
+%!
 %! j = 1; i = 3; p = [1:j-1, shift(j:i,+1), i+1:4];
 %! R1 = cholshift(R,i,j);
-%! 
+%!
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(R1'*R1 - A(p,p),Inf) < 1e1*eps)
-%! 
+%!
 %!test
 %! R = chol(Ac);
-%! 
+%!
 %! i = 1; j = 3; p = [1:i-1, shift(i:j,-1), j+1:4];
 %! R1 = cholshift(R,i,j);
-%! 
+%!
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(R1'*R1 - Ac(p,p),Inf) < 1e1*eps)
-%! 
+%!
 %! j = 1; i = 3; p = [1:j-1, shift(j:i,+1), i+1:4];
 %! R1 = cholshift(R,i,j);
-%! 
+%!
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(R1'*R1 - Ac(p,p),Inf) < 1e1*eps)
 
 %!test
 %! R = chol(single(A));
-%! 
+%!
 %! i = 1; j = 3; p = [1:i-1, shift(i:j,-1), j+1:4];
 %! R1 = cholshift(R,i,j);
-%! 
+%!
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(R1'*R1 - single(A(p,p)),Inf) < 1e1*eps('single'))
-%! 
+%!
 %! j = 1; i = 3; p = [1:j-1, shift(j:i,+1), i+1:4];
 %! R1 = cholshift(R,i,j);
-%! 
+%!
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(R1'*R1 - single(A(p,p)),Inf) < 1e1*eps('single'))
-%! 
+%!
 %!test
 %! R = chol(single(Ac));
-%! 
+%!
 %! i = 1; j = 3; p = [1:i-1, shift(i:j,-1), j+1:4];
 %! R1 = cholshift(R,i,j);
-%! 
+%!
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(R1'*R1 - single(Ac(p,p)),Inf) < 1e1*eps('single'))
-%! 
+%!
 %! j = 1; i = 3; p = [1:j-1, shift(j:i,+1), i+1:4];
 %! R1 = cholshift(R,i,j);
-%! 
+%!
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(R1'*R1 - single(Ac(p,p)),Inf) < 1e1*eps('single'))
 */
diff --git a/src/DLD-FUNCTIONS/colamd.cc b/src/DLD-FUNCTIONS/colamd.cc
--- a/src/DLD-FUNCTIONS/colamd.cc
+++ b/src/DLD-FUNCTIONS/colamd.cc
@@ -47,43 +47,43 @@ along with Octave; see the file COPYING.
 #ifdef IDX_TYPE_LONG
 #define COLAMD_NAME(name) colamd_l ## name
 #define SYMAMD_NAME(name) symamd_l ## name
 #else
 #define COLAMD_NAME(name) colamd ## name
 #define SYMAMD_NAME(name) symamd ## name
 #endif
 
-// The symmetric column elimination tree code take from the Davis LDL code. 
+// The symmetric column elimination tree code take from the Davis LDL code.
 // Copyright given elsewhere in this file.
 static void
-symetree (const octave_idx_type *ridx, const octave_idx_type *cidx, 
+symetree (const octave_idx_type *ridx, const octave_idx_type *cidx,
           octave_idx_type *Parent, octave_idx_type *P, octave_idx_type n)
 {
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Flag, n);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Pinv, (P ? n : 0));
   if (P)
     // If P is present then compute Pinv, the inverse of P
     for (octave_idx_type k = 0 ; k < n ; k++)
       Pinv [P [k]] = k ;
 
   for (octave_idx_type k = 0 ; k < n ; k++)
     {
       // L(k,:) pattern: all nodes reachable in etree from nz in A(0:k-1,k)
-      Parent [k] = n ;                // parent of k is not yet known 
-      Flag [k] = k ;                  // mark node k as visited 
+      Parent [k] = n ;                // parent of k is not yet known
+      Flag [k] = k ;                  // mark node k as visited
       octave_idx_type kk = (P) ? (P [k]) : (k) ;  // kth original, or permuted, column
       octave_idx_type p2 = cidx [kk+1] ;
       for (octave_idx_type p = cidx [kk] ; p < p2 ; p++)
         {
           // A (i,k) is nonzero (original or permuted A)
           octave_idx_type i = (Pinv) ? (Pinv [ridx [p]]) : (ridx [p]) ;
           if (i < k)
             {
-              // follow path from i to root of etree, stop at flagged node 
+              // follow path from i to root of etree, stop at flagged node
               for ( ; Flag [i] != k ; i = Parent [i])
                 {
                   // find parent of i if not yet determined
                   if (Parent [i] == n)
                     Parent [i] = k ;
                   Flag [i] = k ;        // mark i as visited
                 }
             }
@@ -105,34 +105,34 @@ link (octave_idx_type s, octave_idx_type
   pp[s] = t;
   return t;
 }
 
 static inline octave_idx_type
 find (octave_idx_type i, octave_idx_type *pp)
 {
   register octave_idx_type p, gp;
-    
+
   p = pp[i];
   gp = pp[p];
 
   while (gp != p)
     {
       pp[i] = gp;
       i = gp;
       p = pp[i];
       gp = pp[p];
     }
 
   return p;
 }
 
 static octave_idx_type
-etdfs (octave_idx_type v, octave_idx_type *first_kid, 
-       octave_idx_type *next_kid, octave_idx_type *post, 
+etdfs (octave_idx_type v, octave_idx_type *first_kid,
+       octave_idx_type *next_kid, octave_idx_type *post,
        octave_idx_type postnum)
 {
   for (octave_idx_type w = first_kid[v]; w != -1; w = next_kid[w])
     postnum = etdfs (w, first_kid, next_kid, post, postnum);
 
   post[postnum++] = v;
 
   return postnum;
@@ -145,65 +145,65 @@ tree_postorder (octave_idx_type n, octav
   // Allocate storage for working arrays and results
   OCTAVE_LOCAL_BUFFER (octave_idx_type, first_kid, n+1);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, next_kid, n+1);
 
   // Set up structure describing children
   for (octave_idx_type v = 0; v <= n; first_kid[v++] = -1)
     /* do nothing */;
 
-  for (octave_idx_type v = n-1; v >= 0; v--) 
+  for (octave_idx_type v = n-1; v >= 0; v--)
     {
       octave_idx_type dad = parent[v];
       next_kid[v] = first_kid[dad];
       first_kid[dad] = v;
     }
 
   // Depth-first search from dummy root vertex #n
   etdfs (n, first_kid, next_kid, post, 0);
 }
 
 static void
 coletree (const octave_idx_type *ridx, const octave_idx_type *colbeg,
-          octave_idx_type *colend, octave_idx_type *parent, 
+          octave_idx_type *colend, octave_idx_type *parent,
           octave_idx_type nr, octave_idx_type nc)
 {
   OCTAVE_LOCAL_BUFFER (octave_idx_type, root, nc);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, pp, nc);
   OCTAVE_LOCAL_BUFFER (octave_idx_type, firstcol, nr);
 
   // Compute firstcol[row] = first nonzero column in row
   for (octave_idx_type row = 0; row < nr; firstcol[row++] = nc)
     /* do nothing */;
 
-  for (octave_idx_type col = 0; col < nc; col++) 
-    for (octave_idx_type p = colbeg[col]; p < colend[col]; p++) 
+  for (octave_idx_type col = 0; col < nc; col++)
+    for (octave_idx_type p = colbeg[col]; p < colend[col]; p++)
       {
         octave_idx_type row = ridx[p];
         if (firstcol[row] > col)
           firstcol[row] = col;
       }
 
   // Compute etree by Liu's algorithm for symmetric matrices,
   // except use (firstcol[r],c) in place of an edge (r,c) of A.
   // Thus each row clique in A'*A is replaced by a star
   // centered at its first vertex, which has the same fill.
-  for (octave_idx_type col = 0; col < nc; col++) 
+  for (octave_idx_type col = 0; col < nc; col++)
     {
       octave_idx_type cset = make_set (col, pp);
       root[cset] = col;
-      parent[col] = nc; 
-      for (octave_idx_type p = colbeg[col]; p < colend[col]; p++) 
+      parent[col] = nc;
+      for (octave_idx_type p = colbeg[col]; p < colend[col]; p++)
         {
           octave_idx_type row = firstcol[ridx[p]];
-          if (row >= col) 
+          if (row >= col)
             continue;
           octave_idx_type rset = find (row, pp);
           octave_idx_type rroot = root[rset];
-          if (rroot != col) 
+          if (rroot != col)
             {
               parent[rroot] = col;
               cset = link (cset, rset, pp);
               root[cset] = col;
             }
         }
     }
 }
@@ -278,69 +278,69 @@ Ng, Oak Ridge National Laboratory.  (see
 @end deftypefn")
 {
   octave_value_list retval;
 
 #ifdef HAVE_COLAMD
 
   int nargin = args.length ();
   int spumoni = 0;
- 
+
   if (nargout > 2 || nargin < 1 || nargin > 2)
     print_usage ();
   else
     {
       // Get knobs
-      OCTAVE_LOCAL_BUFFER (double, knobs, COLAMD_KNOBS);      
+      OCTAVE_LOCAL_BUFFER (double, knobs, COLAMD_KNOBS);
       COLAMD_NAME (_set_defaults) (knobs);
 
       // Check for user-passed knobs
       if (nargin == 2)
         {
           NDArray User_knobs = args(1).array_value ();
           int nel_User_knobs = User_knobs.length ();
-          
-          if (nel_User_knobs > 0) 
+
+          if (nel_User_knobs > 0)
             knobs [COLAMD_DENSE_ROW] = User_knobs (0);
-          if (nel_User_knobs > 1) 
+          if (nel_User_knobs > 1)
             knobs [COLAMD_DENSE_COL] = User_knobs (1) ;
-          if (nel_User_knobs > 2) 
+          if (nel_User_knobs > 2)
             spumoni = static_cast<int> (User_knobs (2));
 
           // print knob settings if spumoni is set
           if (spumoni)
             {
 
               octave_stdout << "\ncolamd version " << COLAMD_MAIN_VERSION << "."
                             <<  COLAMD_SUB_VERSION << ", " << COLAMD_DATE << ":\n";
 
               if (knobs [COLAMD_DENSE_ROW] >= 0)
-                octave_stdout << "knobs(1): " << User_knobs (0) 
+                octave_stdout << "knobs(1): " << User_knobs (0)
                               << ", rows with > max(16,"
                               << knobs [COLAMD_DENSE_ROW] << "*sqrt(size(A,2)))"
                               << " entries removed\n";
               else
                 octave_stdout << "knobs(1): " << User_knobs (0)
                               << ", only completely dense rows removed\n";
 
               if (knobs [COLAMD_DENSE_COL] >= 0)
-                octave_stdout << "knobs(2): " << User_knobs (1) 
+                octave_stdout << "knobs(2): " << User_knobs (1)
                               << ", cols with > max(16,"
                               << knobs [COLAMD_DENSE_COL] << "*sqrt(size(A)))"
                               << " entries removed\n";
               else
                 octave_stdout << "knobs(2): " << User_knobs (1)
                               << ", only completely dense columns removed\n";
 
-              octave_stdout << "knobs(3): " << User_knobs (2) 
+              octave_stdout << "knobs(3): " << User_knobs (2)
                             << ", statistics and knobs printed\n";
 
             }
         }
-      
+
       octave_idx_type n_row, n_col, nnz;
       octave_idx_type *ridx, *cidx;
       SparseComplexMatrix scm;
       SparseMatrix sm;
 
       if (args(0).is_sparse_type ())
         {
           if (args(0).is_complex_type ())
@@ -426,21 +426,21 @@ Ng, Oak Ridge National Laboratory.  (see
       // Return the stats vector
       if (nargout == 2)
         {
           NDArray out_stats (dim_vector (1, COLAMD_STATS));
           for (octave_idx_type i = 0 ; i < COLAMD_STATS ; i++)
             out_stats (i) = stats [i] ;
           retval(1) = out_stats;
 
-          // fix stats (5) and (6), for 1-based information on 
-          // jumbled matrix.  note that this correction doesn't 
+          // fix stats (5) and (6), for 1-based information on
+          // jumbled matrix.  note that this correction doesn't
           // occur if symamd returns FALSE
-          out_stats (COLAMD_INFO1) ++ ; 
-          out_stats (COLAMD_INFO2) ++ ; 
+          out_stats (COLAMD_INFO1) ++ ;
+          out_stats (COLAMD_INFO2) ++ ;
         }
     }
 
 #else
 
   error ("colamd: not available in this version of Octave");
 
 #endif
@@ -513,42 +513,42 @@ Ng, Oak Ridge National Laboratory.  (see
 @end deftypefn")
 {
   octave_value_list retval;
 
 #ifdef HAVE_COLAMD
 
   int nargin = args.length ();
   int spumoni = 0;
- 
+
   if (nargout > 2 || nargin < 1 || nargin > 2)
     print_usage ();
   else
     {
       // Get knobs
       OCTAVE_LOCAL_BUFFER (double, knobs, COLAMD_KNOBS);
       COLAMD_NAME (_set_defaults) (knobs);
 
       // Check for user-passed knobs
       if (nargin == 2)
         {
           NDArray User_knobs = args(1).array_value ();
           int nel_User_knobs = User_knobs.length ();
-          
-          if (nel_User_knobs > 0) 
+
+          if (nel_User_knobs > 0)
             knobs [COLAMD_DENSE_ROW] = User_knobs (COLAMD_DENSE_ROW);
-          if (nel_User_knobs > 1) 
+          if (nel_User_knobs > 1)
             spumoni = static_cast<int> (User_knobs (1));
         }
 
       // print knob settings if spumoni is set
       if (spumoni > 0)
-        octave_stdout << "symamd: dense row/col fraction: " 
+        octave_stdout << "symamd: dense row/col fraction: "
                       << knobs [COLAMD_DENSE_ROW] << std::endl;
-      
+
       octave_idx_type n_row, n_col, nnz;
       octave_idx_type *ridx, *cidx;
       SparseMatrix sm;
       SparseComplexMatrix scm;
 
       if (args(0).is_sparse_type ())
         {
           if (args(0).is_complex_type ())
@@ -571,17 +571,17 @@ Ng, Oak Ridge National Laboratory.  (see
             }
         }
       else
         {
           if (args(0).is_complex_type ())
             sm = SparseMatrix (real (args(0).complex_matrix_value ()));
           else
             sm = SparseMatrix (args(0).matrix_value ());
-          
+
           n_row = sm.rows ();
           n_col = sm.cols ();
           nnz = sm.nnz ();
           ridx = sm.xridx ();
           cidx = sm.xcidx ();
         }
 
       if (n_row != n_col)
@@ -622,21 +622,21 @@ Ng, Oak Ridge National Laboratory.  (see
       // Return the stats vector
       if (nargout == 2)
         {
           NDArray out_stats (dim_vector (1, COLAMD_STATS));
           for (octave_idx_type i = 0 ; i < COLAMD_STATS ; i++)
             out_stats (i) = stats [i] ;
           retval(1) = out_stats;
 
-          // fix stats (5) and (6), for 1-based information on 
-          // jumbled matrix.  note that this correction doesn't 
+          // fix stats (5) and (6), for 1-based information on
+          // jumbled matrix.  note that this correction doesn't
           // occur if symamd returns FALSE
-          out_stats (COLAMD_INFO1) ++ ; 
-          out_stats (COLAMD_INFO2) ++ ; 
+          out_stats (COLAMD_INFO1) ++ ;
+          out_stats (COLAMD_INFO2) ++ ;
         }
     }
 
 #else
 
   error ("symamd: not available in this version of Octave");
 
 #endif
diff --git a/src/DLD-FUNCTIONS/colloc.cc b/src/DLD-FUNCTIONS/colloc.cc
--- a/src/DLD-FUNCTIONS/colloc.cc
+++ b/src/DLD-FUNCTIONS/colloc.cc
@@ -117,17 +117,17 @@ Polynomial Approximation}.\n\
     }
 
   ntot += left + right;
   if (ntot < 1)
     {
       error ("colloc: the total number of roots must be positive");
       return retval;
     }
-  
+
   CollocWt wts (ncol, left, right);
 
   ColumnVector r = wts.roots ();
   Matrix A = wts.first ();
   Matrix B = wts.second ();
   ColumnVector q = wts.quad_weights ();
 
   retval(3) = q;
diff --git a/src/DLD-FUNCTIONS/convhulln.cc b/src/DLD-FUNCTIONS/convhulln.cc
--- a/src/DLD-FUNCTIONS/convhulln.cc
+++ b/src/DLD-FUNCTIONS/convhulln.cc
@@ -68,25 +68,25 @@ calculated.\n\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
 #ifdef HAVE_QHULL
   std::string options;
 
   int nargin = args.length ();
-  if (nargin < 1 || nargin > 2) 
+  if (nargin < 1 || nargin > 2)
     {
       print_usage ();
       return retval;
     }
 
-  if (nargin == 2) 
+  if (nargin == 2)
     {
-      if (args (1).is_string ()) 
+      if (args (1).is_string ())
         options = args(1).string_value ();
       else if (args(1).is_cell ())
         {
           Cell c = args(1).cell_value ();
           options = "";
           for (octave_idx_type i = 0; i < c.numel (); i++)
             {
               if (! c.elem(i).is_string ())
@@ -128,51 +128,51 @@ calculated.\n\n\
   // because the argument is not declared const.  Ugh.  Unless
   // qh_new_qhull really needs to modify this argument, someone should
   // fix QHULL.
 
   OCTAVE_LOCAL_BUFFER (char, flags, buf_string.length () + 1);
 
   strcpy (flags, buf_string.c_str ());
 
-  if (! qh_new_qhull (dim, n, pt_array, ismalloc, flags, 0, stderr)) 
+  if (! qh_new_qhull (dim, n, pt_array, ismalloc, flags, 0, stderr))
     {
       // If you want some debugging information replace the NULL
       // pointer with stdout
 
       vertexT *vertex, **vertexp;
       facetT *facet;
       setT *vertices;
       unsigned int nf = qh num_facets;
 
       Matrix idx (nf, dim);
 
       octave_idx_type j, i = 0;
-      FORALLfacets 
+      FORALLfacets
         {
           j = 0;
           if (! facet->simplicial)
             // should never happen with QJ
             error ("convhulln: non-simplicial facet");
 
-          if (dim == 3) 
+          if (dim == 3)
             {
               vertices = qh_facet3vertex (facet);
               FOREACHvertex_ (vertices)
                 idx(i, j++) = 1 + qh_pointid(vertex->point);
               qh_settempfree (&vertices);
-            } 
-          else 
+            }
+          else
             {
-              if (facet->toporient ^ qh_ORIENTclock) 
+              if (facet->toporient ^ qh_ORIENTclock)
                 {
                   FOREACHvertex_ (facet->vertices)
                     idx(i, j++) = 1 + qh_pointid(vertex->point);
-                } 
-              else 
+                }
+              else
                 {
                   FOREACHvertexreverse12_ (facet->vertices)
                     idx(i, j++) = 1 + qh_pointid(vertex->point);
                 }
             }
           if (j < dim)
             // likewise but less fatal
             warning ("facet %d only has %d vertices", i, j);
@@ -218,17 +218,17 @@ calculated.\n\n\
 
   // free long memory
   qh_freeqhull (! qh_ALL);
 
   // free short memory and memory allocator
   int curlong, totlong;
   qh_memfreeshort (&curlong, &totlong);
 
-  if (curlong || totlong) 
+  if (curlong || totlong)
     warning ("convhulln: did not free %d bytes of long memory (%d pieces)",
             totlong, curlong);
 #else
   error ("convhulln: not available in this version of Octave");
 #endif
 
   return retval;
 }
diff --git a/src/DLD-FUNCTIONS/daspk.cc b/src/DLD-FUNCTIONS/daspk.cc
--- a/src/DLD-FUNCTIONS/daspk.cc
+++ b/src/DLD-FUNCTIONS/daspk.cc
@@ -307,17 +307,17 @@ parameters for @code{daspk}.\n\
                 {
                   fcn_name = unique_symbol_name ("__daspk_fcn__");
                   fname = "function y = ";
                   fname.append (fcn_name);
                   fname.append (" (x, xdot, t) y = ");
                   daspk_fcn = extract_function
                     (c(0), "daspk", fcn_name, fname, "; endfunction");
                 }
-              
+
               if (daspk_fcn)
                 {
                   if (c(1).is_function_handle () || c(1).is_inline_function ())
                     daspk_jac = c(1).function_value ();
                   else
                     {
                       jac_name = unique_symbol_name ("__daspk_jac__");
                       jname = "function jac = ";
diff --git a/src/DLD-FUNCTIONS/dasrt.cc b/src/DLD-FUNCTIONS/dasrt.cc
--- a/src/DLD-FUNCTIONS/dasrt.cc
+++ b/src/DLD-FUNCTIONS/dasrt.cc
@@ -438,60 +438,60 @@ parameters for @code{dasrt}.\n\
             case 1:
               fcn_name = unique_symbol_name ("__dasrt_fcn__");
               fname = "function y = ";
               fname.append (fcn_name);
               fname.append (" (x, xdot, t) y = ");
               dasrt_f = extract_function
                 (f_arg, "dasrt", fcn_name, fname, "; endfunction");
               break;
-      
+
             case 2:
               {
                 string_vector tmp = args(0).all_strings ();
-        
+
                 if (! error_state)
                   {
                     fcn_name = unique_symbol_name ("__dasrt_fcn__");
                     fname = "function y = ";
                     fname.append (fcn_name);
                     fname.append (" (x, xdot, t) y = ");
                     dasrt_f = extract_function
                       (tmp(0), "dasrt", fcn_name, fname, "; endfunction");
-            
+
                     if (dasrt_f)
                       {
                         jac_name = unique_symbol_name ("__dasrt_jac__");
                         jname = "function jac = ";
                         jname.append(jac_name);
                         jname.append (" (x, xdot, t, cj) jac = ");
                         dasrt_j = extract_function
                           (tmp(1), "dasrt", jac_name, jname, "; endfunction");
 
                         if (! dasrt_j)
                           dasrt_f = 0;
                       }
                   }
               }
               break;
-      
+
             default:
               DASRT_ABORT1
                 ("first arg should be a string or 2-element string array");
             }
         }
     }
-  
+
   if (error_state || (! dasrt_f))
     DASRT_ABORT;
-  
+
   DAERTFunc func (dasrt_user_f);
-  
+
   argp++;
-  
+
   if (args(1).is_function_handle() || args(1).is_inline_function())
     {
       dasrt_cf = args(1).function_value();
 
       if (! dasrt_cf)
         DASRT_ABORT1 ("expecting function name as argument 2");
 
       argp++;
@@ -512,17 +512,17 @@ parameters for @code{dasrt}.\n\
   ColumnVector state (args(argp++).vector_value ());
 
   if (error_state)
     DASRT_ABORT2 ("expecting state vector as argument %d", argp);
 
   ColumnVector stateprime (args(argp++).vector_value ());
 
   if (error_state)
-    DASRT_ABORT2 
+    DASRT_ABORT2
        ("expecting time derivative of state vector as argument %d", argp);
 
   ColumnVector out_times (args(argp++).vector_value ());
 
   if (error_state)
     DASRT_ABORT2
         ("expecting output time vector as %s argument %d", argp);
 
diff --git a/src/DLD-FUNCTIONS/dassl.cc b/src/DLD-FUNCTIONS/dassl.cc
--- a/src/DLD-FUNCTIONS/dassl.cc
+++ b/src/DLD-FUNCTIONS/dassl.cc
@@ -308,17 +308,17 @@ parameters for @code{dassl}.\n\
                 {
                   fcn_name = unique_symbol_name ("__dassl_fcn__");
                   fname = "function y = ";
                   fname.append (fcn_name);
                   fname.append (" (x, xdot, t) y = ");
                   dassl_fcn = extract_function
                     (c(0), "dassl", fcn_name, fname, "; endfunction");
                 }
-              
+
               if (dassl_fcn)
                 {
                   if (c(1).is_function_handle () || c(1).is_inline_function ())
                     dassl_jac = c(1).function_value ();
                   else
                     {
                         jac_name = unique_symbol_name ("__dassl_jac__");
                         jname = "function jac = ";
@@ -376,17 +376,17 @@ parameters for @code{dassl}.\n\
 
                         if (dassl_fcn)
                           {
                             jac_name = unique_symbol_name ("__dassl_jac__");
                             jname = "function jac = ";
                             jname.append(jac_name);
                             jname.append (" (x, xdot, t, cj) jac = ");
                             dassl_jac = extract_function
-                              (tmp(1), "dassl", jac_name, jname, 
+                              (tmp(1), "dassl", jac_name, jname,
                                "; endfunction");
 
                             if (!dassl_jac)
                               {
                                 if (fcn_name.length())
                                   clear_function (fcn_name);
                                 dassl_fcn = 0;
                               }
@@ -498,65 +498,65 @@ parameters for @code{dassl}.\n\
 %%
 %% Solution
 %%
 %%    y1(t) = cos(t)
 %%    y2(t) = sin(t)
 %!function res = f (x, xdot, t)
 %!  res = [xdot(1)+x(2); xdot(2)-x(1)];
 %!test
-%! 
+%!
 %! x0 = [1; 0];
 %! xdot0 = [0; 1];
 %! t = (0:1:10)';
-%! 
+%!
 %! tol = 100 * dassl_options ("relative tolerance");
-%! 
-%! 
+%!
+%!
 %! [x, xdot] = dassl ("f", x0, xdot0, t);
-%! 
+%!
 %! y = [cos(t), sin(t)];
-%! 
+%!
 %! assert(all (all (abs (x - y) < tol)));
 
 %% dassl-2.m
 %%
 %% Test dassl() function
 %%
 %% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
 %%         Comalco Research and Technology
 %%         20 May 1998
 %%
 %% Based on SLATEC quick check for DASSL by Linda Petzold
 %%
 %% Problem
 %%
 %%   x1' + 10*x1 = 0,   x1(0) = 1
 %%   x1  + x2    = 1,   x2(0) = 0
-%% 
+%%
 %%
 %% Solution
 %%
 %%  x1(t) = exp(-10*t)
 %%  x2(t) = 1 - x(1)
 %!function res = f (x, xdot, t)
 %!  res = [xdot(1)+10*x(1); x(1)+x(2)-1];
 %!test
-%! 
+%!
 %! x0 = [1; 0];
 %! xdot0 = [-10; 10];
 %! t = (0:0.2:1)';
-%! 
+%!
 %! tol = 500 * dassl_options ("relative tolerance");
-%! 
-%! 
+%!
+%!
 %! [x, xdot] = dassl ("f", x0, xdot0, t);
-%! 
+%!
 %! y = [exp(-10*t), 1-exp(-10*t)];
-%! 
+%!
 %! assert(all (all (abs (x - y) < tol)));
 
 %!test
 %! dassl_options ("absolute tolerance", eps);
 %! assert(dassl_options ("absolute tolerance") == eps);
 
 %!error <Invalid call to dassl_options.*> dassl_options ("foo", 1, 2);
 
diff --git a/src/DLD-FUNCTIONS/det.cc b/src/DLD-FUNCTIONS/det.cc
--- a/src/DLD-FUNCTIONS/det.cc
+++ b/src/DLD-FUNCTIONS/det.cc
@@ -70,17 +70,17 @@ For that, use any of the condition numbe
 
   if (nargin != 1)
     {
       print_usage ();
       return retval;
     }
 
   octave_value arg = args(0);
-    
+
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   if (nr == 0 && nc == 0)
     {
       retval(0) = 1.0;
       return retval;
     }
diff --git a/src/DLD-FUNCTIONS/dlmread.cc b/src/DLD-FUNCTIONS/dlmread.cc
--- a/src/DLD-FUNCTIONS/dlmread.cc
+++ b/src/DLD-FUNCTIONS/dlmread.cc
@@ -105,17 +105,17 @@ parse_range_spec (const octave_value& ra
         }
       else
         {
           stat = read_cell_spec (is, rlo, clo);
 
           if (stat)
             {
               ch = is.peek ();
-          
+
               if (ch == '.' || ch == ':')
                 {
                   ch = is.get ();
                   if (ch == '.')
                     {
                       ch = is.get ();
                       if (!is || ch != '.')
                         stat = false;
@@ -138,23 +138,23 @@ parse_range_spec (const octave_value& ra
         stat = read_cell_spec (is, rup, cup);
 
       if (!is || !is.eof ())
         stat = false;
     }
   else if (range_spec.is_real_matrix () && range_spec.numel () == 4)
     {
       ColumnVector range(range_spec.vector_value ());
-      // double --> unsigned int     
+      // double --> unsigned int
       rlo = static_cast<octave_idx_type> (range(0));
       clo = static_cast<octave_idx_type> (range(1));
       rup = static_cast<octave_idx_type> (range(2));
       cup = static_cast<octave_idx_type> (range(3));
     }
-  else 
+  else
     stat = false;
 
   return stat;
 }
 
 DEFUN_DLD (dlmread, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{data} =} dlmread (@var{file})\n\
@@ -185,26 +185,26 @@ fields.  The default is zero.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   double empty_value = 0.0;
 
-  if (nargin > 2 && args(nargin-2).is_string () 
+  if (nargin > 2 && args(nargin-2).is_string ()
       && args(nargin-2).string_value () == "emptyvalue")
     {
       empty_value = args(nargin-1).double_value ();
       if (error_state)
          return retval;
       nargin -= 2;
     }
 
-  if (nargin < 1 || nargin > 4) 
+  if (nargin < 1 || nargin > 4)
     {
       print_usage ();
       return retval;
     }
 
   std::istream *input = 0;
   std::ifstream input_file;
 
@@ -255,27 +255,27 @@ fields.  The default is zero.\n\
       if (args(1).is_sq_string ())
         sep = do_string_escapes (args(1).string_value ());
       else
         sep = args(1).string_value ();
 
       if (error_state)
         return retval;
     }
-  
+
   // Take a subset if a range was given.
   octave_idx_type r0 = 0, c0 = 0, r1 = idx_max-1, c1 = idx_max-1;
   if (nargin > 2)
     {
       if (nargin == 3)
         {
           if (!parse_range_spec (args (2), r0, c0, r1, c1))
             error ("dlmread: error parsing RANGE");
-        } 
-      else if (nargin == 4) 
+        }
+      else if (nargin == 4)
         {
           r0 = args(2).idx_type_value ();
           c0 = args(3).idx_type_value ();
 
           if (error_state)
             return retval;
         }
 
@@ -309,17 +309,17 @@ fields.  The default is zero.\n\
           // Skip blank lines for compatibility.
           if (line.find_first_not_of (" \t") == std::string::npos)
             continue;
 
           // To be compatible with matlab, blank separator should
           // correspond to whitespace as delimter.
           if (!sep.length ())
             {
-              size_t n = line.find_first_of (",:; \t", 
+              size_t n = line.find_first_of (",:; \t",
                                              line.find_first_of ("0123456789"));
               if (n == std::string::npos)
                 {
                   sep = " \t";
                   sepflag = true;
                 }
               else
                 {
@@ -385,17 +385,17 @@ fields.  The default is zero.\n\
               std::string str = line.substr (pos1, pos2 - pos1);
 
               if (sepflag && pos2 != std::string::npos)
                 // Treat consecutive separators as one.
                 pos2 = line.find_first_not_of (sep, pos2) - 1;
 
               c = (c > j + 1 ? c : j + 1);
               if (r > rmax || c > cmax)
-                { 
+                {
                   // Use resize_and_fill for the case of not-equal
                   // length rows.
                   rmax = 2*r;
                   cmax = c;
                   if (iscmplx)
                     cdata.resize (rmax, cmax);
                   else
                     rdata.resize (rmax, cmax);
@@ -451,41 +451,41 @@ fields.  The default is zero.\n\
             }
           while (pos1 != std::string::npos);
 
           if (i == r1)
             break;
 
           i++;
         }
- 
+
       if (r1 >= r)
         r1 = r - 1;
       if (c1 >= c)
         c1 = c - 1;
 
       // Now take the subset of the matrix.
       if (iscmplx)
         cdata = cdata.extract (0, c0, r1, c1);
       else
         rdata = rdata.extract (0, c0, r1, c1);
-  
+
       if (iscmplx)
         retval(0) = cdata;
       else
         retval(0) = rdata;
     }
 
   return retval;
 }
 
 /*
 
 %!shared file
-%! file = tmpnam (); 
+%! file = tmpnam ();
 %! fid = fopen (file, "wt");
 %! fwrite (fid, "1, 2, 3\n4, 5, 6\n7, 8, 9\n10, 11, 12");
 %! fclose (fid);
 
 %!assert (dlmread (file), [1, 2, 3; 4, 5, 6; 7, 8, 9;10, 11, 12]);
 %!assert (dlmread (file, ","), [1, 2, 3; 4, 5, 6; 7, 8, 9; 10, 11, 12]);
 %!assert (dlmread (file, ",", [1, 0, 2, 1]), [4, 5; 7, 8]);
 %!assert (dlmread (file, ",", "B1..C2"), [2, 3; 5, 6]);
@@ -494,17 +494,17 @@ fields.  The default is zero.\n\
 %!assert (dlmread (file, ",", 0, 1), [2, 3; 5, 6; 8, 9; 11, 12]);
 %!assert (dlmread (file, ",", "B1.."), [2, 3; 5, 6; 8, 9; 11, 12]);
 %!error (dlmread (file, ",", [0 1]))
 
 %!test
 %! unlink (file);
 
 %!shared file
-%! file = tmpnam (); 
+%! file = tmpnam ();
 %! fid = fopen (file, "wt");
 %! fwrite (fid, "1, 2, 3\n4+4i, 5, 6\n7, 8, 9\n10, 11, 12");
 %! fclose (fid);
 
 %!assert (dlmread (file), [1, 2, 3; 4 + 4i, 5, 6; 7, 8, 9; 10, 11, 12]);
 %!assert (dlmread (file, ","), [1, 2, 3; 4 + 4i, 5, 6; 7, 8, 9; 10, 11, 12]);
 %!assert (dlmread (file, ",", [1, 0, 2, 1]), [4 + 4i, 5; 7, 8]);
 %!assert (dlmread (file, ",", "A2..B3"), [4 + 4i, 5; 7, 8]);
diff --git a/src/DLD-FUNCTIONS/dmperm.cc b/src/DLD-FUNCTIONS/dmperm.cc
--- a/src/DLD-FUNCTIONS/dmperm.cc
+++ b/src/DLD-FUNCTIONS/dmperm.cc
@@ -150,33 +150,33 @@ of the blocks.  If @var{S} is square the
 The method used is described in: A. Pothen & C.-J. Fan. @cite{Computing the\n\
 Block Triangular Form of a Sparse Matrix}. ACM Trans. Math. Software,\n\
 16(4):303-324, 1990.\n\
 @seealso{colamd, ccolamd}\n\
 @end deftypefn")
 {
   int nargin = args.length();
   octave_value_list retval;
-  
+
   if (nargin != 1)
     {
       print_usage ();
       return retval;
     }
 
 #if HAVE_CXSPARSE
   retval = dmperm_internal (false, args(0), nargout);
 #else
   error ("dmperm: not available in this version of Octave");
 #endif
 
   return retval;
 }
 
-/* 
+/*
 
 %!testif HAVE_CXSPARSE
 %! n=20;
 %! a=speye(n,n);a=a(randperm(n),:);
 %! assert(a(dmperm(a),:),speye(n))
 
 %!testif HAVE_CXSPARSE
 %! n=20;
@@ -199,33 +199,33 @@ a Dulmage-Mendelsohn permutation to bloc
 numerical rank of the matrix @var{S} is bounded by\n\
 @code{sprank (@var{S}) >= rank (@var{S})}.  Ignoring floating point errors\n\
 @code{sprank (@var{S}) == rank (@var{S})}.\n\
 @seealso{dmperm}\n\
 @end deftypefn")
 {
   int nargin = args.length();
   octave_value_list retval;
-  
+
   if (nargin != 1)
     {
       print_usage ();
       return retval;
     }
 
 #if HAVE_CXSPARSE
   retval = dmperm_internal (true, args(0), nargout);
 #else
   error ("sprank: not available in this version of Octave");
 #endif
 
   return retval;
 }
 
-/* 
+/*
 
 %!error(sprank(1,2));
 %!testif HAVE_CXSPARSE
 %! assert(sprank(speye(20)), 20)
 %!testif HAVE_CXSPARSE
 %! assert(sprank([1,0,2,0;2,0,4,0]),2)
 
 */
diff --git a/src/DLD-FUNCTIONS/dot.cc b/src/DLD-FUNCTIONS/dot.cc
--- a/src/DLD-FUNCTIONS/dot.cc
+++ b/src/DLD-FUNCTIONS/dot.cc
@@ -28,58 +28,58 @@ along with Octave; see the file COPYING.
 #include "mx-base.h"
 #include "error.h"
 #include "defun-dld.h"
 #include "parse.h"
 
 extern "C"
 {
   F77_RET_T
-  F77_FUNC (ddot3, DDOT3) (const octave_idx_type&, const octave_idx_type&, 
+  F77_FUNC (ddot3, DDOT3) (const octave_idx_type&, const octave_idx_type&,
                            const octave_idx_type&, const double*,
                            const double*, double*);
 
   F77_RET_T
-  F77_FUNC (sdot3, SDOT3) (const octave_idx_type&, const octave_idx_type&, 
+  F77_FUNC (sdot3, SDOT3) (const octave_idx_type&, const octave_idx_type&,
                            const octave_idx_type&, const float*,
                            const float*, float*);
 
   F77_RET_T
-  F77_FUNC (zdotc3, ZDOTC3) (const octave_idx_type&, const octave_idx_type&, 
+  F77_FUNC (zdotc3, ZDOTC3) (const octave_idx_type&, const octave_idx_type&,
                              const octave_idx_type&, const Complex*,
                              const Complex*, Complex*);
 
   F77_RET_T
-  F77_FUNC (cdotc3, CDOTC3) (const octave_idx_type&, const octave_idx_type&, 
+  F77_FUNC (cdotc3, CDOTC3) (const octave_idx_type&, const octave_idx_type&,
                              const octave_idx_type&, const FloatComplex*,
                              const FloatComplex*, FloatComplex*);
 
   F77_RET_T
-  F77_FUNC (dmatm3, DMATM3) (const octave_idx_type&, const octave_idx_type&, 
-                             const octave_idx_type&, const octave_idx_type&, 
+  F77_FUNC (dmatm3, DMATM3) (const octave_idx_type&, const octave_idx_type&,
+                             const octave_idx_type&, const octave_idx_type&,
                              const double*, const double*, double*);
 
   F77_RET_T
-  F77_FUNC (smatm3, SMATM3) (const octave_idx_type&, const octave_idx_type&, 
-                             const octave_idx_type&, const octave_idx_type&, 
+  F77_FUNC (smatm3, SMATM3) (const octave_idx_type&, const octave_idx_type&,
+                             const octave_idx_type&, const octave_idx_type&,
                              const float*, const float*, float*);
 
   F77_RET_T
-  F77_FUNC (zmatm3, ZMATM3) (const octave_idx_type&, const octave_idx_type&, 
-                             const octave_idx_type&, const octave_idx_type&, 
+  F77_FUNC (zmatm3, ZMATM3) (const octave_idx_type&, const octave_idx_type&,
+                             const octave_idx_type&, const octave_idx_type&,
                              const Complex*, const Complex*, Complex*);
 
   F77_RET_T
-  F77_FUNC (cmatm3, CMATM3) (const octave_idx_type&, const octave_idx_type&, 
-                             const octave_idx_type&, const octave_idx_type&, 
+  F77_FUNC (cmatm3, CMATM3) (const octave_idx_type&, const octave_idx_type&,
+                             const octave_idx_type&, const octave_idx_type&,
                              const FloatComplex*, const FloatComplex*,
                              FloatComplex*);
 }
 
-static void 
+static void
 get_red_dims (const dim_vector& x, const dim_vector& y, int dim,
               dim_vector& z, octave_idx_type& m, octave_idx_type& n,
               octave_idx_type& k)
 {
   int nd = x.length ();
   assert (nd == y.length ());
   z = dim_vector::alloc (nd);
   m = 1, n = 1, k = 1;
@@ -129,17 +129,17 @@ but avoids forming a temporary array and
     }
 
   octave_value argx = args(0), argy = args(1);
 
   if (argx.is_numeric_type () && argy.is_numeric_type ())
     {
       dim_vector dimx = argx.dims (), dimy = argy.dims ();
       bool match = dimx == dimy;
-      if (! match && nargin == 2 
+      if (! match && nargin == 2
           && dimx.is_vector () && dimy.is_vector ())
         {
           // Change to column vectors.
           dimx = dimx.redim (1);
           argx = argx.reshape (dimx);
           dimy = dimy.redim (1);
           argy = argy.reshape (dimy);
           match = ! error_state;
diff --git a/src/DLD-FUNCTIONS/eig.cc b/src/DLD-FUNCTIONS/eig.cc
--- a/src/DLD-FUNCTIONS/eig.cc
+++ b/src/DLD-FUNCTIONS/eig.cc
@@ -214,17 +214,17 @@ The eigenvalues returned by @code{eig} a
               tmp_a = arg_a.matrix_value ();
               tmp_b = arg_b.matrix_value ();
 
               if (error_state)
                 return retval;
               else
                 result = EIG (tmp_a, tmp_b, nargout > 1);
             }
-          else 
+          else
             {
               ctmp_a = arg_a.complex_matrix_value ();
               ctmp_b = arg_b.complex_matrix_value ();
 
               if (error_state)
                 return retval;
               else
                 result = EIG (ctmp_a, ctmp_b, nargout > 1);
diff --git a/src/DLD-FUNCTIONS/eigs.cc b/src/DLD-FUNCTIONS/eigs.cc
--- a/src/DLD-FUNCTIONS/eigs.cc
+++ b/src/DLD-FUNCTIONS/eigs.cc
@@ -413,19 +413,19 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
             {
               amm = (args(0).matrix_value());
               symmetric = amm.is_symmetric();
             }
         }
 
     }
 
-  // Note hold off reading B till later to avoid issues of double 
+  // Note hold off reading B till later to avoid issues of double
   // copies of the matrix if B is full/real while A is complex..
-  if (!error_state && nargin > 1 + arg_offset && 
+  if (!error_state && nargin > 1 + arg_offset &&
       !(args(1 + arg_offset).is_real_scalar ()))
     {
       if (args(1+arg_offset).is_complex_type ())
         {
           b_arg = 1+arg_offset;
           have_b = true;
           bmat = 'G';
           b_is_complex = true;
@@ -556,40 +556,40 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
         {
           if (a_is_sparse)
             bsmm = args(b_arg).sparse_matrix_value ();
           else
             bmm = args(b_arg).matrix_value ();
         }
     }
 
-  // Mode 1 for SM mode seems unstable for some reason. 
+  // Mode 1 for SM mode seems unstable for some reason.
   // Use Mode 3 instead, with sigma = 0.
   if (!error_state && !have_sigma && typ == "SM")
     have_sigma = true;
 
   if (!error_state)
     {
       octave_idx_type nconv;
       if (a_is_complex || b_is_complex)
         {
           ComplexMatrix eig_vec;
           ComplexColumnVector eig_val;
 
 
           if (have_a_fun)
-            nconv = EigsComplexNonSymmetricFunc 
+            nconv = EigsComplexNonSymmetricFunc
               (eigs_complex_func, n, typ, sigma, k, p, info, eig_vec, eig_val,
                cresid, octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
           else if (have_sigma)
             {
               if (a_is_sparse)
                 nconv = EigsComplexNonSymmetricMatrixShift
                   (ascm, sigma, k, p, info, eig_vec, eig_val, bscm, permB,
-                   cresid, octave_stdout, tol, (nargout > 1), cholB, disp, 
+                   cresid, octave_stdout, tol, (nargout > 1), cholB, disp,
                    maxit);
               else
                 nconv = EigsComplexNonSymmetricMatrixShift
                   (acm, sigma, k, p, info, eig_vec, eig_val, bcm, permB, cresid,
                    octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
             }
           else
             {
@@ -614,28 +614,28 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
         }
       else if (sigmai != 0.)
         {
           // Promote real problem to a complex one.
           ComplexMatrix eig_vec;
           ComplexColumnVector eig_val;
 
           if (have_a_fun)
-            nconv = EigsComplexNonSymmetricFunc 
+            nconv = EigsComplexNonSymmetricFunc
               (eigs_complex_func, n, typ,  sigma, k, p, info, eig_vec, eig_val,
                cresid, octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
           else
             {
               if (a_is_sparse)
-                nconv = EigsComplexNonSymmetricMatrixShift 
+                nconv = EigsComplexNonSymmetricMatrixShift
                   (SparseComplexMatrix (asmm), sigma, k, p, info, eig_vec,
                    eig_val, SparseComplexMatrix (bsmm), permB, cresid,
                    octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
               else
-                nconv = EigsComplexNonSymmetricMatrixShift 
+                nconv = EigsComplexNonSymmetricMatrixShift
                   (ComplexMatrix (amm), sigma, k, p, info, eig_vec,
                    eig_val, ComplexMatrix (bmm), permB, cresid,
                    octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
             }
 
           if (nargout < 2)
             retval (0) = eig_val;
           else
@@ -648,42 +648,42 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
       else
         {
           if (symmetric)
             {
               Matrix eig_vec;
               ColumnVector eig_val;
 
               if (have_a_fun)
-                nconv = EigsRealSymmetricFunc 
+                nconv = EigsRealSymmetricFunc
                   (eigs_func, n, typ, sigmar, k, p, info, eig_vec, eig_val,
-                   resid, octave_stdout, tol, (nargout > 1), cholB, disp, 
+                   resid, octave_stdout, tol, (nargout > 1), cholB, disp,
                    maxit);
               else if (have_sigma)
                 {
                   if (a_is_sparse)
-                    nconv = EigsRealSymmetricMatrixShift 
+                    nconv = EigsRealSymmetricMatrixShift
                       (asmm, sigmar, k, p, info, eig_vec, eig_val, bsmm, permB,
-                       resid, octave_stdout, tol, (nargout > 1), cholB, disp, 
+                       resid, octave_stdout, tol, (nargout > 1), cholB, disp,
                        maxit);
                   else
-                    nconv = EigsRealSymmetricMatrixShift 
+                    nconv = EigsRealSymmetricMatrixShift
                       (amm, sigmar, k, p, info, eig_vec, eig_val, bmm, permB,
                        resid, octave_stdout, tol, (nargout > 1), cholB, disp,
                        maxit);
                 }
               else
                 {
                   if (a_is_sparse)
-                    nconv = EigsRealSymmetricMatrix 
+                    nconv = EigsRealSymmetricMatrix
                       (asmm, typ, k, p, info, eig_vec, eig_val, bsmm, permB,
                        resid, octave_stdout, tol, (nargout > 1), cholB, disp,
                        maxit);
                   else
-                    nconv = EigsRealSymmetricMatrix 
+                    nconv = EigsRealSymmetricMatrix
                       (amm, typ, k, p, info, eig_vec, eig_val, bmm, permB,
                        resid, octave_stdout, tol, (nargout > 1), cholB, disp,
                        maxit);
                 }
 
               if (nargout < 2)
                 retval (0) = eig_val;
               else
@@ -694,42 +694,42 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
                 }
             }
           else
             {
               ComplexMatrix eig_vec;
               ComplexColumnVector eig_val;
 
               if (have_a_fun)
-                nconv = EigsRealNonSymmetricFunc 
+                nconv = EigsRealNonSymmetricFunc
                   (eigs_func, n, typ, sigmar, k, p, info, eig_vec, eig_val,
-                   resid, octave_stdout, tol, (nargout > 1), cholB, disp, 
+                   resid, octave_stdout, tol, (nargout > 1), cholB, disp,
                    maxit);
               else if (have_sigma)
                 {
                   if (a_is_sparse)
-                    nconv = EigsRealNonSymmetricMatrixShift 
+                    nconv = EigsRealNonSymmetricMatrixShift
                       (asmm, sigmar, k, p, info, eig_vec, eig_val, bsmm, permB,
-                       resid, octave_stdout, tol, (nargout > 1), cholB, disp, 
+                       resid, octave_stdout, tol, (nargout > 1), cholB, disp,
                        maxit);
                   else
-                    nconv = EigsRealNonSymmetricMatrixShift 
+                    nconv = EigsRealNonSymmetricMatrixShift
                       (amm, sigmar, k, p, info, eig_vec, eig_val, bmm, permB,
                        resid, octave_stdout, tol, (nargout > 1), cholB, disp,
                        maxit);
                 }
               else
                 {
                   if (a_is_sparse)
-                    nconv = EigsRealNonSymmetricMatrix 
+                    nconv = EigsRealNonSymmetricMatrix
                       (asmm, typ, k, p, info, eig_vec, eig_val, bsmm, permB,
                        resid, octave_stdout, tol, (nargout > 1), cholB, disp,
                        maxit);
                   else
-                    nconv = EigsRealNonSymmetricMatrix 
+                    nconv = EigsRealNonSymmetricMatrix
                       (amm, typ, k, p, info, eig_vec, eig_val, bmm, permB,
                        resid, octave_stdout, tol, (nargout > 1), cholB, disp,
                        maxit);
                 }
 
               if (nargout < 2)
                 retval (0) = eig_val;
               else
@@ -739,17 +739,17 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
                   retval(0) = eig_vec;
                 }
             }
         }
 
       if (nconv <= 0)
         warning ("eigs: None of the %d requested eigenvalues converged", k);
       else if (nconv < k)
-        warning ("eigs: Only %d of the %d requested eigenvalues converged", 
+        warning ("eigs: Only %d of the %d requested eigenvalues converged",
                  nconv, k);
     }
 
   if (! fcn_name.empty ())
     clear_function (fcn_name);
 #else
   error ("eigs: not available in this version of Octave");
 #endif
diff --git a/src/DLD-FUNCTIONS/fft.cc b/src/DLD-FUNCTIONS/fft.cc
--- a/src/DLD-FUNCTIONS/fft.cc
+++ b/src/DLD-FUNCTIONS/fft.cc
@@ -51,17 +51,17 @@ do_fft (const octave_value_list &args, c
       print_usage ();
       return retval;
     }
 
   octave_value arg = args(0);
   dim_vector dims = arg.dims ();
   octave_idx_type n_points = -1;
   int dim = -1;
-  
+
   if (nargin > 1)
     {
       if (! args(1).is_empty ())
         {
           double dval = args(1).double_value ();
           if (xisnan (dval))
             error ("%s: number of points (N) cannot be NaN", fcn);
           else
@@ -259,62 +259,62 @@ dimension of the matrix along which the 
 %%         Comalco Research and Technology
 %%         02 May 2000
 %!test
 %! N=64;
 %! n=4;
 %! t = 2*pi*(0:1:N-1)/N;
 %! s = cos(n*t);
 %! S = fft(s);
-%! 
+%!
 %! answer = zeros (size(t));
 %! answer(n+1) = N/2;
 %! answer(N-n+1) = N/2;
-%! 
+%!
 %! assert(S, answer, 4*N*eps);
 
 %% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
 %%         Comalco Research and Technology
 %%         02 May 2000
 %!test
 %! N=64;
 %! n=7;
 %! t = 2*pi*(0:1:N-1)/N;
 %! s = cos(n*t);
-%! 
+%!
 %! S = zeros (size(t));
 %! S(n+1) = N/2;
 %! S(N-n+1) = N/2;
-%! 
+%!
 %! assert(ifft(S), s, 4*N*eps);
 
 %% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
 %%         Comalco Research and Technology
 %%         02 May 2000
 %!test
 %! N=64;
 %! n=4;
 %! t = single (2*pi*(0:1:N-1)/N);
 %! s = cos(n*t);
 %! S = fft(s);
-%! 
+%!
 %! answer = zeros (size(t),'single');
 %! answer(n+1) = N/2;
 %! answer(N-n+1) = N/2;
-%! 
+%!
 %! assert(S, answer, 4*N*eps('single'));
 
 %% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
 %%         Comalco Research and Technology
 %%         02 May 2000
 %!test
 %! N=64;
 %! n=7;
 %! t = 2*pi*(0:1:N-1)/N;
 %! s = cos(n*t);
-%! 
+%!
 %! S = zeros (size(t),'single');
 %! S(n+1) = N/2;
 %! S(N-n+1) = N/2;
-%! 
+%!
 %! assert(ifft(S), s, 4*N*eps('single'));
 
 */
diff --git a/src/DLD-FUNCTIONS/fft2.cc b/src/DLD-FUNCTIONS/fft2.cc
--- a/src/DLD-FUNCTIONS/fft2.cc
+++ b/src/DLD-FUNCTIONS/fft2.cc
@@ -52,17 +52,17 @@ do_fft2 (const octave_value_list &args, 
     {
       print_usage ();
       return retval;
     }
 
   octave_value arg = args(0);
   dim_vector dims = arg.dims ();
   octave_idx_type n_rows = -1;
-  
+
   if (nargin > 1)
     {
       double dval = args(1).double_value ();
       if (xisnan (dval))
         error ("%s: number of rows (N) cannot be NaN", fcn);
       else
         {
           n_rows = NINTbig (dval);
@@ -209,86 +209,86 @@ of @var{A} is treated separately\n\
 /*
 
 %% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
 %%         Comalco Research and Technology
 %%         02 May 2000
 %!test
 %! M=16;
 %! N=8;
-%! 
+%!
 %! m=5;
 %! n=3;
-%! 
+%!
 %! x = 2*pi*(0:1:M-1)/M;
 %! y = 2*pi*(0:1:N-1)/N;
 %! sx = cos(m*x);
 %! sy = sin(n*y);
 %! s=kron(sx',sy);
 %! S = fft2(s);
 %! answer = kron(fft(sx)',fft(sy));
 %! assert(S, answer, 4*M*N*eps);
 
 %% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
 %%         Comalco Research and Technology
 %%         02 May 2000
 %!test
 %! M=12;
 %! N=7;
-%! 
+%!
 %! m=3;
 %! n=2;
-%! 
+%!
 %! x = 2*pi*(0:1:M-1)/M;
 %! y = 2*pi*(0:1:N-1)/N;
-%! 
+%!
 %! sx = cos(m*x);
 %! sy = cos(n*y);
-%! 
+%!
 %! S = kron(fft(sx)',fft(sy));
 %! answer=kron(sx',sy);
 %! s = ifft2(S);
-%! 
+%!
 %! assert(s, answer, 30*eps);
 
 
 %% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
 %%         Comalco Research and Technology
 %%         02 May 2000
 %!test
 %! M=16;
 %! N=8;
-%! 
+%!
 %! m=5;
 %! n=3;
-%! 
+%!
 %! x = 2*pi*(0:1:M-1)/M;
 %! y = 2*pi*(0:1:N-1)/N;
 %! sx = single(cos(m*x));
 %! sy = single(sin(n*y));
 %! s=kron(sx',sy);
 %! S = fft2(s);
 %! answer = kron(fft(sx)',fft(sy));
 %! assert(S, answer, 4*M*N*eps('single'));
 
 %% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
 %%         Comalco Research and Technology
 %%         02 May 2000
 %!test
 %! M=12;
 %! N=7;
-%! 
+%!
 %! m=3;
 %! n=2;
-%! 
+%!
 %! x = single(2*pi*(0:1:M-1)/M);
 %! y = single(2*pi*(0:1:N-1)/N);
-%! 
+%!
 %! sx = cos(m*x);
 %! sy = cos(n*y);
-%! 
+%!
 %! S = kron(fft(sx)',fft(sy));
 %! answer=kron(sx',sy);
 %! s = ifft2(S);
-%! 
+%!
 %! assert(s, answer, 30*eps('single'));
 
 */
diff --git a/src/DLD-FUNCTIONS/fftn.cc b/src/DLD-FUNCTIONS/fftn.cc
--- a/src/DLD-FUNCTIONS/fftn.cc
+++ b/src/DLD-FUNCTIONS/fftn.cc
@@ -50,17 +50,17 @@ do_fftn (const octave_value_list &args, 
   if (nargin < 1 || nargin > 2)
     {
       print_usage ();
       return retval;
     }
 
   octave_value arg = args(0);
   dim_vector dims = arg.dims ();
-  
+
   for (int i = 0; i < dims.length (); i++)
     if (dims(i) < 0)
       return retval;
 
   if (nargin > 1)
     {
       Matrix val = args(1).matrix_value ();
       if (val.rows () > val.columns ())
diff --git a/src/DLD-FUNCTIONS/fftw.cc b/src/DLD-FUNCTIONS/fftw.cc
--- a/src/DLD-FUNCTIONS/fftw.cc
+++ b/src/DLD-FUNCTIONS/fftw.cc
@@ -127,25 +127,25 @@ they will not be efficient and the point
   if (args(0).is_string ())
     {
       std::string arg0 = args(0).string_value ();
 
       if (!error_state)
         {
           // Use STL function to convert to lower case
           std::transform (arg0.begin (), arg0.end (), arg0.begin (), tolower);
-          
+
           if (nargin == 2)
             {
               std::string arg1 = args(1).string_value ();
               if (!error_state)
                 {
                   if (arg0 == "planner")
                     {
-                      std::transform (arg1.begin (), arg1.end (), 
+                      std::transform (arg1.begin (), arg1.end (),
                                       arg1.begin (), tolower);
                       octave_fftw_planner::FftwMethod meth
                         = octave_fftw_planner::UNKNOWN;
                       octave_float_fftw_planner::FftwMethod methf
                         = octave_float_fftw_planner::UNKNOWN;
 
                       if (arg1 == "estimate")
                         {
@@ -223,17 +223,17 @@ they will not be efficient and the point
                   else
                     error ("unrecognized argument");
                 }
             }
           else
             {
               if (arg0 == "planner")
                 {
-                  octave_fftw_planner::FftwMethod meth = 
+                  octave_fftw_planner::FftwMethod meth =
                     octave_fftw_planner::method ();
 
                   if (meth == octave_fftw_planner::MEASURE)
                     retval = octave_value ("measure");
                   else if (meth == octave_fftw_planner::PATIENT)
                     retval = octave_value ("patient");
                   else if (meth == octave_fftw_planner::EXHAUSTIVE)
                     retval = octave_value ("exhaustive");
diff --git a/src/DLD-FUNCTIONS/filter.cc b/src/DLD-FUNCTIONS/filter.cc
--- a/src/DLD-FUNCTIONS/filter.cc
+++ b/src/DLD-FUNCTIONS/filter.cc
@@ -49,17 +49,17 @@ extern MArray<float>
 filter (MArray<float>&, MArray<float>&, MArray<float>&, int dim);
 
 extern MArray<FloatComplex>
 filter (MArray<FloatComplex>&, MArray<FloatComplex>&, MArray<FloatComplex>&, int dim);
 #endif
 
 template <class T>
 MArray<T>
-filter (MArray<T>& b, MArray<T>& a, MArray<T>& x, MArray<T>& si, 
+filter (MArray<T>& b, MArray<T>& a, MArray<T>& x, MArray<T>& si,
         int dim = 0)
 {
   MArray<T> y;
 
   octave_idx_type a_len  = a.length ();
   octave_idx_type b_len  = b.length ();
 
   octave_idx_type ab_len = a_len > b_len ? a_len : b_len;
@@ -100,20 +100,20 @@ filter (MArray<T>& b, MArray<T>& a, MArr
       return y;
     }
 
   octave_idx_type si_dim = 0;
   for (octave_idx_type i = 0; i < x_dims.length (); i++)
     {
       if (i == dim)
         continue;
-     
+
       if (x_dims(i) == 1)
         continue;
- 
+
       if (si_dims(++si_dim) != x_dims(i))
         {
           error ("filter: dimensionality of SI and X must agree");
           return y;
         }
     }
 
   if (x_len == 0)
@@ -216,17 +216,17 @@ filter (MArray<T>& b, MArray<T>& a, MArr
                 {
                   OCTAVE_QUIT;
 
                   psi[0] = pb[1] * px[idx];
                 }
             }
         }
     }
-  
+
   return y;
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 extern MArray<double>
 filter (MArray<double>&, MArray<double>&, MArray<double>&,
         MArray<double>&, int dim);
 
@@ -249,17 +249,17 @@ filter (MArray<T>& b, MArray<T>& a, MArr
 {
   dim_vector x_dims = x.dims();
 
   if (dim < 0)
     {
       // Find first non-singleton dimension
       while (dim < x_dims.length () && x_dims(dim) <= 1)
         dim++;
-  
+
       // All dimensions singleton, pick first dimension
       if (dim == x_dims.length ())
         dim = 0;
     }
   else
     if (dim < 0 || dim > x_dims.length ())
       {
         error ("filter: filtering over invalid dimension");
@@ -269,17 +269,17 @@ filter (MArray<T>& b, MArray<T>& a, MArr
   octave_idx_type a_len = a.length ();
   octave_idx_type b_len = b.length ();
 
   octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
   dim_vector si_dims = x.dims ();
   for (int i = dim; i > 0; i--)
     si_dims(i) = si_dims(i-1);
   si_dims(0) = si_len;
-  
+
   MArray<T> si (si_dims, T (0.0));
 
   return filter (b, a, x, si, dim);
 }
 
 DEFUN_DLD (filter, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {y =} filter (@var{b}, @var{a}, @var{x})\n\
@@ -404,27 +404,27 @@ H(z) = {\\displaystyle\\sum_{k=0}^M d_{k
         }
     }
   else
     {
       // Find first non-singleton dimension
       dim = 0;
       while (dim < x_dims.length () && x_dims(dim) <= 1)
         dim++;
-  
+
       // All dimensions singleton, pick first dimension
       if (dim == x_dims.length ())
         dim = 0;
     }
 
   bool isfloat = (args(0).is_single_type ()
                   || args(1).is_single_type ()
                   || args(2).is_single_type ()
                   || (nargin >= 4 && args(3).is_single_type ()));
-    
+
   if (args(0).is_complex_type ()
       || args(1).is_complex_type ()
       || args(2).is_complex_type ()
       || (nargin >= 4 && args(3).is_complex_type ()))
     {
       if (isfloat)
         {
           FloatComplexColumnVector b (args(0).float_complex_vector_value ());
diff --git a/src/DLD-FUNCTIONS/find.cc b/src/DLD-FUNCTIONS/find.cc
--- a/src/DLD-FUNCTIONS/find.cc
+++ b/src/DLD-FUNCTIONS/find.cc
@@ -32,17 +32,17 @@ along with Octave; see the file COPYING.
 #include "oct-obj.h"
 
 // Find at most N_TO_FIND nonzero elements in NDA.  Search forward if
 // DIRECTION is 1, backward if it is -1.  NARGOUT is the number of
 // output arguments.  If N_TO_FIND is -1, find all nonzero elements.
 
 template <typename T>
 octave_value_list
-find_nonzero_elem_idx (const Array<T>& nda, int nargout, 
+find_nonzero_elem_idx (const Array<T>& nda, int nargout,
                        octave_idx_type n_to_find, int direction)
 {
   octave_value_list retval ((nargout == 0 ? 1 : nargout), Matrix ());
 
   Array<octave_idx_type> idx;
   if (n_to_find >= 0)
     idx = nda.find (n_to_find, direction == -1);
   else
@@ -78,31 +78,31 @@ find_nonzero_elem_idx (const Array<T>& n
       break;
     }
 
   return retval;
 }
 
 template <typename T>
 octave_value_list
-find_nonzero_elem_idx (const Sparse<T>& v, int nargout, 
+find_nonzero_elem_idx (const Sparse<T>& v, int nargout,
                        octave_idx_type n_to_find, int direction)
 {
   octave_value_list retval ((nargout == 0 ? 1 : nargout), Matrix ());
 
 
   octave_idx_type nc = v.cols();
   octave_idx_type nr = v.rows();
   octave_idx_type nz = v.nnz();
 
   // Search in the default range.
   octave_idx_type start_nc = -1;
   octave_idx_type end_nc = -1;
   octave_idx_type count;
- 
+
   // Search for the range to search
   if (n_to_find < 0)
     {
       start_nc = 0;
       end_nc = nc;
       n_to_find = nz;
       count = nz;
     }
@@ -130,17 +130,17 @@ find_nonzero_elem_idx (const Sparse<T>& 
           if (nz - v.cidx(j-1) >= n_to_find)
             {
               start_nc = j - 1;
               break;
             }
         }
     }
 
-  count = (n_to_find > v.cidx(end_nc) - v.cidx(start_nc) ? 
+  count = (n_to_find > v.cidx(end_nc) - v.cidx(start_nc) ?
            v.cidx(end_nc) - v.cidx(start_nc) : n_to_find);
 
   // If the original argument was a row vector, force a row vector of
   // the overall indices to be returned.  But see below for scalar
   // case...
 
   octave_idx_type result_nr = count;
   octave_idx_type result_nc = 1;
@@ -162,25 +162,25 @@ find_nonzero_elem_idx (const Sparse<T>& 
 
   Array<T> val (dim_vector (result_nr, result_nc));
 
   if (count > 0)
     {
       // Search for elements to return.  Only search the region where
       // there are elements to be found using the count that we want
       // to find.
-      for (octave_idx_type j = start_nc, cx = 0; j < end_nc; j++) 
-        for (octave_idx_type i = v.cidx(j); i < v.cidx(j+1); i++ ) 
+      for (octave_idx_type j = start_nc, cx = 0; j < end_nc; j++)
+        for (octave_idx_type i = v.cidx(j); i < v.cidx(j+1); i++ )
           {
             OCTAVE_QUIT;
             if (direction < 0 && i < nz - count)
               continue;
             i_idx(cx) = static_cast<double> (v.ridx(i) + 1);
             j_idx(cx) = static_cast<double> (j + 1);
-            idx(cx) = j * nr + v.ridx(i) + 1; 
+            idx(cx) = j * nr + v.ridx(i) + 1;
             val(cx) = v.data(i);
             cx++;
             if (cx == count)
               break;
           }
     }
   else if (scalar_arg)
     {
@@ -220,25 +220,25 @@ find_nonzero_elem_idx (const Sparse<T>& 
       panic_impossible ();
       break;
     }
 
   return retval;
 }
 
 octave_value_list
-find_nonzero_elem_idx (const PermMatrix& v, int nargout, 
+find_nonzero_elem_idx (const PermMatrix& v, int nargout,
                        octave_idx_type n_to_find, int direction)
 {
   // There are far fewer special cases to handle for a PermMatrix.
   octave_value_list retval ((nargout == 0 ? 1 : nargout), Matrix ());
 
   octave_idx_type nc = v.cols();
   octave_idx_type start_nc, end_nc, count;
- 
+
   // Determine the range to search.
   if (n_to_find < 0 || n_to_find >= nc)
     {
       start_nc = 0;
       end_nc = nc;
       n_to_find = nc;
       count = nc;
     }
@@ -263,29 +263,29 @@ find_nonzero_elem_idx (const PermMatrix&
   // Every value is 1.
   Array<double> val (dim_vector (count, 1), 1.0);
 
   if (count > 0)
     {
       const octave_idx_type* p = v.data ();
       if (v.is_col_perm ())
         {
-          for (octave_idx_type k = 0; k < count; k++) 
+          for (octave_idx_type k = 0; k < count; k++)
             {
               OCTAVE_QUIT;
               const octave_idx_type j = start_nc + k;
               const octave_idx_type i = p[j];
               i_idx(k) = static_cast<double> (1+i);
               j_idx(k) = static_cast<double> (1+j);
               idx(k) = j * nc + i + 1;
             }
         }
       else
         {
-          for (octave_idx_type k = 0; k < count; k++) 
+          for (octave_idx_type k = 0; k < count; k++)
             {
               OCTAVE_QUIT;
               const octave_idx_type i = start_nc + k;
               const octave_idx_type j = p[i];
               // Scatter into the index arrays according to
               // j adjusted by the start point.
               const octave_idx_type koff = j - start_nc;
               i_idx(koff) = static_cast<double> (1+i);
@@ -450,31 +450,31 @@ b = sparse(i, j, v, sz(1), sz(2));\n\
 
   if (arg.is_bool_type ())
     {
       if (arg.is_sparse_type ())
         {
           SparseBoolMatrix v = arg.sparse_bool_matrix_value ();
 
           if (! error_state)
-            retval = find_nonzero_elem_idx (v, nargout, 
+            retval = find_nonzero_elem_idx (v, nargout,
                                             n_to_find, direction);
         }
       else if (nargout <= 1 && n_to_find == -1 && direction == 1)
         {
           // This case is equivalent to extracting indices from a logical
-          // matrix. Try to reuse the possibly cached index vector. 
+          // matrix. Try to reuse the possibly cached index vector.
           retval(0) = arg.index_vector ().unmask ();
         }
       else
         {
           boolNDArray v = arg.bool_array_value ();
 
           if (! error_state)
-            retval = find_nonzero_elem_idx (v, nargout, 
+            retval = find_nonzero_elem_idx (v, nargout,
                                             n_to_find, direction);
         }
     }
   else if (arg.is_integer_type ())
     {
 #define DO_INT_BRANCH(INTT) \
       else if (arg.is_ ## INTT ## _type ()) \
         { \
@@ -500,28 +500,28 @@ b = sparse(i, j, v, sz(1), sz(2));\n\
     }
   else if (arg.is_sparse_type ())
     {
       if (arg.is_real_type ())
         {
           SparseMatrix v = arg.sparse_matrix_value ();
 
           if (! error_state)
-            retval = find_nonzero_elem_idx (v, nargout, 
+            retval = find_nonzero_elem_idx (v, nargout,
                                             n_to_find, direction);
         }
       else if (arg.is_complex_type ())
         {
           SparseComplexMatrix v = arg.sparse_complex_matrix_value ();
 
           if (! error_state)
-            retval = find_nonzero_elem_idx (v, nargout, 
+            retval = find_nonzero_elem_idx (v, nargout,
                                             n_to_find, direction);
         }
-      else 
+      else
         gripe_wrong_type_arg ("find", arg);
     }
   else if (arg.is_perm_matrix ())
     {
       PermMatrix P = arg.perm_matrix_value ();
 
       if (! error_state)
         retval = find_nonzero_elem_idx (P, nargout, n_to_find, direction);
@@ -575,28 +575,28 @@ b = sparse(i, j, v, sz(1), sz(2));\n\
 /*
 %!assert(find (char ([0, 97])), 2);
 %!assert(find ([1, 0, 1, 0, 1]), [1, 3, 5]);
 %!assert(find ([1; 0; 3; 0; 1]), [1; 3; 5]);
 %!assert(find ([0, 0, 2; 0, 3, 0; -1, 0, 0]), [3; 5; 7]);
 
 %!test
 %! [i, j, v] = find ([0, 0, 2; 0, 3, 0; -1, 0, 0]);
-%! 
+%!
 %! assert(i, [3; 2; 1]);
 %! assert(j, [1; 2; 3]);
 %! assert(v, [-1; 3; 2]);
 
 %!assert(find (single([1, 0, 1, 0, 1])), [1, 3, 5]);
 %!assert(find (single([1; 0; 3; 0; 1])), [1; 3; 5]);
 %!assert(find (single([0, 0, 2; 0, 3, 0; -1, 0, 0])), [3; 5; 7]);
 
 %!test
 %! [i, j, v] = find (single([0, 0, 2; 0, 3, 0; -1, 0, 0]));
-%! 
+%!
 %! assert(i, [3; 2; 1]);
 %! assert(j, [1; 2; 3]);
 %! assert(v, single([-1; 3; 2]));
 
 %!test
 %! pcol = [5 1 4 3 2];
 %! P = eye (5) (:, pcol);
 %! [i, j, v] = find (P);
diff --git a/src/DLD-FUNCTIONS/gammainc.cc b/src/DLD-FUNCTIONS/gammainc.cc
--- a/src/DLD-FUNCTIONS/gammainc.cc
+++ b/src/DLD-FUNCTIONS/gammainc.cc
@@ -110,49 +110,49 @@ gammainc (@var{x}, @var{a}) @equiv{} 1 -
 
               if (! error_state)
                 {
                   if (a_arg.is_scalar_type ())
                     {
                       float a = a_arg.float_value ();
 
                       if (! error_state)
-                        retval = lower ? gammainc (x, a) 
+                        retval = lower ? gammainc (x, a)
                           : static_cast<float>(1) - gammainc (x, a);
                     }
                   else
                     {
                       FloatNDArray a = a_arg.float_array_value ();
 
                       if (! error_state)
-                        retval = lower ? gammainc (x, a) 
+                        retval = lower ? gammainc (x, a)
                           : static_cast<float>(1) - gammainc (x, a);
                     }
                 }
             }
           else
             {
               FloatNDArray x = x_arg.float_array_value ();
 
               if (! error_state)
                 {
                   if (a_arg.is_scalar_type ())
                     {
                       float a = a_arg.float_value ();
 
                       if (! error_state)
-                        retval = lower ? gammainc (x, a) 
+                        retval = lower ? gammainc (x, a)
                           : static_cast<float>(1) - gammainc (x, a);
                     }
                   else
                     {
                       FloatNDArray a = a_arg.float_array_value ();
 
                       if (! error_state)
-                        retval = lower ? gammainc (x, a) 
+                        retval = lower ? gammainc (x, a)
                           : static_cast<float>(1) - gammainc (x, a);
                     }
                 }
             }
         }
       else
         {
           if (x_arg.is_scalar_type ())
@@ -211,20 +211,20 @@ gammainc (@var{x}, @var{a}) @equiv{} 1 -
 
 %!test
 %! a = [.5 .5 .5 .5 .5];
 %! x = [0 1 2 3 4];
 %! v1 = sqrt(pi)*erf(x)./gamma(a);
 %! v3 = gammainc(x.*x,a);
 %! assert(v1, v3, sqrt(eps));
 
-%!assert (gammainc(0:4,0.5,"upper"), 1-gammainc(0:4,0.5),1e-10) 
+%!assert (gammainc(0:4,0.5,"upper"), 1-gammainc(0:4,0.5),1e-10)
 
 %!test
 %! a = single ([.5 .5 .5 .5 .5]);
 %! x = single([0 1 2 3 4]);
 %! v1 = sqrt(pi('single'))*erf(x)./gamma(a);
 %! v3 = gammainc(x.*x,a);
 %! assert(v1, v3, sqrt(eps('single')));
 
-%!assert (gammainc(single(0:4),single(0.5),"upper"), single(1)-gammainc(single(0:4),single(0.5)),single(1e-7)) 
+%!assert (gammainc(single(0:4),single(0.5),"upper"), single(1)-gammainc(single(0:4),single(0.5)),single(1e-7))
 
 */
diff --git a/src/DLD-FUNCTIONS/givens.cc b/src/DLD-FUNCTIONS/givens.cc
--- a/src/DLD-FUNCTIONS/givens.cc
+++ b/src/DLD-FUNCTIONS/givens.cc
@@ -87,17 +87,17 @@ givens (1, 1)\n\
                   if (! error_state)
                     {
                       switch (nargout)
                         {
                         case 0:
                         case 1:
                           retval(0) = result;
                           break;
-   
+
                         case 2:
                           retval(1) = result (0, 1);
                           retval(0) = result (0, 0);
                           break;
 
                         default:
                           error ("givens: invalid number of output arguments");
                           break;
@@ -117,17 +117,17 @@ givens (1, 1)\n\
                   if (! error_state)
                     {
                       switch (nargout)
                         {
                         case 0:
                         case 1:
                           retval(0) = result;
                           break;
-   
+
                         case 2:
                           retval(1) = result (0, 1);
                           retval(0) = result (0, 0);
                           break;
 
                         default:
                           error ("givens: invalid number of output arguments");
                           break;
@@ -150,17 +150,17 @@ givens (1, 1)\n\
                   if (! error_state)
                     {
                       switch (nargout)
                         {
                         case 0:
                         case 1:
                           retval(0) = result;
                           break;
-   
+
                         case 2:
                           retval(1) = result (0, 1);
                           retval(0) = result (0, 0);
                           break;
 
                         default:
                           error ("givens: invalid number of output arguments");
                           break;
@@ -180,17 +180,17 @@ givens (1, 1)\n\
                   if (! error_state)
                     {
                       switch (nargout)
                         {
                         case 0:
                         case 1:
                           retval(0) = result;
                           break;
-   
+
                         case 2:
                           retval(1) = result (0, 1);
                           retval(0) = result (0, 0);
                           break;
 
                         default:
                           error ("givens: invalid number of output arguments");
                           break;
diff --git a/src/DLD-FUNCTIONS/hex2num.cc b/src/DLD-FUNCTIONS/hex2num.cc
--- a/src/DLD-FUNCTIONS/hex2num.cc
+++ b/src/DLD-FUNCTIONS/hex2num.cc
@@ -162,17 +162,17 @@ num2hex ([-1, 1, e, Inf, NaN, NA]);\n\
                 uint64_t ival;
                 double dval;
               } num;
 
               num.dval = *pv++;
 
               for (octave_idx_type j = 0; j < 16; j++)
                 {
-                  unsigned char ch = 
+                  unsigned char ch =
                     static_cast<char> (num.ival >> ((15 - j) * 4) & 0xF);
                   if (ch >= 10)
                     ch += 'a' - 10;
                   else
                     ch += '0';
 
                   m.elem (i, j) = ch;
                 }
diff --git a/src/DLD-FUNCTIONS/inv.cc b/src/DLD-FUNCTIONS/inv.cc
--- a/src/DLD-FUNCTIONS/inv.cc
+++ b/src/DLD-FUNCTIONS/inv.cc
@@ -211,17 +211,17 @@ of a sparse matrix if possible.\n\
       if (nargout > 1)
         retval(1) = isfloat ? octave_value (frcond) : octave_value (rcond);
 
       retval(0) = result;
 
       volatile double xrcond = rcond;
       xrcond += 1.0;
       if (nargout < 2 && (info == -1 || xrcond == 1.0))
-        warning ("inverse: matrix singular to machine precision, rcond = %g", 
+        warning ("inverse: matrix singular to machine precision, rcond = %g",
                  rcond);
     }
 
   return retval;
 }
 
 /*
 
diff --git a/src/DLD-FUNCTIONS/kron.cc b/src/DLD-FUNCTIONS/kron.cc
--- a/src/DLD-FUNCTIONS/kron.cc
+++ b/src/DLD-FUNCTIONS/kron.cc
@@ -94,17 +94,17 @@ kron (const MDiagArray2<R>& a, const MAr
   return c;
 }
 
 template <class T>
 static MSparse<T>
 kron (const MSparse<T>& A, const MSparse<T>& B)
 {
   octave_idx_type idx = 0;
-  MSparse<T> C (A.rows () * B.rows (), A.columns () * B.columns (), 
+  MSparse<T> C (A.rows () * B.rows (), A.columns () * B.columns (),
                 A.nnz () * B.nnz ());
 
   C.cidx (0) = 0;
 
   for (octave_idx_type Aj = 0; Aj < A.columns (); Aj++)
     for (octave_idx_type Bj = 0; Bj < B.columns (); Bj++)
       {
         octave_quit ();
diff --git a/src/DLD-FUNCTIONS/lookup.cc b/src/DLD-FUNCTIONS/lookup.cc
--- a/src/DLD-FUNCTIONS/lookup.cc
+++ b/src/DLD-FUNCTIONS/lookup.cc
@@ -39,17 +39,17 @@ along with Octave; see the file COPYING.
 #include "gripes.h"
 #include "oct-obj.h"
 #include "ov.h"
 
 static
 bool
 contains_char (const std::string& str, char c)
 {
-  return (str.find (c) != std::string::npos 
+  return (str.find (c) != std::string::npos
           || str.find (std::toupper (c)) != std::string::npos);
 }
 
 // case-insensitive character comparison functors
 struct icmp_char_lt : public std::binary_function<char, char, bool>
 {
   bool operator () (char x, char y) const
     { return std::toupper (x) < std::toupper (y); }
@@ -63,57 +63,57 @@ struct icmp_char_gt : public std::binary
 
 // FIXME -- maybe these should go elsewhere?
 // FIXME -- are they even needed now?
 // case-insensitive ascending comparator
 #if 0
 static bool
 stri_comp_lt (const std::string& a, const std::string& b)
 {
-  return std::lexicographical_compare (a.begin (), a.end (), 
+  return std::lexicographical_compare (a.begin (), a.end (),
                                        b.begin (), b.end (),
                                        icmp_char_lt());
 }
 
 // case-insensitive descending comparator
 static bool
 stri_comp_gt (const std::string& a, const std::string& b)
 {
-  return std::lexicographical_compare (a.begin (), a.end (), 
+  return std::lexicographical_compare (a.begin (), a.end (),
                                        b.begin (), b.end (),
                                        icmp_char_gt());
 }
 #endif
 
 template <class T>
-inline sortmode 
+inline sortmode
 get_sort_mode (const Array<T>& array,
                typename octave_sort<T>::compare_fcn_type desc_comp
                = octave_sort<T>::descending_compare)
 {
   octave_idx_type n = array.numel ();
   if (n > 1 && desc_comp (array (0), array (n-1)))
     return DESCENDING;
   else
     return ASCENDING;
 }
 
 // FIXME: perhaps there should be octave_value::lookup?
-// The question is, how should it behave w.r.t. the second argument's type. 
+// The question is, how should it behave w.r.t. the second argument's type.
 // We'd need a dispatch on two arguments. Hmmm...
 
 #define INT_ARRAY_LOOKUP(TYPE) \
   (table.is_ ## TYPE ## _type () && y.is_ ## TYPE ## _type ()) \
     retval = do_numeric_lookup (table.TYPE ## _array_value (), \
                                 y.TYPE ## _array_value (), \
                                 left_inf, right_inf, \
                                 match_idx, match_bool);
 template <class ArrayT>
 static octave_value
-do_numeric_lookup (const ArrayT& array, const ArrayT& values, 
+do_numeric_lookup (const ArrayT& array, const ArrayT& values,
                    bool left_inf, bool right_inf,
                    bool match_idx, bool match_bool)
 {
   octave_value retval;
 
   Array<octave_idx_type> idx = array.lookup (values);
   octave_idx_type n = array.numel (), nval = values.numel ();
 
@@ -136,17 +136,17 @@ do_numeric_lookup (const ArrayT& array, 
           NDArray ridx (idx.dims ());
 
           for (octave_idx_type i = 0; i < nval; i++)
             {
               octave_idx_type j = idx.xelem (i);
               ridx.xelem (i) = (j != 0 && values(i) == array(j-1)) ? j : 0;
             }
 
-          retval = ridx; 
+          retval = ridx;
         }
       else if (left_inf && right_inf)
         {
           // Results in valid indices. Optimize using lazy index.
           octave_idx_type zero = 0;
           for (octave_idx_type i = 0; i < nval; i++)
             {
               octave_idx_type j = idx.xelem (i) - 1;
@@ -228,17 +228,17 @@ For numeric lookups\n\
 the leftmost subinterval shall be extended to infinity (i.e., all indices\n\
 at least 1)\n\
 \n\
 @item r\n\
 For numeric lookups\n\
 the rightmost subinterval shall be extended to infinity (i.e., all indices\n\
 at most n-1).\n\
 @end table\n\
-@end deftypefn") 
+@end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3 || (nargin == 3 && ! args(2).is_string ()))
     {
       print_usage ();
@@ -277,22 +277,22 @@ at most n-1).\n\
   else if (match_idx && match_bool)
     error ("lookup: only one of m or b can be specified");
   else if (str_case && (left_inf || right_inf))
     error ("lookup: l, r are not recognized for string lookups");
 
   if (error_state)
     return retval;
 
-  if (num_case) 
+  if (num_case)
     {
 
       // In the case of a complex array, absolute values will be used for compatibility
       // (though it's not too meaningful).
-      
+
       if (table.is_complex_type ())
         table = table.abs ();
 
       if (y.is_complex_type ())
         y = y.abs ();
 
       Array<octave_idx_type> idx;
 
@@ -342,17 +342,17 @@ at most n-1).\n\
           for (octave_idx_type i = 0; i < nval; i++)
             {
               octave_idx_type j = idx.xelem (i);
               match.xelem (i) = j != 0 && str_y(i) == str_table(j-1);
             }
 
           retval = match;
         }
-      else if (match_idx) 
+      else if (match_idx)
         {
           NDArray ridx (idx.dims ());
           if (match_idx)
             {
               for (octave_idx_type i = 0; i < nval; i++)
                 {
                   octave_idx_type j = idx.xelem (i);
                   ridx.xelem (i) = (j != 0 && str_y(i) == str_table(j-1)) ? j : 0;
@@ -364,17 +364,17 @@ at most n-1).\n\
       else
         retval = idx;
     }
   else
     print_usage ();
 
   return retval;
 
-}  
+}
 
 /*
 %!assert (lookup(1:3, 0.5), 0)     # value before table
 %!assert (lookup(1:3, 3.5), 3)     # value after table error
 %!assert (lookup(1:3, 1.5), 1)     # value within table error
 %!assert (lookup(1:3, [3,2,1]), [3,2,1])
 %!assert (lookup([1:4]', [1.2, 3.5]'), [1, 3]');
 %!assert (lookup([1:4], [1.2, 3.5]'), [1, 3]');
diff --git a/src/DLD-FUNCTIONS/lsode.cc b/src/DLD-FUNCTIONS/lsode.cc
--- a/src/DLD-FUNCTIONS/lsode.cc
+++ b/src/DLD-FUNCTIONS/lsode.cc
@@ -134,17 +134,17 @@ lsode_user_jacobian (const ColumnVector&
         gripe_user_supplied_eval ("lsode");
     }
 
   return retval;
 }
 
 #define LSODE_ABORT() \
   return retval
- 
+
 #define LSODE_ABORT1(msg) \
   do \
     { \
       ::error ("lsode: " msg); \
       LSODE_ABORT (); \
     } \
   while (0)
 
@@ -308,17 +308,17 @@ parameters for @code{lsode}.\n\
                 {
                   fcn_name = unique_symbol_name ("__lsode_fcn__");
                   fname = "function y = ";
                   fname.append (fcn_name);
                   fname.append (" (x, t) y = ");
                   lsode_fcn = extract_function
                     (c(0), "lsode", fcn_name, fname, "; endfunction");
                 }
-              
+
               if (lsode_fcn)
                 {
                   if (c(1).is_function_handle () || c(1).is_inline_function ())
                     lsode_jac = c(1).function_value ();
                   else
                     {
                         jac_name = unique_symbol_name ("__lsode_jac__");
                         jname = "function jac = ";
@@ -490,56 +490,56 @@ parameters for @code{lsode}.\n\
 %%
 %% Solution
 %%
 %%    y1(t) = cos(t)
 %%    y2(t) = sin(t)
 %!function xdot = f (x, t)
 %!  xdot = [-x(2); x(1)];
 %!test
-%! 
+%!
 %! x0 = [1; 0];
 %! xdot0 = [0; 1];
 %! t = (0:1:10)';
-%! 
+%!
 %! tol = 500 * lsode_options ("relative tolerance");
-%! 
-%! 
+%!
+%!
 %! x = lsode ("f", x0, t);
-%! 
+%!
 %! y = [cos(t), sin(t)];
-%! 
+%!
 %! assert(all (all (abs (x - y) < tol)));
 
 %!function xdotdot = f (x, t)
 %!  xdotdot = [x(2); -x(1)];
 %!test
-%! 
+%!
 %! x0 = [1; 0];
 %! t = [0; 2*pi];
 %! tol = 100 * dassl_options ("relative tolerance");
-%! 
+%!
 %! x = lsode ("f", x0, t);
-%! 
+%!
 %! y = [1, 0; 1, 0];
-%! 
+%!
 %! assert(all (all (abs (x - y) < tol)));
 
 %!function xdot = f (x, t)
 %!  xdot = x;
 %!test
-%! 
+%!
 %! x0 = 1;
 %! t = [0; 1];
 %! tol = 100 * dassl_options ("relative tolerance");
-%! 
+%!
 %! x = lsode ("f", x0, t);
-%! 
+%!
 %! y = [1; e];
-%! 
+%!
 %! assert(all (all (abs (x - y) < tol)));
 
 %!test
 %! lsode_options ("absolute tolerance", eps);
 %! assert(lsode_options ("absolute tolerance") == eps);
 
 %!error <Invalid call to lsode_options.*> lsode_options ("foo", 1, 2);
 
diff --git a/src/DLD-FUNCTIONS/lu.cc b/src/DLD-FUNCTIONS/lu.cc
--- a/src/DLD-FUNCTIONS/lu.cc
+++ b/src/DLD-FUNCTIONS/lu.cc
@@ -139,17 +139,17 @@ For both full and sparse matrices, @code
 information.\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
   bool issparse = (nargin > 0 && args(0).is_sparse_type ());
   bool scale = (nargout  == 5);
 
-  if (nargin < 1 || (issparse && (nargin > 3 || nargout > 5)) 
+  if (nargin < 1 || (issparse && (nargin > 3 || nargout > 5))
       || (!issparse && (nargin > 2 || nargout > 3)))
     {
       print_usage ();
       return retval;
     }
 
   bool vecout = false;
   Matrix thres;
@@ -226,38 +226,38 @@ information.\n\
                 SparseLU fact (m, Qinit, thres, false, true);
 
                 if (nargout < 2)
                   retval (0) = fact.Y ();
                 else
                   {
                     PermMatrix P = fact.Pr_mat ();
                     SparseMatrix L = P.transpose () * fact.L ();
-                    retval(1) = octave_value (fact.U (), 
+                    retval(1) = octave_value (fact.U (),
                                               MatrixType (MatrixType::Upper));
 
-                    retval(0) = octave_value (L, 
-                        MatrixType (MatrixType::Permuted_Lower, 
+                    retval(0) = octave_value (L,
+                        MatrixType (MatrixType::Permuted_Lower,
                                     nr, fact.row_perm ()));
                   }
               }
               break;
 
             case 3:
               {
                 SparseLU fact (m, Qinit, thres, false, true);
 
                 if (vecout)
                   retval (2) = fact.Pr_vec ();
                 else
                   retval(2) = fact.Pr_mat ();
 
-                retval(1) = octave_value (fact.U (), 
+                retval(1) = octave_value (fact.U (),
                                           MatrixType (MatrixType::Upper));
-                retval(0) = octave_value (fact.L (), 
+                retval(0) = octave_value (fact.L (),
                                           MatrixType (MatrixType::Lower));
               }
               break;
 
             case 4:
             default:
               {
                 SparseLU fact (m, thres, scale);
@@ -270,19 +270,19 @@ information.\n\
                     retval(3) = fact.Pc_vec ();
                     retval(2) = fact.Pr_vec ();
                   }
                 else
                   {
                     retval(3) = fact.Pc_mat ();
                     retval(2) = fact.Pr_mat ();
                   }
-                retval(1) = octave_value (fact.U (), 
+                retval(1) = octave_value (fact.U (),
                                           MatrixType (MatrixType::Upper));
-                retval(0) = octave_value (fact.L (), 
+                retval(0) = octave_value (fact.L (),
                                           MatrixType (MatrixType::Lower));
               }
               break;
             }
         }
       else if (arg.is_complex_type ())
         {
           SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
@@ -296,38 +296,38 @@ information.\n\
                 SparseComplexLU fact (m, Qinit, thres, false, true);
 
                 if (nargout < 2)
                   retval (0) = fact.Y ();
                 else
                   {
                     PermMatrix P = fact.Pr_mat ();
                     SparseComplexMatrix L = P.transpose () * fact.L ();
-                    retval(1) = octave_value (fact.U (), 
+                    retval(1) = octave_value (fact.U (),
                                               MatrixType (MatrixType::Upper));
 
-                    retval(0) = octave_value (L, 
-                        MatrixType (MatrixType::Permuted_Lower, 
+                    retval(0) = octave_value (L,
+                        MatrixType (MatrixType::Permuted_Lower,
                                     nr, fact.row_perm ()));
                   }
               }
               break;
 
             case 3:
               {
                 SparseComplexLU fact (m, Qinit, thres, false, true);
 
                 if (vecout)
                   retval (2) = fact.Pr_vec ();
                 else
                   retval(2) = fact.Pr_mat ();
 
-                retval(1) = octave_value (fact.U (), 
+                retval(1) = octave_value (fact.U (),
                                           MatrixType (MatrixType::Upper));
-                retval(0) = octave_value (fact.L (), 
+                retval(0) = octave_value (fact.L (),
                                           MatrixType (MatrixType::Lower));
               }
               break;
 
             case 4:
             default:
               {
                 SparseComplexLU fact (m, thres, scale);
@@ -340,19 +340,19 @@ information.\n\
                     retval(3) = fact.Pc_vec ();
                     retval(2) = fact.Pr_vec ();
                   }
                 else
                   {
                     retval(3) = fact.Pc_mat ();
                     retval(2) = fact.Pr_mat ();
                   }
-                retval(1) = octave_value (fact.U (), 
+                retval(1) = octave_value (fact.U (),
                                           MatrixType (MatrixType::Upper));
-                retval(0) = octave_value (fact.L (), 
+                retval(0) = octave_value (fact.L (),
                                           MatrixType (MatrixType::Lower));
               }
               break;
             }
         }
       else
         gripe_wrong_type_arg ("lu", arg);
     }
@@ -652,35 +652,35 @@ recompute the factorization from scratch
     }
 
   octave_value argl = args(0);
   octave_value argu = args(1);
   octave_value argp = pivoted ? args(2) : octave_value ();
   octave_value argx = args(2 + pivoted);
   octave_value argy = args(3 + pivoted);
 
-  if (argl.is_numeric_type () && argu.is_numeric_type () 
+  if (argl.is_numeric_type () && argu.is_numeric_type ()
       && argx.is_numeric_type () && argy.is_numeric_type ()
       && (! pivoted || argp.is_perm_matrix ()))
     {
       if (check_lu_dims (argl, argu, argp))
         {
-          PermMatrix P = (pivoted 
-                          ? argp.perm_matrix_value () 
+          PermMatrix P = (pivoted
+                          ? argp.perm_matrix_value ()
                           : PermMatrix::eye (argl.rows ()));
 
-          if (argl.is_real_type () 
-              && argu.is_real_type () 
-              && argx.is_real_type () 
+          if (argl.is_real_type ()
+              && argu.is_real_type ()
+              && argx.is_real_type ()
               && argy.is_real_type ())
             {
               // all real case
-              if (argl.is_single_type () 
-                  || argu.is_single_type () 
-                  || argx.is_single_type () 
+              if (argl.is_single_type ()
+                  || argu.is_single_type ()
+                  || argx.is_single_type ()
                   || argy.is_single_type ())
                 {
                   FloatMatrix L = argl.float_matrix_value ();
                   FloatMatrix U = argu.float_matrix_value ();
                   FloatMatrix x = argx.float_matrix_value ();
                   FloatMatrix y = argy.float_matrix_value ();
 
                   FloatLU fact (L, U, P);
@@ -711,32 +711,32 @@ recompute the factorization from scratch
                     retval(2) = fact.P ();
                   retval(1) = get_lu_u (fact);
                   retval(0) = get_lu_l (fact);
                 }
             }
           else
             {
               // complex case
-              if (argl.is_single_type () 
-                  || argu.is_single_type () 
-                  || argx.is_single_type () 
+              if (argl.is_single_type ()
+                  || argu.is_single_type ()
+                  || argx.is_single_type ()
                   || argy.is_single_type ())
                 {
                   FloatComplexMatrix L = argl.float_complex_matrix_value ();
                   FloatComplexMatrix U = argu.float_complex_matrix_value ();
                   FloatComplexMatrix x = argx.float_complex_matrix_value ();
                   FloatComplexMatrix y = argy.float_complex_matrix_value ();
 
                   FloatComplexLU fact (L, U, P);
                   if (pivoted)
                     fact.update_piv (x, y);
                   else
                     fact.update (x, y);
-              
+
                   if (pivoted)
                     retval(2) = fact.P ();
                   retval(1) = get_lu_u (fact);
                   retval(0) = get_lu_l (fact);
                 }
               else
                 {
                   ComplexMatrix L = argl.complex_matrix_value ();
@@ -744,17 +744,17 @@ recompute the factorization from scratch
                   ComplexMatrix x = argx.complex_matrix_value ();
                   ComplexMatrix y = argy.complex_matrix_value ();
 
                   ComplexLU fact (L, U, P);
                   if (pivoted)
                     fact.update_piv (x, y);
                   else
                     fact.update (x, y);
-              
+
                   if (pivoted)
                     retval(2) = fact.P ();
                   retval(1) = get_lu_u (fact);
                   retval(0) = get_lu_l (fact);
                 }
             }
         }
       else
@@ -769,20 +769,20 @@ recompute the factorization from scratch
 /*
 %!shared A, u, v, Ac, uc, vc
 %! A = [0.091364  0.613038  0.999083;
 %!      0.594638  0.425302  0.603537;
 %!      0.383594  0.291238  0.085574;
 %!      0.265712  0.268003  0.238409;
 %!      0.669966  0.743851  0.445057 ];
 %!
-%! u = [0.85082;  
-%!      0.76426;  
-%!      0.42883;  
-%!      0.53010;  
+%! u = [0.85082;
+%!      0.76426;
+%!      0.42883;
+%!      0.53010;
 %!      0.80683 ];
 %!
 %! v = [0.98810;
 %!      0.24295;
 %!      0.43167 ];
 %!
 %! Ac = [0.620405 + 0.956953i  0.480013 + 0.048806i  0.402627 + 0.338171i;
 %!      0.589077 + 0.658457i  0.013205 + 0.279323i  0.229284 + 0.721929i;
@@ -802,58 +802,58 @@ recompute the factorization from scratch
 %!
 
 %!testif HAVE_QRUPDATE_LUU
 %! [L,U,P] = lu(A);
 %! [L,U] = luupdate(L,U,P*u,v);
 %! assert(norm(vec(tril(L)-L),Inf) == 0)
 %! assert(norm(vec(triu(U)-U),Inf) == 0)
 %! assert(norm(vec(P'*L*U - A - u*v.'),Inf) < norm(A)*1e1*eps)
-%! 
+%!
 %!testif HAVE_QRUPDATE_LUU
 %! [L,U,P] = lu(Ac);
 %! [L,U] = luupdate(L,U,P*uc,vc);
 %! assert(norm(vec(tril(L)-L),Inf) == 0)
 %! assert(norm(vec(triu(U)-U),Inf) == 0)
 %! assert(norm(vec(P'*L*U - Ac - uc*vc.'),Inf) < norm(Ac)*1e1*eps)
 
 %!testif HAVE_QRUPDATE_LUU
 %! [L,U,P] = lu(single(A));
 %! [L,U] = luupdate(L,U,P*single(u),single(v));
 %! assert(norm(vec(tril(L)-L),Inf) == 0)
 %! assert(norm(vec(triu(U)-U),Inf) == 0)
 %! assert(norm(vec(P'*L*U - single(A) - single(u)*single(v).'),Inf) < norm(single(A))*1e1*eps('single'))
-%! 
+%!
 %!testif HAVE_QRUPDATE_LUU
 %! [L,U,P] = lu(single(Ac));
 %! [L,U] = luupdate(L,U,P*single(uc),single(vc));
 %! assert(norm(vec(tril(L)-L),Inf) == 0)
 %! assert(norm(vec(triu(U)-U),Inf) == 0)
 %! assert(norm(vec(P'*L*U - single(Ac) - single(uc)*single(vc).'),Inf) < norm(single(Ac))*1e1*eps('single'))
 
 %!testif HAVE_QRUPDATE_LUU
 %! [L,U,P] = lu(A);
 %! [L,U,P] = luupdate(L,U,P,u,v);
 %! assert(norm(vec(tril(L)-L),Inf) == 0)
 %! assert(norm(vec(triu(U)-U),Inf) == 0)
 %! assert(norm(vec(P'*L*U - A - u*v.'),Inf) < norm(A)*1e1*eps)
-%! 
+%!
 %!testif HAVE_QRUPDATE_LUU
 %! [L,U,P] = lu(Ac);
 %! [L,U,P] = luupdate(L,U,P,uc,vc);
 %! assert(norm(vec(tril(L)-L),Inf) == 0)
 %! assert(norm(vec(triu(U)-U),Inf) == 0)
 %! assert(norm(vec(P'*L*U - Ac - uc*vc.'),Inf) < norm(Ac)*1e1*eps)
 
 %!testif HAVE_QRUPDATE_LUU
 %! [L,U,P] = lu(single(A));
 %! [L,U,P] = luupdate(L,U,P,single(u),single(v));
 %! assert(norm(vec(tril(L)-L),Inf) == 0)
 %! assert(norm(vec(triu(U)-U),Inf) == 0)
 %! assert(norm(vec(P'*L*U - single(A) - single(u)*single(v).'),Inf) < norm(single(A))*1e1*eps('single'))
-%! 
+%!
 %!testif HAVE_QRUPDATE_LUU
 %! [L,U,P] = lu(single(Ac));
 %! [L,U,P] = luupdate(L,U,P,single(uc),single(vc));
 %! assert(norm(vec(tril(L)-L),Inf) == 0)
 %! assert(norm(vec(triu(U)-U),Inf) == 0)
 %! assert(norm(vec(P'*L*U - single(Ac) - single(uc)*single(vc).'),Inf) < norm(single(Ac))*1e1*eps('single'))
 */
diff --git a/src/DLD-FUNCTIONS/luinc.cc b/src/DLD-FUNCTIONS/luinc.cc
--- a/src/DLD-FUNCTIONS/luinc.cc
+++ b/src/DLD-FUNCTIONS/luinc.cc
@@ -187,17 +187,17 @@ Given the string argument 'vector', @cod
         }
 
       // FIXME Add code for zero-level factorization
       if (zero_level)
         error ("luinc: zero-level factorization not implemented");
 
       if (!error_state)
         {
-          if (args(0).type_name () == "sparse matrix") 
+          if (args(0).type_name () == "sparse matrix")
             {
               SparseMatrix sm = args(0).sparse_matrix_value ();
               octave_idx_type sm_nr = sm.rows ();
               octave_idx_type sm_nc = sm.cols ();
               ColumnVector Qinit (sm_nc);
 
               for (octave_idx_type i = 0; i < sm_nc; i++)
                 Qinit (i) = i;
@@ -214,18 +214,18 @@ Given the string argument 'vector', @cod
                                        milu, udiag);
 
                         if (! error_state)
                           {
                             SparseMatrix P = fact.Pr ();
                             SparseMatrix L = P.transpose () * fact.L ();
                             retval(1) = octave_value (fact.U (),
                                                       MatrixType (MatrixType::Upper));
-                            retval(0) = octave_value (L, MatrixType 
-                                                      (MatrixType::Permuted_Lower, 
+                            retval(0) = octave_value (L, MatrixType
+                                                      (MatrixType::Permuted_Lower,
                                                        sm_nr, fact.row_perm ()));
                           }
                       }
                       break;
 
                     case 3:
                       {
                         SparseLU fact (sm, Qinit, thresh, false, true, droptol,
@@ -268,47 +268,47 @@ Given the string argument 'vector', @cod
                             retval(0) = octave_value (fact.L (),
                                                       MatrixType (MatrixType::Lower));
                           }
                       }
                       break;
                     }
                 }
             }
-          else if (args(0).type_name () == "sparse complex matrix") 
+          else if (args(0).type_name () == "sparse complex matrix")
             {
-              SparseComplexMatrix sm = 
+              SparseComplexMatrix sm =
                 args(0).sparse_complex_matrix_value ();
               octave_idx_type sm_nr = sm.rows ();
               octave_idx_type sm_nc = sm.cols ();
               ColumnVector Qinit (sm_nc);
 
               for (octave_idx_type i = 0; i < sm_nc; i++)
                 Qinit (i) = i;
 
               if (! error_state)
                 {
                   switch (nargout)
                     {
                     case 0:
                     case 1:
                     case 2:
                       {
-                        SparseComplexLU fact (sm, Qinit, thresh, false, true, 
+                        SparseComplexLU fact (sm, Qinit, thresh, false, true,
                                               droptol, milu, udiag);
 
 
                         if (! error_state)
                           {
                             SparseMatrix P = fact.Pr ();
                             SparseComplexMatrix L = P.transpose () * fact.L ();
                             retval(1) = octave_value (fact.U (),
                                                       MatrixType (MatrixType::Upper));
-                            retval(0) = octave_value (L, MatrixType 
-                                                      (MatrixType::Permuted_Lower, 
+                            retval(0) = octave_value (L, MatrixType
+                                                      (MatrixType::Permuted_Lower,
                                                        sm_nr, fact.row_perm ()));
                           }
                       }
                       break;
 
                     case 3:
                       {
                         SparseComplexLU fact (sm, Qinit, thresh, false, true,
diff --git a/src/DLD-FUNCTIONS/matrix_type.cc b/src/DLD-FUNCTIONS/matrix_type.cc
--- a/src/DLD-FUNCTIONS/matrix_type.cc
+++ b/src/DLD-FUNCTIONS/matrix_type.cc
@@ -137,23 +137,23 @@ LU@tie{}factorization.  Once the matrix 
             retval = args(0);
         }
       else if (args(0).is_sparse_type ())
         {
           if (nargin == 1)
             {
               MatrixType mattyp;
 
-              if (args(0).is_complex_type ()) 
+              if (args(0).is_complex_type ())
                 {
                   mattyp = args(0).matrix_type ();
 
                   if (mattyp.is_unknown () && autocomp )
                     {
-                      SparseComplexMatrix m = 
+                      SparseComplexMatrix m =
                         args(0).sparse_complex_matrix_value ();
                       if (!error_state)
                         {
                           mattyp = MatrixType (m);
                           args(0).matrix_type (mattyp);
                         }
                     }
                 }
@@ -213,17 +213,17 @@ LU@tie{}factorization.  Once the matrix 
               // Ok, we're changing the matrix type
               std::string str_typ = args(1).string_value ();
 
               // FIXME -- why do I have to explicitly call the constructor?
               MatrixType mattyp = MatrixType ();
 
               octave_idx_type nl = 0;
               octave_idx_type nu = 0;
-              
+
               if (error_state)
                 error ("matrix_type: TYPE must be a string");
               else
                 {
                   // Use STL function to convert to lower case
                   std::transform (str_typ.begin (), str_typ.end (),
                                   str_typ.begin (), tolower);
 
@@ -247,17 +247,17 @@ LU@tie{}factorization.  Once the matrix 
                           if (error_state)
                             error ("matrix_type: band size must be integer");
                           else
                             {
                               if (nl == 1 && nu == 1)
                                 mattyp.mark_as_tridiagonal ();
                               else
                                 mattyp.mark_as_banded (nu, nl);
-                              
+
                               if (str_typ == "banded positive definite")
                                 mattyp.mark_as_symmetric ();
                             }
                         }
                     }
                   else if (str_typ == "positive definite")
                     {
                       mattyp.mark_as_full ();
@@ -271,55 +271,55 @@ LU@tie{}factorization.  Once the matrix 
                     mattyp.invalidate_type ();
                   else
                     error ("matrix_type: Unknown matrix type %s", str_typ.c_str());
 
                   if (! error_state)
                     {
                       if (nargin == 3 && (str_typ == "upper" || str_typ == "lower"))
                         {
-                          const ColumnVector perm = 
+                          const ColumnVector perm =
                             ColumnVector (args (2).vector_value ());
 
                           if (error_state)
                             error ("matrix_type: Invalid permutation vector PERM");
                           else
                             {
                               octave_idx_type len = perm.length ();
                               dim_vector dv = args(0).dims ();
-                              
+
                               if (len != dv(0))
                                 error ("matrix_type: Invalid permutation vector PERM");
                               else
                                 {
                                   OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
 
                                   for (octave_idx_type i = 0; i < len; i++)
-                                    p[i] = static_cast<octave_idx_type> (perm (i)) - 1; 
+                                    p[i] = static_cast<octave_idx_type> (perm (i)) - 1;
 
                                   if (str_typ == "upper")
                                     mattyp.mark_as_permuted (len, p);
                                   else
                                     mattyp.mark_as_permuted (len, p);
                                 }
                             }
                         }
                       else if (nargin != 2 && str_typ != "banded positive definite" &&
                                str_typ != "banded")
                         error ("matrix_type: Invalid number of arguments");
 
                       if (! error_state)
                         {
                           // Set the matrix type
                           if (args(0).is_complex_type ())
-                            retval = 
-                              octave_value (args(0).sparse_complex_matrix_value (), 
+                            retval =
+                              octave_value (args(0).sparse_complex_matrix_value (),
                                             mattyp);
                           else
-                            retval = octave_value (args(0).sparse_matrix_value (), 
+                            retval = octave_value (args(0).sparse_matrix_value (),
                                                    mattyp);
                         }
                     }
                 }
             }
         }
       else
         {
@@ -435,37 +435,37 @@ LU@tie{}factorization.  Once the matrix 
                     mattyp.mark_as_full ();
                   else if (str_typ == "unknown")
                     mattyp.invalidate_type ();
                   else
                     error ("matrix_type: Unknown matrix type %s", str_typ.c_str());
 
                   if (! error_state)
                     {
-                      if (nargin == 3 && (str_typ == "upper" 
+                      if (nargin == 3 && (str_typ == "upper"
                                           || str_typ == "lower"))
                         {
-                          const ColumnVector perm = 
+                          const ColumnVector perm =
                             ColumnVector (args (2).vector_value ());
 
                           if (error_state)
                             error ("matrix_type: Invalid permutation vector PERM");
                           else
                             {
                               octave_idx_type len = perm.length ();
                               dim_vector dv = args(0).dims ();
-                              
+
                               if (len != dv(0))
                                 error ("matrix_type: Invalid permutation vector PERM");
                               else
                                 {
                                   OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
 
                                   for (octave_idx_type i = 0; i < len; i++)
-                                    p[i] = static_cast<octave_idx_type> (perm (i)) - 1; 
+                                    p[i] = static_cast<octave_idx_type> (perm (i)) - 1;
 
                                   if (str_typ == "upper")
                                     mattyp.mark_as_permuted (len, p);
                                   else
                                     mattyp.mark_as_permuted (len, p);
                                 }
                             }
                         }
@@ -473,52 +473,52 @@ LU@tie{}factorization.  Once the matrix 
                         error ("matrix_type: Invalid number of arguments");
 
                       if (! error_state)
                         {
                           // Set the matrix type
                           if (args(0).is_single_type ())
                             {
                               if (args(0).is_complex_type())
-                                retval = octave_value 
-                                  (args(0).float_complex_matrix_value (), 
+                                retval = octave_value
+                                  (args(0).float_complex_matrix_value (),
                                    mattyp);
                               else
-                                retval = octave_value 
-                                  (args(0).float_matrix_value (), 
+                                retval = octave_value
+                                  (args(0).float_matrix_value (),
                                    mattyp);
                             }
                           else
                             {
                               if (args(0).is_complex_type())
-                                retval = octave_value 
-                                  (args(0).complex_matrix_value (), 
+                                retval = octave_value
+                                  (args(0).complex_matrix_value (),
                                    mattyp);
                               else
-                                retval = octave_value 
-                                  (args(0).matrix_value (), 
+                                retval = octave_value
+                                  (args(0).matrix_value (),
                                    mattyp);
                             }
                         }
                     }
                 }
             }
         }
     }
 
   return retval;
 }
 
 /*
 
 ## FIXME
-## Disable tests for lower under-determined and upper over-determined 
+## Disable tests for lower under-determined and upper over-determined
 ## matrices as this detection is disabled in MatrixType due to issues
 ## of non minimum norm solution being found.
- 
+
 %!assert(matrix_type(speye(10,10)),"Diagonal");
 %!assert(matrix_type(speye(10,10)([2:10,1],:)),"Permuted Diagonal");
 %!assert(matrix_type([[speye(10,10);sparse(1,10)],[1;sparse(9,1);1]]),"Upper");
 %!assert(matrix_type([[speye(10,10);sparse(1,10)],[1;sparse(9,1);1]](:,[2,1,3:11])),"Permuted Upper");
 %!assert(matrix_type([speye(10,10),sparse(10,1);1,sparse(1,9),1]),"Lower");
 %!assert(matrix_type([speye(10,10),sparse(10,1);1,sparse(1,9),1]([2,1,3:11],:)),"Permuted Lower");
 %!test
 %! bnd=spparms("bandden");
@@ -593,25 +593,25 @@ LU@tie{}factorization.  Once the matrix 
 %!test
 %! a = matrix_type(spdiags(randn(10,3),[-1,0,1],10,10),"Singular");
 %! assert(matrix_type(a),"Singular");
 
 %!assert(matrix_type(triu(ones(10,10))),"Upper");
 %!assert(matrix_type(triu(ones(10,10),-1)),"Full");
 %!assert(matrix_type(tril(ones(10,10))),"Lower");
 %!assert(matrix_type(tril(ones(10,10),1)),"Full");
-%!assert(matrix_type(10*eye(10,10) + ones(10,10)), "Positive Definite"); 
+%!assert(matrix_type(10*eye(10,10) + ones(10,10)), "Positive Definite");
 %!assert(matrix_type(ones(11,10)),"Rectangular")
 %!test
 %! a = matrix_type(ones(10,10),"Singular");
 %! assert(matrix_type(a),"Singular");
 
 %!assert(matrix_type(triu(1i*ones(10,10))),"Upper");
 %!assert(matrix_type(triu(1i*ones(10,10),-1)),"Full");
 %!assert(matrix_type(tril(1i*ones(10,10))),"Lower");
 %!assert(matrix_type(tril(1i*ones(10,10),1)),"Full");
-%!assert(matrix_type(10*eye(10,10) + 1i*triu(ones(10,10),1) -1i*tril(ones(10,10),-1)), "Positive Definite"); 
+%!assert(matrix_type(10*eye(10,10) + 1i*triu(ones(10,10),1) -1i*tril(ones(10,10),-1)), "Positive Definite");
 %!assert(matrix_type(ones(11,10)),"Rectangular")
 %!test
 %! a = matrix_type(ones(10,10),"Singular");
 %! assert(matrix_type(a),"Singular");
 
 */
diff --git a/src/DLD-FUNCTIONS/max.cc b/src/DLD-FUNCTIONS/max.cc
--- a/src/DLD-FUNCTIONS/max.cc
+++ b/src/DLD-FUNCTIONS/max.cc
@@ -252,27 +252,27 @@ do_minmax_body (const octave_value_list&
       octave_value argx = args(0), argy = args(1);
       builtin_type_t xtyp = argx.builtin_type (), ytyp = argy.builtin_type ();
       builtin_type_t rtyp = btyp_mixed_numeric (xtyp, ytyp);
 
       switch (rtyp)
         {
         case btyp_double:
           {
-            if ((argx.is_sparse_type () 
+            if ((argx.is_sparse_type ()
                  && (argy.is_sparse_type () || argy.is_scalar_type ()))
                 || (argy.is_sparse_type () && argx.is_scalar_type ()))
               retval = do_minmax_bin_op<SparseMatrix> (argx, argy, ismin);
             else
               retval = do_minmax_bin_op<NDArray> (argx, argy, ismin);
             break;
           }
         case btyp_complex:
           {
-            if ((argx.is_sparse_type () 
+            if ((argx.is_sparse_type ()
                  && (argy.is_sparse_type () || argy.is_scalar_type ()))
                 || (argy.is_sparse_type () && argx.is_scalar_type ()))
               retval = do_minmax_bin_op<SparseComplexMatrix> (argx, argy, ismin);
             else
               retval = do_minmax_bin_op<ComplexNDArray> (argx, argy, ismin);
             break;
           }
         case btyp_float:
@@ -427,22 +427,22 @@ maximum value(s).  Thus,\n\
 @end group\n\
 @end example\n\
 @seealso{min, cummax, cummin}\n\
 @end deftypefn")
 {
   return do_minmax_body (args, nargout, false);
 }
 
-/* 
+/*
 
 %% test/octave.test/arith/max-1.m
 %!assert (max ([1, 4, 2, 3]) == 4);
 %!assert (max ([1; -10; 5; -2]) == 5);
- 
+
 %% test/octave.test/arith/max-2.m
 %!assert(all (max ([4, i 4.999; -2, 2, 3+4i]) == [4, 2, 3+4i]));
 
 %% test/octave.test/arith/max-3.m
 %!error <Invalid call to max.*> max ();
 
 %% test/octave.test/arith/max-4.m
 %!error <Invalid call to max.*> max (1, 2, 3, 4);
diff --git a/src/DLD-FUNCTIONS/md5sum.cc b/src/DLD-FUNCTIONS/md5sum.cc
--- a/src/DLD-FUNCTIONS/md5sum.cc
+++ b/src/DLD-FUNCTIONS/md5sum.cc
@@ -52,17 +52,17 @@ string @var{str}.\n\
     print_usage();
   else
     {
       bool have_str = false;
       std::string str = args(0).string_value();
 
       if (nargin == 2)
         have_str = args(1).bool_value();
-        
+
       if (!error_state)
         {
           if (have_str)
             retval = oct_md5 (str);
           else
             {
               file_stat fs (str);
 
diff --git a/src/DLD-FUNCTIONS/onCleanup.cc b/src/DLD-FUNCTIONS/onCleanup.cc
--- a/src/DLD-FUNCTIONS/onCleanup.cc
+++ b/src/DLD-FUNCTIONS/onCleanup.cc
@@ -38,21 +38,21 @@ static void gripe_internal (void)
 }
 
 class octave_oncleanup : public octave_base_value, octave_auto_shlib
 {
 public:
   octave_oncleanup (void) : fcn () { }
   octave_oncleanup (const octave_value& fcn);
 
-  octave_base_value *clone (void) const 
-    { 
+  octave_base_value *clone (void) const
+    {
       if (fcn.is_defined ())
         gripe_internal ();
-      return empty_clone (); 
+      return empty_clone ();
     }
 
   octave_base_value *empty_clone (void) const { return new octave_oncleanup (); }
 
   ~octave_oncleanup (void);
 
   bool is_defined (void) const { return true; }
 
@@ -66,17 +66,17 @@ public:
   dim_vector dims (void) const { static dim_vector dv (1, 1); return dv; }
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
-  bool load_binary (std::istream& is, bool swap, 
+  bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
@@ -131,17 +131,17 @@ octave_oncleanup::~octave_oncleanup (voi
 
   // Clear interrupts.
   frame.protect_var (octave_interrupt_state);
   octave_interrupt_state = 0;
 
   // Disallow quit().
   frame.protect_var (quit_allowed);
   quit_allowed = false;
-  
+
   // Clear errors.
   frame.protect_var (error_state);
   error_state = 0;
 
   try
     {
       // Run the actual code.
       fcn.do_multi_index_op (0, octave_value_list ());
@@ -167,85 +167,85 @@ octave_oncleanup::~octave_oncleanup (voi
   // Otherwise, set it back to what it was before.
   if (error_state)
     {
       frame.discard_top ();
       octave_call_stack::backtrace_error_message ();
     }
 }
 
-octave_scalar_map 
+octave_scalar_map
 octave_oncleanup::scalar_map_value (void) const
 {
   octave_scalar_map retval;
   retval.setfield ("task", fcn);
   return retval;
 }
 
-static void 
+static void
 warn_save_load (void)
 {
   warning ("onCleanup: load and save not supported");
 }
 
-bool 
+bool
 octave_oncleanup::save_ascii (std::ostream& /* os */)
 {
   warn_save_load ();
   return true;
 }
 
-bool 
+bool
 octave_oncleanup::load_ascii (std::istream& /* is */)
 {
   warn_save_load ();
   return true;
 }
 
-bool 
+bool
 octave_oncleanup::save_binary (std::ostream& /* os */, bool& /* save_as_floats */)
 {
   warn_save_load ();
   return true;
 }
 
 
-bool 
-octave_oncleanup::load_binary (std::istream& /* is */, bool /* swap */, 
+bool
+octave_oncleanup::load_binary (std::istream& /* is */, bool /* swap */,
                                oct_mach_info::float_format /* fmt */)
 {
   warn_save_load ();
   return true;
 }
 
 #if defined (HAVE_HDF5)
-bool 
-octave_oncleanup::save_hdf5 (hid_t /* loc_id */, const char * /* name */, 
+bool
+octave_oncleanup::save_hdf5 (hid_t /* loc_id */, const char * /* name */,
                              bool /* save_as_floats */)
 {
   warn_save_load ();
   return true;
 }
 
-bool 
+bool
 octave_oncleanup::load_hdf5 (hid_t /* loc_id */, const char * /* name */)
 {
   warn_save_load ();
   return true;
 }
 #endif
 
-void 
+void
 octave_oncleanup::print (std::ostream& os, bool pr_as_read_syntax) const
 {
   print_raw (os, pr_as_read_syntax);
   newline (os);
 }
 
-void 
+void
 octave_oncleanup::print_raw (std::ostream& os, bool pr_as_read_syntax) const
 {
   os << "onCleanup (";
   if (fcn.is_defined ())
     fcn.print_raw (os, pr_as_read_syntax);
   os << ")";
 }
 
diff --git a/src/DLD-FUNCTIONS/qr.cc b/src/DLD-FUNCTIONS/qr.cc
--- a/src/DLD-FUNCTIONS/qr.cc
+++ b/src/DLD-FUNCTIONS/qr.cc
@@ -229,17 +229,17 @@ x = @var{R} \\ @var{C}\n\
                 {
                   economy = true;
                   have_b = (nargin > 2 ? 2 : 0);
                 }
             }
           if (have_b > 0 && args(have_b).is_complex_type ())
             is_cmplx = true;
         }
-        
+
       if (!error_state)
         {
           if (have_b && nargout < 2)
             error ("qr: incorrect number of output arguments");
           else if (is_cmplx)
             {
               SparseComplexQR q (arg.sparse_complex_matrix_value ());
               if (!error_state)
@@ -452,51 +452,51 @@ x = @var{R} \\ @var{C}\n\
 
   return retval;
 }
 
 /*
 
 %!test
 %! a = [0, 2, 1; 2, 1, 2];
-%! 
+%!
 %! [q, r] = qr (a);
-%! 
+%!
 %! [qe, re] = qr (a, 0);
-%! 
+%!
 %! assert (q * r, a, sqrt (eps));
 %! assert (qe * re, a, sqrt (eps));
 
 %!test
 %! a = [0, 2, 1; 2, 1, 2];
-%! 
+%!
 %! [q, r, p] = qr (a);  # not giving right dimensions. FIXME
-%! 
+%!
 %! [qe, re, pe] = qr (a, 0);
-%! 
+%!
 %! assert (q * r, a * p, sqrt (eps));
 %! assert (qe * re, a(:, pe), sqrt (eps));
 
 %!test
 %! a = [0, 2; 2, 1; 1, 2];
-%! 
+%!
 %! [q, r] = qr (a);
-%! 
+%!
 %! [qe, re] = qr (a, 0);
-%! 
+%!
 %! assert (q * r, a, sqrt (eps));
 %! assert (qe * re, a, sqrt (eps));
 
 %!test
 %! a = [0, 2; 2, 1; 1, 2];
-%! 
+%!
 %! [q, r, p] = qr (a);
-%! 
+%!
 %! [qe, re, pe] = qr (a, 0);
-%! 
+%!
 %! assert (q * r, a * p, sqrt (eps));
 %! assert (qe * re, a(:, pe), sqrt (eps));
 
 %!error <Invalid call to qr.*> qr ();
 %!error <Invalid call to qr.*> qr ([1, 2; 3, 4], 0, 2);
 
 %!function retval = testqr (q, r, a, p)
 %!  tol = 100*eps (class(q));
@@ -512,170 +512,170 @@ x = @var{R} \\ @var{C}\n\
 %!      n2 = norm (q*r-a(:,p));
 %!      retval = (retval && n2 < tol);
 %!    else
 %!      n2 = norm (q*r - a*p);
 %!      retval = (retval && n2 < tol);
 %!    endif
 %!  endif
 %!test
-%! 
+%!
 %! t = ones (24, 1);
 %! j = 1;
-%! 
+%!
 %! if false # eliminate big matrix tests
 %!   a = rand(5000,20);
 %!   [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
 %!   [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
 %!   [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
 %!   [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
-%! 
+%!
 %!   a = a+1i*eps;
 %!   [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
 %!   [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
 %!   [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
 %!   [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
 %! endif
-%! 
+%!
 %! a = [ ones(1,15); sqrt(eps)*eye(15) ];
 %! [q,r]=qr(a); t(j++) = testqr(q,r,a);
 %! [q,r]=qr(a'); t(j++) = testqr(q,r,a');
 %! [q,r,p]=qr(a); t(j++) = testqr(q,r,a,p);
 %! [q,r,p]=qr(a'); t(j++) = testqr(q,r,a',p);
-%! 
+%!
 %! a = a+1i*eps;
 %! [q,r]=qr(a); t(j++) = testqr(q,r,a);
 %! [q,r]=qr(a'); t(j++) = testqr(q,r,a');
 %! [q,r,p]=qr(a); t(j++) = testqr(q,r,a,p);
 %! [q,r,p]=qr(a'); t(j++) = testqr(q,r,a',p);
-%! 
+%!
 %! a = [ ones(1,15); sqrt(eps)*eye(15) ];
 %! [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
 %! [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
 %! [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
 %! [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
-%! 
+%!
 %! a = a+1i*eps;
 %! [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
 %! [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
 %! [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
 %! [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
-%! 
+%!
 %! a = [
 %! 611   196  -192   407    -8   -52   -49    29
 %! 196   899   113  -192   -71   -43    -8   -44
 %! -192   113   899   196    61    49     8    52
 %! 407  -192   196   611     8    44    59   -23
 %! -8   -71    61     8   411  -599   208   208
 %! -52   -43    49    44  -599   411   208   208
 %! -49    -8     8    59   208   208    99  -911
 %! 29   -44    52   -23   208   208  -911    99
 %! ];
 %! [q,r] = qr(a);
-%! 
+%!
 %! assert(all (t) && norm(q*r-a) < 5000*eps);
 
 %!test
 %! a = single ([0, 2, 1; 2, 1, 2]);
-%! 
+%!
 %! [q, r] = qr (a);
-%! 
+%!
 %! [qe, re] = qr (a, 0);
-%! 
+%!
 %! assert (q * r, a, sqrt (eps ('single')));
 %! assert (qe * re, a, sqrt (eps ('single')));
 
 %!test
 %! a = single([0, 2, 1; 2, 1, 2]);
-%! 
+%!
 %! [q, r, p] = qr (a);  # not giving right dimensions. FIXME
-%! 
+%!
 %! [qe, re, pe] = qr (a, 0);
-%! 
+%!
 %! assert (q * r, a * p, sqrt (eps('single')));
 %! assert (qe * re, a(:, pe), sqrt (eps('single')));
 
 %!test
 %! a = single([0, 2; 2, 1; 1, 2]);
-%! 
+%!
 %! [q, r] = qr (a);
-%! 
+%!
 %! [qe, re] = qr (a, 0);
-%! 
+%!
 %! assert (q * r, a, sqrt (eps('single')));
 %! assert (qe * re, a, sqrt (eps('single')));
 
 %!test
 %! a = single([0, 2; 2, 1; 1, 2]);
-%! 
+%!
 %! [q, r, p] = qr (a);
-%! 
+%!
 %! [qe, re, pe] = qr (a, 0);
-%! 
+%!
 %! assert (q * r, a * p, sqrt (eps('single')));
 %! assert (qe * re, a(:, pe), sqrt (eps('single')));
 
 %!error <Invalid call to qr.*> qr ();
 %!error <Invalid call to qr.*> qr ([1, 2; 3, 4], 0, 2);
 
 %!test
-%! 
+%!
 %! t = ones (24, 1);
 %! j = 1;
-%! 
+%!
 %! if false # eliminate big matrix tests
 %!   a = rand(5000,20);
 %!   [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
 %!   [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
 %!   [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
 %!   [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
-%! 
+%!
 %!   a = a+1i*eps('single');
 %!   [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
 %!   [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
 %!   [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
 %!   [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
 %! endif
-%! 
+%!
 %! a = [ ones(1,15); sqrt(eps('single'))*eye(15) ];
 %! [q,r]=qr(a); t(j++) = testqr(q,r,a);
 %! [q,r]=qr(a'); t(j++) = testqr(q,r,a');
 %! [q,r,p]=qr(a); t(j++) = testqr(q,r,a,p);
 %! [q,r,p]=qr(a'); t(j++) = testqr(q,r,a',p);
-%! 
+%!
 %! a = a+1i*eps('single');
 %! [q,r]=qr(a); t(j++) = testqr(q,r,a);
 %! [q,r]=qr(a'); t(j++) = testqr(q,r,a');
 %! [q,r,p]=qr(a); t(j++) = testqr(q,r,a,p);
 %! [q,r,p]=qr(a'); t(j++) = testqr(q,r,a',p);
-%! 
+%!
 %! a = [ ones(1,15); sqrt(eps('single'))*eye(15) ];
 %! [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
 %! [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
 %! [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
 %! [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
-%! 
+%!
 %! a = a+1i*eps('single');
 %! [q,r]=qr(a,0); t(j++) = testqr(q,r,a);
 %! [q,r]=qr(a',0); t(j++) = testqr(q,r,a');
 %! [q,r,p]=qr(a,0); t(j++) = testqr(q,r,a,p);
 %! [q,r,p]=qr(a',0); t(j++) = testqr(q,r,a',p);
-%! 
+%!
 %! a = [
 %! 611   196  -192   407    -8   -52   -49    29
 %! 196   899   113  -192   -71   -43    -8   -44
 %! -192   113   899   196    61    49     8    52
 %! 407  -192   196   611     8    44    59   -23
 %! -8   -71    61     8   411  -599   208   208
 %! -52   -43    49    44  -599   411   208   208
 %! -49    -8     8    59   208   208    99  -911
 %! 29   -44    52   -23   208   208  -911    99
 %! ];
 %! [q,r] = qr(a);
-%! 
+%!
 %! assert(all (t) && norm(q*r-a) < 5000*eps('single'));
 
 %% The deactivated tests below can't be tested till rectangular back-subs is
 %% implemented for sparse matrices.
 
 %!testif HAVE_CXSPARSE
 %! n = 20; d= 0.2;
 %! a = sprandn(n,n,d)+speye(n,n);
@@ -754,20 +754,20 @@ static
 bool check_qr_dims (const octave_value& q, const octave_value& r,
                     bool allow_ecf = false)
 {
   octave_idx_type m = q.rows (), k = r.rows (), n = r.columns ();
   return ((q.ndims () == 2 && r.ndims () == 2 && k == q.columns ())
             && (m == k || (allow_ecf && k == n && k < m)));
 }
 
-static 
+static
 bool check_index (const octave_value& i, bool vector_allowed = false)
 {
-  return ((i.is_real_type () || i.is_integer_type ()) 
+  return ((i.is_real_type () || i.is_integer_type ())
           && (i.is_scalar_type () || vector_allowed));
 }
 
 DEFUN_DLD (qrupdate, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{Q1}, @var{R1}] =} qrupdate (@var{Q}, @var{R}, @var{u}, @var{v})\n\
 Given a QR@tie{}factorization of a real or complex matrix\n\
 @w{@var{A} = @var{Q}*@var{R}}, @var{Q}@tie{}unitary and\n\
@@ -793,30 +793,30 @@ The QR@tie{}factorization supplied may b
       return retval;
     }
 
   octave_value argq = args(0);
   octave_value argr = args(1);
   octave_value argu = args(2);
   octave_value argv = args(3);
 
-  if (argq.is_numeric_type () && argr.is_numeric_type () 
+  if (argq.is_numeric_type () && argr.is_numeric_type ()
       && argu.is_numeric_type () && argv.is_numeric_type ())
     {
       if (check_qr_dims (argq, argr, true))
         {
-          if (argq.is_real_type () 
-              && argr.is_real_type () 
-              && argu.is_real_type () 
+          if (argq.is_real_type ()
+              && argr.is_real_type ()
+              && argu.is_real_type ()
               && argv.is_real_type ())
             {
               // all real case
-              if (argq.is_single_type () 
-                  || argr.is_single_type () 
-                  || argu.is_single_type () 
+              if (argq.is_single_type ()
+                  || argr.is_single_type ()
+                  || argu.is_single_type ()
                   || argv.is_single_type ())
                 {
                   FloatMatrix Q = argq.float_matrix_value ();
                   FloatMatrix R = argr.float_matrix_value ();
                   FloatMatrix u = argu.float_matrix_value ();
                   FloatMatrix v = argv.float_matrix_value ();
 
                   FloatQR fact (Q, R);
@@ -837,42 +837,42 @@ The QR@tie{}factorization supplied may b
 
                   retval(1) = get_qr_r (fact);
                   retval(0) = fact.Q ();
                 }
             }
           else
             {
               // complex case
-              if (argq.is_single_type () 
-                  || argr.is_single_type () 
-                  || argu.is_single_type () 
+              if (argq.is_single_type ()
+                  || argr.is_single_type ()
+                  || argu.is_single_type ()
                   || argv.is_single_type ())
                 {
                   FloatComplexMatrix Q = argq.float_complex_matrix_value ();
                   FloatComplexMatrix R = argr.float_complex_matrix_value ();
                   FloatComplexMatrix u = argu.float_complex_matrix_value ();
                   FloatComplexMatrix v = argv.float_complex_matrix_value ();
 
                   FloatComplexQR fact (Q, R);
                   fact.update (u, v);
-              
+
                   retval(1) = get_qr_r (fact);
                   retval(0) = fact.Q ();
                 }
               else
                 {
                   ComplexMatrix Q = argq.complex_matrix_value ();
                   ComplexMatrix R = argr.complex_matrix_value ();
                   ComplexMatrix u = argu.complex_matrix_value ();
                   ComplexMatrix v = argv.complex_matrix_value ();
 
                   ComplexQR fact (Q, R);
                   fact.update (u, v);
-              
+
                   retval(1) = get_qr_r (fact);
                   retval(0) = fact.Q ();
                 }
             }
         }
       else
         error ("qrupdate: Q and R dimensions don't match");
     }
@@ -884,20 +884,20 @@ The QR@tie{}factorization supplied may b
 /*
 %!shared A, u, v, Ac, uc, vc
 %! A = [0.091364  0.613038  0.999083;
 %!      0.594638  0.425302  0.603537;
 %!      0.383594  0.291238  0.085574;
 %!      0.265712  0.268003  0.238409;
 %!      0.669966  0.743851  0.445057 ];
 %!
-%! u = [0.85082;  
-%!      0.76426;  
-%!      0.42883;  
-%!      0.53010;  
+%! u = [0.85082;
+%!      0.76426;
+%!      0.42883;
+%!      0.53010;
 %!      0.80683 ];
 %!
 %! v = [0.98810;
 %!      0.24295;
 %!      0.43167 ];
 %!
 %! Ac = [0.620405 + 0.956953i  0.480013 + 0.048806i  0.402627 + 0.338171i;
 %!      0.589077 + 0.658457i  0.013205 + 0.279323i  0.229284 + 0.721929i;
@@ -917,31 +917,31 @@ The QR@tie{}factorization supplied may b
 %!
 
 %!test
 %! [Q,R] = qr(A);
 %! [Q,R] = qrupdate(Q,R,u,v);
 %! assert(norm(vec(Q'*Q - eye(5)),Inf) < 1e1*eps)
 %! assert(norm(vec(triu(R)-R),Inf) == 0)
 %! assert(norm(vec(Q*R - A - u*v'),Inf) < norm(A)*1e1*eps)
-%! 
+%!
 %!test
 %! [Q,R] = qr(Ac);
 %! [Q,R] = qrupdate(Q,R,uc,vc);
 %! assert(norm(vec(Q'*Q - eye(5)),Inf) < 1e1*eps)
 %! assert(norm(vec(triu(R)-R),Inf) == 0)
 %! assert(norm(vec(Q*R - Ac - uc*vc'),Inf) < norm(Ac)*1e1*eps)
 
 %!test
 %! [Q,R] = qr(single(A));
 %! [Q,R] = qrupdate(Q,R,single(u),single(v));
 %! assert(norm(vec(Q'*Q - eye(5,'single')),Inf) < 1e1*eps('single'))
 %! assert(norm(vec(triu(R)-R),Inf) == 0)
 %! assert(norm(vec(Q*R - single(A) - single(u)*single(v)'),Inf) < norm(single(A))*1e1*eps('single'))
-%! 
+%!
 %!test
 %! [Q,R] = qr(single(Ac));
 %! [Q,R] = qrupdate(Q,R,single(uc),single(vc));
 %! assert(norm(vec(Q'*Q - eye(5,'single')),Inf) < 1e1*eps('single'))
 %! assert(norm(vec(triu(R)-R),Inf) == 0)
 %! assert(norm(vec(Q*R - single(Ac) - single(uc)*single(vc)'),Inf) < norm(single(Ac))*1e1*eps('single'))
 */
 
@@ -977,115 +977,115 @@ If @var{orient} is @code{\"row\"}, full 
   octave_idx_type nargin = args.length ();
   octave_value_list retval;
 
   if (nargin < 4 || nargin > 5)
     {
       print_usage ();
       return retval;
     }
-  
+
   octave_value argq = args(0);
   octave_value argr = args(1);
   octave_value argj = args(2);
   octave_value argx = args(3);
-      
+
   if (argq.is_numeric_type () && argr.is_numeric_type ()
       && argx.is_numeric_type ()
       && (nargin < 5 || args(4).is_string ()))
     {
       std::string orient = (nargin < 5) ? "col" : args(4).string_value ();
 
       bool col = orient == "col";
 
       if (col || orient == "row")
-        if (check_qr_dims (argq, argr, col) 
+        if (check_qr_dims (argq, argr, col)
             && (col || argx.rows () == 1))
           {
             if (check_index (argj, col))
               {
                 MArray<octave_idx_type> j
                   = argj.octave_idx_type_vector_value ();
 
                 octave_idx_type one = 1;
 
-                if (argq.is_real_type () 
-                    && argr.is_real_type () 
+                if (argq.is_real_type ()
+                    && argr.is_real_type ()
                     && argx.is_real_type ())
                   {
                     // real case
-                    if (argq.is_single_type () 
-                        || argr.is_single_type () 
+                    if (argq.is_single_type ()
+                        || argr.is_single_type ()
                         || argx.is_single_type ())
                       {
                         FloatMatrix Q = argq.float_matrix_value ();
                         FloatMatrix R = argr.float_matrix_value ();
                         FloatMatrix x = argx.float_matrix_value ();
 
                         FloatQR fact (Q, R);
 
-                        if (col) 
+                        if (col)
                           fact.insert_col (x, j-one);
-                        else 
+                        else
                           fact.insert_row (x.row (0), j(0)-one);
 
                         retval(1) = get_qr_r (fact);
                         retval(0) = fact.Q ();
 
                       }
                     else
                       {
                         Matrix Q = argq.matrix_value ();
                         Matrix R = argr.matrix_value ();
                         Matrix x = argx.matrix_value ();
 
                         QR fact (Q, R);
 
-                        if (col) 
+                        if (col)
                           fact.insert_col (x, j-one);
-                        else 
+                        else
                           fact.insert_row (x.row (0), j(0)-one);
 
                         retval(1) = get_qr_r (fact);
                         retval(0) = fact.Q ();
 
                       }
                   }
                 else
                   {
                     // complex case
-                    if (argq.is_single_type () 
-                        || argr.is_single_type () 
+                    if (argq.is_single_type ()
+                        || argr.is_single_type ()
                         || argx.is_single_type ())
                       {
                         FloatComplexMatrix Q = argq.float_complex_matrix_value ();
                         FloatComplexMatrix R = argr.float_complex_matrix_value ();
                         FloatComplexMatrix x = argx.float_complex_matrix_value ();
 
                         FloatComplexQR fact (Q, R);
 
-                        if (col) 
+                        if (col)
                           fact.insert_col (x, j-one);
-                        else 
+                        else
                           fact.insert_row (x.row (0), j(0)-one);
 
                         retval(1) = get_qr_r (fact);
                         retval(0) = fact.Q ();
                       }
                     else
                       {
                         ComplexMatrix Q = argq.complex_matrix_value ();
                         ComplexMatrix R = argr.complex_matrix_value ();
                         ComplexMatrix x = argx.complex_matrix_value ();
 
                         ComplexQR fact (Q, R);
 
-                        if (col) 
+                        if (col)
                           fact.insert_col (x, j-one);
-                        else 
+                        else
                           fact.insert_row (x.row (0), j(0)-one);
 
                         retval(1) = get_qr_r (fact);
                         retval(0) = fact.Q ();
                       }
                   }
 
               }
@@ -1230,34 +1230,34 @@ If @var{orient} is @code{\"row\"}, full 
                     if (argq.is_single_type ()
                         || argr.is_single_type ())
                       {
                         FloatMatrix Q = argq.float_matrix_value ();
                         FloatMatrix R = argr.float_matrix_value ();
 
                         FloatQR fact (Q, R);
 
-                        if (col) 
+                        if (col)
                           fact.delete_col (j-one);
-                        else 
+                        else
                           fact.delete_row (j(0)-one);
 
                         retval(1) = get_qr_r (fact);
                         retval(0) = fact.Q ();
                       }
                     else
                       {
                         Matrix Q = argq.matrix_value ();
                         Matrix R = argr.matrix_value ();
 
                         QR fact (Q, R);
 
-                        if (col) 
+                        if (col)
                           fact.delete_col (j-one);
-                        else 
+                        else
                           fact.delete_row (j(0)-one);
 
                         retval(1) = get_qr_r (fact);
                         retval(0) = fact.Q ();
                       }
                   }
                 else
                   {
@@ -1265,34 +1265,34 @@ If @var{orient} is @code{\"row\"}, full 
                     if (argq.is_single_type ()
                         || argr.is_single_type ())
                       {
                         FloatComplexMatrix Q = argq.float_complex_matrix_value ();
                         FloatComplexMatrix R = argr.float_complex_matrix_value ();
 
                         FloatComplexQR fact (Q, R);
 
-                        if (col) 
+                        if (col)
                           fact.delete_col (j-one);
-                        else 
+                        else
                           fact.delete_row (j(0)-one);
 
                         retval(1) = get_qr_r (fact);
                         retval(0) = fact.Q ();
                       }
                     else
                       {
                         ComplexMatrix Q = argq.complex_matrix_value ();
                         ComplexMatrix R = argr.complex_matrix_value ();
 
                         ComplexQR fact (Q, R);
 
-                        if (col) 
+                        if (col)
                           fact.delete_col (j-one);
-                        else 
+                        else
                           fact.delete_row (j(0)-one);
 
                         retval(1) = get_qr_r (fact);
                         retval(0) = fact.Q ();
                       }
                   }
               }
             else
@@ -1304,31 +1304,31 @@ If @var{orient} is @code{\"row\"}, full 
       else
         error ("qrdelete: ORIENT must be \"col\" or \"row\"");
     }
   else
     print_usage ();
 
   return retval;
 }
- 
+
 /*
 %!test
 %! AA = [0.091364  0.613038  0.027504  0.999083;
 %!       0.594638  0.425302  0.562834  0.603537;
 %!       0.383594  0.291238  0.742073  0.085574;
 %!       0.265712  0.268003  0.783553  0.238409;
 %!       0.669966  0.743851  0.457255  0.445057 ];
 %!
 %! [Q,R] = qr(AA);
 %! [Q,R] = qrdelete(Q,R,3);
 %! assert(norm(vec(Q'*Q - eye(5)),Inf) < 16*eps)
 %! assert(norm(vec(triu(R)-R),Inf) == 0)
 %! assert(norm(vec(Q*R - [AA(:,1:2) AA(:,4)]),Inf) < norm(AA)*1e1*eps)
-%! 
+%!
 %!test
 %! AA = [0.364554 + 0.993117i  0.669818 + 0.510234i  0.426568 + 0.041337i  0.847051 + 0.233291i;
 %!       0.049600 + 0.242783i  0.448946 + 0.484022i  0.141155 + 0.074420i  0.446746 + 0.392706i;
 %!       0.581922 + 0.657416i  0.581460 + 0.030016i  0.219909 + 0.447288i  0.201144 + 0.069132i;
 %!       0.694986 + 0.000571i  0.682327 + 0.841712i  0.807537 + 0.166086i  0.192767 + 0.358098i;
 %!       0.945002 + 0.066788i  0.350492 + 0.642638i  0.579629 + 0.048102i  0.600170 + 0.636938i ] * I;
 %!
 %! [Q,R] = qr(AA);
@@ -1344,17 +1344,17 @@ If @var{orient} is @code{\"row\"}, full 
 %!       0.265712  0.268003  0.783553  0.238409;
 %!       0.669966  0.743851  0.457255  0.445057 ];
 %!
 %! [Q,R] = qr(AA);
 %! [Q,R] = qrdelete(Q,R,3,'row');
 %! assert(norm(vec(Q'*Q - eye(4)),Inf) < 1e1*eps)
 %! assert(norm(vec(triu(R)-R),Inf) == 0)
 %! assert(norm(vec(Q*R - [AA(1:2,:);AA(4:5,:)]),Inf) < norm(AA)*1e1*eps)
-%! 
+%!
 %!test
 %! AA = [0.364554 + 0.993117i  0.669818 + 0.510234i  0.426568 + 0.041337i  0.847051 + 0.233291i;
 %!       0.049600 + 0.242783i  0.448946 + 0.484022i  0.141155 + 0.074420i  0.446746 + 0.392706i;
 %!       0.581922 + 0.657416i  0.581460 + 0.030016i  0.219909 + 0.447288i  0.201144 + 0.069132i;
 %!       0.694986 + 0.000571i  0.682327 + 0.841712i  0.807537 + 0.166086i  0.192767 + 0.358098i;
 %!       0.945002 + 0.066788i  0.350492 + 0.642638i  0.579629 + 0.048102i  0.600170 + 0.636938i ] * I;
 %!
 %! [Q,R] = qr(AA);
@@ -1370,17 +1370,17 @@ If @var{orient} is @code{\"row\"}, full 
 %!              0.265712  0.268003  0.783553  0.238409;
 %!              0.669966  0.743851  0.457255  0.445057 ]);
 %!
 %! [Q,R] = qr(AA);
 %! [Q,R] = qrdelete(Q,R,3);
 %! assert(norm(vec(Q'*Q - eye(5,'single')),Inf) < 1e1*eps('single'))
 %! assert(norm(vec(triu(R)-R),Inf) == 0)
 %! assert(norm(vec(Q*R - [AA(:,1:2) AA(:,4)]),Inf) < norm(AA)*1e1*eps('single'))
-%! 
+%!
 %!test
 %! AA = single([0.364554 + 0.993117i  0.669818 + 0.510234i  0.426568 + 0.041337i  0.847051 + 0.233291i;
 %!              0.049600 + 0.242783i  0.448946 + 0.484022i  0.141155 + 0.074420i  0.446746 + 0.392706i;
 %!              0.581922 + 0.657416i  0.581460 + 0.030016i  0.219909 + 0.447288i  0.201144 + 0.069132i;
 %!              0.694986 + 0.000571i  0.682327 + 0.841712i  0.807537 + 0.166086i  0.192767 + 0.358098i;
 %!              0.945002 + 0.066788i  0.350492 + 0.642638i  0.579629 + 0.048102i  0.600170 + 0.636938i ]) * I;
 %!
 %! [Q,R] = qr(AA);
@@ -1409,17 +1409,17 @@ If @var{orient} is @code{\"row\"}, full 
 %!              0.265712  0.268003  0.783553  0.238409;
 %!              0.669966  0.743851  0.457255  0.445057 ]);
 %!
 %! [Q,R] = qr(AA);
 %! [Q,R] = qrdelete(Q,R,3,'row');
 %! assert(norm(vec(Q'*Q - eye(4,'single')),Inf) < 1e1*eps('single'))
 %! assert(norm(vec(triu(R)-R),Inf) == 0)
 %! assert(norm(vec(Q*R - [AA(1:2,:);AA(4:5,:)]),Inf) < norm(AA)*1e1*eps('single'))
-%! 
+%!
 %!test
 %! AA = single([0.364554 + 0.993117i  0.669818 + 0.510234i  0.426568 + 0.041337i  0.847051 + 0.233291i;
 %!              0.049600 + 0.242783i  0.448946 + 0.484022i  0.141155 + 0.074420i  0.446746 + 0.392706i;
 %!              0.581922 + 0.657416i  0.581460 + 0.030016i  0.219909 + 0.447288i  0.201144 + 0.069132i;
 %!              0.694986 + 0.000571i  0.682327 + 0.841712i  0.807537 + 0.166086i  0.192767 + 0.358098i;
 %!              0.945002 + 0.066788i  0.350492 + 0.642638i  0.579629 + 0.048102i  0.600170 + 0.636938i ]) * I;
 %!
 %! [Q,R] = qr(AA);
@@ -1461,21 +1461,21 @@ of @w{@var{A}(:,p)}, where @w{p} is the 
     {
       if (check_qr_dims (argq, argr, true))
         {
           if (check_index (argi) && check_index (argj))
             {
               octave_idx_type i = argi.int_value ();
               octave_idx_type j = argj.int_value ();
 
-              if (argq.is_real_type () 
+              if (argq.is_real_type ()
                   && argr.is_real_type ())
                 {
                   // all real case
-                  if (argq.is_single_type () 
+                  if (argq.is_single_type ()
                       && argr.is_single_type ())
                     {
                       FloatMatrix Q = argq.float_matrix_value ();
                       FloatMatrix R = argr.float_matrix_value ();
 
                       FloatQR fact (Q, R);
                       fact.shift_cols (i-1, j-1);
 
@@ -1492,36 +1492,36 @@ of @w{@var{A}(:,p)}, where @w{p} is the 
 
                       retval(1) = get_qr_r (fact);
                       retval(0) = fact.Q ();
                     }
                 }
               else
                 {
                   // complex case
-                  if (argq.is_single_type () 
+                  if (argq.is_single_type ()
                       && argr.is_single_type ())
                     {
                       FloatComplexMatrix Q = argq.float_complex_matrix_value ();
                       FloatComplexMatrix R = argr.float_complex_matrix_value ();
 
                       FloatComplexQR fact (Q, R);
                       fact.shift_cols (i-1, j-1);
-                  
+
                       retval(1) = get_qr_r (fact);
                       retval(0) = fact.Q ();
                     }
                   else
                     {
                       ComplexMatrix Q = argq.complex_matrix_value ();
                       ComplexMatrix R = argr.complex_matrix_value ();
 
                       ComplexQR fact (Q, R);
                       fact.shift_cols (i-1, j-1);
-                  
+
                       retval(1) = get_qr_r (fact);
                       retval(0) = fact.Q ();
                     }
                 }
             }
           else
             error ("qrshift: invalid index I or J");
         }
@@ -1538,35 +1538,35 @@ of @w{@var{A}(:,p)}, where @w{p} is the 
 %! AA = A.';
 %! i = 2; j = 4; p = [1:i-1, shift(i:j,-1), j+1:5];
 %!
 %! [Q,R] = qr(AA);
 %! [Q,R] = qrshift(Q,R,i,j);
 %! assert(norm(vec(Q'*Q - eye(3)),Inf) < 1e1*eps)
 %! assert(norm(vec(triu(R)-R),Inf) == 0)
 %! assert(norm(vec(Q*R - AA(:,p)),Inf) < norm(AA)*1e1*eps)
-%! 
+%!
 %! j = 2; i = 4; p = [1:j-1, shift(j:i,+1), i+1:5];
 %!
 %! [Q,R] = qr(AA);
 %! [Q,R] = qrshift(Q,R,i,j);
 %! assert(norm(vec(Q'*Q - eye(3)),Inf) < 1e1*eps)
 %! assert(norm(vec(triu(R)-R),Inf) == 0)
 %! assert(norm(vec(Q*R - AA(:,p)),Inf) < norm(AA)*1e1*eps)
-%! 
+%!
 %!test
 %! AA = Ac.';
 %! i = 2; j = 4; p = [1:i-1, shift(i:j,-1), j+1:5];
 %!
 %! [Q,R] = qr(AA);
 %! [Q,R] = qrshift(Q,R,i,j);
 %! assert(norm(vec(Q'*Q - eye(3)),Inf) < 1e1*eps)
 %! assert(norm(vec(triu(R)-R),Inf) == 0)
 %! assert(norm(vec(Q*R - AA(:,p)),Inf) < norm(AA)*1e1*eps)
-%! 
+%!
 %! j = 2; i = 4; p = [1:j-1, shift(j:i,+1), i+1:5];
 %!
 %! [Q,R] = qr(AA);
 %! [Q,R] = qrshift(Q,R,i,j);
 %! assert(norm(vec(Q'*Q - eye(3)),Inf) < 1e1*eps)
 %! assert(norm(vec(triu(R)-R),Inf) == 0)
 %! assert(norm(vec(Q*R - AA(:,p)),Inf) < norm(AA)*1e1*eps)
 
@@ -1575,35 +1575,35 @@ of @w{@var{A}(:,p)}, where @w{p} is the 
 %! AA = single (A).';
 %! i = 2; j = 4; p = [1:i-1, shift(i:j,-1), j+1:5];
 %!
 %! [Q,R] = qr(AA);
 %! [Q,R] = qrshift(Q,R,i,j);
 %! assert(norm(vec(Q'*Q - eye(3,'single')),Inf) < 1e1*eps('single'))
 %! assert(norm(vec(triu(R)-R),Inf) == 0)
 %! assert(norm(vec(Q*R - AA(:,p)),Inf) < norm(AA)*1e1*eps('single'))
-%! 
+%!
 %! j = 2; i = 4; p = [1:j-1, shift(j:i,+1), i+1:5];
 %!
 %! [Q,R] = qr(AA);
 %! [Q,R] = qrshift(Q,R,i,j);
 %! assert(norm(vec(Q'*Q - eye(3,'single')),Inf) < 1e1*eps('single'))
 %! assert(norm(vec(triu(R)-R),Inf) == 0)
 %! assert(norm(vec(Q*R - AA(:,p)),Inf) < norm(AA)*1e1*eps('single'))
-%! 
+%!
 %!test
 %! AA = single(Ac).';
 %! i = 2; j = 4; p = [1:i-1, shift(i:j,-1), j+1:5];
 %!
 %! [Q,R] = qr(AA);
 %! [Q,R] = qrshift(Q,R,i,j);
 %! assert(norm(vec(Q'*Q - eye(3,'single')),Inf) < 1e1*eps('single'))
 %! assert(norm(vec(triu(R)-R),Inf) == 0)
 %! assert(norm(vec(Q*R - AA(:,p)),Inf) < norm(AA)*1e1*eps('single'))
-%! 
+%!
 %! j = 2; i = 4; p = [1:j-1, shift(j:i,+1), i+1:5];
 %!
 %! [Q,R] = qr(AA);
 %! [Q,R] = qrshift(Q,R,i,j);
 %! assert(norm(vec(Q'*Q - eye(3,'single')),Inf) < 1e1*eps('single'))
 %! assert(norm(vec(triu(R)-R),Inf) == 0)
 %! assert(norm(vec(Q*R - AA(:,p)),Inf) < norm(AA)*1e1*eps('single'))
 */
diff --git a/src/DLD-FUNCTIONS/quad.cc b/src/DLD-FUNCTIONS/quad.cc
--- a/src/DLD-FUNCTIONS/quad.cc
+++ b/src/DLD-FUNCTIONS/quad.cc
@@ -321,17 +321,17 @@ cannot be called recursively.\n\
 
                 default:
                   QUAD_ABORT1 ("expecting tol to contain no more than two values");
                 }
 
             case 3:
               if (indefinite)
                 {
-                  FloatIndefQuad iq (quad_float_user_function, bound, 
+                  FloatIndefQuad iq (quad_float_user_function, bound,
                                      indef_type);
                   iq.set_options (quad_opts);
                   val = iq.float_integrate (ier, nfun, abserr);
                 }
               else
                 {
                   if (have_sing)
                     {
@@ -473,25 +473,25 @@ cannot be called recursively.\n\
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
-%!function y = f (x) 
+%!function y = f (x)
 %! y = x + 1;
 %!test
 %! [v, ier, nfun, err] = quad ("f", 0, 5);
-%! assert(ier == 0 && abs (v - 17.5) < sqrt (eps) && nfun > 0 && 
+%! assert(ier == 0 && abs (v - 17.5) < sqrt (eps) && nfun > 0 &&
 %!        err < sqrt (eps))
 %!test
 %! [v, ier, nfun, err] = quad ("f", single(0), single(5));
-%! assert(ier == 0 && abs (v - 17.5) < sqrt (eps ("single")) && nfun > 0 && 
+%! assert(ier == 0 && abs (v - 17.5) < sqrt (eps ("single")) && nfun > 0 &&
 %!        err < sqrt (eps ("single")))
 
 %!function y = f (x)
 %!  y = x .* sin (1 ./ x) .* sqrt (abs (1 - x));
 %!test
 %!  [v, ier, nfun, err] = quad ("f", 0.001, 3);
 %! assert((ier == 0 || ier == 1) && abs (v - 1.98194120273598) < sqrt (eps) && nfun > 0);
 %!test
diff --git a/src/DLD-FUNCTIONS/quadcc.cc b/src/DLD-FUNCTIONS/quadcc.cc
--- a/src/DLD-FUNCTIONS/quadcc.cc
+++ b/src/DLD-FUNCTIONS/quadcc.cc
@@ -1472,17 +1472,17 @@ downdate (double *c, int n, int d, int *
 
 }
 
 
 
 /* The actual integration routine.
     */
 
-DEFUN_DLD (quadcc, args, nargout, 
+DEFUN_DLD (quadcc, args, nargout,
 "-*- texinfo -*-\n\
 @deftypefn  {Function File} {[@var{int}, @var{err}, @var{nr_points}] =} quadcc (@var{f}, @var{a}, @var{b}, @var{tol})\n\
 @deftypefnx {Function File} {[@var{int}, @var{err}, @var{nr_points}] =} quadcc (@var{f}, @var{a}, @var{b}, @var{tol}, @var{sing})\n\
 Numerically evaluates an integral using the doubly-adaptive\n\
 quadrature described by P. Gonnet in @cite{Increasing the\n\
 Reliability of Adaptive Quadrature Using Explicit Interpolants},\n\
 ACM Transactions on Mathematical Software, in Press, 2010.\n\
 The algorithm uses Clenshaw-Curtis quadrature rules of increasing\n\
@@ -2033,18 +2033,18 @@ well-behaved integrand than other method
             {
               igral = copysign (octave_Inf, igral);
               warning ("quadcc: divergent integral detected.");
               break;
             }
 
           /* Compute the local integral. */
           ivl->igral = h * w * ivl->c[0];
-          
-          
+
+
           /* Generate the interval on the right */
           ivr = &(ivals[heap[nivals++]]);
           ivr->a = m;
           ivr->b = iv->b;
           mr = (ivr->a + ivr->b) / 2;
           hr = h / 2;
           ivr->depth = 0;
           ivr->rdepth = iv->rdepth + 1;
@@ -2131,18 +2131,18 @@ well-behaved integrand than other method
             {
               igral = copysign (octave_Inf, igral);
               warning ("quadcc: divergent integral detected.");
               break;
             }
 
           /* Compute the local integral. */
           ivr->igral = h * w * ivr->c[0];
-          
-          
+
+
           /* Fix-up the heap: we now have one interval on top
              that we don't need any more and two new, unsorted
              ones at the bottom. */
           /* Flip the last interval to the top of the heap and
              sift down. */
           t = heap[nivals - 1];
           heap[nivals - 1] = heap[0];
           heap[0] = t;
diff --git a/src/DLD-FUNCTIONS/qz.cc b/src/DLD-FUNCTIONS/qz.cc
--- a/src/DLD-FUNCTIONS/qz.cc
+++ b/src/DLD-FUNCTIONS/qz.cc
@@ -77,17 +77,17 @@ extern "C"
 F77_RET_T
   F77_FUNC (zggbal, ZGGBAL) (F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type& N, Complex* A,
                              const octave_idx_type& LDA, Complex* B,
                              const octave_idx_type& LDB, octave_idx_type& ILO,
                              octave_idx_type& IHI, double* LSCALE,
                              double* RSCALE, double* WORK,
                              octave_idx_type& INFO
-                             F77_CHAR_ARG_LEN_DECL);    
+                             F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dggbak, DGGBAK) (F77_CONST_CHAR_ARG_DECL,
                              F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type& N,
                              const octave_idx_type& ILO,
                              const octave_idx_type& IHI,
                              const double* LSCALE, const double* RSCALE,
@@ -157,18 +157,18 @@ F77_RET_T
                              F77_CONST_CHAR_ARG_DECL,
                              F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type& N,
                              const octave_idx_type& ILO,
                              const octave_idx_type& IHI,
                              Complex* A, const octave_idx_type& LDA,
                              Complex* B, const octave_idx_type& LDB,
                              Complex* ALPHA, Complex* BETA, Complex* CQ,
-                             const octave_idx_type& LDQ, 
-                             Complex* CZ, const octave_idx_type& LDZ, 
+                             const octave_idx_type& LDQ,
+                             Complex* CZ, const octave_idx_type& LDZ,
                              Complex* WORK, const octave_idx_type& LWORK,
                              double* RWORK, octave_idx_type& INFO
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dlag2, DLAG2) (const double* A, const octave_idx_type& LDA,
@@ -619,17 +619,17 @@ compatibility with @sc{matlab}.\n\
 #ifdef DEBUG
       if (compz == 'V')
         std::cout << "qz: balancing done; ZZ=" << std::endl << ZZ << std::endl;
 #endif
     }
 #endif
 
   static char qz_job;
-  qz_job = (nargout < 2 ? 'E' : 'S');   
+  qz_job = (nargout < 2 ? 'E' : 'S');
 
   if (complex_case)
     {
       // Complex case.
 
       // The QR decomposition of cbb.
       ComplexQR cbqr (cbb);
       // The R matrix of QR decomposition for cbb.
@@ -642,56 +642,56 @@ compatibility with @sc{matlab}.\n\
                 (F77_CONST_CHAR_ARG2 (&compq, 1),
                  F77_CONST_CHAR_ARG2 (&compz, 1),
                  nn, ilo, ihi, caa.fortran_vec (),
                  nn, cbb.fortran_vec (), nn, CQ.fortran_vec (), nn,
                  CZ.fortran_vec (), nn, info
                  F77_CHAR_ARG_LEN (1)
                  F77_CHAR_ARG_LEN (1)));
 
-      ComplexRowVector cwork (1 * nn); 
+      ComplexRowVector cwork (1 * nn);
 
       F77_XFCN (zhgeqz, ZHGEQZ,
                 (F77_CONST_CHAR_ARG2 (&qz_job, 1),
                  F77_CONST_CHAR_ARG2 (&compq, 1),
                  F77_CONST_CHAR_ARG2 (&compz, 1),
-                 nn, ilo, ihi, 
-                 caa.fortran_vec (), nn, 
-                 cbb.fortran_vec (),nn, 
-                 xalpha.fortran_vec (), xbeta.fortran_vec (), 
+                 nn, ilo, ihi,
+                 caa.fortran_vec (), nn,
+                 cbb.fortran_vec (),nn,
+                 xalpha.fortran_vec (), xbeta.fortran_vec (),
                  CQ.fortran_vec (), nn,
-                 CZ.fortran_vec (), nn, 
+                 CZ.fortran_vec (), nn,
                  cwork.fortran_vec (), nn, rwork.fortran_vec (), info
                  F77_CHAR_ARG_LEN (1)
                  F77_CHAR_ARG_LEN (1)
-                 F77_CHAR_ARG_LEN (1))); 
+                 F77_CHAR_ARG_LEN (1)));
 
-      if (compq == 'V') 
+      if (compq == 'V')
         {
           // Left eigenvector.
           F77_XFCN (zggbak, ZGGBAK,
                     (F77_CONST_CHAR_ARG2 (&bal_job, 1),
                      F77_CONST_CHAR_ARG2 ("L", 1),
                      nn, ilo, ihi, lscale.data (), rscale.data (),
                      nn, CQ.fortran_vec (), nn, info
                      F77_CHAR_ARG_LEN (1)
                      F77_CHAR_ARG_LEN (1)));
-        }        
+        }
 
       // Right eigenvector.
       if (compz == 'V')
         {
           F77_XFCN (zggbak, ZGGBAK,
                     (F77_CONST_CHAR_ARG2 (&bal_job, 1),
                      F77_CONST_CHAR_ARG2 ("R", 1),
                      nn, ilo, ihi, lscale.data (), rscale.data (),
                      nn, CZ.fortran_vec (), nn, info
                      F77_CHAR_ARG_LEN (1)
                      F77_CHAR_ARG_LEN (1)));
-        } 
+        }
 
     }
   else
     {
 #ifdef DEBUG
       std::cout << "qz: peforming qr decomposition of bb" << std::endl;
 #endif
 
@@ -1067,17 +1067,17 @@ compatibility with @sc{matlab}.\n\
 
           F77_XFCN (ztgevc, ZTGEVC,
                     (F77_CONST_CHAR_ARG2 (&side, 1),
                      F77_CONST_CHAR_ARG2 (&howmny, 1),
                      select, nn, caa.fortran_vec (), nn, cbb.fortran_vec (),
                      nn, CVL.fortran_vec (), nn, CVR.fortran_vec (), nn, nn,
                      m, cwork2.fortran_vec (), rwork2.fortran_vec (), info
                      F77_CHAR_ARG_LEN (1)
-                     F77_CHAR_ARG_LEN (1)));     
+                     F77_CHAR_ARG_LEN (1)));
         }
       else
         {
 #ifdef DEBUG
           std::cout << "qz: computing  generalized eigenvectors" << std::endl;
 #endif
 
           VL = QQ;
@@ -1192,33 +1192,33 @@ compatibility with @sc{matlab}.\n\
         if (complex_case)
           {
 #ifdef DEBUG
             std::cout << "qz: retval (1) = cbb = " << std::endl;
             octave_print_internal (std::cout, cbb, 0);
             std::cout << std::endl << "qz: retval(0) = caa = " <<std::endl;
             octave_print_internal (std::cout, caa, 0);
             std::cout << std::endl;
-#endif  
+#endif
             retval(1) = cbb;
             retval(0) = caa;
           }
       else
         {
 #ifdef DEBUG
           std::cout << "qz: retval (1) = bb = " << std::endl;
           octave_print_internal (std::cout, bb, 0);
           std::cout << std::endl << "qz: retval(0) = aa = " <<std::endl;
           octave_print_internal (std::cout, aa, 0);
           std::cout << std::endl;
 #endif
           retval(1) = bb;
           retval(0) = aa;
         }
-      }      
+      }
       break;
 
 
     case 1:
     case 0:
 #ifdef DEBUG
       std::cout << "qz: retval(0) = gev = " << gev << std::endl;
 #endif
diff --git a/src/DLD-FUNCTIONS/rand.cc b/src/DLD-FUNCTIONS/rand.cc
--- a/src/DLD-FUNCTIONS/rand.cc
+++ b/src/DLD-FUNCTIONS/rand.cc
@@ -244,30 +244,30 @@ do_rand (const octave_value_list& args, 
               {
                 if (args(idx+1).is_real_scalar ())
                   {
                     double d = args(idx+1).double_value ();
 
                     if (! error_state)
                       octave_rand::seed (d);
                   }
-                else if (args(idx+1).is_string () 
+                else if (args(idx+1).is_string ()
                          && args(idx+1).string_value() == "reset")
                   octave_rand::reset ();
                 else
                   error ("%s: seed must be a real scalar", fcn);
               }
             else if (ts == "state" || ts == "twister")
               {
                 if (args(idx+1).is_string ()
                     && args(idx+1).string_value() == "reset")
                   octave_rand::reset (fcn);
                 else
                   {
-                    ColumnVector s = 
+                    ColumnVector s =
                       ColumnVector (args(idx+1).vector_value(false, true));
 
                     if (! error_state)
                       octave_rand::state (s, fcn);
                   }
               }
             else
               error ("%s: unrecognized string argument", fcn);
@@ -463,29 +463,29 @@ using the \"reset\" keyword.\n\
 %! if (__random_statistical_tests__)
 %!   % statistical tests may fail occasionally.
 %!   rand("state",12);
 %!   x = rand(100000,1);
 %!   assert(max(x)<1.); %*** Please report this!!! ***
 %!   assert(min(x)>0.); %*** Please report this!!! ***
 %!   assert(mean(x),0.5,0.0024);
 %!   assert(var(x),1/48,0.0632);
-%!   assert(skewness(x),0,0.012); 
+%!   assert(skewness(x),0,0.012);
 %!   assert(kurtosis(x),-6/5,0.0094);
 %! endif
 %!test
 %! if (__random_statistical_tests__)
 %!   % statistical tests may fail occasionally.
 %!   rand("seed",12);
 %!   x = rand(100000,1);
 %!   assert(max(x)<1.); %*** Please report this!!! ***
 %!   assert(min(x)>0.); %*** Please report this!!! ***
 %!   assert(mean(x),0.5,0.0024);
 %!   assert(var(x),1/48,0.0632);
-%!   assert(skewness(x),0,0.012); 
+%!   assert(skewness(x),0,0.012);
 %!   assert(kurtosis(x),-6/5,0.0094);
 %! endif
 */
 
 
 static std::string current_distribution = octave_rand::distribution ();
 
 DEFUN_DLD (randn, args, ,
@@ -1029,17 +1029,17 @@ All permutations are equally likely.\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value retval;
 
   if (nargin == 1 || nargin == 2)
     {
       octave_idx_type n, m;
-      
+
       if (nargin == 2)
         m = args(1).idx_type_value (true);
       else
         m = 1;
 
       n = args(0).idx_type_value (true);
 
       if (m < 0 || n < 0)
@@ -1080,17 +1080,17 @@ All permutations are equally likely.\n\
           ivec = idx.fortran_vec ();
           rvec = r.fortran_vec ();
 
           // Convert to doubles, reusing r.
           for (octave_idx_type i = 0, l = m*n; i < l; i++)
             rvec[i] = ivec[i] + 1;
 
           // Now create an array object with a cached idx_vector.
-          retval = new octave_matrix (r, idx_vector (idx)); 
+          retval = new octave_matrix (r, idx_vector (idx));
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
diff --git a/src/DLD-FUNCTIONS/regexp.cc b/src/DLD-FUNCTIONS/regexp.cc
--- a/src/DLD-FUNCTIONS/regexp.cc
+++ b/src/DLD-FUNCTIONS/regexp.cc
@@ -46,35 +46,35 @@ along with Octave; see the file COPYING.
 #elif defined (HAVE_REGEX)
 #if defined (__MINGW32__)
 #define __restrict
 #endif
 #include <sys/types.h>
 #include <regex.h>
 #endif
 
-// Define the maximum number of retries for a pattern that 
+// Define the maximum number of retries for a pattern that
 // possibly results in an infinite recursion.
 #define PCRE_MATCHLIMIT_MAX 10
 
 // The regexp is constructed as a linked list to avoid resizing the
 // return values in arrays at each new match.
 
 // FIXME don't bother collecting and composing return values the user
 // doesn't want.
 
 class regexp_elem
 {
 public:
-  regexp_elem (const string_vector& _named_token, const Cell& _t, 
-               const std::string& _m, const Matrix& _te, double _s, 
+  regexp_elem (const string_vector& _named_token, const Cell& _t,
+               const std::string& _m, const Matrix& _te, double _s,
                double _e) :
     named_token (_named_token), t (_t), m (_m), te (_te), s (_s), e (_e) { }
 
-  regexp_elem (const regexp_elem &a) : named_token (a.named_token), t (a.t), 
+  regexp_elem (const regexp_elem &a) : named_token (a.named_token), t (a.t),
                                        m (a.m), te (a.te), s (a.s), e (a.e)
                                        { }
 
   string_vector named_token;
   Cell t;
   std::string m;
   Matrix te;
   double s;
@@ -82,32 +82,32 @@ public:
 };
 
 typedef std::list<regexp_elem>::const_iterator const_iterator;
 
 #define MAXLOOKBEHIND 10
 static bool lookbehind_warned = false;
 
 static int
-octregexp_list (const octave_value_list &args, const std::string &nm, 
-                bool case_insensitive, std::list<regexp_elem> &lst, 
+octregexp_list (const octave_value_list &args, const std::string &nm,
+                bool case_insensitive, std::list<regexp_elem> &lst,
                 string_vector &named, int &nopts, bool &once)
 {
   int sz = 0;
-#if defined (HAVE_REGEX) || defined (HAVE_PCRE) 
+#if defined (HAVE_REGEX) || defined (HAVE_PCRE)
   int nargin = args.length();
   bool lineanchors = false;
   bool dotexceptnewline = false;
   bool freespacing = false;
 
   nopts = nargin - 2;
   once = false;
 
   std::string buffer = args(0).string_value ();
-  size_t max_length = (buffer.length () > MAXLOOKBEHIND ? 
+  size_t max_length = (buffer.length () > MAXLOOKBEHIND ?
                        MAXLOOKBEHIND: buffer.length ());
 
   if (error_state)
     {
       gripe_wrong_type_arg (nm.c_str(), args(0));
       return 0;
     }
 
@@ -194,48 +194,48 @@ octregexp_list (const octave_value_list 
   if (!error_state)
     {
       Cell t;
       std::string m;
       double s, e;
 
       // named tokens "(?<name>...)" are only treated with PCRE not regex.
 #if HAVE_PCRE
-      
+
       size_t pos = 0;
       size_t new_pos;
       int nnames = 0;
       int inames = 0;
       std::ostringstream buf;
       Array<int> named_idx;
 
       while ((new_pos = pattern.find ("(?",pos)) != std::string::npos)
         {
-          if (pattern.at (new_pos + 2) == '<' &&  
+          if (pattern.at (new_pos + 2) == '<' &&
               !(pattern.at (new_pos + 3) == '=' ||
                 pattern.at (new_pos + 3) == '!'))
             {
               // The syntax of named tokens in pcre is "(?P<name>...)" while
-              // we need a syntax "(?<name>...)", so fix that here. Also an 
-              // expression like 
-              // "(?<first>\w+)\s+(?<last>\w+)|(?<last>\w+),\s+(?<first>\w+)" 
+              // we need a syntax "(?<name>...)", so fix that here. Also an
+              // expression like
+              // "(?<first>\w+)\s+(?<last>\w+)|(?<last>\w+),\s+(?<first>\w+)"
               // should be perfectly legal, while pcre does not allow the same
               // named token name on both sides of the alternative. Also fix
               // that here by replacing name tokens by dummy names, and dealing
               // with the dummy names later.
 
               size_t tmp_pos = pattern.find_first_of ('>',new_pos);
 
               if (tmp_pos == std::string::npos)
                 {
                   error ("regexp: syntax error in pattern");
                   break;
                 }
 
-              std::string tmp_name = 
+              std::string tmp_name =
                 pattern.substr(new_pos+3,tmp_pos-new_pos-3);
               bool found = false;
 
               for (int i = 0; i < nnames; i++)
                 if (named(i) == tmp_name)
                   {
                     named_idx.resize(inames+1, 1);
                     named_idx(inames) = i;
@@ -257,20 +257,20 @@ octregexp_list (const octave_value_list 
               else if (inames < 100)
                 buf << "(?P<n0" << inames++;
               else
                 buf << "(?P<n" << inames++;
               pos = tmp_pos;
             }
           else if (pattern.at (new_pos + 2) == '<')
             {
-              // Find lookbehind operators of arbitrary length (ie like 
-              // "(?<=[a-z]*)") and replace with a maximum length operator 
-              // as PCRE can not yet handle arbitrary length lookahead 
-              // operators. Use the string length as the maximum length to 
+              // Find lookbehind operators of arbitrary length (ie like
+              // "(?<=[a-z]*)") and replace with a maximum length operator
+              // as PCRE can not yet handle arbitrary length lookahead
+              // operators. Use the string length as the maximum length to
               // avoid issues.
 
               int brackets = 1;
               size_t tmp_pos1 = new_pos + 2;
               size_t tmp_pos2 = tmp_pos1;
               while (tmp_pos1 <= pattern.length () && brackets > 0)
                 {
                   char ch = pattern.at (tmp_pos1);
@@ -309,17 +309,17 @@ octregexp_list (const octave_value_list 
                         i = 0;
                       else
                         i = 1;
 
                       for (; i < max_length + 1; i++)
                         {
                           buf << pattern.substr(new_pos, tmp_pos3 - new_pos)
                               << "{" << i << "}";
-                          buf << pattern.substr(tmp_pos3 + 1, 
+                          buf << pattern.substr(tmp_pos3 + 1,
                                                 tmp_pos1 - tmp_pos3 - 1);
                           if (i != max_length)
                             buf << "|";
                         }
                       buf << ")";
                     }
                   else
                     buf << pattern.substr (pos, tmp_pos1 - pos);
@@ -345,20 +345,20 @@ octregexp_list (const octave_value_list 
       int erroffset;
       std::string buf_str = buf.str ();
       re = pcre_compile (buf_str.c_str (),
                          (case_insensitive ? PCRE_CASELESS : 0) |
                          (dotexceptnewline ? 0 : PCRE_DOTALL) |
                          (lineanchors ? PCRE_MULTILINE : 0) |
                          (freespacing ? PCRE_EXTENDED : 0),
                          &err, &erroffset, 0);
-    
+
       if (re == 0)
         {
-          error("%s: %s at position %d of expression", nm.c_str(), 
+          error("%s: %s at position %d of expression", nm.c_str(),
                 err, erroffset);
           return 0;
         }
 
       int subpatterns;
       int namecount;
       int nameentrysize;
       char *nametable;
@@ -379,18 +379,18 @@ octregexp_list (const octave_value_list 
           nidx[i] = (static_cast<int>(nametable[i*nameentrysize])) << 8 |
             static_cast<int>(nametable[i*nameentrysize+1]);
         }
 
       while(true)
         {
           OCTAVE_QUIT;
 
-          int matches = pcre_exec(re, 0, buffer.c_str(), 
-                                  buffer.length(), idx, 
+          int matches = pcre_exec(re, 0, buffer.c_str(),
+                                  buffer.length(), idx,
                                   (idx ? PCRE_NOTBOL : 0),
                                   ovector, (subpatterns+1)*3);
 
           if (matches == PCRE_ERROR_MATCHLIMIT)
             {
               // try harder; start with default value for MATCH_LIMIT and increase it
               warning("Your pattern caused PCRE to hit its MATCH_LIMIT.\nTrying harder now, but this will be slow.");
               pcre_extra pe;
@@ -399,18 +399,18 @@ octregexp_list (const octave_value_list 
 
               int i = 0;
               while (matches == PCRE_ERROR_MATCHLIMIT &&
                      i++ < PCRE_MATCHLIMIT_MAX)
                 {
                   OCTAVE_QUIT;
 
                   pe.match_limit *= 10;
-                  matches = pcre_exec(re, &pe, buffer.c_str(), 
-                                      buffer.length(), idx, 
+                  matches = pcre_exec(re, &pe, buffer.c_str(),
+                                      buffer.length(), idx,
                                       (idx ? PCRE_NOTBOL : 0),
                                       ovector, (subpatterns+1)*3);
                 }
             }
 
           if (matches < 0 && matches != PCRE_ERROR_NOMATCH)
             {
               error ("%s: internal error calling pcre_exec\nError code from pcre_exec is %i", nm.c_str(), matches);
@@ -440,17 +440,17 @@ octregexp_list (const octave_value_list 
                           te(pos_match++,1) = double (ovector[2*i+1]);
                         }
                     }
               te.resize(pos_match,2);
               s = double (ovector[0]+1);
               e = double (ovector[1]);
 
               const char **listptr;
-              int status = pcre_get_substring_list(buffer.c_str(), ovector, 
+              int status = pcre_get_substring_list(buffer.c_str(), ovector,
                                                    matches, &listptr);
 
               if (status == PCRE_ERROR_NOMEMORY)
                 {
                   error("%s: cannot allocate memory in pcre_get_substring_list",
                         nm.c_str());
                   pcre_free(re);
                   return 0;
@@ -462,19 +462,19 @@ octregexp_list (const octave_value_list 
               pos_match = 0;
               for (int i = 1; i < matches; i++)
                 if (ovector[2*i] >= 0 && ovector[2*i+1] > 0)
                   {
                     if (i == 1 || ovector[2*i] != ovector[2*i-2]
                         || ovector[2*i-1] != ovector[2*i+1])
                       {
                         if (namecount > 0)
-                          named_tokens(named_idx(i-pos_offset-1)) = 
-                            std::string(*(listptr+nidx[i-pos_offset-1]));    
-                        cell_t(pos_match++) = 
+                          named_tokens(named_idx(i-pos_offset-1)) =
+                            std::string(*(listptr+nidx[i-pos_offset-1]));
+                        cell_t(pos_match++) =
                           std::string(*(listptr+i));
                       }
                     else
                       pos_offset++;
                 }
 
               m =  std::string(*listptr);
               t = cell_t;
@@ -490,65 +490,65 @@ octregexp_list (const octave_value_list 
                 break;
 
             }
         }
 
       pcre_free(re);
 #else
       regex_t compiled;
-      int err=regcomp(&compiled, pattern.c_str(), REG_EXTENDED | 
+      int err=regcomp(&compiled, pattern.c_str(), REG_EXTENDED |
                       (case_insensitive ? REG_ICASE : 0));
       if (err)
         {
           int len = regerror(err, &compiled, 0, 0);
           OCTAVE_LOCAL_BUFFER (char, errmsg, len);
           regerror(err, &compiled, errmsg, len);
-          error("%s: %s in pattern (%s)", nm.c_str(), errmsg, 
+          error("%s: %s in pattern (%s)", nm.c_str(), errmsg,
                 pattern.c_str());
           regfree(&compiled);
           return 0;
         }
 
       int subexpr = 1;
       int idx = 0;
       for (unsigned int i=0; i < pattern.length(); i++)
           subexpr += ( pattern[i] == '(' ? 1 : 0 );
       OCTAVE_LOCAL_BUFFER (regmatch_t, match, subexpr );
 
       while(true)
         {
-          OCTAVE_QUIT; 
+          OCTAVE_QUIT;
 
-          if (regexec(&compiled, buffer.c_str() + idx, subexpr, 
-                      match, (idx ? REG_NOTBOL : 0)) == 0) 
+          if (regexec(&compiled, buffer.c_str() + idx, subexpr,
+                      match, (idx ? REG_NOTBOL : 0)) == 0)
             {
               // Count actual matches
               int matches = 0;
-              while (matches < subexpr && match[matches].rm_so >= 0) 
+              while (matches < subexpr && match[matches].rm_so >= 0)
                 matches++;
 
               if (matches == 0 || match[0].rm_eo == 0)
                 break;
 
               s = double (match[0].rm_so+1+idx);
               e = double (match[0].rm_eo+idx);
               Matrix te(matches-1,2);
               for (int i = 1; i < matches; i++)
                 {
                   te(i-1,0) = double (match[i].rm_so+1+idx);
                   te(i-1,1) = double (match[i].rm_eo+idx);
                 }
 
-              m =  buffer.substr (match[0].rm_so+idx, 
+              m =  buffer.substr (match[0].rm_so+idx,
                                          match[0].rm_eo-match[0].rm_so);
 
               Cell cell_t (dim_vector(1,matches-1));
               for (int i = 1; i < matches; i++)
-                cell_t(i-1) = buffer.substr (match[i].rm_so+idx, 
+                cell_t(i-1) = buffer.substr (match[i].rm_so+idx,
                                              match[i].rm_eo-match[i].rm_so);
               t = cell_t;
 
               idx += match[0].rm_eo;
 
               string_vector sv;
               regexp_elem new_elem (sv, t, m, te, s, e);
               lst.push_back (new_elem);
@@ -681,17 +681,17 @@ octregexp (const octave_value_list &args
         {
           int n = 0;
           octave_value_list new_retval;
           new_retval.resize(nargout);
 
           OCTAVE_LOCAL_BUFFER (int, arg_used, 6);
           for (int j = 0; j < 6; j++)
             arg_used[j] = false;
-          
+
           for (int j = 2; j < nargin; j++)
             {
               int k = 0;
               std::string str = args(j).string_value();
               std::transform (str.begin (), str.end (), str.begin (), tolower);
               if (str.find("once", 0) == 0
                   || str.find("stringanchors", 0) == 0
                   || str.find("lineanchors", 0) == 0
@@ -760,17 +760,17 @@ octcellregexp (const octave_value_list &
               for (int j = 0; j < nargout; j++)
                 newretval[j].resize(cellstr.dims());
 
               new_args(1) = cellpat(0);
 
               for (octave_idx_type i = 0; i < cellstr.numel (); i++)
                 {
                   new_args(0) = cellstr(i);
-                  octave_value_list tmp = octregexp (new_args, nargout, nm, 
+                  octave_value_list tmp = octregexp (new_args, nargout, nm,
                                                      case_insensitive);
 
                   if (error_state)
                     break;
 
                   for (int j = 0; j < nargout; j++)
                     newretval[j](i) = tmp(j);
                 }
@@ -780,17 +780,17 @@ octcellregexp (const octave_value_list &
               for (int j = 0; j < nargout; j++)
                 newretval[j].resize(cellpat.dims());
 
               new_args(0) = cellstr(0);
 
               for (octave_idx_type i = 0; i < cellpat.numel (); i++)
                 {
                   new_args(1) = cellpat(i);
-                  octave_value_list tmp = octregexp (new_args, nargout, nm, 
+                  octave_value_list tmp = octregexp (new_args, nargout, nm,
                                                      case_insensitive);
 
                   if (error_state)
                     break;
 
                   for (int j = 0; j < nargout; j++)
                     newretval[j](i) = tmp(j);
                 }
@@ -805,17 +805,17 @@ octcellregexp (const octave_value_list &
                   for (int j = 0; j < nargout; j++)
                     newretval[j].resize(cellstr.dims());
 
                   for (octave_idx_type i = 0; i < cellstr.numel (); i++)
                     {
                       new_args(0) = cellstr(i);
                       new_args(1) = cellpat(i);
 
-                      octave_value_list tmp = octregexp (new_args, nargout, nm, 
+                      octave_value_list tmp = octregexp (new_args, nargout, nm,
                                                          case_insensitive);
 
                       if (error_state)
                         break;
 
                       for (int j = 0; j < nargout; j++)
                         newretval[j](i) = tmp(j);
                     }
@@ -1431,60 +1431,60 @@ octregexprep (const octave_value_list &a
 
   // Make sure we have string,pattern,replacement
   const std::string buffer = args(0).string_value ();
   if (error_state) return retval;
   const std::string pattern = args(1).string_value ();
   if (error_state) return retval;
   const std::string replacement = args(2).string_value ();
   if (error_state) return retval;
-  
+
   // Pack options excluding 'tokenize' and various output
   // reordering strings into regexp arg list
   octave_value_list regexpargs(nargin-1,octave_value());
   regexpargs(0) = args(0);
   regexpargs(1) = args(1);
   int len=2;
-  for (int i = 3; i < nargin; i++) 
+  for (int i = 3; i < nargin; i++)
     {
       const std::string opt = args(i).string_value();
       if (opt != "tokenize" && opt != "start" && opt != "end"
           && opt != "tokenextents" && opt != "match" && opt != "tokens"
-          && opt != "names"  && opt != "warnings") 
+          && opt != "names"  && opt != "warnings")
         {
           regexpargs(len++) = args(i);
         }
     }
   regexpargs.resize(len);
-  
+
   // Identify replacement tokens; build a vector of group numbers in
-  // the replacement string so that we can quickly calculate the size 
+  // the replacement string so that we can quickly calculate the size
   // of the replacement.
   int tokens = 0;
-  for (size_t i=1; i < replacement.size(); i++) 
+  for (size_t i=1; i < replacement.size(); i++)
     {
-      if (replacement[i-1]=='$' && isdigit(replacement[i])) 
+      if (replacement[i-1]=='$' && isdigit(replacement[i]))
         {
           tokens++, i++;
         }
     }
   std::vector<int> token(tokens);
   int kk = 0;
-  for (size_t i = 1; i < replacement.size(); i++) 
+  for (size_t i = 1; i < replacement.size(); i++)
     {
-      if (replacement[i-1]=='$' && isdigit(replacement[i])) 
+      if (replacement[i-1]=='$' && isdigit(replacement[i]))
         {
           token[kk++] = replacement[i]-'0';
           i++;
         }
     }
 
   // Perform replacement
   std::string rep;
-  if (tokens > 0) 
+  if (tokens > 0)
     {
       std::list<regexp_elem> lst;
       string_vector named;
       int nopts;
       bool once;
       int sz = octregexp_list (regexpargs, nm , false, lst, named, nopts, once);
 
       if (error_state)
@@ -1494,84 +1494,84 @@ octregexprep (const octave_value_list &a
           retval = args(0);
           return retval;
         }
 
       // Determine replacement length
       const size_t replen = replacement.size() - 2*tokens;
       int delta = 0;
       const_iterator p = lst.begin();
-      for (int i = 0; i < sz; i++) 
+      for (int i = 0; i < sz; i++)
         {
           OCTAVE_QUIT;
 
           const Matrix pairs(p->te);
           size_t pairlen = 0;
-          for (int j = 0; j < tokens; j++) 
+          for (int j = 0; j < tokens; j++)
             {
-              if (token[j] == 0) 
+              if (token[j] == 0)
                 pairlen += static_cast<size_t>(p->e - p->s) + 1;
-              else if (token[j] <= pairs.rows()) 
-                pairlen += static_cast<size_t>(pairs(token[j]-1,1) - 
+              else if (token[j] <= pairs.rows())
+                pairlen += static_cast<size_t>(pairs(token[j]-1,1) -
                                                pairs(token[j]-1,0)) + 1;
             }
-          delta += static_cast<int>(replen + pairlen) - 
+          delta += static_cast<int>(replen + pairlen) -
             static_cast<int>(p->e - p->s + 1);
           p++;
         }
-      
+
       // Build replacement string
       rep.reserve(buffer.size()+delta);
       size_t from = 0;
       p = lst.begin();
-      for (int i=0; i < sz; i++) 
+      for (int i=0; i < sz; i++)
         {
           OCTAVE_QUIT;
 
           const Matrix pairs(p->te);
           rep.append(&buffer[from], static_cast<size_t>(p->s - 1) - from);
           from = static_cast<size_t>(p->e - 1) + 1;
-          for (size_t j = 1; j < replacement.size(); j++) 
+          for (size_t j = 1; j < replacement.size(); j++)
             {
-              if (replacement[j-1]=='$' && isdigit(replacement[j])) 
+              if (replacement[j-1]=='$' && isdigit(replacement[j]))
                 {
                   int k = replacement[j]-'0';
-                  if (k == 0) 
-                    { 
+                  if (k == 0)
+                    {
                       // replace with entire match
                       rep.append(&buffer[static_cast<size_t>(p->e - 1)],
                                  static_cast<size_t>(p->e - p->s) + 1);
-                    } 
-                  else if (k <= pairs.rows()) 
+                    }
+                  else if (k <= pairs.rows())
                     {
                       // replace with group capture
                       rep.append(&buffer[static_cast<size_t>(pairs(k-1,0)-1)],
-                                 static_cast<size_t>(pairs(k-1,1) - 
+                                 static_cast<size_t>(pairs(k-1,1) -
                                                      pairs(k-1,0))+1);
                     }
-                  else 
+                  else
                     {
                       // replace with nothing
                     }
                   j++;
-                } 
-              else 
+                }
+              else
                 {
                   rep.append(1,replacement[j-1]);
                 }
-              if (j+1 == replacement.size()) 
+              if (j+1 == replacement.size())
                 {
                   rep.append(1,replacement[j]);
                 }
             }
           p++;
         }
       rep.append(&buffer[from],buffer.size()-from);
-    } 
-  else 
+    }
+  else
     {
       std::list<regexp_elem> lst;
       string_vector named;
       int nopts;
       bool once;
       int sz = octregexp_list (regexpargs, nm, false, lst, named, nopts, once);
 
       if (error_state)
@@ -1581,39 +1581,39 @@ octregexprep (const octave_value_list &a
           retval = args(0);
           return retval;
         }
 
       // Determine replacement length
       const size_t replen = replacement.size();
       int delta = 0;
       const_iterator p = lst.begin();
-      for (int i = 0; i < sz; i++) 
+      for (int i = 0; i < sz; i++)
         {
           OCTAVE_QUIT;
-          delta += static_cast<int>(replen) - 
+          delta += static_cast<int>(replen) -
             static_cast<int>(p->e - p->s + 1);
           p++;
         }
 
       // Build replacement string
       rep.reserve(buffer.size()+delta);
       size_t from = 0;
       p = lst.begin();
-      for (int i=0; i < sz; i++) 
+      for (int i=0; i < sz; i++)
         {
           OCTAVE_QUIT;
           rep.append(&buffer[from], static_cast<size_t>(p->s - 1) - from);
           from = static_cast<size_t>(p->e - 1) + 1;
           rep.append(replacement);
           p++;
         }
       rep.append(&buffer[from],buffer.size()-from);
     }
-  
+
   retval = rep;
   return retval;
 }
 
 DEFUN_DLD (regexprep, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{outstr} =} regexprep (@var{string}, @var{pat}, @var{repstr})\n\
 @deftypefnx {Loadable Function} {@var{outstr} =} regexprep (@var{string}, @var{pat}, @var{repstr}, \"@var{opt1}\", @dots{})\n\
diff --git a/src/DLD-FUNCTIONS/schur.cc b/src/DLD-FUNCTIONS/schur.cc
--- a/src/DLD-FUNCTIONS/schur.cc
+++ b/src/DLD-FUNCTIONS/schur.cc
@@ -237,17 +237,17 @@ leading eigenvalues of\n\
     }
 
   octave_value arg = args(0);
 
   std::string ord;
 
   if (nargin == 2)
     {
-      ord = args(1).string_value (); 
+      ord = args(1).string_value ();
 
       if (error_state)
         {
           error ("schur: second argument must be a string");
           return retval;
         }
     }
 
@@ -304,17 +304,17 @@ leading eigenvalues of\n\
             }
         }
       else
         {
           FloatComplexMatrix ctmp = arg.float_complex_matrix_value ();
 
           if (! error_state)
             {
- 
+
               if (nargout == 0 || nargout == 1)
                 {
                   FloatComplexSCHUR result (ctmp, ord, false);
                   retval(0) = mark_upper_triangular (result.schur_matrix ());
                 }
               else
                 {
                   FloatComplexSCHUR result (ctmp, ord, true);
@@ -346,33 +346,33 @@ leading eigenvalues of\n\
             }
         }
       else
         {
           ComplexMatrix ctmp = arg.complex_matrix_value ();
 
           if (! error_state)
             {
- 
+
               if (nargout == 0 || nargout == 1)
                 {
                   ComplexSCHUR result (ctmp, ord, false);
                   retval(0) = mark_upper_triangular (result.schur_matrix ());
                 }
               else
                 {
                   ComplexSCHUR result (ctmp, ord, true);
                   retval(1) = mark_upper_triangular (result.schur_matrix ());
                   retval(0) = result.unitary_matrix ();
                 }
             }
         }
     }
- 
-  return retval; 
+
+  return retval;
 }
 
 /*
 
 %!test
 %! a = [1, 2, 3; 4, 5, 9; 7, 8, 6];
 %! [u, s] = schur (a);
 %! assert(u' * a * u, s, sqrt (eps));
diff --git a/src/DLD-FUNCTIONS/spparms.cc b/src/DLD-FUNCTIONS/spparms.cc
--- a/src/DLD-FUNCTIONS/spparms.cc
+++ b/src/DLD-FUNCTIONS/spparms.cc
@@ -112,17 +112,17 @@ time.\n\
       else if (nargout == 1)
         retval(0) =  octave_sparse_params::get_vals ();
       else if (nargout == 2)
         {
           retval (0) = octave_sparse_params::get_keys ();
           retval (1) = octave_sparse_params::get_vals ();
         }
       else
-        error ("spparms: too many output arguments"); 
+        error ("spparms: too many output arguments");
     }
   else if (nargin == 1)
     {
       if (args(0).is_string ())
         {
           std::string str = args(0).string_value ();
           int len = str.length ();
           for (int i = 0; i < len; i++)
@@ -153,17 +153,17 @@ time.\n\
             octave_sparse_params::set_vals (vals);
         }
     }
   else if (nargin == 2)
     {
       if (args(0).is_string ())
         {
           std::string str = args(0).string_value ();
-          
+
           double val = args(1).double_value ();
 
           if (error_state)
             error ("spparms: second argument must be a real scalar");
           else if (str == "umfpack")
             warning ("spparms: request to disable umfpack solvers ignored");
           else if (!octave_sparse_params::set_key (str, val))
             error ("spparms: KEY not found");
diff --git a/src/DLD-FUNCTIONS/sqrtm.cc b/src/DLD-FUNCTIONS/sqrtm.cc
--- a/src/DLD-FUNCTIONS/sqrtm.cc
+++ b/src/DLD-FUNCTIONS/sqrtm.cc
@@ -44,17 +44,17 @@ static void
 sqrtm_utri_inplace (Matrix& T)
 {
   typedef typename Matrix::element_type element_type;
 
   const element_type zero = element_type ();
 
   bool singular = false;
 
-  /* 
+  /*
    * the following code is equivalent to this triple loop:
    *
    *  n = rows (T);
    *  for j = 1:n
    *    T(j,j) = sqrt (T(j,j));
    *    for i = j-1:-1:1
    *      T(i,j) /= (T(i,i) + T(j,j));
    *      k = 1:i-1;
diff --git a/src/DLD-FUNCTIONS/str2double.cc b/src/DLD-FUNCTIONS/str2double.cc
--- a/src/DLD-FUNCTIONS/str2double.cc
+++ b/src/DLD-FUNCTIONS/str2double.cc
@@ -33,17 +33,17 @@ along with Octave; see the file COPYING.
 #include "lo-ieee.h"
 
 #include "Cell.h"
 #include "ov.h"
 #include "defun-dld.h"
 #include "gripes.h"
 #include "utils.h"
 
-static inline bool 
+static inline bool
 is_imag_unit (int c)
 { return c == 'i' || c == 'j'; }
 
 static std::istringstream&
 single_num (std::istringstream& is, double& num)
 {
   char c = is.peek ();
   if (c == 'I')
@@ -64,17 +64,17 @@ single_num (std::istringstream& is, doub
       // It's NA or NaN
       is.get ();
       char c1 = is.get ();
       if (c1 == 'A')
         {
           num = octave_NA;
           is.peek (); // Sets eof bit.
         }
-      else 
+      else
         {
           char c2 = is.get ();
           if (c1 == 'a' && c2 == 'N')
             {
               num = octave_NaN;
               is.peek (); // Sets eof bit.
             }
           else
diff --git a/src/DLD-FUNCTIONS/strfind.cc b/src/DLD-FUNCTIONS/strfind.cc
--- a/src/DLD-FUNCTIONS/strfind.cc
+++ b/src/DLD-FUNCTIONS/strfind.cc
@@ -38,31 +38,31 @@ along with Octave; see the file COPYING.
 #include "utils.h"
 
 // This allows safe indexing with char. In C++, char may be (and often is) signed!
 #define ORD(ch) static_cast<unsigned char>(ch)
 #define TABSIZE (UCHAR_MAX + 1)
 
 // This is the quick search algorithm, as described at
 // http://www-igm.univ-mlv.fr/~lecroq/string/node19.html
-static void 
+static void
 qs_preprocess (const Array<char>& needle,
                octave_idx_type table[TABSIZE])
 {
   const char *x = needle.data ();
   octave_idx_type m = needle.numel ();
 
    for (octave_idx_type i = 0; i < UCHAR_MAX; i++)
       table[i] = m + 1;
    for (octave_idx_type i = 0; i < m; i++)
       table[ORD(x[i])] = m - i;
 }
 
 
-static Array<octave_idx_type> 
+static Array<octave_idx_type>
 qs_search (const Array<char>& needle,
            const Array<char>& haystack,
            const octave_idx_type table[TABSIZE],
            bool overlaps = true)
 {
   const char *x = needle.data ();
   octave_idx_type m = needle.numel ();
   const char *y = haystack.data ();
@@ -102,26 +102,26 @@ qs_search (const Array<char>& needle,
     }
   else if (n >= m)
     {
       // General case.
       octave_idx_type j = 0;
 
       if (overlaps)
         {
-          while (j < n - m) 
+          while (j < n - m)
             {
               if (std::equal (x, x + m, y + j))
                 accum.push_back (j);
               j += table[ORD(y[j + m])];
             }
         }
       else
         {
-          while (j < n - m) 
+          while (j < n - m)
             {
               if (std::equal (x, x + m, y + j))
                 {
                   accum.push_back (j);
                   j += m;
                 }
               else
                 j += table[ORD(y[j + m])];
@@ -131,17 +131,17 @@ qs_search (const Array<char>& needle,
       if (j == n - m && std::equal (x, x + m, y + j))
         accum.push_back (j);
     }
 
   octave_idx_type nmatch = accum.size ();
   octave_idx_type one = 1;
   Array<octave_idx_type> result (dim_vector (std::min (one, nmatch), nmatch));
   octave_idx_type k = 0;
-  for (std::deque<octave_idx_type>::const_iterator iter = accum.begin (); 
+  for (std::deque<octave_idx_type>::const_iterator iter = accum.begin ();
        iter != accum.end (); iter++)
     {
       result.xelem (k++) = *iter;
     }
 
   return result;
 }
 
@@ -202,31 +202,31 @@ strfind (@{\"abababa\", \"bebebe\", \"ab
       octave_value argstr = args(0), argpat = args(1);
       if (argpat.is_string ())
         {
           Array<char> needle = argpat.char_array_value ();
           OCTAVE_LOCAL_BUFFER (octave_idx_type, table, UCHAR_MAX);
           qs_preprocess (needle, table);
 
           if (argstr.is_string ())
-            retval = octave_value (qs_search (needle, argstr.char_array_value (), 
-                                              table, overlaps), 
+            retval = octave_value (qs_search (needle, argstr.char_array_value (),
+                                              table, overlaps),
                                    true, true);
           else if (argstr.is_cell ())
             {
               const Cell argsc = argstr.cell_value ();
               Cell retc (argsc.dims ());
               octave_idx_type ns = argsc.numel ();
 
               for (octave_idx_type i = 0; i < ns; i++)
                 {
                   octave_value argse = argsc(i);
                   if (argse.is_string ())
-                    retc(i) = octave_value (qs_search (needle, argse.char_array_value (), 
-                                                       table, overlaps), 
+                    retc(i) = octave_value (qs_search (needle, argse.char_array_value (),
+                                                       table, overlaps),
                                             true, true);
                   else
                     {
                       error ("strfind: each element of CELLSTR must be a string");
                       break;
                     }
                 }
 
@@ -257,17 +257,17 @@ strfind (@{\"abababa\", \"bebebe\", \"ab
 %!assert (strfind ("abababa", "aba", "overlaps", false), [1, 5]);
 %!assert (strfind ({"abababa", "bla", "bla"}, "a"), {[1, 3, 5, 7], 3, 3});
 %!assert (strfind ("Linux _is_ user-friendly. It just isn't ignorant-friendly or idiot-friendly.", "friendly"), [17, 50, 68]);
 
 */
 
 static Array<char>
 qs_replace (const Array<char>& str, const Array<char>& pat,
-            const Array<char>& rep, 
+            const Array<char>& rep,
             const octave_idx_type table[TABSIZE],
             bool overlaps = true)
 {
   Array<char> ret = str;
 
   octave_idx_type siz = str.numel (), psiz = pat.numel (), rsiz = rep.numel ();
 
   if (psiz != 0)
diff --git a/src/DLD-FUNCTIONS/sub2ind.cc b/src/DLD-FUNCTIONS/sub2ind.cc
--- a/src/DLD-FUNCTIONS/sub2ind.cc
+++ b/src/DLD-FUNCTIONS/sub2ind.cc
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 #include "quit.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 
 
-static dim_vector 
+static dim_vector
 get_dim_vector (const octave_value& val, const char *name)
 {
   RowVector dimsv = val.row_vector_value (false, true);
   dim_vector dv;
   octave_idx_type n = dimsv.length ();
 
   if (n < 1)
     error ("%s: dimension vector must not be empty", name);
@@ -198,15 +198,15 @@ moving from one column to next, filling 
     {
       dim_vector dv = get_dim_vector (args(0), "ind2sub");
       idx_vector idx = args(1).index_vector ();
       if (! error_state)
         {
           if (nargout > dv.length ())
             dv = dv.redim (nargout);
 
-          Array<idx_vector> idxa = ind2sub (dv, idx); 
+          Array<idx_vector> idxa = ind2sub (dv, idx);
           retval = Array<octave_value> (idxa);
         }
     }
 
   return retval;
 }
diff --git a/src/DLD-FUNCTIONS/svd.cc b/src/DLD-FUNCTIONS/svd.cc
--- a/src/DLD-FUNCTIONS/svd.cc
+++ b/src/DLD-FUNCTIONS/svd.cc
@@ -201,17 +201,17 @@ decomposition, eliminating the unnecessa
           if (arg.is_real_type ())
             {
               FloatMatrix tmp = arg.float_matrix_value ();
 
               if (! error_state)
                 {
                   if (tmp.any_element_is_inf_or_nan ())
                     {
-                      error ("svd: cannot take SVD of matrix containing Inf or NaN values"); 
+                      error ("svd: cannot take SVD of matrix containing Inf or NaN values");
                       return retval;
                     }
 
                   FloatSVD result (tmp, type, driver);
 
                   FloatDiagMatrix sigma = result.singular_values ();
 
                   if (nargout == 0 || nargout == 1)
@@ -229,17 +229,17 @@ decomposition, eliminating the unnecessa
           else if (arg.is_complex_type ())
             {
               FloatComplexMatrix ctmp = arg.float_complex_matrix_value ();
 
               if (! error_state)
                 {
                   if (ctmp.any_element_is_inf_or_nan ())
                     {
-                      error ("svd: cannot take SVD of matrix containing Inf or NaN values"); 
+                      error ("svd: cannot take SVD of matrix containing Inf or NaN values");
                       return retval;
                     }
 
                   FloatComplexSVD result (ctmp, type, driver);
 
                   FloatDiagMatrix sigma = result.singular_values ();
 
                   if (nargout == 0 || nargout == 1)
@@ -260,17 +260,17 @@ decomposition, eliminating the unnecessa
           if (arg.is_real_type ())
             {
               Matrix tmp = arg.matrix_value ();
 
               if (! error_state)
                 {
                   if (tmp.any_element_is_inf_or_nan ())
                     {
-                      error ("svd: cannot take SVD of matrix containing Inf or NaN values"); 
+                      error ("svd: cannot take SVD of matrix containing Inf or NaN values");
                       return retval;
                     }
 
                   SVD result (tmp, type, driver);
 
                   DiagMatrix sigma = result.singular_values ();
 
                   if (nargout == 0 || nargout == 1)
@@ -288,17 +288,17 @@ decomposition, eliminating the unnecessa
           else if (arg.is_complex_type ())
             {
               ComplexMatrix ctmp = arg.complex_matrix_value ();
 
               if (! error_state)
                 {
                   if (ctmp.any_element_is_inf_or_nan ())
                     {
-                      error ("svd: cannot take SVD of matrix containing Inf or NaN values"); 
+                      error ("svd: cannot take SVD of matrix containing Inf or NaN values");
                       return retval;
                     }
 
                   ComplexSVD result (ctmp, type, driver);
 
                   DiagMatrix sigma = result.singular_values ();
 
                   if (nargout == 0 || nargout == 1)
diff --git a/src/DLD-FUNCTIONS/syl.cc b/src/DLD-FUNCTIONS/syl.cc
--- a/src/DLD-FUNCTIONS/syl.cc
+++ b/src/DLD-FUNCTIONS/syl.cc
@@ -103,17 +103,17 @@ syl ([1, 2; 3, 4], [5, 6; 7, 8], [9, 10;
       gripe_square_matrix_required ("syl: first two parameters:");
       return retval;
     }
   else if (a_nr != c_nr || b_nr != c_nc)
     {
       gripe_nonconformant ();
       return retval;
     }
-  
+
   // Dimensions look o.k., let's solve the problem.
   if (isfloat)
     {
       if (arg_a.is_complex_type ()
           || arg_b.is_complex_type ()
           || arg_c.is_complex_type ())
         {
           // Do everything in complex arithmetic;
diff --git a/src/DLD-FUNCTIONS/symbfact.cc b/src/DLD-FUNCTIONS/symbfact.cc
--- a/src/DLD-FUNCTIONS/symbfact.cc
+++ b/src/DLD-FUNCTIONS/symbfact.cc
@@ -266,17 +266,17 @@ factorization as determined by @var{typ}
               A1 = A;
               A2 = F;
             }
 
           // count the total number of entries in L
           octave_idx_type lnz = 0 ;
           for (octave_idx_type j = 0 ; j < n ; j++)
             lnz += ColCount [j] ;
-        
+
 
           // allocate the output matrix L (pattern-only)
           SparseBoolMatrix L (n, n, lnz);
 
           // initialize column pointers
           lnz = 0;
           for (octave_idx_type j = 0 ; j < n ; j++)
             {
@@ -287,17 +287,17 @@ factorization as determined by @var{typ}
 
 
           /* create a copy of the column pointers */
           octave_idx_type *W = First;
           for (octave_idx_type j = 0 ; j < n ; j++)
             W [j] = L.xcidx(j);
 
           // get workspace for computing one row of L
-          cholmod_sparse *R = cholmod_allocate_sparse (n, 1, n, false, true, 
+          cholmod_sparse *R = cholmod_allocate_sparse (n, 1, n, false, true,
                                                        0, CHOLMOD_PATTERN, cm);
           octave_idx_type *Rp = static_cast<octave_idx_type *>(R->p);
           octave_idx_type *Ri = static_cast<octave_idx_type *>(R->i);
 
           // compute L one row at a time
           for (octave_idx_type k = 0 ; k < n ; k++)
             {
               // get the kth row of L and store in the columns of L
diff --git a/src/DLD-FUNCTIONS/symrcm.cc b/src/DLD-FUNCTIONS/symrcm.cc
--- a/src/DLD-FUNCTIONS/symrcm.cc
+++ b/src/DLD-FUNCTIONS/symrcm.cc
@@ -78,26 +78,26 @@ struct CMK_Node
 };
 
 // A simple queue.
 // Queues Q have a fixed maximum size N (rows,cols of the matrix) and are
 // stored in an array. qh and qt point to queue head and tail.
 
 // Enqueue operation (adds a node "o" at the tail)
 
-inline static void 
+inline static void
 Q_enq (CMK_Node *Q, octave_idx_type N, octave_idx_type& qt, const CMK_Node& o)
-{       
+{
   Q[qt] = o;
   qt = (qt + 1) % (N + 1);
 }
 
 // Dequeue operation (removes a node from the head)
 
-inline static CMK_Node 
+inline static CMK_Node
 Q_deq (CMK_Node * Q, octave_idx_type N, octave_idx_type& qh)
 {
   CMK_Node r = Q[qh];
   qh = (qh + 1) % (N + 1);
   return r;
 }
 
 // Predicate (queue empty)
@@ -110,17 +110,17 @@ Q_deq (CMK_Node * Q, octave_idx_type N, 
 // the right descendant of entry i
 #define RIGHT(i)        (((i) << 1) + 2)        // = (2*(i)+2)
 // the parent of entry i
 #define PARENT(i)       (((i) - 1) >> 1)        // = floor(((i)-1)/2)
 
 // Builds a min-heap (the root contains the smallest element). A is an array
 // with the graph's nodes, i is a starting position, size is the length of A.
 
-static void 
+static void
 H_heapify_min (CMK_Node *A, octave_idx_type i, octave_idx_type size)
 {
   octave_idx_type j = i;
   for (;;)
     {
       octave_idx_type l = LEFT(j);
       octave_idx_type r = RIGHT(j);
 
@@ -135,72 +135,72 @@ H_heapify_min (CMK_Node *A, octave_idx_t
 
       if (smallest != j)
         {
           CMK_Node tmp = A[j];
           A[j] = A[smallest];
           A[smallest] = tmp;
           j = smallest;
         }
-      else 
+      else
         break;
     }
 }
 
 // Heap operation insert. Running time is O(log(n))
 
-static void 
+static void
 H_insert (CMK_Node *H, octave_idx_type& h, const CMK_Node& o)
 {
   octave_idx_type i = h++;
 
   H[i] = o;
 
-  if (i == 0) 
+  if (i == 0)
     return;
   do
     {
       octave_idx_type p = PARENT(i);
       if (H[i].deg < H[p].deg)
         {
           CMK_Node tmp = H[i];
           H[i] = H[p];
           H[p] = tmp;
 
           i = p;
         }
-      else 
+      else
         break;
     }
   while (i > 0);
 }
 
 // Heap operation remove-min. Removes the smalles element in O(1) and
 // reorganizes the heap optionally in O(log(n))
 
-inline static CMK_Node 
+inline static CMK_Node
 H_remove_min (CMK_Node *H, octave_idx_type& h, int reorg/*=1*/)
 {
   CMK_Node r = H[0];
   H[0] = H[--h];
-  if (reorg) 
+  if (reorg)
     H_heapify_min(H, 0, h);
   return r;
 }
 
 // Predicate (heap empty)
 #define H_empty(H, h)   ((h) == 0)
 
 // Helper function for the Cuthill-McKee algorithm. Tries to determine a
 // pseudo-peripheral node of the graph as starting node.
 
-static octave_idx_type 
-find_starting_node (octave_idx_type N, const octave_idx_type *ridx, 
-                    const octave_idx_type *cidx, const octave_idx_type *ridx2, 
-                    const octave_idx_type *cidx2, octave_idx_type *D, 
+static octave_idx_type
+find_starting_node (octave_idx_type N, const octave_idx_type *ridx,
+                    const octave_idx_type *cidx, const octave_idx_type *ridx2,
+                    const octave_idx_type *cidx2, octave_idx_type *D,
                     octave_idx_type start)
 {
   CMK_Node w;
 
   OCTAVE_LOCAL_BUFFER (CMK_Node, Q, N+1);
   boolNDArray btmp (dim_vector (1, N), false);
   bool *visit = btmp.fortran_vec ();
 
@@ -322,37 +322,37 @@ find_starting_node (octave_idx_type N, c
         }
       else
         break;
     }
   return x.id;
 }
 
 // Calculates the node's degrees. This means counting the non-zero elements
-// in the symmetric matrix' rows. This works for non-symmetric matrices 
+// in the symmetric matrix' rows. This works for non-symmetric matrices
 // as well.
 
-static octave_idx_type 
-calc_degrees (octave_idx_type N, const octave_idx_type *ridx, 
+static octave_idx_type
+calc_degrees (octave_idx_type N, const octave_idx_type *ridx,
               const octave_idx_type *cidx, octave_idx_type *D)
 {
   octave_idx_type max_deg = 0;
 
-  for (octave_idx_type i = 0; i < N; i++) 
+  for (octave_idx_type i = 0; i < N; i++)
     D[i] = 0;
 
   for (octave_idx_type j = 0; j < N; j++)
     {
       for (octave_idx_type i = cidx[j]; i < cidx[j+1]; i++)
         {
           OCTAVE_QUIT;
           octave_idx_type k = ridx[i];
           // there is a non-zero element (k,j)
           D[k]++;
-          if (D[k] > max_deg) 
+          if (D[k] > max_deg)
             max_deg = D[k];
           // if there is no element (j,k) there is one in
           // the symmetric matrix:
           if (k != j)
             {
               bool found = false;
               for (octave_idx_type l = cidx[k]; l < cidx[k + 1]; l++)
                 {
@@ -366,30 +366,30 @@ calc_degrees (octave_idx_type N, const o
                   else if (ridx[l] > j)
                     break;
                 }
 
               if (! found)
                 {
                   // A(j,k) == 0
                   D[j]++;
-                  if (D[j] > max_deg) 
+                  if (D[j] > max_deg)
                     max_deg = D[j];
                 }
             }
         }
     }
   return max_deg;
 }
 
 // Transpose of the structure of a square sparse matrix
 
 static void
-transpose (octave_idx_type N, const octave_idx_type *ridx, 
-           const octave_idx_type *cidx, octave_idx_type *ridx2, 
+transpose (octave_idx_type N, const octave_idx_type *ridx,
+           const octave_idx_type *cidx, octave_idx_type *ridx2,
            octave_idx_type *cidx2)
 {
   octave_idx_type nz = cidx[N];
 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, w, N + 1);
   for (octave_idx_type i = 0; i < N; i++)
     w[i] = 0;
   for (octave_idx_type i = 0; i < nz; i++)
@@ -446,17 +446,17 @@ Mathematics, ISBN 0-13-165274-5, 1981.\n
   if (nargin != 1)
     {
       print_usage ();
       return retval;
     }
 
   octave_value arg = args(0);
 
-  // the parameter of the matrix is converted into a sparse matrix 
+  // the parameter of the matrix is converted into a sparse matrix
   //(if necessary)
   octave_idx_type *cidx;
   octave_idx_type *ridx;
   SparseMatrix Ar;
   SparseComplexMatrix Ac;
 
   if (arg.is_real_type ())
     {
@@ -506,17 +506,17 @@ Mathematics, ISBN 0-13-165274-5, 1981.\n
   // compute the node degrees
   OCTAVE_LOCAL_BUFFER (octave_idx_type, D, N);
   octave_idx_type max_deg = calc_degrees (N, ridx, cidx, D);
 
   // if none of the nodes has a degree > 0 (a matrix of zeros)
   // the return value corresponds to the identity permutation
   if (max_deg == 0)
     {
-      for (octave_idx_type i = 0; i < N; i++) 
+      for (octave_idx_type i = 0; i < N; i++)
         P(i) = i;
       return octave_value (P);
     }
 
   // a heap for the a node's neighbors. The number of neighbors is
   // limited by the maximum degree max_deg:
   OCTAVE_LOCAL_BUFFER (CMK_Node, S, max_deg);
 
@@ -530,31 +530,31 @@ Mathematics, ISBN 0-13-165274-5, 1981.\n
   // upper bound for the bandwidth (=quality of solution)
   // initialize the bandwidth of the graph with 0. B contains the
   // the maximum of the theoretical lower limits of the subgraphs
   // bandwidths.
   octave_idx_type B = 0;
 
   // mark all nodes as unvisited; with the exception of the nodes
   // that have degree==0 and build a CC of the graph.
-        
+
   boolNDArray btmp (dim_vector (1, N), false);
   bool *visit = btmp.fortran_vec ();
 
   do
     {
       // locate an unvisited starting node of the graph
       octave_idx_type i;
       for (i = 0; i < N; i++)
-        if (! visit[i]) 
+        if (! visit[i])
           break;
 
       // locate a probably better starting node
       v.id = find_starting_node (N, ridx, cidx, ridx2, cidx2, D, i);
-                
+
       // mark the node as visited and enqueue it (a starting node
       // for the BFS). Since the node will be a root of a spanning
       // tree, its dist is 0.
       v.deg = D[v.id];
       v.dist = 0;
       visit[v.id] = true;
       Q_enq (Q, N, qt, v);
 
@@ -562,28 +562,28 @@ Mathematics, ISBN 0-13-165274-5, 1981.\n
       // keep a "level" in the spanning tree (= min. distance to the
       // root) for determining the bandwidth of the computed
       // permutation P
       octave_idx_type Bsub = 0;
       // min. dist. to the root is 0
       octave_idx_type level = 0;
       // the root is the first/only node on level 0
       octave_idx_type level_N = 1;
-        
+
       while (! Q_empty (Q, N, qh, qt))
         {
           v = Q_deq (Q, N, qh);
           i = v.id;
 
           c++;
 
           // for computing the inverse permutation P where
           // A(inv(P),inv(P)) or P'*A*P is banded
           //         P(i) = c;
-                        
+
           // for computing permutation P where
           // A(P(i),P(j)) or P*A*P' is banded
           P(c) = i;
 
           // put all unvisited neighbors j of node i on the heap
           s = 0;
           octave_idx_type j1 = cidx[i];
           octave_idx_type j2 = cidx2[i];
@@ -652,42 +652,42 @@ Mathematics, ISBN 0-13-165274-5, 1981.\n
 
           // add the neighbors to the queue (sorted by node degree)
           while (! H_empty (S, s))
             {
               OCTAVE_QUIT;
 
               // locate a neighbor of i with minimal degree in O(log(N))
               v = H_remove_min(S, s, 1);
-        
+
               // entered the BFS a new level?
               if (v.dist > level)
                 {
                   // adjustment of bandwith:
                   // "[...] the minimum bandwidth that
                   // can be obtained [...] is the
                   //  maximum number of nodes per level"
                   if (Bsub < level_N)
                     Bsub = level_N;
-        
+
                   level = v.dist;
                   // v is the first node on the new level
                   level_N = 1;
                 }
               else
                 {
                   // there is no new level but another node on
                   // this level:
                   level_N++;
                 }
-        
+
               // enqueue v in O(1)
               Q_enq (Q, N, qt, v);
             }
-        
+
           // synchronize the bandwidth with level_N once again:
           if (Bsub < level_N)
             Bsub = level_N;
         }
       // finish of BFS. If there are still unvisited nodes in the graph
       // then it is split into CCs. The computed bandwidth is the maximum
       // of all subgraphs. Update:
       if (Bsub > B)
diff --git a/src/DLD-FUNCTIONS/tril.cc b/src/DLD-FUNCTIONS/tril.cc
--- a/src/DLD-FUNCTIONS/tril.cc
+++ b/src/DLD-FUNCTIONS/tril.cc
@@ -34,26 +34,26 @@ along with Octave; see the file COPYING.
 #include "Cell.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "oct-obj.h"
 
 // The bulk of the work.
 template <class T>
-static Array<T> 
+static Array<T>
 do_tril (const Array<T>& a, octave_idx_type k, bool pack)
 {
   octave_idx_type nr = a.rows (), nc = a.columns ();
   const T *avec = a.fortran_vec ();
   octave_idx_type zero = 0;
 
   if (pack)
     {
-      octave_idx_type j1 = std::min (std::max (zero, k), nc); 
+      octave_idx_type j1 = std::min (std::max (zero, k), nc);
       octave_idx_type j2 = std::min (std::max (zero, nr + k), nc);
       octave_idx_type n = j1 * nr + ((j2 - j1) * (nr-(j1-k) + nr-(j2-1-k))) / 2;
       Array<T> r (dim_vector (n, 1));
       T *rvec = r.fortran_vec ();
       for (octave_idx_type j = 0; j < nc; j++)
         {
           octave_idx_type ii = std::min (std::max (zero, j - k), nr);
           rvec = std::copy (avec + ii, avec + nr, rvec);
@@ -75,26 +75,26 @@ do_tril (const Array<T>& a, octave_idx_t
           rvec += nr;
         }
 
       return r;
     }
 }
 
 template <class T>
-static Array<T> 
+static Array<T>
 do_triu (const Array<T>& a, octave_idx_type k, bool pack)
 {
   octave_idx_type nr = a.rows (), nc = a.columns ();
   const T *avec = a.fortran_vec ();
   octave_idx_type zero = 0;
 
   if (pack)
     {
-      octave_idx_type j1 = std::min (std::max (zero, k), nc); 
+      octave_idx_type j1 = std::min (std::max (zero, k), nc);
       octave_idx_type j2 = std::min (std::max (zero, nr + k), nc);
       octave_idx_type n = ((j2 - j1) * ((j1+1-k) + (j2-k))) / 2 + (nc - j2) * nr;
       Array<T> r (dim_vector (n, 1));
       T *rvec = r.fortran_vec ();
       for (octave_idx_type j = 0; j < nc; j++)
         {
           octave_idx_type ii = std::min (std::max (zero, j + 1 - k), nr);
           rvec = std::copy (avec, avec + ii, rvec);
@@ -119,17 +119,17 @@ do_triu (const Array<T>& a, octave_idx_t
       return r;
     }
 }
 
 // These two are by David Bateman.
 // FIXME: optimizations possible. "pack" support missing.
 
 template <class T>
-static Sparse<T> 
+static Sparse<T>
 do_tril (const Sparse<T>& a, octave_idx_type k, bool pack)
 {
   if (pack) // FIXME
     {
       error ("tril: \"pack\" not implemented for sparse matrices");
       return Sparse<T> ();
     }
 
@@ -141,17 +141,17 @@ do_tril (const Sparse<T>& a, octave_idx_
       if (m.ridx(i) < j-k)
         m.data(i) = 0.;
 
   m.maybe_compress (true);
   return m;
 }
 
 template <class T>
-static Sparse<T> 
+static Sparse<T>
 do_triu (const Sparse<T>& a, octave_idx_type k, bool pack)
 {
   if (pack) // FIXME
     {
       error ("triu: \"pack\" not implemented for sparse matrices");
       return Sparse<T> ();
     }
 
@@ -196,17 +196,17 @@ do_trilu (const std::string& name,
     {
       pack = args(nargin-1).string_value () == "pack";
       nargin--;
     }
 
   if (nargin == 2)
     {
       k = args(1).int_value (true);
-      
+
       if (error_state)
         return retval;
     }
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   else
     {
@@ -257,32 +257,32 @@ do_trilu (const std::string& name,
 #undef ARRAYCASE
             default:
               {
                 // Generic code that works on octave-values, that is slow
                 // but will also work on arbitrary user types
 
                 if (pack) // FIXME
                   {
-                    error ("%s: \"pack\" not implemented for class %s", 
+                    error ("%s: \"pack\" not implemented for class %s",
                            name.c_str (), arg.class_name ().c_str ());
                     return octave_value ();
                   }
 
                 octave_value tmp = arg;
                 if (arg.numel () == 0)
                   return arg;
 
                 octave_idx_type nr = dims(0), nc = dims (1);
 
                 // The sole purpose of the below is to force the correct
                 // matrix size. This would not be necessary if the
                 // octave_value resize function allowed a fill_value.
                 // It also allows odd attributes in some user types
-                // to be handled. With a fill_value ot should be replaced 
+                // to be handled. With a fill_value ot should be replaced
                 // with
                 //
                 // octave_value_list ov_idx;
                 // tmp = tmp.resize(dim_vector (0,0)).resize (dims, fill_value);
 
                 octave_value_list ov_idx;
                 std::list<octave_value_list> idx_tmp;
                 ov_idx(1) = static_cast<double> (nc+1);
@@ -405,24 +405,24 @@ DEFUN_DLD (triu, args, ,
 {
   return do_trilu ("triu", args);
 }
 
 /*
 
 %!test
 %! a = [1, 2, 3; 4, 5, 6; 7, 8, 9; 10, 11, 12];
-%! 
+%!
 %! l0 = [1, 0, 0; 4, 5, 0; 7, 8, 9; 10, 11, 12];
 %! l1 = [1, 2, 0; 4, 5, 6; 7, 8, 9; 10, 11, 12];
 %! l2 = [1, 2, 3; 4, 5, 6; 7, 8, 9; 10, 11, 12];
 %! lm1 = [0, 0, 0; 4, 0, 0; 7, 8, 0; 10, 11, 12];
 %! lm2 = [0, 0, 0; 0, 0, 0; 7, 0, 0; 10, 11, 0];
 %! lm3 = [0, 0, 0; 0, 0, 0; 0, 0, 0; 10, 0, 0];
 %! lm4 = [0, 0, 0; 0, 0, 0; 0, 0, 0; 0, 0, 0];
-%! 
+%!
 %! assert((tril (a, -4) == lm4 && tril (a, -3) == lm3
 %! && tril (a, -2) == lm2 && tril (a, -1) == lm1
 %! && tril (a) == l0 && tril (a, 1) == l1 && tril (a, 2) == l2));
 
 %!error tril ();
 
 */
diff --git a/src/DLD-FUNCTIONS/tsearch.cc b/src/DLD-FUNCTIONS/tsearch.cc
--- a/src/DLD-FUNCTIONS/tsearch.cc
+++ b/src/DLD-FUNCTIONS/tsearch.cc
@@ -35,36 +35,36 @@ along with Octave; see the file COPYING.
 
 #include "defun-dld.h"
 #include "error.h"
 #include "oct-obj.h"
 #include "parse.h"
 
 inline double max (double a, double b, double c)
 {
-  if (a < b) 
+  if (a < b)
     return (b < c ? c : b);
-  else 
+  else
     return (a < c ? c : a);
 }
 
 inline double min (double a, double b, double c)
 {
-  if (a > b) 
+  if (a > b)
     return (b > c ? c : b);
-  else 
+  else
     return (a > c ? c : a);
 }
 
 #define REF(x,k,i) x(static_cast<octave_idx_type>(elem((k), (i))) - 1)
 
 // for large data set the algorithm is very slow
 // one should presort (how?) either the elements of the points of evaluation
-// to cut down the time needed to decide which triangle contains the 
-// given point 
+// to cut down the time needed to decide which triangle contains the
+// given point
 
 // e.g., build up a neighbouring triangle structure and use a simplex-like
 // method to traverse it
 
 DEFUN_DLD (tsearch, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{idx} =} tsearch (@var{x}, @var{y}, @var{t}, @var{xi}, @var{yi})\n\
 Search for the enclosing Delaunay convex hull.  For @code{@var{t} =\n\
@@ -78,101 +78,101 @@ points @code{(@var{xi}, @var{yi})}.  For
 
   octave_value_list retval;
   const int nargin = args.length ();
   if (nargin != 5)
     {
       print_usage ();
       return retval;
     }
-  
+
   const ColumnVector x (args(0).vector_value ());
   const ColumnVector y (args(1).vector_value ());
   const Matrix elem (args(2).matrix_value ());
   const ColumnVector xi (args(3).vector_value ());
   const ColumnVector yi (args(4).vector_value ());
 
   if (error_state)
     return retval;
 
   const octave_idx_type nelem = elem.rows ();
 
   ColumnVector minx (nelem);
   ColumnVector maxx (nelem);
   ColumnVector miny (nelem);
   ColumnVector maxy (nelem);
-  for (octave_idx_type k = 0; k < nelem; k++) 
+  for (octave_idx_type k = 0; k < nelem; k++)
     {
       minx(k) = min (REF (x, k, 0), REF (x, k, 1), REF (x, k, 2)) - eps;
       maxx(k) = max (REF (x, k, 0), REF (x, k, 1), REF (x, k, 2)) + eps;
       miny(k) = min (REF (y, k, 0), REF (y, k, 1), REF (y, k, 2)) - eps;
       maxy(k) = max (REF (y, k, 0), REF (y, k, 1), REF (y, k, 2)) + eps;
     }
 
   const octave_idx_type np = xi.length ();
   ColumnVector values (np);
 
   double x0 = 0.0, y0 = 0.0;
   double a11 = 0.0, a12 = 0.0, a21 = 0.0, a22 = 0.0, det = 0.0;
 
   octave_idx_type k = nelem; // k is a counter of elements
-  for (octave_idx_type kp = 0; kp < np; kp++) 
+  for (octave_idx_type kp = 0; kp < np; kp++)
     {
-      const double xt = xi(kp); 
+      const double xt = xi(kp);
       const double yt = yi(kp);
-    
+
       // check if last triangle contains the next point
-      if (k < nelem) 
-        { 
+      if (k < nelem)
+        {
           const double dx1 = xt - x0;
           const double dx2 = yt - y0;
           const double c1 = (a22 * dx1 - a21 * dx2) / det;
           const double c2 = (-a12 * dx1 + a11 * dx2) / det;
-          if (c1 >= -eps && c2 >= -eps && (c1 + c2) <= (1 + eps)) 
+          if (c1 >= -eps && c2 >= -eps && (c1 + c2) <= (1 + eps))
             {
               values(kp) = double(k+1);
               continue;
             }
         }
-    
+
       // it doesn't, so go through all elements
-      for (k = 0; k < nelem; k++) 
-        { 
+      for (k = 0; k < nelem; k++)
+        {
           OCTAVE_QUIT;
           if (xt >= minx(k) && xt <= maxx(k) && yt >= miny(k) && yt <= maxy(k))
             {
               // element inside the minimum rectangle: examine it closely
               x0  = REF (x, k, 0);
               y0  = REF (y, k, 0);
               a11 = REF (x, k, 1) - x0;
               a12 = REF (y, k, 1) - y0;
               a21 = REF (x, k, 2) - x0;
               a22 = REF (y, k, 2) - y0;
               det = a11 * a22 - a21 * a12;
-        
+
               // solve the system
               const double dx1 = xt - x0;
               const double dx2 = yt - y0;
               const double c1 = (a22 * dx1 - a21 * dx2) / det;
               const double c2 = (-a12 * dx1 + a11 * dx2) / det;
-              if ((c1 >= -eps) && (c2 >= -eps) && ((c1 + c2) <= (1 + eps))) 
+              if ((c1 >= -eps) && (c2 >= -eps) && ((c1 + c2) <= (1 + eps)))
                 {
                   values(kp) = double(k+1);
                   break;
                 }
             } //endif # examine this element closely
         } //endfor # each element
 
-      if (k == nelem) 
+      if (k == nelem)
         values(kp) = lo_ieee_nan_value ();
-    
+
     } //endfor # kp
-  
+
   retval(0) = values;
-  
+
   return retval;
 }
 
 /*
 %!shared x, y, tri
 %! x = [-1;-1;1];
 %! y = [-1;1;-1];
 %! tri = [1, 2, 3];
diff --git a/src/DLD-FUNCTIONS/typecast.cc b/src/DLD-FUNCTIONS/typecast.cc
--- a/src/DLD-FUNCTIONS/typecast.cc
+++ b/src/DLD-FUNCTIONS/typecast.cc
@@ -40,17 +40,17 @@ get_vec_dims (const dim_vector& old_dims
     return dim_vector (1, n);
   else if (old_dims.length () == 2 && old_dims (0) == 0 && old_dims (1) == 0)
     return dim_vector ();
   else
     return dim_vector (n, 1);
 }
 
 template <class ArrayType>
-static void 
+static void
 get_data_and_bytesize (const ArrayType& array,
                        const void *& data,
                        octave_idx_type& byte_size,
                        dim_vector& old_dims,
                        unwind_protect& frame)
 {
   // The array given may be a temporary, constructed from a scalar or sparse
   // array. This will ensure the data will be deallocated after we exit.
diff --git a/src/DLD-FUNCTIONS/urlwrite.cc b/src/DLD-FUNCTIONS/urlwrite.cc
--- a/src/DLD-FUNCTIONS/urlwrite.cc
+++ b/src/DLD-FUNCTIONS/urlwrite.cc
@@ -50,17 +50,17 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CURL
 
 #include <curl/curl.h>
 #include <curl/curlver.h>
 #include <curl/types.h>
 #include <curl/easy.h>
 
-static int 
+static int
 write_data (void *buffer, size_t size, size_t nmemb, void *streamp)
 {
   std::ostream& stream = *(static_cast<std::ostream*> (streamp));
   stream.write (static_cast<const char*> (buffer), size*nmemb);
   return (stream.fail () ? 0 : size * nmemb);
 }
 
 static int
@@ -69,17 +69,17 @@ read_data (void *buffer, size_t size, si
   std::istream& stream = *(static_cast<std::istream*> (streamp));
   stream.read (static_cast<char*> (buffer), size*nmemb);
   if (stream.eof ())
     return stream.gcount ();
   else
     return (stream.fail () ? 0 : size * nmemb);
 }
 
-static size_t 
+static size_t
 throw_away (void *, size_t size, size_t nmemb, void *)
 {
   return static_cast<size_t>(size * nmemb);
 }
 
 class
 curl_handle
 {
@@ -148,64 +148,64 @@ private:
     bool ascii;
 
   private:
     CURL *curl;
 
     // No copying!
 
     curl_handle_rep (const curl_handle_rep& ov);
-    
+
     curl_handle_rep& operator = (const curl_handle_rep&);
   };
 
 public:
 
 // I'd love to rewrite this as a private method of the curl_handle
 // class, but you can't pass the va_list from the wrapper setopt to
 // the curl_easy_setopt function.
 #define setopt(option, parameter) \
   { \
     CURLcode res = curl_easy_setopt (rep->handle (), option, parameter); \
     if (res != CURLE_OK) \
       error ("%s", curl_easy_strerror (res)); \
   }
 
-  curl_handle (void) : rep (new curl_handle_rep ()) 
-    { 
+  curl_handle (void) : rep (new curl_handle_rep ())
+    {
       rep->valid = false;
     }
 
-  curl_handle (const std::string& _host, const std::string& user, 
+  curl_handle (const std::string& _host, const std::string& user,
                const std::string& passwd) :
     rep (new curl_handle_rep ())
     {
       rep->host = _host;
       init (user, passwd, std::cin, octave_stdout);
 
       std::string url = "ftp://" + _host;
       setopt (CURLOPT_URL, url.c_str());
 
       // Setup the link, with no transfer
       if (!error_state)
         perform ();
     }
 
-  curl_handle (const std::string& url, const std::string& method, 
+  curl_handle (const std::string& url, const std::string& method,
                const Cell& param, std::ostream& os, bool& retval) :
     rep (new curl_handle_rep ())
     {
       retval = false;
 
       init ("", "", std::cin, os);
 
       setopt (CURLOPT_NOBODY, 0);
 
       // Don't need to store the parameters here as we can't change
-      // the URL after the handle is created 
+      // the URL after the handle is created
       std::string query_string = form_query_string (param);
 
       if (method == "get")
         {
           query_string = url + "?" + query_string;
           setopt (CURLOPT_URL, query_string.c_str ());
         }
       else if (method == "post")
@@ -249,17 +249,17 @@ public:
       return rep->is_valid ();
     }
 
   std::string lasterror (void) const
     {
       CURLcode errnum;
 
       curl_easy_getinfo (rep->handle(), CURLINFO_OS_ERRNO, &errnum);
-      
+
       return std::string (curl_easy_strerror (errnum));
     }
 
   void set_ostream (std::ostream& os) const
     {
       setopt (CURLOPT_WRITEDATA, static_cast<void*> (&os));
     }
 
@@ -267,23 +267,23 @@ public:
     {
       setopt (CURLOPT_READDATA, static_cast<void*> (&is));
     }
 
   void ascii (void) const
     {
       setopt (CURLOPT_TRANSFERTEXT, 1);
       rep->ascii = true;
-    } 
+    }
 
   void binary (void) const
     {
       setopt (CURLOPT_TRANSFERTEXT, 0);
       rep->ascii = false;
-    } 
+    }
 
   bool is_ascii (void) const
     {
       return rep->is_ascii ();
     }
 
   bool is_binary (void) const
     {
@@ -433,24 +433,24 @@ public:
             break;
 
           retval(i) = str.substr(pos, newpos - pos);
           pos = newpos + 1;
         }
       return retval;
     }
 
-  void get_fileinfo (const std::string& filename, double& filesize, 
+  void get_fileinfo (const std::string& filename, double& filesize,
                      time_t& filetime, bool& fileisdir) const
     {
       std::string path = pwd();
 
       std::string url = "ftp://" + rep->host + "/" + path + "/" + filename;
       setopt (CURLOPT_URL, url.c_str());
-      setopt (CURLOPT_FILETIME, 1); 
+      setopt (CURLOPT_FILETIME, 1);
       setopt (CURLOPT_HEADERFUNCTION, throw_away);
       setopt (CURLOPT_WRITEFUNCTION, throw_away);
 
       // FIXME
       // The MDTM command fails for a directory on the servers I tested
       // so this is a means of testing for directories. It also means
       // I can't get the date of directories!
       if (! error_state)
@@ -463,25 +463,25 @@ public:
             }
           else
             {
               fileisdir = false;
               time_t ft;
               curl_easy_getinfo(rep->handle (), CURLINFO_FILETIME, &ft);
               filetime = ft;
               double fs;
-              curl_easy_getinfo(rep->handle (), 
+              curl_easy_getinfo(rep->handle (),
                                 CURLINFO_CONTENT_LENGTH_DOWNLOAD, &fs);
               filesize = fs;
             }
         }
 
       setopt (CURLOPT_WRITEFUNCTION, write_data);
       setopt (CURLOPT_HEADERFUNCTION, 0);
-      setopt (CURLOPT_FILETIME, 0); 
+      setopt (CURLOPT_FILETIME, 0);
       url = "ftp://" + rep->host;
       setopt (CURLOPT_URL, url.c_str());
 
       // The MDTM command seems to reset the path to the root with the
       // servers I tested with, so cd again into the correct path. Make
       // the path absolute so that this will work even with servers that
       // don't end up in the root after an MDTM command.
       cwd ("/" + path);
@@ -529,37 +529,37 @@ private:
       std::ostringstream query;
 
       for (int i = 0; i < param.numel (); i += 2)
         {
           std::string name = param(i).string_value ();
           std::string text = param(i+1).string_value ();
 
           // Encode strings.
-          char *enc_name = curl_easy_escape (rep->handle(), name.c_str (), 
+          char *enc_name = curl_easy_escape (rep->handle(), name.c_str (),
                                              name.length ());
-          char *enc_text = curl_easy_escape (rep->handle(), text.c_str (), 
+          char *enc_text = curl_easy_escape (rep->handle(), text.c_str (),
                                              text.length ());
 
           query << enc_name << "=" << enc_text;
 
           curl_free (enc_name);
           curl_free (enc_text);
 
           if (i < param.numel()-1)
             query << "&";
         }
 
       query.flush ();
 
       return query.str ();
     }
 
-  void init (const std::string& user, const std::string& passwd, 
-             std::istream& is, std::ostream& os) 
+  void init (const std::string& user, const std::string& passwd,
+             std::istream& is, std::ostream& os)
     {
       // No data transfer by default
       setopt (CURLOPT_NOBODY, 1);
 
       // Set the username and password
       std::string userpwd = user;
       if (! passwd.empty ())
         userpwd += ":" + passwd;
@@ -603,18 +603,18 @@ public:
 
   typedef std::map<std::string, curl_handle>::iterator iterator;
   typedef std::map<std::string, curl_handle>::const_iterator const_iterator;
 
   curl_handles (void) : map ()
    {
      curl_global_init(CURL_GLOBAL_DEFAULT);
    }
-  
-  ~curl_handles (void) 
+
+  ~curl_handles (void)
     {
       // Remove the elements of the map explicitly as they should
       // be deleted before the call to curl_global_cleanup
       map.erase (begin(), end());
 
       curl_global_cleanup ();
     }
 
@@ -624,17 +624,17 @@ public:
   iterator end (void) { return iterator (map.end ()); }
   const_iterator end (void) const { return const_iterator (map.end ()); }
 
   iterator seek (const std::string& k) { return map.find (k); }
   const_iterator seek (const std::string& k) const { return map.find (k); }
 
   std::string key (const_iterator p) const { return p->first; }
 
-  curl_handle& contents (const std::string& k) 
+  curl_handle& contents (const std::string& k)
     {
       return map[k];
     }
 
   curl_handle contents (const std::string& k) const
     {
       const_iterator p = seek (k);
       return p != end () ? p->second : curl_handle ();
@@ -979,27 +979,27 @@ Undocumented internal function\n\
   std::string passwd = "";
 
   if (nargin < 2 || nargin > 4)
     error ("incorrect number of arguments");
   else
     {
       handle = args(0).string_value ();
       host = args(1).string_value ();
-  
+
       if (nargin > 1)
         user = args(2).string_value ();
 
       if (nargin > 2)
         passwd = args(3).string_value ();
-  
+
       if (!error_state)
         {
           handles.contents (handle) = curl_handle (host, user, passwd);
-          
+
           if (error_state)
             handles.del (handle);
         }
     }
 #else
   error ("__ftp__: not available in this version of Octave");
 #endif
 
@@ -1106,34 +1106,34 @@ Undocumented internal function\n\
                   if (n == 0)
                     {
                       string_vector flds (5);
                       flds(0) = "name";
                       flds(1) = "date";
                       flds(2) = "bytes";
                       flds(3) = "isdir";
                       flds(4) = "datenum";
-                      retval = octave_map (flds); 
+                      retval = octave_map (flds);
                     }
                   else
                     {
                       octave_map st;
                       Cell filectime (dim_vector (n, 1));
                       Cell filesize (dim_vector (n, 1));
                       Cell fileisdir (dim_vector (n, 1));
                       Cell filedatenum (dim_vector (n, 1));
-                    
+
                       st.assign ("name", Cell (sv));
 
                       for (octave_idx_type i = 0; i < n; i++)
                         {
                           time_t ftime;
                           bool fisdir;
                           double fsize;
-                      
+
                           curl.get_fileinfo (sv(i), fsize, ftime, fisdir);
 
                           fileisdir (i) = fisdir;
                           filectime (i) = ctime (&ftime);
                           filesize (i) = fsize;
                           filedatenum (i) = double (ftime);
                         }
                       st.assign ("date", filectime);
@@ -1415,28 +1415,28 @@ Undocumented internal function\n\
 static string_vector
 mput_directory (const curl_handle& curl, const std::string& base,
                 const std::string& dir)
 {
   string_vector retval;
 
   if (! curl.mkdir (dir, false))
     warning ("__ftp_mput__: can not create the remote directory ""%s""",
-             (base.length() == 0 ? dir : base + 
+             (base.length() == 0 ? dir : base +
               file_ops::dir_sep_str () + dir).c_str ());
 
   curl.cwd (dir);
 
   if (! error_state)
     {
       unwind_protect_safe frame;
 
       frame.add_fcn (reset_path, curl);
 
-      std::string realdir = base.length() == 0 ? dir : base + 
+      std::string realdir = base.length() == 0 ? dir : base +
                          file_ops::dir_sep_str () + dir;
 
       dir_entry dirlist (realdir);
 
       if (dirlist)
         {
           string_vector files = dirlist.read ();
 
@@ -1447,54 +1447,54 @@ mput_directory (const curl_handle& curl,
               if (file == "." || file == "..")
                 continue;
 
               std::string realfile = realdir + file_ops::dir_sep_str () + file;
               file_stat fs (realfile);
 
               if (! fs.exists ())
                 {
-                  error ("__ftp__mput: file ""%s"" does not exist", 
+                  error ("__ftp__mput: file ""%s"" does not exist",
                          realfile.c_str ());
                   break;
                 }
 
               if (fs.is_dir ())
                 {
                   retval.append (mput_directory (curl, realdir, file));
 
                   if (error_state)
                     break;
                 }
               else
                 {
                   // FIXME Does ascii mode need to be flagged here?
-                  std::ifstream ifile (realfile.c_str(), std::ios::in | 
+                  std::ifstream ifile (realfile.c_str(), std::ios::in |
                                        std::ios::binary);
 
                   if (! ifile.is_open ())
                     {
-                      error ("__ftp_mput__: unable to open file ""%s""", 
+                      error ("__ftp_mput__: unable to open file ""%s""",
                              realfile.c_str ());
                       break;
                     }
 
                   curl.put (file, ifile);
 
                   ifile.close ();
 
                   if (error_state)
                     break;
 
                   retval.append (realfile);
                 }
             }
         }
       else
-        error ("__ftp_mput__: can not read the directory ""%s""", 
+        error ("__ftp_mput__: can not read the directory ""%s""",
                realdir.c_str());
     }
 
   return retval;
 }
 #endif
 
 DEFUN_DLD (__ftp_mput__, args, nargout,
@@ -1540,17 +1540,17 @@ Undocumented internal function\n\
                     {
                       retval.append (mput_directory (curl, "", file));
                       if (error_state)
                         break;
                     }
                   else
                     {
                       // FIXME Does ascii mode need to be flagged here?
-                      std::ifstream ifile (file.c_str(), std::ios::in | 
+                      std::ifstream ifile (file.c_str(), std::ios::in |
                                            std::ios::binary);
 
                       if (! ifile.is_open ())
                         {
                           error ("__ftp_mput__: unable to open file");
                           break;
                         }
 
@@ -1573,29 +1573,29 @@ Undocumented internal function\n\
   error ("__ftp_mput__: not available in this version of Octave");
 #endif
 
   return (nargout > 0 ? octave_value (retval) : octave_value ());
 }
 
 #ifdef HAVE_CURL
 static void
-getallfiles (const curl_handle& curl, const std::string& dir, 
+getallfiles (const curl_handle& curl, const std::string& dir,
              const std::string& target)
 {
   std::string sep = file_ops::dir_sep_str ();
   file_stat fs (dir);
 
   if (!fs || !fs.is_dir ())
-    { 
+    {
       std::string msg;
       int status = octave_mkdir (dir, 0777, msg);
 
       if (status < 0)
-        error ("__ftp_mget__: can't create directory %s%s%s. %s", 
+        error ("__ftp_mget__: can't create directory %s%s%s. %s",
                target.c_str(), sep.c_str(), dir.c_str(), msg.c_str());
     }
 
   if (! error_state)
     {
       curl.cwd (dir);
 
       if (! error_state)
@@ -1606,26 +1606,26 @@ getallfiles (const curl_handle& curl, co
 
           string_vector sv = curl.list ();
 
           for (octave_idx_type i = 0; i < sv.length (); i++)
             {
               time_t ftime;
               bool fisdir;
               double fsize;
-                      
+
               curl.get_fileinfo (sv(i), fsize, ftime, fisdir);
 
               if (fisdir)
                 getallfiles (curl, sv(i), target + dir + sep);
               else
                 {
                   std::string realfile = target + dir + sep + sv(i);
-                  std::ofstream ofile (realfile.c_str(), 
-                                       std::ios::out | 
+                  std::ofstream ofile (realfile.c_str(),
+                                       std::ios::out |
                                        std::ios::binary);
 
                   if (! ofile.is_open ())
                     {
                       error ("__ftp_mget__: unable to open file");
                       break;
                     }
 
@@ -1685,25 +1685,25 @@ Undocumented internal function\n\
                 {
                   if (pattern.match (sv(i)))
                     {
                       n++;
 
                       time_t ftime;
                       bool fisdir;
                       double fsize;
-                      
+
                       curl.get_fileinfo (sv(i), fsize, ftime, fisdir);
 
                       if (fisdir)
                         getallfiles (curl, sv(i), target);
                       else
                         {
                           std::ofstream ofile ((target + sv(i)).c_str(),
-                                               std::ios::out | 
+                                               std::ios::out |
                                                std::ios::binary);
 
                           if (! ofile.is_open ())
                             {
                               error ("__ftp_mget__: unable to open file");
                               break;
                             }
 
diff --git a/src/OPERATORS/op-b-sbm.cc b/src/OPERATORS/op-b-sbm.cc
--- a/src/OPERATORS/op-b-sbm.cc
+++ b/src/OPERATORS/op-b-sbm.cc
@@ -44,17 +44,17 @@ DEFBINOP_FN (eq, bool, sparse_bool_matri
 
 DEFBINOP_FN (el_and, bool, sparse_bool_matrix, mx_el_and)
 DEFBINOP_FN (el_or, bool, sparse_bool_matrix, mx_el_or)
 
 DEFCATOP (b_sbm, bool, sparse_bool_matrix)
 {
   CAST_BINOP_ARGS (octave_bool&, const octave_sparse_bool_matrix&);
   SparseBoolMatrix tmp (1, 1, v1.bool_value ());
-  return octave_value (tmp. concat (v2.sparse_bool_matrix_value (), 
+  return octave_value (tmp. concat (v2.sparse_bool_matrix_value (),
                                     ra_idx));
 }
 
 DEFCATOP (b_sm, bool, sparse_matrix)
 {
   CAST_BINOP_ARGS (octave_bool&, const octave_sparse_matrix&);
   SparseMatrix tmp (1, 1, v1.scalar_value ());
   return octave_value (tmp. concat (v2.sparse_matrix_value (), ra_idx));
@@ -66,30 +66,30 @@ DEFCATOP (s_sbm, scalar, sparse_bool_mat
   SparseMatrix tmp (1, 1, v1.scalar_value ());
   return octave_value(tmp. concat (v2.sparse_matrix_value (), ra_idx));
 }
 
 DEFCONV (sparse_bool_matrix_conv, bool, sparse_bool_matrix)
 {
   CAST_CONV_ARG (const octave_bool&);
 
-  return new octave_sparse_bool_matrix 
+  return new octave_sparse_bool_matrix
     (SparseBoolMatrix (1, 1, v.bool_value ()));
 }
 
 void
 install_b_sbm_ops (void)
 {
   INSTALL_BINOP (op_eq, octave_bool, octave_sparse_bool_matrix, eq);
   INSTALL_BINOP (op_ne, octave_bool, octave_sparse_bool_matrix, ne);
 
   INSTALL_BINOP (op_el_and, octave_bool, octave_sparse_bool_matrix, el_and);
   INSTALL_BINOP (op_el_or, octave_bool, octave_sparse_bool_matrix, el_or);
 
   INSTALL_CATOP (octave_bool, octave_sparse_bool_matrix, b_sbm);
   INSTALL_CATOP (octave_bool, octave_sparse_matrix, b_sm);
   INSTALL_CATOP (octave_scalar, octave_sparse_bool_matrix, s_sbm);
 
-  INSTALL_ASSIGNCONV (octave_bool, octave_sparse_bool_matrix, 
+  INSTALL_ASSIGNCONV (octave_bool, octave_sparse_bool_matrix,
                       octave_bool_matrix);
 
   INSTALL_WIDENOP (octave_bool, octave_sparse_bool_matrix, sparse_bool_matrix_conv);
 }
diff --git a/src/OPERATORS/op-bm-sbm.cc b/src/OPERATORS/op-bm-sbm.cc
--- a/src/OPERATORS/op-bm-sbm.cc
+++ b/src/OPERATORS/op-bm-sbm.cc
@@ -46,58 +46,58 @@ DEFBINOP_FN (ne, bool_matrix, sparse_boo
 
 DEFBINOP_FN (el_and, bool_matrix, sparse_bool_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  bool_matrix, sparse_bool_matrix, mx_el_or)
 
 DEFCATOP (bm_sbm, bool_matrix, sparse_bool_matrix)
 {
   CAST_BINOP_ARGS (octave_bool_matrix&, const octave_sparse_bool_matrix&);
   SparseBoolMatrix tmp (v1.bool_matrix_value ());
-  return octave_value (tmp. concat (v2.sparse_bool_matrix_value (), 
+  return octave_value (tmp. concat (v2.sparse_bool_matrix_value (),
                                     ra_idx));
 }
 
 DEFCATOP (m_sbm, matrix, sparse_bool_matrix)
 {
   CAST_BINOP_ARGS (octave_matrix&, const octave_sparse_bool_matrix&);
   SparseMatrix tmp (v1.matrix_value ());
   return octave_value (tmp. concat (v2.sparse_matrix_value (), ra_idx));
 }
 
 DEFCATOP (bm_sm, bool_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (octave_bool_matrix&, const octave_sparse_matrix&); 
+  CAST_BINOP_ARGS (octave_bool_matrix&, const octave_sparse_matrix&);
   SparseMatrix tmp (v1.matrix_value ());
   return octave_value (tmp. concat (v2.sparse_matrix_value (), ra_idx));
 }
 
 DEFCONV (sparse_bool_matrix_conv, bool_matrix, sparse_bool_matrix)
 {
   CAST_CONV_ARG (const octave_bool_matrix&);
-  return new octave_sparse_bool_matrix 
+  return new octave_sparse_bool_matrix
     (SparseBoolMatrix (v.bool_matrix_value ()));
 }
 
 DEFNDASSIGNOP_FN (assign, bool_matrix, sparse_bool_matrix, bool_array, assign)
 
 void
 install_bm_sbm_ops (void)
 {
   INSTALL_BINOP (op_eq, octave_bool_matrix, octave_sparse_bool_matrix, eq);
   INSTALL_BINOP (op_ne, octave_bool_matrix, octave_sparse_bool_matrix, ne);
 
-  INSTALL_BINOP (op_el_and, octave_bool_matrix, octave_sparse_bool_matrix, 
+  INSTALL_BINOP (op_el_and, octave_bool_matrix, octave_sparse_bool_matrix,
                  el_and);
-  INSTALL_BINOP (op_el_or, octave_bool_matrix, octave_sparse_bool_matrix, 
+  INSTALL_BINOP (op_el_or, octave_bool_matrix, octave_sparse_bool_matrix,
                  el_or);
 
   INSTALL_CATOP (octave_bool_matrix, octave_sparse_bool_matrix, bm_sbm);
   INSTALL_CATOP (octave_bool_matrix, octave_sparse_matrix, bm_sm);
   INSTALL_CATOP (octave_matrix, octave_sparse_bool_matrix, m_sbm);
 
-  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_sparse_bool_matrix, 
+  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_sparse_bool_matrix,
                     assign)
-  INSTALL_ASSIGNCONV (octave_bool_matrix, octave_sparse_bool_matrix, 
+  INSTALL_ASSIGNCONV (octave_bool_matrix, octave_sparse_bool_matrix,
                       octave_bool_matrix);
 
-  INSTALL_WIDENOP (octave_bool_matrix, octave_sparse_bool_matrix, 
+  INSTALL_WIDENOP (octave_bool_matrix, octave_sparse_bool_matrix,
                    sparse_bool_matrix_conv);
 }
diff --git a/src/OPERATORS/op-cdm-cdm.cc b/src/OPERATORS/op-cdm-cdm.cc
--- a/src/OPERATORS/op-cdm-cdm.cc
+++ b/src/OPERATORS/op-cdm-cdm.cc
@@ -56,25 +56,25 @@ DEFUNOP (hermitian, complex_diag_matrix)
 
 DEFBINOP_OP (add, complex_diag_matrix, complex_diag_matrix, +)
 DEFBINOP_OP (sub, complex_diag_matrix, complex_diag_matrix, -)
 DEFBINOP_OP (mul, complex_diag_matrix, complex_diag_matrix, *)
 
 DEFBINOP (div, complex_diag_matrix, complex_diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_diag_matrix&, const octave_complex_diag_matrix&);
-  
-  return xdiv (v1.complex_diag_matrix_value (), 
+
+  return xdiv (v1.complex_diag_matrix_value (),
                v2.complex_diag_matrix_value ());
 }
 
 DEFBINOP (ldiv, complex_diag_matrix, complex_diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_diag_matrix&, const octave_complex_diag_matrix&);
-  
+
   return xleftdiv (v1.complex_diag_matrix_value (),
                    v2.complex_diag_matrix_value ());
 }
 
 CONVDECL (complex_diag_matrix_to_complex_matrix)
 {
   CAST_CONV_ARG (const octave_complex_diag_matrix&);
 
@@ -98,13 +98,13 @@ install_cdm_cdm_ops (void)
 
   INSTALL_BINOP (op_add, octave_complex_diag_matrix, octave_complex_diag_matrix, add);
   INSTALL_BINOP (op_sub, octave_complex_diag_matrix, octave_complex_diag_matrix, sub);
   INSTALL_BINOP (op_mul, octave_complex_diag_matrix, octave_complex_diag_matrix, mul);
   INSTALL_BINOP (op_div, octave_complex_diag_matrix, octave_complex_diag_matrix, div);
   INSTALL_BINOP (op_ldiv, octave_complex_diag_matrix, octave_complex_diag_matrix, ldiv);
 
   INSTALL_CONVOP (octave_complex_diag_matrix, octave_complex_matrix, complex_diag_matrix_to_complex_matrix);
-  INSTALL_CONVOP (octave_complex_diag_matrix, octave_float_complex_diag_matrix, 
+  INSTALL_CONVOP (octave_complex_diag_matrix, octave_float_complex_diag_matrix,
                   complex_diag_matrix_to_float_complex_diag_matrix);
   INSTALL_ASSIGNCONV (octave_complex_diag_matrix, octave_complex_matrix, octave_complex_matrix);
   INSTALL_WIDENOP (octave_complex_diag_matrix, octave_complex_matrix, complex_diag_matrix_to_complex_matrix);
 }
diff --git a/src/OPERATORS/op-chm.cc b/src/OPERATORS/op-chm.cc
--- a/src/OPERATORS/op-chm.cc
+++ b/src/OPERATORS/op-chm.cc
@@ -39,17 +39,17 @@ along with Octave; see the file COPYING.
 
 DEFUNOP (transpose, char_matrix)
 {
   CAST_UNOP_ARG (const octave_char_matrix&);
 
   return octave_value (v.matrix_value().transpose ());
 }
 
-DEFNDCATOP_FN (chm_chm, char_matrix, char_matrix, char_array, char_array, 
+DEFNDCATOP_FN (chm_chm, char_matrix, char_matrix, char_array, char_array,
                concat)
 
 DEFCATOP (chm_s, char_matrix, scalar)
 {
   CAST_BINOP_ARGS (octave_char_matrix&, const octave_scalar&);
 
   gripe_implicit_conversion ("Octave:num-to-str",
                              v2.type_name (), v1.type_name ());
diff --git a/src/OPERATORS/op-cm-cm.cc b/src/OPERATORS/op-cm-cm.cc
--- a/src/OPERATORS/op-cm-cm.cc
+++ b/src/OPERATORS/op-cm-cm.cc
@@ -77,92 +77,92 @@ DEFNDBINOP_OP (add, complex_matrix, comp
 DEFNDBINOP_OP (sub, complex_matrix, complex_matrix, complex_array, complex_array, -)
 
 DEFBINOP_OP (mul, complex_matrix, complex_matrix, *)
 
 DEFBINOP (div, complex_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
   MatrixType typ = v2.matrix_type ();
-  
-  ComplexMatrix ret = xdiv (v1.complex_matrix_value (), 
+
+  ComplexMatrix ret = xdiv (v1.complex_matrix_value (),
                             v2.complex_matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, complex_matrix, complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, complex_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
   MatrixType typ = v1.matrix_type ();
-  
-  ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (), 
+
+  ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (),
                                 v2.complex_matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP (trans_mul, complex_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
-  return octave_value(xgemm (v1.complex_matrix_value (), 
+  return octave_value(xgemm (v1.complex_matrix_value (),
                              v2.complex_matrix_value (),
                              blas_trans, blas_no_trans));
 }
 
 DEFBINOP (mul_trans, complex_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
-  return octave_value(xgemm (v1.complex_matrix_value (), 
+  return octave_value(xgemm (v1.complex_matrix_value (),
                              v2.complex_matrix_value (),
                              blas_no_trans, blas_trans));
 }
 
 DEFBINOP (herm_mul, complex_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
-  return octave_value(xgemm (v1.complex_matrix_value (), 
+  return octave_value(xgemm (v1.complex_matrix_value (),
                              v2.complex_matrix_value (),
                              blas_conj_trans, blas_no_trans));
 }
 
 DEFBINOP (mul_herm, complex_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
-  return octave_value(xgemm (v1.complex_matrix_value (), 
+  return octave_value(xgemm (v1.complex_matrix_value (),
                              v2.complex_matrix_value (),
                              blas_no_trans, blas_conj_trans));
 }
 
 DEFBINOP (trans_ldiv, complex_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
   MatrixType typ = v1.matrix_type ();
-  
-  ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (), 
+
+  ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (),
                                 v2.complex_matrix_value (), typ, blas_trans);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP (herm_ldiv, complex_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
   MatrixType typ = v1.matrix_type ();
-  
-  ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (), 
+
+  ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (),
                                 v2.complex_matrix_value (), typ, blas_conj_trans);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFNDCMPLXCMPOP_FN (lt, complex_matrix, complex_matrix, complex_array, complex_array, mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, complex_matrix, complex_matrix, complex_array, complex_array, mx_el_le)
@@ -250,11 +250,11 @@ install_cm_cm_ops (void)
   INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, octave_null_str, null_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, octave_null_sq_str, null_assign);
 
   INSTALL_ASSIGNOP (op_add_eq, octave_complex_matrix, octave_complex_matrix, assign_add);
   INSTALL_ASSIGNOP (op_sub_eq, octave_complex_matrix, octave_complex_matrix, assign_sub);
   INSTALL_ASSIGNOP (op_el_mul_eq, octave_complex_matrix, octave_complex_matrix, assign_el_mul);
   INSTALL_ASSIGNOP (op_el_div_eq, octave_complex_matrix, octave_complex_matrix, assign_el_div);
 
-  INSTALL_CONVOP (octave_complex_matrix, octave_float_complex_matrix, 
+  INSTALL_CONVOP (octave_complex_matrix, octave_float_complex_matrix,
                   complex_matrix_to_float_complex_matrix);
 }
diff --git a/src/OPERATORS/op-cm-m.cc b/src/OPERATORS/op-cm-m.cc
--- a/src/OPERATORS/op-cm-m.cc
+++ b/src/OPERATORS/op-cm-m.cc
@@ -56,18 +56,18 @@ DEFBINOP (mul_trans, complex_matrix, mat
   return ComplexMatrix (xgemm (real (m1), m2, blas_no_trans, blas_trans),
                         xgemm (imag (m1), m2, blas_no_trans, blas_trans));
 }
 
 DEFBINOP (div, complex_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
   MatrixType typ = v2.matrix_type ();
-  
-  ComplexMatrix ret = xdiv (v1.complex_matrix_value (), 
+
+  ComplexMatrix ret = xdiv (v1.complex_matrix_value (),
                             v2.matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 
 DEFBINOPX (pow, complex_matrix, matrix)
@@ -75,18 +75,18 @@ DEFBINOPX (pow, complex_matrix, matrix)
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, complex_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
   MatrixType typ = v1.matrix_type ();
-  
-  ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (), 
+
+  ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (),
                                 v2.matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFNDCMPLXCMPOP_FN (lt, complex_matrix, matrix, complex_array, array, mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, complex_matrix, matrix, complex_array, array, mx_el_le)
diff --git a/src/OPERATORS/op-cm-scm.cc b/src/OPERATORS/op-cm-scm.cc
--- a/src/OPERATORS/op-cm-scm.cc
+++ b/src/OPERATORS/op-cm-scm.cc
@@ -59,37 +59,37 @@ DEFBINOP (div, complex_matrix, sparse_co
         gripe_divide_by_zero ();
 
       return octave_value (v1.complex_array_value () / d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
 
-      ComplexMatrix ret = xdiv (v1.complex_matrix_value (), 
+      ComplexMatrix ret = xdiv (v1.complex_matrix_value (),
                                 v2.sparse_complex_matrix_value (), typ);
 
       v2.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOPX (pow, complex_matrix, sparse_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, complex_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&, 
+  CAST_BINOP_ARGS (const octave_complex_matrix&,
                    const octave_sparse_complex_matrix&);
   MatrixType typ = v1.matrix_type ();
-  
-  ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (), 
+
+  ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (),
                                 v2.complex_matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP_FN (mul_trans, complex_matrix, sparse_complex_matrix, mul_trans);
 DEFBINOP_FN (mul_herm, complex_matrix, sparse_complex_matrix, mul_herm);
@@ -101,103 +101,103 @@ DEFBINOP_FN (ge, complex_matrix, sparse_
 DEFBINOP_FN (gt, complex_matrix, sparse_complex_matrix, mx_el_gt)
 DEFBINOP_FN (ne, complex_matrix, sparse_complex_matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, complex_matrix, sparse_complex_matrix, product)
 DEFBINOP_FN (el_div, complex_matrix, sparse_complex_matrix, quotient)
 
 DEFBINOP (el_pow, complex_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&, 
+  CAST_BINOP_ARGS (const octave_complex_matrix&,
                    const octave_sparse_complex_matrix&);
-  
-  return octave_value 
+
+  return octave_value
     (elem_xpow (SparseComplexMatrix (v1.complex_matrix_value ()),
                 v2.sparse_complex_matrix_value ()));
 }
 
 DEFBINOP (el_ldiv, sparse_complex_matrix, matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&, 
+  CAST_BINOP_ARGS (const octave_complex_matrix&,
                    const octave_sparse_complex_matrix&);
 
-  return octave_value (quotient (v2.sparse_complex_matrix_value (), 
+  return octave_value (quotient (v2.sparse_complex_matrix_value (),
                                  v1.complex_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, complex_matrix, sparse_complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  complex_matrix, sparse_complex_matrix, mx_el_or)
 
 DEFCATOP (cm_scm, complex_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (octave_complex_matrix&, 
+  CAST_BINOP_ARGS (octave_complex_matrix&,
                    const octave_sparse_complex_matrix&);
   SparseComplexMatrix tmp (v1.complex_matrix_value ());
-  return octave_value (tmp. concat (v2.sparse_complex_matrix_value (), 
+  return octave_value (tmp. concat (v2.sparse_complex_matrix_value (),
                                     ra_idx));
 }
 
-DEFCONV (sparse_complex_matrix_conv, complex_matrix, 
+DEFCONV (sparse_complex_matrix_conv, complex_matrix,
          sparse_complex_matrix)
 {
   CAST_CONV_ARG (const octave_complex_matrix&);
-  return new octave_sparse_complex_matrix 
+  return new octave_sparse_complex_matrix
     (SparseComplexMatrix (v.complex_matrix_value ()));
 }
 
-DEFNDASSIGNOP_FN (assign, complex_matrix, sparse_complex_matrix, 
+DEFNDASSIGNOP_FN (assign, complex_matrix, sparse_complex_matrix,
                   complex_array, assign)
 
 void
 install_cm_scm_ops (void)
 {
-  INSTALL_BINOP (op_add, octave_complex_matrix, 
+  INSTALL_BINOP (op_add, octave_complex_matrix,
                  octave_sparse_complex_matrix, add);
-  INSTALL_BINOP (op_sub, octave_complex_matrix, 
+  INSTALL_BINOP (op_sub, octave_complex_matrix,
                  octave_sparse_complex_matrix, sub);
-  INSTALL_BINOP (op_mul, octave_complex_matrix, 
+  INSTALL_BINOP (op_mul, octave_complex_matrix,
                  octave_sparse_complex_matrix, mul);
-  INSTALL_BINOP (op_div, octave_complex_matrix, 
+  INSTALL_BINOP (op_div, octave_complex_matrix,
                  octave_sparse_complex_matrix, div);
-  INSTALL_BINOP (op_pow, octave_complex_matrix, 
+  INSTALL_BINOP (op_pow, octave_complex_matrix,
                  octave_sparse_complex_matrix, pow);
-  INSTALL_BINOP (op_ldiv, octave_complex_matrix, 
+  INSTALL_BINOP (op_ldiv, octave_complex_matrix,
                  octave_sparse_complex_matrix, ldiv);
-  INSTALL_BINOP (op_mul_trans, octave_complex_matrix, 
+  INSTALL_BINOP (op_mul_trans, octave_complex_matrix,
                  octave_sparse_complex_matrix, mul_trans);
-  INSTALL_BINOP (op_mul_herm, octave_complex_matrix, 
+  INSTALL_BINOP (op_mul_herm, octave_complex_matrix,
                  octave_sparse_complex_matrix, mul_herm);
-  INSTALL_BINOP (op_lt, octave_complex_matrix, 
+  INSTALL_BINOP (op_lt, octave_complex_matrix,
                  octave_sparse_complex_matrix, lt);
-  INSTALL_BINOP (op_le, octave_complex_matrix, 
+  INSTALL_BINOP (op_le, octave_complex_matrix,
                  octave_sparse_complex_matrix, le);
-  INSTALL_BINOP (op_eq, octave_complex_matrix, 
+  INSTALL_BINOP (op_eq, octave_complex_matrix,
                  octave_sparse_complex_matrix, eq);
-  INSTALL_BINOP (op_ge, octave_complex_matrix, 
+  INSTALL_BINOP (op_ge, octave_complex_matrix,
                  octave_sparse_complex_matrix, ge);
-  INSTALL_BINOP (op_gt, octave_complex_matrix, 
+  INSTALL_BINOP (op_gt, octave_complex_matrix,
                  octave_sparse_complex_matrix, gt);
-  INSTALL_BINOP (op_ne, octave_complex_matrix, 
+  INSTALL_BINOP (op_ne, octave_complex_matrix,
                  octave_sparse_complex_matrix, ne);
-  INSTALL_BINOP (op_el_mul, octave_complex_matrix, 
+  INSTALL_BINOP (op_el_mul, octave_complex_matrix,
                  octave_sparse_complex_matrix, el_mul);
-  INSTALL_BINOP (op_el_div, octave_complex_matrix, 
+  INSTALL_BINOP (op_el_div, octave_complex_matrix,
                  octave_sparse_complex_matrix, el_div);
-  INSTALL_BINOP (op_el_pow, octave_complex_matrix, 
+  INSTALL_BINOP (op_el_pow, octave_complex_matrix,
                  octave_sparse_complex_matrix, el_pow);
-  INSTALL_BINOP (op_el_ldiv, octave_complex_matrix, 
+  INSTALL_BINOP (op_el_ldiv, octave_complex_matrix,
                  octave_sparse_complex_matrix, el_ldiv);
-  INSTALL_BINOP (op_el_and, octave_complex_matrix, 
+  INSTALL_BINOP (op_el_and, octave_complex_matrix,
                  octave_sparse_complex_matrix, el_and);
-  INSTALL_BINOP (op_el_or, octave_complex_matrix, 
+  INSTALL_BINOP (op_el_or, octave_complex_matrix,
                  octave_sparse_complex_matrix, el_or);
 
-  INSTALL_CATOP (octave_complex_matrix, 
+  INSTALL_CATOP (octave_complex_matrix,
                  octave_sparse_complex_matrix, cm_scm);
 
-  INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, 
+  INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix,
                     octave_sparse_complex_matrix, assign)
-  INSTALL_ASSIGNCONV (octave_complex_matrix, octave_sparse_complex_matrix, 
+  INSTALL_ASSIGNCONV (octave_complex_matrix, octave_sparse_complex_matrix,
                       octave_complex_matrix);
 
-  INSTALL_WIDENOP (octave_complex_matrix, octave_sparse_complex_matrix, 
+  INSTALL_WIDENOP (octave_complex_matrix, octave_sparse_complex_matrix,
                    sparse_complex_matrix_conv);
 }
diff --git a/src/OPERATORS/op-cm-sm.cc b/src/OPERATORS/op-cm-sm.cc
--- a/src/OPERATORS/op-cm-sm.cc
+++ b/src/OPERATORS/op-cm-sm.cc
@@ -44,51 +44,51 @@ along with Octave; see the file COPYING.
 DEFBINOP_OP (add, complex_matrix, sparse_matrix, +)
 DEFBINOP_OP (sub, complex_matrix, sparse_matrix, -)
 
 DEFBINOP_OP (mul, complex_matrix, sparse_matrix, *)
 
 DEFBINOP (div, complex_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_sparse_matrix&);
-  
+
   if (v2.rows() == 1 && v2.columns() == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v1.complex_array_value () / d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
 
-      ComplexMatrix ret = xdiv (v1.complex_matrix_value (), 
+      ComplexMatrix ret = xdiv (v1.complex_matrix_value (),
                                 v2.sparse_matrix_value (), typ);
 
       v2.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOPX (pow, complex_matrix, sparse_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, complex_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&, 
+  CAST_BINOP_ARGS (const octave_complex_matrix&,
                    const octave_sparse_matrix&);
   MatrixType typ = v1.matrix_type ();
-  
-  ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (), 
+
+  ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (),
                                 v2.matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP_FN (lt, complex_matrix, sparse_matrix, mx_el_lt)
 DEFBINOP_FN (le, complex_matrix, sparse_matrix, mx_el_le)
@@ -97,27 +97,27 @@ DEFBINOP_FN (ge, complex_matrix, sparse_
 DEFBINOP_FN (gt, complex_matrix, sparse_matrix, mx_el_gt)
 DEFBINOP_FN (ne, complex_matrix, sparse_matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, complex_matrix, sparse_matrix, product)
 DEFBINOP_FN (el_div, complex_matrix, sparse_matrix, quotient)
 
 DEFBINOP (el_pow, complex_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&, 
+  CAST_BINOP_ARGS (const octave_complex_matrix&,
                    const octave_sparse_matrix&);
-  
-  return octave_value 
+
+  return octave_value
     (elem_xpow ( SparseComplexMatrix (v1.complex_matrix_value ()),
                  v2.sparse_matrix_value ()));
 }
 
 DEFBINOP (el_ldiv, complex_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_matrix&, 
+  CAST_BINOP_ARGS (const octave_complex_matrix&,
                    const octave_sparse_matrix&);
   return octave_value
     (quotient (v2.sparse_matrix_value (), v1.complex_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, complex_matrix, sparse_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  complex_matrix, sparse_matrix, mx_el_or)
 
@@ -140,29 +140,29 @@ install_cm_sm_ops (void)
   INSTALL_BINOP (op_pow, octave_complex_matrix, octave_sparse_matrix, pow);
   INSTALL_BINOP (op_ldiv, octave_complex_matrix, octave_sparse_matrix, ldiv);
   INSTALL_BINOP (op_lt, octave_complex_matrix, octave_sparse_matrix, lt);
   INSTALL_BINOP (op_le, octave_complex_matrix, octave_sparse_matrix, le);
   INSTALL_BINOP (op_eq, octave_complex_matrix, octave_sparse_matrix, eq);
   INSTALL_BINOP (op_ge, octave_complex_matrix, octave_sparse_matrix, ge);
   INSTALL_BINOP (op_gt, octave_complex_matrix, octave_sparse_matrix, gt);
   INSTALL_BINOP (op_ne, octave_complex_matrix, octave_sparse_matrix, ne);
-  INSTALL_BINOP (op_el_mul, octave_complex_matrix, octave_sparse_matrix, 
+  INSTALL_BINOP (op_el_mul, octave_complex_matrix, octave_sparse_matrix,
                  el_mul);
-  INSTALL_BINOP (op_el_div, octave_complex_matrix, octave_sparse_matrix, 
+  INSTALL_BINOP (op_el_div, octave_complex_matrix, octave_sparse_matrix,
                  el_div);
-  INSTALL_BINOP (op_el_pow, octave_complex_matrix, octave_sparse_matrix, 
+  INSTALL_BINOP (op_el_pow, octave_complex_matrix, octave_sparse_matrix,
                  el_pow);
-  INSTALL_BINOP (op_el_ldiv, octave_complex_matrix, octave_sparse_matrix, 
+  INSTALL_BINOP (op_el_ldiv, octave_complex_matrix, octave_sparse_matrix,
                  el_ldiv);
-  INSTALL_BINOP (op_el_and, octave_complex_matrix, octave_sparse_matrix, 
+  INSTALL_BINOP (op_el_and, octave_complex_matrix, octave_sparse_matrix,
                  el_and);
-  INSTALL_BINOP (op_el_or, octave_complex_matrix, octave_sparse_matrix, 
+  INSTALL_BINOP (op_el_or, octave_complex_matrix, octave_sparse_matrix,
                  el_or);
 
   INSTALL_CATOP (octave_complex_matrix, octave_sparse_matrix, cm_sm);
 
-  INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, octave_sparse_matrix, 
+  INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, octave_sparse_matrix,
                     assign);
-  INSTALL_ASSIGNCONV (octave_complex_matrix, octave_sparse_matrix, 
+  INSTALL_ASSIGNCONV (octave_complex_matrix, octave_sparse_matrix,
                       octave_complex_matrix)
 
 }
diff --git a/src/OPERATORS/op-cs-cs.cc b/src/OPERATORS/op-cs-cs.cc
--- a/src/OPERATORS/op-cs-cs.cc
+++ b/src/OPERATORS/op-cs-cs.cc
@@ -187,11 +187,11 @@ install_cs_cs_ops (void)
   INSTALL_CATOP (octave_complex, octave_complex, cs_cs);
 
   INSTALL_ASSIGNCONV (octave_complex, octave_complex, octave_complex_matrix);
 
   INSTALL_ASSIGNCONV (octave_complex, octave_null_matrix, octave_complex_matrix);
   INSTALL_ASSIGNCONV (octave_complex, octave_null_str, octave_complex_matrix);
   INSTALL_ASSIGNCONV (octave_complex, octave_null_sq_str, octave_complex_matrix);
 
-  INSTALL_CONVOP (octave_complex, octave_float_complex_matrix, 
+  INSTALL_CONVOP (octave_complex, octave_float_complex_matrix,
                   complex_to_float_complex);
 }
diff --git a/src/OPERATORS/op-cs-scm.cc b/src/OPERATORS/op-cs-scm.cc
--- a/src/OPERATORS/op-cs-scm.cc
+++ b/src/OPERATORS/op-cs-scm.cc
@@ -65,17 +65,17 @@ DEFBINOP (div, complex, sparse_complex_m
       ComplexMatrix ret = xdiv (m1, m2, typ);
       v2.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOP (pow, complex, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex&, 
+  CAST_BINOP_ARGS (const octave_complex&,
                    const octave_sparse_complex_matrix&);
   return xpow (v1.complex_value (), v2.complex_matrix_value ());
 }
 
 DEFBINOP (ldiv, complex, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_sparse_complex_matrix&);
 
@@ -116,57 +116,57 @@ DEFBINOP (el_ldiv, complex, sparse_compl
 
 DEFBINOP_FN (el_and, complex, sparse_complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  complex, sparse_complex_matrix, mx_el_or)
 
 DEFCATOP (cs_scm, complex, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (octave_complex&, const octave_sparse_complex_matrix&);
   SparseComplexMatrix tmp (1, 1, v1.complex_value ());
-  return octave_value (tmp. concat (v2.sparse_complex_matrix_value (), 
+  return octave_value (tmp. concat (v2.sparse_complex_matrix_value (),
                                     ra_idx));
 }
 
 DEFCONV (sparse_complex_matrix_conv, complex, sparse_complex_matrix)
 {
   CAST_CONV_ARG (const octave_complex&);
 
-  return new octave_sparse_complex_matrix 
+  return new octave_sparse_complex_matrix
     (SparseComplexMatrix (v.complex_matrix_value ()));
 }
 
 void
 install_cs_scm_ops (void)
 {
   INSTALL_BINOP (op_add, octave_complex, octave_sparse_complex_matrix, add);
   INSTALL_BINOP (op_sub, octave_complex, octave_sparse_complex_matrix, sub);
   INSTALL_BINOP (op_mul, octave_complex, octave_sparse_complex_matrix, mul);
   INSTALL_BINOP (op_div, octave_complex, octave_sparse_complex_matrix, div);
   INSTALL_BINOP (op_pow, octave_complex, octave_sparse_complex_matrix, pow);
-  INSTALL_BINOP (op_ldiv, octave_complex, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_ldiv, octave_complex, octave_sparse_complex_matrix,
                  ldiv);
   INSTALL_BINOP (op_lt, octave_complex, octave_sparse_complex_matrix, lt);
   INSTALL_BINOP (op_le, octave_complex, octave_sparse_complex_matrix, le);
   INSTALL_BINOP (op_eq, octave_complex, octave_sparse_complex_matrix, eq);
   INSTALL_BINOP (op_ge, octave_complex, octave_sparse_complex_matrix, ge);
   INSTALL_BINOP (op_gt, octave_complex, octave_sparse_complex_matrix, gt);
   INSTALL_BINOP (op_ne, octave_complex, octave_sparse_complex_matrix, ne);
-  INSTALL_BINOP (op_el_mul, octave_complex, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_el_mul, octave_complex, octave_sparse_complex_matrix,
                  el_mul);
-  INSTALL_BINOP (op_el_div, octave_complex, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_el_div, octave_complex, octave_sparse_complex_matrix,
                  el_div);
-  INSTALL_BINOP (op_el_pow, octave_complex, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_el_pow, octave_complex, octave_sparse_complex_matrix,
                  el_pow);
-  INSTALL_BINOP (op_el_ldiv, octave_complex, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_el_ldiv, octave_complex, octave_sparse_complex_matrix,
                  el_ldiv);
-  INSTALL_BINOP (op_el_and, octave_complex, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_el_and, octave_complex, octave_sparse_complex_matrix,
                  el_and);
-  INSTALL_BINOP (op_el_or, octave_complex, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_el_or, octave_complex, octave_sparse_complex_matrix,
                  el_or);
 
   INSTALL_CATOP (octave_complex, octave_sparse_complex_matrix, cs_scm);
 
-  INSTALL_ASSIGNCONV (octave_complex, octave_sparse_complex_matrix, 
+  INSTALL_ASSIGNCONV (octave_complex, octave_sparse_complex_matrix,
                       octave_complex_matrix);
 
-  INSTALL_WIDENOP (octave_complex, octave_sparse_complex_matrix, 
+  INSTALL_WIDENOP (octave_complex, octave_sparse_complex_matrix,
                    sparse_complex_matrix_conv);
 }
diff --git a/src/OPERATORS/op-cs-sm.cc b/src/OPERATORS/op-cs-sm.cc
--- a/src/OPERATORS/op-cs-sm.cc
+++ b/src/OPERATORS/op-cs-sm.cc
@@ -126,17 +126,17 @@ DEFCATOP (cs_sm, sparse_matrix, complex)
   SparseComplexMatrix tmp (1, 1, v1.complex_value ());
   return octave_value (tmp. concat (v2.sparse_matrix_value (), ra_idx));
 }
 
 DEFCONV (sparse_matrix_conv, complex, sparse_matrix)
 {
   CAST_CONV_ARG (const octave_complex&);
 
-  return new octave_sparse_matrix 
+  return new octave_sparse_matrix
     (SparseMatrix (v.matrix_value ()));
 }
 
 void
 install_cs_sm_ops (void)
 {
   INSTALL_BINOP (op_add, octave_complex, octave_sparse_matrix, add);
   INSTALL_BINOP (op_sub, octave_complex, octave_sparse_matrix, sub);
@@ -154,13 +154,13 @@ install_cs_sm_ops (void)
   INSTALL_BINOP (op_el_div, octave_complex, octave_sparse_matrix, el_div);
   INSTALL_BINOP (op_el_pow, octave_complex, octave_sparse_matrix, el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_complex, octave_sparse_matrix, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_complex, octave_sparse_matrix, el_and);
   INSTALL_BINOP (op_el_or, octave_complex, octave_sparse_matrix, el_or);
 
   INSTALL_CATOP (octave_complex, octave_sparse_matrix, cs_sm);
 
-  INSTALL_ASSIGNCONV (octave_complex, octave_sparse_matrix, 
+  INSTALL_ASSIGNCONV (octave_complex, octave_sparse_matrix,
                       octave_complex_matrix);
 
   INSTALL_WIDENOP (octave_complex, octave_sparse_matrix, sparse_matrix_conv);
 }
diff --git a/src/OPERATORS/op-dm-dm.cc b/src/OPERATORS/op-dm-dm.cc
--- a/src/OPERATORS/op-dm-dm.cc
+++ b/src/OPERATORS/op-dm-dm.cc
@@ -50,25 +50,25 @@ DEFUNOP (transpose, diag_matrix)
 
 DEFBINOP_OP (add, diag_matrix, diag_matrix, +)
 DEFBINOP_OP (sub, diag_matrix, diag_matrix, -)
 DEFBINOP_OP (mul, diag_matrix, diag_matrix, *)
 
 DEFBINOP (div, diag_matrix, diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_diag_matrix&, const octave_diag_matrix&);
-  
-  return xdiv (v1.diag_matrix_value (), 
+
+  return xdiv (v1.diag_matrix_value (),
                v2.diag_matrix_value ());
 }
 
 DEFBINOP (ldiv, diag_matrix, diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_diag_matrix&, const octave_diag_matrix&);
-  
+
   return xleftdiv (v1.diag_matrix_value (),
                    v2.diag_matrix_value ());
 }
 
 CONVDECL (diag_matrix_to_matrix)
 {
   CAST_CONV_ARG (const octave_diag_matrix&);
 
diff --git a/src/OPERATORS/op-dms-template.cc b/src/OPERATORS/op-dms-template.cc
--- a/src/OPERATORS/op-dms-template.cc
+++ b/src/OPERATORS/op-dms-template.cc
@@ -44,17 +44,17 @@ DEFNDBINOP_OP (sdmmul, SCALAR, MATRIX, S
 DEFNDBINOP_OP (dmsmul, MATRIX, SCALAR, MATRIXV, SCALARV, *)
 
 #define OCTAVE_MATRIX CONCAT2(octave_, MATRIX)
 #define OCTAVE_SCALAR CONCAT2(octave_, SCALAR)
 #define MATRIX_VALUE CONCAT2(MATRIXV, _value)
 #define SCALAR_VALUE CONCAT2(SCALARV, _value)
 
 template <class T>
-static T 
+static T
 gripe_if_zero (T x)
 {
   if (x == T ())
     gripe_divide_by_zero ();
   return x;
 }
 
 DEFBINOP (dmsdiv, MATRIX, SCALAR)
diff --git a/src/OPERATORS/op-fcdm-fcdm.cc b/src/OPERATORS/op-fcdm-fcdm.cc
--- a/src/OPERATORS/op-fcdm-fcdm.cc
+++ b/src/OPERATORS/op-fcdm-fcdm.cc
@@ -56,25 +56,25 @@ DEFUNOP (hermitian, float_complex_diag_m
 
 DEFBINOP_OP (add, float_complex_diag_matrix, float_complex_diag_matrix, +)
 DEFBINOP_OP (sub, float_complex_diag_matrix, float_complex_diag_matrix, -)
 DEFBINOP_OP (mul, float_complex_diag_matrix, float_complex_diag_matrix, *)
 
 DEFBINOP (div, float_complex_diag_matrix, float_complex_diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_complex_diag_matrix&, const octave_float_complex_diag_matrix&);
-  
-  return xdiv (v1.float_complex_diag_matrix_value (), 
+
+  return xdiv (v1.float_complex_diag_matrix_value (),
                v2.float_complex_diag_matrix_value ());
 }
 
 DEFBINOP (ldiv, float_complex_diag_matrix, float_complex_diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_complex_diag_matrix&, const octave_float_complex_diag_matrix&);
-  
+
   return xleftdiv (v1.float_complex_diag_matrix_value (),
                    v2.float_complex_diag_matrix_value ());
 }
 
 CONVDECL (float_complex_diag_matrix_to_float_complex_matrix)
 {
   CAST_CONV_ARG (const octave_float_complex_diag_matrix&);
 
@@ -97,16 +97,16 @@ install_fcdm_fcdm_ops (void)
   INSTALL_UNOP (op_hermitian, octave_float_complex_diag_matrix, hermitian);
 
   INSTALL_BINOP (op_add, octave_float_complex_diag_matrix, octave_float_complex_diag_matrix, add);
   INSTALL_BINOP (op_sub, octave_float_complex_diag_matrix, octave_float_complex_diag_matrix, sub);
   INSTALL_BINOP (op_mul, octave_float_complex_diag_matrix, octave_float_complex_diag_matrix, mul);
   INSTALL_BINOP (op_div, octave_float_complex_diag_matrix, octave_float_complex_diag_matrix, div);
   INSTALL_BINOP (op_ldiv, octave_float_complex_diag_matrix, octave_float_complex_diag_matrix, ldiv);
 
-  INSTALL_CONVOP (octave_float_complex_diag_matrix, octave_complex_diag_matrix, 
+  INSTALL_CONVOP (octave_float_complex_diag_matrix, octave_complex_diag_matrix,
                   float_complex_diag_matrix_to_complex_diag_matrix);
-  INSTALL_CONVOP (octave_float_complex_diag_matrix, octave_float_complex_matrix, 
+  INSTALL_CONVOP (octave_float_complex_diag_matrix, octave_float_complex_matrix,
                   float_complex_diag_matrix_to_float_complex_matrix);
   INSTALL_ASSIGNCONV (octave_float_complex_diag_matrix, octave_float_complex_matrix, octave_float_complex_matrix);
-  INSTALL_WIDENOP (octave_float_complex_diag_matrix, octave_complex_diag_matrix, 
+  INSTALL_WIDENOP (octave_float_complex_diag_matrix, octave_complex_diag_matrix,
                    float_complex_diag_matrix_to_complex_diag_matrix);
 }
diff --git a/src/OPERATORS/op-fcm-fcm.cc b/src/OPERATORS/op-fcm-fcm.cc
--- a/src/OPERATORS/op-fcm-fcm.cc
+++ b/src/OPERATORS/op-fcm-fcm.cc
@@ -68,165 +68,165 @@ DEFUNOP (hermitian, float_complex_matrix
 }
 
 DEFNCUNOP_METHOD (incr, float_complex_matrix, increment)
 DEFNCUNOP_METHOD (decr, float_complex_matrix, decrement)
 DEFNCUNOP_METHOD (changesign, float_complex_matrix, changesign)
 
 // complex matrix by complex matrix ops.
 
-DEFNDBINOP_OP (add, float_complex_matrix, float_complex_matrix, 
+DEFNDBINOP_OP (add, float_complex_matrix, float_complex_matrix,
                float_complex_array, float_complex_array, +)
-DEFNDBINOP_OP (sub, float_complex_matrix, float_complex_matrix, 
+DEFNDBINOP_OP (sub, float_complex_matrix, float_complex_matrix,
                float_complex_array, float_complex_array, -)
 
 DEFBINOP_OP (mul, float_complex_matrix, float_complex_matrix, *)
 
 DEFBINOP (div, float_complex_matrix, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&, 
+  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
                    const octave_float_complex_matrix&);
   MatrixType typ = v2.matrix_type ();
-  
-  FloatComplexMatrix ret = xdiv (v1.float_complex_matrix_value (), 
+
+  FloatComplexMatrix ret = xdiv (v1.float_complex_matrix_value (),
                             v2.float_complex_matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, float_complex_matrix, float_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, float_complex_matrix, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&, 
+  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
                    const octave_float_complex_matrix&);
   MatrixType typ = v1.matrix_type ();
-  
-  FloatComplexMatrix ret = xleftdiv (v1.float_complex_matrix_value (), 
+
+  FloatComplexMatrix ret = xleftdiv (v1.float_complex_matrix_value (),
                                      v2.float_complex_matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP (trans_mul, float_complex_matrix, float_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_complex_matrix&, const octave_float_complex_matrix&);
-  return octave_value(xgemm (v1.float_complex_matrix_value (), 
+  return octave_value(xgemm (v1.float_complex_matrix_value (),
                              v2.float_complex_matrix_value (),
                              blas_trans, blas_no_trans));
 }
 
 DEFBINOP (mul_trans, float_complex_matrix, float_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_complex_matrix&, const octave_float_complex_matrix&);
-  return octave_value(xgemm (v1.float_complex_matrix_value (), 
+  return octave_value(xgemm (v1.float_complex_matrix_value (),
                              v2.float_complex_matrix_value (),
                              blas_no_trans, blas_trans));
 }
 
 DEFBINOP (herm_mul, float_complex_matrix, float_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_complex_matrix&, const octave_float_complex_matrix&);
-  return octave_value(xgemm (v1.float_complex_matrix_value (), 
+  return octave_value(xgemm (v1.float_complex_matrix_value (),
                              v2.float_complex_matrix_value (),
                              blas_conj_trans, blas_no_trans));
 }
 
 DEFBINOP (mul_herm, float_complex_matrix, float_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_complex_matrix&, const octave_float_complex_matrix&);
-  return octave_value(xgemm (v1.float_complex_matrix_value (), 
+  return octave_value(xgemm (v1.float_complex_matrix_value (),
                              v2.float_complex_matrix_value (),
                              blas_no_trans, blas_conj_trans));
 }
 
 DEFBINOP (trans_ldiv, float_complex_matrix, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&, 
+  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
                    const octave_float_complex_matrix&);
   MatrixType typ = v1.matrix_type ();
-  
-  FloatComplexMatrix ret = xleftdiv (v1.float_complex_matrix_value (), 
+
+  FloatComplexMatrix ret = xleftdiv (v1.float_complex_matrix_value (),
                                      v2.float_complex_matrix_value (), typ, blas_trans);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP (herm_ldiv, float_complex_matrix, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&, 
+  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
                    const octave_float_complex_matrix&);
   MatrixType typ = v1.matrix_type ();
-  
-  FloatComplexMatrix ret = xleftdiv (v1.float_complex_matrix_value (), 
+
+  FloatComplexMatrix ret = xleftdiv (v1.float_complex_matrix_value (),
                                      v2.float_complex_matrix_value (), typ, blas_conj_trans);
 
   v1.matrix_type (typ);
   return ret;
 }
 
-DEFNDCMPLXCMPOP_FN (lt, float_complex_matrix, float_complex_matrix, 
+DEFNDCMPLXCMPOP_FN (lt, float_complex_matrix, float_complex_matrix,
                float_complex_array, float_complex_array, mx_el_lt)
-DEFNDCMPLXCMPOP_FN (le, float_complex_matrix, float_complex_matrix, 
+DEFNDCMPLXCMPOP_FN (le, float_complex_matrix, float_complex_matrix,
                float_complex_array, float_complex_array, mx_el_le)
-DEFNDCMPLXCMPOP_FN (eq, float_complex_matrix, float_complex_matrix, 
+DEFNDCMPLXCMPOP_FN (eq, float_complex_matrix, float_complex_matrix,
                float_complex_array, float_complex_array, mx_el_eq)
-DEFNDCMPLXCMPOP_FN (ge, float_complex_matrix, float_complex_matrix, 
+DEFNDCMPLXCMPOP_FN (ge, float_complex_matrix, float_complex_matrix,
                float_complex_array, float_complex_array, mx_el_ge)
-DEFNDCMPLXCMPOP_FN (gt, float_complex_matrix, float_complex_matrix, 
+DEFNDCMPLXCMPOP_FN (gt, float_complex_matrix, float_complex_matrix,
                float_complex_array, float_complex_array, mx_el_gt)
-DEFNDCMPLXCMPOP_FN (ne, float_complex_matrix, float_complex_matrix, 
+DEFNDCMPLXCMPOP_FN (ne, float_complex_matrix, float_complex_matrix,
                float_complex_array, float_complex_array, mx_el_ne)
 
-DEFNDBINOP_FN (el_mul, float_complex_matrix, float_complex_matrix, 
+DEFNDBINOP_FN (el_mul, float_complex_matrix, float_complex_matrix,
                float_complex_array, float_complex_array, product)
-DEFNDBINOP_FN (el_div, float_complex_matrix, float_complex_matrix, 
+DEFNDBINOP_FN (el_div, float_complex_matrix, float_complex_matrix,
                float_complex_array, float_complex_array, quotient)
-DEFNDBINOP_FN (el_pow, float_complex_matrix, float_complex_matrix, 
+DEFNDBINOP_FN (el_pow, float_complex_matrix, float_complex_matrix,
                float_complex_array, float_complex_array, elem_xpow)
 
 DEFBINOP (el_ldiv, float_complex_matrix, float_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_complex_matrix&,
                    const octave_float_complex_matrix&);
 
   return octave_value (quotient (v2.float_complex_array_value (), v1.float_complex_array_value ()));
 }
 
-DEFNDBINOP_FN (el_and, float_complex_matrix, float_complex_matrix, 
+DEFNDBINOP_FN (el_and, float_complex_matrix, float_complex_matrix,
                float_complex_array, float_complex_array, mx_el_and)
-DEFNDBINOP_FN (el_or,  float_complex_matrix, float_complex_matrix, 
+DEFNDBINOP_FN (el_or,  float_complex_matrix, float_complex_matrix,
                float_complex_array, float_complex_array, mx_el_or)
 
-DEFNDCATOP_FN (fcm_fcm, float_complex_matrix, float_complex_matrix, 
+DEFNDCATOP_FN (fcm_fcm, float_complex_matrix, float_complex_matrix,
                float_complex_array, float_complex_array, concat)
 
-DEFNDCATOP_FN (cm_fcm, complex_matrix, float_complex_matrix, 
+DEFNDCATOP_FN (cm_fcm, complex_matrix, float_complex_matrix,
                float_complex_array, float_complex_array, concat)
 
-DEFNDCATOP_FN (fcm_cm, float_complex_matrix, complex_matrix, 
+DEFNDCATOP_FN (fcm_cm, float_complex_matrix, complex_matrix,
                float_complex_array, float_complex_array, concat)
 
-DEFNDASSIGNOP_FN (assign, float_complex_matrix, float_complex_matrix, 
+DEFNDASSIGNOP_FN (assign, float_complex_matrix, float_complex_matrix,
                   float_complex_array, assign)
-DEFNDASSIGNOP_FN (dbl_assign, float_complex_matrix, complex_matrix, 
+DEFNDASSIGNOP_FN (dbl_assign, float_complex_matrix, complex_matrix,
                   float_complex_array, assign)
 
 DEFNULLASSIGNOP_FN (null_assign, float_complex_matrix, delete_elements)
 
-DEFNDASSIGNOP_OP (assign_add, float_complex_matrix, 
+DEFNDASSIGNOP_OP (assign_add, float_complex_matrix,
                   float_complex_matrix, float_complex_array, +=)
-DEFNDASSIGNOP_OP (assign_sub, float_complex_matrix, 
+DEFNDASSIGNOP_OP (assign_sub, float_complex_matrix,
                   float_complex_matrix, float_complex_array, -=)
 DEFNDASSIGNOP_FNOP (assign_el_mul, float_complex_matrix, float_complex_matrix,
                     float_complex_array, product_eq)
 DEFNDASSIGNOP_FNOP (assign_el_div, float_complex_matrix, float_complex_matrix,
                     float_complex_array, quotient_eq)
 
 CONVDECL (float_complex_matrix_to_complex_matrix)
 {
@@ -243,89 +243,89 @@ install_fcm_fcm_ops (void)
   INSTALL_UNOP (op_uminus, octave_float_complex_matrix, uminus);
   INSTALL_UNOP (op_transpose, octave_float_complex_matrix, transpose);
   INSTALL_UNOP (op_hermitian, octave_float_complex_matrix, hermitian);
 
   INSTALL_NCUNOP (op_incr, octave_float_complex_matrix, incr);
   INSTALL_NCUNOP (op_decr, octave_float_complex_matrix, decr);
   INSTALL_NCUNOP (op_uminus, octave_float_complex_matrix, changesign);
 
-  INSTALL_BINOP (op_add, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_add, octave_float_complex_matrix,
                  octave_float_complex_matrix, add);
-  INSTALL_BINOP (op_sub, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_sub, octave_float_complex_matrix,
                  octave_float_complex_matrix, sub);
-  INSTALL_BINOP (op_mul, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_mul, octave_float_complex_matrix,
                  octave_float_complex_matrix, mul);
-  INSTALL_BINOP (op_div, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_div, octave_float_complex_matrix,
                  octave_float_complex_matrix, div);
-  INSTALL_BINOP (op_pow, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_pow, octave_float_complex_matrix,
                  octave_float_complex_matrix, pow);
-  INSTALL_BINOP (op_ldiv, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_ldiv, octave_float_complex_matrix,
                  octave_float_complex_matrix, ldiv);
-  INSTALL_BINOP (op_trans_mul, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_trans_mul, octave_float_complex_matrix,
                  octave_float_complex_matrix, trans_mul);
-  INSTALL_BINOP (op_mul_trans, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_mul_trans, octave_float_complex_matrix,
                  octave_float_complex_matrix, mul_trans);
-  INSTALL_BINOP (op_herm_mul, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_herm_mul, octave_float_complex_matrix,
                  octave_float_complex_matrix, herm_mul);
-  INSTALL_BINOP (op_mul_herm, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_mul_herm, octave_float_complex_matrix,
                  octave_float_complex_matrix, mul_herm);
-  INSTALL_BINOP (op_trans_ldiv, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_trans_ldiv, octave_float_complex_matrix,
                  octave_float_complex_matrix, trans_ldiv);
-  INSTALL_BINOP (op_herm_ldiv, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_herm_ldiv, octave_float_complex_matrix,
                  octave_float_complex_matrix, herm_ldiv);
 
-  INSTALL_BINOP (op_lt, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_lt, octave_float_complex_matrix,
                  octave_float_complex_matrix, lt);
-  INSTALL_BINOP (op_le, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_le, octave_float_complex_matrix,
                  octave_float_complex_matrix, le);
-  INSTALL_BINOP (op_eq, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_eq, octave_float_complex_matrix,
                  octave_float_complex_matrix, eq);
-  INSTALL_BINOP (op_ge, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_ge, octave_float_complex_matrix,
                  octave_float_complex_matrix, ge);
-  INSTALL_BINOP (op_gt, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_gt, octave_float_complex_matrix,
                  octave_float_complex_matrix, gt);
-  INSTALL_BINOP (op_ne, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_ne, octave_float_complex_matrix,
                  octave_float_complex_matrix, ne);
-  INSTALL_BINOP (op_el_mul, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_el_mul, octave_float_complex_matrix,
                  octave_float_complex_matrix, el_mul);
-  INSTALL_BINOP (op_el_div, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_el_div, octave_float_complex_matrix,
                  octave_float_complex_matrix, el_div);
-  INSTALL_BINOP (op_el_pow, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_el_pow, octave_float_complex_matrix,
                  octave_float_complex_matrix, el_pow);
-  INSTALL_BINOP (op_el_ldiv, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_el_ldiv, octave_float_complex_matrix,
                  octave_float_complex_matrix, el_ldiv);
-  INSTALL_BINOP (op_el_and, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_el_and, octave_float_complex_matrix,
                  octave_float_complex_matrix, el_and);
-  INSTALL_BINOP (op_el_or, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_el_or, octave_float_complex_matrix,
                  octave_float_complex_matrix, el_or);
 
-  INSTALL_CATOP (octave_float_complex_matrix, 
+  INSTALL_CATOP (octave_float_complex_matrix,
                  octave_float_complex_matrix, fcm_fcm);
-  INSTALL_CATOP (octave_complex_matrix, 
+  INSTALL_CATOP (octave_complex_matrix,
                  octave_float_complex_matrix, cm_fcm);
-  INSTALL_CATOP (octave_float_complex_matrix, 
+  INSTALL_CATOP (octave_float_complex_matrix,
                  octave_complex_matrix, fcm_cm);
 
-  INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix, 
+  INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix,
                     octave_float_complex_matrix, assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix, 
+  INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix,
                     octave_complex_matrix, dbl_assign);
 
-  INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix, 
+  INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix,
                     octave_null_matrix, null_assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix, 
+  INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix,
                     octave_null_str, null_assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix, 
+  INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix,
                     octave_null_sq_str, null_assign);
 
   INSTALL_ASSIGNOP (op_add_eq, octave_float_complex_matrix,
                     octave_float_complex_matrix, assign_add);
   INSTALL_ASSIGNOP (op_sub_eq, octave_float_complex_matrix,
                     octave_float_complex_matrix, assign_sub);
   INSTALL_ASSIGNOP (op_el_mul_eq, octave_float_complex_matrix,
                     octave_float_complex_matrix, assign_el_mul);
   INSTALL_ASSIGNOP (op_el_div_eq, octave_float_complex_matrix,
                     octave_float_complex_matrix, assign_el_div);
 
-  INSTALL_CONVOP (octave_float_complex_matrix, octave_complex_matrix, 
+  INSTALL_CONVOP (octave_float_complex_matrix, octave_complex_matrix,
                   float_complex_matrix_to_complex_matrix);
 }
diff --git a/src/OPERATORS/op-fcm-fcs.cc b/src/OPERATORS/op-fcm-fcs.cc
--- a/src/OPERATORS/op-fcm-fcs.cc
+++ b/src/OPERATORS/op-fcm-fcs.cc
@@ -33,161 +33,161 @@ along with Octave; see the file COPYING.
 #include "ov-complex.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // complex matrix by complex scalar ops.
 
-DEFNDBINOP_OP (add, float_complex_matrix, float_complex, 
+DEFNDBINOP_OP (add, float_complex_matrix, float_complex,
                float_complex_array, float_complex, +)
-DEFNDBINOP_OP (sub, float_complex_matrix, float_complex, 
+DEFNDBINOP_OP (sub, float_complex_matrix, float_complex,
                float_complex_array, float_complex, -)
-DEFNDBINOP_OP (mul, float_complex_matrix, float_complex, 
+DEFNDBINOP_OP (mul, float_complex_matrix, float_complex,
                float_complex_array, float_complex, *)
 
 DEFBINOP (div, float_complex_matrix, float_complex)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&, 
+  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
                    const octave_float_complex&);
 
   FloatComplex d = v2.float_complex_value ();
 
   if (d == static_cast<float>(0.0))
     gripe_divide_by_zero ();
 
   return octave_value (v1.float_complex_array_value () / d);
 }
 
 DEFBINOP_FN (pow, float_complex_matrix, float_complex, xpow)
 
 DEFBINOP (ldiv, float_complex_matrix, float_complex)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&, 
+  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
                    const octave_float_complex&);
 
   FloatComplexMatrix m1 = v1.float_complex_matrix_value ();
   FloatComplexMatrix m2 = v2.float_complex_matrix_value ();
   MatrixType typ = v1.matrix_type ();
 
   FloatComplexMatrix ret = xleftdiv (m1, m2, typ);
   v1.matrix_type (typ);
   return ret;
 }
 
-DEFNDCMPLXCMPOP_FN (lt, float_complex_matrix, float_complex, 
+DEFNDCMPLXCMPOP_FN (lt, float_complex_matrix, float_complex,
                float_complex_array, float_complex, mx_el_lt)
-DEFNDCMPLXCMPOP_FN (le, float_complex_matrix, float_complex, 
+DEFNDCMPLXCMPOP_FN (le, float_complex_matrix, float_complex,
                float_complex_array, float_complex, mx_el_le)
-DEFNDCMPLXCMPOP_FN (eq, float_complex_matrix, float_complex, 
+DEFNDCMPLXCMPOP_FN (eq, float_complex_matrix, float_complex,
                float_complex_array, float_complex, mx_el_eq)
-DEFNDCMPLXCMPOP_FN (ge, float_complex_matrix, float_complex, 
+DEFNDCMPLXCMPOP_FN (ge, float_complex_matrix, float_complex,
                float_complex_array, float_complex, mx_el_ge)
-DEFNDCMPLXCMPOP_FN (gt, float_complex_matrix, float_complex, 
+DEFNDCMPLXCMPOP_FN (gt, float_complex_matrix, float_complex,
                float_complex_array, float_complex, mx_el_gt)
-DEFNDCMPLXCMPOP_FN (ne, float_complex_matrix, float_complex, 
+DEFNDCMPLXCMPOP_FN (ne, float_complex_matrix, float_complex,
                float_complex_array, float_complex, mx_el_ne)
 
-DEFNDBINOP_OP (el_mul, float_complex_matrix, float_complex, 
+DEFNDBINOP_OP (el_mul, float_complex_matrix, float_complex,
                float_complex_array, float_complex, *)
 
 DEFBINOP (el_div, float_complex_matrix, float_complex)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&, 
+  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
                    const octave_float_complex&);
 
   FloatComplex d = v2.float_complex_value ();
 
   if (d == static_cast<float>(0.0))
     gripe_divide_by_zero ();
 
   return octave_value (v1.float_complex_array_value () / d);
 }
 
-DEFNDBINOP_FN (el_pow, float_complex_matrix, float_complex, 
+DEFNDBINOP_FN (el_pow, float_complex_matrix, float_complex,
                float_complex_array, float_complex, elem_xpow)
 
 DEFBINOP (el_ldiv, float_complex_matrix, float_complex)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&, 
+  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
                    const octave_float_complex&);
 
   return x_el_div (v2.float_complex_value (), v1.float_complex_array_value ());
 }
 
-DEFNDBINOP_FN (el_and, float_complex_matrix, float_complex, 
+DEFNDBINOP_FN (el_and, float_complex_matrix, float_complex,
                float_complex_array, float_complex, mx_el_and)
-DEFNDBINOP_FN (el_or,  float_complex_matrix, float_complex, 
+DEFNDBINOP_FN (el_or,  float_complex_matrix, float_complex,
                float_complex_array, float_complex, mx_el_or)
 
-DEFNDCATOP_FN (fcm_fcs, float_complex_matrix, float_complex, 
+DEFNDCATOP_FN (fcm_fcs, float_complex_matrix, float_complex,
                float_complex_array, float_complex_array, concat)
 
-DEFNDCATOP_FN (cm_fcs, complex_matrix, float_complex, 
+DEFNDCATOP_FN (cm_fcs, complex_matrix, float_complex,
                float_complex_array, float_complex_array, concat)
 
-DEFNDCATOP_FN (fcm_cs, float_complex_matrix, complex, 
+DEFNDCATOP_FN (fcm_cs, float_complex_matrix, complex,
                float_complex_array, float_complex_array, concat)
 
-DEFNDASSIGNOP_FN (assign, float_complex_matrix, float_complex, 
+DEFNDASSIGNOP_FN (assign, float_complex_matrix, float_complex,
                   float_complex, assign)
-DEFNDASSIGNOP_FN (dbl_assign, complex_matrix, float_complex, 
+DEFNDASSIGNOP_FN (dbl_assign, complex_matrix, float_complex,
                   complex, assign)
 
 DEFNDASSIGNOP_OP (assign_add, float_complex_matrix, float_complex_scalar,
                   float_complex, +=)
 DEFNDASSIGNOP_OP (assign_sub, float_complex_matrix, float_complex_scalar,
                   float_complex, -=)
 DEFNDASSIGNOP_OP (assign_mul, float_complex_matrix, float_complex_scalar,
                   float_complex, *=)
 DEFNDASSIGNOP_OP (assign_div, float_complex_matrix, float_complex_scalar,
                   float_complex, /=)
 
 void
 install_fcm_fcs_ops (void)
 {
-  INSTALL_BINOP (op_add, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_add, octave_float_complex_matrix,
                  octave_float_complex, add);
-  INSTALL_BINOP (op_sub, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_sub, octave_float_complex_matrix,
                  octave_float_complex, sub);
-  INSTALL_BINOP (op_mul, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_mul, octave_float_complex_matrix,
                  octave_float_complex, mul);
-  INSTALL_BINOP (op_div, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_div, octave_float_complex_matrix,
                  octave_float_complex, div);
-  INSTALL_BINOP (op_pow, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_pow, octave_float_complex_matrix,
                  octave_float_complex, pow);
-  INSTALL_BINOP (op_ldiv, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_ldiv, octave_float_complex_matrix,
                  octave_float_complex, ldiv);
   INSTALL_BINOP (op_lt, octave_float_complex_matrix, octave_float_complex, lt);
   INSTALL_BINOP (op_le, octave_float_complex_matrix, octave_float_complex, le);
   INSTALL_BINOP (op_eq, octave_float_complex_matrix, octave_float_complex, eq);
   INSTALL_BINOP (op_ge, octave_float_complex_matrix, octave_float_complex, ge);
   INSTALL_BINOP (op_gt, octave_float_complex_matrix, octave_float_complex, gt);
   INSTALL_BINOP (op_ne, octave_float_complex_matrix, octave_float_complex, ne);
-  INSTALL_BINOP (op_el_mul, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_el_mul, octave_float_complex_matrix,
                  octave_float_complex, el_mul);
-  INSTALL_BINOP (op_el_div, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_el_div, octave_float_complex_matrix,
                  octave_float_complex, el_div);
-  INSTALL_BINOP (op_el_pow, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_el_pow, octave_float_complex_matrix,
                  octave_float_complex, el_pow);
-  INSTALL_BINOP (op_el_ldiv, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_el_ldiv, octave_float_complex_matrix,
                  octave_float_complex, el_ldiv);
-  INSTALL_BINOP (op_el_and, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_el_and, octave_float_complex_matrix,
                  octave_float_complex, el_and);
-  INSTALL_BINOP (op_el_or, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_el_or, octave_float_complex_matrix,
                  octave_float_complex, el_or);
 
   INSTALL_CATOP (octave_float_complex_matrix, octave_float_complex, fcm_fcs);
   INSTALL_CATOP (octave_complex_matrix, octave_float_complex, cm_fcs);
   INSTALL_CATOP (octave_float_complex_matrix, octave_complex, fcm_cs);
 
-  INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix, 
+  INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix,
                     octave_float_complex, assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, 
+  INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix,
                     octave_float_complex, dbl_assign);
 
   INSTALL_ASSIGNOP (op_add_eq, octave_float_complex_matrix,
                     octave_float_complex_scalar, assign_add);
   INSTALL_ASSIGNOP (op_sub_eq, octave_float_complex_matrix,
                     octave_float_complex_scalar, assign_sub);
   INSTALL_ASSIGNOP (op_mul_eq, octave_float_complex_matrix,
                     octave_float_complex_scalar, assign_mul);
diff --git a/src/OPERATORS/op-fcm-fm.cc b/src/OPERATORS/op-fcm-fm.cc
--- a/src/OPERATORS/op-fcm-fm.cc
+++ b/src/OPERATORS/op-fcm-fm.cc
@@ -56,128 +56,128 @@ DEFBINOP (mul_trans, float_complex_matri
   FloatMatrix m2 = v2.float_matrix_value ();
 
   return FloatComplexMatrix (xgemm (real (m1), m2, blas_no_trans, blas_trans),
                              xgemm (imag (m1), m2, blas_no_trans, blas_trans));
 }
 
 DEFBINOP (div, float_complex_matrix, float_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&, 
+  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
                    const octave_float_matrix&);
   MatrixType typ = v2.matrix_type ();
-  
-  FloatComplexMatrix ret = xdiv (v1.float_complex_matrix_value (), 
+
+  FloatComplexMatrix ret = xdiv (v1.float_complex_matrix_value (),
                                  v2.float_matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 
 DEFBINOPX (pow, float_complex_matrix, float_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, float_complex_matrix, float_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&, 
+  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
                    const octave_float_matrix&);
   MatrixType typ = v1.matrix_type ();
-  
-  FloatComplexMatrix ret = xleftdiv (v1.float_complex_matrix_value (), 
+
+  FloatComplexMatrix ret = xleftdiv (v1.float_complex_matrix_value (),
                                      v2.float_matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
-DEFNDCMPLXCMPOP_FN (lt, float_complex_matrix, float_matrix, 
+DEFNDCMPLXCMPOP_FN (lt, float_complex_matrix, float_matrix,
                float_complex_array, float_array, mx_el_lt)
-DEFNDCMPLXCMPOP_FN (le, float_complex_matrix, float_matrix, 
+DEFNDCMPLXCMPOP_FN (le, float_complex_matrix, float_matrix,
                float_complex_array, float_array, mx_el_le)
-DEFNDCMPLXCMPOP_FN (eq, float_complex_matrix, float_matrix, 
+DEFNDCMPLXCMPOP_FN (eq, float_complex_matrix, float_matrix,
                float_complex_array, float_array, mx_el_eq)
-DEFNDCMPLXCMPOP_FN (ge, float_complex_matrix, float_matrix, 
+DEFNDCMPLXCMPOP_FN (ge, float_complex_matrix, float_matrix,
                float_complex_array, float_array, mx_el_ge)
-DEFNDCMPLXCMPOP_FN (gt, float_complex_matrix, float_matrix, 
+DEFNDCMPLXCMPOP_FN (gt, float_complex_matrix, float_matrix,
                float_complex_array, float_array, mx_el_gt)
-DEFNDCMPLXCMPOP_FN (ne, float_complex_matrix, float_matrix, 
+DEFNDCMPLXCMPOP_FN (ne, float_complex_matrix, float_matrix,
                float_complex_array, float_array, mx_el_ne)
 
-DEFNDBINOP_FN (el_mul, float_complex_matrix, float_matrix, 
+DEFNDBINOP_FN (el_mul, float_complex_matrix, float_matrix,
                float_complex_array, float_array, product)
-DEFNDBINOP_FN (el_div, float_complex_matrix, float_matrix, 
+DEFNDBINOP_FN (el_div, float_complex_matrix, float_matrix,
                float_complex_array, float_array, quotient)
-DEFNDBINOP_FN (el_pow, float_complex_matrix, float_matrix, 
+DEFNDBINOP_FN (el_pow, float_complex_matrix, float_matrix,
                float_complex_array, float_array, elem_xpow)
 
 DEFBINOP (el_ldiv, float_complex_matrix, float_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&, 
+  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
                    const octave_float_matrix&);
 
   return quotient (v2.float_array_value (), v1.float_complex_array_value ());
 }
 
-DEFNDBINOP_FN (el_and, float_complex_matrix, float_matrix, 
+DEFNDBINOP_FN (el_and, float_complex_matrix, float_matrix,
                float_complex_array, float_array, mx_el_and)
-DEFNDBINOP_FN (el_or,  float_complex_matrix, float_matrix, 
+DEFNDBINOP_FN (el_or,  float_complex_matrix, float_matrix,
                float_complex_array, float_array, mx_el_or)
 
-DEFNDCATOP_FN (fcm_fm, float_complex_matrix, float_matrix, 
+DEFNDCATOP_FN (fcm_fm, float_complex_matrix, float_matrix,
                float_complex_array, float_array, concat)
 
-DEFNDCATOP_FN (cm_fm, complex_matrix, float_matrix, 
+DEFNDCATOP_FN (cm_fm, complex_matrix, float_matrix,
                float_complex_array, float_array, concat)
 
-DEFNDCATOP_FN (fcm_m, float_complex_matrix, matrix, 
+DEFNDCATOP_FN (fcm_m, float_complex_matrix, matrix,
                float_complex_array, float_array, concat)
 
-DEFNDASSIGNOP_FN (assign, float_complex_matrix, float_matrix, 
+DEFNDASSIGNOP_FN (assign, float_complex_matrix, float_matrix,
                   float_complex_array, assign)
-DEFNDASSIGNOP_FN (dbl_assign, complex_matrix, float_matrix, 
+DEFNDASSIGNOP_FN (dbl_assign, complex_matrix, float_matrix,
                   complex_array, assign)
 
 void
 install_fcm_fm_ops (void)
 {
   INSTALL_BINOP (op_add, octave_float_complex_matrix, octave_float_matrix, add);
   INSTALL_BINOP (op_sub, octave_float_complex_matrix, octave_float_matrix, sub);
   INSTALL_BINOP (op_mul, octave_float_complex_matrix, octave_float_matrix, mul);
   INSTALL_BINOP (op_div, octave_float_complex_matrix, octave_float_matrix, div);
   INSTALL_BINOP (op_pow, octave_float_complex_matrix, octave_float_matrix, pow);
-  INSTALL_BINOP (op_ldiv, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_ldiv, octave_float_complex_matrix,
                  octave_float_matrix, ldiv);
   INSTALL_BINOP (op_lt, octave_float_complex_matrix, octave_float_matrix, lt);
   INSTALL_BINOP (op_le, octave_float_complex_matrix, octave_float_matrix, le);
   INSTALL_BINOP (op_eq, octave_float_complex_matrix, octave_float_matrix, eq);
   INSTALL_BINOP (op_ge, octave_float_complex_matrix, octave_float_matrix, ge);
   INSTALL_BINOP (op_gt, octave_float_complex_matrix, octave_float_matrix, gt);
   INSTALL_BINOP (op_ne, octave_float_complex_matrix, octave_float_matrix, ne);
-  INSTALL_BINOP (op_el_mul, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_el_mul, octave_float_complex_matrix,
                  octave_float_matrix, el_mul);
-  INSTALL_BINOP (op_el_div, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_el_div, octave_float_complex_matrix,
                  octave_float_matrix, el_div);
-  INSTALL_BINOP (op_el_pow, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_el_pow, octave_float_complex_matrix,
                  octave_float_matrix, el_pow);
-  INSTALL_BINOP (op_el_ldiv, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_el_ldiv, octave_float_complex_matrix,
                  octave_float_matrix, el_ldiv);
-  INSTALL_BINOP (op_el_and, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_el_and, octave_float_complex_matrix,
                  octave_float_matrix, el_and);
-  INSTALL_BINOP (op_el_or, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_el_or, octave_float_complex_matrix,
                  octave_float_matrix, el_or);
-  INSTALL_BINOP (op_mul_trans, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_mul_trans, octave_float_complex_matrix,
                  octave_float_matrix, mul_trans);
-  INSTALL_BINOP (op_mul_herm, octave_float_complex_matrix, 
+  INSTALL_BINOP (op_mul_herm, octave_float_complex_matrix,
                  octave_float_matrix, mul_trans);
 
   INSTALL_CATOP (octave_float_complex_matrix, octave_float_matrix, fcm_fm);
   INSTALL_CATOP (octave_complex_matrix, octave_float_matrix, cm_fm);
   INSTALL_CATOP (octave_float_complex_matrix, octave_matrix, fcm_m);
 
-  INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix, 
+  INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix,
                     octave_float_matrix, assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, 
+  INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix,
                     octave_float_matrix, dbl_assign);
 }
diff --git a/src/OPERATORS/op-fcm-fs.cc b/src/OPERATORS/op-fcm-fs.cc
--- a/src/OPERATORS/op-fcm-fs.cc
+++ b/src/OPERATORS/op-fcm-fs.cc
@@ -69,66 +69,66 @@ DEFBINOP (ldiv, float_complex_matrix, fl
   MatrixType typ = v1.matrix_type ();
 
   FloatComplexMatrix ret = xleftdiv (m1, m2, typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
-DEFNDCMPLXCMPOP_FN (lt, float_complex_matrix, float_scalar, float_complex_array, 
+DEFNDCMPLXCMPOP_FN (lt, float_complex_matrix, float_scalar, float_complex_array,
                float_scalar, mx_el_lt)
-DEFNDCMPLXCMPOP_FN (le, float_complex_matrix, float_scalar, float_complex_array, 
+DEFNDCMPLXCMPOP_FN (le, float_complex_matrix, float_scalar, float_complex_array,
                float_scalar, mx_el_le)
-DEFNDCMPLXCMPOP_FN (eq, float_complex_matrix, float_scalar, float_complex_array, 
+DEFNDCMPLXCMPOP_FN (eq, float_complex_matrix, float_scalar, float_complex_array,
                float_scalar, mx_el_eq)
-DEFNDCMPLXCMPOP_FN (ge, float_complex_matrix, float_scalar, float_complex_array, 
+DEFNDCMPLXCMPOP_FN (ge, float_complex_matrix, float_scalar, float_complex_array,
                float_scalar, mx_el_ge)
-DEFNDCMPLXCMPOP_FN (gt, float_complex_matrix, float_scalar, float_complex_array, 
+DEFNDCMPLXCMPOP_FN (gt, float_complex_matrix, float_scalar, float_complex_array,
                float_scalar, mx_el_gt)
-DEFNDCMPLXCMPOP_FN (ne, float_complex_matrix, float_scalar, float_complex_array, 
+DEFNDCMPLXCMPOP_FN (ne, float_complex_matrix, float_scalar, float_complex_array,
                float_scalar, mx_el_ne)
 
-DEFNDBINOP_OP (el_mul, float_complex_matrix, float_scalar, float_complex_array, 
+DEFNDBINOP_OP (el_mul, float_complex_matrix, float_scalar, float_complex_array,
                float_scalar, *)
 
 DEFBINOP (el_div, float_complex_matrix, float)
 {
   CAST_BINOP_ARGS (const octave_float_complex_matrix&, const octave_float_scalar&);
 
   float d = v2.float_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v1.float_complex_array_value () / d);
 }
 
-DEFNDBINOP_FN (el_pow, float_complex_matrix, float_scalar, float_complex_array, 
+DEFNDBINOP_FN (el_pow, float_complex_matrix, float_scalar, float_complex_array,
                float_scalar, elem_xpow)
 
 DEFBINOP (el_ldiv, float_complex_matrix, float)
 {
   CAST_BINOP_ARGS (const octave_float_complex_matrix&, const octave_float_scalar&);
 
   return x_el_div (v2.float_value (), v1.float_complex_array_value ());
 }
 
-DEFNDBINOP_FN (el_and, float_complex_matrix, float_scalar, float_complex_array, 
+DEFNDBINOP_FN (el_and, float_complex_matrix, float_scalar, float_complex_array,
                float_scalar, mx_el_and)
-DEFNDBINOP_FN (el_or,  float_complex_matrix, float_scalar, float_complex_array, 
+DEFNDBINOP_FN (el_or,  float_complex_matrix, float_scalar, float_complex_array,
                float_scalar, mx_el_or)
 
-DEFNDCATOP_FN (fcm_fs, float_complex_matrix, float_scalar, float_complex_array, 
+DEFNDCATOP_FN (fcm_fs, float_complex_matrix, float_scalar, float_complex_array,
                float_array, concat)
 
-DEFNDCATOP_FN (cm_fs, complex_matrix, float_scalar, float_complex_array, 
+DEFNDCATOP_FN (cm_fs, complex_matrix, float_scalar, float_complex_array,
                float_array, concat)
 
-DEFNDCATOP_FN (fcm_s, float_complex_matrix, scalar, float_complex_array, 
+DEFNDCATOP_FN (fcm_s, float_complex_matrix, scalar, float_complex_array,
                float_array, concat)
 
 DEFNDASSIGNOP_FN (assign, float_complex_matrix, float_scalar, float_complex_array, assign)
 DEFNDASSIGNOP_FN (dbl_assign, complex_matrix, float_scalar, complex_array, assign)
 
 DEFNDASSIGNOP_OP (assign_mul, float_complex_matrix, float_scalar,
                   float_scalar, *=)
 DEFNDASSIGNOP_OP (assign_div, float_complex_matrix, float_scalar,
@@ -155,18 +155,18 @@ install_fcm_fs_ops (void)
   INSTALL_BINOP (op_el_ldiv, octave_float_complex_matrix, octave_float_scalar, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_float_complex_matrix, octave_float_scalar, el_and);
   INSTALL_BINOP (op_el_or, octave_float_complex_matrix, octave_float_scalar, el_or);
 
   INSTALL_CATOP (octave_float_complex_matrix, octave_float_scalar, fcm_fs);
   INSTALL_CATOP (octave_complex_matrix, octave_float_scalar, cm_fs);
   INSTALL_CATOP (octave_float_complex_matrix, octave_scalar, fcm_s);
 
-  INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix, 
+  INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix,
                     octave_float_scalar, assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, 
+  INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix,
                     octave_float_scalar, dbl_assign);
 
   INSTALL_ASSIGNOP (op_mul_eq, octave_float_complex_matrix,
                     octave_float_scalar, assign_mul);
   INSTALL_ASSIGNOP (op_div_eq, octave_float_complex_matrix,
                     octave_float_scalar, assign_div);
 }
diff --git a/src/OPERATORS/op-fcs-fcm.cc b/src/OPERATORS/op-fcs-fcm.cc
--- a/src/OPERATORS/op-fcs-fcm.cc
+++ b/src/OPERATORS/op-fcs-fcm.cc
@@ -65,34 +65,34 @@ DEFBINOP (ldiv, float_complex, float_com
   FloatComplex d = v1.float_complex_value ();
 
   if (d == static_cast<float>(0.0))
     gripe_divide_by_zero ();
 
   return octave_value (v2.float_complex_array_value () / d);
 }
 
-DEFNDCMPLXCMPOP_FN (lt, float_complex, float_complex_matrix, float_complex, 
+DEFNDCMPLXCMPOP_FN (lt, float_complex, float_complex_matrix, float_complex,
                float_complex_array, mx_el_lt)
-DEFNDCMPLXCMPOP_FN (le, float_complex, float_complex_matrix, float_complex, 
+DEFNDCMPLXCMPOP_FN (le, float_complex, float_complex_matrix, float_complex,
                float_complex_array, mx_el_le)
-DEFNDCMPLXCMPOP_FN (eq, float_complex, float_complex_matrix, float_complex, 
+DEFNDCMPLXCMPOP_FN (eq, float_complex, float_complex_matrix, float_complex,
                float_complex_array, mx_el_eq)
-DEFNDCMPLXCMPOP_FN (ge, float_complex, float_complex_matrix, float_complex, 
+DEFNDCMPLXCMPOP_FN (ge, float_complex, float_complex_matrix, float_complex,
                float_complex_array, mx_el_ge)
-DEFNDCMPLXCMPOP_FN (gt, float_complex, float_complex_matrix, float_complex, 
+DEFNDCMPLXCMPOP_FN (gt, float_complex, float_complex_matrix, float_complex,
                float_complex_array, mx_el_gt)
-DEFNDCMPLXCMPOP_FN (ne, float_complex, float_complex_matrix, float_complex, 
+DEFNDCMPLXCMPOP_FN (ne, float_complex, float_complex_matrix, float_complex,
                float_complex_array, mx_el_ne)
 
-DEFNDBINOP_OP (el_mul, float_complex, float_complex_matrix, float_complex, 
+DEFNDBINOP_OP (el_mul, float_complex, float_complex_matrix, float_complex,
                float_complex_array, *)
-DEFNDBINOP_FN (el_div, float_complex, float_complex_matrix, float_complex, 
+DEFNDBINOP_FN (el_div, float_complex, float_complex_matrix, float_complex,
                float_complex_array, x_el_div)
-DEFNDBINOP_FN (el_pow, float_complex, float_complex_matrix, float_complex, 
+DEFNDBINOP_FN (el_pow, float_complex, float_complex_matrix, float_complex,
                float_complex_array, elem_xpow)
 
 DEFBINOP (el_ldiv, float_complex, float_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_complex_matrix&);
 
   FloatComplex d = v1.float_complex_value ();
 
diff --git a/src/OPERATORS/op-fcs-fcs.cc b/src/OPERATORS/op-fcs-fcs.cc
--- a/src/OPERATORS/op-fcs-fcs.cc
+++ b/src/OPERATORS/op-fcs-fcs.cc
@@ -127,35 +127,35 @@ DEFBINOP (el_ldiv, float_complex, float_
 
   return octave_value (v2.float_complex_value () / d);
 }
 
 DEFBINOP (el_and, float_complex, float_complex)
 {
   CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_complex&);
 
-  return (v1.float_complex_value () != static_cast<float>(0.0) && 
+  return (v1.float_complex_value () != static_cast<float>(0.0) &&
           v2.float_complex_value () != static_cast<float>(0.0));
 }
 
 DEFBINOP (el_or, float_complex, float_complex)
 {
   CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_complex&);
 
-  return (v1.float_complex_value () != static_cast<float>(0.0) || 
+  return (v1.float_complex_value () != static_cast<float>(0.0) ||
           v2.float_complex_value () != static_cast<float>(0.0));
 }
 
-DEFNDCATOP_FN (fcs_fcs, float_complex, float_complex, float_complex_array, 
+DEFNDCATOP_FN (fcs_fcs, float_complex, float_complex, float_complex_array,
                float_complex_array, concat)
 
-DEFNDCATOP_FN (cs_fcs, complex, float_complex, float_complex_array, 
+DEFNDCATOP_FN (cs_fcs, complex, float_complex, float_complex_array,
                float_complex_array, concat)
 
-DEFNDCATOP_FN (fcs_cs, float_complex, complex, float_complex_array, 
+DEFNDCATOP_FN (fcs_cs, float_complex, complex, float_complex_array,
                float_complex_array, concat)
 
 CONVDECL (float_complex_to_complex)
 {
   CAST_CONV_ARG (const octave_float_complex&);
 
   return new octave_complex_matrix (ComplexMatrix (1, 1, static_cast<Complex>(v.float_complex_value ())));
 }
@@ -198,11 +198,11 @@ install_fcs_fcs_ops (void)
   INSTALL_ASSIGNCONV (octave_float_complex, octave_float_complex, octave_float_complex_matrix);
 
   INSTALL_ASSIGNCONV (octave_complex, octave_float_complex, octave_complex_matrix);
 
   INSTALL_ASSIGNCONV (octave_float_complex, octave_null_matrix, octave_float_complex_matrix);
   INSTALL_ASSIGNCONV (octave_float_complex, octave_null_str, octave_float_complex_matrix);
   INSTALL_ASSIGNCONV (octave_float_complex, octave_null_sq_str, octave_float_complex_matrix);
 
-  INSTALL_CONVOP (octave_float_complex, octave_complex_matrix, 
+  INSTALL_CONVOP (octave_float_complex, octave_complex_matrix,
                   float_complex_to_complex);
 }
diff --git a/src/OPERATORS/op-fcs-fm.cc b/src/OPERATORS/op-fcs-fm.cc
--- a/src/OPERATORS/op-fcs-fm.cc
+++ b/src/OPERATORS/op-fcs-fm.cc
@@ -72,60 +72,60 @@ DEFBINOP (ldiv, float_complex, float_mat
   FloatComplex d = v1.float_complex_value ();
 
   if (d == static_cast<float>(0.0))
     gripe_divide_by_zero ();
 
   return octave_value (v2.float_array_value () / d);
 }
 
-DEFNDCMPLXCMPOP_FN (lt, float_complex, float_matrix, float_complex, 
+DEFNDCMPLXCMPOP_FN (lt, float_complex, float_matrix, float_complex,
                float_array, mx_el_lt)
-DEFNDCMPLXCMPOP_FN (le, float_complex, float_matrix, float_complex, 
+DEFNDCMPLXCMPOP_FN (le, float_complex, float_matrix, float_complex,
                float_array, mx_el_le)
-DEFNDCMPLXCMPOP_FN (eq, float_complex, float_matrix, float_complex, 
+DEFNDCMPLXCMPOP_FN (eq, float_complex, float_matrix, float_complex,
                float_array, mx_el_eq)
-DEFNDCMPLXCMPOP_FN (ge, float_complex, float_matrix, float_complex, 
+DEFNDCMPLXCMPOP_FN (ge, float_complex, float_matrix, float_complex,
                float_array, mx_el_ge)
-DEFNDCMPLXCMPOP_FN (gt, float_complex, float_matrix, float_complex, 
+DEFNDCMPLXCMPOP_FN (gt, float_complex, float_matrix, float_complex,
                float_array, mx_el_gt)
-DEFNDCMPLXCMPOP_FN (ne, float_complex, float_matrix, float_complex, 
+DEFNDCMPLXCMPOP_FN (ne, float_complex, float_matrix, float_complex,
                float_array, mx_el_ne)
 
-DEFNDBINOP_OP (el_mul, float_complex, float_matrix, float_complex, 
+DEFNDBINOP_OP (el_mul, float_complex, float_matrix, float_complex,
                float_array, *)
-DEFNDBINOP_FN (el_div, float_complex, float_matrix, float_complex, 
+DEFNDBINOP_FN (el_div, float_complex, float_matrix, float_complex,
                float_array, x_el_div)
-DEFNDBINOP_FN (el_pow, float_complex, float_matrix, float_complex, 
+DEFNDBINOP_FN (el_pow, float_complex, float_matrix, float_complex,
                float_array, elem_xpow)
 
 DEFBINOP (el_ldiv, float_complex, float_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_matrix&);
 
   FloatComplex d = v1.float_complex_value ();
 
   if (d == static_cast<float>(0.0))
     gripe_divide_by_zero ();
 
   return octave_value (v2.float_array_value () / d);
 }
 
-DEFNDBINOP_FN (el_and, float_complex, float_matrix, float_complex, 
+DEFNDBINOP_FN (el_and, float_complex, float_matrix, float_complex,
                float_array, mx_el_and)
-DEFNDBINOP_FN (el_or,  float_complex, float_matrix, float_complex, 
+DEFNDBINOP_FN (el_or,  float_complex, float_matrix, float_complex,
                float_array, mx_el_or)
 
-DEFNDCATOP_FN (fcs_fm, float_complex, float_matrix, float_complex_array, 
+DEFNDCATOP_FN (fcs_fm, float_complex, float_matrix, float_complex_array,
                float_array, concat)
 
-DEFNDCATOP_FN (cs_fm, complex, float_matrix, float_complex_array, 
+DEFNDCATOP_FN (cs_fm, complex, float_matrix, float_complex_array,
                float_array, concat)
 
-DEFNDCATOP_FN (fcs_m, float_complex, matrix, float_complex_array, 
+DEFNDCATOP_FN (fcs_m, float_complex, matrix, float_complex_array,
                float_array, concat)
 
 void
 install_fcs_fm_ops (void)
 {
   INSTALL_BINOP (op_add, octave_float_complex, octave_float_matrix, add);
   INSTALL_BINOP (op_sub, octave_float_complex, octave_float_matrix, sub);
   INSTALL_BINOP (op_mul, octave_float_complex, octave_float_matrix, mul);
@@ -144,13 +144,13 @@ install_fcs_fm_ops (void)
   INSTALL_BINOP (op_el_ldiv, octave_float_complex, octave_float_matrix, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_float_complex, octave_float_matrix, el_and);
   INSTALL_BINOP (op_el_or, octave_float_complex, octave_float_matrix, el_or);
 
   INSTALL_CATOP (octave_float_complex, octave_float_matrix, fcs_fm);
   INSTALL_CATOP (octave_complex, octave_float_matrix, cs_fm);
   INSTALL_CATOP (octave_float_complex, octave_matrix, fcs_m);
 
-  INSTALL_ASSIGNCONV (octave_float_complex, octave_float_matrix, 
+  INSTALL_ASSIGNCONV (octave_float_complex, octave_float_matrix,
                       octave_float_complex_matrix);
-  INSTALL_ASSIGNCONV (octave_complex, octave_float_matrix, 
+  INSTALL_ASSIGNCONV (octave_complex, octave_float_matrix,
                       octave_complex_matrix);
 }
diff --git a/src/OPERATORS/op-fcs-fs.cc b/src/OPERATORS/op-fcs-fs.cc
--- a/src/OPERATORS/op-fcs-fs.cc
+++ b/src/OPERATORS/op-fcs-fs.cc
@@ -104,35 +104,35 @@ DEFBINOP (el_ldiv, float_complex, float)
 
   return octave_value (v2.float_value () / d);
 }
 
 DEFBINOP (el_and, float_complex, float)
 {
   CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_scalar&);
 
-  return (v1.float_complex_value () != static_cast<float>(0.0) && 
+  return (v1.float_complex_value () != static_cast<float>(0.0) &&
           v2.float_value ());
 }
 
 DEFBINOP (el_or, float_complex, float)
 {
   CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_scalar&);
 
-  return (v1.float_complex_value () != static_cast<float>(0.0) || 
+  return (v1.float_complex_value () != static_cast<float>(0.0) ||
           v2.float_value ());
 }
 
-DEFNDCATOP_FN (fcs_fs, float_complex, float_scalar, float_complex_array, 
+DEFNDCATOP_FN (fcs_fs, float_complex, float_scalar, float_complex_array,
                float_array, concat)
 
-DEFNDCATOP_FN (cs_fs, complex, float_scalar, float_complex_array, 
+DEFNDCATOP_FN (cs_fs, complex, float_scalar, float_complex_array,
                float_array, concat)
 
-DEFNDCATOP_FN (fcs_s, float_complex, scalar, float_complex_array, 
+DEFNDCATOP_FN (fcs_s, float_complex, scalar, float_complex_array,
                float_array, concat)
 
 void
 install_fcs_fs_ops (void)
 {
   INSTALL_BINOP (op_add, octave_float_complex, octave_float_scalar, add);
   INSTALL_BINOP (op_sub, octave_float_complex, octave_float_scalar, sub);
   INSTALL_BINOP (op_mul, octave_float_complex, octave_float_scalar, mul);
@@ -151,13 +151,13 @@ install_fcs_fs_ops (void)
   INSTALL_BINOP (op_el_ldiv, octave_float_complex, octave_float_scalar, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_float_complex, octave_float_scalar, el_and);
   INSTALL_BINOP (op_el_or, octave_float_complex, octave_float_scalar, el_or);
 
   INSTALL_CATOP (octave_float_complex, octave_float_scalar, fcs_fs);
   INSTALL_CATOP (octave_complex, octave_float_scalar, cs_fs);
   INSTALL_CATOP (octave_float_complex, octave_scalar, fcs_s);
 
-  INSTALL_ASSIGNCONV (octave_float_complex, octave_float_scalar, 
+  INSTALL_ASSIGNCONV (octave_float_complex, octave_float_scalar,
                       octave_float_complex_matrix);
-  INSTALL_ASSIGNCONV (octave_complex, octave_float_scalar, 
+  INSTALL_ASSIGNCONV (octave_complex, octave_float_scalar,
                       octave_complex_matrix);
 }
diff --git a/src/OPERATORS/op-fdm-fdm.cc b/src/OPERATORS/op-fdm-fdm.cc
--- a/src/OPERATORS/op-fdm-fdm.cc
+++ b/src/OPERATORS/op-fdm-fdm.cc
@@ -50,25 +50,25 @@ DEFUNOP (transpose, float_diag_matrix)
 
 DEFBINOP_OP (add, float_diag_matrix, float_diag_matrix, +)
 DEFBINOP_OP (sub, float_diag_matrix, float_diag_matrix, -)
 DEFBINOP_OP (mul, float_diag_matrix, float_diag_matrix, *)
 
 DEFBINOP (div, float_diag_matrix, float_diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_diag_matrix&, const octave_float_diag_matrix&);
-  
-  return xdiv (v1.float_diag_matrix_value (), 
+
+  return xdiv (v1.float_diag_matrix_value (),
                v2.float_diag_matrix_value ());
 }
 
 DEFBINOP (ldiv, float_diag_matrix, float_diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_diag_matrix&, const octave_float_diag_matrix&);
-  
+
   return xleftdiv (v1.float_diag_matrix_value (),
                    v2.float_diag_matrix_value ());
 }
 
 CONVDECL (float_diag_matrix_to_diag_matrix)
 {
   CAST_CONV_ARG (const octave_float_diag_matrix&);
 
diff --git a/src/OPERATORS/op-fm-fcm.cc b/src/OPERATORS/op-fm-fcm.cc
--- a/src/OPERATORS/op-fm-fcm.cc
+++ b/src/OPERATORS/op-fm-fcm.cc
@@ -38,19 +38,19 @@ along with Octave; see the file COPYING.
 #include "ov-flt-cx-mat.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // matrix by complex matrix ops.
 
-DEFNDBINOP_OP (add, float_matrix, float_complex_matrix, float_array, 
+DEFNDBINOP_OP (add, float_matrix, float_complex_matrix, float_array,
                float_complex_array, +)
-DEFNDBINOP_OP (sub, float_matrix, float_complex_matrix, float_array, 
+DEFNDBINOP_OP (sub, float_matrix, float_complex_matrix, float_array,
                float_complex_array, -)
 
 DEFBINOP_OP (mul, float_matrix, float_complex_matrix, *)
 
 DEFBINOP (trans_mul, float_matrix, float_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_complex_matrix&);
 
@@ -58,99 +58,99 @@ DEFBINOP (trans_mul, float_matrix, float
   FloatComplexMatrix m2 = v2.float_complex_matrix_value ();
 
   return FloatComplexMatrix (xgemm (m1, real (m2), blas_trans, blas_no_trans),
                              xgemm (m1, imag (m2), blas_trans, blas_no_trans));
 }
 
 DEFBINOP (div, float_matrix, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_matrix&, 
+  CAST_BINOP_ARGS (const octave_float_matrix&,
                    const octave_float_complex_matrix&);
   MatrixType typ = v2.matrix_type ();
-  
-  FloatComplexMatrix ret = xdiv (v1.float_matrix_value (), 
+
+  FloatComplexMatrix ret = xdiv (v1.float_matrix_value (),
                                  v2.float_complex_matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, float_matrix, float_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, float_matrix, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_matrix&, 
+  CAST_BINOP_ARGS (const octave_float_matrix&,
                    const octave_float_complex_matrix&);
   MatrixType typ = v1.matrix_type ();
-  
-  FloatComplexMatrix ret = xleftdiv (v1.float_matrix_value (), 
+
+  FloatComplexMatrix ret = xleftdiv (v1.float_matrix_value (),
                                 v2.float_complex_matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP (trans_ldiv, float_matrix, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_matrix&, 
+  CAST_BINOP_ARGS (const octave_float_matrix&,
                    const octave_float_complex_matrix&);
   MatrixType typ = v1.matrix_type ();
-  
-  FloatComplexMatrix ret = xleftdiv (v1.float_matrix_value (), 
+
+  FloatComplexMatrix ret = xleftdiv (v1.float_matrix_value (),
                          v2.float_complex_matrix_value (), typ, blas_trans);
 
   v1.matrix_type (typ);
   return ret;
 }
 
-DEFNDCMPLXCMPOP_FN (lt, float_matrix, float_complex_matrix, float_array, 
+DEFNDCMPLXCMPOP_FN (lt, float_matrix, float_complex_matrix, float_array,
                float_complex_array, mx_el_lt)
-DEFNDCMPLXCMPOP_FN (le, float_matrix, float_complex_matrix, float_array, 
+DEFNDCMPLXCMPOP_FN (le, float_matrix, float_complex_matrix, float_array,
                float_complex_array, mx_el_le)
-DEFNDCMPLXCMPOP_FN (eq, float_matrix, float_complex_matrix, float_array, 
+DEFNDCMPLXCMPOP_FN (eq, float_matrix, float_complex_matrix, float_array,
                float_complex_array, mx_el_eq)
-DEFNDCMPLXCMPOP_FN (ge, float_matrix, float_complex_matrix, float_array, 
+DEFNDCMPLXCMPOP_FN (ge, float_matrix, float_complex_matrix, float_array,
                float_complex_array, mx_el_ge)
-DEFNDCMPLXCMPOP_FN (gt, float_matrix, float_complex_matrix, float_array, 
+DEFNDCMPLXCMPOP_FN (gt, float_matrix, float_complex_matrix, float_array,
                float_complex_array, mx_el_gt)
-DEFNDCMPLXCMPOP_FN (ne, float_matrix, float_complex_matrix, float_array, 
+DEFNDCMPLXCMPOP_FN (ne, float_matrix, float_complex_matrix, float_array,
                float_complex_array, mx_el_ne)
 
-DEFNDBINOP_FN (el_mul, float_matrix, float_complex_matrix, float_array, 
+DEFNDBINOP_FN (el_mul, float_matrix, float_complex_matrix, float_array,
                float_complex_array, product)
-DEFNDBINOP_FN (el_div, float_matrix, float_complex_matrix, float_array, 
+DEFNDBINOP_FN (el_div, float_matrix, float_complex_matrix, float_array,
                float_complex_array, quotient)
-DEFNDBINOP_FN (el_pow, float_matrix, float_complex_matrix, float_array, 
+DEFNDBINOP_FN (el_pow, float_matrix, float_complex_matrix, float_array,
                float_complex_array, elem_xpow)
 
 DEFBINOP (el_ldiv, float_matrix, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_matrix&, 
+  CAST_BINOP_ARGS (const octave_float_matrix&,
                    const octave_float_complex_matrix&);
 
   return quotient (v2.float_complex_array_value (), v1.float_array_value ());
 }
 
-DEFNDBINOP_FN (el_and, float_matrix, float_complex_matrix, float_array, 
+DEFNDBINOP_FN (el_and, float_matrix, float_complex_matrix, float_array,
                float_complex_array, mx_el_and)
-DEFNDBINOP_FN (el_or,  float_matrix, float_complex_matrix, float_array, 
+DEFNDBINOP_FN (el_or,  float_matrix, float_complex_matrix, float_array,
                float_complex_array, mx_el_or)
 
-DEFNDCATOP_FN (fm_fcm, float_matrix, float_complex_matrix, float_array, 
+DEFNDCATOP_FN (fm_fcm, float_matrix, float_complex_matrix, float_array,
                float_complex_array, concat)
 
-DEFNDCATOP_FN (m_fcm, matrix, float_complex_matrix, float_array, 
+DEFNDCATOP_FN (m_fcm, matrix, float_complex_matrix, float_array,
                float_complex_array, concat)
 
-DEFNDCATOP_FN (fm_cm, float_matrix, complex_matrix, float_array, 
+DEFNDCATOP_FN (fm_cm, float_matrix, complex_matrix, float_array,
                float_complex_array, concat)
 
 DEFCONV (float_complex_matrix_conv, float_matrix, float_complex_matrix)
 {
   CAST_CONV_ARG (const octave_float_matrix&);
 
   return new octave_float_complex_matrix (FloatComplexNDArray (v.float_array_value ()));
 }
@@ -158,49 +158,49 @@ DEFCONV (float_complex_matrix_conv, floa
 void
 install_fm_fcm_ops (void)
 {
   INSTALL_BINOP (op_add, octave_float_matrix, octave_float_complex_matrix, add);
   INSTALL_BINOP (op_sub, octave_float_matrix, octave_float_complex_matrix, sub);
   INSTALL_BINOP (op_mul, octave_float_matrix, octave_float_complex_matrix, mul);
   INSTALL_BINOP (op_div, octave_float_matrix, octave_float_complex_matrix, div);
   INSTALL_BINOP (op_pow, octave_float_matrix, octave_float_complex_matrix, pow);
-  INSTALL_BINOP (op_ldiv, octave_float_matrix, 
+  INSTALL_BINOP (op_ldiv, octave_float_matrix,
                  octave_float_complex_matrix, ldiv);
   INSTALL_BINOP (op_lt, octave_float_matrix, octave_float_complex_matrix, lt);
   INSTALL_BINOP (op_le, octave_float_matrix, octave_float_complex_matrix, le);
   INSTALL_BINOP (op_eq, octave_float_matrix, octave_float_complex_matrix, eq);
   INSTALL_BINOP (op_ge, octave_float_matrix, octave_float_complex_matrix, ge);
   INSTALL_BINOP (op_gt, octave_float_matrix, octave_float_complex_matrix, gt);
   INSTALL_BINOP (op_ne, octave_float_matrix, octave_float_complex_matrix, ne);
-  INSTALL_BINOP (op_el_mul, octave_float_matrix, 
+  INSTALL_BINOP (op_el_mul, octave_float_matrix,
                  octave_float_complex_matrix, el_mul);
-  INSTALL_BINOP (op_el_div, octave_float_matrix, 
+  INSTALL_BINOP (op_el_div, octave_float_matrix,
                  octave_float_complex_matrix, el_div);
-  INSTALL_BINOP (op_el_pow, octave_float_matrix, 
+  INSTALL_BINOP (op_el_pow, octave_float_matrix,
                  octave_float_complex_matrix, el_pow);
-  INSTALL_BINOP (op_el_ldiv, octave_float_matrix, 
+  INSTALL_BINOP (op_el_ldiv, octave_float_matrix,
                  octave_float_complex_matrix, el_ldiv);
-  INSTALL_BINOP (op_el_and, octave_float_matrix, 
+  INSTALL_BINOP (op_el_and, octave_float_matrix,
                  octave_float_complex_matrix, el_and);
-  INSTALL_BINOP (op_el_or, octave_float_matrix, 
+  INSTALL_BINOP (op_el_or, octave_float_matrix,
                  octave_float_complex_matrix, el_or);
-  INSTALL_BINOP (op_trans_mul, octave_float_matrix, 
+  INSTALL_BINOP (op_trans_mul, octave_float_matrix,
                  octave_float_complex_matrix, trans_mul);
-  INSTALL_BINOP (op_herm_mul, octave_float_matrix, 
+  INSTALL_BINOP (op_herm_mul, octave_float_matrix,
                  octave_float_complex_matrix, trans_mul);
-  INSTALL_BINOP (op_trans_ldiv, octave_float_matrix, 
+  INSTALL_BINOP (op_trans_ldiv, octave_float_matrix,
                  octave_float_complex_matrix, trans_ldiv);
-  INSTALL_BINOP (op_herm_ldiv, octave_float_matrix, 
+  INSTALL_BINOP (op_herm_ldiv, octave_float_matrix,
                  octave_float_complex_matrix, trans_ldiv);
 
   INSTALL_CATOP (octave_float_matrix, octave_float_complex_matrix, fm_fcm);
   INSTALL_CATOP (octave_matrix, octave_float_complex_matrix, m_fcm);
   INSTALL_CATOP (octave_float_matrix, octave_complex_matrix, fm_cm);
 
-  INSTALL_ASSIGNCONV (octave_float_matrix, octave_float_complex_matrix, 
+  INSTALL_ASSIGNCONV (octave_float_matrix, octave_float_complex_matrix,
                       octave_float_complex_matrix);
-  INSTALL_ASSIGNCONV (octave_matrix, octave_float_complex_matrix, 
+  INSTALL_ASSIGNCONV (octave_matrix, octave_float_complex_matrix,
                       octave_complex_matrix);
 
-  INSTALL_WIDENOP (octave_float_matrix, octave_float_complex_matrix, 
+  INSTALL_WIDENOP (octave_float_matrix, octave_float_complex_matrix,
                    float_complex_matrix_conv);
 }
diff --git a/src/OPERATORS/op-fm-fcs.cc b/src/OPERATORS/op-fm-fcs.cc
--- a/src/OPERATORS/op-fm-fcs.cc
+++ b/src/OPERATORS/op-fm-fcs.cc
@@ -72,66 +72,66 @@ DEFBINOP (ldiv, float_matrix, float_comp
   MatrixType typ = v1.matrix_type ();
 
   FloatComplexMatrix ret = xleftdiv (m1, m2, typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
-DEFNDCMPLXCMPOP_FN (lt, float_matrix, float_complex, float_array, 
+DEFNDCMPLXCMPOP_FN (lt, float_matrix, float_complex, float_array,
                float_complex, mx_el_lt)
-DEFNDCMPLXCMPOP_FN (le, float_matrix, float_complex, float_array, 
+DEFNDCMPLXCMPOP_FN (le, float_matrix, float_complex, float_array,
                float_complex, mx_el_le)
-DEFNDCMPLXCMPOP_FN (eq, float_matrix, float_complex, float_array, 
+DEFNDCMPLXCMPOP_FN (eq, float_matrix, float_complex, float_array,
                float_complex, mx_el_eq)
-DEFNDCMPLXCMPOP_FN (ge, float_matrix, float_complex, float_array, 
+DEFNDCMPLXCMPOP_FN (ge, float_matrix, float_complex, float_array,
                float_complex, mx_el_ge)
-DEFNDCMPLXCMPOP_FN (gt, float_matrix, float_complex, float_array, 
+DEFNDCMPLXCMPOP_FN (gt, float_matrix, float_complex, float_array,
                float_complex, mx_el_gt)
-DEFNDCMPLXCMPOP_FN (ne, float_matrix, float_complex, float_array, 
+DEFNDCMPLXCMPOP_FN (ne, float_matrix, float_complex, float_array,
                float_complex, mx_el_ne)
 
-DEFNDBINOP_OP (el_mul, float_matrix, float_complex, float_array, 
+DEFNDBINOP_OP (el_mul, float_matrix, float_complex, float_array,
                float_complex, *)
 
 DEFBINOP (el_div, float_matrix, float_complex)
 {
   CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_complex&);
 
   FloatComplex d = v2.float_complex_value ();
 
   if (d == static_cast<float>(0.0))
     gripe_divide_by_zero ();
 
   return octave_value (v1.float_array_value () / d);
 }
 
-DEFNDBINOP_FN (el_pow, float_matrix, float_complex, float_array, 
+DEFNDBINOP_FN (el_pow, float_matrix, float_complex, float_array,
                float_complex, elem_xpow)
 
 DEFBINOP (el_ldiv, float_matrix, flaot_complex)
 {
   CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_complex&);
 
   return x_el_div (v2.float_complex_value (), v1.float_array_value ());
 }
 
-DEFNDBINOP_FN (el_and, float_matrix, float_complex, float_array, 
+DEFNDBINOP_FN (el_and, float_matrix, float_complex, float_array,
                float_complex, mx_el_and)
-DEFNDBINOP_FN (el_or, float_matrix, float_complex, float_array, 
+DEFNDBINOP_FN (el_or, float_matrix, float_complex, float_array,
                float_complex, mx_el_or)
 
-DEFNDCATOP_FN (fm_fcs, float_matrix, float_complex, float_array, 
+DEFNDCATOP_FN (fm_fcs, float_matrix, float_complex, float_array,
                float_complex_array, concat)
 
-DEFNDCATOP_FN (m_fcs, matrix, float_complex, float_array, 
+DEFNDCATOP_FN (m_fcs, matrix, float_complex, float_array,
                float_complex_array, concat)
 
-DEFNDCATOP_FN (fm_cs, float_matrix, complex, float_array, 
+DEFNDCATOP_FN (fm_cs, float_matrix, complex, float_array,
                float_complex_array, concat)
 
 void
 install_fm_fcs_ops (void)
 {
   INSTALL_BINOP (op_add, octave_float_matrix, octave_float_complex, add);
   INSTALL_BINOP (op_sub, octave_float_matrix, octave_float_complex, sub);
   INSTALL_BINOP (op_mul, octave_float_matrix, octave_float_complex, mul);
@@ -150,13 +150,13 @@ install_fm_fcs_ops (void)
   INSTALL_BINOP (op_el_ldiv, octave_float_matrix, octave_float_complex, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_float_matrix, octave_float_complex, el_and);
   INSTALL_BINOP (op_el_or, octave_float_matrix, octave_float_complex, el_or);
 
   INSTALL_CATOP (octave_float_matrix, octave_float_complex, fm_fcs);
   INSTALL_CATOP (octave_matrix, octave_float_complex, m_fcs);
   INSTALL_CATOP (octave_float_matrix, octave_complex, fm_cs);
 
-  INSTALL_ASSIGNCONV (octave_float_matrix, octave_float_complex, 
+  INSTALL_ASSIGNCONV (octave_float_matrix, octave_float_complex,
                       octave_float_complex_matrix);
-  INSTALL_ASSIGNCONV (octave_matrix, octave_float_complex, 
+  INSTALL_ASSIGNCONV (octave_matrix, octave_float_complex,
                       octave_complex_matrix);
 }
diff --git a/src/OPERATORS/op-fm-fm.cc b/src/OPERATORS/op-fm-fm.cc
--- a/src/OPERATORS/op-fm-fm.cc
+++ b/src/OPERATORS/op-fm-fm.cc
@@ -64,114 +64,114 @@ DEFNDBINOP_OP (add, float_matrix, float_
 DEFNDBINOP_OP (sub, float_matrix, float_matrix, float_array, float_array, -)
 
 DEFBINOP_OP (mul, float_matrix, float_matrix, *)
 
 DEFBINOP (div, float_matrix, float_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_matrix&);
   MatrixType typ = v2.matrix_type ();
-  
-  FloatMatrix ret = xdiv (v1.float_matrix_value (), 
+
+  FloatMatrix ret = xdiv (v1.float_matrix_value (),
                           v2.float_matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, float_matrix, float_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, float_matrix, float_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_matrix&);
   MatrixType typ = v1.matrix_type ();
-  
-  FloatMatrix ret = xleftdiv (v1.float_matrix_value (), 
+
+  FloatMatrix ret = xleftdiv (v1.float_matrix_value (),
                               v2.float_matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP (trans_mul, float_matrix, float_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_matrix&);
-  return octave_value(xgemm (v1.float_matrix_value (), 
+  return octave_value(xgemm (v1.float_matrix_value (),
                              v2.float_matrix_value (),
                              blas_trans, blas_no_trans));
 }
 
 DEFBINOP (mul_trans, float_matrix, float_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_matrix&);
-  return octave_value(xgemm (v1.float_matrix_value (), 
+  return octave_value(xgemm (v1.float_matrix_value (),
                              v2.float_matrix_value (),
                              blas_no_trans, blas_trans));
 }
 
 DEFBINOP (trans_ldiv, float_matrix, float_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_matrix&);
   MatrixType typ = v1.matrix_type ();
-  
-  FloatMatrix ret = xleftdiv (v1.float_matrix_value (), 
+
+  FloatMatrix ret = xleftdiv (v1.float_matrix_value (),
                               v2.float_matrix_value (), typ, blas_trans);
 
   v1.matrix_type (typ);
   return ret;
 }
 
-DEFNDBINOP_FN (lt, float_matrix, float_matrix, float_array, 
+DEFNDBINOP_FN (lt, float_matrix, float_matrix, float_array,
                float_array, mx_el_lt)
-DEFNDBINOP_FN (le, float_matrix, float_matrix, float_array, 
+DEFNDBINOP_FN (le, float_matrix, float_matrix, float_array,
                float_array, mx_el_le)
-DEFNDBINOP_FN (eq, float_matrix, float_matrix, float_array, 
+DEFNDBINOP_FN (eq, float_matrix, float_matrix, float_array,
                float_array, mx_el_eq)
-DEFNDBINOP_FN (ge, float_matrix, float_matrix, float_array, 
+DEFNDBINOP_FN (ge, float_matrix, float_matrix, float_array,
                float_array, mx_el_ge)
-DEFNDBINOP_FN (gt, float_matrix, float_matrix, float_array, 
+DEFNDBINOP_FN (gt, float_matrix, float_matrix, float_array,
                float_array, mx_el_gt)
-DEFNDBINOP_FN (ne, float_matrix, float_matrix, float_array, 
+DEFNDBINOP_FN (ne, float_matrix, float_matrix, float_array,
                float_array, mx_el_ne)
 
-DEFNDBINOP_FN (el_mul, float_matrix, float_matrix, float_array, 
+DEFNDBINOP_FN (el_mul, float_matrix, float_matrix, float_array,
                float_array, product)
-DEFNDBINOP_FN (el_div, float_matrix, float_matrix, float_array, 
+DEFNDBINOP_FN (el_div, float_matrix, float_matrix, float_array,
                float_array, quotient)
-DEFNDBINOP_FN (el_pow, float_matrix, float_matrix, float_array, 
+DEFNDBINOP_FN (el_pow, float_matrix, float_matrix, float_array,
                float_array, elem_xpow)
 
 DEFBINOP (el_ldiv, float_matrix, float_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_matrix&);
 
-  return octave_value (quotient (v2.float_array_value (), 
+  return octave_value (quotient (v2.float_array_value (),
                                  v1.float_array_value ()));
 }
 
-DEFNDBINOP_FN (el_and, float_matrix, float_matrix, float_array, 
+DEFNDBINOP_FN (el_and, float_matrix, float_matrix, float_array,
                float_array, mx_el_and)
-DEFNDBINOP_FN (el_or,  float_matrix, float_matrix, float_array, 
+DEFNDBINOP_FN (el_or,  float_matrix, float_matrix, float_array,
                float_array, mx_el_or)
-DEFNDBINOP_FN (el_not_and, float_matrix, float_matrix, float_array, 
+DEFNDBINOP_FN (el_not_and, float_matrix, float_matrix, float_array,
                float_array, mx_el_not_and)
-DEFNDBINOP_FN (el_not_or,  float_matrix, float_matrix, float_array, 
+DEFNDBINOP_FN (el_not_or,  float_matrix, float_matrix, float_array,
                float_array, mx_el_not_or)
-DEFNDBINOP_FN (el_and_not, float_matrix, float_matrix, float_array, 
+DEFNDBINOP_FN (el_and_not, float_matrix, float_matrix, float_array,
                float_array, mx_el_and_not)
-DEFNDBINOP_FN (el_or_not,  float_matrix, float_matrix, float_array, 
+DEFNDBINOP_FN (el_or_not,  float_matrix, float_matrix, float_array,
                float_array, mx_el_or_not)
 
 
 
-DEFNDCATOP_FN (fm_fm, float_matrix, float_matrix, float_array, 
+DEFNDCATOP_FN (fm_fm, float_matrix, float_matrix, float_array,
                float_array, concat)
 
 DEFNDCATOP_FN (m_fm, matrix, float_matrix, float_array, float_array, concat)
 
 DEFNDCATOP_FN (fm_m, float_matrix, matrix, float_array, float_array, concat)
 
 DEFNDASSIGNOP_FN (assign, float_matrix, float_matrix, float_array, assign)
 
@@ -232,19 +232,19 @@ install_fm_fm_ops (void)
   INSTALL_BINOP (op_mul_herm, octave_float_matrix, octave_float_matrix, mul_trans);
   INSTALL_BINOP (op_trans_ldiv, octave_float_matrix, octave_float_matrix, trans_ldiv);
   INSTALL_BINOP (op_herm_ldiv, octave_float_matrix, octave_float_matrix, trans_ldiv);
 
   INSTALL_CATOP (octave_float_matrix, octave_float_matrix, fm_fm);
   INSTALL_CATOP (octave_matrix, octave_float_matrix, m_fm);
   INSTALL_CATOP (octave_float_matrix, octave_matrix, fm_m);
 
-  INSTALL_ASSIGNOP (op_asn_eq, octave_float_matrix, 
+  INSTALL_ASSIGNOP (op_asn_eq, octave_float_matrix,
                     octave_float_matrix, assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_matrix, 
+  INSTALL_ASSIGNOP (op_asn_eq, octave_matrix,
                     octave_float_matrix, dbl_assign);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_matrix, octave_null_matrix, null_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_matrix, octave_null_str, null_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_matrix, octave_null_sq_str, null_assign);
 
   INSTALL_ASSIGNOP (op_add_eq, octave_float_matrix, octave_float_matrix, assign_add);
   INSTALL_ASSIGNOP (op_sub_eq, octave_float_matrix, octave_float_matrix, assign_sub);
diff --git a/src/OPERATORS/op-fm-fs.cc b/src/OPERATORS/op-fm-fs.cc
--- a/src/OPERATORS/op-fm-fs.cc
+++ b/src/OPERATORS/op-fm-fs.cc
@@ -64,59 +64,59 @@ DEFBINOP (ldiv, float_matrix, float)
   MatrixType typ = v1.matrix_type ();
 
   FloatMatrix ret = xleftdiv (m1, m2, typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
-DEFNDBINOP_FN (lt, float_matrix, float_scalar, float_array, 
+DEFNDBINOP_FN (lt, float_matrix, float_scalar, float_array,
                float_scalar, mx_el_lt)
-DEFNDBINOP_FN (le, float_matrix, float_scalar, float_array, 
+DEFNDBINOP_FN (le, float_matrix, float_scalar, float_array,
                float_scalar, mx_el_le)
-DEFNDBINOP_FN (eq, float_matrix, float_scalar, float_array, 
+DEFNDBINOP_FN (eq, float_matrix, float_scalar, float_array,
                float_scalar, mx_el_eq)
-DEFNDBINOP_FN (ge, float_matrix, float_scalar, float_array, 
+DEFNDBINOP_FN (ge, float_matrix, float_scalar, float_array,
                float_scalar, mx_el_ge)
-DEFNDBINOP_FN (gt, float_matrix, float_scalar, float_array, 
+DEFNDBINOP_FN (gt, float_matrix, float_scalar, float_array,
                float_scalar, mx_el_gt)
-DEFNDBINOP_FN (ne, float_matrix, float_scalar, float_array, 
+DEFNDBINOP_FN (ne, float_matrix, float_scalar, float_array,
                float_scalar, mx_el_ne)
 
 DEFNDBINOP_OP (el_mul, float_matrix, float_scalar, float_array, float_scalar, *)
 
 DEFBINOP (el_div, float_matrix, float)
 {
   CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_scalar&);
 
   float d = v2.float_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v1.float_array_value () / d);
 }
 
-DEFNDBINOP_FN (el_pow, float_matrix, float_scalar, float_array, 
+DEFNDBINOP_FN (el_pow, float_matrix, float_scalar, float_array,
                float_scalar, elem_xpow)
 
 DEFBINOP (el_ldiv, float_matrix, float)
 {
   CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_scalar&);
 
   return x_el_div (v2.float_value (), v1.float_array_value ());
 }
 
-DEFNDBINOP_FN (el_and, float_matrix, float_scalar, float_array, 
+DEFNDBINOP_FN (el_and, float_matrix, float_scalar, float_array,
                float_scalar, mx_el_and)
-DEFNDBINOP_FN (el_or, float_matrix, float_scalar, float_array, 
+DEFNDBINOP_FN (el_or, float_matrix, float_scalar, float_array,
                float_scalar, mx_el_or)
 
-DEFNDCATOP_FN (fm_fs, float_matrix, float_scalar, float_array, 
+DEFNDCATOP_FN (fm_fs, float_matrix, float_scalar, float_array,
                float_array, concat)
 
 DEFNDCATOP_FN (m_fs, matrix, float_scalar, float_array, float_array, concat)
 
 DEFNDCATOP_FN (fm_s, float_matrix, scalar, float_array, float_array, concat)
 
 DEFNDASSIGNOP_FN (assign, float_matrix, float_scalar, float_scalar, assign)
 DEFNDASSIGNOP_FN (dbl_assign, matrix, float_scalar, scalar, assign)
diff --git a/src/OPERATORS/op-fs-fcm.cc b/src/OPERATORS/op-fs-fcm.cc
--- a/src/OPERATORS/op-fs-fcm.cc
+++ b/src/OPERATORS/op-fs-fcm.cc
@@ -39,98 +39,98 @@ along with Octave; see the file COPYING.
 #include "ov-flt-re-mat.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // scalar by complex matrix ops.
 
-DEFNDBINOP_OP (add, float_scalar, float_complex_matrix, float_scalar, 
+DEFNDBINOP_OP (add, float_scalar, float_complex_matrix, float_scalar,
                float_complex_array, +)
-DEFNDBINOP_OP (sub, float_scalar, float_complex_matrix, float_scalar, 
+DEFNDBINOP_OP (sub, float_scalar, float_complex_matrix, float_scalar,
                float_complex_array, -)
-DEFNDBINOP_OP (mul, float_scalar, float_complex_matrix, float_scalar, 
+DEFNDBINOP_OP (mul, float_scalar, float_complex_matrix, float_scalar,
                float_complex_array, *)
 
 DEFBINOP (div, float_scalar, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_scalar&, 
+  CAST_BINOP_ARGS (const octave_float_scalar&,
                    const octave_float_complex_matrix&);
 
   FloatMatrix m1 = v1.float_matrix_value ();
   FloatComplexMatrix m2 = v2.float_complex_matrix_value ();
   MatrixType typ = v2.matrix_type ();
 
   FloatComplexMatrix ret = xdiv (m1, m2, typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP_FN (pow, float_scalar, float_complex_matrix, xpow)
 
 DEFBINOP (ldiv, float_scalar, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_scalar&, 
+  CAST_BINOP_ARGS (const octave_float_scalar&,
                    const octave_float_complex_matrix&);
 
   float d = v1.float_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v2.float_complex_array_value () / d);
 }
 
-DEFNDCMPLXCMPOP_FN (lt, float_scalar, float_complex_matrix, float_scalar, 
+DEFNDCMPLXCMPOP_FN (lt, float_scalar, float_complex_matrix, float_scalar,
                float_complex_array, mx_el_lt)
-DEFNDCMPLXCMPOP_FN (le, float_scalar, float_complex_matrix, float_scalar, 
+DEFNDCMPLXCMPOP_FN (le, float_scalar, float_complex_matrix, float_scalar,
                float_complex_array, mx_el_le)
-DEFNDCMPLXCMPOP_FN (eq, float_scalar, float_complex_matrix, float_scalar, 
+DEFNDCMPLXCMPOP_FN (eq, float_scalar, float_complex_matrix, float_scalar,
                float_complex_array, mx_el_eq)
-DEFNDCMPLXCMPOP_FN (ge, float_scalar, float_complex_matrix, float_scalar, 
+DEFNDCMPLXCMPOP_FN (ge, float_scalar, float_complex_matrix, float_scalar,
                float_complex_array, mx_el_ge)
-DEFNDCMPLXCMPOP_FN (gt, float_scalar, float_complex_matrix, float_scalar, 
+DEFNDCMPLXCMPOP_FN (gt, float_scalar, float_complex_matrix, float_scalar,
                float_complex_array, mx_el_gt)
-DEFNDCMPLXCMPOP_FN (ne, float_scalar, float_complex_matrix, float_scalar, 
+DEFNDCMPLXCMPOP_FN (ne, float_scalar, float_complex_matrix, float_scalar,
                float_complex_array, mx_el_ne)
 
-DEFNDBINOP_OP (el_mul, float_scalar, float_complex_matrix, float_scalar, 
+DEFNDBINOP_OP (el_mul, float_scalar, float_complex_matrix, float_scalar,
                float_complex_array, *)
-DEFNDBINOP_FN (el_div, float_scalar, float_complex_matrix, float_scalar, 
+DEFNDBINOP_FN (el_div, float_scalar, float_complex_matrix, float_scalar,
                float_complex_array, x_el_div)
-DEFNDBINOP_FN (el_pow, float_scalar, float_complex_matrix, float_scalar, 
+DEFNDBINOP_FN (el_pow, float_scalar, float_complex_matrix, float_scalar,
                float_complex_array, elem_xpow)
 
 DEFBINOP (el_ldiv, float_scalar, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_scalar&, 
+  CAST_BINOP_ARGS (const octave_float_scalar&,
                    const octave_float_complex_matrix&);
 
   float d = v1.float_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v2.float_complex_array_value () / d);
 }
 
-DEFNDBINOP_FN (el_and, float_scalar, float_complex_matrix, float_scalar, 
+DEFNDBINOP_FN (el_and, float_scalar, float_complex_matrix, float_scalar,
                float_complex_array, mx_el_and)
-DEFNDBINOP_FN (el_or,  float_scalar, float_complex_matrix, float_scalar, 
+DEFNDBINOP_FN (el_or,  float_scalar, float_complex_matrix, float_scalar,
                float_complex_array, mx_el_or)
 
-DEFNDCATOP_FN (fs_fcm, float_scalar, float_complex_matrix, float_array, 
+DEFNDCATOP_FN (fs_fcm, float_scalar, float_complex_matrix, float_array,
                float_complex_array, concat)
 
-DEFNDCATOP_FN (s_fcm, scalar, float_complex_matrix, float_array, 
+DEFNDCATOP_FN (s_fcm, scalar, float_complex_matrix, float_array,
                float_complex_array, concat)
 
-DEFNDCATOP_FN (fs_cm, float_scalar, complex_matrix, float_array, 
+DEFNDCATOP_FN (fs_cm, float_scalar, complex_matrix, float_array,
                float_complex_array, concat)
 
 DEFCONV (float_complex_matrix_conv, float_scalar, float_complex_matrix)
 {
   CAST_CONV_ARG (const octave_float_scalar&);
 
   return new octave_float_complex_matrix (FloatComplexMatrix (v.float_matrix_value ()));
 }
@@ -138,41 +138,41 @@ DEFCONV (float_complex_matrix_conv, floa
 void
 install_fs_fcm_ops (void)
 {
   INSTALL_BINOP (op_add, octave_float_scalar, octave_float_complex_matrix, add);
   INSTALL_BINOP (op_sub, octave_float_scalar, octave_float_complex_matrix, sub);
   INSTALL_BINOP (op_mul, octave_float_scalar, octave_float_complex_matrix, mul);
   INSTALL_BINOP (op_div, octave_float_scalar, octave_float_complex_matrix, div);
   INSTALL_BINOP (op_pow, octave_float_scalar, octave_float_complex_matrix, pow);
-  INSTALL_BINOP (op_ldiv, octave_float_scalar, 
+  INSTALL_BINOP (op_ldiv, octave_float_scalar,
                  octave_float_complex_matrix, ldiv);
   INSTALL_BINOP (op_lt, octave_float_scalar, octave_float_complex_matrix, lt);
   INSTALL_BINOP (op_le, octave_float_scalar, octave_float_complex_matrix, le);
   INSTALL_BINOP (op_eq, octave_float_scalar, octave_float_complex_matrix, eq);
   INSTALL_BINOP (op_ge, octave_float_scalar, octave_float_complex_matrix, ge);
   INSTALL_BINOP (op_gt, octave_float_scalar, octave_float_complex_matrix, gt);
   INSTALL_BINOP (op_ne, octave_float_scalar, octave_float_complex_matrix, ne);
-  INSTALL_BINOP (op_el_mul, octave_float_scalar, 
+  INSTALL_BINOP (op_el_mul, octave_float_scalar,
                  octave_float_complex_matrix, el_mul);
-  INSTALL_BINOP (op_el_div, octave_float_scalar, 
+  INSTALL_BINOP (op_el_div, octave_float_scalar,
                  octave_float_complex_matrix, el_div);
-  INSTALL_BINOP (op_el_pow, octave_float_scalar, 
+  INSTALL_BINOP (op_el_pow, octave_float_scalar,
                  octave_float_complex_matrix, el_pow);
-  INSTALL_BINOP (op_el_ldiv, octave_float_scalar, 
+  INSTALL_BINOP (op_el_ldiv, octave_float_scalar,
                  octave_float_complex_matrix, el_ldiv);
-  INSTALL_BINOP (op_el_and, octave_float_scalar, 
+  INSTALL_BINOP (op_el_and, octave_float_scalar,
                  octave_float_complex_matrix, el_and);
-  INSTALL_BINOP (op_el_or, octave_float_scalar, 
+  INSTALL_BINOP (op_el_or, octave_float_scalar,
                  octave_float_complex_matrix, el_or);
 
   INSTALL_CATOP (octave_float_scalar, octave_float_complex_matrix, fs_fcm);
   INSTALL_CATOP (octave_scalar, octave_float_complex_matrix, s_fcm);
   INSTALL_CATOP (octave_float_scalar, octave_complex_matrix, fs_cm);
 
-  INSTALL_ASSIGNCONV (octave_float_scalar, octave_float_complex_matrix, 
+  INSTALL_ASSIGNCONV (octave_float_scalar, octave_float_complex_matrix,
                       octave_float_complex_matrix);
-  INSTALL_ASSIGNCONV (octave_scalar, octave_float_complex_matrix, 
+  INSTALL_ASSIGNCONV (octave_scalar, octave_float_complex_matrix,
                       octave_complex_matrix);
 
-  INSTALL_WIDENOP (octave_float_scalar, octave_float_complex_matrix, 
+  INSTALL_WIDENOP (octave_float_scalar, octave_float_complex_matrix,
                    float_complex_matrix_conv);
 }
diff --git a/src/OPERATORS/op-fs-fcs.cc b/src/OPERATORS/op-fs-fcs.cc
--- a/src/OPERATORS/op-fs-fcs.cc
+++ b/src/OPERATORS/op-fs-fcs.cc
@@ -114,23 +114,23 @@ DEFBINOP (el_and, float_scalar, float_co
 
 DEFBINOP (el_or, float_scalar, float_complex)
 {
   CAST_BINOP_ARGS (const octave_float_scalar&, const octave_float_complex&);
 
   return octave_value (v1.float_scalar_value () || (v2.float_complex_value () != static_cast<float>(0.0)));
 }
 
-DEFNDCATOP_FN (fs_fcs, float_scalar, float_complex, float_array, 
+DEFNDCATOP_FN (fs_fcs, float_scalar, float_complex, float_array,
                float_complex_array, concat)
 
-DEFNDCATOP_FN (s_fcs, scalar, float_complex, float_array, 
+DEFNDCATOP_FN (s_fcs, scalar, float_complex, float_array,
                float_complex_array, concat)
 
-DEFNDCATOP_FN (fs_cs, float_scalar, complex, float_array, 
+DEFNDCATOP_FN (fs_cs, float_scalar, complex, float_array,
                float_complex_array, concat)
 
 void
 install_fs_fcs_ops (void)
 {
   INSTALL_BINOP (op_add, octave_float_scalar, octave_float_complex, add);
   INSTALL_BINOP (op_sub, octave_float_scalar, octave_float_complex, sub);
   INSTALL_BINOP (op_mul, octave_float_scalar, octave_float_complex, mul);
@@ -149,13 +149,13 @@ install_fs_fcs_ops (void)
   INSTALL_BINOP (op_el_ldiv, octave_float_scalar, octave_float_complex, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_float_scalar, octave_float_complex, el_and);
   INSTALL_BINOP (op_el_or, octave_float_scalar, octave_float_complex, el_or);
 
   INSTALL_CATOP (octave_float_scalar, octave_float_complex, fs_fcs);
   INSTALL_CATOP (octave_scalar, octave_float_complex, s_fcs);
   INSTALL_CATOP (octave_float_scalar, octave_complex, fs_cs);
 
-  INSTALL_ASSIGNCONV (octave_float_scalar, octave_float_complex, 
+  INSTALL_ASSIGNCONV (octave_float_scalar, octave_float_complex,
                       octave_float_complex_matrix);
-  INSTALL_ASSIGNCONV (octave_scalar, octave_float_complex, 
+  INSTALL_ASSIGNCONV (octave_scalar, octave_float_complex,
                       octave_complex_matrix);
 }
diff --git a/src/OPERATORS/op-fs-fm.cc b/src/OPERATORS/op-fs-fm.cc
--- a/src/OPERATORS/op-fs-fm.cc
+++ b/src/OPERATORS/op-fs-fm.cc
@@ -65,54 +65,54 @@ DEFBINOP (ldiv, float_scalar, float_matr
   float d = v1.float_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v2.float_array_value () / d);
 }
 
-DEFNDBINOP_FN (lt, float_scalar, float_matrix, float_scalar, 
+DEFNDBINOP_FN (lt, float_scalar, float_matrix, float_scalar,
                float_array, mx_el_lt)
-DEFNDBINOP_FN (le, float_scalar, float_matrix, float_scalar, 
+DEFNDBINOP_FN (le, float_scalar, float_matrix, float_scalar,
                float_array, mx_el_le)
-DEFNDBINOP_FN (eq, float_scalar, float_matrix, float_scalar, 
+DEFNDBINOP_FN (eq, float_scalar, float_matrix, float_scalar,
                float_array, mx_el_eq)
-DEFNDBINOP_FN (ge, float_scalar, float_matrix, float_scalar, 
+DEFNDBINOP_FN (ge, float_scalar, float_matrix, float_scalar,
                float_array, mx_el_ge)
-DEFNDBINOP_FN (gt, float_scalar, float_matrix, float_scalar, 
+DEFNDBINOP_FN (gt, float_scalar, float_matrix, float_scalar,
 float_array, mx_el_gt)
-DEFNDBINOP_FN (ne, float_scalar, float_matrix, float_scalar, 
+DEFNDBINOP_FN (ne, float_scalar, float_matrix, float_scalar,
                float_array, mx_el_ne)
 
-DEFNDBINOP_OP (el_mul, float_scalar, float_matrix, float_scalar, 
+DEFNDBINOP_OP (el_mul, float_scalar, float_matrix, float_scalar,
                float_array, *)
-DEFNDBINOP_FN (el_div, float_scalar, float_matrix, float_scalar, 
+DEFNDBINOP_FN (el_div, float_scalar, float_matrix, float_scalar,
                float_array, x_el_div)
-DEFNDBINOP_FN (el_pow, float_scalar, float_matrix, float_scalar, 
+DEFNDBINOP_FN (el_pow, float_scalar, float_matrix, float_scalar,
                float_array, elem_xpow)
 
 DEFBINOP (el_ldiv, float_scalar, float_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_scalar&, const octave_float_matrix&);
 
   float d = v1.float_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v2.float_array_value () / d);
 }
 
-DEFNDBINOP_FN (el_and, float_scalar, float_matrix, float_scalar, 
+DEFNDBINOP_FN (el_and, float_scalar, float_matrix, float_scalar,
                float_array, mx_el_and)
-DEFNDBINOP_FN (el_or,  float_scalar, float_matrix, float_scalar, 
+DEFNDBINOP_FN (el_or,  float_scalar, float_matrix, float_scalar,
                float_array, mx_el_or)
 
-DEFNDCATOP_FN (fs_fm, float_scalar, float_matrix, float_array, 
+DEFNDCATOP_FN (fs_fm, float_scalar, float_matrix, float_array,
                float_array, concat)
 
 DEFNDCATOP_FN (s_fm, scalar, float_matrix, float_array, float_array, concat)
 
 DEFNDCATOP_FN (fs_m, float_scalar, matrix, float_array, float_array, concat)
 
 DEFCONV (matrix_conv, float_scalar, float_matrix)
 {
diff --git a/src/OPERATORS/op-int-concat.cc b/src/OPERATORS/op-int-concat.cc
--- a/src/OPERATORS/op-int-concat.cc
+++ b/src/OPERATORS/op-int-concat.cc
@@ -130,17 +130,17 @@ OCTAVE_INT_DOUBLE_CONCAT_FN (uint8)
 OCTAVE_INT_DOUBLE_CONCAT_FN (uint16)
 OCTAVE_INT_DOUBLE_CONCAT_FN (uint32)
 OCTAVE_INT_DOUBLE_CONCAT_FN (uint64)
 
 OCTAVE_DOUBLE_INT_CONCAT_FN (int8)
 OCTAVE_DOUBLE_INT_CONCAT_FN (int16)
 OCTAVE_DOUBLE_INT_CONCAT_FN (int32)
 OCTAVE_DOUBLE_INT_CONCAT_FN (int64)
-                   
+
 OCTAVE_DOUBLE_INT_CONCAT_FN (uint8)
 OCTAVE_DOUBLE_INT_CONCAT_FN (uint16)
 OCTAVE_DOUBLE_INT_CONCAT_FN (uint32)
 OCTAVE_DOUBLE_INT_CONCAT_FN (uint64)
 
 OCTAVE_INT_FLOAT_CONCAT_FN (int8)
 OCTAVE_INT_FLOAT_CONCAT_FN (int16)
 OCTAVE_INT_FLOAT_CONCAT_FN (int32)
@@ -150,17 +150,17 @@ OCTAVE_INT_FLOAT_CONCAT_FN (uint8)
 OCTAVE_INT_FLOAT_CONCAT_FN (uint16)
 OCTAVE_INT_FLOAT_CONCAT_FN (uint32)
 OCTAVE_INT_FLOAT_CONCAT_FN (uint64)
 
 OCTAVE_FLOAT_INT_CONCAT_FN (int8)
 OCTAVE_FLOAT_INT_CONCAT_FN (int16)
 OCTAVE_FLOAT_INT_CONCAT_FN (int32)
 OCTAVE_FLOAT_INT_CONCAT_FN (int64)
-                   
+
 OCTAVE_FLOAT_INT_CONCAT_FN (uint8)
 OCTAVE_FLOAT_INT_CONCAT_FN (uint16)
 OCTAVE_FLOAT_INT_CONCAT_FN (uint32)
 OCTAVE_FLOAT_INT_CONCAT_FN (uint64)
 
 OCTAVE_INT_CHAR_CONCAT_FN (int8)
 OCTAVE_INT_CHAR_CONCAT_FN (int16)
 OCTAVE_INT_CHAR_CONCAT_FN (int32)
@@ -170,17 +170,17 @@ OCTAVE_INT_CHAR_CONCAT_FN (uint8)
 OCTAVE_INT_CHAR_CONCAT_FN (uint16)
 OCTAVE_INT_CHAR_CONCAT_FN (uint32)
 OCTAVE_INT_CHAR_CONCAT_FN (uint64)
 
 OCTAVE_CHAR_INT_CONCAT_FN (int8)
 OCTAVE_CHAR_INT_CONCAT_FN (int16)
 OCTAVE_CHAR_INT_CONCAT_FN (int32)
 OCTAVE_CHAR_INT_CONCAT_FN (int64)
-                   
+
 OCTAVE_CHAR_INT_CONCAT_FN (uint8)
 OCTAVE_CHAR_INT_CONCAT_FN (uint16)
 OCTAVE_CHAR_INT_CONCAT_FN (uint32)
 OCTAVE_CHAR_INT_CONCAT_FN (uint64)
 
 void
 install_int_concat_ops (void)
 {
diff --git a/src/OPERATORS/op-m-cm.cc b/src/OPERATORS/op-m-cm.cc
--- a/src/OPERATORS/op-m-cm.cc
+++ b/src/OPERATORS/op-m-cm.cc
@@ -58,48 +58,48 @@ DEFBINOP (trans_mul, matrix, complex_mat
   return ComplexMatrix (xgemm (m1, real (m2), blas_trans, blas_no_trans),
                         xgemm (m1, imag (m2), blas_trans, blas_no_trans));
 }
 
 DEFBINOP (div, matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
   MatrixType typ = v2.matrix_type ();
-  
-  ComplexMatrix ret = xdiv (v1.matrix_value (), 
+
+  ComplexMatrix ret = xdiv (v1.matrix_value (),
                             v2.complex_matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, matrix, complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
   MatrixType typ = v1.matrix_type ();
-  
-  ComplexMatrix ret = xleftdiv (v1.matrix_value (), 
+
+  ComplexMatrix ret = xleftdiv (v1.matrix_value (),
                                 v2.complex_matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP (trans_ldiv, matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
   MatrixType typ = v1.matrix_type ();
-  
-  ComplexMatrix ret = xleftdiv (v1.matrix_value (), 
+
+  ComplexMatrix ret = xleftdiv (v1.matrix_value (),
                          v2.complex_matrix_value (), typ, blas_trans);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFNDCMPLXCMPOP_FN (lt, matrix, complex_matrix, array, complex_array, mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, matrix, complex_matrix, array, complex_array, mx_el_le)
diff --git a/src/OPERATORS/op-m-m.cc b/src/OPERATORS/op-m-m.cc
--- a/src/OPERATORS/op-m-m.cc
+++ b/src/OPERATORS/op-m-m.cc
@@ -64,34 +64,34 @@ DEFNDBINOP_OP (add, matrix, matrix, arra
 DEFNDBINOP_OP (sub, matrix, matrix, array, array, -)
 
 DEFBINOP_OP (mul, matrix, matrix, *)
 
 DEFBINOP (div, matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
   MatrixType typ = v2.matrix_type ();
-  
+
   Matrix ret = xdiv (v1.matrix_value (), v2.matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, matrix, matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
   MatrixType typ = v1.matrix_type ();
-  
+
   Matrix ret = xleftdiv (v1.matrix_value (), v2.matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP (trans_mul, matrix, matrix)
 {
@@ -106,17 +106,17 @@ DEFBINOP (mul_trans, matrix, matrix)
   return octave_value(xgemm (v1.matrix_value (), v2.matrix_value (),
                              blas_no_trans, blas_trans));
 }
 
 DEFBINOP (trans_ldiv, matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
   MatrixType typ = v1.matrix_type ();
-  
+
   Matrix ret = xleftdiv (v1.matrix_value (), v2.matrix_value (), typ, blas_trans);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFNDBINOP_FN (lt, matrix, matrix, array, array, mx_el_lt)
 DEFNDBINOP_FN (le, matrix, matrix, array, array, mx_el_le)
diff --git a/src/OPERATORS/op-m-scm.cc b/src/OPERATORS/op-m-scm.cc
--- a/src/OPERATORS/op-m-scm.cc
+++ b/src/OPERATORS/op-m-scm.cc
@@ -59,37 +59,37 @@ DEFBINOP (div, matrix, sparse_complex_ma
         gripe_divide_by_zero ();
 
       return octave_value (v1.array_value () / d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
 
-      ComplexMatrix ret = xdiv (v1.matrix_value (), 
+      ComplexMatrix ret = xdiv (v1.matrix_value (),
                                 v2.sparse_complex_matrix_value (), typ);
 
       v2.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOPX (pow, matrix, sparse_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_matrix&, 
+  CAST_BINOP_ARGS (const octave_matrix&,
                    const octave_sparse_complex_matrix&);
   MatrixType typ = v1.matrix_type ();
-  
-  ComplexMatrix ret = xleftdiv (v1.matrix_value (), 
+
+  ComplexMatrix ret = xleftdiv (v1.matrix_value (),
                                 v2.complex_matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP_FN (lt, matrix, sparse_complex_matrix, mx_el_lt)
 DEFBINOP_FN (le, matrix, sparse_complex_matrix, mx_el_le)
@@ -98,47 +98,47 @@ DEFBINOP_FN (ge, matrix, sparse_complex_
 DEFBINOP_FN (gt, matrix, sparse_complex_matrix, mx_el_gt)
 DEFBINOP_FN (ne, matrix, sparse_complex_matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, matrix, sparse_complex_matrix, product)
 DEFBINOP_FN (el_div, matrix, sparse_complex_matrix, quotient)
 
 DEFBINOP (el_pow, matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_matrix&, 
+  CAST_BINOP_ARGS (const octave_matrix&,
                    const octave_sparse_complex_matrix&);
-  
-  return octave_value 
+
+  return octave_value
     (elem_xpow (SparseMatrix (v1.matrix_value ()),
                 v2.sparse_complex_matrix_value ()));
 }
 
 DEFBINOP (el_ldiv, matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_matrix&, 
+  CAST_BINOP_ARGS (const octave_matrix&,
                    const octave_sparse_complex_matrix&);
-  return octave_value 
+  return octave_value
     (quotient (v2.sparse_complex_matrix_value (), v1.matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, matrix, sparse_complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  matrix, sparse_complex_matrix, mx_el_or)
 
 DEFCATOP (m_scm, matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (octave_matrix&, const octave_sparse_complex_matrix&);
   SparseMatrix tmp (v1.matrix_value ());
-  return octave_value (tmp. concat (v2.sparse_complex_matrix_value (), 
+  return octave_value (tmp. concat (v2.sparse_complex_matrix_value (),
                                     ra_idx));
 }
 
 DEFCONV (sparse_complex_matrix_conv, matrix, sparse_complex_matrix)
 {
   CAST_CONV_ARG (const octave_matrix&);
-  return new octave_sparse_complex_matrix 
+  return new octave_sparse_complex_matrix
     (SparseComplexMatrix (v.complex_matrix_value ()));
 }
 
 void
 install_m_scm_ops (void)
 {
   INSTALL_BINOP (op_add, octave_matrix, octave_sparse_complex_matrix, add);
   INSTALL_BINOP (op_sub, octave_matrix, octave_sparse_complex_matrix, sub);
@@ -147,29 +147,29 @@ install_m_scm_ops (void)
   INSTALL_BINOP (op_pow, octave_matrix, octave_sparse_complex_matrix, pow);
   INSTALL_BINOP (op_ldiv, octave_matrix, octave_sparse_complex_matrix, ldiv);
   INSTALL_BINOP (op_lt, octave_matrix, octave_sparse_complex_matrix, lt);
   INSTALL_BINOP (op_le, octave_matrix, octave_sparse_complex_matrix, le);
   INSTALL_BINOP (op_eq, octave_matrix, octave_sparse_complex_matrix, eq);
   INSTALL_BINOP (op_ge, octave_matrix, octave_sparse_complex_matrix, ge);
   INSTALL_BINOP (op_gt, octave_matrix, octave_sparse_complex_matrix, gt);
   INSTALL_BINOP (op_ne, octave_matrix, octave_sparse_complex_matrix, ne);
-  INSTALL_BINOP (op_el_mul, octave_matrix, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_el_mul, octave_matrix, octave_sparse_complex_matrix,
                  el_mul);
-  INSTALL_BINOP (op_el_div, octave_matrix, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_el_div, octave_matrix, octave_sparse_complex_matrix,
                  el_div);
-  INSTALL_BINOP (op_el_pow, octave_matrix, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_el_pow, octave_matrix, octave_sparse_complex_matrix,
                  el_pow);
-  INSTALL_BINOP (op_el_ldiv, octave_matrix, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_el_ldiv, octave_matrix, octave_sparse_complex_matrix,
                  el_ldiv);
-  INSTALL_BINOP (op_el_and, octave_matrix, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_el_and, octave_matrix, octave_sparse_complex_matrix,
                  el_and);
-  INSTALL_BINOP (op_el_or, octave_matrix, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_el_or, octave_matrix, octave_sparse_complex_matrix,
                  el_or);
 
   INSTALL_CATOP (octave_matrix, octave_sparse_complex_matrix, m_scm);
 
-  INSTALL_ASSIGNCONV (octave_matrix, octave_sparse_complex_matrix, 
+  INSTALL_ASSIGNCONV (octave_matrix, octave_sparse_complex_matrix,
                       octave_complex_matrix);
 
-  INSTALL_WIDENOP (octave_matrix, octave_sparse_complex_matrix, 
+  INSTALL_WIDENOP (octave_matrix, octave_sparse_complex_matrix,
                    sparse_complex_matrix_conv);
 }
diff --git a/src/OPERATORS/op-m-sm.cc b/src/OPERATORS/op-m-sm.cc
--- a/src/OPERATORS/op-m-sm.cc
+++ b/src/OPERATORS/op-m-sm.cc
@@ -75,17 +75,17 @@ DEFBINOPX (pow, matrix, sparse_matrix)
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_sparse_matrix&);
   MatrixType typ = v1.matrix_type ();
-  
+
   Matrix ret = xleftdiv (v1.matrix_value (), v2.matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP_FN (mul_trans, matrix, sparse_matrix, mul_trans);
 
@@ -97,26 +97,26 @@ DEFBINOP_FN (gt, matrix, sparse_matrix, 
 DEFBINOP_FN (ne, matrix, sparse_matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, matrix, sparse_matrix, product)
 DEFBINOP_FN (el_div, matrix, sparse_matrix, quotient)
 
 DEFBINOP (el_pow, matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_sparse_matrix&);
-  
-  return octave_value (elem_xpow (SparseMatrix (v1.matrix_value ()), 
+
+  return octave_value (elem_xpow (SparseMatrix (v1.matrix_value ()),
                                   v2.sparse_matrix_value ()));
 }
 
 DEFBINOP (el_ldiv, matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_sparse_matrix&);
-  
-  return octave_value 
+
+  return octave_value
     (quotient (v2.sparse_matrix_value (), v1.matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, matrix, sparse_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  matrix, sparse_matrix, mx_el_or)
 
 DEFCATOP (m_sm, matrix, sparse_matrix)
 {
@@ -157,11 +157,11 @@ install_m_sm_ops (void)
   INSTALL_BINOP (op_el_and, octave_matrix, octave_sparse_matrix, el_and);
   INSTALL_BINOP (op_el_or, octave_matrix, octave_sparse_matrix,  el_or);
 
   INSTALL_CATOP (octave_matrix, octave_sparse_matrix, m_sm);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_matrix, octave_sparse_matrix, assign)
   INSTALL_ASSIGNCONV (octave_matrix, octave_sparse_matrix, octave_matrix)
 
-  INSTALL_WIDENOP (octave_matrix, octave_sparse_matrix, 
+  INSTALL_WIDENOP (octave_matrix, octave_sparse_matrix,
                    sparse_matrix_conv);
 }
diff --git a/src/OPERATORS/op-pm-pm.cc b/src/OPERATORS/op-pm-pm.cc
--- a/src/OPERATORS/op-pm-pm.cc
+++ b/src/OPERATORS/op-pm-pm.cc
@@ -40,24 +40,24 @@ DEFUNOP (transpose, perm_matrix)
   return octave_value (v.perm_matrix_value().transpose ());
 }
 
 DEFBINOP_OP (mul, perm_matrix, perm_matrix, *)
 
 DEFBINOP (div, perm_matrix, perm_matrix)
 {
   CAST_BINOP_ARGS (const octave_perm_matrix&, const octave_perm_matrix&);
-  
+
   return (v1.perm_matrix_value () * v2.perm_matrix_value ().inverse ());
 }
 
 DEFBINOP (ldiv, perm_matrix, perm_matrix)
 {
   CAST_BINOP_ARGS (const octave_perm_matrix&, const octave_perm_matrix&);
-  
+
   return (v1.perm_matrix_value ().inverse () * v2.perm_matrix_value ());
 }
 
 DEFBINOP (pow, perm_matrix, scalar)
 {
   CAST_BINOP_ARGS (const octave_perm_matrix&, const octave_scalar&);
 
   return xpow (v1.perm_matrix_value (), v2.scalar_value ());
diff --git a/src/OPERATORS/op-pm-scm.cc b/src/OPERATORS/op-pm-scm.cc
--- a/src/OPERATORS/op-pm-scm.cc
+++ b/src/OPERATORS/op-pm-scm.cc
@@ -50,17 +50,17 @@ DEFBINOP (mul_pm_scm, perm_matrix, spars
   else
     return v1.perm_matrix_value  () * v2.sparse_complex_matrix_value ();
 }
 
 DEFBINOP (ldiv_pm_scm, perm_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_perm_matrix&, const octave_sparse_complex_matrix&);
 
-  return v1.perm_matrix_value ().inverse () * v2.sparse_complex_matrix_value (); 
+  return v1.perm_matrix_value ().inverse () * v2.sparse_complex_matrix_value ();
 }
 
 // sparse matrix by diagonal matrix ops
 
 DEFBINOP (mul_scm_pm, sparse_complex_matrix, perm_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_perm_matrix&);
 
diff --git a/src/OPERATORS/op-pm-sm.cc b/src/OPERATORS/op-pm-sm.cc
--- a/src/OPERATORS/op-pm-sm.cc
+++ b/src/OPERATORS/op-pm-sm.cc
@@ -50,17 +50,17 @@ DEFBINOP (mul_pm_sm, perm_matrix, sparse
   else
     return v1.perm_matrix_value  () * v2.sparse_matrix_value ();
 }
 
 DEFBINOP (ldiv_pm_sm, perm_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_perm_matrix&, const octave_sparse_matrix&);
 
-  return v1.perm_matrix_value ().inverse () * v2.sparse_matrix_value (); 
+  return v1.perm_matrix_value ().inverse () * v2.sparse_matrix_value ();
 }
 
 // sparse matrix by diagonal matrix ops
 
 DEFBINOP (mul_sm_pm, sparse_matrix, perm_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_perm_matrix&);
 
diff --git a/src/OPERATORS/op-pm-template.cc b/src/OPERATORS/op-pm-template.cc
--- a/src/OPERATORS/op-pm-template.cc
+++ b/src/OPERATORS/op-pm-template.cc
@@ -53,17 +53,17 @@ DEFBINOP (mul, LMATRIX, RMATRIX)
   return v1.LMATRIX_VALUE () * v2.RMATRIX_VALUE ();
 }
 
 #ifdef LEFT
 DEFBINOP (ldiv, LMATRIX, RMATRIX)
 {
   CAST_BINOP_ARGS (const OCTAVE_LMATRIX&, const OCTAVE_RMATRIX&);
 
-  return v1.perm_matrix_value ().inverse () * v2.RMATRIX_VALUE (); 
+  return v1.perm_matrix_value ().inverse () * v2.RMATRIX_VALUE ();
 }
 #else
 DEFBINOP (div, LMATRIX, RMATRIX)
 {
   CAST_BINOP_ARGS (const OCTAVE_LMATRIX&, const OCTAVE_RMATRIX&);
 
   return v1.LMATRIX_VALUE () * v2.perm_matrix_value ().inverse ();
 }
diff --git a/src/OPERATORS/op-range.cc b/src/OPERATORS/op-range.cc
--- a/src/OPERATORS/op-range.cc
+++ b/src/OPERATORS/op-range.cc
@@ -126,17 +126,17 @@ install_range_ops (void)
   INSTALL_CATOP (octave_complex_matrix, octave_range, cm_r);
   INSTALL_CATOP (octave_bool, octave_range, b_r);
   INSTALL_CATOP (octave_bool_matrix, octave_range, bm_r);
   INSTALL_CATOP (octave_char_matrix, octave_range, chm_r);
 
   // FIXME -- this would be unneccessary if
   // octave_base_value::numeric_assign always tried converting lhs
   // before rhs.
-  
+
   INSTALL_ASSIGNCONV (octave_range, octave_null_matrix, octave_matrix);
   INSTALL_ASSIGNCONV (octave_range, octave_null_str, octave_matrix);
   INSTALL_ASSIGNCONV (octave_range, octave_null_sq_str, octave_matrix);
 
   // However, this should probably be here just in case we need it.
-  
+
   INSTALL_WIDENOP (octave_range, octave_matrix, range_to_matrix);
 }
diff --git a/src/OPERATORS/op-s-scm.cc b/src/OPERATORS/op-s-scm.cc
--- a/src/OPERATORS/op-s-scm.cc
+++ b/src/OPERATORS/op-s-scm.cc
@@ -68,24 +68,24 @@ DEFBINOP (div, scalar, sparse_complex_ma
       ComplexMatrix ret = xdiv (m1, m2, typ);
       v2.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOP (pow, scalar, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_scalar&, 
+  CAST_BINOP_ARGS (const octave_scalar&,
                    const octave_sparse_complex_matrix&);
   return xpow (v1.scalar_value (), v2.complex_matrix_value ());
 }
 
 DEFBINOP (ldiv, scalar, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_scalar&, 
+  CAST_BINOP_ARGS (const octave_scalar&,
                    const octave_sparse_complex_matrix&);
 
   double d = v1.double_value ();
   octave_value retval;
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
@@ -102,17 +102,17 @@ DEFBINOP_FN (gt, scalar, sparse_complex_
 DEFBINOP_FN (ne, scalar, sparse_complex_matrix, mx_el_ne)
 
 DEFBINOP_OP (el_mul, scalar, sparse_complex_matrix, *)
 DEFBINOP_FN (el_div, scalar, sparse_complex_matrix, x_el_div)
 DEFBINOP_FN (el_pow, scalar, sparse_complex_matrix, elem_xpow)
 
 DEFBINOP (el_ldiv, scalar, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_scalar&, 
+  CAST_BINOP_ARGS (const octave_scalar&,
                    const octave_sparse_complex_matrix&);
 
   double d = v1.double_value ();
   octave_value retval;
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
@@ -131,17 +131,17 @@ DEFCATOP (s_scm, scalar, sparse_compelx_
   return octave_value
     (tmp.concat (v2.sparse_complex_matrix_value (), ra_idx));
 }
 
 DEFCONV (sparse_complex_matrix_conv, scalar, sparse_complex_matrix)
 {
   CAST_CONV_ARG (const octave_scalar&);
 
-  return new octave_sparse_complex_matrix 
+  return new octave_sparse_complex_matrix
     (SparseComplexMatrix (v.complex_matrix_value ()));
 }
 
 void
 install_s_scm_ops (void)
 {
   INSTALL_BINOP (op_add, octave_scalar, octave_sparse_complex_matrix, add);
   INSTALL_BINOP (op_sub, octave_scalar, octave_sparse_complex_matrix, sub);
@@ -150,29 +150,29 @@ install_s_scm_ops (void)
   INSTALL_BINOP (op_pow, octave_scalar, octave_sparse_complex_matrix, pow);
   INSTALL_BINOP (op_ldiv, octave_scalar, octave_sparse_complex_matrix, ldiv);
   INSTALL_BINOP (op_lt, octave_scalar, octave_sparse_complex_matrix, lt);
   INSTALL_BINOP (op_le, octave_scalar, octave_sparse_complex_matrix, le);
   INSTALL_BINOP (op_eq, octave_scalar, octave_sparse_complex_matrix, eq);
   INSTALL_BINOP (op_ge, octave_scalar, octave_sparse_complex_matrix, ge);
   INSTALL_BINOP (op_gt, octave_scalar, octave_sparse_complex_matrix, gt);
   INSTALL_BINOP (op_ne, octave_scalar, octave_sparse_complex_matrix, ne);
-  INSTALL_BINOP (op_el_mul, octave_scalar, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_el_mul, octave_scalar, octave_sparse_complex_matrix,
                  el_mul);
-  INSTALL_BINOP (op_el_div, octave_scalar, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_el_div, octave_scalar, octave_sparse_complex_matrix,
                  el_div);
-  INSTALL_BINOP (op_el_pow, octave_scalar, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_el_pow, octave_scalar, octave_sparse_complex_matrix,
                  el_pow);
-  INSTALL_BINOP (op_el_ldiv, octave_scalar, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_el_ldiv, octave_scalar, octave_sparse_complex_matrix,
                  el_ldiv);
-  INSTALL_BINOP (op_el_and, octave_scalar, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_el_and, octave_scalar, octave_sparse_complex_matrix,
                  el_and);
-  INSTALL_BINOP (op_el_or, octave_scalar, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_el_or, octave_scalar, octave_sparse_complex_matrix,
                  el_or);
 
   INSTALL_CATOP (octave_scalar, octave_sparse_complex_matrix, s_scm);
 
-  INSTALL_ASSIGNCONV (octave_scalar, octave_sparse_complex_matrix, 
+  INSTALL_ASSIGNCONV (octave_scalar, octave_sparse_complex_matrix,
                       octave_complex_matrix);
 
-  INSTALL_WIDENOP (octave_scalar, octave_sparse_complex_matrix, 
+  INSTALL_WIDENOP (octave_scalar, octave_sparse_complex_matrix,
                    sparse_complex_matrix_conv);
 }
diff --git a/src/OPERATORS/op-sbm-b.cc b/src/OPERATORS/op-sbm-b.cc
--- a/src/OPERATORS/op-sbm-b.cc
+++ b/src/OPERATORS/op-sbm-b.cc
@@ -41,34 +41,34 @@ along with Octave; see the file COPYING.
 DEFBINOP_FN (ne, sparse_bool_matrix, bool, mx_el_ne)
 DEFBINOP_FN (eq, sparse_bool_matrix, bool, mx_el_eq)
 
 DEFBINOP_FN (el_and, sparse_bool_matrix, bool, mx_el_and)
 DEFBINOP_FN (el_or, sparse_bool_matrix, bool, mx_el_or)
 
 DEFCATOP (sbm_b, sparse_bool_matrix, bool)
 {
-  CAST_BINOP_ARGS (octave_sparse_bool_matrix&, const octave_bool&); 
-                   
+  CAST_BINOP_ARGS (octave_sparse_bool_matrix&, const octave_bool&);
+
   SparseBoolMatrix tmp (1, 1, v2.bool_value ());
   return octave_value (v1.sparse_bool_matrix_value (). concat (tmp, ra_idx));
 }
 
 DEFCATOP (sm_b, sparse_matrix, bool)
 {
   CAST_BINOP_ARGS (octave_sparse_matrix&, const octave_bool&);
-                   
+
   SparseMatrix tmp (1, 1, v2.scalar_value ());
   return octave_value (v1.sparse_matrix_value (). concat (tmp, ra_idx));
 }
 
 DEFCATOP (sbm_s, sparse_bool_matrix, scalar)
 {
-  CAST_BINOP_ARGS (octave_sparse_bool_matrix&, const octave_scalar&); 
-                   
+  CAST_BINOP_ARGS (octave_sparse_bool_matrix&, const octave_scalar&);
+
   SparseMatrix tmp (1, 1, v2.scalar_value ());
   return octave_value (v1.sparse_matrix_value (). concat (tmp, ra_idx));
 }
 
 DEFASSIGNOP (assign, sparse_bool_matrix, bool)
 {
   CAST_BINOP_ARGS (octave_sparse_bool_matrix&, const octave_bool&);
 
diff --git a/src/OPERATORS/op-sbm-bm.cc b/src/OPERATORS/op-sbm-bm.cc
--- a/src/OPERATORS/op-sbm-bm.cc
+++ b/src/OPERATORS/op-sbm-bm.cc
@@ -44,34 +44,34 @@ along with Octave; see the file COPYING.
 DEFBINOP_FN (eq, sparse_bool_matrix, bool_matrix, mx_el_eq)
 DEFBINOP_FN (ne, sparse_bool_matrix, bool_matrix, mx_el_ne)
 
 DEFBINOP_FN (el_and, sparse_bool_matrix, bool_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_bool_matrix, bool_matrix, mx_el_or)
 
 DEFCATOP (sbm_bm, sparse_bool_matrix, bool_matrix)
 {
-  CAST_BINOP_ARGS (octave_sparse_bool_matrix&, const octave_bool_matrix&); 
-                   
+  CAST_BINOP_ARGS (octave_sparse_bool_matrix&, const octave_bool_matrix&);
+
   SparseBoolMatrix tmp (v2.bool_matrix_value ());
   return octave_value (v1.sparse_bool_matrix_value (). concat (tmp, ra_idx));
 }
 
 DEFCATOP (sbm_m, sparse_bool_matrix, matrix)
 {
   CAST_BINOP_ARGS (octave_sparse_bool_matrix&, const octave_matrix&);
-                   
+
   SparseMatrix tmp (v2.matrix_value ());
   return octave_value (v1.sparse_matrix_value (). concat (tmp, ra_idx));
 }
 
 DEFCATOP (sm_bm, sparse_matrix, bool_matrix)
 {
-  CAST_BINOP_ARGS (octave_sparse_matrix&, const octave_bool_matrix&); 
-                   
+  CAST_BINOP_ARGS (octave_sparse_matrix&, const octave_bool_matrix&);
+
   SparseMatrix tmp (v2.matrix_value ());
   return octave_value (v1.sparse_matrix_value (). concat (tmp, ra_idx));
 }
 
 DEFASSIGNOP (assign, sparse_bool_matrix, bool_matrix)
 {
   CAST_BINOP_ARGS (octave_sparse_bool_matrix&, const octave_bool_matrix&);
 
@@ -80,20 +80,20 @@ DEFASSIGNOP (assign, sparse_bool_matrix,
 }
 
 void
 install_sbm_bm_ops (void)
 {
   INSTALL_BINOP (op_eq, octave_sparse_bool_matrix, octave_bool_matrix, eq);
   INSTALL_BINOP (op_ne, octave_sparse_bool_matrix, octave_bool_matrix, ne);
 
-  INSTALL_BINOP (op_el_and, octave_sparse_bool_matrix, octave_bool_matrix, 
+  INSTALL_BINOP (op_el_and, octave_sparse_bool_matrix, octave_bool_matrix,
                  el_and);
-  INSTALL_BINOP (op_el_or, octave_sparse_bool_matrix, octave_bool_matrix, 
+  INSTALL_BINOP (op_el_or, octave_sparse_bool_matrix, octave_bool_matrix,
                  el_or);
 
   INSTALL_CATOP (octave_sparse_bool_matrix, octave_bool_matrix, sbm_bm);
   INSTALL_CATOP (octave_sparse_matrix, octave_bool_matrix, sm_bm);
   INSTALL_CATOP (octave_sparse_bool_matrix, octave_matrix, sbm_m);
 
-  INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_bool_matrix, 
+  INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_bool_matrix,
                     octave_bool_matrix, assign);
 }
diff --git a/src/OPERATORS/op-sbm-sbm.cc b/src/OPERATORS/op-sbm-sbm.cc
--- a/src/OPERATORS/op-sbm-sbm.cc
+++ b/src/OPERATORS/op-sbm-sbm.cc
@@ -60,24 +60,24 @@ DEFUNOP (transpose, sparse_bool_matrix)
 
 // sparse bool matrix by sparse bool matrix ops.
 
 DEFBINOP_FN (eq, sparse_bool_matrix, sparse_bool_matrix, mx_el_eq)
 DEFBINOP_FN (ne, sparse_bool_matrix, sparse_bool_matrix, mx_el_ne)
 DEFBINOP_FN (el_and, sparse_bool_matrix, sparse_bool_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_bool_matrix, sparse_bool_matrix, mx_el_or)
 
-DEFNDCATOP_FN (sbm_sbm, sparse_bool_matrix, sparse_bool_matrix, 
+DEFNDCATOP_FN (sbm_sbm, sparse_bool_matrix, sparse_bool_matrix,
                sparse_bool_matrix, sparse_bool_matrix, concat)
-DEFNDCATOP_FN (sbm_sm, sparse_bool_matrix, sparse_matrix, sparse_matrix, 
+DEFNDCATOP_FN (sbm_sm, sparse_bool_matrix, sparse_matrix, sparse_matrix,
                sparse_matrix, concat)
-DEFNDCATOP_FN (sm_sbm, sparse_matrix, sparse_bool_matrix, sparse_matrix, 
+DEFNDCATOP_FN (sm_sbm, sparse_matrix, sparse_bool_matrix, sparse_matrix,
                sparse_matrix, concat)
 
-DEFASSIGNOP_FN (assign, sparse_bool_matrix, sparse_bool_matrix, 
+DEFASSIGNOP_FN (assign, sparse_bool_matrix, sparse_bool_matrix,
                 assign)
 
 CONVDECL (bool_matrix_to_double_matrix)
 {
   CAST_CONV_ARG (const octave_sparse_bool_matrix&);
 
   return new octave_sparse_matrix (SparseMatrix (v.sparse_bool_matrix_value ()));
 }
@@ -86,29 +86,29 @@ void
 install_sbm_sbm_ops (void)
 {
   INSTALL_UNOP (op_not, octave_sparse_bool_matrix, not);
   INSTALL_UNOP (op_uplus, octave_sparse_bool_matrix, uplus);
   INSTALL_UNOP (op_uminus, octave_sparse_bool_matrix, uminus);
   INSTALL_UNOP (op_transpose, octave_sparse_bool_matrix, transpose);
   INSTALL_UNOP (op_hermitian, octave_sparse_bool_matrix, transpose);
 
-  INSTALL_BINOP (op_eq, octave_sparse_bool_matrix, 
+  INSTALL_BINOP (op_eq, octave_sparse_bool_matrix,
                  octave_sparse_bool_matrix, eq);
-  INSTALL_BINOP (op_ne, octave_sparse_bool_matrix, 
+  INSTALL_BINOP (op_ne, octave_sparse_bool_matrix,
                  octave_sparse_bool_matrix, ne);
 
-  INSTALL_BINOP (op_el_and, octave_sparse_bool_matrix, 
+  INSTALL_BINOP (op_el_and, octave_sparse_bool_matrix,
                  octave_sparse_bool_matrix, el_and);
-  INSTALL_BINOP (op_el_or, octave_sparse_bool_matrix, 
+  INSTALL_BINOP (op_el_or, octave_sparse_bool_matrix,
                  octave_sparse_bool_matrix, el_or);
 
-  INSTALL_CATOP (octave_sparse_bool_matrix, octave_sparse_bool_matrix, 
+  INSTALL_CATOP (octave_sparse_bool_matrix, octave_sparse_bool_matrix,
                  sbm_sbm);
   INSTALL_CATOP (octave_sparse_bool_matrix, octave_sparse_matrix, sbm_sm);
   INSTALL_CATOP (octave_sparse_matrix, octave_sparse_bool_matrix, sm_sbm);
 
-  INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_bool_matrix, 
-                    octave_sparse_bool_matrix, assign); 
+  INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_bool_matrix,
+                    octave_sparse_bool_matrix, assign);
 
-  INSTALL_CONVOP (octave_sparse_bool_matrix, octave_sparse_matrix, 
+  INSTALL_CONVOP (octave_sparse_bool_matrix, octave_sparse_matrix,
                   bool_matrix_to_double_matrix);
 }
diff --git a/src/OPERATORS/op-scm-cm.cc b/src/OPERATORS/op-scm-cm.cc
--- a/src/OPERATORS/op-scm-cm.cc
+++ b/src/OPERATORS/op-scm-cm.cc
@@ -43,21 +43,21 @@ along with Octave; see the file COPYING.
 
 DEFBINOP_OP (add, sparse_complex_matrix, complex_matrix, +)
 DEFBINOP_OP (sub, sparse_complex_matrix, complex_matrix, -)
 
 DEFBINOP_OP (mul, sparse_complex_matrix, complex_matrix, *)
 
 DEFBINOP (div, sparse_complex_matrix, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_complex_matrix&);
   MatrixType typ = v2.matrix_type ();
-  
-  ComplexMatrix ret = xdiv (v1.complex_matrix_value (), 
+
+  ComplexMatrix ret = xdiv (v1.complex_matrix_value (),
                             v2.complex_matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, sparse_complex_matrix, complex_matrix)
 {
@@ -77,17 +77,17 @@ DEFBINOP (ldiv, sparse_complex_matrix, c
         gripe_divide_by_zero ();
 
       return octave_value (v2.complex_array_value () / d);
     }
   else
     {
       MatrixType typ = v1.matrix_type ();
 
-      ComplexMatrix ret = xleftdiv (v1.sparse_complex_matrix_value (), 
+      ComplexMatrix ret = xleftdiv (v1.sparse_complex_matrix_value (),
                       v2.complex_matrix_value (), typ);
 
       v1.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOP_FN (trans_mul, sparse_complex_matrix, complex_matrix, trans_mul);
@@ -100,39 +100,39 @@ DEFBINOP_FN (ge, sparse_complex_matrix, 
 DEFBINOP_FN (gt, sparse_complex_matrix, complex_matrix, mx_el_gt)
 DEFBINOP_FN (ne, sparse_complex_matrix, complex_matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, sparse_complex_matrix, complex_matrix, product)
 DEFBINOP_FN (el_div, sparse_complex_matrix, complex_matrix, quotient)
 
 DEFBINOP (el_pow, sparse_complex_matrix, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_complex_matrix&);
-  
-  return octave_value 
-    (elem_xpow (v1.sparse_complex_matrix_value (), SparseComplexMatrix 
+
+  return octave_value
+    (elem_xpow (v1.sparse_complex_matrix_value (), SparseComplexMatrix
                 (v2.complex_matrix_value ())));
 }
 
 DEFBINOP (el_ldiv, sparse_complex_matrix, matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_complex_matrix&);
 
-  return octave_value (quotient (v2.complex_matrix_value (), 
+  return octave_value (quotient (v2.complex_matrix_value (),
                                  v1.sparse_complex_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_complex_matrix, complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_complex_matrix, complex_matrix, mx_el_or)
 
 DEFCATOP (scm_cm, sparse_complex_matrix, complex_matrix)
 {
-  CAST_BINOP_ARGS (octave_sparse_complex_matrix&, 
+  CAST_BINOP_ARGS (octave_sparse_complex_matrix&,
                    const octave_complex_matrix&);
   SparseComplexMatrix tmp (v2.complex_matrix_value ());
   return octave_value
     (v1.sparse_complex_matrix_value (). concat (tmp, ra_idx));
 }
 
 DEFASSIGNOP (assign, sparse_complex_matrix, complex_matrix)
 {
@@ -142,55 +142,55 @@ DEFASSIGNOP (assign, sparse_complex_matr
   SparseComplexMatrix tmp (v2.complex_matrix_value ());
   v1.assign (idx, tmp);
   return octave_value ();
 }
 
 void
 install_scm_cm_ops (void)
 {
-  INSTALL_BINOP (op_add, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_add, octave_sparse_complex_matrix,
                  octave_complex_matrix, add);
-  INSTALL_BINOP (op_sub, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_sub, octave_sparse_complex_matrix,
                  octave_complex_matrix, sub);
-  INSTALL_BINOP (op_mul, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_mul, octave_sparse_complex_matrix,
                  octave_complex_matrix, mul);
-  INSTALL_BINOP (op_div, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_div, octave_sparse_complex_matrix,
                  octave_complex_matrix, div);
-  INSTALL_BINOP (op_pow, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_pow, octave_sparse_complex_matrix,
                  octave_complex_matrix, pow);
-  INSTALL_BINOP (op_ldiv, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_ldiv, octave_sparse_complex_matrix,
                  octave_complex_matrix, ldiv);
-  INSTALL_BINOP (op_trans_mul, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_trans_mul, octave_sparse_complex_matrix,
                  octave_complex_matrix, trans_mul);
-  INSTALL_BINOP (op_herm_mul, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_herm_mul, octave_sparse_complex_matrix,
                  octave_complex_matrix, herm_mul);
-  INSTALL_BINOP (op_lt, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_lt, octave_sparse_complex_matrix,
                  octave_complex_matrix, lt);
-  INSTALL_BINOP (op_le, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_le, octave_sparse_complex_matrix,
                  octave_complex_matrix, le);
-  INSTALL_BINOP (op_eq, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_eq, octave_sparse_complex_matrix,
                  octave_complex_matrix, eq);
-  INSTALL_BINOP (op_ge, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_ge, octave_sparse_complex_matrix,
                  octave_complex_matrix, ge);
-  INSTALL_BINOP (op_gt, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_gt, octave_sparse_complex_matrix,
                  octave_complex_matrix, gt);
-  INSTALL_BINOP (op_ne, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_ne, octave_sparse_complex_matrix,
                  octave_complex_matrix, ne);
-  INSTALL_BINOP (op_el_mul, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_el_mul, octave_sparse_complex_matrix,
                  octave_complex_matrix, el_mul);
-  INSTALL_BINOP (op_el_div, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_el_div, octave_sparse_complex_matrix,
                  octave_complex_matrix, el_div);
-  INSTALL_BINOP (op_el_pow, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_el_pow, octave_sparse_complex_matrix,
                  octave_complex_matrix, el_pow);
-  INSTALL_BINOP (op_el_ldiv, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_el_ldiv, octave_sparse_complex_matrix,
                  octave_complex_matrix, el_ldiv);
-  INSTALL_BINOP (op_el_and, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_el_and, octave_sparse_complex_matrix,
                  octave_complex_matrix, el_and);
-  INSTALL_BINOP (op_el_or, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_el_or, octave_sparse_complex_matrix,
                  octave_complex_matrix, el_or);
 
-  INSTALL_CATOP (octave_sparse_complex_matrix, 
+  INSTALL_CATOP (octave_sparse_complex_matrix,
                  octave_complex_matrix, scm_cm);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_complex_matrix,
                     octave_complex_matrix, assign);
 }
diff --git a/src/OPERATORS/op-scm-cs.cc b/src/OPERATORS/op-scm-cs.cc
--- a/src/OPERATORS/op-scm-cs.cc
+++ b/src/OPERATORS/op-scm-cs.cc
@@ -41,33 +41,33 @@ along with Octave; see the file COPYING.
 // sparse complex matrix by complex scalar ops.
 
 DEFBINOP_OP (add, sparse_complex_matrix, complex, +)
 DEFBINOP_OP (sub, sparse_complex_matrix, complex, -)
 DEFBINOP_OP (mul, sparse_complex_matrix, complex, *)
 
 DEFBINOP (div, sparse_complex_matrix, complex)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_complex&);
 
   Complex d = v2.complex_value ();
   octave_value retval;
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   retval = octave_value (v1.sparse_complex_matrix_value () / d);
 
   return retval;
 }
 
 DEFBINOP (pow, sparse_complex_matrix, complex)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_complex&);
   return xpow (v1.complex_matrix_value (), v2.complex_value ());
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_complex&);
 
@@ -97,17 +97,17 @@ DEFBINOP_FN (eq, sparse_complex_matrix, 
 DEFBINOP_FN (ge, sparse_complex_matrix, complex, mx_el_ge)
 DEFBINOP_FN (gt, sparse_complex_matrix, complex, mx_el_gt)
 DEFBINOP_FN (ne, sparse_complex_matrix, complex, mx_el_ne)
 
 DEFBINOP_OP (el_mul, sparse_complex_matrix, complex, *)
 
 DEFBINOP (el_div, sparse_complex_matrix, complex)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_complex&);
 
   octave_value retval;
 
   Complex d = v2.complex_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
@@ -116,17 +116,17 @@ DEFBINOP (el_div, sparse_complex_matrix,
 
   return retval;
 }
 
 DEFBINOP_FN (el_pow, sparse_complex_matrix, complex, elem_xpow)
 
 DEFBINOP (el_ldiv, sparse_complex_matrix, complex)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_complex&);
 
   return octave_value
     (x_el_div (v2.complex_value (), v1.sparse_complex_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_complex_matrix, complex, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_complex_matrix, complex, mx_el_or)
@@ -151,34 +151,34 @@ DEFASSIGNOP (assign, sparse_complex_matr
 void
 install_scm_cs_ops (void)
 {
   INSTALL_BINOP (op_add, octave_sparse_complex_matrix, octave_complex, add);
   INSTALL_BINOP (op_sub, octave_sparse_complex_matrix, octave_complex, sub);
   INSTALL_BINOP (op_mul, octave_sparse_complex_matrix, octave_complex, mul);
   INSTALL_BINOP (op_div, octave_sparse_complex_matrix, octave_complex, div);
   INSTALL_BINOP (op_pow, octave_sparse_complex_matrix, octave_complex, pow);
-  INSTALL_BINOP (op_ldiv, octave_sparse_complex_matrix, octave_complex, 
+  INSTALL_BINOP (op_ldiv, octave_sparse_complex_matrix, octave_complex,
                  ldiv);
   INSTALL_BINOP (op_lt, octave_sparse_complex_matrix, octave_complex, lt);
   INSTALL_BINOP (op_le, octave_sparse_complex_matrix, octave_complex, le);
   INSTALL_BINOP (op_eq, octave_sparse_complex_matrix, octave_complex, eq);
   INSTALL_BINOP (op_ge, octave_sparse_complex_matrix, octave_complex, ge);
   INSTALL_BINOP (op_gt, octave_sparse_complex_matrix, octave_complex, gt);
   INSTALL_BINOP (op_ne, octave_sparse_complex_matrix, octave_complex, ne);
-  INSTALL_BINOP (op_el_mul, octave_sparse_complex_matrix, octave_complex, 
+  INSTALL_BINOP (op_el_mul, octave_sparse_complex_matrix, octave_complex,
                  el_mul);
-  INSTALL_BINOP (op_el_div, octave_sparse_complex_matrix, octave_complex, 
+  INSTALL_BINOP (op_el_div, octave_sparse_complex_matrix, octave_complex,
                  el_div);
-  INSTALL_BINOP (op_el_pow, octave_sparse_complex_matrix, octave_complex, 
+  INSTALL_BINOP (op_el_pow, octave_sparse_complex_matrix, octave_complex,
                  el_pow);
-  INSTALL_BINOP (op_el_ldiv, octave_sparse_complex_matrix, octave_complex, 
+  INSTALL_BINOP (op_el_ldiv, octave_sparse_complex_matrix, octave_complex,
                  el_ldiv);
-  INSTALL_BINOP (op_el_and, octave_sparse_complex_matrix, octave_complex, 
+  INSTALL_BINOP (op_el_and, octave_sparse_complex_matrix, octave_complex,
                  el_and);
-  INSTALL_BINOP (op_el_or, octave_sparse_complex_matrix, octave_complex, 
+  INSTALL_BINOP (op_el_or, octave_sparse_complex_matrix, octave_complex,
                  el_or);
 
   INSTALL_CATOP (octave_sparse_complex_matrix, octave_complex, scm_cs);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_complex_matrix, octave_complex,
                     assign);
 }
diff --git a/src/OPERATORS/op-scm-m.cc b/src/OPERATORS/op-scm-m.cc
--- a/src/OPERATORS/op-scm-m.cc
+++ b/src/OPERATORS/op-scm-m.cc
@@ -44,51 +44,51 @@ along with Octave; see the file COPYING.
 
 DEFBINOP_OP (add, sparse_complex_matrix, matrix, +)
 DEFBINOP_OP (sub, sparse_complex_matrix, matrix, -)
 
 DEFBINOP_OP (mul, sparse_complex_matrix, matrix, *)
 
 DEFBINOP (div, sparse_complex_matrix, matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_matrix&);
   MatrixType typ = v2.matrix_type ();
-  
-  ComplexMatrix ret = xdiv (v1.complex_matrix_value (), 
+
+  ComplexMatrix ret = xdiv (v1.complex_matrix_value (),
                             v2.matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, sparse_complex_matrix, matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_matrix&);
-  
+
   if (v1.rows() == 1 && v1.columns() == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v2.array_value () / d);
     }
   else
     {
       MatrixType typ = v1.matrix_type ();
 
-      ComplexMatrix ret = xleftdiv (v1.sparse_complex_matrix_value (), 
+      ComplexMatrix ret = xleftdiv (v1.sparse_complex_matrix_value (),
                                     v2.matrix_value (), typ);
 
       v1.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOP_FN (lt, sparse_complex_matrix, matrix, mx_el_lt)
@@ -98,27 +98,27 @@ DEFBINOP_FN (ge, sparse_complex_matrix, 
 DEFBINOP_FN (gt, sparse_complex_matrix, matrix, mx_el_gt)
 DEFBINOP_FN (ne, sparse_complex_matrix, matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, sparse_complex_matrix, matrix, product)
 DEFBINOP_FN (el_div, sparse_complex_matrix, matrix, quotient)
 
 DEFBINOP (el_pow, sparse_complex_matrix, matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_matrix&);
-  
-  return octave_value 
-    (elem_xpow (v1.sparse_complex_matrix_value (), SparseMatrix 
+
+  return octave_value
+    (elem_xpow (v1.sparse_complex_matrix_value (), SparseMatrix
                 (v2.matrix_value ())));
 }
 
 DEFBINOP (el_ldiv, sparse_complex_matrix, matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_matrix&);
 
   return octave_value
     (quotient (v2.matrix_value (), v1.sparse_complex_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_complex_matrix, matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_complex_matrix, matrix, mx_el_or)
@@ -150,26 +150,26 @@ install_scm_m_ops (void)
   INSTALL_BINOP (op_pow, octave_sparse_complex_matrix, octave_matrix, pow);
   INSTALL_BINOP (op_ldiv, octave_sparse_complex_matrix, octave_matrix, ldiv);
   INSTALL_BINOP (op_lt, octave_sparse_complex_matrix, octave_matrix, lt);
   INSTALL_BINOP (op_le, octave_sparse_complex_matrix, octave_matrix, le);
   INSTALL_BINOP (op_eq, octave_sparse_complex_matrix, octave_matrix, eq);
   INSTALL_BINOP (op_ge, octave_sparse_complex_matrix, octave_matrix, ge);
   INSTALL_BINOP (op_gt, octave_sparse_complex_matrix, octave_matrix, gt);
   INSTALL_BINOP (op_ne, octave_sparse_complex_matrix, octave_matrix, ne);
-  INSTALL_BINOP (op_el_mul, octave_sparse_complex_matrix, octave_matrix, 
+  INSTALL_BINOP (op_el_mul, octave_sparse_complex_matrix, octave_matrix,
                  el_mul);
-  INSTALL_BINOP (op_el_div, octave_sparse_complex_matrix, octave_matrix, 
+  INSTALL_BINOP (op_el_div, octave_sparse_complex_matrix, octave_matrix,
                  el_div);
-  INSTALL_BINOP (op_el_pow, octave_sparse_complex_matrix, octave_matrix, 
+  INSTALL_BINOP (op_el_pow, octave_sparse_complex_matrix, octave_matrix,
                  el_pow);
-  INSTALL_BINOP (op_el_ldiv, octave_sparse_complex_matrix, octave_matrix, 
+  INSTALL_BINOP (op_el_ldiv, octave_sparse_complex_matrix, octave_matrix,
                  el_ldiv);
-  INSTALL_BINOP (op_el_and, octave_sparse_complex_matrix, octave_matrix, 
+  INSTALL_BINOP (op_el_and, octave_sparse_complex_matrix, octave_matrix,
                  el_and);
-  INSTALL_BINOP (op_el_or, octave_sparse_complex_matrix, octave_matrix, 
+  INSTALL_BINOP (op_el_or, octave_sparse_complex_matrix, octave_matrix,
                  el_or);
 
   INSTALL_CATOP (octave_sparse_complex_matrix, octave_matrix, scm_m);
 
-  INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_complex_matrix, octave_matrix, 
+  INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_complex_matrix, octave_matrix,
                     assign);
 }
diff --git a/src/OPERATORS/op-scm-s.cc b/src/OPERATORS/op-scm-s.cc
--- a/src/OPERATORS/op-scm-s.cc
+++ b/src/OPERATORS/op-scm-s.cc
@@ -44,33 +44,33 @@ along with Octave; see the file COPYING.
 // sparse complex matrix by scalar ops.
 
 DEFBINOP_OP (add, sparse_complex_matrix, scalar, +)
 DEFBINOP_OP (sub, sparse_complex_matrix, scalar, -)
 DEFBINOP_OP (mul, sparse_complex_matrix, scalar, *)
 
 DEFBINOP (div, sparse_complex_matrix, scalar)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_scalar&);
 
   double d = v2.double_value ();
   octave_value retval;
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   retval = octave_value (v1.sparse_complex_matrix_value () / d);
 
   return retval;
 }
 
 DEFBINOP (pow, sparse_complex_matrix, scalar)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_scalar&);
 
   double tmp = v2.scalar_value ();
   if (static_cast<int> (tmp) == tmp)
     return xpow (v1.sparse_complex_matrix_value (), tmp);
   else
     return xpow (v1.complex_matrix_value (), tmp);
 }
@@ -105,17 +105,17 @@ DEFBINOP_FN (eq, sparse_complex_matrix, 
 DEFBINOP_FN (ge, sparse_complex_matrix, scalar, mx_el_ge)
 DEFBINOP_FN (gt, sparse_complex_matrix, scalar, mx_el_gt)
 DEFBINOP_FN (ne, sparse_complex_matrix, scalar, mx_el_ne)
 
 DEFBINOP_OP (el_mul, sparse_complex_matrix, scalar, *)
 
 DEFBINOP (el_div, sparse_complex_matrix, scalar)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_scalar&);
 
   double d = v2.double_value ();
   octave_value retval;
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
@@ -164,26 +164,26 @@ install_scm_s_ops (void)
   INSTALL_BINOP (op_pow, octave_sparse_complex_matrix, octave_scalar, pow);
   INSTALL_BINOP (op_ldiv, octave_sparse_complex_matrix, octave_scalar, ldiv);
   INSTALL_BINOP (op_lt, octave_sparse_complex_matrix, octave_scalar, lt);
   INSTALL_BINOP (op_le, octave_sparse_complex_matrix, octave_scalar, le);
   INSTALL_BINOP (op_eq, octave_sparse_complex_matrix, octave_scalar, eq);
   INSTALL_BINOP (op_ge, octave_sparse_complex_matrix, octave_scalar, ge);
   INSTALL_BINOP (op_gt, octave_sparse_complex_matrix, octave_scalar, gt);
   INSTALL_BINOP (op_ne, octave_sparse_complex_matrix, octave_scalar, ne);
-  INSTALL_BINOP (op_el_mul, octave_sparse_complex_matrix, octave_scalar, 
+  INSTALL_BINOP (op_el_mul, octave_sparse_complex_matrix, octave_scalar,
                  el_mul);
-  INSTALL_BINOP (op_el_div, octave_sparse_complex_matrix, octave_scalar, 
+  INSTALL_BINOP (op_el_div, octave_sparse_complex_matrix, octave_scalar,
                  el_div);
-  INSTALL_BINOP (op_el_pow, octave_sparse_complex_matrix, octave_scalar, 
+  INSTALL_BINOP (op_el_pow, octave_sparse_complex_matrix, octave_scalar,
                  el_pow);
-  INSTALL_BINOP (op_el_ldiv, octave_sparse_complex_matrix, octave_scalar, 
+  INSTALL_BINOP (op_el_ldiv, octave_sparse_complex_matrix, octave_scalar,
                  el_ldiv);
-  INSTALL_BINOP (op_el_and, octave_sparse_complex_matrix, octave_scalar, 
+  INSTALL_BINOP (op_el_and, octave_sparse_complex_matrix, octave_scalar,
                  el_and);
-  INSTALL_BINOP (op_el_or, octave_sparse_complex_matrix, octave_scalar, 
+  INSTALL_BINOP (op_el_or, octave_sparse_complex_matrix, octave_scalar,
                  el_or);
 
   INSTALL_CATOP (octave_sparse_complex_matrix, octave_scalar, scm_s);
 
-  INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_complex_matrix, octave_scalar, 
+  INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_complex_matrix, octave_scalar,
                     assign);
 }
diff --git a/src/OPERATORS/op-scm-scm.cc b/src/OPERATORS/op-scm-scm.cc
--- a/src/OPERATORS/op-scm-scm.cc
+++ b/src/OPERATORS/op-scm-scm.cc
@@ -54,25 +54,25 @@ along with Octave; see the file COPYING.
 
 DEFUNOP_OP (not, sparse_complex_matrix, !)
 DEFUNOP_OP (uplus, sparse_complex_matrix, /* no-op */)
 DEFUNOP_OP (uminus, sparse_complex_matrix, -)
 
 DEFUNOP (transpose, sparse_complex_matrix)
 {
   CAST_UNOP_ARG (const octave_sparse_complex_matrix&);
-  return octave_value 
+  return octave_value
     (v.sparse_complex_matrix_value().transpose (),
      v.matrix_type ().transpose ());
 }
 
 DEFUNOP (hermitian, sparse_complex_matrix)
 {
   CAST_UNOP_ARG (const octave_sparse_complex_matrix&);
-  return octave_value 
+  return octave_value
     (v.sparse_complex_matrix_value().hermitian (),
      v.matrix_type ().transpose ());
 }
 
 #if 0
 DEFUNOP (incr, sparse_complex_matrix)
 {
   CAST_UNOP_ARG (const octave_sparse_complex_matrix&);
@@ -92,65 +92,65 @@ DEFUNOP (decr, sparse_complex_matrix)
 
 DEFBINOP_OP (add, sparse_complex_matrix, sparse_complex_matrix, +)
 DEFBINOP_OP (sub, sparse_complex_matrix, sparse_complex_matrix, -)
 
 DEFBINOP_OP (mul, sparse_complex_matrix, sparse_complex_matrix, *)
 
 DEFBINOP (div, sparse_complex_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_sparse_complex_matrix&);
- 
+
   if (v2.rows() == 1 && v2.columns() == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v1.sparse_complex_matrix_value () / d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
-      SparseComplexMatrix ret = xdiv (v1.sparse_complex_matrix_value (), 
+      SparseComplexMatrix ret = xdiv (v1.sparse_complex_matrix_value (),
                                       v2.sparse_complex_matrix_value (), typ);
-  
+
       v2.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOPX (pow, sparse_complex_matrix, sparse_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_sparse_complex_matrix&);
 
   if (v1.rows() == 1 && v1.columns() == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v2.sparse_complex_matrix_value () / d);
     }
   else
     {
       MatrixType typ = v1.matrix_type ();
 
-      SparseComplexMatrix ret = 
-        xleftdiv (v1.sparse_complex_matrix_value (), 
+      SparseComplexMatrix ret =
+        xleftdiv (v1.sparse_complex_matrix_value (),
                   v2.sparse_complex_matrix_value (), typ);
 
       v1.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOP_FN (lt, sparse_complex_matrix, sparse_complex_matrix, mx_el_lt)
@@ -161,20 +161,20 @@ DEFBINOP_FN (gt, sparse_complex_matrix, 
 DEFBINOP_FN (ne, sparse_complex_matrix, sparse_complex_matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, sparse_complex_matrix, sparse_complex_matrix, product)
 DEFBINOP_FN (el_div, sparse_complex_matrix, sparse_complex_matrix, quotient)
 DEFBINOP_FN (el_pow, sparse_complex_matrix, sparse_complex_matrix, elem_xpow)
 
 DEFBINOP (el_ldiv, sparse_complex_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_sparse_complex_matrix&);
 
-  return octave_value (quotient (v2.sparse_complex_matrix_value (), 
+  return octave_value (quotient (v2.sparse_complex_matrix_value (),
                                  v1.sparse_complex_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_complex_matrix, sparse_complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_complex_matrix, sparse_complex_matrix, mx_el_or)
 
 DEFCATOP_FN (scm_scm, sparse_complex_matrix, sparse_complex_matrix, concat)
 
@@ -191,58 +191,58 @@ install_scm_scm_ops (void)
   INSTALL_UNOP (op_transpose, octave_sparse_complex_matrix, transpose);
   INSTALL_UNOP (op_hermitian, octave_sparse_complex_matrix, hermitian);
 
 #if 0
   INSTALL_NCUNOP (op_incr, octave_sparse_complex_matrix, incr);
   INSTALL_NCUNOP (op_decr, octave_sparse_complex_matrix, decr);
 #endif
 
-  INSTALL_BINOP (op_add, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_add, octave_sparse_complex_matrix,
                  octave_sparse_complex_matrix, add);
-  INSTALL_BINOP (op_sub, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_sub, octave_sparse_complex_matrix,
                  octave_sparse_complex_matrix, sub);
-  INSTALL_BINOP (op_mul, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_mul, octave_sparse_complex_matrix,
                  octave_sparse_complex_matrix, mul);
-  INSTALL_BINOP (op_div, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_div, octave_sparse_complex_matrix,
                  octave_sparse_complex_matrix, div);
-  INSTALL_BINOP (op_pow, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_pow, octave_sparse_complex_matrix,
                  octave_sparse_complex_matrix, pow);
-  INSTALL_BINOP (op_ldiv, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_ldiv, octave_sparse_complex_matrix,
                  octave_sparse_complex_matrix, ldiv);
-  INSTALL_BINOP (op_lt, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_lt, octave_sparse_complex_matrix,
                  octave_sparse_complex_matrix, lt);
-  INSTALL_BINOP (op_le, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_le, octave_sparse_complex_matrix,
                  octave_sparse_complex_matrix, le);
-  INSTALL_BINOP (op_eq, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_eq, octave_sparse_complex_matrix,
                  octave_sparse_complex_matrix, eq);
-  INSTALL_BINOP (op_ge, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_ge, octave_sparse_complex_matrix,
                  octave_sparse_complex_matrix, ge);
-  INSTALL_BINOP (op_gt, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_gt, octave_sparse_complex_matrix,
                  octave_sparse_complex_matrix, gt);
-  INSTALL_BINOP (op_ne, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_ne, octave_sparse_complex_matrix,
                  octave_sparse_complex_matrix, ne);
-  INSTALL_BINOP (op_el_mul, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_el_mul, octave_sparse_complex_matrix,
                  octave_sparse_complex_matrix, el_mul);
-  INSTALL_BINOP (op_el_div, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_el_div, octave_sparse_complex_matrix,
                  octave_sparse_complex_matrix, el_div);
-  INSTALL_BINOP (op_el_pow, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_el_pow, octave_sparse_complex_matrix,
                  octave_sparse_complex_matrix, el_pow);
-  INSTALL_BINOP (op_el_ldiv, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_el_ldiv, octave_sparse_complex_matrix,
                  octave_sparse_complex_matrix, el_ldiv);
-  INSTALL_BINOP (op_el_and, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_el_and, octave_sparse_complex_matrix,
                  octave_sparse_complex_matrix, el_and);
-  INSTALL_BINOP (op_el_or, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_el_or, octave_sparse_complex_matrix,
                  octave_sparse_complex_matrix, el_or);
 
-  INSTALL_CATOP (octave_sparse_complex_matrix, 
+  INSTALL_CATOP (octave_sparse_complex_matrix,
                  octave_sparse_complex_matrix, scm_scm);
 
-  INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_complex_matrix, 
+  INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_complex_matrix,
                     octave_sparse_complex_matrix, assign);
 
-  INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_complex_matrix, 
+  INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_complex_matrix,
                     octave_null_matrix, null_assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_complex_matrix, 
+  INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_complex_matrix,
                     octave_null_str, null_assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_complex_matrix, 
+  INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_complex_matrix,
                     octave_null_sq_str, null_assign);
 }
diff --git a/src/OPERATORS/op-scm-sm.cc b/src/OPERATORS/op-scm-sm.cc
--- a/src/OPERATORS/op-scm-sm.cc
+++ b/src/OPERATORS/op-scm-sm.cc
@@ -56,19 +56,19 @@ DEFBINOP (div, sparse_complex_matrix, sp
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v1.sparse_complex_matrix_value () / d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
-      SparseComplexMatrix ret = xdiv (v1.sparse_complex_matrix_value (), 
+      SparseComplexMatrix ret = xdiv (v1.sparse_complex_matrix_value (),
                                       v2.sparse_matrix_value (), typ);
-  
+
       v2.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOPX (pow, sparse_complex_matrix, sparse_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
@@ -87,17 +87,17 @@ DEFBINOP (ldiv, sparse_complex_matrix, s
         gripe_divide_by_zero ();
 
       return octave_value (v2.sparse_matrix_value () / d);
     }
   else
     {
       MatrixType typ = v1.matrix_type ();
 
-      SparseComplexMatrix ret = xleftdiv (v1.sparse_complex_matrix_value (), 
+      SparseComplexMatrix ret = xleftdiv (v1.sparse_complex_matrix_value (),
                                           v2.sparse_matrix_value (), typ);
 
       v1.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOP_FN (lt, sparse_complex_matrix, sparse_matrix, mx_el_lt)
@@ -108,17 +108,17 @@ DEFBINOP_FN (gt, sparse_complex_matrix, 
 DEFBINOP_FN (ne, sparse_complex_matrix, sparse_matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, sparse_complex_matrix, sparse_matrix, product)
 DEFBINOP_FN (el_div, sparse_complex_matrix, sparse_matrix, quotient)
 DEFBINOP_FN (el_pow, sparse_complex_matrix, sparse_matrix, elem_xpow)
 
 DEFBINOP (el_ldiv, sparse_complex_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_sparse_matrix&);
 
   return octave_value
     (quotient (v2.sparse_matrix_value (), v1.sparse_complex_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_complex_matrix, sparse_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_complex_matrix, sparse_matrix, mx_el_or)
@@ -137,38 +137,38 @@ install_scm_sm_ops (void)
   INSTALL_BINOP (op_mul, octave_sparse_complex_matrix, octave_sparse_matrix,
                  mul);
   INSTALL_BINOP (op_div, octave_sparse_complex_matrix, octave_sparse_matrix,
                  div);
   INSTALL_BINOP (op_pow, octave_sparse_complex_matrix, octave_sparse_matrix,
                  pow);
   INSTALL_BINOP (op_ldiv, octave_sparse_complex_matrix, octave_sparse_matrix,
                  ldiv);
-  INSTALL_BINOP (op_lt, octave_sparse_complex_matrix, octave_sparse_matrix, 
+  INSTALL_BINOP (op_lt, octave_sparse_complex_matrix, octave_sparse_matrix,
                  lt);
-  INSTALL_BINOP (op_le, octave_sparse_complex_matrix, octave_sparse_matrix, 
+  INSTALL_BINOP (op_le, octave_sparse_complex_matrix, octave_sparse_matrix,
                  le);
-  INSTALL_BINOP (op_eq, octave_sparse_complex_matrix, octave_sparse_matrix, 
+  INSTALL_BINOP (op_eq, octave_sparse_complex_matrix, octave_sparse_matrix,
                  eq);
-  INSTALL_BINOP (op_ge, octave_sparse_complex_matrix, octave_sparse_matrix, 
+  INSTALL_BINOP (op_ge, octave_sparse_complex_matrix, octave_sparse_matrix,
                  ge);
-  INSTALL_BINOP (op_gt, octave_sparse_complex_matrix, octave_sparse_matrix, 
+  INSTALL_BINOP (op_gt, octave_sparse_complex_matrix, octave_sparse_matrix,
                  gt);
-  INSTALL_BINOP (op_ne, octave_sparse_complex_matrix, octave_sparse_matrix, 
+  INSTALL_BINOP (op_ne, octave_sparse_complex_matrix, octave_sparse_matrix,
                  ne);
-  INSTALL_BINOP (op_el_mul, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_el_mul, octave_sparse_complex_matrix,
                  octave_sparse_matrix, el_mul);
-  INSTALL_BINOP (op_el_div, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_el_div, octave_sparse_complex_matrix,
                  octave_sparse_matrix, el_div);
   INSTALL_BINOP (op_el_pow, octave_sparse_complex_matrix,
                  octave_sparse_matrix, el_pow);
-  INSTALL_BINOP (op_el_ldiv, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_el_ldiv, octave_sparse_complex_matrix,
                  octave_sparse_matrix, el_ldiv);
-  INSTALL_BINOP (op_el_and, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_el_and, octave_sparse_complex_matrix,
                  octave_sparse_matrix, el_and);
-  INSTALL_BINOP (op_el_or, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_el_or, octave_sparse_complex_matrix,
                  octave_sparse_matrix, el_or);
 
   INSTALL_CATOP (octave_sparse_complex_matrix, octave_sparse_matrix, scm_sm);
 
-  INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_complex_matrix, 
+  INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_complex_matrix,
                     octave_sparse_matrix, assign);
 }
diff --git a/src/OPERATORS/op-sm-cm.cc b/src/OPERATORS/op-sm-cm.cc
--- a/src/OPERATORS/op-sm-cm.cc
+++ b/src/OPERATORS/op-sm-cm.cc
@@ -43,21 +43,21 @@ along with Octave; see the file COPYING.
 
 DEFBINOP_OP (add, sparse_matrix, complex_matrix, +)
 DEFBINOP_OP (sub, sparse_matrix, complex_matrix, -)
 
 DEFBINOP_OP (mul, sparse_matrix, complex_matrix, *)
 
 DEFBINOP (div, sparse_matrix, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, 
+  CAST_BINOP_ARGS (const octave_sparse_matrix&,
                    const octave_complex_matrix&);
   MatrixType typ = v2.matrix_type ();
-  
-  ComplexMatrix ret = xdiv (v1.matrix_value (), 
+
+  ComplexMatrix ret = xdiv (v1.matrix_value (),
                             v2.complex_matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, sparse_matrix, complex_matrix)
 {
@@ -77,17 +77,17 @@ DEFBINOP (ldiv, sparse_matrix, complex_m
         gripe_divide_by_zero ();
 
       return octave_value (v2.complex_array_value () / d);
     }
   else
     {
       MatrixType typ = v1.matrix_type ();
 
-      ComplexMatrix ret = xleftdiv (v1.sparse_matrix_value (), 
+      ComplexMatrix ret = xleftdiv (v1.sparse_matrix_value (),
                                     v2.complex_matrix_value (), typ);
 
       v1.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOP_FN (lt, sparse_matrix, complex_matrix, mx_el_lt)
@@ -97,30 +97,30 @@ DEFBINOP_FN (ge, sparse_matrix, complex_
 DEFBINOP_FN (gt, sparse_matrix, complex_matrix, mx_el_gt)
 DEFBINOP_FN (ne, sparse_matrix, complex_matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, sparse_matrix, complex_matrix, product)
 DEFBINOP_FN (el_div, sparse_matrix, complex_matrix, quotient)
 
 DEFBINOP (el_pow, sparse_matrix, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, 
+  CAST_BINOP_ARGS (const octave_sparse_matrix&,
                    const octave_complex_matrix&);
-  
-  return octave_value 
-    (elem_xpow (v1.sparse_matrix_value (), SparseComplexMatrix 
+
+  return octave_value
+    (elem_xpow (v1.sparse_matrix_value (), SparseComplexMatrix
                 (v2.complex_matrix_value ())));
 }
 
 DEFBINOP (el_ldiv, sparse_matrix, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, 
+  CAST_BINOP_ARGS (const octave_sparse_matrix&,
                    const octave_complex_matrix&);
 
-  return octave_value 
+  return octave_value
     (quotient (v2.complex_matrix_value (), v1.sparse_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_matrix, complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_matrix, complex_matrix, mx_el_or)
 
 DEFCATOP (sm_cm, sparse_matrix, complex_matrix)
 {
@@ -145,29 +145,29 @@ install_sm_cm_ops (void)
   INSTALL_BINOP (op_pow, octave_sparse_matrix, octave_complex_matrix, pow);
   INSTALL_BINOP (op_ldiv, octave_sparse_matrix, octave_complex_matrix, ldiv);
   INSTALL_BINOP (op_lt, octave_sparse_matrix, octave_complex_matrix, lt);
   INSTALL_BINOP (op_le, octave_sparse_matrix, octave_complex_matrix, le);
   INSTALL_BINOP (op_eq, octave_sparse_matrix, octave_complex_matrix, eq);
   INSTALL_BINOP (op_ge, octave_sparse_matrix, octave_complex_matrix, ge);
   INSTALL_BINOP (op_gt, octave_sparse_matrix, octave_complex_matrix, gt);
   INSTALL_BINOP (op_ne, octave_sparse_matrix, octave_complex_matrix, ne);
-  INSTALL_BINOP (op_el_mul, octave_sparse_matrix, octave_complex_matrix, 
+  INSTALL_BINOP (op_el_mul, octave_sparse_matrix, octave_complex_matrix,
                  el_mul);
-  INSTALL_BINOP (op_el_div, octave_sparse_matrix, octave_complex_matrix, 
+  INSTALL_BINOP (op_el_div, octave_sparse_matrix, octave_complex_matrix,
                  el_div);
-  INSTALL_BINOP (op_el_pow, octave_sparse_matrix, octave_complex_matrix, 
+  INSTALL_BINOP (op_el_pow, octave_sparse_matrix, octave_complex_matrix,
                  el_pow);
-  INSTALL_BINOP (op_el_ldiv, octave_sparse_matrix, octave_complex_matrix, 
+  INSTALL_BINOP (op_el_ldiv, octave_sparse_matrix, octave_complex_matrix,
                  el_ldiv);
-  INSTALL_BINOP (op_el_and, octave_sparse_matrix, octave_complex_matrix, 
+  INSTALL_BINOP (op_el_and, octave_sparse_matrix, octave_complex_matrix,
                  el_and);
-  INSTALL_BINOP (op_el_or, octave_sparse_matrix, octave_complex_matrix, 
+  INSTALL_BINOP (op_el_or, octave_sparse_matrix, octave_complex_matrix,
                  el_or);
 
   INSTALL_CATOP (octave_sparse_matrix, octave_complex_matrix, sm_cm);
 
-  INSTALL_ASSIGNCONV (octave_sparse_matrix, octave_complex_matrix, 
+  INSTALL_ASSIGNCONV (octave_sparse_matrix, octave_complex_matrix,
                       octave_sparse_complex_matrix);
 
-  INSTALL_WIDENOP (octave_sparse_matrix, octave_complex_matrix, 
+  INSTALL_WIDENOP (octave_sparse_matrix, octave_complex_matrix,
                    sparse_complex_matrix_conv);
 }
diff --git a/src/OPERATORS/op-sm-cs.cc b/src/OPERATORS/op-sm-cs.cc
--- a/src/OPERATORS/op-sm-cs.cc
+++ b/src/OPERATORS/op-sm-cs.cc
@@ -116,17 +116,17 @@ DEFBINOP (el_div, sparse_matrix, complex
 }
 
 DEFBINOP_FN (el_pow, sparse_matrix, complex, elem_xpow)
 
 DEFBINOP (el_ldiv, sparse_matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex&);
 
-  return octave_value (x_el_div (v2.complex_value (), 
+  return octave_value (x_el_div (v2.complex_value (),
                                  v1.sparse_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_matrix, complex, mx_el_and)
 DEFBINOP_FN (el_or, sparse_matrix, complex, mx_el_or)
 
 DEFCATOP (sm_cs, sparse_matrix, complex)
 {
diff --git a/src/OPERATORS/op-sm-m.cc b/src/OPERATORS/op-sm-m.cc
--- a/src/OPERATORS/op-sm-m.cc
+++ b/src/OPERATORS/op-sm-m.cc
@@ -45,17 +45,17 @@ DEFBINOP_OP (add, sparse_matrix, matrix,
 DEFBINOP_OP (sub, sparse_matrix, matrix, -)
 
 DEFBINOP_OP (mul, sparse_matrix, matrix, *)
 
 DEFBINOP (div, sparse_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_matrix&);
   MatrixType typ = v2.matrix_type ();
-  
+
   Matrix ret = xdiv (v1.matrix_value (), v2.matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, sparse_matrix, matrix)
 {
@@ -75,17 +75,17 @@ DEFBINOP (ldiv, sparse_matrix, matrix)
         gripe_divide_by_zero ();
 
       return octave_value (v2.array_value () / d);
     }
   else
     {
       MatrixType typ = v1.matrix_type ();
 
-      Matrix ret = xleftdiv (v1.sparse_matrix_value (), 
+      Matrix ret = xleftdiv (v1.sparse_matrix_value (),
                              v2.matrix_value (), typ);
 
       v1.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOP_FN (trans_mul, sparse_matrix, matrix, trans_mul);
@@ -98,25 +98,25 @@ DEFBINOP_FN (gt, sparse_matrix, matrix, 
 DEFBINOP_FN (ne, sparse_matrix, matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, sparse_matrix, matrix, product)
 DEFBINOP_FN (el_div, sparse_matrix, matrix, quotient)
 
 DEFBINOP (el_pow, sparse_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_matrix&);
-  
-  return octave_value (elem_xpow (v1.sparse_matrix_value (), 
+
+  return octave_value (elem_xpow (v1.sparse_matrix_value (),
                                   SparseMatrix (v2.matrix_value ())));
 }
 
 DEFBINOP (el_ldiv, sparse_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_matrix&);
-  
+
   return octave_value
     (quotient (v2.matrix_value (), v1.sparse_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_matrix, matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_matrix, matrix, mx_el_or)
 
 DEFCATOP (sm_m, sparse_matrix, matrix)
diff --git a/src/OPERATORS/op-sm-s.cc b/src/OPERATORS/op-sm-s.cc
--- a/src/OPERATORS/op-sm-s.cc
+++ b/src/OPERATORS/op-sm-s.cc
@@ -118,17 +118,17 @@ DEFBINOP (el_div, sparse_matrix, scalar)
 }
 
 DEFBINOP_FN (el_pow, sparse_matrix, scalar, elem_xpow)
 
 DEFBINOP (el_ldiv, sparse_matrix, scalar)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_scalar&);
 
-  return octave_value 
+  return octave_value
     (x_el_div (v2.complex_value (), v1.sparse_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_matrix, scalar, mx_el_and)
 DEFBINOP_FN (el_or, sparse_matrix, scalar, mx_el_or)
 
 DEFCATOP (sm_s, sparse_matrix, scalar)
 {
diff --git a/src/OPERATORS/op-sm-scm.cc b/src/OPERATORS/op-sm-scm.cc
--- a/src/OPERATORS/op-sm-scm.cc
+++ b/src/OPERATORS/op-sm-scm.cc
@@ -56,19 +56,19 @@ DEFBINOP (div, sparse_matrix, sparse_com
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v1.sparse_matrix_value () / d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
-      SparseComplexMatrix ret = xdiv (v1.sparse_matrix_value (), 
+      SparseComplexMatrix ret = xdiv (v1.sparse_matrix_value (),
                                   v2.sparse_complex_matrix_value (), typ);
-  
+
       v2.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOPX (pow, sparse_matrix, sparse_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
@@ -87,18 +87,18 @@ DEFBINOP (ldiv, sparse_matrix, sparse_co
         gripe_divide_by_zero ();
 
       return octave_value (v2.sparse_complex_matrix_value () / d);
     }
   else
     {
       MatrixType typ = v1.matrix_type ();
 
-      SparseComplexMatrix ret = 
-        xleftdiv (v1.sparse_matrix_value (), 
+      SparseComplexMatrix ret =
+        xleftdiv (v1.sparse_matrix_value (),
                   v2.sparse_complex_matrix_value (), typ);
 
       v1.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOP_FN (lt, sparse_matrix, sparse_complex_matrix, mx_el_lt)
@@ -109,17 +109,17 @@ DEFBINOP_FN (gt, sparse_matrix, sparse_c
 DEFBINOP_FN (ne, sparse_matrix, sparse_complex_matrix, mx_el_ne)
 
 DEFBINOP_FN (el_mul, sparse_matrix, sparse_complex_matrix, product)
 DEFBINOP_FN (el_div, sparse_matrix, sparse_complex_matrix, quotient)
 DEFBINOP_FN (el_pow, sparse_matrix, sparse_complex_matrix, elem_xpow)
 
 DEFBINOP (el_ldiv, sparse_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, 
+  CAST_BINOP_ARGS (const octave_sparse_matrix&,
                    const octave_sparse_complex_matrix&);
 
   return octave_value
     (quotient (v2.sparse_complex_matrix_value (), v1.sparse_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_matrix, sparse_complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_matrix, sparse_complex_matrix, mx_el_or)
@@ -142,41 +142,41 @@ install_sm_scm_ops (void)
   INSTALL_BINOP (op_mul, octave_sparse_matrix, octave_sparse_complex_matrix,
                  mul);
   INSTALL_BINOP (op_div, octave_sparse_matrix, octave_sparse_complex_matrix,
                  div);
   INSTALL_BINOP (op_pow, octave_sparse_matrix, octave_sparse_complex_matrix,
                  pow);
   INSTALL_BINOP (op_ldiv, octave_sparse_matrix, octave_sparse_complex_matrix,
                  ldiv);
-  INSTALL_BINOP (op_lt, octave_sparse_matrix, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_lt, octave_sparse_matrix, octave_sparse_complex_matrix,
                  lt);
-  INSTALL_BINOP (op_le, octave_sparse_matrix, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_le, octave_sparse_matrix, octave_sparse_complex_matrix,
                  le);
-  INSTALL_BINOP (op_eq, octave_sparse_matrix, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_eq, octave_sparse_matrix, octave_sparse_complex_matrix,
                  eq);
-  INSTALL_BINOP (op_ge, octave_sparse_matrix, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_ge, octave_sparse_matrix, octave_sparse_complex_matrix,
                  ge);
-  INSTALL_BINOP (op_gt, octave_sparse_matrix, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_gt, octave_sparse_matrix, octave_sparse_complex_matrix,
                  gt);
-  INSTALL_BINOP (op_ne, octave_sparse_matrix, octave_sparse_complex_matrix, 
+  INSTALL_BINOP (op_ne, octave_sparse_matrix, octave_sparse_complex_matrix,
                  ne);
-  INSTALL_BINOP (op_el_mul, octave_sparse_matrix, 
+  INSTALL_BINOP (op_el_mul, octave_sparse_matrix,
                  octave_sparse_complex_matrix, el_mul);
-  INSTALL_BINOP (op_el_div, octave_sparse_matrix, 
+  INSTALL_BINOP (op_el_div, octave_sparse_matrix,
                  octave_sparse_complex_matrix, el_div);
-  INSTALL_BINOP (op_el_pow, octave_sparse_matrix, 
+  INSTALL_BINOP (op_el_pow, octave_sparse_matrix,
                  octave_sparse_complex_matrix, el_pow);
-  INSTALL_BINOP (op_el_ldiv, octave_sparse_matrix, 
+  INSTALL_BINOP (op_el_ldiv, octave_sparse_matrix,
                  octave_sparse_complex_matrix, el_ldiv);
-  INSTALL_BINOP (op_el_and, octave_sparse_matrix, 
+  INSTALL_BINOP (op_el_and, octave_sparse_matrix,
                  octave_sparse_complex_matrix, el_and);
-  INSTALL_BINOP (op_el_or, octave_sparse_matrix, 
+  INSTALL_BINOP (op_el_or, octave_sparse_matrix,
                  octave_sparse_complex_matrix, el_or);
 
   INSTALL_CATOP (octave_sparse_matrix, octave_sparse_complex_matrix, sm_scm);
 
-  INSTALL_ASSIGNCONV (octave_sparse_matrix, octave_sparse_complex_matrix, 
+  INSTALL_ASSIGNCONV (octave_sparse_matrix, octave_sparse_complex_matrix,
                       octave_sparse_complex_matrix);
 
-  INSTALL_WIDENOP (octave_sparse_matrix, octave_sparse_complex_matrix, 
+  INSTALL_WIDENOP (octave_sparse_matrix, octave_sparse_complex_matrix,
                    sparse_complex_matrix_conv);
 }
diff --git a/src/OPERATORS/op-sm-sm.cc b/src/OPERATORS/op-sm-sm.cc
--- a/src/OPERATORS/op-sm-sm.cc
+++ b/src/OPERATORS/op-sm-sm.cc
@@ -79,19 +79,19 @@ DEFBINOP (div, sparse_matrix, sparse_mat
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v1.sparse_matrix_value () / d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
-      SparseMatrix ret = xdiv (v1.sparse_matrix_value (), 
+      SparseMatrix ret = xdiv (v1.sparse_matrix_value (),
                                v2.sparse_matrix_value (), typ);
-  
+
       v2.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOPX (pow, sparse_matrix, sparse_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
@@ -110,17 +110,17 @@ DEFBINOP (ldiv, sparse_matrix, sparse_ma
         gripe_divide_by_zero ();
 
       return octave_value (v2.sparse_matrix_value () / d);
     }
   else
     {
       MatrixType typ = v1.matrix_type ();
 
-      SparseMatrix ret = xleftdiv (v1.sparse_matrix_value (), 
+      SparseMatrix ret = xleftdiv (v1.sparse_matrix_value (),
                                    v2.sparse_matrix_value (), typ);
 
       v1.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOP_FN (lt, sparse_matrix, sparse_matrix, mx_el_lt)
@@ -167,30 +167,30 @@ install_sm_sm_ops (void)
   INSTALL_BINOP (op_pow, octave_sparse_matrix, octave_sparse_matrix, pow);
   INSTALL_BINOP (op_ldiv, octave_sparse_matrix, octave_sparse_matrix, ldiv);
   INSTALL_BINOP (op_lt, octave_sparse_matrix, octave_sparse_matrix, lt);
   INSTALL_BINOP (op_le, octave_sparse_matrix, octave_sparse_matrix, le);
   INSTALL_BINOP (op_eq, octave_sparse_matrix, octave_sparse_matrix, eq);
   INSTALL_BINOP (op_ge, octave_sparse_matrix, octave_sparse_matrix, ge);
   INSTALL_BINOP (op_gt, octave_sparse_matrix, octave_sparse_matrix, gt);
   INSTALL_BINOP (op_ne, octave_sparse_matrix, octave_sparse_matrix, ne);
-  INSTALL_BINOP (op_el_mul, octave_sparse_matrix, octave_sparse_matrix, 
+  INSTALL_BINOP (op_el_mul, octave_sparse_matrix, octave_sparse_matrix,
                  el_mul);
-  INSTALL_BINOP (op_el_div, octave_sparse_matrix, octave_sparse_matrix, 
+  INSTALL_BINOP (op_el_div, octave_sparse_matrix, octave_sparse_matrix,
                  el_div);
-  INSTALL_BINOP (op_el_pow, octave_sparse_matrix, octave_sparse_matrix, 
+  INSTALL_BINOP (op_el_pow, octave_sparse_matrix, octave_sparse_matrix,
                  el_pow);
-  INSTALL_BINOP (op_el_ldiv, octave_sparse_matrix, octave_sparse_matrix, 
+  INSTALL_BINOP (op_el_ldiv, octave_sparse_matrix, octave_sparse_matrix,
                  el_ldiv);
-  INSTALL_BINOP (op_el_and, octave_sparse_matrix, octave_sparse_matrix, 
+  INSTALL_BINOP (op_el_and, octave_sparse_matrix, octave_sparse_matrix,
                  el_and);
-  INSTALL_BINOP (op_el_or, octave_sparse_matrix, octave_sparse_matrix, 
+  INSTALL_BINOP (op_el_or, octave_sparse_matrix, octave_sparse_matrix,
                  el_or);
 
   INSTALL_CATOP (octave_sparse_matrix, octave_sparse_matrix, sm_sm);
 
-  INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_matrix, octave_sparse_matrix, 
+  INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_matrix, octave_sparse_matrix,
                     assign);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_matrix, octave_null_matrix, null_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_matrix, octave_null_str, null_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_matrix, octave_null_sq_str, null_assign);
 }
diff --git a/src/OPERATORS/op-str-str.cc b/src/OPERATORS/op-str-str.cc
--- a/src/OPERATORS/op-str-str.cc
+++ b/src/OPERATORS/op-str-str.cc
@@ -104,37 +104,37 @@ install_str_str_ops (void)
 
   INSTALL_UNOP (op_hermitian, octave_char_matrix_str, transpose);
   INSTALL_UNOP (op_hermitian, octave_char_matrix_sq_str, transpose);
 
   INSTALL_BINOP (op_lt, octave_char_matrix_str, octave_char_matrix_str, lt);
   INSTALL_BINOP (op_lt, octave_char_matrix_str, octave_char_matrix_sq_str, lt);
   INSTALL_BINOP (op_lt, octave_char_matrix_sq_str, octave_char_matrix_str, lt);
   INSTALL_BINOP (op_lt, octave_char_matrix_sq_str, octave_char_matrix_sq_str, lt);
-  
+
   INSTALL_BINOP (op_le, octave_char_matrix_str, octave_char_matrix_str, le);
   INSTALL_BINOP (op_le, octave_char_matrix_str, octave_char_matrix_sq_str, le);
   INSTALL_BINOP (op_le, octave_char_matrix_sq_str, octave_char_matrix_str, le);
   INSTALL_BINOP (op_le, octave_char_matrix_sq_str, octave_char_matrix_sq_str, le);
-  
+
   INSTALL_BINOP (op_eq, octave_char_matrix_str, octave_char_matrix_str, eq);
   INSTALL_BINOP (op_eq, octave_char_matrix_str, octave_char_matrix_sq_str, eq);
   INSTALL_BINOP (op_eq, octave_char_matrix_sq_str, octave_char_matrix_str, eq);
   INSTALL_BINOP (op_eq, octave_char_matrix_sq_str, octave_char_matrix_sq_str, eq);
-  
+
   INSTALL_BINOP (op_ge, octave_char_matrix_str, octave_char_matrix_str, ge);
   INSTALL_BINOP (op_ge, octave_char_matrix_str, octave_char_matrix_sq_str, ge);
   INSTALL_BINOP (op_ge, octave_char_matrix_sq_str, octave_char_matrix_str, ge);
   INSTALL_BINOP (op_ge, octave_char_matrix_sq_str, octave_char_matrix_sq_str, ge);
-  
+
   INSTALL_BINOP (op_gt, octave_char_matrix_str, octave_char_matrix_str, gt);
   INSTALL_BINOP (op_gt, octave_char_matrix_str, octave_char_matrix_sq_str, gt);
   INSTALL_BINOP (op_gt, octave_char_matrix_sq_str, octave_char_matrix_str, gt);
   INSTALL_BINOP (op_gt, octave_char_matrix_sq_str, octave_char_matrix_sq_str, gt);
-  
+
   INSTALL_BINOP (op_ne, octave_char_matrix_str, octave_char_matrix_str, ne);
   INSTALL_BINOP (op_ne, octave_char_matrix_str, octave_char_matrix_sq_str, ne);
   INSTALL_BINOP (op_ne, octave_char_matrix_sq_str, octave_char_matrix_str, ne);
   INSTALL_BINOP (op_ne, octave_char_matrix_sq_str, octave_char_matrix_sq_str, ne);
 
   INSTALL_CATOP (octave_char_matrix_str, octave_char_matrix_str, str_str);
   INSTALL_CATOP (octave_char_matrix_str, octave_char_matrix_sq_str, str_str);
   INSTALL_CATOP (octave_char_matrix_sq_str, octave_char_matrix_str, str_str);
diff --git a/src/OPERATORS/op-ui64-ui64.cc b/src/OPERATORS/op-ui64-ui64.cc
--- a/src/OPERATORS/op-ui64-ui64.cc
+++ b/src/OPERATORS/op-ui64-ui64.cc
@@ -109,17 +109,17 @@ OCTAVE_MIXED_INT_CMP_OPS (uint64, uint16
 OCTAVE_MIXED_INT_CMP_OPS (uint64, int32)
 OCTAVE_MIXED_INT_CMP_OPS (uint64, uint32)
 OCTAVE_MIXED_INT_CMP_OPS (uint64, int64)
 
 void
 install_ui64_ui64_ops (void)
 {
   OCTAVE_INSTALL_INT_OPS (uint64);
-  
+
   OCTAVE_INSTALL_MS_INT_ASSIGN_OPS (mi8, uint64_, int8_);
   OCTAVE_INSTALL_MS_INT_ASSIGN_OPS (mui8, uint64_, uint8_);
   OCTAVE_INSTALL_MS_INT_ASSIGN_OPS (mi16, uint64_, int16_);
   OCTAVE_INSTALL_MS_INT_ASSIGN_OPS (mui16, uint64_, uint16_);
   OCTAVE_INSTALL_MS_INT_ASSIGN_OPS (mi32, uint64_, int32_);
   OCTAVE_INSTALL_MS_INT_ASSIGN_OPS (mui32, uint64_, uint32_);
   OCTAVE_INSTALL_MS_INT_ASSIGN_OPS (mi64, uint64_, int64_);
 
diff --git a/src/bitfcns.cc b/src/bitfcns.cc
--- a/src/bitfcns.cc
+++ b/src/bitfcns.cc
@@ -439,33 +439,33 @@ bitshift (10, [-2, -1, 0, 1, 2])\n\
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 2 || nargin == 3)
     {
       int nbits = 64;
-      
+
       NDArray n = args(1).array_value ();
 
       if (error_state)
         error ("bitshift: expecting integer as second argument");
       else
         {
           if (nargin == 3)
             {
               // FIXME -- for compatibility, we should accept an array
               // or a scalar as the third argument.
               if (args(2).numel () > 1)
                 error ("bitshift: expecting scalar integer as third argument");
               else
                 {
                   nbits = args(2).int_value ();
-          
+
                   if (error_state)
                     error ("bitshift: expecting integer as third argument");
                   else if (nbits < 0)
                     error ("bitshift: number of bits to mask must be positive");
                 }
             }
         }
 
diff --git a/src/c-file-ptr-stream.cc b/src/c-file-ptr-stream.cc
--- a/src/c-file-ptr-stream.cc
+++ b/src/c-file-ptr-stream.cc
@@ -87,17 +87,17 @@ c_file_ptr_buf::underflow_common (bool b
     return EOF;
 #endif
 }
 
 c_file_ptr_buf::int_type
 c_file_ptr_buf::pbackfail (int_type c)
 {
 #if defined (CXX_ISO_COMPLIANT_LIBRARY)
-  return (c != traits_type::eof () && f) ? ungetc (c, f) : 
+  return (c != traits_type::eof () && f) ? ungetc (c, f) :
     traits_type::not_eof (c);
 #else
   return (c != EOF && f) ? ungetc (c, f) : EOF;
 #endif
 }
 
 std::streamsize
 c_file_ptr_buf::xsputn (const char* s, std::streamsize n)
@@ -144,17 +144,17 @@ c_file_ptr_buf::seekoff (std::streamoff 
 #endif
   return -1;
 }
 
 std::streampos
 c_file_ptr_buf::seekpos (std::streampos /* offset */, std::ios::openmode)
 {
   // FIXME
-#if 0  
+#if 0
   if (f)
     {
       fseek (f, offset, SEEK_SET);
 
       return ftell (f);
     }
   else
     return 0;
@@ -247,17 +247,17 @@ c_zfile_ptr_buf::underflow_common (bool 
     return EOF;
 #endif
 }
 
 c_zfile_ptr_buf::int_type
 c_zfile_ptr_buf::pbackfail (int_type c)
 {
 #if defined (CXX_ISO_COMPLIANT_LIBRARY)
-  return (c != traits_type::eof () && f) ? gzungetc (c, f) : 
+  return (c != traits_type::eof () && f) ? gzungetc (c, f) :
     traits_type::not_eof (c);
 #else
   return (c != EOF && f) ? gzungetc (c, f) : EOF;
 #endif
 }
 
 std::streamsize
 c_zfile_ptr_buf::xsputn (const char* s, std::streamsize n)
@@ -295,17 +295,17 @@ c_zfile_ptr_buf::seekoff (std::streamoff
 #endif
   return -1;
 }
 
 std::streampos
 c_zfile_ptr_buf::seekpos (std::streampos /* offset */, std::ios::openmode)
 {
   // FIXME
-#if 0  
+#if 0
   if (f)
     {
       gzseek (f, offset, SEEK_SET);
 
       return gztell (f);
     }
   else
     return 0;
diff --git a/src/c-file-ptr-stream.h b/src/c-file-ptr-stream.h
--- a/src/c-file-ptr-stream.h
+++ b/src/c-file-ptr-stream.h
@@ -57,17 +57,17 @@ public:
   int_type pbackfail (int_type);
 
   std::streamsize xsputn (const char*, std::streamsize);
 
   std::streamsize xsgetn (char *, std::streamsize);
 
   std::streampos seekoff (std::streamoff, std::ios::seekdir,
                           std::ios::openmode = std::ios::in | std::ios::out);
-  
+
   std::streampos seekpos (std::streampos,
                           std::ios::openmode = std::ios::in | std::ios::out);
 
   int sync (void);
 
   int flush (void);
 
   int buf_close (void);
@@ -164,17 +164,17 @@ public:
   int_type pbackfail (int_type);
 
   std::streamsize xsputn (const char*, std::streamsize);
 
   std::streamsize xsgetn (char *, std::streamsize);
 
   std::streampos seekoff (std::streamoff, std::ios::seekdir,
                           std::ios::openmode = std::ios::in | std::ios::out);
-  
+
   std::streampos seekpos (std::streampos,
                           std::ios::openmode = std::ios::in | std::ios::out);
 
   int sync (void);
 
   int flush (void);
 
   int buf_close (void);
diff --git a/src/comment-list.h b/src/comment-list.h
--- a/src/comment-list.h
+++ b/src/comment-list.h
@@ -99,17 +99,17 @@ public:
 
 class
 octave_comment_buffer
 {
 public:
 
   octave_comment_buffer (void)
     : comment_list (new octave_comment_list ()) { }
-  
+
   static bool instance_ok (void);
 
   static void append
     (const std::string& s,
      octave_comment_elt::comment_type t = octave_comment_elt::unknown);
 
   static octave_comment_list *get_comment (void);
 
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -226,17 +226,17 @@ and orientation.\n\
             }
         }
       else
         {
           bool a0_scalar = args(0).is_scalar_type ();
           bool a1_scalar = args(1).is_scalar_type ();
           if (a0_scalar && a1_scalar)
             retval = atan2 (args(0).scalar_value (), args(1).scalar_value ());
-          else if ((a0_scalar || args(0).is_sparse_type ()) 
+          else if ((a0_scalar || args(0).is_sparse_type ())
                    && (a1_scalar || args(1).is_sparse_type ()))
             {
               SparseMatrix m0 = args(0).sparse_matrix_value ();
               SparseMatrix m1 = args(1).sparse_matrix_value ();
               retval = binmap<double> (m0, m1, ::atan2, "atan2");
             }
           else
             {
@@ -310,17 +310,17 @@ do_hypot (const octave_value& x, const o
             }
         }
       else
         {
           bool a0_scalar = arg0.is_scalar_type ();
           bool a1_scalar = arg1.is_scalar_type ();
           if (a0_scalar && a1_scalar)
             retval = hypot (arg0.scalar_value (), arg1.scalar_value ());
-          else if ((a0_scalar || arg0.is_sparse_type ()) 
+          else if ((a0_scalar || arg0.is_sparse_type ())
                    && (a1_scalar || arg1.is_sparse_type ()))
             {
               SparseMatrix m0 = arg0.sparse_matrix_value ();
               SparseMatrix m1 = arg1.sparse_matrix_value ();
               retval = binmap<double> (m0, m1, ::hypot, "hypot");
             }
           else
             {
@@ -379,17 +379,17 @@ the arguments are accumulated from left 
 %!assert (size (hypot (rand (2, 3, 4), 1)), [2, 3, 4])
 %!assert (size (hypot (1, rand (2, 3, 4))), [2, 3, 4])
 %!assert (size (hypot (1, 2)), [1, 1])
 %!assert (hypot (1:10, 1:10), sqrt(2) * [1:10], 16*eps)
 %!assert (hypot (single(1:10), single(1:10)), single(sqrt(2) * [1:10]));
 */
 
 template<typename T, typename ET>
-void 
+void
 map_2_xlog2 (const Array<T>& x, Array<T>& f, Array<ET>& e)
 {
   f = Array<T>(x.dims ());
   e = Array<ET>(x.dims ());
   for (octave_idx_type i = 0; i < x.numel (); i++)
     {
       int exp;
       f.xelem (i) = xlog2 (x(i), exp);
@@ -555,17 +555,17 @@ agree, or if either of the arguments is 
                 MAKE_INT_BRANCH (uint32);
                 MAKE_INT_BRANCH (uint64);
 #undef MAKE_INT_BRANCH
                 default:
                   panic_impossible ();
                 }
             }
           else
-            error ("rem: cannot combine %s and %d", 
+            error ("rem: cannot combine %s and %d",
                    args(0).class_name ().c_str (), args(1).class_name ().c_str ());
         }
       else if (args(0).is_single_type () || args(1).is_single_type ())
         {
           if (args(0).is_scalar_type () && args(1).is_scalar_type ())
             retval = xrem (args(0).float_value (), args(1).float_value ());
           else
             {
@@ -575,17 +575,17 @@ agree, or if either of the arguments is 
             }
         }
       else
         {
           bool a0_scalar = args(0).is_scalar_type ();
           bool a1_scalar = args(1).is_scalar_type ();
           if (a0_scalar && a1_scalar)
             retval = xrem (args(0).scalar_value (), args(1).scalar_value ());
-          else if ((a0_scalar || args(0).is_sparse_type ()) 
+          else if ((a0_scalar || args(0).is_sparse_type ())
                    && (a1_scalar || args(1).is_sparse_type ()))
             {
               SparseMatrix m0 = args(0).sparse_matrix_value ();
               SparseMatrix m1 = args(1).sparse_matrix_value ();
               retval = binmap<double> (m0, m1, xrem, "rem");
             }
           else
             {
@@ -688,17 +688,17 @@ either of the arguments is complex.\n\
                 MAKE_INT_BRANCH (uint32);
                 MAKE_INT_BRANCH (uint64);
 #undef MAKE_INT_BRANCH
                 default:
                   panic_impossible ();
                 }
             }
           else
-            error ("mod: cannot combine %s and %d", 
+            error ("mod: cannot combine %s and %d",
                    args(0).class_name ().c_str (), args(1).class_name ().c_str ());
         }
       else if (args(0).is_single_type () || args(1).is_single_type ())
         {
           if (args(0).is_scalar_type () && args(1).is_scalar_type ())
             retval = xmod (args(0).float_value (), args(1).float_value ());
           else
             {
@@ -708,17 +708,17 @@ either of the arguments is complex.\n\
             }
         }
       else
         {
           bool a0_scalar = args(0).is_scalar_type ();
           bool a1_scalar = args(1).is_scalar_type ();
           if (a0_scalar && a1_scalar)
             retval = xmod (args(0).scalar_value (), args(1).scalar_value ());
-          else if ((a0_scalar || args(0).is_sparse_type ()) 
+          else if ((a0_scalar || args(0).is_sparse_type ())
                    && (a1_scalar || args(1).is_sparse_type ()))
             {
               SparseMatrix m0 = args(0).sparse_matrix_value ();
               SparseMatrix m1 = args(1).sparse_matrix_value ();
               retval = binmap<double> (m0, m1, xmod, "mod");
             }
           else
             {
@@ -750,17 +750,17 @@ either of the arguments is complex.\n\
 %!assert (mod(5, 0), 5);
 %!assert (mod(-5, 0), -5);
 %!assert (mod([-5, 5, 0], [3, 0, 3]), [1, 5, 0]);
 %!assert (mod([-5; 5; 0], [3; 0; 3]), [1; 5; 0]);
 %!assert (mod([-5, 5; 0, 3], [3, 0 ; 3, 1]), [1, 5 ; 0, 0]);
 %!assert (mod([-5, 5; 0, 3], [0, 0 ; 0, 0]), [-5, 5; 0, 3]);
 
 ## mixed scalar/matrix tests
-%!assert (mod([-5, 5; 0, 3], 0), [-5, 5; 0, 3]); 
+%!assert (mod([-5, 5; 0, 3], 0), [-5, 5; 0, 3]);
 %!assert (mod([-5, 5; 0, 3], 3), [1, 2; 0, 0]);
 %!assert (mod(-5,[0,0; 0,0]), [-5, -5; -5, -5]);
 %!assert (mod(-5,[3,0; 3,1]), [1, -5; 1, 0]);
 %!assert (mod(-5,[3,2; 3,1]), [1, 1; 1, 0]);
 
 ## integer types
 %!assert (mod(uint8(5),uint8(4)),uint8(1))
 %!assert (mod(uint8([1:5]),uint8(4)),uint8([1,2,3,0,1]))
@@ -1251,17 +1251,17 @@ Given a matrix argument, instead of a ve
 
   if (nargin == 1 && args(0).is_defined ())
     retval = args(0).diag();
   else if (nargin == 2 && args(0).is_defined () && args(1).is_defined ())
     {
       octave_idx_type k = args(1).int_value ();
 
       if (error_state)
-        error ("diag: invalid second argument");      
+        error ("diag: invalid second argument");
       else
         retval = args(0).diag(k);
     }
   else if (nargin == 3)
     {
       octave_value arg0 = args(0);
       if (arg0.ndims () == 2 && (args(0).rows () == 1 || args(0).columns () == 1))
         {
@@ -1381,17 +1381,17 @@ all_scalar_1x1 (const octave_value_list&
   for (int i = 0; i < n_args; i++)
     if (args(i).numel () != 1)
       return false;
 
   return true;
 }
 
 template <class TYPE, class T>
-static void 
+static void
 single_type_concat (Array<T>& result,
                     const octave_value_list& args,
                     int dim)
 {
   int n_args = args.length ();
   if (! (equal_types<T, char>::value
          || equal_types<T, octave_value>::value)
       && all_scalar_1x1 (args))
@@ -1425,17 +1425,17 @@ single_type_concat (Array<T>& result,
         }
 
       if (! error_state)
         result = Array<T>::cat (dim, n_args, array_list);
     }
 }
 
 template <class TYPE, class T>
-static void 
+static void
 single_type_concat (Sparse<T>& result,
                     const octave_value_list& args,
                     int dim)
 {
   int n_args = args.length ();
   OCTAVE_LOCAL_BUFFER (Sparse<T>, sparse_list, n_args);
 
   for (int j = 0; j < n_args && ! error_state; j++)
@@ -1446,28 +1446,28 @@ single_type_concat (Sparse<T>& result,
     }
 
   if (! error_state)
     result = Sparse<T>::cat (dim, n_args, sparse_list);
 }
 
 // Dispatcher.
 template<class TYPE>
-static TYPE 
+static TYPE
 do_single_type_concat (const octave_value_list& args, int dim)
 {
   TYPE result;
 
   single_type_concat<TYPE, typename TYPE::element_type> (result, args, dim);
 
   return result;
 }
 
 template<class MAP>
-static void 
+static void
 single_type_concat_map (octave_map& result,
                         const octave_value_list& args,
                         int dim)
 {
   int n_args = args.length ();
   OCTAVE_LOCAL_BUFFER (MAP, map_list, n_args);
 
   for (int j = 0; j < n_args && ! error_state; j++)
@@ -1494,17 +1494,17 @@ do_single_type_concat_map (const octave_
   return result;
 }
 
 static octave_value
 do_cat (const octave_value_list& args, int dim, std::string fname)
 {
   octave_value retval;
 
-  int n_args = args.length (); 
+  int n_args = args.length ();
 
   if (n_args == 0)
     retval = Matrix ();
   else if (n_args == 1)
     retval = args(0);
   else if (n_args > 1)
     {
 
@@ -1512,33 +1512,33 @@ do_cat (const octave_value_list& args, i
 
       bool all_sq_strings_p = args(0).is_sq_string ();
       bool all_dq_strings_p = args(0).is_dq_string ();
       bool all_real_p = args(0).is_real_type ();
       bool any_sparse_p = args(0).is_sparse_type();
 
       for (int i = 1; i < args.length (); i++)
         {
-          result_type = 
+          result_type =
             get_concat_class (result_type, args(i).class_name ());
 
           if (all_sq_strings_p && ! args(i).is_sq_string ())
             all_sq_strings_p = false;
           if (all_dq_strings_p && ! args(i).is_dq_string ())
             all_dq_strings_p = false;
           if (all_real_p && ! args(i).is_real_type ())
             all_real_p = false;
           if (!any_sparse_p && args(i).is_sparse_type ())
             any_sparse_p = true;
         }
 
       if (result_type == "double")
         {
           if (any_sparse_p)
-            {           
+            {
               if (all_real_p)
                 retval = do_single_type_concat<SparseMatrix> (args, dim);
               else
                 retval = do_single_type_concat<SparseComplexMatrix> (args, dim);
             }
           else
             {
               if (all_real_p)
@@ -1603,32 +1603,32 @@ do_cat (const octave_value_list& args, i
               concat_rule = &dim_vector::hvcat;
               dim = -dim - 1;
             }
 
           for (int i = 1; i < args.length (); i++)
             {
               if (! (dv.*concat_rule) (args(i).dims (), dim))
                 {
-                  // Dimensions do not match. 
+                  // Dimensions do not match.
                   error ("cat: dimension mismatch");
                   return retval;
                 }
             }
 
           // The lines below might seem crazy, since we take a copy
           // of the first argument, resize it to be empty and then resize
           // it to be full. This is done since it means that there is no
           // recopying of data, as would happen if we used a single resize.
-          // It should be noted that resize operation is also significantly 
+          // It should be noted that resize operation is also significantly
           // slower than the do_cat_op function, so it makes sense to have
           // an empty matrix and copy all data.
           //
           // We might also start with a empty octave_value using
-          //   tmp = octave_value_typeinfo::lookup_type 
+          //   tmp = octave_value_typeinfo::lookup_type
           //                                (args(1).type_name());
           // and then directly resize. However, for some types there might
           // be some additional setup needed, and so this should be avoided.
 
           octave_value tmp = args (0);
           tmp = tmp.resize (dim_vector (0,0)).resize (dv);
 
           if (error_state)
@@ -1651,17 +1651,17 @@ do_cat (const octave_value_list& args, i
 
               if (dim >= dv_len)
                 {
                   if (j > 1)
                     error ("%s: indexing error", fname.c_str ());
                   break;
                 }
               else
-                ra_idx (dim) += (dim < dv_tmp.length () ? 
+                ra_idx (dim) += (dim < dv_tmp.length () ?
                                  dv_tmp (dim) : 1);
             }
           retval = tmp;
         }
     }
   else
     print_usage ();
 
@@ -1769,17 +1769,17 @@ cat (4, ones(2, 2), zeros (2, 2))\n\
 %! assert (cat (1, cast (1, t1), cast (2, t2)), cast ([1; 2], tr));
 %! assert (cat (1, cast (1, t1), cast ([2; 3], t2)), cast ([1; 2; 3], tr));
 %! assert (cat (1, cast ([1; 2], t1), cast (3, t2)), cast ([1; 2; 3], tr));
 %! assert (cat (1, cast ([1; 2], t1), cast ([3; 4], t2)), cast ([1; 2; 3; 4], tr));
 %! assert (cat (2, cast (1, t1), cast (2, t2)), cast ([1, 2], tr));
 %! assert (cat (2, cast (1, t1), cast ([2, 3], t2)), cast ([1, 2, 3], tr));
 %! assert (cat (2, cast ([1, 2], t1), cast (3, t2)), cast ([1, 2, 3], tr));
 %! assert (cat (2, cast ([1, 2], t1), cast ([3, 4], t2)), cast ([1, 2, 3, 4], tr));
-%! 
+%!
 %! assert ([cast(1, t1); cast(2, t2)], cast ([1; 2], tr));
 %! assert ([cast(1, t1); cast([2; 3], t2)], cast ([1; 2; 3], tr));
 %! assert ([cast([1; 2], t1); cast(3, t2)], cast ([1; 2; 3], tr));
 %! assert ([cast([1; 2], t1); cast([3; 4], t2)], cast ([1; 2; 3; 4], tr));
 %! assert ([cast(1, t1), cast(2, t2)], cast ([1, 2], tr));
 %! assert ([cast(1, t1), cast([2, 3], t2)], cast ([1, 2, 3], tr));
 %! assert ([cast([1, 2], t1), cast(3, t2)], cast ([1, 2, 3], tr));
 %! assert ([cast([1, 2], t1), cast([3, 4], t2)], cast ([1, 2, 3, 4], tr));
@@ -1788,17 +1788,17 @@ cat (4, ones(2, 2), zeros (2, 2))\n\
 %!   assert (cat (1, cast (1i, t1), cast (2, t2)), cast ([1i; 2], tr));
 %!   assert (cat (1, cast (1i, t1), cast ([2; 3], t2)), cast ([1i; 2; 3], tr));
 %!   assert (cat (1, cast ([1i; 2], t1), cast (3, t2)), cast ([1i; 2; 3], tr));
 %!   assert (cat (1, cast ([1i; 2], t1), cast ([3; 4], t2)), cast ([1i; 2; 3; 4], tr));
 %!   assert (cat (2, cast (1i, t1), cast (2, t2)), cast ([1i, 2], tr));
 %!   assert (cat (2, cast (1i, t1), cast ([2, 3], t2)), cast ([1i, 2, 3], tr));
 %!   assert (cat (2, cast ([1i, 2], t1), cast (3, t2)), cast ([1i, 2, 3], tr));
 %!   assert (cat (2, cast ([1i, 2], t1), cast ([3, 4], t2)), cast ([1i, 2, 3, 4], tr));
-%! 
+%!
 %!   assert ([cast(1i, t1); cast(2, t2)], cast ([1i; 2], tr));
 %!   assert ([cast(1i, t1); cast([2; 3], t2)], cast ([1i; 2; 3], tr));
 %!   assert ([cast([1i; 2], t1); cast(3, t2)], cast ([1i; 2; 3], tr));
 %!   assert ([cast([1i; 2], t1); cast([3; 4], t2)], cast ([1i; 2; 3; 4], tr));
 %!   assert ([cast(1i, t1), cast(2, t2)], cast ([1i, 2], tr));
 %!   assert ([cast(1i, t1), cast([2, 3], t2)], cast ([1i, 2, 3], tr));
 %!   assert ([cast([1i, 2], t1), cast(3, t2)], cast ([1i, 2, 3], tr));
 %!   assert ([cast([1i, 2], t1), cast([3, 4], t2)], cast ([1i, 2, 3, 4], tr));
@@ -1806,17 +1806,17 @@ cat (4, ones(2, 2), zeros (2, 2))\n\
 %!   assert (cat (1, cast (1, t1), cast (2i, t2)), cast ([1; 2i], tr));
 %!   assert (cat (1, cast (1, t1), cast ([2i; 3], t2)), cast ([1; 2i; 3], tr));
 %!   assert (cat (1, cast ([1; 2], t1), cast (3i, t2)), cast ([1; 2; 3i], tr));
 %!   assert (cat (1, cast ([1; 2], t1), cast ([3i; 4], t2)), cast ([1; 2; 3i; 4], tr));
 %!   assert (cat (2, cast (1, t1), cast (2i, t2)), cast ([1, 2i], tr));
 %!   assert (cat (2, cast (1, t1), cast ([2i, 3], t2)), cast ([1, 2i, 3], tr));
 %!   assert (cat (2, cast ([1, 2], t1), cast (3i, t2)), cast ([1, 2, 3i], tr));
 %!   assert (cat (2, cast ([1, 2], t1), cast ([3i, 4], t2)), cast ([1, 2, 3i, 4], tr));
-%! 
+%!
 %!   assert ([cast(1, t1); cast(2i, t2)], cast ([1; 2i], tr));
 %!   assert ([cast(1, t1); cast([2i; 3], t2)], cast ([1; 2i; 3], tr));
 %!   assert ([cast([1; 2], t1); cast(3i, t2)], cast ([1; 2; 3i], tr));
 %!   assert ([cast([1; 2], t1); cast([3i; 4], t2)], cast ([1; 2; 3i; 4], tr));
 %!   assert ([cast(1, t1), cast(2i, t2)], cast ([1, 2i], tr));
 %!   assert ([cast(1, t1), cast([2i, 3], t2)], cast ([1, 2i, 3], tr));
 %!   assert ([cast([1, 2], t1), cast(3i, t2)], cast ([1, 2, 3i], tr));
 %!   assert ([cast([1, 2], t1), cast([3i, 4], t2)], cast ([1, 2, 3i, 4], tr));
@@ -1824,17 +1824,17 @@ cat (4, ones(2, 2), zeros (2, 2))\n\
 %!   assert (cat (1, cast (1i, t1), cast (2i, t2)), cast ([1i; 2i], tr));
 %!   assert (cat (1, cast (1i, t1), cast ([2i; 3], t2)), cast ([1i; 2i; 3], tr));
 %!   assert (cat (1, cast ([1i; 2], t1), cast (3i, t2)), cast ([1i; 2; 3i], tr));
 %!   assert (cat (1, cast ([1i; 2], t1), cast ([3i; 4], t2)), cast ([1i; 2; 3i; 4], tr));
 %!   assert (cat (2, cast (1i, t1), cast (2i, t2)), cast ([1i, 2i], tr));
 %!   assert (cat (2, cast (1i, t1), cast ([2i, 3], t2)), cast ([1i, 2i, 3], tr));
 %!   assert (cat (2, cast ([1i, 2], t1), cast (3i, t2)), cast ([1i, 2, 3i], tr));
 %!   assert (cat (2, cast ([1i, 2], t1), cast ([3i, 4], t2)), cast ([1i, 2, 3i, 4], tr));
-%! 
+%!
 %!   assert ([cast(1i, t1); cast(2i, t2)], cast ([1i; 2i], tr));
 %!   assert ([cast(1i, t1); cast([2i; 3], t2)], cast ([1i; 2i; 3], tr));
 %!   assert ([cast([1i; 2], t1); cast(3i, t2)], cast ([1i; 2; 3i], tr));
 %!   assert ([cast([1i; 2], t1); cast([3i; 4], t2)], cast ([1i; 2; 3i; 4], tr));
 %!   assert ([cast(1i, t1), cast(2i, t2)], cast ([1i, 2i], tr));
 %!   assert ([cast(1i, t1), cast([2i, 3], t2)], cast ([1i, 2i, 3], tr));
 %!   assert ([cast([1i, 2], t1), cast(3i, t2)], cast ([1i, 2, 3i], tr));
 %!   assert ([cast([1i, 2], t1), cast([3i, 4], t2)], cast ([1i, 2, 3i, 4], tr));
@@ -2108,17 +2108,17 @@ returns the number of columns in the giv
       else
         {
           const dim_vector dv = args(0).dims ();
 
           if (nd > 0)
             {
               if (nd <= dv.length ())
                 retval(0) = dv(nd-1);
-              else 
+              else
                 retval(0) = 1;
             }
           else
             error ("size: requested dimension (= %d) out of range", nd);
         }
     }
   else
     print_usage ();
@@ -2683,20 +2683,20 @@ complex ([1, 2], [3, 4])\n\
                     {
                       result = SparseComplexMatrix (im_val.dims (), re_val (0));
                       octave_idx_type nr = im_val.rows ();
                       octave_idx_type nc = im_val.cols ();
 
                       for (octave_idx_type j = 0; j < nc; j++)
                         {
                           octave_idx_type off = j * nr;
-                          for (octave_idx_type i = im_val.cidx(j); 
+                          for (octave_idx_type i = im_val.cidx(j);
                                i < im_val.cidx(j + 1); i++)
-                            result.data (im_val.ridx(i) + off) =  
-                              result.data (im_val.ridx(i) + off) + 
+                            result.data (im_val.ridx(i) + off) =
+                              result.data (im_val.ridx(i) + off) +
                               Complex (0, im_val.data (i));
                         }
                     }
                   retval = octave_value (new octave_sparse_complex_matrix (result));
                 }
               else if (im.numel () == 1)
                 {
                   SparseComplexMatrix result;
@@ -2706,30 +2706,30 @@ complex ([1, 2], [3, 4])\n\
                     {
                       result = SparseComplexMatrix (re_val.rows(), re_val.cols(), Complex(0, im_val (0)));
                       octave_idx_type nr = re_val.rows ();
                       octave_idx_type nc = re_val.cols ();
 
                       for (octave_idx_type j = 0; j < nc; j++)
                         {
                           octave_idx_type off = j * nr;
-                          for (octave_idx_type i = re_val.cidx(j); 
+                          for (octave_idx_type i = re_val.cidx(j);
                                i < re_val.cidx(j + 1); i++)
-                            result.data (re_val.ridx(i) + off) =  
-                              result.data (re_val.ridx(i) + off) + 
+                            result.data (re_val.ridx(i) + off) =
+                              result.data (re_val.ridx(i) + off) +
                               re_val.data (i);
                         }
                     }
                   retval = octave_value (new octave_sparse_complex_matrix (result));
                 }
               else
                 {
                   if (re_val.dims () == im_val.dims ())
                     {
-                      SparseComplexMatrix result = SparseComplexMatrix(re_val) 
+                      SparseComplexMatrix result = SparseComplexMatrix(re_val)
                         + Complex(0, 1) * SparseComplexMatrix (im_val);
                       retval = octave_value (new octave_sparse_complex_matrix (result));
                     }
                   else
                     error ("complex: dimension mismatch");
                 }
             }
         }
@@ -3003,17 +3003,17 @@ fill_matrix (const octave_value_list& ar
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   oct_data_conv::data_type dt = oct_data_conv::dt_double;
 
   dim_vector dims (1, 1);
-  
+
   if (nargin > 0 && args(nargin-1).is_string ())
     {
       std::string nm = args(nargin-1).string_value ();
       nargin--;
 
       dt = oct_data_conv::string_to_data_type (nm);
 
       if (error_state)
@@ -3119,27 +3119,27 @@ fill_matrix (const octave_value_list& ar
             }
         }
     }
 
   return retval;
 }
 
 static octave_value
-fill_matrix (const octave_value_list& args, double val, float fval, 
+fill_matrix (const octave_value_list& args, double val, float fval,
              const char *fcn)
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   oct_data_conv::data_type dt = oct_data_conv::dt_double;
 
   dim_vector dims (1, 1);
-  
+
   if (nargin > 0 && args(nargin-1).is_string ())
     {
       std::string nm = args(nargin-1).string_value ();
       nargin--;
 
       dt = oct_data_conv::string_to_data_type (nm);
 
       if (error_state)
@@ -3209,17 +3209,17 @@ fill_matrix (const octave_value_list& ar
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   oct_data_conv::data_type dt = oct_data_conv::dt_double;
 
   dim_vector dims (1, 1);
-  
+
   if (nargin > 0 && args(nargin-1).is_string ())
     {
       std::string nm = args(nargin-1).string_value ();
       nargin--;
 
       dt = oct_data_conv::string_to_data_type (nm);
 
       if (error_state)
@@ -3290,17 +3290,17 @@ fill_matrix (const octave_value_list& ar
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   oct_data_conv::data_type dt = oct_data_conv::dt_double;
 
   dim_vector dims (1, 1);
-  
+
   if (nargin > 0 && args(nargin-1).is_string ())
     {
       std::string nm = args(nargin-1).string_value ();
       nargin--;
 
       dt = oct_data_conv::string_to_data_type (nm);
 
       if (error_state)
@@ -3368,17 +3368,17 @@ fill_matrix (const octave_value_list& ar
 static octave_value
 fill_matrix (const octave_value_list& args, bool val, const char *fcn)
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   dim_vector dims (1, 1);
-  
+
   switch (nargin)
     {
     case 0:
       break;
 
     case 1:
       get_dimensions (args(0), fcn, dims);
       break;
@@ -3537,17 +3537,17 @@ When called with a single argument, retu
 specified.  When called with more than one scalar argument the first two\n\
 arguments are taken as the number of rows and columns and any further\n\
 arguments specify additional matrix dimensions.\n\
 The optional argument @var{class} specifies the return type and may be\n\
 either \"double\" or \"single\".\n\
 @seealso{isinf}\n\
 @end deftypefn")
 {
-  return fill_matrix (args, lo_ieee_inf_value (), 
+  return fill_matrix (args, lo_ieee_inf_value (),
                       lo_ieee_float_inf_value (), "Inf");
 }
 
 DEFALIAS (inf, Inf);
 
 /*
 
 %!assert(inf (3), [Inf, Inf, Inf; Inf, Inf, Inf; Inf, Inf, Inf]);
@@ -3595,23 +3595,23 @@ When called with a single argument, retu
 specified.  When called with more than one scalar argument the first two\n\
 arguments are taken as the number of rows and columns and any further\n\
 arguments specify additional matrix dimensions.\n\
 The optional argument @var{class} specifies the return type and may be\n\
 either \"double\" or \"single\".\n\
 @seealso{isnan}\n\
 @end deftypefn")
 {
-  return fill_matrix (args, lo_ieee_nan_value (), 
+  return fill_matrix (args, lo_ieee_nan_value (),
                       lo_ieee_float_nan_value (), "NaN");
 }
 
 DEFALIAS (nan, NaN);
 
-/* 
+/*
 %!assert(NaN (3), [NaN, NaN, NaN; NaN, NaN, NaN; NaN, NaN, NaN]);
 %!assert(NaN (2, 3), [NaN, NaN, NaN; NaN, NaN, NaN]);
 %!assert(NaN (3, 2), [NaN, NaN; NaN, NaN; NaN, NaN]);
 %!assert(size (NaN (3, 4, 5)),  [3, 4, 5]);
 
 %!assert(NaN (3,'single'), single([NaN, NaN, NaN; NaN, NaN, NaN; NaN, NaN, NaN]));
 %!assert(NaN (2, 3,'single'), single([NaN, NaN, NaN; NaN, NaN, NaN]));
 %!assert(NaN (3, 2,'single'), single([NaN, NaN; NaN, NaN; NaN, NaN]));
@@ -3697,54 +3697,54 @@ either \"double\" or \"single\".\n\
       if (args(0).is_single_type ())
         {
           float val = args(0).float_value ();
 
           if (! error_state)
             {
               val  = ::fabsf(val);
               if (xisnan (val) || xisinf (val))
-                retval = fill_matrix (octave_value ("single"), 
-                                      lo_ieee_nan_value (), 
+                retval = fill_matrix (octave_value ("single"),
+                                      lo_ieee_nan_value (),
                                       lo_ieee_float_nan_value (), "eps");
               else if (val < FLT_MIN)
-                retval = fill_matrix (octave_value ("single"), 0e0, 
+                retval = fill_matrix (octave_value ("single"), 0e0,
                                       powf (2.0, -149e0), "eps");
               else
                 {
                   int expon;
                   frexpf (val, &expon);
-                  val = std::pow (static_cast <float> (2.0), 
+                  val = std::pow (static_cast <float> (2.0),
                                   static_cast <float> (expon - 24));
-                  retval = fill_matrix (octave_value ("single"), DBL_EPSILON, 
+                  retval = fill_matrix (octave_value ("single"), DBL_EPSILON,
                                         val, "eps");
                 }
             }
         }
       else
         {
           double val = args(0).double_value ();
 
           if (! error_state)
             {
               val  = ::fabs(val);
               if (xisnan (val) || xisinf (val))
-                retval = fill_matrix (octave_value_list (), 
-                                      lo_ieee_nan_value (), 
+                retval = fill_matrix (octave_value_list (),
+                                      lo_ieee_nan_value (),
                                       lo_ieee_float_nan_value (), "eps");
               else if (val < DBL_MIN)
                 retval = fill_matrix (octave_value_list (),
                                       pow (2.0, -1074e0), 0e0, "eps");
               else
                 {
                   int expon;
                   frexp (val, &expon);
-                  val = std::pow (static_cast <double> (2.0), 
+                  val = std::pow (static_cast <double> (2.0),
                                   static_cast <double> (expon - 53));
-                  retval = fill_matrix (octave_value_list (), val, 
+                  retval = fill_matrix (octave_value_list (), val,
                                         FLT_EPSILON, "eps");
                 }
             }
         }
     }
   else
     retval = fill_matrix (args, DBL_EPSILON, FLT_EPSILON, "eps");
 
@@ -3934,17 +3934,17 @@ When called with a single argument, retu
 specified.  When called with more than one scalar argument the first two\n\
 arguments are taken as the number of rows and columns and any further\n\
 arguments specify additional matrix dimensions.\n\
 The optional argument @var{class} specifies the return type and may be\n\
 either \"double\" or \"single\".\n\
 @seealso{isna}\n\
 @end deftypefn")
 {
-  return fill_matrix (args, lo_ieee_na_value (), 
+  return fill_matrix (args, lo_ieee_na_value (),
                       lo_ieee_float_na_value (), "NA");
 }
 
 /*
 
 %!assert(single(NA('double')),NA('single'))
 %!assert(double(NA('single')),NA('double'))
 
@@ -4207,17 +4207,17 @@ with @sc{matlab}.\n\
 %!assert (eye(3,'int8'), int8([1, 0, 0; 0, 1, 0; 0, 0, 1]));
 %!assert (eye(2, 3,'int8'), int8([1, 0, 0; 0, 1, 0]));
 
 %!error <Invalid call to eye.*> eye (1, 2, 3);
 
  */
 
 template <class MT>
-static octave_value 
+static octave_value
 do_linspace (const octave_value& base, const octave_value& limit,
              octave_idx_type n)
 {
   typedef typename MT::column_vector_type CVT;
   typedef typename MT::element_type T;
 
   octave_value retval;
 
@@ -4294,17 +4294,17 @@ fewer than two values are requested.\n\
       octave_value arg_2 = args(1);
 
       if (arg_1.is_single_type () || arg_2.is_single_type ())
         {
           if (arg_1.is_complex_type () || arg_2.is_complex_type ())
             retval = do_linspace<FloatComplexMatrix> (arg_1, arg_2, npoints);
           else
             retval = do_linspace<FloatMatrix> (arg_1, arg_2, npoints);
-            
+
         }
       else
         {
           if (arg_1.is_complex_type () || arg_2.is_complex_type ())
             retval = do_linspace<ComplexMatrix> (arg_1, arg_2, npoints);
           else
             retval = do_linspace<Matrix> (arg_1, arg_2, npoints);
         }
@@ -4475,17 +4475,17 @@ by an empty argument.\n\
           else
             new_dims(i) = new_size(i);
         }
     }
   else if (nargin > 2)
     {
       new_dims = dim_vector::alloc (nargin-1);
       int empty_dim = -1;
-      
+
       for (int i = 1; i < nargin; i++)
         {
           if (args(i).is_empty ())
             {
               if (empty_dim > 0)
                 {
                   error ("reshape: only a single dimension can be unknown");
                   break;
@@ -4515,17 +4515,17 @@ by an empty argument.\n\
           octave_idx_type nel = new_dims.numel ();
 
           if (nel == 0)
             new_dims(empty_dim-1) = 0;
           else
             {
               octave_idx_type a_nel = args(0).numel ();
               octave_idx_type size_empty_dim = a_nel / nel;
-              
+
               if (a_nel != size_empty_dim * nel)
                 error ("reshape: size is not divisible by the product of known dimensions (= %d)", nel);
               else
                 new_dims(empty_dim-1) = size_empty_dim;
             }
         }
     }
   else
@@ -4636,17 +4636,17 @@ Note that for compatibility with @sc{mat
 a minimum of two dimensions and row vectors are left unchanged.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).squeeze ();
   else
-    print_usage ();    
+    print_usage ();
 
   return retval;
 }
 
 DEFUN (full, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{FM} =} full (@var{SM})\n\
  returns a full storage matrix from a sparse, diagonal, permutation matrix\n\
@@ -4654,17 +4654,17 @@ or a range.\n\
 @seealso{sparse}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).full_value ();
   else
-    print_usage ();    
+    print_usage ();
 
   return retval;
 }
 
 // Compute various norms of the vector X.
 
 DEFUN (norm, args, ,
   "-*- texinfo -*-\n\
@@ -5294,17 +5294,17 @@ coarse resolution.)\n\
   octave_time now;
 
   double tmp = now.double_value ();
 
   if (nargout > 0)
     retval = static_cast<octave_uint64> (1e6 * tmp);
   else
     tic_toc_timestamp = tmp;
-      
+
   return retval;
 }
 
 DEFUN (toc, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} toc ()\n\
 See tic.\n\
 @end deftypefn")
@@ -5328,17 +5328,17 @@ See tic.\n\
 
       double tmp = now.double_value () - tic_toc_timestamp;
 
       if (nargout > 0)
         retval = tmp;
       else
         octave_stdout << "Elapsed time is " << tmp << " seconds.\n";
     }
-    
+
   return retval;
 }
 
 DEFUN (cputime, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{total}, @var{user}, @var{system}] =} cputime ();\n\
 Return the CPU time used by your Octave session.  The first output is\n\
 the total time spent executing your process and is equal to the sum of\n\
@@ -5665,17 +5665,17 @@ ordered lists.\n\
 %!assert (sort (sparse ([0, NaN, 1i, 0, -1, 2, Inf]), 2), sparse ([0, 0, 1i, -1, 2, Inf, NaN]))
 %!assert (sort (sparse ([0, NaN, 1i, 0, -1, 2, Inf]), 3), sparse ([0, NaN, 1i, 0, -1, 2, Inf]))
 %!assert (sort (sparse ([0, NaN, 1i, 0, -1, 2, Inf]), "ascend"), sparse ([0, 0, 1i, -1, 2, Inf, NaN]))
 %!assert (sort (sparse ([0, NaN, 1i, 0, -1, 2, Inf]), 2, "ascend"), sparse ([0, 0, 1i, -1, 2, Inf, NaN]))
 %!assert (sort (sparse ([0, NaN, 1i, 0, -1, 2, Inf]), "descend"), sparse ([NaN, Inf, 2, -1, 1i, 0, 0]))
 %!assert (sort (sparse ([0, NaN, 1i, 0, -1, 2, Inf]), 2, "descend"), sparse ([NaN, Inf, 2, -1, 1i, 0, 0]))
 
 %!shared a
-%! a = randn (10, 10); 
+%! a = randn (10, 10);
 %! a (a < 0) = 0;
 %! a = 1i * a;
 %!assert (sort (sparse (a)), sparse (sort (a)))
 %!assert (sort (sparse (a), 1), sparse (sort (a, 1)))
 %!assert (sort (sparse (a), 2), sparse (sort (a, 2)))
 %!test
 %! [v, i] = sort (a);
 %! [vs, is] = sort (sparse (a));
@@ -5845,17 +5845,17 @@ This function does not support sparse ma
             smode = get_sort_mode_option (args(1), "second");
         }
       else
         error ("expecting second argument to be character string");
 
       if (error_state)
         return retval;
     }
-    
+
   octave_value arg = args(0);
 
   if (by_rows)
     {
       if (arg.is_sparse_type ())
         error ("issorted: sparse matrices not yet supported");
       if (arg.ndims () == 2)
         retval = arg.is_sorted_rows (smode) != UNSORTED;
@@ -5987,17 +5987,17 @@ it may be better to use @code{sort}.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 template <class NDT>
-static NDT 
+static NDT
 do_accumarray_sum (const idx_vector& idx, const NDT& vals,
                    octave_idx_type n = -1)
 {
   typedef typename NDT::element_type T;
   if (n < 0)
     n = idx.extent (0);
   else if (idx.extent (n) > n)
     error ("accumarray: index out of range");
@@ -6055,35 +6055,35 @@ Undocumented internal function.\n\
             }
           else
             gripe_wrong_type_arg ("accumarray", vals);
         }
     }
   else
     print_usage ();
 
-  return retval;  
+  return retval;
 }
 
 template <class NDT>
-static NDT 
+static NDT
 do_accumarray_minmax (const idx_vector& idx, const NDT& vals,
                       octave_idx_type n, bool ismin,
                       const typename NDT::element_type& zero_val)
 {
   typedef typename NDT::element_type T;
   if (n < 0)
     n = idx.extent (0);
   else if (idx.extent (n) > n)
     error ("accumarray: index out of range");
 
   NDT retval (dim_vector (n, 1), zero_val);
 
   // Pick minimizer or maximizer.
-  void (MArray<T>::*op) (const idx_vector&, const MArray<T>&) = 
+  void (MArray<T>::*op) (const idx_vector&, const MArray<T>&) =
     ismin ? (&MArray<T>::idx_min) : (&MArray<T>::idx_max);
 
   octave_idx_type l = idx.length (n);
   if (vals.numel () == 1)
     (retval.*op) (idx, NDT (dim_vector (l, 1), vals(0)));
   else if (vals.numel () == l)
     (retval.*op) (idx, vals);
   else
@@ -6149,17 +6149,17 @@ do_accumarray_minmax_fun (const octave_v
             default:
               gripe_wrong_type_arg ("accumarray", vals);
             }
         }
     }
   else
     print_usage ();
 
-  return retval;  
+  return retval;
 }
 
 DEFUN (__accumarray_min__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __accumarray_min__ (@var{idx}, @var{vals}, @var{zero}, @var{n})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
@@ -6171,17 +6171,17 @@ DEFUN (__accumarray_max__, args, ,
 @deftypefn {Built-in Function} {} __accumarray_max__ (@var{idx}, @var{vals}, @var{zero}, @var{n})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   return do_accumarray_minmax_fun (args, false);
 }
 
 template <class NDT>
-static NDT 
+static NDT
 do_accumdim_sum (const idx_vector& idx, const NDT& vals,
                  int dim = -1, octave_idx_type n = -1)
 {
   typedef typename NDT::element_type T;
   if (n < 0)
     n = idx.extent (0);
   else if (idx.extent (n) > n)
     error ("accumarray: index out of range");
@@ -6239,30 +6239,30 @@ Undocumented internal function.\n\
             }
           else
             gripe_wrong_type_arg ("accumdim", vals);
         }
     }
   else
     print_usage ();
 
-  return retval;  
+  return retval;
 }
 
 template <class NDT>
 static NDT
 do_merge (const Array<bool>& mask,
           const NDT& tval, const NDT& fval)
 {
   typedef typename NDT::element_type T;
   dim_vector dv = mask.dims ();
   NDT retval (dv);
 
   bool tscl = tval.numel () == 1, fscl = fval.numel () == 1;
-  
+
   if ((! tscl && tval.dims () != dv)
       || (! fscl && fval.dims () != dv))
     error ("merge: dimensions mismatch");
   else
     {
       T *rv = retval.fortran_vec ();
       octave_idx_type n = retval.numel ();
 
@@ -6393,17 +6393,17 @@ it is first converted to logical.\n\
           MAKE_INT_BRANCH (int32)
           MAKE_INT_BRANCH (int64)
           MAKE_INT_BRANCH (uint8)
           MAKE_INT_BRANCH (uint16)
           MAKE_INT_BRANCH (uint32)
           MAKE_INT_BRANCH (uint64)
 
           else
-            error ("merge: cannot merge %s with %s with array mask", 
+            error ("merge: cannot merge %s with %s with array mask",
                    tval.class_name ().c_str (),
                    fval.class_name ().c_str ());
         }
     }
   else
     print_usage ();
 
   return retval;
@@ -6615,17 +6615,17 @@ then an empty matrix is returned.\n\
 
 %!error diff ();
 
 %!error diff (1, 2, 3, 4);
 
 */
 
 template <class T>
-static Array<T> 
+static Array<T>
 do_repelems (const Array<T>& src, const Array<octave_idx_type>& rep)
 {
   Array<T> retval;
 
   assert (rep.ndims () == 2 && rep.rows () == 2);
 
   octave_idx_type n = rep.columns (), l = 0;
   for (octave_idx_type i = 0; i < n; i++)
diff --git a/src/debug.cc b/src/debug.cc
--- a/src/debug.cc
+++ b/src/debug.cc
@@ -180,17 +180,17 @@ get_user_code (const std::string& fname 
       if (fcn.is_defined () && fcn.is_user_code ())
         dbg_fcn = fcn.user_code_value ();
     }
 
   return dbg_fcn;
 }
 
 static void
-parse_dbfunction_params (const char *who, const octave_value_list& args, 
+parse_dbfunction_params (const char *who, const octave_value_list& args,
                          std::string& symbol_name, bp_table::intmap& lines)
 {
   int nargin = args.length ();
   int idx = 0;
   int list_idx = 0;
   symbol_name = std::string ();
   lines = bp_table::intmap ();
 
@@ -227,36 +227,36 @@ parse_dbfunction_params (const char *who
             break;
           lines[list_idx++] = line;
         }
       else if (args(i).is_map ())
         octave_stdout << who << ": accepting a struct" << std::endl;
       else
         {
           const NDArray arg = args(i).array_value ();
-          
+
           if (error_state)
             break;
-          
+
           for (octave_idx_type j = 0; j < arg.nelem (); j++)
             {
               int line = static_cast<int> (arg.elem (j));
               if (error_state)
                 break;
               lines[list_idx++] = line;
             }
-          
+
           if (error_state)
             break;
         }
-    } 
+    }
 }
 
 bp_table::intmap
-bp_table::do_add_breakpoint (const std::string& fname, 
+bp_table::do_add_breakpoint (const std::string& fname,
                              const bp_table::intmap& line)
 {
   intmap retval;
 
   octave_idx_type len = line.size ();
 
   octave_user_code *dbg_fcn = get_user_code (fname);
 
@@ -288,18 +288,18 @@ bp_table::do_add_breakpoint (const std::
     error ("add_breakpoint: unable to find the function requested\n");
 
   tree_evaluator::debug_mode = bp_table::have_breakpoints () || Vdebugging;
 
   return retval;
 }
 
 
-int 
-bp_table::do_remove_breakpoint (const std::string& fname, 
+int
+bp_table::do_remove_breakpoint (const std::string& fname,
                                 const bp_table::intmap& line)
 {
   int retval = 0;
 
   octave_idx_type len = line.size ();
 
   if (len == 0)
     {
@@ -345,23 +345,23 @@ bp_table::do_remove_breakpoint (const st
 
   tree_evaluator::debug_mode = bp_table::have_breakpoints () || Vdebugging;
 
   return retval;
 }
 
 
 bp_table::intmap
-bp_table::do_remove_all_breakpoints_in_file (const std::string& fname, 
+bp_table::do_remove_all_breakpoints_in_file (const std::string& fname,
                                              bool silent)
 {
   intmap retval;
 
   octave_user_code *dbg_fcn = get_user_code (fname);
-  
+
   if (dbg_fcn)
     {
       tree_statement_list *cmds = dbg_fcn->body ();
 
       if (cmds)
         {
           octave_value_list bkpts = cmds->list_breakpoints ();
 
@@ -382,28 +382,28 @@ bp_table::do_remove_all_breakpoints_in_f
     error ("remove_all_breakpoint_in_file: "
            "unable to find the function requested\n");
 
   tree_evaluator::debug_mode = bp_table::have_breakpoints () || Vdebugging;
 
   return retval;
 }
 
-void 
+void
 bp_table::do_remove_all_breakpoints (void)
 {
   for (const_bp_set_iterator it = bp_set.begin (); it != bp_set.end (); it++)
     remove_all_breakpoints_in_file (*it);
 
 
   tree_evaluator::debug_mode = bp_table::have_breakpoints () || Vdebugging;
 }
 
-std::string 
-do_find_bkpt_list (octave_value_list slist, 
+std::string
+do_find_bkpt_list (octave_value_list slist,
                    std::string match)
 {
   std::string retval;
 
   for (int i = 0; i < slist.length (); i++)
     {
       if (slist (i).string_value () == match)
         {
@@ -430,39 +430,39 @@ bp_table::do_get_breakpoint_list (const 
 
           if (f)
             {
               tree_statement_list *cmds = f->body ();
 
               if (cmds)
                 {
                   octave_value_list bkpts = cmds->list_breakpoints ();
-                  octave_idx_type len = bkpts.length (); 
+                  octave_idx_type len = bkpts.length ();
 
                   if (len > 0)
                     {
                       bp_table::intmap bkpts_vec;
-                      
+
                       for (int i = 0; i < len; i++)
                         bkpts_vec[i] = bkpts (i).double_value ();
-                      
+
                       std::string symbol_name = f->name ();
 
                       retval[symbol_name] = bkpts_vec;
                     }
                 }
             }
         }
     }
 
   return retval;
 }
 
 static octave_value
-intmap_to_ov (const bp_table::intmap& line) 
+intmap_to_ov (const bp_table::intmap& line)
 {
   int idx = 0;
 
   NDArray retval (dim_vector (1, line.size ()));
 
   for (size_t i = 0; i < line.size (); i++)
     {
       bp_table::const_intmap_iterator p = line.find (i);
@@ -530,17 +530,17 @@ a breakpoint.  If you get the wrong line
 @seealso{dbstop, dbstatus, dbwhere}\n\
 @end deftypefn")
 {
   octave_value retval;
   std::string symbol_name = "";
   bp_table::intmap lines;
 
   parse_dbfunction_params ("dbclear", args, symbol_name, lines);
-      
+
   if (! error_state)
     bp_table::remove_breakpoint (symbol_name, lines);
 
   return retval;
 }
 
 DEFUN (dbstatus, args, nargout,
   "-*- texinfo -*-\n\
@@ -591,17 +591,17 @@ mode this should be left out.\n\
     }
 
   if (nargout == 0)
     {
       // Print out the breakpoint information.
 
       for (bp_table::fname_line_map_iterator it = bp_list.begin ();
            it != bp_list.end (); it++)
-        {         
+        {
           octave_stdout << "breakpoint in " << it->first << " at line(s) ";
 
           bp_table::intmap m = it->second;
 
           size_t nel = m.size ();
 
           for (size_t j = 0; j < nel; j++)
             octave_stdout << m[j] << ((j < nel - 1) ? ", " : ".");
@@ -696,20 +696,20 @@ do_dbtype (std::ostream& os, const std::
   if (! ff.empty ())
     {
       std::ifstream fs (ff.c_str (), std::ios::in);
 
       if (fs)
         {
           char ch;
           int line = 1;
-        
+
           if (line >= start && line <= end)
             os << line << "\t";
-        
+
           while (fs.get (ch))
             {
               if (line >= start && line <= end)
                 {
                   os << ch;
                 }
 
               if (ch == '\n')
@@ -772,17 +772,17 @@ List script file with line numbers.\n\
 
                   if (ind != std::string::npos)
                     {
                       std::string start_str = arg.substr (0, ind);
                       std::string end_str = arg.substr (ind + 1);
 
                       int start = atoi (start_str.c_str ());
                       int end = atoi (end_str.c_str ());
-                
+
                       if (std::min (start, end) <= 0)
                         error ("dbtype: start and end lines must be >= 1\n");
 
                       if (start <= end)
                         do_dbtype (octave_stdout, dbg_fcn->name (), start, end);
                       else
                         error ("dbtype: start line must be less than end line\n");
                     }
@@ -804,27 +804,27 @@ List script file with line numbers.\n\
 
               if (ind != std::string::npos)
                 {
                   std::string start_str = arg.substr (0, ind);
                   std::string end_str = arg.substr (ind + 1);
 
                   start = atoi (start_str.c_str ());
                   end = atoi (end_str.c_str ());
-                  
+
                 }
               else
                 {
                   start = atoi (arg.c_str ());
                   end = start;
                 }
 
               if (std::min (start, end) <= 0)
                 error ("dbtype: start and end lines must be >= 1\n");
-              
+
               if (start <= end)
                 do_dbtype (octave_stdout, dbg_fcn->name (), start, end);
               else
                 error ("dbtype: start line must be less than end line\n");
             }
           break;
 
         default:
@@ -1005,17 +1005,17 @@ Using @code{dbstep in} will cause execut
 any m-files defined on the next line.  Using @code{dbstep out} will cause\n\
 execution to continue until the current function returns.\n\
 @seealso{dbcont, dbquit}\n\
 @end deftypefn")
 {
   if (Vdebugging)
     {
       int nargin = args.length ();
-      
+
       if (nargin > 1)
         print_usage ();
       else if (nargin == 1)
         {
           if (args(0).is_string ())
             {
               std::string arg = args(0).string_value ();
 
diff --git a/src/debug.h b/src/debug.h
--- a/src/debug.h
+++ b/src/debug.h
@@ -62,51 +62,51 @@ public:
     if (! instance)
       instance = new bp_table ();
 
     if (! instance)
       {
         ::error ("unable to create breakpoint table!");
         retval = false;
       }
-    
+
     return retval;
   }
 
   // Add a breakpoint at the nearest executable line.
-  static intmap add_breakpoint (const std::string& fname = "", 
+  static intmap add_breakpoint (const std::string& fname = "",
                                 const intmap& lines = intmap ())
   {
     return instance_ok ()
       ? instance->do_add_breakpoint (fname, lines) : intmap ();
   }
 
   // Remove a breakpoint from a line in file.
-  static int remove_breakpoint (const std::string& fname = "", 
+  static int remove_breakpoint (const std::string& fname = "",
                                 const intmap& lines = intmap ())
   {
     return instance_ok ()
       ? instance->do_remove_breakpoint (fname, lines) : 0;
   }
 
   // Remove all the breakpoints in a specified file.
   static intmap remove_all_breakpoints_in_file (const std::string& fname,
                                                 bool silent = false)
   {
     return instance_ok ()
       ? instance->do_remove_all_breakpoints_in_file (fname, silent) : intmap ();
   }
-  
+
   // Remove all the breakpoints registered with octave.
   static void remove_all_breakpoints (void)
   {
     if (instance_ok ())
       instance->do_remove_all_breakpoints ();
   }
-  
+
   // Return all breakpoints.  Each element of the map is a vector
   // containing the breakpoints corresponding to a given function name.
   static fname_line_map
   get_breakpoint_list (const octave_value_list& fname_list)
   {
     return instance_ok ()
       ? instance->do_get_breakpoint_list (fname_list) : fname_line_map ();
   }
@@ -126,17 +126,17 @@ private:
   std::set<std::string> bp_set;
 
   static bp_table *instance;
 
   intmap do_add_breakpoint (const std::string& fname, const intmap& lines);
 
   int do_remove_breakpoint (const std::string&, const intmap& lines);
 
-  intmap do_remove_all_breakpoints_in_file (const std::string& fname, 
+  intmap do_remove_all_breakpoints_in_file (const std::string& fname,
                                             bool silent);
 
   void do_remove_all_breakpoints (void);
 
   fname_line_map do_get_breakpoint_list (const octave_value_list& fname_list);
 
   bool do_have_breakpoints (void) { return (! bp_set.empty ()); }
 };
diff --git a/src/defun-int.h b/src/defun-int.h
--- a/src/defun-int.h
+++ b/src/defun-int.h
@@ -39,17 +39,17 @@ extern OCTINTERP_API void check_version 
 
 extern OCTINTERP_API void
 install_builtin_function (octave_builtin::fcn f, const std::string& name,
                           const std::string& doc,
                           bool can_hide_function = true);
 
 extern OCTINTERP_API void
 install_dld_function (octave_dld_function::fcn f, const std::string& name,
-                      const octave_shlib& shl, const std::string& doc, 
+                      const octave_shlib& shl, const std::string& doc,
                       bool relative = false);
 
 extern OCTINTERP_API void
 install_mex_function (void *fptr, bool fmex, const std::string& name,
                       const octave_shlib& shl, bool relative = false);
 
 extern OCTINTERP_API void
 alias_builtin (const std::string& alias, const std::string& name);
diff --git a/src/defun.cc b/src/defun.cc
--- a/src/defun.cc
+++ b/src/defun.cc
@@ -122,17 +122,17 @@ alias_builtin (const std::string& alias,
 {
   symbol_table::alias_built_in_function (alias, name);
 }
 
 octave_shlib
 get_current_shlib (void)
 {
   octave_shlib retval;
-  
+
   octave_function *curr_fcn = octave_call_stack::current ();
   if (curr_fcn)
     {
       if (curr_fcn->is_dld_function ())
         {
           octave_dld_function *dld = dynamic_cast<octave_dld_function *> (curr_fcn);
           retval = dld->get_shlib ();
         }
diff --git a/src/dynamic-ld.cc b/src/dynamic-ld.cc
--- a/src/dynamic-ld.cc
+++ b/src/dynamic-ld.cc
@@ -381,17 +381,17 @@ octave_dynamic_loader::do_load_oct (cons
                 ::error ("failed to install .oct file function `%s'",
                          fcn_name.c_str ());
             }
         }
       else
         ::error ("%s is not a valid shared library",
                  file_name.c_str ());
     }
-  
+
   return retval;
 }
 
 octave_function *
 octave_dynamic_loader::do_load_mex (const std::string& fcn_name,
                                     const std::string& file_name,
                                     bool /*relative*/)
 {
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -61,17 +61,17 @@ bool Vdebug_on_warning = false;
 
 // TRUE means that Octave will try to display a stack trace when a
 // warning is encountered.
 static bool Vbacktrace_on_warning = false;
 
 // TRUE means that Octave will print a verbose warning.  Currently unused.
 static bool Vverbose_warning;
 
-// TRUE means that Octave will print no warnings, but lastwarn will be 
+// TRUE means that Octave will print no warnings, but lastwarn will be
 //updated
 static bool Vquiet_warning = false;
 
 // A structure containing (most of) the current state of warnings.
 static octave_map warning_options;
 
 // The text of the last error message.
 static std::string Vlast_error_message;
@@ -795,17 +795,17 @@ handle_message (error_fun f, const char 
         arg = args(0);
 
       if (arg.is_defined ())
         {
           if (arg.is_string ())
             {
               tstr = arg.string_value ();
               msg = tstr.c_str ();
-              
+
               if (! msg)
                 return retval;
             }
           else if (arg.is_empty ())
             return retval;
         }
     }
 
@@ -915,53 +915,53 @@ location of the error.  Typically @var{e
                 {
                   if (file.empty ())
                     {
                       if (nm.empty ())
                         {
                           if (l > 0)
                             {
                               if (c > 0)
-                                pr_where_1 ("error: near line %d, column %d", 
+                                pr_where_1 ("error: near line %d, column %d",
                                             l, c);
                               else
                                 pr_where_1 ("error: near line %d", l);
                             }
                         }
                       else
                         {
                           if (l > 0)
                             {
                               if (c > 0)
-                                pr_where_1 ("error: called from `%s' near line %d, column %d", 
+                                pr_where_1 ("error: called from `%s' near line %d, column %d",
                                             nm.c_str (), l, c);
                               else
                                 pr_where_1 ("error: called from `%d' near line %d", nm.c_str (), l);
                             }
                         }
                     }
                   else
                     {
                       if (nm.empty ())
                         {
                           if (l > 0)
                             {
                               if (c > 0)
-                                pr_where_1 ("error: in file %s near line %d, column %d", 
+                                pr_where_1 ("error: in file %s near line %d, column %d",
                                             file.c_str (), l, c);
                               else
                                 pr_where_1 ("error: in file %s near line %d", file.c_str (), l);
                             }
                         }
                       else
                         {
                           if (l > 0)
                             {
                               if (c > 0)
-                                pr_where_1 ("error: called from `%s' in file %s near line %d, column %d", 
+                                pr_where_1 ("error: called from `%s' in file %s near line %d, column %d",
                                             nm.c_str (), file.c_str (), l, c);
                               else
                                 pr_where_1 ("error: called from `%d' in file %s near line %d", nm.c_str (), file.c_str (), l);
                             }
                         }
                     }
                 }
             }
@@ -1310,17 +1310,17 @@ warning named by @var{id} is handled as 
                     arg2 = Vlast_warning_id;
 
                   Cell ident = warning_options.contents ("identifier");
                   Cell state = warning_options.contents ("state");
 
                   octave_idx_type nel = ident.numel ();
 
                   bool found = false;
-                  
+
                   std::string val;
 
                   for (octave_idx_type i = 0; i < nel; i++)
                     {
                       if (ident(i).string_value () == arg2)
                         {
                           val = state(i).string_value ();
                           found = true;
@@ -1559,57 +1559,57 @@ their default values.\n\
               std::string new_error_id;
               std::string new_error_file;
               std::string new_error_name;
               int new_error_line = -1;
               int new_error_column = -1;
 
               if (! error_state && new_err.contains ("message"))
                 {
-                  const std::string tmp = 
+                  const std::string tmp =
                     new_err.getfield("message").string_value ();
                   new_error_message = tmp;
                 }
 
               if (! error_state && new_err.contains ("identifier"))
                 {
-                  const std::string tmp = 
+                  const std::string tmp =
                     new_err.getfield("identifier").string_value ();
                   new_error_id = tmp;
                 }
 
               if (! error_state && new_err.contains ("stack"))
                 {
-                  octave_scalar_map new_err_stack = 
+                  octave_scalar_map new_err_stack =
                     new_err.getfield("identifier").scalar_map_value ();
 
                   if (! error_state && new_err_stack.contains ("file"))
                     {
-                      const std::string tmp = 
+                      const std::string tmp =
                         new_err_stack.getfield("file").string_value ();
                       new_error_file = tmp;
                     }
 
                   if (! error_state && new_err_stack.contains ("name"))
                     {
-                      const std::string tmp = 
+                      const std::string tmp =
                         new_err_stack.getfield("name").string_value ();
                       new_error_name = tmp;
                     }
 
                   if (! error_state && new_err_stack.contains ("line"))
                     {
-                      const int tmp = 
+                      const int tmp =
                         new_err_stack.getfield("line").nint_value ();
                       new_error_line = tmp;
                     }
-                  
+
                   if (! error_state && new_err_stack.contains ("column"))
                     {
-                      const int tmp = 
+                      const int tmp =
                         new_err_stack.getfield("column").nint_value ();
                       new_error_column = tmp;
                     }
                 }
 
               if (! error_state)
                 {
                   Vlast_error_message = new_error_message;
@@ -1626,17 +1626,17 @@ their default values.\n\
         }
 
       if (! error_state)
         retval = err;
     }
   else
     print_usage ();
 
-  return retval;  
+  return retval;
 }
 
 DEFUN (lasterr, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{msg}, @var{msgid}] =} lasterr (@var{msg}, @var{msgid})\n\
 Without any arguments, return the last error message.  With one\n\
 argument, set the last error message to @var{msg}.  With two arguments,\n\
 also set the last message identifier.\n\
@@ -1673,17 +1673,17 @@ also set the last message identifier.\n\
             }
         }
       else
         error ("lasterr: expecting arguments to be character strings");
     }
   else
     print_usage ();
 
-  return retval;  
+  return retval;
 }
 
 // For backward compatibility.
 DEFALIAS (error_text, lasterr);
 DEFALIAS (__error_text__, lasterr);
 
 DEFUN (lastwarn, args, nargout,
   "-*- texinfo -*-\n\
@@ -1720,17 +1720,17 @@ also set the last message identifier.\n\
             }
         }
       else
         error ("lastwarn: expecting arguments to be character strings");
     }
   else
     print_usage ();
 
-  return retval;  
+  return retval;
 }
 
 DEFUN (usage, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} usage (@var{msg})\n\
 Print the message @var{msg}, prefixed by the string @samp{usage: }, and\n\
 set Octave's internal error state such that control will return to the\n\
 top level without evaluating any more commands.  This is useful for\n\
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -465,17 +465,17 @@ do_stream_open (const std::string& name,
                   if (! tmp.empty ())
                     {
                       warning_with_id ("Octave:fopen-file-in-path",
                                        "fopen: file found in load path");
                       fname = tmp;
                     }
                 }
             }
-          
+
           if (! fs.is_dir ())
             {
               std::string tmode = mode;
 
               // Use binary mode if 't' is not specified, but don't add
               // 'b' if it is already present.
 
               size_t bpos = tmode.find ('b');
@@ -861,17 +861,17 @@ If @var{fid} is omitted, the output is w
 
   int nargin = args.length ();
 
   if (nargin > 1 || (nargin > 0 && args(0).is_string ()))
     {
       octave_stream os;
       int fmt_n = 0;
 
-      if (args(0).is_string ()) 
+      if (args(0).is_string ())
         {
           os = octave_stream_list::lookup (1, who);
         }
       else
         {
           fmt_n = 1;
           os = octave_stream_list::lookup (args(0), who);
         }
diff --git a/src/gl-render.cc b/src/gl-render.cc
--- a/src/gl-render.cc
+++ b/src/gl-render.cc
@@ -58,19 +58,19 @@ xmin (octave_idx_type x, octave_idx_type
 
 class
 opengl_texture
 {
 protected:
   class texture_rep
   {
   public:
-    texture_rep (void) 
+    texture_rep (void)
       : id (), w (), h (), tw (), th (), tx (), ty (),
-        valid (false), count (1) 
+        valid (false), count (1)
     { }
 
     texture_rep (GLuint id_arg, int w_arg, int h_arg, int tw_arg, int th_arg)
         : id (id_arg), w (w_arg), h (h_arg), tw (tw_arg), th (th_arg),
           tx (double(w)/tw), ty (double(h)/th), valid (true),
           count (1) { }
 
     ~texture_rep (void)
@@ -126,17 +126,17 @@ public:
 
   static opengl_texture create (const octave_value& data);
 
   void bind (int mode = GL_TEXTURE_2D) const
     { rep->bind (mode); }
 
   void tex_coord (double q, double r) const
     { rep->tex_coord (q, r); }
-  
+
   bool is_valid (void) const
     { return rep->valid; }
 };
 
 static int
 next_power_of_2 (int n)
 {
   int m = 1;
@@ -300,30 +300,30 @@ protected:
                        reinterpret_cast<fcn> (tess_error));
     }
 
   bool is_filled (void) const { return fill; }
 
 private:
   static void CALLBACK tess_begin (GLenum type, void *t)
     { reinterpret_cast<opengl_tesselator *> (t)->begin (type); }
-  
+
   static void CALLBACK tess_end (void *t)
     { reinterpret_cast<opengl_tesselator *> (t)->end (); }
-  
+
   static void CALLBACK tess_vertex (void *v, void *t)
     { reinterpret_cast<opengl_tesselator *> (t)->vertex (v); }
-  
+
   static void CALLBACK tess_combine (GLdouble c[3], void *v[4], GLfloat w[4],
                                      void **out,  void *t)
     { reinterpret_cast<opengl_tesselator *> (t)->combine (c, v, w, out); }
-  
+
   static void CALLBACK tess_edge_flag (GLboolean flag, void *t)
     { reinterpret_cast<opengl_tesselator *> (t)->edge_flag (flag); }
-  
+
   static void CALLBACK tess_error (GLenum err, void *t)
     { reinterpret_cast<opengl_tesselator *> (t)->error (err); }
 
 private:
   GLUtesselator *glu_tess;
   bool fill;
 };
 
@@ -341,17 +341,17 @@ public:
     float ambient;
     float diffuse;
     float specular;
     float specular_exp;
 
     // reference counter
     int count;
 
-    vertex_data_rep (void) 
+    vertex_data_rep (void)
       : coords (), color (), normal (), alpha (),
         ambient (), diffuse (), specular (), specular_exp (),count (1) { }
 
     vertex_data_rep (const Matrix& c, const Matrix& col, const Matrix& n,
                      double a, float as, float ds, float ss, float se)
         : coords (c), color (col), normal (n), alpha (a),
           ambient (as), diffuse (ds), specular (ss), specular_exp (se),
           count (1) { }
@@ -437,17 +437,17 @@ protected:
 
   void vertex (void *data)
     {
       vertex_data::vertex_data_rep *v
           = reinterpret_cast<vertex_data::vertex_data_rep *> (data);
       //printf("patch_tesselator::vertex (%g, %g, %g)\n", v->coords(0), v->coords(1), v->coords(2));
 
       // FIXME: why did I need to keep the first vertex of the face
-      // in JHandles? I think it's related to the fact that the 
+      // in JHandles? I think it's related to the fact that the
       // tessellation process might re-order the vertices, such that
       // the first one you get here might not be the first one of the face;
       // but I can't figure out the actual reason.
       if (color_mode > 0 && (first || color_mode == 2))
         {
           Matrix col = v->color;
 
           if (col.numel () == 3)
@@ -535,17 +535,17 @@ private:
   std::list<vertex_data> tmp_vdata;
 };
 
 void
 opengl_renderer::draw (const graphics_object& go)
 {
   if (! go.valid_object ())
     return;
-  
+
   const base_properties& props = go.get_properties ();
 
   if (go.isa ("figure"))
     draw_figure (dynamic_cast<const figure::properties&> (props));
   else if (go.isa ("axes"))
     draw_axes (dynamic_cast<const axes::properties&> (props));
   else if (go.isa ("line"))
     draw_line (dynamic_cast<const line::properties&> (props));
@@ -608,17 +608,17 @@ opengl_renderer::draw_figure (const figu
 void
 opengl_renderer::draw_axes (const axes::properties& props)
 {
   // setup OpenGL transformation
 
   Matrix x_zlim = props.get_transform_zlim ();
   Matrix x_mat1 = props.get_opengl_matrix_1 ();
   Matrix x_mat2 = props.get_opengl_matrix_2 ();
-  
+
   xZ1 = x_zlim(0)-(x_zlim(1)-x_zlim(0))/2;
   xZ2 = x_zlim(1)+(x_zlim(1)-x_zlim(0))/2;
 
 #if defined (HAVE_FRAMEWORK_OPENGL)
   GLint vw[4];
 #else
   int vw[4];
 #endif
@@ -635,23 +635,23 @@ opengl_renderer::draw_axes (const axes::
   glMultMatrixd (x_mat2.data ());
   glMatrixMode (GL_MODELVIEW);
 
   glClear (GL_DEPTH_BUFFER_BIT);
 
   // store axes transformation data
 
   xform = props.get_transform ();
-  
+
   // draw axes object
 
   GLboolean antialias;
   glGetBooleanv (GL_LINE_SMOOTH, &antialias);
   glDisable (GL_LINE_SMOOTH);
-  
+
   Matrix xlim = xform.xscale (props.get_xlim ().matrix_value ());
   Matrix ylim = xform.yscale (props.get_ylim ().matrix_value ());
   Matrix zlim = xform.zscale (props.get_zlim ().matrix_value ());
   double x_min = xlim(0), x_max = xlim(1);
   double y_min = ylim(0), y_max = ylim(1);
   double z_min = zlim(0), z_max = zlim(1);
 
   double xd = (props.xdir_is ("normal") ? 1 : -1);
@@ -1022,17 +1022,17 @@ opengl_renderer::draw_axes (const axes::
               double xval = xticks(i);
 
               if (xlim(0) <= xval && xlim(1) >= xval)
                 {
                   // FIXME: as tick text is transparent, shouldn't be
                   //        drawn after axes object, for correct rendering?
                   Matrix b = render_text (xticklabels(i),
                                         tickpos(i,0), tickpos(i,1), tickpos(i,2),
-                                        halign, valign); 
+                                        halign, valign);
 
                   wmax = std::max (wmax, static_cast<int> (b(2)));
                   hmax = std::max (hmax, static_cast<int> (b(3)));
                 }
             }
         }
 
       // minor grid lines
@@ -1053,17 +1053,17 @@ opengl_renderer::draw_axes (const axes::
                       glVertex3d (xval, yPlane, zPlaneN);
                       glVertex3d (xval, yPlane, zPlane);
                     }
                 }
             }
           glEnd ();
           set_linestyle ("-", true);
         }
-                        
+
       // minor tick marks
       if (do_xminortick)
         {
           if (tick_along_z)
             {
               glBegin (GL_LINES);
               for (int i = 0; i < xmticks.numel (); i++)
                 {
@@ -1165,17 +1165,17 @@ opengl_renderer::draw_axes (const axes::
         }
     }
   else
     {
       gh_manager::get_object (props.get_xlabel ()).set ("visible", "off");
     }
 
   // Y grid
-                
+
   if (ystate != AXE_DEPTH_DIR && visible)
     {
       bool do_ygrid = (props.is_ygrid () && (gridstyle != "none"));
       bool do_yminorgrid = (props.is_yminorgrid () && (minorgridstyle != "none"));
       bool do_yminortick = props.is_yminortick ();
       Matrix yticks = xform.yscale (props.get_ytick ().matrix_value ());
       // FIXME: use pre-computed minor ticks
       Matrix ymticks;
@@ -1272,17 +1272,17 @@ opengl_renderer::draw_axes (const axes::
               double yval = yticks(i);
 
               if (ylim(0) <= yval && ylim(1) >= yval)
                 {
                   // FIXME: as tick text is transparent, shouldn't be
                   //        drawn after axes object, for correct rendering?
                   Matrix b = render_text (yticklabels(i),
                                         tickpos(i,0), tickpos(i,1), tickpos(i,2),
-                                        halign, valign); 
+                                        halign, valign);
 
                   wmax = std::max (wmax, static_cast<int> (b(2)));
                   hmax = std::max (hmax, static_cast<int> (b(3)));
                 }
             }
         }
 
       // minor grid lines
@@ -1413,17 +1413,17 @@ opengl_renderer::draw_axes (const axes::
                 }
             }
         }
     }
   else
     {
       gh_manager::get_object (props.get_ylabel ()).set ("visible", "off");
     }
-                
+
   // Z Grid
 
   if (zstate != AXE_DEPTH_DIR && visible)
     {
       bool do_zgrid = (props.is_zgrid () && (gridstyle != "none"));
       bool do_zminorgrid = (props.is_zminorgrid () && (minorgridstyle != "none"));
       bool do_zminortick = props.is_zminortick ();
       Matrix zticks = xform.zscale (props.get_ztick ().matrix_value ());
@@ -1560,17 +1560,17 @@ opengl_renderer::draw_axes (const axes::
               double zval = zticks(i);
 
               if (zlim(0) <= zval && zlim(1) >= zval)
                 {
                   // FIXME: as tick text is transparent, shouldn't be
                   //        drawn after axes object, for correct rendering?
                   Matrix b = render_text (zticklabels(i),
                                         tickpos(i,0), tickpos(i,1), tickpos(i,2),
-                                        halign, valign); 
+                                        halign, valign);
 
                   wmax = std::max (wmax, static_cast<int> (b(2)));
                   hmax = std::max (hmax, static_cast<int> (b(3)));
                 }
             }
         }
 
       // minor grid lines
@@ -1760,17 +1760,17 @@ opengl_renderer::draw_axes (const axes::
     }
 
   set_linestyle ("-");
 
   // Title
 
   text::properties& title_props =
     reinterpret_cast<text::properties&> (gh_manager::get_object (props.get_title ()).get_properties ());
-      
+
   if (! title_props.get_string ().empty () && title_props.positionmode_is("auto"))
     {
       ColumnVector p = xform.untransform (bbox(0)+bbox(2)/2, (bbox(1)-10),
           (x_zlim(0)+x_zlim(1))/2, true);
       title_props.set_position (p.extract_n(0, 3).transpose ());
       title_props.set_positionmode ("auto");
     }
 
@@ -1916,17 +1916,17 @@ opengl_renderer::draw_line (const line::
                   flag = false;
                   glEnd ();
                 }
             }
 
           if (flag)
             glEnd ();
         }
-          
+
       set_linewidth (0.5);
       set_linestyle ("-");
     }
 
   set_clipping (false);
 
   if (! props.marker_is ("none") &&
       ! (props.markeredgecolor_is ("none")
@@ -1952,17 +1952,17 @@ opengl_renderer::draw_line (const line::
           if (clip[i] == clip_ok)
             draw_marker (x(i), y(i),
                          has_z ? z(i) : static_cast<double> (i) / n,
                          lc, fc);
         }
 
       end_marker ();
     }
-  
+
   set_clipping (props.is_clipping ());
 }
 
 void
 opengl_renderer::draw_surface (const surface::properties& props)
 {
   const Matrix x = xform.xscale (props.get_xdata ().matrix_value ());
   const Matrix y = xform.yscale (props.get_ydata ().matrix_value ());
@@ -2109,17 +2109,17 @@ opengl_renderer::draw_surface (const sur
                         cb[k] = c(j-1, i-1, k);
                       glColor3fv (cb);
 
                       if (fl_mode > 0)
                         {
                           for (int k = 0; k < 3; k++)
                             cb[k] *= as;
                           glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
-                          
+
                           for (int k = 0; k < 3; k++)
                             cb[k] = ds * c(j-1, i-1, k);
                           glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
                         }
                     }
                   if (fl_mode > 0)
                     {
                       d = sqrt (n(j-1,i-1,0) * n(j-1,i-1,0)
@@ -2138,48 +2138,48 @@ opengl_renderer::draw_surface (const sur
                         cb[k] = c(j-1, i, k);
                       glColor3fv (cb);
 
                       if (fl_mode > 0)
                         {
                           for (int k = 0; k < 3; k++)
                             cb[k] *= as;
                           glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
-                          
+
                           for (int k = 0; k < 3; k++)
                             cb[k] = ds * c(j-1, i, k);
                           glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
                         }
                     }
 
                   if (fl_mode == 2)
                     {
                       d = sqrt (n(j-1,i,0) * n(j-1,i,0)
                                 + n(j-1,i,1) * n(j-1,i,1)
                                 + n(j-1,i,2) * n(j-1,i,2));
                       glNormal3d (n(j-1,i,0)/d, n(j-1,i,1)/d, n(j-1,i,2)/d);
                     }
 
                   glVertex3d (x(j1,i), y(j-1,i2), z(j-1,i));
-                  
+
                   // Vertex 3
                   if (fc_mode == 3)
                     tex.tex_coord (double (i) / (zc-1), double (j) / (zr-1));
                   else if (fc_mode == 2)
                     {
                       for (int k = 0; k < 3; k++)
                         cb[k] = c(j, i, k);
                       glColor3fv (cb);
 
                       if (fl_mode > 0)
                         {
                           for (int k = 0; k < 3; k++)
                             cb[k] *= as;
                           glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
-                          
+
                           for (int k = 0; k < 3; k++)
                             cb[k] = ds * c(j, i, k);
                           glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
                         }
                     }
                   if (fl_mode == 2)
                     {
                       d = sqrt (n(j,i,0) * n(j,i,0)
@@ -2198,17 +2198,17 @@ opengl_renderer::draw_surface (const sur
                         cb[k] = c(j, i-1, k);
                       glColor3fv (cb);
 
                       if (fl_mode > 0)
                         {
                           for (int k = 0; k < 3; k++)
                             cb[k] *= as;
                           glMaterialfv (LIGHT_MODE, GL_AMBIENT, cb);
-                          
+
                           for (int k = 0; k < 3; k++)
                             cb[k] = ds * c(j, i-1, k);
                           glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
                         }
                     }
                   if (fl_mode == 2)
                     {
                       d = sqrt (n(j,i-1,0) * n(j,i-1,0)
@@ -2391,17 +2391,17 @@ opengl_renderer::draw_surface (const sur
                       if (el_mode > 0)
                         {
                           d = sqrt (n(j,i-1,0) * n(j,i-1,0)
                                     + n(j,i-1,1) * n(j,i-1,1)
                                     + n(j,i-1,2) * n(j,i-1,2));
                           glNormal3d (n(j,i-1,0)/d, n(j,i-1,1)/d, n(j,i-1,2)/d);
                         }
                       glVertex3d (x(j2,i-1), y(j,i1), z(j,i-1));
-                      
+
                       // Vertex 2
                       if (ec_mode == 2)
                         {
                           for (int k = 0; k < 3; k++)
                             cb[k] = c(j, i, k);
                           glColor3fv (cb);
 
                           if (fl_mode > 0)
@@ -2418,17 +2418,17 @@ opengl_renderer::draw_surface (const sur
                       if (el_mode == 2)
                         {
                           d = sqrt (n(j,i,0) * n(j,i,0)
                                     + n(j,i,1) * n(j,i,1)
                                     + n(j,i,2) * n(j,i,2));
                           glNormal3d (n(j,i,0)/d, n(j,i,1)/d, n(j,i,2)/d);
                         }
                       glVertex3d (x(j2,i), y(j,i2), z(j,i));
-                      
+
                       glEnd ();
                     }
                 }
             }
 
           set_linestyle ("-");
           set_linewidth (0.5);
 
@@ -2474,17 +2474,17 @@ opengl_renderer::draw_surface (const sur
 
       init_marker (props.get_marker (), props.get_markersize (),
                    props.get_linewidth ());
 
       for (int i = 0; i < zc; i++)
         {
           if (y_mat)
             i1 = i;
-          
+
           for (int j = 0; j < zr; j++)
             {
               if (clip(j,i))
                 continue;
 
               if (x_mat)
                 j1 = j;
 
@@ -2521,34 +2521,34 @@ opengl_renderer::draw_patch (const patch
   // int vmax = v.columns ();
   int nf = f.rows ();
   int fcmax = f.columns ();
 
   bool has_z = (v.columns () > 2);
   bool has_facecolor = false;
   bool has_facealpha = false;
 
-  int fc_mode = ((props.facecolor_is("none") 
+  int fc_mode = ((props.facecolor_is("none")
                   || props.facecolor_is_rgb ()) ? 0 :
                  (props.facecolor_is("flat") ? 1 : 2));
   int fl_mode = (props.facelighting_is ("none") ? 0 :
                  (props.facelighting_is ("flat") ? 1 : 2));
   int fa_mode = (props.facealpha_is_double () ? 0 :
                  (props.facealpha_is ("flat") ? 1 : 2));
-  int ec_mode = ((props.edgecolor_is("none") 
+  int ec_mode = ((props.edgecolor_is("none")
                   || props.edgecolor_is_rgb ()) ? 0 :
                  (props.edgecolor_is("flat") ? 1 : 2));
   int el_mode = (props.edgelighting_is ("none") ? 0 :
                  (props.edgelighting_is ("flat") ? 1 : 2));
   int ea_mode = (props.edgealpha_is_double () ? 0 :
                  (props.edgealpha_is ("flat") ? 1 : 2));
 
   Matrix fcolor = props.get_facecolor_rgb ();
   Matrix ecolor = props.get_edgecolor_rgb ();
-  
+
   float as = props.get_ambientstrength ();
   float ds = props.get_diffusestrength ();
   float ss = props.get_specularstrength ();
   float se = props.get_specularexponent ();
 
   boolMatrix clip (1, nv, false);
 
   if (has_z)
@@ -2575,17 +2575,17 @@ opengl_renderer::draw_patch (const patch
 
   if (fc_mode > 0 || ec_mode > 0)
     {
       c = props.get_color_data ().matrix_value ();
 
       if (c.rows () == 1)
         {
           // Single color specifications, we can simplify a little bit
-          
+
           if (fc_mode > 0)
             {
               fcolor = c;
               fc_mode = 0;
             }
 
           if (ec_mode > 0)
             {
@@ -2686,17 +2686,17 @@ opengl_renderer::draw_patch (const patch
                 continue;
 
               tess.begin_polygon (true);
               tess.begin_contour ();
 
               for (int j = 0; j < count_f(i); j++)
                 {
                   vertex_data::vertex_data_rep *vv = vdata[i+j*fr].get_rep ();
-        
+
                   tess.add_vertex (vv->coords.fortran_vec (), vv);
                 }
 
               tess.end_contour ();
               tess.end_polygon ();
             }
 
           if (fl_mode > 0)
@@ -2881,35 +2881,35 @@ opengl_renderer::draw_text (const text::
 
 void
 opengl_renderer::draw_image (const image::properties& props)
 {
   octave_value cdata = props.get_color_data ();
   dim_vector dv (cdata.dims ());
   int h = dv(0), w = dv(1);
   bool ok = true;
-  
+
   Matrix x = props.get_xdata ().matrix_value ();
   Matrix y = props.get_ydata ().matrix_value ();
 
-  if (w > 1 && x(1) == x(0)) 
+  if (w > 1 && x(1) == x(0))
     x(1) = x(1) + (w-1);
 
-  if (h > 1 && y(1) == y(0)) 
+  if (h > 1 && y(1) == y(0))
     y(1) = y(1) + (h-1);
 
   const ColumnVector p0 = xform.transform (x(0), y(0), 0);
   const ColumnVector p1 = xform.transform (x(1), y(1), 0);
 
   // image pixel size in screen pixel units
   float pix_dx, pix_dy;
   // image pixel size in normalized units
   float nor_dx, nor_dy;
 
-  if (w > 1) 
+  if (w > 1)
     {
       pix_dx = (p1(0) - p0(0))/(w-1);
       nor_dx = (x(1) - x(0))/(w-1);
     }
   else
     {
       const ColumnVector p1w = xform.transform (x(1) + 1, y(1), 0);
       pix_dx = p1w(0) - p0(0);
@@ -2952,20 +2952,20 @@ opengl_renderer::draw_image (const image
       if (im_ymax > ymax)
         i1 -= (im_ymax - ymax)/nor_dy;
     }
   else // clip to viewport
     {
       GLfloat vp[4];
       glGetFloatv(GL_VIEWPORT, vp);
       // FIXME -- actually add the code to do it!
-      
+
     }
 
-  if (i0 >= i1 || j0 >= j1) 
+  if (i0 >= i1 || j0 >= j1)
     return;
 
   glPixelZoom (pix_dx, -pix_dy);
   glRasterPos3d (im_xmin + nor_dx*j0, im_ymin + nor_dy*i0, 0);
 
   // by default this is 4
   glPixelStorei (GL_UNPACK_ALIGNMENT,1);
 
@@ -3029,17 +3029,17 @@ opengl_renderer::draw_image (const image
           draw_pixels (j1-j0, i1-i0, GL_RGB, GL_UNSIGNED_BYTE, a);
         }
       else
         {
           ok = false;
           warning ("opengl_texture::draw: invalid image data type (expected double, uint16, or uint8)");
         }
     }
-  else 
+  else
     {
       ok = false;
       warning ("opengl_texture::draw: invalid image size (expected n*m*3 or n*m)");
     }
   glPixelZoom (1, 1);
 }
 
 void
@@ -3208,17 +3208,17 @@ opengl_renderer::end_marker (void)
   set_linewidth (0.5f);
 }
 
 void
 opengl_renderer::draw_marker (double x, double y, double z,
                               const Matrix& lc, const Matrix& fc)
 {
   ColumnVector tmp = xform.transform (x, y, z, false);
-  
+
   glLoadIdentity ();
   glTranslated (tmp(0), tmp(1), -tmp(2));
 
   if (filled_marker_id > 0 && fc.numel () > 0)
     {
       glColor3dv (fc.data ());
       set_polygon_offset (true, -1.0);
       glCallList (filled_marker_id);
@@ -3352,33 +3352,33 @@ opengl_renderer::make_marker_list (const
       glVertex2f (sz/2, sz/2);
       glEnd ();
       break;
     case 'p':
       {
         double ang;
         double r;
         double dr = 1.0 - sin(M_PI/10)/sin(3*M_PI/10)*1.02;
-  
+
         glBegin ((filled ? GL_POLYGON : GL_LINE_LOOP));
         for (int i = 0; i < 2*5; i++)
           {
             ang = (-0.5 + double(i+1)/5) * M_PI;
             r = 1.0 - (dr * fmod(double(i+1), 2.0));
             glVertex2d (sz*r*cos(ang)/2, sz*r*sin(ang)/2);
           }
         glEnd ();
       }
       break;
     case 'h':
       {
         double ang;
         double r;
         double dr = 1.0 - 0.5/sin(M_PI/3)*1.02;
-  
+
         glBegin ((filled ? GL_POLYGON : GL_LINE_LOOP));
         for (int i = 0; i < 2*6; i++)
           {
             ang = (0.5 + double(i+1)/6.0) * M_PI;
             r = 1.0 - (dr * fmod(double(i+1), 2.0));
             glVertex2d (sz*r*cos(ang)/2, sz*r*sin(ang)/2);
           }
         glEnd ();
diff --git a/src/gl-render.h b/src/gl-render.h
--- a/src/gl-render.h
+++ b/src/gl-render.h
@@ -46,20 +46,20 @@ along with Octave; see the file COPYING.
 class
 OCTINTERP_API
 opengl_renderer
 {
 public:
   opengl_renderer (void)
     : toolkit (), xform (), xmin (), xmax (), ymin (), ymax (),
     zmin (), zmax (), xZ1 (), xZ2 (), marker_id (), filled_marker_id (),
-    camera_pos (), camera_dir () 
+    camera_pos (), camera_dir ()
 #if HAVE_FREETYPE
     , text_renderer ()
-#endif 
+#endif
   { }
 
   virtual ~opengl_renderer (void) { }
 
   virtual void draw (const graphics_handle& h)
     { draw (gh_manager::get_object (h)); }
 
   virtual void draw (const graphics_object& go);
@@ -109,24 +109,24 @@ protected:
                                Matrix& bbox,
                                int halign = 0, int valign = 0,
                                double rotation = 0.0);
 
   virtual Matrix render_text (const std::string& txt,
                               double x, double y, double z,
                               int halign, int valign, double rotation = 0.0);
 
-  virtual void draw_pixels (GLsizei w, GLsizei h, GLenum format, 
+  virtual void draw_pixels (GLsizei w, GLsizei h, GLenum format,
                             GLenum type, const GLvoid *data);
 
 private:
-  opengl_renderer (const opengl_renderer&) 
+  opengl_renderer (const opengl_renderer&)
     : toolkit (), xform (), xmin (), xmax (), ymin (), ymax (),
     zmin (), zmax (), xZ1 (), xZ2 (), marker_id (), filled_marker_id (),
-    camera_pos (), camera_dir () 
+    camera_pos (), camera_dir ()
 #if HAVE_FREETYPE
     , text_renderer ()
 #endif
     { }
 
   opengl_renderer& operator = (const opengl_renderer&)
     { return *this; }
 
diff --git a/src/gl2ps-renderer.cc b/src/gl2ps-renderer.cc
--- a/src/gl2ps-renderer.cc
+++ b/src/gl2ps-renderer.cc
@@ -29,68 +29,68 @@ along with Octave; see the file COPYING.
 #include <cstdio>
 
 #include "lo-mappers.h"
 #include "oct-locbuf.h"
 
 #include "gl2ps-renderer.h"
 #include "gl2ps.h"
 
-void 
-glps_renderer::draw (const graphics_object& go) 
+void
+glps_renderer::draw (const graphics_object& go)
 {
   static bool in_draw = false;
-  
-  if (!in_draw) 
+
+  if (!in_draw)
     {
       in_draw = true;
 
       FILE *fp = fdopen (fid, "wb");
       GLint buffsize = 0, state = GL2PS_OVERFLOW;
       GLint viewport[4];
 
       glGetIntegerv (GL_VIEWPORT, viewport);
 
       GLint gl2ps_term;
       if (term.find ("eps") != std::string::npos) gl2ps_term = GL2PS_EPS;
       else if (term.find ("pdf") != std::string::npos) gl2ps_term = GL2PS_PDF;
       else if (term.find ("svg") != std::string::npos) gl2ps_term = GL2PS_SVG;
       else if (term.find ("ps") != std::string::npos) gl2ps_term = GL2PS_PS;
       else if (term.find ("pgf") != std::string::npos) gl2ps_term = GL2PS_PGF;
       else if (term.find ("tex") != std::string::npos) gl2ps_term = GL2PS_TEX;
-      else 
+      else
         {
           error ("gl2ps-renderer:: Unknown terminal");
           return;
         }
 
       GLint gl2ps_text = 0;
       if (term.find ("notxt") != std::string::npos) gl2ps_text = GL2PS_NO_TEXT;
 
       while (state == GL2PS_OVERFLOW)
-        { 
+        {
           buffsize += 1024*1024;
           gl2psBeginPage ("glps_renderer figure", "Octave", viewport,
                           gl2ps_term, GL2PS_BSP_SORT,
                           (GL2PS_SILENT | GL2PS_SIMPLE_LINE_OFFSET
                            | GL2PS_NO_BLENDING | GL2PS_OCCLUSION_CULL
-                           | GL2PS_BEST_ROOT | gl2ps_text), 
+                           | GL2PS_BEST_ROOT | gl2ps_text),
                           GL_RGBA, 0, NULL, 0, 0, 0,
                           buffsize, fp, "" );
 
           opengl_renderer::draw (go);
           state = gl2psEndPage ();
         }
 
       gnulib::fclose (fp);
 
       in_draw = 0;
     }
   else
-    opengl_renderer::draw (go); 
+    opengl_renderer::draw (go);
 }
 
 int
 glps_renderer::alignment_to_mode (int ha, int va) const
 {
   int gl2psa=GL2PS_TEXT_BL;
   if (ha == 0)
     {
@@ -117,17 +117,17 @@ glps_renderer::alignment_to_mode (int ha
       else if (va == 2)
         gl2psa=GL2PS_TEXT_T;
       else if (va == 1)
         gl2psa=GL2PS_TEXT_C;
     }
   return gl2psa;
 }
 
-Matrix 
+Matrix
 glps_renderer::render_text (const std::string& txt,
                             double x, double y, double z,
                             int ha, int va, double rotation)
 {
   if (txt.empty ())
     return Matrix (1, 4, 0.0);
 
   glRasterPos3d (x, y, z);
@@ -154,41 +154,41 @@ glps_renderer::set_font (const base_prop
   if (fn == "times" || fn == "times-roman")
     fontname = "Times-Roman";
   else if (fn == "courier")
     fontname = "Courier";
   else if (fn == "symbol")
     fontname = "Symbol";
   else if (fn == "zapfdingbats")
     fontname = "ZapfDingbats";
-  else 
+  else
     fontname = "Helvetica";
 
   // FIXME -- add support for bold and italic
 }
 
 template <typename T>
 static void
 draw_pixels (GLsizei w, GLsizei h, GLenum format, const T *data)
 {
   OCTAVE_LOCAL_BUFFER (GLfloat, a, 3*w*h);
 
   for (int i = 0; i < 3*w*h; i++)
     a[i] = data[i];
-    
+
   gl2psDrawPixels (w, h, 0, 0, format, GL_FLOAT, a);
 }
 
-void 
+void
 glps_renderer::draw_pixels (GLsizei w, GLsizei h, GLenum format,
                             GLenum type, const GLvoid *data)
 {
-  if (type == GL_UNSIGNED_SHORT) 
+  if (type == GL_UNSIGNED_SHORT)
     ::draw_pixels (w, h, format, static_cast<const GLushort *> (data));
-  else if (type == GL_UNSIGNED_BYTE) 
+  else if (type == GL_UNSIGNED_BYTE)
     ::draw_pixels (w, h, format, static_cast<const GLubyte *> (data));
   else
     gl2psDrawPixels (w, h, 0, 0, format, type, data);
 }
 
 void
 glps_renderer::draw_text (const text::properties& props)
 {
@@ -200,17 +200,17 @@ glps_renderer::draw_text (const text::pr
 
   const Matrix pos = get_transform ().scale (props.get_data_position ());
   int halign = 0, valign = 0;
 
   if (props.horizontalalignment_is ("center"))
     halign = 1;
   else if (props.horizontalalignment_is ("right"))
     halign = 2;
-  
+
   if (props.verticalalignment_is ("top"))
     valign = 2;
   else if (props.verticalalignment_is ("baseline"))
     valign = 3;
   else if (props.verticalalignment_is ("middle"))
     valign = 1;
 
   // FIXME: handle margin and surrounding box
diff --git a/src/gl2ps-renderer.h b/src/gl2ps-renderer.h
--- a/src/gl2ps-renderer.h
+++ b/src/gl2ps-renderer.h
@@ -21,40 +21,40 @@ along with Octave; see the file COPYING.
 */
 
 #if !defined (gl2ps_renderer_h)
 #define gl2ps_renderer_h 1
 
 #include "gl-render.h"
 #include "gl2ps.h"
 
-class 
+class
 OCTINTERP_API
 glps_renderer : public opengl_renderer
 {
 public:
-  glps_renderer (const int _fid, const std::string& _term) 
-    : opengl_renderer () , fid (_fid), term (_term), 
+  glps_renderer (const int _fid, const std::string& _term)
+    : opengl_renderer () , fid (_fid), term (_term),
     fontsize (), fontname () { }
 
   ~glps_renderer (void) { }
 
   virtual void draw (const graphics_object& go);
 
 protected:
 
   virtual Matrix render_text (const std::string& txt,
                               double x, double y, double z,
                               int halign, int valign, double rotation = 0.0);
 
 
   virtual void set_font (const base_properties& props);
 
   virtual void draw_text (const text::properties& props);
-  virtual void draw_pixels (GLsizei w, GLsizei h, GLenum format, 
+  virtual void draw_pixels (GLsizei w, GLsizei h, GLenum format,
                             GLenum type, const GLvoid *data);
 
   virtual void set_linestyle (const std::string& s, bool use_stipple)
   {
     opengl_renderer::set_linestyle (s, use_stipple);
     if (use_stipple)
       gl2psEnable (GL2PS_LINE_STIPPLE);
     else
diff --git a/src/gl2ps.c b/src/gl2ps.c
--- a/src/gl2ps.c
+++ b/src/gl2ps.c
@@ -45,17 +45,17 @@
 #if defined(GL2PS_HAVE_ZLIB)
 #include <zlib.h>
 #endif
 
 #if defined(GL2PS_HAVE_LIBPNG)
 #include <png.h>
 #endif
 
-/********************************************************************* 
+/*********************************************************************
  *
  * Private definitions, data structures and prototypes
  *
  *********************************************************************/
 
 /* Magic numbers (assuming that the order of magnitude of window
    coordinates is 10^3) */
 
@@ -223,17 +223,17 @@ typedef struct {
 
   /* BSP-specific */
   GLint maxbestroot;
 
   /* Occlusion culling-specific */
   GLboolean zerosurfacearea;
   GL2PSbsptree2d *imagetree;
   GL2PSprimitive *primitivetoadd;
-  
+
   /* PDF-specific */
   int streamlength;
   GL2PSlist *pdfprimlist, *pdfgrouplist;
   int *xreflist;
   int objects_stack; /* available objects */
   int extgs_stack; /* graphics state object number */
   int font_stack; /* font object number */
   int im_stack; /* image object number */
@@ -261,34 +261,34 @@ typedef struct {
    local GL2PScontext during gl2psBeginPage) */
 
 static GL2PScontext *gl2ps = NULL;
 
 /* Need to forward-declare this one */
 
 static GLint gl2psPrintPrimitives(void);
 
-/********************************************************************* 
+/*********************************************************************
  *
  * Utility routines
  *
  *********************************************************************/
 
 static void gl2psMsg(GLint level, const char *fmt, ...)
 {
   va_list args;
 
   if(!(gl2ps->options & GL2PS_SILENT)){
     switch(level){
     case GL2PS_INFO : fprintf(stderr, "GL2PS info: "); break;
     case GL2PS_WARNING : fprintf(stderr, "GL2PS warning: "); break;
     case GL2PS_ERROR : fprintf(stderr, "GL2PS error: "); break;
     }
     va_start(args, fmt);
-    vfprintf(stderr, fmt, args); 
+    vfprintf(stderr, fmt, args);
     va_end(args);
     fprintf(stderr, "\n");
   }
   /* if(level == GL2PS_ERROR) exit(1); */
 }
 
 static void *gl2psMalloc(size_t size)
 {
@@ -355,45 +355,45 @@ static void gl2psFreeCompress(void)
   gl2ps->compress->dest = NULL;
   gl2ps->compress->srcLen = 0;
   gl2ps->compress->destLen = 0;
 }
 
 static int gl2psAllocCompress(unsigned int srcsize)
 {
   gl2psFreeCompress();
-  
+
   if(!gl2ps->compress || !srcsize)
     return GL2PS_ERROR;
-  
+
   gl2ps->compress->srcLen = srcsize;
   gl2ps->compress->destLen = (int)ceil(1.001 * gl2ps->compress->srcLen + 12);
   gl2ps->compress->src = (Bytef*)gl2psMalloc(gl2ps->compress->srcLen);
   gl2ps->compress->start = gl2ps->compress->src;
   gl2ps->compress->dest = (Bytef*)gl2psMalloc(gl2ps->compress->destLen);
-  
+
   return GL2PS_SUCCESS;
 }
 
 static void *gl2psReallocCompress(unsigned int srcsize)
 {
   if(!gl2ps->compress || !srcsize)
     return NULL;
-  
+
   if(srcsize < gl2ps->compress->srcLen)
     return gl2ps->compress->start;
-  
+
   gl2ps->compress->srcLen = srcsize;
   gl2ps->compress->destLen = (int)ceil(1.001 * gl2ps->compress->srcLen + 12);
-  gl2ps->compress->src = (Bytef*)gl2psRealloc(gl2ps->compress->src, 
+  gl2ps->compress->src = (Bytef*)gl2psRealloc(gl2ps->compress->src,
                                               gl2ps->compress->srcLen);
   gl2ps->compress->start = gl2ps->compress->src;
-  gl2ps->compress->dest = (Bytef*)gl2psRealloc(gl2ps->compress->dest, 
+  gl2ps->compress->dest = (Bytef*)gl2psRealloc(gl2ps->compress->dest,
                                                gl2ps->compress->destLen);
-  
+
   return gl2ps->compress->start;
 }
 
 static size_t gl2psWriteBigEndianCompress(unsigned long data, size_t bytes)
 {
   size_t i;
   size_t size = sizeof(unsigned long);
   for(i = 1; i <= bytes; ++i){
@@ -402,18 +402,18 @@ static size_t gl2psWriteBigEndianCompres
   }
   return bytes;
 }
 
 static int gl2psDeflate(void)
 {
   /* For compatibility with older zlib versions, we use compress(...)
      instead of compress2(..., Z_BEST_COMPRESSION) */
-  return compress(gl2ps->compress->dest, &gl2ps->compress->destLen, 
-                  gl2ps->compress->start, gl2ps->compress->srcLen);  
+  return compress(gl2ps->compress->dest, &gl2ps->compress->destLen,
+                  gl2ps->compress->start, gl2ps->compress->srcLen);
 }
 
 #endif
 
 static int gl2psPrintf(const char* fmt, ...)
 {
   int ret;
   va_list args;
@@ -451,17 +451,17 @@ static void gl2psPrintGzipHeader()
                   2, /* extra flags: max compression */
                   '\x03'}; /* OS code: 0x03 (Unix) */
 
   if(gl2ps->options & GL2PS_COMPRESS){
     gl2psSetupCompress();
     /* add the gzip file header */
     fwrite(tmp, 10, 1, gl2ps->stream);
   }
-#endif  
+#endif
 }
 
 static void gl2psPrintGzipFooter()
 {
 #if defined(GL2PS_HAVE_ZLIB)
   int n;
   uLong crc, len;
   char tmp[8];
@@ -472,17 +472,17 @@ static void gl2psPrintGzipFooter()
     }
     else{
       /* determine the length of the header in the zlib stream */
       n = 2; /* CMF+FLG */
       if(gl2ps->compress->dest[1] & (1<<5)){
         n += 4; /* DICTID */
       }
       /* write the data, without the zlib header and footer */
-      fwrite(gl2ps->compress->dest+n, gl2ps->compress->destLen-(n+4), 
+      fwrite(gl2ps->compress->dest+n, gl2ps->compress->destLen-(n+4),
              1, gl2ps->stream);
       /* add the gzip file footer */
       crc = crc32(0L, gl2ps->compress->start, gl2ps->compress->srcLen);
       for(n = 0; n < 4; ++n){
         tmp[n] = (char)(crc & 0xff);
         crc >>= 8;
       }
       len = gl2ps->compress->srcLen;
@@ -491,17 +491,17 @@ static void gl2psPrintGzipFooter()
         len >>= 8;
       }
       fwrite(tmp, 8, 1, gl2ps->stream);
     }
     gl2psFreeCompress();
     gl2psFree(gl2ps->compress);
     gl2ps->compress = NULL;
   }
-#endif 
+#endif
 }
 
 /* The list handling routines */
 
 static void gl2psListRealloc(GL2PSlist *list, GLint n)
 {
   if(!list){
     gl2psMsg(GL2PS_ERROR, "Cannot reallocate NULL list");
@@ -540,17 +540,17 @@ static GL2PSlist *gl2psListCreate(GLint 
 static void gl2psListReset(GL2PSlist *list)
 {
   if(!list) return;
   list->n = 0;
 }
 
 static void gl2psListDelete(GL2PSlist *list)
 {
-  if(!list) return;  
+  if(!list) return;
   gl2psFree(list->array);
   gl2psFree(list);
 }
 
 static void gl2psListAdd(GL2PSlist *list, void *data)
 {
   if(!list){
     gl2psMsg(GL2PS_ERROR, "Cannot add into unallocated list");
@@ -613,17 +613,17 @@ static void gl2psListRead(GL2PSlist *lis
 {
   if((index < 0) || (index >= list->n))
     gl2psMsg(GL2PS_ERROR, "Wrong list index in gl2psListRead");
   memcpy(data, &list->array[index * list->size], list->size);
 }
 
 static void gl2psEncodeBase64Block(unsigned char in[3], unsigned char out[4], int len)
 {
-  static const char cb64[] = 
+  static const char cb64[] =
     "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
 
   out[0] = cb64[ in[0] >> 2 ];
   out[1] = cb64[ ((in[0] & 0x03) << 4) | ((in[1] & 0xf0) >> 4) ];
   out[2] = (len > 1) ? cb64[ ((in[1] & 0x0f) << 2) | ((in[2] & 0xc0) >> 6) ] : '=';
   out[3] = (len > 2) ? cb64[ in[2] & 0x3f ] : '=';
 }
 
@@ -666,17 +666,17 @@ static void gl2psListEncodeBase64(GL2PSl
 static GLboolean gl2psSameColor(GL2PSrgba rgba1, GL2PSrgba rgba2)
 {
   if(!GL2PS_ZERO(rgba1[0] - rgba2[0]) ||
      !GL2PS_ZERO(rgba1[1] - rgba2[1]) ||
      !GL2PS_ZERO(rgba1[2] - rgba2[2]))
     return GL_FALSE;
   return GL_TRUE;
 }
-  
+
 static GLboolean gl2psVertsSameColor(const GL2PSprimitive *prim)
 {
   int i;
 
   for(i = 1; i < prim->numverts; i++){
     if(!gl2psSameColor(prim->verts[0].rgba, prim->verts[i].rgba)){
       return GL_FALSE;
     }
@@ -685,45 +685,45 @@ static GLboolean gl2psVertsSameColor(con
 }
 
 static GLboolean gl2psSameColorThreshold(int n, GL2PSrgba rgba[],
                                          GL2PSrgba threshold)
 {
   int i;
 
   if(n < 2) return GL_TRUE;
-  
+
   for(i = 1; i < n; i++){
     if(fabs(rgba[0][0] - rgba[i][0]) > threshold[0] ||
        fabs(rgba[0][1] - rgba[i][1]) > threshold[1] ||
        fabs(rgba[0][2] - rgba[i][2]) > threshold[2])
       return GL_FALSE;
   }
-  
+
   return GL_TRUE;
 }
 
 static void gl2psSetLastColor(GL2PSrgba rgba)
 {
-  int i;        
+  int i;
   for(i = 0; i < 3; ++i){
     gl2ps->lastrgba[i] = rgba[i];
   }
 }
 
 static GLfloat gl2psGetRGB(GL2PSimage *im, GLuint x, GLuint y,
                            GLfloat *red, GLfloat *green, GLfloat *blue)
 {
-  
+
   GLsizei width = im->width;
   GLsizei height = im->height;
   GLfloat *pixels = im->pixels;
   GLfloat *pimag;
 
-  /* OpenGL image is from down to up, PS image is up to down */  
+  /* OpenGL image is from down to up, PS image is up to down */
   switch(im->format){
   case GL_RGBA:
     pimag = pixels + 4 * (width * (height - 1 - y) + x);
     break;
   case GL_RGB:
   default:
     pimag = pixels + 3 * (width * (height - 1 - y) + x);
     break;
@@ -736,17 +736,17 @@ static GLfloat gl2psGetRGB(GL2PSimage *i
 }
 
 /* Helper routines for pixmaps */
 
 static GL2PSimage *gl2psCopyPixmap(GL2PSimage *im)
 {
   int size;
   GL2PSimage *image = (GL2PSimage*)gl2psMalloc(sizeof(GL2PSimage));
-  
+
   image->width = im->width;
   image->height = im->height;
   image->format = im->format;
   image->type = im->type;
   image->zoom_x = im->zoom_x;
   image->zoom_y = im->zoom_y;
 
   switch(image->format){
@@ -756,17 +756,17 @@ static GL2PSimage *gl2psCopyPixmap(GL2PS
   case GL_RGB:
   default:
     size = image->height * image->width * 3 * sizeof(GLfloat);
     break;
   }
 
   image->pixels = (GLfloat*)gl2psMalloc(size);
   memcpy(image->pixels, im->pixels, size);
-  
+
   return image;
 }
 
 static void gl2psFreePixmap(GL2PSimage *im)
 {
   if(!im)
     return;
   gl2psFree(im->pixels);
@@ -778,17 +778,17 @@ static void gl2psFreePixmap(GL2PSimage *
 #if !defined(png_jmpbuf)
 #  define png_jmpbuf(png_ptr) ((png_ptr)->jmpbuf)
 #endif
 
 static void gl2psUserWritePNG(png_structp png_ptr, png_bytep data, png_size_t length)
 {
   unsigned int i;
   GL2PSlist *png = (GL2PSlist*)png_get_io_ptr(png_ptr);
-  for(i = 0; i < length; i++) 
+  for(i = 0; i < length; i++)
     gl2psListAdd(png, &data[i]);
 }
 
 static void gl2psUserFlushPNG(png_structp png_ptr)
 {
 }
 
 static void gl2psConvertPixmapToPNG(GL2PSimage *pixmap, GL2PSlist *png)
@@ -796,31 +796,31 @@ static void gl2psConvertPixmapToPNG(GL2P
   png_structp png_ptr;
   png_infop info_ptr;
   unsigned char *row_data;
   GLfloat dr, dg, db;
   int row, col;
 
   if(!(png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL)))
     return;
-  
+
   if(!(info_ptr = png_create_info_struct(png_ptr))){
     png_destroy_write_struct(&png_ptr, NULL);
     return;
   }
-  
+
   if(setjmp(png_jmpbuf(png_ptr))) {
     png_destroy_write_struct(&png_ptr, &info_ptr);
     return;
   }
-  
+
   png_set_write_fn(png_ptr, (void *)png, gl2psUserWritePNG, gl2psUserFlushPNG);
   png_set_compression_level(png_ptr, Z_DEFAULT_COMPRESSION);
-  png_set_IHDR(png_ptr, info_ptr, pixmap->width, pixmap->height, 8, 
-               PNG_COLOR_TYPE_RGB, PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_BASE, 
+  png_set_IHDR(png_ptr, info_ptr, pixmap->width, pixmap->height, 8,
+               PNG_COLOR_TYPE_RGB, PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_BASE,
                PNG_FILTER_TYPE_BASE);
   png_write_info(png_ptr, info_ptr);
 
   row_data = (unsigned char*)gl2psMalloc(3 * pixmap->width * sizeof(unsigned char));
   for(row = 0; row < pixmap->height; row++){
     for(col = 0; col < pixmap->width; col++){
       gl2psGetRGB(pixmap, col, row, &dr, &dg, &db);
       row_data[3*col] = (unsigned char)(255. * dr);
@@ -834,17 +834,17 @@ static void gl2psConvertPixmapToPNG(GL2P
   png_write_end(png_ptr, info_ptr);
   png_destroy_write_struct(&png_ptr, &info_ptr);
 }
 
 #endif
 
 /* Helper routines for text strings */
 
-static GLint gl2psAddText(GLint type, const char *str, const char *fontname, 
+static GLint gl2psAddText(GLint type, const char *str, const char *fontname,
                           GLshort fontsize, GLint alignment, GLfloat angle)
 {
   GLfloat pos[4];
   GL2PSprimitive *prim;
   GLboolean valid;
 
   if(!gl2ps || !str || !fontname) return GL2PS_UNINITIALIZED;
 
@@ -866,40 +866,40 @@ static GLint gl2psAddText(GLint type, co
   prim->culled = 0;
   prim->offset = 0;
   prim->pattern = 0;
   prim->factor = 0;
   prim->width = 1;
   glGetFloatv(GL_CURRENT_RASTER_COLOR, prim->verts[0].rgba);
   prim->data.text = (GL2PSstring*)gl2psMalloc(sizeof(GL2PSstring));
   prim->data.text->str = (char*)gl2psMalloc((strlen(str)+1)*sizeof(char));
-  strcpy(prim->data.text->str, str); 
+  strcpy(prim->data.text->str, str);
   prim->data.text->fontname = (char*)gl2psMalloc((strlen(fontname)+1)*sizeof(char));
   strcpy(prim->data.text->fontname, fontname);
   prim->data.text->fontsize = fontsize;
   prim->data.text->alignment = alignment;
   prim->data.text->angle = angle;
 
   gl2psListAdd(gl2ps->auxprimitives, &prim);
   glPassThrough(GL2PS_TEXT_TOKEN);
-    
+
   return GL2PS_SUCCESS;
 }
 
 static GL2PSstring *gl2psCopyText(GL2PSstring *t)
 {
   GL2PSstring *text = (GL2PSstring*)gl2psMalloc(sizeof(GL2PSstring));
   text->str = (char*)gl2psMalloc((strlen(t->str)+1)*sizeof(char));
-  strcpy(text->str, t->str); 
+  strcpy(text->str, t->str);
   text->fontname = (char*)gl2psMalloc((strlen(t->fontname)+1)*sizeof(char));
   strcpy(text->fontname, t->fontname);
   text->fontsize = t->fontsize;
   text->alignment = t->alignment;
   text->angle = t->angle;
-  
+
   return text;
 }
 
 static void gl2psFreeText(GL2PSstring *text)
 {
   if(!text)
     return;
   gl2psFree(text->str);
@@ -909,17 +909,17 @@ static void gl2psFreeText(GL2PSstring *t
 
 /* Helpers for blending modes */
 
 static GLboolean gl2psSupportedBlendMode(GLenum sfactor, GLenum dfactor)
 {
   /* returns TRUE if gl2ps supports the argument combination: only two
      blending modes have been implemented so far */
 
-  if( (sfactor == GL_SRC_ALPHA && dfactor == GL_ONE_MINUS_SRC_ALPHA) || 
+  if( (sfactor == GL_SRC_ALPHA && dfactor == GL_ONE_MINUS_SRC_ALPHA) ||
       (sfactor == GL_ONE && dfactor == GL_ZERO) )
     return GL_TRUE;
   return GL_FALSE;
 }
 
 static void gl2psAdaptVertexForBlending(GL2PSvertex *v)
 {
   /* Transforms vertex depending on the actual blending function -
@@ -929,17 +929,17 @@ static void gl2psAdaptVertexForBlending(
 
   if(!v || !gl2ps)
     return;
 
   if(gl2ps->options & GL2PS_NO_BLENDING || !gl2ps->blending){
     v->rgba[3] = 1.0F;
     return;
   }
-  
+
   switch(gl2ps->blendfunc[0]){
   case GL_ONE:
     v->rgba[3] = 1.0F;
     break;
   default:
     break;
   }
 }
@@ -950,27 +950,27 @@ static void gl2psAssignTrianglePropertie
 
   t->prop = T_VAR_COLOR;
 
   /* Uncommenting the following lines activates an even more fine
      grained distinction between triangle types - please don't delete,
      a remarkable amount of PDF handling code inside this file depends
      on it if activated */
   /*
-  t->prop = T_CONST_COLOR;    
+  t->prop = T_CONST_COLOR;
   for(i = 0; i < 3; ++i){
-    if(!GL2PS_ZERO(t->vertex[0].rgba[i] - t->vertex[1].rgba[i]) || 
+    if(!GL2PS_ZERO(t->vertex[0].rgba[i] - t->vertex[1].rgba[i]) ||
        !GL2PS_ZERO(t->vertex[1].rgba[i] - t->vertex[2].rgba[i])){
       t->prop = T_VAR_COLOR;
       break;
     }
   }
   */
 
-  if(!GL2PS_ZERO(t->vertex[0].rgba[3] - t->vertex[1].rgba[3]) || 
+  if(!GL2PS_ZERO(t->vertex[0].rgba[3] - t->vertex[1].rgba[3]) ||
      !GL2PS_ZERO(t->vertex[1].rgba[3] - t->vertex[2].rgba[3])){
     t->prop |= T_VAR_ALPHA;
   }
   else{
     if(t->vertex[0].rgba[3] < 1)
       t->prop |= T_ALPHA_LESS_1;
     else
       t->prop |= T_ALPHA_1;
@@ -1003,17 +1003,17 @@ static GL2PSprimitive *gl2psCopyPrimitiv
   GL2PSprimitive *prim;
 
   if(!p){
     gl2psMsg(GL2PS_ERROR, "Trying to copy an empty primitive");
     return NULL;
   }
 
   prim = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
-  
+
   prim->type = p->type;
   prim->numverts = p->numverts;
   prim->boundary = p->boundary;
   prim->offset = p->offset;
   prim->pattern = p->pattern;
   prim->factor = p->factor;
   prim->culled = p->culled;
   prim->width = p->width;
@@ -1039,27 +1039,27 @@ static GLboolean gl2psSamePosition(GL2PS
 {
   if(!GL2PS_ZERO(p1[0] - p2[0]) ||
      !GL2PS_ZERO(p1[1] - p2[1]) ||
      !GL2PS_ZERO(p1[2] - p2[2]))
     return GL_FALSE;
   return GL_TRUE;
 }
 
-/********************************************************************* 
+/*********************************************************************
  *
- * 3D sorting routines 
+ * 3D sorting routines
  *
  *********************************************************************/
 
 static GLfloat gl2psComparePointPlane(GL2PSxyz point, GL2PSplane plane)
 {
-  return (plane[0] * point[0] + 
-          plane[1] * point[1] + 
-          plane[2] * point[2] + 
+  return (plane[0] * point[0] +
+          plane[1] * point[1] +
+          plane[2] * point[2] +
           plane[3]);
 }
 
 static GLfloat gl2psPsca(GLfloat *a, GLfloat *b)
 {
   return (a[0]*b[0] + a[1]*b[1] + a[2]*b[2]);
 }
 
@@ -1096,53 +1096,53 @@ static void gl2psGetNormal(GLfloat *a, G
 
 static void gl2psGetPlane(GL2PSprimitive *prim, GL2PSplane plane)
 {
   GL2PSxyz v = {0.0F, 0.0F, 0.0F}, w = {0.0F, 0.0F, 0.0F};
 
   switch(prim->type){
   case GL2PS_TRIANGLE :
   case GL2PS_QUADRANGLE :
-    v[0] = prim->verts[1].xyz[0] - prim->verts[0].xyz[0]; 
-    v[1] = prim->verts[1].xyz[1] - prim->verts[0].xyz[1]; 
-    v[2] = prim->verts[1].xyz[2] - prim->verts[0].xyz[2]; 
-    w[0] = prim->verts[2].xyz[0] - prim->verts[0].xyz[0]; 
-    w[1] = prim->verts[2].xyz[1] - prim->verts[0].xyz[1]; 
-    w[2] = prim->verts[2].xyz[2] - prim->verts[0].xyz[2]; 
-    if((GL2PS_ZERO(v[0]) && GL2PS_ZERO(v[1]) && GL2PS_ZERO(v[2])) || 
+    v[0] = prim->verts[1].xyz[0] - prim->verts[0].xyz[0];
+    v[1] = prim->verts[1].xyz[1] - prim->verts[0].xyz[1];
+    v[2] = prim->verts[1].xyz[2] - prim->verts[0].xyz[2];
+    w[0] = prim->verts[2].xyz[0] - prim->verts[0].xyz[0];
+    w[1] = prim->verts[2].xyz[1] - prim->verts[0].xyz[1];
+    w[2] = prim->verts[2].xyz[2] - prim->verts[0].xyz[2];
+    if((GL2PS_ZERO(v[0]) && GL2PS_ZERO(v[1]) && GL2PS_ZERO(v[2])) ||
        (GL2PS_ZERO(w[0]) && GL2PS_ZERO(w[1]) && GL2PS_ZERO(w[2]))){
       plane[0] = plane[1] = 0.0F;
       plane[2] = 1.0F;
       plane[3] = -prim->verts[0].xyz[2];
     }
     else{
       gl2psGetNormal(v, w, plane);
-      plane[3] = 
-        - plane[0] * prim->verts[0].xyz[0] 
-        - plane[1] * prim->verts[0].xyz[1] 
+      plane[3] =
+        - plane[0] * prim->verts[0].xyz[0]
+        - plane[1] * prim->verts[0].xyz[1]
         - plane[2] * prim->verts[0].xyz[2];
     }
     break;
   case GL2PS_LINE :
-    v[0] = prim->verts[1].xyz[0] - prim->verts[0].xyz[0]; 
-    v[1] = prim->verts[1].xyz[1] - prim->verts[0].xyz[1]; 
-    v[2] = prim->verts[1].xyz[2] - prim->verts[0].xyz[2]; 
+    v[0] = prim->verts[1].xyz[0] - prim->verts[0].xyz[0];
+    v[1] = prim->verts[1].xyz[1] - prim->verts[0].xyz[1];
+    v[2] = prim->verts[1].xyz[2] - prim->verts[0].xyz[2];
     if(GL2PS_ZERO(v[0]) && GL2PS_ZERO(v[1]) && GL2PS_ZERO(v[2])){
       plane[0] = plane[1] = 0.0F;
       plane[2] = 1.0F;
       plane[3] = -prim->verts[0].xyz[2];
     }
     else{
       if(GL2PS_ZERO(v[0]))      w[0] = 1.0F;
       else if(GL2PS_ZERO(v[1])) w[1] = 1.0F;
       else                      w[2] = 1.0F;
       gl2psGetNormal(v, w, plane);
-      plane[3] = 
-        - plane[0] * prim->verts[0].xyz[0] 
-        - plane[1] * prim->verts[0].xyz[1] 
+      plane[3] =
+        - plane[0] * prim->verts[0].xyz[0]
+        - plane[1] * prim->verts[0].xyz[1]
         - plane[2] * prim->verts[0].xyz[2];
     }
     break;
   case GL2PS_POINT :
   case GL2PS_PIXMAP :
   case GL2PS_TEXT :
   case GL2PS_SPECIAL :
   case GL2PS_IMAGEMAP:
@@ -1167,21 +1167,21 @@ static void gl2psCutEdge(GL2PSvertex *a,
   v[0] = b->xyz[0] - a->xyz[0];
   v[1] = b->xyz[1] - a->xyz[1];
   v[2] = b->xyz[2] - a->xyz[2];
 
   if(!GL2PS_ZERO(psca = gl2psPsca(plane, v)))
     sect = -gl2psComparePointPlane(a->xyz, plane) / psca;
   else
     sect = 0.0F;
-  
+
   c->xyz[0] = a->xyz[0] + v[0] * sect;
   c->xyz[1] = a->xyz[1] + v[1] * sect;
   c->xyz[2] = a->xyz[2] + v[2] * sect;
-  
+
   c->rgba[0] = (1 - sect) * a->rgba[0] + sect * b->rgba[0];
   c->rgba[1] = (1 - sect) * a->rgba[1] + sect * b->rgba[1];
   c->rgba[2] = (1 - sect) * a->rgba[2] + sect * b->rgba[2];
   c->rgba[3] = (1 - sect) * a->rgba[3] + sect * b->rgba[3];
 }
 
 static void gl2psCreateSplitPrimitive(GL2PSprimitive *parent, GL2PSplane plane,
                                       GL2PSprimitive *child, GLshort numverts,
@@ -1194,20 +1194,20 @@ static void gl2psCreateSplitPrimitive(GL
     child->data.image = parent->data.image;
   }
   else{
     if(numverts > 4){
       gl2psMsg(GL2PS_WARNING, "%d vertices in polygon", numverts);
       numverts = 4;
     }
     switch(numverts){
-    case 1 : child->type = GL2PS_POINT; break; 
-    case 2 : child->type = GL2PS_LINE; break; 
-    case 3 : child->type = GL2PS_TRIANGLE; break; 
-    case 4 : child->type = GL2PS_QUADRANGLE; break;    
+    case 1 : child->type = GL2PS_POINT; break;
+    case 2 : child->type = GL2PS_LINE; break;
+    case 3 : child->type = GL2PS_TRIANGLE; break;
+    case 4 : child->type = GL2PS_QUADRANGLE; break;
     default: child->type = GL2PS_NO_TYPE; break;
     }
   }
 
   child->boundary = 0; /* FIXME: not done! */
   child->culled = parent->culled;
   child->offset = parent->offset;
   child->pattern = parent->pattern;
@@ -1216,23 +1216,23 @@ static void gl2psCreateSplitPrimitive(GL
   child->numverts = numverts;
   child->verts = (GL2PSvertex*)gl2psMalloc(numverts * sizeof(GL2PSvertex));
 
   for(i = 0; i < numverts; i++){
     if(index1[i] < 0){
       child->verts[i] = parent->verts[index0[i]];
     }
     else{
-      gl2psCutEdge(&parent->verts[index0[i]], &parent->verts[index1[i]], 
+      gl2psCutEdge(&parent->verts[index0[i]], &parent->verts[index1[i]],
                    plane, &child->verts[i]);
     }
   }
 }
 
-static void gl2psAddIndex(GLshort *index0, GLshort *index1, GLshort *nb, 
+static void gl2psAddIndex(GLshort *index0, GLshort *index1, GLshort *nb,
                           GLshort i, GLshort j)
 {
   GLint k;
 
   for(k = 0; k < *nb; k++){
     if((index0[k] == i && index1[k] == j) ||
        (index1[k] == i && index0[k] == j)) return;
   }
@@ -1245,77 +1245,77 @@ static GLshort gl2psGetIndex(GLshort i, 
 {
   return (i < num - 1) ? i + 1 : 0;
 }
 
 static GLint gl2psTestSplitPrimitive(GL2PSprimitive *prim, GL2PSplane plane)
 {
   GLint type = GL2PS_COINCIDENT;
   GLshort i, j;
-  GLfloat d[5]; 
-
-  for(i = 0; i < prim->numverts; i++){  
+  GLfloat d[5];
+
+  for(i = 0; i < prim->numverts; i++){
     d[i] = gl2psComparePointPlane(prim->verts[i].xyz, plane);
   }
 
   if(prim->numverts < 2){
     return 0;
   }
   else{
     for(i = 0; i < prim->numverts; i++){
       j = gl2psGetIndex(i, prim->numverts);
       if(d[j] > GL2PS_EPSILON){
         if(type == GL2PS_COINCIDENT)      type = GL2PS_IN_BACK_OF;
-        else if(type != GL2PS_IN_BACK_OF) return 1; 
+        else if(type != GL2PS_IN_BACK_OF) return 1;
         if(d[i] < -GL2PS_EPSILON)         return 1;
       }
       else if(d[j] < -GL2PS_EPSILON){
-        if(type == GL2PS_COINCIDENT)       type = GL2PS_IN_FRONT_OF;   
+        if(type == GL2PS_COINCIDENT)       type = GL2PS_IN_FRONT_OF;
         else if(type != GL2PS_IN_FRONT_OF) return 1;
         if(d[i] > GL2PS_EPSILON)           return 1;
       }
     }
   }
   return 0;
 }
 
-static GLint gl2psSplitPrimitive(GL2PSprimitive *prim, GL2PSplane plane, 
+static GLint gl2psSplitPrimitive(GL2PSprimitive *prim, GL2PSplane plane,
                                  GL2PSprimitive **front, GL2PSprimitive **back)
 {
   GLshort i, j, in = 0, out = 0, in0[5], in1[5], out0[5], out1[5];
   GLint type;
-  GLfloat d[5]; 
+  GLfloat d[5];
 
   type = GL2PS_COINCIDENT;
 
-  for(i = 0; i < prim->numverts; i++){  
+  for(i = 0; i < prim->numverts; i++){
     d[i] = gl2psComparePointPlane(prim->verts[i].xyz, plane);
   }
 
   switch(prim->type){
   case GL2PS_POINT :
     if(d[0] > GL2PS_EPSILON)       type = GL2PS_IN_BACK_OF;
     else if(d[0] < -GL2PS_EPSILON) type = GL2PS_IN_FRONT_OF;
     else                           type = GL2PS_COINCIDENT;
     break;
   default :
     for(i = 0; i < prim->numverts; i++){
       j = gl2psGetIndex(i, prim->numverts);
       if(d[j] > GL2PS_EPSILON){
         if(type == GL2PS_COINCIDENT)      type = GL2PS_IN_BACK_OF;
-        else if(type != GL2PS_IN_BACK_OF) type = GL2PS_SPANNING; 
+        else if(type != GL2PS_IN_BACK_OF) type = GL2PS_SPANNING;
         if(d[i] < -GL2PS_EPSILON){
           gl2psAddIndex(in0, in1, &in, i, j);
           gl2psAddIndex(out0, out1, &out, i, j);
           type = GL2PS_SPANNING;
         }
         gl2psAddIndex(out0, out1, &out, j, -1);
       }
       else if(d[j] < -GL2PS_EPSILON){
-        if(type == GL2PS_COINCIDENT)       type = GL2PS_IN_FRONT_OF;   
+        if(type == GL2PS_COINCIDENT)       type = GL2PS_IN_FRONT_OF;
         else if(type != GL2PS_IN_FRONT_OF) type = GL2PS_SPANNING;
         if(d[i] > GL2PS_EPSILON){
           gl2psAddIndex(in0, in1, &in, i, j);
           gl2psAddIndex(out0, out1, &out, i, j);
           type = GL2PS_SPANNING;
         }
         gl2psAddIndex(in0, in1, &in, j, -1);
       }
@@ -1332,17 +1332,17 @@ static GLint gl2psSplitPrimitive(GL2PSpr
     *front = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
     gl2psCreateSplitPrimitive(prim, plane, *back, out, out0, out1);
     gl2psCreateSplitPrimitive(prim, plane, *front, in, in0, in1);
   }
 
   return type;
 }
 
-static void gl2psDivideQuad(GL2PSprimitive *quad, 
+static void gl2psDivideQuad(GL2PSprimitive *quad,
                             GL2PSprimitive **t1, GL2PSprimitive **t2)
 {
   *t1 = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
   *t2 = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
   (*t1)->type = (*t2)->type = GL2PS_TRIANGLE;
   (*t1)->numverts = (*t2)->numverts = 3;
   (*t1)->culled = (*t2)->culled = quad->culled;
   (*t1)->offset = (*t2)->offset = quad->offset;
@@ -1361,27 +1361,27 @@ static void gl2psDivideQuad(GL2PSprimiti
   (*t2)->boundary = ((quad->boundary & 4) ? 2 : 0) | ((quad->boundary & 4) ? 2 : 0);
 }
 
 static int gl2psCompareDepth(const void *a, const void *b)
 {
   GL2PSprimitive *q, *w;
   GLfloat dq = 0.0F, dw = 0.0F, diff;
   int i;
-  
+
   q = *(GL2PSprimitive**)a;
   w = *(GL2PSprimitive**)b;
 
   for(i = 0; i < q->numverts; i++){
-    dq += q->verts[i].xyz[2]; 
+    dq += q->verts[i].xyz[2];
   }
   dq /= (GLfloat)q->numverts;
 
   for(i = 0; i < w->numverts; i++){
-    dw += w->verts[i].xyz[2]; 
+    dw += w->verts[i].xyz[2];
   }
   dw /= (GLfloat)w->numverts;
 
   diff = dq - dw;
   if(diff > 0.){
     return -1;
   }
   else if(diff < 0.){
@@ -1422,17 +1422,17 @@ static GLint gl2psFindRoot(GL2PSlist *pr
     }
     for(i = 0; i < maxp; i++){
       prim1 = *(GL2PSprimitive**)gl2psListPointer(primitives, i);
       gl2psGetPlane(prim1, plane);
       count = 0;
       for(j = 0; j < gl2psListNbr(primitives); j++){
         if(j != i){
           prim2 = *(GL2PSprimitive**)gl2psListPointer(primitives, j);
-          count += gl2psTestSplitPrimitive(prim2, plane); 
+          count += gl2psTestSplitPrimitive(prim2, plane);
         }
         if(count > best) break;
       }
       if(count < best){
         best = count;
         index = i;
         *root = prim1;
         if(!count) return index;
@@ -1456,17 +1456,17 @@ static void gl2psFreeImagemap(GL2PSimage
     gl2psFree(list);
     list = next;
   }
 }
 
 static void gl2psFreePrimitive(void *data)
 {
   GL2PSprimitive *q;
-  
+
   q = *(GL2PSprimitive**)data;
   gl2psFree(q->verts);
   if(q->type == GL2PS_TEXT || q->type == GL2PS_SPECIAL){
     gl2psFreeText(q->data.text);
   }
   else if(q->type == GL2PS_PIXMAP){
     gl2psFreePixmap(q->data.image);
   }
@@ -1481,17 +1481,17 @@ static void gl2psAddPrimitiveInList(GL2P
     gl2psListAdd(list, &prim);
   }
   else{
     gl2psDivideQuad(prim, &t1, &t2);
     gl2psListAdd(list, &t1);
     gl2psListAdd(list, &t2);
     gl2psFreePrimitive(&prim);
   }
-  
+
 }
 
 static void gl2psFreeBspTree(GL2PSbsptree **tree)
 {
   if(*tree){
     if((*tree)->back) gl2psFreeBspTree(&(*tree)->back);
     if((*tree)->primitives){
       gl2psListAction((*tree)->primitives, gl2psFreePrimitive);
@@ -1593,17 +1593,17 @@ static void gl2psTraverseBspTree(GL2PSbs
     if(inverse){
       gl2psListActionInverse(tree->primitives, action);
     }
     else{
       gl2psListAction(tree->primitives, action);
     }
     gl2psTraverseBspTree(tree->front, eye, epsilon, compare, action, inverse);
   }
-  else if(GL_TRUE == compare(-epsilon, result)){ 
+  else if(GL_TRUE == compare(-epsilon, result)){
     gl2psTraverseBspTree(tree->front, eye, epsilon, compare, action, inverse);
     if(inverse){
       gl2psListActionInverse(tree->primitives, action);
     }
     else{
       gl2psListAction(tree->primitives, action);
     }
     gl2psTraverseBspTree(tree->back, eye, epsilon, compare, action, inverse);
@@ -1661,28 +1661,28 @@ static void gl2psRescaleAndOffset()
       else{
         prim->verts[0].xyz[2] -= GL2PS_ZOFFSET;
         prim->verts[1].xyz[2] -= GL2PS_ZOFFSET;
       }
     }
     else if(prim->offset && (prim->type == GL2PS_TRIANGLE)){
       factor = gl2ps->offset[0];
       units = gl2ps->offset[1];
-      area = 
-        (prim->verts[1].xyz[0] - prim->verts[0].xyz[0]) * 
-        (prim->verts[2].xyz[1] - prim->verts[1].xyz[1]) - 
-        (prim->verts[2].xyz[0] - prim->verts[1].xyz[0]) * 
+      area =
+        (prim->verts[1].xyz[0] - prim->verts[0].xyz[0]) *
+        (prim->verts[2].xyz[1] - prim->verts[1].xyz[1]) -
+        (prim->verts[2].xyz[0] - prim->verts[1].xyz[0]) *
         (prim->verts[1].xyz[1] - prim->verts[0].xyz[1]);
       if(!GL2PS_ZERO(area)){
-        dZdX = 
+        dZdX =
           ((prim->verts[2].xyz[1] - prim->verts[1].xyz[1]) *
            (prim->verts[1].xyz[2] - prim->verts[0].xyz[2]) -
            (prim->verts[1].xyz[1] - prim->verts[0].xyz[1]) *
            (prim->verts[2].xyz[2] - prim->verts[1].xyz[2])) / area;
-        dZdY = 
+        dZdY =
           ((prim->verts[1].xyz[0] - prim->verts[0].xyz[0]) *
            (prim->verts[2].xyz[2] - prim->verts[1].xyz[2]) -
            (prim->verts[2].xyz[0] - prim->verts[1].xyz[0]) *
            (prim->verts[1].xyz[2] - prim->verts[0].xyz[2])) / area;
         maxdZ = (GLfloat)sqrt(dZdX * dZdX + dZdY * dZdY);
       }
       else{
         maxdZ = 0.0F;
@@ -1690,34 +1690,34 @@ static void gl2psRescaleAndOffset()
       dZ = factor * maxdZ + units;
       prim->verts[0].xyz[2] += dZ;
       prim->verts[1].xyz[2] += dZ;
       prim->verts[2].xyz[2] += dZ;
     }
   }
 }
 
-/********************************************************************* 
+/*********************************************************************
  *
- * 2D sorting routines (for occlusion culling) 
+ * 2D sorting routines (for occlusion culling)
  *
  *********************************************************************/
 
 static GLint gl2psGetPlaneFromPoints(GL2PSxyz a, GL2PSxyz b, GL2PSplane plane)
 {
-  GLfloat n; 
+  GLfloat n;
 
   plane[0] = b[1] - a[1];
   plane[1] = a[0] - b[0];
   n = (GLfloat)sqrt(plane[0]*plane[0] + plane[1]*plane[1]);
   plane[2] = 0.0F;
   if(!GL2PS_ZERO(n)){
     plane[0] /= n;
     plane[1] /= n;
-    plane[3] = -plane[0]*a[0]-plane[1]*a[1]; 
+    plane[3] = -plane[0]*a[0]-plane[1]*a[1];
     return 1;
   }
   else{
     plane[0] = -1.0F;
     plane[1] = 0.0F;
     plane[3] = a[0];
     return 0;
   }
@@ -1892,47 +1892,47 @@ static GL2PSprimitive *gl2psCreateSplitP
   child->verts = (GL2PSvertex*)gl2psMalloc(numverts * sizeof(GL2PSvertex));
   for(i = 0; i < numverts; i++){
     child->verts[i] = vertx[i];
   }
   return child;
 }
 
 static void gl2psSplitPrimitive2D(GL2PSprimitive *prim,
-                                  GL2PSplane plane, 
-                                  GL2PSprimitive **front, 
+                                  GL2PSplane plane,
+                                  GL2PSprimitive **front,
                                   GL2PSprimitive **back)
 {
   /* cur will hold the position of the current vertex
      prev will hold the position of the previous vertex
      prev0 will hold the position of the vertex number 0
      v1 and v2 represent the current and previous vertices, respectively
      flag is set if the current vertex should be checked against the plane */
   GLint cur = -1, prev = -1, i, v1 = 0, v2 = 0, flag = 1, prev0 = -1;
-  
+
   /* list of vertices that will go in front and back primitive */
   GL2PSvertex *front_list = NULL, *back_list = NULL;
-  
+
   /* number of vertices in front and back list */
   GLshort front_count = 0, back_count = 0;
 
   for(i = 0; i <= prim->numverts; i++){
     v1 = i;
     if(v1 == prim->numverts){
       if(prim->numverts < 3) break;
       v1 = 0;
       v2 = prim->numverts - 1;
       cur = prev0;
     }
     else if(flag){
       cur = gl2psCheckPoint(prim->verts[v1].xyz, plane);
       if(i == 0){
         prev0 = cur;
       }
-    } 
+    }
     if(((prev == -1) || (prev == cur) || (prev == 0) || (cur == 0)) &&
        (i < prim->numverts)){
       if(cur == GL2PS_POINT_INFRONT){
         front_count++;
         front_list = (GL2PSvertex*)gl2psRealloc(front_list,
                                                 sizeof(GL2PSvertex)*front_count);
         front_list[front_count-1] = prim->verts[v1];
       }
@@ -1977,36 +1977,36 @@ static void gl2psSplitPrimitive2D(GL2PSp
   gl2psFree(front_list);
   gl2psFree(back_list);
 }
 
 static GLint gl2psAddInBspImageTree(GL2PSprimitive *prim, GL2PSbsptree2d **tree)
 {
   GLint ret = 0;
   GL2PSprimitive *frontprim = NULL, *backprim = NULL;
-  
+
   /* FIXME: until we consider the actual extent of text strings and
      pixmaps, never cull them. Otherwise the whole string/pixmap gets
      culled as soon as the reference point is hidden */
-  if(prim->type == GL2PS_PIXMAP || 
-     prim->type == GL2PS_TEXT || 
+  if(prim->type == GL2PS_PIXMAP ||
+     prim->type == GL2PS_TEXT ||
      prim->type == GL2PS_SPECIAL){
     return 1;
   }
 
   if(*tree == NULL){
     if((prim->type != GL2PS_IMAGEMAP) && (GL_FALSE == gl2ps->zerosurfacearea)){
       gl2psAddPlanesInBspTreeImage(gl2ps->primitivetoadd, tree);
     }
     return 1;
   }
   else{
     switch(gl2psCheckPrimitive(prim, (*tree)->plane)){
     case GL2PS_IN_BACK_OF: return gl2psAddInBspImageTree(prim, &(*tree)->back);
-    case GL2PS_IN_FRONT_OF: 
+    case GL2PS_IN_FRONT_OF:
       if((*tree)->front != NULL) return gl2psAddInBspImageTree(prim, &(*tree)->front);
       else                       return 0;
     case GL2PS_SPANNING:
       gl2psSplitPrimitive2D(prim, (*tree)->plane, &frontprim, &backprim);
       ret = gl2psAddInBspImageTree(backprim, &(*tree)->back);
       if((*tree)->front != NULL){
         if(gl2psAddInBspImageTree(frontprim, &(*tree)->front)){
           ret = 1;
@@ -2131,24 +2131,24 @@ static void gl2psBuildPolygonBoundary(GL
   gl2psBuildPolygonBoundary(tree->back);
   for(i = 0; i < gl2psListNbr(tree->primitives); i++){
     prim = *(GL2PSprimitive**)gl2psListPointer(tree->primitives, i);
     if(prim->boundary) gl2psAddBoundaryInList(prim, tree->primitives);
   }
   gl2psBuildPolygonBoundary(tree->front);
 }
 
-/********************************************************************* 
+/*********************************************************************
  *
  * Feedback buffer parser
  *
  *********************************************************************/
 
-static void gl2psAddPolyPrimitive(GLshort type, GLshort numverts, 
-                                  GL2PSvertex *verts, GLint offset, 
+static void gl2psAddPolyPrimitive(GLshort type, GLshort numverts,
+                                  GL2PSvertex *verts, GLint offset,
                                   GLushort pattern, GLint factor,
                                   GLfloat width, char boundary)
 {
   GL2PSprimitive *prim;
 
   prim = (GL2PSprimitive*)gl2psMalloc(sizeof(GL2PSprimitive));
   prim->type = type;
   prim->numverts = numverts;
@@ -2205,38 +2205,38 @@ static void gl2psParseFeedbackBuffer(GLi
   GL2PSimagemap *node;
 
   current = gl2ps->feedback;
   boundary = gl2ps->boundary = GL_FALSE;
 
   while(used > 0){
 
     if(GL_TRUE == boundary) gl2ps->boundary = GL_TRUE;
-    
+
     switch((GLint)*current){
     case GL_POINT_TOKEN :
       current ++;
       used --;
       i = gl2psGetVertex(&vertices[0], current);
       current += i;
       used    -= i;
-      gl2psAddPolyPrimitive(GL2PS_POINT, 1, vertices, 0, 
+      gl2psAddPolyPrimitive(GL2PS_POINT, 1, vertices, 0,
                             pattern, factor, psize, 0);
       break;
     case GL_LINE_TOKEN :
     case GL_LINE_RESET_TOKEN :
       current ++;
       used --;
       i = gl2psGetVertex(&vertices[0], current);
       current += i;
       used    -= i;
       i = gl2psGetVertex(&vertices[1], current);
       current += i;
       used    -= i;
-      gl2psAddPolyPrimitive(GL2PS_LINE, 2, vertices, 0, 
+      gl2psAddPolyPrimitive(GL2PS_LINE, 2, vertices, 0,
                             pattern, factor, lwidth, 0);
       break;
     case GL_POLYGON_TOKEN :
       count = (GLint)current[1];
       current += 2;
       used -= 2;
       v = vtot = 0;
       while(count > 0 && used > 0){
@@ -2257,94 +2257,94 @@ static void gl2psParseFeedbackBuffer(GLi
             flag = 0;
           gl2psAddPolyPrimitive(GL2PS_TRIANGLE, 3, vertices, offset,
                                 pattern, factor, 1, flag);
           vertices[1] = vertices[2];
         }
         else
           v ++;
       }
-      break;      
+      break;
     case GL_BITMAP_TOKEN :
     case GL_DRAW_PIXEL_TOKEN :
     case GL_COPY_PIXEL_TOKEN :
       current ++;
       used --;
       i = gl2psGetVertex(&vertices[0], current);
       current += i;
       used    -= i;
-      break;      
+      break;
     case GL_PASS_THROUGH_TOKEN :
       switch((GLint)current[1]){
       case GL2PS_BEGIN_OFFSET_TOKEN : offset = 1; break;
       case GL2PS_END_OFFSET_TOKEN : offset = 0; break;
       case GL2PS_BEGIN_BOUNDARY_TOKEN : boundary = GL_TRUE; break;
       case GL2PS_END_BOUNDARY_TOKEN : boundary = GL_FALSE; break;
       case GL2PS_END_STIPPLE_TOKEN : pattern = factor = 0; break;
       case GL2PS_BEGIN_BLEND_TOKEN : gl2ps->blending = GL_TRUE; break;
       case GL2PS_END_BLEND_TOKEN : gl2ps->blending = GL_FALSE; break;
-      case GL2PS_BEGIN_STIPPLE_TOKEN : 
+      case GL2PS_BEGIN_STIPPLE_TOKEN :
         current += 2;
-        used -= 2; 
-        pattern = (GLushort)current[1]; 
+        used -= 2;
+        pattern = (GLushort)current[1];
         current += 2;
-        used -= 2; 
-        factor = (GLint)current[1]; 
+        used -= 2;
+        factor = (GLint)current[1];
         break;
-      case GL2PS_SRC_BLEND_TOKEN : 
-        current += 2; 
-        used -= 2; 
+      case GL2PS_SRC_BLEND_TOKEN :
+        current += 2;
+        used -= 2;
         gl2ps->blendfunc[0] = (GLint)current[1];
         break;
-      case GL2PS_DST_BLEND_TOKEN : 
-        current += 2; 
-        used -= 2; 
+      case GL2PS_DST_BLEND_TOKEN :
+        current += 2;
+        used -= 2;
         gl2ps->blendfunc[1] = (GLint)current[1];
         break;
-      case GL2PS_POINT_SIZE_TOKEN : 
-        current += 2; 
-        used -= 2; 
+      case GL2PS_POINT_SIZE_TOKEN :
+        current += 2;
+        used -= 2;
         psize = current[1];
         break;
-      case GL2PS_LINE_WIDTH_TOKEN : 
-        current += 2; 
-        used -= 2; 
+      case GL2PS_LINE_WIDTH_TOKEN :
+        current += 2;
+        used -= 2;
         lwidth = current[1];
         break;
       case GL2PS_IMAGEMAP_TOKEN :
         prim = (GL2PSprimitive *)gl2psMalloc(sizeof(GL2PSprimitive));
         prim->type = GL2PS_IMAGEMAP;
         prim->boundary = 0;
         prim->numverts = 4;
         prim->verts = (GL2PSvertex *)gl2psMalloc(4 * sizeof(GL2PSvertex));
         prim->culled = 0;
         prim->offset = 0;
         prim->pattern = 0;
         prim->factor = 0;
         prim->width = 1;
-        
+
         node = (GL2PSimagemap*)gl2psMalloc(sizeof(GL2PSimagemap));
         node->image = (GL2PSimage*)gl2psMalloc(sizeof(GL2PSimage));
         node->image->type = 0;
         node->image->format = 0;
         node->image->zoom_x = 1.0F;
         node->image->zoom_y = 1.0F;
         node->next = NULL;
-        
+
         if(gl2ps->imagemap_head == NULL)
           gl2ps->imagemap_head = node;
         else
           gl2ps->imagemap_tail->next = node;
         gl2ps->imagemap_tail = node;
         prim->data.image = node->image;
-        
+
         current += 2; used -= 2;
         i = gl2psGetVertex(&prim->verts[0], &current[1]);
         current += i; used -= i;
-        
+
         node->image->width = (GLint)current[2];
         current += 2; used -= 2;
         node->image->height = (GLint)current[2];
         prim->verts[0].xyz[0] = prim->verts[0].xyz[0] - (int)(node->image->width / 2) + 0.5F;
         prim->verts[0].xyz[1] = prim->verts[0].xyz[1] - (int)(node->image->height / 2) + 0.5F;
         for(i = 1; i < 4; i++){
           for(v = 0; v < 3; v++){
             prim->verts[i].xyz[v] = prim->verts[0].xyz[v];
@@ -2354,56 +2354,56 @@ static void gl2psParseFeedbackBuffer(GLi
         }
         prim->verts[1].xyz[0] = prim->verts[1].xyz[0] + node->image->width;
         prim->verts[2].xyz[0] = prim->verts[1].xyz[0];
         prim->verts[2].xyz[1] = prim->verts[2].xyz[1] + node->image->height;
         prim->verts[3].xyz[1] = prim->verts[2].xyz[1];
 
         sizeoffloat = sizeof(GLfloat);
         v = 2 * sizeoffloat;
-        vtot = node->image->height + node->image->height * 
+        vtot = node->image->height + node->image->height *
           ((node->image->width - 1) / 8);
         node->image->pixels = (GLfloat*)gl2psMalloc(v + vtot);
         node->image->pixels[0] = prim->verts[0].xyz[0];
         node->image->pixels[1] = prim->verts[0].xyz[1];
-        
+
         for(i = 0; i < vtot; i += sizeoffloat){
           current += 2; used -= 2;
           if((vtot - i) >= 4)
             memcpy(&(((char*)(node->image->pixels))[i + v]), &(current[2]), sizeoffloat);
           else
             memcpy(&(((char*)(node->image->pixels))[i + v]), &(current[2]), vtot - i);
         }
         current++; used--;
         gl2psListAdd(gl2ps->primitives, &prim);
         break;
       case GL2PS_DRAW_PIXELS_TOKEN :
       case GL2PS_TEXT_TOKEN :
         if(auxindex < gl2psListNbr(gl2ps->auxprimitives))
-          gl2psListAdd(gl2ps->primitives, 
+          gl2psListAdd(gl2ps->primitives,
                        gl2psListPointer(gl2ps->auxprimitives, auxindex++));
         else
           gl2psMsg(GL2PS_ERROR, "Wrong number of auxiliary tokens in buffer");
         break;
       }
-      current += 2; 
-      used -= 2; 
-      break;      
+      current += 2;
+      used -= 2;
+      break;
     default :
       gl2psMsg(GL2PS_WARNING, "Unknown token in buffer");
       current ++;
       used --;
       break;
     }
   }
 
   gl2psListReset(gl2ps->auxprimitives);
 }
 
-/********************************************************************* 
+/*********************************************************************
  *
  * PostScript routines
  *
  *********************************************************************/
 
 static void gl2psWriteByte(unsigned char byte)
 {
   unsigned char h = byte / 16;
@@ -2423,36 +2423,36 @@ static void gl2psPrintPostScriptPixmap(G
   /* FIXME: should we define an option for these? Or just keep the
      8-bit per component case? */
   int greyscale = 0; /* set to 1 to output greyscale image */
   int nbit = 8; /* number of bits per color compoment (2, 4 or 8) */
 
   if((width <= 0) || (height <= 0)) return;
 
   gl2psPrintf("gsave\n");
-  gl2psPrintf("%.2f %.2f translate\n", x, y); 
+  gl2psPrintf("%.2f %.2f translate\n", x, y);
   gl2psPrintf("%.2f %.2f scale\n", width * im->zoom_x, height * im->zoom_y);
 
   if(greyscale){ /* greyscale */
-    gl2psPrintf("/picstr %d string def\n", width); 
-    gl2psPrintf("%d %d %d\n", width, height, 8); 
-    gl2psPrintf("[ %d 0 0 -%d 0 %d ]\n", width, height, height); 
+    gl2psPrintf("/picstr %d string def\n", width);
+    gl2psPrintf("%d %d %d\n", width, height, 8);
+    gl2psPrintf("[ %d 0 0 -%d 0 %d ]\n", width, height, height);
     gl2psPrintf("{ currentfile picstr readhexstring pop }\n");
     gl2psPrintf("image\n");
     for(row = 0; row < height; row++){
-      for(col = 0; col < width; col++){ 
+      for(col = 0; col < width; col++){
         gl2psGetRGB(im, col, row, &dr, &dg, &db);
         fgrey = (0.30F * dr + 0.59F * dg + 0.11F * db);
         grey = (unsigned char)(255. * fgrey);
         gl2psWriteByte(grey);
       }
       gl2psPrintf("\n");
     }
-    nbhex = width * height * 2; 
-    gl2psPrintf("%%%% nbhex digit          :%d\n", nbhex); 
+    nbhex = width * height * 2;
+    gl2psPrintf("%%%% nbhex digit          :%d\n", nbhex);
   }
   else if(nbit == 2){ /* color, 2 bits for r and g and b; rgbs following each other */
     nrgb = width  * 3;
     nbits = nrgb * nbit;
     nbyte = nbits / 8;
     if((nbyte * 8) != nbits) nbyte++;
     gl2psPrintf("/rgbstr %d string def\n", nbyte);
     gl2psPrintf("%d %d %d\n", width, height, nbit);
@@ -2463,42 +2463,42 @@ static void gl2psPrintPostScriptPixmap(G
     for(row = 0; row < height; row++){
       icase = 1;
       col = 0;
       b = 0;
       for(ibyte = 0; ibyte < nbyte; ibyte++){
         if(icase == 1) {
           if(col < width) {
             gl2psGetRGB(im, col, row, &dr, &dg, &db);
-          } 
+          }
           else {
             dr = dg = db = 0;
           }
           col++;
           red = (unsigned char)(3. * dr);
           green = (unsigned char)(3. * dg);
           blue = (unsigned char)(3. * db);
           b = red;
           b = (b<<2) + green;
           b = (b<<2) + blue;
           if(col < width) {
             gl2psGetRGB(im, col, row, &dr, &dg, &db);
-          } 
+          }
           else {
             dr = dg = db = 0;
           }
           col++;
           red = (unsigned char)(3. * dr);
           green = (unsigned char)(3. * dg);
           blue = (unsigned char)(3. * db);
           b = (b<<2) + red;
           gl2psWriteByte(b);
           b = 0;
           icase++;
-        } 
+        }
         else if(icase == 2) {
           b = green;
           b = (b<<2) + blue;
           if(col < width) {
             gl2psGetRGB(im, col, row, &dr, &dg, &db);
           }
           else {
             dr = dg = db = 0;
@@ -2507,17 +2507,17 @@ static void gl2psPrintPostScriptPixmap(G
           red = (unsigned char)(3. * dr);
           green = (unsigned char)(3. * dg);
           blue = (unsigned char)(3. * db);
           b = (b<<2) + red;
           b = (b<<2) + green;
           gl2psWriteByte(b);
           b = 0;
           icase++;
-        } 
+        }
         else if(icase == 3) {
           b = blue;
           if(col < width) {
             gl2psGetRGB(im, col, row, &dr, &dg, &db);
           }
           else {
             dr = dg = db = 0;
           }
@@ -2535,45 +2535,45 @@ static void gl2psPrintPostScriptPixmap(G
       }
       gl2psPrintf("\n");
     }
   }
   else if(nbit == 4){ /* color, 4 bits for r and g and b; rgbs following each other */
     nrgb = width  * 3;
     nbits = nrgb * nbit;
     nbyte = nbits / 8;
-    if((nbyte * 8) != nbits) nbyte++; 
+    if((nbyte * 8) != nbits) nbyte++;
     gl2psPrintf("/rgbstr %d string def\n", nbyte);
     gl2psPrintf("%d %d %d\n", width, height, nbit);
     gl2psPrintf("[ %d 0 0 -%d 0 %d ]\n", width, height, height);
     gl2psPrintf("{ currentfile rgbstr readhexstring pop }\n");
     gl2psPrintf("false 3\n");
     gl2psPrintf("colorimage\n");
     for(row = 0; row < height; row++){
       col = 0;
       icase = 1;
       for(ibyte = 0; ibyte < nbyte; ibyte++){
         if(icase == 1) {
           if(col < width) {
             gl2psGetRGB(im, col, row, &dr, &dg, &db);
-          } 
+          }
           else {
             dr = dg = db = 0;
           }
           col++;
           red = (unsigned char)(15. * dr);
           green = (unsigned char)(15. * dg);
           gl2psPrintf("%x%x", red, green);
           icase++;
-        } 
+        }
         else if(icase == 2) {
           blue = (unsigned char)(15. * db);
           if(col < width) {
             gl2psGetRGB(im, col, row, &dr, &dg, &db);
-          } 
+          }
           else {
             dr = dg = db = 0;
           }
           col++;
           red = (unsigned char)(15. * dr);
           gl2psPrintf("%x%x", blue, red);
           icase++;
         }
@@ -2586,49 +2586,49 @@ static void gl2psPrintPostScriptPixmap(G
       }
       gl2psPrintf("\n");
     }
   }
   else{ /* 8 bit for r and g and b */
     nbyte = width * 3;
     gl2psPrintf("/rgbstr %d string def\n", nbyte);
     gl2psPrintf("%d %d %d\n", width, height, 8);
-    gl2psPrintf("[ %d 0 0 -%d 0 %d ]\n", width, height, height); 
+    gl2psPrintf("[ %d 0 0 -%d 0 %d ]\n", width, height, height);
     gl2psPrintf("{ currentfile rgbstr readhexstring pop }\n");
     gl2psPrintf("false 3\n");
     gl2psPrintf("colorimage\n");
     for(row = 0; row < height; row++){
       for(col = 0; col < width; col++){
         gl2psGetRGB(im, col, row, &dr, &dg, &db);
         red = (unsigned char)(255. * dr);
         gl2psWriteByte(red);
         green = (unsigned char)(255. * dg);
         gl2psWriteByte(green);
         blue = (unsigned char)(255. * db);
         gl2psWriteByte(blue);
       }
       gl2psPrintf("\n");
     }
   }
-  
+
   gl2psPrintf("grestore\n");
 }
 
 static void gl2psPrintPostScriptImagemap(GLfloat x, GLfloat y,
                                          GLsizei width, GLsizei height,
                                          const unsigned char *imagemap){
   int i, size;
-  
+
   if((width <= 0) || (height <= 0)) return;
-  
+
   size = height + height * (width - 1) / 8;
-  
+
   gl2psPrintf("gsave\n");
   gl2psPrintf("%.2f %.2f translate\n", x, y);
-  gl2psPrintf("%d %d scale\n%d %d\ntrue\n", width, height,width, height); 
+  gl2psPrintf("%d %d scale\n%d %d\ntrue\n", width, height,width, height);
   gl2psPrintf("[ %d 0 0 -%d 0 %d ] {<", width, height);
   for(i = 0; i < size; i++){
     gl2psWriteByte(*imagemap);
     imagemap++;
   }
   gl2psPrintf(">} imagemask\ngrestore\n");
 }
 
@@ -2652,37 +2652,37 @@ static void gl2psPrintPostScriptHeader(v
 
   gl2psPrintf("%%%%Title: %s\n"
               "%%%%Creator: GL2PS %d.%d.%d%s, %s\n"
               "%%%%For: %s\n"
               "%%%%CreationDate: %s"
               "%%%%LanguageLevel: 3\n"
               "%%%%DocumentData: Clean7Bit\n"
               "%%%%Pages: 1\n",
-              gl2ps->title, GL2PS_MAJOR_VERSION, GL2PS_MINOR_VERSION, 
+              gl2ps->title, GL2PS_MAJOR_VERSION, GL2PS_MINOR_VERSION,
               GL2PS_PATCH_VERSION, GL2PS_EXTRA_VERSION, GL2PS_COPYRIGHT,
               gl2ps->producer, ctime(&now));
 
   if(gl2ps->format == GL2PS_PS){
     gl2psPrintf("%%%%Orientation: %s\n"
                 "%%%%DocumentMedia: Default %d %d 0 () ()\n",
                 (gl2ps->options & GL2PS_LANDSCAPE) ? "Landscape" : "Portrait",
                 (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[3] :
-                (int)gl2ps->viewport[2], 
-                (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[2] : 
+                (int)gl2ps->viewport[2],
+                (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[2] :
                 (int)gl2ps->viewport[3]);
   }
 
   gl2psPrintf("%%%%BoundingBox: %d %d %d %d\n"
               "%%%%EndComments\n",
-              (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[1] : 
+              (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[1] :
               (int)gl2ps->viewport[0],
               (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[0] :
               (int)gl2ps->viewport[1],
-              (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[3] : 
+              (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[3] :
               (int)gl2ps->viewport[2],
               (gl2ps->options & GL2PS_LANDSCAPE) ? (int)gl2ps->viewport[2] :
               (int)gl2ps->viewport[3]);
 
   /* RGB color: r g b C (replace C by G in output to change from rgb to gray)
      Grayscale: r g b G
      Font choose: size fontname FC
      Text string: (string) x y size fontname S??
@@ -2720,32 +2720,32 @@ static void gl2psPrintPostScriptHeader(v
               "/SCR{ FC moveto SW neg SH -2 div rmoveto show } BD\n"
               "/STL{ FC moveto 0 SH neg rmoveto show } BD\n"
               "/STC{ FC moveto SW -2 div SH neg rmoveto show } BD\n"
               "/STR{ FC moveto SW neg SH neg rmoveto show } BD\n");
 
   /* rotated text routines: same nameanem with R appended */
 
   gl2psPrintf("/FCT { FC translate 0 0 } BD\n"
-              "/SR  { gsave FCT moveto rotate show grestore } BD\n"  
+              "/SR  { gsave FCT moveto rotate show grestore } BD\n"
               "/SBCR{ gsave FCT moveto rotate SW -2 div 0 rmoveto show grestore } BD\n"
               "/SBRR{ gsave FCT moveto rotate SW neg 0 rmoveto show grestore } BD\n"
               "/SCLR{ gsave FCT moveto rotate 0 SH -2 div rmoveto show grestore} BD\n");
   gl2psPrintf("/SCCR{ gsave FCT moveto rotate SW -2 div SH -2 div rmoveto show grestore} BD\n"
               "/SCRR{ gsave FCT moveto rotate SW neg SH -2 div rmoveto show grestore} BD\n"
               "/STLR{ gsave FCT moveto rotate 0 SH neg rmoveto show grestore } BD\n"
               "/STCR{ gsave FCT moveto rotate SW -2 div SH neg rmoveto show grestore } BD\n"
               "/STRR{ gsave FCT moveto rotate SW neg SH neg rmoveto show grestore } BD\n");
 
   gl2psPrintf("/P  { newpath 0.0 360.0 arc closepath fill } BD\n"
               "/LS { newpath moveto } BD\n"
               "/L  { lineto } BD\n"
               "/LE { lineto stroke } BD\n"
               "/T  { newpath moveto lineto lineto closepath fill } BD\n");
-  
+
   /* Smooth-shaded triangle with PostScript level 3 shfill operator:
         x3 y3 r3 g3 b3 x2 y2 r2 g2 b2 x1 y1 r1 g1 b1 STshfill */
 
   gl2psPrintf("/STshfill {\n"
               "      /b1 exch def /g1 exch def /r1 exch def /y1 exch def /x1 exch def\n"
               "      /b2 exch def /g2 exch def /r2 exch def /y2 exch def /x2 exch def\n"
               "      /b3 exch def /g3 exch def /r3 exch def /y3 exch def /x3 exch def\n"
               "      gsave << /ShadingType 4 /ColorSpace [/DeviceRGB]\n"
@@ -2789,21 +2789,21 @@ static void gl2psPrintPostScriptHeader(v
   /* stack = (V3) (V13) (V23) (V13) (V23) (V13) (V23) (V2) (V1) */
 
   gl2psPrintf("      4 index 10 index add 0.5 mul\n" /* x12 = (x1+x2)/2 */
               "      4 index 10 index add 0.5 mul\n" /* y12 = (y1+y2)/2 */
               "      4 index 10 index add 0.5 mul\n" /* r12 = (r1+r2)/2 */
               "      4 index 10 index add 0.5 mul\n" /* g12 = (g1+g2)/2 */
               "      4 index 10 index add 0.5 mul\n" /* b12 = (b1+b2)/2 */
               "      5 copy 5 copy 40 5 roll 25 5 roll 15 5 roll 25 5 roll\n");
-  
+
   /* stack = (V3) (V13) (V23) (V13) (V12) (V23) (V13) (V1) (V12) (V23) (V12) (V2) */
 
   gl2psPrintf("      STnoshfill STnoshfill STnoshfill STnoshfill } BD\n");
-  
+
   /* Gouraud shaded triangle using recursive subdivision until the difference
      between corner colors does not exceed the thresholds:
         x3 y3 r3 g3 b3 x2 y2 r2 g2 b2 x1 y1 r1 g1 b1 STnoshfill  */
 
   gl2psPrintf("/STnoshfill {\n"
               "      2 index 8 index sub abs rThreshold gt\n" /* |r1-r2|>rth */
               "      { STsplit }\n"
               "      { 1 index 7 index sub abs gThreshold gt\n" /* |g1-g2|>gth */
@@ -2827,51 +2827,51 @@ static void gl2psPrintPostScriptHeader(v
               "                    ifelse }\n"
               "                  ifelse }\n"
               "                ifelse }\n"
               "              ifelse }\n"
               "            ifelse }\n"
               "          ifelse }\n"
               "        ifelse }\n"
               "      ifelse } BD\n");
-  
+
   gl2psPrintf("tryPS3shading\n"
               "{ /shfill where\n"
               "  { /ST { STshfill } BD }\n"
               "  { /ST { STnoshfill } BD }\n"
               "  ifelse }\n"
               "{ /ST { STnoshfill } BD }\n"
               "ifelse\n");
 
   gl2psPrintf("end\n"
               "%%%%EndProlog\n"
               "%%%%BeginSetup\n"
               "/DeviceRGB setcolorspace\n"
               "gl2psdict begin\n"
               "%%%%EndSetup\n"
               "%%%%Page: 1 1\n"
               "%%%%BeginPageSetup\n");
-  
+
   if(gl2ps->options & GL2PS_LANDSCAPE){
     gl2psPrintf("%d 0 translate 90 rotate\n",
                 (int)gl2ps->viewport[3]);
   }
 
   gl2psPrintf("%%%%EndPageSetup\n"
               "mark\n"
               "gsave\n"
               "1.0 1.0 scale\n");
-          
+
   if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
     gl2psPrintf("%g %g %g C\n"
                 "newpath %d %d moveto %d %d lineto %d %d lineto %d %d lineto\n"
                 "closepath fill\n",
-                gl2ps->bgcolor[0], gl2ps->bgcolor[1], gl2ps->bgcolor[2], 
-                (int)gl2ps->viewport[0], (int)gl2ps->viewport[1], (int)gl2ps->viewport[2], 
-                (int)gl2ps->viewport[1], (int)gl2ps->viewport[2], (int)gl2ps->viewport[3], 
+                gl2ps->bgcolor[0], gl2ps->bgcolor[1], gl2ps->bgcolor[2],
+                (int)gl2ps->viewport[0], (int)gl2ps->viewport[1], (int)gl2ps->viewport[2],
+                (int)gl2ps->viewport[1], (int)gl2ps->viewport[2], (int)gl2ps->viewport[3],
                 (int)gl2ps->viewport[0], (int)gl2ps->viewport[3]);
   }
 }
 
 static void gl2psPrintPostScriptColor(GL2PSrgba rgba)
 {
   if(!gl2psSameColor(gl2ps->lastrgba, rgba)){
     gl2psSetLastColor(rgba);
@@ -2891,17 +2891,17 @@ static void gl2psEndPostScriptLine(void)
     gl2psPrintf("%g %g LE\n", gl2ps->lastvertex.xyz[0], gl2ps->lastvertex.xyz[1]);
     for(i = 0; i < 3; i++)
       gl2ps->lastvertex.xyz[i] = -1.;
     for(i = 0; i < 4; i++)
       gl2ps->lastvertex.rgba[i] = -1.;
   }
 }
 
-static void gl2psParseStipplePattern(GLushort pattern, GLint factor, 
+static void gl2psParseStipplePattern(GLushort pattern, GLint factor,
                                      int *nb, int array[10])
 {
   int i, n;
   int on[8] = {0, 0, 0, 0, 0, 0, 0, 0};
   int off[8] = {0, 0, 0, 0, 0, 0, 0, 0};
   char tmp[16];
 
   /* extract the 16 bits from the OpenGL stipple pattern */
@@ -2931,34 +2931,34 @@ static void gl2psParseStipplePattern(GLu
 }
 
 static int gl2psPrintPostScriptDash(GLushort pattern, GLint factor, const char *str)
 {
   int len = 0, i, n, array[10];
 
   if(pattern == gl2ps->lastpattern && factor == gl2ps->lastfactor)
     return 0;
-  
+
   gl2ps->lastpattern = pattern;
   gl2ps->lastfactor = factor;
-  
+
   if(!pattern || !factor){
     /* solid line */
     len += gl2psPrintf("[] 0 %s\n", str);
   }
   else{
     gl2psParseStipplePattern(pattern, factor, &n, array);
     len += gl2psPrintf("[");
     for(i = 0; i < n; i++){
       if(i) len += gl2psPrintf(" ");
       len += gl2psPrintf("%d", array[i]);
     }
     len += gl2psPrintf("] 0 %s\n", str);
   }
-  
+
   return len;
 }
 
 static void gl2psPrintPostScriptPrimitive(void *data)
 {
   int newline;
   GL2PSprimitive *prim;
 
@@ -2971,17 +2971,17 @@ static void gl2psPrintPostScriptPrimitiv
      line joins and to not restart the stippling for every line
      segment. So if the primitive to print is not a line we must first
      finish the current line (if any): */
   if(prim->type != GL2PS_LINE) gl2psEndPostScriptLine();
 
   switch(prim->type){
   case GL2PS_POINT :
     gl2psPrintPostScriptColor(prim->verts[0].rgba);
-    gl2psPrintf("%g %g %g P\n", 
+    gl2psPrintf("%g %g %g P\n",
                 prim->verts[0].xyz[0], prim->verts[0].xyz[1], 0.5 * prim->width);
     break;
   case GL2PS_LINE :
     if(!gl2psSamePosition(gl2ps->lastvertex.xyz, prim->verts[0].xyz) ||
        !gl2psSameColor(gl2ps->lastrgba, prim->verts[0].rgba) ||
        gl2ps->lastlinewidth != prim->width ||
        gl2ps->lastpattern != prim->pattern ||
        gl2ps->lastfactor != prim->factor){
@@ -3134,24 +3134,24 @@ static void gl2psPrintPostScriptBeginVie
       rgba[0] = gl2ps->colormap[index][0];
       rgba[1] = gl2ps->colormap[index][1];
       rgba[2] = gl2ps->colormap[index][2];
       rgba[3] = 1.0F;
     }
     gl2psPrintf("%g %g %g C\n"
                 "newpath %d %d moveto %d %d lineto %d %d lineto %d %d lineto\n"
                 "closepath fill\n",
-                rgba[0], rgba[1], rgba[2], 
+                rgba[0], rgba[1], rgba[2],
                 x, y, x+w, y, x+w, y+h, x, y+h);
   }
-    
+
   gl2psPrintf("newpath %d %d moveto %d %d lineto %d %d lineto %d %d lineto\n"
               "closepath clip\n",
               x, y, x+w, y, x+w, y+h, x, y+h);
-  
+
 }
 
 static GLint gl2psPrintPostScriptEndViewport(void)
 {
   GLint res;
 
   res = gl2psPrintPrimitives();
   gl2psPrintf("grestore\n");
@@ -3183,17 +3183,17 @@ static GL2PSbackend gl2psEPS = {
   gl2psPrintPostScriptBeginViewport,
   gl2psPrintPostScriptEndViewport,
   gl2psPrintPostScriptPrimitive,
   gl2psPrintPostScriptFinalPrimitive,
   "eps",
   "Encapsulated Postscript"
 };
 
-/********************************************************************* 
+/*********************************************************************
  *
  * LaTeX routines
  *
  *********************************************************************/
 
 static void gl2psPrintTeXHeader(void)
 {
   char name[256];
@@ -3211,26 +3211,26 @@ static void gl2psPrintTeXHeader(void)
     if(i <= 0) strcpy(name, gl2ps->filename);
   }
   else{
     strcpy(name, "untitled");
   }
 
   time(&now);
 
-  fprintf(gl2ps->stream, 
+  fprintf(gl2ps->stream,
           "%% Title: %s\n"
           "%% Creator: GL2PS %d.%d.%d%s, %s\n"
           "%% For: %s\n"
           "%% CreationDate: %s",
           gl2ps->title, GL2PS_MAJOR_VERSION, GL2PS_MINOR_VERSION,
           GL2PS_PATCH_VERSION, GL2PS_EXTRA_VERSION, GL2PS_COPYRIGHT,
           gl2ps->producer, ctime(&now));
 
-  fprintf(gl2ps->stream, 
+  fprintf(gl2ps->stream,
           "\\setlength{\\unitlength}{1pt}\n"
           "\\begin{picture}(0,0)\n"
           "\\includegraphics{%s}\n"
           "\\end{picture}%%\n"
           "%s\\begin{picture}(%d,%d)(0,0)\n",
           name, (gl2ps->options & GL2PS_LANDSCAPE) ? "\\rotatebox{90}{" : "",
           (int)gl2ps->viewport[2], (int)gl2ps->viewport[3]);
 }
@@ -3238,17 +3238,17 @@ static void gl2psPrintTeXHeader(void)
 static void gl2psPrintTeXPrimitive(void *data)
 {
   GL2PSprimitive *prim;
 
   prim = *(GL2PSprimitive**)data;
 
   switch(prim->type){
   case GL2PS_TEXT :
-    fprintf(gl2ps->stream, "\\fontsize{%d}{0}\n\\selectfont", 
+    fprintf(gl2ps->stream, "\\fontsize{%d}{0}\n\\selectfont",
             prim->data.text->fontsize);
     fprintf(gl2ps->stream, "\\put(%g,%g)",
             prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
     if(prim->data.text->angle)
       fprintf(gl2ps->stream, "{\\rotatebox{%g}", prim->data.text->angle);
     fprintf(gl2ps->stream, "{\\makebox(0,0)");
     switch(prim->data.text->alignment){
     case GL2PS_TEXT_C:
@@ -3302,17 +3302,17 @@ static void gl2psPrintTeXFooter(void)
 {
   fprintf(gl2ps->stream, "\\end{picture}%s\n",
           (gl2ps->options & GL2PS_LANDSCAPE) ? "}" : "");
 }
 
 static void gl2psPrintTeXBeginViewport(GLint viewport[4])
 {
   glRenderMode(GL_FEEDBACK);
-  
+
   if(gl2ps->header){
     gl2psPrintTeXHeader();
     gl2ps->header = GL_FALSE;
   }
 }
 
 static GLint gl2psPrintTeXEndViewport(void)
 {
@@ -3331,17 +3331,17 @@ static GL2PSbackend gl2psTEX = {
   gl2psPrintTeXBeginViewport,
   gl2psPrintTeXEndViewport,
   gl2psPrintTeXPrimitive,
   gl2psPrintTeXFinalPrimitive,
   "tex",
   "LaTeX text"
 };
 
-/********************************************************************* 
+/*********************************************************************
  *
  * PDF routines
  *
  *********************************************************************/
 
 static int gl2psPrintPDFCompressorType(void)
 {
 #if defined(GL2PS_HAVE_ZLIB)
@@ -3367,17 +3367,17 @@ static int gl2psPrintPDFStrokeColor(GL2P
   }
   offs += gl2psPrintf("RG\n");
   return offs;
 }
 
 static int gl2psPrintPDFFillColor(GL2PSrgba rgba)
 {
   int i, offs = 0;
-  
+
   for(i = 0; i < 3; ++i){
     if(GL2PS_ZERO(rgba[i]))
       offs += gl2psPrintf("%.0f ", 0.);
     else if(rgba[i] < 1e-4 || rgba[i] > 1e6) /* avoid %e formatting */
       offs += gl2psPrintf("%f ", rgba[i]);
     else
       offs += gl2psPrintf("%g ", rgba[i]);
   }
@@ -3393,24 +3393,24 @@ static int gl2psPrintPDFLineWidth(GLfloa
     return gl2psPrintf("%f w\n", lw);
   else
     return gl2psPrintf("%g w\n", lw);
 }
 
 static void gl2psPutPDFText(GL2PSstring *text, int cnt, GLfloat x, GLfloat y)
 {
   GLfloat rad, crad, srad;
-  
+
   if(text->angle == 0.0F){
     gl2ps->streamlength += gl2psPrintf
       ("BT\n"
        "/F%d %d Tf\n"
        "%f %f Td\n"
        "(%s) Tj\n"
-       "ET\n", 
+       "ET\n",
        cnt, text->fontsize, x, y, text->str);
   }
   else{
     rad = (GLfloat)M_PI * text->angle / 180.0F;
     srad = (GLfloat)sin(rad);
     crad = (GLfloat)cos(rad);
     gl2ps->streamlength += gl2psPrintf
       ("BT\n"
@@ -3429,33 +3429,33 @@ static void gl2psPutPDFImage(GL2PSimage 
      "%d 0 0 %d %f %f cm\n"
      "/Im%d Do\n"
      "Q\n",
      (int)image->width, (int)image->height, x, y, cnt);
 }
 
 static void gl2psPDFstacksInit(void)
 {
-  gl2ps->objects_stack = 7 /* FIXED_XREF_ENTRIES */ + 1; 
-  gl2ps->extgs_stack = 0;   
-  gl2ps->font_stack = 0;    
-  gl2ps->im_stack = 0;      
-  gl2ps->trgroupobjects_stack = 0;    
-  gl2ps->shader_stack = 0;  
-  gl2ps->mshader_stack = 0; 
+  gl2ps->objects_stack = 7 /* FIXED_XREF_ENTRIES */ + 1;
+  gl2ps->extgs_stack = 0;
+  gl2ps->font_stack = 0;
+  gl2ps->im_stack = 0;
+  gl2ps->trgroupobjects_stack = 0;
+  gl2ps->shader_stack = 0;
+  gl2ps->mshader_stack = 0;
 }
 
 static void gl2psPDFgroupObjectInit(GL2PSpdfgroup *gro)
 {
   if(!gro)
     return;
-  
+
   gro->ptrlist = NULL;
-  gro->fontno = gro->gsno = gro->imno = gro->maskshno = gro->shno 
-    = gro->trgroupno = gro->fontobjno = gro->imobjno = gro->shobjno 
+  gro->fontno = gro->gsno = gro->imno = gro->maskshno = gro->shno
+    = gro->trgroupno = gro->fontobjno = gro->imobjno = gro->shobjno
     = gro->maskshobjno = gro->gsobjno = gro->trgroupobjno = -1;
 }
 
 /* Build up group objects and assign name and object numbers */
 
 static void gl2psPDFgroupListInit(void)
 {
   int i;
@@ -3470,17 +3470,17 @@ static void gl2psPDFgroupListInit(void)
   int lastTriangleWasNotSimpleWithSameColor = 0;
 
   if(!gl2ps->pdfprimlist)
     return;
 
   gl2ps->pdfgrouplist = gl2psListCreate(500, 500, sizeof(GL2PSpdfgroup));
   gl2psInitTriangle(&lastt);
 
-  for(i = 0; i < gl2psListNbr(gl2ps->pdfprimlist); ++i){  
+  for(i = 0; i < gl2psListNbr(gl2ps->pdfprimlist); ++i){
     p = *(GL2PSprimitive**)gl2psListPointer(gl2ps->pdfprimlist, i);
     switch(p->type){
     case GL2PS_PIXMAP:
       gl2psPDFgroupObjectInit(&gro);
       gro.ptrlist = gl2psListCreate(1, 2, sizeof(GL2PSprimitive*));
       gro.imno = gl2ps->im_stack++;
       gl2psListAdd(gro.ptrlist, &p);
       gl2psListAdd(gl2ps->pdfgrouplist, &gro);
@@ -3488,17 +3488,17 @@ static void gl2psPDFgroupListInit(void)
     case GL2PS_TEXT:
       gl2psPDFgroupObjectInit(&gro);
       gro.ptrlist = gl2psListCreate(1, 2, sizeof(GL2PSprimitive*));
       gro.fontno = gl2ps->font_stack++;
       gl2psListAdd(gro.ptrlist, &p);
       gl2psListAdd(gl2ps->pdfgrouplist, &gro);
       break;
     case GL2PS_LINE:
-      if(lasttype != p->type || lastwidth != p->width || 
+      if(lasttype != p->type || lastwidth != p->width ||
          lastpattern != p->pattern || lastfactor != p->factor ||
          !gl2psSameColor(p->verts[0].rgba, lastrgba)){
         gl2psPDFgroupObjectInit(&gro);
         gro.ptrlist = gl2psListCreate(1, 2, sizeof(GL2PSprimitive*));
         gl2psListAdd(gro.ptrlist, &p);
         gl2psListAdd(gl2ps->pdfgrouplist, &gro);
       }
       else{
@@ -3507,102 +3507,102 @@ static void gl2psPDFgroupListInit(void)
       lastpattern = p->pattern;
       lastfactor = p->factor;
       lastwidth = p->width;
       lastrgba[0] = p->verts[0].rgba[0];
       lastrgba[1] = p->verts[0].rgba[1];
       lastrgba[2] = p->verts[0].rgba[2];
       break;
     case GL2PS_POINT:
-      if(lasttype != p->type || lastwidth != p->width || 
+      if(lasttype != p->type || lastwidth != p->width ||
          !gl2psSameColor(p->verts[0].rgba, lastrgba)){
         gl2psPDFgroupObjectInit(&gro);
         gro.ptrlist = gl2psListCreate(1,2,sizeof(GL2PSprimitive*));
         gl2psListAdd(gro.ptrlist, &p);
         gl2psListAdd(gl2ps->pdfgrouplist, &gro);
       }
       else{
         gl2psListAdd(gro.ptrlist, &p);
       }
       lastwidth = p->width;
       lastrgba[0] = p->verts[0].rgba[0];
       lastrgba[1] = p->verts[0].rgba[1];
       lastrgba[2] = p->verts[0].rgba[2];
       break;
     case GL2PS_TRIANGLE:
       gl2psFillTriangleFromPrimitive(&tmpt, p, GL_TRUE);
-      lastTriangleWasNotSimpleWithSameColor = 
+      lastTriangleWasNotSimpleWithSameColor =
         !(tmpt.prop & T_CONST_COLOR && tmpt.prop & T_ALPHA_1) ||
         !gl2psSameColor(tmpt.vertex[0].rgba, lastt.vertex[0].rgba);
-      if(lasttype == p->type && tmpt.prop == lastt.prop && 
+      if(lasttype == p->type && tmpt.prop == lastt.prop &&
          lastTriangleWasNotSimpleWithSameColor){
         /* TODO Check here for last alpha */
         gl2psListAdd(gro.ptrlist, &p);
       }
       else{
         gl2psPDFgroupObjectInit(&gro);
         gro.ptrlist = gl2psListCreate(1, 2, sizeof(GL2PSprimitive*));
         gl2psListAdd(gro.ptrlist, &p);
         gl2psListAdd(gl2ps->pdfgrouplist, &gro);
       }
       lastt = tmpt;
       break;
     default:
       break;
-    } 
+    }
     lasttype = p->type;
   }
 }
 
 static void gl2psSortOutTrianglePDFgroup(GL2PSpdfgroup *gro)
 {
   GL2PStriangle t;
   GL2PSprimitive *prim = NULL;
-  
+
   if(!gro)
     return;
 
   if(!gl2psListNbr(gro->ptrlist))
     return;
 
   prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, 0);
 
   if(prim->type != GL2PS_TRIANGLE)
     return;
 
   gl2psFillTriangleFromPrimitive(&t, prim, GL_TRUE);
-  
-  if(t.prop & T_CONST_COLOR && t.prop & T_ALPHA_LESS_1){        
-    gro->gsno = gl2ps->extgs_stack++; 
+
+  if(t.prop & T_CONST_COLOR && t.prop & T_ALPHA_LESS_1){
+    gro->gsno = gl2ps->extgs_stack++;
     gro->gsobjno = gl2ps->objects_stack ++;
   }
-  else if(t.prop & T_CONST_COLOR && t.prop & T_VAR_ALPHA){              
+  else if(t.prop & T_CONST_COLOR && t.prop & T_VAR_ALPHA){
     gro->gsno = gl2ps->extgs_stack++;
     gro->gsobjno = gl2ps->objects_stack++;
-    gro->trgroupno = gl2ps->trgroupobjects_stack++; 
+    gro->trgroupno = gl2ps->trgroupobjects_stack++;
     gro->trgroupobjno = gl2ps->objects_stack++;
     gro->maskshno = gl2ps->mshader_stack++;
     gro->maskshobjno = gl2ps->objects_stack++;
   }
-  else if(t.prop & T_VAR_COLOR && t.prop & T_ALPHA_1){          
+  else if(t.prop & T_VAR_COLOR && t.prop & T_ALPHA_1){
     gro->shno = gl2ps->shader_stack++;
     gro->shobjno = gl2ps->objects_stack++;
   }
-  else if(t.prop & T_VAR_COLOR && t.prop & T_ALPHA_LESS_1){             
+  else if(t.prop & T_VAR_COLOR && t.prop & T_ALPHA_LESS_1){
     gro->gsno = gl2ps->extgs_stack++;
     gro->gsobjno = gl2ps->objects_stack++;
-    gro->shno = gl2ps->shader_stack++; 
+    gro->shno = gl2ps->shader_stack++;
     gro->shobjno = gl2ps->objects_stack++;
   }
-  else if(t.prop & T_VAR_COLOR && t.prop & T_VAR_ALPHA){                
+  else if(t.prop & T_VAR_COLOR && t.prop & T_VAR_ALPHA){
     gro->gsno = gl2ps->extgs_stack++;
     gro->gsobjno = gl2ps->objects_stack++;
-    gro->shno = gl2ps->shader_stack++; 
+    gro->shno = gl2ps->shader_stack++;
     gro->shobjno = gl2ps->objects_stack++;
-    gro->trgroupno = gl2ps->trgroupobjects_stack++; 
+    gro->trgroupno = gl2ps->trgroupobjects_stack++;
     gro->trgroupobjno = gl2ps->objects_stack++;
     gro->maskshno = gl2ps->mshader_stack++;
     gro->maskshobjno = gl2ps->objects_stack++;
   }
 }
 
 /* Main stream data */
 
@@ -3625,236 +3625,236 @@ static void gl2psPDFgroupListWriteMainSt
 
     prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, 0);
 
     switch(prim->type){
     case GL2PS_POINT:
       gl2ps->streamlength += gl2psPrintf("1 J\n");
       gl2ps->streamlength += gl2psPrintPDFLineWidth(prim->width);
       gl2ps->streamlength += gl2psPrintPDFStrokeColor(prim->verts[0].rgba);
-      for(j = 0; j <= lastel; ++j){  
+      for(j = 0; j <= lastel; ++j){
         prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
         gl2ps->streamlength +=
           gl2psPrintf("%f %f m %f %f l\n",
                       prim->verts[0].xyz[0], prim->verts[0].xyz[1],
                       prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
       }
-      gl2ps->streamlength += gl2psPrintf("S\n"); 
+      gl2ps->streamlength += gl2psPrintf("S\n");
       gl2ps->streamlength += gl2psPrintf("0 J\n");
       break;
     case GL2PS_LINE:
       /* We try to use as few paths as possible to draw lines, in
          order to get nice stippling even when the individual segments
          are smaller than the stipple */
       gl2ps->streamlength += gl2psPrintPDFLineWidth(prim->width);
       gl2ps->streamlength += gl2psPrintPDFStrokeColor(prim->verts[0].rgba);
       gl2ps->streamlength += gl2psPrintPostScriptDash(prim->pattern, prim->factor, "d");
       /* start new path */
-      gl2ps->streamlength += 
-        gl2psPrintf("%f %f m\n", 
+      gl2ps->streamlength +=
+        gl2psPrintf("%f %f m\n",
                     prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
-      
+
       for(j = 1; j <= lastel; ++j){
         prev = prim;
         prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
         if(!gl2psSamePosition(prim->verts[0].xyz, prev->verts[1].xyz)){
           /* the starting point of the new segment does not match the
              end point of the previous line, so we end the current
              path and start a new one */
-          gl2ps->streamlength += 
-            gl2psPrintf("%f %f l\n", 
+          gl2ps->streamlength +=
+            gl2psPrintf("%f %f l\n",
                         prev->verts[1].xyz[0], prev->verts[1].xyz[1]);
-          gl2ps->streamlength += 
-            gl2psPrintf("%f %f m\n", 
+          gl2ps->streamlength +=
+            gl2psPrintf("%f %f m\n",
                         prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
         }
         else{
           /* the two segements are connected, so we just append to the
              current path */
-          gl2ps->streamlength += 
+          gl2ps->streamlength +=
             gl2psPrintf("%f %f l\n",
                         prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
         }
       }
       /* end last path */
-      gl2ps->streamlength += 
-        gl2psPrintf("%f %f l\n", 
+      gl2ps->streamlength +=
+        gl2psPrintf("%f %f l\n",
                     prim->verts[1].xyz[0], prim->verts[1].xyz[1]);
       gl2ps->streamlength += gl2psPrintf("S\n");
       break;
     case GL2PS_TRIANGLE:
       gl2psFillTriangleFromPrimitive(&t, prim, GL_TRUE);
       gl2psSortOutTrianglePDFgroup(gro);
-      
+
       /* No alpha and const color: Simple PDF draw orders  */
-      if(t.prop & T_CONST_COLOR && t.prop & T_ALPHA_1){         
-        gl2ps->streamlength += gl2psPrintPDFFillColor(t.vertex[0].rgba);        
-        for(j = 0; j <= lastel; ++j){  
+      if(t.prop & T_CONST_COLOR && t.prop & T_ALPHA_1){
+        gl2ps->streamlength += gl2psPrintPDFFillColor(t.vertex[0].rgba);
+        for(j = 0; j <= lastel; ++j){
           prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
           gl2psFillTriangleFromPrimitive(&t, prim, GL_FALSE);
-          gl2ps->streamlength 
+          gl2ps->streamlength
             += gl2psPrintf("%f %f m\n"
                            "%f %f l\n"
                            "%f %f l\n"
                            "h f\n",
                            t.vertex[0].xyz[0], t.vertex[0].xyz[1],
                            t.vertex[1].xyz[0], t.vertex[1].xyz[1],
                            t.vertex[2].xyz[0], t.vertex[2].xyz[1]);
         }
       }
-      /* Const alpha < 1 and const color: Simple PDF draw orders 
+      /* Const alpha < 1 and const color: Simple PDF draw orders
          and an extra extended Graphics State for the alpha const */
-      else if(t.prop & T_CONST_COLOR && t.prop & T_ALPHA_LESS_1){               
+      else if(t.prop & T_CONST_COLOR && t.prop & T_ALPHA_LESS_1){
         gl2ps->streamlength += gl2psPrintf("q\n"
                                            "/GS%d gs\n",
                                            gro->gsno);
         gl2ps->streamlength += gl2psPrintPDFFillColor(prim->verts[0].rgba);
-        for(j = 0; j <= lastel; ++j){  
+        for(j = 0; j <= lastel; ++j){
           prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
           gl2psFillTriangleFromPrimitive(&t, prim, GL_FALSE);
-          gl2ps->streamlength 
+          gl2ps->streamlength
             += gl2psPrintf("%f %f m\n"
                            "%f %f l\n"
                            "%f %f l\n"
                            "h f\n",
                            t.vertex[0].xyz[0], t.vertex[0].xyz[1],
                            t.vertex[1].xyz[0], t.vertex[1].xyz[1],
                            t.vertex[2].xyz[0], t.vertex[2].xyz[1]);
         }
         gl2ps->streamlength += gl2psPrintf("Q\n");
       }
-      /* Variable alpha and const color: Simple PDF draw orders 
-         and an extra extended Graphics State + Xobject + Shader 
+      /* Variable alpha and const color: Simple PDF draw orders
+         and an extra extended Graphics State + Xobject + Shader
          object for the alpha mask */
-      else if(t.prop & T_CONST_COLOR && t.prop & T_VAR_ALPHA){          
+      else if(t.prop & T_CONST_COLOR && t.prop & T_VAR_ALPHA){
         gl2ps->streamlength += gl2psPrintf("q\n"
                                            "/GS%d gs\n"
                                            "/TrG%d Do\n",
                                            gro->gsno, gro->trgroupno);
         gl2ps->streamlength += gl2psPrintPDFFillColor(prim->verts[0].rgba);
-        for(j = 0; j <= lastel; ++j){  
+        for(j = 0; j <= lastel; ++j){
           prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
           gl2psFillTriangleFromPrimitive(&t, prim, GL_FALSE);
-          gl2ps->streamlength 
+          gl2ps->streamlength
             += gl2psPrintf("%f %f m\n"
                            "%f %f l\n"
                            "%f %f l\n"
                            "h f\n",
                            t.vertex[0].xyz[0], t.vertex[0].xyz[1],
                            t.vertex[1].xyz[0], t.vertex[1].xyz[1],
                            t.vertex[2].xyz[0], t.vertex[2].xyz[1]);
         }
         gl2ps->streamlength += gl2psPrintf("Q\n");
       }
       /* Variable color and no alpha: Shader Object for the colored
          triangle(s) */
-      else if(t.prop & T_VAR_COLOR && t.prop & T_ALPHA_1){              
+      else if(t.prop & T_VAR_COLOR && t.prop & T_ALPHA_1){
         gl2ps->streamlength += gl2psPrintf("/Sh%d sh\n", gro->shno);
       }
-      /* Variable color and const alpha < 1: Shader Object for the 
-         colored triangle(s) and an extra extended Graphics State 
+      /* Variable color and const alpha < 1: Shader Object for the
+         colored triangle(s) and an extra extended Graphics State
          for the alpha const */
-      else if(t.prop & T_VAR_COLOR && t.prop & T_ALPHA_LESS_1){         
+      else if(t.prop & T_VAR_COLOR && t.prop & T_ALPHA_LESS_1){
         gl2ps->streamlength += gl2psPrintf("q\n"
                                            "/GS%d gs\n"
                                            "/Sh%d sh\n"
                                            "Q\n",
                                            gro->gsno, gro->shno);
       }
-      /* Variable alpha and color: Shader Object for the colored 
-         triangle(s) and an extra extended Graphics State 
+      /* Variable alpha and color: Shader Object for the colored
+         triangle(s) and an extra extended Graphics State
          + Xobject + Shader object for the alpha mask */
-      else if(t.prop & T_VAR_COLOR && t.prop & T_VAR_ALPHA){            
+      else if(t.prop & T_VAR_COLOR && t.prop & T_VAR_ALPHA){
         gl2ps->streamlength += gl2psPrintf("q\n"
                                            "/GS%d gs\n"
                                            "/TrG%d Do\n"
                                            "/Sh%d sh\n"
                                            "Q\n",
                                            gro->gsno, gro->trgroupno, gro->shno);
       }
       break;
     case GL2PS_PIXMAP:
       for(j = 0; j <= lastel; ++j){
         prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
-        gl2psPutPDFImage(prim->data.image, gro->imno, prim->verts[0].xyz[0], 
+        gl2psPutPDFImage(prim->data.image, gro->imno, prim->verts[0].xyz[0],
                          prim->verts[0].xyz[1]);
       }
       break;
     case GL2PS_TEXT:
-      for(j = 0; j <= lastel; ++j){  
+      for(j = 0; j <= lastel; ++j){
         prim = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
         gl2ps->streamlength += gl2psPrintPDFFillColor(prim->verts[0].rgba);
         gl2psPutPDFText(prim->data.text, gro->fontno, prim->verts[0].xyz[0],
                         prim->verts[0].xyz[1]);
       }
       break;
     default:
       break;
-    } 
+    }
   }
 }
 
 /* Graphics State names */
 
 static int gl2psPDFgroupListWriteGStateResources(void)
 {
   GL2PSpdfgroup *gro;
   int offs = 0;
   int i;
 
   offs += fprintf(gl2ps->stream,
-                  "/ExtGState\n" 
+                  "/ExtGState\n"
                   "<<\n"
                   "/GSa 7 0 R\n");
-  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){  
-    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i); 
+  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){
+    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i);
     if(gro->gsno >= 0)
       offs += fprintf(gl2ps->stream, "/GS%d %d 0 R\n", gro->gsno, gro->gsobjno);
   }
-  offs += fprintf(gl2ps->stream, ">>\n"); 
+  offs += fprintf(gl2ps->stream, ">>\n");
   return offs;
 }
 
 /* Main Shader names */
 
 static int gl2psPDFgroupListWriteShaderResources(void)
 {
   GL2PSpdfgroup *gro;
   int offs = 0;
   int i;
 
   offs += fprintf(gl2ps->stream,
                   "/Shading\n"
                   "<<\n");
-  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){  
-    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i); 
+  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){
+    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i);
     if(gro->shno >= 0)
       offs += fprintf(gl2ps->stream, "/Sh%d %d 0 R\n", gro->shno, gro->shobjno);
     if(gro->maskshno >= 0)
       offs += fprintf(gl2ps->stream, "/TrSh%d %d 0 R\n", gro->maskshno, gro->maskshobjno);
   }
-  offs += fprintf(gl2ps->stream,">>\n");  
+  offs += fprintf(gl2ps->stream,">>\n");
   return offs;
 }
 
 /* Images & Mask Shader XObject names */
 
 static int gl2psPDFgroupListWriteXObjectResources(void)
 {
   int i;
   GL2PSprimitive *p = NULL;
   GL2PSpdfgroup *gro;
   int offs = 0;
 
   offs += fprintf(gl2ps->stream,
                   "/XObject\n"
                   "<<\n");
 
-  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){  
-    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i); 
+  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){
+    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i);
     if(!gl2psListNbr(gro->ptrlist))
       continue;
     p = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, 0);
     switch(p->type){
     case GL2PS_PIXMAP:
       gro->imobjno = gl2ps->objects_stack++;
       if(GL_RGBA == p->data.image->format)  /* reserve one object for image mask */
         gl2ps->objects_stack++;
@@ -3876,212 +3876,212 @@ static int gl2psPDFgroupListWriteXObject
 static int gl2psPDFgroupListWriteFontResources(void)
 {
   int i;
   GL2PSpdfgroup *gro;
   int offs = 0;
 
   offs += fprintf(gl2ps->stream, "/Font\n<<\n");
 
-  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){  
-    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i); 
+  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){
+    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i);
     if(gro->fontno < 0)
       continue;
     gro->fontobjno = gl2ps->objects_stack++;
     offs += fprintf(gl2ps->stream, "/F%d %d 0 R\n", gro->fontno, gro->fontobjno);
   }
   offs += fprintf(gl2ps->stream, ">>\n");
 
   return offs;
 }
 
 static void gl2psPDFgroupListDelete(void)
 {
   int i;
   GL2PSpdfgroup *gro = NULL;
-  
+
   if(!gl2ps->pdfgrouplist)
     return;
 
-  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){ 
+  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){
     gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist,i);
     gl2psListDelete(gro->ptrlist);
   }
 
   gl2psListDelete(gl2ps->pdfgrouplist);
   gl2ps->pdfgrouplist = NULL;
 }
 
 /* Print 1st PDF object - file info */
 
 static int gl2psPrintPDFInfo(void)
 {
   int offs;
   time_t now;
   struct tm *newtime;
-  
+
   time(&now);
   newtime = gmtime(&now);
-  
+
   offs = fprintf(gl2ps->stream,
                  "1 0 obj\n"
                  "<<\n"
                  "/Title (%s)\n"
                  "/Creator (GL2PS %d.%d.%d%s, %s)\n"
                  "/Producer (%s)\n",
                  gl2ps->title, GL2PS_MAJOR_VERSION, GL2PS_MINOR_VERSION,
                  GL2PS_PATCH_VERSION, GL2PS_EXTRA_VERSION, GL2PS_COPYRIGHT,
                  gl2ps->producer);
-  
+
   if(!newtime){
-    offs += fprintf(gl2ps->stream, 
+    offs += fprintf(gl2ps->stream,
                     ">>\n"
                     "endobj\n");
     return offs;
   }
-  
-  offs += fprintf(gl2ps->stream, 
+
+  offs += fprintf(gl2ps->stream,
                   "/CreationDate (D:%d%02d%02d%02d%02d%02d)\n"
                   ">>\n"
                   "endobj\n",
-                  newtime->tm_year+1900, 
-                  newtime->tm_mon+1, 
+                  newtime->tm_year+1900,
+                  newtime->tm_mon+1,
                   newtime->tm_mday,
                   newtime->tm_hour,
                   newtime->tm_min,
                   newtime->tm_sec);
   return offs;
 }
 
 /* Create catalog and page structure - 2nd and 3th PDF object */
 
 static int gl2psPrintPDFCatalog(void)
 {
-  return fprintf(gl2ps->stream, 
+  return fprintf(gl2ps->stream,
                  "2 0 obj\n"
                  "<<\n"
                  "/Type /Catalog\n"
                  "/Pages 3 0 R\n"
                  ">>\n"
                  "endobj\n");
 }
 
 static int gl2psPrintPDFPages(void)
 {
-  return fprintf(gl2ps->stream, 
+  return fprintf(gl2ps->stream,
                  "3 0 obj\n"
-                 "<<\n" 
+                 "<<\n"
                  "/Type /Pages\n"
                  "/Kids [6 0 R]\n"
                  "/Count 1\n"
                  ">>\n"
                  "endobj\n");
 }
 
 /* Open stream for data - graphical objects, fonts etc. PDF object 4 */
 
 static int gl2psOpenPDFDataStream(void)
 {
   int offs = 0;
-  
-  offs += fprintf(gl2ps->stream, 
+
+  offs += fprintf(gl2ps->stream,
                   "4 0 obj\n"
-                  "<<\n" 
+                  "<<\n"
                   "/Length 5 0 R\n" );
   offs += gl2psPrintPDFCompressorType();
-  offs += fprintf(gl2ps->stream, 
+  offs += fprintf(gl2ps->stream,
                   ">>\n"
                   "stream\n");
   return offs;
 }
 
 /* Stream setup - Graphics state, fill background if allowed */
 
 static int gl2psOpenPDFDataStreamWritePreface(void)
 {
   int offs;
 
   offs = gl2psPrintf("/GSa gs\n");
-  
+
   if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
     offs += gl2psPrintPDFFillColor(gl2ps->bgcolor);
     offs += gl2psPrintf("%d %d %d %d re\n",
                         (int)gl2ps->viewport[0], (int)gl2ps->viewport[1],
                         (int)gl2ps->viewport[2], (int)gl2ps->viewport[3]);
-    offs += gl2psPrintf("f\n");  
+    offs += gl2psPrintf("f\n");
   }
   return offs;
 }
 
 /* Use the functions above to create the first part of the PDF*/
 
 static void gl2psPrintPDFHeader(void)
 {
   int offs = 0;
   gl2ps->pdfprimlist = gl2psListCreate(500, 500, sizeof(GL2PSprimitive*));
   gl2psPDFstacksInit();
 
-  gl2ps->xreflist = (int*)gl2psMalloc(sizeof(int) * gl2ps->objects_stack); 
+  gl2ps->xreflist = (int*)gl2psMalloc(sizeof(int) * gl2ps->objects_stack);
 
 #if defined(GL2PS_HAVE_ZLIB)
   if(gl2ps->options & GL2PS_COMPRESS){
     gl2psSetupCompress();
   }
-#endif    
+#endif
   gl2ps->xreflist[0] = 0;
   offs += fprintf(gl2ps->stream, "%%PDF-1.4\n");
   gl2ps->xreflist[1] = offs;
-  
+
   offs += gl2psPrintPDFInfo();
   gl2ps->xreflist[2] = offs;
-  
+
   offs += gl2psPrintPDFCatalog();
   gl2ps->xreflist[3] = offs;
-  
+
   offs += gl2psPrintPDFPages();
   gl2ps->xreflist[4] = offs;
-  
+
   offs += gl2psOpenPDFDataStream();
   gl2ps->xreflist[5] = offs; /* finished in gl2psPrintPDFFooter */
   gl2ps->streamlength = gl2psOpenPDFDataStreamWritePreface();
 }
 
 /* The central primitive drawing */
 
 static void gl2psPrintPDFPrimitive(void *data)
 {
   GL2PSprimitive *prim = *(GL2PSprimitive**)data;
 
-  if((gl2ps->options & GL2PS_OCCLUSION_CULL) && prim->culled) 
+  if((gl2ps->options & GL2PS_OCCLUSION_CULL) && prim->culled)
     return;
 
   prim = gl2psCopyPrimitive(prim); /* deep copy */
   gl2psListAdd(gl2ps->pdfprimlist, &prim);
 }
 
 /* close stream and ... */
 
 static int gl2psClosePDFDataStream(void)
 {
   int offs = 0;
- 
+
 #if defined(GL2PS_HAVE_ZLIB)
   if(gl2ps->options & GL2PS_COMPRESS){
     if(Z_OK != gl2psDeflate())
       gl2psMsg(GL2PS_ERROR, "Zlib deflate error");
     else
       fwrite(gl2ps->compress->dest, gl2ps->compress->destLen, 1, gl2ps->stream);
     gl2ps->streamlength += gl2ps->compress->destLen;
-    
+
     offs += gl2ps->streamlength;
     gl2psFreeCompress();
   }
-#endif 
-  
-  offs += fprintf(gl2ps->stream, 
+#endif
+
+  offs += fprintf(gl2ps->stream,
                   "endstream\n"
                   "endobj\n");
   return offs;
 }
 
 /* ... write the now known length object */
 
 static int gl2psPrintPDFDataStreamLength(int val)
@@ -4092,58 +4092,58 @@ static int gl2psPrintPDFDataStreamLength
                  "endobj\n", val);
 }
 
 /* Put the info created before in PDF objects */
 
 static int gl2psPrintPDFOpenPage(void)
 {
   int offs;
-  
+
   /* Write fixed part */
-  
-  offs = fprintf(gl2ps->stream, 
+
+  offs = fprintf(gl2ps->stream,
                  "6 0 obj\n"
-                 "<<\n" 
+                 "<<\n"
                  "/Type /Page\n"
                  "/Parent 3 0 R\n"
                  "/MediaBox [%d %d %d %d]\n",
                  (int)gl2ps->viewport[0], (int)gl2ps->viewport[1],
                  (int)gl2ps->viewport[2], (int)gl2ps->viewport[3]);
-  
+
   if(gl2ps->options & GL2PS_LANDSCAPE)
     offs += fprintf(gl2ps->stream, "/Rotate -90\n");
-  
+
   offs += fprintf(gl2ps->stream,
                   "/Contents 4 0 R\n"
-                  "/Resources\n" 
-                  "<<\n" 
+                  "/Resources\n"
+                  "<<\n"
                   "/ProcSet [/PDF /Text /ImageB /ImageC]  %%/ImageI\n");
-  
+
   return offs;
 
   /* End fixed part, proceeds in gl2psPDFgroupListWriteVariableResources() */
 }
 
 static int gl2psPDFgroupListWriteVariableResources(void)
 {
   int offs = 0;
-  
+
   /* a) Graphics States for shader alpha masks*/
-  offs += gl2psPDFgroupListWriteGStateResources();  
-  
-  /* b) Shader and shader masks */ 
-  offs += gl2psPDFgroupListWriteShaderResources();  
- 
+  offs += gl2psPDFgroupListWriteGStateResources();
+
+  /* b) Shader and shader masks */
+  offs += gl2psPDFgroupListWriteShaderResources();
+
   /* c) XObjects (Images & Shader Masks) */
   offs += gl2psPDFgroupListWriteXObjectResources();
-  
+
   /* d) Fonts */
   offs += gl2psPDFgroupListWriteFontResources();
-  
+
   /* End resources and page */
   offs += fprintf(gl2ps->stream,
                   ">>\n"
                   ">>\n"
                   "endobj\n");
   return offs;
 }
 
@@ -4164,229 +4164,229 @@ static int gl2psPrintPDFGSObject(void)
                  "/UCR2 /Default\n"
                  "/TR2 /Default\n"
                  ">>\n"
                  "endobj\n");
 }
 
 /* Put vertex' edge flag (8bit) and coordinates (32bit) in shader stream */
 
-static int gl2psPrintPDFShaderStreamDataCoord(GL2PSvertex *vertex, 
-                                              size_t (*action)(unsigned long data, 
-                                                               size_t size), 
-                                              GLfloat dx, GLfloat dy, 
+static int gl2psPrintPDFShaderStreamDataCoord(GL2PSvertex *vertex,
+                                              size_t (*action)(unsigned long data,
+                                                               size_t size),
+                                              GLfloat dx, GLfloat dy,
                                               GLfloat xmin, GLfloat ymin)
 {
   int offs = 0;
   unsigned long imap;
   GLfloat diff;
   double dmax = ~1UL;
   char edgeflag = 0;
 
   /* FIXME: temp bux fix for 64 bit archs: */
   if(sizeof(unsigned long) == 8) dmax = dmax - 2048.;
 
   offs += (*action)(edgeflag, 1);
 
   /* The Shader stream in PDF requires to be in a 'big-endian'
      order */
-    
+
   if(GL2PS_ZERO(dx * dy)){
     offs += (*action)(0, 4);
     offs += (*action)(0, 4);
   }
   else{
     diff = (vertex->xyz[0] - xmin) / dx;
     if(diff > 1)
       diff = 1.0F;
     else if(diff < 0)
       diff = 0.0F;
     imap = (unsigned long)(diff * dmax);
     offs += (*action)(imap, 4);
-      
+
     diff = (vertex->xyz[1] - ymin) / dy;
     if(diff > 1)
       diff = 1.0F;
     else if(diff < 0)
       diff = 0.0F;
     imap = (unsigned long)(diff * dmax);
     offs += (*action)(imap, 4);
   }
-  
+
   return offs;
 }
 
 /* Put vertex' rgb value (8bit for every component) in shader stream */
 
 static int gl2psPrintPDFShaderStreamDataRGB(GL2PSvertex *vertex,
-                                            size_t (*action)(unsigned long data, 
+                                            size_t (*action)(unsigned long data,
                                                              size_t size))
 {
   int offs = 0;
   unsigned long imap;
   double dmax = ~1UL;
 
   /* FIXME: temp bux fix for 64 bit archs: */
   if(sizeof(unsigned long) == 8) dmax = dmax - 2048.;
 
   imap = (unsigned long)((vertex->rgba[0]) * dmax);
   offs += (*action)(imap, 1);
-    
+
   imap = (unsigned long)((vertex->rgba[1]) * dmax);
   offs += (*action)(imap, 1);
-    
+
   imap = (unsigned long)((vertex->rgba[2]) * dmax);
   offs += (*action)(imap, 1);
-  
+
   return offs;
 }
 
 /* Put vertex' alpha (8/16bit) in shader stream */
 
-static int gl2psPrintPDFShaderStreamDataAlpha(GL2PSvertex *vertex, 
-                                              size_t (*action)(unsigned long data, 
+static int gl2psPrintPDFShaderStreamDataAlpha(GL2PSvertex *vertex,
+                                              size_t (*action)(unsigned long data,
                                                                size_t size),
                                               int sigbyte)
 {
   int offs = 0;
   unsigned long imap;
   double dmax = ~1UL;
 
   /* FIXME: temp bux fix for 64 bit archs: */
   if(sizeof(unsigned long) == 8) dmax = dmax - 2048.;
 
   if(sigbyte != 8 && sigbyte != 16)
     sigbyte = 8;
-        
+
   sigbyte /= 8;
-  
+
   imap = (unsigned long)((vertex->rgba[3]) * dmax);
-  
+
   offs += (*action)(imap, sigbyte);
-  
+
   return offs;
 }
 
 /* Put a triangles raw data in shader stream */
 
-static int gl2psPrintPDFShaderStreamData(GL2PStriangle *triangle, 
-                                         GLfloat dx, GLfloat dy, 
+static int gl2psPrintPDFShaderStreamData(GL2PStriangle *triangle,
+                                         GLfloat dx, GLfloat dy,
                                          GLfloat xmin, GLfloat ymin,
-                                         size_t (*action)(unsigned long data, 
+                                         size_t (*action)(unsigned long data,
                                                           size_t size),
                                          int gray)
 {
   int i, offs = 0;
   GL2PSvertex v;
-  
+
   if(gray && gray != 8 && gray != 16)
     gray = 8;
-  
+
   for(i = 0; i < 3; ++i){
     offs += gl2psPrintPDFShaderStreamDataCoord(&triangle->vertex[i], action,
                                                dx, dy, xmin, ymin);
-    if(gray){ 
+    if(gray){
       v = triangle->vertex[i];
-      offs += gl2psPrintPDFShaderStreamDataAlpha(&v, action, gray); 
+      offs += gl2psPrintPDFShaderStreamDataAlpha(&v, action, gray);
     }
     else{
       offs += gl2psPrintPDFShaderStreamDataRGB(&triangle->vertex[i], action);
     }
   }
-  
+
   return offs;
 }
 
-static void gl2psPDFRectHull(GLfloat *xmin, GLfloat *xmax, 
-                             GLfloat *ymin, GLfloat *ymax, 
+static void gl2psPDFRectHull(GLfloat *xmin, GLfloat *xmax,
+                             GLfloat *ymin, GLfloat *ymax,
                              GL2PStriangle *triangles, int cnt)
 {
   int i, j;
 
   *xmin = triangles[0].vertex[0].xyz[0];
   *xmax = triangles[0].vertex[0].xyz[0];
   *ymin = triangles[0].vertex[0].xyz[1];
   *ymax = triangles[0].vertex[0].xyz[1];
-  
+
   for(i = 0; i < cnt; ++i){
     for(j = 0; j < 3; ++j){
       if(*xmin > triangles[i].vertex[j].xyz[0])
         *xmin = triangles[i].vertex[j].xyz[0];
       if(*xmax < triangles[i].vertex[j].xyz[0])
         *xmax = triangles[i].vertex[j].xyz[0];
       if(*ymin > triangles[i].vertex[j].xyz[1])
         *ymin = triangles[i].vertex[j].xyz[1];
       if(*ymax < triangles[i].vertex[j].xyz[1])
         *ymax = triangles[i].vertex[j].xyz[1];
     }
   }
 }
 
-/* Writes shaded triangle 
+/* Writes shaded triangle
    gray == 0 means write RGB triangles
    gray == 8             8bit-grayscale (for alpha masks)
    gray == 16            16bit-grayscale (for alpha masks) */
 
-static int gl2psPrintPDFShader(int obj, GL2PStriangle *triangles, 
+static int gl2psPrintPDFShader(int obj, GL2PStriangle *triangles,
                                int size, int gray)
 {
   int i, offs = 0, vertexbytes, done = 0;
   GLfloat xmin, xmax, ymin, ymax;
-        
+
   switch(gray){
   case 0:
     vertexbytes = 1+4+4+1+1+1;
     break;
   case 8:
     vertexbytes = 1+4+4+1;
     break;
   case 16:
     vertexbytes = 1+4+4+2;
     break;
   default:
     gray = 8;
     vertexbytes = 1+4+4+1;
     break;
   }
-  
+
   gl2psPDFRectHull(&xmin, &xmax, &ymin, &ymax, triangles, size);
-  
+
   offs += fprintf(gl2ps->stream,
                   "%d 0 obj\n"
                   "<< "
                   "/ShadingType 4 "
                   "/ColorSpace %s "
                   "/BitsPerCoordinate 32 "
                   "/BitsPerComponent %d "
                   "/BitsPerFlag 8 "
                   "/Decode [%f %f %f %f 0 1 %s] ",
                   obj,
-                  (gray) ? "/DeviceGray" : "/DeviceRGB", 
+                  (gray) ? "/DeviceGray" : "/DeviceRGB",
                   (gray) ? gray : 8,
                   xmin, xmax, ymin, ymax,
                   (gray) ? "" : "0 1 0 1");
-  
+
 #if defined(GL2PS_HAVE_ZLIB)
   if(gl2ps->options & GL2PS_COMPRESS){
     gl2psAllocCompress(vertexbytes * size * 3);
 
     for(i = 0; i < size; ++i)
       gl2psPrintPDFShaderStreamData(&triangles[i],
-                                    xmax-xmin, ymax-ymin, xmin, ymin, 
+                                    xmax-xmin, ymax-ymin, xmin, ymin,
                                     gl2psWriteBigEndianCompress, gray);
 
     if(Z_OK == gl2psDeflate() && 23 + gl2ps->compress->destLen < gl2ps->compress->srcLen){
       offs += gl2psPrintPDFCompressorType();
       offs += fprintf(gl2ps->stream,
                       "/Length %d "
                       ">>\n"
                       "stream\n",
                       (int)gl2ps->compress->destLen);
-      offs += gl2ps->compress->destLen * fwrite(gl2ps->compress->dest, 
-                                                gl2ps->compress->destLen, 
+      offs += gl2ps->compress->destLen * fwrite(gl2ps->compress->dest,
+                                                gl2ps->compress->destLen,
                                                 1, gl2ps->stream);
       done = 1;
     }
     gl2psFreeCompress();
   }
 #endif
 
   if(!done){
@@ -4397,118 +4397,118 @@ static int gl2psPrintPDFShader(int obj, 
                     ">>\n"
                     "stream\n",
                     vertexbytes * 3 * size);
     for(i = 0; i < size; ++i)
       offs += gl2psPrintPDFShaderStreamData(&triangles[i],
                                             xmax-xmin, ymax-ymin, xmin, ymin,
                                             gl2psWriteBigEndian, gray);
   }
-  
+
   offs += fprintf(gl2ps->stream,
                   "\nendstream\n"
                   "endobj\n");
-  
+
   return offs;
 }
 
 /* Writes a XObject for a shaded triangle mask */
 
 static int gl2psPrintPDFShaderMask(int obj, int childobj)
 {
   int offs = 0, len;
-  
+
   offs += fprintf(gl2ps->stream,
                   "%d 0 obj\n"
                   "<<\n"
                   "/Type /XObject\n"
                   "/Subtype /Form\n"
                   "/BBox [ %d %d %d %d ]\n"
                   "/Group \n<<\n/S /Transparency /CS /DeviceRGB\n"
                   ">>\n",
                   obj,
                   (int)gl2ps->viewport[0], (int)gl2ps->viewport[1],
                   (int)gl2ps->viewport[2], (int)gl2ps->viewport[3]);
-  
-  len = (childobj>0) 
+
+  len = (childobj>0)
     ? strlen("/TrSh sh\n") + (int)log10((double)childobj)+1
-    : strlen("/TrSh0 sh\n"); 
-  
+    : strlen("/TrSh0 sh\n");
+
   offs += fprintf(gl2ps->stream,
                   "/Length %d\n"
                   ">>\n"
                   "stream\n",
                   len);
   offs += fprintf(gl2ps->stream,
                   "/TrSh%d sh\n",
                   childobj);
   offs += fprintf(gl2ps->stream,
                   "endstream\n"
                   "endobj\n");
-  
+
   return offs;
 }
 
 /* Writes a Extended graphics state for a shaded triangle mask if
    simplealpha ist true the childobj argument is ignored and a /ca
    statement will be written instead */
 
 static int gl2psPrintPDFShaderExtGS(int obj, int childobj)
 {
   int offs = 0;
-  
+
   offs += fprintf(gl2ps->stream,
                   "%d 0 obj\n"
                   "<<\n",
                   obj);
-  
+
   offs += fprintf(gl2ps->stream,
                   "/SMask << /S /Alpha /G %d 0 R >> ",
                   childobj);
-  
+
   offs += fprintf(gl2ps->stream,
                   ">>\n"
                   "endobj\n");
   return offs;
 }
 
 /* a simple graphics state */
 
 static int gl2psPrintPDFShaderSimpleExtGS(int obj, GLfloat alpha)
 {
   int offs = 0;
-  
+
   offs += fprintf(gl2ps->stream,
                   "%d 0 obj\n"
                   "<<\n"
                   "/ca %g"
                   ">>\n"
                   "endobj\n",
                   obj, alpha);
   return offs;
 }
 
 /* Similar groups of functions for pixmaps and text */
 
 static int gl2psPrintPDFPixmapStreamData(GL2PSimage *im,
-                                         size_t (*action)(unsigned long data, 
-                                                          size_t size), 
+                                         size_t (*action)(unsigned long data,
+                                                          size_t size),
                                          int gray)
 {
   int x, y, shift;
   GLfloat r, g, b, a;
 
   if(im->format != GL_RGBA && gray)
     return 0;
 
   if(gray && gray != 8 && gray != 16)
     gray = 8;
 
   gray /= 8;
-  
+
   shift = (sizeof(unsigned long) - 1) * 8;
 
   for(y = 0; y < im->height; ++y){
     for(x = 0; x < im->width; ++x){
       a = gl2psGetRGB(im, x, y, &r, &g, &b);
       if(im->format == GL_RGBA && gray){
         (*action)((unsigned long)(a * 255) << shift, gray);
       }
@@ -4529,20 +4529,20 @@ static int gl2psPrintPDFPixmapStreamData
 }
 
 static int gl2psPrintPDFPixmap(int obj, int childobj, GL2PSimage *im, int gray)
 {
   int offs = 0, done = 0, sigbytes = 3;
 
   if(gray && gray !=8 && gray != 16)
     gray = 8;
-  
+
   if(gray)
-    sigbytes = gray / 8; 
-  
+    sigbytes = gray / 8;
+
   offs += fprintf(gl2ps->stream,
                   "%d 0 obj\n"
                   "<<\n"
                   "/Type /XObject\n"
                   "/Subtype /Image\n"
                   "/Width %d\n"
                   "/Height %d\n"
                   "/ColorSpace %s \n"
@@ -4550,60 +4550,60 @@ static int gl2psPrintPDFPixmap(int obj, 
                   obj,
                   (int)im->width, (int)im->height,
                   (gray) ? "/DeviceGray" : "/DeviceRGB" );
   if(GL_RGBA == im->format && gray == 0){
     offs += fprintf(gl2ps->stream,
                     "/SMask %d 0 R\n",
                     childobj);
   }
-  
+
 #if defined(GL2PS_HAVE_ZLIB)
   if(gl2ps->options & GL2PS_COMPRESS){
     gl2psAllocCompress((int)(im->width * im->height * sigbytes));
-    
+
     gl2psPrintPDFPixmapStreamData(im, gl2psWriteBigEndianCompress, gray);
-    
+
     if(Z_OK == gl2psDeflate() && 23 + gl2ps->compress->destLen < gl2ps->compress->srcLen){
       offs += gl2psPrintPDFCompressorType();
       offs += fprintf(gl2ps->stream,
                       "/Length %d "
                       ">>\n"
                       "stream\n",
                       (int)gl2ps->compress->destLen);
       offs += gl2ps->compress->destLen * fwrite(gl2ps->compress->dest, gl2ps->compress->destLen,
                                                 1, gl2ps->stream);
       done = 1;
     }
     gl2psFreeCompress();
   }
 #endif
-  
+
   if(!done){
     /* no compression, or too long after compression, or compress error
        -> write non-compressed entry */
     offs += fprintf(gl2ps->stream,
                     "/Length %d "
                     ">>\n"
                     "stream\n",
                     (int)(im->width * im->height * sigbytes));
     offs += gl2psPrintPDFPixmapStreamData(im, gl2psWriteBigEndian, gray);
   }
-  
+
   offs += fprintf(gl2ps->stream,
                   "\nendstream\n"
                   "endobj\n");
-  
+
   return offs;
 }
 
 static int gl2psPrintPDFText(int obj, GL2PSstring *s, int fontnumber)
 {
   int offs = 0;
-  
+
   offs += fprintf(gl2ps->stream,
                   "%d 0 obj\n"
                   "<<\n"
                   "/Type /Font\n"
                   "/Subtype /Type1\n"
                   "/Name /F%d\n"
                   "/BaseFont /%s\n"
                   "/Encoding /MacRomanEncoding\n"
@@ -4621,31 +4621,31 @@ static int gl2psPDFgroupListWriteObjects
   GL2PSprimitive *p = NULL;
   GL2PSpdfgroup *gro;
   int offs = entryoffs;
   GL2PStriangle *triangles;
   int size = 0;
 
   if(!gl2ps->pdfgrouplist)
     return offs;
-  
-  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){  
-    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i); 
+
+  for(i = 0; i < gl2psListNbr(gl2ps->pdfgrouplist); ++i){
+    gro = (GL2PSpdfgroup*)gl2psListPointer(gl2ps->pdfgrouplist, i);
     if(!gl2psListNbr(gro->ptrlist))
       continue;
     p = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, 0);
     switch(p->type){
     case GL2PS_POINT:
       break;
     case GL2PS_LINE:
       break;
     case GL2PS_TRIANGLE:
       size = gl2psListNbr(gro->ptrlist);
       triangles = (GL2PStriangle*)gl2psMalloc(sizeof(GL2PStriangle) * size);
-      for(j = 0; j < size; ++j){  
+      for(j = 0; j < size; ++j){
         p = *(GL2PSprimitive**)gl2psListPointer(gro->ptrlist, j);
         gl2psFillTriangleFromPrimitive(&triangles[j], p, GL_TRUE);
       }
       if(triangles[0].prop & T_VAR_COLOR){
         gl2ps->xreflist[gro->shobjno] = offs;
         offs += gl2psPrintPDFShader(gro->shobjno, triangles, size, 0);
       }
       if(triangles[0].prop & T_ALPHA_LESS_1){
@@ -4677,79 +4677,79 @@ static int gl2psPDFgroupListWriteObjects
     case GL2PS_SPECIAL :
       /* alignment contains the format for which the special output text
          is intended */
       if(p->data.text->alignment == GL2PS_PDF)
         offs += fprintf(gl2ps->stream, "%s\n", p->data.text->str);
       break;
     default:
       break;
-    } 
+    }
   }
   return offs;
 }
 
 /* All variable data has been written at this point and all required
    functioninality has been gathered, so we can write now file footer
    with cross reference table and trailer */
 
 static void gl2psPrintPDFFooter(void)
 {
-  int i, offs;  
+  int i, offs;
 
   gl2psPDFgroupListInit();
   gl2psPDFgroupListWriteMainStream();
- 
-  offs = gl2ps->xreflist[5] + gl2ps->streamlength; 
+
+  offs = gl2ps->xreflist[5] + gl2ps->streamlength;
   offs += gl2psClosePDFDataStream();
   gl2ps->xreflist[5] = offs;
-  
+
   offs += gl2psPrintPDFDataStreamLength(gl2ps->streamlength);
   gl2ps->xreflist[6] = offs;
   gl2ps->streamlength = 0;
-  
+
   offs += gl2psPrintPDFOpenPage();
   offs += gl2psPDFgroupListWriteVariableResources();
   gl2ps->xreflist = (int*)gl2psRealloc(gl2ps->xreflist,
                                        sizeof(int) * (gl2ps->objects_stack + 1));
   gl2ps->xreflist[7] = offs;
-  
+
   offs += gl2psPrintPDFGSObject();
   gl2ps->xreflist[8] = offs;
-  
-  gl2ps->xreflist[gl2ps->objects_stack] = 
+
+  gl2ps->xreflist[gl2ps->objects_stack] =
     gl2psPDFgroupListWriteObjects(gl2ps->xreflist[8]);
 
   /* Start cross reference table. The file has to been opened in
      binary mode to preserve the 20 digit string length! */
   fprintf(gl2ps->stream,
           "xref\n"
           "0 %d\n"
           "%010d 65535 f \n", gl2ps->objects_stack, 0);
-  
+
   for(i = 1; i < gl2ps->objects_stack; ++i)
     fprintf(gl2ps->stream, "%010d 00000 n \n", gl2ps->xreflist[i]);
-  
+
   fprintf(gl2ps->stream,
           "trailer\n"
-          "<<\n" 
+          "<<\n"
           "/Size %d\n"
           "/Info 1 0 R\n"
           "/Root 2 0 R\n"
           ">>\n"
           "startxref\n%d\n"
           "%%%%EOF\n",
           gl2ps->objects_stack, gl2ps->xreflist[gl2ps->objects_stack]);
-  
-  /* Free auxiliary lists and arrays */    
+
+  /* Free auxiliary lists and arrays */
   gl2psFree(gl2ps->xreflist);
   gl2psListAction(gl2ps->pdfprimlist, gl2psFreePrimitive);
   gl2psListDelete(gl2ps->pdfprimlist);
   gl2psPDFgroupListDelete();
-  
+
 #if defined(GL2PS_HAVE_ZLIB)
   if(gl2ps->options & GL2PS_COMPRESS){
     gl2psFreeCompress();
     gl2psFree(gl2ps->compress);
     gl2ps->compress = NULL;
   }
 #endif
 }
@@ -4757,26 +4757,26 @@ static void gl2psPrintPDFFooter(void)
 /* PDF begin viewport */
 
 static void gl2psPrintPDFBeginViewport(GLint viewport[4])
 {
   int offs = 0;
   GLint index;
   GLfloat rgba[4];
   int x = viewport[0], y = viewport[1], w = viewport[2], h = viewport[3];
-  
+
   glRenderMode(GL_FEEDBACK);
-  
+
   if(gl2ps->header){
     gl2psPrintPDFHeader();
     gl2ps->header = GL_FALSE;
   }
 
   offs += gl2psPrintf("q\n");
-  
+
   if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
     if(gl2ps->colormode == GL_RGBA || gl2ps->colorsize == 0){
       glGetFloatv(GL_COLOR_CLEAR_VALUE, rgba);
     }
     else{
       glGetIntegerv(GL_INDEX_CLEAR_VALUE, &index);
       rgba[0] = gl2ps->colormap[index][0];
       rgba[1] = gl2ps->colormap[index][1];
@@ -4786,28 +4786,28 @@ static void gl2psPrintPDFBeginViewport(G
     offs += gl2psPrintPDFFillColor(rgba);
     offs += gl2psPrintf("%d %d %d %d re\n"
                         "W\n"
                         "f\n",
                         x, y, w, h);
   }
   else{
     offs += gl2psPrintf("%d %d %d %d re\n"
-                        "W\n"   
+                        "W\n"
                         "n\n",
-                        x, y, w, h);            
-  }
-  
+                        x, y, w, h);
+  }
+
   gl2ps->streamlength += offs;
 }
 
 static GLint gl2psPrintPDFEndViewport(void)
 {
   GLint res;
-  
+
   res = gl2psPrintPrimitives();
   gl2ps->streamlength += gl2psPrintf("Q\n");
   return res;
 }
 
 static void gl2psPrintPDFFinalPrimitive(void)
 {
 }
@@ -4820,23 +4820,23 @@ static GL2PSbackend gl2psPDF = {
   gl2psPrintPDFBeginViewport,
   gl2psPrintPDFEndViewport,
   gl2psPrintPDFPrimitive,
   gl2psPrintPDFFinalPrimitive,
   "pdf",
   "Portable Document Format"
 };
 
-/********************************************************************* 
+/*********************************************************************
  *
  * SVG routines
  *
  *********************************************************************/
 
-static void gl2psSVGGetCoordsAndColors(int n, GL2PSvertex *verts, 
+static void gl2psSVGGetCoordsAndColors(int n, GL2PSvertex *verts,
                                        GL2PSxyz *xyz, GL2PSrgba *rgba)
 {
   int i, j;
 
   for(i = 0; i < n; i++){
     xyz[i][0] = verts[i].xyz[0];
     xyz[i][1] = gl2ps->viewport[3] - verts[i].xyz[1];
     xyz[i][2] = 0.0F;
@@ -4856,35 +4856,35 @@ static void gl2psSVGGetColorString(GL2PS
   sprintf(str, "#%2.2x%2.2x%2.2x", rc, gc, bc);
 }
 
 static void gl2psPrintSVGHeader(void)
 {
   int x, y, width, height;
   char col[32];
   time_t now;
-  
+
   time(&now);
-  
+
   if (gl2ps->options & GL2PS_LANDSCAPE){
     x = (int)gl2ps->viewport[1];
     y = (int)gl2ps->viewport[0];
     width = (int)gl2ps->viewport[3];
     height = (int)gl2ps->viewport[2];
   }
   else{
     x = (int)gl2ps->viewport[0];
     y = (int)gl2ps->viewport[1];
     width = (int)gl2ps->viewport[2];
     height = (int)gl2ps->viewport[3];
   }
-  
+
   /* Compressed SVG files (.svgz) are simply gzipped SVG files */
   gl2psPrintGzipHeader();
-  
+
   gl2psPrintf("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n");
   gl2psPrintf("<svg xmlns=\"http://www.w3.org/2000/svg\"\n");
   gl2psPrintf("     xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n"
               "     width=\"%dpx\" height=\"%dpx\" viewBox=\"%d %d %d %d\">\n",
               width, height, x, y, width, height);
   gl2psPrintf("<title>%s</title>\n", gl2ps->title);
   gl2psPrintf("<desc>\n");
   gl2psPrintf("Creator: GL2PS %d.%d.%d%s, %s\n"
@@ -4894,19 +4894,19 @@ static void gl2psPrintSVGHeader(void)
               GL2PS_EXTRA_VERSION, GL2PS_COPYRIGHT, gl2ps->producer, ctime(&now));
   gl2psPrintf("</desc>\n");
   gl2psPrintf("<defs>\n");
   gl2psPrintf("</defs>\n");
 
   if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
     gl2psSVGGetColorString(gl2ps->bgcolor, col);
     gl2psPrintf("<polygon fill=\"%s\" points=\"%d,%d %d,%d %d,%d %d,%d\"/>\n", col,
-                (int)gl2ps->viewport[0], (int)gl2ps->viewport[1], 
-                (int)gl2ps->viewport[2], (int)gl2ps->viewport[1], 
-                (int)gl2ps->viewport[2], (int)gl2ps->viewport[3], 
+                (int)gl2ps->viewport[0], (int)gl2ps->viewport[1],
+                (int)gl2ps->viewport[2], (int)gl2ps->viewport[1],
+                (int)gl2ps->viewport[2], (int)gl2ps->viewport[3],
                 (int)gl2ps->viewport[0], (int)gl2ps->viewport[3]);
   }
 
   /* group all the primitives and disable antialiasing */
   gl2psPrintf("<g shape-rendering=\"crispEdges\">\n");
 }
 
 static void gl2psPrintSVGSmoothTriangle(GL2PSxyz xyz[3], GL2PSrgba rgba[3])
@@ -4919,62 +4919,62 @@ static void gl2psPrintSVGSmoothTriangle(
   /* Apparently there is no easy way to do Gouraud shading in SVG
      without explicitly pre-defining gradients, so for now we just do
      recursive subdivision */
 
   if(gl2psSameColorThreshold(3, rgba, gl2ps->threshold)){
     gl2psSVGGetColorString(rgba[0], col);
     gl2psPrintf("<polygon fill=\"%s\" ", col);
     if(rgba[0][3] < 1.0F) gl2psPrintf("fill-opacity=\"%g\" ", rgba[0][3]);
-    gl2psPrintf("points=\"%g,%g %g,%g %g,%g\"/>\n", xyz[0][0], xyz[0][1], 
+    gl2psPrintf("points=\"%g,%g %g,%g %g,%g\"/>\n", xyz[0][0], xyz[0][1],
                 xyz[1][0], xyz[1][1], xyz[2][0], xyz[2][1]);
   }
   else{
     /* subdivide into 4 subtriangles */
     for(i = 0; i < 3; i++){
-      xyz2[0][i] = xyz[0][i]; 
+      xyz2[0][i] = xyz[0][i];
       xyz2[1][i] = 0.5F * (xyz[0][i] + xyz[1][i]);
       xyz2[2][i] = 0.5F * (xyz[0][i] + xyz[2][i]);
     }
     for(i = 0; i < 4; i++){
-      rgba2[0][i] = rgba[0][i]; 
+      rgba2[0][i] = rgba[0][i];
       rgba2[1][i] = 0.5F * (rgba[0][i] + rgba[1][i]);
       rgba2[2][i] = 0.5F * (rgba[0][i] + rgba[2][i]);
     }
     gl2psPrintSVGSmoothTriangle(xyz2, rgba2);
     for(i = 0; i < 3; i++){
       xyz2[0][i] = 0.5F * (xyz[0][i] + xyz[1][i]);
-      xyz2[1][i] = xyz[1][i]; 
+      xyz2[1][i] = xyz[1][i];
       xyz2[2][i] = 0.5F * (xyz[1][i] + xyz[2][i]);
     }
     for(i = 0; i < 4; i++){
       rgba2[0][i] = 0.5F * (rgba[0][i] + rgba[1][i]);
-      rgba2[1][i] = rgba[1][i]; 
+      rgba2[1][i] = rgba[1][i];
       rgba2[2][i] = 0.5F * (rgba[1][i] + rgba[2][i]);
     }
     gl2psPrintSVGSmoothTriangle(xyz2, rgba2);
     for(i = 0; i < 3; i++){
       xyz2[0][i] = 0.5F * (xyz[0][i] + xyz[2][i]);
-      xyz2[1][i] = xyz[2][i]; 
+      xyz2[1][i] = xyz[2][i];
       xyz2[2][i] = 0.5F * (xyz[1][i] + xyz[2][i]);
     }
     for(i = 0; i < 4; i++){
       rgba2[0][i] = 0.5F * (rgba[0][i] + rgba[2][i]);
-      rgba2[1][i] = rgba[2][i]; 
+      rgba2[1][i] = rgba[2][i];
       rgba2[2][i] = 0.5F * (rgba[1][i] + rgba[2][i]);
     }
     gl2psPrintSVGSmoothTriangle(xyz2, rgba2);
     for(i = 0; i < 3; i++){
       xyz2[0][i] = 0.5F * (xyz[0][i] + xyz[1][i]);
-      xyz2[1][i] = 0.5F * (xyz[1][i] + xyz[2][i]); 
+      xyz2[1][i] = 0.5F * (xyz[1][i] + xyz[2][i]);
       xyz2[2][i] = 0.5F * (xyz[0][i] + xyz[2][i]);
     }
     for(i = 0; i < 4; i++){
       rgba2[0][i] = 0.5F * (rgba[0][i] + rgba[1][i]);
-      rgba2[1][i] = 0.5F * (rgba[1][i] + rgba[2][i]); 
+      rgba2[1][i] = 0.5F * (rgba[1][i] + rgba[2][i]);
       rgba2[2][i] = 0.5F * (rgba[0][i] + rgba[2][i]);
     }
     gl2psPrintSVGSmoothTriangle(xyz2, rgba2);
   }
 }
 
 static void gl2psPrintSVGDash(GLushort pattern, GLint factor)
 {
@@ -4990,17 +4990,17 @@ static void gl2psPrintSVGDash(GLushort p
   }
   gl2psPrintf("\" ");
 }
 
 static void gl2psEndSVGLine(void)
 {
   int i;
   if(gl2ps->lastvertex.rgba[0] >= 0.){
-    gl2psPrintf("%g,%g\"/>\n", gl2ps->lastvertex.xyz[0], 
+    gl2psPrintf("%g,%g\"/>\n", gl2ps->lastvertex.xyz[0],
                 gl2ps->viewport[3] - gl2ps->lastvertex.xyz[1]);
     for(i = 0; i < 3; i++)
       gl2ps->lastvertex.xyz[i] = -1.;
     for(i = 0; i < 4; i++)
       gl2ps->lastvertex.rgba[i] = -1.;
   }
 }
 
@@ -5012,17 +5012,17 @@ static void gl2psPrintSVGPixmap(GLfloat 
   int i;
 
   /* The only image types supported by the SVG standard are JPEG, PNG
      and SVG. Here we choose PNG, and since we want to embed the image
      directly in the SVG stream (and not link to an external image
      file), we need to encode the pixmap into PNG in memory, then
      encode it into base64. */
 
-  png = gl2psListCreate(pixmap->width * pixmap->height * 3, 1000, 
+  png = gl2psListCreate(pixmap->width * pixmap->height * 3, 1000,
                         sizeof(unsigned char));
   gl2psConvertPixmapToPNG(pixmap, png);
   gl2psListEncodeBase64(png);
   gl2psPrintf("<image x=\"%g\" y=\"%g\" width=\"%d\" height=\"%d\"\n",
               x, y - pixmap->height, pixmap->width, pixmap->height);
   gl2psPrintf("xlink:href=\"data:image/png;base64,");
   for(i = 0; i < gl2psListNbr(png); i++){
     gl2psListRead(png, i, &c);
@@ -5081,17 +5081,17 @@ static void gl2psPrintSVGPrimitive(void 
     }
     gl2ps->lastvertex = prim->verts[1];
     gl2psSetLastColor(prim->verts[0].rgba);
     gl2ps->lastlinewidth = prim->width;
     gl2ps->lastpattern = prim->pattern;
     gl2ps->lastfactor = prim->factor;
     if(newline){
       gl2psSVGGetColorString(rgba[0], col);
-      gl2psPrintf("<polyline fill=\"none\" stroke=\"%s\" stroke-width=\"%g\" ", 
+      gl2psPrintf("<polyline fill=\"none\" stroke=\"%s\" stroke-width=\"%g\" ",
                   col, prim->width);
       if(rgba[0][3] < 1.0F) gl2psPrintf("stroke-opacity=\"%g\" ", rgba[0][3]);
       gl2psPrintSVGDash(prim->pattern, prim->factor);
       gl2psPrintf("points=\"%g,%g ", xyz[0][0], xyz[0][1]);
     }
     else{
       gl2psPrintf("%g,%g ", xyz[0][0], xyz[0][1]);
     }
@@ -5181,30 +5181,30 @@ static void gl2psPrintSVGPrimitive(void 
   default :
     break;
   }
 }
 
 static void gl2psPrintSVGFooter(void)
 {
   gl2psPrintf("</g>\n");
-  gl2psPrintf("</svg>\n");  
-  
+  gl2psPrintf("</svg>\n");
+
   gl2psPrintGzipFooter();
 }
 
 static void gl2psPrintSVGBeginViewport(GLint viewport[4])
 {
   GLint index;
   char col[32];
   GLfloat rgba[4];
   int x = viewport[0], y = viewport[1], w = viewport[2], h = viewport[3];
 
   glRenderMode(GL_FEEDBACK);
-  
+
   if(gl2ps->header){
     gl2psPrintSVGHeader();
     gl2ps->header = GL_FALSE;
   }
 
   if(gl2ps->options & GL2PS_DRAW_BACKGROUND){
     if(gl2ps->colormode == GL_RGBA || gl2ps->colorsize == 0){
       glGetFloatv(GL_COLOR_CLEAR_VALUE, rgba);
@@ -5212,28 +5212,28 @@ static void gl2psPrintSVGBeginViewport(G
     else{
       glGetIntegerv(GL_INDEX_CLEAR_VALUE, &index);
       rgba[0] = gl2ps->colormap[index][0];
       rgba[1] = gl2ps->colormap[index][1];
       rgba[2] = gl2ps->colormap[index][2];
       rgba[3] = 1.0F;
     }
     gl2psSVGGetColorString(rgba, col);
-    gl2psPrintf("<polygon fill=\"%s\" points=\"%d,%d %d,%d %d,%d %d,%d\"/>\n", col, 
-                x, gl2ps->viewport[3] - y, 
-                x + w, gl2ps->viewport[3] - y, 
-                x + w, gl2ps->viewport[3] - (y + h), 
+    gl2psPrintf("<polygon fill=\"%s\" points=\"%d,%d %d,%d %d,%d %d,%d\"/>\n", col,
+                x, gl2ps->viewport[3] - y,
+                x + w, gl2ps->viewport[3] - y,
+                x + w, gl2ps->viewport[3] - (y + h),
                 x, gl2ps->viewport[3] - (y + h));
   }
 
   gl2psPrintf("<clipPath id=\"cp%d%d%d%d\">\n", x, y, w, h);
-  gl2psPrintf("  <polygon points=\"%d,%d %d,%d %d,%d %d,%d\"/>\n", 
-              x, gl2ps->viewport[3] - y, 
-              x + w, gl2ps->viewport[3] - y, 
-              x + w, gl2ps->viewport[3] - (y + h), 
+  gl2psPrintf("  <polygon points=\"%d,%d %d,%d %d,%d %d,%d\"/>\n",
+              x, gl2ps->viewport[3] - y,
+              x + w, gl2ps->viewport[3] - y,
+              x + w, gl2ps->viewport[3] - (y + h),
               x, gl2ps->viewport[3] - (y + h));
   gl2psPrintf("</clipPath>\n");
   gl2psPrintf("<g clip-path=\"url(#cp%d%d%d%d)\">\n", x, y, w, h);
 }
 
 static GLint gl2psPrintSVGEndViewport(void)
 {
   GLint res;
@@ -5277,17 +5277,17 @@ static void gl2psPrintPGFColor(GL2PSrgba
 }
 
 static void gl2psPrintPGFHeader(void)
 {
   time_t now;
 
   time(&now);
 
-  fprintf(gl2ps->stream, 
+  fprintf(gl2ps->stream,
           "%% Title: %s\n"
           "%% Creator: GL2PS %d.%d.%d%s, %s\n"
           "%% For: %s\n"
           "%% CreationDate: %s",
           gl2ps->title, GL2PS_MAJOR_VERSION, GL2PS_MINOR_VERSION,
           GL2PS_PATCH_VERSION, GL2PS_EXTRA_VERSION, GL2PS_COPYRIGHT,
           gl2ps->producer, ctime(&now));
 
@@ -5331,59 +5331,59 @@ static const char *gl2psPGFTextAlignment
   case GL2PS_TEXT_C  : return "center";
   case GL2PS_TEXT_CL : return "west";
   case GL2PS_TEXT_CR : return "east";
   case GL2PS_TEXT_B  : return "south";
   case GL2PS_TEXT_BR : return "south east";
   case GL2PS_TEXT_T  : return "north";
   case GL2PS_TEXT_TL : return "north west";
   case GL2PS_TEXT_TR : return "north east";
-  case GL2PS_TEXT_BL : 
+  case GL2PS_TEXT_BL :
   default            : return "south west";
   }
 }
 
 static void gl2psPrintPGFPrimitive(void *data)
 {
   GL2PSprimitive *prim;
 
   prim = *(GL2PSprimitive**)data;
 
   switch(prim->type){
   case GL2PS_POINT :
     /* Points in openGL are rectangular */
     gl2psPrintPGFColor(prim->verts[0].rgba);
-    fprintf(gl2ps->stream, 
+    fprintf(gl2ps->stream,
             "\\pgfpathrectangle{\\pgfpoint{%fpt}{%fpt}}"
             "{\\pgfpoint{%fpt}{%fpt}}\n\\pgfusepath{fill}\n",
             prim->verts[0].xyz[0]-0.5*prim->width,
             prim->verts[0].xyz[1]-0.5*prim->width,
             prim->width,prim->width);
     break;
   case GL2PS_LINE :
     gl2psPrintPGFColor(prim->verts[0].rgba);
     if(gl2ps->lastlinewidth != prim->width){
       gl2ps->lastlinewidth = prim->width;
       fprintf(gl2ps->stream, "\\pgfsetlinewidth{%fpt}\n", gl2ps->lastlinewidth);
     }
     gl2psPrintPGFDash(prim->pattern, prim->factor);
-    fprintf(gl2ps->stream, 
+    fprintf(gl2ps->stream,
             "\\pgfpathmoveto{\\pgfpoint{%fpt}{%fpt}}\n"
             "\\pgflineto{\\pgfpoint{%fpt}{%fpt}}\n"
             "\\pgfusepath{stroke}\n",
             prim->verts[1].xyz[0], prim->verts[1].xyz[1],
             prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
     break;
   case GL2PS_TRIANGLE :
     if(gl2ps->lastlinewidth != 0){
       gl2ps->lastlinewidth = 0;
       fprintf(gl2ps->stream, "\\pgfsetlinewidth{0.01pt}\n");
     }
     gl2psPrintPGFColor(prim->verts[0].rgba);
-    fprintf(gl2ps->stream, 
+    fprintf(gl2ps->stream,
             "\\pgfpathmoveto{\\pgfpoint{%fpt}{%fpt}}\n"
             "\\pgflineto{\\pgfpoint{%fpt}{%fpt}}\n"
             "\\pgflineto{\\pgfpoint{%fpt}{%fpt}}\n"
             "\\pgfpathclose\n"
             "\\pgfusepath{fill,stroke}\n",
             prim->verts[2].xyz[0], prim->verts[2].xyz[1],
             prim->verts[1].xyz[0], prim->verts[1].xyz[1],
             prim->verts[0].xyz[0], prim->verts[0].xyz[1]);
@@ -5442,24 +5442,24 @@ static void gl2psPrintPGFBeginViewport(G
     else{
       glGetIntegerv(GL_INDEX_CLEAR_VALUE, &index);
       rgba[0] = gl2ps->colormap[index][0];
       rgba[1] = gl2ps->colormap[index][1];
       rgba[2] = gl2ps->colormap[index][2];
       rgba[3] = 1.0F;
     }
     gl2psPrintPGFColor(rgba);
-    fprintf(gl2ps->stream, 
+    fprintf(gl2ps->stream,
             "\\pgfpathrectangle{\\pgfpoint{%dpt}{%dpt}}"
             "{\\pgfpoint{%dpt}{%dpt}}\n"
             "\\pgfusepath{fill}\n",
             x, y, w, h);
   }
-  
-  fprintf(gl2ps->stream, 
+
+  fprintf(gl2ps->stream,
           "\\pgfpathrectangle{\\pgfpoint{%dpt}{%dpt}}"
           "{\\pgfpoint{%dpt}{%dpt}}\n"
           "\\pgfusepath{clip}\n",
           x, y, w, h);
 }
 
 static GLint gl2psPrintPGFEndViewport(void)
 {
@@ -5481,17 +5481,17 @@ static GL2PSbackend gl2psPGF = {
   gl2psPrintPGFBeginViewport,
   gl2psPrintPGFEndViewport,
   gl2psPrintPGFPrimitive,
   gl2psPrintPGFFinalPrimitive,
   "tex",
   "PGF Latex Graphics"
 };
 
-/********************************************************************* 
+/*********************************************************************
  *
  * General primitive printing routine
  *
  *********************************************************************/
 
 /* Warning: the ordering of the backends must match the format
    #defines in gl2ps.h */
 
@@ -5516,17 +5516,17 @@ static void gl2psComputeTightBoundingBox
       gl2ps->viewport[0] = (GLint)prim->verts[i].xyz[0];
     if(prim->verts[i].xyz[0] > gl2ps->viewport[2])
       gl2ps->viewport[2] = (GLint)(prim->verts[i].xyz[0] + 0.5F);
     if(prim->verts[i].xyz[1] < gl2ps->viewport[1])
       gl2ps->viewport[1] = (GLint)prim->verts[i].xyz[1];
     if(prim->verts[i].xyz[1] > gl2ps->viewport[3])
       gl2ps->viewport[3] = (GLint)(prim->verts[i].xyz[1] + 0.5F);
   }
-}  
+}
 
 static GLint gl2psPrintPrimitives(void)
 {
   GL2PSbsptree *root;
   GL2PSxyz eye = {0.0F, 0.0F, 100.0F * GL2PS_ZSCALE};
   GLint used;
 
   used = glRenderMode(GL_RENDER);
@@ -5537,17 +5537,17 @@ static GLint gl2psPrintPrimitives(void)
   }
 
   if(used > 0)
     gl2psParseFeedbackBuffer(used);
 
   gl2psRescaleAndOffset();
 
   if(gl2ps->header){
-    if(gl2psListNbr(gl2ps->primitives) && 
+    if(gl2psListNbr(gl2ps->primitives) &&
        (gl2ps->options & GL2PS_TIGHT_BOUNDING_BOX)){
       gl2ps->viewport[0] = gl2ps->viewport[1] = 100000;
       gl2ps->viewport[2] = gl2ps->viewport[3] = -100000;
       gl2psListAction(gl2ps->primitives, gl2psComputeTightBoundingBox);
     }
     (gl2psbackends[gl2ps->format]->printHeader)();
     gl2ps->header = GL_FALSE;
   }
@@ -5579,36 +5579,36 @@ static GLint gl2psPrintPrimitives(void)
     root = (GL2PSbsptree*)gl2psMalloc(sizeof(GL2PSbsptree));
     gl2psBuildBspTree(root, gl2ps->primitives);
     if(GL_TRUE == gl2ps->boundary) gl2psBuildPolygonBoundary(root);
     if(gl2ps->options & GL2PS_OCCLUSION_CULL){
       gl2psTraverseBspTree(root, eye, -GL2PS_EPSILON, gl2psLess,
                            gl2psAddInImageTree, 1);
       gl2psFreeBspImageTree(&gl2ps->imagetree);
     }
-    gl2psTraverseBspTree(root, eye, GL2PS_EPSILON, gl2psGreater, 
+    gl2psTraverseBspTree(root, eye, GL2PS_EPSILON, gl2psGreater,
                          gl2psbackends[gl2ps->format]->printPrimitive, 0);
     gl2psFreeBspTree(&root);
     /* reallocate the primitive list (it's been deleted by
        gl2psBuildBspTree) in case there is another viewport */
     gl2ps->primitives = gl2psListCreate(500, 500, sizeof(GL2PSprimitive*));
     break;
   }
   gl2psbackends[gl2ps->format]->printFinalPrimitive();
 
   return GL2PS_SUCCESS;
 }
 
-/********************************************************************* 
+/*********************************************************************
  *
  * Public routines
  *
  *********************************************************************/
 
-GL2PSDLL_API GLint gl2psBeginPage(const char *title, const char *producer, 
+GL2PSDLL_API GLint gl2psBeginPage(const char *title, const char *producer,
                                   GLint viewport[4], GLint format, GLint sort,
                                   GLint options, GLint colormode,
                                   GLint colorsize, GL2PSrgba *colormap,
                                   GLint nr, GLint ng, GLint nb, GLint buffersize,
                                   FILE *stream, const char *filename)
 {
   GLint index;
   int i;
@@ -5666,17 +5666,17 @@ GL2PSDLL_API GLint gl2psBeginPage(const 
   else{
     for(i = 0; i < 4; i++){
       gl2ps->viewport[i] = viewport[i];
     }
   }
 
   if(!gl2ps->viewport[2] || !gl2ps->viewport[3]){
     gl2psMsg(GL2PS_ERROR, "Incorrect viewport (x=%d, y=%d, width=%d, height=%d)",
-             gl2ps->viewport[0], gl2ps->viewport[1], 
+             gl2ps->viewport[0], gl2ps->viewport[1],
              gl2ps->viewport[2], gl2ps->viewport[3]);
     gl2psFree(gl2ps);
     gl2ps = NULL;
     return GL2PS_ERROR;
   }
 
   gl2ps->threshold[0] = nr ? 1.0F / (GLfloat)nr : 0.064F;
   gl2ps->threshold[1] = ng ? 1.0F / (GLfloat)ng : 0.034F;
@@ -5690,21 +5690,21 @@ GL2PSDLL_API GLint gl2psBeginPage(const 
     gl2ps->lastvertex.rgba[i] = -1.0F;
     gl2ps->lastrgba[i] = -1.0F;
   }
   gl2ps->lastlinewidth = -1.0F;
   gl2ps->lastpattern = 0;
   gl2ps->lastfactor = 0;
   gl2ps->imagetree = NULL;
   gl2ps->primitivetoadd = NULL;
-  gl2ps->zerosurfacearea = GL_FALSE;  
+  gl2ps->zerosurfacearea = GL_FALSE;
   gl2ps->pdfprimlist = NULL;
   gl2ps->pdfgrouplist = NULL;
   gl2ps->xreflist = NULL;
-  
+
   /* get default blending mode from current OpenGL state (enabled by
      default for SVG) */
   gl2ps->blending = (gl2ps->format == GL2PS_SVG) ? GL_TRUE : glIsEnabled(GL_BLEND);
   glGetIntegerv(GL_BLEND_SRC, &gl2ps->blendfunc[0]);
   glGetIntegerv(GL_BLEND_DST, &gl2ps->blendfunc[1]);
 
   if(gl2ps->colormode == GL_RGBA){
     gl2ps->colorsize = 0;
@@ -5737,55 +5737,55 @@ GL2PSDLL_API GLint gl2psBeginPage(const 
   if(!title){
     gl2ps->title = (char*)gl2psMalloc(sizeof(char));
     gl2ps->title[0] = '\0';
   }
   else{
     gl2ps->title = (char*)gl2psMalloc((strlen(title)+1)*sizeof(char));
     strcpy(gl2ps->title, title);
   }
-    
+
   if(!producer){
     gl2ps->producer = (char*)gl2psMalloc(sizeof(char));
     gl2ps->producer[0] = '\0';
   }
   else{
     gl2ps->producer = (char*)gl2psMalloc((strlen(producer)+1)*sizeof(char));
     strcpy(gl2ps->producer, producer);
   }
-  
+
   if(!filename){
     gl2ps->filename = (char*)gl2psMalloc(sizeof(char));
     gl2ps->filename[0] = '\0';
   }
   else{
     gl2ps->filename = (char*)gl2psMalloc((strlen(filename)+1)*sizeof(char));
     strcpy(gl2ps->filename, filename);
   }
 
   gl2ps->primitives = gl2psListCreate(500, 500, sizeof(GL2PSprimitive*));
   gl2ps->auxprimitives = gl2psListCreate(100, 100, sizeof(GL2PSprimitive*));
   gl2ps->feedback = (GLfloat*)gl2psMalloc(gl2ps->buffersize * sizeof(GLfloat));
   glFeedbackBuffer(gl2ps->buffersize, GL_3D_COLOR, gl2ps->feedback);
-  glRenderMode(GL_FEEDBACK);  
+  glRenderMode(GL_FEEDBACK);
 
   return GL2PS_SUCCESS;
 }
 
 GL2PSDLL_API GLint gl2psEndPage(void)
 {
   GLint res;
 
   if(!gl2ps) return GL2PS_UNINITIALIZED;
 
   res = gl2psPrintPrimitives();
 
   if(res != GL2PS_OVERFLOW)
     (gl2psbackends[gl2ps->format]->printFooter)();
-  
+
   fflush(gl2ps->stream);
 
   gl2psListDelete(gl2ps->primitives);
   gl2psListDelete(gl2ps->auxprimitives);
   gl2psFreeImagemap(gl2ps->imagemap_head);
   gl2psFree(gl2ps->colormap);
   gl2psFree(gl2ps->title);
   gl2psFree(gl2ps->producer);
@@ -5797,17 +5797,17 @@ GL2PSDLL_API GLint gl2psEndPage(void)
   return res;
 }
 
 GL2PSDLL_API GLint gl2psBeginViewport(GLint viewport[4])
 {
   if(!gl2ps) return GL2PS_UNINITIALIZED;
 
   (gl2psbackends[gl2ps->format]->beginViewport)(viewport);
-  
+
   return GL2PS_SUCCESS;
 }
 
 GL2PSDLL_API GLint gl2psEndViewport(void)
 {
   GLint res;
 
   if(!gl2ps) return GL2PS_UNINITIALIZED;
@@ -5815,17 +5815,17 @@ GL2PSDLL_API GLint gl2psEndViewport(void
   res = (gl2psbackends[gl2ps->format]->endViewport)();
 
   /* reset last used colors, line widths */
   gl2ps->lastlinewidth = -1.0F;
 
   return res;
 }
 
-GL2PSDLL_API GLint gl2psTextOpt(const char *str, const char *fontname, 
+GL2PSDLL_API GLint gl2psTextOpt(const char *str, const char *fontname,
                                 GLshort fontsize, GLint alignment, GLfloat angle)
 {
   return gl2psAddText(GL2PS_TEXT, str, fontname, fontsize, alignment, angle);
 }
 
 GL2PSDLL_API GLint gl2psText(const char *str, const char *fontname, GLshort fontsize)
 {
   return gl2psAddText(GL2PS_TEXT, str, fontname, fontsize, GL2PS_TEXT_BL, 0.0F);
@@ -5833,17 +5833,17 @@ GL2PSDLL_API GLint gl2psText(const char 
 
 GL2PSDLL_API GLint gl2psSpecial(GLint format, const char *str)
 {
   return gl2psAddText(GL2PS_SPECIAL, str, "", 0, format, 0.0F);
 }
 
 GL2PSDLL_API GLint gl2psDrawPixels(GLsizei width, GLsizei height,
                                    GLint xorig, GLint yorig,
-                                   GLenum format, GLenum type, 
+                                   GLenum format, GLenum type,
                                    const void *pixels)
 {
   int size, i;
   GLfloat pos[4], *piv, zoom_x, zoom_y;
   GL2PSprimitive *prim;
   GLboolean valid;
 
   if(!gl2ps || !pixels) return GL2PS_UNINITIALIZED;
@@ -5894,17 +5894,17 @@ GL2PSDLL_API GLint gl2psDrawPixels(GLsiz
       prim->data.image->format = GL_RGB;
       size = height * width * 3;
       prim->data.image->pixels = (GLfloat*)gl2psMalloc(size * sizeof(GLfloat));
       piv = (GLfloat*)pixels;
       for(i = 0; i < size; ++i, ++piv){
         prim->data.image->pixels[i] = *piv;
         if(!((i + 1) % 3))
           ++piv;
-      }   
+      }
     }
     else{
       size = height * width * 4;
       prim->data.image->pixels = (GLfloat*)gl2psMalloc(size * sizeof(GLfloat));
       memcpy(prim->data.image->pixels, pixels, size * sizeof(GLfloat));
     }
     break;
   case GL_RGB:
@@ -5921,21 +5921,21 @@ GL2PSDLL_API GLint gl2psDrawPixels(GLsiz
   return GL2PS_SUCCESS;
 }
 
 GL2PSDLL_API GLint gl2psDrawImageMap(GLsizei width, GLsizei height,
                                      const GLfloat position[3],
                                      const unsigned char *imagemap){
   int size, i;
   int sizeoffloat = sizeof(GLfloat);
-  
+
   if(!gl2ps || !imagemap) return GL2PS_UNINITIALIZED;
 
   if((width <= 0) || (height <= 0)) return GL2PS_ERROR;
-  
+
   size = height + height * ((width - 1) / 8);
   glPassThrough(GL2PS_IMAGEMAP_TOKEN);
   glBegin(GL_POINTS);
   glVertex3f(position[0], position[1],position[2]);
   glEnd();
   glPassThrough((GLfloat)width);
   glPassThrough((GLfloat)height);
   for(i = 0; i < size; i += sizeoffloat){
@@ -6005,17 +6005,17 @@ GL2PSDLL_API GLint gl2psDisable(GLint mo
 }
 
 GL2PSDLL_API GLint gl2psPointSize(GLfloat value)
 {
   if(!gl2ps) return GL2PS_UNINITIALIZED;
 
   glPassThrough(GL2PS_POINT_SIZE_TOKEN);
   glPassThrough(value);
-  
+
   return GL2PS_SUCCESS;
 }
 
 GL2PSDLL_API GLint gl2psLineWidth(GLfloat value)
 {
   if(!gl2ps) return GL2PS_UNINITIALIZED;
 
   glPassThrough(GL2PS_LINE_WIDTH_TOKEN);
diff --git a/src/gl2ps.h b/src/gl2ps.h
--- a/src/gl2ps.h
+++ b/src/gl2ps.h
@@ -134,19 +134,19 @@
 /* Arguments for gl2psEnable/gl2psDisable */
 
 #define GL2PS_POLYGON_OFFSET_FILL 1
 #define GL2PS_POLYGON_BOUNDARY    2
 #define GL2PS_LINE_STIPPLE        3
 #define GL2PS_BLEND               4
 
 /* Text alignment (o=raster position; default mode is BL):
-   +---+ +---+ +---+ +---+ +---+ +---+ +-o-+ o---+ +---o 
-   | o | o   | |   o |   | |   | |   | |   | |   | |   | 
-   +---+ +---+ +---+ +-o-+ o---+ +---o +---+ +---+ +---+ 
+   +---+ +---+ +---+ +---+ +---+ +---+ +-o-+ o---+ +---o
+   | o | o   | |   o |   | |   | |   | |   | |   | |   |
+   +---+ +---+ +---+ +-o-+ o---+ +---o +---+ +---+ +---+
     C     CL    CR    B     BL    BR    T     TL    TR */
 
 #define GL2PS_TEXT_C  1
 #define GL2PS_TEXT_CL 2
 #define GL2PS_TEXT_CR 3
 #define GL2PS_TEXT_B  4
 #define GL2PS_TEXT_BL 5
 #define GL2PS_TEXT_BR 6
@@ -155,30 +155,30 @@
 #define GL2PS_TEXT_TR 9
 
 typedef GLfloat GL2PSrgba[4];
 
 #if defined(__cplusplus)
 extern "C" {
 #endif
 
-GL2PSDLL_API GLint gl2psBeginPage(const char *title, const char *producer, 
+GL2PSDLL_API GLint gl2psBeginPage(const char *title, const char *producer,
                                   GLint viewport[4], GLint format, GLint sort,
                                   GLint options, GLint colormode,
-                                  GLint colorsize, GL2PSrgba *colormap, 
+                                  GLint colorsize, GL2PSrgba *colormap,
                                   GLint nr, GLint ng, GLint nb, GLint buffersize,
                                   FILE *stream, const char *filename);
 GL2PSDLL_API GLint gl2psEndPage(void);
 GL2PSDLL_API GLint gl2psSetOptions(GLint options);
 GL2PSDLL_API GLint gl2psGetOptions(GLint *options);
 GL2PSDLL_API GLint gl2psBeginViewport(GLint viewport[4]);
 GL2PSDLL_API GLint gl2psEndViewport(void);
-GL2PSDLL_API GLint gl2psText(const char *str, const char *fontname, 
+GL2PSDLL_API GLint gl2psText(const char *str, const char *fontname,
                              GLshort fontsize);
-GL2PSDLL_API GLint gl2psTextOpt(const char *str, const char *fontname, 
+GL2PSDLL_API GLint gl2psTextOpt(const char *str, const char *fontname,
                                 GLshort fontsize, GLint align, GLfloat angle);
 GL2PSDLL_API GLint gl2psSpecial(GLint format, const char *str);
 GL2PSDLL_API GLint gl2psDrawPixels(GLsizei width, GLsizei height,
                                    GLint xorig, GLint yorig,
                                    GLenum format, GLenum type, const void *pixels);
 GL2PSDLL_API GLint gl2psEnable(GLint mode);
 GL2PSDLL_API GLint gl2psDisable(GLint mode);
 GL2PSDLL_API GLint gl2psPointSize(GLfloat value);
diff --git a/src/graphics.cc b/src/graphics.cc
--- a/src/graphics.cc
+++ b/src/graphics.cc
@@ -332,17 +332,17 @@ convert_position (const Matrix& pos, con
     }
   else if (from_units.compare ("characters"))
     {
       if (res <= 0)
         res = xget (0, "screenpixelsperinch").double_value ();
 
       double f = 0.0;
 
-      // FIXME -- this assumes the system font is Helvetica 10pt 
+      // FIXME -- this assumes the system font is Helvetica 10pt
       //          (for which "x" requires 6x12 pixels at 74.951 pixels/inch)
       f = 12.0 * res / 74.951;
 
       if (f > 0)
         {
           retval(0) = 0.5 * pos(0) * f;
           retval(1) = pos(1) * f;
           if (is_rectangle)
@@ -661,17 +661,17 @@ get_array_limits (const Array<T>& m, dou
 {
   const T *data = m.data ();
   octave_idx_type n = m.numel ();
 
   for (octave_idx_type i = 0; i < n; i++)
     {
       double e = double (data[i]);
 
-      // Don't need to test for NaN here as NaN>x and NaN<x is always false 
+      // Don't need to test for NaN here as NaN>x and NaN<x is always false
       if (! xisinf (e))
         {
           if (e < emin)
             emin = e;
 
           if (e > emax)
             emax = e;
 
@@ -895,17 +895,17 @@ color_values::str2rgb (std::string str)
     tmp_rgb[0] = tmp_rgb[1] = 1;
   else if (str.compare(0, len, "magenta", 0, len) == 0)
     tmp_rgb[0] = tmp_rgb[2] = 1;
   else if (str.compare(0, len, "cyan", 0, len) == 0)
     tmp_rgb[1] = tmp_rgb[2] = 1;
   else if (str.compare(0, len, "white", 0, len) == 0
            || str.compare(0, len, "w", 0, len) == 0)
     tmp_rgb[0] = tmp_rgb[1] = tmp_rgb[2] = 1;
-  else  
+  else
     retval = false;
 
   if (retval)
     {
       for (int i = 0; i < 3; i++)
         xrgb(i) = tmp_rgb[i];
     }
 
@@ -940,17 +940,17 @@ color_property::do_set (const octave_val
                       color_val = col;
                       current_type = color_t;
                       return true;
                     }
                 }
               else
                 error ("invalid value for color property \"%s\" (value = %s)",
                        get_name ().c_str (), s.c_str ());
-            }   
+            }
         }
       else
         error ("invalid value for color property \"%s\"",
            get_name ().c_str ());
     }
   else if (val.is_numeric_type ())
     {
       Matrix m = val.matrix_value ();
@@ -967,17 +967,17 @@ color_property::do_set (const octave_val
                   return true;
                 }
             }
         }
       else
         error ("invalid value for color property \"%s\"",
            get_name ().c_str ());
     }
-  else 
+  else
     error ("invalid value for color property \"%s\"",
            get_name ().c_str ());
 
   return false;
 }
 
 bool
 double_radio_property::do_set (const octave_value& val)
@@ -1005,17 +1005,17 @@ double_radio_property::do_set (const oct
 
       if (current_type != double_t || new_dval != dval)
         {
           dval = new_dval;
           current_type = double_t;
           return true;
         }
     }
-  else 
+  else
     error ("invalid value for double_radio property \"%s\"",
            get_name ().c_str ());
 
   return false;
 }
 
 bool
 array_property::validate (const octave_value& v)
@@ -1180,24 +1180,24 @@ handle_property::do_set (const octave_va
     }
   else
     error ("set: invalid graphics handle for property \"%s\"",
            get_name ().c_str ());
 
   return false;
 }
 
-Matrix 
+Matrix
 children_property::do_get_children (bool return_hidden) const
 {
   Matrix retval (children_list.size (), 1);
   octave_idx_type k = 0;
 
   graphics_object go = gh_manager::get_object (0);
-          
+
   root_figure::properties& props =
     dynamic_cast<root_figure::properties&> (go.get_properties ());
 
   if (! props.is_showhiddenhandles ())
     {
       for (const_children_list_iterator p = children_list.begin ();
            p != children_list.end (); p++)
         {
@@ -1215,21 +1215,21 @@ children_property::do_get_children (bool
       retval.resize (k, 1);
     }
   else
     {
       for (const_children_list_iterator p = children_list.begin ();
            p != children_list.end (); p++)
         retval(k++) = *p;
     }
-      
+
   return retval;
 }
 
-void 
+void
 children_property::do_delete_children (bool clear)
 {
   for (children_list_iterator p = children_list.begin ();
        p != children_list.end (); p++)
     {
       graphics_object go = gh_manager::get_object (*p);
 
       if (go.valid_object ())
@@ -1417,17 +1417,17 @@ property::create (const std::string& nam
           else
             error ("addproperty: invalid object type (= %s)",
                    go_name.c_str ());
         }
       else
         error ("addproperty: unsupported type for dynamic property (= %s)",
                type.c_str ());
     }
-  
+
   return retval;
 }
 
 // ---------------------------------------------------------------------
 
 void
 property_list::set (const caseless_str& name, const octave_value& val)
 {
@@ -1598,17 +1598,17 @@ property_list::as_struct (const std::str
       const pval_map_type pval_map = p->second;
 
       for (pval_map_const_iterator q = pval_map.begin ();
            q != pval_map.end ();
            q++)
         m.assign (prefix + q->first, q->second);
     }
 
-  return m;    
+  return m;
 }
 
 graphics_handle::graphics_handle (const octave_value& a)
   : val (octave_NaN)
 {
   if (a.is_empty ())
     /* do nothing */;
   else
@@ -1857,31 +1857,31 @@ gh_manager::do_free (const graphics_hand
     {
       if (h.value () != 0)
         {
           iterator p = handle_map.find (h);
 
           if (p != handle_map.end ())
             {
               base_properties& bp = p->second.get_properties ();
-              
+
               bp.set_beingdeleted (true);
 
               bp.delete_children ();
 
               octave_value val = bp.get_deletefcn ();
 
               bp.execute_deletefcn ();
 
               // Notify graphics toolkit.
               graphics_toolkit toolkit = p->second.get_toolkit ();
               if (toolkit)
                 toolkit.finalize (p->second);
 
-              // Note: this will be valid only for first explicitly 
+              // Note: this will be valid only for first explicitly
               // deleted object.  All its children will then have an
               // unknown graphics toolkit.
 
               // Graphics handles for non-figure objects are negative
               // integers plus some random fractional part.  To avoid
               // running out of integers, we recycle the integer part
               // but tack on a new random part each time.
 
@@ -1936,17 +1936,17 @@ reparent (const octave_value& ov, const 
 
   if (! error_state)
     {
       h = gh_manager::lookup (val);
 
       if (h.ok ())
         {
           graphics_object obj = gh_manager::get_object (h);
-          
+
           graphics_handle parent_h = obj.get_parent ();
 
           graphics_object parent_obj = gh_manager::get_object (parent_h);
 
           parent_obj.remove_child (h);
 
           if (adopt)
             obj.set ("parent", new_parent.value ());
@@ -2275,17 +2275,17 @@ base_properties::add_listener (const cas
 {
   property p = get_property (nm);
 
   if (! error_state && p.ok ())
     p.add_listener (v, mode);
 }
 
 void
-base_properties::delete_listener (const caseless_str& nm, 
+base_properties::delete_listener (const caseless_str& nm,
                                   const octave_value& v, listener_mode mode)
 {
   property p = get_property (nm);
 
   if (! error_state && p.ok ())
     p.delete_listener (v, mode);
 }
 
@@ -2472,26 +2472,26 @@ base_graphics_object::remove_all_listene
 std::string
 base_graphics_object::values_as_string (void)
 {
   std::string retval;
 
   if (valid_object ())
     {
       octave_map m = get ().map_value ();
-  
+
       for (octave_map::const_iterator pa = m.begin (); pa != m.end (); pa++)
         {
           if (pa->first != "children")
             {
               property p = get_properties ().get_property (pa->first);
 
               if (p.ok () && ! p.is_hidden ())
                 {
-                  retval += "\n\t" + std::string (pa->first) + ":  "; 
+                  retval += "\n\t" + std::string (pa->first) + ":  ";
                   if (p.is_radio ())
                     retval += p.values_as_string ();
                 }
             }
         }
       if (retval != "")
         retval += "\n";
     }
@@ -2504,17 +2504,17 @@ base_graphics_object::values_as_string (
 octave_scalar_map
 base_graphics_object::values_as_struct (void)
 {
   octave_scalar_map retval;
 
   if (valid_object ())
     {
       octave_scalar_map m = get ().scalar_map_value ();
-  
+
       for (octave_scalar_map::const_iterator pa = m.begin ();
            pa != m.end (); pa++)
         {
           if (pa->first != "children")
             {
               property p = get_properties ().get_property (pa->first);
 
               if (p.ok () && ! p.is_hidden ())
@@ -2645,44 +2645,44 @@ root_figure::properties::update_units (v
 void
 root_figure::properties::remove_child (const graphics_handle& gh)
 {
   gh_manager::pop_figure (gh);
 
   graphics_handle cf = gh_manager::current_figure ();
 
   xset (0, "currentfigure", cf.value ());
-  
+
   base_properties::remove_child (gh);
 }
 
 property_list
 root_figure::factory_properties = root_figure::init_factory_properties ();
 
 static void
 reset_default_properties (property_list& default_properties)
 {
   property_list new_defaults;
 
   for (property_list::plist_map_const_iterator p = default_properties.begin ();
        p != default_properties.end (); p++)
     {
       const property_list::pval_map_type pval_map = p->second;
       std::string prefix = p->first;
-      
+
       for (property_list::pval_map_const_iterator q = pval_map.begin ();
            q != pval_map.end ();
            q++)
         {
           std::string s = q->first;
 
           if (prefix == "axes" && (s == "position" || s == "units"))
             new_defaults.set (prefix + s, q->second);
-          else if (prefix == "figure" && (s == "position" || s == "units" 
-                                          || s == "windowstyle" 
+          else if (prefix == "figure" && (s == "position" || s == "units"
+                                          || s == "windowstyle"
                                           || s == "paperunits"))
             new_defaults.set (prefix + s, q->second);
         }
     }
 
   default_properties = new_defaults;
 }
 
@@ -2848,24 +2848,24 @@ figure::properties::set_papertype (const
                 }
             }
         }
     }
 }
 
 static Matrix
 papersize_from_type (const caseless_str punits, const caseless_str typ)
-{ 
+{
   Matrix ret (1, 2, 1.0);
 
   if (! punits.compare ("normalized"))
     {
       double in2units;
       double mm2units;
-      
+
       if (punits.compare ("inches"))
         {
           in2units = 1.0;
           mm2units = 1 / 25.4 ;
         }
       else if (punits.compare ("centimeters"))
         {
           in2units = 2.54;
@@ -2998,26 +2998,26 @@ papersize_from_type (const caseless_str 
           ret (1) = 34.0 * in2units;
         }
       else if (typ.compare ("e"))
         {
           ret (0) = 34.0 * in2units;
           ret (1) = 43.0 * in2units;
         }
     }
- 
+
   return ret;
 }
 
 void
 figure::properties::update_paperunits (const caseless_str& old_paperunits)
 {
   Matrix pos = get_paperposition ().matrix_value ();
   Matrix sz = get_papersize ().matrix_value ();
-  
+
   pos (0) = pos (0) / sz(0);
   pos (1) = pos (1) / sz(1);
   pos (2) = pos (2) / sz(0);
   pos (3) = pos (3) / sz(1);
 
   caseless_str punits = get_paperunits ();
   caseless_str typ = get_papertype ();
 
@@ -3058,17 +3058,17 @@ figure::properties::update_paperunits (c
 }
 
 void
 figure::properties::update_papertype (void)
 {
   caseless_str typ = get_papertype ();
 
   if (! typ.compare ("<custom>"))
-    // Call papersize.set rather than set_papersize to avoid loops between 
+    // Call papersize.set rather than set_papersize to avoid loops between
     // update_papersize and update_papertype
     papersize.set (octave_value (papersize_from_type (get_paperunits (), typ)));
 }
 
 void
 figure::properties::update_papersize (void)
 {
   papertype.set ("<custom>");
@@ -3197,29 +3197,29 @@ axes::properties::init (void)
   xset (ylabel.handle_value (), "verticalalignmentmode", "auto");
   xset (title.handle_value (), "verticalalignment", "bottom");
   xset (title.handle_value (), "verticalalignmentmode", "auto");
 
   xset (ylabel.handle_value (), "rotation", 90.0);
   xset (ylabel.handle_value (), "rotationmode", "auto");
 
   xset (zlabel.handle_value (), "visible", "off");
-  
+
   xset (xlabel.handle_value (), "clipping", "off");
   xset (ylabel.handle_value (), "clipping", "off");
   xset (zlabel.handle_value (), "clipping", "off");
   xset (title.handle_value (), "clipping", "off");
 
   adopt (xlabel.handle_value ());
   adopt (ylabel.handle_value ());
   adopt (zlabel.handle_value ());
   adopt (title.handle_value ());
 }
 
-void 
+void
 axes::properties::sync_positions (void)
 {
 #if 0
   // FIXME -- this should take font metrics into consideration,
   // and also the fact that the colorbox leaves the outerposition
   // alone but alters the position. For now just don't adjust the
   // positions relative to each other.
 
@@ -3345,21 +3345,21 @@ axes::properties::set_defaults (base_gra
   dataaspectratiomode = "auto";
   layer = "bottom";
 
   Matrix tlim (1, 2, 0.0);
   tlim(1) = 1;
   xlim = tlim;
   ylim = tlim;
   zlim = tlim;
-  
+
   Matrix cl (1, 2, 0);
   cl(1) = 1;
   clim = cl;
-  
+
   xlimmode = "auto";
   ylimmode = "auto";
   zlimmode = "auto";
   climmode = "auto";
 
   xgrid = "off";
   ygrid = "off";
   zgrid = "off";
@@ -3466,17 +3466,17 @@ axes::properties::set_defaults (base_gra
   xset (ylabel.handle_value (), "verticalalignmentmode", "auto");
   xset (title.handle_value (), "verticalalignment", "bottom");
   xset (title.handle_value (), "verticalalignmentmode", "auto");
 
   xset (ylabel.handle_value (), "rotation", 90.0);
   xset (ylabel.handle_value (), "rotationmode", "auto");
 
   xset (zlabel.handle_value (), "visible", "off");
-  
+
   xset (xlabel.handle_value (), "clipping", "off");
   xset (ylabel.handle_value (), "clipping", "off");
   xset (zlabel.handle_value (), "clipping", "off");
   xset (title.handle_value (), "clipping", "off");
 
   adopt (xlabel.handle_value ());
   adopt (ylabel.handle_value ());
   adopt (zlabel.handle_value ());
@@ -3682,41 +3682,41 @@ axes::properties::update_camera (void)
 
   Matrix xlimits = sx.scale (get_xlim ().matrix_value ());
   Matrix ylimits = sy.scale (get_ylim ().matrix_value ());
   Matrix zlimits = sz.scale (get_zlim ().matrix_value ());
 
   double xo = xlimits(xd > 0 ? 0 : 1);
   double yo = ylimits(yd > 0 ? 0 : 1);
   double zo = zlimits(zd > 0 ? 0 : 1);
-  
+
   Matrix pb  = get_plotboxaspectratio ().matrix_value ();
-  
+
   bool autocam = (camerapositionmode_is ("auto")
                   && cameratargetmode_is ("auto")
                   && cameraupvectormode_is ("auto")
                   && cameraviewanglemode_is ("auto"));
   bool dowarp = (autocam && dataaspectratiomode_is("auto")
                  && plotboxaspectratiomode_is ("auto"));
 
   ColumnVector c_eye (xform_vector ());
   ColumnVector c_center (xform_vector ());
   ColumnVector c_upv (xform_vector ());
-  
+
   if (cameratargetmode_is ("auto"))
     {
       c_center(0) = (xlimits(0)+xlimits(1))/2;
       c_center(1) = (ylimits(0)+ylimits(1))/2;
       c_center(2) = (zlimits(0)+zlimits(1))/2;
 
       cameratarget = xform2cam (c_center);
     }
   else
     c_center = cam2xform (get_cameratarget ().matrix_value ());
-  
+
   if (camerapositionmode_is ("auto"))
     {
       Matrix tview = get_view ().matrix_value ();
       double az = tview(0), el = tview(1);
       double d = 5*sqrt(pb(0)*pb(0)+pb(1)*pb(1)+pb(2)*pb(2));
 
       if (el == 90 || el == -90)
         c_eye(2) = d*signum(el);
@@ -3757,29 +3757,29 @@ axes::properties::update_camera (void)
   else
     c_upv = cam2xform (get_cameraupvector ().matrix_value ());
 
   Matrix x_view = xform_matrix ();
   Matrix x_projection = xform_matrix ();
   Matrix x_viewport = xform_matrix ();
   Matrix x_normrender = xform_matrix ();
   Matrix x_pre = xform_matrix ();
-  
+
   x_render = xform_matrix ();
   x_render_inv = xform_matrix ();
 
   scale (x_pre, pb(0), pb(1), pb(2));
   translate (x_pre, -0.5, -0.5, -0.5);
   scale (x_pre, xd/(xlimits(1)-xlimits(0)), yd/(ylimits(1)-ylimits(0)),
          zd/(zlimits(1)-zlimits(0)));
   translate (x_pre, -xo, -yo, -zo);
 
   xform (c_eye, x_pre);
   xform (c_center, x_pre);
-  scale (c_upv, pb(0)/(xlimits(1)-xlimits(0)), pb(1)/(ylimits(1)-ylimits(0)), 
+  scale (c_upv, pb(0)/(xlimits(1)-xlimits(0)), pb(1)/(ylimits(1)-ylimits(0)),
          pb(2)/(zlimits(1)-zlimits(0)));
   translate (c_center, -c_eye(0), -c_eye(1), -c_eye(2));
 
   ColumnVector F (c_center), f (F), UP (c_upv);
   normalize (f);
   normalize (UP);
 
   if (std::abs (dot (f, UP)) > 1e-15)
@@ -4360,30 +4360,30 @@ axes::properties::get_axis_limits (doubl
   retval.resize (1, 2);
 
   retval(0) = min_val;
   retval(1) = max_val;
 
   return retval;
 }
 
-void 
+void
 axes::properties::calc_ticks_and_lims (array_property& lims,
                                        array_property& ticks,
                                        bool limmode_is_auto, bool is_logscale)
 {
   // FIXME -- add log ticks and lims
 
   if (lims.get ().is_empty ())
     return;
 
   double lo = (lims.get ().matrix_value ()) (0);
   double hi = (lims.get ().matrix_value ()) (1);
   // FIXME should this be checked for somewhere else? (i.e. set{x,y,z}lim)
-  if (hi < lo) 
+  if (hi < lo)
     {
       double tmp = hi;
       hi = lo;
       lo = tmp;
     }
 
   if (is_logscale)
     {
@@ -4399,34 +4399,34 @@ axes::properties::calc_ticks_and_lims (a
 
   if (limmode_is_auto)
     {
       // adjust limits to include min and max tics
       Matrix tmp_lims (1,2);
       tmp_lims(0) = tick_sep * i1;
       tmp_lims(1) = tick_sep * i2;
 
-      if (is_logscale) 
+      if (is_logscale)
         {
           tmp_lims(0) = std::pow (10.,tmp_lims(0));
           tmp_lims(1) = std::pow (10.,tmp_lims(1));
           if (tmp_lims(0) <= 0)
             tmp_lims(0) = std::pow (10., lo);
         }
       lims = tmp_lims;
     }
   else
     {
       // adjust min and max tics if they are out of limits
       i1 = static_cast<int> (std::ceil (lo / tick_sep));
       i2 = static_cast<int> (gnulib::floor (hi / tick_sep));
     }
-      
+
   Matrix tmp_ticks (1, i2-i1+1);
-  for (int i = 0; i <= i2-i1; i++) 
+  for (int i = 0; i <= i2-i1; i++)
     {
       tmp_ticks (i) = tick_sep * (i+i1);
       if (is_logscale)
         tmp_ticks (i) = std::pow (10., tmp_ticks (i));
     }
 
   ticks = tmp_ticks;
 }
@@ -4479,45 +4479,45 @@ get_children_limits (double& min_val, do
           if (obj.is_yliminclude ())
             {
               octave_value lim = obj.get_ylim ();
 
               check_limit_vals (min_val, max_val, min_pos, lim);
             }
         }
       break;
-    
+
     case 'z':
       for (octave_idx_type i = 0; i < n; i++)
         {
           graphics_object obj = gh_manager::get_object (kids(i));
 
           if (obj.is_zliminclude ())
             {
               octave_value lim = obj.get_zlim ();
 
               check_limit_vals (min_val, max_val, min_pos, lim);
             }
         }
       break;
-    
+
     case 'c':
       for (octave_idx_type i = 0; i < n; i++)
         {
           graphics_object obj = gh_manager::get_object (kids(i));
 
           if (obj.is_climinclude ())
             {
               octave_value lim = obj.get_clim ();
 
               check_limit_vals (min_val, max_val, min_pos, lim);
             }
         }
       break;
-    
+
     case 'a':
       for (octave_idx_type i = 0; i < n; i++)
         {
           graphics_object obj = gh_manager::get_object (kids(i));
 
           if (obj.is_aliminclude ())
             {
               octave_value lim = obj.get_alim ();
@@ -4537,17 +4537,17 @@ static bool updating_axis_limits = false
 void
 axes::update_axis_limits (const std::string& axis_type,
                           const graphics_handle& h)
 {
   if (updating_axis_limits)
     return;
 
   Matrix kids = Matrix (1, 1, h.value ());
- 
+
   double min_val = octave_Inf;
   double max_val = -octave_Inf;
   double min_pos = octave_Inf;
 
   char update_type = 0;
 
   Matrix limits;
   double val;
@@ -4578,17 +4578,17 @@ axes::update_axis_limits (const std::str
       || axis_type == "xlim")
     {
       if (xproperties.xlimmode_is ("auto"))
         {
           limits = xproperties.get_xlim ().matrix_value ();
           FIX_LIMITS ;
 
           get_children_limits (min_val, max_val, min_pos, kids, 'x');
-          
+
           limits = xproperties.get_axis_limits (min_val, max_val, min_pos,
                                                 xproperties.xscale_is ("log"));
 
           update_type = 'x';
         }
     }
   else if (axis_type == "ydata" || axis_type == "yscale"
            || axis_type == "ylimmode" || axis_type == "yliminclude"
@@ -4744,17 +4744,17 @@ axes::update_axis_limits (const std::str
 
   if (axis_type == "xdata" || axis_type == "xscale"
       || axis_type == "xlimmode" || axis_type == "xliminclude"
       || axis_type == "xlim")
     {
       if (xproperties.xlimmode_is ("auto"))
         {
           get_children_limits (min_val, max_val, min_pos, kids, 'x');
-          
+
           limits = xproperties.get_axis_limits (min_val, max_val, min_pos,
                                                 xproperties.xscale_is ("log"));
 
           update_type = 'x';
         }
     }
   else if (axis_type == "ydata" || axis_type == "yscale"
            || axis_type == "ylimmode" || axis_type == "yliminclude"
@@ -4880,93 +4880,93 @@ axes::update_axis_limits (const std::str
 inline
 double force_in_range (const double x, const double lower, const double upper)
 {
   if (x < lower)
     { return lower; }
   else if (x > upper)
     { return upper; }
   else
-    { return x; }  
+    { return x; }
 }
 
 void
 axes::properties::zoom_about_point (double x, double y, double factor,
                                     bool push_to_zoom_stack)
 {
   // FIXME: Do we need error checking here?
   Matrix xlims = get_xlim ().matrix_value ();
   Matrix ylims = get_ylim ().matrix_value ();
-              
+
   // Get children axes limits
   Matrix kids = get_children ();
   double minx = octave_Inf;
   double maxx = -octave_Inf;
   double min_pos_x = octave_Inf;
   get_children_limits (minx, maxx, min_pos_x, kids, 'x');
 
   double miny = octave_Inf;
   double maxy = -octave_Inf;
   double min_pos_y = octave_Inf;
   get_children_limits (miny, maxy, min_pos_y, kids, 'y');
-              
+
   // Perform the zooming
   xlims (0) = x + factor * (xlims (0) - x);
   xlims (1) = x + factor * (xlims (1) - x);
   ylims (0) = y + factor * (ylims (0) - y);
   ylims (1) = y + factor * (ylims (1) - y);
-              
+
   zoom (xlims, ylims, push_to_zoom_stack);
 }
 
 void
 axes::properties::zoom (const Matrix& xl, const Matrix& yl, bool push_to_zoom_stack)
 {
   if (push_to_zoom_stack)
     {
       zoom_stack.push_front (xlimmode.get ());
       zoom_stack.push_front (xlim.get ());
       zoom_stack.push_front (ylimmode.get ());
       zoom_stack.push_front (ylim.get ());
     }
-  
+
   xlim = xl;
   xlimmode = "manual";
   ylim = yl;
   ylimmode = "manual";
 
   update_transform ();
   update_xlim (false);
   update_ylim (false);
 }
 
 void
 axes::properties::translate_view (double delta_x, double delta_y)
 {
   // FIXME: Do we need error checking here?
   Matrix xlims = get_xlim ().matrix_value ();
   Matrix ylims = get_ylim ().matrix_value ();
-              
+
   // Get children axes limits
   Matrix kids = get_children ();
   double minx = octave_Inf;
   double maxx = -octave_Inf;
   double min_pos_x = octave_Inf;
   get_children_limits (minx, maxx, min_pos_x, kids, 'x');
-        
+
   double miny = octave_Inf;
   double maxy = -octave_Inf;
   double min_pos_y = octave_Inf;
   get_children_limits (miny, maxy, min_pos_y, kids, 'y');
-  
+
   xlims (0) += delta_x;
   xlims (1) += delta_x;
   ylims (0) += delta_y;
   ylims (1) += delta_y;
- 
+
   zoom (xlims, ylims, false);
 }
 
 void
 axes::properties::rotate_view (double delta_el, double delta_az)
 {
   Matrix v = get_view ().matrix_value ();
 
@@ -5086,17 +5086,17 @@ text::properties::update_text_extent (vo
   renderer.set_color (get_color_rgb ());
 
   int halign = 0, valign = 0;
 
   if (horizontalalignment_is ("center"))
     halign = 1;
   else if (horizontalalignment_is ("right"))
     halign = 2;
-  
+
   if (verticalalignment_is ("top"))
     valign = 2;
   else if (verticalalignment_is ("baseline"))
     valign = 3;
   else if (verticalalignment_is ("middle"))
     valign = 1;
 
   Matrix bbox;
@@ -5251,32 +5251,32 @@ surface::properties::update_normals (voi
             }
         }
       vertexnormals = n;
     }
 }
 
 // ---------------------------------------------------------------------
 
-void 
+void
 hggroup::properties::update_limits (void) const
 {
   graphics_object obj = gh_manager::get_object (__myhandle__);
 
   if (obj)
     {
       obj.update_axis_limits ("xlim");
       obj.update_axis_limits ("ylim");
       obj.update_axis_limits ("zlim");
       obj.update_axis_limits ("clim");
       obj.update_axis_limits ("alim");
     }
 }
 
-void 
+void
 hggroup::properties::update_limits (const graphics_handle& h) const
 {
   graphics_object obj = gh_manager::get_object (__myhandle__);
 
   if (obj)
     {
       obj.update_axis_limits ("xlim", h);
       obj.update_axis_limits ("ylim", h);
@@ -5291,17 +5291,17 @@ static bool updating_hggroup_limits = fa
 void
 hggroup::update_axis_limits (const std::string& axis_type,
                              const graphics_handle& h)
 {
   if (updating_hggroup_limits)
     return;
 
   Matrix kids = Matrix (1, 1, h.value ());
- 
+
   double min_val = octave_Inf;
   double max_val = -octave_Inf;
   double min_pos = octave_Inf;
 
   Matrix limits;
   double val;
 
   char update_type = 0;
@@ -5407,17 +5407,17 @@ hggroup::update_axis_limits (const std::
   double max_val = -octave_Inf;
   double min_pos = octave_Inf;
 
   char update_type = 0;
 
   if (axis_type == "xlim" || axis_type == "xliminclude")
     {
       get_children_limits (min_val, max_val, min_pos, kids, 'x');
-          
+
       update_type = 'x';
     }
   else if (axis_type == "ylim" || axis_type == "yliminclude")
     {
       get_children_limits (min_val, max_val, min_pos, kids, 'y');
 
       update_type = 'y';
     }
@@ -5515,17 +5515,17 @@ graphics_handle
 gh_manager::do_make_graphics_handle (const std::string& go_name,
                                      const graphics_handle& p, bool do_createfcn)
 {
   graphics_handle h = get_handle (go_name);
 
   base_graphics_object *go = 0;
 
   go = make_graphics_object_from_type (go_name, h, p);
-  
+
   if (go)
     {
       graphics_object obj (go);
 
       handle_map[h] = obj;
       if (do_createfcn)
         go->get_properties ().execute_createfcn ();
 
@@ -5550,17 +5550,17 @@ gh_manager::do_make_figure_handle (doubl
   graphics_object obj (go);
 
   handle_map[h] = obj;
 
   // Notify graphics toolkit.
   graphics_toolkit toolkit = go->get_toolkit ();
   if (toolkit)
     toolkit.initialize (obj);
-  
+
   return h;
 }
 
 void
 gh_manager::do_push_figure (const graphics_handle& h)
 {
   do_pop_figure (h);
 
@@ -5726,17 +5726,17 @@ gh_manager::do_execute_callback (const g
     args(1) = Matrix ();
 
   unwind_protect_safe frame;
   frame.add_fcn (gh_manager::restore_gcbo);
 
   if (true)
     {
       gh_manager::autolock guard;
-  
+
       callback_objects.push_front (get_object (h));
       xset_gcbo (h);
     }
 
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
   // Copy CB because "function_value" method is non-const.
 
@@ -5768,17 +5768,17 @@ gh_manager::do_execute_callback (const g
     {
       std::string nm = cb.class_name ();
       error ("trying to execute non-executable object (class = %s)",
              nm.c_str ());
     }
 
   if (fcn && ! error_state)
     feval (fcn, args);
-  
+
   END_INTERRUPT_WITH_EXCEPTIONS;
 }
 
 void
 gh_manager::do_post_event (const graphics_event& e)
 {
   event_queue.push_back (e);
 
@@ -5853,17 +5853,17 @@ gh_manager::do_process_events (bool forc
 
       gh_manager::lock ();
 
       if (! event_queue.empty ())
         {
           if (callback_objects.empty () || force)
             {
               e = event_queue.front ();
-              
+
               event_queue.pop_front ();
             }
           else
             {
               const graphics_object& go = callback_objects.front ();
 
               if (go.get_properties ().is_interruptible ())
                 {
@@ -5949,17 +5949,17 @@ are not reset.\n\
   else
     {
       // get vector of graphics handles
       ColumnVector hcv (args(0).vector_value ());
 
       if (! error_state)
         {
           // loop over graphics objects
-          for (octave_idx_type n = 0; n < hcv.length (); n++) 
+          for (octave_idx_type n = 0; n < hcv.length (); n++)
             gh_manager::get_object (hcv(n)).reset_default_properties ();
         }
     }
 
   return octave_value ();
 }
 
 DEFUN (set, args, nargout,
@@ -6008,17 +6008,17 @@ the dimensions of @var{pv}.\n\
       // get vector of graphics handles
       ColumnVector hcv (args(0).vector_value ());
 
       if (! error_state)
         {
           bool request_drawnow = false;
 
           // loop over graphics objects
-          for (octave_idx_type n = 0; n < hcv.length (); n++) 
+          for (octave_idx_type n = 0; n < hcv.length (); n++)
             {
               graphics_object obj = gh_manager::get_object (hcv(n));
 
               if (obj)
                 {
                   if (nargin == 3 && args(1).is_cellstr ()
                       && args(2).is_cell ())
                     {
@@ -6517,17 +6517,17 @@ Undocumented internal function.\n\
           // as callbacks might delete one of the handles we
           // later want to delete
           for (octave_idx_type i = 0; i < vals.numel (); i++)
             {
               h = gh_manager::lookup (vals.elem (i));
 
               if (! h.ok ())
                 {
-                  error ("delete: invalid graphics object (= %g)", 
+                  error ("delete: invalid graphics object (= %g)",
                          vals.elem (i));
                   break;
                 }
             }
 
           if (! error_state)
             {
               for (octave_idx_type i = 0; i < vals.numel (); i++)
@@ -6538,27 +6538,27 @@ Undocumented internal function.\n\
                     {
                       graphics_object obj = gh_manager::get_object (h);
 
                       // Don't do recursive deleting, due to callbacks
                       if (! obj.get_properties ().is_beingdeleted ())
                         {
                           graphics_handle parent_h = obj.get_parent ();
 
-                          graphics_object parent_obj = 
+                          graphics_object parent_obj =
                             gh_manager::get_object (parent_h);
 
                           // NOTE: free the handle before removing it from its
-                          //       parent's children, such that the object's 
+                          //       parent's children, such that the object's
                           //       state is correct when the deletefcn callback
                           //       is executed
 
                           gh_manager::free (h);
 
-                          // A callback function might have already deleted 
+                          // A callback function might have already deleted
                           // the parent
                           if (parent_obj.valid_object ())
                             parent_obj.remove_child (h);
 
                           Vdrawnow_requested = true;
                         }
                     }
                 }
@@ -6711,17 +6711,17 @@ Internal function: returns the pixel siz
 
       if (! error_state)
         {
           graphics_object fobj = gh_manager::get_object (h);
           if (fobj &&  fobj.isa ("image"))
             {
               image::properties& ip =
                 dynamic_cast<image::properties&> (fobj.get_properties ());
-              
+
               Matrix dp =  Matrix (1, 2, 0);
               dp(0, 0) = ip.pixel_xsize ();
               dp(0, 1) = ip.pixel_ysize ();
               retval = dp;
             }
           else
             error ("__image_pixel_size__: object is not an image");
         }
diff --git a/src/graphics.h.in b/src/graphics.h.in
--- a/src/graphics.h.in
+++ b/src/graphics.h.in
@@ -172,17 +172,17 @@ public:
       return m;
     }
 
   virtual double scale (double d) const
     {
       error ("invalid axis scale");
       return d;
     }
-  
+
   virtual double unscale (double d) const
     {
       error ("invalid axis scale");
       return d;
     }
 
   virtual base_scaler* clone () const
     { return new base_scaler (); }
@@ -346,17 +346,17 @@ public:
 
   int get_id (void) const { return id; }
 
   void set_id (int d) { id = d; }
 
   // Sets property value, notifies graphics toolkit.
   // If do_run is true, runs associated listeners.
   bool set (const octave_value& v, bool do_run = true);
-  
+
   virtual octave_value get (void) const
     {
       error ("get: invalid property \"%s\"", name.c_str ());
       return octave_value ();
     }
 
 
   virtual std::string values_as_string (void) const
@@ -378,17 +378,17 @@ public:
     }
 
   void add_listener (const octave_value& v, listener_mode mode = POSTSET)
     {
       octave_value_list& l = listeners[mode];
       l.resize (l.length () + 1, v);
     }
 
-  void delete_listener (const octave_value& v = octave_value (), 
+  void delete_listener (const octave_value& v = octave_value (),
                         listener_mode mode = POSTSET)
     {
       octave_value_list& l = listeners[mode];
 
       if (v.is_defined ())
         {
           bool found = false;
           int i;
@@ -491,20 +491,20 @@ private:
 // ---------------------------------------------------------------------
 
 class string_array_property : public base_property
 {
 public:
   enum desired_enum { string_t, cell_t };
 
   string_array_property (const std::string& s, const graphics_handle& h,
-                  const std::string& val = "", const char& sep = '|', 
+                  const std::string& val = "", const char& sep = '|',
                   const desired_enum& typ = string_t)
     : base_property (s, h), desired_type (typ), separator (sep)
-    { 
+    {
       size_t pos = 0;
 
       while (true)
         {
           size_t new_pos = val.find_first_of (separator, pos);
 
           if (new_pos == std::string::npos)
             {
@@ -513,21 +513,21 @@ public:
             }
           else
             str.append (val.substr (pos, new_pos - pos));
 
           pos = new_pos + 1;
         }
     }
 
-  string_array_property (const std::string& s, const graphics_handle& h, 
-                  const Cell& c, const char& sep = '|', 
+  string_array_property (const std::string& s, const graphics_handle& h,
+                  const Cell& c, const char& sep = '|',
                   const desired_enum& typ = string_t)
     : base_property (s, h), desired_type (typ), separator (sep)
-    { 
+    {
       if (c.is_cellstr ())
         {
           string_vector strings (c.numel ());
 
           for (octave_idx_type i = 0; i < c.numel (); i++)
             strings[i] = c(i).string_value ();
 
           str = strings;
@@ -537,25 +537,25 @@ public:
                get_name ().c_str ());
     }
 
   string_array_property (const string_array_property& p)
     : base_property (p), desired_type (p.desired_type),
       separator (p.separator), str (p.str) { }
 
   octave_value get (void) const
-    { 
+    {
       if (desired_type == string_t)
         return octave_value (string_value ());
       else
         return octave_value (cell_value ());
     }
 
-  std::string string_value (void) const 
-    { 
+  std::string string_value (void) const
+    {
       std::string s;
 
       for (octave_idx_type i = 0; i < str.length (); i++)
         {
           s += str[i];
           if (i != str.length () - 1)
             s += separator;
         }
@@ -687,26 +687,26 @@ public:
     if (! contains (val))
       {
         error ("invalid value = %s", val.c_str ());
         retval = false;
       }
 
     return retval;
   }
-  
+
   bool contains (const std::string& val)
   {
     return (possible_vals.find (val) != possible_vals.end ());
   }
 
   std::string values_as_string (void) const;
 
   Cell values_as_cell (void) const;
-  
+
   octave_idx_type nelem (void) const { return possible_vals.size (); }
 
 private:
   // Might also want to cache
   std::string default_val;
   std::set<caseless_str> possible_vals;
 };
 
@@ -733,49 +733,49 @@ public:
 
   octave_value get (void) const { return octave_value (current_val); }
 
   const std::string& current_value (void) const { return current_val; }
 
   std::string values_as_string (void) const { return vals.values_as_string (); }
 
   Cell values_as_cell (void) const { return vals.values_as_cell (); }
-      
+
   bool is (const caseless_str& v) const
     { return v.compare (current_val); }
 
   bool is_radio (void) const { return true; }
 
   radio_property& operator = (const octave_value& val)
     {
       set (val);
       return *this;
     }
 
   base_property* clone (void) const { return new radio_property (*this); }
 
 protected:
-  bool do_set (const octave_value& newval) 
+  bool do_set (const octave_value& newval)
   {
     if (newval.is_string ())
       {
         std::string s = newval.string_value ();
         if (vals.validate (s))
           {
             if (s != current_val)
               {
                 current_val = s;
                 return true;
               }
           }
         else
           error ("set: invalid value for radio property \"%s\" (value = %s)",
               get_name ().c_str (), s.c_str ());
       }
-    else        
+    else
       error ("set: invalid value for radio property \"%s\"",
           get_name ().c_str ());
     return false;
   }
 
 private:
   radio_values vals;
   std::string current_val;
@@ -872,17 +872,17 @@ public:
   { }
 
   color_property (const std::string& nm, const graphics_handle& h,
                   const std::string& v)
     : base_property (nm, h),
       current_type (radio_t), color_val (color_values ()), radio_val (v),
       current_val (radio_val.default_value ())
   { }
-  
+
   color_property (const std::string& nm, const graphics_handle& h,
                   const color_property& v)
     : base_property (nm, h),
       current_type (v.current_type), color_val (v.color_val),
       radio_val (v.radio_val), current_val (v.current_val)
   { }
 
   color_property (const color_property& p)
@@ -929,17 +929,17 @@ public:
 
   operator octave_value (void) const { return get (); }
 
   base_property* clone (void) const { return new color_property (*this); }
 
   std::string values_as_string (void) const { return radio_val.values_as_string (); }
 
   Cell values_as_cell (void) const { return radio_val.values_as_cell (); }
-      
+
 protected:
   OCTINTERP_API bool do_set (const octave_value& newval);
 
 private:
   enum current_enum { color_t, radio_t } current_type;
   color_values color_val;
   radio_values radio_val;
   std::string current_val;
@@ -1110,17 +1110,17 @@ public:
 
   double min_val (void) const { return xmin; }
   double max_val (void) const { return xmax; }
   double min_pos (void) const { return xminp; }
 
   Matrix get_limits (void) const
     {
       Matrix m (1, 3);
-      
+
       m(0) = min_val ();
       m(1) = max_val ();
       m(2) = min_pos ();
 
       return m;
     }
 
   array_property& operator = (const octave_value& val)
@@ -1130,17 +1130,17 @@ public:
     }
 
   base_property* clone (void) const
     {
       array_property *p = new array_property (*this);
 
       p->type_constraints = type_constraints;
       p->size_constraints = size_constraints;
-      
+
       return p;
     }
 
 protected:
   bool do_set (const octave_value& v)
     {
       if (validate (v))
         {
@@ -1152,17 +1152,17 @@ protected:
               get_data_limits ();
 
               return true;
             }
         }
       else
         error ("invalid value for array property \"%s\"",
                get_name ().c_str ());
-      
+
       return false;
     }
 
 private:
   OCTINTERP_API bool validate (const octave_value& v);
 
   OCTINTERP_API bool is_equal (const octave_value& v) const;
 
@@ -1272,17 +1272,17 @@ public:
                  const char* val)
     : radio_property (nm, h, radio_values ("on|off"), val)
     { }
 
   bool_property (const bool_property& p)
     : radio_property (p) { }
 
   bool is_on (void) const { return is ("on"); }
-  
+
   bool_property& operator = (const octave_value& val)
     {
       set (val);
       return *this;
     }
 
   base_property* clone (void) const { return new bool_property (*this); }
 
@@ -1366,79 +1366,79 @@ protected:
 private:
   octave_value data;
 };
 
 // ---------------------------------------------------------------------
 
 class children_property : public base_property
 {
-public: 
+public:
   children_property (void)
     : base_property ("", graphics_handle ())
     {
       do_init_children (Matrix ());
     }
-  
+
   children_property (const std::string& nm, const graphics_handle& h,
                      const Matrix &val)
     : base_property (nm, h)
     {
       do_init_children (val);
     }
 
   children_property (const children_property& p)
-    : base_property (p) 
+    : base_property (p)
     {
       do_init_children (p.children_list);
     }
 
   children_property& operator = (const octave_value& val)
     {
       set (val);
       return *this;
     }
 
   base_property* clone (void) const { return new children_property (*this); }
 
   bool remove_child (const double &val)
     {
       return do_remove_child (val);
     }
-  
+
   void adopt (const double &val)
     {
       do_adopt_child (val);
     }
-  
+
   Matrix get_children (void) const
     {
       return do_get_children (false);
     }
-  
+
   Matrix get_hidden (void) const
     {
       return do_get_children (true);
     }
 
   Matrix get_all (void) const
    {
      return do_get_all_children ();
    }
-  
+
   octave_value get (void) const
     {
       return octave_value (get_children ());
     }
-  
+
   void delete_children (bool clear = false)
     {
       do_delete_children (clear);
     }
-  
+
 private:
   typedef std::list<double>::iterator children_list_iterator;
   typedef std::list<double>::const_iterator const_children_list_iterator;
   std::list<double> children_list;
 
 protected:
   bool do_set (const octave_value& val)
     {
@@ -1507,17 +1507,17 @@ private:
     }
 
   Matrix do_get_children (bool return_hidden) const;
 
   Matrix do_get_all_children (void) const
     {
       Matrix retval (children_list.size (), 1);
       octave_idx_type i  = 0;
-      
+
       for (const_children_list_iterator p = children_list.begin ();
            p != children_list.end (); p++)
         retval(i++) = *p;
       return retval;
     }
 
   bool do_remove_child (double child)
     {
@@ -1532,17 +1532,17 @@ private:
         }
       return false;
     }
 
   void do_adopt_child (const double &val)
     {
       children_list.push_front (val);
     }
-  
+
   void do_delete_children (bool clear);
 };
 
 
 
 // ---------------------------------------------------------------------
 
 class callback_property : public base_property
@@ -1555,17 +1555,17 @@ public:
   callback_property (const callback_property& p)
     : base_property (p), callback (p.callback) { }
 
   octave_value get (void) const { return callback; }
 
   OCTINTERP_API void execute (const octave_value& data = octave_value ()) const;
 
   bool is_defined (void) const
-    { 
+    {
       return (callback.is_defined () && ! callback.is_empty ());
     }
 
   callback_property& operator = (const octave_value& val)
     {
       set (val);
       return *this;
     }
@@ -1663,27 +1663,27 @@ public:
       *rep = val;
       return *this;
     }
 
   property& operator = (const property& p)
     {
       if (rep && --rep->count <= 0)
         delete rep;
-      
+
       rep = p.rep;
       rep->count++;
 
       return *this;
     }
 
   void add_listener (const octave_value& v, listener_mode mode = POSTSET)
     { rep->add_listener (v, mode); }
 
-  void delete_listener (const octave_value& v = octave_value (), 
+  void delete_listener (const octave_value& v = octave_value (),
                         listener_mode mode = POSTSET)
   { rep->delete_listener (v, mode); }
 
   void run_listeners (listener_mode mode = POSTSET)
     { rep->run_listeners (mode); }
 
   OCTINTERP_API static
       property create (const std::string& name, const graphics_handle& parent,
@@ -1703,33 +1703,33 @@ public:
   const color_property& as_color_property (void) const
     { return *(dynamic_cast<color_property*> (rep)); }
 
   const double_property& as_double_property (void) const
     { return *(dynamic_cast<double_property*> (rep)); }
 
   const bool_property& as_bool_property (void) const
     { return *(dynamic_cast<bool_property*> (rep)); }
-  
+
   const handle_property& as_handle_property (void) const
     { return *(dynamic_cast<handle_property*> (rep)); }
     */
 
 private:
   base_property *rep;
 };
 
 // ---------------------------------------------------------------------
 
 class property_list
 {
 public:
   typedef std::map<std::string, octave_value> pval_map_type;
   typedef std::map<std::string, pval_map_type> plist_map_type;
-  
+
   typedef pval_map_type::iterator pval_map_iterator;
   typedef pval_map_type::const_iterator pval_map_const_iterator;
 
   typedef plist_map_type::iterator plist_map_iterator;
   typedef plist_map_type::const_iterator plist_map_const_iterator;
 
   property_list (const plist_map_type& m = plist_map_type ())
     : plist_map (m) { }
@@ -1796,31 +1796,31 @@ public:
       return Matrix (1, 2, 0.0);
     }
 
   virtual double get_screen_resolution (void) const
     {
       gripe_invalid ("get_screen_resolution");
       return 72.0;
     }
-  
+
   virtual Matrix get_screen_size (void) const
     {
       gripe_invalid ("get_screen_size");
       return Matrix (1, 2, 0.0);
     }
 
   // Callback function executed when the given graphics object
   // changes.  This allows the graphics toolkit to act on property
   // changes if needed.
   virtual void update (const graphics_object&, int)
     { gripe_invalid ("base_graphics_toolkit::update"); }
 
   void update (const graphics_handle&, int);
-  
+
   // Callback function executed when the given graphics object is
   // created.  This allows the graphics toolkit to do toolkit-specific
   // initializations for a newly created object.
   virtual void initialize (const graphics_object&)
     { gripe_invalid ("base_graphics_toolkit::initialize"); }
 
   void initialize (const graphics_handle&);
 
@@ -1886,17 +1886,17 @@ public:
     }
 
   operator bool (void) const { return rep->is_valid (); }
 
   std::string get_name (void) const { return rep->get_name (); }
 
   void redraw_figure (const graphics_object& go) const
     { rep->redraw_figure (go); }
-  
+
   void print_figure (const graphics_object& go, const std::string& term,
                      const std::string& file, bool mono,
                      const std::string& debug_file = "") const
     { rep->print_figure (go, term, file, mono, debug_file); }
 
   Matrix get_canvas_size (const graphics_handle& fh) const
     { return rep->get_canvas_size (fh); }
 
@@ -1904,36 +1904,36 @@ public:
     { return rep->get_screen_resolution (); }
 
   Matrix get_screen_size (void) const
     { return rep->get_screen_size (); }
 
   // Notifies graphics toolkit that object't property has changed.
   void update (const graphics_object& go, int id)
     { rep->update (go, id); }
-  
+
   void update (const graphics_handle& h, int id)
     { rep->update (h, id); }
 
   // Notifies graphics toolkit that new object was created.
   void initialize (const graphics_object& go)
     { rep->initialize (go); }
-  
+
   void initialize (const graphics_handle& h)
     { rep->initialize (h); }
-  
+
   // Notifies graphics toolkit that object was destroyed.
   // This is called only for explicitly deleted object. Children are
   // deleted implicitly and graphics toolkit isn't notified.
   void finalize (const graphics_object& go)
     { rep->finalize (go); }
-  
+
   void finalize (const graphics_handle& h)
     { rep->finalize (h); }
-  
+
   OCTINTERP_API static graphics_toolkit default_toolkit (void);
 
   static void register_toolkit (const graphics_toolkit& b)
     { available_toolkits[b.get_name ()] = b; }
 
   static void unregister_toolkit (const std::string& name)
     { available_toolkits.erase (name); }
 
@@ -1947,17 +1947,17 @@ public:
       return default_toolkit ();
   }
 
   static Cell available_toolkits_list (void)
   {
     Cell m (1 , available_toolkits.size ());
     const_available_toolkits_iterator p;
     int i;
-    
+
     for (i = 0, p = available_toolkits.begin ();
          p !=  available_toolkits.end (); p++, i++)
       m(i) = p->first;
 
     return m;
   }
 
 private:
@@ -2024,17 +2024,17 @@ public:
 
   virtual bool has_property (const caseless_str&) const
   {
     panic_impossible ();
     return false;
   }
 
   bool is_modified (void) const { return is___modified__ (); }
- 
+
   virtual void remove_child (const graphics_handle& h)
     {
       if (children.remove_child (h.value ()))
         mark_modified ();
     }
 
   virtual void adopt (const graphics_handle& h)
   {
@@ -2058,19 +2058,19 @@ public:
   void set_tag (const octave_value& val) { tag = val; }
 
   void set_parent (const octave_value& val);
 
   Matrix get_children (void) const
     {
       return children.get_children ();
     }
-  
-  Matrix get_all_children (void) const 
-    { 
+
+  Matrix get_all_children (void) const
+    {
       return children.get_all ();
     }
 
   Matrix get_hidden_children (void) const
     {
       return children.get_hidden ();
     }
 
@@ -2087,17 +2087,17 @@ public:
 
   virtual void update_axis_limits (const std::string& axis_type,
                                    const graphics_handle& h) const;
 
   virtual void delete_children (bool clear = false)
     {
       children.delete_children (clear);
     }
-  
+
   static property_list::pval_map_type factory_defaults (void);
 
   // FIXME -- these functions should be generated automatically by the
   // genprops.awk script.
   //
   // EMIT_BASE_PROPERTIES_GET_FUNCTIONS
 
   virtual octave_value get_xlim (void) const { return octave_value (); }
@@ -2118,17 +2118,17 @@ public:
   }
 
   std::set<std::string> dynamic_property_names (void) const;
 
   bool has_dynamic_property (const std::string& pname);
 
 protected:
   std::set<std::string> dynamic_properties;
- 
+
   void set_dynamic (const caseless_str& pname, const octave_value& val);
 
   octave_value get_dynamic (const caseless_str& pname) const;
 
   octave_value get_dynamic (bool all = false) const;
 
   property get_property_dynamic (const caseless_str& pname);
 
@@ -2154,17 +2154,17 @@ protected:
     // additional (octave-specific) properties
     bool_property __modified__ s , "on"
     graphics_handle __myhandle__ fhrs , mh
     // FIXME -- should this really be here?
     handle_property uicontextmenu , graphics_handle ()
   END_PROPERTIES
 
 protected:
-  struct cmp_caseless_str 
+  struct cmp_caseless_str
     {
       bool operator () (const caseless_str &a, const caseless_str &b) const
         {
           std::string a1 = a;
           std::transform (a1.begin (), a1.end (), a1.begin (), tolower);
           std::string b1 = b;
           std::transform (b1.begin (), b1.end (), b1.begin (), tolower);
 
@@ -2172,17 +2172,17 @@ protected:
         }
     };
 
   std::map<caseless_str, property, cmp_caseless_str> all_props;
 
 protected:
   void insert_static_property (const std::string& name, base_property& p)
     { insert_property (name, property (&p, true)); }
-  
+
   virtual void init (void) { }
 };
 
 class OCTINTERP_API base_graphics_object
 {
 public:
   friend class graphics_object;
 
@@ -2551,44 +2551,44 @@ public:
   //
   // EMIT_GRAPHICS_OBJECT_GET_FUNCTIONS
 
   octave_value get_xlim (void) const
   { return get_properties ().get_xlim (); }
 
   octave_value get_ylim (void) const
   { return get_properties ().get_ylim (); }
-  
+
   octave_value get_zlim (void) const
   { return get_properties ().get_zlim (); }
-  
+
   octave_value get_clim (void) const
   { return get_properties ().get_clim (); }
-  
+
   octave_value get_alim (void) const
   { return get_properties ().get_alim (); }
 
   bool is_xliminclude (void) const
   { return get_properties ().is_xliminclude (); }
-  
+
   bool is_yliminclude (void) const
   { return get_properties ().is_yliminclude (); }
-  
+
   bool is_zliminclude (void) const
   { return get_properties ().is_zliminclude (); }
-  
+
   bool is_climinclude (void) const
   { return get_properties ().is_climinclude (); }
-  
+
   bool is_aliminclude (void) const
   { return get_properties ().is_aliminclude (); }
 
   bool is_handle_visible (void) const
   { return get_properties ().is_handle_visible (); }
-  
+
   graphics_toolkit get_toolkit (void) const { return rep->get_toolkit (); }
 
   void add_property_listener (const std::string& nm, const octave_value& v,
                               listener_mode mode = POSTSET)
     { rep->add_property_listener (nm, v, mode); }
 
   void delete_property_listener (const std::string& nm, const octave_value& v,
                                  listener_mode mode = POSTSET)
@@ -2605,17 +2605,17 @@ private:
 
 class OCTINTERP_API root_figure : public base_graphics_object
 {
 public:
   class OCTINTERP_API properties : public base_properties
   {
   public:
     void remove_child (const graphics_handle& h);
-    
+
     // See the genprops.awk script for an explanation of the
     // properties declarations.
 
     // FIXME -- it seems strange to me that the diary, diaryfile,
     // echo, format, formatspacing, language, and recursionlimit
     // properties are here.  WTF do they have to do with graphics?
     // Also note that these properties (and the monitorpositions,
     // pointerlocation, and pointerwindow properties) are not yet used
@@ -2761,21 +2761,21 @@ public:
     graphics_toolkit get_toolkit (void) const
       {
         if (! toolkit)
           toolkit = graphics_toolkit::default_toolkit ();
 
         return toolkit;
       }
 
-    void set_toolkit (const graphics_toolkit& b) 
-    { 
+    void set_toolkit (const graphics_toolkit& b)
+    {
       if (toolkit)
         toolkit.finalize (__myhandle__);
-      toolkit = b; 
+      toolkit = b;
       __graphics_toolkit__ = b.get_name ();
       __plot_stream__ = Matrix ();
       mark_modified ();
     }
 
     void set___graphics_toolkit__ (const octave_value& val)
     {
       if (! error_state)
@@ -2860,17 +2860,17 @@ public:
       string_property wvisual , ""
       radio_property wvisualmode , "{auto}|manual"
       string_property xdisplay , ""
       string_property xvisual , ""
       radio_property xvisualmode , "{auto}|manual"
       callback_property buttondownfcn , Matrix ()
       string_property __graphics_toolkit__ s , "gnuplot"
     END_PROPERTIES
-    
+
   protected:
     void init (void)
       {
         colormap.add_constraint (dim_vector (-1, 3));
         alphamap.add_constraint (dim_vector (-1, 1));
         paperposition.add_constraint (dim_vector (1, 4));
         pointershapecdata.add_constraint (dim_vector (16, 16));
         pointershapehotspot.add_constraint (dim_vector (1, 2));
@@ -2888,17 +2888,17 @@ public:
   figure (const graphics_handle& mh, const graphics_handle& p)
     : base_graphics_object (), xproperties (mh, p), default_properties ()
   {
     xproperties.override_defaults (*this);
   }
 
   ~figure (void)
   {
-    xproperties.delete_children (); 
+    xproperties.delete_children ();
   }
 
   void override_defaults (base_graphics_object& obj)
   {
     // Allow parent (root figure) to override first (properties knows how
     // to find the parent object).
     xproperties.override_defaults (obj);
 
@@ -2988,20 +2988,20 @@ public:
     }
 
   static ColumnVector xform_vector (double x, double y, double z);
 
   static Matrix xform_eye (void);
 
   ColumnVector transform (double x, double y, double z,
                           bool use_scale = true) const;
-  
+
   ColumnVector untransform (double x, double y, double z,
                             bool use_scale = true) const;
-  
+
   ColumnVector untransform (double x, double y, bool use_scale = true) const
     { return untransform (x, y, (zlim(0)+zlim(1))/2, use_scale); }
 
   Matrix xscale (const Matrix& m) const { return sx.scale (m); }
   Matrix yscale (const Matrix& m) const { return sy.scale (m); }
   Matrix zscale (const Matrix& m) const { return sz.scale (m); }
 
   Matrix scale (const Matrix& m) const
@@ -3288,37 +3288,37 @@ public:
     void update_outerposition (void) { sync_positions ();}
     void update_position (void) { sync_positions (); }
 
     double calc_tick_sep (double minval, double maxval);
     void calc_ticks_and_lims (array_property& lims, array_property& ticks, bool limmode_is_auto, bool is_logscale);
     void calc_ticklabels (const array_property& ticks, any_property& labels, bool is_logscale);
     void fix_limits (array_property& lims)
     {
-      if (lims.get ().is_empty ()) 
+      if (lims.get ().is_empty ())
         return;
 
       Matrix l = lims.get ().matrix_value ();
       if (l(0) > l(1))
         {
           l(0) = 0;
           l(1) = 1;
           lims = l;
         }
       else if (l(0) == l(1))
         {
           l(0) -= 0.5;
           l(1) += 0.5;
           lims = l;
         }
-    }      
+    }
 
   public:
     Matrix get_axis_limits (double xmin, double xmax, double min_pos, bool logscale);
-    
+
     void update_xlim (bool do_clr_zoom = true)
     {
       if (xtickmode.is ("auto"))
         calc_ticks_and_lims (xlim, xtick, xlimmode.is ("auto"), xscale.is ("log"));
       if (xticklabelmode.is ("auto"))
         calc_ticklabels (xtick, xticklabel, xscale.is ("log"));
 
       fix_limits (xlim);
@@ -3346,17 +3346,17 @@ public:
         calc_ticks_and_lims (zlim, ztick, zlimmode.is ("auto"), zscale.is ("log"));
       if (zticklabelmode.is ("auto"))
         calc_ticklabels (ztick, zticklabel, zscale.is ("log"));
 
       fix_limits (zlim);
 
       zoom_stack.clear ();
     }
-    
+
   };
 
 private:
   properties xproperties;
 
 public:
   axes (const graphics_handle& mh, const graphics_handle& p)
     : base_graphics_object (), xproperties (mh, p), default_properties ()
@@ -3474,17 +3474,17 @@ public:
       bool_property zliminclude hl , "off"
     END_PROPERTIES
 
   private:
     Matrix compute_xlim (void) const;
     Matrix compute_ylim (void) const;
 
     void update_xdata (void) { set_xlim (compute_xlim ()); }
-    
+
     void update_ydata (void) { set_ylim (compute_ylim ()); }
 
     void update_zdata (void)
       {
         set_zlim (zdata.get_limits ());
         set_zliminclude (get_zdata ().numel () > 0);
       }
   };
@@ -3679,33 +3679,33 @@ public:
         cdata.add_constraint ("uint16");
         cdata.add_constraint ("int16");
         cdata.add_constraint (dim_vector (-1, -1));
         cdata.add_constraint (dim_vector (-1, -1, 3));
       }
 
   private:
     void update_xdata (void)
-    { 
+    {
       Matrix limits = xdata.get_limits ();
       float dp = pixel_xsize ();
 
       limits(0) = limits(0) - dp;
       limits(1) = limits(1) + dp;
-      set_xlim (limits); 
+      set_xlim (limits);
     }
 
     void update_ydata (void)
     {
       Matrix limits = ydata.get_limits ();
       float dp = pixel_ysize ();
 
       limits(0) = limits(0) - dp;
       limits(1) = limits(1) + dp;
-      set_ylim (limits); 
+      set_ylim (limits);
     }
 
     void update_cdata (void)
       {
         if (cdatamapping_is ("scaled"))
           set_clim (cdata.get_limits ());
         else
           clim = cdata.get_limits ();
@@ -3763,17 +3763,17 @@ public:
 
 class OCTINTERP_API patch : public base_graphics_object
 {
 public:
   class OCTINTERP_API properties : public base_properties
   {
   public:
     octave_value get_color_data (void) const;
-    
+
     bool is_climinclude (void) const
       { return (climinclude.is_on () && cdatamapping.is ("scaled")); }
     std::string get_climinclude (void) const
       { return climinclude.current_value (); }
 
     bool is_aliminclude (void) const
       { return (aliminclude.is_on () && alphadatamapping.is ("scaled")); }
     std::string get_aliminclude (void) const
@@ -3843,17 +3843,17 @@ public:
         facevertexcdata.add_constraint (dim_vector (-1, 3));
         facevertexalphadata.add_constraint (dim_vector (-1, 1));
       }
 
   private:
     void update_xdata (void) { set_xlim (xdata.get_limits ()); }
     void update_ydata (void) { set_ylim (ydata.get_limits ()); }
     void update_zdata (void) { set_zlim (zdata.get_limits ()); }
-    
+
     void update_cdata (void)
       {
         if (cdatamapping_is ("scaled"))
           set_clim (cdata.get_limits ());
         else
           clim = cdata.get_limits ();
       }
   };
@@ -3970,17 +3970,17 @@ public:
   private:
     void update_normals (void);
 
     void update_xdata (void)
       {
         update_normals ();
         set_xlim (xdata.get_limits ());
       }
- 
+
     void update_ydata (void)
       {
         update_normals ();
         set_ylim (ydata.get_limits ());
       }
 
     void update_zdata (void)
       {
@@ -4154,17 +4154,17 @@ public:
 
   ~uimenu (void) { xproperties.delete_children (); }
 
   base_properties& get_properties (void) { return xproperties; }
 
   const base_properties& get_properties (void) const { return xproperties; }
 
   bool valid_object (void) const { return true; }
-  
+
 };
 
 // ---------------------------------------------------------------------
 
 octave_value
 get_property_from_handle (double handle, const std::string &property,
                           const std::string &func);
 bool
@@ -4521,17 +4521,17 @@ private:
   void do_pop_figure (const graphics_handle& h);
 
   graphics_handle do_current_figure (void) const
   {
     return figure_list.empty () ? graphics_handle () : figure_list.front ();
   }
 
   void do_lock (void) { graphics_lock.lock (); }
-  
+
   void do_unlock (void) { graphics_lock.unlock (); }
 
   void do_execute_callback (const graphics_handle& h, const octave_value& cb,
                             const octave_value& data);
 
   void do_post_callback (const graphics_handle& h, const std::string name,
                          const octave_value& data);
 
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -290,24 +290,24 @@ Mark the end of any @code{for}, @code{if
 @seealso{for, if, do, while, function}\n\
 @end deftypefn"),
 
   pair_type ("end_try_catch",
     "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} end_try_catch\n\
 Mark the end of an @code{try-catch} block.\n\
 @seealso{try, catch}\n\
-@end deftypefn"), 
+@end deftypefn"),
 
   pair_type ("end_unwind_protect",
     "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} end_unwind_protect\n\
 Mark the end of an unwind_protect block.\n\
 @seealso{unwind_protect}\n\
-@end deftypefn"), 
+@end deftypefn"),
 
   pair_type ("endfor",
     "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} endfor\n\
 Mark the end of a for loop.  See @code{for} for an example.\n\
 @seealso{for}\n\
 @end deftypefn"),
 
@@ -469,17 +469,17 @@ endswitch\n\
 @deftypefn {Keyword} {} try\n\
 Begin a try-catch block.\n\
 \n\
 If an error occurs within a try block, then the catch code will be run and\n\
 execution will proceed after the catch block (though it is often\n\
 recommended to use the lasterr function to re-throw the error after cleanup\n\
 is completed).\n\
 @seealso{catch,unwind_protect}\n\
-@end deftypefn"), 
+@end deftypefn"),
 
   pair_type ("until",
     "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} until\n\
 End a do-until loop.\n\
 @seealso{do}\n\
 @end deftypefn"),
 
@@ -490,24 +490,24 @@ Begin an unwind_protect block.\n\
 \n\
 If an error occurs within the first part of an unwind_protect block\n\
 the commands within the unwind_protect_cleanup block are executed before\n\
 the error is thrown.  If an error is not thrown, then the\n\
 unwind_protect_cleanup block is still executed (in other words, the\n\
 unwind_protect_cleanup will be run with or without an error in the\n\
 unwind_protect block).\n\
 @seealso{unwind_protect_cleanup,try}\n\
-@end deftypefn"), 
+@end deftypefn"),
 
   pair_type ("unwind_protect_cleanup",
     "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} unwind_protect_cleanup\n\
 Begin the cleanup section of an unwind_protect block.\n\
 @seealso{unwind_protect}\n\
-@end deftypefn"), 
+@end deftypefn"),
 
   pair_type ("varargin",
     "-*- texinfo -*-\n\
 @deftypefn {Keyword} {} varargin\n\
 Pass an arbitrary number of arguments into a function.\n\
 @seealso{varargout, nargin, nargout}\n\
 @end deftypefn"),
 
@@ -587,17 +587,17 @@ make_name_list (void)
 }
 
 static bool
 looks_like_html (const std::string& msg)
 {
   const size_t p1 = msg.find ('\n');
   std::string t = msg.substr (0, p1);
   const size_t p2 = t.find ("<html"); // FIXME: this comparison should be case-insensitive
-  
+
    return (p2 != std::string::npos);
 }
 
 static bool
 looks_like_texinfo (const std::string& msg, size_t& p1)
 {
   p1 = msg.find ('\n');
 
@@ -607,17 +607,17 @@ looks_like_texinfo (const std::string& m
     p1 = 0;
 
   size_t p2 = t.find ("-*- texinfo -*-");
 
   return (p2 != std::string::npos);
 }
 
 static bool
-raw_help_from_symbol_table (const std::string& nm, std::string& h, 
+raw_help_from_symbol_table (const std::string& nm, std::string& h,
                             std::string& w, bool& symbol_found)
 {
   bool retval = false;
 
   octave_value val = symbol_table::find_function (nm);
 
   if (val.is_defined ())
     {
@@ -638,17 +638,17 @@ raw_help_from_symbol_table (const std::s
               ? "command-line function" : "built-in function";
         }
     }
 
   return retval;
 }
 
 static bool
-raw_help_from_file (const std::string& nm, std::string& h, 
+raw_help_from_file (const std::string& nm, std::string& h,
                     std::string& file, bool& symbol_found)
 {
   bool retval = false;
 
   // FIXME -- this is a bit of a kluge...
   unwind_protect frame;
   frame.protect_var (reading_script_file);
   reading_script_file = true;
@@ -657,17 +657,17 @@ raw_help_from_file (const std::string& n
 
   if (h.length () > 0)
     retval = true;
 
   return retval;
 }
 
 static bool
-raw_help_from_map (const std::string& nm, std::string& h, 
+raw_help_from_map (const std::string& nm, std::string& h,
                    const map_type& map, bool& symbol_found)
 {
   map_iter idx = map.find (nm);
   symbol_found = (idx != map.end ());
   h = (symbol_found) ? idx->second : "";
   return symbol_found;
 }
 
@@ -687,17 +687,17 @@ raw_help (const std::string& nm, bool& s
 }
 
 static void
 do_get_help_text (const std::string& name, std::string& text,
                   std::string& format)
 {
   bool symbol_found = false;
   text = raw_help (name, symbol_found);
-  
+
   format = "Not found";
   if (symbol_found)
     {
       size_t idx = -1;
       if (text.empty ())
         {
           format = "Not documented";
         }
@@ -738,17 +738,17 @@ To convert the help text to other format
       const std::string name = args (0).string_value ();
 
       if (! error_state)
         {
           std::string text;
           std::string format;
 
           do_get_help_text (name, text, format);
-  
+
           retval(1) = format;
           retval(0) = text;
         }
       else
         error ("get_help_text: invalid input");
     }
   else
     print_usage ();
@@ -812,17 +812,17 @@ To convert the help text to other format
       const std::string fname = args(0).string_value ();
 
       if (! error_state)
         {
           std::string text;
           std::string format;
 
           do_get_help_text_from_file (fname, text, format);
-  
+
           retval(1) = format;
           retval(0) = text;
         }
       else
         error ("get_help_text_from_file: invalid input");
     }
   else
     print_usage ();
@@ -985,22 +985,22 @@ Undocumented internal function.\n\
 inline bool
 file_is_in_dir (const std::string filename, const std::string dir)
 {
   if (filename.find (dir) == 0)
     {
       const int dir_len = dir.size ();
       const int filename_len = filename.size ();
       const int max_allowed_seps = file_ops::is_dir_sep (dir [dir_len-1]) ? 0 : 1;
-      
+
       int num_seps = 0;
       for (int i = dir_len; i < filename_len; i++)
         if (file_ops::is_dir_sep (filename [i]))
           num_seps ++;
-      
+
       return (num_seps <= max_allowed_seps);
     }
   else
     return false;
 }
 
 // Return a cell array of strings containing the names of all
 // functions available in DIRECTORY.  If no directory is given, search
@@ -1013,17 +1013,17 @@ DEFUN (__list_functions__, args, ,
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   // Get list of functions
   string_vector ffl = load_path::fcn_names ();
   string_vector afl = autoloaded_functions ();
-  
+
   if (args.length () == 0)
     retval = Cell (ffl.append (afl));
   else
     {
       std::string dir = args (0).string_value ();
 
       if (! error_state)
         {
@@ -1036,17 +1036,17 @@ Undocumented internal function.\n\
               // directory, for example).
               fl.sort (true);
 
               retval = Cell (fl);
             }
         }
       else
         error ("__list_functions__: input must be a string");
-    }  
+    }
 
   return retval;
 }
 
 DEFUN (doc_cache_file, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} doc_cache_file ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} doc_cache_file (@var{new_val})\n\
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -961,17 +961,17 @@ do_keyboard (const octave_value_list& ar
   // Vsaving_history variable...
   command_history::ignore_entries (false);
 
   frame.add_fcn (command_history::ignore_entries, ! Vsaving_history);
 
   frame.protect_var (Vsaving_history);
   frame.protect_var (Vdebugging);
 
-  frame.add_fcn (octave_call_stack::restore_frame, 
+  frame.add_fcn (octave_call_stack::restore_frame,
                  octave_call_stack::current_frame ());
 
   // FIXME -- probably we just want to print one line, not the
   // entire statement, which might span many lines...
   //
   // tree_print_code tpc (octave_stdout);
   // stmt.accept (tpc);
 
@@ -1008,17 +1008,17 @@ If @code{keyboard} is invoked without ar
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 0 || nargin == 1)
     {
       unwind_protect frame;
 
-      frame.add_fcn (octave_call_stack::restore_frame, 
+      frame.add_fcn (octave_call_stack::restore_frame,
                      octave_call_stack::current_frame ());
 
       // Skip the frame assigned to the keyboard function.
       octave_call_stack::goto_frame_relative (0);
 
       tree_evaluator::debug_mode = true;
 
       tree_evaluator::current_frame = octave_call_stack::current_frame ();
diff --git a/src/lex.h b/src/lex.h
--- a/src/lex.h
+++ b/src/lex.h
@@ -59,20 +59,20 @@ public:
   lexical_feedback (void)
 
     : bracketflag (0), braceflag (0), looping (0),
       convert_spaces_to_comma (true), at_beginning_of_statement (true),
       defining_func (0), looking_at_function_handle (false),
       looking_at_return_list (false), looking_at_parameter_list (false),
       looking_at_decl_list (false), looking_at_initializer_expression (false),
       looking_at_matrix_or_assign_lhs (false), looking_at_object_index (),
-      looking_for_object_index (false), do_comma_insert (false), 
-      looking_at_indirect_ref (false), parsed_function_name (), 
-      parsing_class_method (false), maybe_classdef_get_set_method (false), 
-      parsing_classdef (false), quote_is_transpose (false), 
+      looking_for_object_index (false), do_comma_insert (false),
+      looking_at_indirect_ref (false), parsed_function_name (),
+      parsing_class_method (false), maybe_classdef_get_set_method (false),
+      parsing_classdef (false), quote_is_transpose (false),
       pending_local_variables ()
 
     {
       init ();
     }
 
   ~lexical_feedback (void) { }
 
diff --git a/src/lex.ll b/src/lex.ll
--- a/src/lex.ll
+++ b/src/lex.ll
@@ -720,50 +720,50 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 
     int id_tok = handle_identifier ();
 
     if (id_tok >= 0)
       COUNT_TOK_AND_RETURN (id_tok);
   }
 
 %{
-// Superclass method identifiers. 
+// Superclass method identifiers.
 %}
 
 {IDENT}@{IDENT}{S}* |
 {IDENT}@{IDENT}.{IDENT}{S}* {
     LEXER_DEBUG ("{IDENT}@{IDENT}{S}*|{IDENT}@{IDENT}.{IDENT}{S}*");
 
     int id_tok = handle_superclass_identifier ();
 
     if (id_tok >= 0)
       {
         lexer_flags.looking_for_object_index = true;
 
         COUNT_TOK_AND_RETURN (SUPERCLASSREF);
       }
   }
-  
+
 %{
 // Metaclass query
-%}  
-  
-\?{IDENT}{S}* | 
+%}
+
+\?{IDENT}{S}* |
 \?{IDENT}.{IDENT}{S}* {
     LEXER_DEBUG ("\?{IDENT}{S}* | \?{IDENT}.{IDENT}{S}*");
-    
+
     int id_tok = handle_meta_identifier ();
 
     if (id_tok >= 0)
       {
         lexer_flags.looking_for_object_index = true;
 
         COUNT_TOK_AND_RETURN (METAQUERY);
       }
-  }  
+  }
 
 %{
 // Function handles and superclass references
 %}
 
 "@" {
     LEXER_DEBUG ("@");
 
@@ -771,17 +771,17 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 
     lexer_flags.quote_is_transpose = false;
     lexer_flags.convert_spaces_to_comma = false;
     lexer_flags.looking_at_function_handle++;
     lexer_flags.looking_for_object_index = false;
     lexer_flags.at_beginning_of_statement = false;
 
     COUNT_TOK_AND_RETURN ('@');
-      
+
   }
 
 %{
 // A new line character.  New line characters inside matrix constants
 // are handled by the <MATRIX_START> start state code above.  If closest
 // nesting is inside parentheses, don't return a row separator.
 %}
 
@@ -805,17 +805,17 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
         gripe_matlab_incompatible ("bare newline inside parentheses");
       }
     else if (nesting_level.is_bracket_or_brace ())
       return LEXICAL_ERROR;
   }
 
 %{
 // Single quote can either be the beginning of a string or a transpose
-// operator. 
+// operator.
 %}
 
 "'" {
     LEXER_DEBUG ("'");
 
     current_input_column++;
     lexer_flags.convert_spaces_to_comma = true;
 
@@ -841,17 +841,17 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
     current_input_column++;
     int tok = handle_string ('"');
 
     COUNT_TOK_AND_RETURN (tok);
 }
 
 %{
 // Gobble comments.
-%} 
+%}
 
 {CCHAR} {
     LEXER_DEBUG ("{CCHAR}");
 
     lexer_flags.looking_for_object_index = false;
 
     xunput (yytext[0], yytext);
 
@@ -1505,32 +1505,32 @@ is_keyword_token (const std::string& s)
           yylval.tok_val = new token (token::switch_end, l, c);
           lexer_flags.at_beginning_of_statement = true;
           break;
 
         case endwhile_kw:
           yylval.tok_val = new token (token::while_end, l, c);
           lexer_flags.at_beginning_of_statement = true;
           break;
-          
+
         case endclassdef_kw:
           yylval.tok_val = new token (token::classdef_end, l, c);
           lexer_flags.at_beginning_of_statement = true;
           break;
-          
+
         case endevents_kw:
           yylval.tok_val = new token (token::events_end, l, c);
           lexer_flags.at_beginning_of_statement = true;
           break;
-          
+
         case endmethods_kw:
           yylval.tok_val = new token (token::methods_end, l, c);
           lexer_flags.at_beginning_of_statement = true;
           break;
-          
+
         case endproperties_kw:
           yylval.tok_val = new token (token::properties_end, l, c);
           lexer_flags.at_beginning_of_statement = true;
           break;
 
         case for_kw:
         case while_kw:
           promptflag--;
@@ -1550,17 +1550,17 @@ is_keyword_token (const std::string& s)
           break;
 
         case if_kw:
         case switch_kw:
           promptflag--;
           break;
 
         case get_kw:
-        case set_kw:  
+        case set_kw:
           // 'get' and 'set' are keywords in classdef method
           // declarations.
           if (! lexer_flags.maybe_classdef_get_set_method)
             return 0;
           break;
 
         case properties_kw:
         case methods_kw:
@@ -1569,17 +1569,17 @@ is_keyword_token (const std::string& s)
           // classdef blocks.
           if (! lexer_flags.parsing_classdef)
             return 0;
           // fall through ...
 
         case classdef_kw:
           // 'classdef' is always a keyword.
           promptflag--;
-          break;          
+          break;
 
         case function_kw:
           promptflag--;
 
           lexer_flags.defining_func++;
           lexer_flags.parsed_function_name.push (false);
 
           if (! (reading_fcn_file || reading_script_file
@@ -1802,17 +1802,17 @@ grab_comment_block (stream_reader& reade
                     }
                 }
             }
           else
             {
               at_bol = false;
               begin_comment = false;
             }
-        }       
+        }
 
       if (in_comment)
         {
           buf += static_cast<char> (c);
 
           if (c == '\n')
             {
               at_bol = true;
@@ -1874,17 +1874,17 @@ grab_comment_block (stream_reader& reade
 class
 flex_stream_reader : public stream_reader
 {
 public:
   flex_stream_reader (char *buf_arg) : stream_reader (), buf (buf_arg) { }
 
   int getc (void) { return ::text_yyinput (); }
   int ungetc (int c) { ::xunput (c, buf); return 0; }
-  
+
 private:
   char *buf;
 };
 
 static int
 process_comment (bool start_in_block, bool& eof)
 {
   eof = false;
@@ -2562,21 +2562,21 @@ handle_string (char delim)
         {
           if (escape_pending)
             buf << static_cast<char> (c);
           else
             {
               c = text_yyinput ();
               if (c == delim)
                 {
-                  buf << static_cast<char> (c);             
+                  buf << static_cast<char> (c);
                 }
               else
                 {
-                  std::string s;  
+                  std::string s;
                   xunput (c, yytext);
 
                   if (delim == '\'')
                     s = buf.str ();
                   else
                     s = do_string_escapes (buf.str ());
 
                   lexer_flags.quote_is_transpose = true;
@@ -3069,82 +3069,82 @@ looks_like_command_arg (void)
   return retval;
 }
 
 static int
 handle_superclass_identifier (void)
 {
   eat_continuation ();
 
-  std::string pkg;  
-  std::string meth = strip_trailing_whitespace (yytext); 
+  std::string pkg;
+  std::string meth = strip_trailing_whitespace (yytext);
   size_t pos = meth.find ("@");
   std::string cls = meth.substr (pos).substr (1);
-  meth = meth.substr (0, pos - 1);  
-  
+  meth = meth.substr (0, pos - 1);
+
   pos = cls.find (".");
   if (pos != std::string::npos)
-    {    
+    {
       pkg = cls.substr (pos).substr (1);
       cls = cls.substr (0, pos - 1);
     }
-    
+
   int kw_token = (is_keyword_token (meth) || is_keyword_token (cls)
                   || is_keyword_token (pkg));
   if (kw_token)
     {
       error ("method, class and package names may not be keywords");
       return LEXICAL_ERROR;
     }
- 
+
   yylval.tok_val
     = new token (meth.empty () ? 0 : &(symbol_table::insert (meth)),
                  cls.empty () ? 0 : &(symbol_table::insert (cls)),
                  pkg.empty () ? 0 : &(symbol_table::insert (pkg)),
-                 input_line_number, current_input_column);                                 
+                 input_line_number, current_input_column);
   token_stack.push (yylval.tok_val);
-  
+
   lexer_flags.convert_spaces_to_comma = true;
   current_input_column += yyleng;
-  
+
   return SUPERCLASSREF;
 }
 
 static int
 handle_meta_identifier (void)
 {
   eat_continuation ();
 
   std::string pkg;
   std::string cls = strip_trailing_whitespace (yytext).substr (1);
   size_t pos = cls.find (".");
-  
+
   if (pos != std::string::npos)
-    {    
+    {
       pkg = cls.substr (pos).substr (1);
       cls = cls.substr (0, pos - 1);
     }
-  
+
   int kw_token = is_keyword_token (cls) || is_keyword_token (pkg);
   if (kw_token)
     {
        error ("class and package names may not be keywords");
       return LEXICAL_ERROR;
     }
-  
+
   yylval.tok_val
     = new token (cls.empty () ? 0 : &(symbol_table::insert (cls)),
                  pkg.empty () ? 0 : &(symbol_table::insert (pkg)),
                  input_line_number, current_input_column);
 
   token_stack.push (yylval.tok_val);
-                   
+
   lexer_flags.convert_spaces_to_comma = true;
   current_input_column += yyleng;
-  
+
   return METAQUERY;
 }
 
 // Figure out exactly what kind of token to return when we have seen
 // an identifier.  Handles keywords.  Return -1 if the identifier
 // should be ignored.
 
 static int
@@ -3284,17 +3284,17 @@ handle_identifier (void)
           lexer_flags.pending_local_variables.insert (tok);
         }
     }
 
   // Find the token in the symbol table.  Beware the magic
   // transformation of the end keyword...
 
   if (tok == "end")
-    tok = "__end__";    
+    tok = "__end__";
 
   yylval.tok_val = new token (&(symbol_table::insert (tok)),
                               input_line_number, current_input_column);
 
   token_stack.push (yylval.tok_val);
 
   // After seeing an identifer, it is ok to convert spaces to a comma
   // (if needed).
@@ -3333,17 +3333,17 @@ lexical_feedback::init (void)
   // Not initially defining a function.
   defining_func = 0;
 
   // Not parsing an object index.
   while (! parsed_function_name.empty ())
     parsed_function_name.pop ();
 
   parsing_class_method = false;
-  
+
   // Not initially defining a class with classdef.
   maybe_classdef_get_set_method = false;
   parsing_classdef = false;
 
   // Not initiallly looking at a function handle.
   looking_at_function_handle = 0;
 
   // Not parsing a function return, parameter, or declaration list.
@@ -3366,17 +3366,17 @@ lexical_feedback::init (void)
 
   // Object index not possible until we've seen something.
   looking_for_object_index = false;
 
   // Yes, we are at the beginning of a statement.
   at_beginning_of_statement = true;
 
   // No need to do comma insert or convert spaces to comma at
-  // beginning of input. 
+  // beginning of input.
   convert_spaces_to_comma = true;
   do_comma_insert = false;
 
   // Not initially looking at indirect references.
   looking_at_indirect_ref = false;
 
   // Quote marks strings intially.
   quote_is_transpose = false;
diff --git a/src/load-path.cc b/src/load-path.cc
--- a/src/load-path.cc
+++ b/src/load-path.cc
@@ -936,24 +936,24 @@ load_path::check_file_type (std::string&
           fname += ".m";
           retval = true;
         }
     }
   else
     error ("%s: %s: invalid type code = %d", who, fcn.c_str (), type);
 
   return retval;
-} 
+}
 
 std::string
 load_path::do_find_fcn (const std::string& fcn, std::string& dir_name,
                         int type) const
 {
   std::string retval;
-  
+
   //  update ();
 
   if (fcn.length () > 0 && fcn[0] == '@')
     {
       size_t pos = fcn.find ('/');
 
       if (pos != std::string::npos)
         {
@@ -1762,25 +1762,25 @@ load_path::add_to_fcn_map (const dir_inf
                   // partial matches?
 
                   if (sys_path.find (old.dir_name) != std::string::npos
                       && in_path_list (sys_path, old.dir_name))
                     {
                       std::string fcn_path = file_ops::concat (dir_name, fname);
 
                       warning_with_id ("Octave:shadowed-function",
-                                       "function %s shadows a core library function", 
+                                       "function %s shadows a core library function",
                                        fcn_path.c_str ());
                     }
                 }
               else if (symbol_table::is_built_in_function_name (base))
                 {
                   std::string fcn_path = file_ops::concat (dir_name, fname);
                   warning_with_id ("Octave:shadowed-function",
-                                   "function %s shadows a built-in function", 
+                                   "function %s shadows a built-in function",
                                    fcn_path.c_str ());
                 }
 
               file_info_list.push_front (fi);
             }
         }
       else
         {
@@ -1878,17 +1878,17 @@ genpath (const std::string& dirname, con
 
   dir_entry dir (dirname);
 
   if (dir)
     {
       retval = dirname;
 
       string_vector dirlist = dir.read ();
-      
+
       octave_idx_type len = dirlist.length ();
 
       for (octave_idx_type i = 0; i < len; i++)
         {
           std::string elt = dirlist[i];
 
           bool skip_p = (elt == "." || elt == ".." || elt[0] == '@');
 
diff --git a/src/load-path.h b/src/load-path.h
--- a/src/load-path.h
+++ b/src/load-path.h
@@ -305,17 +305,17 @@ private:
     {
       initialize ();
     }
 
     dir_info (const dir_info& di)
       : dir_name (di.dir_name), abs_dir_name (di.abs_dir_name),
         is_relative (di.is_relative),
         dir_mtime (di.dir_mtime),
-        dir_time_last_checked (di.dir_time_last_checked), 
+        dir_time_last_checked (di.dir_time_last_checked),
         all_files (di.all_files), fcn_files (di.fcn_files),
         private_file_map (di.private_file_map),
         method_file_map (di.method_file_map) { }
 
     ~dir_info (void) { }
 
     dir_info& operator = (const dir_info& di)
     {
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -186,17 +186,17 @@ read_binary_file_header (std::istream& i
   else if (strncmp (magic, "Octave-1-B", magic_len) == 0)
     swap = ! oct_mach_info::words_big_endian ();
   else
     {
       if (! quiet)
         error ("load: unable to read read binary file");
       return -1;
     }
-        
+
   char tmp = 0;
   is.read (&tmp, 1);
 
   flt_fmt = mopt_digit_to_float_format (tmp);
 
   if (flt_fmt == oct_mach_info::flt_fmt_unknown)
     {
       if (! quiet)
@@ -211,23 +211,23 @@ read_binary_file_header (std::istream& i
 #ifdef HAVE_ZLIB
 static bool
 check_gzip_magic (const std::string& fname)
 {
   bool retval = false;
   std::ifstream file (fname.c_str ());
   OCTAVE_LOCAL_BUFFER (unsigned char, magic, 2);
 
-  if (file.read (reinterpret_cast<char *> (magic), 2) && magic[0] == 0x1f && 
+  if (file.read (reinterpret_cast<char *> (magic), 2) && magic[0] == 0x1f &&
       magic[1] == 0x8b)
     retval = true;
 
   file.close ();
   return retval;
-} 
+}
 #endif
 
 static load_save_format
 get_file_format (std::istream& file, const std::string& filename)
 {
   load_save_format retval = LS_UNKNOWN;
 
   oct_mach_info::float_format flt_fmt = oct_mach_info::flt_fmt_unknown;
@@ -272,37 +272,37 @@ get_file_format (std::istream& file, con
             }
         }
     }
 
   return retval;
 }
 
 static load_save_format
-get_file_format (const std::string& fname, const std::string& orig_fname, 
+get_file_format (const std::string& fname, const std::string& orig_fname,
                  bool &use_zlib)
 {
   load_save_format retval = LS_UNKNOWN;
 
 #ifdef HAVE_HDF5
   // check this before we open the file
   if (H5Fis_hdf5 (fname.c_str ()) > 0)
     return LS_HDF5;
 #endif /* HAVE_HDF5 */
 
   std::ifstream file (fname.c_str ());
   use_zlib = false;
-      
+
   if (file)
     {
       retval = get_file_format (file, orig_fname);
       file.close ();
 
 #ifdef HAVE_ZLIB
-      if (retval == LS_UNKNOWN && check_gzip_magic (fname))     
+      if (retval == LS_UNKNOWN && check_gzip_magic (fname))
         {
           gzifstream gzfile (fname.c_str ());
           use_zlib = true;
 
           if (gzfile)
             {
               retval = get_file_format (gzfile, orig_fname);
               gzfile.close ();
@@ -506,32 +506,32 @@ find_file_to_load (const std::string& na
                                "load: file found in load path");
               fname = tmp;
             }
         }
     }
 
   size_t dot_pos = fname.rfind (".");
   size_t sep_pos = fname.find_last_of (file_ops::dir_sep_chars ());
-    
+
   if (dot_pos == std::string::npos
       || (sep_pos != std::string::npos && dot_pos < sep_pos))
     {
       // Either no '.' in name or no '.' appears after last directory
       // separator.
 
       file_stat fs (fname);
 
       if (! (fs.exists () && fs.is_reg ()))
         fname = find_file_to_load (fname + ".mat", orig_name);
     }
   else
     {
       file_stat fs (fname);
-  
+
       if (! (fs.exists () && fs.is_reg ()))
         {
           fname = "";
 
           error ("load: unable to find file %s", orig_name.c_str ());
         }
     }
 
@@ -814,17 +814,17 @@ Force Octave to assume the file is in Oc
                   if (format == LS_BINARY)
                     {
                       if (read_binary_file_header (file, swap, flt_fmt) < 0)
                         {
                           if (file) file.close ();
                           return retval;
                         }
                     }
-                  else if (format == LS_MAT5_BINARY 
+                  else if (format == LS_MAT5_BINARY
                            || format == LS_MAT7_BINARY)
                     {
                       if (read_mat5_binary_file_header (file, swap, false, orig_fname) < 0)
                         {
                           if (file) file.close ();
                           return retval;
                         }
                     }
@@ -848,17 +848,17 @@ Force Octave to assume the file is in Oc
                   if (format == LS_BINARY)
                     {
                       if (read_binary_file_header (file, swap, flt_fmt) < 0)
                         {
                           if (file) file.close ();
                           return retval;
                         }
                     }
-                  else if (format == LS_MAT5_BINARY 
+                  else if (format == LS_MAT5_BINARY
                            || format == LS_MAT7_BINARY)
                     {
                       if (read_mat5_binary_file_header (file, swap, false, orig_fname) < 0)
                         {
                           if (file) file.close ();
                           return retval;
                         }
                     }
@@ -870,17 +870,17 @@ Force Octave to assume the file is in Oc
                   file.close ();
                 }
               else
                 error ("load: unable open input file `%s'",
                        orig_fname.c_str ());
             }
         }
     }
-    
+
   return retval;
 }
 
 // Return TRUE if PATTERN has any special globbing chars in it.
 
 static bool
 glob_pattern_p (const std::string& pattern)
 {
@@ -930,17 +930,17 @@ do_save (std::ostream& os, const octave_
       save_ascii_data (os, tc, name, global, 0);
       break;
 
     case LS_BINARY:
       save_binary_data (os, tc, name, help, global, save_as_floats);
       break;
 
     case LS_MAT_ASCII:
-      if (! save_mat_ascii_data (os, tc, fmt.opts & LS_MAT_ASCII_LONG ? 16 : 8, 
+      if (! save_mat_ascii_data (os, tc, fmt.opts & LS_MAT_ASCII_LONG ? 16 : 8,
                                  fmt.opts & LS_MAT_ASCII_TABS))
         warning ("save: unable to save %s in ASCII format", name.c_str ());
       break;
 
     case LS_MAT_BINARY:
       save_mat_binary_data (os, tc, name);
       break;
 
@@ -986,17 +986,17 @@ do_save (std::ostream& os, const symbol_
 // in the format specified by FMT.
 
 static size_t
 save_fields (std::ostream& os, const octave_scalar_map& m,
              const std::string& pattern,
              load_save_format fmt, bool save_as_floats)
 {
   glob_match pat (pattern);
-  
+
   size_t saved = 0;
 
   for (octave_scalar_map::const_iterator p = m.begin (); p != m.end (); p++)
     {
       std::string empty_str;
 
       if (pat.match(m.key (p)))
         {
@@ -1075,24 +1075,24 @@ parse_save_options (const string_vector 
       else if (argv[i] == "-hdf5" || argv[i] == "-h")
         {
 #ifdef HAVE_HDF5
           format = LS_HDF5;
 #else /* ! HAVE_HDF5 */
           error ("save: octave executable was not linked with HDF5 library");
 #endif /* ! HAVE_HDF5 */
         }
-      else if (argv[i] == "-mat-binary" || argv[i] == "-mat" 
+      else if (argv[i] == "-mat-binary" || argv[i] == "-mat"
                || argv[i] == "-m" || argv[i] == "-6" || argv[i] == "-v6"
                || argv[i] == "-V6")
         {
           format = LS_MAT5_BINARY;
         }
 #ifdef HAVE_ZLIB
-      else if (argv[i] == "-mat7-binary" || argv[i] == "-7" 
+      else if (argv[i] == "-mat7-binary" || argv[i] == "-7"
                || argv[i] == "-v7" || argv[i] == "-V7")
         {
           format = LS_MAT7_BINARY;
         }
 #endif
       else if (argv[i] == "-mat4-binary" || argv[i] == "-V4"
                || argv[i] == "-v4" || argv[i] == "-4")
         {
@@ -1137,31 +1137,31 @@ parse_save_options (const string_vector 
       else
         warning ("save: \"-tabs\" option only has an effect with \"-ascii\"");
     }
 
   return retval;
 }
 
 static string_vector
-parse_save_options (const std::string &arg, load_save_format &format, 
-                    bool &append, bool &save_as_floats, 
+parse_save_options (const std::string &arg, load_save_format &format,
+                    bool &append, bool &save_as_floats,
                     bool &use_zlib)
 {
   std::istringstream is (arg);
   std::string str;
   string_vector argv;
-  
+
   while (! is.eof ())
     {
       is >> str;
       argv.append (str);
     }
 
-  return parse_save_options (argv, format, append, save_as_floats, 
+  return parse_save_options (argv, format, append, save_as_floats,
                              use_zlib);
 }
 
 void
 write_header (std::ostream& os, load_save_format format)
 {
   switch (format.type)
     {
@@ -1251,50 +1251,50 @@ save_vars (const string_vector& argv, in
     write_header (os, fmt);
 
   if (argv_idx == argc)
     {
       save_vars (os, "*", fmt, save_as_floats);
     }
   else if (argv[argv_idx] == "-struct")
     {
-      if (++argv_idx >= argc) 
+      if (++argv_idx >= argc)
         {
           error ("save: missing struct name");
           return;
         }
 
       std::string struct_name = argv[argv_idx];
 
       if (! symbol_table::is_variable (struct_name))
         {
           error ("save: no such variable: `%s'", struct_name.c_str ());
           return;
         }
 
       octave_value struct_var = symbol_table::varref (struct_name);
 
-      if (! struct_var.is_map () || struct_var.numel () != 1) 
+      if (! struct_var.is_map () || struct_var.numel () != 1)
         {
           error ("save: `%s' is not a scalar structure",
                  struct_name.c_str ());
           return;
         }
       octave_scalar_map struct_var_map = struct_var.scalar_map_value ();
 
       ++argv_idx;
 
-      if (argv_idx < argc) 
+      if (argv_idx < argc)
         {
           for (int i = argv_idx; i < argc; i++)
             {
               if (! save_fields (os, struct_var_map, argv[i], fmt,
                                  save_as_floats))
                 {
-                  warning ("save: no such field `%s.%s'", 
+                  warning ("save: no such field `%s.%s'",
                            struct_name.c_str (), argv[i].c_str ());
                 }
             }
         }
       else
         save_fields (os, struct_var_map, "*", fmt, save_as_floats);
     }
   else
@@ -1364,19 +1364,19 @@ dump_octave_core (void)
       load_save_format format = LS_BINARY;
 
       bool save_as_floats = false;
 
       bool append = false;
 
       bool use_zlib = false;
 
-      parse_save_options (Voctave_core_file_options, format, append, 
+      parse_save_options (Voctave_core_file_options, format, append,
                           save_as_floats, use_zlib);
-  
+
       std::ios::openmode mode = std::ios::out;
 
       // Matlab v7 files are always compressed
       if (format == LS_MAT7_BINARY)
         use_zlib = false;
 
       if (format == LS_BINARY
 #ifdef HAVE_HDF5
@@ -1421,17 +1421,17 @@ dump_octave_core (void)
                 }
               else
                 warning ("unable to open `%s' for writing...", fname);
             }
           else
 #endif
             {
               std::ofstream file (fname, mode);
-          
+
               if (file)
                 {
                   dump_octave_core (file, fname, format, save_as_floats);
 
                   file.close ();
                 }
               else
                 warning ("unable to open `%s' for writing...", fname);
@@ -1590,21 +1590,21 @@ the file @file{data} in Octave's binary 
 
   load_save_format format = LS_ASCII;
 
   bool append = false;
 
   bool use_zlib = false;
 
   // get default options
-  parse_save_options (Vdefault_save_options, format, append, save_as_floats, 
+  parse_save_options (Vdefault_save_options, format, append, save_as_floats,
                       use_zlib);
 
   // override from command line
-  argv = parse_save_options (argv, format, append, save_as_floats, 
+  argv = parse_save_options (argv, format, append, save_as_floats,
                              use_zlib);
   argc = argv.length ();
   int i = 0;
 
   if (error_state)
     return retval;
 
   if (i == argc)
@@ -1631,17 +1631,17 @@ the file @file{data} in Octave's binary 
         // don't insert any commands here!  the brace below must go
         // with the "else" above!
         {
           if (append)
             warning ("save: ignoring -append option for output to stdout");
 
           // FIXME -- should things intended for the screen end up
           // in a octave_value (string)?
-          
+
           save_vars (argv, i, argc, octave_stdout, format,
                      save_as_floats, true);
         }
     }
 
   // Guard against things like `save a*', which are probably mistakes...
 
   else if (i == argc - 1 && glob_pattern_p (argv[i]))
@@ -1676,17 +1676,17 @@ the file @file{data} in Octave's binary 
         {
           // FIXME. It should be possible to append to HDF5 files.
           if (append)
             {
               error ("save: appending to HDF5 files is not implemented");
               return retval;
             }
 
-          bool write_header_info = ! (append && 
+          bool write_header_info = ! (append &&
                                       H5Fis_hdf5 (fname.c_str ()) > 0);
 
           hdf5_ofstream hdf5_file (fname.c_str (), mode);
 
           if (hdf5_file.file_id != -1)
             {
               save_vars (argv, i, argc, hdf5_file, format,
                          save_as_floats, write_header_info);
@@ -1723,17 +1723,17 @@ the file @file{data} in Octave's binary 
                   gripe_file_open ("save", fname);
                   return retval;
                 }
             }
           else
 #endif
             {
               std::ofstream file (fname.c_str (), mode);
-          
+
               if (file)
                 {
                   bool write_header_info = ! file.tellp ();
 
                   save_vars (argv, i, argc, file, format,
                              save_as_floats, write_header_info);
 
                   file.close ();
diff --git a/src/load-save.h b/src/load-save.h
--- a/src/load-save.h
+++ b/src/load-save.h
@@ -48,17 +48,17 @@ enum load_save_format_options
 {
   // LS_MAT_ASCII options (not exclusive)
   LS_MAT_ASCII_LONG = 1,
   LS_MAT_ASCII_TABS = 2,
   // LS_MAT_BINARY options
   LS_MAT_BINARY_V5 = 1,
   LS_MAT_BINARY_V7,
   // zero means no option.
-  LS_NO_OPTION = 0  
+  LS_NO_OPTION = 0
 };
 
 class load_save_format
 {
 public:
   load_save_format (load_save_format_type t,
                     load_save_format_options o = LS_NO_OPTION)
     : type (t), opts (o) { }
diff --git a/src/ls-ascii-helper.cc b/src/ls-ascii-helper.cc
--- a/src/ls-ascii-helper.cc
+++ b/src/ls-ascii-helper.cc
@@ -38,39 +38,39 @@ along with Octave; see the file COPYING.
 // Depending on KEEP_NEWLINE, either eat newline from stream or
 // keep it unread.
 
 void
 skip_until_newline (std::istream& is, bool keep_newline)
 {
   if (! is)
     return;
-  
+
   while (is)
     {
       char c = is.peek ();
 
       if (c == '\n' || c == '\r')
         {
           // Reached newline.
           if (! keep_newline)
             {
               // Eat the CR or LF character.
               char d;
               is.get (d);
-              
+
               // Make sure that for binary-mode opened ascii files
               // containing CRLF line endings we skip the LF after CR.
               if (c == '\r' && is.peek () == '\n')
                 {
                   // Yes, LF following CR, eat it.
                   is.get (d);
                 }
             }
-          
+
           // Newline was found, and read from stream if
           // keep_newline == true, so exit loop.
           break;
         }
       else
         {
           // No newline charater peeked, so read it and proceed to next
           // character.
@@ -85,37 +85,37 @@ skip_until_newline (std::istream& is, bo
 // previous read) then eat newline(s) until a non-newline character is
 // found.
 
 void
 skip_preceeding_newline (std::istream& is)
 {
   if (! is)
     return;
-  
+
   // Check whether IS currently points to newline character.
   char c = is.peek ();
 
   if (c == '\n' || c == '\r')
     {
       // Yes, at newline.
       do
         {
           // Eat the CR or LF character.
           char d;
           is.get (d);
-          
+
           // Make sure that for binary-mode opened ascii files
           // containing CRLF line endings we skip the LF after CR.
           if (c == '\r' && is.peek () == '\n')
             {
               // Yes, LF following CR, eat it.
               is.get (d);
           }
-          
+
           // Peek into next character.
           c = is.peek ();
 
           // Loop while still a newline ahead.
         }
       while (c == '\n' || c == '\r');
     }
 }
@@ -125,51 +125,51 @@ skip_preceeding_newline (std::istream& i
 // it unread.  Characters read are stored and returned as
 // std::string.
 
 std::string
 read_until_newline (std::istream& is, bool keep_newline)
 {
   if (! is)
     return std::string ();
-  
+
   std::ostringstream buf;
-  
+
   while (is)
     {
       char c = is.peek ();
 
       if (c == '\n' || c == '\r')
         {
           // Reached newline.
           if (! keep_newline)
             {
               // Eat the CR or LF character.
               char d;
               is.get (d);
-              
+
               // Make sure that for binary-mode opened ascii files
               // containing CRLF line endings we skip the LF after
               // CR.
 
               if (c == '\r' && is.peek () == '\n')
                 {
                   // Yes, LF following CR, eat it.
                   is.get (d);
                 }
             }
-          
+
           // Newline was found, and read from stream if
           // keep_newline == true, so exit loop.
           break;
         }
       else
         {
           // No newline charater peeked, so read it, store it, and
           // proceed to next.
           char d;
           is.get (d);
           buf << d;
         }
     }
-  
+
   return buf.str ();
 }
diff --git a/src/ls-hdf5.cc b/src/ls-hdf5.cc
--- a/src/ls-hdf5.cc
+++ b/src/ls-hdf5.cc
@@ -92,17 +92,17 @@ make_valid_identifier (const std::string
 
   return retval;
 }
 
 // Define this to 1 if/when HDF5 supports automatic conversion between
 // integer and floating-point binary data:
 #define HAVE_HDF5_INT2FLOAT_CONVERSIONS 0
 
-// Given two compound types t1 and t2, determine whether they 
+// Given two compound types t1 and t2, determine whether they
 // are compatible for reading/writing.  This function only
 // works for non-nested types composed of simple elements (ints, floats...),
 // which is all we need it for
 
 bool
 hdf5_types_compatible (hid_t t1, hid_t t2)
 {
   int n;
@@ -164,17 +164,17 @@ hdf5_check_attr (hid_t loc_id, const cha
   H5Eset_auto (H5E_DEFAULT, err_func, err_func_data);
 #else
   H5Eset_auto (err_func, err_func_data);
 #endif
   return retval;
 }
 
 bool
-hdf5_get_scalar_attr (hid_t loc_id, hid_t type_id, 
+hdf5_get_scalar_attr (hid_t loc_id, hid_t type_id,
                       const char *attr_name, void *buf)
 {
   bool retval = false;
 
   // we have to pull some shenanigans here to make sure
   // HDF5 doesn't print out all sorts of error messages if we
   // call H5Aopen for a non-existing attribute
 
@@ -214,18 +214,18 @@ hdf5_get_scalar_attr (hid_t loc_id, hid_
   return retval;
 }
 
 
 
 
 // The following subroutines creates an HDF5 representations of the way
 // we will store Octave complex types (pairs of floating-point numbers).
-// NUM_TYPE is the HDF5 numeric type to use for storage (e.g. 
-// H5T_NATIVE_DOUBLE to save as 'double'). Note that any necessary 
+// NUM_TYPE is the HDF5 numeric type to use for storage (e.g.
+// H5T_NATIVE_DOUBLE to save as 'double'). Note that any necessary
 // conversions are handled automatically by HDF5.
 
 hid_t
 hdf5_make_complex_type (hid_t num_type)
 {
   hid_t type_id = H5Tcreate (H5T_COMPOUND, sizeof (double) * 2);
 
   H5Tinsert (type_id, "real", 0 * sizeof (double), num_type);
@@ -261,17 +261,17 @@ hdf5_read_next_data (hid_t group_id, con
   // earlier versions of Octave.
 
   if (! ident_valid )
     {
       // fix the identifier, replacing invalid chars with underscores
       vname = make_valid_identifier (vname);
 
       // check again (in case vname was null, empty, or some such thing):
-      ident_valid = valid_identifier (vname); 
+      ident_valid = valid_identifier (vname);
     }
 
   H5Gget_objinfo (group_id, name, 1, &info);
 
   if (info.type == H5G_GROUP && ident_valid)
     {
 #if HAVE_HDF5_18
       subgroup_id = H5Gopen (group_id, name, H5P_DEFAULT);
@@ -300,34 +300,34 @@ hdf5_read_next_data (hid_t group_id, con
             }
 
           type_id = H5Dget_type (data_id);
 
           type_class_id = H5Tget_class (type_id);
 
           if (type_class_id != H5T_STRING)
             goto done;
-          
+
           space_id = H5Dget_space (data_id);
           hsize_t rank = H5Sget_simple_extent_ndims (space_id);
 
           if (rank != 0)
             goto done;
 
           int slen = H5Tget_size (type_id);
           if (slen < 0)
             goto done;
 
           OCTAVE_LOCAL_BUFFER (char, typ, slen);
 
           // create datatype for (null-terminated) string to read into:
           hid_t st_id = H5Tcopy (H5T_C_S1);
           H5Tset_size (st_id, slen);
 
-          if (H5Dread (data_id, st_id, H5S_ALL, H5S_ALL, H5P_DEFAULT, 
+          if (H5Dread (data_id, st_id, H5S_ALL, H5S_ALL, H5P_DEFAULT,
                        typ) < 0)
             goto done;
 
           H5Tclose (st_id);
           H5Dclose (data_id);
 
           d->tc = octave_value_typeinfo::lookup_type (typ);
 
@@ -343,17 +343,17 @@ hdf5_read_next_data (hid_t group_id, con
           // an HDF5 group is treated as an octave structure by
           // default (since that preserves name information), and an
           // octave list otherwise.
 
           if (hdf5_check_attr (subgroup_id, "OCTAVE_LIST"))
             d->tc = octave_value_typeinfo::lookup_type ("list");
           else
             d->tc = octave_value_typeinfo::lookup_type ("struct");
-          
+
           // check for OCTAVE_GLOBAL attribute:
           d->global = hdf5_check_attr (subgroup_id, "OCTAVE_GLOBAL");
 
           H5Gclose (subgroup_id);
 
           retval = (d->tc.load_hdf5 (group_id, name) ? 1 : -1);
         }
 
@@ -369,46 +369,46 @@ hdf5_read_next_data (hid_t group_id, con
 
       if (data_id < 0)
         {
           retval = data_id;
           goto done;
         }
 
       type_id = H5Dget_type (data_id);
-      
+
       type_class_id = H5Tget_class (type_id);
 
       if (type_class_id == H5T_FLOAT)
         {
           space_id = H5Dget_space (data_id);
 
           hsize_t rank = H5Sget_simple_extent_ndims (space_id);
-          
+
           if (rank == 0)
             d->tc = octave_value_typeinfo::lookup_type ("scalar");
           else
             d->tc = octave_value_typeinfo::lookup_type ("matrix");
 
           H5Sclose (space_id);
         }
       else if (type_class_id == H5T_INTEGER)
         {
           // What integer type do we really have..
           std::string int_typ;
 #ifdef HAVE_H5T_GET_NATIVE_TYPE
-          // FIXME test this code and activated with an autoconf 
+          // FIXME test this code and activated with an autoconf
           // test!! It is also incorrect for 64-bit indexing!!
-          
+
           switch (H5Tget_native_type (type_id, H5T_DIR_ASCEND))
             {
             case H5T_NATIVE_CHAR:
               int_typ = "int8 ";
               break;
- 
+
             case H5T_NATIVE_SHORT:
               int_typ = "int16 ";
               break;
 
             case H5T_NATIVE_INT:
             case H5T_NATIVE_LONG:
               int_typ = "int32 ";
               break;
@@ -428,17 +428,17 @@ hdf5_read_next_data (hid_t group_id, con
             case H5T_NATIVE_UINT:
             case H5T_NATIVE_ULONG:
               int_typ = "uint32 ";
               break;
 
             case H5T_NATIVE_ULLONG:
               int_typ = "uint64 ";
               break;
-            }   
+            }
 #else
           hid_t int_sign = H5Tget_sign (type_id);
 
           if (int_sign == H5T_SGN_ERROR)
             warning ("load: can't read `%s' (unknown datatype)", name);
           else
             {
               if (int_sign == H5T_SGN_NONE)
@@ -464,33 +464,33 @@ hdf5_read_next_data (hid_t group_id, con
                       int_typ.append ("32 ");
                       break;
 
                     case 8:
                       int_typ.append ("64 ");
                       break;
 
                     default:
-                      warning ("load: can't read `%s' (unknown datatype)", 
+                      warning ("load: can't read `%s' (unknown datatype)",
                                name);
                       int_typ = "";
                       break;
                     }
                 }
             }
 #endif
           if (int_typ == "")
             warning ("load: can't read `%s' (unknown datatype)", name);
           else
             {
               // Matrix or scalar?
               space_id = H5Dget_space (data_id);
 
               hsize_t rank = H5Sget_simple_extent_ndims (space_id);
-              
+
               if (rank == 0)
                 int_typ.append ("scalar");
               else
                 int_typ.append ("matrix");
 
               d->tc = octave_value_typeinfo::lookup_type (int_typ);
               H5Sclose (space_id);
             }
@@ -501,17 +501,17 @@ hdf5_read_next_data (hid_t group_id, con
         {
           hid_t complex_type = hdf5_make_complex_type (H5T_NATIVE_DOUBLE);
 
           if (hdf5_types_compatible (type_id, complex_type))
             {
               // read complex matrix or scalar variable
               space_id = H5Dget_space (data_id);
               hsize_t rank = H5Sget_simple_extent_ndims (space_id);
-                  
+
               if (rank == 0)
                 d->tc = octave_value_typeinfo::lookup_type ("complex scalar");
               else
                 d->tc = octave_value_typeinfo::lookup_type ("complex matrix");
 
               H5Sclose (space_id);
             }
           else
@@ -521,17 +521,17 @@ hdf5_read_next_data (hid_t group_id, con
 
           H5Tclose (complex_type);
         }
       else
         {
           warning ("load: can't read `%s' (unknown datatype)", name);
           retval = 0; // unknown datatype; skip
         }
-      
+
       // check for OCTAVE_GLOBAL attribute:
       d->global = hdf5_check_attr (data_id, "OCTAVE_GLOBAL");
 
       H5Tclose (type_id);
       H5Dclose (data_id);
 
       retval = (d->tc.load_hdf5 (group_id, name) ? 1 : -1);
     }
@@ -542,17 +542,17 @@ hdf5_read_next_data (hid_t group_id, con
       // bad characters to '_', say?
       warning ("load: skipping invalid identifier `%s' in hdf5 file",
                name);
     }
 
  done:
   if (retval < 0)
     error ("load: error while reading hdf5 item %s", name);
-  
+
   if (retval > 0)
     {
       // get documentation string, if any:
       int comment_length = H5Gget_comment (group_id, name, 0, 0);
 
       if (comment_length > 1)
         {
           OCTAVE_LOCAL_BUFFER (char, tdoc, comment_length);
@@ -574,33 +574,33 @@ hdf5_read_next_data (hid_t group_id, con
 }
 
 // Read the next Octave variable from the stream IS, which must really be
 // an hdf5_ifstream.  Return the variable value in tc, its doc string
 // in doc, and whether it is global in global.  The return value is
 // the name of the variable, or NULL if none were found or there was
 // and error.
 std::string
-read_hdf5_data (std::istream& is, const std::string& /* filename */, 
+read_hdf5_data (std::istream& is, const std::string& /* filename */,
                 bool& global, octave_value& tc, std::string& doc)
 {
   std::string retval;
 
   doc.resize (0);
 
   hdf5_ifstream& hs = dynamic_cast<hdf5_ifstream&> (is);
   hdf5_callback_data d;
 
   herr_t H5Giterate_retval = -1;
 
   hsize_t num_obj = 0;
 #if HAVE_HDF5_18
-  hid_t group_id = H5Gopen (hs.file_id, "/", H5P_DEFAULT); 
+  hid_t group_id = H5Gopen (hs.file_id, "/", H5P_DEFAULT);
 #else
-  hid_t group_id = H5Gopen (hs.file_id, "/"); 
+  hid_t group_id = H5Gopen (hs.file_id, "/");
 #endif
   H5Gget_num_objs (group_id, &num_obj);
   H5Gclose (group_id);
   if (hs.current_item < static_cast<int> (num_obj))
     H5Giterate_retval = H5Giterate (hs.file_id, "/", &hs.current_item,
                                     hdf5_read_next_data, &d);
 
   if (H5Giterate_retval > 0)
@@ -629,17 +629,17 @@ hdf5_add_attr (hid_t loc_id, const char 
 {
   herr_t retval = 0;
 
   hid_t as_id = H5Screate (H5S_SCALAR);
 
   if (as_id >= 0)
     {
 #if HAVE_HDF5_18
-      hid_t a_id = H5Acreate (loc_id, attr_name, H5T_NATIVE_UCHAR, 
+      hid_t a_id = H5Acreate (loc_id, attr_name, H5T_NATIVE_UCHAR,
                               as_id, H5P_DEFAULT, H5P_DEFAULT);
 #else
       hid_t a_id = H5Acreate (loc_id, attr_name,
                               H5T_NATIVE_UCHAR, as_id, H5P_DEFAULT);
 #endif
       if (a_id >= 0)
         {
           unsigned char attr_val = 1;
@@ -665,17 +665,17 @@ hdf5_add_scalar_attr (hid_t loc_id, hid_
 {
   herr_t retval = 0;
 
   hid_t as_id = H5Screate (H5S_SCALAR);
 
   if (as_id >= 0)
     {
 #if HAVE_HDF5_18
-      hid_t a_id = H5Acreate (loc_id, attr_name, type_id, 
+      hid_t a_id = H5Acreate (loc_id, attr_name, type_id,
                               as_id, H5P_DEFAULT, H5P_DEFAULT);
 #else
       hid_t a_id = H5Acreate (loc_id, attr_name,
                               type_id, as_id, H5P_DEFAULT);
 #endif
       if (a_id >= 0)
         {
           retval = H5Awrite (a_id, type_id, buf);
@@ -713,37 +713,37 @@ save_hdf5_empty (hid_t loc_id, const cha
     }
 
   if (!empty)
     return 0;
 
   space_hid = H5Screate_simple (1, &sz, 0);
   if (space_hid < 0) return space_hid;
 #if HAVE_HDF5_18
-  data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_IDX, space_hid, 
+  data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_IDX, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
-  data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_IDX, space_hid, 
+  data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_IDX, space_hid,
                         H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       return data_hid;
     }
-  
+
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, dims) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
   if (retval >= 0)
     retval = hdf5_add_attr (loc_id, "OCTAVE_EMPTY_MATRIX");
-  
+
   return (retval == 0 ? 1 : retval);
 }
 
 // Load an empty matrix, if needed. Returns
 //    > 0  loaded empty matrix, dimensions returned
 //    = 0  Not an empty matrix; did nothing
 //    < 0  Error condition
 int
@@ -759,17 +759,17 @@ load_hdf5_empty (hid_t loc_id, const cha
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
   hid_t space_id = H5Dget_space (data_hid);
   H5Sget_simple_extent_dims (space_id, &hdims, &maxdims);
   int retval;
 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, dims, hdims);
 
-  retval = H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, 
+  retval = H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
                     H5P_DEFAULT, dims);
   if (retval >= 0)
     {
       d.resize (hdims);
       for (hsize_t i = 0; i < hdims; i++)
         d(i) = dims[i];
     }
 
@@ -831,17 +831,17 @@ add_hdf5_data (hid_t loc_id, const octav
 {
   hsize_t dims[3];
   hid_t type_id = -1, space_id = -1, data_id = -1, data_type_id = -1;
   bool retval = false;
   octave_value val = tc;
   // FIXME: diagonal & permutation matrices currently don't know how to save
   // themselves, so we convert them first to normal matrices using A = A(:,:).
   // This is a temporary hack.
-  if (val.is_diag_matrix () || val.is_perm_matrix () 
+  if (val.is_diag_matrix () || val.is_perm_matrix ()
       || val.type_id () == octave_lazy_index::static_type_id ())
     val = val.full_value ();
 
   std::string t = val.type_name();
 #if HAVE_HDF5_18
   data_id = H5Gcreate (loc_id, name.c_str (), H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_id = H5Gcreate (loc_id, name.c_str (), 0);
@@ -859,17 +859,17 @@ add_hdf5_data (hid_t loc_id, const octav
   if (space_id < 0)
     goto error_cleanup;
 #if HAVE_HDF5_18
   data_type_id = H5Dcreate (data_id, "type",  type_id, space_id,
                             H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_type_id = H5Dcreate (data_id, "type",  type_id, space_id, H5P_DEFAULT);
 #endif
-  if (data_type_id < 0 || H5Dwrite (data_type_id, type_id, H5S_ALL, H5S_ALL, 
+  if (data_type_id < 0 || H5Dwrite (data_type_id, type_id, H5S_ALL, H5S_ALL,
                                     H5P_DEFAULT, t.c_str ()) < 0)
     goto error_cleanup;
 
   // Now call the real function to save the variable
   retval = val.save_hdf5 (data_id, "value", save_as_floats);
 
   // attach doc string as comment:
   if (retval && doc.length () > 0
diff --git a/src/ls-hdf5.h b/src/ls-hdf5.h
--- a/src/ls-hdf5.h
+++ b/src/ls-hdf5.h
@@ -52,27 +52,27 @@ public:
     {
       if (mode & std::ios::in)
         file_id = H5Fopen (name, H5F_ACC_RDONLY, H5P_DEFAULT);
       else if (mode & std::ios::out)
         {
           if (mode & std::ios::app && H5Fis_hdf5 (name) > 0)
             file_id = H5Fopen (name, H5F_ACC_RDWR, H5P_DEFAULT);
           else
-            file_id = H5Fcreate (name, H5F_ACC_TRUNC, H5P_DEFAULT, 
+            file_id = H5Fcreate (name, H5F_ACC_TRUNC, H5P_DEFAULT,
                                  H5P_DEFAULT);
         }
       if (file_id < 0)
         std::ios::setstate (std::ios::badbit);
 
       current_item = 0;
     }
 
   void close ()
-    { 
+    {
       if (file_id >= 0)
         {
           if (H5Fclose (file_id) < 0)
             std::ios::setstate (std::ios::badbit);
           file_id = -1;
         }
     }
 
@@ -82,17 +82,17 @@ public:
 
       if (mode & std::ios::in)
         file_id = H5Fopen (name, H5F_ACC_RDONLY, H5P_DEFAULT);
       else if (mode & std::ios::out)
         {
           if (mode & std::ios::app && H5Fis_hdf5 (name) > 0)
             file_id = H5Fopen (name, H5F_ACC_RDWR, H5P_DEFAULT);
           else
-            file_id = H5Fcreate (name, H5F_ACC_TRUNC, H5P_DEFAULT, 
+            file_id = H5Fcreate (name, H5F_ACC_TRUNC, H5P_DEFAULT,
                                  H5P_DEFAULT);
         }
       if (file_id < 0)
         std::ios::setstate (std::ios::badbit);
 
       current_item = 0;
     }
 };
@@ -194,17 +194,17 @@ extern OCTINTERP_API bool
 hdf5_get_scalar_attr (hid_t loc_id, hid_t type_id, const char *attr_name,
                       void *buf);
 
 extern OCTINTERP_API herr_t
 hdf5_add_attr (hid_t loc_id, const char *attr_name);
 
 
 extern OCTINTERP_API herr_t
-hdf5_add_scalar_attr (hid_t loc_id, hid_t type_id, 
+hdf5_add_scalar_attr (hid_t loc_id, hid_t type_id,
                       const char *attr_name, void *buf);
 
 #ifdef IDX_TYPE_LONG
 #define H5T_NATIVE_IDX H5T_NATIVE_LONG
 #else
 #define H5T_NATIVE_IDX H5T_NATIVE_INT
 #endif
 
diff --git a/src/ls-mat-ascii.cc b/src/ls-mat-ascii.cc
--- a/src/ls-mat-ascii.cc
+++ b/src/ls-mat-ascii.cc
@@ -144,17 +144,17 @@ get_lines_and_columns (std::istream& is,
           tmp_nc++;
 
           size_t end = buf.find_first_of (", \t", beg);
 
           if (end != std::string::npos)
             {
               beg = buf.find_first_not_of (", \t", end);
 
-              if (beg == std::string::npos || (buf[beg] == '\r' && 
+              if (beg == std::string::npos || (buf[beg] == '\r' &&
                                   beg == buf.length () - 1))
                 {
                   // We had a line with trailing spaces and
                   // ending with a CRLF, so this should look like EOL,
                   // not a new colum.
                   break;
                 }
             }
@@ -355,17 +355,17 @@ save_mat_ascii_data (std::ostream& os, c
 
       if (tabs)
         {
           for (octave_idx_type i = 0; i < m.rows (); i++)
             {
               for (octave_idx_type j = 0; j < m.cols (); j++)
                 {
                   // Omit leading tabs.
-                  if (j != 0) os << '\t'; 
+                  if (j != 0) os << '\t';
                   octave_write_double (os, m (i, j));
                 }
               os << "\n";
             }
         }
       else
         os << m;
 
diff --git a/src/ls-mat4.cc b/src/ls-mat4.cc
--- a/src/ls-mat4.cc
+++ b/src/ls-mat4.cc
@@ -104,17 +104,17 @@ read_mat_binary_data (std::istream& is, 
       break;
 
     default:
       break;
     }
 }
 
 int
-read_mat_file_header (std::istream& is, bool& swap, int32_t& mopt, 
+read_mat_file_header (std::istream& is, bool& swap, int32_t& mopt,
                       int32_t& nr, int32_t& nc,
                       int32_t& imag, int32_t& len,
                       int quiet)
 {
   swap = false;
 
   // We expect to fail here, at the beginning of a record, so not
   // being able to read another mopt value should not result in an
@@ -353,17 +353,17 @@ read_mat_binary_data (std::istream& is, 
             read_mat_binary_data (is, dtmp, prec, nr - 1, swap, flt_fmt);
             read_mat_binary_data (is, ctmp, prec, 1, swap, flt_fmt);
             read_mat_binary_data (is, ctmp, prec, nr - 1, swap, flt_fmt);
 
             for (octave_idx_type i = 0; i < nr - 1; i++)
               data.xelem(i) = Complex (dtmp[i], ctmp[i]);
             read_mat_binary_data (is, ctmp, prec, 1, swap, flt_fmt);
 
-            SparseComplexMatrix smc = SparseComplexMatrix (data, r, c, 
+            SparseComplexMatrix smc = SparseComplexMatrix (data, r, c,
                                                            nr_new, nc_new);
 
             tc = order ? smc.transpose () : smc;
           }
         else
           {
             octave_idx_type nr_new, nc_new;
             Array<double> data (dim_vector (1, nr - 1));
@@ -430,34 +430,34 @@ read_mat_binary_data (std::istream& is, 
       return retval;
     }
 
  data_read_error:
   error ("load: trouble reading binary file `%s'", filename.c_str ());
   return retval;
 }
 
-// Save the data from TC along with the corresponding NAME on stream OS 
+// Save the data from TC along with the corresponding NAME on stream OS
 // in the MatLab version 4 binary format.
 
 bool
 save_mat_binary_data (std::ostream& os, const octave_value& tc,
-                      const std::string& name) 
+                      const std::string& name)
 {
   int32_t mopt = 0;
 
   mopt += tc.is_sparse_type () ? 2 : tc.is_string () ? 1 : 0;
 
   oct_mach_info::float_format flt_fmt =
     oct_mach_info::native_float_format ();;
 
   mopt += 1000 * float_format_to_mopt_digit (flt_fmt);
 
   os.write (reinterpret_cast<char *> (&mopt), 4);
-  
+
   octave_idx_type len;
   int32_t nr = tc.rows ();
 
   int32_t nc = tc.columns ();
 
   if (tc.is_sparse_type ())
     {
       len = tc.nnz ();
@@ -493,24 +493,24 @@ save_mat_binary_data (std::ostream& os, 
   if (tc.is_string ())
     {
       unwind_protect frame;
 
       charMatrix chm = tc.char_matrix_value ();
 
       octave_idx_type nrow = chm.rows ();
       octave_idx_type ncol = chm.cols ();
-        
+
       OCTAVE_LOCAL_BUFFER (double, buf, ncol*nrow);
-        
+
       for (octave_idx_type i = 0; i < nrow; i++)
         {
           std::string tstr = chm.row_as_string (i);
           const char *s = tstr.data ();
-          
+
           for (octave_idx_type j = 0; j < ncol; j++)
             buf[j*nrow+i] = static_cast<double> (*s++ & 0x00FF);
         }
       os.write (reinterpret_cast<char *> (buf), nrow*ncol*sizeof(double));
     }
   else if (tc.is_range ())
     {
       Range r = tc.range_value ();
diff --git a/src/ls-mat4.h b/src/ls-mat4.h
--- a/src/ls-mat4.h
+++ b/src/ls-mat4.h
@@ -25,17 +25,17 @@ along with Octave; see the file COPYING.
 
 extern oct_mach_info::float_format
 mopt_digit_to_float_format (int mach);
 
 extern int
 float_format_to_mopt_digit (oct_mach_info::float_format flt_fmt);
 
 extern int
-read_mat_file_header (std::istream& is, bool& swap, int32_t& mopt, 
+read_mat_file_header (std::istream& is, bool& swap, int32_t& mopt,
                       int32_t& nr, int32_t& nc, int32_t& imag,
                       int32_t& len, int quiet = 0);
 
 extern std::string
 read_mat_binary_data (std::istream& is, const std::string& filename,
                       octave_value& tc);
 
 extern bool
diff --git a/src/ls-mat5.cc b/src/ls-mat5.cc
--- a/src/ls-mat5.cc
+++ b/src/ls-mat5.cc
@@ -120,17 +120,17 @@ enum arrayclasstype
 // each element before copying to DATA.  FLT_FMT specifies the format
 // of the data if we are reading floating point numbers.
 
 static void
 read_mat5_binary_data (std::istream& is, double *data,
                        octave_idx_type  count, bool swap, mat5_data_type type,
                        oct_mach_info::float_format flt_fmt)
 {
-  
+
   switch (type)
     {
     case miINT8:
       read_doubles (is, data, LS_CHAR, count, swap, flt_fmt);
       break;
 
     case miUTF8:
     case miUINT8:
@@ -185,17 +185,17 @@ read_mat5_binary_data (std::istream& is,
     }
 }
 
 static void
 read_mat5_binary_data (std::istream& is, float *data,
                        octave_idx_type  count, bool swap, mat5_data_type type,
                        oct_mach_info::float_format flt_fmt)
 {
-  
+
   switch (type)
     {
     case miINT8:
       read_floats (is, data, LS_CHAR, count, swap, flt_fmt);
       break;
 
     case miUTF8:
     case miUINT8:
@@ -419,18 +419,18 @@ read_mat5_integer_data (std::istream& is
             for (octave_idx_type i = 0; i < n; i++) \
               ctmp(i) = Complex (re(i).double_value (), im(i)); \
   \
             tc = ctmp;  \
           } \
         else \
           tc = re; \
   }
-  
-// Read one element tag from stream IS, 
+
+// Read one element tag from stream IS,
 // place the type code in TYPE and the byte count in BYTES
 // return nonzero on error
 static int
 read_mat5_tag (std::istream& is, bool swap, int32_t& type, int32_t& bytes)
 {
   unsigned int upper;
   int32_t temp;
 
@@ -524,26 +524,26 @@ read_mat5_binary_element (std::istream& 
 
       OCTAVE_LOCAL_BUFFER (char, inbuf, element_length);
       is.read (inbuf, element_length);
 
       // We uncompress the first 8 bytes of the header to get the buffer length
       // This will fail with an error Z_MEM_ERROR
       uLongf destLen = 8;
       OCTAVE_LOCAL_BUFFER (unsigned int, tmp, 2);
-      if (uncompress (reinterpret_cast<Bytef *> (tmp), &destLen, 
+      if (uncompress (reinterpret_cast<Bytef *> (tmp), &destLen,
                       reinterpret_cast<Bytef *> (inbuf), element_length)
           !=  Z_MEM_ERROR)
         {
           // Why should I have to initialize outbuf as I'll just overwrite!!
           if (swap)
             swap_bytes<4> (tmp, 2);
 
           destLen = tmp[1] + 8;
-          std::string outbuf (destLen, ' '); 
+          std::string outbuf (destLen, ' ');
 
           // FIXME -- find a way to avoid casting away const here!
 
           int err = uncompress (reinterpret_cast<Bytef *> (const_cast<char *> (outbuf.c_str ())),
                                 &destLen, reinterpret_cast<Bytef *> (inbuf),
                                 element_length);
 
           if (err != Z_OK)
@@ -585,17 +585,17 @@ read_mat5_binary_element (std::istream& 
                 }
 
               error ("load: error uncompressing data element (%s from zlib)",
                      msg.c_str ());
             }
           else
             {
               std::istringstream gz_is (outbuf);
-              retval = read_mat5_binary_element (gz_is, filename, 
+              retval = read_mat5_binary_element (gz_is, filename,
                                                  swap, global, tc);
             }
         }
       else
         error ("load: error probing size of compressed data element");
 
       return retval;
     }
@@ -631,21 +631,21 @@ read_mat5_binary_element (std::istream& 
 
   imag = (flags & 0x0800) != 0; // has an imaginary part?
 
   global = (flags & 0x0400) != 0; // global variable?
 
   logicalvar = (flags & 0x0200) != 0; // boolean ?
 
   arrayclass = static_cast<arrayclasstype> (flags & 0xff);
-  
+
   int32_t tmp_nzmax;
   read_int (is, swap, tmp_nzmax);   // max number of non-zero in sparse
   nzmax = tmp_nzmax;
-  
+
   // dimensions array subelement
   if (arrayclass != MAT_FILE_WORKSPACE_CLASS)
     {
       int32_t dim_len;
 
       if (read_mat5_tag (is, swap, type, dim_len) || type != miINT32)
         {
           error ("load: invalid dimensions array subelement");
@@ -684,17 +684,17 @@ read_mat5_binary_element (std::istream& 
     // Structure field subelements have zero-length array name subelements.
 
     std::streampos tmp_pos = is.tellg ();
 
     if (len)
       {
         if (! is.read (name, len ))
           goto data_read_error;
-        
+
         is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
       }
 
     name[len] = '\0';
     retval = name;
   }
 
   switch (arrayclass)
@@ -748,17 +748,17 @@ read_mat5_binary_element (std::istream& 
             sm = SparseMatrix (nr, nc, nzmax);
             ridx = sm.ridx ();
             cidx = sm.cidx ();
             data = sm.data ();
           }
 
         // row indices
         std::streampos tmp_pos;
-          
+
         if (read_mat5_tag (is, swap, type, len))
           {
             error ("load: reading sparse row data for `%s'", retval.c_str ());
             goto data_read_error;
           }
 
         tmp_pos = is.tellg ();
 
@@ -819,17 +819,17 @@ read_mat5_binary_element (std::istream& 
           }
 
         is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
 
         // imaginary data subelement
         if (imag)
           {
             NDArray im (dim_vector (static_cast<int> (nnz), 1));
-          
+
             if (read_mat5_tag (is, swap, type, len))
               {
                 error ("load: reading sparse matrix data for `%s'", retval.c_str ());
                 goto data_read_error;
               }
 
             read_mat5_binary_data (is, im.fortran_vec (), nnz, swap,
                                    static_cast<enum mat5_data_type> (type), flt_fmt);
@@ -871,45 +871,45 @@ read_mat5_binary_element (std::istream& 
 
         if (ftype == "simple" || ftype == "scopedfunction")
           {
             if (fpath.length() == 0)
               // We have a builtin function
               tc = make_fcn_handle (fname);
             else
               {
-                std::string mroot = 
+                std::string mroot =
                   m0.contents("matlabroot")(0).string_value();
 
                 if ((fpath.length () >= mroot.length ()) &&
                     fpath.substr(0, mroot.length()) == mroot &&
                     OCTAVE_EXEC_PREFIX != mroot)
                   {
                     // If fpath starts with matlabroot, and matlabroot
                     // doesn't equal octave_config_info ("exec_prefix")
                     // then the function points to a version of Octave
                     // or Matlab other than the running version. In that
                     // case we replace with the same function in the
                     // running version of Octave?
-                    
+
                     // First check if just replacing matlabroot is enough
-                    std::string str = OCTAVE_EXEC_PREFIX + 
-                      fpath.substr (mroot.length ());               
+                    std::string str = OCTAVE_EXEC_PREFIX +
+                      fpath.substr (mroot.length ());
                     file_stat fs (str);
 
                     if (fs.exists ())
                       {
                         size_t xpos
                           = str.find_last_of (file_ops::dir_sep_chars ());
 
                         std::string dir_name = str.substr (0, xpos);
 
                         octave_function *fcn
                           = load_fcn_from_file (str, dir_name, "", fname);
-                    
+
                         if (fcn)
                           {
                             octave_value tmp (fcn);
 
                             tc = octave_value (new octave_fcn_handle (tmp, fname));
                           }
                       }
                     else
@@ -936,17 +936,17 @@ read_mat5_binary_element (std::istream& 
                         if (fcn)
                           {
                             octave_value tmp (fcn);
 
                             tc = octave_value (new octave_fcn_handle (tmp, fname));
                           }
                         else
                           {
-                            warning ("load: can't find the file %s", 
+                            warning ("load: can't find the file %s",
                                      fpath.c_str());
                             goto skip_ahead;
                           }
                       }
                   }
                 else
                   {
                     size_t xpos
@@ -960,17 +960,17 @@ read_mat5_binary_element (std::istream& 
                     if (fcn)
                       {
                         octave_value tmp (fcn);
 
                         tc = octave_value (new octave_fcn_handle (tmp, fname));
                       }
                     else
                       {
-                        warning ("load: can't find the file %s", 
+                        warning ("load: can't find the file %s",
                                  fpath.c_str());
                         goto skip_ahead;
                       }
                   }
               }
           }
         else if (ftype == "nested")
           {
@@ -998,34 +998,34 @@ read_mat5_binary_element (std::istream& 
             symbol_table::set_scope (local_scope);
 
             octave_call_stack::push (local_scope, 0);
             frame.add_fcn (octave_call_stack::pop);
 
             if (m2.nfields() > 0)
               {
                 octave_value tmp;
-      
-                for (Octave_map::iterator p0 = m2.begin() ; 
+
+                for (Octave_map::iterator p0 = m2.begin() ;
                      p0 != m2.end(); p0++)
                   {
                     std::string key = m2.key(p0);
                     octave_value val = m2.contents(p0)(0);
 
                     symbol_table::varref (key, local_scope, 0) = val;
                   }
               }
-            
+
             int parse_status;
-            octave_value anon_fcn_handle = 
+            octave_value anon_fcn_handle =
               eval_string (fname.substr (4), true, parse_status);
 
             if (parse_status == 0)
               {
-                octave_fcn_handle *fh = 
+                octave_fcn_handle *fh =
                   anon_fcn_handle.fcn_handle_value ();
 
                 if (fh)
                   tc = new octave_fcn_handle (fh->fcn_val (), "@<anonymous>");
                 else
                   {
                     error ("load: failed to load anonymous function handle");
                     goto skip_ahead;
@@ -1067,17 +1067,17 @@ read_mat5_binary_element (std::istream& 
 
             std::streampos tmp_pos = is.tellg ();
 
             if (fn_len)
               {
                 if (! is.read (elname, fn_len))
                   goto data_read_error;
 
-                is.seekg (tmp_pos + 
+                is.seekg (tmp_pos +
                           static_cast<std::streamoff> (PAD (fn_len)));
               }
 
             elname[fn_len] = '\0';
 
             field(i) = elname;
           }
 
@@ -1092,17 +1092,17 @@ read_mat5_binary_element (std::istream& 
         for (octave_idx_type j = 0; j < n; j++)
           {
             for (octave_idx_type i = 0; i < n_fields; i++)
               {
                 if (field(i) == "MCOS")
                   {
                     octave_value fieldtc;
                     read_mat5_binary_element (is, filename, swap, global,
-                                              fieldtc); 
+                                              fieldtc);
                     if (! is || error_state)
                       goto data_read_error;
 
                     elt[i](j) = fieldtc;
                   }
                 else
                   elt[i](j) = octave_value ();
               }
@@ -1128,17 +1128,17 @@ read_mat5_binary_element (std::istream& 
           OCTAVE_LOCAL_BUFFER (char, name, len+1);
 
           std::streampos tmp_pos = is.tellg ();
 
           if (len)
             {
               if (! is.read (name, len ))
                 goto data_read_error;
-        
+
               is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
             }
 
           name[len] = '\0';
           classname = name;
         }
       }
       // Fall-through
@@ -1194,17 +1194,17 @@ read_mat5_binary_element (std::istream& 
 
             // fields subelements
             for (octave_idx_type j = 0; j < n; j++)
               {
                 for (octave_idx_type i = 0; i < n_fields; i++)
                   {
                     octave_value fieldtc;
                     read_mat5_binary_element (is, filename, swap, global,
-                                              fieldtc); 
+                                              fieldtc);
                     elt[i](j) = fieldtc;
                   }
               }
 
             for (octave_idx_type i = 0; i < n_fields; i++)
               {
                 const char *key = elname + i*field_name_length;
 
@@ -1213,30 +1213,30 @@ read_mat5_binary_element (std::istream& 
           }
 
         if (isclass)
           {
             if (classname == "inline")
               {
                 // inline is not an object in Octave but rather an
                 // overload of a function handle. Special case.
-                tc =  
+                tc =
                   new octave_fcn_inline (m.contents("expr")(0).string_value(),
                                          m.contents("args")(0).string_value());
               }
             else
               {
                 octave_class* cls = new octave_class (m, classname);
                 cls->reconstruct_exemplar ();
 
                 if (! cls->reconstruct_parents ())
                   warning ("load: unable to reconstruct object inheritance");
 
-                tc = cls; 
-                if (load_path::find_method (classname, "loadobj") != 
+                tc = cls;
+                if (load_path::find_method (classname, "loadobj") !=
                     std::string())
                   {
                     octave_value_list tmp = feval ("loadobj", tc, 1);
 
                     if (! error_state)
                       tc = tmp(0);
                     else
                       goto data_read_error;
@@ -1260,17 +1260,17 @@ read_mat5_binary_element (std::istream& 
         // MAT_FILE_DOUBLE_CLASS, so check if we have a logical
         // variable and convert it.
 
         if (logicalvar)
           {
             uint8NDArray in = tc.uint8_array_value ();
             octave_idx_type nel = in.numel ();
             boolNDArray out (dims);
-            
+
             for (octave_idx_type i = 0; i < nel; i++)
               out (i) = in(i).bool_value ();
 
             tc = out;
           }
       }
       break;
 
@@ -1297,21 +1297,21 @@ read_mat5_binary_element (std::istream& 
     case MAT_FILE_UINT64_CLASS:
       OCTAVE_MAT5_INTEGER_READ (uint64NDArray);
       break;
 
 
     case MAT_FILE_SINGLE_CLASS:
       {
         FloatNDArray re (dims);
-      
+
         // real data subelement
 
         std::streampos tmp_pos;
-          
+
         if (read_mat5_tag (is, swap, type, len))
           {
             error ("load: reading matrix data for `%s'", retval.c_str ());
             goto data_read_error;
           }
 
         octave_idx_type n = re.numel ();
         tmp_pos = is.tellg ();
@@ -1326,17 +1326,17 @@ read_mat5_binary_element (std::istream& 
 
         is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (len)));
 
         if (imag)
           {
             // imaginary data subelement
 
             FloatNDArray im (dims);
-          
+
             if (read_mat5_tag (is, swap, type, len))
               {
                 error ("load: reading matrix data for `%s'", retval.c_str ());
                 goto data_read_error;
               }
 
             n = im.numel ();
             read_mat5_binary_data (is, im.fortran_vec (), n, swap,
@@ -1363,21 +1363,21 @@ read_mat5_binary_element (std::istream& 
 
     case MAT_FILE_CHAR_CLASS:
       // handle as a numerical array to start with
 
     case MAT_FILE_DOUBLE_CLASS:
     default:
       {
         NDArray re (dims);
-      
+
         // real data subelement
 
         std::streampos tmp_pos;
-          
+
         if (read_mat5_tag (is, swap, type, len))
           {
             error ("load: reading matrix data for `%s'", retval.c_str ());
             goto data_read_error;
           }
 
         octave_idx_type n = re.numel ();
         tmp_pos = is.tellg ();
@@ -1394,28 +1394,28 @@ read_mat5_binary_element (std::istream& 
 
         if (logicalvar)
           {
             // Logical variables can either be MAT_FILE_UINT8_CLASS or
             // MAT_FILE_DOUBLE_CLASS, so check if we have a logical
             // variable and convert it.
 
             boolNDArray out (dims);
-            
+
             for (octave_idx_type i = 0; i < n; i++)
               out (i) = static_cast<bool> (re (i));
 
             tc = out;
           }
         else if (imag)
           {
             // imaginary data subelement
 
             NDArray im (dims);
-          
+
             if (read_mat5_tag (is, swap, type, len))
               {
                 error ("load: reading matrix data for `%s'", retval.c_str ());
                 goto data_read_error;
               }
 
             n = im.numel ();
             read_mat5_binary_data (is, im.fortran_vec (), n, swap,
@@ -1463,17 +1463,17 @@ read_mat5_binary_element (std::istream& 
 
                     bool utf8_multi_byte = false;
                     for (octave_idx_type i = 0; i < n; i++)
                       {
                         unsigned char a = static_cast<unsigned char> (re(i));
                         if (a > 0x7f)
                           utf8_multi_byte = true;
                       }
-                    
+
                     if (utf8_multi_byte)
                       {
                         warning ("load: can not read multi-byte encoded UTF8 characters.");
                         warning ("      Replacing unreadable characters with '?'.");
                         for (octave_idx_type i = 0; i < n; i++)
                           {
                             unsigned char a = static_cast<unsigned char> (re(i));
                             if (a > 0x7f)
@@ -1504,17 +1504,17 @@ read_mat5_binary_element (std::istream& 
 
  skip_ahead:
   warning ("skipping over `%s'", retval.c_str ());
   is.seekg (pos + static_cast<std::streamoff> (element_length));
   return read_mat5_binary_element (is, filename, swap, global, tc);
 }
 
 int
-read_mat5_binary_file_header (std::istream& is, bool& swap, bool quiet, 
+read_mat5_binary_file_header (std::istream& is, bool& swap, bool quiet,
                               const std::string& filename)
 {
   int16_t version=0, magic=0;
   uint64_t subsys_offset;
 
   is.seekg (116, std::ios::beg);
   is.read (reinterpret_cast<char *> (&subsys_offset), 8);
 
@@ -1580,17 +1580,17 @@ read_mat5_binary_file_header (std::istre
 
       // Reposition to just after the header
       is.seekg (128, std::ios::beg);
     }
 
   return 0;
 }
 
-static int 
+static int
 write_mat5_tag (std::ostream& is, int type, octave_idx_type bytes)
 {
   int32_t temp;
 
   if (bytes > 0 && bytes <= 4)
     temp = (bytes << 16) + type;
   else
     {
@@ -1619,17 +1619,17 @@ write_mat5_tag (std::ostream& is, int ty
       for (octave_idx_type i = 0; i < count; i++) \
         ptr[i] = static_cast<TYPE> (data[i]); \
       stream.write (reinterpret_cast<char *> (ptr), count * sizeof (TYPE)); \
     } \
   while (0)
 
 // write out the numeric values in M to OS,
 // preceded by the appropriate tag.
-static void 
+static void
 write_mat5_array (std::ostream& os, const NDArray& m, bool save_as_floats)
 {
   save_type st = LS_DOUBLE;
   const double *data = m.data ();
 
   if (save_as_floats)
     {
       if (m.too_large_for_float ())
@@ -1666,33 +1666,33 @@ write_mat5_array (std::ostream& os, cons
   write_mat5_tag (os, mst, len);
 
   {
     switch (st)
       {
       case LS_U_CHAR:
         MAT5_DO_WRITE (uint8_t, data, nel, os);
         break;
-        
+
       case LS_U_SHORT:
         MAT5_DO_WRITE (uint16_t, data, nel, os);
         break;
-        
+
       case LS_U_INT:
         MAT5_DO_WRITE (uint32_t, data, nel, os);
         break;
-        
+
       case LS_U_LONG:
         MAT5_DO_WRITE (uint64_t, data, nel, os);
         break;
 
       case LS_CHAR:
         MAT5_DO_WRITE (int8_t, data, nel, os);
         break;
-        
+
       case LS_SHORT:
         MAT5_DO_WRITE (int16_t, data, nel, os);
         break;
 
       case LS_INT:
         MAT5_DO_WRITE (int32_t, data, nel, os);
         break;
 
@@ -1716,17 +1716,17 @@ write_mat5_array (std::ostream& os, cons
   }
   if (PAD (len) > len)
     {
       static char buf[9]="\x00\x00\x00\x00\x00\x00\x00\x00";
       os.write (buf, PAD (len) - len);
     }
 }
 
-static void 
+static void
 write_mat5_array (std::ostream& os, const FloatNDArray& m, bool)
 {
   save_type st = LS_FLOAT;
   const float *data = m.data ();
 
   float max_val, min_val;
   if (m.all_integers (max_val, min_val))
     st = get_save_type (max_val, min_val);
@@ -1752,33 +1752,33 @@ write_mat5_array (std::ostream& os, cons
   write_mat5_tag (os, mst, len);
 
   {
     switch (st)
       {
       case LS_U_CHAR:
         MAT5_DO_WRITE (uint8_t, data, nel, os);
         break;
-        
+
       case LS_U_SHORT:
         MAT5_DO_WRITE (uint16_t, data, nel, os);
         break;
-        
+
       case LS_U_INT:
         MAT5_DO_WRITE (uint32_t, data, nel, os);
         break;
-        
+
       case LS_U_LONG:
         MAT5_DO_WRITE (uint64_t, data, nel, os);
         break;
 
       case LS_CHAR:
         MAT5_DO_WRITE (int8_t, data, nel, os);
         break;
-        
+
       case LS_SHORT:
         MAT5_DO_WRITE (int16_t, data, nel, os);
         break;
 
       case LS_INT:
         MAT5_DO_WRITE (int32_t, data, nel, os);
         break;
 
@@ -1803,17 +1803,17 @@ write_mat5_array (std::ostream& os, cons
   if (PAD (len) > len)
     {
       static char buf[9]="\x00\x00\x00\x00\x00\x00\x00\x00";
       os.write (buf, PAD (len) - len);
     }
 }
 
 template <class T>
-void 
+void
 write_mat5_integer_data (std::ostream& os, const T *m, int size,
                          octave_idx_type nel)
 {
   mat5_data_type mst;
   unsigned len;
 
   switch (size)
     {
@@ -1888,23 +1888,23 @@ template void
 write_mat5_integer_data (std::ostream& os, const octave_uint32 *m,
                          int size, octave_idx_type nel);
 
 template void
 write_mat5_integer_data (std::ostream& os, const octave_uint64 *m,
                          int size, octave_idx_type nel);
 
 template void
-write_mat5_integer_data (std::ostream& os, const int *m, 
+write_mat5_integer_data (std::ostream& os, const int *m,
                          int size, octave_idx_type nel);
 
 // Write out cell element values in the cell array to OS, preceded by
 // the appropriate tag.
 
-static bool 
+static bool
 write_mat5_cell_array (std::ostream& os, const Cell& cell,
                        bool mark_as_global, bool save_as_floats)
 {
   octave_idx_type nel = cell.numel ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       octave_value ov = cell(i);
@@ -2086,29 +2086,29 @@ save_mat5_array_length (const FloatCompl
     tmp[i] = std::imag (val[i]);
 
   ret += save_mat5_array_length (tmp, nel, save_as_floats);
 
   return ret;
 }
 
 int
-save_mat5_element_length (const octave_value& tc, const std::string& name, 
+save_mat5_element_length (const octave_value& tc, const std::string& name,
                           bool save_as_floats, bool mat7_format)
 {
   size_t max_namelen = (mat7_format ? 63 : 31);
   size_t len = name.length ();
   std::string cname = tc.class_name ();
   int ret = 32;
 
   if (len > 4)
     ret += PAD (len > max_namelen ? max_namelen : len);
 
   ret += PAD (4 * tc.ndims ());
-  
+
   if (tc.is_string ())
     {
       charNDArray chm = tc.char_array_value ();
       ret += 8;
       if (chm.numel () > 2)
         ret += PAD (2 * chm.numel ());
     }
   else if (tc.is_sparse_type ())
@@ -2181,35 +2181,35 @@ save_mat5_element_length (const octave_v
         }
     }
   else if (tc.is_cell ())
     {
       Cell cell = tc.cell_value ();
       octave_idx_type nel = cell.numel ();
 
       for (int i = 0; i < nel; i++)
-        ret += 8 + 
+        ret += 8 +
           save_mat5_element_length (cell (i), "", save_as_floats, mat7_format);
     }
-  else if (tc.is_complex_scalar () || tc.is_complex_matrix ()) 
+  else if (tc.is_complex_scalar () || tc.is_complex_matrix ())
     {
       if (tc.is_single_type ())
         {
           const FloatComplexNDArray m = tc.float_complex_array_value ();
           ret += save_mat5_array_length (m.fortran_vec (), m.numel (),
                                          save_as_floats);
         }
       else
-        {      
+        {
           const ComplexNDArray m = tc.complex_array_value ();
           ret += save_mat5_array_length (m.fortran_vec (), m.numel (),
                                          save_as_floats);
         }
     }
-  else if (tc.is_map () || tc.is_inline_function () || tc.is_object ()) 
+  else if (tc.is_map () || tc.is_inline_function () || tc.is_object ())
     {
       int fieldcnt = 0;
       const Octave_map m = tc.map_value ();
       octave_idx_type nel = m.numel ();
 
       if (tc.is_inline_function ())
         // length of "inline" is 6
         ret += 8 + PAD (6 > max_namelen ? max_namelen : 6);
@@ -2228,17 +2228,17 @@ save_mat5_element_length (const octave_v
 
       for (octave_idx_type j = 0; j < nel; j++)
         {
 
           for (Octave_map::const_iterator i = m.begin (); i != m.end (); i++)
             {
               const Cell elts = m.contents (i);
 
-              ret += 8 + save_mat5_element_length (elts(j), "", 
+              ret += 8 + save_mat5_element_length (elts(j), "",
                                                save_as_floats, mat7_format);
             }
         }
     }
   else
     ret = -1;
 
   return ret;
@@ -2268,17 +2268,17 @@ gripe_dim_too_large (const std::string& 
 
 // save the data from TC along with the corresponding NAME on stream
 // OS in the MatLab version 5 binary format.  Return true on success.
 
 bool
 save_mat5_binary_element (std::ostream& os,
                           const octave_value& tc, const std::string& name,
                           bool mark_as_global, bool mat7_format,
-                          bool save_as_floats, bool compressing) 
+                          bool save_as_floats, bool compressing)
 {
   int32_t flags = 0;
   int32_t nnz_32 = 0;
   std::string cname = tc.class_name ();
   size_t max_namelen = (mat7_format ? 63 : 31);
 
   dim_vector dv = tc.dims ();
   int nd = tc.ndims ();
@@ -2336,45 +2336,45 @@ save_mat5_binary_element (std::ostream& 
 
       // The code seeks backwards in the stream to fix the header. Can't
       // do this with zlib, so use a stringstream.
       ret = save_mat5_binary_element (buf, tc, name, mark_as_global, true,
                                       save_as_floats, true);
 
       if (ret)
         {
-          // destLen must be at least 0.1% larger than source buffer 
+          // destLen must be at least 0.1% larger than source buffer
           // + 12 bytes. Reality is it must be larger again than that.
           std::string buf_str = buf.str ();
           uLongf srcLen = buf_str.length ();
-          uLongf destLen = srcLen * 101 / 100 + 12; 
+          uLongf destLen = srcLen * 101 / 100 + 12;
           OCTAVE_LOCAL_BUFFER (char, out_buf, destLen);
 
-          if (compress (reinterpret_cast<Bytef *> (out_buf), &destLen, 
+          if (compress (reinterpret_cast<Bytef *> (out_buf), &destLen,
                         reinterpret_cast<const Bytef *> (buf_str.c_str ()), srcLen) == Z_OK)
             {
               write_mat5_tag (os, miCOMPRESSED,
-                              static_cast<octave_idx_type> (destLen)); 
+                              static_cast<octave_idx_type> (destLen));
 
               os.write (out_buf, destLen);
             }
           else
             {
               error ("save: error compressing data element");
               ret = false;
             }
         }
 
       return ret;
     }
 #endif
 
-  write_mat5_tag (os, miMATRIX, save_mat5_element_length 
+  write_mat5_tag (os, miMATRIX, save_mat5_element_length
                   (tc, name, save_as_floats, mat7_format));
-  
+
   // array flags subelement
   write_mat5_tag (os, miUINT32, 8);
 
   if (tc.is_bool_type ())
     flags |= 0x0200;
 
   if (mark_as_global)
     flags |= 0x0400;
@@ -2405,17 +2405,17 @@ save_mat5_binary_element (std::ostream& 
   else if (tc.is_real_scalar () || tc.is_real_matrix () || tc.is_range ()
            || tc.is_complex_scalar () || tc.is_complex_matrix ())
     {
       if (tc.is_single_type ())
         flags |= MAT_FILE_SINGLE_CLASS;
       else
         flags |= MAT_FILE_DOUBLE_CLASS;
     }
-  else if (tc.is_map ()) 
+  else if (tc.is_map ())
     flags |= MAT_FILE_STRUCT_CLASS;
   else if (tc.is_cell ())
     flags |= MAT_FILE_CELL_CLASS;
   else if (tc.is_inline_function () || tc.is_object ())
     flags |= MAT_FILE_OBJECT_CLASS;
   else
     {
       gripe_wrong_type_arg ("save", tc, false);
@@ -2467,17 +2467,17 @@ save_mat5_binary_element (std::ostream& 
       write_mat5_tag (os, miUINT16, len);
 
       const char *s = chm.data ();
 
       for (octave_idx_type i = 0; i < nel; i++)
         buf[i] = *s++ & 0x00FF;
 
       os.write (reinterpret_cast<char *> (buf), len);
-      
+
       if (paddedlength > len)
         {
           static char padbuf[9]="\x00\x00\x00\x00\x00\x00\x00\x00";
           os.write (padbuf, paddedlength - len);
         }
     }
   else if (tc.is_sparse_type ())
     {
@@ -2592,34 +2592,34 @@ save_mat5_binary_element (std::ostream& 
     }
   else if (tc.is_cell ())
     {
       Cell cell = tc.cell_value ();
 
       if (! write_mat5_cell_array (os, cell, mark_as_global, save_as_floats))
         goto error_cleanup;
     }
-  else if (tc.is_complex_scalar () || tc.is_complex_matrix ()) 
+  else if (tc.is_complex_scalar () || tc.is_complex_matrix ())
     {
       if (tc.is_single_type ())
         {
           FloatComplexNDArray m_cmplx = tc.float_complex_array_value ();
 
           write_mat5_array (os, ::real (m_cmplx), save_as_floats);
           write_mat5_array (os, ::imag (m_cmplx), save_as_floats);
         }
       else
         {
           ComplexNDArray m_cmplx = tc.complex_array_value ();
 
           write_mat5_array (os, ::real (m_cmplx), save_as_floats);
           write_mat5_array (os, ::imag (m_cmplx), save_as_floats);
         }
     }
-  else if (tc.is_map () || tc.is_inline_function() || tc.is_object ()) 
+  else if (tc.is_map () || tc.is_inline_function() || tc.is_object ())
     {
       if (tc.is_inline_function () || tc.is_object ())
         {
           std::string classname = tc.is_object() ? tc.class_name () : "inline";
           size_t namelen = classname.length ();
 
           if (namelen > max_namelen)
             namelen = max_namelen; // only 31 or 63 char names permitted
@@ -2687,17 +2687,17 @@ save_mat5_binary_element (std::ostream& 
             // write the data of each element
 
             // Iterating over the list of keys will preserve the order
             // of the fields.
             for (octave_idx_type i = 0; i < nf; i++)
               {
                 bool retval2 = save_mat5_binary_element (os, elts[i][j], "",
                                                          mark_as_global,
-                                                         false, 
+                                                         false,
                                                          save_as_floats);
                 if (! retval2)
                   goto error_cleanup;
               }
           }
       }
     }
   else
diff --git a/src/ls-oct-ascii.cc b/src/ls-oct-ascii.cc
--- a/src/ls-oct-ascii.cc
+++ b/src/ls-oct-ascii.cc
@@ -86,17 +86,17 @@ extract_keyword (std::istream& is, const
     return retval;
 
   char c;
   while (is.get (c))
     {
       if (c == '%' || c == '#')
         {
           std::ostringstream buf;
-        
+
           while (is.get (c) && (c == ' ' || c == '\t' || c == '%' || c == '#'))
             ; // Skip whitespace and comment characters.
 
           if (isalpha (c))
             buf << c;
 
           while (is.get (c) && isalpha (c))
             buf << c;
@@ -295,17 +295,17 @@ read_ascii_data (std::istream& is, const
     }
 
   return name;
 }
 
 // Save the data from TC along with the corresponding NAME, and global
 // flag MARK_AS_GLOBAL on stream OS in the plain text format described
 // above for load_ascii_data.  If NAME is empty, the name: line is not
-// generated.  PRECISION specifies the number of decimal digits to print. 
+// generated.  PRECISION specifies the number of decimal digits to print.
 //
 // Assumes ranges and strings cannot contain Inf or NaN values.
 //
 // Returns 1 for success and 0 for failure.
 
 // FIXME -- should probably write the help string here too.
 
 bool
diff --git a/src/ls-oct-ascii.h b/src/ls-oct-ascii.h
--- a/src/ls-oct-ascii.h
+++ b/src/ls-oct-ascii.h
@@ -37,17 +37,17 @@ along with Octave; see the file COPYING.
 
 // Used when converting Inf to something that gnuplot can read.
 
 #ifndef OCT_RBV
 #define OCT_RBV DBL_MAX / 100.0
 #endif
 
 extern OCTINTERP_API std::string
-extract_keyword (std::istream& is, const char *keyword, 
+extract_keyword (std::istream& is, const char *keyword,
                  const bool next_only = false);
 
 extern OCTINTERP_API std::string
 read_ascii_data (std::istream& is, const std::string& filename, bool& global,
                  octave_value& tc, octave_idx_type count);
 
 extern OCTINTERP_API bool
 save_ascii_data (std::ostream& os, const octave_value& val_arg,
@@ -65,17 +65,17 @@ save_three_d (std::ostream& os, const oc
 // returning TRUE if successful and FALSE otherwise.
 //
 // Input should look something like:
 //
 //  [%#][ \t]*keyword[ \t]*int-value.*\n
 
 template <class T>
 bool
-extract_keyword (std::istream& is, const char *keyword, T& value, 
+extract_keyword (std::istream& is, const char *keyword, T& value,
                  const bool next_only = false)
 {
   bool status = false;
   value = T();
 
   char c;
   while (is.get (c))
     {
@@ -112,17 +112,17 @@ extract_keyword (std::istream& is, const
             break;
         }
     }
   return status;
 }
 
 template <class T>
 bool
-extract_keyword (std::istream& is, const std::string& kw, T& value, 
+extract_keyword (std::istream& is, const std::string& kw, T& value,
                  const bool next_only = false)
 {
   return extract_keyword (is, kw.c_str (), value, next_only);
 }
 
 // Match one of the elements in KEYWORDS on stream IS, placing the
 // matched keyword in KW and the associated value in VALUE,
 // returning TRUE if successful and FALSE otherwise.
diff --git a/src/ls-oct-binary.cc b/src/ls-oct-binary.cc
--- a/src/ls-oct-binary.cc
+++ b/src/ls-oct-binary.cc
@@ -75,17 +75,17 @@ along with Octave; see the file COPYING.
 //
 // Header (one per file):
 // =====================
 //
 //   object               type            bytes
 //   ------               ----            -----
 //   magic number         string             10
 //
-//   float format         integer             1  
+//   float format         integer             1
 //
 //
 // Data (one set for each item):
 // ============================
 //
 //   object               type            bytes
 //   ------               ----            -----
 //   name_length          integer             4
@@ -247,34 +247,34 @@ read_binary_data (std::istream& is, bool
         std::string typ = s;
         tc = octave_value_typeinfo::lookup_type (typ);
       }
       break;
     default:
       goto data_read_error;
       break;
     }
-  
+
   if (!tc.load_binary (is, swap, fmt))
     {
     data_read_error:
       error ("load: trouble reading binary file `%s'", filename.c_str ());
     }
 
   return retval;
 }
 
 // Save the data from TC along with the corresponding NAME, help
 // string DOC, and global flag MARK_AS_GLOBAL on stream OS in the
 // binary format described above for read_binary_data.
 
 bool
 save_binary_data (std::ostream& os, const octave_value& tc,
                   const std::string& name, const std::string& doc,
-                  bool mark_as_global, bool save_as_floats) 
+                  bool mark_as_global, bool save_as_floats)
 {
   int32_t name_len = name.length ();
 
   os.write (reinterpret_cast<char *> (&name_len), 4);
   os << name;
 
   int32_t doc_len = doc.length ();
 
@@ -291,17 +291,17 @@ save_binary_data (std::ostream& os, cons
   os.write (reinterpret_cast<char *> (&tmp), 1);
 
   // Write the string corresponding to the octave_value type
   std::string typ = tc.type_name ();
   int32_t len = typ.length ();
   os.write (reinterpret_cast<char *> (&len), 4);
   const char *btmp = typ.data ();
   os.write (btmp, len);
-      
+
   // The octave_value of tc is const. Make a copy...
   octave_value val = tc;
 
   // Call specific save function
   bool success = val.save_binary (os, save_as_floats);
 
   return (os && success);
 }
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -407,17 +407,17 @@ ceil ([-2.7, 2.7])\n\
   return retval;
 }
 
 /*
 
 %% double precision
 %!assert(ceil ([2, 1.1, -1.1, -1]), [2, 2, -1, -1]);
 
-%% compelx double precison 
+%% compelx double precison
 %!assert(ceil ([2+2i, 1.1+1.1i, -1.1-1.1i, -1-i]), [2+2i, 2+2i, -1-i, -1-i]);
 
 %% single precision
 %!assert(ceil (single([2, 1.1, -1.1, -1])), single([2, 2, -1, -1]));
 
 %% compelx single preci
 %!assert(ceil (single ([2+2i, 1.1+1.1i, -1.1-1.1i, -1-i])), single([2+2i, 2+2i, -1-i, -1-i]));
 
@@ -1801,17 +1801,17 @@ tolower (\"MiXeD cAsE 123\")\n\
     print_usage ();
 
   return retval;
 }
 
 DEFALIAS (lower, tolower);
 
 /*
- 
+
 %!error <Invalid call to tolower.*> tolower();
 %!error <Invalid call to tolower.*> lower();
 %!assert(tolower("OCTAVE"), "octave");
 %!assert(tolower("123OCTave!_&"), "123octave!_&");
 %!assert(tolower({"ABC", "DEF", {"GHI", {"JKL"}}}), {"abc", "def", {"ghi", {"jkl"}}});
 %!assert(tolower(["ABC"; "DEF"]), ["abc"; "def"]);
 %!assert(tolower({["ABC"; "DEF"]}), {["abc";"def"]});
 %!assert(tolower(68), "d");
@@ -1847,17 +1847,17 @@ toupper (\"MiXeD cAsE 123\")\n\
     print_usage ();
 
   return retval;
 }
 
 DEFALIAS (upper, toupper);
 
 /*
- 
+
 %!error <Invalid call to toupper.*> toupper();
 %!error <Invalid call to toupper.*> upper();
 %!assert(toupper("octave"), "OCTAVE");
 %!assert(toupper("123OCTave!_&"), "123OCTAVE!_&");
 %!assert(toupper({"abc", "def", {"ghi", {"jkl"}}}), {"ABC", "DEF", {"GHI", {"JKL"}}});
 %!assert(toupper(["abc"; "def"]), ["ABC"; "DEF"]);
 %!assert(toupper({["abc"; "def"]}), {["ABC";"DEF"]});
 %!assert(toupper(100), "D");
diff --git a/src/mex.cc b/src/mex.cc
--- a/src/mex.cc
+++ b/src/mex.cc
@@ -379,17 +379,17 @@ public:
 
   int is_logical_scalar_true (void) const
   {
     return (is_logical_scalar () && val.is_true ());
   }
 
   mwSize get_m (void) const { return val.rows (); }
 
-  mwSize get_n (void) const 
+  mwSize get_n (void) const
   {
     mwSize n = 1;
 
     // Force dims and ndims to be cached.
     get_dimensions();
 
     for (mwIndex i = ndims - 1; i > 0; i--)
       n *= dims[i];
@@ -665,17 +665,17 @@ public:
       case mxINT16_CLASS: return 2;
       case mxUINT16_CLASS: return 2;
       case mxINT32_CLASS: return 4;
       case mxUINT32_CLASS: return 4;
       case mxINT64_CLASS: return 8;
       case mxUINT64_CLASS: return 8;
       case mxFUNCTION_CLASS: return 0;
       default: return 0;
-      }    
+      }
   }
 
   bool mutation_needed (void) const { return mutate_flag; }
 
   void request_mutation (void) const
   {
     if (mutate_flag)
       panic_impossible ();
@@ -1045,17 +1045,17 @@ public:
       case mxINT16_CLASS: return 2;
       case mxUINT16_CLASS: return 2;
       case mxINT32_CLASS: return 4;
       case mxUINT32_CLASS: return 4;
       case mxINT64_CLASS: return 8;
       case mxUINT64_CLASS: return 8;
       case mxFUNCTION_CLASS: return 0;
       default: return 0;
-      }    
+      }
   }
 
 protected:
 
   mxArray_matlab (const mxArray_matlab& val)
     : mxArray_base (val), class_name (strsave (val.class_name)),
       id (val.id), ndims (val.ndims),
       dims (static_cast<mwSize *> (malloc (ndims * sizeof (mwSize))))
@@ -1151,33 +1151,33 @@ public:
 
   // FIXME??
   mxArray_number (mwSize m, const char **str)
     : mxArray_matlab (mxCHAR_CLASS, m, max_str_len (m, str)),
       pr (calloc (get_number_of_elements (), get_element_size ())),
       pi (0)
   {
     mxChar *cpr = static_cast<mxChar *> (pr);
-    
+
     mwSize *dv = get_dimensions ();
 
     mwSize nc = dv[1];
 
     for (mwIndex j = 0; j < m; j++)
       {
         const char *ptr = str[j];
 
         size_t tmp_len = strlen (ptr);
 
         for (size_t i = 0; i < tmp_len; i++)
           cpr[m*i+j] = static_cast<mxChar> (ptr[i]);
 
         for (size_t i = tmp_len; i < nc; i++)
           cpr[m*i+j] = static_cast<mxChar> (' ');
-      } 
+      }
   }
 
   mxArray_number *dup (void) const { return new mxArray_number (*this); }
 
   ~mxArray_number (void)
   {
     mxFree (pr);
     mxFree (pi);
@@ -1448,17 +1448,17 @@ protected:
         break;
 
       case mxUINT64_CLASS:
         retval = int_to_ov<uint64_t, uint64NDArray, octave_uint64> (dv);
         break;
 
       default:
         panic_impossible ();
-      }    
+      }
 
     return retval;
   }
 
   mxArray_number (const mxArray_number& val)
     : mxArray_matlab (val),
       pr (malloc (get_number_of_elements () * get_element_size ())),
       pi (val.pi ? malloc (get_number_of_elements () * get_element_size ()) : 0)
@@ -2167,27 +2167,27 @@ public:
   // "unmarked" version of this.
   void *realloc (void *ptr, size_t n)
   {
     void *v;
 
     if (ptr)
       {
         v = gnulib::realloc (ptr, n);
-        
+
         std::set<void *>::iterator p = memlist.find (ptr);
-        
+
         if (v && p != memlist.end ())
           {
             memlist.erase (p);
             memlist.insert (v);
           }
-        
+
         p = global_memlist.find (ptr);
-        
+
         if (v && p != global_memlist.end ())
           {
             global_memlist.erase (p);
             global_memlist.insert (v);
           }
       }
     else
       v = malloc (n);
@@ -2506,17 +2506,17 @@ mxFree (void *ptr)
     xfree (ptr);
 }
 
 static inline mxArray *
 maybe_mark_array (mxArray *ptr)
 {
   return mex_context ? mex_context->mark_array (ptr) : ptr;
 }
-  
+
 // Constructors.
 mxArray *
 mxCreateCellArray (mwSize ndims, const mwSize *dims)
 {
   return maybe_mark_array (new mxArray (ndims, dims));
 }
 
 mxArray *
@@ -2816,17 +2816,17 @@ mxSetN (mxArray *ptr, mwSize n)
 
 void
 mxSetDimensions (mxArray *ptr, const mwSize *dims, mwSize ndims)
 {
   ptr->set_dimensions (static_cast<mwSize *> (
                          maybe_unmark (const_cast<mwSize *> (dims))),
                        ndims);
 }
-  
+
 // Data extractors.
 double *
 mxGetPr (const mxArray *ptr)
 {
   return static_cast<double *> (ptr->get_data ());
 }
 
 double *
@@ -3022,17 +3022,17 @@ mxGetString (const mxArray *ptr, char *b
   return ptr->get_string (buf, buflen);
 }
 
 char *
 mxArrayToString (const mxArray *ptr)
 {
   return ptr->array_to_string ();
 }
-  
+
 mwIndex
 mxCalcSingleSubscript (const mxArray *ptr, mwSize nsubs, mwIndex *subs)
 {
   return ptr->calc_single_subscript (nsubs, subs);
 }
 
 size_t
 mxGetElementSize (const mxArray *ptr)
@@ -3455,17 +3455,17 @@ mexLock (void)
 
       mlock ();
     }
 }
 
 int
 mexSet (double handle, const char *property, mxArray *val)
 {
-  bool ret = 
+  bool ret =
     set_property_in_handle (handle, property, mxArray::as_octave_value (val),
                             "mexSet");
   return (ret ? 0 : 1);
 }
 
 void
 mexUnlock (void)
 {
diff --git a/src/mex.h b/src/mex.h
--- a/src/mex.h
+++ b/src/mex.h
@@ -68,37 +68,37 @@ typedef int bool;
 extern "C" {
 #endif
 
 #if defined (V4)
 void mexFunction (int nlhs, mxArray* plhs[], int nrhs, mxArray *prhs[]);
 #else
 void mexFunction (int nlhs, mxArray* plhs[], int nrhs, const mxArray *prhs[]);
 #endif
-  
+
 #include "mexproto.h"
 
 /* V4 floating point routines renamed in V5.  */
 #define mexIsNaN mxIsNaN
 #define mexIsFinite mxIsFinite
 #define mexIsInf mxIsInf
 #define mexGetEps mxGetEps
 #define mexGetInf mxGetInf
 #define mexGetNaN mxGetNan
-  
+
 #define mexGetGlobal(nm) mexGetArray (nm, "global")
 #define mexGetMatrix(nm) mexGetArray (nm, "caller")
 #define mexGetMatrixPtr(nm) mexGetArrayPtr (nm, "caller")
 
 #define mexGetArray(nm, space) mexGetVariable (space, nm)
 #define mexGetArrayPtr(nm, space) mexGetVariablePtr (space, nm)
 
 #define mexPutMatrix(ptr) mexPutVariable ("caller", "", ptr)
 #define mexPutArray(ptr, space) mexPutVariable (space, "", ptr)
-  
+
 #define mxCreateFull mxCreateDoubleMatrix
 
 #define mxCreateScalarDouble mxCreateDoubleScalar
 
 #define mxFreeMatrix mxDestroyArray
 
 #define mxIsString mxIsChar
 
diff --git a/src/mexproto.h b/src/mexproto.h
--- a/src/mexproto.h
+++ b/src/mexproto.h
@@ -78,17 +78,17 @@ extern OCTINTERP_API int mexCallMATLAB (
 
 extern OCTINTERP_API void mexSetTrapFlag (int flag);
 extern OCTINTERP_API int mexEvalString (const char *s);
 extern OCTINTERP_API void mexErrMsgTxt (const char *s);
 extern OCTINTERP_API void mexErrMsgIdAndTxt (const char *id, const char *s, ...);
 extern OCTINTERP_API void mexWarnMsgTxt (const char *s);
 extern OCTINTERP_API void mexWarnMsgIdAndTxt (const char *id, const char *s, ...);
 extern OCTINTERP_API int mexPrintf (const char *fmt, ...);
-  
+
 extern OCTINTERP_API mxArray *mexGetVariable (const char *space, const char *name);
 extern OCTINTERP_API const mxArray *mexGetVariablePtr (const char *space, const char *name);
 
 extern OCTINTERP_API int mexPutVariable (const char *space, const char *name, mxArray *ptr);
 
 extern OCTINTERP_API void mexMakeArrayPersistent (mxArray *ptr);
 extern OCTINTERP_API void mexMakeMemoryPersistent (void *ptr);
 
@@ -104,23 +104,23 @@ extern OCTINTERP_API void mexUnlock (voi
 extern OCTINTERP_API int mxIsFinite (double v);
 extern OCTINTERP_API int mxIsInf (double v);
 extern OCTINTERP_API int mxIsNaN (double v);
 
 /* Floating point values.  */
 extern OCTINTERP_API double mxGetEps (void);
 extern OCTINTERP_API double mxGetInf (void);
 extern OCTINTERP_API double mxGetNaN (void);
-  
+
 /* Memory management.  */
 extern OCTINTERP_API void *mxCalloc (size_t n, size_t size);
 extern OCTINTERP_API void *mxMalloc (size_t n);
 extern OCTINTERP_API void *mxRealloc (void *ptr, size_t size);
 extern OCTINTERP_API void mxFree (void *ptr);
-  
+
 /* Constructors.  */
 extern OCTINTERP_API mxArray *mxCreateCellArray (mwSize ndims, const mwSize *dims);
 extern OCTINTERP_API mxArray *mxCreateCellMatrix (mwSize m, mwSize n);
 extern OCTINTERP_API mxArray *mxCreateCharArray (mwSize ndims, const mwSize *dims);
 extern OCTINTERP_API mxArray *mxCreateCharMatrixFromStrings (mwSize m, const char **str);
 extern OCTINTERP_API mxArray *mxCreateDoubleMatrix (mwSize nr, mwSize nc, mxComplexity flag);
 extern OCTINTERP_API mxArray *mxCreateDoubleScalar (double val);
 extern OCTINTERP_API mxArray *mxCreateLogicalArray (mwSize ndims, const mwSize *dims);
@@ -179,17 +179,17 @@ extern OCTINTERP_API size_t mxGetN (cons
 extern OCTINTERP_API mwSize *mxGetDimensions (const mxArray *ptr);
 extern OCTINTERP_API mwSize mxGetNumberOfDimensions (const mxArray *ptr);
 extern OCTINTERP_API size_t mxGetNumberOfElements (const mxArray *ptr);
 
 /* Dimension setters.  */
 extern OCTINTERP_API void mxSetM (mxArray *ptr, mwSize M);
 extern OCTINTERP_API void mxSetN (mxArray *ptr, mwSize N);
 extern OCTINTERP_API void mxSetDimensions (mxArray *ptr, const mwSize *dims, mwSize ndims);
-  
+
 /* Data extractors.  */
 extern OCTINTERP_API double *mxGetPi (const mxArray *ptr);
 extern OCTINTERP_API double *mxGetPr (const mxArray *ptr);
 extern OCTINTERP_API double mxGetScalar (const mxArray *ptr);
 extern OCTINTERP_API mxChar *mxGetChars (const mxArray *ptr);
 extern OCTINTERP_API mxLogical *mxGetLogicals (const mxArray *ptr);
 extern OCTINTERP_API void *mxGetData (const mxArray *ptr);
 extern OCTINTERP_API void *mxGetImagData (const mxArray *ptr);
@@ -233,17 +233,17 @@ extern OCTINTERP_API void mxSetFieldByNu
 
 extern OCTINTERP_API int mxGetNumberOfFields (const mxArray *ptr);
 
 extern OCTINTERP_API const char *mxGetFieldNameByNumber (const mxArray *ptr, int key_num);
 extern OCTINTERP_API int mxGetFieldNumber (const mxArray *ptr, const char *key);
 
 extern OCTINTERP_API int mxGetString (const mxArray *ptr, char *buf, mwSize buflen);
 extern OCTINTERP_API char *mxArrayToString (const mxArray *ptr);
-  
+
 /* Miscellaneous.  */
 #ifdef NDEBUG
 #define mxAssert(expr, msg) \
   do \
     { \
       if (! expr) \
         { \
           mexPrintf ("Assertion failed: %s, at line %d of file \"%s\".\n%s\n", \
diff --git a/src/mxarray.h.in b/src/mxarray.h.in
--- a/src/mxarray.h.in
+++ b/src/mxarray.h.in
@@ -75,17 +75,17 @@ typedef enum
   }
   mxClassID;
 
 typedef unsigned char mxLogical;
 
 /* typedef Uint16 mxChar; */
 typedef char mxChar;
 
-/* 
+/*
  * FIXME? Mathworks says these should be size_t on 64-bit system and when
  * mex is used with the -largearraydims flag, but why do that? Its better
  * to conform to the same indexing as the rest of Octave
  */
 typedef %OCTAVE_IDX_TYPE% mwSize;
 typedef %OCTAVE_IDX_TYPE% mwIndex;
 
 #if ! defined (MXARRAY_TYPEDEFS_ONLY)
diff --git a/src/oct-hist.cc b/src/oct-hist.cc
--- a/src/oct-hist.cc
+++ b/src/oct-hist.cc
@@ -148,17 +148,17 @@ static std::string Vhistory_timestamp_fo
 
 // TRUE if we are saving history.
 bool Vsaving_history = true;
 
 // Display, save, or load history.  Stolen and modified from bash.
 //
 // Arg of -w FILENAME means write file, arg of -r FILENAME
 // means read file, arg of -q means don't number lines.  Arg of N
-// means only display that many items. 
+// means only display that many items.
 
 static void
 do_history (int argc, const string_vector& argv)
 {
   int numbered_output = 1;
 
   int i;
   for (i = 1; i < argc; i++)
@@ -323,28 +323,28 @@ edit_history_repl_hist (const std::strin
 static void
 edit_history_add_hist (const std::string& line)
 {
   if (! line.empty ())
     {
       std::string tmp = line;
 
       int len = tmp.length ();
-        
+
       if (len > 0 && tmp[len-1] == '\n')
         tmp.resize (len - 1);
 
       if (! tmp.empty ())
         command_history::add (tmp);
     }
 }
 
 static std::string
 mk_tmp_hist_file (int argc, const string_vector& argv,
-                  int insert_curr, const char *warn_for) 
+                  int insert_curr, const char *warn_for)
 {
   std::string retval;
 
   string_vector hlist = command_history::list ();
 
   int hist_count = hlist.length ();
 
   // The current command line is already part of the history list by
diff --git a/src/oct-lvalue.cc b/src/oct-lvalue.cc
--- a/src/oct-lvalue.cc
+++ b/src/oct-lvalue.cc
@@ -80,15 +80,15 @@ octave_lvalue::value (void)
       else
         {
           if (val->is_constant ())
             retval = val->subsref (type, idx);
           else
             {
               octave_value_list t = val->subsref (type, idx, 1);
               if (t.length () > 0)
-                retval = t(0);        
+                retval = t(0);
             }
         }
     }
 
   return retval;
 }
diff --git a/src/oct-lvalue.h b/src/oct-lvalue.h
--- a/src/oct-lvalue.h
+++ b/src/oct-lvalue.h
@@ -32,22 +32,22 @@ class octave_value_list;
 #include "pt-idx.h"
 
 class
 octave_lvalue
 {
 public:
 
   octave_lvalue (octave_value *v = 0)
-    : val (v), type (), idx (), nel (1) 
+    : val (v), type (), idx (), nel (1)
     { }
 
   octave_lvalue (const octave_lvalue& vr)
-    : val (vr.val), type (vr.type), idx (vr.idx), nel (vr.nel) 
-    { 
+    : val (vr.val), type (vr.type), idx (vr.idx), nel (vr.nel)
+    {
     }
 
   octave_lvalue& operator = (const octave_lvalue& vr)
     {
       if (this != &vr)
         {
           val = vr.val;
           type = vr.type;
@@ -63,20 +63,20 @@ public:
   bool is_black_hole (void) const { return val == 0; }
 
   bool is_defined (void) const { return val && val->is_defined (); }
 
   bool is_undefined (void) const { return ! val || val->is_undefined (); }
 
   bool is_map (void) const { return val && val->is_map (); }
 
-  void define (const octave_value& v) 
-    { 
+  void define (const octave_value& v)
+    {
       if (val)
-        *val = v; 
+        *val = v;
     }
 
   void assign (octave_value::assign_op, const octave_value&);
 
   void numel (octave_idx_type n) { nel = n; }
 
   octave_idx_type numel (void) const { return nel; }
 
diff --git a/src/oct-map.cc b/src/oct-map.cc
--- a/src/oct-map.cc
+++ b/src/oct-map.cc
@@ -90,33 +90,33 @@ octave_fields::rmfield (const std::strin
           if (q->second >= n)
             q->second--;
         }
 
       return n;
     }
 }
 
-void 
+void
 octave_fields::orderfields (Array<octave_idx_type>& perm)
 {
   octave_idx_type n = rep->size ();
   perm.clear (n, 1);
 
   make_unique ();
   octave_idx_type i = 0;
   for (fields_rep::iterator q = rep->begin (); q != rep->end (); q++)
     {
       octave_idx_type j = q->second;
       q->second = i;
       perm(i++) = j;
     }
 }
 
-bool 
+bool
 octave_fields::equal_up_to_order (const octave_fields& other,
                                   octave_idx_type* perm) const
 {
   bool retval = true;
 
   iterator p = begin (), q = other.begin ();
   for (; p != end () && q != other.end (); p++, q++)
     {
@@ -129,17 +129,17 @@ octave_fields::equal_up_to_order (const 
         }
     }
 
   retval = (p == end () && q == other.end ());
 
   return retval;
 }
 
-bool 
+bool
 octave_fields::equal_up_to_order (const octave_fields& other,
                                   Array<octave_idx_type>& perm) const
 {
   octave_idx_type n = nfields ();
   if (perm.length () != n)
     perm.clear (1, n);
 
   return equal_up_to_order (other, perm.fortran_vec ());
@@ -177,17 +177,17 @@ octave_scalar_map::setfield (const std::
 void
 octave_scalar_map::rmfield (const std::string& k)
 {
   octave_idx_type idx = xkeys.rmfield (k);
   if (idx >= 0)
     xvals.erase (xvals.begin () + idx);
 }
 
-octave_scalar_map 
+octave_scalar_map
 octave_scalar_map::orderfields (void) const
 {
   Array<octave_idx_type> perm;
   return orderfields (perm);
 }
 
 octave_scalar_map
 octave_scalar_map::orderfields (Array<octave_idx_type>& perm) const
@@ -225,17 +225,17 @@ octave_scalar_map::orderfields (const oc
 }
 
 octave_value
 octave_scalar_map::contents (const std::string& k) const
 {
   return getfield (k);
 }
 
-octave_value& 
+octave_value&
 octave_scalar_map::contents (const std::string& k)
 {
   octave_idx_type idx = xkeys.getfield (k);
   if (idx >= static_cast<octave_idx_type> (xvals.size ()))
     xvals.resize (idx+1);
   return xvals[idx];
 }
 
@@ -288,17 +288,17 @@ octave_map::setfield (const std::string&
 void
 octave_map::rmfield (const std::string& k)
 {
   octave_idx_type idx = xkeys.rmfield (k);
   if (idx >= 0)
     xvals.erase (xvals.begin () + idx);
 }
 
-octave_map 
+octave_map
 octave_map::orderfields (void) const
 {
   Array<octave_idx_type> perm;
   return orderfields (perm);
 }
 
 octave_map
 octave_map::orderfields (Array<octave_idx_type>& perm) const
@@ -336,27 +336,27 @@ octave_map::orderfields (const octave_ma
 }
 
 Cell
 octave_map::contents (const std::string& k) const
 {
   return getfield (k);
 }
 
-Cell& 
+Cell&
 octave_map::contents (const std::string& k)
 {
   octave_idx_type idx = xkeys.getfield (k);
   if (idx >= static_cast<octave_idx_type> (xvals.size ()))
     xvals.push_back (Cell (dimensions)); // auto-set correct dims.
   return xvals[idx];
 }
 
-void 
-octave_map::extract_scalar (octave_scalar_map& dest, 
+void
+octave_map::extract_scalar (octave_scalar_map& dest,
                             octave_idx_type idx) const
 {
   octave_idx_type nf = nfields ();
   for (octave_idx_type i = 0; i < nf; i++)
     dest.xvals[i] = xvals[i](idx);
 }
 
 octave_scalar_map
@@ -398,17 +398,17 @@ octave_map::fast_elem_extract (octave_id
   octave_scalar_map retval (xkeys);
 
   extract_scalar (retval, n);
 
   return retval;
 }
 
 bool
-octave_map::fast_elem_insert (octave_idx_type n, 
+octave_map::fast_elem_insert (octave_idx_type n,
                               const octave_scalar_map& rhs)
 {
   bool retval = false;
 
   octave_idx_type nf = nfields ();
   if (rhs.xkeys.is_same (xkeys))
     {
       for (octave_idx_type i = 0; i < nf; i++)
@@ -433,17 +433,17 @@ octave_map::fast_elem_insert (octave_idx
 
 octave_map
 octave_map::squeeze (void) const
 {
   octave_map retval (*this);
   octave_idx_type nf = nfields ();
 
   retval.dimensions = dimensions.squeeze ();
-  
+
   for (octave_idx_type i = 0; i < nf; i++)
     retval.xvals[i] = xvals[i].squeeze ();
 
   retval.optimize_dimensions ();
 
   return retval;
 }
 
@@ -630,17 +630,17 @@ void permute_to_correct_order1 (const oc
      dest = octave_map (src.dims (), ref.keys ());
   else
      dest = src.orderfields (ref, perm);
 }
 
 template <class map>
 static void
 permute_to_correct_order (octave_idx_type n, octave_idx_type nf,
-                          octave_idx_type idx, const map *map_list, 
+                          octave_idx_type idx, const map *map_list,
                           map *new_map_list)
 {
   new_map_list[idx] = map_list[idx];
 
   Array<octave_idx_type> perm (dim_vector (1, nf));
 
   for (octave_idx_type i = 0; i < n; i++)
     {
@@ -827,17 +827,17 @@ octave_map::index (const idx_vector& i, 
       retval.dimensions = dummy.dims ();
     }
 
   retval.optimize_dimensions ();
 
   return retval;
 }
 
-octave_map 
+octave_map
 octave_map::index (const Array<idx_vector>& ia, bool resize_ok) const
 {
   octave_map retval (xkeys);
   octave_idx_type nf = nfields ();
 
   for (octave_idx_type k = 0; k < nf; k++)
     retval.xvals[k] = xvals[k].index (ia, resize_ok);
 
@@ -851,17 +851,17 @@ octave_map::index (const Array<idx_vecto
       retval.dimensions = dummy.dims ();
     }
 
   retval.optimize_dimensions ();
 
   return retval;
 }
 
-octave_map 
+octave_map
 octave_map::index (const octave_value_list& idx, bool resize_ok) const
 {
   octave_idx_type n_idx = idx.length ();
   octave_map retval;
 
   switch (n_idx)
     {
     case 1:
@@ -903,23 +903,23 @@ octave_map::index (const octave_value_li
       }
       break;
     }
 
   return retval;
 }
 
 // Perhaps one day these will be optimized. Right now, they just call index.
-octave_map 
+octave_map
 octave_map::column (octave_idx_type k) const
 {
   return index (idx_vector::colon, k);
 }
 
-octave_map 
+octave_map
 octave_map::page (octave_idx_type k) const
 {
   static Array<idx_vector> ia (dim_vector (3, 1), idx_vector::colon);
 
   ia(2) = k;
   return index (ia);
 }
 
@@ -1106,17 +1106,17 @@ octave_map::assign (const octave_value_l
   Cell tmp;
   iterator p = seek (k);
   Cell& ref = p != end () ? contents (p) : tmp;
 
   if (&ref == &tmp)
     ref = Cell (dimensions);
 
   ref.assign (idx, rhs);
-    
+
   if (! error_state && ref.dims () != dimensions)
     {
       dimensions = ref.dims ();
 
       octave_idx_type nf = nfields ();
       for (octave_idx_type i = 0; i < nf; i++)
         {
           if (&xvals[i] != &ref)
@@ -1225,17 +1225,17 @@ octave_map::concat (const octave_map& rb
         {
           const_iterator pb = rb.seek (key(pa));
 
           if (pb == rb.end ())
             {
               error ("field name mismatch in structure concatenation");
               break;
             }
-        
+
           contents(pa).insert (rb.contents(pb), ra_idx);
         }
     }
   else
     {
       dim_vector dv = dims ();
 
       if (dv.all_zero ())
@@ -1465,17 +1465,17 @@ Octave_map::concat (const Octave_map& rb
         {
           const_iterator pb = rb.seek (key(pa));
 
           if (pb == rb.end ())
             {
               error ("field name mismatch in structure concatenation");
               break;
             }
-        
+
           retval.assign (key(pa),
                          contents(pa).insert (rb.contents(pb), ra_idx));
         }
 
       // Preserve order of keys.
       retval.key_list = key_list;
     }
   else
diff --git a/src/oct-map.h b/src/oct-map.h
--- a/src/oct-map.h
+++ b/src/oct-map.h
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 #include <map>
 
 #include "Cell.h"
 #include "oct-obj.h"
 
 class string_vector;
 
 // A class holding a map field->index. Supports reference-counting.
-class OCTINTERP_API 
+class OCTINTERP_API
 octave_fields
 {
   class fields_rep : public std::map<std::string, octave_idx_type>
   {
   public:
     fields_rep (void) : std::map<std::string, octave_idx_type> (), count (1) { }
     fields_rep (const fields_rep& other)
       : std::map<std::string, octave_idx_type> (other), count (1) { }
@@ -75,17 +75,17 @@ public:
         {
           --rep->count;
           rep = new fields_rep (*rep);
         }
     }
 
   octave_fields (const octave_fields& o) : rep (o.rep) { rep->count++; }
 
-  octave_fields& 
+  octave_fields&
   operator = (const octave_fields& o)
     {
       o.rep->count++;
       if (--rep->count == 0)
         delete rep;
       rep = o.rep;
 
       return *this;
@@ -97,17 +97,17 @@ public:
   typedef const_iterator iterator;
 
   const_iterator begin (void) const { return rep->begin (); }
   const_iterator end (void) const { return rep->end (); }
 
   std::string key (const_iterator p) const { return p->first; }
   octave_idx_type index (const_iterator p) const { return p->second; }
 
-  const_iterator seek (const std::string& k) const 
+  const_iterator seek (const std::string& k) const
     { return rep->find (k); }
 
   // high-level methods.
 
   // number of fields.
   octave_idx_type nfields (void) const { return rep->size (); }
 
   // check whether a field exists.
@@ -175,41 +175,41 @@ public:
   typedef octave_fields::const_iterator const_iterator;
   typedef const_iterator iterator;
 
   const_iterator begin (void) const { return xkeys.begin (); }
   const_iterator end (void) const { return xkeys.end (); }
 
   const_iterator seek (const std::string& k) const { return xkeys.seek (k); }
 
-  std::string key (const_iterator p) const 
+  std::string key (const_iterator p) const
     { return xkeys.key (p); }
   octave_idx_type index (const_iterator p) const
     { return xkeys.index (p); }
 
-  const octave_value& contents (const_iterator p) const 
+  const octave_value& contents (const_iterator p) const
     { return xvals[xkeys.index (p)]; }
 
   octave_value& contents (iterator p)
     { return xvals[xkeys.index (p)]; }
 
   const octave_value& contents (octave_idx_type i) const
     { return xvals[i]; }
 
   octave_value& contents (octave_idx_type i)
     { return xvals[i]; }
 
   // number of fields.
   octave_idx_type nfields (void) const { return xkeys.nfields (); }
 
   // check whether a field exists.
-  bool isfield (const std::string& name) const 
+  bool isfield (const std::string& name) const
     { return xkeys.isfield (name); }
 
-  bool contains (const std::string& name) const 
+  bool contains (const std::string& name) const
     { return isfield (name); }
 
   string_vector fieldnames (void) const
     { return xkeys.fieldnames (); }
 
   string_vector keys (void) const
     { return fieldnames (); }
 
@@ -298,57 +298,57 @@ public:
   typedef octave_fields::const_iterator const_iterator;
   typedef const_iterator iterator;
 
   const_iterator begin (void) const { return xkeys.begin (); }
   const_iterator end (void) const { return xkeys.end (); }
 
   const_iterator seek (const std::string& k) const { return xkeys.seek (k); }
 
-  std::string key (const_iterator p) const 
+  std::string key (const_iterator p) const
     { return xkeys.key (p); }
   octave_idx_type index (const_iterator p) const
     { return xkeys.index (p); }
 
-  const Cell& contents (const_iterator p) const 
+  const Cell& contents (const_iterator p) const
     { return xvals[xkeys.index (p)]; }
 
   Cell& contents (iterator p)
     { return xvals[xkeys.index (p)]; }
 
   const Cell& contents (octave_idx_type i) const
     { return xvals[i]; }
 
   Cell& contents (octave_idx_type i)
     { return xvals[i]; }
 
   // number of fields.
   octave_idx_type nfields (void) const { return xkeys.nfields (); }
 
   // check whether a field exists.
-  bool isfield (const std::string& name) const 
+  bool isfield (const std::string& name) const
     { return xkeys.isfield (name); }
 
-  bool contains (const std::string& name) const 
+  bool contains (const std::string& name) const
     { return isfield (name); }
 
   string_vector fieldnames (void) const
     { return xkeys.fieldnames (); }
 
   string_vector keys (void) const
     { return fieldnames (); }
 
   // get contents of a given field. empty value if not exist.
   Cell getfield (const std::string& key) const;
 
   // set contents of a given field. add if not exist. checks for
   // correct dimensions.
   void setfield (const std::string& key, const Cell& val);
   void assign (const std::string& k, const Cell& val)
-    { setfield (k, val); } 
+    { setfield (k, val); }
 
   // remove a given field. do nothing if not exist.
   void rmfield (const std::string& key);
   void del (const std::string& k) { rmfield (k); }
 
   // return a copy with fields ordered, optionally along with permutation.
   octave_map orderfields (void) const;
   octave_map orderfields (Array<octave_idx_type>& perm) const;
@@ -385,19 +385,19 @@ public:
     { return checkelem (n); }
   octave_scalar_map operator () (octave_idx_type i, octave_idx_type j) const
     { return checkelem (i, j); }
 
   octave_scalar_map
   operator () (const Array<octave_idx_type>& ra_idx) const
     { return checkelem (ra_idx); }
 
-  octave_map squeeze (void) const; 
+  octave_map squeeze (void) const;
 
-  octave_map permute (const Array<int>& vec, bool inv = false) const; 
+  octave_map permute (const Array<int>& vec, bool inv = false) const;
 
   dim_vector dims (void) const { return dimensions; }
 
   int ndims (void) const { return dimensions.length (); }
 
   octave_map transpose (void) const;
 
   octave_map reshape (const dim_vector& dv) const;
@@ -414,28 +414,28 @@ public:
 
   octave_map index (const idx_vector& i, const idx_vector& j,
                     bool resize_ok = false) const;
 
   octave_map index (const Array<idx_vector>& ia,
                     bool resize_ok = false) const;
 
   octave_map index (const octave_value_list&, bool resize_ok = false) const;
-  
+
   octave_map column (octave_idx_type k) const;
   octave_map page (octave_idx_type k) const;
 
   void assign (const idx_vector& i, const octave_map& rhs);
 
   void assign (const idx_vector& i, const idx_vector& j, const octave_map& rhs);
 
   void assign (const Array<idx_vector>& ia, const octave_map& rhs);
 
   void assign (const octave_value_list&, const octave_map& rhs);
-  
+
   void assign (const octave_value_list& idx, const std::string& k,
                const Cell& rhs);
 
   void delete_elements (const idx_vector& i);
 
   void delete_elements (int dim, const idx_vector& i);
 
   void delete_elements (const Array<idx_vector>& ia);
@@ -452,21 +452,21 @@ public:
 
 private:
 
   octave_fields xkeys;
   std::vector<Cell> xvals;
   dim_vector dimensions;
 
   void optimize_dimensions (void);
-  void extract_scalar (octave_scalar_map& dest, 
+  void extract_scalar (octave_scalar_map& dest,
                        octave_idx_type index) const;
-  static void do_cat (int dim, octave_idx_type n, 
+  static void do_cat (int dim, octave_idx_type n,
                       const octave_scalar_map *map_list, octave_map& retval);
-  static void do_cat (int dim, octave_idx_type n, 
+  static void do_cat (int dim, octave_idx_type n,
                       const octave_map *map_list, octave_map& retval);
 };
 
 template<>
 inline octave_map octave_value_extract<octave_map> (const octave_value& v)
   { return v.map_value (); }
 
 // The original Octave_map object. Octave_map and octave_map are convertible to
@@ -536,19 +536,19 @@ Octave_map
           dimensions = m.dimensions;
         }
 
       return *this;
     }
 
   ~Octave_map (void) { }
 
-  Octave_map squeeze (void) const; 
+  Octave_map squeeze (void) const;
 
-  Octave_map permute (const Array<int>& vec, bool inv = false) const; 
+  Octave_map permute (const Array<int>& vec, bool inv = false) const;
 
   // This is the number of keys.
   octave_idx_type nfields (void) const { return map.size (); }
 
   void del (const std::string& k)
     {
       iterator p = map.find (k);
 
@@ -625,17 +625,17 @@ Octave_map
 
   Octave_map& assign (const octave_value_list& idx, const std::string& k,
                       const Cell& rhs);
 
   Octave_map& assign (const std::string& k, const octave_value& rhs);
 
   Octave_map& assign (const std::string& k, const Cell& rhs);
 
-  Octave_map index (const octave_value_list& idx, 
+  Octave_map index (const octave_value_list& idx,
                     bool resize_ok = false) const;
 
 private:
 
   // The map of names to values.
   std::map<std::string, Cell> map;
 
   // An extra list of keys, so we can keep track of the order the keys
diff --git a/src/oct-obj.cc b/src/oct-obj.cc
--- a/src/oct-obj.cc
+++ b/src/oct-obj.cc
@@ -71,17 +71,17 @@ octave_value_list::prepend (const octave
 
   while (n > 0)
     {
       elem (n) = elem (n - 1);
       n--;
     }
 
   elem (0) = val;
-  
+
   return *this;
 }
 
 octave_value_list&
 octave_value_list::append (const octave_value& val)
 {
   octave_idx_type n = length ();
 
@@ -119,17 +119,17 @@ octave_value_list::reverse (void)
     }
 
   return *this;
 }
 
 octave_value_list
 octave_value_list::splice (octave_idx_type offset, octave_idx_type rep_length,
                            const octave_value_list& lst) const
-{ 
+{
   octave_value_list retval;
 
   octave_idx_type len = length ();
 
   if (offset < 0 || offset >= len)
     {
       if (! (rep_length == 0 && offset == len))
         {
@@ -182,17 +182,17 @@ octave_value_list::all_scalars (void) co
   octave_idx_type n = length ();
 
   for (octave_idx_type i = 0; i < n; i++)
     {
       dim_vector dv = elem(i).dims ();
       if (! dv.all_ones ())
         return false;
     }
-  
+
   return true;
 }
 
 bool
 octave_value_list::any_cell (void) const
 {
   octave_idx_type n = length ();
 
diff --git a/src/oct-obj.h b/src/oct-obj.h
--- a/src/oct-obj.h
+++ b/src/oct-obj.h
@@ -106,33 +106,33 @@ public:
   octave_value& operator () (octave_idx_type n) { return elem (n); }
 
   const octave_value& operator () (octave_idx_type n) const { return elem (n); }
 
   octave_idx_type length (void) const { return data.length (); }
 
   bool empty (void) const { return length () == 0; }
 
-  void resize (octave_idx_type n, const octave_value& rfv 
-               = Array<octave_value>::resize_fill_value ()) 
+  void resize (octave_idx_type n, const octave_value& rfv
+               = Array<octave_value>::resize_fill_value ())
   {
     data.resize (dim_vector (1, n), rfv);
   }
 
   octave_value_list& prepend (const octave_value& val);
 
   octave_value_list& append (const octave_value& val);
 
   octave_value_list& append (const octave_value_list& lst);
 
   octave_value_list& reverse (void);
 
   octave_value_list
   slice (octave_idx_type offset, octave_idx_type len, bool tags = false) const
-    { 
+    {
       octave_value_list retval (data.linear_slice (offset, offset + len));
       if (tags && len > 0 && names.length () > 0)
         retval.names = names.linear_slice (offset, std::min (len, names.length ()));
 
       return retval;
     }
 
   octave_value_list
diff --git a/src/oct-parse.yy b/src/oct-parse.yy
--- a/src/oct-parse.yy
+++ b/src/oct-parse.yy
@@ -632,20 +632,20 @@ identifier      : NAME
                     $$ = new tree_identifier (*sr, $1->line (), $1->column ());
                   }
                 ;
 
 superclass_identifier
                 : SUPERCLASSREF
                   { $$ = new tree_identifier ($1->line (), $1->column ()); }
                 ;
-            
+
 meta_identifier : METAQUERY
                   { $$ = new tree_identifier ($1->line (), $1->column ()); }
-                ;           
+                ;
 
 string          : DQ_STRING
                   { $$ = make_constant (DQ_STRING, $1); }
                 | SQ_STRING
                   { $$ = make_constant (SQ_STRING, $1); }
                 ;
 
 constant        : NUM
@@ -732,17 +732,17 @@ fcn_handle      : '@' FCN_HANDLE
                     $$ = make_fcn_handle ($2);
                     lexer_flags.looking_at_function_handle--;
                   }
                 ;
 
 anon_fcn_handle : '@' param_list statement
                   { $$ = make_anon_fcn_handle ($2, $3); }
                 ;
-        
+
 primary_expr    : identifier
                   { $$ = $1; }
                 | constant
                   { $$ = $1; }
                 | fcn_handle
                   { $$ = $1; }
                 | matrix
                   { $$ = $1; }
@@ -1103,17 +1103,17 @@ case_list       : // empty
                 | default_case
                   { $$ = new tree_switch_case_list ($1); }
                 | case_list1
                   { $$ = $1; }
                 | case_list1 default_case
                   {
                     $1->append ($2);
                     $$ = $1;
-                  }             
+                  }
                 ;
 
 case_list1      : switch_case
                   { $$ = new tree_switch_case_list ($1); }
                 | case_list1 switch_case
                   {
                     $1->append ($2);
                     $$ = $1;
@@ -1350,18 +1350,18 @@ function_list   : function
 // ===================
 // Function definition
 // ===================
 
 function_beg    : push_fcn_symtab FCN stash_comment
                   {
                     $$ = $3;
 
-                    if (reading_classdef_file || lexer_flags.parsing_classdef) 
-                      lexer_flags.maybe_classdef_get_set_method = true; 
+                    if (reading_classdef_file || lexer_flags.parsing_classdef)
+                      lexer_flags.maybe_classdef_get_set_method = true;
                   }
                 ;
 
 function        : function_beg function1
                   {
                     $$ = finish_function (0, $2, $1);
                     recover_from_parsing_function ();
                   }
@@ -1373,17 +1373,17 @@ function        : function_beg function1
                 ;
 
 fcn_name        : identifier
                   {
                     std::string id_name = $1->name ();
 
                     lexer_flags.parsed_function_name.top () = true;
                     lexer_flags.maybe_classdef_get_set_method = false;
-            
+
                     $$ = $1;
                   }
                 | GET '.' identifier
                   {
                     lexer_flags.maybe_classdef_get_set_method = false;
                     $$ = $3;
                   }
                 | SET '.' identifier
@@ -1582,17 +1582,17 @@ events_list     : class_event
                   { $$ = 0; }
                 | events_list '\n' class_event
                   { $$ = 0; }
                 ;
 
 class_event     : identifier
                   { $$ = 0; }
                 ;
- 
+
 // =============
 // Miscellaneous
 // =============
 
 stash_comment   : // empty
                   { $$ = octave_comment_buffer::get_comment (); }
                 ;
 
@@ -1712,29 +1712,29 @@ end_error (const char *type, token::end_
       error (fmt, type, "endclassdef", l, c);
       break;
 
     case token::if_end:
       error (fmt, type, "endif", l, c);
       break;
 
     case token::switch_end:
-      error (fmt, type, "endswitch", l, c); 
+      error (fmt, type, "endswitch", l, c);
       break;
 
     case token::while_end:
-      error (fmt, type, "endwhile", l, c); 
+      error (fmt, type, "endwhile", l, c);
       break;
 
     case token::try_catch_end:
-      error (fmt, type, "end_try_catch", l, c); 
+      error (fmt, type, "end_try_catch", l, c);
       break;
 
     case token::unwind_protect_end:
-      error (fmt, type, "end_unwind_protect", l, c); 
+      error (fmt, type, "end_unwind_protect", l, c);
       break;
 
     default:
       panic_impossible ();
       break;
     }
 }
 
@@ -2915,17 +2915,17 @@ frob_function (const std::string& fname,
       fcn->document (help_buf.top ());
 
       help_buf.pop ();
     }
 
   if (reading_fcn_file && current_function_depth == 1
       && ! parsing_subfunctions)
     primary_fcn_ptr = fcn;
-  
+
   return fcn;
 }
 
 static tree_function_def *
 finish_function (tree_parameter_list *ret_list,
                  octave_user_function *fcn, octave_comment_list *lc)
 {
   tree_function_def *retval = 0;
@@ -3004,17 +3004,17 @@ recover_from_parsing_function (void)
 
 // Make an index expression.
 
 static tree_index_expression *
 make_index_expression (tree_expression *expr, tree_argument_list *args,
                        char type)
 {
   tree_index_expression *retval = 0;
-  
+
   if (args && args->has_magic_tilde ())
     {
       yyerror ("invalid use of empty argument (~) in index expression");
       return retval;
     }
 
   int l = expr->line ();
   int c = expr->column ();
@@ -3272,17 +3272,17 @@ safe_fclose (FILE *f)
 static bool
 looks_like_copyright (const std::string& s)
 {
   bool retval = false;
 
   if (! s.empty ())
     {
       size_t offset = s.find_first_not_of (" \t");
-  
+
       retval = (s.substr (offset, 9) == "Copyright");
     }
 
   return retval;
 }
 
 static int
 text_getc (FILE *f)
@@ -3317,17 +3317,17 @@ public:
   int getc (void) { return ::text_getc (f); }
   int ungetc (int c)
   {
     if (c == '\n')
       input_line_number--;
 
     return ::ungetc (c, f);
   }
-  
+
 private:
   FILE *f;
 };
 
 static bool
 skip_white_space (stream_reader& reader)
 {
   int c = 0;
@@ -3554,17 +3554,17 @@ parse_fcn_file (const std::string& ff, c
 
           frame.protect_var (primary_fcn_ptr);
           primary_fcn_ptr = 0;
 
           reset_parser ();
 
           // Do this with an unwind-protect cleanup function so that
           // the forced variables will be unmarked in the event of an
-          // interrupt. 
+          // interrupt.
           symbol_table::scope_id scope = symbol_table::top_scope ();
           frame.add_fcn (symbol_table::unmark_forced_variables, scope);
 
           if (! help_txt.empty ())
             help_buf.push (help_txt);
 
           if (reading_script_file)
             prep_lexer_for_script_file ();
@@ -3600,17 +3600,17 @@ parse_fcn_file (const std::string& ff, c
           make_script (0, end_of_script);
 
           fcn_ptr = primary_fcn_ptr;
         }
     }
   else if (require_file)
     error ("no such file, `%s'", ff.c_str ());
   else if (! warn_for.empty ())
-    error ("%s: unable to open file `%s'", warn_for.c_str (), ff.c_str ());    
+    error ("%s: unable to open file `%s'", warn_for.c_str (), ff.c_str ());
 
   return fcn_ptr;
 }
 
 std::string
 get_help_from_file (const std::string& nm, bool& symbol_found,
                     std::string& file)
 {
@@ -3666,17 +3666,17 @@ lookup_autoload (const std::string& nm)
   am_iter p = autoload_map.find (nm);
 
   if (p != autoload_map.end ())
     retval = load_path::find_file (p->second);
 
   return retval;
 }
 
-string_vector 
+string_vector
 autoloaded_functions (void)
 {
   string_vector names (autoload_map.size());
 
   octave_idx_type i = 0;
   typedef std::map<std::string, std::string>::const_iterator am_iter;
   for (am_iter p = autoload_map.begin (); p != autoload_map.end (); p++)
     names[i++] = p->first;
@@ -3754,18 +3754,18 @@ load_fcn_from_file (const std::string& f
       // Temporarily load m-file version of mex-file, if it exists,
       // to get the help-string to use.
       frame.protect_var (curr_fcn_file_name);
       frame.protect_var (curr_fcn_file_full_name);
 
       curr_fcn_file_name = nm;
       curr_fcn_file_full_name = file.substr (0, len - 2);
 
-      octave_function *tmpfcn = parse_fcn_file (file.substr (0, len - 2), 
-                                                dispatch_type, autoloading, 
+      octave_function *tmpfcn = parse_fcn_file (file.substr (0, len - 2),
+                                                dispatch_type, autoloading,
                                                 false);
 
       retval = octave_dynamic_loader::load_mex (nm, file, fcn_file_from_relative_lookup);
 
       if (tmpfcn)
         retval->document (tmpfcn->doc_string ());
       delete tmpfcn;
     }
@@ -3973,17 +3973,17 @@ source_file (const std::string& file_nam
         octave_call_stack::goto_caller_frame ();
       else if (context == "base")
         octave_call_stack::goto_base_frame ();
       else
         error ("source: context must be \"caller\" or \"base\"");
 
       if (! error_state)
         frame.add_fcn (octave_call_stack::pop);
-    }      
+    }
 
   if (! error_state)
     {
       octave_function *fcn = parse_fcn_file (file_full_name, "", true,
                                              require_file, warn_for);
 
       if (! error_state)
         {
@@ -4116,17 +4116,17 @@ be named @file{@var{file}.m}.\n\
     print_usage ();
 
   return retval;
 }
 
 // Evaluate an Octave function (built-in or interpreted) and return
 // the list of result values.  NAME is the name of the function to
 // call.  ARGS are the arguments to the function.  NARGOUT is the
-// number of output arguments expected. 
+// number of output arguments expected.
 
 octave_value_list
 feval (const std::string& name, const octave_value_list& args, int nargout)
 {
   octave_value_list retval;
 
   octave_value fcn = symbol_table::find_function (name, args);
 
@@ -4239,24 +4239,24 @@ by name, and use @code{feval} to call th
 
 DEFUN (builtin, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@dots{}]} builtin (@var{f}, @dots{})\n\
 Call the base function @var{f} even if @var{f} is overloaded to\n\
 another function for the given type signature.\n\
 @end deftypefn")
 {
-  octave_value_list retval; 
+  octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin > 0)
     {
       const std::string name (args(0).string_value ());
- 
+
       if (! error_state)
         {
           octave_value fcn = symbol_table::builtin_find (name);
 
           if (fcn.is_defined ())
             retval = feval (fcn.function_value (), args.splice (0, 1),
                             nargout);
           else
diff --git a/src/oct-procbuf.cc b/src/oct-procbuf.cc
--- a/src/oct-procbuf.cc
+++ b/src/oct-procbuf.cc
@@ -51,17 +51,17 @@ static octave_procbuf *octave_procbuf_li
 #define BUFSIZ 1024
 #endif
 
 octave_procbuf *
 octave_procbuf::open (const char *command, int mode)
 {
 #if defined (__CYGWIN__) || defined (__MINGW32__) || defined (_MSC_VER)
 
-  if (is_open ()) 
+  if (is_open ())
     return 0;
 
   f = octave_popen (command, (mode & std::ios::in) ? "r" : "w");
 
   if (! f)
     return 0;
 
   // Oops... popen doesn't return the associated pid, so fake it for now
@@ -69,17 +69,17 @@ octave_procbuf::open (const char *comman
   proc_pid = 1;
 
   open_p = true;
 
   if (mode & std::ios::out)
     ::setvbuf (f, 0, _IOLBF, BUFSIZ);
 
   return this;
-  
+
 #elif defined (HAVE_SYS_WAIT_H)
 
   int pipe_fds[2];
 
   volatile int child_std_end = (mode & std::ios::in) ? 1 : 0;
 
   volatile int parent_end, child_end;
 
@@ -166,17 +166,17 @@ octave_procbuf::close (void)
     {
       wstatus = octave_pclose (f);
       f = 0;
     }
 
   open_p = false;
 
   return this;
-  
+
 #elif defined (HAVE_SYS_WAIT_H)
 
   if (f)
     {
       pid_t wait_pid;
 
       int status = -1;
 
diff --git a/src/oct-stream.cc b/src/oct-stream.cc
--- a/src/oct-stream.cc
+++ b/src/oct-stream.cc
@@ -235,17 +235,17 @@ scanf_format_list::scanf_format_list (co
 scanf_format_list::~scanf_format_list (void)
 {
   octave_idx_type n = list.length ();
 
   for (octave_idx_type i = 0; i < n; i++)
     {
       scanf_format_elt *elt = list(i);
       delete elt;
-    }   
+    }
 }
 
 void
 scanf_format_list::add_elt_to_list (int width, bool discard, char type,
                                     char modifier, octave_idx_type& num_elts,
                                     const std::string& char_class)
 {
   if (buf)
@@ -663,17 +663,17 @@ printf_format_list::printf_format_list (
 printf_format_list::~printf_format_list (void)
 {
   octave_idx_type n = list.length ();
 
   for (octave_idx_type i = 0; i < n; i++)
     {
       printf_format_elt *elt = list(i);
       delete elt;
-    }   
+    }
 }
 
 void
 printf_format_list::add_elt_to_list (int args, const std::string& flags,
                                      int fw, int prec, char type,
                                      char modifier, octave_idx_type& num_elts)
 {
   if (buf)
@@ -917,17 +917,17 @@ octave_base_stream::do_gets (octave_idx_
                              bool strip_newline, const std::string& who)
 {
   std::string retval;
 
   if ((interactive || forced_interactive) && file_number () == 0)
     {
       ::error ("%s: unable to read from stdin while running interactively",
                who.c_str ());
-             
+
       return retval;
     }
 
   err = false;
 
   std::istream *isp = input_stream ();
 
   if (isp)
@@ -1031,17 +1031,17 @@ long
 octave_base_stream::skipl (long num, bool& err, const std::string& who)
 {
   long cnt = -1;
 
   if ((interactive || forced_interactive) && file_number () == 0)
     {
       ::error ("%s: unable to read from stdin while running interactively",
                who.c_str ());
-             
+
       return count;
     }
 
   err = false;
 
   std::istream *isp = input_stream ();
 
   if (isp)
@@ -1169,17 +1169,17 @@ octave_scan (std::istream& is, const sca
       octave_scan_1 (ss, fmt, valptr);
     }
   else
     octave_scan_1 (is, fmt, valptr);
 
   return is;
 }
 
-// Note that this specialization is only used for reading characters, not 
+// Note that this specialization is only used for reading characters, not
 // character strings. See BEGIN_S_CONVERSION for details.
 
 template<>
 std::istream&
 octave_scan<> (std::istream& is, const scanf_format_elt& /* fmt */,
                char* valptr)
 {
   return is >> valptr;
@@ -1384,17 +1384,17 @@ octave_scan<> (std::istream& is, const s
   return is;
 }
 
 template <class T>
 void
 do_scanf_conv (std::istream& is, const scanf_format_elt& fmt,
                T valptr, Matrix& mval, double *data, octave_idx_type& idx,
                octave_idx_type& conversion_count, octave_idx_type nr, octave_idx_type max_size,
-               bool discard) 
+               bool discard)
 {
   OCTAVE_SCAN (is, fmt, valptr);
 
   if (is)
     {
       if (idx == max_size && ! discard)
         {
           max_size *= 2;
@@ -1666,17 +1666,17 @@ octave_base_stream::do_scanf (scanf_form
                               octave_idx_type& conversion_count, const std::string& who)
 {
   octave_value retval = Matrix ();
 
   if ((interactive || forced_interactive) && file_number () == 0)
     {
       ::error ("%s: unable to read from stdin while running interactively",
                who.c_str ());
-             
+
       return retval;
     }
 
   conversion_count = 0;
 
   octave_idx_type nconv = fmt_list.num_conversions ();
 
   octave_idx_type data_index = 0;
@@ -2609,17 +2609,17 @@ octave_base_stream::do_printf (printf_fo
 
           if (elt)
             {
               // NSA is the number of `star' args to convert.
 
               int nsa = (elt->fw < 0) + (elt->prec < 0);
 
               int sa_1 = 0;
-              int sa_2 = 0; 
+              int sa_2 = 0;
 
               if (nsa > 0)
                 {
                   sa_1 = val_cache.int_value ();
 
                   if (! val_cache)
                     break;
                   else
@@ -2640,17 +2640,17 @@ octave_base_stream::do_printf (printf_fo
                 {
                   os << "%";
                   retval++;
                 }
               else if (elt->args == 0 && elt->text)
                 {
                   os << elt->text;
                   retval += strlen (elt->text);
-                }             
+                }
               else if (elt->type == 's')
                 {
                   std::string val = val_cache.string_value ();
 
                   if (val_cache)
                     retval += do_printf_conv (os, fmt, nsa, sa_1,
                                               sa_2, val.c_str (), who);
                   else
@@ -2730,17 +2730,17 @@ octave_base_stream::do_printf (printf_fo
               retval = -1;
               break;
             }
 
           elt = fmt_list.next (nconv > 0 && ! val_cache.exhausted ());
 
           if (! elt || (val_cache.exhausted () && elt->args > 0))
             break;
-        }             
+        }
     }
   else
     invalid_operation (who, "writing");
 
   return retval;
 }
 
 int
@@ -3912,17 +3912,17 @@ octave_stream::puts (const std::string& 
 
 int
 octave_stream::puts (const octave_value& tc_s, const std::string& who)
 {
   int retval = -1;
 
   if (tc_s.is_string ())
     {
-      std::string s = tc_s.string_value ();      
+      std::string s = tc_s.string_value ();
       retval = puts (s, who);
     }
   else
     {
       // Note that this is not ::error () !
 
       error (who + ": argument must be a string");
     }
@@ -3988,17 +3988,17 @@ octave_stream::float_format (void) const
 std::string
 octave_stream::mode_as_string (int mode)
 {
   std::string retval = "???";
   std::ios::openmode in_mode = static_cast<std::ios::openmode> (mode);
 
   if (in_mode == std::ios::in)
     retval = "r";
-  else if (in_mode == std::ios::out 
+  else if (in_mode == std::ios::out
            || in_mode == (std::ios::out | std::ios::trunc))
     retval = "w";
   else if (in_mode == (std::ios::out | std::ios::app))
     retval = "a";
   else if (in_mode == (std::ios::in | std::ios::out))
     retval = "r+";
   else if (in_mode == (std::ios::in | std::ios::out | std::ios::trunc))
     retval = "w+";
@@ -4008,17 +4008,17 @@ octave_stream::mode_as_string (int mode)
     retval = "rb";
   else if (in_mode == (std::ios::out | std::ios::binary)
            || in_mode == (std::ios::out | std::ios::trunc | std::ios::binary))
     retval = "wb";
   else if (in_mode == (std::ios::out | std::ios::app | std::ios::binary))
     retval = "ab";
   else if (in_mode == (std::ios::in | std::ios::out | std::ios::binary))
     retval = "r+b";
-  else if (in_mode == (std::ios::in | std::ios::out | std::ios::trunc 
+  else if (in_mode == (std::ios::in | std::ios::out | std::ios::trunc
                        | std::ios::binary))
     retval = "w+b";
   else if (in_mode == (std::ios::in | std::ios::out | std::ios::ate
                        | std::ios::binary))
     retval = "a+b";
 
   return retval;
 }
diff --git a/src/oct-stream.h b/src/oct-stream.h
--- a/src/oct-stream.h
+++ b/src/oct-stream.h
@@ -162,17 +162,17 @@ private:
   // List of format elements.
   Array<scanf_format_elt*> list;
 
   // Temporary buffer.
   std::ostringstream *buf;
 
   void add_elt_to_list (int width, bool discard, char type, char modifier,
                         octave_idx_type& num_elts,
-                        const std::string& char_class = std::string ()); 
+                        const std::string& char_class = std::string ());
 
   void process_conversion (const std::string& s, size_t& i, size_t n,
                            int& width, bool& discard, char& type,
                            char& modifier, octave_idx_type& num_elts);
 
   int finish_conversion (const std::string& s, size_t& i, size_t n,
                          int& width, bool discard, char& type,
                          char modifier, octave_idx_type& num_elts);
@@ -210,17 +210,17 @@ public:
           type = e.type;
           modifier = e.modifier;
         }
 
       return *this;
     }
 
   ~printf_format_elt (void) { delete [] text; }
- 
+
   // The C-style format string.
   const char *text;
 
   // How many args do we expect to consume?
   int args;
 
   // Field width.
   int fw;
@@ -297,22 +297,22 @@ private:
   Array<printf_format_elt*> list;
 
   // Temporary buffer.
   std::ostringstream *buf;
 
   void add_elt_to_list (int args, const std::string& flags, int fw,
                         int prec, char type, char modifier,
                         octave_idx_type& num_elts);
- 
+
   void process_conversion (const std::string& s, size_t& i, size_t n,
                            int& args, std::string& flags, int& fw,
                            int& prec, char& modifier, char& type,
-                           octave_idx_type& num_elts); 
- 
+                           octave_idx_type& num_elts);
+
   void finish_conversion (const std::string& s, size_t& i, int args,
                           const std::string& flags, int fw, int prec,
                           char modifier, char& type,
                           octave_idx_type& num_elts);
 
   // No copying!
 
   printf_format_list (const printf_format_list&);
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -108,17 +108,17 @@ static bool inhibit_startup_message = fa
 // (--traditional)
 static bool traditional = false;
 
 // If TRUE, print verbose info in some cases.
 // (--verbose; -V)
 static bool verbose_flag = false;
 
 // Usage message
-static const char *usage_string = 
+static const char *usage_string =
   "octave [-HVdfhiqvx] [--debug] [--echo-commands] [--eval CODE]\n\
        [--exec-path path] [--help] [--image-path path] [--info-file file]\n\
        [--info-program prog] [--interactive] [--line-editing]\n\
        [--no-history] [--no-init-file] [--no-init-path] [--no-line-editing]\n\
        [--no-site-file] [--no-window-system] [-p path] [--path path]\n\
        [--silent] [--traditional] [--verbose] [--version] [file]";
 
 // This is here so that it's more likely that the usage message and
@@ -479,17 +479,17 @@ execute_command_line_file (const std::st
   input_from_command_line_file = true;
 
   curr_fcn_file_name = fname;
   curr_fcn_file_full_name = curr_fcn_file_name;
 
   octave_program_invocation_name = curr_fcn_file_name;
 
   size_t pos = curr_fcn_file_name.find_last_of (file_ops::dir_sep_chars ());
-  
+
   std::string tmp = (pos != std::string::npos)
     ? curr_fcn_file_name.substr (pos+1) : curr_fcn_file_name;
 
   octave_program_name = tmp;
 
   std::string context;
   bool verbose = false;
   bool require_file = true;
diff --git a/src/ov-base-diag.cc b/src/ov-base-diag.cc
--- a/src/ov-base-diag.cc
+++ b/src/ov-base-diag.cc
@@ -101,17 +101,17 @@ octave_base_diag<DMT, MT>::do_index_op (
     }
   else
     retval = to_dense ().do_index_op (idx, resize_ok);
 
   return retval;
 }
 
 template <class DMT, class MT>
-octave_value 
+octave_value
 octave_base_diag<DMT, MT>::subsasgn (const std::string& type,
                                      const std::list<octave_value_list>& idx,
                                      const octave_value& rhs)
 {
   octave_value retval;
 
   switch (type[0])
     {
@@ -121,21 +121,21 @@ octave_base_diag<DMT, MT>::subsasgn (con
           {
             octave_value_list jdx = idx.front ();
             // Check for a simple element assignment. That means, if D is a diagonal matrix,
             // `D(i,i) = x' will not destroy its diagonality (provided i is a valid index).
             if (jdx.length () == 2 && jdx(0).is_scalar_type () && jdx(1).is_scalar_type ())
               {
                 typename DMT::element_type val;
                 idx_vector i0 = jdx(0).index_vector (), i1 = jdx(1).index_vector ();
-                if (! error_state  && i0(0) == i1(0) 
+                if (! error_state  && i0(0) == i1(0)
                     && i0(0) < matrix.rows () && i1(0) < matrix.cols ()
                     && chk_valid_scalar (rhs, val))
                   {
-                    matrix.dgelem (i0(0)) = val;                    
+                    matrix.dgelem (i0(0)) = val;
                     retval = this;
                     this->count++;
                     // invalidate cache
                     dense_cache = octave_value ();
                   }
               }
 
             if (! error_state && ! retval.is_defined ())
@@ -349,35 +349,35 @@ octave_base_diag<DMT, MT>::float_complex
 {
   return FloatComplexNDArray (float_complex_matrix_value ());
 }
 
 template <class DMT, class MT>
 boolNDArray
 octave_base_diag<DMT, MT>::bool_array_value (bool warn) const
 {
-  return to_dense ().bool_array_value (warn); 
+  return to_dense ().bool_array_value (warn);
 }
-  
+
 template <class DMT, class MT>
 charNDArray
 octave_base_diag<DMT, MT>::char_array_value (bool warn) const
 {
-  return to_dense ().char_array_value (warn); 
+  return to_dense ().char_array_value (warn);
 }
-  
+
 template <class DMT, class MT>
-SparseMatrix 
+SparseMatrix
 octave_base_diag<DMT, MT>::sparse_matrix_value (bool) const
 {
   return SparseMatrix (diag_matrix_value ());
 }
 
 template <class DMT, class MT>
-SparseComplexMatrix 
+SparseComplexMatrix
 octave_base_diag<DMT, MT>::sparse_complex_matrix_value (bool) const
 {
   return SparseComplexMatrix (complex_diag_matrix_value ());
 }
 
 template <class DMT, class MT>
 idx_vector
 octave_base_diag<DMT, MT>::index_vector (void) const
@@ -388,42 +388,42 @@ octave_base_diag<DMT, MT>::index_vector 
 template <class DMT, class MT>
 octave_value
 octave_base_diag<DMT, MT>::convert_to_str_internal (bool pad, bool force, char type) const
 {
   return to_dense ().convert_to_str_internal (pad, force, type);
 }
 
 template <class DMT, class MT>
-bool 
+bool
 octave_base_diag<DMT, MT>::save_ascii (std::ostream& os)
 {
   os << "# rows: " << matrix.rows () << "\n"
     << "# columns: " << matrix.columns () << "\n";
 
   os << matrix.diag ();
 
   return true;
 }
 
 template <class DMT, class MT>
-bool 
+bool
 octave_base_diag<DMT, MT>::load_ascii (std::istream& is)
 {
   octave_idx_type r = 0, c = 0;
   bool success = true;
 
   if (extract_keyword (is, "rows", r, true)
       && extract_keyword (is, "columns", c, true))
     {
       octave_idx_type l = r < c ? r : c;
       MT tmp (l, 1);
       is >> tmp;
 
-      if (!is) 
+      if (!is)
         {
           error ("load: failed to load diagonal matrix constant");
           success = false;
         }
       else
         {
           // This is a little tricky, as we have the Matrix type, but
           // not ColumnVector type. We need to help the compiler get
@@ -477,18 +477,18 @@ octave_base_diag<DMT, MT>::print (std::o
   print_raw (os, pr_as_read_syntax);
   newline (os);
 }
 template <class DMT, class MT>
 int
 octave_base_diag<DMT, MT>::write (octave_stream& os, int block_size,
                                   oct_data_conv::data_type output_type, int skip,
                                   oct_mach_info::float_format flt_fmt) const
-{ 
-  return to_dense ().write (os, block_size, output_type, skip, flt_fmt); 
+{
+  return to_dense ().write (os, block_size, output_type, skip, flt_fmt);
 }
 
 template <class DMT, class MT>
 void
 octave_base_diag<DMT, MT>::print_info (std::ostream& os,
                                        const std::string& prefix) const
 {
   matrix.print_info (os, prefix);
diff --git a/src/ov-base-diag.h b/src/ov-base-diag.h
--- a/src/ov-base-diag.h
+++ b/src/ov-base-diag.h
@@ -144,24 +144,24 @@ public:
 
   FloatComplex float_complex_value (bool = false) const;
 
   ComplexMatrix complex_matrix_value (bool = false) const;
 
   FloatComplexMatrix float_complex_matrix_value (bool = false) const;
 
   ComplexNDArray complex_array_value (bool = false) const;
-   
+
   FloatComplexNDArray float_complex_array_value (bool = false) const;
-   
+
   boolNDArray bool_array_value (bool warn = false) const;
 
   charNDArray char_array_value (bool = false) const;
-  
-  NDArray array_value (bool = false) const; 
+
+  NDArray array_value (bool = false) const;
 
   FloatNDArray float_array_value (bool = false) const;
 
   SparseMatrix sparse_matrix_value (bool = false) const;
 
   SparseComplexMatrix sparse_complex_matrix_value (bool = false) const;
 
   int8NDArray
@@ -209,17 +209,17 @@ public:
   void print_info (std::ostream& os, const std::string& prefix) const;
 
 protected:
 
   DMT matrix;
 
   octave_value to_dense (void) const;
 
-  virtual bool chk_valid_scalar (const octave_value&, 
+  virtual bool chk_valid_scalar (const octave_value&,
                                  typename DMT::element_type&) const = 0;
 
 private:
 
   mutable octave_value dense_cache;
 
 };
 
diff --git a/src/ov-base-int.cc b/src/ov-base-int.cc
--- a/src/ov-base-int.cc
+++ b/src/ov-base-int.cc
@@ -189,17 +189,17 @@ octave_base_int_matrix<T>::save_ascii (s
     os << " " << d (i);
 
   os << "\n" << this->matrix;
 
   return true;
 }
 
 template <class T>
-bool 
+bool
 octave_base_int_matrix<T>::load_ascii (std::istream& is)
 {
   int mdims = 0;
   bool success = true;
 
   if (extract_keyword (is, "ndims", mdims, true))
     {
       if (mdims >= 0)
@@ -209,17 +209,17 @@ octave_base_int_matrix<T>::load_ascii (s
 
           for (int i = 0; i < mdims; i++)
             is >> dv(i);
 
           T tmp(dv);
 
           is >> tmp;
 
-          if (!is) 
+          if (!is)
             {
               error ("load: failed to load matrix constant");
               success = false;
             }
 
           this->matrix = tmp;
         }
       else
@@ -230,17 +230,17 @@ octave_base_int_matrix<T>::load_ascii (s
     }
   else
     error ("load: failed to extract number of dimensions");
 
   return success;
 }
 
 template <class T>
-bool 
+bool
 octave_base_int_matrix<T>::save_binary (std::ostream& os, bool&)
 {
   dim_vector d = this->dims ();
   if (d.length() < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
   int32_t tmp = - d.length();
@@ -299,17 +299,17 @@ octave_base_int_matrix<T>::load_binary (
 
   if (! is.read (reinterpret_cast<char *> (m.fortran_vec ()), m.byte_size ()))
     return false;
 
   if (swap)
     {
       int nel = dv.numel ();
       int bytes = nel / m.byte_size();
-      for (int i = 0; i < nel; i++) 
+      for (int i = 0; i < nel; i++)
         switch (bytes)
           {
           case 8:
             swap_bytes<8> (&m(i));
             break;
           case 4:
             swap_bytes<4> (&m(i));
             break;
@@ -341,25 +341,25 @@ octave_base_int_matrix<T>::save_hdf5 (hi
 
   int rank = dv.length ();
   hid_t space_hid = -1, data_hid = -1;
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
     hdims[i] = dv (rank-i-1);
- 
+
   space_hid = H5Screate_simple (rank, hdims, 0);
 
   if (space_hid < 0) return false;
 #if HAVE_HDF5_18
-  data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid, 
+  data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
-  data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid, 
+  data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid,
                         H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
 
@@ -388,17 +388,17 @@ octave_base_int_matrix<T>::load_hdf5 (hi
 #if HAVE_HDF5_18
   hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
   hid_t space_id = H5Dget_space (data_hid);
 
   hsize_t rank = H5Sget_simple_extent_ndims (space_id);
-  
+
   if (rank < 1)
     {
       H5Sclose (space_id);
       H5Dclose (data_hid);
       return false;
     }
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
@@ -416,18 +416,18 @@ octave_base_int_matrix<T>::load_hdf5 (hi
   else
     {
       dv.resize (rank);
       for (hsize_t i = 0, j = rank - 1; i < rank; i++, j--)
         dv(j) = hdims[i];
     }
 
   T m (dv);
-  if (H5Dread (data_hid, save_type_hid, H5S_ALL, H5S_ALL, 
-               H5P_DEFAULT, m.fortran_vec()) >= 0) 
+  if (H5Dread (data_hid, save_type_hid, H5S_ALL, H5S_ALL,
+               H5P_DEFAULT, m.fortran_vec()) >= 0)
     {
       retval = true;
       this->matrix = m;
     }
 
   H5Sclose (space_id);
   H5Dclose (data_hid);
 
@@ -480,38 +480,38 @@ template <class T>
 bool
 octave_base_int_scalar<T>::save_ascii (std::ostream& os)
 {
   os << this->scalar << "\n";
   return true;
 }
 
 template <class T>
-bool 
+bool
 octave_base_int_scalar<T>::load_ascii (std::istream& is)
 {
   is >> this->scalar;
   if (!is)
     {
       error ("load: failed to load scalar constant");
       return false;
     }
   return true;
 }
 
 template <class T>
-bool 
+bool
 octave_base_int_scalar<T>::save_binary (std::ostream& os, bool&)
 {
   os.write (reinterpret_cast<char *> (&(this->scalar)), this->byte_size());
   return true;
 }
 
 template <class T>
-bool 
+bool
 octave_base_int_scalar<T>::load_binary (std::istream& is, bool swap,
                                         oct_mach_info::float_format)
 {
   T tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), this->byte_size()))
     return false;
 
   if (swap)
@@ -544,23 +544,23 @@ octave_base_int_scalar<T>::save_hdf5 (hi
   bool retval = true;
   hsize_t dimens[3];
   hid_t space_hid = -1, data_hid = -1;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0) return false;
 
 #if HAVE_HDF5_18
-  data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid, 
+  data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
-  data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid, 
+  data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid,
                         H5P_DEFAULT);
 #endif
-  if (data_hid < 0) 
+  if (data_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
 
   retval = H5Dwrite (data_hid, save_type_hid, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, &(this->scalar)) >= 0;
 
@@ -580,25 +580,25 @@ octave_base_int_scalar<T>::load_hdf5 (hi
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
   hid_t space_id = H5Dget_space (data_hid);
 
   hsize_t rank = H5Sget_simple_extent_ndims (space_id);
 
   if (rank != 0)
-    { 
+    {
       H5Dclose (data_hid);
       return false;
     }
 
   T tmp;
-  if (H5Dread (data_hid, save_type_hid, H5S_ALL, H5S_ALL, 
+  if (H5Dread (data_hid, save_type_hid, H5S_ALL, H5S_ALL,
                H5P_DEFAULT, &tmp) < 0)
-    { 
+    {
       H5Dclose (data_hid);
       return false;
     }
 
   this->scalar = tmp;
 
   H5Dclose (data_hid);
 
diff --git a/src/ov-base-int.h b/src/ov-base-int.h
--- a/src/ov-base-int.h
+++ b/src/ov-base-int.h
@@ -68,17 +68,17 @@ public:
   octave_value convert_to_str_internal (bool, bool, char type) const;
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& );
 
-  bool load_binary (std::istream& is, bool swap, 
+  bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format );
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 };
@@ -111,17 +111,17 @@ public:
   octave_value convert_to_str_internal (bool, bool, char type) const;
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& );
 
-  bool load_binary (std::istream& is, bool swap, 
+  bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format );
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool );
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 };
diff --git a/src/ov-base-mat.cc b/src/ov-base-mat.cc
--- a/src/ov-base-mat.cc
+++ b/src/ov-base-mat.cc
@@ -262,20 +262,20 @@ octave_base_matrix<MT>::assign (const oc
       break;
     }
 
   // Clear cache.
   clear_cached_info ();
 }
 
 template <class MT>
-MatrixType 
+MatrixType
 octave_base_matrix<MT>::matrix_type (const MatrixType& _typ) const
-{ 
-  delete typ; 
+{
+  delete typ;
   typ = new MatrixType (_typ);
   return *typ;
 }
 
 template <class MT>
 void
 octave_base_matrix<MT>::assign (const octave_value_list& idx,
                                 typename MT::element_type rhs)
@@ -386,21 +386,21 @@ octave_base_matrix<MT>::delete_elements 
   // Clear cache.
   clear_cached_info ();
 }
 
 template <class MT>
 octave_value
 octave_base_matrix<MT>::resize (const dim_vector& dv, bool fill) const
 {
-  MT retval (matrix); 
+  MT retval (matrix);
   if (fill)
     retval.resize (dv, 0);
   else
-    retval.resize (dv); 
+    retval.resize (dv);
   return retval;
 }
 
 template <class MT>
 bool
 octave_base_matrix<MT>::is_true (void) const
 {
   bool retval = false;
@@ -456,17 +456,17 @@ octave_base_matrix<MT>::fast_elem_extrac
   if (n < matrix.numel ())
     return matrix(n);
   else
     return octave_value ();
 }
 
 template <class MT>
 bool
-octave_base_matrix<MT>::fast_elem_insert (octave_idx_type n, 
+octave_base_matrix<MT>::fast_elem_insert (octave_idx_type n,
                                           const octave_value& x)
 {
   if (n < matrix.numel ())
     {
       // Don't use builtin_type () here to avoid an extra VM call.
       typedef typename MT::element_type ET;
       const builtin_type_t btyp = class_to_btyp<ET>::btyp;
       if (btyp == btyp_unknown) // Dead branch?
diff --git a/src/ov-base-mat.h b/src/ov-base-mat.h
--- a/src/ov-base-mat.h
+++ b/src/ov-base-mat.h
@@ -47,27 +47,27 @@ class
 octave_base_matrix : public octave_base_value
 {
 public:
 
   octave_base_matrix (void)
     : octave_base_value (), matrix (), typ (), idx_cache () { }
 
   octave_base_matrix (const MT& m, const MatrixType& t = MatrixType ())
-    : octave_base_value (), matrix (m), 
+    : octave_base_value (), matrix (m),
       typ (t.is_known () ? new MatrixType(t) : 0), idx_cache ()
   {
     if (matrix.ndims () == 0)
       matrix.resize (dim_vector (0, 0));
   }
 
   octave_base_matrix (const octave_base_matrix& m)
-    : octave_base_value (), matrix (m.matrix), 
-      typ (m.typ ? new MatrixType (*m.typ) : 0), 
-      idx_cache (m.idx_cache ? new idx_vector (*m.idx_cache) : 0) 
+    : octave_base_value (), matrix (m.matrix),
+      typ (m.typ ? new MatrixType (*m.typ) : 0),
+      idx_cache (m.idx_cache ? new idx_vector (*m.idx_cache) : 0)
     { }
 
   ~octave_base_matrix (void) { clear_cached_info (); }
 
   size_t byte_size (void) const { return matrix.byte_size (); }
 
   octave_value squeeze (void) const { return MT (matrix.squeeze ()); }
 
@@ -178,15 +178,15 @@ protected:
       idx_cache = idx ? new idx_vector (idx) : 0;
       return idx;
     }
 
   void clear_cached_info (void) const
     {
       delete typ; typ = 0;
       delete idx_cache; idx_cache = 0;
-    } 
+    }
 
   mutable MatrixType *typ;
   mutable idx_vector *idx_cache;
 };
 
 #endif
diff --git a/src/ov-base-scalar.cc b/src/ov-base-scalar.cc
--- a/src/ov-base-scalar.cc
+++ b/src/ov-base-scalar.cc
@@ -153,17 +153,17 @@ octave_base_scalar<ST>::print_raw (std::
 
 template <class ST>
 bool
 octave_base_scalar<ST>::print_name_tag (std::ostream& os,
                                         const std::string& name) const
 {
   indent (os);
   os << name << " = ";
-  return false;    
+  return false;
 }
 
 template <class ST>
 bool
 octave_base_scalar<ST>::fast_elem_insert_self (void *where, builtin_type_t btyp) const
 {
 
   // Don't use builtin_type () here to avoid an extra VM call.
diff --git a/src/ov-base-scalar.h b/src/ov-base-scalar.h
--- a/src/ov-base-scalar.h
+++ b/src/ov-base-scalar.h
@@ -94,20 +94,20 @@ public:
   octave_value any (int = 0) const { return (scalar != ST ()); }
 
   octave_value diag (octave_idx_type k = 0) const;
 
   octave_value sort (octave_idx_type, sortmode) const
     { return octave_value (scalar); }
   octave_value sort (Array<octave_idx_type> &sidx, octave_idx_type,
                      sortmode) const
-    { 
-      sidx.resize (dim_vector (1, 1)); 
-      sidx(0) = 0; 
-      return octave_value (scalar); 
+    {
+      sidx.resize (dim_vector (1, 1));
+      sidx(0) = 0;
+      return octave_value (scalar);
     }
 
   sortmode is_sorted (sortmode mode = UNSORTED) const
     { return mode ? mode : ASCENDING; }
 
   Array<octave_idx_type> sort_rows_idx (sortmode) const
     { return Array<octave_idx_type> (dim_vector (1, 0)); }
 
diff --git a/src/ov-base-sparse.cc b/src/ov-base-sparse.cc
--- a/src/ov-base-sparse.cc
+++ b/src/ov-base-sparse.cc
@@ -40,17 +40,17 @@ along with Octave; see the file COPYING.
 #include "ls-hdf5.h"
 
 #include "boolSparse.h"
 #include "ov-base-sparse.h"
 #include "pager.h"
 
 template <class T>
 octave_value
-octave_base_sparse<T>::do_index_op (const octave_value_list& idx, 
+octave_base_sparse<T>::do_index_op (const octave_value_list& idx,
                                     bool resize_ok)
 {
   octave_value retval;
 
   octave_idx_type n_idx = idx.length ();
 
   switch (n_idx)
     {
@@ -111,17 +111,17 @@ octave_base_sparse<T>::subsref (const st
     default:
       panic_impossible ();
     }
 
   return retval.next_subsref (type, idx);
 }
 
 template <class T>
-octave_value 
+octave_value
 octave_base_sparse<T>::subsasgn (const std::string& type,
                                  const std::list<octave_value_list>& idx,
                                  const octave_value& rhs)
 {
   octave_value retval;
 
   switch (type[0])
     {
@@ -158,17 +158,17 @@ octave_base_sparse<T>::subsasgn (const s
     default:
       panic_impossible ();
     }
 
   return retval;
 }
 
 template <class T>
-void 
+void
 octave_base_sparse<T>::assign (const octave_value_list& idx, const T& rhs)
 {
 
   octave_idx_type len = idx.length ();
 
   switch (len)
     {
     case 1:
@@ -242,26 +242,26 @@ octave_base_sparse<MT>::delete_elements 
       error ("sparse indexing needs 1 or 2 indices");
     }
 
   // Invalidate the matrix type
   typ.invalidate_type ();
 }
 
 template <class T>
-octave_value 
+octave_value
 octave_base_sparse<T>::resize (const dim_vector& dv, bool) const
-{ 
-  T retval (matrix); 
-  retval.resize (dv); 
-  return retval; 
+{
+  T retval (matrix);
+  retval.resize (dv);
+  return retval;
 }
 
 template <class T>
-bool 
+bool
 octave_base_sparse<T>::is_true (void) const
 {
   bool retval = false;
   dim_vector dv = matrix.dims ();
   octave_idx_type nel = dv.numel ();
   octave_idx_type nz = nnz ();
 
   if (nz == nel && nel > 0)
@@ -272,35 +272,35 @@ octave_base_sparse<T>::is_true (void) co
 
       retval = t2(0);
     }
 
   return retval;
 }
 
 template <class T>
-bool 
+bool
 octave_base_sparse<T>::print_as_scalar (void) const
 {
   dim_vector dv = dims ();
 
   return (dv.all_ones () || dv.any_zero ());
 }
 
 template <class T>
-void 
+void
 octave_base_sparse<T>::print (std::ostream& os, bool pr_as_read_syntax) const
 {
   print_raw (os, pr_as_read_syntax);
   newline (os);
 }
 
 template <class T>
-void 
-octave_base_sparse<T>::print_info (std::ostream& os, 
+void
+octave_base_sparse<T>::print_info (std::ostream& os,
                                    const std::string& prefix) const
 {
   matrix.print_info (os, prefix);
 }
 
 template <class T>
 void
 octave_base_sparse<T>::print_raw (std::ostream& os,
@@ -390,33 +390,33 @@ octave_base_sparse<T>::save_ascii (std::
   os << "# columns: "  << dv (1) << "\n";
 
   os << this->matrix;
 
   return true;
 }
 
 template <class T>
-bool 
+bool
 octave_base_sparse<T>::load_ascii (std::istream& is)
 {
   octave_idx_type nz = 0;
   octave_idx_type nr = 0;
   octave_idx_type nc = 0;
   bool success = true;
 
   if (extract_keyword (is, "nnz", nz, true) &&
       extract_keyword (is, "rows", nr, true) &&
       extract_keyword (is, "columns", nc, true))
     {
       T tmp (nr, nc, nz);
 
       is >> tmp;
 
-      if (!is) 
+      if (!is)
         {
           error ("load: failed to load matrix constant");
           success = false;
         }
 
       matrix = tmp;
     }
   else
diff --git a/src/ov-base-sparse.h b/src/ov-base-sparse.h
--- a/src/ov-base-sparse.h
+++ b/src/ov-base-sparse.h
@@ -43,36 +43,36 @@ class tree_walker;
 
 class octave_sparse_bool_matrix;
 
 template <class T>
 class
 octave_base_sparse : public octave_base_value
 {
  public:
- 
+
   octave_base_sparse (void)
-    : octave_base_value (), matrix (), typ (MatrixType ()) 
+    : octave_base_value (), matrix (), typ (MatrixType ())
   { }
 
   octave_base_sparse (const T& a) : octave_base_value (), matrix (a),
                                     typ (MatrixType ())
   {
     if (matrix.ndims () == 0)
       matrix.resize (dim_vector (0, 0));
   }
 
-  octave_base_sparse (const T& a, const MatrixType& t) : octave_base_value (), 
+  octave_base_sparse (const T& a, const MatrixType& t) : octave_base_value (),
                                 matrix (a), typ (t)
   {
     if (matrix.ndims () == 0)
       matrix.resize (dim_vector (0, 0));
   }
 
-  octave_base_sparse (const octave_base_sparse& a) : 
+  octave_base_sparse (const octave_base_sparse& a) :
     octave_base_value (), matrix (a.matrix), typ (a.typ) { }
 
   ~octave_base_sparse (void) { }
 
   octave_idx_type nnz (void) const { return matrix.nnz (); }
 
   octave_idx_type nzmax (void) const { return matrix.nzmax (); }
 
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -63,26 +63,26 @@ builtin_type_t btyp_mixed_numeric (built
     y = btyp_double;
 
   if (x <= btyp_float_complex && y <= btyp_float_complex)
     retval = static_cast<builtin_type_t> (x | y);
   else if (x <= btyp_uint64 && y <= btyp_float)
     retval = x;
   else if (x <= btyp_float && y <= btyp_uint64)
     retval = y;
-  else if ((x >= btyp_int8 && x <= btyp_int64 
+  else if ((x >= btyp_int8 && x <= btyp_int64
             && y >= btyp_int8 && y <= btyp_int64)
            || (x >= btyp_uint8 && x <= btyp_uint64
                && y >= btyp_uint8 && y <= btyp_uint64))
     retval = (x > y) ? x : y;
 
   return retval;
 }
 
-std::string btyp_class_name[btyp_num_types] = 
+std::string btyp_class_name[btyp_num_types] =
 {
   "double", "single", "double", "single",
   "int8", "int16", "int32", "int64",
   "uint8", "uint16", "uint32", "uint64",
   "logical", "char",
   "struct", "cell", "function_handle"
 };
 
@@ -324,24 +324,24 @@ octave_base_value::permute (const Array<
 
 octave_value
 octave_base_value::resize (const dim_vector&, bool) const
 {
   gripe_wrong_type_arg ("octave_base_value::resize ()", type_name ());
   return octave_value ();
 }
 
-MatrixType 
+MatrixType
 octave_base_value::matrix_type (void) const
 {
   gripe_wrong_type_arg ("octave_base_value::matrix_type ()", type_name ());
   return MatrixType ();
 }
 
-MatrixType 
+MatrixType
 octave_base_value::matrix_type (const MatrixType&) const
 {
   gripe_wrong_type_arg ("octave_base_value::matrix_type ()", type_name ());
   return MatrixType ();
 }
 
 octave_value
 octave_base_value::all (int) const
@@ -412,17 +412,17 @@ octave_base_value::print_name_tag (std::
       retval = true;
     }
 
   return retval;
 }
 
 void
 octave_base_value::print_with_name (std::ostream& output_buf,
-                                    const std::string& name, 
+                                    const std::string& name,
                                     bool print_padding)
 {
   bool pad_after = print_name_tag (output_buf, name);
 
   print (output_buf);
 
   if (print_padding && pad_after)
     newline (output_buf);
@@ -1029,38 +1029,38 @@ octave_base_value::fcn_inline_value (boo
 octave_value_list
 octave_base_value::list_value (void) const
 {
   octave_value_list retval;
   gripe_wrong_type_arg ("octave_base_value::list_value()", type_name ());
   return retval;
 }
 
-bool 
+bool
 octave_base_value::save_ascii (std::ostream&)
 {
   gripe_wrong_type_arg ("octave_base_value::save_ascii()", type_name ());
   return false;
 }
 
-bool 
+bool
 octave_base_value::load_ascii (std::istream&)
 {
   gripe_wrong_type_arg ("octave_base_value::load_ascii()", type_name ());
   return false;
 }
 
-bool 
+bool
 octave_base_value::save_binary (std::ostream&, bool&)
 {
   gripe_wrong_type_arg ("octave_base_value::save_binary()", type_name ());
   return false;
 }
 
-bool 
+bool
 octave_base_value::load_binary (std::istream&, bool,
                                 oct_mach_info::float_format)
 {
   gripe_wrong_type_arg ("octave_base_value::load_binary()", type_name ());
   return false;
 }
 
 #if defined (HAVE_HDF5)
@@ -1068,17 +1068,17 @@ octave_base_value::load_binary (std::ist
 bool
 octave_base_value::save_hdf5 (hid_t, const char *, bool)
 {
   gripe_wrong_type_arg ("octave_base_value::save_binary()", type_name ());
 
   return false;
 }
 
-bool 
+bool
 octave_base_value::load_hdf5 (hid_t, const char *)
 {
   gripe_wrong_type_arg ("octave_base_value::load_binary()", type_name ());
 
   return false;
 }
 
 #endif
@@ -1112,17 +1112,17 @@ octave_value
 octave_base_value::sort (octave_idx_type, sortmode) const
 {
   gripe_wrong_type_arg ("octave_base_value::sort ()", type_name ());
 
   return octave_value();
 }
 
 octave_value
-octave_base_value::sort (Array<octave_idx_type> &, 
+octave_base_value::sort (Array<octave_idx_type> &,
                          octave_idx_type, sortmode) const
 {
   gripe_wrong_type_arg ("octave_base_value::sort ()", type_name ());
 
   return octave_value();
 }
 
 sortmode
@@ -1148,17 +1148,17 @@ octave_base_value::is_sorted_rows (sortm
 
   return UNSORTED;
 }
 
 
 const char *
 octave_base_value::get_umap_name (unary_mapper_t umap)
 {
-  static const char *names[num_unary_mappers] = 
+  static const char *names[num_unary_mappers] =
     {
       "abs",
       "acos",
       "acosh",
       "angle",
       "arg",
       "asin",
       "asinh",
@@ -1344,17 +1344,17 @@ octave_base_value::numeric_assign (const
 
           octave_base_value::type_conv_info cf_this
             = numeric_conversion_function ();
 
           // Try biased (one-sided) conversions first.
           if (cf_rhs.type_id () >= 0
               && (octave_value_typeinfo::lookup_assign_op (octave_value::op_asn_eq,
                                                            t_lhs, cf_rhs.type_id ())
-                  || octave_value_typeinfo::lookup_pref_assign_conv (t_lhs, 
+                  || octave_value_typeinfo::lookup_pref_assign_conv (t_lhs,
                                                                      cf_rhs.type_id ()) >= 0))
             cf_this = 0;
           else if (cf_this.type_id () >= 0
                    && (octave_value_typeinfo::lookup_assign_op (octave_value::op_asn_eq,
                                                                 cf_this.type_id (), t_rhs)
                        || octave_value_typeinfo::lookup_pref_assign_conv (cf_this.type_id (),
                                                                           t_rhs) >= 0))
             cf_rhs = 0;
@@ -1421,17 +1421,17 @@ bool octave_base_value::beginning_of_lin
 // Each print() function should call this before printing anything.
 //
 // This doesn't need to be fast, but isn't there a better way?
 
 void
 octave_base_value::indent (std::ostream& os) const
 {
   assert (curr_print_indent_level >= 0);
- 
+
   if (beginning_of_line)
     {
       // FIXME -- do we need this?
       // os << prefix;
 
       for (int i = 0; i < curr_print_indent_level; i++)
         os << " ";
 
@@ -1466,17 +1466,17 @@ octave_base_value::fast_elem_extract (oc
 }
 
 bool
 octave_base_value::fast_elem_insert (octave_idx_type, const octave_value&)
 {
   return false;
 }
 
-bool 
+bool
 octave_base_value::fast_elem_insert_self (void *, builtin_type_t) const
 {
   return false;
 }
 
 CONVDECLX (matrix_conv)
 {
   return new octave_matrix ();
diff --git a/src/ov-base.h b/src/ov-base.h
--- a/src/ov-base.h
+++ b/src/ov-base.h
@@ -74,21 +74,21 @@ enum builtin_type_t
   btyp_char,
   btyp_struct,
   btyp_cell,
   btyp_func_handle,
   btyp_unknown,
   btyp_num_types = btyp_unknown
 };
 
-extern OCTINTERP_API std::string 
+extern OCTINTERP_API std::string
 btyp_class_name [btyp_num_types];
 
 extern OCTINTERP_API string_vector
-get_builtin_classes (void); 
+get_builtin_classes (void);
 
 inline bool btyp_isnumeric (builtin_type_t btyp)
 { return btyp <= btyp_uint64; }
 
 inline bool btyp_isinteger (builtin_type_t btyp)
 { return btyp >= btyp_int8 && btyp <= btyp_uint64; }
 
 inline bool btyp_isfloat (builtin_type_t btyp)
@@ -187,17 +187,17 @@ public:
   // type conversion, including result type information
   class type_conv_info
   {
   public:
     type_conv_info (type_conv_fcn f = 0, int t = -1) : _fcn (f), _type_id (t) { }
 
     operator type_conv_fcn (void) const { return _fcn; }
 
-    octave_base_value * operator () (const octave_base_value &v) const 
+    octave_base_value * operator () (const octave_base_value &v) const
       { return (*_fcn) (v); }
 
     int type_id (void) const { return _type_id; }
 
   private:
     type_conv_fcn _fcn;
     int _type_id;
   };
@@ -235,17 +235,17 @@ public:
   virtual octave_value squeeze (void) const;
 
   virtual octave_value full_value (void) const;
 
   virtual octave_base_value *try_narrowing_conversion (void) { return 0; }
 
   virtual void maybe_economize (void) { }
 
-  virtual Matrix size (void); 
+  virtual Matrix size (void);
 
   virtual octave_idx_type numel (const octave_value_list&);
 
   virtual octave_value
   subsref (const std::string& type,
            const std::list<octave_value_list>& idx);
 
   virtual octave_value_list
@@ -500,21 +500,21 @@ public:
 
   virtual SparseComplexMatrix sparse_complex_matrix_value (bool = false) const;
 
   virtual SparseBoolMatrix sparse_bool_matrix_value (bool = false) const;
 
   virtual DiagMatrix diag_matrix_value (bool = false) const;
 
   virtual FloatDiagMatrix float_diag_matrix_value (bool = false) const;
-  
+
   virtual ComplexDiagMatrix complex_diag_matrix_value (bool = false) const;
-  
+
   virtual FloatComplexDiagMatrix float_complex_diag_matrix_value (bool = false) const;
-  
+
   virtual PermMatrix perm_matrix_value (void) const;
 
   virtual octave_int8 int8_scalar_value (void) const;
 
   virtual octave_int16 int16_scalar_value (void) const;
 
   virtual octave_int32 int32_scalar_value (void) const;
 
@@ -597,28 +597,28 @@ public:
 
   virtual void
   print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   virtual bool
   print_name_tag (std::ostream& os, const std::string& name) const;
 
   virtual void
-  print_with_name (std::ostream& output_buf, const std::string& name, 
+  print_with_name (std::ostream& output_buf, const std::string& name,
                    bool print_padding = true);
 
   virtual void print_info (std::ostream& os, const std::string& prefix) const;
 
   virtual bool save_ascii (std::ostream& os);
 
   virtual bool load_ascii (std::istream& is);
 
   virtual bool save_binary (std::ostream& os, bool& save_as_floats);
 
-  virtual bool load_binary (std::istream& is, bool swap, 
+  virtual bool load_binary (std::istream& is, bool swap,
                             oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   virtual bool
   save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   virtual bool
   load_hdf5 (hid_t loc_id, const char *name);
@@ -634,19 +634,19 @@ public:
   virtual octave_idx_type *mex_get_ir (void) const { return 0; }
 
   virtual octave_idx_type *mex_get_jc (void) const { return 0; }
 
   virtual mxArray *as_mxArray (void) const;
 
   virtual octave_value diag (octave_idx_type k = 0) const;
 
-  virtual octave_value sort (octave_idx_type dim = 0, 
+  virtual octave_value sort (octave_idx_type dim = 0,
                              sortmode mode = ASCENDING) const;
-  virtual octave_value sort (Array<octave_idx_type> &sidx, 
+  virtual octave_value sort (Array<octave_idx_type> &sidx,
                              octave_idx_type dim = 0,
                              sortmode mode = ASCENDING) const;
 
   virtual sortmode is_sorted (sortmode mode = UNSORTED) const;
 
   virtual Array<octave_idx_type>
   sort_rows_idx (sortmode mode = ASCENDING) const;
 
diff --git a/src/ov-bool-mat.cc b/src/ov-bool-mat.cc
--- a/src/ov-bool-mat.cc
+++ b/src/ov-bool-mat.cc
@@ -177,46 +177,46 @@ octave_bool_matrix::convert_to_str_inter
 void
 octave_bool_matrix::print_raw (std::ostream& os,
                                bool pr_as_read_syntax) const
 {
   octave_print_internal (os, matrix, pr_as_read_syntax,
                          current_print_indent_level ());
 }
 
-bool 
+bool
 octave_bool_matrix::save_ascii (std::ostream& os)
 {
   dim_vector d = dims ();
   if (d.length () > 2)
     {
       NDArray tmp = array_value ();
       os << "# ndims: " << d.length () << "\n";
 
       for (int i = 0; i < d.length (); i++)
         os << " " << d (i);
 
       os << "\n" << tmp;
     }
   else
     {
-      // Keep this case, rather than use generic code above for backward 
+      // Keep this case, rather than use generic code above for backward
       // compatiability. Makes load_ascii much more complex!!
       os << "# rows: " << rows () << "\n"
          << "# columns: " << columns () << "\n";
 
       Matrix tmp = matrix_value ();
 
       os << tmp;
     }
 
   return true;
 }
 
-bool 
+bool
 octave_bool_matrix::load_ascii (std::istream& is)
 {
   bool success = true;
 
   string_vector keywords (2);
 
   keywords[0] = "ndims";
   keywords[1] = "rows";
@@ -281,17 +281,17 @@ octave_bool_matrix::load_ascii (std::ist
           octave_idx_type nc = 0;
 
           if (nr >= 0 && extract_keyword (is, "columns", nc) && nc >= 0)
             {
               if (nr > 0 && nc > 0)
                 {
                   Matrix tmp (nr, nc);
                   is >> tmp;
-                  if (is) 
+                  if (is)
                     {
                       boolMatrix btmp (nr, nc);
                       for (octave_idx_type j = 0; j < nc; j++)
                         for (octave_idx_type i = 0; i < nr; i++)
                           btmp.elem (i,j) = (tmp.elem (i, j) != 0.);
 
                       matrix = btmp;
                     }
@@ -319,17 +319,17 @@ octave_bool_matrix::load_ascii (std::ist
     {
       error ("load: failed to extract number of rows and columns");
       success = false;
     }
 
   return success;
 }
 
-bool 
+bool
 octave_bool_matrix::save_binary (std::ostream& os, bool& /* save_as_floats */)
 {
 
   dim_vector d = dims ();
   if (d.length() < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
@@ -349,17 +349,17 @@ octave_bool_matrix::save_binary (std::os
   for (octave_idx_type i = 0; i < nel; i++)
     htmp[i] = (mtmp[i] ? 1 : 0);
 
   os.write (htmp, nel);
 
   return true;
 }
 
-bool 
+bool
 octave_bool_matrix::load_binary (std::istream& is, bool swap,
                                  oct_mach_info::float_format /* fmt */)
 {
   int32_t mdims;
   if (! is.read (reinterpret_cast<char *> (&mdims), 4))
     return false;
   if (swap)
     swap_bytes<4> (&mdims);
@@ -377,17 +377,17 @@ octave_bool_matrix::load_binary (std::is
   for (int i = 0; i < mdims; i++)
     {
       if (! is.read (reinterpret_cast<char *> (&di), 4))
         return false;
       if (swap)
         swap_bytes<4> (&di);
       dv(i) = di;
     }
-  
+
   // Convert an array with a single dimension to be a row vector.
   // Octave should never write files like this, other software
   // might.
 
   if (mdims == 1)
     {
       mdims = 2;
       dv.resize (mdims);
@@ -428,32 +428,32 @@ octave_bool_matrix::save_hdf5 (hid_t loc
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
     hdims[i] = dv (rank-i-1);
 
   space_hid = H5Screate_simple (rank, hdims, 0);
   if (space_hid < 0) return false;
 #if HAVE_HDF5_18
-  data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_HBOOL, space_hid, 
+  data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_HBOOL, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
-  data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_HBOOL, space_hid, 
+  data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_HBOOL, space_hid,
                         H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
 
   octave_idx_type nel = m.nelem ();
   bool *mtmp = m.fortran_vec ();
   OCTAVE_LOCAL_BUFFER (hbool_t, htmp, nel);
-  
+
   for (octave_idx_type i = 0; i < nel; i++)
     htmp[i] = mtmp[i];
 
   retval = H5Dwrite (data_hid, H5T_NATIVE_HBOOL, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, htmp) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
@@ -476,17 +476,17 @@ octave_bool_matrix::load_hdf5 (hid_t loc
 #if HAVE_HDF5_18
   hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
   hid_t space_id = H5Dget_space (data_hid);
 
   hsize_t rank = H5Sget_simple_extent_ndims (space_id);
-  
+
   if (rank < 1)
     {
       H5Dclose (data_hid);
       return false;
     }
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
   OCTAVE_LOCAL_BUFFER (hsize_t, maxdims, rank);
@@ -504,17 +504,17 @@ octave_bool_matrix::load_hdf5 (hid_t loc
     {
       dv.resize (rank);
       for (hsize_t i = 0, j = rank - 1; i < rank; i++, j--)
         dv(j) = hdims[i];
     }
 
   octave_idx_type nel = dv.numel ();
   OCTAVE_LOCAL_BUFFER (hbool_t, htmp, nel);
-  if (H5Dread (data_hid, H5T_NATIVE_HBOOL, H5S_ALL, H5S_ALL, H5P_DEFAULT, htmp) >= 0) 
+  if (H5Dread (data_hid, H5T_NATIVE_HBOOL, H5S_ALL, H5S_ALL, H5P_DEFAULT, htmp) >= 0)
     {
       retval = true;
 
       boolNDArray btmp (dv);
       for (octave_idx_type i = 0; i < nel; i++)
           btmp.elem (i) = htmp[i];
 
       matrix = btmp;
diff --git a/src/ov-bool-mat.h b/src/ov-bool-mat.h
--- a/src/ov-bool-mat.h
+++ b/src/ov-bool-mat.h
@@ -63,34 +63,34 @@ public:
 
   octave_bool_matrix (const boolMatrix& bm)
     : octave_base_matrix<boolNDArray> (bm) { }
 
   octave_bool_matrix (const boolMatrix& bm, const MatrixType& t)
     : octave_base_matrix<boolNDArray> (bm, t) { }
 
   octave_bool_matrix (const boolNDArray& bm, const idx_vector& cache)
-    : octave_base_matrix<boolNDArray> (bm) 
-    { 
+    : octave_base_matrix<boolNDArray> (bm)
+    {
       set_idx_cache (cache);
     }
 
   octave_bool_matrix (const octave_bool_matrix& bm)
     : octave_base_matrix<boolNDArray> (bm) { }
 
   ~octave_bool_matrix (void) { }
 
   octave_base_value *clone (void) const { return new octave_bool_matrix (*this); }
   octave_base_value *empty_clone (void) const { return new octave_bool_matrix (); }
 
   type_conv_info numeric_conversion_function (void) const;
 
   octave_base_value *try_narrowing_conversion (void);
 
-  idx_vector index_vector (void) const 
+  idx_vector index_vector (void) const
     { return idx_cache ? *idx_cache : set_idx_cache (idx_vector (matrix)); }
 
   builtin_type_t builtin_type (void) const { return btyp_bool; }
 
   bool is_bool_matrix (void) const { return true; }
 
   bool is_bool_type (void) const { return true; }
 
@@ -158,17 +158,17 @@ public:
     { return FloatComplexNDArray (matrix); }
 
   charNDArray
   char_array_value (bool = false) const
   {
     charNDArray retval (dims ());
 
     octave_idx_type nel = numel ();
-  
+
     for (octave_idx_type i = 0; i < nel; i++)
       retval(i) = static_cast<char>(matrix(i));
 
     return retval;
   }
 
   boolMatrix bool_matrix_value (bool = false) const
     { return matrix.matrix_value (); }
@@ -193,17 +193,17 @@ public:
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
-  bool load_binary (std::istream& is, bool swap, 
+  bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
diff --git a/src/ov-bool-sparse.cc b/src/ov-bool-sparse.cc
--- a/src/ov-bool-sparse.cc
+++ b/src/ov-bool-sparse.cc
@@ -155,17 +155,17 @@ octave_sparse_bool_matrix::complex_matri
 }
 
 ComplexNDArray
 octave_sparse_bool_matrix::complex_array_value (bool) const
 {
   return ComplexNDArray (ComplexMatrix (matrix.matrix_value ()));
 }
 
-NDArray 
+NDArray
 octave_sparse_bool_matrix::array_value (bool) const
 {
   return NDArray (Matrix(matrix.matrix_value ()));
 }
 
 charNDArray
 octave_sparse_bool_matrix::char_array_value (bool) const
 {
@@ -175,90 +175,90 @@ octave_sparse_bool_matrix::char_array_va
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = matrix.cidx(j); i < matrix.cidx(j+1); i++)
       retval(matrix.ridx(i) + nr * j) = static_cast<char>(matrix.data (i));
 
   return retval;
 }
 
-boolMatrix 
+boolMatrix
 octave_sparse_bool_matrix::bool_matrix_value (bool) const
-{ 
-  return matrix.matrix_value (); 
+{
+  return matrix.matrix_value ();
 }
 
-boolNDArray 
+boolNDArray
 octave_sparse_bool_matrix::bool_array_value (bool) const
-{ 
-  return boolNDArray (matrix.matrix_value ()); 
+{
+  return boolNDArray (matrix.matrix_value ());
 }
 
 
-SparseMatrix 
+SparseMatrix
 octave_sparse_bool_matrix::sparse_matrix_value (bool) const
 {
   return SparseMatrix (this->matrix);
 }
 
-SparseComplexMatrix 
+SparseComplexMatrix
 octave_sparse_bool_matrix::sparse_complex_matrix_value (bool) const
 {
   return SparseComplexMatrix (this->matrix);
 }
 
-bool 
+bool
 octave_sparse_bool_matrix::save_binary (std::ostream& os, bool&)
 {
   dim_vector d = this->dims ();
   if (d.length() < 1)
     return false;
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
 
   int nr = d(0);
   int nc = d(1);
   int nz = nnz ();
 
   int32_t itmp;
   // Use negative value for ndims to be consistent with other formats
-  itmp= -2;        
+  itmp= -2;
   os.write (reinterpret_cast<char *> (&itmp), 4);
-  
-  itmp= nr;    
+
+  itmp= nr;
   os.write (reinterpret_cast<char *> (&itmp), 4);
-  
+
   itmp= nc;
   os.write (reinterpret_cast<char *> (&itmp), 4);
-  
+
   itmp= nz;
   os.write (reinterpret_cast<char *> (&itmp), 4);
 
   // add one to the printed indices to go from
   // zero-based to one-based arrays
-  for (int i = 0; i < nc+1; i++)  
+  for (int i = 0; i < nc+1; i++)
     {
       octave_quit ();
       itmp = matrix.cidx(i);
       os.write (reinterpret_cast<char *> (&itmp), 4);
     }
 
-  for (int i = 0; i < nz; i++) 
+  for (int i = 0; i < nz; i++)
     {
       octave_quit ();
-      itmp = matrix.ridx(i); 
+      itmp = matrix.ridx(i);
       os.write (reinterpret_cast<char *> (&itmp), 4);
     }
 
   OCTAVE_LOCAL_BUFFER (char, htmp, nz);
 
   for (int i = 0; i < nz; i++)
     htmp[i] = (matrix.data (i) ? 1 : 0);
-   
+
   os.write (htmp, nz);
 
   return true;
 }
 
 bool
 octave_sparse_bool_matrix::load_binary (std::istream& is, bool swap,
                                         oct_mach_info::float_format /* fmt */)
@@ -288,27 +288,27 @@ octave_sparse_bool_matrix::load_binary (
       swap_bytes<4> (&nc);
       swap_bytes<4> (&nz);
     }
 
   SparseBoolMatrix m (static_cast<octave_idx_type> (nr),
                       static_cast<octave_idx_type> (nc),
                       static_cast<octave_idx_type> (nz));
 
-  for (int i = 0; i < nc+1; i++) 
+  for (int i = 0; i < nc+1; i++)
     {
       octave_quit ();
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
         return false;
       if (swap)
         swap_bytes<4> (&tmp);
       m.cidx(i) = tmp;
     }
 
-  for (int i = 0; i < nz; i++) 
+  for (int i = 0; i < nz; i++)
     {
       octave_quit ();
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
         return false;
       if (swap)
         swap_bytes<4> (&tmp);
       m.ridx(i) = tmp;
     }
@@ -318,17 +318,17 @@ octave_sparse_bool_matrix::load_binary (
 
   OCTAVE_LOCAL_BUFFER (char, htmp, nz);
 
   if (! is.read (htmp, nz))
     return false;
 
   for (int i = 0; i < nz; i++)
     m.data(i) = (htmp[i] ? 1 : 0);
- 
+
   if (! m.indices_ok ())
     return false;
 
   matrix = m;
 
   return true;
 }
 
@@ -354,84 +354,84 @@ octave_sparse_bool_matrix::save_hdf5 (hi
 
   hid_t space_hid = -1, data_hid = -1;
   bool retval = true;
   SparseBoolMatrix m = sparse_bool_matrix_value ();
   octave_idx_type tmp;
   hsize_t hdims[2];
 
   space_hid = H5Screate_simple (0, hdims, 0);
-  if (space_hid < 0) 
+  if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid,
                         H5P_DEFAULT);
 #endif
-  if (data_hid < 0) 
+  if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
-  
+
   tmp = m.rows ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, &tmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
-    }    
+    }
 
 #if HAVE_HDF5_18
   data_hid = H5Dcreate (group_hid, "nc", H5T_NATIVE_IDX, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "nc", H5T_NATIVE_IDX, space_hid,
                         H5P_DEFAULT);
 #endif
-  if (data_hid < 0) 
+  if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
-  
+
   tmp = m.cols ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, &tmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
-    }    
+    }
 
 #if HAVE_HDF5_18
-  data_hid = H5Dcreate (group_hid, "nz", H5T_NATIVE_IDX, space_hid, 
+  data_hid = H5Dcreate (group_hid, "nz", H5T_NATIVE_IDX, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
-  data_hid = H5Dcreate (group_hid, "nz", H5T_NATIVE_IDX, space_hid, 
+  data_hid = H5Dcreate (group_hid, "nz", H5T_NATIVE_IDX, space_hid,
                         H5P_DEFAULT);
 #endif
-  if (data_hid < 0) 
+  if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
-  
+
   tmp = m.nnz ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, &tmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
@@ -440,100 +440,100 @@ octave_sparse_bool_matrix::save_hdf5 (hi
 
   H5Sclose (space_hid);
 
   hdims[0] = m.cols() + 1;
   hdims[1] = 1;
 
   space_hid = H5Screate_simple (2, hdims, 0);
 
-  if (space_hid < 0) 
+  if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 
 #if HAVE_HDF5_18
-  data_hid = H5Dcreate (group_hid, "cidx", H5T_NATIVE_IDX, space_hid, 
+  data_hid = H5Dcreate (group_hid, "cidx", H5T_NATIVE_IDX, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
-  data_hid = H5Dcreate (group_hid, "cidx", H5T_NATIVE_IDX, space_hid, 
+  data_hid = H5Dcreate (group_hid, "cidx", H5T_NATIVE_IDX, space_hid,
                         H5P_DEFAULT);
 #endif
-  if (data_hid < 0) 
+  if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
-  
+
   octave_idx_type * itmp = m.xcidx ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, itmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
-    }    
+    }
 
   H5Sclose (space_hid);
 
   hdims[0] = m.nnz ();
   hdims[1] = 1;
 
   space_hid = H5Screate_simple (2, hdims, 0);
 
-  if (space_hid < 0) 
+  if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 
 #if HAVE_HDF5_18
-  data_hid = H5Dcreate (group_hid, "ridx", H5T_NATIVE_IDX, space_hid, 
+  data_hid = H5Dcreate (group_hid, "ridx", H5T_NATIVE_IDX, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
-  data_hid = H5Dcreate (group_hid, "ridx", H5T_NATIVE_IDX, space_hid, 
+  data_hid = H5Dcreate (group_hid, "ridx", H5T_NATIVE_IDX, space_hid,
                         H5P_DEFAULT);
 #endif
-  if (data_hid < 0) 
+  if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
-  
+
   itmp = m.xridx ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, itmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
 #if HAVE_HDF5_18
-  data_hid = H5Dcreate (group_hid, "data", H5T_NATIVE_HBOOL, space_hid, 
+  data_hid = H5Dcreate (group_hid, "data", H5T_NATIVE_HBOOL, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
-  data_hid = H5Dcreate (group_hid, "data", H5T_NATIVE_HBOOL, space_hid, 
+  data_hid = H5Dcreate (group_hid, "data", H5T_NATIVE_HBOOL, space_hid,
                         H5P_DEFAULT);
 #endif
-  if (data_hid < 0) 
+  if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
-  OCTAVE_LOCAL_BUFFER (hbool_t, htmp, m.nnz ());  
+  OCTAVE_LOCAL_BUFFER (hbool_t, htmp, m.nnz ());
   for (int i = 0; i < m.nnz (); i++)
     htmp[i] = m.xdata(i);
 
   retval = H5Dwrite (data_hid, H5T_NATIVE_HBOOL, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, htmp) >= 0;
   H5Dclose (data_hid);
   H5Sclose (space_hid);
   H5Gclose (group_hid);
@@ -542,17 +542,17 @@ octave_sparse_bool_matrix::save_hdf5 (hi
 }
 
 bool
 octave_sparse_bool_matrix::load_hdf5 (hid_t loc_id, const char *name)
 {
   octave_idx_type nr, nc, nz;
   hid_t group_hid, data_hid, space_hid;
   hsize_t rank;
-  
+
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize(dv);
   if (empty)
     return (empty > 0);
 
 #if HAVE_HDF5_18
@@ -566,72 +566,72 @@ octave_sparse_bool_matrix::load_hdf5 (hi
   data_hid = H5Dopen (group_hid, "nr", H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "nr");
 #endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 0)
-    { 
+    {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, &nr) < 0)
-    { 
+    {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
 
 #if HAVE_HDF5_18
   data_hid = H5Dopen (group_hid, "nc", H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "nc");
 #endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 0)
-    { 
+    {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, &nc) < 0)
-    { 
+    {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
 
 #if HAVE_HDF5_18
   data_hid = H5Dopen (group_hid, "nz", H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "nz");
 #endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 0)
-    { 
+    {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, &nz) < 0)
-    { 
+    {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
 
   SparseBoolMatrix m (static_cast<octave_idx_type> (nr),
@@ -664,17 +664,17 @@ octave_sparse_bool_matrix::load_hdf5 (hi
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   octave_idx_type *itmp = m.xcidx ();
-  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, itmp) < 0) 
+  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, itmp) < 0)
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
@@ -704,17 +704,17 @@ octave_sparse_bool_matrix::load_hdf5 (hi
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   itmp = m.xridx ();
   if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
-               H5P_DEFAULT, itmp) < 0) 
+               H5P_DEFAULT, itmp) < 0)
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
@@ -769,17 +769,17 @@ octave_sparse_bool_matrix::load_hdf5 (hi
 }
 
 #endif
 
 mxArray *
 octave_sparse_bool_matrix::as_mxArray (void) const
 {
   mwSize nz = nzmax ();
-  mxArray *retval = new mxArray (mxLOGICAL_CLASS, rows (), columns (), 
+  mxArray *retval = new mxArray (mxLOGICAL_CLASS, rows (), columns (),
                                  nz, mxREAL);
   bool *pr = static_cast<bool *> (retval->get_data ());
   mwIndex *ir = retval->get_ir ();
   mwIndex *jc = retval->get_jc ();
 
   for (mwIndex i = 0; i < nz; i++)
     {
       pr[i] = matrix.data(i);
diff --git a/src/ov-bool-sparse.h b/src/ov-bool-sparse.h
--- a/src/ov-bool-sparse.h
+++ b/src/ov-bool-sparse.h
@@ -79,17 +79,17 @@ public:
   octave_base_value *clone (void) const { return new octave_sparse_bool_matrix (*this); }
   octave_base_value *empty_clone (void) const { return new octave_sparse_bool_matrix (); }
 
   type_conv_info numeric_conversion_function (void) const;
 
   octave_base_value *try_narrowing_conversion (void);
 
   // FIXME Adapt idx_vector to allow sparse logical indexing!!
-  idx_vector index_vector (void) const 
+  idx_vector index_vector (void) const
     { return idx_vector (bool_array_value ()); }
 
   builtin_type_t builtin_type (void) const { return btyp_bool; }
 
   bool is_bool_matrix (void) const { return true; }
 
   bool is_bool_type (void) const { return true; }
 
@@ -124,17 +124,17 @@ public:
 
   SparseBoolMatrix sparse_bool_matrix_value (bool = false) const
     { return matrix; }
 
   octave_value convert_to_str_internal (bool pad, bool force, char type) const;
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
-  bool load_binary (std::istream& is, bool swap, 
+  bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
diff --git a/src/ov-bool.cc b/src/ov-bool.cc
--- a/src/ov-bool.cc
+++ b/src/ov-bool.cc
@@ -78,80 +78,80 @@ octave_bool::do_index_op (const octave_v
   // 1x1 matrix back to a scalar value.  Need a better solution
   // to this problem.
 
   octave_value tmp (new octave_bool_matrix (bool_matrix_value ()));
 
   return tmp.do_index_op (idx, resize_ok);
 }
 
-octave_value 
+octave_value
 octave_bool::resize (const dim_vector& dv, bool fill) const
-{ 
+{
   if (fill)
     {
-      boolNDArray retval (dv, false); 
-      if (dv.numel()) 
-        retval(0) = scalar; 
-      return retval; 
+      boolNDArray retval (dv, false);
+      if (dv.numel())
+        retval(0) = scalar;
+      return retval;
     }
   else
     {
-      boolNDArray retval (dv); 
-      if (dv.numel()) 
-        retval(0) = scalar; 
-      return retval; 
+      boolNDArray retval (dv);
+      if (dv.numel())
+        retval(0) = scalar;
+      return retval;
     }
 }
 
 octave_value
 octave_bool::convert_to_str_internal (bool, bool, char type) const
 {
   char s[2];
   s[0] = static_cast<char> (scalar);
   s[1] = '\0';
 
   return octave_value (s, type);
 }
 
-bool 
+bool
 octave_bool::save_ascii (std::ostream& os)
 {
   double d = double_value ();
 
   octave_write_double (os, d);
   os << "\n";
 
   return true;
 }
 
-bool 
+bool
 octave_bool::load_ascii (std::istream& is)
 {
   scalar = (octave_read_value<double> (is) != 0.);
 
   if (!is)
     {
       error ("load: failed to load scalar constant");
       return false;
     }
 
   return true;
 }
 
-bool 
+bool
 octave_bool::save_binary (std::ostream& os, bool& /* save_as_floats */)
 {
   char tmp = (scalar ? 1 : 0);
   os.write (reinterpret_cast<char *> (&tmp), 1);
 
   return true;
 }
 
-bool 
+bool
 octave_bool::load_binary (std::istream& is, bool /* swap */,
                           oct_mach_info::float_format /* fmt */)
 {
   char tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), 1))
     return false;
   scalar = (tmp ? 1 : 0);
   return true;
@@ -165,23 +165,23 @@ octave_bool::save_hdf5 (hid_t loc_id, co
 {
   hsize_t dimens[3];
   hid_t space_hid = -1, data_hid = -1;
   bool retval = true;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0) return false;
 #if HAVE_HDF5_18
-  data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_DOUBLE, space_hid, 
+  data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_DOUBLE, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
-  data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_DOUBLE, space_hid, 
+  data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_DOUBLE, space_hid,
                         H5P_DEFAULT);
 #endif
-  if (data_hid < 0) 
+  if (data_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
 
   double tmp = double_value ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, &tmp) >= 0;
@@ -200,25 +200,25 @@ octave_bool::load_hdf5 (hid_t loc_id, co
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
   hid_t space_id = H5Dget_space (data_hid);
 
   hsize_t rank = H5Sget_simple_extent_ndims (space_id);
 
   if (rank != 0)
-    { 
+    {
       H5Dclose (data_hid);
       return false;
     }
 
   double dtmp;
-  if (H5Dread (data_hid, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, 
+  if (H5Dread (data_hid, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL,
                H5P_DEFAULT, &dtmp) < 0)
-    { 
+    {
       H5Dclose (data_hid);
       return false;
     }
 
   scalar = (dtmp != 0.);
 
   H5Dclose (data_hid);
 
diff --git a/src/ov-bool.h b/src/ov-bool.h
--- a/src/ov-bool.h
+++ b/src/ov-bool.h
@@ -186,17 +186,17 @@ public:
   octave_value convert_to_str_internal (bool pad, bool force, char type) const;
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
-  bool load_binary (std::istream& is, bool swap, 
+  bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
diff --git a/src/ov-builtin.h b/src/ov-builtin.h
--- a/src/ov-builtin.h
+++ b/src/ov-builtin.h
@@ -67,17 +67,17 @@ public:
   octave_function *function_value (bool = false) { return this; }
 
   bool is_builtin_function (void) const { return true; }
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args);
 
   octave_value_list
-  do_multi_index_op (int nargout, const octave_value_list& args, 
+  do_multi_index_op (int nargout, const octave_value_list& args,
                      const std::list<octave_lvalue>* lvalue_list);
 
   static const std::list<octave_lvalue> *curr_lvalue_list;
 
 protected:
 
   // A pointer to the actual function.
   fcn f;
diff --git a/src/ov-cell.cc b/src/ov-cell.cc
--- a/src/ov-cell.cc
+++ b/src/ov-cell.cc
@@ -102,20 +102,20 @@ octave_base_matrix<Cell>::fast_elem_extr
   if (n < matrix.numel ())
     return Cell (matrix(n));
   else
     return octave_value ();
 }
 
 template <>
 bool
-octave_base_matrix<Cell>::fast_elem_insert (octave_idx_type n, 
+octave_base_matrix<Cell>::fast_elem_insert (octave_idx_type n,
                                             const octave_value& x)
 {
-  const octave_cell *xrep = 
+  const octave_cell *xrep =
     dynamic_cast<const octave_cell *> (&x.get_rep ());
 
   bool retval = xrep && xrep->matrix.numel () == 1 && n < matrix.numel ();
   if (retval)
     matrix(n) = xrep->matrix(0);
 
   return retval;
 }
@@ -308,17 +308,17 @@ octave_cell::subsasgn (const std::string
                     tmpc = Cell ();
 
                     if (! tmp.is_defined () || tmp.is_zero_by_zero ())
                       {
                         tmp = octave_value::empty_conv (type.substr (1), rhs);
                         tmp.make_unique (); // probably a no-op.
                       }
                     else
-                      // optimization: ignore the copy still stored inside our array. 
+                      // optimization: ignore the copy still stored inside our array.
                       tmp.make_unique (1);
 
                     if (! error_state)
                       t_rhs = tmp.subsasgn (next_type, next_idx, rhs);
                   }
                 else
                   gripe_indexed_cs_list ();
               }
@@ -430,49 +430,49 @@ octave_cell::subsasgn (const std::string
         default:
           panic_impossible ();
         }
     }
 
   return retval;
 }
 
-bool 
+bool
 octave_cell::is_cellstr (void) const
 {
   bool retval;
   if (cellstr_cache.get ())
     retval = true;
   else
     {
       retval = matrix.is_cellstr ();
       // Allocate empty cache to mark that this is indeed a cellstr.
       if (retval)
         cellstr_cache.reset (new Array<std::string> ());
     }
 
   return retval;
 }
 
-void 
+void
 octave_cell::assign (const octave_value_list& idx, const Cell& rhs)
 {
   clear_cellstr_cache ();
   octave_base_matrix<Cell>::assign (idx, rhs);
 }
 
-void 
+void
 octave_cell::assign (const octave_value_list& idx, const octave_value& rhs)
 {
   clear_cellstr_cache ();
   octave_base_matrix<Cell>::assign (idx, rhs);
 }
 
 
-void 
+void
 octave_cell::delete_elements (const octave_value_list& idx)
 {
   clear_cellstr_cache ();
   octave_base_matrix<Cell>::delete_elements (idx);
 }
 
 size_t
 octave_cell::byte_size (void) const
@@ -496,17 +496,17 @@ octave_cell::sort (octave_idx_type dim, 
 
       tmp = tmp.sort (dim, mode);
 
       // We already have the cache.
       retval = new octave_cell (tmp);
     }
   else
     error ("sort: only cell arrays of character strings may be sorted");
-  
+
   return retval;
 }
 
 octave_value
 octave_cell::sort (Array<octave_idx_type> &sidx, octave_idx_type dim,
                    sortmode mode) const
 {
   octave_value retval;
@@ -517,34 +517,34 @@ octave_cell::sort (Array<octave_idx_type
 
       tmp = tmp.sort (sidx, dim, mode);
 
       // We already have the cache.
       retval = new octave_cell (tmp);
     }
   else
     error ("sort: only cell arrays of character strings may be sorted");
-  
+
   return retval;
 }
 
-sortmode 
+sortmode
 octave_cell::is_sorted (sortmode mode) const
 {
   sortmode retval = UNSORTED;
 
   if (is_cellstr ())
     {
       Array<std::string> tmp = cellstr_value ();
 
       retval = tmp.is_sorted (mode);
     }
   else
     error ("issorted: not a cell array of strings");
-  
+
   return retval;
 }
 
 
 Array<octave_idx_type>
 octave_cell::sort_rows_idx (sortmode mode) const
 {
   Array<octave_idx_type> retval;
@@ -552,34 +552,34 @@ octave_cell::sort_rows_idx (sortmode mod
   if (is_cellstr ())
     {
       Array<std::string> tmp = cellstr_value ();
 
       retval = tmp.sort_rows_idx (mode);
     }
   else
     error ("sortrows: only cell arrays of character strings may be sorted");
-  
+
   return retval;
 }
 
-sortmode 
+sortmode
 octave_cell::is_sorted_rows (sortmode mode) const
 {
   sortmode retval = UNSORTED;
 
   if (is_cellstr ())
     {
       Array<std::string> tmp = cellstr_value ();
 
       retval = tmp.is_sorted_rows (mode);
     }
   else
     error ("issorted: not a cell array of strings");
-  
+
   return retval;
 }
 
 bool
 octave_cell::is_true (void) const
 {
   error ("invalid conversion from cell array to logical value");
   return false;
@@ -741,71 +741,71 @@ octave_cell::print_raw (std::ostream& os
       dim_vector dv = matrix.dims ();
       os << "{" << dv.str () << " Cell Array}";
       newline (os);
     }
 }
 
 #define CELL_ELT_TAG "<cell-element>"
 
-bool 
+bool
 octave_cell::save_ascii (std::ostream& os)
 {
   dim_vector d = dims ();
   if (d.length () > 2)
     {
       os << "# ndims: " << d.length () << "\n";
-      
+
       for (int i = 0; i < d.length (); i++)
         os << " " << d (i);
       os << "\n";
 
       Cell tmp = cell_value ();
-      
+
       for (octave_idx_type i = 0; i < d.numel (); i++)
         {
           octave_value o_val = tmp.elem (i);
 
           // Recurse to print sub-value.
           bool b = save_ascii_data (os, o_val, CELL_ELT_TAG, false, 0);
-              
+
           if (! b)
             return os;
         }
     }
   else
     {
-      // Keep this case, rather than use generic code above for backward 
+      // Keep this case, rather than use generic code above for backward
       // compatiability. Makes load_ascii much more complex!!
       os << "# rows: " << rows () << "\n"
          << "# columns: " << columns () << "\n";
 
       Cell tmp = cell_value ();
-      
+
       for (octave_idx_type j = 0; j < tmp.cols (); j++)
         {
           for (octave_idx_type i = 0; i < tmp.rows (); i++)
             {
               octave_value o_val = tmp.elem (i, j);
 
               // Recurse to print sub-value.
               bool b = save_ascii_data (os, o_val, CELL_ELT_TAG, false, 0);
-              
+
               if (! b)
                 return os;
             }
-          
+
           os << "\n";
         }
     }
 
   return true;
 }
 
-bool 
+bool
 octave_cell::load_ascii (std::istream& is)
 {
   bool success = true;
 
   clear_cellstr_cache ();
 
   string_vector keywords(2);
 
@@ -832,17 +832,17 @@ octave_cell::load_ascii (std::istream& i
               Cell tmp(dv);
 
               for (octave_idx_type i = 0; i < dv.numel (); i++)
                 {
                   octave_value t2;
                   bool dummy;
 
                   // recurse to read cell elements
-                  std::string nm = read_ascii_data (is, std::string (), 
+                  std::string nm = read_ascii_data (is, std::string (),
                                                     dummy, t2, i);
 
                   if (nm == CELL_ELT_TAG)
                     {
                       if (is)
                         tmp.elem (i) = t2;
                     }
                   else
@@ -897,17 +897,17 @@ octave_cell::load_ascii (std::istream& i
                           else
                             {
                               error ("load: cell array element had unexpected name");
                               success = false;
                               goto cell_read_error;
                             }
                         }
                     }
-              
+
                 cell_read_error:
 
                   if (is)
                     matrix = tmp;
                   else
                     {
                       error ("load: failed to load cell element");
                       success = false;
@@ -931,50 +931,50 @@ octave_cell::load_ascii (std::istream& i
     {
       error ("load: failed to extract number of rows and columns");
       success = false;
     }
 
   return success;
 }
 
-bool 
+bool
 octave_cell::save_binary (std::ostream& os, bool& save_as_floats)
 {
   dim_vector d = dims ();
   if (d.length () < 1)
     return false;
 
   // Use negative value for ndims
   int32_t di = - d.length();
   os.write (reinterpret_cast<char *> (&di), 4);
   for (int i = 0; i < d.length (); i++)
     {
       di = d(i);
       os.write (reinterpret_cast<char *> (&di), 4);
     }
-  
+
   Cell tmp = cell_value ();
-      
+
   for (octave_idx_type i = 0; i < d.numel (); i++)
     {
       octave_value o_val = tmp.elem (i);
 
       // Recurse to print sub-value.
-      bool b = save_binary_data (os, o_val, CELL_ELT_TAG, "", 0, 
+      bool b = save_binary_data (os, o_val, CELL_ELT_TAG, "", 0,
                                  save_as_floats);
-              
+
       if (! b)
         return false;
     }
-  
+
   return true;
 }
 
-bool 
+bool
 octave_cell::load_binary (std::istream& is, bool swap,
                           oct_mach_info::float_format fmt)
 {
   clear_cellstr_cache ();
 
   bool success = true;
   int32_t mdims;
   if (! is.read (reinterpret_cast<char *> (&mdims), 4))
@@ -992,17 +992,17 @@ octave_cell::load_binary (std::istream& 
   for (int i = 0; i < mdims; i++)
     {
       if (! is.read (reinterpret_cast<char *> (&di), 4))
         return false;
       if (swap)
         swap_bytes<4> (&di);
       dv(i) = di;
     }
-  
+
   // Convert an array with a single dimension to be a row vector.
   // Octave should never write files like this, other software
   // might.
 
   if (mdims == 1)
     {
       mdims = 2;
       dv.resize (mdims);
@@ -1015,17 +1015,17 @@ octave_cell::load_binary (std::istream& 
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       octave_value t2;
       bool dummy;
       std::string doc;
 
       // recurse to read cell elements
-      std::string nm = read_binary_data (is, swap, fmt, std::string (), 
+      std::string nm = read_binary_data (is, swap, fmt, std::string (),
                                          dummy, t2, doc);
 
       if (nm == CELL_ELT_TAG)
         {
           if (is)
             tmp.elem (i) = t2;
         }
       else
@@ -1059,53 +1059,53 @@ octave_cell::mex_get_data (void) const
 bool
 octave_cell::save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats)
 {
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
-  hsize_t rank = dv.length (); 
+  hsize_t rank = dv.length ();
   hid_t space_hid = -1, data_hid = -1, size_hid = -1;
 
 #if HAVE_HDF5_18
   data_hid = H5Gcreate (loc_id, name, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Gcreate (loc_id, name, 0);
 #endif
 
   if (data_hid < 0)
     return false;
 
-  // Have to save cell array shape, since can't have a 
+  // Have to save cell array shape, since can't have a
   // dataset of groups....
 
   space_hid = H5Screate_simple (1, &rank, 0);
 
-  if (space_hid < 0) 
+  if (space_hid < 0)
     {
       H5Gclose (data_hid);
       return false;
     }
 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (hsize_t i = 0; i < rank; i++)
     hdims[i] = dv(rank-i-1);
 
 #if HAVE_HDF5_18
-  size_hid = H5Dcreate (data_hid, "dims", H5T_NATIVE_IDX, space_hid, 
+  size_hid = H5Dcreate (data_hid, "dims", H5T_NATIVE_IDX, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
-  size_hid = H5Dcreate (data_hid, "dims", H5T_NATIVE_IDX, space_hid, 
+  size_hid = H5Dcreate (data_hid, "dims", H5T_NATIVE_IDX, space_hid,
                         H5P_DEFAULT);
 #endif
-  if (size_hid < 0) 
+  if (size_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (data_hid);
       return false;
     }
 
   if (H5Dwrite (size_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
                 H5P_DEFAULT, hdims) < 0)
@@ -1170,35 +1170,35 @@ octave_cell::load_hdf5 (hid_t loc_id, co
 
 #if HAVE_HDF5_18
   hid_t data_hid = H5Dopen (group_id, "dims", H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (group_id, "dims");
 #endif
   hid_t space_hid = H5Dget_space (data_hid);
   hsize_t rank = H5Sget_simple_extent_ndims (space_hid);
-  if (rank != 1) 
+  if (rank != 1)
     {
       H5Dclose (data_hid);
       H5Gclose (group_id);
       return false;
     }
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
   OCTAVE_LOCAL_BUFFER (hsize_t, maxdims, rank);
 
   H5Sget_simple_extent_dims (space_hid, hdims, maxdims);
 
   // Octave uses column-major, while HDF5 uses row-major ordering.
 
   dv.resize (hdims[0]);
 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, tmp, hdims[0]);
-  
-  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, 
+
+  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
                H5P_DEFAULT, tmp) < 0)
     {
       H5Dclose (data_hid);
       H5Gclose (group_id);
       return false;
     }
 
   H5Dclose (data_hid);
@@ -1212,46 +1212,46 @@ octave_cell::load_hdf5 (hid_t loc_id, co
   herr_t retval2 = -1;
 
   Cell m (dv);
 
   int current_item = 0;
 
   hsize_t num_obj = 0;
 #if HAVE_HDF5_18
-  group_id = H5Gopen (loc_id, name, H5P_DEFAULT); 
+  group_id = H5Gopen (loc_id, name, H5P_DEFAULT);
 #else
-  group_id = H5Gopen (loc_id, name); 
+  group_id = H5Gopen (loc_id, name);
 #endif
   H5Gget_num_objs (group_id, &num_obj);
   H5Gclose (group_id);
 
   for (octave_idx_type i = 0; i < dv.numel (); i++)
     {
 
       if (current_item >= static_cast<int> (num_obj))
         retval2 = -1;
       else
         retval2 = H5Giterate (loc_id, name, &current_item,
                               hdf5_read_next_data, &dsub);
-      
+
       if (retval2 <= 0)
         break;
 
       octave_value ov = dsub.tc;
       m.elem (i) = ov;
 
     }
 
   if (retval2 >= 0)
     {
       matrix = m;
       retval = true;
     }
-  
+
   return retval;
 }
 
 #endif
 
 DEFUN (iscell, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} iscell (@var{x})\n\
@@ -1515,13 +1515,13 @@ octave_cell::map (unary_mapper_t umap) c
     FORWARD_MAPPER (xisprint);
     FORWARD_MAPPER (xispunct);
     FORWARD_MAPPER (xisspace);
     FORWARD_MAPPER (xisupper);
     FORWARD_MAPPER (xisxdigit);
     FORWARD_MAPPER (xtoascii);
     FORWARD_MAPPER (xtolower);
     FORWARD_MAPPER (xtoupper);
-    
+
     default:
       return octave_base_value::map (umap);
     }
 }
diff --git a/src/ov-cell.h b/src/ov-cell.h
--- a/src/ov-cell.h
+++ b/src/ov-cell.h
@@ -143,32 +143,32 @@ public:
 
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
-  bool load_binary (std::istream& is, bool swap, 
+  bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   octave_value map (unary_mapper_t umap) const;
 
   mxArray *as_mxArray (void) const;
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
-  void *mex_get_data (void) const; 
+  void *mex_get_data (void) const;
 
 private:
 
   void clear_cellstr_cache (void) const
     { cellstr_cache.reset (); }
 
   mutable std::auto_ptr<Array<std::string> > cellstr_cache;
 
diff --git a/src/ov-ch-mat.cc b/src/ov-ch-mat.cc
--- a/src/ov-ch-mat.cc
+++ b/src/ov-ch-mat.cc
@@ -35,24 +35,24 @@ along with Octave; see the file COPYING.
 #include "ov-base-mat.h"
 #include "ov-base-mat.cc"
 #include "ov-ch-mat.h"
 #include "gripes.h"
 #include "pr-output.h"
 
 template class octave_base_matrix<charNDArray>;
 
-idx_vector 
+idx_vector
 octave_char_matrix::index_vector (void) const
-{ 
+{
   const char *p = matrix.data ();
   if (numel () == 1 && *p == ':')
     return idx_vector (':');
   else
-    return idx_vector (array_value (true)); 
+    return idx_vector (array_value (true));
 }
 
 double
 octave_char_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (rows () > 0 && columns () > 0)
@@ -146,17 +146,17 @@ octave_char_matrix::as_mxArray (void) co
   const char *p = matrix.data ();
 
   for (mwIndex i = 0; i < nel; i++)
     pr[i] = p[i];
 
   return retval;
 }
 
-// The C++ standard guarantees cctype defines functions, not macros (and hence macros *CAN'T* 
+// The C++ standard guarantees cctype defines functions, not macros (and hence macros *CAN'T*
 // be defined if only cctype is included)
 // so there's no need to f*ck around. The exceptions are isascii and toascii,
 // which are not C++.
 // Oddly enough, all those character functions are int (*) (int), even
 // in C++. Wicked!
 static inline int xisascii (int c)
 { return isascii (c); }
 
@@ -183,15 +183,15 @@ octave_char_matrix::map (unary_mapper_t 
     STRING_MAPPER (xispunct, std::ispunct, bool);
     STRING_MAPPER (xisspace, std::isspace, bool);
     STRING_MAPPER (xisupper, std::isupper, bool);
     STRING_MAPPER (xisxdigit, std::isxdigit, bool);
     STRING_MAPPER (xtoascii, xtoascii, double);
     STRING_MAPPER (xtolower, std::tolower, char);
     STRING_MAPPER (xtoupper, std::toupper, char);
 
-    default: 
+    default:
       {
         octave_matrix m (array_value (true));
         return m.map (umap);
       }
     }
 }
diff --git a/src/ov-class.cc b/src/ov-class.cc
--- a/src/ov-class.cc
+++ b/src/ov-class.cc
@@ -61,17 +61,17 @@ const std::string octave_class::t_name (
 
 void
 octave_class::register_type (void)
 {
   t_id = octave_value_typeinfo::register_type
     (octave_class::t_name, "<unknown>", octave_value (new octave_class ()));
 }
 
-octave_class::octave_class (const octave_map& m, const std::string& id, 
+octave_class::octave_class (const octave_map& m, const std::string& id,
                             const octave_value_list& parents)
   : octave_base_value (), map (m), c_name (id), obsolete_copies (0)
 {
   octave_idx_type n = parents.length ();
 
   for (octave_idx_type idx = 0; idx < n; idx++)
     {
       octave_value parent = parents(idx);
@@ -94,30 +94,30 @@ octave_class::octave_class (const octave
     }
 
   if (! error_state)
     symbol_table::add_to_parent_map (id, parent_list);
 }
 
 octave_base_value *
 octave_class::unique_clone (void)
-{ 
+{
   if (count == obsolete_copies)
     {
       // All remaining copies are obsolete. We don't actually need to clone.
       count++;
       return this;
     }
   else
-    { 
+    {
       // In theory, this shouldn't be happening, but it's here just in case.
       if (count < obsolete_copies)
         obsolete_copies = 0;
 
-      return clone (); 
+      return clone ();
     }
 }
 
 std::string
 octave_class::get_current_method_class (void)
 {
   std::string retval = class_name ();
 
@@ -460,17 +460,17 @@ octave_class::subsref (const std::string
               if (type[0] != '.') tmp = idx.front ();
               true_nargout = numel (tmp);
             }
 
           retval = feval (meth.function_value (), args, true_nargout);
 
           // Since we're handling subsref, return the list in the first value
           // if it has more than one element, to be able to pass through
-          // rvalue1 calls. 
+          // rvalue1 calls.
           if (retval.length () > 1)
             retval = octave_value (retval, true);
         }
       else
         {
           if (type.length () == 1 && type[0] == '(')
             retval(0) = octave_value (map.index (idx.front ()), class_name ());
           else
@@ -761,17 +761,17 @@ octave_class::subsasgn (const std::strin
                       error ("invalid class assignment");
                   }
               }
           }
           break;
 
         case '.':
           {
-            // Find the class in which this method resides before 
+            // Find the class in which this method resides before
             // attempting to access the requested field.
 
             std::string method_class = get_current_method_class ();
 
             octave_base_value *obvp = unique_parent_class (method_class);
 
             if (obvp)
               {
@@ -829,21 +829,21 @@ octave_class::index_vector (void) const
 
       octave_value_list tmp = feval (meth.function_value (), args, 1);
 
       if (!error_state && tmp.length () >= 1)
         {
           if (tmp(0).is_object())
             error ("subsindex function must return a valid index vector");
           else
-            // Index vector returned by subsindex is zero based 
+            // Index vector returned by subsindex is zero based
             // (why this inconsistency Mathworks?), and so we must
             // add one to the value returned as the index_vector method
             // expects it to be one based.
-            retval = do_binary_op (octave_value::op_add, tmp (0), 
+            retval = do_binary_op (octave_value::op_add, tmp (0),
                                    octave_value (1.0)).index_vector ();
         }
     }
   else
     error ("no subsindex method defined for class %s",
            class_name().c_str ());
 
   return retval;
@@ -970,28 +970,28 @@ octave_class::print_name_tag (std::ostre
   os << name << " =";
   newline (os);
   newline (os);
 
   return retval;
 }
 
 void
-octave_class::print_with_name (std::ostream& os, const std::string& name, 
+octave_class::print_with_name (std::ostream& os, const std::string& name,
                                bool)
 {
   octave_value fcn = symbol_table::find_method ("display", class_name ());
 
   if (fcn.is_defined ())
     {
       octave_value_list args;
 
       count++;
       args(0) = octave_value (this);
-      
+
       string_vector arg_names (1);
 
       arg_names[0] = name;
 
       args.stash_name_tags (arg_names);
 
       feval (fcn.function_value (), args);
     }
@@ -999,17 +999,17 @@ octave_class::print_with_name (std::ostr
     {
       indent (os);
       os << name << " = <class " << class_name () << ">";
       newline (os);
     }
 }
 
 // Loading a class properly requires an exemplar map entry for success.
-// If we don't have one, we attempt to create one by calling the constructor 
+// If we don't have one, we attempt to create one by calling the constructor
 // with no arguments.
 bool
 octave_class::reconstruct_exemplar (void)
 {
   bool retval = false;
 
   octave_class::exemplar_const_iterator it
     = octave_class::exemplar_map.find (c_name);
@@ -1066,17 +1066,17 @@ octave_class::reconstruct_parents (void)
           if( key == val(0).class_name() )
             {
               might_have_inheritance = true;
               dbgstr = "cork";
               break;
             }
         }
     }
-  
+
   if (might_have_inheritance)
     {
       octave_class::exemplar_const_iterator it
         = octave_class::exemplar_map.find (c_name);
 
       if (it == octave_class::exemplar_map.end ())
         retval = false;
       else
@@ -1121,27 +1121,27 @@ octave_class::save_ascii (std::ostream& 
   os << "# length: " << m.nfields () << "\n";
 
   octave_map::iterator i = m.begin ();
   while (i != m.end ())
     {
       octave_value val = map.contents (i);
 
       bool b = save_ascii_data (os, val, m.key (i), false, 0);
-      
+
       if (! b)
         return os;
 
       i++;
     }
 
   return true;
 }
 
-bool 
+bool
 octave_class::load_ascii (std::istream& is)
 {
   octave_idx_type len = 0;
   std::string classname;
   bool success = true;
 
   if (extract_keyword (is, "classname", classname) && classname != "")
     {
@@ -1169,23 +1169,23 @@ octave_class::load_ascii (std::istream& 
                     {
                       error ("load: internal error loading class elements");
                       return false;
                     }
 
                   m.assign (nm, tcell);
                 }
 
-              if (is) 
+              if (is)
                 {
                   c_name = classname;
                   reconstruct_exemplar ();
 
                   map = m;
-                  
+
                   if (! reconstruct_parents ())
                     warning ("load: unable to reconstruct object inheritance");
                   else
                     {
                       if (load_path::find_method (classname, "loadobj")
                           != std::string ())
                         {
                           octave_value in = new octave_class (*this);
@@ -1207,32 +1207,32 @@ octave_class::load_ascii (std::istream& 
           else if (len == 0 )
             {
               map = octave_map (dim_vector (1, 1));
               c_name = classname;
             }
           else
             panic_impossible ();
         }
-      else 
+      else
         {
           error ("load: failed to extract number of elements in class");
           success = false;
         }
     }
   else
     {
       error ("load: failed to extract name of class");
       success = false;
     }
 
   return success;
 }
 
-bool 
+bool
 octave_class::save_binary (std::ostream& os, bool& save_as_floats)
 {
   int32_t classname_len = class_name().length ();
 
   os.write (reinterpret_cast<char *> (&classname_len), 4);
   os << class_name ();
 
   octave_map m;
@@ -1245,34 +1245,34 @@ octave_class::save_binary (std::ostream&
       else
         return false;
     }
   else
     m = map_value ();
 
   int32_t len = m.nfields();
   os.write (reinterpret_cast<char *> (&len), 4);
-  
+
   octave_map::iterator i = m.begin ();
   while (i != m.end ())
     {
       octave_value val = map.contents (i);
 
       bool b = save_binary_data (os, val, m.key (i), "", 0, save_as_floats);
-      
+
       if (! b)
         return os;
 
       i++;
     }
 
   return true;
 }
 
-bool 
+bool
 octave_class::load_binary (std::istream& is, bool swap,
                             oct_mach_info::float_format fmt)
 {
   bool success = true;
 
   int32_t classname_len;
 
   is.read (reinterpret_cast<char *> (&classname_len), 4);
@@ -1302,34 +1302,34 @@ octave_class::load_binary (std::istream&
 
       for (octave_idx_type j = 0; j < len; j++)
         {
           octave_value t2;
           bool dummy;
           std::string doc;
 
           // recurse to read cell elements
-          std::string nm = read_binary_data (is, swap, fmt, std::string (), 
+          std::string nm = read_binary_data (is, swap, fmt, std::string (),
                                              dummy, t2, doc);
 
           if (! is)
             break;
 
           Cell tcell = t2.is_cell () ? t2.cell_value () : Cell (t2);
- 
+
           if (error_state)
             {
               error ("load: internal error loading class elements");
               return false;
             }
 
           m.assign (nm, tcell);
         }
 
-      if (is) 
+      if (is)
         {
           map = m;
 
           if (! reconstruct_parents ())
             warning ("load: unable to reconstruct object inheritance");
           else
             {
               if (load_path::find_method (c_name, "loadobj") != std::string ())
@@ -1391,17 +1391,17 @@ octave_class::save_hdf5 (hid_t loc_id, c
     goto error_cleanup;
 #if HAVE_HDF5_18
   class_hid = H5Dcreate (group_hid, "classname",  type_hid, space_hid,
                          H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   class_hid = H5Dcreate (group_hid, "classname",  type_hid, space_hid,
                          H5P_DEFAULT);
 #endif
-  if (class_hid < 0 || H5Dwrite (class_hid, type_hid, H5S_ALL, H5S_ALL, 
+  if (class_hid < 0 || H5Dwrite (class_hid, type_hid, H5S_ALL, H5S_ALL,
                                     H5P_DEFAULT, c_name.c_str ()) < 0)
     goto error_cleanup;
 
 #if HAVE_HDF5_18
   data_hid = H5Gcreate (group_hid, "value", H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Gcreate (group_hid, "value", 0);
 #endif
@@ -1421,17 +1421,17 @@ octave_class::save_hdf5 (hid_t loc_id, c
     m = map_value ();
 
   // recursively add each element of the class to this group
   i = m.begin ();
   while (i != m.end ())
     {
       octave_value val = map.contents (i);
 
-      bool retval2 = add_hdf5_data (data_hid, val, m.key (i), "", false, 
+      bool retval2 = add_hdf5_data (data_hid, val, m.key (i), "", false,
                                     save_as_floats);
 
       if (! retval2)
         break;
 
       i++;
     }
 
@@ -1450,27 +1450,27 @@ octave_class::save_hdf5 (hid_t loc_id, c
     H5Tclose (type_hid);
 
   if (group_hid > 0)
     H5Gclose (group_hid);
 
   return true;
 }
 
-bool 
+bool
 octave_class::load_hdf5 (hid_t loc_id, const char *name)
 {
   bool retval = false;
 
   hid_t group_hid = -1;
   hid_t data_hid = -1;
   hid_t type_hid = -1;
   hid_t type_class_hid = -1;
   hid_t space_hid = -1;
-  hid_t subgroup_hid = -1; 
+  hid_t subgroup_hid = -1;
   hid_t st_id = -1;
 
   hdf5_callback_data dsub;
 
   herr_t retval2 = 0;
   octave_map m (dim_vector (1, 1));
   int current_item = 0;
   hsize_t num_obj = 0;
@@ -1495,17 +1495,17 @@ octave_class::load_hdf5 (hid_t loc_id, c
     goto error_cleanup;
 
   type_hid = H5Dget_type (data_hid);
 
   type_class_hid = H5Tget_class (type_hid);
 
   if (type_class_hid != H5T_STRING)
     goto error_cleanup;
-          
+
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 0)
     goto error_cleanup;
 
   slen = H5Tget_size (type_hid);
   if (slen < 0)
@@ -1515,50 +1515,50 @@ octave_class::load_hdf5 (hid_t loc_id, c
   do
     {
       OCTAVE_LOCAL_BUFFER (char, classname, slen);
 
       // create datatype for (null-terminated) string to read into:
       st_id = H5Tcopy (H5T_C_S1);
       H5Tset_size (st_id, slen);
 
-      if (H5Dread (data_hid, st_id, H5S_ALL, H5S_ALL, H5P_DEFAULT, 
+      if (H5Dread (data_hid, st_id, H5S_ALL, H5S_ALL, H5P_DEFAULT,
                    classname) < 0)
         {
           H5Tclose (st_id);
           H5Dclose (data_hid);
           H5Gclose (group_hid);
           return false;
         }
-     
+
       H5Tclose (st_id);
       H5Dclose (data_hid);
       data_hid = -1;
 
       c_name = classname;
     }
   while (0);
   reconstruct_exemplar ();
 
 #if HAVE_HDF5_18
-  subgroup_hid = H5Gopen (group_hid, name, H5P_DEFAULT); 
+  subgroup_hid = H5Gopen (group_hid, name, H5P_DEFAULT);
 #else
-  subgroup_hid = H5Gopen (group_hid, name); 
+  subgroup_hid = H5Gopen (group_hid, name);
 #endif
   H5Gget_num_objs (subgroup_hid, &num_obj);
   H5Gclose (subgroup_hid);
 
   while (current_item < static_cast<int> (num_obj)
          && (retval2 = H5Giterate (group_hid, name, &current_item,
                                    hdf5_read_next_data, &dsub)) > 0)
     {
       octave_value t2 = dsub.tc;
 
       Cell tcell = t2.is_cell () ? t2.cell_value () : Cell (t2);
- 
+
       if (error_state)
         {
           error ("load: internal error loading class elements");
           return false;
         }
 
       m.assign (dsub.name, tcell);
 
@@ -1584,17 +1584,17 @@ octave_class::load_hdf5 (hid_t loc_id, c
                 }
               else
                 retval = false;
             }
           else
             retval = true;
         }
     }
-  
+
  error_cleanup:
   if (data_hid > 0)
     H5Dclose (data_hid);
 
   if (data_hid > 0)
     H5Gclose (group_hid);
 
   return retval;
@@ -1917,17 +1917,17 @@ object @var{x} or the named class.\n\
               octave_stdout << "Methods for class " << class_name << ":\n\n";
 
               sv.list_in_columns (octave_stdout);
 
               octave_stdout << std::endl;
             }
           else
             retval = Cell (sv);
-        }         
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 static bool
diff --git a/src/ov-class.h b/src/ov-class.h
--- a/src/ov-class.h
+++ b/src/ov-class.h
@@ -45,30 +45,30 @@ class tree_walker;
 // Data structures.
 
 class
 octave_class : public octave_base_value
 {
 public:
 
   octave_class (void)
-    : octave_base_value (), map (), c_name (), 
-      parent_list (), obsolete_copies (0)  
+    : octave_base_value (), map (), c_name (),
+      parent_list (), obsolete_copies (0)
     { }
 
   octave_class (const octave_map& m, const std::string& id)
-    : octave_base_value (), map (m), c_name (id), 
-      parent_list (), obsolete_copies (0) 
+    : octave_base_value (), map (m), c_name (id),
+      parent_list (), obsolete_copies (0)
     { }
 
   octave_class (const octave_class& s)
     : octave_base_value (s), map (s.map), c_name (s.c_name),
       parent_list (s.parent_list), obsolete_copies (0)  { }
 
-  octave_class (const octave_map& m, const std::string& id, 
+  octave_class (const octave_map& m, const std::string& id,
                 const octave_value_list& parents);
 
   ~octave_class (void) { }
 
   octave_base_value *clone (void) const { return new octave_class (*this); }
 
   octave_base_value *unique_clone (void);
 
@@ -76,17 +76,17 @@ public:
   {
     return new octave_class (octave_map (map.keys ()), class_name ());
   }
 
   Cell dotref (const octave_value_list& idx);
 
   Matrix size (void);
 
-  octave_idx_type numel (const octave_value_list&); 
+  octave_idx_type numel (const octave_value_list&);
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx)
     {
       octave_value_list tmp = subsref (type, idx, 1);
       return tmp.length () > 0 ? tmp(0) : octave_value ();
     }
 
@@ -149,32 +149,32 @@ public:
   octave_base_value *unique_parent_class (const std::string&);
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   bool print_name_tag (std::ostream& os, const std::string& name) const;
 
-  void print_with_name (std::ostream& os, const std::string& name, 
+  void print_with_name (std::ostream& os, const std::string& name,
                         bool print_padding = true);
 
   bool reconstruct_exemplar (void);
 
   static void clear_exemplar_map (void);
 
   bool reconstruct_parents (void);
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
-  bool load_binary (std::istream& is, bool swap, 
+  bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
diff --git a/src/ov-complex.cc b/src/ov-complex.cc
--- a/src/ov-complex.cc
+++ b/src/ov-complex.cc
@@ -215,17 +215,17 @@ octave_complex::complex_array_value (boo
 }
 
 FloatComplexNDArray
 octave_complex::float_complex_array_value (bool /* force_conversion */) const
 {
   return FloatComplexNDArray (dim_vector (1, 1), static_cast<FloatComplex> (scalar));
 }
 
-octave_value 
+octave_value
 octave_complex::resize (const dim_vector& dv, bool fill) const
 {
   if (fill)
     {
       ComplexNDArray retval (dv, ComplexNDArray::resize_fill_value ());
 
       if (dv.numel ())
         retval(0) = scalar;
@@ -238,55 +238,55 @@ octave_complex::resize (const dim_vector
 
       if (dv.numel ())
         retval(0) = scalar;
 
       return retval;
     }
 }
 
-bool 
+bool
 octave_complex::save_ascii (std::ostream& os)
 {
   Complex c = complex_value ();
 
   octave_write_complex (os, c);
 
   os << "\n";
 
   return true;
 }
 
-bool 
+bool
 octave_complex::load_ascii (std::istream& is)
 {
   scalar = octave_read_value<Complex> (is);
 
-  if (!is) 
+  if (!is)
     {
       error ("load: failed to load complex scalar constant");
       return false;
     }
 
   return true;
 }
 
 
-bool 
+bool
 octave_complex::save_binary (std::ostream& os, bool& /* save_as_floats */)
 {
   char tmp = static_cast<char> (LS_DOUBLE);
   os.write (reinterpret_cast<char *> (&tmp), 1);
   Complex ctmp = complex_value ();
   os.write (reinterpret_cast<char *> (&ctmp), 16);
 
   return true;
 }
 
-bool 
+bool
 octave_complex::load_binary (std::istream& is, bool swap,
                              oct_mach_info::float_format fmt)
 {
   char tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), 1))
     return false;
 
   Complex ctmp;
@@ -309,36 +309,36 @@ octave_complex::save_hdf5 (hid_t loc_id,
   hid_t space_hid = -1, type_hid = -1, data_hid = -1;
   bool retval = true;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0)
     return false;
 
   type_hid = hdf5_make_complex_type (H5T_NATIVE_DOUBLE);
-  if (type_hid < 0) 
+  if (type_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
 #if HAVE_HDF5_18
-  data_hid = H5Dcreate (loc_id, name, type_hid, space_hid, 
+  data_hid = H5Dcreate (loc_id, name, type_hid, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, type_hid, space_hid, H5P_DEFAULT);
 #endif
-  if (data_hid < 0) 
+  if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       return false;
     }
 
   Complex tmp = complex_value ();
-  retval = H5Dwrite (data_hid, type_hid, H5S_ALL, H5S_ALL, H5P_DEFAULT, 
+  retval = H5Dwrite (data_hid, type_hid, H5S_ALL, H5S_ALL, H5P_DEFAULT,
                      &tmp) >= 0;
 
   H5Dclose (data_hid);
   H5Tclose (type_hid);
   H5Sclose (space_hid);
 
   return retval;
 }
@@ -361,17 +361,17 @@ octave_complex::load_hdf5 (hid_t loc_id,
       H5Tclose (complex_type);
       H5Dclose (data_hid);
       return false;
     }
 
   hid_t space_id = H5Dget_space (data_hid);
   hsize_t rank = H5Sget_simple_extent_ndims (space_id);
 
-  if (rank != 0) 
+  if (rank != 0)
     {
       H5Tclose (complex_type);
       H5Sclose (space_id);
       H5Dclose (data_hid);
       return false;
     }
 
   // complex scalar:
diff --git a/src/ov-complex.h b/src/ov-complex.h
--- a/src/ov-complex.h
+++ b/src/ov-complex.h
@@ -159,17 +159,17 @@ public:
   void decrement (void) { scalar -= 1.0; }
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
-  bool load_binary (std::istream& is, bool swap, 
+  bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
diff --git a/src/ov-cx-diag.cc b/src/ov-cx-diag.cc
--- a/src/ov-cx-diag.cc
+++ b/src/ov-cx-diag.cc
@@ -33,17 +33,17 @@ along with Octave; see the file COPYING.
 #include "ov-complex.h"
 #include "ov-cx-mat.h"
 #include "ls-utils.h"
 
 template class octave_base_diag<ComplexDiagMatrix, ComplexMatrix>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_complex_diag_matrix);
 
-DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_complex_diag_matrix, 
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_complex_diag_matrix,
                                      "complex diagonal matrix", "double");
 
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
   CAST_CONV_ARG (const octave_complex_diag_matrix&);
 
   return new octave_complex_matrix (v.complex_matrix_value ());
@@ -154,17 +154,17 @@ octave_complex_diag_matrix::map (unary_m
         retval.resize (matrix.rows (), matrix.columns ());
         return retval;
       }
     default:
       return to_dense ().map (umap);
     }
 }
 
-bool 
+bool
 octave_complex_diag_matrix::save_binary (std::ostream& os, bool& save_as_floats)
 {
 
   int32_t r = matrix.rows (), c = matrix.cols ();
   os.write (reinterpret_cast<char *> (&r), 4);
   os.write (reinterpret_cast<char *> (&c), 4);
 
   ComplexMatrix m = ComplexMatrix (matrix.diag ());
@@ -187,17 +187,17 @@ octave_complex_diag_matrix::save_binary 
     }
 
   const Complex *mtmp = m.data ();
   write_doubles (os, reinterpret_cast<const double *> (mtmp), st, 2 * m.numel ());
 
   return true;
 }
 
-bool 
+bool
 octave_complex_diag_matrix::load_binary (std::istream& is, bool swap,
                                  oct_mach_info::float_format fmt)
 {
   int32_t r, c;
   char tmp;
   if (! (is.read (reinterpret_cast<char *> (&r), 4)
          && is.read (reinterpret_cast<char *> (&c), 4)
          && is.read (reinterpret_cast<char *> (&tmp), 1)))
@@ -215,17 +215,17 @@ octave_complex_diag_matrix::load_binary 
                 static_cast<save_type> (tmp), 2 * len, swap, fmt);
   if (error_state || ! is)
     return false;
   matrix = m;
 
   return true;
 }
 
-bool 
-octave_complex_diag_matrix::chk_valid_scalar (const octave_value& val, 
+bool
+octave_complex_diag_matrix::chk_valid_scalar (const octave_value& val,
                                               Complex& x) const
 {
   bool retval = val.is_complex_scalar () || val.is_real_scalar ();
   if (retval)
     x = val.complex_value ();
   return retval;
 }
diff --git a/src/ov-cx-diag.h b/src/ov-cx-diag.h
--- a/src/ov-cx-diag.h
+++ b/src/ov-cx-diag.h
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 #include "ov-base-diag.h"
 #include "ov-cx-mat.h"
 #include "ov-typeinfo.h"
 
 // Real diagonal matrix values.
 
 class
 OCTINTERP_API
-octave_complex_diag_matrix 
+octave_complex_diag_matrix
   : public octave_base_diag<ComplexDiagMatrix, ComplexMatrix>
 {
 public:
 
   octave_complex_diag_matrix (void)
     : octave_base_diag<ComplexDiagMatrix, ComplexMatrix> () { }
 
   octave_complex_diag_matrix (const ComplexDiagMatrix& m)
@@ -72,24 +72,24 @@ public:
   FloatDiagMatrix float_diag_matrix_value (bool = false) const;
 
   ComplexDiagMatrix complex_diag_matrix_value (bool = false) const;
 
   FloatComplexDiagMatrix float_complex_diag_matrix_value (bool = false) const;
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
-  bool load_binary (std::istream& is, bool swap, 
+  bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
-  bool chk_valid_scalar (const octave_value&, 
+  bool chk_valid_scalar (const octave_value&,
                          Complex&) const;
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/src/ov-cx-mat.cc b/src/ov-cx-mat.cc
--- a/src/ov-cx-mat.cc
+++ b/src/ov-cx-mat.cc
@@ -221,46 +221,46 @@ octave_complex_matrix::float_complex_mat
   return FloatComplexMatrix (matrix.matrix_value ());
 }
 
 boolNDArray
 octave_complex_matrix::bool_array_value (bool warn) const
 {
   if (matrix.any_element_is_nan ())
     gripe_nan_to_logical_conversion ();
-  else if (warn && (! matrix.all_elements_are_real () 
+  else if (warn && (! matrix.all_elements_are_real ()
                     || real (matrix).any_element_not_one_or_zero ()))
     gripe_logical_conversion ();
 
   return mx_el_ne (matrix, Complex (0.0));
 }
-  
+
 charNDArray
 octave_complex_matrix::char_array_value (bool frc_str_conv) const
 {
   charNDArray retval;
 
   if (! frc_str_conv)
     gripe_implicit_conversion ("Octave:num-to-str",
                                "complex matrix", "string");
   else
     {
       retval = charNDArray (dims ());
       octave_idx_type nel = numel ();
-  
+
       for (octave_idx_type i = 0; i < nel; i++)
         retval.elem (i) = static_cast<char>(std::real (matrix.elem (i)));
     }
 
   return retval;
-}  
+}
 
-FloatComplexNDArray 
-octave_complex_matrix::float_complex_array_value (bool) const 
-{ 
+FloatComplexNDArray
+octave_complex_matrix::float_complex_array_value (bool) const
+{
   return FloatComplexNDArray (matrix);
 }
 
 SparseMatrix
 octave_complex_matrix::sparse_matrix_value (bool force_conversion) const
 {
   SparseMatrix retval;
 
@@ -278,54 +278,54 @@ octave_complex_matrix::sparse_complex_ma
 {
   return SparseComplexMatrix (matrix.matrix_value ());
 }
 
 octave_value
 octave_complex_matrix::diag (octave_idx_type k) const
 {
   octave_value retval;
-  if (k == 0 && matrix.ndims () == 2 
+  if (k == 0 && matrix.ndims () == 2
       && (matrix.rows () == 1 || matrix.columns () == 1))
     retval = ComplexDiagMatrix (DiagArray2<Complex> (matrix));
   else
     retval = octave_base_matrix<ComplexNDArray>::diag (k);
 
   return retval;
 }
 
-bool 
+bool
 octave_complex_matrix::save_ascii (std::ostream& os)
 {
   dim_vector d = dims ();
   if (d.length () > 2)
     {
       ComplexNDArray tmp = complex_array_value ();
 
       os << "# ndims: " << d.length () << "\n";
 
       for (int i = 0; i < d.length (); i++)
         os << " " << d (i);
 
       os << "\n" << tmp;
     }
   else
     {
-      // Keep this case, rather than use generic code above for backward 
+      // Keep this case, rather than use generic code above for backward
       // compatiability. Makes load_ascii much more complex!!
       os << "# rows: " << rows () << "\n"
          << "# columns: " << columns () << "\n";
 
       os << complex_matrix_value ();
     }
 
   return true;
 }
 
-bool 
+bool
 octave_complex_matrix::load_ascii (std::istream& is)
 {
   bool success = true;
 
   string_vector keywords(2);
 
   keywords[0] = "ndims";
   keywords[1] = "rows";
@@ -410,17 +410,17 @@ octave_complex_matrix::load_ascii (std::
     {
       error ("load: failed to extract number of rows and columns");
       success = false;
     }
 
   return success;
 }
 
-bool 
+bool
 octave_complex_matrix::save_binary (std::ostream& os, bool& save_as_floats)
 {
   dim_vector d = dims ();
   if (d.length() < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
   int32_t tmp = - d.length();
@@ -452,17 +452,17 @@ octave_complex_matrix::save_binary (std:
 
 
   const Complex *mtmp = m.data ();
   write_doubles (os, reinterpret_cast<const double *> (mtmp), st, 2 * d.numel ());
 
   return true;
 }
 
-bool 
+bool
 octave_complex_matrix::load_binary (std::istream& is, bool swap,
                                  oct_mach_info::float_format fmt)
 {
   char tmp;
   int32_t mdims;
   if (! is.read (reinterpret_cast<char *> (&mdims), 4))
     return false;
   if (swap)
@@ -544,17 +544,17 @@ octave_complex_matrix::save_hdf5 (hid_t 
   bool retval = true;
   ComplexNDArray m = complex_array_value ();
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
     hdims[i] = dv (rank-i-1);
- 
+
   space_hid = H5Screate_simple (rank, hdims, 0);
   if (space_hid < 0) return false;
 
   hid_t save_type_hid = H5T_NATIVE_DOUBLE;
 
   if (save_as_floats)
     {
       if (m.too_large_for_float ())
@@ -565,31 +565,31 @@ octave_complex_matrix::save_hdf5 (hid_t 
       else
         save_type_hid = H5T_NATIVE_FLOAT;
     }
 #if HAVE_HDF5_INT2FLOAT_CONVERSIONS
   // hdf5 currently doesn't support float/integer conversions
   else
     {
       double max_val, min_val;
-      
+
       if (m.all_integers (max_val, min_val))
         save_type_hid
           = save_type_to_hdf5 (get_save_type (max_val, min_val));
     }
 #endif /* HAVE_HDF5_INT2FLOAT_CONVERSIONS */
 
   type_hid = hdf5_make_complex_type (save_type_hid);
   if (type_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
 #if HAVE_HDF5_18
-  data_hid = H5Dcreate (loc_id, name, type_hid, space_hid, 
+  data_hid = H5Dcreate (loc_id, name, type_hid, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, type_hid, space_hid, H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
@@ -613,17 +613,17 @@ octave_complex_matrix::save_hdf5 (hid_t 
   H5Tclose (complex_type_hid);
   H5Dclose (data_hid);
   H5Tclose (type_hid);
   H5Sclose (space_hid);
 
   return retval;
 }
 
-bool 
+bool
 octave_complex_matrix::load_hdf5 (hid_t loc_id, const char *name)
 {
   bool retval = false;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize(dv);
@@ -644,17 +644,17 @@ octave_complex_matrix::load_hdf5 (hid_t 
       H5Tclose (complex_type);
       H5Dclose (data_hid);
       return false;
     }
 
   hid_t space_id = H5Dget_space (data_hid);
 
   hsize_t rank = H5Sget_simple_extent_ndims (space_id);
-  
+
   if (rank < 1)
     {
       H5Tclose (complex_type);
       H5Sclose (space_id);
       H5Dclose (data_hid);
       return false;
     }
 
@@ -675,17 +675,17 @@ octave_complex_matrix::load_hdf5 (hid_t 
       dv.resize (rank);
       for (hsize_t i = 0, j = rank - 1; i < rank; i++, j--)
         dv(j) = hdims[i];
     }
 
   ComplexNDArray m (dv);
   Complex *reim = m.fortran_vec ();
   if (H5Dread (data_hid, complex_type, H5S_ALL, H5S_ALL, H5P_DEFAULT,
-               reim) >= 0) 
+               reim) >= 0)
     {
       retval = true;
       matrix = m;
     }
 
   H5Tclose (complex_type);
   H5Sclose (space_id);
   H5Dclose (data_hid);
diff --git a/src/ov-cx-mat.h b/src/ov-cx-mat.h
--- a/src/ov-cx-mat.h
+++ b/src/ov-cx-mat.h
@@ -123,17 +123,17 @@ public:
 
   ComplexNDArray complex_array_value (bool = false) const { return matrix; }
 
   FloatComplexNDArray float_complex_array_value (bool = false) const;
 
   boolNDArray bool_array_value (bool warn = false) const;
 
   charNDArray char_array_value (bool frc_str_conv = false) const;
-  
+
   SparseMatrix sparse_matrix_value (bool = false) const;
 
   SparseComplexMatrix sparse_complex_matrix_value (bool = false) const;
 
   octave_value diag (octave_idx_type k = 0) const;
 
   void increment (void) { matrix += Complex (1.0); }
 
@@ -142,17 +142,17 @@ public:
   void changesign (void) { matrix.changesign (); }
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
-  bool load_binary (std::istream& is, bool swap, 
+  bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
diff --git a/src/ov-cx-sparse.cc b/src/ov-cx-sparse.cc
--- a/src/ov-cx-sparse.cc
+++ b/src/ov-cx-sparse.cc
@@ -92,17 +92,17 @@ octave_sparse_complex_matrix::try_narrow
                    * double (matrix.cols ()) * sizeof (Complex)))
         retval = new octave_complex_matrix (matrix.matrix_value ());
     }
   else
     {
       if (matrix.all_elements_are_real ())
         retval = new octave_sparse_matrix (::real (matrix));
     }
-    
+
   return retval;
 }
 
 double
 octave_sparse_complex_matrix::double_value (bool force_conversion) const
 {
   double retval = lo_ieee_nan_value ();
 
@@ -162,17 +162,17 @@ octave_sparse_complex_matrix::complex_va
 }
 
 ComplexMatrix
 octave_sparse_complex_matrix::complex_matrix_value (bool) const
 {
   return matrix.matrix_value ();
 }
 
-ComplexNDArray 
+ComplexNDArray
 octave_sparse_complex_matrix::complex_array_value (bool) const
 {
   return ComplexNDArray (matrix.matrix_value ());
 }
 
 charNDArray
 octave_sparse_complex_matrix::char_array_value (bool frc_str_conv) const
 {
@@ -184,76 +184,76 @@ octave_sparse_complex_matrix::char_array
   else
     {
       retval = charNDArray (dims (), 0);
       octave_idx_type nc = matrix.cols ();
       octave_idx_type nr = matrix.rows ();
 
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = matrix.cidx(j); i < matrix.cidx(j+1); i++)
-          retval(matrix.ridx(i) + nr * j) = 
+          retval(matrix.ridx(i) + nr * j) =
             static_cast<char>(std::real (matrix.data (i)));
     }
 
   return retval;
 }
 
 SparseMatrix
 octave_sparse_complex_matrix::sparse_matrix_value (bool force_conversion) const
 {
   SparseMatrix retval;
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
-                               "complex sparse matrix", 
+                               "complex sparse matrix",
                                "real sparse matrix");
 
   retval = ::real (matrix);
 
   return retval;
 }
 
-SparseBoolMatrix 
+SparseBoolMatrix
 octave_sparse_complex_matrix::sparse_bool_matrix_value (bool warn) const
 {
   if (matrix.any_element_is_nan ())
     gripe_nan_to_logical_conversion ();
-  else if (warn && (! matrix.all_elements_are_real () 
+  else if (warn && (! matrix.all_elements_are_real ()
                     || real (matrix).any_element_not_one_or_zero ()))
     gripe_logical_conversion ();
 
   return mx_el_ne (matrix, Complex (0.0));
 }
 
-bool 
-octave_sparse_complex_matrix::save_binary (std::ostream& os, 
+bool
+octave_sparse_complex_matrix::save_binary (std::ostream& os,
                                            bool&save_as_floats)
 {
   dim_vector d = this->dims ();
   if (d.length() < 1)
     return false;
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
 
   int nr = d(0);
   int nc = d(1);
   int nz = nnz ();
 
   int32_t itmp;
   // Use negative value for ndims to be consistent with other formats
-  itmp= -2;        
+  itmp= -2;
   os.write (reinterpret_cast<char *> (&itmp), 4);
-  
-  itmp= nr;    
+
+  itmp= nr;
   os.write (reinterpret_cast<char *> (&itmp), 4);
-  
+
   itmp= nc;
   os.write (reinterpret_cast<char *> (&itmp), 4);
-  
+
   itmp= nz;
   os.write (reinterpret_cast<char *> (&itmp), 4);
 
   save_type st = LS_DOUBLE;
   if (save_as_floats)
     {
       if (matrix.too_large_for_float ())
         {
@@ -267,27 +267,27 @@ octave_sparse_complex_matrix::save_binar
     {
       double max_val, min_val;
       if (matrix.all_integers (max_val, min_val))
         st = get_save_type (max_val, min_val);
     }
 
   // add one to the printed indices to go from
   // zero-based to one-based arrays
-   for (int i = 0; i < nc+1; i++)  
+   for (int i = 0; i < nc+1; i++)
      {
        octave_quit ();
        itmp = matrix.cidx(i);
        os.write (reinterpret_cast<char *> (&itmp), 4);
      }
 
-   for (int i = 0; i < nz; i++) 
+   for (int i = 0; i < nz; i++)
      {
        octave_quit ();
-       itmp = matrix.ridx(i); 
+       itmp = matrix.ridx(i);
        os.write (reinterpret_cast<char *> (&itmp), 4);
      }
 
    write_doubles (os, reinterpret_cast<const double *> (matrix.data()), st, 2 * nz);
 
   return true;
 }
 
@@ -322,39 +322,39 @@ octave_sparse_complex_matrix::load_binar
       swap_bytes<4> (&nc);
       swap_bytes<4> (&nz);
     }
 
   SparseComplexMatrix m (static_cast<octave_idx_type> (nr),
                          static_cast<octave_idx_type> (nc),
                          static_cast<octave_idx_type> (nz));
 
-  for (int i = 0; i < nc+1; i++) 
+  for (int i = 0; i < nc+1; i++)
     {
       octave_quit ();
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
         return false;
       if (swap)
         swap_bytes<4> (&tmp);
       m.cidx(i) = tmp;
     }
 
-  for (int i = 0; i < nz; i++) 
+  for (int i = 0; i < nz; i++)
     {
       octave_quit ();
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
         return false;
       if (swap)
         swap_bytes<4> (&tmp);
       m.ridx(i) = tmp;
     }
 
   if (! is.read (reinterpret_cast<char *> (&ctmp), 1))
     return false;
-  
+
   read_doubles (is, reinterpret_cast<double *> (m.data ()),
                 static_cast<save_type> (ctmp), 2 * nz, swap, fmt);
 
   if (error_state || ! is)
     return false;
 
   if (! m.indices_ok ())
     return false;
@@ -362,17 +362,17 @@ octave_sparse_complex_matrix::load_binar
   matrix = m;
 
   return true;
 }
 
 #if defined (HAVE_HDF5)
 
 bool
-octave_sparse_complex_matrix::save_hdf5 (hid_t loc_id, const char *name, 
+octave_sparse_complex_matrix::save_hdf5 (hid_t loc_id, const char *name,
                                          bool save_as_floats)
 {
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   // Ensure that additional memory is deallocated
@@ -388,86 +388,86 @@ octave_sparse_complex_matrix::save_hdf5 
 
   hid_t space_hid = -1, data_hid = -1;
   bool retval = true;
   SparseComplexMatrix m = sparse_complex_matrix_value ();
   octave_idx_type tmp;
   hsize_t hdims[2];
 
   space_hid = H5Screate_simple (0, hdims, 0);
-  if (space_hid < 0) 
+  if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 
 #if HAVE_HDF5_18
-  data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid, 
+  data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
-  data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid, 
+  data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid,
                         H5P_DEFAULT);
 #endif
-  if (data_hid < 0) 
+  if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
-  
+
   tmp = m.rows ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, &tmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
-    }    
+    }
 
 #if HAVE_HDF5_18
-  data_hid = H5Dcreate (group_hid, "nc", H5T_NATIVE_IDX, space_hid, 
+  data_hid = H5Dcreate (group_hid, "nc", H5T_NATIVE_IDX, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
-  data_hid = H5Dcreate (group_hid, "nc", H5T_NATIVE_IDX, space_hid, 
+  data_hid = H5Dcreate (group_hid, "nc", H5T_NATIVE_IDX, space_hid,
                         H5P_DEFAULT);
 #endif
-  if (data_hid < 0) 
+  if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
-  
+
   tmp = m.cols ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, &tmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
-    }    
+    }
 
 #if HAVE_HDF5_18
-  data_hid = H5Dcreate (group_hid, "nz", H5T_NATIVE_IDX, space_hid, 
+  data_hid = H5Dcreate (group_hid, "nz", H5T_NATIVE_IDX, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
-  data_hid = H5Dcreate (group_hid, "nz", H5T_NATIVE_IDX, space_hid, 
+  data_hid = H5Dcreate (group_hid, "nz", H5T_NATIVE_IDX, space_hid,
                         H5P_DEFAULT);
 #endif
-  if (data_hid < 0) 
+  if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
-  
+
   tmp = m.nnz ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, &tmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
@@ -476,74 +476,74 @@ octave_sparse_complex_matrix::save_hdf5 
 
   H5Sclose (space_hid);
 
   hdims[0] = m.cols() + 1;
   hdims[1] = 1;
 
   space_hid = H5Screate_simple (2, hdims, 0);
 
-  if (space_hid < 0) 
+  if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 
 #if HAVE_HDF5_18
-  data_hid = H5Dcreate (group_hid, "cidx", H5T_NATIVE_IDX, space_hid, 
+  data_hid = H5Dcreate (group_hid, "cidx", H5T_NATIVE_IDX, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
-  data_hid = H5Dcreate (group_hid, "cidx", H5T_NATIVE_IDX, space_hid, 
+  data_hid = H5Dcreate (group_hid, "cidx", H5T_NATIVE_IDX, space_hid,
                         H5P_DEFAULT);
 #endif
-  if (data_hid < 0) 
+  if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
-  
+
   octave_idx_type * itmp = m.xcidx ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, itmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
-    }    
+    }
 
   H5Sclose (space_hid);
 
   hdims[0] = m.nnz ();
   hdims[1] = 1;
 
   space_hid = H5Screate_simple (2, hdims, 0);
 
-  if (space_hid < 0) 
+  if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 
 #if HAVE_HDF5_18
-  data_hid = H5Dcreate (group_hid, "ridx", H5T_NATIVE_IDX, space_hid, 
+  data_hid = H5Dcreate (group_hid, "ridx", H5T_NATIVE_IDX, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
-  data_hid = H5Dcreate (group_hid, "ridx", H5T_NATIVE_IDX, space_hid, 
+  data_hid = H5Dcreate (group_hid, "ridx", H5T_NATIVE_IDX, space_hid,
                         H5P_DEFAULT);
 #endif
-  if (data_hid < 0) 
+  if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
-  
+
   itmp = m.xridx ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, itmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
@@ -576,32 +576,32 @@ octave_sparse_complex_matrix::save_hdf5 
   hid_t type_hid = hdf5_make_complex_type (save_type_hid);
   if (type_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 #if HAVE_HDF5_18
-  data_hid = H5Dcreate (group_hid, "data", type_hid, space_hid, 
+  data_hid = H5Dcreate (group_hid, "data", type_hid, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "data", type_hid, space_hid, H5P_DEFAULT);
-#endif  
+#endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   hid_t complex_type_hid = hdf5_make_complex_type (H5T_NATIVE_DOUBLE);
   retval = false;
-  if (complex_type_hid >= 0) 
+  if (complex_type_hid >= 0)
     {
       Complex * ctmp = m.xdata ();
 
       retval = H5Dwrite (data_hid, complex_type_hid, H5S_ALL, H5S_ALL,
                          H5P_DEFAULT, ctmp) >= 0;
     }
 
   H5Dclose (data_hid);
@@ -613,96 +613,96 @@ octave_sparse_complex_matrix::save_hdf5 
 }
 
 bool
 octave_sparse_complex_matrix::load_hdf5 (hid_t loc_id, const char *name)
 {
   octave_idx_type nr, nc, nz;
   hid_t group_hid, data_hid, space_hid;
   hsize_t rank;
-  
+
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize(dv);
   if (empty)
     return (empty > 0);
-  
+
 #if HAVE_HDF5_18
   group_hid = H5Gopen (loc_id, name, H5P_DEFAULT);
 #else
   group_hid = H5Gopen (loc_id, name);
 #endif
   if (group_hid < 0 ) return false;
 
 #if HAVE_HDF5_18
   data_hid = H5Dopen (group_hid, "nr", H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "nr");
 #endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 0)
-    { 
+    {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, &nr) < 0)
-    { 
+    {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
 
 #if HAVE_HDF5_18
   data_hid = H5Dopen (group_hid, "nc", H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "nc");
 #endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 0)
-    { 
+    {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, &nc) < 0)
-    { 
+    {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
 
 #if HAVE_HDF5_18
   data_hid = H5Dopen (group_hid, "nz", H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "nz");
 #endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 0)
-    { 
+    {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, &nz) < 0)
-    { 
+    {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
 
   SparseComplexMatrix m (static_cast<octave_idx_type> (nr),
@@ -735,17 +735,17 @@ octave_sparse_complex_matrix::load_hdf5 
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   octave_idx_type *itmp = m.xcidx ();
-  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, itmp) < 0) 
+  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, itmp) < 0)
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
@@ -774,17 +774,17 @@ octave_sparse_complex_matrix::load_hdf5 
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   itmp = m.xridx ();
-  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, itmp) < 0) 
+  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, itmp) < 0)
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
diff --git a/src/ov-cx-sparse.h b/src/ov-cx-sparse.h
--- a/src/ov-cx-sparse.h
+++ b/src/ov-cx-sparse.h
@@ -59,28 +59,28 @@ public:
     : octave_base_sparse<SparseComplexMatrix> (SparseComplexMatrix (m)) { }
 
   octave_sparse_complex_matrix (const ComplexMatrix& m)
     : octave_base_sparse<SparseComplexMatrix> (SparseComplexMatrix (m)) { }
 
   octave_sparse_complex_matrix (const SparseComplexMatrix& m)
     : octave_base_sparse<SparseComplexMatrix> (m) { }
 
-  octave_sparse_complex_matrix (const SparseComplexMatrix& m, 
+  octave_sparse_complex_matrix (const SparseComplexMatrix& m,
                                 const MatrixType &t)
     : octave_base_sparse<SparseComplexMatrix> (m, t) { }
 
   octave_sparse_complex_matrix (const MSparse<Complex>& m)
     : octave_base_sparse<SparseComplexMatrix> (m) { }
 
-  octave_sparse_complex_matrix (const MSparse<Complex>& m, 
+  octave_sparse_complex_matrix (const MSparse<Complex>& m,
                                 const MatrixType &t)
     : octave_base_sparse<SparseComplexMatrix> (m, t) { }
 
-  octave_sparse_complex_matrix (const Sparse<Complex>& m, 
+  octave_sparse_complex_matrix (const Sparse<Complex>& m,
                                 const MatrixType &t)
     : octave_base_sparse<SparseComplexMatrix> (SparseComplexMatrix (m), t) { }
 
   octave_sparse_complex_matrix (const Sparse<Complex>& m)
     : octave_base_sparse<SparseComplexMatrix> (SparseComplexMatrix (m)) { }
 
   octave_sparse_complex_matrix (const octave_sparse_complex_matrix& cm)
     : octave_base_sparse<SparseComplexMatrix> (cm) { }
@@ -132,17 +132,17 @@ public:
       // Yes, for compatibility, we drop the imaginary part here.
       return os.write (matrix_value (true), block_size, output_type,
                        skip, flt_fmt);
     }
 #endif
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
-  bool load_binary (std::istream& is, bool swap, 
+  bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
diff --git a/src/ov-dld-fcn.h b/src/ov-dld-fcn.h
--- a/src/ov-dld-fcn.h
+++ b/src/ov-dld-fcn.h
@@ -39,18 +39,18 @@ class octave_value_list;
 // Dynamically-linked functions.
 
 class
 OCTINTERP_API
 octave_dld_function : public octave_builtin
 {
 public:
 
-  octave_dld_function (void) 
-    : sh_lib (), t_checked (), system_fcn_file () 
+  octave_dld_function (void)
+    : sh_lib (), t_checked (), system_fcn_file ()
   { }
 
   octave_dld_function (octave_builtin::fcn ff, const octave_shlib& shl,
                        const std::string& nm = std::string (),
                        const std::string& ds = std::string ());
 
   ~octave_dld_function (void);
 
@@ -62,17 +62,17 @@ public:
 
   octave_time time_checked (void) const { return t_checked; }
 
   bool is_system_fcn_file (void) const { return system_fcn_file; }
 
   bool is_builtin_function (void) const { return false; }
 
   bool is_dld_function (void) const { return true; }
-  
+
   static octave_dld_function* create (octave_builtin::fcn ff,
       const octave_shlib& shl,
       const std::string& nm = std::string (),
       const std::string& ds = std::string ());
 
   octave_shlib get_shlib (void) const
     { return sh_lib; }
 
diff --git a/src/ov-fcn-handle.cc b/src/ov-fcn-handle.cc
--- a/src/ov-fcn-handle.cc
+++ b/src/ov-fcn-handle.cc
@@ -126,24 +126,24 @@ octave_fcn_handle::subsref (const std::s
 
   if (idx.size () > 1)
     retval = retval(0).next_subsref (nargout, type, idx);
 
   return retval;
 }
 
 octave_value_list
-octave_fcn_handle::do_multi_index_op (int nargout, 
+octave_fcn_handle::do_multi_index_op (int nargout,
                                       const octave_value_list& args)
 {
   return do_multi_index_op (nargout, args, 0);
 }
 
 octave_value_list
-octave_fcn_handle::do_multi_index_op (int nargout, 
+octave_fcn_handle::do_multi_index_op (int nargout,
                                       const octave_value_list& args,
                                       const std::list<octave_lvalue>* lvalue_list)
 {
   octave_value_list retval;
 
   out_of_date_check (fcn, std::string (), false);
 
   if (has_overloads)
@@ -185,17 +185,17 @@ octave_fcn_handle::do_multi_index_op (in
         retval = fcn.do_multi_index_op (nargout, args, lvalue_list);
       else
         error ("%s: no longer valid function handle", nm.c_str ());
     }
 
   return retval;
 }
 
-bool 
+bool
 octave_fcn_handle::is_equal_to (const octave_fcn_handle& h) const
 {
   bool retval = fcn.is_copy_of (h.fcn) && (has_overloads == h.has_overloads);
   retval = retval && (overloads.size () == h.overloads.size ());
 
   if (retval && has_overloads)
     {
       for (int i = 0; i < btyp_num_types && retval; i++)
@@ -205,29 +205,29 @@ octave_fcn_handle::is_equal_to (const oc
       for (; iter != overloads.end () && retval; iter++, hiter++)
         retval = (iter->first == hiter->first) && (iter->second.is_copy_of (hiter->second));
     }
 
   return retval;
 }
 
 bool
-octave_fcn_handle::set_fcn (const std::string &octaveroot, 
+octave_fcn_handle::set_fcn (const std::string &octaveroot,
                             const std::string& fpath)
 {
   bool success = true;
 
   if (octaveroot.length () != 0
       && fpath.length () >= octaveroot.length ()
       && fpath.substr (0, octaveroot.length ()) == octaveroot
       && OCTAVE_EXEC_PREFIX != octaveroot)
     {
       // First check if just replacing matlabroot is enough
-      std::string str = OCTAVE_EXEC_PREFIX + 
-        fpath.substr (octaveroot.length ());                
+      std::string str = OCTAVE_EXEC_PREFIX +
+        fpath.substr (octaveroot.length ());
       file_stat fs (str);
 
       if (fs.exists ())
         {
           size_t xpos = str.find_last_of (file_ops::dir_sep_chars ());
 
           std::string dir_name = str.substr (0, xpos);
 
@@ -440,22 +440,22 @@ octave_fcn_handle::load_ascii (std::istr
         {
           is.seekg (pos);
           is.clear ();
         }
 
       if (is && success)
         {
           int parse_status;
-          octave_value anon_fcn_handle = 
+          octave_value anon_fcn_handle =
             eval_string (buf, true, parse_status);
 
           if (parse_status == 0)
             {
-              octave_fcn_handle *fh = 
+              octave_fcn_handle *fh =
                 anon_fcn_handle.fcn_handle_value ();
 
               if (fh)
                 {
                   fcn = fh->fcn;
 
                   octave_user_function *uf = fcn.user_function_value (true);
 
@@ -581,49 +581,49 @@ octave_fcn_handle::load_binary (std::ist
       is.get (ctmp2, tmp+1, 0);
 
       unwind_protect_safe frame;
 
       // Set up temporary scope to use for evaluating the text that
       // defines the anonymous function.
 
       symbol_table::scope_id local_scope = symbol_table::alloc_scope ();
-      frame.add_fcn (symbol_table::erase_scope, local_scope);         
+      frame.add_fcn (symbol_table::erase_scope, local_scope);
 
       symbol_table::set_scope (local_scope);
 
       octave_call_stack::push (local_scope, 0);
       frame.add_fcn (octave_call_stack::pop);
 
       if (len > 0)
         {
           for (octave_idx_type i = 0; i < len; i++)
             {
               octave_value t2;
               bool dummy;
               std::string doc;
 
-              std::string name = 
-                read_binary_data (is, swap, fmt, std::string (), 
+              std::string name =
+                read_binary_data (is, swap, fmt, std::string (),
                                   dummy, t2, doc);
 
               if (!is)
                 {
                   error ("load: failed to load anonymous function handle");
                   break;
                 }
 
               symbol_table::varref (name, local_scope) = t2;
             }
         }
 
       if (is && success)
         {
           int parse_status;
-          octave_value anon_fcn_handle = 
+          octave_value anon_fcn_handle =
             eval_string (ctmp2, true, parse_status);
 
           if (parse_status == 0)
             {
               octave_fcn_handle *fh = anon_fcn_handle.fcn_handle_value ();
 
               if (fh)
                 {
@@ -652,17 +652,17 @@ octave_fcn_handle::load_binary (std::ist
           size_t pos2 = nm.find_first_of ("\n", pos1 + 1);
           octaveroot = nm.substr (pos1 + 1, pos2 - pos1 - 1);
           fpath = nm.substr (pos2 + 1);
           nm = nm.substr (0, pos1);
         }
 
       success = set_fcn (octaveroot, fpath);
      }
- 
+
  return success;
 }
 
 #if defined (HAVE_HDF5)
 bool
 octave_fcn_handle::save_hdf5 (hid_t loc_id, const char *name,
                               bool save_as_floats)
 {
@@ -694,17 +694,17 @@ octave_fcn_handle::save_hdf5 (hid_t loc_
   space_hid = H5Screate_simple (0 , hdims, 0);
   if (space_hid < 0)
     {
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
 #if HAVE_HDF5_18
-  data_hid = H5Dcreate (group_hid, "nm",  type_hid, space_hid, 
+  data_hid = H5Dcreate (group_hid, "nm",  type_hid, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "nm",  type_hid, space_hid, H5P_DEFAULT);
 #endif
   if (data_hid < 0 || H5Dwrite (data_hid, type_hid, H5S_ALL, H5S_ALL,
                                 H5P_DEFAULT, nm.c_str ()) < 0)
     {
       H5Sclose (space_hid);
@@ -757,17 +757,17 @@ octave_fcn_handle::save_hdf5 (hid_t loc_
       if (varlen > 0)
         {
           hid_t as_id = H5Screate (H5S_SCALAR);
 
           if (as_id >= 0)
             {
 #if HAVE_HDF5_18
               hid_t a_id = H5Acreate (group_hid, "SYMBOL_TABLE",
-                                      H5T_NATIVE_IDX, as_id, 
+                                      H5T_NATIVE_IDX, as_id,
                                       H5P_DEFAULT, H5P_DEFAULT);
 
 #else
               hid_t a_id = H5Acreate (group_hid, "SYMBOL_TABLE",
                                       H5T_NATIVE_IDX, as_id, H5P_DEFAULT);
 #endif
 
               if (a_id >= 0)
@@ -783,17 +783,17 @@ octave_fcn_handle::save_hdf5 (hid_t loc_
             }
           else
             retval = false;
 #if HAVE_HDF5_18
           data_hid = H5Gcreate (group_hid, "symbol table", H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
           data_hid = H5Gcreate (group_hid, "symbol table", 0);
 #endif
-          if (data_hid < 0) 
+          if (data_hid < 0)
             {
               H5Sclose (space_hid);
               H5Tclose (type_hid);
               H5Gclose (group_hid);
               return false;
             }
 
           for (std::list<symbol_table::symbol_record>::const_iterator p = vars.begin ();
@@ -860,17 +860,17 @@ octave_fcn_handle::save_hdf5 (hid_t loc_
           return false;
         }
 
       H5Tclose (type_hid);
       type_hid = H5Tcopy (H5T_C_S1);
       H5Tset_size (type_hid, fpath.length () + 1);
 
 #if HAVE_HDF5_18
-      a_id = H5Acreate (group_hid, "FILE", type_hid, space_hid, 
+      a_id = H5Acreate (group_hid, "FILE", type_hid, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT);
 #else
       a_id = H5Acreate (group_hid, "FILE", type_hid, space_hid, H5P_DEFAULT);
 #endif
 
       if (a_id >= 0)
         {
           retval = (H5Awrite (a_id, type_hid, fpath.c_str ()) >= 0);
@@ -1087,19 +1087,19 @@ octave_fcn_handle::load_hdf5 (hid_t loc_
 
       octave_call_stack::push (local_scope, 0);
       frame.add_fcn (octave_call_stack::pop);
 
       if (len > 0 && success)
         {
           hsize_t num_obj = 0;
 #if HAVE_HDF5_18
-          data_hid = H5Gopen (group_hid, "symbol table", H5P_DEFAULT); 
+          data_hid = H5Gopen (group_hid, "symbol table", H5P_DEFAULT);
 #else
-          data_hid = H5Gopen (group_hid, "symbol table"); 
+          data_hid = H5Gopen (group_hid, "symbol table");
 #endif
           H5Gget_num_objs (data_hid, &num_obj);
           H5Gclose (data_hid);
 
           if (num_obj != static_cast<hsize_t>(len))
             {
               error ("load: failed to load anonymous function handle");
               success = false;
@@ -1122,17 +1122,17 @@ octave_fcn_handle::load_hdf5 (hid_t loc_
                   symbol_table::varref (dsub.name, local_scope) = dsub.tc;
                 }
             }
         }
 
       if (success)
         {
           int parse_status;
-          octave_value anon_fcn_handle = 
+          octave_value anon_fcn_handle =
             eval_string (fcn_tmp, true, parse_status);
 
           if (parse_status == 0)
             {
               octave_fcn_handle *fh = anon_fcn_handle.fcn_handle_value ();
 
               if (fh)
                 {
@@ -1245,17 +1245,17 @@ octave_fcn_handle::load_hdf5 (hid_t loc_
   H5Sclose (space_hid);
   H5Gclose (group_hid);
 
   return success;
 }
 
 #endif
 
-/* 
+/*
 
 %!test
 %! a = 2;
 %! f = @(x) a + x;
 %! g = @(x) 2 * x;
 %! hm = @version;
 %! hdld = @svd;
 %! hbi = @log2;
@@ -1467,17 +1467,17 @@ make_fcn_handle (const std::string& nm, 
 
   octave_value f = symbol_table::find_function (tnm, octave_value_list (),
                                                 local_funcs);
 
   octave_function *fptr = f.function_value (true);
 
   // Here we are just looking to see if FCN is a method or constructor
   // for any class.
-  if (local_funcs && fptr 
+  if (local_funcs && fptr
       && (fptr->is_subfunction () || fptr->is_private_function ()
           || fptr->is_class_constructor ()))
     {
       // Locally visible function.
       retval = octave_value (new octave_fcn_handle (f, tnm));
     }
   else
     {
@@ -1595,17 +1595,17 @@ Return a struct containing information a
                   m.setfield ("function", fh_nm);
 
                   if (fcn->is_subfunction ())
                     {
                       m.setfield ("type", "subfunction");
                       Cell parentage (dim_vector (1, 2));
                       parentage.elem(0) = fh_nm;
                       parentage.elem(1) = fcn->parent_fcn_name ();
-                      m.setfield ("parentage", octave_value (parentage)); 
+                      m.setfield ("parentage", octave_value (parentage));
                     }
                   else if (fcn->is_private_function ())
                     m.setfield ("type", "private");
                   else if (fh->is_overloaded ())
                     m.setfield ("type", "overloaded");
                   else
                     m.setfield ("type", "simple");
                 }
@@ -1731,42 +1731,42 @@ are ignored in the lookup.\n\
 %!  else
 %!    n++;
 %!    y = testrecursionfunc (@(x) f(2*x), x, n);
 %!  endif
 %!test
 %! assert (testrecursionfunc (@(x) x, 1), 8);
 */
 
-octave_fcn_binder::octave_fcn_binder (const octave_value& f, 
+octave_fcn_binder::octave_fcn_binder (const octave_value& f,
                                       const octave_value& root,
-                                      const octave_value_list& templ, 
-                                      const std::vector<int>& mask, 
+                                      const octave_value_list& templ,
+                                      const std::vector<int>& mask,
                                       int exp_nargin)
 : octave_fcn_handle (f), root_handle (root), arg_template (templ),
   arg_mask (mask), expected_nargin (exp_nargin)
 {
 }
 
 octave_fcn_handle *
 octave_fcn_binder::maybe_binder (const octave_value& f)
 {
   octave_fcn_handle *retval = 0;
 
   octave_user_function *usr_fcn = f.user_function_value (false);
   tree_parameter_list *param_list = usr_fcn ? usr_fcn->parameter_list () : 0;
-  
+
   // Verify that the body is a single expression (always true in theory).
-  
+
   tree_statement_list *cmd_list = usr_fcn ? usr_fcn->body () : 0;
-  tree_expression *body_expr = (cmd_list->length () == 1 
+  tree_expression *body_expr = (cmd_list->length () == 1
                                 ? cmd_list->front ()->expression () : 0);
 
 
-  if (body_expr && body_expr->is_index_expression () 
+  if (body_expr && body_expr->is_index_expression ()
       && ! (param_list && param_list->takes_varargs ()))
     {
       // It's an index expression.
       tree_index_expression *idx_expr = dynamic_cast<tree_index_expression *> (body_expr);
       tree_expression *head_expr = idx_expr->expression ();
       std::list<tree_argument_list *> arg_lists = idx_expr->arg_lists ();
       std::string type_tags = idx_expr->type_tags ();
 
@@ -1868,38 +1868,38 @@ octave_fcn_binder::maybe_binder (const o
 
               if (! bad)
                 {
                   // Stash proper name tags.
                   std::list<string_vector> arg_names = idx_expr->arg_names ();
                   assert (arg_names.size () == 1);
                   arg_template.stash_name_tags (arg_names.front ());
 
-                  retval = new octave_fcn_binder (f, root_val, arg_template, 
+                  retval = new octave_fcn_binder (f, root_val, arg_template,
                                                   arg_mask, npar);
                 }
             }
         }
     }
 
   if (! retval)
      retval = new octave_fcn_handle (f, octave_fcn_handle::anonymous);
 
   return retval;
 }
 
 octave_value_list
-octave_fcn_binder::do_multi_index_op (int nargout, 
+octave_fcn_binder::do_multi_index_op (int nargout,
                                       const octave_value_list& args)
 {
   return do_multi_index_op (nargout, args, 0);
 }
 
 octave_value_list
-octave_fcn_binder::do_multi_index_op (int nargout, 
+octave_fcn_binder::do_multi_index_op (int nargout,
                                       const octave_value_list& args,
                                       const std::list<octave_lvalue>* lvalue_list)
 {
   octave_value_list retval;
 
   if (args.length () == expected_nargin)
     {
       for (int i = 0; i < arg_template.length (); i++)
diff --git a/src/ov-fcn-handle.h b/src/ov-fcn-handle.h
--- a/src/ov-fcn-handle.h
+++ b/src/ov-fcn-handle.h
@@ -86,17 +86,17 @@ public:
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx,
                              int nargout, const std::list<octave_lvalue>* lvalue_list);
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args);
 
   octave_value_list
-  do_multi_index_op (int nargout, const octave_value_list& args, 
+  do_multi_index_op (int nargout, const octave_value_list& args,
                      const std::list<octave_lvalue>* lvalue_list);
 
   bool is_defined (void) const { return true; }
 
   bool is_function_handle (void) const { return true; }
 
   builtin_type_t builtin_type (void) const { return btyp_func_handle; }
 
@@ -135,17 +135,17 @@ public:
   bool is_equal_to (const octave_fcn_handle&) const;
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
-  bool load_binary (std::istream& is, bool swap, 
+  bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
@@ -189,29 +189,29 @@ extern octave_value make_fcn_handle (con
 
 class
 OCTINTERP_API
 octave_fcn_binder : public octave_fcn_handle
 {
 private:
   // Private ctor.
   octave_fcn_binder (const octave_value& f, const octave_value& root,
-                     const octave_value_list& templ, 
+                     const octave_value_list& templ,
                      const std::vector<int>& mask, int exp_nargin);
 
 public:
 
   // Factory method.
   static octave_fcn_handle *maybe_binder (const octave_value& f);
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args);
 
   octave_value_list
-  do_multi_index_op (int nargout, const octave_value_list& args, 
+  do_multi_index_op (int nargout, const octave_value_list& args,
                      const std::list<octave_lvalue>* lvalue_list);
 
 protected:
 
   octave_value root_handle;
   octave_value_list arg_template;
   std::vector<int> arg_mask;
   int expected_nargin;
diff --git a/src/ov-fcn-inline.cc b/src/ov-fcn-inline.cc
--- a/src/ov-fcn-inline.cc
+++ b/src/ov-fcn-inline.cc
@@ -99,17 +99,17 @@ octave_fcn_inline::octave_fcn_inline (co
 
               if (curr_fcn)
                 {
                   symbol_table::scope_id parent_scope
                     = curr_fcn->parent_fcn_scope ();
 
                   if (parent_scope < 0)
                     parent_scope = curr_fcn->scope ();
-        
+
                   uf->stash_parent_fcn_scope (parent_scope);
                 }
             }
         }
     }
 
   if (fcn.is_undefined ())
     error ("inline: unable to define function");
@@ -359,17 +359,17 @@ octave_fcn_inline::save_hdf5 (hid_t loc_
   space_hid = H5Screate_simple (0 , hdims, 0);
   if (space_hid < 0)
     {
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
 #if HAVE_HDF5_18
-  data_hid = H5Dcreate (group_hid, "nm",  type_hid, space_hid, 
+  data_hid = H5Dcreate (group_hid, "nm",  type_hid, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (group_hid, "nm",  type_hid, space_hid, H5P_DEFAULT);
 #endif
   if (data_hid < 0 || H5Dwrite (data_hid, type_hid, H5S_ALL, H5S_ALL,
                                 H5P_DEFAULT, nm.c_str ()) < 0)
     {
       H5Sclose (space_hid);
@@ -668,17 +668,17 @@ If the second argument is an integer @va
           string_vector fargs;
 
           if (nargin == 1)
             {
               bool is_arg = false;
               bool in_string = false;
               std::string tmp_arg;
               size_t i = 0;
-              
+
               while (i < fun.length ())
                 {
                   bool terminate_arg = false;
                   char c = fun[i++];
 
                   if (in_string)
                     {
                       if (c == '\'' || c == '\"')
@@ -695,17 +695,17 @@ If the second argument is an integer @va
                       continue;
                     else if (isdigit (c))
                       tmp_arg.append (1, c);
                     else
                       {
                         // Before we do anything remove trailing whitespaces.
                         while (i < fun.length () && isspace (c))
                           c = fun[i++];
-                        
+
                         // Do we have a variable or a function?
                         if (c != '(')
                           terminate_arg = true;
                         else
                           {
                             tmp_arg = std::string ();
                             is_arg = false;
                           }
@@ -714,27 +714,27 @@ If the second argument is an integer @va
                     {
                       tmp_arg.append (1, c);
                       is_arg = true;
                     }
 
                   if (terminate_arg || (i == fun.length () && is_arg))
                     {
                       bool have_arg = false;
-                      
+
                       for (int j = 0; j < fargs.length (); j++)
                         if (tmp_arg == fargs (j))
                           {
                             have_arg = true;
                             break;
                           }
-                          
+
                       if (! have_arg && tmp_arg != "i" && tmp_arg != "j" &&
-                          tmp_arg != "NaN" && tmp_arg != "nan" && 
-                          tmp_arg != "Inf" && tmp_arg != "inf" && 
+                          tmp_arg != "NaN" && tmp_arg != "nan" &&
+                          tmp_arg != "Inf" && tmp_arg != "inf" &&
                           tmp_arg != "NA" && tmp_arg != "pi" &&
                           tmp_arg != "eps")
                         fargs.append (tmp_arg);
 
                       tmp_arg = std::string ();
                       is_arg = false;
                     }
                 }
@@ -928,17 +928,17 @@ by replacing all occurrences of @code{*}
                 }
               new_func.append (t1);
               i++;
             }
 
           if (func_is_string)
             retval = octave_value (new_func);
           else
-            retval = octave_value (new octave_fcn_inline 
+            retval = octave_value (new octave_fcn_inline
                                    (new_func, old->fcn_arg_names ()));
         }
     }
   else
     print_usage ();
 
   return retval;
 }
diff --git a/src/ov-fcn-inline.h b/src/ov-fcn-inline.h
--- a/src/ov-fcn-inline.h
+++ b/src/ov-fcn-inline.h
@@ -41,17 +41,17 @@ class
 OCTINTERP_API
 octave_fcn_inline : public octave_fcn_handle
 {
 public:
 
   octave_fcn_inline (void)
     : octave_fcn_handle (), iftext (), ifargs () { }
 
-  octave_fcn_inline (const std::string& f, const string_vector& a, 
+  octave_fcn_inline (const std::string& f, const string_vector& a,
                      const std::string& n = std::string ());
 
   octave_fcn_inline (const octave_fcn_inline& fi)
     : octave_fcn_handle (fi), iftext (fi.iftext), ifargs (fi.ifargs) { }
 
   ~octave_fcn_inline (void) { }
 
   octave_base_value *clone (void) const { return new octave_fcn_inline (*this); }
@@ -70,17 +70,17 @@ public:
   octave_map map_value (void) const;
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
-  bool load_binary (std::istream& is, bool swap, 
+  bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
diff --git a/src/ov-fcn.h b/src/ov-fcn.h
--- a/src/ov-fcn.h
+++ b/src/ov-fcn.h
@@ -152,17 +152,17 @@ protected:
   // TRUE if this function is tagged so that it can't be cleared.
   bool locked;
 
   // TRUE means this is a private function.
   bool private_function;
 
   // If this object is a class method or constructor, or a private
   // function inside a class directory, this is the name of the class
-  // to which the method belongs. 
+  // to which the method belongs.
   std::string xdispatch_class;
 
   // The name of this function.
   std::string my_name;
 
   // The name of the directory in the path where we found this
   // function.  May be relative.
   std::string my_dir_name;
diff --git a/src/ov-float.cc b/src/ov-float.cc
--- a/src/ov-float.cc
+++ b/src/ov-float.cc
@@ -69,17 +69,17 @@ octave_float_scalar::do_index_op (const 
   // 1x1 matrix back to a scalar value.  Need a better solution
   // to this problem.
 
   octave_value tmp (new octave_matrix (matrix_value ()));
 
   return tmp.do_index_op (idx, resize_ok);
 }
 
-octave_value 
+octave_value
 octave_float_scalar::resize (const dim_vector& dv, bool fill) const
 {
   if (fill)
     {
       FloatNDArray retval (dv, NDArray::resize_fill_value());
 
       if (dv.numel ())
         retval(0) = scalar;
@@ -118,53 +118,53 @@ octave_float_scalar::convert_to_str_inte
         }
 
       retval = octave_value (std::string (1, static_cast<char> (ival)), type);
     }
 
   return retval;
 }
 
-bool 
+bool
 octave_float_scalar::save_ascii (std::ostream& os)
 {
   float d = float_value ();
 
   octave_write_float (os, d);
 
   os << "\n";
 
   return true;
 }
 
-bool 
+bool
 octave_float_scalar::load_ascii (std::istream& is)
 {
   scalar = octave_read_value<float> (is);
   if (!is)
     {
       error ("load: failed to load scalar constant");
       return false;
     }
 
   return true;
 }
 
-bool 
+bool
 octave_float_scalar::save_binary (std::ostream& os, bool& /* save_as_floats */)
 {
   char tmp = LS_FLOAT;
   os.write (reinterpret_cast<char *> (&tmp), 1);
   float dtmp = float_value ();
   os.write (reinterpret_cast<char *> (&dtmp), 4);
 
   return true;
 }
 
-bool 
+bool
 octave_float_scalar::load_binary (std::istream& is, bool swap,
                             oct_mach_info::float_format fmt)
 {
   char tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), 1))
     return false;
 
   float dtmp;
@@ -184,23 +184,23 @@ octave_float_scalar::save_hdf5 (hid_t lo
 {
   hsize_t dimens[3];
   hid_t space_hid = -1, data_hid = -1;
   bool retval = true;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0) return false;
 #if HAVE_HDF5_18
-  data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_FLOAT, space_hid, 
+  data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_FLOAT, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
-  data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_FLOAT, space_hid, 
+  data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_FLOAT, space_hid,
                         H5P_DEFAULT);
 #endif
-  if (data_hid < 0) 
+  if (data_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
 
   float tmp = float_value ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_FLOAT, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, &tmp) >= 0;
@@ -219,25 +219,25 @@ octave_float_scalar::load_hdf5 (hid_t lo
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
   hid_t space_id = H5Dget_space (data_hid);
 
   hsize_t rank = H5Sget_simple_extent_ndims (space_id);
 
   if (rank != 0)
-    { 
+    {
       H5Dclose (data_hid);
       return false;
     }
 
   float dtmp;
-  if (H5Dread (data_hid, H5T_NATIVE_FLOAT, H5S_ALL, H5S_ALL, 
+  if (H5Dread (data_hid, H5T_NATIVE_FLOAT, H5S_ALL, H5S_ALL,
                H5P_DEFAULT, &dtmp) < 0)
-    { 
+    {
       H5Dclose (data_hid);
       return false;
     }
 
   scalar = dtmp;
 
   H5Dclose (data_hid);
 
diff --git a/src/ov-float.h b/src/ov-float.h
--- a/src/ov-float.h
+++ b/src/ov-float.h
@@ -218,17 +218,17 @@ public:
   void decrement (void) { --scalar; }
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
-  bool load_binary (std::istream& is, bool swap, 
+  bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
diff --git a/src/ov-flt-complex.cc b/src/ov-flt-complex.cc
--- a/src/ov-flt-complex.cc
+++ b/src/ov-flt-complex.cc
@@ -200,17 +200,17 @@ octave_float_complex::complex_array_valu
 }
 
 FloatComplexNDArray
 octave_float_complex::float_complex_array_value (bool /* force_conversion */) const
 {
   return FloatComplexNDArray (dim_vector (1, 1), scalar);
 }
 
-octave_value 
+octave_value
 octave_float_complex::resize (const dim_vector& dv, bool fill) const
 {
   if (fill)
     {
       FloatComplexNDArray retval (dv, FloatComplexNDArray::resize_fill_value ());
 
       if (dv.numel ())
         retval(0) = scalar;
@@ -223,55 +223,55 @@ octave_float_complex::resize (const dim_
 
       if (dv.numel ())
         retval(0) = scalar;
 
       return retval;
     }
 }
 
-bool 
+bool
 octave_float_complex::save_ascii (std::ostream& os)
 {
   FloatComplex c = float_complex_value ();
 
   octave_write_float_complex (os, c);
 
   os << "\n";
 
   return true;
 }
 
-bool 
+bool
 octave_float_complex::load_ascii (std::istream& is)
 {
   scalar = octave_read_value<FloatComplex> (is);
 
-  if (!is) 
+  if (!is)
     {
       error ("load: failed to load complex scalar constant");
       return false;
     }
 
   return true;
 }
 
 
-bool 
+bool
 octave_float_complex::save_binary (std::ostream& os, bool& /* save_as_floats */)
 {
   char tmp = static_cast<char> (LS_FLOAT);
   os.write (reinterpret_cast<char *> (&tmp), 1);
   FloatComplex ctmp = float_complex_value ();
   os.write (reinterpret_cast<char *> (&ctmp), 8);
 
   return true;
 }
 
-bool 
+bool
 octave_float_complex::load_binary (std::istream& is, bool swap,
                              oct_mach_info::float_format fmt)
 {
   char tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), 1))
     return false;
 
   FloatComplex ctmp;
@@ -294,36 +294,36 @@ octave_float_complex::save_hdf5 (hid_t l
   hid_t space_hid = -1, type_hid = -1, data_hid = -1;
   bool retval = true;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0)
     return false;
 
   type_hid = hdf5_make_complex_type (H5T_NATIVE_FLOAT);
-  if (type_hid < 0) 
+  if (type_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
 #if HAVE_HDF5_18
-  data_hid = H5Dcreate (loc_id, name, type_hid, space_hid, 
+  data_hid = H5Dcreate (loc_id, name, type_hid, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
-#else                   
+#else
   data_hid = H5Dcreate (loc_id, name, type_hid, space_hid, H5P_DEFAULT);
 #endif
-  if (data_hid < 0) 
+  if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       return false;
     }
 
   FloatComplex tmp = float_complex_value ();
-  retval = H5Dwrite (data_hid, type_hid, H5S_ALL, H5S_ALL, H5P_DEFAULT, 
+  retval = H5Dwrite (data_hid, type_hid, H5S_ALL, H5S_ALL, H5P_DEFAULT,
                      &tmp) >= 0;
 
   H5Dclose (data_hid);
   H5Tclose (type_hid);
   H5Sclose (space_hid);
 
   return retval;
 }
@@ -346,17 +346,17 @@ octave_float_complex::load_hdf5 (hid_t l
       H5Tclose (complex_type);
       H5Dclose (data_hid);
       return false;
     }
 
   hid_t space_id = H5Dget_space (data_hid);
   hsize_t rank = H5Sget_simple_extent_ndims (space_id);
 
-  if (rank != 0) 
+  if (rank != 0)
     {
       H5Tclose (complex_type);
       H5Sclose (space_id);
       H5Dclose (data_hid);
       return false;
     }
 
   // complex scalar:
diff --git a/src/ov-flt-complex.h b/src/ov-flt-complex.h
--- a/src/ov-flt-complex.h
+++ b/src/ov-flt-complex.h
@@ -157,17 +157,17 @@ public:
   void decrement (void) { scalar -= 1.0; }
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
-  bool load_binary (std::istream& is, bool swap, 
+  bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
diff --git a/src/ov-flt-cx-diag.cc b/src/ov-flt-cx-diag.cc
--- a/src/ov-flt-cx-diag.cc
+++ b/src/ov-flt-cx-diag.cc
@@ -32,17 +32,17 @@ along with Octave; see the file COPYING.
 #include "ov-flt-complex.h"
 #include "ov-flt-cx-mat.h"
 #include "ls-utils.h"
 
 template class octave_base_diag<FloatComplexDiagMatrix, FloatComplexMatrix>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_float_complex_diag_matrix);
 
-DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_float_complex_diag_matrix, 
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_float_complex_diag_matrix,
                                      "float complex diagonal matrix", "single");
 
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
   CAST_CONV_ARG (const octave_float_complex_diag_matrix&);
 
   return new octave_float_complex_matrix (v.float_complex_matrix_value ());
@@ -139,18 +139,18 @@ octave_float_complex_diag_matrix::map (u
         return retval;
       }
     default:
       return to_dense ().map (umap);
     }
 }
 
 
-bool 
-octave_float_complex_diag_matrix::save_binary (std::ostream& os, 
+bool
+octave_float_complex_diag_matrix::save_binary (std::ostream& os,
                                                bool& /* save_as_floats */)
 {
 
   int32_t r = matrix.rows (), c = matrix.cols ();
   os.write (reinterpret_cast<char *> (&r), 4);
   os.write (reinterpret_cast<char *> (&c), 4);
 
   FloatComplexMatrix m = FloatComplexMatrix (matrix.diag ());
@@ -163,17 +163,17 @@ octave_float_complex_diag_matrix::save_b
     }
 
   const FloatComplex *mtmp = m.data ();
   write_floats (os, reinterpret_cast<const float *> (mtmp), st, 2 * m.numel ());
 
   return true;
 }
 
-bool 
+bool
 octave_float_complex_diag_matrix::load_binary (std::istream& is, bool swap,
                                  oct_mach_info::float_format fmt)
 {
   int32_t r, c;
   char tmp;
   if (! (is.read (reinterpret_cast<char *> (&r), 4)
          && is.read (reinterpret_cast<char *> (&c), 4)
          && is.read (reinterpret_cast<char *> (&tmp), 1)))
@@ -182,26 +182,26 @@ octave_float_complex_diag_matrix::load_b
     {
       swap_bytes<4> (&r);
       swap_bytes<4> (&c);
     }
 
   FloatComplexDiagMatrix m (r, c);
   FloatComplex *re = m.fortran_vec ();
   octave_idx_type len = m.length ();
-  read_floats (is, reinterpret_cast<float *> (re), 
+  read_floats (is, reinterpret_cast<float *> (re),
                static_cast<save_type> (tmp), 2 * len, swap, fmt);
   if (error_state || ! is)
     return false;
   matrix = m;
 
   return true;
 }
 
-bool 
-octave_float_complex_diag_matrix::chk_valid_scalar (const octave_value& val, 
+bool
+octave_float_complex_diag_matrix::chk_valid_scalar (const octave_value& val,
                                                     FloatComplex& x) const
 {
   bool retval = val.is_complex_scalar () || val.is_real_scalar ();
   if (retval)
     x = val.float_complex_value ();
   return retval;
 }
diff --git a/src/ov-flt-cx-diag.h b/src/ov-flt-cx-diag.h
--- a/src/ov-flt-cx-diag.h
+++ b/src/ov-flt-cx-diag.h
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 #include "ov-base-diag.h"
 #include "ov-flt-cx-mat.h"
 #include "ov-typeinfo.h"
 
 // Real diagonal matrix values.
 
 class
 OCTINTERP_API
-octave_float_complex_diag_matrix 
+octave_float_complex_diag_matrix
   : public octave_base_diag<FloatComplexDiagMatrix, FloatComplexMatrix>
 {
 public:
 
   octave_float_complex_diag_matrix (void)
     : octave_base_diag<FloatComplexDiagMatrix, FloatComplexMatrix> () { }
 
   octave_float_complex_diag_matrix (const FloatComplexDiagMatrix& m)
@@ -70,24 +70,24 @@ public:
   FloatDiagMatrix float_diag_matrix_value (bool = false) const;
 
   ComplexDiagMatrix complex_diag_matrix_value (bool = false) const;
 
   FloatComplexDiagMatrix float_complex_diag_matrix_value (bool = false) const;
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
-  bool load_binary (std::istream& is, bool swap, 
+  bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
-  bool chk_valid_scalar (const octave_value&, 
+  bool chk_valid_scalar (const octave_value&,
                          FloatComplex&) const;
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/src/ov-flt-cx-mat.cc b/src/ov-flt-cx-mat.cc
--- a/src/ov-flt-cx-mat.cc
+++ b/src/ov-flt-cx-mat.cc
@@ -210,46 +210,46 @@ octave_float_complex_matrix::float_compl
   return FloatComplexMatrix (matrix.matrix_value ());
 }
 
 boolNDArray
 octave_float_complex_matrix::bool_array_value (bool warn) const
 {
   if (matrix.any_element_is_nan ())
     gripe_nan_to_logical_conversion ();
-  else if (warn && (! matrix.all_elements_are_real () 
+  else if (warn && (! matrix.all_elements_are_real ()
                     || real (matrix).any_element_not_one_or_zero ()))
     gripe_logical_conversion ();
 
   return mx_el_ne (matrix, FloatComplex (0.0));
 }
-  
+
 charNDArray
 octave_float_complex_matrix::char_array_value (bool frc_str_conv) const
 {
   charNDArray retval;
 
   if (! frc_str_conv)
     gripe_implicit_conversion ("Octave:num-to-str",
                                "complex matrix", "string");
   else
     {
       retval = charNDArray (dims ());
       octave_idx_type nel = numel ();
-  
+
       for (octave_idx_type i = 0; i < nel; i++)
         retval.elem (i) = static_cast<char>(std::real (matrix.elem (i)));
     }
 
   return retval;
-}  
+}
 
-FloatComplexNDArray 
-octave_float_complex_matrix::float_complex_array_value (bool) const 
-{ 
+FloatComplexNDArray
+octave_float_complex_matrix::float_complex_array_value (bool) const
+{
   return FloatComplexNDArray (matrix);
 }
 
 SparseMatrix
 octave_float_complex_matrix::sparse_matrix_value (bool force_conversion) const
 {
   SparseMatrix retval;
 
@@ -267,54 +267,54 @@ octave_float_complex_matrix::sparse_comp
 {
   return SparseComplexMatrix (complex_matrix_value ());
 }
 
 octave_value
 octave_float_complex_matrix::diag (octave_idx_type k) const
 {
   octave_value retval;
-  if (k == 0 && matrix.ndims () == 2 
+  if (k == 0 && matrix.ndims () == 2
       && (matrix.rows () == 1 || matrix.columns () == 1))
     retval = FloatComplexDiagMatrix (DiagArray2<FloatComplex> (matrix));
   else
     retval = octave_base_matrix<FloatComplexNDArray>::diag (k);
 
   return retval;
 }
 
-bool 
+bool
 octave_float_complex_matrix::save_ascii (std::ostream& os)
 {
   dim_vector d = dims ();
   if (d.length () > 2)
     {
       FloatComplexNDArray tmp = complex_array_value ();
 
       os << "# ndims: " << d.length () << "\n";
 
       for (int i = 0; i < d.length (); i++)
         os << " " << d (i);
 
       os << "\n" << tmp;
     }
   else
     {
-      // Keep this case, rather than use generic code above for backward 
+      // Keep this case, rather than use generic code above for backward
       // compatiability. Makes load_ascii much more complex!!
       os << "# rows: " << rows () << "\n"
          << "# columns: " << columns () << "\n";
 
       os << complex_matrix_value ();
     }
 
   return true;
 }
 
-bool 
+bool
 octave_float_complex_matrix::load_ascii (std::istream& is)
 {
   bool success = true;
 
   string_vector keywords(2);
 
   keywords[0] = "ndims";
   keywords[1] = "rows";
@@ -399,17 +399,17 @@ octave_float_complex_matrix::load_ascii 
     {
       error ("load: failed to extract number of rows and columns");
       success = false;
     }
 
   return success;
 }
 
-bool 
+bool
 octave_float_complex_matrix::save_binary (std::ostream& os, bool&)
 {
   dim_vector d = dims ();
   if (d.length() < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
   int32_t tmp = - d.length();
@@ -430,17 +430,17 @@ octave_float_complex_matrix::save_binary
     }
 
   const FloatComplex *mtmp = m.data ();
   write_floats (os, reinterpret_cast<const float *> (mtmp), st, 2 * d.numel ());
 
   return true;
 }
 
-bool 
+bool
 octave_float_complex_matrix::load_binary (std::istream& is, bool swap,
                                  oct_mach_info::float_format fmt)
 {
   char tmp;
   int32_t mdims;
   if (! is.read (reinterpret_cast<char *> (&mdims), 4))
     return false;
   if (swap)
@@ -521,42 +521,42 @@ octave_float_complex_matrix::save_hdf5 (
   bool retval = true;
   FloatComplexNDArray m = complex_array_value ();
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
     hdims[i] = dv (rank-i-1);
- 
+
   space_hid = H5Screate_simple (rank, hdims, 0);
   if (space_hid < 0) return false;
 
   hid_t save_type_hid = H5T_NATIVE_FLOAT;
 
 #if HAVE_HDF5_INT2FLOAT_CONVERSIONS
   // hdf5 currently doesn't support float/integer conversions
   else
     {
       float max_val, min_val;
-      
+
       if (m.all_integers (max_val, min_val))
         save_type_hid
           = save_type_to_hdf5 (get_save_type (max_val, min_val));
     }
 #endif /* HAVE_HDF5_INT2FLOAT_CONVERSIONS */
 
   type_hid = hdf5_make_complex_type (save_type_hid);
   if (type_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
 #if HAVE_HDF5_18
-  data_hid = H5Dcreate (loc_id, name, type_hid, space_hid, 
+  data_hid = H5Dcreate (loc_id, name, type_hid, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, type_hid, space_hid, H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
@@ -580,17 +580,17 @@ octave_float_complex_matrix::save_hdf5 (
   H5Tclose (complex_type_hid);
   H5Dclose (data_hid);
   H5Tclose (type_hid);
   H5Sclose (space_hid);
 
   return retval;
 }
 
-bool 
+bool
 octave_float_complex_matrix::load_hdf5 (hid_t loc_id, const char *name)
 {
   bool retval = false;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize(dv);
@@ -611,17 +611,17 @@ octave_float_complex_matrix::load_hdf5 (
       H5Tclose (complex_type);
       H5Dclose (data_hid);
       return false;
     }
 
   hid_t space_id = H5Dget_space (data_hid);
 
   hsize_t rank = H5Sget_simple_extent_ndims (space_id);
-  
+
   if (rank < 1)
     {
       H5Tclose (complex_type);
       H5Sclose (space_id);
       H5Dclose (data_hid);
       return false;
     }
 
@@ -642,17 +642,17 @@ octave_float_complex_matrix::load_hdf5 (
       dv.resize (rank);
       for (hsize_t i = 0, j = rank - 1; i < rank; i++, j--)
         dv(j) = hdims[i];
     }
 
   FloatComplexNDArray m (dv);
   FloatComplex *reim = m.fortran_vec ();
   if (H5Dread (data_hid, complex_type, H5S_ALL, H5S_ALL, H5P_DEFAULT,
-               reim) >= 0) 
+               reim) >= 0)
     {
       retval = true;
       matrix = m;
     }
 
   H5Tclose (complex_type);
   H5Sclose (space_id);
   H5Dclose (data_hid);
diff --git a/src/ov-flt-cx-mat.h b/src/ov-flt-cx-mat.h
--- a/src/ov-flt-cx-mat.h
+++ b/src/ov-flt-cx-mat.h
@@ -121,17 +121,17 @@ public:
 
   ComplexNDArray complex_array_value (bool = false) const { return matrix; }
 
   FloatComplexNDArray float_complex_array_value (bool = false) const;
 
   boolNDArray bool_array_value (bool warn = false) const;
 
   charNDArray char_array_value (bool frc_str_conv = false) const;
-  
+
   SparseMatrix sparse_matrix_value (bool = false) const;
 
   SparseComplexMatrix sparse_complex_matrix_value (bool = false) const;
 
   octave_value diag (octave_idx_type k = 0) const;
 
   void increment (void) { matrix += FloatComplex (1.0); }
 
@@ -140,17 +140,17 @@ public:
   void changesign (void) { matrix.changesign (); }
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
-  bool load_binary (std::istream& is, bool swap, 
+  bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
diff --git a/src/ov-flt-re-diag.cc b/src/ov-flt-re-diag.cc
--- a/src/ov-flt-re-diag.cc
+++ b/src/ov-flt-re-diag.cc
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 #include "ov-float.h"
 #include "ov-flt-re-mat.h"
 #include "ls-utils.h"
 
 template class octave_base_diag<FloatDiagMatrix, FloatMatrix>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_float_diag_matrix);
 
-DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_float_diag_matrix, 
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_float_diag_matrix,
                                      "float diagonal matrix", "single");
 
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
   CAST_CONV_ARG (const octave_float_diag_matrix&);
 
   return new octave_float_matrix (v.float_matrix_value ());
@@ -108,17 +108,17 @@ octave_float_diag_matrix::map (unary_map
         retval.resize (matrix.rows (), matrix.columns ());
         return retval;
       }
     default:
       return to_dense ().map (umap);
     }
 }
 
-bool 
+bool
 octave_float_diag_matrix::save_binary (std::ostream& os,
                                        bool& /* save_as_floats*/)
 {
 
   int32_t r = matrix.rows (), c = matrix.cols ();
   os.write (reinterpret_cast<char *> (&r), 4);
   os.write (reinterpret_cast<char *> (&c), 4);
 
@@ -132,17 +132,17 @@ octave_float_diag_matrix::save_binary (s
     }
 
   const float *mtmp = m.data ();
   write_floats (os, mtmp, st, m.numel ());
 
   return true;
 }
 
-bool 
+bool
 octave_float_diag_matrix::load_binary (std::istream& is, bool swap,
                                  oct_mach_info::float_format fmt)
 {
   int32_t r, c;
   char tmp;
   if (! (is.read (reinterpret_cast<char *> (&r), 4)
          && is.read (reinterpret_cast<char *> (&c), 4)
          && is.read (reinterpret_cast<char *> (&tmp), 1)))
@@ -159,17 +159,17 @@ octave_float_diag_matrix::load_binary (s
   read_floats (is, re, static_cast<save_type> (tmp), len, swap, fmt);
   if (error_state || ! is)
     return false;
   matrix = m;
 
   return true;
 }
 
-bool 
-octave_float_diag_matrix::chk_valid_scalar (const octave_value& val, 
+bool
+octave_float_diag_matrix::chk_valid_scalar (const octave_value& val,
                                             float& x) const
 {
   bool retval = val.is_real_scalar ();
   if (retval)
     x = val.float_value ();
   return retval;
 }
diff --git a/src/ov-flt-re-diag.h b/src/ov-flt-re-diag.h
--- a/src/ov-flt-re-diag.h
+++ b/src/ov-flt-re-diag.h
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 #include "ov-base-diag.h"
 #include "ov-flt-re-mat.h"
 #include "ov-typeinfo.h"
 
 // Real diagonal matrix values.
 
 class
 OCTINTERP_API
-octave_float_diag_matrix 
+octave_float_diag_matrix
   : public octave_base_diag<FloatDiagMatrix, FloatMatrix>
 {
 public:
 
   octave_float_diag_matrix (void)
     : octave_base_diag<FloatDiagMatrix, FloatMatrix> () { }
 
   octave_float_diag_matrix (const FloatDiagMatrix& m)
@@ -70,24 +70,24 @@ public:
   FloatDiagMatrix float_diag_matrix_value (bool = false) const;
 
   ComplexDiagMatrix complex_diag_matrix_value (bool = false) const;
 
   FloatComplexDiagMatrix float_complex_diag_matrix_value (bool = false) const;
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
-  bool load_binary (std::istream& is, bool swap, 
+  bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
-  bool chk_valid_scalar (const octave_value&, 
+  bool chk_valid_scalar (const octave_value&,
                          float&) const;
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/src/ov-flt-re-mat.cc b/src/ov-flt-re-mat.cc
--- a/src/ov-flt-re-mat.cc
+++ b/src/ov-flt-re-mat.cc
@@ -200,66 +200,66 @@ octave_float_matrix::complex_array_value
 }
 
 FloatComplexNDArray
 octave_float_matrix::float_complex_array_value (bool) const
 {
   return FloatComplexNDArray (matrix);
 }
 
-NDArray 
+NDArray
 octave_float_matrix::array_value (bool) const
-{ 
-  return NDArray (matrix); 
+{
+  return NDArray (matrix);
 }
 
 boolNDArray
 octave_float_matrix::bool_array_value (bool warn) const
 {
   if (matrix.any_element_is_nan ())
     gripe_nan_to_logical_conversion ();
   else if (warn && matrix.any_element_not_one_or_zero ())
     gripe_logical_conversion ();
 
   return boolNDArray (matrix);
 }
-  
+
 charNDArray
 octave_float_matrix::char_array_value (bool) const
 {
   charNDArray retval (dims ());
 
   octave_idx_type nel = numel ();
-  
+
   for (octave_idx_type i = 0; i < nel; i++)
     retval.elem (i) = static_cast<char>(matrix.elem (i));
 
   return retval;
 }
-  
-SparseMatrix 
+
+SparseMatrix
 octave_float_matrix::sparse_matrix_value (bool) const
 {
   return SparseMatrix (matrix_value ());
 }
 
-SparseComplexMatrix 
+SparseComplexMatrix
 octave_float_matrix::sparse_complex_matrix_value (bool) const
 {
   // FIXME Need a SparseComplexMatrix (Matrix) constructor to make
   // this function more efficient. Then this should become
   // return SparseComplexMatrix (matrix.matrix_value ());
   return SparseComplexMatrix (sparse_matrix_value ());
 }
 
 octave_value
 octave_float_matrix::diag (octave_idx_type k) const
 {
   octave_value retval;
-  if (k == 0 && matrix.ndims () == 2 
+  if (k == 0 && matrix.ndims () == 2
       && (matrix.rows () == 1 || matrix.columns () == 1))
     retval = FloatDiagMatrix (DiagArray2<float> (matrix));
   else
     retval = octave_base_matrix<FloatNDArray>::diag (k);
 
   return retval;
 }
 
@@ -307,17 +307,17 @@ octave_float_matrix::convert_to_str_inte
         }
     }
 
   retval = octave_value (chm, type);
 
   return retval;
 }
 
-bool 
+bool
 octave_float_matrix::save_ascii (std::ostream& os)
 {
   dim_vector d = dims ();
 
   if (d.length () > 2)
     {
       FloatNDArray tmp = float_array_value ();
 
@@ -325,28 +325,28 @@ octave_float_matrix::save_ascii (std::os
 
       for (int i=0; i < d.length (); i++)
         os << " " << d (i);
 
       os << "\n" << tmp;
     }
   else
     {
-      // Keep this case, rather than use generic code above for backward 
+      // Keep this case, rather than use generic code above for backward
       // compatiability. Makes load_ascii much more complex!!
       os << "# rows: " << rows () << "\n"
          << "# columns: " << columns () << "\n";
 
       os << float_matrix_value ();
     }
 
   return true;
 }
 
-bool 
+bool
 octave_float_matrix::load_ascii (std::istream& is)
 {
   bool success = true;
 
   string_vector keywords(2);
 
   keywords[0] = "ndims";
   keywords[1] = "rows";
@@ -413,17 +413,17 @@ octave_float_matrix::load_ascii (std::is
                       success = false;
                     }
                 }
               else if (nr == 0 || nc == 0)
                 matrix = FloatMatrix (nr, nc);
               else
                 panic_impossible ();
             }
-          else 
+          else
             {
               error ("load: failed to extract number of rows and columns");
               success = false;
             }
         }
       else
         panic_impossible ();
     }
@@ -431,17 +431,17 @@ octave_float_matrix::load_ascii (std::is
     {
       error ("load: failed to extract number of rows and columns");
       success = false;
     }
 
   return success;
 }
 
-bool 
+bool
 octave_float_matrix::save_binary (std::ostream& os, bool&)
 {
 
   dim_vector d = dims ();
   if (d.length() < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
@@ -463,17 +463,17 @@ octave_float_matrix::save_binary (std::o
     }
 
   const float *mtmp = m.data ();
   write_floats (os, mtmp, st, d.numel ());
 
   return true;
 }
 
-bool 
+bool
 octave_float_matrix::load_binary (std::istream& is, bool swap,
                                  oct_mach_info::float_format fmt)
 {
   char tmp;
   int32_t mdims;
   if (! is.read (reinterpret_cast<char *> (&mdims), 4))
     return false;
   if (swap)
@@ -552,17 +552,17 @@ octave_float_matrix::save_hdf5 (hid_t lo
   bool retval = true;
   FloatNDArray m = array_value ();
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
     hdims[i] = dv (rank-i-1);
- 
+
   space_hid = H5Screate_simple (rank, hdims, 0);
 
   if (space_hid < 0) return false;
 
   hid_t save_type_hid = H5T_NATIVE_FLOAT;
 
 #if HAVE_HDF5_INT2FLOAT_CONVERSIONS
   // hdf5 currently doesn't support float/integer conversions
@@ -571,20 +571,20 @@ octave_float_matrix::save_hdf5 (hid_t lo
       float max_val, min_val;
 
       if (m.all_integers (max_val, min_val))
         save_type_hid
           = save_type_to_hdf5 (get_save_type (max_val, min_val));
     }
 #endif /* HAVE_HDF5_INT2FLOAT_CONVERSIONS */
 #if HAVE_HDF5_18
-  data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid, 
+  data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
-  data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid, 
+  data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid,
                         H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
 
@@ -613,17 +613,17 @@ octave_float_matrix::load_hdf5 (hid_t lo
 #if HAVE_HDF5_18
   hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
   hid_t space_id = H5Dget_space (data_hid);
 
   hsize_t rank = H5Sget_simple_extent_ndims (space_id);
-  
+
   if (rank < 1)
     {
       H5Sclose (space_id);
       H5Dclose (data_hid);
       return false;
     }
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
@@ -642,18 +642,18 @@ octave_float_matrix::load_hdf5 (hid_t lo
     {
       dv.resize (rank);
       for (hsize_t i = 0, j = rank - 1; i < rank; i++, j--)
         dv(j) = hdims[i];
     }
 
   FloatNDArray m (dv);
   float *re = m.fortran_vec ();
-  if (H5Dread (data_hid, H5T_NATIVE_FLOAT, H5S_ALL, H5S_ALL, 
-               H5P_DEFAULT, re) >= 0) 
+  if (H5Dread (data_hid, H5T_NATIVE_FLOAT, H5S_ALL, H5S_ALL,
+               H5P_DEFAULT, re) >= 0)
     {
       retval = true;
       matrix = m;
     }
 
   H5Sclose (space_id);
   H5Dclose (data_hid);
 
diff --git a/src/ov-flt-re-mat.h b/src/ov-flt-re-mat.h
--- a/src/ov-flt-re-mat.h
+++ b/src/ov-flt-re-mat.h
@@ -82,17 +82,17 @@ public:
 
   ~octave_float_matrix (void) { }
 
   octave_base_value *clone (void) const { return new octave_float_matrix (*this); }
   octave_base_value *empty_clone (void) const { return new octave_float_matrix (); }
 
   octave_base_value *try_narrowing_conversion (void);
 
-  idx_vector index_vector (void) const 
+  idx_vector index_vector (void) const
     { return idx_cache ? *idx_cache : set_idx_cache (idx_vector (matrix)); }
 
   builtin_type_t builtin_type (void) const { return btyp_float; }
 
   bool is_real_matrix (void) const { return true; }
 
   bool is_real_type (void) const { return true; }
 
@@ -142,25 +142,25 @@ public:
 
   FloatComplex float_complex_value (bool = false) const;
 
   ComplexMatrix complex_matrix_value (bool = false) const;
 
   FloatComplexMatrix float_complex_matrix_value (bool = false) const;
 
   ComplexNDArray complex_array_value (bool = false) const;
-   
+
   FloatComplexNDArray float_complex_array_value (bool = false) const;
 
   boolNDArray bool_array_value (bool warn = false) const;
 
   charNDArray char_array_value (bool = false) const;
-  
+
   NDArray array_value (bool = false) const;
-  
+
   FloatNDArray float_array_value (bool = false) const { return matrix; }
 
   SparseMatrix sparse_matrix_value (bool = false) const;
 
   SparseComplexMatrix sparse_complex_matrix_value (bool = false) const;
 
   octave_value diag (octave_idx_type k = 0) const;
 
@@ -176,17 +176,17 @@ public:
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
-  bool load_binary (std::istream& is, bool swap, 
+  bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
diff --git a/src/ov-intx.h b/src/ov-intx.h
--- a/src/ov-intx.h
+++ b/src/ov-intx.h
@@ -108,17 +108,17 @@ public:
                                      type_name (), "real scalar");
 
           retval = matrix(0).double_value ();
         }
       else
         gripe_invalid_conversion (type_name (), "real scalar");
 
       return retval;
-      
+
     }
 
   float
   float_value (bool = false) const
     {
       float retval = lo_ieee_float_nan_value ();
 
       if (numel () > 0)
@@ -127,17 +127,17 @@ public:
                                      type_name (), "real scalar");
 
           retval = matrix(0).float_value ();
         }
       else
         gripe_invalid_conversion (type_name (), "real scalar");
 
       return retval;
-      
+
     }
 
   double scalar_value (bool = false) const { return double_value (); }
 
   float float_scalar_value (bool = false) const { return float_value (); }
 
   Matrix
   matrix_value (bool = false) const
@@ -208,51 +208,51 @@ public:
           for (octave_idx_type i = 0; i < nel; i++)
             vec[i] = FloatComplex (matrix(i).float_value ());
         }
       return retval;
     }
 
   NDArray
   array_value (bool = false) const
-    { 
-      NDArray retval (matrix.dims ()); 
+    {
+      NDArray retval (matrix.dims ());
       double *vec = retval.fortran_vec ();
       octave_idx_type nel = matrix.numel ();
       for (octave_idx_type i = 0; i < nel; i++)
         vec[i] = matrix(i).double_value ();
       return retval;
     }
 
   FloatNDArray
   float_array_value (bool = false) const
-    { 
-      FloatNDArray retval (matrix.dims ()); 
+    {
+      FloatNDArray retval (matrix.dims ());
       float *vec = retval.fortran_vec ();
       octave_idx_type nel = matrix.numel ();
       for (octave_idx_type i = 0; i < nel; i++)
         vec[i] = matrix(i).float_value ();
       return retval;
     }
 
   ComplexNDArray
   complex_array_value (bool = false) const
-    { 
-      ComplexNDArray retval (matrix.dims ()); 
+    {
+      ComplexNDArray retval (matrix.dims ());
       Complex *vec = retval.fortran_vec ();
       octave_idx_type nel = matrix.numel ();
       for (octave_idx_type i = 0; i < nel; i++)
         vec[i] = Complex (matrix(i).double_value ());
       return retval;
     }
 
   FloatComplexNDArray
   float_complex_array_value (bool = false) const
-    { 
-      FloatComplexNDArray retval (matrix.dims ()); 
+    {
+      FloatComplexNDArray retval (matrix.dims ());
       FloatComplex *vec = retval.fortran_vec ();
       octave_idx_type nel = matrix.numel ();
       for (octave_idx_type i = 0; i < nel; i++)
         vec[i] = FloatComplex (matrix(i).float_value ());
       return retval;
     }
 
   boolNDArray
@@ -273,41 +273,41 @@ public:
   }
 
   charNDArray
   char_array_value (bool = false) const
   {
     charNDArray retval (dims ());
 
     octave_idx_type nel = numel ();
-  
+
     char *vec = retval.fortran_vec ();
     for (octave_idx_type i = 0; i < nel; i++)
       vec[i] = matrix(i).char_value ();
 
     return retval;
   }
 
   // Use matrix_ref here to clear index cache.
-  void increment (void) 
-   { 
-     matrix_ref() += OCTAVE_INT_T (1); 
+  void increment (void)
+   {
+     matrix_ref() += OCTAVE_INT_T (1);
    }
 
   void decrement (void)
-   { 
-     matrix_ref() -= OCTAVE_INT_T (1); 
+   {
+     matrix_ref() -= OCTAVE_INT_T (1);
    }
 
   void changesign (void)
-   { 
-     matrix_ref ().changesign (); 
+   {
+     matrix_ref ().changesign ();
    }
 
-  idx_vector index_vector (void) const 
+  idx_vector index_vector (void) const
     { return idx_cache ? *idx_cache : set_idx_cache (idx_vector (matrix)); }
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              oct_mach_info::float_format flt_fmt) const
     { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
   // Unsafe.  This function exists to support the MEX interface.
@@ -349,17 +349,17 @@ public:
           return intNDArray<OCTAVE_INT_T> (matrix.dims (), OCTAVE_INT_T ());
         case umap_isnan:
         case umap_isna:
         case umap_isinf:
           return boolNDArray (matrix.dims (), false);
         case umap_finite:
           return boolNDArray (matrix.dims (), true);
 
-        default: 
+        default:
           {
             octave_matrix m (array_value ());
             return m.map (umap);
           }
         }
     }
 
 private:
@@ -400,17 +400,17 @@ public:
       // and similar constructions.  Hmm...
 
       // FIXME -- using this constructor avoids narrowing the
       // 1x1 matrix back to a scalar value.  Need a better solution
       // to this problem.
 
       octave_value tmp
         (new OCTAVE_VALUE_INT_MATRIX_T
-         (OCTAVE_VALUE_INT_NDARRAY_EXTRACTOR_FUNCTION ())); 
+         (OCTAVE_VALUE_INT_NDARRAY_EXTRACTOR_FUNCTION ()));
 
       return tmp.do_index_op (idx, resize_ok);
     }
 
   bool OCTAVE_TYPE_PREDICATE_FUNCTION (void) const { return true; }
 
   bool is_integer_type (void) const { return true; }
 
@@ -529,41 +529,41 @@ public:
     {
       FloatComplexMatrix retval (1, 1);
       retval(0,0) = FloatComplex (scalar.float_value ());
       return retval;
     }
 
   NDArray
   array_value (bool = false) const
-    { 
-      NDArray retval (dim_vector (1, 1)); 
+    {
+      NDArray retval (dim_vector (1, 1));
       retval(0) = scalar.double_value ();
       return retval;
     }
 
   FloatNDArray
   float_array_value (bool = false) const
-    { 
-      FloatNDArray retval (dim_vector (1, 1)); 
+    {
+      FloatNDArray retval (dim_vector (1, 1));
       retval(0) = scalar.float_value ();
       return retval;
     }
 
   ComplexNDArray
   complex_array_value (bool = false) const
-    { 
+    {
       ComplexNDArray retval (dim_vector (1, 1));
       retval(0) = FloatComplex (scalar.double_value ());
       return retval;
     }
 
   FloatComplexNDArray
   float_complex_array_value (bool = false) const
-    { 
+    {
       FloatComplexNDArray retval (dim_vector (1, 1));
       retval(0) = FloatComplex (scalar.float_value ());
       return retval;
     }
 
   boolNDArray
   bool_array_value (bool warn = false) const
   {
@@ -580,24 +580,24 @@ public:
   charNDArray
   char_array_value (bool = false) const
   {
     charNDArray retval (dim_vector (1, 1));
     retval(0) = scalar.char_value ();
     return retval;
   }
 
-  void increment (void) 
-   { 
-     scalar += OCTAVE_INT_T (1); 
+  void increment (void)
+   {
+     scalar += OCTAVE_INT_T (1);
    }
 
   void decrement (void)
-   { 
-     scalar -= OCTAVE_INT_T (1); 
+   {
+     scalar -= OCTAVE_INT_T (1);
    }
 
   idx_vector index_vector (void) const { return idx_vector (scalar); }
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, octave_idx_type skip,
              oct_mach_info::float_format flt_fmt) const
     {
@@ -639,17 +639,17 @@ public:
           return OCTAVE_INT_T ();
         case umap_isnan:
         case umap_isna:
         case umap_isinf:
           return false;
         case umap_finite:
           return true;
 
-        default: 
+        default:
           {
             octave_scalar m (scalar_value ());
             return m.map (umap);
           }
         }
     }
 
 private:
diff --git a/src/ov-lazy-idx.cc b/src/ov-lazy-idx.cc
--- a/src/ov-lazy-idx.cc
+++ b/src/ov-lazy-idx.cc
@@ -64,69 +64,69 @@ octave_lazy_index::try_narrowing_convers
 
     default:
       break;
     }
 
   return retval;
 }
 
-octave_value 
+octave_value
 octave_lazy_index::reshape (const dim_vector& new_dims) const
 {
   return idx_vector (index.as_array ().reshape (new_dims),
                      index.extent (0));
 }
 
-octave_value 
+octave_value
 octave_lazy_index::permute (const Array<int>& vec, bool inv) const
 {
   // If the conversion has already been made, forward the operation.
   if (value.is_defined ())
     return value.permute (vec, inv);
   else
     return idx_vector (index.as_array ().permute (vec, inv),
                        index.extent (0));
 }
 
-octave_value 
+octave_value
 octave_lazy_index::squeeze (void) const
 {
   return idx_vector (index.as_array ().squeeze (),
                      index.extent (0));
 }
 
-octave_value 
+octave_value
 octave_lazy_index::sort (octave_idx_type dim, sortmode mode) const
 {
   const dim_vector odims = index.orig_dimensions ();
   // index_vector can employ a more efficient sorting algorithm.
-  if (mode == ASCENDING && odims.length () == 2 
+  if (mode == ASCENDING && odims.length () == 2
       && (dim >= 0 && dim <= 1) && odims (1-dim) == 1)
     return index_vector ().sorted ();
   else
-    return idx_vector (index.as_array ().sort (dim, mode), 
+    return idx_vector (index.as_array ().sort (dim, mode),
                        index.extent (0));
 }
 
-octave_value 
+octave_value
 octave_lazy_index::sort (Array<octave_idx_type> &sidx, octave_idx_type dim,
                          sortmode mode) const
 {
   const dim_vector odims = index.orig_dimensions ();
   // index_vector can employ a more efficient sorting algorithm.
-  if (mode == ASCENDING && odims.length () == 2 
+  if (mode == ASCENDING && odims.length () == 2
       && (dim >= 0 && dim <= 1) && odims (1-dim) == 1)
     return index_vector ().sorted (sidx);
   else
-    return idx_vector (index.as_array ().sort (sidx, dim, mode), 
+    return idx_vector (index.as_array ().sort (sidx, dim, mode),
                        index.extent (0));
 }
 
-sortmode 
+sortmode
 octave_lazy_index::is_sorted (sortmode mode) const
 {
   if (index.is_range ())
     {
       // Avoid the array conversion.
       octave_idx_type inc = index.increment ();
       if (inc == 0)
         return (mode == UNSORTED ? ASCENDING : mode);
@@ -134,23 +134,23 @@ octave_lazy_index::is_sorted (sortmode m
         return (mode == DESCENDING ? UNSORTED : ASCENDING);
       else
         return (mode == ASCENDING ? UNSORTED : DESCENDING);
     }
   else
     return index.as_array ().is_sorted (mode);
 }
 
-Array<octave_idx_type> 
+Array<octave_idx_type>
 octave_lazy_index::sort_rows_idx (sortmode mode) const
 {
   return index.as_array ().sort_rows_idx (mode);
 }
 
-sortmode 
+sortmode
 octave_lazy_index::is_sorted_rows (sortmode mode) const
 {
   return index.as_array ().is_sorted_rows (mode);
 }
 
 static const std::string value_save_tag ("index_value");
 
 bool octave_lazy_index::save_ascii (std::ostream& os)
@@ -170,27 +170,27 @@ bool octave_lazy_index::load_ascii (std:
     index = value.index_vector ();
 
   return ! error_state;
 }
 
 
 bool octave_lazy_index::save_binary (std::ostream& os, bool& save_as_floats)
 {
-  return save_binary_data (os, make_value (), value_save_tag, 
+  return save_binary_data (os, make_value (), value_save_tag,
                            std::string (), false, save_as_floats);
 }
 
-bool octave_lazy_index::load_binary (std::istream& is, bool swap, 
+bool octave_lazy_index::load_binary (std::istream& is, bool swap,
                                      oct_mach_info::float_format fmt)
 {
   bool dummy;
   std::string doc;
 
-  std::string nm = read_binary_data (is, swap, fmt, std::string (), 
+  std::string nm = read_binary_data (is, swap, fmt, std::string (),
                                      dummy, value, doc);
 
   if (nm != value_save_tag)
     error ("lazy_index: corrupted data on load");
   else
     index = value.index_vector ();
 
   return ! error_state;
diff --git a/src/ov-lazy-idx.h b/src/ov-lazy-idx.h
--- a/src/ov-lazy-idx.h
+++ b/src/ov-lazy-idx.h
@@ -33,20 +33,20 @@ OCTINTERP_API
 octave_lazy_index : public octave_base_value
 {
 public:
 
   octave_lazy_index (void)
     : octave_base_value (), index (), value () { }
 
   octave_lazy_index (const idx_vector& idx)
-    : octave_base_value (), index (idx), value () { } 
+    : octave_base_value (), index (idx), value () { }
 
   octave_lazy_index (const octave_lazy_index& i)
-    : octave_base_value (), index (i.index), value (i.value) { } 
+    : octave_base_value (), index (i.index), value (i.value) { }
 
   ~octave_lazy_index (void) { }
 
   octave_base_value *clone (void) const { return new octave_lazy_index (*this); }
   octave_base_value *empty_clone (void) const { return new octave_matrix (); }
 
   type_conv_info numeric_conversion_function (void) const;
 
@@ -165,23 +165,23 @@ public:
 
   FORWARD_VALUE_QUERY1 (FloatComplex, float_complex_value)
 
   FORWARD_VALUE_QUERY1 (ComplexMatrix, complex_matrix_value)
 
   FORWARD_VALUE_QUERY1 (FloatComplexMatrix, float_complex_matrix_value)
 
   FORWARD_VALUE_QUERY1 (ComplexNDArray, complex_array_value)
-   
+
   FORWARD_VALUE_QUERY1 (FloatComplexNDArray, float_complex_array_value)
-   
+
   FORWARD_VALUE_QUERY1 (boolNDArray, bool_array_value)
 
   FORWARD_VALUE_QUERY1 (charNDArray, char_array_value)
-  
+
   FORWARD_VALUE_QUERY1 (NDArray, array_value)
 
   FORWARD_VALUE_QUERY1 (FloatNDArray, float_array_value)
 
   FORWARD_VALUE_QUERY1 (SparseMatrix, sparse_matrix_value)
 
   FORWARD_VALUE_QUERY1 (SparseComplexMatrix, sparse_complex_matrix_value)
 
@@ -195,29 +195,29 @@ public:
     { return make_value ().print_raw (os, pr_as_read_syntax); }
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
-  bool load_binary (std::istream& is, bool swap, 
+  bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
   // HDF5 functions not defined.
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              oct_mach_info::float_format flt_fmt) const
     { return make_value ().write (os, block_size, output_type, skip, flt_fmt); }
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
-  void *mex_get_data (void) const 
+  void *mex_get_data (void) const
     { return make_value ().mex_get_data (); }
 
   mxArray *as_mxArray (void) const
     { return make_value ().as_mxArray (); }
 
   octave_value map (unary_mapper_t umap) const
     { return make_value ().map (umap); }
 
diff --git a/src/ov-null-mat.cc b/src/ov-null-mat.cc
--- a/src/ov-null-mat.cc
+++ b/src/ov-null-mat.cc
@@ -39,17 +39,17 @@ default_null_matrix_numeric_conversion_f
   // CAST_CONV_ARG (const octave_null_matrix&);
 
   return a.empty_clone ();
 }
 
 octave_base_value::type_conv_info
 octave_null_matrix::numeric_conversion_function (void) const
 {
-  return octave_base_value::type_conv_info (default_null_matrix_numeric_conversion_function, 
+  return octave_base_value::type_conv_info (default_null_matrix_numeric_conversion_function,
                                             octave_matrix::static_type_id ());
 }
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_null_str, "null_string", "char");
 
 const octave_value octave_null_str::instance (new octave_null_str ());
 
 static octave_base_value *
@@ -59,17 +59,17 @@ default_null_str_numeric_conversion_func
   // CAST_CONV_ARG (const octave_null_str&);
 
   return a.empty_clone ();
 }
 
 octave_base_value::type_conv_info
 octave_null_str::numeric_conversion_function (void) const
 {
-  return octave_base_value::type_conv_info (default_null_str_numeric_conversion_function, 
+  return octave_base_value::type_conv_info (default_null_str_numeric_conversion_function,
                                             octave_char_matrix_str::static_type_id ());
 }
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_null_sq_str, "null_sq_string", "char");
 
 const octave_value octave_null_sq_str::instance (new octave_null_sq_str ());
 
 static octave_base_value *
@@ -79,17 +79,17 @@ default_null_sq_str_numeric_conversion_f
   // CAST_CONV_ARG (const octave_null_sq_str&);
 
   return a.empty_clone ();
 }
 
 octave_base_value::type_conv_info
 octave_null_sq_str::numeric_conversion_function (void) const
 {
-  return octave_base_value::type_conv_info (default_null_sq_str_numeric_conversion_function, 
+  return octave_base_value::type_conv_info (default_null_sq_str_numeric_conversion_function,
                                             octave_char_matrix_sq_str::static_type_id ());
 }
 
 DEFUN (isnull, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isnull (@var{x})\n\
 Return true if @var{x} is a special null matrix, string, or single quoted\n\
 string.  Indexed assignment with such a value on the right-hand side should\n\
diff --git a/src/ov-null-mat.h b/src/ov-null-mat.h
--- a/src/ov-null-mat.h
+++ b/src/ov-null-mat.h
@@ -51,17 +51,17 @@ public:
 
 private:
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 // The special "" value
 
-class 
+class
 OCTINTERP_API
 octave_null_str : public octave_char_matrix_str
 {
   octave_null_str (void) : octave_char_matrix_str () { }
 
 public:
 
   static const octave_value instance;
@@ -73,17 +73,17 @@ public:
 
 private:
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 // The special '' value
 
-class 
+class
 OCTINTERP_API
 octave_null_sq_str : public octave_char_matrix_sq_str
 {
   octave_null_sq_str (void) : octave_char_matrix_sq_str () { }
 
 public:
 
   static const octave_value instance;
diff --git a/src/ov-perm.cc b/src/ov-perm.cc
--- a/src/ov-perm.cc
+++ b/src/ov-perm.cc
@@ -73,17 +73,17 @@ octave_perm_matrix::do_index_op (const o
   if (nidx == 2)
     {
       idx0 = idx(0).index_vector ();
       idx1 = idx(1).index_vector ();
     }
 
   // This hack is to allow constructing permutation matrices using
   // eye(n)(p,:), eye(n)(:,q) && eye(n)(p,q) where p & q are permutation
-  // vectors. 
+  // vectors.
   // Note that, for better consistency, eye(n)(:,:) still converts to a full
   // matrix.
   if (! error_state && nidx == 2)
     {
       bool left = idx0.is_permutation (matrix.rows ());
       bool right = idx1.is_permutation (matrix.cols ());
 
       if (left && right)
@@ -243,48 +243,48 @@ octave_perm_matrix::index_vector (void) 
 }
 
 octave_value
 octave_perm_matrix::convert_to_str_internal (bool pad, bool force, char type) const
 {
   return to_dense ().convert_to_str_internal (pad, force, type);
 }
 
-bool 
+bool
 octave_perm_matrix::save_ascii (std::ostream& os)
 {
   typedef octave_int<octave_idx_type> idx_int_type;
 
   os << "# size: " << matrix.rows () << "\n";
   os << "# orient: " << (matrix.is_col_perm () ? 'c' : 'r') << '\n';
 
   Array<octave_idx_type> pvec = matrix.pvec ();
   octave_idx_type n = pvec.length ();
   ColumnVector tmp (n);
   for (octave_idx_type i = 0; i < n; i++) tmp(i) = pvec(i) + 1;
   os << tmp;
 
   return true;
 }
 
-bool 
+bool
 octave_perm_matrix::load_ascii (std::istream& is)
 {
   typedef octave_int<octave_idx_type> idx_int_type;
   octave_idx_type n;
   bool success = true;
   char orient;
 
   if (extract_keyword (is, "size", n, true)
       && extract_keyword (is, "orient", orient, true))
     {
       bool colp = orient == 'c';
       ColumnVector tmp (n);
       is >> tmp;
-      if (!is) 
+      if (!is)
         {
           error ("load: failed to load permutation matrix constant");
           success = false;
         }
       else
         {
           Array<octave_idx_type> pvec (dim_vector (n, 1));
           for (octave_idx_type i = 0; i < n; i++) pvec(i) = tmp(i) - 1;
@@ -298,17 +298,17 @@ octave_perm_matrix::load_ascii (std::ist
     {
       error ("load: failed to extract size & orientation");
       success = false;
     }
 
   return success;
 }
 
-bool 
+bool
 octave_perm_matrix::save_binary (std::ostream& os, bool&)
 {
 
   int32_t sz = matrix.rows ();
   bool colp = matrix.is_col_perm ();
   os.write (reinterpret_cast<char *> (&sz), 4);
   os.write (reinterpret_cast<char *> (&colp), 1);
   os.write (reinterpret_cast<const char *> (matrix.data ()), matrix.byte_size ());
@@ -329,17 +329,17 @@ octave_perm_matrix::load_binary (std::is
   MArray<octave_idx_type> m (dim_vector (sz, 1));
 
   if (! is.read (reinterpret_cast<char *> (m.fortran_vec ()), m.byte_size ()))
     return false;
 
   if (swap)
     {
       int nel = m.numel ();
-      for (int i = 0; i < nel; i++) 
+      for (int i = 0; i < nel; i++)
         switch (sizeof (octave_idx_type))
           {
           case 8:
             swap_bytes<8> (&m(i));
             break;
           case 4:
             swap_bytes<4> (&m(i));
             break;
@@ -384,18 +384,18 @@ octave_perm_matrix::print (std::ostream&
   print_raw (os, pr_as_read_syntax);
   newline (os);
 }
 
 int
 octave_perm_matrix::write (octave_stream& os, int block_size,
                                 oct_data_conv::data_type output_type, int skip,
                                 oct_mach_info::float_format flt_fmt) const
-{ 
-  return to_dense ().write (os, block_size, output_type, skip, flt_fmt); 
+{
+  return to_dense ().write (os, block_size, output_type, skip, flt_fmt);
 }
 
 void
 octave_perm_matrix::print_info (std::ostream& os,
                                     const std::string& prefix) const
 {
   matrix.print_info (os, prefix);
 }
@@ -407,17 +407,17 @@ octave_perm_matrix::to_dense (void) cons
   if (! dense_cache.is_defined ())
       dense_cache = Matrix (matrix);
 
   return dense_cache;
 }
 
 DEFINE_OCTAVE_ALLOCATOR (octave_perm_matrix);
 
-DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_perm_matrix, 
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_perm_matrix,
                                      "permutation matrix", "double");
 
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
   CAST_CONV_ARG (const octave_perm_matrix&);
 
   return new octave_matrix (v.matrix_value ());
diff --git a/src/ov-perm.h b/src/ov-perm.h
--- a/src/ov-perm.h
+++ b/src/ov-perm.h
@@ -25,17 +25,17 @@ along with Octave; see the file COPYING.
 
 #include "mx-base.h"
 #include "str-vec.h"
 
 #include "ov-base.h"
 #include "ov-typeinfo.h"
 #include "oct-obj.h"
 
-class 
+class
 OCTINTERP_API
 octave_perm_matrix : public octave_base_value
 {
 public:
   octave_perm_matrix (void) : matrix (), dense_cache () { }
 
   octave_perm_matrix (const PermMatrix& p) : matrix (p), dense_cache () { }
 
@@ -142,24 +142,24 @@ public:
 
   FloatComplex float_complex_value (bool = false) const;
 
   ComplexMatrix complex_matrix_value (bool = false) const;
 
   FloatComplexMatrix float_complex_matrix_value (bool = false) const;
 
   ComplexNDArray complex_array_value (bool = false) const;
-   
+
   FloatComplexNDArray float_complex_array_value (bool = false) const;
-   
+
   boolNDArray bool_array_value (bool warn = false) const;
 
   charNDArray char_array_value (bool = false) const;
-  
-  NDArray array_value (bool = false) const; 
+
+  NDArray array_value (bool = false) const;
 
   FloatNDArray float_array_value (bool = false) const;
 
   SparseMatrix sparse_matrix_value (bool = false) const;
 
   SparseComplexMatrix sparse_complex_matrix_value (bool = false) const;
 
   int8NDArray
@@ -191,17 +191,17 @@ public:
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
-  bool load_binary (std::istream& is, bool swap, 
+  bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              oct_mach_info::float_format flt_fmt) const;
 
   mxArray *as_mxArray (void) const;
 
@@ -211,17 +211,17 @@ public:
 
   void print_info (std::ostream& os, const std::string& prefix) const;
 
   octave_value map (unary_mapper_t umap) const
     { return to_dense ().map (umap); }
 
 protected:
 
-  PermMatrix matrix;  
+  PermMatrix matrix;
 
   virtual octave_value to_dense (void) const;
 
   mutable octave_value dense_cache;
 
 private:
 
   DECLARE_OCTAVE_ALLOCATOR
diff --git a/src/ov-range.cc b/src/ov-range.cc
--- a/src/ov-range.cc
+++ b/src/ov-range.cc
@@ -208,23 +208,23 @@ octave_range::float_value (bool) const
 
 charNDArray
 octave_range::char_array_value (bool) const
 {
   const Matrix matrix = range.matrix_value ();
   charNDArray retval (dims ());
 
   octave_idx_type nel = numel ();
-  
+
   for (octave_idx_type i = 0; i < nel; i++)
     retval.elem (i) = static_cast<char>(matrix.elem (i));
 
   return retval;
 }
-  
+
 octave_value
 octave_range::all (int dim) const
 {
   // FIXME -- this is a potential waste of memory.
 
   Matrix m = range.matrix_value ();
 
   return m.all (dim);
@@ -235,22 +235,22 @@ octave_range::any (int dim) const
 {
   // FIXME -- this is a potential waste of memory.
 
   Matrix m = range.matrix_value ();
 
   return m.any (dim);
 }
 
-octave_value 
+octave_value
 octave_range::diag (octave_idx_type k) const
-{ 
+{
   return (k == 0
           ? octave_value (DiagMatrix (DiagArray2<double> (range.matrix_value ())))
-          : octave_value (range.diag (k))); 
+          : octave_value (range.diag (k)));
 }
 
 
 bool
 octave_range::is_true (void) const
 {
   bool retval = false;
 
@@ -318,25 +318,25 @@ octave_range::bool_array_value (bool war
   if (m.any_element_is_nan ())
     gripe_nan_to_logical_conversion ();
   else if (warn && m.any_element_not_one_or_zero ())
     gripe_logical_conversion ();
 
   return boolNDArray (m);
 }
 
-octave_value 
+octave_value
 octave_range::resize (const dim_vector& dv, bool fill) const
-{ 
-  NDArray retval = array_value (); 
+{
+  NDArray retval = array_value ();
   if (fill)
     retval.resize (dv, NDArray::resize_fill_value ());
   else
-    retval.resize (dv); 
-  return retval; 
+    retval.resize (dv);
+  return retval;
 }
 
 octave_value
 octave_range::convert_to_str_internal (bool pad, bool force, char type) const
 {
   octave_value tmp (range.matrix_value ());
   return tmp.convert_to_str (pad, force, type);
 }
@@ -368,17 +368,17 @@ octave_range::print_name_tag (std::ostre
     os << name << " = ";
   else
     {
       os << name << " =";
       newline (os);
       newline (os);
       retval = true;
     }
-    
+
   return retval;
 }
 
 // Skip white space and comments on stream IS.
 
 static void
 skip_comments (std::istream& is)
 {
@@ -389,17 +389,17 @@ skip_comments (std::istream& is)
         ; // Skip whitespace on way to beginning of next line.
       else
         break;
     }
 
   skip_until_newline (is, false);
 }
 
-bool 
+bool
 octave_range::save_ascii (std::ostream& os)
 {
   Range r = range_value ();
   double base = r.base ();
   double limit = r.limit ();
   double inc = r.inc ();
   octave_idx_type len = r.nelem ();
 
@@ -416,17 +416,17 @@ octave_range::save_ascii (std::ostream& 
     os << len;
   os << " ";
   octave_write_double (os, inc);
   os << "\n";
 
   return true;
 }
 
-bool 
+bool
 octave_range::load_ascii (std::istream& is)
 {
   // # base, limit, range comment added by save ().
   skip_comments (is);
 
   double base, limit, inc;
   is >> base >> limit >> inc;
 
@@ -439,17 +439,17 @@ octave_range::load_ascii (std::istream& 
   if (inc != 0)
     range = Range (base, limit, inc);
   else
     range = Range (base, inc, static_cast<octave_idx_type> (limit));
 
   return true;
 }
 
-bool 
+bool
 octave_range::save_binary (std::ostream& os, bool& /* save_as_floats */)
 {
   char tmp = LS_DOUBLE;
   os.write (reinterpret_cast<char *> (&tmp), 1);
   Range r = range_value ();
   double bas = r.base ();
   double lim = r.limit ();
   double inc = r.inc ();
@@ -458,17 +458,17 @@ octave_range::save_binary (std::ostream&
 
   os.write (reinterpret_cast<char *> (&bas), 8);
   os.write (reinterpret_cast<char *> (&lim), 8);
   os.write (reinterpret_cast<char *> (&inc), 8);
 
   return true;
 }
 
-bool 
+bool
 octave_range::load_binary (std::istream& is, bool swap,
                            oct_mach_info::float_format /* fmt */)
 {
   char tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), 1))
     return false;
   double bas, lim, inc;
   if (! is.read (reinterpret_cast<char *> (&bas), 8))
@@ -489,19 +489,19 @@ octave_range::load_binary (std::istream&
     range = Range (bas, inc, static_cast<octave_idx_type> (lim));
 
   return true;
 }
 
 #if defined (HAVE_HDF5)
 
 // The following subroutines creates an HDF5 representation of the way
-// we will store Octave range types (triplets of floating-point numbers). 
-// NUM_TYPE is the HDF5 numeric type to use for storage (e.g. 
-// H5T_NATIVE_DOUBLE to save as 'double'). Note that any necessary 
+// we will store Octave range types (triplets of floating-point numbers).
+// NUM_TYPE is the HDF5 numeric type to use for storage (e.g.
+// H5T_NATIVE_DOUBLE to save as 'double'). Note that any necessary
 // conversions are handled automatically by HDF5.
 
 static hid_t
 hdf5_make_range_type (hid_t num_type)
 {
   hid_t type_id = H5Tcreate (H5T_COMPOUND, sizeof (double) * 3);
 
   H5Tinsert (type_id, "base", 0 * sizeof (double), num_type);
@@ -518,34 +518,34 @@ octave_range::save_hdf5 (hid_t loc_id, c
   hsize_t dimens[3];
   hid_t space_hid = -1, type_hid = -1, data_hid = -1;
   bool retval = true;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0) return false;
 
   type_hid = hdf5_make_range_type (H5T_NATIVE_DOUBLE);
-  if (type_hid < 0) 
+  if (type_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
 #if HAVE_HDF5_18
-  data_hid = H5Dcreate (loc_id, name, type_hid, space_hid, 
+  data_hid = H5Dcreate (loc_id, name, type_hid, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, type_hid, space_hid, H5P_DEFAULT);
 #endif
-  if (data_hid < 0) 
+  if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Tclose (type_hid);
       return false;
     }
-  
+
   Range r = range_value ();
   double range_vals[3];
   range_vals[0] = r.base ();
   range_vals[1] = r.inc () != 0 ? r.limit () : r.nelem ();
   range_vals[2] = r.inc ();
 
   if (H5Dwrite (data_hid, type_hid, H5S_ALL, H5S_ALL, H5P_DEFAULT,
                 range_vals) >= 0)
@@ -559,17 +559,17 @@ octave_range::save_hdf5 (hid_t loc_id, c
 
   H5Dclose (data_hid);
   H5Tclose (type_hid);
   H5Sclose (space_hid);
 
   return retval;
 }
 
-bool 
+bool
 octave_range::load_hdf5 (hid_t loc_id, const char *name)
 {
   bool retval = false;
 
 #if HAVE_HDF5_18
   hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
@@ -592,30 +592,30 @@ octave_range::load_hdf5 (hid_t loc_id, c
     {
       H5Tclose (range_type);
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       return false;
     }
 
   double rangevals[3];
-  if (H5Dread (data_hid, range_type, H5S_ALL, H5S_ALL, H5P_DEFAULT, 
+  if (H5Dread (data_hid, range_type, H5S_ALL, H5S_ALL, H5P_DEFAULT,
                rangevals) >= 0)
     {
       retval = true;
       octave_idx_type nel;
-      if (hdf5_get_scalar_attr (data_hid, H5T_NATIVE_IDX, 
+      if (hdf5_get_scalar_attr (data_hid, H5T_NATIVE_IDX,
                                 "OCTAVE_RANGE_NELEM", &nel))
         range = Range (rangevals[0], rangevals[2], nel);
       else
         {
           if (rangevals[2] != 0)
             range = Range (rangevals[0], rangevals[1], rangevals[2]);
           else
-            range = Range (rangevals[0], rangevals[2], 
+            range = Range (rangevals[0], rangevals[2],
                            static_cast<octave_idx_type> (rangevals[1]));
         }
     }
 
   H5Tclose (range_type);
   H5Sclose (space_hid);
   H5Dclose (data_hid);
 
diff --git a/src/ov-range.h b/src/ov-range.h
--- a/src/ov-range.h
+++ b/src/ov-range.h
@@ -66,17 +66,17 @@ public:
   octave_range (const Range& r)
     : octave_base_value (), range (r), idx_cache ()
       {
         if (range.nelem () < 0 && range.nelem () != -2)
           ::error ("invalid range");
       }
 
   octave_range (const octave_range& r)
-    : octave_base_value (), range (r.range), 
+    : octave_base_value (), range (r.range),
       idx_cache (r.idx_cache ? new idx_vector (*r.idx_cache) : 0)
     { }
 
   octave_range (const Range& r, const idx_vector& cache)
     : octave_base_value (), range (r), idx_cache ()
       {
         set_idx_cache (cache);
       }
@@ -102,17 +102,17 @@ public:
     { return subsref (type, idx); }
 
   octave_value do_index_op (const octave_value_list& idx,
                             bool resize_ok = false);
 
   idx_vector index_vector (void) const;
 
   dim_vector dims (void) const
-    { 
+    {
       octave_idx_type n = range.nelem ();
       return dim_vector (n > 0, n);
     }
 
   octave_value resize (const dim_vector& dv, bool fill = false) const;
 
 
   size_t byte_size (void) const { return 3 * sizeof (double); }
@@ -185,17 +185,17 @@ public:
 
   NDArray array_value (bool = false) const
     { return range.matrix_value (); }
 
   FloatNDArray float_array_value (bool = false) const
     { return FloatMatrix (range.matrix_value ()); }
 
   charNDArray char_array_value (bool = false) const;
-  
+
   // FIXME -- it would be better to have Range::intXNDArray_value
   // functions to avoid the intermediate conversion to a matrix
   // object.
 
   int8NDArray
   int8_array_value (void) const { return int8NDArray (array_value ()); }
 
   int16NDArray
@@ -254,17 +254,17 @@ public:
   bool print_name_tag (std::ostream& os, const std::string& name) const;
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
-  bool load_binary (std::istream& is, bool swap, 
+  bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
@@ -296,17 +296,17 @@ private:
       delete idx_cache;
       idx_cache = idx ? new idx_vector (idx) : 0;
       return idx;
     }
 
   void clear_cached_info (void) const
     {
       delete idx_cache; idx_cache = 0;
-    } 
+    }
 
   mutable idx_vector *idx_cache;
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
diff --git a/src/ov-re-diag.cc b/src/ov-re-diag.cc
--- a/src/ov-re-diag.cc
+++ b/src/ov-re-diag.cc
@@ -83,22 +83,22 @@ octave_diag_matrix::try_narrowing_conver
 octave_value
 octave_diag_matrix::do_index_op (const octave_value_list& idx,
                                  bool resize_ok)
 {
   octave_value retval;
 
   // This hack is to allow constructing permutation matrices using
   // eye(n)(p,:), eye(n)(:,q) && eye(n)(p,q) where p & q are permutation
-  // vectors. 
+  // vectors.
   if (! resize_ok && idx.length () == 2 && matrix.is_multiple_of_identity (1))
     {
       idx_vector idx0 = idx(0).index_vector ();
       idx_vector idx1 = idx(1).index_vector ();
-      
+
       if (! error_state)
         {
           bool left = idx0.is_permutation (matrix.rows ());
           bool right = idx1.is_permutation (matrix.cols ());
 
           if (left && right)
             {
               if (idx0.is_colon ()) left = false;
@@ -168,17 +168,17 @@ octave_diag_matrix::map (unary_mapper_t 
         retval.resize (matrix.rows (), matrix.columns ());
         return retval;
       }
     default:
       return to_dense ().map (umap);
     }
 }
 
-bool 
+bool
 octave_diag_matrix::save_binary (std::ostream& os, bool& save_as_floats)
 {
 
   int32_t r = matrix.rows (), c = matrix.cols ();
   os.write (reinterpret_cast<char *> (&r), 4);
   os.write (reinterpret_cast<char *> (&c), 4);
 
   Matrix m = Matrix (matrix.diag ());
@@ -201,17 +201,17 @@ octave_diag_matrix::save_binary (std::os
     }
 
   const double *mtmp = m.data ();
   write_doubles (os, mtmp, st, m.numel ());
 
   return true;
 }
 
-bool 
+bool
 octave_diag_matrix::load_binary (std::istream& is, bool swap,
                                  oct_mach_info::float_format fmt)
 {
   int32_t r, c;
   char tmp;
   if (! (is.read (reinterpret_cast<char *> (&r), 4)
          && is.read (reinterpret_cast<char *> (&c), 4)
          && is.read (reinterpret_cast<char *> (&tmp), 1)))
@@ -228,17 +228,17 @@ octave_diag_matrix::load_binary (std::is
   read_doubles (is, re, static_cast<save_type> (tmp), len, swap, fmt);
   if (error_state || ! is)
     return false;
   matrix = m;
 
   return true;
 }
 
-bool 
-octave_diag_matrix::chk_valid_scalar (const octave_value& val, 
+bool
+octave_diag_matrix::chk_valid_scalar (const octave_value& val,
                                       double& x) const
 {
   bool retval = val.is_real_scalar ();
   if (retval)
     x = val.double_value ();
   return retval;
 }
diff --git a/src/ov-re-diag.h b/src/ov-re-diag.h
--- a/src/ov-re-diag.h
+++ b/src/ov-re-diag.h
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 #include "ov-base-diag.h"
 #include "ov-re-mat.h"
 #include "ov-typeinfo.h"
 
 // Real diagonal matrix values.
 
 class
 OCTINTERP_API
-octave_diag_matrix 
+octave_diag_matrix
   : public octave_base_diag<DiagMatrix, Matrix>
 {
 public:
 
   octave_diag_matrix (void)
     : octave_base_diag<DiagMatrix, Matrix> () { }
 
   octave_diag_matrix (const DiagMatrix& m)
@@ -75,24 +75,24 @@ public:
   FloatDiagMatrix float_diag_matrix_value (bool = false) const;
 
   ComplexDiagMatrix complex_diag_matrix_value (bool = false) const;
 
   FloatComplexDiagMatrix float_complex_diag_matrix_value (bool = false) const;
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
-  bool load_binary (std::istream& is, bool swap, 
+  bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
-  bool chk_valid_scalar (const octave_value&, 
+  bool chk_valid_scalar (const octave_value&,
                          double&) const;
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/src/ov-re-mat.cc b/src/ov-re-mat.cc
--- a/src/ov-re-mat.cc
+++ b/src/ov-re-mat.cc
@@ -225,139 +225,139 @@ octave_matrix::bool_array_value (bool wa
 {
   if (matrix.any_element_is_nan ())
     gripe_nan_to_logical_conversion ();
   else if (warn && matrix.any_element_not_one_or_zero ())
     gripe_logical_conversion ();
 
   return boolNDArray (matrix);
 }
-  
+
 charNDArray
 octave_matrix::char_array_value (bool) const
 {
   charNDArray retval (dims ());
 
   octave_idx_type nel = numel ();
-  
+
   for (octave_idx_type i = 0; i < nel; i++)
     retval.elem (i) = static_cast<char>(matrix.elem (i));
 
   return retval;
 }
-  
-SparseMatrix 
+
+SparseMatrix
 octave_matrix::sparse_matrix_value (bool) const
 {
   return SparseMatrix (matrix.matrix_value ());
 }
 
-SparseComplexMatrix 
+SparseComplexMatrix
 octave_matrix::sparse_complex_matrix_value (bool) const
 {
   // FIXME Need a SparseComplexMatrix (Matrix) constructor to make
   // this function more efficient. Then this should become
   // return SparseComplexMatrix (matrix.matrix_value ());
   return SparseComplexMatrix (sparse_matrix_value ());
 }
 
 octave_value
 octave_matrix::diag (octave_idx_type k) const
 {
   octave_value retval;
-  if (k == 0 && matrix.ndims () == 2 
+  if (k == 0 && matrix.ndims () == 2
       && (matrix.rows () == 1 || matrix.columns () == 1))
     retval = DiagMatrix (DiagArray2<double> (matrix));
   else
     retval = octave_base_matrix<NDArray>::diag (k);
 
   return retval;
 }
 
 // We override these two functions to allow reshaping both
 // the matrix and the index cache.
-octave_value 
+octave_value
 octave_matrix::reshape (const dim_vector& new_dims) const
 {
   if (idx_cache)
     {
       return new octave_matrix (matrix.reshape (new_dims),
                                 idx_vector (idx_cache->as_array ().reshape (new_dims),
                                             idx_cache->extent (0)));
     }
   else
     return octave_base_matrix<NDArray>::reshape (new_dims);
 }
 
-octave_value 
+octave_value
 octave_matrix::squeeze (void) const
 {
   if (idx_cache)
     {
       return new octave_matrix (matrix.squeeze (),
                                 idx_vector (idx_cache->as_array ().squeeze (),
                                             idx_cache->extent (0)));
     }
   else
     return octave_base_matrix<NDArray>::squeeze ();
 }
 
-octave_value 
+octave_value
 octave_matrix::sort (octave_idx_type dim, sortmode mode) const
 {
   if (idx_cache)
     {
       // This is a valid index matrix, so sort via integers because it's
       // generally more efficient.
       return octave_lazy_index (*idx_cache).sort (dim, mode);
     }
   else
     return octave_base_matrix<NDArray>::sort (dim, mode);
 }
 
-octave_value 
+octave_value
 octave_matrix::sort (Array<octave_idx_type> &sidx, octave_idx_type dim,
                      sortmode mode) const
 {
   if (idx_cache)
     {
       // This is a valid index matrix, so sort via integers because it's
       // generally more efficient.
       return octave_lazy_index (*idx_cache).sort (sidx, dim, mode);
     }
   else
     return octave_base_matrix<NDArray>::sort (sidx, dim, mode);
 }
 
-sortmode 
+sortmode
 octave_matrix::is_sorted (sortmode mode) const
 {
   if (idx_cache)
     {
       // This is a valid index matrix, so check via integers because it's
       // generally more efficient.
       return idx_cache->as_array ().is_sorted (mode);
     }
   else
     return octave_base_matrix<NDArray>::is_sorted (mode);
 }
-Array<octave_idx_type> 
+Array<octave_idx_type>
 octave_matrix::sort_rows_idx (sortmode mode) const
 {
   if (idx_cache)
     {
       // This is a valid index matrix, so sort via integers because it's
       // generally more efficient.
       return octave_lazy_index (*idx_cache).sort_rows_idx (mode);
     }
   else
     return octave_base_matrix<NDArray>::sort_rows_idx (mode);
 }
 
-sortmode 
+sortmode
 octave_matrix::is_sorted_rows (sortmode mode) const
 {
   if (idx_cache)
     {
       // This is a valid index matrix, so check via integers because it's
       // generally more efficient.
       return idx_cache->as_array ().is_sorted_rows (mode);
     }
@@ -409,17 +409,17 @@ octave_matrix::convert_to_str_internal (
         }
     }
 
   retval = octave_value (chm, type);
 
   return retval;
 }
 
-bool 
+bool
 octave_matrix::save_ascii (std::ostream& os)
 {
   dim_vector d = dims ();
 
   if (d.length () > 2)
     {
       NDArray tmp = array_value ();
 
@@ -427,28 +427,28 @@ octave_matrix::save_ascii (std::ostream&
 
       for (int i=0; i < d.length (); i++)
         os << " " << d (i);
 
       os << "\n" << tmp;
     }
   else
     {
-      // Keep this case, rather than use generic code above for backward 
+      // Keep this case, rather than use generic code above for backward
       // compatiability. Makes load_ascii much more complex!!
       os << "# rows: " << rows () << "\n"
          << "# columns: " << columns () << "\n";
 
       os << matrix_value ();
     }
 
   return true;
 }
 
-bool 
+bool
 octave_matrix::load_ascii (std::istream& is)
 {
   bool success = true;
 
   string_vector keywords(2);
 
   keywords[0] = "ndims";
   keywords[1] = "rows";
@@ -515,17 +515,17 @@ octave_matrix::load_ascii (std::istream&
                       success = false;
                     }
                 }
               else if (nr == 0 || nc == 0)
                 matrix = Matrix (nr, nc);
               else
                 panic_impossible ();
             }
-          else 
+          else
             {
               error ("load: failed to extract number of rows and columns");
               success = false;
             }
         }
       else
         panic_impossible ();
     }
@@ -533,17 +533,17 @@ octave_matrix::load_ascii (std::istream&
     {
       error ("load: failed to extract number of rows and columns");
       success = false;
     }
 
   return success;
 }
 
-bool 
+bool
 octave_matrix::save_binary (std::ostream& os, bool& save_as_floats)
 {
 
   dim_vector d = dims ();
   if (d.length() < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
@@ -575,17 +575,17 @@ octave_matrix::save_binary (std::ostream
     }
 
   const double *mtmp = m.data ();
   write_doubles (os, mtmp, st, d.numel ());
 
   return true;
 }
 
-bool 
+bool
 octave_matrix::load_binary (std::istream& is, bool swap,
                                  oct_mach_info::float_format fmt)
 {
   char tmp;
   int32_t mdims;
   if (! is.read (reinterpret_cast<char *> (&mdims), 4))
     return false;
   if (swap)
@@ -664,17 +664,17 @@ octave_matrix::save_hdf5 (hid_t loc_id, 
   bool retval = true;
   NDArray m = array_value ();
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
     hdims[i] = dv (rank-i-1);
- 
+
   space_hid = H5Screate_simple (rank, hdims, 0);
 
   if (space_hid < 0) return false;
 
   hid_t save_type_hid = H5T_NATIVE_DOUBLE;
 
   if (save_as_floats)
     {
@@ -692,22 +692,22 @@ octave_matrix::save_hdf5 (hid_t loc_id, 
     {
       double max_val, min_val;
 
       if (m.all_integers (max_val, min_val))
         save_type_hid
           = save_type_to_hdf5 (get_save_type (max_val, min_val));
     }
 #endif /* HAVE_HDF5_INT2FLOAT_CONVERSIONS */
- 
+
 #if HAVE_HDF5_18
-  data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid, 
+  data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
-  data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid, 
+  data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid,
                         H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
 
@@ -736,17 +736,17 @@ octave_matrix::load_hdf5 (hid_t loc_id, 
 #if HAVE_HDF5_18
   hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
   hid_t space_id = H5Dget_space (data_hid);
 
   hsize_t rank = H5Sget_simple_extent_ndims (space_id);
-  
+
   if (rank < 1)
     {
       H5Sclose (space_id);
       H5Dclose (data_hid);
       return false;
     }
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
@@ -765,18 +765,18 @@ octave_matrix::load_hdf5 (hid_t loc_id, 
     {
       dv.resize (rank);
       for (hsize_t i = 0, j = rank - 1; i < rank; i++, j--)
         dv(j) = hdims[i];
     }
 
   NDArray m (dv);
   double *re = m.fortran_vec ();
-  if (H5Dread (data_hid, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, 
-               H5P_DEFAULT, re) >= 0) 
+  if (H5Dread (data_hid, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL,
+               H5P_DEFAULT, re) >= 0)
     {
       retval = true;
       matrix = m;
     }
 
   H5Sclose (space_id);
   H5Dclose (data_hid);
 
diff --git a/src/ov-re-mat.h b/src/ov-re-mat.h
--- a/src/ov-re-mat.h
+++ b/src/ov-re-mat.h
@@ -75,28 +75,28 @@ public:
     : octave_base_matrix<NDArray> (Matrix (v)) { }
 
   octave_matrix (const ColumnVector& v)
     : octave_base_matrix<NDArray> (Matrix (v)) { }
 
   octave_matrix (const octave_matrix& m)
     : octave_base_matrix<NDArray> (m) { }
 
-  octave_matrix (const Array<octave_idx_type>& idx, 
+  octave_matrix (const Array<octave_idx_type>& idx,
                  bool zero_based = false, bool cache_index = false)
     : octave_base_matrix<NDArray> (NDArray (idx, zero_based))
     {
       // Auto-create cache to speed up subsequent indexing.
       if (zero_based && cache_index)
         set_idx_cache (idx_vector (idx));
     }
 
   octave_matrix (const NDArray& nda, const idx_vector& cache)
-    : octave_base_matrix<NDArray> (nda) 
-    { 
+    : octave_base_matrix<NDArray> (nda)
+    {
       set_idx_cache (cache);
     }
 
   ~octave_matrix (void) { }
 
   octave_base_value *clone (void) const { return new octave_matrix (*this); }
   octave_base_value *empty_clone (void) const { return new octave_matrix (); }
 
@@ -156,23 +156,23 @@ public:
 
   FloatComplex float_complex_value (bool = false) const;
 
   ComplexMatrix complex_matrix_value (bool = false) const;
 
   FloatComplexMatrix float_complex_matrix_value (bool = false) const;
 
   ComplexNDArray complex_array_value (bool = false) const;
-   
+
   FloatComplexNDArray float_complex_array_value (bool = false) const;
-   
+
   boolNDArray bool_array_value (bool warn = false) const;
 
   charNDArray char_array_value (bool = false) const;
-  
+
   NDArray array_value (bool = false) const { return matrix; }
 
   FloatNDArray float_array_value (bool = false) const { return matrix; }
 
   SparseMatrix sparse_matrix_value (bool = false) const;
 
   SparseComplexMatrix sparse_complex_matrix_value (bool = false) const;
 
@@ -204,17 +204,17 @@ public:
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
-  bool load_binary (std::istream& is, bool swap, 
+  bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
diff --git a/src/ov-re-sparse.cc b/src/ov-re-sparse.cc
--- a/src/ov-re-sparse.cc
+++ b/src/ov-re-sparse.cc
@@ -160,36 +160,36 @@ octave_sparse_matrix::char_array_value (
   octave_idx_type nr = matrix.rows ();
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = matrix.cidx(j); i < matrix.cidx(j+1); i++)
       retval(matrix.ridx(i) + nr * j) = static_cast<char>(matrix.data (i));
 
   return retval;
 }
-  
+
 ComplexMatrix
 octave_sparse_matrix::complex_matrix_value (bool) const
 {
   return ComplexMatrix (matrix.matrix_value ());
 }
 
 ComplexNDArray
 octave_sparse_matrix::complex_array_value (bool) const
 {
   return ComplexNDArray (ComplexMatrix (matrix.matrix_value ()));
 }
 
-NDArray 
+NDArray
 octave_sparse_matrix::array_value (bool) const
 {
   return NDArray (matrix.matrix_value ());
 }
 
-SparseBoolMatrix 
+SparseBoolMatrix
 octave_sparse_matrix::sparse_bool_matrix_value (bool warn) const
 {
   if (matrix.any_element_is_nan ())
     gripe_nan_to_logical_conversion ();
   else if (warn && matrix.any_element_not_one_or_zero ())
     gripe_logical_conversion ();
 
   return mx_el_ne (matrix, 0.0);
@@ -207,21 +207,21 @@ octave_sparse_matrix::convert_to_str_int
       char s = '\0';
       retval = octave_value (&s, type);
     }
   else
     {
       octave_idx_type nr = matrix.rows ();
       octave_idx_type nc = matrix.cols ();
       charNDArray chm (dv, static_cast<char> (0));
-          
+
       bool warned = false;
 
       for (octave_idx_type j = 0; j < nc; j++)
-        for (octave_idx_type i = matrix.cidx(j); 
+        for (octave_idx_type i = matrix.cidx(j);
              i < matrix.cidx(j+1); i++)
           {
             octave_quit ();
 
             double d = matrix.data (i);
 
               if (xisnan (d))
                 {
@@ -241,52 +241,52 @@ octave_sparse_matrix::convert_to_str_int
 
                       if (! warned)
                         {
                           ::warning ("range error for conversion to character value");
                           warned = true;
                         }
                     }
 
-                  chm (matrix.ridx(i) + j * nr) = 
+                  chm (matrix.ridx(i) + j * nr) =
                     static_cast<char> (ival);
                 }
           }
 
       retval = octave_value (chm, type);
     }
 
   return retval;
 }
 
-bool 
+bool
 octave_sparse_matrix::save_binary (std::ostream& os, bool&save_as_floats)
 {
   dim_vector d = this->dims ();
   if (d.length() < 1)
     return false;
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
 
   int nr = d(0);
   int nc = d(1);
   int nz = nnz ();
 
   int32_t itmp;
   // Use negative value for ndims to be consistent with other formats
-  itmp= -2;        
+  itmp= -2;
   os.write (reinterpret_cast<char *> (&itmp), 4);
-  
-  itmp= nr;    
+
+  itmp= nr;
   os.write (reinterpret_cast<char *> (&itmp), 4);
-  
+
   itmp= nc;
   os.write (reinterpret_cast<char *> (&itmp), 4);
-  
+
   itmp= nz;
   os.write (reinterpret_cast<char *> (&itmp), 4);
 
   save_type st = LS_DOUBLE;
   if (save_as_floats)
     {
       if (matrix.too_large_for_float ())
         {
@@ -300,27 +300,27 @@ octave_sparse_matrix::save_binary (std::
     {
       double max_val, min_val;
       if (matrix.all_integers (max_val, min_val))
         st = get_save_type (max_val, min_val);
     }
 
   // add one to the printed indices to go from
   // zero-based to one-based arrays
-   for (int i = 0; i < nc+1; i++)  
+   for (int i = 0; i < nc+1; i++)
      {
        octave_quit ();
        itmp = matrix.cidx(i);
        os.write (reinterpret_cast<char *> (&itmp), 4);
      }
 
-   for (int i = 0; i < nz; i++) 
+   for (int i = 0; i < nz; i++)
      {
        octave_quit ();
-       itmp = matrix.ridx(i); 
+       itmp = matrix.ridx(i);
        os.write (reinterpret_cast<char *> (&itmp), 4);
      }
 
    write_doubles (os, matrix.data(), st, nz);
 
   return true;
 }
 
@@ -355,56 +355,56 @@ octave_sparse_matrix::load_binary (std::
       swap_bytes<4> (&nc);
       swap_bytes<4> (&nz);
     }
 
   SparseMatrix m (static_cast<octave_idx_type> (nr),
                   static_cast<octave_idx_type> (nc),
                   static_cast<octave_idx_type> (nz));
 
-  for (int i = 0; i < nc+1; i++) 
+  for (int i = 0; i < nc+1; i++)
     {
       octave_quit ();
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
         return false;
       if (swap)
         swap_bytes<4> (&tmp);
       m.xcidx(i) = tmp;
     }
 
-  for (int i = 0; i < nz; i++) 
+  for (int i = 0; i < nz; i++)
     {
       octave_quit ();
       if (! is.read (reinterpret_cast<char *> (&tmp), 4))
         return false;
       if (swap)
         swap_bytes<4> (&tmp);
       m.xridx(i) = tmp;
     }
 
   if (! is.read (reinterpret_cast<char *> (&ctmp), 1))
     return false;
-  
+
   read_doubles (is, m.xdata (), static_cast<save_type> (ctmp), nz, swap, fmt);
 
   if (error_state || ! is)
     return false;
 
   if (! m.indices_ok ())
     return false;
 
   matrix = m;
 
   return true;
 }
 
 #if defined (HAVE_HDF5)
 
 bool
-octave_sparse_matrix::save_hdf5 (hid_t loc_id, const char *name, 
+octave_sparse_matrix::save_hdf5 (hid_t loc_id, const char *name,
                                  bool save_as_floats)
 {
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   // Ensure that additional memory is deallocated
@@ -420,84 +420,84 @@ octave_sparse_matrix::save_hdf5 (hid_t l
 
   hid_t space_hid = -1, data_hid = -1;
   bool retval = true;
   SparseMatrix m = sparse_matrix_value ();
   octave_idx_type tmp;
   hsize_t hdims[2];
 
   space_hid = H5Screate_simple (0, hdims, 0);
-  if (space_hid < 0) 
+  if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 #if HAVE_HDF5_18
-  data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid, 
+  data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
-  data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid, 
+  data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid,
                         H5P_DEFAULT);
 #endif
-  if (data_hid < 0) 
+  if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
-  
+
   tmp = m.rows ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT,
                      &tmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
-    }    
+    }
 #if HAVE_HDF5_18
-  data_hid = H5Dcreate (group_hid, "nc", H5T_NATIVE_IDX, space_hid, 
+  data_hid = H5Dcreate (group_hid, "nc", H5T_NATIVE_IDX, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
-  data_hid = H5Dcreate (group_hid, "nc", H5T_NATIVE_IDX, space_hid, 
+  data_hid = H5Dcreate (group_hid, "nc", H5T_NATIVE_IDX, space_hid,
                         H5P_DEFAULT);
 #endif
-  if (data_hid < 0) 
+  if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
-  
+
   tmp = m.cols ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT,
                      &tmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
-    }    
+    }
 
 #if HAVE_HDF5_18
-  data_hid = H5Dcreate (group_hid, "nz", H5T_NATIVE_IDX, space_hid, 
+  data_hid = H5Dcreate (group_hid, "nz", H5T_NATIVE_IDX, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
-#else                   
-  data_hid = H5Dcreate (group_hid, "nz", H5T_NATIVE_IDX, space_hid, 
+#else
+  data_hid = H5Dcreate (group_hid, "nz", H5T_NATIVE_IDX, space_hid,
                         H5P_DEFAULT);
 #endif
-  if (data_hid < 0) 
+  if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
-  
+
   tmp = m.nnz ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT,
                      &tmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
@@ -506,73 +506,73 @@ octave_sparse_matrix::save_hdf5 (hid_t l
 
   H5Sclose (space_hid);
 
   hdims[0] = m.cols() + 1;
   hdims[1] = 1;
 
   space_hid = H5Screate_simple (2, hdims, 0);
 
-  if (space_hid < 0) 
+  if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 
 #if HAVE_HDF5_18
-  data_hid = H5Dcreate (group_hid, "cidx", H5T_NATIVE_IDX, space_hid, 
+  data_hid = H5Dcreate (group_hid, "cidx", H5T_NATIVE_IDX, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
-  data_hid = H5Dcreate (group_hid, "cidx", H5T_NATIVE_IDX, space_hid, 
+  data_hid = H5Dcreate (group_hid, "cidx", H5T_NATIVE_IDX, space_hid,
                         H5P_DEFAULT);
 #endif
-  if (data_hid < 0) 
+  if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
-  
+
   octave_idx_type * itmp = m.xcidx ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT,
                      itmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
-    }    
+    }
 
   H5Sclose (space_hid);
 
   hdims[0] = m.nnz ();
   hdims[1] = 1;
 
   space_hid = H5Screate_simple (2, hdims, 0);
 
-  if (space_hid < 0) 
+  if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 #if HAVE_HDF5_18
-  data_hid = H5Dcreate (group_hid, "ridx", H5T_NATIVE_IDX, space_hid, 
+  data_hid = H5Dcreate (group_hid, "ridx", H5T_NATIVE_IDX, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
-  data_hid = H5Dcreate (group_hid, "ridx", H5T_NATIVE_IDX, space_hid, 
+  data_hid = H5Dcreate (group_hid, "ridx", H5T_NATIVE_IDX, space_hid,
                         H5P_DEFAULT);
 #endif
-  if (data_hid < 0) 
+  if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
-  
+
   itmp = m.xridx ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT,
                      itmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
@@ -599,128 +599,128 @@ octave_sparse_matrix::save_hdf5 (hid_t l
 
       if (m.all_integers (max_val, min_val))
         save_type_hid
           = save_type_to_hdf5 (get_save_type (max_val, min_val));
     }
 #endif /* HAVE_HDF5_INT2FLOAT_CONVERSIONS */
 
 #if HAVE_HDF5_18
-  data_hid = H5Dcreate (group_hid, "data", save_type_hid, space_hid, 
+  data_hid = H5Dcreate (group_hid, "data", save_type_hid, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
-  data_hid = H5Dcreate (group_hid, "data", save_type_hid, space_hid, 
+  data_hid = H5Dcreate (group_hid, "data", save_type_hid, space_hid,
                         H5P_DEFAULT);
 #endif
-  if (data_hid < 0) 
+  if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
-  
+
   double * dtmp = m.xdata ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, dtmp) >= 0;
   H5Dclose (data_hid);
   H5Sclose (space_hid);
   H5Gclose (group_hid);
 
   return retval;
 }
 
 bool
 octave_sparse_matrix::load_hdf5 (hid_t loc_id, const char *name)
 {
   octave_idx_type nr, nc, nz;
   hid_t group_hid, data_hid, space_hid;
   hsize_t rank;
-  
+
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize(dv);
   if (empty)
     return (empty > 0);
-  
+
 #if HAVE_HDF5_18
   group_hid = H5Gopen (loc_id, name, H5P_DEFAULT);
 #else
   group_hid = H5Gopen (loc_id, name);
 #endif
   if (group_hid < 0) return false;
 
 #if HAVE_HDF5_18
   data_hid = H5Dopen (group_hid, "nr", H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "nr");
 #endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 0)
-    { 
+    {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
-  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, 
+  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
                H5P_DEFAULT, &nr) < 0)
-    { 
+    {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
 
 #if HAVE_HDF5_18
   data_hid = H5Dopen (group_hid, "nc", H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "nc");
 #endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 0)
-    { 
+    {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
-  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, 
+  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
                H5P_DEFAULT, &nc) < 0)
-    { 
+    {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
-  
+
 #if HAVE_HDF5_18
   data_hid = H5Dopen (group_hid, "nz", H5P_DEFAULT);
 #else
   data_hid = H5Dopen (group_hid, "nz");
 #endif
   space_hid = H5Dget_space (data_hid);
   rank = H5Sget_simple_extent_ndims (space_hid);
 
   if (rank != 0)
-    { 
+    {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
-  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, 
+  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
                H5P_DEFAULT, &nz) < 0)
-    { 
+    {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
 
   SparseMatrix m (static_cast<octave_idx_type> (nr),
@@ -753,18 +753,18 @@ octave_sparse_matrix::load_hdf5 (hid_t l
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   octave_idx_type *itmp = m.xcidx ();
-  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, 
-               H5P_DEFAULT, itmp) < 0) 
+  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
+               H5P_DEFAULT, itmp) < 0)
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
@@ -792,18 +792,18 @@ octave_sparse_matrix::load_hdf5 (hid_t l
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   itmp = m.xridx ();
-  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, 
-               H5P_DEFAULT, itmp) < 0) 
+  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
+               H5P_DEFAULT, itmp) < 0)
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
@@ -832,17 +832,17 @@ octave_sparse_matrix::load_hdf5 (hid_t l
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   double *dtmp = m.xdata ();
   bool retval = false;
-  if (H5Dread (data_hid, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, 
+  if (H5Dread (data_hid, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL,
                H5P_DEFAULT, dtmp) >= 0
       && m.indices_ok ())
     {
       retval = true;
       matrix = m;
     }
 
   H5Sclose (space_hid);
diff --git a/src/ov-re-sparse.h b/src/ov-re-sparse.h
--- a/src/ov-re-sparse.h
+++ b/src/ov-re-sparse.h
@@ -65,23 +65,23 @@ public:
   octave_sparse_matrix (const SparseMatrix& m)
     : octave_base_sparse<SparseMatrix> (m) { }
 
   octave_sparse_matrix (const SparseMatrix& m, const MatrixType& t)
     : octave_base_sparse<SparseMatrix> (m, t) { }
 
   octave_sparse_matrix (const MSparse<double>& m)
     : octave_base_sparse<SparseMatrix> (m) { }
-    
+
   octave_sparse_matrix (const MSparse<double>& m, const MatrixType& t)
     : octave_base_sparse<SparseMatrix> (m, t) { }
 
   octave_sparse_matrix (const Sparse<double>& m)
     : octave_base_sparse<SparseMatrix> (SparseMatrix (m)) { }
-    
+
   octave_sparse_matrix (const Sparse<double>& m, const MatrixType& t)
     : octave_base_sparse<SparseMatrix> (SparseMatrix (m), t) { }
 
   octave_sparse_matrix (const octave_sparse_matrix& m)
     : octave_base_sparse<SparseMatrix> (m) { }
 
   ~octave_sparse_matrix (void) { }
 
@@ -113,17 +113,17 @@ public:
 
   boolNDArray bool_array_value (bool warn = false) const;
 
   charNDArray char_array_value (bool = false) const;
 
   ComplexMatrix complex_matrix_value (bool = false) const;
 
   ComplexNDArray complex_array_value (bool = false) const;
-   
+
   NDArray array_value (bool = false) const;
 
   SparseMatrix sparse_matrix_value (bool = false) const
     { return matrix; }
 
   SparseComplexMatrix sparse_complex_matrix_value (bool = false) const
     { return SparseComplexMatrix (matrix); }
 
@@ -135,17 +135,17 @@ public:
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              oct_mach_info::float_format flt_fmt) const
     { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 #endif
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
-  bool load_binary (std::istream& is, bool swap, 
+  bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
diff --git a/src/ov-scalar.cc b/src/ov-scalar.cc
--- a/src/ov-scalar.cc
+++ b/src/ov-scalar.cc
@@ -84,17 +84,17 @@ octave_scalar::do_index_op (const octave
   // 1x1 matrix back to a scalar value.  Need a better solution
   // to this problem.
 
   octave_value tmp (new octave_matrix (matrix_value ()));
 
   return tmp.do_index_op (idx, resize_ok);
 }
 
-octave_value 
+octave_value
 octave_scalar::resize (const dim_vector& dv, bool fill) const
 {
   if (fill)
     {
       NDArray retval (dv, NDArray::resize_fill_value());
 
       if (dv.numel ())
         retval(0) = scalar;
@@ -133,53 +133,53 @@ octave_scalar::convert_to_str_internal (
         }
 
       retval = octave_value (std::string (1, static_cast<char> (ival)), type);
     }
 
   return retval;
 }
 
-bool 
+bool
 octave_scalar::save_ascii (std::ostream& os)
 {
   double d = double_value ();
 
   octave_write_double (os, d);
 
   os << "\n";
 
   return true;
 }
 
-bool 
+bool
 octave_scalar::load_ascii (std::istream& is)
 {
   scalar = octave_read_value<double> (is);
   if (!is)
     {
       error ("load: failed to load scalar constant");
       return false;
     }
 
   return true;
 }
 
-bool 
+bool
 octave_scalar::save_binary (std::ostream& os, bool& /* save_as_floats */)
 {
   char tmp = LS_DOUBLE;
   os.write (reinterpret_cast<char *> (&tmp), 1);
   double dtmp = double_value ();
   os.write (reinterpret_cast<char *> (&dtmp), 8);
 
   return true;
 }
 
-bool 
+bool
 octave_scalar::load_binary (std::istream& is, bool swap,
                             oct_mach_info::float_format fmt)
 {
   char tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), 1))
     return false;
 
   double dtmp;
@@ -200,23 +200,23 @@ octave_scalar::save_hdf5 (hid_t loc_id, 
   hsize_t dimens[3];
   hid_t space_hid = -1, data_hid = -1;
   bool retval = true;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0) return false;
 
 #if HAVE_HDF5_18
-  data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_DOUBLE, space_hid, 
+  data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_DOUBLE, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
-  data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_DOUBLE, space_hid, 
+  data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_DOUBLE, space_hid,
                         H5P_DEFAULT);
 #endif
-  if (data_hid < 0) 
+  if (data_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
 
   double tmp = double_value ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, &tmp) >= 0;
@@ -235,25 +235,25 @@ octave_scalar::load_hdf5 (hid_t loc_id, 
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
   hid_t space_id = H5Dget_space (data_hid);
 
   hsize_t rank = H5Sget_simple_extent_ndims (space_id);
 
   if (rank != 0)
-    { 
+    {
       H5Dclose (data_hid);
       return false;
     }
 
   double dtmp;
-  if (H5Dread (data_hid, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, 
+  if (H5Dread (data_hid, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL,
                H5P_DEFAULT, &dtmp) < 0)
-    { 
+    {
       H5Dclose (data_hid);
       return false;
     }
 
   scalar = dtmp;
 
   H5Dclose (data_hid);
 
diff --git a/src/ov-scalar.h b/src/ov-scalar.h
--- a/src/ov-scalar.h
+++ b/src/ov-scalar.h
@@ -219,17 +219,17 @@ public:
   void decrement (void) { --scalar; }
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
-  bool load_binary (std::istream& is, bool swap, 
+  bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
diff --git a/src/ov-str-mat.cc b/src/ov-str-mat.cc
--- a/src/ov-str-mat.cc
+++ b/src/ov-str-mat.cc
@@ -133,17 +133,17 @@ octave_char_matrix_str::do_index_op_inte
                                  type);
       }
       break;
     }
 
   return retval;
 }
 
-octave_value 
+octave_value
 octave_char_matrix_str::resize (const dim_vector& dv, bool fill) const
 {
   charNDArray retval (matrix);
   if (fill)
     retval.resize (dv, charNDArray::resize_fill_value ());
   else
     retval.resize (dv);
   return octave_value (retval, is_sq_string () ? '\'' : '"');
@@ -262,17 +262,17 @@ octave_char_matrix_str::cellstr_value (v
 
 void
 octave_char_matrix_str::print_raw (std::ostream& os, bool pr_as_read_syntax) const
 {
   octave_print_internal (os, matrix, pr_as_read_syntax,
                          current_print_indent_level (), true);
 }
 
-bool 
+bool
 octave_char_matrix_str::save_ascii (std::ostream& os)
 {
   dim_vector d = dims ();
   if (d.length () > 2)
     {
       charNDArray tmp = char_array_value ();
       os << "# ndims: " << d.length () << "\n";
       for (int i=0; i < d.length (); i++)
@@ -299,17 +299,17 @@ octave_char_matrix_str::save_ascii (std:
           os.write (tmp, len);
           os << "\n";
         }
     }
 
   return true;
 }
 
-bool 
+bool
 octave_char_matrix_str::load_ascii (std::istream& is)
 {
   bool success = true;
 
   string_vector keywords(3);
 
   keywords[0] = "ndims";
   keywords[1] = "elements";
@@ -401,38 +401,38 @@ octave_char_matrix_str::load_ascii (std:
                               chm.resize (elements, max_len, 0);
                             }
 
                           chm.insert (tmp, i, 0);
                         }
                     }
                   else
                     {
-                      error ("load: failed to extract string length for element %d", 
+                      error ("load: failed to extract string length for element %d",
                              i+1);
                       success = false;
                     }
                 }
-          
+
               if (! error_state)
                 matrix = chm;
             }
           else
             {
               error ("load: failed to extract number of string elements");
               success = false;
             }
         }
       else if (kw == "length")
         {
           int len = val;
-      
+
           if (len >= 0)
             {
-              // This is cruft for backward compatiability, 
+              // This is cruft for backward compatiability,
               // but relatively harmless.
 
               // Use this instead of a C-style character buffer so
               // that we can properly handle embedded NUL characters.
               charMatrix tmp (1, len);
               char *ptmp = tmp.fortran_vec ();
 
               if (len > 0 && ! is.read (ptmp, len))
@@ -455,17 +455,17 @@ octave_char_matrix_str::load_ascii (std:
     {
       error ("load: failed to extract number of rows and columns");
       success = false;
     }
 
   return success;
 }
 
-bool 
+bool
 octave_char_matrix_str::save_binary (std::ostream& os,
                                      bool& /* save_as_floats */)
 {
   dim_vector d = dims ();
   if (d.length() < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
@@ -477,17 +477,17 @@ octave_char_matrix_str::save_binary (std
       os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
   charNDArray m = char_array_value ();
   os.write (m.fortran_vec (), d.numel ());
   return true;
 }
 
-bool 
+bool
 octave_char_matrix_str::load_binary (std::istream& is, bool swap,
                                      oct_mach_info::float_format /* fmt */)
 {
   int32_t elements;
   if (! is.read (reinterpret_cast<char *> (&elements), 4))
     return false;
   if (swap)
     swap_bytes<4> (&elements);
@@ -502,33 +502,33 @@ octave_char_matrix_str::load_binary (std
       for (int i = 0; i < mdims; i++)
         {
           if (! is.read (reinterpret_cast<char *> (&di), 4))
             return false;
           if (swap)
             swap_bytes<4> (&di);
           dv(i) = di;
         }
-      
+
       // Convert an array with a single dimension to be a row vector.
       // Octave should never write files like this, other software
       // might.
 
       if (mdims == 1)
         {
           mdims = 2;
           dv.resize (mdims);
           dv(1) = dv(0);
           dv(0) = 1;
         }
 
       charNDArray m(dv);
       char *tmp = m.fortran_vec ();
       is.read (tmp, dv.numel ());
-      
+
       if (error_state || ! is)
         return false;
       matrix = m;
     }
   else
     {
       charMatrix chm (elements, 0);
       int max_len = 0;
@@ -571,48 +571,48 @@ octave_char_matrix_str::save_hdf5 (hid_t
   bool retval = true;
   charNDArray m = char_array_value ();
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
     hdims[i] = dv (rank-i-1);
- 
+
   space_hid = H5Screate_simple (rank, hdims, 0);
   if (space_hid < 0)
     return false;
 #if HAVE_HDF5_18
-  data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_CHAR, space_hid, 
+  data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_CHAR, space_hid,
                         H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
-  data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_CHAR, space_hid, 
+  data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_CHAR, space_hid,
                         H5P_DEFAULT);
 #endif
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
 
   OCTAVE_LOCAL_BUFFER (char, s, dv.numel ());
 
   for (int i = 0; i < dv.numel (); ++i)
     s[i] = m(i);
 
-  retval = H5Dwrite (data_hid, H5T_NATIVE_CHAR, H5S_ALL, H5S_ALL, 
+  retval = H5Dwrite (data_hid, H5T_NATIVE_CHAR, H5S_ALL, H5S_ALL,
                      H5P_DEFAULT, s) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
   return retval;
 }
 
-bool 
+bool
 octave_char_matrix_str::load_hdf5 (hid_t loc_id, const char *name)
 {
   bool retval = false;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize(dv);
@@ -655,18 +655,18 @@ octave_char_matrix_str::load_hdf5 (hid_t
         {
           dv.resize (rank);
           for (hsize_t i = 0, j = rank - 1; i < rank; i++, j--)
             dv(j) = hdims[i];
         }
 
       charNDArray m (dv);
       char *str = m.fortran_vec ();
-      if (H5Dread (data_hid, H5T_NATIVE_CHAR, H5S_ALL, H5S_ALL, 
-                   H5P_DEFAULT, str) >= 0) 
+      if (H5Dread (data_hid, H5T_NATIVE_CHAR, H5S_ALL, H5S_ALL,
+                   H5P_DEFAULT, str) >= 0)
         {
           retval = true;
           matrix = m;
         }
 
       H5Tclose (type_hid);
       H5Sclose (space_hid);
       H5Dclose (data_hid);
@@ -699,17 +699,17 @@ octave_char_matrix_str::load_hdf5 (hid_t
                   H5Tclose (st_id);
                   H5Tclose (type_hid);
                   H5Sclose (space_hid);
                   H5Dclose (data_hid);
                   return false;
                 }
 
               matrix = charMatrix (s);
-          
+
               H5Tclose (st_id);
               H5Tclose (type_hid);
               H5Sclose (space_hid);
               H5Dclose (data_hid);
               return true;
             }
         }
       else if (rank == 1)
@@ -725,17 +725,17 @@ octave_char_matrix_str::load_hdf5 (hid_t
               H5Dclose (data_hid);
               return false;
             }
           else
             {
               // hdf5 string arrays store strings of all the
               // same physical length (I think), which is
               // slightly wasteful, but oh well.
-          
+
               OCTAVE_LOCAL_BUFFER (char, s, elements * slen);
 
               // create datatype for (null-terminated) string
               // to read into:
               hid_t st_id = H5Tcopy (H5T_C_S1);
               H5Tset_size (st_id, slen);
 
               if (H5Dread (data_hid, st_id, H5S_ALL, H5S_ALL, H5P_DEFAULT, s) < 0)
diff --git a/src/ov-str-mat.h b/src/ov-str-mat.h
--- a/src/ov-str-mat.h
+++ b/src/ov-str-mat.h
@@ -141,17 +141,17 @@ public:
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
-  bool load_binary (std::istream& is, bool swap, 
+  bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -78,17 +78,17 @@ octave_struct::dotref (const octave_valu
   std::string nm = idx(0).string_value ();
 
   octave_map::const_iterator p = map.seek (nm);
 
   if (p != map.end ())
     retval = map.contents (p);
   else if (auto_add)
     retval = (numel () == 0) ? Cell (dim_vector (1, 1)) : Cell (dims ());
-  else 
+  else
     error ("structure has no member `%s'", nm.c_str ());
 
   return retval;
 }
 
 #if 0
 static void
 gripe_invalid_index1 (void)
@@ -442,21 +442,21 @@ octave_struct::subsasgn (const std::stri
                         if (! error_state)
                           {
                             count++;
                             retval = octave_value (this);
                           }
                         else
                           gripe_failed_assignment ();
                       }
-                    else 
+                    else
                       {
                         const octave_map& cmap = const_cast<const octave_map &> (map);
                         // cast map to const reference to avoid forced key insertion.
-                        if (idxf.all_scalars () 
+                        if (idxf.all_scalars ()
                             || cmap.contents (key).index (idxf, true).numel () == 1)
                           {
                             map.assign (idxf, key, Cell (t_rhs.storable_value ()));
                             if (! error_state)
                               {
                                 count++;
                                 retval = octave_value (this);
                               }
@@ -488,17 +488,17 @@ octave_struct::subsasgn (const std::stri
                         else
                           gripe_failed_assignment ();
                       }
                     else
                       error ("invalid structure assignment");
                   }
                 else
                   {
-                    if (t_rhs.is_null_value()) 
+                    if (t_rhs.is_null_value())
                       {
                         map.delete_elements (idx.front());
 
                         if (! error_state)
                           {
                             count++;
                             retval = octave_value (this);
                           }
@@ -672,33 +672,33 @@ octave_struct::print_name_tag (std::ostr
       os << name << " =";
       newline (os);
       retval = true;
     }
 
   return retval;
 }
 
-static bool 
-scalar (const dim_vector& dims) 
+static bool
+scalar (const dim_vector& dims)
 {
   return dims.length () == 2 && dims (0) == 1 && dims (1) == 1;
 }
 
 /*
 %!shared x
 %! x(1).a=1; x(2).a=2; x(1).b=3; x(2).b=3;
 %!assert(struct('a',1,'b',3),x(1))
 %!assert(isempty(x([])))
 %!assert(isempty(struct('a',{},'b',{})))
 %!assert(struct('a',{1,2},'b',{3,3}),x)
 %!assert(struct('a',{1,2},'b',3),x)
 %!assert(struct('a',{1,2},'b',{3}),x)
 %!assert(struct('b',3,'a',{1,2}),x)
-%!assert(struct('b',{3},'a',{1,2}),x) 
+%!assert(struct('b',{3},'a',{1,2}),x)
 %!test x=struct([]);
 %!assert(size(x),[0,0]);
 %!assert(isstruct(x));
 %!assert(isempty(fieldnames(x)));
 %!fail("struct('a',{1,2},'b',{1,2,3})","dimensions of parameter 2 do not match those of parameter 4")
 %!fail("struct(1,2,3,4)","struct expects alternating \"field\", VALUE pairs");
 %!fail("struct('1',2,'3')","struct expects alternating \"field\", VALUE pairs");
 */
@@ -726,25 +726,25 @@ octave_struct::save_ascii (std::ostream&
 
   for (octave_idx_type i = 0; i < nf; i++)
     {
       std::string key = keys(i);
 
       octave_value val = map.contents (key);
 
       bool b = save_ascii_data (os, val, key, false, 0);
-      
+
       if (! b)
         return os;
     }
 
   return true;
 }
 
-bool 
+bool
 octave_struct::load_ascii (std::istream& is)
 {
   octave_idx_type len = 0;
   dim_vector dv (1, 1);
   bool success = true;
 
   // KLUGE: earlier Octave versions did not save extra dimensions with struct,
   // and as a result did not preserve dimensions for empty structs.
@@ -795,17 +795,17 @@ octave_struct::load_ascii (std::istream&
                 {
                   error ("load: internal error loading struct elements");
                   return false;
                 }
 
               m.setfield (nm, tcell);
             }
 
-          if (is) 
+          if (is)
             map = m;
           else
             {
               error ("load: failed to load structure");
               success = false;
             }
         }
       else if (len == 0 )
@@ -816,17 +816,17 @@ octave_struct::load_ascii (std::istream&
   else {
     error ("load: failed to extract number of elements in structure");
     success = false;
   }
 
   return success;
 }
 
-bool 
+bool
 octave_struct::save_binary (std::ostream& os, bool& save_as_floats)
 {
   octave_map m = map_value ();
 
   octave_idx_type nf = m.nfields ();
 
   dim_vector d = dims ();
   if (d.length () < 1)
@@ -835,40 +835,40 @@ octave_struct::save_binary (std::ostream
   // Use negative value for ndims
   int32_t di = - d.length();
   os.write (reinterpret_cast<char *> (&di), 4);
   for (int i = 0; i < d.length (); i++)
     {
       di = d(i);
       os.write (reinterpret_cast<char *> (&di), 4);
     }
-  
+
   int32_t len = nf;
   os.write (reinterpret_cast<char *> (&len), 4);
 
   // Iterating over the list of keys will preserve the order of the
   // fields.
   string_vector keys = m.fieldnames ();
 
   for (octave_idx_type i = 0; i < nf; i++)
     {
       std::string key = keys(i);
 
       octave_value val = map.contents (key);
 
       bool b = save_binary_data (os, val, key, "", 0, save_as_floats);
-      
+
       if (! b)
         return os;
     }
 
   return true;
 }
 
-bool 
+bool
 octave_struct::load_binary (std::istream& is, bool swap,
                             oct_mach_info::float_format fmt)
 {
   bool success = true;
   int32_t len;
   if (! is.read (reinterpret_cast<char *> (&len), 4))
     return false;
   if (swap)
@@ -905,34 +905,34 @@ octave_struct::load_binary (std::istream
 
       for (octave_idx_type j = 0; j < len; j++)
         {
           octave_value t2;
           bool dummy;
           std::string doc;
 
           // recurse to read cell elements
-          std::string nm = read_binary_data (is, swap, fmt, std::string (), 
+          std::string nm = read_binary_data (is, swap, fmt, std::string (),
                                              dummy, t2, doc);
 
           if (!is)
             break;
 
           Cell tcell = t2.is_cell () ? t2.cell_value () : Cell (t2);
- 
+
           if (error_state)
             {
               error ("load: internal error loading struct elements");
               return false;
             }
 
           m.setfield (nm, tcell);
         }
 
-      if (is) 
+      if (is)
         map = m;
       else
         {
           error ("load: failed to load structure");
           success = false;
         }
     }
   else if (len == 0)
@@ -967,29 +967,29 @@ octave_struct::save_hdf5 (hid_t loc_id, 
   string_vector keys = m.fieldnames ();
 
   for (octave_idx_type i = 0; i < nf; i++)
     {
       std::string key = keys(i);
 
       octave_value val = map.contents (key);
 
-      bool retval2 = add_hdf5_data (data_hid, val, key, "", false, 
+      bool retval2 = add_hdf5_data (data_hid, val, key, "", false,
                                     save_as_floats);
 
       if (! retval2)
         break;
     }
 
   H5Gclose (data_hid);
 
   return true;
 }
 
-bool 
+bool
 octave_struct::load_hdf5 (hid_t loc_id, const char *name)
 {
   bool retval = false;
 
   hdf5_callback_data dsub;
 
   herr_t retval2 = 0;
   octave_map m (dim_vector (1, 1));
@@ -1008,33 +1008,33 @@ octave_struct::load_hdf5 (hid_t loc_id, 
 
   while (current_item < static_cast<int> (num_obj)
          && (retval2 = H5Giterate (loc_id, name, &current_item,
                                    hdf5_read_next_data, &dsub)) > 0)
     {
       octave_value t2 = dsub.tc;
 
       Cell tcell = t2.is_cell () ? t2.cell_value () : Cell (t2);
- 
+
       if (error_state)
         {
           error ("load: internal error loading struct elements");
           return false;
         }
 
       m.setfield (dsub.name, tcell);
 
     }
 
   if (retval2 >= 0)
     {
       map = m;
       retval = true;
     }
-  
+
   return retval;
 }
 
 #endif
 
 mxArray *
 octave_struct::as_mxArray (void) const
 {
@@ -1073,17 +1073,17 @@ octave_struct::fast_elem_extract (octave
 {
   if (n < map.numel ())
     return map.checkelem (n);
   else
     return octave_value ();
 }
 
 bool
-octave_struct::fast_elem_insert (octave_idx_type n, 
+octave_struct::fast_elem_insert (octave_idx_type n,
                                  const octave_value& x)
 {
   bool retval = false;
 
   if (n < map.numel ())
     {
       // To avoid copying the scalar struct, it just stores a pointer to
       // itself.
@@ -1406,17 +1406,17 @@ octave_scalar_struct::save_ascii (std::o
 
   for (octave_idx_type i = 0; i < nf; i++)
     {
       std::string key = keys(i);
 
       octave_value val = map.contents (key);
 
       bool b = save_ascii_data (os, val, key, false, 0);
-      
+
       if (! b)
         return os;
     }
 
   return true;
 }
 
 bool
@@ -1447,17 +1447,17 @@ octave_scalar_struct::load_ascii (std::i
                 {
                   error ("load: internal error loading struct elements");
                   return false;
                 }
 
               m.setfield (nm, t2);
             }
 
-          if (is) 
+          if (is)
             map = m;
           else
             {
               error ("load: failed to load structure");
               success = false;
             }
         }
       else if (len == 0)
@@ -1468,17 +1468,17 @@ octave_scalar_struct::load_ascii (std::i
   else {
     error ("load: failed to extract number of elements in structure");
     success = false;
   }
 
   return success;
 }
 
-bool 
+bool
 octave_scalar_struct::save_binary (std::ostream& os, bool& save_as_floats)
 {
   octave_map m = map_value ();
 
   octave_idx_type nf = m.nfields ();
 
   int32_t len = nf;
   os.write (reinterpret_cast<char *> (&len), 4);
@@ -1489,25 +1489,25 @@ octave_scalar_struct::save_binary (std::
 
   for (octave_idx_type i = 0; i < nf; i++)
     {
       std::string key = keys(i);
 
       octave_value val = map.contents (key);
 
       bool b = save_binary_data (os, val, key, "", 0, save_as_floats);
-      
+
       if (! b)
         return os;
     }
 
   return true;
 }
 
-bool 
+bool
 octave_scalar_struct::load_binary (std::istream& is, bool swap,
                                    oct_mach_info::float_format fmt)
 {
   bool success = true;
   int32_t len;
   if (! is.read (reinterpret_cast<char *> (&len), 4))
     return false;
   if (swap)
@@ -1521,32 +1521,32 @@ octave_scalar_struct::load_binary (std::
 
       for (octave_idx_type j = 0; j < len; j++)
         {
           octave_value t2;
           bool dummy;
           std::string doc;
 
           // recurse to read cell elements
-          std::string nm = read_binary_data (is, swap, fmt, std::string (), 
+          std::string nm = read_binary_data (is, swap, fmt, std::string (),
                                              dummy, t2, doc);
 
           if (!is)
             break;
 
           if (error_state)
             {
               error ("load: internal error loading struct elements");
               return false;
             }
 
           m.setfield (nm, t2);
         }
 
-      if (is) 
+      if (is)
         map = m;
       else
         {
           error ("load: failed to load structure");
           success = false;
         }
     }
   else if (len == 0)
@@ -1581,29 +1581,29 @@ octave_scalar_struct::save_hdf5 (hid_t l
   string_vector keys = m.fieldnames ();
 
   for (octave_idx_type i = 0; i < nf; i++)
     {
       std::string key = keys(i);
 
       octave_value val = map.contents (key);
 
-      bool retval2 = add_hdf5_data (data_hid, val, key, "", false, 
+      bool retval2 = add_hdf5_data (data_hid, val, key, "", false,
                                     save_as_floats);
 
       if (! retval2)
         break;
     }
 
   H5Gclose (data_hid);
 
   return true;
 }
 
-bool 
+bool
 octave_scalar_struct::load_hdf5 (hid_t loc_id, const char *name)
 {
   bool retval = false;
 
   hdf5_callback_data dsub;
 
   herr_t retval2 = 0;
   octave_scalar_map m;
@@ -1636,17 +1636,17 @@ octave_scalar_struct::load_hdf5 (hid_t l
 
     }
 
   if (retval2 >= 0)
     {
       map = m;
       retval = true;
     }
-  
+
   return retval;
 }
 
 #endif
 
 mxArray *
 octave_scalar_struct::as_mxArray (void) const
 {
@@ -1704,17 +1704,17 @@ octave_scalar_struct::fast_elem_insert_s
 %! x(1).a=1; x(2).a=2; x(1).b=3; x(2).b=3;
 %!assert(struct('a',1,'b',3),x(1))
 %!assert(isempty(x([])))
 %!assert(isempty(struct('a',{},'b',{})))
 %!assert(struct('a',{1,2},'b',{3,3}),x)
 %!assert(struct('a',{1,2},'b',3),x)
 %!assert(struct('a',{1,2},'b',{3}),x)
 %!assert(struct('b',3,'a',{1,2}),x)
-%!assert(struct('b',{3},'a',{1,2}),x) 
+%!assert(struct('b',{3},'a',{1,2}),x)
 %!test x=struct([]);
 %!assert(size(x),[0,0]);
 %!assert(isstruct(x));
 %!assert(isempty(fieldnames(x)));
 %!fail("struct('a',{1,2},'b',{1,2,3})","dimensions of parameter 2 do not match those of parameter 4")
 %!fail("struct(1,2,3,4)","struct expects alternating \"field\", VALUE pairs");
 %!fail("struct('1',2,'3')","struct expects alternating \"field\", VALUE pairs");
 */
@@ -1768,37 +1768,37 @@ If the argument is an object, return the
           else
             error ("struct: expecting cell array of field names as second argument");
         }
       else
         retval = octave_map (args(0).dims ());
 
       return retval;
     }
-    
+
   // Check for "field", VALUE pairs.
 
-  for (int i = 0; i < nargin; i += 2) 
+  for (int i = 0; i < nargin; i += 2)
     {
       if (! args(i).is_string () || i + 1 >= nargin)
         {
           error ("struct expects alternating \"field\", VALUE pairs");
           return retval;
         }
     }
 
   // Check that the dimensions of the values correspond.
 
   dim_vector dims (1, 1);
 
   int first_dimensioned_value = 0;
 
-  for (int i = 1; i < nargin; i += 2) 
+  for (int i = 1; i < nargin; i += 2)
     {
-      if (args(i).is_cell ()) 
+      if (args(i).is_cell ())
         {
           dim_vector argdims (args(i).dims ());
 
           if (! scalar (argdims))
             {
               if (! first_dimensioned_value)
                 {
                   dims = argdims;
@@ -1813,50 +1813,50 @@ If the argument is an object, return the
             }
         }
     }
 
   // Create the return value.
 
   octave_map map (dims);
 
-  for (int i = 0; i < nargin; i+= 2) 
+  for (int i = 0; i < nargin; i+= 2)
     {
       // Get key.
 
       std::string key (args(i).string_value ());
 
       if (error_state)
         return retval;
 
       if (! valid_identifier (key))
         {
           error ("struct: invalid structure field name `%s'", key.c_str ());
           return retval;
         }
 
       // Value may be v, { v }, or { v1, v2, ... }
       // In the first two cases, we need to create a cell array of
-      // the appropriate dimensions filled with v.  In the last case, 
+      // the appropriate dimensions filled with v.  In the last case,
       // the cell array has already been determined to be of the
       // correct dimensions.
 
-      if (args(i+1).is_cell ()) 
+      if (args(i+1).is_cell ())
         {
           const Cell c (args(i+1).cell_value ());
 
           if (error_state)
             return retval;
 
-          if (scalar (c.dims ())) 
+          if (scalar (c.dims ()))
             map.setfield (key, Cell (dims, c(0)));
-          else 
+          else
             map.setfield (key, c);
         }
-      else 
+      else
         map.setfield (key, Cell (dims, args(i+1)));
 
       if (error_state)
         return retval;
     }
 
   return octave_value (map);
 }
@@ -2032,29 +2032,29 @@ A(1)\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 3)
     {
-      if (! args(0).is_cell ()) 
+      if (! args(0).is_cell ())
         error ("cell2struct: first argument must be a cell");
       else if (! (args(1).is_cellstr () || args(1).is_char_matrix ()))
         error ("cell2struct: second argument must be a cell array of strings or a character matrix");
       else if (! args(2).is_real_scalar ())
         error ("cell2struct: third argument must be a real scalar");
       else
         {
           const Cell vals = args(0).cell_value ();
           const Array<std::string> fields = args(1).cellstr_value ();
           int dim = args(2).int_value () - 1;
           octave_idx_type ext = 0;
-          
+
           if (dim < 0)
             error ("cell2struct: dim must be a valid dimension");
           else
             {
               ext = vals.ndims () > dim ? vals.dims ()(dim) : 1;
               if (ext != fields.numel ())
                 error ("cell2struct: number of fields doesn't match dimension");
             }
diff --git a/src/ov-struct.h b/src/ov-struct.h
--- a/src/ov-struct.h
+++ b/src/ov-struct.h
@@ -133,17 +133,17 @@ public:
   bool print_name_tag (std::ostream& os, const std::string& name) const;
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
-  bool load_binary (std::istream& is, bool swap, 
+  bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
@@ -254,17 +254,17 @@ public:
   bool print_name_tag (std::ostream& os, const std::string& name) const;
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
-  bool load_binary (std::istream& is, bool swap, 
+  bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
diff --git a/src/ov-type-conv.h b/src/ov-type-conv.h
--- a/src/ov-type-conv.h
+++ b/src/ov-type-conv.h
@@ -18,32 +18,32 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_ov_type_conv_h)
 #define octave_ov_type_conv_h 1
 
-static 
+static
 octave_value
 octave_type_conv_body (const octave_value &arg, const std::string& name, int t_result)
 {
   int t_arg = arg.type_id ();
   octave_value retval;
 
   if (t_arg == t_result || arg.class_name () == name)
     {
       retval = arg;
     }
   else
     {
       octave_base_value::type_conv_fcn cf1
         = octave_value_typeinfo::lookup_type_conv_op (t_arg, t_result);
-       
+
       if (cf1)
         {
           octave_base_value *tmp (cf1 (*(arg.internal_rep ())));
 
           if (tmp)
             {
               retval = octave_value (tmp);
 
@@ -66,17 +66,17 @@ octave_type_conv_body (const octave_valu
                   retval = octave_type_conv_body (xarg, name, t_result);
                 }
             }
         }
     }
 
   return retval;
 }
-                         
+
 
 #define OCTAVE_TYPE_CONV_BODY3(NAME, MATRIX_RESULT_T, SCALAR_RESULT_T) \
  \
   octave_value retval; \
  \
   int nargin = args.length (); \
  \
   if (nargin == 1) \
diff --git a/src/ov-typeinfo.cc b/src/ov-typeinfo.cc
--- a/src/ov-typeinfo.cc
+++ b/src/ov-typeinfo.cc
@@ -143,17 +143,17 @@ octave_value_typeinfo::register_assignan
                                               int t_lhs, octave_value_typeinfo::assignany_op_fcn f)
 {
   return (instance_ok ())
     ? instance->do_register_assignany_op (op, t_lhs, f) : -1;
 }
 
 bool
 octave_value_typeinfo::register_pref_assign_conv (int t_lhs, int t_rhs,
-                                                  int t_result) 
+                                                  int t_result)
 {
   return (instance_ok ())
     ? instance->do_register_pref_assign_conv (t_lhs, t_rhs, t_result) : false;
 }
 
 bool
 octave_value_typeinfo::register_type_conv_op (int t, int t_result,
                                               octave_base_value::type_conv_fcn f)
@@ -408,17 +408,17 @@ octave_value_typeinfo::do_register_assig
 
   assignany_ops.checkelem (static_cast<int> (op), t_lhs) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
 bool
 octave_value_typeinfo::do_register_pref_assign_conv (int t_lhs, int t_rhs,
-                                                     int t_result) 
+                                                     int t_result)
 {
   if (lookup_pref_assign_conv (t_lhs, t_rhs) >= 0)
     {
       std::string t_lhs_name = types(t_lhs);
       std::string t_rhs_name = types(t_rhs);
 
       warning ("overriding assignment conversion for types `%s' and `%s'",
                t_lhs_name.c_str (), t_rhs_name.c_str ());
diff --git a/src/ov-usr-fcn.cc b/src/ov-usr-fcn.cc
--- a/src/ov-usr-fcn.cc
+++ b/src/ov-usr-fcn.cc
@@ -78,17 +78,17 @@ octave_user_script::octave_user_script (
 {
   if (cmd_list)
     cmd_list->mark_as_script_body ();
 }
 
 octave_user_script::octave_user_script (const std::string& fnm,
                                         const std::string& nm,
                                         const std::string& ds)
-  : octave_user_code (nm, ds), cmd_list (0), file_name (fnm), 
+  : octave_user_code (nm, ds), cmd_list (0), file_name (fnm),
     t_parsed (static_cast<time_t> (0)),
     t_checked (static_cast<time_t> (0)),
     call_depth (-1)
 { }
 
 octave_user_script::~octave_user_script (void)
 {
   delete cmd_list;
@@ -457,17 +457,17 @@ octave_user_function::do_multi_index_op 
   if (tree_break_command::breaking)
     tree_break_command::breaking--;
 
   if (error_state)
     {
       octave_call_stack::backtrace_error_message ();
       return retval;
     }
-  
+
   // Copy return values out.
 
   if (ret_list && ! special_expr)
     {
       ret_list->initialize_undefined_elements (my_name, nargout, Matrix ());
 
       Cell varargout;
 
@@ -564,17 +564,17 @@ octave_user_function::bind_automatic_var
   symbol_table::mark_hidden (".nargin.");
   symbol_table::mark_hidden (".nargout.");
 
   symbol_table::mark_automatic (".nargin.");
   symbol_table::mark_automatic (".nargout.");
 
   if (takes_varargs ())
     symbol_table::varref ("varargin") = va_args.cell_value ();
-  
+
   if (lvalue_list)
     {
       octave_idx_type nbh = 0;
       for (std::list<octave_lvalue>::const_iterator p = lvalue_list->begin ();
            p != lvalue_list->end (); p++)
         nbh += p->is_black_hole ();
 
       if (nbh > 0)
diff --git a/src/ov-usr-fcn.h b/src/ov-usr-fcn.h
--- a/src/ov-usr-fcn.h
+++ b/src/ov-usr-fcn.h
@@ -38,17 +38,17 @@ along with Octave; see the file COPYING.
 class string_vector;
 
 class octave_value;
 class tree_parameter_list;
 class tree_statement_list;
 class tree_va_return_list;
 class tree_walker;
 
-class 
+class
 octave_user_code : public octave_function
 {
 public:
   octave_user_code (void)
     : octave_function () { }
 
   ~octave_user_code (void) { }
 
@@ -285,17 +285,17 @@ public:
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx,
                              int nargout, const std::list<octave_lvalue>* lvalue_list);
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args);
 
   octave_value_list
-  do_multi_index_op (int nargout, const octave_value_list& args, 
+  do_multi_index_op (int nargout, const octave_value_list& args,
                      const std::list<octave_lvalue>* lvalue_list);
 
   tree_parameter_list *parameter_list (void) { return param_list; }
 
   tree_parameter_list *return_list (void) { return ret_list; }
 
   tree_statement_list *body (void) { return cmd_list; }
 
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -1172,17 +1172,17 @@ octave_value::maybe_mutate (void)
   octave_base_value *tmp = rep->try_narrowing_conversion ();
 
   if (tmp && tmp != rep)
     {
       if (--rep->count == 0)
         delete rep;
 
       rep = tmp;
-    }    
+    }
 }
 
 octave_value
 octave_value::single_subsref (const std::string& type,
                               const octave_value_list& idx)
 {
   std::list<octave_value_list> i;
 
@@ -1210,49 +1210,49 @@ octave_value::subsref (const std::string
     return rep->subsref (type, idx, nargout, lvalue_list);
   else
     return subsref (type, idx, nargout);
 }
 
 octave_value
 octave_value::next_subsref (const std::string& type,
                             const std::list<octave_value_list>& idx,
-                            size_t skip) 
+                            size_t skip)
 {
   if (! error_state && idx.size () > skip)
     {
       std::list<octave_value_list> new_idx (idx);
       for (size_t i = 0; i < skip; i++)
         new_idx.erase (new_idx.begin ());
       return subsref (type.substr (skip), new_idx);
     }
   else
     return *this;
 }
 
 octave_value_list
 octave_value::next_subsref (int nargout, const std::string& type,
                             const std::list<octave_value_list>& idx,
-                            size_t skip) 
+                            size_t skip)
 {
   if (! error_state && idx.size () > skip)
     {
       std::list<octave_value_list> new_idx (idx);
       for (size_t i = 0; i < skip; i++)
         new_idx.erase (new_idx.begin ());
       return subsref (type.substr (skip), new_idx, nargout);
     }
   else
     return *this;
 }
 
 octave_value
 octave_value::next_subsref (bool auto_add, const std::string& type,
                             const std::list<octave_value_list>& idx,
-                            size_t skip) 
+                            size_t skip)
 {
   if (! error_state && idx.size () > skip)
     {
       std::list<octave_value_list> new_idx (idx);
       for (size_t i = 0; i < skip; i++)
         new_idx.erase (new_idx.begin ());
       return subsref (type.substr (skip), new_idx, auto_add);
     }
@@ -1347,17 +1347,17 @@ octave_value&
 octave_value::assign (assign_op op, const octave_value& rhs)
 {
   if (op == op_asn_eq)
     // Regularize a null matrix if stored into a variable.
     operator = (rhs.storable_value ());
   else if (is_defined ())
     {
       octave_value_typeinfo::assign_op_fcn f = 0;
-      
+
       // Only attempt to operate in-place if this variable is unshared.
       if (rep->count == 1)
         {
           int tthis = this->type_id ();
           int trhs = rhs.type_id ();
 
           f = octave_value_typeinfo::lookup_assign_op (op, tthis, trhs);
         }
@@ -1528,41 +1528,41 @@ make_vector_dims (const dim_vector& dv, 
 
   return retval;
 }
 
 ColumnVector
 octave_value::column_vector_value (bool force_string_conv,
                                    bool frc_vec_conv) const
 {
-  return ColumnVector (vector_value (force_string_conv, 
+  return ColumnVector (vector_value (force_string_conv,
                                      frc_vec_conv));
 }
 
 ComplexColumnVector
 octave_value::complex_column_vector_value (bool force_string_conv,
                                            bool frc_vec_conv) const
 {
-  return ComplexColumnVector (complex_vector_value (force_string_conv, 
+  return ComplexColumnVector (complex_vector_value (force_string_conv,
                                                     frc_vec_conv));
 }
 
 RowVector
 octave_value::row_vector_value (bool force_string_conv,
                                 bool frc_vec_conv) const
 {
-  return RowVector (vector_value (force_string_conv, 
+  return RowVector (vector_value (force_string_conv,
                                   frc_vec_conv));
 }
 
 ComplexRowVector
 octave_value::complex_row_vector_value (bool force_string_conv,
                                         bool frc_vec_conv) const
 {
-  return ComplexRowVector (complex_vector_value (force_string_conv, 
+  return ComplexRowVector (complex_vector_value (force_string_conv,
                                                  frc_vec_conv));
 }
 
 Array<double>
 octave_value::vector_value (bool force_string_conv,
                             bool force_vector_conversion) const
 {
   Array<double> retval = array_value (force_string_conv);
@@ -1610,17 +1610,17 @@ octave_value::int_vector_value (bool for
         retval = convert_to_int_array (uint64_array_value ());
       else if (is_uint16_type ())
         retval = convert_to_int_array (uint16_array_value ());
       else if (is_uint8_type ())
         retval = convert_to_int_array (uint8_array_value ());
       else
         retval = array_value (force_string_conv);
     }
-  else 
+  else
     {
       const NDArray a = array_value (force_string_conv);
       if (! error_state)
         {
           if (require_int)
             {
               retval.resize (a.dims ());
               for (octave_idx_type i = 0; i < a.numel (); i++)
@@ -1686,17 +1686,17 @@ octave_value::octave_idx_type_vector_val
         retval = convert_to_octave_idx_type_array (uint64_array_value ());
       else if (is_uint16_type ())
         retval = convert_to_octave_idx_type_array (uint16_array_value ());
       else if (is_uint8_type ())
         retval = convert_to_octave_idx_type_array (uint8_array_value ());
       else
         retval = array_value (force_string_conv);
     }
-  else 
+  else
     {
       const NDArray a = array_value (force_string_conv);
       if (! error_state)
         {
           if (require_int)
             {
               retval.resize (a.dims ());
               for (octave_idx_type i = 0; i < a.numel (); i++)
@@ -1739,41 +1739,41 @@ octave_value::complex_vector_value (bool
                                              force_vector_conversion,
                                              type_name (), "complex vector"));
 }
 
 FloatColumnVector
 octave_value::float_column_vector_value (bool force_string_conv,
                                          bool frc_vec_conv) const
 {
-  return FloatColumnVector (float_vector_value (force_string_conv, 
+  return FloatColumnVector (float_vector_value (force_string_conv,
                                                 frc_vec_conv));
 }
 
 FloatComplexColumnVector
 octave_value::float_complex_column_vector_value (bool force_string_conv,
                                                  bool frc_vec_conv) const
 {
-  return FloatComplexColumnVector (float_complex_vector_value (force_string_conv, 
+  return FloatComplexColumnVector (float_complex_vector_value (force_string_conv,
                                                                frc_vec_conv));
 }
 
 FloatRowVector
 octave_value::float_row_vector_value (bool force_string_conv,
                                       bool frc_vec_conv) const
 {
-  return FloatRowVector (float_vector_value (force_string_conv, 
+  return FloatRowVector (float_vector_value (force_string_conv,
                                              frc_vec_conv));
 }
 
 FloatComplexRowVector
 octave_value::float_complex_row_vector_value (bool force_string_conv,
                                               bool frc_vec_conv) const
 {
-  return FloatComplexRowVector (float_complex_vector_value (force_string_conv, 
+  return FloatComplexRowVector (float_complex_vector_value (force_string_conv,
                                                            frc_vec_conv));
 }
 
 Array<float>
 octave_value::float_vector_value (bool force_string_conv,
                                   bool force_vector_conversion) const
 {
   Array<float> retval = float_array_value (force_string_conv);
@@ -1795,30 +1795,30 @@ octave_value::float_complex_vector_value
   if (error_state)
     return retval;
   else
     return retval.reshape (make_vector_dims (retval.dims (),
                                              force_vector_conversion,
                                              type_name (), "complex vector"));
 }
 
-octave_value 
+octave_value
 octave_value::storable_value (void) const
 {
   octave_value retval = *this;
   if (is_null_value ())
     retval = octave_value (rep->empty_clone ());
   else
     retval.maybe_economize ();
 
   return retval;
 }
 
-void 
-octave_value::make_storable_value (void) 
+void
+octave_value::make_storable_value (void)
 {
   if (is_null_value ())
     {
       octave_base_value *rc = rep->empty_clone ();
       if (--rep->count == 0)
         delete rep;
       rep = rc;
     }
@@ -1868,17 +1868,17 @@ do_binary_op (octave_value::binary_op op
           try
             {
               retval = f (v1, v2);
             }
           catch (octave_execution_exception)
             {
               gripe_library_execution_error ();
             }
-        }           
+        }
       else
         gripe_binary_op (octave_value::binary_op_as_string (op),
                          v1.class_name (), v2.class_name ());
     }
   else
     {
       // FIXME -- we need to handle overloading operators for built-in
       // classes (double, char, int8, etc.)
@@ -2115,17 +2115,17 @@ do_binary_op (octave_value::compound_bin
           try
             {
               retval = f (v1, v2);
             }
           catch (octave_execution_exception)
             {
               gripe_library_execution_error ();
             }
-        }           
+        }
       else
         retval = decompose_binary_op (op, v1, v2);
     }
   else
     {
       octave_value_typeinfo::binary_op_fcn f
         = octave_value_typeinfo::lookup_binary_op (op, t1, t2);
 
@@ -2156,17 +2156,17 @@ gripe_cat_op (const std::string& tn1, co
 
 static void
 gripe_cat_op_conv (void)
 {
   error ("type conversion failed for concatenation operator");
 }
 
 octave_value
-do_cat_op (const octave_value& v1, const octave_value& v2, 
+do_cat_op (const octave_value& v1, const octave_value& v2,
            const Array<octave_idx_type>& ra_idx)
 {
   octave_value retval;
 
   // Can't rapid return for concatenation with an empty object here as
   // something like cat(1,[],single([]) must return the correct type.
 
   int t1 = v1.type_id ();
@@ -2359,17 +2359,17 @@ octave_value::do_non_const_unary_op (una
   if (op == op_incr || op == op_decr)
     {
       // We want the gripe just here, because in the other branch this should
       // not happen, and if it did anyway (internal error), the message would
       // be confusing.
       if (is_undefined ())
         {
           std::string op_str = unary_op_as_string (op);
-          error ("in x%s or %sx, x must be defined first", 
+          error ("in x%s or %sx, x must be defined first",
                  op_str.c_str (), op_str.c_str ());
           return *this;
         }
 
       // Genuine.
       int t = type_id ();
 
       octave_value_typeinfo::non_const_unary_op_fcn f
@@ -2510,17 +2510,17 @@ octave_value::unary_op_to_assign_op (una
         std::string on = unary_op_as_string (op);
         error ("operator %s: no assign operator found", on.c_str ());
       }
     }
 
   return binop;
 }
 
-octave_value::binary_op 
+octave_value::binary_op
 octave_value::op_eq_to_binary_op (assign_op op)
 {
   binary_op binop = unknown_binary_op;
 
   switch (op)
     {
     case op_add_eq:
       binop = op_add;
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -105,19 +105,19 @@ public:
     op_struct_ref,
     num_binary_ops,
     unknown_binary_op
   };
 
   enum compound_binary_op
   {
     // ** compound operations **
-    op_trans_mul,      
+    op_trans_mul,
     op_mul_trans,
-    op_herm_mul,      
+    op_herm_mul,
     op_mul_herm,
     op_trans_ldiv,
     op_herm_ldiv,
     op_el_not_and,
     op_el_not_or,
     op_el_and_not,
     op_el_or_not,
     num_compound_binary_ops,
@@ -235,20 +235,20 @@ public:
   octave_value (const charMatrix& chm, bool is_string,
                 char type = '\'') GCC_ATTR_DEPRECATED;
   octave_value (const charNDArray& chnda, bool is_string,
                 char type = '\'') GCC_ATTR_DEPRECATED;
   octave_value (const Array<char>& chnda, bool is_string,
                 char type = '\'') GCC_ATTR_DEPRECATED;
   octave_value (const SparseMatrix& m, const MatrixType& t = MatrixType ());
   octave_value (const Sparse<double>& m, const MatrixType& t = MatrixType ());
-  octave_value (const SparseComplexMatrix& m, 
+  octave_value (const SparseComplexMatrix& m,
                 const MatrixType& t = MatrixType ());
   octave_value (const Sparse<Complex>& m, const MatrixType& t = MatrixType ());
-  octave_value (const SparseBoolMatrix& bm, 
+  octave_value (const SparseBoolMatrix& bm,
                 const MatrixType& t = MatrixType ());
   octave_value (const Sparse<bool>& m, const MatrixType& t = MatrixType ());
   octave_value (const octave_int8& i);
   octave_value (const octave_int16& i);
   octave_value (const octave_int32& i);
   octave_value (const octave_int64& i);
   octave_value (const octave_uint8& i);
   octave_value (const octave_uint16& i);
@@ -265,17 +265,17 @@ public:
   octave_value (const uint8NDArray& inda);
   octave_value (const Array<octave_uint8>& inda);
   octave_value (const uint16NDArray& inda);
   octave_value (const Array<octave_uint16>& inda);
   octave_value (const uint32NDArray& inda);
   octave_value (const Array<octave_uint32>& inda);
   octave_value (const uint64NDArray& inda);
   octave_value (const Array<octave_uint64>& inda);
-  octave_value (const Array<octave_idx_type>& inda, 
+  octave_value (const Array<octave_idx_type>& inda,
                 bool zero_based = false, bool cache_index = false);
   octave_value (const Array<std::string>& cellstr);
   octave_value (const idx_vector& idx, bool lazy = true);
   octave_value (double base, double limit, double inc);
   octave_value (const Range& r);
   octave_value (const octave_map& m);
   octave_value (const octave_scalar_map& m);
   octave_value (const Octave_map& m);
@@ -631,17 +631,17 @@ public:
     { return rep->is_sparse_type (); }
 
   // Does this constant correspond to a truth value?
 
   bool is_true (void) const
     { return rep->is_true (); }
 
   // Do two constants match (in a switch statement)?
-  
+
   bool is_equal (const octave_value&) const;
 
   // Are the dimensions of this constant zero by zero?
 
   bool is_zero_by_zero (void) const
     { return (rows () == 0 && columns () == 0); }
 
   bool is_constant (void) const
@@ -774,29 +774,29 @@ public:
   SparseComplexMatrix sparse_complex_matrix_value (bool frc_str_conv = false) const
     { return rep->sparse_complex_matrix_value (frc_str_conv); }
 
   SparseBoolMatrix sparse_bool_matrix_value (bool warn = false) const
     { return rep->sparse_bool_matrix_value (warn); }
 
   DiagMatrix diag_matrix_value (bool force = false) const
     { return rep->diag_matrix_value (force); }
-  
+
   FloatDiagMatrix float_diag_matrix_value (bool force = false) const
     { return rep->float_diag_matrix_value (force); }
-  
+
   ComplexDiagMatrix complex_diag_matrix_value (bool force = false) const
     { return rep->complex_diag_matrix_value (force); }
-  
+
   FloatComplexDiagMatrix float_complex_diag_matrix_value (bool force = false) const
     { return rep->float_complex_diag_matrix_value (force); }
 
   PermMatrix perm_matrix_value (void) const
     { return rep->perm_matrix_value (); }
-  
+
   octave_int8 int8_scalar_value (void) const
     { return rep->int8_scalar_value (); }
 
   octave_int16 int16_scalar_value (void) const
     { return rep->int16_scalar_value (); }
 
   octave_int32 int32_scalar_value (void) const
     { return rep->int32_scalar_value (); }
@@ -941,17 +941,17 @@ public:
 
   // Possibly economize a lazy-indexed value.
 
   void maybe_economize (void)
     { rep->maybe_economize (); }
 
   // The following two hook conversions are called on any octave_value prior to
   // storing it to a "permanent" location, like a named variable, a cell or a
-  // struct component, or a return value of a function. 
+  // struct component, or a return value of a function.
 
   octave_value storable_value (void) const;
 
   // Ditto, but in place, i.e. equivalent to *this = this->storable_value (),
   // but possibly more efficient.
 
   void make_storable_value (void);
 
@@ -1056,20 +1056,20 @@ public:
   octave_idx_type *mex_get_jc (void) const { return rep->mex_get_jc (); }
 
   mxArray *as_mxArray (void) const { return rep->as_mxArray (); }
 
   octave_value diag (octave_idx_type k = 0) const
     { return rep->diag (k); }
 
   octave_value sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const
-    { return rep->sort (dim, mode); } 
+    { return rep->sort (dim, mode); }
   octave_value sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
                  sortmode mode = ASCENDING) const
-    { return rep->sort (sidx, dim, mode); } 
+    { return rep->sort (sidx, dim, mode); }
 
   sortmode is_sorted (sortmode mode = UNSORTED) const
     { return rep->is_sorted (mode); }
 
   Array<octave_idx_type> sort_rows_idx (sortmode mode = ASCENDING) const
     { return rep->sort_rows_idx (mode); }
 
   sortmode is_sorted_rows (sortmode mode = UNSORTED) const
diff --git a/src/pager.cc b/src/pager.cc
--- a/src/pager.cc
+++ b/src/pager.cc
@@ -402,17 +402,17 @@ close_diary_file (void)
 
 static void
 open_diary_file (void)
 {
   close_diary_file ();
 
   // If there is pending output in the pager buf, it should not go
   // into the diary file.
- 
+
   octave_stdout.set_diary_skip ();
 
   external_diary_file.open (diary_file.c_str (), std::ios::app);
 
   if (! external_diary_file)
     error ("diary: can't open diary file `%s'", diary_file.c_str ());
 }
 
@@ -459,17 +459,17 @@ With no arguments, @code{diary} toggles 
     case 2:
       {
         std::string arg = argv[1];
 
         if (arg == "on")
           {
             write_to_diary_file = true;
             open_diary_file ();
-          }     
+          }
         else if (arg == "off")
           {
             close_diary_file ();
             write_to_diary_file = false;
           }
         else
           {
             diary_file = arg;
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -220,33 +220,33 @@ calc_scale_exp (const int& x)
    * According to the ISO specification for C++ the modulo operator is
    * compiler dependent if any of the arguments are negative.  Since this
    * function will need to work on negative arguments, and we want to avoid
    * portability issues, we re-implement the modulo function to the desired
    * behavior (truncation).  There may be a gnulib replacement.
    *
    * ISO/IEC 14882:2003 : Programming languages -- C++. 5.6.4: ISO, IEC. 2003 .
    * "the binary % operator yields the remainder from the division of the first
-   * expression by the second. .... If both operands are nonnegative then the 
-   * remainder is nonnegative; if not, the sign of the remainder is 
+   * expression by the second. .... If both operands are nonnegative then the
+   * remainder is nonnegative; if not, the sign of the remainder is
    * implementation-defined".  */
 }
 
 static int
 engineering_exponent (const double& x)
 {
   int ex = 0;
   if (x != 0)
     {
       double absval = (x < 0.0 ? -x : x);
       int logabsval = static_cast<int> (gnulib::floor (log10 (absval)));
       /* Avoid using modulo function with negative arguments for portability.
        * See extended comment at calc_scale_exp */
       if (logabsval < 0.0)
-        ex = logabsval - 2 + ((-logabsval + 2) % 3);  
+        ex = logabsval - 2 + ((-logabsval + 2) % 3);
       else
         ex = logabsval - (logabsval % 3);
     }
   return ex;
 }
 
 static int
 num_digits (const double& x)
@@ -264,17 +264,17 @@ public:
   const float_format& f;
 
   double val;
 
   int exponent (void) const
   {
     return engineering_exponent (val);
   }
-    
+
   double mantissa (void) const
   {
     return val / std::pow (10.0, exponent ());
   }
 
   pr_engineering_float (const float_format& f_arg, double val_arg)
     : f (f_arg), val (val_arg) { }
 };
@@ -283,32 +283,32 @@ std::ostream&
 operator << (std::ostream& os, const pr_engineering_float& pef)
 {
   if (pef.f.fw >= 0)
     os << std::setw (pef.f.fw - pef.f.ex);
 
   if (pef.f.prec >= 0)
     os << std::setprecision (pef.f.prec);
 
-  std::ios::fmtflags oflags = 
-    os.flags (static_cast<std::ios::fmtflags> 
+  std::ios::fmtflags oflags =
+    os.flags (static_cast<std::ios::fmtflags>
               (pef.f.fmt | pef.f.up | pef.f.sp));
 
   os << pef.mantissa ();
 
   int ex = pef.exponent ();
   if (ex < 0)
     {
       os << std::setw (0) << "e-";
       ex = -ex;
     }
   else
     os << std::setw (0) << "e+";
 
-  os << std::setw (pef.f.ex - 2) << std::setfill('0') << ex 
+  os << std::setw (pef.f.ex - 2) << std::setfill('0') << ex
      << std::setfill(' ');
 
   os.flags (oflags);
 
   return os;
 }
 
 class
@@ -328,18 +328,18 @@ std::ostream&
 operator << (std::ostream& os, const pr_formatted_float& pff)
 {
   if (pff.f.fw >= 0)
     os << std::setw (pff.f.fw);
 
   if (pff.f.prec >= 0)
     os << std::setprecision (pff.f.prec);
 
-  std::ios::fmtflags oflags = 
-    os.flags (static_cast<std::ios::fmtflags> 
+  std::ios::fmtflags oflags =
+    os.flags (static_cast<std::ios::fmtflags>
               (pff.f.fmt | pff.f.up | pff.f.sp));
 
   os << pff.val;
 
   os.flags (oflags);
 
   return os;
 }
@@ -369,17 +369,17 @@ rational_approx (double val, int len)
       double lastd = 0.;
       double n = xround (val);
       double d = 1.;
       double frac = val - n;
       int m = 0;
 
       std::ostringstream buf2;
       buf2.flags (std::ios::fixed);
-      buf2 << std::setprecision (0) << static_cast<int>(n); 
+      buf2 << std::setprecision (0) << static_cast<int>(n);
       s = buf2.str();
 
       while (1)
         {
           double flip = 1. / frac;
           double step = xround (flip);
           double nextn = n;
           double nextd = d;
@@ -395,42 +395,42 @@ rational_approx (double val, int len)
           frac = flip - step;
           n = n * step + lastn;
           d = d * step + lastd;
           lastn = nextn;
           lastd = nextd;
 
           std::ostringstream buf;
           buf.flags (std::ios::fixed);
-          buf << std::setprecision (0) << static_cast<int>(n) 
+          buf << std::setprecision (0) << static_cast<int>(n)
               << "/" << static_cast<int>(d);
           m++;
 
           if (n < 0 && d < 0)
             {
               // Double negative, string can be two characters longer..
-              if (buf.str().length() > static_cast<unsigned int>(len + 2) && 
-                  m > 1) 
+              if (buf.str().length() > static_cast<unsigned int>(len + 2) &&
+                  m > 1)
                 break;
             }
-          else if (buf.str().length() > static_cast<unsigned int>(len) && 
-                   m > 1) 
+          else if (buf.str().length() > static_cast<unsigned int>(len) &&
+                   m > 1)
             break;
 
           s = buf.str();
         }
 
       if (lastd < 0.)
         {
           // Move sign to the top
           lastd = - lastd;
           lastn = - lastn;
           std::ostringstream buf;
           buf.flags (std::ios::fixed);
-          buf << std::setprecision (0) << static_cast<int>(lastn) 
+          buf << std::setprecision (0) << static_cast<int>(lastn)
                << "/" << static_cast<int>(lastd);
           s = buf.str();
         }
     }
 
   return s;
 }
 
@@ -451,18 +451,18 @@ std::ostream&
 operator << (std::ostream& os, const pr_rational_float& prf)
 {
   int fw = (rat_string_len > 0 ? rat_string_len : prf.f.fw);
   std::string s = rational_approx (prf.val, fw);
 
   if (fw >= 0)
     os << std::setw (fw);
 
-  std::ios::fmtflags oflags = 
-    os.flags (static_cast<std::ios::fmtflags> 
+  std::ios::fmtflags oflags =
+    os.flags (static_cast<std::ios::fmtflags>
               (prf.f.fmt | prf.f.up | prf.f.sp));
 
   if (fw > 0 && s.length() > static_cast<unsigned int>(fw))
     os << "*";
   else
     os << s;
 
   os.flags (oflags);
@@ -804,17 +804,17 @@ set_format (const Matrix& m, int& fw, do
   Matrix m_abs = m.abs ();
   double max_abs = pr_max_internal (m_abs);
   double min_abs = pr_min_internal (m_abs);
 
   int x_max = max_abs == 0.0 ? 0 : num_digits (max_abs);
 
   int x_min = min_abs == 0.0 ? 0 : num_digits (min_abs);
 
-  scale = (x_max == 0 || int_or_inf_or_nan) ? 1.0 
+  scale = (x_max == 0 || int_or_inf_or_nan) ? 1.0
     : std::pow (10.0, calc_scale_exp (x_max - 1));
 
   set_real_matrix_format (x_max, x_min, inf_or_nan, int_or_inf_or_nan, fw);
 }
 
 static inline void
 set_format (const Matrix& m)
 {
@@ -1222,17 +1222,17 @@ set_format (const ComplexMatrix& cm, int
 
   int i_x_max = i_max_abs == 0.0 ? 0 : num_digits (i_max_abs);
 
   int i_x_min = i_min_abs == 0.0 ? 0 : num_digits (i_min_abs);
 
   int x_max = r_x_max > i_x_max ? r_x_max : i_x_max;
   int x_min = r_x_min > i_x_min ? r_x_min : i_x_min;
 
-  scale = (x_max == 0 || int_or_inf_or_nan) ? 1.0 
+  scale = (x_max == 0 || int_or_inf_or_nan) ? 1.0
     : std::pow (10.0, calc_scale_exp (x_max - 1));
 
   set_complex_matrix_format (x_max, x_min, r_x_max, r_x_min, inf_or_nan,
                              int_or_inf_or_nan, r_fw, i_fw);
 }
 
 static inline void
 set_format (const ComplexMatrix& cm)
@@ -1378,17 +1378,17 @@ set_format (const Range& r, int& fw, dou
 
   double max_abs = r_max < 0.0 ? -r_max : r_max;
   double min_abs = r_min < 0.0 ? -r_min : r_min;
 
   int x_max = max_abs == 0.0 ? 0 : num_digits (max_abs);
 
   int x_min = min_abs == 0.0 ? 0 : num_digits (min_abs);
 
-  scale = (x_max == 0 || all_ints) ? 1.0 
+  scale = (x_max == 0 || all_ints) ? 1.0
     : std::pow (10.0, calc_scale_exp (x_max - 1));
 
   set_range_format (x_max, x_min, all_ints, fw);
 }
 
 static inline void
 set_format (const Range& r)
 {
@@ -1483,17 +1483,17 @@ pr_any_float (const float_format *fmt, s
             }
           else
             {
               for (int i = sizeof (double) - 1; i >= 0; i--)
                 os << std::setw (2) << static_cast<int> (tmp.i[i]);
             }
 
           os.fill (ofill);
-          os.setf (oflags);       
+          os.setf (oflags);
         }
       else if (bit_format)
         {
           equiv tmp;
           tmp.d = d;
 
           // FIXME -- is it correct to swap bytes for VAX
           // formats and not for Cray?
@@ -1957,17 +1957,17 @@ octave_print_internal (std::ostream& os,
       else
         {
           os << "Diagonal Matrix\n\n";
           pr_scale_header (os, scale);
 
           // kluge. Get the true width of a number.
           int zero_fw;
 
-            { 
+            {
               std::ostringstream tmp_oss;
               pr_float (tmp_oss, 0.0, fw, scale);
               zero_fw = tmp_oss.str ().length ();
             }
 
           for (octave_idx_type col = 0; col < nc; col += inc)
             {
               octave_idx_type lim = col + inc < nc ? col + inc : nc;
@@ -2155,17 +2155,17 @@ octave_print_internal (std::ostream& os,
         }
     }
   else
     {
       int r_fw, i_fw;
       double scale = 1.0;
       set_format (cm, r_fw, i_fw, scale);
       int column_width = i_fw + r_fw;
-      column_width += (rat_format || bank_format || hex_format 
+      column_width += (rat_format || bank_format || hex_format
                        || bit_format) ? 2 : 7;
       octave_idx_type total_width = nc * column_width;
       octave_idx_type max_width = command_editor::terminal_cols ();
 
       if (pr_as_read_syntax)
         max_width -= 4;
       else
         max_width -= extra_indent;
@@ -2253,17 +2253,17 @@ octave_print_internal (std::ostream& os,
                     {
                       octave_quit ();
 
                       os << "  ";
 
                       pr_complex (os, cm(i,j), r_fw, i_fw, scale);
                     }
 
-                  if (i < nr - 1) 
+                  if (i < nr - 1)
                     os << "\n";
                 }
             }
         }
     }
 }
 
 void
@@ -2291,17 +2291,17 @@ octave_print_internal (std::ostream& os,
         }
     }
   else
     {
       int r_fw, i_fw;
       double scale = 1.0;
       set_format (ComplexMatrix (cm.diag ()), r_fw, i_fw, scale);
       int column_width = i_fw + r_fw;
-      column_width += (rat_format || bank_format || hex_format 
+      column_width += (rat_format || bank_format || hex_format
                        || bit_format) ? 2 : 7;
       octave_idx_type total_width = nc * column_width;
       octave_idx_type max_width = command_editor::terminal_cols ();
 
       if (pr_as_read_syntax)
         max_width -= 4;
       else
         max_width -= extra_indent;
@@ -2368,17 +2368,17 @@ octave_print_internal (std::ostream& os,
       else
         {
           os << "Diagonal Matrix\n\n";
           pr_scale_header (os, scale);
 
           // kluge. Get the true width of a number.
           int zero_fw;
 
-            { 
+            {
               std::ostringstream tmp_oss;
               pr_complex (tmp_oss, Complex (0.0), r_fw, i_fw, scale);
               zero_fw = tmp_oss.str ().length ();
             }
 
           for (octave_idx_type col = 0; col < nc; col += inc)
             {
               octave_idx_type lim = col + inc < nc ? col + inc : nc;
@@ -2397,17 +2397,17 @@ octave_print_internal (std::ostream& os,
                       os << "  ";
 
                       if (i == j)
                         pr_complex (os, cm(i,j), r_fw, i_fw, scale);
                       else
                         os << std::setw (zero_fw) << '0';
                     }
 
-                  if (i < nr - 1) 
+                  if (i < nr - 1)
                     os << "\n";
                 }
             }
         }
     }
 }
 
 void
@@ -2557,54 +2557,54 @@ octave_print_internal (std::ostream& os,
     default:
       PRINT_ND_ARRAY (os, nda, ComplexNDArray, Complex, ComplexMatrix);
       break;
     }
 }
 
 void
 octave_print_internal (std::ostream& os, bool d, bool pr_as_read_syntax)
-{ 
-  octave_print_internal (os, double (d), pr_as_read_syntax); 
+{
+  octave_print_internal (os, double (d), pr_as_read_syntax);
 }
 
 // FIXME -- write single precision versions of the printing functions.
 
 void
 octave_print_internal (std::ostream& os, float d, bool pr_as_read_syntax)
-{ 
-  octave_print_internal (os, double (d), pr_as_read_syntax); 
+{
+  octave_print_internal (os, double (d), pr_as_read_syntax);
 }
 
 void
 octave_print_internal (std::ostream& os, const FloatMatrix& m,
                        bool pr_as_read_syntax, int extra_indent)
-{ 
-  octave_print_internal (os, Matrix (m), pr_as_read_syntax, extra_indent); 
+{
+  octave_print_internal (os, Matrix (m), pr_as_read_syntax, extra_indent);
 }
 
 void
 octave_print_internal (std::ostream& os, const FloatDiagMatrix& m,
                        bool pr_as_read_syntax, int extra_indent)
-{ 
-  octave_print_internal (os, DiagMatrix (m), pr_as_read_syntax, extra_indent); 
+{
+  octave_print_internal (os, DiagMatrix (m), pr_as_read_syntax, extra_indent);
 }
 
 void
 octave_print_internal (std::ostream& os, const FloatNDArray& nda,
                        bool pr_as_read_syntax, int extra_indent)
 {
-  octave_print_internal (os, NDArray (nda), pr_as_read_syntax, extra_indent); 
+  octave_print_internal (os, NDArray (nda), pr_as_read_syntax, extra_indent);
 }
 
 void
 octave_print_internal (std::ostream& os, const FloatComplex& c,
                        bool pr_as_read_syntax)
 {
-  octave_print_internal (os, Complex (c), pr_as_read_syntax); 
+  octave_print_internal (os, Complex (c), pr_as_read_syntax);
 }
 
 void
 octave_print_internal (std::ostream& os, const FloatComplexMatrix& cm,
                        bool pr_as_read_syntax, int extra_indent)
 {
   octave_print_internal (os, ComplexMatrix (cm), pr_as_read_syntax, extra_indent);
 }
@@ -2972,17 +2972,17 @@ pr_int (std::ostream& os, const T& d, in
         }
       else
         {
           for (int i = sz - 1; i >= 0; i--)
             os << std::setw (2) << static_cast<int> (tmpi[i]);
         }
 
       os.fill (ofill);
-      os.setf (oflags);   
+      os.setf (oflags);
     }
   else if (bit_format)
     {
       if (oct_mach_info::words_big_endian ())
         {
           for (size_t i = 0; i < sz; i++)
             PRINT_CHAR_BITS (os, tmpi[i]);
         }
@@ -3208,17 +3208,17 @@ octave_print_internal_template (std::ost
         fw = nda(0).nbits ();
       else
         {
           bool isneg = false;
           int digits = 0;
 
           for (octave_idx_type i = 0; i < dims.numel (); i++)
             {
-              int new_digits = static_cast<int> 
+              int new_digits = static_cast<int>
                 (gnulib::floor (log10 (double (abs (nda(i).value ()))) + 1.0));
 
               if (new_digits > digits)
                 digits = new_digits;
 
               if (! isneg)
               isneg = (abs (nda(i).value ()) != nda(i).value ());
             }
@@ -3299,17 +3299,17 @@ octave_print_internal_template (std::ost
                   octave_idx_type lim = col + inc < n_cols ? col + inc : n_cols;
 
                   pr_col_num_header (os, total_width, max_width, lim, col,
                                      extra_indent);
 
                   for (octave_idx_type ii = 0; ii < n_rows; ii++)
                     {
                       os << std::setw (extra_indent) << "";
-                      
+
                       for (octave_idx_type jj = col; jj < lim; jj++)
                         {
                           octave_quit ();
                           os << "  ";
                           pr_int (os, page(ii,jj), fw);
                         }
                       if ((ii < n_rows - 1) || (i < m -1))
                         os << "\n";
@@ -3513,27 +3513,27 @@ Note that the output from @code{fdisp} a
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
-/* 
+/*
 %!test
 %! format short
 %! fd = tmpfile ();
 %! for r = [0, Inf -Inf, NaN]
 %!   for i = [0, Inf -Inf, NaN]
 %!     fdisp (fd, complex (r, i));
 %!   endfor
 %! endfor
 %! fclose (fd);
-*/                                 
+*/
 
 static void
 init_format_state (void)
 {
   free_format = false;
   plus_format = false;
   rat_format = false;
   bank_format = false;
diff --git a/src/procstream.h b/src/procstream.h
--- a/src/procstream.h
+++ b/src/procstream.h
@@ -99,17 +99,17 @@ private:
 };
 
 class
 OCTINTERP_API
 oprocstream : public std::ostream, public procstreambase
 // oprocstream : public procstreambase, public std::ostream
 {
 public:
- 
+
   oprocstream (void) : std::ostream (0), procstreambase () { }
 
   oprocstream (const std::string& name, int mode = std::ios::out)
     : std::ostream (0), procstreambase(name, mode) { }
 
   oprocstream (const char *name, int mode = std::ios::out)
     : std::ostream (0), procstreambase(name, mode) { }
 
diff --git a/src/pt-arg-list.cc b/src/pt-arg-list.cc
--- a/src/pt-arg-list.cc
+++ b/src/pt-arg-list.cc
@@ -163,17 +163,17 @@ tree_argument_list::convert_to_const_vec
 {
   // END doesn't make sense for functions.  Maybe we need a different
   // way of asking an octave_value object this question?
 
   bool stash_object = (list_includes_magic_end
                        && object
                        && ! (object->is_function ()
                              || object->is_function_handle ()));
-  
+
   unwind_protect frame;
 
   if (stash_object)
     {
       frame.protect_var (indexed_object);
 
       indexed_object = object;
     }
diff --git a/src/pt-assign.h b/src/pt-assign.h
--- a/src/pt-assign.h
+++ b/src/pt-assign.h
@@ -141,17 +141,17 @@ public:
   tree_argument_list *left_hand_side (void) { return lhs; }
 
   tree_expression *right_hand_side (void) { return rhs; }
 
   tree_expression *dup (symbol_table::scope_id scope,
                         symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
-  
+
   octave_value::assign_op op_type (void) const { return octave_value::op_asn_eq; }
 
 private:
 
   // The left hand side of the assignment.
   tree_argument_list *lhs;
 
   // The right hand side of the assignment.
diff --git a/src/pt-binop.cc b/src/pt-binop.cc
--- a/src/pt-binop.cc
+++ b/src/pt-binop.cc
@@ -33,17 +33,17 @@ along with Octave; see the file COPYING.
 #include "pt-walk.h"
 #include "variables.h"
 
 // TRUE means we mark | and & expressions for braindead short-circuit
 // behavior.
 static bool Vdo_braindead_shortcircuit_evaluation;
 
 // Binary expressions.
- 
+
 octave_value_list
 tree_binary_expression::rvalue (int nargout)
 {
   octave_value_list retval;
 
   if (nargout > 1)
     error ("binary operator `%s': invalid number of output arguments",
            oper () . c_str ());
@@ -153,17 +153,17 @@ tree_binary_expression::dup (symbol_tabl
 
 void
 tree_binary_expression::accept (tree_walker& tw)
 {
   tw.visit_binary_expression (*this);
 }
 
 // Boolean expressions.
- 
+
 octave_value_list
 tree_boolean_expression::rvalue (int nargout)
 {
   octave_value_list retval;
 
   if (nargout > 1)
     error ("binary operator `%s': invalid number of output arguments",
            oper () . c_str ());
diff --git a/src/pt-bp.cc b/src/pt-bp.cc
--- a/src/pt-bp.cc
+++ b/src/pt-bp.cc
@@ -232,17 +232,17 @@ tree_breakpoint::visit_if_command_list (
   for (tree_if_command_list::iterator p = lst.begin (); p != lst.end (); p++)
     {
       tree_if_clause *t = *p;
 
       if (t->line () >= line)
         take_action (*t);
 
       if (! found)
-        {      
+        {
           tree_statement_list *stmt_lst = t->commands ();
 
           if (stmt_lst)
             stmt_lst->accept (*this);
         }
 
       if (found)
         break;
diff --git a/src/pt-bp.h b/src/pt-bp.h
--- a/src/pt-bp.h
+++ b/src/pt-bp.h
@@ -57,17 +57,17 @@ tree_breakpoint : public tree_walker
   void visit_continue_command (tree_continue_command&);
 
   void visit_global_command (tree_global_command&);
 
   void visit_static_command (tree_static_command&);
 
   void visit_decl_elt (tree_decl_elt&);
 
-  void visit_decl_init_list (tree_decl_init_list&);  
+  void visit_decl_init_list (tree_decl_init_list&);
 
   void visit_while_command (tree_while_command&);
 
   void visit_do_until_command (tree_do_until_command&);
 
   void visit_simple_for_command (tree_simple_for_command&);
 
   void visit_complex_for_command (tree_complex_for_command&);
@@ -128,17 +128,17 @@ tree_breakpoint : public tree_walker
 
   void visit_switch_command (tree_switch_command&);
 
   void visit_try_catch_command (tree_try_catch_command&);
 
   void visit_unwind_protect_command (tree_unwind_protect_command&);
 
   octave_value_list get_list (void) { return bp_list; }
-  
+
   int get_line (void) { return line; }
 
  private:
 
   void do_decl_command (tree_decl_command&);
 
   void take_action (tree& tr);
 
diff --git a/src/pt-cbinop.cc b/src/pt-cbinop.cc
--- a/src/pt-cbinop.cc
+++ b/src/pt-cbinop.cc
@@ -30,44 +30,44 @@ along with Octave; see the file COPYING.
 #include "pt-cbinop.h"
 #include "pt-bp.h"
 #include "pt-unop.h"
 #include "pt-walk.h"
 
 // If a tree expression is a transpose or hermitian transpose, return
 // the argument and corresponding operator.
 
-static octave_value::unary_op 
+static octave_value::unary_op
 strip_trans_herm (tree_expression *&exp)
 {
   if (exp->is_unary_expression ())
     {
-      tree_unary_expression *uexp = 
+      tree_unary_expression *uexp =
         dynamic_cast<tree_unary_expression *> (exp);
 
       octave_value::unary_op op = uexp->op_type ();
 
       if (op == octave_value::op_transpose
           || op == octave_value::op_hermitian)
         exp = uexp->operand ();
       else
         op = octave_value::unknown_unary_op;
 
       return op;
     }
   else
     return octave_value::unknown_unary_op;
 }
 
-static octave_value::unary_op 
+static octave_value::unary_op
 strip_not (tree_expression *&exp)
 {
   if (exp->is_unary_expression ())
     {
-      tree_unary_expression *uexp = 
+      tree_unary_expression *uexp =
         dynamic_cast<tree_unary_expression *> (exp);
 
       octave_value::unary_op op = uexp->op_type ();
 
       if (op == octave_value::op_not)
         exp = uexp->operand ();
       else
         op = octave_value::unknown_unary_op;
diff --git a/src/pt-cell.cc b/src/pt-cell.cc
--- a/src/pt-cell.cc
+++ b/src/pt-cell.cc
@@ -51,17 +51,17 @@ tree_cell::rvalue1 (int)
 
   int i = 0;
 
   for (iterator p = begin (); p != end (); p++)
     {
       tree_argument_list *elt = *p;
 
       octave_value_list row = elt->convert_to_const_vector ();
-      
+
       if (nr == 1)
         // Optimize the single row case.
         val = row.cell_value ();
       else if (nc < 0)
         {
           nc = row.length ();
 
           val = Cell (nr, nc);
diff --git a/src/pt-colon.cc b/src/pt-colon.cc
--- a/src/pt-colon.cc
+++ b/src/pt-colon.cc
@@ -107,30 +107,30 @@ tree_colon_expression::make_range (const
 
 octave_value
 tree_colon_expression::make_range (const octave_value& ov_base,
                                    const octave_value& ov_limit,
                                    const octave_value& ov_increment) const
 {
   octave_value retval;
 
-  if (ov_base.is_object () || ov_limit.is_object () || 
+  if (ov_base.is_object () || ov_limit.is_object () ||
       ov_increment.is_object ())
     {
       octave_value_list tmp1;
       tmp1(2) = ov_limit;
       tmp1(1) = ov_increment;
       tmp1(0) = ov_base;
 
       octave_value fcn = symbol_table::find_function ("colon", tmp1);
 
       if (fcn.is_defined ())
         {
           octave_value_list tmp2 = fcn.do_multi_index_op (1, tmp1);
-                      
+
           if (! error_state)
             retval = tmp2 (0);
         }
       else
         ::error ("can not find overloaded colon function");
     }
   else
     {
@@ -206,17 +206,17 @@ tree_colon_expression::rvalue1 (int)
 
           if (!error_state)
             {
               octave_value fcn = symbol_table::find_function ("colon", tmp1);
 
               if (fcn.is_defined ())
                 {
                   octave_value_list tmp2 = fcn.do_multi_index_op (1, tmp1);
-                      
+
                   if (! error_state)
                     retval = tmp2 (0);
                 }
               else
                 ::error ("can not find overloaded colon function");
             }
         }
       else
diff --git a/src/pt-const.cc b/src/pt-const.cc
--- a/src/pt-const.cc
+++ b/src/pt-const.cc
@@ -43,17 +43,17 @@ tree_constant::print (std::ostream& os, 
   if (pr_orig_text && ! orig_text.empty ())
     os << orig_text;
   else
     val.print (os, pr_as_read_syntax);
 }
 
 void
 tree_constant::print_raw (std::ostream& os, bool pr_as_read_syntax,
-                          bool pr_orig_text) 
+                          bool pr_orig_text)
 {
   if (pr_orig_text && ! orig_text.empty ())
     os << orig_text;
   else
     val.print_raw (os, pr_as_read_syntax);
 }
 
 octave_value_list
diff --git a/src/pt-decl.cc b/src/pt-decl.cc
--- a/src/pt-decl.cc
+++ b/src/pt-decl.cc
@@ -90,17 +90,17 @@ tree_decl_init_list::dup (symbol_table::
   tree_decl_init_list *new_dil = new tree_decl_init_list ();
 
   for (const_iterator p = begin (); p != end (); p++)
     {
       const tree_decl_elt *elt = *p;
 
       new_dil->append (elt ? elt->dup (scope, context) : 0);
     }
-  
+
   return new_dil;
 }
 
 void
 tree_decl_init_list::accept (tree_walker& tw)
 {
   tw.visit_decl_init_list (*this);
 }
diff --git a/src/pt-eval.cc b/src/pt-eval.cc
--- a/src/pt-eval.cc
+++ b/src/pt-eval.cc
@@ -863,17 +863,17 @@ tree_evaluator::visit_switch_command (tr
     ::error ("missing value in switch command near line %d, column %d",
              cmd.line (), cmd.column ());
 }
 
 void
 tree_evaluator::visit_try_catch_command (tree_try_catch_command& cmd)
 {
   unwind_protect frame;
-  
+
   frame.protect_var (buffer_error_messages);
   frame.protect_var (Vdebug_on_error);
   frame.protect_var (Vdebug_on_warning);
 
   buffer_error_messages++;
   Vdebug_on_error = false;
   Vdebug_on_warning = false;
 
@@ -920,17 +920,17 @@ tree_evaluator::do_unwind_protect_cleanu
   // in the first part of the unwind_protect are not completely
   // ignored.
 
   frame.protect_var (error_state);
   error_state = 0;
 
   // We want to preserve the last statement indicator for possible
   // backtracking.
-  frame.add_fcn (octave_call_stack::set_statement, 
+  frame.add_fcn (octave_call_stack::set_statement,
                  octave_call_stack::current_statement ());
 
   // Similarly, if we have seen a return or break statement, allow all
   // the cleanup code to run before returning or handling the break.
   // We don't have to worry about continue statements because they can
   // only occur in loops.
 
   frame.protect_var (tree_return_command::returning);
diff --git a/src/pt-fcn-handle.cc b/src/pt-fcn-handle.cc
--- a/src/pt-fcn-handle.cc
+++ b/src/pt-fcn-handle.cc
@@ -39,17 +39,17 @@ void
 tree_fcn_handle::print (std::ostream& os, bool pr_as_read_syntax,
                         bool pr_orig_text)
 {
   print_raw (os, pr_as_read_syntax, pr_orig_text);
 }
 
 void
 tree_fcn_handle::print_raw (std::ostream& os, bool pr_as_read_syntax,
-                            bool pr_orig_text) 
+                            bool pr_orig_text)
 {
   os << ((pr_as_read_syntax || pr_orig_text) ? "@" : "") << nm;
 }
 
 octave_value
 tree_fcn_handle::rvalue1 (int)
 {
   return make_fcn_handle (nm);
@@ -117,17 +117,17 @@ tree_anon_fcn_handle::rvalue1 (int)
 
       uf->stash_parent_fcn_name (curr_fcn->name ());
       uf->stash_dir_name (curr_fcn->dir_name ());
 
       symbol_table::scope_id parent_scope = curr_fcn->parent_fcn_scope ();
 
       if (parent_scope < 0)
         parent_scope = curr_fcn->scope ();
-        
+
       uf->stash_parent_fcn_scope (parent_scope);
     }
 
   uf->mark_as_inline_function ();
 
   octave_value ov_fcn (uf);
 
   octave_value fh (octave_fcn_binder::maybe_binder (ov_fcn));
diff --git a/src/pt-id.h b/src/pt-id.h
--- a/src/pt-id.h
+++ b/src/pt-id.h
@@ -67,17 +67,17 @@ public:
 
   virtual bool is_variable (void) { return xsym().is_variable (); }
 
   virtual bool is_black_hole (void) { return false; }
 
   // Try to find a definition for an identifier.  Here's how:
   //
   //   * If the identifier is already defined and is a function defined
-  //     in an function file that has been modified since the last time 
+  //     in an function file that has been modified since the last time
   //     we parsed it, parse it again.
   //
   //   * If the identifier is not defined, try to find a builtin
   //     variable or an already compiled function with the same name.
   //
   //   * If the identifier is still undefined, try looking for an
   //     function file to parse.
   //
diff --git a/src/pt-idx.cc b/src/pt-idx.cc
--- a/src/pt-idx.cc
+++ b/src/pt-idx.cc
@@ -122,17 +122,17 @@ tree_index_expression::has_magic_end (vo
        p != args.end ();
        p++)
     {
       tree_argument_list *elt = *p;
 
       if (elt && elt->has_magic_end ())
         return true;
     }
-  
+
   return false;
 }
 
 // This is useful for printing the name of the variable in an indexed
 // assignment.
 
 std::string
 tree_index_expression::name (void) const
@@ -356,17 +356,17 @@ tree_index_expression::rvalue (int nargo
                   // value to the built-in __end__ function.
 
                   const octave_value_list tmp_list
                     = tmp.subsref (type.substr (tmpi, i - tmpi), idx, nargout);
 
                   tmp = tmp_list.length () ? tmp_list(0) : octave_value ();
                   tmpi = i;
                   idx.clear ();
-                  
+
                   if (tmp.is_cs_list ())
                     gripe_indexed_cs_list ();
 
                   if (error_state)
                     break;
                 }
             }
 
@@ -493,17 +493,17 @@ tree_index_expression::lvalue (void)
 
                 if (tmp.is_undefined ())
                   {
                     if (tidx.has_magic_colon ())
                       gripe_invalid_inquiry_subscript ();
                     else
                       tmp = Cell ();
                   }
-                else if (tmp.is_zero_by_zero () 
+                else if (tmp.is_zero_by_zero ()
                          && (tmp.is_matrix_type () || tmp.is_string ()))
                   {
                     tmp = Cell ();
                   }
 
                 retval.numel (tmp.numel (tidx));
 
                 if (error_state)
@@ -516,17 +516,17 @@ tree_index_expression::lvalue (void)
               break;
 
             case '.':
               {
                 octave_value tidx = get_struct_index (p_arg_nm, p_dyn_field);
                 if (error_state)
                   break;
 
-                bool autoconv = (tmp.is_zero_by_zero () 
+                bool autoconv = (tmp.is_zero_by_zero ()
                                  && (tmp.is_matrix_type () || tmp.is_string ()
                                      || tmp.is_cell ()));
 
                 if (i > 0 && type [i-1] == '(')
                   {
                     octave_value_list pidx = idx.back ();
 
                     // Use octave_map, not octave_scalar_map so that the
@@ -633,17 +633,17 @@ tree_index_expression::dup (symbol_table
        p++)
     {
       const tree_argument_list *elt = *p;
 
       new_args.push_back (elt ? elt->dup (scope, context) : 0);
     }
 
   new_idx_expr->args = new_args;
-  
+
   new_idx_expr->type = type;
 
   new_idx_expr->arg_nm = arg_nm;
 
   std::list<tree_expression *> new_dyn_field;
 
   for (std::list<tree_expression *>::const_iterator p = dyn_field.begin ();
        p != dyn_field.end ();
@@ -652,17 +652,17 @@ tree_index_expression::dup (symbol_table
       const tree_expression *elt = *p;
 
       new_dyn_field.push_back (elt ? elt->dup (scope, context) : 0);
     }
 
   new_idx_expr->dyn_field = new_dyn_field;
 
   new_idx_expr->copy_base (*this);
-  
+
   return new_idx_expr;
 }
 
 void
 tree_index_expression::accept (tree_walker& tw)
 {
   tw.visit_index_expression (*this);
 }
diff --git a/src/pt-idx.h b/src/pt-idx.h
--- a/src/pt-idx.h
+++ b/src/pt-idx.h
@@ -114,17 +114,17 @@ private:
 
   tree_index_expression (int l, int c);
 
   octave_map make_arg_struct (void) const;
 
   std::string
   get_struct_index
     (std::list<string_vector>::const_iterator p_arg_nm,
-     std::list<tree_expression *>::const_iterator p_dyn_field) const; 
+     std::list<tree_expression *>::const_iterator p_dyn_field) const;
 
   // No copying!
 
   tree_index_expression (const tree_index_expression&);
 
   tree_index_expression& operator = (const tree_index_expression&);
 };
 
diff --git a/src/pt-mat.cc b/src/pt-mat.cc
--- a/src/pt-mat.cc
+++ b/src/pt-mat.cc
@@ -251,30 +251,30 @@ get_concat_class (const std::string& c1,
       else if (c1_is_logical && c2_is_logical)
         retval = c1;
       else if (c1 == "struct" && c2 == c1)
         retval = c1;
       else if (c1 == "cell" && c2 == c1)
         retval = c1;
     }
 
-  return retval;    
+  return retval;
 }
 
 static void
-eval_error (const char *msg, int l, int c, 
+eval_error (const char *msg, int l, int c,
             const dim_vector& x, const dim_vector& y)
 {
   if (l == -1 && c == -1)
     {
       ::error ("%s (%s vs %s)", msg, x.str ().c_str (), y.str ().c_str ());
     }
   else
     {
-      ::error ("%s (%s vs %s) near line %d, column %d", msg, 
+      ::error ("%s (%s vs %s) near line %d, column %d", msg,
                x.str ().c_str (), y.str ().c_str (), l, c);
     }
 }
 
 bool
 tm_row_const::tm_row_const_rep::do_init_element (tree_expression *elt,
                                                  const octave_value& val,
                                                  bool& first_elem)
@@ -540,28 +540,28 @@ tm_const::init (const tree_matrix& tm)
           all_mt = false;
 
           if (first_elem)
             {
               first_elem = false;
 
               dv = this_elt_dv;
             }
-          else if (all_str && dv.length () == 2 
+          else if (all_str && dv.length () == 2
                    && this_elt_dv.length () == 2)
             {
               // FIXME: this is Octave's specialty. Character matrices allow
               // rows of unequal length.
               if (this_elt_nc > cols ())
                 dv(1) = this_elt_nc;
               dv(0) += this_elt_nr;
             }
           else if (! dv.hvcat (this_elt_dv, 0))
             {
-              eval_error ("vertical dimensions mismatch", -1, -1, 
+              eval_error ("vertical dimensions mismatch", -1, -1,
                           dv, this_elt_dv);
               return;
             }
         }
     }
 
   ok = ! error_state;
 }
@@ -625,17 +625,17 @@ void
 maybe_warn_string_concat (bool all_dq_strings_p, bool all_sq_strings_p)
 {
   if (! (all_dq_strings_p || all_sq_strings_p))
     warning_with_id ("Octave:string-concat",
                      "concatenation of different character string types may have unintended consequences");
 }
 
 template<class TYPE, class T>
-static void 
+static void
 single_type_concat (Array<T>& result,
                     tm_const& tmp)
 {
   octave_idx_type r = 0, c = 0;
 
   for (tm_const::iterator p = tmp.begin (); p != tmp.end (); p++)
     {
       tm_row_const row = *p;
@@ -669,17 +669,17 @@ single_type_concat (Array<T>& result,
         }
 
       r += row.rows ();
       c = 0;
     }
 }
 
 template<class TYPE, class T>
-static void 
+static void
 single_type_concat (Array<T>& result,
                     const dim_vector& dv,
                     tm_const& tmp)
 {
   if (dv.any_zero ())
     {
       result = Array<T> (dv);
       return;
@@ -723,17 +723,17 @@ single_type_concat (Array<T>& result,
   else
     {
       result = Array<T> (dv);
       single_type_concat<TYPE> (result, tmp);
     }
 }
 
 template<class TYPE, class T>
-static void 
+static void
 single_type_concat (Sparse<T>& result,
                     const dim_vector& dv,
                     tm_const& tmp)
 {
   if (dv.any_zero ())
     {
       result = Sparse<T> (dv);
       return;
@@ -764,17 +764,17 @@ single_type_concat (Sparse<T>& result,
       sparse_row_list[j] = stmp;
       j++;
     }
 
   result = Sparse<T>::cat (-1, nrows, sparse_row_list);
 }
 
 template<class MAP>
-static void 
+static void
 single_type_concat (octave_map& result,
                     const dim_vector& dv,
                     tm_const& tmp)
 {
   if (dv.any_zero ())
     {
       result = octave_map (dv);
       return;
@@ -802,29 +802,29 @@ single_type_concat (octave_map& result,
       map_row_list[j] = mtmp;
       j++;
     }
 
   result = octave_map::cat (-1, nrows, map_row_list);
 }
 
 template<class TYPE>
-static octave_value 
+static octave_value
 do_single_type_concat (const dim_vector& dv,
                        tm_const& tmp)
 {
   TYPE result;
 
   single_type_concat<TYPE> (result, dv, tmp);
 
   return result;
 }
 
 template<>
-octave_value 
+octave_value
 do_single_type_concat<octave_map> (const dim_vector& dv,
                                    tm_const& tmp)
 {
   octave_map result;
 
   if (tmp.all_1x1_p ())
     single_type_concat<octave_scalar_map> (result, dv, tmp);
   else
@@ -880,28 +880,28 @@ tree_matrix::rvalue1 (int)
 
               if (row.length () == 1)
                 tmp3 (j++) = *(row.begin ());
               else
                 {
                   octave_value_list tmp1 (row.length (), octave_value ());
 
                   int i = 0;
-                  for (tm_row_const::iterator q = row.begin (); 
+                  for (tm_row_const::iterator q = row.begin ();
                        q != row.end (); q++)
                     tmp1 (i++) = *q;
 
                   octave_value_list tmp2;
-                  octave_value fcn = 
+                  octave_value fcn =
                     symbol_table::find_function ("horzcat", tmp1);
 
                   if (fcn.is_defined ())
                     {
                       tmp2 = fcn.do_multi_index_op (1, tmp1);
-                      
+
                       if (error_state)
                         goto done;
 
                       tmp3 (j++) = tmp2 (0);
                     }
                   else
                     {
                       ::error ("cat not find overloaded horzcat function");
@@ -915,28 +915,28 @@ tree_matrix::rvalue1 (int)
           else
             {
               octave_value_list tmp2;
               octave_value fcn = symbol_table::find_function ("vertcat", tmp3);
 
               if (fcn.is_defined ())
                 {
                   tmp2 = fcn.do_multi_index_op (1, tmp3);
-                      
+
                   if (! error_state)
                     retval = tmp2 (0);
                 }
               else
                 ::error ("cat not find overloaded vertcat function");
             }
         }
       else if (result_type == "double")
         {
           if (any_sparse_p)
-            {       
+            {
               if (all_real_p)
                 retval = do_single_type_concat<SparseMatrix> (dv, tmp);
               else
                 retval = do_single_type_concat<SparseComplexMatrix> (dv, tmp);
             }
           else
             {
               if (all_real_p)
@@ -1014,29 +1014,29 @@ tree_matrix::rvalue1 (int)
 
           // Find the first non-empty object
 
           if (any_sparse_p)
             {
               // Start with sparse matrix to avoid issues memory issues
               // with things like [ones(1,4),sprandn(1e8,4,1e-4)]
               if (all_real_p)
-                ctmp = octave_sparse_matrix ().resize (dv); 
+                ctmp = octave_sparse_matrix ().resize (dv);
               else
-                ctmp = octave_sparse_complex_matrix ().resize (dv); 
+                ctmp = octave_sparse_complex_matrix ().resize (dv);
             }
           else
             {
               for (tm_const::iterator p = tmp.begin (); p != tmp.end (); p++)
                 {
                   octave_quit ();
 
                   tm_row_const row = *p;
 
-                  for (tm_row_const::iterator q = row.begin (); 
+                  for (tm_row_const::iterator q = row.begin ();
                        q != row.end (); q++)
                     {
                       octave_quit ();
 
                       ctmp = *q;
 
                       if (! ctmp.all_zero_dims ())
                         goto found_non_empty;
diff --git a/src/pt-mat.h b/src/pt-mat.h
--- a/src/pt-mat.h
+++ b/src/pt-mat.h
@@ -75,21 +75,21 @@ private:
   tree_matrix (const tree_matrix&);
 
   tree_matrix& operator = (const tree_matrix&);
 };
 
 // The character to fill with when creating string arrays.
 extern char Vstring_fill_char;
 
-extern std::string 
+extern std::string
 get_concat_class (const std::string& c1, const std::string& c2);
 
 extern void
 maybe_warn_string_concat (bool all_dq_strings_p, bool all_sq_strings_p);
 
-extern std::string 
+extern std::string
 get_concat_class (const std::string& c1, const std::string& c2);
 
 extern void
 maybe_warn_string_concat (bool all_dq_strings_p, bool all_sq_strings_p);
 
 #endif
diff --git a/src/pt-pr-code.cc b/src/pt-pr-code.cc
--- a/src/pt-pr-code.cc
+++ b/src/pt-pr-code.cc
@@ -565,17 +565,17 @@ tree_print_code::visit_index_expression 
             tree_argument_list *l = *p_arg_lists;
             if (l)
               l->accept (*this);
 
             nesting.pop ();
             os << ")";
           }
           break;
-            
+
         case '{':
           {
             char nc = nesting.top ();
             if ((nc == '[' || nc == '{') && expr.paren_count () == 0)
               os << "{";
             else
               os << " {";
             // We only care about whitespace inside [] and {} when we
@@ -585,17 +585,17 @@ tree_print_code::visit_index_expression 
             tree_argument_list *l = *p_arg_lists;
             if (l)
               l->accept (*this);
 
             nesting.pop ();
             os << "}";
           }
           break;
-            
+
         case '.':
           {
             string_vector nm = *p_arg_names;
             assert (nm.length () == 1);
             os << "." << nm(0);
           }
           break;
 
diff --git a/src/pt-select.cc b/src/pt-select.cc
--- a/src/pt-select.cc
+++ b/src/pt-select.cc
@@ -180,17 +180,17 @@ tree_switch_case_list::dup (symbol_table
   tree_switch_case_list *new_scl = new tree_switch_case_list ();
 
   for (const_iterator p = begin (); p != end (); p++)
     {
       const tree_switch_case *elt = *p;
 
       new_scl->append (elt ? elt->dup (scope, context) : 0);
     }
-  
+
   return new_scl;
 }
 
 void
 tree_switch_case_list::accept (tree_walker& tw)
 {
   tw.visit_switch_case_list (*this);
 }
diff --git a/src/pt-select.h b/src/pt-select.h
--- a/src/pt-select.h
+++ b/src/pt-select.h
@@ -253,17 +253,17 @@ tree_switch_command : public tree_comman
 {
 public:
 
   tree_switch_command (int l = -1, int c = -1)
     : tree_command (l, c), expr (0), list (0), lead_comm (0),
       trail_comm (0) { }
 
   tree_switch_command (tree_expression *e, tree_switch_case_list *lst,
-                       octave_comment_list *lc, octave_comment_list *tc, 
+                       octave_comment_list *lc, octave_comment_list *tc,
                        int l = -1, int c = -1)
     : tree_command (l, c), expr (e), list (lst), lead_comm (lc),
       trail_comm (tc) { }
 
   ~tree_switch_command (void);
 
   tree_expression *switch_value (void) { return expr; }
 
diff --git a/src/pt-stmt.cc b/src/pt-stmt.cc
--- a/src/pt-stmt.cc
+++ b/src/pt-stmt.cc
@@ -151,17 +151,17 @@ tree_statement::accept (tree_walker& tw)
   tw.visit_statement (*this);
 }
 
 int
 tree_statement_list::set_breakpoint (int line)
 {
   tree_breakpoint tbp (line, tree_breakpoint::set);
   accept (tbp);
-  
+
   return tbp.get_line ();
 }
 
 void
 tree_statement_list::delete_breakpoint (int line)
 {
   if (line < 0)
     {
@@ -172,17 +172,17 @@ tree_statement_list::delete_breakpoint (
       for (int i = 0; i < len; i++)
         {
           tree_breakpoint tbp (i, tree_breakpoint::clear);
           accept (tbp);
         }
     }
   else
     {
-      tree_breakpoint tbp (line, tree_breakpoint::clear); 
+      tree_breakpoint tbp (line, tree_breakpoint::clear);
       accept (tbp);
     }
 }
 
 octave_value_list
 tree_statement_list::list_breakpoints (void)
 {
   tree_breakpoint tbp (0, tree_breakpoint::list);
diff --git a/src/pt-unop.cc b/src/pt-unop.cc
--- a/src/pt-unop.cc
+++ b/src/pt-unop.cc
@@ -79,17 +79,17 @@ tree_prefix_expression::rvalue1 (int)
             }
         }
       else
         {
           octave_value val = op->rvalue1 ();
 
           if (! error_state && val.is_defined ())
             {
-              // Attempt to do the operation in-place if it is unshared 
+              // Attempt to do the operation in-place if it is unshared
               // (a temporary expression).
               if (val.get_count () == 1)
                 retval = val.do_non_const_unary_op (etype);
               else
                 retval = ::do_unary_op (etype, val);
 
               if (error_state)
                 retval = octave_value ();
diff --git a/src/pt-unop.h b/src/pt-unop.h
--- a/src/pt-unop.h
+++ b/src/pt-unop.h
@@ -55,17 +55,17 @@ public:
 
   bool is_unary_expression (void) const { return true; }
 
   bool has_magic_end (void) const { return (op && op->has_magic_end ()); }
 
   tree_expression *operand (void) { return op; }
 
   std::string oper (void) const;
-  
+
   octave_value::unary_op op_type (void) const { return etype; }
 
 protected:
 
   // The operand for the expression.
   tree_expression *op;
 
   // The type of the expression.
diff --git a/src/sighandlers.cc b/src/sighandlers.cc
--- a/src/sighandlers.cc
+++ b/src/sighandlers.cc
@@ -400,18 +400,18 @@ sigpipe_handler (int /* sig */)
 #ifdef USE_W32_SIGINT
 static BOOL CALLBACK
 w32_sigint_handler (DWORD sig)
 {
   const char *sig_name;
 
   switch(sig)
     {
-      case CTRL_BREAK_EVENT:   
-        sig_name = "Ctrl-Break"; 
+      case CTRL_BREAK_EVENT:
+        sig_name = "Ctrl-Break";
         break;
       case CTRL_C_EVENT:
         sig_name = "Ctrl-C";
         break;
       case CTRL_CLOSE_EVENT:
         sig_name = "close console";
         break;
       case CTRL_LOGOFF_EVENT:
@@ -438,17 +438,17 @@ w32_sigint_handler (DWORD sig)
       default:
         // We should do the following:
         //    clean_up_and_exit (0);
         // We can't because we aren't running in the normal Octave thread.
         user_abort(sig_name, sig);
         break;
     }
 
-  // Return TRUE if the event was handled, or FALSE if another handler 
+  // Return TRUE if the event was handled, or FALSE if another handler
   // should be called.
   // FIXME check that windows terminates the thread.
   return TRUE;
 }
 #endif /* w32_sigint_handler */
 
 
 octave_interrupt_handler
@@ -462,17 +462,17 @@ octave_catch_interrupts (void)
 
 #ifdef SIGBREAK
   retval.brk_handler = octave_set_signal_handler (SIGBREAK, sigint_handler);
 #endif
 
 #ifdef USE_W32_SIGINT
 
   // Intercept windows console control events.
-  // Note that the windows console signal handlers chain, so if 
+  // Note that the windows console signal handlers chain, so if
   // install_signal_handlers is called more than once in the same program,
   // then first call the following to avoid duplicates:
   //
   //   SetConsoleCtrlHandler (w32_sigint_handler, FALSE);
 
   if (! SetConsoleCtrlHandler (w32_sigint_handler, TRUE))
     error ("SetConsoleCtrlHandler failed with %ld\n", GetLastError ());
 
diff --git a/src/sighandlers.h b/src/sighandlers.h
--- a/src/sighandlers.h
+++ b/src/sighandlers.h
@@ -85,32 +85,32 @@ octave_set_interrupt_handler (const vola
 
 // Maybe this should be in a separate file?
 
 class
 OCTINTERP_API
 octave_child
 {
 public:
-  
+
   // Do whatever to handle event for child with PID (might not
   // actually be dead, could just be stopped).  Return true if
   // the list element corresponding to PID should be removed from
   // list.  This function should not call any functions that modify
   // the octave_child_list.
 
   typedef bool (*child_event_handler) (pid_t, int);
 
   octave_child (pid_t id = -1, child_event_handler f = 0)
     : pid (id), handler (f), have_status (0), status (0) { }
 
   octave_child (const octave_child& oc)
     : pid (oc.pid), handler (oc.handler),
       have_status (oc.have_status), status (oc.status) { }
- 
+
   octave_child& operator = (const octave_child& oc)
     {
       if (&oc != this)
         {
           pid = oc.pid;
           handler = oc.handler;
           have_status = oc.have_status;
           status = oc.status;
diff --git a/src/sparse-xdiv.cc b/src/sparse-xdiv.cc
--- a/src/sparse-xdiv.cc
+++ b/src/sparse-xdiv.cc
@@ -138,17 +138,17 @@ xdiv (const Matrix& a, const SparseMatri
     return Matrix ();
 
   Matrix atmp = a.transpose ();
   SparseMatrix btmp = b.transpose ();
   MatrixType btyp = typ.transpose ();
 
   octave_idx_type info;
   double rcond = 0.0;
-  Matrix result = btmp.solve (btyp, atmp, info, rcond, 
+  Matrix result = btmp.solve (btyp, atmp, info, rcond,
                               solve_singularity_warning);
 
   typ = btyp.transpose ();
   return result.transpose ();
 }
 
 // -*- 2 -*-
 ComplexMatrix
@@ -218,17 +218,17 @@ xdiv (const SparseMatrix& a, const Spars
     return SparseMatrix ();
 
   SparseMatrix atmp = a.transpose ();
   SparseMatrix btmp = b.transpose ();
   MatrixType btyp = typ.transpose ();
 
   octave_idx_type info;
   double rcond = 0.0;
-  SparseMatrix result = btmp.solve (btyp, atmp, info, rcond, 
+  SparseMatrix result = btmp.solve (btyp, atmp, info, rcond,
                                     solve_singularity_warning);
 
   typ = btyp.transpose ();
   return result.transpose ();
 }
 
 // -*- 6 -*-
 SparseComplexMatrix
@@ -541,17 +541,17 @@ xleftdiv (const SparseComplexMatrix& a, 
 
   octave_idx_type info;
   double rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning);
 }
 
 // -*- 8 -*-
 SparseComplexMatrix
-xleftdiv (const SparseComplexMatrix& a, const SparseComplexMatrix& b, 
+xleftdiv (const SparseComplexMatrix& a, const SparseComplexMatrix& b,
           MatrixType &typ)
 {
   if (! mx_leftdiv_conform (a, b))
     return SparseComplexMatrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning);
diff --git a/src/sparse-xdiv.h b/src/sparse-xdiv.h
--- a/src/sparse-xdiv.h
+++ b/src/sparse-xdiv.h
@@ -32,62 +32,62 @@ class ComplexDiagMatrix;
 class SparseMatrix;
 class SparseComplexMatrix;
 
 extern Matrix xdiv (const Matrix& a, const SparseMatrix& b, MatrixType &typ);
 extern ComplexMatrix xdiv (const Matrix& a, const SparseComplexMatrix& b,
                            MatrixType &typ);
 extern ComplexMatrix xdiv (const ComplexMatrix& a, const SparseMatrix& b,
                            MatrixType &typ);
-extern ComplexMatrix xdiv (const ComplexMatrix& a, 
+extern ComplexMatrix xdiv (const ComplexMatrix& a,
                            const SparseComplexMatrix& b, MatrixType &typ);
 
 extern SparseMatrix xdiv (const SparseMatrix& a, const SparseMatrix& b,
                           MatrixType &typ);
-extern SparseComplexMatrix xdiv (const SparseMatrix& a, 
+extern SparseComplexMatrix xdiv (const SparseMatrix& a,
                                  const SparseComplexMatrix& b, MatrixType &typ);
-extern SparseComplexMatrix xdiv (const SparseComplexMatrix& a, 
+extern SparseComplexMatrix xdiv (const SparseComplexMatrix& a,
                                  const SparseMatrix& b, MatrixType &typ);
-extern SparseComplexMatrix xdiv (const SparseComplexMatrix& a, 
+extern SparseComplexMatrix xdiv (const SparseComplexMatrix& a,
                                  const SparseComplexMatrix& b, MatrixType &typ);
 
-extern SparseMatrix xdiv (const SparseMatrix& a, 
+extern SparseMatrix xdiv (const SparseMatrix& a,
                           const DiagMatrix& b, MatrixType &typ);
-extern SparseComplexMatrix xdiv (const SparseMatrix& a, 
+extern SparseComplexMatrix xdiv (const SparseMatrix& a,
                                  const ComplexDiagMatrix& b, MatrixType &typ);
-extern SparseComplexMatrix xdiv (const SparseComplexMatrix& a, 
+extern SparseComplexMatrix xdiv (const SparseComplexMatrix& a,
                                  const DiagMatrix& b, MatrixType &typ);
-extern SparseComplexMatrix xdiv (const SparseComplexMatrix& a, 
+extern SparseComplexMatrix xdiv (const SparseComplexMatrix& a,
                                  const ComplexDiagMatrix& b, MatrixType &typ);
 
 extern Matrix x_el_div (double a, const SparseMatrix& b);
 extern ComplexMatrix x_el_div (double a, const SparseComplexMatrix& b);
 extern ComplexMatrix x_el_div (const Complex a, const SparseMatrix& b);
-extern ComplexMatrix x_el_div (const Complex a, 
+extern ComplexMatrix x_el_div (const Complex a,
                                const SparseComplexMatrix& b);
 
-extern Matrix xleftdiv (const SparseMatrix& a, const Matrix& b, 
+extern Matrix xleftdiv (const SparseMatrix& a, const Matrix& b,
                         MatrixType& typ);
 extern ComplexMatrix xleftdiv (const SparseMatrix& a, const ComplexMatrix& b,
                                MatrixType &typ);
 extern ComplexMatrix xleftdiv (const SparseComplexMatrix& a, const Matrix& b,
                                MatrixType &typ);
-extern ComplexMatrix xleftdiv (const SparseComplexMatrix& a, 
+extern ComplexMatrix xleftdiv (const SparseComplexMatrix& a,
                                const ComplexMatrix& b, MatrixType &typ);
 
 extern SparseMatrix xleftdiv (const SparseMatrix& a, const SparseMatrix& b,
                               MatrixType &typ);
-extern SparseComplexMatrix xleftdiv (const SparseMatrix& a, 
+extern SparseComplexMatrix xleftdiv (const SparseMatrix& a,
                                      const SparseComplexMatrix& b, MatrixType &typ);
-extern SparseComplexMatrix xleftdiv (const SparseComplexMatrix& a, 
+extern SparseComplexMatrix xleftdiv (const SparseComplexMatrix& a,
                                      const SparseMatrix& b, MatrixType &typ);
-extern SparseComplexMatrix xleftdiv (const SparseComplexMatrix& a, 
+extern SparseComplexMatrix xleftdiv (const SparseComplexMatrix& a,
                                      const SparseComplexMatrix& b, MatrixType &typ);
 
 extern SparseMatrix xleftdiv (const DiagMatrix&, const SparseMatrix&, MatrixType&);
-extern SparseComplexMatrix xleftdiv (const ComplexDiagMatrix&, const SparseMatrix&, 
+extern SparseComplexMatrix xleftdiv (const ComplexDiagMatrix&, const SparseMatrix&,
                                      MatrixType&);
-extern SparseComplexMatrix xleftdiv (const DiagMatrix&, const SparseComplexMatrix&, 
+extern SparseComplexMatrix xleftdiv (const DiagMatrix&, const SparseComplexMatrix&,
                                      MatrixType&);
-extern SparseComplexMatrix xleftdiv (const ComplexDiagMatrix&, const SparseComplexMatrix&, 
+extern SparseComplexMatrix xleftdiv (const ComplexDiagMatrix&, const SparseComplexMatrix&,
                                      MatrixType&);
 
 #endif
diff --git a/src/sparse-xpow.cc b/src/sparse-xpow.cc
--- a/src/sparse-xpow.cc
+++ b/src/sparse-xpow.cc
@@ -296,17 +296,17 @@ elem_xpow (double a, const SparseComplex
 
   return result;
 }
 
 // -*- 3 -*-
 octave_value
 elem_xpow (const SparseMatrix& a, double b)
 {
-  // FIXME What should a .^ 0 give?? Matlab gives a 
+  // FIXME What should a .^ 0 give?? Matlab gives a
   // sparse matrix with same structure as a, which is strictly
   // incorrect. Keep compatiability.
 
   octave_value retval;
 
   octave_idx_type nz = a.nnz ();
 
   if (b <= 0.0)
@@ -321,19 +321,19 @@ elem_xpow (const SparseMatrix& a, double
           // FIXME -- avoid apparent GNU libm bug by
           // converting A and B to complex instead of just A.
           Complex btmp (b);
 
           for (octave_idx_type j = 0; j < nc; j++)
             for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
               {
                 octave_quit ();
-              
+
                 Complex atmp (a.data (i));
-                
+
                 result (a.ridx(i), j) = std::pow (atmp, btmp);
               }
 
           retval = octave_value (result);
         }
       else
         {
           Matrix result (nr, nc, (std::pow (0.0, b)));
@@ -447,17 +447,17 @@ done:
     {
       SparseMatrix result (nr, nc, 1.0);
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
             {
               octave_quit ();
-              result.xelem(a.ridx(i), j) = std::pow (a.data(i), 
+              result.xelem(a.ridx(i), j) = std::pow (a.data(i),
                                                      b (a.ridx(i), j));
             }
         }
       result.maybe_compress (true);
       retval = result;
     }
 
   return retval;
@@ -471,23 +471,23 @@ elem_xpow (const SparseMatrix& a, const 
 
   if (b == 0.0)
     // Can this case ever happen, due to automatic retyping with maybe_mutate?
     retval = octave_value (NDArray (a.dims (), 1));
   else
     {
       octave_idx_type nz = a.nnz ();
       SparseComplexMatrix result (a);
-      
+
       for (octave_idx_type i = 0; i < nz; i++)
         {
           octave_quit ();
           result.data (i) = std::pow (Complex (a.data (i)), b);
         }
-  
+
       result.maybe_compress (true);
 
       retval = result;
     }
 
   return retval;
 }
 
@@ -579,54 +579,54 @@ elem_xpow (const SparseComplexMatrix& a,
       ComplexMatrix result (nr, nc, Complex (std::pow (0.0, b)));
 
       if (xisint (b))
         {
           for (octave_idx_type j = 0; j < nc; j++)
             for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
               {
                 octave_quit ();
-                result (a.ridx(i), j) = 
+                result (a.ridx(i), j) =
                   std::pow (a.data (i), static_cast<int> (b));
               }
         }
       else
         {
           for (octave_idx_type j = 0; j < nc; j++)
             for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
               {
                 octave_quit ();
                 result (a.ridx(i), j) = std::pow (a.data (i), b);
               }
-        }  
+        }
 
       retval = result;
     }
   else
     {
       octave_idx_type nz = a.nnz ();
 
       SparseComplexMatrix result (a);
-  
+
       if (xisint (b))
         {
           for (octave_idx_type i = 0; i < nz; i++)
             {
               octave_quit ();
               result.data (i) = std::pow (a.data (i), static_cast<int> (b));
             }
         }
       else
         {
           for (octave_idx_type i = 0; i < nz; i++)
             {
               octave_quit ();
               result.data (i) = std::pow (a.data (i), b);
             }
-        }  
+        }
 
       result.maybe_compress (true);
 
       retval = result;
     }
 
   return retval;
 }
@@ -652,17 +652,17 @@ elem_xpow (const SparseComplexMatrix& a,
     {
       for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
         {
           octave_quit ();
           double btmp = b (a.ridx(i), j);
           Complex tmp;
 
           if (xisint (btmp))
-            result.xelem(a.ridx(i), j) = std::pow (a.data (i), 
+            result.xelem(a.ridx(i), j) = std::pow (a.data (i),
                                               static_cast<int> (btmp));
           else
             result.xelem(a.ridx(i), j) = std::pow (a.data (i), btmp);
         }
     }
 
   result.maybe_compress (true);
 
@@ -687,17 +687,17 @@ elem_xpow (const SparseComplexMatrix& a,
 
       for (octave_idx_type i = 0; i < nz; i++)
         {
           octave_quit ();
           result.data (i) = std::pow (a.data (i), b);
         }
 
       result.maybe_compress (true);
-      
+
       retval = result;
     }
 
   return retval;
 }
 
 // -*- 12 -*-
 octave_value
@@ -711,17 +711,17 @@ elem_xpow (const SparseComplexMatrix& a,
 
   if (nr != b_nr || nc != b_nc)
     {
       gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
       return octave_value ();
     }
 
   SparseComplexMatrix result (nr, nc, Complex(1.0, 0.0));
-  for (octave_idx_type j = 0; j < nc; j++) 
+  for (octave_idx_type j = 0; j < nc; j++)
     {
       for (octave_idx_type i = a.cidx(j); i < a.cidx(j+1); i++)
         {
           octave_quit ();
           result.xelem(a.ridx(i), j) = std::pow (a.data (i), b (a.ridx(i), j));
         }
     }
   result.maybe_compress (true);
diff --git a/src/sparse-xpow.h b/src/sparse-xpow.h
--- a/src/sparse-xpow.h
+++ b/src/sparse-xpow.h
@@ -34,24 +34,24 @@ extern octave_value xpow (const SparseMa
 extern octave_value xpow (const SparseComplexMatrix& a, double b);
 
 extern octave_value elem_xpow (double a, const SparseMatrix& b);
 extern octave_value elem_xpow (double a, const SparseComplexMatrix& b);
 
 extern octave_value elem_xpow (const SparseMatrix& a, double b);
 extern octave_value elem_xpow (const SparseMatrix& a, const SparseMatrix& b);
 extern octave_value elem_xpow (const SparseMatrix& a, const Complex& b);
-extern octave_value elem_xpow (const SparseMatrix& a, 
+extern octave_value elem_xpow (const SparseMatrix& a,
                                const SparseComplexMatrix& b);
 
 extern octave_value elem_xpow (const Complex& a, const SparseMatrix& b);
-extern octave_value elem_xpow (const Complex& a, 
+extern octave_value elem_xpow (const Complex& a,
                                const SparseComplexMatrix& b);
 
 extern octave_value elem_xpow (const SparseComplexMatrix& a, double b);
-extern octave_value elem_xpow (const SparseComplexMatrix& a, 
+extern octave_value elem_xpow (const SparseComplexMatrix& a,
                                const SparseMatrix& b);
-extern octave_value elem_xpow (const SparseComplexMatrix& a, 
+extern octave_value elem_xpow (const SparseComplexMatrix& a,
                                const Complex& b);
-extern octave_value elem_xpow (const SparseComplexMatrix& a, 
+extern octave_value elem_xpow (const SparseComplexMatrix& a,
                                const SparseComplexMatrix& b);
 
 #endif
diff --git a/src/sparse.cc b/src/sparse.cc
--- a/src/sparse.cc
+++ b/src/sparse.cc
@@ -41,24 +41,24 @@ along with Octave; see the file COPYING.
 #include "ov-cx-sparse.h"
 #include "ov-bool-sparse.h"
 
 DEFUN (issparse, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} issparse (@var{x})\n\
 Return true if @var{x} is a sparse matrix.\n\
 @seealso{ismatrix}\n\
-@end deftypefn") 
+@end deftypefn")
 {
-   if (args.length() != 1) 
+   if (args.length() != 1)
      {
        print_usage ();
        return octave_value ();
      }
-   else 
+   else
      return octave_value (args(0).is_sparse_type ());
 }
 
 DEFUN (sparse, args, ,
     "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{s} =} sparse (@var{a})\n\
 @deftypefnx {Loadable Function} {@var{s} =} sparse (@var{i}, @var{j}, @var{sv}, @var{m}, @var{n}, @var{nzmax})\n\
 @deftypefnx {Loadable Function} {@var{s} =} sparse (@var{i}, @var{j}, @var{sv})\n\
diff --git a/src/strfns.cc b/src/strfns.cc
--- a/src/strfns.cc
+++ b/src/strfns.cc
@@ -524,24 +524,24 @@ do_strcmp_fun (const octave_value& arg0,
     }
   else
     retval = false;
 
   return retval;
 }
 
 // If both args are arrays, dimensions may be significant.
-static bool 
+static bool
 strcmp_array_op (const charNDArray& s1, const charNDArray& s2, octave_idx_type)
 {
   return (s1.dims () == s2.dims ()
           && std::equal (s1.data (), s1.data () + s1.numel (), s2.data ()));
 }
 
-// Otherwise, just use strings. 
+// Otherwise, just use strings.
 static bool
 strcmp_str_op (const std::string& s1, const std::string& s2,
                octave_idx_type)
 {
   return s1 == s2;
 }
 
 DEFUN (strcmp, args, ,
@@ -613,33 +613,33 @@ This is just the opposite of the corresp
 ## %!assert (all (strcmp ('', {y; y}) == [false; false]));
 ## %!assert (all (strcmp ({''}, {y; y}) == [false; false]));
 %!assert (all (strcmp ({'foo'}, y) == [false; false]));
 %!assert (all (strcmp ({'foo'}, y) == [false; false]));
 %!assert (all (strcmp (y, {'foo'}) == [false; false]));
 %!assert (all (strcmp (y, {'foo'}) == [false; false]));
 */
 
-// Apparently, Matlab ignores the dims with strncmp. It also 
-static bool 
+// Apparently, Matlab ignores the dims with strncmp. It also
+static bool
 strncmp_array_op (const charNDArray& s1, const charNDArray& s2, octave_idx_type n)
 {
   octave_idx_type l1 = s1.numel (), l2 = s2.numel ();
-  return (n > 0 && n <= l1 && n <= l2 
+  return (n > 0 && n <= l1 && n <= l2
           && std::equal (s1.data (), s1.data () + n, s2.data ()));
 }
 
 // Otherwise, just use strings. Note that we neither extract substrings (which
 // would mean a copy, at least in GCC), nor use string::compare (which is a
 // 3-way compare).
 static bool
 strncmp_str_op (const std::string& s1, const std::string& s2, octave_idx_type n)
 {
   octave_idx_type l1 = s1.length (), l2 = s2.length ();
-  return (n > 0 && n <= l1 && n <= l2 
+  return (n > 0 && n <= l1 && n <= l2
           && std::equal (s1.data (), s1.data () + n, s2.data ()));
 }
 
 DEFUN (strncmp, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} strncmp (@var{s1}, @var{s2}, @var{n})\n\
 Return 1 if the first @var{n} characters of strings @var{s1} and @var{s2} are\n\
 the same, and 0 otherwise.\n\
@@ -708,17 +708,17 @@ This is just the opposite of the corresp
 // case-insensitive character equality functor
 struct icmp_char_eq : public std::binary_function<char, char, bool>
 {
   bool operator () (char x, char y) const
     { return std::toupper (x) == std::toupper (y); }
 };
 
 // strcmpi is equivalent to strcmp in that it checks all dims.
-static bool 
+static bool
 strcmpi_array_op (const charNDArray& s1, const charNDArray& s2, octave_idx_type)
 {
   return (s1.dims () == s2.dims ()
           && std::equal (s1.data (), s1.data () + s1.numel (), s2.data (),
                          icmp_char_eq ()));
 }
 
 // Ditto for string.
@@ -764,31 +764,31 @@ This is just the opposite of the corresp
   return retval;
 }
 
 /*
 %!assert (strcmpi("abc123", "ABC123"), logical(1));
 */
 
 // Like strncmp.
-static bool 
+static bool
 strncmpi_array_op (const charNDArray& s1, const charNDArray& s2, octave_idx_type n)
 {
   octave_idx_type l1 = s1.numel (), l2 = s2.numel ();
-  return (n > 0 && n <= l1 && n <= l2 
+  return (n > 0 && n <= l1 && n <= l2
           && std::equal (s1.data (), s1.data () + n, s2.data (),
                          icmp_char_eq ()));
 }
 
 // Ditto.
 static bool
 strncmpi_str_op (const std::string& s1, const std::string& s2, octave_idx_type n)
 {
   octave_idx_type l1 = s1.length (), l2 = s2.length ();
-  return (n > 0 && n <= l1 && n <= l2 
+  return (n > 0 && n <= l1 && n <= l2
           && std::equal (s1.data (), s1.data () + n, s2.data (),
                          icmp_char_eq ()));
 }
 
 DEFUNX ("strncmpi", Fstrncmpi, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} strncmpi (@var{s1}, @var{s2}, @var{n})\n\
 Return 1 if the first @var{n} character of @var{s1} and @var{s2} are the\n\
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -1,13 +1,13 @@
 /*
 
 Copyright (C) 1993-2011 John W. Eaton
 Copyright (C) 2009 VZLU Prague, a.s.
-  
+
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
 Octave is distributed in the hope that it will be useful, but WITHOUT
@@ -106,17 +106,17 @@ symbol_table::symbol_record::find (const
       retval = varval ();
 
       if (retval.is_undefined ())
         {
           // Use cached fcn_info pointer if possible.
           if (rep->finfo)
             retval = rep->finfo->find (args);
           else
-            { 
+            {
               retval = symbol_table::find_function (name (), args);
 
               if (retval.is_defined ())
                 rep->finfo = get_fcn_info (name ());
             }
         }
     }
 
@@ -295,17 +295,17 @@ out_of_date_check (octave_value& functio
                       // place of the old.
 
                       retval = load_out_of_date_fcn (file, dir_name, function,
                                                      dispatch_type);
 
                       clear_breakpoints = true;
                     }
 
-                  // If the function has been replaced then clear any 
+                  // If the function has been replaced then clear any
                   // breakpoints associated with it
                   if (clear_breakpoints)
                     bp_table::remove_all_breakpoints_in_file (nm, true);
                 }
             }
         }
     }
 
@@ -408,17 +408,17 @@ symbol_table::fcn_info::fcn_info_rep::lo
           const std::list<std::string>& plist = parent_classes (dispatch_type);
 
           std::list<std::string>::const_iterator it = plist.begin ();
 
           while (it != plist.end ())
             {
               retval = find_method (*it);
 
-              if (retval.is_defined ()) 
+              if (retval.is_defined ())
                 {
                   class_methods[dispatch_type] = retval;
                   break;
                 }
 
               it++;
             }
         }
@@ -448,17 +448,17 @@ symbol_table::fcn_info::fcn_info_rep::pr
   if (dispatch_map.empty ())
     os << "dispatch: " << name << " is not overloaded" << std::endl;
   else
     {
       os << "Overloaded function " << name << ":\n\n";
 
       for (dispatch_map_const_iterator p = dispatch_map.begin ();
            p != dispatch_map.end (); p++)
-        os << "  " << name << " (" << p->first << ", ...) -> " 
+        os << "  " << name << " (" << p->first << ", ...) -> "
            << p->second << " (" << p->first << ", ...)\n";
 
       os << std::endl;
     }
 }
 
 std::string
 symbol_table::fcn_info::fcn_info_rep::help_for_dispatch (void) const
@@ -485,32 +485,32 @@ static builtin_type_t (*build_sup_table 
 {
   static builtin_type_t sup_table[btyp_num_types][btyp_num_types];
   for (int i = 0; i < btyp_num_types; i++)
     for (int j = 0; j < btyp_num_types; j++)
       {
         builtin_type_t ityp = static_cast<builtin_type_t> (i);
         builtin_type_t jtyp = static_cast<builtin_type_t> (j);
         // FIXME: Is this really right?
-        bool use_j = 
+        bool use_j =
           (jtyp == btyp_func_handle || ityp == btyp_bool
-           || (btyp_isarray (ityp) 
-               && (! btyp_isarray (jtyp) 
+           || (btyp_isarray (ityp)
+               && (! btyp_isarray (jtyp)
                    || (btyp_isinteger (jtyp) && ! btyp_isinteger (ityp))
                    || ((ityp == btyp_double || ityp == btyp_complex || ityp == btyp_char)
                        && (jtyp == btyp_float || jtyp == btyp_float_complex)))));
 
         sup_table[i][j] = use_j ? jtyp : ityp;
       }
 
   return sup_table;
 }
 
 std::string
-get_dispatch_type (const octave_value_list& args, 
+get_dispatch_type (const octave_value_list& args,
                    builtin_type_t& builtin_type)
 {
   static builtin_type_t (*sup_table)[btyp_num_types] = build_sup_table ();
   std::string dispatch_type;
 
   int n = args.length ();
 
   if (n > 0)
@@ -723,17 +723,17 @@ symbol_table::fcn_info::fcn_info_rep::xf
       std::string dispatch_type = get_dispatch_type (args);
 
       octave_value fcn = find_method (dispatch_type);
 
       if (fcn.is_defined ())
         return fcn;
     }
 
-  // Legacy dispatch.  
+  // Legacy dispatch.
 
   if (! args.empty () && ! dispatch_map.empty ())
     {
       std::string dispatch_type = args(0).type_name ();
 
       std::string fname;
 
       dispatch_map_iterator p = dispatch_map.find (dispatch_type);
@@ -1128,18 +1128,18 @@ symbol_table::fcn_info::fcn_info_rep::du
       for (dispatch_map_const_iterator p = dispatch_map.begin ();
            p != dispatch_map.end (); p++)
         os << tprefix << "dispatch: " << fcn_file_name (p->second)
            << " [" << p->first << "]\n";
     }
 }
 
 octave_value
-symbol_table::find (const std::string& name, 
-                    const octave_value_list& args, 
+symbol_table::find (const std::string& name,
+                    const octave_value_list& args,
                     bool skip_variables,
                     bool local_funcs)
 {
   symbol_table *inst = get_instance (xcurrent_scope);
 
   return inst
     ? inst->do_find (name, args, skip_variables, local_funcs)
     : octave_value ();
@@ -1158,21 +1158,21 @@ symbol_table::find_function (const std::
                              const octave_value_list& args,
                              bool local_funcs)
 {
   octave_value retval;
 
   if (! name.empty () && name[0] == '@')
     {
       // Look for a class specific function.
-      std::string dispatch_type = 
+      std::string dispatch_type =
         name.substr (1, name.find_first_of (file_ops::dir_sep_str ()) - 1);
 
-      std::string method = 
-        name.substr (name.find_last_of (file_ops::dir_sep_str ()) + 1, 
+      std::string method =
+        name.substr (name.find_last_of (file_ops::dir_sep_str ()) + 1,
                      std::string::npos);
 
       retval = find_method (method, dispatch_type);
     }
   else
     {
       size_t pos = name.find_first_of (Vfilemarker);
 
@@ -1299,17 +1299,17 @@ symbol_table::stash_dir_name_for_subfunc
 
           if (f)
             f->stash_dir_name (dir_name);
         }
     }
 }
 
 octave_value
-symbol_table::do_find (const std::string& name, 
+symbol_table::do_find (const std::string& name,
                        const octave_value_list& args,
                        bool skip_variables,
                        bool local_funcs)
 {
   octave_value retval;
 
   // Variable.
 
@@ -1421,18 +1421,18 @@ void symbol_table::cleanup (void)
 
   // Clear variables in global scope.
   // FIXME: are there any?
   all_instances[xglobal_scope]->clear_variables ();
 
   // Clear global variables.
   global_table.clear ();
 
-  // Delete all possibly remaining scopes. 
-  for (all_instances_iterator iter = all_instances.begin (); 
+  // Delete all possibly remaining scopes.
+  for (all_instances_iterator iter = all_instances.begin ();
        iter != all_instances.end (); iter++)
     {
       scope_id scope = iter->first;
       if (scope != xglobal_scope && scope != xtop_scope)
         scope_id_cache::free (scope);
 
       // First zero the table entry to avoid possible duplicate delete.
       symbol_table *inst = iter->second;
diff --git a/src/symtab.h b/src/symtab.h
--- a/src/symtab.h
+++ b/src/symtab.h
@@ -1,13 +1,13 @@
 /*
 
 Copyright (C) 1993-2011 John W. Eaton
 Copyright (C) 2009 VZLU Prague
-  
+
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
 Octave is distributed in the hope that it will be useful, but WITHOUT
@@ -392,17 +392,17 @@ public:
 
     symbol_record (const std::string& nm = std::string (),
                    const octave_value& v = octave_value (),
                    unsigned int sc = local)
       : rep (new symbol_record_rep (nm, v, sc)) { }
 
     symbol_record (const symbol_record& sr)
       : rep (sr.rep)
-    { 
+    {
       rep->count++;
     }
 
     symbol_record& operator = (const symbol_record& sr)
     {
       if (this != &sr)
         {
           if (--rep->count == 0)
@@ -525,17 +525,17 @@ public:
     class
     fcn_info_rep
     {
     public:
 
       fcn_info_rep (const std::string& nm)
         : name (nm), subfunctions (), private_functions (),
           class_constructors (), class_methods (), dispatch_map (),
-          cmdline_function (), autoload_function (), function_on_path (), 
+          cmdline_function (), autoload_function (), function_on_path (),
           built_in_function (), count (1) { }
 
       octave_value load_private_function (const std::string& dir_name);
 
       octave_value load_class_constructor (void);
 
       octave_value load_class_method (const std::string& dispatch_type);
 
@@ -578,17 +578,17 @@ public:
       std::pair<std::string, octave_value>
       subfunction_defined_in_scope (scope_id scope) const
       {
         scope_val_const_iterator p = subfunctions.find (scope);
 
         return p == subfunctions.end ()
           ? std::pair<std::string, octave_value> ()
           : std::pair<std::string, octave_value> (name, p->second);
-      }      
+      }
 
       void erase_subfunction (scope_id scope)
       {
         scope_val_iterator p = subfunctions.find (scope);
 
         if (p != subfunctions.end ())
           subfunctions.erase (p);
       }
@@ -734,17 +734,17 @@ public:
     };
 
   public:
 
     fcn_info (const std::string& nm = std::string ())
       : rep (new fcn_info_rep (nm)) { }
 
     fcn_info (const fcn_info& fi) : rep (fi.rep)
-    { 
+    {
       rep->count++;
     }
 
     fcn_info& operator = (const fcn_info& fi)
     {
       if (this != &fi)
         {
           if (--rep->count == 0)
@@ -814,17 +814,17 @@ public:
     {
       rep->unlock_subfunction (scope);
     }
 
     std::pair<std::string, octave_value>
     subfunction_defined_in_scope (scope_id scope = xcurrent_scope) const
     {
       return rep->subfunction_defined_in_scope (scope);
-    }        
+    }
 
     void erase_subfunction (scope_id scope)
     {
       rep->erase_subfunction (scope);
     }
 
     void mark_subfunction_in_scope_as_private (scope_id scope,
                                                const std::string& class_name)
@@ -850,19 +850,19 @@ public:
     void install_built_in_function (const octave_value& f)
     {
       rep->install_built_in_function (f);
     }
 
     void clear (void) { rep->clear (); }
 
     void clear_user_function (void) { rep->clear_user_function (); }
-    
+
     void clear_autoload_function (void) { rep->clear_autoload_function (); }
-    
+
     void clear_mex_function (void) { rep->clear_mex_function (); }
 
     void add_dispatch (const std::string& type, const std::string& fname)
     {
       rep->add_dispatch (type, fname);
     }
 
     void clear_dispatch (const std::string& type)
@@ -1034,17 +1034,17 @@ public:
           inst->do_inherit (*donor_symbol_table, donor_context);
       }
   }
 
   static bool at_top_level (void) { return xcurrent_scope == xtop_scope; }
 
   // Find a value corresponding to the given name in the table.
   static octave_value
-  find (const std::string& name, 
+  find (const std::string& name,
         const octave_value_list& args = octave_value_list (),
         bool skip_variables = false,
         bool local_funcs = true);
 
   static octave_value builtin_find (const std::string& name);
 
   // Insert a new name in the table.
   static symbol_record& insert (const std::string& name)
@@ -1187,17 +1187,17 @@ public:
   {
     fcn_table_iterator p = fcn_table.find (name);
 
     return (p != fcn_table.end ())
       ? p->second.find_autoload () : octave_value ();
   }
 
   static octave_value
-  find_function (const std::string& name, 
+  find_function (const std::string& name,
                  const octave_value_list& args = octave_value_list (),
                  bool local_funcs = true);
 
   static octave_value find_user_function (const std::string& name)
   {
     fcn_table_iterator p = fcn_table.find (name);
 
     return (p != fcn_table.end ())
@@ -1292,17 +1292,17 @@ public:
   static void clear (const std::string& name)
   {
     clear_variable (name);
   }
 
   static void clear_all (void)
   {
     clear_variables ();
-    
+
     clear_global_pattern ("*");
 
     clear_functions ();
   }
 
   static void clear_variables (scope_id scope)
   {
     symbol_table *inst = get_instance (scope);
@@ -1449,17 +1449,17 @@ public:
         finfo.clear_mex_function ();
       }
   }
 
   static bool set_class_relationship (const std::string& sup_class,
                                       const std::string& inf_class);
 
   static bool is_superiorto (const std::string& a, const std::string& b);
-    
+
   static void alias_built_in_function (const std::string& alias,
                                        const std::string& name)
   {
     octave_value fcn = find_built_in_function (name);
 
     if (fcn.is_defined ())
       {
         fcn_info finfo (alias);
@@ -1696,17 +1696,17 @@ public:
         std::list<symbol_record> tmp = glob_variables (patterns[i]);
 
         retval.insert (retval.begin (), tmp.begin (), tmp.end ());
       }
 
     return retval;
   }
 
-  static std::list<symbol_record> regexp_variables 
+  static std::list<symbol_record> regexp_variables
     (const string_vector& patterns)
   {
     std::list<symbol_record> retval;
 
     size_t len = patterns.length ();
 
     for (size_t i = 0; i < len; i++)
       {
@@ -1819,24 +1819,24 @@ public:
       inst->do_cache_name (name);
   }
 
   static void lock_subfunctions (scope_id scope = xcurrent_scope)
   {
     for (fcn_table_iterator p = fcn_table.begin ();
          p != fcn_table.end (); p++)
       p->second.lock_subfunction (scope);
-  }    
+  }
 
   static void unlock_subfunctions (scope_id scope = xcurrent_scope)
   {
     for (fcn_table_iterator p = fcn_table.begin ();
          p != fcn_table.end (); p++)
       p->second.unlock_subfunction (scope);
-  }    
+  }
 
   static void free_scope (scope_id scope)
   {
     if (scope == xglobal_scope || scope == xtop_scope)
       error ("can't free global or top-level scopes!");
     else
       symbol_table::scope_id_cache::free (scope);
   }
@@ -1870,17 +1870,17 @@ public:
     }
 
   static void set_curr_fcn (octave_user_function *curr_fcn,
                             scope_id scope = xcurrent_scope)
     {
       assert (scope != xtop_scope && scope != xglobal_scope);
       symbol_table *inst = get_instance (scope);
       // FIXME: normally, functions should not usurp each other's scope.
-      // If for any incredible reason this is needed, call 
+      // If for any incredible reason this is needed, call
       // set_user_function (0, scope) first.
       assert (inst->curr_fcn == 0 || curr_fcn == 0);
       inst->curr_fcn = curr_fcn;
     }
 
   static void cleanup (void);
 
 private:
@@ -2225,17 +2225,17 @@ private:
       {
         symbol_record& sr = p->second;
 
         if (sr.is_global () && pattern.match (sr.name ()))
           sr.unmark_global ();
       }
 
 
-    for (global_table_iterator q = global_table.begin (); 
+    for (global_table_iterator q = global_table.begin ();
          q != global_table.end ();)
       {
         if (pattern.match (q->first))
           global_table.erase (q++); //Gotta be careful to not
                                     //invalidate iterators
         else
           q++;
       }
diff --git a/src/syscalls.cc b/src/syscalls.cc
--- a/src/syscalls.cc
+++ b/src/syscalls.cc
@@ -1261,17 +1261,17 @@ system-dependent error message.\n\
         {
           std::string name = args(0).string_value ();
 
           std::string msg;
 
           int status = octave_unlink (name, msg);
 
           retval(0) = status;
-          retval(1) = msg;          
+          retval(1) = msg;
         }
       else
         error ("unlink: file name must be a string");
     }
   else
     print_usage ();
 
   return retval;
@@ -1328,17 +1328,17 @@ information about the subprocess that ex
   retval(1) = 0;
   retval(0) = -1;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
       pid_t pid = args(0).int_value (true);
-  
+
       if (! error_state)
         {
           int options = 0;
 
           if (args.length () == 2)
             options = args(1).int_value (true);
 
           if (! error_state)
diff --git a/src/sysdep.cc b/src/sysdep.cc
--- a/src/sysdep.cc
+++ b/src/sysdep.cc
@@ -37,17 +37,17 @@ along with Octave; see the file COPYING.
 #include <unistd.h>
 
 #if defined (HAVE_TERMIOS_H)
 #include <termios.h>
 #elif defined (HAVE_TERMIO_H)
 #include <termio.h>
 #elif defined (HAVE_SGTTY_H)
 #include <sgtty.h>
-#endif 
+#endif
 
 #if defined (HAVE_CONIO_H)
 #include <conio.h>
 #endif
 
 #if defined (HAVE_SYS_IOCTL_H)
 #include <sys/ioctl.h>
 #endif
@@ -166,17 +166,17 @@ MINGW_init (void)
 }
 #endif
 
 #if defined (_MSC_VER)
 static void
 MSVC_init (void)
 {
   w32_set_octave_home ();
-  
+
   // Init mutex to protect setjmp/longjmp and get main thread context
   w32_sigint_init ();
 
   w32_set_quiet_shutdown ();
 }
 #endif
 
 
@@ -184,35 +184,35 @@ MSVC_init (void)
 
 bool
 same_file_internal (const std::string& file1, const std::string& file2)
 {
 #ifdef OCTAVE_USE_WINDOWS_API
 
   bool retval = false;
 
-  // Windows native code 
+  // Windows native code
   // Reference: http://msdn2.microsoft.com/en-us/library/aa363788.aspx
 
   HANDLE hfile1 = CreateFile (file1.c_str (), 0, FILE_SHARE_READ, 0,
-                              OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0); 
+                              OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
 
   if (hfile1 != INVALID_HANDLE_VALUE)
     {
       HANDLE hfile2 = CreateFile (file2.c_str (), 0, FILE_SHARE_READ, 0,
                                   OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
 
       if (hfile2 != INVALID_HANDLE_VALUE)
-        {  
+        {
           BY_HANDLE_FILE_INFORMATION hfi1;
           BY_HANDLE_FILE_INFORMATION hfi2;
-  
+
           if (GetFileInformationByHandle (hfile1, &hfi1)
               && GetFileInformationByHandle (hfile2, &hfi2))
-  
+
             retval = (hfi1.dwVolumeSerialNumber == hfi2.dwVolumeSerialNumber
                       && hfi1.nFileIndexHigh == hfi2.nFileIndexHigh
                       && hfi1.nFileIndexLow == hfi2.nFileIndexLow);
 
           CloseHandle (hfile2);
         }
 
       CloseHandle (hfile1);
@@ -250,19 +250,19 @@ void
 sysdep_cleanup (void)
 {
   MINGW_SIGNAL_CLEANUP ();
 }
 
 // Set terminal in raw mode.  From less-177.
 //
 // Change terminal to "raw mode", or restore to "normal" mode.
-// "Raw mode" means 
+// "Raw mode" means
 //      1. An outstanding read will complete on receipt of a single keystroke.
-//      2. Input is not echoed.  
+//      2. Input is not echoed.
 //      3. On output, \n is mapped to \r\n.
 //      4. \t is NOT expanded into spaces.
 //      5. Signal-causing characters such as ctrl-C (interrupt),
 //         etc. are NOT disabled.
 // It doesn't matter whether an input \n is mapped to \r, or vice versa.
 
 void
 raw_mode (bool on, bool wait)
@@ -308,17 +308,17 @@ raw_mode (bool on, bool wait)
 #if defined (ONOCR)
         s.c_oflag &= ~(ONOCR);
 #endif
 #if defined (ONLRET)
         s.c_oflag &= ~(ONLRET);
 #endif
         s.c_cc[VMIN] = wait ? 1 : 0;
         s.c_cc[VTIME] = 0;
-      }      
+      }
     else
       {
         // Restore saved modes.
 
         s = save_term;
       }
 
     tcsetattr (tty_fd, wait ? TCSAFLUSH : TCSADRAIN, &s);
@@ -350,17 +350,17 @@ raw_mode (bool on, bool wait)
 #endif
 #if defined (ONOCR)
         s.c_oflag &= ~(ONOCR);
 #endif
 #if defined (ONLRET)
         s.c_oflag &= ~(ONLRET);
 #endif
         s.c_cc[VMIN] = wait ? 1 : 0;
-      }      
+      }
     else
       {
         // Restore saved modes.
 
         s = save_term;
       }
 
     ioctl (tty_fd, TCSETAW, &s);
@@ -382,17 +382,17 @@ raw_mode (bool on, bool wait)
 //      ospeed = s.sg_ospeed;
 //      erase_char = s.sg_erase;
 //      kill_char = s.sg_kill;
 
         // Set the modes to the way we want them.
 
         s.sg_flags |= CBREAK;
         s.sg_flags &= ~(ECHO);
-      } 
+      }
     else
       {
         // Restore saved modes.
 
         s = save_term;
       }
 
     ioctl (tty_fd, TIOCSETN, &s);
@@ -452,17 +452,17 @@ octave_kbhit (bool wait)
     = octave_ignore_interrupts ();
 
   // Restore it, disabling system call restarts (if possible) so the
   // read can be interrupted.
 
   octave_set_interrupt_handler (saved_interrupt_handler, false);
 
   int c = std::cin.get ();
- 
+
   if (std::cin.fail () || std::cin.eof ())
     std::cin.clear ();
 
   // Restore it, enabling system call restarts (if possible).
   octave_set_interrupt_handler (saved_interrupt_handler, true);
 
   raw_mode (false, true);
 #endif
@@ -522,22 +522,22 @@ Set the value of the environment variabl
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 2 || nargin == 1)
     {
-      std::string var = args(0).string_value (); 
+      std::string var = args(0).string_value ();
 
       if (! error_state)
         {
           std::string val = (nargin == 2
-                             ? args(1).string_value () : std::string ()); 
+                             ? args(1).string_value () : std::string ());
 
           if (! error_state)
             octave_env::putenv (var, val);
           else
             error ("putenv: second argument should be a string");
         }
       else
         error ("putenv: first argument should be a string");
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -600,17 +600,17 @@ main_loop (void)
                           // We should exit with a non-zero status.
                           retval = 1;
                           break;
                         }
                     }
                   else
                     {
                       if (octave_completion_matches_called)
-                        octave_completion_matches_called = false;           
+                        octave_completion_matches_called = false;
                       else
                         command_editor::increment_current_command_number ();
                     }
                 }
               else if (parser_end_of_input)
                 break;
             }
         }
@@ -796,17 +796,17 @@ run_command_and_return_output (const std
             output_buf.put (ch);
           else
             {
               if (! cmd->eof () && errno == EAGAIN)
                 {
                   cmd->clear ();
 
                   if (wait_for_input (fid) != 1)
-                    break;                      
+                    break;
                 }
               else
                 break;
             }
         }
 
       int cmd_status = cmd->close ();
 
@@ -934,17 +934,17 @@ command shell that is started to run the
 #endif
 
           if (type == et_async)
             {
               // FIXME -- maybe this should go in sysdep.cc?
 #ifdef HAVE_FORK
               pid_t pid = fork ();
 
-              if (pid < 0) 
+              if (pid < 0)
                 error ("system: fork failed -- can't create child process");
               else if (pid == 0)
                 {
                   // FIXME -- should probably replace this
                   // call with something portable.
 
                   execl ("/bin/sh", "sh", "-c", cmd_str.c_str (),
                          static_cast<void *> (0));
diff --git a/src/toplev.h b/src/toplev.h
--- a/src/toplev.h
+++ b/src/toplev.h
@@ -202,17 +202,17 @@ public:
   }
 
   // Function at location N on the call stack (N == 0 is current), may
   // be built-in.
   static octave_function *element (size_t n)
   {
     return instance_ok () ? instance->do_element (n) : 0;
   }
-  
+
   // First user-defined function on the stack.
   static octave_user_code *caller_user_code (size_t nskip = 0)
   {
     return instance_ok () ? instance->do_caller_user_code (nskip) : 0;
   }
 
   static void
   push (octave_function *f,
@@ -273,17 +273,17 @@ public:
 
   static octave_map empty_backtrace (void);
 
   static void pop (void)
   {
     if (instance_ok ())
       instance->do_pop ();
   }
-  
+
   static void clear (void)
   {
     if (instance_ok ())
       instance->do_clear ();
   }
 
   static void backtrace_error_message (void)
   {
@@ -339,17 +339,17 @@ private:
       {
         call_stack_elt& elt = cs[n];
         retval = elt.fcn;
       }
 
     return retval;
   }
 
-  octave_user_code *do_caller_user_code (size_t nskip) const; 
+  octave_user_code *do_caller_user_code (size_t nskip) const;
 
   void do_push (octave_function *f, symbol_table::scope_id scope,
                 symbol_table::context_id context)
   {
     size_t prev_frame = curr_frame;
     curr_frame = cs.size ();
     cs.push_back (call_stack_elt (f, scope, context, prev_frame));
     symbol_table::set_scope_and_context (scope, context);
diff --git a/src/txt-eng-ft.cc b/src/txt-eng-ft.cc
--- a/src/txt-eng-ft.cc
+++ b/src/txt-eng-ft.cc
@@ -169,17 +169,17 @@ private:
           file = "C:/WINDOWS/Fonts/verdana.ttf";
 #else
           // FIXME: find a "standard" font for UNIX platforms
 #endif
         }
 
       if (! file.empty () && FT_New_Face (library, file.c_str (), 0, &retval))
         ::warning ("ft_manager: unable to load font: %s", file.c_str ());
-      
+
       return retval;
     }
 
 private:
   FT_Library library;
 #if HAVE_FONTCONFIG
   bool fc_init_done;
 #endif
diff --git a/src/txt-eng-ft.h b/src/txt-eng-ft.h
--- a/src/txt-eng-ft.h
+++ b/src/txt-eng-ft.h
@@ -81,16 +81,16 @@ public:
 private:
   int rotation_to_mode (double rotation) const;
 
 private:
   FT_Face face;
   Matrix bbox;
   uint8NDArray pixels;
   int xoffset;
-  int yoffset;  
+  int yoffset;
   int mode;
   uint8_t red, green, blue;
 };
 
 #endif // HAVE_FREETYPE
 
 #endif
diff --git a/src/txt-eng.h b/src/txt-eng.h
--- a/src/txt-eng.h
+++ b/src/txt-eng.h
@@ -128,29 +128,29 @@ public:
   virtual void visit (text_element_list& e)
     {
       for (text_element_list::iterator it = e.begin ();
            it != e.end (); ++it)
         {
           (*it)->accept (*this);
         }
     }
-  
+
   virtual void visit (text_subscript_element& e)
     { visit (dynamic_cast<text_element_list&> (e)); }
-  
+
   virtual void visit (text_superscript_element& e)
     { visit (dynamic_cast<text_element_list&> (e)); }
 
   virtual void reset (void) { }
 
 protected:
   text_processor (void) { }
 
-  virtual ~text_processor (void) { } 
+  virtual ~text_processor (void) { }
 };
 
 #define TEXT_ELEMENT_ACCEPT(cls) \
 inline void \
 cls::accept (text_processor& p) \
 { p.visit (*this); }
 
 TEXT_ELEMENT_ACCEPT(text_element_string)
diff --git a/src/unwind-prot.h b/src/unwind-prot.h
--- a/src/unwind-prot.h
+++ b/src/unwind-prot.h
@@ -45,17 +45,17 @@ public:
   public:
     virtual void run (void) { }
     virtual ~elem (void) { }
 
     friend class unwind_protect;
   };
 
   // An element that merely runs a void (*)(void) function.
-  
+
   class fcn_elem : public elem
   {
   public:
     fcn_elem (void (*fptr) (void))
       : e_fptr (fptr) { }
 
     void run (void) { e_fptr (); }
 
@@ -201,50 +201,50 @@ public:
 
   // Protect any variable, value given.
   template <class T>
   void protect_var (T& var, const T& val)
     {
       add (new restore_var_elem<T> (var, val));
     }
 
-  operator bool (void) const 
-    { 
-      return head != 0; 
+  operator bool (void) const
+    {
+      return head != 0;
     }
 
-  void run_top (void) 
-    { 
+  void run_top (void)
+    {
       if (head)
         {
           // No leak on exception!
           std::auto_ptr<elem> ptr (head);
           head = ptr->next;
           ptr->run ();
         }
     }
 
-  void run_top (int num) 
-    { 
+  void run_top (int num)
+    {
       while (num-- > 0)
         run_top ();
     }
 
   void discard_top (void)
     {
       if (head)
         {
           elem *ptr = head;
           head = ptr->next;
           delete ptr;
         }
     }
 
-  void discard_top (int num) 
-    { 
+  void discard_top (int num)
+    {
       while (num-- > 0)
         discard_top ();
     }
 
   void run (void)
     {
       while (head)
         run_top ();
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -265,17 +265,17 @@ static string_vector
 make_absolute (const string_vector& sv)
 {
   octave_idx_type len = sv.length ();
 
   string_vector retval (len);
 
   for (octave_idx_type i = 0; i < len; i++)
     retval[i] = octave_env::make_absolute (sv[i]);
- 
+
   return retval;
 }
 
 DEFUN (file_in_loadpath, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} file_in_loadpath (@var{file})\n\
 @deftypefnx {Built-in Function} {} file_in_loadpath (@var{file}, \"all\")\n\
 \n\
@@ -405,17 +405,17 @@ file_in_path (const std::string& name, c
 // full path to the file.
 
 std::string
 fcn_file_in_path (const std::string& name)
 {
   std::string retval;
 
   int len = name.length ();
-  
+
   if (len > 0)
     {
       if (octave_env::absolute_pathname (name))
         {
           file_stat fs (name);
 
           if (fs.exists ())
             retval = name;
@@ -441,17 +441,17 @@ fcn_file_in_path (const std::string& nam
 
 std::string
 contents_file_in_path (const std::string& dir)
 {
   std::string retval;
 
   if (dir.length () > 0)
     {
-      std::string tcontents = file_ops::concat (load_path::find_dir (dir), 
+      std::string tcontents = file_ops::concat (load_path::find_dir (dir),
                                                 std::string ("Contents.m"));
 
       file_stat fs (tcontents);
 
       if (fs.exists ())
         retval = octave_env::make_absolute (tcontents);
     }
 
@@ -462,17 +462,17 @@ contents_file_in_path (const std::string
 // full path to the file.
 
 std::string
 oct_file_in_path (const std::string& name)
 {
   std::string retval;
 
   int len = name.length ();
-  
+
   if (len > 0)
     {
       if (octave_env::absolute_pathname (name))
         {
           file_stat fs (name);
 
           if (fs.exists ())
             retval = name;
@@ -491,17 +491,17 @@ oct_file_in_path (const std::string& nam
 // full path to the file.
 
 std::string
 mex_file_in_path (const std::string& name)
 {
   std::string retval;
 
   int len = name.length ();
-  
+
   if (len > 0)
     {
       if (octave_env::absolute_pathname (name))
         {
           file_stat fs (name);
 
           if (fs.exists ())
             retval = name;
@@ -776,17 +776,17 @@ Return the full name of @var{file}, rela
   if (args.length () == 1)
     {
       std::string nm = args(0).string_value ();
 
       if (! error_state)
         retval = octave_env::make_absolute (nm);
       else
         error ("make_absolute_filename: expecting argument to be a file name");
-    }      
+    }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (find_dir_in_path, args, ,
   "-*- texinfo -*-\n\
@@ -1347,17 +1347,17 @@ subsequent indexing using @var{ind} will
         }
     }
 
   return retval;
 }
 
 octave_value_list
 do_simple_cellfun (octave_value_list (*fun) (const octave_value_list&, int),
-                   const char *fun_name, const octave_value_list& args, 
+                   const char *fun_name, const octave_value_list& args,
                    int nargout)
 {
   octave_value_list new_args = args, retval;
   int nargin = args.length ();
   OCTAVE_LOCAL_BUFFER (bool, iscell, nargin);
   OCTAVE_LOCAL_BUFFER (Cell, cells, nargin);
   OCTAVE_LOCAL_BUFFER (Cell, rcells, nargout);
 
@@ -1370,25 +1370,25 @@ do_simple_cellfun (octave_value_list (*f
     {
       octave_value arg = new_args(i);
       iscell[i] = arg.is_cell ();
       if (iscell[i])
         {
           cells[i] = arg.cell_value ();
           octave_idx_type n = ccells[i].numel ();
           if (n == 1)
-            { 
+            {
               iscell[i] = false;
               new_args(i) = ccells[i](0);
             }
           else if (numel == 1)
             {
               numel = n;
               dims = ccells[i].dims ();
-            } 
+            }
           else if (dims != ccells[i].dims ())
             {
               error ("%s: cell arguments must have matching sizes", fun_name);
               break;
             }
         }
     }
 
diff --git a/src/utils.h b/src/utils.h
--- a/src/utils.h
+++ b/src/utils.h
@@ -118,17 +118,17 @@ extern OCTINTERP_API char *octave_vsnpri
 
 extern OCTINTERP_API char *octave_snprintf (const char *fmt, ...);
 
 extern OCTINTERP_API void octave_sleep (double seconds);
 
 extern OCTINTERP_API
 octave_value_list
 do_simple_cellfun (octave_value_list (*fun) (const octave_value_list&, int),
-                   const char *fun_name, const octave_value_list& args, 
+                   const char *fun_name, const octave_value_list& args,
                    int nargout);
 
 extern OCTINTERP_API
 octave_value
 do_simple_cellfun (octave_value_list (*fun) (const octave_value_list&, int),
                    const char *fun_name, const octave_value_list& args);
 
 #endif
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -159,17 +159,17 @@ extract_function (const octave_value& ar
         {
           int parse_status;
 
           eval_string (cmd, true, parse_status, 0);
 
           if (parse_status == 0)
             {
               retval = is_valid_function (fname, warn_for, 0);
-      
+
               if (! retval)
                 {
                   error ("%s: `%s' is not valid as a function",
                          warn_for.c_str (), fname.c_str ());
                   return retval;
                 }
 
               warning ("%s: passing function body as a string is obsolete."
@@ -966,17 +966,17 @@ print_descriptor (std::ostream& os, std:
             default:
               os << std::setiosflags (std::ios::left) << std::setw (param.parameter_length);
               param_buf << std::setiosflags (std::ios::left) << std::setw (param.parameter_length);
             }
 
           if (param.command == 's' && param.modifier == 'c')
             {
               int a, b;
-             
+
               if (param.modifier == 'c')
                 {
                   a = param.first_parameter_length - param.balance;
                   a = (a < 0 ? 0 : a);
                   b = param.parameter_length - a - param.text . length ();
                   b = (b < 0 ? 0 : b);
                   os << std::setiosflags (std::ios::left) << std::setw (a)
                      << "" << std::resetiosflags (std::ios::left) << param.text
@@ -1147,17 +1147,17 @@ private:
                 case 's':
                   if (param.modifier != 'c')
                     os << dims_str;
                   break;
 
                 case 't':
                   os << varval.type_name ();
                   break;
-            
+
                 default:
                   error ("whos_line_format: command `%c' unknown",
                          param.command);
                 }
 
               os << std::resetiosflags (std::ios::left)
                  << std::resetiosflags (std::ios::right);
               i++;
@@ -1534,21 +1534,21 @@ do_who (int argc, const string_vector& a
   bool global_only = false;
   bool have_regexp = false;
 
   int i;
   for (i = 1; i < argc; i++)
     {
       if (argv[i] == "-file")
         {
-          // FIXME. This is an inefficient manner to implement this as the 
+          // FIXME. This is an inefficient manner to implement this as the
           // variables are loaded in to a temporary context and then treated.
           // It would be better to refecat symbol_info_list to not store the
           // symbol records and then use it in load-save.cc (do_load) to
-          // implement this option there so that the variables are never 
+          // implement this option there so that the variables are never
           // stored at all.
           if (i == argc - 1)
             error ("whos: -file argument must be followed by a file name");
           else
             {
               std::string nm = argv [i + 1];
 
               unwind_protect frame;
@@ -1564,17 +1564,17 @@ do_who (int argc, const string_vector& a
               frame.add_fcn (octave_call_stack::pop);
 
               frame.add_fcn (symbol_table::clear_variables);
 
               feval ("load", octave_value (nm), 0);
 
               if (! error_state)
                 {
-                  std::string newmsg = std::string ("Variables in the file ") + 
+                  std::string newmsg = std::string ("Variables in the file ") +
                     nm + ":\n\n";
 
                   retval =  do_who (i, argv, return_list, verbose, newmsg);
                 }
             }
 
           return retval;
         }
@@ -1597,17 +1597,17 @@ do_who (int argc, const string_vector& a
       for (int j = 0; j < npats; j++)
         pats[j] = argv[i+j];
     }
   else
     {
       pats.resize (++npats);
       pats[0] = "*";
     }
-    
+
   symbol_info_list symbol_stats;
   std::list<std::string> symbol_names;
 
   for (int j = 0; j < npats; j++)
     {
       std::string pat = pats[j];
 
       if (have_regexp)
@@ -1880,28 +1880,28 @@ bind_internal_variable (const std::strin
 {
   octave_value_list args;
 
   args(0) = val;
 
   feval (fname, args, 0);
 }
 
-void 
+void
 mlock (void)
 {
   octave_function *fcn = octave_call_stack::current ();
 
   if (fcn)
     fcn->lock ();
   else
     error ("mlock: invalid use outside a function");
 }
 
-void 
+void
 munlock (const std::string& nm)
 {
   octave_value val = symbol_table::find_function (nm);
 
   if (val.is_defined ())
     {
       octave_function *fcn = val.function_value ();
 
@@ -2019,17 +2019,17 @@ then return true if the current function
     print_usage ();
 
   return retval;
 }
 
 // Deleting names from the symbol tables.
 
 static inline bool
-name_matches_any_pattern (const std::string& nm, const string_vector& argv, 
+name_matches_any_pattern (const std::string& nm, const string_vector& argv,
                           int argc, int idx, bool have_regexp = false)
 {
   bool retval = false;
 
   for (int k = idx; k < argc; k++)
     {
       std::string patstr = argv[k];
       if (! patstr.empty ())
@@ -2320,17 +2320,17 @@ without the dash as well.\n\
 
   string_vector argv = args.make_argv ("clear");
 
   if (! error_state)
     {
       if (argc == 1)
         {
           do_clear_globals (argv, argc, 1);
-          do_clear_variables (argv, argc, 1); 
+          do_clear_variables (argv, argc, 1);
         }
       else
         {
           int idx = 0;
 
           bool clear_all = false;
           bool clear_functions = false;
           bool clear_globals = false;
diff --git a/src/variables.h b/src/variables.h
--- a/src/variables.h
+++ b/src/variables.h
@@ -40,21 +40,21 @@ class string_vector;
 #include "ov.h"
 #include "ov-builtin.h"
 #include "symtab.h"
 
 extern OCTINTERP_API void clear_mex_functions (void);
 
 extern OCTINTERP_API octave_function *
 is_valid_function (const octave_value&, const std::string& = std::string (),
-                   bool warn = false); 
+                   bool warn = false);
 
 extern OCTINTERP_API octave_function *
 is_valid_function (const std::string&, const std::string& = std::string (),
-                   bool warn = false); 
+                   bool warn = false);
 
 extern OCTINTERP_API octave_function *
 extract_function (const octave_value& arg, const std::string& warn_for,
                   const std::string& fname, const std::string& header,
                   const std::string& trailer);
 
 extern OCTINTERP_API string_vector
 get_struct_elts (const std::string& text);
diff --git a/src/xdiv.cc b/src/xdiv.cc
--- a/src/xdiv.cc
+++ b/src/xdiv.cc
@@ -130,69 +130,69 @@ Matrix
 xdiv (const Matrix& a, const Matrix& b, MatrixType &typ)
 {
   if (! mx_div_conform (a, b))
     return Matrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
 
-  Matrix result 
-    = b.solve (typ, a.transpose (), info, rcond, 
+  Matrix result
+    = b.solve (typ, a.transpose (), info, rcond,
                solve_singularity_warning, true, blas_trans);
 
   return result.transpose ();
 }
 
 // -*- 2 -*-
 ComplexMatrix
 xdiv (const Matrix& a, const ComplexMatrix& b, MatrixType &typ)
 {
   if (! mx_div_conform (a, b))
     return ComplexMatrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
 
   ComplexMatrix result
-    = b.solve (typ, a.transpose (), info, rcond, 
+    = b.solve (typ, a.transpose (), info, rcond,
                solve_singularity_warning, true, blas_trans);
 
   return result.transpose ();
 }
 
 // -*- 3 -*-
 ComplexMatrix
 xdiv (const ComplexMatrix& a, const Matrix& b, MatrixType &typ)
 {
   if (! mx_div_conform (a, b))
     return ComplexMatrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
 
   ComplexMatrix result
-    = b.solve (typ, a.transpose (), info, rcond, 
+    = b.solve (typ, a.transpose (), info, rcond,
                solve_singularity_warning, true, blas_trans);
 
   return result.transpose ();
 }
 
 // -*- 4 -*-
 ComplexMatrix
 xdiv (const ComplexMatrix& a, const ComplexMatrix& b, MatrixType &typ)
 {
   if (! mx_div_conform (a, b))
     return ComplexMatrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
 
   ComplexMatrix result
-    = b.solve (typ, a.transpose (), info, rcond, 
+    = b.solve (typ, a.transpose (), info, rcond,
                solve_singularity_warning, true, blas_trans);
 
   return result.transpose ();
 }
 
 // Funny element by element division operations.
 //
 //       op2 \ op1:   s   cs
@@ -428,69 +428,69 @@ FloatMatrix
 xdiv (const FloatMatrix& a, const FloatMatrix& b, MatrixType &typ)
 {
   if (! mx_div_conform (a, b))
     return FloatMatrix ();
 
   octave_idx_type info;
   float rcond = 0.0;
 
-  FloatMatrix result 
-    = b.solve (typ, a.transpose (), info, rcond, 
+  FloatMatrix result
+    = b.solve (typ, a.transpose (), info, rcond,
                solve_singularity_warning, true, blas_trans);
 
   return result.transpose ();
 }
 
 // -*- 2 -*-
 FloatComplexMatrix
 xdiv (const FloatMatrix& a, const FloatComplexMatrix& b, MatrixType &typ)
 {
   if (! mx_div_conform (a, b))
     return FloatComplexMatrix ();
 
   octave_idx_type info;
   float rcond = 0.0;
 
-  FloatComplexMatrix result 
-    = b.solve (typ, a.transpose (), info, rcond, 
+  FloatComplexMatrix result
+    = b.solve (typ, a.transpose (), info, rcond,
                solve_singularity_warning, true, blas_trans);
 
   return result.transpose ();
 }
 
 // -*- 3 -*-
 FloatComplexMatrix
 xdiv (const FloatComplexMatrix& a, const FloatMatrix& b, MatrixType &typ)
 {
   if (! mx_div_conform (a, b))
     return FloatComplexMatrix ();
 
   octave_idx_type info;
   float rcond = 0.0;
 
-  FloatComplexMatrix result 
-    = b.solve (typ, a.transpose (), info, rcond, 
+  FloatComplexMatrix result
+    = b.solve (typ, a.transpose (), info, rcond,
                solve_singularity_warning, true, blas_trans);
 
   return result.transpose ();
 }
 
 // -*- 4 -*-
 FloatComplexMatrix
 xdiv (const FloatComplexMatrix& a, const FloatComplexMatrix& b, MatrixType &typ)
 {
   if (! mx_div_conform (a, b))
     return FloatComplexMatrix ();
 
   octave_idx_type info;
   float rcond = 0.0;
 
-  FloatComplexMatrix result 
-    = b.solve (typ, a.transpose (), info, rcond, 
+  FloatComplexMatrix result
+    = b.solve (typ, a.transpose (), info, rcond,
                solve_singularity_warning, true, blas_trans);
 
   return result.transpose ();
 }
 
 // Funny element by element division operations.
 //
 //       op2 \ op1:   s   cs
diff --git a/src/xdiv.h b/src/xdiv.h
--- a/src/xdiv.h
+++ b/src/xdiv.h
@@ -67,17 +67,17 @@ extern FloatComplexMatrix x_el_div (floa
 extern FloatComplexMatrix x_el_div (const FloatComplex a, const FloatMatrix& b);
 extern FloatComplexMatrix x_el_div (const FloatComplex a, const FloatComplexMatrix& b);
 
 extern FloatNDArray x_el_div (float a, const FloatNDArray& b);
 extern FloatComplexNDArray x_el_div (float a, const FloatComplexNDArray& b);
 extern FloatComplexNDArray x_el_div (const FloatComplex a, const FloatNDArray& b);
 extern FloatComplexNDArray x_el_div (const FloatComplex a, const FloatComplexNDArray& b);
 
-extern FloatMatrix xleftdiv (const FloatMatrix& a, const FloatMatrix& b, MatrixType &typ, 
+extern FloatMatrix xleftdiv (const FloatMatrix& a, const FloatMatrix& b, MatrixType &typ,
                              blas_trans_type transt = blas_no_trans);
 extern FloatComplexMatrix xleftdiv (const FloatMatrix& a, const FloatComplexMatrix& b,
                                MatrixType &typ, blas_trans_type transt = blas_no_trans);
 extern FloatComplexMatrix xleftdiv (const FloatComplexMatrix& a, const FloatMatrix& b,
                                MatrixType &typ, blas_trans_type transt = blas_no_trans);
 extern FloatComplexMatrix xleftdiv (const FloatComplexMatrix& a, const FloatComplexMatrix& b,
                                MatrixType &typ, blas_trans_type transt = blas_no_trans);
 
@@ -86,44 +86,44 @@ extern Matrix xdiv (const Matrix& a, con
 extern ComplexMatrix xdiv (const ComplexMatrix& a, const DiagMatrix& b);
 extern ComplexMatrix xdiv (const ComplexMatrix& a, const ComplexDiagMatrix& b);
 
 extern DiagMatrix xdiv (const DiagMatrix& a, const DiagMatrix& b);
 extern ComplexDiagMatrix xdiv (const ComplexDiagMatrix& a, const DiagMatrix& b);
 extern ComplexDiagMatrix xdiv (const ComplexDiagMatrix& a, const ComplexDiagMatrix& b);
 
 extern FloatMatrix xdiv (const FloatMatrix& a, const FloatDiagMatrix& b);
-extern FloatComplexMatrix xdiv (const FloatComplexMatrix& a, 
-                                const FloatDiagMatrix& b); 
-extern FloatComplexMatrix xdiv (const FloatMatrix& a, 
-                                const FloatComplexDiagMatrix& b); 
-extern FloatComplexMatrix xdiv (const FloatComplexMatrix& a, 
+extern FloatComplexMatrix xdiv (const FloatComplexMatrix& a,
+                                const FloatDiagMatrix& b);
+extern FloatComplexMatrix xdiv (const FloatMatrix& a,
+                                const FloatComplexDiagMatrix& b);
+extern FloatComplexMatrix xdiv (const FloatComplexMatrix& a,
                                 const FloatComplexDiagMatrix& b);
 
 extern FloatDiagMatrix xdiv (const FloatDiagMatrix& a, const FloatDiagMatrix& b);
-extern FloatComplexDiagMatrix xdiv (const FloatComplexDiagMatrix& a, 
+extern FloatComplexDiagMatrix xdiv (const FloatComplexDiagMatrix& a,
                                     const FloatDiagMatrix& b);
-extern FloatComplexDiagMatrix xdiv (const FloatComplexDiagMatrix& a, 
+extern FloatComplexDiagMatrix xdiv (const FloatComplexDiagMatrix& a,
                                     const FloatComplexDiagMatrix& b);
 
 extern Matrix xleftdiv (const DiagMatrix& a, const Matrix& b);
 extern ComplexMatrix xleftdiv (const DiagMatrix& a, const ComplexMatrix& b);
 extern ComplexMatrix xleftdiv (const ComplexDiagMatrix& a, const ComplexMatrix& b);
 
 extern DiagMatrix xleftdiv (const DiagMatrix& a, const DiagMatrix& b);
 extern ComplexDiagMatrix xleftdiv (const DiagMatrix& a, const ComplexDiagMatrix& b);
 extern ComplexDiagMatrix xleftdiv (const ComplexDiagMatrix& a, const ComplexDiagMatrix& b);
 
-extern FloatMatrix xleftdiv (const FloatDiagMatrix& a, 
+extern FloatMatrix xleftdiv (const FloatDiagMatrix& a,
                              const FloatMatrix& b);
-extern FloatComplexMatrix xleftdiv (const FloatDiagMatrix& a, 
+extern FloatComplexMatrix xleftdiv (const FloatDiagMatrix& a,
                                     const FloatComplexMatrix& b);
-extern FloatComplexMatrix xleftdiv (const FloatComplexDiagMatrix& a, 
+extern FloatComplexMatrix xleftdiv (const FloatComplexDiagMatrix& a,
                                     const FloatComplexMatrix& b);
 
-extern FloatDiagMatrix xleftdiv (const FloatDiagMatrix& a, 
+extern FloatDiagMatrix xleftdiv (const FloatDiagMatrix& a,
                                  const FloatDiagMatrix& b);
-extern FloatComplexDiagMatrix xleftdiv (const FloatDiagMatrix& a, 
+extern FloatComplexDiagMatrix xleftdiv (const FloatDiagMatrix& a,
                                         const FloatComplexDiagMatrix& b);
-extern FloatComplexDiagMatrix xleftdiv (const FloatComplexDiagMatrix& a, 
+extern FloatComplexDiagMatrix xleftdiv (const FloatComplexDiagMatrix& a,
                                         const FloatComplexDiagMatrix& b);
 
 #endif
diff --git a/src/xnorm.cc b/src/xnorm.cc
--- a/src/xnorm.cc
+++ b/src/xnorm.cc
@@ -54,41 +54,41 @@ octave_value xnorm (const octave_value& 
             retval = xnorm (x.float_complex_column_vector_value (),
                             p.float_value ());
           else if (isfloat)
             retval = xnorm (x.float_column_vector_value (),
                             p.float_value ());
           else if (iscomplex)
             retval = xnorm (x.complex_column_vector_value (),
                             p.double_value ());
-          else 
+          else
             retval = xnorm (x.column_vector_value (),
                             p.double_value ());
         }
       else if (issparse)
         {
           if (iscomplex)
             retval = xnorm (x.sparse_complex_matrix_value (),
                             p.double_value ());
-          else 
+          else
             retval = xnorm (x.sparse_matrix_value (),
                             p.double_value ());
         }
       else
         {
           if (isfloat & iscomplex)
             retval = xnorm (x.float_complex_matrix_value (),
                             p.float_value ());
           else if (isfloat)
             retval = xnorm (x.float_matrix_value (),
                             p.float_value ());
           else if (iscomplex)
             retval = xnorm (x.complex_matrix_value (),
                             p.double_value ());
-          else 
+          else
             retval = xnorm (x.matrix_value (),
                             p.double_value ());
         }
     }
   else
     gripe_wrong_type_arg ("xnorm", x, true);
 
   return retval;
@@ -104,32 +104,32 @@ octave_value xcolnorms (const octave_val
 
   if (isfloat || x.is_double_type ())
     {
       if (issparse)
         {
           if (iscomplex)
             retval = xcolnorms (x.sparse_complex_matrix_value (),
                                 p.double_value ());
-          else 
+          else
             retval = xcolnorms (x.sparse_matrix_value (),
                                 p.double_value ());
         }
       else
         {
           if (isfloat & iscomplex)
             retval = xcolnorms (x.float_complex_matrix_value (),
                                 p.float_value ());
           else if (isfloat)
             retval = xcolnorms (x.float_matrix_value (),
                                 p.float_value ());
           else if (iscomplex)
             retval = xcolnorms (x.complex_matrix_value (),
                                 p.double_value ());
-          else 
+          else
             retval = xcolnorms (x.matrix_value (),
                                 p.double_value ());
         }
     }
   else
     gripe_wrong_type_arg ("xcolnorms", x, true);
 
   return retval;
@@ -145,32 +145,32 @@ octave_value xrownorms (const octave_val
 
   if (isfloat || x.is_double_type ())
     {
       if (issparse)
         {
           if (iscomplex)
             retval = xrownorms (x.sparse_complex_matrix_value (),
                                 p.double_value ());
-          else 
+          else
             retval = xrownorms (x.sparse_matrix_value (),
                                 p.double_value ());
         }
       else
         {
           if (isfloat & iscomplex)
             retval = xrownorms (x.float_complex_matrix_value (),
                                 p.float_value ());
           else if (isfloat)
             retval = xrownorms (x.float_matrix_value (),
                                 p.float_value ());
           else if (iscomplex)
             retval = xrownorms (x.complex_matrix_value (),
                                 p.double_value ());
-          else 
+          else
             retval = xrownorms (x.matrix_value (),
                                 p.double_value ());
         }
     }
   else
     gripe_wrong_type_arg ("xrownorms", x, true);
 
   return retval;
@@ -185,28 +185,28 @@ octave_value xfrobnorm (const octave_val
   bool isfloat = x.is_single_type ();
 
   if (isfloat || x.is_double_type ())
     {
       if (issparse)
         {
           if (iscomplex)
             retval = xfrobnorm (x.sparse_complex_matrix_value ());
-          else 
+          else
             retval = xfrobnorm (x.sparse_matrix_value ());
         }
       else
         {
           if (isfloat & iscomplex)
             retval = xfrobnorm (x.float_complex_matrix_value ());
           else if (isfloat)
             retval = xfrobnorm (x.float_matrix_value ());
           else if (iscomplex)
             retval = xfrobnorm (x.complex_matrix_value ());
-          else 
+          else
             retval = xfrobnorm (x.matrix_value ());
         }
     }
   else
     gripe_wrong_type_arg ("xfrobnorm", x, true);
 
   return retval;
 }
diff --git a/src/xpow.cc b/src/xpow.cc
--- a/src/xpow.cc
+++ b/src/xpow.cc
@@ -689,17 +689,17 @@ elem_xpow (double a, const ComplexMatrix
       {
         octave_quit ();
         result (i, j) = std::pow (atmp, b (i, j));
       }
 
   return result;
 }
 
-static inline bool 
+static inline bool
 same_sign (double a, double b)
 {
   return (a >= 0 && b >= 0) || (a <= 0 && b <= 0);
 }
 
 octave_value
 elem_xpow (double a, const Range& r)
 {
@@ -726,17 +726,17 @@ elem_xpow (double a, const Range& r)
           double limit = std::pow (a, r.base () + (n-1) * r.inc ());
           double inc = std::pow (a, -r.inc ());
           result(n-1) = limit;
           for (octave_idx_type i = n-2; i >= 0; i--)
             result(i) = (limit *= inc);
         }
 
       retval = result;
-    }  
+    }
   else
     retval = elem_xpow (a, r.matrix_value ());
 
   return retval;
 }
 
 // -*- 3 -*-
 octave_value
@@ -749,18 +749,18 @@ elem_xpow (const Matrix& a, double b)
 
   if (! xisint (b) && a.any_element_is_negative ())
     {
       ComplexMatrix result (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = 0; i < nr; i++)
           {
-            octave_quit (); 
-      
+            octave_quit ();
+
             Complex atmp (a (i, j));
 
             result (i, j) = std::pow (atmp, b);
           }
 
       retval = result;
     }
   else
@@ -962,17 +962,17 @@ elem_xpow (const Complex& a, const Range
           Complex limit = std::pow (a, r.base () + (n-1) * r.inc ());
           Complex inc = std::pow (a, -r.inc ());
           result(n-1) = limit;
           for (octave_idx_type i = n-2; i >= 0; i--)
             result(i) = (limit *= inc);
         }
 
       retval = result;
-    }  
+    }
   else
     retval = elem_xpow (a, r.matrix_value ());
 
 
   return retval;
 }
 
 // -*- 9 -*-
@@ -2108,18 +2108,18 @@ elem_xpow (const FloatMatrix& a, float b
 
   if (! xisint (b) && a.any_element_is_negative ())
     {
       FloatComplexMatrix result (nr, nc);
 
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = 0; i < nr; i++)
           {
-            octave_quit (); 
-      
+            octave_quit ();
+
             FloatComplex atmp (a (i, j));
 
             result (i, j) = std::pow (atmp, b);
           }
 
       retval = result;
     }
   else
diff --git a/src/zfstream.cc b/src/zfstream.cc
--- a/src/zfstream.cc
+++ b/src/zfstream.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 Ludwig Schwardt, Kevin Ruland 
+Copyright (C) 2005-2011 Ludwig Schwardt, Kevin Ruland
 
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -41,17 +41,17 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_ZLIB
 
 #include <cstring>          // for strcpy, strcat, strlen (mode strings)
 #include <cstdio>           // for BUFSIZ
 
 // Internal buffer sizes (default and "unbuffered" versions)
 #define STASHED_CHARACTERS 16
-#define BIGBUFSIZE (256 * 1024 + STASHED_CHARACTERS) 
+#define BIGBUFSIZE (256 * 1024 + STASHED_CHARACTERS)
 #define SMALLBUFSIZE 1
 
 /*****************************************************************************/
 
 // Default constructor
 gzfilebuf::gzfilebuf()
 : file(0), io_mode(std::ios_base::openmode(0)), own_fd(false),
   buffer(0), buffer_size(BIGBUFSIZE), own_buffer(true)
@@ -211,26 +211,26 @@ gzfilebuf::showmanyc()
   if (this->gptr() && (this->gptr() < this->egptr()))
     return std::streamsize(this->egptr() - this->gptr());
   else
     return 0;
 }
 
 // Puts back a character to the stream in two cases. Firstly, when there
 // is no putback position available, and secondly when the character putback
-// differs from the one in the file. We can only support the first case 
+// differs from the one in the file. We can only support the first case
 // with gzipped files.
 gzfilebuf::int_type
 gzfilebuf::pbackfail (gzfilebuf::int_type c)
 {
   if (this->is_open())
     {
       if (gzseek (file, this->gptr() - this->egptr() - 1, SEEK_CUR) < 0)
         return traits_type::eof();
-  
+
       // Invalidates contents of the buffer
       enable_buffer ();
 
       // Attempt to fill internal buffer from gzipped file
       // (buffer must be guaranteed to exist...)
       int bytes_read = gzread(file, buffer, buffer_size);
       // Indicates error or EOF
       if (bytes_read <= 0)
@@ -456,17 +456,17 @@ gzfilebuf::disable_buffer()
       this->setp(0, 0);
   }
 }
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
 // Seek functions
 gzfilebuf::pos_type
-gzfilebuf::seekoff(off_type off, std::ios_base::seekdir way, 
+gzfilebuf::seekoff(off_type off, std::ios_base::seekdir way,
                    std::ios_base::openmode)
 {
   pos_type ret = pos_type (off_type (-1));
 
   if (this->is_open())
     {
       off_type computed_off = off;
 
@@ -475,17 +475,17 @@ gzfilebuf::seekoff(off_type off, std::io
 
       if (way == std::ios_base::beg)
         ret = pos_type (gzseek (file, computed_off, SEEK_SET));
       else if (way == std::ios_base::cur)
         ret = pos_type (gzseek (file, computed_off, SEEK_CUR));
       else
         // Can't seek from end of a gzipped file, so this will give -1
         ret = pos_type (gzseek (file, computed_off, SEEK_END));
-  
+
       if (io_mode & std::ios_base::in)
         // Invalidates contents of the buffer
         enable_buffer ();
       else
         // flush contents of buffer to file
         overflow ();
     }
 
diff --git a/src/zfstream.h b/src/zfstream.h
--- a/src/zfstream.h
+++ b/src/zfstream.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005-2011 Ludwig Schwardt, Kevin Ruland 
+Copyright (C) 2005-2011 Ludwig Schwardt, Kevin Ruland
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -172,26 +172,26 @@ protected:
 
   /**
    *  @brief  Alters the stream positions.
    *
    *  Each derived class provides its own appropriate behavior.
    */
   virtual pos_type
   seekoff(off_type off, std::ios_base::seekdir way,
-          std::ios_base::openmode mode = 
+          std::ios_base::openmode mode =
           std::ios_base::in|std::ios_base::out);
 
   /**
    *  @brief  Alters the stream positions.
    *
    *  Each derived class provides its own appropriate behavior.
    */
   virtual pos_type
-  seekpos(pos_type sp, std::ios_base::openmode mode = 
+  seekpos(pos_type sp, std::ios_base::openmode mode =
           std::ios_base::in|std::ios_base::out);
 
   virtual int_type
   pbackfail (int_type c = traits_type::eof());
 
 //
 // Some future enhancements
 //
