# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1463499173 14400
#      Tue May 17 11:32:53 2016 -0400
# Node ID bae585228161375dd5e453ad3be55f3f0ba251e6
# Parent  fb5dd9f7d69722f22753978baaae52b1b6c35310
use namespace for numeric_limits

* lo-ieee.h (octave_numeric_limits): Rename to numeric_limits and
define inside octave namespace.

* Canvas.cc, data.cc, graphics.cc, graphics.in.h, oct-handle.h,
oct-stream.cc, quadcc.cc, sparse-xdiv.cc, str2double.cc, variables.h,
__glpk__.cc, __init_fltk__.cc, __voronoi__.cc, octave.cc, CMatrix.cc,
CNDArray.cc, CSparse.cc, Sparse-C.cc, dDiagMatrix.cc, dMatrix.cc,
dSparse.cc, fCMatrix.cc, fCNDArray.cc, fDiagMatrix.cc, fMatrix.cc,
Faddeeva.cc, eigs-base.cc, lo-mappers.cc, lo-mappers.h, lo-specfun.cc,
oct-norm.cc, oct-rand.cc, oct-rand.h, oct-spparms.cc, randgamma.cc,
randpoisson.cc, lo-utils.cc: Change all uses of octave_numeric_limits
to octave::numeric_limits.

diff --git a/libgui/graphics/Canvas.cc b/libgui/graphics/Canvas.cc
--- a/libgui/graphics/Canvas.cc
+++ b/libgui/graphics/Canvas.cc
@@ -610,17 +610,17 @@ Canvas::canvasMousePressEvent (QMouseEve
 
       if (! currentObj)
         currentObj = obj;
 
       if (currentObj.get_properties ().handlevisibility_is ("on"))
         Utils::properties<figure> (figObj)
           .set_currentobject (currentObj.get_handle ().as_octave_value ());
       else
-        Utils::properties<figure> (figObj).set_currentobject (octave_numeric_limits<double>::NaN ());
+        Utils::properties<figure> (figObj).set_currentobject (octave::numeric_limits<double>::NaN ());
 
       Figure* fig = dynamic_cast<Figure*> (Backend::toolkitObject (figObj));
 
       MouseMode newMouseMode = NoMode;
 
       if (fig)
         newMouseMode = fig->mouseMode ();
 
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -5664,17 +5664,17 @@ compute the norms of each column and ret
         error ("norm: invalid combination of options");
 
       if (str == "cols" || str == "columns" || str == "rows")
         error ("norm: invalid combination of options");
 
       if (str == "fro")
         p_arg = octave_value (2);
       else if (str == "inf")
-        p_arg = octave_numeric_limits<double>::Inf ();
+        p_arg = octave::numeric_limits<double>::Inf ();
       else
         error ("norm: unrecognized option: %s", str.c_str ());
     }
   else if (! p_arg.is_scalar_type ())
     err_wrong_type_arg ("norm", p_arg);
 
   octave_value retval;
 
@@ -5692,17 +5692,17 @@ compute the norms of each column and ret
       retval = xrownorms (x_arg, p_arg);
       break;
 
     case sffrob:
       retval = xfrobnorm (x_arg);
       break;
 
     case sfinf:
-      retval = xnorm (x_arg, octave_numeric_limits<double>::Inf ());
+      retval = xnorm (x_arg, octave::numeric_limits<double>::Inf ());
       break;
     }
 
   return retval;
 }
 
 /*
 %!shared x
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -1498,18 +1498,18 @@ array_property::is_equal (const octave_v
     }
 
   return false;
 }
 
 void
 array_property::get_data_limits (void)
 {
-  xmin = xminp = octave_numeric_limits<double>::Inf ();
-  xmax = xmaxp = -octave_numeric_limits<double>::Inf ();
+  xmin = xminp = octave::numeric_limits<double>::Inf ();
+  xmax = xmaxp = -octave::numeric_limits<double>::Inf ();
 
   if (! data.is_empty ())
     {
       if (data.is_integer_type ())
         {
           if (data.is_int8_type ())
             get_array_limits (data.int8_array_value (),
                               xmin, xmax, xminp, xmaxp);
@@ -1717,17 +1717,17 @@ property::create (const std::string& nam
   else if (type.compare ("double"))
     {
       double dv = (args.length () > 0 ? args(0).double_value () : 0.0);
 
       retval = property (new double_property (name, h, dv));
     }
   else if (type.compare ("handle"))
     {
-      double hv = (args.length () > 0 ? args(0).double_value () : octave_numeric_limits<double>::NaN ());
+      double hv = (args.length () > 0 ? args(0).double_value () : octave::numeric_limits<double>::NaN ());
 
       graphics_handle gh (hv);
 
       retval = property (new handle_property (name, h, gh));
     }
   else if (type.compare ("boolean"))
     {
       retval = property (new bool_property (name, h, false));
@@ -2574,17 +2574,17 @@ xget (const graphics_handle& h, const ca
   return go.get (pname);
 }
 
 static graphics_handle
 reparent (const octave_value& ov, const std::string& who,
           const std::string& pname, const graphics_handle& new_parent,
           bool adopt = true)
 {
-  graphics_handle h = octave_numeric_limits<double>::NaN ();
+  graphics_handle h = octave::numeric_limits<double>::NaN ();
 
   double hv = ov.xdouble_value ("%s: %s must be a graphics handle",
                                who.c_str (), pname.c_str ());
 
   h = gh_manager::lookup (hv);
 
   if (! h.ok ())
     error ("%s: invalid graphics handle (= %g) for %s",
@@ -2607,26 +2607,26 @@ reparent (const octave_value& ov, const 
 }
 
 // This function is NOT equivalent to the scripting language function gcf.
 graphics_handle
 gcf (void)
 {
   octave_value val = xget (0, "currentfigure");
 
-  return val.is_empty () ? octave_numeric_limits<double>::NaN () : val.double_value ();
+  return val.is_empty () ? octave::numeric_limits<double>::NaN () : val.double_value ();
 }
 
 // This function is NOT equivalent to the scripting language function gca.
 graphics_handle
 gca (void)
 {
   octave_value val = xget (gcf (), "currentaxes");
 
-  return val.is_empty () ? octave_numeric_limits<double>::NaN () : val.double_value ();
+  return val.is_empty () ? octave::numeric_limits<double>::NaN () : val.double_value ();
 }
 
 static void
 delete_graphics_object (const graphics_handle& h)
 {
   if (h.ok ())
     {
       graphics_object go = gh_manager::get_object (h);
@@ -2992,17 +2992,17 @@ base_properties::get_property_dynamic (c
   return it->second;
 }
 
 void
 base_properties::set_parent (const octave_value& val)
 {
   double hp = val.xdouble_value ("set: parent must be a graphics handle");
 
-  graphics_handle new_parent = octave_numeric_limits<double>::NaN ();
+  graphics_handle new_parent = octave::numeric_limits<double>::NaN ();
 
   if (hp == __myhandle__)
     error ("set: can not set object parent to be object itself");
 
   new_parent = gh_manager::lookup (hp);
 
   if (! new_parent.ok ())
     error ("set: invalid graphics handle (= %g) for parent", hp);
@@ -6050,20 +6050,20 @@ normalized_aspectratios (Matrix& aspectr
 }
 
 static void
 max_axes_scale (double& s, Matrix& limits, const Matrix& kids,
                 double pbfactor, double dafactor, char limit_type, bool tight)
 {
   if (tight)
     {
-      double minval = octave_numeric_limits<double>::Inf ();
-      double maxval = -octave_numeric_limits<double>::Inf ();
-      double min_pos = octave_numeric_limits<double>::Inf ();
-      double max_neg = -octave_numeric_limits<double>::Inf ();
+      double minval = octave::numeric_limits<double>::Inf ();
+      double maxval = -octave::numeric_limits<double>::Inf ();
+      double min_pos = octave::numeric_limits<double>::Inf ();
+      double max_neg = -octave::numeric_limits<double>::Inf ();
       get_children_limits (minval, maxval, min_pos, max_neg, kids, limit_type);
       if (xfinite (minval) && xfinite (maxval))
         {
           limits(0) = minval;
           limits(1) = maxval;
           s = xmax (s, (maxval - minval) / (pbfactor * dafactor));
         }
     }
@@ -6104,17 +6104,17 @@ axes::properties::update_aspectratios (v
     }
   else if (plotboxaspectratiomode_is ("auto"))
     {
       normalized_aspectratios (pba, da, dx, dy, dz);
       plotboxaspectratio.set (pba, false);
     }
   else
     {
-      double s = -octave_numeric_limits<double>::Inf ();
+      double s = -octave::numeric_limits<double>::Inf ();
       bool modified_limits = false;
       Matrix kids;
 
       if (xlimmode_is ("auto") && ylimmode_is ("auto") && zlimmode_is ("auto"))
         {
           modified_limits = true;
           kids = get_children ();
           max_axes_scale (s, xlimits, kids, pba(0), da(0), 'x', true);
@@ -6225,18 +6225,18 @@ axes::properties::get_boundingbox (bool 
 }
 
 Matrix
 axes::properties::get_extent (bool with_text, bool only_text_height) const
 {
   graphics_xform xform = get_transform ();
 
   Matrix ext (1, 4, 0.0);
-  ext(0) = ext(1) = octave_numeric_limits<double>::Inf ();
-  ext(2) = ext(3) = -octave_numeric_limits<double>::Inf ();
+  ext(0) = ext(1) = octave::numeric_limits<double>::Inf ();
+  ext(2) = ext(3) = -octave::numeric_limits<double>::Inf ();
   for (int i = 0; i <= 1; i++)
     for (int j = 0; j <= 1; j++)
       for (int k = 0; k <= 1; k++)
         {
           ColumnVector p = xform.transform (i ? xPlaneN : xPlane,
                                             j ? yPlaneN : yPlane,
                                             k ? zPlaneN : zPlane, false);
           ext(0) = std::min (ext(0), p(0));
@@ -7109,20 +7109,20 @@ axes::update_axis_limits (const std::str
                           const graphics_handle& h)
 {
   if (updating_axis_limits.find (get_handle ().value ())
       != updating_axis_limits.end ())
     return;
 
   Matrix kids = Matrix (1, 1, h.value ());
 
-  double min_val = octave_numeric_limits<double>::Inf ();
-  double max_val = -octave_numeric_limits<double>::Inf ();
-  double min_pos = octave_numeric_limits<double>::Inf ();
-  double max_neg = -octave_numeric_limits<double>::Inf ();
+  double min_val = octave::numeric_limits<double>::Inf ();
+  double max_val = -octave::numeric_limits<double>::Inf ();
+  double min_pos = octave::numeric_limits<double>::Inf ();
+  double max_neg = -octave::numeric_limits<double>::Inf ();
 
   char update_type = 0;
 
   Matrix limits;
   double val;
 
 #define FIX_LIMITS \
   if (limits.numel () == 4) \
@@ -7313,20 +7313,20 @@ axes::update_axis_limits (const std::str
   if ((updating_axis_limits.find (get_handle ().value ())
        != updating_axis_limits.end ())
       || (updating_aspectratios.find (get_handle ().value ())
           != updating_aspectratios.end ()))
     return;
 
   Matrix kids = xproperties.get_children ();
 
-  double min_val = octave_numeric_limits<double>::Inf ();
-  double max_val = -octave_numeric_limits<double>::Inf ();
-  double min_pos = octave_numeric_limits<double>::Inf ();
-  double max_neg = -octave_numeric_limits<double>::Inf ();
+  double min_val = octave::numeric_limits<double>::Inf ();
+  double max_val = -octave::numeric_limits<double>::Inf ();
+  double min_pos = octave::numeric_limits<double>::Inf ();
+  double max_neg = -octave::numeric_limits<double>::Inf ();
 
   char update_type = 0;
 
   Matrix limits;
 
   if (axis_type == "xdata" || axis_type == "xscale"
       || axis_type == "xlimmode" || axis_type == "xliminclude"
       || axis_type == "xlim")
@@ -7537,26 +7537,26 @@ axes::properties::zoom_about_point (cons
                                     bool push_to_zoom_stack)
 {
   // FIXME: Do we need error checking here?
   Matrix xlims = get_xlim ().matrix_value ();
   Matrix ylims = get_ylim ().matrix_value ();
 
   // Get children axes limits
   Matrix kids = get_children ();
-  double minx = octave_numeric_limits<double>::Inf ();
-  double maxx = -octave_numeric_limits<double>::Inf ();
-  double min_pos_x = octave_numeric_limits<double>::Inf ();
-  double max_neg_x = -octave_numeric_limits<double>::Inf ();
+  double minx = octave::numeric_limits<double>::Inf ();
+  double maxx = -octave::numeric_limits<double>::Inf ();
+  double min_pos_x = octave::numeric_limits<double>::Inf ();
+  double max_neg_x = -octave::numeric_limits<double>::Inf ();
   get_children_limits (minx, maxx, min_pos_x, max_neg_x, kids, 'x');
 
-  double miny = octave_numeric_limits<double>::Inf ();
-  double maxy = -octave_numeric_limits<double>::Inf ();
-  double min_pos_y = octave_numeric_limits<double>::Inf ();
-  double max_neg_y = -octave_numeric_limits<double>::Inf ();
+  double miny = octave::numeric_limits<double>::Inf ();
+  double maxy = -octave::numeric_limits<double>::Inf ();
+  double min_pos_y = octave::numeric_limits<double>::Inf ();
+  double max_neg_y = -octave::numeric_limits<double>::Inf ();
   get_children_limits (miny, maxy, min_pos_y, max_neg_y, kids, 'y');
 
   xlims = do_zoom (x, factor, xlims, xscale_is ("log"));
   ylims = do_zoom (y, factor, ylims, yscale_is ("log"));
 
   zoom (mode, xlims, ylims, push_to_zoom_stack);
 }
 
@@ -7684,26 +7684,26 @@ axes::properties::translate_view (const 
                                   bool push_to_zoom_stack)
 {
   // FIXME: Do we need error checking here?
   Matrix xlims = get_xlim ().matrix_value ();
   Matrix ylims = get_ylim ().matrix_value ();
 
   // Get children axes limits
   Matrix kids = get_children ();
-  double minx = octave_numeric_limits<double>::Inf ();
-  double maxx = -octave_numeric_limits<double>::Inf ();
-  double min_pos_x = octave_numeric_limits<double>::Inf ();
-  double max_neg_x = -octave_numeric_limits<double>::Inf ();
+  double minx = octave::numeric_limits<double>::Inf ();
+  double maxx = -octave::numeric_limits<double>::Inf ();
+  double min_pos_x = octave::numeric_limits<double>::Inf ();
+  double max_neg_x = -octave::numeric_limits<double>::Inf ();
   get_children_limits (minx, maxx, min_pos_x, max_neg_x, kids, 'x');
 
-  double miny = octave_numeric_limits<double>::Inf ();
-  double maxy = -octave_numeric_limits<double>::Inf ();
-  double min_pos_y = octave_numeric_limits<double>::Inf ();
-  double max_neg_y = -octave_numeric_limits<double>::Inf ();
+  double miny = octave::numeric_limits<double>::Inf ();
+  double maxy = -octave::numeric_limits<double>::Inf ();
+  double min_pos_y = octave::numeric_limits<double>::Inf ();
+  double max_neg_y = -octave::numeric_limits<double>::Inf ();
   get_children_limits (miny, maxy, min_pos_y, max_neg_y, kids, 'y');
 
   xlims = do_translate (x0, x1, xlims, xscale_is ("log"));
   ylims = do_translate (y0, y1, ylims, yscale_is ("log"));
 
   zoom (mode, xlims, ylims, push_to_zoom_stack);
 }
 
@@ -8430,20 +8430,20 @@ void
 hggroup::update_axis_limits (const std::string& axis_type,
                              const graphics_handle& h)
 {
   if (updating_hggroup_limits)
     return;
 
   Matrix kids = Matrix (1, 1, h.value ());
 
-  double min_val = octave_numeric_limits<double>::Inf ();
-  double max_val = -octave_numeric_limits<double>::Inf ();
-  double min_pos = octave_numeric_limits<double>::Inf ();
-  double max_neg = -octave_numeric_limits<double>::Inf ();
+  double min_val = octave::numeric_limits<double>::Inf ();
+  double max_val = -octave::numeric_limits<double>::Inf ();
+  double min_pos = octave::numeric_limits<double>::Inf ();
+  double max_neg = -octave::numeric_limits<double>::Inf ();
 
   Matrix limits;
   double val;
 
   char update_type = 0;
 
   if (axis_type == "xlim" || axis_type == "xliminclude")
     {
@@ -8543,20 +8543,20 @@ hggroup::update_axis_limits (const std::
 void
 hggroup::update_axis_limits (const std::string& axis_type)
 {
   if (updating_hggroup_limits)
     return;
 
   Matrix kids = xproperties.get_children ();
 
-  double min_val = octave_numeric_limits<double>::Inf ();
-  double max_val = -octave_numeric_limits<double>::Inf ();
-  double min_pos = octave_numeric_limits<double>::Inf ();
-  double max_neg = -octave_numeric_limits<double>::Inf ();
+  double min_val = octave::numeric_limits<double>::Inf ();
+  double max_val = -octave::numeric_limits<double>::Inf ();
+  double min_pos = octave::numeric_limits<double>::Inf ();
+  double max_neg = -octave::numeric_limits<double>::Inf ();
 
   char update_type = 0;
 
   if (axis_type == "xlim" || axis_type == "xliminclude")
     {
       get_children_limits (min_val, max_val, min_pos, max_neg, kids, 'x');
 
       update_type = 'x';
@@ -10083,17 +10083,17 @@ Undocumented internal function.\n\
 
 static octave_value
 make_graphics_object (const std::string& go_name,
                       bool integer_figure_handle,
                       const octave_value_list& args)
 {
   octave_value retval;
 
-  double val = octave_numeric_limits<double>::NaN ();
+  double val = octave::numeric_limits<double>::NaN ();
 
   octave_value_list xargs = args.splice (0, 1);
 
   caseless_str p ("parent");
 
   for (int i = 0; i < xargs.length (); i++)
     {
       if (xargs(i).is_string () && p.compare (xargs(i).string_value ()))
@@ -10168,17 +10168,17 @@ Undocumented internal function.\n\
       retval = h.value ();
     }
   else
     {
       bool int_fig_handle = true;
 
       octave_value_list xargs = args.splice (0, 1);
 
-      graphics_handle h = octave_numeric_limits<double>::NaN ();
+      graphics_handle h = octave::numeric_limits<double>::NaN ();
 
       if (xisnan (val))
         {
           caseless_str pname ("integerhandle");
 
           for (int i = 0; i < xargs.length (); i++)
             {
               if (xargs(i).is_string ()
@@ -10422,17 +10422,17 @@ DEFUN (__go_delete__, args, ,
 Undocumented internal function.\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   if (args.length () != 1)
     print_usage ();
 
-  graphics_handle h = octave_numeric_limits<double>::NaN ();
+  graphics_handle h = octave::numeric_limits<double>::NaN ();
 
   const NDArray vals = args(0).xarray_value ("delete: invalid graphics object");
 
   // Check all the handles to delete are valid first,
   // as callbacks might delete one of the handles we later want to delete.
   for (octave_idx_type i = 0; i < vals.numel (); i++)
     {
       h = gh_manager::lookup (vals(i));
@@ -10458,17 +10458,17 @@ Undocumented internal function.\n\
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   std::string mode;
   if (nargin == 2)
     mode = args(1).string_value ();
 
-  graphics_handle h = octave_numeric_limits<double>::NaN ();
+  graphics_handle h = octave::numeric_limits<double>::NaN ();
 
   double val = args(0).xdouble_value ("__go_axes_init__: invalid graphics object");
 
   h = gh_manager::lookup (val);
 
   if (! h.ok ())
     error ("__go_axes_init__: invalid graphics object (= %g)", val);
 
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -1532,17 +1532,17 @@ public:
   }
 
   handle_property& operator = (const graphics_handle& h)
   {
     set (octave_value (h.value ()));
     return *this;
   }
 
-  void invalidate (void) { current_val = octave_numeric_limits<double>::NaN (); }
+  void invalidate (void) { current_val = octave::numeric_limits<double>::NaN (); }
 
   base_property* clone (void) const { return new handle_property (*this); }
 
 protected:
   OCTINTERP_API bool do_set (const octave_value& v);
 
 private:
   graphics_handle current_val;
@@ -4525,27 +4525,27 @@ public:
 
   private:
     void update_position (void)
     {
       Matrix pos = get_data_position ();
       Matrix lim;
 
       lim = Matrix (1, 3, pos(0));
-      lim(2) = (lim(2) <= 0 ? octave_numeric_limits<double>::Inf () : lim(2));
+      lim(2) = (lim(2) <= 0 ? octave::numeric_limits<double>::Inf () : lim(2));
       set_xlim (lim);
 
       lim = Matrix (1, 3, pos(1));
-      lim(2) = (lim(2) <= 0 ? octave_numeric_limits<double>::Inf () : lim(2));
+      lim(2) = (lim(2) <= 0 ? octave::numeric_limits<double>::Inf () : lim(2));
       set_ylim (lim);
 
       if (pos.numel () == 3)
         {
           lim = Matrix (1, 3, pos(2));
-          lim(2) = (lim(2) <= 0 ? octave_numeric_limits<double>::Inf () : lim(2));
+          lim(2) = (lim(2) <= 0 ? octave::numeric_limits<double>::Inf () : lim(2));
           set_zliminclude ("on");
           set_zlim (lim);
         }
       else
         set_zliminclude ("off");
     }
 
     void update_text_extent (void);
diff --git a/libinterp/corefcn/oct-handle.h b/libinterp/corefcn/oct-handle.h
--- a/libinterp/corefcn/oct-handle.h
+++ b/libinterp/corefcn/oct-handle.h
@@ -30,20 +30,20 @@ along with Octave; see the file COPYING.
 
 #include "ov.h"
 
 // ---------------------------------------------------------------------
 
 class octave_handle
 {
 public:
-  octave_handle (void) : val (octave_numeric_limits<double>::NaN ()) { }
+  octave_handle (void) : val (octave::numeric_limits<double>::NaN ()) { }
 
   octave_handle (const octave_value& a)
-    : val (octave_numeric_limits<double>::NaN ())
+    : val (octave::numeric_limits<double>::NaN ())
   {
     if (a.is_empty ())
       ; // do nothing
     else
       {
         try
           {
             val = a.double_value ();
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -2510,17 +2510,17 @@ init_inf_nan (void)
 
   return retval;
 }
 
 textscan::textscan (const std::string& who_arg)
   : who (who_arg), buf (), whitespace_table (), delim_table (),
     delims (), comment_style (), comment_len (0), comment_char (-2),
     buffer_size (0), date_locale (), inf_nan (init_inf_nan ()),
-    empty_value (octave_numeric_limits<double>::NaN ()), exp_chars ("edED"),
+    empty_value (octave::numeric_limits<double>::NaN ()), exp_chars ("edED"),
     header_lines (0), treat_as_empty (), treat_as_empty_len (0),
     whitespace (" \b\t"), eol1 ('\r'), eol2 ('\n'),
     return_on_error (1), collect_output (false),
     multiple_delims_as_one (false), default_exp (true),
     numeric_delim (false), lines (0)
 { }
 
 octave_value
@@ -2894,38 +2894,38 @@ textscan::read_double (delimited_stream&
     is.putback (ch);
 
   // Check for +/- inf and NaN
   if (! valid && width_left >= 3)
     {
       int i = lookahead (is, inf_nan, 3, false);   // false -> case insensitive
       if (i == 0)
         {
-          retval = octave_numeric_limits<double>::Inf ();
+          retval = octave::numeric_limits<double>::Inf ();
           valid = true;
         }
       else if (i == 1)
         {
-          retval = octave_numeric_limits<double>::NaN ();
+          retval = octave::numeric_limits<double>::NaN ();
           valid = true;
         }
     }
 
   // Check for +/- inf and NaN
   if (! valid && width_left >= 3)
     {
       int i = lookahead (is, inf_nan, 3, false);   // false -> case insensitive
       if (i == 0)
         {
-          retval = octave_numeric_limits<double>::Inf ();
+          retval = octave::numeric_limits<double>::Inf ();
           valid = true;
         }
       else if (i == 1)
         {
-          retval = octave_numeric_limits<double>::NaN ();
+          retval = octave::numeric_limits<double>::NaN ();
           valid = true;
         }
     }
 
   if (! valid)
     is.setstate (std::ios::failbit);
   else
     is.setstate (is.rdstate () & ~std::ios::failbit);
@@ -2961,17 +2961,17 @@ textscan::scan_complex (delimited_stream
               char *pos = is.tellg ();
               std::ios::iostate state = is.rdstate ();
 
               is.get ();
               ch2 = is.get ();
               if (ch2 == 'f')
                 {
                   inf = true;
-                  re = (ch == '+') ? octave_numeric_limits<double>::Inf () : -octave_numeric_limits<double>::Inf ();
+                  re = (ch == '+') ? octave::numeric_limits<double>::Inf () : -octave::numeric_limits<double>::Inf ();
                   value = 0;
                 }
               else
                 {
                   is.clear (state);
                   is.seekg (pos);   // reset to position before look-ahead
                 }
             }
@@ -2987,17 +2987,17 @@ textscan::scan_complex (delimited_stream
       char *pos = is.tellg ();
       std::ios::iostate state = is.rdstate ();
       //re = octave_read_value<double> (is);
       re = read_double (is, fmt);
 
       // check for "treat as empty" string
       if (treat_as_empty.numel ()
           && (is.fail () || octave_is_NaN_or_NA (Complex (re))
-              || re == octave_numeric_limits<double>::Inf ()))
+              || re == octave::numeric_limits<double>::Inf ()))
         {
 
           for (int i = 0; i < treat_as_empty.numel (); i++)
             {
               if (ch == treat_as_empty (i).string_value ()[0])
                 {
                   as_empty = true;   // first char matches, so read the lot
                   break;
diff --git a/libinterp/corefcn/quadcc.cc b/libinterp/corefcn/quadcc.cc
--- a/libinterp/corefcn/quadcc.cc
+++ b/libinterp/corefcn/quadcc.cc
@@ -1697,17 +1697,17 @@ Mathematical Software, Vol. 37, Issue 3,
               nans[nnans++] = i;
               iv->fx[i] = 0.0;
             }
         }
       Vinvfx (iv->fx, &(iv->c[idx[3]]), 3);
       Vinvfx (iv->fx, &(iv->c[idx[2]]), 2);
       Vinvfx (iv->fx, &(iv->c[0]), 0);
       for (i = 0; i < nnans; i++)
-        iv->fx[nans[i]] = octave_numeric_limits<double>::NaN ();
+        iv->fx[nans[i]] = octave::numeric_limits<double>::NaN ();
       iv->a = iivals[j];
       iv->b = iivals[j + 1];
       iv->depth = 3;
       iv->rdepth = 1;
       iv->ndiv = 0;
       iv->igral = 2 * h * iv->c[idx[3]] * w;
       nc = 0.0;
       for (i = n[2] + 1; i <= n[3]; i++)
@@ -1817,17 +1817,17 @@ Mathematical Software, Vol. 37, Issue 3,
 
           // Compute the new coefficients.
           Vinvfx (iv->fx, &(iv->c[idx[d]]), d);
           // Downdate any NaNs.
           if (nnans > 0)
             {
               downdate (&(iv->c[idx[d]]), n[d], d, nans, nnans);
               for (i = 0; i < nnans; i++)
-                iv->fx[nans[i]] = octave_numeric_limits<double>::NaN ();
+                iv->fx[nans[i]] = octave::numeric_limits<double>::NaN ();
             }
 
           // Compute the error estimate.
           nc = 0.0;
           for (i = n[d - 1] + 1; i <= n[d]; i++)
             {
               temp = iv->c[idx[d] + i];
               nc += temp * temp;
@@ -1951,17 +1951,17 @@ Mathematical Software, Vol. 37, Issue 3,
                   ivl->fx[i] = 0.0;
                 }
             }
           Vinvfx (ivl->fx, ivl->c, 0);
           if (nnans > 0)
             {
               downdate (ivl->c, n[0], 0, nans, nnans);
               for (i = 0; i < nnans; i++)
-                ivl->fx[nans[i]] = octave_numeric_limits<double>::NaN ();
+                ivl->fx[nans[i]] = octave::numeric_limits<double>::NaN ();
             }
           for (i = 0; i <= n[d]; i++)
             {
               ivl->c[idx[d] + i] = 0.0;
               for (j = i; j <= n[d]; j++)
                 ivl->c[idx[d] + i] += Tleft[i * 33 + j] * iv->c[idx[d] + j];
             }
           ncdiff = 0.0;
@@ -1977,17 +1977,17 @@ Mathematical Software, Vol. 37, Issue 3,
             }
           ncdiff = sqrt (ncdiff);
           ivl->err = ncdiff * h;
           // Check for divergence.
           ivl->ndiv = iv->ndiv + (fabs (iv->c[0]) > 0
                                   && ivl->c[0] / iv->c[0] > 2);
           if (ivl->ndiv > ndiv_max && 2 * ivl->ndiv > ivl->rdepth)
             {
-              igral = gnulib::copysign (octave_numeric_limits<double>::Inf (), igral);
+              igral = gnulib::copysign (octave::numeric_limits<double>::Inf (), igral);
               warning ("quadcc: divergent integral detected");
               break;
             }
 
           // Compute the local integral.
           ivl->igral = h * w * ivl->c[0];
 
           // Generate the interval on the right.
@@ -2042,17 +2042,17 @@ Mathematical Software, Vol. 37, Issue 3,
                   ivr->fx[i] = 0.0;
                 }
             }
           Vinvfx (ivr->fx, ivr->c, 0);
           if (nnans > 0)
             {
               downdate (ivr->c, n[0], 0, nans, nnans);
               for (i = 0; i < nnans; i++)
-                ivr->fx[nans[i]] = octave_numeric_limits<double>::NaN ();
+                ivr->fx[nans[i]] = octave::numeric_limits<double>::NaN ();
             }
           for (i = 0; i <= n[d]; i++)
             {
               ivr->c[idx[d] + i] = 0.0;
               for (j = i; j <= n[d]; j++)
                 ivr->c[idx[d] + i] += Tright[i * 33 + j] * iv->c[idx[d] + j];
             }
           ncdiff = 0.0;
@@ -2068,17 +2068,17 @@ Mathematical Software, Vol. 37, Issue 3,
             }
           ncdiff = sqrt (ncdiff);
           ivr->err = ncdiff * h;
           // Check for divergence.
           ivr->ndiv = iv->ndiv + (fabs (iv->c[0]) > 0
                                   && ivr->c[0] / iv->c[0] > 2);
           if (ivr->ndiv > ndiv_max && 2 * ivr->ndiv > ivr->rdepth)
             {
-              igral = gnulib::copysign (octave_numeric_limits<double>::Inf (), igral);
+              igral = gnulib::copysign (octave::numeric_limits<double>::Inf (), igral);
               warning ("quadcc: divergent integral detected");
               break;
             }
 
           // Compute the local integral.
           ivr->igral = h * w * ivr->c[0];
 
           // Fix-up the heap: we now have one interval on top that we
diff --git a/libinterp/corefcn/sparse-xdiv.cc b/libinterp/corefcn/sparse-xdiv.cc
--- a/libinterp/corefcn/sparse-xdiv.cc
+++ b/libinterp/corefcn/sparse-xdiv.cc
@@ -370,21 +370,21 @@ xdiv (const SparseComplexMatrix& a, cons
 Matrix
 x_el_div (double a, const SparseMatrix& b)
 {
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
   Matrix result;
   if (a == 0.)
-    result = Matrix (nr, nc, octave_numeric_limits<double>::NaN ());
+    result = Matrix (nr, nc, octave::numeric_limits<double>::NaN ());
   else if (a > 0.)
-    result = Matrix (nr, nc, octave_numeric_limits<double>::Inf ());
+    result = Matrix (nr, nc, octave::numeric_limits<double>::Inf ());
   else
-    result = Matrix (nr, nc, -octave_numeric_limits<double>::Inf ());
+    result = Matrix (nr, nc, -octave::numeric_limits<double>::Inf ());
 
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
       {
         octave_quit ();
         result.elem (b.ridx (i), j) = a / b.data (i);
       }
@@ -393,17 +393,17 @@ x_el_div (double a, const SparseMatrix& 
 }
 
 ComplexMatrix
 x_el_div (double a, const SparseComplexMatrix& b)
 {
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
 
-  ComplexMatrix result (nr, nc, Complex (octave_numeric_limits<double>::NaN (), octave_numeric_limits<double>::NaN ()));
+  ComplexMatrix result (nr, nc, Complex (octave::numeric_limits<double>::NaN (), octave::numeric_limits<double>::NaN ()));
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
       {
         octave_quit ();
         result.elem (b.ridx (i), j) = a / b.data (i);
       }
 
diff --git a/libinterp/corefcn/str2double.cc b/libinterp/corefcn/str2double.cc
--- a/libinterp/corefcn/str2double.cc
+++ b/libinterp/corefcn/str2double.cc
@@ -59,17 +59,17 @@ single_num (std::istringstream& is)
   if (std::toupper (c) == 'I')
     {
       // It's infinity.
       is.get ();
       char c1 = is.get ();
       char c2 = is.get ();
       if (std::tolower (c1) == 'n' && std::tolower (c2) == 'f')
         {
-          num = octave_numeric_limits<double>::Inf ();
+          num = octave::numeric_limits<double>::Inf ();
           is.peek (); // May set EOF bit.
         }
       else
         is.setstate (std::ios::failbit); // indicate that read has failed.
     }
   else if (c == 'N')
     {
       // It's NA or NaN
@@ -80,17 +80,17 @@ single_num (std::istringstream& is)
           num = octave_NA;
           is.peek (); // May set EOF bit.
         }
       else
         {
           char c2 = is.get ();
           if (c1 == 'a' && c2 == 'N')
             {
-              num = octave_numeric_limits<double>::NaN ();
+              num = octave::numeric_limits<double>::NaN ();
               is.peek (); // May set EOF bit.
             }
           else
             is.setstate (std::ios::failbit); // indicate that read has failed.
         }
     }
   else
     is >> num;
@@ -270,27 +270,27 @@ str2double1 (const std::string& str_arg)
   //        Example: "1,23.45" is wrong, but passes Octave.
   str.erase (std::remove (str.begin (), str.end(), ','), str.end ());
   std::istringstream is (str);
 
   double num;
   bool i1, i2, s1, s2;
 
   if (is.eof ())
-    val = octave_numeric_limits<double>::NaN ();
+    val = octave::numeric_limits<double>::NaN ();
   else if (! extract_num (is, num, i1, s1))
-    val = octave_numeric_limits<double>::NaN ();
+    val = octave::numeric_limits<double>::NaN ();
   else
     {
       set_component (val, num, i1);
 
       if (! is.eof ())
         {
           if (! extract_num (is, num, i2, s2) || i1 == i2 || ! s2)
-            val = octave_numeric_limits<double>::NaN ();
+            val = octave::numeric_limits<double>::NaN ();
           else
             set_component (val, num, i2);
         }
     }
 
   return val;
 }
 
@@ -344,41 +344,41 @@ risk of using @code{eval} on unknown dat
   if (args.length () != 1)
     print_usage ();
 
   octave_value retval;
 
   if (args(0).is_string ())
     {
       if (args(0).rows () == 0 || args(0).columns () == 0)
-        retval = Matrix (1, 1, octave_numeric_limits<double>::NaN ());
+        retval = Matrix (1, 1, octave::numeric_limits<double>::NaN ());
       else if (args(0).rows () == 1 && args(0).ndims () == 2)
         retval = str2double1 (args(0).string_value ());
       else
         {
           const string_vector sv = args(0).string_vector_value ();
 
           retval = sv.map<Complex> (str2double1);
         }
     }
   else if (args(0).is_cell ())
     {
       const Cell cell = args(0).cell_value ();
 
-      ComplexNDArray output (cell.dims (), octave_numeric_limits<double>::NaN ());
+      ComplexNDArray output (cell.dims (), octave::numeric_limits<double>::NaN ());
 
       for (octave_idx_type i = 0; i < cell.numel (); i++)
         {
           if (cell(i).is_string ())
             output(i) = str2double1 (cell(i).string_value ());
         }
       retval = output;
     }
   else
-    retval = Matrix (1, 1, octave_numeric_limits<double>::NaN ());
+    retval = Matrix (1, 1, octave::numeric_limits<double>::NaN ());
 
   return retval;
 }
 
 /*
 %!assert (str2double ("1"), 1)
 %!assert (str2double ("-.1e-5"), -1e-6)
 %!assert (str2double (char ("1", "2 3", "4i")), [1; NaN; 4i])
diff --git a/libinterp/corefcn/variables.h b/libinterp/corefcn/variables.h
--- a/libinterp/corefcn/variables.h
+++ b/libinterp/corefcn/variables.h
@@ -103,18 +103,18 @@ extern OCTINTERP_API octave_value
 set_internal_variable (int& var, const octave_value_list& args,
                        int nargout, const char *nm,
                        int minval = std::numeric_limits<int>::min (),
                        int maxval = std::numeric_limits<int>::max ());
 
 extern OCTINTERP_API octave_value
 set_internal_variable (double& var, const octave_value_list& args,
                        int nargout, const char *nm,
-                       double minval = -octave_numeric_limits<double>::Inf (),
-                       double maxval = octave_numeric_limits<double>::Inf ());
+                       double minval = -octave::numeric_limits<double>::Inf (),
+                       double maxval = octave::numeric_limits<double>::Inf ());
 
 extern OCTINTERP_API octave_value
 set_internal_variable (std::string& var, const octave_value_list& args,
                        int nargout, const char *nm, bool empty_ok = true);
 
 extern OCTINTERP_API octave_value
 set_internal_variable (std::string& var, const octave_value_list& args,
                        int nargout, const char *nm, const char **choices);
diff --git a/libinterp/dldfcn/__glpk__.cc b/libinterp/dldfcn/__glpk__.cc
--- a/libinterp/dldfcn/__glpk__.cc
+++ b/libinterp/dldfcn/__glpk__.cc
@@ -417,17 +417,17 @@ Undocumented internal function.\n\
 
   // LB argument, default: Free
   Array<int> freeLB (dim_vector (mrowsc, 1));
   for (int i = 0; i < mrowsc; i++)
     {
       if (xisinf (lb[i]))
         {
           freeLB(i) = 1;
-          lb[i] = -octave_numeric_limits<double>::Inf ();
+          lb[i] = -octave::numeric_limits<double>::Inf ();
         }
       else
         freeLB(i) = 0;
     }
 
   // 5th Input. An array of at least length numcols containing the upper
   //            bound on each of the variables.
   Matrix UB = args(4).xmatrix_value ("__glpk__: invalid value of UB");
@@ -438,17 +438,17 @@ Undocumented internal function.\n\
   double *ub = UB.fortran_vec ();
 
   Array<int> freeUB (dim_vector (mrowsc, 1));
   for (int i = 0; i < mrowsc; i++)
     {
       if (xisinf (ub[i]))
         {
           freeUB(i) = 1;
-          ub[i] = octave_numeric_limits<double>::Inf ();
+          ub[i] = octave::numeric_limits<double>::Inf ();
         }
       else
         freeUB(i) = 0;
     }
 
   // 6th Input. A column array containing the sense of each constraint
   //            in the constraint matrix.
   charMatrix CTYPE = args(5).xchar_matrix_value ("__glpk__: invalid value of CTYPE");
diff --git a/libinterp/dldfcn/__init_fltk__.cc b/libinterp/dldfcn/__init_fltk__.cc
--- a/libinterp/dldfcn/__init_fltk__.cc
+++ b/libinterp/dldfcn/__init_fltk__.cc
@@ -1194,17 +1194,17 @@ private:
   {
     pixel2status (gh_manager::get_object (ax), px0, py0, px1, py1);
   }
 
   void pixel2status (graphics_object ax, int px0, int py0,
                      int px1 = -1, int py1 = -1)
   {
     double x0, y0, x1, y1;
-    x0 = y0 = x1 = y1 = octave_numeric_limits<double>::NaN ();
+    x0 = y0 = x1 = y1 = octave::numeric_limits<double>::NaN ();
     std::stringstream cbuf;
     cbuf.precision (4);
     cbuf.width (6);
     pixel2pos (ax, px0, py0, x0, y0);
     cbuf << "[" << x0 << ", " << y0 << "]";
     if (px1 >= 0)
       {
         pixel2pos (ax, px1, py1, x1, y1);
diff --git a/libinterp/dldfcn/__voronoi__.cc b/libinterp/dldfcn/__voronoi__.cc
--- a/libinterp/dldfcn/__voronoi__.cc
+++ b/libinterp/dldfcn/__voronoi__.cc
@@ -239,17 +239,17 @@ Undocumented internal function.\n\
 
   boolMatrix at_inf (nr, 1, false);
 
   // The list of Voronoi vertices.  The first element is always
   // Inf.
   Matrix F (num_voronoi_vertices+1, dim);
 
   for (octave_idx_type d = 0; d < dim; d++)
-    F(0,d) = octave_numeric_limits<double>::Inf ();
+    F(0,d) = octave::numeric_limits<double>::Inf ();
 
   // The cell array of vectors of indices into F that represent the
   // vertices of the Voronoi regions (cells).
 
   Cell C (nr, 1);
 
   // Now loop through the list of vertices again and store the
   // coordinates of the Voronoi vertices and the lists of indices
diff --git a/libinterp/octave.cc b/libinterp/octave.cc
--- a/libinterp/octave.cc
+++ b/libinterp/octave.cc
@@ -804,22 +804,22 @@ octave_initialize_interpreter (int argc,
     maximum_braindamage ();
 
   init_signals ();
 
   octave_ieee_init ();
 
   // The idea here is to force xerbla to be referenced so that we will link to
   // our own version instead of the one provided by the BLAS library.  But
-  // octave_numeric_limits<double>::NaN () should never be -1, so we
+  // octave::numeric_limits<double>::NaN () should never be -1, so we
   // should never actually call xerbla.  FIXME (again!):  If this
   // becomes a constant expression the test might be optimized away and
   // then the reference to the function might also disappear.
 
-  if (octave_numeric_limits<double>::NaN () == -1)
+  if (octave::numeric_limits<double>::NaN () == -1)
     F77_FUNC (xerbla, XERBLA) ("octave", 13 F77_CHAR_ARG_LEN (6));
 
   initialize_error_handlers ();
 
   if (! embedded)
     install_signal_handlers ();
   else
     quit_allowed = false;
diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -258,17 +258,17 @@ extern "C"
   F77_RET_T
   F77_FUNC (xzlange, XZLANGE) (F77_CONST_CHAR_ARG_DECL,
                                const octave_idx_type&, const octave_idx_type&,
                                const Complex*, const octave_idx_type&,
                                double*, double&
                                F77_CHAR_ARG_LEN_DECL);
 }
 
-static const Complex Complex_NaN_result (octave_numeric_limits<double>::NaN (), octave_numeric_limits<double>::NaN ());
+static const Complex Complex_NaN_result (octave::numeric_limits<double>::NaN (), octave::numeric_limits<double>::NaN ());
 
 // Complex Matrix class
 
 ComplexMatrix::ComplexMatrix (const Matrix& a)
   : ComplexNDArray (a)
 {
 }
 
@@ -1121,17 +1121,17 @@ ComplexMatrix::inverse (MatrixType &matt
           else
             mattype.mark_as_unsymmetric ();
         }
 
       if (! mattype.is_hermitian ())
         ret = finverse (mattype, info, rcon, force, calc_cond);
 
       if ((mattype.is_hermitian () || calc_cond) && rcon == 0.)
-        ret = ComplexMatrix (rows (), columns (), Complex (octave_numeric_limits<double>::Inf (), 0.));
+        ret = ComplexMatrix (rows (), columns (), Complex (octave::numeric_limits<double>::Inf (), 0.));
     }
 
   return ret;
 }
 
 ComplexMatrix
 ComplexMatrix::pseudo_inverse (double tol) const
 {
@@ -1670,25 +1670,25 @@ ComplexMatrix::rcond (void) const
 {
   MatrixType mattype (*this);
   return rcond (mattype);
 }
 
 double
 ComplexMatrix::rcond (MatrixType &mattype) const
 {
-  double rcon = octave_numeric_limits<double>::NaN ();
+  double rcon = octave::numeric_limits<double>::NaN ();
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
 
   if (nr == 0 || nc == 0)
-    rcon = octave_numeric_limits<double>::Inf ();
+    rcon = octave::numeric_limits<double>::Inf ();
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Unknown)
         typ = mattype.type (*this);
 
       // Only calculate the condition number for LU/Cholesky
@@ -3142,17 +3142,17 @@ ComplexMatrix::row_min (Array<octave_idx
       for (octave_idx_type i = 0; i < nr; i++)
         {
           bool real_only = row_is_real_only (i);
 
           octave_idx_type idx_j;
 
           Complex tmp_min;
 
-          double abs_min = octave_numeric_limits<double>::NaN ();
+          double abs_min = octave::numeric_limits<double>::NaN ();
 
           for (idx_j = 0; idx_j < nc; idx_j++)
             {
               tmp_min = elem (i, idx_j);
 
               if (! xisnan (tmp_min))
                 {
                   abs_min = real_only ? std::real (tmp_min)
@@ -3217,17 +3217,17 @@ ComplexMatrix::row_max (Array<octave_idx
       for (octave_idx_type i = 0; i < nr; i++)
         {
           bool real_only = row_is_real_only (i);
 
           octave_idx_type idx_j;
 
           Complex tmp_max;
 
-          double abs_max = octave_numeric_limits<double>::NaN ();
+          double abs_max = octave::numeric_limits<double>::NaN ();
 
           for (idx_j = 0; idx_j < nc; idx_j++)
             {
               tmp_max = elem (i, idx_j);
 
               if (! xisnan (tmp_max))
                 {
                   abs_max = real_only ? std::real (tmp_max)
@@ -3292,17 +3292,17 @@ ComplexMatrix::column_min (Array<octave_
       for (octave_idx_type j = 0; j < nc; j++)
         {
           bool real_only = column_is_real_only (j);
 
           octave_idx_type idx_i;
 
           Complex tmp_min;
 
-          double abs_min = octave_numeric_limits<double>::NaN ();
+          double abs_min = octave::numeric_limits<double>::NaN ();
 
           for (idx_i = 0; idx_i < nr; idx_i++)
             {
               tmp_min = elem (idx_i, j);
 
               if (! xisnan (tmp_min))
                 {
                   abs_min = real_only ? std::real (tmp_min)
@@ -3367,17 +3367,17 @@ ComplexMatrix::column_max (Array<octave_
       for (octave_idx_type j = 0; j < nc; j++)
         {
           bool real_only = column_is_real_only (j);
 
           octave_idx_type idx_i;
 
           Complex tmp_max;
 
-          double abs_max = octave_numeric_limits<double>::NaN ();
+          double abs_max = octave::numeric_limits<double>::NaN ();
 
           for (idx_i = 0; idx_i < nr; idx_i++)
             {
               tmp_max = elem (idx_i, j);
 
               if (! xisnan (tmp_max))
                 {
                   abs_max = real_only ? std::real (tmp_max)
diff --git a/liboctave/array/CNDArray.cc b/liboctave/array/CNDArray.cc
--- a/liboctave/array/CNDArray.cc
+++ b/liboctave/array/CNDArray.cc
@@ -663,18 +663,18 @@ ComplexNDArray
 concat (NDArray& ra, ComplexNDArray& rb, const Array<octave_idx_type>& ra_idx)
 {
   ComplexNDArray retval (ra);
   if (rb.numel () > 0)
     retval.insert (rb, ra_idx);
   return retval;
 }
 
-static const Complex Complex_NaN_result (octave_numeric_limits<double>::NaN (),
-                                         octave_numeric_limits<double>::NaN ());
+static const Complex Complex_NaN_result (octave::numeric_limits<double>::NaN (),
+                                         octave::numeric_limits<double>::NaN ());
 
 ComplexNDArray
 ComplexNDArray::max (int dim) const
 {
   return do_mx_minmax_op<Complex> (*this, dim, mx_inline_max);
 }
 
 ComplexNDArray
diff --git a/liboctave/array/CSparse.cc b/liboctave/array/CSparse.cc
--- a/liboctave/array/CSparse.cc
+++ b/liboctave/array/CSparse.cc
@@ -247,17 +247,17 @@ SparseComplexMatrix::is_hermitian (void)
         }
 
       return true;
     }
 
   return false;
 }
 
-static const Complex Complex_NaN_result (octave_numeric_limits<double>::NaN (), octave_numeric_limits<double>::NaN ());
+static const Complex Complex_NaN_result (octave::numeric_limits<double>::NaN (), octave::numeric_limits<double>::NaN ());
 
 SparseComplexMatrix
 SparseComplexMatrix::max (int dim) const
 {
   Array<octave_idx_type> dummy_idx;
   return max (dummy_idx, dim);
 }
 
@@ -285,17 +285,17 @@ SparseComplexMatrix::max (Array<octave_i
 
       if (nr == 0 || nc == 0 || dim >= dv.ndims ())
         return SparseComplexMatrix (nr == 0 ? 0 : 1, nc);
 
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nc; j++)
         {
           Complex tmp_max;
-          double abs_max = octave_numeric_limits<double>::NaN ();
+          double abs_max = octave::numeric_limits<double>::NaN ();
           octave_idx_type idx_j = 0;
           for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
             {
               if (ridx (i) != idx_j)
                 break;
               else
                 idx_j++;
             }
@@ -442,17 +442,17 @@ SparseComplexMatrix::min (Array<octave_i
 
       if (nr == 0 || nc == 0 || dim >= dv.ndims ())
         return SparseComplexMatrix (nr == 0 ? 0 : 1, nc);
 
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nc; j++)
         {
           Complex tmp_min;
-          double abs_min = octave_numeric_limits<double>::NaN ();
+          double abs_min = octave::numeric_limits<double>::NaN ();
           octave_idx_type idx_j = 0;
           for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
             {
               if (ridx (i) != idx_j)
                 break;
               else
                 idx_j++;
             }
@@ -780,17 +780,17 @@ SparseComplexMatrix::dinverse (MatrixTyp
     retval = *this;
 
   // Force make_unique to be called
   Complex *v = retval.data ();
 
   if (calccond)
     {
       double dmax = 0.;
-      double dmin = octave_numeric_limits<double>::Inf ();
+      double dmin = octave::numeric_limits<double>::Inf ();
       for (octave_idx_type i = 0; i < nr; i++)
         {
           double tmp = std::abs (v[i]);
           if (tmp > dmax)
             dmax = tmp;
           if (tmp < dmin)
             dmin = tmp;
         }
@@ -1303,17 +1303,17 @@ SparseComplexMatrix::dsolve (MatrixType 
         for (octave_idx_type j = 0; j < b.cols (); j++)
           for (octave_idx_type k = 0; k < nc; k++)
             for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
               retval(k,j) = b(ridx (i),j) / data (i);
 
       if (calc_cond)
         {
           double dmax = 0.;
-          double dmin = octave_numeric_limits<double>::Inf ();
+          double dmin = octave::numeric_limits<double>::Inf ();
           for (octave_idx_type i = 0; i < nm; i++)
             {
               double tmp = std::abs (data (i));
               if (tmp > dmax)
                 dmax = tmp;
               if (tmp < dmin)
                 dmin = tmp;
             }
@@ -1393,17 +1393,17 @@ SparseComplexMatrix::dsolve (MatrixType 
                     }
                 }
             retval.xcidx (j+1) = ii;
           }
 
       if (calc_cond)
         {
           double dmax = 0.;
-          double dmin = octave_numeric_limits<double>::Inf ();
+          double dmin = octave::numeric_limits<double>::Inf ();
           for (octave_idx_type i = 0; i < nm; i++)
             {
               double tmp = std::abs (data (i));
               if (tmp > dmax)
                 dmax = tmp;
               if (tmp < dmin)
                 dmin = tmp;
             }
@@ -1453,17 +1453,17 @@ SparseComplexMatrix::dsolve (MatrixType 
         for (octave_idx_type j = 0; j < b.cols (); j++)
           for (octave_idx_type k = 0; k < nc; k++)
             for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
               retval(k,j) = b(ridx (i),j) / data (i);
 
       if (calc_cond)
         {
           double dmax = 0.;
-          double dmin = octave_numeric_limits<double>::Inf ();
+          double dmin = octave::numeric_limits<double>::Inf ();
           for (octave_idx_type i = 0; i < nr; i++)
             {
               double tmp = std::abs (data (i));
               if (tmp > dmax)
                 dmax = tmp;
               if (tmp < dmin)
                 dmin = tmp;
             }
@@ -1543,17 +1543,17 @@ SparseComplexMatrix::dsolve (MatrixType 
                     }
                 }
             retval.xcidx (j+1) = ii;
           }
 
       if (calc_cond)
         {
           double dmax = 0.;
-          double dmin = octave_numeric_limits<double>::Inf ();
+          double dmin = octave::numeric_limits<double>::Inf ();
           for (octave_idx_type i = 0; i < nm; i++)
             {
               double tmp = std::abs (data (i));
               if (tmp > dmax)
                 dmax = tmp;
               if (tmp < dmin)
                 dmin = tmp;
             }
diff --git a/liboctave/array/Sparse-C.cc b/liboctave/array/Sparse-C.cc
--- a/liboctave/array/Sparse-C.cc
+++ b/liboctave/array/Sparse-C.cc
@@ -33,17 +33,17 @@ along with Octave; see the file COPYING.
 #include "Sparse.h"
 #include "Sparse.cc"
 
 
 static double
 xabs (const Complex& x)
 {
   return ((xisinf (x.real ()) || xisinf (x.imag ()))
-          ? octave_numeric_limits<double>::Inf () : abs (x));
+          ? octave::numeric_limits<double>::Inf () : abs (x));
 }
 
 
 template <>
 bool
 sparse_ascending_compare<Complex> (const Complex& a, const Complex& b)
 {
   return (xisnan (b) || (xabs (a) < xabs (b))
diff --git a/liboctave/array/dDiagMatrix.cc b/liboctave/array/dDiagMatrix.cc
--- a/liboctave/array/dDiagMatrix.cc
+++ b/liboctave/array/dDiagMatrix.cc
@@ -239,17 +239,17 @@ DiagMatrix::inverse (octave_idx_type &in
     (*current_liboctave_error_handler) ("inverse requires square matrix");
 
   DiagMatrix retval (r, c);
 
   info = 0;
   for (octave_idx_type i = 0; i < len; i++)
     {
       if (elem (i, i) == 0.0)
-        retval.elem (i, i) = octave_numeric_limits<double>::Inf ();
+        retval.elem (i, i) = octave::numeric_limits<double>::Inf ();
       else
         retval.elem (i, i) = 1.0 / elem (i, i);
     }
 
   return retval;
 }
 
 DiagMatrix
diff --git a/liboctave/array/dMatrix.cc b/liboctave/array/dMatrix.cc
--- a/liboctave/array/dMatrix.cc
+++ b/liboctave/array/dMatrix.cc
@@ -811,17 +811,17 @@ Matrix::inverse (MatrixType &mattype, oc
           else
             mattype.mark_as_unsymmetric ();
         }
 
       if (! mattype.is_hermitian ())
         ret = finverse (mattype, info, rcon, force, calc_cond);
 
       if ((mattype.is_hermitian () || calc_cond) && rcon == 0.)
-        ret = Matrix (rows (), columns (), octave_numeric_limits<double>::Inf ());
+        ret = Matrix (rows (), columns (), octave::numeric_limits<double>::Inf ());
     }
 
   return ret;
 }
 
 Matrix
 Matrix::pseudo_inverse (double tol) const
 {
@@ -1347,25 +1347,25 @@ Matrix::rcond (void) const
 {
   MatrixType mattype (*this);
   return rcond (mattype);
 }
 
 double
 Matrix::rcond (MatrixType &mattype) const
 {
-  double rcon = octave_numeric_limits<double>::NaN ();
+  double rcon = octave::numeric_limits<double>::NaN ();
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
 
   if (nr == 0 || nc == 0)
-    rcon = octave_numeric_limits<double>::Inf ();
+    rcon = octave::numeric_limits<double>::Inf ();
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Unknown)
         typ = mattype.type (*this);
 
       // Only calculate the condition number for LU/Cholesky
@@ -2688,17 +2688,17 @@ Matrix::row_min (Array<octave_idx_type>&
     {
       result.resize (nr);
       idx_arg.resize (dim_vector (nr, 1));
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
           octave_idx_type idx_j;
 
-          double tmp_min = octave_numeric_limits<double>::NaN ();
+          double tmp_min = octave::numeric_limits<double>::NaN ();
 
           for (idx_j = 0; idx_j < nc; idx_j++)
             {
               tmp_min = elem (i, idx_j);
 
               if (! xisnan (tmp_min))
                 break;
             }
@@ -2743,17 +2743,17 @@ Matrix::row_max (Array<octave_idx_type>&
     {
       result.resize (nr);
       idx_arg.resize (dim_vector (nr, 1));
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
           octave_idx_type idx_j;
 
-          double tmp_max = octave_numeric_limits<double>::NaN ();
+          double tmp_max = octave::numeric_limits<double>::NaN ();
 
           for (idx_j = 0; idx_j < nc; idx_j++)
             {
               tmp_max = elem (i, idx_j);
 
               if (! xisnan (tmp_max))
                 break;
             }
@@ -2798,17 +2798,17 @@ Matrix::column_min (Array<octave_idx_typ
     {
       result.resize (nc);
       idx_arg.resize (dim_vector (1, nc));
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           octave_idx_type idx_i;
 
-          double tmp_min = octave_numeric_limits<double>::NaN ();
+          double tmp_min = octave::numeric_limits<double>::NaN ();
 
           for (idx_i = 0; idx_i < nr; idx_i++)
             {
               tmp_min = elem (idx_i, j);
 
               if (! xisnan (tmp_min))
                 break;
             }
@@ -2853,17 +2853,17 @@ Matrix::column_max (Array<octave_idx_typ
     {
       result.resize (nc);
       idx_arg.resize (dim_vector (1, nc));
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           octave_idx_type idx_i;
 
-          double tmp_max = octave_numeric_limits<double>::NaN ();
+          double tmp_max = octave::numeric_limits<double>::NaN ();
 
           for (idx_i = 0; idx_i < nr; idx_i++)
             {
               tmp_max = elem (idx_i, j);
 
               if (! xisnan (tmp_max))
                 break;
             }
diff --git a/liboctave/array/dSparse.cc b/liboctave/array/dSparse.cc
--- a/liboctave/array/dSparse.cc
+++ b/liboctave/array/dSparse.cc
@@ -297,17 +297,17 @@ SparseMatrix::max (Array<octave_idx_type
       idx_arg.resize (dim_vector (nr == 0 ? 0 : 1, nc), 0);
 
       if (nr == 0 || nc == 0 || dim >= dv.ndims ())
         return SparseMatrix (nr == 0 ? 0 : 1, nc);
 
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nc; j++)
         {
-          double tmp_max = octave_numeric_limits<double>::NaN ();
+          double tmp_max = octave::numeric_limits<double>::NaN ();
           octave_idx_type idx_j = 0;
           for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
             {
               if (ridx (i) != idx_j)
                 break;
               else
                 idx_j++;
             }
@@ -396,17 +396,17 @@ SparseMatrix::max (Array<octave_idx_type
       octave_idx_type ii = 0;
       result.xcidx (0) = 0;
       result.xcidx (1) = nel;
       for (octave_idx_type j = 0; j < nr; j++)
         {
           if (idx_arg(j) == -1)
             {
               idx_arg(j) = 0;
-              result.xdata (ii) = octave_numeric_limits<double>::NaN ();
+              result.xdata (ii) = octave::numeric_limits<double>::NaN ();
               result.xridx (ii++) = j;
             }
           else
             {
               double tmp = elem (j, idx_arg(j));
               if (tmp != 0.)
                 {
                   result.xdata (ii) = tmp;
@@ -448,17 +448,17 @@ SparseMatrix::min (Array<octave_idx_type
       idx_arg.resize (dim_vector (nr == 0 ? 0 : 1, nc), 0);
 
       if (nr == 0 || nc == 0 || dim >= dv.ndims ())
         return SparseMatrix (nr == 0 ? 0 : 1, nc);
 
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nc; j++)
         {
-          double tmp_min = octave_numeric_limits<double>::NaN ();
+          double tmp_min = octave::numeric_limits<double>::NaN ();
           octave_idx_type idx_j = 0;
           for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
             {
               if (ridx (i) != idx_j)
                 break;
               else
                 idx_j++;
             }
@@ -547,17 +547,17 @@ SparseMatrix::min (Array<octave_idx_type
       octave_idx_type ii = 0;
       result.xcidx (0) = 0;
       result.xcidx (1) = nel;
       for (octave_idx_type j = 0; j < nr; j++)
         {
           if (idx_arg(j) == -1)
             {
               idx_arg(j) = 0;
-              result.xdata (ii) = octave_numeric_limits<double>::NaN ();
+              result.xdata (ii) = octave::numeric_limits<double>::NaN ();
               result.xridx (ii++) = j;
             }
           else
             {
               double tmp = elem (j, idx_arg(j));
               if (tmp != 0.)
                 {
                   result.xdata (ii) = tmp;
@@ -871,17 +871,17 @@ SparseMatrix::dinverse (MatrixType &matt
     retval = *this;
 
   // Force make_unique to be called
   double *v = retval.data ();
 
   if (calccond)
     {
       double dmax = 0.;
-      double dmin = octave_numeric_limits<double>::Inf ();
+      double dmin = octave::numeric_limits<double>::Inf ();
       for (octave_idx_type i = 0; i < nr; i++)
         {
           double tmp = fabs (v[i]);
           if (tmp > dmax)
             dmax = tmp;
           if (tmp < dmin)
             dmin = tmp;
         }
@@ -1385,17 +1385,17 @@ SparseMatrix::dsolve (MatrixType &mattyp
         for (octave_idx_type j = 0; j < b.cols (); j++)
           for (octave_idx_type k = 0; k < nc; k++)
             for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
               retval(k,j) = b(ridx (i),j) / data (i);
 
       if (calc_cond)
         {
           double dmax = 0.;
-          double dmin = octave_numeric_limits<double>::Inf ();
+          double dmin = octave::numeric_limits<double>::Inf ();
           for (octave_idx_type i = 0; i < nm; i++)
             {
               double tmp = fabs (data (i));
               if (tmp > dmax)
                 dmax = tmp;
               if (tmp < dmin)
                 dmin = tmp;
             }
@@ -1474,17 +1474,17 @@ SparseMatrix::dsolve (MatrixType &mattyp
                     }
                 }
             retval.xcidx (j+1) = ii;
           }
 
       if (calc_cond)
         {
           double dmax = 0.;
-          double dmin = octave_numeric_limits<double>::Inf ();
+          double dmin = octave::numeric_limits<double>::Inf ();
           for (octave_idx_type i = 0; i < nm; i++)
             {
               double tmp = fabs (data (i));
               if (tmp > dmax)
                 dmax = tmp;
               if (tmp < dmin)
                 dmin = tmp;
             }
@@ -1533,17 +1533,17 @@ SparseMatrix::dsolve (MatrixType &mattyp
         for (octave_idx_type j = 0; j < b.cols (); j++)
           for (octave_idx_type k = 0; k < nc; k++)
             for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
               retval(k,j) = b(ridx (i),j) / data (i);
 
       if (calc_cond)
         {
           double dmax = 0.;
-          double dmin = octave_numeric_limits<double>::Inf ();
+          double dmin = octave::numeric_limits<double>::Inf ();
           for (octave_idx_type i = 0; i < nm; i++)
             {
               double tmp = fabs (data (i));
               if (tmp > dmax)
                 dmax = tmp;
               if (tmp < dmin)
                 dmin = tmp;
             }
@@ -1622,17 +1622,17 @@ SparseMatrix::dsolve (MatrixType &mattyp
                     }
                 }
             retval.xcidx (j+1) = ii;
           }
 
       if (calc_cond)
         {
           double dmax = 0.;
-          double dmin = octave_numeric_limits<double>::Inf ();
+          double dmin = octave::numeric_limits<double>::Inf ();
           for (octave_idx_type i = 0; i < nm; i++)
             {
               double tmp = fabs (data (i));
               if (tmp > dmax)
                 dmax = tmp;
               if (tmp < dmin)
                 dmin = tmp;
             }
diff --git a/liboctave/array/fCMatrix.cc b/liboctave/array/fCMatrix.cc
--- a/liboctave/array/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -258,18 +258,18 @@ extern "C"
   F77_RET_T
   F77_FUNC (xclange, XCLANGE) (F77_CONST_CHAR_ARG_DECL,
                                const octave_idx_type&, const octave_idx_type&,
                                const FloatComplex*, const octave_idx_type&,
                                float*, float&
                                F77_CHAR_ARG_LEN_DECL);
 }
 
-static const FloatComplex FloatComplex_NaN_result (octave_numeric_limits<float>::NaN (),
-                                                   octave_numeric_limits<float>::NaN ());
+static const FloatComplex FloatComplex_NaN_result (octave::numeric_limits<float>::NaN (),
+                                                   octave::numeric_limits<float>::NaN ());
 
 // FloatComplex Matrix class
 
 FloatComplexMatrix::FloatComplexMatrix (const FloatMatrix& a)
   : FloatComplexNDArray (a)
 {
 }
 
@@ -1125,17 +1125,17 @@ FloatComplexMatrix::inverse (MatrixType 
             mattype.mark_as_unsymmetric ();
         }
 
       if (! mattype.is_hermitian ())
         ret = finverse (mattype, info, rcon, force, calc_cond);
 
       if ((mattype.is_hermitian () || calc_cond) && rcon == 0.)
         ret = FloatComplexMatrix (rows (), columns (),
-                                  FloatComplex (octave_numeric_limits<float>::Inf (), 0.));
+                                  FloatComplex (octave::numeric_limits<float>::Inf (), 0.));
     }
 
   return ret;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::pseudo_inverse (float tol) const
 {
@@ -1666,25 +1666,25 @@ FloatComplexMatrix::rcond (void) const
 {
   MatrixType mattype (*this);
   return rcond (mattype);
 }
 
 float
 FloatComplexMatrix::rcond (MatrixType &mattype) const
 {
-  float rcon = octave_numeric_limits<float>::NaN ();
+  float rcon = octave::numeric_limits<float>::NaN ();
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
 
   if (nr == 0 || nc == 0)
-    rcon = octave_numeric_limits<float>::Inf ();
+    rcon = octave::numeric_limits<float>::Inf ();
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Unknown)
         typ = mattype.type (*this);
 
       // Only calculate the condition number for LU/Cholesky
@@ -3155,17 +3155,17 @@ FloatComplexMatrix::row_min (Array<octav
       for (octave_idx_type i = 0; i < nr; i++)
         {
           bool real_only = row_is_real_only (i);
 
           octave_idx_type idx_j;
 
           FloatComplex tmp_min;
 
-          float abs_min = octave_numeric_limits<float>::NaN ();
+          float abs_min = octave::numeric_limits<float>::NaN ();
 
           for (idx_j = 0; idx_j < nc; idx_j++)
             {
               tmp_min = elem (i, idx_j);
 
               if (! xisnan (tmp_min))
                 {
                   abs_min = real_only ? std::real (tmp_min)
@@ -3230,17 +3230,17 @@ FloatComplexMatrix::row_max (Array<octav
       for (octave_idx_type i = 0; i < nr; i++)
         {
           bool real_only = row_is_real_only (i);
 
           octave_idx_type idx_j;
 
           FloatComplex tmp_max;
 
-          float abs_max = octave_numeric_limits<float>::NaN ();
+          float abs_max = octave::numeric_limits<float>::NaN ();
 
           for (idx_j = 0; idx_j < nc; idx_j++)
             {
               tmp_max = elem (i, idx_j);
 
               if (! xisnan (tmp_max))
                 {
                   abs_max = real_only ? std::real (tmp_max)
@@ -3305,17 +3305,17 @@ FloatComplexMatrix::column_min (Array<oc
       for (octave_idx_type j = 0; j < nc; j++)
         {
           bool real_only = column_is_real_only (j);
 
           octave_idx_type idx_i;
 
           FloatComplex tmp_min;
 
-          float abs_min = octave_numeric_limits<float>::NaN ();
+          float abs_min = octave::numeric_limits<float>::NaN ();
 
           for (idx_i = 0; idx_i < nr; idx_i++)
             {
               tmp_min = elem (idx_i, j);
 
               if (! xisnan (tmp_min))
                 {
                   abs_min = real_only ? std::real (tmp_min)
@@ -3380,17 +3380,17 @@ FloatComplexMatrix::column_max (Array<oc
       for (octave_idx_type j = 0; j < nc; j++)
         {
           bool real_only = column_is_real_only (j);
 
           octave_idx_type idx_i;
 
           FloatComplex tmp_max;
 
-          float abs_max = octave_numeric_limits<float>::NaN ();
+          float abs_max = octave::numeric_limits<float>::NaN ();
 
           for (idx_i = 0; idx_i < nr; idx_i++)
             {
               tmp_max = elem (idx_i, j);
 
               if (! xisnan (tmp_max))
                 {
                   abs_max = real_only ? std::real (tmp_max)
diff --git a/liboctave/array/fCNDArray.cc b/liboctave/array/fCNDArray.cc
--- a/liboctave/array/fCNDArray.cc
+++ b/liboctave/array/fCNDArray.cc
@@ -670,18 +670,18 @@ concat (NDArray& ra, FloatComplexNDArray
         const Array<octave_idx_type>& ra_idx)
 {
   FloatComplexNDArray retval (ra);
   if (rb.numel () > 0)
     retval.insert (rb, ra_idx);
   return retval;
 }
 
-static const FloatComplex FloatComplex_NaN_result (octave_numeric_limits<float>::NaN (),
-                                                   octave_numeric_limits<float>::NaN ());
+static const FloatComplex FloatComplex_NaN_result (octave::numeric_limits<float>::NaN (),
+                                                   octave::numeric_limits<float>::NaN ());
 
 FloatComplexNDArray
 FloatComplexNDArray::max (int dim) const
 {
   return do_mx_minmax_op<FloatComplex> (*this, dim, mx_inline_max);
 }
 
 FloatComplexNDArray
diff --git a/liboctave/array/fDiagMatrix.cc b/liboctave/array/fDiagMatrix.cc
--- a/liboctave/array/fDiagMatrix.cc
+++ b/liboctave/array/fDiagMatrix.cc
@@ -239,17 +239,17 @@ FloatDiagMatrix::inverse (octave_idx_typ
     (*current_liboctave_error_handler) ("inverse requires square matrix");
 
   FloatDiagMatrix retval (r, c);
 
   info = 0;
   for (octave_idx_type i = 0; i < len; i++)
     {
       if (elem (i, i) == 0.0)
-        retval.elem (i, i) = octave_numeric_limits<float>::Inf ();
+        retval.elem (i, i) = octave::numeric_limits<float>::Inf ();
       else
         retval.elem (i, i) = 1.0 / elem (i, i);
     }
 
   return retval;
 }
 
 FloatDiagMatrix
diff --git a/liboctave/array/fMatrix.cc b/liboctave/array/fMatrix.cc
--- a/liboctave/array/fMatrix.cc
+++ b/liboctave/array/fMatrix.cc
@@ -818,17 +818,17 @@ FloatMatrix::inverse (MatrixType &mattyp
           else
             mattype.mark_as_unsymmetric ();
         }
 
       if (! mattype.is_hermitian ())
         ret = finverse (mattype, info, rcon, force, calc_cond);
 
       if ((mattype.is_hermitian () || calc_cond) && rcon == 0.)
-        ret = FloatMatrix (rows (), columns (), octave_numeric_limits<float>::Inf ());
+        ret = FloatMatrix (rows (), columns (), octave::numeric_limits<float>::Inf ());
     }
 
   return ret;
 }
 
 FloatMatrix
 FloatMatrix::pseudo_inverse (float tol) const
 {
@@ -1358,25 +1358,25 @@ FloatMatrix::rcond (void) const
 {
   MatrixType mattype (*this);
   return rcond (mattype);
 }
 
 float
 FloatMatrix::rcond (MatrixType &mattype) const
 {
-  float rcon = octave_numeric_limits<float>::NaN ();
+  float rcon = octave::numeric_limits<float>::NaN ();
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
 
   if (nr == 0 || nc == 0)
-    rcon = octave_numeric_limits<float>::Inf ();
+    rcon = octave::numeric_limits<float>::Inf ();
   else
     {
       volatile int typ = mattype.type ();
 
       if (typ == MatrixType::Unknown)
         typ = mattype.type (*this);
 
       // Only calculate the condition number for LU/Cholesky
@@ -2705,17 +2705,17 @@ FloatMatrix::row_min (Array<octave_idx_t
     {
       result.resize (nr);
       idx_arg.resize (dim_vector (nr, 1));
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
           octave_idx_type idx_j;
 
-          float tmp_min = octave_numeric_limits<float>::NaN ();
+          float tmp_min = octave::numeric_limits<float>::NaN ();
 
           for (idx_j = 0; idx_j < nc; idx_j++)
             {
               tmp_min = elem (i, idx_j);
 
               if (! xisnan (tmp_min))
                 break;
             }
@@ -2760,17 +2760,17 @@ FloatMatrix::row_max (Array<octave_idx_t
     {
       result.resize (nr);
       idx_arg.resize (dim_vector (nr, 1));
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
           octave_idx_type idx_j;
 
-          float tmp_max = octave_numeric_limits<float>::NaN ();
+          float tmp_max = octave::numeric_limits<float>::NaN ();
 
           for (idx_j = 0; idx_j < nc; idx_j++)
             {
               tmp_max = elem (i, idx_j);
 
               if (! xisnan (tmp_max))
                 break;
             }
@@ -2815,17 +2815,17 @@ FloatMatrix::column_min (Array<octave_id
     {
       result.resize (nc);
       idx_arg.resize (dim_vector (1, nc));
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           octave_idx_type idx_i;
 
-          float tmp_min = octave_numeric_limits<float>::NaN ();
+          float tmp_min = octave::numeric_limits<float>::NaN ();
 
           for (idx_i = 0; idx_i < nr; idx_i++)
             {
               tmp_min = elem (idx_i, j);
 
               if (! xisnan (tmp_min))
                 break;
             }
@@ -2870,17 +2870,17 @@ FloatMatrix::column_max (Array<octave_id
     {
       result.resize (nc);
       idx_arg.resize (dim_vector (1, nc));
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           octave_idx_type idx_i;
 
-          float tmp_max = octave_numeric_limits<float>::NaN ();
+          float tmp_max = octave::numeric_limits<float>::NaN ();
 
           for (idx_i = 0; idx_i < nr; idx_i++)
             {
               tmp_max = elem (idx_i, j);
 
               if (! xisnan (tmp_max))
                 break;
             }
diff --git a/liboctave/cruft/Faddeeva/Faddeeva.cc b/liboctave/cruft/Faddeeva/Faddeeva.cc
--- a/liboctave/cruft/Faddeeva/Faddeeva.cc
+++ b/liboctave/cruft/Faddeeva/Faddeeva.cc
@@ -161,18 +161,18 @@
 
 #  include "Faddeeva.hh"
 
 #  include <cfloat>
 #  include <cmath>
 #  include <limits>
 
 // use std::numeric_limits, since 1./0. and 0./0. fail with some compilers (MS)
-#  define Inf octave_numeric_limits<double>::Inf ()
-#  define NaN octave_numeric_limits<double>::NaN ()
+#  define Inf octave::numeric_limits<double>::Inf ()
+#  define NaN octave::numeric_limits<double>::NaN ()
 
 typedef std::complex<double> cmplx;
 
 // Use C-like complex syntax, since the C syntax is more restrictive
 #  define cexp(z) exp(z)
 #  define creal(z) real(z)
 #  define cimag(z) imag(z)
 #  define cpolar(r,t) polar(r,t)
diff --git a/liboctave/numeric/eigs-base.cc b/liboctave/numeric/eigs-base.cc
--- a/liboctave/numeric/eigs-base.cc
+++ b/liboctave/numeric/eigs-base.cc
@@ -436,18 +436,18 @@ LuAminusSigmaB (const SparseMatrix &m, c
 
   for (octave_idx_type j = 0; j < n; j++)
     {
       P[j] = P2[j];
       Q[j] = Q2[j];
     }
 
   // Test condition number of LU decomposition
-  double minU = octave_numeric_limits<double>::NaN ();
-  double maxU = octave_numeric_limits<double>::NaN ();
+  double minU = octave::numeric_limits<double>::NaN ();
+  double maxU = octave::numeric_limits<double>::NaN ();
   for (octave_idx_type j = 0; j < n; j++)
     {
       double d = 0.;
       if (U.xcidx (j+1) > U.xcidx (j)
           && U.xridx (U.xcidx (j+1)-1) == j)
         d = std::abs (U.xdata (U.xcidx (j+1)-1));
 
       if (xisnan (minU) || d < minU)
@@ -512,18 +512,18 @@ LuAminusSigmaB (const Matrix &m, const M
   lu<Matrix> fact (AminusSigmaB);
 
   L = fact.P ().transpose () * fact.L ();
   U = fact.U ();
   for (octave_idx_type j = 0; j < n; j++)
     P[j] = Q[j] = j;
 
   // Test condition number of LU decomposition
-  double minU = octave_numeric_limits<double>::NaN ();
-  double maxU = octave_numeric_limits<double>::NaN ();
+  double minU = octave::numeric_limits<double>::NaN ();
+  double maxU = octave::numeric_limits<double>::NaN ();
   for (octave_idx_type j = 0; j < n; j++)
     {
       double d = std::abs (U.xelem (j,j));
       if (xisnan (minU) || d < minU)
         minU = d;
 
       if (xisnan (maxU) || d > maxU)
         maxU = d;
@@ -600,18 +600,18 @@ LuAminusSigmaB (const SparseComplexMatri
 
   for (octave_idx_type j = 0; j < n; j++)
     {
       P[j] = P2[j];
       Q[j] = Q2[j];
     }
 
   // Test condition number of LU decomposition
-  double minU = octave_numeric_limits<double>::NaN ();
-  double maxU = octave_numeric_limits<double>::NaN ();
+  double minU = octave::numeric_limits<double>::NaN ();
+  double maxU = octave::numeric_limits<double>::NaN ();
   for (octave_idx_type j = 0; j < n; j++)
     {
       double d = 0.;
       if (U.xcidx (j+1) > U.xcidx (j)
           && U.xridx (U.xcidx (j+1)-1) == j)
         d = std::abs (U.xdata (U.xcidx (j+1)-1));
 
       if (xisnan (minU) || d < minU)
@@ -676,18 +676,18 @@ LuAminusSigmaB (const ComplexMatrix &m, 
   lu<ComplexMatrix> fact (AminusSigmaB);
 
   L = fact.P ().transpose () * fact.L ();
   U = fact.U ();
   for (octave_idx_type j = 0; j < n; j++)
     P[j] = Q[j] = j;
 
   // Test condition number of LU decomposition
-  double minU = octave_numeric_limits<double>::NaN ();
-  double maxU = octave_numeric_limits<double>::NaN ();
+  double minU = octave::numeric_limits<double>::NaN ();
+  double maxU = octave::numeric_limits<double>::NaN ();
   for (octave_idx_type j = 0; j < n; j++)
     {
       double d = std::abs (U.xelem (j,j));
       if (xisnan (minU) || d < minU)
         minU = d;
 
       if (xisnan (maxU) || d > maxU)
         maxU = d;
@@ -859,17 +859,17 @@ EigsRealSymmetricMatrix (const M& m, con
             }
 
           // This is a kludge, as ARPACK doesn't give its
           // iteration pointer. But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
           // is a way of obtaining the iteration counter.
           if (ido != 99)
-            workl[iptr(5)-1] = octave_numeric_limits<double>::NaN ();
+            workl[iptr(5)-1] = octave::numeric_limits<double>::NaN ();
         }
 
       if (ido == -1 || ido == 1 || ido == 2)
         {
           if (have_b)
             {
               Matrix mtmp (n,1);
               for (octave_idx_type i = 0; i < n; i++)
@@ -1112,17 +1112,17 @@ EigsRealSymmetricMatrixShift (const M& m
             }
 
           // This is a kludge, as ARPACK doesn't give its
           // iteration pointer. But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
           // is a way of obtaining the iteration counter.
           if (ido != 99)
-            workl[iptr(5)-1] = octave_numeric_limits<double>::NaN ();
+            workl[iptr(5)-1] = octave::numeric_limits<double>::NaN ();
         }
 
       if (ido == -1 || ido == 1 || ido == 2)
         {
           if (have_b)
             {
               if (ido == -1)
                 {
@@ -1385,17 +1385,17 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
             }
 
           // This is a kludge, as ARPACK doesn't give its
           // iteration pointer. But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
           // is a way of obtaining the iteration counter.
           if (ido != 99)
-            workl[iptr(5)-1] = octave_numeric_limits<double>::NaN ();
+            workl[iptr(5)-1] = octave::numeric_limits<double>::NaN ();
         }
 
 
       if (ido == -1 || ido == 1 || ido == 2)
         {
           double *ip2 = workd + iptr(0) - 1;
           ColumnVector x(n);
 
@@ -1654,17 +1654,17 @@ EigsRealNonSymmetricMatrix (const M& m, 
             }
 
           // This is a kludge, as ARPACK doesn't give its
           // iteration pointer. But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
           // is a way of obtaining the iteration counter.
           if (ido != 99)
-            workl[iptr(5)-1] = octave_numeric_limits<double>::NaN ();
+            workl[iptr(5)-1] = octave::numeric_limits<double>::NaN ();
         }
 
       if (ido == -1 || ido == 1 || ido == 2)
         {
           if (have_b)
             {
               Matrix mtmp (n,1);
               for (octave_idx_type i = 0; i < n; i++)
@@ -1956,17 +1956,17 @@ EigsRealNonSymmetricMatrixShift (const M
             }
 
           // This is a kludge, as ARPACK doesn't give its
           // iteration pointer. But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
           // is a way of obtaining the iteration counter.
           if (ido != 99)
-            workl[iptr(5)-1] = octave_numeric_limits<double>::NaN ();
+            workl[iptr(5)-1] = octave::numeric_limits<double>::NaN ();
         }
 
       if (ido == -1 || ido == 1 || ido == 2)
         {
           if (have_b)
             {
               if (ido == -1)
                 {
@@ -2284,17 +2284,17 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
             }
 
           // This is a kludge, as ARPACK doesn't give its
           // iteration pointer. But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
           // is a way of obtaining the iteration counter.
           if (ido != 99)
-            workl[iptr(5)-1] = octave_numeric_limits<double>::NaN ();
+            workl[iptr(5)-1] = octave::numeric_limits<double>::NaN ();
         }
 
       if (ido == -1 || ido == 1 || ido == 2)
         {
           double *ip2 = workd + iptr(0) - 1;
           ColumnVector x(n);
 
           for (octave_idx_type i = 0; i < n; i++)
@@ -2604,17 +2604,17 @@ EigsComplexNonSymmetricMatrix (const M& 
             }
 
           // This is a kludge, as ARPACK doesn't give its
           // iteration pointer. But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
           // is a way of obtaining the iteration counter.
           if (ido != 99)
-            workl[iptr(5)-1] = octave_numeric_limits<double>::NaN ();
+            workl[iptr(5)-1] = octave::numeric_limits<double>::NaN ();
         }
 
       if (ido == -1 || ido == 1 || ido == 2)
         {
           if (have_b)
             {
               ComplexMatrix mtmp (n,1);
               for (octave_idx_type i = 0; i < n; i++)
@@ -2860,17 +2860,17 @@ EigsComplexNonSymmetricMatrixShift (cons
             }
 
           // This is a kludge, as ARPACK doesn't give its
           // iteration pointer. But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
           // is a way of obtaining the iteration counter.
           if (ido != 99)
-            workl[iptr(5)-1] = octave_numeric_limits<double>::NaN ();
+            workl[iptr(5)-1] = octave::numeric_limits<double>::NaN ();
         }
 
       if (ido == -1 || ido == 1 || ido == 2)
         {
           if (have_b)
             {
               if (ido == -1)
                 {
@@ -3145,17 +3145,17 @@ EigsComplexNonSymmetricFunc (EigsComplex
             }
 
           // This is a kludge, as ARPACK doesn't give its
           // iteration pointer. But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
           // is a way of obtaining the iteration counter.
           if (ido != 99)
-            workl[iptr(5)-1] = octave_numeric_limits<double>::NaN ();
+            workl[iptr(5)-1] = octave::numeric_limits<double>::NaN ();
         }
 
       if (ido == -1 || ido == 1 || ido == 2)
         {
           Complex *ip2 = workd + iptr(0) - 1;
           ComplexColumnVector x(n);
 
           for (octave_idx_type i = 0; i < n; i++)
diff --git a/liboctave/numeric/lo-mappers.cc b/liboctave/numeric/lo-mappers.cc
--- a/liboctave/numeric/lo-mappers.cc
+++ b/liboctave/numeric/lo-mappers.cc
@@ -81,17 +81,17 @@ signum (double x)
 {
   double tmp = 0.0;
 
   if (x < 0.0)
     tmp = -1.0;
   else if (x > 0.0)
     tmp = 1.0;
 
-  return xisnan (x) ? octave_numeric_limits<double>::NaN () : tmp;
+  return xisnan (x) ? octave::numeric_limits<double>::NaN () : tmp;
 }
 
 double
 xlog2 (double x)
 {
   return gnulib::log2 (x);
 }
 
@@ -304,17 +304,17 @@ signum (float x)
 {
   float tmp = 0.0;
 
   if (x < 0.0)
     tmp = -1.0;
   else if (x > 0.0)
     tmp = 1.0;
 
-  return xisnan (x) ? octave_numeric_limits<float>::NaN () : tmp;
+  return xisnan (x) ? octave::numeric_limits<float>::NaN () : tmp;
 }
 
 float
 xlog2 (float x)
 {
   return gnulib::log2f (x);
 }
 
diff --git a/liboctave/numeric/lo-mappers.h b/liboctave/numeric/lo-mappers.h
--- a/liboctave/numeric/lo-mappers.h
+++ b/liboctave/numeric/lo-mappers.h
@@ -309,17 +309,17 @@ xmod (T x, T y)
 
 template <typename T>
 T
 xrem (T x, T y)
 {
   T retval;
 
   if (y == 0)
-    retval = octave_numeric_limits<T>::NaN ();
+    retval = octave::numeric_limits<T>::NaN ();
   else
     {
       T q = x / y;
 
       if (X_NINT (y) != y
           && (std::abs ((q - X_NINT (q)) / X_NINT (q))
               < std::numeric_limits<T>::epsilon ()))
         retval = 0;
diff --git a/liboctave/numeric/lo-specfun.cc b/liboctave/numeric/lo-specfun.cc
--- a/liboctave/numeric/lo-specfun.cc
+++ b/liboctave/numeric/lo-specfun.cc
@@ -437,22 +437,22 @@ xgamma (double x)
 {
   double result;
 
   // Special cases for (near) compatibility with Matlab instead of
   // tgamma.  Matlab does not have -0.
 
   if (x == 0)
     result = (xnegative_sign (x)
-              ? -octave_numeric_limits<double>::Inf ()
-              : octave_numeric_limits<double>::Inf ());
+              ? -octave::numeric_limits<double>::Inf ()
+              : octave::numeric_limits<double>::Inf ());
   else if ((x < 0 && D_NINT (x) == x) || xisinf (x))
-    result = octave_numeric_limits<double>::Inf ();
+    result = octave::numeric_limits<double>::Inf ();
   else if (xisnan (x))
-    result = octave_numeric_limits<double>::NaN ();
+    result = octave::numeric_limits<double>::NaN ();
   else
     {
 #if defined (HAVE_TGAMMA)
       result = tgamma (x);
 #else
       F77_XFCN (xdgamma, XDGAMMA, (x, result));
 #endif
     }
@@ -467,17 +467,17 @@ xlgamma (double x)
   return lgamma (x);
 #else
   double result;
   double sgngam;
 
   if (xisnan (x))
     result = x;
   else if ((x <= 0 && D_NINT (x) == x) || xisinf (x))
-    result = octave_numeric_limits<double>::Inf ();
+    result = octave::numeric_limits<double>::Inf ();
   else
     F77_XFCN (dlgams, DLGAMS, (x, result, sgngam));
 
   return result;
 #endif
 }
 
 Complex
@@ -489,17 +489,17 @@ rc_lgamma (double x)
   int sgngam;
   result = lgamma_r (x, &sgngam);
 #else
   double sgngam = 0.0;
 
   if (xisnan (x))
     result = x;
   else if ((x <= 0 && D_NINT (x) == x) || xisinf (x))
-    result = octave_numeric_limits<double>::Inf ();
+    result = octave::numeric_limits<double>::Inf ();
   else
     F77_XFCN (dlgams, DLGAMS, (x, result, sgngam));
 
 #endif
 
   if (sgngam < 0)
     return result + Complex (0., M_PI);
   else
@@ -511,22 +511,22 @@ xgamma (float x)
 {
   float result;
 
   // Special cases for (near) compatibility with Matlab instead of
   // tgamma.  Matlab does not have -0.
 
   if (x == 0)
     result = (xnegative_sign (x)
-              ? -octave_numeric_limits<float>::Inf ()
-              : octave_numeric_limits<float>::Inf ());
+              ? -octave::numeric_limits<float>::Inf ()
+              : octave::numeric_limits<float>::Inf ());
   else if ((x < 0 && D_NINT (x) == x) || xisinf (x))
-    result = octave_numeric_limits<float>::Inf ();
+    result = octave::numeric_limits<float>::Inf ();
   else if (xisnan (x))
-    result = octave_numeric_limits<float>::NaN ();
+    result = octave::numeric_limits<float>::NaN ();
   else
     {
 #if defined (HAVE_TGAMMA)
       result = tgammaf (x);
 #else
       F77_XFCN (xgamma, XGAMMA, (x, result));
 #endif
     }
@@ -541,17 +541,17 @@ xlgamma (float x)
   return lgammaf (x);
 #else
   float result;
   float sgngam;
 
   if (xisnan (x))
     result = x;
   else if ((x <= 0 && D_NINT (x) == x) || xisinf (x))
-    result = octave_numeric_limits<float>::Inf ();
+    result = octave::numeric_limits<float>::Inf ();
   else
     F77_XFCN (algams, ALGAMS, (x, result, sgngam));
 
   return result;
 #endif
 }
 
 FloatComplex
@@ -563,17 +563,17 @@ rc_lgamma (float x)
   int sgngam;
   result = lgammaf_r (x, &sgngam);
 #else
   float sgngam = 0.0f;
 
   if (xisnan (x))
     result = x;
   else if ((x <= 0 && D_NINT (x) == x) || xisinf (x))
-    result = octave_numeric_limits<float>::Inf ();
+    result = octave::numeric_limits<float>::Inf ();
   else
     F77_XFCN (algams, ALGAMS, (x, result, sgngam));
 
 #endif
 
   if (sgngam < 0)
     return result + FloatComplex (0., M_PI);
   else
@@ -837,22 +837,22 @@ zbesh1 (const Complex& z, double alpha, 
 
 static inline Complex
 zbesh2 (const Complex& z, double alpha, int kode, octave_idx_type& ierr);
 
 static inline Complex
 bessel_return_value (const Complex& val, octave_idx_type ierr)
 {
   static const Complex inf_val
-    = Complex (octave_numeric_limits<double>::Inf (),
-               octave_numeric_limits<double>::Inf ());
+    = Complex (octave::numeric_limits<double>::Inf (),
+               octave::numeric_limits<double>::Inf ());
 
   static const Complex nan_val
-    = Complex (octave_numeric_limits<double>::NaN (),
-               octave_numeric_limits<double>::NaN ());
+    = Complex (octave::numeric_limits<double>::NaN (),
+               octave::numeric_limits<double>::NaN ());
 
   Complex retval;
 
   switch (ierr)
     {
     case 0:
     case 3:
       retval = val;
@@ -922,18 +922,18 @@ zbesj (const Complex& z, double alpha, i
 
       if (ierr == 0 || ierr == 3)
         {
           tmp -= sin (M_PI * alpha) * zbesy (z, alpha, kode, ierr);
 
           retval = bessel_return_value (tmp, ierr);
         }
       else
-        retval = Complex (octave_numeric_limits<double>::NaN (),
-                          octave_numeric_limits<double>::NaN ());
+        retval = Complex (octave::numeric_limits<double>::NaN (),
+                          octave::numeric_limits<double>::NaN ());
     }
 
   return retval;
 }
 
 static inline Complex
 zbesy (const Complex& z, double alpha, int kode, octave_idx_type& ierr)
 {
@@ -950,17 +950,17 @@ zbesy (const Complex& z, double alpha, i
 
       double zr = z.real ();
       double zi = z.imag ();
 
       ierr = 0;
 
       if (zr == 0.0 && zi == 0.0)
         {
-          yr = -octave_numeric_limits<double>::Inf ();
+          yr = -octave::numeric_limits<double>::Inf ();
           yi = 0.0;
         }
       else
         {
           F77_FUNC (zbesy, ZBESY) (zr, zi, alpha, 2, 1, &yr, &yi, nz,
                                    &wr, &wi, ierr);
 
           if (kode != 2)
@@ -993,18 +993,18 @@ zbesy (const Complex& z, double alpha, i
 
       if (ierr == 0 || ierr == 3)
         {
           tmp += sin (M_PI * alpha) * zbesj (z, alpha, kode, ierr);
 
           retval = bessel_return_value (tmp, ierr);
         }
       else
-        retval = Complex (octave_numeric_limits<double>::NaN (),
-                          octave_numeric_limits<double>::NaN ());
+        retval = Complex (octave::numeric_limits<double>::NaN (),
+                          octave::numeric_limits<double>::NaN ());
     }
 
   return retval;
 }
 
 static inline Complex
 zbesi (const Complex& z, double alpha, int kode, octave_idx_type& ierr)
 {
@@ -1058,18 +1058,18 @@ zbesi (const Complex& z, double alpha, i
               tmp2 *= exp (-z - std::abs (z.real ()));
             }
 
           tmp += tmp2;
 
           retval = bessel_return_value (tmp, ierr);
         }
       else
-        retval = Complex (octave_numeric_limits<double>::NaN (),
-                          octave_numeric_limits<double>::NaN ());
+        retval = Complex (octave::numeric_limits<double>::NaN (),
+                          octave::numeric_limits<double>::NaN ());
     }
 
   return retval;
 }
 
 static inline Complex
 zbesk (const Complex& z, double alpha, int kode, octave_idx_type& ierr)
 {
@@ -1084,17 +1084,17 @@ zbesk (const Complex& z, double alpha, i
 
       double zr = z.real ();
       double zi = z.imag ();
 
       ierr = 0;
 
       if (zr == 0.0 && zi == 0.0)
         {
-          yr = octave_numeric_limits<double>::Inf ();
+          yr = octave::numeric_limits<double>::Inf ();
           yi = 0.0;
         }
       else
         {
           F77_FUNC (zbesk, ZBESK) (zr, zi, alpha, 2, 1, &yr, &yi, nz, ierr);
 
           if (kode != 2)
             {
@@ -1476,22 +1476,22 @@ cbesh1 (const FloatComplex& z, float alp
 
 static inline FloatComplex
 cbesh2 (const FloatComplex& z, float alpha, int kode, octave_idx_type& ierr);
 
 static inline FloatComplex
 bessel_return_value (const FloatComplex& val, octave_idx_type ierr)
 {
   static const FloatComplex inf_val
-    = FloatComplex (octave_numeric_limits<float>::Inf (),
-                    octave_numeric_limits<float>::Inf ());
+    = FloatComplex (octave::numeric_limits<float>::Inf (),
+                    octave::numeric_limits<float>::Inf ());
 
   static const FloatComplex nan_val
-    = FloatComplex (octave_numeric_limits<float>::NaN (),
-                    octave_numeric_limits<float>::NaN ());
+    = FloatComplex (octave::numeric_limits<float>::NaN (),
+                    octave::numeric_limits<float>::NaN ());
 
   FloatComplex retval;
 
   switch (ierr)
     {
     case 0:
     case 3:
       retval = val;
@@ -1558,18 +1558,18 @@ cbesj (const FloatComplex& z, float alph
       if (ierr == 0 || ierr == 3)
         {
           tmp -= sinf (static_cast<float> (M_PI) * alpha)
                  * cbesy (z, alpha, kode, ierr);
 
           retval = bessel_return_value (tmp, ierr);
         }
       else
-        retval = FloatComplex (octave_numeric_limits<float>::NaN (),
-                               octave_numeric_limits<float>::NaN ());
+        retval = FloatComplex (octave::numeric_limits<float>::NaN (),
+                               octave::numeric_limits<float>::NaN ());
     }
 
   return retval;
 }
 
 static inline FloatComplex
 cbesy (const FloatComplex& z, float alpha, int kode, octave_idx_type& ierr)
 {
@@ -1582,17 +1582,17 @@ cbesy (const FloatComplex& z, float alph
       octave_idx_type nz;
 
       FloatComplex w;
 
       ierr = 0;
 
       if (real (z) == 0.0 && imag (z) == 0.0)
         {
-          y = FloatComplex (-octave_numeric_limits<float>::Inf (), 0.0);
+          y = FloatComplex (-octave::numeric_limits<float>::Inf (), 0.0);
         }
       else
         {
           F77_FUNC (cbesy, CBESY) (z, alpha, 2, 1, &y, nz, &w, ierr);
 
           if (kode != 2)
             {
               float expz = exp (std::abs (imag (z)));
@@ -1624,18 +1624,18 @@ cbesy (const FloatComplex& z, float alph
       if (ierr == 0 || ierr == 3)
         {
           tmp += sinf (static_cast<float> (M_PI) * alpha)
                  * cbesj (z, alpha, kode, ierr);
 
           retval = bessel_return_value (tmp, ierr);
         }
       else
-        retval = FloatComplex (octave_numeric_limits<float>::NaN (),
-                               octave_numeric_limits<float>::NaN ());
+        retval = FloatComplex (octave::numeric_limits<float>::NaN (),
+                               octave::numeric_limits<float>::NaN ());
     }
 
   return retval;
 }
 
 static inline FloatComplex
 cbesi (const FloatComplex& z, float alpha, int kode, octave_idx_type& ierr)
 {
@@ -1678,18 +1678,18 @@ cbesi (const FloatComplex& z, float alph
               tmp2 *= exp (-z - std::abs (z.real ()));
             }
 
           tmp += tmp2;
 
           retval = bessel_return_value (tmp, ierr);
         }
       else
-        retval = FloatComplex (octave_numeric_limits<float>::NaN (),
-                               octave_numeric_limits<float>::NaN ());
+        retval = FloatComplex (octave::numeric_limits<float>::NaN (),
+                               octave::numeric_limits<float>::NaN ());
     }
 
   return retval;
 }
 
 static inline FloatComplex
 cbesk (const FloatComplex& z, float alpha, int kode, octave_idx_type& ierr)
 {
@@ -1700,17 +1700,17 @@ cbesk (const FloatComplex& z, float alph
       FloatComplex y = 0.0;
 
       octave_idx_type nz;
 
       ierr = 0;
 
       if (real (z) == 0.0 && imag (z) == 0.0)
         {
-          y = FloatComplex (octave_numeric_limits<float>::Inf (), 0.0);
+          y = FloatComplex (octave::numeric_limits<float>::Inf (), 0.0);
         }
       else
         {
           F77_FUNC (cbesk, CBESK) (z, alpha, 2, 1, &y, nz, ierr);
 
           if (kode != 2)
             {
               FloatComplex expz = exp (-z);
@@ -3044,19 +3044,19 @@ static double do_erfinv (double x, bool 
     {
       // Tail region.
       const double q = sqrt (-2*gnulib::log (0.5*(1-ax)));
       const double yn = ((((c[0]*q + c[1])*q + c[2])*q + c[3])*q + c[4])*q + c[5];
       const double yd = (((d[0]*q + d[1])*q + d[2])*q + d[3])*q + 1.0;
       y = yn / yd * signum (-x);
     }
   else if (ax == 1.0)
-    return octave_numeric_limits<double>::Inf () * signum (x);
+    return octave::numeric_limits<double>::Inf () * signum (x);
   else
-    return octave_numeric_limits<double>::NaN ();
+    return octave::numeric_limits<double>::NaN ();
 
   if (refine)
     {
       // One iteration of Halley's method gives full precision.
       double u = (erf (y) - x) * spi2 * exp (y*y);
       y -= u / (1 + y*u);
     }
 
@@ -3131,21 +3131,21 @@ static double do_erfcinv (double x, bool
       const double yd = (((d[0]*q + d[1])*q + d[2])*q + d[3])*q + 1.0;
 
       y = yn / yd;
 
       if (x < pbreak_lo)
         y = -y;
     }
   else if (x == 0.0)
-    return octave_numeric_limits<double>::Inf ();
+    return octave::numeric_limits<double>::Inf ();
   else if (x == 2.0)
-    return -octave_numeric_limits<double>::Inf ();
+    return -octave::numeric_limits<double>::Inf ();
   else
-    return octave_numeric_limits<double>::NaN ();
+    return octave::numeric_limits<double>::NaN ();
 
   if (refine)
     {
       // One iteration of Halley's method gives full precision.
       double u = (erf (y) - (1-x)) * spi2 * exp (y*y);
       y -= u / (1 + y*u);
     }
 
@@ -3769,17 +3769,17 @@ psi (const T& z)
 
   const bool is_int = (xfloor (z) == z);
 
   T p = 0;
   if (z <= 0)
     {
       // limits - zeros of the gamma function
       if (is_int)
-        p = -octave_numeric_limits<T>::Inf (); // Matlab returns -Inf for psi (0)
+        p = -octave::numeric_limits<T>::Inf (); // Matlab returns -Inf for psi (0)
       else
         // Abramowitz and Stegun, page 259, eq 6.3.7
         p = psi (1 - z) - (pi / tan (pi * z));
     }
   else if (is_int)
     {
       // Abramowitz and Stegun, page 258, eq 6.3.2
       p = - euler_mascheroni;
@@ -3905,18 +3905,18 @@ psi (const octave_idx_type n, const T z)
       if (n > 1)
         // FIXME: xgamma here is a killer for our precision since it grows
         //        way too fast.
         ans = ans / (pow (-1.0, n + 1) / xgamma (double (n+1)));
       else if (n == 0)
         ans = -ans;
     }
   else if (ierr == 2)
-    ans = - octave_numeric_limits<T>::Inf ();
+    ans = - octave::numeric_limits<T>::Inf ();
   else // we probably never get here
-    ans = octave_numeric_limits<T>::NaN ();
+    ans = octave::numeric_limits<T>::NaN ();
 
   return ans;
 }
 
 // explicit instantiations
 template double psi<double> (const octave_idx_type n, const double z);
 template float  psi<float>  (const octave_idx_type n, const float z);
diff --git a/liboctave/numeric/oct-norm.cc b/liboctave/numeric/oct-norm.cc
--- a/liboctave/numeric/oct-norm.cc
+++ b/liboctave/numeric/oct-norm.cc
@@ -175,35 +175,35 @@ class norm_accumulator_inf
 {
   R max;
 public:
   norm_accumulator_inf () : max (0) {}
   template <typename U>
   void accum (U val)
   {
     if (xisnan (val))
-      max = octave_numeric_limits<R>::NaN ();
+      max = octave::numeric_limits<R>::NaN ();
     else
       max = std::max (max, std::abs (val));
   }
   operator R () { return max; }
 };
 
 // norm accumulator for the -inf pseudonorm (min abs value)
 template <typename R>
 class norm_accumulator_minf
 {
   R min;
 public:
-  norm_accumulator_minf () : min (octave_numeric_limits<R>::Inf ()) {}
+  norm_accumulator_minf () : min (octave::numeric_limits<R>::Inf ()) {}
   template <typename U>
   void accum (U val)
   {
     if (xisnan (val))
-      min = octave_numeric_limits<R>::NaN ();
+      min = octave::numeric_limits<R>::NaN ();
     else
       min = std::min (min, std::abs (val));
   }
   operator R () { return min; }
 };
 
 // norm accumulator for the 0-pseudonorm (hamming distance)
 template <typename R>
diff --git a/liboctave/numeric/oct-rand.cc b/liboctave/numeric/oct-rand.cc
--- a/liboctave/numeric/oct-rand.cc
+++ b/liboctave/numeric/oct-rand.cc
@@ -352,28 +352,28 @@ octave_rand::do_scalar (double a)
           break;
 
         case expon_dist:
           F77_FUNC (dgenexp, DGENEXP) (1.0, retval);
           break;
 
         case poisson_dist:
           if (a < 0.0 || ! xfinite (a))
-            retval = octave_numeric_limits<double>::NaN ();
+            retval = octave::numeric_limits<double>::NaN ();
           else
             {
               // workaround bug in ignpoi, by calling with different Mu
               F77_FUNC (dignpoi, DIGNPOI) (a + 1, retval);
               F77_FUNC (dignpoi, DIGNPOI) (a, retval);
             }
           break;
 
         case gamma_dist:
           if (a <= 0.0 || ! xfinite (a))
-            retval = octave_numeric_limits<double>::NaN ();
+            retval = octave::numeric_limits<double>::NaN ();
           else
             F77_FUNC (dgengam, DGENGAM) (1.0, a, retval);
           break;
 
         default:
           (*current_liboctave_error_handler)
             ("rand: invalid distribution ID = %d", current_distribution);
           break;
@@ -435,28 +435,28 @@ octave_rand::do_float_scalar (float a)
           break;
 
         case expon_dist:
           F77_FUNC (dgenexp, DGENEXP) (1.0, dretval);
           break;
 
         case poisson_dist:
           if (da < 0.0 || ! xfinite (a))
-            dretval = octave_numeric_limits<double>::NaN ();
+            dretval = octave::numeric_limits<double>::NaN ();
           else
             {
               // workaround bug in ignpoi, by calling with different Mu
               F77_FUNC (dignpoi, DIGNPOI) (da + 1, dretval);
               F77_FUNC (dignpoi, DIGNPOI) (da, dretval);
             }
           break;
 
         case gamma_dist:
           if (da <= 0.0 || ! xfinite (a))
-            dretval = octave_numeric_limits<double>::NaN ();
+            dretval = octave::numeric_limits<double>::NaN ();
           else
             F77_FUNC (dgengam, DGENGAM) (1.0, da, dretval);
           break;
 
         default:
           (*current_liboctave_error_handler)
             ("rand: invalid distribution ID = %d", current_distribution);
           break;
@@ -764,17 +764,17 @@ octave_rand::fill (octave_idx_type len, 
       else
         oct_fill_rande (len, v);
       break;
 
     case poisson_dist:
       if (use_old_generators)
         {
           if (a < 0.0 || ! xfinite (a))
-#define RAND_FUNC(x) x = octave_numeric_limits<double>::NaN ();
+#define RAND_FUNC(x) x = octave::numeric_limits<double>::NaN ();
             MAKE_RAND (len);
 #undef RAND_FUNC
           else
             {
               // workaround bug in ignpoi, by calling with different Mu
               double tmp;
               F77_FUNC (dignpoi, DIGNPOI) (a + 1, tmp);
 #define RAND_FUNC(x) F77_FUNC (dignpoi, DIGNPOI) (a, x)
@@ -785,17 +785,17 @@ octave_rand::fill (octave_idx_type len, 
       else
         oct_fill_randp (a, len, v);
       break;
 
     case gamma_dist:
       if (use_old_generators)
         {
           if (a <= 0.0 || ! xfinite (a))
-#define RAND_FUNC(x) x = octave_numeric_limits<double>::NaN ();
+#define RAND_FUNC(x) x = octave::numeric_limits<double>::NaN ();
             MAKE_RAND (len);
 #undef RAND_FUNC
           else
 #define RAND_FUNC(x) F77_FUNC (dgengam, DGENGAM) (1.0, a, x)
             MAKE_RAND (len);
 #undef RAND_FUNC
         }
       else
@@ -854,17 +854,17 @@ octave_rand::fill (octave_idx_type len, 
         oct_fill_float_rande (len, v);
       break;
 
     case poisson_dist:
       if (use_old_generators)
         {
           double da = a;
           if (da < 0.0 || ! xfinite (a))
-#define RAND_FUNC(x) x = octave_numeric_limits<double>::NaN ();
+#define RAND_FUNC(x) x = octave::numeric_limits<double>::NaN ();
             MAKE_RAND (len);
 #undef RAND_FUNC
           else
             {
               // workaround bug in ignpoi, by calling with different Mu
               double tmp;
               F77_FUNC (dignpoi, DIGNPOI) (da + 1, tmp);
 #define RAND_FUNC(x) F77_FUNC (dignpoi, DIGNPOI) (da, x)
@@ -876,17 +876,17 @@ octave_rand::fill (octave_idx_type len, 
         oct_fill_float_randp (a, len, v);
       break;
 
     case gamma_dist:
       if (use_old_generators)
         {
           double da = a;
           if (da <= 0.0 || ! xfinite (a))
-#define RAND_FUNC(x) x = octave_numeric_limits<double>::NaN ();
+#define RAND_FUNC(x) x = octave::numeric_limits<double>::NaN ();
             MAKE_RAND (len);
 #undef RAND_FUNC
           else
 #define RAND_FUNC(x) F77_FUNC (dgengam, DGENGAM) (1.0, da, x)
             MAKE_RAND (len);
 #undef RAND_FUNC
         }
       else
diff --git a/liboctave/numeric/oct-rand.h b/liboctave/numeric/oct-rand.h
--- a/liboctave/numeric/oct-rand.h
+++ b/liboctave/numeric/oct-rand.h
@@ -45,17 +45,17 @@ public:
 
   ~octave_rand (void) { }
 
   static bool instance_ok (void);
 
   // Return the current seed.
   static double seed (void)
   {
-    return instance_ok () ? instance->do_seed () : octave_numeric_limits<double>::NaN ();
+    return instance_ok () ? instance->do_seed () : octave::numeric_limits<double>::NaN ();
   }
 
   // Set the seed.
   static void seed (double s)
   {
     if (instance_ok ())
       instance->do_seed (s);
   }
@@ -130,23 +130,23 @@ public:
   {
     if (instance_ok ())
       instance->do_gamma_distribution ();
   }
 
   // Return the next number from the sequence.
   static double scalar (double a = 1.0)
   {
-    return instance_ok () ? instance->do_scalar (a) : octave_numeric_limits<double>::NaN ();
+    return instance_ok () ? instance->do_scalar (a) : octave::numeric_limits<double>::NaN ();
   }
 
   // Return the next number from the sequence.
   static float float_scalar (float a = 1.0)
   {
-    return instance_ok () ? instance->do_float_scalar (a) : octave_numeric_limits<float>::NaN ();
+    return instance_ok () ? instance->do_float_scalar (a) : octave::numeric_limits<float>::NaN ();
   }
 
   // Return an array of numbers from the sequence.
   static Array<double> vector (octave_idx_type n, double a = 1.0)
   {
     return instance_ok () ? instance->do_vector (n, a) : Array<double> ();
   }
 
diff --git a/liboctave/numeric/oct-spparms.cc b/liboctave/numeric/oct-spparms.cc
--- a/liboctave/numeric/oct-spparms.cc
+++ b/liboctave/numeric/oct-spparms.cc
@@ -89,17 +89,17 @@ bool
 octave_sparse_params::set_key (const std::string& key, const double& val)
 {
   return instance_ok () ? instance->do_set_key (key, val) : false;
 }
 
 double
 octave_sparse_params::get_key (const std::string& key)
 {
-  return instance_ok () ? instance->do_get_key (key) : octave_numeric_limits<double>::NaN ();
+  return instance_ok () ? instance->do_get_key (key) : octave::numeric_limits<double>::NaN ();
 }
 
 double
 octave_sparse_params::get_bandden (void)
 {
   return instance_ok () ? instance->do_get_bandden () : 0.0;
 }
 
@@ -204,17 +204,17 @@ double
 octave_sparse_params::do_get_key (const std::string& key)
 {
   for (int i = 0; i < OCTAVE_SPARSE_CONTROLS_SIZE; i++)
     {
       if (keys (i) == key)
         return params(i);
     }
 
-  return octave_numeric_limits<double>::NaN ();
+  return octave::numeric_limits<double>::NaN ();
 }
 
 void
 octave_sparse_params::do_print_info (std::ostream& os,
                                      const std::string& prefix) const
 {
   for (int i = 0; i < OCTAVE_SPARSE_CONTROLS_SIZE; i++)
     os << prefix << keys(i) << ": " << params(i) << "\n";
diff --git a/liboctave/numeric/randgamma.cc b/liboctave/numeric/randgamma.cc
--- a/liboctave/numeric/randgamma.cc
+++ b/liboctave/numeric/randgamma.cc
@@ -98,17 +98,17 @@ oct_fill_randg (double a, octave_idx_typ
   /* If a < 1, start by generating gamma (1+a) */
   const double d =  (a < 1. ? 1.+a : a) - 1./3.;
   const double c = 1./sqrt (9.*d);
 
   /* Handle invalid cases */
   if (a <= 0 || INFINITE(a))
     {
       for (i=0; i < n; i++)
-        r[i] = octave_numeric_limits<double>::NaN ();
+        r[i] = octave::numeric_limits<double>::NaN ();
       return;
     }
 
   for (i=0; i < n; i++)
     {
       double x, xsq, v, u;
     restart:
       x = RNOR;
@@ -153,17 +153,17 @@ oct_fill_float_randg (float a, octave_id
   /* If a < 1, start by generating gamma(1+a) */
   const float d =  (a < 1. ? 1.+a : a) - 1./3.;
   const float c = 1./sqrt (9.*d);
 
   /* Handle invalid cases */
   if (a <= 0 || INFINITE(a))
     {
       for (i=0; i < n; i++)
-        r[i] = octave_numeric_limits<float>::NaN ();
+        r[i] = octave::numeric_limits<float>::NaN ();
       return;
     }
 
   for (i=0; i < n; i++)
     {
       float x, xsq, v, u;
     frestart:
       x = RNOR;
diff --git a/liboctave/numeric/randpoisson.cc b/liboctave/numeric/randpoisson.cc
--- a/liboctave/numeric/randpoisson.cc
+++ b/liboctave/numeric/randpoisson.cc
@@ -478,17 +478,17 @@ poisson_rejection_float (double lambda, 
 /* Generate a set of poisson numbers with the same distribution */
 void
 oct_fill_randp (double L, octave_idx_type n, double *p)
 {
   octave_idx_type i;
   if (L < 0.0 || INFINITE(L))
     {
       for (i=0; i<n; i++)
-        p[i] = octave_numeric_limits<double>::NaN ();
+        p[i] = octave::numeric_limits<double>::NaN ();
     }
   else if (L <= 10.0)
     {
       poisson_cdf_lookup (L, p, n);
     }
   else if (L <= 1e8)
     {
       for (i=0; i<n; i++)
@@ -507,17 +507,17 @@ oct_fill_randp (double L, octave_idx_typ
     }
 }
 
 /* Generate one poisson variate */
 double
 oct_randp (double L)
 {
   double ret;
-  if (L < 0.0) ret = octave_numeric_limits<double>::NaN ();
+  if (L < 0.0) ret = octave::numeric_limits<double>::NaN ();
   else if (L <= 12.0)
     {
       /* From Press, et al. Numerical recipes */
       double g = exp (-L);
       int em = -1;
       double t = 1.0;
       do
         {
@@ -530,17 +530,17 @@ oct_randp (double L)
     {
       /* numerical recipes */
       poisson_rejection (L, &ret, 1);
     }
   else if (INFINITE(L))
     {
       /* FIXME: R uses NaN, but the normal approximation suggests that
        * limit should be Inf.  Which is correct? */
-      ret = octave_numeric_limits<double>::NaN ();
+      ret = octave::numeric_limits<double>::NaN ();
     }
   else
     {
       /* normal approximation: from Phys. Rev. D (1994) v50 p1284 */
       ret = floor (RNOR*sqrt (L) + L + 0.5);
       if (ret < 0.0) ret = 0.0; /* will probably never happen */
     }
   return ret;
@@ -550,17 +550,17 @@ oct_randp (double L)
 void
 oct_fill_float_randp (float FL, octave_idx_type n, float *p)
 {
   double L = FL;
   octave_idx_type i;
   if (L < 0.0 || INFINITE(L))
     {
       for (i=0; i<n; i++)
-        p[i] = octave_numeric_limits<double>::NaN ();
+        p[i] = octave::numeric_limits<double>::NaN ();
     }
   else if (L <= 10.0)
     {
       poisson_cdf_lookup_float (L, p, n);
     }
   else if (L <= 1e8)
     {
       for (i=0; i<n; i++)
@@ -580,17 +580,17 @@ oct_fill_float_randp (float FL, octave_i
 }
 
 /* Generate one poisson variate */
 float
 oct_float_randp (float FL)
 {
   double L = FL;
   float ret;
-  if (L < 0.0) ret = octave_numeric_limits<float>::NaN ();
+  if (L < 0.0) ret = octave::numeric_limits<float>::NaN ();
   else if (L <= 12.0)
     {
       /* From Press, et al. Numerical recipes */
       double g = exp (-L);
       int em = -1;
       double t = 1.0;
       do
         {
@@ -603,17 +603,17 @@ oct_float_randp (float FL)
     {
       /* numerical recipes */
       poisson_rejection_float (L, &ret, 1);
     }
   else if (INFINITE(L))
     {
       /* FIXME: R uses NaN, but the normal approximation suggests that
        * limit should be Inf. Which is correct? */
-      ret = octave_numeric_limits<float>::NaN ();
+      ret = octave::numeric_limits<float>::NaN ();
     }
   else
     {
       /* normal approximation: from Phys. Rev. D (1994) v50 p1284 */
       ret = floor (RNOR*sqrt (L) + L + 0.5);
       if (ret < 0.0) ret = 0.0; /* will probably never happen */
     }
   return ret;
diff --git a/liboctave/util/lo-ieee.h b/liboctave/util/lo-ieee.h
--- a/liboctave/util/lo-ieee.h
+++ b/liboctave/util/lo-ieee.h
@@ -112,35 +112,39 @@ extern OCTAVE_API int __lo_ieee_float_si
                           __lo_ieee_float_is_NA (x) : __lo_ieee_is_NA (x))
 #define lo_ieee_is_NaN_or_NA(x) (sizeof (x) == sizeof (float) ? \
                           __lo_ieee_float_is_NaN_or_NA (x) : __lo_ieee_is_NaN_or_NA (x))
 #define lo_ieee_signbit(x) (sizeof (x) == sizeof (float) ? \
                           __lo_ieee_float_signbit (x) : __lo_ieee_signbit (x))
 
 #ifdef __cplusplus
 
-template <typename T>
-struct octave_numeric_limits
-{
-  static T NA (void) { return static_cast<T> (0); }
-  static T NaN (void) { return static_cast<T> (0); }
-  static T Inf (void) { return static_cast<T> (0); }
-};
-
-template <>
-struct octave_numeric_limits<double>
+namespace
+octave
 {
-  static double NA (void) { return octave_NA; }
-  static double NaN (void) { return octave_NaN; }
-  static double Inf (void) { return octave_Inf; }
-};
+  template <typename T>
+  struct numeric_limits
+  {
+    static T NA (void) { return static_cast<T> (0); }
+    static T NaN (void) { return static_cast<T> (0); }
+    static T Inf (void) { return static_cast<T> (0); }
+  };
 
-template <>
-struct octave_numeric_limits<float>
-{
-  static float NA (void) { return octave_Float_NA; }
-  static float NaN (void) { return octave_Float_NaN; }
-  static float Inf (void) { return octave_Float_Inf; }
-};
+  template <>
+  struct numeric_limits<double>
+  {
+    static double NA (void) { return octave_NA; }
+    static double NaN (void) { return octave_NaN; }
+    static double Inf (void) { return octave_Inf; }
+  };
+
+  template <>
+  struct numeric_limits<float>
+  {
+    static float NA (void) { return octave_Float_NA; }
+    static float NaN (void) { return octave_Float_NaN; }
+    static float Inf (void) { return octave_Float_Inf; }
+  };
+}
 
 #endif
 
 #endif
diff --git a/liboctave/util/lo-utils.cc b/liboctave/util/lo-utils.cc
--- a/liboctave/util/lo-utils.cc
+++ b/liboctave/util/lo-utils.cc
@@ -236,17 +236,17 @@ read_inf_nan_na (std::istream& is, char 
         char c1 = is.get ();
         if (c1 == 'a' || c1 == 'A')
           {
             char c2 = is.get ();
             if (c2 == 'n' || c2 == 'N')
               val = std::numeric_limits<T>::quiet_NaN ();
             else
               {
-                val = octave_numeric_limits<T>::NA ();
+                val = octave::numeric_limits<T>::NA ();
                 if (c2 != std::istream::traits_type::eof ())
                   is.putback (c2);
               }
           }
         else
           is.setstate (std::ios::failbit);
       }
       break;
